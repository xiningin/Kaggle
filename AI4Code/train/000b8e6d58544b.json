{"cell_type":{"7b0aa087":"code","ccccc589":"code","a85175b5":"code","555f5f27":"code","7a6bbec2":"code","5d2dabac":"code","bdf7a223":"code","5edcba3e":"code","9223ef29":"code","1ac24796":"code","43068fd9":"code","a3dc22ba":"code","e3db7c8d":"code","61d7a91e":"code","28b45b9e":"code","a9c417c9":"code","da264aa9":"code","182e41f5":"code","84ababa9":"code","68d93762":"code","499b3c2d":"code","79bc14f8":"code","b2d19d2c":"code","ff5a2408":"code","4963f1a0":"code","0c6bc671":"code","e3f03d49":"code","63e6ca7f":"code","1bbd5274":"code","495d2d3d":"code","5287437b":"markdown","e8672233":"markdown","8d9993e9":"markdown","e2ecb075":"markdown","da3ade31":"markdown","79c70491":"markdown","bcac7fbd":"markdown","85833e52":"markdown","2e2ac098":"markdown","2cbd8134":"markdown","15dc1d2b":"markdown","6220c531":"markdown"},"source":{"7b0aa087":"GAUSSIAN_NOISE = 0.05\n# number of validation images to use\nVALID_IMG_COUNT = 1500\n# number of images per category to keep \nTRAIN_IMAGES_PER_CATEGORY = 500 \nBASE_MODEL='InceptionV3' # ['VGG16', 'RESNET52', 'InceptionV3', 'Xception', 'DenseNet169', 'DenseNet121']\nIMG_SIZE = (299, 299) # [(224, 224), (384, 384), (512, 512), (640, 640)]\nBATCH_SIZE = 64 # [1, 8, 16, 24]\nDROPOUT = 0.5\nDENSE_COUNT = 256\nLEARN_RATE = 3e-4\nEPOCHS = 30\nRGB_FLIP = 1 # should rgb be flipped when rendering images","ccccc589":"import os\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom skimage.io import imread\nimport matplotlib.pyplot as plt\nfrom skimage.segmentation import mark_boundaries\nfrom skimage.util import montage\nmontage_rgb = lambda x: np.stack([montage(x[:, :, :, i]) for i in range(x.shape[3])], -1)\nbase_dir = '..\/input'\ntrain_image_dir = os.path.join(base_dir, 'train')\ntest_image_dir = os.path.join(base_dir, 'test')\nimport gc; gc.enable() # memory is tight\nname_label_dict = {\n0:  \"Nucleoplasm\", \n1:  \"Nuclear membrane\",   \n2:  \"Nucleoli\",   \n3:  \"Nucleoli fibrillar center\" ,  \n4:  \"Nuclear speckles\"   ,\n5:  \"Nuclear bodies\"   ,\n6:  \"Endoplasmic reticulum\",   \n7:  \"Golgi apparatus\"   ,\n8:  \"Peroxisomes\"   ,\n9:  \"Endosomes\"   ,\n10:  \"Lysosomes\"   ,\n11:  \"Intermediate filaments\",   \n12:  \"Actin filaments\"   ,\n13:  \"Focal adhesion sites\",   \n14:  \"Microtubules\"   ,\n15:  \"Microtubule ends\",   \n16:  \"Cytokinetic bridge\",   \n17:  \"Mitotic spindle\"   ,\n18:  \"Microtubule organizing center\" ,  \n19:  \"Centrosome\"   ,\n20:  \"Lipid droplets\",   \n21:  \"Plasma membrane\",   \n22:  \"Cell junctions\"  , \n23:  \"Mitochondria\"   ,\n24:  \"Aggresome\"   ,\n25:  \"Cytosol\",\n26:  \"Cytoplasmic bodies\",   \n27:  \"Rods & rings\" \n}","a85175b5":"image_df = pd.read_csv(os.path.join('..\/input\/',\n                                 'train.csv'))\nprint(image_df.shape[0], 'masks found')\nprint(image_df['Id'].value_counts().shape[0])\n# just use green for now\nimage_df['path'] = image_df['Id'].map(lambda x: os.path.join(train_image_dir, '{}.rgb'.format(x)))\nimage_df['target_list'] = image_df['Target'].map(lambda x: [int(a) for a in x.split(' ')])\nimage_df.head()","555f5f27":"from itertools import chain\nfrom collections import Counter\nall_labels = list(chain.from_iterable(image_df['target_list'].values))\nc_val = Counter(all_labels)\nn_keys = c_val.keys()\nmax_idx = max(n_keys)\nfig, ax1 = plt.subplots(1,1, figsize = (10, 5))\nax1.bar(n_keys, [c_val[k] for k in n_keys])\nax1.set_xticks(range(max_idx))\nax1.set_xticklabels([name_label_dict[k] for k in range(max_idx)], rotation=90)\nfor k,v in c_val.items():\n    print(name_label_dict[k], 'count:', v)","7a6bbec2":"# create a categorical vector\nimage_df['target_vec'] = image_df['target_list'].map(lambda ck: [i in ck for i in range(max_idx+1)])\nimage_df.sample(3)","5d2dabac":"from sklearn.model_selection import train_test_split\nraw_train_df, valid_df = train_test_split(image_df, \n                 test_size = 0.3, \n                  # hack to make stratification work                  \n                 stratify = image_df['Target'].map(lambda x: x[:3] if '27' not in x else '0'))\nprint(raw_train_df.shape[0], 'training masks')\nprint(valid_df.shape[0], 'validation masks')","bdf7a223":"# keep labels with more then 50 objects\nout_df_list = []\nfor k,v in c_val.items():\n    if v>100:\n        keep_rows = raw_train_df['target_list'].map(lambda x: k in x)\n        out_df_list += [raw_train_df[keep_rows].sample(TRAIN_IMAGES_PER_CATEGORY, \n                                                       replace=True)]\ntrain_df = pd.concat(out_df_list, ignore_index=True)\nprint(train_df.shape[0])\ntrain_df.sample(3)","5edcba3e":"fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (10, 5))\ntrain_sum_vec = np.sum(np.stack(train_df['target_vec'].values, 0), 0)\nvalid_sum_vec = np.sum(np.stack(valid_df['target_vec'].values, 0), 0)\nax1.bar(n_keys, [train_sum_vec[k] for k in n_keys])\nax1.set_title('Training Distribution')\nax2.bar(n_keys, [valid_sum_vec[k] for k in n_keys])\nax2.set_title('Validation Distribution')","9223ef29":"from keras.preprocessing.image import ImageDataGenerator\nif BASE_MODEL=='VGG16':\n    from keras.applications.vgg16 import VGG16 as PTModel, preprocess_input\nelif BASE_MODEL=='RESNET52':\n    from keras.applications.resnet50 import ResNet50 as PTModel, preprocess_input\nelif BASE_MODEL=='InceptionV3':\n    from keras.applications.inception_v3 import InceptionV3 as PTModel, preprocess_input\nelif BASE_MODEL=='Xception':\n    from keras.applications.xception import Xception as PTModel, preprocess_input\nelif BASE_MODEL=='DenseNet169': \n    from keras.applications.densenet import DenseNet169 as PTModel, preprocess_input\nelif BASE_MODEL=='DenseNet121':\n    from keras.applications.densenet import DenseNet121 as PTModel, preprocess_input\nelse:\n    raise ValueError('Unknown model: {}'.format(BASE_MODEL))","1ac24796":"try:\n    # keras 2.2\n    import keras_preprocessing.image as KPImage\nexcept:\n    # keras 2.1\n    import keras.preprocessing.image as KPImage\n    \nfrom PIL import Image\nclass rgb_pil():\n    @staticmethod\n    def open(in_path):\n        if '.rgb' in in_path:\n            r_img = np.array(Image.open(in_path.replace('.rgb', '_red.png'))).astype(np.float32)\n            g_img = np.array(Image.open(in_path.replace('.rgb', '_green.png'))).astype(np.float32)\n            y_img = np.array(Image.open(in_path.replace('.rgb', '_yellow.png'))).astype(np.float32)\n            b_img = Image.open(in_path.replace('.rgb', '_blue.png'))\n            \n            rgb_arr = np.stack([r_img\/2+y_img\/2, g_img\/2+y_img\/2, b_img], -1).clip(0, 255).astype(np.uint8)\n            return Image.fromarray(rgb_arr)\n        else:\n            return Image.open(in_path)\n    fromarray = Image.fromarray\nKPImage.pil_image = rgb_pil","43068fd9":"from keras.preprocessing.image import ImageDataGenerator\ndg_args = dict(featurewise_center = False, \n                  samplewise_center = False,\n                  rotation_range = 45, \n                  width_shift_range = 0.1, \n                  height_shift_range = 0.1, \n                  shear_range = 0.01,\n                  zoom_range = [0.9, 1.25],  \n                  brightness_range = [0.75, 1.25],\n                  horizontal_flip = True, \n                  vertical_flip = True,\n                  fill_mode = 'reflect',\n                   data_format = 'channels_last',\n              preprocessing_function = preprocess_input)\n\nvalid_args = dict(fill_mode = 'reflect',\n                   data_format = 'channels_last',\n                  preprocessing_function = preprocess_input)\n\ncore_idg = ImageDataGenerator(**dg_args)\nvalid_idg = ImageDataGenerator(**valid_args)","a3dc22ba":"def flow_from_dataframe(img_data_gen, in_df, path_col, y_col, **dflow_args):\n    base_dir = os.path.dirname(in_df[path_col].values[0])\n    print('## Ignore next message from keras, values are replaced anyways')\n    df_gen = img_data_gen.flow_from_directory(base_dir, \n                                     class_mode = 'sparse',\n                                    **dflow_args)\n    df_gen.filenames = in_df[path_col].values\n    df_gen.classes = np.stack(in_df[y_col].values)\n    df_gen.samples = in_df.shape[0]\n    df_gen.n = in_df.shape[0]\n    df_gen._set_index_array()\n    df_gen.directory = '' # since we have the full path\n    print('Reinserting dataframe: {} images'.format(in_df.shape[0]))\n    return df_gen","e3db7c8d":"train_gen = flow_from_dataframe(core_idg, train_df, \n                             path_col = 'path',\n                            y_col = 'target_vec', \n                            target_size = IMG_SIZE,\n                             color_mode = 'rgb',\n                            batch_size = BATCH_SIZE)\n\n# used a fixed dataset for evaluating the algorithm\nvalid_x, valid_y = next(flow_from_dataframe(valid_idg, \n                               valid_df, \n                             path_col = 'path',\n                            y_col = 'target_vec', \n                            target_size = IMG_SIZE,\n                             color_mode = 'rgb',\n                            batch_size = VALID_IMG_COUNT)) # one big batch\nprint(valid_x.shape, valid_y.shape)","61d7a91e":"t_x, t_y = next(train_gen)\nprint('x', t_x.shape, t_x.dtype, t_x.min(), t_x.max())\nprint('y', t_y.shape, t_y.dtype, t_y.min(), t_y.max())\nfig, (ax1) = plt.subplots(1, 1, figsize = (10, 10))\nax1.imshow(montage_rgb((t_x-t_x.min())\/(t_x.max()-t_x.min()))[:, :, ::RGB_FLIP])\nax1.set_title('images')","28b45b9e":"fig, (m_axs) = plt.subplots(4, 4, figsize = (20, 20))\nfor i, c_ax in enumerate(m_axs.flatten()):\n    c_ax.imshow(((t_x[i]-t_x.min())\/(t_x.max()-t_x.min()))[:, ::RGB_FLIP])\n    c_title = '\\n'.join([name_label_dict[j] for j, v in enumerate(t_y[i]) if v>0.5])\n    c_ax.set_title(c_title)\n    c_ax.axis('off')","a9c417c9":"base_pretrained_model = PTModel(input_shape =  t_x.shape[1:], \n                              include_top = False, weights = 'imagenet')\nbase_pretrained_model.trainable = False","da264aa9":"from keras import models, layers\nfrom keras.optimizers import Adam\nimg_in = layers.Input(t_x.shape[1:], name='Image_RGB_In')\nimg_noise = layers.GaussianNoise(GAUSSIAN_NOISE)(img_in)\npt_features = base_pretrained_model(img_noise)\npt_depth = base_pretrained_model.get_output_shape_at(0)[-1]\nbn_features = layers.BatchNormalization()(pt_features)\nfeature_dropout = layers.SpatialDropout2D(DROPOUT)(bn_features)\ngmp_dr = layers.GlobalAvgPool2D()(bn_features)\ndr_steps = layers.Dropout(DROPOUT)(layers.Dense(DENSE_COUNT, activation = 'relu')(gmp_dr))\nout_layer = layers.Dense(t_y.shape[1], activation = 'sigmoid')(dr_steps)\n\nprotein_model = models.Model(inputs = [img_in], outputs = [out_layer], name = 'full_model')\n\nprotein_model.compile(optimizer = Adam(lr=LEARN_RATE), \n                   loss = 'binary_crossentropy',\n                   metrics = ['binary_accuracy'])\n\nprotein_model.summary()","182e41f5":"from keras.callbacks import ModelCheckpoint, LearningRateScheduler, EarlyStopping, ReduceLROnPlateau\nweight_path=\"{}_weights.best.hdf5\".format('boat_detector')\n\ncheckpoint = ModelCheckpoint(weight_path, monitor='val_loss', verbose=1, \n                             save_best_only=True, mode='min', save_weights_only = True)\n\nreduceLROnPlat = ReduceLROnPlateau(monitor='val_loss', factor=0.8, patience=10, verbose=1, mode='auto', epsilon=0.0001, cooldown=5, min_lr=0.0001)\nearly = EarlyStopping(monitor=\"val_loss\", \n                      mode=\"min\", \n                      patience=15) # probably needs to be more patient, but kaggle time is limited\ncallbacks_list = [checkpoint, early, reduceLROnPlat]","84ababa9":"from IPython.display import clear_output\ntrain_gen.batch_size = BATCH_SIZE\nfit_results = protein_model.fit_generator(train_gen, \n                            steps_per_epoch = train_gen.samples\/\/BATCH_SIZE,\n                      validation_data = (valid_x, valid_y), \n                      epochs = EPOCHS, \n                      callbacks = callbacks_list,\n                      workers = 3)\nclear_output()","68d93762":"fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (20, 10))\nax1.plot(fit_results.history['loss'], label='Training')\nax1.plot(fit_results.history['val_loss'], label='Validation')\nax1.legend()\nax1.set_title('Loss')\nax2.plot(fit_results.history['binary_accuracy'], label='Training')\nax2.plot(fit_results.history['val_binary_accuracy'], label='Validation')\nax2.legend()\nax2.set_title('Binary Accuracy')\nax2.set_ylim(0, 1)","499b3c2d":"protein_model.load_weights(weight_path)\nprotein_model.save('full_protein_model.h5')","79bc14f8":"for k, v in zip(protein_model.metrics_names, \n        protein_model.evaluate(valid_x, valid_y)):\n    if k!='loss':\n        print('{:40s}:\\t{:2.1f}%'.format(k, 100*v))","b2d19d2c":"t_x, t_y = next(train_gen)\nt_yp = protein_model.predict(t_x)\nfig, (m_axs) = plt.subplots(4, 4, figsize = (20, 20))\nfor i, c_ax in enumerate(m_axs.flatten()):\n    c_ax.imshow(((t_x[i]-t_x.min())\/(t_x.max()-t_x.min()))[:, ::RGB_FLIP])\n    c_title = '\\n'.join(['{}: Pred: {:2.1f}%'.format(name_label_dict[j], 100*t_yp[i, j]) \n                         for j, v in enumerate(t_y[i]) if v>0.5])\n    c_ax.set_title(c_title)\n    c_ax.axis('off')","ff5a2408":"test_paths = os.listdir(test_image_dir)\nprint(len(test_paths), 'test images found')\nsubmission_df = pd.read_csv('..\/input\/sample_submission.csv')\nsubmission_df['path'] = submission_df['Id'].map(lambda x: \n                                                      os.path.join(test_image_dir, '{}.rgb'.format(x)))\nsubmission_df.sample(3)","4963f1a0":"test_gen = flow_from_dataframe(valid_idg, \n                               submission_df, \n                             path_col = 'path',\n                            y_col = 'Predicted', \n                            target_size = IMG_SIZE,\n                             color_mode = 'rgb',\n                            batch_size = BATCH_SIZE, \n                              shuffle = False)","0c6bc671":"t_x, _ = next(test_gen)\nfig, (m_axs) = plt.subplots(4, 4, figsize = (20, 20))\nfor i, c_ax in enumerate(m_axs.flatten()):\n    c_ax.imshow(((t_x[i]-t_x.min())\/(t_x.max()-t_x.min()))[:, ::RGB_FLIP])\n    c_title = '\\n'.join(['{}: Pred: {:2.1f}%'.format(name_label_dict[j], 100*v)\n                         for j, v in enumerate(t_y[i]) if v>0.25])\n    c_ax.set_title(c_title)\n    c_ax.axis('off')\nfig.savefig('labeled_predictions.png')","e3f03d49":"BATCH_SIZE = BATCH_SIZE*2 # we can use larger batches for inference\ntest_gen = flow_from_dataframe(valid_idg, \n                               submission_df, \n                             path_col = 'path',\n                            y_col = 'Id', \n                            target_size = IMG_SIZE,\n                             color_mode = 'rgb',\n                            batch_size = BATCH_SIZE, \n                              shuffle = False)","63e6ca7f":"from tqdm import tqdm_notebook\nall_scores = dict()\nfor _, (t_x, t_names) in zip(tqdm_notebook(range(test_gen.n\/\/BATCH_SIZE+1)),\n                            test_gen):\n    t_y = protein_model.predict(t_x)\n    for c_id, c_score in zip(t_names, t_y):\n        all_scores[c_id] = ' '.join([str(i) for i,s in enumerate(c_score) if s>0.25])","1bbd5274":"submission_df['Predicted'] = submission_df['Id'].map(lambda x: all_scores.get(x, '0'))\nsubmission_df['Predicted'].value_counts()[:20]","495d2d3d":"out_df = submission_df[['Id', 'Predicted']]\nout_df.to_csv('submission.csv', index=False)\nout_df.head(20)","5287437b":"# Show the Scores\nHere we see the scores and we have to decide about a cut-off for counting an image as ship or not. We can be lazy and pick 0.5 but some more rigorous cross-validation would definitely improve this process.","e8672233":"### Balancing Training Classes\nWe balance out the training classes a bit more by sampling (or oversampling) a fixed number with each category so we have a better balance when training. The approach is not perfect but serves as a good starting point for this problem.\n","8d9993e9":"## Model Parameters\nWe might want to adjust these later (or do some hyperparameter optimizations). It is slightly easier to keep track of parallel notebooks with different parameters if they are all at the beginning in a clear (machine readable format, see Kaggling with Kaggle (https:\/\/www.kaggle.com\/kmader\/kaggling-with-kaggle).","e2ecb075":"# Run the test data\nWe use the sample_submission file as the basis for loading and running the images.","da3ade31":"# Augment Data","79c70491":"# Split into training and validation groups\nWe stratify by the number of boats appearing so we have nice balances in each set","bcac7fbd":"# Build a Model\nWe build the pre-trained top model and then use a global-max-pooling (we are trying to detect any ship in the image and thus max is better suited than averaging (which would tend to favor larger ships to smaller ones). ","85833e52":"# Setup Test Data Generator\nWe use the same generator as before to read and preprocess images","2e2ac098":"# Overview\nHere we use a pretrained model and transfer learning to try and identify the different types of proteins present in the image.\n\n## Beyond\nThe model currently just uses all 3 channels and includes all labels although some are exceedingly rare, better image usage and stratification would definitely help","2cbd8134":"## Very dark magic\nKeras reads single images and so we have to hack it to get it to read 3 images as one color image. Please do not try this at home. This will definitely break!","15dc1d2b":"## Setup the Subsequent Layers\nHere we setup the rest of the model which we will actually be training","6220c531":"# Prepare Submission\nProcess all images (batchwise) and keep the score at the end"}}