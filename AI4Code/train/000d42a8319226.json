{"cell_type":{"557003fb":"code","62f1ad9b":"code","cb0a3148":"code","5ec5e05b":"code","e7b675b0":"code","e09285e0":"code","eda9a5b4":"code","b8251d2c":"code","4941c9de":"code","121fa1ce":"code","9eaa00c6":"code","c75333db":"code","63c2fab6":"code","779e61b4":"code","cc140c88":"code","b6359efc":"code","318397bc":"code","59050387":"code","858860ff":"code","08154108":"code","fcb62345":"code","024c42fa":"code","aa102114":"code","3598d069":"code","7ae5bba2":"code","6cd27d75":"markdown","bcd78cb1":"markdown","1e395fbd":"markdown","2b0a1d5b":"markdown","7621da1c":"markdown","cb5ee839":"markdown","90cd07b1":"markdown","332be211":"markdown","d4cc28c0":"markdown","27fb11c5":"markdown"},"source":{"557003fb":"import gc\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport scipy\nfrom scipy.sparse.linalg import svds\nfrom tqdm import tqdm\nimport re\nimport xml\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity","62f1ad9b":"questions =  pd.read_csv(\"..\/input\/questions.csv\")\nprofessionals = pd.read_csv(\"..\/input\/professionals.csv\")\nanswers = pd.read_csv(\"..\/input\/answers.csv\")","cb0a3148":"professionals.head()","5ec5e05b":"prof_ans = pd.merge(professionals, answers, how = 'left' ,\n                    left_on = 'professionals_id', right_on = 'answers_author_id')\nprof_ans_q = pd.merge(prof_ans, questions, how = 'left' ,\n                      left_on = 'answers_question_id', right_on = 'questions_id')","e7b675b0":"prof_ans_q[\"eventStrength\"] = 1","e09285e0":"prof_ans_q = prof_ans_q[['professionals_id','questions_id','eventStrength']]","eda9a5b4":"prof_ans_q.questions_id = prof_ans_q.questions_id.fillna('NoQ')","b8251d2c":"professionals_questions_full_df = prof_ans_q \\\n                    .groupby(['professionals_id', 'questions_id'])['eventStrength'].sum().reset_index() ","4941c9de":"professionals_questions_full_df = pd.DataFrame(professionals_questions_full_df)","121fa1ce":"professionals_questions_full_df.head()","9eaa00c6":"#Creating a sparse pivot table with professionals in rows and questions in columns\nprofessionals_questions_pivot_matrix_df = professionals_questions_full_df.pivot(index='professionals_id', \n                                                          columns='questions_id', \n                                                          values='eventStrength').fillna(0)\n\n# Transform the professionals-questions dataframe into a matrix\nprofessionals_questions_pivot_matrix = professionals_questions_pivot_matrix_df.as_matrix()\n\nprofessionals_id = list(professionals_questions_pivot_matrix_df.index)\n\n# Print the first 5 rows of the professionals-questions matrix\nprofessionals_questions_pivot_matrix[:5]","c75333db":"professionals_questions_pivot_matrix_df.head()","63c2fab6":"# Performs matrix factorization of the original donor-project matrix\n# Here we set k = 20, which is the number of factors we are going to get\n# In the definition of SVD, an original matrix A is approxmated as a product A \u2248 U\u03a3V \n# where U and V have orthonormal columns, and \u03a3 is non-negative diagonal.\nU, sigma, Vt = svds(professionals_questions_pivot_matrix, k = 20)\nsigma = np.diag(sigma)","779e61b4":"# Reconstruct the matrix by multiplying its factors\nall_professionals_predicted_ratings = np.dot(np.dot(U, sigma), Vt) \n\n#Converting the reconstructed matrix back to a Pandas dataframe\ncf_preds_df = pd.DataFrame(all_professionals_predicted_ratings, \n                           columns = professionals_questions_pivot_matrix_df.columns,\n                          index = professionals_id ).transpose()\ncf_preds_df.head()","cc140c88":"class CFRecommender:\n    \n    MODEL_NAME = 'Collaborative Filtering'\n    \n    def __init__(self, cf_predictions_df, questions_df=None):\n        self.cf_predictions_df = cf_predictions_df\n        self.questions_df = questions_df\n        \n    def get_model_name(self):\n        return self.MODEL_NAME\n        \n    def recommend_projects(self, professionals_id, questions_to_ignore=[], topn=10):\n        # Get and sort the donor's predictions\n        sorted_donor_predictions = self.cf_predictions_df[professionals_id].sort_values(ascending=False) \\\n                                    .reset_index().rename(columns={professionals_id: 'recStrength'})\n\n        # Recommend the highest predicted projects that the donor hasn't donated to\n        recommendations_df = sorted_donor_predictions[~sorted_donor_predictions['questions_id'].isin(questions_to_ignore)] \\\n                               .sort_values('recStrength', ascending = False) \\\n                               .head(topn)\n        \n        recommendations_df = recommendations_df.merge(self.questions_df, how = 'left', \n                                                          left_on = 'questions_id', \n                                                          right_on = 'questions_id')\n\n\n        return recommendations_df","b6359efc":"professional1 = '9ced4ce7519049c0944147afb75a8ce3'","318397bc":"cfr_model = CFRecommender(cf_preds_df, questions)\nrecommended = cfr_model.recommend_projects(professional1)","59050387":"len(recommended)","858860ff":"professionals_questions = pd.merge(professionals, answers, \n                                   how = 'left' ,\n                                   left_on = 'professionals_id', \n                                   right_on = 'answers_author_id')","08154108":"#Function to get all questions answered by a professional\ndef get_questions(professional):\n    questions = professionals_questions[professionals_questions.professionals_id == professional].answers_question_id\n    questions = pd.DataFrame(questions).rename(index=str, columns={\"answers_question_id\": \"question_id\"})\n    return(questions) ","fcb62345":"questions_all = get_questions(professional1)","024c42fa":"len(set(recommended.questions_id).intersection(questions_all.question_id))","aa102114":"professional2 ='0c673e046d824ec0ad0ebe012a0673e4'","3598d069":"recommended = cfr_model.recommend_projects(professional2)","7ae5bba2":"len(set(recommended.questions_id).intersection(questions_all.question_id))","6cd27d75":"# Build the Collaborative Filtering Model","bcd78cb1":"We will build a **model-based Collaborative Filtering (CF) Recommender**. In this approach, models are developed using machine learning algorithms to recommend questions to professionals. There are many model-based CF algorithms, here we adopt a latent factor model, which compresses professional-donor matrix into a low-dimensional representation in terms of latent factors. A reduced presentation could be utilized for either professional-based or question-based neighborhood searching algorithms to find recommendations. Here we a use popular latent factor model named Singular Value Decomposition (SVD).","1e395fbd":"# Questions answered by a professional","2b0a1d5b":"Now we will use SVD to get latent factors. After the factorization, we will try to reconstruct the original matrix by multiplying its factors. The resulting matrix is not sparse any more. It is the generated predictions for questions the professional have not yet answered to, which we will exploit for recommendations.","7621da1c":"# Hit rate calculation -  Scenario 1","cb5ee839":"We will first get the `professional-question matrix` and print the first five rows.","90cd07b1":"# Scenario -2","332be211":"# Singular Value Decomposition (SVD)","d4cc28c0":"Now we are ready to compresses professional-question matrix into a low-dimensional representation in terms of latent factors.","27fb11c5":"# Create the professional question matrix"}}