{"cell_type":{"0b66280b":"code","7f81821a":"code","46329b3c":"code","a1265d02":"code","118cd02c":"code","95722fd2":"code","eb9aa0df":"code","eba375cc":"code","15bd051c":"code","2fab9dbc":"code","b1e095de":"code","cdf1e02c":"code","7e9e47f1":"code","18425812":"code","287f8f1b":"code","bd650330":"code","1806f136":"code","49e259ab":"code","fa50d9b2":"code","b289ca70":"code","0a7026b5":"code","f280f69d":"markdown","393d3c0f":"markdown","42a67b06":"markdown","5866956d":"markdown","c65d6c72":"markdown","a607e335":"markdown","86d7648c":"markdown","8d996785":"markdown","7a1ee188":"markdown","34457700":"markdown","a10db9e1":"markdown","8f7edc29":"markdown","214d1cf7":"markdown","96b9c492":"markdown","52daee23":"markdown","255d8558":"markdown","72934658":"markdown","f277892a":"markdown","24fc7073":"markdown"},"source":{"0b66280b":"%config Completer.use_jedi = False","7f81821a":"%matplotlib inline\n!pip show tensorflow\n!wget -cq https:\/\/ti.arc.nasa.gov\/c\/5 -O naza.zip\n!unzip -qqo naza.zip -d battery_data","46329b3c":"import datetime\nimport numpy as np\nimport pandas as pd\nfrom scipy.io import loadmat\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn import metrics\nimport matplotlib.pyplot as plt\nimport seaborn as sns","a1265d02":"def load_data(battery):\n  mat = loadmat('battery_data\/' + battery + '.mat')\n  print('Total data in dataset: ', len(mat[battery][0, 0]['cycle'][0]))\n  counter = 0\n  dataset = []\n  capacity_data = []\n  \n  for i in range(len(mat[battery][0, 0]['cycle'][0])):\n    row = mat[battery][0, 0]['cycle'][0, i]\n    if row['type'][0] == 'discharge':\n      ambient_temperature = row['ambient_temperature'][0][0]\n      date_time = datetime.datetime(int(row['time'][0][0]),\n                               int(row['time'][0][1]),\n                               int(row['time'][0][2]),\n                               int(row['time'][0][3]),\n                               int(row['time'][0][4])) + datetime.timedelta(seconds=int(row['time'][0][5]))\n      data = row['data']\n      capacity = data[0][0]['Capacity'][0][0]\n      for j in range(len(data[0][0]['Voltage_measured'][0])):\n        voltage_measured = data[0][0]['Voltage_measured'][0][j]\n        current_measured = data[0][0]['Current_measured'][0][j]\n        temperature_measured = data[0][0]['Temperature_measured'][0][j]\n        current_load = data[0][0]['Current_load'][0][j]\n        voltage_load = data[0][0]['Voltage_load'][0][j]\n        time = data[0][0]['Time'][0][j]\n        dataset.append([counter + 1, ambient_temperature, date_time, capacity,\n                        voltage_measured, current_measured,\n                        temperature_measured, current_load,\n                        voltage_load, time])\n      capacity_data.append([counter + 1, ambient_temperature, date_time, capacity])\n      counter = counter + 1\n  print(dataset[0])\n  return [pd.DataFrame(data=dataset,\n                       columns=['cycle', 'ambient_temperature', 'datetime',\n                                'capacity', 'voltage_measured',\n                                'current_measured', 'temperature_measured',\n                                'current_load', 'voltage_load', 'time']),\n          pd.DataFrame(data=capacity_data,\n                       columns=['cycle', 'ambient_temperature', 'datetime',\n                                'capacity'])]\ndataset, capacity = load_data('B0005')\npd.set_option('display.max_columns', 10)\nprint(dataset.head())\ndataset.describe()","118cd02c":"plot_df = capacity.loc[(capacity['cycle']>=1),['cycle','capacity']]\nsns.set_style(\"darkgrid\")\nplt.figure(figsize=(12, 8))\nplt.plot(plot_df['cycle'], plot_df['capacity'])\n#Draw threshold\nplt.plot([0.,len(capacity)], [1.4, 1.4])\nplt.ylabel('Capacity')\n# make x-axis ticks legible\nadf = plt.gca().get_xaxis().get_major_formatter()\nplt.xlabel('cycle')\nplt.title('Discharge B0005')","95722fd2":"attrib=['cycle', 'datetime', 'capacity']\ndis_ele = capacity[attrib]\nC = dis_ele['capacity'][0]\nfor i in range(len(dis_ele)):\n    dis_ele['SoH']=(dis_ele['capacity'])\/C\nprint(dis_ele.head(5))","eb9aa0df":"plot_df = dis_ele.loc[(dis_ele['cycle']>=1),['cycle','SoH']]\nsns.set_style(\"white\")\nplt.figure(figsize=(8, 5))\nplt.plot(plot_df['cycle'], plot_df['SoH'])\n#Draw threshold\nplt.plot([0.,len(capacity)], [0.70, 0.70])\nplt.ylabel('SOH')\n# make x-axis ticks legible\nadf = plt.gca().get_xaxis().get_major_formatter()\nplt.xlabel('cycle')\nplt.title('Discharge B0005')","eba375cc":"C = dataset['capacity'][0]\nsoh = []\nfor i in range(len(dataset)):\n  soh.append([dataset['capacity'][i] \/ C])\nsoh = pd.DataFrame(data=soh, columns=['SoH'])\n\nattribs=['capacity', 'voltage_measured', 'current_measured',\n         'temperature_measured', 'current_load', 'voltage_load', 'time']\ntrain_dataset = dataset[attribs]\nsc = MinMaxScaler(feature_range=(0,1))\ntrain_dataset = sc.fit_transform(train_dataset)\nprint(train_dataset.shape)\nprint(soh.shape)","15bd051c":"import tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense\nfrom tensorflow.keras.layers import Dropout\nfrom tensorflow.keras.layers import Flatten\nfrom tensorflow.keras.layers import LSTM\nfrom tensorflow.keras.optimizers import Adam","2fab9dbc":"model = Sequential()\nmodel.add(Dense(8, activation='relu', input_dim=train_dataset.shape[1]))\nmodel.add(Dense(8, activation='relu'))\nmodel.add(Dense(8, activation='relu'))\nmodel.add(Dropout(rate=0.25))\nmodel.add(Dense(1))\nmodel.summary()\nmodel.compile(optimizer=Adam(beta_1=0.9, beta_2=0.999, epsilon=1e-08), loss='mean_absolute_error')","b1e095de":"model.fit(x=train_dataset, y=soh.to_numpy(), batch_size=25, epochs=50)","cdf1e02c":"dataset_val, capacity_val = load_data('B0006')\nattrib=['cycle', 'datetime', 'capacity']\ndis_ele = capacity_val[attrib]\nC = dis_ele['capacity'][0]\nfor i in range(len(dis_ele)):\n    dis_ele['SoH']=(dis_ele['capacity']) \/ C\nprint(dataset_val.head(5))\nprint(dis_ele.head(5))","7e9e47f1":"attrib=['capacity', 'voltage_measured', 'current_measured',\n        'temperature_measured', 'current_load', 'voltage_load', 'time']\nsoh_pred = model.predict(sc.fit_transform(dataset_val[attrib]))\nprint(soh_pred.shape)\n\nC = dataset_val['capacity'][0]\nsoh = []\nfor i in range(len(dataset_val)):\n  soh.append(dataset_val['capacity'][i] \/ C)\nnew_soh = dataset_val.loc[(dataset_val['cycle'] >= 1), ['cycle']]\nnew_soh['SoH'] =  soh\nnew_soh['NewSoH'] = soh_pred\nnew_soh = new_soh.groupby(['cycle']).mean().reset_index()\nprint(new_soh.head(10))\nrms = np.sqrt(mean_squared_error(new_soh['SoH'], new_soh['NewSoH']))\nprint('Root Mean Square Error: ', rms)","18425812":"plot_df = new_soh.loc[(new_soh['cycle']>=1),['cycle','SoH', 'NewSoH']]\nsns.set_style(\"white\")\nplt.figure(figsize=(16, 10))\nplt.plot(plot_df['cycle'], plot_df['SoH'], label='SoH')\nplt.plot(plot_df['cycle'], plot_df['NewSoH'], label='Predicted SoH')\n#Draw threshold\n#plt.plot([0.,len(capacity)], [0.70, 0.70], label='Threshold')\nplt.ylabel('SOH')\n# make x-axis ticks legible\nadf = plt.gca().get_xaxis().get_major_formatter()\nplt.xlabel('cycle')\nplt.legend()\nplt.title('Discharge B0006')","287f8f1b":"dataset_val, capacity_val = load_data('B0005')\nattrib=['cycle', 'datetime', 'capacity']\ndis_ele = capacity_val[attrib]\nrows=['cycle','capacity']\ndataset=dis_ele[rows]\ndata_train=dataset[(dataset['cycle']<50)]\ndata_set_train=data_train.iloc[:,1:2].values\ndata_test=dataset[(dataset['cycle']>=50)]\ndata_set_test=data_test.iloc[:,1:2].values\n\nsc=MinMaxScaler(feature_range=(0,1))\ndata_set_train=sc.fit_transform(data_set_train)\ndata_set_test=sc.transform(data_set_test)\n\nX_train=[]\ny_train=[]\n#take the last 10t to predict 10t+1\nfor i in range(10,49):\n    X_train.append(data_set_train[i-10:i,0])\n    y_train.append(data_set_train[i,0])\nX_train,y_train=np.array(X_train),np.array(y_train)\n \nX_train=np.reshape(X_train,(X_train.shape[0],X_train.shape[1],1))","bd650330":"regress = Sequential()\nregress.add(LSTM(units=200, return_sequences=True, input_shape=(X_train.shape[1],1)))\nregress.add(Dropout(0.3))\nregress.add(LSTM(units=200, return_sequences=True))\nregress.add(Dropout(0.3))\nregress.add(LSTM(units=200, return_sequences=True))\nregress.add(Dropout(0.3))\nregress.add(LSTM(units=200))\nregress.add(Dropout(0.3))\nregress.add(Dense(units=1))\nregress.compile(optimizer='adam',loss='mean_squared_error')\nregress.summary()","1806f136":"regress.fit(X_train,y_train,epochs=200,batch_size=25)","49e259ab":"print(len(data_test))\ndata_total=pd.concat((data_train['capacity'], data_test['capacity']),axis=0)\ninputs=data_total[len(data_total)-len(data_test)-10:].values\ninputs=inputs.reshape(-1,1)\ninputs=sc.transform(inputs)","fa50d9b2":"X_test=[]\nfor i in range(10,129):\n    X_test.append(inputs[i-10:i,0])\nX_test=np.array(X_test)\nX_test=np.reshape(X_test,(X_test.shape[0],X_test.shape[1],1))\npred=regress.predict(X_test)\nprint(pred.shape)\npred=sc.inverse_transform(pred)\npred=pred[:,0]\ntests=data_test.iloc[:,1:2]\nrmse = np.sqrt(mean_squared_error(tests, pred))\nprint('Test RMSE: %.3f' % rmse)\nmetrics.r2_score(tests,pred)","b289ca70":"ln = len(data_train)\ndata_test['pre']=pred\nplot_df = dataset.loc[(dataset['cycle']>=1),['cycle','capacity']]\nplot_per = data_test.loc[(data_test['cycle']>=ln),['cycle','pre']]\nplt.figure(figsize=(16, 10))\nplt.plot(plot_df['cycle'], plot_df['capacity'], label=\"Actual data\", color='blue')\nplt.plot(plot_per['cycle'],plot_per['pre'],label=\"Prediction data\", color='red')\n#Draw threshold\nplt.plot([0.,168], [1.38, 1.38],dashes=[6, 2], label=\"treshold\")\nplt.ylabel('Capacity')\n# make x-axis ticks legible\nadf = plt.gca().get_xaxis().get_major_formatter()\nplt.xlabel('cycle')\nplt.legend()\nplt.title('Discharge B0005 (prediction) start in cycle 50 -RULe=-8, window-size=10')","0a7026b5":"pred=0\nAfil=0\nPfil=0\na=data_test['capacity'].values\nb=data_test['pre'].values\nj=0\nk=0\nfor i in range(len(a)):\n    actual=a[i]\n    \n    if actual<=1.38:\n        j=i\n        Afil=j\n        break\nfor i in range(len(a)):\n    pred=b[i]\n    if pred< 1.38:\n        k=i\n        Pfil=k\n        break\nprint(\"The Actual fail at cycle number: \"+ str(Afil+ln))\nprint(\"The prediction fail at cycle number: \"+ str(Pfil+ln))\nRULerror=Pfil-Afil\nprint(\"The error of RUL= \"+ str(RULerror)+ \" Cycle(s)\")","f280f69d":"Similarly to what has been done previously, a graph of the SoH is made for each cycle, the horizontal line represents the threshold of 70% in which the battery already fulfills its life cycle and it is advisable to make the change.","393d3c0f":"The following graph shows the aging process of the battery as the charge cycles progress. The horizontal line represents the threshold related to what can be considered the end of the battery's life cycle.","42a67b06":"Finally, it can be seen in the graph that the capacity value and how it behaves over time is very close to the real value and supporting these data, the error in the estimation of the RUL was -8 which makes us understand that The model went ahead by 8 cycles to estimate that the battery reached its end of life.","5866956d":"Finally both SoH are plotted to observe their differences","c65d6c72":"Preparation of the model, 3 dense layers are used, and the parameters are used as they are in the paper: 3 dense layers and one dropout, and one of the ADAM type is used as optimizer","a607e335":"For the estimation of SoH, it can be seen that the data pattern is learned by the model correctly, as predicted by the theory, since the shape of the curves is almost identical. The SoH shown has the same behavior as expected in theory, which is corroborated with the root mean square error value of the graph in illustration 8, whose value of 9% is very similar to that found previously. This reaffirms the precision when making the prediction.","86d7648c":"It is also necessary to calculate the SoH of the battery, since this is the data that will be predicted using the * deep learning * model.","8d996785":"# Library import\nIn this part, all the necessary libraries for the treatment of the dataset are important.","7a1ee188":"# Introduction\nManual for the preparation and use of the Deep Learning model for battery SoH prediction\nThis Python Notebook shows and analyzes how the battery charge \/ discharge dataset obtained from NASA should be treated. It also shows how the model proposed by [1] and [2] is prepared and its encoding necessary to be used.\n\nRequirements\nFor the training phase of this model it is necessary to have Python 3.x installed along with the following libraries:\n\nTensorflow 2.0\nNumpy\nPandas\nScipy\nSci-kit learn\nMatplot\nSeaborn\nFor the prediction phase of this model it is necessary to have the same libraries with the exception of Matplot and Seaborn\n\nDataset preparation\nSince this manual was created from Google Colab (this may not be necessary to do it in an offline environment), it is necessary to download the dataset and then unzip it in a specific directory.","34457700":"```\nData Structure:\ncycle:\ttop level structure array containing the charge, discharge and impedance operations\n\ttype: \toperation  type, can be charge, discharge or impedance\n\tambient_temperature:\tambient temperature (degree C)\n\ttime: \tthe date and time of the start of the cycle, in MATLAB  date vector format\n\tdata:\tdata structure containing the measurements\n\t   for charge the fields are:\n\t\tVoltage_measured: \tBattery terminal voltage (Volts)\n\t\tCurrent_measured:\tBattery output current (Amps)\n\t\tTemperature_measured: \tBattery temperature (degree C)\n\t\tCurrent_charge:\t\tCurrent measured at charger (Amps)\n\t\tVoltage_charge:\t\tVoltage measured at charger (Volts)\n\t\tTime:\t\t\tTime vector for the cycle (secs)\n\t   for discharge the fields are:\n\t\tVoltage_measured: \tBattery terminal voltage (Volts)\n\t\tCurrent_measured:\tBattery output current (Amps)\n\t\tTemperature_measured: \tBattery temperature (degree C)\n\t\tCurrent_charge:\t\tCurrent measured at load (Amps)\n\t\tVoltage_charge:\t\tVoltage measured at load (Volts)\n\t\tTime:\t\t\tTime vector for the cycle (secs)\n\t\tCapacity:\t\tBattery capacity (Ahr) for discharge till 2.7V \n\t   for impedance the fields are:\n\t\tSense_current:\t\tCurrent in sense branch (Amps)\n\t\tBattery_current:\tCurrent in battery branch (Amps)\n\t\tCurrent_ratio:\t\tRatio of the above currents \n\t\tBattery_impedance:\tBattery impedance (Ohms) computed from raw data\n\t\tRectified_impedance:\tCalibrated and smoothed battery impedance (Ohms) \n\t\tRe:\t\t\tEstimated electrolyte resistance (Ohms)\n\t\tRct:\t\t\tEstimated charge transfer resistance (Ohms)\n\n```","a10db9e1":"A table is created containing the real SoH and the SoH predicted by the network and the root of the mean square error is calculated.","8f7edc29":"In this section the model is trained, based on the proposal of [2] and making use of LSTM-type networks instead of standard neural networks.","214d1cf7":"As can be seen, the mean RMSE is 0.05 (5%), which is very close to the values observed in the literature using this type of network.","96b9c492":"# Loading the dataset into memory\nAccording to the README of the dataset, the data is stored in several \".mat\" files, each file corresponds to a specific battery and the data structure of each file is as follows:","52daee23":"# Training phase for calculating SoH\nThe dataset is prepared in such a way that it can be used by Tensorflow in the training phase, for this, two structures are created corresponding to the input and output expected to be obtained. For the input data, the relevant characteristics of the dataset are filtered, which are:\n\n* Battery capacity\n* Voltage\n* Current\n* Temperature\n* Charging voltage\n* Charging current\n* Instant of time (from the start of the download)\n\nFor the output data, the SoH of the battery is calculated and in both input and output cases, the values are normalized to a range of values between [0-1].","255d8558":"# Testing to test the SoH prediction model\nTo test the correctness of the model, the information of the same battery is loaded (B0006)","72934658":"For the Deep Learning model proposed in [1] it is only necessary to collect the data related to the discharge of the battery, for this a function is created in Python that is in charge of reading this data from the \".mat\" file and storing it in memory in two pandas DataFrame for later access. After loading the dataset, a description of the data is made using panda functions to verify if the data loading was correct.","f277892a":"# RUL estimation\nIn the same way that was done for the estimation of SoH, the training and testing dataset is prepared, in this particular case the battery capacity data is used using the first data of the first 50 cycles to predict the capacity in the following cycles in such a way as to be able to know when the threshold of the battery is reached and estimate the remaining cycles to reach the End of Life of the battery","24fc7073":"## The model is trained, 50 epochs are used for training"}}