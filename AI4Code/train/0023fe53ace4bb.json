{"cell_type":{"0b04591a":"code","5214fe1e":"code","4287afca":"code","9fe41d6a":"code","d91114cd":"code","de9c3eec":"code","06925db7":"code","8c8b5492":"code","266ea54e":"code","2572559e":"code","ee638789":"code","f0708bba":"markdown","37365702":"markdown","4142961d":"markdown","46f9d46f":"markdown"},"source":{"0b04591a":"%matplotlib inline\n\n\nimport pandas as pd\n\nbase_path = '..\/Backtests\/'\n\nbm = 'SPXTR'\nbm_name = 'S&P 500 Total Return Index'\n\n\nstrat_names = {\n    \"core_trend\" : \"Core Trend Strategy\",    \n    \"time_return\" : \"Time Return Strategy\",\n    \"counter_trend\" : \"Counter Trend Strategy\",\n    \"curve_trading\" : \"Curve Trading Strategy\",\n    \"equity_momentum\" : \"Equity Momentum Strategy\",\n}\n\nstrat = 'curve_trading'\nstrat_name = strat_names[strat]\n\ndf = pd.read_csv(base_path + strat + '.csv', index_col=0, parse_dates=True, names=[strat] )\ndf[bm_name] = pd.read_csv(base_path + bm + '.csv', index_col=0, parse_dates=[0] )\ndf = df.loc[:'2018-12-31'].dropna()\nprint(\"Fetched: {}\".format(strat_name))","5214fe1e":"import matplotlib\nimport matplotlib.pyplot as plt\nyr_periods = 252\n\n# Format for book display\nfont = {'family' : 'eurostile',\n        'weight' : 'normal',\n        'size'   : 16}\nmatplotlib.rc('font', **font)\n\ndef equity_graph(df):\n    df = df \/ df.iloc[0]\n    df['Correlation'] = df[strat].pct_change().rolling(window=int(yr_periods \/ 1)).corr(df[bm_name].pct_change())\n    \n    df['Drawdown'] = (df[strat] \/ df[strat].cummax()) - 1\n    \n    df.fillna(0, inplace=True) # make sure no NA values are in there\n    fig = plt.figure(figsize=(15, 12))\n\n    # First chart\n    ax = fig.add_subplot(311)\n    ax.set_title('Strategy Comparisons')\n    ax.semilogy(df[strat], '-',label=strat_name, color='black')\n    ax.semilogy(df[bm_name] , '--', color='grey')\n    ax.legend()\n    \n    # Second chart\n    ax = fig.add_subplot(312)\n    ax.fill_between(df.index, df['Drawdown'], label='Drawdown', color='black')\n    ax.legend()\n\n    # Third chart\n    ax = fig.add_subplot(313)\n    ax.fill_between(df.index,df['Correlation'], label='12M Rolling Correlation', color='grey')\n    ax.legend()\n\nequity_graph(df)","4287afca":"import empyrical as em\nfrom IPython.core.display import display, HTML\n\nmonthly_data = em.aggregate_returns(df[strat].pct_change(),'monthly')\nyearly_data = em.aggregate_returns(df[strat].pct_change(),'yearly')\n\ntable = \"\"\"\n<table class='table table-hover table-condensed table-striped'>\n<thead>\n<tr>\n<th style=\"text-align:right\">Year<\/th>\n<th style=\"text-align:right\">Jan<\/th>\n<th style=\"text-align:right\">Feb<\/th>\n<th style=\"text-align:right\">Mar<\/th>\n<th style=\"text-align:right\">Apr<\/th>\n<th style=\"text-align:right\">May<\/th>\n<th style=\"text-align:right\">Jun<\/th>\n<th style=\"text-align:right\">Jul<\/th>\n<th style=\"text-align:right\">Aug<\/th>\n<th style=\"text-align:right\">Sep<\/th>\n<th style=\"text-align:right\">Oct<\/th>\n<th style=\"text-align:right\">Nov<\/th>\n<th style=\"text-align:right\">Dec<\/th>\n<th style=\"text-align:right\">Year<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\"\"\"\n\nfirst_year = True\nfirst_month = True\nyr = 0\nmnth = 0\nfor m, val in monthly_data.iteritems():\n    yr = m[0]\n    mnth = m[1]\n\n    if(first_month):\n        table += \"<td align='right'><b>{}<\/b><\/td>\\n\".format(yr)\n        first_month = False\n\n    if(first_year): # pad empty months for first year if sim doesn't start in January\n        first_year = False\n        if(mnth > 1):\n            for i in range(1, mnth):\n                table += \"<td align='right'>-<\/td>\\n\"\n\n    table += \"<td align='right'>{:+.1f}<\/td>\\n\".format(val * 100)\n\n    if(mnth==12): # check for dec, add yearly\n        table += \"<td align='right'><b>{:+.1f}<\/b><\/td>\\n\".format(yearly_data[yr] * 100)     \n        table += '<\/tr>\\n <tr> \\n'    \n        first_month = True\n\n# add padding for empty months and last year's value\nif(mnth != 12):\n    for i in range(mnth+1, 13):\n        table += \"<td align='right'>-<\/td>\\n\"\n        if(i==12):\n            table += \"<td align='right'><b>{:+.1f}<\/b><\/td>\\n\".format(\n                yearly_data[yr] * 100\n            ) \n            table += '<\/tr>\\n <tr> \\n'\ntable += '<\/tr>\\n <\/tbody> \\n <\/table>'\n\ndisplay(HTML(table))\n\n","9fe41d6a":"def holding_period_map(df):\n    yr = em.aggregate_returns(df[strat].pct_change(), 'yearly')\n    df = pd.DataFrame(columns=range(1,len(yr)+1), index=yr.index)\n\n    yr_start = 0\n    \n    table = \"<table class='table table-hover table-condensed table-striped'>\"\n    table += \"<tr><th>Years<\/th>\"\n    \n    for i in range(len(yr)):\n        table += \"<th>{}<\/th>\".format(i+1)\n    table += \"<\/tr>\"\n\n    for the_year, value in yr.iteritems(): # Iterates years\n        table += \"<tr><th>{}<\/th>\".format(the_year) # New table row\n        \n        for yrs_held in (range(1, len(yr)+1)): # Iterates yrs held \n            if yrs_held   <= len(yr[yr_start:yr_start + yrs_held]):\n                ret = em.annual_return(yr[yr_start:yr_start + yrs_held], 'yearly' )\n                table += \"<td>{:+.0f}<\/td>\".format(ret * 100)\n        table += \"<\/tr>\"    \n        yr_start+=1\n    return table\n\ntable = holding_period_map(df)\ndisplay(HTML(table))\n\n","d91114cd":"import pandas as pd\nimport numpy as np\n\nbase_path = '..\/Backtests\/'","de9c3eec":"# Rebalance on percent divergence\nclass PercentRebalance(object):\n    def __init__(self, percent_target):\n        self.rebalance_count = 0\n        self.percent_target = percent_target\n        \n    def rebalance(self, row, weights, date):\n        total = row.sum()\n        rebalanced = row\n        rebalanced = np.multiply(total, weights)\n        if np.any(np.abs((row-rebalanced)\/rebalanced) > (self.percent_target\/100.0)):\n            self.rebalance_count = self.rebalance_count + 1\n            return rebalanced\n        else:\n            return row\n\n# Rebalance on calendar\nclass MonthRebalance(object):\n    def __init__(self, months):\n        self.month_to_rebalance = months\n        self.rebalance_count = 0\n        self.last_rebalance_month = 0\n\n    def rebalance(self, row, weights, date):\n        current_month = date.month\n\n        if self.last_rebalance_month != current_month:\n            total = row.sum()\n            rebalanced = np.multiply(weights, total)\n            self.rebalance_count = self.rebalance_count + 1\n            self.last_rebalance_month = date.month\n            return rebalanced\n        else:\n            return row","06925db7":"\n# Calculate the rebalanced combination\ndef calc_rebalanced_returns(returns, rebalancer, weights):\n    returns = returns.copy() + 1\n    \n    # create a numpy ndarray to hold the cumulative returns\n    cumulative = np.zeros(returns.shape)\n    cumulative[0] = np.array(weights)\n\n    # also convert returns to an ndarray for faster access\n    rets = returns.values\n\n    # using ndarrays all of the multiplicaion is now handled by numpy\n    for i in range(1, len(cumulative) ):\n        np.multiply(cumulative[i-1], rets[i], out=cumulative[i])\n        cumulative[i] = rebalancer.rebalance(cumulative[i], weights, returns.index[i])\n\n    # convert the cumulative returns back into a dataframe\n    cumulativeDF = pd.DataFrame(cumulative, index=returns.index, columns=returns.columns)\n\n    # finding out how many times rebalancing happens is an interesting exercise\n    print (\"Rebalanced {} times\".format(rebalancer.rebalance_count))\n\n    # turn the cumulative values back into daily returns\n    rr = cumulativeDF.pct_change() + 1\n    rebalanced_return = rr.dot(weights) - 1\n    return rebalanced_return\n\ndef get_strat(strat):\n    df = pd.read_csv(base_path + strat + '.csv', index_col=0, parse_dates=True, names=[strat] )\n    return df","8c8b5492":"# Use monthly rebalancer, one month interval\nrebalancer = MonthRebalance(1)\n\n# Define strategies and weights\nportfolio = {\n    'core_trend': 0.25,\n    'counter_trend': 0.25,\n    'curve_trading': 0.25,\n    'time_return': 0.25,\n}\n\n# Read all the files into one DataFrame\ndf = pd.concat(\n        [\n            pd.read_csv('{}{}.csv'.format(\n                        base_path,\n                        strat\n                        ), \n                        index_col=0,\n                        parse_dates=True,\n                        names=[strat]\n                       ).pct_change().dropna()\n            for strat in list(portfolio.keys())\n        ], axis=1\n)\n\n# Calculate the combined portfolio\ndf['Combined'] = calc_rebalanced_returns(\n    df, \n    rebalancer, \n    weights=list(portfolio.values())\n    )\n\ndf.dropna(inplace=True)\n\n\n","266ea54e":"# Make Graph\nimport matplotlib \nimport matplotlib.pyplot as plt\n\ninclude_combined = True\ninclude_benchmark = True\nbenchmark = 'SPXTR'\n\nif include_benchmark:\n    returns[benchmark] = get_strat(benchmark).pct_change()\n\n#returns = returns['2003-1-1':]\nnormalized = (returns+1).cumprod()\n\nfont = {'family' : 'eurostile',\n        'weight' : 'normal',\n        'size'   : 16}\n\nmatplotlib.rc('font', **font)\n\n\nfig = plt.figure(figsize=(15, 8))\n\n# First chart\nax = fig.add_subplot(111)\nax.set_title('Strategy Comparisons')\n\ndashstyles = ['-','--','-.','.-.', '-']\ni = 0\nfor strat in normalized:\n    if strat == 'Combined':\n        if not include_combined:\n            continue\n        clr = 'black'\n        dash = '-'\n        width = 5\n    elif strat == benchmark:\n        if not include_benchmark:\n            continue\n        clr = 'black'\n        dash = '-'\n        width = 2\n    #elif strat == 'equity_momentum':\n    #    continue\n\n    else:\n        clr = 'grey'\n        dash = dashstyles[i]\n        width = i + 1\n        i += 1\n    ax.semilogy(normalized[strat], dash, label=strat, color=clr, linewidth=width)\n    \n    ax.legend()","2572559e":"df.to_clipboard()","ee638789":"portfolio = {\n    'x': 1,\n    'y': 2,\n    'z': 3\n    \n}\n#print(portfolio.values())\n\nx = np.array(list(portfolio.keys()))\n             \nprint(x)\n\n","f0708bba":"# Combined Models","37365702":"# Model comparison","4142961d":"# 20 Performance Visualization and Combinations","46f9d46f":"The following code should run successfully on a local computer, but not here. The code is correct. Outputs are hidden."}}