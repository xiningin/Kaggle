{"cell_type":{"c6737c73":"code","93ffba7d":"code","59cc8d42":"code","0f4f1880":"code","420097d2":"code","f178c7b0":"code","10ebdbe6":"code","ef6d723f":"code","4dba29e8":"code","b421c1dc":"code","710f8201":"code","28962e54":"code","157ca250":"code","ff38916e":"code","f920c6b8":"code","4b34db25":"code","2c1bc192":"markdown","3adc24b4":"markdown","184553a7":"markdown","11c824a3":"markdown","128165da":"markdown","48b30656":"markdown","fe09237d":"markdown"},"source":{"c6737c73":"from bs4 import BeautifulSoup as soup\nfrom urllib.request import Request, urlopen\nfrom matplotlib import dates\nfrom datetime import datetime\nfrom dateutil.relativedelta import *\n\n# Web scraping\n\nfname = 'https:\/\/database.lichess.org\/'\nreq = Request(fname, headers={'User-Agent': 'Mozilla\/5.0'})\nwebpage = urlopen(req)\npage_soup = soup(webpage, \"html.parser\")\ncontainers = page_soup.findAll(\"tr\")\n\nnew_containers = []\nfor container in containers:\n    if str(container).find('standard') != -1:\n        new_containers.append(container)\n        \nnum_games_list = []\nfor i in range(len(new_containers)-1, -1, -1):\n    c = new_containers[i].findAll(\"td\")\n    num = int(c[2].text.replace(',', ''))\n    num_games_list.append(num)\n    \n# Create date tickers\n\ndate_list = []\nstart_date = datetime(2013, 1, 1)\nfor x in range(len(new_containers)):\n    date_list.append(start_date)\n    start_date += relativedelta(months=1)","93ffba7d":"import pandas as pd\nimport matplotlib.pyplot as plt\n\ndf = pd.DataFrame(data=num_games_list, columns=['Number'])\ndf.index = date_list\nplt.figure(figsize=(10, 8))\nplt.plot(df)\nplt.title(\"Popularity of Lichess Over Time\", fontsize=20)\nplt.ylabel(\"Number of Games\", fontsize=16)\nplt.axvline(datetime(2014, 8, 1), linestyle='--')\nplt.xlim(datetime(2013, 1, 1))\nplt.show()","59cc8d42":"import numpy as np\n\ndf = pd.DataFrame(data=np.log10(num_games_list), columns=['Number'])\ndf.index = date_list\nplt.figure(figsize=(10, 8))\nplt.plot(df)\nplt.title(\"Popularity of Lichess Over Time, Logarithmic\", fontsize=20)\nplt.ylabel(\"Number of Games, log10\", fontsize=16)\nplt.axvline(datetime(2014, 8, 1), linestyle='--')\nplt.xlim(datetime(2013, 1, 1))\nplt.show()","0f4f1880":"import bz2\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport math","420097d2":"with bz2.open(\"\/kaggle\/input\/raw-chess-games-pgn\/lichess_db_standard_rated_2014-08.pgn.bz2\", \"rb\") as f:\n    data = f.read()","f178c7b0":"data = str(data) # Convert binary data into string for easier functionality\nraw_games = data.split('[Event') # Split the data into chess games using the '[Event' string\nprint(\"Game at 0th index: %s\" % raw_games[0])\ndel raw_games[0] # The first index isn't a game\ndel data # Remove binary string to save memory","10ebdbe6":"analysis_games = 0\nempty_games = 0\n\nprint(\"Sample normal game: %s\\n\" % raw_games[0])\nfor game in raw_games:\n    if game.find('eval') != -1:\n        if analysis_games == 0:\n            print(\"Sample game with analysis attached: %s\\n\" % game)\n        analysis_games += 1\n\nfor game in raw_games:\n    if game.find('1.') == -1:\n        if empty_games == 0:\n            print(\"Sample empty game: %s\" % game)\n        empty_games += 1","ef6d723f":"normal_games = len(raw_games)-analysis_games-empty_games\n\nprint(\"Number of total games: %d\" % len(raw_games))\nprint(\"Number of normal games: %d\" % normal_games)\nprint(\"Number of games with eval attached: %d\" % analysis_games)\nprint(\"Number of empty games: %d\" % empty_games)\n\nexplode = [0, 0.1, 0]\nplt.figure(figsize=(12, 8))\nlabels = ['Normal', 'Analysis', 'Empty']\npie_data = [normal_games\/len(raw_games), analysis_games\/len(raw_games), empty_games\/len(raw_games)]\nplt.pie(pie_data, labels=labels, autopct='%1.2f%%', shadow=True, explode=explode, textprops={'fontsize': 14})\nplt.show()","4dba29e8":"all_games = []\nfor i in range(len(raw_games)):\n    if raw_games[i].find('eval') != -1 or raw_games[i].find('1.') == -1:\n        continue\n    else:\n        all_games.append(raw_games[i])\n\ndel raw_games # remove old uncleaned version to save memory","b421c1dc":"len(all_games)","710f8201":"%%time\nPGN_list = []\nmode_list = []\nresult_list = []\navg_rating_list = []\nrating_diff_list = []\ntermination_list = []\nfor game in all_games:\n    # PGN\n    index = game.find(\"1. \") + 2\n    while True:\n        if game[index:index+2] == '0-' or game[index:index+2] == '1-' or game[index:index+2] == '1\/':\n            # Game termination\n            break\n        index += 1\n    \n    PGN_list.append(game[game.find(\"1.\"):index-1])\n    \n    # Mode\n    index = game.find(\"d\") + 2\n    s = \"\"\n    while True:\n        if game[index] == \" \":\n            break\n        s += game[index]\n        index += 1\n    mode_list.append(s)\n    \n    # Result\n    index = game.find('Result')+8\n    result = game[index:index+2]\n    if result == \"1-\":\n        result_list.append(\"White Wins\")\n    elif result == \"0-\":\n        result_list.append(\"Black Wins\")\n    elif result == \"1\/\":\n        result_list.append(\"Draw\")\n    \n    # Rating\n    wIndex = game.find('WhiteElo') + 10\n    bIndex = game.find('BlackElo') + 10\n    wString = \"\"\n    while True:\n        # Use a loop in case there's a rating <1000\n        if game[wIndex] == '\"':\n            break\n        wString += game[wIndex]\n        wIndex += 1\n    \n    bString = \"\"\n    while True:\n        if game[bIndex] == '\"':\n            break\n        bString += game[bIndex]\n        bIndex += 1\n        \n    wRating = int(wString)\n    bRating = int(bString)\n    avg_rating_list.append(math.ceil((wRating+bRating)\/2))\n    rating_diff_list.append(wRating-bRating)\n    \n    # Termination\n    index = game.find(\"[Termination\")\n    quotes = 0\n    s = \"\"\n    while quotes < 2:\n        if game[index] == '\"':\n            quotes += 1\n        elif quotes == 1:\n            s += game[index]\n        index += 1\n    \n    termination_list.append(s)","28962e54":"chess_df = pd.DataFrame({})\nchess_df['PGN'] = PGN_list\nchess_df['Mode'] = mode_list\nchess_df['Result'] = result_list\nchess_df['Average Rating'] = avg_rating_list\nchess_df['Rating Difference'] = rating_diff_list\nchess_df['Termination Type'] = termination_list","157ca250":"chess_df.head()","ff38916e":"print(\"Dataset is %.2f MB\" % (chess_df.memory_usage(deep=True).sum()\/1000000))","f920c6b8":"print(\"Original array length: %d\\nNew dataframe length: %d\" % (len(all_games), len(chess_df)))","4b34db25":"EXPORT = True\n\nif EXPORT:\n    chess_df.to_csv(\"lichess-08-2014.csv\", index=True, header=True)","2c1bc192":"<h1 class=\"alert alert-block alert-info\" style=\"text-align:center; font-size:24px\" id =\"EDA\">Exploratory Data Analysis (EDA) <a class=\"anchor-link\" href=\"https:\/\/www.kaggle.com\/ironicninja\/converting-raw-chess-pgn-to-readable-data\/notebook#EDA\">\u00b6<\/a> <\/h1>\n\n<p style=\"font-size:15px; font-family:verdana; line-height: 1.7em; padding-top: 15px\"> In this dataset, there are three types of games: \"normal\" games (consistent with PGN), games with analysis (i.e., there is 'eval' attached which an engine's evaluation of the position), and empty games (no moves were played at all). Below, I give an example of each of these types of games. <\/p>","3adc24b4":"<h1 class=\"alert alert-block alert-info\" style=\"text-align:center; font-size:24px\" id=\"convert\">Converting the Data into a Pandas Dataframe <a class=\"anchor-link\" href=\"https:\/\/www.kaggle.com\/ironicninja\/converting-raw-chess-pgn-to-readable-data\/notebook#convert\">\u00b6<\/a> <\/h1>\n\n<p style=\"font-size:15px; font-family:verdana; line-height: 1.7em; padding-top: 15px\"> In this section, I convert the raw data I have into a pandas dataframe, so that later it can be transformed into a readable CSV file. My algorithms search through the strings and are able to generate essential features from it. I'm not sure if the bz2 data can be converted to JSON or be converted directly to a dictionary, but if it could, it would make the process of feature engineering much easier. <\/p>\n\n<p style=\"font-size:15px; font-family:verdana; line-height: 1.7em; padding-top: 15px\"> If you're interested, I've included a naive method of extracting games with the eval bar in a notebook linked here: <a href=\"https:\/\/www.kaggle.com\/ironicninja\/method-for-extracting-games-with-eval-bar\"> Method for Extracting Games with Eval Bar<\/a>. I opted not to include the method here since A. I'm not using it and B. I don't want to confuse the reader. <\/p>","184553a7":"<p style=\"font-size:15px; font-family:verdana; line-height: 1.7em\">Included in these graphs is a dashed line which represents the number of games in the August 2014 database I use for this notebook.<\/p>","11c824a3":"<h1 class=\"alert alert-block alert-info\" style=\"text-align:center; font-size:24px\" id=\"imports\"> Reading the Raw Data \/ Essential Imports <a class=\"anchor-link\" href=\"https:\/\/www.kaggle.com\/ironicninja\/converting-raw-chess-pgn-to-readable-data\/notebook#imports\">\u00b6<\/a> <\/h1>","128165da":"<h1 class=\"alert alert-block alert-info\" style=\"text-align:center; font-size:24px\" id=\"cleaning\">Cleaning the Data <a class=\"anchor-link\" href=\"https:\/\/www.kaggle.com\/ironicninja\/converting-raw-chess-pgn-to-readable-data\/notebook#cleaning\">\u00b6<\/a> <\/h1>\n\n<p style=\"font-size:15px; font-family:verdana; line-height: 1.7em; padding-top: 15px\"> The games that are not consistent with normal PGN notation can cause bugs in the code. Therefore, in this section, I remove the games that are empty or have analysis through a brute force approach. <\/p>","48b30656":"<p style=\"font-size:15px; font-family:verdana; line-height: 1.7em\"> I create a pie chart here to visualize the amount of different types of games there are in this raw dataset.<\/p>","fe09237d":"<h1 class=\"alert alert-block alert-info\" style=\"text-align:center; font-size:36px\">Chess Visualization Project, Part 1<\/h1>\n\n<p style=\"font-size:15px; font-family:verdana; line-height: 1.7em; padding-top: 15px\"> This is Part 1 of my two part series for visualizing chess data. In this notebook, I take unpolished chess portable game notation (PGN) and convert it into a readable CSV with essential features. I take the CSV I create here and perform different analyses and visualizations on the data in Part 2 of this notebook. <\/p> \n    \n<p style=\"font-size:15px; font-family:verdana; line-height: 1.7em; padding-top: 15px\">Note: I am using an August 2014 version of the database because other versions are far too large. This version does not have many of the features future versions have (e.g. Rapid mode, variant chess), which also makes the data a bit easier to deal with. The foundation of this code is definitely appliable to newer versions of the database though. Below is a graph that shows just how much more popular chess has become recently.<\/p>"}}