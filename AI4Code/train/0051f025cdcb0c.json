{"cell_type":{"b83b7e73":"code","281fc045":"code","955a007c":"code","f603e0e6":"code","7f4540da":"code","f0b080c3":"code","d9a5234c":"code","be997889":"code","a3e0d7d9":"code","579f2aa6":"code","7932c81e":"code","3c2ec675":"code","524d50ea":"code","f07dfad6":"code","20aee177":"code","9ae11e86":"code","bc11f94a":"code","45c0fc75":"code","b27bf95b":"code","7fbec058":"code","e167262e":"code","0166677a":"code","1e8b607b":"code","6419de39":"code","fbc30df4":"code","07107061":"code","e1943842":"code","83b17201":"code","52ccd6ea":"code","7c41276e":"code","31d3f60d":"code","a8312f90":"markdown","48220ca7":"markdown","3deb3672":"markdown","2947c110":"markdown"},"source":{"b83b7e73":"\"\"\"\nthis kernel uses code and data from these kernels:\nhttps:\/\/www.kaggle.com\/dfrumkin\/a-simple-way-to-use-giba-s-features\/notebook\nhttps:\/\/www.kaggle.com\/johnfarrell\/giba-s-property-extended-result\nhttps:\/\/www.kaggle.com\/titericz\/the-property-by-giba\n\"\"\"\nimport numpy as np\nimport pandas as pd\n\nimport os\nimport datetime\n\nimport gc\n\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.model_selection import KFold\n\nfrom math import sqrt\nimport math\n\nimport lightgbm as lgb\n\nfrom tqdm import tqdm_notebook\n","281fc045":"train = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')","955a007c":"#This code is borrowed from a kernel. Not sure\nall_features = [c for c in test.columns if c not in ['ID']]\ndef has_ugly(row):\n    for v in row.values[row.values > 0]:\n        if str(v)[::-1].find('.') > 2:\n            return True\n    return False\ntest['has_ugly'] = test[all_features].apply(has_ugly, axis=1)\ntest_og = test[['ID']].copy()\ntest_og['nonzero_mean'] = test[[c for c in test.columns if c not in ['ID', 'has_ugly']]].apply(lambda x: np.expm1(np.log1p(x[x!=0]).mean()), axis=1)\ntest = test[test.has_ugly == False]","f603e0e6":"\ntrain_t = train.drop(['target'], axis = 1, inplace=False)\ntrain_t.set_index('ID', inplace=True)\ntrain_t = train_t.T\ntest_t = test.set_index('ID', inplace=False)\ntest_t = test_t.T","7f4540da":"gc.collect()","f0b080c3":"\nfeatures = ['f190486d6', '58e2e02e6', 'eeb9cd3aa', '9fd594eec', '6eef030c1',\n        '15ace8c9f', 'fb0f5dbfe', '58e056e12', '20aa07010', '024c577b9',\n        'd6bb78916', 'b43a7cfd5', '58232a6fb', '1702b5bf0', '324921c7b',\n        '62e59a501', '2ec5b290f', '241f0f867', 'fb49e4212', '66ace2992',\n        'f74e8f13d', '5c6487af1', '963a49cdc', '26fc93eb7', '1931ccfdd',\n        '703885424', '70feb1494', '491b9ee45', '23310aa6f', 'e176a204a',\n        '6619d81fc', '1db387535', 'fc99f9426', '91f701ba2', '0572565c2',\n        '190db8488', 'adb64ff71', 'c47340d97', 'c5a231d81', '0ff32eb98']\n","d9a5234c":"extra_features = []","be997889":"#run this iteratively until you have no more links. Then prune\ndef chain_pairs(ordered_items):\n    ordered_chains = []\n    links_found = 0\n    for i_1, op_chain in enumerate(ordered_items.copy()[:]):\n        if op_chain[0] != op_chain[1]:\n            end_chain = op_chain[-1]\n            for i_2, op in enumerate(ordered_items.copy()[:]):\n                if (end_chain == op[0]):\n                    links_found += 1\n                    op_chain.extend(op[1:])\n                    end_chain = op_chain[-1]\n\n            ordered_chains.append(op_chain)\n    return links_found, ordered_chains\n\ndef prune_chain(ordered_chain):\n    \n    ordered_chain = sorted(ordered_chain, key=len, reverse=True)\n    new_chain = []\n    id_lookup = {}\n    for oc in ordered_chain:\n        id_already_in_chain = False\n        for idd in oc:\n            if idd in id_lookup:\n                id_already_in_chain = True\n            id_lookup[idd] = idd\n\n        if not id_already_in_chain:\n            new_chain.append(oc)\n    return sorted(new_chain, key=len, reverse=True)\n","a3e0d7d9":"def find_new_ordered_features(ordered_ids, data_t):\n    data = data_t.copy()\n    \n    f1 = ordered_ids[0][:-1]\n    f2 = ordered_ids[0][1:]\n    for ef in ordered_ids[1:]:\n        f1 += ef[:-1]\n        f2 += ef[1:]\n            \n    d1 = data[f1].apply(tuple, axis=1).apply(hash).to_frame().rename(columns={0: 'key'})\n    d1['ID'] = data.index\n    gc.collect()\n    d2 = data[f2].apply(tuple, axis=1).apply(hash).to_frame().rename(columns={0: 'key'})\n    d2['ID'] = data.index\n    gc.collect()\n    d3 = d2[~d2.duplicated(['key'], keep=False)]\n    d4 = d1[~d1.duplicated(['key'], keep=False)]\n    d5 = d4.merge(d3, how='inner', on='key')\n\n    d_feat = d1.merge(d5, how='left', on='key')\n    d_feat.fillna(0, inplace=True)\n\n    ordered_features = list(d_feat[['ID_x', 'ID_y']][d_feat.ID_x != 0].apply(list, axis=1))\n    del d1,d2,d3,d4,d5,d_feat\n    gc.collect()\n    \n    links_found = 1\n    #print(ordered_features)\n    while links_found > 0:\n        links_found, ordered_features = chain_pairs(ordered_features)\n        #print(links_found)\n    \n    ordered_features = prune_chain(ordered_features)\n    \n    #make lookup of all features found so far\n    found = {}\n    for ef in extra_features:\n        found[ef[0]] = ef\n        #print (ef[0])\n    found [features[0]] = features\n\n    #make list of sets of 40 that have not been found yet\n    new_feature_sets = []\n    for of in ordered_features:\n        if len(of) >= 40:\n            if of[0] not in found:\n                new_feature_sets.append(of)\n                \n    return new_feature_sets","579f2aa6":"\ndef add_new_feature_sets(data, data_t):\n    \n    print ('\\nData Shape:', data.shape)\n    f1 = features[:-1]\n    f2 = features[1:]\n\n    for ef in extra_features:\n        f1 += ef[:-1]\n        f2 += ef[1:]\n\n    d1 = data[f1].apply(tuple, axis=1).apply(hash).to_frame().rename(columns={0: 'key'})\n    d1['ID'] = data['ID']    \n    gc.collect()\n    d2 = data[f2].apply(tuple, axis=1).apply(hash).to_frame().rename(columns={0: 'key'})\n    d2['ID'] = data['ID']\n    gc.collect()\n    #print('here')\n    d3 = d2[~d2.duplicated(['key'], keep=False)]\n    del d2\n    d4 = d1[~d1.duplicated(['key'], keep=False)]\n    #print('here')\n    d5 = d4.merge(d3, how='inner', on='key')\n    del d4\n    d = d1.merge(d5, how='left', on='key')\n    d.fillna(0, inplace=True)\n    #print('here')\n    ordered_ids = list(d[['ID_x', 'ID_y']][d.ID_x != 0].apply(list, axis=1))\n    del d1,d3,d5,d\n    gc.collect()\n\n    links_found = 1\n    while links_found > 0:\n        links_found, ordered_ids = chain_pairs(ordered_ids)\n        #print(links_found)\n\n    print ('OrderedIds:', len(ordered_ids))\n    #Make distinct ordered id chains\n    ordered_ids = prune_chain(ordered_ids)\n    print ('OrderedIds Pruned:', len(ordered_ids))\n\n    #look for ordered features with new ordered id chains\n    new_feature_sets = find_new_ordered_features(ordered_ids, data_t)    \n\n    extra_features.extend(new_feature_sets)\n    print('New Feature Count:', len(new_feature_sets))\n    print('Extra Feature Count:', len(extra_features))","7932c81e":"%%time\n\nadd_new_feature_sets(train,train_t)\nadd_new_feature_sets(test,test_t)\nadd_new_feature_sets(train,train_t)\nadd_new_feature_sets(test,test_t)\nadd_new_feature_sets(train,train_t)","3c2ec675":"with open(\"extra_features_{}.txt\".format(len(extra_features)), \"w\") as text_file:\n    for ef in extra_features:\n        text_file.write(','.join(ef) + '\\n')","524d50ea":"del train_t, test_t, test\ngc.collect()","f07dfad6":"#now that memory is cleared we can get back full test\ntest = pd.read_csv('..\/input\/test.csv')\ntest['has_ugly'] = test[all_features].apply(has_ugly, axis=1)\ntest[test.has_ugly == True] = 0","20aee177":"\ndef get_log_pred(data, feats, extra_feats, offset = 2):\n    f1 = feats[:(offset * -1)]\n    f2 = feats[offset:]\n    for ef in extra_feats:\n        f1 += ef[:(offset * -1)]\n        f2 += ef[offset:]\n        \n    d1 = data[f1].apply(tuple, axis=1).apply(hash).to_frame().rename(columns={0: 'key'})\n    d2 = data[f2].apply(tuple, axis=1).apply(hash).to_frame().rename(columns={0: 'key'})\n    d2['pred'] = data[feats[offset-2]]\n    d2 = d2[d2['pred'] != 0] # Keep?\n    d3 = d2[~d2.duplicated(['key'], keep=False)]\n    d4 = d1[~d1.duplicated(['key'], keep=False)]\n    d5 = d4.merge(d3, how='inner', on='key')\n        \n    d = d1.merge(d5, how='left', on='key')\n    return np.log1p(d.pred).fillna(0)\n","9ae11e86":"end_offset = 39\npred_test = []\npred_train = []\nefs = extra_features\nfor o in tqdm_notebook(list(range(2, end_offset))):\n    print('Offset:', o)\n\n    log_pred = get_log_pred(train, features, extra_features, o)\n    pred_train.append(np.expm1(log_pred))\n    have_data = log_pred != 0\n    train_count = have_data.sum()\n    score = sqrt(mean_squared_error(np.log1p(train.target[have_data]), log_pred[have_data]))\n    print(f'Score = {score} on {have_data.sum()} out of {train.shape[0]} training samples')\n\n\n    log_pred_test = get_log_pred(test, features, efs, o)\n    pred_test.append(np.expm1(log_pred_test))\n    have_data = log_pred_test != 0\n    test_count = have_data.sum()\n    print(f'Have predictions for {have_data.sum()} out of {test.shape[0]} test samples')\n\n    ","bc11f94a":"pred_train_final = pred_train[0].copy()\nfor r in range(1,len(pred_train)):\n    pred_train_final[pred_train_final == 0] = pred_train[r][pred_train_final == 0]\n\ntrain_leak_match_count = (pred_train_final!=0).sum();\nno_match_count = (pred_train_final==0).sum();\nprint (\"Train leak count: \", train_leak_match_count, \"Train no leak count: \",  no_match_count)\n\npred_train_temp = pred_train_final.copy()\ntrain[\"nonzero_mean\"] = train[[f for f in train.columns if f not in [\"ID\", \"target\",\"nonzero_mean\"]]].apply(lambda x: np.expm1(np.log1p(x[x!=0]).mean()), axis=1)\npred_train_temp[pred_train_temp==0] = train['nonzero_mean'][pred_train_temp==0]\nprint(f'Baseline Train Score = {sqrt(mean_squared_error(np.log1p(train.target), np.log1p(pred_train_temp)))}')","45c0fc75":"pred_test_final = pred_test[0].copy()\nfor r in range(1,len(pred_test)):\n    pred_test_final[pred_test_final == 0] = pred_test[r][pred_test_final == 0]\n    ","b27bf95b":"##https:\/\/www.kaggle.com\/rsakata\/21st-place-solution-bug-fixed-private-0-52785\npred_test_final[(4e+07 < pred_test_final)] = 4e+07\npred_test_final[((pred_test_final < 29000) & (pred_test_final > 0))] = 30000\n##https:\/\/www.kaggle.com\/c\/santander-value-prediction-challenge\/discussion\/63931\npred_test_final[test.ID == 'd72fad286'] = 1560000\npred_test_final[test.ID == 'a304cde42'] = 320000.0\n\ntest_leak_match_count = (pred_test_final!=0).sum();\nno_match_count = (pred_test_final==0).sum();\nprint (\"Test leak count: \", test_leak_match_count, \"Test no leak count: \",  no_match_count)","7fbec058":"##Make Leak Baseline\npred_test_temp = pred_test_final.copy()\ntest_og[\"nonzero_mean\"] = test_og[[f for f in test_og.columns if f not in [\"ID\", \"target\", \"nonzero_mean\", \"has_ugly\"]]].apply(lambda x: np.expm1(np.log1p(x[x!=0]).mean()), axis=1)\npred_test_temp[pred_test_temp==0] = test_og['nonzero_mean'][pred_test_temp==0]\ntest_og['target']=pred_test_temp\ntest_og[['ID', 'target']].to_csv('leak_baseline_{}.csv'.format(test_leak_match_count), index=False)\n","e167262e":"\ntest_leaks = pd.read_csv('..\/input\/sample_submission.csv')\ndel test_leaks['target']\ntest_leaks['target']=pred_test_final\ntest_leaks.to_csv('leak_only_{}.csv'.format(test_leak_match_count), index=False)\n","0166677a":"extra_features_list = []\n\nfor ef in extra_features:\n    extra_features_list.extend(ef)\n\nextra_features_list.extend(features)\nlen(extra_features_list)","1e8b607b":"#This makes the 100 40 length feature groups into 40 100 length feature groups. \n#These 100 size vectors is what I would have liked to feed into an LSTM\\CNN but I never got a chance to try this\nfeats = pd.DataFrame(extra_features) \ntime_features = []\nfor c in feats.columns[:]:    \n    time_features.append([f for f in feats[c].values if f is not None])\n    \n\n#Make a bunch of different feature groups to build aggregates from\nagg_features = []\nall_cols = train.columns.drop(['ID', 'target', 'nonzero_mean'])\nagg_features.append(all_cols)\nagg_features.append([c for c in all_cols if c not in extra_features_list])\nagg_features.append(extra_features_list)\nagg_features.extend(time_features)\nagg_features.extend(extra_features)\n ","6419de39":"#I made more aggregate feature to select from in model\\feature selection. \n#See this thread for some more aggregate ideas\n#https:\/\/www.kaggle.com\/c\/santander-value-prediction-challenge\/discussion\/62446\n\ndef add_new_features(source, dest, feats):\n    #dest['high_{}_{}'.format(feats[0], len(feats))] = source[feats].max(axis=1)\n    #dest['mean_{}_{}'.format(feats[0], len(feats))] = source[feats].replace(0, np.nan).mean(axis=1)\n    #dest['low_{}_{}'.format(feats[0], len(feats))] = source[feats].replace(0, np.nan).min(axis=1)\n    #dest['median_{}_{}'.format(feats[0], len(feats))] = source[feats].replace(0, np.nan).median(axis=1)\n    #dest['sum_{}_{}'.format(feats[0], len(feats))] = source[feats].sum(axis=1)\n    #dest['stddev_{}_{}'.format(feats[0], len(feats))] = source[feats].std(axis=1)\n    \n    dest['mean_log_{}_{}'.format(feats[0], len(feats))] = np.log1p(source[feats].replace(0, np.nan).mean(axis=1))    \n    dest['first_nonZero_{}_{}'.format(feats[0], len(feats))] = np.log1p(source[feats].replace(0, np.nan).bfill(1).iloc[:, 0])\n    dest['last_nonZero_{}_{}'.format(feats[0], len(feats))] = np.log1p(source[feats[::-1]].replace(0, np.nan).bfill(1).iloc[:, 0])    \n    \n    #dest['nb_nans_{}_{}'.format(feats[0], len(feats))] =  source[feats].replace(0, np.nan).isnull().sum(axis=1)\n    #dest['unique_{}_{}'.format(feats[0], len(feats))] = source[feats].nunique(axis=1)","fbc30df4":"#now that leak is done we should get back ugly data for feature engineering. This might not be necessary.\ndel test\ngc.collect\ntest = pd.read_csv('..\/input\/test.csv')","07107061":"train_feats = pd.DataFrame()\ntest_feats =pd.DataFrame()\n\nfor i, ef in tqdm_notebook(list(enumerate(agg_features))):        \n    add_new_features(train, train_feats, ef)\n    add_new_features(test, test_feats, ef)","e1943842":"# I made a general model runner but in this kernel it is hard coded to just the LGB class. \n# I left some of the generalness in the kernel incase it is of interest\n\nclass MyModel():\n    def __init__(self, X_tr, y_tr, X_val, y_val, X_test):\n        self.X_tr = X_tr\n        self.y_tr = y_tr\n        self.X_val = X_val\n        self.y_val = y_val\n        self.X_test = X_test\n        self.params = {}\n    def predict_val(self):\n        return self.model.predict(self.X_val)\n    def predict_test(self):\n        return self.model.predict(self.X_test)\n    \nclass LgbBoostModel(MyModel):\n    def train(self):          \n        \n        \n        self.params = { 'objective': 'regression', 'metric': 'rmse', 'boosting': 'gbdt', 'seed':seed, 'is_training_metric': True\n                  ,'max_bin': 350 #,'max_bin': 150\n                  ,'learning_rate': .005\n                  ,'max_depth': -1                  \n                  ,'num_leaves': 48\n                  ,'feature_fraction': 0.1\n                  ,'reg_alpha': 0\n                  ,'reg_lambda': 0.2\n                  ,'min_child_weight': 10}\n        \n        self.model = lgb.train(self.params, lgb.Dataset(self.X_tr, label=self.y_tr), 30000, \n                            [lgb.Dataset(self.X_tr, label=self.y_tr), lgb.Dataset(self.X_val, label=self.y_val)], \n                               verbose_eval=200, early_stopping_rounds=200)\n\n","83b17201":"#Make training data from the original training plus the leak. This is key to getting a good score.\ncols = train_feats.columns\ntrain_feat_final = pd.concat([train_feats[cols], test_feats[cols][test_leaks.target != 0]], axis = 0)\ntrain_feat_id = pd.concat([train['ID'], test['ID'][test_leaks.target != 0]], axis = 0)\ntest_feat_final = test_feats[cols]    \ny = np.array(list(np.log1p(train.target.values)) + list(np.log1p(test_leaks['target'][test_leaks.target != 0])))\n\nX = train_feat_final.values\nX_test = test_feat_final.values\n\nprint(X.shape)\nprint(X_test.shape)","52ccd6ea":"n_splits = 5\nseed = 42\n\nkf = KFold(n_splits=n_splits, random_state=seed, shuffle=True)\n\nrmse_scores = {}\noof_preds = {}\nsub_preds = {}\nmodel_params = {}\n\nmodel_types = ['lgb']\n\nfor model_type in model_types:\n    rmse_scores[model_type] = list()\n    oof_preds[model_type] = np.zeros((X.shape[0],))\n    sub_preds[model_type] = np.zeros((X_test.shape[0],))\n\nprint('{} fold..'.format(n_splits))\n\nfor fold, (train_index, test_index) in tqdm_notebook(list(enumerate(list(kf.split(y))[:]))):\n\n    # print(\"TRAIN:\", train_index, \"TEST:\", test_index)\n    X_tr, X_val = X[train_index], X[test_index]\n    y_tr, y_val = y[train_index], y[test_index]\n\n    for model_type in model_types:\n        print ('\\n*** ' + model_type)\n        #model = get_model_class(model_type,  X_tr, y_tr, X_val, y_val, X_test)\n        model = LgbBoostModel(X_tr, y_tr, X_val, y_val, X_test)\n\n        model.train()\n\n        oof_preds[model_type][test_index] = model.predict_val()\n        sub_preds[model_type] += model.predict_test() \/ n_splits        \n        rmse = mean_squared_error(y_val, model.predict_val())**0.5\n        rmse_scores[model_type].append(rmse)\n\n        model.params['cv'] = n_splits\n        #model.params['fold_by_target'] = fold_by_target\n        model.params['seed'] = seed            \n        model_params[model_type] = model.params\n\n        print('Fold %d: %s Mean Squared Error %f'%(fold, model_type, rmse))\n","7c41276e":"def mean(values):\n    return float(sum(values)) \/ max(len(values), 1)\n\ndef sum_of_square_deviation(values, mean):\n    return float(1\/len(values) * sum((x - mean)** 2 for x in values))    \n\ndef export_results(model_type):\n    subm = pd.read_csv('..\/input\/sample_submission.csv')\n    subm['target'] = np.expm1(sub_preds[model_type])\n    \n    oof = pd.DataFrame(train_feat_id.copy())\n    oof['target'] = np.expm1(y)\n    oof['prediction'] = np.expm1(oof_preds[model_type])\n    mean_rmse = mean(rmse_scores[model_type])\n    standard_deviation_rmse = math.sqrt(sum_of_square_deviation(rmse_scores[model_type],mean_rmse))\n    \n    #key = '{}_{}_{}'.format(model_type, int(mean_rmse * 10000), int(standard_deviation_rmse * 10000))\n    key = '{}'.format(model_type)\n    print( '{} Mean Squared Error {}'.format(model_type ,mean_rmse))\n    print( '{} Stdev Squared Error {}'.format(model_type, standard_deviation_rmse))\n    \n    file_name = 'subm_{}_ml_base.csv'.format(key)                                 \n    subm.to_csv(file_name, index=False, float_format=\"%.8f\")\n    \n    #file_name = 'subm_{}_with_leaks.csv'.format(key)    \n    file_name = 'submission.csv'.format(key)    \n    subm['target'][test_leaks.target != 0] = test_leaks['target'][test_leaks.target != 0]\n    subm.to_csv(file_name, index=False, float_format=\"%.8f\")\n    \n    \n    file_name = 'subm_{}_oof.csv'.format(key)    \n    oof.to_csv(file_name, index=False, float_format=\"%.8f\")\n    model_params[model_type]['cv_score'] = int(mean_rmse * 10000)\n    model_params[model_type]['cv_stddev'] = int(standard_deviation_rmse * 10000)\n    model_params[model_type]['train_row_count'] = X.shape[0]\n    model_params[model_type]['train_feature_count'] = X.shape[1]\n    model_params[model_type]['test_leak_count'] = (test_leaks.target != 0).sum()\n    with open('subm_{}_params.txt'.format(key) , \"w\") as text_file:\n        params = str(model_params[model_type])\n        print(f\"{params}\", file=text_file)","31d3f60d":"\nfor model_type in model_types:\n    export_results(model_type)\n","a8312f90":"## This section uses the feature sets to exploit the leak and make a leak baseline to be used for ML training and submissions.\n\n## All of my submissions where based off setting end_offset to 40 instead of 39. This is optimal in train and public LB. But not in private LB. It is kind of intuitive that 40 is too far. I wish I had done more full ML pipeline testing with this solution. Maybe there was some information that could have saved me from this mistake.","48220ca7":"## This section runs a single LGB model on all aggregate features. \n\n## My final score was based on blended feature selection from aggregates and raw features only.\n","3deb3672":"## This section makes aggregate features from the 40 length feature sets\n","2947c110":"## This section finds all the ordered feature sets. \n\n## If you want more then the 100 40 length sets you can change the length filter in the code after you have the first 100 and run this some more. It gets a bit iffy below 30 length. I did not find any improvement after 110 extra feature sets."}}