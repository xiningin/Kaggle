{"cell_type":{"800c88e4":"code","63e97c22":"code","c7b677e7":"code","4ceeead1":"code","14d0e191":"code","4a3dcb63":"code","431d00a4":"code","056ef5fc":"code","4e7249e1":"code","754ffade":"code","00a6866b":"code","601c7ebf":"code","7cf6fc59":"code","0b1cce3f":"code","6c0e37ac":"code","77cc4598":"code","28828f5e":"code","ddf20167":"markdown","9c7ae728":"markdown","e4f6f399":"markdown","d49ea701":"markdown","f20ac840":"markdown","41d142fe":"markdown","e1496da0":"markdown","d0886274":"markdown","b45207f4":"markdown","d5ead55f":"markdown","c7da0ced":"markdown","14472c08":"markdown","4e43a970":"markdown","ccf08ea6":"markdown"},"source":{"800c88e4":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport os\nimport seaborn as sns\nfrom matplotlib.colors import rgb2hex\nsns.set_style(\"darkgrid\")\nplt.style.use('seaborn')","63e97c22":"df = pd.read_csv('..\/input\/electric-motor-temperature\/measures_v2.csv')\ndf.shape","c7b677e7":"df.describe()","4ceeead1":"df.isnull().sum().sort_values(ascending=False)","14d0e191":"sessions = df.groupby('profile_id').agg('count')['u_d'] \/ (2 * 3600)\nsessions.plot.barh(figsize=(12,18), grid='both', title='Time per Session')\nplt.xlabel('Time (hr)')","4a3dcb63":"sessions.plot.hist(bins=50, title='Session Length Distribution', figsize=(12,6), grid='both')\nplt.xlabel('Time (hr)')","431d00a4":"corr = df.corr()\n# Generate a mask for the upper triangle\nmask = np.zeros_like(corr, dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\nfig, ax = plt.subplots(figsize=(15,10))\nsns.heatmap(corr, cmap='Spectral_r', mask=mask, square=True, annot=True, linewidth=0.5, cbar_kws={\"shrink\" : 0.5})","056ef5fc":"df_cpy = df.drop(['profile_id'], axis=1)\n\nflierprops = dict(markerfacecolor='g', color='g', alpha=0.5)\n\nn_cols = 4\nn_rows = int(np.ceil(df_cpy.shape[-1]*2 \/ n_cols))\nfig, axes = plt.subplots(n_rows, n_cols, figsize=(4 * n_cols, 3 * n_rows))\nfor i, (col) in enumerate(list(df_cpy.columns)):\n    mean = df_cpy[col].mean()\n    median = df_cpy[col].median()\n    sns.histplot(df_cpy[col], ax=axes.flatten()[2*i], kde=True)\n    sns.boxplot(x=df_cpy[col], orient='h', ax=axes.flatten()[2*i+1], color='g')\n    axes.flatten()[2*i+1].vlines(mean, ymin = -1, ymax = 1, color='r', label=f\"For [{col}]\\nMean: {mean:.2}\\nMedian: {median:.2}\")\n    axes.flatten()[2*i+1].legend()\n\n    if i % n_cols == 0:\n        ax.set_ylabel('Frequency')\n    else:\n        ax.set_ylabel('')\nplt.tight_layout()","4e7249e1":"pid_grouped = {pid: df_ for pid, df_ in df.groupby('profile_id')}\n\n\ndef parameter_visualizer(pid_grouped, coi, ylabel, n_cols):\n    \n    n_rows = int(np.ceil(len(pid_grouped) \/ n_cols))\n\n    color_list = plt.cm.Set1(np.linspace(0, 1, 10))\n    feat_clrs = {k: rgb2hex(color_list[i]) for i, k in enumerate(coi)}\n\n    fig, axes = plt.subplots(n_rows, n_cols, figsize=(4*n_cols, n_rows*3))\n\n    for i, (ax, (p_id, df_)) in enumerate(zip(axes.flatten(), pid_grouped.items())):\n        for col in coi:\n            lines = ax.plot(df_[col].reset_index(drop=True), label=col, color=feat_clrs[col])\n        ax.set_title(f'profile {p_id}')\n        if i % n_cols == 0:\n            ax.set_ylabel(ylabel)\n        else:\n            ax.set_ylabel('')\n        if i >= (len(pid_grouped) - n_cols):\n            ax.set_xlabel('Sample')\n    fig.tight_layout()\n    _ = ax.legend(ncol=15, loc='lower center', bbox_to_anchor=(.5, 1), bbox_transform=fig.transFigure)","754ffade":"coi = ['coolant', 'pm', 'stator_yoke', 'stator_tooth', 'stator_winding', 'ambient']\nparameter_visualizer(pid_grouped, coi, ylabel='Temperature in \u00b0C', n_cols=4)","00a6866b":"coi = ['u_q', 'u_d']\nparameter_visualizer(pid_grouped, coi, 'Voltage in V', 4)","601c7ebf":"coi = ['i_q', 'i_d']\nparameter_visualizer(pid_grouped, coi, 'Current in A', 4)","7cf6fc59":"coi = ['motor_speed']\nparameter_visualizer(pid_grouped, coi, 'Voltage in V', 4)","0b1cce3f":"coi = ['torque']\nparameter_visualizer(pid_grouped, coi, 'Voltage in V', 4)","6c0e37ac":"sessions.index","77cc4598":"n_cols = 4\nn_rows = int(np.ceil(len(pid_grouped) \/ n_cols))\n\nfig, axes = plt.subplots(n_rows, n_cols, figsize=(4*n_cols, n_rows*3), sharey=True, sharex=True)\n\nfor i, (ax, (p_id, df_)) in enumerate(zip(axes.flatten(), pid_grouped.items())):\n    \n    ax.plot(df_['motor_speed'], df_['torque'])\n    ax.set_title(f'profile {p_id} - {sessions[p_id]:.2} hours')\n    ax.set_ylabel('Torque in N*m')\n    ax.set_xlabel('Motor speed in RPM')\n        \nfig.tight_layout()\n_ = ax.legend(ncol=15, loc='lower center', bbox_to_anchor=(.5, 1), bbox_transform=fig.transFigure)","28828f5e":"N_BINS = 1000\ndfui = df.assign(binned_torque=pd.cut(df.torque.values.flatten(), bins=N_BINS, include_lowest=True),\n                 binned_speed=pd.cut(df.motor_speed.values.flatten(), bins=N_BINS, include_lowest=True))\n\nts_map = dfui.loc[:, ['binned_torque', 'binned_speed', 'torque']]\\\n            .groupby(['binned_torque', 'binned_speed']).count().fillna(0).reset_index()\\\n            .rename(columns={'torque': 'count'})\\\n            .pivot(index='binned_torque', columns='binned_speed', values='count')\\\n            .sort_values('binned_torque', ascending=False)\nplt.figure(figsize=(12, 8))\nax = sns.heatmap(ts_map, cmap='plasma', robust=True, square=True, yticklabels=490, xticklabels=490, cbar_kws={\"shrink\" : 0.5})\n_ = ax.set_ylabel('Torque p.u.')\n_ = ax.set_xlabel('Motor speed p.u.')\n_ = ax.set_xticklabels([0, 0.5, 1], rotation=0)\n_ = ax.set_yticklabels([1, 0, -1])\nplt.tight_layout()","ddf20167":"Seems like the data is pretty clean!\n\nWe can see from the description of the features that the measurements are per recording session. Let's find out about for how long each session lasted and the general demographics about this feature (basically peek at how many hours does a recording session typically take). To do this I will convert the 2HZ sampling rate (2 data points per second) into hours","9c7ae728":"The heat loss and cooling modes of a permanent magnet synchronous motor (PMSM) directly affect its temperature rise. The accurate evaluation and prediction of stator winding temperature is of great significance to the safety and reliability of PMSMs. ([Article: Predicting Temperature of Permanent Magnet\nSynchronous Motor Based on Deep Neural Network](https:\/\/www.researchgate.net\/publication\/344972500_Predicting_Temperature_of_Permanent_Magnet_Synchronous_Motor_Based_on_Deep_Neural_Network))\n\nThis dataset provides readings from several sensors fitted to monitor the main two pieces of PMSMs, namely the **stator** and the **rotor**. Below image showcases the components under consideration.\n\n![image.png](attachment:bd7b5e18-54ac-4bbb-a159-f947a69466ac.png)\n\nGenerally, due to presence of moving parts working under various states of the motor speed and torque (a point at the motor speed x torque plain) thermal losses will be generated which impact the equipment in the long run shortening its lifespan. The copper loss of a permanent magnet motor stator directly affects the heating degree of the stator winding.","e4f6f399":"Below is a simple description of the data from the sensors mentioned above:\n\n* \" **u_q** \": q component of Voltage measured in Volts0\n* \" **u_d** \": d component of Voltage measured in Volts\n* \" **i_q** \": q component of Current measured in Amps\n* \" **i_d** \": d component of Current measured in Amps\n* \" **ambient** \": ambient temperature around the stator in \u00b0C (measured by a thermal sensor fixed close to stator)\n* \" **coolant** \": motor coolant (water in this case) temperature of the motor in \u00b0C (measured by a fixed thermal sensor at coolant outlet)\n* \" **motor speed** \": ambient temperature around the stator in \u00b0C (measured by a fixed thermal sensor)\n* \" **stator_tooth** \": stator tooth temperature in \u00b0C\n* \" **stator_winding** \": stator winding temperature in \u00b0C\n* \" **stator_yoke** \": stator yoke temperature in \u00b0C\n* \" **pm** \": permanent magnet tooth temperature in \u00b0C\n* \" **profile_id** \": id of the measurement session\n\nPs. all the data point are recorded in 2Hz (one row per 0.5 seconds)","d49ea701":"Now let's have a look at the distributions of all the features we'll be working with","f20ac840":"# Briefly about the task Permanent Magnet Synchronous Motor","41d142fe":"Now we check for missing data and see if there is any that we need to deal with","e1496da0":"# Exploratory Data Analysis","d0886274":"# Time Series Data Visualization\n\nNow we should kleep in mind that the data represents a time series per measurement session. So we better visualize the data in its intended nature to get the better idea of how they act up through each session. ","b45207f4":"Let's get some quick look at the data and see what it's like","d5ead55f":"Reading the data from the source","c7da0ced":"# Visualizing the **Motor Speed x Torque Plain**\n\nThis is an important step as all the measurement sessions try to simulate the conditions a PMSM might be subject to during its lifetime. This is described as the point a motor is at certain timeslice on the Motor Speed x Torque plain. With this we'll be able to see how well each of the sessions simulate the real working conditions","14472c08":"Let's see how these features relate to each other, in technical terms we'll now find out about the linear correlation across all the available features through a heatmap (the hotter the color, the higher the correlation). To better visualize the graph we'll just leave out the upper triangle and display each coefficient of correlation on its respective box. You can see a colorbar to the right outlining the colorcoding of the heatmap","4e43a970":"# Importing libraries and setting plot styles","ccf08ea6":"And with the above we can see that some of the measurements were not performed optimally and ** most probably the data gathered during those sessions (sessions 1-50 for example) cannot represent a device's lifetime well.** Some others cover this plane rather decently. It should be noted that this is not a result of how long or short the measurement session is which becomes lucid if the session length at the title of each graph is payed attention to. Now let's see what a general speed-to-torque plain looks like. Mind that the shape of this plain is determined by the physical limits of the parametres under scrutiny"}}