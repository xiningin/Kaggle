{"cell_type":{"b67a251f":"code","e8219180":"code","167f6baa":"code","36f632e6":"code","349fb98b":"code","45c96baf":"code","2a241282":"code","51e4f42d":"code","45e028d0":"code","30444e41":"code","8c13680f":"code","c3fbf53d":"code","de1b7360":"code","5ceecf57":"code","dd92e995":"code","c218dfc7":"code","1c570394":"code","38fa93ba":"code","c1a80f59":"code","6206df95":"code","92ca0e12":"code","92b7c3cb":"code","da19a1d0":"code","8b53c861":"code","209150e6":"markdown","2ee0d976":"markdown","62ba2963":"markdown","df640d03":"markdown","266b83bb":"markdown"},"source":{"b67a251f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os","e8219180":"N = 3\nsolution = \"121\"\n\nfor N in range(3,8):\n    new_solution = []\n    for i in range(len(solution)-N+2):\n        substring = solution[i:i+(N-1)]\n        if all(str(x) in substring for x in range(1,N)):\n            new_solution.append(substring+str(N)+substring)\n    solution = new_solution[:1]\n    for i in range(len(new_solution)-1):\n        x1 = new_solution[i]\n        x2 = new_solution[i+1]\n        for j in range(1,len(x1)+1):\n            if x2[:j]==x1[-1*j:]:\n                break\n        solution.append(x2[j:])\n    solution = \"\".join(solution)\n    print(N,len(solution))\n\nsolution = solution.replace('1','t')\nsolution = solution.replace('7','1')\nsolution = solution.replace('t','7')\nsolution = solution.replace('2','t')\nsolution = solution.replace('6','2')\nsolution = solution.replace('t','6')","167f6baa":"solutions = {}\nsub_perms = {}\nordered_solutions = []\nstart_idx = 0\nsol = []\nfor i in range(len(solution)-6):\n    perm = solution[i:i+7]\n    if ''.join((sorted(perm)))=='1234567':\n        if start_idx==-1:\n            start_idx = i\n            sol = []\n        sol.append(perm)\n        if perm.startswith('12'):\n            end_idx = i+7\n            \n            solutions[perm] = solution[start_idx:end_idx]\n            sub_perms[perm] = sol\n            print(len(solutions[perm]),end=\" \")\n            ordered_solutions.append(solutions[perm])\n            start_idx = -1","36f632e6":"ordered_solutions[0]","349fb98b":"len(ordered_solutions),len(ordered_solutions[0])","45c96baf":"modified_substring_list = []\nmodified_substring_category = []\nmodified_substring_group = []\n\nfor substring in ordered_solutions:\n    modified_substring = substring[-1]+'12'+substring[:-2]+substring[-1]+substring[-2]+'12'\n    modified_substring_list.append(modified_substring)\n    modified_substring_category.append(substring[-1]+substring[-2])\n    modified_substring_group.append(substring[:3])\n    print('original:',substring)\n    print('modified:',modified_substring)\n    print()\nmodified_substring_list = np.array(modified_substring_list)\nmodified_substring_category = np.array(modified_substring_category)\nmodified_substring_group = np.array(modified_substring_group)","2a241282":"print(len(modified_substring_list[0]))","51e4f42d":"from sklearn.model_selection import StratifiedKFold\nskf = StratifiedKFold(n_splits=3)\n\n## Split substrings in 3 sets\ndf = pd.DataFrame([modified_substring_group,modified_substring_category],index=['group','category']).T.sort_values(['group','category'])\ndf = df.reset_index(drop=True)\ndf_subset = df[df.category==df.category.apply(lambda x:''.join(sorted(x)))].reset_index(drop=True)\ncategory_encodings = {x:i for i,x in enumerate(df_subset.category.unique())}\ndf_subset['encoded_cat'] = df_subset.category.apply(lambda x: category_encodings[x])\nfor split,(train_index, test_index) in enumerate(skf.split(df_subset, df_subset.encoded_cat)):\n    df_subset.loc[test_index,'split'] = split\ntemp_splits = df_subset.set_index(['group','category']).split.to_dict()\n\nsplits = {}\nfor group,category in temp_splits:\n    splits[(group,category)] = int(temp_splits[(group,category)])\n    category_reversed = category[-1]+category[0]\n    splits[(group,category_reversed)] = int((temp_splits[(group,category)]+1)%3)\n    \ndf_subset.split.value_counts()","45e028d0":"splitted_substrings = [[],[],[]]\nsplitted_categories = [[],[],[]]\ncategory2substring = [{},{},{}]\n\nfor i in range(120):\n    substring = modified_substring_list[i]\n    category = modified_substring_category[i]\n    group = modified_substring_group[i]\n    split = int(splits[group,category])\n    splitted_substrings[split].append(substring)\n    splitted_categories[split].append(category)\n    if category not in category2substring[split]:\n        category2substring[split][category] = []\n    category2substring[split][category].append(substring)","30444e41":"!wget http:\/\/webhotel4.ruc.dk\/~keld\/research\/LKH-3\/LKH-3.0.7.tgz \n!tar xvfz LKH-3.0.7.tgz \n!cd LKH-3.0.7; make ","8c13680f":"def get_tsp_solution(distance_matrix,timer=30,verbose=0):\n    \n    # CREATE DISTANCE MATRIX\n    SIZE = len(distance_matrix)\n    M = distance_matrix.astype(int)\n            \n    # WRITE PROBLEM FILE\n    f = open(f'group.par','w')\n    f.write(\"PROBLEM_FILE = ..\/distances.atsp\\n\")\n    f.write(\"TOUR_FILE = ..\/output.txt\\n\")\n    f.write(f\"OPTIMUM = {SIZE}\\n\")\n    f.write(f\"BACKTRACKING = YES\\n\")\n    f.write(f\"MAX_CANDIDATES = 7 SYMMETRIC\\n\")\n    f.write(\"MOVE_TYPE = 3\\n\")\n    f.write(\"PATCHING_C = 3\\n\")\n    f.write(\"PATCHING_A = 2\\n\")\n    f.write(\"RUNS = 1\\n\")\n    f.write(f\"TIME_LIMIT = {timer}\\n\") #seconds\n    f.close()\n    \n    # WRITE PARAMETER FILE\n    f = open(f'distances.atsp','w')\n    f.write(\"NAME: distances\\n\")\n    f.write(\"TYPE: ATSP\\n\")\n    f.write(\"COMMENT: Asymmetric TSP\\n\")\n    f.write(f\"DIMENSION: {SIZE}\\n\")\n    f.write(\"EDGE_WEIGHT_TYPE: EXPLICIT\\n\")\n    f.write(\"EDGE_WEIGHT_FORMAT: FULL_MATRIX\\n\")\n    f.write(\"EDGE_WEIGHT_SECTION\\n\")\n    for j in range(SIZE):\n        #if j%25==0: print(j,', ',end='')\n        for k in range(SIZE):\n            f.write(f\"{M[j,k]:2d} \") \n        f.write(\"\\n\")\n    f.close()\n    \n    # EXECUTE TSP SOLVER\n    \n    if verbose==0:\n        !cd LKH-3.0.7; .\/LKH ..\/group.par >> out.txt\n    else:\n        !cd LKH-3.0.7; .\/LKH ..\/group.par\n    \n    # READ RESULTING ORDER\n    with open('output.txt') as f:\n        lines = f.readlines()\n    for i,ln in enumerate(lines):\n        if 'TOUR_SECTION' in ln: break\n    perms = [int(x[:-1]) for x in lines[i+1:-2] ]\n    \n    \n    return perms","c3fbf53d":"output_strings = []\noutput_strings_list = [[],[],[]]\nfor split in range(3):\n    print(\"Solving for split\",split)\n    substrings = splitted_substrings[split]\n    categories = splitted_categories[split]\n\n    distance_matrix = np.ones((len(categories),len(categories)))\n    for i,cat1 in enumerate(categories):\n        for j,cat2 in enumerate(categories):\n            if cat1[1]==cat2[0]:\n                distance_matrix[i,j] = 0\n                \n    solution = get_tsp_solution(distance_matrix,verbose=0)\n\n    \n    output_string = \"\"\n    for idx in solution:\n        output_strings_list[split].append(substrings[idx-1])\n        if len(output_string)==0:\n            output_string += substrings[idx-1]\n            \n        else:\n            output_string += substrings[idx-1][3:]\n    print(\"length of solution\",len(output_string))\n    output_strings.append(output_string)","de1b7360":"## Checking if solution is valid\nimport itertools\nLETTERS = list(map(str,range(1,8)))\npermutations = [''.join(x) for x in itertools.permutations(LETTERS)]\nmandatory = [x for x in permutations if x.startswith('12')]\nnon_mandatory = [x for x in permutations if not x.startswith('12')]\nprint(len(permutations),len(mandatory),len(non_mandatory))","5ceecf57":"for x in non_mandatory:\n    assert x in \"|\".join(output_strings)","dd92e995":"len(non_mandatory)","c218dfc7":"global_counter = 0 \nrepeated = []\nfor x in non_mandatory:\n    counter = 0\n    if x in output_strings[0]:\n        counter += 1\n    if x in output_strings[1]:\n        counter += 1\n    if x in output_strings[2]:\n        counter += 1\n    if counter>=2:\n        global_counter += 1\n        repeated.append(x)\nglobal_counter","1c570394":"for i in range(5):\n    print(repeated[i])","38fa93ba":"for i in range(3):\n    for x in mandatory:\n        if x not in output_strings[i]:\n            output_strings[i] = output_strings[i]+x","c1a80f59":"for i in range(3):\n    print(len(output_strings[i]))","6206df95":"LETTERS = [\n    '\ud83c\udf85',  # father christmas\n    '\ud83e\udd36',  # mother christmas\n    '\ud83e\udd8c',  # reindeer\n    '\ud83e\udddd',  # elf\n    '\ud83c\udf84',  # christmas tree\n    '\ud83c\udf81',  # gift\n    '\ud83c\udf80',  # ribbon\n]","92ca0e12":"for i,x in enumerate(LETTERS):\n    for j in range(3):\n        output_strings[j] = output_strings[j].replace(str(i+1),x)","92b7c3cb":"for i,x in enumerate(LETTERS):\n    for j in range(3):\n        output_strings[j] = output_strings[j].replace(str(i+1),x)","da19a1d0":"output_strings[0]","8b53c861":"# WRITE SUBMISSION CSV\nsub = pd.DataFrame()\nsub['schedule'] = [output_strings[0], output_strings[1], output_strings[2]]\nsub.to_csv('submission_baseline.csv',index=False)\nsub.head()","209150e6":"## ATSP","2ee0d976":"## Achieving 5913 solutions","62ba2963":"## Merging these 120 sequences\n\nIf we observe, each of these cycles begin with 'X12' and end with 'Y12'. We merge 2 sequences left-to-right if Y of left sequence (third last symbol) is equal to X of right sequence","df640d03":"## Modify these 120 cycles so that each of output sequence contains 2 mandatory groups","266b83bb":"## Splitting 5913 solution to 120 cycles of length 53"}}