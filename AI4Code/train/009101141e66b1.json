{"cell_type":{"57e45126":"code","9a4c0c93":"code","6b58580a":"code","7da56d1a":"code","c23a0f0e":"code","eac61ef3":"code","eedd83e1":"code","73726f5c":"code","579016f3":"markdown","d70331f2":"markdown","e8c4968e":"markdown","a0e6f8df":"markdown","069dd128":"markdown","a9d4010f":"markdown"},"source":{"57e45126":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","9a4c0c93":"import pandas as pd\nimport numpy as np\n\nimport torch\nimport torchvision.datasets as data\nimport torchvision.transforms as transforms\nimport random\n\nfrom sklearn import preprocessing\n\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\n\nrandom.seed(777)\ntorch.manual_seed(777)\nif device == 'cuda':\n  torch.cuda.manual_seed_all(777)\n\ntrain_data=pd.read_csv('\/kaggle\/input\/horse-win-rate\/train-horse-win-rate.csv',header=None,skiprows=1,usecols=range(1,8))\ntest_data=pd.read_csv('\/kaggle\/input\/horse-win-rate\/test-horse-win-rate.csv',header=None,skiprows=1,usecols=range(1,7))","6b58580a":"learning_rate = 0.01\ntraining_epochs = 200\nbatch_size = 1\nScaler = preprocessing.StandardScaler()","7da56d1a":"x_train_data=train_data.loc[:,0:6]\ny_train_data=train_data.loc[:,7]\n\nx_train_data=np.array(x_train_data)\ny_train_data=np.array(y_train_data)\nx_train_data = Scaler.fit_transform(x_train_data)\n\nx_train_data=torch.FloatTensor(x_train_data)\ny_train_data=torch.FloatTensor(y_train_data)\n\ntrain_dataset = torch.utils.data.TensorDataset(x_train_data, y_train_data)\ndata_loader = torch.utils.data.DataLoader(dataset=train_dataset,\n                                            batch_size=batch_size,\n                                            shuffle=True,\n                                            drop_last=True)","c23a0f0e":"linear1 = torch.nn.Linear(6,6,bias=True)\nlinear2 = torch.nn.Linear(6,1,bias=True)\n\nrelu = torch.nn.LeakyReLU()","eac61ef3":"torch.nn.init.kaiming_uniform_(linear1.weight)\ntorch.nn.init.kaiming_uniform_(linear2.weight)","eedd83e1":"model = torch.nn.Sequential(linear1, relu,\n                            linear2,).to(device)\nloss = torch.nn.MSELoss().to(device)\noptimizer = torch.optim.Adam(model.parameters(), lr=learning_rate) \n\ntotal_batch = len(data_loader)\nfor epoch in range(training_epochs):\n  avg_cost = 0\n\n  for X, Y in data_loader:\n    \n    X = X.to(device)\n    Y = Y.to(device)\n\n    # \uadf8\ub798\ub514\uc5b8\ud2b8 \ucd08\uae30\ud654\n    optimizer.zero_grad()\n    # Forward \uacc4\uc0b0\n    hypothesis = model(X)\n    # Error \uacc4\uc0b0\n    cost = loss(hypothesis, Y)\n    # Backparopagation\n    cost.backward()\n    # \uac00\uc911\uce58 \uac31\uc2e0\n    optimizer.step()\n\n    # \ud3c9\uade0 Error \uacc4\uc0b0\n    avg_cost += cost \/ total_batch\n\n    print('Epoch:', '%04d' % (epoch + 1), 'cost =', '{:.9f}'.format(avg_cost))\n    \n  print('Learning finished')","73726f5c":"with torch.no_grad():\n\n  x_test_data=test_data.loc[:,:]\n  x_test_data=np.array(x_test_data)\n  x_test_data = Scaler.transform(x_test_data)\n  x_test_data=torch.from_numpy(x_test_data).float().to(device)\n\n  prediction = model(x_test_data)\ncorrect_prediction = prediction.cpu().numpy().reshape(-1,1)\n\nsubmit=pd.read_csv('\/kaggle\/input\/horse-win-rate\/submit_sample.csv')\nfor i in range(len(correct_prediction)):\n  submit['Expected'][i]=correct_prediction[i].item()\n\nsubmit\n\nsubmit.to_csv('baseline.csv',index=False,header=True)\n\n!kaggle competitions submit -c horse-win-rate -f baseline.csv -m \"submmit\"","579016f3":"# \ubaa8\ub378 \ud559\uc2b5","d70331f2":"# \ubaa8\ub378 \ud3c9\uac00","e8c4968e":"* He initialization","a0e6f8df":"# \uc124\uba85 \ub3d9\uc601\uc0c1 \ub9c1\ud06c\n[ https:\/\/youtu.be\/DmUjdIO96Js ]","069dd128":"* Activation Function: LeakyReLU","a9d4010f":"# NN \ubaa8\ub378 \uc815\uc758"}}