{"cell_type":{"c1e38dd1":"code","77810b32":"code","d646c24b":"code","3c23dbe5":"code","1c2f9da8":"code","7a626943":"code","fb7b3828":"code","6d498a55":"code","17601814":"code","b6bbdaf3":"code","293b2e19":"code","2aec4b17":"code","4188fa83":"code","02962596":"code","6faba909":"code","6ef5866b":"code","dfadcdc4":"code","1c606c64":"code","3fc41b6f":"code","9b852f80":"code","f6ede44e":"code","de4661af":"markdown","d05ccb7c":"markdown","ac4ff6d0":"markdown","b4e4afe0":"markdown","a643c166":"markdown","1308372f":"markdown"},"source":{"c1e38dd1":"%matplotlib inline\nimport matplotlib.pyplot as plt\nimport random\nimport os\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport cv2\nimport os\nimport tensorflow as tf\nimport keras.backend as K\nfrom keras.applications import Xception\nfrom keras.layers import UpSampling2D, Conv2D, Activation, LeakyReLU, BatchNormalization\nfrom keras import Model\nfrom keras.losses import binary_crossentropy\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint\nfrom tqdm import tqdm_notebook\nprint(os.listdir(\"..\/input\"))","77810b32":"train = pd.read_csv('..\/input\/severstal-steel-defect-detection\/train.csv')\ntrain['defect'] = train['EncodedPixels'].notnull()\ntrain['ClassId'] = train['ImageId_ClassId'].str[-1:]\ntrain['ImageId'] = train['ImageId_ClassId'].str[:-2]\ntrain = train[['ImageId','ClassId','defect','EncodedPixels']]\ntrain = train[train.defect]","d646c24b":"def mask2rle(img):\n    tmp = np.rot90( np.flipud( img ), k=3 )\n    rle = []\n    lastColor = 0;\n    startpos = 0\n    endpos = 0\n\n    tmp = tmp.reshape(-1,1)   \n    for i in range( len(tmp) ):\n        if (lastColor==0) and tmp[i]>0:\n            startpos = i\n            lastColor = 1\n        elif (lastColor==1)and(tmp[i]==0):\n            endpos = i-1\n            lastColor = 0\n            rle.append( str(startpos)+' '+str(endpos-startpos+1) )\n    return \" \".join(rle)\n\ndef rle2mask(rle, imgshape):\n    width = imgshape[0]\n    height= imgshape[1]\n    \n    mask= np.zeros( width*height ).astype(np.uint8)\n    \n    array = np.asarray([int(x) for x in rle.split()])\n    starts = array[0::2]\n    lengths = array[1::2]\n\n    current_position = 0\n    for index, start in enumerate(starts):\n        mask[int(start):int(start+lengths[index])] = 1\n        current_position += lengths[index]\n        \n    return np.flipud( np.rot90( mask.reshape(height, width), k=1 ) )\n\ndef rle2mask_eda(mask_rle, shape=(1600,256)):\n    '''\n    mask_rle: run-length as string formated (start length)\n    shape: (width,height) of array to return \n    Returns numpy array, 1 - mask, 0 - background\n\n    '''\n    s = mask_rle.split()\n    starts, lengths = [np.asarray(x, dtype=int) for x in (s[0:][::2], s[1:][::2])]\n    starts -= 1\n    ends = starts + lengths\n    img = np.zeros(shape[0]*shape[1], dtype=np.uint8)\n    for lo, hi in zip(starts, ends):\n        img[lo:hi] = 1\n    return img.reshape(shape).T","3c23dbe5":"train = pd.read_csv('..\/input\/severstal-steel-defect-detection\/train.csv')\ntrain['defect'] = train['EncodedPixels'].notnull()\ntrain['ClassId'] = train['ImageId_ClassId'].str[-1:]\ntrain['ImageId'] = train['ImageId_ClassId'].str[:-2]\ntrain = train[['ImageId','ClassId','defect','EncodedPixels']]\ntrain = train[train.defect]\nmask2rle(rle2mask_eda(train['EncodedPixels'].iloc[1]))==train['EncodedPixels'].iloc[1]","1c2f9da8":"# ref: https:\/\/www.kaggle.com\/paulorzp\/eda-and-opencv-starter\ncolumns = 2\nrows = 10\nfig = plt.figure(figsize=(20,columns*rows+2))\nfor i in range(1,columns*rows+1):\n    fn = train['ImageId'].iloc[i]\n    c = train['ClassId'].iloc[i]\n    fig.add_subplot(rows, columns, i).set_title(fn+\"  ClassId=\"+c)\n    img = cv2.imread( '..\/input\/severstal-steel-defect-detection\/train_images\/'+fn )\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    mask = rle2mask_eda(train['EncodedPixels'].iloc[i])\n    img[mask==1,0] = 255\n    plt.imshow(img)\nplt.show()","7a626943":"df_train = pd.read_csv('..\/input\/severstal-steel-defect-detection\/train.csv')\ndf_train = df_train[df_train['EncodedPixels'].notnull()].reset_index(drop=True)","fb7b3828":"IMG_SIZE = 256\nBATCH_SIZE = 4\nEPOCHS = 30\nPATIENCE = 7","6d498a55":"#ref: https:\/\/www.kaggle.com\/ateplyuk\/keras\ndef keras_generator(batch_size):\n    while True:\n        x_batch = []\n        y_batch = []\n        \n        for i in range(batch_size):            \n            fn = df_train['ImageId_ClassId'].iloc[i].split('_')[0]\n            img = cv2.imread( '..\/input\/severstal-steel-defect-detection\/train_images\/'+fn )\n            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)            \n            \n            mask = rle2mask(df_train['EncodedPixels'].iloc[i], img.shape)\n            \n            img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))\n            mask = cv2.resize(mask, (IMG_SIZE, IMG_SIZE))\n            \n            x_batch += [img]\n            y_batch += [mask]\n                                    \n        x_batch = np.array(x_batch)\n        y_batch = np.array(y_batch)\n\n        yield x_batch, np.expand_dims(y_batch, -1)","17601814":"def dice_coef(y_true, y_pred):\n    y_true_f = K.flatten(y_true)\n    y_pred = K.cast(y_pred, 'float64')\n    y_pred_f = K.cast(K.greater(K.flatten(y_pred), 0.8), 'float64')\n    intersection = y_true_f * y_pred_f\n    score = 2. * K.sum(intersection) \/ (K.sum(y_true_f) + K.sum(y_pred_f))\n    return score\n\ndef dice_loss(y_true, y_pred):\n    smooth = 1.\n    y_true_f = K.flatten(y_true)\n    y_pred_f = K.flatten(y_pred)\n    intersection = y_true_f * y_pred_f\n    score = (2. * K.sum(intersection) + smooth) \/ (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)\n    return 1. - score\n\ndef bce_dice_loss(y_true, y_pred):\n    return binary_crossentropy(y_true, y_pred) + dice_loss(y_true, y_pred)","b6bbdaf3":"#ref: https:\/\/www.kaggle.com\/cpmpml\/fast-iou-metric-in-numpy-and-tensorflow\ndef get_iou_vector(A, B):\n    # Numpy version    \n    batch_size = A.shape[0]\n    metric = 0.0\n    for batch in range(batch_size):\n        t, p = A[batch], B[batch]\n        true = np.sum(t)\n        pred = np.sum(p)\n        \n        # deal with empty mask first\n        if true == 0:\n            metric += (pred == 0)\n            continue\n        \n        # non empty mask case.  Union is never empty \n        # hence it is safe to divide by its number of pixels\n        intersection = np.sum(t * p)\n        union = true + pred - intersection\n        iou = intersection \/ union\n        \n        # iou metrric is a stepwise approximation of the real iou over 0.5\n        iou = np.floor(max(0, (iou - 0.45)*20)) \/ 10\n        \n        metric += iou\n        \n    # teake the average over all images in batch\n    metric \/= batch_size\n    return metric\n\n\ndef iou_metric(label, pred):\n    # Tensorflow version\n    return tf.py_func(get_iou_vector, [label, pred > 0.8], tf.float64)","293b2e19":"def get_callback(patient):\n    ES = EarlyStopping(\n        monitor='loss', \n        patience=patient, \n        mode='max', \n        verbose=1)\n    RR = ReduceLROnPlateau(\n        monitor = 'loss', \n        factor = 0.5, \n        patience = patient \/ 2, \n        min_lr=0.000001, \n        verbose=1, \n        mode='max')\n    return [ES, RR]","2aec4b17":"base_model = Xception(weights=None, input_shape=(IMG_SIZE,IMG_SIZE,3), include_top=False)\nbase_model.load_weights('..\/input\/keras-pretrained-models\/xception_weights_tf_dim_ordering_tf_kernels_notop.h5')\n\nbase_out = base_model.output\nup1 = UpSampling2D(32, interpolation='bilinear')(base_out)\nconv1 = Conv2D(1, (1, 1))(up1)\nconv1 = Activation('sigmoid')(conv1)\n#bn1 = BatchNormalization()(conv1)\n# re2 = LeakyReLU(0.2)(bn1)\n# up2 = UpSampling2D(16, interpolation='bilinear')(re2)\n# conv2 = Conv2D(1, (1, 1))(up2)\n# conv2 = Activation('sigmoid')(conv2)\n\nmodel = Model(base_model.input, conv1)\nmodel.compile(loss=bce_dice_loss, optimizer='adam', metrics=[iou_metric])","4188fa83":"history = model.fit_generator(keras_generator(BATCH_SIZE),\n                              steps_per_epoch=len(df_train.index)\/EPOCHS,                    \n                              epochs=EPOCHS,                    \n                              verbose=1,\n                              shuffle=True,\n                              callbacks = get_callback(PATIENCE)\n)","02962596":"plt.figure(figsize=(7, 7), dpi= 80, facecolor='w', edgecolor='k')\nplt.plot(history.history['loss']) \nplt.title('model loss')  \nplt.ylabel('loss')  \nplt.xlabel('epoch')  \nplt.legend(['train'], loc='upper left')  \nplt.show()","6faba909":"plt.figure(figsize=(7, 7), dpi= 80, facecolor='w', edgecolor='k')\nplt.plot(history.history['iou_metric']) \nplt.title('model iou_metric')  \nplt.ylabel('iou_metric')  \nplt.xlabel('epoch')  \nplt.legend(['train'], loc='upper left')  \nplt.show()","6ef5866b":"%%time\ntest_img = []\ntestfiles=os.listdir(\"..\/input\/severstal-steel-defect-detection\/test_images\/\")\nfor fn in tqdm_notebook(testfiles):\n        img = cv2.imread( '..\/input\/severstal-steel-defect-detection\/test_images\/'+fn )\n        img = cv2.resize(img,(IMG_SIZE,IMG_SIZE))       \n        test_img.append(img)","dfadcdc4":"%%time\ntest_datagen = ImageDataGenerator()\ntest_generator = test_datagen.flow(\n    np.asarray(test_img),\n    batch_size=BATCH_SIZE\n)\n\ntestfiles=os.listdir(\"..\/input\/severstal-steel-defect-detection\/test_images\/\")\nnb_samples = len(testfiles)\npredict = model.predict_generator(test_generator, steps = nb_samples\/BATCH_SIZE)","1c606c64":"%%time\npred_rle = []\nfor img in predict:      \n    img = cv2.resize(img, (1600, 256))\n    tmp = np.copy(img)\n    #tmp[tmp<np.mean(img)] = 0\n    tmp[tmp<0.8] = 0\n    tmp[tmp>0] = 1\n    pred_rle.append(mask2rle(tmp))","3fc41b6f":"img_t = cv2.imread( '..\/input\/severstal-steel-defect-detection\/test_images\/'+ testfiles[4])\nplt.imshow(img_t)\nplt.show()\n\nmask_t = rle2mask(pred_rle[4], img.shape)\nplt.imshow(mask_t)\nplt.show()","9b852f80":"pred_rle_4 = []\nfor _ in pred_rle:\n    pred_rle_4.extend([_, _, _, _])    \nlen(pred_rle_4)","f6ede44e":"sub = pd.read_csv( '..\/input\/severstal-steel-defect-detection\/sample_submission.csv' )\nsub['EncodedPixels'] = pred_rle_4\nsub.to_csv('submission.csv', index=False)\nsub.head(10)","de4661af":"## 2. Xception Model in Keras","d05ccb7c":"# Xception Baseline Model for Starter in Keras\n## Severstal: Steel Defect Detection\n\nThis kernel is based on [EDA and OpenCV Starter](https:\/\/www.kaggle.com\/paulorzp\/eda-and-opencv-starter) and [Keras](https:\/\/www.kaggle.com\/ateplyuk\/keras).\n\n__Xception Model__ using __bce_dice_loss__ is applied.\n\n## Contents\n1. Introduction <br\/>\n2. Xception Model in Keras <br\/>\n3. Training <br\/>\n4. Prediction and Plot Result <br\/>\n5. Submission <br\/>","ac4ff6d0":"## 4. Training","b4e4afe0":"## 5. Submission","a643c166":"## 4. Prediction & Plot Prediction Result","1308372f":"## 1. Introduction\n\n![](https:\/\/raw.githubusercontent.com\/seriousmac\/img_link\/master\/kg\/01.jpeg)\n\n> In this competition, you\u2019ll help engineers improve the algorithm by localizing and classifying surface defects on a steel sheet.\n\n### Xception Model\n\n- Xception V1 model, with weights pre-trained on ImageNet.\n- On ImageNet, this model gets to a top-1 validation accuracy of 0.790 and a top-5 validation accuracy of 0.945.\n![](https:\/\/raw.githubusercontent.com\/seriousmac\/img_link\/master\/kg\/02.PNG)\n- ref: [Xception: Deep Learning with Depthwise Separable Convolutions](https:\/\/arxiv.org\/abs\/1610.02357)\n\n### View Defects and Classes"}}