{"cell_type":{"604004d9":"code","372831f5":"code","72d57d18":"code","9f5dc082":"code","59e8112d":"code","3d2ad100":"code","cc3c98d8":"code","dd88e8f1":"code","fb80ad1f":"code","6f0c4a4e":"code","a009b081":"code","37f3101a":"code","e3c3035e":"code","5984858e":"markdown","b73cbc66":"markdown","12b38064":"markdown","c0d0d61c":"markdown","678bb8b0":"markdown","77e731de":"markdown","f1167310":"markdown","4f42a2f0":"markdown","35a6933c":"markdown","f73fdd76":"markdown","7f8709bb":"markdown","23dc8253":"markdown","71620dfd":"markdown","56310d15":"markdown","6e3116e5":"markdown"},"source":{"604004d9":"import time\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nimport copy\n%matplotlib inline","372831f5":"def mandelbrot(xpixels=600, maxiter=100, xmin=-2.6, xmax=1.85, ymin=-1.25, ymax=1.25):\n\n    # Compute ypixels so the image is not stretched (1:1 ratio)\n    ypixels = round(xpixels \/ (xmax-xmin) * (ymax-ymin))\n    \n    # Initialisation of result to 0\n    mat = np.zeros((xpixels, ypixels))\n    \n    # Looping through pixels\n    for x in range(xpixels):\n        for y in range(ypixels):\n            \n            # Mapping pixel to C\n            creal = xmin + x \/ xpixels * (xmax - xmin)\n            cim = ymin + y \/ ypixels * (ymax - ymin)\n            \n            # Initialisation of C and Z\n            c = complex(creal, cim)\n            z = complex(0, 0)\n            \n            # Mandelbrot iteration\n            for n in range(maxiter):\n                z = z*z + c\n                # If unbounded: save iteration count and break\n                if z.real*z.real + z.imag*z.imag > 4.0:\n                    # Smooth iteration count\n                    mat[x,y] = n + 1 - math.log(math.log(abs(z*z+c)))\/math.log(2)\n                    break\n                # Otherwise: leave it to 0\n    return(mat)","72d57d18":"def draw_image(mat, cmap='inferno', powern=0.5, dpi=72):\n    ## Value normalization\n    # Apply power normalization, because number of iteration is \n    # distributed according to a power law (fewer pixels have \n    # higher iteration number)\n    mat = np.power(mat, powern)\n    \n    # Colormap: set the color the black for values under vmin (inner points of\n    # the set), vmin will be set in the imshow function\n    new_cmap = copy.copy(cm.get_cmap(cmap))\n    new_cmap.set_under('black')\n    \n    ## Plotting image\n    \n    # Figure size\n    plt.figure(figsize=(mat.shape[0]\/dpi, mat.shape[1]\/dpi))\n    \n    # Plotting mat with cmap\n    # vmin=1 because smooth iteration count is always > 1\n    # We need to transpose mat because images use row-major\n    # ordering (C convention)\n    # origin='lower' because mat[0,0] is the lower left pixel\n    plt.imshow(mat.T, cmap=new_cmap, vmin=1, origin = 'lower')\n    \n    # Remove axis and margins\n    plt.subplots_adjust(left=0, right=1, bottom=0, top=1)\n    plt.axis('off')","9f5dc082":"# Running and plotting result\nmat = mandelbrot()\ndraw_image(mat)","59e8112d":"# Measuring computation time\n%timeit -n 10 -r 3 mandelbrot()","3d2ad100":"from numba import cuda","cc3c98d8":"@cuda.jit\ndef mandelbrot_gpu(mat, maxiter=100, xmin=-2.6, xmax=1.85, ymin=-1.25, ymax=1.25):\n    x = cuda.blockIdx.x\n    y = cuda.threadIdx.x\n    \n    # Mapping pixel to C\n    creal = xmin + x \/ mat.shape[0] * (xmax - xmin)\n    cim = ymin + y \/ mat.shape[1] * (ymax - ymin)\n    \n    # Initialisation of C and Z\n    c = complex(creal, cim)\n    z = complex(0, 0)\n    \n    # Mandelbrot iteration\n    for n in range(maxiter):\n        z = z*z+c\n        # If unbounded: save iteration count and break\n        if z.real*z.real + z.imag*z.imag > 4.0:\n            # Smooth iteration count\n            mat[x,y] = n + 1 - math.log(math.log(abs(z*z+c)))\/math.log(2)\n            break\n        # Otherwise: leave it to 0","dd88e8f1":"# Parameters\nxmin, xmax = -2.6, 1.85\nymin, ymax = -1.25, 1.25\nxpixels = 600\nypixels = round(xpixels \/ (xmax-xmin) * (ymax-ymin))\n\nmaxiter = 100\nmat = np.zeros((xpixels, ypixels))\n\n# Running and plotting result\nmandelbrot_gpu[xpixels, ypixels](mat, maxiter, xmin, xmax, ymin, ymax)\ndraw_image(mat)","fb80ad1f":"# Measuring computation time\n%timeit -n 10 -r 3 mandelbrot_gpu[xpixels, ypixels](mat, maxiter, xmin, xmax, ymin, ymax)","6f0c4a4e":"# Parameters\nxpixels = 1200\nypixels = round(xpixels \/ (xmax-xmin) * (ymax-ymin))\nmaxiter = 1000\nmat = np.zeros((xpixels, ypixels))\n\n# Running and plotting result\nmandelbrot_gpu[xpixels, ypixels](mat, maxiter, xmin, xmax, ymin, ymax)\ndraw_image(mat, powern = .3)","a009b081":"xmin, xmax = -1.7687782, -1.7687794\nymin, ymax = -0.0017384, -0.0017394\nxpixels = 1200\nypixels = round(xpixels \/ (xmax-xmin) * (ymax-ymin))\n# Some deeper places need more iterations\nmaxiter = 1e4\nmat = np.zeros((xpixels, ypixels))\n\nmandelbrot_gpu[xpixels, ypixels](mat, maxiter, xmin, xmax, ymin, ymax)\ndraw_image(mat, cmap='hot', powern = 1)","37f3101a":"xmin, xmax = -0.776606, -0.776581\nymin, ymax = -0.136651, -0.136630\nxpixels = 1200\nypixels = round(xpixels \/ (xmax-xmin) * (ymax-ymin))\nmat = np.zeros((xpixels, ypixels))\n\nmandelbrot_gpu[xpixels, ypixels](mat, maxiter, xmin, xmax, ymin, ymax)\ndraw_image(mat, cmap='gist_stern', powern = .8)","e3c3035e":"xmin, xmax = -0.3754, -0.3725\nymin, ymax = 0.6585, 0.6609\nxpixels = 1200\nypixels = round(xpixels \/ (xmax-xmin) * (ymax-ymin))\nmat = np.zeros((xpixels, ypixels))\n\nmandelbrot_gpu[xpixels, ypixels](mat, maxiter, xmin, xmax, ymin, ymax)\ndraw_image(mat, cmap='gist_ncar')","5984858e":"## How to execute Python function on CUDA\n\nIn order to execute our function on CUDA, we need to make it a **CUDA kernel** and set the dimension of the grid on which the kernel will run (in parallel!).\n\nKeep in mind that you can further optimize the runtime by playing with the grid structure (grid dimension, number of blocks per grid and of threads per blocks), and the optimal structure depends of the GPU device you are using. To keep the code short and clear we will use a **1D-grid with `xpixels` blocks of `ypixels` threads**.\n\nWe need to make some minor adjustments to our code:\n- add the `@cuda.jit` decorator before our function definition to make it a CUDA kernel\n- we don't need to loop through each pixel, since it is handled by the grid structure\n- we get the `x` and `y` indexes with respectively `cuda.blockIdx.x` (ID of current block) and `cuda.threadIdx.x` (ID of current thread)\n- the kernel can not return any output, but NumPy arrays that are supplied as arguments to it are automatically transferred between the CPU and the GPU. We will use this feature to modify the `mat` array.\n- in the kernel call, we need to set the number of blocks (`xpixels`) and the number of threads per blocks (`ypixels`)\n\nbut everything else is identical!","b73cbc66":"For the rendering, we use the `matplotlib` library. Here are the parameters of the `draw_image` function:\n- `mat`: the output matrix from the previous function\n- `cmap`: [matplotlib colormap](https:\/\/matplotlib.org\/stable\/tutorials\/colors\/colormaps.html)\n- `powern`: power-law parameter on colors\n- `dpi`: Dots per inch","12b38064":"Here we can visualize the **Mandelbrot set**! The inner points, in black ($mat == 0$), are those who belong to the set. The outer points are colored according to the number of iterations before $|z_n| > 2$. The boundary of the set looks very *rough*, or *chaotic*. Actually it has been demonstrated in *(Shishikura, 1991)* that the boundary of the Mandelbrot set is a 2 dimension object! A lot of mathematical questions about the set are still open to date.\n\nThe drawing is as expected, but it seems to take seconds to run. We will run it 30 times (3 runs of 10) the algorithm to estimate accuretaly its runtime.","c0d0d61c":"We define the `mandelbrot` function that returns the Mandelbrot set as a 2D NumPy array. Our function will take the following parameters:\n\n- `xpixels`: width, in pixels, for the output image\n- `maxiter`: number of iterations before we consider the pixel is bounded\n- `xmin, xmax, ymin, ymax`: coordinates of the frame in which we compute the Mandelbrot Set","678bb8b0":"\n\n# Introduction to the Mandelbrot set\n<a id=\"introduction\"><\/a>\n***\n\nIn this notebook we will see how to plot the [Mandelbrot Set](https:\/\/en.wikipedia.org\/wiki\/Mandelbrot_set). We will begin with a standart implementation with numpy using only CPU. Then we will speed up things using GPU with CUDA. \n\n### Definition of the Mandelbrot set\n\nThe Mandelbrot set is the **set of complex numbers $c$ such that the following sequence is bounded:**\n\n$$\\begin{equation}\n    \\begin{cases}\n        z_0=0\\\\\n        z_{n+1}=z_n^2+c\n    \\end{cases} \n\\end{equation}$$\n\nThe beauty of the Mandelbrot set is that such a simple equation leads to a *chaotic* set. Such figures are called [fractals](https:\/\/en.wikipedia.org\/wiki\/Fractal).\n\nTo **draw the set**, we will map each pixel of a 2D image to a complex number $c$, and compute the sequence $z_n$ by iteration. We can prove that if $|z_n| > 2$ for any $n$, then the sequence is unbounded. Using this property, we can stop the iteration once this criteria is met. The number of iteration before meeting the criteria is kept, and will be used to color the space outside of the set. Instead of saving the raw (integer) number of iteration, we will keep the [smooth iteration count](https:\/\/www.iquilezles.org\/www\/articles\/mset_smooth\/mset_smooth.htm) instead.\n\nThe Mandelbrot set is a very good candidate for GPU computing since it is **embarrassingly parallel**. Indeed, the computation of pixels being independent from each other, it is easy to parallelize them on the GPU threads.\n","77e731de":"With given parameters, it runs in approximately **2 seconds** (of course, depending on the hardware you run it on). It is a bit slow, in particular if we want to run it mutliple time or with more pixels and more iterations! We will try to speed up things using **GPU computing**.","f1167310":"# [CUDA] \ud83d\ude80 Accelerating Mandelbrot fractal with GPU\n*** \n**J\u00e9r\u00e9my Lesuffleur - 13\/03\/2021**\n\n## Table of contents\n\n* [Introduction to the Mandelbrot set](#introduction)\n\n* [Part 1: Computation on **CPU** with NumPy](#part1)\n\n* [Part 2: Computation on **GPU** with CUDA](#part2)","4f42a2f0":"Now let's try the algorithm! \n\nSince our code might be rather slow, we begin with an image of width $600$ and a maxiter of $100$ (the default values).\n\n","35a6933c":"## To go further\n\nYou can find the **above code with more features** (interactive exploration, custom colormap, Object-Oriented Programming...) on [my GitHub](https:\/\/github.com\/jlesuffleur\/gpu_mandelbrot).\n\nTo dive deeper in the subject, here are some links from where I draw inspiration:\n- [CUDA Programming with Numba](https:\/\/nyu-cds.github.io\/python-numba\/05-cuda\/) by \nthe NYU Center for Data Science\n- [GPU accelerated Mandelbrot Set in Python](https:\/\/www.researchgate.net\/publication\/339781069_GPU_Accelerated_Mandelbrot_Set_in_Python) \n- [How To Quickly Compute The Mandelbrot Set In Python](https:\/\/gist.github.com\/jfpuget\/60e07a82dece69b011bb)  \n- [Numba + CUDA Mandelbrot](https:\/\/www.kaggle.com\/landlord\/numba-cuda-mandelbrot)\n- [Mandelbrot Set Explorer](https:\/\/mandel.gart.nz\/) \n\n### **Do not hesitate to upvote, comment, and fork the code to try it yourself!**","f73fdd76":"The speedup is **huge**: runtime is reduced by **more than 1000x**!\n\nNow that we have a very fast implementation, we can run it with more pixels and iterations.","7f8709bb":"# Part 2: Computation on GPU with CUDA\n<a id=\"part2\"><\/a>\n***\nIt is possible to accelerate our algorithm using the GPU instead of the CPU. We will use the **CUDA toolkit** to execute code on the GPU. Here you can find [an introduction to CUDA](https:\/\/developer.nvidia.com\/blog\/even-easier-introduction-cuda\/).\n\nIn this notebook, we will use the [CUDA jit toolkit by Numba](http:\/\/numba.pydata.org\/numba-doc\/0.13\/CUDAJit.html). You can find a very clear tutorial on [CUDA Programming with Numba](https:\/\/nyu-cds.github.io\/python-numba\/05-cuda\/) by the New York University. This toolkit is a high level point of entry to GPU computing which allows us to execute Python functions on the CUDA hardware. This will save us the pain of rewriting our Python code in CUDA (at the cost of a slightly slower execution time)!\n\nOf course, a GPU compatible with CUDA is required to execute the code below. The first step is to import the `numba.cuda` module:","23dc8253":"Let's try with the parameters used in part 1, for the sake of comparison:","71620dfd":"The image quality is much better, and runtime still very fast.\n\nWe will now plot some other places of the Mandelbrot Set, by changing the frame parameters, and playing with the colormaps.","56310d15":"The picture is identical to the above one, so our algorithm ran as expected! Now let's check the runtime.","6e3116e5":"# Part 1: Computation on CPU with NumPy\n<a id=\"part1\"><\/a>\n***\n\nFor this first part, we will use mainly `numpy` to compute the set, and `matplotlib` to render it:"}}