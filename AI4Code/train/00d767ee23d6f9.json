{"cell_type":{"0c533812":"code","bc600827":"code","4aff2645":"code","ed63fab7":"code","863adc40":"code","8e56af41":"code","ca378f93":"code","dc47b194":"markdown","767d6c8b":"markdown","1816c164":"markdown","34855c38":"markdown"},"source":{"0c533812":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport plotly.graph_objs as go\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode(connected=True)\nfrom collections import Counter\nimport matplotlib.pyplot as plt\n#import seaborn as sns\nfrom mlxtend.classifier import StackingCVClassifier\nfrom sklearn.linear_model import LogisticRegression\n%matplotlib inline\nimport seaborn as sns # for making plots with seaborn\ncolor = sns.color_palette()\nfrom pandas.tools.plotting import parallel_coordinates\nfrom sklearn.decomposition import PCA\nfrom sklearn import ensemble,model_selection,svm\nfrom xgboost import XGBClassifier\nfrom sklearn.ensemble import RandomForestClassifier","bc600827":"train = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')","4aff2645":"print('size of train data',train.shape)\nprint('size of test data',test.shape)","ed63fab7":"train.head()","863adc40":"train.info()","8e56af41":"####################### Train data #############################################\ntrain['HF1'] = train['Horizontal_Distance_To_Hydrology']+train['Horizontal_Distance_To_Fire_Points']\ntrain['HF2'] = abs(train['Horizontal_Distance_To_Hydrology']-train['Horizontal_Distance_To_Fire_Points'])\ntrain['HR1'] = abs(train['Horizontal_Distance_To_Hydrology']+train['Horizontal_Distance_To_Roadways'])\ntrain['HR2'] = abs(train['Horizontal_Distance_To_Hydrology']-train['Horizontal_Distance_To_Roadways'])\ntrain['FR1'] = abs(train['Horizontal_Distance_To_Fire_Points']+train['Horizontal_Distance_To_Roadways'])\ntrain['FR2'] = abs(train['Horizontal_Distance_To_Fire_Points']-train['Horizontal_Distance_To_Roadways'])\ntrain['ele_vert'] = train.Elevation-train.Vertical_Distance_To_Hydrology\n\ntrain['slope_hyd'] = (train['Horizontal_Distance_To_Hydrology']**2+train['Vertical_Distance_To_Hydrology']**2)**0.5\ntrain.slope_hyd=train.slope_hyd.map(lambda x: 0 if np.isinf(x) else x) # remove infinite value if any\n\n#Mean distance to Amenities \ntrain['Mean_Amenities']=(train.Horizontal_Distance_To_Fire_Points + train.Horizontal_Distance_To_Hydrology + train.Horizontal_Distance_To_Roadways) \/ 3 \n#Mean Distance to Fire and Water \ntrain['Mean_Fire_Hyd']=(train.Horizontal_Distance_To_Fire_Points + train.Horizontal_Distance_To_Hydrology) \/ 2 \n\n####################### Test data #############################################\ntest['HF1'] = test['Horizontal_Distance_To_Hydrology']+test['Horizontal_Distance_To_Fire_Points']\ntest['HF2'] = abs(test['Horizontal_Distance_To_Hydrology']-test['Horizontal_Distance_To_Fire_Points'])\ntest['HR1'] = abs(test['Horizontal_Distance_To_Hydrology']+test['Horizontal_Distance_To_Roadways'])\ntest['HR2'] = abs(test['Horizontal_Distance_To_Hydrology']-test['Horizontal_Distance_To_Roadways'])\ntest['FR1'] = abs(test['Horizontal_Distance_To_Fire_Points']+test['Horizontal_Distance_To_Roadways'])\ntest['FR2'] = abs(test['Horizontal_Distance_To_Fire_Points']-test['Horizontal_Distance_To_Roadways'])\ntest['ele_vert'] = test.Elevation-test.Vertical_Distance_To_Hydrology\n\ntest['slope_hyd'] = (test['Horizontal_Distance_To_Hydrology']**2+test['Vertical_Distance_To_Hydrology']**2)**0.5\ntest.slope_hyd=test.slope_hyd.map(lambda x: 0 if np.isinf(x) else x) # remove infinite value if any\n\n#Mean distance to Amenities \ntest['Mean_Amenities']=(test.Horizontal_Distance_To_Fire_Points + test.Horizontal_Distance_To_Hydrology + test.Horizontal_Distance_To_Roadways) \/ 3 \n#Mean Distance to Fire and Water \ntest['Mean_Fire_Hyd']=(test.Horizontal_Distance_To_Fire_Points + test.Horizontal_Distance_To_Hydrology) \/ 2","ca378f93":"feature = [col for col in train.columns if col not in ['Cover_Type','Id']]\nX_train = train[feature]\nX_test = test[feature]\nc1 = ensemble.ExtraTreesClassifier(n_estimators=150,bootstrap=True) \nc2= ensemble.RandomForestClassifier(n_estimators=150,bootstrap=True)\nc3=XGBClassifier();\nmeta = svm.LinearSVC()\netc = StackingCVClassifier(classifiers=[c1,c2,c3],use_probas=True,meta_classifier=meta)\n\n#parameters = {'n_estimators':np.range(100,500)}\n#gc=model_selection.GridSearchCV(parameters,etc)\n#etc=XGBClassifier();stackcv\netc.fit(X_train.values, train['Cover_Type'].values)\nsub = pd.DataFrame({\"Id\": test['Id'],\"Cover_Type\": etc.predict(X_test.values)})\nsub.to_csv(\"stackcv_linearsvc.csv\", index=False) ","dc47b194":"* **Features engineering** :\n    * **Linear combination** :\n           * Elevation, Vertical dist. to Hydrology\n           * Horizontal dist. to Hydrology, Horizontal dist. to Fire Points \n           * Horizontal dist. to Hydrology, Horizontal dist. to Roadways \n           * Horizontal dist. to Fire Points, Horizontal dist. to Roadways \n    * **Euclidean distance** : \n            * Horizontal dist. to Hydrology, Vertical dist. to Hydrology\n            * euclidean distance = \\sqrt{(verticaldistance)^2 + (horizontaldistance)^2}\\] \n    * **Distance to Amenities** :\n         * As we know distances to amenities like Water, Fire and Roadways played a key role in determining cover type \n           * Mean distance to Amenities \n           * Mean Distance to Fire and Water ","767d6c8b":"# Feature Engineering","1816c164":"# Model Building","34855c38":"This kernel borrows the data preprocessing part from this very thorough and useful kernel by Lathwal: https:\/\/www.kaggle.com\/codename007\/forest-cover-type-eda-baseline-model"}}