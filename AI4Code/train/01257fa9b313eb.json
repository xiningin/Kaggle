{"cell_type":{"aa4980e8":"code","1c8f49c3":"code","628deddf":"code","af1857aa":"code","a720aae1":"code","bcdc16c3":"code","61acdd35":"code","d6c872bb":"code","77916bf1":"code","eb986ca4":"code","4d73ecec":"code","ccfaf2b5":"code","a42fa245":"code","ba13d857":"code","acaaad4b":"markdown","1eddb15a":"markdown","7b046d29":"markdown","6b6a5b03":"markdown","cf0301ba":"markdown","d6d8ca0e":"markdown","86e111f6":"markdown","34a0095e":"markdown"},"source":{"aa4980e8":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split","1c8f49c3":"df = pd.read_csv('..\/input\/banknote-authentication-uci\/BankNoteAuthentication.csv')\ndf.head()","628deddf":"sns.pairplot(df, hue=\"class\")","af1857aa":"features = df[['variance', 'skewness', 'curtosis', 'entropy']].values\nlabels = df[['class']].values.reshape(-1)","a720aae1":"X_train, X_test, y_train, y_test = train_test_split(features, labels, test_size=0.33, random_state=42)","bcdc16c3":"def euclidian(fvec, alpha):\n    prototypes, proto_labels = alpha\n    # Compute distance from each prototype to this point\n    distances = list(np.sum(np.subtract(fvec, p)**2) for p in prototypes)\n    min_dist_index = distances.index(min(distances))\n\n    # Determine winner prototype.\n    winner = prototypes[min_dist_index]\n    winner_label = proto_labels[min_dist_index]\n    \n    return winner, winner_label, min_dist_index","61acdd35":"def init_prototype(data, labels):\n    labels = labels.astype(int)\n    unique_labels = list(set(labels))\n\n    prototypes = np.empty((len(unique_labels), data.shape[1]))\n    proto_labels = []\n\n    # Initialize prototypes using class means.\n    for i in unique_labels:\n        class_data = data[labels == i, :]\n\n        # Compute class mean.\n        mean = np.mean(class_data, axis=0)\n\n        prototypes[i] = mean\n        proto_labels.append(i)\n        \n    return prototypes, proto_labels","d6c872bb":"def lvq(alpha, X, y, learning_rate):\n    prototypes, proto_labels = alpha\n    winner, winner_label, min_dist_index = euclidian(X, alpha)\n            \n    #Push or repel the prototype based on the label.\n    sign = 1 if winner_label == y else -1\n\n    # Update winner prototype\n    prototypes[min_dist_index] = np.add(prototypes[min_dist_index], np.subtract(X, winner) * learning_rate * sign)\n    \n    return prototypes","77916bf1":"def validate(X, y, val_err, alpha):\n    winner, winner_label, min_dist_index = euclidian(X, alpha)\n\n    # Check if labels match\n    if not winner_label == y:\n        val_err = val_err + 1\n    \n    return val_err","eb986ca4":"def train_lvq(data, labels, num_epochs, learning_rate, validation_data=None, validation_labels=None):\n    # Get init values\n    prototypes, proto_labels = init_prototype(data, labels)\n\n    # Loop through data set.\n    for epoch in range(0, num_epochs):\n        for X, y in zip(data, labels):\n            alpha = prototypes, proto_labels\n            prototypes = lvq(alpha, X, y, learning_rate)\n\n        # Use validation set to test performance.\n        val_err = 0\n        if validation_labels is not None:\n            for X, y in zip(validation_data, validation_labels):\n                alpha = prototypes, proto_labels\n                val_err = validate(X, y, val_err, alpha)\n\n            val_err = val_err \/ len(validation_labels)\n            print(\"Epoch \" + str(epoch) + \". Validation error: \" + str(val_err))\n        else:\n            print(\"Epoch \" + str(epoch))\n\n\n    return (prototypes, proto_labels)","4d73ecec":"alpha = train_lvq(X_train, y_train, 10, 0.1, validation_data=X_test, validation_labels=y_test)","ccfaf2b5":" def get_accuracy(X, y, alpha):\n    wrong = 0\n    for i, x in enumerate(X):\n        wrong = validate(x, y[i], wrong, alpha)\n        \n    accuracy = 1 - wrong \/ len(X)\n    return accuracy","a42fa245":"train_accuracy = get_accuracy(X_train, y_train, alpha)\nprint(\"Train accuracy: {0:1.3f}\".format(train_accuracy))","ba13d857":"test_accuracy = get_accuracy(X_test, y_test, alpha)\nprint(\"Train accuracy: {0:1.3f}\".format(test_accuracy))","acaaad4b":"# Conclusion\n\nWith just in few epochs, we get a 74.5% accuracy. It shows that the model works but needs improvements.","1eddb15a":"## Euclidian\n\n![euclidian.png](attachment:euclidian.png)","7b046d29":"<h1 align=center style=\"color:blue;border:1px dotted\">Banknote Authentication using Learning Vector Quantization<\/h1>","6b6a5b03":"# Analyze Trained Prototype","cf0301ba":"## Implementation","d6d8ca0e":"# Prepare Data","86e111f6":"## Algorithm\n\n![image.png](attachment:image.png)","34a0095e":"# Learning Vector Quantization"}}