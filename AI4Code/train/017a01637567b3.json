{"cell_type":{"ae5cd4d8":"code","5a65547b":"code","3829d8f4":"code","95c6653b":"code","b7628e24":"code","b73cb1bd":"code","03112cab":"code","8b7c6b83":"code","92862c30":"code","b9107e8d":"code","7a5ba652":"code","3e57a819":"code","d8f4bc28":"code","49e16110":"markdown"},"source":{"ae5cd4d8":"#import package\nimport pandas as pd\nimport numpy as np\nimport math\nimport matplotlib.pyplot as plt\nimport datetime as dt\nimport matplotlib.dates as mdates\n\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error\nfrom keras.models import Sequential\nfrom keras.layers import LSTM, Dropout, Dense\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","5a65547b":"#read dataset\nraw = pd.read_csv('..\/input\/CryptocoinsHistoricalPrices.csv')\nraw.head()","3829d8f4":"#extract data of Ripple from the original dataset\nXRP = raw[raw['coin']=='XRP'][['Date','Close']]\n#sort data by date\nXRP = XRP.sort_values(by='Date', ascending=True)\nXRP.head()","95c6653b":"#generate the list of close price and convert to 2D array\nclose_price = XRP.Close.as_matrix()\nclose_price = np.reshape(close_price,(-1,1))\n\n#generate the list of date and convert to 2D array\ndate = XRP.Date.as_matrix()\ndate = np.reshape(date,(-1,1))","b7628e24":"class data_preparation(object):\n    def __init__(self,price,time,train,valid,test,shift):\n        self.price = price #price dataset\n        self.time = time #datetime dataset\n        self.train = train #fration of train data\n        self.valid = valid #fration of valid data\n        self.test = test #fration  of test data\n        #train + valid + test = 1\n        self.shift = shift #length of historical price using for predicting future price\n        self.interface1 = (int(self.train*len(self.price))\/\/self.shift)*self.shift\n        self.interface2 = self.interface1 + ((int(self.valid*len(self.price))\/\/self.shift)*self.shift)\n        self.end = (len(self.price)\/\/self.shift)*self.shift\n              \n    #function for generating x or y dataset\n    global xy\n    def xy(data,shift,str):\n        series = []\n        length = len(data) - shift - 1\n        for i in range(length):\n            if str == 'x':\n                series.append(data[i:shift+i,0])\n            else:\n                series.append(data[shift+i,0])\n        return np.array(series)\n    \n    #function for separating train, valid and test dataset\n    global allocation    \n    def allocation(x_or_y,interface1,interface2,end):\n        train = x_or_y[:interface1]\n        valid = x_or_y[interface1:interface2]\n        test = x_or_y[interface2:end]\n        return train, valid, test\n        \n    #function for generating unnormalized x dataset\n    global x\n    def x(self):\n        x = xy(self.price,self.shift,'x')\n        x_train, x_valid, x_test = allocation(x,self.interface1,self.interface2,self.end)\n        return x_train, x_valid, x_test\n\n    #function for generating unnormalized y dataset\n    global y\n    def y(self):\n        y = xy(self.price,self.shift,'y')\n        y_train, y_valid,y_test = allocation(y,self.interface1,self.interface2,self.end)\n        return y_train, y_valid,y_test\n        #function for generating unnormalized y dataset\n    \n    #function for generating unnormalized y dataset for visualization\n    def actual_y(self):\n        y = xy(self.price,self.shift,'y')\n        y_train, y_valid,y_test = allocation(y,self.interface1,self.interface2,self.end)\n        return y_train, y_valid,y_test\n    \n    #normalization function\n    global norm\n    def norm(pre_norm):\n        scaler = MinMaxScaler()\n        pre_norm = np.reshape(pre_norm,(-1,1))\n        scaler.fit(pre_norm)\n        norm = scaler.transform(pre_norm)\n        return norm\n    \n    #function for generating normalized x dataset\n    def norm_x(self):\n        x_train, x_valid, x_test = x(self)\n        norm_x_train = np.reshape(norm(x_train) ,(-1,self.shift,1))        \n        norm_x_valid = np.reshape(norm(x_valid) ,(-1,self.shift,1))  \n        norm_x_test = np.reshape(norm(x_test) ,(-1,self.shift,1))\n        return norm_x_train, norm_x_valid, norm_x_test\n    \n    #function for generating normalized y dataset\n    def norm_y(self):\n        y_train, y_valid, y_test = y(self)\n        norm_y_train = np.reshape(norm(y_train) ,(-1,1))        \n        norm_y_valid = np.reshape(norm(y_valid) ,(-1,1))  \n        norm_y_test = np.reshape(norm(y_test) ,(-1,1))  \n        return norm_y_train, norm_y_valid, norm_y_test\n    \n    #function for generating time domain of each dataset\n    def timestamp(self):\n        time = xy(self.time,self.shift,'date')\n        time_train, time_valid,time_test = allocation(time,self.interface1,self.interface2,self.end)\n        return time_train, time_valid, time_test","b73cb1bd":"#feed price and time datasets to data_preparation\n#set shift = 7 ->look back 7 days' (shift = 7) close price to predict the close price of the 8th day\nshift = 7\nprocess = data_preparation(price = close_price, time = date,train = 0.7, valid=0.10, test = 0.20, shift = shift)","03112cab":"#generate normalized x and y dataset\nnorm_x_train, norm_x_valid,norm_x_test = process.norm_x()\nnorm_y_train, norm_y_valid,norm_y_test = process.norm_y()","8b7c6b83":"#generate LSTM model\nrun = Sequential()\n#add LSTM layer with 256 nodes\nrun.add(LSTM(units = 256,input_shape = (shift,1),return_sequences = False))\nrun.add(Dense(1))\n\n#use adam as optimizer to minimize mean square error (mse)\nrun.compile(optimizer = 'adam',loss = 'mse')\n\n#fit train dataset with the model\nrun.fit(norm_x_train,norm_y_train, validation_data = (norm_x_valid,norm_y_valid),epochs = 100,batch_size = 10, shuffle = True)\n\n#feed norm_x_test dataset to predict norm_y_test\nprediction = run.predict(norm_x_test)","92862c30":"#generate date and unnormalized y datasets for visualization\ny_train, y_valid,y_test = process.actual_y()\ndate_train, date_valid,date_test = process.timestamp()","b9107e8d":"#scale y_test dataset\n#this scaler will be used to convert the normalized predicted result to actual price\ny_test_scaler = MinMaxScaler()\ny_test = np.reshape(y_test,(-1,1))\ny_test_scaler.fit(y_test)\n\n#scale up the predicted close price\nprediction = y_test_scaler.inverse_transform(prediction)","7a5ba652":"#convert type of date dateset from string to datetime\ndate_train = [dt.datetime.strptime(date,'%Y-%m-%d').date() for date in date_train]\ndate_valid = [dt.datetime.strptime(date,'%Y-%m-%d').date() for date in date_valid]\ndate_test = [dt.datetime.strptime(date,'%Y-%m-%d').date() for date in date_test]","3e57a819":"#calculate RMSE of the predicted close price from y_test\nRMSE = math.sqrt(mean_squared_error(y_test, prediction))\nRMSE = round(RMSE, 4)\nRMSE = str(RMSE)\nRMSE = 'RMSE =  ' + RMSE","d8f4bc28":"#plot figure of close price\nplt.style.use('ggplot')\n\nfig1 = plt.figure(figsize=(12,8),dpi=100,)\n\nax1 = fig1.add_subplot(111)\n#plot train dataset against date\nax1.plot(date_train,y_train, linewidth=3.0,color='lightgray',label='Train dataset')\n#plot valid dataset against date\nax1.plot(date_valid,y_valid, linewidth=3.0,color='darkgray',label='Validation dataset')\n#plot test dataset against date\nax1.plot(date_test,y_test,linewidth=3.0, color='midnightblue',label='Test dataset')\n#use the same scale for norm_y_test to modify the prediction result and plot against date\nax1.plot(date_test,prediction,linewidth=2.0,color='maroon',label='Prediction')\n\nax1.set_ylabel('Close Price (USD)',fontsize=14, color='black')\nax1.set_xlabel('Date',fontsize=14, color='black')\nax1.set_facecolor('white')\nax1.legend(fontsize=12,edgecolor='black',facecolor='white',borderpad=0.75)\nax1.tick_params(colors='black',labelsize=12)\nax1.spines['bottom'].set_color('black')\nax1.spines['top'].set_color('black')\nax1.spines['left'].set_color('black')\nax1.spines['right'].set_color('black')\nax1.grid(color='lightgray', linestyle=':', linewidth=1)\n\n#expand the graph of test dataset and predicted prices\ninset = plt.axes([0.2, 0.25, 0.45, 0.45], facecolor='lightgrey')\ninset.plot(date_test,y_test,linewidth=3.0, color='midnightblue',label='Test dataset')\ninset.plot(date_test,prediction,linewidth=2.0,color='maroon',label='Prediction')\n\ninset.tick_params(colors='black',labelsize=12)\ninset.spines['bottom'].set_color('black')\ninset.spines['top'].set_color('black')\ninset.spines['left'].set_color('black')\ninset.spines['right'].set_color('black')\ninset.grid(color='white', linestyle=':', linewidth=1)\ninset.text(0.6, 0.8,RMSE,transform = inset.transAxes, fontsize = 12)\n\nplt.show()","49e16110":"# Introduction\n\nThis kernel uses Keras Long Short Term Memory (LSTM) recurrent neural network to  analyze historical price of Ripple coin in order to predict the future p\nrice of this coin.\n\n# Model \nThe close price of XRP on the 8th day is computed using the close prices of previous 7 days. \nLSTM model contains 1 layer with 256 nodes.\n\n# Code and Result"}}