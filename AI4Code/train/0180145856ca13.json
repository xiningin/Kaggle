{"cell_type":{"5a94501c":"code","efca66ae":"code","00bcb897":"code","a1a9f7b1":"code","a9f27a5d":"code","39e9af0f":"code","3e081165":"code","1e1122a8":"code","c6d35a18":"code","4989f86b":"code","942bdc40":"code","4b9ecec2":"code","006464ee":"code","105fdab0":"markdown","29ea8454":"markdown","6acbb10e":"markdown","40c5c58e":"markdown","7469d8a5":"markdown","0364c841":"markdown","6857a6fa":"markdown","cf0e9566":"markdown","e81ea3c7":"markdown","56191e32":"markdown","0a78bbad":"markdown"},"source":{"5a94501c":"# modules we'll use\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport datetime\n\n# read in our data\nearthquakes = pd.read_csv(\"..\/input\/earthquake-database\/database.csv\")\nlandslides = pd.read_csv(\"..\/input\/landslide-events\/catalog.csv\")\nvolcanos = pd.read_csv(\"..\/input\/volcanic-eruptions\/database.csv\")\n\n# set seed for reproducibility\nnp.random.seed(0)","efca66ae":"# print the first few rows of the date column\n","00bcb897":"# check the data type of our date column\nlandslides['date'].dtype","a1a9f7b1":"# Your turn! Check the data type of the Date column in the earthquakes dataframe\n# (note the capital 'D' in date!)\nprint(earthquakes['Date'].head())\nearthquakes['Date'].dtype","a9f27a5d":"# create a new column, date_parsed, with the parsed dates\nlandslides['date_parsed'] = pd.to_datetime(landslides['date'], format = \"%m\/%d\/%y\")","39e9af0f":"# print the first few rows\nlandslides['date_parsed'].head()","3e081165":"# Your turn! Create a new column, date_parsed, in the earthquakes\n# dataset that has correctly parsed dates in it. (Don't forget to \n# double-check that the dtype is correct!)\nearthquakes['Date_parsed'] =pd.to_datetime(earthquakes['Date'], infer_datetime_format=True)\nearthquakes['Date_parsed'].head()","1e1122a8":"# try to get the day of the month from the date column\nday_of_month_landslides = landslides['date'].dt.day","c6d35a18":"# get the day of the month from the date_parsed column\nday_of_month_landslides = landslides['date_parsed'].dt.day","4989f86b":"# Your turn! get the day of the month from the date_parsed column\nday_of_month_earthquakes = earthquakes['Date_parsed'].dt.day\nprint(day_of_month_earthquakes)","942bdc40":"# remove na's\nday_of_month_landslides = day_of_month_landslides.dropna()\n\n# plot the day of the month\nsns.distplot(day_of_month_landslides, kde=False, bins=31)","4b9ecec2":"# Your turn! Plot the days of the month from your\n# earthquake dataset and make sure they make sense.\nday_of_month_earthquakes=day_of_month_earthquakes.dropna()\nsns.distplot(day_of_month_earthquakes, kde=False, bins=31)","006464ee":"volcanos['Last Known Eruption'].sample(5)","105fdab0":"# Application 1: Select just the day of the month from our column: *.dt.day\/month\/year","29ea8454":"# Step 2: Check the data type of our date column: *.head() or *.dtype","6acbb10e":"We got an error! The important part to look at here is the part at the very end that says `AttributeError: Can only use .dt accessor with datetimelike values`. We're getting this error because the dt.day() function doesn't know how to deal with a column with the dtype \"object\". Even though our dataframe has dates in it, because they haven't been parsed we can't interact with them in a useful way.\n\nLuckily, we have a column that we parsed earlier , and that lets us get the day of the month out no problem:","40c5c58e":"# Step 4: Plot the day of the month to check the date parsing\n___\n\nOne of the biggest dangers in parsing dates is mixing up the months and days. The to_datetime() function does have very helpful error messages, but it doesn't hurt to double-check that the days of the month we've extracted make sense. \n\nTo do this, let's plot a histogram of the days of the month. We expect it to have values between 1 and 31 and, since there's no reason to suppose the landslides are more common on some days of the month than others, a relatively even distribution. (With a dip on 31 because not all months have 31 days.) Let's see if that's the case:","7469d8a5":"Yep, it looks like we did parse our dates correctly & this graph makes good sense to me. Why don't you take a turn checking the dates you parsed earlier?","0364c841":"___\n* **What if I run into an error with multiple date formats?** While we're specifying the date format here, sometimes you'll run into an error when there are multiple date formats in a single column. If that happens, you have have pandas try to infer what the right date format should be. You can do that like so:\n\n`landslides['date_parsed'] = pd.to_datetime(landslides['Date'], infer_datetime_format=True)`\n\n* **Why don't you always use `infer_datetime_format = True?`** There are two big reasons not to always have pandas guess the time format. The first is that pandas won't always been able to figure out the correct date format, especially if someone has gotten creative with data entry. The second is that it's much slower than specifying the exact format of the dates.\n____","6857a6fa":"# Step 3: Convert our date columns to datetime: pd.to_datetime()\npd.to_datetime(arg, format)\narg: integer, float, string, datetime, list, tuple, 1-d array, Series\nformat: string, default None. strftime to parse time, eg \u201c%d\/%m\/%Y\u201d, note that \u201c%f\u201d will parse all the way up to nanoseconds.\n___\n\nWe can pandas what the format of our dates are with a guide called as [\"strftime directive\", which you can find more information on at this link](http:\/\/strftime.org\/). The basic idea is that you need to point out which parts of the date are where and what punctuation is between them. There are [lots of possible parts of a date](http:\/\/strftime.org\/), but the most common are `%d` for day, `%m` for month, `%y` for a two-digit year and `%Y` for a four digit year.\n\nSome examples:\n\n * 1\/17\/07 has the format \"%m\/%d\/%y\"\n * 17-1-2007 has the format \"%d-%m-%Y\"\n \n Looking back up at the head of the `date` column in the landslides dataset, we can see that it's in the format \"month\/day\/two-digit year\", so we can use the same syntax as the first example to parse in our dates: ","cf0e9566":"You may have to check the [numpy documentation](https:\/\/docs.scipy.org\/doc\/numpy-1.12.0\/reference\/generated\/numpy.dtype.kind.html#numpy.dtype.kind) to match the letter code to the dtype of the object. \"O\" is the code for \"object\", so we can see that these two methods give us the same information.","e81ea3c7":"# Step 1: Get our environment set up\n________\nFor today, we'll be working with two datasets: one containing information on earthquakes that occured between 1965 and 2016, and another that contains information on landslides that occured between 2007 and 2016.\n","56191e32":"And that's it for today! If you have any questions, be sure to post them in the comments below or [on the forums](https:\/\/www.kaggle.com\/questions-and-answers). \n\nRemember that your notebook is private by default, and in order to share it with other people or ask for help with it, you'll need to make it public. First, you'll need to save a version of your notebook that shows your current work by hitting the \"Commit & Run\" button. (Your work is saved automatically, but versioning your work lets you go back and look at what it was like at the point you saved it. It also lets you share a nice compiled notebook instead of just the raw code.) Then, once your notebook is finished running, you can go to the Settings tab in the panel to the left (you may have to expand it by hitting the [<] button next to the \"Commit & Run\" button) and setting the \"Visibility\" dropdown to \"Public\".\n\n# More practice!\n___\n\nIf you're interested in graphing time series, [check out this Learn tutorial](https:\/\/www.kaggle.com\/residentmario\/time-series-plotting-optional).\n\nYou can also look into passing columns that you know have dates in them  the `parse_dates` argument in `read_csv`. (The documention [is here](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/generated\/pandas.read_csv.html).) Do note that this method can be very slow, but depending on your needs it may sometimes be handy to use.\n\nFor an extra challenge, you can try try parsing the column `Last Known Eruption` from the `volcanos` dataframe. This column contains a mixture of text (\"Unknown\") and years both before the common era (BCE, also known as BC) and in the common era (CE, also known as AD).","0a78bbad":"Yep, those are dates! But just because I, a human, can tell that these are dates doesn't mean that Python knows that they're dates. Notice that the at the bottom of the output of `head()`, you can see that it says that the data type of this  column is \"object\". \n\n> Pandas uses the \"object\" dtype for storing various types of data types, but most often when you see a column with the dtype \"object\" it will have strings in it. \n\nIf you check the pandas dtype documentation [here](http:\/\/pandas.pydata.org\/pandas-docs\/stable\/basics.html#dtypes), you'll notice that there's also a specific `datetime64` dtypes. Because the dtype of our column is `object` rather than `datetime64`, we can tell that Python doesn't know that this column contains dates.\n\nWe can also look at just the dtype of your column without printing the first few rows if we like:"}}