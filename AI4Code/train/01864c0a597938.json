{"cell_type":{"d95441cf":"code","3614e6a9":"code","fa808d41":"code","9b037c06":"code","fa43007e":"code","f37cffd8":"code","c1219e79":"code","105bd5c1":"code","9a892024":"code","e419a2cb":"code","5bbd212e":"code","bbb8a8f8":"code","7befa9ea":"code","0dc74bf5":"code","7aee328b":"code","980b6988":"code","f44eb265":"code","d23e98ad":"code","e300d9bc":"code","4a5851ee":"code","0d9b3507":"code","0ed65a12":"code","221eac7b":"code","7daa1f23":"code","c91d67d3":"code","4f68af54":"code","787ec13d":"code","9bdcac94":"code","7e2c499f":"code","774d7c3b":"code","51ea3285":"code","a248a0b3":"code","8c24d617":"code","857bd23a":"code","309c136e":"code","5841201e":"code","cd0b7d82":"code","6a8de5a9":"code","f503ac97":"code","9ec6ec0e":"code","36e60774":"code","cf8bd8ec":"code","31716141":"code","ca79364e":"code","f1b46b9e":"code","26675b4a":"code","e30a0bae":"code","8d0d2210":"code","9561c09b":"code","39b74459":"code","336e6ea5":"code","93fb9203":"code","cea0aa90":"code","0ff9a698":"code","72f1f916":"code","7a80c231":"code","08e935d1":"code","731a90d8":"code","d16143f9":"code","bda8e373":"code","aca6bc48":"code","743f53c0":"code","57ee9083":"code","785ba226":"code","b449221c":"code","e1c43e44":"code","70457da2":"code","fbd42fff":"code","a068e1f7":"code","5b59e271":"code","2ada127a":"code","cca36d9c":"code","6bbdaf7e":"code","5323ed03":"code","abc8515a":"code","a8996122":"code","7d4cd8cb":"code","db82fafb":"code","1d1642bc":"code","e4ec48e2":"code","71074c65":"code","db9ebb48":"code","4677d72b":"code","938bc186":"code","469289cf":"code","7e16d851":"code","d41aeeda":"code","15003404":"code","1f43873b":"code","e9a74be5":"code","c33ce573":"code","5f9ed20a":"code","e4accae4":"code","1ea8cda0":"code","e6637317":"code","c26baa16":"markdown","6e9b8080":"markdown","d27dde95":"markdown","a5f55689":"markdown","54a3d675":"markdown","01dc8eaf":"markdown","87b1db7a":"markdown","7ae2b753":"markdown","cac3ddcc":"markdown","722a6885":"markdown","3b3dc34a":"markdown","240a9e98":"markdown","17671949":"markdown","0b9feb07":"markdown","90e836a9":"markdown","838fe32e":"markdown","29379b4a":"markdown","654568b4":"markdown","b10bc109":"markdown","8f3ffb0f":"markdown","e7e2696a":"markdown","f617fdd9":"markdown","999954b9":"markdown","4107eb37":"markdown","5da2347e":"markdown","584168c2":"markdown","ce8d76d5":"markdown","b7b3bca3":"markdown","46e369a6":"markdown","8cf369a5":"markdown","11c9d43d":"markdown","a4b12187":"markdown","03858382":"markdown","68b8fd75":"markdown","f755edc4":"markdown","b0e2edfe":"markdown","7e707651":"markdown","fc26a2b7":"markdown","f3401717":"markdown","7fd9696e":"markdown","1424b7a8":"markdown","e595b37f":"markdown","91b9ea64":"markdown","41267ff7":"markdown","ec58ea12":"markdown","4fa222b6":"markdown","eb048e7a":"markdown","cde568d1":"markdown","9c234d2a":"markdown","dcddd13c":"markdown","0cdf5354":"markdown","966c2d0d":"markdown","e38476b0":"markdown","5a9e1b37":"markdown","162072ee":"markdown","37c3f961":"markdown","d7086ec2":"markdown","9e1ae4d3":"markdown","08303d66":"markdown","57e4f4e1":"markdown","fad93767":"markdown","73c9863f":"markdown","b84dbdce":"markdown","89a22492":"markdown","2511dec5":"markdown","a9f79d32":"markdown","086d9ed6":"markdown","04589b8f":"markdown","e225319e":"markdown","ca96cd30":"markdown","73d1fe33":"markdown","35dff2c0":"markdown","0e156e2b":"markdown","154d3d53":"markdown","f6ae944d":"markdown","b25a3b37":"markdown"},"source":{"d95441cf":"# Imports \n\n# initalize drive\n#from google.colab import drive\n#drive.mount('\/content\/drive')\n#!pip install -Uqq fastbook kaggle waterfallcharts treeinterpreter dtreeviz mne\n","3614e6a9":"\n#import fastbook\n\n#drive.flush_and_unmount()\n#drive.mount('\/content\/drive')\n#fastbook.setup_book()\n\n# Part 1 Feature extraction\n\n# Base libraries\nfrom multiprocessing import Pool\n\nimport os\nimport numpy as np\nimport mne\nimport pandas as pd\nimport random\n\nfrom tqdm import tqdm\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom scipy.fftpack import fft, fftfreq, rfft, rfftfreq\nfrom sklearn.preprocessing import quantile_transform\nfrom sklearn.preprocessing import minmax_scale\nfrom sklearn.preprocessing import normalize\nfrom sklearn.preprocessing import scale\nfrom sklearn.preprocessing import robust_scale\nimport mne\nimport matplotlib \nfrom collections import defaultdict\nfrom math import cos, sin, acos, radians, pi\nfrom scipy.interpolate import griddata\nfrom numpy import newaxis\nfrom torch.utils.data import Dataset, DataLoader\nfrom torchvision import transforms, utils\n\n\n# Wavelets \nimport pywt","fa808d41":"drive.mount('\/content\/drive')\n","9b037c06":"# Importing the data using multiprocessing\n\n# 10x speed increase for reading 900 csv files\n\n\ntrain_dir = '\/content\/drive\/My Drive\/Colab_Data\/EEG\/SMNI_CMI_TRAIN\/Train\/'\ntest_dir = '\/content\/drive\/My Drive\/Colab_Data\/EEG\/SMNI_CMI_TEST\/Test\/'\n\n# wrap your csv importer in a function that can be mapped\ndef read_csv(filename):\n    'converts a filename to a pandas dataframe'\n    return pd.read_csv(filename)\n\n\n# get a list of file names\nfiles_train = os.listdir(train_dir)\nfile_list_train = [os.path.join(train_dir,filename) for filename in files_train if filename.split('.')[1]=='csv']\n                     \nfiles_test = os.listdir(test_dir)\nfile_list_test = [os.path.join(test_dir,filename) for filename in files_test if filename.split('.')[1]=='csv']\n                     \n# set up your pool\nwith Pool(processes=12) as pool:\n\n    # pool maps the dataframe\n\n\n    df_list_train = pool.map(read_csv, file_list_train)\n    df_list_test =  pool.map(read_csv, file_list_test)\n\n\n# reduce the list of dataframes to a single dataframe\ncombined_df_train = pd.concat(df_list_train, ignore_index=True)\ncombined_df_test = pd.concat(df_list_test, ignore_index=True)\ncombined_df = pd.concat([combined_df_train,combined_df_test], ignore_index=True)\n\n\nEEG_data = combined_df[combined_df['subject identifier'] == 'a']\nEEG_data_control = combined_df[combined_df['subject identifier'] == 'c']\n\ndel combined_df","fa43007e":"# standardizing the sensor position naming convention\n\n# Training set \n\nEEG_data = EEG_data.drop(['Unnamed: 0'], axis=1)\nEEG_data.loc[EEG_data['matching condition'] == 'S2 nomatch,', 'matching condition'] =  'S2 nomatch' ## remove comma sign from stimulus name  \n\n## replace some 'senso4\/1AX4XfWjxIbaBk1mjB1EGwKxLgAcVGZ4jYKlCxUrTC3J6zb1GcEgabB3B9bMr position' values\nEEG_data.loc[EEG_data['sensor position'] == 'AF1', 'sensor position'] = 'AF3'\nEEG_data.loc[EEG_data['sensor position'] == 'AF2', 'sensor position'] = 'AF4'\nEEG_data.loc[EEG_data['sensor position'] == 'PO1', 'sensor position'] = 'PO3'\nEEG_data.loc[EEG_data['sensor position'] == 'PO2', 'sensor position'] = 'PO4'\n\nEEG_data.loc[EEG_data['sensor position'] == 'FP1', 'sensor position'] = 'Fp1'\nEEG_data.loc[EEG_data['sensor position'] == 'FP2', 'sensor position'] = 'Fp2'\nEEG_data.loc[EEG_data['sensor position'] == 'CPZ', 'sensor position'] = 'CPz'\nEEG_data.loc[EEG_data['sensor position'] == 'FZ', 'sensor position'] = 'Fz'\n\nEEG_data.loc[EEG_data['sensor position'] == 'CZ', 'sensor position'] = 'Cz' ## exclusion of this position because it has a systematically extrem value\n\nEEG_data.loc[EEG_data['sensor position'] == 'PZ', 'sensor position'] = 'Pz'\nEEG_data.loc[EEG_data['sensor position'] == 'FPZ', 'sensor position'] = 'Fpz'\nEEG_data.loc[EEG_data['sensor position'] == 'AFZ', 'sensor position'] = 'AFz'\nEEG_data.loc[EEG_data['sensor position'] == 'FCZ', 'sensor position'] = 'FCz'\n\nEEG_data.loc[EEG_data['sensor position'] == 'POZ', 'sensor position'] = 'POz'\nEEG_data.loc[EEG_data['sensor position'] == 'OZ', 'sensor position'] = 'Oz'\n\n## Control Group\n\n\nEEG_data_control = EEG_data_control.drop(['Unnamed: 0'], axis=1) ## remove the unused column\nEEG_data_control.loc[EEG_data_control['matching condition'] == 'S2 nomatch,', 'matching condition'] =  'S2 nomatch' ## remove comma sign from stimulus name    \n## replace some 'sensor position' values\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'AF1', 'sensor position'] = 'AF3'\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'AF2', 'sensor position'] = 'AF4'\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'PO1', 'sensor position'] = 'PO3'\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'PO2', 'sensor position'] = 'PO4'\n\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'FP1', 'sensor position'] = 'Fp1'\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'FP2', 'sensor position'] = 'Fp2'\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'CPZ', 'sensor position'] = 'CPz'\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'FZ', 'sensor position'] = 'Fz'\n\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'CZ', 'sensor position'] = 'Cz' ## exclusion of this position because it has a systematically extrem value\n\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'PZ', 'sensor position'] = 'Pz'\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'FPZ', 'sensor position'] = 'Fpz'\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'AFZ', 'sensor position'] = 'AFz'\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'FCZ', 'sensor position'] = 'FCz'\n\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'POZ', 'sensor position'] = 'POz'\nEEG_data_control.loc[EEG_data_control['sensor position'] == 'OZ', 'sensor position'] = 'Oz'","f37cffd8":"# Organzing according to experiment condition groups\n\n#Alc_Groups\nAlc_S1Obj = EEG_data[EEG_data['matching condition'] == 'S1 obj']\nAlc_S2Match = EEG_data[EEG_data['matching condition'] == 'S2 match']\nAlc_S2Nomatch = EEG_data[EEG_data['matching condition'] == 'S2 nomatch']\n\n#Control groups \nCon_S1Obj = EEG_data_control[EEG_data_control['matching condition'] == 'S1 obj']\nCon_S2Match = EEG_data_control[EEG_data_control['matching condition'] == 'S2 match']\nCon_S2Nomatch = EEG_data_control[EEG_data_control['matching condition'] == 'S2 nomatch']\n\n\ndef trial_len_integrity_check(inputDF):\n\n  nameAndTrialNumber = inputDF.groupby(['trial number','name']).size().reset_index().rename(columns={0:'count'})\n  nameAndTrialNumber['count'] =np.where(nameAndTrialNumber['count'] == 16384,False,True)\n\n  del inputDF\n\n  if nameAndTrialNumber['count'].any():\n    # data integrity problem\n    Exception('Data Integrity problem, one of the arrays is not shaped 256x256')\n  #nameAndTrialNumber.drop(['count'],axis=1)\n\n  return nameAndTrialNumber[['trial number','name']]\n\n\n# Creating dataframes that contain relevant indexing information and checks data integrity\n# Trial Number, and subject names \n\nCon_S1Obj_Index = trial_len_integrity_check(Con_S1Obj) \nCon_S2Match_Index = trial_len_integrity_check(Con_S2Match) \nCon_S2Nomatch_Index = trial_len_integrity_check(Con_S2Nomatch) \n\nAlc_S1Obj_Index = trial_len_integrity_check(Alc_S1Obj) \nAlc_S2Match_Index = trial_len_integrity_check(Alc_S2Match) \nAlc_S2Nomatch_Index = trial_len_integrity_check(Alc_S2Nomatch) \n\nAll_Alcs = pd.concat([Alc_S1Obj_Index,Alc_S2Match_Index,Alc_S2Nomatch_Index])\nAll_Cons = pd.concat([Con_S1Obj_Index,Con_S2Match_Index,Con_S2Nomatch_Index])\n\nAll_Alcs.reset_index(drop=True,inplace=True)\nAll_Cons.reset_index(drop=True,inplace=True)\n","c1219e79":"# visualizing the time series channels\nTrueCrimeSubjectZero = EEG_data[((EEG_data.name == 'co2a0000364') & (EEG_data['trial number'] == 0))]\nprint('Number of data points on example subject Zero, Trial Zero')\nprint(TrueCrimeSubjectZero.shape)\nprint('Number of Channels')\nprint(TrueCrimeSubjectZero.shape[0] \/ 256)\nprint('Sampling Rate')\nprint(TrueCrimeSubjectZero.shape[0] \/ 64)","105bd5c1":"# Examining one channel\noneSensor = TrueCrimeSubjectZero[TrueCrimeSubjectZero['sensor position'] == 'Fp1']\n\ntime = oneSensor['time']\nsensorValue = oneSensor['sensor value']\n\nplt.plot(time,sensorValue)\nplt.show()\n","9a892024":"from scipy.fft import fft, fftfreq\n\n# Number of samples in normalized_tone\nN = 256 * 1 # 256 htz for one second\n\nyf = abs(fft(sensorValue.astype(np.int64)))\nPowerFilterIndex =  np.where(yf >= 200)[0]\n#yf = np.delete(yf,PowerFilterIndex)\nyf[PowerFilterIndex] = 200\n\nvariance = np.std(yf)**2\n#fft_power = variance * abs(yf)\n\nN = len(yf)\n\nxf = abs(fftfreq(N, 1 \/ 100))\n\nprint(len(yf))\n# Values above 60 htz are removed they are likely noise generated by electrical devices \n\nplt.bar(xf, yf)\nplt.show()\n\n# Frequency Power information\n","e419a2cb":"t = 0.5\ntime = np.arange(0,256,1)\nscales = [0.1,4.3,7.3,21.3,32,64,512]\nx = yf\nsignal = sensorValue\n\ndef plot_wavelet(ax, time, signal, scales, waveletname = 'morl', \n                 cmap = plt.cm.seismic, title = '', ylabel = '', xlabel = ''):\n    \n    dt = 0.5\n\n    [coefficients, frequencies] = pywt.cwt(signal, scales, waveletname, dt)\n    #print(frequencies.max())\n    power = (abs(coefficients)) ** 2\n    period = 1. \/ frequencies\n    #levels = [0.0625, 0.125, 0.25, 0.5, 1, 2, 4, 8]\n    levels = [0.1,4.3,7.3,21.3,32,64,512]\n\n    contourlevels = np.log2(levels)\n    \n    im = ax.contourf(time, np.log2(period), np.log2(power), contourlevels, extend='both',cmap=cmap)\n    \n    ax.set_title(title, fontsize=20)\n    ax.set_ylabel(ylabel, fontsize=18)\n    ax.set_xlabel(xlabel, fontsize=18)\n    \n    yticks = 2**np.arange(np.ceil(np.log2(period.min())), np.ceil(np.log2(period.max())))\n    #ax.set_yticks(np.log2(yticks))\n    #ax.set_yticklabels(yticks)\n    ax.invert_yaxis()\n    ylim = ax.get_ylim()\n    ax.set_ylim(ylim[0], -1)\n    return yticks, ylim\n\n#scales = [1,2,4,8,16]#np.arange(1, 256)\n\nfig, ax = plt.subplots(figsize=(4, 4))\nplot_wavelet(ax, time, signal, scales, xlabel='', ylabel='', title='')\n\nax.set_xticks([])\nax.set_yticks([])\nax.set_xticklabels([])\nax.set_yticklabels([])\nax.margins(x=0,y=0)\nplt.tight_layout(pad=0, rect=(0,0,0,0))\nplt.show()","5bbd212e":"from google.colab import files\nfiles.upload() # Upload plotting_10005.txt\n# File easily found with a google search of: EEG plotting_10005.txt","bbb8a8f8":"def extract_frequency_band_power_information(input_data):\n\n    coords = pd.read_csv('\/content\/plotting_1005.txt', sep='\\t',  header = None)\n    coords = coords.drop(coords.columns[4], axis=1)\n\n            #refactored to increase performance\n    neeg = EEG_data.drop(columns=['matching condition','name','trial number', 'subject identifier','time', 'sample num', 'sensor value'])\n\n    neeg = neeg.drop_duplicates()\n\n    neeg = neeg.reset_index(drop=True)\n\n\n    trials_dic = {}\n\n    dbc = 0\n\n    if Alc_base.shape == Con_base.shape:\n        \n        #print('Same shape error:')\n        #print(Alc_base.shape)\n        #print(Con_base.shape)\n        raise SystemExit \n\n    if input_data.shape == Alc_base.shape[0]:\n      dbc = EEG_data\n\n    if input_data.shape == Con_base.shape[0]:\n      dbc = EEG_data_control\n    \n    if input_data[0] == Alc_S1ObjTrials_fft[0]:\n\n      dbc = Alc_S1Obj\n\n    if input_data[0] == Alc_S2MatchTrials_fft[0]:\n\n      dbc = Alc_S2Match\n\n    if input_data[0] == Alc_S2NomatchTrials_fft[0]:\n\n      dbc = Alc_S2Nomatch\n#########################\n      # Control\n\n    if input_data[0] == Con_S1ObjTrials_fft[0]:\n\n      dbc = Con_S1Obj\n\n    if input_data[0] == Con_S2MatchTrials_fft[0]:\n\n      dbc = Con_S2Match\n\n    if input_data[0] == Con_S2NomatchTrials_fft[0]:\n\n      dbc = Con_S2Nomatch\n\n\n    # Removing the non condition trials if necessary\n\n\n    for pos in input_data:\n        #print(pos)\n        #print(input_data.shape)\n        #print(dbc)        \n        \n        fullTrialData = dbc[dbc['trial number'] == pos]\n\n        # if filtered, drop the trials that don't fit the criterea \n        \n        testSubjectNameList = fullTrialData.name.unique()\n        #print(f'current {pos}')\n\n        #print(f'subject id list length {testSubjectNameList}')\n        for nameID in testSubjectNameList:\n            trial_subject  = fullTrialData.loc[fullTrialData['name'] == nameID]\n        #   print(nameID)\n\n            frameName = str(pos) + '_' + nameID              \n            trial_subject = trial_subject.pivot_table(index='channel', columns='time', values = 'sensor value')\n\n            trials_dic[frameName] = trial_subject\n\n    print('loop done, length of trials dictionary')\n    print(len(trials_dic))\n    #print(trials_dic.keys())\n\n\n\n    RGB_dic = {}\n\n\n\n    for key in trials_dic:\n        #print(data.head(1))\n        \n        \n        data = trials_dic.get(key)\n        #print('starting data conversion')\n        #print(data.shape)\n\n\n      # if encountering the odd null value, uses a forward fill \n        #data = data.fillna(method='ffill')\n\n\n\n        # Get real amplitudes of FFT (only in postive frequencies)\n\n        fft_raw = fft(data)\n\n        fft_vals = np.absolute(fft_raw)\n\n        fft_vals = normalize(fft_vals, axis=1)\n\n        # Get frequencies for amplitudes in Hz\n\n\n        fs = 256    # Sampling rate\n\n        fft_freq = fftfreq(fs, 1.0\/fs)\n\n\n        # Define EEG bands\n        eeg_bands = {'Theta': (4, 7),\n                  'Alpha': (8, 12),\n                  'Beta': (13, 30),\n                  }\n        \n        # Take the  sum of squared absolute values\/amplitudes for each EEG band\n\n        eeg_band_fft = defaultdict(list)\n\n        for band in eeg_bands:  \n        \n\n            freq_ix = np.where((fft_freq >= eeg_bands[band][0]) & \n                                (fft_freq <= eeg_bands[band][1]))[0]\n\n\n            \n            for channel in fft_vals:\n        \n                filterdch = channel[freq_ix]\n                \n                sqdvals = np.square(filterdch)\n                \n                sumvals = np.sum(sqdvals, axis=0)\n                \n                eeg_band_fft[band].append(sumvals)\n                \n\n\n\n        extracted_df =  pd.DataFrame(eeg_band_fft)\n\n\n\n\n        extracted_df = extracted_df.reset_index(drop=True)\n        neeg = neeg.reset_index(drop=True)\n\n\n\n        e_names =  neeg\n        e_names = e_names.rename(columns = {'sensor position' : 0})\n\n\n\n        extracted_df = extracted_df.join(neeg)\n\n        testerd = pd.merge(e_names, coords, on=0,  how='inner')\n\n\n        testerd.set_index('channel', inplace=True)\n\n        testerd.columns = ['pos','x', 'y', 'z']\n\n\n        extracted_df = extracted_df.rename(columns={'sensor position': \"pos\"})\n\n        #filter values and coordinates\n        extracted_df = pd.merge(extracted_df, testerd, on=\"pos\", how='inner')\n        extracted_df = extracted_df.drop(['x','y','z'], axis=1)\n        extracted_df.set_index('channel', inplace=True)\n\n        extracted_df = extracted_df.drop(columns=['pos'])\n        extracted_df.index.names = ['pos']\n        #adapted from https:\/\/www.samuelbosch.com\/2014\/02\/azimuthal-equidistant-projection.html\n\n        class Point(object):\n            def __init__(self,x, y, z):\n                self.x = x\n                self.y = y\n                self.z = z\n\n        class AzimuthalEquidistantProjection(object):\n            \"\"\" \n                http:\/\/mathworld.wolfram.com\/AzimuthalEquidistantProjection.html\n                http:\/\/mathworld.wolfram.com\/SphericalCoordinates.html\n            \"\"\"\n            def __init__(self):\n\n                self.t1 = pi \/ 2 ## polar latitude center of projection , https:\/\/en.wikipedia.org\/wiki\/Azimuthal_equidistant_projection\n                self.l0 = 0 ## arbitrary longitude center of projection\n                self.cost1 = cos(self.t1)\n                self.sint1 = sin(self.t1)\n        \n            def project(self, point):\n        \n                #ADDAPTED FOR 3D CARTESIAN TO SPHERICAL \n        \n                hxy = np.hypot(point.x, point.y)\n        \n                t = np.arctan2(point.z, hxy)\n                l = np.arctan2(point.y, point.x)\n        \n                ###\n        \n                costcosll0 = cos(t) * cos(l-self.l0)\n                sint = sin(t)\n        \n                c = acos ((self.sint1) * (sint) + (self.cost1) * costcosll0)\n                k = c \/ sin(c)\n        \n                x = k * cos(t) * sin(l-self.l0)\n                y = k * (self.cost1 * sint - self.sint1 * costcosll0)\n                return x, y\n\n\n            \n        #Projection df\n\n        projected_df =  pd.DataFrame()\n\n        for index, row in testerd.iterrows():\n\n            x = row['x']\n            y = row['y']\n            z = row['z']\n\n\n            p = AzimuthalEquidistantProjection()\n            r = p.project(Point(x,y,z))\n\n            r = pd.Series(r)\n\n            projected_df = projected_df.append(r,ignore_index=True)\n        \n\n        projected_df =  projected_df.rename(columns={0: 'X',1: 'Y'})\n\n\n        ###map coodinate with valuies\n\n        new_df = projected_df.join(extracted_df)\n        new_df = new_df.drop([31]) # drop row because i contains no values\n        #print(new_df)\n\n        Theta_df = new_df.drop(['Alpha','Beta','X','Y'], axis=1)\n        Alpha_df = new_df.drop(['Theta','Beta','X','Y'], axis=1)\n        Beta_df = new_df.drop(['Theta','Alpha','X','Y'], axis=1)\n        \n\n        #map onto mesh\n\n        xpoints = np.array(new_df[['X']].squeeze())\n        ypoints = np.array(new_df[['Y']].squeeze())\n\n        Thetavalues = np.array(Theta_df).squeeze()\n        Alphavalues = np.array(Alpha_df).squeeze()\n        Betavalues = np.array(Beta_df).squeeze()\n        \n\n        xx,yy = np.mgrid[-1.5:1.5:32j, -1.5:1.5:32j]\n\n        Thetavalues = minmax_scale(Thetavalues,feature_range=(0.0, 1.0), axis=0)\n        Alphavalues = minmax_scale(Alphavalues,feature_range=(0.0, 1.0), axis=0)\n        Betavalues = minmax_scale(Betavalues,feature_range=(0.0, 1.0), axis=0)\n\n\n\n        Thetagrid = griddata((xpoints, ypoints), Thetavalues, (xx, yy),method='cubic', fill_value = 0.0)\n        Alphagrid = griddata((xpoints, ypoints), Alphavalues, (xx, yy),method='cubic', fill_value = 0.0)\n        Betagrid = griddata((xpoints, ypoints), Betavalues, (xx, yy),method='cubic', fill_value = 0.0)\n      \n\n        ##RGB construction\n\n        RGB = np.empty((32, 32, 3))\n\n        RGB[:,:,0] = Thetagrid\n        RGB[:,:,1] = Alphagrid\n        RGB[:,:,2] = Betagrid\n\n        RGB_dic[key] = RGB\n    ##creating new dict with new keys\n\n    lendict = len(RGB_dic)\n    #print('lendict: ',lendict)\n\n    lenlist=np.arange(0,lendict)\n\n    #print(lenlist)\n\n    final_dict = dict(zip(lenlist, list(RGB_dic.values()))) \n    return final_dict\n\n      ","7befa9ea":"def pull_trial_numbers(input_data):\n  trialNumbers = input_data['trial number'].unique()\n  return trialNumbers\n\n\n\nAlc_S1ObjTrials_fft = pull_trial_numbers(Alc_S1Obj)\nAlc_S2MatchTrials_fft = pull_trial_numbers(Alc_S2Match)\nAlc_S2NomatchTrials_fft = pull_trial_numbers(Alc_S2Nomatch)\n\nCon_S1ObjTrials_fft = pull_trial_numbers(Con_S1Obj)\nCon_S2MatchTrials_fft = pull_trial_numbers(Con_S2Match)\nCon_S2NomatchTrials_fft = pull_trial_numbers(Con_S2Nomatch)\n\nAlc_base = EEG_data['trial number'].unique()\nCon_base = EEG_data_control['trial number'].unique()\n","0dc74bf5":"\nAlc_S1Obj_Dict_fft = extract_frequency_band_power_information(Alc_S1ObjTrials_fft)\nAlc_S2Match_Dict_fft = extract_frequency_band_power_information(Alc_S2MatchTrials_fft)\nAlc_S2Nomatch_Dict_fft = extract_frequency_band_power_information(Alc_S2NomatchTrials_fft)\n\nCon_S1Obj_Dict_fft = extract_frequency_band_power_information(Con_S1ObjTrials_fft)\nCon_S2Match_Dict_fft = extract_frequency_band_power_information(Con_S2MatchTrials_fft)\nCon_S2Nomatch_Dict_fft = extract_frequency_band_power_information(Con_S2NomatchTrials_fft)","7aee328b":"alc_dict_fft = {}\ncon_dict_fft = {}\n\n# Merging the output dictionaries\n\n\nalc_dict_fft.update(Alc_S1Obj_Dict_fft)\n\nnext_dict_keys = [ key + len(alc_dict_fft) for key in Alc_S2Match_Dict_fft.keys()]\ntmp_dict   = dict(zip(next_dict_keys,Alc_S2Match_Dict_fft.values()))\nalc_dict_fft.update(tmp_dict)\n\nnext_dict_keys = [ key + len(alc_dict_fft) for key in Alc_S2Nomatch_Dict_fft.keys()]\ntmp_dict   = dict(zip(next_dict_keys,Alc_S2Nomatch_Dict_fft.values()))\nalc_dict_fft.update(tmp_dict)\n\n########### merging the control dictionaries\n\n\ncon_dict_fft.update(Con_S1Obj_Dict_fft)\n\nnext_dict_keys = [ key + len(con_dict_fft) for key in Con_S2Match_Dict_fft.keys()]\ntmp_dict   = dict(zip(next_dict_keys,Con_S2Match_Dict_fft.values()))\ncon_dict_fft.update(tmp_dict)\n\nnext_dict_keys = [ key + len(con_dict_fft) for key in Con_S2Nomatch_Dict_fft.keys()]\ntmp_dict   = dict(zip(next_dict_keys,Con_S2Nomatch_Dict_fft.values()))\ncon_dict_fft.update(tmp_dict)\n\n","980b6988":"def save_array_as_image(inputDict,is_alc):\n # for i, (key,value) in enumerate(inputDict.items()):\n  from PIL import Image\n  if is_alc == True:\n     is_alc = '_alc'\n  else:\n     is_alc = '_con'\n\n  for k,v in inputDict.items():\n    imName = str(k) + is_alc + '.jpg'\n    im = Image.fromarray((v * 255).astype(np.uint8))\n    im.save(imName)","f44eb265":"# directory setup (make your own )\n%mkdir \/home\/james\n%cd \/home\/james\/\n\n!mkdir EEG_Images_fft\n%cd \/home\/james\/EEG_Images_fft\n\n\n!mkdir \/home\/james\/EEG_Images_fft\/Alc\n!mkdir \/home\/james\/EEG_Images_fft\/Con\n\n\n# Saving the images in directories for a dataloader to use later\n%cd \/home\/james\/EEG_Images_fft\/Con\nsave_array_as_image(con_dict_fft,is_alc=False)\n\n%cd \/home\/james\/EEG_Images_fft\/Alc\nsave_array_as_image(alc_dict_fft,is_alc=True)\n","d23e98ad":"%cd \/home\/james\/\n\nroot_dir = \"\/home\/james\/EEG_Images_fft\"\nEEG_Con_Path = os.path.join(root_dir,'Con')\nEEG_Alc_Path = os.path.join(root_dir,'Alc')\n\nList_EEG_Con = [os.path.join(EEG_Con_Path, f) for f in os.listdir(EEG_Con_Path)]\nList_EEG_Alc = [os.path.join(EEG_Alc_Path, f) for f in os.listdir(EEG_Alc_Path)]\n","e300d9bc":"from fastbook import tensor\nfrom fastbook import Image\nfrom fastbook import show_image","4a5851ee":"tensors_dict = {}\n\ntensors_dict[0] = [tensor(Image.open(o)) for o in List_EEG_Con]\ntensors_dict[1] = [tensor(Image.open(o)) for o in List_EEG_Alc]\n\nstacked_tensors_dict = {}\nfor digit, img_tensor in tensors_dict.items():\n    stacked_tensors_dict[digit] = torch.stack(img_tensor).float()\/255\n\n    means_dict = {}\nfor digit, tnsr in stacked_tensors_dict.items():\n    means_dict[digit] = stacked_tensors_dict[digit].mean(0)\n    show_image(means_dict[digit],)\n    # first is for alcoholics\n    # Second is for the control","0d9b3507":"alcTheta_mean = stacked_tensors_dict[0][:,:,:,0].mean(0)\nconTheta_mean = stacked_tensors_dict[1][:,:,:,0].mean(0)\n\nalcAlpha_mean = stacked_tensors_dict[0][:,:,:,1].mean(0)\nconAlpha_mean = stacked_tensors_dict[1][:,:,:,1].mean(0)\n\nalcBeta_mean = stacked_tensors_dict[0][:,:,:,2].mean(0)\nconBeta_mean = stacked_tensors_dict[1][:,:,:,2].mean(0)","0ed65a12":"show_image(alcTheta_mean,figsize=(5,5),title='Alcoholic average Theta Waves')\n\n#","221eac7b":"show_image(conTheta_mean,figsize=(5,5),title='Control average Theta Waves')\n","7daa1f23":"show_image(alcAlpha_mean,figsize=(5,5),title='Alcoholic average Alpha Waves')\nshow_image(conAlpha_mean,figsize=(5,5),title='Control average Alpha Waves')\n","c91d67d3":"show_image(alcBeta_mean,figsize=(5,5),title='Alcoholic average Beta Waves')\nshow_image(conBeta_mean,figsize=(5,5),title='Control average Beta Waves')\n","4f68af54":"%cd \/home\/james\/\n\nroot_dir = \"\/home\/james\/EEG_Images_fft\"\nEEG_Con_Path = os.path.join(root_dir,'Con')\nEEG_Alc_Path = os.path.join(root_dir,'Alc')\n\nList_EEG_Con = [os.path.join(EEG_Con_Path, f) for f in os.listdir(EEG_Con_Path)]\nList_EEG_Alc = [os.path.join(EEG_Alc_Path, f) for f in os.listdir(EEG_Alc_Path)]\n\nNumOfControlImages = len(List_EEG_Con) \nNumOfAlchImages = len(List_EEG_Alc) \n\nprint(f'Control Group size {NumOfControlImages}')\nprint(f'Alcholic Group size: {NumOfAlchImages}')\n\nclass DataLoaders(GetAttr):\n  def __init__(self, *loaders): self.loaders = loaders\n  def __getitem__(self, i): return self.loaders[i]\n  train,valid = add_props(lambda i, self: self[i])\n\nEEGs = DataBlock (\n    blocks=(ImageBlock, CategoryBlock),\n    get_items=get_image_files,\n    splitter = RandomSplitter(valid_pct=0.2, seed=42),\n    get_y=parent_label,\n    item_tfms=Resize(32,32))\n\ndls = EEGs.dataloaders\ndestination =Path(root_dir)\npath = destination\nfns = get_image_files(path)\ndls = EEGs.dataloaders(path)","787ec13d":"dls.valid.show_batch(max_n=16, nrows=4)","9bdcac94":"learn = cnn_learner(dls, resnet18, metrics=error_rate)\nlearn.fine_tune(6)","7e2c499f":"def extract_beta_frequency_band_power_information(input_data):\n\n    coords = pd.read_csv('\/content\/plotting_1005.txt', sep='\\t',  header = None)\n    coords = coords.drop(coords.columns[4], axis=1)\n\n            #refactored to increase performance\n    neeg = EEG_data.drop(columns=['matching condition','name','trial number', 'subject identifier','time', 'sample num', 'sensor value'])\n\n    neeg = neeg.drop_duplicates()\n\n    neeg = neeg.reset_index(drop=True)\n\n\n    trials_dic = {}\n\n    dbc = 0\n\n    if Alc_base.shape == Con_base.shape:\n        \n        #print('Same shape error:')\n        #print(Alc_base.shape)\n        #print(Con_base.shape)\n        raise SystemExit \n\n    if input_data.shape == Alc_base.shape[0]:\n      dbc = EEG_data\n\n    if input_data.shape == Con_base.shape[0]:\n      dbc = EEG_data_control\n    \n    if input_data[0] == Alc_S1ObjTrials_fft[0]:\n\n      dbc = Alc_S1Obj\n\n    if input_data[0] == Alc_S2MatchTrials_fft[0]:\n\n      dbc = Alc_S2Match\n\n    if input_data[0] == Alc_S2NomatchTrials_fft[0]:\n\n      dbc = Alc_S2Nomatch\n#########################\n      # Control\n\n    if input_data[0] == Con_S1ObjTrials_fft[0]:\n\n      dbc = Con_S1Obj\n\n    if input_data[0] == Con_S2MatchTrials_fft[0]:\n\n      dbc = Con_S2Match\n\n    if input_data[0] == Con_S2NomatchTrials_fft[0]:\n\n      dbc = Con_S2Nomatch\n\n\n    # Removing the non condition trials if necessary\n\n\n    for pos in input_data:\n        #print(pos)\n        #print(input_data.shape)\n        #print(dbc)        \n        \n        fullTrialData = dbc[dbc['trial number'] == pos]\n\n        # if filtered, drop the trials that don't fit the criterea \n        \n        testSubjectNameList = fullTrialData.name.unique()\n        #print(f'current {pos}')\n\n        #print(f'subject id list length {testSubjectNameList}')\n        for nameID in testSubjectNameList:\n            trial_subject  = fullTrialData.loc[fullTrialData['name'] == nameID]\n        #   print(nameID)\n\n            frameName = str(pos) + '_' + nameID              \n            trial_subject = trial_subject.pivot_table(index='channel', columns='time', values = 'sensor value')\n\n            trials_dic[frameName] = trial_subject\n\n    print('loop done, length of trials dictionary')\n    print(len(trials_dic))\n    #print(trials_dic.keys())\n\n\n\n    RGB_dic = {}\n\n\n\n    for key in trials_dic:\n        #print(data.head(1))\n        \n        \n        data = trials_dic.get(key)\n        #print('starting data conversion')\n        #print(data.shape)\n\n\n      # if encountering the odd null value, uses a forward fill \n        #data = data.fillna(method='ffill')\n\n\n\n        # Get real amplitudes of FFT (only in postive frequencies)\n\n        fft_raw = fft(data)\n\n        fft_vals = np.absolute(fft_raw)\n\n        fft_vals = normalize(fft_vals, axis=1)\n\n        # Get frequencies for amplitudes in Hz\n\n\n        fs = 256    # Sampling rate\n\n        fft_freq = fftfreq(fs, 1.0\/fs)\n\n\n        # Define EEG bands\n        eeg_bands = {'Theta': (11, 15),\n                  'Alpha': (16, 20),\n                  'Beta': (21, 28),\n                  }\n        \n        # Take the  sum of squared absolute values\/amplitudes for each EEG band\n\n        eeg_band_fft = defaultdict(list)\n\n        for band in eeg_bands:  \n        \n\n            freq_ix = np.where((fft_freq >= eeg_bands[band][0]) & \n                                (fft_freq <= eeg_bands[band][1]))[0]\n\n\n            \n            for channel in fft_vals:\n        \n                filterdch = channel[freq_ix]\n                \n                sqdvals = np.square(filterdch)\n                \n                sumvals = np.sum(sqdvals, axis=0)\n                \n                eeg_band_fft[band].append(sumvals)\n                \n\n\n\n        extracted_df =  pd.DataFrame(eeg_band_fft)\n\n\n\n\n        extracted_df = extracted_df.reset_index(drop=True)\n        neeg = neeg.reset_index(drop=True)\n\n\n\n        e_names =  neeg\n        e_names = e_names.rename(columns = {'sensor position' : 0})\n\n\n\n        extracted_df = extracted_df.join(neeg)\n\n        testerd = pd.merge(e_names, coords, on=0,  how='inner')\n\n\n        testerd.set_index('channel', inplace=True)\n\n        testerd.columns = ['pos','x', 'y', 'z']\n\n\n        extracted_df = extracted_df.rename(columns={'sensor position': \"pos\"})\n\n        #filter values and coordinates\n        extracted_df = pd.merge(extracted_df, testerd, on=\"pos\", how='inner')\n        extracted_df = extracted_df.drop(['x','y','z'], axis=1)\n        extracted_df.set_index('channel', inplace=True)\n\n        extracted_df = extracted_df.drop(columns=['pos'])\n        extracted_df.index.names = ['pos']\n        #adapted from https:\/\/www.samuelbosch.com\/2014\/02\/azimuthal-equidistant-projection.html\n\n        class Point(object):\n            def __init__(self,x, y, z):\n                self.x = x\n                self.y = y\n                self.z = z\n\n        class AzimuthalEquidistantProjection(object):\n            \"\"\" \n                http:\/\/mathworld.wolfram.com\/AzimuthalEquidistantProjection.html\n                http:\/\/mathworld.wolfram.com\/SphericalCoordinates.html\n            \"\"\"\n            def __init__(self):\n\n                self.t1 = pi \/ 2 ## polar latitude center of projection , https:\/\/en.wikipedia.org\/wiki\/Azimuthal_equidistant_projection\n                self.l0 = 0 ## arbitrary longitude center of projection\n                self.cost1 = cos(self.t1)\n                self.sint1 = sin(self.t1)\n        \n            def project(self, point):\n        \n                #ADDAPTED FOR 3D CARTESIAN TO SPHERICAL \n        \n                hxy = np.hypot(point.x, point.y)\n        \n                t = np.arctan2(point.z, hxy)\n                l = np.arctan2(point.y, point.x)\n        \n                ###\n        \n                costcosll0 = cos(t) * cos(l-self.l0)\n                sint = sin(t)\n        \n                c = acos ((self.sint1) * (sint) + (self.cost1) * costcosll0)\n                k = c \/ sin(c)\n        \n                x = k * cos(t) * sin(l-self.l0)\n                y = k * (self.cost1 * sint - self.sint1 * costcosll0)\n                return x, y\n\n\n            \n        #Projection df\n\n        projected_df =  pd.DataFrame()\n\n        for index, row in testerd.iterrows():\n\n            x = row['x']\n            y = row['y']\n            z = row['z']\n\n\n            p = AzimuthalEquidistantProjection()\n            r = p.project(Point(x,y,z))\n\n            r = pd.Series(r)\n\n            projected_df = projected_df.append(r,ignore_index=True)\n        \n\n        projected_df =  projected_df.rename(columns={0: 'X',1: 'Y'})\n\n\n        ###map coodinate with valuies\n\n        new_df = projected_df.join(extracted_df)\n        new_df = new_df.drop([31]) # drop row because i contains no values\n        #print(new_df)\n\n        Theta_df = new_df.drop(['Alpha','Beta','X','Y'], axis=1)\n        Alpha_df = new_df.drop(['Theta','Beta','X','Y'], axis=1)\n        Beta_df = new_df.drop(['Theta','Alpha','X','Y'], axis=1)\n        \n\n        #map onto mesh\n\n        xpoints = np.array(new_df[['X']].squeeze())\n        ypoints = np.array(new_df[['Y']].squeeze())\n\n        Thetavalues = np.array(Theta_df).squeeze()\n        Alphavalues = np.array(Alpha_df).squeeze()\n        Betavalues = np.array(Beta_df).squeeze()\n        \n\n        xx,yy = np.mgrid[-1.5:1.5:32j, -1.5:1.5:32j]\n\n        Thetavalues = minmax_scale(Thetavalues,feature_range=(0.0, 1.0), axis=0)\n        Alphavalues = minmax_scale(Alphavalues,feature_range=(0.0, 1.0), axis=0)\n        Betavalues = minmax_scale(Betavalues,feature_range=(0.0, 1.0), axis=0)\n\n\n\n        Thetagrid = griddata((xpoints, ypoints), Thetavalues, (xx, yy),method='cubic', fill_value = 0.0)\n        Alphagrid = griddata((xpoints, ypoints), Alphavalues, (xx, yy),method='cubic', fill_value = 0.0)\n        Betagrid = griddata((xpoints, ypoints), Betavalues, (xx, yy),method='cubic', fill_value = 0.0)\n      \n\n        ##RGB construction\n\n        RGB = np.empty((32, 32, 3))\n\n        RGB[:,:,0] = Thetagrid\n        RGB[:,:,1] = Alphagrid\n        RGB[:,:,2] = Betagrid\n\n        RGB_dic[key] = RGB\n    ##creating new dict with new keys\n\n    lendict = len(RGB_dic)\n    #print('lendict: ',lendict)\n\n    lenlist=np.arange(0,lendict)\n\n    #print(lenlist)\n\n    final_dict = dict(zip(lenlist, list(RGB_dic.values()))) \n    return final_dict\n\n      ","774d7c3b":"def pull_trial_numbers(input_data):\n  trialNumbers = input_data['trial number'].unique()\n  return trialNumbers\n\nAlc_S1ObjTrials_fft = pull_trial_numbers(Alc_S1Obj)\nAlc_S2MatchTrials_fft = pull_trial_numbers(Alc_S2Match)\nAlc_S2NomatchTrials_fft = pull_trial_numbers(Alc_S2Nomatch)\n\nCon_S1ObjTrials_fft = pull_trial_numbers(Con_S1Obj)\nCon_S2MatchTrials_fft = pull_trial_numbers(Con_S2Match)\nCon_S2NomatchTrials_fft = pull_trial_numbers(Con_S2Nomatch)\n\nAlc_base = EEG_data['trial number'].unique()\nCon_base = EEG_data_control['trial number'].unique()\n","51ea3285":"\nAlc_S1Obj_Dict_fft = extract_beta_frequency_band_power_information(Alc_S1ObjTrials_fft)\nAlc_S2Match_Dict_fft = extract_beta_frequency_band_power_information(Alc_S2MatchTrials_fft)\nAlc_S2Nomatch_Dict_fft = extract_beta_frequency_band_power_information(Alc_S2NomatchTrials_fft)\n\nCon_S1Obj_Dict_fft = extract_beta_frequency_band_power_information(Con_S1ObjTrials_fft)\nCon_S2Match_Dict_fft = extract_beta_frequency_band_power_information(Con_S2MatchTrials_fft)\nCon_S2Nomatch_Dict_fft = extract_beta_frequency_band_power_information(Con_S2NomatchTrials_fft)","a248a0b3":"alc_dict_fft = {}\ncon_dict_fft = {}\n\n# Merging the output dictionaries\n\n\nalc_dict_fft.update(Alc_S1Obj_Dict_fft)\n\nnext_dict_keys = [ key + len(alc_dict_fft) for key in Alc_S2Match_Dict_fft.keys()]\ntmp_dict   = dict(zip(next_dict_keys,Alc_S2Match_Dict_fft.values()))\nalc_dict_fft.update(tmp_dict)\n\nnext_dict_keys = [ key + len(alc_dict_fft) for key in Alc_S2Nomatch_Dict_fft.keys()]\ntmp_dict   = dict(zip(next_dict_keys,Alc_S2Nomatch_Dict_fft.values()))\nalc_dict_fft.update(tmp_dict)\n\n########### merging the control dictionaries\n\n\ncon_dict_fft.update(Con_S1Obj_Dict_fft)\n\nnext_dict_keys = [ key + len(con_dict_fft) for key in Con_S2Match_Dict_fft.keys()]\ntmp_dict   = dict(zip(next_dict_keys,Con_S2Match_Dict_fft.values()))\ncon_dict_fft.update(tmp_dict)\n\nnext_dict_keys = [ key + len(con_dict_fft) for key in Con_S2Nomatch_Dict_fft.keys()]\ntmp_dict   = dict(zip(next_dict_keys,Con_S2Nomatch_Dict_fft.values()))\ncon_dict_fft.update(tmp_dict)\n\n","8c24d617":"def save_array_as_image(inputDict,is_alc):\n # for i, (key,value) in enumerate(inputDict.items()):\n  from PIL import Image\n  if is_alc == True:\n     is_alc = '_alc'\n  else:\n     is_alc = '_con'\n\n  for k,v in inputDict.items():\n    imName = str(k) + is_alc + '.jpg'\n    im = Image.fromarray((v * 255).astype(np.uint8))\n    im.save(imName)","857bd23a":"# directory setup \n%cd \/home\/james\/\n\n!mkdir EEG_Images_fft_beta\n%cd \/home\/james\/EEG_Images_fft_beta\n\n\n!mkdir \/home\/james\/EEG_Images_fft_beta\/Alc\n!mkdir \/home\/james\/EEG_Images_fft_beta\/Con\n\n","309c136e":"%cd \/home\/james\/EEG_Images_fft_beta\/Con\nsave_array_as_image(con_dict_fft,is_alc=False)\n\n%cd \/home\/james\/EEG_Images_fft_beta\/Alc\nsave_array_as_image(alc_dict_fft,is_alc=True)\n","5841201e":"root_dir = \"\/home\/james\/EEG_Images_fft_beta\"\nEEG_Con_Path = os.path.join(root_dir,'Con')\nEEG_Alc_Path = os.path.join(root_dir,'Alc')\n\nList_EEG_Con = [os.path.join(EEG_Con_Path, f) for f in os.listdir(EEG_Con_Path)]\nList_EEG_Alc = [os.path.join(EEG_Alc_Path, f) for f in os.listdir(EEG_Alc_Path)]\n","cd0b7d82":"tensors_dict = {}\n\ntensors_dict[0] = [tensor(Image.open(o)) for o in List_EEG_Con]\ntensors_dict[1] = [tensor(Image.open(o)) for o in List_EEG_Alc]\n\nstacked_tensors_dict = {}\nfor digit, img_tensor in tensors_dict.items():\n    stacked_tensors_dict[digit] = torch.stack(img_tensor).float()\/255\n\n    means_dict = {}\nfor digit, tnsr in stacked_tensors_dict.items():\n    means_dict[digit] = stacked_tensors_dict[digit].mean(0)\n    show_image(means_dict[digit],)\n    # first is for alcoholics\n    # Second is for the control","6a8de5a9":"alcTheta_mean = stacked_tensors_dict[0][:,:,:,0].mean(0)\nconTheta_mean = stacked_tensors_dict[1][:,:,:,0].mean(0)\n\nalcAlpha_mean = stacked_tensors_dict[0][:,:,:,1].mean(0)\nconAlpha_mean = stacked_tensors_dict[1][:,:,:,1].mean(0)\n\nalcBeta_mean = stacked_tensors_dict[0][:,:,:,2].mean(0)\nconBeta_mean = stacked_tensors_dict[1][:,:,:,2].mean(0)","f503ac97":"show_image(alcTheta_mean,figsize=(5,5),title='Power of Alcoholic Beta1 Waves')\nshow_image(conTheta_mean,figsize=(5,5),title='Power of Control Beta1 Waves')\n","9ec6ec0e":"show_image(alcAlpha_mean,figsize=(5,5),title='Alcoholic average Beta 2 Waves')\nshow_image(conAlpha_mean,figsize=(5,5),title='Control average Beta 2 Waves')\n","36e60774":"show_image(alcBeta_mean,figsize=(5,5),title='Alcoholic average Beta 3 Waves')\nshow_image(conBeta_mean,figsize=(5,5),title='Control average Beta 3 Waves')","cf8bd8ec":"%cd \/home\/james\/\n\nroot_dir = \"\/home\/james\/EEG_Images_fft\"\nEEG_Con_Path = os.path.join(root_dir,'Con')\nEEG_Alc_Path = os.path.join(root_dir,'Alc')\n\nList_EEG_Con = [os.path.join(EEG_Con_Path, f) for f in os.listdir(EEG_Con_Path)]\nList_EEG_Alc = [os.path.join(EEG_Alc_Path, f) for f in os.listdir(EEG_Alc_Path)]\n","31716141":"from fastbook import GetAttr\nfrom fastbook import DataBlock\nfrom fastbook import add_props\nfrom fastbook import ImageBlock\nfrom fastbook import CategoryBlock\nfrom fastbook import get_image_files\nfrom fastbook import RandomSplitter\nfrom fastbook import parent_label\nfrom fastbook import Resize\n\nfrom fastbook import Path\nfrom fastbook import cnn_learner\nfrom fastbook import error_rate\nfrom fastbook import resnet18\nfrom fastbook import ClassificationInterpretation\nfrom fastbook import xresnet18","ca79364e":"%cd \/home\/james\/\n\nroot_dir = \"\/home\/james\/EEG_Images_fft\"\nEEG_Con_Path = os.path.join(root_dir,'Con')\nEEG_Alc_Path = os.path.join(root_dir,'Alc')\n\nList_EEG_Con = [os.path.join(EEG_Con_Path, f) for f in os.listdir(EEG_Con_Path)]\nList_EEG_Alc = [os.path.join(EEG_Alc_Path, f) for f in os.listdir(EEG_Alc_Path)]\n\nNumOfControlImages = len(List_EEG_Con) \nNumOfAlchImages = len(List_EEG_Alc) \n\nprint(f'Control Group size {NumOfControlImages}')\nprint(f'Alcholic Group size: {NumOfAlchImages}')\n\nclass DataLoaders(GetAttr):\n  def __init__(self, *loaders): self.loaders = loaders\n  def __getitem__(self, i): return self.loaders[i]\n  train,valid = add_props(lambda i, self: self[i])\n\nEEGs = DataBlock (\n    blocks=(ImageBlock, CategoryBlock),\n    get_items=get_image_files,\n    splitter = RandomSplitter(valid_pct=0.2, seed=42),\n    get_y=parent_label,\n    item_tfms=Resize(32,32))\n\ndls = EEGs.dataloaders\ndestination =Path(root_dir)\npath = destination\nfns = get_image_files(path)\ndls = EEGs.dataloaders(path)","f1b46b9e":"dls.valid.show_batch(max_n=16, nrows=4)","26675b4a":"EEGs = EEGs.new()\ndls = EEGs.dataloaders(path)","e30a0bae":"learn = cnn_learner(dls, xresnet18, metrics=error_rate)\nlearn.fine_tune(6)","8d0d2210":"interp_round1 = ClassificationInterpretation.from_learner(learn)","9561c09b":"interp_round1.plot_confusion_matrix()","39b74459":"# Step 2 Analyse Channels by means of hierarchical clustering\n\n# Calculating the similarities in the time series, \n# Grouping together \n\n#Functions\n\ndef cluster_channels(distance_matrix,num_of_clusters):\n\n  def hierarchical_clustering(dist_mat, method='ward'):\n    if method == 'complete':\n        Z = complete(distance_matrix)\n    if method == 'single':\n        Z = single(distance_matrix)\n    if method == 'average':\n        Z = average(distance_matrix)\n    if method == 'ward':\n        Z = ward(distance_matrix)\n\n    # Plotted visualization\n\n    #fig = plt.figure(figsize=(16, 8))\n    #dn = dendrogram(Z)\n    #plt.title(f\"Dendrogram for {method}-linkage with correlation distance\")\n    #plt.show()\n\n    return Z\n\n  linkage_matrix = hierarchical_clustering(distance_matrix)\n\n  # The cluster labels match the rows in the one second frame\n\n  cluster_labels = fcluster(linkage_matrix, num_of_clusters, criterion='maxclust')\n  return cluster_labels\n\ndef select_clusters(cluster_index,totalFramesToInclude):\n    \n    unique_clusters = np.unique(cluster_index)\n    unique_clusters_count = np.unique(cluster_index,return_counts=True)[1]\n    #print(len(unique_clusters_count))\n    unique_clusters_count[unique_clusters_count != 0]\n    #print(len(unique_clusters_count))\n    \n    # Sort the order of the clusters into the largest to smallest\n\n    unique , count = np.unique(cluster_index, return_counts=True)\n\n    count_sort_ind = np.argsort(-count)\n\n    size_sorted_clusters = unique[count_sort_ind]\n\n  # Include all the clusters that are larger than one\n\n\n    #largerClusters = [k for k,v in enumerate(unique_clusters_count) if v > 1]\n\n    largerClusters = [k for k,v in enumerate(size_sorted_clusters) if v > 1]\n\n    # Below is an extremely important line, removes a zero from the index \n    # that does not belong in the cluster index. Otherwise everything breaks\n\n    largerClusters = [x for x in largerClusters if not x == 0]\n  \n    largerClusters = sorted(largerClusters)\n    \n\n    # If there are more 2+ size clusters than 9, then hanle that\n\n    if len(largerClusters) == totalFramesToInclude:\n      #largerClusters = sorted(largerClusters)\n\n      #Sort by size\n      final_clusters = largerClusters\n\n    # If there are more, chose the larger clusters\n    elif len(largerClusters) > totalFramesToInclude:\n      \n      largerClusters = sorted(largerClusters)\n      \n      x = totalFramesToInclude\n      largerClusters = largerClusters[0:x]\n\n\n    elif len(largerClusters) < totalFramesToInclude: # Choose the larger clusters, and then randomly select size one clusters\n\n\n      sizeOneClusters = list(set(unique_clusters).difference(largerClusters))\n\n      # Choosing the random small clusters to populate a list\n      numToRandSelect = totalFramesToInclude - len(largerClusters)\n      random_small_clusters = random.sample(sizeOneClusters,numToRandSelect)\n      largerClusters = largerClusters + random_small_clusters\n\n    else:\n      Exception('size error')\n\n    if not len(largerClusters) == totalFramesToInclude:\n      print('not ok')\n    \n    #print(len(largerClusters))\n\n    final_clusters = np.array(largerClusters)\n    \n    return final_clusters\n\n# Step 3 Select the final clusters to transform\n\n\ndef select_channels_to_transform(trial_index, clusters_index, final_clusters_index):\n  \n  \"\"\"\n  outputs indicies of the channels that will be called out of the\n  64 Channel EEG frame\n\n  Takes in a list of clusters that will be uses\n\n  \"\"\"\n  \n  finalChannelsIndex = {}\n\n\n  for i in np.nditer(final_clusters_index): #range(1,len(final_clusters_index)-1):\n    #print(i)\n    timeSeriesIndices = np.where(clusters_index==i)[0]\n    if timeSeriesIndices.shape[0] == 0:\n      print(len(timeSeriesIndices)) \n\n    randomSelectionIndex = np.random.choice(timeSeriesIndices)\n    finalChannelsIndex[randomSelectionIndex] = i\n  \n  return finalChannelsIndex\n\n\n","336e6ea5":"\ndef fig2data ( fig ):\n    \"\"\"\n    @brief Convert a Matplotlib figure to a 4D numpy array with RGBA channels and return it\n    @param fig a matplotlib figure\n    @return a numpy 3D array of RGBA values\n    \"\"\"\n    # draw the renderer\n    fig.canvas.draw ( )\n \n    # Get the RGBA buffer from the figure\n    w,h = fig.canvas.get_width_height()\n    buf = np.fromstring ( fig.canvas.tostring_argb(), dtype=np.uint8 )\n    buf.shape = ( w, h,4 )\n \n    # canvas.tostring_argb give pixmap in ARGB mode. Roll the ALPHA channel to have it in RGBA mode\n    buf = np.roll ( buf, 3, axis = 2 )\n    return buf\n    \nfor cluster in np.unique(cluster_labels):\n  print(f'####################New cluster {cluster}  ################3')\n\n  for channel in Alc_Example.index:\n    if cluster_labels[channel] == cluster:\n        print(cluster)\n        print(channel)\n        signal = Alc_Example.loc[channel]\n        x = signal\n\n        fig, ax = plt.subplots(figsize=(3,3))\n        plot_wavelet(ax, time, signal, scales, xlabel=xlabel, ylabel=ylabel, title=title)\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        ax.margins(x=0,y=0)\n        plt.tight_layout(pad=0, rect=(0,0,0,0))\n\n        np_array = fig2data(fig)\n\n\n\n        #plt_array = get_img_from_fig(plt,dpi=80)\n\n        plt.show()\n\n","93fb9203":"# Step 1, pull out all of the samples\n# from each Dataset\n\ndef pull_one_second_frame(row, trial_index,input_data):\n\n    \"\"\"\n    Indexes the dataframe for the unique name and trial,\n    then creates a 64 by 256 pivot table\n    containing the time, channel, and sensor voltage information\n\n    \"\"\"\n    return input_data[(input_data['trial number'] == trial_index.loc[row]['trial number']) &\n             (input_data['name'] == trial_index.loc[row]['name'])].pivot_table(index='channel', columns='time', values = 'sensor value')","cea0aa90":"# Part 2 \n\n# Step 4 Conversion to Wavelet, Plotting, and Numpy conversion\ndef wavelet_transformation_plot_to_array(signal):\n    dt = 0.8\n    time = np.arange(0,256,1)\n    scales = np.arange(1, 256)\n\n  #def plot_wavelet(ax, time, signal, scales, waveletname = 'cmor', \n  #                 cmap = plt.cm.seismic, title = '', ylabel = '', xlabel = ''):\n  \n\n    def plot_wavelet(ax, time, signal, scales, waveletname = 'morl', \n                    cmap = plt.cm.seismic, title = '', ylabel = '', xlabel = ''):\n        \n        dt = time[1] - time[0]\n        [coefficients, frequencies] = pywt.cwt(signal, scales, waveletname, dt)\n        power = (abs(coefficients)) ** 2\n        period = 1. \/ frequencies\n        #levels = [0.0625, 0.125, 0.25, 0.5, 1, 2, 4, 8]\n\n        # levels corresponding to different wavelengths of brain wave\n\n\n        levels = [0.1,4.3,7.3,21.3,32,64,512]\n\n        contourlevels = np.log2(levels)\n        \n        im = ax.contourf(time, np.log2(period), np.log2(power), contourlevels, extend='both',cmap=cmap)\n        \n        # turns off the plot\n        plt.ioff()\n\n\n        #ax.set_title(title, fontsize=20)\n        #ax.set_ylabel(ylabel, fontsize=18)\n        #ax.set_xlabel(xlabel, fontsize=18)\n        \n        yticks = 2**np.arange(np.ceil(np.log2(period.min())), np.ceil(np.log2(period.max())))\n        ax.set_yticks(np.log2(yticks))\n        ax.set_yticklabels(yticks)\n        \n        ax.invert_yaxis()\n        ylim = ax.get_ylim()\n        ax.set_ylim(ylim[0], -1)\n        return yticks, ylim\n\n    x = signal\n    title = ''\n    ylabel = ''\n    xlabel = ''\n\n\n\n    fig, ax = plt.subplots(figsize=(4,4))\n    plt.ioff()\n    plot_wavelet(ax, time, signal, scales, xlabel=xlabel, ylabel=ylabel, title=title)\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.set_xticklabels([])\n    ax.set_yticklabels([])\n    ax.margins(x=0,y=0)\n    plt.tight_layout(pad=0, rect=(0,0,0,0))\n\n    # Numpy conversion \n\n    def fig2data ( fig ):\n        \"\"\"\n        @brief Convert a Matplotlib figure to a 4D numpy array with RGBA channels and return it\n        @param fig a matplotlib figure\n        @return a numpy 3D array of RGBA values\n        \"\"\"\n        # draw the renderer\n        fig.canvas.draw ( )\n    \n        # Get the RGBA buffer from the figure\n        w,h = fig.canvas.get_width_height()\n        buf = np.frombuffer ( fig.canvas.tostring_argb(), dtype=np.uint8 )\n        buf.shape = ( w, h,4 )\n    \n        # canvas.tostring_argb give pixmap in ARGB mode. Roll the ALPHA channel to have it in RGBA mode\n        buf = np.roll ( buf, 3, axis = 2 )\n        return buf\n    plt.close()\n    outputArray = fig2data(fig)\n\n    return outputArray","0ff9a698":"# part 3 array processing and filtering\n\ndef rgba2rgb( rgba, background=(255,255,255) ):\n    row, col, ch = rgba.shape\n\n    if ch == 3:\n        return rgba\n\n    assert ch == 4, 'RGBA image has 4 channels.'\n\n    rgb = np.zeros( (row, col, 3), dtype='float32' )\n    r, g, b, a = rgba[:,:,0], rgba[:,:,1], rgba[:,:,2], rgba[:,:,3]\n\n    a = np.asarray( a, dtype='float32' ) \/ 255.0\n\n    R, G, B = background\n\n    rgb[:,:,0] = r * a + (1.0 - a) * R\n    rgb[:,:,1] = g * a + (1.0 - a) * G\n    rgb[:,:,2] = b * a + (1.0 - a) * B\n\n    return np.asarray( rgb, dtype='uint8' )\n\n\n","72f1f916":"## Step 8: Collaging the images and saving them\n\n# Functions to name each image\n\ndef name_image(trial, trial_index,experiment_condition=''):\n  \"\"\"\n  creates a file name for the image as a .jpg\n  includes the trial number, subjectID, and the experiment condition\n\n  OUTPUT = EXPCONDITION_TRIALNUMBER_SUBJECTID.jpg\n\n  \"\"\"\n\n  trial_num = str(trial_index.loc[trial]['trial number'])\n  subject_ID = str(trial_index.loc[trial]['name'])\n\n  fileName = experiment_condition + '_' + trial_num + '_' + subject_ID + '.jpg' \n\n  return fileName\n\ndef name_image_a_or_c(trial, trial_index):\n  \"\"\"\n  creates a file name for the image as a .jpg\n  includes the trial number, subjectID, and the experiment condition\n\n  OUTPUT = EXPCONDITION_TRIALNUMBER_SUBJECTID.jpg\n\n  \"\"\"\n\n  trial_num = str(trial_index.loc[trial]['trial number'])\n  subject_ID = str(trial_index.loc[trial]['name'])\n  experiment_condition = str(trial_index.loc[trial]['trial info'])\n\n  fileName = experiment_condition + '_' + trial_num + '_' + subject_ID + '.jpg' \n\n  return fileName\n","7a80c231":"# Code to create directories\n\n# Two groups Group 1: Fast AI Binary Classification\n\n# Group 2: Orignal Conditions for experiment\n\n#Base directory\n!mkdir \/home\/james\n!mkdir \/home\/james\/EEG\n\nfastAI_root_dir = '\/home\/james\/EEG'\n\n#Alc and Con Group \n!mkdir \/home\/james\/EEG\/Con\n!mkdir \/home\/james\/EEG\/Alc\nAlc_Dir = '\/home\/james\/EEG\/Alc'\nCon_Dir = '\/home\/james\/EEG\/Con'\n\n!mkdir \/home\/james\/EEG_Groups\n\norig_root_dir = '\/home\/james\/EEG_Groups'\n\n#Alc Group \n\n!mkdir \/home\/james\/EEG_Groups\/alc_s1Obj\n!mkdir \/home\/james\/EEG_Groups\/alc_s2Match\n!mkdir \/home\/james\/EEG_Groups\/alc_s2Nomatch\n\nAlc_S1Obj_Dir = '\/home\/james\/EEG_Groups\/alc_s1Obj'\nAlc_S2Match_Dir = '\/home\/james\/EEG_Groups\/alc_s2Match'\nAlc_S2Nomatch_Dir = '\/home\/james\/EEG_Groups\/alc_s2Nomatch'\n\n#Control Group\n\n!mkdir \/home\/james\/EEG_Groups\/con_s1Obj\n!mkdir \/home\/james\/EEG_Groups\/con_s2Match\n!mkdir \/home\/james\/EEG_Groups\/con_s2Nomatch\n\nCon_S1Obj_Dir = '\/home\/james\/EEG_Groups\/con_s1Obj'\nCon_S2Match_Dir = '\/home\/james\/EEG_Groups\/con_s2Match'\nCon_S2Nomatch_Dir = '\/home\/james\/EEG_Groups\/con_s2Nomatch'\n\n# For reference\n\n","08e935d1":"Alc_S1Obj_Index['trial info'] = 'a_S1Obj'\nAlc_S2Match_Index['trial info'] = 'a_S2Match'\nAlc_S2Nomatch_Index['trial info'] = 'a_S2Nomatch'\n\nCon_S1Obj_Index['trial info'] = 'c_S1Obj'\nCon_S2Match_Index['trial info'] = 'c_S2Match'\nCon_S2Nomatch_Index['trial info'] = 'c_S2Nomatch'\n\n\nAll_Alcs = pd.concat([Alc_S1Obj_Index,Alc_S2Match_Index,Alc_S2Nomatch_Index])\nAll_Cons = pd.concat([Con_S1Obj_Index,Con_S2Match_Index,Con_S2Nomatch_Index])\n\nAll_Alcs.reset_index(drop=True,inplace=True)\nAll_Cons.reset_index(drop=True,inplace=True)","731a90d8":"#!mkdir '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Alc'\n#!mkdir '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Con'\n","d16143f9":"# Feature Extraction for alcoholic group\n\n\n#alc_wavelet_img_dir = '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Alc'\n#con_wavelet_img_dir = '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Con'\n\n\n# Variables\ninput_data = EEG_data\ntrial_index = All_Alcs\n#experCond = 'c_S2Nomatch'\nimg_directory = Alc_Dir\n\n\nnum_of_clusters = 14\ntotalFramesToInclude = 9 \n\n\n\nfor trial in trial_index.index: #runs through trial index\n  #print('new row')\n  EEG_Frame = pull_one_second_frame(trial,trial_index,input_data)\n\n  # Analyse the EEG clusters\n  cluster_labels = cluster_channels(EEG_Frame,num_of_clusters)\n\n  final_clusters = select_clusters(cluster_labels,totalFramesToInclude)\n\n  ########### Step 2 Selecting the channels for analysis\n\n  final_channels = select_channels_to_transform(trial_index,cluster_labels,final_clusters)\n  #print(final_channels)\n\n  ########### Step 3 Processing the arrays\n\n  array_dict = {}\n\n  for key in final_channels.keys():\n    #print(key)\n    signal = EEG_Frame.loc[key]\n\n    # Raw array representation of plots\n    np_array = wavelet_transformation_plot_to_array(signal)\n    plt.close()\n    np_array = rgba2rgb(np_array)\n\n    # Grayscale filter to decrease size of images\n\n    #np_array = np.dot(np_array[...,:3], [0.287,0.299, 0.814])\n\n\n    # Cropping the array\n\n\n\n    array_dict[key] = np_array\n\n\n  ############ Step 4 ### Creating a collage\n\n  ordered_keys = list(array_dict.keys())\n\n  for (k,v) in array_dict.items():\n    array_dict[k] = cv2.resize(v,(200,200))\n\n\n  horizontalRow1 = np.hstack([array_dict[ordered_keys[0]],array_dict[ordered_keys[1]],array_dict[ordered_keys[2]]])\n  horizontalRow2 = np.hstack([array_dict[ordered_keys[3]],array_dict[ordered_keys[4]],array_dict[ordered_keys[5]]])\n  horizontalRow3 = np.hstack([array_dict[ordered_keys[6]],array_dict[ordered_keys[7]],array_dict[ordered_keys[8]]])\n\n\n  collaged_array = np.vstack([horizontalRow1,horizontalRow2,horizontalRow3])\n\n  nameOfCollage = name_image_a_or_c(int(trial),trial_index)\n\n  ######### Step 5 Save image\n\n  filePath = os.path.join(img_directory,nameOfCollage)\n  cv2.imwrite(filePath,collaged_array)\n\n  \n\n\n","bda8e373":"# Feature Extraction for Control Group\n\n# Config variables\ninput_data = EEG_data_control\ntrial_index = All_Cons\n#experCond = '' \nimg_directory = Con_Dir\n\n\nnum_of_clusters = 14\ntotalFramesToInclude = 9 \n\n\n\nfor trial in trial_index.index: #runs through trial index\n  #print('new row')\n  EEG_Frame = pull_one_second_frame(trial,trial_index,input_data)\n\n  # Analyse the EEG clusters\n  cluster_labels = cluster_channels(EEG_Frame,num_of_clusters)\n\n  final_clusters = select_clusters(cluster_labels,totalFramesToInclude)\n\n  ########### Step 2 Selecting the channels for analysis\n\n  final_channels = select_channels_to_transform(trial_index,cluster_labels,final_clusters)\n  #print(final_channels)\n\n  ########### Step 3 Processing the arrays\n\n  array_dict = {}\n\n  for key in final_channels.keys():\n    #print(key)\n    signal = EEG_Frame.loc[key]\n\n    # Raw array representation of plots# Config varialbes\n\n    np_array = wavelet_transformation_plot_to_array(signal)\n    np_array = rgba2rgb(np_array)\n\n    # Greyscale filter to decrease size of images\n\n    #np_array = np.dot(np_array[...,:3], [0.287,0.299, 0.814])\n\n    array_dict[key] = np_array\n\n\n  ############ Step 4 ### Creating a collage\n\n  ordered_keys = list(array_dict.keys())\n\n  for (k,v) in array_dict.items():\n    array_dict[k] = cv2.resize(v,(200,200))\n\n\n  horizontalRow1 = np.hstack([array_dict[ordered_keys[0]],array_dict[ordered_keys[1]],array_dict[ordered_keys[2]]])\n  horizontalRow2 = np.hstack([array_dict[ordered_keys[3]],array_dict[ordered_keys[4]],array_dict[ordered_keys[5]]])\n  horizontalRow3 = np.hstack([array_dict[ordered_keys[6]],array_dict[ordered_keys[7]],array_dict[ordered_keys[8]]])\n\n\n  collaged_array = np.vstack([horizontalRow1,horizontalRow2,horizontalRow3])\n\n  nameOfCollage = name_image_a_or_c(int(trial),trial_index)\n\n  ######### Step 5 Save image\n\n  filePath = os.path.join(img_directory,nameOfCollage)\n  cv2.imwrite(filePath,collaged_array)\n\n  \n","aca6bc48":"Alc_S1Obj_Dir = '\/home\/james\/EEG_Alc_Wavelets\/alc_s1Obj'\nAlc_S2Match_Dir = '\/home\/james\/EEG_Alc_Wavelets\/alc_s2Match'\nAlc_S2Nomatch_Dir = '\/home\/james\/EEG_Alc_Wavelets\/alc_s2Nomatch'\n\n#Control Group\n\n!mkdir \/home\/james\/EEG_Alc_Wavelets\/con_s1Obj\n!mkdir \/home\/james\/EEG_Alc_Wavelets\/con_s2Match\n!mkdir \/home\/james\/EEG_Alc_Wavelets\/con_s2Nomatch\n\nCon_S1Obj_Dir = '\/home\/james\/EEG_Alc_Wavelets\/con_s1Obj'\nCon_S2Match_Dir = '\/home\/james\/EEG_Alc_Wavelets\/con_s2Match'\nCon_S2Nomatch_Dir = '\/home\/james\/EEG_Alc_Wavelets\/con_s2Nomatch'\n\n# For reference","743f53c0":"# Handling directories\n\"\"\"\n\ngdrivePath = '\/content\/drive\/MyDrive\/Colab_Data\/EEG'\n\n%cd '\/content\/drive\/MyDrive\/Colab_Data\/EEG'\n\n!mkdir '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG'\n\n!mkdir '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Alc'\n!mkdir '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Con'\n\n#Alc_Dir = '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Alc'\n#Con_Dir = '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Con'\n\nfor fileName in os.listdir(Alc_S1Obj_Dir):\n  shutil.copy(os.path.join(Alc_s1Obj_Dir,fileName), os.path.join(Alc_Dir,fileName))\nfor fileName in os.listdir(Alc_S2Match_Dir):\n  shutil.copy(os.path.join(Alc_S2Match_Dir,fileName), os.path.join(Alc_Dir,fileName))\nfor fileName in os.listdir(Alc_S2Nomatch_Dir):\n  shutil.copy(os.path.join(Alc_S2Nomatch_Dir,fileName), os.path.join(Alc_Dir,fileName))\n\nfor fileName in os.listdir(Con_S1Obj_Dir):\n  shutil.copy(os.path.join(Con_s1Obj_Dir,fileName), os.path.join(Con_Dir,fileName))\nfor fileName in os.listdir(Con_S2Match_Dir):\n  shutil.copy(os.path.join(Con_S2Match_Dir,fileName), os.path.join(Con_Dir,fileName))\nfor fileName in os.listdir(Con_S2Nomatch_Dir):\n  shutil.copy(os.path.join(Con_S2Nomatch_Dir,fileName), os.path.join(Con_Dir,fileName))\n\"\"\"\n\n\"\"\"\nimport os\nimport shutil\n!mkdir '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Alc'\n!mkdir '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Con'\n\nAlc_Dir = '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Alc'\nCon_Dir = '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Con'\n\n\nfor fileName in os.listdir(Alc_S1Obj_Dir):\n  shutil.copy(os.path.join(Alc_s1Obj_Dir,fileName), os.path.join(Alc_Dir,fileName))\nfor fileName in os.listdir(Alc_S2Match_Dir):\n  shutil.copy(os.path.join(Alc_S2Match_Dir,fileName), os.path.join(Alc_Dir,fileName))\n\"\"\"","57ee9083":"\n\n#Alc_Dir = '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Alc'\n#Con_Dir = '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Con'\n\nAlc_Dir = '\/home\/james\/EEG\/Alc'\nCon_Dir = '\/home\/james\/EEG\/Con'\n\n\nEEG_Con_Path = Alc_Dir\nEEG_Alc_Path = Con_Dir\n\nList_EEG_Con = [os.path.join(EEG_Con_Path, f) for f in os.listdir(EEG_Con_Path)]\nList_EEG_Alc = [os.path.join(EEG_Alc_Path, f) for f in os.listdir(EEG_Alc_Path)]\n\n#root_dir = '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/'\nroot_dir = '\/home\/james\/EEG'","785ba226":"NumOfControlImages = len(List_EEG_Con) \nNumOfAlchImages = len(List_EEG_Alc) \n\nprint(f'Control Group size {NumOfControlImages}')\nprint(f'Alcholic Group size: {NumOfAlchImages}')","b449221c":"from PIL import Image\npicked_image = 77\nim = Image.open(List_EEG_Alc[picked_image])\nim.to_thumb(225,225)","e1c43e44":"class DataLoaders(GetAttr):\n  def __init__(self, *loaders): self.loaders = loaders\n  def __getitem__(self, i): return self.loaders[i]\n  train,valid = add_props(lambda i, self: self[i])","70457da2":"EEGs = DataBlock (\n    blocks=(ImageBlock, CategoryBlock),\n    get_items=get_image_files,\n    splitter = RandomSplitter(valid_pct=0.2, seed=99),\n    get_y=parent_label,\n    item_tfms=Resize(225,225)\n    )","fbd42fff":"\ndls = EEGs.dataloaders(root_dir)","a068e1f7":"learn = cnn_learner(dls, resnet18, metrics=error_rate)\nlearn.fine_tune(6)","5b59e271":"del learn","2ada127a":"learn = cnn_learner(dls, resnet34, metrics=error_rate)\nlearn.fine_tune(6)","cca36d9c":"learn = cnn_learner(dls, resnet50, metrics=error_rate)\nlearn.fine_tune(6)","6bbdaf7e":"learn.save('eegResnet34.mdl')","5323ed03":"interp = ClassificationInterpretation.from_learner(learn)","abc8515a":"interp.plot_confusion_matrix()\n","a8996122":"interp.plot_top_losses(15)\n","7d4cd8cb":"import re","db82fafb":"sensor_positions = list(EEG_data['sensor position'].unique())\n","1d1642bc":"#sensors_of_interest = ['Fp1','AF3','F3','F7','Fp2','AF4','F4','F8','T8']\n\nmicroDF = input_data[(input_data['trial number'] == trial_index.loc[row]['trial number']) &\n             (input_data['name'] == trial_index.loc[row]['name'])]\nsnapshot = microDF[microDF['time'] == 0]\nchannels_position_index = snapshot[['channel','sensor position']]\n\n\nchannels_position_index.reset_index(drop=True,inplace=True)\nchannels_of_interest = []\n\nfor position in sensors_of_interest:\n  idx = channels_position_index[channels_position_index['sensor position'] == position]\n\n  channels_of_interest.append(int(idx['channel']))\n \nint(idx['channel'])","e4ec48e2":"channels_of_interest","71074c65":"!mkdir \/home\/james\/EEG_Frontal_Cortex\n\n!mkdir \/home\/james\/EEG_Frontal_Cortex\/Alc\n!mkdir \/home\/james\/EEG_Frontal_Cortex\/Con\n\nFC_Alc_Dir = '\/home\/james\/EEG_Frontal_Cortex\/Alc'\nFC_Con_Dir = '\/home\/james\/EEG_Frontal_Cortex\/Con'","db9ebb48":"# Pulling it together\n\n# Config varialbes\ninput_data = EEG_data\ntrial_index = All_Alcs\n#experCond = 'c_S2Nomatch'\nimg_directory = FC_Alc_Dir\n\n\nnum_of_clusters = 14\ntotalFramesToInclude = 9 \n\n\n\nfor trial in trial_index.index: #runs through trial index\n  #print('new row')\n  EEG_Frame = pull_one_second_frame(trial,trial_index,input_data)\n\n  # Analyse the EEG clusters\n  #luster_labels = cluster_channels(EEG_Frame,num_of_clusters)\n\n  #final_clusters = select_clusters(cluster_labels,totalFramesToInclude)\n\n  ############ Step 2 Selecting the channels for analysis\n\n  final_channels = channels_of_interest\n  \n  #select_channels_to_transform(trial_index,cluster_labels,final_clusters)\n  #print(final_channels)\n\n  ########### Step 3 Processing the arrays\n\n  array_dict = {}\n\n  for key in final_channels.keys():\n    #print(key)\n    signal = EEG_Frame.loc[key]\n\n    # Raw array representation of plots\n    np_array = wavelet_transformation_plot_to_array(signal)\n    plt.close()\n    np_array = rgba2rgb(np_array)\n\n    # Grayscale filter to decrease size of images\n\n    #np_array = np.dot(np_array[...,:3], [0.287,0.299, 0.814])\n\n\n    # Cropping the array\n\n\n\n    array_dict[key] = np_array\n\n\n  ############ Step 4 ### Creating a collage\n\n  ordered_keys = list(array_dict.keys())\n\n  for (k,v) in array_dict.items():\n    array_dict[k] = cv2.resize(v,(200,200))\n\n\n  horizontalRow1 = np.hstack([array_dict[ordered_keys[0]],array_dict[ordered_keys[1]],array_dict[ordered_keys[2]]])\n  horizontalRow2 = np.hstack([array_dict[ordered_keys[3]],array_dict[ordered_keys[4]],array_dict[ordered_keys[5]]])\n  horizontalRow3 = np.hstack([array_dict[ordered_keys[6]],array_dict[ordered_keys[7]],array_dict[ordered_keys[8]]])\n\n\n  collaged_array = np.vstack([horizontalRow1,horizontalRow2,horizontalRow3])\n\n  nameOfCollage = name_image_a_or_c(int(trial),trial_index)\n\n  ######### Step 5 Save image\n\n  filePath = os.path.join(img_directory,nameOfCollage)\n  cv2.imwrite(filePath,collaged_array)\n\n  ","4677d72b":"# Pulling it together\n\n# Config varialbes\ninput_data = EEG_data_control\ntrial_index = All_Cons\n#experCond = 'c_S2Nomatch'\nimg_directory = FC_Con_Dir\n\n\nnum_of_clusters = 14\ntotalFramesToInclude = 9 \n\n\n\nfor trial in trial_index.index: #runs through trial index\n  #print('new row')\n  EEG_Frame = pull_one_second_frame(trial,trial_index,input_data)\n\n  # Analyse the EEG clusters\n  #luster_labels = cluster_channels(EEG_Frame,num_of_clusters)\n\n  #final_clusters = select_clusters(cluster_labels,totalFramesToInclude)\n\n  ############ Step 2 Selecting the channels for analysis\n\n  #final_channels = channels_of_interest\n  \n  #select_channels_to_transform(trial_index,cluster_labels,final_clusters)\n  #print(final_channels)\n\n  ########### Step 3 Processing the arrays\n\n  array_dict = {}\n\n  for key in final_channels.keys():\n    #print(key)\n    signal = EEG_Frame.loc[key]\n\n    # Raw array representation of plots\n    np_array = wavelet_transformation_plot_to_array(signal)\n    plt.close()\n    np_array = rgba2rgb(np_array)\n\n    # Grayscale filter to decrease size of images\n\n    #np_array = np.dot(np_array[...,:3], [0.287,0.299, 0.814])\n\n\n    # Cropping the array\n\n\n\n    array_dict[key] = np_array\n\n\n  ############ Step 4 ### Creating a collage\n\n  ordered_keys = list(array_dict.keys())\n\n  for (k,v) in array_dict.items():\n    array_dict[k] = cv2.resize(v,(200,200))\n\n\n  horizontalRow1 = np.hstack([array_dict[ordered_keys[0]],array_dict[ordered_keys[1]],array_dict[ordered_keys[2]]])\n  horizontalRow2 = np.hstack([array_dict[ordered_keys[3]],array_dict[ordered_keys[4]],array_dict[ordered_keys[5]]])\n  horizontalRow3 = np.hstack([array_dict[ordered_keys[6]],array_dict[ordered_keys[7]],array_dict[ordered_keys[8]]])\n\n\n  collaged_array = np.vstack([horizontalRow1,horizontalRow2,horizontalRow3])\n\n  nameOfCollage = name_image_a_or_c(int(trial),trial_index)\n\n  ######### Step 5 Save image\n\n  filePath = os.path.join(img_directory,nameOfCollage)\n  cv2.imwrite(filePath,collaged_array)","938bc186":"# Move all the alc and control files into \n\n#Alc_Dir = '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Alc'\n#Con_Dir = '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/Con'\n\n\nEEG_Con_Path = FC_Alc_Dir\nEEG_Alc_Path = FC_Con_Dir\n\nList_EEG_Con = [os.path.join(EEG_Con_Path, f) for f in os.listdir(EEG_Con_Path)]\nList_EEG_Alc = [os.path.join(EEG_Alc_Path, f) for f in os.listdir(EEG_Alc_Path)]\n\n#root_dir = '\/content\/drive\/MyDrive\/Colab_Data\/DL201\/EEG\/'\nroot_dir = '\/home\/james\/EEG'","469289cf":"NumOfControlImages = len(List_EEG_Con) \nNumOfAlchImages = len(List_EEG_Alc) \n\nprint(f'Control Group size {NumOfControlImages}')\nprint(f'Alcholic Group size: {NumOfAlchImages}')","7e16d851":"from PIL import Image\npicked_image = 47\nim = Image.open(List_EEG_Alc[picked_image])\nim.to_thumb(225,225)","d41aeeda":"interp.plot_confusion_matrix()\n\n\ninterp.plot_top_losses(50)\n\n\n   # Have a nice structure\n","15003404":"class DataLoaders(GetAttr):\n  def __init__(self, *loaders): self.loaders = loaders\n  def __getitem__(self, i): return self.loaders[i]\n  train,valid = add_props(lambda i, self: self[i])","1f43873b":"EEGs = DataBlock (\n    blocks=(ImageBlock, CategoryBlock),\n    get_items=get_image_files,\n    splitter = RandomSplitter(valid_pct=0.2, seed=99),\n    get_y=parent_label,\n    item_tfms=Resize(225,225)\n    )","e9a74be5":"# a way to modify the datablock\n\ndls = EEGs.dataloaders(root_dir)","c33ce573":"learn = cnn_learner(dls, resnet18, metrics=error_rate)\nlearn.fine_tune(6)","5f9ed20a":"learn = cnn_learner(dls, resnet34, metrics=error_rate)\nlearn.fine_tune(6)","e4accae4":"interp = ClassificationInterpretation.from_learner(learn)","1ea8cda0":"interp.plot_confusion_matrix()\n","e6637317":"interp.plot_top_losses(6)\n","c26baa16":"# Average Power of Alpha waves in Alcoholic and Control Groups\n","6e9b8080":"# Feature Extraction (success and failures\n\n### Problems\n\nRaw time series data has excellent temporal (time axis) accuracy,\nbut has no information on frequency because it is raw data\n\n\nRather, what we need is to fit this into a model for an electromatic wave, so that \nwe can get frequency information.\n\n\n\n### Solutions\n\nFourier Transform\n\nWavlet Transform","d27dde95":"![image.png](https:\/\/i.imgur.com\/lcJh2JJ.png)","a5f55689":"![image.png](https:\/\/i.imgur.com\/iKtYhyf.png)","54a3d675":"# Exploration","01dc8eaf":"# Beta 2 Waves\n\n### Hypothesis, Beta two waves should be more prevalent in Control Group\n\n","87b1db7a":"# Conclusion\n\nConclusion: Although the two groups do exhibit statistically significant differences, it doesn\u2019t translate to perfect accuracy\nLeonidas (NIIT University, Mumbai, India) achieved a p value below 0.001\nKaggle\n\n# Thank you for making it this far\n\n### To any engineers out there, this was my first attempt at signal processing, and any feedback or criticism would be very much appreciated, especially when it had to do with the wavelet transforms\n","7ae2b753":"epoch\ttrain_loss\tvalid_loss\terror_rate\ttime\n\n0\t0.875190\t1.549510\t0.548387\t03:08\n\n1\t0.683642\t1.584309\t0.526882\t03:08\n\n2\t0.490144\t1.312087\t0.430108\t03:16\n\n3\t0.380837\t0.864145\t0.311828\t03:12\n\n4\t0.299431\t0.740602\t0.258065\t03:08\n\n5\t0.249155\t0.724146\t**0.247312**\t03:12\n\nFinal error rate: **0.25 percent**","cac3ddcc":"\n### Part 2: Preparing the data\/ Feature Extraction \n\nFeature extraction:\n\nTime\nSensor placement\nAmplitude\nFrequency\nPower\n\nFrequency changes\n(at what time is a frequency present or not present in a signal)\n\n\n\n\n### Part 3: Training the model attempt 1 & 2:\n\n### Attempt one:\n\nFeatures: \n\nSensor placement\nFrequency (Beta, Alpha, Theta) \nPower\n(Time information  not included in the model)  \n\n\nAttempt 1: Failure and re evaluation\n\nAttempt 2: (looking at beta frequency bands)\nslight improvment and encouragement\n\n### Part 4: A new model: feature extraction part 2\n\nFeatures:\n\nTime \nPower\nFrequency\nChanges in frequency\nSensor placement\n\nAttempt 1 and Attempt 2\n\n### Part 5: final analysis\n\nSuccess and failures\n\ncorrelation != high accuracy\n\nFood for thought\n","722a6885":"![image.png](https:\/\/i.imgur.com\/QxbjXDM.png)","3b3dc34a":"#Saving the images","240a9e98":"epoch\ttrain_loss\tvalid_loss\terror_rate\ttime\n\n0\t0.875190\t1.549510\t0.548387\t03:08\n\n1\t0.683642\t1.584309\t0.526882\t03:08\n\n2\t0.490144\t1.312087\t0.430108\t03:16\n\n3\t0.380837\t0.864145\t0.311828\t03:12\n\n4\t0.299431\t0.740602\t0.258065\t03:08\n\n5\t0.249155\t0.724146\t**0.247312**\t03:12\n\nFinal error rate: **0.25**","17671949":"# Code Execution","0b9feb07":"#### mapping the channels onto a grid","90e836a9":"![image.png](https:\/\/i.imgur.com\/cZmdOcK.png)","838fe32e":"### Peeking at the data: Looking at each cluster in a print test\n\nThese graphs show time, and frequency data visualized in two dimensions\n\nThe bottom area of the chart has low resolution information the low frequencies that don't change often.\n\nThe top areas of the chart have higher resolution information on the high frequencies that do change more often. ","29379b4a":"# Part Two Feature Extraction of Wavelets","654568b4":"![image.png](data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcIAAADzCAIAAACaK4GuAAAgAElEQVR4AexdB1gVRxfdB8QYjcaKilIUu6IUW+w9dmNBxCgWbLH9dmPvIgpiwRoFFQtGE3vvXaxEsWA09kJUxEJ9uzP\/B0dvJvsAASkPfHx+z9mZO3fuPTNzpuzsruQ94ZfvyxZvUMPByty0eLEidhXL2ZYvX8W2sp1NxcqVKtpXjP1nZxP7z75iJTub2H+VDf+Sj4BtpcqEm22lyva2dg529lUdqlSzt6tqZ4vfKraVa1arWt3BvrqD\/fdVq+BfjSoO1ezt4mqkkm1FG1JiCMSLgJ1NJYfKtpXKV7CtaGNfyaZW9Wo25cqWtLJs1rhRzq+zlbEu0fHHtvm\/y1PGuqRNufLlS5epUK58hXLlK5avULF8BZsKFSsZEE5+2463IpIYaVupcoVy5e0q29rb2tlUqGhbqXJCVZBQfBILSkTMtlJl+mdfKbbZ4J9D5UoOlStVsa2Mfw6VK1V3sLezqVjVzraKbeVSxa1sy5cvW6yY5+TJkv98j7XzPTiL4jyGy9GcablWyxWZcyX2HxP\/cc4M\/1KKgMK4+I+QVORYkOkXAcRQ+EMt8FgNlNEQ+CQCsvZDA45D0trSok\/PHrExWvlfGA2QfhLGdBBQmBJXKXKM9t+qSYdydYtQ5NjOSP9EAkR\/\/NiolOgorijrli1bs2iR5DvHbdVcN65ExtKoEvMvb4o0+iGcUgbRtdUQQwjw2BZ06eL5HN98jaFLkWM4o2HMgHmyEUCH5IwzRfsvklzRSFKTxg3jJgcfdDJZyeBOS83giw0ojKiTAvHUS7qNduC6eH+ZzJkc26jiUmMDiuI9a9bCadMk3znuy+e4cRbDeWyyrI3m8gc5SP\/7+8XWdKo4rtsOMDmNnfLLS5d4ayRJkWNiOVSsQipaNzslGQL\/RQA0GtsVgWRc61+0cL6xkfRTl86xkQqLTTVA+l\/cMnBEAW\/+hz3F2kFPSR9rxd4X1zdjR2Ka1lAqYmR5yWy3X93dpRWz3Ja6z+Y8hnF04NiBWlE+rD8\/dulYhA1\/aYOAEhMT9dNPzpIkPX36lPNY8NOmoC9DK3U2hf1Lo3FT0WxfGU8YPzY2kmQMzVoPGoUsy6IVjGWeWlHkZZ5zF82YKvnO9Vg5z5Mzrcy0LO6Px614lNhdUpmx2H\/YH6VU0WdD+LMRiJ001atXR5KkHTt2GGj0c\/H8OIuJa7YflmB379w2NpIaNqj3gUYhg9\/PLc+Q\/7MQINIkelHi\/nTjY3kpbRgWRZMBCflDAhTgirzUY87yubOltV4Llnl4MEWr8H\/HBIXH2ht3HdvJMXgnpN0Q\/\/kIWFtbGxsb\/\/LLL6qR+fM1f4EaqFd89F1xd3ezt7cdOPDnPn36cM61Wi2SKPBR0vB\/eiOgKMqrV69kWcYiTJcoY1fGacOeKXb1X3uYsmL+PG\/3mdKvs+cs8\/D4wJXCbPojdRpoNMVo\/yfjv9D\/J\/rDEt7U1LR169bNmzdPSOy\/mQxXiSGg2hWR5ZiaNWusW7d23LhfWrVqhZyY8iSmxZCWLgiEhoZOnDiRKgUB6gWKomi1WppbUHy6mPafQqjo\/wSYstzLM3Y2usp97vK5c7kif6DQj\/T58f9YXWJYXHUyxsQx5D8F\/McGw0WCCCicvY8Iz\/Ftzl17dhezMI\/bz4sdfBP6l6AiQ0IcAmiEaJYfu59iZlZYUbRjx47p2LGjoZXqVUs5e\/ZssWLFRBoRF+937tzx9\/enKtMry2ONYcoyD49ls2dLqz3m\/erpGXvOKZYgP3bfOHtjifUjgwrz1Ng0WZZfvnw5c+bM2rVr29vb29raWlhYlCpVqn379i9evNBft+P80qsfmSm37\/xVsJCpwtlXX2f7sA39EXhdMtUr4\/XTmI\/s+cE6xuRixcw4V8aMGdWvXz9qnHq4WtRPPFPFKoJdpe3IkSMmJiZipEipGzdu7Ny5M1JV1SpmybCwovjM8\/rVbba0dt78VV5en6TRWEPj+jTBIcvyunXrrl27FhYWptVqQ0NDX79+bWFhIfoMRDLMyUxS8LZt23766SfOeY4cOQyIpValYd9TUZTAwMAOHTpwzocNGzZ06FBMdqgZp1ZxBj2JI5AQ4O7u7kZGRtjORuOnLiDL8sCBA6tXry6ugBMvJRVSdWcuicTIytp5831nxtHoynnz4mhUOEkXZ444G42NgLqP98sYY8uWLYPdtNNkbW0dFRWFcSMh4FLB1SykgjG2ffv2gQMHcs4LFCjw8uVL9PMs5GK6uiLLMjU8BJYuXYq1fP\/+\/V1dXQ00mq71kUBhVEcdO3YsV66cSop2C1u3bl21alWiUWJYlXxqXiZCmrpJsrJx3sK109ykNZ7zEqPRD8dNYykUfxg3QJQLFizQamOPSX1M5KampiEhIbjUarXp4TaVnWkDa9asmTFjBufc3Nz8zz\/\/zLR+6JHh1PAURXF0dBw0aBDnvFevXl26dKEk6px6ZPeXZ0r16tUbNGhAfqtqx9bWFjQKAZFqKEtGBmRl87xF66d8oNHYc6Oxj3yzD49sf\/wf26UJHnj69ddf4TadVzAzM3v79i1jzHCUJOm16+Xl5evrqyiKlZXVgQMHDLPRpEMXryTaJB3uK1KkiI+PD+e8T58+rq6u6IqUGq8GQ2S6IWBtbd28efN3796JoxrVUb58+erXr59uxiS7oDga3TjZTVo9bx6O33+g0ThNsY0sbhGP50A+hpHGYw82xz1O57Ny1YeV\/sfpbinrktroGDxmF\/tMXiwDG\/4+gcCUKVPAnlWqVPH19Y2OjtbJEHvs7OM\/nURDhIAA3YhAV\/T09DQxMQkJCWGMDRo0qEePHpA13F8SMEu\/ICqFymOMmRYoOHTI\/06fPBXLJOKjE3HPUebLk7dl8xYgGSYrscyTxn8fmUxFbPFfcln5zXNhLI3GLeqF2ehHKz9SJ3pvrJYPfx9d5Yyv+nWlSr2VheX7t+\/iHiD5dy\/1Y07D\/\/EgwBgbO3bs7du3GWM\/\/vjjtGnT4puNEoemeTOKx8TMHCVJUrNmzeDB0KFDW7ZsKfZkMZyZvcyUtuNM6DdfZ1+6eMnUyVM+kMbHVz1xxv+8EmhWuEjnTk6xJEO0k8a+poBG\/afMltZ6zFsVe+Dp46I+thOLln6gUTGKwitXrlT1+TJlykRGRlKkoZkSVokERowY8eTJE8553759+\/Xrl4ikIemTCNCKXlGUtWvXSpJ08uRJNEhfX99ixYqJGgztU0QjHcJ08xnVdObMmbx5827dutXJyUl8ugz14uPjY2tr6+LiAsOQJR2MTEYRcYt6kUbj5tC4WaRLo\/+J+bcUkUax2VSiRAlscwAIQzP9F6wEQoqiDBo06MWLF5zzgQMHdurUKSYmJgFZQ3TyEKhVqxYO0yDb1atXv\/76a5x6ppE+eRoN0ilFgAiBdqUVRVm+fLm1tfW+fft++OEH4goaCKdOndqkSZP+\/fszxsC\/esekcYv6BGj0P0jFzUYTpVESVxTF0tIyLCyMYggaijEEVAgwxrp3746+vWjRotq1axt6uAqi5F7S6RFJklavXi3eu5AkKbnaDPKpggAxIHGCLMuDBg2yt7e\/cuWKnZ0dSqFUzCr69OkzfPhw6hFiaqpY9blKZGWzx8JNwqJemI3G6f7InIkt6n\/99VeVHRYWFq9fv1ZFGi4TRwA0yjnfsGGDjY0NNbjEcxlS40UA05a\/\/\/67Zs2a+fPnf\/78OcSAqkajefXqFfVGuh8VrypDZOoiQLCT2rZxf8+ePStRogRxJVWKq6vr2LFjhw0bBnl97BfJpdGPrEoIxAZ0adTS0jI0NJQQ+Y+04SIBBLp164bZ6MmTJ4sUKWJALwGckhqtKIqTk5MkSYGBgWIeWZbz5MkTHBysjx1SNDSLhkUaRRU4ODhMmDCBc47NFlrvI9CzZ88ZM2YMGTIEeBC96hE8srJl7sLfJv97iyme2WgcdX6YjX6SRoGRSKMianrkuZ6ZoigKzUbv3LmTJ08ecRGqZ8ZmAnPQPxs3biwe26YeWKRIkZs3b8INA5lmeHUWLVp0\/fr1nHNstoAxqF6cnJzmz58\/bNgwYhIKZLjlHwyQlT\/mLtwyaba0bu4837hXk4jnRmMnRMK5UboUyZQxJs5G4SHRqGFKlfSadnFxQT9\/+fJlzpw5k57RIBkvAowxW1tb3KCn86Fon6ampg8ePEAu4tZ4lRgiUxeBeBkwb968x44dY4wZGxujOHFC2rRp05UrVw4dOpSIVe+qLI5GN090S2UatbCwePXqFRAh51O3PrKeNmdnZ3Iqd+7chhGI0EhBgOgSedEI0f0URcmfP\/8\/\/\/xjaJkpADYVs4ArGWP58uXDiem8efPSezmIcOvUqePv749FPUWmohmpoCpuUb9pkpvkN8czdjYa+\/2fD0e76dSTalH\/cX76oXTVbBSx4mw0Faz8AlQwxjp16kQL+e++++4LcDoNXQRF1qxZkyAVe2DhwoWDgoIQI8anoUEG1XEIiGgT\/gUKFHjz5g3nvGjRovfv3xdlOOfVqlXbs2fP\/\/73P\/2dWMjKb3MX+E9OgEbpKD89gCjEfGgX8dKohYUFbjEZGk8SEWCMtWvXjhqWqakpHWxMogaDmAqBhw8fVqhQAZHiMlCWZXNz8127dlG3NExLVdCl9aW4Zg8JCSlYsCBKtLS0vHDhAr3YCfXi4OBw5swZvNsQYnpXX3Snft0cz9Uenhxfo40jS3oviWo2qoI4IRqlRb1K3nCZEAK4xYRFjZ2dXXBwcEKShvhPIqAoysyZM9u1a0dPxaDv4bdkyZK\/\/PILvYr0k9oMAqmFgDjTRPjOnTsFChTAkFa8ePEjR44QS4JtraysAgMD6cBTalmSmnro+H28NBrrm84tJlXxBhpVAZLiy549e9I4XKdOnaCgoBSrMmTknPfv39\/Dw4PeMSZ24I4dO9aqVQsoifEG3NIaARFt0OX58+eLFi2KcJkyZXbv3g0ZItPChQs\/evRoxIgRsE1cWKS1tUnVTzS6wd1zzVz1bNRAo0nFMTXk6KlhznmrVq0uX76cGlq\/XB25c+f+448\/4D+NT9gqGTVqFK33afP0y0Uq3T0nilQUxd\/fnx5esrOz8\/PzQ42ATGNf\/mRqGh0dPXDgwPjeeZbupsdboIFG44UlQyLxOhIczenZs+e2bdsyxIysUWhMTIwkSXh4id6ET3fqXV1d6TkxcX6UNXzXfy8Ic8aYm5tbmzZtEFO7du2FCxfCfqLRPHnyKIrSu3fvkJAQ4l\/98pFodOPsj7NRpmAln9CdepUDhkW9CpCUXSqKMmDAAJoZDRgwwN\/fX08bTco8TN9c3t7exsbGdCtDPDfKGFuwYEH+\/PnFKWr6WvdFl0atGqNanz59Bg0ahMjWrVtPmTIF6NBxKNTU0KFDAwMDEUka9AVHolH\/2Z5+c4RFfeynlkQjE3yKyUCjIkwpDuMNT8iuKMqkSZO8vb1TrM2Q0d7enr7tg3mNuKcWHR0tSRI+0ED36w2gpRsCNBvlnDdo0ADfzuGc9+zZE+dDaUf75cuXOLUyadIkHK7QOw6N3SeKfW1z7BuefnPzXEc0GgdnYjQqMGy8NGplZYV3vhnaaBKb5rt374YOHYquzhhbtGiRl5eX2NqSqOdLEwNE1Ouoj0mStHTpUszuEUlJgOjbb7999+6dAeE0ajAAVlEU3DISwUcSCZQpU8bb2xuXI0eOxNcG6bTfrVu3rK2tOefz5s1bu3YtxYtmiwOkGJ9+4YRoNJYn8bX6D7YIs9GPN++REi+NWlpaGmg0WbX46tWrkSNH0qizdu3auXPnJkvDFy5Mr2fVarVHjhzRaDR\/\/fWXbu+lGFtb27CwMLFLf+EAprr7MTEx586d02g0pBngi7+c81y5coEfGWOTJk3q2LEjyXPOr1y5Urp0abz\/aPHixUiiJ51or4Y6jpg3\/cJpR6P\/\/PMP3EBLTT+XMmdJgYGBeMkNzjmeOnXKzc3NAF1SKpOYkQKSJDk6Oop5VUgqimJqanrnzh3KIgobwqmCgFarLViwYLly5VasWKEoCq20qC4Q0Gg0V65cwbph\/vz5TZo0EQX2799fqVIlxtju3btHjRqlMkysPjGsEkvzy7SjUXw+jPb409yTTF5AQEDA5MmT4YSiKBcuXJg6dWom9ymdzEf\/Qd\/DPEWSpIsXL1Lx1C0Rg8tcuXLhOze0IUDyhsDnI6AoSv\/+\/QsXLnzz5s2vvvoKCqmmiFI55zly5Hj79i2mk35+fnXq1BFL37Jli52dHWNs\/\/79ffv2FWsZYrhPSPFi3vQLpzWNpp8nmbykY8eOzZw5k5wIDAycNGkSXRoCiSCALkS\/Bw8eNDIygjz6re48RVGU7777Ljw8POO31RJxLJMnSZK0cuVKRVE0Gs25c+dQQWK9cM6jo6Nz5cpFjm7btq1atWp0yTn38fH5\/vvvOeeHDh3q0qWLqITOsWXwij6RW0yfvzf6\/Plz0WcRGkNYF4Hff\/993rx5iGeM\/f333+PHj9cVM8ToIqBiSWdnZ3Nzc3QtVQukE06MMXNz85MnT0JApUG3CENMchG4dOkSfanF1tYWzyAxxmjujwHs0aNH3377LSk\/cuSI6nyFu7t78+bNOednzpxp3rw51SDnPDQ01MbGZs2aNRl\/CiqNZqNWVlZY1BNAhkDiCGzcuBEnnKh54Y5T4rkMqWBAsCF+GzZs+NNPP6kepRf5FPt0Xbt2HTdunBz3Z4Ax1REYOHBgyZIlAfuQIUNwm4hKIT69ePGimZkZ1c61a9doCMRAOHbsWEdHR8bYxYsXGzRoAEn0kV69ekmSVLx4cVKbYcNhqtMo\/DTQKFVtEgOLFi2it18rihIVFTVs2LAMaxZJNFo\/xNCpCKtq1aqNGTOGeqYqQGL79u1r0aIFPCAZ\/XAoK1ghSdLWrVuBdmBg4DfffENLb7pfoijKjh07KlSoQHPM58+fFy5cWJTs37+\/q6srY+zu3bv29vYiNObm5pMnTy5btuzdu3fF+AwIpzqNwgcrKyv6iFgGeJUJi5w7dy6+XkmrnoEDB2ZCPzLAZGJGBHLnzo1z2omYAsmOHTuqKDiRLPEmifxLZsQrmYqRVCiVSDHxbmXEWzRlSejMEASoCHq+DtooOwXEoq9evSpJkpi3WLFi69atQ14xfs6cOTTHZIzFxMSYmZmJRXTt2hXfBH348CFu2cOSe\/fuWVlZcc5r1Kjx448\/ko+iPWSzKpKEUxbAMECDQawSWdnksWDTVHf18fvP3Bs10Ghya2jy5MkbNmxALtT6wIEDU7f6k2tSppAHRNSmtVqtqgPH6wVy4RuC8QokJZJqh5hIJIikaEiZDDkrZidjxEiiNrHn62YX82JcQUYcxYVTFI+A7ifjoQTxP\/zwQ4MGDcTSa9So0b59e9hGQ5csy4MHD6YH6lGQmZkZ4ckY69Chw9SpUxVFCQ0NLV26NJlx6tQpe3t7xtjgwYNLlSql6wK5mVCl0C1+XXBIm5gE41XaPpgaHbN53iIDjaraXgZc9u\/ff8+ePeLNxx49emSAHZmtSOq9MPzkyZN0Z+OTrjg5OaGrf1JSV4AoBgbQgXBdyVSPQU9GDydaSVkpKlKAElEnlYUksAYiieww6SPqwZfpZs2aRTGMsTlz5hQsWFCljXPu6OiIV0mQcMmSJcPCwqhe6tSps2rVKhSBnQEoOXfuXNu2bRVFOXz4MN2kErsPvKCHMogQUwaUKhftQsAYLivrZ3saaFSFUgZcdu3a9cCBA9TOGGN4\/WgGmJKpiqQ5Bax2c3Pr3bt3Ej1o0qRJEiU\/KUb96pOSnylAdEN6aGIIpkA8hYk+VAFqaaQHgQ+8EHdBL6bTFQZJwRjynS6NjIwuXLiAXPg9cOAAPnZL\/IjiGjZsOG3aNGSEJN1WQaStrS3tBmg0GiLKTZs2de\/eXZblGzduYAIr2o+8iKGlvTg7JgEVLJ+8JJ0UiFUlK1u8vHfMWWhY1BMsGRPo2LHj0aNHUTbqmB4uzhiDMk+p1CWio6M7dux49erVJNretGnTJErqitFjOSAUcQKlK5yKMeAaWZZpnoWYFBcB4hBnoKSKgFUU5dmzZwcPHvTw8Fi5ciUeW9AVA09duHABd9vx\/Dv0R0ZG4iuNorWKojg4OPz6669iZJEiRa5fv45cnPOyZctu3rwZTE3rDLyjC\/QaHh6O4\/2kRDQbkRQDm0k5uZD0AOWlwSO2CFlZNWXm6l+mGGg06UimiWSzZs0CAgLENy\/07NkzTUrKWkrFHqIoSuPGjZPon6IoOBdF3S+JGUkMRTPGhg0b9ssvv4izHpJJ0wDmoSICYnHUz8VICiuKQjczEUnugA2RCtZYu3Ztrly5rKysFi9ePGjQoHz58t2\/f1+WZRV0uBw3btysWbPEJFhC360jG8CSmD2gdFmWCxcuvGfPHpq0Fi9e\/Pjx40iVJAkBRVHGjh1LX9nJkycPmB37DL\/88sulS5domCG\/EBBLT7VwjHbtzDkbJs0y0GiqQZoyRXXr1r106RLyYuXSr1+\/NKz4lFmpr7nQaRljDRs2pB6YuLGMsT59+iRROCFViqJs2bLFyMhIvFmckHCqxKtmweQ4KRe3LJPYfsCYtF4WZ6ZarfbGjRs5cuTAabw7d+5ER0c7Ozur7s6hIOhp1qwZHu4khUitVKkSPugAVoXlpqamDx8+hPEQwz192KAoipWVFS0vChQo8PDhQ2R0cXGJiIhARltb25cvXyLLX3\/9lT9\/fhMTE2hDJMKoawqnuOphAIr+sO+hlde5ecTzojzDnXpql+kTcHBwuH37tli1Sd\/jSx8L9bMUsU3j5ZUihonb3KNHD2QXu1biWSiVskiSlDt37jFjxqgsIcm0CDx48ODAgQNBQUFXrlw5f\/785cuXL126dPny5YsXL+Ly+vXrt27dupnw3\/Xr14ODg2\/E\/d26dYuWQeQX5qG1atUqVqzY6NGjY2JiKOnu3btYX+uiJ8syDjARGuBWRVH69Onj6+urQsPIyIi2CJClcuXKy5cvJ7EiRYo8fvwYzGtubn7z5k2Y0blzZ8goipI\/f\/67d+8ivl+\/fvnz5+\/Zs2eJEiX8\/f0551FRUY8ePbpw4UJAQMC5c+fOnz9\/5cqV69ev37x5M3GIEgLv1q1bwcHB165dA\/6xTC0r\/nPnr584M9mzUdoj4JyvXLlS1XYtLCxCQkIIC3hIWRCgWiGxLzlQrlw5DMuEVf\/+\/bM2RPAO84XPqXpxxoEnspOIW4cOHVTtNiEzxBvxpFxRlJIlS2o0mu3bt\/fq1YtU0XxQlBQ1E8WIkckKL1iwoFbcX7NmzZo3b\/5D3F\/Tpk2bNGnSuHHjhg0b1qtXr06dOrVr164j\/NWO+6tVq1bNmjW\/\/\/772rVr16xZs1atWrVr17axsUFko0aN5s2bN2nSJAcHh6+++qpq1ap9+\/aNjIwEyGS5JEnu7u66Nsuy3LJlS7GnEywbNmwYO3YssgAZxhjoWJSvU6cOviMCmXz58oFnGWPW1tanT5+GBkyHYY+5ufmWLVtQUI4cOcaNGxceHt6zZ09JkgoUKGBtbV2lSpUGDRo0atSocePGjRo1ql+\/PsBR4SNApQ4SdLVr1wa2NeL+evTosW\/fPi4r272XbZ3tmWwaFRGkx28oUkWjFG8IJIRAmTJl8MAC9b2ff\/45IeGsEU99Ei6njE+RF6oYYzVr1vwkOFRuq1atHjx4QBOxhDLSfEqWZUxtUGj79u1z5Mjx9OlTRVHy5csXFRVFN1Von5Ruo4tJlEqWJFS0bjxQio6OfvToEZ4rj4yMfPPmzbt3796\/fx8eHh4R9xeZwB9Sw+P+IiIi3r9\/j9979+7duHHj7Nmzy5cvnzRpkru7+549e44ePfr+\/XuyATjAkRs3bmg0mu7du1Nzper74YcfKAulcs6vX7+u2kUhGhVxaN68Od7Rg7z58+cnIrazs1u3bh04t0uXLlTKxIkTBw0axDlv2rRpiRIlKP7ixYunTp26fv3669evY2JiIiMj379\/\/+7du\/Dw8ATgiSc6KiqKYiMiIqLj\/gDamzdv3r59G+u4rGxw91w\/afpn0Shmo2Q951yXRjt27Hjq1CmxMRHuYsYvNmxtbY0dJUKgf\/\/+FM56AbGDkXfxRlJqvAFkQT+MjIysX79+vGIUiVaHReLYsWP3799PSYkEiEFGjx5dqFAhFKfRaJ48eYJc\/fr1K1u2rGg\/FQQBYgpVfCKFJpQkdhxxmpyQvBivWgjSxBkydAlr4Y5osFh0WFiYJEndunUjr5Fd\/OQqDRgAnF4CCz3Pnj3Lly8fZYcNzs7O9P5yWZbFh5qaNm3q7u6OvF27dgWZwFQnJ6elS5dKkhQaGkp7ssS\/hADMUJVIqYkHVND9R4lWXj\/bIyU0KmrB+VgxxsLCAq9tpsg6deqoPnVJDStx67+QVHNzc+qrqH58KDSruk\/rODj4OY2BVD148KB169afRIy4wMXFxc\/PT4RdNy81YFhYtmxZY2NjznmfPn3wLiIIhISESJJUq1YtiNFtYlzilwpCFjJDt9CkxNC9JpUw9XaCRSWAS7F0mEdiKjsRTziAGZFl27ZtxsbGr169orze3t5YuZM8BTjn2EUhAwIDAytUqEClQ7J3796YtHLOIyMjLSwsyIDOnTsPHz4cYs7OzlSoLMvVq1e3tLT08PBAJAEOYRoeKAu6mGibmJT08AfNMVr\/uV4bJs\/4rNkoaFQsW5dGq1evvnnzZgyeYhWKub7kcMGCBVXuZ20aRW+MiYlBixd\/VTgkfkn9RFGUK1euiL0roYzUb\/v161e1atWExCgeUxjkkuL+evXqZWFhcfr0aeIyRVHWrVtnZGRkbm6O9aaiKEuXLi1RokTr1q1LlSplZWVVsWLF7t270\/3lz+zD6ETkC1mrCoisqkqiS6gie4hGIYAikEoyFLC3tx81ahRkFEWRJOnEiRMqBoewLMs0GwWLHTlypFmzZmQGxAYPHkzvFWBmts8AACAASURBVA0NDS1atChNafv164c7S4yxvn37EjkqilK2bFkjI6PHjx+TzYQMBageyXgKkA1JCeCtYP\/JG\/dM\/cbJbimn0Xi\/xaRLo\/Xq1RNno+KeUVJMz\/IyOJws1k3WplHcn7lz5w7VLM3gKCYpAUKMMXblyhUXFxeKiTc7OhXWfevXrzc2NsYpxXiFsWykpKVLlxoZGeXNm9fExASPMIKAyPL169fnyJFDkiR7e\/tGjRpJkvT999\/Pnz9\/zZo1q1atWrhw4e7du2EAjEzcVCpXDGAiQtQgaiOxpFAnOEg0QzXFEec6ImUT50JDaGgo1t2Kohw4cADfWxUtoTAe\/cQllPzxxx\/YuRLNGD9+fNu2bRHz8OFD8b15EyZMaNOmDVgVD6cQX798+fLJkycgSrFE4KMaGESBFISp1iiAV5Ok8MAT1RZuMf2rlHNzc3PVor5x48a\/\/\/67CCINMinwJOtlyZkzJ5wiGLM2jXLOhwwZUjPujw4GpqxaCbEdO3YMHTqULuPVJqZid69v377xSqoitVptuXLl2rRpExoa6ufnFxERIaqCMGMsMDCQc+7m5tasWbN79+7Ra09FRtbNqCorKZcigYqcmJS8KhldeyiG+JoIC3lJgDHWtGnT1q1b9+3bt2TJkuLdIVEGuWiejr7v6+uL7zaKpXh5eTVq1Ah5b9y4YWlpSYS+dOlSun8l3oAlAZQiEj1tj1IRiMGYQRaqAEn8Ern+A0iMdpPHgpTQqGiBj4+PqmBzc3N8GZTEqlWrtmXLFiobbqhyfcmXujSaxO6dSUFDw7h7966rq2uOHDkaNWpELT4FHqE5TZgwAd2SWl28qtDN0K\/69+9frVo1sY\/FmwUCGo3m8OHDKgFVH4YkrTchLNpDSWKkSmcil8QRlD2hqRb1tXi1ITs5TtooRjdAMgjQb3R0dOfOnX\/++eeLFy+SjFgoYSI+mKcoypw5c2iFStp8fHxq1aqFxnD58mUs6qHN39+fPjECGoVm5FVVhGgJiRH4onnJDVNBZHOC36n\/5PF7spIxdv78edXUUrxTD8nq1av7+\/uLuZJrfZaRJxDoluKbN2\/oxQ1U5Vl7NkogaLXagICAPHnylCtXbv369VTLJKCKoXgAJZJvkyZN8FV0yqIbQHbkVRRl37592bNnJ5268ohRFOXSpUv4xNMnhRNSklXjFUV5E\/dHWBGDAytaa9PONQSGDx8u7uqgUnbs2FG5cmWoOnnypKWlJU3kDx8+XLp0aegUZ6NiG8gYkD\/ntc3UnnTf0GxhYUGREKtRo8bmzZszxkk9K5VwI7uePHlSsGBBanyIz\/LH7\/EgHbw+f\/68nZ1d9uzZ8+XLR3djRaAwBaBdSOJQ6mOKolSuXPn69euEauIBKH\/w4AF9\/y5eeZrrLV68OG\/evKrpQrxZvqhIVIR4q0OsGrEGOefOzs54KgeV7urqCmExy4EDBypUqIDqPnz4sKWlJaVevHixSJEiqPGBAwfSLCTT0yjBhABdWlhYPHv2DO0JkdWrV9+6davoMAl\/Uc1OdBbtQ6vV4qU4RKOIz9o0Sn2DAImKijp06FDnzp3z589vbW2NbwHE22BoVUUBKDEzM3v27JmuZioCARUXS5K0ZMkSFBRvm0RkjRo1cCJFVahK+Zd2qYs2YUjtGZgwxlxdXY8dO4aRiTGGrVKSxxD1+PFj+o7I6tWr7ezsKHt4eDj2voKCgqZPnw55sTpEVelaESmejcJ6shsBurSwsHj69KnoSbVq1Xbu3CkO5iQsimX5sK7XjLHDhw9bW1sTZUCGTs9lYUy0cX+qtnT\/\/v2FCxc6OzvXrVu3d+\/eXbt27dat28SJE7dv3\/7XX38BDfRemgThDEqnTp3+\/vtvmp\/Gi5vY66DE3t5eXGzGm2v27NkVKlSIiYkRs8cr+QVGgi7Fhk21AzSIasePH79x40a67NmzJ0lS4MWLF6ampugL3t7e+Loy1Wn27NkVRTl69OiUKVN0S8ww8FNMo6IPqm7AObe0tMQDHiRWpUqV3bt3G2g03preunVr+fLliUYhg8e045XPApHEgPCF2gndBIiIiHjw4EFYWNiZM2fmzp3bqVMnGxubXLlyVa5cuW\/fvocOHaLeSHnr1auHdwglgg+EaanOOR82bFixYsUSyaIoip2dnZOTk247TyTXl5NE+FPdqXynmvL29saT+IihO07QgMjQ0FB6Tszd3b1hw4Y0dMmynD9\/flmW\/f39Z82aRfGqaa+q9PS4TDGN0vig6vww2srKSkWjDg4OoFECnQLp4aeelUHtBk1hxYoV1atXF5FkjGVtGkWFqNbX6Ej4BURg26ioqNDQ0EePHvn4+HTo0MHGxsba2rpOnTozZsy4f\/8+jc3t27c\/e\/asCGPi1Q4yXbduHX2FQlcexuTPn3\/v3r1k2JfcdHUhohhdOlMBtWnTJjz8jizdu3cXK4uE8Ry9oiijRo3C15UhzxjDet\/NzQ17PqrBGBVE9qRf4PNplJq7iIiVlRWeKCBoHBwc6HuNFJl+fupZSSoE3N3dmzdvDhspKWvvjepWCDoh9QRxakOYIPLu3burV68eMGBAgwYNChUqVKVKle3bt3POXVxc8AYgUqJbCsVAJ2Ns3759+fLlE4sjGQQuX75M712nGZBKxnApIkD1RQGQw5EjR+hFpYqi4FWQeBIMwOKefpEiRRA5ZMgQfJGMzkfmzZv33bt3EyZMEA91YBwVyxKNSY9wimmUjBZ3Rqj5Fi9eXKRRxpiBRsXqJPTQAsaMGYPPq4kyQ4YMITzF+KwUBg7oQsRQ4h1YcWwWhRljERERMTEx\/v7+hQoVkiSpUqVKkiT9+eefIrbxYkWooukGBQXlzp1bq9VSvCrXmjVr8Bw9xSckSQJfToDQpgB8V0GE1CtXrojvjiFKRRbSULBgQbymp3v37pi9Iokxli9fvmPHjvXv3x8DJ5VCgYxBPsU0mri5unujDg4O+\/btI6QSz54FUqniyZeEalpRlP\/9739YwpOMoijjx4\/HaQcCTdzRI9JBKmWk4r6cwPXr1589e7Znzx4XFxfAkjga4toT6EmSRJ+y0K24GTNmlC5dmvAUa4EiDQEVAtRoaSCUZfnRo0c4Bwph1d4oSZqamj5+\/FhRlC5duuAj9aS8du3a48ePb9So0ZUrV6gLUEYSS+9AWtMo+WNvb\/9F0Sgcp4PHhIPYvKi39+vXj+aetN0zffr0W7duQZ5ajEgTyB6vQiouywcAgqIo7969I8yT4jXhhrdeLlq0iECmRSLWkm3btsWBcCJQypuUgr5kGQBFcIWFheHzc8AENApURfBNTU2Dg4MZY+3atRs3bhyEtVqtLMuTJk2qV69eiRIlXr58CfakjLp9Lf2QTzsaVR14srOzi31N9Mc\/QvZjRFb7H3ttcJP4DpeoeEJAUZQaNWpMnToVEFCWadOmnT17lsTEp7Pp\/h4RMW0eZTUck+aP2JdExHRzUyoFFEUpX7583bp1IUyQUt78+fPjibKM7KhkTaYKEJhAW5Zl8WGHPn36QIDE4FyhQoXwXGndunVXrVolwn7mzJmvvvqKXpKdyI52uuKUnjQqviKXGnG6epuhhcHlESNG7N+\/n1oP+n\/NmjXnz58PAWpSnp6e9PIhJDHGxo8fr\/uSbGpMdOM7Qx1N18JpIxWTmiS2KxJDYOrUqUZGRgQy6VQU5dWrV5Ik4ckRcoxYm2IMARUCBCbiCXALC4ujR4\/iUvd1XNhvKVq06PHjxznnVatWpfd1IIssy3hXIdUR6aeOo7IkPS7TiEatrKxUs1FbW9svjUbFm2\/U8SRJql27Np3RQR3b2dn5+voSEaDFrF69mj4BhiZy69YtSZLoOxn4agU1UAqkR7vRpzJotgKUPokD7Y2SZFBQkLGxcbx3mX755RdJkqKjo1E7GdlX9QnzT9pC2CJAmNvZ2U2aNAnrcdxiggBNBTjnVlZWuINka2uLALIDfNAo7YdS7X\/SpDQUMNBoGoIbp1pcbu\/YscPU1LRYsWLbtm2jdhMTE2Nra7tz505qeTjtsXr16kWLFonZO3fubGZmVrx4cRyWhOUYlpPIIGntbIboxxBFA5Xu99MTsopA02q1kiThWU\/QJW2b2Nra9u7dm7o6VFFNJaTZEE8IUDtHjIuLC32hAIeZiGEpS+XKlX19fRVFsba2pqUbMGeMmZqaajQamojoxcCWUTRKkGXhgO44OXTo0J07dzo7O7u4uJDjiqKUKFEiICBAbE+yLK9YscLLywujLtqiJEn3798vV65c+\/btKTsNy2JATM3aYepdcJPI9JNeE9rIki1btqJFi0ZGRqoosmjRovPmzRO16UW\/FQ3S7zDhDDMPHjyYM2dOPFbboUMHMRX9hTHWqFGjBQsWcM4LFy585coVAE6wT58+vV+\/fmLGjKfUNKJRS0vLxBf1wFTVZPW7PSTPurFjxwYHBxMJIoC3as6fP9\/S0lLs\/+bm5nTMltrHr7\/+OmnSJJEXcAh82LBh4ucSofnWrVubNm1KnolZS5q6GQUS8k9EnsYefIUCn\/YVM5YrVw5nbsSKyMLtVvT9M8OqiiDQ8OG54ODgli1bogjVRuePP\/44bdo0znmePHnoLQok+f79+7t376LiqLOgLCriMy1PdvY0olFxbxTtz87OjvZGCd9UdFts5dQ3AAeVgnKpdFUWGtOobiijqJCyq1LpkjG2d+\/eggUL0jfTKQmv9Q4MDFQ9FVO4cGGc16EJrFar3b17N71yVFGUx48f4\/RicHAwvZwUpjLGXFxcChUq9O7dOzKPArjvRDbQopVi4kWJVrUQo19SS9kJLsKTYkg42e0y3TMsXry4Q4cOdevWJXxgQo4cOZYuXSo2gHQ3LasVWLp06V69enXp0gXAUr8jP3v16jVw4EDOed68eUNDQ9GKqL2RmB4F0ohG6Skmwqhy5coHDx6E52mECI1puvophjo2YmjnkQTQYURGoC5E7ECpnHPMAZEdAvfu3ZMkydHR0cjISHwrrSzLeIiYcw4ahTGyLONJYRU4Z8+e7dixI5W+cePGVq1a4diTsbFxREQEdXh838LIyAgfCCMfQaC4MSo6KPoobl3RjX662UKekoMwEvEESLwNmsyIN1UPIy9cuJAtW7aYuD+4hsdAxW+1w+xM55peob1582bcJlIUhdowtXPO+eDBg3\/66SfOOR1sIhoRxfTIqTSi0RIlSty\/f1\/suhUrVtT9AEPqAiEWB7jR3BFPfHE17k9VH7Isr1u3bvLkyefOnYNVMTEx6EurV6\/u2LHj4MGDHzx4gCTEb9682cbGpnnz5nhbJfQzxrp3796oUaPw8HAnJ6fVq1eDccDXxIPVq1efM2cO9DDG8FlQXBImN27caNiwIbkwf\/58b29v+FKpUiW8AxvKnzx50qlTJ9zHv3r1Kqa0yDhkyJBWrVo1bNhQtJxzvnTp0g4dOgwYMEC1FaAoyvr167t3737r1i2yhFjj0qVLYoNGGOQbFhZGOFNGYmGK0duAoijh4eGSJG3YsIGM9Pf3p3WDanpOMoZAchFQFKVt27atWrVCu6LXD1L\/HTt2bNOmTTnn+M4j9FMqtcbklpuG8mlBo4yxkiVL4s2P5Hy5cuXoebu08Id6LAJdunQpX758mzZtyACMe4MGDSpWrFiJEiWwvULc2rhx44oVKw4cOLBgwYLv37+nXIwxZ2fnixcv1q1bt1WrVhTPOW\/ZsuXo0aMPHz5cqFAhrVZLSZIkHTp0iHN+8+ZNR0dHunH8\/PlzJycniDk5OdE7LkNCQgoXLqxqHIyxu3fv1qtXD+4oijJ48GC6QT9hwgRPT0+CcebMmfjIbfv27em9UIyxkydPfvXVV8eOHcuZM+fvv\/+OolGQkZHR2rVrb968ie\/e0Kgzbtw4a2trPz8\/jUaDEYX86tGjR+nSpYsXL07HsJB0\/PhxMzOzFi1a4MYXyZN5mSXAGLOxsaEvWDDGevToUaJECVrlqIbezOKXXtmJ5hcREYFvtYnNnlrO1KlTv\/\/+e8ZY9uzZYTwlqUZxfXEtjWi0VKlStA2Mxle2bFkcqRURSV0UaCk6bdo0SZKOHDkiSVL37t2pqiZPnqzRaDw8PBYuXGhiYkJfDH\/9+rVGozl06JAsyz\/F\/cFmWZbXrFmDKaSfn1\/evHnpSc2\/\/\/5bkiQ8kSZJEh1Xwmlt+IVRF2FZlpcuXTpq1ChcLliwoGjRonjZcHBwcL58+VRQMMbu379fqVIlxDPG6JuInPM\/\/\/yza9euQJIxVrZs2cDAQEVRVqxYIc6eHBwccFOrWbNmVatWpZFm4sSJRNyNGjV68+YNLeerVav24MGDx48ft2rVqkiRIvjOB+d87dq1JiYmR48e\/eGHHwoWLEhPqeJJyhYtWpw+fbpQoUIYKfHcHk3fVK7p5yUaycaNGyVJunz5MrAqXrw47i+pGq3qUj890merqClickMtGTbPmTOnatWq0dHR2bJlo84ruqN3+KcRjapmo+jqIo2mBRCoG1mWW7ZsiWfIfv\/9d41G069fP0VR9u\/fL0nS4sWLOedv374tUKCAs7MzKqlv3770LGBERESFChWozr777jt8F1pRFEmSaArZvHlzcB9jrHHjxvSJmEWLFrVu3ZpmoB06dKAW06hRo02bNsHxgIAAeiouICDg66+\/xjCLVGR5\/Pgx3oMJI1u0aIFUXNavX580S5L06tUr+KXRaDA1fvfunZGREebFGFGCgoJgWLZs2cjfpk2bErnjiAmGkDt37nz11Vd+fn6c8\/DwcI1Gg+2qe\/fuWVtbFy9eHAaXLVuWVl6enp579+4l6FR7FBSvtwEsTb766iv6SnPevHn37t1LY4nY5\/XWCz03jDo+tV6KocDKlSsdHBzevHmTO3duitTrpUAa0ai1tTU+0k0olCtX7tixY1THFE8xnxmAQjT0wMBAXCqKsm3btmzZslWqVKlOnTpjx46lnrBx40ZjY+Pt27f\/+eefxsbGoaGhSOKclyxZ8vTp04qiNGnSJGfOnHSHYfr06ZjrhYSESJK0Zs0aLPdu375tZGQEdhsyZMisWbPIF\/oEAmMsf\/78N2\/eRFJERASOEHPO9+zZgy\/MqDB59+6dRqOh+a+zszMJMMbohWMHDx4kRsa9ph07dsiyPHXqVCK4ly9flixZEtS5YcMGjUbz6NEjWBIUFGRiYoL1+6BBgxo3bkzG\/\/HHH9bW1hcuXKhVq1bhwoWxCuOcX79+XaPRlCpVysHBIUeOHNeuXaMmTutfundH2vQ\/AHjbtGlTpUoVeITXssFy1C\/CVBH675QeWoinS8gwAAtI8btv3z4bG5vnz5+bm5uTGLUxMUZfwmlEoyVKlLh37544HylfvrxIo2KjTBUsxJYN5VTE4cOHJ0yYQG9BpmFw7ty5rVu3dnR0XL58OQmD11xdXZ2dndu1a3fgwAHRvDZt2nTp0sXe3p5elYhymzRp0qlTJ1mWa9So8fz5c2KTbt264QtUWq0WU0uys3DhwthV8PX1tba2RjwdeMJlrly5UDpjbNiwYaIlNC\/u06cPkTXnfNGiRYMGDQoJCTExMfntt99oZR0UFFS0aNHevXvXrFmTjkxAobOzc48ePfr27VujRo23b9+ShYqi\/Prrr82aNWvXrh2OtRJKt27dcnR0XLBggep0MO01k9mizfofZowtXLjQysoKpubMmXPnzp3kNQX035FMYSH1RLIWbe\/SpUtlypR58OBBuXLl9Jo9ye60oFE8FSve1+aclytXjhb1RBlkRoYEZFl++vTpgwcPMA\/F\/iC6Smho6M6dO1UTatTosmXL9u3bp3qe\/fbt27lz527RokXbtm1FX06cOIH9zd27dxcvXlx0vFSpUvjOyuDBg\/E4B\/SLLFa0aFFsMXPO6ck56KdbSVZWVqqPaNrZ2ZUoUQJbE6SNc37q1Knly5cvXLiQhjcEFEW5fPny7du3L168SLRLXpw5cwZhURWlZr3A5cuXv\/rqK\/RwY2Pjc+fOkeMI0GXW811PPAoJCSlUqNCNGzccHBz0xKRPmJFGNFqqVKm\/\/vpLbHC6t5jE1E9YmWbJ8a49aeGPYslOBGiND8KliaeXlxfua1EuyH\/99dePHz+eMGECTuPTjKZkyZJ37txRFKVly5Z4qSIVRKO0ubk5XvLEGGvevDnFx8TEdOrUSVEU3BwD3dNtIhxZjYqKgjx+STkN72KM6gQfXICpxLlkeZrVRkYqhnf4lSQJB34lSVJ9UozQy0hbs3TZqAJjY+M\/\/\/yzQYMGmcPXtKBRxlj58uWDgoKoBzLGypQpc+LECREUsRuL8ekWJl6gpSjxFJJwJ120EwKQF+MZY6Ghobt27RIj0eVy587dt2\/fvHnzurm5ifobN2585swZxlitWrU8PDziPclRoUIFJHHO6SsjsM3Z2XnRokX16tUrVaoUIYbSIyMjccdcZT8yUqWIk18yG1mgkPBRveqUistiAcKnYMGCnTp1ioiIyJ49O5AhKAioLOa7nrhD8H777be7du2irTM9MS9BM9KIRitVqiR+FYcxVrp06VOnTol2EGRiZDqHMRsVLSGiVPUccd5K\/Q0Z6d4U3aCHF0jduXNn8eLFa9SoQU\/NY+Hs7e09c+ZMzrmdnd3KlSvJBigHU7dr187V1VWr1UZFRf3vf\/8Tie\/QoUN16tTJkSPHw4cPKS+VqxujAlaWZZq9xsvghAN5p7veV+nM1JdADGuLESNGfPvttw8ePMBDt0gSfzO1p\/ppPOClTlegQIGNGzeOGDFCP61VW5V2NIrHaWgRVKpUKXy1ERaIcyK1TelyjWoj83SpBPRB80cYRUt4IhfSI1ot8iljbMOGDXiBE\/Ev53zLli1jxozhnBcsWFD86jrxF+d8zJgx+GJoYGDglClTqAjoOXnyJH1QQNUKiXBpok15VZ6qBFAvupFi9iwZFuvx4cOHRkZGly5dKlGiBEEh1l2WREBPnALOFhYWy5Ytmz59up5Y9Qkz0oJGOecVK1a8evUqykYDLV26tPgNcX2gUbHnwFT0GYqnAB3RULGqCC71N2JYzrl424qE0VCOHz8OZjQxMcHtOBRHhTLGPDw88JTRxo0bJ0+ejIz4VWmjXOICXJSkg1OQRBJNSHEpMjjpwUMNiThOlmSNAPDBEWM7OzsaaAERHaXIGs7qlRfUhmVZtrW1HTduHL27RK\/sjMeYtKPRwMBAsbwyZcoEBARQoyTIRJl0DhOVkzEIEGnCHuo\/ZDziiVkoO5a9dEl8Km4dUC7OOQ4tZcuWDVloqkv6d+zYYWlpqSjKlClTpk2bRpopIE4twYmkisAUSySXKZVsJp0IqC7hO6AQ82alsOhd48aNW7VqVbJkSZWDKnBUqYbLFCMA8KnL1KpVy9XVVfXtlhQrT\/OMqU6jaGcVK1bEayxwqShKmTJlzp8\/T92eemmae5hAAWRAQgFa3pLN0EQe6V6SKjELdU6ariJGUZROnTpxznH2XmUmZJ4+fYoHnJo3b+7v7w8ZJInkqMpLdC\/aoyJQJKkEoJMixSzkhW5ZWS+GMbZ79+4SJUqULl2a0KDxRqzcrOd7hnuEyUSHDh1atGhB7wnKcKs+YUAa0aiNjc2VK1fE\/ly2bNkLFy7QbQqxi37CxKyYjM6Jc\/J4vVNCXn7zzTfR0dE2NjZ\/\/\/33F8VlCQGSRvFElxQoUKBA1apV06g4g1oVAoCdwO\/Xr1\/Dhg3p0LRKWO8uU51G4aGNjc3169fpYWTOefny5VVjy5dJCvAazcXR0fHixYvFixentYxu+yhUqNDu3btLliwJMA17c7oQpVYMhnZMybVarYmJCT4+mFr6DXoSR4AWWIyxcePG1a9fPzQ0NPEs+pKa6jSKpaupqemCBQv27dt34sSJI0eO7Nu3z8zMDHujCZ1M1BdE0t4OGj+6dOny008\/lS9fPpEyv\/vuOycnJzMzMxqoExE2JKUYAXF4Qxu2sbGhN2ylWK0hY7IQYIxhi3\/VqlV58+ZNVt6MFE51GsV7hr799tscOXJIkvTNN98YGxubmppKkoQz4fCWqCQjnc\/QsvFqKEmS8PnPhGyZMGGCJEl4yQidXaVxO6FchvgUIEADFeBt1qxZtmzZUqDHkCXFCIAWtFot3VxNsap0zZgWNMo5DwgI2Lx5844dO7Zu3bpt27Y9e\/b4+\/sDI9X96HT1Vg8KExmwU6dORkZG1HvjtQ4vMK1VqxYNPInLx6vEEJkUBAhhCM+aNUv3PbBJ0WOQSQEC4s0SrVZ74MAB3WMSKVCbTlnSgkYT6edikvjG+HTyVj+KQXeNiYnZtGnTli1b6EZcQtb1798f7\/1kjInbzQnJG+JTgABaJqoGbxi4fv366NGjU6DKkCXFCNAk48KFC3hLeopVpWvGVKdRNEeCAzdPVJGqYT9dHdaDwmgsAUriOByvdaBOgpROO8QrbIhMGQKoFPEOnlarffv2bcq0GXIlFwHqBdiYjoyMFL\/jkFxt6S2f6jRKDtDdZ5AmsQDaKw37JP+FBIhDgQ\/Bkrj7BJfYzxPPYkhNFgKqZvmFj\/TJgi4VhQE7GrmBRlMRWIMqAwIGBL4IBDCS0cSiTp06mcbttJuNZhoIDIYaEDAgkNEIgEPFNcGOHTtwmdGmJaF8A40mASSDiAEBAwJpjgCRpkipaV5qqhRgoNFUgdGgxICAAYHPRIBuAGS+txYYaPQz696Q3YCAAYHPR0B1Ty+TTUgNNPr5LcCgwYCAAYFUQSCzrusNNJrE6qcKTqK8QcyAgAGBFCCAO\/X0lnFdDXTCVDcpw2IMNJpE6PWx8pJoukHMgIDeI0DnnGi+QgHRdnRD1Q6AKJAx4c+hUfhJx+wJCDyHIKIghuGnbkzG+B9fqeRIQECAl5fX\/v37R48eHR0dzRjbs2fPkSNHyHhxU5y+uiGqpPomlJCXNIi76YhUvXufHhUlVaJ+MtXX13fr1q1z5szBB5kXLlxIH68nEfb+pQAAIABJREFUGVKFgGiDqFMfwvSUAYzfvn27p6fn5s2bV69eLX5VgcQAIwEIF2RZ9vPzI\/dFABMaFGfMmEEfv4H8\/Pnzt23bBoWIQVWSNhWMiL958ya+PKZK1QdsP8cGgBkSEuLl5eXp6blp06Zdu3YFBAQgHs6Kv2Lz5pwfOXJk165dFEnVl1CW0NDQCRMm0CsiOefR0dHe3t6XL18W2zDVBQKqyj19+rS3t\/ehQ4fgOGMsODj4xo0bly9fptoR65QikwFUimlUUZTnz58fPXr00qVLeDo+ODj48OHDum9ahVnkIflMaCbD3LQXpRqNiopq2bLlgAEDNmzYUKhQIXxIqlOnToMGDaKPLInmkF\/Ub6k+yHfIUzUjnjJSq4IY6SGCVlU2ZT9y5Ai+POri4mJjY8M5nzhx4oIFC8S3wGBsIyYVK0X0IsPDhAZZwhhr3rw5vke9aNGirl27zpgxQ3wilvBUAcg5t7Kyevz4Mb0ZCzppSKPOTxqMjIx+\/vlnsYuOGzdu3bp1YgxhCG0wGDqBqlarHTx4cPfu3akBkC9ZIBATE3PhwgVJklxcXI4fP+7j49OxY8eNGzeKaMBxWpjTZc+ePfGJRhFDpFK9E2j4BoEkSVevXqW+wBgbPXr0nj17II94atuiDXjhXmBg4IgRIxo1avTNN9\/Q9zi6det24cKFvn374lUVovIUVlCKaRRO5sqVq1GjRiDEVq1aWVlZzZ07l5opIaIyjlqtKl6vLu\/fv29sbDx79mxZlmfMmDFnzhzO+fDhw\/GNOTKVfKRGgySKp0tdryFDnVmUpHaG5iI2MpAFxXDObWxs8D2SwMDAdu3aybIcEhJCz4NTuVSc7oSX3MnwAIwk79CWKleu3KBBA1Dn2rVrJUny9PSEqaqPsNKQAwAdHBxevXqFMLkv+ohIxCiKIkmS+DoS1OmzZ89QR+\/evRPlxbCo8+3bt03i\/qh\/kjuiWOYKiy48fPhQkiQvLy\/OeVhYmK+vryRJPj4+8DciIgLIIIv4O3r0aAsLC2rbaMmEkjg0ghlfv36t0WiOHTsmykRHR0dFRQE9miiIAqKpf8T93b9\/38jIqH79+visWadOnRRFWbBgQb58+UgVbEaNJ1SzCVZZimmUc\/73339rNBonJyeUOmnSJEmSaOiGM+IoDVdFE0WHEzQx3RNQN+\/fv5ckydraOjg4mDEWEhLCOV+0aFHNmjWnT5\/er18\/1HRAQMD27dsPHTq0d+9ezvnWrVv37NmzYcOGfv36hYWFvXz5ctCgQefPn1+xYsXgwYNBbdeuXfPx8Vm7du2ZM2cYY3\/99VeXLl0uX748dOjQp0+fAiVCZseOHdu3b1+4cOG9e\/cYY5MnT\/bx8fn999937dpFSP7000+5cuUCg+DbLevWrVuzZg3a65QpUy5evDhkyJD169cjy\/79+3fs2DFr1qx0h\/bTBcJxxpjYcuzt7V1cXGB8aGhozpw5s2fPzhi7efPmlStXfH193759yxjbuXPnsmXLXr9+PXjwYB8fH8ZY+fLl16xZM3fu3EGDBp05cwYvw\/Xz8xs5cuTt27c557dv3z579uz+\/fsxTH799dft27dfu3Zt3759b9y4gXn9kSNHOOePHz++devWwoULFy1axDmPiorasWPHuXPnMKMB1OD05cuXDx8+vG7dujCYPr\/6aeczgwRj7OnTp8bGxrTX8ejRIyMjI2tra875iRMnTp48OXXqVHg9adKkEydOXLt2bdiwYT4+Pr6+vjVr1vTz8\/v555\/d3Nzg7r1795YuXerm5ga47ty5s3379jNnzmzfvp1zrtFolixZsnnz5okTJyqKEhISMmHCBLwA\/tSpU0ePHl27dq2Pjw\/n\/OTJk+fPn1+2bBm6FeZ2NJmoVKlSgQIFOOdmZmaTJ09mjGFOvXbtWlrEUKdLdj2kmEZRpCRJP\/7446NHj54\/f+7n5ydJ0j\/\/\/MM5nzp16oMHDy5cuDB37lzO+ZIlS27fvn3\/\/n00wRkzZri5uR08eBAbJck2Or0yLFu2zMHBoWHDhjNnzkStzJo1y9zcfPv27aampkOGDOGcr169+tixY126dHFwcGCMNWjQwM\/P79ChQ5IkjR079tmzZyYmJh4eHkePHm3evPnMmTOHDh3q6up6Pe6vRYsWnPOrV69iMHd0dGzbti2N1ZxzV1fXSZMmPXz48PTp0+3atYuIiDAyMmrTps3mzZvRiFELt2\/frlixoqOj44ABAw4dOhQTE1OtWrXvvvsONhcvXvzmzZtDhw7NlSuXLMtbtmy5evXq7du327dvf+DAgfTCMqnl0NwZxiNbuXLlunXrRnspNWrUkCQpPDz8wIED06ZNs7W17dOnD+fc09PTxcWFc25tbV2tWjXOeaVKlZYsWbJ9+\/aOHTuWLl169+7dgwYNWr58ebdu3SpXrnznzp2RI0deuHAhKCho7NixYWFhRkZGLVu2vHnz5uDBg8eOHcsYK1KkSJcuXbRa7ZgxY3bv3r1kyZKSJUv6+PgsWbLE2dn5wIEDq1evlmWZVmBnz57dtGnThAkTfvrpJ1Ql2CGp\/uurHHENhiJJkpYsWYL5o6IoOXLkMDY25px7eXnNnz+\/WLFihw8fZow1atTIw8PjxYsXkiRNnTp14sSJkiTt3bvXw8OjXLlyXl5eI0aMwIZ+27Ztvb293dzcRo4c+eLFi+vXr69bt44xJknS7Nmzz58\/D5pGTO\/evc+dOzd16tR169Y5OjqWL18+LCzM3t5+wIABPj4++\/fvFzuRVquNiIioW7furl27tFqtJEnu7u6w3MjICF0bqNM8T5zbJqlCUkyj0C5Jkqmp6bFjxw4fPty1a1eNRvP06VNFUVasWPH8+fNp06aZmJgwxubNm3fixIl169ZJkvTw4cMqVaqULFkyICAAW8VJMjS9hKgbh4eHR0dHP3z4cM2aNZIkjRo1inO+dOlSfOYsR44c1apVw9LgzJkzy5YtwwtpzMzMnj9\/zjkvXbp04cKFsU5ctmyZVqsdNGiQq6urRqP54Ycf0Ousra2PHz8eFRUlSdL69es3bdqEtoiVBUjz1KlTcL1IkSKc8+zZs9evXx8x1HUZY\/fu3fvtt98sLCwg1rRpU0mS0IGLFSvGOcdCjHPu4OCANvTPP\/88evQovXBNRjlUBbSnWaFCBZqNarXaAgUKGBkZKYry22+\/HThwoF27doUKFVIUZe3atXifReXKlUuVKsUYq1q1Ks1NJEmqW7eul5cXYywyMtLX19fd3b1NmzZACTccTExM2rdvzzkPCgqqUqUK59zExMTW1pZzbm9vHxER8ezZs2PHjr148SI0NLR58+YVKlQYPnw4VYe\/v3+hQoWGDRuWI0eOQoUKzZs3D0nJ7pbJQCu9RRljoaGhxsbG+Ig80JMkyczMjHPeu3fv\/fv3586d29HREZ8QHzp0KOfcyMho7Nixc+bMqVq1Khi5e\/fuNWvWNDExCQwMfP36dXBwcFBQUOHChcFxnPOQkJCYmBgTE5OVK1dyzgsVKgRXNRpN7969hw8fPnDgQMZYVFQUbqsuX778hx9++P7777du3aoauvbt23f37l3UgpGREfbWGWNGRkZHjhxJhT2uFNMo2WRvb4\/9BU9PT0mSjh8\/zjlfs2bNpk2bpkyZAnJZuXLlsWPHTp8+bWJicv\/+\/Tp16lSvXj296z855THGfHx81q9fDzc1Gk2JEiU453PmzAGLWVpaFi9enHNer169kJCQvXv3GhkZYR6ExXX9+vVz5MjBOZckCZ\/b7t+\/v5OTU8GCBalBlClTJjQ0VJZlY2PjgIAArDKoy2HgHTVqFKac5cuXl2XZ1NQUwzJ58\/79+8GDB+Py559\/1mg0Dx8+bNeuXZ48eUCXsFNRFBMTE865qakptgtlWX7x4gXp0ZMAOgARKKwqW7Zsjx49EN63b58kSVOmTImJibG3t\/fz82vSpAmGn3379tWuXVtRFDMzM9RXjRo13rx5AxwkSWrcuLGTkxPwfPz48dy5c+ltbFj9GRkZ4dZQWFhYvXr1OOcFChRo0KCBVqstXLgw3TK+e\/dueHh4YGBgy5YtoQHUf\/HiRS8vL29v7woVKpiamq5atUqcFukJwikzA6Chdm7cuCFJ0u+\/\/w5V\/v7+xsbGuBX+9ddf\/\/PPP9myZfvxxx8551OmTMGSS5IkR0fHyZMn16tXD0pat249fPhwrMOw8ggLCzMxMbGzs4NaoC1J0unTpxlj9DL8b7\/9tkePHkOHDi1TpgwkHz9+HBMT8\/Tp04MHD1pYWFhaWpKP2GbZuXMn9mH++eefAQMG\/PLLL5xzf39\/SZLQF2AAfERrIQ1JCqSYRtE+JEnq3bs3SgoICJAkKTg4+M6dOyVLlrx3797Ro0c1Gk1oaKilpeXDhw+fPHkiSdKTJ09sbGzQt5NkYvoK0Ti2ePFiMzOzbdu27dq1S5IkjGCtW7euUqUKY8zc3Bz9J2fOnNu3b+\/SpQvoMl++fMeOHcOejiRJd+\/elSRp1qxZiqK0atXqhx9+mDBhQs6cOQ8dOvTixYsOHTpQdS5ZsmTMmDGSJEVGRlLfq1+\/fr58+R49enT\/\/v2WLVtGRkZmz569aNGir1+\/JrrhnJubm\/v4+Gzbtq127dqFCxfGYhaz0cjIyFy5cjHGtm\/fLknSH3\/80bBhw+rVq3t4eIwZMyYoKCh90U1SaeJAgg3oKlWqNGjQYNeuXcePHx85cmSXLl3Q4vPly9esWbO6detKkvT+\/fuAgABra+tTp07ly5dPkiRFUVq2bOnl5XX37l03N7cWLVrs2bNHkqRhw4a5u7svWLAgODhYkqRmzZr179\/f29v7zp07Go2mZcuWnPPNmzfb2tpiJMNwaGNjU6dOnYkTJ86ePfvcuXObNm26cuXK\/v37zczMXr58CXtgOWNs9uzZ33\/\/vRiZJM\/1W4i6xuXLl7G5dOTIkatXr7Zp02bChAmwXaPRTJgwIVu2bHh3\/bJly77++uu9e\/dKktS8efMZM2YULFjw2rVrly9frlix4oMHD5ycnCRJQmu8du3a0qVLNRpNp06dpk+f\/scff9y6dQu7AZzz77777tatW1FRUSYmJhUqVDh48KCxsXGfPn3Gjx8\/bdq0oKCgVq1ahYeHb9q0CdtZsOfixYv29vZVq1Z1dnZ2dXV98uRJWFhYq1at\/vrrLxcXl379+oFAyTUKJK8qUkyjjLHr168DHRS5atUqjUazc+fONWvWaDSaS5cuzZ0718jI6NChQxqN5uDBgxs2bMDggylVCi1Onn8pkcZi+fbt2z\/\/\/LOfn9\/SpUsXL16MQ12enp6zZs2KiYkZPnw45oCrVq1yd3e\/fPny7NmzfX19J0+e\/PjxY875kCFDBg8eHBoa2qFDB3zLb8yYMVgHrVixYu7cuXv27MFO+aZNm0aOHLl9+3Y\/Pz9HR0fAglH06dOnq1atWrJkydGjR48dO\/b69etevXqNHz\/+xYsXEENH9fDwWLZs2fLly4cOHYo90+nTp3fv3h371CNGjGCMnTx50tXVdevWrRcuXOjQocOwYcO8vb1Tgk7a56GGQYcfZs2aNXToUG9v79\/i\/iIiIuD43r1758yZc\/LkyS5durx\/\/\/7NmzcDBgw4cODAxo0bZ86cyRg7ceLE9OnTAwMDt2zZgs2W0aNHOzo6\/vjjj6GhoYqi7Nixo1+\/fl27dt28ebOiKD169Jg3bx5jLCAgYPLkyeHh4UOHDu3VqxdjLCgoqFOnTn369MEhgdOnT2\/ZsuXVq1dYatDIh8CRI0ewe5D2aKVTCagU\/D58+NDR0bF79+6\/\/\/77tm3bPD09qaY8PDymTJmyfv36bt26YfE+evToP\/\/8c9y4cUuXLo2MjFyyZMmKFSt27dp18uRJfF\/AxcWlXbt22DTDBne3bt0mTJjw559\/3rx5s1u3bmioEydOvH\/\/\/u3bt3v06DFp0iTO+ZgxY1q2bDlw4MCAgABFUQYOHHju3LkrcX9k7dmzZ52cnLp37z569GhXV1eMc5s2bTp27NjixYvDwsJSB74U0yjn\/MKFC05OTuPHjweI7u7uHTt2\/OOPP968edO5c+edO3eeOXNm5MiR586d69atm5ubW1BQ0KhRo06dOvW\/\/\/2vb9++4j2E1HEmNbSgAsCk6KvBwcEI4Fer1aIyIiMjEQBvov8wxt68eQMl4eHh+KoPxMTFwv379yMiImCvLMtYeCqKgqkoChJToZAQe\/funagNJ5xiYmKioqIgCcqADD72zRiLiIiA\/pcvX967dy810EpDHQQayoBHQEZEA2jDL9Qa7hEThsAZi25kxGkwUvL8+fP379+j+iIjI1+8eKEqOjIyEpPi58+fP3v2DBkhI954gQbEU+kIqBSmIWpppprgwn5LeHg45zw0NFR1DkFRFBx4Ql1QLgpA\/vnz5yKMRGdIvXv37suXL+EK9QiUi5p69uwZUp89e\/bPP\/8AZGwChIaGip1XluXXr19zzukMDDKGh4eTSamAWYppFA0IXqF7R0ZGvn\/\/HkdV3rx5Qy2Jcx4ZGUmoybKMlq2qgFRwJjVUELjoOcRc0E3dhsQQQDxFokchC+FAHU9MJRnKS1\/6gwGUnXqpGIMwmQptqk6LVNJPqaIeZNSTXzIVllM7IfBhJ8TwC18oI9WaeKpUV4aGIsKEEKDNWbrfFW+tifJi6aIBJJOpA\/CO2jAd2CRYkCQ2KjELxICq6pYOxMSMAIrwpEIRT1Uj4kllUS3rKoQ8WU76RT0pDKeYRqk8aqkqu6n9kbkUEM9Ikx49CYjTFmoi1CvEGFWvFu0HFKgweK1iOsIKAVUqVCGJQKPqJ2OQRL8kiewYk3WtQnZd4hAlMzyciHm0fiT8VY4TPvACqXR3CNQp9kyEqcrId6oUUT\/C+BUzIgYEQfIUoOom5Zk3IDqlgpGaHMkQe9KIJfYggEANm5iEapCSKBfVvlg0iqNCkURZRCU0JKcy\/immURoTRB\/Ik5iYGCIIlcWiV6ok\/blEjerWByyEm5RK80dUEn7FnkMjCtW9OCCrGl9MTAzBSEwhlkupGI3okvRQK6S2CxndGkmrVvV5FQlrCStdv8QYKooApwBVEMmoAip4CQ2CVJRXtVsohyVUIslT76CzrpSUSQMiVuIAQ42KQEOA2jz8FQFBFigk6CgS8qQNl1Tjoh7qd2BMZBGrSaVERJ7KFSNTHk4xjZKJFCD6hzWEOwToFwHR25RbnwY5VfjS4zTkHQRQr2JHJQep51DdExQiwUEhNIjtEvGiGWIpYhgyonLSJioXQRLVwmAxVU\/CMFJRFEwhCRDReMKWAmKqyjWSQbw4hpFyETqaFlG9iMjQ5rhY41TpqpUWFS1qyIxhgg6IkQtUWWiH1K9FeVGY4qklQwM1YxKggoAhzUMxOYAYNFM1kU5VR4MYbS2SPalWOymmURgKZ1QLYVVLgtEkSaiRM\/oZoAaB6tTlU5gtDo9iBVPzIu9wu4ly6VYhGoHYFKitIBKX0CyaR7NOKosCopioRKw+EtaHgAo3YjTYJjYecb4jAgUZaoSUhMkmXer2NFXRpEdkcxVEJEMBai3EAmSJKm+muySmI2cRIHzII4Astj2xtauyU40QG0IPdQRRQFVrkIFCat6UEXpQNGSgigwggz83kGIahUEqs1T2iaaL\/lM8AfS5bqR2ftERMUwtSezDKJzEVLVIQJGzJIAsutVMWXT7JJWCQkmSAhRPplJxlCT2cETq4W+8HokukF+iJPCh2sGl2J9FSFU4UC5oRl4V4HSJQskeXBIR0NSJdOohwsk1iXwEbrr4ADeVGHV8MRUy+BXNSCRGzI4shLaqHumStMFUukR21aVoRrLDKabRZJdkyJAuCKDFoM2lS4GGQrhuDzeAklwEaLyheWtq0lxyrUmuvIFGk4uYnstT4yMmpVeB6bnlmcs8TPZpS4dYIHN5oVfW0kyfppN6ZV5ixhhoNDF0MmcaNUddSs2cDum71fGuGfXdaD22j9qtHtv4X9MMNPpfPLLCFe0ZoTlGRUXhqdOs4Js++UDzfVqH0gCmT2ZmDlsITOLQzDTBN9Bo5mhlybeSyPTw4cP0MrfkqzHkiB8Bsbcb2DN+jD4jluD9DB3pmNVAo+kIdnoUJbY\/hFeuXKnnryVMD1zSpozFixeTYhF5ijQEkogAdvAJw0y2T2Kg0SRWc+YSE5dIK1asoHc4Zi4v9NzajRs3ajQavL6L+r+e26y35i1YsACvOxEtzDSoGmhUrLasEUbjo5Wml5dX7dq1s4ZreuWFpaWlJEl4337mu7msV1By\/s033+DrWESdNBXQM0vjM0ffaFTEjnb3MtkMPz6c0zNOBZe7u3vjxo21Wi0RK7VUCqSneVmjrPDwcEmSNm7cKEkS3vNmAPNzalaSJLyEkFppZhqZMpxG0fhE7PBoIz26JyaJ4c+ps6ydF5DiV6vVLlq0qFWrVnjrIjXNzHQbVC9ra9euXW3bttVqtXny5PHz86MhXy+NzQRGaTQaaqJkbqYZmTKcRgEZejVYkriSntUVp6gEsSGQCAIiS65du3bEiBH09UCC9\/\/sXQd4VUXTPjchvwalKojYsNFUyqeigiggIoj0EFp6IJFiIiWNAAakCgGkRJDeQigBQXrvICWhhBYgtAAhCSmk33vO7v+cO+FlPTcJEVJuIHl4LnNmZ2dn3p2d3bOnlaKaB4CPLBo5cuSvv\/5KH3Fr1aoVyePOp0dWLxXQIGBhYUEvIxdneo2M+R6aSRrVACRmASoSV1ga4dJDEQFKjsiVnPMZM2aMHTs2JCREM0uJMqKGUjo\/CHh5eS1btoxzPnbs2NIrePlBLG8ZfJu9NI3mDVSupZQiL168GBUVde3aNVEOQ73ELO9F682DDjL+TZ8+vRTMAuwQd3f3c+fOcc53795dsWJFevdlaZQ+NsKSJOHDNgjUx9ZW1BWLfTXKGJsyZcr06dO9vb1Xrlw5YcKERYsW\/fHHHyKURJeehOYzOGifDm\/VDA4OXrduHX3+G4v60gGfTzBzE+vWrRu9uygrK0un01GIlqKaG1yP5FtYWFy\/fl0jVmLwLPY0OnPmTFtb2xkzZmzdujUqKmrnzp1Llix57bXXpk2bRiBS9iRazK0axEsPgYAm+JYvX37u3LnBgwdrTpc0YqheSuQHARsbGxKTZdnCwkJz93h+NJTKiAhYWFjgk\/Eiv2TQxZ5Gn3vuOc1injFGn2LeuXMnJnka86UjP\/9RhSlnwYIFnPNu3boBPRD511YqqUGgW7duQPjVV1\/F12E1YqWH+URAkiT6pGiJHOlFlkbFRSUhK8vy+vXr69Wrh7N1XOhkjH377bcvvvgiSWLYg8hn3zyDYoAIbw6eN28e57xNmzaEBgY\/JJ9BlP6ry8AKL8O2s7MDkq1atTpx4sR\/1fnMygNMOj2iQ51Od+nSJcKEOKKYuWNVZGkUQCD4bty4YWFhsWLFChSJINK50sqVKzWnohrh0kMNAprgS0pK+vPPPznnXbp0wSfbgLNGWKOq9BAImAJlb2+Pb7e4ublt3boVgYpapUQeCOCTBJQQdDrd3r176RYdoA0iDz1mUVSUaZTwwo3K9erVa9y4MQ4BGYitW7e+\/\/77gAl8cEoJUwQIJfqVZfno0aN79uxhjHXq1OnChQv0muFSJE1xy40j4gncGGPOzs4I3enTp0+ePBnrg9xUlfKx\/NSkS1mWdTqdnZ0dQaQpLQG4FVka1ZzUDxgw4MMPP6Rrc7hLFGEKNFu0aHHw4EHk3xIAqBmYSHARmPPnz6eXjbq5uQUHB5cO9SfpHxFYBwcHqFq7du3w4cM10YvSUsIUAWBFkP7999+WlpYdO3bEh5uoCrb7TDWYF6fI0igAMhgM165dK1OmzMKFC7F\/h+ENfAmm8ePHf\/7550RriswLRzOzBgPe09OTruDNnj3bxcUFZkIAnFIibwQQfrIsZ2VlOTo6Qj4yMnLIkCGlJ\/UA5JEExjttjLRu3drW1rZLly5UkUpFmUcqLGaBIkuj4umks7NzxYoVNZ5TmOKXiHv37kmSdPnyZexDaWqVHmoQoAkca\/8ffviBJrCIiIgPPvgAQ700jWpwy+MQMUkyiqJcvnzZ3d0dH2LinDs5OeWhobQICBCYuJhM\/KpVqy5btszNzY1zTjv4JSmHqrlJWRk4LSRgvLRyXODS3wK5rHCuqINNHXz0H3kq8JnIBz75JQwGg06nmzZtGg1v8Ywe2OF6qKIo1apV69u3L2mnPshvS8+qnJgiW7duTSlVr9fXqVMHkGhSA\/ilhCkCplG3evVqHx8fzEmc8549eyKSTTWUcjQIiCOdc\/76668fOnSob9++4lm8KewaJWZ0WJRplHDZt29flSpV9Ho9VkyalSYgJmLOnDnly5e\/ffu2GaFm3qbQpQ\/G2O3btzt06IBw\/OqrrzIyMsTBb95+mIt1yI8gxo0bFxQUhDsfDAaDra2tuZhr3nYAQzEO69Spc\/jw4Q4dOsB2MZ+Cab5E0adRV1fX5cuXY72ZGzRYUun1+iZNmgwYMEDEPbdazxqfog0TD7lPeVNRlIMHD\/bp0werfmdn5+PHj9NhjmBSRdyJIkb8swasqb8AWVEUV1fXVatWgcMY6969u2mVUk6OCAA3EO+8887OnTs7deoEDqI0Rw1mxyyyNIo10auvvvqfUGCMhYaGSpKk2U\/5T0pKrjBwM3WBiijZUfzRL6qEhoaOHDkSh\/7+\/iEhIeLaX5MoccXPtK1nmQMAAUKrVq22b98OvqIojo6OmH4gVkrkgQBijzH25ptvHjlyhF5TQPEp5tM8lJhLURGnUcbYp59+Ss6LO\/Q5wgEo9Xp9mTJlVq9enaPYM84ESkTQ+lSWZUVRBg8ePHv2bNze2KdPn\/3795vCRfOTmBQQ4qbCzyBHRJhQqlOnzunTp0UosH0vMktpUwSwlQdUOec1a9YMCwvDlXqqJQqY6jEvTpGlUTpIQJg5AAAgAElEQVSLPHLkSKdOnfI5SvGOIkVRvvnmm3r16pkXdsVtzSPjzM3Nbc2aNWSmwWAYNWoUPRWW4xk9TqMoUyCrFreXZtQ+YSLL8nvvvXf79m3MT4wx2jwxI1vN2xREFxF16tTZvHnzTz\/9RFYjsEGYtzdFe6WeMda5c+c\/\/\/wTG6N5bCSjiIjNmzdbWVmZO5qFZp8m7NAO8fV6PQUcwo5GeLdu3c6ePYu6mzdvHjVqFIClZEqlxES\/oIook1vyhTFPMUGA4Ld69ep0sY5cZoz16tUrn4uDpxilfLqG6AJib7311r59+5ydnWkuL3n3PBXlavTu3bv4\/hcGfH6gJ+EBAwZMmjQpP\/JPmQyizdSv3GCkSP36669RRZbl1NTUzp07ixzQWIoSgUDXpE6RL9Z96mngTBsg5cqV07hceqVeA0huh+L+O4UTY+zll1++ceNG7dq1UauEXQgpyjQ6dOjQsmXLai5xADgNgcAF\/\/z5802aNMHhs0nQgpESKyASF5i4gfnu3btt27alPEiSjLEmTZqIcSxqQIqktYCoE0Ugnh3wCWrRcb1eX6lSJcw3JNCjRw\/NlPPsQPTYnhKqdG\/4uXPn3njjDajChgk4Zk0UWRpljFWrVq1fv34YnyDyAAjjn2ClvJCH\/FNZhNUoY8xgMOiNfxSCdHV4y5YtkCEEDAbDnj17evbsiURJg\/ybb74hAZy\/02F4eHhycjKSRabxDx2kUf5Ugpwfp2iJdOXKFUqjgKv0Kab8oCfKADoiPvroo40bN3bu3Jm+IYRSsYpZ04WRRgkFcQAriqLX6y0sLI4dOybCkTdepqO3Z8+epnO+qZjYhPnTZD\/gEt3BLMI5v3379r59+xYvXjxnzpwdO3bQZ1OPHDkyd+7cpk2bkpuEJ\/0GBQWJb7wnAU9PT3yqAe1evXrV1tb2119\/pafvT506NW3atOnTp2\/ZsuXmzZtUUTTPFFJqUUy7WKyZCpdQDsHFGNu9e3f16tXFbRDGWP\/+\/Uvf3JyfnhVDFBjWrVt3165dv\/7664kTJzDBk2R+dBa\/TCGlUYJAvNR+4MCBqlWrwmEMS3BMCdyIR4Qsy19\/\/TUqIt2UFLjJ4Pv37ycnJyclJSU8+EtMTEx68Ee85OTklJSU5OTkuLi4qKioK1euREZG7t+\/f9GiRZs3b960aVNISMjixYt37979xx9\/hISE2NjYpKenizlXluXAwMBp06YRk9byjLF58+bRC5\/Evac9e\/YMGjRo0qRJixcv3rp165w5c5YsWbJ79+59+\/aFhoZu3rz55s2bCQkJt2\/fTkhIiI+PT0hISExMpN9k419SUhIRcXFx8fHxsbGxpr1ZQjkIM8zfoaGh7777LrmDMT9o0KBjx44hOEuos0VmNnDjnB86dKhChQo3btwYOnTokSNHACwALzKrHr+hwkij8F\/c4GjUqBEWR1i25GG3mBQgNnjw4ODgYDyEV7KWPBQ6cXFxsbGxMTExdx78xcTE3DX+gRkbG3vv3r3Y2Njo6OizZ88eO3aMXhVKH\/whZI4cObJy5cqYmBjGWHh4+NSpU4ES4d+tW7e9e\/eKTM75zp07Fy1ahNFOOaJdu3YRERGyLF+6dCksLCwtLQ0CiYmJFy5cCA8Pj4iIuHz58pUrV27fvn3nzh2YGmP8u3Pnzo0bN27dunXt2rXo6Ghaw4q9rzGjJB7SxMMY8\/HxoTscsbBijAUGBs6fP78k+lX0NovrHlmWGzRoQBfoevbsGR0drdfrRYGiN+9xWizwNIrZG0ORQKlQocKGDRsAUP7HmGz8oyCeMWMGnrqDKpwaPI7\/RVgHyOTYpugOBMAEmKKzKOWce3l5URGmqBYtWtDVPLTLGDt79uzMmTNJP0Ganp7evXt30k8KiRY7iG7mh1VEkFr6Fc0TLyFqqpTQQ0BKRL9+\/ZycnAA++R4UFETfXi2hPhaZ2YSbGFHW1tbTp0+XZdnd3f348eMaYIvMsCdqqMDTKJaiZBYNs7Nnz1paWmZmZmJIUykCNEcfNMKc85MnT\/7f\/\/0fHn+i6sA9RyXmxszRWo2nogxoZDdCGCBQ2jK9\/fvTTz\/VZDdFUVJTU+mmMSpijG3cuHHkyJGaXjM95JyL+wA5oir2pkjnKFxSmIS\/OKl06tTJ29sbEJHAkiVLfH19S4pTxWgnYhKre0mS1q1bxznv16\/fxYsXAbi4YihGg\/PVdIGnUUJB\/OWcDxw48NVXXwWC+V+wkB6SJ9wtLCwSExPhmyYBgV8iCDIePtLIzNEjUQYDmHwkVCdPnhwXFwevjx071r59e7r5SVN3+PDhYo7z8\/OLjIwkGdp20BhgMBhEeTSRB4EWQeQhbP5FcJ+mrkaNGv3xxx\/iINfr9Vu2bBHfh2\/+ThWvhRQYNKItLS2Dg4MpS+zevVsMvxITPwWeRrHMESGoUaPGuHHjNOP\/kR2JtAuCc\/7OO+8MGTIEKyODwSA29EidZi5g6gtxxIQLNAgEOjxz5kxAQAAQnjx58vDhw02dZYyNHj0akXrr1i16bTsyhWkVcMQtaTBFw9A6vMiPWqgyT4LghUec8zp16qxZs4Y4WKUeOHDg+++\/R9eYpy9mYhUGL01FL774In3XcsaMGV27dqXtfjJVhN1MjM\/ZjAJPo+IsTashWZYrV64cFxeHIMN1uvzAhFpEBAUFlSlThpyhUQqBnD00My5SmMYuDRTiYY4OEhPa6EHbbdu2Ef62trZbtmwhfKCKDvEkmKIokyZNEi+MkCRukEATiPscLYEjaEgTAxAooQR5jSmhcuXK58+fJ1\/AvHTpUv369Uuog0VpNoIEwVmxYsWlS5dyzlNSUiwtLffs2YP5uCgNe6K2CiONwiCCbN26da1atQLzCYm0tDSdThcREYH+APGEmktcdSwPKc3NmDFjwIABhEbLli3Fu46QbRVFWbhwIcK0bdu2169fp4DOO0WWOHAK0GANMs899xweqAewaWlp77777jMbivlH2xQiSZJWr15NIEuStGPHDgAOIv\/6i0eywNMoeU4jk4Z3QEDAsGHDCtC9unXr0stgqC3TjinAtsxfFdxPTU1t06YNnQHQRxZpXamJxeXLlyONfvHFF1gUQAypwfx9L0oLCWfGmJWVFZ3LA3lC7PXXXy9Ke0puWzi54ZwfP37c0tJyy5YtFJPW1tY7d+4kWhQzd2cLPI3CYRqfnPP\/\/e9\/YD45wRibNWtWpUqVEMRICk+uvARpEN3HqG7VqlV8fDzn\/LvvvtOcWdNGiizL8+fPp8XU3bt38fgTOqsEIVAspsbGxr744otoWuyFqlWrioeQKSVEBDTTdpMmTWrVqoUtZkmSaGNKrFIC6AJPo7SowdKGc\/7ZZ58VIBCKosTHx5cvX\/7o0aOk9pmNXRFkgsLd3T0kJCQxMdHOzg6wgKDE+ueff8bExHDOFyxY4OPjg51Qmo1IWKxSgH1XQlWJy\/N9+\/a99tprcETc5a9evfqtW7dQVErkBwFJkujRErobR5KkSZMm0ToU2OZHTzHLFHgahT9027yiKC1btgSzoIj69esPHDgQk1hBqS1ZepDyMM6Dg4NdXFzOnj07evRoLNI1E1twcPC5c+c4523atDlx4gRcFqO2NI2KsABJzvns2bPfe+89wkczjb3xxhvbt29HxVIiNwQoM9CyVJIkEcxu3bpVrlxZBDw3JebFL\/A0Ko5GznlmZia90bYA3VYUxcvL65133gHcmoAuwLbMVpXpzpGiKBkZGV988UV0dLR4jz1QIl927ty5b98+xlijRo2I8wyil\/9uBThE+Pn50RV58DGHVa5cmT51lX\/lz6YkJmnG2EsvvbRr1y5gmJWVJUkSnS0ZDAaAbO5AFXgaJYdpqpFleenSpT4+PgULh16vj4iI0Ol0Yn+YO9CFYx\/FHwKOMfbVV19duXJl+vTp1CAhjwlfUZSwsLDZs2fv3r3bwcGBSsXeoXfxFY6xJVsroeTi4vLDDz9gZsL4l2W5WrVqCxYsKNlOFon1FI2yLBsMBisrK3rrG8Zy+fLlw8PDxZgsEqOerJECT6OAg0KtVatWq1atejIb\/1Wb8DUYDFWrVn3Gt6I014Voferh4REcHLxs2TJseqJHiLh58+aIESMGDx5Mj+IAXAQu5FH0jBO4sYxz3qlTp\/79+xNEyKEU6h9\/\/HFgYOAzjtUj3acwA3SSJEVFRRGT4rlChQoXLlwAwo9UaBYCBZ5GMVHTnrGVlVVCQkIBuorR7u7u\/vvvv+OwAJso0aoOHjzYsWPHu3fvkhciPkTfv3\/f3t6+bdu2R48eFUtLtNeFZ7w4qTDGGjduLL5Mi0Y+JYUff\/zR1dXV1BKkDNOiZ5Aj5sfdu3dXqlQpMTERO4GMsTJlymBvRATfrLEqjDRKg5MxFhYWZmFhUeBjlcDdvXs3XoZfYuAuklioXr265o5RcSTHxMS0bt26VatW9KbxIrHo6WmkVq1aoaGhptc2GWMTJ07ExwVoMVEaljl2PBKCv79\/z5496QXkWH41bNiwXr16kMlRg9kxCyONkpOyLH\/33XeNGzcGQAXivJgRxE\/eF4jyp0NJw4YNEYXY6wSHc16+fHl6I5R4uvp0+F7gXtB6E3mzWrVqp06dEkMauXLVqlU1a9YUDUARCLH0WaYpGnv37k2PgdI7XwilgwcPlilT5vr16yUpOAsjjSJoXnjhhcmTJ4sx9+ShQx1Awd2qVSu09eSanw4NsizjpnryiLCiPRZKB5IkDR06VEysT4fvhe0FY6xy5cq57chv3749tweZSqMUXUNQUBx6eHhs3LgRRRSinHNJkvbv3y\/yzZ0u8DSKwRkbGytJ0v3798U3YxYgHLIst2vXrmBzdAGaV4yqxo4dS7BQyIpjmGhHR8cDBw6UQpfPPgKABoOhcuXKKSkppsByzsPDw6tUqULPOGAU5LOJZ0oM8\/rAgQM1158JWGtr6\/Xr15ek+CzwNEoBQd9aaNq0KUKwAAMFMdqzZ89r164VRhMFaG0RqzIYDKmpqYhUYCWilJKSAoEiNq\/ENYdNJMZYamrqSy+9RC4ATxD37t2ztrbWOIhSDf9ZPgQmzs7O8+fPF5dZdLdJ2bJlN23aVJJCtMDTKJzX6XRr1qwRvxZQUKFDuMuyPH78eA8Pj4JS+9ToQRfgFn0xmSKInxp\/i8YRxlhUVBTWm4AReZZzbm1tDfBL0mKqaBA0tgJ8DAZD06ZNN27cCA5BqijK\/\/3f\/23evLkkAVjgaZS+NhEeHq7T6cTRWxg9tXfvXkmSNO\/gKIyGSpBOwhyDHF2AjSeRKEF+FaOpSJRHjx59\/fXXgS1MAqdy5cpJSUm4NgI+CFR5xgkCpG7dupRDxSjlnL\/wwguDBg16ptMoAdS7d++PPvoIH\/DRwPQkMYRrpoQy3b6LMCWCmivARp\/E4KKvSyAAE855VFQUwYUb9EpSjBY9giYtUiwtX778gw8+AHQIMAD++uuv0\/erSQG6AISJ4meOAdA45\/Xq1SP\/iUl3PjHGhg0bVqlSpfv375cY3ApjNSrLcsWKFfEFShG4gooaSgeKotSsWZM+JYYEIW61lJhuKChcjHoAOE319+7d69+\/P06d0FRh7LdA+dNH0McCvvzyy9xcY4zVrl17zZo1JEBr2GczAnODCMjQVPTFF1\/g3EgTnzqdjp6sz1uVuZQWRhq9evUqnWsjtRVsMNEXRgnBHTt2VKhQITU1FYAiiRRso9Bv\/gQ5DvdPnz7dtGnTqKgobJWiyPx9KXYLKZwIMScnJzs7OxrwwJAIEvv8889HjhxJzz4QX\/wtdl\/MxABg0rlzZyztyTaCTpZlnU6HTwyYidl5mVEYaXTSpEm9e\/emVsW1YV525LsMWVJRFFmW09LSatSogadCMadhPyvfip82QUqaiqJs3bp1yJAh69evB3QUx5oIftr8LyB\/xEBq2bLl4MGDCTcNhnTYpk0bT09PalnMvwVky9OgRlykt27dWoxJcX6qVKnSnTt3ALK5e14YafSLL76IjIws7Cs\/yJidO3d+8803qTnCHUXmjn7h2Ifgo5BdsWLF+vXr6Q2kSJ0kgyAuHEOeNq0NGjQQP3Ar4kyuOjo6Ojs7E11Ip2IlHVOAlpSU1KxZM02WoFLG2Ouvv47tkRLgcmGk0Q8++ABgMcYKPKnR4Ce1siyvXLlSp9PhhUaaxUIJ6IMCNZGQF\/Pj8uXLo6Oj6fwAY7tA23z6lRGeb7zxBj28qHEYg3\/kyJHfffed5qPf4kVRTcVn9lBRlKFDh9rb24vDlvZJCczvvvvOzc2txOBTGGm0efPm9GG1wkCBUKYcSsGdnp7+9ttvL1q0iJpDTIuppDAsMWed2AblnK9evZpz7uLiAoMBERHglxI5IkAoKYryyiuvaD5dIwLIGAsNDf3444+h5FmOQICgIYBJ1apVt27dahqKNAnt3LmzwF\/3rrGkIA8LPI0eOnTIzc0Nw7gwlj+AnoCgS6hvv\/02DokQQ7wgITN7XcCHiLVr13LO+\/btC8MplBHQ4JcSuSFAWFWuXDk5OZlksPWMMGOMnThxonr16jhRFfdVc9P8bPIVRdF8PgSgESCMse7du5cYcJ48jWrGZPfu3efPn6\/xvwDP68WopVboQpMkSeL1eohpLHnqD00dpy8qe3t73759G3ujhIOpcInAJ8e5Gb6AECMTTBEBhGXeMwpOPF9++WXoMSX0en1SUlLZsmVxE09+wMzRyLztoVIYkJ9WTGXEdjUpDEXUBP3m2Kg4TxCYeKOYaYvgkKROpyMOaUYpGqWPhIOvITT2iJZAoakMPBUvfUMepWKQaNrN+fCx0yjaFh1gjOl0uoiICGpMURQsS3Nu\/gm4YhjJsly5cuV9+\/bBf7H0CRopkVWRHQiExYsXc86HDRt28OBBwgd5oWShhJCjXjE1nkIRfBCmvQiIQJjKEIcE6LaQihUrmqZIsRVZlp977jmoEovANCVgQz7lNRrEjKApys8htm5xGQMjWgM4PZ2FOQxmY9BhsIPI0QBy09raGi90R4sivN9++y00EyHiQ7RoIfUR+CgiDjWB3iTD9Ho9vBBxEO0RG83RHZX52GmUNKINgjgsLIzuGMXXgXJt+IkLRFc55wEBAbT9p4HvidspqQoIB1mWV6xYIcvynDlzFi5ciKDRoFeynNQMhrzzCMYVhiLGFXmN9JEjCIjw27dvV69eHdGFuppaZcuWFc+KxESgkaRDsUewGgLTtAqyWN5em1Y05Yi+QC0MRirUXDGDkaYK6alFIJajADHXr19Pq1HyVGwdBrRo0UJjITSjB0kAfFKOWrlBRK7BQSRQqi6CrxkmmoYeOvgkaRRKyW5FUXr06NGiRQvwidCY8rDtx6I02nCYmppKj5+iG2DGY7XzNFSigFiyZAnnfOvWrYX6XFmR4aUZcpp2EYqIPRIQg4FojDGxSKMNh7IsR0ZGiregoIgIaKtateqlS5cwkhGNGnnTQ1TBI\/mmMhoOWS4Oe41A\/g+hSoQXNJXGx8fv379\/3759MTEx4lShObnBkMyj9bp169KXAWn5iS4Qs2rbtm3pBSWmeiCPnE4VgSEJ0ATJGKNXxCJvolNEDj3Up9Fj2nTOnMdOo\/CEGpZl+fLly2XKlDlz5gxgpSbhW84W\/Hcumqaq6LZPPvmEANJML\/+9hRJcg9AG5owx2hu9cuUKbh1FaQny07TT0deiF3m4RklBI2C61BK1EU1Nh4WFab4RYirJOX\/vvfc2b96ssTZHSWKSPZSFqZZpXYpw\/IpW5aE57yLGWFpaWnJyckpKil6vz8jIIEsyMzMJ2HXr1vn5+c2cOXPBggWLFy+eMGFC3759Bw0aNGbMmKFDh\/78888rVqzIyMjQWJubCzCGWpEkib6iiu7Q6FEUpU+fPnSVBVMUlCB7ojoVkRK9Xn\/t2rUxY8bMnDkzICBg48aNkydPnjt37r179zjnYWFh0dHR9+7du337dlxc3J07d2JiYu4Z\/+Lj42NiYhRFSUpK0iQxsekc6MdOo7Ab\/nt6er722mtoQ8xlkEHpExKmChljHTp0oN0WKsVc+oRtlazq5LsYBFu2bKFNas2T9aYYliBPyXiMIoPBQNM5uUB85B3EA5VCMj8IQGbDhg3du3dHi+CDIOWNGjWiLz5gqGPtkxu8GClQDsK0CjWH2Kb1VB7yphqIc\/Xq1WnTpnl4ePj4+EycOHHo0KH9+\/f38\/MbMGDAiBEjPDw8PvnkExsbm7FjxwYHB+\/cuXPx4sULFy5MTExUFOXixYt169b95JNP\/Pz8tm7dajAYYo1\/d+7c8fX1PXHiRG6NEp8xVq5cuY0bN+r1enKH7IcXxOzXr9\/WrVs1qkS0SX7WrFnjx4\/nnKempiYnJ0dHR7u4uHz55ZevvPLKokWLZs6cuX79+uHDh5crV65Lly5du3Z1cnLq3bv3jz\/+6O7u7urq6ubm5ujo6OTk5Gb8s7Oz++mnnxwcHPR6vWiP2K7GJPXwsdMoOhJRYm1tHRAQQG3AAoRIDm0\/AQsjBDoURfH09PTz88t7qwvyTzGBLs\/KykpMTKQrb4qi9OvXj7wWk2zJxSEqKmrfvn1Hjx49ceLE\/v37Dxw4EB4efurUqdOnT4eHh585cyY8PPz0g7\/IyMiIiIgLFy7s27fvn3\/+ofuWCKi8T6IpkmVZnjt37oABA8RrIAQdhSJgtLGxAc7oCJSaEjSOUlNTDx48uHXr1vDw8H\/++efUqVMnjH9hxr\/wf\/+dPHkyPDycfg8cOPB4r\/A4derU+PHj+\/fv7+XlNW7cOC8vr\/79+wcEBHh4ePj6+g4cOPDHH3+khEgIiEtCxlhycvLw4cO\/\/PLLihUr\/vzzzx4eHn5+fs2aNdPpdL\/\/\/rupmyKH0igeZMCZNX25HvnE19fX09MTcx7xCVIAm5mZKUmSlZWVl5eXh4eHo6NjkyZNatas6efnR7dLQ\/mIESOGDh3at2\/fgIAAd3f3oUOHDhs2zNfX19vb28fHx9vb29fX19\/ff+TIkePGjfPx8RHHiKaLRV+y6dzSqNFoowwjSYVzJbsO4zybmc3gnK9atUqSpPj4+IcszjU+i0WPTQNBUQMxt2\/fXqivRBFbNGda7PXQ0NCzZ8+StYMHDxZf95AjkubsFwYYObhgwQJbW1sHBwc3N7fu3bt36tTJxsam04O\/zp07t2\/f3sbGpnPnzh06dOjSpcs333zTsmXLtm3bNmrUqEePHiEhIXQHGNTm5jsBNX78+EmTJpEMGZAjgJ6enl27dsUyQlxt5KZ\/7969NjY2X375Zc+ePdu3b99B+OvYsSM51Fn469SpU8eOHbt06dK5c2cbG5u\/\/\/47N81588l+ylMaX8QiER9RjDLUyJEjf\/rpp++\/\/97Pz8\/T03PWrFkNGjQQxTQ2MMZSUlIkSaKVJiTFdEnobdmyxcLCIu\/3t\/bo0aNSpUo9e\/YcOHBg3759PT09Bw0atGPHDmoUvWBKmE6HOHuASRrL8zrMVxpVk2YOaRSeK4pSv359e3v7vFoq5DJC6rnnnlu5cqXY8YXcrJmqRyj4+PgQGoyxX375hfbaEVVman0uZsEpIpKSksLDwyMjI69evXrr1q2YmJg7d+7cFv7o8NatW7dv346Pj798+XJcXNyNGzemT5\/evn37du3atWrVKiwsTGwNMxDOooDVqFGjNmzYABvEWiIdGBj41VdfYUxSkZhMoZlzfv369V9++aVZs2YdO3b8\/fffN23adPPmzRs3bkQb\/27l9BcdHX379u1bt27duHHj9u3b586dwweKRTOKmAZKdOshWic+gQboxo4d+8orr8TGxmKcoggcSnM6ne7w4cNidVEyPDxckqRt27YhEYmlsKEoCNM0yh6sOhVacmavPRXw1aUo4wQQzUhHjhx5991309PTi8LiPNsIDQ196aWXDh8+TN1QbLDmaWRhF4pee3p64tDf3\/\/MmTNoHXxwzJyAwRi0+blABKdw8YSCljE2ZcqUhg0bLlmyhDRrzuPEVMgY8\/X1PX\/+vDjOoVkkli9f3rBhQwxssQjbTWT\/2LFj3333XWdnZ9PvieVYXaOKbCanxKIipsVZgUzy8PCwtbU9c+YMuSn6Qrd2vvnmm1OnToWd6E3ioJcZY3Xr1g0KChIxp1LaYahQoULHjh1xgqXRA\/1FQZimUZy8551GxSCzsbE5fvw43nVfFHbn1AYNj9q1a7do0ULsvJxkn2YehRr94r1tjLHffvttz549CEpxAJQIOMRxItJkPBaS8EXEQXMSRxmTMTZ69GidTnfixAkShiqghIqurq75QSwiIoK+16SxhwIS91OvW7dOkqTff\/9dbJdapzCGF6aEqe+mHNNahcrRPLz09ttvv\/XWW2lpaWgUUwh9P\/n69etURJaLExjxCZbatWsvW7aMoJONf4ArIiKiTJky58+fh+biBOFJ0ii5pCiK6QuvAF8RE4qiHDlyRJIkuobwyIgsYvOKoDl0ChF0VYTanTJlyu7du5EXisCYAm8CuYkIza+mOQw5MSfSYBOHXKNGjapVq4Z7d3AtRZRkjDk6OpJ+sa6mRc55WloafR8UYjADhKIoZcqUGTBgAHFojUaqIGOq2ZRjDuFNBsMRMnL37t3VqlWrV69eamqqOPeQmCRJBw8exMcXABStzEQEatSoMWPGDA0ylFV\/\/PFHT09P1M37OqEpdAXMQRpdNTZw6W+BXH64B5r3alRE5\/PPPxedL2AT86eOQoqssrS09PPzezYXpAgsgs3Z2RmcqVOnbtmyRcwp+YPWLKQQYHDnkWahCs6cNHuUxD99+rSFhcWyZcugEE0gyBljeJEoxHIkZFkuX768GHtEYwLgnB8+fFiSJNoEAx9EjmpFpugX8WGwKFZkNFqHp5zzPXv2WFtbd+3aVWPG8uXLdTrduXPnwEcGFEEjH2vUqIEP2Yt9wRirVq3a\/fv3oaSYicdOo7B7zZo19BQmphcUFRcRGBhIj\/eDEPIAACAASURBVDabBlxxmVSU7SKsOeeurq7UNGNs\/\/79QUFBCEcQRWnbY7el6Uo6ldMwNTMEldIvYQIOHeI3MDDwtddew62CGM9iXQcHByzkiZ+bL2XLlkVDGhnCvEePHnSro1iKHPTINabYcXlbIuovSpqs2r9\/vyRJK1asoKZpnqhatWqnTp00SCJigRtxrKyslixZglLSk5SUFBoa+vXXX+N0nqDTiBWlvw\/vG\/2vq1EK2fT09Pfff3\/Xrl3F3p0EJWKxZs2aj30jSJF2QCE0RsOMMZaamurt7Y0WFEUZMmQIDou9y2BJ\/gkxg+SzlsZNDDbsx9G+3ieffLJq1SoSJhlI0qa\/vb29yMmj9SpVqtADM5CHDcR56623xAWyqSoKY1O+hoMdSejXCBTBIXkk7ktQZiC+p6enu7u7eNXEysrq0KFDZBiZLf5SLSzM69ev36FDBxLAvfrdu3f\/+OOPsZ6F7\/kErVAwecLV6IgRI8qVK4eYKBQT860UOZRzvmvXrpYtW1Kv5FvB0yAoBtP169dHjx6NzT7OOb6RJZ7elgi3MVrEYBOZohciHzQIcbmHvHz9+vXGjRtjlYRWqBZjzMbGJj\/hxBj77LPPjhw5QvYgI0BhUlIS3REFASyiRWHRHQ0NR0BoBIr4ELAQgUMyb+DAgYhJxti7776LC3okCS\/E6sRcsWKFJEniR5kiIyMlSZo3bx71FOoWscva5pBGV4+bvGTCpOy9UabeOZ99iz3jikFmTGZcIR6TFW4U4JxXrFjx119\/JaX5DAKtBQV0DHthTK1atZBBqBTdWUBtFqQajf3wQtOGCLJIa8Ro0F65cgW9Q2PVy8sLgxbZBE2TQjoUBwMETFvRcPIvqaloDof01QZTfMg28VUaeVjLGLO1taWXE1IvaJKFv78\/3cZforHKAwEqgnc1a9YUOVWqVNm4cSNAFokcdUqSdPz4cWj74IMPxCfOc6xSDMw80mi2NQozPrOkZBkys51hnBsvP61YsUKn06Wnp8PJYnDApEmsST\/\/\/HPavQaHZM08meaYHHNkwnVNKTLgxYsXJ0yYIPbOhAkT6D47MEFguQS1YoiLL3MU+WJ1sWJJpHv16gXXgCFxGGNIo5DJzceff\/45MDBQPJOFpCzL1tbWePHr04QefNQQr732mhif1tbWd+7cIXhFkDW1cKjT6S5cuECYK4piZWUVGhqKFQDEiplAGl01NnDx+IniapQso7WnMXFmX7qX9QbOeHh4+Kuvvurq6kqhgO3eYvSHegsQDx8+vEuXLnT2SkZSkTnHbt62kYP0i7NREXBUJ0+nTZt26NAhMDnnv\/\/+e1xcHBIBFYl9B2G0JerPPw09+a9S7JJ169alu9kx0SKWOOc2NjYAKm\/vVq1aRQ+PwSNsoZw5c0an0+VdHbWeAkKW5UGDBg0ePBgIWFhY7N27F64RFHkAQqtRSrj0OmM86wklxU88Mo3SM0ucK3o5K\/uBJsaTE5NefPHF4cOHY1bJA4gicxLRT0unmzdvfv\/99126dEHWIIISRJFZlf+GNBhq0iUCUaPQtBYE8G1FXHSaPn06PQ8KTMRMgYqaZQKaAAHJ3Ij8S+amoYj5siwHBAT069cPlosgKIpCX1jLcfbSmHrixImff\/5Z3GYlnYqi\/PDDD7gHCDf6aKo\/HYeAcd26dfXr1z958qSiKH\/99de3335Lj9JBAKGYo+M6nY4W73q9vnbt2n5+frQOyFG42JhIoyvHTBJXozCIVqOyrFf3RumdJIy793ETX8\/8UPjBhio4RU+Ip\/DXr1+XJMnHx4f6TPwtesPyblGT3DWHmrq05yvKmCbZrKwsR0dHzbBfvHhxVFQUnb9j1sGA16y2RJ1oS4x+WAUmCBSVIOL27dt4tQ0cIRDu3r2LV0ZoINU4aDAY0tLSXFxcSIM4S929e9fS0jIqKgoa0IpGyVNwiIBRFKVu3brBwcGc8169ei1cuBDekfvidIUiEOXKldu2bRtjjC430ZNReVdB3aIjxDS6aNxvOKknC9SrTNmPz6vP1Cs8O01Wq6q+WUAMAlzMKTrTTVrC9E4Jgn6DgoIkSaLtlbznPRN9xcNA\/KF5BA1AFpEXxTR16bq8mC63bdt27NgxUxygEG2BA\/1PN0FnMPSADbaJke8OHDggPg+WNziyLNvZ2YmTE0EXEhJCaRrTWN56ngLAycG33357+\/btsiw7ODisW7cO71KhUoRcjv7qdLqrV6\/STSZ4kMzscEMaXTF6Ys5pNHtHVDEoelqNpqen161blzxB5iII8kYkR5gKiikmC9IJrOvUqfPNN9+ItpkKF5QZT64HZmMcpqam0nu5b9y4ce3atatXr16+fDkhIYG8MH3qgfjJycl48IbSK2Ps7Nmz4qtwkSZwE6WiKHFxcWFhYWfOnKE3J0VFRV25ciU2NhbRTz4ip5u6jOZMi8yc89VXX3Xr1o2WkOJCMjAwcMqUKeiRPLwg8Nu1ayfGG+XN5s2b0xZTHtWfpiIElYWFBb3rvl+\/fuIL2ACRGPMaBCRJ2rBhA+fc3t4+NDQUEasRK+ZDMY0uHvOv1Wj2DU\/GK\/V0w5PC2fGwE82bNx8xYgQWPgQBDovRHyRHcQBwzjdt2lSvXr1t27aZrsKK0VpN04gkEPTh6HPnzu3YsSMkJGTZsmUhISGrV69esWLFwoULV61ade7cOfEFP+gI0hwXFzdo0CAsrMDcsGEDwlcDyK1bt3bs2LFq1arg4ODQ0NBNxr+QkJCFCxeuXbs2PDz87t271Aq9Th8v2tD0Pq3sxFY0zprnoSzLS5cuLVeuHNyBC3Z2dmvWrCG40EF5eIGPA5MGUmhlZYVXw2g6Kw9VJbcIPnbu3Llu3bqyLPfq1YuuLwFYELm52aFDhw8\/\/PDevXsff\/zx6dOnNfGcW62i5iONrhw1cclY9Uo9Y3J2uJAt6tm8mlENBsO8efO+++47W9vuGRlZRW3oE7SXkZGxefNmfPAO2bZYuoQxFhcXd\/78+ZMnT9Kr2un39OnT4ISFhf3zzz\/Hjh07c+ZMVFRUYmIiIhJjOCMjY9u2bZs2bdpm\/KNXsSAoGWOXLl0aO3Ys+Ui1qHTt2rVQgnxx48aN48eP7927NyIigp7A0bRIZp89e\/bIkSMnTpw4e\/bsBePfuXPnIoS\/U6dOhYWFnT179u7du5ozlSfowCKtWr58ebqxkeAiHOrVq3fkyBGKHKCXo1lUijQKhGfNmvXmm28WS8jlaGeRMRVFuXv3riRJMTExnTp1oj0lQhLhCiJHqyRJ2rx5c8OGDakUkOYoXDxMMY2qq1GDjBflqafwdIuocUF67NgxSZJK3FkJVqbdu3fv0aMHRbm4XBJHhUgXan+godxOjXFCBEkQYmbMyspKS0tbuHDhrFmzSABBtn\/\/fm9vbzFAicYjj3Dw9OnTw4YNo1Mn09wnnkaJ2qg6rCJHqHVTMbRltgSup3366addu3bF1TYy2MrK6sqVKyLyeTgiyzIijcT0en3Lli27detGhxSTgC4PVSW3CDFAblpbW0dGRtrZ2a1atQpDkpZr4qGpv7Isf\/jhhzNnzuzTpw9i21SsmDlIo6tHBy4dl\/0UE8VQ9qaoMZOmJN8vU6YM3YZp3CHKPuMvZuvz3bzBYIiIiJAkCa\/qoKriytQ0g+Rb\/X8Q1AweHIIQdYGJJIVSFBERHByMwKXEFxAQQF9hQoIgyWXLlqEuaXNzczt58iQ0kx5NyGqqUKn4i+pEkLymlkbGrA7JVIPBsGbNGvqEOnZCs7Kynn\/+eXHCy8MvAt\/W1hYAEp6SJF2+fJlzLoaZGH5mhUaBGCMiJknS\/fv3P\/zww8jISFKOcH1kW7Vq1apfv367du0o7ea\/4iM1F5gA0uiqXyctG\/+vF+VlZ0rG42Pjfvi+ba1atbKysvIIoAKzqUAViX05Z84cKysrW1tbaiEzM1NcamHYFGj7OSvDGKNi0QwR4Tyyp6iXMUa77xRhNL3Pnz\/\/0KFDpuehixYtonAkDRcvXhwzZowYoBjbyL8kSYcay2FG9tSrZH+wS\/QCMmZOEG737t2TJOnq1avUKYyx8PDw8uXL5\/hUUm4edejQATAqipKVlWVpaYllF2FojukgN38ei0\/+Eg6SJPXt27du3briih5jM28oKlWqJEnSlClTKKjyFn4sS5+4kphGaTVKe6Nq0MgsOTnlwrnzSxYtbtrky0uXLlFrslzClqJkNnXq3Llz33\/\/\/T59+ty7d0\/sD3q39hPD+WgFYqN5S+eRsKiimOb++uuvnTt3igpnz56NT92KaZpu3EOaW7FixeHDh2EVCFEVhDXM3CyEWI7aUGqehF6vf+edd\/z9\/ck8xtiSJUvef\/\/9\/I9h+ggr3WROmzM7d+6kDKLZK8gRWPOE5b9aRa7hHVTjx49\/8cUX33\/\/faTOfCpUFKVatWoWFhYZGRkIY7PDTUyjtBpV77Q33h6amWVISEiy69nLvY\/blUvq+UhJHBXiOov8UhTF19fXzs4uLS2tGPvDdKUpBpZoWN6S5ODt27f79+8vLjNHjBiRkJCAXoNCWo2iLbxdXNO5mkPSjBUWVc8xjWoyBRoyc0I0e9iwYe+99x68c3JyovtAAeYjfZk3bx4e+uCcDxw4cPny5QAN1dEp4DxlBBxUFOW5556rV68eHNTEEvimxBtvvIH7bfNfy1RPIXJM0yhWozipVwwyvqiME5NCtKmgVSMjgBDTDW1XUX+j1wvahIf6MDgfsh5QYtEjLSFfxCoDBgygNzlSqPn6+lKpKMM5X7JkyYMG1f\/\/+OMPccNOhIhQwhKAamkOoUrTCoQhUFIIWZb1en2ZMmUSEhKoF8qXLz937lz0CIjcPJJledeuXdWqVSNJRVE+\/vhjApM4j9SQm+YSxBcDiWLm+eefb9CggSZ+cgwbjZtvvfWWpaWlhmleh0ij4iWm7C4nS+mee3p1nnGV+vBhJvNyJWdrELJiv4pM8MW9\/5x1FQI37zCCneIgJBo7udAQGho6cOBAqhIfHy8+dUOGU9HSpUuhgXM+c+ZMuAUoxHZR+kji8Wo9Um2RCYgjvEyZMmvXrqWmJUmKjo4mGhDlZhWBcOPGDVpA0bLj\/fffFzEHXdIRyw0EDZ\/cfPnllxs1akQAEief7tepU0eSpKysLFofIOA1rRTnIdJo9iWmf9\/wpFr2II0Wp5WlbeeEgLg3yhhLSUnBe1jOnDmDNKoJ3Pnz52MYp6am0lMlOal\/5ngiUGPGjOnbty\/nnL6EQVhg2OdxagmZcuXK3bx5k3OelJT09ddfP2toiomS6Bo1anzxxRePgcM777xjaWmZ23ftH0NhwVdBGl09OjB4wmTxk3Y4qX\/wkqeCb71U42MjgDmZHiiiE\/PBgweHhYVxznfv3v3rr79ieSVu\/P35558I8dDQUJKHtse2p6RXxDITKbJp06aMMVdXV0qCtK5ElszbX0VRatSoERAQwBibNWsWfaws7ypPX6k4LXHOq1ev\/r\/\/\/e8x3Kxfv74kSdhOLJazxkeYjTQaOmZyyMSppWn0EXiZUzGyIVaXERERNGL\/+OOPyZMna4xVFEWv1+\/bty8uLk5RlFu3bg0cODAlJQXVRYWauk\/9IflOY5XGf9OmTSdNmlS9enV6MAEIIOGCIxKkR5blJUuWVKhQYcqUKVZWVqdOnRJlnjWaMHnzzTc\/+eSTx\/C9QYMG9JJWIE8KH0NVYVUR0+jKwGmlabSwgC40vZqQorti\/f39Dx48SGGH4CNi\/\/799KWgLVu20EP3omkabWLRU09j642I7du3S5LUqlUr8dUBBELeKNHSPiYmpkuXLpIk9e\/fH13w1GMIBwkicpzoKlWqtG7dGgL5J6pUqYIr9eJtp\/nXUOiSSKOrRwdSGjW9Ul96Ul\/o3fBYDZgOZoPBMHHixHPnznl7e6MUY5g4x44do68qjho1yvTjqRB+LItKcCXkUPjAGPv88893795NHDEjAFsI50gcPXr066+\/jo+Pz7H06WaabhNZWlo2bdr0v3rNGHvuuec++OADqij2wn9VVYjySKMrR00sTaOFCHThqKbxLG59xsfHL1iwwNPTkxrETh\/FnyzLZ8+eXbdunaIoXbp0wb3QuFoFhYVjr1lrxXsMNFZqMHlkDsXjXho9z9ohpmQi6tatW6VKlccAwdPTc\/369QaDgYIZah9DVWFVEdPoqsnT8YYndfFM15hKr9QXFvZPpBf5EQTlRPoY\/Y8\/\/piWloY3hIqRl5KSYm9vv2TJkpL+zfongi\/PygSpmD1xse6Rd+CLUBMt1s2z2aewkDAkBObMmfMYdywQhpi6MN+bF1g5ptHszIkESoTR8BL5HKh5QV5g1mhGLEJtz549+\/fvF0vRJMksXbp01apV0dHRiHISwLCH\/LNDEBTAUIMM4aApzQ0cTGy5CTwLfGAlokHvbP2v7ovzENT+VyWFKy8rqyZNCwkYL4WOnhQyYYq6GuWKgT4WQtnToHCFc9nA1U\/Vc\/U9egp9kunhs6Gibxi9ovO4FgxnRHDBFAnSSdpM91moFGdhogGisEiTcrFdqiXWJTvBASEaVqi02CJMRXYTS8kM4gAlkal5lYZYV6SpCnpNXG2ZKicOqoMQ+xdMUWehgvZflQNPTXeLenB7DZhiLTALigBoIApKc7HrIY9EPImD37yBFQFBRInMYndQNcCYRlcEjJdWjpywZsoMnqXXG985qmZS2ZhA9YqcnqlkZaofB2UK0ihQIIDEhIX3EZCHcJ4ITSlGO5brmq9ioLrpCMeTPGgI+FIOokNRA5QQE\/egwTZSJVYUdx6ptDB+RQDJeKRRsTmgjcyVf5cJeaBBBGY70QDRZQ1fNAY0ZGAMisyNIAthJ6KOcBAxxyaJ+LBsHpk3b0\/RIolhBYDuEO8H0AjnrdlsSzVewFPCUDwkF8QuEOsiUAGd2bmMNLoiYPz8X0ZzWTFwWTauOjPS0nds2eo32GvRnHlz\/giyt+91+drVTNmg+pD9OrSH7sBV0X9Zlml7DtvDBoNh8ODBiEVRWIMRpi+McwpxakisSLSiKF5eXgsXLuzevfuYMWMggN6SZfnHH39s1qwZ53zu3Lnz5s1DDs0xC6AUGh56WziUqc3kuylfw0EuEHMrwUWSkCfDAakGc42nYi1AJCYasV3MT6QT3Vc4UD2RVlxYg81wHHCJbqL0yZ0iDVBIhNgW4QyBJ\/KzWCtj+CCKyE1yDUwCRK\/XGwwGMHNzH0+aiIgVq5cPGsdJ\/brxU5cav8UkM0OWIqdkpLs6u7z\/9jvjR4+JOHlq+7YtOp20NGS5zHlWloEr6ttnyW24BAJDjhoRQdm5c+f27duJQ0CTEk0VxCtJKooSExMDlNEf4DDGOnXq1KFDh4MHD9ra2rZp04aa1uv1mZmZGO1vvPGGTqdTFOXUqVNbt26FGYyxxMREqkLKyQCNgw8wK8T\/gYY43oiJCQmYYDFOHEoKer0eh2QovED2JA6SCJKvKA+mqA00IAUW0CnLsqb7IGNWBHU0BR4ZD7OBDPlLvwhvEI\/hDjWkmR2pH5+aBCrCQlghbEQkxckMVUSmCAg0QNK8CFxi+mvcFDWNGmTG1TP3n4cMliQp8sJFummUKYYFi+bPW7RQ5vzu3biNf29asGDB9evXOed\/\/\/037RwPHDiQ3rq2ffv2ixcvTp06lUA8ceLEoUOH6Itye\/fuPXDgAOc8IiJi7ty5J0+ePH\/+vMFgOHHixMSJE3fs2BEQEICHZynP3rlzZ9GiRXFxcXv27KHvJPv6+i5cuHDBggUXL15ExDdu3Lh169anT59OSEg4evSoLMsLFy5ctmzZ5s2bR44cOW7cOEVRbG1tK1WqxBjbtGlTSEgI5zwlJcXBwWHz5s2\/\/PLLsmXLqLeioqKWLFkyatQo6qqi6ULTVuiT3Pfv34+Li4ObnPMrV65kZGQgjJC\/MP8jHVDmTU9Ph7BIUO8g0GkvRTQDYx4pNUdASANj7PTp0zAGezVii+ZAk7XkEXwX\/cKMTlAAEHFUP4Yj0INuIoUiYmSVuC57jIbMpwpcBrxwlgggAD7iHN0EdyCD+09QVPwETuqNl5gmc71B4bKeKQ0++bhmzZqqM8Zr82lpKXYOvaYFzcww6G1sbIOXLq9UqRJ9siYoKKh58+Z6vb5atWqfffYZ57xNmzYGg4E+qco5f\/fddznnixcv5pyvXLmydu3asizb2Ni4ubkZDAa6lWzdunUWFhYTJ07s2rVru3btAJmiKO+9995vv\/1GS8iaNWtGRERYWVm99NJLCxYsuHHjBnqCc16tWjVJkv7++++YmBhqt1evXsePH\/f09JQkad++fZ06daLvQ7Ro0aJt27ac84sXL0qSNHXq1Hr16pUpU4ZzHhQUNGHCBFdXV0mSjh07pgmFIugwCiBZlrt06VK+fPmlS5d6eHi0aNEiKiqKRuArr7xC7xMh2wgBSp0ibmRqUlJS69atIUlMxCjkSYnoHZauVFfEQaRRZfbs2U2aNKFD5HGUmhVB5gEEsg2ww1QIAAqCK0f3USsPAmhDA3EAF\/h5KClBReTdnTt34Ljm\/Enko4hzfuPGDfrQhiggLuHNDqiHaXRMYIjx1SSKYmCcv1e7Vs3atdTvMCnq\/aOMK5JO+qB+PcZ5QkLSrh27a9euXblyZc75unXrWrVqxTmvU6fOJ598IstymzZtBg4cSE8cUjqjVwUrinLx4kX6PmJ6evrp06f37dtXu3Ztg8EQGRmpLn4jI2fOnPnyyy9TrMiynJGRIUnS3bt3aZqi1w5KkmRnZydCTH2g1+uff\/55nU5nb2\/POW\/VqlVQUBAti3Q63cyZM21tbempMicnp169etHkr9Ppjh07tnr1ap1OJ8vyyy+\/\/MsvvyxZsqRhw4aHDh3SpKdCDWLxjIZz\/uWXX9aqVUuW5dTU1P79+xNunHNa15MlIgiUCmnwJyYm0tzDObe2tiZPkQ5wSEoQlJSmNdeX4LKYapF0qK7BYNiyZUvZsmVJs1gFtJkQhBj5AsDJCzBNvdBsYohnA\/n0i9pFxgSBHtT0Tj7VmrNYWlrapk2bhg8fvnLlysDAQEdHR7JWXE4aDIY\/\/\/zTw8ODxun06dOXLVvm6uo6ceLEfv36YXEquolwFZnFTCONrhg9ccWkqVxvMN7RxMZPmijppIysTLrrSeGyZCF1tu3KOD9z5uyYX8e2atWqQoUKdLmmdu3anPO33nqrZs2anPOFCxe+\/PLLtWvXprPRhQsXSpJEV5ZiYmLoZVm7du2qV6\/e\/fv3GzZsSB\/vlSRp+\/bta9eurVu3LmLr5s2bkiSdOXOGsKtataosy1WqVBk4cCCmLxrS9+7do1qS8Y8xVr9+\/Tlz5lBFSZL++OOP7t27Uxr18PDo2rUrQS9J0okTJ5YvX05FZAYVUX8XcbdhOH355ZctWrQgS44cOUKfA7p\/\/7640Z6YmBgZGXnz5k3GWEREBF1TvnnzZocOHcqXL5+RkcEYq1OnTlpaGj6bTBnh\/Pnz4eHhyIz0ppLDhw+np6fD31u3btFX2GRZjo2NvXr1alpa2p07d0iAMRYdHR0VFUWw37lzh85F0HcgijnE\/908YywoKGjEiBFgk50rVqzAC0apiPiiF0QnJCR8\/\/33qJ5\/AqpSUlLGjBmzYMEC+jxBWFjY6NGjV69eTQLIsPnXbJ6SLVq0+OCDD4KDg0+ePDl37lxJkv755x8arYgxRVE2btw4adIkznlUVNTXX3\/9zz\/\/jBo1asaMGS+88AL5RbAAvaNHj4I2F8exNxr864RlE9WTenp86dKVyxUqVXRycZY51zP1ZlJJJ\/3y6yjGuSRZrFqx2t7evm7duoqiXLt27fPPP5dluUmTJvQt6ejo6J07d0qSNHToUMZYWFjYpEmTKEnt2rWLnquVJIkSWZ06ddLT0+nkOjIycuPGjRYWFoAvKSlJkqRZs2bRAqFBgwac8xo1atDrxJFJOef169enw8GDB9OZe+PGjQMDAznn4eHhDRs2PHz4cPv27elVMa6urh07dqS+1Ol0Z8+enTp1qiRJer2+efPmI0eOvHjx4s2bN48ePSo2UTR9hsVg8+bN33jjDcZYbGzs4MGDyfe0tLRXX32VXuPk7+8fGBg4adKk9u3bb9iwYfr06a+88krfvn09PDxoLqF34n3zzTcTJkx4\/\/33aV1\/5coVNze3BQsWODk5de7cmYDt1KnTyJEjfXx8OnTowDk\/cOCAv7\/\/xIkT3d3daQP6hx9+eOmll7y9va2trek8w9\/ff9KkSQ0aNKBUGxkZ+dVXX5mu44oGtPy3kpiY+MILL1hYWEyYMAHW7t2718LCgnZ1sETV6KShq9frz5079+GHH1IpMcXdZyQIDHUQWFtRtDdp0oReSDpnzhxJkkR7oJzefkCpR2OPmR+GhoZKkuTl5QWQ\/f3979y5gzMeWtETOPQ5Hx8fn6+++oo4CQkJeI6eOARFbGxsgwYNzO6NWbISEjgteOR4KWR84JLfHn4ZVC8bjh4\/5uPn6zvMf8+B\/cuWL+3b\/8fIy5cMihwQMGrcmPHjx49v3rx5XFxcVlaWnZ3dwYMHfXx86A0uCxYsiI6Onj17dlJSEud8\/fr1hw8fHjt2rMFg2LFjh5eXl6Iozs7O7du337Vr15AhQ2JjY3fs2NGsWbPDhw+vWrWqbdu2WCVxzjdu3Dh8+PANGzYcPXp08+bNaWlp7du39\/HxQWzRLXh2dnZjxozZunXrkCFDNm7cyDl3d3e3sbHZsmXLauMf53zYsGFNmjRJT0+fPn360KFDOeeJiYmfffbZtWvXli9fXqdOHc75zZs3v\/zyy99++2369OkUqRgYhR24mZmZaIIx1qxZs5dffnnDhg0eHh5ffPGFi4sLuVyhQoUffvhh5cqVdNcB5zw2NrZKlSq0MRIeHs45f\/PNNz\/44ANa11A4yrJsYWHRrVu3b775htatnPMqVar88ssvI0aMQDmNRQAAEfxJREFUsLCwMBgMx44d69Chw6lTpywtLffs2aMoire3tyRJjDEnJyd656OlpeWAAQMYY717975w4YIkSd7e3oqixMXF1a9fX7PWEDMIXCt2YtiwYa+88ookSRcvXiQLf\/rpJ0mSbGxsyLYLFy6cPHmSULp69WpQUNC+ffvo8ibn\/OrVq\/RSAs75tWvXLl269M8\/\/8THxyuKEh0dvX37dtpST0hIWLVq1ZkzZy5evEjXYAkcmiYlSaI5TFGUHTt26HS6ixcv6vX69PT0nTt30r4NY+y7776jD8NQMjJPPHPsUJrIqQg3ySYnJ7dr127lypXnzp3z9\/fv2bMn57x79+6vvfYa59zZ2blcuXLbt2\/n6s5hQsuWLTnns4x\/y5Yt++GHHzjnY8eOlSQpODg4x0aLjSkrwVOnLxk9QVozZcayKb+r940assgaOp3HalRm6p6p+iCT\/LA3aeSLpyFYTNHci2SHOhphEsOJqniFF5KUVaFBvD8f+inZiTL16tWjOwfISCpCKCM5oiLqYtWAXoEwOAVOUOtoSFGUjh074s4tWZZpOU9Ez549Z82aZWlpmZWVRZsAVapUYYyVKVOGTt7r1Knz1ltv0djDXnPZsmX79etXtWrVkydP0uXgHj16dO\/ePSYmpkaNGsOHDw8NDT106BCdSdy9e5cxtn37dgsLC0VRRo4cSQZUrFiRTmkdHBzmz5\/\/9ttvU\/ZJSEgoV64cwZLbgq7AQXsMhYyxgICAXbt2PffcczQyf\/75523btlWtWrVbt26MMVtb2wULFpw6deqll16SZfn+\/fuSJNWrV2\/gwIHUO4GBgQTFb7\/95urqyjkfN26cjY3N1q1bra2tZVkePXp03759d+\/erdPpbG1t\/\/rrL5LHuoyrp3RSkyZNZs6cuXz5cnd3d51OR+\/PbtSoEee8YcOGHTt2JDHaRUFgPIbLxVJFkqQXX3wRY4qIoKCgMmXK0IJUlmX63uro0aMJnzFjxnzxxReUQDIyMurVq6coiiRJ\/v7+S5YsoSvPERER5vhdJkVZMnXa\/DETpOBJUxZOCjTeep99b72iKDLDh5cUOtnHM\/UagMRnk6gIUxASJU6QqYgiA7mSOpsg1nQ8cqW4OS0GJTSTNjLgm2++oc+6abSJFeEFyZBhGstNs6qpwsLg1KhR480336QsuWPHjooVK5K11tbWrVu33r9\/v4WFRVhYGGPsxIkTNjY2GzdulCTp9OnTnPOvv\/6aoi0jI+Ojjz6i\/VALC4tmzZp17NixR48eZPArr7yyevXqqKgod3f3OXPm7Nixg3MeHx\/\/4osv1qpVS1GUiRMnUirv2bMnLUt1Op2fnx+N8JMnT1pZWdGW6JUrVz799FMRKxHGwsDnsXV6eXmdOXNm4sSJderUMRgMtMv01ltvNW3a9N69ezqdLigoaPny5XThlDFGy\/xRo0bRdB4TEyNJ0q1btywsLOheEYrP8+fPL126lDE2ZcqUzz\/\/nFLA7NmzKS1StFNvKopiaWnZsGHDZcuWBQUFBQQE6HS6mJgYRVE2bNhw\/\/796tWrS5Iky\/I777yDAVKyMmmrVq3oorEYEiEhIZhR6H34nHM\/Pz\/axxs7duxHH31EbiYkJNA1VUmScPLEOT906JClpaXZQcGUuYFTg34dIwUHTl00ZUp2Gn2QLGn5aTA+AkqXnozX7o2P1XNOUQWXkD01eQqpCgQGANaGYhURdyRQUQBMahr32cESIubMmYNXIWCNjAs4YuY1NYwspJyOOIbZhUQAQHKwZcuWlStXHjFihLu7Oz2aJcvy3bt3y5Yt+9FHH3HOe\/Xq1aFDh6VLlwYGBoaHh0+bNo222GRZnj9\/viRJw4YNi4mJadas2blz57IyMq0syzSoV\/\/unZha79ccFTBy25atbdt8zxlfMG++haR7p8bbbb5rHTDiF874X2vWtm7devXq1YMHD7506RJjzMbG5v\/+7\/\/i4uKsra2bNGmiKErjxo2dnZ3r16\/\/7rvv\/vPPPyNGjPj2229xRRt9VEhYPbZa+og8bX1IkjRx4sQpU6aoF+Jq1e3QruPSxcssJEu6V1q9Y0UNd\/UUrPyLFZwcnIkfdjxcJ1lwxnWSxBWW\/d1cRRWeOnnK\/Lnz\/P2GNvvqaxIYFTCSM167Zi31Zhf6wq5xUOkkyfMnD6N+tn\/vPgtJF3c3ljO+a8fOyAsX\/9egIW0xPf\/88zQcKKRzC9THRqPwKu7cuVuns3R2dlVfwcF5TExsbGz8pk1bJMniwoVIo1O8WrXqnPOePe0kyYLOEnBCc+bMGbraYWFh0alTp8jIyFu3bqWnp9PJwfnz5wvP8sfRzJQ\/p\/4+Y+xYacGEiQunTjXeeq+o\/a2oSVJNXsZ0qUYTk9Uc9KCR7FKjjJjjQCO7YWgRgTN0ZD0Eh6iTxKg1ka+pheEKJSQAvpiUH9iePQHgkIRJA\/SjtCgJ0ezo6OibN2\/euXMnIiKC7nkgSFNTU6Oiosiq2NjYtWvX0m59cnJyTEwMLndcvHiR1krZd54xfuLY8dT7KZzxlOT7169eS05Morwwb87cIYMGb9qw0XuIV+tW3xHzzp0727dvp1vNaBP50qVLnPOzZ89evXqVWqftQnpTlCzLtJ8gwoVOEZnFTtvb29Nl8ffee69cuXLU42++\/pZdT\/ujR45ZSJYL5y9KvJeUnppBUPy9bsMfM2dR6uSMb9m0tYyFVVJCok6Sfh05KiX5viqmsMEDB1lZluGMnwo\/+cn\/Pk5OTNJJ0vy585isvFKlKqmS9QausLSUVJ0kdWzfgSpGXb6ik6QTx45zxl+v\/hpnvFcPde3POW\/cuDF95UUMjGIHMJ8GzJ07v0KFSo6Ozvv3H5w7d\/6ff87lnH\/xRZO+ffvfu5c4b96CefMWyDLr1cveyuq5jIwMHx8fuqmccx4SEkKXoOmU38HBwdvbmy4DWFhYODg45NOGIhIzptFpY8dKf\/w6euqokZypJ+\/qq0aNc2Z2KuWcKeoVfFrBqW8sMWZTZBwQ1Nk4mxNHEdEajniYY76jpAwxNKRZVIo5FwFn2iJVJwEqVTcu1FcIcHHJSdrEtoqgM+AjPWWL1glz8VAECs7CfiCjqYLVkDqS6SyDqTNjSvL97rbdRgwbPm3q78FLlx3Yt5\/GNqZDKASH2kLT1BDW+4QVJtEigO4\/NXH+\/HkbG5vp06fLsrxx48azZ8\/SM3UfN\/xkoOcgJvMhg7xat2rj1tt95\/ZdTObr1q73GuytGFhf937LlgRnZeh3bt9V78P66alpy5cF165Zq13bH4JmzLwWdXXs6DEf1v1g8cJFwUuX9e\/bL+5u7P8aNPx9ylTOeNcuNrExd7PHlKxE37hZt3advu4\/qm\/\/YXzN6tD33nl3begazniHdu23bt7S28W1efPmKSkpPxv\/NFD\/J3+LVzg5OSU2Nn7Pnn03bqhfqJbVl8Tx6Ojb\/\/xzLC7unjGi+I0b0QcOHFIU5fTp03SWwDmPi4vDixwjIiJWrFhBV\/MZY9evXzfP1ei00aOlP8ePnz91KjdkciZTMlXXpMZVqNoTxMRa1Ng56vghjjGtqjGhSqprvWz+g1IxzWHAI3FQT9OhKCkK5EhDFWmg1vH7L3so8ZM9D7yATiSCh3qMFMIXkv\/yS9RWELS6Wjdinj1NGZHM5hCq\/\/YCiTIHO8kTOqWgpGmcGlVtDw5FmjN+KfKCcfqk59YUI3rqKSudiBgnUeMUq86m9E9dgqnI\/Nt3lfUgEtAXGhkz4SsG9QQrG5AHsKiHxhP57JP6B1MO1hZGAVpnGEfKg\/GSvQRhRtCYevZG53bZv7RAUd\/so6ivnVRP74wwMkU2ZD1YvsgYfSpBOD8gVLGH4GePtYdIUo8Xxu+\/+zevFiAJ0IxTdXbv0ws26RdbHMYHfB7qJA3\/jnOKMTXItaUIxRyJh1q1FOw05ittqeaYfFGRN6ZDTSkdMmVx0KxZv\/0mzZ885Y8JE7jBwA164xtHDcbHmdQ7RtXOU2R121QNDup79DEdGoPmQViIIZJd90Eo\/DsOcnSeVBnjSQyafGowtUERQ\/OBL\/nUBgMgLw4P07YKimNqszjwxKFotPDBuYLq3UM6e+YzDmZm7EFVrXEMUz\/KBnU8q3nEWMoMxv41qH1NNDcYCb36yw1Mn8G5wfi6xCwj50EwkLWihQWFwxPqQYIT8TTos+OTyQ\/TGQGiyNlo0Isl1LtS1HNwIyxAyQigbESAfpnBuPggrNRfQ0aqEbeHHK4YMWQGLmepNCqqOBv\/iUxNKVWhuhBWe0Q1Se1uiknEaoETpr2QWxN0EYViTFEegElnP7L6uUy1yPhLgIuW0xAjDYgl41SU7SOmnwetMIXikDDMjlKK1ez4zM3O\/HtEs51qpxFwrv4y4z+FP7hjyXi9aPH0oNkTfpP+HDdhasBInpbBE5N4RgZLT1Wy0hU5kylZSlY6S0vn6Zk8y6CioDfwjEyemcWzMlVan8Wz9DwzI5uTmZVNEyczQxXOyFTfYqoKm\/wzyGqR+A8yhiyVL+uNtYxtyXq1LX2m+puV8ZAmDlqEDVnGpmEb7CST6Fd1xNgE2SAbe1pWsk3SG9RSVaGJX4XKyUj\/F57pGSrO1GJ6hop8eoZ8P5nLSkbiPS4rWcmJ6iu301O5rKQnxLPUNC4bshKTuGyIjrykpgOD3thfWTwt1ehRBk9N56mp3KBEX7igCqSnZSUmKCn31YbSUtROVJHPVGlZz+UMJSXZSOjT42N5eqqqUDbwzAxqhX55ZpYhOUnVb9BzshMoZaQbw8YYJ6Y9VeActeOE+CQ6S41DlpqiIikbWGqaSsuKKpmRwTMzVUAyM7PuJfK0NNVafZZaKhtU0PRZPCPdkJwk30+W7ycp95PUCDRkqYSsvxV5gct6Q1JC5r04Qomn3s9KiOep91UA1fjMyIiPNSQlcIMRXuIbskg+LTZG1ZaZzjPTWUoyz0hLi7tL+hNuXlerpN8nviqTnqr+ZqQbwyBNRTs7WmgMFuhvbv2iWptltPnBL0nqs9TRmp5uuHePq+8uNshJSTwtXcVQVtToytTzlJTM+HhDYqKKOUVmZrqxUzJUR4xBpYafGjBU0RB\/47pKq2GfxvVZCdE3jd2RpuKQlcEz0nhmCqEn\/GaoRbnZaeoXSSK3ZGZl5xnVEuOIU0MoQ50y1UnROBkYDGpKTM1k91MDh4+YO2GitGXB4gG23X\/u1tPPtY+HnV3fHj369Ozeu2f3H+179be387RzGGTnOMTB2cvRZYiT+s\/bydXbycXHubePs6u3k6uXozNxTH+9HF28HElelTQKqxxTvqbU+0ErRkm1aXBMWwHHy\/FfkjnW0thD7Rp96U00fv9tp+qFRj\/azY9t+ZQhf72dXIGtl6ML0d5OBGb2r69LHyBPfTHY3mlob7fB9k4+zq5+rm5ejs5+Tr19s6Fz8Xfp423v5OPgMqSXg7e9s79Ln\/6dbSd7+bq37+Tv0ucnm24jf+zv38fdy8lRVevsNMTRYZC9nXroZP+AcBzsYO\/l5DjEwcnL0dnXpTch7GXn5Ovo4uPg4uPg7Ovo6uPg7G3vDA7xxV\/0KeH5GL95I68GqmqhGjNoa5Cdw8BeDt5OLh7de\/Xv2m1ob\/cBtt372XQb5vajl52jv0ufQT3s\/F36uLXr5G3v5GXn9ItbX19H11\/c+np07T7UubevS+\/+XbsNcXDycXEe6uLi7eAwxM7O39V1WO\/eI9zcvOzt\/V1dh9jZTRoyxNfJaYidnY+j46h+\/XwcHYe6uPzcvXv\/Ll38nJ297O37duo0rHfv4X36kEzfTp3GeXp62Nr6OjmN6tevX+fOvk5OXvb2Y376iTT069x5YI9uEwYO7N+lCxV5Ozh42al9pBrj3BsxkDcmuZV6Obt6ObvQb24yGr7YX4Szl6Ozj4PLUOfe\/i5uvo4uQ3rae\/Vy8HV0Uf+59Blk5zC4p2qzr6Orv0sff+feQ517+zm5UhR5Ozt5Ozj4ODp6OzgMdXHxdXLycXT0c3Ye1ru3r5PTUBeX4X36jHBz83VSxYg\/tE9vb2cnY2SqtbwdVLTxjwLYCEt2ptLYn+NI9HJ29XZx9Xbp7eXskv1rzHJ+Tq6+Lmrve7m6\/uzg4OHg4OHk5Pn\/i08ojEsoik8ujUspjkvODo9cMnEyAI6fFrmtyzriAAAAAElFTkSuQmCC)","b10bc109":"### Feature Extraction Code","8f3ffb0f":"# This time series plot is actually composed of many\n\n# different frequency waves. What you see are the low frequencies which have large wavelengths\n\n# The high frequencies get drowned out by the other waves\n\n# So different frequency bands need to be extracted","e7e2696a":"#### More directory handling","f617fdd9":"![image.png](https:\/\/i.imgur.com\/Yln5Xa9.png)","999954b9":"# Improving the results\n\n### Attempting to focus in on the frontal areas of the brain, the right oppcipital lobe, and the temporal lobe ","4107eb37":"## Beta sub band differences results","5da2347e":"# Part 1 Setup\n\n##### imports\n\n","584168c2":"![image.png](attachment:526435e1-f550-4543-a6a1-1cb25e46a9e2.png)![image.png](attachment:760d1857-c45b-4103-bf9f-1b881ba4bcb9.png)\n\n### Here, in the alpha band, differences start to show up","ce8d76d5":"# Average Power of Beta waves in Alcoholic and Control Groups\n","b7b3bca3":"# Does what happen in Vegas, Really Stay in Vegas? \n# Brain wave signal analysis of alcoholics and non-alcoholic subject groups\n\n# Question: \n\n### Can Alcoholism\/ predisposition to alcoholism be identifed by deep learning?\n\n\n\n### Part 1: Introduction and Background\n\n### Objective: Create a project that takes raw sensor data, and coverts it into  something usable by high level AI models\n\n###  Background information on Alcohol Dependance\/Alcoholism\n\nAlcoholism is a complex subject with a wide range of causes and risk factors including: \n\n1. Inherited Traits (Not caused directly by alcohol use)\n2. Psychological\n  a. Beliefs about Alcohol\n  b. Mental Illness (Bipolar Disorder and Depression)\n3. Familial Factors (having alcoholic family members)\n4. Enviromental Factors (Workplace stress, or Unemployment)\n5. Religious, Social, and Cultural Factors\n  a. Living in areas where alcohol use is accepted or shunned\n\n\n\n\n\n\n","46e369a6":"![image.png](https:\/\/i.imgur.com\/HYtAa8M.png)","8cf369a5":"![brainwavebands.png](https:\/\/i.imgur.com\/Sc3bWh7.png)\nCredit to Muse","11c9d43d":"# Image Classifier Using Theta, Alpha, Beta waves as RBG channels in an image format","a4b12187":"# Beta 1 \n\n### Hypothesis: Should be more prevalent in the control group","03858382":"![alcbeta2.png](attachment:a44c1687-c1c4-4362-bf6a-3b836d50f412.png)\n![conbeta2.png](attachment:dc3d768a-d5e3-48fb-a813-515e9bd9ad83.png)","68b8fd75":"![image.png](attachment:737f8b4c-84bd-4ae0-81f9-8f6e75cd69e2.png)","f755edc4":"# Extracting features Through a Wavelet Transform \n\nSince the research shows that alcoholics's brainwaves are more unstable than the control we need a way to infer the quality of the signal. Instead of only having the power of each frequency, we need a way to know when certain frequencies are present. \n\nThis is where a wavelet transform serves as a superior model to represent the raw signal. These wavelets contain more information, and are often used in audio and image compression.  ","b0e2edfe":"![image.png](attachment:7049df13-6085-479c-9614-664387c49442.png)","7e707651":"\n# Beta Band information\n\n### Here, as the next step of feature extraction, I looked for a way to focus on the key differences in the beta band, rather than a broad look \n\nStudies show that alcoholics have higher frequency beta waves than normal people (Rangaswamy et al. 2002) So, I went about making some modifications to the code to extract these frequency bands.","fc26a2b7":"![image.png](https:\/\/i.imgur.com\/g2ek8LW.png)","f3401717":"### Clustering of the channels by K-means applied to time series","7fd9696e":"## Interpreting the graph\n\nThis graph (cut off at 200) shows the power of each frequency from 0 to 50 hertz. Around 60 htz there is noise from electronics operating at that frequency, so it is cut off here. As you can see, the majority of the signal is between 0-30 htz\n\n### Benefits of using Fourier Transform:\n\n### Produces detailed information on the frequencies present in the signal\n\n### Drawbacks\n\n### Does not have information about when the frequency was present in the signal","1424b7a8":"![image.png](attachment:049bb346-16ec-48a3-bd1d-45ca3285eae0.png)![image.png](attachment:116b0274-cdd1-4794-a2b5-a21cec1d864e.png)","e595b37f":"# Part 3 Training the model\n\nOverview:\n\nControl group: 388 Images (collage of 9 channels) Total Channels: 3592\nAlcoholic group: 384 (collage of 9 channels) Total Channels: 3456\n\n80 Percent allocated for training\n20 Percent allocated for validation \n\n","91b9ea64":"# Attempt 1\n# Extracting Frequency \/ Power using Fourier Transform\n\n#### Many thanks and credit to Thomas Rider \n\nlink to notebook: https:\/\/www.kaggle.com\/xridet48\/eeg-images-vs-features-autoencoder\n","41267ff7":"#### mapping the channels onto a grid","ec58ea12":"# Processing the images","4fa222b6":"![image.png](attachment:0de9c88b-336e-4218-a202-515ba04a8464.png)![image.png](attachment:3baf52a0-5faa-40fc-bd48-557b447b84d0.png)","eb048e7a":"### Feature Extraction code\n\n### Features to be extracted \n\n#### Time (x) axis 0 to 255 samples 256htz\n\n### Y axis (Frequency) Bottom has low frequency, \n\n### Z (color, prevalence)","cde568d1":"# Inputting the data into a classifier","9c234d2a":"## These images are produced by overlaying the summed power of each three frequency bands, as the 64 channels are mapped to a circle as an RGB array. \n\nThey were then inputting into a classifier based on resnet 18, which yielded 60% accuracy. A new approach would be needed to continue forward","dcddd13c":"#### Handling the Directories","0cdf5354":"# Step 4: Choosing the relevant frames\n\n### This was one of the most labor intensive part of the project. Due to how the 64 channels would heavily correlate with one another, it was necessary to put them into groups.\n\n### There were various options to do this\n\n#### Option One: random selection\n\nAdvantages: simple and straightforward to code\n\nDisadvantages: subject to looking at the wrong information, repeating the mistake of the first attempt.\n\n### Option Two: correlate the data between the alcoholic and control groups, examine the channels that differ the most between the two\n\nAdvantages: Would likely yield results by looking at the right place\n\nDisadvantages: Compromises integrity of the data \n\n### Option Three: Cluster the highly correlated channels together and sample the different clusters\n\nAdvantage: would lead to a wider spectrum of data being analysed\n\nDisadvantage: could overlook important sensor channels by being too broad.\n\n### Option Four: Look at the channels that have been shown to have statistically significant differences in alcoholics, and see the results\n\nAdvantage: Very easy to code\n\nDisadantage: could compromise integrity of data if not approached correctly.\n\n## Here I chose options number three and four. Option three because it was a compromise between random selection that deals with the correlation problem\n\n## I also chose number four as an exploratory analysis, since it required very little unique code, and may yield interesting results that could later be verified using hypothesis testing\n","966c2d0d":"### Benefits of the wavelet transform\n\n##### These graphs contain information on not only the frequencies contained within the signal, but also when they are present. These images can be interpreted by an AI image classifier. \n\n### Drawbacks\n\nBefore, we had too little information, whereas now we have too much. Transforming all 64 channels results in having 64 graphs, many of which are highly correlated. To move forward, a way has to be found to deal with the correlation problem. \n\n# So, an attempt to do both will be made, first with the Fourier transform, and the second with the wavelet transform","e38476b0":"![image.png](https:\/\/i.imgur.com\/2WizDDb.png)![image.png](https:\/\/i.imgur.com\/2rCHMQy.png)![image.png](https:\/\/i.imgur.com\/nbvwdNK.png)![image.png](https:\/\/i.imgur.com\/MBQK2oN.png)![image.png](https:\/\/i.imgur.com\/AvyOaTg.png)![image.png](https:\/\/i.imgur.com\/LfBUExS.png)![image.png](https:\/\/i.imgur.com\/UbOTZII.png)![image.png](https:\/\/i.imgur.com\/FyJtkQt.png)![image.png](https:\/\/i.imgur.com\/CK608xV.png)","5a9e1b37":"![image.png](https:\/\/i.imgur.com\/QwxjVr5.png)","162072ee":"# Training the model","37c3f961":"![image.png](https:\/\/i.imgur.com\/qlrSv9u.png)","d7086ec2":"# A more accurate model: Morlet Wavelet\n\n# Brain Waves are more complex than sine waves and need a different equation to model it\n\n### Brain waves can be at different frequencies at different times at different intensities\n\n# Enter Wavelets\n\n### Used in image \/ audio compression\n\n### It's much more efficient to model the audio as a wavlet than to contain every last granular detail since the information is represented mathematically\n\n### Can model more complex waves such as a brain wave than a fourier transform can\n\n","9e1ae4d3":"# Results: A 10% improvment from before, but still not enough\n\n\n### Reasons: The wrong features\n\n### A time series only contains only time and amplitude information\n\n### The Fourier transform only contains frequency and power information\n\n#### It does not tell us about time because the model's equation assumes that a frequency is present throughout the sampling period\n\n### A compromise is needed\n","08303d66":"## Extract frequency band_power information function","57e4f4e1":"# Key Difference: Beta 3 waves\n\n### hypothesis: Should be more prevalent in Alcoholics \n","fad93767":"## Exploring the Fourier Transform and Classification results","73c9863f":"![conbeta3.png](attachment:50c24f13-bd79-4b02-935e-4354f95f693e.png)\n![alceta3.png](attachment:f15b22d2-9c1f-4d33-8ac6-b3b6ebd92776.png)","b84dbdce":"![image.png](https:\/\/i.imgur.com\/2Byh59z.png)","89a22492":"# Clustering the channels produced groups which had similar graphs\n\nCluster (Number): Size\n\nCluster 1: 2\t\t\tCluster 2: 6 \t\t\tCluster 3: 2 \t\t\tCluster 4: 17\n\nCluster 5: 8\t\t\tCluster 6: 1\t\t\tCluster 7: 5\t\t\tCluster 8: 1\n\nCluster 9: 17\t\tCluster 10: 2\t\tClusters 11, 12, 13 and 14: All size 1","2511dec5":"epoch\ttrain_loss\tvalid_loss\terror_rate\ttime\n\n0\t1.244782\t0.770245\t0.505435\t00:07\n\nnum train_loss\tvalid_loss\terror_rate\ttime\n\n0\t0.979887\t0.813298\t0.445652\t00:13\n\n1\t0.909634\t0.949886\t0.429348\t00:13\n\n2\t0.843650\t0.890759\t0.413043\t00:13\n\n3\t0.741687\t1.011093\t0.418478\t00:13\n\n4\t0.653198\t1.035518\t0.402174\t00:13\n\n5\t0.569481\t1.030253\t**0.391304**\t00:14\n\nThe final error rate is in bold above","a9f79d32":"# Data Wrangling (renaming columns and indexing the trials) ","086d9ed6":"![image.png](https:\/\/i.imgur.com\/itIgfQ6.png)","04589b8f":"![image.png](https:\/\/i.imgur.com\/UJ5htrN.png)","e225319e":"![image.png](https:\/\/i.imgur.com\/cUctMw2.png)","ca96cd30":"# Average Power of Theta Waves in Alcoholic and Control Groups\n","73d1fe33":"![image.png](attachment:d1d5d236-b2d3-4499-9480-9ce605ffa11a.png)![image.png](attachment:ad8410a2-cad4-48b3-b48c-58e20cefb598.png)\n\nIn the beta band, the differences start to become even more pronounced","35dff2c0":"#Saving the images","0e156e2b":"\n\n### Brain wave background information\n\nThe brain emits a weak electromagnetic field that can be measured via electrodes placed on the scalp\n\nFive types of Brain waves: \n\nBeta: Assosiated with waking, alert conciousness\nAlpha: Assosiated with waking, relaxed conciousness (index of relaxation)\nTheta: Assosiated with sleep and meditation\nDelta: Assosiated with deep sleep and deep meditation\nGamma: Assosiated with REM sleep (dreaming) and trained monks\n\n\n### Differences between the two groups \n\n# Alpha Brain waves: Alcoholics have been shown to have poor alpha rythnm\n\n# Beta Brain Waves: Shown to have statistically significant differences. \n\nSpacial: Occipital, Temporal lobes, and frontal regions shown to have higher levels of beta waves. \n\nQualitative differences: Alcoholics exhibit higher beta frequencies than non alcoholics, who have lower brain waves\n\n\n### Main point: there is scientific evidence that alcoholics have different brain waves\n\n\n","154d3d53":"# Findings","f6ae944d":"# Statistical Significance\n\n### Findings are in line with the scientific literature\n\n### Alcohol dependants show higher amounts of beta waves (higher frequency) versus alpha waves (lower frequency)","b25a3b37":"![image.png](https:\/\/i.imgur.com\/43jJnat.png)"}}