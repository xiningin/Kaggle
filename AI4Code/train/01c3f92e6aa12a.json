{"cell_type":{"bd1ac0e7":"code","0f547142":"code","cd1149f8":"code","d4ae96a2":"code","381b337c":"code","50403184":"code","a7c5fa18":"code","0c701455":"code","ed9e1218":"code","a73aeea5":"code","f888e1f2":"code","0ac550ff":"code","5067240b":"code","9329b6b0":"code","25ea178a":"code","d34d0533":"code","9a67500a":"code","997aa7e6":"code","0268f9c0":"code","1e2755ba":"code","214f3b19":"code","980775fd":"code","8400b92a":"code","f5ff2552":"code","91a7fffd":"code","8e54fe30":"code","7ccf0e10":"code","d63bf057":"code","d0910561":"code","c3b11fc3":"code","40a1c6fc":"markdown","f42af4db":"markdown","ea812ad2":"markdown","560e9954":"markdown","7d9bf011":"markdown","2eb48efc":"markdown","7d707c54":"markdown","83c3e538":"markdown","1ee57b93":"markdown","e5479cb2":"markdown","0ce460aa":"markdown","1275f7b7":"markdown","aae6e0c7":"markdown","49f021ee":"markdown"},"source":{"bd1ac0e7":"from __future__ import absolute_import, division, print_function, unicode_literals\nimport numpy as np \nimport pandas as pd \nimport tensorflow as tf\nfrom tensorflow.keras import datasets, layers, models\nimport matplotlib.pyplot as plt\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Convolution2D\nfrom tensorflow.keras.layers import MaxPooling2D\nfrom tensorflow.keras.layers import Flatten\nfrom tensorflow.keras.layers import Dense\nfrom keras.callbacks import callbacks\nfrom keras.utils import to_categorical\nfrom tensorflow.keras.callbacks import ModelCheckpoint\n","0f547142":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","cd1149f8":"df_train = pd.read_csv('..\/input\/digit-recognizer\/train.csv')\ndf_test = pd.read_csv('..\/input\/digit-recognizer\/test.csv')","d4ae96a2":"df_train.shape","381b337c":"df_test.shape","50403184":"df_train.head()","a7c5fa18":"df_test.head()","0c701455":"height = 28\nwidth = 28\nclasses =10","ed9e1218":"x_train = df_train.drop(['label'], axis = 1).to_numpy().reshape(42000, 28, 28, 1).astype('float32')\nx_train \/= 255.\ny_train = tf.keras.utils.to_categorical(df_train['label'], classes)\n\nx_test = df_test.to_numpy().reshape(28000, 28, 28, 1).astype('float32')\nx_test \/= 255.","a73aeea5":"print(x_train.shape)\nprint(y_train.shape)\nprint(x_test.shape)","f888e1f2":"g = plt.imshow(x_train[6,:,:,0])\nprint(\"Output = \" +str(y_train[6,:]))","0ac550ff":"g = plt.imshow(x_test[7,:,:,0])","5067240b":"model =  models.Sequential()\nmodel.add(layers.Conv2D(filters = 32, kernel_size =(3, 3), activation = 'relu', input_shape = (28, 28, 1), padding = 'same'))\nmodel.add(layers.MaxPooling2D((2,2)))\nmodel.add(layers.Dropout(0.3))\nmodel.add(layers.Conv2D(filters = 64, kernel_size =(3, 3), activation = 'relu', input_shape = (28, 28, 1), padding = 'same'))\nmodel.add(layers.MaxPooling2D((2,2)))\nmodel.add(layers.Dropout(0.3))                            \nmodel.add(layers.Conv2D(filters = 64, kernel_size =(3, 3), activation = 'relu', input_shape = (28, 28, 1), padding = 'same'))\n","9329b6b0":"model.summary()","25ea178a":"model.add(layers.Flatten())\nmodel.add(layers.Dense(64, activation = 'relu'))\nmodel.add(layers.Dropout(0.3))\nmodel.add(layers.Dense(10, activation = 'softmax'))","d34d0533":"model.summary()","9a67500a":"model.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])","997aa7e6":"class EarlyStoppingAtMinLoss(tf.keras.callbacks.Callback):\n  \"\"\"Stop training when the loss is at its min, i.e. the loss stops decreasing.\n\n  Arguments:\n      patience: Number of epochs to wait after min has been hit. After this\n      number of no improvement, training stops.\n  \"\"\"\n\n  def __init__(self, patience=0):\n    super(EarlyStoppingAtMinLoss, self).__init__()\n\n    self.patience = patience\n\n    # best_weights to store the weights at which the minimum loss occurs.\n    self.best_weights = None\n\n  def on_train_begin(self, logs=None):\n    # The number of epoch it has waited when loss is no longer minimum.\n    self.wait = 0\n    # The epoch the training stops at.\n    self.stopped_epoch = 0\n    # Initialize the best as infinity.\n    self.best = np.Inf\n\n  def on_epoch_end(self, epoch, logs=None):\n    current = logs.get('loss')\n    if np.less(current, self.best):\n      self.best = current\n      self.wait = 0\n      # Record the best weights if current results is better (less).\n      self.best_weights = self.model.get_weights()\n    else:\n      self.wait += 1\n      if self.wait >= self.patience:\n        self.stopped_epoch = epoch\n        self.model.stop_training = True\n        print('Restoring model weights from the end of the best epoch.')\n        self.model.set_weights(self.best_weights)\n\n  def on_train_end(self, logs=None):\n    if self.stopped_epoch > 0:\n      print('Epoch %05d: early stopping' % (self.stopped_epoch + 1))","0268f9c0":"from sklearn.model_selection import train_test_split\nx_t, x_v, y_t, y_v = train_test_split(x_train, y_train, test_size=0.2,random_state = 42)","1e2755ba":"x_t.shape","214f3b19":"x_v.shape","980775fd":"y_t.shape","8400b92a":"y_v.shape","f5ff2552":"history = model.fit(x_t, y_t,validation_data=(x_v, y_v), epochs=15,callbacks = [EarlyStoppingAtMinLoss()])","91a7fffd":"result = model.predict(x_v)","8e54fe30":"from sklearn.metrics import confusion_matrix\nimport seaborn as sns\n\n\ny_class = np.argmax(result, axis = 1) \n\ny_check = np.argmax(y_v, axis = 1) \n\ncmatrix = confusion_matrix(y_check, y_class)\n\nplt.figure(figsize=(15,8))\nplt.title('Confusion matrix of the test\/predicted digits ', weight='bold', fontsize=18)\nsns.heatmap(cmatrix,annot=True,cmap=\"Reds\",fmt=\"d\",cbar=False)","7ccf0e10":"plt.plot(history.history['acc'], label='Train')\nplt.plot(history.history['val_acc'], label = 'Validation')\nplt.title('Model Accuracy')\nplt.xlabel('Epoch')\nplt.ylabel('Accuracy')\nplt.ylim([0.5, 1])\nplt.legend(loc='lower right')","d63bf057":"plt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title('Model Loss')\nplt.ylabel('Loss')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Validation'], loc='upper right')\nplt.show()","d0910561":"y_predict = model.predict_classes(x_test, verbose=0)\nm = plt.imshow(x_test[9,:,:,0])\nprint(\"Output = \" +str(y_predict[9]))","c3b11fc3":"submissions=pd.DataFrame({\"ImageId\": list(range(1,len(y_predict)+1)),\n                         \"Label\": y_predict})\nsubmissions.to_csv(\"sub.csv\", index=False, header=True)","40a1c6fc":"Digit Recognizer Using Convolution Neural Network\n>   1. Import the Libraries\n>   2. Load the data\n>   3. Visualizing the shape of train and test data\n>   4. Normalization of data\n>   5. Visualization of image\n>   6. Create the Convolution Model \n>        * Add the Convolution Layer\n>        * Add the MaxPooling Layer\n>        * Add the Flatten Layer \n>        * Add the Dense Layer\n>   7. Compile the Model\n>   8. Train the Model\n>   9. Visualizing the Accuracy of Model\n>   10. Prediction on Test data","f42af4db":"*Now, we will have to predict for test set. So that's why we will create the Convolution Model*","ea812ad2":"5. Visualization of image","560e9954":"1. Import the Libraries","7d9bf011":"6. Create the Convolution Model \n>    * Add the Convolution Layer\n>    * Add the MaxPooling Layer","2eb48efc":"10. Prediction on Test data","7d707c54":"4. Normalization of data","83c3e538":"   * Add the Flatten Layer \n   * Add the Dense Layer","1ee57b93":"9. Visualizing the Accuracy of Model","e5479cb2":"3. Visualizing the shape of train and test data","0ce460aa":"8. Train the Model","1275f7b7":"2. Load the data","aae6e0c7":"7. Compile the Model","49f021ee":"*Now,  it's  time  to  see  a  prediction!*"}}