{"cell_type":{"01d71431":"code","7dab9159":"code","e2988b79":"code","4d2abe40":"code","e71c744d":"code","ab15fcb7":"code","8a2ae469":"code","13ac2784":"code","02eec461":"code","a9f30191":"code","1337f2a0":"code","510833ac":"code","86c5ff88":"code","b4a1c0a0":"code","055efe1d":"code","b3eff629":"code","a5e44a35":"code","e3699f1f":"code","4c15b53e":"code","b355bafb":"code","971693f3":"code","c9545b8b":"code","654c7471":"code","d14cdc15":"markdown"},"source":{"01d71431":"import os\nos.environ[\"KMP_DUPLICATE_LIB_OK\"] = \"TRUE\"\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset, DataLoader\nfrom torchvision import transforms\nfrom sklearn.model_selection import StratifiedShuffleSplit","7dab9159":"# split data to training set and validation set\n\ndf = pd.read_csv('..\/input\/digit-recognizer\/train.csv')\n\nsss = StratifiedShuffleSplit(n_splits=1,test_size=0.1,random_state=42)\n\nfor train_index, val_index in sss.split(df.iloc[:,1:],df.iloc[:,0]):\n    train_data = df.iloc[train_index,:]\n    val_data = df.iloc[val_index,:]","e2988b79":"# load data\n\nclass DataLoad(Dataset):\n    def __init__(self, data, transform=None):\n        self.data = data\n\n        if self.data.shape[1] == 28*28+1:\n            self.X = self.data.iloc[:, 1:].values.reshape((-1,28,28)).astype(np.uint8)\n            self.y = torch.from_numpy(self.data.iloc[:,0].values)\n        else:\n            self.X = self.data.values.reshape((-1,28,28)).astype(np.uint8)\n            self.y = None\n        self.X = np.expand_dims(self.X, -1)\n        self.transform = transform\n\n    def __len__(self):\n        return self.data.shape[0]\n    \n    def __getitem__(self, index):\n        if self.transform is not None:\n            if self.y is not None:\n                return self.transform(self.X[index]), self.y[index]\n            return self.transform(self.X[index])\n        else:\n            if self.y is not None:\n                return self.X[index], self.y[index]\n            return self.X[index]","4d2abe40":"transform = transforms.Compose([\n    transforms.ToTensor(),\n    transforms.Normalize((0.1307,), (0.3081,))\n])","e71c744d":"batch_size = 128\nepochs = 30\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")","ab15fcb7":"train_df = DataLoad(train_data, transform)\ntrain_ds = DataLoader(train_df, batch_size=batch_size, shuffle=True)\n\nval_df = DataLoad(val_data, transform)\nval_ds = DataLoader(val_df, batch_size=batch_size)","8a2ae469":"# view some training dataset images\n\ndataiter = iter(train_ds)\nimages, labels = dataiter.next()\nimages = images.numpy()\n\n\nfig = plt.figure(figsize=(10, 10))\nfor i in range(25):\n    ax = fig.add_subplot(5, 5, i+1, xticks=[], yticks=[])\n    ax.imshow(np.squeeze(images[i]), cmap='gray')\n    ax.set_xlabel(str(labels[i].item()))","13ac2784":"# view some validation dataset images\n\ndataiter = iter(val_ds)\nimages, labels = dataiter.next()\nimages = images.numpy()\n\n\nfig = plt.figure(figsize=(10, 10))\nfor i in range(25):\n    ax = fig.add_subplot(5, 5, i+1, xticks=[], yticks=[])\n    ax.imshow(np.squeeze(images[i]), cmap='gray')\n    ax.set_xlabel(str(labels[i].item()))","02eec461":"# build a LeNet-5 style nerual network\n\nclass LeNet(nn.Module):\n    def __init__(self):\n        super(LeNet, self).__init__()\n        self.features = nn.Sequential(\n            nn.Conv2d(1,128,5,1),\n            nn.ReLU(True),\n            nn.MaxPool2d(2,2),\n            nn.Conv2d(128,128,5,1),\n            nn.ReLU(True),\n            nn.MaxPool2d(2,2),\n            nn.Conv2d(128,128,5,1),\n            nn.ReLU(True),\n        )\n        self.classifer = nn.Sequential(\n            nn.Flatten(),\n            nn.Linear(128,84),\n            nn.ReLU(True),\n            nn.Dropout(0.1),\n            nn.Linear(84,10),\n            nn.Softmax(-1)\n        )\n\n    def forward(self, x):\n        x = nn.ZeroPad2d((2,2,2,2))(x)\n        x = self.features(x)\n        x = self.classifer(x)\n        return x","a9f30191":"model = LeNet().to(device)","1337f2a0":"print(model)","510833ac":"optimizer = optim.Adam(model.parameters(),lr=0.001)\nscheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer,mode='max',factor=0.5,patience=5)","86c5ff88":"def train(model, device, train_ds, optimizer, epoch):\n    model.train()\n\n    total_num = len(train_ds.dataset)\n    train_loss = 0.0\n    train_acc = 0.0\n    correct = 0\n\n    for images, labels in train_ds:\n        images = images.to(device)\n        labels = labels.to(device)\n\n        optimizer.zero_grad()\n        outputs = model(images)\n        loss = F.cross_entropy(outputs, labels)\n        \n        loss.backward()\n        optimizer.step()\n\n        _, predict = torch.max(outputs.data, -1)\n        correct += predict.eq(labels.view_as(predict)).sum().item()\n\n    train_loss = loss.item()\n    train_acc = correct \/ total_num\n\n    print('epoch: {} --> train_loss: {:.6f} - train_acc: {:.6f} [{}\/{}] '\n                .format(epoch, train_loss, train_acc, correct, total_num), end='')","b4a1c0a0":"def validation(model, device, val_ds):\n    model.eval()\n\n    with torch.no_grad():\n        total_num = len(val_ds.dataset)\n        val_loss = 0.0\n        val_acc = 0.0\n        correct = 0\n\n        for images, labels in val_ds:\n            images = images.to(device)\n            labels = labels.to(device)\n\n            outputs = model(images)\n            val_loss += F.cross_entropy(outputs, labels, reduction='sum').item()\n\n            _, predict = torch.max(outputs.data, -1)\n            correct += predict.eq(labels.view_as(predict)).sum().item()\n\n        val_loss = val_loss \/ total_num\n        val_acc = correct \/ total_num\n\n        scheduler.step(val_acc)\n\n        print('- val_loss: {:.6f} - val_acc: {:.6f} [{}\/{}] '\n                .format(val_loss, val_acc, correct, total_num))","055efe1d":"for epoch in range(1, epochs+1):\n    train(model,device,train_ds,optimizer,epoch)\n    validation(model,device,val_ds)","b3eff629":"torch.save(model.state_dict(), 'Pytorch-LeNet.ckpt')","a5e44a35":"test_data = pd.read_csv('..\/input\/digit-recognizer\/test.csv')\ntest_df = DataLoad(test_data, transform)\ntest_ds = DataLoader(test_df,batch_size=batch_size)","e3699f1f":"dataiter = iter(test_ds)\nimages = dataiter.next()\nimages = images.numpy()\n\nfig = plt.figure(figsize=(10, 10))\nfor i in range(25):\n    ax = fig.add_subplot(5, 5, i+1, xticks=[], yticks=[])\n    ax.imshow(np.squeeze(images[i]), cmap='gray')","4c15b53e":"with torch.no_grad():\n    result = np.array([])\n    for images in test_ds:\n        images = images.to(device)\n\n        outputs = model(images)\n        _, predict = torch.max(outputs, -1)\n        result = np.concatenate([result,predict.cpu().numpy()])","b355bafb":"result = result.astype(np.int32)","971693f3":"result, len(result)","c9545b8b":"submission = pd.read_csv('..\/input\/digit-recognizer\/sample_submission.csv')\nsubmission['Label'] = result","654c7471":"submission.to_csv('pytorch-submission.csv',index=False)","d14cdc15":"# Submit"}}