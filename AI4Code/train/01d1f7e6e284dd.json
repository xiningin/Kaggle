{"cell_type":{"360939b0":"code","bd02f6ff":"code","5f244db7":"code","d77ffc0c":"code","8beb723d":"code","653cec02":"code","89fa7d25":"code","3c5a1f4d":"code","ef5cbf14":"code","aff2ecd2":"code","059c23a1":"code","65b76a1c":"code","9086916f":"code","04bae4d5":"code","35f9212e":"code","94a97f0c":"code","b6ac6099":"code","33a999c9":"code","69ba27c5":"code","5d1b6d20":"code","167360b4":"code","d5a5ef26":"code","198d4a32":"code","325e0fed":"code","4c0c36c2":"code","70d227b8":"code","9a425eab":"markdown","74400375":"markdown","db7523a3":"markdown","1254e885":"markdown","1f6944b2":"markdown","d9a9d2c8":"markdown","9a2a8510":"markdown","ab49f93a":"markdown","6cd0e012":"markdown","ab995691":"markdown","1f5b2bcd":"markdown","be2a65e2":"markdown","4ee235b1":"markdown","37f9daea":"markdown","78069618":"markdown","080b4e28":"markdown","da5dddbb":"markdown","cdcd032b":"markdown","0258474a":"markdown","8591b6f0":"markdown","694d752e":"markdown","d942eb8c":"markdown","a3b057ae":"markdown","042c235c":"markdown","9deba206":"markdown","fbcac20f":"markdown","2b553b6e":"markdown"},"source":{"360939b0":"!pip install -q jupyterthemes\n!jt -t onedork","bd02f6ff":"import pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nimport numpy as np\nimport scipy\nfrom datetime import datetime\nfrom jupyterthemes import jtplot\njtplot.style()\n","5f244db7":"train_df = pd.read_csv('..\/input\/tabular-playground-series-jan-2022\/train.csv')\ntest_df = pd.read_csv('..\/input\/tabular-playground-series-jan-2022\/test.csv')\n\nprint(f'Size of train dataset: {len(train_df)}')","d77ffc0c":"print(f\"Start date: {train_df['date'].min()}\")\nprint(f\"End date: {train_df['date'].max()}\")","8beb723d":"start_date =  datetime.strptime(train_df.loc[0,'date'], '%Y-%m-%d')\ntrain_df['datetime'] = [\n    datetime.strptime(date, '%Y-%m-%d') for date in train_df['date']\n]\ntrain_df['NumDaysFromStart'] = [\n    (datetime.strptime(date, '%Y-%m-%d') - start_date).days for date in train_df['date']\n]","653cec02":"np.array_equal(train_df['NumDaysFromStart'].unique(), np.arange(train_df['NumDaysFromStart'].nunique()))","89fa7d25":"print(f\"Unique values in country: \\n{train_df['country'].unique()}\\n\")\nprint(f\"Value counts in country: \\n{train_df['country'].value_counts()}\") # Same amount of data in each country","3c5a1f4d":"print(f\"Unique values in store: \\n{train_df['store'].unique()}\\n\")\nprint(f\"Value counts in store: \\n{train_df['store'].value_counts()}\") # Same amount of data in each store","ef5cbf14":"print(f\"Unique values in product: \\n{train_df['product'].unique()}\\n\")\nprint(f\"Value counts in product: \\n{train_df['product'].value_counts()}\") # Same amount of data in each product","aff2ecd2":"# Function to add month labels as xticks in matplotlib\ndef add_month_labels():\n    locator = mdates.MonthLocator()\n    fmt = mdates.DateFormatter('%b')\n\n    X = plt.gca().xaxis\n    X.set_major_locator(locator)\n    X.set_major_formatter(fmt)","059c23a1":"%matplotlib inline\nmean_sold_per_day = train_df.groupby('datetime')['num_sold'].mean()\n# new_years = train_df[train_df['date'].str.match('\\d{4}-01-01')]['NumDaysFromStart'].unique()\n\nplt.figure(figsize = (40,20))\n\nplt.plot(mean_sold_per_day)\nplt.title('Mean num_sold over time')\nplt.ylabel('Mean num_sold')\nplt.xlabel('Month')\nadd_month_labels()","65b76a1c":"# code taken from here: https:\/\/newbedev.com\/how-do-i-fit-a-sine-curve-to-my-data-with-pylab-and-np\ndef fit_sin(tt, yy):\n    '''Fit sin to the input time sequence, and return fitting parameters \"amp\", \"omega\", \"phase\", \"offset\", \"freq\", \"period\" and \"fitfunc\"'''\n    tt = np.array(tt)\n    yy = np.array(yy)\n    ff = np.fft.fftfreq(len(tt), (tt[1]-tt[0]))   # assume uniform spacing\n    Fyy = abs(np.fft.fft(yy))\n    guess_freq = abs(ff[np.argmax(Fyy[1:])+1])   # excluding the zero frequency \"peak\", which is related to offset\n    guess_amp = np.std(yy) * 2.**0.5\n    guess_offset = np.mean(yy)\n    guess = np.array([guess_amp, 2.*np.pi*guess_freq, 0., guess_offset])\n\n    def sinfunc(t, A, w, p, c):  return A * np.sin(w*t + p) + c\n\n    popt, pcov = scipy.optimize.curve_fit(sinfunc, tt, yy, p0=guess)\n    A, w, p, c = popt\n    f = w\/(2.*np.pi)\n    fitfunc = lambda t: A * np.sin(w*t + p) + c\n    return {\"amp\": A, \"omega\": w, \"phase\": p, \"offset\": c, \"freq\": f, \"period\": 1.\/f, \"fitfunc\": fitfunc, \"maxcov\": np.max(pcov), \"rawres\": (guess,popt,pcov)}\nfit = fit_sin(np.arange(len(mean_sold_per_day)), mean_sold_per_day)\nfitted_curve = fit['fitfunc'](np.arange(len(mean_sold_per_day)))\n\nprint( \"Amplitude=%(amp)s, Period=%(period)s, phase=%(phase)s, offset=%(offset)s, Max. Cov.=%(maxcov)s\" % fit )","9086916f":"dates = train_df['datetime'].unique()\n\nplt.figure(figsize=(40,20))\nplt.plot(mean_sold_per_day, label='num_sold')\nplt.plot(dates, fitted_curve, label='sin')\nadd_month_labels()\nplt.title('Mean num_sold over time, with sin curve')\nplt.ylabel('Mean num_sold')\nplt.xlabel('Month')\nplt.legend()","04bae4d5":"# First date is a thursday\ntrain_df['DayOfWeek'] = (train_df['NumDaysFromStart'] + 3) % 7 + 1 # Mon is 1, Tues is 2 ...\ntrain_df['DayType'] = (train_df['DayOfWeek'] >= 6).replace({True: 'weekend', False: 'weekday'})","35f9212e":"mean_sold_by_daytype = train_df.groupby(['DayType', 'datetime'])['num_sold'].mean()\nmean_sold_by_daynum = train_df.groupby(['DayOfWeek', 'datetime'])['num_sold'].mean()","94a97f0c":"plt.figure(figsize=(40,20))\ndays = ['Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat', 'Sun']\n\nfor daynum in range(1,8):\n    plt.plot(mean_sold_by_daynum[daynum], label = days[daynum-1])\n    \nplt.plot(mean_sold_per_day, label = 'All')\nplt.title('Mean num_sold over time, by day of week')\nplt.ylabel('Mean num_sold')\nplt.xlabel('Month')\nadd_month_labels()\nplt.legend()","b6ac6099":"plt.figure(figsize=(40,20))\ndaytypes = ['weekday', 'weekend']\nplt.plot(dates, mean_sold_per_day, label='All')\nfor daytype in daytypes:\n    plt.plot(train_df.loc[train_df['DayType'] == daytype,'datetime'].unique(),mean_sold_by_daytype[daytype], label = daytype)\n\nplt.title('Mean num_sold over time, by day type')\nplt.ylabel('Mean num_sold')\nplt.xlabel('Month')\nadd_month_labels()\nplt.legend()","33a999c9":"mean_sold_per_product = train_df.groupby('product')['num_sold'].mean()\nplt.figure(figsize=(30,15))\nplt.ylabel('num_sold')\nplt.title('Mean sold per product')\nmean_sold_per_product.plot(kind='bar')","69ba27c5":"products = ['Kaggle Hat', 'Kaggle Mug', 'Kaggle Sticker']\nmean_sold_per_product_vs_date = train_df.groupby(['product', 'date'])['num_sold'].mean()\n\nplt.figure(figsize=(40,20))\nfor product in products:\n    plt.plot(dates, mean_sold_per_product_vs_date[product], label = product)\n    \nplt.title('Mean num_sold over time, by product')\nplt.ylabel('Mean num_sold')\nplt.xlabel('Month')\nadd_month_labels()\nplt.legend()","5d1b6d20":"mean_sold_per_product_and_daytype_vs_date = train_df.groupby(['product', 'DayType', 'date'])['num_sold'].mean()\n\nplt.figure(figsize=(40,20))\nfor product in products:\n    for daytype in daytypes:\n        plt.plot(\n            train_df.loc[train_df['DayType'] == daytype,'datetime'].unique(),\n            mean_sold_per_product_and_daytype_vs_date[product][daytype], label = f'{product}\/{daytype}'\n        )\nplt.title('Mean num_sold over time, by product and day type')\nplt.ylabel('Mean num_sold')\nplt.xlabel('Month')\nadd_month_labels()\nplt.legend()","167360b4":"mean_sold_per_country = train_df.groupby('country')['num_sold'].mean()\nplt.figure(figsize=(30,15))\nplt.ylabel('num_sold')\nplt.title('Mean sold per country')\nmean_sold_per_country.plot(kind='bar')","d5a5ef26":"countries = ['Finland', 'Norway', 'Sweden']\nmean_sold_per_country_vs_date = train_df.groupby(['country', 'date'])['num_sold'].mean()","198d4a32":"plt.figure(figsize=(40,20))\nfor country in countries:\n    plt.plot(np.arange(1461), mean_sold_per_country_vs_date[country], label = country)\nplt.legend()","325e0fed":"mean_sold_per_store = train_df.groupby('store')['num_sold'].mean()\nplt.figure(figsize=(30,15))\nplt.ylabel('num_sold')\nplt.title('Mean sold per store')\nmean_sold_per_store.plot(kind='bar')","4c0c36c2":"stores = ['KaggleMart', 'KaggleRama']\nmean_sold_per_store_vs_date = train_df.groupby(['store', 'datetime'])['num_sold'].mean()","70d227b8":"stores = ['KaggleMart', 'KaggleRama']\nplt.figure(figsize=(40,20))\nfor store in stores:\n    plt.plot(dates, mean_sold_per_store_vs_date[store], label = store)\nadd_month_labels()\nplt.legend()","9a425eab":"## Conclusion: Training data contains <u>all<\/u> combinations of (date, country, store, product) \n18 combinations for each day, no missing values :)","74400375":"### num_sold over time for each product","db7523a3":"## 2.2 num_sold vs product","1254e885":"#### Kaggle Sticker graphs now look almost constant on non-outlier regions","1f6944b2":"## 2.4 num_sold vs store","d9a9d2c8":"## 2.3 num_sold vs country","9a2a8510":"## 2.1 num_sold vs date","ab49f93a":"# 1 Exploration of each column","6cd0e012":"#### Period is very close to 365 days!","ab995691":"### Creating NumDaysFromStart and datetime Column","1f5b2bcd":"# 0.2 Reading Data","be2a65e2":"## 1.1 Date Column","4ee235b1":"### num_sold vs date for each country","37f9daea":"### Weekday vs Weekends","78069618":"## Fitting sin curve to data using MSE","080b4e28":"#### Very distinct separation between weekdays and weekends\n#### Fridays are also consistently higher than other weekdays","da5dddbb":"#### Creating DayofWeek and DayType columns","cdcd032b":"#### Clear separation between weekdays and weekends","0258474a":"## Plotting by day of week","8591b6f0":"# 0.1 Importing\/Installing libraries","694d752e":"## 1.2 Other Columns (Country, Store and Product)","d942eb8c":"### Checking if data is a contiguous range of dates","a3b057ae":"#  2 Studying how num_sold is affected by all other variables","042c235c":"#### Clear preferences for Kaggle Hat","9deba206":"#### Looks periodical with a slight positive gradient (perhaps growth of the website)\n#### Spikes probably caused by holidays (biggest spikes are caused by New Year\/Christmas)\n#### Occilates within a range of values which resemble a sin wave\n#### Occilations may be caused by variations in each week (eg Weekdays vs weekends)\n#### Lets try to fit a sin curve to it!","fbcac20f":"* Kaggle Hats display the most sinusoidal properties\n    * Possibly because it is most affected by seasons, more hats are needed during winter\n* Kaggle Mugs are only slightly affected by seasons\n* Kaggle Stickers are not affected at all by seasons\n* Very clear separation between each product","2b553b6e":"#### Fits pretty well at first, but fails to capture the small positive gradient\n#### Tends to 'hug' the upper part of the curve, most likely due to holiday outliers"}}