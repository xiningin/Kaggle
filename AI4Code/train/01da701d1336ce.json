{"cell_type":{"1e43eb63":"code","e667e694":"code","54c7c6a6":"code","949aae34":"code","312935ad":"code","937758d1":"code","6a036dc9":"code","6f0aa8c7":"code","e118798b":"code","4a26cf84":"code","3f8d3670":"code","d1578ba3":"code","17d2b052":"code","68526869":"code","36469a52":"markdown","f93bbd4d":"markdown","69ade119":"markdown","4a3f606a":"markdown","3c4add75":"markdown","abbf5cab":"markdown","800ac720":"markdown","25ce90f1":"markdown","aad5898e":"markdown","f4cc17a0":"markdown"},"source":{"1e43eb63":"import numpy as np\nimport pandas as pd\nimport statsmodels.api as sm\nimport matplotlib.pyplot as plt\n\nimport seaborn as sns\nsns.set()\n\nimport os\nimport re\nimport statistics\nimport joe_helpers as joe","e667e694":"def ExtractTitle(name):\n###############################################################################################\n# extracts a title from a name field, eg: \"Braund, Mr. Owen Harris\" returns \"Mr\"\n###############################################################################################\n    ptn = \"[^,]*,\\s(the\\s)?([^\\.]*)\"\n    p = re.compile(ptn, re.IGNORECASE)\n    m = p.match(name)\n\n    if m is not None:\n        return m.group(2)\n    else:\n        print(\"FAILED EXTRACTING TITLE FROM: \" + name)\n        return None\n\ndef ProcessTitles(cln):\n###############################################################################################\n# sets the title col on all rows (and prints out all the titles)\n###############################################################################################\n    titles = {}\n    t = \"\"\n    count = 0\n\n    for index, row in cln.data.iterrows():\n        t = ExtractTitle(row.Name)\n\n        if t is not None:\n            cln.data.loc[index, \"Title\"] = t\n            \n            if t in titles:\n                titles[t] += 1\n            else:\n                titles[t] = 1\n\n    #print(titles)\n \ndef ProcessNobles(cln):\n###############################################################################################\n# sets the Noble flag on all rows with nobility titles, this may not be useful\n###############################################################################################\n    nobles = {\n        'Don': 0, \n        'Dona': 0, \n        'Major': 0, \n        'Lady': 0, \n        'Sir': 0, \n        'Col': 0, \n        'Countess': 0, \n        'Jonkheer': 0\n    }\n    \n    for index, row in cln.data.iterrows():\n        if row.Title in nobles:\n            cln.data.loc[index, \"Noble\"] = 1    \n\n###############################################################################################\n# all titles found in the data, split male\/female -- aquired from ProcessTitles()\n# need to check these against test and make sure we don't see any new ones\n# at the moment we're only using these for ProcessNobles()\n###############################################################################################\nall_titles = ['Mr', 'Mrs', 'Miss', 'Master', 'Don', 'Rev', 'Dr', 'Mme', 'Ms', 'Major', 'Lady', 'Sir', 'Mlle', 'Col', 'Capt', 'Countess', 'Jonkheer', 'Dona']\nm_titles = ['Mr', 'Master', 'Don', 'Rev', 'Dr', 'Major', 'Sir', 'Col', 'Capt', 'Jonkheer']\nf_titles = ['Mrs', 'Miss', 'Mme', 'Ms', 'Lady', 'Mlle', 'Countess', 'Dona']\n\ndef ProcessSexPlus(cln):\n###############################################################################################\n# add SexPlus col (expands male\/female to man\/woman\/boy\/girl)\n###############################################################################################\n    df = cln.data\n    \n    df.loc[(df.Sex == \"male\") & (df.Age < 16), [\"SexPlus\"]] = \"boy\"\n    df.loc[(df.Sex == \"male\") & (df.Age >= 16), [\"SexPlus\"]] = \"man\"\n    \n    df.loc[(df.Age.isnull()) & (df.Title == \"Master\"), [\"SexPlus\"]] = \"boy\"\n    df.loc[(df.SexPlus == \"\") & (df.Sex == \"male\"), [\"SexPlus\"]] = \"man\"\n    \n    df.loc[(df.Sex == \"female\") & (df.Age < 16), [\"SexPlus\"]] = \"girl\"\n    df.loc[(df.Sex == \"female\") & (df.Age >= 16), [\"SexPlus\"]] = \"woman\"\n    \n    #Miss and Mlle could be handled better, we could look at the percentage of Miss and Mlle with ages set\n    #who are actually child vs unmarried adult, then split the nulls between girl and woman\n    df.loc[(df.Age.isnull()) & (df.Title == \"Miss\"), [\"SexPlus\"]] = \"girl\"\n    df.loc[(df.Age.isnull()) & (df.Title == \"Mlle\"), [\"SexPlus\"]] = \"girl\"\n    df.loc[(df.SexPlus == \"\") & (df.Sex == \"female\"), [\"SexPlus\"]] = \"woman\"\n\ndef ProcessFamilies(cln):\n###############################################################################################\n# process family groups, split SibSp\/Parch out to Spouse\/Children\/Parents\/Siblings\n###############################################################################################\n    df = cln.data\n    df_process = df.loc[(df.SibSp > 0) | (df.Parch > 0)]\n    \n    for index, row in df_process.iterrows():\n        process_as = \"\"\n        \n        if row.SibSp > 1 or row.SexPlus == \"boy\" or row.SexPlus == \"girl\":\n            process_as = \"child\"\n        elif row.Parch > 2 or row.SexPlus == \"man\" or row.SexPlus == \"woman\":\n            process_as = \"adult\"\n            \n        #handful of annoying edge cases with < 16 years old married girls...\n        if row.SibSp == 1 and row.Parch == 0 and row.Title == \"Mrs\" and row.SexPlus == \"girl\":\n            process_as = \"adult\"\n\n        if process_as == \"child\":\n            df.loc[index, \"Parents\"] = row.Parch\n            df.loc[index, \"Siblings\"] = row.SibSp\n            \n            if row.SexPlus == \"\":\n                #if we don't have an age so haven't set a SexPlus we can do it here\n                if row.Sex == \"male\":\n                    df.loc[index, \"SexPlus\"] = \"boy\"\n                else:\n                    df.loc[index, \"SexPlus\"] = \"girl\"\n        elif process_as == \"adult\":\n            df.loc[index, \"Spouse\"] = row.SibSp\n            df.loc[index, \"Children\"] = row.Parch\n            \n            if row.Sex == \"male\":\n                df.loc[index, \"SexPlus\"] = \"man\"\n            else:\n                df.loc[index, \"SexPlus\"] = \"woman\"\n\n        df.loc[index, \"FamilySize\"] = (1 + row.Parch + row.SibSp)      \n    \ndef ProcessMissingAges(cln):\n###############################################################################################\n# process the rows with missing ages using medians of the 80% which do have Age set\n# -- must be called after ProcessTitles() and ProcessSexPlus()\n###############################################################################################\n    df = cln.data\n\n    #originally i used median ages for man\/woman\/boy\/girl for the missing age values but after plotting it\n    #became clear that these were different across passenger classes so now i use the median from each class\n\n    for i in range(1,4):\n        median_man   = statistics.median(df.loc[(df.Pclass == i) & (df.Age.isnull() == False) & (df.SexPlus == \"man\") , \"Age\"])\n        median_boy   = statistics.median(df.loc[(df.Pclass == i) & (df.Age.isnull() == False) & (df.SexPlus == \"boy\") , \"Age\"])\n        median_woman = statistics.median(df.loc[(df.Pclass == i) & (df.Age.isnull() == False) & (df.SexPlus == \"woman\"), \"Age\"])\n        median_girl  = statistics.median(df.loc[(df.Pclass == i) & (df.Age.isnull() == False) & (df.SexPlus == \"girl\") , \"Age\"])\n\n        df.loc[(df.Pclass == i) & (df.Age.isnull()) & (df.SexPlus == \"man\"), [\"Age\"]] = median_man\n        df.loc[(df.Pclass == i) & (df.Age.isnull()) & (df.SexPlus == \"woman\"), [\"Age\"]] = median_woman\n        df.loc[(df.Pclass == i) & (df.Age.isnull()) & (df.SexPlus == \"boy\"), [\"Age\"]] = median_boy\n        df.loc[(df.Pclass == i) & (df.Age.isnull()) & (df.SexPlus == \"girl\"), [\"Age\"]] = median_girl\n        \ndef ProcessFarePerPerson(cln):\n###############################################################################################\n# calculate fare per person based on the number of people on the ticket\n###############################################################################################\n    cln.SetMissingValues(\"Fare\", 0)\n    df = cln.data\n    tickets_count = df.groupby(\"Ticket\")[\"Ticket\"].count()\n            \n    for ticket_number in tickets_count.keys():\n        fpp = df.loc[df.Ticket == ticket_number, \"Fare\"] \/ tickets_count[ticket_number]\n        df.loc[df.Ticket == ticket_number, \"FarePerPerson\"] = fpp\n        \ndef ProcessBins(cln):\n###############################################################################################\n# bin age and fare\n###############################################################################################\n    cln.data[\"FareBin\"] = pd.qcut(cln.data.FarePerPerson, 4, labels=[1, 2, 3, 4])\n    cln.data[\"AgeBin\"] = pd.qcut(cln.data.Age, 5, labels=[1, 2, 3, 4, 5])\n    cln.data.AgeBin = cln.data.AgeBin.astype(\"int64\")\n    cln.data.FareBin = cln.data.FareBin.astype(\"int64\")","54c7c6a6":"###############################################################################################\n# run preprocessing\n###############################################################################################\n\ndef Clean(file1, file2):\n###############################################################################################\n# load the data and add our new cols \n###############################################################################################\n    cln = joe.DataCleaner(file1)\n    cln.Concat(file2)    \n\n    cln.AddColumn(\"Title\", \"\")\n    cln.AddColumn(\"Noble\", 0)\n    cln.AddColumn(\"SexPlus\", \"\")\n    cln.AddColumn(\"Spouse\", 0)\n    cln.AddColumn(\"Children\", 0)\n    cln.AddColumn(\"Parents\", 0)\n    cln.AddColumn(\"Siblings\", 0)\n    cln.AddColumn(\"FamilySize\", 0)\n    cln.AddColumn(\"FarePerPerson\", 0)\n\n    ProcessTitles(cln)\n    ProcessNobles(cln)\n    ProcessSexPlus(cln)\n    ProcessFamilies(cln)\n    ProcessMissingAges(cln)\n    ProcessFarePerPerson(cln)\n    ProcessBins(cln)\n    \n    return cln.data\n\ndf_all = Clean(\"\/kaggle\/input\/titanic\/train.csv\", \"\/kaggle\/input\/titanic\/test.csv\")\n\n###############################################################################################\n# set up dataframe slices for some plotting\n###############################################################################################\ndf_train = df_all.loc[df_all.Survived.isnull() == False]\ndf_test = df_all.loc[df_all.Survived.isnull() == True]\n\ndf_male = df_train.loc[df_train.Sex == \"male\"]\ndf_female = df_train.loc[df_train.Sex == \"female\"]\n\ndf_men = df_train.loc[df_train.SexPlus == \"man\"]\ndf_women = df_train.loc[df_train.SexPlus == \"woman\"]\ndf_children = df_train.loc[(df_train.SexPlus == \"boy\") | (df_train.SexPlus == \"girl\")]\ndf_boys = df_train.loc[df_train.SexPlus == \"boy\"]\ndf_girls = df_train.loc[df_train.SexPlus == \"girl\"]\n\ndf_1st = df_train.loc[df_train.Pclass == 1]\ndf_2nd = df_train.loc[df_train.Pclass == 2]\ndf_3rd = df_train.loc[df_train.Pclass == 3]\n\ndf_s = df_train.loc[df_train.Embarked == \"S\"]\ndf_c = df_train.loc[df_train.Embarked == \"C\"]\ndf_q = df_train.loc[df_train.Embarked == \"Q\"]","949aae34":"def FmtPcnt(num, den, rnd=1):\n###############################################################################################\n# format a percentage string\n###############################################################################################\n        return str(round((num \/ den * 100), rnd)) + \"%\"\n\ndef DrawDSHist(df, title, **kwargs):\n###############################################################################################\n# draw a single died\/survived histogram\n###############################################################################################\n    ntotal = len(df)\n    ndied = len(df.loc[df.Survived == 0])\n    nsurvived = ntotal - ndied\n    sdied = \"Died (\" + FmtPcnt(ndied, ntotal) + \")\"\n    ssurvived = \"Survived (\" + FmtPcnt(nsurvived, ntotal) + \")\"\n    \n    t = title + \" (\" + str(len(df)) + \" total)\"\n    joe.Plotting(df).CountPlot(\"Survived\", t, tick_locations=[0,1], tick_labels=[sdied, ssurvived], **kwargs)\n\ndef DrawDSFacetGrid(df, col, title):\n###############################################################################################\n# draw a died\/survived facetgrid\n###############################################################################################\n    joe.Plotting(df).FacetGrid(None, \"Survived\", col, sns.distplot, title=title, kde=False, bins=[0,1,2])\n\ndef DrawAgeRegFacetGrid(df, col, title):\n###############################################################################################\n# draw a died\/survived facetgrid\n###############################################################################################\n    joe.Plotting(df).FacetGrid(\"Age\", \"Survived\", col, sns.regplot, title=title, logistic=True, ci=None, line_kws={'color':'orange'})\n    \ndef DrawPredictedSurvival(df, col, title):\n###############################################################################################\n# draw a logistic regression curve to predict survival by col\n###############################################################################################\n    joe.Plotting(df).RegressionPlot(col, \"Survived\", title=title, logistic=True, ci=None)","312935ad":"#temp hack until i fix my plotting wrapper\nos.mkdir(\"\/kaggle\/working\/plots\")","937758d1":"DrawDSHist(df_train, \"All\")\nDrawDSHist(df_train, \"All by Sex\", hue=\"Sex\")\nDrawDSHist(df_train, \"All by Class\", hue=\"Pclass\")\nDrawDSHist(df_train, \"All by SexPlus\", hue=\"SexPlus\", hue_order=[\"man\", \"woman\", \"boy\", \"girl\"])\nDrawDSHist(df_1st, \"1st class by SexPlus\", hue=\"SexPlus\", hue_order=[\"man\", \"woman\", \"boy\", \"girl\"])\nDrawDSHist(df_2nd, \"2nd class by SexPlus\", hue=\"SexPlus\", hue_order=[\"man\", \"woman\", \"boy\", \"girl\"])\nDrawDSHist(df_3rd, \"3rd class by SexPlus\", hue=\"SexPlus\", hue_order=[\"man\", \"woman\", \"boy\", \"girl\"])","6a036dc9":"joe.Plotting(df_train).BoxPlot(x=\"Pclass\", y=\"Age\", title=\"All by Pclass\")\n#joe.Plotting(df_1st).BoxPlot(x=\"SexPlus\", y=\"Age\", order=[\"man\",\"woman\",\"boy\",\"girl\"], title=\"1st by SexPlus\")\n#joe.Plotting(df_2nd).BoxPlot(x=\"SexPlus\", y=\"Age\", order=[\"man\",\"woman\",\"boy\",\"girl\"], title=\"2nd by SexPlus\")\n#joe.Plotting(df_3rd).BoxPlot(x=\"SexPlus\", y=\"Age\", order=[\"man\",\"woman\",\"boy\",\"girl\"], title=\"3rd by SexPlus\")","6f0aa8c7":"DrawPredictedSurvival(df_men, \"Age\", \"Men\")\nDrawPredictedSurvival(df_women, \"Age\", \"Women\")\nDrawPredictedSurvival(df_boys, \"Age\", \"Boys\")\nDrawPredictedSurvival(df_girls, \"Age\", \"Girls\")\n\nDrawPredictedSurvival(df_1st, \"Age\", \"1st Class\")\nDrawPredictedSurvival(df_2nd, \"Age\", \"2nd Class\")\nDrawPredictedSurvival(df_3rd, \"Age\", \"3rd Class\")","e118798b":"DrawDSHist(df_train, \"All by AgeBin\", hue=\"AgeBin\")\nDrawDSHist(df_train, \"All by FareBin\", hue=\"FareBin\")","4a26cf84":"#S = Southampton\n#C = Cherbourg (France)\n#Q = Queenstown (Ireland)\n\nDrawDSHist(df_train, \"All by Embarked\", hue=\"Embarked\")\nDrawDSHist(df_train, \"All by Pclass\", hue=\"Pclass\")\nDrawDSHist(df_s, \"Southampton by Pclass\", hue=\"Pclass\")\nDrawDSHist(df_c, \"Cherbourg by Pclass\", hue=\"Pclass\")\nDrawDSHist(df_q, \"Queenstown by Pclass\", hue=\"Pclass\")\n\ndf.groupby([\"Embarked\", \"Pclass\"])[\"Embarked\"].count()","3f8d3670":"DrawPredictedSurvival(df_men, \"FamilySize\", \"Family Size (Men)\")\nDrawPredictedSurvival(df_women, \"FamilySize\", \"Family Size (Women)\")\nDrawPredictedSurvival(df_boys, \"FamilySize\", \"Family Size (Boys)\")\nDrawPredictedSurvival(df_girls, \"FamilySize\", \"Family Size (Girls)\")","d1578ba3":"from sklearn.model_selection import KFold, cross_val_score, train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.compose import ColumnTransformer\n\ndef CreateModel(x):\n###############################################################################################\n# create the model pipeline\n###############################################################################################\n    num_features = x.select_dtypes(include='number').columns.to_list()\n    cat_features = x.select_dtypes(include='object').columns.to_list()\n\n    num_pipe = Pipeline([\n        ('imputer', SimpleImputer(strategy='median')),\n        ('poly',PolynomialFeatures(degree=2)),\n        ('scaler', StandardScaler())\n    ])\n    \n    cat_pipe = Pipeline([\n        ('imputer', SimpleImputer(strategy='most_frequent')),\n        ('coder', OneHotEncoder(handle_unknown='ignore'))\n    ])\n\n    ctr = ColumnTransformer(remainder='drop',\n        transformers=[\n        ('numerical', num_pipe, num_features),\n        ('categorical', cat_pipe, cat_features)\n    ])\n\n    model = Pipeline([\n        ('transformer', ctr),\n        ('predictor', RandomForestClassifier(n_jobs=1,random_state=0))\n    ])\n    \n    return model\n\ndef TestModel(data):\n###############################################################################################\n# test the model with a train\/test split and a k-fold cv\n###############################################################################################\n    md = joe.DataCleaner(data.copy())\n    y = md.data[\"Survived\"]\n    md.DropColumns(\"Survived\")\n    x = md.data\n\n    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=456)\n    \n    model = CreateModel(x_train)\n    model.fit(x_train, y_train)\n    \n    #score...\n    print(\"------------------------------------\")\n    print(\"Default score: \", model.score(x_train, y_train))\n    kfold = KFold(n_splits=10, shuffle=True)\n    kf_cv_scores = cross_val_score(model, x_train, y_train, cv=kfold)\n    print(\"KFold average: %.2f\" % kf_cv_scores.mean())\n    print(\"------------------------------------\")\n    print(\"\")\n    \ndef GetPredictions(df_train, df_test):\n###############################################################################################\n# run the model and get the predictions\n###############################################################################################\n    trn = joe.DataCleaner(df_train.copy())\n    y = trn.data[\"Survived\"]\n    trn.DropColumns(\"Survived\")\n    x = trn.data\n    \n    model = CreateModel(x)\n    model.fit(x, y)\n\n    tst = joe.DataCleaner(df_test.copy())\n    tst.DropColumns(\"Survived\")\n    x = tst.data\n    \n    pred_values = model.predict(x)\n    \n    tst.data[\"PassengerId\"] = df_test.PassengerId\n    tst.data[\"Survived\"] = pred_values\n    tst.data.Survived = tst.data.Survived.apply(round)\n    \n    return tst.data\n\ndef ModifyDF(df):\n###############################################################################################\n# modify a df for modelling\n###############################################################################################\n    tst = joe.DataCleaner(df.copy())    \n    tst.DropColumns([\"Name\", \"Age\", \"SibSp\", \"Parch\", \"Ticket\", \"Fare\", \"Cabin\", \"Embarked\", \"Title\", \"Noble\", \"Spouse\", \"Children\", \"Parents\", \"Siblings\"])    \n    \n    return tst.data","17d2b052":"###############################################################################################\n# split class model - test \/ create submission\n# i thought doing each Pclass seperately might be better but it didn't work :(\n###############################################################################################\nmod_train_1st = ModifyDF(df_1st)\nmod_train_2nd = ModifyDF(df_2nd)\nmod_train_3rd = ModifyDF(df_3rd)\n\nmod_test_1st = ModifyDF(df_test.loc[df_test.Pclass == 1])\nmod_test_2nd = ModifyDF(df_test.loc[df_test.Pclass == 2])\nmod_test_3rd = ModifyDF(df_test.loc[df_test.Pclass == 3])\n\nprint(\"1st class\")\nTestModel(mod_train_1st) \nprint(\"2nd class\")\nTestModel(mod_train_2nd) \nprint(\"3rd class\")\nTestModel(mod_train_3rd)\n\n#sub_1st = GetPredictions(mod_train_1st, mod_test_1st, mod_cols_1st)\n#sub_2nd = GetPredictions(mod_train_2nd, mod_test_2nd, mod_cols_2nd)\n#sub_3rd = GetPredictions(mod_train_3rd, mod_test_3rd, mod_cols_3rd)\n\n#df_submission = pd.concat([sub_1st, sub_2nd, sub_3rd], ignore_index=True)\n#df_submission.reset_index(drop=True)\n#df_submission = pd.DataFrame(df_submission, columns=[\"PassengerId\", \"Survived\"])\n#df_submission.to_csv(\"submission.csv\", index=False)","68526869":"###############################################################################################\n# single model - test \/ create submission\n###############################################################################################\nmod_train = ModifyDF(df_train)\nmod_test = ModifyDF(df_test)\n\nTestModel(mod_train) \n\ndf_submission = GetPredictions(mod_train, mod_test)\ndf_submission = pd.DataFrame(df_submission, columns=[\"PassengerId\", \"Survived\"])\ndf_submission.to_csv(\"submission.csv\", index=False)","36469a52":"## Age by Pclass\n\nA quick look at age across passenger classes shows us that the wealthier upper class passengers tended to be older. Splitting it further shows quite clearly that I need to go back to the data cleaning code where I use median ages for passengers with Age=Null and do a better job using their Pclass as well.\n\nI'm also looking at the number of male outliers at the higher end of the data (2nd and 3rd class) and I'm wondering if mean age would be better than median. I may just need to try both and see what results in a better model.","f93bbd4d":"## Some basic died\/survived plots\n\n1st and 2nd class women and children did well. 3rd class did generally badly.\n\nIf we look at the difference between the SexPlus plot and the subsequent SexPlus plots for each passenger class, we can already see that the combination of SexPlus and PClass are important.\n\nIf you look at boys and girls, there is a significant difference. We'll be treating them seperately as it seems \"children\" is too broad to be useful.","69ade119":"# Data Cleaning\n\nThe data we have is a bit of a mess. Clearly this is on purpose and part of the point of this beginners competition is to make us work to clean it up and engineer useful information out of it.\n\nThe first thing we do here is extract the titles from the passenger names and add it to a Title column.\n\nThe next thing we do is set a flag called Noble which is set to 1 for people with nobility\/aristocracy titles.\n\nNext we add a column called SexPlus. I expect want to be able to explore the data and play with models using man\/woman\/boy\/girl instead of just male\/female so we add those here. It also helps in a second to process missing ages.\n\nThe data has a SibSp column for the number of siblings\/spouses the passenger is travelling with, and Parch for parents\/children. This is clearly unhelpful at least for exploring the data (we'll see about modeling later) so we split this back into 4 new columns: Spouse\/Children\/Parents\/Siblings. We also add a FamilySize column. While were here, we add SexPlus to passengers who have Age=Null if we can figure out what they are through SibSp and Parch.\n\nAbout 20% of the data is missing Age. We use median ages for each SexPlus group for the missing data. At the moment Miss and Mlle are assumed to be girls which is a bit lazy tbh. What I should actually do is look at the percentage of Miss\/Mlle with Age data who are actually children (vs unmarried women) then split the nulls between girl and woman according to that percentage.","4a3f606a":"## Survival rates in larger families","3c4add75":"## AgeBin and FareBin\n\nI'm not having a great deal of fun getting much mileage out of Fare and Age but binning them seems to be the best I can do so far","abbf5cab":"# Modeling\n\nI messed around with trying 3 seperate models (by Pclass) to see if I could get better results. I didn't.\n\nAfter much messing around I am currently using a RandomForestClassifier and I'm hitting about 75% accuracy.","800ac720":"## Survival rates by age","25ce90f1":"## Cabin numbers\n\nThese are useless.\n\nThe only information you can gain from these is the deck that the cabin was on. Some decks had cabins only for certain classes, while some had accomodation for more than one:\n\nDeck A: 1st\\\nDeck B: 1st\\\nDeck C: 1st\\\nDeck D: 1st 2nd 3rd\\\nDeck E: 1st 2nd 3rd\\\nDeck F: 2nd 3rd\\\nDeck G: 3rd\n\nWe already know Pclass for each passenger and 77% of cabin numbers are missing so any hope of doing anything useful with them ends here.","aad5898e":"## Embarked\n\nWhen we look at Embarked, at first glance it looks interesting, a much higher percentage of people embarking in Southampton died, but when you split the passengers from each port by Pclass, the results don't look vastly different then the combined Pclass split from all ports. It appears that this is nothing more than the Pclass of the passengers getting on at each port, so will already be dealt with by Pclass. Embarked will be dropped from the model.","f4cc17a0":"# Plotting \/ Exploring\n\nI've divided the data into datasets I expect to be significant to make the exploration quicker and easier.\n\n- male\/female\n- men\/women\/children\/boys\/girls\n- 1st\/2nd\/3rd (class)\n- s\/c\/q (embarkation ports)"}}