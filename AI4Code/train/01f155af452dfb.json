{"cell_type":{"df7a1e43":"code","2abb902a":"code","637fcbae":"code","66435615":"code","59c41258":"code","85fc037a":"code","200a0fc4":"code","aab29f8e":"code","553aaedb":"code","36e775c1":"code","e9c3ab9c":"code","e1bbf28b":"code","cbe1f39d":"code","644de251":"code","4426349c":"code","dcfff64a":"code","1bb12b00":"code","de0f9e0b":"code","e267e92e":"code","16e85f99":"code","9d5018de":"code","f44c5add":"code","93ac4f0e":"code","dc0f7a00":"code","e0a34155":"code","084164a4":"code","6b24ec02":"code","17141ae1":"code","5dba751a":"code","90e64aa3":"code","30c7db40":"code","a93e9f37":"code","de426568":"code","ad7702f3":"code","3afecc08":"code","a85c5591":"code","4bbec6c4":"code","28ae036b":"code","aad5e539":"code","18386a31":"code","bc049b3e":"code","0e0b2b81":"code","34fbdc0e":"code","046e26c7":"code","eaf0f416":"code","eeabe81f":"code","9a6fe74d":"code","e8d7a393":"code","b71eed68":"code","fad52460":"code","9d32280a":"code","91dad63b":"code","074aaa56":"code","dd1d073f":"code","d671f651":"code","a68c883d":"code","166dcf1b":"code","037d1af8":"code","90bcc563":"code","809880fc":"code","d0dfb4e8":"code","eb19158a":"code","b013dbcd":"code","95f8266c":"code","b0a1ec4a":"code","d7b3ad81":"code","87475495":"code","94bb0ed1":"code","35267d96":"code","3016b276":"code","bb317851":"code","82f4025e":"code","acfefaaf":"markdown","0ddccec7":"markdown","62de014f":"markdown","1ed77429":"markdown","9ddb0a46":"markdown","5626260a":"markdown","ea8d9d15":"markdown","df66b829":"markdown","24562efb":"markdown","ce481be9":"markdown","843ec4ea":"markdown","9d02c26f":"markdown","d7325b8b":"markdown","21027f39":"markdown","b6c3b720":"markdown","3da7e5da":"markdown","4d189062":"markdown","06c15f7f":"markdown","5a61b50b":"markdown","d0596611":"markdown","2fd33a50":"markdown","e3c04c3d":"markdown","3229ba3e":"markdown","fa69b4ee":"markdown","9ee71ac4":"markdown","7b903664":"markdown","4562a890":"markdown","83c6999a":"markdown","14e51d6c":"markdown","c695823c":"markdown","87b3ac96":"markdown","f5cbbcd5":"markdown","7957f8c5":"markdown","3a80420b":"markdown","2eff2043":"markdown","095dbdc5":"markdown","32d0d42b":"markdown","948235b7":"markdown","58bdcc5a":"markdown","7570ea24":"markdown"},"source":{"df7a1e43":"country_main = 'Ukraine'\nrolling_window = False","2abb902a":"import os\nimport io\nimport pandas as pd\nimport numpy as np\nimport requests\nimport seaborn as sns\nimport openpyxl\nimport matplotlib\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\n\nfrom datetime import date, timedelta, datetime\nfrom fbprophet import Prophet\nfrom fbprophet.make_holidays import make_holidays_df\nfrom fbprophet.diagnostics import cross_validation, performance_metrics\nfrom fbprophet.plot import plot_cross_validation_metric\nimport holidays\nfrom collections import Counter\nimport pycountry\n\nfrom PIL import Image\nfrom IPython.display import FileLink\n\nimport warnings\nwarnings.simplefilter('ignore')","637fcbae":"# Thanks https:\/\/api-covid19.rnbo.gov.ua\/\nfor filename in ['main-data?mode=ukraine&fbclid=IwAR1vNXEE0nkmorUmGP4StG4cLrj1Z9VoX3c3Bi8dfltr0elgOj4b0M3ONvk']:\n    print(f'Download daily data from RNBO of Ukraine')\n    url = f'https:\/\/api-covid19.rnbo.gov.ua\/charts\/{filename}'\n    myfile = requests.get(url)\n    open(filename, 'wb').write(myfile.content)\n    \ndata = pd.read_json('main-data?mode=ukraine&fbclid=IwAR1vNXEE0nkmorUmGP4StG4cLrj1Z9VoX3c3Bi8dfltr0elgOj4b0M3ONvk')\ndata","66435615":"data['n_confirmed'] = data['confirmed'].diff()\ndata = data[166:].reset_index(drop=True)\ndata['n_confirmed'] = data['n_confirmed'].astype('int')\ndata","59c41258":"data['n_confirmed'].plot()","85fc037a":"df2 = data[['dates','n_confirmed']].dropna()\ndf2 = df2[df2['n_confirmed'] > 0].reset_index(drop=True)\ndf2['n_confirmed'].plot()","200a0fc4":"if rolling_window:\n    df2['n_confirmed'] = df2['n_confirmed'].rolling(7).mean()\n    df2['n_confirmed'].plot()","aab29f8e":"# As in my original notebook https:\/\/www.kaggle.com\/vbmokin\/covid-19-in-ukraine-prophet-holidays-tuning\ndf2.columns = ['Date', 'Confirmed']\ndf2['Country'] = 'Ukraine'","553aaedb":"# The new data (probable value)\nn = len(df2)\ndf2.loc[n, 'Date'] = '2020-12-07'\ndf2.loc[n, 'Confirmed'] = 8641\ndf2.loc[n, 'Country'] = 'Ukraine'","36e775c1":"latest_date = df2['Date'].max()\nlatest_date","e9c3ab9c":"df2.tail(5)","e1bbf28b":"df2.info()","cbe1f39d":"tests = pd.read_csv('..\/input\/covid19-in-ukraine-daily-data\/tests_number_06_12.csv', sep=';')\ntests['date'] = pd.to_datetime(tests['date'], format='%d.%m.%Y', errors='ignore')\n# Add 1 day as in confirmed cases data\n#tests['date'] = tests['date'].apply(lambda x: (x + timedelta(days=1)).strftime('%Y-%m-%d'))\ntests['date'] = tests['date'].apply(lambda x: (x + timedelta(days=1)).strftime('%Y-%m-%d'))\ntests","644de251":"tests0 = tests.copy()\ntests.columns = ['ds','y']\ntests","4426349c":"# Thanks to dataset https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries\nholidays_df = pd.read_csv('..\/input\/covid19-holidays-of-countries\/holidays_df_of_70_countries_for_covid_19.csv')\nholidays_df[holidays_df['country'] == country_main]","dcfff64a":"holidays_df_code_countries = holidays_df['code'].unique()\nholidays_df_code_countries","1bb12b00":"# From notebook https:\/\/www.kaggle.com\/vbmokin\/covid-19-prophet-forecast-next-2-weeks\ndef dict_code_countries_with_holidays(list_name_countries: list,\n                                      holidays_df: pd.DataFrame()):\n        \n    \"\"\"\n    Defines a dictionary with the names of user countries and their two-letter codes (ISO 3166) \n    in the dataset \"COVID-19: Holidays of countries\" \n    \n    Returns: \n    - countries: dictionary with the names of user countries and their two-letter codes (ISO 3166) \n    - holidays_df_identificated: DataFrame with holidays data for countries from dictionary 'countries'\n    \n    Args: \n    - list_name_countries: list of the name of countries (name or common_name or official_name or alha2 or alpha3 codes from ISO 3166)\n    - holidays_df: DataFrame with holidays \"COVID-19: Holidays of countries\"\n    \"\"\"\n    \n    import pycountry\n    \n    # Identification of countries for which there are names according to ISO\n    countries = {}\n    dataset_all_countries = list(holidays_df['code'].unique())\n    list_name_countries_identificated = []\n    list_name_countries_not_identificated = []\n    for country in list_name_countries:\n        try: \n            country_id = pycountry.countries.get(alpha_2=country)\n            if country_id.alpha_2 in dataset_all_countries:\n                countries[country] = country_id.alpha_2\n        except AttributeError:\n            try: \n                country_id = pycountry.countries.get(name=country)\n                if country_id.alpha_2 in dataset_all_countries:\n                    countries[country] = country_id.alpha_2\n            except AttributeError:\n                try: \n                    country_id = pycountry.countries.get(official_name=country)\n                    if country_id.alpha_2 in dataset_all_countries:\n                        countries[country] = country_id.alpha_2\n                except AttributeError:\n                    try: \n                        country_id = pycountry.countries.get(common_name=country)\n                        if country_id.alpha_2 in dataset_all_countries:\n                            countries[country] = country_id.alpha_2\n                    except AttributeError:\n                        try: \n                            country_id = pycountry.countries.get(alpha_3=country)\n                            if country_id.alpha_2 in dataset_all_countries:\n                                countries[country] = country_id.alpha_2\n                        except AttributeError:\n                            list_name_countries_not_identificated.append(country)\n    holidays_df_identificated = holidays_df[holidays_df['code'].isin(countries.values())]\n    \n    print(f'Thus, the dataset has holidays in {len(countries)} countries from your list with {len(list_name_countries)} countries')\n#     if len(countries) == len(dataset_all_countries):\n#         print('All available in this dataset holiday data is used')\n#     else:\n#         print(\"Holidays are available in the dataset for such countries (if there are countries from your list, then it's recommended making changes to the list)\")\n#         print(np.array(holidays_df[~holidays_df['code'].isin(countries.values())].country_official_name.unique()))\n        \n    return countries, holidays_df_identificated.reset_index(drop=True)","de0f9e0b":"countries_dict, holidays_df_base = dict_code_countries_with_holidays([country_main],holidays_df)\ncountries_dict","e267e92e":"holidays_df_base['type'] = 'holiday'\nholidays_df = holidays_df_base.copy()\nholidays_df","16e85f99":"# From https:\/\/www.kaggle.com\/vbmokin\/covid-19-prophet-forecast-next-2-weeks\ndef adaption_df_to_holidays_df_for_prophet(df, col, countries_dict):\n    # Adaptation the dataframe df (by column=col) to holidays_df by list of countries in dictionary countries_dict\n    \n    # Filter df for countries which there are in the dataset with holidays\n    df = df[df[col].isin(list(countries_dict.keys()))].reset_index(drop=True)\n    \n    # Add alpha_2 (code from ISO 3166) for each country\n    df['iso_alpha'] = None\n    for key, value in countries_dict.items():\n        df.loc[df[col] == key, 'iso_alpha'] = value    \n    \n    return df","9d5018de":"df2 = adaption_df_to_holidays_df_for_prophet(df2, 'Country', countries_dict)\ndf2.columns = ['Date', 'Confirmed', 'Country', 'iso_alpha']\ndf2","f44c5add":"country_iso_alpha = df2.loc[0,'iso_alpha']\ncountry_iso_alpha","93ac4f0e":"def aux_holidays_df_generator(holidays_df, dates_list, name, source, window_size, shift7=True):\n    # Add dates from dates_list with anomalies of various kinds to the holiday dataset holidays_df\n    # name - the name of the anomaly\n    # source - the source of the primary information used for processing\n    \n    last_row = len(holidays_df)\n    if shift7:\n        holidays_dates = holidays_df['ds_holidays'].tolist()\n    else: holidays_dates = holidays_df['ds'].tolist()\n    common_dates = list(set(holidays_dates).intersection(set(dates_list)))\n    dates_list = list(set(dates_list).difference(set(common_dates)))\n        \n    for i in range(len(dates_list)):\n        holidays_df = holidays_df.append([holidays_df.loc[last_row-1,:]], ignore_index=True)\n        ds_dt = datetime.strptime(dates_list[i], '%Y-%m-%d')\n        holidays_df.loc[last_row+i, 'ds_holidays'] = dates_list[i]\n        holidays_df.loc[last_row+i, 'holiday'] = name\n        \n        if shift7:\n            # Make shift with 7 day ahead\n            holidays_df.loc[last_row+i, 'ds'] = (ds_dt + timedelta(days=7)).strftime('%Y-%m-%d')\n        else:\n            # Don't make shift with 7 day ahead\n            holidays_df.loc[last_row+i, 'ds'] = ds_dt.strftime('%Y-%m-%d')\n            \n        holidays_df.loc[last_row+i, 'source'] = source\n        holidays_df.loc[last_row+i, 'lower_window'] = -window_size\n        holidays_df.loc[last_row+i, 'upper_window'] = window_size\n    \n        # Type of holidays or pseudo-holidays\n        if name == 'the weakening of quarantine':\n            holidays_df.loc[last_row+i, 'type'] = 'SI'\n        elif name == 'Very comfortable conditions for rest':\n            holidays_df.loc[last_row+i, 'type'] = 'meteo'\n        elif name == 'Holidays as days of less efficient work of laboratories':\n            holidays_df.loc[last_row+i, 'type'] = 'lab'\n        elif name == 'Weekend quarantine as holidays':\n            holidays_df.loc[last_row+i, 'type'] = 'weekend'\n    \n    holidays_df[holidays_df['ds_holidays'].isin(dates_list)]['lower_window'] = -window_size\n    holidays_df[holidays_df['ds_holidays'].isin(dates_list)]['upper_window'] = window_size\n        \n    return holidays_df.sort_values(by=['ds'])","dc0f7a00":"def plot_with_anomalies(df, cols_y_list, cols_y_list_name, dates_x, col_anomalies, val_anomal, log_y=False):\n    # Draws a plot with title - the features cols_y_list (y) and dates_x (x) from the dataframe df\n    # and with vertical lines in the date with col_anomalies == 1 \n    # with the length between the minimum and maximum of feature cols_y_list[0]\n    # with log_y = False or True\n    # cols_y_list - dictionary of the names of cols from cols_y_list (keys - name of feature, value - it's name for the plot legend), \n    # name of cols_y_list[0] is the title of the all plot\n    \n    fig = px.line(df, x=dates_x, y=cols_y_list[0], title=cols_y_list_name[cols_y_list[0]], log_y=log_y, template='gridon',width=700, height=800)\n    y_max = df[cols_y_list[0]].max()\n    for i in range(len(cols_y_list)-1):\n        fig.add_trace(go.Scatter(x=df[dates_x], y=df[cols_y_list[i+1]], mode='lines', name=cols_y_list_name[cols_y_list[i+1]]))\n        max_i = df[cols_y_list[i+1]].max()\n        y_max = max_i if max_i > y_max else y_max\n    \n    anomal_dates_list = df[df[col_anomalies] == val_anomal][dates_x].tolist()\n    y_min = min(df[cols_y_list[0]].min(),0)\n    for i in range(len(anomal_dates_list)):\n        anomal_date = anomal_dates_list[i]\n        fig.add_shape(dict(type=\"line\", x0=anomal_date, y0=y_min, x1=anomal_date, y1=y_max, line=dict(color=\"red\", width=1)))\n    fig.show()","e0a34155":"# Thank to https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data\ndata = pd.read_csv(f\"https:\/\/storage.googleapis.com\/covid19-open-data\/v2\/UA\/main.csv\")","084164a4":"data['stringency_index_jump'] = 0\nfor i in range(len(data)-1):\n    if (data.loc[i+1,'stringency_index'] is not None) and (data.loc[i,'stringency_index'] is not None) and (data.loc[i+1,'stringency_index'] < data.loc[i,'stringency_index']):\n        data.loc[i+1, 'stringency_index_jump'] = 1\nsource_gov = 'https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker'\ndates_gov_list = data[data['stringency_index_jump'] == 1]['date'].tolist()\nholidays_df = aux_holidays_df_generator(holidays_df, dates_gov_list, 'the weakening of quarantine', source_gov, 2)\nplot_with_anomalies(data, [\"stringency_index\"], {\"stringency_index\" : \"Stringency index and dates of the weakening of quarantine in \" + country_main}, 'date', 'stringency_index_jump', 1)","6b24ec02":"data.columns.tolist()","17141ae1":"data['rest_comfort'] = 0\ndata.loc[(data['average_temperature'] >= data['average_temperature'].quantile(.95)) & (data['rainfall'] <= data['rainfall'].quantile(.05)), 'rest_comfort'] = 1\ndates_weather_list = data[data['rest_comfort'] == 1]['date'].tolist()\nholidays_df = aux_holidays_df_generator(holidays_df, dates_weather_list, 'Very comfortable conditions for rest', 'https:\/\/www.ncei.noaa.gov\/', 2)\nplot_with_anomalies(data, [\"average_temperature\", \"rainfall\"], {\"average_temperature\" : \"Average temperature over time in \" + country_main, \"rainfall\" : \"rainfall\"}, 'date', 'rest_comfort', 1)","5dba751a":"df2.info()","90e64aa3":"holidays_dates = holidays_df_base['ds_holidays'].tolist()\nholidays_dates","30c7db40":"data['holidays_date'] = 0\nholidays_df = aux_holidays_df_generator(holidays_df, holidays_dates, 'Holidays as days of less efficient work of laboratories', \n                                        'https:\/\/github.com\/dr-prodigy\/python-holidays', 0, False)\nholidays_df","a93e9f37":"#holidays_weekend_quarantine = ['2020-11-21', '2020-11-22']","de426568":"# data['holidays_date'] = 0\n# holidays_df = aux_holidays_df_generator(holidays_df, holidays_weekend_quarantine, 'Weekend quarantine as holidays', \n#                                         'https:\/\/www.kmu.gov.ua\/', 0, False)\n# holidays_df","ad7702f3":"# pd.set_option('max_rows', 300)\n# df2","3afecc08":"fig = px.line(df2, x=\"Date\", y=\"Confirmed\", \n              title=\"Confirmed cases in \" + country_main, \n              log_y=False,template='gridon',width=700, height=600)\nfig.show()","a85c5591":"fig = px.line(df2, x=\"Date\", y=\"Confirmed\", \n              title=\"Confirmed cases (logarithmic scale) in \" + country_main, \n              log_y=True,template='gridon',width=700, height=600)\nfig.show()","4bbec6c4":"df2['holiday'] = 0\nholidays_df_dates = holidays_df['ds'].tolist()\ndf2.loc[df2['Date'].isin(holidays_df_dates), 'holiday'] = 1\nplot_with_anomalies(df2, [\"Confirmed\"], {\"Confirmed\" : \"Confirmed cases and holidays data in \" + country_main}, 'Date', 'holiday', 1)\ndf2 = df2.drop(columns=['holiday'])","28ae036b":"holidays_df_dates","aad5e539":"df2.describe()","18386a31":"df2.head()","bc049b3e":"df2.tail()","0e0b2b81":"# For stage 1 of tuning\nchangepoint_prior_scale_initial_level = 0.15\nweekly_season_reg_coef = 1.25\nlower_window_list = [0, -1, -2, -3] # must be exactly 4 values (identical allowed)\nupper_window_list = [0, 1, 2, 3] # must be exactly 4 values (identical allowed)\nprior_scale_list = [1.5, 2, 2.5, 3] # must be exactly 4 values (identical allowed)\nholidays_adaptive = ['holiday', 'SI', 'meteo'] # holidays with adaptive window\n\n# For stage 2 of tuning\nseveral_days_period = 4\nseveral_days_season_reg_coef = 2\nchangepoint_prior_scale_list = [0.15, 0.2, 0.25, 0.3] # must be exactly 4 values (identical allowed)\nweekly_fourier_order_list = [4, 8, 10, 12] # must be exactly 4 values (identical allowed), \nseveral_days_fourier_order_list = [0, 1, 2, 3] # must be exactly 4 values (identical allowed)\n# 0 in fourier_order lists means the absence of this component\n\n# Check length of lists\nif (len(lower_window_list) != 4) or (len(upper_window_list) != 4) or \\\n   (len(prior_scale_list) != 4) or (len(weekly_fourier_order_list) != 4) or (len(several_days_fourier_order_list) != 4):\n    print('Number of data is wrong!')","34fbdc0e":"df2 = df2.drop(columns = ['Country', 'iso_alpha'])\ndf2.columns = ['ds','y']\ndf2","046e26c7":"days_to_forecast = 14 # in future (after training data)\ndays_to_forecast_for_evalution = 14 # on the latest training data - for model training\nfirst_forecasted_date = sorted(list(set(df2['ds'].values)))[-days_to_forecast_for_evalution]\nend_forecasted_date = (datetime.strptime(df2['ds'].max(), \"%Y-%m-%d\")+timedelta(days = days_to_forecast)).strftime(\"%Y-%m-%d\")\nfirst_data_date = df2['ds'].min()\n\nprint('The first date of data for modeling is: ' + first_data_date)\nprint('The first date to perform forecasts for evaluation is: ' + first_forecasted_date)\nprint('The end date to perform forecasts in future for is: ' + end_forecasted_date)","eaf0f416":"tests0.columns = ['ds', 'tests']\ndf3 = pd.merge(df2, tests0, on = ['ds'], how = 'left')\ndf3","eeabe81f":"def convert10_base4(n):\n    # convert decimal to base 4\n    alphabet = \"0123\"\n    if n < 4:\n        return alphabet[n]\n    else:\n        return (convert10_base4(n \/\/ 4) + alphabet[n % 4]).format('4f')","9a6fe74d":"def export_plot_to_tiff(plot, fig_name):\n    DPI = 100 # this value controls the quality of final image\n    fig_name = \"{}.tiff\".format(fig_name)\n    buf = io.BytesIO()\n    try:\n        plot.figure.savefig(buf, format=\"png\", dpi=DPI)\n    except AttributeError:\n        plot.savefig(buf, format=\"png\", dpi=DPI)\n    else:\n        print(\"Function supports only objects that have savefig() method.\")\n        return\n    buf.seek(0)\n    im = Image.open(buf)\n    im.save(fig_name)\n    im.save(buf, format=\"tiff\")\n    buf.close()\n    return FileLink(fig_name)\n\ndef export_df_to_excel(df, sheet_name):\n    sheet_name = \"{}.xlsx\".format(sheet_name)\n    with pd.ExcelWriter(sheet_name, engine='openpyxl', date_format='yyyy-mm-dd') as writer:\n        df.to_excel(writer, index=False)\n    return FileLink(sheet_name)\n\ndef export_forecast_to_excel(df, sheet_name):\n    df.ds = df.ds.apply(lambda row: row.strftime(\"%Y-%m-%d\"))\n    df.rename(columns={\n        \"ds\": \"\u0414\u0430\u0442\u0430\",\n        \"yhat_lower\": \"\u041d\u0438\u0436\u043d\u044f \u043c\u0435\u0436\u0430 \u0434\u043e\u0432\u0456\u0440\u0447\u043e\u0433\u043e \u0456\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0443, \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u0432\u0438\u043f\u0430\u0434\u043a\u0456\u0432\",\n        \"yhat\": \"\u041f\u0440\u043e\u0433\u043d\u043e\u0437\u043e\u0432\u0430\u043d\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f, \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u0432\u0438\u043f\u0430\u0434\u043a\u0456\u0432\",\n        \"yhat_upper\":  \"\u0412\u0435\u0440\u0445\u043d\u044f \u043c\u0435\u0436\u0430 \u0434\u043e\u0432\u0456\u0440\u0447\u043e\u0433\u043e \u0456\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0443, \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u0432\u0438\u043f\u0430\u0434\u043a\u0456\u0432\"\n    }, inplace=True)\n    return export_df_to_excel(df, sheet_name)","e8d7a393":"def make_forecasts(country_df, df_tests, holidays_df, days_to_forecast, days_to_forecast_for_evalution, \n                   first_forecasted_date, additive1_need=False,\n                   regressor=False):\n    # Stage 1 of model tuning\n    \n    def eval_error(forecast_df, country_df_val, first_forecasted_date, title):\n        # Evaluate forecasts with validation set val_df and calculaction and printing with title the relative error\n        forecast_df[forecast_df['yhat'] < 0]['yhat'] = 0\n        result_df = forecast_df[(forecast_df['ds'] >= pd.to_datetime(first_forecasted_date))]\n        result_val_df = result_df.merge(country_df_val, on=['ds'])\n        result_val_df['rel_diff'] = (result_val_df['y'] - result_val_df['yhat'].round()).abs()\n        relative_error = sum(result_val_df['rel_diff'].values)*100\/result_val_df['y'].sum()        \n        return relative_error\n    \n    def model_training_forecasting(df, df_tests, forecast_days, holidays_df=None, mode_main='multiplicative',\n                                   regressor=False):\n        # Prophet model training and forecasting\n        \n        #print('model_training_forecasting')\n        #display(df)\n        \n        model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False, \n                        holidays=holidays_df, changepoint_range=1, changepoint_prior_scale = changepoint_prior_scale_initial_level,\n                        seasonality_mode = mode_main)\n        model.add_seasonality(name='weekly', period=7, fourier_order=8, mode = 'multiplicative', \n                              prior_scale = changepoint_prior_scale_initial_level\/weekly_season_reg_coef)\n        if regressor:\n            model.add_regressor('tests')\n        model.fit(df)\n        \n        future = model.make_future_dataframe(periods=forecast_days)\n        if regressor:\n            future['tests'] = df_tests['tests']\n        forecast = model.predict(future)\n        forecast[forecast['yhat'] < 0]['yhat'] = 0\n        return model, forecast\n\n    cols_w = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'multiplicative_terms','multiplicative_terms_lower', 'multiplicative_terms_upper', 'weekly', 'weekly_lower', 'weekly_upper']\n    cols_h = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'holidays', 'holidays_lower', 'holidays_upper', 'multiplicative_terms','multiplicative_terms_lower', 'multiplicative_terms_upper', 'weekly',\n              'weekly_lower', 'weekly_upper']\n    if regressor:\n        cols_w += ['tests', 'tests_lower', 'tests_upper']\n        cols_h += ['tests', 'tests_lower', 'tests_upper']\n        \n    if additive1_need:\n        mode_main_list = ['additive', 'multiplicative']\n    else: mode_main_list = ['multiplicative'] # take only this mode\n    relative_errors_holidays = []\n    counter = 0\n    results = pd.DataFrame(columns=['Conf_real', 'Conf_pred', 'Conf_pred_h', 'mode', 'n_h', 'err', 'err_h', 'prior_scale', 'how_less, %'])\n    \n    country_holidays_df = holidays_df[holidays_df['code'] == country_iso_alpha][['ds', 'holiday', 'lower_window', 'upper_window', 'prior_scale', 'type']].reset_index(drop=True)\n    country_dfs = []            \n\n    # Data preparation for forecast with Prophet\n    country_df['ds'] = pd.to_datetime(country_df['ds'])\n\n    # Set training and validation datasets\n    country_df_future = country_df.copy()\n    country_df_val = country_df[(country_df['ds'] >= pd.to_datetime(first_forecasted_date))].copy()\n    country_df = country_df[(country_df['ds'] < pd.to_datetime(first_forecasted_date))]\n\n    #print('Stage1')\n    #display(country_df)\n    \n    n = 64 # number of combination of parameters lower_window \/ upper_window \/ prior_scale\n    for k in range(len(mode_main_list)):\n        # 'additive' and 'multiplicative' mode tuning\n        # Without holidays\n        # Model training and forecasting without holidays\n        model, forecast = model_training_forecasting(country_df, df_tests, days_to_forecast_for_evalution, mode_main=mode_main_list[k],\n                                                     regressor=regressor)\n        #fig = model.plot_components(forecast)\n\n        # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n        forecast_df = forecast[['ds', 'yhat']].copy()\n        relative_error = eval_error(forecast_df, country_df_val, first_forecasted_date, 'without holidays')\n\n        # With holidays\n        # Model training with tuning prior_scale and forecasting\n        for i in range(n):\n            parameters_iter = convert10_base4(i).zfill(3)\n            lower_window_i = lower_window_list[int(parameters_iter[0])]\n            upper_window_i = upper_window_list[int(parameters_iter[1])]\n            prior_scale_i = prior_scale_list[int(parameters_iter[2])]\n            country_holidays_df_change = country_holidays_df[country_holidays_df['type'].isin(holidays_adaptive)]\n            country_holidays_df_change['lower_window'] = lower_window_i\n            country_holidays_df_change['upper_window'] = upper_window_i\n            country_holidays_df_change['prior_scale'] = prior_scale_i\n            number_holidays = len(country_holidays_df[(country_holidays_df['ds'] > first_data_date) & (country_holidays_df['ds'] < end_forecasted_date)])\n            model_holidays, forecast_holidays = model_training_forecasting(country_df, df_tests, days_to_forecast_for_evalution, country_holidays_df, \n                                                                           mode_main=mode_main_list[k], regressor=regressor)\n\n            # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n            forecast_holidays_df = forecast_holidays[['ds', 'yhat']].copy()\n            relative_error_holidays = eval_error(forecast_holidays_df, country_df_val, first_forecasted_date, 'with holidays impact')\n\n            # Save results\n            if (k == 0) and (i == 0):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                lower_window_best = lower_window_i\n                upper_window_best = upper_window_i\n                prior_scale_best = prior_scale_i\n                mode_best = mode_main_list[k]\n\n            elif (relative_error_holidays < relative_error_holidays_min):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                lower_window_best = lower_window_i\n                upper_window_best = upper_window_i\n                prior_scale_best = prior_scale_i\n                mode_best = mode_main_list[k]\n\n            # Save results to dataframe with result for the last date\n            confirmed_real_last = country_df_val.tail(1)['y'].values[0].astype('int')\n            results.loc[i+n*k,'Conf_real'] = confirmed_real_last if confirmed_real_last > 0 else 0\n            confirmed_pred_last = round(forecast_df.tail(1)['yhat'].values[0]).astype('int')\n            results.loc[i+n*k,'Conf_pred'] = confirmed_pred_last if confirmed_pred_last > 0 else 0\n            confirmed_pred_holidays_last = round(forecast_holidays_df_best.tail(1)['yhat'].values[0],0).astype('int')\n            results.loc[i+n*k,'Conf_pred_h'] = confirmed_pred_holidays_last if confirmed_pred_holidays_last > 0 else 0\n            results.loc[i+n*k,'mode'] = mode_main_list[k]\n            results.loc[i+n*k,'n_h'] = number_holidays\n            results.loc[i+n*k,'err'] = relative_error\n            results.loc[i+n*k,'err_h'] = relative_error_holidays\n            results.loc[i+n*k,'lower_window'] = lower_window_i\n            results.loc[i+n*k,'upper_window'] = upper_window_i\n            results.loc[i+n*k,'prior_scale'] = prior_scale_i\n            results.loc[i+n*k,'how_less, %'] = round((relative_error-relative_error_holidays)*100\/relative_error,1)\n\n            print('i =',i+n*k,' from',len(mode_main_list)*n-1,':  lower_window =', lower_window_i, 'upper_window =',upper_window_i, 'prior_scale =', prior_scale_i)\n            print('relative_error_holidays =',relative_error_holidays, 'relative_error_holidays_min =',relative_error_holidays_min, '\\n')\n\n        # Results visualization\n        print('Seasonality mode is', mode_main_list[k])\n        print('The best errors of model with holidays is', relative_error_holidays_min, 'with lower_window =', str(lower_window_best),\n              ' upper_window =', str(upper_window_best), ' prior_scale =', str(prior_scale_best))\n        print('The error of model without holidays is', relative_error, '\\n')\n\n    # Save results to dataframe with all dates\n    forecast_holidays_df_best['country'] = country_main\n    forecast_holidays_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)\n    forecast_holidays_dfs = forecast_holidays_df_best.tail(days_to_forecast_for_evalution)\n\n    # Forecasting the future\n    if relative_error < relative_error_holidays_min:\n        # The forecast without taking into account the holidays is the best\n        model_future_best, forecast_future_best = model_training_forecasting(country_df_future, df_tests, days_to_forecast, mode_main=mode_best,\n                                                                             regressor=regressor)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting without holidays) - ' + mode_main_list[k])\n        cols = cols_w\n        print('The best model is model without holidays')\n    else:\n        # The forecast taking into account the holidays is the best\n        print('The best model is model with holidays')\n        model_future_best, forecast_future_best = model_training_forecasting(country_df_future, df_tests, days_to_forecast, holidays_df,\n                                                                             mode_main=mode_best, regressor=regressor)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting with holidays) - ' + mode_best)\n        cols = cols_h\n    # Save forecasting results \n    forecast_future_df_best = forecast_future_best[cols]\n    forecast_future_df_best['country'] = country_main\n    forecast_future_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)    \n    forecast_future_dfs = forecast_future_df_best.tail(days_to_forecast)\n    fig = model_future_best.plot_components(forecast_future_best)\n    \n    #forecast_holidays_dfs.to_csv('forecast_holidays_dfs.csv', index=False)\n    #forecast_future_dfs.to_csv('forecast_future_dfs.csv', index=False)\n    #results.to_csv('results.csv', index=False)\n    \n    return forecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results","b71eed68":"def make_forecasts_stage2(country_df, df_tests, holidays_df, days_to_forecast, days_to_forecast_for_evalution, first_forecasted_date,\n                          mode_main='multiplicative',\n                          regressor=False):\n    # Stage 2 of model tuning\n    \n    def eval_error(forecast_df, country_df_val, first_forecasted_date, title):\n        # Evaluate forecasts with validation set val_df and calculaction and printing with title the relative error\n        forecast_df[forecast_df['yhat'] < 0]['yhat'] = 0\n        result_df = forecast_df[(forecast_df['ds'] >= pd.to_datetime(first_forecasted_date))]\n        result_val_df = result_df.merge(country_df_val, on=['ds'])\n        result_val_df['rel_diff'] = (result_val_df['y'] - result_val_df['yhat'].round()).abs()\n        relative_error = sum(result_val_df['rel_diff'].values)*100\/result_val_df['y'].sum()\n        return relative_error\n    \n    def model_training_forecasting(df, df_tests, forecast_days, holidays_df=None, mode_main='multiplicative', \n                                  weekly_fourier_order=10, several_days_fourier_order=10,\n                                  changepoint_prior_scale = changepoint_prior_scale_initial_level, mode_seasonality = 'additive',\n                                  regressor=False):\n        # Prophet model training and forecasting\n        \n        model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False, \n                        holidays=holidays_df, changepoint_range=1, changepoint_prior_scale = changepoint_prior_scale,\n                        seasonality_mode = mode_main)\n        if weekly_fourier_order > 0:\n            model.add_seasonality(name='weekly', period=7, fourier_order=weekly_fourier_order, mode = mode_seasonality, \n                                  prior_scale = changepoint_prior_scale\/weekly_season_reg_coef)\n        if several_days_fourier_order > 0:\n            model.add_seasonality(name='several_days', period=several_days_period, fourier_order=several_days_fourier_order, mode = mode_seasonality, \n                                  prior_scale = changepoint_prior_scale\/several_days_season_reg_coef)\n        if regressor:\n            model.add_regressor('tests')\n        model.fit(df)\n        future = model.make_future_dataframe(periods=forecast_days)\n        if regressor:\n            future['tests'] = df_tests['tests']\n        forecast = model.predict(future)\n        forecast[forecast['yhat'] < 0]['yhat'] = 0\n        return model, forecast\n\n    cols_w = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'multiplicative_terms','multiplicative_terms_lower', 'multiplicative_terms_upper']\n    cols_h = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'holidays', 'holidays_lower', 'holidays_upper', 'multiplicative_terms','multiplicative_terms_lower', 'multiplicative_terms_upper']\n    if regressor:\n        cols_w += ['tests', 'tests_lower', 'tests_upper']\n        cols_h += ['tests', 'tests_lower', 'tests_upper']\n    mode_seasonality_list = ['additive', 'multiplicative']\n    relative_errors_holidays = []\n    counter = 0\n    results = pd.DataFrame(columns=['Conf_real', 'Conf_pred', 'Conf_pred_h', 'mode_s', 'err', 'err_h', 'weekly_fn', 'several_days_fn', 'ch_p_s_fn', 'how_less, %'])\n    \n    country_dfs = []\n    # Data preparation for forecast with Prophet\n    country_df['ds'] = pd.to_datetime(country_df['ds'])\n\n    # Set training and validation datasets\n    country_df_future = country_df.copy()\n    country_df_val = country_df[(country_df['ds'] >= pd.to_datetime(first_forecasted_date))].copy()\n    country_df = country_df[(country_df['ds'] < pd.to_datetime(first_forecasted_date))]\n\n    #print('Stage2')\n    #display(country_df)\n    \n    n = 64 # number of combination of parameters weekly_fourier_order \/ several_days_fourier_order\n    relative_error_min = 100\n    for k in range(len(mode_seasonality_list)):\n        # 'additive' and 'multiplicative' mode tuning\n        # Without holidays\n        # Model training and forecasting without holidays\n        model, forecast = model_training_forecasting(country_df, df_tests, days_to_forecast_for_evalution, mode_main=mode_main,\n                                                     mode_seasonality = mode_seasonality_list[k], regressor=regressor)\n        #fig = model.plot_components(forecast)\n\n        # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n        forecast_df = forecast[['ds', 'yhat']].copy()\n        relative_error = eval_error(forecast_df, country_df_val, first_forecasted_date, 'without holidays')\n        mode_seasonality_w_best = mode_seasonality_list[1] if relative_error < relative_error_min else mode_seasonality_list[0]\n\n        # With holidays\n        # Model training with tuning prior_scale and forecasting\n        for i in range(n):\n            parameters_iter = convert10_base4(i).zfill(3)\n            weekly_fourier_order_i = weekly_fourier_order_list[int(parameters_iter[0])]\n            several_days_fourier_order_i = several_days_fourier_order_list[int(parameters_iter[1])]\n            changepoint_prior_scale_i = changepoint_prior_scale_list[int(parameters_iter[2])]\n            model_holidays, forecast_holidays = model_training_forecasting(country_df, df_tests, days_to_forecast_for_evalution, \n                                                                           holidays_df, mode_main=mode_main,\n                                                                           weekly_fourier_order = weekly_fourier_order_i, \n                                                                           several_days_fourier_order = several_days_fourier_order_i,\n                                                                           changepoint_prior_scale = changepoint_prior_scale_i,\n                                                                           mode_seasonality = mode_seasonality_list[k], regressor=regressor)\n            \n            # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n            forecast_holidays_df = forecast_holidays[['ds', 'yhat']].copy()\n            relative_error_holidays = eval_error(forecast_holidays_df, country_df_val, first_forecasted_date, 'with holidays impact')\n\n            # Save results\n            if (k == 0) and (i == 0):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                weekly_fourier_order_best = weekly_fourier_order_i\n                several_days_fourier_order_best = several_days_fourier_order_i\n                changepoint_prior_scale_best = changepoint_prior_scale_i\n                mode_seasonality_best = mode_seasonality_list[k]\n\n            elif (relative_error_holidays < relative_error_holidays_min):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                weekly_fourier_order_best = weekly_fourier_order_i\n                several_days_fourier_order_best = several_days_fourier_order_i\n                changepoint_prior_scale_best = changepoint_prior_scale_i\n                mode_seasonality_best = mode_seasonality_list[k]\n\n            # Save results to dataframe with result for the last date\n            confirmed_real_last = country_df_val.tail(1)['y'].values[0].astype('int')\n            results.loc[i+n*k,'Conf_real'] = confirmed_real_last if confirmed_real_last > 0 else 0\n            confirmed_pred_last = round(forecast_df.tail(1)['yhat'].values[0]).astype('int')\n            results.loc[i+n*k,'Conf_pred'] = confirmed_pred_last if confirmed_pred_last > 0 else 0\n            confirmed_pred_holidays_last = round(forecast_holidays_df_best.tail(1)['yhat'].values[0],0).astype('int')\n            results.loc[i+n*k,'Conf_pred_h'] = confirmed_pred_holidays_last if confirmed_pred_holidays_last > 0 else 0\n            results.loc[i+n*k,'mode_s'] = mode_seasonality_list[k]\n            results.loc[i+n*k,'err'] = relative_error\n            results.loc[i+n*k,'err_h'] = relative_error_holidays\n            results.loc[i+n*k,'weekly_fn'] = weekly_fourier_order_i\n            results.loc[i+n*k,'several_days_fn'] = several_days_fourier_order_i\n            results.loc[i+n*k,'ch_p_s_fn'] = changepoint_prior_scale_i\n            results.loc[i+n*k,'how_less, %'] = round((relative_error-relative_error_holidays)*100\/relative_error,1)\n\n            print('i =',i+n*k,' from',len(mode_seasonality_list)*n-1,':  weekly_fourier_order =', weekly_fourier_order_i, 'several_days_fourier_order =', several_days_fourier_order_i,\n                  'changepoint_prior_scale =', changepoint_prior_scale_i)\n            print('relative_error_holidays =',relative_error_holidays, 'relative_error_holidays_min =',relative_error_holidays_min, '\\n')\n\n        # Results visualization\n        print('Seasonality mode is', mode_seasonality_list[k])\n        print('The best errors of model with holidays is', relative_error_holidays_min,\n              'weekly_fourier_order =', weekly_fourier_order_i, 'several_days_fourier_order =', several_days_fourier_order_i,\n              'changepoint_prior_scale =', changepoint_prior_scale_i)\n        print('The error of model without holidays is', relative_error, '\\n')\n\n    # Save results to dataframe with all dates\n    forecast_holidays_df_best['country'] = country_main\n    forecast_holidays_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)\n    forecast_holidays_dfs = forecast_holidays_df_best.tail(days_to_forecast_for_evalution)\n\n    # Forecasting the future\n    if relative_error < relative_error_holidays_min:\n        # The forecast without taking into account the holidays is the best\n        model_future_best, forecast_future_best = model_training_forecasting(country_df, df_tests, days_to_forecast_for_evalution, mode_main=mode_main,\n                                                                             mode_seasonality = mode_seasonality_w_best, regressor=regressor)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting without holidays) - ' + mode_seasonality_w_best)\n        cols = cols_w\n        print('The best model is model without holidays')\n    else:\n        # The forecast taking into account the holidays is the best\n        print('The best model is model with holidays')\n        model_future_best, forecast_future_best = model_training_forecasting(country_df, df_tests, days_to_forecast_for_evalution, \n                                                                             holidays_df, mode_main=mode_main,\n                                                                             weekly_fourier_order = weekly_fourier_order_best, \n                                                                             several_days_fourier_order = several_days_fourier_order_best,\n                                                                             changepoint_prior_scale = changepoint_prior_scale_i,\n                                                                             mode_seasonality = mode_seasonality_best, regressor=regressor)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting with holidays) - ' + mode_seasonality_best)\n        cols = cols_h\n    # Save forecasting results \n    forecast_future_df_best = forecast_future_best[cols]\n    forecast_future_df_best['country'] = country_main\n    forecast_future_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)    \n    forecast_future_dfs = forecast_future_df_best.tail(days_to_forecast)\n    fig = model_future_best.plot_components(forecast_future_best)\n\n    return forecast_future_df_best, forecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results","fad52460":"def tuning_model(df2, \n                 df_tests,\n                 holidays_df, \n                 days_to_forecast, \n                 days_to_forecast_for_evalution, \n                 first_forecasted_date, \n                 additive1_need=False,\n                 regressor=False):\n    # Tuning Prophet model in 2 stages\n    \n    #print('Tuning')\n    #display(df2)\n    \n    # STAGE 1\n    forecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results = make_forecasts(df2, df_tests, holidays_df, \n                        days_to_forecast, days_to_forecast_for_evalution, first_forecasted_date, additive1_need=additive1_need)\n    \n    # Determination of the best parameters\n    results['err_h'] = results['err_h'].astype('float')\n    results['lower_window'] = results['lower_window'].astype('int')\n    results['upper_window'] = results['upper_window'].astype('int')\n    \n    # Display results\n    if additive1_need:\n        results_a = results[results['mode'] == 'additive']\n        display(results_a.nsmallest(5, 'err_h'))\n    results_m = results[results['mode'] == 'multiplicative']\n    display(results_m.nsmallest(5, 'err_h'))\n\n    # The smallest WAPE:\n    best_result = results.nsmallest(1, 'err_h').reset_index(drop=True)\n    lower_window_opt = best_result.lower_window[0]\n    upper_window_opt = best_result.upper_window[0]\n    prior_scale_opt = best_result['prior_scale'][0]\n    mode_opt = best_result['mode'][0]\n\n    # Output results\n    print(f\"Thus, for {country_main} the optimal parameters of Prophet model that gave an WAPE = {best_result['err_h'][0]} are:\")\n    print(\"* lower_window =\", lower_window_opt)\n    print(\"* upper_window =\", upper_window_opt)\n    print(\"* prior_scale =\", prior_scale_opt)\n    print(\"* mode_opt =\", mode_opt)\n\n    # Optimal parameters\n    holidays_df['lower_window'] = lower_window_opt\n    holidays_df['upper_window'] = upper_window_opt\n    holidays_df['prior_scale'] = prior_scale_opt\n\n    # The smallest WAPE:\n    display(best_result)\n    \n    # STAGE 2\n    forecast_future_df_best, forecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results = make_forecasts_stage2(df2, \n                df_tests, holidays_df, days_to_forecast, days_to_forecast_for_evalution, first_forecasted_date, mode_main=mode_opt)\n    \n    forecast_future_df_best.to_csv('forecast_future_df_best.csv', index=False)\n    forecast_holidays_dfs.to_csv('forecast_holidays_dfs2.csv', index=False)\n    forecast_future_dfs.to_csv('forecast_future_dfs2.csv', index=False)\n    results.to_csv('results2.csv', index=False)\n\n    display(results)\n\n    # Determination of the best parameters\n    results['err_h'] = results['err_h'].astype('float')\n    results['weekly_fn'] = results['weekly_fn'].astype('int')\n    results['several_days_fn'] = results['several_days_fn'].astype('int')\n    results_a = results[results['mode_s'] == 'additive']\n    results_m = results[results['mode_s'] == 'multiplicative']\n    #display(results_a)\n    #display(results_m)\n    display(results_a.nsmallest(5, 'err_h'))\n    display(results_m.nsmallest(5, 'err_h'))\n\n    # The smallest WAPE:\n    best_result2 = results.nsmallest(1, 'err_h').reset_index(drop=True)\n    weekly_fourier_order_opt = best_result2.weekly_fn[0]\n    several_days_fourier_order_opt = best_result2.several_days_fn[0]\n    mode_seasonality_opt = mode_seasonality_weekly_opt = mode_seasonality_several_days_opt = best_result2['mode_s'][0]\n    changepoint_prior_scale_opt = best_result2['ch_p_s_fn'][0]\n    weekly_seasonality_prior_scale_opt = changepoint_prior_scale_opt\/weekly_season_reg_coef\n    several_days_seasonality_prior_scale_opt = changepoint_prior_scale_opt\/several_days_season_reg_coef\n\n    # Results of all tuning\n    # The smallest WAPE:\n    display(best_result2)\n    best_result2.to_csv('best_result2.csv', index=False)\n    holidays_df.to_csv('holidays_df_all.csv', index=False)\n\n    print(f\"Thus, for {country_main} the optimal 11 parameters of Prophet model that gave an WAPE = {best_result2.err_h[0]} are:\")\n    print(\"* lower_window =\", lower_window_opt)\n    print(\"* upper_window =\", upper_window_opt)\n    print(\"* prior_scale =\", prior_scale_opt)\n    print(\"* changepoint_prior_scale =\", changepoint_prior_scale_opt)\n    print(\"* mode_opt =\", mode_opt)\n    print(\"* weekly_fourier_order =\", weekly_fourier_order_opt)\n    print(\"* mode_seasonality_weekly =\", mode_seasonality_weekly_opt)\n    print(\"* weekly_seasonality_prior_scale =\", weekly_seasonality_prior_scale_opt)\n    print(\"* several_days_fourier_order =\", several_days_fourier_order_opt)\n    print(\"* mode_seasonality_several_days =\", mode_seasonality_several_days_opt)\n    print(\"* several_days_seasonality_prior_scale =\", several_days_seasonality_prior_scale_opt)\n\n    return df2, days_to_forecast, holidays_df, mode_opt, weekly_fourier_order_opt, several_days_fourier_order_opt,\\\n           changepoint_prior_scale_opt, mode_seasonality_opt","9d32280a":"def model_training_forecasting(df, df_tests, forecast_days, holidays_df=None, mode_main='multiplicative', \n                               weekly_fourier_order=10, several_days_fourier_order=10, \n                               changepoint_prior_scale = changepoint_prior_scale_initial_level, mode_seasonality = 'additive',\n                               regressor=False):\n    # Optimal Prophet model training and forecasting\n    #print('Prediction')\n    #display(df)\n\n    model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False, \n                    holidays=holidays_df, changepoint_range=1, changepoint_prior_scale = changepoint_prior_scale,\n                    seasonality_mode = mode_main)\n    if weekly_fourier_order > 0:\n        model.add_seasonality(name='weekly', period=7, fourier_order=weekly_fourier_order, mode = mode_seasonality, \n                              prior_scale = changepoint_prior_scale\/weekly_season_reg_coef)\n    if several_days_fourier_order > 0:\n        model.add_seasonality(name='several_days', period=several_days_period, fourier_order=several_days_fourier_order, mode = mode_seasonality, \n                              prior_scale = changepoint_prior_scale\/several_days_season_reg_coef)\n    if regressor:\n        model.add_regressor('tests')\n    model.fit(df)\n    #print(forecast_days)\n    future = model.make_future_dataframe(periods=forecast_days)\n    #display(future)\n    #display(future.tail(30))\n    if regressor:\n        future['tests'] = df_tests['tests']\n    forecast = model.predict(future)\n    \n    forecast[forecast['yhat'] < 0]['yhat'] = 0\n    forecast['yhat_lower'] = forecast['yhat_lower'].round().astype('int')\n    forecast['yhat'] = forecast['yhat'].round().astype('int')\n    forecast['yhat_upper'] = forecast['yhat_upper'].round().astype('int')\n    \n    return model, forecast","91dad63b":"def prediction_model(df2, df_tests, days_to_forecast, holidays_df, mode_opt,\n                     weekly_fourier_order_opt, several_days_fourier_order_opt,\n                     changepoint_prior_scale_opt, mode_seasonality_opt, regressor):\n    # Prediction future by the given model\n    \n    # Get prediction\n    model_future_opt, forecast_future_opt = model_training_forecasting(df2, df_tests, days_to_forecast, \n                                               holidays_df, mode_main=mode_opt,\n                                               weekly_fourier_order = weekly_fourier_order_opt, \n                                               several_days_fourier_order = several_days_fourier_order_opt,\n                                               changepoint_prior_scale = changepoint_prior_scale_opt,\n                                               mode_seasonality = mode_seasonality_opt, regressor=regressor)\n    # Visualization\n    fig = model_future_opt.plot(forecast_future_opt)\n    fig = model_future_opt.plot_components(forecast_future_opt)\n    \n    # Output results \n    forecast_future_opt_future = forecast_future_opt[['ds', 'yhat_lower', 'yhat', 'yhat_upper']]\n    forecast_future_opt_future.tail(days_to_forecast)\n    forecast_future_opt_future.to_csv('forecast_future_opt_future.csv', index=False)\n    \n    return forecast_future_opt, forecast_future_opt_future, model_future_opt","074aaa56":"# Selection only type='lab' from holidays_df\nholidays_df_tests = holidays_df.copy()\nholidays_df_tests = holidays_df_tests[holidays_df_tests['type'] == 'lab'].reset_index(drop=True)","dd1d073f":"# Model tuning for number of tests\ntests, days_to_forecast, holidays_df, mode_opt_tests, \\\n       weekly_fourier_order_opt_tests, several_days_fourier_order_opt_tests, \\\n       changepoint_prior_scale_opt_tests, mode_seasonality_opt_tests = tuning_model(tests, None, \n                                                                                    holidays_df_tests, \n                                                                                    days_to_forecast, \n                                                                                    days_to_forecast_for_evalution, \n                                                                                    first_forecasted_date, \n                                                                                    additive1_need=False,\n                                                                                    regressor=False)","d671f651":"# Number of tests prediction\nforecast_future_opt_test, forecast_future_opt_future_tests, \\\n            model = prediction_model(tests, None, days_to_forecast, holidays_df_tests, mode_opt_tests,\n                          weekly_fourier_order_opt_tests, several_days_fourier_order_opt_tests,\n                          changepoint_prior_scale_opt_tests, mode_seasonality_opt_tests, \n                          regressor=False)","a68c883d":"forecast_future_opt_test.head(3)","166dcf1b":"# Jump of changes of number of tests\nforecast_future_opt_test['jump'] = forecast_future_opt_test['trend'].diff().diff()\nforecast_future_opt_test['jump'].plot()","037d1af8":"# Plot with number of tests jumps\nfig = plt.figure(facecolor='w', figsize=(12,6))\nt = pd.to_datetime(forecast_future_opt_test['ds'].tolist())\nplt.plot(t, forecast_future_opt_test['trend'], ls='-', c='#0072B2', label = \"\u0422\u0440\u0435\u043d\u0434 \u043a\u0456\u043b\u044c\u043a\u043e\u0441\u0442\u0456 \u0442\u0435\u0441\u0442\u0456\u0432\")\n#plt.plot(t, forecast_future_opt_test['trend'], ls='-', c='#0072B2', label = \"\u0422\u0440\u0435\u043d\u0434 \u043a\u0456\u043b\u044c\u043a\u043e\u0441\u0442\u0456 \u0442\u0435\u0441\u0442\u0456\u0432\")\n#plt.scatter(t, forecast_future_opt_test['jump'], c='k', label = '\u041c\u0456\u0441\u0446\u044f \u0440\u0456\u0437\u043a\u043e\u0457 \u0437\u043c\u0456\u043d\u0438 \u0442\u0440\u0435\u043d\u0434\u0443')\nplt.title(\"\u0422\u0440\u0435\u043d\u0434 \u043a\u0456\u043b\u044c\u043a\u043e\u0441\u0442\u0456 \u0442\u0435\u0441\u0442\u0456\u0432\")\n#plt.legend(loc='best')\nplt.grid(True, which='major', c='gray', ls='-', lw=2, alpha=0.2)\nfig.tight_layout()","90bcc563":"export_plot_to_tiff(fig, 'tests_number_jumps')","809880fc":"export_df_to_excel(forecast_future_opt_test, 'forecast_future_opt_test')","d0dfb4e8":"# Sub-waves\nforecast_future_opt_test[forecast_future_opt_test['jump'].abs()>150]['ds']","eb19158a":"df2.info()","b013dbcd":"# Dataset for confirmed case prediction with prediction of additional regressor\nforecast_future_opt_future_tests['ds'] = forecast_future_opt_future_tests['ds'].dt.strftime('%Y-%m-%d')\ndf3 = pd.merge(df2, forecast_future_opt_future_tests[['ds', 'yhat']], on=['ds'], how='left')\ndf3.columns = ['ds', 'y', 'tests']\ndf3","95f8266c":"df_tests = forecast_future_opt_future_tests[['ds', 'yhat']].copy()\ndf_tests.columns = ['ds', 'tests']","b0a1ec4a":"# df2, days_to_forecast, holidays_df, mode_opt, \\\n#        weekly_fourier_order_opt, several_days_fourier_order_opt, \\\n#        changepoint_prior_scale_opt, mode_seasonality_opt = tuning_model(df2, df_tests,\n#                                                                         holidays_df, \n#                                                                         days_to_forecast, \n#                                                                         days_to_forecast_for_evalution, \n#                                                                         first_forecasted_date, \n#                                                                         additive1_need=False,\n#                                                                         regressor=True)","d7b3ad81":"#df3","87475495":"# forecast_future_opt, forecast_future_opt_future, model = prediction_model(df3, df_tests, days_to_forecast, holidays_df, mode_opt,\n#                                               weekly_fourier_order_opt, several_days_fourier_order_opt,\n#                                               changepoint_prior_scale_opt, mode_seasonality_opt,\n#                                               regressor=True)","94bb0ed1":"# # Forecast at 2020-11-22\n# prev0_df2 = pd.read_csv('..\/input\/covid19-in-ukraine-daily-data\/n_confirmed_with_forecast_for_2_week_to_06-12-2020_by_opt_prophet_model_from_06-07-to-22-11_2020.csv')\n# prev0_df2.tail(14)","35267d96":"# # Forecast at 2020-11-29\n# prev1_df2 = pd.read_csv('..\/input\/covid19-in-ukraine-daily-data\/29.11.2020 - n_confirmed_with_forecast_for_2_week_to_06-12-2020_by_opt_prophet_model_from_06-07-2020.csv')\n# prev1_df2.tail(14)","3016b276":"# def comparing_plot(df_new, df_old0, df_old1, df, num):\n#     # Drawing plots for comparison of previous forecasts in English and Ukranian languages\n    \n#     if rolling_window:\n#         df_old0['yhat'] = df_old0['yhat'].rolling(7).mean()\n#         df_old1['yhat'] = df_old1['yhat'].rolling(7).mean()\n#         #df_old0['ds'] = df_old0['ds'].apply(lambda x: x.astype('datetime64[ns]') + timedelta(days=7)).strftime('%Y-%m-%d')\n#         #df_old0['ds'] = (df_old0['ds'].astype('datetime64[ns]') + timedelta(days=7)).strftime('%Y-%m-%d')\n    \n#     if num > 0:\n#         df_new = df_new[num:]\n#         df_old0 = df_old0[num:]\n#         df_old1 = df_old1[num:]\n#         df = df[num:]\n    \n#     def plot_lang(labels_list):\n#         # Drawing plot for comparison of previous forecasts in given language\n    \n        \n#         fig = plt.figure(facecolor='w', figsize=(16,8))\n\n#         # New forecast\n#         t_new = pd.to_datetime(df_new['ds'].tolist())\n#         plt.plot(t_new, df_new['yhat'], ls='-', c='#0072B2', label = labels_list[0])\n#         if not rolling_window:\n#             plt.fill_between(t_new, df_new['yhat_lower'], df_new['yhat_upper'], color='#0072B2', alpha=0.2)\n\n#         # Old1 forecast\n#         t_old1 = pd.to_datetime(df_old1['ds'].tolist())\n#         plt.plot(t_old1, df_old1['yhat'], ls='-', c='g', label = labels_list[1])\n#         if not rolling_window:\n#             plt.fill_between(t_old1, df_old1['yhat_lower'], df_old1['yhat_upper'], color='g', alpha=0.2)\n\n#         # Old0 forecast\n#         t_old0 = pd.to_datetime(df_old0['ds'].tolist())\n#         plt.plot(t_old0, df_old0['yhat'], ls='-', c='r', label = labels_list[2])\n#         if not rolling_window:\n#             plt.fill_between(t_old0, df_old0['yhat_lower'], df_old0['yhat_upper'], color='r', alpha=0.2)\n\n#         # Observation data\n#         t = pd.to_datetime(df['ds'].tolist())\n#         plt.scatter(t, df['y'], c='k', label = labels_list[3])\n\n#         plt.legend(loc='best')\n#         plt.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n#         fig.tight_layout()\n        \n    \n#     # English version\n#     date_today = date.today().strftime(\"%d.%m.%Y\")\n#     forecast_today_en = f\"Forecast at {date_today}\"\n#     forecast_today_ua = f\"\u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u0432\u0456\u0434 {date_today}\"\n#     plot_lang([forecast_today_en, \"Forecast at 29.11.2020\", \"Forecast at 22.11.2020\", \"Official data\"])\n    \n#     # Ukranian version\n#     plot_lang([forecast_today_ua, \"\u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u0432\u0456\u0434 29.11.2020\", \"\u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u0432\u0456\u0434 22.11.2020\", \"\u0414\u0430\u043d\u0456 \u0420\u041d\u0411\u041e \u0423\u043a\u0440\u0430\u0457\u043d\u0438\"])","bb317851":"# Comparing for all data\n#comparing_plot(df_new=forecast_future_opt_future, df_old0=prev0_df2, df_old1=prev1_df2, df=df2, num=0)","82f4025e":"# # Comparing data for the last 2 weeks\n# num_end = 126 if not rolling_window else 0    \n# comparing_plot(df_new=forecast_future_opt_future, df_old0=prev0_df2, df_old1=prev1_df2, df=df2, num=num_end)","acfefaaf":"## 4.3. Set initial values for tuning<a class=\"anchor\" id=\"4.3\"><\/a>\n\n[Back to Table of Contents](#0.1)","0ddccec7":"### 3.2.4. Weekend quarantine as holidays<a class=\"anchor\" id=\"3.2.4\"><\/a>\n\n[Back to Table of Contents](#0.1)","62de014f":"### 5.3. Model tuning for the confirmed cases data with regressor<a class=\"anchor\" id=\"5.3\"><\/a>\n\n[Back to Table of Contents](#0.1)","1ed77429":"<a class=\"anchor\" id=\"0\"><\/a>\n# COVID-19 in Ukraine: EDA & Forecasting with regressor (number of PCR tests) with holidays impact for confirmed cases. Prophet with holidays and pseudo-holidays - 11 parameters tuning:\n* lower_window\n* upper_window\n* prior_scale\n* mode\n* changepoint_prior_scale\n* weekly_fourier_order\n* mode_seasonality_weekly\n* weekly_seasonality_prior_scale\n* several_days_fourier_order (for period = n days, n = 2, 3, ... 6)\n* mode_seasonality_several_days\n* several_days_seasonality_prior_scale","9ddb0a46":"### Prediction of additional regressor","5626260a":"## Describe statistics","ea8d9d15":"I hope you find this kernel useful and enjoyable.","df66b829":"### Thank to dataset [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries)","24562efb":"### 5.1. Functions for modeling<a class=\"anchor\" id=\"5.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","ce481be9":"## 5. Tuning Prophet model and holidays parameters<a class=\"anchor\" id=\"5\"><\/a>\n\n[Back to Table of Contents](#0.1)","843ec4ea":"### We will select only the last wave: from the middle of July","9d02c26f":"## 3. Selection data with holidays<a class=\"anchor\" id=\"3\"><\/a>\n\n[Back to Table of Contents](#0.1)","d7325b8b":"#### Thanks to:\n* [COVID-19 Open Data](https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data)\n* [NOAA](https:\/\/www.ncei.noaa.gov\/)","21027f39":"[Go to Top](#0)","b6c3b720":"## 4.2. Statistics<a class=\"anchor\" id=\"4.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","3da7e5da":"### 5.2. Model tuning and prediction for additional regressor with number of PCR tests<a class=\"anchor\" id=\"5.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","4d189062":"## Earliest Cases","06c15f7f":"## Latest Cases","5a61b50b":"<a class=\"anchor\" id=\"0.1\"><\/a>\n## Table of Contents\n\n1. [Import libraries](#1)\n1. [Download data](#2)\n1. [Selection data with holidays](#3)\n    - [Holidays with a shift](#3.1)\n    - [Additional dates of anomalies as holidays](#3.2)    \n        - [The weakening of quarantine](#3.2.1)\n        - [Very comfortable conditions for rest](#3.2.2)\n        - [Holidays as days of less efficient work of laboratories](#3.2.3)\n        - [Weekend quarantine as holidays](#3.2.4)        \n1. [EDA](#4)\n    - [Plots - Confirmed cases over time](#4.1)\n    - [Statistics](#4.2)\n    - [Set initial values for tuning](#4.3)\n1. [Tuning Prophet model and holidays parameters](#5)\n    - [Functions for modeling](#5.1)\n    - [Model tuning and prediction for additional regressor with number of PCR tests](#5.2)\n    - [Model tuning for the confirmed cases data with regressor](#5.3)\n1. [Prediction](#6)\n1. [Comparison with previous forecasts](#7)","d0596611":"#### Thanks to [Oxford COVID-19 government response tracker](https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker)","2fd33a50":"Import libraries","e3c04c3d":"### Confirmed cases data","3229ba3e":"## 4. EDA<a class=\"anchor\" id=\"4\"><\/a>\n\n[Back to Table of Contents](#0.1)","fa69b4ee":"## 3.2. Additional dates of anomalies as holidays<a class=\"anchor\" id=\"3.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","9ee71ac4":"### Number of tests data","7b903664":"## 2. Download data<a class=\"anchor\" id=\"2\"><\/a>\n\n[Back to Table of Contents](#0.1)","4562a890":"### 3.2.1. The weakening of quarantine<a class=\"anchor\" id=\"3.2.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","83c6999a":"## 7. Comparison with previous forecasts <a class=\"anchor\" id=\"7\"><\/a>\n\n\n[Back to Table of Contents](#0.1)","14e51d6c":"#### Thanks to [COVID-19 in Ukraine: daily data](https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ukraine-daily-data)","c695823c":"There are many studies in the field of coronavirus forecasting. Many researchers use **Prophet** (from Facebook). But for some reason, no one takes into account the holidays impact. After all, despite all the prohibitions, it is difficult for people to stay at home and they still somehow celebrate the **holidays** to which they are accustomed. The desire to celebrate is especially strong when people are sitting at home all the time looking for something to do. In my opinion, the impact of the holidays is manifested in the fact that within 4-10 days after these holidays there may be a jump in the number of confirmed cases, due to the fact that people went shopping, and even visiting each other, perhaps even in violation of quarantine requirements. \n\nThe Prophet uses the library [holidays](https:\/\/github.com\/dr-prodigy\/python-holidays) with information about the main holidays of 67 countries, but and its package has some disadvantages. That's why I created a more perfect own dataset and plan to update it periodically. Now **my dataset [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries) has holidays for 70 countries** and more adapted for use in the prediction of coronavirus diseases.\n\nHolidays and pseudo-holidays (**anomalies dates**) are defined in three ways:\n- dates of official public holidays;\n- the weakening of quarantine according to open data;\n- dates of very comfortable conditions for rest (there are more 95% quantile on average temperature and not more 5% quantile of rainfall) - for each country it should be adapted individually (open data NOAA are used)\n\nThe model is **tuning in two stages** - makes a complete search of values from 4 possible for each feature at first for one part of parameters, then - for another. In the second stage, the optimal parameters determined in the first stage are used. Each stage ends with an interactive graph (library \"plotly\"), which clearly shows the WAPE for each combination of parameters.\n\nThe Prophet model with all optimized parameters and holidays is used for **forecasting** future data for the next days and visualization of forecasting results. The data is taken from [COVID-19 Open Data](https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data) (usually this dataset are updated there daily and are available as of yesterday), so the next days are counted from the date of the last committee of this notebook.","87b3ac96":"## 3.1. Holidays with a shift<a class=\"anchor\" id=\"3.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","f5cbbcd5":"# Dataset [COVID-19 in Ukraine: daily data](https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ukraine-daily-data)","7957f8c5":"### 3.2.3. Holidays as days of less efficient work of laboratories <a class=\"anchor\" id=\"3.2.3\"><\/a>\n\n[Back to Table of Contents](#0.1)","3a80420b":"## 4.1. Plots - Confirmed cases over time<a class=\"anchor\" id=\"4.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","2eff2043":"## 6. Prediction <a class=\"anchor\" id=\"6\"><\/a>\n\n[Back to Table of Contents](#0.1)","095dbdc5":"#### Thanks to https:\/\/api-covid19.rnbo.gov.ua\/","32d0d42b":"# Acknowledgements\n\n### Datasets:\n- my dataset [COVID-19 in Ukraine: daily data](https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ukraine-daily-data)\n- official data of Ukraine: via API from portal of the [National Security and Defense Council of Ukraine](https:\/\/www.rnbo.gov.ua\/en\/) and from FB page of the [Ministry of Health of Ukraine](https:\/\/moz.gov.ua\/)\n- dataset [COVID-19 Open Data](https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data) (including dataset [Oxford COVID-19 government response tracker](https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker) and dataset [NOAA](https:\/\/www.ncei.noaa.gov\/)) : @article{Wahltinez2020,author = \"Oscar Wahltinez and Matt Lee and Anthony Erlinger and Mayank Daswani and Pranali Yawalkar and Kevin Murphy and Michael Brenner\", year = 2020, title = \"COVID-19 Open-Data: curating a fine-grained, global-scale data repository for SARS-CoV-2\", note = \"Work in progress\",  url = {https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data},} \n- my dataset with holidays data [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries) - it is recommended to follow the updates\n\n### Notebooks:\n- notebook [COVID-19-in-Ukraine: Prophet & holidays tuning](https:\/\/www.kaggle.com\/vbmokin\/covid-19-in-ukraine-prophet-holidays-tuning)\n- notebook [COVID-19 Novel Coronavirus EDA & Forecasting Cases](https:\/\/www.kaggle.com\/khoongweihao\/covid-19-novel-coronavirus-eda-forecasting-cases) from [@Wei Hao Khoong](https:\/\/www.kaggle.com\/khoongweihao)\n\n### Libraries from GitHub:\n- https:\/\/facebook.github.io\/prophet\/\n- https:\/\/facebook.github.io\/prophet\/docs\/\n- https:\/\/github.com\/facebook\/prophet\n- https:\/\/github.com\/dr-prodigy\/python-holidays","948235b7":"Your comments and feedback are most welcome.","58bdcc5a":"## 1. Import libraries<a class=\"anchor\" id=\"1\"><\/a>\n\n[Back to Table of Contents](#0.1)","7570ea24":"### 3.2.2. Very comfortable conditions for rest <a class=\"anchor\" id=\"3.2.2\"><\/a>\n\n[Back to Table of Contents](#0.1)"}}