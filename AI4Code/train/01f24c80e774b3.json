{"cell_type":{"034c603f":"code","fb9ed949":"code","0b540ce0":"code","72eaad36":"code","6cc21669":"code","7265e799":"code","9bc73b28":"code","3d279b83":"code","6c662361":"code","448ae2a6":"code","ff52d83d":"code","536ba725":"code","8745333b":"markdown","dce73708":"markdown","615edb47":"markdown","58265fb6":"markdown","cfddf8d4":"markdown"},"source":{"034c603f":"#!pip install numpy --upgrade \n#!pip install catboost","fb9ed949":"\nimport numpy as np\n#np.set_printoptions(suppress=True)\nimport pandas as pd\nfrom sklearn import metrics\nfrom sklearn import preprocessing\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.preprocessing import OneHotEncoder, StandardScaler\nfrom sklearn.model_selection import GridSearchCV, RandomizedSearchCV\nfrom sklearn.metrics import accuracy_score\n#PCA\nfrom sklearn.decomposition import PCA,KernelPCA\n# para modelar\nimport lightgbm as lgbm\n\n#import io\n#from google.colab import files\nimport os\n\n\nprint(os.listdir(\"..\/input\"))\n","0b540ce0":"n_test= 49999\nfichero = 'datos.csv'\ntests = 'entrega_para_predecir.csv'\nresultados_finales = 'resultados_finales_test.csv'\nsample = 'resultados_finales_sampleSubmission.csv'\npath_dir = 'pokemon-challenge-mlh\/'\npokemon_csv = '..\/input\/pokemon.csv'\nbattles_csv = '..\/input\/battles.csv'\ntest_csv = '..\/input\/test.csv'\n","72eaad36":"# ----------------------------------------------------DATASET-----------------------------------------------------------\ndef get_data():\n\n    #-------pokemon.csv\n    df_pokemon = pd.read_csv(pokemon_csv)\n    df_pokemon = df_pokemon.fillna({'Name': 'None', 'Type 1': 'None', 'Type 2': 'None'})\n    #df_pokemon = df_pokemon.dropna()\n    #cambiando nombre de variable\n    df_pokemon = df_pokemon.rename(index=str, columns={\"#\": \"id_pokemon\"})\n    # encoding\n    df_pokemon['Legendary'] = np.where(df_pokemon['Legendary'] == True, 1, 0)\n    # encoding name, type1 y type2\n    valores_type1 = df_pokemon['Type 1'].values\n    valores_type2 = df_pokemon['Type 2'].values\n    valores_name = df_pokemon['Name'].values\n\n    #print(df_pokemon.isna().sum())\n\n    le1 = preprocessing.LabelEncoder()\n    le2 = preprocessing.LabelEncoder()\n    lename = preprocessing.LabelEncoder()\n    encoding1 = le1.fit_transform(valores_type1)\n    encoding2 = le2.fit_transform(valores_type2)\n    encodingName = lename.fit_transform(valores_name)\n\n    # asignando\n    df_pokemon['Type 1'] = encoding1\n    df_pokemon['Type 2'] = encoding2\n    df_pokemon['Name'] = encodingName\n\n    # rapido -> 1, Lento -> 0\n    sum_speeds = np.sum(df_pokemon['Speed'].values)\n    total_speeds = len(df_pokemon['Speed'])\n    media_speeds = sum_speeds \/ total_speeds\n    df_pokemon['Rapidez'] = np.where(df_pokemon['Speed'] > media_speeds, 1, 0)\n    \n    #sum de las stats\n    #'HP', 'Attack', 'Defense','Sp. Atk', 'Sp. Def', 'Speed'\n    df_pokemon['total_stats'] = df_pokemon['HP'] + df_pokemon['Attack'] + df_pokemon['Defense'] + df_pokemon['Sp. Atk'] + df_pokemon['Sp. Def'] + df_pokemon['Speed']\n\n    #-------battles.csv\n    df_battles = pd.read_csv(battles_csv)\n    # quitamos el numero de batalla\n    df_battles = df_battles[['First_pokemon','Second_pokemon', 'Winner']]\n\n    #winrates\n    #df_pokemon = get_winrate(df_pokemon, df_battles)\n    #print(df_pokemon.head())\n\n    #-------test.csv\n    df_test = pd.read_csv(test_csv)\n\n    return df_pokemon, df_battles, df_test, le1, le2, lename","6cc21669":"# autor: https:\/\/www.kaggle.com\/vforvince1\/visualizing-data-and-predicting-pokemon-fights\ndef calculate_effectiveness(data):\n    '''\n        this function creates a new column of each pokemon's effectiveness against it's enemy.\n        every effectiveness starts with 1, if an effective type is found on enemy's type, effectiveness * 2\n        if not very effective is found on enemy's type, effectiveness \/ 2\n        if not effective is found on enemy's type, effectiveness * 0\n        This function creates 4 new columns\n            1. P1_type1, pokemon 1 first type effectiveness against the enemy's type\n            2. P1_type2, pokemon 1 second type effectiveness against the enemy's type\n            3. P2_type1, pokemon 2 first type effectiveness against the enemy's type\n            4. P2_type2, pokemon 2 second type effectiveness against the enemy's type\n    '''\n\n    very_effective_dict = {'Normal': [],\n                           'Fighting': ['Normal', 'Rock', 'Steel', 'Ice', 'Dark'],\n                           'Flying': ['Fighting', 'Bug', 'Grass'],\n                           'Poison': ['Grass', 'Fairy'],\n                           'Ground': ['Poison', 'Rock', 'Steel', 'Fire', 'Electric'],\n                           'Rock': ['Flying', 'Bug', 'Fire', 'Ice'],\n                           'Bug': ['Grass', 'Psychic', 'Dark'],\n                           'Ghost': ['Ghost', 'Psychic'],\n                           'Steel': ['Rock', 'Ice', 'Fairy'],\n                           'Fire': ['Bug', 'Steel', 'Grass', 'Ice'],\n                           'Water': ['Ground', 'Rock', 'Fire'],\n                           'Grass': ['Ground', 'Rock', 'Water'],\n                           'Electric': ['Flying', 'Water'],\n                           'Psychic': ['Fighting', 'Poison'],\n                           'Ice': ['Flying', 'Ground', 'Grass', 'Dragon'],\n                           'Dragon': ['Dragon'],\n                           'Dark': ['Ghost', 'Psychic'],\n                           'Fairy': ['Fighting', 'Dragon', 'Dark'],\n                           'None': []}\n\n    not_very_effective_dict = {'Normal': ['Rock', 'Steel'],\n                               'Fighting': ['Flying', 'Poison', 'Bug', 'Psychic', 'Fairy'],\n                               'Flying': ['Rock', 'Steel', 'Electric'],\n                               'Poison': ['Poison', 'Rock', 'Ground', 'Ghost'],\n                               'Ground': ['Bug', 'Grass'],\n                               'Rock': ['Fighting', 'Ground', 'Steel'],\n                               'Bug': ['Fighting', 'Flying', 'Poison', 'Ghost', 'Steel', 'Fire', 'Fairy'],\n                               'Ghost': ['Dark'],\n                               'Steel': ['Steel', 'Fire', 'Water', 'Electric'],\n                               'Fire': ['Rock', 'Fire', 'Water', 'Dragon'],\n                               'Water': ['Water', 'Grass', 'Dragon'],\n                               'Grass': ['Flying', 'Poison', 'Bug', 'Steel', 'Fire', 'Grass', 'Dragon'],\n                               'Electric': ['Grass', 'Electric', 'Dragon'],\n                               'Psychic': ['Steel', 'Psychic'],\n                               'Ice': ['Steel', 'Fire', 'Water', 'Psychic'],\n                               'Dragon': ['Steel'],\n                               'Dark': ['Fighting', 'Dark', 'Fairy'],\n                               'Fairy': ['Posion', 'Steel', 'Fire'],\n                               'None': []}\n\n    not_effective_dict = {'Normal': ['Ghost'],\n                          'Fighting': ['Ghost'],\n                          'Flying': [],\n                          'Poison': ['Steel'],\n                          'Ground': ['Flying'],\n                          'Rock': [],\n                          'Bug': [],\n                          'Ghost': ['Normal'],\n                          'Steel': [],\n                          'Fire': [],\n                          'Water': [],\n                          'Grass': [],\n                          'Electric': ['Ground'],\n                          'Psychic': ['Dark'],\n                          'Ice': [],\n                          'Dragon': ['Fairy'],\n                          'Dark': [],\n                          'Fairy': [],\n                          'None': []}\n\n    p1_type1_list = []\n    p1_type2_list = []\n    p1_max = []\n    p2_type1_list = []\n    p2_type2_list = []\n    p2_max = []\n\n    for row in data.itertuples():\n        nested_type = [[1, 1], [1, 1]]\n\n        tipos_pok_1 = [row.tipo1_id1, row.tipo2_id1]\n        tipos_pok_2 = [row.tipo1_id2, row.tipo2_id2]\n\n        # manipulating values if found on dictionary\n        for i in range(0, 2):\n            for j in range(0, 2):\n                if tipos_pok_2[j] in very_effective_dict.get(tipos_pok_1[i]):\n                    nested_type[0][i] *= 2\n                if tipos_pok_2[j] in not_very_effective_dict.get(tipos_pok_1[i]):\n                    nested_type[0][i] \/= 2\n                if tipos_pok_2[j] in not_effective_dict.get(tipos_pok_1[i]):\n                    nested_type[0][i] *= 0\n\n                if tipos_pok_1[j] in very_effective_dict.get(tipos_pok_2[i]):\n                    nested_type[1][i] *= 2\n                if tipos_pok_1[j] in not_very_effective_dict.get(tipos_pok_2[i]):\n                    nested_type[1][i] \/= 2\n                if tipos_pok_1[j] in not_effective_dict.get(tipos_pok_2[i]):\n                    nested_type[1][i] *= 0\n\n        p1_type1_list.append(nested_type[0][0])\n        p1_type2_list.append(nested_type[0][1])\n        p2_type1_list.append(nested_type[1][0])\n        p2_type2_list.append(nested_type[1][1])\n        p1_max.append(np.maximum(nested_type[0][0], nested_type[0][1]))\n        p2_max.append(np.maximum(nested_type[1][0], nested_type[1][1]))\n\n    data = data.assign(P1_type1=p1_type1_list, P1_type2=p1_type2_list,\n                       P2_type1=p2_type1_list, P2_type2=p2_type2_list)\n    #data = data.drop(['First_pokemon', 'Second_pokemon'], axis=1)\n\n    return data\n      \n","7265e799":"def diff_combates(df_lista):\n  \n  # DIFF ataques vs defensas cuerpo a cuerpo\n  lista_ata_pok1 = df_lista[['Attack_id1']].values\n  lista_ata_pok2 = df_lista[['Attack_id2']].values\n  lista_def_pok1 = df_lista[['Defense_id1']].values\n  lista_def_pok2 = df_lista[['Defense_id2']].values\n  \n  lista_diff_ataDef_pok1 = lista_ata_pok1 - lista_def_pok1\n  lista_diff_ataDef_pok2 = lista_ata_pok2 - lista_def_pok1\n  \n  # asignamos\n  df_lista['diff_ata_def_pok1'] = lista_diff_ataDef_pok1\n  df_lista['diff_ata_def_pok2'] = lista_diff_ataDef_pok2\n  \n  # DIFF ataques especiales\n  efec_pok1 = df_lista[['P1_type1', 'P1_type2']].values\n  efec_pok2 = df_lista[['P2_type1', 'P2_type2']].values\n  sumatorio_efectividad_pok1 = np.sum(efec_pok1, axis=1)\n  sumatorio_efectividad_pok2 = np.sum(efec_pok2, axis=1)\n  lista_ataESP_pok1 = df_lista[['Sp. Atk_id1']].values\n  lista_ataESP_pok2 = df_lista[['Sp. Atk_id2']].values\n  lista_defESP_pok1 = df_lista[['Sp. Def_id1']].values\n  lista_defESP_pok2 = df_lista[['Sp. Def_id2']].values\n  # los ataques los multiplico por la efectividad\n  # multiplicaciones\n  lista_ataESP_pok1_final = np.zeros((len(df_lista)))\n  lista_ataESP_pok2_final = np.zeros((len(df_lista)))\n  lista_diff_ataDefESP_pok1 = np.zeros((len(df_lista)))\n  lista_diff_ataDefESP_pok2 = np.zeros((len(df_lista)))\n  \n  # he tenido que dividir las matrices porque colab se peta al multiplicarlas (fallo de RAM)\n  for i in range(0, len(df_lista)):\n    lista_ataESP_pok1_final[i] = lista_ataESP_pok1[i] * sumatorio_efectividad_pok1[i]\n    lista_ataESP_pok2_final[i] = lista_ataESP_pok2[i] * sumatorio_efectividad_pok2[i]\n    \n    lista_diff_ataDefESP_pok1[i] = lista_ataESP_pok1_final[i] - lista_defESP_pok2[i]\n    lista_diff_ataDefESP_pok2[i] = lista_ataESP_pok2_final[i] - lista_defESP_pok1[i]\n    \n    i+=1\n     \n  # restas\n  #lista_diff_ataDefESP_pok1 = lista_ataESP_pok1_final - lista_defESP_pok2\n  #lista_diff_ataDefESP_pok2 = lista_ataESP_pok2_final - lista_defESP_pok1\n  \n  # asignamos\n  df_lista['diff_ata_def_ESP_pok1'] = lista_diff_ataDef_pok1\n  df_lista['diff_ata_def_ESP_pok2'] = lista_diff_ataDef_pok2\n  \n  return df_lista","9bc73b28":"# ----------------------------------------------------------------------------------------------------------------------\ndef juntar_csvs(es_conjunto_de_test):\n    df_pokemon, df_battles, df_test, le1, le2, lename = get_data()\n\n    #vectorizacion\n    pokemon_values = df_pokemon.values #(800, cols)\n    if es_conjunto_de_test == False:\n      battles_values = df_battles.values #(50000, 3) --> id_pok1, id_pok2, winner\n      indice_pok1 = 0\n      indice_pok2 = 1\n    else:\n      battles_values = df_test.values  # (10000, 3) --> battle_id, id_pok1, id_pok2\n      indice_pok1 = 1\n      indice_pok2 = 2\n    \n    ids_pokemon = pokemon_values[:,0]\n    # obtenemos valores unicos y los indices inversos para luego reconstruir el array original\n    ids_pok1, inv1 = np.unique(battles_values[:, indice_pok1], return_inverse=True)\n    ids_pok2, inv2 = np.unique(battles_values[:, indice_pok2], return_inverse=True)\n    \n    if es_conjunto_de_test == False:\n      resultados_batallas = battles_values[:, 2]\n\n    # buscamos donde estan las caracteristicas de cada pokemon en las batallas\n    indices1 = np.intersect1d(ids_pok1, ids_pokemon, return_indices=True)\n    indices2 = np.intersect1d(ids_pok2, ids_pokemon, return_indices=True)\n\n    # asignamos las caracteristicas\n    vals_pok1 = pokemon_values[indices1[2], 1:]\n    vals_pok2 = pokemon_values[indices2[2], 1:]\n\n    # pokemons sin batallas\n    sin_battles = pokemon_values[\n        np.where(\n            np.logical_not(\n                np.isin(ids_pokemon, ids_pok1)))]\n    # 16 en total\n    print('Pokemons que no han peleado:', len(sin_battles))\n\n    # y reconstruimos el array original\n    lon_values = len(battles_values)\n    # ([1|5]0000, x) cada uno\n    pok1 = vals_pok1[inv1]\n    pok2 = vals_pok2[inv2]\n    #columnas = pok2.shape[1] * 2\n    columnas = pok2.shape[1] + 13 + 6 + 6 #11 por atrs pok2 + 6 ratios + 6 diffs\n\n    pok_final = np.ones((lon_values, columnas))\n    print(pok_final.shape)\n    pok_final[:, :11] = pok1[:, :11]#nombre1,tipo1_id1,tipo2_id1, 'HP_id1','Attack_id1','Defense_id1','Sp. Atk_id1','Sp. Def_id1','Speed_id1', 'Generation_id1', 'Legendary_id1'\n    pok_final[:, 11:22] = pok2[:, :11]#nombre2,tipo2_id2,tipo2_id2,'HP_id2','Attack_id2','Defense_id2','Sp. Atk_id2','Sp. Def_id2','Speed_id2', 'Generation_id2', 'Legendary_id2'\n    # aplicamos diff\n    pok_final[:, 22:30] = pok1[:, 3:11] - pok2[:, 3:11]\n    # el mas rapido\n    #pok_final[:, -1] = np.where(pok1[:, -1] > pok2[:, -1], battles_values[:, 0], battles_values[:, 1])\n    # ratios. Excluyo Generacion y Legendario\n    pok1_ratios = pok1[:, 3:9]\n    pok2_ratios = pok2[:, 3:9]\n    pok_final[:, 30:36] = pok1_ratios\/pok2_ratios\n    \n    # aqui juntamos el resto para crear el dataset con el que entrenar\/testear\n    # ids contrincante 1, ids contrincante 2 y el que golpea primero (a\u00f1adido)\n    valores = np.array((battles_values[:, indice_pok1], battles_values[:, indice_pok2], battles_values[:, indice_pok1])) #(3, [1|5]0000)\n    valores = valores.T #([1|5]0000, 3)\n    \n    if es_conjunto_de_test == False:\n      caracteristicas_y_resultados = np.ones((lon_values, columnas + 1)) # ([1|5]0000, x)\n      caracteristicas_y_resultados[:,:-1] = pok_final\n      caracteristicas_y_resultados[:,-1] = resultados_batallas\n      \n      lista = np.concatenate((valores, caracteristicas_y_resultados), axis=1)\n      \n    else: \n      # en el test no hay winner\n      lista = np.concatenate((valores, pok_final), axis=1)\n      \n    lista = lista.astype(int)\n\n    columnas = ['First_pokemon', 'Second_pokemon', 'id_primer_ataq',\n                                            'nombre1', 'tipo1_id1', 'tipo2_id1',\n                'HP_id1','Attack_id1','Defense_id1','Sp. Atk_id1','Sp. Def_id1','Speed_id1', 'Generation_id1', 'Legendary_id1',\n                                            'nombre2', 'tipo1_id2', 'tipo2_id2',\n                'HP_id2','Attack_id2','Defense_id2','Sp. Atk_id2','Sp. Def_id2','Speed_id2', 'Generation_id2', 'Legendary_id2',\n                                            'diff_HP','diff_Attack','diff_Defense','diff_Sp. Atk','diff_Sp. Def','diff_Speed',\n                                            'diff_Generation', 'diff_Legendary',\n                                            'diff_Rapidez', 'diff_stats',\n                                            'ratio_HP','ratio_Attack','ratio_Defense','ratio_Sp. Atk','ratio_Sp. Def','ratio_Speed']\n    # caso conjunto de entrenamiento\n    if es_conjunto_de_test == False:\n      columnas.append('Winner')\n    \n    # guardo en DF\n    df_lista = pd.DataFrame(lista, columns=columnas)\n\n    # efectividad de las habilidades\n    # primero pasamos a las antiguas labels\n    df_lista['tipo1_id1'] = le1.inverse_transform(df_lista['tipo1_id1'])\n    df_lista['tipo2_id1'] = le2.inverse_transform(df_lista['tipo2_id1'])\n    df_lista['tipo1_id2'] = le1.inverse_transform(df_lista['tipo1_id2'])\n    df_lista['tipo2_id2'] = le2.inverse_transform(df_lista['tipo2_id2'])\n    df_lista['nombre1'] = lename.inverse_transform(df_lista['nombre1'])\n    df_lista['nombre2'] = lename.inverse_transform(df_lista['nombre2'])\n\n    # y luego aplicamos los valores\n    df_lista = calculate_effectiveness(df_lista)\n    \n    # a\u00f1adidos\n    # ++ ratios y diffs agrupados\n    df_lista['diff_HPDefense_SpDef'] = df_lista['diff_HP'] + df_lista['diff_Defense'] + df_lista['diff_Sp. Def']\n    df_lista['ratio_HPDefense_SpDef'] = df_lista['ratio_HP'] + df_lista['ratio_Defense'] + df_lista['ratio_Sp. Def']\n    #  ++ diff efectividad\n    efec_pok1 = df_lista['P1_type1'].values + df_lista['P1_type2'].values\n    efec_pok2 = df_lista['P2_type1'].values + df_lista['P2_type2'].values\n    df_lista['diff_efectividad'] = np.subtract(efec_pok1,efec_pok2)\n    # ata -ddef y ataESP- defESP\n    #df_lista = diff_combates(df_lista)\n    \n    # reordenamos para colocar la columnas Winner al final\n    if es_conjunto_de_test == False:\n      winners = df_lista['Winner'].values\n      df_lista = df_lista.drop(['Winner'], axis=1)\n      df_lista['Winner'] = winners\n\n    #y volvemos a aplicar los encodings\n    df_lista['tipo1_id1'] = le1.fit_transform(df_lista['tipo1_id1'])\n    df_lista['tipo2_id1'] = le2.fit_transform(df_lista['tipo2_id1'])\n    df_lista['tipo1_id2'] = le1.fit_transform(df_lista['tipo1_id2'])\n    df_lista['tipo2_id2'] = le2.fit_transform(df_lista['tipo2_id2'])\n    df_lista['nombre1'] = lename.fit_transform(df_lista['nombre1'])\n    df_lista['nombre2'] = lename.fit_transform(df_lista['nombre2'])\n\n    # elimino carac que aportan menos\n    df_lista = df_lista.drop(['Legendary_id1', 'Legendary_id2', 'Generation_id1', 'Generation_id2'], axis=1)\n    df_lista = df_lista.drop(['nombre1', 'nombre2'], axis = 1)\n    #df_lista = df_lista.drop(['diff_ata_def_pok1', 'diff_ata_def_pok2', 'diff_ata_def_ESP_pok1', 'diff_ata_def_ESP_pok2'], axis=1)\n    #df_lista = df_lista.drop(['diff_HP','diff_Defense','diff_Sp. Def',\n    #                         'ratio_HP','ratio_Defense', 'ratio_Sp. Def'], axis=1)\n    \n    print(df_lista.shape)\n\n    # guardamos\n    if es_conjunto_de_test == False:\n      df_lista.to_csv(fichero, index=False)\n    else:\n      df_lista.to_csv(tests, index=False)\n\n    return lista","3d279b83":"# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------MODELO EMPLEADOS--------------------------------------------------\n#0.9791 --> 0.05lr\n#n_estimators=800, learning_rate=0.05, subsample=0.75,max_depth=10\ndef GradientBoostingCl(train_x, train_y, test_x, test_y):\n\n    clf = GradientBoostingClassifier(n_estimators=800, learning_rate=0.05, subsample=0.75,max_depth=9)\n    clf.fit(train_x, train_y)\n\n    y_pred=clf.predict(test_x)\n    print(clf.feature_importances_)\n    print(\"Accuracy random forest1:\",metrics.accuracy_score(test_y, y_pred))\n    \n\n    return clf","6c662361":"# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------- MODELO  LIGHTGBM -----------------------------------------------------\ndef lightgbm_model(train_x, train_y, test_x, test_y, columnas):\n  \n\n    # making lgbm datasets for train and valid\n    d_train = lgbm.Dataset(train_x, label= train_y)\n    d_valid = lgbm.Dataset(test_x, label= test_y)\n    \n    # training\n    bst = lgbm.train(params, d_train, valid_sets= [d_valid], verbose_eval=100, feature_name= (columnas.tolist())[:-1])\n    \n    #Prediction --> comentar estas lineas cuando se vaya a subir a kaggle co n49999\n    y_pred=bst.predict(test_x)\n    \n    #convert into binary values \n    for i in range(0,len(test_y)):\n      if y_pred[i]>=.5:       # setting threshold to .5\n        y_pred[i]=1\n      else:  \n        y_pred[i]=0\n        \n    #Accuracy\n    accuracy=accuracy_score(y_pred,test_y)\n    print(accuracy)\n    \n    lgbm.plot_importance(bst, max_num_features = 15)\n    #lgbm.plot_tree(bst, figsize= (100,100))\n\n    return bst\n  \n# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------------------------------------------------------------------------\n# -----------------------------------------eleccion de mejores parametros-----------------------------------------------\ndef feature_search(X, y, columnas):\n  \n  # parametros a probar\n  gridParams = {\n      'learning_rate': [0.05, 0.07, 0.08, 0.1],\n      'num_iterations': [900, 1000, 1100],\n      'boosting_type' : ['goss'],\n      'objective' : ['binary'],\n      'subsample' : [0.7,0.75],\n      'lambda_l1' : [0.005, 0.01],\n      'lambda_l2' : [0.005, 0.01],\n      'max_depth': [9, 10, 11, 12, -1] \n    }\n  \n  # entrenamos con los por defecto del modelo\n  model = lgbm.LGBMClassifier(params)\n  \n  # definimos el grid\n  grid = RandomizedSearchCV(estimator = model, \n    param_distributions = gridParams, \n    scoring='roc_auc',\n    n_jobs=-1,\n    iid=False, \n    verbose=2,\n    cv=3)\n  \n  grid.fit(X, y)\n\n  # Print the best parameters found\n  print(grid.best_params_)\n  print(grid.best_score_)\n  \n  # TODO reemplazar mejores parametros y entrenar modelo\n  \n  return grid\n  \n","448ae2a6":"# ----------------------------------------------------------------------------------------------------------------------\n# ---------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------RESULTADOS--------------------------------------------------\n# ----------------------------------------------------------------------------------------------------------------------\n# ---------------------------------------------------------------------------------------------------------\ndef agrupados():\n\n    df = pd.read_csv(fichero)\n    \n    lista = df.values\n    \n    print(df.columns)\n\n    X = lista[:, :-1]\n    y = lista[:, -1]\n\n    train_x,train_y = X[:n_test], y[:n_test]\n    test_x, test_y = X[n_test:], y[n_test:]\n\n    # lightbeam\n    clf = lightgbm_model(train_x, train_y, test_x, test_y, df.columns)\n    #clf = feature_search(X, y, df.columns)\n\n\n    return clf","ff52d83d":"# ------------------------------------------guardar datos finales-------------------------------------------------------\ndef resultado_final():\n\n    df = pd.read_csv(tests)\n    lista = df.values\n    print(lista.shape)\n    \n    clf = agrupados()\n    \n    y_pred=clf.predict(lista)\n    for i in range(0,len(lista)):\n      if y_pred[i]>=.5:       # setting threshold to .5\n        y_pred[i]=1\n      else:  \n        y_pred[i]=0\n    y_pred = y_pred.astype(int)\n\n    df_test = pd.read_csv(test_csv)\n    df_test['Winner'] = y_pred\n    df_test.to_csv(resultados_finales, index=False)\n\n    df_sample = df_test[['battle_number', 'Winner']]\n    df_sample.to_csv(sample, index=False)","536ba725":"\n# LIGHTGBM\n#{'subsample': 0.7, 'objective': 'binary', 'num_iterations': 900, 'max_depth': 11, 'learning_rate': 0.07, 'lambda_l2': 0.01, 'lambda_l1': 0.005, 'boosting_type': 'goss'}\n# parameters for LightGBMClassifier\nparams = {'num_iterations': 900,\n          'objective' :'binary',\n          'learning_rate' : 0.08,\n          'boosting_type' : 'goss',\n          'max_depth': 12,\n          'metric': 'binary_logloss',\n          #'xgboost_dart_mode': True,\n          'lambda_l1': 0.01,\n          'lambda_l2': 0.01,\n          'subsample': 0.75 }\n\n# ----------------------------------------------------------------------------------------------------------------------\n# funciones que preparan los datos\njuntar_csvs(False)\njuntar_csvs(True)\n#funciones que entrenan el modelo\n#agrupados()\nresultado_final()","8745333b":"Crea el conjunto de entrenamiento o prepara la predicci\u00f3n para subir a Kaggle.","dce73708":"Librer\u00edas necesarias. Destaca lightgbm.","615edb47":"Esta funci\u00f3n limpia y prepara un poco por separado los csv's que se van a emplear.","58265fb6":"Par\u00e1metros  generales: nombres de ficheros y n\u00famero de ejemplos para entrenar (49999 para subir a Kaggle).","cfddf8d4":"Efectividad: \n\nhttps:\/\/www.kaggle.com\/vforvince1\/visualizing-data-and-predicting-pokemon-fights"}}