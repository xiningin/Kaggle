{"cell_type":{"44208634":"code","85f4453f":"code","7c06e55e":"code","8e3c3477":"code","4fce35f2":"code","fcbb8935":"code","f56f6481":"code","813766e5":"code","8838d943":"code","58372070":"code","cd07767b":"code","22a56b23":"code","4c5150f6":"code","8bb445b2":"code","fa9acc64":"code","5022ceba":"code","97effde5":"code","541e214b":"code","8166577b":"code","7ac0e3c1":"code","7a37a005":"markdown","59e170c0":"markdown","6b754fcb":"markdown","9f18fb88":"markdown","3d87bd40":"markdown","1d3b9f80":"markdown","e40f9c34":"markdown","5213e2f9":"markdown","a5d1dee7":"markdown","fcfd524e":"markdown","b5df4abe":"markdown","64809ac9":"markdown","711b4b6f":"markdown","c41596c6":"markdown","5f3181cf":"markdown","35698433":"markdown","2113454e":"markdown","5f33d30a":"markdown","10bc9ea0":"markdown","ab4955b8":"markdown","73124a33":"markdown","c89cb8de":"markdown","2c619ff6":"markdown"},"source":{"44208634":"# Importing the required Packages\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n","85f4453f":"#Task 1: Read 2 CSV Files - matches.csv and Deliverables.csv \n# The datasets have IPL match data across 2008 - 2017\n# matches.csv has 150460 rows\n# deliverable.csv has 636 rows\n\ndf_matches = pd.read_csv(\"\/kaggle\/input\/ipldata\/matches.csv\")\ndf_delv = pd.read_csv(\"\/kaggle\/input\/ipldata\/deliveries.csv\")","7c06e55e":"df_matches.head(1)","8e3c3477":"df_delv.head(1)","4fce35f2":"# getting required data from df_del\n\nsubset_df = pd.DataFrame()\ndf_delv['match_id'].unique()\ndf_delv[df_delv['match_id'] == 1][:1]\n\nfor match_id in range(1,637):\n        subset_df = subset_df.append(df_delv[df_delv['match_id'] == match_id][:1])\n        \n        \n# Steps Followed:\n\n#1. Merging\/Joining df_delv & df_matches df to get all the information we need\n    #- Joing is done on the match_id column of delv and id column of matches dataset\nmerged_df = pd.merge(df_matches, subset_df,left_on='id',right_on='match_id')\n#2. Take the subset of the df_delv DataFrame with the columns we need\ndf3 = merged_df[['city','batting_team','bowling_team','winner']]\n\n#3. Filtering the data where winner team is same as batting team \nbatting_wins = df3[df3['batting_team'] == df3['winner']]['city'].value_counts()\n\n#4. Filtering the data where winner team is same as bowling team \nbowling_wins = df3[df3['bowling_team'] == df3['winner']]['city'].value_counts()\n\nbatting = batting_wins.reset_index()\nbowling = bowling_wins.reset_index()\n\nbatting2 = batting.rename(columns={'index':'city','city':'batting_wins'})\nbowling2 = bowling.rename(columns={'index': 'city', 'city':'bowling_wins'})\n\nmerged_wins = pd.merge(batting2, bowling2, on='city')\nmerged_wins.head(2)","fcbb8935":"# Plotting\nplt.figure(figsize=(15,10))\n\nlabels = merged_wins.city\nbatting_wins = merged_wins.batting_wins\nbowling_wins = merged_wins.bowling_wins\n\nx = np.arange(len(labels))  # the label locations\nwidth = 0.35  # the width of the bars\n\nfig, ax = plt.subplots(figsize=(15,8))\nrects1 = ax.bar(x - width\/2, batting_wins, width, label='Matches won by Batting Team')\nrects2 = ax.bar(x + width\/2, bowling_wins, width, label='Matches won by Bowling Team')\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_ylabel('No of Matches', fontsize=15)\nax.set_title('Is bowling or batting first a better option at a given venue?', fontsize=20)\nax.set_xticks(x)\nax.set_xticklabels(labels, rotation=90, fontsize=15)\nax.legend(fontsize=15)\n\n\ndef autolabel(rects):\n    \"\"\"Attach a text label above each bar in *rects*, displaying its height.\"\"\"\n    for rect in rects:\n        height = rect.get_height()\n        ax.annotate('{}'.format(height),\n                    xy=(rect.get_x() + rect.get_width() \/ 2, height),\n                    xytext=(0, 3),  # 3 points vertical offset\n                    textcoords=\"offset points\",\n                    ha='center', va='bottom', fontsize=12)\n\n\nautolabel(rects1)\nautolabel(rects2)\n\nfig.tight_layout()\n\nplt.show();","f56f6481":"# Pie Chart:\nbatting_wins = merged_wins['batting_wins'].sum()\nbowling_wins = merged_wins['bowling_wins'].sum()\nprint((bowling_wins\/(bowling_wins+batting_wins))*100)\nplt.pie([batting_wins,bowling_wins],labels=['Batting','Bowling'], autopct='%1.1f%%', shadow=True, startangle=90)\nplt.show()","813766e5":"#Steps Followed:\n#1. # Finding for a sigle city - Hyderabad\n    #- subsetting only the data corresponding to one city to try the logic:\ndataset_hyd = df_matches[df_matches['city'] == 'Hyderabad']\n\n#2. Find the winning percentage for the winning tyeam\n    #- i.e. (Match count of Team that won maximum no of matches\/ no. of matches that took place there)*100\n(dataset_hyd['winner'].value_counts()[:1]\/dataset_hyd.shape[0])*100\n\n#3. Applying the same logic to all the cities by using groupby on city columns:\nx = df_matches.groupby('city').apply(lambda x: (x['winner'].value_counts()[:1]\/x.shape[0])*100)\n\n#4. resetting the indexes, so that the groupby object can be converted into a DataFrame - Easy to work with\nx = x.reset_index()\n\n#5. Rename columns accordingly\nx.rename(columns={'level_1': 'Winning_Team', 'winner':'winning_perc'}, inplace=True)\n\n#6. In the winning percentage columns, rounding the digit to get only the first decimal\nx.winning_perc = round(x.winning_perc,1)\n","8838d943":"# Plotting the graph:\n# Using Bar plot:\nplt.figure(figsize=(15,10))\n#plt.bar(x.city, x['winning_perc'], width=0.6)\ncolor_dict = {'Rajasthan Royals':'#A3D9EB', 'Royal Challengers Bangalore':'#e5b582',\n       'Delhi Daredevils':'#66ECDB', 'Deccan Chargers':'#E8EBA3', 'Kings XI Punjab':'#a8a9ac',\n       'Chennai Super Kings':'#fcce06', 'Kolkata Knight Riders':'#BEF5AF',\n       'Sunrisers Hyderabad':'#F37068', 'Gujarat Lions':'#ECCCB5', 'Kochi Tuskers Kerala':'#E4A3EB',\n       'Mumbai Indians':'#25E70D'}\n\n# The Below code is to have text inside of the bars.\n# We need to iterate through every row and set the text\n# I have given 2 texts here - 1. Name of the winning team, 2. The percentage of matches it won \nfor i in x.iterrows():\n    \n    plt.bar(i[1].city, i[1].winning_perc, width=0.6, color= color_dict[i[1].Winning_Team])\n    plt.text(i[1].city, i[1].winning_perc, i[1].Winning_Team, rotation=90, horizontalalignment='center',verticalalignment='top', color='black', fontsize=12)\n    plt.text(i[1].city, i[1].winning_perc, i[1].winning_perc, horizontalalignment='center', verticalalignment='bottom', fontsize=13)\n    \nplt.xticks(rotation=90, fontsize=12)\nplt.xlabel(\"Cities\", fontsize=12)\nplt.ylabel(\"% of matches won\", fontsize=12)\nplt.title(\"Is there a correlation between the Winning Team and \\nthe Location where the match is held?\", fontsize=18)\nplt.show()","58372070":"team_homelands = [['Rajasthan Royals','Jaipur'], ['Royal Challengers Bangalore','Bangalore'],\n       ['Delhi Daredevils','Delhi'], ['Deccan Chargers','Nagpur'], ['Kings XI Punjab','Chandigarh'],\n       ['Chennai Super Kings','Chennai'], ['Kolkata Knight Riders','Kolkata'],\n       ['Sunrisers Hyderabad','Hyderabad'], ['Gujarat Lions','Rajkot'], ['Kochi Tuskers Kerala','Kochi'],\n       ['Mumbai Indians','Mumbai']]\n\nhomelands_df = pd.DataFrame(team_homelands)\nhomelands_df\n\n# Merging the tables:\nteam_homeland = pd.merge(x,homelands_df, left_on='Winning_Team', right_on=0)\nteam_homeland = team_homeland.rename(columns={1:'homeland'})\n\nteam_homeland[team_homeland['city'] == team_homeland['homeland']]['winning_perc'].mean()","cd07767b":"# TrendLine for Top 15 Batsman:\n# i.e. Top 15 is calculated as \n#      - Batsmen who have scored the maximum number of \"Man of The Match\" in IPL in all the given seasons:\n\n# Shortlisting the top 15 and making it into a list object\na = df_matches['player_of_match'].value_counts()[:10]\nbest_batsmen_list = list(a.index)\n\n\n# By iterating through every batsman in the list, the mean of (batsman runs\/match) is calculated for every season\n# The result is updated into a dictionary: key: batsman_name value:Dataframe that contains season and batsman_runs average\n\n# This required me to merge data from df_matches and df_delv by match_id to get season info.\n\nbatsman_trend = pd.DataFrame()\ndictionary = {}\n\nfor batsman in best_batsmen_list:         \n    batsman_Y = df_delv[df_delv['batsman']== batsman]\n    s = batsman_Y.groupby(['match_id'],as_index=False)['batsman_runs'].sum()\n    merged = pd.merge(s,df_matches,left_on='match_id',right_on='id')\n    merged.season = merged.season.astype(int)\n    batsman_Y_per_season = merged.groupby(['season'], as_index=False)['batsman_runs'].mean()\n    dictionary.update({batsman:batsman_Y_per_season})\n \nfig = plt.figure(figsize=(15,15))\ni = 5\nj = 3\nk = 1\n\n# Iterating through all the values in the dictionary, line plot done for every batsman\n\nfor key,value in dictionary.items():   \n    \n    ax = plt.subplot(i,j,k)\n    #print(subplot)\n    ax.plot(value['season'],value['batsman_runs'], marker='*',color='#E45897')\n    title = str(\"Rank: \"+ str(k)+\" \"+key) \n    ax.set_title(title,fontsize=17,color=\"#558878\")\n    ax.set_xlabel(\"season\")\n    ax.set_ylabel(\"Average Runs\\nper match\", fontsize=13)\n    k = k+1\n\nplt.tight_layout()\nplt.show();\n    ","22a56b23":"# Calculating for 1 batsman:\nbatsman_1 = df_delv[df_delv['batsman'] == 'V Sehwag']\n#print((batsman_1[(batsman_1['batsman_runs'] == 4) | (batsman_1['batsman_runs'] == 6)]['batsman_runs'].count()\/batsman_1['batsman'].count())* 100)\n#batsman_1['batsman'].count()\n\n#get top batsmen: - batsmen who played atleast 50 balls total:\nx = df_delv.groupby('batsman',as_index=False)['match_id'].count()\nx = x[x['match_id'] >= 50]\n\n#x = df_delv['batsman'].value_counts()[:200]\nbatsman_list = pd.Index.tolist(x.batsman)\n#print(batsman_list)\nbatsmen_atleast_50_balls = pd.DataFrame()\n\nfor batsman in batsman_list:\n    #print(\"bowler: \", bowler)\n    x = df_delv[df_delv['batsman'] == batsman]\n    batsmen_atleast_50_balls = pd.concat([x,batsmen_atleast_50_balls])\n\n# DataFrame of all the data for players who played atleast 50 balls\n#batsmen_atleast_50_balls\n\n# Apply to all the batsman in the batsmen_atleast_50_balls DataFrame:\n\nhard_hitting = batsmen_atleast_50_balls.groupby('batsman').apply(lambda x: (x[(x['batsman_runs'] == 4) | (x['batsman_runs'] == 6)]['batsman_runs'].count()\/x['batsman'].count())* 100)\nhard_hitting = pd.DataFrame(hard_hitting.reset_index())\nhard_hitting.rename(columns={0:\"percentage_of_4_or_6\"}, inplace=True)\nhard_hitting_15 = hard_hitting.sort_values('percentage_of_4_or_6',ascending=False)[:15]\n#hard_hitting_15 ","4c5150f6":"color_band = ['#EF160F', '#EC5B1D', '#EC841D','#EC841D', '#ECDD5F','#E9F264','#D0F264','#A5E934','#6EF619','#19F6BF','#19F4F6','#19D0F6','#5FB7EE','#D484EF','#EF849E']\nplt.bar(hard_hitting_15['batsman'],hard_hitting_15['percentage_of_4_or_6'], width=0.5, color=color_band)\nplt.title(\"# Metric:1 Hard-Hitting Capability - Top 15\", fontsize=15)\nplt.xlabel('Batsman', fontsize=12)\nplt.ylabel(\"No of 4's or 6's hit in 100 balls\", fontsize=13)\nplt.xticks(rotation=90)\nplt.yticks(fontsize=12)\n\n#for i in hard_hitting_15.iterrows():\n    #plt.text(i[1]['percentage_of_4_or_6'],i[1].batsman, i[1].batsman, horizontalalignment='right', verticalalignment='center', color='black', fontsize=12)\n    #plt.text(i[1]['percentage_of_4_or_6'],i[1].batsman, round(i[1]['percentage_of_4_or_6'],1), horizontalalignment='left', verticalalignment='center', fontsize=13)\n    \nplt.show()","8bb445b2":"# 2. Finisher or not \n\nplayer_dismissed = df_delv[df_delv['player_dismissed'].notnull()][['match_id','batsman','non_striker','player_dismissed']]\n#p1 = player_dismissed[player_dismissed['match_id'] == 1\n#p1[p1['batsman'] != p1['player_dismissed']][['match_id','batsman']]\n\nfinishers = player_dismissed[player_dismissed['batsman'] != player_dismissed['player_dismissed']][['match_id','batsman']]\nfinishers.rename(columns={'batsman':'finisher'},inplace=True)\nfinishers = finishers['finisher'].value_counts()[:15]\n\nfinishers.plot.bar(color=color_band)\nplt.xlabel(\"Batsman\")\nplt.xticks(fontsize=12)\nplt.ylabel(\"No of matches - Not out\", fontsize=12)\nplt.title(\"# Metric:2 Top 15 finishers in IPL matches\", fontsize=15)\n\nplt.show()","fa9acc64":"# 3. Fast scoring ability - strike rate - Total runs\/Total balls\n\nd1 = df_delv[df_delv['batsman'] == 'S Dhawan'][['match_id','batsman','total_runs','batsman_runs']]\n#print(d1['total_runs'].sum()\/d1.shape[0])\nstrike_rate = pd.DataFrame()\nstrike_rate['batsman'] = pd.Series(df_delv['batsman'])\nstrike_rate['strike_rate'] = pd.Series(d1['total_runs'].sum() \/ d1.shape[0])\n\nstrike_rate.dropna()\n\ng = df_delv.groupby('batsman').apply(lambda x: (x['total_runs'].sum()\/x.shape[0])*100)\nstrike_rate = g.reset_index()\nstrike_rate.rename(columns={0:'strike_rate'}, inplace=True)\nstrike_rate_top_15 = strike_rate.sort_values('strike_rate', ascending=False)[:15]\n#strike_rate_top_15\n\nplt.bar(strike_rate_top_15['batsman'], strike_rate_top_15['strike_rate'], width=0.5, color=color_band)\nplt.xticks(rotation=90,fontsize=12)\nplt.xlabel(\"batsman\")\nplt.ylabel(\"strike_rate %\", fontsize=12)\nplt.title(\"#Metric:3 Strike rate (Batsman Runs in 100 Balls) of IPL batsmen - top 15\", fontsize=15)\n\n#for i in strike_rate_top_15.iterrows():\n    #plt.text(i[1]['percentage_of_4_or_6'],i[1].batsman, i[1].batsman, horizontalalignment='right', verticalalignment='center', color='black', fontsize=12)\n    #plt.text(i[1].batsman,i[1]['strike_rate'], round(i[1]['strike_rate'],1), horizontalalignment='center', verticalalignment='bottom', fontsize=13)\n\nplt.show()","5022ceba":"# 4. consistency - average (Total runs\/match)\n\nsubset = df_delv[df_delv['batsman'] == 'MS Dhoni'][['match_id','inning','batsman','batsman_runs']]\ns = subset.groupby(['match_id','batsman'], as_index=False)['batsman_runs'].sum()\nconsistency_1 = s.groupby('batsman',as_index=False)['batsman_runs'].mean()\nconsistency_1 \n\nTotal_runs_per_match = df_delv.groupby(['match_id','batsman'], as_index=False)['batsman_runs'].sum()\nconsistency_score = Total_runs_per_match.groupby('batsman',as_index=False)['batsman_runs'].mean()\nconsistency_score_15 = consistency_score.sort_values('batsman_runs',ascending=False)[:15]\n#consistency_score_15\n\nplt.bar(consistency_score_15['batsman'],consistency_score_15['batsman_runs'], width=0.5, color=color_band)\nplt.title(\"# Metric:4 Consistency Score: Average of Total Runs Per Match - Top 15\", fontsize=15)\nplt.xlabel('Batman')\nplt.xticks(rotation=90,fontsize=12)\nplt.ylabel(\"Average of (Total Runs\/match)\", fontsize=12)\nplt.show()","97effde5":"# 1. economy - no. of runs conceded\/over - average\n\n# Calculating for 1 Bowler\nbowler_1 = df_delv[df_delv['bowler'] == 'TS Mills'][['match_id','over','bowler','total_runs']]\nbowler_1\n\nruns_per_over = bowler_1.groupby(['match_id','over','bowler'], as_index=False)['total_runs'].sum()\nruns_per_over = runs_per_over['total_runs'].mean()\nruns_per_over\n\n#get top bowlers:\nx = df_delv['bowler'].value_counts()[:50]\nbowlers_list = pd.Index.tolist(x.index)\ntop_50_bowlers = pd.DataFrame()\n\nfor bowler in bowlers_list:\n    #print(\"bowler: \", bowler)\n    x = df_delv[df_delv['bowler'] == bowler]\n    top_50_bowlers = pd.concat([x,top_50_bowlers])\n\n#top_50_bowlers\n\n# Applying for top 50 Bowlers\nruns_per_over = top_50_bowlers.groupby(['match_id','over','bowler'], as_index=False)['total_runs'].sum()\neconomy = runs_per_over.groupby('bowler', as_index=False)['total_runs'].mean()\neconomy.rename(columns={'total_runs':'Average runs conceded per over'}, inplace=True)\neconomy_15 = economy.sort_values('Average runs conceded per over')[:15]\n#economy_15\n\nplt.bar(economy_15['bowler'],economy_15['Average runs conceded per over'], width=0.5, color=color_band)\nplt.title(\"#1. Economy score Bowlers - Average no. of runs conceded\/over - Top 15\", fontsize=15)\nplt.xlabel('Bowler')\nplt.xticks(rotation=90, fontsize=12)\nplt.ylabel(\"Average runs conceded per over\", fontsize=12)\nplt.yticks()\nplt.show()","541e214b":"# 2. wicket taking ability - wickets\/total no of balls*100\n\n#get top bowlers:\nx = df_delv['bowler'].value_counts()[:50]\nbowlers_list = pd.Index.tolist(x.index)\ntop_50_bowlers = pd.DataFrame()\n\nfor bowler in bowlers_list:\n    #print(\"bowler: \", bowler)\n    x = df_delv[df_delv['bowler'] == bowler]\n    top_50_bowlers = pd.concat([x,top_50_bowlers])\n\n#top_50_bowlers\n\n# Calculating for 1 bowler\nbowler_2 = top_50_bowlers[top_50_bowlers['bowler'] == 'TS Mills']\n#print(bowler_2['dismissal_kind'].count())\n#print(bowler_2.shape[0])\n#print((bowler_2['dismissal_kind'].count()\/bowler_2.shape[0])*100)\n\n# Applying for top 50 Bowlers:\nwicket_no_of_balls = top_50_bowlers.groupby('bowler').apply(lambda x: (x['dismissal_kind'].count()\/x.shape[0])*100 )\nwicket_no_of_balls = pd.DataFrame((wicket_no_of_balls.reset_index()))\nwicket_no_of_balls.rename(columns={0:\"wicket percentage\"}, inplace=True)\nwicket_no_of_balls_15 = wicket_no_of_balls.sort_values('wicket percentage',ascending=False)[:15]\n#wicket_no_of_balls_15\n\nplt.bar(wicket_no_of_balls_15['bowler'],wicket_no_of_balls_15['wicket percentage'], width=0.5, color=color_band)\nplt.title(\"#2. Wicket taking ability - Top 15\", fontsize=15)\nplt.xlabel(\"Bowler\")\nplt.xticks(rotation=90,fontsize=12)\nplt.ylabel(\"No. of wickets taken in 100 balls\", fontsize=12)\nplt.show()","8166577b":"#3. Consistency Score:\nbowler_2['bowler'].count()\/bowler_2['dismissal_kind'].count()\n\nconsistency_score = df_delv.groupby('bowler').apply(lambda x: x['bowler'].count()\/x['dismissal_kind'].count())\nconsistency_score = pd.DataFrame(consistency_score.reset_index())\nconsistency_score\nconsistency_score.rename(columns={0:'No. of Balls_per Wicket'}, inplace=True)\nconsistency_score_15_bowlers = consistency_score.sort_values('No. of Balls_per Wicket')[:15]\n#consistency_score_15_bowlers\n\nplt.bar(consistency_score_15_bowlers.bowler, consistency_score_15_bowlers['No. of Balls_per Wicket'], width=0.5, color=color_band)\nplt.title(\"#3. Consistency Score of Bowlers in IPL - Top 15\", fontsize=15)\nplt.xlabel('Bowler')\nplt.ylabel('No. of Balls_per Wicket', fontsize=12)\nplt.xticks(rotation=90, fontsize=12)\nplt.show()","7ac0e3c1":"# 4. crucial wicket taking ability \n# - how many time 4 or 5 wickets taken\/total no of innings played - high performance percentage\n\n#print(bowler_2['player_dismissed'].count()\/4)\n#print(bowler_2['match_id'].nunique())\n(bowler_2['player_dismissed'].count()\/4)\/bowler_2['match_id'].nunique()* 100\n\nhigh_performance_percentage = df_delv.groupby('bowler').apply(lambda x: (x['player_dismissed'].count()\/3)\/x['match_id'].nunique()* 100)\nhigh_performance_percentage = pd.DataFrame(high_performance_percentage.reset_index())\nhigh_performance_percentage.rename(columns={0:'performance percentage'}, inplace=True)\nhigh_performance_percentage_15 = high_performance_percentage.sort_values('performance percentage', ascending=False)[:15]\n\nplt.bar(high_performance_percentage_15['bowler'],high_performance_percentage_15['performance percentage'], width=0.5, color=color_band)\nplt.title(\"#4. Crucial Wicket taking ability - Top 15\", fontsize=15)\nplt.xlabel(\"Bowler\")\nplt.xticks(rotation=90,fontsize=12)\nplt.ylabel(\"Confidence that the bowler will take \\natleast 3 wickets in a Match\", fontsize=12)\nplt.show()","7a37a005":"### Metric 4: Consistency - average of (Total runs\/match)","59e170c0":"<img src=\"https:\/\/www.proathlix.com\/blog\/wp-content\/uploads\/2019\/03\/ipl.jpg\" width=400 height=400 \/>","6b754fcb":"### **Inference**\n\n1. From the graph, DA Warner, AB DE Villiers seems to have shown a consistent improvement in the performance.\n2. All the others have spikes representing, 1 match goes too well and another not so well.<br>\n3. Also the trend is shown only for batting scores. So if one of the top 10 (chosen as per 'Playerof the Match') is not a Batsman, then his trend could be weak in the above graphs.","9f18fb88":"### Inference:","3d87bd40":"### Question 2: Is there a correlation between the Winning Team and the Location where the match is held?","1d3b9f80":"### Question 1: Is bowling or batting first a better option at a given venue?","e40f9c34":"### Metric 2: Finisher or Not: No of Matches NOT OUT","5213e2f9":"### Metric 4: crucial wicket taking ability : how many time 4 or 5 wickets taken\/total no of innings played - high performance percentage","a5d1dee7":"<b>**Yes**<\/b>, From the graph, Bowling First seems to have a <b>**9%**<\/b> overall advantage over Batting\n1. It is clear that Bowling first has an Advantage over Batting in almost all the locations.\n2. However in Chennai the Batting Team has won <b>**64%**<\/b> of the times\n3. In Venues like Nagpur, Ahmedabad, Pune - There doesn't seem to be much difference.","fcfd524e":"### Metric 1: Hard hitting ability - no. of 4-s or 6-6 \/ Total number of balls played","b5df4abe":"## Bowler's Metrics\n\nThe Following Metrics are identified to represent the characteristics of a Bowler.\n\n  1. economy - no. of runs conceded\/over - average\n  2. wicket taking ability - wickets\/total no of balls*100\n  3. consistency - no of runs\/no of wickets\n  4. crucial wicket taking ability - how many time 4 or 5 wickets taken\/total no of innings played - high performance percentage\n \nI have calaculated the above Metrics for all the Batsmen. Based upon the score, top 15 Batsmen are determined and their Metrics are plotted.\n ","64809ac9":"1. Which Team wons maximum number of times in each location?\n2. Find the winning percentage for the winning tyeam","711b4b6f":"### Metrics 2: wicket taking ability - wickets\/total no of balls*100","c41596c6":"Yes, There is a high correlation between the Winning team and the Location of the Match\nOut of all the matches played in a Venue, on an average 51.3% of the matches were won by it's Home Team.\n\n1. From the graph, it is evident that the teams that play on their homeland wins maximum number of times\n2. So, a team playing in their Homeland have an Advantage.\n3. This could be because they are more familiar with the ground, the pitch etc.","5f3181cf":"**Using the IPL matches and IPL deliverables datasets, I have tried to do the following Descriptive Analytics.**<br>\n\n<b>**Question 1**:<\/b> Is bowling or batting first a better option at a given venue?<br>\n<b>**Question 2**:<\/b> Is there a correlation between the Winning Team and the Location where the match is held?<br>\n<b>**Question 3**:<\/b> Who are the top 10 Players? and what is their batting trend over years in IPL ?<br>\n<b>**Question 4**:<\/b> Identify and Analyse a good Batman's Characteristics?<br>\n<b>**Question 5**:<\/b> Identify and Analyse a good Bowler's Characteristics?<br>\n\nIf the above questions interest you, read further.\nI have provided the Python-Pandas Code and Explanation at every step as well.","35698433":"Calculating Top 10 Batsmen:\nI am going to pick the batsmen that scored 'Player_of_the_match' most number of the times in all the IPL matches so far.\nPlotiing the trend line:\nI am going to plot average(total batsman_runs per match) - plotting this score for every top Batsman across all the seasons of IPL","2113454e":"## Batsman's Metrics:\n\nThe Following Metrics are identified to represent the characteristics of a Batsman.\n\n 1. Hard hitting ability - no of 4\/6 \/ no of balls played\n 2. Finisher or not - No of matches not out\n 3. Fast scoring ability - strike rate - Total runs\/Total balls in every match - Average\n 4. consistency - average runs\/Match\n \n I have calaculated the above Metrics for all the Batsmen. Based upon the score, top 15 Batsmen are determined and their Metrics are plotted.","5f33d30a":"### Metric 3: Fast scoring ability - strike rate - Runs\/100 balls","10bc9ea0":"### Inference","ab4955b8":"### Question 3: Who are the top 10 Players and what is their batting trend over years in IPL ?","73124a33":"### Metric 1: economy - no. of runs conceded\/over - average","c89cb8de":"### Metrics 3: Consistency Score: No. of Balls_per Wicket","2c619ff6":"<h1><center>IPL data Analysis<br>Exploratory Analytics Using Pandas Python Packages<\/center><\/h1> "}}