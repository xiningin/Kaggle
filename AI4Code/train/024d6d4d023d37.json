{"cell_type":{"c186989f":"code","caa5410c":"code","dc12fc92":"code","aef04930":"code","7d8beb3f":"code","5e01a9f8":"code","b27ac303":"code","63a95947":"code","0fa03aa4":"code","e098e464":"code","afbddc42":"code","739fd448":"code","f3e72be8":"code","554d1b66":"code","f9135037":"code","fcf07bc6":"code","2c2eae28":"code","4f0aad4f":"code","1e3066d7":"code","9408de08":"code","4a7380bd":"code","b9a83232":"code","5b2f5b1d":"code","9f9537b3":"code","b33a9438":"code","db597799":"code","facbc66f":"code","a7c26f79":"code","d8f08843":"code","48c2453c":"code","2f834b73":"markdown","367ae2be":"markdown","c81b7dfe":"markdown","37451d7f":"markdown","cbbaa0c8":"markdown","7c4e2266":"markdown","4c03f397":"markdown","2ba40dd8":"markdown","66e5de1c":"markdown","6c95e8fe":"markdown","9cadd751":"markdown","c8af6f15":"markdown","554afa2d":"markdown","94b98211":"markdown","aa5a861b":"markdown","2c1b788b":"markdown","414f77bc":"markdown","13ea99d1":"markdown"},"source":{"c186989f":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn import linear_model\nfrom sklearn.model_selection import train_test_split\nimport gc\nimport warnings\nfrom IPython.display import Markdown, display ,HTML\nfrom sklearn.model_selection import GridSearchCV","caa5410c":"pd.set_option('display.max_columns', 100)\nwarnings.filterwarnings('ignore')\n\ndef log(string):\n    display(Markdown(\"> <span style='color:blue'>\"+str(string)+\"<\/span>\"))","dc12fc92":"# read the dataset\ndigits = pd.read_csv(\"..\/input\/train.csv\")\ndigits.info()","aef04930":"# head\ndigits.head()","7d8beb3f":"one = digits.iloc[2, 1:]\none.shape\none = one.values.reshape(28, 28)\nplt.imshow(one, cmap='gray')","5e01a9f8":"four = digits.iloc[3, 1:]\nfour.shape\nfour = four.values.reshape(28, 28)\nplt.imshow(four, cmap='gray')","b27ac303":"# visualise the array\nprint(four[5:-5, 5:-5])","63a95947":"# Summarise the counts of 'label' to see how many labels of each digit are present\ncount = pd.DataFrame(digits.label.astype('category').value_counts()).sort_index()\ncount = count.rename(columns={'label': 'Count'})","0fa03aa4":"# Summarise count in terms of percentage \npercetage = pd.DataFrame(100*(round(digits.label.astype('category').value_counts()\/len(digits.index), 4))).sort_index()\npercetage = percetage.rename(columns={'label': 'Percetage'})\n","e098e464":"pd.concat([count, percetage], axis=1, join_axes=[count.index])","afbddc42":"# missing values - there are none\n#digits.isnull().sum()\n\n## no null vales in dataset","739fd448":"# average values\/distributions of features\ndescription = digits.describe()\ndescription","f3e72be8":"# Creating training and test sets\n# Splitting the data into train and test\nX = digits.iloc[:, 1:]\nY = digits.iloc[:, 0]\n\n# Rescaling the features\nfrom sklearn.preprocessing import scale\nX = scale(X)\n\n# train test split with train_size=10% and test size=90%\nx_train, x_test, y_train, y_test = train_test_split(X, Y, train_size=0.90, random_state=101)\nprint(x_train.shape)\nprint(x_test.shape)\nprint(y_train.shape)\nprint(y_test.shape)\n","554d1b66":"# delete test set from memory, to avoid a memory error\n# we'll anyway use CV to evaluate the model, and can use the separate test.csv file as well\n# to evaluate the model finally\n\n# del x_test\n# del y_test","f9135037":"from sklearn import svm\nfrom sklearn import metrics\n\n# an initial SVM model with linear kernel   \nsvm_linear = svm.SVC(kernel='linear')\n\n# fit\nsvm_linear.fit(x_train, y_train)","fcf07bc6":"# predict\npredictions = svm_linear.predict(x_test)\npredictions[:10]","2c2eae28":"# evaluation: accuracy\n# C(i, j) represents the number of points known to be in class i \n# but predicted to be in class j\nconfusion = metrics.confusion_matrix(y_true = y_test, y_pred = predictions)\nconfusion","4f0aad4f":"# measure accuracy\nlog(metrics.accuracy_score(y_true=y_test, y_pred=predictions))","1e3066d7":"# class-wise accuracy\nclass_wise = metrics.classification_report(y_true=y_test, y_pred=predictions)\nprint(class_wise)","9408de08":"# run gc.collect() (garbage collect) to free up memory\n# else, since the dataset is large and SVM is computationally heavy,\n# it'll throw a memory error while training\nlog(\"Memory Claimed : \"+str(gc.collect()))","4a7380bd":"# rbf kernel with other hyperparameters kept to default \nsvm_rbf = svm.SVC(kernel='rbf')\nsvm_rbf.fit(x_train, y_train)","b9a83232":"# predict\npredictions = svm_rbf.predict(x_test)\n\n# accuracy \nlog(metrics.accuracy_score(y_true=y_test, y_pred=predictions))","5b2f5b1d":"# conduct (grid search) cross-validation to find the optimal values \n# of cost C and the choice of kernel\n\n\n\nparameters = {'C':[1, 10, 100], \n             'gamma': [1e-2, 1e-3, 1e-4]}\n\n# instantiate a model \nsvc_grid_search = svm.SVC(kernel=\"rbf\")\n\n# create a classifier to perform grid search\nclf = GridSearchCV(svc_grid_search, param_grid=parameters, scoring='accuracy',return_train_score=True)\n\n# fit\nclf.fit(x_train, y_train)","9f9537b3":"# results\ncv_results = pd.DataFrame(clf.cv_results_)\ncv_results","b33a9438":"def plot_accuracy_graph(location,gamma_value) :\n    plt.subplot(location)\n    gamma = cv_results[cv_results['param_gamma']==gamma_value]\n    plt.plot(gamma[\"param_C\"], gamma[\"mean_test_score\"])\n    plt.plot(gamma[\"param_C\"], gamma[\"mean_train_score\"])\n    plt.xlabel('C')\n    plt.ylabel('Accuracy')\n    plt.title(\"Gamma=\"+str(gamma_value))\n    plt.ylim([0.60, 1])\n    plt.legend(['test accuracy', 'train accuracy'], loc='lower right')\n    plt.xscale('log')","db597799":"# converting C to numeric type for plotting on x-axis\ncv_results['param_C'] = cv_results['param_C'].astype('int')\n\n# # plotting\nplt.figure(figsize=(16,6))\n\n# subplot 1\/3\nplot_accuracy_graph(131,0.01)\nplot_accuracy_graph(132,0.001)\nplot_accuracy_graph(133,0.0001)\n\nplt.show()","facbc66f":"print(clf.best_score_)\nprint(clf.best_params_)","a7c26f79":"# optimal hyperparameters\nbest_C = 10\nbest_gamma = 0.001\n\n\n# model\nsvm_final = svm.SVC(kernel='rbf', C=best_C, gamma=best_gamma)\n\n# fit\nsvm_final.fit(x_train, y_train)","d8f08843":"# predict\npredictions = svm_final.predict(x_test)","48c2453c":"# evaluation: CM \nconfusion = metrics.confusion_matrix(y_true = y_test, y_pred = predictions)\n\n# measure accuracy\ntest_accuracy = metrics.accuracy_score(y_true=y_test, y_pred=predictions)\n\nlog(test_accuracy)\nprint(confusion)\n","2f834b73":"#### Side note: Indexing Recall ####\n`list =    [0, 4, 2, 10, 22, 101, 10]` <br>\n`indices = [0, 1, 2, 3, ...,        ]` <br>\n`reverse = [-n           -3  -2   -1]` <br>","367ae2be":"### Non-Linear SVM\n\nLet's now try a non-linear model with the RBF kernel.","c81b7dfe":"### Conclusion\n\nThe final accuracy on test data is approx. 96.90%. \n\n","37451d7f":"### User Prefrences  ","cbbaa0c8":"### Importing Libraries","7c4e2266":"Also, let's look at the average values of each column, since we'll need to do some rescaling in case the ranges vary too much.","4c03f397":"## Data Understanding and Cleaning\n \n Let's understand the dataset and see if it needs some cleaning etc.","2ba40dd8":"### Reading data ","66e5de1c":"# Data Description\nFor this problem, we use the MNIST data which is a large database of handwritten digits. The 'pixel values' of each digit (image) comprise the features, and the actual number between 0-9 is the label. \n\nSince each image is of 28 x 28 pixels, and each pixel forms a feature, there are 784 features. MNIST digit recognition is a well-studied problem in the ML community, and people have trained numerous models (Neural Networks, SVMs, boosted trees etc.) achieving error rates as low as 0.23% (i.e. accuracy = 99.77%, with a convolutional neural network).\n\nBefore the popularity of neural networks, though, models such as SVMs and boosted trees were the state-of-the-art in such problems. In this assigment we will build model with **SVM** only.","6c95e8fe":"### Final Model\n\nLet's now build the final model with chosen hyperparameters.","9cadd751":"## Data Preparation for Model Building\n\nLet's now prepare the dataset for building the model. We'll only use a fraction of the data else training will take a long time.\n","c8af6f15":"You can see that the max value of the mean and maximum values of some features (pixels) is 139, 255 etc., whereas most features lie in much lower ranges  (look at description of pixel 0, pixel 1 etc. above).\n\nThus, it seems like a good idea to rescale the features.","554afa2d":"## Model Building\n\nLet's now build the model and tune the hyperparameters. Let's start with a **linear model** first.\n\n### Linear SVM\n\nLet's first try building a linear SVM model (i.e. a linear kernel). ","94b98211":"Thus, each digit\/label has an approximately 9%-11% fraction in the dataset and the **dataset is balanced**. This is an important factor in considering the choices of models to be used, especially SVM, since **SVMs rarely perform well on imbalanced data**.\nLet's quickly look at missing values, if any.","aa5a861b":"The accuracy achieved with a non-linear kernel is slightly higher than a linear one. Let's now do a grid search CV to tune the hyperparameters C and gamma.\n\n### Grid Search Cross-Validation","2c1b788b":"From the plot above, we can observe that (from higher to lower gamma \/ left to right):\n- At very high gamma (0.01), the model is achieving 100% accuracy on the training data, though the test score is quite low (<75%). Thus, the model is overfitting.\n\n- At gamma=0.001, the training and test scores are comparable at around C=1, though the model starts to overfit at higher values of C\n\n- At gamma=0.0001, the model does not overfit till C=10 but starts showing signs at C=100. Also, the training and test scores are slightly lower than at gamma=0.001.\n\nThus, it seems that the best combination is gamma=0.001 and C=1 (the plot in the middle), which gives the highest test accuracy (~92%) while avoiding overfitting.\n\nLet's now build the final model and see the performance on test data.\n\n","414f77bc":"# Objective\nYou are required to develop a model using Support Vector Machine which should correctly classify the handwritten digits from 0-9 based on the pixel values given as features. Thus, this is a 10-class classification problem. ","13ea99d1":"# Approach\n\nWe'll divide the analysis into the following parts:\n- Data understanding and cleaning\n- Data preparation for model building\n- Building an SVM model - hyperparameter tuning, model evaluation etc.\n"}}