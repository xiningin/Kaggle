{"cell_type":{"99ae4abe":"code","1fd7bd10":"code","05e39136":"code","2f5b24e2":"code","2c27ccda":"code","09a50b3e":"code","b2e726ab":"code","11218959":"code","20e0e574":"code","96009969":"code","cbd3bc17":"code","97fa25ec":"code","335ee22a":"code","42847bd3":"code","5fb5921b":"markdown","6b92977a":"markdown","cf1fb07c":"markdown","c4b75097":"markdown","45273820":"markdown","25e8c477":"markdown","de6e7d69":"markdown","e5ca76c5":"markdown"},"source":{"99ae4abe":"#Librer\u00edas para la implementaci\u00f3n de la CNN\nimport numpy as np\nimport pandas as pd\nimport torch\nfrom torchvision import datasets, transforms\nfrom torch import nn, optim\nimport torch.nn.functional as F\n\n#Librer\u00eda para separar train set del validation set\nfrom sklearn.model_selection import train_test_split\n\n#Librer\u00eda para el uso de gr\u00e1ficas\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\nplt.rcParams['figure.figsize'] = (7.0, 4.0) # set default size of plots\nplt.rcParams['image.interpolation'] = 'nearest'\nplt.rcParams['image.cmap'] = 'gray'\n\n#Manejo de data files\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n#Random seed\nnp.random.seed(1)","1fd7bd10":"#Import de la Data\n\ntrain = pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")\ntest = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\n\n\n#Dimensiones del train y test set\nprint('Train Shape:', train.shape)\nprint('Test Shape:', test.shape)","05e39136":"#Separaci\u00f3n del train set en: train set y validation set (80% - 20%)\nx_train, x_validation, y_train, y_validation = train_test_split(train.values[:,1:], train.values[:,0], test_size=0.2)\naux = np.zeros(test.shape)\n\n#Se estandariza la data al dividirlos entre 255 \ntrain_set = torch.utils.data.TensorDataset(torch.from_numpy(x_train.astype(np.float32)\/255), torch.from_numpy(y_train))\n\nval_set = torch.utils.data.TensorDataset(torch.from_numpy(x_validation.astype(np.float32)\/255), torch.from_numpy(y_validation))\n\ntest_set = torch.utils.data.TensorDataset(torch.from_numpy(test.values[:,:].astype(np.float32)\/255), torch.from_numpy(aux).type(torch.FloatTensor))\n\n#Definici\u00f3n del batch size\nbatch_size = 64\n\n#Data loaders\ntrain_loader = torch.utils.data.DataLoader(train_set, batch_size = batch_size, shuffle = True)\nval_loader = torch.utils.data.DataLoader(val_set, batch_size = batch_size, shuffle = False)\ntest_loader = torch.utils.data.DataLoader(test_set, batch_size = batch_size, shuffle = False)","2f5b24e2":"#Mostrar ejemplo de la data\ndataiter = iter(train_loader)\nimages, labels = dataiter.next()\n\nimg = images[0]\nimg = img.numpy()\nimg = img.reshape(28,28)\n\n\nfig = plt.figure(figsize = (5,5)) \nax = fig.add_subplot(111)\nax.imshow(img, cmap='gray')","2c27ccda":"class Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        # Convolutional layers with Batch Normalization\n        self.conv1 = nn.Conv2d(1, 6, 5)\n        self.bn1 = nn.BatchNorm2d(6)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.bn2 = nn.BatchNorm2d(16)\n        \n        #Pooling layer\n        self.pool = nn.AvgPool2d((2,2), stride = 2)\n        \n        #Linear Layers with Batch Normalization\n        self.fc1 = nn.Linear(256, 240)\n        self.bn3 = nn.BatchNorm1d(240)\n        self.fc2 = nn.Linear(240, 120)\n        self.bn4 = nn.BatchNorm1d(120)\n        self.fc3 = nn.Linear(120, 10)\n        \n        #Dropout\n        self.dropout = nn.Dropout(0.2)\n        \n    def forward(self, x):\n        # Flatten image\n        x = x.view(-1, 1, 28, 28)\n        #Convolutional layers\n        x = self.pool(F.relu(self.bn1(self.conv1(x))))\n        x = self.dropout(x)\n        x = self.pool(F.relu(self.bn2(self.conv2(x))))\n        x = self.dropout(x)\n        \n        #Flatten image\n        x = x.view(-1, 4*4*16)\n        #Linear layers\n        x = F.relu(self.bn3(self.fc1(x)))\n        x = self.dropout(x)\n        x = F.relu(self.bn4(self.fc2(x)))\n        x = self.dropout(x)\n        x = F.log_softmax(self.fc3(x), dim = 1)\n        \n        return x","09a50b3e":"def weights_init_xavier_normal(m):\n    \n    classname = m.__class__.__name__\n    # for every Linear layer in a model\n    if (classname.find('Linear') != -1) or (classname.find('Conv2d') != -1):\n      nn.init.xavier_normal_(m.weight.data, gain=nn.init.calculate_gain('relu'))\n      m.bias.data.fill_(0)","b2e726ab":"model = Net()\nmodel.apply(weights_init_xavier_normal)\nprint(model)","11218959":"#Loss Function\ncriterion = nn.CrossEntropyLoss()\n#Optimizer\noptimizer = torch.optim.Adam(model.parameters(), lr=0.003)","20e0e574":"#number of epochs to train the model\nepochs = 60\nsteps = 0\nm_train = len(train_loader)\nm_validation = len(val_loader)\n\ntrain_losses, val_losses, train_acc, val_acc = [],[],[],[]\n\nfor epoch in range(epochs):\n    print('epoch: ', epoch+1)\n    train_loss = 0.0\n    val_loss = 0.0\n    total_train = 0.0\n    correct_train = 0.0\n    total_validation = 0.0\n    correct_validation = 0.0\n    train_accuracy = 0.0\n    val_accuracy = 0.0\n    \n    model.train()\n    for images, labels in train_loader:\n        \n        optimizer.zero_grad()\n        out = model(images)\n        loss = criterion(out, labels)\n        loss.backward()\n        optimizer.step()\n        \n        train_loss += loss.item()*images.size(0)\n        \n        _, predicted = torch.max(out, 1)\n        total_train += labels.size(0)\n        correct_train += (predicted == labels).sum()\n        \n    \n    else:\n        #Validacion\n        with torch.no_grad():\n            model.eval()\n            for images, labels in val_loader:\n                \n                out = model(images)\n                loss = criterion(out, labels)\n                \n                val_loss += loss.item()*images.size(0)\n                \n                _, predicted = torch.max(out, 1)\n                total_validation += labels.size(0)\n                correct_validation += (predicted == labels).sum()\n            \n            #Calculo de loss y accuracy\n            \n            #loss\n            train_loss = train_loss \/ m_train\n            val_loss = val_loss \/ m_validation\n            train_losses.append(train_loss)\n            val_losses.append(val_loss)\n            \n            #accuracy\n            train_accuracy = correct_train.item() \/ total_train\n            val_accuracy = correct_validation.item() \/ total_validation\n            \n            train_acc.append(train_accuracy)\n            val_acc.append(val_accuracy)\n            \n            print('Train loss: ', train_loss)\n            print('Validation loss: ', val_loss)\n            print('Train accuracy: ', train_accuracy)\n            print('Validation accuracy: ', val_accuracy)\n            print('------------------------------------')","96009969":"plt.plot(train_losses)\nplt.plot(val_losses)\nplt.ylabel('Loss')\nplt.xlabel('Epoch')\nplt.legend(['Training Loss','Validation Loss'])\nplt.title(\"Loss\")\nplt.show()","cbd3bc17":"plt.plot(train_acc)\nplt.plot(val_acc)\nplt.ylabel('Accuracy')\nplt.xlabel('Epoch')\nplt.legend(['Training Accuracy','Validation Accuracy'])\nplt.title(\"Accuracy\")\nplt.show()","97fa25ec":"dataiter = iter(train_loader)\nimages, labels = dataiter.next()\n\nimg = images[0]\nimg = img.numpy()\nimg = img.reshape(28,28)\n\n\nfig = plt.figure(figsize = (5,5)) \nax = fig.add_subplot(111)\nax.imshow(img, cmap='gray')","335ee22a":"image_id, label = [],[]\n\nfor images,labels in test_loader:\n    \n    out = model(images)\n    labels, pred_test = torch.max(out,1)\n    \n    for i in range(len(pred_test)):        \n        image_id.append(len(image_id)+1)\n        label.append(pred_test[i].numpy())\n        \nfinal = pd.DataFrame(data={'ImageId':image_id, 'Label':label})\nfinal.describe","42847bd3":"print(final.head())\nfinal.to_csv('submission.csv', index=False)","5fb5921b":"## **Arquitectura del modelo**","6b92977a":"## **Visualizaci\u00f3n de la data**","cf1fb07c":"## **Imports**","c4b75097":"## **Preprocesamiento de datos**","45273820":"## **Entrenamiento del Modelo**","25e8c477":"## **Inicializaci\u00f3n de par\u00e1metros**","de6e7d69":"# **Proyecto 1 - RodriguezSansonetti**","e5ca76c5":"## **Prueba del Modelo**"}}