{"cell_type":{"c08c9083":"code","897f37da":"code","3907eb09":"code","42d633fa":"code","f9133c92":"code","64c8a273":"code","d1141cbe":"code","9285b396":"code","6774e945":"code","b3d558fa":"code","5ac92e83":"code","673033c1":"code","e7e3ffe5":"markdown","6e6c4677":"markdown","579b447b":"markdown","911557e3":"markdown","f0e2e5b5":"markdown","0c2a42bc":"markdown","96b0ed4b":"markdown","9e08c723":"markdown","9782a1e5":"markdown","486782e8":"markdown","90ef9f99":"markdown"},"source":{"c08c9083":"from pathlib import Path\n\nDATA_DIR = Path(\"\/kaggle\/input\")\nif (DATA_DIR \/ \"ucfai-core-fa19-gans\").exists():\n    DATA_DIR \/= \"ucfai-core-fa19-gans\"\nelif DATA_DIR.exists():\n    # no-op to keep the proper data path for Kaggle\n    pass\nelse:\n    # You'll need to download the data from Kaggle and place it in the `data\/`\n    #   directory beside this notebook.\n    # The data should be here: https:\/\/kaggle.com\/c\/ucfai-core-fa19-gans\/data\n    DATA_DIR = Path(\"data\")","897f37da":"# general imports\nimport numpy as np\nimport time\nimport os\nimport math\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom IPython.display import HTML\n\n# torch imports\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch.backends.cudnn as cudnn\nimport torchvision.transforms as transforms\n\nfrom torch.utils.data import DataLoader\nfrom torchvision.datasets import ImageFolder\n\nimport torchvision.utils as vutils\nfrom torch.utils.data import random_split\n\n# uncomment to use specific seed for randomly generating weights and noise\n# seed = 999\n# torch.manual_seed(seed)\n","3907eb09":"try:\n    import torchsummary\nexcept:\n    torchsummary = None\n\nfrom tabulate import tabulate\n\nBATCH_TEMPLATE = \"Epoch [{} \/ {}], Batch [{} \/ {}]:\"\nEPOCH_TEMPLATE = \"Epoch [{} \/ {}]:\"\nTEST_TEMPLATE = \"Epoch [{}] Test:\"\n\ndef print_iter(\n    curr_epoch=None,\n    epochs=None,\n    batch_i=None,\n    num_batches=None,\n    writer=None,\n    msg=False,\n    **kwargs):\n    \"\"\"\n    Formats an iteration. kwargs should be a variable amount of metrics=vals\n    Optional Arguments:\n        curr_epoch(int): current epoch number (should be in range [0, epochs - 1])\n        epochs(int): total number of epochs\n        batch_i(int): current batch iteration\n        num_batches(int): total number of batches\n        writer(SummaryWriter): tensorboardX summary writer object\n        msg(bool): if true, doesn't print but returns the message string\n\n    if curr_epoch and epochs is defined, will format end of epoch iteration\n    if batch_i and num_batches is also defined, will define a batch iteration\n    if curr_epoch is only defined, defines a validation (testing) iteration\n    if none of these are defined, defines a single testing iteration\n    if writer is not defined, metrics are not saved to tensorboard\n    \"\"\"\n    if curr_epoch is not None:\n        if batch_i is not None and num_batches is not None and epochs is not None:\n            out = BATCH_TEMPLATE.format(curr_epoch + 1, epochs, batch_i, num_batches)\n        elif epochs is not None:\n            out = EPOCH_TEMPLATE.format(curr_epoch + 1, epochs)\n        else:\n            out = TEST_TEMPLATE.format(curr_epoch + 1)\n    else:\n        out = \"Testing Results:\"\n\n    floatfmt = []\n    for metric, val in kwargs.items():\n        if \"loss\" in metric or \"recall\" in metric or \"alarm\" in metric or \"prec\" in metric:\n            floatfmt.append(\".4f\")\n        elif \"accuracy\" in metric or \"acc\" in metric:\n            floatfmt.append(\".2f\")\n        else:\n            floatfmt.append(\".6f\")\n\n        if writer and curr_epoch:\n            writer.add_scalar(metric, val, curr_epoch)\n        elif writer and batch_i:\n            writer.add_scalar(metric, val, batch_i * (curr_epoch + 1))\n\n    out += \"\\n\" + tabulate(kwargs.items(), headers=[\"Metric\", \"Value\"],\n                           tablefmt='github', floatfmt=floatfmt)\n\n    if msg:\n        return out\n    print(out)\n\n\ndef summary(model, input_dim):\n    if torchsummary is None:\n        raise(ModuleNotFoundError, \"TorchSummary was not found!\")\n    torchsummary.summary(model, input_dim)","42d633fa":"image_size = (64, 64)\nbatch_size = 128\nnum_workers = 4\n\n# I'm sorry little one\nthanos_level = 4\n\ndataset = ImageFolder(\n    str(DATA_DIR),\n    transform=transforms.Compose([\n        transforms.Resize(image_size),\n        transforms.CenterCrop(image_size),\n        transforms.ToTensor(),\n        transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),\n    ])\n)\n\n# comment out if you want to use whole dataset\ndataset, _ = random_split(dataset,\n                          [int(len(dataset) \/ thanos_level),\n                           len(dataset) - int((len(dataset) \/ thanos_level))])\n\n# TODO: Create the dataloader from our dataset above\n# YOUR CODE HERE\nraise NotImplementedError()\n\nprint(\"Length of dataset: {}, dataloader: {}\".format(len(dataset), len(dataloader)))\n\n# Plot some training images\nreal_batch = next(iter(dataloader))\nplt.figure(figsize=(8,8))\nplt.axis(\"off\")\nplt.title(\"Training Images\")\nplt.imshow(np.transpose(vutils.make_grid(real_batch[0][:64], padding=2, normalize=True).cpu(),(1,2,0)))","f9133c92":"def get_padding(output_dim, input_dim, kernel_size, stride):\n    \"\"\"\n    Calculates padding given in output and input dim, and parameters of the\n    convolutional layer\n\n    Arguments should all be integers. Use this function to calculate padding\n    for 1 dimesion at a time.\n    Output dimensions should be the same or bigger than input dimensions\n\n    Returns 0 if invalid arguments were passed, otherwise returns an int or\n    tuple that represents the padding.\n    \"\"\"\n\n    padding = (((output_dim - 1) * stride) - input_dim + kernel_size) \/\/ 2\n\n    if padding < 0:\n        return 0\n    else:\n        return padding\n\nprint(get_padding(32, 64, 4, 2))","64c8a273":"def gen_block(input_channels, output_channels, kernel_size, stride, padding):\n    layers = [nn.ConvTranspose2d(input_channels,\n                                 output_channels,\n                                 kernel_size,\n                                 stride=stride,\n                                 padding=padding,\n                                 bias=False)]\n    layers += [nn.BatchNorm2d(output_channels)]\n    layers += [nn.ReLU(inplace=True)]\n    \n    return layers\n    \nclass Generator(nn.Module):\n    def __init__(self, channels=3, input_size=100, output_dim=64):\n        super(Generator, self).__init__()\n        self.channels = channels\n        self.input_size = input_size\n        self.output_size = output_dim\n        self.layers = self.build_layers()\n        \n    def forward(self, x):\n        return self.layers(x).squeeze()\n    \n    def build_layers(self):\n        layers = []\n        in_c = self.input_size\n        out_c = self.output_size * 8\n        \n        # dim: out_c x 4 x 4\n        layers += gen_block(in_c, out_c, 4, 1, 0)\n        in_c = out_c\n        out_c = self.output_size * 4\n        \n        # TODO: Create the next two blocks the same way the above one is created\n        # Use kernel size of 4 and a stride of 2. Whats the padding?\n        # YOUR CODE HERE\n        raise NotImplementedError()\n        # dim: out_c x 32 x 32\n        layers += gen_block(in_c, out_c, 4, 2, 1)\n        in_c = out_c\n        out_c = self.channels\n        \n        # dim: out_c x 64 x 64\n        # don't use batch norm in the last layer since its the output.\n        layers += [nn.ConvTranspose2d(in_c, out_c, 4, 2, 1), nn.Tanh()]\n        \n        return nn.Sequential(*layers)","d1141cbe":"def discrim_block(input_channels, output_channels, kernel_size, stride, padding):\n    layers = [nn.Conv2d(input_channels,\n                        output_channels,\n                        kernel_size,\n                        stride=stride,\n                        padding=padding,\n                        bias=False)]\n    layers += [nn.BatchNorm2d(output_channels)]\n    layers += [nn.LeakyReLU(0.2, inplace=True)]\n    \n    return layers\n\nclass Discriminator(nn.Module):\n    def __init__(self, channels=3, input_dim=64):\n        super(Discriminator, self).__init__()\n        self.channels = channels\n        self.input_dim = input_dim\n        self.layers = self.build_layers()\n        \n    def forward(self, x):\n        return self.layers(x).squeeze()\n    \n    def build_layers(self):\n        layers = []\n        in_c = self.channels\n        out_c = self.input_dim\n        \n        # dim: out_c x 32 x 32\n        layers += [nn.Conv2d(in_c, out_c, 4, 2, 1, bias=False), nn.LeakyReLU(0.2, inplace=True)]\n        in_c = out_c\n        out_c = self.input_dim * 2\n        # TODO: Create the next 2 blocks for the discriminator. Kernel size of 4 and a stride of 2\n        # this is quite similar to the generator...\n        # YOUR CODE HERE\n        raise NotImplementedError()\n        # dim: out_c x 4 x 4\n        layers += discrim_block(in_c, out_c, 4, 2, 1)\n        in_c = out_c\n        out_c = 1\n        \n        # dim: 1\n        layers += [nn.Conv2d(in_c, out_c, 4, 1, 0), nn.Sigmoid()]\n        \n        return nn.Sequential(*layers)\n        ","9285b396":"def weights_init(m):\n    classname = m.__class__.__name__\n    if classname.find('Conv') != -1:\n        nn.init.normal_(m.weight.data, 0.0, 0.02)\n    elif classname.find('BatchNorm') != -1:\n        nn.init.normal_(m.weight.data, 1.0, 0.02)\n        nn.init.constant_(m.bias.data, 0)","6774e945":"gen_input = 100\ngen_output = 64\n\ngen = Generator(input_size=gen_input, output_dim=gen_output)\ngen.apply(weights_init)\ndiscrim = Discriminator(channels=3, input_dim=gen_output)\ndiscrim.apply(weights_init)\n\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\nprint(\"Using device: {}\".format(device))\ngen.to(device)\ndiscrim.to(device)\n\n# hyperparameters from DCGAN paper\nlearn_rate = 0.0002\n\noptG = optim.Adam(gen.parameters(), lr=learn_rate, betas=(0.5, 0.999))\noptD = optim.Adam(discrim.parameters(), lr=learn_rate, betas=(0.5, 0.999))\n\n# TODO: Define our criterion (loss function)\n# YOUR CODE HERE\nraise NotImplementedError()\nfixed_noise = torch.randn(gen_output, gen_input, 1, 1, device=device)\n\nreal_label = 1\nfake_label = 0\n\nprint(\"Generator:\")\nsummary(gen, (gen_input, 1, 1))\nprint(\"\\nDiscriminator:\")\nsummary(discrim, (3, gen_output, gen_output))","b3d558fa":"start_time = time.time()\n\nepochs = 5\nprint_step = 50\n\ngen_imgs = []\n\nfor e in range(epochs):\n    g_train_loss = 0\n    d_train_loss = 0\n    e_time = time.time()\n    \n    for i, data in enumerate(dataloader):\n\n        # Train Discriminator\n        \n        # only need images from data, don't care about class from ImageFolder\n        images = data[0].to(device)\n        b_size = images.size(0)\n        labels = torch.full((b_size,), real_label, device=device)\n        \n        # train on real\n        discrim.zero_grad()\n        d_output = discrim(images).view(-1)\n        loss_real = criterion(d_output, labels)\n        loss_real.backward()\n      \n        # get fake data from generator\n        noise = torch.randn(b_size, gen_input, 1, 1, device=device)\n        fake_images = gen(noise)\n        # this replaces all values in labels with fake_label, which is zero in this case\n        labels.fill_(fake_label)\n        \n        # calculate loss and update gradients on fake\n        # must detach the fake images from the computational graph of the\n        #   generator, so that gradients arent updated for the generator\n        d_output = discrim(fake_images.detach()).view(-1)\n        loss_fake = criterion(d_output, labels)\n        loss_fake.backward()\n        \n        # add up real and fake loss\n        d_loss = loss_real + loss_fake\n        \n        # optimize weights after calculating real and fake loss then\n        #   backprogating on each\n        optD.step()\n        \n        d_train_loss += d_loss.item()\n        \n        # Train Generator\n        gen.zero_grad()\n        labels.fill_(real_label)\n        # get new output from discriminator for fake images, which is now\n        #   updated from our above step\n        d_output = discrim(fake_images).view(-1)\n        # calculate the Generator's loss based on this, use real_labels since\n        #   fake images should be real for generator\n        # i.e the generator wants the discriminator to output real for it's fake\n        #   images, so thats the target for generator\n        g_loss = criterion(d_output, labels)\n        g_loss.backward()\n        optG.step()\n        \n        g_train_loss += g_loss.item()\n        \n        if i % print_step == 0:\n            print_iter(\n                curr_epoch=e,\n                epochs=epochs,\n                batch_i=i,\n                num_batches=len(dataloader),\n                d_loss=d_train_loss \/ (i + 1),\n                g_loss=g_train_loss \/ (i + 1))\n            # save example images\n            gen.eval()\n            with torch.no_grad():\n                fake_images = gen(fixed_noise).detach().cpu()\n                gen.train()\n                gen_imgs.append(vutils.make_grid(fake_images, padding=2, normalize=True))\n                \n    print_iter(\n        curr_epoch=e,\n        epochs=epochs,\n        d_loss=d_train_loss \/ (i + 1),\n        g_loss=g_train_loss \/ (i + 1))\n    print(\"\\nEpoch {} took {:.2f} minutes.\\n\".format(e+1, (time.time() - e_time) \/ 60))\n    \nprint(\"Model took {:.2f} minutes to train.\".format((time.time() - start_time) \/ 60))","5ac92e83":"fig = plt.figure(figsize=(8,8))\nplt.axis(\"off\")\nims = [[plt.imshow(np.transpose(i,(1,2,0)), animated=True)] for i in gen_imgs]\nani = animation.ArtistAnimation(fig, ims, interval=1000, repeat_delay=1000, blit=True)\n\nHTML(ani.to_jshtml())","673033c1":"# Grab a batch of real images from the dataloader\nreal_batch = next(iter(dataloader))\n\n# Plot the real images\nplt.figure(figsize=(15,15))\nplt.subplot(1,2,1)\nplt.axis(\"off\")\nplt.title(\"Real Images\")\nplt.imshow(np.transpose(vutils.make_grid(real_batch[0].to(device)[:64], padding=5, normalize=True).cpu(),(1,2,0)))\n\n# Plot the fake images from the last epoch\nplt.subplot(1,2,2)\nplt.axis(\"off\")\nplt.title(\"Fake Images\")\nplt.imshow(np.transpose(gen_imgs[-1],(1,2,0)))\nplt.show()","e7e3ffe5":"### Train Model\nIt is time to train. Remember our training loop:\n1. Train Discriminator\n    1. Feed real images in, calculate loss, and backprop through the discriminator.\n    2. Feed fake images in, calculate loss, and backprop through the discriminator.\n    3. Sum the losses then update our weights based on both of these losses with our optimizer.\n2. Train Generator\n    1. Take fake images used to update the discriminator and feed them into the discriminator model again. However, the labels for this will be 1 instead of 0, since the generator's goal is to get the discriminator to predict it's generated images as real. Here the loss is calculated for the generator, *based* on the discriminator's output.\n    2. Update weights for generator using the optimizer.\n3. Loop **1 and 2** until done training.","6e6c4677":"### Final Results\nThis will show the last epoch's results, which hopefully will be our best.","579b447b":"# Closing Thoughts\nNow that we've built a GAN, the possibilities are endless for what you can apply this too! Getting this model to train is another story though, it'll be lot of playing around and trial\/error, but for a very amazing result. I suggest you find datasets of cats or some images that you can try to use this model to train on. You can also try your hand on implementing a cGAN or InfoGAN model, using this as a base. Take the time to explore what you can do and try it out!\n\nFor this dataset, try increasing the size of the model to generate larger image sizes, like 128, 128. You would need to add a layer to the generator and discriminator, and probably reduce your batch size and such. You can also try training on the whole dataset for a longer time and see what you get!","911557e3":"### Dataloader\nLet's define our dataset and dataloader using Pytorch's Imagefolder. This was used also in our CNN workshop. The built in Imagefolder dataset will load in images from all subfolders of the given path, and pass it through our transforms without the need for creating a custom dataset. For time purposes, we will set a variable called `thanos_level` that will cut our dataset in half, thirds, fourths etc so we can train on a subset of the 200,000 images. For 5 Epochs, the whole dataset will take about a half hour to train, half will be 15 minutes, and a fourth will be about 6 minutes. For best results, use the whole dataset! \n\nFor transforms, we use a resize down to our image size (keeping it small for speed purposes), center crop the image so the face is centered in the image, convert it to a tensor and normalize it with a STD and mean of 0.5. When this is all done, our RGB scalar values will be betweenn -1 and 1, inclusive, the same as what our generator output will be.\n\nIts important to visualize our data before building the model, so lets take a look and plot some images from the dataset.","f0e2e5b5":"### View Results\nThis segment of code will create a small animation that goes through the generator's output through training. Notice how the features become clearer as time goes on. Its able to produce a human face in RGB, amazing!","0c2a42bc":"### Discriminator\nNow for the discriminator. This will be a simple CNN that we have seen before. The few differences is that we are going to use [`LeakyReLU`](https:\/\/medium.com\/@danqing\/a-practical-guide-to-relu-b83ca804f1f7) which is a adapatation to `ReLU`. LeakyReLU has a chance to \"leak\" negative values from the function output, instead of zeroing out **all** negative values. This has shown to give better results for the discriminator and help avoid the issues mentioned at the end of the slides.\n\nInstead of max pooling, we use larger strides to halve our input size down until 1 node, which will be our output for the discriminator of either Real or Fake. Pooling in GANs is usually never used as it almost always creates models that don' train. Its better to have a larger stride to reduce size of the feature maps. Since we want the generator to produce images representing the input, it needs context of the whole image, so max pooling would not help here.\n\nAnother important note is to not use batch normalization in the first or last block of the discriminator, it can cause the model to not train.","96b0ed4b":"### Generator\nHere we will define our generator model. I've created a simple function that will give us a block of the network, which includes the Convolution Tranpose (which convolves and upsamples in one layer), a batch normalization, and our activation function `ReLU`. I've also included the the `get_padding` helper function we used before, which calculators the required padding needed. You can use the function when building the model or just run it below manually and hardcode the padding.\n\nWe start with our input size and want to upsample and reduce the number filters until the final layer has 3 channels for RGB, and 64x64, our output size.\n\nIt is important as you build the model to keep track of the size of the feature maps as the network gets deeper, as we need to make sure our output size matches the size we set above! If you want larger sizes we can add more layers to the generator. Try doing 128x128 images after the workshop!","9e08c723":"### Create models, optimizers, and loss function\nNow let's create our generator and discriminator models and apply our weight initalization function to them.\n\nWe also need to define the optimizer, device, and loss function. From the DCGAN paper, we will use the Adam optimizer with different betas parameters. These betas define how aggresive the optimizer is in reducing the learning rate on a plateau. The GAN suffers if the optimizer is too agreesive, so we reduce this behavior. **We need two optimizers, one for the generator and one for the discriminator.**\n\nOur loss function will be Binary Cross Entropy since we have binary labels.\n\nFor purposes of visualizing our model lets define some fixed noise which we will generate examples on each batch iteration, so we can see how the model improves throughout training.","9782a1e5":"<img\n    style=\"border-radius: 0.5em;\"\n    src=\"https:\/\/ucfai.org\/groups\/core\/fa19\/gans\/banner.png\">\n\n<div class=\"col-12\">\n    <h1> A Look Behind DeepFake ~ GANs\" <\/h1>\n    <hr>\n<\/div>\n\n<div style=\"line-height: 2em;\">\n    <p>by: \n        <a href=\"https:\/\/ucfai.org\/authors\/brandons209\">@brandons209<\/a> on Oct 30, 2019<\/p>\n<\/div>","486782e8":"### Define function for initalizing weights\nLets define a function to initalize our weights a certain way, this is following the DCGAN paper and their parameters they used. Convolution weights are randomized from a normal distrubution with a mean of 0 and STD of 0.02, with batch normalization weights randomized from a nnormal distrubution with a mean of 1 and a STD of 0.02.\n\nThis is how the DCGAN paper had it, so it should *hopefully* help produce the best results.","90ef9f99":"## Creating New Celebrities\n\nIn this notebook we will be generating unqiue human faces based off of celebrities. Maybe one of them will look like their kid? This dataset contains around 200,000 pictures of celebrities faces, all of them aligned to the center of the image. This is important so the GAN can learned the features of the face properly when generating.\n\nOur network will be a DCGAN since we are working with image data, a popular domain for generating new data with GANs. \n\nAs always, lets import all of our libraries needed, and our helper function from printing Epoch results nicely."}}