{"cell_type":{"acab1cc3":"code","dd365031":"code","e3f28c5c":"code","e549da38":"code","82044dc6":"code","ce48e067":"code","cbabe21f":"code","c195bf7f":"code","3a51ed2c":"code","e9d830b1":"code","35fd2020":"code","7b9cb863":"code","82d73216":"code","736b00b3":"code","0e67aace":"code","5892a6c7":"code","aa911064":"code","863c695f":"code","878edda1":"code","09e2028d":"code","e1c753fb":"code","1bc528b9":"code","83fae390":"code","c58e0d86":"code","4428d621":"code","3790fc1c":"markdown","e57f405e":"markdown","ef26f5f4":"markdown","1ccc0cf2":"markdown","2400d49b":"markdown","f18217ef":"markdown"},"source":{"acab1cc3":"from mpl_toolkits.mplot3d import Axes3D\nfrom sklearn.preprocessing import StandardScaler\nimport matplotlib.pyplot as plt # plotting\nimport numpy as np # linear algebra\nimport os # accessing directory structure\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\n%matplotlib inline\nplt.style.use('ggplot')","dd365031":"for dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","e3f28c5c":"df = pd.read_excel('\/kaggle\/input\/Nigeria states and population.xlsx')\ndf.head()","e549da38":"col =df.columns\ndef cleandata(df):\n    states = []\n    for i in range(0,74):\n        if(i%2==0):\n            lga=df[col[i]]\n            lga.drop(0)\n            lga.dropna()\n            state = col[i]\n        else:\n            pop = df[col[i]]\n            pop = pop.drop(0)\n            pop.dropna()\n          \n        if not((i%2==0)):\n            if(i==2): continue \n            state= pd.concat([lga,pop], axis=1, keys=['LGA', 'Population'])\n            states.append(state)\n    return states","82044dc6":"df = cleandata(df)","ce48e067":"for i in range(len(df)):\n    df[i] = df[i].dropna()","cbabe21f":"df=pd.concat(df,keys=col[0:74:2])\ndf.tail()","c195bf7f":"df.info()","3a51ed2c":"df.describe()","e9d830b1":"df.index.names =['State', 's\/n']\ndf.head()","35fd2020":"\nstate_and_pop = df.groupby('State').sum()['Population']\nstate_and_pop","7b9cb863":"plt.figure(figsize=(16,10))\nstate_and_pop.plot(kind='bar')","82d73216":"df.reset_index(inplace=True)\ndf.drop(['s\/n'],axis=1,inplace=True)\ndf.head()","736b00b3":"pip install googlemaps","0e67aace":"import requests\nimport logging\nimport time\nimport googlemaps\nfrom datetime import datetime\n\ngmaps = googlemaps.Client(key='AIzaSyCp7aUbM1pmyCmuLHnrTo0TzpOMOS6zYUA')\n\n# Geocoding an address\ngeocode_result = gmaps.geocode('ABA ,ABIA STATE, NIGERIA')\nprint(geocode_result)","5892a6c7":"# df.drop(['s\/n'], axis=1, inplace=True)\ndf['Address'] = df['LGA'].astype(str) + ',' + \\\n                df['State'] + ',' +' Nigeria'   \n\ndf.head()","aa911064":"\nlogger = logging.getLogger(\"root\")\nlogger.setLevel(logging.DEBUG)\n# create console handler\nch = logging.StreamHandler()\nch.setLevel(logging.DEBUG)\nlogger.addHandler(ch)\n\n# Set your Google API key here. \n# Even if using the free 2500 queries a day, its worth getting an API key since the rate limit is 50 \/ second.\n# With API_KEY = None, you will run into a 2 second delay every 10 requests or so.\n# With a \"Google Maps Geocoding API\" key from https:\/\/console.developers.google.com\/apis\/, \n# the daily limit will be 2500, but at a much faster rate.\n# Example: API_KEY = 'AIzaSyC9azed9tLdjpZNjg2_kVePWvMIBq154eA'\nAPI_KEY = 'AIzaSyCp7aUbM1pmyCmuLHnrTo0TzpOMOS6zYUA'\n# Backoff time sets how many minutes to wait between google pings when your API limit is hit\nBACKOFF_TIME = 30\n# Set your output file name here.\noutput_filename = 'geocode_data.csv'\n# Return Full Google Results? If True, full JSON results from Google are included in output\nRETURN_FULL_RESULTS = False","863c695f":"# Form a list of addresses for geocoding:\n# Make a big list of all of the addresses to be processed.\naddresses = df['Address'].tolist()","878edda1":"def get_google_results(address, api_key=None, return_full_response=False):\n    \"\"\"\n    Get geocode results from Google Maps Geocoding API.\n    \n    Note, that in the case of multiple google geocode reuslts, this function returns details of the FIRST result.\n\n    @param return_full_response: Boolean to indicate if you'd like to return the full response from google. This\n                    is useful if you'd like additional location details for storage or parsing later.\n    \"\"\"\n    # Set up your Geocoding url\n    geocode_url = \"https:\/\/maps.googleapis.com\/maps\/api\/geocode\/json?address={}\".format(address)\n    if api_key is not None:\n        geocode_url = geocode_url + \"&key={}\".format(api_key)\n        \n    # Ping google for the reuslts:\n    results = requests.get(geocode_url)\n    # Results will be in JSON format - convert to dict using requests functionality\n    results = results.json()\n    \n    # if there's no results or an error, return empty results.\n    if len(results['results']) == 0:\n        output = {\n            \"formatted_address\" : None,\n            \"latitude\": None,\n            \"longitude\": None,\n            \"accuracy\": None,\n            \"google_place_id\": None,\n            \"type\": None,\n            \"postcode\": None\n        }\n    else:    \n        answer = results['results'][0]\n        output = {\n            \"formatted_address\" : answer.get('formatted_address'),\n            \"latitude\": answer.get('geometry').get('location').get('lat'),\n            \"longitude\": answer.get('geometry').get('location').get('lng'),\n            \"accuracy\": answer.get('geometry').get('location_type'),\n            \"google_place_id\": answer.get(\"place_id\"),\n            \"type\": \",\".join(answer.get('types')),\n            \"postcode\": \",\".join([x['long_name'] for x in answer.get('address_components') \n                                  if 'postal_code' in x.get('types')])\n        }\n        \n    # Append some other details:    \n    output['input_string'] = address\n    output['number_of_results'] = len(results['results'])\n    output['status'] = results.get('status')\n    if return_full_response is True:\n        output['response'] = results\n    \n    return output","09e2028d":"# Ensure, before we start, that the API key is ok\/valid, and internet access is ok\ntest_result = get_google_results(\"Lagos, Nigeria\", API_KEY, RETURN_FULL_RESULTS)\nif (test_result['status'] != 'OK') or (test_result['formatted_address'] != 'Lagos, Nigeria'):\n    logger.warning(\"There was an error when testing the Google Geocoder.\")\n    raise ConnectionError('Problem with test results from Google Geocode - check your API key and internet connection.')\n\n# Create a list to hold results\nresults = []\n# Go through each address in turn\nfor address in addresses:\n    # While the address geocoding is not finished:\n    geocoded = False\n    while geocoded is not True:\n        # Geocode the address with google\n        try:\n            geocode_result = get_google_results(address, API_KEY, return_full_response=RETURN_FULL_RESULTS)\n        except Exception as e:\n            logger.exception(e)\n            logger.error(\"Major error with {}\".format(address))\n            logger.error(\"Skipping!\")\n            geocoded = True\n            \n        # If we're over the API limit, backoff for a while and try again later.\n        if geocode_result['status'] == 'OVER_QUERY_LIMIT':\n            logger.info(\"Hit Query Limit! Backing off for a bit.\")\n            time.sleep(BACKOFF_TIME * 60) # sleep for 30 minutes\n            geocoded = False\n        else:\n            # If we're ok with API use, save the results\n            # Note that the results might be empty \/ non-ok - log this\n            if geocode_result['status'] != 'OK':\n                logger.warning(\"Error geocoding {}: {}\".format(address, geocode_result['status']))\n            logger.debug(\"Geocoded: {}: {}\".format(address, geocode_result['status']))\n            results.append(geocode_result)           \n            geocoded = True\n\n    # Print status every 100 addresses\n    if len(results) % 100 == 0:\n    \tlogger.info(\"Completed {} of {} address\".format(len(results), len(addresses)))\n   \n    if len(results) % 750 == 0:\n        pd.DataFrame(results).to_csv(\"{}_bak\".format(output_filename))\n\n# All done\nlogger.info(\"Finished geocoding all addresses\")\n# Write the full results to csv using the pandas library.\npd.DataFrame(results).to_csv(output_filename, encoding='utf8')","e1c753fb":"geocode_data=pd.read_csv('geocode_data.csv',index_col=False)\ngeocode_data['population']=df['Population']\ngeocode_data.head()","1bc528b9":"geocode_data.drop(['Unnamed: 0','input_string','accuracy','google_place_id','type','postcode','number_of_results'], axis=1,inplace=True)\ngeocode_data.head()","83fae390":"import geopandas as gpd\nimport geopy\nfrom geopy.geocoders import Nominatim\nfrom geopy.extra.rate_limiter import RateLimiter\nimport folium\nfrom folium.plugins import FastMarkerCluster","c58e0d86":"map1 = folium.Map(\n    location=[9.0820,8.6753],\n    tiles='cartodbpositron',\n    zoom_start=7,\n)","4428d621":"geocode_data.apply(lambda row:folium.CircleMarker(location=[row[\"latitude\"], row[\"longitude\"]],radius=row['population']).add_to(map1), axis=1)\nmap1","3790fc1c":"## Exploratory Analysis\nTo begin this exploratory analysis, first import libraries and define functions for plotting the data using `matplotlib`. Depending on the data, not all plots will be made. ","e57f405e":"## Introduction\nMost data often require some level of pre-processing before they are usable. imagine having data about infection and the address of the victims. one of possible finding is to know where the infection broke out. A quick way to predict that is to have a visual geographical representation of the infection spread. however, in order to visualize your data geographically, we need to pre-process our data by converting the address into latitude and longitude. The process of converting location address into coordinates is called GeoCoding. One of the easiest way to quickly locate a place nowadays is to use google map. Even though there are a host of other alternatives but in this notebook, we would only demonstrate GoogleMap APIs for geocoding and MapBox for visualization.","ef26f5f4":"The next hidden code cells define functions for plotting data. Click on the \"Code\" button in the published kernel to reveal the hidden code.","1ccc0cf2":"There is 0 csv file in the current version of the dataset:\n","2400d49b":"## Conclusion\nThis concludes your starter analysis! To go forward from here, click the blue \"Fork Notebook\" button at the top of this kernel. This will create a copy of the code and environment for you to edit. Delete, modify, and add code as you please. Happy Kaggling!","f18217ef":"Oh, no! There are no automatic insights available for the file types used in this dataset. As your Kaggle kerneler bot, I'll keep working to fine-tune my hyper-parameters. In the meantime, please feel free to try a different dataset."}}