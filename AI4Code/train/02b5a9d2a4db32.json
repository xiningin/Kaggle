{"cell_type":{"a6b45655":"code","27ec4b56":"code","e4424fe4":"code","1170428c":"code","51982449":"code","badd4f47":"code","367ec1b9":"code","8e61e447":"code","0ecd4478":"code","46dd131c":"code","1ac7f188":"code","d6dfc035":"code","902d6d43":"code","96de68b9":"code","49bce2af":"code","1a5f9b36":"code","2b8a21ab":"code","b3942bd1":"code","b5396523":"code","3660659d":"markdown","790e9831":"markdown","7aa50dc6":"markdown","7b871336":"markdown","6ca30fd9":"markdown","a1158d61":"markdown","57a84278":"markdown","fbcf9ea7":"markdown","1d2efb7a":"markdown","6ed6e4dd":"markdown","28517c0c":"markdown","da2bca51":"markdown","a17f9048":"markdown","3aa6a8fe":"markdown","cdebb82e":"markdown","7d26b1bf":"markdown"},"source":{"a6b45655":"import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.pylab as pl\nimport matplotlib.gridspec as gridspec\nfrom matplotlib import colors\n\n# Input data files are available in the \"..\/input\/\" directory.\n# Any results you write to the current directory are saved as output.","27ec4b56":"zone = \"NW\"    # NW or SE\nyear = 2016    # 2016, 2017 or 2018\nmonth = 5\npart_month = 3 # Choice between 1,2,3, as we said earlier each month is divided in 3 parts\n#min and max indexes when the dataset is loaded in memory\nind_min = 2592\nind_max = 2692","e4424fe4":"directory = '\/kaggle\/input\/meteonet\/'\nfname = directory + f'{zone}_reflectivity_old_product_{str(year)}\/{zone}_reflectivity_old_product_{str(year)}\/reflectivity-old-{zone}-{str(year)}-{str(month).zfill(2)}\/reflectivity-old-{zone}-{str(year)}-{str(month).zfill(2)}\/reflectivity_old_{zone}_{str(year)}_{str(month).zfill(2)}.{str(part_month)}.npz'\nfname_coords = directory + 'Radar_coords\/Radar_coords\/'+ f'radar_coords_{zone}.npz'\n\nd = np.load(fname, allow_pickle=True)\ndata = d['data'][ind_min:ind_max,:,:]     #reflectivity values\ndates = d['dates'][ind_min:ind_max]        #associated dates values\nmiss_dates = d['miss_dates'][ind_min:ind_max]        #missing dates values\n\n#get the coordinates of the points\ncoords = np.load(fname_coords, allow_pickle=True)\n#it is about coordinates of the center of pixels -> it is necessary to get the coordinates of the center of pixels\nlat = coords['lats']\nlon = coords['lons']","1170428c":"fig = plt.figure(figsize=(9,9))\ngs = gridspec.GridSpec(2, 2, figure = fig)\nfig.suptitle(\"4 examples of reflectivity plots\" + ' \/ ' + str(255) +' : missing values', fontsize=12)\n\n# Reflectivity : colorbar definition\nif (np.max(data) > 56):\n    borne_max = np.max(data)\nelse:\n    borne_max = 56 + 10\ncmap = colors.ListedColormap(['lavender','indigo','mediumblue','dodgerblue', 'skyblue','cyan',\n                          'olivedrab','lime','greenyellow','orange','red','magenta','pink','silver'])\nbounds = [0,4,8,12,16,20,24,32,40,48,56,borne_max,255]\nnorm = colors.BoundaryNorm(bounds, cmap.N)\n\n# 4 plot examples\nax =  pl.subplot(gs[0, 0])  \np1=ax.pcolormesh(lon, lat, data[0,:,:],cmap=cmap, norm=norm)\nax.set_ylabel('latitude (degrees_north)')\nax.set_title(str(dates[0]) + \" - \"+  zone + \" zone\")\npl.colorbar(p1,ax=ax, cmap=cmap, norm=norm, boundaries=bounds, ticks=bounds, \n            orientation= 'vertical').set_label('Reflectivity (in dBZ)')\n\nax =  pl.subplot(gs[0, 1])  \np2=ax.pcolormesh(lon, lat, data[1,:,:],cmap=cmap, norm=norm)\nax.set_title(str(dates[1]) + \" - \"+  zone + \" zone\")\npl.colorbar(p2,ax=ax, cmap=cmap, norm=norm, boundaries=bounds, ticks=bounds, \n            orientation= 'vertical').set_label('Reflectivity (in dBZ)')\n\nax =  pl.subplot(gs[1, 0])  \np3=ax.pcolormesh(lon, lat, data[2,:,:],cmap=cmap, norm=norm)\nax.set_xlabel('longitude (degrees_east)')\nax.set_ylabel('latitude (degrees_north)')\nax.set_title(str(dates[2]) + \" - \"+  zone + \" zone\")\npl.colorbar(p3,ax=ax, cmap=cmap, norm=norm, boundaries=bounds, ticks=bounds, \n            orientation= 'vertical').set_label('Reflectivity (in dBZ)')\n\nax =  pl.subplot(gs[1, 1])  \np4=ax.pcolormesh(lon, lat, data[3,:,:],cmap=cmap, norm=norm)\nax.set_xlabel('longitude (degrees_east)')\nax.set_title(str(dates[3]) + \" - \"+  zone + \" zone\")\npl.colorbar(p4,ax=ax, cmap=cmap, norm=norm, boundaries=bounds, ticks=bounds, \n            orientation= 'vertical').set_label('Reflectivity (in dBZ)')\n\nplt.show()","51982449":"data.shape","badd4f47":"dates.shape","367ec1b9":"dates[0:5]","8e61e447":"miss_dates.shape","0ecd4478":"miss_dates","46dd131c":"lat.shape","1ac7f188":"lat","d6dfc035":"import cartopy.crs as ccrs\nimport cartopy.feature as cfeature","902d6d43":"#index of the chosen 5 min of the decade for the plot with cartopy (cf last cell of the notebook) \nind = 24","96de68b9":"# Coordinates of studied area boundaries (in \u00b0N and \u00b0E)\nlllat = 46.25  #lower left latitude\nurlat = 51.896  #upper right latitude\nlllon = -5.842  #lower left longitude\nurlon = 2  #upper right longitude\nextent = [lllon, urlon, lllat, urlat]\n\nfig = plt.figure(figsize=(9,10))\n\n# Select projection\nax = plt.axes(projection=ccrs.PlateCarree())\n\n#colorbar definition\nif (np.max(data) > 56):\n    borne_max = np.max(data)\nelse:\n    borne_max = 56 + 10\ncmap = colors.ListedColormap(['lavender','indigo','mediumblue','dodgerblue', 'skyblue','cyan',\n                          'olivedrab','lime','greenyellow','orange','red','magenta','pink','silver'])\nbounds = [0,4,8,12,16,20,24,32,40,48,56,borne_max,255]\nnorm = colors.BoundaryNorm(bounds, cmap.N)\n\n#plot the data and the background map (coastlines and borders)\nimg = ax.imshow(data[ind,:,:], interpolation='none', origin='upper',cmap=cmap, norm=norm, extent=extent)\nax.coastlines(resolution='50m', linewidth=1)\nax.add_feature(cfeature.BORDERS.with_scale('50m'))\n\nplt.colorbar(img, cmap=cmap, norm=norm, boundaries=bounds, ticks=bounds, orientation= 'horizontal').set_label('Reflectivity (in dBZ) \/ '+ \n                                                                                                              str(255) +' : missing values')\nplt.title(\"Reflectivity - \"+ str(dates[ind]) + \" - \"+  zone + \" zone\")\nplt.show()","49bce2af":"#multiplication coefficient for the graphic representation of rainfall rate (in 1\/coeff mm\/h)\n#\/!\\### the colorbar is adapted to the coefficient 10 (cf plot at the end)\ncoeff = 10 ","1a5f9b36":"##from dBZ to mm\/h : Marshall-Palmer formula\na = 200\nb = 1.6\n\nrr = np.zeros((data.shape[0],data.shape[1],data.shape[2]))\nrr[data==255]=np.nan\nrr[data!=255] = (10**(data[data!=255]\/10)\/a)**(1\/b)\n\nrr_plot = coeff*rr","2b8a21ab":"def plot_mmh(data,coeff, lat,lon, title = \"4 examples of rainfall rate plots\"):\n           \n    #plots\n    fig, ax = plt.subplots(2, 2,figsize=(9,9))\n    fig.suptitle(title, fontsize=16)\n    \n    #colorbar definition\n    #\/!\\### the scale is adapted to the coefficient 10\n    if (np.nanmax(rr_plot) > 3646):\n        borne_max = np.nanmax(rr_plot)\n    else:\n        borne_max = 3646 + 10\n    cmap = colors.ListedColormap(['white', 'darkslateblue', 'mediumblue','dodgerblue', 'skyblue','olive','mediumseagreen'\n                                      ,'cyan','lime','yellow','khaki','burlywood','orange','brown','red'])\n    bounds = [0,2,4,6,12,21,36,65,115,205,365,648,1153,2050,3646,borne_max]\n    norm = colors.BoundaryNorm(bounds, cmap.N)\n    \n    pl=ax[0,0].pcolormesh(lon, lat, rr_plot[0,:,:],cmap=cmap, norm=norm)\n    ax[0,0].set_ylabel('latitude (degrees_north)')\n    ax[0,0].set_title(str(dates[0]) + \" - \"+  zone + \" zone\")\n\n    pl=ax[0,1].pcolormesh(lon, lat, rr_plot[1,:,:],cmap=cmap, norm=norm)\n    ax[0,1].set_title(str(dates[1]) + \" - \"+  zone + \" zone\")\n\n    pl=ax[1,0].pcolormesh(lon, lat, rr_plot[2,:,:],cmap=cmap, norm=norm)\n    ax[1,0].set_xlabel('longitude (degrees_east)')\n    ax[1,0].set_ylabel('latitude (degrees_north)')\n    ax[1,0].set_title(str(dates[2]) + \" - \"+  zone + \" zone\")\n\n    pl=ax[1,1].pcolormesh(lon, lat, rr_plot[3,:,:],cmap=cmap, norm=norm)\n    ax[1,1].set_xlabel('longitude (degrees_east)')\n    ax[1,1].set_title(str(dates[3]) + \" - \"+  zone + \" zone\")\n\n    cbar = fig.colorbar(pl,ax=ax.ravel().tolist(),cmap=cmap, norm=norm, boundaries=bounds, ticks=bounds, orientation= 'vertical').set_label('Rainfall rate (in 1\/10 mm\/h) \/ nan : missing values')\n    plt.show()\n    return rr","b3942bd1":"#\/!\\ these function works only if there are at least 3 dates later than this chosen for the plot with Cartopy (ind variable, cf second cell)\nrr = plot_mmh(data,coeff, lat,lon)","b5396523":"data_plot = coeff*rr\n\nfig = plt.figure(figsize=(9,10))\n\n# Select projection\nax = plt.axes(projection=ccrs.PlateCarree())\n\n#colorbar definition\n#\/!\\### the scale is adapted to the coefficient 10\nif (np.nanmax(data_plot) > 3646):\n    borne_max = np.nanmax(data_plot)\nelse:\n    borne_max = 3646 + 10\ncmap = colors.ListedColormap(['white', 'darkslateblue', 'mediumblue','dodgerblue', 'skyblue','olive','mediumseagreen'\n                                  ,'cyan','lime','yellow','khaki','burlywood','orange','brown','red'])\nbounds = [0,2,4,6,12,21,36,65,115,205,365,648,1153,2050,3646,borne_max]\nnorm = colors.BoundaryNorm(bounds, cmap.N)\n\n#plot the data and the background map (coastlines and borders)\nimg = ax.imshow(data_plot[ind,:,:], interpolation='none', origin='upper',cmap=cmap, norm=norm, extent=extent)\nax.coastlines(resolution='50m', linewidth=1)\nax.add_feature(cfeature.BORDERS.with_scale('50m'))\n\nplt.colorbar(img, cmap=cmap, norm=norm, boundaries=bounds, ticks=bounds, orientation= 'horizontal').set_label('Rainfall rate (in 1\/10 mm\/h) \/ nan : missing values')\nplt.title(\"Rainfall rate - \"+ str(dates[ind]) + \" - \"+  zone + \" zone\")\nplt.show()","3660659d":"## Data\n\nDimensions of the `data` array: \n* time dimension (number of 5 min records) -> can be reduced and determined by min and max indexes when the dataset is loaded in memory (cf second cell)\n* Number of points on the y axis : latitude\n* Number of points on the x axis : longitude","790e9831":"Plot the reflectivity values for 1 given time step with a basemap","7aa50dc6":"Let's plot quickly the data :","7b871336":"# Note\n\n<font size=\"4.5\">To use <span style=\"color:blue\">**Cartopy**<\/span>, a library to plot data with basemaps (see cells below), it is necessary to <span style=\"color:red\">activate the internet connection<\/span> of that notebook (in edit mode, you can find on the right column, in the *Settings* section, a row entitled *Internet*, put the slider bar on **on**).  <\/font>","6ca30fd9":"# Plot with Cartopy","a1158d61":"Plot with Cartopy :","57a84278":"# More details\n\nThe data are stored per period of 10 or 11 days (each month is separated in 3 files). The zone is called 'NW' (for North-West of France).\nThe time step is 5 min (per day, start hour :00h and end hour : 23h55), the spatial resolution, 0.01\u00b0 (the projection system is EPSG:4326).\n\nEach file contains 3 data categories : \n\n* `data` : reflectivity values\n* `dates` : the associated dates to the reflectivity values\n* `miss_dates` : the dates for which the data are missing\n\nThe min and max indexes defined in the second cell (allow to load just take a piece of data if you have a small RAM) apply to these datasets. \n\nThe values are not continuous, there are defined in this way (each value is the inferior bound of each interval) :\n\n* 0 : Z < 8 dBZ \n* 8 : 8 < Z < 16 dBZ     \n* 16 : 16 < Z < 20 dBZ \n* ...\n* 70 : 70 dBZ < Z \n\n**To get the coordinates (lat,lon) of the points :**\nOne `.npz` file contains 2 arrays : one for the latitudes and one for the longitudes (it is about coordinates of the center of each pixel).","fbcf9ea7":"Index of the chosen 5 min of the decade for the plot with cartopy (cf last cell of the notebook) \n\n**\/!\\ 0 <= ind < ind_max-ind_min** ","1d2efb7a":"First, let's select the zone and date we want to study :\n\n**Note** : if the RAM size is not enough, it is possible to load only a part of data (values between min and max indexes).  The maximum possible value about index is 3168 (1 data per 5 min at maximum for a 11 days maximal period -> 12x24x11 = 3168, with : 12 data per hour (frequency = 5 min), 24 hours per day and 11 days","6ed6e4dd":"# Radar observation : reflectivity composite of the old product\n\nThe aim of this notebook is to indicate how to read the reflectivity data of the old product. These data range from 01\/01\/2016 to 31\/12\/16 included. The radar emits a signal which is reflected by the precipitation. \"Reflectivity\" is the amount of transmitted power returned to the radar receiver after hitting precipitation, compared to a reference power density at a distance of 1 meter from the radar antenna.\n\nFor each pixel is indicated a reflectivity value expressed in dBZ. If the value is missing, the value is 255.\n\nIn this notebook, a formula is provided to convert the dBZ into mm.h<sup>-1<\/sup>.\n\nFor more information about data, cf [documentation](https:\/\/meteofrance.github.io\/meteonet\/english\/data\/rain-radar\/).","28517c0c":"## Latitude","da2bca51":"## Dates\n\nDimensions of the `dates` array:\n* time dimension (number of 5 min records for which there are data)  -> can be reduced and determined by min and max indexes when the dataset is loaded in memory (cf second cell)","a17f9048":"# Convert dBZ into mm\/h","3aa6a8fe":"Now, we load the data and the coordinates :","cdebb82e":"## Missing dates\n\nDimensions of the `miss_dates` array:\n* time dimension (dates for which there are no data) -> can be reduced and determined by min and max indexes when the dataset is loaded in memory (cf second cell)","7d26b1bf":"# Quickstart"}}