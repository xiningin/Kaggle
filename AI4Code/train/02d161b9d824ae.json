{"cell_type":{"250bf7dd":"code","b21c6f3f":"code","0b1fa8a6":"code","35196646":"code","0e578769":"code","f407395e":"code","be68ff44":"code","509379bf":"code","8726ac55":"code","9459a11b":"code","d2250acb":"code","62021a6e":"code","5afaf5d5":"code","b2af19c8":"code","94726e46":"code","797212d2":"code","e2afa046":"code","5bb64b0d":"code","8aa99f1c":"code","e712a8ad":"code","94dfac1a":"code","a1f4f88c":"code","e8c6f58a":"code","3eab28ab":"code","9c44813e":"code","f28ba8ea":"code","3b5dc4e4":"code","ccdb665a":"code","6c45f56c":"code","5cde775e":"code","ab02f438":"code","4bd933b0":"code","86180cd9":"code","1fde41ab":"code","70beaa90":"code","284c6c46":"code","e45dd9a4":"code","f9a72bf2":"code","50e15087":"code","7b1a52ee":"code","15e7df77":"code","5a28cd76":"code","ded7f87f":"code","6e941d97":"code","b14eba0f":"code","c8e52f5e":"code","465a4fa9":"code","d42406c7":"code","fbad7dbd":"markdown","580238bb":"markdown","60926066":"markdown","ea39b0c8":"markdown","5273cf60":"markdown","9ac90798":"markdown","756dd692":"markdown","689b8e2c":"markdown","2d591e73":"markdown"},"source":{"250bf7dd":"#IMPORTING LIBRARIES\nimport numpy as np\nimport pandas as pd\n","b21c6f3f":"#IMPORTING DATA FROM CSV FILES INTO A DATAFRAME FOR ANALYSIS \npost = pd.read_csv(\"..\/input\/post-recommender\/posts.csv\")\nuser = pd.read_csv(\"..\/input\/post-recommender\/users.csv\")\nview = pd.read_csv(\"..\/input\/post-recommender\/views.csv\")","0b1fa8a6":"user.head()","35196646":"post.head()","0e578769":"view.head()","f407395e":"user.shape, post.shape, view.shape","be68ff44":"user.describe()","509379bf":"post.describe()","8726ac55":"view.describe()","9459a11b":"user.isna().sum()","d2250acb":"post.isna().sum()","62021a6e":"view.isna().sum()","5afaf5d5":"post[post[\"category\"].isna()]","b2af19c8":"post[\"category\"].unique()","94726e46":"post[\"category\"] = post[\"category\"].fillna(\"random\")","797212d2":"post.isna().sum()","e2afa046":"cat = {}\nfor i in post[\"category\"]:\n    cat.update({i:[]})\n    for j in i.split(\"|\"):\n        cat[i].append(j)\nprint(cat)","5bb64b0d":"updated_data =  []\nfor i in cat:\n    dummy = post[post['category']==i]\n    id = dummy['_id'].values[0]\n    title = dummy['title'].values[0]\n    post_type = dummy[' post_type'].values[0]\n    for j in cat[i]: \n        dict1 = {}\n        dict1.update({'_id':id})\n        dict1.update({'title':title})\n        dict1.update({'category':j})\n        dict1.update({' post_type':post_type})\n        updated_data.append(dict1)","8aa99f1c":"post1 = pd.DataFrame(updated_data)\n","e712a8ad":"post1.head()","94dfac1a":"post1[\"category\"].unique()","a1f4f88c":"view.columns","e8c6f58a":"post1.columns","3eab28ab":"user.columns","9c44813e":"post1.rename(columns={\"_id\":'post_id'}, inplace = True)","f28ba8ea":"user.rename(columns={\"user_id\":'post_id'}, inplace = True)","3b5dc4e4":"main = pd.merge(view,post1)","ccdb665a":"main.columns","6c45f56c":"main.head()","5cde775e":"main.info()","ab02f438":"main.describe()","4bd933b0":"print(\"The number of unique user_ids are {}\".format(len(list(main[\"user_id\"].unique()))))\nprint(\"The number of unique categories are {}\".format(len(list(main[\"category\"].unique()))))\nusers = list(main[\"user_id\"].unique())\ncategories = list(main[\"category\"].unique())","86180cd9":"#MATRIX WILL BE OF 88,235\nuser_mat = [[] for i in range(len(users))]\nfor i in range(len(users)):\n    for j in range(len(categories)):\n        value = len(main[(main[\"user_id\"]==users[i]) & (main[\"category\"]==categories[j])])\n        user_mat[i].append(value)","1fde41ab":"for i in user_mat[0]:\n    print(i,end=\" \")","70beaa90":"# for creating a sparse matrix\nfrom scipy.sparse import csr_matrix \nuser_mat = csr_matrix(user_mat)","284c6c46":"from sklearn.neighbors import NearestNeighbors\nmodel = NearestNeighbors(metric='cosine', algorithm='brute', n_neighbors=15)","e45dd9a4":"model.fit(user_mat)","f9a72bf2":"def recommender(user_id, data=user_mat, model=model):\n    model.fit(data)\n    index = users.index(user_id)\n    current_user = main[main['user_id']==user_id]\n    distances, indices = model.kneighbors(data[index], 15)\n    recomendation = []\n    for i in indices[0]:\n        user = main[main['user_id']==users[i]]\n        for i in user['category'].unique():\n            if i not in current_user['category'].unique():\n                recomendation.append(i)\n    return recomendation\n#     print(indices)","50e15087":"main[main[\"user_id\"]==users[0]][\"category\"].unique()","7b1a52ee":"recommender(users[0])[:10]","15e7df77":"main.head()","5a28cd76":"main[\" post_type\"].unique()","ded7f87f":"posts = list(main[\"post_id\"].unique())","6e941d97":"item_profiles = {}\nfor i in categories:\n    item_profiles.update({i:[]})\n    for j in posts:\n        item_profiles[i].append(1) if i in list(main[main['post_id']==j]['category'].unique()) else item_profiles[i].append(0)","b14eba0f":"# converting lists to vectors or arrays\nfor i in item_profiles:\n    item_profiles[i] = np.array(item_profiles[i])\nfor i in item_profiles:\n    print(i, item_profiles[i])\n    break","c8e52f5e":"user_profiles = {}\n# Filling the user_profiles\nfor i in users:\n    user_profiles.update({i:[]})\n    # finding the current user\n    current_user = main[main['user_id']==i]\n    # listing all the categories the user has viewed\n    current_user_categories = list(current_user['category'].unique())\n    # Listing all the posts the user has viewed\n    current_user_post = list(current_user['post_id'].unique())\n    \n    category_weight = {}\n    # create a dummy vector which will store the final vector for the user profile of length equal to posts\n    result_vector = np.array([0 for i in range(len(posts))])\n    for j in current_user_categories:\n        category_weight.update({j:0})\n        # Now count how many times j has appeared\n        for k in list(current_user['category']):\n            if j==k:\n                category_weight[j]+=1\n        # Now divide it with the length of the current_user_post\n        category_weight[j] = category_weight[j]\/len(current_user_post)\n        # Now we have calculated our weights, Now we will calculate user-profile\n        result_vector = result_vector+ (category_weight[j]*item_profiles[j])\n    user_profiles[i] = result_vector\/len(current_user_post)","465a4fa9":"from sklearn.metrics.pairwise import cosine_similarity\n\n# we will create a function which will take user_id as argument and will provide recomendation\n# all other arguments will be set to some default values. \ndef recommender1(user_id, user_profiles = user_profiles, item_profiles=item_profiles):\n    # calculate the cosine similiraity between the item-profile of all categories and the users user-profile\n    # create a dictionary category as key and cosine value as the value\n    similarity = {}\n    for i in item_profiles:\n        similarity.update({i:cosine_similarity(user_profiles[user_id].reshape(1, -1), item_profiles[i].reshape(1, -1))})\n    # as we have found the similarity now we will sort it and show the user the posts of the top categories and which the user\n    # hasnot viewed yet\n    sorted_similarity = sorted(similarity.items(), key=lambda x: x[1], reverse=True)\n    # now we will filter those posts that the user hasnot viewed\n    user_posts = list(main[main['user_id']==user_id]['post_id'].unique())\n    # create recomendation list\n    recommendations = []\n    # displaying users viewed posts and categories\n    print(\"posts user has viewed:{}\".format(user_posts))\n    print(\"categories viewed by users:{}\".format(list(main[main['user_id']==user_id]['category'].unique())))\n    for i in sorted_similarity:\n        category_posts = list(main[main['category']==i[0]]['post_id'].unique())\n        for j in category_posts:\n            if j not in user_posts:\n                recommendations.append([i[0], j])\n        # we will recommend top 20 posts to the user\n        if len(recommendations)==20:\n            break\n    for i in recommendations:\n        print(i)","d42406c7":"recommender1(users[30])\n","fbad7dbd":"### CONTENT BASED FILTERING","580238bb":"# POST RECOMMENDATION SYSTEM","60926066":"Creating a user user collaborative filtering approach.Creating a matrix with users as rows and categories as columns","ea39b0c8":"Creating a dictionary for having actual categories as key and splitted","5273cf60":"Top 10 Recommendations for user[0]","9ac90798":"### DATA EXPLORATION AND PREPROCESSING","756dd692":"## WHAT IS RECOMMENDER SYSTEM?\n* A recommendation engine filters the data using different algorithms and recommends the most relevant items to users. It first captures the past behavior of a customer and based on that, recommends products which the users might be likely to buy.\n* We can recommend items to a user which are most popular among all the users.\n* We can divide the users into multiple segments based on their preferences (user features) and recommend items   to them based on the segment they belong to.\n\n## APPROACHES TO RECOMMENDER SYSTEM\n1. Content Based approach(Metric:Euclidean Distance,Cosine Similarity)\n2. Collaborative Filtering(USER-USER or ITEM-ITEM)\n","689b8e2c":"Now we will be creating a item profile and a user profile for each category.We have the user profile already made.For item profile we can create a profile for if the post falls under a particular category or not.","2d591e73":"### MODELING (COLLABORATIVE AND CONTENT BASED FILTERING)"}}