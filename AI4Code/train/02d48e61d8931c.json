{"cell_type":{"a8b03a8f":"code","8cde6c05":"code","eabf915a":"code","6498132d":"code","dafe7319":"code","5aa1fd13":"code","c30bea46":"markdown","e75a8ad0":"markdown","09a7d509":"markdown","7642c7eb":"markdown","b87f4eb9":"markdown","ebd0f54a":"markdown","e3c9d67b":"markdown","9e7ad269":"markdown","5e5a0638":"markdown","25f07c1d":"markdown","b5fdcfa6":"markdown","c3657dc1":"markdown","68dedf85":"markdown","1e7089fe":"markdown","bfd2787f":"markdown","374bd13d":"markdown","1928dca1":"markdown","d8691fe7":"markdown","54598e2d":"markdown","323d191a":"markdown","014dbf6e":"markdown","71608644":"markdown","f25a8e5b":"markdown","bb6f5451":"markdown"},"source":{"a8b03a8f":"def calculate_iou(y_true, y_pred):\n    \n    \n    \"\"\"\n    Input:\n    Keras provides the input as numpy arrays with shape (batch_size, num_columns).\n    \n    Arguments:\n    y_true -- first box, numpy array with format [x, y, width, height, conf_score]\n    y_pred -- second box, numpy array with format [x, y, width, height, conf_score]\n    x any y are the coordinates of the top left corner of each box.\n    \n    Output: IoU of type float32. (This is a ratio. Max is 1. Min is 0.)\n    \n    \"\"\"\n\n    \n    results = []\n    \n    for i in range(0,y_true.shape[0]):\n    \n        # set the types so we are sure what type we are using\n        y_true = y_true.astype(np.float32)\n        y_pred = y_pred.astype(np.float32)\n\n\n        # boxTrue\n        x_boxTrue_tleft = y_true[0,0]  # numpy index selection\n        y_boxTrue_tleft = y_true[0,1]\n        boxTrue_width = y_true[0,2]\n        boxTrue_height = y_true[0,3]\n        area_boxTrue = (boxTrue_width * boxTrue_height)\n\n        # boxPred\n        x_boxPred_tleft = y_pred[0,0]\n        y_boxPred_tleft = y_pred[0,1]\n        boxPred_width = y_pred[0,2]\n        boxPred_height = y_pred[0,3]\n        area_boxPred = (boxPred_width * boxPred_height)\n\n\n        # calculate the bottom right coordinates for boxTrue and boxPred\n\n        # boxTrue\n        x_boxTrue_br = x_boxTrue_tleft + boxTrue_width\n        y_boxTrue_br = y_boxTrue_tleft + boxTrue_height # Version 2 revision\n\n        # boxPred\n        x_boxPred_br = x_boxPred_tleft + boxPred_width\n        y_boxPred_br = y_boxPred_tleft + boxPred_height # Version 2 revision\n\n\n        # calculate the top left and bottom right coordinates for the intersection box, boxInt\n\n        # boxInt - top left coords\n        x_boxInt_tleft = np.max([x_boxTrue_tleft,x_boxPred_tleft])\n        y_boxInt_tleft = np.max([y_boxTrue_tleft,y_boxPred_tleft]) # Version 2 revision\n\n        # boxInt - bottom right coords\n        x_boxInt_br = np.min([x_boxTrue_br,x_boxPred_br])\n        y_boxInt_br = np.min([y_boxTrue_br,y_boxPred_br]) \n\n        # Calculate the area of boxInt, i.e. the area of the intersection \n        # between boxTrue and boxPred.\n        # The np.max() function forces the intersection area to 0 if the boxes don't overlap.\n        \n        \n        # Version 2 revision\n        area_of_intersection = \\\n        np.max([0,(x_boxInt_br - x_boxInt_tleft)]) * np.max([0,(y_boxInt_br - y_boxInt_tleft)])\n\n        iou = area_of_intersection \/ ((area_boxTrue + area_boxPred) - area_of_intersection)\n\n\n        # This must match the type used in py_func\n        iou = iou.astype(np.float32)\n        \n        # append the result to a list at the end of each loop\n        results.append(iou)\n    \n    # return the mean IoU score for the batch\n    return np.mean(results)\n","8cde6c05":"def IoU(y_true, y_pred):\n    \n    # Note: the type float32 is very important. It must be the same type as the output from\n    # the python function above or you too may spend many late night hours \n    # trying to debug and almost give up.\n    \n    iou = tf.py_func(calculate_iou, [y_true, y_pred], tf.float32)\n\n    return iou","eabf915a":"# model.compile(optimizer='Adam', loss='mse', metrics=[IoU])","6498132d":"import numpy as np\nimport tensorflow as tf\n\n# create two inputs simulating a batch_size = 3\n# shape (3,5)\ny_true = np.array([[1,5,2,3,0.5], [1,5,2,3,0.5], [1,5,2,3,0.5]])\ny_pred = np.array([[2,4,3,3,0.7], [2,4,3,3,0.7], [2,4,3,3,0.7]])\n\n# call the first function\nresult = calculate_iou(y_true, y_pred)\n\nprint(result)\nprint(type(result))","dafe7319":"# call the second function\niou = IoU(y_true, y_pred)\n\nprint(type(iou))","5aa1fd13":"# because iou is a tensor we can only print it inside a Tensorflow session\n\nwith tf.Session() as sess:\n    print(sess.run(iou))","c30bea46":"<hr>\n\nThank you for reading.","e75a8ad0":"In this kernel I will quickly demonstrate a method for implementing a custom metric in Keras without having to use tensors to write it. A tensorflow wrapper function called tf.py_func makes this possible. The body of the function is written using numpy and then inserted into py_func. You can think of py_func as a kind of Trojan horse.\n\nWe will implement a basic IoU (Intersection Over Union) metric.","09a7d509":"**Version 2:**\n\nIn the previous version I implemented a simple IoU function imagining a graph with the origin (0,0) located in the bottom left. In this version I've updated the IoU function imagining a numpy array with the origin (0,0) located at the top left corner. \n\nThis version can be a bit confusing. To understand it better keep in mind that:\n\nGiven bounding box: *[x, y, width, height, conf_score]*\n\nthen index selection in numpy will take the form *array[y,x]* i.e. *array[row, column]*.","7642c7eb":"We will be predicting one bounding box. The output has 5 columns. This is the form:\n\ny_true = [x, y, width, height, conf]<br>\ny_pred = [x, y, width, height, conf]\n\nx and y are the coordinates of the top left corner of the box and<br>\nconf is the confidence score.","b87f4eb9":"### What output do we get from Keras?","ebd0f54a":"### Define a function containing py_func","e3c9d67b":"<hr>","9e7ad269":"As the model is running Keras outputs batches of y_pred and y_true as numpy arrays. So if y is as shown above and we have a batch size of 10, then y_pred and y_true will be numpy arrays with a shape (10,5) i.e. 10 rows and 5 colums.","5e5a0638":"### What is the form of y, the target?","25f07c1d":"This is my simple IoU implementation:","b5fdcfa6":"### How to use this with Keras?","c3657dc1":"### What is IoU?","68dedf85":"We need to simply enter the IoU function as a metric in the compile step, like this:","1e7089fe":"Our custon IoU function will take y_true and y_pred as inputs and output the average IoU score for the batch - as a scalar of type float32. This is what py_func needs to work its magic.\nSomething to note is that all caculations done within the function must be numpy. For example np.min() and np.max(). Python functions should not be used.","bfd2787f":"### The IoU Function","374bd13d":"This is a quick test to make sure that the functions we created are working as expected. The final answer should be:<br> IoU = 0.153846","1928dca1":"### Resources\n\nThese are some resources that I found helpful when learning this subject:","d8691fe7":"<hr>","54598e2d":"This is a good blog post that clearly explains IoU.\n\nhttps:\/\/www.pyimagesearch.com\/2016\/11\/07\/intersection-over-union-iou-for-object-detection\/","323d191a":"Tensorflow info on py_func:<br>\n https:\/\/www.tensorflow.org\/api_docs\/python\/tf\/py_func\n\nBlog post explaining IoU:<br>\n https:\/\/www.pyimagesearch.com\/2016\/11\/07\/intersection-over-union-iou-for-object-detection\/\n\nKernel by @aglotero where I first saw py_func used:<br>\nhttps:\/\/www.kaggle.com\/aglotero\/another-iou-metric\n\n","014dbf6e":"#### Introduction","71608644":"The input arguments will be y_true, y_pred and the \"calculate_iou\" function we created above.","f25a8e5b":"### Testing the functions","bb6f5451":"#### and that's it. "}}