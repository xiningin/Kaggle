{"cell_type":{"8f231dd1":"code","4476cd5f":"code","f3f325eb":"code","880bc97b":"code","0489d636":"code","c6d9d15a":"code","c30fe685":"code","b52fb751":"code","b2ac5b32":"code","5ecba9e0":"code","38acfb89":"code","d16ebbb6":"code","79820ed3":"code","2fefffaf":"code","a04c75ec":"code","7ae0ddf3":"code","7d72c0d1":"code","539770a4":"code","2516250d":"code","c8dcf425":"code","9cfc3224":"code","f7239d86":"code","2020c954":"code","8a91ae18":"code","448fea22":"code","331fcf50":"code","8476c90b":"code","c073d1f9":"code","c06880c9":"code","5703ba18":"code","557b53f7":"code","b8f9fdcf":"markdown","0e90a4ae":"markdown","a857e184":"markdown","95325c6b":"markdown","c1355f88":"markdown","271c6226":"markdown","123a82fb":"markdown","ff1f3003":"markdown","cac45069":"markdown","5fe10b0e":"markdown","b00b1d14":"markdown","ae30b320":"markdown","6ae5de85":"markdown","ca00690c":"markdown","39d01660":"markdown","1f6019c9":"markdown","fead989d":"markdown","b70e28e3":"markdown","bd015153":"markdown","a71e4957":"markdown","35405d01":"markdown","f7061f72":"markdown","bde5c97b":"markdown","4f533d7d":"markdown","351b9d1c":"markdown","9dcbdf1e":"markdown","ef3b1b6e":"markdown"},"source":{"8f231dd1":"import numpy as np\nimport pandas as pd\nimport scipy.special\nimport matplotlib.pyplot as plt\nimport os","4476cd5f":"path_in = '..\/input\/santa-2019-revenge-of-the-accountants\/'\npath_start_solution = '..\/input\/santa-workshop-tour-start-solution\/'\nprint(os.listdir(path_in))\nprint(os.listdir(path_start_solution))","f3f325eb":"data = pd.read_csv(path_in+'family_data.csv')\ndata.index = data['family_id']\nsamp_subm = pd.read_csv(path_in+'sample_submission.csv')\nstart_solution = pd.read_csv(path_start_solution+'revenge_start_solution_xp2.csv', index_col=0)","880bc97b":"num_days = 100\nlower = 125\nupper = 300\ndays = list(range(num_days, 0, -1))\nweights=[1\/(i*i) for i in range(1, 6)]","0489d636":"def calc_family_costs(family):\n    assigned_day = family['assigned_day']\n    number_member = family['n_people']\n    if assigned_day == family['choice_0']:\n        penalty = 0\n    elif assigned_day == family['choice_1']:\n        penalty = 50\n    elif assigned_day == family['choice_2']:\n        penalty = 50 + 9 * number_member\n    elif assigned_day == family['choice_3']:\n        penalty = 100 + 9 * number_member\n    elif assigned_day == family['choice_4']:\n        penalty = 200 + 9 * number_member\n    elif assigned_day == family['choice_5']:\n        penalty = 200 + 18 * number_member\n    elif assigned_day == family['choice_6']:\n        penalty = 300 + 18 * number_member\n    elif assigned_day == family['choice_7']:\n        penalty = 300 + 36 * number_member\n    elif assigned_day == family['choice_8']:\n        penalty = 400 + 36 * number_member\n    elif assigned_day == family['choice_9']:\n        penalty = 500 + 36 * number_member + 199 * number_member\n    else:\n        penalty = 500 + 36 * number_member + 398 * number_member\n    return penalty","c6d9d15a":"def calc_accounting_cost(data):\n    accounting_cost = 0\n    daily_occupancy = {k:0 for k in days}\n    family_size_dict = data[['n_people']].to_dict()['n_people']\n    for f, d in enumerate(data['assigned_day']):\n        n = family_size_dict[f]\n        daily_occupancy[d] += n\n    \n    # day = 100\n    accounting_cost = (daily_occupancy[days[0]]-125.0) \/ 400.0 * sum(weights)*daily_occupancy[days[0]]**(0.5)\n    \n    # day = 99\n    temp = 0\n    diff = abs(daily_occupancy[days[1]]-daily_occupancy[days[0]])\n    for j in range(5):\n        temp += weights[j]*daily_occupancy[days[1]]**(0.5+diff\/50.0)\n    temp = ((daily_occupancy[days[1]]-125.0) \/ 400.0) * temp\n    accounting_cost += temp\n    \n    # day = 98\n    temp = 0\n    diff = abs(daily_occupancy[days[2]]-daily_occupancy[days[1]])\n    temp += daily_occupancy[days[2]]**(0.5+diff\/50)\n    diff = abs(daily_occupancy[days[2]]-daily_occupancy[days[0]])\n    for j in range(1, 5):\n        temp += weights[j]*daily_occupancy[days[2]]**(0.5+diff\/50.0)\n    temp = ((daily_occupancy[days[2]]-125.0) \/ 400.0) * temp\n    accounting_cost += temp\n    \n    # day = 97\n    temp = 0\n    diff = abs(daily_occupancy[days[3]]-daily_occupancy[days[2]])\n    temp += daily_occupancy[days[3]]**(0.5+diff\/50)\n    diff = abs(daily_occupancy[days[3]]-daily_occupancy[days[1]])\n    temp += weights[1]*daily_occupancy[days[3]]**(0.5+diff\/50)\n    diff = abs(daily_occupancy[days[3]]-daily_occupancy[days[0]])\n    for j in range(2, 5):\n        temp += weights[j]*daily_occupancy[days[3]]**(0.5+diff\/50.0)\n    temp = ((daily_occupancy[days[3]]-125.0) \/ 400.0) * temp\n    accounting_cost += temp\n    \n    # day = 96\n    temp = 0\n    diff = abs(daily_occupancy[days[4]]-daily_occupancy[days[3]])\n    temp += daily_occupancy[days[4]]**(0.5+diff\/50)\n    diff = abs(daily_occupancy[days[4]]-daily_occupancy[days[2]])\n    temp += weights[1]*daily_occupancy[days[4]]**(0.5+diff\/50)\n    diff = abs(daily_occupancy[days[4]]-daily_occupancy[days[1]])\n    temp += weights[2]*daily_occupancy[days[4]]**(0.5+diff\/50)\n    diff = abs(daily_occupancy[days[4]]-daily_occupancy[days[0]])\n    for j in range(3, 5):\n        temp += weights[j]*daily_occupancy[days[4]]**(0.5+diff\/50.0)\n    temp = ((daily_occupancy[days[4]]-125.0) \/ 400.0) * temp\n    accounting_cost += temp\n    \n    for day in days[5:]:\n        temp = 0\n        for j in range(5):\n            diff = abs(daily_occupancy[day] - daily_occupancy[day+j+1])\n            temp += weights[j]*daily_occupancy[day]**(0.5 + diff \/ 50.0)\n        temp = ((daily_occupancy[day]-125.0) \/ 400.0) * temp\n        \n        accounting_cost += temp\n    return accounting_cost","c30fe685":"def plot_results(data, name):\n    x = data.columns\n    y = data.loc[name]\n    plt.plot(x, y, 'ro')\n    plt.grid()\n    plt.title(name)\n    plt.xlabel('steps')\n    plt.ylabel('value')\n    plt.show()","b52fb751":"def check_day(data, day):\n    group_data = data.groupby('assigned_day').sum()['n_people'].to_frame()\n    if (125 <= group_data.loc[day, 'n_people']) & (group_data.loc[day, 'n_people'] <= 300):\n        return True\n    else:\n        return False","b2ac5b32":"for i in range(num_days):\n    data.loc[i*60:(i+1)*60-1, 'assigned_day'] = i+1\ndata['assigned_day'] = data['assigned_day'].astype(int)","5ecba9e0":"data['assigned_day'] = start_solution['assigned_day']","38acfb89":"data.head()","d16ebbb6":"family_id = 100\ncalc_family_costs(data.iloc[family_id])","79820ed3":"data['penalty_cost'] = data.apply(calc_family_costs, axis=1)\ndata['penalty_cost'].sum()","2fefffaf":"data.head()","a04c75ec":"acc_costs = calc_accounting_cost(data)\nacc_costs","7ae0ddf3":"print('Total costs:', data['penalty_cost'].sum()+ acc_costs)","7d72c0d1":"def check_swap_day(data, family, choice):\n    data_copy = data.copy()\n    data_copy.loc[family, 'assigned_day'] = data_copy.loc[family, 'choice_'+str(choice)]\n    data_copy.loc[family, 'penalty_cost'] = calc_family_costs(data_copy.iloc[family])\n    \n    penalty_before = data.loc[family, 'penalty_cost']\n    accounting_before = calc_accounting_cost(data)\n    \n    penalty_after = data_copy.loc[family, 'penalty_cost']\n    accounting_after = calc_accounting_cost(data_copy)\n    \n    # Check conditions\n    day_before = check_day(data_copy, data.loc[family, 'assigned_day'])\n    day_after = check_day(data_copy, data_copy.loc[family, 'assigned_day'])\n\n    if(day_before==True and day_after==True):\n        improvement = (penalty_before-penalty_after)+(accounting_before-accounting_after)\n    else:\n        improvement = -1\n    \n    return improvement","539770a4":"family_id = 386\ncheck_swap_day(data, family_id, 0)","2516250d":"def check_swap_family(data, family, choice):\n    family1 = family\n    day_family1 = data.loc[family1, 'assigned_day']\n    penalty1 = data.loc[family1, 'penalty_cost']\n    member_family1 = data.loc[family1, 'n_people']\n    \n    day_member_list = data.groupby('assigned_day')['family_id'].apply(list).to_frame()\n    \n    improvements = {}\n    for member in day_member_list.loc[data.loc[family1, 'choice_'+str(choice)], 'family_id']:\n        family2 = member\n        day_family2 = data.loc[family2, 'assigned_day']\n        member_family2 = data.loc[family2, 'n_people']\n        penalty2 = data.loc[family2, 'penalty_cost']\n        \n        # simulate the swap with another family\n        data_copy = data.copy()\n        data_copy.loc[family2, 'assigned_day'] = data_copy.loc[family1, 'assigned_day']\n        data_copy.loc[family1, 'assigned_day'] = data_copy.loc[family1, 'choice_'+str(choice)]\n        # calc the new penalty cost for both families\n        new_penalty1 = calc_family_costs(data_copy.iloc[family1])\n        new_penalty2 = calc_family_costs(data_copy.iloc[family2])\n        # check both days before and after swaping\n        day_before = check_day(data_copy, data.loc[family1, 'assigned_day'])\n        day_after = check_day(data_copy, data_copy.loc[family1, 'choice_'+str(choice)])\n        # calc the accounting costs before and after swaping\n        accounting_before = calc_accounting_cost(data)\n        accounting_after = calc_accounting_cost(data_copy)\n        if(day_before==True and day_after==True):\n            improvement = (penalty1-new_penalty1) + (penalty2-new_penalty2) + (accounting_before-accounting_after)\n        else:\n            improvement = -1\n        improvements.update({member:improvement})\n   \n    maximum = max(zip(improvements.values(), improvements.keys()))\n    family_swap = maximum[1]\n    return improvement, family_swap","c8dcf425":"family_id = 386\ncheck_swap_family(data, family_id, 0)","9cfc3224":"family_id = 386\nchoice = 0\nimprovement_day = check_swap_day(data, family_id, choice)\nimprovement_family, family_swap = check_swap_family(data, family_id, choice)\nimprovement_day, improvement_family, family_swap","f7239d86":"def go_to_bazaar(data, family):\n    family1 = family\n    day_family1 = data.loc[family1, 'assigned_day']\n    penalty1 = data.loc[family1, 'penalty_cost']\n    member_family1 = data.loc[family1, 'n_people']\n    \n    status = False\n    \n    for choice in range(10):\n        \"\"\" Should i swap the day? \"\"\"\n        improvement_day = check_swap_day(data, family1, choice)\n        \"\"\" Should i swap with another family? \"\"\"\n        improvement_family, family2 = check_swap_family(data, family1, choice)\n    \n        if(improvement_day >= 0 or improvement_family >= 0):\n            if(improvement_day >= improvement_family):\n                #print('swap day')\n                data.loc[family, 'assigned_day'] = data.loc[family, 'choice_'+str(choice)]\n                data.loc[family, 'penalty_cost'] = calc_family_costs(data.iloc[family])\n                status = True\n            else:\n                #print('swap family')\n                data.loc[family2, 'assigned_day'] = data.loc[family1, 'assigned_day']\n                data.loc[family1, 'assigned_day'] = data.loc[family1, 'choice_'+str(choice)]\n        \n                data.loc[family1, 'penalty_cost'] = calc_family_costs(data.iloc[family1])\n                data.loc[family2, 'penalty_cost'] = calc_family_costs(data.iloc[family2])\n                status = True\n            if(status==True):\n                break","2020c954":"family_id = 386\n#go_to_bazaar(data, family_id)\n#print('Total costs:', data['penalty_cost'].sum(), calc_accounting_cost(data))","8a91ae18":"results = pd.DataFrame()\nresults[0] = data['penalty_cost'].describe()\nresults.loc['costs', 0] = data['penalty_cost'].sum()+calc_accounting_cost(data)","448fea22":"num_steps = 3\n\nfor step in range(num_steps):\n    print('step: ', step)\n    families_high_scored = list(data[data['penalty_cost']>0].index)\n    print('# families: ', len(families_high_scored),\n          'first:', families_high_scored[0],\n          'last:', families_high_scored[-1])\n    for family in families_high_scored:\n        #print('   family:', family)\n        go_to_bazaar(data, family)\n    data['penalty_cost'] = data.apply(calc_family_costs, axis=1)\n    print('costs:', data['penalty_cost'].sum(), calc_accounting_cost(data))\n    results[step+1] = data['penalty_cost'].describe()\n    results.loc['costs', step+1] = data['penalty_cost'].sum()+calc_accounting_cost(data)","331fcf50":"results = results.reindex(sorted(results.columns), axis=1)","8476c90b":"plot_results(results, 'costs')","c073d1f9":"plot_results(results, 'mean')","c06880c9":"print('Total costs:', data['penalty_cost'].sum() + calc_accounting_cost(data))","5703ba18":"data = data.sort_index()\noutput = pd.DataFrame({'family_id': samp_subm.index,\n                       'assigned_day': data['assigned_day']})\noutput.to_csv('submission.csv', index=False)","557b53f7":"import pandas as pd\nrevenge_start_solution_01 = pd.read_csv(\"..\/input\/santa-workshop-tour-start-solution\/revenge_start_solution_01.csv\")\nsanta_workshop_tour_start_solution_01 = pd.read_csv(\"..\/input\/santa-workshop-tour-start-solution\/santa_workshop_tour_start_solution_01.csv\")","b8f9fdcf":"# Welcome to Santa's Workshop Tour Bazaar 2019: Revenge of the Accountants\n\nThis is a starter code and easy to understand. \n\nWe consider a linear optimization problem to minimize a cost function subject to constraints. The cost function contains the family (preference) and accounding (penalty) costs. The constraints are: For each day the total number of people attending the workshop must be between 125 and 300. \n\nThe algorithm: We create a simple feasible start solution for the first iteration step. For this we say that every day get the same number fo families. This number is 50. After that the families go to the bazaar to reduce the total costs. Each familie with preference costs greater than 0 tries to swap the day with another family or swap the assigned day. But the swap is only valid if it changes the preference or acoounding costs.\n\nThe convergence of the algorithm:\n\n|iteration step| objective value|\n|---------------|-------------|\n | 0 | 12.778.763 |   \n | 1 |  766.069|   \n | 2 |  462.110|   \n | 3 |  416.496|\n | 4 | 400.576|\n | 5 | 395.614|\n | 6 | |\n | 7 |\n | ...|...|\n |x|145.111|\n |x+1| 144.594|\n |x+2|144.413|\n |x+3||\n |x+4||\n |x+5||\n \n We can see that the improvement of the objective value is small in the later steps. Alternatively you can also start with another start solution which is closer to the optimum. \n \n For this version we start with a precalculated start solution.","0e90a4ae":"Test the check_swap_family function.","a857e184":"## Accounting Costs","95325c6b":"# Load Libraries","c1355f88":"Calc the family costs for a given family_id.","271c6226":"# Iterations","123a82fb":"# Store Results\nWe want to analyse the results of the iteration steps.","ff1f3003":"# Write Output","cac45069":"## Check day\nTo check a swap we have to test the constraint explained before.","5fe10b0e":"Compare the check_swap_day and check_swap_family functions.","b00b1d14":"Test the go_to_bazaar function.","ae30b320":"# Parameter","6ae5de85":"Load a start solution.","ca00690c":"# Read Data\nHere you can also load a start solution.","39d01660":"Test the check_swap_day function.","1f6019c9":"Calc the accounting costs for all days and all families.","fead989d":"Combine the check_swap_day and check_swap_family functions to the algorithm.","b70e28e3":"Have a look on the data.","bd015153":"# Functions\nWe define some function for the method used below.\n## Calc Family Costs","a71e4957":"# Method To Reduce The Total Costs\nThe main idea is to change the day with another family or swap the assigned day with respect to the constraints.","35405d01":"# Analyse Results","f7061f72":"# Input Data","bde5c97b":"Calc the cost for all families.","4f533d7d":"Total costs for the start solution are the sum over the family costs and the accounting cost.","351b9d1c":"## Plot Function\nWe use a plot function to visualize the total costs of each iteration step and check the convergence.","9dcbdf1e":"# Create A Start Solution\nWe use a simple distribution and test the above functions to calc the cost per family.","ef3b1b6e":"# Final costs"}}