{"cell_type":{"b2f46a58":"code","66ff36d5":"code","d23c1e92":"code","6a0112e2":"code","e00f2f5a":"code","c5670b18":"code","e83a0d8e":"code","71860bac":"markdown","12230a76":"markdown","42f4356a":"markdown","3f27c996":"markdown"},"source":{"b2f46a58":"import numpy as np\nimport pandas as pd\nfrom io import BytesIO\n\nimport torch\nimport torch.nn.functional as F\n","66ff36d5":"ds = np.lib.DataSource()\nfp = ds.open('..\/input\/ml-scratch-master\/ML_Scratch-master\/knn\/iris.data')\n\nx = np.genfromtxt(BytesIO(fp.read().encode()), delimiter=',', usecols=range(2), max_rows=100)\ny = np.zeros(100)\ny[50:] = 1\n\nnp.random.seed(1)\nidx = np.arange(y.shape[0])\nnp.random.shuffle(idx)\nX_test, y_test = x[idx[:25]], y[idx[:25]]\nX_train, y_train = x[idx[25:]], y[idx[25:]]\nmu, std = np.mean(X_train, axis=0), np.std(X_train, axis=0)\nX_train, X_test = (X_train - mu) \/ std, (X_test - mu) \/ std","d23c1e92":"device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nclass LogisticRegression3(torch.nn.Module):\n\n    def __init__(self, num_features):\n        super(LogisticRegression3, self).__init__()\n        self.linear = torch.nn.Linear(num_features, 1)\n       \n    def forward(self, x):\n        logits = self.linear(x)\n        probas = torch.sigmoid(logits)\n        return probas\n\nmodel = LogisticRegression3(num_features=2).to(device)","6a0112e2":"cost_fn = torch.nn.BCELoss(reduction='sum')\noptimizer = torch.optim.SGD(model.parameters(), lr=0.1)","e00f2f5a":"def comp_accuracy(label_var, pred_probas):\n    pred_labels = custom_where((pred_probas > 0.5).float(), 1, 0).view(-1)\n    acc = torch.sum(pred_labels == label_var.view(-1)).float() \/ label_var.size(0)\n    return acc\ndef custom_where(cond, x_1, x_2):\n    return (cond * x_1) + ((1-cond) * x_2)","c5670b18":"num_epochs = 1\n\nX_train_tensor = torch.tensor(X_train, dtype=torch.float32, device=device)\ny_train_tensor = torch.tensor(y_train, dtype=torch.float32, device=device).view(-1, 1)\n\n\nfor epoch in range(num_epochs):\n    \n    #### Compute outputs ####\n    predictions = model(X_train_tensor)\n    \n    #### Compute gradients ####\n    loss = cost_fn(predictions, y_train_tensor)\n    optimizer.zero_grad()\n    loss.backward()\n    \n    optimizer.step()\n\n","e83a0d8e":"X_test_tensor = torch.tensor(X_test, dtype=torch.float32, device=device)\ny_test_tensor = torch.tensor(y_test, dtype=torch.float32, device=device)\n\npred_probas = model(X_test_tensor)\ntest_acc = comp_accuracy(y_test_tensor, pred_probas)\n\nprint('Test set accuracy: %.2f%%' % (test_acc*100))\n","71860bac":"### Evaluate","12230a76":"### Model","42f4356a":"### Train","3f27c996":"### Prepare Data"}}