{"cell_type":{"b265a2b7":"code","426c3e40":"code","5b045e1a":"code","5ecbb092":"code","a1a49857":"code","f7028f1f":"code","5c4f1f13":"code","83993ff2":"code","78db7b6d":"code","1ed2e4aa":"code","e60e69e6":"code","c60f2d8e":"code","a0eecc2f":"code","04379df1":"code","c490644d":"code","ca29d7bf":"code","89f4a59e":"code","c6372ed5":"code","cf8aa32d":"code","01132e9e":"code","90b3f4b5":"code","3f4503a6":"code","3608e0b1":"code","4d1169cf":"code","f6ef1554":"code","1273cfce":"code","f28092ad":"code","050e2b3e":"code","db7a41b4":"code","c83590aa":"code","5e3bfb72":"code","2eda4ff3":"code","c5726e0d":"code","0560cc9f":"code","d77b2dd5":"code","a95b035d":"code","6ba18665":"code","4b48018d":"code","a4cdc858":"markdown","b534215f":"markdown","79fe7d4f":"markdown","83532c15":"markdown","16d13489":"markdown","a511d7c7":"markdown","d60a8bdf":"markdown","2294b94e":"markdown","b2dff516":"markdown"},"source":{"b265a2b7":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport matplotlib.style as style\nstyle.use('fivethirtyeight')\nimport plotly.express as px\nimport seaborn as sns\nsns.set_style('whitegrid')\n\nimport os\nimport warnings\nwarnings.filterwarnings('ignore')\nfrom joblib import Parallel, delayed\n\nfrom xgboost import XGBRegressor\nfrom sklearn.model_selection import KFold\nimport xgboost as xgb\nfrom sklearn.metrics import r2_score\nimport lightgbm as lgbm\nfrom lightgbm import LGBMRegressor","426c3e40":"# Import data\ntrain = pd.read_csv('..\/input\/optiver-realized-volatility-prediction\/train.csv')\ntest = pd.read_csv('..\/input\/optiver-realized-volatility-prediction\/test.csv')\nbook_train = pd.read_parquet('..\/input\/optiver-realized-volatility-prediction\/book_train.parquet')\nbook_test = pd.read_parquet('..\/input\/optiver-realized-volatility-prediction\/book_test.parquet')\ntrade_train = pd.read_parquet('..\/input\/optiver-realized-volatility-prediction\/trade_train.parquet')\ntrade_test = pd.read_parquet('..\/input\/optiver-realized-volatility-prediction\/trade_test.parquet')\nsubmission = pd.read_csv('..\/input\/optiver-realized-volatility-prediction\/sample_submission.csv')","5b045e1a":"train.head()","5ecbb092":"book_train.head()","a1a49857":"trade_train.head()","f7028f1f":"train['stock_id'].value_counts()","5c4f1f13":"sns.histplot(train['target']);","83993ff2":"def visualize_bid_ask(df, groupby, bid_col, ask_col):\n    group = df.groupby([groupby])[bid_col, ask_col].mean()\n    \n    # Plot bid vs ask\n    fig = px.scatter(group, x=bid_col, y=ask_col, template='plotly_dark+presentation', width=1000, height=400)\n    fig.show()","78db7b6d":"visualize_bid_ask(book_train, 'stock_id', 'bid_price1', 'ask_price1')","1ed2e4aa":"visualize_bid_ask(book_train, 'stock_id', 'bid_price2', 'ask_price2')","e60e69e6":"volatility = train.sort_values('target', ascending=False)","c60f2d8e":"plt.figure(figsize=(10, 5))\nsns.barplot(x='stock_id', y='target', data=volatility[:20]);\nplt.title('High Volatile Stocks');","a0eecc2f":"plt.figure(figsize=(10, 5))\nsns.barplot(x='stock_id', y='target', data=volatility[-50:]);\nplt.title('Low Volatile Stocks');","04379df1":"def log_return(list_stock_prices):\n    return np.log(list_stock_prices).diff()","c490644d":"def realized_volatility(series_log_return):\n    return np.sqrt(np.sum(series_log_return**2))","ca29d7bf":"def get_stock_stat_df(stock_id, dataset):\n    \n    book = pd.read_parquet(f'..\/input\/optiver-realized-volatility-prediction\/book_{dataset}.parquet\/stock_id={stock_id}\/')\n    book['stock_id'] = stock_id\n    \n    # Calculate WAP\n    book['wap1'] = (book.bid_price1 * book.ask_size1 + book.ask_price1 * book.bid_size1) \/ (book.bid_size1 + book.ask_size1)\n    book['wap2'] = (book.bid_price2 * book.ask_size2 + book.ask_price2 * book.bid_size2) \/ (book.bid_size2+ book.ask_size2)\n    \n    # Log return\n    book['log_return1'] = log_return(book['wap1'])\n    book['log_return2'] = log_return(book['wap2'])\n    \n    # Bid Ask Spread\n    book['bid_ask_spread1'] = abs(book['bid_price1'] - book['ask_price1'])\n    book['bid_ask_spread2'] = abs(book['bid_price2'] - book['ask_price2'])\n    \n    book = book[~book['log_return1'].isnull()]\n    book = book[~book['log_return2'].isnull()]\n    \n#     stock_stat = book.groupby(['stock_id', 'time_id']).agg({'bid_ask_spread1':['mean'],\n#                                                            'bid_ask_spread2':['mean'],\n#                                                            'log_return1':[realized_volatility],\n#                                                            'log_return2':[realized_volatility]}).reset_index()\n\n    stock_stat = book.groupby(['stock_id', 'time_id']).agg(sec_in_bucket=('seconds_in_bucket', 'mean'),\n                                                           bid_ask_spread_1=('bid_ask_spread1', 'mean'),\n                                                           bid_ask_spread_2=('bid_ask_spread2', 'mean'),\n                                                           log_return_1=('log_return1', realized_volatility),\n                                                           log_return_2=('log_return2', realized_volatility)).reset_index()\n    \n    # Trade\n    trade =  pd.read_parquet(f'..\/input\/optiver-realized-volatility-prediction\/trade_{dataset}.parquet\/stock_id={stock_id}\/')\n    trade['stock_id'] = stock_id\n    trade['trade_log_return'] = trade.groupby(['time_id'])['price'].apply(log_return).fillna(0)\n\n#     trade_stat = trade.groupby(['stock_id', 'time_id']).agg({'price':['mean'], \n#                                                              'size':['sum'], \n#                                                              'order_count':['sum'],\n#                                                              'trade_log_return':[realized_volatility]}).reset_index()\n\n    trade_stat = trade.groupby(['stock_id', 'time_id']).agg(Price=('price', 'mean'),\n                                                            Size=('size', 'sum'),\n                                                            order_count=('order_count', 'sum'),\n                                                            trade_count=('order_count', 'count'),\n                                                            Trade_log=('trade_log_return', realized_volatility)).reset_index()\n    \n    # Merge book and trade dataframe\n    stats = stock_stat.merge(trade_stat, on=['stock_id', 'time_id'], how='left')\n    \n    return stats\n\ndef get_dataSet(stock_ids : list, dataType = 'train'):\n\n    stock_stat = Parallel(n_jobs=-1)(\n        delayed(get_stock_stat_df)(stock_id, dataType) \n        for stock_id in stock_ids\n    )\n    \n    stock_stat_df = pd.concat(stock_stat, ignore_index = True)\n\n    return stock_stat_df","89f4a59e":"%%time\nstock_ids = list(train['stock_id'].unique())\ntrain_stock_stats_df = get_dataSet(stock_ids, 'train')","c6372ed5":"data = pd.merge(train, train_stock_stats_df, on = ['stock_id', 'time_id'], how = 'left')","cf8aa32d":"data.columns","01132e9e":"# data=data.rename(columns={('bid_ask_spread1', 'mean'):'bid_ask_spread1', \n#              ('bid_ask_spread2', 'mean'):'bid_ask_spread2',\n#              ('log_return1', 'realized_volatility'):'log_return1',\n#              ('log_return2', 'realized_volatility'):'log_return2',\n#              ('price', 'mean'):'Price',\n#              ('size', 'sum'):'Size',\n#              ('order_count', 'sum'):'Order_count',\n#              ('trade_log_return', 'realized_volatility'):'Trade_log_return'\n#             })","90b3f4b5":"data.fillna(0, inplace=True)","3f4503a6":"def rmspe(y_true, y_pred):\n    return  (np.sqrt(np.mean(np.square((y_true - y_pred) \/ y_true))))","3608e0b1":"X = data.drop('target', axis=1)\ny = data['target']","4d1169cf":"def feval_RMSPE(preds, train_data):\n    labels = train_data.get_label()\n    return 'RMSPE', round(rmspe(y_true = labels, y_pred = preds),5), False","f6ef1554":"def Xgboost(X, y, params, folds=5):\n    \n    best_model = None\n    best_rmspe = None\n    \n    skf = KFold(n_splits=folds, shuffle=True, random_state=42)\n    for fold, (tr_idx, ts_idx) in enumerate(skf.split(X)):\n        print(f'Fold: {fold}')\n        \n        x_tr, y_tr = X.iloc[tr_idx], y.iloc[tr_idx]\n        x_ts, y_ts = X.iloc[ts_idx], y.iloc[ts_idx]\n        \n        model = XGBRegressor(**params)\n        model.fit(x_tr, y_tr,\n                 eval_set=[(x_ts, y_ts)],\n                 early_stopping_rounds=100,\n                  verbose=False)\n        \n        pred = model.predict(x_ts)\n        error = rmspe(y_ts, pred)\n        print(f'RMSPE: {error}')\n        print('-'*50)\n        \n        if best_rmspe == None or best_rmspe > error:\n            best_rmspe = error\n            best_model = model\n        \n    return best_model","1273cfce":"xgb_params = {\n    'objective':'reg:squarederror',\n    'n_jobs':-1,\n    'eval_metric': \"rmse\",\n#     \"tree_method\": 'gpu_hist', \n#     \"gpu_id\": 0\n}","f28092ad":"model_xgb = Xgboost(X, y, xgb_params, 5)","050e2b3e":"xgb.plot_importance(model_xgb)","db7a41b4":"def LGBM(X, y, params, folds=5, print_error=True):\n    \n    best_model = None\n    best_rmspe = None\n    \n    cat_col = ['stock_id']\n    skf = KFold(n_splits=folds, shuffle=True, random_state=42)\n    for fold, (tr_idx, ts_idx) in enumerate(skf.split(X)):\n        \n        x_tr, y_tr = X.iloc[tr_idx], y.iloc[tr_idx]\n        x_ts, y_ts = X.iloc[ts_idx], y.iloc[ts_idx]\n\n        train = lgbm.Dataset(x_tr, label=y_tr, categorical_feature=cat_col, weight=1\/np.power(y_tr,2))\n        test = lgbm.Dataset(x_ts, label=y_ts, categorical_feature=cat_col, weight=1\/np.power(y_ts,2))\n\n        model = lgbm.train(params, \n                          train, \n                          3000, \n                          valid_sets=test, \n                          feval=feval_RMSPE,\n                          early_stopping_rounds=500,\n                          verbose_eval=False\n                         )\n\n        pred = model.predict(x_ts)\n        error = rmspe(y_ts, pred)\n        \n        if print_error:\n            print(f'Fold: {fold}')\n            print(f'RMSPE: {error}')\n            print('-'*50)\n\n        if best_rmspe == None or best_rmspe > error:\n            best_rsmpe = error\n            best_model = model\n        \n    return best_model","c83590aa":"lgbm_params = {\n    'task': 'train',\n    'boosting_type': 'gbdt',\n    'learning_rate': 0.01,\n    'objective': 'regression',\n    'metric': 'None',\n    'max_depth': -1,\n    'n_jobs': -1,\n    'feature_fraction': 0.7,\n    'bagging_fraction': 0.7,\n    'lambda_l2': 1,\n    'verbose': -1\n}\n\nmodel_lgbm = LGBM(X, y, lgbm_params, 5)","5e3bfb72":"lgbm.plot_importance(model_lgbm);","2eda4ff3":"%%time\ntest_stock_ids = list(test['stock_id'].unique())\ntest_stock_stats_df = get_dataSet(test_stock_ids, 'test')","c5726e0d":"test = pd.merge(test, test_stock_stats_df, on = ['stock_id', 'time_id'], how = 'left')\ntest.fillna(0, inplace=True)","0560cc9f":"# test=test.rename(columns={('bid_ask_spread1', 'mean'):'bid_ask_spread1', \n#              ('bid_ask_spread2', 'mean'):'bid_ask_spread2',\n#              ('log_return1', 'realized_volatility'):'log_return1',\n#              ('log_return2', 'realized_volatility'):'log_return2',\n#              ('price', 'mean'):'Price',\n#              ('size', 'sum'):'Size',\n#              ('order_count', 'sum'):'Order_count',\n#              ('trade_log_return', 'realized_volatility'):'Trade_log_return'\n#             })","d77b2dd5":"test_df = test.drop('row_id', axis=1)","a95b035d":"pred_xgb = model_xgb.predict(test_df)\npred_lgbm = model_lgbm.predict(test_df)","6ba18665":"submission['target'] = pred_lgbm","4b48018d":"submission.to_csv('submission.csv', index=False)","a4cdc858":" # Volatility Prediction","b534215f":"## High Volatile and low Volatile stocks","79fe7d4f":"## Submission","83532c15":"## XGBoost","16d13489":"## Introduction\n \n**Task**: To predict Voaltility\n\n**Volatility** : It is a rate at which the price of a security increases or decreases for a given set of returns. \n\n> A higher volatility means that a security's value can potentially be spread out over a larger range of values. This means that the price of the security can change dramatically over a short time period in either direction.\n\n> A lower volatility means that a security's value does not fluctuate dramatically, and tends to be more steady.\n\n**Bid Price**: The bid price is the amount of money a buyer is willing to pay for a security.\n\n**Ask Price**: The ask price is the lowest price a seller of a stock is willing to accept for a share of that given stock.\n\n**Bid Size**: Bid size represents the quantity of a security that investors are willing to purchase at a specified bid price. \n\n**Ask Size**: The ask size is the amount of a security that a market maker is offering to sell at the ask price.","a511d7c7":"### Bid price and Ask Price","d60a8bdf":"## Preprocessing","2294b94e":"## Data Visualization","b2dff516":"## LGBM"}}