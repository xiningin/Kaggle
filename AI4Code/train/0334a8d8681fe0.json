{"cell_type":{"2e408ca0":"code","5662ef4f":"code","40fd23df":"code","b97bd074":"code","1b04d4f1":"code","3eac2744":"code","a4cd4835":"code","b91d328b":"code","15b575bf":"code","3534bcd4":"code","00b01424":"code","fb127e95":"code","5970fdec":"code","40ef7bca":"code","4c0f0e88":"code","b2ceedbb":"markdown","56bad291":"markdown","1fd22ccf":"markdown","a9ead0fd":"markdown","e047f556":"markdown","8ba49157":"markdown","273ff803":"markdown","d1c1c269":"markdown","caa9e217":"markdown","d315daf1":"markdown","74d82e49":"markdown","54cd3570":"markdown","7efceecc":"markdown","b53c345d":"markdown","0eecdf63":"markdown","c8e99dc4":"markdown","1ca202a6":"markdown","831ac731":"markdown","f6938295":"markdown","3591cc60":"markdown","329d60c2":"markdown","4c03f34a":"markdown","1d9e9ff0":"markdown","3c85a6b4":"markdown","44ad8c0f":"markdown","23186b5d":"markdown","272865f1":"markdown","53e4879a":"markdown","56a0d63b":"markdown","fbd4d8e9":"markdown"},"source":{"2e408ca0":"# Load libraries\nfrom pandas import read_csv\n# from pandas.tools.plotting import scatter_matrix (https:\/\/github.com\/pandas-dev\/pandas\/issues\/15893)\nfrom pandas.plotting import scatter_matrix\nfrom matplotlib import pyplot\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.svm import SVC\n\nimport warnings\nwarnings.filterwarnings('ignore')","5662ef4f":"# Load dataset\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# filename = '\/kaggle\/input\/iris\/Iris.csv' \n# https:\/\/www.kaggle.com\/sohier\/tutorial-accessing-data-with-pandas\n\ndataset = read_csv('\/kaggle\/input\/iris\/Iris.csv')\n\n# df.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'}, inplace=True)\ndataset.rename(columns={'SepalLengthCm': 'sepal-length', 'SepalWidthCm': 'sepal-width', 'PetalLengthCm':'petal-length', 'PetalWidthCm':'petal-width', 'Species':'class'}, inplace=True)\n\n# drop the Id column\ndataset = dataset.drop('Id', 1)","40fd23df":"# shape\nprint(dataset.shape)","b97bd074":"# head\nprint(dataset.head(5))","1b04d4f1":"# descriptions\nprint(dataset.describe())","3eac2744":"# class distribution\nprint(dataset.groupby('class').size())","a4cd4835":"# box and whisker plots\ndataset.plot(kind='box', subplots=True, layout=(2,2), sharex=False, sharey=False)\npyplot.show()","b91d328b":"# histograms\ndataset.hist()\npyplot.show()","15b575bf":"# scatter plot matrix\nscatter_matrix(dataset)\npyplot.show()","3534bcd4":"# Split-out validation dataset\narray = dataset.values\nX = array[:,0:4]\nY = array[:,4]\nvalidation_size = 0.20\nseed = 7\nX_train, X_validation, Y_train, Y_validation = train_test_split(X, Y, test_size=validation_size, random_state=seed)","00b01424":"# Spot-Check Algorithms\nmodels = []\nmodels.append(('LR', LogisticRegression()))\nmodels.append(('LDA', LinearDiscriminantAnalysis()))\nmodels.append(('KNN', KNeighborsClassifier()))\nmodels.append(('CART', DecisionTreeClassifier()))\nmodels.append(('NB', GaussianNB()))\nmodels.append(('SVM', SVC()))\n# evaluate each model in turn\nresults = []\nnames = []\nfor name, model in models:\n    kfold = KFold(n_splits=10, random_state=seed)\n    cv_results = cross_val_score(model, X_train, Y_train, cv=kfold, scoring='accuracy')\n    results.append(cv_results)\n    names.append(name)\n    msg = \"%s: %f (%f)\" % (name, cv_results.mean(), cv_results.std())\n    print(msg)","fb127e95":"# Compare Algorithms\nfig = pyplot.figure()\nfig.suptitle('Algorithm Comparison')\nax = fig.add_subplot(111)\npyplot.boxplot(results)\nax.set_xticklabels(names)\npyplot.show()","5970fdec":"# Make predictions on validation dataset based on LogisticRegression\nlr = LogisticRegression()\nlr.fit(X_train, Y_train)\npredictions = lr.predict(X_validation)\nprint(accuracy_score(Y_validation, predictions))\nprint(confusion_matrix(Y_validation, predictions))\nprint(classification_report(Y_validation, predictions))","40ef7bca":"# Make predictions on validation dataset based on KNeighborsClassifier\nknn = KNeighborsClassifier()\nknn.fit(X_train, Y_train)\npredictions = knn.predict(X_validation)\nprint(accuracy_score(Y_validation, predictions))\nprint(confusion_matrix(Y_validation, predictions))\nprint(classification_report(Y_validation, predictions))","4c0f0e88":"# Make predictions on validation dataset based on SVC\nsvc = SVC()\nsvc.fit(X_train, Y_train)\npredictions = svc.predict(X_validation)\nprint(accuracy_score(Y_validation, predictions))\nprint(confusion_matrix(Y_validation, predictions))\nprint(classification_report(Y_validation, predictions))","b2ceedbb":"## 6.1 Make predictions on validation dataset based on LogisticRegression","56bad291":"# 7. References and Credits\n\n* Thank you to Jason Brownlee for his post https:\/\/machinelearningmastery.com\/machine-learning-in-python-step-by-step\/\n* For formatting, this link is useful https:\/\/www.kaggle.com\/chrisbow\/formatting-notebooks-with-markdown-tutorial\n* How to replace dataset header with custom header https:\/\/stackoverflow.com\/questions\/11346283\/renaming-columns-in-pandas","1fd22ccf":"## 6.2 Make predictions on validation dataset based on KNeighborsClassifier","a9ead0fd":"## 5.3 Build Models\n\nWe don't know which algorithms would be good on this problem or what configurations to use. We get an idea from the plots that some of the classes are partially linearly separable in some\ndimensions, so we are expecting generally good results. Let's evaluate six different algorithms:\n* Logistic Regression (LR)\n* Linear Discriminant Analysis (LDA)\n* k-Nearest Neighbors (KNN)\n* Classifcation and Regression Trees (CART)\n* Gaussian Naive Bayes (NB)\n* Support Vector Machines (SVM)\n\nThis list is a good mixture of simple linear (LR and LDA), nonlinear (KNN, CART, NB and SVM) algorithms. We reset the random number seed before each run to ensure that the evaluation of each algorithm is performed using exactly the same data splits. It ensures the results are directly comparable. Let's build and evaluate our six models:","e047f556":"## 3.4 Class Distribution\n\nLet's now take a look at the number of instances (rows) that belong to each class. We can view this as an absolute count.\n\n* On classification problems we need to know how balanced the class values are. \n* Highly imbalanced problems (a lot more observations for one class than another) are common and may need special handling in the data preparation stage of our project.","8ba49157":"<u>Inference<\/u>: \n* It looks like perhaps two of the input variables (sepal-length and sepal-width) have a Gaussian distribution. \n* This is useful to note as we can use algorithms that can exploit this assumption.","273ff803":"## 5.1 Create a Validation Dataset\n\nWe need to know whether or not the model that we created is any good. Later, we will use statistical methods to estimate the accuracy of the models that we create on unseen data. We also want a more concrete estimate of the accuracy of the best model on unseen data by evaluating it on actual unseen data. That is, we are going to hold back some data that the algorithms will not get to see and we will use this data to get a second and independent idea of how accurate the best model might actually be. We will split the loaded dataset into two, 80% of which we will use to train our models and 20% that we will hold back as a validation dataset.","d1c1c269":"## 2.1 Import libraries\n\nFirst, let's import all of the modules, functions and objects we are going to use in this project.","caa9e217":"# 1. Problem Definition\n\nWe are going to work on the Iris Species dataset provided by UCI Machine Learning Repository.\n\nWe are going to cover the following points:\n2. Loading the dataset.\n3. Summarizing the dataset.\n4. Visualizing the dataset.\n5. Evaluating some algorithms.\n6. Making some predictions.\n7. References and Credits\n\n<u>Goal<\/u>: Classification of Iris flowers","d315daf1":"# 2. Load The Data\n\nIn this step we are going to load the libraries and the input file provided by Kaggle.","74d82e49":"# 3. Summarize the Dataset\n\nIn this step we are going to take a look at the data in a few different ways:\n* Dimensions of the dataset.\n* Peek at the data itself.\n* Statistical summary of all attributes.\n* Breakdown of the data by the class variable.","54cd3570":"## 4.2 Multivariate Plots\n\nNow we can look at the interactions between the variables. Let's look at scatter plots of all pairs of attributes. This can be helpful to spot structured relationships between input variables.","7efceecc":"## 2.2 Load Dataset","b53c345d":"# 5. Evaluate Some Algorithms\n\nNow it is time to create some models of the data and estimate their accuracy on unseen data.\nHere is what we are going to cover in this step:\n1. Separate out a validation dataset.\n2. Setup the test harness to use 10-fold cross validation.\n3. Build 6 different models to predict species from flower measurements\n4. Select the best model.","0eecdf63":"## 3.3 Statistical Summary\n\nLet's take a look at a summary of each attribute. This includes the count, mean, the min and max values as well as some percentiles.","c8e99dc4":"<u>Inference<\/u>: \n* Note the diagonal grouping of some pairs of attributes such as between\n    * sepal-length and petal-length\n    * petal-lenth and petal-width\n* This suggests a high correlation and a predictable relationship.","1ca202a6":"We now have training data in the X_train and Y_train for preparing models and a X_validation and Y_validation sets that we can use later.","831ac731":"<u>Inference<\/u>: \n* We can see that each class has the same number of instances (50 or 33% of the dataset).\n* Since this is not a case of imbalanced dataset, there is no need for SMOTE (Synthetic Minority Oversampling Technique)\n* In case of unbalanced dataset, we would need to refer to the techniques mentioned in https:\/\/machinelearningmastery.com\/tactics-to-combat-imbalanced-classes-in-your-machine-learning-dataset\/ ","f6938295":"# 6. Make Predictions\n\nOut of LR, KNN and SVM, we don't know which will be most accurate on our validation dataset. Let's find out. We will run these models directly on the validation set and summarize the results as a final accuracy score, a confusion matrix and a classification report.\n\nThis will give us an independent final check on the accuracy of the best model. It is important to keep a validation set just in case we made a slip during training, such as overfitting to the training set or a data leak. Both will result in an overly optimistic result.","3591cc60":"## 4.1 Univariate Plots\n\nWe will start with some univariate plots, that is, plots of each individual variable. Given that the input variables are numeric, we can create box and whisker plots of each.","329d60c2":"## 3.1 Dimensions of Dataset\n\nWe can get a quick idea of the number of instances (rows) and number of attributes (columns).","4c03f34a":"We can also create a histogram of each input variable to get an idea of the distribution.","1d9e9ff0":"## 6.3 Make predictions on validation dataset based on SVC","3c85a6b4":"## 5.4 Select The Best Model\n\nWe now have 6 models and accuracy estimations for each. We need to compare the models to each other and select the most accurate. Running the example above, we get the following raw results:\n\n* We can see that it looks like LR, KNN and SVM have the largest estimated accuracy score.\n* All 3 models (LR, KNN, SVM) have an accuracy = 0.983333 and standard deviation = 0.033333\n\nWe can also create a plot of the model evaluation results and compare the spread and the mean accuracy of each model. \nThere is a population of accuracy measures for each algorithm because each algorithm was evaluated 10 times (10 fold cross validation).","44ad8c0f":"<u>Inference<\/u>:\n* We can see that the box and whisker plots are squashed at the top of the range, with many samples achieving 100% accuracy.","23186b5d":"# 4. Data Visualization\n\nWe now have a basic idea about the data. We need to extend this with some visualizations. We are going to look at two types of plots:\n* Univariate plots to better understand each attribute.\n* Multivariate plots to better understand the relationships between attributes.","272865f1":"## 5.2 Test Harness\n\nWe will use 10-fold cross validation to estimate accuracy. This will split our dataset into 10 parts, train on 9 and test on 1 and repeat for all combinations of train-test splits. We are using the metric of accuracy to evaluate models. This is a ratio of the number of correctly predicted instances divided by the total number of instances in the dataset multiplied by 100 to give a percentage (e.g. 95% accurate). We will be using the scoring variable when we run build and evaluate each model next.","53e4879a":"<u>Inference<\/u>: \n* We can see that all of the numerical values have the same scale (centimeters) and similar ranges between 0 and 8 centimeters.\n* Hence, rescaling\/normalization is not required in this case\n\n<u>Why do we need to rescale data?<\/u>\n\n* When our data is comprised of attributes with varying scales, many machine learning algorithms can benefit from rescaling the attributes to all have the same scale. \n* This is referred to as normalization and attributes are often rescaled into the range between 0 and 1. \n* This is useful for optimization algorithms used in the core of machine learning algorithms like gradient descent. \n* It is also useful for algorithms that weight inputs like regression and neural networks and algorithms that use distance measures like k-Nearest Neighbors. \n* We can rescale our data using scikit-learn using the MinMaxScaler class.","56a0d63b":"<u>Inference<\/u>:\n* The KNN algorithm was the most accurate model that we tested on the validation dataset.\n* The accuracy of KNN is 0.9 or 90% whereas the accuracy of LR and SVM is 0.87 or 87%. \n* The confusion matrix provides an indication of the three errors made. \n* Finally the classification report provides a breakdown of each class by precision, recall, f1-score and support showing the results.","fbd4d8e9":"## 3.2 Peek at the Data\n\nLet's eyeball our data."}}