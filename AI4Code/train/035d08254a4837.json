{"cell_type":{"e303d70a":"code","5cf3204e":"code","af9fe64d":"code","514fb535":"code","5d9ddcb6":"code","d58d2d50":"code","3655a73c":"code","eabc18e8":"code","f4beace3":"code","b3a1e4f1":"code","4b969242":"code","e945440e":"code","1e1417a9":"code","f7a39c5a":"code","bdac245f":"code","67277a59":"code","dc0e9fd0":"code","37e5ee7a":"code","20421a72":"code","7e0be756":"code","9c8199d4":"code","a4a119db":"code","f723596a":"code","5798bb4f":"code","3f8d0340":"code","05693854":"code","30d02837":"code","36516a17":"code","0dc02367":"code","9d1c2145":"code","2963fadf":"code","f69ed8da":"code","8cb0746d":"code","c48726b4":"code","9eca3c65":"code","b0a4ab57":"code","9d3f68c4":"code","19caf92b":"code","6de4f4c0":"code","62e2c642":"code","707bc934":"code","3bd83918":"code","eb5b61cb":"code","fd4baf8c":"code","dfa8d069":"code","add9641c":"code","bc209f90":"code","fbefd333":"code","22f78dc5":"code","9ca260d5":"code","e28511e2":"code","a6bd3445":"code","c00dbc02":"code","93fed865":"code","186db761":"code","2e99c959":"code","2cd6586c":"code","c0260651":"code","ecad55b8":"code","eb57ee59":"code","0494d151":"code","5a7b006e":"code","a07ef89a":"code","d41b8bd2":"code","5e9d4215":"code","8c9885ae":"code","95e101a4":"code","e9ba2d85":"code","b449a9c2":"code","c39dc0f6":"code","254f93ea":"code","b29e237a":"code","0e41cbb4":"code","f4650030":"code","077d5a7f":"code","9c2dbf6c":"code","6921743b":"code","25cdb715":"code","4b1459d0":"code","df4fd050":"code","958f3042":"code","a7881f5e":"code","34aba1b3":"code","8beec87d":"code","187f5132":"code","80755ff5":"code","bf3d5be7":"code","0adec513":"code","920dc246":"code","138dd94e":"code","b5c358d7":"code","38f70cfc":"code","0f495020":"code","eab400fe":"code","b62b98b3":"code","39356461":"code","8a8867c9":"code","d82622d8":"code","02bf92fd":"code","b79e3b96":"code","51d4bf94":"code","1732d88f":"code","ca120ee3":"code","6077befb":"code","ab550bfb":"code","bcd7d328":"code","b321fb03":"code","9d1ae3e2":"code","50dc778d":"code","c137b172":"code","ea4cf351":"code","a68682ae":"code","b813d6ce":"code","23488ec5":"code","20a918f0":"code","1d548632":"code","8500c375":"code","95c48dc1":"code","71a4ae9f":"code","c999a768":"code","22a8d59d":"code","4f510eff":"code","01d5f939":"code","9cb37860":"code","da8d381c":"code","7aa90f9f":"code","a3e59e49":"code","084ad86c":"code","cd8484b7":"code","84574da8":"code","9c25dc31":"code","412116aa":"code","7d2f7a71":"code","9ffc051e":"code","a17b52ea":"code","5ad5dc43":"code","6d557c9f":"code","0c867ed9":"code","1c1f63f3":"code","1876fa4a":"code","fd321961":"code","f4bb3f53":"code","fde6ae68":"code","5d31c0e5":"code","88cad22f":"code","68f29913":"code","690cef66":"code","48bd00dc":"code","cacad792":"code","84b165a7":"code","95bf848b":"code","398d5bc2":"code","23359e93":"code","4b6f6e69":"code","4bf08a76":"code","dd5f66aa":"code","d4f45b96":"code","5eef2ff7":"code","8c46831e":"code","fac37826":"code","bc30010b":"code","345356fd":"code","0a12a3fe":"code","e370d25e":"code","a44c8a01":"code","04664453":"markdown","3cab90f7":"markdown","239b1270":"markdown","eb58412b":"markdown","6d0505a6":"markdown","b6118191":"markdown","7a1f2199":"markdown","48011328":"markdown","3d507bb9":"markdown","c196e8ae":"markdown","68d890df":"markdown","1b7953d4":"markdown","18657eee":"markdown","7715e403":"markdown","02cc431d":"markdown","05960dee":"markdown","8cefebb0":"markdown","a70f0f04":"markdown","5978f8e2":"markdown","c6b03cce":"markdown","74c41d03":"markdown","0a6ba56b":"markdown","a398c0bb":"markdown","c8541fd0":"markdown","020abfe3":"markdown","4c54d2cf":"markdown","227e5465":"markdown","ed2308b7":"markdown","d2eb992e":"markdown","f4aa5cab":"markdown","6c37ee66":"markdown","0cd3bda8":"markdown","fd03990e":"markdown","71204408":"markdown","1c136eb5":"markdown","b02a71f6":"markdown","3e10f58c":"markdown","647f7a43":"markdown","a6e3245e":"markdown","0b32764c":"markdown","bc090c21":"markdown","323beb24":"markdown","453d316f":"markdown","ddb01f72":"markdown","8d5aae65":"markdown","36e146c0":"markdown","87e01a39":"markdown","18148e89":"markdown","9fa54e20":"markdown","f29ebab1":"markdown","d07c0117":"markdown","3e1631dd":"markdown","13be9894":"markdown","149f0113":"markdown","78d41b69":"markdown","8ec11830":"markdown","ee9935d5":"markdown","504ff5d9":"markdown","c96e6307":"markdown","d26d8de7":"markdown","8897c80a":"markdown","defc427f":"markdown","0d588a00":"markdown","13d1ff0f":"markdown","c1d89796":"markdown","9de1cc35":"markdown","cfdee5ee":"markdown","f70354c9":"markdown","7af8192d":"markdown","c9b033fc":"markdown","71cc89f3":"markdown","1c8c060e":"markdown","9dcd9521":"markdown","33fbcf1c":"markdown","d4fe7257":"markdown","58154ceb":"markdown","e39d563d":"markdown","fa7f3261":"markdown","f2a9696e":"markdown","b138fc7a":"markdown","c3c54c15":"markdown"},"source":{"e303d70a":"import numpy as np","5cf3204e":"np.array([3.2,4,6,5])","af9fe64d":"np.array([1,4,2,5,3]) ## integer array:","514fb535":"np.array([1,2,3,4], dtype=\"str\")","5d9ddcb6":"np.array([3,6,2,3], dtype=\"float32\")","d58d2d50":"# nested lists result in multidimensional arrays\n\nnp.array([range(i,i+3) for i in [2,4,6]])","3655a73c":"# Create a length-10 integer array filled with zeros\n\nnp.zeros(10, dtype=\"int\") ","eabc18e8":"np.zeros((5,6), dtype=\"float\")","f4beace3":"# Create a 3x5 floating-point array filled with 1s\n\nnp.ones((3,5), dtype=\"float\")","b3a1e4f1":"# Create a 3x5 array filled with 3.14\n\nnp.full((3,5), 3.14)","4b969242":"# Create an array filled with a linear sequence\n# Starting at 0, ending at 20, stepping by 2\n# (this is similar to the built-in range() function)\n\nnp.arange(0,20,2)","e945440e":"# Create an array of five values evenly spaced between 0 and 1\n\nnp.linspace(0,1,5)","1e1417a9":"# Create a 3x3 array of uniformly distributed\n# random values between 0 and 1\n\nnp.random.random((3,3))","f7a39c5a":"# Create a 3x3 array of normally distributed random values\n# with mean 0 and standard deviation 1\n\nnp.random.normal(0,1,(3,3))","bdac245f":"# Create a 3x3 array of random integers in the interval [0, 10)\n\nnp.random.randint(0,10,(3,3))","67277a59":"# Create a 3x3 identity matrix\n\nnp.eye(3)","dc0e9fd0":"#Return a new array of given shape and type, with random values\n\nnp.empty((3,3),dtype=\"int\")","37e5ee7a":"np.zeros(10,dtype=\"int16\")","20421a72":"#or using the associated NumPy object:\n\nnp.zeros(10,dtype=np.int16)","7e0be756":"#NumPy Array Attributes\n#We\u2019ll use NumPy\u2019s random number generator, which we will seed with a set value in order to ensure that the same random arrays are generated each time this code is run:\n\nnp.random.seed(0) # seed for reproducibility\nx1 = np.random.randint(10, size=6) # One-dimensional array","9c8199d4":"#Each array has attributes ndim (the number of dimensions), shape (the size of each dimension), and size (the total size of the array):\n\nnp.random.seed(0) # seed for reproducibility\nx1 = np.random.randint(10, size=6) #it's same ((np.random.randint((0,10), size=6))) # One-dimensional array\nx2 = np.random.randint(10, size=(3,4)) # Two-dimensional array\nx3 = np.random.randint(10, size=(3,4,5)) # Three-dimensional array\n\nprint(\"x1 ndim: \",x1.ndim)\nprint(\"x1 shape: \",x1.shape)\nprint(\"x1 size: \",x1.size) #totaly,6 elements\n\nprint(\"x1 ndim: \",x2.ndim)\nprint(\"x1 shape: \",x2.shape)\nprint(\"x1 size: \",x2.size) #totaly,12 elements\n\nprint(\"x1 ndim: \",x3.ndim)\nprint(\"x1 shape: \",x3.shape)\nprint(\"x1 size: \",x3.size)#totaly,60 elements\n\nprint(\"dtype: \",x1.dtype) #the data type of the array\n# Other attributes include itemsize, which lists the size (in bytes) of each array element,\n# and nbytes, which lists the total size (in bytes) of the array:\nprint(\"itemsize:\",x1.itemsize,\"bytes\")\nprint(\"nbytes:\",x1.nbytes,\"bytes\")\n\nprint(\"dtype: \",x2.dtype) #the data type of the array\nprint(\"itemsize:\",x2.itemsize,\"bytes\")\nprint(\"nbytes:\",x2.nbytes,\"bytes\")\n\nprint(\"dtype: \",x3.dtype) #the data type of the array\nprint(\"itemsize:\",x3.itemsize,\"bytes\")\nprint(\"nbytes:\",x3.nbytes,\"bytes\") \n\n#In general, we expect that nbytes is equal to itemsize times size.","a4a119db":"x1","f723596a":"x1[0]","5798bb4f":"x1[4]","3f8d0340":"#To index from the end of the array, you can use negative indices:\n\nx1[-1]","05693854":"x1[-2]","30d02837":"x2","36516a17":"x2[2,1]","0dc02367":"x2[2,0]","9d1c2145":"x2[2,-4]","2963fadf":"x2[-2,-3]","f69ed8da":"#You can also modify values using any of the above index notation:\n\nx2[0,0]=12\nx2","8cb0746d":"x1","c48726b4":"x1[0] = 3.14159 # this will be truncated!\nx1","9eca3c65":"x = np.arange(10)\nx","b0a4ab57":"x[:5] # first five elements","9d3f68c4":"x[5:] # elements after index 5","19caf92b":"x[4:7]# middle subarray","6de4f4c0":"x[::2] # every other element","62e2c642":"x[1::2] #every other element, starting at index 1","707bc934":"x[-7:-2:2]","3bd83918":"x[-4:-2:1]","eb5b61cb":"# A potentially confusing case is when the step value is negative. In this case, the\n# defaults for start and stop are swapped. This becomes a convenient way to reverse\n# an array:\n\nx[::-1] # all elements, reversed","fd4baf8c":"x[5::-2]# reversed every other from index 5","dfa8d069":"x[5:1:-2]","add9641c":"x[5:-8:-1]","bc209f90":"x[7:-6:-1]","fbefd333":"x[-7:-8:-1]","22f78dc5":"# Multidimensional slices work in the same way, with multiple slices separated by commas.\n# For example:\n\nx2","9ca260d5":"# two rows, three columns\n\nx2[:2, :3]","e28511e2":"# all rows, every other column\n\nx2[:3,::2]","a6bd3445":"#Finally, subarray dimensions can even be reversed together:\n\nx2[::-1,::-1]","c00dbc02":"# One commonly needed routine is accessing single\n# rows or columns of an array. You can do this by combining indexing and slicing,\n# using an empty slice marked by a single colon (:):\n\nprint(x2[:, 0]) # first column of x2","93fed865":"print(x2[0,:]) # first row of x2","186db761":"#In the case of row access, the empty slice can be omitted for a more compact syntax:\n\nprint(x2[0]) # equivalent to x2[0, :]","2e99c959":"print(x2)","2cd6586c":"#Let\u2019s extract a 2\u00d72 subarray from this:\n\nx2_sub = x2[:2,:2]\nprint(x2_sub)","c0260651":"#Now if we modify this subarray, we\u2019ll see that the original array is changed! Observe:\n\nx2_sub[0,0] = 99\nprint(x2_sub)","ecad55b8":"print(x2)","eb57ee59":"x2_sub_copy = x2[:2,:2].copy()\nprint(x2_sub_copy)","0494d151":"#If we now modify this subarray, the original array is not touched:\n\nx2_sub_copy[0,0] = 42\nprint(x2_sub_copy)","5a7b006e":"print(x2)","a07ef89a":"# Another useful type of operation is reshaping of arrays. The most flexible way of\n# doing this is with the reshape() method. For example, if you want to put the numbers\n# 1 through 9 in a 3\u00d73 grid, you can do the following:\n\ngrid = np.arange(1,10,1).reshape(3,3)\nprint(grid)","d41b8bd2":"x = np.array([1, 2, 3])\nx.shape # x is a vector (3,)","5e9d4215":"# row vector via reshape\n\nx.reshape(1,3).shape","8c9885ae":"# row vector via newaxis\n\nx[np.newaxis, :].shape","95e101a4":"x.reshape(1,-1).shape","e9ba2d85":"# column vector via reshape\n\nx.reshape((3, 1))","b449a9c2":"# column vector via newaxis\n\nx[:, np.newaxis]","c39dc0f6":"x.reshape(-1,1).shape","254f93ea":"x = np.array([1,2,3])\ny = np.array([3,2,1])\nnp.concatenate((x, y))\n","b29e237a":"z = np.array([99,99,99]) #z =[99,99,99]\n\nprint(np.concatenate((x,y,z)))","0e41cbb4":"grid = np.array([[1,2,3],\n                [4,5,6]])","f4650030":"# concatenate along the first axis\n\nnp.concatenate((grid,grid))","077d5a7f":"# concatenate along the second axis (zero-indexed)\n\nnp.concatenate((grid, grid), axis=1)","9c2dbf6c":"# For working with arrays of mixed dimensions, it can be clearer to use the np.vstack\n# (vertical stack) and np.hstack (horizontal stack) functions:\n\nx = np.array([1,2,3])\ngrid = np.array([[9,8,7],\n                 [6,5,4]])\n\n\n# vertically stack the arrays\nnp.vstack([x,grid])","6921743b":"#horizontally stack the arrays\n\ny = np.array([[99],\n            [99]])\nnp.hstack([grid,y])","25cdb715":"x = [1,2,3,99,99,3,2,1]\nx1, x2, x3 = np.split(x, [3,5])\nprint(x1, x2, x3)","4b1459d0":"x = np.array([1,2,3,99,99,3,2,1])\nx1, x2, x3, x4 = np.split(x, [3,4,5])\nprint(x1, x2, x3,x4)","df4fd050":"grid = np.arange(36,dtype=np.float).reshape((6,6))\ngrid","958f3042":"upper, lower = np.vsplit(grid, [2])\nprint(upper)\nprint(lower)","a7881f5e":"upper,middle, lower = np.vsplit(grid, [2,3])\nprint(\"upper: \",upper)\nprint(\"middle: \",middle)\nprint(\"lower: \",lower)","34aba1b3":"left, right = np.hsplit(grid, [2])\nprint(left)\nprint(right)","8beec87d":"left, right = np.hsplit(grid, 2)\nprint(left)\nprint(right)","187f5132":"# NumPy\u2019s ufuncs feel very natural to use because they make use of Python\u2019s native\n# arithmetic operators. The standard addition, subtraction, multiplication, and division\n# can all be used:\n\nx = np.arange(4)\nprint(\"x =\", x)\nprint(\"x + 5 =\", x + 5)\nprint(\"x - 5 =\", x - 5)\nprint(\"x * 2 =\", x * 2)\nprint(\"x \/ 2 =\", x \/ 2)\nprint(\"x \/\/ 2 =\", x \/\/ 2) # floor division","80755ff5":"#There is also a unary ufunc for negation, a ** operator for exponentiation, and a %\n#operator for modulus:\n\nprint(\"-x = \", -x)\nprint(\"x ** 2 = \", x ** 2)\nprint(\"x % 2 = \", x % 2)","bf3d5be7":"# In addition, these can be strung together however you wish, and the standard order\n# of operations is respected:\n\n-(0.5*x+1) ** 2","0adec513":"# All of these arithmetic operations are simply convenient wrappers around specific\n# functions built into NumPy; for example, the + operator is a wrapper for the add\n# function:\n\nprint(np.add(3,2))\n\nprint(np.add(x,2)) #Addition +\nprint(np.subtract(x,5)) #Subtraction -\nprint(np.negative(x)) #Unary negation -\nprint(np.multiply(x,3)) #Multiplication *\nprint(np.divide(x,2)) #Division \/\nprint(np.floor_divide(x,2)) #Floor division \/\/\nprint(np.power(x,2)) #Exponentiation **\nprint(np.mod(x,2)) #Modulus\/remainder **\n\nprint(np.multiply(x, x))","920dc246":"# Just as NumPy understands Python\u2019s built-in arithmetic operators, it also understands\n# Python\u2019s built-in absolute value function:\n\nx = np.array([-2,-1,0,1,2])\nabs(x)","138dd94e":"# The corresponding NumPy ufunc is np.absolute, which is also available under the\n# alias np.abs:\n\nprint(np.absolute(x))\nprint(np.abs(x))","b5c358d7":"# This ufunc can also handle complex data, in which the absolute value returns the\n# magnitude:\n\nx = np.array([7-24j,4-3j,2+0j,1+3j])\nnp.abs(x)","38f70cfc":"# NumPy provides a large number of useful ufuncs, and some of the most useful for the\n# data scientist are the trigonometric functions. We\u2019ll start by defining an array of\n# angles:\n\ntheta = np.linspace(0,np.pi,3)\n\n\n#Now we can compute some trigonometric fuctions on these values:\nprint(\"theta      =\",theta)\nprint(\"sin(theta) =\",np.sin(theta))\nprint(\"cos(theta) =\",np.cos(theta))\nprint(\"tan(theta) =\",np.tan(theta))","0f495020":"x = [-1, 0, 1]\n\nprint(\"x = \", x)\nprint(\"arcsin(x) = \", np.arcsin(x))\nprint(\"arccos(x) = \", np.arccos(x))\nprint(\"arctan(x) = \", np.arctan(x))","eab400fe":"x = [1,2,3]\nprint(\"x      =\",x)\nprint(\"e^x    =\",np.exp(x))\nprint(\"2^x    =\",np.exp2(x))\nprint(\"3^x    =\",np.power(3,x))","b62b98b3":"# The inverse of the exponentials, the logarithms, are also available. The basic np.log\n# gives the natural logarithm; if you prefer to compute the base-2 logarithm or the\n# base-10 logarithm, these are available as well:\n\nx = [1, 2, 4, 10]\nprint(\"x        =\", x)\nprint(\"ln(x)    =\", np.log(x))\nprint(\"log2(x)  =\", np.log2(x))\nprint(\"log10(x) =\", np.log10(x))","39356461":"# There are also some specialized versions that are useful for maintaining precision\n# with very small input:\n\nx = [0, 0.001, 0.01, 0.1]\nprint(\"exp(x) - 1 =\", np.expm1(x))\nprint(\"log(1 + x) =\", np.log1p(x))","8a8867c9":"x = np.arange(5)\ny = np.empty(5)\nnp.multiply(x, 10, out=y)\nprint(y)","d82622d8":"#This can even be used with array views. For example, we can write the results of a\n#computation to every other element of a specified array:\n\ny = np.zeros(10)\nnp.power(2, x, out=y[::2])\nprint(y)\n\n# If we had instead written y[::2] = 2 ** x, this would have resulted in the creation\n# of a temporary array to hold the results of 2 ** x, followed by a second operation\n# copying those values into the y array. This doesn\u2019t make much of a difference for such\n# a small computation, but for very large arrays the memory savings from careful use of\n# the out argument can be significant.","02bf92fd":"y = np.zeros(10)\ny[::2] = 2 ** x\nprint(y)","b79e3b96":"x = np.arange(1,6)\nprint(np.add.reduce(x))\nprint(np.subtract.reduce(x))\nprint(np.multiply.reduce(x))","51d4bf94":"#If we\u2019d like to store all the intermediate results of the computation, we can instead use\n#accumulate:\n\nprint(np.add.accumulate(x))\nprint(np.subtract.accumulate(x))\nprint(np.multiply.accumulate(x))\nprint(np.divide.accumulate(x))\nprint(np.floor_divide.accumulate(x))","1732d88f":"x = np.arange(1,6)\nnp.multiply.outer(x, x)","ca120ee3":"# As a quick example, consider computing the sum of all values in an array. Python\n# itself can do this using the built-in sum function:\n\nL = np.random.random(100)\nsum(L)","6077befb":"#The syntax is quite similar to that of NumPy\u2019s sum function, and the result is the same\n#in the simplest case:\n\nnp.sum(L)","ab550bfb":"# However, because it executes the operation in compiled code, NumPy\u2019s version of the\n# operation is computed much more quickly:\n\nbig_array = np.random.rand(1000000)\n%timeit sum(big_array)\n%timeit np.sum(big_array)","bcd7d328":"#Similarly, Python has built-in min and max functions, used to find the minimum value\n#and maximum value of any given array:\n\nmin(big_array),max(big_array)","b321fb03":"#NumPy\u2019s corresponding functions have similar syntax, and again operate much more\n#quickly:\n\nnp.min(big_array),np.max(big_array)","9d1ae3e2":"%timeit min(big_array)\n%timeit np.min(big_array)","50dc778d":"# For min, max, sum, and several other NumPy aggregates, a shorter syntax is to use\n# methods of the array object itself:\n\nprint(big_array.min(), big_array.max(), big_array.sum())\n# Whenever possible, make sure that you are using the NumPy version of these aggre\u2010\n#gates when operating on NumPy arrays!\n%timeit np.min(big_array)\n%timeit big_array.min()","c137b172":"# One common type of aggregation operation is an aggregate along a row or column.\n# Say you have some data stored in a two-dimensional array:\n\nM = np.random.random((3,4))\nprint(M)\n\nM.sum()","ea4cf351":"# Aggregation functions take an additional argument specifying the axis along which\n# the aggregate is computed. For example, we can find the minimum value within each\n# column by specifying axis=0:\n\nprint(M.min(axis=0))\n#or use that way\nprint(np.min(M,axis=0))\nM","a68682ae":"# Similarly, we can find the maximum value within each row:\n\nM.max(axis=1)","b813d6ce":"# Note that some of these NaN-safe functions were not added until\n# NumPy 1.8, so they will not be available in older NumPy versions.\n\nx = np.array([1,2,np.nan,4,5])\n\nprint(\"np.sum       =\",np.sum(x))\nprint(\"np.nansum    =\",np.nansum(x))\n\nprint(\"np.mean      =\",np.mean(x))\nprint(\"np.nanmean   =\",np.nanmean(x))\n\nprint(\"np.std       =\",np.std(x))\nprint(\"np.nanstd    =\",np.nanstd(x))\n\n\n#Be careful that this is not a real index of minimum value.\nprint(\"np.argmin    =\",np.argmin(x)) \n#if there is a nan value in an array, it returns index of nan value.\n\n\nprint(\"np.nanargmin =\",np.nanargmin(x))\n","23488ec5":"import numpy as np\n\na = np.array([0,1,2])\nb = np.array([5,5,5])\na+b","20a918f0":"a+5","1d548632":"# We can similarly extend this to arrays of higher dimension. Observe the result when\n# we add a one-dimensional array to a two-dimensional array:\n\nM = np.ones((3,3))\nM","8500c375":"M+a\n\n# Here the one-dimensional array a is stretched, or broadcast, across the second\n# dimension in order to match the shape of M .","95c48dc1":"# here we\u2019ve stretched both a and b to match a common shape, and the result is a two-\n# dimensional array!\n\na = np.arange(3) #(3,) 1 dimensional\nb = np.arange(3)[:,np.newaxis] #(3,1) 2 dimensional\nprint(a)\nprint(b)","71a4ae9f":"a+b","c999a768":"#Let\u2019s look at adding a two-dimensional array to a one-dimensional array:\nM = np.ones((2,3))\na = np.arange(3)\n\n# Let\u2019s consider an operation on these two arrays. The shapes of the arrays are:\n# M.shape = (2, 3)\n# a.shape = (3,)\n# We see by rule 1 that the array a has fewer dimensions, so we pad it on the left with\n# ones:\n# M.shape -> (2, 3)\n# a.shape -> (1, 3)\n# By rule 2, we now see that the first dimension disagrees, so we stretch this dimension\n# to match:\n# M.shape -> (2, 3)\n# a.shape -> (2, 3)\n# The shapes match, and we see that the final shape will be (2, 3) :\n\nM+a","22a8d59d":"# Let\u2019s take a look at an example where both arrays need to be broadcast:\na = np.arange(3).reshape((3,1))\nb = np.arange(3)\n# Again, we\u2019ll start by writing out the shape of the arrays:\n\n# a.shape = (3, 1)\n# b.shape = (3,)\n# |\n# Rule 1 says we must pad the shape of b with ones:\n# a.shape -> (3, 1)\n# b.shape -> (1, 3)\n# And rule 2 tells us that we upgrade each of these ones to match the corresponding\n# size of the other array:\n# a.shape -> (3, 3)\n# b.shape -> (3, 3)\n# Because the result matches, these shapes are compatible. We can see this here:\na+b","4f510eff":"# Now let\u2019s take a look at an example in which the two arrays are not compatible:\n\nM = np.ones((3,2))\na = np.arange(3)\n\n# This is just a slightly different situation than in the first example: the matrix M is\n# transposed. How does this affect the calculation? The shapes of the arrays are:\n# M.shape = (3, 2)\n# a.shape = (3,)\n# Again, rule 1 tells us that we must pad the shape of a with ones:\n# M.shape -> (3, 2)\n# a.shape -> (1, 3)\n# By rule 2, the first dimension of a is stretched to match that of M :\n# M.shape -> (3, 2)\n# a.shape -> (3, 3)\n# Now we hit rule 3\u2014the final shapes do not match, so these two arrays are incompati\u2010\n# ble, as we can observe by attempting this operation:\n\n# print(M+a) #ERROR! operands could not be broadcast together with shapes","01d5f939":"print(a[:, np.newaxis].shape)\nM + a[:, np.newaxis]","9cb37860":"x = np.array([1,2,3,4,5])\n\nprint(x<3)  # less than\nprint(x>3)  # greater than\nprint(x<=3) #less than or equal\nprint(x>=3) #greater than or equal\nprint(x!=3) #not equal\nprint(x==3) #equal","da8d381c":"# It is also possible to do an element-by-element comparison of two arrays, and to\n# include compound expressions:\n\n(2*x) == (2**x)","7aa90f9f":"# As in the case of arithmetic operators, the comparison operators are implemented as\n# ufuncs in NumPy; for example, when you write x < 3 , internally NumPy uses\n# np.less(x, 3) . A summary of the comparison operators and their equivalent ufunc\n# is shown here:","a3e59e49":"rng = np.random.RandomState(seed=0)\nx = rng.randint(10, size=(3,4))\nprint(x)\n\nx<6","084ad86c":"print(x)\n\n# To count the number of True entries in a Boolean array, np.count_nonzero is useful:\n\n# how many values less than 6?\nprint(\"1-: \",np.count_nonzero(x<6))\n\n# We see that there are eight array entries that are less than 6. Another way to get at this\n# information is to use np.sum ; in this case, False is interpreted as 0 , and True is inter\u2010\n# preted as 1 :\n\nprint(\"2-: \",np.sum(x<6))\n\nprint(\"3-: \",np.sum(x!=np.nan))\nprint(\"4-: \",np.count_nonzero(x!=np.nan))","cd8484b7":"# how many values less than 6 in each row?\nprint(np.sum(x < 6, axis=1))\n\n# how many values less than 6 in each column?\nprint(np.sum(x < 6, axis=0))","84574da8":"# If we\u2019re interested in quickly checking whether any or all the values are true, we can\n# use (you guessed it) np.any() or np.all() :\n\n# are there any values greater than 8?\nprint(np.any(x>8))\n\n# are there any values less than zero?\nprint(np.any(x<0))\n\n# are all values less than 10?\nprint(np.all(x<10))\n\n# are all values equal to 6?\nprint(np.all(x==6))","9c25dc31":"# are all values in each row less than 8?\nprint(np.all(x<8, axis=1))\n\n# are all values in each column less than 3?\nprint(np.all(x<3, axis=0))","412116aa":"print(x)\nprint(x<5)\nprint(x[x<5])","7d2f7a71":"# In Python, all nonzero integers will evaluate as True .\nbool(42), bool(0), bool(-1)","9ffc051e":"bool(42 and 0)","a17b52ea":"bool(42 or 0)","5ad5dc43":"# When you have an array of Boolean values in NumPy, this can be thought of as a\n# string of bits where 1 = True and 0 = False , and the result of & and | operates in a\n# similar manner as before:\n\nA = np.array([1, 0, 1, 0, 1, 0], dtype=bool)\nB = np.array([1, 1, 1, 0, 1, 1], dtype=bool)\nA | B","6d557c9f":"x = np.arange(10)\n(x > 4) & (x < 8)","0c867ed9":"import numpy as np\n\nrand = np.random.RandomState(42)\nx = rand.randint(100, size=10)\nprint(x)","1c1f63f3":"[x[3],x[7],x[2]]","1876fa4a":"ind = [3,7,4]\nx[ind]","fd321961":"ind = np.array([[3, 7],\n                [4, 5]])\nx[ind]","f4bb3f53":"X = np.arange(12).reshape((3,4))\nX","fde6ae68":"row = np.array([0,1,2])\ncol = np.array([2,1,3])\nX[row,col]","5d31c0e5":"X[row[:, np.newaxis], col] #row[:, np.newaxis].shape (3,1)","88cad22f":"# Here, each row value is matched with each column vector, exactly as we saw in broad\u2010\n# casting of arithmetic operations. For example:\n\nrow[:, np.newaxis] * col","68f29913":"print(X)","690cef66":"X[2,[2,0,1]]","48bd00dc":"X[1:, [2, 0, 1]]","cacad792":"mask = np.array([1, 0, 1, 0], dtype=bool)\nX[row[:, np.newaxis], mask]  # mask 0 and 2 indixes are true!","84b165a7":"x = np.arange(10)\ni = np.array([2,1,8,4])\nx[i] = 99\nprint(x)","95bf848b":"x[i] -= 10\nprint(x)","398d5bc2":"x = np.zeros(10)\nx[[0, 2]] = [4, 6]\nprint(x)","23359e93":"x = np.zeros(10)\nx[[0, 0]] = [4, 6]\nprint(x)\n\n# Where did the 4 go? The result of this operation is to first assign x[0] = 4 , followed\n# by x[0] = 6 . The result, of course, is that x[0] contains the value 6.","4b6f6e69":"i = [2, 3, 3, 4, 4, 4]\nx[i] += 1\nx","4bf08a76":"x = np.zeros(10)\nnp.add.at(x, i, 1)\nprint(x)","dd5f66aa":"x = np.array([2,1,4,3,5])\nnp.sort(x)","d4f45b96":"x.sort()\nprint(x)","5eef2ff7":"# A useful feature of NumPy\u2019s sorting algorithms is the ability to sort along specific\n# rows or columns of a multidimensional array using the axis argument. For example:\n\nrand = np.random.RandomState(42)\nX = rand.randint(0,10,(4,6))\nprint(X)","8c46831e":"# sort each column of X\n\nnp.sort(X, axis=0)","fac37826":"# sort each row of X\n\nnp.sort(X, axis=1)","bc30010b":"# Note that the first three values in the resulting array are the three smallest in the\n# array, and the remaining array positions contain the remaining values. Within the\n# two partitions, the elements have arbitrary order.\n\nx = np.array([7, 2, 1, 3, 6, 5, 4])\nnp.partition(x, 3)","345356fd":"# The result is an array where the first two slots in each row contain the smallest values\n# from that row, with the remaining values filling the remaining slots.\n\nnp.partition(X, 2, axis=1)","0a12a3fe":"np.partition(X, 2, axis=0)","e370d25e":"np.argpartition(X, 2, axis=1)","a44c8a01":"np.argpartition(X, 2, axis=0)","04664453":"* Broadcasting is simply a\nset of rules for applying binary ufuncs (addition, subtraction, multiplication, etc.) on\narrays of different sizes.","3cab90f7":"<img src=\"https:\/\/1.bp.blogspot.com\/-xrnk-4zD2Ac\/W1LCbjrSjjI\/AAAAAAAAXUY\/8QJ0AZBxsQ0h6BgUV4kml0NqIO_hOs2KwCLcBGAs\/s1600\/4212_t2-1.PNG\" alt=\"cce\" border=\"0\">","239b1270":"* np.concatenate can also be used for two-dimensional arrays:","eb58412b":"### Splitting of arrays","6d0505a6":"<a id=\"13\"><\/a> <br>\n#### Array arithmetic","b6118191":"<a id=\"8\"><\/a> <br>\n### Array Slicing: Accessing Subarrays","7a1f2199":"<a id=\"47\"><\/a> <br>\n#### Creating copies of arrays","48011328":"<a id=\"14\"><\/a> <br>\n#### Absolute value","3d507bb9":"* For large calculations, it is sometimes useful to be able to specify the array where the\nresult of the calculation will be stored. Rather than creating a temporary array, you\ncan use this to write computation results directly to the memory location where you\u2019d\nlike them to be. For all ufuncs, you can do this using the out argument of the\nfunction:","c196e8ae":"* NumPy has fast built-in aggregation functions for working on arrays; we\u2019ll discuss\nand demonstrate some of them here.","68d890df":"<a id=\"6\"><\/a> <br>\n### NumPy Array Attributes","1b7953d4":"<a id=\"19\"><\/a> <br>\n#### Aggregates","18657eee":"<img src=\"https:\/\/i.stack.imgur.com\/zkMBy.png\" alt=\"cce\" border=\"0\">","7715e403":"<a id=\"30\"><\/a> <br>\n### Broadcasting example 3","02cc431d":"<a id=\"20\"><\/a> <br>\n#### Outer products","05960dee":"* In a multidimensional array, you access items using a comma-separated tuple of indices:","8cefebb0":"* If you are familiar with Python\u2019s standard list indexing, indexing in NumPy will feel\nquite familiar. In a one-dimensional array, you can access the ith value (counting from\nzero) by specifying the desired index in square brackets, just as with Python lists:","a70f0f04":"<a id=\"45\"><\/a> <br>\n#### Accessing array rows and columns","5978f8e2":"* Despite the nice features of array views, it is sometimes useful to instead explicitly\ncopy the data within an array or a subarray. This can be most easily done with the\ncopy() method:","c6b03cce":"* **We\u2019ll cover a few categories of basic array manipulations here:**\n* Attributes of arrays\n   * Determining the size, shape, memory consumption, and data types of arrays\n* Indexing of arrays\n   * Getting and setting the value of individual array elements\n* Slicing of arrays\n   * Getting and setting smaller subarrays within a larger array\n* Reshaping of arrays\n   * Changing the shape of a given array\n* Joining and splitting of arrays\n   * Combining multiple arrays into one, and splitting one array into many","74c41d03":"<a id=\"37\"><\/a> <br>\n### Combined Indexing","0a6ba56b":"* Ufuncs exist in two flavors: unary ufuncs, which operate on a single input, and binary\nufuncs, which operate on two inputs. We\u2019ll see examples of both these types of functions here.","a398c0bb":"* This default behavior is actually quite useful: it means that when we work with large\ndatasets, we can access and process pieces of these datasets without the need to copy\nthe underlying data buffer.","c8541fd0":"<a id=\"22\"><\/a> <br>\n### Summing the Values in an Array","020abfe3":"<a id=\"26\"><\/a> <br>\n### Introducing Broadcasting","4c54d2cf":"<a id=\"35\"><\/a> <br>\n# Fancy Indexing","227e5465":"* The opposite of concatenation is splitting, which is implemented by the functions\nnp.split, np.hsplit, and np.vsplit. For each of these, we can pass a list of indices\ngiving the split points:","ed2308b7":"<a id=\"40\"><\/a> <br>\n### Fast Sorting in NumPy: np.sort and np.argsort","d2eb992e":"<a id=\"34\"><\/a> <br>\n### Working with Boolean Arrays ","f4aa5cab":"<a id=\"46\"><\/a> <br>\n#### Subarrays as no-copy views","6c37ee66":"<a id=\"25\"><\/a> <br>\n# Computation on Arrays: Broadcasting","0cd3bda8":"<a id=\"3\"><\/a> <br>\n### Creating Arrays from Scratch","fd03990e":"<a id=\"2\"><\/a> <br>\n# Understanding Data Types in Python","71204408":"<a id=\"12\"><\/a> <br>\n### Exploring NumPy\u2019s UFuncs","1c136eb5":"<a id=\"43\"><\/a> <br>\n#### One-dimensional subarrays","b02a71f6":"* Similarly, np.dsplit will split arrays along the third axis.","3e10f58c":"* Where possible, the reshape method will use a no-copy view of the\ninitial array, but with noncontiguous memory buffers this is not always the case.\n\n* Another common reshaping pattern is the conversion of a one-dimensional array\ninto a two-dimensional row or column matrix. You can do this with the reshape\nmethod, or more easily by making use of the newaxis keyword within a slice operation:","647f7a43":"* **Broadcasting in NumPy follows a strict set of rules to determine the interaction\nbetween the two arrays:**\n    \n* Rule 1: If the two arrays differ in their number of dimensions, the shape of the\none with fewer dimensions is padded with ones on its leading (left) side.\n* Rule 2: If the shape of the two arrays does not match in any dimension, the array\nwith shape equal to 1 in that dimension is stretched to match the other shape.\n* Rule 3: If in any dimension the sizes disagree and neither is equal to 1, an error is\nraised.","a6e3245e":"<a id=\"1\"><\/a> <br>\n# Introduction to NumPy\n\n* NumPy is the fundamental package for scientific computing in Python","0b32764c":"<a id=\"27\"><\/a> <br>\n### Visualization of NumPy broadcasting\n\n<img src=\"https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/figures\/02.05-broadcasting.png\" alt=\"broadcasting\" border=\"0\">","bc090c21":"<a id=\"9\"><\/a> <br>\n### Reshaping of Arrays","323beb24":"<a id=\"29\"><\/a> <br>\n### Broadcasting example 2","453d316f":"<a id=\"24\"><\/a> <br>\n### Multidimensional aggregates","ddb01f72":"* Similarly, np.dstack will stack arrays along the third axis.","8d5aae65":"#### Rules of Broadcasting","36e146c0":"<a id=\"36\"><\/a> <br>\n### Exploring Fancy Indexing","87e01a39":"<a id=\"42\"><\/a> <br>\n### Partial Sorts: Partitioning","18148e89":"<a id=\"18\"><\/a> <br>\n#### Specifying output","9fa54e20":"* Another common type of operation available in a NumPy ufunc are the exponentials:","f29ebab1":"<a id=\"44\"><\/a> <br>\n#### Multidimensional subarrays","d07c0117":"* You can also concatenate more than two arrays at once:","3e1631dd":"<a id=\"4\"><\/a> <br>\n### NumPy Standard Data Types","13be9894":"<img src=\"https:\/\/3.bp.blogspot.com\/-2pjqt9Ga6IM\/W20-sIVK0II\/AAAAAAAAXVM\/BB74tRGTiwgcYTgezVLD3LKH7NFj4pjpgCLcBGAs\/s1600\/4214_t2-3.PNG\" alt=\"cce\" border=\"0\">","149f0113":"<a id=\"39\"><\/a> <br>\n# Sorting Arrays","78d41b69":"* Notice that N split points lead to N + 1 subarrays. The related functions np.hsplit\nand np.vsplit are similar:","8ec11830":"#### Concatenation of arrays","ee9935d5":"<a id=\"38\"><\/a> <br>\n### Modifying Values with Fancy Indexing","504ff5d9":"<a id=\"21\"><\/a> <br>\n# Aggregations: Min, Max, and Everything in Between","c96e6307":"# This kernel will be updated regularly.","d26d8de7":"<a id=\"16\"><\/a> <br>\n#### Exponents and logarithms","8897c80a":"<a id=\"10\"><\/a> <br>\n### Array Concatenation and Splitting","defc427f":"\n### In this kernel, we will cover NumPy in detail.\n\n**Content:**\n\n1. [Introduction to NumPy](#1)\n2. [Understanding Data Types in Python](#2)\n      * [Creating Arrays from Scratch](#3)\n      * [NumPy Standard Data Types](#4)\n3. [The Basics of NumPy Arrays](#5)\n      * [NumPy Array Attributes](#6)\n      * [Array Indexing: Accessing Single Elements](#7)\n      * [Array Slicing: Accessing Subarrays](#8)\n         * 1- [One-dimensional subarrays](#43)  \n         * 2- [Multidimensional subarrays](#44)\n         * 3- [Accessing array rows and columns](#45)\n         * 4- [Subarrays as no-copy views](#46)\n         * 5- [Creating copies of arrays](#47)\n      * [Reshaping of Arrays](#9)\n      * [Array Concatenation and Splitting](#10)\n4. [Computation on NumPy Arrays: Universal Functions](#11)\n      * [Exploring NumPy\u2019s UFuncs](#12)\n         * 1- [Array arithmetic](#13)  \n         * 2- [Exponents and logarithms](#14)\n         * 3- [Absolute value](#15)\n         * 4- [Trigonometric functions](#16)\n      * [Advanced Ufunc Features](#17)\n         * 1- [Specifying output](#18)  \n         * 2- [Aggregates](#19)\n         * 3- [Outer products](#20)\n5. [Aggregations: Min, Max, and Everything in Between](#21)\n      * [Summing the Values in an Array](#22)\n      * [Minimum and Maximum](#23)\n      * [Multidimensional aggregates](#24)\n6. [Computation on Arrays: Broadcasting](#25)\n      * [Introducing Broadcasting](#26)\n      * [Visualization of NumPy broadcasting](#27)\n      * [Broadcasting example 1](#28)\n      * [Broadcasting example 2](#29)\n      * [Broadcasting example 3](#30)\n7. [Comparisons, Masks, and Boolean Logic](#31)\n      * [Comparison Operators as ufuncs](#32)\n      * [Working with Boolean Arrays ](#33)\n8. [Fancy Indexing](#34)\n      * [Exploring Fancy Indexing](#35)   \n      * [Combined Indexing](#36) \n      * [Modifying Values with Fancy Indexing](#37)\n9. [Fancy Indexing](#38)\n      * [Fast Sorting in NumPy: np.sort and np.argsort](#39)   \n      * [Sorting along rows or columns](#40) \n      * [Partial Sorts: Partitioning](#41)\n10. [Conclusion](#42)   ","0d588a00":"* For binary ufuncs, there are some interesting aggregates that can be computed\ndirectly from the object. For example, if we\u2019d like to reduce an array with a particular\noperation, we can use the reduce method of any ufunc. A reduce repeatedly applies a\ngiven operation to the elements of an array until only a single result remains.\nFor example, calling reduce on the add ufunc returns the sum of all elements in the\narray:","13d1ff0f":"* Finally, any ufunc can compute the output of all pairs of two different inputs using\nthe outer method. This allows you, in one line, to do things like create a multiplica\u2010\ntion table:","c1d89796":"<a id=\"15\"><\/a> <br>\n#### Trigonometric functions","9de1cc35":"<a id=\"32\"><\/a> <br>\n### Comparison Operators as ufuncs","cfdee5ee":"<a id=\"28\"><\/a> <br>\n### Broadcasting example 1","f70354c9":"<a id=\"7\"><\/a> <br>\n### Array Indexing: Accessing Single Elements","7af8192d":"<img src=\"https:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/1\/1a\/NumPy_logo.svg\/1200px-NumPy_logo.svg.png\" alt=\"cce\" border=\"0\">","c9b033fc":"<a id=\"23\"><\/a> <br>\n### Minimum and Maximum","71cc89f3":"* Just as we can use square brackets to access individual array elements, we can also use\nthem to access subarrays with the slice notation, marked by the colon (:) character.\nThe NumPy slicing syntax follows that of the standard Python list; to access a slice of\nan array x, use this:\n* x[start:stop:step]\n* If any of these are unspecified, they default to the values start=0, stop=size of\ndimension, step=1. We\u2019ll take a look at accessing subarrays in one dimension and in\nmultiple dimensions.","1c8c060e":"<a id=\"41\"><\/a> <br>\n### Sorting along rows or columns","9dcd9521":"* The result of these comparison operators is always an array with a Boolean data type.\nAll six of the standard comparison operations are available:\n\n* for example, you might wish to count all values greater than a certain value,\nor perhaps remove all outliers that are above some threshold. In NumPy,\nBoolean masking is often the most efficient way to accomplish these types of tasks.","33fbcf1c":"<a id=\"11\"><\/a> <br>\n# Computation on NumPy Arrays: Universal Functions","d4fe7257":"### Resources that helped in preparing this kernel:\n\n* https:\/\/www.oreilly.com\/library\/view\/python-data-science\/9781491912126\/","58154ceb":"<a id=\"33\"><\/a> <br>\n### Comparison operators and their equivalent\n\n<img src=\"https:\/\/3.bp.blogspot.com\/-ePv8m0F9BaI\/W4nwyN2vb2I\/AAAAAAAAXWs\/zF0LYfQGYzI4u4JILeHSnH4-jRoUgk-TwCLcBGAs\/s1600\/4229_2.PNG\" alt=\"Comparison operators and their equivalent\" border=\"0\">","e39d563d":"* One important\u2014and extremely useful\u2014thing to know about array slices is that they\nreturn views rather than copies of the array data. This is one area in which NumPy\narray slicing differs from Python list slicing: in lists, slices will be copies. Consider our\ntwo-dimensional array from before:","fa7f3261":"<a id=\"31\"><\/a> <br>\n# Comparisons, Masks, and Boolean Logic","f2a9696e":"<a id=\"5\"><\/a> <br>\n# The Basics of NumPy Arrays","b138fc7a":"<a id=\"17\"><\/a> <br>\n### Advanced Ufunc Features","c3c54c15":"<a id=\"42\"><\/a>\n# Conclusion\n* **If you like it, please upvote   :)**\n* **If you have any question, I will be appreciate to hear it   :)**"}}