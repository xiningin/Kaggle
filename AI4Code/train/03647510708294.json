{"cell_type":{"18834d0c":"code","19a69181":"code","7040bf53":"code","46daaab2":"code","4fe8969d":"code","c736b508":"code","a7f87cd0":"code","d467be69":"code","6aa4b1fd":"code","da0ae8ff":"code","265683b7":"code","a9749731":"code","e5266626":"code","d0e7c480":"code","657bfcc2":"code","f547259c":"code","f60385dc":"code","994431fe":"code","52d8204f":"code","f26e7f6b":"code","80afed3e":"code","95a93086":"code","6bed32c2":"code","5dc12470":"code","97d1990e":"markdown","9bde8456":"markdown","c2eaf6be":"markdown","5ed45277":"markdown","3b2a5fee":"markdown","33a799ad":"markdown","f8a67f16":"markdown","98a974bb":"markdown","d2921664":"markdown","46cfc1ac":"markdown","f069a919":"markdown","2775c9d1":"markdown"},"source":{"18834d0c":"!pip install beautifulsoup4","19a69181":"import datetime\nimport asyncio\nimport aiohttp\nimport requests as r\nimport pandas as pd\nimport numpy as np\nfrom bs4 import BeautifulSoup, SoupStrainer\n\n# for run asyncio in jupyter \/ https:\/\/github.com\/jupyter\/notebook\/issues\/3397\nimport nest_asyncio\nnest_asyncio.apply()","7040bf53":"date_id = 'id1'  \nfifa_url = 'https:\/\/www.fifa.com\/fifa-world-ranking\/ranking-table\/men\/rank'\n\ndef get_dates_html():\n    page_source = r.get(f'{fifa_url}\/{date_id}\/')\n    page_source.raise_for_status()\n    dates = BeautifulSoup(page_source.text, \n                          'html.parser', \n                          parse_only=SoupStrainer('li', attrs={'class': 'fi-ranking-schedule__nav__item'}))\n    return dates\n\n\ndef create_dates_dataset(html_dates):\n    date_ids = [li['data-value'] for li in html_dates]\n    dates = [li.text.strip() for li in html_dates]\n    dataset = pd.DataFrame(data={'date': dates, 'date_id': date_ids})\n    \n    # convert 'date' from str to datetime and sorting \"old -> new\"\n    dataset['date'] = pd.to_datetime(dataset['date'], format='%d %B %Y')\n    dataset.sort_values('date', ignore_index=True, inplace=True)\n    assert dataset.date.min() == dataset.iloc[0].date, \\\n            \"Incorrect dataset sorting\"\n    \n    return dataset\n\ndates_from_page = get_dates_html()\ndates_dataset = create_dates_dataset(dates_from_page)\n\nassert len(dates_from_page) == dates_dataset.shape[0], \\\n        \"Number of dates in html and dataset don't match\"\n\nasync def get_rank_page(date_id, session):\n    async with session.get(f'{fifa_url}\/{date_id}\/') as response:\n        page = await response.text()\n        if response.status == 200:\n            return {'page': page, 'id': date_id}\n        else:\n            print(f'Parse error, page: {response.url}')\n            return False\n        \n        \ndef scrapy_rank_table(page, date):\n    rows = BeautifulSoup(page, \n                          'html.parser', \n                          parse_only=SoupStrainer('tbody')).find_all('tr')\n    table = []\n    for row in rows:\n        table.append({\n            'id': int(row['data-team-id']), \n            'country_full': row.find('span', {'class': 'fi-t__nText'}).text, \n            'country_abrv': row.find('span', {'class': 'fi-t__nTri'}).text,\n            'rank': int(row.find('td', {'class': 'fi-table__rank'}).text), \n            #'total_points': int(row.find('td', {'class': 'fi-table__points'}).text),\n            'total_points': row.find('td', {'class': 'fi-table__points'}).text,\n            #'previous_points': int(row.find('td', {'class': 'fi-table__prevpoints'}).text or 0),\n            'previous_points': row.find('td', {'class': 'fi-table__prevpoints'}).text or 0,\n            'rank_change': int(row.find('td', {'class': 'fi-table__rankingmovement'}).text.replace('-', '0')),\n            'confederation': row.find('td', {'class': 'fi-table__confederation'}).text.strip('#'),\n            'rank_date': date\n        })\n    return table\n    \n\nasync def parse_ranks(pages_df):\n    fifa_ranking = pd.DataFrame(columns=[\n        'id', 'rank', 'country_full', 'country_abrv', \n        'total_points', 'previous_points', 'rank_change', \n        'confederation', 'rank_date'\n    ])\n\n    start_time = datetime.datetime.now()\n    print(\"Start parsing.. \", datetime.datetime.now()-start_time)\n    \n    task_parse = []\n    async with aiohttp.ClientSession() as session:\n        for date_id in pages_df.date_id.to_list():\n            task_parse += [asyncio.create_task(get_rank_page(date_id, session))]\n    \n        for task in asyncio.as_completed(task_parse):\n            page = await task\n            if not task:\n                continue\n            date_ranking = scrapy_rank_table(page['page'], \n                                             pages_df[pages_df.date_id == page['id']].date.iloc[0])\n            fifa_ranking = fifa_ranking.append(date_ranking, ignore_index=True)\n\n            if fifa_ranking.rank_date.nunique() % 50 == 0:\n                print(f'Complite {fifa_ranking.rank_date.nunique()}\/{pages_df.shape[0]} dates')\n    \n    fifa_ranking.sort_values('rank_date', ignore_index=True, inplace=True)\n    print(f'Parsing complite. Time {datetime.datetime.now()-start_time}')\n    return fifa_ranking\n\n\ndef data_correction(df):\n    \"\"\" Handmade \"\"\"\n    # Lebanon has two abbreviations\n    df.replace({'country_abrv': 'LIB'}, 'LBN', inplace=True)\n    # Montenegro duplicates\n    df.drop(df[df.id == 1903356].index, inplace=True)\n    # North Macedonia has two full names\n    df.replace({'country_full': 'FYR Macedonia'}, 'North Macedonia', inplace=True)\n    # Cabo Verde has two full names\n    df.replace({'country_full': 'Cape Verde Islands'}, 'Cabo Verde', inplace=True)\n    # Saint Vincent and the Grenadines have two full names\n    df.replace({'country_full': 'St. Vincent and the Grenadines'}, 'St. Vincent \/ Grenadines', inplace=True)\n    # Swaziland has two full names\n    df.replace({'country_full': 'Eswatini'}, 'Swaziland', inplace=True)\n    # Curacao transform to Cura\u00e7ao (with '\u00e7')\n    df.replace({'country_full': 'Curacao'}, 'Cura\u00e7ao', inplace=True)\n    # S\u00e3o Tom\u00e9 and Pr\u00edncipe have three full names\n    df.replace({'country_full': ['Sao Tome e Principe', 'S\u00e3o Tom\u00e9 e Pr\u00edncipe']}, \n               'S\u00e3o Tom\u00e9 and Pr\u00edncipe', inplace=True)\n    return df\n\n\ndef check_data(ranks_df, dates_df):\n    if ranks_df.rank_date.nunique() != dates_df.date.nunique():\n        print(\"Warning! Numbers of rank dates don't match\")\n    if ranks_df.country_full.nunique() != ranks_df.country_abrv.nunique():\n        print(\"Warning! Number of names and abbreviations does not match\")\n    if ranks_df.country_full.nunique() != ranks_df.id.nunique():\n        print(\"Warning! Number of names and IDs does not match\")\n        \n\ndef save_as_csv(df):\n    df.to_csv(\n        f'fifa_ranking-{df.rank_date.max().date()}.csv',\n        index=False, \n        encoding='utf-8'\n    )\n    print('Dataframe saved in currently folder')","46daaab2":"fifa_ranking_df = asyncio.run(parse_ranks(dates_dataset))\nfifa_ranking_df = data_correction(fifa_ranking_df)\ncheck_data(fifa_ranking_df, dates_dataset)\nsave_as_csv(fifa_ranking_df)\n\nfifa_ranking_df.tail()","4fe8969d":"teams = [['Italy', 'ITA', 'A'],\n        ['Switzerland', 'SUI', 'A'],\n        ['Turkey', 'TUR', 'A'],\n        ['Wales', 'WAL', 'A'],\n        ['Belgium', 'BEL', 'B'],\n        ['Denmark', 'DEN', 'B'],\n        ['Finland', 'FIN', 'B'],\n        ['Russia', 'RUN', 'B'],\n        ['Austria', 'AUT', 'C'],\n        ['Netherlands', 'NED', 'C'],\n        ['North Macedonia', 'MKD', 'C'],\n        ['Ukraine', 'UKR', 'C'],\n        ['Croatia', 'CRO', 'D'],\n        ['Czech Republic', ' CZE', 'D'],\n        ['England', 'ENG', 'D'],\n        ['Scotland', 'SCO', 'D'],\n        ['Poland', 'POL', 'E'],\n        ['Slovakia', 'SVK', 'E'],\n        ['Spain', 'ESP', 'E'],\n        ['Sweden', 'SWE', 'E'],\n        ['France', 'FRA', 'F'],\n        ['Germany', 'GER', 'F'],\n        ['Hungary', 'HUN', 'F'],\n        ['Portugal', 'POR', 'F']]\nteams_df = pd.DataFrame(teams, columns=['Country', 'Abrv', 'Group'])\nteams_df.head(4)","c736b508":"match_df = pd.read_csv('..\/input\/international-football-results-from-1872-to-2017\/results.csv')\n# only matches from 1993\nmatch_df = match_df[match_df.date > '1993-01-01']\n# only matches between playing teams\nmatch_df = match_df[match_df.home_team.isin(teams_df.Country.to_list())]\nmatch_df = match_df[match_df.away_team.isin(teams_df.Country.to_list())]\nmatch_df.reset_index(drop=True, inplace=True)\n# drop city column\nmatch_df.drop(labels='city', axis=1, inplace=True)\nprint('Number of matches after filtering: {}'.format(len(match_df)))","a7f87cd0":"MATCHES = len(match_df)\n\nhome_rank = np.zeros(MATCHES, dtype=np.int)\naway_rank = np.zeros(MATCHES, dtype=np.int)\nhome_total_points = np.zeros(MATCHES, dtype=np.float)\naway_total_points = np.zeros(MATCHES, dtype=np.float)\nfor i in range(MATCHES):\n    home_listing = fifa_ranking_df[((fifa_ranking_df.country_full == match_df.iloc[i].home_team) & \n                            (fifa_ranking_df.rank_date <= match_df.iloc[i].date))].sort_values(by='rank_date', ascending=False)\n    \n    try:\n        home_rank[i] = int(home_listing.iloc[0]['rank'])\n    except:\n        home_rank[i] = 155\n        \n    away_listing = fifa_ranking_df[((fifa_ranking_df.country_full == match_df.iloc[i].away_team) & \n                            (fifa_ranking_df.rank_date <= match_df.iloc[i].date))].sort_values(by='rank_date', ascending=False)\n        \n    try:\n        away_rank[i] = int(away_listing.iloc[0]['rank'])\n    except:\n        away_rank[i] = 155","d467be69":"match_df['home_rank'] = home_rank\nmatch_df['away_rank'] = away_rank\nmatch_df['friendly'] = (match_df.tournament == 'Friendly')\nmatch_df.drop(labels=['tournament', 'date', 'country'], axis=1, inplace=True)\nmatch_df.neutral = match_df.neutral.astype(int)\nmatch_df.friendly = match_df.neutral.astype(int)","6aa4b1fd":"match_df.tail()","da0ae8ff":"X = match_df[['home_team', 'away_team', 'neutral', 'home_rank', 'away_rank', 'friendly']]\ny1 = match_df['home_score']\ny2 = match_df['away_score']\n\nonehot_columns = ['home_team', 'away_team']\nonehot_df = X[onehot_columns]\nonehot_df = pd.get_dummies(onehot_df, columns = onehot_columns)\nmatch_onehot_drop = X.drop(onehot_columns, axis = 1)\nmatch_onehot = pd.concat([match_onehot_drop, onehot_df], axis = 1)\nmatch_onehot.head()","265683b7":"from xgboost import XGBRegressor\n\n# home team score model\nhmodel = XGBRegressor()\nhmodel.fit(match_onehot.values, y1.values)\n#away team score model\namodel = XGBRegressor()\namodel.fit(match_onehot.values, y2.values)","a9749731":"def predict(h_country, a_country, neutral=True):\n    # create vector\n    cols = ['neutral', 'home_rank', 'away_rank', 'friendly']\n    for c in onehot_df.columns.to_list():\n        cols.append(c)\n    df = pd.DataFrame(np.zeros((1,len(cols)), dtype=int), columns=cols)\n    if neutral:\n        df.neutral.iloc[0] = 1\n    else:\n        df.neutral.iloc[0] = 0\n    df.home_rank.iloc[0] = fifa_ranking_df[((fifa_ranking_df.rank_date == '2021-05-27') & (fifa_ranking_df.country_full == h_country))]['rank'].values[0]\n    df.away_rank.iloc[0] = fifa_ranking_df[((fifa_ranking_df.rank_date == '2021-05-27') & (fifa_ranking_df.country_full == a_country))]['rank'].values[0]\n    df['home_team_'+h_country].iloc[0] = 1\n    df['away_team_'+a_country].iloc[0] = 1\n    #df = df[hmodel.get_booster().feature_names]\n    # predict\n    hscore = int(hmodel.predict(df.iloc[0].to_numpy().reshape(1,52))[0])\n    ascore = int(amodel.predict(df.iloc[0].to_numpy().reshape(1,52))[0])\n    return hscore, ascore","e5266626":"predict('Italy', 'Turkey', False)","d0e7c480":"predict('Wales', 'Switzerland')","657bfcc2":"predict('Denmark', 'Finland', False)","f547259c":"predict('Russia', 'Belgium', False)","f60385dc":"predict('England', 'Croatia', False)","994431fe":"predict('Austria', 'North Macedonia')","52d8204f":"predict('Netherlands', 'Ukraine', False)","f26e7f6b":"predict('Scotland', 'Czech Republic', False)","80afed3e":"predict('Poland', 'Slovakia')","95a93086":"predict('Spain', 'Sweden', False)","6bed32c2":"predict('Hungary', 'Portugal', False)","5dc12470":"predict('Germany', 'France', False)","97d1990e":"## Convert categorical features to onehot\nCountry names are strings which are not suitable input to most models, so here we convert them to onehot format.","9bde8456":"# Intro\nIn this notebook we will create a model to predict match results for the UEFA Euro 2021 championship. The data set consists of historic results from past matches and the FIFA rankings.","c2eaf6be":"# Data collection\nHistoric results are already available as a dataset. FIFA rankings will be scraped off the web using code from [this GitHub project](https:\/\/github.com\/cnc8\/fifa-world-ranking).   \n\nLet's start by importing some libraries.","5ed45277":"Now, get FIFA rankings using Beautiful Soup.","3b2a5fee":"Then we drop a few columns that will not be used.","33a799ad":"# Train XGBoost model\nWe will train a XGBoost regressor model, or rather two of them, to predict match results. One model to predict the home team score and one model for the away team score. It is also possible to use [sklearn.multioutput.MultiOutputRegressor](https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.multioutput.MultiOutputRegressor.html) to combine the two models.","f8a67f16":"## ","98a974bb":"# Summary\nWe have seen how a very simple match predicting model can be trained with XGBoost. I do not expect accuracy to be very high here, but it is a starting point for making more advanced models with more features.","d2921664":"# Predict\nNow the fun part! Let's predict the match results for the first week's matches, starting tomorrow! We need to check careful where the matches are played, so we get the \"neutral ground\" feature set right, and we also put the home team first in the function below.","46cfc1ac":"# Feature creation\nNext we will add some features to the match data, which is FIFA ranking for the home and away teams. There are many other features we could add, such as historic weather data etc.   \n\nFor each match the latest rank for each team is added to the dataframe.","f069a919":"## Define participants","2775c9d1":"## Filter out relevant historic match data\nThere are several choices to be made here. Include only matches between participants, or use all matches with at least one participant country - here we go for the former. The FIFA ranking is from December 1992, so we will filter out matches before that date since ranking will be an important feature in the model we will create."}}