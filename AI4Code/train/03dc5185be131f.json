{"cell_type":{"e23194d6":"code","8f22dbb9":"code","4844e110":"code","a9102a05":"code","fe58aa34":"code","3f7e424a":"code","3d9c95f1":"code","abad6d8a":"code","51666df5":"code","da657c1c":"markdown","c223c4ba":"markdown","78100da7":"markdown","9be73554":"markdown","78820cc8":"markdown"},"source":{"e23194d6":"import torchvision\nimport  torch.nn as nn\nimport torch\nimport torch.nn.functional as F\nfrom torchvision import transforms,models,datasets\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom torch import optim","8f22dbb9":"train_data_dir = '\/kaggle\/input\/cat-and-dog\/training_set\/training_set'\n\ntransform = transforms.Compose([transforms.Resize(255),\n                                transforms.CenterCrop(224),\n                                transforms.ToTensor()])\n\ndataset = torchvision.datasets.ImageFolder(train_data_dir, transform= transform)\ntrain_loader = torch.utils.data.DataLoader(dataset, batch_size=400 ,shuffle=True)","4844e110":"test_data_dir = '\/kaggle\/input\/cat-and-dog\/test_set\/test_set'\n\ntransform = transforms.Compose([transforms.Resize(255),\n                                transforms.CenterCrop(224),\n                                transforms.ToTensor()])\n\ndataset = torchvision.datasets.ImageFolder(train_data_dir, transform= transform)\ntest_loader = torch.utils.data.DataLoader(dataset, batch_size=400 ,shuffle=True)","a9102a05":"def imshow(inp, title=None):\n    \"\"\"Imshow for Tensor.\"\"\"\n    inp = inp.numpy().transpose((1, 2, 0))\n    plt.figure(figsize=(20,150))\n    plt.imshow(inp)\n\ninputs, classes = next(iter(train_loader))\n\n# Make a grid from batch\nout = torchvision.utils.make_grid(inputs, scale_each= True)\n\nimshow(out)","fe58aa34":"model = models.densenet121(pretrained = True)","3f7e424a":"for params in model.parameters():\n    params.requires_grad = False","3d9c95f1":"from collections import OrderedDict\n\nclassifier = nn.Sequential(OrderedDict([\n    ('fc1',nn.Linear(1024,500)),\n    ('relu',nn.ReLU()),\n    ('fc2',nn.Linear(500,2)),\n    ('Output',nn.LogSoftmax(dim=1))\n]))\n\nmodel.classifier = classifier","abad6d8a":"model = model.cuda()","51666df5":"optimizer= optim.Adam(model.classifier.parameters())\ncriterian= nn.NLLLoss()\nlist_train_loss=[]\nlist_test_loss=[]\n\nfor epoch in range(10):\n    train_loss= 0\n    test_loss= 0\n    for bat,(img,label) in enumerate(train_loader):\n        \n        # moving batch and lables to gpu\n        img = img.to('cuda:0')\n        label = label.to('cuda:0')\n        \n        model.train()\n        optimizer.zero_grad()\n\n        output = model(img)\n        loss = criterian(output,label)\n        loss.backward()\n        optimizer.step()\n        train_loss = train_loss+loss.item()\n        #print(bat)\n\n    accuracy=0\n    for bat,(img,label) in enumerate(test_loader):\n        img = img.to('cuda:0')\n        label = label.to('cuda:0')\n\n        model.eval()\n        logps= model(img)\n        loss = criterian(logps,label)\n\n        test_loss+= loss.item()\n        ps=torch.exp(logps)\n        top_ps,top_class=ps.topk(1,dim=1)\n        equality=top_class == label.view(*top_class.shape)\n        accuracy +=torch.mean(equality.type(torch.FloatTensor)).item()\n\n    list_train_loss.append(train_loss\/20)\n    list_test_loss.append(test_loss\/20)\n    print('epoch: ',epoch,'    train_loss:  ',train_loss\/20,'   test_loss:    ',test_loss\/20,'    accuracy:  ',accuracy\/len(test_loader))","da657c1c":"# Loading train and test data","c223c4ba":"# importing required libraries","78100da7":"# Loading Densenet121 model","9be73554":"# Moving the model to gpu","78820cc8":"# Taking batch size of 400 images"}}