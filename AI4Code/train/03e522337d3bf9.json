{"cell_type":{"0b2cdaac":"code","8add5fd4":"code","593dd04f":"code","0e1ca13b":"code","b66f5c81":"code","1540f7e7":"code","86f573f5":"code","2dd322e0":"code","ccbda2f7":"code","36fc40b2":"code","081735d2":"code","1c258b1e":"code","e542666f":"code","e5cd6102":"code","d077d69f":"code","3c851916":"code","ae3b13be":"code","e28121cd":"code","6103346c":"code","b4dcead9":"code","cb05f139":"code","edbd4207":"code","53376586":"code","8a32f2ed":"code","0765210b":"code","421fe863":"markdown","0756037f":"markdown","5abf7f78":"markdown","c5585989":"markdown","bf900320":"markdown","ca31fa66":"markdown","419f3e1e":"markdown","59f7fb14":"markdown"},"source":{"0b2cdaac":"import pandas as pd\nimport numpy as np\nimport pickle\nimport itertools\nimport gc\nimport math\nimport matplotlib.pyplot as plt\nimport dateutil.easter as easter\nfrom matplotlib.ticker import MaxNLocator, FormatStrFormatter, PercentFormatter\nfrom datetime import datetime, date, timedelta\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import GroupKFold, train_test_split\nfrom sklearn.linear_model import LinearRegression, HuberRegressor, Ridge, Lasso, ElasticNet, BayesianRidge, PassiveAggressiveRegressor\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.neural_network import MLPRegressor\nnp.random.seed(42)","8add5fd4":"original_train_df = pd.read_csv('..\/input\/tabular-playground-series-jan-2022\/train.csv')\noriginal_test_df = pd.read_csv('..\/input\/tabular-playground-series-jan-2022\/test.csv')\ngdp_df = pd.read_csv('..\/input\/gdp-20152019-finland-norway-and-sweden\/GDP_data_2015_to_2019_Finland_Norway_Sweden.csv')\n\ngdp_df.set_index('year', inplace=True)\n\n# The dates are read as strings and must be converted\nfor df in [original_train_df, original_test_df]:\n    df['date'] = pd.to_datetime(df.date)\noriginal_train_df.head(2)","593dd04f":"# Feature engineering\ndef engineer(df):\n    \"\"\"Return a new dataframe with the engineered features\"\"\"\n    \n    def get_gdp(row):\n        country = 'GDP_' + row.country\n        return gdp_df.loc[row.date.year, country]\n        \n    new_df = pd.DataFrame({'gdp': np.log(df.apply(get_gdp, axis=1)),\n                           'wd4': df.date.dt.weekday == 4, # Friday\n                           'wd56': df.date.dt.weekday >= 5, # Saturday and Sunday\n                          })\n\n    # One-hot encoding (no need to encode the last categories)\n    for country in ['Finland', 'Norway']:\n        new_df[country] = df.country == country\n    new_df['KaggleRama'] = df.store == 'KaggleRama'\n    for product in ['Kaggle Mug', 'Kaggle Hat']:\n        new_df[product] = df['product'] == product\n        \n    # Seasonal variations (Fourier series)\n    # The three products have different seasonal patterns\n    dayofyear = df.date.dt.dayofyear\n    for k in range(1, 3):\n        new_df[f'sin{k}'] = np.sin(dayofyear \/ 365 * 2 * math.pi * k)\n        new_df[f'cos{k}'] = np.cos(dayofyear \/ 365 * 2 * math.pi * k)\n        new_df[f'mug_sin{k}'] = new_df[f'sin{k}'] * new_df['Kaggle Mug']\n        new_df[f'mug_cos{k}'] = new_df[f'cos{k}'] * new_df['Kaggle Mug']\n        new_df[f'hat_sin{k}'] = new_df[f'sin{k}'] * new_df['Kaggle Hat']\n        new_df[f'hat_cos{k}'] = new_df[f'cos{k}'] * new_df['Kaggle Hat']\n\n    return new_df\n\ntrain_df = engineer(original_train_df)\ntrain_df['date'] = original_train_df.date\ntrain_df['num_sold'] = original_train_df.num_sold.astype(np.float32)\ntest_df = engineer(original_test_df)\n\nfeatures = test_df.columns\n\nfor df in [train_df, test_df]:\n    df[features] = df[features].astype(np.float32)\nprint(list(features))","0e1ca13b":"# Feature engineering for holidays\ndef engineer_more(df):\n    \"\"\"Return a new dataframe with more engineered features\"\"\"\n    new_df = engineer(df)\n\n    # End of year\n    new_df = pd.concat([new_df,\n                        pd.DataFrame({f\"dec{d}\":\n                                      (df.date.dt.month == 12) & (df.date.dt.day == d)\n                                      for d in range(24, 32)}),\n                        pd.DataFrame({f\"n-dec{d}\":\n                                      (df.date.dt.month == 12) & (df.date.dt.day == d) & (df.country == 'Norway')\n                                      for d in range(24, 32)}),\n                        pd.DataFrame({f\"f-jan{d}\":\n                                      (df.date.dt.month == 1) & (df.date.dt.day == d) & (df.country == 'Finland')\n                                      for d in range(1, 14)}),\n                        pd.DataFrame({f\"jan{d}\":\n                                      (df.date.dt.month == 1) & (df.date.dt.day == d) & (df.country == 'Norway')\n                                      for d in range(1, 10)}),\n                        pd.DataFrame({f\"s-jan{d}\":\n                                      (df.date.dt.month == 1) & (df.date.dt.day == d) & (df.country == 'Sweden')\n                                      for d in range(1, 15)})],\n                       axis=1)\n    \n    # May\n    new_df = pd.concat([new_df,\n                        pd.DataFrame({f\"may{d}\":\n                                      (df.date.dt.month == 5) & (df.date.dt.day == d) \n                                      for d in list(range(1, 10))}), #  + list(range(17, 25))\n                        pd.DataFrame({f\"may{d}\":\n                                      (df.date.dt.month == 5) & (df.date.dt.day == d) & (df.country == 'Norway')\n                                      for d in list(range(19, 26))})],\n                       axis=1)\n    \n    # June and July\n    new_df = pd.concat([new_df,\n                        pd.DataFrame({f\"june{d}\":\n                                      (df.date.dt.month == 6) & (df.date.dt.day == d) & (df.country == 'Sweden')\n                                      for d in list(range(8, 14))}),\n                        #pd.DataFrame({f\"june{d}\":\n                        #              (df.date.dt.month == 6) & (df.date.dt.day == d) & (df.country == 'Norway')\n                        #              for d in list(range(22, 31))}),\n                        #pd.DataFrame({f\"july{d}\":\n                        #              (df.date.dt.month == 7) & (df.date.dt.day == d) & (df.country == 'Norway')\n                        #              for d in list(range(1, 3))})],\n                       ],\n                       axis=1)\n    \n    # Last Wednesday of June\n    wed_june_date = df.date.dt.year.map({2015: pd.Timestamp(('2015-06-24')),\n                                         2016: pd.Timestamp(('2016-06-29')),\n                                         2017: pd.Timestamp(('2017-06-28')),\n                                         2018: pd.Timestamp(('2018-06-27')),\n                                         2019: pd.Timestamp(('2019-06-26'))})\n    new_df = pd.concat([new_df,\n                        pd.DataFrame({f\"wed_june{d}\": \n                                      (df.date - wed_june_date == np.timedelta64(d, \"D\")) & (df.country != 'Norway')\n                                      for d in list(range(-4, 6))})],\n                       axis=1)\n    \n    # First Sunday of November\n    sun_nov_date = df.date.dt.year.map({2015: pd.Timestamp(('2015-11-1')),\n                                         2016: pd.Timestamp(('2016-11-6')),\n                                         2017: pd.Timestamp(('2017-11-5')),\n                                         2018: pd.Timestamp(('2018-11-4')),\n                                         2019: pd.Timestamp(('2019-11-3'))})\n    new_df = pd.concat([new_df,\n                        pd.DataFrame({f\"sun_nov{d}\": \n                                      (df.date - sun_nov_date == np.timedelta64(d, \"D\")) & (df.country != 'Norway')\n                                      for d in list(range(0, 9))})],\n                       axis=1)\n    \n    # First half of December (Independence Day of Finland, 6th of December)\n    new_df = pd.concat([new_df,\n                        pd.DataFrame({f\"dec{d}\":\n                                      (df.date.dt.month == 12) & (df.date.dt.day == d) & (df.country == 'Finland')\n                                      for d in list(range(6, 14))})],\n                       axis=1)\n\n    # Easter\n    easter_date = df.date.apply(lambda date: pd.Timestamp(easter.easter(date.year)))\n    new_df = pd.concat([new_df,\n                        pd.DataFrame({f\"easter{d}\": \n                                      (df.date - easter_date == np.timedelta64(d, \"D\"))\n                                      for d in list(range(-2, 11)) + list(range(40, 48)) + list(range(50, 59))})],\n                       axis=1)\n    \n    return new_df.astype(np.float32)\n\ntrain_df = engineer_more(original_train_df)\ntrain_df['date'] = original_train_df.date\ntrain_df['num_sold'] = original_train_df.num_sold.astype(np.float32)\ntest_df = engineer_more(original_test_df)\n\nfeatures = list(test_df.columns)\nprint(list(features))\n\n# prepare single scaler\nscaler = StandardScaler()\nX = scaler.fit_transform(train_df[features])","b66f5c81":"mask = np.random.rand(len(train_df)) < 0.9\nvalid_df = train_df[~mask]\ntrain_df = train_df[mask]\nvalid_df.head()","1540f7e7":"len((valid_df.columns))","86f573f5":"linear = LinearRegression()                                              # simple one\nhuber = HuberRegressor()                                                 # uses more complicated loss that makes it robust \nridge = Ridge()                                                          # avoids overfitting because of weight addition into loss function. So weights are kept small\nlasso = Lasso(max_iter=200, alpha=0.2)                                   # has more complicated reguilarization\nelastic_net = ElasticNet(max_iter=200)                                   # combination of lasso and ridge\nbayesian = BayesianRidge()                                               # statistical analysis is understaken in this model. It is actually very interesting one\n\nperceptron = MLPRegressor(hidden_layer_sizes=(128, 32, 16),              # several fully connected layers with hidden function. It may not be that useful in linearized data\n                    max_iter=200,\n                    activation='tanh', # tanh performs better than relu\n                    solver='adam')\n# someting more complex\npar = PassiveAggressiveRegressor()                                       \ngbr = GradientBoostingRegressor()","2dd322e0":"def smape_loss(y_true, y_pred):\n    \"\"\"SMAPE Loss\"\"\"\n    return np.abs(y_true - y_pred) \/ (y_true + np.abs(y_pred)) * 200\n\ndef train_model(model, scaler, X_tr, X_va=None):\n    start_time = datetime.now()\n    \n    X = X_tr[features]\n    y = X_tr.num_sold.values.reshape(-1, 1)\n    \n    X = scaler.transform(X)\n\n    model.fit(X, np.log(y).ravel())\n    \n    if X_va is not None:\n        X_v = X_va[features]\n        X_v = scaler.transform(X_v)\n        y_v = X_va.num_sold.values.reshape(-1, 1)\n\n\n        y_v_pred = np.exp(model.predict(X_v)).reshape(-1, 1)\n        \n        smape_before_correction = np.mean(smape_loss(y_v, y_v_pred))\n\n        smape = np.mean(smape_loss(y_v, y_v_pred))\n        print(f\"Model {model} | {str(datetime.now() - start_time)[-12:-7]}\"\n              f\" | SMAPE: {smape:.5f}\")\n        \n        plt.figure(figsize=(10, 10))\n        plt.scatter(y_v, y_v_pred, s=1, color='r')\n        plt.plot([plt.xlim()[0], plt.xlim()[1]], [plt.xlim()[0], plt.xlim()[1]], '--', color='k')\n        plt.gca().set_aspect('equal')\n        plt.xlabel('y_true')\n        plt.ylabel('y_pred')\n        plt.title('OOF Predictions')\n        plt.show()\n        \n    return model","ccbda2f7":"linear = train_model(linear, scaler, train_df, valid_df)","36fc40b2":"huber = train_model(huber, scaler, train_df, valid_df)","081735d2":"ridge = train_model(ridge, scaler, train_df, valid_df)","1c258b1e":"lasso = Lasso(max_iter=200, alpha=0.000002)\nlasso = train_model(lasso, scaler, train_df, valid_df)","e542666f":"elastic_net = ElasticNet(max_iter=200, alpha=0.0000002)\nelastic_net = train_model(elastic_net, scaler, train_df, valid_df)","e5cd6102":"bayesian = train_model(bayesian, scaler, train_df, valid_df)","d077d69f":"perceptron = MLPRegressor(hidden_layer_sizes=(64, 16, 8),              # several fully connected layers with hidden function. It may not be that useful in linearized data\n                    max_iter=100,\n                    activation='tanh', \n                    solver='adam')\nperceptron = train_model(perceptron, scaler, train_df, valid_df)","3c851916":"par = PassiveAggressiveRegressor(early_stopping=True)                                       \n\npar = train_model(par, scaler, train_df, valid_df)","ae3b13be":"gbr = GradientBoostingRegressor(max_depth=7)\ngbr = train_model(gbr, scaler, train_df, valid_df)","e28121cd":"def predict(model, scaler, df):\n    pred_list = []\n    pred_list.append(np.exp(model.predict(scaler.transform(df[features]))))\n    return pred_list","6103346c":"linear_valid = predict(linear, scaler, valid_df)\nhuber_valid = predict(huber, scaler, valid_df)\nridge_valid = predict(ridge, scaler, valid_df)\nlasso_valid = predict(lasso, scaler, valid_df)\nelastic_net_valid = predict(elastic_net, scaler, valid_df)\nbayesian_valid = predict(bayesian, scaler, valid_df)\nperceptron_valid = predict(perceptron, scaler, valid_df)\npar_valid = predict(par, scaler, valid_df)\ngbr_valid = predict(gbr, scaler, valid_df)","b4dcead9":"names = ['linear', 'huber', 'ridge', 'lasso', 'elastic_net', 'bayesian', 'perceptron', 'par', 'gbr', 'actual']\n#names = ['linear', 'huber', 'ridge', 'lasso', 'elastic_net', 'bayesian', 'actual']\nactual = valid_df['num_sold'].values\ndata = pd.DataFrame(list(zip(linear_valid[0], huber_valid[0], ridge_valid[0], lasso_valid[0], elastic_net_valid[0], bayesian_valid[0], perceptron_valid[0], par_valid[0], gbr_valid[0], actual)), columns=names)\n#data = pd.DataFrame(list(zip(linear_valid[0], huber_valid[0], ridge_valid[0], lasso_valid[0], elastic_net_valid[0], bayesian_valid[0], actual)), columns=names)\ndata.head()","cb05f139":"# train ensemble\nensemble = Lasso(fit_intercept=False, positive=True, alpha=0)\nensemble.fit(data[names[:-1]], data['actual'])\nprint('Weight of ensemble are', ensemble.coef_)\nensemble.coef_.sum()","edbd4207":"linear_test = predict(linear, scaler, test_df)\nhuber_test = predict(huber, scaler, test_df)\nridge_test = predict(ridge, scaler, test_df)\nlasso_test = predict(lasso, scaler, test_df)\nelastic_net_test = predict(elastic_net, scaler, test_df)\nbayesian_test = predict(bayesian, scaler, test_df)\nperceptron_test = predict(perceptron, scaler, test_df)\npar_test = predict(par, scaler, test_df)\ngbr_test = predict(gbr, scaler, test_df)\n\n\ndata = pd.DataFrame(list(zip(linear_test[0], huber_test[0], ridge_test[0], lasso_test[0], elastic_net_test[0], bayesian_test[0], perceptron_test[0], par_test[0], gbr_test[0])), columns=names[:-1])\n#data = pd.DataFrame(list(zip(linear_test[0], huber_test[0], ridge_test[0], lasso_test[0], elastic_net_test[0], bayesian_test[0])), columns=names[:-1])\ndata.head()","53376586":"# predict\ntest_prediction = ensemble.predict(data)\n\nsub = original_test_df[['row_id']].copy()\nsub['num_sold'] = test_prediction\nsub.to_csv('submission.csv', index=False)\nsub.head()","8a32f2ed":"# Plot the distribution of the test predictions\nplt.figure(figsize=(16,3))\nplt.hist(train_df['num_sold'], bins=np.linspace(0, 3000, 201),\n         density=True, label='Training')\nplt.hist(sub['num_sold'], bins=np.linspace(0, 3000, 201),\n         density=True, rwidth=0.5, label='Test predictions')\nplt.xlabel('num_sold')\nplt.ylabel('Frequency')\nplt.legend()\nplt.show()","0765210b":"sub_rounded = sub.copy()\nsub_rounded['num_sold'] = (sub_rounded['num_sold']).round() # cheating\nsub_rounded.to_csv('submission_rounded.csv', index=False)\nsub_rounded.head()","421fe863":"### Observations\nSimple regressions perform well while multilayer perceptron and other complicated models have lower score. \nComplexity of this problem is too low for complex models to work. Probably it is better to break the problem by using more feature engineering or autoencoder to make data complex\nInteresting that Lasso and Elastic Net failed completely. May be they are required to be tuned or the problem is that they want to acees the inter weights of model. I don't know\n\nUpdate: Hyperparameters needed to be tuned well to achieve good results","0756037f":"## Train\n\nTrain all of them independently on whole train ataset and see its score on the validation data","5abf7f78":"PassiveAggressiveRegressor has nonzero weight. Means it is still good even if too complex","c5585989":"## Models\n\nI pick morels from sklearn libraries that solve linear regression tasks. \nYou can find more information about them at https:\/\/scikit-learn.org\/stable\/supervised_learning.html\n\nNote that I don't tune hyperparameters, so models perform better if more time was spent on them","bf900320":"## Introduction\n\n\nData preprocessing and most part of code is copied from https:\/\/www.kaggle.com\/ambrosm\/tpsjan22-03-linear-model\/notebook\n\nThis notebbok\n* Explores and compares several models in sklean library\n* Creates ensemble that has no overfitting risk since test data is only used for predictions\n\nUpdates\n* V2: models' hyper-paramters are tuned to get the largest validation score","ca31fa66":"Let's take 10% of train dataset that will be used for ensemble","419f3e1e":"## Ensemble\nNow let's each model predict on validation dataset and find the corresponding weights on the final encemble using this data. \nInstead of manual set, I will use lasso regression to fiind the weighs. Restrictions are that regression is zero biased and weights are positive. Lasso type is used bevause only this model in library has the parameter of only positive weights","59f7fb14":"## Data Preparation"}}