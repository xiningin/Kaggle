{"cell_type":{"97868470":"code","92925d6b":"code","1f843ad0":"code","8e4c77d2":"code","1789d652":"code","58d3c4ef":"code","790650e0":"code","c42cd2aa":"code","20c25608":"code","a5c31aa7":"code","67a8168f":"code","17d68d62":"code","d7f04980":"code","338a7477":"code","299793d3":"code","bf7a1d1d":"code","d81aa77c":"code","9dbce936":"code","00defd66":"code","114709eb":"code","10b662c5":"code","45e7a037":"code","6696131e":"code","9772b374":"code","48db94ed":"code","6bed65f3":"code","aa651cc6":"code","1ac0c7bd":"code","019b27f6":"code","a1623813":"code","943e8ac7":"code","603b1748":"code","fb03d216":"code","1f0fe1cd":"code","51aec9bd":"code","d5fbc2c0":"code","549f67d4":"code","c20a5b02":"code","a5286c57":"code","d1856f3c":"code","65710581":"code","2775f324":"code","59c0e33e":"code","0a361729":"code","233bddfa":"code","5a7bf010":"code","1872a8bc":"code","20505054":"code","4ff2fb83":"code","9482b73e":"code","b95ca59e":"code","c822e4d3":"code","74458770":"code","121ad550":"code","e088e9a2":"code","ed8a391f":"code","20519252":"code","0fc4fed6":"code","b231d648":"code","5ad6ca5c":"code","99ded0f9":"code","1b7fff30":"code","fc19a7c0":"code","5de155a7":"code","a70ab546":"code","fd74fdc5":"markdown","147e5a98":"markdown","d8cd46d7":"markdown","f986b553":"markdown","7429ec64":"markdown","9cd61ec4":"markdown","fef557a7":"markdown","f9536319":"markdown","2b9979f3":"markdown","f8cdf917":"markdown","3531cae6":"markdown","269f9261":"markdown","df8b8b6d":"markdown","173f5591":"markdown","43947869":"markdown","cb4ea309":"markdown","bf9069f4":"markdown","edb354b1":"markdown","a7359f7f":"markdown","56dc948c":"markdown","5a12c870":"markdown","fee48ac5":"markdown","1dff20d7":"markdown","0c5dde73":"markdown","3c1703bc":"markdown"},"source":{"97868470":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt","92925d6b":"df_train=pd.read_csv(\"\/kaggle\/input\/term-deposit-prediction-data-set\/train.csv\")\ndf_test=pd.read_csv(\"\/kaggle\/input\/term-deposit-prediction-data-set\/test.csv\")","1f843ad0":"df_train.head()","8e4c77d2":"df_test.head()","1789d652":"df_train.shape\n","58d3c4ef":"df_test.shape","790650e0":"df_train.info()","c42cd2aa":"correlations=df_train.corr()\nplt.figure(figsize=(12,8))\nsns.heatmap(data=correlations,square=True,annot = True,cmap=\"viridis\")\n\nplt.yticks(rotation=0)\nplt.xticks(rotation=90)","20c25608":"df_train.describe()","a5c31aa7":"df_train['subscribed'].value_counts()","67a8168f":"df_test.isnull().sum()","17d68d62":"df_test.describe()","d7f04980":"df_test.isnull().sum()","338a7477":"df_train.head()","299793d3":"category_variables=['job','marital','education','default','housing','loan','contact','month','poutcome']\ndf_train_encoded=pd.get_dummies(df_train[category_variables])\ndf_train_encoded.shape","bf7a1d1d":"df_train_encoded.head()","d81aa77c":"df_train_encoded.info()","9dbce936":"df=df_train.drop(['job','marital','education','default','housing','loan','contact','month','poutcome'],axis=1)\ndf=pd.concat([df,df_train_encoded],axis=1)","00defd66":"df.head()","114709eb":"df.dtypes","10b662c5":"df_test.head()","45e7a037":"category_variables=['job','marital','education','default','housing','loan','contact','month','poutcome']\ndf_test_encoded=pd.get_dummies(df_test[category_variables])\ndf_test_encoded.shape","6696131e":"df_test_encoded.info()","9772b374":"df1_test=df_test.drop(['job','marital','education','default','housing','loan','contact','month','poutcome'],axis=1)\ndf1_test=pd.concat([df1_test,df_test_encoded],axis=1)","48db94ed":"df1_test.head()","6bed65f3":"from sklearn.preprocessing import LabelEncoder\nlabel_encoder = LabelEncoder()\ndf['subscribed'] = label_encoder.fit_transform(df['subscribed'])","aa651cc6":"df['subscribed'].value_counts()","1ac0c7bd":"sns.countplot(x='subscribed',data=df,palette='husl')","019b27f6":"count_no_subscribed=len(df[df['subscribed']==0])\ncount_subscribed=len(df[df['subscribed']==1])\npct_no_subscribed=(count_no_subscribed\/(count_no_subscribed+count_subscribed))*100\npct_subscribed=(count_subscribed\/(count_no_subscribed+count_subscribed))*100\nprint(\"percentage of no subscription is \",pct_no_subscribed)\nprint(\"percentage of subscription \",pct_subscribed)","a1623813":"X=df.drop(['ID','subscribed'],axis=1)\ny=df['subscribed']","943e8ac7":"pip install --upgrade scikit-learn","603b1748":"from imblearn.over_sampling import SMOTE\nfrom sklearn.model_selection import train_test_split","fb03d216":"X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.3, random_state=0)\ncolumns = X_train.columns","1f0fe1cd":"y_train","51aec9bd":"# Fit the SMOTE\nos = SMOTE(random_state=0)\nos_data_X,os_data_y=os.fit_sample(X_train, y_train)","d5fbc2c0":"os_data_X = pd.DataFrame(data=os_data_X,columns=columns )\nos_data_y= pd.DataFrame(data=os_data_y,columns=['subscribed'])","549f67d4":"# we can Check the numbers of our data\nprint(\"length of oversampled data is \",len(os_data_X))\nprint(\"Number of no subscription in oversampled data\",len(os_data_y[os_data_y['subscribed']==0]))\nprint(\"Number of subscription\",len(os_data_y[os_data_y['subscribed']==1]))\nprint(\"Proportion of no subscription data in oversampled data is \",len(os_data_y[os_data_y['subscribed']==0])\/len(os_data_X))\nprint(\"Proportion of subscription data in oversampled data is \",len(os_data_y[os_data_y['subscribed']==1])\/len(os_data_X))","c20a5b02":"df.columns.values","a5286c57":"data_final_vars=df.columns.values.tolist()\ny=['subscribed']\nX=[i for i in data_final_vars if i not in y]\n\nfrom sklearn.feature_selection import RFE\nfrom sklearn.linear_model import LogisticRegression\n\nlogreg=LogisticRegression()\n\nrfe=RFE(logreg,20)\nrfe=rfe.fit(os_data_X,os_data_y.values.ravel())\nprint(rfe.support_)\nprint(rfe.ranking_)","d1856f3c":"cols=['previous','job_admin.', 'job_blue-collar','job_entrepreneur', 'job_housemaid', 'job_management','job_retired', 'job_self-employed', 'job_services', 'job_student','job_technician', 'job_unemployed', 'job_unknown','marital_divorced', 'marital_married', 'marital_single','education_primary', 'education_secondary', 'default_no', 'default_yes']\nX=os_data_X[cols]\ny=os_data_y['subscribed']\n","65710581":"X.shape","2775f324":"X.head()","59c0e33e":"y.shape","0a361729":"import statsmodels.api as sm\nlogit_model=sm.Logit(y,X)\nresult=logit_model.fit()\nprint(result.summary2())","233bddfa":"# Final Columns for model building\nX.columns.values","5a7bf010":"# Select Variables in test data\ncol_list=['previous', 'job_admin.', 'job_blue-collar', 'job_entrepreneur',\n       'job_housemaid', 'job_management', 'job_retired',\n       'job_self-employed', 'job_services', 'job_student',\n       'job_technician', 'job_unemployed', 'job_unknown',\n       'marital_divorced', 'marital_married', 'marital_single',\n       'education_primary', 'education_secondary', 'default_no',\n       'default_yes']\ndf1_test_final=df1_test[col_list]\ndf1_test_final.head()","1872a8bc":"df1_test_final.shape","20505054":"from sklearn.model_selection import train_test_split\nX_train,X_val,y_train,y_val=train_test_split(X,y,test_size=0.3,random_state=21)\nX_test=df1_test_final","4ff2fb83":"X_train.shape,X_val.shape,y_train.shape,y_val.shape,X_test.shape","9482b73e":"from sklearn.linear_model import LogisticRegression\nlogreg=LogisticRegression()","b95ca59e":"logreg.fit(X_train,y_train)","c822e4d3":"y_log_pred=logreg.predict(X_val)","74458770":"from sklearn import metrics\n\nprint('Accuracy of logistic regression classifier on validation set:')\nprint(metrics.accuracy_score(y_val,y_log_pred))","121ad550":"from sklearn.metrics import classification_report,confusion_matrix\nprint(confusion_matrix(y_val,y_log_pred))","e088e9a2":"print(classification_report(y_val,y_log_pred))","ed8a391f":"from sklearn.metrics import roc_auc_score\nfrom sklearn.metrics import roc_curve\nlogit_roc_auc = roc_auc_score(y_val, logreg.predict(X_val))\nfpr, tpr, thresholds = roc_curve(y_val, logreg.predict_proba(X_val)[:,1])\nplt.figure(figsize=(12,8))\nplt.plot(fpr, tpr, label='Logistic Regression (area = %0.2f)' % logit_roc_auc)\nplt.plot([0, 1], [0, 1],'r--')\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.05])\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.title('Receiver operating characteristic')\nplt.legend(loc=\"lower right\")\nplt.savefig('Log_ROC')\nplt.show()","20519252":"y_pred_final=logreg.predict(X_test)","0fc4fed6":"y_pred_final = pd.DataFrame(y_pred_final, columns = ['Subscribed_Predicted'])","b231d648":"y_pred_final.head()","5ad6ca5c":"pred_data=pd.concat([df_test,y_pred_final],axis=1)","99ded0f9":"pred_data['Subscribed_Predicted']=pred_data['Subscribed_Predicted'].replace({0: 'no', 1: 'yes'})","1b7fff30":"pred_data.head()","fc19a7c0":"pred_data['Subscribed_Predicted'].value_counts()","5de155a7":"sns.countplot(x='Subscribed_Predicted',data=pred_data,palette='husl')","a70ab546":"pred_data.to_csv(\"Term deposit prediction.csv\")","fd74fdc5":"#### Replace categorical variables with dummy variables in test data","147e5a98":"#### Replace categorical variables with dummy variables in training data","d8cd46d7":"#### Encoding categorical variables in training data","f986b553":"The RFE has helped us to select the following features:'previous', 'subscribed', 'job_admin.', 'job_blue-collar','job_entrepreneur', 'job_housemaid', 'job_management','job_retired', 'job_self-employed', 'job_services', 'job_student','job_technician', 'job_unemployed', 'job_unknown','marital_divorced', 'marital_married', 'marital_single','education_primary', 'education_secondary', 'default_no', 'default_yes'","7429ec64":"##### The p-values for all of the variables are smaller than 0.05. Hence we can consider these variables for our model.","9cd61ec4":"#### Summarize train data","fef557a7":"#### Feature selection using RFE","f9536319":"#### Validate the Logistic Regression model","2b9979f3":"#### Checking missing values in test data","f8cdf917":"Here our dependent variable classes are imbalanced, and the ratio of no-subscription to subscription instances is 88:12. So we have to balance the classes.","3531cae6":"#### Perform label encoding on the target column in the train","269f9261":"####  Building a logistic regression model","df8b8b6d":"#### Checking dependent variable classes","173f5591":"#### Export Result","43947869":"#### Implementing the model","cb4ea309":"#### Import libraries","bf9069f4":"#### Shapes of the datasets","edb354b1":"#### Correlations between continous variables in train data","a7359f7f":"#### Encoding categorical variables in testing data","56dc948c":"#### ROC Curve","5a12c870":"#### Import Dataset","fee48ac5":"#### Predicting the test dataset","1dff20d7":"#### Summarize test data","0c5dde73":"#### Perform SMOTE to balance the dependent variable classes","3c1703bc":"#### Split our data for training, validation and testing"}}