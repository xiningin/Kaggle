{"cell_type":{"93f3fcc9":"code","fc7f2835":"code","7ff33580":"code","f16ba72d":"code","eada6b6d":"code","f08809f5":"code","033ce652":"code","6a31a677":"code","55df7873":"code","e53d1204":"code","bbcf618f":"code","f5ab83a2":"code","1ad12b80":"code","fbd7e145":"code","a6c70dc7":"code","ef96c96a":"code","45fd5941":"code","15f8f771":"code","9407d0d1":"code","f497c316":"code","310054f1":"code","6e0f664f":"code","726fd762":"code","b245b492":"code","19b43ffb":"markdown","29e708cb":"markdown","89eed007":"markdown","b6a9fe63":"markdown","4e9c3db9":"markdown","3b4b434e":"markdown","bdc5c0f9":"markdown","1df9828b":"markdown","8eca00d9":"markdown","cdb661fe":"markdown","ad2b6ebc":"markdown"},"source":{"93f3fcc9":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","fc7f2835":"train = pd.read_csv('\/kaggle\/input\/jane-street-market-prediction\/train.csv')\n\ntrain = train.astype({col: np.float32 for col in train.select_dtypes('float64').columns})\ntrain = train.astype({col: np.int32 for col in train.select_dtypes('int64').columns})","7ff33580":"class TrainData():\n    \n    def __init__(self, df, action_threshold=0.0):\n        self.train = df.copy()\n        self.action_threshold = action_threshold\n        \n    \n    def add_weight_resp(self):\n        \"\"\"Calculates weight * resp for new column weight_resp.\"\"\"\n        self.train['weight_resp'] = self.train['weight'] * self.train['resp']\n        self.train['weight_resp'] = self.train['weight_resp'].astype(np.float32)\n        \n    def add_action(self):\n        \"\"\"Adds action column if weight_resp > action_threshold.\"\"\"\n        self.train['action'] = np.where(\n            self.train['weight_resp'] > self.action_threshold, 1, 0)\n        self.train['action'] = self.train['action'].astype(np.int32)","f16ba72d":"act_thresh = 0.1\n\ntd = TrainData(df=train, action_threshold=act_thresh)\ntd.add_weight_resp()\ntd.add_action()","eada6b6d":"sns.distplot(td.train['weight_resp'], rug=False, bins=100)\nplt.title('Distribution: weight * resp')","f08809f5":"plt.hist(td.train['action'])\nplt.title(f'Distribution: action\\nwith threshold = {act_thresh}')","033ce652":"fig = plt.figure(figsize=(24, 16))\nsns.scatterplot(x='weight', y='resp', hue='weight_resp', data=td.train, palette='icefire')\nplt.title('weight vs. resp', fontsize=20)","6a31a677":"fig = plt.figure(figsize=(24, 16))\nsns.scatterplot(x='weight', y='resp', hue='action', data=td.train, palette='icefire')\nplt.title('weight vs. resp', fontsize=20)","55df7873":"sns.pairplot(td.train.iloc[:, 7:12], hue='feature_0')","e53d1204":"sns.pairplot(pd.concat([td.train.iloc[:, 8:12], td.train.loc[:, 'action']], axis=1), hue='action')","bbcf618f":"for val in td.train['feature_0'].unique():\n    subdf = td.train.loc[td.train['feature_0'] == val]\n    print(f\"***\\nfeature_0 = {val}\\n{subdf['action'].value_counts()}\\n\")","f5ab83a2":"import networkx as nx\nimport community\nimport matplotlib.cm as cm\nfrom matplotlib.colors import Normalize","1ad12b80":"feats = pd.read_csv(\n    '\/kaggle\/input\/jane-street-market-prediction\/features.csv')\nfeats = feats.astype({col: np.int32 for col in feats.select_dtypes('bool').columns})","fbd7e145":"class FeatureGraph():\n    \n    def __init__(self, df):\n        self.G = nx.Graph()\n        self.data = df.copy()\n        self.partition = None\n        \n        \n    def add_feature_nodes(self):\n        \"\"\"Adds nodes for features.\"\"\"\n        for feat in self.data['feature'].unique():\n            self.G.add_nodes_from([feat], color='green')\n            \n            \n    def add_tag_nodes(self):\n        \"\"\"Adds nodes for tags.\"\"\"\n        for col in self.data.columns:\n            if 'tag' in col:\n                self.G.add_nodes_from([col], color='red')\n                \n                \n    def add_edges(self):\n        \"\"\"Adds edges between features and tags if value == 1.\"\"\"\n        for row in range(self.data.shape[0]):\n            source_node = self.data.loc[row, 'feature']\n\n            for col in range(1, self.data.shape[1]):\n                target_node = self.data.columns[col]\n                if self.data.iloc[row, col] == 1:\n                    self.G.add_edge(source_node, target_node)\n\n    \n    def create_graph(self):\n        \"\"\"Creates graph object.\"\"\"\n        self.add_feature_nodes()\n        self.add_tag_nodes()\n        self.add_edges()\n        \n        \n    def create_partition(self):\n        \"\"\"Partition the graph and adds partition attribute to each node.\"\"\"\n        self.partition = community.best_partition(self.G)\n        nx.set_node_attributes(self.G, self.partition, 'partition')","a6c70dc7":"fg = FeatureGraph(df=feats)\nfg.create_graph()","ef96c96a":"fig = plt.figure(figsize=(24, 16))\npos = nx.spring_layout(fg.G)\ncol = nx.get_node_attributes(fg.G, 'color').values()\nnx.draw(fg.G, pos=pos, font_size=8, with_labels=True, node_size=100, node_color=col)","45fd5941":"fg.create_partition()\n\ncmap = cm.viridis\nnorm = Normalize(vmin=min(fg.partition.values()), \n                 vmax=max(fg.partition.values()))\n\npart_list = []\nfor k in fg.partition.keys():\n    part_list.append(fg.partition[k])\n\npart_set = set(part_list)\n\npartition_dict = {}\nfor i in part_set:\n    partition_dict.update({i: []})\n\npartition_colors = []\n\nfor node in fg.G.nodes(data=True):\n    for k in partition_dict.keys():\n        if node[1]['partition'] == k:\n            partition_colors.append(cmap(norm(k)))\n            if 'feature' in node[0]:\n                partition_dict[k].append(node[0])","15f8f771":"fig = plt.figure(figsize=(24, 16))\npos = nx.spring_layout(fg.G)\nnx.draw(fg.G, pos=pos, font_size=8, with_labels=True, node_size=100, node_color=partition_colors)","9407d0d1":"partition_dict","f497c316":"l_list = []\n\nfor k, v in partition_dict.items():\n    l_list.append(len(v))","310054f1":"plot_list = partition_dict[np.argsort(l_list)[1]] + ['action']\nsns.pairplot(td.train.loc[:, plot_list], hue='action')","6e0f664f":"plot_list = partition_dict[np.argsort(l_list)[2]] + ['action']\nsns.pairplot(td.train.loc[:, plot_list], hue='action')","726fd762":"# plot_list = partition_dict[np.argsort(l_list)[3]] + ['action']\n# sns.pairplot(td.train.loc[:, plot_list], hue='action')","b245b492":"# plot_list = partition_dict[np.argsort(l_list)[4]] + ['action']\n# sns.pairplot(td.train.loc[:, plot_list], hue='action')","19b43ffb":"## Pairplots by Partition\nNow, let's take a look at the pairplots for a few of the smaller partitions, colored by `action`.","29e708cb":"I find it very interesting that the positive `action` class appears to be centered within each scatter plot, and that `feature_0` value of 1 corresponds with this with a bit of a skew. Makes me wonder whether the former is a subset of the latter...","89eed007":"# Jane Street Market Prediction EDA\n## Action Threshold and Feature Communities\n\nSince the training set does not provide the label `action`, it is left up to us to determine how that label is applied to the data used to train our models. In this notebook, we set an arbitrary initial `action_threshold` value for `weight * resp` that will determine the positive `action` class. Then, we'll determine raw feature similarity by creating a graph (nodes and edges) using the feature and tags. Finally, we'll group the features according to the community structure exhibited in the graph and take a look at pairplots of the groups with our `action` label.\n\nTODO: determine methods that will optimize the `action_threshold` value for creating the positive class.","b6a9fe63":"Nope.","4e9c3db9":"## Tags\nEach of the features in our training set have a set of boolean tags associated with them. These are specified in `features.csv`. In order to find some similarities among the features, let's create a bipartite graph where the nodes are the features and tags, and where an edge exists between a feature and a tag if the tag value is `True`. Then, let's apply the `best_partition` method to better see the community structure.","3b4b434e":"## Plots\nLet's take a look at a few distributions with the arbitrarily set `action_threshold`...","bdc5c0f9":"The distribution of our dependent variable above shows a significant class imbalance. Oversampling may be a good idea here.\n\nThe following scatterplots show `weight` vs. `resp`. The first one is colored by `weight * resp`. The second one is colored by `action` and was used to come up with the `action_threshold` value. Note the outliers.","1df9828b":"Below, we have the features colored in green and the tags colored in red. We definitely see some community structure within the network.","8eca00d9":"## Training Data\nFor initial analysis, we are going to arbitrarily set the `action_threshold` parameter in our `TrainData` object. \n\nThe `add_action` method will add the `action` column with a value of 1 if `weight * resp > action_threshold`, else 0.","cdb661fe":"Note that node `feature_0` has no edges. \n\nNow, let's color the nodes according to the communities determined by the `best_partition` method. We will also create `partition_dict` to look at scatter plots for each partition.","ad2b6ebc":"## Comparing `feature_0` to `action`\nHere, I'm using Seaborn's pairplot to produce bivariate scatterplots for a handful of features. In particular, I was curious to see how `feature_0` - a feature with only two values - compared to the `action` variable derived from our `action_threshold`."}}