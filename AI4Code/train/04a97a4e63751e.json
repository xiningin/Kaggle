{"cell_type":{"a3166028":"code","5dd8ac3f":"code","d99155a1":"code","474f4700":"code","b3338974":"code","4bc10f44":"code","9d1d892a":"code","b0d6082b":"code","b5cda318":"code","4e0397e7":"code","90a4b085":"markdown","72dc39c4":"markdown","f63a32f8":"markdown","df485a17":"markdown","d0de2436":"markdown","beee1f1e":"markdown","8415d60e":"markdown"},"source":{"a3166028":"!pip install FlowIO==0.9.3","5dd8ac3f":"%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nimport seaborn as sns\nplt.rcParams[\"figure.figsize\"] = (15, 10)\nplt.rcParams[\"figure.dpi\"] = 125\nplt.rcParams[\"font.size\"] = 14\nplt.rcParams['font.family'] = ['sans-serif']\nplt.rcParams['font.sans-serif'] = ['DejaVu Sans']\nplt.style.use('ggplot')\nsns.set_style(\"whitegrid\", {'axes.grid': False})\nfrom itertools import cycle\nprop_cycle = plt.rcParams['axes.prop_cycle']\ncolors = prop_cycle.by_key()['color']","d99155a1":"from pathlib import Path\nimport numpy as np\nimport pandas as pd\nimport doctest\nimport copy\nfrom skimage.io import imread\nimport flowio\n\n# tests help notebooks stay managable\ndef autotest(func):\n    globs = copy.copy(globals())\n    globs.update({func.__name__: func})\n    doctest.run_docstring_examples(\n        func, globs, verbose=True, name=func.__name__)\n    return func\n\n# extra arguments accepted for backwards-compatibility (with the fcm-0.9.1 package)\ndef loadFCS(filename, *args, **kwargs):\n    f = flowio.FlowData(filename)\n    events = np.reshape(f.events, (-1, f.channel_count))\n    channels = []\n    for i in range(1, f.channel_count+1):\n        key = str(i)\n        if 'PnS' in f.channels[key] and f.channels[key]['PnS'] != u' ':\n            channels.append(f.channels[key]['PnS'])\n        elif 'PnN' in f.channels[key] and f.channels[key]['PnN'] != u' ':\n            channels.append(f.channels[key]['PnN'])\n        else:\n            channels.append('None')\n    return FcmData(events, channels)\n\nclass FcmData(object):\n    def __init__(self, events, channels):\n        self.channels = channels\n        self.events = events\n        self.shape = events.shape\n\n    def __array__(self):\n        return self.events","474f4700":"nk_data = Path('..') \/ 'input' \/ 'nk_cell_dataset'","b3338974":"nk_data_df = pd.DataFrame({'path': list(nk_data.glob('*\/*.fcs'))})\nnk_data_df['gated'] = nk_data_df['path'].map(lambda x: x.parent.stem)\nnk_data_df.sample(3)","4bc10f44":"# look at the measured markers\nfirst_fcs = loadFCS(str(nk_data_df['path'].iloc[0]), transform=None, auto_comp=False)\nprint(first_fcs.channels)","9d1d892a":"fig, ax1 = plt.subplots(1, 1, figsize=(12, 3))\nax1.imshow(first_fcs.events.T)\nax1.set_aspect(1000)","b0d6082b":"from sklearn.preprocessing import RobustScaler\nchan_norm = RobustScaler()\nfig, ax1 = plt.subplots(1, 1, figsize=(30, 30))\nax1.imshow(chan_norm.fit_transform(first_fcs.events).T, cmap='RdBu', vmin=-2, vmax=2)\nax1.set_aspect(1000)\nax1.set_title('Normalized Events')\nax1.set_yticks(range(len(first_fcs.channels)))\nax1.set_yticklabels(first_fcs.channels);","b5cda318":"fig, ax1 = plt.subplots(1, 1, figsize=(20, 15))\nax1.plot(chan_norm.fit_transform(first_fcs.events))\nax1.legend(first_fcs.channels)","4e0397e7":"!ls -lR ..\/input | grep csv","90a4b085":"## Visualize one file","72dc39c4":"# Overview\nThe notebooks aims to load and peruse the data used to train the [CellCNN paper](https:\/\/www.nature.com\/articles\/ncomms14825) and [code](https:\/\/github.com\/eiriniar\/CellCnn)\n- https:\/\/www.nature.com\/articles\/ncomms14825\n- https:\/\/github.com\/eiriniar\/CellCnn","f63a32f8":"# Setup\nSetup the code, libraries and imports","df485a17":"# Load Data","d0de2436":"# Extract Groups","beee1f1e":"# Build Models","8415d60e":"# To be continued..."}}