{"cell_type":{"cb5b3b44":"code","d2aa7b4f":"code","8f31ebd1":"code","77ca53f3":"code","0c7394c3":"code","3c7d8638":"code","9a697201":"code","b231a740":"code","8e0e911d":"code","fabb3262":"code","3cff625c":"code","12b98d4c":"code","1331ae6a":"code","0b4088d1":"code","8363a79c":"code","f99ee040":"code","0131538f":"code","44e0f01d":"code","ee4de5fb":"code","09606dcb":"code","5efd09dd":"code","e86a460e":"code","cf8d9a9e":"code","fb045771":"code","645118a1":"code","d5e607bc":"code","8b63c391":"code","5fb97591":"code","4b85e6ad":"code","35eb2818":"code","1c888a73":"code","ef9e62c2":"markdown","3b1c9f4d":"markdown","197bba8f":"markdown","1ffa438e":"markdown","9851bce5":"markdown","ed578240":"markdown","492e2b08":"markdown","b76cbaae":"markdown","611b9f50":"markdown","d8168500":"markdown","8bc7d149":"markdown","0ed450a1":"markdown","78e10c48":"markdown","225e411f":"markdown","08f068b2":"markdown"},"source":{"cb5b3b44":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom matplotlib import dates\nimport matplotlib.pyplot as plt\nimport networkx as nx\nfrom datetime import datetime\nfrom tensorflow import keras\nimport math as math\nfrom sklearn.metrics import mean_squared_error\nplt.style.use('seaborn')\n\n        \nlux = (49.61167 , 6.13)\nhighway = ['A1', 'A3', 'A4', 'A6', 'A7', 'A13', 'B40']        \ndirectory = '\/kaggle\/input\/motorway-traffic-in-luxembourg\/'\nfiles=['datexDataA1.csv','datexDataA3.csv','datexDataA4.csv','datexDataA6.csv','datexDataA7.csv','datexDataA13.csv','datexDataB40.csv']","d2aa7b4f":"# Describe Data\ndef describeData(data):\n    print(\"shape = {}\".format(data.shape))\n    description = data.describe().T\n    description[\"isNull\"] = data.isnull().sum()\n    print(description)\n# root mean squared error or rmse\ndef measure_rmse(actual, predicted):\n    return math.sqrt(mean_squared_error(actual, predicted))\n\n# filter data     \ndef getFilteredData(data,idCamera,indexMin='2000-01-01 00:00:00+0000',indexMax='2030-01-01 00:00:00+0000'):\n    result = data[(data.index>indexMin) ]\n    result = result[(result.index<indexMax)]\n    result = result[(result['id'] == idCamera)].fillna(method = 'ffill')\n    return result\n\ndef getFilteredDataByHighway(data,road,direction='outboundFromTown',indexMin='2000-01-01 00:00:00+0000',indexMax='2030-01-01 00:00:00+0000'):\n    result = data[(data.index>indexMin) ]\n    result = result[(result.index<indexMax)]\n    result = result[(result['direction'] == direction)]\n    result = result[(result['road'] == road)].fillna(method = 'ffill')\n    return result\n\n# Get Previous Camera Dict\ndef getPreviousCamDict(camera):\n    prev_cam = {}\n    for road in camera['road'].unique():\n        fromLux = camera.loc[(camera['road']==road)&(camera['direction']=='outboundFromTown')].copy()\n        toLux = camera.loc[(camera['road']==road)&(camera['direction']=='inboundTowardsTown')].copy()\n        fromLux.sort_values(by=['direction_dist'],inplace=True,ascending = True)\n        toLux.sort_values(by=['direction_dist'],inplace=True,ascending = False)\n        \n        toLux['previd']=toLux['id'].shift(1)\n        toLux.dropna(inplace=True)\n        fromLux['previd']=fromLux['id'].shift(1)\n        fromLux.dropna(inplace=True)\n        \n        for lux in [fromLux,toLux]:\n            if lux.shape[0]>0:\n                for index, row in lux.iterrows():\n                    prev_cam[row['id']] = row['previd']  \n    return prev_cam    \n# Graph\ndef getGraph(cameras,direction = \"outboundFromTown\"):\n    G = nx.DiGraph(label=\"TRAFFIC\")\n    dict_previous_cam = getPreviousCamDict(cameras)\n    for i, rowi in cameras.loc[cameras[\"direction\"]==direction].iterrows():\n        G.add_node(rowi['id'],key=rowi['id'],label=\"id\",road=rowi['road'],latitude=rowi['latitude'],longitude=rowi['longitude'])\n        previous = dict_previous_cam.get(rowi['id'])\n        if previous != None:\n            G.add_edge(previous,rowi['id'])            \n    return G\n\ndef printMap(G,title=\"\"):\n    colors=[]\n    pos={}\n    pos2={}\n    labels={}\n    dict_colors = {'A1':'orange', 'A3':'blue', 'A4':'red', 'A6':'green', 'A7':'black', 'A13':'yellow', 'B40':'cyan'}    \n    fig, ax = plt.subplots(figsize=(12,12), dpi=200)  \n    # graph    \n    for e in G:\n        pos[e]=(G.nodes[e]['longitude'],G.nodes[e]['latitude'])\n        pos2[e]=(G.nodes[e]['longitude']+0.010,G.nodes[e]['latitude']+0.001)\n        new = e.split(\".\")\n        labels[e] = new[2]\n        colors.append(dict_colors.get(G.nodes[e]['road']))\n    # nodes\n    nx.draw_networkx_nodes(G, pos,node_size=50,node_color=colors)\n    nx.draw_networkx_edges(G, pos, node_size=50, arrowstyle='->',arrowsize=20)\n    # labels\n    nx.draw_networkx_labels(G, pos2, labels= labels,font_size=10)\n    markers = [plt.Line2D([0,0],[0,0],color=color, marker='o', linestyle='') for color in dict_colors.values()]\n    plt.legend(markers, dict_colors.keys(), numpoints=1,loc='upper left') \n    plt.title(title)\n    plt.show()\n    \ndef plot_long_serie(data,title='',label='',xlabel='Time',ylabel='', dpi=100):\n    days = dates.DayLocator()\n    dfmt = dates.DateFormatter('%b %d')\n    fig, ax = plt.subplots(figsize=(16,9), dpi=dpi)  \n    ax.set_title(title)\n    ax.plot(data.index.values, data.values, label=label,linewidth=1)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.legend()\n    ax.xaxis.set_major_locator(days)\n    ax.xaxis.set_major_formatter(dfmt)\n    ax.xaxis.set_tick_params(which='major',labelsize=7)\n    ax.grid(True)\n    plt.show()\n\ndef plot_day_traffic(data0,data1,titles,dpi=100):    \n    fig, axes = plt.subplots(2, 7, figsize=(16,9),dpi=dpi)    \n    yLimite=data0.max()*1.1\n    for i, a in zip(range(7), axes[0].ravel()):\n        df = data0[data0.index.dayofweek==i]\n        df.index = [df.index.time,df.index.date]\n        df = df.unstack().interpolate()\n        for column in df:\n            a.plot(df.index.map(lambda x: (x.minute+x.hour*60)\/60 ), df[column], marker='', linewidth=1, alpha=0.9) \n            a.set_ylim(0,yLimite)\n            a.set_title(titles[i])\n            a.set_xticks(np.arange(0,25,3))\n    yLimite=data1.max()*1.1             \n    for i, a in zip(range(7), axes[1].ravel()):\n        df = data1[data1.index.dayofweek==i]\n        df.index = [df.index.time,df.index.date]\n        df = df.unstack().interpolate()\n        for column in df:\n            a.plot(df.index.map(lambda x: (x.minute+x.hour*60)\/60 ), df[column], marker='', linewidth=1, alpha=0.9)                     \n            a.set_ylim(0,yLimite)\n            a.set_xticks(np.arange(0,25,3))\n    plt.show()\n    \n\n# Draw multiple plots \ndef plot_mult(datas,labels,xlabel,ylabel,dpi=100):\n    days = dates.DayLocator()\n    hours = dates.HourLocator(byhour=[0,6,12,18])\n    dfmt = dates.DateFormatter('%b %d')\n    fig, ax = plt.subplots(figsize=(16,9), dpi=dpi)  \n    \n    for i, data in enumerate(datas):\n        plabel = labels[i]\n        ax.plot(data.index.values, data.values, label=plabel,linewidth=1)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.legend()\n    ax.xaxis.set_major_locator(days)\n    ax.xaxis.set_major_formatter(dfmt)\n    ax.xaxis.set_minor_locator(hours)\n    ax.xaxis.set_minor_formatter(dates.DateFormatter('%H'))\n    ax.xaxis.set_tick_params(which='major', pad=15,labelsize=7)\n    ax.xaxis.set_tick_params(which='minor', labelsize=4)\n    ax.grid(True)\n    plt.show()\n","8f31ebd1":"frames=[]\nfor file in files:\n    #print(file + ' start')\n    df = pd.read_csv(directory+file, parse_dates = False, header = None,sep=';')\n    df.columns=['id','time','latitude','longitude','direction','road','trafficStatus','avgVehicleSpeed','vehicleFlowRate','trafficConcentration']\n    df.loc[df['time'].str.len()<25,'time']=pd.NaT\n    df['time'] = pd.to_datetime(df['time'],errors='coerce',utc=False)  \n    df['time'] = df['time'].fillna(method = 'ffill')\n    #df.index = df['time','id']\n    df.set_index(['time','id'],drop=False,inplace=True)\n    df=df[~df.index.duplicated()]\n    df.set_index(['time'],drop=False,inplace=True)\n    df['dayofweek'] = df.index.dayofweek\n    df['day'] = df.index.day\n    df['hour'] = df.index.hour\n    new = df[\"id\"].str.split(\".\", expand = True) \n    df['highway']=new[0]\n    df['direction_code']=new[1]\n    df['direction_dist']=pd.to_numeric(new[2])    \n    # df=df[~camera.index.duplicated()]\n    frames.append(df)\n    print(file + ': end loading {} rows '.format(df.shape[0]))\ndata = pd.concat(frames)\n\ndata.dropna(inplace=True)\n# Build camera dataframe\ncamera = data[['id','latitude','longitude','direction_dist','direction_code','road','direction']]\ncamera.index = camera['id']\ncamera=camera[~camera.index.duplicated()]\ndel(new,frames,file,df)\ndata.head(5)","77ca53f3":"print(\"min index is\",data.index.min())\nprint(\"max index is\",data.index.max())\nnRow, nCol = data.shape\nprint(f'There are {nRow} rows and {nCol} columns in the dataset')","0c7394c3":"nRow, nCol = camera.shape\nprint(f'There are {nRow} rows and {nCol} columns in camera dataset')\ncamera.head(5)","3c7d8638":"# print the cameras map\nGFrom = getGraph(camera,direction=\"outboundFromTown\")\nGTo = getGraph(camera,direction=\"inboundTowardsTown\")\n\nprintMap(GTo,title=\"Cameras - direction = to Luxembourg\")","9a697201":"printMap(GFrom,title=\"Cameras - direction = From Luxembourg\")","b231a740":"road = 'A3'\n  \nfromLuxCam = 'A3.VM.11397'\ntoLuxCam = 'A3.MV.11397'\nfromDate = '2019-11-25 00:00:00+0000'\ntoDate = '2019-12-23 00:00:00+0000'\n\nfromLux = getFilteredData(data,fromLuxCam,fromDate,toDate)\ntoLux = getFilteredData(data,toLuxCam,fromDate,toDate)\n\nfromLux_rolling_avg = fromLux.avgVehicleSpeed.rolling(window=10,center=True).mean()\nfromLux_rolling_flow = fromLux.vehicleFlowRate.rolling(window=10,center=True).mean()\nfromLux_rolling_traf = fromLux.trafficConcentration.rolling(window=10,center=True).mean()\nfromLux_rolling_avg.dropna(inplace=True)\nfromLux_rolling_flow.dropna(inplace=True)\nfromLux_rolling_traf.dropna(inplace=True)\n\ntoLux_rolling_avg = toLux.avgVehicleSpeed.rolling(window=10,center=True).mean()\ntoLux_rolling_flow = toLux.vehicleFlowRate.rolling(window=10,center=True).mean()\ntoLux_rolling_traf = toLux.trafficConcentration.rolling(window=10,center=True).mean()\ntoLux_rolling_avg.dropna(inplace=True)\ntoLux_rolling_flow.dropna(inplace=True)\ntoLux_rolling_traf.dropna(inplace=True)","8e0e911d":"plot_long_serie(fromLux_rolling_avg,title='From LUX camera={}'.format(fromLuxCam),label='Average Vehicle Speed',xlabel='Date',ylabel='Speed')","fabb3262":"plot_long_serie(fromLux_rolling_flow,title='From LUX camera={}'.format(fromLuxCam),label='Vehicle Flow Rate',xlabel='Date',ylabel='Rate')","3cff625c":"plot_long_serie(fromLux_rolling_traf,title='From LUX camera={}'.format(fromLuxCam),label='Traffic Concentration',xlabel='Date',ylabel='Concentration')\n","12b98d4c":"plot_long_serie(toLux_rolling_avg,title='To LUX camera={}'.format(toLuxCam),label='Average Vehicle Speed',xlabel='Date',ylabel='Speed')","1331ae6a":"plot_long_serie(toLux_rolling_flow,title='To LUX camera={}'.format(toLuxCam),label='Vehicle Flow Rate',xlabel='Date',ylabel='Rate')","0b4088d1":"plot_long_serie(toLux_rolling_traf,title='To LUX camera={}'.format(toLuxCam),label='Traffic Concentration',xlabel='Date',ylabel='Concentration')","8363a79c":"titles=['Monday','Tueday','Wednesday','Thursday','Friday','Saturday','Sunday']\nplot_day_traffic(toLux_rolling_avg,fromLux_rolling_avg,titles)","f99ee040":"plot_day_traffic(toLux_rolling_flow,fromLux_rolling_flow,titles)","0131538f":"plot_day_traffic(toLux_rolling_traf,fromLux_rolling_traf,titles)","44e0f01d":"for direction in ['outboundFromTown','inboundTowardsTown']:\n    df = getFilteredDataByHighway(data,road,direction,fromDate,toDate)\n    cams = camera.loc[(camera['road']==road)&(camera['direction']==direction)].sort_values(by=['direction_dist'])['id'].values\n    datas=[]\n    datas2=[]\n    datas3=[]\n    labels=[]\n    for cam in cams:    \n        temp=df.loc[(df['id']==cam)&(df.index.dayofweek.isin([0,1,2,3,4]))].copy()\n        temp['minute']=temp.index.time\n        temp.avgVehicleSpeed = temp.avgVehicleSpeed.rolling(window=3,center=True).mean()\n        temp.vehicleFlowRate = temp.vehicleFlowRate.rolling(window=3,center=True).mean()\n        temp.trafficConcentration = temp.trafficConcentration.rolling(window=3,center=True).mean()\n        temp.dropna(inplace=True)\n        data1 = temp.groupby('minute').mean()[\"avgVehicleSpeed\"].copy()\n        data1.index = data1.index.map(lambda x : x.strftime(\"%H:%M:%S\"))\n        datas.append(data1)\n        data2 = temp.groupby('minute').mean()[\"vehicleFlowRate\"].copy()\n        data2.index = data2.index.map(lambda x : x.strftime(\"%H:%M:%S\"))\n        datas2.append(data2)\n        data3 = temp.groupby('minute').mean()[\"trafficConcentration\"].copy()\n        data3.index = data3.index.map(lambda x : x.strftime(\"%H:%M:%S\"))\n        datas3.append(data3)\n        labels.append(cam)\n        \n    plot_mult(datas,labels,'Date','avgVehicleSpeed')    \n    plot_mult(datas2,labels,'Date','vehicleFlowRate')     \n    plot_mult(datas3,labels,'Date','vehicleFlowRate') \n","ee4de5fb":"from sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import accuracy_score,precision_score, recall_score,f1_score,SCORERS\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.model_selection import train_test_split\nfrom timeit import default_timer as timer\nfrom sklearn.preprocessing import MinMaxScaler","09606dcb":"## Generate X and y\n######################################################\ndef generateDf(dataIn,cam,cam1):\n    df0 = getFilteredData(dataIn,cam)\n    df1 = getFilteredData(dataIn,cam1)\n    df1 = df1[['avgVehicleSpeed', 'vehicleFlowRate']]\n    col_rename = {}\n    for col in df1.columns:\n        col_rename[col]='prev_station_' + col\n    \n    df1.rename(columns=col_rename,inplace=True)\n    df = df0.join(df1)\n    df=df[['avgVehicleSpeed', 'vehicleFlowRate','trafficConcentration','dayofweek','hour','prev_station_avgVehicleSpeed', 'prev_station_vehicleFlowRate']].copy()\n    df['isWeekend'] = df['dayofweek'].map(lambda x : 0 if x < 5 else 1)\n\n    # Diff %\n    for i in range(1,backward+1):\n         df['avgDiff'+str(i)] = df['avgVehicleSpeed'].shift(i-1)\/ df['avgVehicleSpeed'].shift(i) - 1\n         df['avgDiff'+str(i)].replace([np.inf, -np.inf], np.nan,inplace=True)\n         df['avgDiff'+str(i)].fillna(method='bfill')\n         df['flowDiff'+str(i)] = df['vehicleFlowRate'].shift(i-1)\/ df['vehicleFlowRate'].shift(i) - 1\n         df['flowDiff'+str(i)].replace([np.inf, -np.inf], np.nan,inplace=True)\n         df['flowDiff'+str(i)].fillna(method='bfill')\n         df['flowTraffic'+str(i)] = df['trafficConcentration'].shift(i-1)\/ df['trafficConcentration'].shift(i) - 1\n         df['flowTraffic'+str(i)].replace([np.inf, -np.inf], np.nan,inplace=True)\n         df['flowTraffic'+str(i)].fillna(method='bfill')\n         \n    # EWL\n    df['EWMavg']=df['avgVehicleSpeed'].ewm(span=3, adjust=False).mean()\n    df['EWMflow']=df['vehicleFlowRate'].ewm(span=3, adjust=False).mean()\n    df['EWMtraffic']=df['trafficConcentration'].ewm(span=3, adjust=False).mean()\n    return df\n\ndef generateXYspeed20(df):    \n    df['ydiff'] = df['avgVehicleSpeed'].shift(forward)\/df['avgVehicleSpeed'] - 1    \n    df['y'] = 0\n    df.loc[df['ydiff']<-0.2,['y']]=1\n    df.dropna(inplace=True)\n    y = df['y']\n    X = df.drop(['y','ydiff'], axis=1)\n    return X , y\n\ndef generateXYspeedUnder(df):    \n    mean = df['avgVehicleSpeed'].mean()\n    df['ydiff'] = df['avgVehicleSpeed'].shift(forward)\n    df['y'] = 0\n    df.loc[df['ydiff']<mean*0.6,['y']]=1\n    df.dropna(inplace=True)\n    y = df['y']\n    X = df.drop(['y','ydiff'], axis=1)\n    return X , y\n\ndef generateXYspeedAndFlowUnder(df):    \n    means = df['avgVehicleSpeed'].mean()\n    meanf = df['vehicleFlowRate'].mean()\n    df['ydiffSpeed'] = df['avgVehicleSpeed'].shift(forward)\n    df['ydiffFlow'] = df['vehicleFlowRate'].shift(forward)\n    df['y'] = 0\n    df.loc[(df['ydiffSpeed']<means*0.6) &(df['ydiffFlow']<meanf*0.6),['y']]=1\n    df.dropna(inplace=True)\n    y = df['y']\n    X = df.drop(['y','ydiffSpeed','ydiffFlow'], axis=1)\n    return X , y\n\ndef print_metrics(y_true,y_pred):\n    conf_mx = confusion_matrix(y_true,y_pred)\n    print(conf_mx)\n    print (\" Accuracy    : \", accuracy_score(y_true,y_pred))\n    print (\" Precision   : \", precision_score(y_true,y_pred))\n    print (\" Sensitivity : \", recall_score(y_true,y_pred))\n\n\n","5efd09dd":"def train_model(X,y):\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42)\n    start = timer()\n    forest = RandomForestClassifier(max_depth = 10, n_estimators = 500, random_state = 42)\n    random_forest = forest.fit(X_train,y_train)\n    end = timer()\n    \n    y_pred = random_forest.predict(X_train)\n    print (\"------------------------------------------\")\n    print (\"TRAIN\")\n    print_metrics(y_train,y_pred)\n    importances = list(zip(random_forest.feature_importances_, X.columns))\n    importances.sort(reverse=True)\n    print([x for (_,x) in importances[0:5]])\n    y_pred = random_forest.predict(X_test)\n    print (\"------------------------------------------\")\n    print (\"TEST\")\n    print_metrics(y_test,y_pred)\n    \n    return random_forest ","e86a460e":"cam = 'A3.MV.10437'\ncam1= 'A3.MV.11397'   \n\nforward = -3\nbackward = 3    \ndf = generateDf(data,cam,cam1)\n\n\nprint ('camera :',cam)\nprint (\"---------------------------------------------------------------\")\nprint (\"Predict 20% speed drop\")\nX,y = generateXYspeed20(df)\nmodel = train_model(X,y)\n\nprint (\"---------------------------------------------------------------\")\nprint (\"Predict speed less than 60% of the average speed\")\nX,y = generateXYspeedUnder(df)\nmodel = train_model(X,y)\n\nprint (\"---------------------------------------------------------------\")\nprint (\"Predict speed anf flow less than 60% of the average\")\nX,y = generateXYspeedAndFlowUnder(df)\nmodel = train_model(X,y)\n","cf8d9a9e":"def train_model_and_get_metrics(X,y):\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42)\n    start = timer()\n    forest = RandomForestClassifier(max_depth = 10, n_estimators = 500, random_state = 42)\n    random_forest = forest.fit(X_train,y_train)\n    end = timer()\n    y_pred = random_forest.predict(X_test)\n    #print (\" Accuracy    : \", accuracy_score(y_true,y_pred))\n    #print (\" Precision   : \", precision_score(y_true,y_pred))\n    #print (\" Sensitivity : \", recall_score(y_true,y_pred))    \n    return [accuracy_score(y_test,y_pred), precision_score(y_test,y_pred),recall_score(y_test,y_pred)]","fb045771":"cams = camera.loc[(camera['road']=='A3')&(camera['direction']=='inboundTowardsTown')].sort_values(by=['direction_dist'],ascending=False)['id'].values\nprev_cam_dict = getPreviousCamDict(camera)\nspeed20=[]\nspeedUnder=[]\nspeedAndFlowUnder=[]\nfor cam in (cams[1:]):\n    cam1 = prev_cam_dict.get(cam)\n    print ('camera :',cam)\n    df = generateDf(data,cam,cam1)\n    X,y = generateXYspeed20(df)\n    speed20.append(train_model_and_get_metrics(X,y))\n    X,y = generateXYspeedUnder(df)\n    speedUnder.append(train_model_and_get_metrics(X,y))\n    X,y = generateXYspeedAndFlowUnder(df)\n    speedAndFlowUnder.append(train_model_and_get_metrics(X,y))\nspeed20df = pd.DataFrame(speed20, columns = ['Accurancy', 'precision','recall'])\nspeedUnderdf = pd.DataFrame(speedUnder, columns = ['Accurancy', 'precision','recall'])\nspeedAndFlowUnderdf = pd.DataFrame(speedAndFlowUnder, columns = ['Accurancy', 'precision','recall'])","645118a1":"for col in ['Accurancy', 'precision','recall']:\n    plt.plot(speed20df[col], label='speed20')    \n    plt.plot(speedUnderdf[col], label='speedUnder')\n    plt.plot(speedAndFlowUnderdf[col], label='speedAndFlowUnder')\n    plt.title(col)\n    plt.legend()\n    plt.show()","d5e607bc":"def getSequences(sequence, backward, forward=1):\n    X, y = list(), list()\n    for i in range(len(sequence)-(backward+forward-1)):\n        if forward > 1:\n            seq_x, seq_y = sequence[i:i+backward], sequence[i+backward:i+backward+forward]\n        else:\n            seq_x, seq_y = sequence[i:i+backward], sequence[i+backward]\n        X.append(seq_x)\n        y.append(seq_y)\n    \n    return np.array(X), np.array(y)","8b63c391":"# Parameters\npindexMin = '2000-01-01 00:00:00+0000'\npindexMax = '2030-01-01 00:00:00+0000'\n\ncam = 'A3.VM.8246' \ncam1 = 'A3.VM.7280'\n\nWINDOW = 10\nFORECAST = 3","5fb97591":"# Build features dataframe\ndf0 = getFilteredData(data,cam,indexMin=pindexMin,indexMax=pindexMax)\ndf0=df0[['avgVehicleSpeed', 'vehicleFlowRate']]\ndf1 = getFilteredData(data,cam1,indexMin=pindexMin,indexMax=pindexMax)\ndf1=df1[['avgVehicleSpeed', 'vehicleFlowRate']]\n    \ndf1.rename(columns={'avgVehicleSpeed' : 'pre_avgVehicleSpeed', 'vehicleFlowRate' : 'pre_vehicleFlowRate'},inplace=True)\ndf = df0.join(df1,how='inner')\ndf.dropna(inplace=True)\n\nscaler = MinMaxScaler()\nscaled = scaler.fit_transform(df)\n\nX, _ = getSequences(scaled, backward = WINDOW , forward= FORECAST )\n_ , ySpeed = getSequences(scaled[:,0], backward = WINDOW , forward= FORECAST )\n_ , yFlow = getSequences(scaled[:,1], backward = WINDOW , forward= FORECAST )\n\nprint(\"X shape\", X.shape,\" - y shape \", y.shape)\n\nX_train = X[1000:]\nX_test = X[:1000]\nySpeed_train = ySpeed[1000:]\nySpeed_test = ySpeed[:1000]\nyFlow_train = yFlow[1000:]\nyFlow_test = yFlow[:1000]","4b85e6ad":"# Train the model\ndef trainTheModel(X_train,y_train):\n    model = keras.Sequential()\n    model.add(keras.layers.LSTM(128, activation='relu', input_shape=(X_train.shape[1], X_train.shape[2])))\n    #model.add(keras.layers.Dense(100, activation='relu'))\n    model.add(keras.layers.Dense(FORECAST))\n    model.compile(loss='mse', optimizer='adam')\n    early_stop = keras.callbacks.EarlyStopping(\n            monitor='val_loss',\n            patience=10\n    )   \n    history = model.fit(\n        X_train,y_train, \n        epochs=10, \n        batch_size=64, \n        validation_split=0.05,\n        shuffle=True,\n        callbacks=[early_stop],\n        verbose=0\n        )            \n\n    plt.plot(history.history['loss'], label='train')\n    plt.plot(history.history['val_loss'], label='test')\n    plt.legend()\n    plt.show()\n    return model\n\nmodelSpeed = trainTheModel(X_train,ySpeed_train)\nmodelFlow = trainTheModel(X_train,yFlow_train)","35eb2818":"# Evaluate the results with test data\nySpeed_pred = modelSpeed.predict(X_test)\nyFlow_pred = modelFlow.predict(X_test)\n\nfor i in [0,1,2]:\n    print(\"RMSE for Speed Prediction + {} minutes= {}\".format(i*5+5,measure_rmse(ySpeed_test[:,i], (ySpeed_pred[:,i]))))\n\nfor i in [0,1,2]:\n    print(\"RMSE for Flow Prediction + {} minutes= {}\".format(i*5+5,measure_rmse(yFlow_test[:,i], (yFlow_pred[:,i]))))","1c888a73":"iStart=100\niStop=200\nfor i in [0,1,2]:\n    plt.plot(ySpeed_pred[:iStop,i], label='prediction')    \n    plt.plot(ySpeed_test[:iStop,i], label='true')\n    plt.title('Speed prediction + {} minutes'.format(i*5+5))\n    plt.legend()\n    plt.show()\nfor i in [0,1,2]:\n    plt.plot(yFlow_pred[:iStop,i], label='prediction')    \n    plt.plot(yFlow_test[:iStop,i], label='true')\n    plt.title('Flow prediction + {} minutes'.format(i*5+5))\n    plt.legend()\n    plt.show()","ef9e62c2":"# Exploratory data analysis\n> &#171;For this graphic exploration, we will focus on the camera at kilometer 11 of the A3, this camera is located on the border between France and Luxembourg. Traffic at the border experiences daily overloads in the morning towards Luxembourg and in the evening towards France.&#187;","3b1c9f4d":"# Print the cameras map","197bba8f":"# Load data","1ffa438e":"## Utility functions used in this notebook","9851bce5":"### Concentration, to Luxembourg and from Luxembourg","ed578240":"> &#171; The indicator that have the best results is **60% drop in speed (relative to overall average speed) within 15 minutes**&#187;","492e2b08":"# Conclusion\n\nThe two indicators that give the best performance at 15 minutes are:\n- Random Forest : 60% drop in speed (relative to overall average speed) within 15 minutes.\n- LSTM : traffic flow forecast\n\n\nThe preliminary prediction tests brought the following two observations:\n\n- it's better to train one model by camera.\n- In the features, it's better to take account of upstream camera data","b76cbaae":"# Prediction of indicators with Random forest\n\nThis first analysis focuses on the prediction of indicators. These three simple indicators (Yes \/ No) are as follows:\n- 20% decrease in speed (compared to now) in 15 minutes.\n- 60% drop in speed (relative to overall average speed) within 15 minutes.\n- 60% drop in speed and flow (compared to the overall average) in 15 minutes.\n\nThese three indicators attempt to qualify respectively a slowing down, a potential traffic jam, more certainly a traffic jam.\n\nTo train the model, the following features are used :\nAt a moment t, for a camera,\n- Average speed in km\/h\n- Traffic concentration in percentage\n- Traffic flow in number of cars per hour\n- The average speed for the camera 1km upstream\n- The concentration of traffic for the camera 1km upstream\n- Traffic flow for the camera 1km upstream\n- Day of the week number\n- Weekend: Yes \/ No\n- Hour of day\n- Speed change in %, between t and (t - 5 minutes), between (t - 5 minutes) and (t - 10 minutes) and between (t - 10 minutes) and (t - 15 minutes)\n- Evolution of the flow in %, between t and (t - 5 minutes), between (t - 5 minutes) and (t - 10 minutes) and between (t - 10 minutes) and (t - 15 minutes)\n- Evolution of the concentration in %, between t and (t - 5 minutes), between (t - 5 minutes) and (t - 10 minutes) and between (t - 10 minutes) and (t - 15 minutes)\n- Exponential weighted average of the speed over the last 15 minutes\n- Exponential weighted average of the concentration over the last 15 minutes\n- Exponential weighted average of the stream over the last 15 minutes\n\nThe preliminary prediction tests brought the following two observations:\n- Training only one model for all cameras at the same time does not give a good result. The dynamics of each point of the motorway are different.\n- In the features, if we take only the camera data, the 15-minute predictions are unreliable. Therefore, the data from the upstream camera has been added.\n","611b9f50":"### traffic flow by day, to Luxembourg and from Luxembourg","d8168500":"# Time serie forecasting\n\n> &#171; The question is, can we predict one or more future values from a window into the past using a LSTM ? &#187;\n\n**The window has 10 steps in past**\n```\nWINDOW = 10\nFORECAST = 1\n```\n---\n\nIN:\n\n---\n\nThe Features IN are composed of 4 series (\n- avgVehicleSpeed of the camera \n- vehicleFlowRate of the camera \n- avgVehicleSpeed of the previous camera\n- vehicleFlowRate of the previous camera\n\n\n---\n\nOUT :  \n\n---\n\ntarget feature : average speed or vehicleFlowRate\n\nFORECAST = 1 (+5 minutes), 2 (+10 minutes) or 3 (+15 minutes)\n","8bc7d149":"### Average speed by day, to Luxembourg and from Luxembourg","0ed450a1":"## Which indicator gives the most reliable predictions?\n- 20% decrease in speed (compared to now) in 15 minutes.\n- 60% drop in speed (relative to overall average speed) within 15 minutes.\n- 60% drop in speed and flow (compared to the overall average) in 15 minutes.\n\nlet's test over a couple of cameras","78e10c48":"> &#171; It can also be interesting to observe how the traffic spreads along the highway: is the speed collapsing everywhere at the same time, or spreading along the highway  &#187;","225e411f":"## See the traffic jams\n\n> &#171;If we plot the data per day, towards Luxembourg at the top, then Luxembourg at the bottom, we can clearly see the traffic jams in the morning and in the evening for the days of the week&#187;","08f068b2":"# Introduction\n\nThe data analyzed was captured by the 186 cameras of cita.lu between 19\/11\/2019 and 26\/12\/2019 on the Luxembourg motorways.\n\nData for each camera is updated every 5 minutes.\n\nFor this period, this represents a data set of 1,887,379 records.\n\nIf we extrapolate to 1 year, this represents approximately 18,130,000 records.\n\nThe 3 measurements available for each camera every 5 minutes are:\n- Average speed in km\/h\n- Traffic concentration in percentage\n- Traffic flow in number of cars per hour\n\n"}}