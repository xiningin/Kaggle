{"cell_type":{"0c5f894c":"code","fabaef3f":"code","8dba40f0":"code","300e6d26":"code","7c6c7162":"code","49bb9f4e":"code","95682c1e":"code","9f5542ee":"code","b2232843":"code","25a6847f":"code","1933a47b":"code","642bace4":"code","e551e12d":"code","69b89e1f":"code","67a4d64d":"code","e7369723":"code","af0035fe":"code","1cf6090b":"code","ac7c3d37":"code","ea596cd2":"code","cce43b35":"code","39a01eb9":"code","215cfb64":"code","27c95721":"markdown","b39da81a":"markdown","5a3c806d":"markdown","f540a243":"markdown","cb93cda0":"markdown","9f2d8a28":"markdown","0d13089b":"markdown","d0b0fee6":"markdown"},"source":{"0c5f894c":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport joblib\nfrom sklearn.model_selection import StratifiedKFold, GroupKFold, train_test_split\nfrom sklearn.preprocessing import LabelEncoder, MinMaxScaler, StandardScaler\nfrom sklearn.linear_model import LinearRegression, SGDRegressor\nfrom sklearn import metrics\nimport lightgbm as lgb\nfrom xgboost import XGBRegressor\n# Input data files are available in the \"..\/input\/\" directory.","fabaef3f":"train = pd.read_csv('..\/input\/champs-scalar-coupling\/train.csv')\ntest = pd.read_csv('..\/input\/champs-scalar-coupling\/test.csv')\nstructures = pd.read_csv('..\/input\/champs-scalar-coupling\/structures.csv')","8dba40f0":"print('Train shape: {}'.format(train.shape))\nprint('Test shape: {}'.format(test.shape))","300e6d26":"train.info()","7c6c7162":"test.info()","49bb9f4e":"train.describe()","95682c1e":"train[['molecule_name','scalar_coupling_constant']].groupby('molecule_name').mean()[:100]","9f5542ee":"train[['type','scalar_coupling_constant']].groupby('type').count()","b2232843":"sns.distplot(train['scalar_coupling_constant'])","25a6847f":"train = pd.merge(train, structures, how = 'left',left_on  = ['molecule_name', 'atom_index_0'],\nright_on = ['molecule_name',  'atom_index'])\n\ntrain = pd.merge(train, structures, how = 'left',left_on  = ['molecule_name', 'atom_index_1'],\nright_on = ['molecule_name',  'atom_index'])","1933a47b":"test = pd.merge(test, structures, how = 'left',left_on  = ['molecule_name', 'atom_index_0'],\nright_on = ['molecule_name',  'atom_index'])\n\ntest = pd.merge(test, structures, how = 'left',left_on  = ['molecule_name', 'atom_index_1'],\nright_on = ['molecule_name',  'atom_index'])","642bace4":"train.head()","e551e12d":"train['dist'] = ((train['x_y'] - train['x_x'])**2 + (train['y_y'] - train['y_x'])**2 + \n(train['z_y'] - train['z_x'])**2 ) ** 0.5\n\ntest['dist'] = ((test['x_y'] - test['x_x'])**2 + (test['y_y'] - test['y_x'])**2 +\n(test['z_y'] - test['z_x'])**2 ) ** 0.5","69b89e1f":"train.head()","67a4d64d":"train.columns","e7369723":"features = ['atom_index_x', 'x_x', 'y_x','z_x', 'atom_index_y', 'x_y', 'y_y', 'z_y', 'dist']","af0035fe":"X_train,X_val,y_train,y_val = train_test_split(train[features], train['scalar_coupling_constant'],test_size=0.2)","1cf6090b":"xgb = XGBRegressor()\nxgb.fit(X_train,y_train)\npreds = xgb.predict(X_val)\njoblib.dump(xgb, 'xgb_model.pkl')","ac7c3d37":"np.log(metrics.mean_absolute_error(y_val,preds))","ea596cd2":"test_predictions = xgb.predict(test[features])","cce43b35":"sns.distplot(test_predictions)","39a01eb9":"submission = pd.DataFrame()\nsubmission['id'] = test['id']\nsubmission['scalar_coupling_constant'] = test_predictions","215cfb64":"submission.to_csv('usingXGBoost.csv.gz',index=False,compression='gzip')","27c95721":"This is my first competition and first kernel on Kaggle. If you think I've made some mistakes or I can improve somewhere, please let me know. Thanks :)","b39da81a":"## Feature Engineering","5a3c806d":"# Predicting Molecular Properties","f540a243":"Looks like the distribution of the scalar coupling constant in the train dataset.","cb93cda0":"> ","9f2d8a28":"> ## Modeling","0d13089b":"## Loading the data","d0b0fee6":"## EDA"}}