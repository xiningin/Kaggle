{"cell_type":{"23d125ec":"code","6de68edc":"code","13db49f7":"code","04e61086":"code","76f3d060":"code","ace0bb5d":"code","1459a108":"code","1ea8fb98":"code","2268d1c4":"code","a86c4997":"code","71c47065":"code","a393b2db":"code","144f6ec5":"code","37fa8306":"code","797d97ef":"code","a246b67f":"code","3adcb299":"code","895532e7":"code","b8e964d2":"code","b67d354d":"code","f787ea6e":"code","1bace3b8":"code","95acd11b":"code","b432bb68":"code","ee20ec7c":"markdown","d943a9a4":"markdown"},"source":{"23d125ec":"import random\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom keras.utils import to_categorical\nfrom tensorflow.keras.models import Sequential \nfrom tensorflow.keras.layers import Input,Dense ,Dropout\nfrom tensorflow.keras.utils  import plot_model, model_to_dot\nfrom tensorflow.keras.optimizers import Adam \nfrom keras.callbacks import EarlyStopping\nfrom sklearn.model_selection import train_test_split","6de68edc":"radius=10\nsampleNumber=10000\nCircular1centerPoint = (2, 4)\nCircular2centerPoint = (16, 4)","13db49f7":"\n\n\ndef point_on_Circular(centerPoint, radius,sampleNumber ) :\n    \"\"\"\n    Random point on the Circular with vertices pt.x,pt.y and radius.\n    \"\"\"\n\n    # random angle\n    alpha = 2 * np.pi * np.random.random(sampleNumber)\n    # random radius\n    r =radius * np.sqrt(np.random.random(sampleNumber))\n    # calculating coordinates\n    return ( \n             r * np.cos(alpha) + centerPoint[0],\n             r * np.sin(alpha) + centerPoint[1],\n           )","04e61086":"def showPoints(X,y):\n    circle1=plt.Circle(Circular1centerPoint,radius,color='b', fill=False)\n    circle2=plt.Circle(Circular2centerPoint,radius,color='b', fill=False)\n\n    \n    plt.gcf().gca().add_artist(circle1)\n    plt.gcf().gca().add_artist(circle2)\n\n    plt.scatter(X[y.c1].x1, X[y.c1].x2, s=0.5,c =\"r\")\n    plt.scatter(X[y.c2].x1, X[y.c2].x2, s=0.5,c =\"b\")\n#     plt.scatter(X[y.c3].x1, X[y.c3].x2, s=0.5,c =\"g\")\n    plt.show()\n    \n    \n    ","76f3d060":"\n \npointsOnC1 =np.array(point_on_Circular(Circular1centerPoint, radius,sampleNumber\/\/2))\npointsOnC2=np.array(point_on_Circular(Circular2centerPoint, radius,sampleNumber\/\/2))\n\n","ace0bb5d":"X=pointsOnC1\nd = {'x1': X[0], 'x2':X[1] }\ndf  = pd.DataFrame(data=d)\n\nX=pointsOnC2\nd = {'x1': X[0], 'x2':X[1] }\ndf=df.append(pd.DataFrame(data=d))\n\ndf['c1']=  ((df['x1']  - Circular1centerPoint[0]) * (df['x1'] - Circular1centerPoint[0]) +  (df['x2']  - Circular1centerPoint[1]) * (df['x2']  - Circular1centerPoint[1]) <= radius ** 2)\ndf['c2']=  ((df['x1']  - Circular2centerPoint[0]) * (df['x1'] - Circular2centerPoint[0]) +  (df['x2']  - Circular2centerPoint[1]) * (df['x2']  - Circular2centerPoint[1]) <= radius ** 2)\n# df['c3']=    df['c1'] &   df['c2']\n\nX=df[['x1', 'x2']]\ny=df[['c1', 'c2']]\n# ,'c3'\n\n","1459a108":"df.head()","1ea8fb98":"showPoints(X,y)","2268d1c4":"# Split into train\/test\nX_train, X_test, y_train, y_test = train_test_split(    \n    X, y.values, test_size=0.10, random_state=42)","a86c4997":"# Split into train\/val\nX_train, X_val, y_train, y_val = train_test_split(    \n    X_train, y_train, test_size=0.10, random_state=42)","71c47065":"\nmodel = Sequential()\nmodel.add(Input(shape=( 2,)))\nmodel.add(Dense(units=2,activation=\"sigmoid\"))\n","a393b2db":"plot_model(model, to_file='model_plot.png', show_shapes=True, show_layer_names=True)","144f6ec5":" \nmodel.summary()\n ","37fa8306":"\nearly_stopping_monitor = EarlyStopping(monitor=\"val_binary_accuracy\", patience=2)\n\nmodel.compile(optimizer=Adam( ),\n            loss='binary_crossentropy',\n            metrics=['binary_accuracy'])\n\n\nhistory= model.fit(X_train, y_train, batch_size = 1,epochs = 10,\n                   validation_data = (X_val, y_val), \n                   callbacks=[early_stopping_monitor])","797d97ef":"score = model.evaluate(X_test,y_test,batch_size=32)\nprint(score)","a246b67f":"\n \n# list all data in history\nprint(history.history.keys())\n# summarize history for accuracy\nplt.plot(history.history['binary_accuracy'])\nplt.plot(history.history['val_binary_accuracy'])\nplt.title('model accuracy')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()\n# summarize history for loss\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title('model loss')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()","3adcb299":"y_predictions = model.predict(X_test)\n","895532e7":"y_predictions[y_predictions>=0.5] = True\ny_predictions[y_predictions<0.5] = False","b8e964d2":"y_predictions=y_predictions.T","b67d354d":"X_test=X_test.reset_index()\n\nd={'c1':y_predictions[0],'c2':y_predictions[1]}\ny_predictions=pd.DataFrame(d,dtype=\"bool\") ","f787ea6e":"showPoints(X_test,y_predictions)","1bace3b8":"print(y_predictions.shape,y_test.shape,len(y_predictions),len(y_test))","95acd11b":"#np\ny_predictions=y_predictions.values","b432bb68":"correct_predictions = np.nonzero(y_predictions == y_test)[0]\nincorrect_predictions = np.nonzero(y_predictions != y_test)[0]\nprint(len(correct_predictions),\" classified correctly\")\nprint(len(incorrect_predictions),\" classified incorrectly\")","ee20ec7c":"# **Thankyou For Reading**","d943a9a4":"# **In short**\n\n\n\n* Use **sigmoid** for activation of your output layer Don't use **softmax**.\n* Use **binary_crossentropy** for loss function.\n* Use **predict** for evaluation Don't use **predict_classes**."}}