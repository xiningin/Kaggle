{"cell_type":{"4fbfda22":"code","c85131ee":"code","1578384c":"code","e5034df0":"code","18666adf":"code","9c9a30bc":"code","4d69695d":"code","4369da3d":"code","a95f8b42":"code","aabbae72":"code","34d147b7":"code","70012bfe":"markdown","ca3e974a":"markdown"},"source":{"4fbfda22":"import numpy as np\nimport pandas as pd\nimport random\n\nfrom Levenshtein import distance","c85131ee":"SEED = 2021\n\nrandom.seed = SEED","1578384c":"df = pd.read_csv(\"..\/input\/bms-molecular-translation\/train_labels.csv\")\ndf","e5034df0":"# Pick some important constants. Note this gets O(TEST_POP_SIZE * INIT_POP_SIZE) so be careful!\nTEST_POP_SIZE = 100\nINIT_POP_SIZE = 500\nMUTATIONS = 50\nGENERATIONS = 100","18666adf":"total_population = len(df)\nprint(f\"total_population: {total_population}\")\n\n# Sample an initial population from the complete training set.\ninitial_population = df[\"InChI\"].sample(INIT_POP_SIZE, random_state=SEED).reset_index(drop=True)","9c9a30bc":"# Simplest possible Genetic Algorithm helper methods.\n\ndef cross_over(parent1, parent2):\n    \"\"\" Splice two parents together at a random point to generate a child. \"\"\"\n    min_len = min(len(parent1), len(parent2))\n    splice_idx = random.randint(0, min_len)\n    child = parent1[:splice_idx] + parent2[splice_idx:]\n    return child\n    \ndef mutate(individual):\n    \"\"\" Mutate an individual by swapping two characters at a random point.\"\"\"\n    mutation_idx = random.randint(0, len(individual)-2)\n    return individual[:mutation_idx] + individual[mutation_idx+1] + individual[mutation_idx] + individual[mutation_idx+2:]\n\ndef select_best(population, n_best):\n    \"\"\" Score the given population against a sample from the total training population. \"\"\"\n    test_population = df[\"InChI\"].sample(TEST_POP_SIZE, random_state=SEED).reset_index(drop=True)\n    scores = []\n    for p in population:\n        score = 0\n        for t in test_population:\n            score += distance(p,t)\n        score = score\/TEST_POP_SIZE\n        scores.append(score)\n    sorted_population = [p for _, p in sorted(zip(scores, population))]\n    return sorted_population[:n_best], min(scores)","4d69695d":"# Test cross_over and mutate on some simple srtings.\nprint(cross_over(\"abcdef\", \"vwxyz\"))\nprint(cross_over(\"abcdef\", \"vwxyz\"))\nprint(cross_over(\"abcdef\", \"vwxyz\"))\nprint(cross_over(\"vwxyz\", \"abcdef\"))\nprint(cross_over(\"vwxyz\", \"abcdef\"))\nprint(cross_over(\"vwxyz\", \"abcdef\"))\n\nprint(mutate(\"abcdef\"))\nprint(mutate(\"abcdef\"))\nprint(mutate(\"abcdef\"))\nprint(mutate(\"abcdef\"))","4369da3d":"# What is the fittest member of the population to start with?\nselect_best(initial_population, 1)","a95f8b42":"def genetic_algorithm():\n    \"\"\" This is just meant to be a simple naive baseline. No need to make it more complex that it needs to be. \"\"\"\n    population = initial_population\n\n    for gen in range(GENERATIONS):\n        # Select the top half of the population and then fill back to the original population limit by making children.\n        population, _ = select_best(population, INIT_POP_SIZE\/\/2)\n        children = []\n        for child in range(INIT_POP_SIZE\/\/2):\n            children.append(cross_over(population[random.randint(0, INIT_POP_SIZE\/\/2 - 1)], population[random.randint(0, INIT_POP_SIZE\/\/2 - 1)]))\n        population.extend(children)\n        \n        # Add some mutations.\n        for m in range(MUTATIONS):\n            mutant = random.randint(0, INIT_POP_SIZE - 1)\n            population[mutant] = mutate(population[mutant])\n        \n        # Report on the best so far.\n        _, best_score = select_best(population, 1)        \n        print(f\"Generation: {gen} : {best_score}\")\n    \n    return select_best(population, 1)","aabbae72":"best_string, score = genetic_algorithm()\n\n# What single string did we generate?\nprint(best_string[0], score)","34d147b7":"# Build the submission. The csv is huge and very repitative. .gz files can be submitted directly, so let's compress it.\nsubm = pd.read_csv('..\/input\/bms-molecular-translation\/sample_submission.csv')\nsubm['InChI'] = best_string[0]\nsubm.to_csv('submission.csv.gz', compression=\"gzip\", index=False)","70012bfe":"# Start the Genetic Algorithm","ca3e974a":"Please note this is not a serious model for the actual problem at hand, just exploring what a single string response can score on the LB!\n\n# Motivation\n\nThe sample submission has the label for water, but all the training samples I've looked at are complex carbon based molecules. This got me thinking, purely as a naive baseline, is there a single string that is closest, that is has the minimum average Levenshtein distance to all the training samples?\n\nUnfortunately, finding that optimal single string is NP-complete: https:\/\/cstheory.stackexchange.com\/questions\/36593\/find-a-string-with-minimal-edit-distance-from-a-set-of-given-strings\n\nSo, I have a population of strings and I'm looking to generate a string that minimizes the average Levenshtein distance to the training set. It is rare I come across a problem that is so ameanable to using a genetic algorithm, so I thought I'd have some fun!"}}