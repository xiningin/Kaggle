{"cell_type":{"fbd412d4":"code","b3aa1aad":"code","e721494e":"code","d24be2f1":"code","d48b6826":"code","29604730":"code","4fd18e52":"code","824b9999":"code","7a03e84d":"code","33a1d794":"code","46176db8":"code","9cf0f937":"code","188f3814":"code","c4eb7a64":"code","e36d1e80":"code","e4851b20":"code","034d3015":"code","898e8080":"code","a9c586cf":"markdown","ce24c3d6":"markdown","7b09b576":"markdown","1721f441":"markdown","096fa4a5":"markdown","6438be87":"markdown","774027ee":"markdown","f66c8053":"markdown","ceb7abf5":"markdown"},"source":{"fbd412d4":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n%matplotlib inline\n\nfrom sklearn.cross_validation import train_test_split\nfrom sklearn import metrics\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import GridSearchCV","b3aa1aad":"df = pd.read_csv('..\/input\/train.csv')\ndf.head()","e721494e":"df.columns","d24be2f1":"# Given the horizontal & vertical distance to hydrology\n# It will be more intuitive to obtain the euclidean distance\n# sqrt{(verticaldistance)^2 + (horizontaldistance)^2}\n\nfrom math import sqrt\n\ndf['Euclid_Distance_To_Hydrology'] = \\\ndf.apply(lambda x: abs(sqrt(x['Horizontal_Distance_To_Hydrology']**2 + \\\n                            x['Vertical_Distance_To_Hydrology']**2)), axis=1)","d48b6826":"cols = [i for i in df.columns if i not in ['Id', 'Cover_Type']]\n\npredictor = df[cols] #exclude id & target columns\ntarget = df['Cover_Type']\n\ntrain_predictor, test_predictor, train_target, test_target = \\\ntrain_test_split(predictor, target, test_size=0.2)","29604730":"model = RandomForestClassifier().fit(train_predictor, train_target)\npredictions = model.predict(test_predictor)","4fd18e52":"metrics.accuracy_score(test_target, predictions)","824b9999":"df2= pd.DataFrame(model.feature_importances_, index=cols)\ndf2 = df2.sort_values(by=0,ascending=False)\ndf2.columns = ['feature importance']\ndf2","7a03e84d":"def forest(x):\n    if x==1:\n        return 'Spruce\/Fir'\n    elif x==2:\n        return 'Lodgepole Pine'\n    elif x==3:\n        return 'Ponderosa Pine'\n    elif x==4:\n        return 'Cottonwood\/Willow'\n    elif x==5:\n        return 'Aspen'\n    elif x==6:\n        return 'Douglas-fir'\n    elif x==7:\n        return 'Krummholz'\n\n# Create pd Series for Original\nOriginal = test_target.apply(lambda x: forest(x)).reset_index(drop=True)\nOriginal.name = 'Original'\n\n# Create pd Series for Predicted\nPredicted = pd.DataFrame(predictions, columns=['Predicted'])\nPredicted = Predicted['Predicted'].apply(lambda x: forest(x))","33a1d794":"confusion = pd.crosstab(Original, Predicted)\nconfusion","46176db8":"plt.figure(figsize=(10, 5))\nsns.heatmap(confusion,annot=True,cmap=sns.cubehelix_palette(8));","9cf0f937":"# dump columns with 0 importance\nfor i in ['Soil_Type7', 'Soil_Type15']:\n    del predictor[i]","188f3814":"model = RandomForestClassifier()\n\n# removed some parameter queries so can upload notebook faster\ngrid_values = {'n_estimators':[200],\n                'max_features':[0.2,0.5],\n                'max_depth':[60],\n                \"criterion\": [\"gini\"]}\ngrid = GridSearchCV(model, param_grid = grid_values, cv=5, n_jobs=-1)\ngrid.fit(predictor, target)\n\nprint(grid.best_params_)\nprint(grid.best_score_)","c4eb7a64":"model = RandomForestClassifier(n_estimators = grid.best_params_['n_estimators'], \\\n                               max_features = grid.best_params_['max_features'], \\\n                               max_depth = grid.best_params_['max_depth'], \\\n                               criterion = grid.best_params_['criterion'])\nmodel.fit(predictor, target)","e36d1e80":"test = pd.read_csv('..\/input\/test.csv')","e4851b20":"# dump columns with 0 importance\nfor i in ['Soil_Type7', 'Soil_Type15']:\n    del test[i]","034d3015":"# Feature Engineering\ntest['Euclid_Distance_To_Hydrology'] = \\\ntest.apply(lambda x: abs(sqrt(x['Horizontal_Distance_To_Hydrology']**2 + \\\n                              x['Vertical_Distance_To_Hydrology']**2)), axis=1)","898e8080":"cols = [i for i in cols if i not in ['Soil_Type7', 'Soil_Type15']]\n\npredict_real_test = model.predict(test[cols])\nsubmit = pd.concat([test['Id'], pd.Series(predict_real_test)],axis=1)\nsubmit.columns = columns=['Id','Cover_Type']\nsubmit.to_csv('submission.csv',index=False)","a9c586cf":"### Feature Importance","ce24c3d6":"### Basic Random Forest","7b09b576":"We can see that __Soil_Type7, Soil_Type15__ have 0 low feature importance.\n\nWill dump them in final model so that processing can be faster.","1721f441":"### Submission","096fa4a5":"### Accuarcy","6438be87":"### Rerun Model with Entire Train Set","774027ee":"### Grid Search Hyper-Parameters","f66c8053":"### Feature Engineering","ceb7abf5":"### Confusion Matrix"}}