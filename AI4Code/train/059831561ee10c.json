{"cell_type":{"800202f0":"code","acfb51ea":"code","2be149fe":"code","3a664cdf":"code","44b87b8d":"code","9553f1ee":"code","8ea625e1":"code","b1819efc":"code","47d2832e":"code","142a00ec":"code","c848380f":"code","c1f339c1":"code","5152ccc2":"code","89ccfc46":"code","22f8a373":"code","22f0bebd":"code","68edefff":"markdown","3761ec52":"markdown"},"source":{"800202f0":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","acfb51ea":"!pip install lifetimes","2be149fe":"# Importing necessary libraries\nfrom sqlalchemy import create_engine\nimport datetime as dt\nimport pandas as pd\nfrom lifetimes import BetaGeoFitter\nfrom lifetimes import GammaGammaFitter","3a664cdf":"# We will use online_retail_II data.\ndf_ = pd.read_csv('..\/input\/online-retail-ii-uci\/online_retail_II.csv')\ndf = df_.copy()\ndf.head()","44b87b8d":"# Data Processing\n# I will drop canceled transactions in Invoice\n# There are some minus values in Quantity and Price. Let's handle it also.\n# We will reduce the country to United Kingdom to work faster\ndf.dropna(inplace=True)\ndf = df[~df[\"Invoice\"].str.contains(\"C\", na=False)]\ndf = df[df[\"Quantity\"] > 0]\ndf = df[df[\"Price\"] > 0]\ndf = df[df['Country']=='United Kingdom']\ndf.describe().T","9553f1ee":"# As you see above there seems some outlier problems.\n# Let's solve outlier problem and change outlier's value. We will fix them a certain value\ndef outlier_thresholds(dataframe, variable):\n    quartile1 = dataframe[variable].quantile(0.01)\n    quartile3 = dataframe[variable].quantile(0.99)\n    interquantile_range = quartile3 - quartile1\n    up_limit = quartile3 + 1.5 * interquantile_range\n    low_limit = quartile1 - 1.5 * interquantile_range\n    return low_limit, up_limit\n\ndef replace_with_thresholds(dataframe, variable):\n    low_limit, up_limit = outlier_thresholds(dataframe, variable)\n    dataframe.loc[(dataframe[variable] < low_limit), variable] = low_limit\n    dataframe.loc[(dataframe[variable] > up_limit), variable] = up_limit\n\nreplace_with_thresholds(df, \"Quantity\")\nreplace_with_thresholds(df, \"Price\")\ndf.describe().T","8ea625e1":"# At this point, We need one more variable here because we don't know the total price that customers' has spent\ndf[\"TotalPrice\"] = df[\"Quantity\"] * df[\"Price\"]\ndf.head()","b1819efc":"# Now, we can create and prepare our dataframe for BG\/NBD and GAMMA GAMMA models\ndf['InvoiceDate']= pd.to_datetime(df['InvoiceDate'])\ntoday_date = dt.datetime(2011, 12, 11)\n\ncltv_df = df.groupby('Customer ID').agg({'InvoiceDate': [lambda date: (date.max() - date.min()).days,\n                                                         lambda date: (today_date - date.min()).days],\n                                         'Invoice': lambda num: num.nunique(),\n                                         'TotalPrice': lambda TotalPrice: TotalPrice.sum()})\ncltv_df.columns = cltv_df.columns.droplevel(0)\ncltv_df.columns = ['recency', 'T', 'frequency', 'monetary']\ncltv_df.head()","47d2832e":"# 'monetary' value should be expressed as the \"average earnings\" per purchase.\ncltv_df[\"monetary\"] = cltv_df[\"monetary\"] \/ cltv_df[\"frequency\"]\ncltv_df.head()","142a00ec":"# I can't make a prediction for people who has purchased only once so we take the frequency values greater than 1\n# .. and handle minues values problem in monetary\ncltv_df = cltv_df[(cltv_df['frequency'] > 1)]\ncltv_df.head()","c848380f":"# In order to define recency and T values into the gamma model, we should convert them to weekly  \ncltv_df[\"recency\"] = cltv_df[\"recency\"] \/ 7\ncltv_df[\"T\"] = cltv_df[\"T\"] \/ 7\ncltv_df.head()","c1f339c1":"# BG\/NBD\n# This model alone is a very valuable modeling technique that can model how much sales will be made after 1 week.\n# We will create 2 variable for 1 week and 1 month\nbgf = BetaGeoFitter(penalizer_coef=0.001)\nbgf.fit(cltv_df['frequency'],\n        cltv_df['recency'],\n        cltv_df['T'])\n\ncltv_df[\"expected_purc_1_week\"] = bgf.predict(1,\n                                              cltv_df['frequency'],\n                                              cltv_df['recency'],\n                                              cltv_df['T'])\n\ncltv_df[\"expected_purc_1_month\"] = bgf.predict(4,\n                                               cltv_df['frequency'],\n                                               cltv_df['recency'],\n                                               cltv_df['T'])\ncltv_df.head()","5152ccc2":"# Gamma Gamma\n# It'll show us expected average profit\nggf = GammaGammaFitter(penalizer_coef=0.01)\nggf.fit(cltv_df['frequency'], cltv_df['monetary'])\n\n# Prediction\ncltv_6 = ggf.customer_lifetime_value(bgf,\n                                   cltv_df['frequency'],\n                                   cltv_df['recency'],\n                                   cltv_df['T'],\n                                   cltv_df['monetary'],\n                                   time=6,              # 6 months\n                                   freq=\"W\",            # 'W':Weekly\n                                   discount_rate=0.01)\ncltv_6.head()\ncltv_6 = cltv_6.reset_index()\ncltv_6.sort_values(by=\"clv\", ascending=False).head(20)","89ccfc46":"cltv_final_6 = cltv_df.merge(cltv_6, on=\"Customer ID\", how=\"left\")\ncltv_final_6.sort_values(by=\"clv\", ascending=False).head(10)","22f8a373":"# CLTV standartization\nfrom sklearn.preprocessing import MinMaxScaler\nscaler = MinMaxScaler(feature_range=(0, 1))\nscaler.fit(cltv_final_6[[\"clv\"]])\ncltv_final_6[\"scaled_clv\"] = scaler.transform(cltv_final_6[[\"clv\"]])\ncltv_final_6.sort_values(by=\"scaled_clv\", ascending=False).head()","22f0bebd":"# In the final We'll rate and segment our customers\ncltv_final_6[\"segment\"] = pd.qcut(cltv_final_6[\"scaled_clv\"], 4, labels=[\"D\", \"C\", \"B\", \"A\"])\ncltv_final_6 = cltv_final_6.rename(columns={'clv': 'expected_average_profitclv'})\ncltv_final_6.head()","68edefff":"### Today We'll perfom a project about 'Probabilistic lifetime value estimation with time projection'\n#### * Companies may want to make 3-month\/6-month\/1-year plans and set a roadmap for employees.\n#### * While making these plans, I need to have a foresight about the life cycle of my customers.\n#### * Accordingly, I will assign tasks to company employees or determine a progress route\n#### * Therefore, I need such a lifetime value that I can evaluate the issue with 3-month\/6-month projections. \n#### Let's start","3761ec52":"##### Firstly, I prefer to choose 'A' because these customers are very valuable to our company and we should try to increase sales by 10% for this group\n##### Secondly, Segment 'C' is about to leave buying our products so we may try to raise their degree to 'B'on the next 6 months\n\n### Thanks for your time!"}}