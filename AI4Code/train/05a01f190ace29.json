{"cell_type":{"5c09fdc0":"code","a93b8266":"code","e82003f1":"code","f1a0ea10":"code","6d4b8089":"code","98b20f92":"code","b9b14edb":"code","b34615e6":"code","b34376dc":"code","aa1cc6ae":"code","c56c4b98":"code","fa81f3b8":"code","1a624a28":"code","8226eda4":"code","6e255e09":"code","51edb6ba":"code","bf8c66bb":"code","cce7117a":"code","f15af8f3":"code","d8197fbd":"code","fd7c336b":"code","2b03dec7":"code","ab75a960":"code","aa998043":"code","d70d678f":"code","216cb3ba":"code","d9ba678d":"code","5c1d2985":"code","86bc17ae":"code","e6528c6a":"code","29e7a20b":"code","30c376b1":"code","7062df55":"code","dceae2c4":"code","025ed383":"code","9eceb53f":"code","fc82bf3d":"code","60286c10":"markdown","97d1e368":"markdown","16f57008":"markdown","771d0775":"markdown","462f9067":"markdown","83b5ee28":"markdown","8583db8d":"markdown","a5362d14":"markdown","f2c57f96":"markdown","a49e2448":"markdown","4d03994f":"markdown","a33cd48c":"markdown","4930e06f":"markdown","6f48a402":"markdown","4811928a":"markdown"},"source":{"5c09fdc0":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt  \nimport plotly.graph_objs as go\nfrom plotly.graph_objs import Figure, Data\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.decomposition import PCA\nfrom sklearn.cluster import KMeans ","a93b8266":"dataset = pd.read_csv('..\/input\/iris-flower-dataset\/IRIS.csv')","e82003f1":"dataset.head()","f1a0ea10":"dataset.dropna(inplace=True)\ndataset.drop('species', axis = 1 , inplace=True)","6d4b8089":"dataset.head()","98b20f92":"fig = go.Figure()\nfig.add_trace(go.Histogram(x=dataset['sepal_length'], name='sepal_length'))\nfig.add_trace(go.Histogram(x=dataset['sepal_width'], name='sepal_width'))\nfig.add_trace(go.Histogram(x=dataset['petal_length'], name='petal_length'))\nfig.add_trace(go.Histogram(x=dataset['petal_width'], name='petal_width'))\n\n# Overlay histograms\nfig.layout.update(barmode='overlay')\n# Reduce opacity to see histograms\nfig.update_traces(opacity=0.75)\nfig.show()","b9b14edb":"sd = StandardScaler()","b34615e6":"scaled_data = sd.fit_transform(dataset)","b34376dc":"dataset = pd.DataFrame(scaled_data, columns=dataset.columns)","aa1cc6ae":"dataset.head()","c56c4b98":"df = dataset.copy(deep=True)","fa81f3b8":"pca = PCA()","1a624a28":"decomposed_data = pca.fit_transform(dataset)","8226eda4":"#Plotting the Cumulative Summation of the Explained Variance\nplt.figure()\nplt.plot(np.cumsum(pca.explained_variance_ratio_))\nplt.xlabel('Number of Components')\nplt.ylabel('Variance (%)') #for each component\nplt.title('Iris Dataset Explained Variance')\nplt.show()","6e255e09":"pca = PCA(n_components=2)","51edb6ba":"decomposed_data = pca.fit_transform(dataset)","bf8c66bb":"columns = ['component#%i' % i for i in range(2)]","cce7117a":"decomposed_df = pd.DataFrame(decomposed_data, columns=columns)","f15af8f3":"decomposed_df.head()","d8197fbd":"# fig = go.Figure(data=go.Scatter(x=decomposed_df['component#0'], y=decomposed_df['component#1'], mode='markers'))\n\n# Create a trace\ntrace = go.Scatter(\n    x = decomposed_df['component#0'],\n    y = decomposed_df['component#1'],\n    mode = 'markers',\n    marker=dict(\n        size=16,\n        color=np.random.randn(500), #set color equal to a variable\n        colorscale='Viridis', # one of plotly colorscales\n        showscale=True\n    )\n)\nlayout = {\n    \"title\": \"Scatter plot\",\n    \"xaxis\": {\n        \"showgrid\": True,\n        \"zeroline\": False,\n        \"showticklabels\": False\n    },\n    \"yaxis\": {\n        \"showgrid\": True,\n        \"zeroline\": False,\n        \"showticklabels\": False\n    },\n    \"legend\": {\"font\": {\"size\": 16}},\n    \"titlefont\": {\"size\": 24}\n}\ndata = [trace]\nfig = Figure(data=data, layout=layout)\nfig.show()","fd7c336b":"pca.explained_variance_ratio_","2b03dec7":"wcss = []\nclusters = []\nd = []\nfor k in range(1, 40):\n    kmeans = KMeans(n_clusters=k, init=\"k-means++\", n_init=10,\n                    max_iter=300)\n    kmeans.fit_predict(dataset)\n    wcss.append(kmeans.inertia_)\n    clusters.append(k)","ab75a960":"data = {\n                \"type\": \"scatter\",\n                \"x\": clusters,\n                \"y\": wcss\n            }\n\ndata = Data([data])\nlayout = go.Layout(\n    title=\"Computing WCSS for KMeans++\",\n    yaxis=dict(title='Sum of squared errors'),\n    xaxis=dict(title='Number of clusters'),\n    paper_bgcolor='rgba(0,0,0,0)',\n    plot_bgcolor='rgba(0,0,0,0)'\n)\n\nfig = Figure(data=data, layout=layout)\nfig.show()","aa998043":"kmeans = KMeans(n_clusters=5, init=\"k-means++\", n_init=10,\n                    max_iter=300)","d70d678f":"kmeans","216cb3ba":"kmeans.fit(decomposed_df)","d9ba678d":"kmeans.labels_","5c1d2985":"dataset.insert(loc=0, column='clusters', value=pd.Series(kmeans.labels_).astype(int))","86bc17ae":"dataset.head(10)","e6528c6a":"decomposed_df.insert(loc=0, column='clusters', value=pd.Series(kmeans.labels_).astype(int))","29e7a20b":"dataset['clusters'].value_counts()","30c376b1":"kmeans.cluster_centers_","7062df55":"centroid_df = pd.DataFrame(kmeans.cluster_centers_, columns = decomposed_df.columns[1:])","dceae2c4":"centroid_df.head()","025ed383":"dataset.head()","9eceb53f":"decomposed_df.columns","fc82bf3d":"clusters = decomposed_df['clusters'].unique()\n\ncolumns = decomposed_df.columns[1:]\n\nsymbol = ('circle', 'square', 'triangle-up', 'diamond', 'cross', 'x',\n                  'triangle-down', 'asterisk', 'octagon', 'diamond-tall-down')\ncolor = ('yellow','blue',  'magenta', 'green', 'teal', 'navy','peru',\n                 'lightslategrey', 'red', 'olive')\n\nplot_data = []\n\nfor c in clusters:\n    trace1 = {\n      \"mode\": \"markers\", \n      \"name\": \"cluster\"+str(c),\n      \"type\": \"scatter\", \n      \"x\": decomposed_df.loc[decomposed_df['clusters']==c][columns[0]], \n      \"y\": decomposed_df.loc[decomposed_df['clusters']==c][columns[1]],\n      \"marker\": {\n        \"line\": {\n          \"color\": \"navy\", \n          \"width\": 0.5\n        }, \n        \"size\": 12, \n        \"color\": color[c],\n        \"symbol\": symbol[c]\n      }\n    }\n    trace2 = {\n      \"name\": \"centroid\"+str(c),\n      \"type\": \"scatter\", \n      \"x\": [centroid_df[columns[0]][c]], \n      \"y\": [centroid_df[columns[1]][c]],\n      \"marker\": {\n        \"color\": \"rgb(200,10,10)\", \n        \"symbol\": symbol[c]\n      }\n    }\n    plot_data.append(trace1)\n    plot_data.append(trace2)\n    \ndata = Data(plot_data)\nlayout = {\n    \"title\": \"K-Means Clustering (k=%s)\" % len(clusters),\n    \"xaxis\": {\n        \"showgrid\": True,\n        \"zeroline\": False,\n        \"showticklabels\": False\n    },\n    \"yaxis\": {\n        \"showgrid\": True,\n        \"zeroline\": False,\n        \"showticklabels\": False\n    },\n    \"legend\": {\"font\": {\"size\": 16}},\n    \"titlefont\": {\"size\": 24}\n}\nfig = Figure(data=data, layout=layout)\nfig.show()","60286c10":"#### reading iris dataset csv file","97d1e368":"#### plotting all the features in a histogram","16f57008":"#### Using elbow method to compute the clusters","771d0775":"#### adding cluters into original dataframe","462f9067":"### importing necessary libaries","83b5ee28":"#### using pca method to decompose the dimensions","8583db8d":"This plot tells us that selecting 2 components we can preserve something around 98.8% or 99% of the total variance of the data. It makes sense, we\u2019ll not use 100% of our variance, because it denotes all components, and we want only the principal ones.","a5362d14":"#### removing species column","f2c57f96":"#### using plotly method to plot elbow curve","a49e2448":"as per above graph 5 clusters seems good to proceed further","4d03994f":"##### standardizing the dataset to bring down into same scale","a33cd48c":"#### adding clusters colums to decomposed dataframe for plotting the cluters","4930e06f":"#### we can calculate the explained variance for each attribute by using scikit-learn, and plot the result","6f48a402":"* seems clusters1 has max datapoints","4811928a":"#### creating dataframe for centers"}}