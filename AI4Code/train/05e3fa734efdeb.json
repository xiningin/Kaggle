{"cell_type":{"b8d8ddc5":"code","d6487890":"code","be789cf3":"code","9305b1be":"code","4a0567be":"code","6bb647cc":"code","b3f5de2b":"code","e3d86039":"code","02222aba":"code","0baa01a2":"code","392e926c":"code","f9e63965":"code","b92dce25":"code","eea1d258":"code","52abad4e":"code","f7655564":"code","627cfc44":"code","844da6f2":"code","344e3d96":"code","e93e18ee":"code","fb808da8":"code","c5c6fcb7":"code","13bd7f7f":"code","9dbdb30a":"code","e987a211":"code","baa3bd7c":"code","d8631663":"code","44821dcb":"code","f4dc21b5":"code","5caa78d6":"code","168eb1ff":"code","84bcf1a1":"code","d7e77e9f":"code","934f3d26":"code","163c2a49":"code","bbc0cb14":"code","cc18e291":"code","a404a1fb":"code","665b9738":"code","c44ee678":"code","063d5cbd":"code","d600a493":"code","e909b4a0":"code","97666c49":"code","0c091650":"code","013ab539":"code","05e225de":"code","10b4fb86":"code","4168c2c7":"code","8f3a98ba":"code","06049d6a":"code","80cc862d":"code","c1cfae53":"code","2bfd3ef5":"code","7abdd64e":"code","5ec40afe":"code","9d265a3b":"code","9dd2e74f":"code","58724fbe":"code","31ecbdca":"code","a8ccde55":"code","828a9a12":"code","dcac36f0":"code","7d542075":"code","fee5601f":"code","5a996c98":"code","1ef0eb2a":"code","a33e48f2":"code","f71abdfe":"code","9560b1f3":"code","3853825a":"code","07eb9ad1":"code","cd8b2721":"code","c0e74d8e":"code","ee4a61e9":"code","c9641f20":"code","5937b4e5":"code","1f9e7d33":"code","2316526c":"code","0eedf667":"code","98f0eaef":"code","2c41bb9e":"code","386de69c":"code","fa95439d":"code","23bee5a0":"code","eb46ede9":"code","71922197":"code","1cb7882c":"code","1e07a06c":"code","0216f75a":"code","4d1ba820":"markdown","11365858":"markdown"},"source":{"b8d8ddc5":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","d6487890":"import re\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split as split\nfrom sklearn.metrics import confusion_matrix, classification_report, accuracy_score, pairwise_distances\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom pandas.tools.plotting import scatter_matrix\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom sklearn.model_selection import train_test_split as split\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\nfrom sklearn.preprocessing import MaxAbsScaler, LabelEncoder\n\nimport warnings\n\nwarnings.filterwarnings('ignore')\n%matplotlib inline","be789cf3":"# use error_bad_lines to get rid of error in line 821\nphones = pd.read_csv(\"..\/input\/phone_dataset .csv\",error_bad_lines=False)","9305b1be":"phones.head()","4a0567be":"phones.info()","6bb647cc":"# number of nulls in each feature\nphones.isnull().sum()","b3f5de2b":"# number of unique values in each feature\nphones.nunique()","e3d86039":"# remove the column img_url (a url for the image of the model)\nphones.drop(columns=['img_url'],inplace=True)","02222aba":"# switch weight columns into floats\nphones.weight_g = phones.weight_g.convert_objects(convert_numeric=True)\nphones.weight_oz = phones.weight_oz.convert_objects(convert_numeric=True)","0baa01a2":"# check for mismatch in weight conversion from oz to gr up to 0.03\n# how should we treat mismatched weight data ???\nphones[abs(0.03527396 * (phones.weight_g) - (phones.weight_oz)) >= 0.03]","392e926c":"# check what type of strings show up in battery column\nphones.battery.head()","f9e63965":"# a function to turn removable battery data into a boolean feature\ndef removable(battery):\n    if battery[0] == 'Removable':\n        return True\n    elif battery[0] == 'Non-removable':\n        return False\n    else:\n        return np.nan","b92dce25":"# looking for regular expressions in battery column strings\n# the method 'findall' returns a list with a single element. that element is a tuple of the regular expressions found\na = phones.battery.astype(str).apply(lambda x: \n                                        (re.findall('(Non-removable|Removable|)\\s*(Li-Ion|Li-Po|Li-ion|Li-po|NiMH|)\\s*(\\d*)',x))) \n\nphones['battery_removable'] = a.apply(lambda x: removable(x[0])) # the first regex indicates 'removable' \/ 'non-removable'\nphones['battery_type'] = a.apply(lambda x: (x[0])[1]) # the second regex indicates 'Li-Ion' \/ 'Li-Po' \/ 'Li-ion' \/ 'Li-po' \/ 'NiMH'\nphones['battery_mah'] = a.apply(lambda x: ((x[0])[2])).convert_objects(convert_numeric=True) # the third regex gives the numerical data for mah\n","eea1d258":"# the battery column was translated into three new features:\n# 1. battery_removable (boolean)\n# 2. battery_type (string): Li-Ion \/ Li-Po \/ Li-ion \/ Li-po \/ NiMH\n# 3. battery_mah (float)\nphones.head()","52abad4e":"# now we can remove the original battery column...\nphones.drop(columns=['battery'],inplace=True)","f7655564":"# begin work on display_resolution feature\nphones.display_resolution.head()","627cfc44":"# extract regex from display_resolution feature\na = phones.display_resolution.astype(str).apply(lambda x: \n                                        (re.findall('(\\d*\\.\\d*)\\s*inches(\\s*\\(.(\\d*\\.\\d*)|)',x))) \n\n","844da6f2":"# look at the empty regexes we got (1233 in total)\na[a.apply(lambda x: len(x) == 0)]","344e3d96":"# there are origianlly 1214 NaNs in the display_resolution column \n# regex did not work for additional 19 values\n# let's look at those values ...\nphones.display_resolution.isnull().sum()","e93e18ee":"# here are the 19 \"weird\" display_resolution values that are not NaNs\n# conclusion: we're not missing anything by getting the empty regex for these\nphones.display_resolution[~phones.display_resolution.isnull() & a.apply(lambda x: len(x) == 0)]","fb808da8":"# functions to parse data from display_resolution regex\n\ndef display_resolution_inches(regex):\n    if regex == []:\n        return np.nan\n    else:\n        return float((regex[0])[0])\n    \ndef screen_to_body_ratio(regex):\n    if regex == []:\n        return np.nan\n    elif regex[0][-1] is None:\n        return np.nan\n    else:\n        return (regex[0][-1])","c5c6fcb7":"phones['display_resolution_inches'] = a.apply(lambda x: display_resolution_inches(x))\nphones['screen_to_body_ratio_%'] = a.apply(lambda x: screen_to_body_ratio(x)).convert_objects(convert_numeric=True)","13bd7f7f":"# the display_resolution was translated into two new features:\n# 1. display_resolution_inches (float)\n# 2. screen_to_body_ratio_% (float)\nphones.head()","9dbdb30a":"# now we can remove the original display_resolution column...\nphones.drop(columns=['display_resolution'],inplace=True)","e987a211":"phones.dimentions.isnull().sum()","baa3bd7c":"# weird '-' as a value in 'dimentions'\n# there are 331 '-' and 19 nulls, that leaves us with 8628-331-19=8278 valid values\nphones.dimentions[phones.dimentions == '-'].value_counts()","d8631663":"# extract regex from \"dimentions\" feature\n# eliminate 'mm' to include min value of thickness, we get two tuples, one for mm and one for inches\na = phones.dimentions.astype(str).apply(lambda x: \n                                        (re.findall('(\\d*\\.\\d*|\\d*)\\sx\\s(\\d*\\.\\d*|\\d*)\\sx\\s(\\d*\\.\\d*|\\d*)',x))) \n# a = phones.dimentions.astype(str).apply(lambda x: \n#                                         (re.findall('(\\d*\\.\\d*|\\d*)\\sx\\s(\\d*\\.\\d*|\\d*)\\sx\\s(\\d*\\.\\d*|\\d*)\\smm',x))) \n","44821dcb":"a.head()","f4dc21b5":"phones.dimentions.head()","5caa78d6":"# check which regex reads failed (but not because there was a NaN or '-')\nphones.dimentions[a.apply(lambda x: len(x) == 0) & ~phones.dimentions.isnull() & (phones.dimentions != '-')]","168eb1ff":"# process mm thickness-only info\nb = phones.dimentions.astype(str).apply(lambda x: \n                                        (re.findall('(\\d*\\.\\d*|\\d*)\\smm\\sthickness',x)))","84bcf1a1":"# convert regex data into numerical data\n# return value as a list\ndef dimension_conversion(regex):\n    if len(regex) == 0: # empty regex\n        return []\n    elif len(regex) == 1 & isinstance(regex[0],str): # regex coming from thickneww only data\n        new_regex = []\n        try:            \n            new_regex.append(float(regex[0]))\n        except:\n            pass\n        return new_regex\n    elif (len(regex) >= 1) & isinstance(regex[0],tuple): # regex coming from full dimension data\n        new_regex = list(regex[0])\n        for i in range(len(new_regex)):\n            try:\n                new_regex[i] = float(regex[0][i])\n            except:\n                pass\n        return new_regex\n    else:\n        return []","d7e77e9f":"# combine dimensions data\n# data that did not match one of the following (but wasn't NaN) was converted into NaN\n# 1. number x number x number mm\n# 2. number mm thickness\n# 3. '-'\nc = a.apply(lambda x: dimension_conversion(x)) + b.apply(lambda x: dimension_conversion(x))","934f3d26":"# define functions to extract data on each dimension\ndef length(x):\n    if len(x) == 3:\n        if x[0] is not None:\n            return x[0]\n        else:\n            return np.nan\n    else:\n        return np.nan\n    \ndef width(x):\n    if len(x) == 3:\n        if x[1] is not None:\n            return x[1]\n        else:\n            return np.nan\n    else:\n        return np.nan\n    \ndef thickness(x):\n    if len(x) == 3:\n        if x[2] is not None:\n            return x[2]\n        else:\n            return np.nan\n    elif len(x) == 1:\n        if x[0] is not None:\n            return x[0]\n        else:\n            return np.nan\n    else:\n        return np.nan","163c2a49":"length = c.apply(lambda x: length(x))","bbc0cb14":"width = c.apply(lambda x: width(x))","cc18e291":"thickness = c.apply(lambda x: thickness(x))","a404a1fb":"# test thickness function against original b values\nthickness[c.apply(lambda x: len(x) == 1)]","665b9738":"# test thickness function against NaNs\nthickness[c.apply(lambda x: len(x) == 0)]","c44ee678":"phones['length_mm'] = length\nphones['width_mm'] = width\nphones['thickness_mm'] = thickness","063d5cbd":"phones.drop(columns=['dimentions'],inplace=True)","d600a493":"phones.internal_memory.value_counts()","e909b4a0":"# process internal_memory info\na = phones.internal_memory.astype(str).apply(lambda x: \n                                        (re.findall('(?i)(\\d*|\\d*\\.\\d*)\\\/*(\\d*)\\\/*(\\d*)\\s(?=GB)|(\\d*|\\d*\\.\\d*)\\\/*(\\d*)\\\/*(\\d*)\\s(?=MB)|(\\d*|\\d*\\.\\d*)\\\/*(\\d*)\\\/*(\\d*)\\s(?=KB)',x,re.IGNORECASE)))","97666c49":"a.head(10)","0c091650":"(a.iloc[3][0][3]=='')","013ab539":"# functions for extracting internal_memory string data broken into types: GB \/ MB \/ KB\n\ndef GB(regex):\n    gb = []\n    for i in range(3):\n        for j in range(2):\n            try:\n                gb.append(float(regex[j][i])) # GB found in regex groups 1, 2, and 3\n            except:\n                pass\n    return gb\n\ndef MB(regex):\n    mb = []\n    for i in range(3):\n        for j in range(2):\n            try:\n                mb.append(float(regex[j][i+3])) # MB found in regex groups 4,5,6\n            except:\n                pass\n    return mb\n\ndef KB(regex):\n    kb = []\n    for i in range(3):\n        for j in range(2):\n            try:\n                kb.append(float(regex[j][i+6])) # KB found in regex groups 7,8,9\n            except:\n                pass\n    return kb\n\ndef GB_MB_KB(regex):\n    return [GB(regex),MB(regex),KB(regex)]","05e225de":"a.apply(lambda x: GB_MB_KB(x))","10b4fb86":"# test internal_memory with mixed types (eg, GB and MB)\na[a.apply(lambda x: len(x) == 2)]","4168c2c7":"# apply BG_MB_KB to mixed type internal_memory strings to check validity\na[a.apply(lambda x: len(x) == 2)].apply(lambda x: GB_MB_KB(x))","8f3a98ba":"a_GB = a.apply(lambda x: GB_MB_KB(x)[0])\na_MB = a.apply(lambda x: GB_MB_KB(x)[1])\na_KB = a.apply(lambda x: GB_MB_KB(x)[2])","06049d6a":"a_GB.head()","80cc862d":"a_MB.iloc[[180,1354,7351,7381]]","c1cfae53":"# test KB types\na_KB[a.apply(lambda x: GB_MB_KB(x)[2] != [])]","2bfd3ef5":"# generate three seperate columns including all internal_memory options of a given type (GB \/ MB \/ KB) as floats\n# in the next step, turn categorical...\nphones[\"internal_memory_BG\"] = a_GB \nphones[\"internal_memory_MB\"] = a_MB\nphones[\"internal_memory_KB\"] = a_KB","7abdd64e":"phones.RAM.value_counts()","5ec40afe":"phones_new=phones[phones['approx_price_EUR'].isnull()==0]","9d265a3b":"sns.heatmap(phones_new.isnull(),yticklabels=False,cbar=False,cmap='viridis')","9dd2e74f":"phones_new.drop('NFC',axis=1,inplace=True)","58724fbe":"phones_new.drop('4G_bands',axis=1,inplace=True)","31ecbdca":"# GPU  (graphics processing unit) column will be categorial type\n\na_regex = '(\"\"|Adreno|Intel|Mali|Broadcom|PowerVR|ULP|Vivante|Nvidia|Kepler|3D|Mediatek|SGX531u|VideoCore)'\nGPU_replacements = {'':0, 'Adreno':1,'Intel':2,'Mali':3,'Broadcom':4,'PowerVR':5,'ULP':6,'Vivante':7,'Nvidia':8,'Kepler':9\n                   ,'3D':10,'Mediatek':11,'SGX531u':12,'VideoCore':13}\n\n#Extract Using Regex\nphones_new['GPU_new'] = phones_new['GPU'].str.extract(a_regex).fillna('')\n#Look up values from dictionary\nphones_new['GPU_new'] = phones_new['GPU_new'].apply(lambda x: GPU_replacements.get(x,''))\n#Use default value from other coumn if no other value\n","a8ccde55":"phones_new['GPU_new'].value_counts()","828a9a12":"# indexing brands\nbrands=[]\nphones_new['brand_idx']=999\nx=1\nbrands.append(phones_new['brand'].iloc[0])\nphones_new['brand_idx'].iloc[0]=1\ni=1\nfor i in range(1,len(phones_new['brand'])-1):\n    if phones_new['brand'].iloc[i] in brands:\n        phones_new['brand_idx'].iloc[i]=brands.index(phones_new['brand'].iloc[i])+1\n    else:\n        x=x+1\n        brands.append(phones_new['brand'].iloc[i])\n        phones_new['brand_idx'].iloc[i]=x","dcac36f0":"# indexing models - irrelavant\n# models=[]\n# phones_new['model_idx']=999\n# x=1\n# models.append(phones_new['model'].iloc[0])\n# phones_new['model_idx'].iloc[0]=1\n# i=1\n# for i in range(1,len(df_new['model'])-1):\n#     if phones_new['model'].iloc[i] in models:\n#         phones_new['model_idx'].iloc[i]=models.index(phones_new['model'].iloc[i])+1\n#     else:\n#         x=x+1\n#         models.append(phones_new['model'].iloc[i])\n#         phones_new['model_idx'].iloc[i]=x","7d542075":"phones_new['year'] = phones_new['announced'].str.extract('(\\d\\d\\d\\d)', expand=True)\nphones_new['year'].fillna(phones_new['year'].value_counts().index[0],inplace=True)\nphones_new['year'].value_counts()","fee5601f":"a_regex = '(January|February|March|April|May|June|July|August|September|October|November|December)'\nmonth_replacements = {'January':1, 'February':2,\n            'March':3,'April':4 ,'May':5,'June':6,'July':7,'August':8,'September':9,'October':10,'November':11, 'December':12}\n\n#Extract Using Regex\nphones_new['Month'] = phones_new['announced'].str.extract(a_regex).fillna('')\n#Look up values from dictionary\nphones_new['Month'] = phones_new['Month'].apply(lambda x: month_replacements.get(x,''))\n#Use default value from other coumn if no other value","5a996c98":"# create a list of ratio of each month in data to complete missing data\nratio=[]\nfor i in range (1,13):\n    a=(phones_new['Month']==i).sum()\/(sum(phones_new['Month'].value_counts())-(phones_new['Month']==\"\").sum())*(phones_new['Month']==\"\").sum()\n    ratio.append(round(a))\nratio\n# sum(df_new['Month'].value_counts())","1ef0eb2a":"#creating new column-Month_new to replace \"\" with the number of month by ratio\nphones_new['Month_new']=999\nj=0 # place in list\nk=1\nl=1\nfor i in range(0, len(phones_new)):\n    if phones_new['Month'].iloc[i]==\"\":\n        if k<=ratio[j]:\n            phones_new['Month_new'].iloc[i]=l\n            k=k+1\n        else:\n            k=1\n            l=l+1\n            j=j+1\n    else:\n         phones_new['Month_new'].iloc[i]=phones_new['Month'].iloc[i]","a33e48f2":"phones_new['Month_new'].replace(999,12,inplace=True)\nphones_new['Month_new'].value_counts()","f71abdfe":"#creating a binary column - GPS_new if there is a GPS in model\ncheck_list = ['Yes', 'GPS']\nregstr = '|'.join(check_list)\nphones_new['GPS_new']=phones_new['GPS']\n# df_new['GPS_new'] = np.where(df_new['GPS'].isin(check_list),'YES','NO')\nphones_new['GPS_new']=phones_new['GPS_new'].str.contains(regstr, case=False, na=False)","9560b1f3":"phones_new['primary_cam_MP']=phones_new[\"primary_camera\"].str.split(' ',expand=True)[0]\nphones_new['primary_cam_MP'].fillna(0,inplace=True)\nphones_new['primary_cam_MP'].replace('2MP',2,inplace=True)\nphones_new['primary_cam_MP'].replace('5MP|',5,inplace=True)\nphones_new['primary_cam_MP'].replace('600',0,inplace=True)\nphones_new['primary_cam_MP'].replace(['SVGA','Yes.','QVGA','Yes|','CIF','No','VGA|','Yes','Dual','VGA'],0,inplace=True)\n\n","3853825a":"phones_new['secondary_cam_MP']=phones_new[\"secondary_camera\"].str.split(' ',expand=True)[0]\nphones_new['secondary_cam_MP'].fillna(0,inplace=True)","07eb9ad1":"phones_new['secondary_cam_MP'].replace('8MP',8,inplace=True)\nphones_new['secondary_cam_MP'].replace('1.3MP',1.3,inplace=True)\nphones_new['secondary_cam_MP'].replace(['No','Yes','QCIF','0.','QVGA','Videocalling','CIF','0','VGA|','HD','Dual','VGA','Spy','VGA@15fps','QCIF@15fps','VGA\/','720p','Videocall',],0,inplace=True)","cd8b2721":"# OS  (Operation System) column will be int type\n\na_regex = '(\"\"|Android|Windows|Firefox|iOS|BlackBerry|Linux|webOS|Sailfish|Nokia|Symbian|Tizen)'\nOS_replacements = {'':0, 'Android':1,'Windows':2,'Firefox':3,'iOS':4,'BlackBerry':5,'Linux':6,'webOS':7,'Sailfish':8,'Nokia':9\n                   ,'Symbian':10,'Tizen':11}\n\n#Extract Using Regex\nphones_new['OS'] = phones_new['OS'].str.extract(a_regex).fillna('')\n#Look up values from dictionary\nphones_new['OS'] = phones_new['OS'].apply(lambda x: OS_replacements.get(x,''))\n#Use default value from other coumn if no other value\n","c0e74d8e":"# drop rows with NAN and 0\nphones_new=phones_new[phones_new['length_mm']!=0]\nphones_new=phones_new[phones_new['length_mm']!=\"\"]","ee4a61e9":"#change data types (length_mm,Year, primary_cam_MP, secondary_cam_MP) to numeric\nphones_new['year'] = phones_new['year'].apply(lambda x: int(x))\nphones_new['primary_cam_MP'] = phones_new['primary_cam_MP'].apply(lambda x: float(x))\nphones_new['secondary_cam_MP'] = phones_new['secondary_cam_MP'].apply(lambda x: float(x))\nphones_new['length_mm']=phones_new['length_mm'].apply(lambda x: float(x))\n","c9641f20":"# drop columns with over 1,000 empty cells\nphones_new.drop(['3G_bands','CPU','network_speed','Chipset','sensors','GPU','RAM'], axis=1, inplace=True)\nsns.heatmap(phones_new.isnull(),yticklabels=False,cbar=False,cmap='viridis')","5937b4e5":"# SUM PRICES OVER THE YEARS\ngroup_year_prices=phones_new.groupby('year')['approx_price_EUR'].sum()\ngroup_year_prices.plot.bar()","1f9e7d33":"# MEAN PRICES PER YEAR\ngroup_year_prices_mean=phones_new.groupby('year')['approx_price_EUR'].mean()\ngroup_year_prices_mean.plot.bar()\n\n# 2003 AND 2017 SEEMS TO BE WITH OUTLIERS - NEED TO BE CHECKED","2316526c":"\nax = sns.boxplot(x='year', y='approx_price_EUR', data=phones_new[phones_new['year']==2017])\n# OVER 5000 EURO'S - not reasonable","0eedf667":"# Checking outliers by months\nphones_new_month=phones_new[['Month_new','approx_price_EUR']]\nplt.figure(figsize=(12,8))\nax = sns.boxplot(x=\"Month_new\", y=\"approx_price_EUR\", data=phones_new_month,palette=\"Set3\")\nplt.show()\n\n#Several samples over ~1,000 euro, to be dropped\n","98f0eaef":"# DECLARE RANGES AND CHECK NUMBER OF SAMPLES IN EACH RANGE\nbins = [0,100, 200, 300, 400, 500,600,700,800,900,1000, np.inf]\nnames = ['0-100','101-200', '201-300', '301-400', '401-500', '501-600','601-700','701-800','801-900','901-1000','1001+']\n\nphones_new['Range'] = pd.cut(phones_new['approx_price_EUR'], bins, labels=names)\nphones_new['Range'].value_counts(dropna=False)","2c41bb9e":"# drop rows where price is over 1000 EURO\nphones_new = phones_new.drop(phones_new[(phones_new['approx_price_EUR'] >=1000)].index)","386de69c":"# Check prices after dropping outliers - yearly\nphones_new_year=phones_new[['year','approx_price_EUR']]\nplt.figure(figsize=(22,8))\nax = sns.boxplot(x=\"year\", y=\"approx_price_EUR\", data=phones_new_year,palette=\"Set3\")\nplt.show()","fa95439d":"# Check prices after dropping outliers - monthly\nphones_new_month=phones_new[['Month_new','approx_price_EUR']]\nplt.figure(figsize=(12,8))\nax = sns.boxplot(x=\"Month_new\", y=\"approx_price_EUR\", data=phones_new_month,palette=\"Set3\")\nplt.show()","23bee5a0":"# creating subdata of numeric and bool features to see corr\nphones_corr=phones_new[['approx_price_EUR','OS','weight_g','weight_oz', 'GPS_new', 'primary_cam_MP', 'secondary_cam_MP','GPU_new', 'battery_mah','battery_removable',\n       'display_resolution_inches', 'screen_to_body_ratio_%', 'length_mm','brand_idx']]\nphones_corr.corr(method ='kendall')","eb46ede9":"# Heatmap of corr - check important features\ncorr=phones_corr.corr()\nfig=plt.figure(figsize=(10,6))\nax=fig.add_subplot(111)\ncax=ax.matshow(corr,cmap='coolwarm',vmin=-1, vmax=1)\nfig.colorbar(cax)\nticks=np.arange(0,len(phones_corr.columns)-1,1)\nax.set_xticks(ticks)\nplt.xticks(rotation=90)\nax.set_yticks(ticks)\nax.set_xticklabels(phones_corr.columns)\nax.set_yticklabels(phones_corr.columns)\nplt.show()","71922197":"phones_ready=phones_new[['approx_price_EUR','OS','weight_g','weight_oz', 'GPS_new', 'primary_cam_MP', 'secondary_cam_MP','GPU_new', 'battery_mah','battery_removable',\n       'display_resolution_inches', 'screen_to_body_ratio_%', 'length_mm','width_mm','brand_idx']]\n","1cb7882c":"phones_ready=phones_ready.dropna(subset=['screen_to_body_ratio_%', 'battery_mah','length_mm','width_mm','battery_removable'])\n\nphones_ready['weight_g'].fillna(phones_ready['weight_g'].mean(),inplace=True)\nphones_ready['weight_oz'].fillna(phones_ready['weight_oz'].mean(),inplace=True)\nphones_ready['battery_removable'] = phones_ready['battery_removable'].apply(lambda x: bool(x))","1e07a06c":"# Define ranges to each group for classification\nbins = [0,50, 100, 150, 200, 250,300,350,400,450,500, np.inf]\nnames = [50,100, 150, 200, 250,300,350,400,450,500,800]\n\nphones_ready['price_Range'] = pd.cut(phones_ready['approx_price_EUR'], bins, labels=names)\nphones_ready['price_Range'].value_counts(dropna=False)","0216f75a":"\nphones_ready.info()","4d1ba820":"# Define the dataframe for the model ","11365858":"# PLOTS"}}