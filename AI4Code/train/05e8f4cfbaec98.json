{"cell_type":{"b67277d3":"code","b13c2e21":"code","e9e93aac":"code","ae1d1170":"code","589b7f4c":"code","873d7acd":"code","1356ff6e":"code","d67c3ba1":"markdown","dab516f8":"markdown","be0ccfae":"markdown","8787cd08":"markdown","7a36e466":"markdown","4c065a71":"markdown"},"source":{"b67277d3":"! pip install wget;\n! pip install dna_features_viewer;\nimport wget\nimport os\nfrom Bio import SeqIO\nfrom Bio.Seq import Seq\nfrom Bio import pairwise2\nfrom Bio.pairwise2 import format_alignment\nfrom Bio.SubsMat import MatrixInfo as matlist\nfrom Bio.SeqUtils import GC\nfrom dna_features_viewer import GraphicFeature, GraphicRecord\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\n\naccession_numbers = [\n    \"MT019530\",\n    \"AY278488\",\n]\n\ngenbank_base_url = 'https:\/\/www.ncbi.nlm.nih.gov\/search\/api\/download-sequence\/?db=nuccore&id='\nsequences = {}\nfor an in accession_numbers:\n    url = genbank_base_url + an\n    if not os.path.isfile(an + '.fna'):\n        filename = wget.download(url)\n        print(\"Succesfully downloaded: \" + filename)\n    else:\n        filename = an + '.fna'\n    filename = filename  # \"\/kaggle\/working\/\"+filename\n    fasta_sequences = SeqIO.parse(open(filename), 'fasta')\n    for fasta in fasta_sequences:\n        name, sequence = fasta.id, str(fasta.seq)\n        sequences.update({name: Seq(sequence)})\n        print(name, sequence[:10] + \"...\" + sequence[-10:])\n        print()\n\ncov2 = \"MT019530.1\"\ncov1 = \"AY278488.2\"\nv1seq = sequences[cov2]\nv2seq = sequences[cov1]","b13c2e21":"def plot_gc_content(seqs, names):\n    windows = [500]#np.linspace(100, 1000, 10)\n    #windows = np.round(windows)\n    \n    plt.figure(figsize=(16, 6))\n    for seq in seqs:\n        for window in windows:\n            x = np.linspace(0, len(seq), int(len(seq)\/window))\n            x_center = []\n            y = []\n            for i, j in enumerate(x):\n                #print(x[i-1], j)\n                y.append(GC(seq[int(x[i-1]): int(j)]))\n                x_center.append(int(j-(window\/2)))\n            y.pop(0)\n            x_center.pop(0)\n            sns.lineplot(x_center, y)\n    #plt.legend(list(map(str, windows)))\n    plt.legend(names)\n    plt.title(\"GC Content Distrubution [Window Size = 1000]\");\n    \nplot_gc_content([v2seq, v1seq], [\"SARS-CoV-2\", \"SARS-CoV\"])","e9e93aac":"# Index all instances of a sub sequence\n# Returns a list indexes\ndef find_all(seq, sub_seq):\n    sub_seq_len = len(sub_seq)\n    result = seq.find(sub_seq)\n\n    indexes = []\n    while result != -1:\n        if result != -1:\n            indexes.append(result)\n        result = seq.find(sub_seq, start=result + sub_seq_len)\n        # print(result)\n    return (indexes)\n\n\n# Index all instances of a list of sub sequences\n# Returns dictionary where the key is the sub sequence\n# and the value is a list of indexes\ndef find_all_multiples(seq, sub_seqs):\n    results = {}\n    for sub_seq in sub_seqs:\n        indexes = find_all(seq, sub_seq)\n        results.update({sub_seq: indexes})\n    return (results)\n\n\n# Find open reading frames in a sequence given\n# the stop and start codons passed to the function\n# Returns a list of tuples with start and stop locations\ndef find_orf(seq, threshold, start_codon, stop_codons):\n    orf = []\n    start = seq.find(start_codon)\n    start_codon_len = len(start_codon)\n    while start != -1:\n        stop_index = []\n        for stop_codon in stop_codons:\n            stop_index.append(seq.find(stop_codon, start=start + start_codon_len))\n        stop = min(stop_index)\n        if start != -1 and (stop - start) > threshold:\n            orf.append((start+3, stop))\n        last_start = start\n        start = seq.find(start_codon, start=stop + 3)\n        if (start < last_start):\n            break\n    return (orf)\n\n# Find how many ORFs are present in a sequence (forwards and backwards) at a given minimum and maximum frame length \ndef orf_threshold_counts(seq, start_codon, stop_codon, threshold_max):\n    thresholds = np.linspace(10, threshold_max, 25)\n    y = []\n    x = []\n    for threshold in thresholds:\n        norm_orf = find_orf(seq, threshold, start_codon, stop_codon)\n        revc_orf = find_orf(seq.reverse_complement(), threshold, start_codon, stop_codon)\n        y.append(len(norm_orf) + len(revc_orf))\n        x.append(threshold)\n    return (x, y)","ae1d1170":"# %%\nstart_codon = 'ATG'\nstop_codons = ['TGA', 'TAA', 'TAG']\norf_max_length = 125\nv1x, v1y = orf_threshold_counts(v1seq, start_codon, stop_codons, orf_max_length)\nv2x, v2y = orf_threshold_counts(v2seq, start_codon, stop_codons, orf_max_length)\n\nplt.figure(figsize=(16, 6))\nsns.scatterplot(v1x, v1y)\nplot = sns.scatterplot(v2x, v2y)\n#plot.set(yscale=\"log\")\nplt.grid(True,which=\"both\",ls=\"--\",c='gray')\nplt.title('ORF Lenths')\nplt.xlabel('Length (in Nucleotides)')\nplt.ylabel('Total ORFs')\nplt.legend(['SARS-CoV-2', 'SARS-CoV'])\nplt.show()","589b7f4c":"start_codon = 'ATG'\nstop_codons = ['TGA', 'TAA', 'TAG']\norf_min_length = 20\nv2forf_indices = find_orf(v2seq, orf_min_length, start_codon, stop_codons)\nv2rorf_indices = find_orf(v2seq.reverse_complement(), orf_min_length, start_codon, stop_codons)\nv1forf_indices = find_orf(v1seq, orf_min_length, start_codon, stop_codons)\nv1rorf_indices = find_orf(v1seq.reverse_complement(), orf_min_length, start_codon, stop_codons)\n\nclass OpenReadingFrame:\n    def __init__(self, start, stop, seq, forward):\n        self.start_index = start\n        self.stop_index = stop\n        self.seq = seq\n        self.forward = forward\n        self.length = len(seq)\n\nv2orfs = []\n\nfor index in v2forf_indices:\n    new_seq = v2seq[index[0]:index[1]]\n    if len(new_seq) % 3 == 0:\n        new_orf = OpenReadingFrame(index[0],index[1], new_seq, True)\n        v2orfs.append(new_orf)\n        \n\nfor index in v2rorf_indices:\n    new_seq = v2seq.reverse_complement()[index[0]:index[1]]\n    if len(new_seq) % 3 == 0:\n        new_orf = OpenReadingFrame(index[0],index[1], new_seq, False)\n        v2orfs.append(new_orf)\n\nv1orfs = []\n\nfor index in v1forf_indices:\n    new_seq = v1seq[index[0]:index[1]]\n    if len(new_seq) % 3 == 0:\n        new_orf = OpenReadingFrame(index[0],index[1], new_seq, True)\n        v1orfs.append(new_orf)\n\nfor index in v1rorf_indices:\n    new_seq = v1seq.reverse_complement()[index[0]:index[1]]\n    if len(new_seq) % 3 == 0:\n        new_orf = OpenReadingFrame(index[0],index[1], new_seq, False)\n        v1orfs.append(new_orf)\n\nv2aa = []\nfor orf in v2orfs:\n    v2aa.append(orf.seq.translate())\n\nv1aa = []\nfor orf in v1orfs:\n    v1aa.append(orf.seq.translate())\n\nv2orfs.sort(key=lambda x: x.length)\nv2aa = sorted(v2aa, key=len)\nwith open ('proteins.txt', 'w') as f:\n    for item in v2aa:\n        f.write(\"%s\\n\" % item)\n","873d7acd":"orf = v2orfs[-2]\n#full_seq = v2seq.reverse_complement()\nseq = str(orf.seq)#str(full_seq[orf.start_index:orf.stop_index])\nseq = str(v2seq[orf.start_index-9:orf.stop_index+9])\nrecord = GraphicRecord(sequence=seq, features=[\n    GraphicFeature(start=len(seq)-5, end=len(seq)-6, strand=+1, color='#ffcccc', label=\"Stop Codon\"),\n    GraphicFeature(start=5, end=6, strand=+1, color='#ccccff', label=\"Start Codon\")\n])\n\nax, _ = record.plot(figure_width=20)\nrecord.plot_sequence(ax)\nrecord.plot_translation(ax, location=(9,len(seq)-9), long_form_translation=True)\nplt.title(\"Example Detected Protein\");","1356ff6e":"matrix = matlist.blosum62\nmax_score = 0.6\nfor protein1 in v1aa:\n    for protein2 in v2aa:\n        for alignment in pairwise2.align.globalxx(protein2, protein1):\n            score = alignment.score\/alignment.end\n            if score >= max_score:\n                max_score = score\n                print(\"Normalized Score %.3f\"%score)\n                print(format_alignment(*alignment))","d67c3ba1":"## Download GenBank sequences and Display GC Content","dab516f8":"## Compare Proteins to SARS-CoV\nI'm going to try to align the potential proteins to proteins from SARS-CoV(1) identified with the same methods.\n>GenBank: AY278488.2  \n>SARS coronavirus BJ01, complete genome  \n>https:\/\/www.ncbi.nlm.nih.gov\/nuccore\/AY278488.2  \n\nI will the BLOSUM62 scoring matrix to calculate the alignment, as this is the same scoring matrix used by protein-protein BLAST, however I still do not know which scoring matrices are optimal for a given situation.  \n\nBecause the protein sequences are small, I will do a global alignment.\nI will also normalize by length so that longer proteins are not overly favoured.\n\nThis alignment method will store the best normalized score for each alignment, and only display and store better alignments as it finds them.\n\n**I have noticed one problematic behaviour with this method, where the alignment will take mismatched amino acids and add two indels to avoid a mismatch.**","be0ccfae":"# Results:\nI've started identifying potential genes, they can be found in proteins.txt  \nI am still a novice with BLAST, so I don't know how to upload my file of random protein sequences.\nHowever, searching manually one-by-one has already yielded some meaningful results:  \n>**FLQQFMQINSHQLGAYILLETMYSRLKQAVL:**  \n>GenBank: AAR88129.1  \n>putative structure protein 2e [SARS coronavirus ZJ01]  \n  \n**This is certianly the most significant result of the excersise, as identifying the same SARS-CoV-2 protein as someone else verifies the code execution and to some extent the methodologies used to find them.**\n\nOther proteins that have been documented in other sequences, too many to check one at a time:\n\n>* FHSSGM - lots of 100% - gene ID'd  \n>-- Ostreococcus lucimarinus CCE9901  \n>-- Onthophagus taurus - beetle  \n>-- Dickeya paradisiaca - banana rot\n>* PKVCVSS  \n>* NLFAHLL  \n>-- Damsel Fish- Acanthochromis polyacanthus  \n>-- Clown Fish - Acanthochromis polyacanthus  \n>-- Sunflower Infection - Plasmopara halstedii  \n>-- Red Dates - Ziziphus jujuba  \n>* ELSLAHQSV  \n>-- Hypothetical Water Mold\n>* QICILCTTFRST  \n>-- 75% Match: Sinocyclocheilus rhinocerous - ray finned fish","8787cd08":"## Define ORF Detection Functions & Plot\nTo help with portability, a list of stop and start codons can be passed to these functions.\nThis will help when we want to search mitochondria DNA, RNA and other \"edge cases\". Because viruses must have be compatible with their hosts genetic code, I am under the impression that \"standard\" start and stop sequences are acceptable.  \nFor this detection I am using the following start and stop codons:\n> start = \"ATG\"  \n> stop = \"TGA\", \"TAA\", or \"TAG\"","7a36e466":"# Corona Virus Protein Identification\n**In this notebook I will be trying to identify proteins in SARS-CoV-2.\nTo do this, I will identify open reading frames (ORFs) iterating forwards and backwards over the sequence.\nAfter idenitifying potential open reading frames, I will translate viable ORFs into proteins, and use NCBI's BLAST to verify any potential proteins.** \n  \nTo complete this excercise, I will use pythons BioPython module which supports many free nucleotide and protein alignment functions.  \nHere is the sequence I am testing:\n>GenBank: MT019530.1  \n>Severe acute respiratory syndrome coronavirus 2 isolate BetaCoV\/Wuhan\/IPBCAMS-WH-02\/2019, complete genome  \n>https:\/\/www.ncbi.nlm.nih.gov\/nuccore\/MT019530\n\nI have learned these methods from the book: \n>**Introduction to Computational Genomics:** A Case Studies Approach  \n>Nello Cristianini, Matthew W. Hahn  \n>[Full text available here](https:\/\/eembdersler.files.wordpress.com\/2012\/02\/introduction-to-computational-genomics-a-case-studies-approach.pdf)\n\nAfter I get satifsying results with this method I will move on to Hidden Markov Models (HMM).","4c065a71":"## Read ORFs and Convert to Possible Proteins\nNow we're taking the start and stop codon indices from both sequences in forward and reverse order and extracting ORFs.  \nThen we'll translate to proteins and save the results to a file."}}