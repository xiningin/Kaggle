{"cell_type":{"f5200130":"code","0fd808ab":"code","9f7a6e0f":"code","0ef578ff":"code","706ee0fe":"code","4a78b2c9":"code","4ea4a292":"code","e66fb39c":"code","004fdab3":"code","251b4d87":"code","845a130c":"code","cd5d95b0":"code","c429c9d1":"code","8fc511a0":"code","58fe1a59":"code","c3ac23fd":"code","ecd9641b":"code","956845da":"code","de8d2b13":"code","b042dff9":"code","77c77e52":"code","6ca97dcc":"code","5569a2ab":"code","1acc3538":"code","c622a6d6":"code","ba12b682":"code","75b6a66d":"code","803285db":"code","b7a03837":"code","6f10fad4":"code","2414b673":"code","604459d6":"code","7bf69df1":"code","d5e15e0f":"code","586f0f62":"code","d831055d":"code","86b1180a":"code","b1dc9c88":"code","65ba6f02":"code","4d00f5ff":"code","dc73ad9f":"code","28e19d83":"code","49b0cb42":"code","3ca3b8aa":"code","d739ec78":"code","a5f142c6":"code","95ed3dce":"code","a691e1a0":"code","d7ea0f75":"code","de20ce29":"code","2814905e":"code","cea79c98":"code","c5df6b3b":"code","695157d8":"code","4614fcd2":"code","208c8123":"code","4750d98f":"code","dfa18334":"code","3614f718":"code","12078c47":"code","45363b3f":"code","3398ebfd":"code","7377e8a7":"code","4c78bbfd":"code","c65dbc24":"code","187b3e8e":"code","f45d4ff0":"code","6621ae32":"code","d782ba05":"code","8653ab52":"code","3bf40204":"code","20755910":"code","5b854ad0":"code","c6ecaaea":"code","e0151328":"code","d7dccd7b":"code","44fce6f1":"code","eb53ef37":"code","6b065183":"code","e831ffa8":"code","e35adfb4":"code","e01edf88":"code","2227c03f":"code","7b33b8d0":"code","184a90c1":"code","4fa202f5":"code","20cdec62":"code","fdfe7f1f":"code","46fd7743":"code","eac5812e":"code","30ca9317":"code","d3b3e593":"code","c10ec622":"code","2a989ec0":"code","419a8801":"code","7c18b3ea":"code","e375f3cd":"code","73c2d1e2":"code","986604bd":"code","f0efd5b4":"code","4e68baac":"code","fea0e29c":"code","0d33528a":"markdown","115fd7fd":"markdown","253daf1d":"markdown","30b4d7be":"markdown","e7020aa5":"markdown","8a62d4dd":"markdown","7dc15ead":"markdown","16de273f":"markdown","e52c4679":"markdown","1c5032b5":"markdown","7f1e8659":"markdown","0fcbea9f":"markdown","61869749":"markdown","866ef849":"markdown","2c4a1162":"markdown","2f0db53d":"markdown"},"source":{"f5200130":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nimport plotly.graph_objects as go\nfrom fbprophet import Prophet\nimport pycountry\nimport plotly.express as px","0fd808ab":"df = pd.read_csv('..\/input\/novel-corona-virus-2019-dataset\/covid_19_data.csv',parse_dates=['Last Update'])\ndf.rename(columns={'ObservationDate':'Date', 'Country\/Region':'Country'}, inplace=True)\n\ndf_confirmed = pd.read_csv(\"\/kaggle\/input\/novel-corona-virus-2019-dataset\/time_series_covid_19_confirmed.csv\")\ndf_recovered = pd.read_csv(\"\/kaggle\/input\/novel-corona-virus-2019-dataset\/time_series_covid_19_recovered.csv\")\ndf_deaths = pd.read_csv(\"\/kaggle\/input\/novel-corona-virus-2019-dataset\/time_series_covid_19_deaths.csv\")\n\ndf_confirmed.rename(columns={'Country\/Region':'Country'}, inplace=True)\ndf_recovered.rename(columns={'Country\/Region':'Country'}, inplace=True)\ndf_deaths.rename(columns={'Country\/Region':'Country'}, inplace=True)","9f7a6e0f":"df.head(10)","0ef578ff":"df['Date']","706ee0fe":"last_day=df.query('Date == \"03\/13\/2020\"')\nlast_day","4a78b2c9":"#Country=last_day['Country','Date','Confirmed','Deaths','Recovered']\nCountry = last_day.sort_values(\"Confirmed\",ascending=False).reset_index()\nCountry.head()","4ea4a292":"Perc_rec = (Country['Recovered'] \/ Country['Confirmed']) * 100\nPerc_death = (Country['Deaths'] \/ Country['Confirmed']) * 100\nCountry['Percentage_recovery'] = Perc_rec\nCountry['Percentage_deaths'] = Perc_death","e66fb39c":"Country['Country']","004fdab3":"plt.bar(Country['Country'][0:5], Country['Percentage_deaths'][0:5],align='center', alpha=0.5)\n#plt.xticks(y_pos, objects)\nplt.ylabel('Usage')\nplt.title('Programming language usage')\n\nplt.show()","251b4d87":"plt.bar(Country['Country'][0:5], Country['Percentage_recovery'][0:5],align='center', alpha=0.5)\n#plt.xticks(y_pos, objects)\nplt.ylabel('Usage')\nplt.title('Programming language usage')\n\nplt.show()","845a130c":"fig = go.Figure()\nfig.add_trace(go.Bar(x=Country['Country'][0:5],\n                y=Country['Percentage_deaths'][0:5],\n                name='Deaths[%]',\n                marker_color='red'\n                ))\nfig.add_trace(go.Bar(x=Country['Country'][0:5],\n                y=Country['Percentage_recovery'][0:5],\n                name='Recovered[%]',\n                marker_color='green'\n                ))\n\n\nfig.update_layout(\n    title='Worldwide Corona Virus Cases - Bar Chart',\n    xaxis_tickfont_size=14,\n    yaxis=dict(\n        title='Percentages [%]',\n        titlefont_size=16,\n        tickfont_size=14,\n    ),\n    legend=dict(\n        x=0,\n        y=1.0,\n        bgcolor='rgba(255, 255, 255, 0)',\n        bordercolor='rgba(255, 255, 255, 0)'\n    ),\n    barmode='group',\n    bargap=0.15, # gap between bars of adjacent location coordinates.\n    bargroupgap=0.1 # gap between bars of the same location coordinate.\n)\nfig.show()","cd5d95b0":"ItalyDF=df.query('Country==\"Italy\"').groupby(\"Date\")","c429c9d1":"ItalyDF.head()","8fc511a0":"Italy=df.query('Country==\"Italy\"').groupby(\"Date\")[['Confirmed', 'Deaths', 'Recovered']].sum().reset_index()\nChina=df.query('Country==\"Mainland China\"').groupby(\"Date\")[['Confirmed', 'Deaths', 'Recovered']].sum().reset_index()","58fe1a59":"Italy.tail()","c3ac23fd":"Italy.groupby('Confirmed').sum()","ecd9641b":"confirmed_IT = Italy.groupby('Date').sum()['Confirmed'].reset_index()\ndeaths_IT = Italy.groupby('Date').sum()['Deaths'].reset_index()\nrecovered_IT = Italy.groupby('Date').sum()['Recovered'].reset_index()\n\nconfirmed_CHN = China.groupby('Date').sum()['Confirmed'].reset_index()\ndeaths_CHN = China.groupby('Date').sum()['Deaths'].reset_index()\nrecovered_CHN = China.groupby('Date').sum()['Recovered'].reset_index()","956845da":"fig = go.Figure()\nfig.add_trace(go.Bar(x=confirmed_CHN['Date'],\n                y=confirmed_CHN['Confirmed'],\n                name='Confirmed CHN',\n                marker_color='red'\n                ))\nfig.add_trace(go.Bar(x=confirmed_IT['Date'],\n                y=confirmed_IT['Confirmed'],\n                name='Confirmed ITA',\n                marker_color='green'\n                ))\n\n\nfig.update_layout(\n    title='Worldwide Corona Virus Cases - Confirmed China \/ Italy',\n    xaxis_tickfont_size=14,\n    yaxis=dict(\n        title='Number of Cases',\n        titlefont_size=16,\n        tickfont_size=14,\n    ),\n    legend=dict(\n        x=0,\n        y=1.0,\n        bgcolor='rgba(255, 255, 255, 0)',\n        bordercolor='rgba(255, 255, 255, 0)'\n    ),\n    barmode='group',\n    bargap=0.15, # gap between bars of adjacent location coordinates.\n    bargroupgap=0.1 # gap between bars of the same location coordinate.\n)\nfig.show()","de8d2b13":"new_cases_CHN = confirmed_CHN['Confirmed'].diff()\nnew_cases_IT = confirmed_IT['Confirmed'].diff()","b042dff9":"fig = go.Figure()\nfig.add_trace(go.Bar(x=confirmed_CHN['Date'],\n                y=new_cases_CHN,\n                name='Confirmed CHN',\n                marker_color='red'\n                ))\nfig.add_trace(go.Bar(x=confirmed_IT['Date'],\n                y=new_cases_IT,\n                name='Confirmed ITA',\n                marker_color='green'\n                ))\n\n\nfig.update_layout(\n    title='Worldwide Corona Virus Cases - Confirmed China \/ Italy',\n    xaxis_tickfont_size=14,\n    yaxis=dict(\n        title='Number of New Cases',\n        titlefont_size=16,\n        tickfont_size=14,\n    ),\n    legend=dict(\n        x=0,\n        y=1.0,\n        bgcolor='rgba(255, 255, 255, 0)',\n        bordercolor='rgba(255, 255, 255, 0)'\n    ),\n    barmode='group',\n    bargap=0.15, # gap between bars of adjacent location coordinates.\n    bargroupgap=0.1 # gap between bars of the same location coordinate.\n)\nfig.show()","77c77e52":"from plotly.subplots import make_subplots\nfig = make_subplots(rows=1, cols=2)\n#fig = go.Figure()\nfig.add_trace(go.Bar(x=confirmed_CHN['Date'],\n                y=new_cases_CHN,\n                name='Confirmed CHN',\n                marker_color='red'),\n                1, 1\n                )\nfig.add_trace(go.Bar(x=confirmed_IT['Date'],\n                y=new_cases_IT,\n                name='Confirmed ITA',\n                marker_color='green'),\n                1, 2\n                )\n\n\nfig.update_layout(\n    title='Worldwide Corona Virus Cases - Confirmed China \/ Italy',\n    xaxis_tickfont_size=14,\n    yaxis=dict(\n        title='Number of Cases',\n        titlefont_size=16,\n        tickfont_size=14,\n    ),\n    legend=dict(\n        x=0,\n        y=1.0,\n        bgcolor='rgba(255, 255, 255, 0)',\n        bordercolor='rgba(255, 255, 255, 0)'\n    ),\n    barmode='group',\n    bargap=0.15, # gap between bars of adjacent location coordinates.\n    bargroupgap=0.1 # gap between bars of the same location coordinate.\n)\nfig.show()","6ca97dcc":"fig = go.Figure()\nfig.add_trace(go.Bar(x=confirmed_IT['Date'],\n                y=confirmed_IT['Confirmed'],\n                name='Confirmed',\n                marker_color='blue'\n                ))\nfig.add_trace(go.Bar(x=deaths_IT['Date'],\n                y=deaths_IT['Deaths'],\n                name='Deaths',\n                marker_color='Red'\n                ))\nfig.add_trace(go.Bar(x=recovered_IT['Date'],\n                y=recovered_IT['Recovered'],\n                name='Recovered',\n                marker_color='Green'\n                ))\n\nfig.update_layout(\n    title='Italy Corona Virus Cases - Confirmed, Deaths, Recovered (Bar Chart)',\n    xaxis_tickfont_size=14,\n    yaxis=dict(\n        title='Number of Cases',\n        titlefont_size=16,\n        tickfont_size=14,\n    ),\n    legend=dict(\n        x=0,\n        y=1.0,\n        bgcolor='rgba(255, 255, 255, 0)',\n        bordercolor='rgba(255, 255, 255, 0)'\n    ),\n    barmode='group',\n    bargap=0.15, # gap between bars of adjacent location coordinates.\n    bargroupgap=0.1 # gap between bars of the same location coordinate.\n)\nfig.show()","5569a2ab":"confirmed = Italy.groupby('Date').sum()['Confirmed'].reset_index()\ndeaths = Italy.groupby('Date').sum()['Deaths'].reset_index()\nrecovered = Italy.groupby('Date').sum()['Recovered'].reset_index()","1acc3538":"confirmed.columns = ['ds','y']\n#confirmed['ds'] = confirmed['ds'].dt.date\nconfirmed['ds'] = pd.to_datetime(confirmed['ds'])","c622a6d6":"confirmed.head()","ba12b682":"m = Prophet(interval_width=0.95)\nm.fit(confirmed)\nfuture = m.make_future_dataframe(periods=7)\nfuture.tail()","75b6a66d":"forecast = m.predict(future)\nforecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()","803285db":"confirmed_forecast_plot = m.plot(forecast)","b7a03837":"deaths.columns = ['ds','y']\ndeaths['ds'] = pd.to_datetime(deaths['ds'])","6f10fad4":"m = Prophet(interval_width=0.95)\nm.fit(deaths)\nfuture = m.make_future_dataframe(periods=7)\nfuture.tail()","2414b673":"forecast = m.predict(future)\nforecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()","604459d6":"deaths_forecast_plot = m.plot(forecast)","7bf69df1":"recovered.columns = ['ds','y']\nrecovered['ds'] = pd.to_datetime(recovered['ds'])","d5e15e0f":"m = Prophet(interval_width=0.95)\nm.fit(recovered)\nfuture = m.make_future_dataframe(periods=14)\nfuture.tail()","586f0f62":"forecast = m.predict(future)\nforecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()","d831055d":"recovered_forecast_plot = m.plot(forecast)","86b1180a":"#confirmed_CHN","b1dc9c88":"confirmed_CHN2 = confirmed_CHN\nconfirmed_CHN2 = confirmed_CHN2.drop(['Date'], axis=1)\nconfirmed_CHN2.index = pd.DatetimeIndex(confirmed_CHN['Date'])\n","65ba6f02":"type(confirmed_CHN2['Confirmed'][0])","4d00f5ff":"from pylab import rcParams\nimport statsmodels.api as sm\nmod = sm.tsa.statespace.SARIMAX(confirmed_CHN2['Confirmed'],\n                                order=(1, 1, 1),\n                                seasonal_order=(1, 1, 0, 12),\n                                enforce_stationarity=False,\n                                enforce_invertibility=False)\nresults = mod.fit()\nprint(results.summary().tables[1])","dc73ad9f":"results.plot_diagnostics(figsize=(16, 8))\nplt.show()","28e19d83":"pred = results.get_prediction(start=pd.to_datetime('2020-02-20'), dynamic=False)\npred_ci = pred.conf_int()\n","49b0cb42":"pred_ci.head()\n#mean_values = pred_ci['upper Confirmed'] - pred_ci['lower Confirmed'] \/ 2\n#mean_values\n","3ca3b8aa":"fig, ax = plt.subplots()\nax.plot(pred_ci.index, pred.predicted_mean, '-')\nax.plot(pred_ci.index, confirmed_CHN2['Confirmed'][-24:], '-',color='red')\nax.fill_between(pred_ci.index, pred_ci['lower Confirmed'], pred_ci['upper Confirmed'], alpha=0.2)\n#ax.plot(x, y, 'o', color='tab:brown')","d739ec78":"pred_uc = results.get_forecast(steps=20)\npred_ci_next = pred_uc.conf_int()\n#pred_uc.predicted_mean","a5f142c6":"fig, ax = plt.subplots()\nax.plot(pred_ci_next.index, pred_uc.predicted_mean, '-')\n#ax.plot(pred_ci.index, confirmed_CHN2['Confirmed'][-24:], '-',color='red')\nax.fill_between(pred_ci_next.index, pred_ci_next['lower Confirmed'], pred_ci_next['upper Confirmed'], alpha=0.2)\n#ax.plot(x, y, 'o', color='tab:brown')","95ed3dce":"confirmed_IT2 = confirmed_IT\nconfirmed_IT2 = confirmed_IT2.drop(['Date'], axis=1)\nconfirmed_IT2.index = pd.DatetimeIndex(confirmed_IT['Date'])","a691e1a0":"mod2 = sm.tsa.statespace.SARIMAX(confirmed_IT2['Confirmed'],\n                                order=(1, 1, 1),\n                                seasonal_order=(1, 1, 0, 12),\n                                enforce_stationarity=False,\n                                enforce_invertibility=False)\nresults = mod2.fit()\nprint(results.summary().tables[1])","d7ea0f75":"results.plot_diagnostics(figsize=(16, 8))\nplt.show()","de20ce29":"pred = results.get_prediction(start=pd.to_datetime('2020-02-20'), dynamic=False)\npred_ci = pred.conf_int()","2814905e":"fig, ax = plt.subplots()\nax.plot(pred_ci.index, pred.predicted_mean, '-')\nax.plot(pred_ci.index, confirmed_IT2['Confirmed'][-24:], '-',color='red')\nax.fill_between(pred_ci.index, pred_ci['lower Confirmed'], pred_ci['upper Confirmed'], alpha=0.2)\n#ax.plot(x, y, 'o', color='tab:brown')","cea79c98":"pred_uc = results.get_forecast(steps=20)\npred_ci_next = pred_uc.conf_int()\n#pred_uc.predicted_mean","c5df6b3b":"fig, ax = plt.subplots()\nax.plot(pred_ci_next.index, pred_uc.predicted_mean, '-')\n#ax.plot(pred_ci.index, confirmed_CHN2['Confirmed'][-24:], '-',color='red')\nax.fill_between(pred_ci_next.index, pred_ci_next['lower Confirmed'], pred_ci_next['upper Confirmed'], alpha=0.2)\n#ax.plot(x, y, 'o', color='tab:brown')","695157d8":"new_cases_forecast = pred_uc.predicted_mean.diff()\nnew_cases_forecast","4614fcd2":"from plotly.subplots import make_subplots\nfig = go.Figure()\nfig.add_trace(go.Bar(x=pred_ci_next.index,\n                y=new_cases_forecast,\n                name='Confirmed CHN',\n                marker_color='red'),\n                )\n\n\n\nfig.update_layout(\n    title='Worldwide Corona Virus Cases - Confirmed China \/ Italy',\n    xaxis_tickfont_size=14,\n    yaxis=dict(\n        title='Number of Cases',\n        titlefont_size=16,\n        tickfont_size=14,\n    ),\n    legend=dict(\n        x=0,\n        y=1.0,\n        bgcolor='rgba(255, 255, 255, 0)',\n        bordercolor='rgba(255, 255, 255, 0)'\n    ),\n    barmode='group',\n    bargap=0.15, # gap between bars of adjacent location coordinates.\n    bargroupgap=0.1 # gap between bars of the same location coordinate.\n)\nfig.show()","208c8123":"df.head(4)","4750d98f":"import matplotlib.pyplot as plt\nplt.plot(df.Date,df.Confirmed)","dfa18334":"df['Country'].value_counts()","3614f718":"my_dataset = ['Date','Country', 'Confirmed', 'Deaths','Recovered']","12078c47":"my_dataset_df = df[my_dataset]","45363b3f":"my_dataset_df.head()","3398ebfd":"df_Italy = my_dataset_df.where(my_dataset_df['Country']=='Italy').dropna(axis=0)","7377e8a7":"df_Italy.head()","4c78bbfd":"print(df_Italy['Confirmed'].min())\nprint(df_Italy['Confirmed'].max())","c65dbc24":"df_Italy.shape","187b3e8e":"import matplotlib.pyplot as plt\nplt.plot(df_Italy.Date,df_Italy.Confirmed)","f45d4ff0":"df = df_Italy","6621ae32":"TRAIN_SPLIT = int(0.7*(df.shape[0]))\nprint(TRAIN_SPLIT)","d782ba05":"def univariate_data(dataset, start_index, end_index, history_size, target_size):\n  data = []\n  labels = []\n\n  start_index = start_index + history_size\n  if end_index is None:\n    end_index = len(dataset) - target_size\n\n  for i in range(start_index, end_index):\n    indices = range(i-history_size, i)\n    # Reshape data from (history_size,) to (history_size, 1)\n    data.append(np.reshape(dataset[indices], (history_size, 1)))\n    labels.append(dataset[i+target_size])\n  return np.array(data), np.array(labels)","8653ab52":"uni_data = df[\"Confirmed\"]\nuni_data.index = df[\"Date\"]\nuni_data.head()","3bf40204":"uni_data = uni_data.values","20755910":"uni_train_mean = uni_data[:TRAIN_SPLIT].mean()\nuni_train_std = uni_data[:TRAIN_SPLIT].std()\nuni_data = (uni_data-uni_train_mean)\/uni_train_std","5b854ad0":"univariate_past_history = 300\nunivariate_future_target = 30\n\nunivariate_past_history = 5\nunivariate_future_target = 3\n\nx_train_uni, y_train_uni = univariate_data(uni_data, 0, TRAIN_SPLIT,\n                                           univariate_past_history,\n                                           univariate_future_target)\nx_val_uni, y_val_uni = univariate_data(uni_data, TRAIN_SPLIT, None,\n                                       univariate_past_history,\n                                       univariate_future_target)","c6ecaaea":"def create_time_steps(length):\n  return list(range(-length, 0))","e0151328":"def show_plot(plot_data, delta, title):\n  labels = ['History', 'True Future', 'Model Prediction']\n  marker = ['.-', 'rx', 'go']\n  time_steps = create_time_steps(plot_data[0].shape[0])\n  if delta:\n    future = delta\n  else:\n    future = 0\n\n  plt.title(title)\n  for i, x in enumerate(plot_data):\n    if i:\n      plt.plot(future, plot_data[i], marker[i], markersize=10,\n               label=labels[i])\n    else:\n      plt.plot(time_steps, plot_data[i].flatten(), marker[i], label=labels[i])\n  plt.legend()\n  plt.xlim([time_steps[0], (future+5)*2])\n  plt.xlabel('Time-Step')\n  return plt","d7dccd7b":"try:\n  # %tensorflow_version only exists in Colab.\n  %tensorflow_version 2.x\n  print(tf.__version__)\nexcept Exception:\n  pass","44fce6f1":"import tensorflow as tf\nfrom tensorflow.keras.layers import (Input, Activation, Dense, Flatten, Conv1D, LSTM,\n                                     MaxPooling1D, Dropout, BatchNormalization)","eb53ef37":"BATCH_SIZE = 16\nBUFFER_SIZE = 10000\n\ntrain_univariate = tf.data.Dataset.from_tensor_slices((x_train_uni, y_train_uni))\ntrain_univariate = train_univariate.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()\n\nval_univariate = tf.data.Dataset.from_tensor_slices((x_val_uni, y_val_uni))\nval_univariate = val_univariate.batch(BATCH_SIZE).repeat()","6b065183":"x_train_uni.shape[-2:]","e831ffa8":"#Define the model\n\nclass model (tf.keras.Model):\n    \n    def __init__(self):\n       \n        super(model, self).__init__()\n        \n        self.conv_1 = Conv1D(32, kernel_size=5,\n                      strides=1, padding=\"causal\",\n                      activation=\"relu\",\n                      input_shape=x_train_uni.shape[-2:]) \n        \n        self.LSTM_1 = LSTM(64, return_sequences=True)\n        self.LSTM_2 = LSTM(64, return_sequences=True) \n  \n        self.flatten = tf.keras.layers.Flatten()\n \n        self.dense_1 = tf.keras.layers.Dense(units=30, activation='relu')\n        self.dense_2 = tf.keras.layers.Dense(units=10, activation='relu')\n        self.dense_3 = tf.keras.layers.Dense(units=1)\n        \n    def call(self, inputs):\n\n        x = self.conv_1(inputs)\n        x = self.LSTM_1(x)\n        x = self.LSTM_2(x)\n                \n        x = self.flatten(x)\n        x = self.dense_1(x)     \n        x = self.dense_2(x)\n        x = self.dense_3(x)\n        \n        return x","e35adfb4":"simple_lstm_model = model()","e01edf88":"simple_lstm_model.compile(optimizer='adam', loss='mae')","2227c03f":"EVALUATION_INTERVAL = 20\nEPOCHS = 10\n\nsimple_lstm_model.fit(train_univariate, epochs=EPOCHS,\n                      steps_per_epoch=EVALUATION_INTERVAL,\n                      validation_data=val_univariate, validation_steps=50)","7b33b8d0":"for x, y in val_univariate.take(3):\n  plot = show_plot([x[0].numpy(), y[0].numpy(),\n                    simple_lstm_model.predict(x)[0]], 0, 'Simple LSTM model')\n  plot.show()","184a90c1":"df.columns","4fa202f5":"features_considered = ['Confirmed','Deaths', 'Recovered']","20cdec62":"features = df[features_considered]\nfeatures.index = df['Date']","fdfe7f1f":"def multivariate_data(dataset, target, start_index, end_index, history_size,\n                      target_size, step, single_step=False):\n  data = []\n  labels = []\n\n  start_index = start_index + history_size\n  if end_index is None:\n    end_index = len(dataset) - target_size\n\n  for i in range(start_index, end_index):\n    indices = range(i-history_size, i, step)\n    data.append(dataset[indices])\n\n    if single_step:\n      labels.append(target[i+target_size])\n    else:\n      labels.append(target[i:i+target_size])\n\n  return np.array(data), np.array(labels)","46fd7743":"BATCH_SIZE = 256\nBUFFER_SIZE = 10000\nEVALUATION_INTERVAL = 200\nEPOCHS = 10","eac5812e":"dataset = features.values\ndata_mean = dataset[:TRAIN_SPLIT].mean(axis=0)\ndata_std = dataset[:TRAIN_SPLIT].std(axis=0)\n\ndataset = (dataset-data_mean)\/data_std","30ca9317":"def multivariate_data(dataset, target, start_index, end_index, history_size,\n                      target_size, step, single_step=False):\n  data = []\n  labels = []\n\n  start_index = start_index + history_size\n  if end_index is None:\n    end_index = len(dataset) - target_size\n\n  for i in range(start_index, end_index):\n    indices = range(i-history_size, i, step)\n    data.append(dataset[indices])\n\n    if single_step:\n      labels.append(target[i+target_size])\n    else:\n      labels.append(target[i:i+target_size])\n\n  return np.array(data), np.array(labels)","d3b3e593":"BATCH_SIZE = 256\nBUFFER_SIZE = 10000\nEVALUATION_INTERVAL = 200\nEPOCHS = 10","c10ec622":"past_history = 410\nfuture_target = 100\nSTEP = 6\n\npast_history = 5\nfuture_target = 3\nSTEP = 6\n\nx_train_multi, y_train_multi = multivariate_data(dataset, dataset[:, 1], 0,\n                                                 TRAIN_SPLIT, past_history,\n                                                 future_target, STEP)\nx_val_multi, y_val_multi = multivariate_data(dataset, dataset[:, 1],\n                                             TRAIN_SPLIT, None, past_history,\n                                             future_target, STEP)","2a989ec0":"print(x_train_multi.shape)\nprint(y_train_multi.shape)\nprint(x_val_multi.shape)\nprint(y_val_multi.shape)","419a8801":"train_data_multi = tf.data.Dataset.from_tensor_slices((x_train_multi, y_train_multi))\ntrain_data_multi = train_data_multi.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()\n\nval_data_multi = tf.data.Dataset.from_tensor_slices((x_val_multi, y_val_multi))\nval_data_multi = val_data_multi.batch(BATCH_SIZE).repeat()","7c18b3ea":"#Define the model\n\nclass model (tf.keras.Model):\n    \n    def __init__(self):\n       \n        super(model, self).__init__()\n        \n        self.conv_1 = Conv1D(32, kernel_size=5,\n                      strides=1, padding=\"causal\",\n                      activation=\"relu\",\n                      input_shape=x_train_multi.shape[-2:]) \n        \n        self.LSTM_1 = LSTM(32, return_sequences=True)\n        self.LSTM_2 = LSTM(16, return_sequences=True) \n  \n        self.flatten = tf.keras.layers.Flatten()\n \n        self.dense_1 = tf.keras.layers.Dense(units=500, activation='relu')\n      ##  self.dense_2 = tf.keras.layers.Dense(units=100, activation='relu')\n        self.dense_2 = tf.keras.layers.Dense(units=3, activation='relu')\n     ##   self.dense_3 = tf.keras.layers.Dense(units=1)\n        \n    def call(self, inputs):\n\n        x = self.conv_1(inputs)\n        x = self.LSTM_1(x)\n        x = self.LSTM_2(x)\n                \n        x = self.flatten(x)\n        x = self.dense_1(x)     \n        x = self.dense_2(x)\n   ##     x = self.dense_3(x)\n        \n        return x","e375f3cd":"multi_step_model = model()","73c2d1e2":"multi_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(clipvalue=1.0), loss='mae')","986604bd":"multi_step_history = multi_step_model.fit(train_data_multi, epochs=EPOCHS,\n                                          steps_per_epoch=EVALUATION_INTERVAL,\n                                          validation_data=val_data_multi,\n                                          validation_steps=50)","f0efd5b4":"def multi_step_plot(history, true_future, prediction):\n  plt.figure(figsize=(12, 6))\n  num_in = create_time_steps(len(history))\n  num_out = len(true_future)\n\n  plt.plot(num_in, np.array(history[:, 1]), label='History')\n  plt.plot(np.arange(num_out)\/STEP, np.array(true_future), 'bo',\n           label='True Future')\n  if prediction.any():\n    plt.plot(np.arange(num_out)\/STEP, np.array(prediction), 'ro',\n             label='Predicted Future')\n  plt.legend(loc='upper left')\n  plt.show()","4e68baac":"def create_time_steps(length):\n  return list(range(-length, 0))","fea0e29c":"for x, y in val_data_multi.take(3):\n  multi_step_plot(x[0], y[0], multi_step_model.predict(x)[0])","0d33528a":"## Forecasting Recovered Cases Worldwide with Prophet (Baseline)\n\nWe perform a week's ahead forecast with Prophet, with 95% prediction intervals. Here, no tweaking of seasonality-related parameters and additional regressors are performed.","115fd7fd":"# COVID-19 Novel Coronavirus: EDA & Forecast Number of Cases","253daf1d":"### Time Series Forecasting TEST","30b4d7be":"## Transforming Data for Forecasting","e7020aa5":"## Latest Cases","8a62d4dd":"## Percentages of Deaths and Recovered over Confirmed","7dc15ead":"## Italy","16de273f":"### Forecast ITALY","e52c4679":"# Visualizations","1c5032b5":"# Forecasting Total Number of Cases Worldwide\n\n## Prophet\n\nWe use Prophet, a procedure for forecasting time series data based on an additive model where non-linear trends are fit with yearly, weekly, and daily seasonality, plus holiday effects. ","7f1e8659":"## Forecasting Confirmed Cases Worldwide with Prophet (Baseline)\n\nWe perform a week's ahead forecast with Prophet, with 95% prediction intervals. Here, no tweaking of seasonality-related parameters and additional regressors are performed.","0fcbea9f":"## Summary Plot of Italy Cases - Confirmed, Deaths & Recovered","61869749":"# Data Import, Preprocessing and EDA","866ef849":"## Italy View \/\/ China view","2c4a1162":"## COVID Analysis\n\nInspired by COVID-19 Novel Coronavirus EDA & Forecasting Cases","2f0db53d":"## Forecasting Deaths Worldwide with Prophet (Baseline)\n\nWe perform a week's ahead forecast with Prophet, with 95% prediction intervals. Here, no tweaking of seasonality-related parameters and additional regressors are performed."}}