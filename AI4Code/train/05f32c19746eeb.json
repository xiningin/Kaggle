{"cell_type":{"b5c11e51":"code","2ce538b4":"code","6eb5743f":"code","536d013c":"code","a9be618a":"code","951f4171":"code","b2ca4703":"code","ae02eefd":"code","6df13699":"code","9f8f5892":"code","8ec2f289":"code","58988572":"code","265af9f5":"code","1e932d01":"code","6bc9e67f":"code","7ac49227":"code","89e3e803":"code","6393d220":"code","9f23bcac":"code","e68c56dc":"code","a2847fad":"code","23a44cad":"code","4412730e":"code","2a05b688":"code","2fdf06ae":"code","d18cbbf2":"code","bac32cd2":"code","42b517ac":"code","2d9d0418":"code","f091ee02":"code","cfaf765b":"code","ea601a78":"code","bb6cc06d":"code","b042671f":"code","00afd4e2":"code","220e1856":"code","d03af0d8":"code","5fce2e33":"code","c0572376":"code","284cbf26":"code","287249e5":"code","91716e25":"code","37bed43b":"code","91acc687":"markdown","f6fd2f63":"markdown"},"source":{"b5c11e51":"#Resources\n#https:\/\/www.youtube.com\/watch?v=GO420aMtHfk&t=2037s","2ce538b4":"import pandas as pd\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport os","6eb5743f":"for dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","536d013c":"df = pd.read_csv('\/kaggle\/input\/kaggle-survey-2021\/kaggle_survey_2021_responses.csv')\ndf.shape","a9be618a":"df.describe()","951f4171":"df.dtypes","b2ca4703":"df.head()","ae02eefd":"# Remove the top row\ndf = df.iloc[1:, :]","6df13699":"# let's take a look at null values\ndf.isnull().sum() \/ df.shape[0]","9f8f5892":"questions = {} \n# Key => question number\n# Value => dataframe includes all answers (some has multiple answers or parts)\n\n# let's start with keys\nkeys = list(dict.fromkeys([i.split('_')[0] for i in df.columns])) # Q1_Part_1","8ec2f289":"# for instance, each question that starts with (Q4) should be put together in the same df\n# note: for Q1 if we use (startswith) questions like Q11,Q12, Q13, ... will be put accedently with Q1\n# goes the same for Q2 and Q3\n\nfor key in keys:\n    if key in ['Q1','Q2', 'Q3']:\n        questions[key] = df[key]\n    else:\n        questions[key] = df[[q for q in df.columns.values if q.startswith(key)]]   ","58988572":"# let's look at kagglers age dist\nfig = px.histogram(df, x=\"Q1\")\nfig.show()","265af9f5":"# look at age VS how many years they've been writing code\n# my guiss is older people tend to write more code, let's see\n# this time i'll use heatmap\nfig = px.density_heatmap(df, x='Q1', y='Q6', category_orders={'Q1': ['18-21','22-24','25-29','30-34','35-39','40-44','45-49','50-54', '55-59','60-69','70+'], 'Q6': ['I have never written code', '<1 year', '1-2 years', '3-5 years', '5-10 years', '10-20 years', '20+ years']})\nfig.show()","1e932d01":"# Q7 look at programming languages\n# Rename columns to be (python, R, SQL, ....) instead of (Q7_Part_1, Q7_Part_2,...)\n# so basically I will reanme each columns with the most frequesnt value\nquestions['Q7'].columns = list(questions['Q7'].mode().values)\n\n\n# transform it to be each skill and the count\nq7 = questions['Q7'].count().reset_index()\n\n# rename columns from (level_0, 0) to (language, count)\nq7.columns = ['language', 'count']\n# sort by count\nq7 = q7.sort_values('count', ascending=False)\n\nfig = px.bar(q7, x='language', y='count')\nfig.show()","6bc9e67f":"q = questions['Q7'].copy()\nq = q.assign(Roles=df['Q5'])\nq.columns","7ac49227":"# I wanna understand everything like (eduaction level, pay, ...) by postion or role (data scientis, analyst,...)\n# I will use the same approach to create data snippits for each role","89e3e803":"roles = {}\n\nfor role in df['Q5'].unique():\n    roles[role] = df[df['Q5'] == role]","6393d220":"roles.keys()","9f23bcac":"# How does education level (Q4) vary by role","e68c56dc":"# let's first look at the whole thing\nedu = df['Q4'].value_counts()\nfig = px.bar(q7, x=edu.index, y=edu)\nfig.show()","a2847fad":"# what about data scientis\nds_edu = roles['Data Scientist']['Q4'].value_counts()\nfig = px.bar(q7, x=ds_edu.index, y=ds_edu)\nfig.show()","23a44cad":"# wow, most data scientists tend to get a master degree\n# but you still can be a data scientist with bachelor's degree. Thank god","4412730e":"# let's make it for some roles\n# have googled on how to filter df using dropdown menu and got it in the answer below\n#https:\/\/stackoverflow.com\/questions\/59406167\/plotly-how-to-filter-a-pandas-dataframe-using-a-dropdown-menu\n\nfig = go.Figure()\nfig.update_layout(\n    title=\"Education Level By Role\",\n    xaxis_title=\"Education Level\",\n    yaxis_title=\"Count\",\n)\n\n# set up ONE trace\n\nfig.add_trace(go.Bar(x=edu.index, y=edu.values))\n\nbuttons = []\n\nfor role in roles.keys():\n    buttons.append(dict(method='restyle',\n                            label=role,\n                            visible=True,\n                            args=[{'y':[roles[role]['Q4'].value_counts().values],\n                                   'x':[roles[role]['Q4'].value_counts().index],\n                                   'type':'bar'}, [0]],\n                            ))\n\n# # Have no clue what is that and how it works, just wanna something to show\nupdatemenu = []\nyour_menu = dict()\nupdatemenu.append(your_menu)\n\nupdatemenu[0]['buttons'] = buttons\nupdatemenu[0]['direction'] = 'down'\nupdatemenu[0]['showactive'] = True\n\n# add dropdown menus to the figure\nfig.update_layout(showlegend=False, updatemenus=updatemenu)\nfig.show()","2a05b688":"# makes sense that role like research sientists are most likely to have a doctoral degree\n# Data scientists most likely to have a master degree but again a lot don't","2fdf06ae":"# will try to make bars represent percentage instead of row numbers","d18cbbf2":"fig = go.Figure()\nfig.update_layout(\n    title=\"Comparing Education Level By Role\",\n    xaxis_title=\"Education Level\",\n    yaxis_title=\"persent\",\n)\n\n# set up ONE trace\n\n# let's make y as percent instead of row numbers\nfig.add_trace(go.Bar(name='Role', x=edu.index, y=(edu.values\/edu.sum())))\n\nbuttons = []\n\nfor role in roles.keys():\n    role_edu = roles[role]['Q4'].value_counts()\n    buttons.append(dict(method='restyle',\n                            label=role,\n                            visible=True,\n                            args=[{'y':[role_edu.values\/(role_edu.sum())],\n                                   'x':[role_edu.index],\n                                   'type':'bar'}, [0]],\n                            ))\n\n# # Have no clue what is that and how it works, just wanna something to show\nupdatemenu = []\nyour_menu = dict()\nupdatemenu.append(your_menu)\n\nupdatemenu[0]['buttons'] = buttons\nupdatemenu[0]['direction'] = 'down'\nupdatemenu[0]['showactive'] = True\n\n# add dropdown menus to the figure\nfig.update_layout(showlegend=False, updatemenus=updatemenu)\nfig.show()","bac32cd2":"# it turns out the around 50% of data scientists have master degree","42b517ac":"# Let's try to compare edu by roles in the same graph\n# let's create two dropdowns","2d9d0418":"fig = go.Figure()\nfig.update_layout(\n    title=\"Comparing Education Level By Role\",\n    xaxis_title=\"Education Level\",\n    yaxis_title=\"persent\",\n)\n\n# set up ONE trace\n\n# let's make y as percent instead of row numbers\nfig.add_trace(go.Bar(name=\"1st selection\", x=edu.index, y=(edu.values\/edu.sum())))\n\n\n\n\n# it figures out we can create two button lists\nbuttons1 = []\nbuttons2 = []\n\nfor role in roles.keys():\n    role_edu = roles[role]['Q4'].value_counts()\n    buttons1.append(dict(method='restyle',\n                            label=role,\n                            visible=True,\n                            args=[{'y':[role_edu.values\/(role_edu.sum())],\n                                   'x':[role_edu.index],\n                                   'type':'bar'}, [0]],\n                            ))\n    \n# it figures out we can add one more trace and buttons to display two roles at a time\nfig.add_trace(go.Bar(name='2nd selection', x=edu.index, y=(edu.values\/edu.sum())))   \n\nbuttons2 = []\n\nfor role in roles.keys():\n    role_edu = roles[role]['Q4'].value_counts()\n    buttons2.append(dict(method='restyle',\n                            label=role,\n                            visible=True,\n                            args=[{'y':[role_edu.values\/(role_edu.sum())],\n                                   'x':[role_edu.index],\n                                   'type':'bar'}, [1]], # just played around this index (0,1) and it figures\n                                                         # 0 for 1st trace and 1 for the second, not sure but it works\n                            ))\n    \n\n# I've got this now, we can use it to customize each button\n#https:\/\/plotly.com\/python\/reference\/layout\/updatemenus\/\nupdatemenu = [\n    dict(buttons=buttons1,\n         direction='down',\n         pad={'r': 10, 't': 10, 'b': 10},\n         showactive=True,\n         x=0.1,\n         xanchor='left',\n         y=1.23,\n         yanchor='top'\n        ),\n    dict(buttons=buttons2,\n         direction='down',\n         pad={'r': 10, 't': 10},\n         showactive=True,\n         x=0.5,\n         xanchor='left',\n         y=1.23,\n         yanchor='top'\n        )\n]\n\n# add dropdown menus to the figure\nfig.update_layout(updatemenus=updatemenu)\nfig.update_layout(annotations = [\n    dict(text = '1st selection', x = 0, xref='paper', y=1.15, yref='paper', align='left', showarrow=False),\n    dict(text = '2nd selection', x = 0.45, xref='paper', y=1.15, yref='paper', align='right', showarrow=False)\n\n])\nfig.show()","f091ee02":"# let's look at what programming language kagglers recommend by role\n","cfaf765b":"recommended_languages = df['Q8'].value_counts()","ea601a78":"fig = go.Figure()\nfig.update_layout(\n    title=\"Recommended languages By Role\",\n    xaxis_title=\"Programming Languages\",\n    yaxis_title=\"persent\",\n)\n\n# set up ONE trace\n\n# let's make y as percent instead of row numbers\nfig.add_trace(go.Bar(name=\"1st selection\", x=recommended_languages.index, y=(recommended_languages.values\/recommended_languages.values.sum())))\n\n\n\n\n# it figures out we can create two button lists\nbuttons1 = []\n\nbuttons1.append(dict(method='restyle',\n                            label='All data',\n                            visible=True,\n                            args=[{'y':[recommended_languages.values\/(recommended_languages.sum())],\n                                   'x':[recommended_languages.index],\n                                   'type':'bar'}, [0]],\n                            ))\n\nfor role in roles.keys():\n    recommended_languages_byrole = roles[role]['Q8'].value_counts()\n    buttons1.append(dict(method='restyle',\n                            label=role,\n                            visible=True,\n                            args=[{'y':[recommended_languages_byrole.values\/(recommended_languages_byrole.sum())],\n                                   'x':[recommended_languages_byrole.index],\n                                   'type':'bar'}, [0]],\n                            ))\n    \n# it figures out we can add one more trace and buttons to display two roles at a time\nfig.add_trace(go.Bar(name='2nd selection', x=recommended_languages.index, y=(recommended_languages.values\/recommended_languages.values.sum())))   \n\nbuttons2 = []\n\nbuttons2.append(dict(method='restyle',\n                            label='All data',\n                            visible=True,\n                            args=[{'y':[recommended_languages.values\/(recommended_languages.sum())],\n                                   'x':[recommended_languages.index],\n                                   'type':'bar'}, [1]],\n                            ))\n\nfor role in roles.keys():\n    recommended_languages_byrole = roles[role]['Q8'].value_counts()\n    buttons2.append(dict(method='restyle',\n                            label=role,\n                            visible=True,\n                            args=[{'y':[recommended_languages_byrole.values\/(recommended_languages_byrole.sum())],\n                                   'x':[recommended_languages_byrole.index],\n                                   'type':'bar'}, [1]], # just played around this index (0,1) and it figures\n                                                         # 0 for 1st trace and 1 for the second, not sure but it works\n                            ))\n    \n\n# I've got this now, we can use it to customize each button\n#https:\/\/plotly.com\/python\/reference\/layout\/updatemenus\/\nupdatemenu = [\n    dict(buttons=buttons1,\n         direction='down',\n         pad={'r': 10, 't': 10, 'b': 10},\n         showactive=True,\n         x=0.1,\n         xanchor='left',\n         y=1.15,\n         yanchor='top'\n        ),\n    dict(buttons=buttons2,\n         direction='down',\n         pad={'r': 10, 't': 10},\n         showactive=True,\n         x=0.5,\n         xanchor='left',\n         y=1.15,\n         yanchor='top'\n        )\n]\n\n# add dropdown menus to the figure\nfig.update_layout(updatemenus=updatemenu)\nfig.update_layout(annotations = [\n    dict(text = '1st selection', x = 0, xref='paper', y=1.15, yref='paper', align='left', showarrow=False),\n    dict(text = '2nd selection', x = 0.45, xref='paper', y=1.15, yref='paper', align='right', showarrow=False)\n\n])\nfig.show()","bb6cc06d":"# wow. About 80% recommedned Python\n# evnen statisticians who use R most commonly, still recommend python though\n# if you coming in and trying to understand what should i learn first, pyhton is the number 1 thing","b042671f":"# so good so far, but I wanna make a kind function that can help us generate those graphs","00afd4e2":"def filter_bars(role, data):\n    df = data[data['Roles'] == role]\n    q = df.drop('Roles', axis= 1).count().reset_index()\n    q.columns = ['feature','Count']\n    return (q.feature, q.Count\/q.Count.sum())\n\ndef build_graph(question, Roles, Title):\n    \"\"\"\n        first case: questions that have multiple columns\n        I'll handle it as the same as Q7 above\n    \"\"\"\n    if isinstance(question, pd.DataFrame):\n        q_copy = question.copy()\n        q_copy.columns = list(q_copy.mode().iloc[0,:])\n        q_feature_count = q_copy.count().reset_index()\n        q_feature_count.columns = ['feature','Count']\n        q_feature_count = q_feature_count.sort_values('Count', ascending = False)\n        q_copy['Roles'] = df.Q5\n        \n        fig = go.Figure(layout=go.Layout(title= go.layout.Title(text=Title)))\n        #changed from role selection to selection 1\n        fig.add_trace(go.Bar(name= 'Selection 1', x= q_feature_count.feature, y=(q_feature_count.Count\/ q_feature_count.Count.sum())))\n\n        buttons = []\n        #added button for all data comparison\n        buttons.append(dict(method='restyle',\n                                label= 'All Samples',\n                                visible=True,\n                                args=[{'y':[(q_feature_count.Count\/ q_feature_count.Count.sum())],\n                                       'x':[q_feature_count.feature],\n                                       'type':'bar'}, [0]], # the [0] at the end lets us know they are for the first trace\n                                )\n                          )\n        \n        for i in list(Roles.keys())[1:]:\n            buttons.append(dict(method='restyle',\n                                label= i,\n                                visible=True,\n                                args=[{'y':[filter_bars(i,q_copy)[1].values],\n                                       'x':[filter_bars(i,q_copy)[0].values],\n                                       'type':'bar'}, [0]], # the [0] at the end lets us know they are for the first trace\n                                )\n                          )\n            \n        fig.add_trace(go.Bar(name= 'Selection 2', x= q_feature_count.feature, y=(q_feature_count.Count\/ q_feature_count.Count.sum())))\n\n        buttons_2 = []\n        #added button for all data comparison\n        buttons_2.append(dict(method='restyle',\n                                label= 'All Samples',\n                                visible=True,\n                                args=[{'y':[(q_feature_count.Count\/ q_feature_count.Count.sum())],\n                                       'x':[q_feature_count.feature],\n                                       'type':'bar'}, [1]], # the [0] at the end lets us know they are for the first trace\n                                )\n                          )\n        \n        for i in list(Roles.keys())[1:]:\n            buttons_2.append(dict(method='restyle',\n                                label= i,\n                                visible=True,\n                                args=[{'y':[filter_bars(i,q_copy)[1].values],\n                                       'x':[filter_bars(i,q_copy)[0].values],\n                                       'type':'bar'}, [1]], # the [0] at the end lets us know they are for the first trace\n                                )\n                          )    \n            \n        button_layer_1_height = 1.15    \n        updatemenus = list([\n            dict(buttons=buttons,\n                    direction=\"down\",\n                    pad={\"r\": 10, \"t\": 10},\n                    showactive=True,\n                    x=0.1,\n                    xanchor=\"left\",\n                    y=button_layer_1_height,\n                    yanchor=\"top\"),\n            dict(buttons=buttons_2,\n                    direction=\"down\",\n                    pad={\"r\": 10, \"t\": 10},\n                    showactive=True,\n                    x=0.50,\n                    xanchor=\"left\",\n                    y=button_layer_1_height,\n                    yanchor=\"top\")\n        ])\n        \n        fig.update_layout( updatemenus=updatemenus)\n        #added annotations next to dropdowns \n        fig.update_layout(\n            annotations=[\n                dict(text=\"Selection 1\", x=0, xref=\"paper\", y=1.1, yref=\"paper\",\n                                     align=\"left\", showarrow=False),\n                dict(text=\"Selection 2\", x=0.45, xref=\"paper\", y=1.1,\n                                     yref=\"paper\", showarrow=False)\n            ])\n        fig.update_xaxes(categoryorder= 'array', categoryarray= q_feature_count.feature)\n        fig.show()\n        \n    else:\n        print('else')\n        \"\"\"\n            2nd case is questions that have only one column like Q2 and Q8 above\n        \"\"\"\n        qnumber= question.copy()\n        vcnts = qnumber.value_counts()\n        qnumber = pd.concat([qnumber,df.Q5], axis =1)\n        qnumber.columns = ['feature','Roles']\n        \n        fig = go.Figure(layout=go.Layout(title= go.layout.Title(text=Title)))\n        #changed from role selection to selection 1\n        fig.add_trace(go.Bar(name= 'Selection 1', x= vcnts.index, y=(vcnts.values\/ vcnts.values.sum())))\n\n        buttons = []\n\n        #added button for all data comparison\n        buttons.append(dict(method='restyle',\n                                label= 'All Samples',\n                                visible=True,\n                                args=[{'y':[vcnts.values\/ vcnts.values.sum()],\n                                       'x':[vcnts.index],\n                                       'type':'bar'}, [0]], # the [0] at the end lets us know they are for the first trace\n                                )\n                          )\n        \n        for i in list(Roles.keys())[1:]:\n            qrole = qnumber[qnumber['Roles']==i].feature.value_counts()\n            buttons.append(dict(method='restyle',\n                                label= i,\n                                visible=True,\n                                args=[{'y':[qrole.values\/qrole.values.sum()],\n                                       'x':[qrole.index],\n                                       'type':'bar'}, [0]], # the [0] at the end lets us know they are for the first trace\n                                )\n                          )\n            \n        fig.add_trace(go.Bar(name= 'Selection 1', x= vcnts.index, y=(vcnts.values\/ vcnts.values.sum())))\n\n        buttons_2 = []\n\n        #added button for all data comparison\n        buttons_2.append(dict(method='restyle',\n                                label= 'All Samples',\n                                visible=True,\n                                args=[{'y':[vcnts.values\/ vcnts.values.sum()],\n                                       'x':[vcnts.index],\n                                       'type':'bar'}, [1]], # the [0] at the end lets us know they are for the first trace\n                                )\n                          )\n        \n        for i in list(Roles.keys())[1:]:\n            qrole = qnumber[qnumber['Roles']==i].feature.value_counts()\n            buttons_2.append(dict(method='restyle',\n                                label= i,\n                                visible=True,\n                                args=[{'y':[qrole.values\/qrole.values.sum()],\n                                       'x':[qrole.index],\n                                       'type':'bar'}, [1]], # the [0] at the end lets us know they are for the first trace\n                                )\n                          )\n        button_layer_1_height = 1.15    \n        updatemenus = list([\n            dict(buttons=buttons,\n                    direction=\"down\",\n                    pad={\"r\": 10, \"t\": 10},\n                    showactive=True,\n                    x=0.1,\n                    xanchor=\"left\",\n                    y=button_layer_1_height,\n                    yanchor=\"top\"),\n            dict(buttons=buttons_2,\n                    direction=\"down\",\n                    pad={\"r\": 10, \"t\": 10},\n                    showactive=True,\n                    x=0.50,\n                    xanchor=\"left\",\n                    y=button_layer_1_height,\n                    yanchor=\"top\")\n        ])\n        \n        fig.update_layout( updatemenus=updatemenus)\n        #added annotations next to dropdowns \n        fig.update_layout(\n            annotations=[\n                dict(text=\"Selection 1\", x=0, xref=\"paper\", y=1.1, yref=\"paper\",\n                                     align=\"left\", showarrow=False),\n                dict(text=\"Selection 2\", x=0.45, xref=\"paper\", y=1.1,\n                                     yref=\"paper\", showarrow=False)\n            ])\n        fig.update_xaxes(categoryorder= 'array', categoryarray= vcnts.index)\n        fig.show()\n        \n    return","220e1856":"# maybe it's not the most elegant way to do it but that's what i've come up with. I might revist it later","d03af0d8":"build_graph(questions['Q7'], roles, 'Popular Programming Language')","5fce2e33":"# Python, SQL, and R are the most popular ones\n# All people tend to use pyhton much more than R except for Statisticians :)\n# seems like analysts are using SQL a bit more than data scientists","c0572376":"build_graph(df['Q8'], roles, 'Recommended language')","284cbf26":"build_graph(questions['Q9'], roles, 'IDE')","287249e5":"build_graph(questions['Q14'], roles, 'most common data viz library')","91716e25":"build_graph(questions['Q31'], roles, 'most common PI softwares')","37bed43b":"build_graph(questions['Q38'], roles, 'Primary tool used in analytics')","91acc687":"#### We're going to do sum EDA\n- a quick look at age and ediucation level dist\n- Try to comapre answeres by different roles (data scientist, data analyst,...)\n","f6fd2f63":"I wanna make it easier to run analysis on each question. What if I put all questions in a dictionary along with their answers as a dataframe. This would help me understand each one rather than doing filters each time. "}}