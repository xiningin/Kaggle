{"cell_type":{"5fb3fcea":"code","8e4d14f8":"code","f9d0d659":"code","9a87407d":"code","6bc327ee":"code","3a1ad837":"code","17f14303":"code","0422389b":"code","eba513c1":"code","27e3e902":"code","4dd3d4b4":"code","05ccd207":"code","5e641fe2":"code","8b980450":"code","8143fad8":"code","2a5204c7":"code","c30f7883":"code","3624ad37":"code","d48cf03e":"code","246ecb17":"markdown","fedbc690":"markdown","d0a0c13f":"markdown"},"source":{"5fb3fcea":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","8e4d14f8":"import numpy as np\nimport pandas as pd\n\nfrom sklearn import metrics\nfrom sklearn.model_selection import train_test_split\n\nimport tensorflow as tf\nfrom tensorflow.keras import layers\nfrom tensorflow import keras\nimport distutils\nimport cv2\nfrom sklearn import metrics\nfrom keras.models import Sequential\nfrom keras.layers import Dense, BatchNormalization, Dropout","f9d0d659":"train = pd.read_csv('https:\/\/raw.githubusercontent.com\/defcom17\/NSL_KDD\/master\/KDDTrain%2B.csv')\ntest = pd.read_csv('https:\/\/raw.githubusercontent.com\/defcom17\/NSL_KDD\/master\/KDDTest%2B.csv')\ntrain","9a87407d":"columns = (['duration', 'protocol_type', 'service', 'flag', 'src_bytes', 'dst_bytes', 'land',\n            'wrong_fragment', 'urgent', 'hot', 'num_failed_logins', 'logged_in', 'num_compromised',\n            'root_shell', 'su_attempted', 'num_root', 'num_file_creations', 'num_shells', 'num_access_files',\n            'num_outbound_cmds', 'is_host_login', 'is_guest_login', 'count', 'srv_count', 'serror_rate',\n            'srv_serror_rate', 'rerror_rate', 'srv_rerror_rate', 'same_srv_rate', 'diff_srv_rate', 'srv_diff_host_rate',\n            'dst_host_count', 'dst_host_srv_count', 'dst_host_same_srv_rate', 'dst_host_diff_srv_rate',\n            'dst_host_same_src_port_rate', 'dst_host_srv_diff_host_rate', 'dst_host_serror_rate',\n            'dst_host_srv_serror_rate', 'dst_host_rerror_rate', 'dst_host_srv_rerror_rate', 'attack', 'level'])\n\ntrain.columns = columns\ntest.columns = columns\n\ntrain","6bc327ee":"train.loc[train.attack == 'normal', 'is_attacked'] = 0 \ntrain.loc[train.attack != 'normal', 'is_attacked'] = 1\ntest.loc[test.attack == 'normal', 'is_attacked'] = 0 \ntest.loc[test.attack != 'normal', 'is_attacked'] = 1","3a1ad837":"train_cnt = train.shape\ntest_cnt = test.shape\ncombined_data = pd.concat([train, test])\npd.options.display.max_columns = None\ncombined_data","17f14303":"combined_data.describe()","0422389b":"for column in combined_data.columns:\n    if len(np.unique(combined_data[column].dropna().values))<15:\n        print('{}: {}'.format(column,np.unique(combined_data[column].dropna().values)))","eba513c1":"from sklearn.preprocessing import OneHotEncoder\nohe = OneHotEncoder(sparse=False) # sparse=False categorical_features=...\nnew_ohe_features = ohe.fit_transform(combined_data.protocol_type.values.reshape(-1, 1))\ntmp = pd.DataFrame(new_ohe_features, columns=['protocol_type=' + str(i) for i in range(new_ohe_features.shape[1])])\ntmp.reset_index(drop=True, inplace=True)\ncombined_data.reset_index(drop=True, inplace=True)\ncombined_data_ohe = pd.concat([combined_data, tmp], axis=1)\nnew_ohe_features = ohe.fit_transform(combined_data.service.values.reshape(-1, 1))\ntmp = pd.DataFrame(new_ohe_features, columns=['service=' + str(i) for i in range(new_ohe_features.shape[1])])\ncombined_data_ohe = pd.concat([combined_data_ohe, tmp], axis=1)\nnew_ohe_features = ohe.fit_transform(combined_data.flag.values.reshape(-1, 1))\ntmp = pd.DataFrame(new_ohe_features, columns=['flag=' + str(i) for i in range(new_ohe_features.shape[1])])\ncombined_data_ohe = pd.concat([combined_data_ohe, tmp], axis=1)\ncombined_data_ohe","27e3e902":"train_ohe = combined_data_ohe[0:train_cnt[0]]\ntrain_ohe","4dd3d4b4":"test_ohe = combined_data_ohe[0:test_cnt[0]]\ntest_ohe","05ccd207":"test_ohe = test_ohe.drop(columns=['protocol_type', 'service', 'flag', 'attack', 'level'])\ntrain_ohe = train_ohe.drop(columns=['protocol_type', 'service', 'flag', 'attack', 'level'])","5e641fe2":"y_train_ohe = train_ohe.is_attacked.to_frame()\nX_train_ohe = train_ohe.drop(columns=['is_attacked'])\ny_test_ohe = test_ohe.is_attacked.to_frame()\nX_test_ohe = test_ohe.drop(columns=['is_attacked'])","8b980450":"def create_model_dropout(n_inputs):\n\n    inputs = keras.Input(shape=(n_inputs,), name=\"input\")\n    batch = layers.BatchNormalization()(inputs)\n    layer1 = layers.Dense(256, activation=\"sigmoid\", name=\"dense1\")(batch)\n    drop = layers.Dropout(0.5)(layer1)\n    layer11 = layers.Dense(56, activation=\"relu\", name=\"dense3\")(drop)\n    drop = layers.Dropout(0.5)(layer11)\n    layer2 = layers.Dense(256, activation=\"sigmoid\", name=\"dense2\")(drop)\n    batch = layers.BatchNormalization()(layer2)\n    outputs = layers.Dense(1, activation=\"sigmoid\", name=\"out\")(batch)\n\n    return keras.Model(inputs=inputs, outputs=outputs)","8143fad8":"import keras.backend as K\n\n\ndef recall(y_true, y_pred):\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))\n    recall = true_positives \/ (possible_positives + K.epsilon())\n    return recall\n\n\ndef precision(y_true, y_pred):\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))\n    precision = true_positives \/ (predicted_positives + K.epsilon())\n    return precision","2a5204c7":"model1 = create_model_dropout(122)\nmodel1.summary()","c30f7883":"model1.compile(loss=tf.keras.losses.binary_crossentropy, optimizer=\"ADAM\", \n               metrics=['accuracy', precision, recall])","3624ad37":"history = model1.fit(X_train_ohe, y_train_ohe, batch_size=100, epochs=10)","d48cf03e":"model1.evaluate(X_test_ohe, y_test_ohe)","246ecb17":"## Categorical features","fedbc690":"## Prepare data","d0a0c13f":"## Model"}}