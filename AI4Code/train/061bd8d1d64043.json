{"cell_type":{"d53926a5":"code","9afd1e23":"code","e7881320":"code","7d4a0a9f":"code","8692c421":"code","6ff94e08":"code","8ce6e7ff":"code","5d19ba30":"code","f4252336":"code","71bf934c":"code","df6371e8":"code","7f1e5a3c":"code","18957415":"code","f5531c18":"code","6c1a309b":"code","ba7ab812":"code","9b238690":"code","177b49fd":"code","03fe190f":"code","6a4d9f77":"code","d1ae3c97":"code","9fbcc3ea":"code","fd783bc8":"code","f3ea432c":"code","36975588":"code","3d9e9539":"code","f328267e":"markdown","f36bf407":"markdown","7bc9cdd4":"markdown","66a715d0":"markdown","7aef5bf0":"markdown","c391f22e":"markdown","62b1ff6b":"markdown","be7c7a0d":"markdown"},"source":{"d53926a5":"import numpy as np\nimport pandas as pd\nimport random\nimport time\nfrom collections import deque\nfrom sklearn import preprocessing","9afd1e23":"import tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, LSTM, CuDNNLSTM, BatchNormalization\nfrom tensorflow.keras.layers import Activation, Flatten, Conv1D, MaxPooling1D\nfrom tensorflow.keras.callbacks import TensorBoard, ModelCheckpoint","e7881320":"df = pd.read_csv(\"..\/input\/LTC-USD.csv\", names = ['time','low','high','open','close','volume'])\n\ndf.head()","7d4a0a9f":"df.shape","8692c421":"df.info()","6ff94e08":"df.columns","8ce6e7ff":"SEQ_LEN = 60\nFUTURE_PERIOD_PREDICT = 3\nRATIO_TO_PREDICT = 'LTC-USD'","5d19ba30":"def classify (current, future):\n    if float(future) > float(current):\n        return 1\n    else:\n        return 0","f4252336":"def preprocess_df(df):\n    df = df.drop('future', 1)\n    \n    for col in df.columns:\n        if col != 'target':\n            df[col] = df[col].pct_change()\n            df.dropna(inplace=True)\n            df[col] = preprocessing.scale(df[col].values)\n    df.dropna(inplace=True)\n    \n    sequential_data = []\n    prev_days = deque(maxlen=SEQ_LEN)\n    \n    for i in df.values:\n        prev_days.append([n for n in i[:-1]])\n        if len(prev_days) == SEQ_LEN:\n            sequential_data.append([np.array(prev_days), i[-1]])\n    random.shuffle(sequential_data)\n    \n    buys = []\n    sells = []\n    \n    for seq, target in sequential_data:\n        if target == 0:\n            sells.append([seq, target])\n        elif target == 1:\n            buys.append([seq, target])\n    random.shuffle(buys)\n    random.shuffle(sells)\n    \n    lower = min(len(buys), len(sells))\n    buys = buys[:lower]\n    sells = sells[:lower]\n    \n    sequential_data = buys + sells\n    random.shuffle(sequential_data)\n    \n    X = []\n    y = []\n    \n    for seq, target in sequential_data:\n        X.append(seq)\n        y.append(target)\n        \n    return np.array(X), y","71bf934c":"main_df = pd.DataFrame()\nratios = ['LTC-USD', 'BCH-USD', 'BTC-USD', 'ETH-USD'] \n\nfor ratio in ratios:\n    ratio = ratio.split('.csv')[0]\n    dataset = f'..\/input\/{ratio}.csv'\n    df = pd.read_csv(dataset, names=['time','low','high','open','close','volume'])\n    df.rename(columns={'close':f'{ratio}_close','volume':f'{ratio}_volume'}, inplace=True)\n    df.set_index('time', inplace=True)\n    df = df[[f'{ratio}_close',f'{ratio}_volume']]\n    \n    if len(main_df) == 0:\n        main_df = df\n    else:\n        main_df = main_df.join(df)\n        ","df6371e8":"main_df.fillna(method='ffill', inplace=True)\nmain_df.dropna(inplace=True)\nprint(main_df.head())","7f1e5a3c":"main_df['future'] = main_df[f'{RATIO_TO_PREDICT}_close'].shift(-FUTURE_PERIOD_PREDICT)\nmain_df['target'] = list(map(classify, main_df[f'{RATIO_TO_PREDICT}_close'],main_df['future']))\nmain_df.dropna(inplace=True)\nprint(main_df.head())","18957415":"times = sorted(main_df.index.values)\nlast_5pct = sorted(main_df.index.values)[-int(0.05*len(times))]\n\nprint(time)\nprint(last_5pct)","f5531c18":"validation_main_df = main_df[(main_df.index >= last_5pct)]\ntrain_main_df = main_df[(main_df.index < last_5pct)]\n\nprint(validation_main_df.head())\nprint(train_main_df.head())","6c1a309b":"train_x, train_y = preprocess_df(train_main_df)\nvalidation_x, validation_y = preprocess_df(validation_main_df)","ba7ab812":"print(f\"train data: {len(train_x)} validation: {len(validation_x)}\")\nprint(f\"Dont buys: {train_y.count(0)}, buys: {train_y.count(1)}\")\nprint(f\"VALIDATION Dont buys: {validation_y.count(0)}, buys: {validation_y.count(1)}\")","9b238690":"print(train_x.shape[1:])","177b49fd":"EPOCHS = 10\nBATCH_SIZE = 64\nNAME = f'{SEQ_LEN}-SEQ-{FUTURE_PERIOD_PREDICT}-PRED-{int(time.time())}'","03fe190f":"rnn_model = Sequential()\n\nrnn_model.add(CuDNNLSTM(128, input_shape=(train_x.shape[1:]),return_sequences=True))\nrnn_model.add(Dropout(0.2))\nrnn_model.add(BatchNormalization())\n\nrnn_model.add(CuDNNLSTM(128,return_sequences=True))\nrnn_model.add(Dropout(0.1))\nrnn_model.add(BatchNormalization())\n\nrnn_model.add(CuDNNLSTM(128))\nrnn_model.add(Dropout(0.2))\nrnn_model.add(BatchNormalization())\n\nrnn_model.add(Dense(32, activation='relu'))\nrnn_model.add(Dropout(0.2))\n\nrnn_model.add(Dense(2, activation='softmax'))","6a4d9f77":"opt = tf.keras.optimizers.Adam(lr=0.001, decay=1e-6)","d1ae3c97":"rnn_model.compile(loss='sparse_categorical_crossentropy',\n              optimizer=opt,\n              metrics=['accuracy'])","9fbcc3ea":"tensorboard = TensorBoard(log_dir='..\/{}'.format(NAME))\n\nfilepath = 'RNN_Final-{epoch:02d}-{val_acc:.3f}'\ncheckpoint = ModelCheckpoint('..\/{}.model'.format(filepath, monitor='val-acc', verbose=1, save_best_only=True, mode='max'))\n","fd783bc8":"history = rnn_model.fit(train_x, train_y,\n                    batch_size=BATCH_SIZE,\n                    epochs=EPOCHS,\n                    validation_data=(validation_x, validation_y),\n                    callbacks = [tensorboard, checkpoint])","f3ea432c":"rnn_score = rnn_model.evaluate(validation_x, validation_y, verbose=0)\nprint('Test loss:', rnn_score[0])\nprint('Test accuracy:', rnn_score[1])","36975588":"cnn_model = Sequential()\n\ncnn_model.add(Conv1D(128,3,input_shape=(train_x.shape[1:])))\ncnn_model.add(Activation('relu'))\ncnn_model.add(Dropout(0.2))\ncnn_model.add(MaxPooling1D(pool_size=2))\n\ncnn_model.add(Conv1D(128,3))\ncnn_model.add(Activation('relu'))\ncnn_model.add(Dropout(0.2))\ncnn_model.add(MaxPooling1D(pool_size=2))\n\ncnn_model.add(Conv1D(128,3))\ncnn_model.add(Activation('relu'))\ncnn_model.add(Dropout(0.2))\ncnn_model.add(MaxPooling1D(pool_size=2))\n\ncnn_model.add(Flatten())\ncnn_model.add(Dense(32))\n\ncnn_model.add(Dense(2, activation='softmax'))\n\ncnn_model.compile(loss='sparse_categorical_crossentropy',\n                  optimizer=opt,\n                  metrics=['accuracy'])\n\ncnn_history = cnn_model.fit(train_x, train_y,\n                    batch_size=BATCH_SIZE,\n                    epochs=EPOCHS,\n                    validation_data=(validation_x, validation_y))\n","3d9e9539":"cnn_score = cnn_model.evaluate(validation_x, validation_y, verbose=0)\nprint('Test loss:', cnn_score[0])\nprint('Test accuracy:', cnn_score[1])","f328267e":"# Cryptocurrency Predict using Recurrent Neural Network(RNN) and Convolutional Neural Network(CNN)\nThis code is from [pythonprogramming.net](https:\/\/pythonprogramming.net\/cryptocurrency-recurrent-neural-network-deep-learning-python-tensorflow-keras\/) tutorial.\n\nUsing Recurrent Neural Network (RNN) and Convolutional Neural Network (CNN), this code will predict the price movement of  Bitcoin, Ethereum, Litecoin and Bitcoin Cash cryptocurrency data. The target output will be a binary of **0** for price increase and **1** for price decrease. Also, this code will show the performace of RNN vs CNN.","f36bf407":"## RNN Model","7bc9cdd4":"## Data","66a715d0":"## Parameters\n\nA sequence lenght of 60 minutes data will be collected to be feed into the model and will predict the futere in 3 minute time.","7aef5bf0":"## CNN Model","c391f22e":"## Build the Dataframe for data training and validation","62b1ff6b":"## Classify Target","be7c7a0d":"## Preprocessing Data"}}