{"cell_type":{"ff28a50e":"code","994d2c24":"code","8b549395":"code","9e89c4bd":"code","27d715ea":"code","1af6ea7f":"code","cd37c216":"code","3b383b5b":"code","4751c1cc":"code","51736a32":"code","e69f241d":"code","46a88794":"code","f412d1ba":"code","f7eb5242":"code","e35e5841":"code","6aee1584":"code","f1a5fdd5":"code","e84d6947":"code","80815cc0":"code","9f8d860d":"code","32423a8c":"code","020af801":"code","76fe6f3d":"code","16abec0c":"code","9bb8d70e":"code","9bd9085d":"markdown","e8071860":"markdown","1a76e34b":"markdown","fb489a81":"markdown","d5852e42":"markdown","438d92e1":"markdown","5d4696c1":"markdown","8d577a5d":"markdown","37976a76":"markdown","fdc89a90":"markdown","7b1e1c4b":"markdown","adcd9b68":"markdown","dff75d70":"markdown","38d3c499":"markdown","5db670db":"markdown","fca63766":"markdown","a31facf7":"markdown","7b6f42d2":"markdown","799ac917":"markdown","02edafbc":"markdown","164a7e80":"markdown","56ccadb8":"markdown","ee1aff41":"markdown","21bfc58f":"markdown","6bd01183":"markdown","3ad8a5d1":"markdown","3e1f1ace":"markdown","0feddf4e":"markdown","4597b4ac":"markdown","26325c08":"markdown","24005355":"markdown","2889671e":"markdown","2acc1013":"markdown","8789b785":"markdown","f53a371a":"markdown"},"source":{"ff28a50e":"import pandas as pd\nimport numpy as np\nimport missingno as msno\nimport seaborn as sns\nimport math\nimport re\nimport matplotlib.pyplot as plt\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.offline import init_notebook_mode, iplot\nfrom wordcloud import WordCloud, STOPWORDS\ninit_notebook_mode(connected=True)\npd.set_option('display.max_columns', None)\npd.options.mode.chained_assignment = None\n\nmovies_df = pd.read_csv('..\/input\/filmtv-movies-dataset\/filmtv_movies - ENG.csv')\nmovies_df.head(5)","994d2c24":"null_values_series = movies_df.isnull().sum().where(lambda x : x > 0).dropna().astype('Int32')\nprint(null_values_series.to_string()) # to_string() removes the name and dtype from the output\nmsno.matrix(movies_df[null_values_series.index.tolist()], figsize=(15, 8));","8b549395":"def calculation_of_field_impact_on_nas(df, field_name, filter_values_list):\n    nas_list_of_lists = []\n    for filter_value in filter_values_list:\n        filtered_df = df[df[field_name] >= filter_value]\n        nas_list_of_lists.append([filter_value] + filtered_df[null_values_series.index.tolist()].isnull().sum().tolist() + [len(filtered_df)])\n    nas_df_cols = ['filter_value'] + null_values_series.index.tolist() + ['total_records']\n    return pd.DataFrame(data=nas_list_of_lists, columns=nas_df_cols).melt(id_vars=['filter_value'],\n                                                                          value_vars=null_values_series.index.tolist() + ['total_records'],\n                                                                          var_name='field_name', value_name='nas').sort_values(by=['filter_value', 'field_name'])\n\n\ntotal_votes_filters = [1, 10, 50, 100]\nnas_df = calculation_of_field_impact_on_nas(df=movies_df, field_name='total_votes', filter_values_list=total_votes_filters)\n\n# Count of NA values based on total_votes filters\nsns.set(style='white')\n\nplt.figure(figsize=(15, 8))\nplt.title('Count of NAs based on Total Votes filters', size=20)\nax = sns.lineplot(data=nas_df, x='filter_value', y='nas', hue='field_name', palette='coolwarm')\nax.legend(title='Dataframe Field', labels=sorted(null_values_series.index.tolist()) + ['total_records'])\nplt.xlabel('Total Votes filter', size=15)\nplt.ylabel('NAs count', size=15)\nplt.xticks(total_votes_filters)\nplt.show()","9e89c4bd":"top20_movies_df = movies_df.sort_values(by='total_votes', ascending=False)[:20]\n\n# Bubble plot with the relationship between total_votes and avg_vote for the 20 most voted movies\nfig = go.Figure(data=go.Scatter(x=top20_movies_df['total_votes'], y=top20_movies_df['avg_vote'],\n                                mode='markers+text', marker=dict(size=top20_movies_df['avg_vote']**1.5, color=top20_movies_df['avg_vote']),\n                                text=top20_movies_df['title'], textposition='top center', textfont=dict(size=9),\n                                customdata=top20_movies_df['country'],\n                                hoverlabel=dict(namelength=0), # removes the trace number off to the side of the tooltip box\n                                hovertemplate='%{text}:<br>%{customdata}<br>%{x:.0f} votes<br>%{y:.1f} mean rating'))\nfig.update_layout(title='Mean Rating and Total Votes of the 20 most popular movies', template='plotly_white',\n                  title_x=0.5, legend=dict(yanchor='bottom', y=-0.15, xanchor='left', x=0, font=dict(size=10), orientation='h'),\n                  autosize=False, width=800, height=500)\nfig['layout']['xaxis']['title'] = 'Total Votes'\nfig['layout']['yaxis']['title'] = 'Mean Rating'\nfig.show()","27d715ea":"top100_movies_df = movies_df.sort_values(by='total_votes', ascending=False)[:100]\n\nfig = px.scatter(top100_movies_df, x='total_votes', y='avg_vote', color='genre',\n                 size='total_votes', hover_data=['title'])\nfig.update_layout(title='Mean Rating and Total Votes colored by Genre for the the 100 most popular movies', template='plotly_white',\n                  title_x=0.5, legend=dict(yanchor='bottom', y=-0.15, xanchor='left', x=0, font=dict(size=10), orientation='h'),\n                  autosize=False, width=800, height=500)\nfig['layout']['xaxis']['title'] = 'Total Votes'\nfig['layout']['yaxis']['title'] = 'Mean Rating'\nfig.show()","1af6ea7f":"# create three main categories of mean rating\ntop100_movies_df['mean_rating_qcut'], qcut_mean_ratings = pd.qcut(x=top100_movies_df['avg_vote'], q=3, retbins=True)\nmean_rating_labels = ['low (<' + str(qcut_mean_ratings[1]) + '\/10)',\n                   'medium (<' + str(qcut_mean_ratings[2]) + '\/10)',\n                   'high (>=' + str(qcut_mean_ratings[2]) + '\/10)']\ntop100_movies_df['mean_rating_qcut'] = pd.qcut(x=top100_movies_df['avg_vote'], q=3, labels=mean_rating_labels)\n\n# find decade of top100_movies_df\ntop100_movies_df['decade'] = (top100_movies_df['year']\/\/10)*10\nn_bins = int(((top100_movies_df['decade'].max()-top100_movies_df['decade'].min())\/10)+1)\n\n# Count of movies release year\nsns.set(style='white')\n\nplt.figure(figsize=(15, 8))\nplt.title('Count of movie Release Decades for 100 most popular movies', size=20)\nax = sns.histplot(data=top100_movies_df.sort_values(by='mean_rating_qcut', ascending=True), x='decade', stat='count', hue='mean_rating_qcut', multiple='stack',\n                  bins=n_bins, binrange=(top100_movies_df['decade'].min(), top100_movies_df['decade'].max()+10))\nax.margins(x=0)\nax.legend_.set_title('Mean Rating') # setting only the legend title, without specifying the labels (somehow seaborn kept inverting the labels order in the usual legend setup)\nplt.xlabel('Release Decade', size=15)\nplt.ylabel('Count', size=15)\nplt.xticks(np.arange(top100_movies_df['decade'].min(), top100_movies_df['decade'].max()+20, step=10), rotation=45, ha='right')\nplt.show()","cd37c216":"# create three main categories of n. actors\ntop100_movies_df['number_actors'] = [len(x.split(',')) for x in top100_movies_df['actors']]\ntop100_movies_df['number_actors_qcut'], qcut_mean_ratings = pd.qcut(x=top100_movies_df['number_actors'], q=3, retbins=True)\nmean_rating_labels = ['low (<' + str(qcut_mean_ratings[1]) + ' actors)',\n                   'medium (<' + str(qcut_mean_ratings[2]) + ' actors)',\n                   'high (>=' + str(qcut_mean_ratings[2]) + ' actors)']\ntop100_movies_df['number_actors_qcut'] = pd.qcut(x=top100_movies_df['number_actors'], q=3, labels=mean_rating_labels)\n\n# Dispersion of average ratings based on the genre\nsns.set(style='white')\nplt.figure(figsize=(15, 8))\nplt.title('Dispersion of Average Ratings per Number of Actors', fontsize=20)\nax = sns.boxplot(data=top100_movies_df, x='number_actors_qcut', y='avg_vote', palette='coolwarm')\nplt.xlabel('Number of Actors', fontsize=15)\nplt.ylabel('Average Rating', fontsize=15)\nplt.xticks(rotation=45, ha='right')\nplt.show()","3b383b5b":"# Count of movie genres\nsns.set(style='white')\n\nplt.figure(figsize=(15, 8))\nplt.title('Count of movie Genres', size=20)\ntop15_genres = movies_df['genre'].value_counts()[:15]\nax = sns.barplot(x=top15_genres.values, y=top15_genres.index, palette='coolwarm')\nplt.xlabel('Genre', size=15)\nplt.ylabel('Count', size=15)\nfor i, v in enumerate(top15_genres.values):\n    plt.text(x=40, y=i+0.12, s=v, color='k', fontsize=12.5)\nplt.show()","4751c1cc":"# Count of movies release year\nsns.set(style='white')\n\n# simplfying the genre names keeping only the two most common ones ('Drama' and 'Comedy') and naming every other genre 'Other'\ntop2_genres = movies_df['genre'].value_counts()[:2]\nmovies_df['generic_genre'] = [x if x in top2_genres.index.tolist() else 'Other' for x in movies_df['genre']]\n\nmin_year = 1920\nmax_year = max(movies_df['year'])\n\nplt.figure(figsize=(15, 8))\nplt.title('Count of movie Release Years, including the Genres sub-counts', size=20)\nax = sns.histplot(data=movies_df.sort_values(by='generic_genre', ascending=True), x='year', stat='count', bins=max_year-min_year+1, # each release year has its own bin\n                  binrange=(min_year, max_year), hue='generic_genre', multiple='stack')\nax.legend_.set_title('Genre') # setting only the legend title, without specifying the labels (somehow seaborn kept inverting the labels order in the usual legend setup)\nax.margins(x=0)\nplt.xlabel('Release Year', size=15)\nplt.ylabel('Count', size=15)\nplt.xticks(np.arange(min_year, max_year, step=5), rotation=45, ha='right')\nplt.show()","51736a32":"# Relative density of movies release year based on the genre\nsns.set(style='white')\n\nplt.figure(figsize=(15, 8))\nplt.title('Relative density of movie Release Years by Genre', size=20)\nax = sns.kdeplot(data=movies_df[movies_df['year'].astype('Int32') >= min_year].sort_values(by='generic_genre', ascending=True),\n                 x='year', hue='generic_genre', bw_adjust=.5, multiple='fill')\nax.legend_.set_title('Genre') # setting only the legend title, without specifying the labels (somehow seaborn kept inverting the labels order in the usual legend setup)\nax.margins(x=-0.05) # margins in the kdeplot must be slightly negative, otherwise seaborn includes both tails of density\nplt.xlabel('Release Year', size=15)\nplt.ylabel('Relative Density', size=15)\nplt.xticks(np.arange(min_year, max_year, step=5), rotation=45, ha='right')\nplt.show()","e69f241d":"# Dispersion of average ratings based on the genre\nsns.set(style='white')\nplt.figure(figsize=(15, 8))\nplt.title('Dispersion of Average Ratings per Genre', fontsize=20)\nax = sns.boxplot(data=movies_df[movies_df['genre'].isin(movies_df['genre'].value_counts()[:15].index.tolist())], # filtering only the movies with top15 genres\n                 x='genre', y='avg_vote', palette='coolwarm')\nplt.xlabel('Genre', fontsize=15)\nplt.ylabel('Average Rating', fontsize=15)\nplt.xticks(rotation=45, ha='right')\nplt.show()","46a88794":"movies_df['avg_vote_qcut'], qcut_avg_votes = pd.qcut(x=movies_df['avg_vote'], q=3, retbins=True)\navg_vote_labels = ['low (<' + str(qcut_avg_votes[1]) + '\/10)',\n                   'medium (<' + str(qcut_avg_votes[2]) + '\/10)',\n                   'high (>=' + str(qcut_avg_votes[2]) + '\/10)']\nmovies_df['avg_vote_qcut'] = pd.qcut(x=movies_df['avg_vote'], q=3, labels=avg_vote_labels)\n\n# Crosstab with the correlations between most common genres and average votes\nmovie_genres_crosstab = pd.crosstab(\n    movies_df[movies_df['genre'].isin(movies_df['genre'].value_counts()[:15].index.tolist())]['genre'], # filtering only the movies with top15 genres\n    movies_df[movies_df['genre'].isin(movies_df['genre'].value_counts()[:15].index.tolist())]['avg_vote_qcut'])\nmovie_genres_crosstab.style.background_gradient(cmap='summer_r')","f412d1ba":"# Estimations of average votes based on release year and broken down by genre name\nsns.set(style='white')\n\nplt.figure(figsize=(15, 8))\nplt.title('Dispersion of Average Ratings per Genre', fontsize=20)\nax = sns.lineplot(data=movies_df[movies_df['year'].astype('Int32') >= min_year].sort_values(by='generic_genre', ascending=True), x='year', y='avg_vote',\n                  ci=85, hue='generic_genre') # ci (Confidence Interval) is reduced from the default 95 so that the bands around the estimations are not too large to spoil the plot\nax.legend_.set_title('Genre') # setting only the legend title, without specifying the labels (somehow seaborn kept inverting the labels order in the usual legend setup)\nax.margins(x=0)\nplt.xlabel('Release Year', fontsize=15)\nplt.ylabel('Average Rating', fontsize=15)\nplt.xticks(np.arange(min_year, max_year, step=5), rotation=45, ha='right')\nplt.show()","f7eb5242":"top4_genres = movies_df['genre'].value_counts()[:4]\n\nfig = plt.figure(figsize=(12, 12), facecolor=None)\nfor i in range(len(top4_genres)):\n    ax = fig.add_subplot(2, 2, i+1)\n    subset = movies_df[movies_df['genre'] == top4_genres.index[i]]['description']\n    plt.title(top4_genres.index[i] + ' descriptions', fontsize=20)\n    ax.imshow(WordCloud(width=1000, height=1000, background_color='white', stopwords=set(STOPWORDS),\n                        max_words=200, min_font_size=20, random_state=42).generate(str(subset)))\n    ax.axis('off')","e35e5841":"# Count of movies release year\nsns.set(style='white')\n\nmax_duration = 210\n\n# simplfying the genre names keeping only the two most common ones ('Drama' and 'Comedy') and naming every other genre 'Other'\nplt.figure(figsize=(15, 8))\nplt.title('Count of movie Duration, including the Genres sub-counts', size=20)\nax = sns.histplot(data=movies_df[movies_df['duration'].astype('Int32') < max_duration].sort_values(by='generic_genre', ascending=True),\n                  x='duration', stat='count', bins=int(max_duration\/10), hue='generic_genre', multiple='stack')\nax.legend_.set_title('Genre') # setting only the legend title, without specifying the labels (somehow seaborn kept inverting the labels order in the usual legend setup)\nax.margins(x=0)\nplt.xlabel('Duration', size=15)\nplt.ylabel('Count', size=15)\nplt.xticks(np.arange(40, max_duration, step=10), rotation=45, ha='right')\nplt.show()","6aee1584":"# Relative density of movies release year based on the genre\nsns.set(style='white')\n\nplt.figure(figsize=(15, 8))\nplt.title('Relative density of movie Release Years by Genre', size=20)\nax = sns.kdeplot(data=movies_df[movies_df['duration'].astype('Int32') < max_duration].sort_values(by='generic_genre', ascending=True),\n                 x='duration', hue='generic_genre', bw_adjust=.5, multiple='fill')\nax.legend_.set_title('Genre') # setting only the legend title, without specifying the labels (somehow seaborn kept inverting the labels order in the usual legend setup)\nax.margins(x=-0.05) # margins in the kdeplot must be slightly negative, otherwise seaborn includes both tails of density\nplt.xlabel('Duration', size=15)\nplt.ylabel('Relative Density', size=15)\nplt.xticks(np.arange(40, max_duration, step=10), rotation=45, ha='right')\nplt.show()","f1a5fdd5":"movies_df['duration_qcut'], qcut_duration = pd.qcut(x=movies_df['duration'], q=3, retbins=True)\nduration_labels = ['short (<' + str(round(qcut_duration[1])) + ' min)',\n                   'medium (<' + str(round(qcut_duration[2])) + ' min)',\n                   'long (>=' + str(round(qcut_duration[2])) + ' min)']\nmovies_df['duration_qcut'] = pd.qcut(x=movies_df['duration'], q=3, labels=duration_labels)\n\n# Crosstab with the correlations between most duration categories and average votes\nmovie_duration_crosstab = pd.crosstab(\n    movies_df[movies_df['genre'].isin(movies_df['genre'].value_counts()[:15].index.tolist())]['genre'], # filtering only the movies with top15 genres\n    movies_df[movies_df['genre'].isin(movies_df['genre'].value_counts()[:15].index.tolist())]['duration_qcut'])\nmovie_duration_crosstab.style.background_gradient(cmap='summer_r')","e84d6947":"# Relative density of movies release year based on the genre\nsns.set(style='white')\n\nqcut_custom_dict = {avg_vote_labels[0]: 0, avg_vote_labels[1]: 1, avg_vote_labels[2]: 2}\n\nplt.figure(figsize=(15, 8))\nplt.title('Relative density of movie Average Vote by Duration (in minutes)', size=20)\nax = sns.kdeplot(data=movies_df[movies_df['duration'].astype('Int32') < max_duration].sort_values(\n    by=['avg_vote_qcut'], key=lambda x: x.map(qcut_custom_dict), ascending=True), # sorting records based on 'avg_vote_qcut', with 'low' values followed by 'medium' and 'high'\n                 x='duration', hue='avg_vote_qcut', fill=True, alpha=0.3)\nax.legend_.set_title('Average Vote') # setting only the legend title, without specifying the labels (somehow seaborn kept inverting the labels order in the usual legend setup)\nax.margins(x=-0.05) # margins in the kdeplot must be slightly negative, otherwise seaborn includes both tails of density\nplt.xlabel('Duration (in minutes)', size=15)\nplt.ylabel('Relative Density', size=15)\nplt.show()","80815cc0":"# Estimations of average votes based on release year and broken down by genre name\nsns.set(style='white')\n\nplt.figure(figsize=(15, 8))\nplt.title('Dispersion of Average Ratings per Duration category', fontsize=20)\nax = sns.lineplot(data=movies_df[(movies_df['year'].astype('Int32') >= min_year) & (movies_df['duration'].astype('Int32') < max_duration)].sort_values(\n    by='duration_qcut', ascending=True), x='year', y='avg_vote',\n                  ci=85, hue='duration_qcut') # ci (Confidence Interval) is reduced from the default 95 so that the bands around the estimations are not too large to spoil the plot\nax.legend_.set_title('Duration') # setting only the legend title, without specifying the labels (somehow seaborn kept inverting the labels order in the usual legend setup)\nax.margins(x=0)\nplt.xlabel('Release Year', fontsize=15)\nplt.ylabel('Average Rating', fontsize=15)\nplt.xticks(np.arange(min_year, max_year, step=5), rotation=45, ha='right')\nplt.show()","9f8d860d":"fig = plt.figure(figsize=(18, 6), facecolor=None)\nfor i in range(len(duration_labels)):\n    ax = fig.add_subplot(1, 3, i+1)\n    subset = movies_df[movies_df['duration_qcut'] == duration_labels[i]]['description']\n    plt.title(duration_labels[i].capitalize() + ' descriptions', fontsize=20)\n    ax.imshow(WordCloud(width=1000, height=1000, background_color='white', stopwords=set(STOPWORDS),\n                        max_words=200, min_font_size=20, random_state=42).generate(str(subset)))\n    ax.axis('off')","32423a8c":"# collecting the country codes from Wikipedia\ncountry_codes_url = 'https:\/\/en.wikipedia.org\/wiki\/List_of_ISO_3166_country_codes'\ncountry_codes_html = requests.get(country_codes_url, timeout=20)\ncountry_codes_tree = html.fromstring(country_codes_html.text)\ncountry_tags = country_codes_tree.xpath('\/\/table[contains(@class,\"wikitable sortable\")]\/tbody\/tr')\ncountry_codes_dict = {}\nfor country_tag in country_tags:\n    try:\n        country_name = country_tag.xpath('.\/td\/a')[0].text.split('(', 1)[0].split(',', 1)[0].strip(' \\t')\n        country_code = country_tag.xpath('.\/td\/a[contains(@href,\"alpha-3\")]\/span[@class=\"monospaced\"]')[0].text\n    except IndexError:\n        continue\n    country_codes_dict[country_name] = country_code\ncountry_codes_dict['United Kingdom'] = country_codes_dict.pop('United Kingdom of Great Britain and Northern Ireland')\n    \n# fixing some country names incorrectly translated with TextBlob during the translation from Italian to English (cleaning process required before loading the dataset on Kaggle)\nmovies_df['country'].replace({'Brasil': 'Brazil', # apologies for this error in the dataset, I missed that\n                              'England': 'United Kingdom', 'Great Britain': 'United Kingdom'}, regex=True, inplace=True)\n\n# unnesting the country names for the movies that have been filmed in more than one country\nunnested_countries_df = movies_df.assign(country_name=movies_df['country'].str.split(',')).explode('country_name')\nunnested_countries_df['country_name'] = unnested_countries_df['country_name'].str.strip(' \\t')\nunnested_countries_df = unnested_countries_df[(unnested_countries_df['country_name'] != '') & (unnested_countries_df['country_name'].notnull())]\n\n# manual replacement of some countries that do not correspond to the names on Wikipedia\nunnested_countries_df['country_name'].replace({\n    'Czech Republic': 'Czechia', 'Russia': 'Russian Federation', 'East Germany': 'Germany', 'West Germany': 'Germany', 'United States': 'United States of America',\n    'Vatican City': 'Holy See', 'Vietnam': 'Viet Nam', 'Syria': 'Syrian Arab Republic', 'Macedonia': 'North Macedonia', 'Macau': 'Macao', 'Republic of the Congo': 'Congo',\n    'Ivory Coast': \"C\u00f4te d'Ivoire\", 'Laos': \"Lao People's Democratic Republic\", 'Principality of Monaco': 'Monaco'}, regex=True, inplace=True)\n\n# aggregating the data to find insights from the FilmTV dataset\nagg_countries_df = unnested_countries_df.groupby('country_name').agg(\n    movies_count=pd.NamedAgg(column='filmtv_id', aggfunc=np.size),\n    mean_rating=pd.NamedAgg(column='avg_vote', aggfunc=np.mean),\n    median_rating=pd.NamedAgg(column='avg_vote', aggfunc=np.median),\n    mean_total_ratings=pd.NamedAgg(column='total_votes', aggfunc=np.mean),\n    sum_total_ratings=pd.NamedAgg(column='total_votes', aggfunc=np.sum),\n    mean_duration=pd.NamedAgg(column='duration', aggfunc=np.mean),\n    median_duration=pd.NamedAgg(column='duration', aggfunc=np.median)\n).reset_index(level=0)\n\n# mapping the country codes taken from Wikipedia, as they are required by the plotly for the geographical visualizations\n# The Korean countries cannot be automatically mapped due duplicate names on Wikipedia. Therefore the country_codes_dict is manually amended\ncountry_codes_dict['North Korea'] = 'PRK'\ncountry_codes_dict['South Korea'] = 'KOR'\nagg_countries_df['country_code'] = agg_countries_df['country_name'].map(country_codes_dict)\nagg_countries_df.sort_values(by='movies_count', ascending=False, inplace=True)\n\ncountry_names_to_replace = set([x for x in unnested_countries_df['country_name'] if x not in [x for x in country_codes_dict.keys()]])\nprint(str(len(country_names_to_replace)) + ' countries not in the Wikipedia list:')\nprint(sorted([str(x) for x in country_names_to_replace]))\n\n# agg_countries_df.head(5)","020af801":"fig = px.choropleth(data_frame=agg_countries_df, locations='country_code', color='movies_count', hover_name='country_name',\n                    color_continuous_scale='Viridis', projection='natural earth')\nfig.update_layout(title='Count of countries based on movie locations', title_x=0.5, margin={'r':0, 'l':0, 'b':0, 'pad':0})\nfig.show()","76fe6f3d":"fig = px.choropleth(data_frame=agg_countries_df[~agg_countries_df['country_name'].isin(['United States of America'])], # removing the most common country (USA)\n                    locations='country_code', color='movies_count', hover_name='country_name',\n                    scope='europe', color_continuous_scale='Viridis', projection='natural earth')\nfig.update_layout(title='Count of European countries based on movie locations', title_x=0.5, margin={'r':0, 'l':0, 'b':0, 'pad':0})\nfig.show()","16abec0c":"# Bubble plot with the relationship between movies_count and mean (y-axis) and median (marker size) ratings\nfiltered_agg_countries_df = agg_countries_df[agg_countries_df['movies_count'] > 35]\n\nfig = go.Figure(data=go.Scatter(x=filtered_agg_countries_df['movies_count'], y=filtered_agg_countries_df['mean_rating'],\n                                mode='markers+text',\n                                marker=dict(size=filtered_agg_countries_df['median_rating']**2, color=filtered_agg_countries_df['median_rating']),\n                                text=filtered_agg_countries_df['country_name'], textposition='top center', textfont=dict(size=9),\n                                customdata=filtered_agg_countries_df['median_rating'],\n                                hoverlabel=dict(namelength=0), # removes the trace number off to the side of the tooltip box\n                                hovertemplate='%{text}:<br>%{x:.0f} movies<br>%{y:.2f} mean rating<br>%{customdata:.2f} median rating'))\nfig.update_layout(title='Mean Rating based on Movies Count (log) for each country', template='plotly_white',\n                  title_x=0.5, legend=dict(yanchor='bottom', y=-0.15, xanchor='left', x=0, font=dict(size=10), orientation='h'),\n                  autosize=False, width=800, height=500)\nfig.update_xaxes(type='log')\nfig['layout']['xaxis']['title'] = 'Movies Count (log)'\nfig['layout']['yaxis']['title'] = 'Mean Rating'\nfig.show()","9bb8d70e":"# aggregating the data grouping the dataframe with 'country_name' and 'duration_qcut'\nunnested_countries_df['duration_qcut'], qcut_duration = pd.qcut(x=unnested_countries_df['duration'], q=3, retbins=True)\nunnested_duration_labels = ['short (<' + str(round(qcut_duration[1])) + ' min)',\n                            'medium (<' + str(round(qcut_duration[2])) + ' min)',\n                            'long (>=' + str(round(qcut_duration[2])) + ' min)']\nunnested_countries_df['duration_qcut'] = pd.qcut(x=movies_df['duration'], q=3, labels=unnested_duration_labels)\n\nagg_countries_duration_df = unnested_countries_df.groupby(['country_name', 'duration_qcut']).agg(\n    movies_count=pd.NamedAgg(column='filmtv_id', aggfunc=np.size),\n    mean_rating=pd.NamedAgg(column='avg_vote', aggfunc=np.mean),\n    median_rating=pd.NamedAgg(column='avg_vote', aggfunc=np.median),\n    mean_total_ratings=pd.NamedAgg(column='total_votes', aggfunc=np.mean),\n    sum_total_ratings=pd.NamedAgg(column='total_votes', aggfunc=np.sum)\n).reset_index()\nagg_countries_duration_df = agg_countries_duration_df[agg_countries_duration_df['country_name'].isin(agg_countries_df[:8]['country_name'].tolist())]\n\n# Pointplot to show the interaction between Duration category and Mean Rating\nplt.figure(figsize=(15, 8))\nplt.title('Interaction between Duration category and Mean Rating for the most popular 8 countries', fontsize=20)\nax = sns.pointplot(data=agg_countries_duration_df, x='duration_qcut', y='mean_rating', hue='country_name')\nax.legend_.set_title('Country') # setting only the legend title, without specifying the labels (somehow seaborn kept inverting the labels order in the usual legend setup)\nax.margins(x=0.006)\nplt.xlabel('Duration category', fontsize=15)\nplt.ylabel('Mean Rating', fontsize=15)\nplt.show()","9bd9085d":"Plotting an histogram with the count of duration categories with bins of 10 minutes each.\n\n<i>Most movies have a duration between 90 and 110 minutes, with Comedies having a higher relative frequency.<\/i>\n<br>\n<i>Almost one third of all movies have a duration between 90 and 100 minutes, showing that duration values do not have a high variance (low kurtosis).<\/i>","e8071860":"Visualizing the columns with missing values using the *missingno* library.\n\n<i>The main fields with missing data are 'notes', 'critics_vote', 'actors', and 'description'.<\/i>","1a76e34b":"# <a id='2'>2. Dataset<\/a>&ensp;&ensp;&ensp;<a href='#0'>\u2191<\/a>\n\n<div class=\"alert alert-block alert-info\" style=\"font-size:14px; line-height: 1.7em\">\n<p>\u26a0\ufe0f <b>Warnings<\/b>:\n<li>All string fields besides 'title' have been translated using the <i>TextBlob<\/i> Python library during the cleaning process, which has been carried out before loading the data on Kaggle<\/li>\n<li>The fields 'humor', 'rhythm', 'effort', 'tension', and 'erotism' are not completely reliable as FilmTV does not always assign a value for each category, but the website still shows them anyway. For this reason, it is not possible to know whether a value of 0 actually means 0 or NaN, and therefore these fields above have not been included in the analysis<\/li>\n<\/p>\n<\/div>","fb489a81":"# <a id='1'>1. Introduction<\/a>&ensp;&ensp;&ensp;<a href='#0'>\u2191<\/a>\n\n<div class=\"alert alert-block alert-info\" style=\"font-size:14px; line-height: 1.7em\">\n<p>\ud83c\udfaf <b>Goals<\/b>:\n<li>Generic visualization of most common movies<\/li>\n<li>Investigating the main characteristics that make some movies more rated than others<\/li>\n<\/p>\n<br>\n<p>\ud83d\udd28 <b>Tools<\/b>:\n<li><i>numpy<\/i> and <i>pandas<\/i> for data manipulation<\/li>\n<li><i>missingno<\/i> to display the missing data in the FilmTV dataset<\/li>\n<li><i>seaborn<\/i>, <i>plotly<\/i>, and <i>WordCloud<\/i> for data visualization<\/li>\n<\/p>\n<\/div>","d5852e42":"## <a id='31'>3.1. Top Movies<\/a>&ensp;&ensp;&ensp;<a href='#0'>\u2191<\/a>","438d92e1":"# <a id='4'>4. Key Findings<\/a>&ensp;&ensp;&ensp;<a href='#0'>\u2191<\/a>\n\n<div class=\"alert alert-block alert-info\" style=\"font-size:14px\">\n<p>\n\ud83d\udd11 <b>Top Movies<\/b>:\n<li><i>Pulp Fiction<\/i> and <i>The Shining<\/i> are the most popular movies<\/li>\n<li>Dramas are the movie genre most frequent among the top 100 movies based on total votes<\/li>\n<li>The decade 2000-10 is the most frequent decade of release for the top 100 movies<\/li>\n<li>There is no movie in top 100 that has been released from the beginning of the year 2020 (which was not obvious given that the FilmTV dataset was scraped on 2021-09-10)<\/li>\n<li>The mean rating of the top 100 movies descreased decade after decade, with the most evident drop in perceived quality occured in the decade 2000-10<\/li>\n<\/p>\n<br>\n<p>\ud83d\udd11 <b>Genres<\/b>:\n<li>Dramas and Comedies are the most popular genres overall<\/li>\n<li>The count of movies based on release year has increased over time, but has dropped since the year 2017<\/li>\n<li>Comedies became more popular decade after decade - but stopped increasing after the 1970s - while Dramas had several fluctuations, but are more popular overall compared to the 1920s<\/li>\n<li>Documentaries have the highest average ratings and with small dispersion of values, whereas Romantic movies are the ones with the lowest average ratings and the highest dispersion of values<\/li>\n<li>Comedies are more often low-rated than Dramas<\/li>\n<li>Average ratings dropped over time for all genres, but Dramas experienced the lowest ratings reduction<\/li>\n<\/p>\n<br>\n<p>\ud83d\udd11 <b>Duration<\/b>:\n<li>Most movies have a duration between 90 and 110 minutes<\/li>\n<li>Comedies are extremely frequent for the duration range between 90 and 100 minutes, while Dramas tend to be longer than the other genres<\/li>\n<li>Animations, Documentaries, and Horrors have usually very low duration (less than 91 minutes), whereas Biography, Musical, and War movies have the opposite tendency<\/li>\n<li>Movies with low ratings are generally shorter in duration<\/li>\n<li>The mode duration is approximately 90 minutes, and the farther the movie duration from the mode the higher the chance that the movie has been highly rated<\/li>\n<li>After the rating drops of short and medium-duration movies from the 1940s until the 1980s, their average rating increased in the next two decades, reaching the same value as the long movies (at least 103 minutes of duration)<\/li>\n<\/p>\n<br>\n<p>\ud83d\udd11 <b>Countries<\/b>:\n<li><i>United States of America<\/i> is the country where most movies have been filmed, followed by <i>Italy<\/i>, <i>France<\/i>, <i>United Kingdom<\/i>, <i>Germany<\/i>, and <i>Spain<\/i><\/li>\n<li>Countries where fewer movies were shot have higher ratings, and, given that older movies had higher votes expressed on FilmTV, it makes sense that the ones with the highest mean rating are the former countries <i>Czechoslovakia<\/i> and <i>Soviet Union<\/i><\/li>\n<li>Italy has movie ratings far worse compared to other countries with similar n. of movies, allowing to assume that FilmTV overrepresents trash movies that do not even appear for other countries, or that Italian are biased in favour of foreign movies<\/li>\n<li>The mean ratings tend to be low for movies with short and medium duration, while ratings are significantly higher for long movies (at least 104 minutes)<\/li>\n<li>The only countries where ratings linearly increase depending on the duration are Japan, Germany, and Canada<\/li>\n<\/p>\n<\/div>","5d4696c1":"Repeating the same visualization, but including only the European countries.\n\n<i>It is also not a surprise that the European country where the highest amount of movies have been filmed is Italy - after all, FilmTV is an Italian website and several movies and comments posted relate to Italian films.<\/i>\n<br>\n<i>The other countries highlighted in the plot below are respectively France, UK, Germany, and Spain.<\/i>","8d577a5d":"# <a id='3'>3. Exploratory Data Analysis<\/a>&ensp;&ensp;&ensp;<a href='#0'>\u2191<\/a>","37976a76":"Estimating the relative frequency of each movie genre from 1920 until 2021.\n\n<i>The following density plot shows that Comedy movies became more popular decade after decade - but stopped increasing after the 1970s - while Dramas had several fluctuations, but are more popular overall compared to 1920.<\/i>","fdc89a90":"## <a id='34'>3.4. Countries<\/a>&ensp;&ensp;&ensp;<a href='#0'>\u2191<\/a>","7b1e1c4b":"Plotting an histogram with the count of movies by year of release.\n\n<i>The drop of movies from 2017-18 is due to the fact that the FilmTV dataset only includes the movies with at least one expressed vote (provided by a critic or the public).<\/i>\n<br>\n<i>Several recent movies have not been rated yet by any critic or user, and this explains the frequency drop in the last couple of years.<\/i>","adcd9b68":"Comparing the estimated average ratings based on year of release and broken down by the genre sub-categories.\n\n<i>The interesting finding is that average ratings have been dramatically reduced from the 1920s - where the three major genres were close to each other between the average ratings of 7.5 and 8.0 - and the Drama genre is the only one that has not been considered to get worse decade after decade.<\/i>","dff75d70":"Visualizing the relationship between the number of actors in the top 100 movies and the mean rating expressed on FilmTV.\n\n<i>Movies with medium number of actors (between 8 and 11) have a slightly lower mean rating and their rating distribution is the lowest one among the top 100 movies.<\/i>\n<br>\n<i>The two outliers are 'War of the Worlds' and '300', and belong to the low and medium categories respectively.<\/i>","38d3c499":"Visualizing the relationship between average votes and duration (in minutes), using a density plot.\n\n<i>Movies with low ratings are generally shorter in duration than the ones more appreciated by the FilmTV users.<\/i>\n<br>\n<i>The mode duration is approximately 90 minutes, and the farther the movie duration from the mode, the higher the chance that the movie has been highly rated - although this behaviour is more evident for the right tail of the duration distribution.<\/i>","5db670db":"Comparing the estimated average votes based on year of release and broken down by the duration sub-categories.\n\n<i>One interesting finding is that, from the 1920s to the 1940s, movies with medium duration (between 91 and 102 minutes) have experienced a large fluctuation of averag ratings, which was probably partially caused also by the low frequency of medium-duration movies one century ago: at that time, most movies were short.<\/i>\n<br>\n<i>Another remarkable finding is that, after the rating drops of short and medium-duration movies from the 1940s until the 1980s, their average rating increased in the next two decades, reaching the same value as the long movies (at least 103 minutes of duration).<\/i>","fca63766":"Estimating the relative frequency of duration values, comparing the distribution of durations by genres.\n\n<i>The previous finding about Comedy movies is confirmed, and it is also evident that Dramas tend to be longer than other movie genres.<\/i>","a31facf7":"Plotting an histogram with the count of top 100 movies by decade of release.\n\n<i>The highest frequency of the 2000-10 decade is evident, but what is remarkable is that the previous decade (1990-2000) had several more popular movies than the following one (2010-20).<\/i>\n<br>\n<i>It also worth to notice that there is no movie in the top 100 list that has been released from the beginning of the year 2020, which was not obvious given that the FilmTV dataset was scraped on 2021-09-10.<\/i>\n<br>\n<i>Another clear information from the following plot is that the mean rating of the top 100 movie descreased decade after decade, with the most evident drop in perceived quality occured in the 2000-10 decade.<\/i>","7b6f42d2":"Creating the WordCloud of descriptions text for the most common 4 genres.","799ac917":"Displaying the country locations based on the movies count.\n\n<i>Without any surprise, the country where the highest amount of movies have been filmed is the United States of America.<\/i>","02edafbc":"How does the movie reputation (i.e. 'total_votes') affect the n. of missing values?\n\nThe following graph shows the impact of each field with missing data in comparison with the total records after the 'total_votes' column is used to filter the dataset.\n\n<i>By filtering only the movies with at least 10 votes, the number of NAs is drastically reduced; the only exception is the 'notes' field, which appears to have blank values regardless of the movie reputation.<\/i>","164a7e80":"Additional investigation on the relationship between the average ratings and the most common genres.\n\nThe following crosstab allows to see how correlations change from one variable grouping to another.\n\n<i>It becomes evident that Comedies are more often low-rated compared to Dramas.<\/i>","56ccadb8":"Displaying the titles of top 20 movies based on the 'total_votes' field.\n\n<i>The most popular ones are 'Pulp Fiction' and 'The Shining', which obtained a mean rating of at least 9\/10.<\/i>\n<br>\n<i>The movies with the lowest ratings are 'Inception' and 'Avatar', which received also less votes overall than 'Pulp Fiction' and 'The Shining'.<\/i>","ee1aff41":"Visualizing the relationship between the movies count and the mean and median ratings per country.\n\n<i>Countries were fewer movies were shot have higher ratings, and, given that older movies had higher votes expressed on FilmTV, it is understandable to see two former country names such as Czechoslovakia and Soviet Union being the ones with the highest mean and median ratings overall.<\/i>\n<br>\n<i>Italy has worse movie ratings compared to other countries with similar n. of movies (e.g. France and Germany) and this might be due to the overrepresentation of some trash movies that do not even appear on FilmTV for other countries, or might be due to Italians' bias in favour of foreign movies.<\/i>\n<br>\n<i>In other words, FilmTV has several more Italian movies on the website compared to other similar countries as (France, Germany, etc.), but they are perceived by the critics and users to be worse in quality.<\/i>","21bfc58f":"Visualizing the dispersion of average ratings based on movie genre.\n\n<i>Documentaries are the ones with the highest average ratings and with small dispersion of values, whereas Romantic movies are the ones with the lowest average ratings and the highest dispersion of values.<\/i>","6bd01183":"## <a id='33'>3.3. Duration<\/a>&ensp;&ensp;&ensp;<a href='#0'>\u2191<\/a>","3ad8a5d1":"## <a id='32'>3.2. Genres<\/a>&ensp;&ensp;&ensp;<a href='#0'>\u2191<\/a>","3e1f1ace":"Creating the WordCloud of descriptions text for the 3 duration categories.","0feddf4e":"FilmTV is the most popular Italian website with movies data.\n\nThe purpose of this notebook is to analyse the FilmTV dataset available at this [Kaggle link](https:\/\/www.kaggle.com\/stefanoleone992\/filmtv-movies-dataset), which provide information regarding movie aspects such as genre, year of release, country name, director and actor names, duration, average rating, total votes, and the descriptions and notes translated from Italian to English with *TextBlob*.\n\nOnce the dataset is read with *pandas* and the missing data gets displayed with the *missingno* library, the most popular movies are filtered and displayed to see the comparison from one to another.\n\nThe next step is the analysis of the whole dataset, focusing on the genre, duration, and country fields.\n\nKey findings are summarized at the end of this notebook.","4597b4ac":"Additional investigation on the relationship between the average ratings and the duration categories.\n\n<i>Animations, Documentaries, and Horrors have usually very low duration (less than 91 minutes), whereas Biography, Musical, and War movies have the opposite tendency.<\/i>","26325c08":"Collecting the country codes from the Wikipedia website - required to display the country locations with *plotly*","24005355":"Visualizing the count of movie genres, selecting only the 15 most common ones.\n\n<i>It is evident that 'Drama' and 'Comedy' are by far the most common movie genres on FilmTV, followed by 'Thriller', 'Horror', and 'Action'.<\/i>","2889671e":"Displaying the distribution of genres of top 100 movies based on the 'total_votes' field.\n\n<i>There is no genre that is particularly frequent in the top 100 movies, although Dramas and Fantasy are the ones most common in the top 20 list.<\/i>","2acc1013":"Reading the dataset using the *pandas* library and displaying the first 5 records.","8789b785":"Interactions between Duration categories and Mean Rating for the most 8 most popular countries.\n\n<i>The mean ratings tend to be low for movies with short and medium duration, while ratings are significantly higher for long movies (>= 104 minutes).<\/i>\n<br>\n<i>The only countries where ratings linearly increase depending on the duration are Japan, Germany, and Canada.<\/i>","f53a371a":"<center><img src=\"https:\/\/i.imgur.com\/hv1oPnr.jpg\"><\/center>\n\n<br>\n\n<center><h1>\ud83c\udfa6 Movies analysis with FilmTV dataset<\/h1><\/center>\n\n# <a id='0'>Notebook Content<\/a>\n\n### - <a href='#1'>1. Introduction<\/a>\n### - <a href='#2'>2. Dataset<\/a>\n### - <a href='#3'>3. Exploratory Data Analysis<\/a>\n#### &ensp; - <a href='#31'>3.1. Top Movies<\/a>\n#### &ensp; - <a href='#32'>3.2. Genres<\/a>\n#### &ensp; - <a href='#33'>3.3. Duration<\/a>\n#### &ensp; - <a href='#34'>3.4. Countries<\/a>\n### - <a href='#4'>4. Key Findings<\/a>"}}