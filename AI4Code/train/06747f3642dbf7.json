{"cell_type":{"100bf6a7":"code","29173b86":"code","2ca782c4":"code","79673359":"code","e53c1849":"code","2ed0a1b7":"code","6b61e082":"code","54d32e2c":"code","88630dbd":"code","e9818d9b":"markdown","ead701fa":"markdown","7e176e87":"markdown","aca00099":"markdown","8e607147":"markdown","a7718868":"markdown","f01d74b6":"markdown","b1ed340c":"markdown","c63bc555":"markdown","f236f875":"markdown"},"source":{"100bf6a7":"import networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np","29173b86":"G = nx.Graph()\nG.add_nodes_from([0, 1])\nG.add_edge(0, 1)\n# G.add_node(1)\nfig = plt.figure(figsize= (8,2))\nplt.subplot(121)\npos = {0: [0,0],1:[1,0]}\nnx.draw(G, pos,  node_color= [0,1 ])\nm1 = nx.algorithms.community.modularity(G, [{0}, {1}])\nstr1 = 'Partition into two subgroups \\n'+ 'Modularity {}'.format(m1)\nplt.title(str1)\nplt.subplot(122)\npos = {0: [0,0],1:[1,0]}\nnx.draw(G, pos,  node_color= [0,0 ])\nm1 = nx.algorithms.community.modularity(G, [{0,1}])\nstr1 = 'Partition - all nodes in one group \\n'+ 'Modularity {}'.format(m1)\nplt.title(str1)\n\nplt.show()","2ca782c4":"G = nx.Graph()\n# G.add_node(1)\nG.add_nodes_from([0, 1,2])\n#G.add_edge(0, 1)\nG.add_edges_from([(0, 1), (1, 2)])\nfig = plt.figure(figsize= (12,3))\nplt.subplot(131)\npos = {0: [0,0],1:[1,0],2:[2,0]}\nnx.draw(G, pos,  node_color= [0,0,0 ])\nm1 = nx.algorithms.community.modularity(G, [{0,1,2}])\nstr1 = 'Partion: \\n all nodes in one group \\n'+ 'Modularity {}'.format(m1)\nplt.title(str1)\n\nplt.subplot(132)\npos = {0: [0,0],1:[1,0],2:[2,0]}\nnx.draw(G, pos,  node_color= [0,1,2 ])\nm1 = nx.algorithms.community.modularity(G, [{0},{1},{2}])\nstr1 = 'Partition: \\n all nodes in different groups \\n'+ 'Modularity {}'.format(m1)\nplt.title(str1)\n\nplt.subplot(133)\npos = {0: [0,0],1:[1,0],2:[2,0]}\nnx.draw(G, pos,  node_color= [0,0,1 ])\nm1 = nx.algorithms.community.modularity(G, [{0,1},{2}])\nstr1 = 'Partion: \\n Group1 - [0,1], Group2 - [2]  \\n'+ 'Modularity {}'.format(m1)\nplt.title(str1)\n\nplt.show()","79673359":"G = nx.Graph()\n# G.add_node(1)\nG.add_nodes_from([0, 1,2])\n#G.add_edge(0, 1)\nG.add_edges_from([(0, 1), (1, 2), (0, 2)])\nfig = plt.figure(figsize= (12,3))\nplt.subplot(131)\nnx.draw(G,   node_color= [0,0,0 ])\nm1 = nx.algorithms.community.modularity(G, [{0,1,2}])\nstr1 = 'Partion: \\n all nodes in one group \\n'+ 'Modularity ' + str(np.round(m1,3) )\nplt.title(str1)\n\nplt.subplot(132)\nnx.draw(G,   node_color= [0,1,2 ])\nm1 = nx.algorithms.community.modularity(G, [{0},{1},{2}])\nstr1 = 'Partion: \\n all nodes in different groups \\n'+ 'Modularity ' + str(np.round(m1,3) )\nplt.title(str1)\n\nplt.subplot(133)\nnx.draw(G,   node_color= [0,0,2 ])\nm1 = nx.algorithms.community.modularity(G, [{0,1},{2}])\nstr1 = 'Partion: \\n  Group1 - [0,1], Group2 - [2] \\n'+ 'Modularity ' + str(np.round(m1,3) )\nplt.title(str1)\n\nplt.show()","e53c1849":"G = nx.complete_graph(5)\n\nfig = plt.figure(figsize= (18,3))\nplt.subplot(151)\nnx.draw(G,   node_color= np.zeros( G.number_of_nodes() )    )\nm1 = nx.algorithms.community.modularity(G, [range( G.number_of_nodes() )])\nstr1 = 'Partion: \\n all nodes in one group \\n'+ 'Modularity ' + str(np.round(m1,3) )\nplt.title(str1)\n\n\nplt.subplot(152)\nnx.draw(G,   node_color= range( G.number_of_nodes() ) )\nm1 = nx.algorithms.community.modularity(G, [ {t} for t in  range( G.number_of_nodes()) ] )\nstr1 = 'Partion: \\n all nodes in different groups \\n'+ 'Modularity ' + str(np.round(m1,3)) + '=1\/node_number' \nplt.title(str1)\n\nplt.subplot(153)\nv = np.zeros( G.number_of_nodes() )\nv[0] = 1\nnx.draw(G,   node_color= v  )\nm1 = nx.algorithms.community.modularity(G, [{0}] + [  range(1, G.number_of_nodes() ) ] )\nstr1 = 'Partion: \\n Group1 = [0], Group2 = [1,2,3,4] \\n'+ 'Modularity ' + str(np.round(m1,3)) \nplt.title(str1)\n\nplt.subplot(154)\nv = np.zeros( G.number_of_nodes() )\nv[0] = 1; v[1] = 1\nnx.draw(G,   node_color= v  )\nm1 = nx.algorithms.community.modularity(G, [{0,1}] + [  range(2, G.number_of_nodes() ) ] )\nstr1 = 'Partion: \\n Group1 = [0,1], Group2 = [2,3,4] \\n'+ 'Modularity ' + str(np.round(m1,3)) \nplt.title(str1)\n\nplt.subplot(155)\nv = np.zeros( G.number_of_nodes() )\nv[0] = 1; v[1] = 2\nnx.draw(G,   node_color= v  )\nm1 = nx.algorithms.community.modularity(G, [{0},{1}] + [  range(2, G.number_of_nodes() ) ] )\nstr1 = 'Partion: \\n Group1 = [0,1], Group2 = [2,3,4] \\n'+ 'Modularity ' + str(np.round(m1,3)) \nplt.title(str1)\n\nplt.show()","2ed0a1b7":"kaggle_env = 1\nif kaggle_env != 1: # On kaggle igraph is pre-installed \n    !pip install python-igraph # Pay attention: not just \"pip install igraph\" \n    !pip install cairocffi # Module required for plots \nimport igraph # On kaggle it is pre-installed \nimport numpy as np","6b61e082":"g = igraph.Graph(directed=False)\ng.add_vertices(3)\ng.add_edges([[0,1],[1,2],[2,0]] )\nprint('Modularity for all nodes in different groups partition:', g.modularity([0,1,2]) ) # [0,1,2] - membership list - i.e. defines group number for i-th node. For example [0,0,0] - all nodes in Group0, [0,1,2] - all nodes in different groups.\n    # It is different from the networkx interface , where we define groups like: [ {0},{1},{2}] - each group is sublist \n    # nx.algorithms.community.modularity(G, [{0},{1},{2}])\nprint('It is 1\/3 - general pattern  for any complete graph - 1\/nodes_count')\n\nvisual_style = {}\nvisual_style[\"vertex_color\"] = ['red', 'blue', 'green']\nvisual_style[\"vertex_label\"] = range(g.vcount()) \n\nigraph.plot(g, **visual_style,  bbox=(100,100))","54d32e2c":"g = igraph.Graph()\ng.add_vertices(16)\nnodes = np.array([0,1,4,5])\nfor k in [0,2,8,10]:#,2,4,6,8]:\n  for i in nodes+k:\n    for j in nodes+k:\n      if i<=j: continue \n      g.add_edge(i, j)\ng.add_edge(1, 2)\ng.add_edge(4, 8)\ng.add_edge(13, 14)\ng.add_edge(7, 11)\n\n########################################################################\n# Cluster by Louvain algorithm \n# https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#community_multilevel\n########################################################################\nlouvain_partition = g.community_multilevel()# weights=graph.es['weight'], return_levels=False)\nmodularity1 = g.modularity(louvain_partition)#, weights=graph.es['weight'])\nprint(\"The modularity for igraph-Louvain partition is {}\".format(modularity1))\n#print();\nprint('Partition info:')\nprint(louvain_partition)\n\n########################################################################\n# Cluster by optimal algorithm (applicable only for small graphs <100 nodes), it would be very slow otherwise \n# https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#community_optimal_modularity\n########################################################################\nprint();\nv = g.community_optimal_modularity() # weights= gra.es[\"weight\"]) \nmodularity1 = g.modularity(v)#, weights=graph.es['weight'])\nprint(\"The modularity for igraph-optimal partition is {}\".format(modularity1))\n#print();\nprint('Partition info:')\nprint(v) \n\n########################################################################\n# Plot graph \n########################################################################\nlayout = g.layout_grid( ) # reingold_tilford(root=[2])\nvisual_style = {} \ndict_colors = {0:'Aqua', 1:'Aqua', 4:'Aqua', 5:'Aqua',2:'Aquamarine', 3:'Aquamarine', 6:'Aquamarine', 7:'Aquamarine',\n               8:'Crimson', 9:'Crimson', 12:'Crimson', 13:'Crimson',10:'Goldenrod', 11:'Goldenrod', 14:'Goldenrod', 15:'Goldenrod',\n               } # https:\/\/en.wikipedia.org\/wiki\/X11_color_names - colors by names supported by igraph \nvisual_style[\"vertex_color\"] = [dict_colors[k]  for k in range(g.vcount() )]\nvisual_style[\"vertex_label\"] = range(g.vcount()) \nigraph.plot(g, layout = layout, **visual_style, bbox = (200,200) )","88630dbd":"g = igraph.Graph(directed=False)\ng.add_vertices(3)\ng.add_edges([[0,0],[0,1],[1,2],[2,0]] )\n\nlouvain_partition = g.community_multilevel()# weights=graph.es['weight'], return_levels=False)\nmodularity1 = g.modularity(louvain_partition)#, weights=graph.es['weight'])\nprint(\"The modularity for igraph-Louvain partition is {}\".format(modularity1))\n#print();\nprint('Partition info:')\nprint(louvain_partition)\n\nmodularity1 = g.modularity([0,1,2])#, weights=graph.es['weight'])\nprint(\"The modularity for all nodes in different groups partition is {}\".format(modularity1))\n\nmodularity1 = g.modularity([0,0,0])#, weights=graph.es['weight'])\nprint(\"The modularity for all nodes in one groups partition is {}\".format(modularity1))\n\nmodularity1 = g.modularity([0,1,1])#, weights=graph.es['weight'])\nprint(\"The modularity for all 0,1,1 partition is {}\".format(modularity1))\n\n\nigraph.plot(g,bbox = [200,100])","e9818d9b":"## Simplest graph - three  nodes in line ","ead701fa":"## Complete graph on 5 nodes\n\nExplore different partitions and observe that modularity behaves as intuitevely expected:\n\n1) Largest modularity is zero - all nodes in the same group, all other partitions will lead to negative modularity - that is expected, because complete graph is the most connected graph, so splitting it to subgroups, should decrease any reasonable measure of grouping perforamce \n\n2) the smallest value of modularity is when all nodes in different groups - \nagain it is expected by similar reason as above. \nActual value = 1\/nodes_count - holds for complete graphs. \n\n3) The bigger partition differs from - all in one group the smaller modularity would be \n","7e176e87":"## Simplest graph - Triangle","aca00099":"# Modularity with networkx ","8e607147":"## Simplest graph - just two nodes with one edge","a7718868":"# Coding modularity by hands\n\nExplicit example of calculation by hands and coding by hands modularity can be found in notebook:\nhttps:\/\/www.kaggle.com\/alexandervc\/hw1-part3-modularity-and-louvain-by-ac#3.1-Modularity-gain-when-an-isolated-node-moves-into-a-community-[4-points]\n\nSubsections \"Calculations by hands\" and \"Code to calculate modularity\"\n\n","f01d74b6":"## Louvain clustering and optimal clustering by igraph\n\nhttps:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#community_optimal_modularity\n\nhttps:\/\/stackoverflow.com\/questions\/24514297\/igraph-community-optimal-modularity-takes-no-weight-argument?rq=1\n\nClearly on some simple examples Louvain clustering algorithm would produce optimal clustering (i.e. with the top possible modularity). \nPackage igraph has  method to find optimal clustering, but it would be slow in general and applicable only in graph with not big number of nodes \n\nhttps:\/\/stackoverflow.com\/a\/60930979\/625396\nExample to use Louvain in 3 packages - networkx, igraph, bct\n","b1ed340c":"## Example of triangle+self loop","c63bc555":"# Modularity with \"igraph\"\n\nPackage \"igraph\" has built-in functions to calculate modularity, and clustering algorithms like Louvain, Leiden, optimal_clustering (with respect to modularity - works for small graphs only), and many many other graph clustering algorithms\n\nhttps:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#modularity  - modularity function\nhttps:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#community_optimal_modularity - optimal clustering \nhttps:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#community_multilevel - Louvain clustering \n\n\n\nPlots of igraph are not with matplotlib backend, so it is not clear how to create subplots, add titles, so on - which can be easy done by matplotlib. \nSo it is not clear how to make pictures like above with igraph ","f236f875":"# What is about\n\nNoteboook shows some examples of modularity calculation for different graphs.\nHope  it might help to give some intution what modularity is, as well, exercise oneself with networkx and igraph packages.\n\n\nIt does NOT correspond to HW1 task, just complement. \n\n\nDraft version \"under construction\", June 2020 AC.\n\n"}}