{"cell_type":{"8e8cd34d":"code","50184e80":"code","1888f7c3":"code","c05e1dea":"code","33a53591":"code","931db700":"code","721e54e1":"code","f7a0bf1f":"code","0f668853":"code","c27e24df":"code","e901bfde":"code","93e69213":"code","3ec84040":"code","4a4d5346":"code","d5e4c169":"code","cbe7895d":"code","d141b1aa":"code","2890e5ec":"code","5bd35814":"code","e245b013":"code","83d1a17b":"code","6725a0ce":"code","6711f37a":"code","64f89ecf":"code","abe7a3f7":"code","9260105f":"code","bf164eb1":"code","e6e661ec":"code","53961cb5":"code","4d49cd98":"code","62ef05e3":"code","e718eeda":"code","8977b667":"code","ab4ca46f":"code","6e53a5d6":"code","f7f453f1":"code","5aa5409e":"code","6b762707":"markdown","7eda3bbf":"markdown","9392a8f5":"markdown","0ff1c7ab":"markdown","39e46f00":"markdown"},"source":{"8e8cd34d":"!pip3 install pycocotools","50184e80":"!git clone https:\/\/github.com\/dromosys\/TGS-SaltIdentification-Open-Solution-fastai\nimport sys\nsys.path.insert(0, '\/kaggle\/working\/TGS-SaltIdentification-Open-Solution-fastai')","1888f7c3":"import numpy as np\nimport pandas as pd\nimport os\nprint(os.listdir(\"\/kaggle\/input\/tgs-salt-identification-challenge\"))\n#os.getcwd()","c05e1dea":"%matplotlib inline\n%reload_ext autoreload\n%autoreload 2\nfrom fastai.conv_learner import *\nfrom fastai.dataset import *\nfrom fastai.models.resnet import vgg_resnet50\nfrom fastai.models.senet import *\nfrom skimage.transform import resize\nimport json\nfrom sklearn.model_selection import train_test_split, StratifiedKFold , KFold\nfrom sklearn.metrics import jaccard_similarity_score\nfrom pycocotools import mask as cocomask\nfrom utils import my_eval,intersection_over_union_thresholds,RLenc\nfrom lovasz_losses import lovasz_hinge\nprint(torch.__version__)\ntorch.cuda.is_available()\ntorch.backends.cudnn.benchmark=True","33a53591":"MASKS_FN = 'train.csv'\nTRAIN_DN = Path('train\/images\/')\nMASKS_DN = Path('train\/masks\/')\nTEST = Path('test\/images\/')\n\nPATH = Path('\/kaggle\/input\/tgs-salt-identification-challenge\/')\nPATH128 = Path('\/tmp\/128\/')\nTMP = Path('\/tmp\/')\nMODEL = Path('\/tmp\/model\/')\nPRETRAINED = Path('\/kaggle\/input\/is-there-salt-resnet34\/model\/resnet34_issalt.h5')\nseg = pd.read_csv(PATH\/MASKS_FN).set_index('id')\nseg.head()\n\nsz = 128\nbs = 64\nnw = 4","931db700":"train_names_png = [TRAIN_DN\/f for f in os.listdir(PATH\/TRAIN_DN)]\ntrain_names = list(seg.index.values)\nmasks_names_png = [MASKS_DN\/f for f in os.listdir(PATH\/MASKS_DN)]\ntest_names_png = [TEST\/f for f in os.listdir(PATH\/TEST)]","721e54e1":"train_names_png[0], masks_names_png[0], test_names_png[0]","f7a0bf1f":"TMP.mkdir(exist_ok=True)\nPATH128.mkdir(exist_ok=True)\n(PATH128\/'train').mkdir(exist_ok=True)\n(PATH128\/'test').mkdir(exist_ok=True)\n(PATH128\/MASKS_DN).mkdir(exist_ok=True)\n(PATH128\/TRAIN_DN).mkdir(exist_ok=True)\n(PATH128\/TEST).mkdir(exist_ok=True)","0f668853":"def resize_mask(fn, sz=128):\n    Image.open(PATH\/fn).resize((sz,sz)).save(PATH128\/fn)","c27e24df":"with ThreadPoolExecutor(4) as e: e.map(resize_mask, train_names_png)","e901bfde":"with ThreadPoolExecutor(4) as e: e.map(resize_mask, masks_names_png)","93e69213":"with ThreadPoolExecutor(4) as e: e.map(resize_mask, test_names_png)","3ec84040":"PATH = PATH128 #just for sanity","4a4d5346":"def show_img(im, figsize=None, ax=None, alpha=None):\n    if not ax: fig,ax = plt.subplots(figsize=figsize)\n    ax.imshow(im, alpha=alpha)\n    ax.set_axis_off()\n    return ax","d5e4c169":"from datasets import CustomDataset","cbe7895d":"def dice(pred, targs):\n    pred = (pred>0).float()\n    return 2. * (pred*targs).sum() \/ (pred+targs).sum()\n\ndef IoU_np(pred, targs, thres=0):\n    pred = (pred>thres)\n    intersection = (pred*targs).sum()\n    return intersection \/ ((pred+targs).sum() - intersection + 1.0)\n\ndef IoU(pred, targs, thres=0):\n    pred = (pred>thres).float()\n    intersection = (pred*targs).sum()\n    return intersection \/ ((pred+targs).sum() - intersection + 1.0)","d141b1aa":"def get_base():\n    layers = cut_model(f(True), cut)\n    return nn.Sequential(*layers)\n\ndef load_pretrained(model, path): #load a model pretrained on ship\/no-ship classification\n    weights = torch.load(PRETRAINED, map_location=lambda storage, loc: storage)\n    model.load_state_dict(weights, strict=False)\n            \n    return model","2890e5ec":"class SaveFeatures():\n    features=None\n    def __init__(self, m): self.hook = m.register_forward_hook(self.hook_fn)\n    def hook_fn(self, module, input, output): self.features = output\n    def remove(self): self.hook.remove()","5bd35814":"class UnetBlock(nn.Module):\n    def __init__(self, up_in, x_in, n_out):\n        super().__init__()\n        up_out = x_out = n_out\/\/2\n        self.x_conv  = nn.Conv2d(x_in,  x_out,  1)\n        self.tr_conv = nn.ConvTranspose2d(up_in, up_out, 2, stride=2)\n        self.bn = nn.BatchNorm2d(n_out)\n        \n    def forward(self, up_p, x_p):\n        up_p = self.tr_conv(up_p)\n        x_p = self.x_conv(x_p)\n        cat_p = torch.cat([up_p,x_p], dim=1)\n        return self.bn(F.relu(cat_p))","e245b013":"class Unet34(nn.Module):\n    def __init__(self, rn):\n        super().__init__()\n        self.rn = rn\n        self.sfs = [SaveFeatures(rn[i]) for i in [2,4,5,6]]\n        self.up1 = UnetBlock(512,256,256)\n        self.up2 = UnetBlock(256,128,256)\n        self.up3 = UnetBlock(256,64,256)\n        self.up4 = UnetBlock(256,64,256)\n        self.up5 = nn.ConvTranspose2d(256, 1, 2, stride=2)\n        \n    def forward(self,x):\n        x = F.dropout(F.relu(self.rn(x)),0.2)\n        x = self.up1(x, self.sfs[3].features)\n        x = self.up2(x, self.sfs[2].features)\n        x = self.up3(x, self.sfs[1].features)\n        x = self.up4(x, self.sfs[0].features)\n        x = self.up5(x)\n        return x[:,0]\n    \n    def close(self):\n        for sf in self.sfs: sf.remove()","83d1a17b":"class UnetModel():\n    def __init__(self,model,name='unet'):\n        self.model,self.name = model,name\n\n    def get_layer_groups(self, precompute):\n        lgs = list(split_by_idxs(children(self.model.rn), [lr_cut]))\n        return lgs + [children(self.model)[1:]]","6725a0ce":"x_names = [f'{x}.png' for x in train_names]\nx_names_path = np.array([str(TRAIN_DN\/x) for x in x_names])\ny_names = [x for x in x_names]\ny_names_path = np.array([str(MASKS_DN\/x) for x in x_names])","6711f37a":"aug_tfms = [RandomRotate(4, tfm_y=TfmType.CLASS),\n            RandomFlip(tfm_y=TfmType.CLASS),\n            RandomLighting(0.05, 0.05, tfm_y=TfmType.CLASS)]\n# aug_tfms = []","64f89ecf":"sz","abe7a3f7":"lr=3e-3\nwd=1e-7\nlrs = np.array([lr\/100,lr\/10,lr])\n\nn_folds = 10\nout=np.zeros((18000,sz,sz))\nalpha = 0\nfor i in range(n_folds):\n    val_size = 4000\/\/n_folds\n    val_idxs=list(range(i*val_size, (i+1)*val_size))\n    ((val_x,trn_x),(val_y,trn_y)) = split_by_idx(val_idxs, x_names_path, y_names_path)\n    test_x = np.array(test_names_png)\n    \n    tfms = tfms_from_model(resnet34, sz=sz, pad=0, crop_type=CropType.NO, tfm_y=TfmType.CLASS, aug_tfms=aug_tfms)\n    datasets = ImageData.get_ds(CustomDataset, (trn_x,trn_y), (val_x,val_y), tfms, (test_x, test_x), path=PATH)\n    md = ImageData(PATH, datasets, bs=64, num_workers=nw, classes=None)\n    denorm = md.trn_ds.denorm\n    \n    f = resnet34\n    cut,lr_cut = model_meta[f]\n    m_base = load_pretrained(get_base(),PRETRAINED)\n    m = to_gpu(Unet34(m_base))\n    models = UnetModel(m)\n    learn = ConvLearner(md, models, tmp_name=TMP, models_name=MODEL)\n    learn.opt_fn=optim.Adam\n#     learn.crit=nn.BCEWithLogitsLoss()\n    learn.crit = lovasz_hinge\n    learn.metrics=[accuracy_thresh(0.5),dice, IoU]\n    \n    learn.freeze_to(2)\n#     learn.fit(lr,1)\n    learn.fit(lr,2,wds=wd,cycle_len=10,use_clr_beta=(10,10, 0.85, 0.9))\n    learn.unfreeze()\n    learn.fit(lrs, 3, wds=wd, cycle_len=10,use_clr_beta=(10,10, 0.85, 0.9))\n    print(f'computing test set: {i}')\n    out+=learn.predict(is_test=True)\n    print('Computing optimal threshold')\n    preds, targs = learn.predict_with_targs()\n    IoUs=[]\n    for a in np.arange(0, 1, 0.1):\n        IoUs.append(IoU_np(preds, targs, a))\n    IoU_max = np.array(IoUs).argmax()\n    print(f'optimal Threshold: {IoU_max\/10.0}')\n    alpha+=IoU_max\/10.0","9260105f":"out = out\/n_folds\nalpha = alpha\/n_folds","bf164eb1":"fig, axes = plt.subplots(6, 6, figsize=(12, 12))\nfor i,ax in enumerate(axes.flat):\n    ax = show_img(Image.open(PATH\/test_names_png[i+30]), ax=ax)\n    show_img(out[i+30]>alpha, ax=ax, alpha=0.2)\nplt.tight_layout(pad=0.1)","e6e661ec":"def rle_encode(im):\n    '''\n    im: numpy array, 1 - mask, 0 - background\n    Returns run length as string formated\n    '''\n    pixels = im.flatten(order='F')\n    pixels = np.concatenate([[0], pixels, [0]])\n    runs = np.where(pixels[1:] != pixels[:-1])[0] + 1\n    runs[1::2] -= runs[::2]\n    return ' '.join(str(x) for x in runs)","53961cb5":"tmp_list = []\nname_list = []\nfor i in range(18000):\n    img = cv2.resize(out[i,:,:], dsize=(101,101), interpolation = cv2.INTER_CUBIC)\n    tmp_list.append(rle_encode(img>alpha))\n    name_list.append(test_names_png[i].name[0:-4])","4d49cd98":"test_names_png[0], test_x[0]","62ef05e3":"sub = pd.DataFrame(list(zip(name_list, tmp_list)), columns = ['id', 'rle_mask'])","e718eeda":"sub.to_csv('submission.csv', index=False)","8977b667":"out","ab4ca46f":"ls","6e53a5d6":"rm -rf \/tmp\/model\/","f7f453f1":"rm -rf \/tmp\/128","5aa5409e":"rm -rf \/kaggle\/working\/TGS-SaltIdentification-Open-Solution-fastai","6b762707":"# UNET","7eda3bbf":"Filter with classification probabilities previously computed","9392a8f5":"# Optimal threshold finder","0ff1c7ab":"https:\/\/www.kaggle.com\/imrandude\/tgs-salt-identification-fastai-unet-resnet","39e46f00":"# Predict"}}