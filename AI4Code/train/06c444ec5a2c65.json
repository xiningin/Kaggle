{"cell_type":{"334e841b":"code","ccf1909c":"code","fffbc0f7":"code","a0004d7c":"code","3003dcda":"code","b412a3f6":"code","b15a640b":"code","26e42084":"code","84800080":"code","4f1b858c":"code","54bebc2d":"code","a8047b46":"code","61e2a46e":"code","f2679303":"code","9a8637be":"code","13c73db9":"code","6f6c2d25":"code","e2caf6af":"code","ae332f0e":"code","80d225c8":"code","78fb061b":"code","80988970":"code","ca4715fb":"code","6b123c65":"code","0a187ee9":"code","c2237ea2":"markdown","e47ad665":"markdown","b9cfaeac":"markdown","fa8bba3f":"markdown","f9bff792":"markdown","8ea8abcb":"markdown","8bc11e88":"markdown","59169d93":"markdown","28bf9fea":"markdown","9458826a":"markdown","b8ebf5a6":"markdown","e4c2a356":"markdown","a7dac44d":"markdown","5f0b0c2d":"markdown","f5d20953":"markdown","4ceb1650":"markdown","3f663da3":"markdown","ab5f82fc":"markdown","7358da9a":"markdown","7fd8c6e7":"markdown","fdfd77c1":"markdown","9b0532ad":"markdown"},"source":{"334e841b":"import tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import backend as K\nfrom tensorflow.keras.layers import Dense, Activation,Dropout,Conv2D, MaxPooling2D,BatchNormalization, Flatten\nfrom tensorflow.keras.optimizers import Adam, Adamax\nfrom tensorflow.keras.metrics import categorical_crossentropy\nfrom tensorflow.keras import regularizers\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.models import Model, load_model, Sequential\nimport numpy as np\nimport pandas as pd\nimport shutil\nimport time\nimport cv2 as cv2\nfrom tqdm import tqdm\nfrom sklearn.model_selection import train_test_split\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import imshow\nimport os\nimport seaborn as sns\nsns.set_style('darkgrid')\nfrom PIL import Image\nfrom sklearn.metrics import confusion_matrix, classification_report\nfrom IPython.core.display import display, HTML","ccf1909c":"fpath=r'..\/input\/plantdisease\/PlantVillage\/Potato___healthy\/00fc2ee5-729f-4757-8aeb-65c3355874f2___RS_HL 1864.JPG'\nimg=plt.imread(fpath)\nprint (img.shape)\nimshow(img)\n","fffbc0f7":"sdir=r'..\/input\/plantdisease\/PlantVillage'\nclasslist=os.listdir(sdir)    \nfilepaths=[]\nlabels=[]    \nfor klass in classlist:\n    classpath=os.path.join(sdir,klass)\n    if os.path.isdir(classpath):\n        flist=os.listdir(classpath)        \n        for f in flist:\n            fpath=os.path.join(classpath,f)        \n            filepaths.append(fpath)\n            labels.append(klass)\nFseries=pd.Series(filepaths, name='filepaths')\nLseries=pd.Series(labels, name='labels')    \ndf=pd.concat([Fseries, Lseries], axis=1)    \nprint (df.head())\nprint('df length: ', len(df))\nprint (df['labels'].value_counts())","a0004d7c":"sample_list=[]\nmax_size= 500\ngroups=df.groupby('labels')\nfor label in df['labels'].unique():                 \n    group=groups.get_group(label)\n    sample_count=len(group)    \n    if sample_count> max_size:\n        samples=group.sample(max_size, replace=False, weights=None, random_state=123, axis=0).reset_index(drop=True)\n    else:\n        samples=group.sample(frac=1.0, replace=False, random_state=123, axis=0).reset_index(drop=True)\n    sample_list.append(samples)\ndf=pd.concat(sample_list, axis=0).reset_index(drop=True)\nprint (len(df))     \nprint (df['labels'].value_counts())     \n        ","3003dcda":"working_dir=r'.\/'\naug_dir=os.path.join(working_dir, 'aug')\nif os.path.isdir(aug_dir):\n    shutil.rmtree(aug_dir)\nos.mkdir(aug_dir)\nfor label in df['labels'].unique():\n    dir_path=os.path.join(aug_dir,label)    \n    os.mkdir(dir_path)\nprint(os.listdir(aug_dir))","b412a3f6":"target=500 # set the target count for each class in df\ngen=ImageDataGenerator(horizontal_flip=True,  rotation_range=20, width_shift_range=.2,\n                              height_shift_range=.2, zoom_range=.2)\ngroups=df.groupby('labels') # group by class\nfor label in df['labels'].unique():  # for every class               \n    group=groups.get_group(label)  # a dataframe holding only rows with the specified label \n    sample_count=len(group)   # determine how many samples there are in this class  \n    if sample_count< target: # if the class has less than target number of images\n        aug_img_count=0\n        delta=target-sample_count  # number of augmented images to create\n        target_dir=os.path.join(aug_dir, label)  # define where to write the images    \n        aug_gen=gen.flow_from_dataframe( group,  x_col='filepaths', y_col=None, target_size=(224,224), class_mode=None,\n                                        batch_size=1, shuffle=False, save_to_dir=target_dir, save_prefix='aug-',\n                                        save_format='jpg')\n        while aug_img_count<delta:\n            images=next(aug_gen)            \n            aug_img_count += len(images) ","b15a640b":"aug=r'.\/aug'\nauglist=os.listdir(aug)\nfor klass in auglist:\n    classpath=os.path.join(aug, klass)\n    flist=os.listdir(classpath)\n    print('klass: ', klass, '  file count: ', len(flist))","26e42084":"plt.figure(figsize=(20, 20))\nfor i in range(25):\n    image=next(aug_gen)\/255\n    image=np.squeeze(image, axis=0)\n    plt.subplot(5,5,i+1)\n    plt.imshow(image)\nplt.show()\n            ","84800080":"aug_fpaths=[]\naug_labels=[]\nclasslist=os.listdir(aug_dir)\nfor klass in classlist:\n    classpath=os.path.join(aug_dir, klass)     \n    flist=os.listdir(classpath)    \n    for f in flist:        \n        fpath=os.path.join(classpath,f)         \n        aug_fpaths.append(fpath)\n        aug_labels.append(klass)\nFseries=pd.Series(aug_fpaths, name='filepaths')\nLseries=pd.Series(aug_labels, name='labels')\naug_df=pd.concat([Fseries, Lseries], axis=1)\nndf=pd.concat([df,aug_df], axis=0).reset_index(drop=True)\n#ndf=df.sample(frac=1.0, replace=False, random_state=123, axis=0).reset_index(drop=True)\n\n\nprint (df['labels'].value_counts()) \nprint(aug_df['labels'].value_counts())\nprint (ndf['labels'].value_counts()) ","4f1b858c":"train_split=.8\nvalid_split=.1\ndummy_split=valid_split\/(1-train_split)\ntrain_df, dummy_df=train_test_split(ndf, train_size=train_split, shuffle=True, random_state=123)\nvalid_df, test_df=train_test_split(dummy_df, train_size=dummy_split, shuffle=True, random_state=123)\nprint ('train_df length: ', len(train_df),'  test_df length: ', len(test_df), '  valid_df length: ', len(valid_df))","54bebc2d":"height=224\nwidth=224\nchannels=3\nbatch_size=40\nimg_shape=(height, width, channels)\nimg_size=(height, width)\nlength=len(test_df)\ntest_batch_size=sorted([int(length\/n) for n in range(1,length+1) if length % n ==0 and length\/n<=80],reverse=True)[0]  \ntest_steps=int(length\/test_batch_size)\nprint ( 'test batch size: ' ,test_batch_size, '  test steps: ', test_steps)\ndef scalar(img):\n    #img=img\/127.5-1\n    return img \ntrgen=ImageDataGenerator(preprocessing_function=scalar, horizontal_flip=True)\ntvgen=ImageDataGenerator(preprocessing_function=scalar)\nsdir=r'..\/input\/mars-surface-and-curiosity-image-set-nasa\/Mars Surface and Curiosity Image\/images'\ntrain_gen=trgen.flow_from_dataframe( train_df, x_col='filepaths', y_col='labels', target_size=img_size, class_mode='categorical',\n                                    color_mode='rgb', shuffle=True, batch_size=batch_size)\ntest_gen=tvgen.flow_from_dataframe( test_df, x_col='filepaths', y_col='labels', target_size=img_size, class_mode='categorical',\n                                    color_mode='rgb', shuffle=False, batch_size=test_batch_size)\nvalid_gen=tvgen.flow_from_dataframe( valid_df, x_col='filepaths', y_col='labels', target_size=img_size, class_mode='categorical',\n                                    color_mode='rgb', shuffle=True, batch_size=batch_size)\nclasses=list(train_gen.class_indices.keys())\nclass_count=len(classes)\ntrain_steps=int(len(train_gen.labels)\/batch_size)\nprint('Below is a list of class names and their associated index')\nprint(f'{'class':^30s}{'Index':^7s})\nfor i in range(class_count):\n    print(f'{classes[i]:^30s}, {i:^7s})\n","a8047b46":"def show_image_samples(gen ):\n    t_dict=gen.class_indices\n    classes=list(t_dict.keys())    \n    images,labels=next(gen) # get a sample batch from the generator \n    plt.figure(figsize=(20, 20))\n    length=len(labels)\n    if length<25:   #show maximum of 25 images\n        r=length\n    else:\n        r=25\n    for i in range(r):\n        plt.subplot(5, 5, i + 1)\n        image=images[i]\/255\n        plt.imshow(image)\n        index=np.argmax(labels[i])\n        class_name=classes[index]\n        plt.title(class_name, color='blue', fontsize=10)\n        plt.axis('off')\n    plt.show()","61e2a46e":"show_image_samples(train_gen)","f2679303":"def print_in_color(txt_msg,fore_tupple,back_tupple,):\n    #prints the text_msg in the foreground color specified by fore_tupple with the background specified by back_tupple \n    #text_msg is the text, fore_tupple is foregroud color tupple (r,g,b), back_tupple is background tupple (r,g,b)\n    rf,gf,bf=fore_tupple\n    rb,gb,bb=back_tupple\n    msg='{0}' + txt_msg\n    mat='\\33[38;2;' + str(rf) +';' + str(gf) + ';' + str(bf) + ';48;2;' + str(rb) + ';' +str(gb) + ';' + str(bb) +'m' \n    print(msg .format(mat), flush=True)\n    print('\\33[0m', flush=True) # returns default print color to back to black\n    return","9a8637be":"model_name='EfficientNetB1'\nbase_model=tf.keras.applications.EfficientNetB1(include_top=False, weights=\"imagenet\",input_shape=img_shape, pooling='max') \nx=base_model.output\nx=keras.layers.BatchNormalization(axis=-1, momentum=0.99, epsilon=0.001 )(x)\nx = Dense(256, kernel_regularizer = regularizers.l2(l = 0.016),activity_regularizer=regularizers.l1(0.006),\n                bias_regularizer=regularizers.l1(0.006) ,activation='relu')(x)\nx=Dropout(rate=.45, seed=123)(x)        \noutput=Dense(class_count, activation='softmax')(x)\nmodel=Model(inputs=base_model.input, outputs=output)\nmodel.compile(Adamax(lr=.001), loss='categorical_crossentropy', metrics=['accuracy']) ","13c73db9":"  class LRA(keras.callbacks.Callback):\n    reset=False\n    count=0\n    stop_count=0\n    \n    def __init__(self,model, patience,stop_patience, threshold, factor, dwell, model_name, freeze,batches, initial_epoch,epochs, ask_epoch):\n        super(LRA, self).__init__()\n        self.epochs=epochs\n        self.ask_epoch=ask_epoch\n        self.model=model\n        self.patience=patience # specifies how many epochs without improvement before learning rate is adjusted\n        self.stop_patience=stop_patience\n        self.threshold=threshold # specifies training accuracy threshold when lr will be adjusted based on validation loss\n        self.factor=factor # factor by which to reduce the learning rate\n        self.dwell=dwell\n        self.lr=float(tf.keras.backend.get_value(model.optimizer.lr)) # get the initiallearning rate and save it in self.lr\n        self.highest_tracc=0.0 # set highest training accuracy to 0\n        self.lowest_vloss=np.inf # set lowest validation loss to infinity\n        #self.count=0 # initialize counter that counts epochs with no improvement\n        #self.stop_count=0 # initialize counter that counts how manytimes lr has been adjustd with no improvement  \n        self.initial_epoch=initial_epoch \n        self.batches=batches\n        #self.epochs=epochs\n        best_weights=self.model.get_weights() # set a class vaiable so weights can be loaded after training is completed        \n        msg=' '\n        if freeze==True:\n            msgs=f' Starting training using  base model { model_name} with weights frozen to imagenet weights initializing LRA callback'\n        else:\n            msgs=f' Starting training using base model { model_name} training all layers '            \n        print_in_color (msgs, (244, 252, 3), (55,65,80)) \n    def on_train_begin(self, logs=None):\n        msg='{0:^8s}{1:^10s}{2:^9s}{3:^9s}{4:^9s}{5:^9s}{6:^9s}{7:^10s}{8:^8s}'.format('Epoch', 'Loss', 'Accuracy',\n                                                                                              'V_loss','V_acc', 'LR', 'Next LR', 'Monitor', 'Duration')\n        print_in_color(msg, (244,252,3), (55,65,80)) \n    def on_train_end(self, logs=None):\n        model.set_weights(LRA.best_weights)\n        msg='Training is completed - model is set with weights for the epoch with the lowest loss'\n        print_in_color(msg, (0,255,0), (55,65,80)) \n        \n    def on_train_batch_end(self, batch, logs=None):\n        acc=logs.get('accuracy')* 100  # get training accuracy \n        loss=logs.get('loss')\n        msg='{0:20s}processing batch {1:4s} of {2:5s} accuracy= {3:8.3f}  loss: {4:8.5f}'.format(' ', str(batch), str(self.batches), acc, loss)\n        print(msg, '\\r', end='') # prints over on the same line to show running batch count\n        \n        \n    def on_epoch_begin(self,epoch, logs=None):\n        self.now= time.time()\n        \n    def on_epoch_end(self, epoch, logs=None):  # method runs on the end of each epoch\n        later=time.time()\n        duration=later-self.now \n        lr=float(tf.keras.backend.get_value(self.model.optimizer.lr)) # get the current learning rate\n        current_lr=lr\n        v_loss=logs.get('val_loss')  # get the validation loss for this epoch\n        acc=logs.get('accuracy')  # get training accuracy \n        v_acc=logs.get('val_accuracy')\n        loss=logs.get('loss')\n        #print ( '\\n',v_loss, self.lowest_vloss, acc, self.highest_tracc)\n        if acc < self.threshold: # if training accuracy is below threshold adjust lr based on training accuracy\n            monitor='accuracy'\n            if acc>self.highest_tracc: # training accuracy improved in the epoch                \n                self.highest_tracc=acc # set new highest training accuracy\n                LRA.best_weights=self.model.get_weights() # traing accuracy improved so save the weights\n                self.count=0 # set count to 0 since training accuracy improved\n                self.stop_count=0 # set stop counter to 0\n                if v_loss<self.lowest_vloss:\n                    self.lowest_vloss=v_loss\n                color= (0,255,0)\n                self.lr=lr\n            else: \n                # training accuracy did not improve check if this has happened for patience number of epochs\n                # if so adjust learning rate\n                if self.count>=self.patience -1:\n                    color=(245, 170, 66)\n                    self.lr= lr* self.factor # adjust the learning by factor\n                    tf.keras.backend.set_value(self.model.optimizer.lr, self.lr) # set the learning rate in the optimizer\n                    self.count=0 # reset the count to 0\n                    self.stop_count=self.stop_count + 1\n                    if self.dwell:\n                        self.model.set_weights(LRA.best_weights) # return to better point in N space                        \n                    else:\n                        if v_loss<self.lowest_vloss:\n                            self.lowest_vloss=v_loss                                    \n                else:\n                    self.count=self.count +1 # increment patience counter                    \n        else: # training accuracy is above threshold so adjust learning rate based on validation loss\n            monitor='val_loss'\n            if v_loss< self.lowest_vloss: # check if the validation loss improved \n                self.lowest_vloss=v_loss # replace lowest validation loss with new validation loss                \n                LRA.best_weights=self.model.get_weights() # validation loss improved so save the weights\n                self.count=0 # reset count since validation loss improved  \n                self.stop_count=0  \n                color=(0,255,0)\n                self.lr=lr\n            else: # validation loss did not improve\n                if self.count>=self.patience-1:\n                    color=(245, 170, 66)\n                    self.lr=self.lr * self.factor # adjust the learning rate                    \n                    self.stop_count=self.stop_count + 1 # increment stop counter because lr was adjusted \n                    self.count=0 # reset counter\n                    tf.keras.backend.set_value(self.model.optimizer.lr, self.lr) # set the learning rate in the optimizer\n                    if self.dwell:\n                        self.model.set_weights(LRA.best_weights) # return to better point in N space\n                else: \n                    self.count =self.count +1 # increment the patience counter                    \n                if acc>self.highest_tracc:\n                    self.highest_tracc= acc\n        msg=f'{str(epoch+1):^3s}\/{str(self.epochs):4s} {loss:^9.3f}{acc*100:^9.3f}{v_loss:^9.5f}{v_acc*100:^9.3f}{current_lr:^9.5f}{self.lr:^9.5f}{monitor:^11s}{duration:^8.2f}'\n        print_in_color (msg,color, (55,65,80))\n        if self.stop_count> self.stop_patience - 1: # check if learning rate has been adjusted stop_count times with no improvement\n            msg=f' training has been halted at epoch {epoch + 1} after {self.stop_patience} adjustments of learning rate with no improvement'\n            print_in_color(msg, (0,255,255), (55,65,80))\n            self.model.stop_training = True # stop training\n        else: \n            if self.ask_epoch !=None:\n                if epoch + 1 >= self.ask_epoch:\n                    msg='enter H to halt training or an integer for number of epochs to run then ask again'\n                    print_in_color(msg, (0,255,255), (55,65,80))\n                    ans=input('')\n                    if ans=='H' or ans=='h':\n                        msg=f'training has been halted at epoch {epoch + 1} due to user input'\n                        print_in_color(msg, (0,255,255), (55,65,80))\n                        self.model.stop_training = True # stop training\n                    else:\n                        ans=int(ans)\n                        self.ask_epoch +=ans\n                           \n                   ","6f6c2d25":"epochs =40\npatience= 1 # number of epochs to wait to adjust lr if monitored value does not improve\nstop_patience =3 # number of epochs to wait before stopping training if monitored value does not improve\nthreshold=.9 # if train accuracy is < threshhold adjust monitor accuracy, else monitor validation loss\nfactor=.5 # factor to reduce lr by\ndwell=True # experimental, if True and monitored metric does not improve on current epoch set  modelweights back to weights of previous epoch\nfreeze=False # if true free weights of  the base model\nask_epoch=10 # number of epochs to run before asking if you want to halt training\nbatches=train_steps\ncallbacks=[LRA(model=model,patience=patience,stop_patience=stop_patience, threshold=threshold,\n                   factor=factor,dwell=dwell, model_name=model_name, freeze=freeze, batches=batches,initial_epoch=0,epochs=epochs, ask_epoch=ask_epoch )]\n\nhistory=model.fit(x=train_gen,  epochs=epochs, verbose=0, callbacks=callbacks,  validation_data=valid_gen,\n               validation_steps=None,  shuffle=False,  initial_epoch=0)","e2caf6af":"def tr_plot(tr_data, start_epoch):\n    #Plot the training and validation data\n    tacc=tr_data.history['accuracy']\n    tloss=tr_data.history['loss']\n    vacc=tr_data.history['val_accuracy']\n    vloss=tr_data.history['val_loss']\n    Epoch_count=len(tacc)+ start_epoch\n    Epochs=[]\n    for i in range (start_epoch ,Epoch_count):\n        Epochs.append(i+1)   \n    index_loss=np.argmin(vloss)#  this is the epoch with the lowest validation loss\n    val_lowest=vloss[index_loss]\n    index_acc=np.argmax(vacc)\n    acc_highest=vacc[index_acc]\n    plt.style.use('fivethirtyeight')\n    sc_label='best epoch= '+ str(index_loss+1 +start_epoch)\n    vc_label='best epoch= '+ str(index_acc + 1+ start_epoch)\n    fig,axes=plt.subplots(nrows=1, ncols=2, figsize=(20,8))\n    axes[0].plot(Epochs,tloss, 'r', label='Training loss')\n    axes[0].plot(Epochs,vloss,'g',label='Validation loss' )\n    axes[0].scatter(index_loss+1 +start_epoch,val_lowest, s=150, c= 'blue', label=sc_label)\n    axes[0].set_title('Training and Validation Loss')\n    axes[0].set_xlabel('Epochs')\n    axes[0].set_ylabel('Loss')\n    axes[0].legend()\n    axes[1].plot (Epochs,tacc,'r',label= 'Training Accuracy')\n    axes[1].plot (Epochs,vacc,'g',label= 'Validation Accuracy')\n    axes[1].scatter(index_acc+1 +start_epoch,acc_highest, s=150, c= 'blue', label=vc_label)\n    axes[1].set_title('Training and Validation Accuracy')\n    axes[1].set_xlabel('Epochs')\n    axes[1].set_ylabel('Accuracy')\n    axes[1].legend()\n    plt.tight_layout\n    #plt.style.use('fivethirtyeight')\n    plt.show()\n","ae332f0e":"def print_info( test_gen, preds, print_code, save_dir, subject ):\n    class_dict=test_gen.class_indices\n    labels= test_gen.labels\n    file_names= test_gen.filenames \n    error_list=[]\n    true_class=[]\n    pred_class=[]\n    prob_list=[]\n    new_dict={}\n    error_indices=[]\n    y_pred=[]\n    for key,value in class_dict.items():\n        new_dict[value]=key             # dictionary {integer of class number: string of class name}\n    # store new_dict as a text fine in the save_dir\n    classes=list(new_dict.values())     # list of string of class names\n    dict_as_text=str(new_dict)\n    dict_name= subject + '-' +str(len(classes)) +'.txt'  \n    dict_path=os.path.join(save_dir,dict_name)    \n    with open(dict_path, 'w') as x_file:\n        x_file.write(dict_as_text)    \n    errors=0      \n    for i, p in enumerate(preds):\n        pred_index=np.argmax(p)        \n        true_index=labels[i]  # labels are integer values\n        if pred_index != true_index: # a misclassification has occurred\n            error_list.append(file_names[i])\n            true_class.append(new_dict[true_index])\n            pred_class.append(new_dict[pred_index])\n            prob_list.append(p[pred_index])\n            error_indices.append(true_index)            \n            errors=errors + 1\n        y_pred.append(pred_index)    \n    if print_code !=0:\n        if errors>0:\n            if print_code>errors:\n                r=errors\n            else:\n                r=print_code           \n            msg='{0:^28s}{1:^28s}{2:^28s}{3:^16s}'.format('Filename', 'Predicted Class' , 'True Class', 'Probability')\n            print_in_color(msg, (0,255,0),(55,65,80))\n            for i in range(r):                \n                split1=os.path.split(error_list[i])                \n                split2=os.path.split(split1[0])                \n                fname=split2[1] + '\/' + split1[1]\n                msg='{0:^28s}{1:^28s}{2:^28s}{3:4s}{4:^6.4f}'.format(fname, pred_class[i],true_class[i], ' ', prob_list[i])\n                print_in_color(msg, (255,255,255), (55,65,60))\n                #print(error_list[i]  , pred_class[i], true_class[i], prob_list[i])               \n        else:\n            msg='With accuracy of 100 % there are no errors to print'\n            print_in_color(msg, (0,255,0),(55,65,80))\n    if errors>0:\n        plot_bar=[]\n        plot_class=[]\n        for  key, value in new_dict.items():        \n            count=error_indices.count(key) \n            if count!=0:\n                plot_bar.append(count) # list containg how many times a class c had an error\n                plot_class.append(value)   # stores the class \n        fig=plt.figure()\n        fig.set_figheight(len(plot_class)\/3)\n        fig.set_figwidth(10)\n        plt.style.use('fivethirtyeight')\n        for i in range(0, len(plot_class)):\n            c=plot_class[i]\n            x=plot_bar[i]\n            plt.barh(c, x, )\n            plt.title( ' Errors by Class on Test Set')\n    y_true= np.array(labels)        \n    y_pred=np.array(y_pred)\n    if len(classes)<= 30:\n        # create a confusion matrix \n        cm = confusion_matrix(y_true, y_pred )        \n        length=len(classes)\n        if length<8:\n            fig_width=8\n            fig_height=8\n        else:\n            fig_width= int(length * .5)\n            fig_height= int(length * .5)\n        plt.figure(figsize=(fig_width, fig_height))\n        sns.heatmap(cm, annot=True, vmin=0, fmt='g', cmap='Blues', cbar=False)       \n        plt.xticks(np.arange(length)+.5, classes, rotation= 90)\n        plt.yticks(np.arange(length)+.5, classes, rotation=0)\n        plt.xlabel(\"Predicted\")\n        plt.ylabel(\"Actual\")\n        plt.title(\"Confusion Matrix\")\n        plt.show()\n    clr = classification_report(y_true, y_pred, target_names=classes)\n    print(\"Classification Report:\\n----------------------\\n\", clr)","80d225c8":"tr_plot(history,0)\nsave_dir=r'.\/'\nsubject='plants'\nacc=model.evaluate( test_gen, batch_size=test_batch_size, verbose=1, steps=test_steps, return_dict=False)[1]*100\nmsg=f'accuracy on the test set is {acc:5.2f} %'\nprint_in_color(msg, (0,255,0),(55,65,80))\nsave_id=str (model_name +  '-' + subject +'-'+ str(acc)[:str(acc).rfind('.')+3] + '.h5')\nsave_loc=os.path.join(save_dir, save_id)\nmodel.save(save_loc)","78fb061b":"print_code=0\npreds=model.predict(test_gen) \nprint_info( test_gen, preds, print_code, save_dir, subject )  ","80988970":"fpath=r'..\/input\/plantdisease\/PlantVillage\/Pepper__bell___Bacterial_spot\/0022d6b7-d47c-4ee2-ae9a-392a53f48647___JR_B.Spot 8964.JPG'\nimg=plt.imread(fpath)\nprint ('Input image shape is ', img.shape)\n# resize the image so it is the same size as the images the model was trained on\nimg=cv2.resize(img, img_size) # in earlier code img_size=(224,224) was used for training the model\nprint ('the resized image has shape ', img.shape)\n### show the resized image\nplt.imshow(img)\n# Normally the next line of code rescales the images. However the EfficientNet model expects images in the range 0 to 255\n# img= img\/255\n# plt.imread returns a numpy array so it is not necessary to convert the image to a numpy array\n# since we have only one image we have to expand the dimensions of img so it is off the form (1,224,224,3)\n# where the first dimension 1 is the batch size used by model.predict\nimg=np.expand_dims(img, axis=0)\nprint ('image shape after expanding dimensions is ',img.shape)\n# now predict the image\npred=model.predict(img)\nprint (' the shape of prediction is ', pred.shape)\n# this dataset has 15 classes so model.predict will return a list of 15 probability values\n# we want to find the index of the column that has the highest probability\nindex=np.argmax(pred[0])\n# to get the actual Name of the class earlier Imade a list of the class names called classes\nklass=classes[index]\n# lets get the value of the highest probability\nprobability=pred[0][index]*100\n# print out the class, and the probability \nprint('the image is predicted as being ', klass, ' with a probability of ', probability)\n","ca4715fb":"### if you want to predict on several images the code is very similar. Lets make a directory and store 2 image files in it\n### one will be the image we used above. The second will be an image of a tomato leaf with Target_spot disease","6b123c65":"working_dir = r'.\/' # kagle working directory\n# in the working directory create a sub directory called test_images\ndir_path=os.path.join(working_dir, 'test_images')\nif os.path.isdir(dir_path): # check if the directory exists, if it does remove it and all its content\n    shutil.rmtree(dir_path)\nos.mkdir(dir_path) # make a new empty directory\nimg1_path=r'..\/input\/plantdisease\/PlantVillage\/Pepper__bell___Bacterial_spot\/0022d6b7-d47c-4ee2-ae9a-392a53f48647___JR_B.Spot 8964.JPG'\nimg2_path = r'..\/input\/plantdisease\/PlantVillage\/Tomato__Target_Spot\/002213fb-b620-4593-b9ac-6a6cc119b100___Com.G_TgS_FL 8360.JPG'\nimg1_destination=os.path.join(dir_path,'img1.jpg')\nshutil.copy(img1_path, img1_destination)\nimg2_destination=os.path.join(dir_path, 'img2.jpg')\nshutil.copy(img2_path, img2_destination)\n# check if the files are there\nfiles = os.listdir(dir_path)\nprint (files)            \n            \n","0a187ee9":"images=[]\nfile_list=os.listdir(dir_path)\nfor f in file_list:\n    fpath=os.path.join(dir_path,f)\n    img=plt.imread(fpath)\n    img=cv2.resize(img, img_size)\n    images.append(img)\nimg_array=np.array(images)\nprint (' shape of the image array is ',img_array.shape)\npreds=model.predict(img_array)\nprint('shape of preds is ', preds.shape)\nfi='FILE'\nci='CLASS'\npi='PROBABILITY'\nprint(f'{fi:^10s} {ci:^35s} {pi:^10s}')\nfor i, p in enumerate(preds):\n    index=np.argmax(p)\n    klass=classes[index]    \n    probability=p[index]*100\n    file=file_list[i]\n    print (f'{file:^10s}{klass:^35s}  {probability:^10.2f}')\n    \n\n    ","c2237ea2":"### create a subclass of callbacks to control learning rate and print training results for each epoch","e47ad665":"### define function to plot the training data","b9cfaeac":"### To balance the dataset we will create augmented images for classes with less than 370 samples\n### first create directories to hold the augmented images","fa8bba3f":"### As you can see the prediction is correct","f9bff792":"### Create the aux_df then concatenate with df ","8ea8abcb":"###  now all classes in df have the target number of samples\n### split df into train_df and valid_df","8bc11e88":"### define function to print text in RGB foreground and background colors","59169d93":"###  iterate through the data directory and create a data frame of the form filepaths, labels","28bf9fea":"### **This notebook contains a custom callback you may wish to copy and use  \nIt is a combination of the Keras callbacks Reduce Learning Rate on Plateau,  \nEarly Stopping and Model Checkpoint but eliminates some of the limitations  \nof each. In addition it provides an easier to read summary of the model's  \nperformance at the end of each epoch. It also provides a handy feature  \nthat enables you to set the number of epochs to train for until a message  \nasks if you wish to halt training on the current epoch by entering H or  \nto enter an integer which will determine how many more epochs to run  \nbefore the message appears again. This is very useful if you are training  \na model and decide the metrics are satisfactory and you want to end  \nthe model training early. Note the callback always returns your model  \nwith the weights set to those of the epoch which had the highest performance  \non the metric being monitored (accuracy or validation accuracy)  \nThe callback initially monitors training accuracy and will adjust the learning  \nrate based on that until the accuracy reaches a user specified threshold  \nlevel. Once that level of training accuracy is achieved the callback switches  \nto monitoring validation loss and adjusts the learning rate based on that.  \nthe callback is of the form:  \ncallbacks=[LRA(model, patience, stop_patience, threshold,factor, dwell,\n               model_name, freeze, batches,initial_epoch, epochs, ask_epoch )]    \n **where:**\n - **model** is your compiled model\n - **patience** is an integer that determines many consecutive epochs can occur before the learning rate\n   will be adjusted (similar to patience parameter in Reduce Learning Rate on Plateau)\n \n - **stop_patience** is an integer that determines hom many consecutive epochs for which the\n   learning rate was adjusted but no improvement in the monitored metric occurred before\n   training is halted(similar to patience parameter in early stopping)\n \n - **threshold** is a float that determines the level that training accuracy must achieve\n   before the callback switches over to monitoring validation loss. This  is useful for\n   cases where the validation loss in early epochs tends to vary widely and can cause\n   unwanted behavior when using the conventional Keras callbacks\n - **factor** is a float that determines the new learning rate by the equation lr=lr*factor.\n   (similar to the factor parameter in Reduce Learning Rate on Plateau)\n - **dwell** is a boolean. It is used in the callback as part of an experiment on training\n   models. If on a given epoch the metric being monitored fails to improve it means\n   your model has moved to a location on the surface of Nspace (where N is the number\n   of trainable parameters) that is NOT as favorable (poorer metric performance) than\n   the position in Nspace you were in for the previous epoch. If dwell is set to True\n   the callback loads the model with the weights from the previous (better metric value)\n   epoch. Why move to a worse place if the place you were in previously was better. Then\n   the learning rate is reduced for the next epoch of training. If dwell is set to false\n   this action does not take place.\n \n - **model_name** is a string\n - **freeze** is just a boolean\n   Note model_name and freeze are simply used to print out a header at the start of training.\n   For example is model_name is set to 'InceptionResnetV2' and freeze is set to False\n   the header would appear as 'Training InceptionResnetV2 traing all layers'. If freeze\n   is set to False the header would be 'Training InceptionRenetV2 base model layers frozen'\n   Parameter freese does not make the basemodel non trainable you must do that in\n   seperate code when building your model.\n - **batches** is an integer. It should be set to a value of \n   batches=int(number of traing samples\/batch_size). During training the callback provides\n   information during an epoch of the form\n   'processing batch of batches  accuracy= accuracy  loss= loss where batch is the current \n    batch being processs, batches is as described above, accuracy is the current training\n    accuracy and loss is the current loss. Typically the message would appear as\n    processing batch 25 of 50  accuracy: 54%  loss: .04567. As each batch is processed\n    these values are changed.    \n - **initial_epoch** is an integer. Typically set this to zero Itis used in the information\n    printed out for each epoch. In the case where you train the model say with the\n    basemodel weights frozen say you train for 10 epochs. Then you want to fine tune\n    the model and train for more eppochs for the second training session you would\n    reinstantiate the callback and set initial_epoch=10.\n - **epochs** an integer value for the number of epochs to train\n - **ask_epoch** is either set to an integer value or None. If set to an integer it denotes\n    the epoch number at which user input is requested. If the user enter H training is\n    halted. If the user inters an integer it represents how many more epochs to run\n    before you are asked for the user input again. If ask_epoch is set to None the\n    user is NOT asked to provide any input. This feature is handy is when training your model\n    and the metrics are either unsatisfactory and you want to stop training, or for the case\n    where your metrics are satisfactory and there is no need to train any further. Note\n    you model is always set to the weights for the epoch that had the beset metric\n    performance. So if you halt the training you can still use the model for predictions.  \n      \n ### ** Example of Use:\n callbacks=[LRA(my_model, 2, 5, .9, .5, True, 'InceptionResnetV2', False, 80,20,10)]\n this implies:\n - your model is my_model\n - after 2 epochs of no improvement the learning rate will be reduced\n - after 5 consecutive adjustment of the leaarning rate with no metric improve training terminates\n - once the training accuracy reaches 90% the callback adjust learning rate based on validation loss\n - when the learning rate is adjust the new learning rate is .5 X learning rate\n - if the current epoch's metric value did not improve, the weights for the prior epoch are loaded\n   and the learning rate is reduced\n - the string name of your model to print in the header at the start of training\n - the header will note the entire model is being trained\n - the number of batches per epoch is 80\n - train for 20 epochs\n - after the tenth epoch you will be asked if you want to halt training by entering H or enter \n   an integer denoting how many more epochs to run before you will be prompted again\n                 \n","9458826a":"### create function to show some image examples","b8ebf5a6":"### create train, test, valid  generators","e4c2a356":"### create the model","a7dac44d":"### look at some augmented images","5f0b0c2d":"### some viewers have asked how to use the trained model to predict a single image\n### the code below demonstrates that using a Pepper__bell___Bacterial_spot image","f5d20953":"### input an image","4ceb1650":"### evaluate model on the test set then save the model","3f663da3":"### instantiate the custom callback and train the model","ab5f82fc":"### this is a very unbalanced data set for df,  limit  maximum number of samples in a class to 500","7358da9a":"### create augmented images and store in the aug directories\n","7fd8c6e7":"### define function to generate the confusion matrix and classification report","fdfd77c1":"### make predictions on test set and generate confusion matrix and classification report","9b0532ad":"### so we have 2 files in a directory that we want to predict\n### the code for that is shown below"}}