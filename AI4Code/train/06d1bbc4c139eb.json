{"cell_type":{"6a9f3e69":"code","a52049e8":"code","405ce965":"code","3f1131f5":"code","47a6b0d9":"code","a7cab030":"code","9f6a9b12":"code","7d542c35":"code","2382c957":"code","8c5158ee":"code","923e14ee":"code","a1bff8b9":"code","5b38aa38":"code","18092ac9":"code","dc6bc10c":"code","b3a7f7cc":"code","127f9d66":"code","86af34a8":"code","a70a7095":"code","e325c9b6":"code","29ebf4fe":"code","38fdf6c7":"code","c95c4973":"code","edf44b6a":"code","44cfc209":"markdown","7f167e26":"markdown","8cbbdd0b":"markdown","ae15e36c":"markdown","ebd63538":"markdown","a801824a":"markdown","95c044d6":"markdown"},"source":{"6a9f3e69":"package_paths = [\n    \"..\/input\/pytorch-image-library\/pytorch-image-models-master\/pytorch-image-models-master\",\n]\nimport sys;\n\nfor pth in package_paths:\n    sys.path.append(pth)\n\nimport timm","a52049e8":"import pandas as pd\nimport numpy as np\nimport cv2\nimport torch\nimport torch.nn as nn\nimport albumentations as A\n\nfrom torch.utils.data import Dataset, DataLoader\nfrom albumentations.core.composition import Compose, OneOf\nfrom albumentations.pytorch import ToTensorV2","405ce965":"class CFG:\n    seed = 42\n    model_name = 'tf_efficientnet_b5_ns'\n    pretrained = False\n    img_size = 512\n    num_classes = 6\n    lr = 2.5e-4\n    min_lr = 1e-6\n    t_max = 20\n    num_epochs = 20\n    batch_size = 32\n    accum = 1\n    precision = 16\n    n_fold = 5\n    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')","3f1131f5":"PATH = \"..\/input\/plant-pathology-2021-fgvc8\/\"\n\nTEST_DIR = PATH + 'test_images\/'","47a6b0d9":"df_all = pd.read_csv(PATH + \"train.csv\")\ndf_all.shape","a7cab030":"from collections import defaultdict\n\n\ndct = defaultdict(list)\n\nfor i, label in enumerate(df_all.labels):\n    for category in label.split():\n        dct[category].append(i)\n \ndct = {key: np.array(val) for key, val in dct.items()}\ndct","9f6a9b12":"new_df = pd.DataFrame(np.zeros((df_all.shape[0], len(dct.keys())), dtype=np.int8), columns=dct.keys())\n\nfor key, val in dct.items():\n    new_df.loc[val, key] = 1\n    \ndf_all = pd.concat([df_all, new_df], axis=1)\ndf_all.head()","7d542c35":"multi_labels = new_df.columns\nmulti_labels","2382c957":"sub = pd.read_csv(PATH + \"sample_submission.csv\")\nsub.head()","8c5158ee":"tmp = pd.DataFrame(np.zeros([len(sub), len(new_df.columns)]), columns=multi_labels)\nsub = pd.concat([sub, tmp], axis=1)\nsub.head()","923e14ee":"class PlantDataset(Dataset):\n    def __init__(self, df, transform=None):\n        self.image_id = df['image'].values\n        self.labels = df.iloc[:, 2:].values\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.labels)\n\n    def __getitem__(self, idx):\n        image_id = self.image_id[idx]\n        label = torch.tensor(self.labels[idx], dtype=torch.float32)\n        \n        image_path = TEST_DIR + image_id\n        image = cv2.imread(image_path)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        \n        augmented = self.transform(image=image)\n        image = augmented['image']\n        return {'image':image, 'target': label}","a1bff8b9":"def get_transform(phase: str):\n    if phase == 'train':\n        return Compose([\n            A.RandomResizedCrop(height=CFG.img_size, width=CFG.img_size),\n            A.HorizontalFlip(p=0.5),\n            A.ShiftScaleRotate(p=0.5),\n            A.RandomBrightnessContrast(p=0.5),\n            A.Normalize(),\n            ToTensorV2(),\n        ])\n    else:\n        return Compose([\n            A.Resize(height=CFG.img_size, width=CFG.img_size),\n            A.Normalize(),\n            ToTensorV2(),\n        ])","5b38aa38":"test_dataset = PlantDataset(sub, get_transform('valid'))\ntest_loader = DataLoader(test_dataset, batch_size=CFG.batch_size, shuffle=False, num_workers=2)","18092ac9":"class CustomResNet(nn.Module):\n    def __init__(self, model_name='resnet18', pretrained=True):\n        super().__init__()\n        self.model = timm.create_model(model_name, pretrained=pretrained)\n        in_features = self.model.get_classifier().in_features\n#         self.model.fc = nn.Linear(in_features, CFG.num_classes)\n        self.model.fc = nn.Sequential(\n            nn.Linear(in_features, in_features),\n            nn.ReLU(inplace=True),\n            nn.Dropout(0.5),\n            nn.Linear(in_features, CFG.num_classes)\n        )\n\n    def forward(self, x):\n        x = self.model(x)\n        return x","dc6bc10c":"class CustomEffNet(nn.Module):\n    def __init__(self, model_name='tf_efficientnet_b0_ns', pretrained=True):\n        super().__init__()\n        self.model = timm.create_model(model_name, pretrained=pretrained)\n        in_features = self.model.get_classifier().in_features\n#         self.model.fc = nn.Linear(in_features, CFG.num_classes)\n        self.model.classifier = nn.Sequential(\n            nn.Linear(in_features, in_features),\n            nn.ReLU(inplace=True),\n            nn.Dropout(0.5),\n            nn.Linear(in_features, CFG.num_classes)\n        )\n\n    def forward(self, x):\n        x = self.model(x)\n        return x","b3a7f7cc":"from collections import OrderedDict\n\ndef fix_model_state_dict(state_dict):\n    new_state_dict = OrderedDict()\n    for k, v in state_dict.items():\n        name = k\n        if name.startswith('model.'):\n            name = name[6:]  # remove 'model.' of dataparallel\n        new_state_dict[name] = v\n    return new_state_dict","127f9d66":"# model = CustomResNet(model_name=CFG.model_name, pretrained=False)\nmodel = CustomEffNet(model_name=CFG.model_name, pretrained=False)","86af34a8":"checkpoint = \"..\/input\/plant2021-multi-label-model-training\/logs\/tf_efficientnet_b5_ns\/version_0\/checkpoints\/last.ckpt\"\nmodel.load_state_dict(torch.load(checkpoint)['state_dict'])","a70a7095":"model.cuda()\nmodel.eval()\n\nsigmoid = nn.Sigmoid()\n\npredictions = []\nfor batch in test_loader:\n    image = batch['image'].cuda()\n    with torch.no_grad():\n        outputs = model(image)\n        preds = outputs.detach().cpu()\n        # The probability of 0.5 or more is considered positive.\n        predictions.append(sigmoid(preds).numpy() > 0.5)","e325c9b6":"predictions = pd.DataFrame(np.concatenate(predictions).astype(np.int), columns=new_df.columns)","29ebf4fe":"sub.iloc[:, 2:] = predictions\nsub","38fdf6c7":"sub","c95c4973":"labels = []\nfor i, row in sub.iloc[:, 2:].iterrows():\n    if ((row['healthy'] == 1) or row.sum() == 0):\n        tmp = 'healthy'\n    else:\n        tmp = ' '.join(multi_labels[row==row.max()])\n    labels.append(tmp)","edf44b6a":"sub['labels'] = labels\nsub[['image', 'labels']].to_csv('submission.csv', index=False)\nsub.head()","44cfc209":"# Define Model","7f167e26":"# Config","8cbbdd0b":"# Import","ae15e36c":"# Inference","ebd63538":"## Version Notes\n\n- train  V4, inference v4, Model: Resnet50,           IMAGE_SIZE: 512, BS: 32, LB: 0.616\n- train  V6, inference V5, Model: SE-ResNeXt50_32x4d, IMAGE_SIZE: 512, BS: 16, LB: 0.555\n- train  V8, inference v6, Model: Resnet50,           IMAGE_SIZE: 512, BS: 32, LB: 0.584\n  - Add processing to remove duplicates\n- train V11, inference v7, Model: Resnet50,           IMAGE_SIZE: 512, BS: 32, LB: 0.585\n  - More epoch, change lr_scheduler\n- train V14, inference v8, Model: Resnet50,           IMAGE_SIZE: 512, BS: 32, LB: 0.572\n  - torchmetrics F1\n- train V15, inference v9, Model: Resnet50,           IMAGE_SIZE: 512, BS: 32, LB: 0.560\n  - Focal Loss(alpha=1, gamma=2)\n- train V16, inference v11, Model: Resnet50,          IMAGE_SIZE: 512, BS: 32, LB: 0.580\n  - iterative-stratification(cross validators with stratification for multilabel data)\n- train V17, inference v12, Model: Resnet50           IMAGE_SIZE: 512, BS: 32, LB: ???\n  - epoch 60\n- train V18, inference v14, Model: EfficientNetB5 NS, IMAGE_SIZE: 512, BS: 16, LB: ???","a801824a":"# Overview\n\nIn this notebook, I used Pytorch Lightning to solve it as a multi-label problem.\nI used the following [notebook](https:\/\/www.kaggle.com\/demetrypascal\/better-train-csv-format-keras-starter) as a reference.\n\nThe accuracy of the multi-label solution is about the same as that of the simple solution, and I think the accuracy can be improved by post-processing.\n\n[Training Notebook](https:\/\/www.kaggle.com\/pegasos\/plant2021-multi-label-model-training)","95c044d6":"# Define Dataset"}}