{"cell_type":{"a024ae75":"code","7cb243b5":"code","c02291b6":"code","41350f0d":"code","2f760ef2":"code","665e5263":"code","c585a76f":"code","021c0f44":"code","3ae8c244":"code","47ef19a3":"code","b1cb3e1a":"code","46b262f3":"code","13236189":"code","d643e20c":"code","c579558e":"code","6df56518":"code","e4723fe9":"code","e9714ed1":"code","fcf36ea0":"code","d2750945":"code","1f21a338":"code","d7c6fd42":"code","15c4d923":"code","e3d36a2c":"code","657b3cf7":"markdown","14b5fbc9":"markdown","5b0826cb":"markdown","a97efa63":"markdown","56811192":"markdown","ee6f0446":"markdown","4d3fb019":"markdown","03afcba6":"markdown","3784dbf9":"markdown","d19a2513":"markdown","9859d43d":"markdown","8adada4d":"markdown","ea13adfc":"markdown","cda1362c":"markdown","e19649f6":"markdown","642c608b":"markdown","7851523f":"markdown"},"source":{"a024ae75":"!pip install keras==2.2.4 # critical dependency\n!pip install -q bert-tensorflow==1.0.1","7cb243b5":"!pip freeze > kaggle_image_requirements.txt","c02291b6":"# Import neural network libraries\nimport tensorflow as tf\nimport tensorflow_hub as hub\nfrom bert.tokenization import FullTokenizer\nfrom tensorflow.keras import backend as K\n\n# Initialize session\nsess = tf.Session()","41350f0d":"# Some other key imports\nimport os\nimport re\nimport pandas as pd\nimport numpy as np\nfrom tqdm import tqdm","2f760ef2":"# Params for bert model and tokenization\nNsamp = 1000 # number of samples to generate in each class - 'spam', 'not spam'\nmaxtokens = 200 # the maximum number of tokens per document\nmaxtokenlen = 100 # the maximum length of each token","665e5263":"def tokenize(row):\n    if row is None or row is '':\n        tokens = \"\"\n    else:\n        try:\n            tokens = row.split(\" \")[:maxtokens]\n        except:\n            tokens=\"\"\n    return tokens","c585a76f":"def reg_expressions(row):\n    tokens = []\n    try:\n        for token in row:\n            token = token.lower()\n            token = re.sub(r'[\\W\\d]', \"\", token)\n            token = token[:maxtokenlen] # truncate token\n            tokens.append(token)\n    except:\n        token = \"\"\n        tokens.append(token)\n    return tokens","021c0f44":"import nltk\n\nnltk.download('stopwords')\nfrom nltk.corpus import stopwords\nstopwords = stopwords.words('english')    \nprint(stopwords) # see default stopwords\n\ndef stop_word_removal(row):\n    token = [token for token in row if token not in stopwords]\n    token = filter(None, token)\n    return token","3ae8c244":"# Input data files are available in the \"..\/input\/\" directory.\nfilepath = \"..\/input\/enron-email-dataset\/emails.csv\"\n\n# Read the data into a pandas dataframe called emails\nemails = pd.read_csv(filepath)\n\nprint(\"Successfully loaded {} rows and {} columns!\".format(emails.shape[0], emails.shape[1]))\nprint(emails.head())","47ef19a3":"# take a closer look at the first email\nprint(emails.loc[0][\"message\"])","b1cb3e1a":"# Separate headers from the message bodies\nimport email\n\ndef extract_messages(df):\n    messages = []\n    for item in df[\"message\"]:\n        # Return a message object structure from a string\n        e = email.message_from_string(item)    \n        # get message body  \n        message_body = e.get_payload()\n        messages.append(message_body)\n    print(\"Successfully retrieved message body from e-mails!\")\n    return messages\n\nbodies = extract_messages(emails)","46b262f3":"# extract random 10000 enron email bodies for building dataset\nimport random\nbodies_df = pd.DataFrame(random.sample(bodies, 10000))\n\n# expand default pandas display options to make emails more clearly visible when printed\npd.set_option('display.max_colwidth', 300)\n\nbodies_df.head() # you could do print(bodies_df.head()), but Jupyter displays this nicer for pandas DataFrames","13236189":"#messages = emails[\"message\"].apply(email.message_from_string)\n#bodies_df = messages.apply(lambda x: x.get_payload()).sample(10000)","d643e20c":"filepath = \"..\/input\/fraudulent-email-corpus\/fradulent_emails.txt\"\nwith open(filepath, 'r',encoding=\"latin1\") as file:\n    data = file.read()\n    \n# split on a code word appearing close to the beginning of each email\nfraud_emails = data.split(\"From r\")\n\nprint(\"Successfully loaded {} spam emails!\".format(len(fraud_emails)))","c579558e":"fraud_bodies = extract_messages(pd.DataFrame(fraud_emails,columns=[\"message\"],dtype=str))\nfraud_bodies_df = pd.DataFrame(fraud_bodies[1:])\n\nfraud_bodies_df.head() # you could do print(fraud_bodies_df.head()), but Jupyter displays this nicer for pandas DataFrames","6df56518":"import random\n\n# Convert everything to lower-case, truncate to maxtokens and truncate each token to maxtokenlen\nEnronEmails = bodies_df.iloc[:,0].apply(tokenize)\nEnronEmails = EnronEmails.apply(stop_word_removal)\nEnronEmails = EnronEmails.apply(reg_expressions)\nEnronEmails = EnronEmails.sample(Nsamp)\n\nSpamEmails = fraud_bodies_df.iloc[:,0].apply(tokenize)\nSpamEmails = SpamEmails.apply(stop_word_removal)\nSpamEmails = SpamEmails.apply(reg_expressions)\nSpamEmails = SpamEmails.sample(Nsamp)\n\nraw_data = pd.concat([SpamEmails,EnronEmails], axis=0).values","e4723fe9":"print(\"Shape of combined data represented as numpy array is:\")\nprint(raw_data.shape)\nprint(\"Data represented as numpy array is:\")\nprint(raw_data)\n\n# corresponding labels\nCategories = ['spam','notspam']\nheader = ([1]*Nsamp)\nheader.extend(([0]*Nsamp))","e9714ed1":"# function for shuffling data in unison with labels\/header\ndef unison_shuffle(a, b):\n    p = np.random.permutation(len(b))\n    data = a[p]\n    header = np.asarray(b)[p]\n    return data, header\n\n# function for converting data into the right format, due to the difference in required format from sklearn models\n# we expect a single string per email here, versus a list of tokens for the sklearn models previously explored\ndef convert_data(raw_data,header):\n    converted_data, labels = [], []\n    for i in range(raw_data.shape[0]):\n        out = ' '.join(raw_data[i])\n        converted_data.append(out)\n        labels.append(header[i])\n        #print(i)\n    converted_data = np.array(converted_data, dtype=object)[:, np.newaxis]\n    \n    return converted_data, np.array(labels)\n\nraw_data, header = unison_shuffle(raw_data, header)\n\n# split into independent 70% training and 30% testing sets\nidx = int(0.7*raw_data.shape[0])\n# 70% of data for training\ntrain_x, train_y = convert_data(raw_data[:idx],header[:idx])\n# remaining 30% for testing\ntest_x, test_y = convert_data(raw_data[idx:],header[idx:])\n\nprint(\"train_x\/train_y list details, to make sure it is of the right form:\")\nprint(len(train_x))\nprint(train_x)\nprint(train_y[:5])\nprint(train_y.shape)","fcf36ea0":"class InputExample(object):\n    \"\"\"A single training\/test example for simple sequence classification.\"\"\"\n\n    def __init__(self, guid, text_a, text_b=None, label=None):\n        \"\"\"Constructs a InputExample.\n    Args:\n      guid: Unique id for the example.\n      text_a: string. The untokenized text of the first sequence. For single\n        sequence tasks, only this sequence must be specified.\n      text_b: (Optional) string. The untokenized text of the second sequence.\n        Only must be specified for sequence pair tasks.\n      label: (Optional) string. The label of the example. This should be\n        specified for train examples, but not for test examples.\n    \"\"\"\n        self.guid = guid\n        self.text_a = text_a\n        self.text_b = text_b\n        self.label = label\n\n\ndef create_tokenizer_from_hub_module(bert_path):\n    \"\"\"Get the vocab file and casing info from the Hub module.\"\"\"\n    bert_module = hub.Module(bert_path)\n    tokenization_info = bert_module(signature=\"tokenization_info\", as_dict=True)\n    vocab_file, do_lower_case = sess.run(\n        [tokenization_info[\"vocab_file\"], tokenization_info[\"do_lower_case\"]]\n    )\n\n    return FullTokenizer(vocab_file=vocab_file, do_lower_case=do_lower_case)\n\n\ndef convert_single_example(tokenizer, example, max_seq_length=256):\n    \"\"\"Converts a single `InputExample` into a single `InputFeatures`.\"\"\"\n\n    tokens_a = tokenizer.tokenize(example.text_a)\n    if len(tokens_a) > max_seq_length - 2:\n        tokens_a = tokens_a[0 : (max_seq_length - 2)]\n\n    tokens = []\n    segment_ids = []\n    tokens.append(\"[CLS]\")\n    segment_ids.append(0)\n    for token in tokens_a:\n        tokens.append(token)\n        segment_ids.append(0)\n    tokens.append(\"[SEP]\")\n    segment_ids.append(0)\n\n    input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n    # The mask has 1 for real tokens and 0 for padding tokens. Only real\n    # tokens are attended to.\n    input_mask = [1] * len(input_ids)\n\n    # Zero-pad up to the sequence length.\n    while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(0)\n        segment_ids.append(0)\n\n    assert len(input_ids) == max_seq_length\n    assert len(input_mask) == max_seq_length\n    assert len(segment_ids) == max_seq_length\n\n    return input_ids, input_mask, segment_ids, example.label\n\n\ndef convert_examples_to_features(tokenizer, examples, max_seq_length=256):\n    \"\"\"Convert a set of `InputExample`s to a list of `InputFeatures`.\"\"\"\n\n    input_ids, input_masks, segment_ids, labels = [], [], [], []\n    for example in tqdm(examples, desc=\"Converting examples to features\"):\n        input_id, input_mask, segment_id, label = convert_single_example(\n            tokenizer, example, max_seq_length\n        )\n        input_ids.append(input_id)\n        input_masks.append(input_mask)\n        segment_ids.append(segment_id)\n        labels.append(label)\n    return (\n        np.array(input_ids),\n        np.array(input_masks),\n        np.array(segment_ids),\n        np.array(labels).reshape(-1, 1),\n    )\n\n\ndef convert_text_to_examples(texts, labels):\n    \"\"\"Create InputExamples\"\"\"\n    InputExamples = []\n    for text, label in zip(texts, labels):\n        InputExamples.append(\n            InputExample(guid=None, text_a=\" \".join(text), text_b=None, label=label)\n        )\n    return InputExamples","d2750945":"class BertLayer(tf.keras.layers.Layer):\n    def __init__(\n        self,\n        n_fine_tune_layers=10,\n        pooling=\"mean\",\n        bert_path=\"https:\/\/tfhub.dev\/google\/bert_uncased_L-12_H-768_A-12\/1\",\n        **kwargs,\n    ):\n        self.n_fine_tune_layers = n_fine_tune_layers\n        self.trainable = True\n        self.output_size = 768\n        self.pooling = pooling\n        self.bert_path = bert_path\n        if self.pooling not in [\"first\", \"mean\"]:\n            raise NameError(\n                f\"Undefined pooling type (must be either first or mean, but is {self.pooling}\"\n            )\n\n        super(BertLayer, self).__init__(**kwargs)\n\n    def build(self, input_shape):\n        self.bert = hub.Module(\n            self.bert_path, trainable=self.trainable, name=f\"{self.name}_module\"\n        )\n\n        # Remove unused layers\n        trainable_vars = self.bert.variables\n        if self.pooling == \"first\":\n            trainable_vars = [var for var in trainable_vars if not \"\/cls\/\" in var.name]\n            trainable_layers = [\"pooler\/dense\"]\n\n        elif self.pooling == \"mean\":\n            trainable_vars = [\n                var\n                for var in trainable_vars\n                if not \"\/cls\/\" in var.name and not \"\/pooler\/\" in var.name\n            ]\n            trainable_layers = []\n        else:\n            raise NameError(\n                f\"Undefined pooling type (must be either first or mean, but is {self.pooling}\"\n            )\n\n        # Select how many layers to fine tune\n        for i in range(self.n_fine_tune_layers):\n            trainable_layers.append(f\"encoder\/layer_{str(11 - i)}\")\n\n        # Update trainable vars to contain only the specified layers\n        trainable_vars = [\n            var\n            for var in trainable_vars\n            if any([l in var.name for l in trainable_layers])\n        ]\n\n        # Add to trainable weights\n        for var in trainable_vars:\n            self._trainable_weights.append(var)\n\n        for var in self.bert.variables:\n            if var not in self._trainable_weights:\n                self._non_trainable_weights.append(var)\n\n        super(BertLayer, self).build(input_shape)\n\n    def call(self, inputs):\n        inputs = [K.cast(x, dtype=\"int32\") for x in inputs]\n        input_ids, input_mask, segment_ids = inputs\n        bert_inputs = dict(\n            input_ids=input_ids, input_mask=input_mask, segment_ids=segment_ids\n        )\n        if self.pooling == \"first\":\n            pooled = self.bert(inputs=bert_inputs, signature=\"tokens\", as_dict=True)[\n                \"pooled_output\"\n            ]\n        elif self.pooling == \"mean\":\n            result = self.bert(inputs=bert_inputs, signature=\"tokens\", as_dict=True)[\n                \"sequence_output\"\n            ]\n\n            mul_mask = lambda x, m: x * tf.expand_dims(m, axis=-1)\n            masked_reduce_mean = lambda x, m: tf.reduce_sum(mul_mask(x, m), axis=1) \/ (\n                    tf.reduce_sum(m, axis=1, keepdims=True) + 1e-10)\n            input_mask = tf.cast(input_mask, tf.float32)\n            pooled = masked_reduce_mean(result, input_mask)\n        else:\n            raise NameError(f\"Undefined pooling type (must be either first or mean, but is {self.pooling}\")\n\n        return pooled\n\n    def compute_output_shape(self, input_shape):\n        return (input_shape[0], self.output_size)","1f21a338":"# Function to build overall model\ndef build_model(max_seq_length):\n    in_id = tf.keras.layers.Input(shape=(max_seq_length,), name=\"input_ids\")\n    in_mask = tf.keras.layers.Input(shape=(max_seq_length,), name=\"input_masks\")\n    in_segment = tf.keras.layers.Input(shape=(max_seq_length,), name=\"segment_ids\")\n    bert_inputs = [in_id, in_mask, in_segment]\n    \n    # just extract BERT features, don't fine-tune\n    bert_output = BertLayer(n_fine_tune_layers=0)(bert_inputs)\n    # train dense classification layer on top of extracted features\n    dense = tf.keras.layers.Dense(256, activation=\"relu\")(bert_output)\n    pred = tf.keras.layers.Dense(1, activation=\"sigmoid\")(dense)\n\n    model = tf.keras.models.Model(inputs=bert_inputs, outputs=pred)\n    model.compile(loss=\"binary_crossentropy\", optimizer=\"adam\", metrics=[\"accuracy\"])\n    model.summary()\n\n    return model\n\n# Function to initialize variables correctly\ndef initialize_vars(sess):\n    sess.run(tf.local_variables_initializer())\n    sess.run(tf.global_variables_initializer())\n    sess.run(tf.tables_initializer())\n    K.set_session(sess)","d7c6fd42":"# tf hub bert model path\nbert_path = \"https:\/\/tfhub.dev\/google\/bert_uncased_L-12_H-768_A-12\/1\" \n\n# Instantiate tokenizer\ntokenizer = create_tokenizer_from_hub_module(bert_path)\n\n# Convert data to InputExample format\ntrain_examples = convert_text_to_examples(train_x, train_y)\ntest_examples = convert_text_to_examples(test_x, test_y)\n\n# Convert to features\n(train_input_ids,train_input_masks,train_segment_ids,train_labels) = \\\nconvert_examples_to_features(tokenizer, train_examples, max_seq_length=maxtokens)\n(test_input_ids,test_input_masks,test_segment_ids,test_labels) = \\\nconvert_examples_to_features(tokenizer, test_examples, max_seq_length=maxtokens)\n\n# Build model\nmodel = build_model(maxtokens)\n\n# Instantiate variables\ninitialize_vars(sess)\n\n# Train model\nhistory = model.fit([train_input_ids, train_input_masks, train_segment_ids],train_labels,\n                    validation_data=([test_input_ids, test_input_masks, test_segment_ids],test_labels),\n                    epochs=5,batch_size=32)","15c4d923":"import matplotlib.pyplot as plt\n\ndf_history = pd.DataFrame(history.history)\nfig,ax = plt.subplots()\nplt.plot(range(df_history.shape[0]),df_history['val_acc'],'bs--',label='validation')\nplt.plot(range(df_history.shape[0]),df_history['acc'],'r^--',label='training')\nplt.xlabel('epoch')\nplt.ylabel('accuracy')\nplt.title('BERT Email Classification Training')\nplt.legend(loc='best')\nplt.grid()\nplt.show()\n\nfig.savefig('BERTConvergence.eps', format='eps')\nfig.savefig('BERTConvergence.pdf', format='pdf')\nfig.savefig('BERTConvergence.png', format='png')\nfig.savefig('BERTConvergence.svg', format='svg')","e3d36a2c":"from IPython.display import HTML\ndef create_download_link(title = \"Download file\", filename = \"data.csv\"):  \n    html = '<a href={filename}>{title}<\/a>'\n    html = html.format(title=title,filename=filename)\n    return HTML(html)\n\ncreate_download_link(filename='BERTConvergence.svg')","657b3cf7":"# Build, Train and Evaluate BERT Model\nFirst define critical functions that define various components of the BERT model ","14b5fbc9":"# Preliminaries\nFirst install critical dependencies not already on the Kaggle docker image. **NOTE THAT THIS NOTEBOOK USES TENSORFLOW 1.14 IN ORDER TO BE COMPARED WITH ELMo, WHICH WAS NOT PORTED TO TENSORFLOW 2.X. To see equivalent Tensorflow 2.X BERT Code, see https:\/\/www.kaggle.com\/azunre\/tlfornlp-chapters2-3-spam-bert-tf2** ","5b0826cb":"# Read and Preprocess Enron dataset\nRead Enron dataset and get a sense for the data by printing sample messages to screen","a97efa63":"\nWrite requirements to file, anytime you run it, in case you have to go back and recover Kaggle dependencies. **MOST OF THESE REQUIREMENTS WOULD NOT BE NECESSARY FOR LOCAL INSTALLATION**\n\nRequirements are hosted for each notebook in the companion github repo, and can be pulled down and installed here if needed. Companion github repo is located at https:\/\/github.com\/azunre\/transfer-learning-for-nlp","56811192":"We now use the custom TF hub BERT embedding layer within a higher-level function to define the overall model. More specifically, we put a dense trainable layer of output dimension 256 on top of the BERT embedding.","ee6f0446":"# WARNING\n**Please make sure to \"COPY AND EDIT NOTEBOOK\" to use compatible library dependencies! DO NOT CREATE A NEW NOTEBOOK AND COPY+PASTE THE CODE - this will use latest Kaggle dependencies at the time you do that, and the code will need to be modified to make it work. Also make sure internet connectivity is enabled on your notebook**","4d3fb019":"# Putting It All Together To Assemble Dataset\n\nNow, putting all the preprocessing steps together we assemble our dataset...","03afcba6":"**Make figures downloadable to local system in interactive mode**","3784dbf9":"**Tokenization**","d19a2513":"The following (commented out) code is arguably the more \"pythonic\" way of achieving the extraction of bodies from messages. It is only 2 lines long and achieves the same result. However, we feel the code above is more transparent with regards to how the processing is carried out, and as such leave this here for the python experts if they prefer.","9859d43d":"**Visualize Convergence**","8adada4d":"Next, we define a custom tf hub BERT layer","ea13adfc":"# Read and Preprocess Fraudulent \"419\" Email Corpus","cda1362c":"# Define Tokenization, Stop-word and Punctuation Removal Functions\nBefore proceeding, we must decide how many samples to draw from each class. We must also decide the maximum number of tokens per email, and the maximum length of each token. This is done by setting the following overarching hyperparameters","e19649f6":"**Stop-word removal**\n\nLet\u2019s define a function to remove stopwords - words that occur so frequently in language that they offer no useful information for classification. This includes words such as \u201cthe\u201d and \u201care\u201d, and the popular library NLTK provides a heavily-used list that will employ.","642c608b":"Since 70% of 2000 is 1400, looks good! (for Nsamp=1000)\n\nOnwards!","7851523f":"**Use regular expressions to remove unnecessary characters**\n\nNext, we define a function to remove punctuation marks and other nonword characters (using regular expressions) from the emails with the help of the ubiquitous python regex library. In the same step, we truncate all tokens to hyperparameter maxtokenlen defined above."}}