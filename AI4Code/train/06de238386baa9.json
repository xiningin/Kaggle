{"cell_type":{"054d3452":"code","9ce81540":"code","5650572b":"code","8e785620":"code","da299976":"code","e7db5937":"code","8f061f1f":"code","ff785b61":"code","9d9bc59c":"code","6bae15fa":"code","c22a53bf":"code","9549b64d":"code","1ff0c6c7":"code","2aedf8ac":"code","062e3d1b":"code","94b0591b":"code","bfd9419e":"code","61b9a817":"code","38ae4f7a":"code","1c283b68":"code","28dc66ed":"code","ffae11c2":"code","01817c70":"code","b855e218":"code","ea928094":"code","501634be":"code","84aac49c":"code","4313daf8":"code","c9a02054":"code","320d7dc5":"code","7837fca2":"code","8769dedc":"code","41b31aa0":"markdown","c912f7da":"markdown","ca070be2":"markdown","129281ea":"markdown","543be357":"markdown","5f6df027":"markdown","747ec0b2":"markdown","d4aad70f":"markdown","58d6ccf4":"markdown"},"source":{"054d3452":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nmyStop = 0\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        myStop += 1\n        print(os.path.join(dirname, filename))\n        if myStop==20:\n            break\n        \n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","9ce81540":"from PIL import Image\nfrom tqdm import tqdm\nimport glob\nimport gc\nimport matplotlib.pyplot as plt\n%matplotlib inline","5650572b":"from sklearn.naive_bayes import GaussianNB\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom random import random\nfrom sklearn import metrics","8e785620":"train_df = pd.read_csv(\"\/kaggle\/input\/garage-detection-unofficial-ssl-challenge\/image_labels_train.csv\")\ntrain_df.head()","da299976":"Image.open(\"\/kaggle\/input\/garage-detection-unofficial-ssl-challenge\/GarageImages\/GarageImages\/image1607.jpg\")","e7db5937":"np.array(Image.open(\"\/kaggle\/input\/garage-detection-unofficial-ssl-challenge\/GarageImages\/GarageImages\/image1607.jpg\")).shape","8f061f1f":"np.array(Image.open(\"\/kaggle\/input\/garage-detection-unofficial-ssl-challenge\/GarageImages\/GarageImages\/image1607.jpg\").resize((224, 224)))[:,:,0].flatten().shape","ff785b61":"(224, )*2","9d9bc59c":"224*224","6bae15fa":"def preprocess_image(image_path, desired_size=224):\n    im = Image.open(image_path)\n    im = im.resize((desired_size, )*2, resample=Image.LANCZOS)\n    im = np.array(im)\n    if len(im.shape)==3:\n        im = im[:,:,0]\n    im = im.flatten()\n    return im","c22a53bf":"# get the number of training images from the target\\id dataset\nN = train_df.shape[0]\n# create an empty matrix for storing the images\nx_train = np.empty((N, 50176), dtype=np.uint8)\n\n# loop through the images from the images ids from the target\\id dataset\n# then grab the cooresponding image from disk, pre-process, and store in matrix in memory\nfor i, image_id in enumerate(tqdm(train_df['ID'])):\n    x_train[i, :] = preprocess_image(\n        f'\/kaggle\/input\/garage-detection-unofficial-ssl-challenge\/GarageImages\/GarageImages\/image{image_id}.jpg'\n    )","9549b64d":"holdout_df = pd.read_csv(\"\/kaggle\/input\/garage-detection-unofficial-ssl-challenge\/image_labels_holdout.csv\")\nholdout_df.head()","1ff0c6c7":"# get the number of training images from the target\\id dataset\nN = holdout_df.shape[0]\n# create an empty matrix for storing the images\nx_holdout = np.empty((N, 50176), dtype=np.uint8)\n\n# loop through the images from the images ids from the target\\id dataset\n# then grab the cooresponding image from disk, pre-process, and store in matrix in memory\nfor i, image_id in enumerate(tqdm(holdout_df['ID'])):\n    x_holdout[i, :] = preprocess_image(\n        f'\/kaggle\/input\/garage-detection-unofficial-ssl-challenge\/GarageImages\/GarageImages\/image{image_id}.jpg'\n    )","2aedf8ac":"unlabeledIDs = []\nlabeledIDs = holdout_df['ID'].tolist() + train_df['ID'].tolist()\nfor file in tqdm(glob.glob('\/kaggle\/input\/garage-detection-unofficial-ssl-challenge\/GarageImages\/GarageImages\/*.jpg')):\n    myStart = file.find('\/image')\n    myEnd = file.find('.jpg')\n    myID = file[myStart+6:myEnd]\n    if int(myID) not in labeledIDs:\n        unlabeledIDs.append(myID)","062e3d1b":"# get the number of training images from the target\\id dataset\nN = len(unlabeledIDs)\n# create an empty matrix for storing the images\nx_unlabeled = np.empty((N, 50176), dtype=np.uint8)\n\n# loop through the images from the images ids from the target\\id dataset\n# then grab the cooresponding image from disk, pre-process, and store in matrix in memory\nfor i, image_id in enumerate(tqdm(unlabeledIDs)):\n    x_unlabeled[i, :] = preprocess_image(\n        f'\/kaggle\/input\/garage-detection-unofficial-ssl-challenge\/GarageImages\/GarageImages\/image{image_id}.jpg'\n    )","94b0591b":"def get_auc(X,Y):\n    probabilityOf1 = model.predict_proba(X)[:,1]\n    fpr, tpr, thresholds = metrics.roc_curve(Y, probabilityOf1, pos_label=1)\n    return metrics.auc(fpr, tpr)","bfd9419e":"sslRounds = 4\nx_train_ssl = np.concatenate((x_train, x_unlabeled), axis=0)\nfor sslRound in tqdm(range(sslRounds)):\n    # define model\n    model = MultinomialNB()\n    # fit model\n    if sslRound==0:\n        # first round, fit on just labeled data\n        model.fit(x_train, train_df['GarageDoorEntranceIndicator'])\n    else:\n        # all other rounds, fit on all data\n        model.fit(x_train_ssl, y_train_ssl)\n    # score unlabeled data\n    predictions = model.predict_proba(x_unlabeled)[:,1]\n    # set random threshold\n    threshold = 0.5\n    # print(\"threshold selected: \", threshold)\n    # create pseudo lables based on threshold\n    pseudoLabels = np.where(predictions>threshold,1,0)\n    # add pseudo labels to next round of training \n    y_train_ssl = np.concatenate((train_df['GarageDoorEntranceIndicator'], pseudoLabels), axis=0)\n    # clean up\n    if sslRound<(sslRounds-1):\n        del model\n        gc.collect()","61b9a817":"import json\nimport math\n# import cv2\n# import PIL\n# from PIL import Image\n# import numpy as np\nimport tensorflow as tf\nfrom tensorflow.keras import layers\n# from keras.applications import DenseNet121\nfrom tensorflow.keras.callbacks import Callback, ModelCheckpoint\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.optimizers import Adam\nimport matplotlib.pyplot as plt\n# import pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import cohen_kappa_score, accuracy_score\nimport scipy\nfrom tqdm import tqdm\n%matplotlib inline","38ae4f7a":"!pip install \/kaggle\/input\/efficientnet-tfkeras-001\/efficientnet-master\/efficientnet-master","1c283b68":"import efficientnet.tfkeras as efn","28dc66ed":"BATCH_SIZE = 15\nTRAIN_VAL_RATIO = 0.10\nEPOCHS = 6\nLR = 0.00010409613402110064\nimSize = 224","ffae11c2":"def preprocess_image(image_path, desired_size=224):\n    im = Image.open(image_path)\n    im = im.resize((desired_size, desired_size))\n    im = np.array(im)\n    if len(im.shape)==3:\n        return im\n    else:\n        im2 = np.empty((desired_size, desired_size, 3), dtype=np.uint8)\n        for j in range(3):\n            im2[:,:,j] = im\n        return im2","01817c70":"NonHoldoutIDs = train_df['ID'].tolist() + unlabeledIDs\nlen(NonHoldoutIDs)","b855e218":"# get the number of training images from the target\\id dataset\nN = len(NonHoldoutIDs)\n# create an empty matrix for storing the images\nx_train = np.empty((N, imSize, imSize, 3), dtype=np.uint8)\n# loop through the images from the images ids from the target\\id dataset\n# then grab the cooresponding image from disk, pre-process, and store in matrix in memory\nfor i, image_id in enumerate(tqdm(NonHoldoutIDs)):\n    x_train[i, :, :, :] = preprocess_image(\n        f'\/kaggle\/input\/garage-detection-unofficial-ssl-challenge\/GarageImages\/GarageImages\/image{image_id}.jpg'\n    )","ea928094":"# do the same thing as the last cell but on the test\\holdout set\nN = holdout_df.shape[0]\nx_holdout = np.empty((N, imSize, imSize, 3), dtype=np.uint8)\nfor i, image_id in enumerate(tqdm(holdout_df['ID'])):\n    x_holdout[i, :, :, :] = preprocess_image(\n        f'\/kaggle\/input\/garage-detection-unofficial-ssl-challenge\/GarageImages\/GarageImages\/image{image_id}.jpg'\n    )","501634be":"x_train, x_val, y_train, y_val = train_test_split(\n    x_train, y_train_ssl,\n    test_size=TRAIN_VAL_RATIO, \n    random_state=2020\n)","84aac49c":"def create_datagen():\n    return ImageDataGenerator(\n        zoom_range=0.15,  # set range for random zoom\n        # set mode for filling points outside the input boundaries\n        fill_mode='constant',\n        cval=0.,  # value used for fill_mode = \"constant\"\n        horizontal_flip=True,  # randomly flip images\n        vertical_flip=True,  # randomly flip images\n    )\n\n# Using original generator\ndata_generator = create_datagen().flow(x_train, y_train, batch_size=BATCH_SIZE, seed=2019)","4313daf8":"effnet = efn.EfficientNetB3(weights=None,\n                            input_shape=(imSize, imSize, 3),\n                            include_top=False)\neffnet.load_weights(\"..\/input\/efficientnet-keras-weights-b0b5\/efficientnet-b3_imagenet_1000_notop.h5\")","c9a02054":"model = tf.keras.Sequential()\nmodel.add(effnet)\nmodel.add(layers.GlobalAveragePooling2D())\nmodel.add(layers.Dense(1, activation='sigmoid'))\n\nmodel.compile(\n    optimizer=Adam(lr=LR),\n    loss = 'binary_crossentropy',\n    metrics=[tf.keras.metrics.AUC()]\n)\nmodel.summary()","320d7dc5":"history = model.fit_generator(\n    data_generator,\n    steps_per_epoch=x_train.shape[0] \/\/ BATCH_SIZE,\n    epochs=EPOCHS,\n    validation_data=(x_val, y_val)\n)","7837fca2":"history_df = pd.DataFrame(history.history)\nhistory_df[['loss', 'val_loss']].plot()\nhistory_df[['auc', 'val_auc']].plot()","8769dedc":"holdoutPreds = model.predict_proba(x_holdout)\nfpr, tpr, thresholds = metrics.roc_curve(holdout_df['GarageDoorEntranceIndicator'], holdoutPreds, pos_label=1)\nprint(\"final holdout auc: \", metrics.auc(fpr, tpr))","41b31aa0":"# --- Self Training ---","c912f7da":"# Notes\n\n* In this notebook we're going to flatten the images and run a simple base Niave Bayes Regression model.  \n* We'll use a modified version of EM + Niave Bayes approach inspired by https:\/\/www.cs.cmu.edu\/~tom\/pubs\/NigamEtAl-bookChapter.pdf\n* Running EfficientNet on full data with pseudo labels","ca070be2":"# Resources\n\nhttps:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.metrics.auc.html\n\nhttps:\/\/stackoverflow.com\/questions\/36967920\/numpy-flatten-rgb-image-array\n\nhttps:\/\/scikit-learn.org\/stable\/modules\/naive_bayes.html\n\nhttps:\/\/stackoverflow.com\/questions\/3964681\/find-all-files-in-a-directory-with-extension-txt-in-python?rq=1\n\nhttps:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.model_selection.train_test_split.html","129281ea":"# --- Score Holdout ---","543be357":"# Training","5f6df027":"# Image Processing","747ec0b2":"# EDA","d4aad70f":"# Imports","58d6ccf4":"# --- EfficientNet ---"}}