{"cell_type":{"095800c1":"code","9553e646":"code","d77ea9f2":"code","29093459":"code","67da1d01":"code","bcb5e674":"code","9da147de":"code","eba86837":"markdown"},"source":{"095800c1":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","9553e646":"import re\nto_underscore = lambda x: re.sub(\"[^0-9a-zA-Z#]+\", \"_\", x.lower())","d77ea9f2":"typetable = pd.read_csv(\"..\/input\/pokemon-type-table\/typetable.csv\")\nvals = []\n\nfor c1 in typetable.columns[1:]:\n    # valores para cuando el pokemon defensor solo tiene un tipo\n    vals.append(pd.DataFrame({\n        \"idx\": typetable[\"atck\"].map(lambda x: \"%s-vs-%s-None\" % (x, c1)), #.rename(None)\n        \"mul\": typetable[c1],\n    }))\n    # valores para cuando el pokemon defensor tiene doble tipo\n    for c2 in typetable.columns[1:]:\n        vals.append(pd.DataFrame({\n            \"idx\": typetable[\"atck\"].map(lambda x: \"%s-vs-%s-%s\" % (x, c1, c2)), #.rename(None)\n            \"mul\": typetable[c1] * typetable[c2],\n        }))\n\n# pasamos el dataset a un diccionario para que sea mas rapido acceder\nmult = pd.concat(vals).reset_index().drop([\"index\"], axis=1)\nmult = dict(zip(mult.values[:,0], mult.values[:,1]))\ndef multiplier(cat):\n    # podemos tanto devolver nan, como devolver directamente 0 cuando no tenemos valor\n    return mult.get(cat, 0)\n    # return mult.get(cat, np.nan)","29093459":"print(multiplier(\"Water-vs-Fire-None\"))\nprint(multiplier(\"Water-vs-Fire-Grass\"))\nprint(multiplier(\"Fire-vs-Water-Fire\"))\nprint(multiplier(\"Fire-vs-Grass-Bug\"))\nprint(multiplier(\"None-vs-Grass-Bug\"))","67da1d01":"pokemon = pd.read_csv(\"..\/input\/pokemon-challenge-mlh\/pokemon.csv\").rename(to_underscore, axis='columns').fillna(\"None\")\npokemon[\"legendary\"] = pokemon[\"legendary\"].map(int)\npokemon = pokemon.drop([\"hp\", \"attack\", \"defense\", \"sp_atk\", \"sp_def\", \"speed\", \"generation\", \"legendary\"], axis=1)\npokemon.head()","bcb5e674":"battles = pd.read_csv(\"..\/input\/pokemon-challenge-mlh\/battles.csv\").rename(to_underscore, axis='columns')\nbattles.head()","9da147de":"def merge_data(battles):\n    # hacemos el merge\n    battles = battles \\\n        .merge(pokemon.rename(lambda x: \"f_%s\" % x, axis=\"columns\"), left_on=\"first_pokemon\", right_on=\"f_#\") \\\n        .merge(pokemon.rename(lambda x: \"s_%s\" % x, axis=\"columns\"), left_on=\"second_pokemon\", right_on=\"s_#\") \\\n\n    # aplicamos los multiplicadores\n    battles[\"f_t1\"] = (battles[\"f_type_1\"] + \"-vs-\" + battles[\"s_type_1\"] + \"-\" + battles[\"s_type_2\"]).map(multiplier)\n    battles[\"f_t2\"] = (battles[\"f_type_2\"] + \"-vs-\" + battles[\"s_type_1\"] + \"-\" + battles[\"s_type_2\"]).map(multiplier)\n    battles[\"s_t1\"] = (battles[\"s_type_1\"] + \"-vs-\" + battles[\"f_type_1\"] + \"-\" + battles[\"f_type_2\"]).map(multiplier)\n    battles[\"s_t2\"] = (battles[\"s_type_2\"] + \"-vs-\" + battles[\"f_type_1\"] + \"-\" + battles[\"f_type_2\"]).map(multiplier)\n    \n    # eliminamos los datos originales\n    battles = battles\\\n        .sort_values(['battle_number']) \\\n        .reset_index() \\\n        .drop([\"index\",\"battle_number\", \"first_pokemon\", \"second_pokemon\", \"f_#\", \"s_#\"], axis=1)\n    return battles\n\ntrain = merge_data(battles)\n\ntrain.head(50)","eba86837":"# Pokemon Multipliers\n\nEste Kernel esta destinado a calcular los multiplicadores de la **tabla de tipos** a las batallas pokemons."}}