{"cell_type":{"26c723ab":"code","76113313":"code","f3d990f1":"code","c46c061c":"code","768ea231":"code","6f6af009":"markdown","fc24d2e5":"markdown","8f91a48d":"markdown","6925fa3e":"markdown","8992fa97":"markdown"},"source":{"26c723ab":"from math import inf","76113313":"WINNING_STATES = [\n    0b111000000,\n    0b000111000,\n    0b000000111,\n    0b100100100,\n    0b010010010,\n    0b001001001,\n    0b100010001,\n    0b001010100,\n]","f3d990f1":"playerX = \"\\033[32mX\\033[39m\"\nplayerO = \"\\033[33mO\\033[39m\"","c46c061c":"class InvalidMoveException(Exception):\n    pass\n\n\nclass TicTacToe:\n\n    def __init__(self):\n        self.board = [\n            \"1\", \"2\", \"3\",\n            \"4\", \"5\", \"6\",\n            \"7\", \"8\", \"9\",\n        ]\n\n        self.players = [playerX, playerO]\n        self.no_of_moves_played = 0\n\n    def play(self, box: int):\n        next_player_index = self.no_of_moves_played % 2\n        self._act(self.players[next_player_index], box)\n        self.no_of_moves_played += 1\n\n        if self._terminal(self.board):\n            print(\"game terminated\")\n            exit()\n\n    def ai_turn(self):\n        next_player_index = self.no_of_moves_played % 2\n\n        player = self.players[next_player_index]\n\n        action = self._minimax([*self.board], player)\n        self._act(player, action[1])\n        self.no_of_moves_played += 1\n\n        if self._terminal(self.board):\n            print(\"game terminated\")\n            exit()\n\n    def _get_box(self, box: int) -> str:\n        return self.board[box - 1]\n\n    def _set_box(self, box: int, value: str):\n        self.board[box - 1] = value\n\n    def _act(self, player: str, box: int):\n        if self._get_box(box) in self.players:\n            raise InvalidMoveException(\"Invalid move\")\n        self._set_box(box, player)\n        print(f\"player {player} has acted in box {box}\")\n\n    def _get_available_moves(self, board: list) -> list:\n        return [int(box) for box in filter(lambda box: box not in self.players, board)]\n\n    def _terminal(self, board: list) -> bool:\n        if all([box in self.players for box in board]):\n            return True\n\n        if board.count(self.players[0]) < 3 and board.count(self.players[1]) < 3:\n            return False\n\n        return self._winning(playerX, board) or self._winning(playerO, board)\n\n    def _get_binary_state(self, player: str, board: list) -> int:\n        state = 0b0\n\n        for i in range(0, len(board)):\n            if board[i] == player:\n                state += 2 ** i\n        return state\n\n    def _minimax(self, board: list, player: str):\n        available_moves = self._get_available_moves(board)\n        if self._winning(playerX, board):\n            return 1, None\n        elif self._winning(playerO, board):\n            return -1, None\n        elif len(available_moves) == 0:\n            return 0, None\n\n        actions = []\n\n        for available_move in available_moves:\n            board_to_update = [*board]\n            board_to_update[available_move - 1] = player\n\n            if player == playerX:\n                action = self._minimax(board_to_update, playerO)\n            else:\n                action = self._minimax(board_to_update, playerX)\n\n            actions.append((action[0], available_move))\n\n        if player == playerX:\n            best_score = -inf\n            best_move = None\n\n            for (score, available_move) in actions:\n                if score > best_score:\n                    best_score, best_move = score, available_move\n            return best_score, best_move\n        else:\n            best_score = inf\n            best_move = None\n\n            for (score, available_move) in actions:\n                if score < best_score:\n                    best_score, best_move = score, available_move\n            return best_score, best_move\n\n    def _winning(self, player: str, board: list):\n        player_state = self._get_binary_state(player, board)\n\n        for winning_state in WINNING_STATES:\n            if player_state & winning_state == winning_state:\n                return True\n        return False\n\n    def __str__(self):\n        return (f\"{self._get_box(1)} | {self._get_box(2)} | {self._get_box(3)}\\n\"\n                f\"---------\\n\"\n                f\"{self._get_box(4)} | {self._get_box(5)} | {self._get_box(6)}\\n\"\n                f\"---------\\n\"\n                f\"{self._get_box(7)} | {self._get_box(8)} | {self._get_box(9)}\")","768ea231":"if __name__ == '__main__':\n    game = TicTacToe()\n\n    i = 0\n    while i < 9:\n        try:\n            if game.players[i % 2] == playerO:\n                game.ai_turn()\n            else:\n                box_number = int(input(f\"Player {game.players[i % 2]} turn to play: \"))\n                game.play(box_number)\n            i += 1\n        except InvalidMoveException as e:\n            print(e.args[0])\n        finally:\n            print(game)","6f6af009":"Then, we initialize a bunch of winning states. These states let us know the board configuration that contains a winning state","fc24d2e5":"First, we import required components","8f91a48d":"### The unbeatable tic-tac-toe game\nThe following piece of code uses adversarial search to create an artificially intelligent opponent that always tries to win or draw a tic tac toe game.","6925fa3e":"Now we create the `TicTacToe` class to hold the logic of the game","8992fa97":"Next, let's create our players, I am color-coding them for ease of recognition in the program output"}}