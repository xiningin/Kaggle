{"cell_type":{"42d7e0b7":"code","3dcea7ed":"code","6008ad3a":"code","68dbdd5f":"code","931a715c":"code","ab3c0b99":"code","0c9e5f94":"code","8ba3896f":"code","9ac3eda6":"code","8fdb8598":"code","09858044":"code","7e949d01":"code","0671be45":"code","e8aebbaf":"code","9bcac621":"code","885afbd1":"code","2740bc08":"code","79f998fc":"markdown","2e7f8592":"markdown","b876dcab":"markdown","d3a289a2":"markdown","2c60b2d5":"markdown","38be4176":"markdown","ada6f15d":"markdown","f5745bec":"markdown","04a37dd8":"markdown","b4a30bb6":"markdown","3d68366b":"markdown","5ea79ea8":"markdown","c8d48035":"markdown","9f88da7a":"markdown","05198903":"markdown","bb3ec4fd":"markdown","23cc9af2":"markdown","77404c43":"markdown","a2ddee76":"markdown","3f4dbebe":"markdown","2c71a4a1":"markdown","21cb64e1":"markdown"},"source":{"42d7e0b7":"# For example matching a time format\n\nimport re\n\nline = \"Jan  3 07:57:39 Kali sshd[1397]: Failed password 02:12:36 for root from 172.16.12.55 port 34380 ssh2\"\nregex = \"\\d+\"\nresult = re.findall(regex, line) # returns all of the digit matches as a list\nfirst_result = re.findall(regex, line)[0] # returns first match\nprint(result)\nprint(first_result)","3dcea7ed":"word = \"I just realized how interesting coding is\"\nregex = \"\\w+\"\nresult = re.findall(regex, word) # returns each word as a list\nprint(result)","6008ad3a":"word = \"The colors of the rainbow has many colours and the rainbow does not have a single colour\"\nregex = \"colou?rs?\" # ? before a string signifies that the string is optional\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","68dbdd5f":"word = \"I just realized how interesting coding is\"\nregex = \"\\w{3}\"\nresult = re.findall(regex, word) # returns the first three character of each word as a list\nprint(result)","931a715c":"word = \"[Google](http:\/\/google.com), [test] \\n [itp](http:itp.nyu.edu)\"\nregex = \"\\[.*\\]\" # ? before a string signifies that the string is optional\nresult = re.findall(regex, word) # return s all of the matches as a list\nprint(result)","ab3c0b99":"word = \"[Google](http:\/\/google.com), [test] \\n [itp](http:itp.nyu.edu)\"\nregex = \"\\[.*?\\]\" # ? before a string signifies that the string is optional\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","0c9e5f94":"word = \"The colors of the rainbow has many colours and the rainbow does not have a single colour\"\n# regex = \"\\w+$\" # means 1 or more word characters at the end of a line.\n# regex = \"^\\w+$\" # means 1 or more word characters at the beginning and end of a line (equally just a line with just one word).\nregex = \"^\\w+\" # means the beginning of a line followed by 1 or more word characters\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","8ba3896f":"word = \"The colors of the rainbow has many colours and the rainbow does not have a single colour\"\nregex = \"\\\\b\\w{3}\\\\b\" # this matches 3 word characters specifically\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","9ac3eda6":"word = \"The colors of the rainbow has many colours and the rainbow does not have a single colour\"\nregex = \"\\\\b\\w{5,9}\\\\b\" # this matches 5 to 9 word characters specifically\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","8fdb8598":"# shallow copy copies by referencing the original value, while deep copy copies with no reference\nimport copy \nx = [1,[2]] \ny = copy.copy(x) \nz = copy.deepcopy(x) \ny is z ","09858044":"word = \"lynk is not the correct spelling of link\"\nregex = \"l[yi]nk\" # this matches either link or lynk\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","7e949d01":"word = \"I am in my 400L, I am currently XX years of age in the year 2018\"\nregex = \"[0-3]{2}\" # this matches characters from 0 to 3 and is max of two characters long\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","0671be45":"word = \"I am in my 400L, I am currently XX years of age in the year 2018\"\nregex = \"[^0-3]{2}\" # this matches characters from 0 to 3 and is max of two characters long\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","e8aebbaf":"word = \"I am in my 400L, I am currently XX years of age in the year 2018. My email addresses are stanleydukor@gmail.com, stanleydukor@yahoo.com, stanleydukor@hotmail.edu\"\nregex = \"\\w+@\\w+\\.(?:com|net|org|live|edu)\" # this matches email addresses\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","9bcac621":"word = \"These are some phone numbers 917-555-1234. Also, you can call me at 646.555.1234 and of course I'm always reachable at (212)867-5509\"\nregex = \"\\(?\\d{3}[-.)]\\d{3}[-.]\\d{4}\" # this matches phone numbers\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","885afbd1":"word = \"[Google](http:\/\/google.com), [test] \\n [itp](http:itp.nyu.edu)\"\nregex = \"\\[.*?\\]\\(http.*?\\)\" # ? matches the name of a link and the link itself\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","2740bc08":"word = \"2017-07-05 16:04:18.000000\"\nregex = \"\\d{4}-\\d{2}-\\d{2}\\s+\\d{2}:\\d{2}:\\d{2}\"\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","79f998fc":"- To replace with the name of the link and the link itself in an html format, we first group them (i.e. \"\\[(.*?)\\]\\((http.*?)\\)\" ","2e7f8592":"- They are meta characters that modify the previous character in a regular expression. (e.g. how many of those things you want to match in a row)\n- '*' matches 0 or more \n- '+' matches 1 or more \n- '?' matches 0 or 1 (optional)\n- {n} matches all n\n- {min, max}\n\nFor example, '\\w\\w\\w' means match all first 3 words. Also, '\\w{3}' does the same thing","b876dcab":"### Alternation","d3a289a2":"## Capturing Groups","2c60b2d5":"- Note that '?' paired with a quantifier makes '.*' not greedy","38be4176":"### Quantifiers","ada6f15d":"## Introduction","f5745bec":"- In the example below, we get to see that '.*' is greedy by default. It will continue to match until it can no more match ","04a37dd8":"- Suppose we have a stringm '212-555-1234', and we want to match it, we use:\n    \"\\d{3}-(\\d{3})-(\\d{4})\"\n- Note that the whole string is automatically grouped by regex as \"GROUP 0\". \n- Also, using a bracket in this context signifies that the content of the bracket is \"Group 1\" and \"Group 2\" respectively.\n- Accessing each group is with the use of a '$' or '\\'. e.g. $1 or \\1 signifies 'GROUP 1'","b4a30bb6":"### Position","3d68366b":"- A sequence of characters that defines a search pattern.\n- '\\d' means any character between 0 and 9 where d is digit (Meta character)\n- Literal characters are characters that are specified and will always occur.\n- Meta characters are characters that are more generalized not specific.\n- E.g. to match a number in the format \"917-55-1234\", the regular expression will be \"\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d\"","5ea79ea8":"## Meta characters","c8d48035":"- '.' means any character, and '*' means 0 or more \n- For example, if we write a regular expression \"rainbow.*\", it means all data that begins with rainbow, could be rainbow123, rainbow boy, rainbow city etc.\n- '.*' is a wildcard that matches the universe","9f88da7a":"# Regular Expressions ","05198903":" ### Single Characters","bb3ec4fd":"- Character classes are stuffs that appear in between square brackets.\n- Each string inside the square brackets are alternatives to each other\n- Also, characters in the square brackets do not possess there meta characteristics, instead they are just literal characters.","23cc9af2":"## Character classes","77404c43":"- '^' inside a square brackets can be used when we want to get anything that is not amongst the remaining characters after it.\n- Note that if '^' is not located at the beginning, after the first pair of square brackets, then it isn't a special\/meta character again, but a literal one.","a2ddee76":"- '\\d' matches any character between 0 and 9 where d means digit\n- '\\w' matches any character A-Za-z0-9 where w means word\n- '\\s' matches any whitespace (can match a space, a tab etc.)\n- '.' matches any character whatsoever\n- Capitalizing 'd' or 'w' or 's' makes the expression the opposite\n","3f4dbebe":"- They are meta characters that matches the position of a character in the string itself. \n- '^' means beginning\n- '$' means end\n- '\\b' word boundary (it is advisable to use escape before it (i.e. \"\\\\b\") otherwise \\b means a backspace characters","2c71a4a1":"- We know that in Character classes, each string inside the square brackets are alternatives to each other, which is a limitation.\n- With alternation, multiple strings can be alternatives to each other.\n- For example, in '(com|net)', we mean 'com' or 'net'.","21cb64e1":"- The only two special characters inside the square brackets are the '-' and '^'\n- '-' inside a square brackets can be used when we want to get a range of strings, e.g. 'a-z1-9' matches any character from a to z and from 1 to 9"}}