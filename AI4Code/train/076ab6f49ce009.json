{"cell_type":{"08d4e83f":"code","9925a243":"code","7faf83d1":"code","83a6f6bd":"code","34ae8279":"code","c113d6b7":"code","83160256":"code","863a0152":"code","87c6a6c4":"code","a251992a":"code","ac68e6ac":"code","bb8e3ec8":"code","aaddb486":"code","777040b0":"code","e6b83c59":"code","a2779eb6":"code","c35af48e":"code","6b8f7ce5":"code","332f26bc":"code","e1c39281":"code","4cb755e3":"code","4a147b09":"code","1be6633b":"code","ee66a980":"code","529d91c4":"code","a2a8eea5":"code","108d27fd":"code","c6a5c90f":"code","45a43432":"code","331eca45":"code","f49bdc2b":"code","1f577820":"code","f04c49ba":"code","e3105354":"code","3661a506":"code","2cc3f036":"code","7f18b533":"code","581b275c":"code","8d468784":"code","5a1f1683":"code","3a8e7193":"code","9af49162":"code","7acf3d68":"code","7435225c":"code","eccca81a":"code","183807fe":"code","63b8e33b":"code","78ab8351":"code","f2533aea":"code","973f6368":"code","dbc8b013":"code","3570bd6a":"code","a2d61f89":"code","ad677a9d":"code","ac645cef":"code","32047bf9":"code","286cf5e5":"code","6cb0df2b":"code","10b8eb4b":"code","4fbe3d43":"code","ecbb79c9":"code","134fcb8b":"code","a7f87cb4":"code","701a4451":"code","97f10d62":"code","ab8287bd":"code","9011575f":"code","445b3068":"code","390cda43":"code","616ae513":"code","4e55c3e8":"code","d5407366":"code","83817148":"markdown","31760dc1":"markdown","3468bc76":"markdown","aea30ded":"markdown","151a838c":"markdown","144a897f":"markdown","9880e116":"markdown","17c831e3":"markdown","d219cf4b":"markdown","9b80c185":"markdown","aac008d1":"markdown","f20258d3":"markdown","23f69088":"markdown","90a58576":"markdown","9ab66dee":"markdown","318a05a3":"markdown","2cb8ad1f":"markdown","bbaba2b8":"markdown","a27f1764":"markdown","60b2c4a5":"markdown","27c4fd27":"markdown","9fe494a4":"markdown","f28eabba":"markdown","e7ded9a1":"markdown","ef855a22":"markdown","d6d8ced4":"markdown","066593c1":"markdown","f9242757":"markdown","d809e51b":"markdown","ada6a14b":"markdown","631dfeae":"markdown","23994659":"markdown"},"source":{"08d4e83f":"# Data Manupilation\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Visualization\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Basket Analysis\nfrom mlxtend.frequent_patterns import apriori, association_rules\n\n# Deep Learning\nimport tensorflow as tf\nimport torch\nimport torch.nn as nn \nfrom torch.utils.data import DataLoader\nimport torch.nn.functional as F\nfrom sklearn import metrics\nfrom transformers import BertTokenizer, BertConfig, BertForSequenceClassification\ntokenizer = BertTokenizer.from_pretrained('bert-base-uncased', do_lower_case = True)\nfrom tqdm import tqdm\n\n# Text\nimport re\nimport nltk\nfrom nltk.corpus import stopwords\nnltk.download('stopwords')\nstopw = stopwords.words('english')","9925a243":"df = pd.read_csv('..\/input\/topic-modeling-for-research-articles-20\/Train.csv')\ndf_test = pd.read_csv('..\/input\/topic-modeling-for-research-articles-20\/Test.csv')\ndf.head()","7faf83d1":"df['no_topics'] = df.iloc[:,2:].sum(axis = 1)\ndf.sort_values(by = 'no_topics', ascending = False).head()","83a6f6bd":"df['no_topics'].value_counts()","34ae8279":"df.loc[12706,'ABSTRACT' ]","c113d6b7":"df.loc[df['id'] == 11080].T","83160256":"frequency_result = apriori(df.iloc[:,2:31], min_support = 0.01, use_colnames=True).sort_values('support', ascending = False).reset_index(drop= True)\nassociation = association_rules(frequency_result, metric = 'lift', min_threshold =1 )","863a0152":"#print(association.sort_values(by = ['confidence','support'], ascending = False).to_string())","87c6a6c4":"association.sort_values(by = ['confidence','support'], ascending = False).head()","a251992a":"df.columns","ac68e6ac":"df_test.head()","bb8e3ec8":"df['category'] = df.iloc[:,2:31].apply((lambda x: 'Machine Learning and AI' if (x['Statistics'] == 1 or x['Statistics Theory']==1 or x['Machine Learning']==1 or x['Artificial Intelligence'] == 1 or x['Computer Vision and Pattern Recognition'] ==1) \n                                        else 'Physics' if (x['Physics'] ==1 or x['Superconductivity'] == 1 or x['Strongly Correlated Electrons'] == 1 or  x['Astrophysics of Galaxies'] == 1 or x['Cosmology and Nongalactic Astrophysics'] ==1 or x['Earth and Planetary Astrophysics'] ==1 or x['Fluid Dynamics'] ==1 or x['Instrumentation and Methods for Astrophysics'] ==1 or x['Materials Science'] ==1) \n                                        else 'Mathematics' if(x['Mathematics'] ==1 or x['Number Theory'] == 1 or x['Analysis of PDEs'] == 1 or x['Differential Geometry'] ==1 or x['Optimization and Control'] == 1 or x['Representation Theory'] ==1) else 'other') , axis = 1)\n\ndf_test['category'] = df_test.iloc[:,2:31].apply((lambda x: 'Machine Learning and AI' if x['Statistics'] == 1 or x['Computer Science']==1 else 'Physics' if x['Physics'] else 'Mathematics' if x['Mathematics'] else 'other'), axis = 1)","aaddb486":"df.head()","777040b0":"df['category'].value_counts()","e6b83c59":"df_train = df[['ABSTRACT', 'category']]\ndf_train = df_train[df_train['category'] != 'other' ]\ndf_train =df_train.rename(columns = {'ABSTRACT' : 'text'})\n\ndf_test = df_test[['ABSTRACT', 'category']]\ndf_test = df_test[df_test['category'] != 'other' ]\ndf_test =df_test.rename(columns = {'ABSTRACT' : 'text'})","a2779eb6":"df_train.head()","c35af48e":"df_train['len_text'] = df_train['text'].apply(lambda x: len(x.split()) )\ndf_test['len_text'] = df_test['text'].apply(lambda x: len(x.split()) )","6b8f7ce5":"df_train.head()","332f26bc":"len(df_train)","e1c39281":"sns.set(font_scale=1.2)\nsns.set_style(\"white\")\nfig, ax = plt.subplots(2,sharex = True, figsize = (8,8), gridspec_kw={\"height_ratios\": (.2, .85)})\nsns.boxplot(df_train['len_text'], ax = ax[0])\nsns.distplot(df_train['len_text'], ax = ax[1], kde =False)\nax[0].set(xlabel = '', yticks = [])\nax[0].set_title('The Distibution of Length of Texts', fontsize = 20)\nax[1].set_xlabel('Length of Text', fontsize = 14)\nax[1].set_ylabel('Count', fontsize = 14)\nsns.despine(ax = ax[0])\nsns.despine(ax=ax[0], left=True)\nplt.subplots_adjust(hspace = .05)\nplt.show()","4cb755e3":"from sklearn.preprocessing import LabelEncoder","4a147b09":"enc = LabelEncoder()\ndf_train['label'] = enc.fit_transform(df_train['category'])\ndf_test['label'] = enc.fit_transform(df_test['category'])","1be6633b":"df_train['category'].value_counts()","ee66a980":"df_train.head()","529d91c4":"fig ,ax = plt.subplots(figsize = (8,8))\nfor col in df_train['category'].unique():\n    ax = sns.distplot(df_train.loc[(df_train['category'] == col) & (df_train['len_text'] < 350), 'len_text'], kde = False)\n    \nax.legend(df_train['category'].unique())\nax.set_title('The Distribution of Length of Texts by Category', fontsize = 18)\nax.set_xlabel('Length of Texts')\nsns.despine(left = True)\nax.set_ylabel('Count')\nplt.show()","a2a8eea5":"category_encoding = df_train.groupby(['category'])['label'].min().rename('label').reset_index()\ncategory_encoding","108d27fd":"def clean_text(text):\n    text = re.sub(r'[^a-zA-Z\\']',' ',text)\n    text = text.split()\n    text = [word for word in text if word not in stopw]\n    text = ' '.join(text)\n    text = re.sub(r'  ', ' ', text)\n    text = re.sub(r'   ', ' ', text)\n    return text","c6a5c90f":"print(\"---- Text ----\\n\")\nprint(df_train.loc[0, 'text'])\nprint(\"\\n---- Cleaned Text ----\\n\")\nprint(clean_text(df_train.loc[0, 'text']))","45a43432":"df_train['cleaned_text'] = df_train['text'].apply(lambda x: clean_text(x))\ndf_test['cleaned_text'] = df_test['text'].apply(lambda x: clean_text(x))","331eca45":"def n_gram(df, category = '', n_gram = 1, text_column= 'cleaned_text'):\n    n_gram_result = {}\n    \n    if category != '':\n        df = df[df['category'] == category]\n    \n    for text in tqdm(df[text_column]):\n        for i in range(len(text)):\n            words = text.split()[i:i+n_gram]\n            words = ' '.join(words)\n\n            if (len(words.split()) % n_gram) > 0 or words == '':\n                continue\n\n            elif words in n_gram_result.keys():\n                n_gram_result[words] += 1\n            else:\n                n_gram_result[words] = 1\n                \n                \n    n_gram_result = pd.DataFrame([n_gram_result]).T.reset_index()\n    n_gram_result.columns = [category + '_n_grams_'+ str(n_gram), category+ '_counts_' + str(n_gram)]\n\n\n    return n_gram_result","f49bdc2b":"temp_result = {}\nfor category in df_train['category'].unique():\n    for i in range(1,4):\n        result = n_gram(df_train, category = category, n_gram = i, text_column = 'cleaned_text').sort_values(by = category + \"_counts_\"+ str(i), ascending = False).head(30).reset_index(drop =True)\n        temp_result[category + \"_\", str(i)] = result\n\n\nn_gram_result = pd.DataFrame({})\nfor i in temp_result.keys():\n    n_gram_result = pd.concat([n_gram_result , temp_result[i]], axis = 1)","1f577820":"n_gram_result.iloc[:,0:6]","f04c49ba":"n_gram_result.iloc[:,6:12]","e3105354":"n_gram_result.iloc[:,12:18]","3661a506":"from tensorflow.keras.preprocessing.text import Tokenizer\nfrom tensorflow.keras.preprocessing.sequence import pad_sequences\nfrom tensorflow.keras.utils import to_categorical","2cc3f036":"glove_embeddings = np.load('..\/input\/pickled-glove840b300d-for-10sec-loading\/glove.840B.300d.pkl', allow_pickle=True)","7f18b533":"print(\"There are {} words and every word has {} dimensions in Glove Dictionary. I used the word 'sister' as an example.\".format(len(glove_embeddings.keys()),len(glove_embeddings['sister']),))","581b275c":"covered_words_by_category = {'Physics' : {},'Machine Learning and AI':{},'Mathematics' : {} }\nuncovered_words_by_category = {'Physics' : {},'Machine Learning and AI':{},'Mathematics' : {} }\nfor category in df_train['category'].unique():\n    for text in tqdm(df_train.loc[df['category'] == category, 'cleaned_text']):\n        text = text.split()\n        for word in text:\n            if word in glove_embeddings.keys():\n                if word not in covered_words_by_category[category].keys():\n                    covered_words_by_category[category][word] = 1\n                else:\n                    covered_words_by_category[category][word] += 1\n\n            else:\n                if word not in uncovered_words_by_category[category].keys():\n                    uncovered_words_by_category[category][word] = 1\n                else:\n                    uncovered_words_by_category[category][word] += 1\n                    \n                    \ncovered_words ={}\nuncovered_words = {}\nfor text in tqdm(df_train['cleaned_text']):\n    text = text.split()\n    for word in text:\n        if word in glove_embeddings.keys():\n            if word not in covered_words.keys():\n                covered_words[word] = 1\n            else:\n                covered_words[word] += 1\n\n        else:\n            if word not in uncovered_words.keys():\n                uncovered_words[word] = 1\n            else:\n                uncovered_words[word] += 1","8d468784":"print(\"---There are {} words in the whole dataset, and {:.2f}% of the words aren't covered by Glove---\".format((len(uncovered_words) + len(covered_words)),len(uncovered_words) \/ (len(uncovered_words)+len(covered_words))*100))\nprint(\"---There are {} words in the Physics category, and {:.2f}% of the words aren't covered by Glove---\".format((len(uncovered_words_by_category['Physics']) + len(covered_words_by_category['Physics'])),len(uncovered_words_by_category['Physics']) \/ (len(uncovered_words_by_category['Physics'])+len(covered_words_by_category['Physics']))*100))\nprint(\"---There are {} words in the Machine Learning and AI category, and {:.2f}% of the words aren't covered by Glove---\".format((len(uncovered_words_by_category['Machine Learning and AI']) + len(covered_words_by_category['Machine Learning and AI'])),len(uncovered_words_by_category['Machine Learning and AI']) \/ (len(uncovered_words_by_category['Machine Learning and AI'])+len(covered_words_by_category['Machine Learning and AI']))*100))\nprint(\"---There are {} words in the Mathematics category, and {:.2f}% of the words aren't covered by Glove---\".format((len(uncovered_words_by_category['Mathematics']) + len(covered_words_by_category['Mathematics'])),len(uncovered_words_by_category['Mathematics']) \/ (len(uncovered_words_by_category['Mathematics'])+len(covered_words_by_category['Mathematics']))*100))","5a1f1683":"covered_words_by_category = pd.DataFrame(covered_words_by_category).reset_index().rename(columns = {'index' :'words'})\nuncovered_words_by_category = pd.DataFrame(uncovered_words_by_category).reset_index().rename(columns = {'index' :'words'})","3a8e7193":"uncovered_words_by_category[['words', 'Physics']].sort_values(by = 'Physics', ascending = False).head(20)","9af49162":"uncovered_words_by_category[['words', 'Machine Learning and AI']].sort_values(by = 'Machine Learning and AI', ascending = False).head(20)","7acf3d68":"uncovered_words_by_category[['words', 'Mathematics']].sort_values(by = 'Mathematics', ascending = False).head(20)","7435225c":"tokenizer_keras = Tokenizer(num_words = 36073, oov_token = '<OOV>' )\ntokenizer_keras.fit_on_texts(df_train['text'])\nword_index = tokenizer_keras.word_index\nvocab_size_keras = len(word_index)\nembedding_dim = 300\nword_embeddings = np.zeros((vocab_size_keras , embedding_dim))\n\nfor word, i in word_index.items():\n    if word in glove_embeddings.keys():\n        word_embeddings[i-1] = glove_embeddings[word]","eccca81a":"word_tokens = pd.DataFrame([word_index]).T.reset_index().rename(columns = {'index': 'words', 0: 'tokens'})\nkeras_word_embeddings = pd.DataFrame(word_embeddings).reset_index().rename(columns = {'index':'tokens'})\nkeras_word_embeddings['tokens'] = keras_word_embeddings['tokens'] + 1","183807fe":"word_tokens.merge(keras_word_embeddings , how = 'left' , on = 'tokens')","63b8e33b":"def prepare_data(df, tokenizer, text_column = 'cleaned_text',label_column = 'labels', max_len = 256):\n    '''\n    This function converts the text data into tokens. max_len is the number of words that we want to use in each text. \n    So, if the text includes more than 256 words, the post words of the text is going to be deleted.(trun)\n    If the text includes less than 256 words, 0 will be added into vector. (padding)\n    '''\n    sequences = tokenizer.texts_to_sequences(df[text_column])\n    padded = pad_sequences(sequences, maxlen = max_len, padding = 'post', truncating = 'post')\n    labels = tf.keras.utils.to_categorical(df[label_column])\n    return padded, labels","78ab8351":"df_train.head()","f2533aea":"df_train.head()","973f6368":"max_len = 128\npadded, labels = prepare_data(df_train, tokenizer_keras, text_column = 'cleaned_text', label_column = 'label', max_len= max_len)","dbc8b013":"training_portion =0.75\ntraining_size = int(len(df_train) * training_portion)\npadded_training = padded[:training_size]\nlabels_training = labels[:training_size]\npadded_val = padded[training_size:]\nlabels_val = labels[training_size:]","3570bd6a":"len(word_embeddings)","a2d61f89":"padded_training[6]","ad677a9d":"model_glove = tf.keras.Sequential()\nmodel_glove.add(tf.keras.layers.Embedding(vocab_size_keras , embedding_dim,input_length = max_len, weights = [word_embeddings], trainable = False))\nmodel_glove.add(tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(128, return_sequences = True)))\nmodel_glove.add(tf.keras.layers.Dropout(0.5))\nmodel_glove.add(tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(64)))\nmodel_glove.add(tf.keras.layers.Dropout(0.5))\nmodel_glove.add(tf.keras.layers.Dense(32, activation = 'relu'))\nmodel_glove.add(tf.keras.layers.Dropout(0.5))\nmodel_glove.add(tf.keras.layers.Dense(3, activation = 'softmax'))\n\nmodel_glove.compile(optimizer = 'Adam', loss= 'categorical_crossentropy', metrics = ['accuracy'])\nmodel_glove.summary()","ac645cef":"model_glove.fit(padded_training, labels_training, epochs = 10, verbose = 1, validation_data = (padded_val, labels_val))","32047bf9":"test_data, test_label = prepare_data(df_test, tokenizer_keras, text_column = 'cleaned_text', label_column = 'label', max_len = 128)\noutput_label = np.argmax(test_label, axis =1 ).flatten()\npredicted_label = np.argmax(model_glove.predict(test_data), axis = 1).flatten()\ntest_accuracy = np.sum(output_label == predicted_label) \/ len(output_label)\nprint(\"The test set includes {} texts and the accuracy is {:.2f}\".format(len(output_label), test_accuracy * 100))","286cf5e5":"tf.keras.backend.clear_session()\nimport tensorflow_hub as hub\nfrom sklearn.model_selection import StratifiedKFold","6cb0df2b":"def processing_data( row, row_label,category_encoding = category_encoding ,max_len = max_len):\n    \n    '''\n    Bert needs 3 different token vectors, so we need to convert data.\n    '''\n    label = category_encoding[category_encoding['category'] == row_label]['label'].values[0]\n    temp_input_ids = tokenizer.encode(row, max_length = max_len)\n    pad_len = max_len - len(temp_input_ids)  \n    input_ids =temp_input_ids + [0] * pad_len\n    attention_masks= [1] * len(temp_input_ids)+ [0] * pad_len\n    token_type_ids =  [0] * max_len\n    return np.array(input_ids), np.array(attention_masks), np.array(token_type_ids), np.array(label)\n\n\ndef encode(df, max_len = max_len, text_column = 'cleaned_text', category_encoding = category_encoding):\n    '''\n    This function is created to convert 3 special vectors into numpy array.\n    '''\n    ids, masks, token_ids, labels  = map(list, zip(*df[[text_column, 'category']].apply(lambda x: processing_data(x[text_column], x.category, category_encoding, max_len = max_len) , axis = 1)))\n    ids = np.array(ids, dtype = 'float32')\n    masks = np.array(masks, dtype = 'float32')\n    token_ids = np.array(token_ids, dtype = 'float32')\n    labels = tf.keras.utils.to_categorical(labels)\n    return ids, masks, token_ids, labels","10b8eb4b":"category_encoding","4fbe3d43":"def build_model(max_len = max_len, no_category = 3):\n    ids = tf.keras.Input(shape = (max_len, ), dtype = tf.int32)\n    masks = tf.keras.Input(shape = (max_len, ), dtype = tf.int32)\n    token_ids = tf.keras.Input(shape = (max_len), dtype = tf.int32)\n    \n    bert_layer = hub.KerasLayer(\"https:\/\/tfhub.dev\/tensorflow\/bert_en_uncased_L-12_H-768_A-12\/1\",  trainable=True)\n    \n    pooled_output , sequence_output = bert_layer([ids, masks, token_ids])\n    \n    output = sequence_output[:,0,:]\n\n    out = tf.keras.layers.Dense(no_category, activation = 'softmax')(output)\n    \n    model = tf.keras.models.Model(inputs = [ids, masks, token_ids], outputs = out)\n    \n    model.compile(loss = 'categorical_crossentropy', optimizer= tf.optimizers.Adam(learning_rate = 3e-5), metrics = ['accuracy'])\n                  \n    return model","ecbb79c9":"tf.keras.backend.clear_session()\nskf = StratifiedKFold(n_splits = 4, shuffle = True)\nids, masks, token_ids, labels = encode(df_train, max_len = max_len)\n\nfor i , (train_index, val_index) in enumerate(skf.split(ids, labels.argmax(1))):\n    ids_train = ids[train_index,:]\n    masks_train = masks[train_index,:]\n    token_ids_train = token_ids[train_index, :]\n    labels_train = labels[train_index, :]\n    ids_val = ids[val_index,:]\n    masks_val = masks[val_index, :] \n    token_ids_val = token_ids[val_index, :]\n    labels_val = labels[val_index, :]\n    print(\"Fold :{}\".format(i+1))\n    model = build_model(max_len = max_len)\n    \n    model.fit((ids_train, masks_train, token_ids_train), labels_train, verbose = 1, epochs = 4, batch_size = 32, validation_data = ((ids_val, masks_val, token_ids_val), labels_val))","134fcb8b":"def flat_accuracy(output, prediction):\n    prediction_flat = np.argmax(prediction, axis=1).flatten()\n    output_flat = np.argmax(output, axis=1).flatten()\n    return np.sum(prediction_flat == output_flat) \/ len(output_flat)","a7f87cb4":"ids_test, masks_test, token_ids_test, labels_test = encode(df_test, max_len = 128)\nprediction = model.predict((ids_test, masks_test, token_ids_test))\noutput = tf.keras.utils.to_categorical(df_test['label'])\ntest_result = flat_accuracy(output, prediction)\nprint(\"The test set includes {} texts and the accuracy is {:.2f}\".format(len(output), test_result * 100))","701a4451":"df_bbc = pd.read_csv('..\/input\/bbc-fulltext-and-category\/bbc-text.csv')\ndf_bbc.head()","97f10d62":"df_research = df_train.groupby('category').sample(n = 600, random_state = 1)\n#df_research = df_train.groupby('category').apply(lambda x: x.sample(500)).reset_index(drop=True)","ab8287bd":"df_merge = pd.concat([df_research[['text', 'category']], df_bbc]).reset_index(drop = True)\ndf_merge['category'].value_counts()","9011575f":"from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(df_merge['text'], df_merge['category'], test_size = 0.05, random_state = 42)","445b3068":"df_merge = pd.concat([X_train, y_train], axis = 1)\ndf_merge_test = pd.concat([X_test, y_test], axis = 1)","390cda43":"enc2 = LabelEncoder()\ndf_merge['label'] = enc2.fit_transform(df_merge['category'])\ndf_merge['cleaned_text'] = df_merge['text'].apply(lambda x: clean_text(x))\ndf_merge_test['label'] = enc2.fit_transform(df_merge_test['category'])\ndf_merge_test['cleaned_text'] = df_merge_test['text'].apply(lambda x: clean_text(x))\ndf_merge_test = df_merge_test.reset_index(drop= True)","616ae513":"category_encoding_merge = df_merge.groupby(['category'])['label'].min().rename('label').reset_index()\ncategory_encoding_merge","4e55c3e8":"tf.keras.backend.clear_session()\nskf = StratifiedKFold(n_splits = 4, shuffle = True)\nids, masks, token_ids, labels = encode(df_merge, max_len = max_len, category_encoding = category_encoding_merge)\n\nfor i , (train_index, val_index) in enumerate(skf.split(ids, labels.argmax(1))):\n    ids_train = ids[train_index,:]\n    masks_train = masks[train_index,:]\n    token_ids_train = token_ids[train_index, :]\n    labels_train = labels[train_index, :]\n    ids_val = ids[val_index,:]\n    masks_val = masks[val_index, :] \n    token_ids_val = token_ids[val_index, :]\n    labels_val = labels[val_index, :]\n    print(\"Fold :{}\".format(i+1))\n    model_merge = build_model(max_len = max_len, no_category = 8)\n    \n    model_merge.fit((ids_train, masks_train, token_ids_train), labels_train, verbose = 1, epochs = 4, batch_size = 32, validation_data = ((ids_val, masks_val, token_ids_val), labels_val))","d5407366":"ids_test, masks_test, token_ids_test, labels_test = encode(df_merge_test, max_len = max_len, category_encoding = category_encoding_merge)\nprediction = model_merge.predict((ids_test, masks_test, token_ids_test))\noutput = tf.keras.utils.to_categorical(df_merge_test['label'])\ntest_result = flat_accuracy(output, prediction)\nprint(\"The test set includes {} texts and the accuracy is {:.2f}\".format(len(output), test_result * 100))","83817148":"# Mathematics N-Gram","31760dc1":"# Tensorflow with Bert","3468bc76":"# **Cleaning the Text**\n* It is better to get rid of punctuation and stopwords from the text.","aea30ded":"# Uncovered words in the Glove Embeddings\n* We will find the words that Glove doesn't include and proportion of uncovered words.","151a838c":"# Physics N-Gram","144a897f":"# Classification for both Research and BBC Datasets\n* I am adding extra data for broader classification.\n* I have already implemented Bert Classification in another noteboook. You can reach from the link below.\n* https:\/\/www.kaggle.com\/cempek\/bbc-multiclass-glove-tf-vs-bert-pytorch-tf-99-5\n* We had 3 categories in previous dataset. I am now adding 5 more categories from BBC dataset includes less technical topics.\n* BBC dataset includes news about politics, entertainment, sport, tech, and business.","9880e116":"# Embedding Matrix\n**Creating embedding matrix for all the words that are in the whole dataset.**","17c831e3":"* As we can see, almost half of the texts are about machine learning and AI. \n* I dropped the other category for train dataset. So, we will have three main categories.","d219cf4b":"* This is the example of bert tokenization. The category names are encoded. [input_ids, token_type_ids, attention_mask].","9b80c185":"**Mathematics uncovered words**","aac008d1":"# The total number of words ","f20258d3":"* We retrieve sample data from the research dataset since BBC dataset has around 450 news in each category.","23f69088":"**Physics uncoverd words**","90a58576":"**Testing Model with Glove**","9ab66dee":"# Tensorflow with Glove Embeddings","318a05a3":"I have used same model for this merged dataset, I just changed the number category in the model.","2cb8ad1f":"**Result of Basket Analysis**\n\n\n* We can see most related categories from the table.\n* I looked confidence value to find out the relationship.\n* For example, fourth row shows that Strongly Collerated Electrons and Physics was together 6.3% of the whole dataset. And based on the confidence figure, Strongly Collerated Electronslso and Physics are highly correlated.\n* Hence, we can say that Strongly Collerated Electrons is subcategory of Physics.","bbaba2b8":"# N-Grams\n* This function returns the unique words(bigram) or sequence of words and its occurrence frequency.","a27f1764":"**Creating the validation data**","60b2c4a5":"Each text has more than one topic. For example, one text can be about computer science, statistics and machine learning at the same time. \n\nLet's find out the total number of topics for each text with the sum function.","27c4fd27":"* As you can see from the chart above, most of the text lengths are between 0 and 300. There 3 outliers in the texts.","9fe494a4":"The length of texts for Mathemathics is lower than other categories.","f28eabba":"# Bigram, 2-Gram, and 3-Gram\n* The new dataframe is created to find top 30 sequence of words in terms of categories.","e7ded9a1":"# Machine Learning and AI N-Gram","ef855a22":"# Result\n* In the research dataset, Bert performed better than bidirectional LSTM model.\n* After I merged the Research and BBC datasets, I have received better results(more than 95%) in the test data. \n* It is hard to predict the text that has very similar topic like Math and Physics, so the accuracy increased in the merged dataset which includes topics such as politics, entertainment, sport, business, machine learning and so on.","d6d8ced4":"* Based on confidence figure, I have decided to shrink the categories into 3 main categories.\n* Machine Learning and AI -> Statistics, Statistics Theory, Machine Learning, Artificial Intelligence, Computer Vision and Pattern Recognition\n* Physics -> Physics, Superconductivity, Strongly Correlated Electrons,  Astrophysics of Galaxies, Cosmology and Nongalactic Astrophysics, Earth and Planetary Astrophysics, Fluid Dynamics, Instrumentation and Methods for Astrophysics, Materials Science\n* Mathematics -> Mathematics, Number Theory, Analysis of PDEs, Differential Geometry, Optimization and Control, Representation Theory","066593c1":"* In glove embeddings, it is helpful to clean the text. Glove embeddings doesn't cover 25% of the words because there are too many words in these three topics. If we don't clean the text, proportion of uncovered words is around 70%.","f9242757":"**Machine Learning and AI uncoverd words**","d809e51b":"# Basket Analysis\n* I want to reduce the number of topic for related topics.\n* Basically, I want to create main category for each text so that I can classifiy them. \n* To find the relationships of topics, I used basket analysis.","ada6a14b":"* As you can see, highest total number of topic is 7. Actually, all of the texts have more than one topics.\n* I picked one of the text that has 7 different topics. You can see whole text and text topics below.","631dfeae":"**Splitting data into test and training**","23994659":"* Glove provides vector representation for words. I will use Common Crawl (840B tokens, 2.2M vocab, cased, 300d vectors).\n* It provides 300 dimensinal vector. Every dimension represents different feature of word. For example, one is positivity value of word, another one is negativity value of word, and so on.\n* We will find all words in the dataset and will create emmbedding matrix for all words.\n* The bidirectional layer will be used in neural network. Bidirectional layer is impoartant to train text data because it trains the sentence or text as is and reversed version of sentence.\n* **For example, \"I like a bar that plays jazz music\" - \"I like a bar of white chocolate not small piece\". As you can see first 3 words are same. If we don't train dataset with bidirectional layers, we cannot understand real meaning of the bar.**"}}