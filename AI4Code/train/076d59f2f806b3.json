{"cell_type":{"a2077228":"code","1795ad1c":"code","3048273f":"code","1f3a1805":"code","3fd458d6":"code","72095b64":"code","0c024013":"code","d1e77c5e":"code","d2dedb47":"code","dc16f964":"code","11f213c6":"code","987fe5fd":"code","1f0b9827":"code","21847ccd":"code","537296e3":"code","ca1e0c95":"code","94961b5d":"code","59d0a051":"markdown","063ca487":"markdown","49b782ce":"markdown","333d0b54":"markdown","c90906b9":"markdown","58d4bdff":"markdown","a667c7ca":"markdown","bbab4926":"markdown","3cda7559":"markdown","e02c8ade":"markdown"},"source":{"a2077228":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\nimport os \nimport cv2\n\n# geospatial frameworks\nimport rasterio as rs\nfrom rasterio.plot import show  # imshow for raster\nfrom rasterio.merge import merge\nimport geopandas as gpd\nfrom shapely.geometry import Point, Polygon  # for geometry processing\n","1795ad1c":"ROOT_DIR = '..\/input\/spacenet-6-multisensor-allweather-mapping\/AOI_11_Rotterdam\/'","3048273f":"MODES=os.listdir(ROOT_DIR)\nMODES.sort()\nMODES=MODES[:-2]","1f3a1805":"MODES","3fd458d6":"def get_filepath(image_id, mode='PS-RGB'):\n    return f'{ROOT_DIR}{mode}\/SN6_Train_AOI_11_Rotterdam_{mode}_{image_id}.tif'\n\ndef get_raster(image_id, mode='PS-RGB'):\n    return rs.open(get_filepath(image_id, mode))\n\n# I anticipated adding mode options, but I think the tile boundaries are the same for each mode\ndef create_geometry(mode, image_ids):\n    geometry = []\n    coordinate_system = rs.open(get_filepath(image_ids[0], mode)).crs\n    for image_id in tqdm(image_ids):\n        # read the raster\n        ex_raster = rs.open(get_filepath(image_id, mode))\n        \n        # grab its boundaries\n        lbox, bbox, rbox, tbox = ex_raster.bounds\n        # convert into coordinates\n        geometry.append(Polygon([\n            (lbox,tbox),\n            (rbox,tbox),\n            (rbox,bbox),\n            (lbox,bbox)]))\n\n    # create geodataframe\n    d = {'image_id': image_ids, 'geometry': geometry}\n    gdf = gpd.GeoDataFrame(d, crs=coordinate_system)\n\n    # saving to geojson file\n    gdf.to_file(f'{mode}.geojson', driver='GeoJSON')\n    print(f'{mode}.geojson saved successfully!')\n    \n\ndef get_region_index(patch):\n    \"\"\"\n    leaves nodata trails in the edges\n    np.argwhere() returns list of index. [[row,col],[row,col]]\n        of every element that gets true condition\n    \"\"\"\n    coords = np.argwhere(patch[:,:,0]!=0)\n    if len(coords)==0:\n        return 0,0,0,0\n    row0,col0 = coords.min(axis=0)  # find lowest row and col\n    row1,col1 = coords.max(axis=0)  # find highest row and col\n    return row0,row1+1,col0,col1+1\n\ndef extract_uniqe_tiles(geo_data_frame):\n    gdf= geo_data_frame.sample(frac=1)\n    plain_data_frame = gdf[:1]\n    for i ,(image_id,geometry) in tqdm(gdf.iterrows()):\n        if np.any(plain_data_frame.overlaps(geometry)) :\n            continue\n        instance=gpd.GeoDataFrame({'image_id':image_id,'geometry':geometry},crs=gdf.crs,index=[i])\n        plain_data_frame=plain_data_frame.append(instance,ignore_index=True)\n    return plain_data_frame","72095b64":"# grab unique image_id from the annotation csv\ndf = pd.read_csv(ROOT_DIR+'SummaryData\/SN6_Train_AOI_11_Rotterdam_Buildings.csv')\nimage_ids = df.ImageId.unique()","0c024013":"create_geometry('PS-RGB', image_ids)\ngdf = gpd.read_file('PS-RGB.geojson')\nfig, ax1 = plt.subplots(figsize=(20,10))\ngdf.plot(color='grey', alpha=0.3, edgecolor='black',ax=ax1)","d1e77c5e":"unique_tiles=extract_uniqe_tiles(gdf)\nfig, ax1 = plt.subplots(figsize=(20,10))\ngdf.plot(color='grey', alpha=0.3, edgecolor='black', ax=ax1)\nunique_tiles.plot(color='red', alpha=0.9, edgecolor='black', ax=ax1)","d2dedb47":"tiles=[]\nfor image_id in tqdm(image_ids):\n    tiles.append(get_raster(image_id,mode=MODES[1]))\nmosaic, out_trans = merge(tiles)","dc16f964":"img = rs.plot.reshape_as_image(mosaic)\nplt.figure(figsize=(10,10))\nplt.imshow(img)","11f213c6":"def create_data_set(mosaic_map,patch_size=(224,224)):\n    step_h,step_w = patch_size\n    h,w = mosaic_map.shape[:2]\n    s_total = step_h*step_w\n    patches = []\n    for m in tqdm(range(0,h,step_h)):\n        for n in range(0,w,step_w):\n            patch = mosaic_map[m : m+step_h, n : n+step_w]\n            r0,r1,c0,c1=get_region_index(patch)\n            s_mask = (r1-r0) * (c1 - c0)\n            goodness = s_mask\/s_total\n            if goodness > .98:\n                patches.append(patch)\n    return patches","987fe5fd":"OUTPUT_ROOT='\/kaggle\/working\/'\n\ndef write_data_set(patches,mode='RGB', root_dir=OUTPUT_ROOT):\n    assert os.path.exists(root_dir)\n    data_set_path = root_dir + \"DataSet\"\n    if not os.path.exists(data_set_path):\n        os.mkdir(data_set_path)\n    for i in tqdm(range(len(patches))):\n        current_set_path = os.path.join(data_set_path,'{:04d}'.format(i)) \n        if not os.path.exists(current_set_path):\n            os.mkdir(current_set_path)\n        file_path=os.path.join(current_set_path,mode+'.jpg')\n        cv2.imwrite(file_path,patches[i])\n        ","1f0b9827":"PATCH_SIZE=(1024,1024)\nfor mode in MODES[:3]:\n    print(mode,':\\n')\n    tiles = []\n    print('Reading Tiles ...')\n    for image_id in tqdm(image_ids):\n        tiles.append(get_raster(image_id,mode=mode))\n    print('Making Mosaic Map ...')\n    mosaic, _ = merge(tiles)\n    mosaic = np.transpose(mosaic,axes=[1,2,0])\n    print('Mosaic Map Size',mosaic.shape)\n    print('Making Patches ...')\n    patches = create_data_set(mosaic,PATCH_SIZE)\n    print('Writing Data On The Disk ...')\n    write_data_set(patches,mode=mode)\n    print ('*'*100)\nprint('*'*47,'Done','*'*47)","21847ccd":"mode=MODES[3]\nprint(mode,':\\n')\ntiles = []\nprint('Reading Tiles ...')\nfor image_id in tqdm(image_ids):\n    tiles.append(get_raster(image_id,mode=mode))\nprint('Making Mosaic Map ...')\nmosaic, _ = merge(tiles)\nmosaic = np.transpose(mosaic,axes=[1,2,0])\nmosaic = cv2.resize(mosaic,dsize=(0,0),fx=2,fy=2)\nprint('Mosaic Map Size',mosaic.shape)\nprint('Making Patches ...')\npatches = create_data_set(mosaic,PATCH_SIZE)\nprint('Writing Data On The Disk ...')\nwrite_data_set(patches,mode=mode)\nprint ('*'*100)","537296e3":"mode = MODES[4]\nCHANNEL = 0\nprint(mode,':\\n')\ntiles = []\nprint('Reading Tiles ...')\nfor image_id in tqdm(image_ids):\n    tiles.append(get_raster(image_id,mode=mode))\nprint('Making Mosaic Map ...')\nmosaic, _ = merge(tiles)\nmosaic = np.transpose(mosaic,axes=[1,2,0])\nsingle_channel = mosaic[:,:,CHANNEL]\nsingle_channel = np.expand_dims(single_channel,axis=-1)\nsingle_channel = single_channel\/single_channel.max()*255\nprint('Mosaic Map Size',mosaic.shape)\nprint('Channel Size',img.shape)\nprint('Making Patches ...')\npatches = create_data_set(single_channel,PATCH_SIZE)\nprint('Writing Data On The Disk ...')\nwrite_data_set(patches,mode=mode)\nprint ('*'*100)","ca1e0c95":"img1=cv2.imread('.\/DataSet\/0001\/PS-RGB.jpg')\nimg2=cv2.imread('.\/DataSet\/0001\/PAN.jpg')\nimg3=cv2.imread('.\/DataSet\/0001\/PS-RGBNIR.jpg')\nimg4=cv2.imread('.\/DataSet\/0001\/RGBNIR.jpg')\nimg5=cv2.imread('.\/DataSet\/0001\/SAR-Intensity.jpg')\n","94961b5d":"fig,ax=plt.subplots(1,5, figsize=(25,5))\nax[0].imshow(img1)\nax[1].imshow(img2)\nax[2].imshow(img3)\nax[3].imshow(img4)\nax[4].imshow(img5[:,:,1])","59d0a051":"Here are all the tiles","063ca487":"The first approach to extract unique non overlaping tiles was as follow but since there are \"No Data\" parts in tiles and the extracted tiles are not close enough this method is not efficient","49b782ce":"This is our mosaic map","333d0b54":"Some utility functions from [here](https:\/\/www.kaggle.com\/sandhiwangiyana\/sn6-working-with-geo-reference-images-eda)","c90906b9":"Here is an example of what we get","58d4bdff":"And finally for SAR-Intensity images we need to scale the intensity levels ","a667c7ca":"For RGBNIR images we need to scale up the size with a factor of 2","bbab4926":"We try to make a Mosaic map off the tiles you can find detailed information [here](https:\/\/automating-gis-processes.github.io\/CSC18\/lessons\/L6\/raster-mosaic.html)\n","3cda7559":"Now let's make our data set","e02c8ade":"The processing for 'PAN', 'PS-RGB' and  'PS-RGBNIR' is the same "}}