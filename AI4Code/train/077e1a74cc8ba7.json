{"cell_type":{"86c140b7":"code","b4ab5a17":"code","db0e7179":"code","97390dc4":"code","4cfa38dd":"code","b698aeed":"code","7adb63cc":"code","5ad9f6e0":"code","70160190":"code","afd0e790":"code","fb30d0f2":"code","fb1415f3":"code","66a2900b":"code","de8932f6":"code","488f3543":"code","02b87b45":"code","e1082c58":"code","30f70798":"code","e3360885":"code","b8591a43":"code","4476f987":"code","e527e7af":"code","b62871be":"code","2329d9ad":"code","3dadbc16":"code","c2c2ad7b":"code","91a7fbcb":"code","9b452293":"code","54646320":"code","34ad2567":"code","2d6ea53e":"code","d615366e":"code","adc02808":"code","8cdd6b08":"markdown","12d57910":"markdown","70a93199":"markdown","b5fd36de":"markdown","1d0940a5":"markdown","9bc7e244":"markdown","d5987adb":"markdown"},"source":{"86c140b7":"# importing some library which help to perform vasic operations on dataset.\nimport pandas as pd\nimport numpy as np\nfrom scipy import stats\nimport statsmodels.api as sm\nimport matplotlib.pyplot as plt\n\n%matplotlib inline","b4ab5a17":"# reading the dataset using pandas library\ndf = pd.read_csv('..\/input\/into-the-future\/train.csv')","db0e7179":"# printing first five rows in out dataset\ndf.head()","97390dc4":"# It is used for calculating some statistical data like percentile, mean and std of the numerical values of the Series or DataFrame\ndf.describe()","4cfa38dd":"# It is used to print a concise summary of our DataFrame.\ndf.info()","b698aeed":"# we not need to convert time to datetime because our dataset already in same format which i want.\ndf['time'] = pd.to_datetime(df['time'])\n\n# deleting the unusable column from our dataset.\ndf.drop('id',axis=1,inplace=True)\n\n# set_index is used to set the DataFrame index using existing columns.\ndf.set_index('time',inplace=True)","7adb63cc":"# printing last five rows of our dataset.\ndf.tail()","5ad9f6e0":"# printing the shape of our dataset\nprint(df.shape)\n\n# graphical representation of feature_1 in our dataset same thing will do in feature_2.\nplt.plot(df['feature_1'])","70160190":"plt.plot(df['feature_2'])","afd0e790":"from fbprophet import Prophet\n\nimport logging\nlogging.getLogger().setLevel(logging.ERROR)","fb30d0f2":"data = df.reset_index()\ndata.tail(n=3)","fb1415f3":"data2 = data[['time','feature_2']].reset_index()\ndata2.drop('index',axis=1,inplace=True)\ndata2.columns = ['ds', 'y']\ndata2.tail(3)","66a2900b":"# train test\nprediction_size = 30\ntrain_df2 = data2[:-prediction_size]\ntrain_df2.tail()","de8932f6":"# initialize Prophet\nm = Prophet()\n\n# point towards dataframe\nm.fit(train_df2)","488f3543":"# set future prediction window of prediction_size\nfuture = m.make_future_dataframe(periods=435, freq='10S')\n#future = m.make_future_dataframe(periods=prediction_size)\n\n# preview our data -- note that Prophet is only showing future dates (not values), as we need to call the prediction method still\nfuture.tail(n=3)","02b87b45":"forecast = m.predict(future)\n\n# This will printing last five rows after forecasting\nforecast.tail(3)","e1082c58":"# If you want to show only usefull columns then..\nforecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()","30f70798":"fig1 = m.plot(forecast)\nfig1","e3360885":"fig2 = m.plot_components(forecast)\nfig2","b8591a43":"print(', '.join(forecast.columns))","4476f987":"def make_comparison_dataframe(historical, forecast):\n    \"\"\"Join the history with the forecast.\n    \n       The resulting dataset will contain columns 'yhat', 'yhat_lower', 'yhat_upper' and 'y'.\n    \"\"\"\n    return forecast.set_index('ds')[['yhat', 'yhat_lower', 'yhat_upper']].join(historical.set_index('ds'))","e527e7af":"cmp_df = make_comparison_dataframe(data2, forecast[534:563])\ncmp_df.tail(n=3)\nlen(cmp_df)","b62871be":"fcast = forecast[534:563]['yhat']\nfcast.head()","2329d9ad":"def calculate_forecast_errors(df, prediction_size):\n    # Make a copy\n    df = df.copy()\n    \n    # Now we calculate the values of e_i and p_i according to the formulas given in the article above.\n    df['e'] = df['y'] - df['yhat']\n    df['p'] = 100 * df['e'] \/ df['y']\n    \n    # Recall that we held out the values of the last `prediction_size` days\n    # in order to predict them and measure the quality of the model. \n    \n    # Now cut out the part of the data which we made our prediction for.\n    predicted_part = df[-prediction_size:]\n    \n    # Define the function that averages absolute error values over the predicted part.\n    error_mean = lambda error_name: np.mean(np.abs(predicted_part[error_name]))\n    \n    # Now we can calculate MAPE and MAE and return the resulting dictionary of errors.\n    return {'MAPE': error_mean('p'), 'MAE': error_mean('e')}\n","3dadbc16":"# MAE(mean absolute error) is absolute error is the absolute value of the difference between the forecasted value and the actual value.\n# MAPE(mean absolute percentage error) is allows us to compare forecasts of different series in different scales.\nfor err_name, err_value in calculate_forecast_errors(cmp_df, prediction_size).items():\n    print(err_name, err_value)","c2c2ad7b":"from plotly.offline import init_notebook_mode, iplot\nfrom plotly import graph_objs as go\n\n# Initialize plotly\ninit_notebook_mode(connected=True)","91a7fbcb":"def show_forecast(cmp_df, num_predictions, num_values, title):\n    \"\"\"Visualize the forecast.\"\"\"\n    \n    def create_go(name, column, num, **kwargs):\n        points = cmp_df.tail(num)\n        args = dict(name=name, x=points.index, y=points[column], mode='lines')\n        args.update(kwargs)\n        return go.Scatter(**args)\n    \n    lower_bound = create_go('Lower Bound', 'yhat_lower', num_predictions,\n                            line=dict(width=0),\n                            marker=dict(color=\"gray\"))\n    upper_bound = create_go('Upper Bound', 'yhat_upper', num_predictions,\n                            line=dict(width=0),\n                            marker=dict(color=\"gray\"),\n                            fillcolor='rgba(68, 68, 68, 0.3)', \n                            fill='tonexty')\n    forecast = create_go('Forecast', 'yhat', num_predictions,\n                         line=dict(color='rgb(31, 119, 180)'))\n    actual = create_go('Actual', 'y', num_values,\n                       marker=dict(color=\"red\"))\n    \n    # In this case the order of the series is important because of the filling\n    data = [lower_bound, upper_bound, forecast, actual]\n\n    layout = go.Layout(yaxis=dict(title='features'), title=title, showlegend = False)\n    fig = go.Figure(data=data, layout=layout)\n    iplot(fig, show_link=False)\n\nshow_forecast(cmp_df, prediction_size, 100, 'Visualization')","9b452293":"test = pd.read_csv('..\/input\/into-the-future\/test.csv')\nlen(test)","54646320":"d = forecast[594:]['yhat']\nlen(d)","34ad2567":"# generating new dataframe for final outcome\nfinal = pd.DataFrame()\n\nfinal['id'] = test['id']\nfinal['feature_2'] = list(d)","2d6ea53e":"# printing first five rows of our predicted data\nfinal.head()","d615366e":"final.tail()","adc02808":"# finally save that final dataframe into the CSV file using \"to_csv\" function.\nfinal.to_csv(\"\/kaggle\/working\/solution.csv\", index=False)","8cdd6b08":"#### To measure the quality of our forecast, we need to split our dataset into the historical part, which is the first and biggest slice of our data, and the prediction part, which will be located at the end of the timeline.","12d57910":"#### We now have an initial time series forecast using Prophet, we can plot the results as shown below:","70a93199":"#### Prophet is a forecasting tool developed by Facebook to quickly forecast time series data, available in R and Python. ","b5fd36de":"#### Now we need to create a new Prophet object. Here we can pass the parameters of the model into the constructor. Then we train our model by invoking its fit method on our training dataset:","1d0940a5":"#### Next, we can call the predict method, which will assign each row in our 'future' dataframe a predicted value, which it names yhat. Additionally, it will show lower\/upper bounds of uncertainty, called yhat_lower and yhat_upper.","9bc7e244":"Name: Mohit Radadiya\n\nEmail: radadiyamohit909@gmail.com\n\ncontact: 8140857649","d5987adb":"#### In the resulting dataframe you can see many columns characterizing the prediction, including trend and seasonality components as well as their confidence intervals. The forecast itself is stored in the yhat column.\n\n#### The Prophet library has its own built-in tools for visualization that enable us to quickly evaluate the result.\n\n#### First, there is a method called Prophet.plot that plots all the points from the forecast:"}}