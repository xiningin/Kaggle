{"cell_type":{"5a141168":"code","948e0242":"code","8e8ce5cb":"code","06f1e4b0":"code","08df0221":"code","9396aa31":"code","299ac803":"code","8ced9338":"code","5a7211fd":"code","a278dc9d":"code","0ae52c17":"code","f507c174":"markdown","5b8801f9":"markdown","b7d30ddb":"markdown","1247867c":"markdown","0f704812":"markdown","ae326290":"markdown","753747ca":"markdown","dd857c52":"markdown","f9d9bfee":"markdown","f9495404":"markdown","3811985c":"markdown"},"source":{"5a141168":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","948e0242":"!pip install minisom\nfrom minisom import MiniSom  \n\nimport matplotlib.pyplot as plt\n%matplotlib inline","8e8ce5cb":"DATA_DIR = '\/kaggle\/input\/customer-segmentation-tutorial-in-python\/Mall_Customers.csv'\ndf = pd.read_csv(DATA_DIR)\ndf","06f1e4b0":"plt.style.use('fivethirtyeight')","08df0221":"age = df['Age'].tolist()\nspending_score = df['Spending Score (1-100)'].tolist()\nfig = plt.figure(figsize=(6,6))\nplt.scatter(age, spending_score)\nplt.suptitle(\"Scatter Plot of Age and Spending Score\")\nplt.xlabel(\"Age\")\nplt.ylabel(\"Spending Score\")\nplt.show()","9396aa31":"age = df['Age'].tolist()\nannual_income = df['Annual Income (k$)'].tolist()\nfig = plt.figure(figsize=(6,6))\nplt.scatter(age, annual_income)\nplt.suptitle(\"Scatter Plot of Age and Annual Income\")\nplt.xlabel(\"Age\")\nplt.ylabel(\"Annual Income (k$)\")\nplt.show()","299ac803":"annual_income = df['Annual Income (k$)'].tolist()\nspending_score = df['Spending Score (1-100)'].tolist()\nfig = plt.figure(figsize=(6,6))\nplt.scatter(annual_income, spending_score)\nplt.suptitle(\"Scatter Plot of Annual Income & Spending Score\")\nplt.xlabel(\"Annual Income (k$)\")\nplt.ylabel(\"Spending Score (1-100)\")\nplt.show()","8ced9338":"df.isnull().sum()","5a7211fd":"# Select Annual Income and Spending Score as our features\nfeatures = df[['Annual Income (k$)', 'Spending Score (1-100)']]\n\n# Transform features to list\ndata = features.values\ndata.shape","a278dc9d":"# I use linear som topography\nsom_shape = (1, 5)\n\nsom = MiniSom(som_shape[0], som_shape[1], data.shape[1], sigma=0.5, learning_rate=0.5)\n\nmax_iter = 1000\nq_error = []\nt_error = []\n\nfor i in range(max_iter):\n    rand_i = np.random.randint(len(data))\n    som.update(data[rand_i], som.winner(data[rand_i]), i, max_iter)\n    q_error.append(som.quantization_error(data))\n    t_error.append(som.topographic_error(data))\n\nplt.plot(np.arange(max_iter), q_error, label='quantization error')\nplt.plot(np.arange(max_iter), t_error, label='topographic error')\nplt.ylabel('Quantization error')\nplt.xlabel('Iteration index')\nplt.legend()\nplt.show()","0ae52c17":"# each neuron represents a cluster\nwinner_coordinates = np.array([som.winner(x) for x in data]).T\n\n# with np.ravel_multi_index we convert the bidimensional\n# coordinates to a monodimensional index\ncluster_index = np.ravel_multi_index(winner_coordinates, som_shape)\n\n# Plotting the clusters \nplt.figure(figsize=(10,8))\n\nfor c in np.unique(cluster_index):\n    plt.scatter(data[cluster_index == c, 0],\n                data[cluster_index == c, 1], label='cluster='+str(c), alpha=.7)\n\n# Plotting centroids\nfor centroid in som.get_weights():\n    plt.scatter(centroid[:, 0], centroid[:, 1], marker='x', \n                s=10, linewidths=20, color='k') # label='centroid'\n    \nplt.title(\"Clusters of Customers\")\nplt.xlabel(\"Annual Income (k$)\")\nplt.ylabel(\"Spending Score (1-100)\")\nplt.legend();","f507c174":"## Final Result\nHere we can see that there are 5 cluster of customers based on the annual income and spending score :\n\nCluster 0 : High income low spender\n\nCluster 1 : High income high spender\n\nCluster 2 : Low income high spender\n\nCluster 3 : Medium income medium spender\n\nCluster 4 : Low income low spender","5b8801f9":"### Annual Income and Spending Score Data Distribution\n\n**Result : There are 5 clusters detected**","b7d30ddb":"## Feature Selection\n\nWe will see which features combination are able to be clustered","1247867c":"### Age and Spending Score Data Distribution\n\nResult : No apparent cluster detected","0f704812":"## Train SOM","ae326290":"## Libraries\n\nCredits to Giuseppe Vettigli (Just Glowing) for the MiniSom library which I use here to implement the Self Organizing Map (SOM)\n\nRepository : https:\/\/github.com\/JustGlowing\/minisom","753747ca":"## Import Data","dd857c52":"## Intro\n\nIn this notebook we will demonstrate how to use minisom to do linear topology clustering\n\nPlease upvote this notebook if you find it helpful :)\n\nJonathan Kristanto &copy; May 2021","f9d9bfee":"### Age and Annual Income Data Distribution\n\nResult : No apparent cluster detected","f9495404":"## Clean & Transform Data","3811985c":"## Result Plot"}}