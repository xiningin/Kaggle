{"cell_type":{"4230506e":"code","6f59a74a":"code","43ebf3d5":"code","6f45bc6a":"code","56a7ac4d":"code","cf43728b":"code","33657073":"code","2d635886":"code","4d5789d7":"markdown"},"source":{"4230506e":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport gc","6f59a74a":"import seaborn as sns","43ebf3d5":"train = pd.read_csv('..\/input\/tabular-playground-series-oct-2021\/train.csv')\ntest = pd.read_csv('..\/input\/tabular-playground-series-oct-2021\/test.csv')\nsubmission = pd.read_csv('..\/input\/tabular-playground-series-oct-2021\/sample_submission.csv')","6f45bc6a":"def memory_usage_per_type(df):\n    types = ['float','int','object']\n    for type in types:\n        selected_col = df.select_dtypes(include=[type])\n        memory_usage_of_selected_type_b = selected_col.memory_usage(deep=True).sum()\n        memory_usage_of_selected_type_mb = memory_usage_of_selected_type_b\/1024**2\n        print(\"memeory usage for {} columns: {:03.2f} MB\".format(type,memory_usage_of_selected_type_mb))\ndef memory_usage(df):\n    return df.memory_usage(deep=True).sum()\/1024**2\nmemory_usage_per_type(train)\nprint(\"Memory use before optimization {:.2f} MB\".format(memory_usage(train)))","56a7ac4d":"def downcast_and_compare_memory_consuming_by_type_first(type_):\n    selected_type = train.select_dtypes(include=[type_])\n    converted_type = selected_type.apply(pd.to_numeric,downcast=type_)\n    memory_before = memory_usage(selected_type)\n    memory_after = memory_usage(converted_type)\n    print('before the downcast:{:.2f} MB'.format(memory_before))\n    print('after the downcast:{:.2f} MB'.format(memory_after))\n    print('')\n    compare_type_changes = pd.concat([selected_type.dtypes,converted_type.dtypes],axis=1)\n    compare_type_changes.columns = ['before','after']\n    return compare_type_changes.apply(pd.Series.value_counts)","cf43728b":"downcast_and_compare_memory_consuming_by_type_first('float')","33657073":"def downcast_and_compare_memory_consuming_by_type_second(type_):\n    selected_col = train.select_dtypes(include=[type_])\n    memory_before = memory_usage(selected_col)\n    optimize_col = selected_col.copy()\n    for col in optimize_col.columns:\n        mx_col = optimize_col[col].max()\n        mn_col = optimize_col[col].min()\n        if type_=='int':\n            if mn_col>0:\n                    if mx_col < 255:\n                        optimize_col[col] = optimize_col[col].astype(np.uint8)\n                    elif mx_col < 65535:\n                        optimize_col[col] = optimize_col[col].astype(np.uint16)\n                    elif mx_col < 4294967295:\n                        optimize_col[col] = optimize_col[col].astype(np.uint32)\n                    else:\n                        optimize_col[col] = optimize_col[col].astype(np.uint64)\n            else:\n                    if mn_col > np.iinfo(np.int8).min and mx < np.iinfo(np.int8).max:\n                        optimize_col[col] = optimize_col[col].astype(np.int8)\n                    elif mn > np.iinfo(np.int16).min and mx < np.iinfo(np.int16).max:\n                        optimize_col[col] = optimize_col[col].astype(np.int16)\n                    elif mn > np.iinfo(np.int32).min and mx < np.iinfo(np.int32).max:\n                        optimize_col[col] = optimize_col[col].astype(np.int32)\n                    elif mn > np.iinfo(np.int64).min and mx < np.iinfo(np.int64).max:\n                        optimize_col[col] = optimize_col[col].astype(np.int64)\n        else:\n            if mn_col > np.finfo(np.float16).min and mx_col < np.finfo(np.float16).max:\n                    optimize_col[col] = optimize_col[col].astype(np.float16)\n            elif mn_col > np.finfo(np.float32).min and mx_col < np.finfo(np.float32).max:\n                    optimize_col[col] = optimize_col[col].astype(np.float32)\n            else:\n                    optimize_col[col] = optimize_col[col].astype(np.float64)\n            \n    memory_after = memory_usage(optimize_col)\n    print('before the downcast:{:.2f} MB'.format(memory_before))\n    print('after the downcast:{:.2f} MB'.format(memory_after))\n    compare_type_changes = pd.concat([selected_col.dtypes,optimize_col.dtypes],axis=1)\n    compare_type_changes.columns = ['before','after']\n    return compare_type_changes.apply(pd.Series.value_counts)","2d635886":"downcast_and_compare_memory_consuming_by_type_second('float')\n","4d5789d7":"Came across this blog post about downcasting the data as i tried it found it really cool.\nhttps:\/\/medium.com\/@alielagrebi\/optimize-the-pandas-dataframe-memory-consuming-for-low-environment-24aa74cf9413"}}