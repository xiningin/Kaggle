{"cell_type":{"db90565c":"code","226d1688":"code","dc1faa65":"code","418a8940":"code","085a58ee":"code","58daf2b8":"code","ae7bb10a":"code","d476a1f1":"code","67162541":"code","4e2ab0e7":"code","7d020fba":"code","d719b0fc":"code","566678a7":"code","90e8eb8d":"code","d63e34eb":"code","6ecc1a3d":"code","5565db67":"code","f61e9e7d":"code","072de912":"code","0ebfda01":"code","811eda8e":"code","96cb211b":"code","b97e7913":"code","f7b03995":"code","d5e4cd62":"code","e50c5d6d":"code","8fcbc160":"code","f72bcea0":"code","2a9862a9":"code","d79042ef":"markdown","1a29367a":"markdown","9a0c7114":"markdown","b164e041":"markdown","66e39b01":"markdown","458c30f6":"markdown","08d71845":"markdown","2c4cdb5f":"markdown","f3541635":"markdown","f247165c":"markdown","841ea8e2":"markdown","0cf7ba60":"markdown","53f7a738":"markdown","341e8588":"markdown","d8c2bdfb":"markdown","069cce4c":"markdown","983174da":"markdown","2781f107":"markdown","428eac78":"markdown","e40daaa9":"markdown","20b22067":"markdown","bba04ec0":"markdown"},"source":{"db90565c":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport matplotlib.style as stl\nstl.use(\"ggplot\")\nfrom sklearn.metrics import classification_report\nfrom sklearn.ensemble import RandomForestClassifier\nrf = RandomForestClassifier(max_depth=10)\nimport warnings\nwarnings.filterwarnings(\"ignore\")","226d1688":"data=pd.read_csv(\"..\/input\/stroke-prediction-dataset\/healthcare-dataset-stroke-data.csv\")\ndata.drop(\"id\",axis=1,inplace=True)","dc1faa65":"impdata = pd.read_csv(\"..\/input\/imputed-stroke-dataset\/impstroke.csv\")\nimpdata.drop(\"Unnamed: 0\",axis=1,inplace=True)\nx=impdata.drop(\"stroke\",axis=1)\ny=impdata[\"stroke\"]","418a8940":"plt.figure(figsize=(10,6))\ncp=sns.countplot(x=data[\"stroke\"],palette=\"seismic\")\nplt.title(\"Imbalance in the Target Variable\\n\",fontsize=30)\nplt.xlabel(\"Stroke\",fontsize=15)\nplt.ylabel(\"Count\",fontsize=15)\nplt.show()","085a58ee":"continuous=[\"bmi\",\"avg_glucose_level\",\"age\"] #work type is an encoded categorical feature, not a continuous one","58daf2b8":"fig,axes=plt.subplots(nrows=3,ncols=1,figsize=(12,20))\nfig.suptitle(\"Distributions of Continuous Features\",fontsize=25)\n\n\nlabel1='Mean = {}\\nMedian = {}\\nStandard Deviation = {}'.format(\"%.2f\"%data[\"bmi\"].mean(),\n                                                               data[\"bmi\"].median(),\n                                                               \"%.2f\"%data[\"bmi\"].std())\nsns.histplot(x=data[\"bmi\"],ax=axes[0],color='crimson',label=label1).legend(loc='best',fontsize=15)\naxes[0].set_title(\"BMI: Worrisome Outliers\")\naxes[0].set_xlabel(None)\n\n\nlabel2='Mean = {}\\nMedian = {}\\nStandard Deviation = {}'.format(\"%.2f\"%data[\"avg_glucose_level\"].mean(),\n                                                                \"%.2f\"%data[\"avg_glucose_level\"].median(),\n                                                                \"%.2f\"%data[\"avg_glucose_level\"].std())\nsns.histplot(x=data[\"avg_glucose_level\"],ax=axes[1],color=\"crimson\", label=label2).legend(loc='best',fontsize=15)\naxes[1].set_title(\"Average Glucose Level: Somewhat Skewed, but Nothing Awful\")\naxes[1].set_xlabel(None)\n\n\nlabel3='Mean = {}\\nMedian = {}\\nStandard Deviation = {}'.format(\"%.2f\"%data[\"age\"].mean(),\n                                                                data[\"age\"].median(),\n                                                                \"%.2f\"%data[\"age\"].std())\nsns.histplot(x=data[\"age\"],ax=axes[2],color=\"crimson\",label=label3).legend(loc='best',fontsize=15)\naxes[2].set_title(\"Age: No Outliers\")\naxes[2].set_xlabel(None)\n\nplt.show()","ae7bb10a":"categoricals = []\nfor col in data.drop(\"stroke\",axis=1):\n    if not(col in continuous):\n        categoricals.append(col)","d476a1f1":"fig,axes=plt.subplots(nrows=7,ncols=1,figsize=(13,50))\nfig.suptitle(\"Distributions of Categorical Features\",fontsize=40)\ni=0\nfor col in (data.drop(\"stroke\",axis=1).columns):\n    if not(col in continuous):\n        sns.countplot(x=data[col],ax=axes[i],palette=\"cool\")\n        axes[i].set_title(col,fontsize=20)\n        axes[i].set_xlabel(None)\n        axes[i].set_ylabel(\"Count\",fontsize=15)\n        i+=1\nplt.show()","67162541":"for col in categoricals:\n    impdata[col] = impdata[col].astype(\"category\")","4e2ab0e7":"from sklearn.preprocessing import RobustScaler\nfrom umap import UMAP","7d020fba":"rb=RobustScaler()\nscaled_data = rb.fit_transform(x)","d719b0fc":"ump=UMAP(random_state=11,n_neighbors=5,min_dist=0.5)","566678a7":"umap_data = ump.fit_transform(scaled_data)","90e8eb8d":"plt.figure(figsize=(16,10))\nsns.scatterplot(x=umap_data[:,0],y=umap_data[:,1],hue=y,palette=\"seismic\")\nplt.title('UMAP',fontsize=45)\nplt.show()","d63e34eb":"from sklearn.decomposition import PCA","6ecc1a3d":"pca = PCA(n_components=2)\npca_data=pca.fit_transform(scaled_data)","5565db67":"pca_data=pd.DataFrame(pca_data,columns=[\"PC1\",\"PC2\"])\npca_data[\"Stroke\"]=y\npca_data.head()","f61e9e7d":"plt.figure(figsize=(16,8))\nsns.scatterplot(x=\"PC1\",y=\"PC2\",hue=\"Stroke\",data=pca_data, palette=\"seismic\")\nplt.title(\"Distribution across Top 2 PCA Components\",fontsize=30)\nplt.show()","072de912":"from imblearn.over_sampling import RandomOverSampler","0ebfda01":"proportions = [0.1,0.33,0.5,0.66,1]","811eda8e":"oversampled_data = {}\nfor i in proportions:\n    oversampler = RandomOverSampler(sampling_strategy=i)\n    x_ros, y_ros = oversampler.fit_resample(x, y)\n    x_ros = rb.fit_transform(x_ros)\n    oversampled_data[i] = [x_ros,y_ros]","96cb211b":"fig,axes=plt.subplots(nrows=5,ncols=2,figsize=(20,35))\nfig.suptitle(\"Random Oversampling Results\\nWith Different Minority Class Proportions\",fontsize=40)\nfor i in range(5):\n    proportion = proportions[i]\n    x_ros, y_ros = oversampled_data[proportion]\n    ros_umap = ump.fit_transform(x_ros)\n    sns.scatterplot(x=ros_umap[:,0],y=ros_umap[:,1],hue=y_ros,palette=\"seismic\",ax=axes[i,0])\n    axes[i,0].set_title(f\"UMAP\\nMinority Class Proportion = {proportion}\")\n    pca_ros=pca.fit_transform(x_ros)\n    pca_ros=pd.DataFrame(pca_ros,columns=[\"PC1\",\"PC2\"])\n    pca_ros[\"Stroke\"]=y_ros\n    sns.scatterplot(x=\"PC1\",y=\"PC2\",hue=\"Stroke\",data=pca_ros, palette=\"seismic\",ax=axes[i,1])\n    axes[i,1].set_title(f\"Top 2 PCA Components\\nMinority Class Proportion = {proportion}\")\nplt.show()","b97e7913":"from sklearn.svm import SVC\nsv=SVC()","f7b03995":"xg, yg = oversampled_data[1]\nxgumap = ump.fit_transform(xg)\nsv.fit(xgumap,yg)\nxump = ump.transform(x)\ny_pred = sv.predict(xump)\ntest_mat_ros=classification_report(y,y_pred)\nprint(f\"Gaussian SVM on UMAP output (Testing Results):\\n{test_mat_ros}\")","d5e4cd62":"for i in range(5):\n    proportion = proportions[i]\n    x_ros, y_ros = oversampled_data[proportion]\n    rf.fit(x_ros,y_ros)\n    y_pred_ts=rf.predict(x)\n    test_mat_ros=classification_report(y,y_pred_ts)\n    print(\"Random Forest Results with Random Oversampling:\")\n    print(\"Proportion = {}\\n{}\\n\\n\".format(proportion,test_mat_ros))","e50c5d6d":"from imblearn.under_sampling import RandomUnderSampler","8fcbc160":"undersampled_data = {}\nfor i in proportions:\n    undersampler = RandomUnderSampler(sampling_strategy=i)\n    x_rus, y_rus = undersampler.fit_resample(x, y)\n    x_rus = rb.fit_transform(x_rus)\n    undersampled_data[i] = [x_rus,y_rus]","f72bcea0":"fig,axes=plt.subplots(nrows=5,ncols=2,figsize=(20,35))\nfig.suptitle(\"Random Undersampling Results\\nWith Different Minority Class Proportions\",fontsize=40)\nfor i in range(5):\n    proportion = proportions[i]\n    x_rus, y_rus = undersampled_data[proportion]\n    rus_umap = ump.fit_transform(x_rus)\n    sns.scatterplot(x=rus_umap[:,0],y=rus_umap[:,1],hue=y_rus,palette=\"seismic\",ax=axes[i,0])\n    axes[i,0].set_title(f\"UMAP\\nProportion = {proportion}\")\n    pca_rus=pca.fit_transform(x_rus)\n    pca_rus=pd.DataFrame(pca_rus,columns=[\"PC1\",\"PC2\"])\n    pca_rus[\"Stroke\"]=y_rus\n    sns.scatterplot(x=\"PC1\",y=\"PC2\",hue=\"Stroke\",data=pca_rus, palette=\"seismic\",ax=axes[i,1])\n    axes[i,1].set_title(f\"Top 2 PCA Components\\nProportion = {proportion}\")\nplt.show()","2a9862a9":"for i in range(5):\n    proportion = proportions[i]\n    x_rus, y_rus = undersampled_data[proportion]\n    rf.fit(x_rus,y_rus)\n    y_pred_ts=rf.predict(x)\n    test_mat_ros=classification_report(y,y_pred_ts)\n    print(\"Random Forest Results with Random Undersampling:\")\n    print(\"Proportion = {}\\n{}\\n\\n\".format(proportion,test_mat_ros))","d79042ef":"Patients in the \"1\" class don't seem to be well differentiated in one separate cluster.  ","1a29367a":"This is very unusual.  \nBut these two would make nice features.  \nWe'll see about that in the feature engineering section.","9a0c7114":"My guess is: **probably not**. At least not considerably, and at least not with this data.  \nI say this because the minority-class samples are sparsely distributed throughout the majority-class distribution ie **the two classes are not well distinguished\/separated**.   \n\nI actually went on and further experimented with SMOTE and as expected; no improvement.","b164e041":"That last UMAP scatterplot seems to somewhat separate the classes.  \nAn SVM classifer with an RBF kernel might do a decent job.","66e39b01":"# Exploratory Analysis","458c30f6":"This indicates imbalance in the target variable.","08d71845":"### Model Evaluation with Random Oversampling","2c4cdb5f":"**Hello and welcome**.  \n\n**This is part 2 to a 3-kernel project on Stroke Prediction.**\n\n  \n**Part 1 is Preprocessing: Data Cleaning, Target Encoding and MICE for missing values**  \nLink: **https:\/\/www.kaggle.com\/mahmoudlimam\/stroke-pre-processing-mice-target-encoding**\n\n  \n**Part 2 (which is this one) is EDA (including UMAP and PCA) and Random Oversampling**\n\n  \n**Part 3 is Detailed Feature extraction and Selection, and model evaluation**  \nLink: **https:\/\/www.kaggle.com\/mahmoudlimam\/stroke-pca-ica-lda-kmeans-dbscan-prediction** \n\nI didn't include a hyperparameter tuning section as Feature Engineering in an F1_Score of 1 with a somewhat deep Random Forest.","f3541635":"# Random Sampling","f247165c":"Wow, this is funny.  \nApparently, the algorithm is now classifying pretty much all the minority-class samples correctly, and all the majority-class samples incorrectly.  \nQuite amusing, but totally awful.","841ea8e2":"\u0627\u0644\u062d\u0645\u062f \u0644\u0644\u0647 \u0627\u0644\u0630\u064a \u0628\u0646\u0639\u0645\u062a\u0647 \u062a\u062a\u0645 \u0627\u0644\u0635\u0627\u0644\u062d\u0627\u062a","0cf7ba60":"SMOTE and its variants are common techniques for oversampling.  \nMany of them are quite sensitive to outliers though.  \nLet's make a quick EDA to search for outliers","53f7a738":"## 1 - Random Oversampling","341e8588":"### Question: Would other resampling techniques give better results?","d8c2bdfb":"### Training an SVM Classifier on the output of UMAP","069cce4c":"plt.figure(figsize=(20,15))\ncat_mi = pd.DataFrame(np.zeros((7,7)),columns=categoricals,index=categoricals)\nfor i in range(7):\n    for j in range(7):\n        print(data.columns[i]+\" vs \"+data.columns[j])\n        cat_mi.iloc[i,j] = mutual_info_classif(impdata[data.columns[i]].values.reshape(-1,1),impdata[data.columns[j]].values.reshape(-1,),random_state=11)\n        print(\"finished\")","983174da":"Well that's quite awful.  \nDidn't expect that.  \nPerhaps it would've done much better on the training data.  \nBut no one cares about that.","2781f107":"\u0628\u0633\u0645 \u0627\u0644\u0644\u0647","428eac78":"**\"What to do now?\" I hear you ask, curious viewer.**  \nWell, we just try to separate them.  \nWith some ***Feature Engineering***  .    \n**Adding** more informative **features** (ones that reduce entropy in the target feature) would probably separate the two classes, at least a bit more.  \nThis can be found in the next episode here: https:\/\/www.kaggle.com\/mahmoudlimam\/stroke-pca-ica-lda-kmeans-dbscan-prediction  \nMake sure you see it, it's the last episode xD","e40daaa9":"### Model Evaluation with Random Undersampling","20b22067":"## 2 - Random Undersampling","bba04ec0":"# **Stroke: EDA, UMAP & Resampling**"}}