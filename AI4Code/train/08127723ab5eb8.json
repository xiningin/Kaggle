{"cell_type":{"c1c20b68":"code","81a55c13":"code","468e7546":"code","6281a410":"code","b9231cf3":"code","77953ec0":"code","48ce94f3":"code","0bfe4f8a":"markdown"},"source":{"c1c20b68":"from tqdm import tqdm\nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import GroupKFold","81a55c13":"n_splits=5\nnrows = None","468e7546":"df = pd.read_csv(\"..\/input\/jigsaw-toxic-severity-rating\/validation_data.csv\", nrows=nrows)\ntexts = set(df.less_toxic.to_list() + df.more_toxic.to_list())\ntext2id = {t:id for id,t in enumerate(texts)}\ndf['less_id'] = df['less_toxic'].map(text2id)\ndf['more_id'] = df['more_toxic'].map(text2id)\ndf","6281a410":"# Set array to store pair information\nlen_ids = len(text2id)\nidarr = np.zeros((len_ids,len_ids), dtype=bool)\n\nfor lid, mid in df[['less_id', 'more_id']].values:\n    min_id = min(lid, mid)\n    max_id = max(lid, mid)\n    idarr[max_id, min_id] = True","b9231cf3":"# Recursively retrieve the text that is paired with the text whose id is i,\n# and store it's id in this_list.\n# then set idarr[i, j] to False\ndef add_ids(i, this_list):\n    for j in range(len_ids):\n        if idarr[i, j]:\n            idarr[i, j] = False\n            this_list.append(j)\n            this_list = add_ids(j,this_list)\n            #print(j,i)\n    for j in range(i+1,len_ids):\n        if idarr[j, i]:\n            idarr[j, i] = False\n            this_list.append(j)\n            this_list = add_ids(j,this_list)\n            #print(j,i)\n    return this_list\n\ngroup_list = []\nfor i in tqdm(range(len_ids)):\n    for j in range(i+1,len_ids):\n        if idarr[j, i]:\n            this_list = add_ids(i,[i])\n            #print(this_list)\n            group_list.append(this_list)\n\nid2groupid = {}\nfor gid,ids in enumerate(group_list):\n    for id in ids:\n        id2groupid[id] = gid\n\ndf['less_gid'] = df['less_id'].map(id2groupid)\ndf['more_gid'] = df['more_id'].map(id2groupid)\ndf","77953ec0":"print('unique text counts:', len_ids)\nprint('grouped text counts:', len(group_list))","48ce94f3":"# now we can use GroupKFold with group id\ngroup_kfold = GroupKFold(n_splits=n_splits)\n\n# Since df.less_gid and df.more_gid are the same, let's use df.less_gid here.\nfor fold, (trn, val) in enumerate(group_kfold.split(df, df, df.less_gid)): \n    df.loc[val , \"fold\"] = fold\n\ndf[\"fold\"] = df[\"fold\"].astype(int)\ndf","0bfe4f8a":"In order to avoid leaks, the same text needs to be put into same Folds.  \nFor a single document this is easy, but for a pair of documents to both be in same folds is a bit tricky.  \n\nThis simple notebook tracks pairs of text recursively to group them and try to create a leak-free Fold split."}}