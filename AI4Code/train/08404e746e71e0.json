{"cell_type":{"15ba6a6f":"code","9c45c3d4":"code","49d414c0":"code","f8f7d111":"code","d76d80a2":"code","c12498b5":"code","350ab292":"code","edc8bbcb":"code","913d91f8":"code","d2875d21":"code","53046db0":"code","0c22f7cd":"code","b84f94ef":"code","5505ea7a":"code","4e2be721":"code","d5619756":"code","3f94ecad":"code","4ef25ab6":"code","db4a0b5a":"code","e8f2c9d4":"code","28d7e513":"code","29445984":"code","8da3e9e7":"code","976a5b5c":"code","978302b8":"code","394cc803":"code","f5320eb9":"code","9046ba44":"code","726ef8ea":"code","639c08d8":"code","9bfcfb08":"code","d9a97b92":"code","63e12b08":"code","d2763f27":"code","40586406":"code","d65de79a":"code","87fa9339":"code","5392abb4":"code","239fa4f8":"code","e6d5dd94":"code","4f836a66":"code","4943bebf":"code","3647dbd8":"code","6a1a449c":"code","7f278383":"code","0c88abd4":"code","b62877ff":"code","44c4bbd8":"code","49b989fe":"code","c61c9634":"code","2ab4ad22":"code","78bafb48":"code","eb7ae2f5":"code","a2a584f3":"code","1dd499c7":"code","c2dc8ee9":"code","a0c995cd":"code","5f175611":"code","3c8283eb":"code","e3b967a7":"code","0ab1fbaa":"code","2d0c7071":"markdown","9cf81760":"markdown","73358493":"markdown","c1166591":"markdown","f0fb010d":"markdown","61739ffa":"markdown","9feca5a2":"markdown","ca575457":"markdown","5c9ebeca":"markdown","f0a9947b":"markdown","f492165e":"markdown","651eff34":"markdown","1cce1661":"markdown","bef7a300":"markdown","ebb066de":"markdown","a0fa02f6":"markdown","1839bfef":"markdown","55ecbfcc":"markdown","1cabaec0":"markdown"},"source":{"15ba6a6f":"grph = True\nkaggle = True\n\nimport os\nimport zipfile\nimport pandas as pd\nimport numpy as np\n#import time\n#import geopy\n#from geopy import distance\n\nimport random\n\n#from sklearn import linear_model\n#from sklearn.ensemble import RandomForestRegressor\n#from sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.metrics import mean_squared_error, r2_score\n\nimport math\nfrom math import sqrt\n\nimport pickle\n\nimport lightgbm as lgb\n\nif grph:\n    import matplotlib.pyplot as plt\n    import folium","9c45c3d4":"pd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\npd.set_option('display.max_colwidth', -1)\n\npd.set_option('mode.chained_assignment','raise')","49d414c0":"if not kaggle:\n    os.chdir(\"C:\/...\")","f8f7d111":"def read_files(chunks = 1100, chunk_no = None):\n    random.seed(42)\n\n    #chunks = 5500 # 10000\n    #chunks = 1100 # 50 000\n    #chunks = 550 # 100 000\n    #chunks = 220 # 250 000\n    #chunks = 55 # 1 000 000\n    #chunks = 11 # 5 000 000\n\n    nrows = int( 55423857 \/ chunks )\n\n    def skiprows(x):\n        if x == 0:\n            return False\n        return chunk_no != random.randrange(chunks)\n\n    if kaggle:\n        df = pd.read_csv('..\/input\/train.csv', nrows = nrows, parse_dates=[\"pickup_datetime\"])\n    else:\n        with zipfile.ZipFile('all.zip') as zipf: \n            with zipf.open('train.csv') as myZip:\n                if chunk_no == None:\n                    df = pd.read_csv(myZip,nrows=nrows,parse_dates=[\"pickup_datetime\"])\n                else:\n                    df = pd.read_csv(myZip,skiprows=skiprows,parse_dates=[\"pickup_datetime\"])\n\n    random.seed(42)\n    df = df.sample(frac=1).reset_index(drop=True) #Random reshuffle\n    \n    if kaggle:\n        df_test = pd.read_csv('..\/input\/test.csv', nrows = nrows, parse_dates=[\"pickup_datetime\"])\n    else:\n        with zipfile.ZipFile('all.zip') as zipf: \n            with zipf.open('test.csv') as myZip:\n                df_test = pd.read_csv(myZip,parse_dates=[\"pickup_datetime\"])\n                \n    return df, df_test","d76d80a2":"chunks = 200","c12498b5":"df,df_test = read_files(chunks)","350ab292":"df.head()","edc8bbcb":"df.describe()","913d91f8":"df_test.head()","d2875d21":"def calculate_distance(data):\n    \n# https:\/\/stackoverflow.com\/questions\/19412462\/getting-distance-between-two-points-based-on-latitude-longitude\n    for df in data:\n        R=6371.0\n        pi=math.pi\n\n        df_tmp = df.eval(\"\"\"\n        lat1 = @pi \/ 180. * pickup_latitude\n        lon1 = @pi \/ 180. * pickup_longitude\n        lat2 = @pi \/ 180. * dropoff_latitude\n        lon2 = @pi \/ 180. * dropoff_longitude\n\n        dlon = lon2 - lon1\n        dlat = lat2 - lat1\n\n        a = sin(dlat \/ 2)**2 + cos(lat1) * cos(lat2) * sin(dlon \/ 2)**2\n        c = 2 * arctan2(sqrt(a), sqrt(1 - a))\n\n        distance = @R * c\n        \"\"\",inplace=False)\n        df['dist'] = df_tmp['distance']\n        df['dist2'] = df_tmp['distance'] * df_tmp['distance'] \n    return data","53046db0":"# geopy.distance.distance((-74.1, 40.),(-74., 40.)).km # 11.160876733592401\n# geopy.distance.distance((-74., 40.1),(-74., 40.)).km # 3.077915051090274\n\nlong_km = .1 \/ 11.160876733592401\nlat_km = .1 \/ 3.077915051090274\n\ndef is_airport(data):\n    for df in data:\n        df[\"is_jfk_pickup\"] = False\n        df.loc[df.eval(\n            '(-73.778889 - 2*@long_km < pickup_longitude < -73.778889 + 2*@long_km)\\\n            &\\\n            (40.639722 - 1*@lat_km < pickup_latitude < 40.639722 + .5*@lat_km)')\n               ,\"is_jfk_pickup\"] = True\n\n        df[\"is_ewr_pickup\"] = False\n        df.loc[df.eval(\n            '(-74.168611 - 2*@long_km < pickup_longitude < -74.168611 + 2*@long_km)\\\n            &\\\n            (40.6925 - 1*@lat_km < pickup_latitude < 40.6925 + 1*@lat_km)')\n               ,\"is_ewr_pickup\"] = True\n\n        df[\"is_lga_pickup\"] = False\n        df.loc[df.eval(\n            '(-73.872611 - 1.4*@long_km < pickup_longitude < -73.872611 + 1.5*@long_km)\\\n            &\\\n            (40.77725 - .3*@lat_km < pickup_latitude < 40.77725 + .3*@lat_km)')\n               ,\"is_lga_pickup\"] = True\n\n        \n        df[\"is_jfk_dropoff\"] = False\n        df.loc[df.eval(\n            '(-73.778889 - 2*@long_km < dropoff_longitude < -73.778889 + 2*@long_km)\\\n            &\\\n            (40.639722 - 1*@lat_km < dropoff_latitude < 40.639722 + .5*@lat_km)')\n               ,\"is_jfk_dropoff\"] = True\n\n        df[\"is_ewr_dropoff\"] = False\n        df.loc[df.eval(\n            '(-74.168611 - 2*@long_km < dropoff_longitude < -74.168611 + 2*@long_km)\\\n            &\\\n            (40.6925 - 1*@lat_km < dropoff_latitude < 40.6925 + 1*@lat_km)')\n               ,\"is_ewr_dropoff\"] = True\n\n        df[\"is_lga_dropoff\"] = False\n        df.loc[df.eval(\n            '(-73.872611 - 1.4*@long_km < dropoff_longitude < -73.872611 + 1.5*@long_km)\\\n            &\\\n            (40.77725 - .3*@lat_km < dropoff_latitude < 40.77725 + .3*@lat_km)')\n               ,\"is_lga_dropoff\"] = True\n    return data\n\n","0c22f7cd":"df,df_test = calculate_distance([df,df_test])","b84f94ef":"df,df_test = is_airport([df,df_test])","5505ea7a":"def is_business_day(date):\n    return bool(len(pd.bdate_range(date, date)))\n\ndef time_related_vars(data):\n    for df in data:\n        #df['bday'] = df['pickup_datetime'].apply(is_business_day)\n        #df['bday'] = bool(len(pd.bdate_range(df['pickup_datetime'].value(), df['pickup_datetime'].value())))\n        df['weekday'] = df['pickup_datetime'].dt.weekday # The day of the week with Monday=0, Sunday=6\n        df['day'] = df['pickup_datetime'].dt.day\n        df['hour'] = df['pickup_datetime'].dt.hour\n        df['month'] = df['pickup_datetime'].dt.month\n        df['year'] = df['pickup_datetime'].dt.year\n        df['daytime'] = False\n        df.loc[(df.hour >= 8)&(df.hour < 20),'daytime'] = True \n        #df['businesstime'] = False\n        #df.loc[df.daytime&df.bday,'businesstime'] = True \n        #df['time_stamp'] = df['year'].astype('str') + '-' + df['month'].astype('str') + '-' + df['day'].astype('str')\n        df['time_stamp'] = df['year'].astype('str') + '-' + df['month'].astype('str') + '-' + df['day'].astype('str') + ':' + df['hour'].astype('str')\n    return data","4e2be721":"df,df_test = time_related_vars((df,df_test))","d5619756":"# Free inspiration from\n# https:\/\/www.kaggle.com\/nicapotato\/taxi-rides-time-analysis-and-oof-lgbm\ngrp = df.groupby('time_stamp',as_index=False)['fare_amount'].agg(['sum','mean','std','skew','count']).reset_index()\ndf = df.merge(grp, how='left', on=['time_stamp'])\ndf_test = df_test.merge(grp, how='left', on=['time_stamp'])","3f94ecad":"def basic_fare():\n    df['min_fare'] = 2.5 + 0.5 * 5 * df.dist \/ 1.6\n    df_test['min_fare'] = 2.5 + 0.5 * 5 * df_test.dist \/ 1.6\n    df['min_multiple'] = df['fare_amount'] \/ df['min_fare']","4ef25ab6":"basic_fare()","db4a0b5a":"if not kaggle:\n    df.to_pickle('df.pkl')\n    df_test.to_pickle('df_test.pkl')","e8f2c9d4":"if not kaggle:\n    df = pd.read_pickle('df.pkl')\n    df_test = pd.read_pickle('df_test.pkl')","28d7e513":"df.dropna(inplace=True)\n\ndf.drop(df.index[(df.pickup_longitude < -75) | \n           (df.pickup_longitude > -72) | \n           (df.pickup_latitude < 40) | \n           (df.pickup_latitude > 42)],inplace=True)\ndf.drop(df.index[(df.dropoff_longitude < -75) | \n           (df.dropoff_longitude > -72) | \n           (df.dropoff_latitude < 40) | \n           (df.dropoff_latitude > 42)],inplace=True)","29445984":"df.nlargest(100,'fare_amount')","8da3e9e7":"df.nsmallest(100,'fare_amount')","976a5b5c":"if grph:\n    df[['fare_amount', 'dist']].plot.scatter(x='dist',y='fare_amount')","978302b8":"# drop all x more expensive than it should be. No problem with airports, it easily fits:\n# Initial fare $2.5 + $0.5 per 1\/5 mile\nmax_fare_multiple = 20\nmin_fare_multiple = 0.05","394cc803":"drop_too_expensive = df.index[(df.fare_amount > ( max_fare_multiple * ( 2.5 + 0.5 * 5 * df.dist \/ 1.6 )))] \nprint(\"n_dropped={}, {}%\".format(len(drop_too_expensive),len(drop_too_expensive)\/len(df)))\ndf.drop(drop_too_expensive,inplace=True)","f5320eb9":"# And of the minimum\ndrop_too_cheap = df.index[df.fare_amount < ( min_fare_multiple * ( 2.5 + 0.5 * 5 * df.dist \/ 1.6 ))] \nprint(\"n_dropped={}, {}%\".format(len(drop_too_cheap),len(drop_too_cheap)\/len(df)))\ndf.drop(drop_too_cheap,inplace=True)","9046ba44":"if grph:\n    df[['fare_amount', 'dist']].plot.scatter(x='dist',y='fare_amount')","726ef8ea":"#from folium.plugins import FastMarkerCluster\n\ndef plot_map(df=df, maxpoints=200,showlines=False):\n    if not grph:\n        return None\n    m = folium.Map(\n        location=[df[\"pickup_latitude\"].median(), df[\"pickup_longitude\"].median()],\n        zoom_start=12)\n\n    for index, row in enumerate(list(zip(df[\"pickup_latitude\"].values, df[\"pickup_longitude\"].values))):\n        folium.CircleMarker(location=row, radius=2, weight=1, color='green').add_to(m)\n        if index == maxpoints:\n            break\n\n    for index, row in enumerate(list(zip(df[\"dropoff_latitude\"].values, df[\"dropoff_longitude\"].values))):\n        folium.CircleMarker(location=row, radius=2, weight=1, color='red').add_to(m)\n        if index == maxpoints:\n            break\n\n            \n    if showlines:\n        for index, row in enumerate(list(\n            zip(zip(df[\"dropoff_latitude\"].values, df[\"dropoff_longitude\"].values),\n                zip(df[\"pickup_latitude\"].values, df[\"pickup_longitude\"].values)))):\n            #folium.CircleMarker(location=row, radius=2, weight=1, color='red').add_to(m)\n            #print(index,row)\n            folium.PolyLine(row, color=\"blue\", weight=1, opacity=0.5).add_to(m)\n            if index == maxpoints:\n                break\n            \n    return m\n                ","639c08d8":"plot_map(df_test,80,True)","9bfcfb08":"if grph:\n    plt.figure();\n    df.dist.plot.hist(bins=50, range=(0,100))\n    plt.figure();\n    df_test.dist.plot.hist(bins=50,range=(0,100))","d9a97b92":"if grph:\n    plt.figure();\n    df.dist.plot.hist(bins=50, range=(0,25))\n    plt.figure();\n    df_test.dist.plot.hist(bins=50,range=(0,25))","63e12b08":"df.pickup_datetime.describe()","d2763f27":"df_test.pickup_datetime.describe()","40586406":"if grph:\n    df[['fare_amount','weekday']].boxplot(by='weekday',showfliers=False)\n# df[['fare_amount','bday']].boxplot(by='bday',showfliers=False)","d65de79a":"# df[['dist','businesstime']].boxplot(by='businesstime',showfliers=False)\n# df[['fare_amount','businesstime']].boxplot(by='businesstime',showfliers=False)","87fa9339":"if grph:\n    df[['dist','hour']].boxplot(by='hour',showfliers=False)\n    df[['fare_amount','hour']].boxplot(by='hour',showfliers=False)","5392abb4":"if grph:\n    df[['dist','month']].boxplot(by='month',showfliers=False)\n    df[['fare_amount','month']].boxplot(by='month',showfliers=False)","239fa4f8":"df.head()","e6d5dd94":"df.describe()","4f836a66":"# Solver cannot run with time, needs to have fload.\ndf['float_pickup_datetime'] = df['pickup_datetime'].values.astype('float')\ndf_test['float_pickup_datetime'] = df_test['pickup_datetime'].values.astype('float')","4943bebf":"# Random split to train and test\ndftr = df.sample( frac = 0.8, random_state=42)\ndfval = df.drop( dftr.index)","3647dbd8":"# This way interativelly trial and error select a good set of features.\nll = ['passenger_count','dist','bday','weekday','hour','daytime','businesstime','month','pickup_longitude','pickup_latitude','dropoff_longitude','dropoff_latitude','lat_diff','long_diff']\nll = ['dist'] # 4.971843085485664\nll = ['passenger_count','dist'] # 4.978781923333827 -> not important\nll = ['dist','bday'] # 4.938947744089244 -> OK\nll = ['dist','bday','weekday'] # 4.910031675409393 -> OK\nll = ['dist','bday','weekday','hour'] # 4.837025815294643 -> OK\nll = ['dist','bday','weekday','hour','daytime'] # 4.759085591019987 -> OK\nll = ['dist','bday','weekday','hour','businesstime'] # 4.804090429646956 -> Not OK\nll = ['dist','bday','weekday','hour','daytime','businesstime'] # 4.79580778655997 -> OK\nll = ['dist','month'] # 4.955495881088339 -> OK\nll = ['dist','bday','weekday','hour','daytime','month'] # 4.706722506235075 -> OK\n\nll = ['dist','bday','weekday','hour','daytime','month','pickup_longitude','pickup_latitude','dropoff_longitude','dropoff_latitude'] # 4.284077318471638 -> OK\n\nll = ['dist','bday','weekday','hour','daytime','month','pickup_longitude','pickup_latitude','dropoff_longitude','dropoff_latitude','lat_diff','long_diff'] # 4.315628577392338 -> Not OK\n\n\nll = ['dist','bday','weekday','hour','daytime','month','lat_avg','long_avg','lat_diff','long_diff']\n\nll = ['dist','bday','weekday','hour','daytime','month','pickup_longitude','pickup_latitude','dropoff_longitude','dropoff_latitude'] # 4.284077318471638 -> OK\n\nll = ['dist','dist2','weekday','hour','daytime','year','month','pickup_longitude','pickup_latitude','dropoff_longitude','dropoff_latitude',\n'is_jfk_pickup', 'is_ewr_pickup', 'is_lga_pickup', 'is_jfk_dropoff', 'is_ewr_dropoff', 'is_lga_dropoff']\n\nll = ['dist','dist2','float_pickup_datetime', 'weekday','hour','daytime','year','month','pickup_longitude',\n      'pickup_latitude','dropoff_longitude','dropoff_latitude','is_jfk_pickup', 'is_ewr_pickup',\n      'is_lga_pickup', 'is_jfk_dropoff', 'is_ewr_dropoff', 'is_lga_dropoff',\n      'sum','mean','std','skew','count']\n\n","6a1a449c":"ntr = len(dftr['dist'])\nnval = len(dfval['dist'])\nnte = len(df_test['dist'])\n#ntotal = len(df['dist'])\n\nXtr = pd.DataFrame(dftr[ll]).values.reshape(ntr, len(ll))\nXval = pd.DataFrame(dfval[ll]).values.reshape(nval, len(ll))\nXte = pd.DataFrame(df_test[ll]).values.reshape(nte, len(ll))\n#Xtotal = pd.DataFrame(df[ll]).values.reshape(ntotal, len(ll))\n\n# We will actually learn min_multiple, as it is at the first approximaton constant \nYtr = dftr['min_multiple'].values\nYval = dfval['min_multiple'].values","7f278383":"# https:\/\/lightgbm.readthedocs.io\/en\/latest\/Python-API.html\n# Good parameters are data size dependent. Should be found e.g. by grid search\nmax_bin = 2*255\ngbm = lgb.LGBMRegressor(n_estimators=10000, silent=False, max_bin=max_bin)","0c88abd4":"parameters = gbm.fit( Xtr, Ytr )","b62877ff":"if not kaggle:\n    pickle.dump(gbm, open('model.pkl', 'wb'))","44c4bbd8":"if not kaggle:\n    gbm = pickle.load(open('model.pkl', 'rb'))","49b989fe":"Ytest = gbm.predict(Xte)","c61c9634":"df_test['fare_amount'] = pd.Series(Ytest) * df_test['min_fare']\ndf_test[['key','fare_amount']].to_csv('submission.csv',index=False)","2ab4ad22":"# Print some statistics\nprint(\"FARE MULTIPLE, LGBM\")\nprint(parameters)\nprint(ll)\nprint(\"df size: {}\".format(len(df)))\nprint(\"chunks: {}\".format(chunks))\nprint(\"max bin: {}\".format(max_bin))\nprint(\"min,max_fare_multiple {} {}\".format(min_fare_multiple,max_fare_multiple))","78bafb48":"Ytr_hat = gbm.predict(Xtr)\nYval_hat = gbm.predict(Xval)\n# Ytotal = gbm.predict(Xtotal)","eb7ae2f5":"# df['fare_predicted'] = pd.Series(Ytotal) * df['min_fare']\ndftr['fare_predicted'] = pd.Series(Ytr) * dftr['min_fare']\ndfval['fare_predicted'] = pd.Series(Yval) * dfval['min_fare']\n\n\n#df['fare_err'] = (df['fare_amount'] - df['fare_predicted']).abs()\ndftr['fare_err'] = (dftr['fare_amount'] - dftr['fare_predicted']).abs()\ndfval['fare_err'] = (dfval['fare_amount'] - dfval['fare_predicted']).abs()","a2a584f3":"rms_tr = (dftr['fare_err']**2).mean()**.5\nprint( \"Accuracy training: \", rms_tr)","1dd499c7":"rms_val = (dfval['fare_err']**2).mean()**.5\nprint( \"Accuracy2: \", rms_val)","c2dc8ee9":"err100 = dfval.nlargest(100,'fare_err')\nerr100.to_csv('100errval.csv')","a0c995cd":"err100.head()","5f175611":"plot_map(err100,100,True)","3c8283eb":"if grph:\n    plt.figure();\n    dftr.fare_err.plot.hist(bins=50, range=(0,25))\n    plt.figure();\n    dfval.fare_err.plot.hist(bins=50, range=(0,25))","e3b967a7":"if grph:\n    dftr[['fare_err', 'dist']].plot.scatter(x='dist',y='fare_err')","0ab1fbaa":"if grph:\n    dfval[['fare_err', 'dist']].plot.scatter(x='dist',y='fare_err')","2d0c7071":"## Feedback how it went and what was mispredicted...","9cf81760":"# Feature visualization\nThere must be a dependence of the fare on the feature. Othervise the feature won't have a predictive power... Let's review one by one...","73358493":"...and save, what we have.","c1166591":"...looks like from 20:00 to 7:00 people tend to take longer rides than during the daytime","f0fb010d":"# Remove outliers\n## GPS outliers\nSome data are with mistakes - looking at the test data, interval [40,42] and [-75,-72] should be more than OK. \nAlso remove NaNs.","61739ffa":"# Feature development\nHere, we will create some basic features for the dataset. We will visualize them in later section.","9feca5a2":"# Intro","ca575457":"One more thing - let's plot training and test data histograms","5c9ebeca":"# Numerical method\nWe will not train fare prediction directly, but we will train functon 'a' in 'fare = a * distance'. In this case, even a constant value of 'a' would give a reasonable result.","f0a9947b":"# Look at the data\nFirst, we will need some plotting routine.\n* Green are pick-up locations\n* Red are drop-offs","f492165e":"## Useful time related variables\nEsential features of the time dependent data set. Also, create time stamp, which is day + hour, and calculate average (count, median etc) fare for given hour.","651eff34":"...looks roughly the same. Let's zoom in...","1cce1661":"## Fare amount outliers","bef7a300":"Let's get some idea, what the test data are about:","ebb066de":"* This kernel assumes fare in form of 'fare = a() * distance', where the function 'a()' is to be fitted\n* Data cleaning, features visualization\n* Solver uses the gradient boosting tree with LightGBM library\n* Visualization of the data and error are provided to get some insights","a0fa02f6":"## Distance + flag of ride from\/to airport","1839bfef":"## Basic fare\nThis is the very basic fare to be paid: \\$2.5 + \\$0.5 per 1\/5 of the mile","55ecbfcc":"Check time: Is the test from the same period as the training data???","1cabaec0":"# Read the training file, test file\nFirst, download all the files from the kaggle web site zipped into `all.zip`. \n* We will read only portion of the training file at once, randomly splitting the training file into multiple chunks. The training file will be then randomly reshuffled alowing easy plot of representative samples.  \n* The test file will be read whole. "}}