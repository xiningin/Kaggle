{"cell_type":{"f844c2d7":"code","56431445":"code","b1b9ef21":"code","df1f4e6e":"code","79c8400f":"code","dca07c30":"code","f9c2e36e":"code","5e42a97c":"code","889e2479":"code","09998c96":"code","bf032aff":"code","39ba0b04":"code","533d906d":"code","fe1adc45":"code","8c2429d4":"code","d6fab7be":"code","886d6716":"code","6b4c62b4":"code","bd8a2e81":"code","3a3ab9cb":"code","6b86b7d1":"code","6e2bc2ea":"code","b21df9d8":"code","3af98c79":"code","88f04108":"code","77971230":"code","af9ec2ce":"code","e864250b":"code","9f2b56e4":"code","31f9749d":"code","9844401e":"code","bb46b53d":"code","cfee70c0":"code","4d3b898b":"code","adeb7586":"code","7dc4f02e":"markdown","abbdf201":"markdown","9cf08edd":"markdown","ad7d7c41":"markdown","5ab6b8e1":"markdown","c7f9a239":"markdown","002438be":"markdown","68bf9a7b":"markdown","f94c2fa9":"markdown","339e1569":"markdown","37a0af43":"markdown","d26b97dc":"markdown","c05da71c":"markdown","0111425c":"markdown","f16d4076":"markdown","1645f4d9":"markdown","6950d2a0":"markdown","bdbc4797":"markdown","c3604787":"markdown"},"source":{"f844c2d7":"from collections import Counter\nfrom functools import reduce\nimport operator\nfrom bisect import bisect_left\n\nimport numpy as np\nimport pandas as pd\n\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\n\npd.options.display.max_rows = 500\npd.set_option('display.max_colwidth', None)","56431445":"orders = pd.read_csv('order_brush_order.csv')","b1b9ef21":"orders.head()","df1f4e6e":"orders.info()","79c8400f":"for col in orders:\n    print(f'{col} nunique: ',orders[col].nunique())\n    \nfor col in orders:\n    print(f'{col} duplicated: ',sum(orders[col].duplicated()))","dca07c30":"orders.head()","f9c2e36e":"orders[orders.groupby('shopid').event_time.apply(pd.Series.duplicated,keep=False)].sort_values('event_time')","5e42a97c":"orders['event_time'] = pd.to_datetime(orders['event_time']) # to ensure proper sorting, not necessary but to be safe","889e2479":"orders.dtypes","09998c96":"# sort for easy debugging when comparing against kaggle examples \norders_sorted = orders.sort_values(['shopid','event_time'])\norders_sorted.head(100)","bf032aff":"# good for preventing repeated time spent on groupby, but cannot slice groupby object to estimate time during full run\nshop_gb = orders_sorted.groupby(['shopid'])  ","39ba0b04":"test_cases = {1:8996761,\n              2:27121667,\n              3:145777302,\n              4:181009364\n             }\n\norder_shop = shop_gb.get_group(test_cases[3])\n\n# imagine order_shop df is passed in to this apply func\nevent_times = order_shop['event_time'].values\narray_length = len(event_times)\ncounter_list = []\n\n\nfor start_idx, start_time in enumerate(event_times[:-2]):\n    counts_for_start_time = {}\n    \n    max_end_time = start_time + np.timedelta64(1, 'h')   # prepare to find elements within this right bound of time\n    max_end_idx = bisect_left(event_times, max_end_time) - 1    # find largest idx within time bound, this will be largest possible window for current start_time\n    \n    if max_end_idx < start_idx + 2:\n        continue # no need to continue if cannot form at least 3 rows\n    \n    \n    if start_idx:  \n        left_timeshift_possible = start_time - event_times[start_idx-1]  # can be handled by df.diff outside apply\n        min_end_time = max_end_time - left_timeshift_possible  \n        \n        # smallest window begins at 3 rows minimum, or idx of largest time less than min_end_time \n        min_end_idx = max(start_idx + 2, bisect_left(event_times, min_end_time)-1) \n\n        print('start: {}  min_end: {}  max_end: {}'.format(start_idx,min_end_idx,max_end_idx))\n    else:\n        min_end_idx = start_idx + 2\n    \n    for window_tail_idx in range(min_end_idx, max_end_idx + 1):\n        current_window = order_shop.iloc[start_idx: window_tail_idx+1] #iloc excludes right edge\n        concentration_ratio = len(current_window)\/current_window['userid'].nunique()\n        \n        if concentration_ratio >= 3: \n\n            counts_for_start_time.update(dict(current_window['userid'].value_counts()))\n            \n            event_times[start_idx-1]\n            event_times[window_tail_idx+1]\n            current_window\n            counts_for_start_time\n        \n    # prevent appending empty counts_for_start_time (for clean debugging prints, doesn't affect Counter summation later)\n    if counts_for_start_time:\n        counter_list.append(Counter(counts_for_start_time))  # prepare Counter type for accumulation later\n        counter_list\n            \n                \nif counter_list:  # if not empty [{}] for shops with no brushing:\n    reduced_counter_list = reduce(operator.add,counter_list)\n    reduced_counter_list\n    max_value = max(reduced_counter_list.values())\n    users = sorted(user for user,count in reduced_counter_list.items() if count == max_value)\n    print('FINAL ANSWER BELOW')\n    '&'.join(map(str,users))\nelse:\n    '0'","533d906d":"test_cases = {1:8996761,\n              2:27121667,\n              3:145777302,\n              4:181009364\n             }\n\norder_shop = shop_gb.get_group(test_cases[3])\n\n# imagine order_shop df is passed in to this apply func\nevent_times = order_shop['event_time'].values\narray_length = len(event_times)\ncounter_list = []\n\n\nfor start_idx, start_time in enumerate(event_times[:-2]):\n    \n    max_end_time = start_time + np.timedelta64(1, 'h')   # prepare to find elements within this right bound of time\n    max_end_idx = bisect_left(event_times, max_end_time) - 1    # find largest idx within time bound, this will be largest possible window for current start_time\n    \n    if max_end_idx < start_idx + 2:\n        continue # no need to continue if cannot form at least 3 rows\n    \n    \n    if start_idx:  \n        left_timeshift_possible = start_time - event_times[start_idx-1]  # can be handled by df.diff outside apply\n        min_end_time = max_end_time - left_timeshift_possible  \n        \n        # smallest window begins at 3 rows minimum, or idx of largest time less than min_end_time \n        min_end_idx = max(start_idx + 2, bisect_left(event_times, min_end_time)-1) \n\n        print('start: {}  min_end: {}  max_end: {}'.format(start_idx,min_end_idx,max_end_idx))\n    else:\n        min_end_idx = start_idx + 2\n    \n    for window_tail_idx in range(min_end_idx, max_end_idx + 1):\n        current_window = order_shop.iloc[start_idx: window_tail_idx+1] #iloc excludes right edge\n        concentration_ratio = len(current_window)\/current_window['userid'].nunique()\n        \n        if concentration_ratio >= 3: \n            counter_list.append(Counter(current_window['userid']))\n            \n            event_times[start_idx-1]\n            event_times[window_tail_idx+1]\n            current_window\n        \n                \nif counter_list:  # if not empty [{}] for shops with no brushing:\n    reduced_counter_list = reduce(operator.add,counter_list)\n    reduced_counter_list\n    max_value = max(reduced_counter_list.values())\n    users = sorted(user for user,count in reduced_counter_list.items() if count == max_value)\n    print('FINAL ANSWER BELOW')\n    '&'.join(map(str,users))\nelse:\n    '0'","fe1adc45":"test_cases = {1:8996761,\n              2:27121667,\n              3:145777302,\n              4:181009364\n             }\n\norder_shop = shop_gb.get_group(test_cases[1])\n\n# imagine order_shop df is passed in to this apply func\nevent_times = order_shop['event_time'].values\narray_length = len(event_times)\nuser_set = set()\n\n\nfor start_idx, start_time in enumerate(event_times[:-2]):\n    \n    max_end_time = start_time + np.timedelta64(1, 'h')   # prepare to find elements within this right bound of time\n    max_end_idx = bisect_left(event_times, max_end_time) - 1    # find largest idx within time bound, this will be largest possible window for current start_time\n    \n    start_idx, max_end_idx\n    \n    if max_end_idx < start_idx + 2:\n        print('skip')\n        continue # no need to continue if cannot form at least 3 rows\n    \n    start_idx,max_end_idx\n    \n    if start_idx:  \n        left_timeshift_possible = start_time - event_times[start_idx-1]  # can be handled by df.diff outside apply\n        min_end_time = max_end_time - left_timeshift_possible  \n        \n        # smallest window begins at 3 rows minimum, or idx of largest time less than min_end_time \n        min_end_idx = max(start_idx + 2, bisect_left(event_times, min_end_time) - 1) \n\n        print('min_end: {} max_end: {}'.format(min_end_idx,max_end_idx))\n    else:\n        min_end_idx = start_idx + 2\n    \n    for window_tail_idx in range(min_end_idx, max_end_idx + 1):\n        current_window = order_shop.iloc[start_idx: window_tail_idx+1] #iloc excludes right edge\n        concentration_ratio = len(current_window)\/current_window['userid'].nunique()\n        \n        if concentration_ratio >= 3: \n            current_window_counts = Counter(current_window['userid'])\n\n            max_value = max(current_window_counts.values())\n            user_set.update(user for user, count in current_window_counts.items() if count ==  max_value)\n            \n            current_window\n            current_window_counts\n                \nif user_set:  # if not empty [{}] for shops with no brushing:\n    users = sorted(user_set)\n    print(users)\n    print('FINAL ANSWER BELOW')\n    '&'.join(map(str,users))\nelse:\n    '0'\n    \n    # ADD RETURN STATEMENT WHEN PASTING INTO FUNCTION","8c2429d4":"test_cases = {1:8996761,\n              2:27121667,\n              3:145777302,\n              4:181009364,\n              5:155143347,\n              6:156883302\n             }\n\norder_shop = shop_gb.get_group(test_cases[6])\n\n# imagine order_shop df is passed in to this apply func\nevent_times = order_shop['event_time'].values\narray_length = len(event_times)\ncounter_list = []\n\n\nfor start_idx, start_time in enumerate(event_times[:-2]):\n    counts_for_start_time = {}\n    \n    max_end_time = start_time + np.timedelta64(1, 'h')   # prepare to find elements within this right bound of time\n    max_end_idx = bisect_left(event_times, max_end_time) - 1    # find largest idx within time bound, this will be largest possible window for current start_time\n    \n    if max_end_idx < start_idx + 2:\n        continue # no need to continue if cannot form at least 3 rows\n    \n    \n    if start_idx:  \n        left_timeshift_possible = start_time - event_times[start_idx-1]  # can be handled by df.diff outside apply\n        min_end_time = max_end_time - left_timeshift_possible  \n\n        bisected_idx = bisect_left(event_times, min_end_time)\n        # short-circuit prevents IndexError when event_times[bisected_idx] after or \n        if bisected_idx == array_length or event_times[bisected_idx] >  min_end_time:\n            bisected_idx -= 1\n            while bisected_idx > start_idx+2 and event_times[bisected_idx-1] == event_times[bisected_idx]: \n                bisected_idx -= 1\n        # smallest window begins at 3 rows minimum, or idx of largest time less than min_end_time \n        min_end_idx = max(start_idx + 2,bisected_idx) \n    #   print('start: {}  min_end: {}  max_end: {}'.format(start_idx,min_end_idx,max_end_idx))\n    else:\n        min_end_idx = start_idx + 2\n    \n    for window_tail_idx in range(min_end_idx, max_end_idx + 1):\n        current_window = order_shop.iloc[start_idx: window_tail_idx+1] #iloc excludes right edge\n        concentration_ratio = len(current_window)\/current_window['userid'].nunique()\n        \n        if concentration_ratio >= 3: \n\n            counts_for_start_time.update(dict(current_window['userid'].value_counts()))\n            \n            event_times[start_idx-1]\n            event_times[window_tail_idx+1]\n            current_window\n            counts_for_start_time\n        \n    # prevent appending empty counts_for_start_time (for clean debugging prints, doesn't affect Counter summation later)\n    if counts_for_start_time:\n        counter_list.append(Counter(counts_for_start_time))  # prepare Counter type for accumulation later\n        counter_list\n            \n                \nif counter_list:  # if not empty [{}] for shops with no brushing:\n    reduced_counter_list = reduce(operator.add,counter_list)\n    reduced_counter_list\n    max_value = max(reduced_counter_list.values())\n    users = sorted(user for user,count in reduced_counter_list.items() if count == max_value)\n    print('FINAL ANSWER BELOW')\n    '&'.join(map(str,users))\nelse:\n    '0'","d6fab7be":"test_cases = {1:8996761,\n              2:27121667,\n              3:145777302,\n              4:181009364,\n              5:155143347,\n              6:156883302\n             }\n\norder_shop = shop_gb.get_group(test_cases[5])\n\n# imagine order_shop df is passed in to this apply func\nevent_times = order_shop['event_time'].values\narray_length = len(event_times)\n\norder_user = {}\n\nfor start_idx, start_time in enumerate(event_times[:-2]):\n    \n    max_end_time = start_time + np.timedelta64(1, 'h')   # prepare to find elements within this right bound of time\n    max_end_idx = bisect_left(event_times, max_end_time) - 1    # find largest idx within time bound, this will be largest possible window for current start_time\n    \n    if max_end_idx < start_idx + 2:\n        continue # no need to continue if cannot form at least 3 rows\n    \n    \n    if start_idx:  \n        left_timeshift_possible = start_time - event_times[start_idx-1]  # can be handled by df.diff outside apply\n        min_end_time = max_end_time - left_timeshift_possible  \n\n        bisected_idx = bisect_left(event_times, min_end_time)\n        # short-circuit prevents IndexError when event_times[bisected_idx] after or \n        if bisected_idx == array_length or event_times[bisected_idx] >  min_end_time:\n            bisected_idx -= 1\n            while bisected_idx > start_idx+2 and event_times[bisected_idx-1] == event_times[bisected_idx]: \n                bisected_idx -= 1\n        # smallest window begins at 3 rows minimum, or idx of largest time less than min_end_time \n        min_end_idx = max(start_idx + 2,bisected_idx) \n    #   print('start: {}  min_end: {}  max_end: {}'.format(start_idx,min_end_idx,max_end_idx))\n    else:\n        min_end_idx = start_idx + 2\n    \n    for window_tail_idx in range(min_end_idx, max_end_idx + 1):\n        current_window = order_shop.iloc[start_idx: window_tail_idx+1] #iloc excludes right edge\n        concentration_ratio = len(current_window)\/current_window['userid'].nunique()\n        \n        if concentration_ratio >= 3: \n            \n            order_user.update(dict(zip(current_window['orderid'],current_window['userid'])))            \n            \n            event_times[start_idx-1]\n            event_times[window_tail_idx+1]\n            current_window\n        \n\nif order_user:\n    user_counts = {userid:list(order_user.values()).count(userid) for userid in set(order_user.values())}\n    max_value = max(user_counts.values())\n    users = sorted(user for user,count in user_counts.items() if count == max_value)\n    print('FINAL ANSWER BELOW')\n    '&'.join(map(str,users))\nelse:\n    '0'","886d6716":"def find_brush_enum_window_aggregate(order_shop):\n    \n    event_times = order_shop['event_time'].values\n    array_length = len(event_times)\n    counter_list = []\n\n\n    for start_idx, start_time in enumerate(event_times[:-2]):\n        counts_for_start_time = {}\n\n        max_end_time = start_time + np.timedelta64(1, 'h')   # prepare to find elements within this right bound of time\n        max_end_idx = bisect_left(event_times, max_end_time) - 1    # find largest idx within time bound, this will be largest possible window for current start_time\n\n        if max_end_idx < start_idx + 2:\n            continue # no need to continue if cannot form at least 3 rows\n\n        if start_idx:  \n            left_timeshift_possible = start_time - event_times[start_idx-1]  # can be handled by df.diff outside apply\n            min_end_time = max_end_time - left_timeshift_possible  \n\n            # smallest window begins at 3 rows minimum, or idx of largest time less than min_end_time \n            min_end_idx = max(start_idx + 2, bisect_left(event_times, min_end_time)-1) \n        else:\n            # no row before start_idx == 0, so no restriction from bisected_idx\n            min_end_idx = start_idx + 2\n\n        for window_tail_idx in range(min_end_idx, max_end_idx + 1):\n            current_window = order_shop.iloc[start_idx: window_tail_idx+1] #iloc excludes right edge\n            concentration_ratio = len(current_window)\/current_window['userid'].nunique()\n\n            if concentration_ratio >= 3: \n                counts_for_start_time.update(dict(current_window['userid'].value_counts()))\n        \n\n        # prevent appending empty counts_for_start_time (for clean debugging prints, doesn't affect Counter summation later)\n        if counts_for_start_time:\n            counter_list.append(Counter(counts_for_start_time))  # prepare Counter type for accumulation later\n\n    if counter_list:  # if not empty [{}] for shops with no brushing:\n        reduced_counter_list = reduce(operator.add,counter_list)\n        max_value = max(reduced_counter_list.values())\n        users = sorted(user for user,count in reduced_counter_list.items() if count == max_value)\n        return '&'.join(map(str,users))\n    else:\n        return '0'","6b4c62b4":"#result_enum_window_aggregate = orders_sorted.groupby(['shopid']).apply(find_brush_enum_window_aggregate)","bd8a2e81":"#result_enum_window_aggregate = result_enum_window_aggregate.reset_index(name='userid')\n#result_enum_window_aggregate.to_csv('enum_window_aggregate.csv',index=False)","3a3ab9cb":"def find_brush_enum_window_no_update(order_shop):\n    event_times = order_shop['event_time'].values\n    array_length = len(event_times)\n    counter_list = []\n\n\n    for start_idx, start_time in enumerate(event_times[:-2]):\n\n        max_end_time = start_time + np.timedelta64(1, 'h')   # prepare to find elements within this right bound of time\n        max_end_idx = bisect_left(event_times, max_end_time) - 1    # find largest idx within time bound, this will be largest possible window for current start_time\n\n        if max_end_idx < start_idx + 2:\n            continue # no need to continue if cannot form at least 3 rows\n\n\n        if start_idx:  \n            left_timeshift_possible = start_time - event_times[start_idx-1]  # can be handled by df.diff outside apply\n            min_end_time = max_end_time - left_timeshift_possible  \n\n            # smallest window begins at 3 rows minimum, or idx of largest time less than min_end_time \n            min_end_idx = max(start_idx + 2, bisect_left(event_times, min_end_time)-1)\n            \n        else:\n            # no row before start_idx == 0, so no restriction from bisected_idx\n            min_end_idx = start_idx + 2\n\n        for window_tail_idx in range(min_end_idx, max_end_idx + 1):\n            current_window = order_shop.iloc[start_idx: window_tail_idx+1] #iloc excludes right edge\n            concentration_ratio = len(current_window)\/current_window['userid'].nunique()\n\n            if concentration_ratio >= 3: \n                counter_list.append(Counter(current_window['userid']))\n\n\n    if counter_list:  # if not empty [{}] for shops with no brushing:\n        reduced_counter_list = reduce(operator.add,counter_list)\n        max_value = max(reduced_counter_list.values())\n        users = sorted(user for user,count in reduced_counter_list.items() if count == max_value)\n\n        return '&'.join(map(str,users))\n    else:\n        return '0'","6b86b7d1":"#result_enum_window_no_update = orders_sorted.groupby(['shopid']).apply(find_brush_enum_window_no_update)","6e2bc2ea":"#result_enum_window_no_update = result_enum_window_no_update.reset_index(name='userid')\n#result_enum_window_no_update.to_csv('enum_window_no_update.csv',index=False)","b21df9d8":"def find_brush_enum_window(order_shop):\n\n\n    event_times = order_shop['event_time'].values\n    array_length = len(event_times)\n    user_set = set()\n\n\n    for start_idx, start_time in enumerate(event_times[:-2]):\n\n        max_end_time = start_time + np.timedelta64(1, 'h')   # prepare to find elements within this right bound of time\n        max_end_idx = bisect_left(event_times, max_end_time) - 1    # find largest idx within time bound, this will be largest possible window for current start_time\n\n        if max_end_idx < start_idx + 2:\n            continue # no need to continue if cannot form at least 3 rows\n\n        if start_idx:  \n            left_timeshift_possible = start_time - event_times[start_idx-1]  # can be handled by df.diff outside apply\n            min_end_time = max_end_time - left_timeshift_possible  \n\n            # smallest window begins at 3 rows minimum, or idx of largest time less than min_end_time \n            min_end_idx = max(start_idx + 2, bisect_left(event_times, min_end_time)-1)\n\n        else:\n            # no row before start_idx == 0, so no restriction from bisected_idx\n            min_end_idx = start_idx + 2\n\n        for window_tail_idx in range(min_end_idx, max_end_idx + 1):\n            current_window = order_shop.iloc[start_idx: window_tail_idx+1] #iloc excludes right edge\n            concentration_ratio = len(current_window)\/current_window['userid'].nunique()\n\n            if concentration_ratio >= 3: \n                current_window_counts = Counter(current_window['userid'])\n                current_window_counts\n                max_value = max(current_window_counts.values())\n                user_set.update(user for user, count in current_window_counts.items() if count ==  max_value)\n\n\n    if user_set:  # if not empty [{}] for shops with no brushing:\n        users = sorted(user_set)\n        return '&'.join(map(str,users))\n    else:\n        return '0'","3af98c79":"#result_enum_window = orders_sorted.groupby(['shopid']).apply(find_brush_enum_window)","88f04108":"#result_enum_window = result_enum_window.reset_index(name='userid')\n#result_enum_window.to_csv('enum_window.csv',index=False)","77971230":"def find_brush_enum_window_bisect(order_shop):\n    event_times = order_shop['event_time'].values\n    array_length = len(event_times)\n    counter_list = []\n\n\n    for start_idx, start_time in enumerate(event_times[:-2]):\n        counts_for_start_time = {}\n\n        max_end_time = start_time + np.timedelta64(1, 'h')   # prepare to find elements within this right bound of time\n        max_end_idx = bisect_left(event_times, max_end_time) - 1    # find largest idx within time bound, this will be largest possible window for current start_time\n\n        if max_end_idx < start_idx + 2:\n            continue # no need to continue if cannot form at least 3 rows\n\n\n        if start_idx:  \n            left_timeshift_possible = start_time - event_times[start_idx-1]  # can be handled by df.diff outside apply\n            min_end_time = max_end_time - left_timeshift_possible  \n\n            bisected_idx = bisect_left(event_times, min_end_time)\n            \n            # short-circuit prevents IndexError when event_times[bisected_idx] after or \n            if bisected_idx == array_length or event_times[bisected_idx] >  min_end_time:\n                bisected_idx -= 1\n                while bisected_idx > start_idx+2 and event_times[bisected_idx-1] == event_times[bisected_idx]: \n                    bisected_idx -= 1\n            # smallest window begins at 3 rows minimum, or idx of largest time less than min_end_time \n            min_end_idx = max(start_idx + 2,bisected_idx) \n\n        else:\n            # no row before start_idx == 0, so no restriction from bisected_idx \n            min_end_idx = start_idx + 2\n\n        for window_tail_idx in range(min_end_idx, max_end_idx + 1):\n            current_window = order_shop.iloc[start_idx: window_tail_idx+1] #iloc excludes right edge\n            concentration_ratio = len(current_window)\/current_window['userid'].nunique()\n\n            if concentration_ratio >= 3: \n                counts_for_start_time.update(dict(current_window['userid'].value_counts()))\n                \n        # prevent appending empty counts_for_start_time (for clean debugging prints, doesn't affect Counter summation later)\n        if counts_for_start_time:\n            counter_list.append(Counter(counts_for_start_time))  # prepare Counter type for accumulation later\n\n    if counter_list:  # if not empty [{}] for shops with no brushing:\n        reduced_counter_list = reduce(operator.add,counter_list)\n        max_value = max(reduced_counter_list.values())\n        users = sorted(user for user,count in reduced_counter_list.items() if count == max_value)\n        return '&'.join(map(str,users))\n    else:\n        return '0'","af9ec2ce":"#result_enum_window_bisect = orders_sorted.groupby(['shopid']).apply(find_brush_enum_window_bisect)","e864250b":"#result_enum_window_bisect = result_enum_window_bisect.reset_index(name='userid')\n#result_enum_window_bisect.to_csv('enum_window_bisect.csv',index=False)","9f2b56e4":"def find_brush_enum_window_dedup(order_shop):\n    \n    event_times = order_shop['event_time'].values\n    array_length = len(event_times)\n\n    order_user = {}\n\n    for start_idx, start_time in enumerate(event_times[:-2]):\n\n        max_end_time = start_time + np.timedelta64(1, 'h')   # prepare to find elements within this right bound of time\n        max_end_idx = bisect_left(event_times, max_end_time) - 1    # find largest idx within time bound, this will be largest possible window for current start_time\n\n        if max_end_idx < start_idx + 2:\n            continue # no need to continue if cannot form at least 3 rows\n\n\n        if start_idx:  \n            left_timeshift_possible = start_time - event_times[start_idx-1]  # can be handled by df.diff outside apply\n            min_end_time = max_end_time - left_timeshift_possible  \n\n            bisected_idx = bisect_left(event_times, min_end_time)\n            # short-circuit prevents IndexError when event_times[bisected_idx] after or \n            if bisected_idx == array_length or event_times[bisected_idx] >  min_end_time:\n                bisected_idx -= 1\n                while bisected_idx > start_idx+2 and event_times[bisected_idx-1] == event_times[bisected_idx]: \n                    bisected_idx -= 1\n            # smallest window begins at 3 rows minimum, or idx of largest time less than min_end_time \n            min_end_idx = max(start_idx + 2,bisected_idx) \n\n        else:\n            # no row before start_idx == 0, so no restriction from bisected_idx\n            min_end_idx = start_idx + 2\n\n        for window_tail_idx in range(min_end_idx, max_end_idx + 1):\n            current_window = order_shop.iloc[start_idx: window_tail_idx+1] #iloc excludes right edge\n            concentration_ratio = len(current_window)\/current_window['userid'].nunique()\n\n            if concentration_ratio >= 3: \n                order_user.update(dict(zip(current_window['orderid'],current_window['userid'])))            \n\n\n    if order_user:\n        user_counts = {userid:list(order_user.values()).count(userid) for userid in set(order_user.values())}\n        max_value = max(user_counts.values())\n        users = sorted(user for user,count in user_counts.items() if count == max_value)\n        \n        return '&'.join(map(str,users))\n    else:\n        return '0'","31f9749d":"result_enum_window_dedup = orders_sorted.groupby(['shopid']).apply(find_brush_enum_window_dedup)","9844401e":"result_enum_window_dedup = result_enum_window_dedup.reset_index(name='userid')\nresult_enum_window_dedup.to_csv('enum_window_dedup.csv',index=False)","bb46b53d":"def find_brush_enum_window_dedup_diff(order_shop):\n    \n    event_times = order_shop['event_time'].values\n    array_length = len(event_times)\n    \n    order_user = {}\n    # insert to shift right 1 position for natural indexing using start_idx\n    event_times_diff = np.insert(np.diff(event_times),values=0,obj=0)\n    \n    for start_idx, start_time in enumerate(event_times[:-2]):\n\n        max_end_time = start_time + np.timedelta64(1, 'h')   # prepare to find elements within this right bound of time\n        max_end_idx = bisect_left(event_times, max_end_time) - 1    # find largest idx within time bound, this will be largest possible window for current start_time\n\n        if max_end_idx < start_idx + 2:\n            continue # no need to continue if cannot form at least 3 rows\n\n\n        if start_idx:\n            min_end_time = max_end_time - event_times_diff[start_idx]  \n\n            bisected_idx = bisect_left(event_times, min_end_time)\n            # short-circuit prevents IndexError when event_times[bisected_idx] after or \n            if bisected_idx == array_length or event_times[bisected_idx] >  min_end_time:\n                bisected_idx -= 1\n                while bisected_idx > start_idx+2 and event_times[bisected_idx-1] == event_times[bisected_idx]: \n                    bisected_idx -= 1\n            # smallest window begins at 3 rows minimum, or idx of largest time less than min_end_time \n            min_end_idx = max(start_idx + 2,bisected_idx)\n\n        else:\n            # no row before start_idx == 0, so no restriction from bisected_idx\n            min_end_idx = start_idx + 2\n\n        for window_tail_idx in range(min_end_idx, max_end_idx + 1):\n            current_window = order_shop.iloc[start_idx: window_tail_idx+1] #iloc excludes right edge\n            concentration_ratio = len(current_window)\/current_window['userid'].nunique()\n\n            if concentration_ratio >= 3: \n                order_user.update(dict(zip(current_window['orderid'],current_window['userid'])))            \n\n\n    if order_user:\n        user_counts = {userid:list(order_user.values()).count(userid) for userid in set(order_user.values())}\n        max_value = max(user_counts.values())\n        users = sorted(user for user,count in user_counts.items() if count == max_value)\n        \n        return '&'.join(map(str,users))\n    else:\n        return '0'","cfee70c0":"#result_enum_window_dedup_diff = orders_sorted.groupby(['shopid']).apply(find_brush_enum_window_dedup_diff)","4d3b898b":"from bisect import bisect, bisect_left\n\ntime = [10,10,20,20,20,30,30]\n# bisect finds index of array to insert new value to keep array sorted.\n# bisect and bisect_left differences show up when the value to be inserted matches exactly one of the values in the array\n# such a difference is magnified if that matched value is duplicated in the array\n\nbisect(time,20)\nbisect_left(time,20)\n\n# No difference between bisect and bisect_left when value inserted does not clash\nbisect(time,21)\nbisect_left(time,21) ","adeb7586":"bisect_left([1,1,2,2,3,3,3],3.1) ","7dc4f02e":"**All 3 links have 315 brushing shops and ~ 30 seconds runtime on full data**\n\n- [Score: 1](#1)  (do not double count orders no matter how many brushing windows they appear in)\n- [Score 0.99508](#2) (max user after aggregating all brushing windows found (same score [with updating](#2.1) or [without updating](#2) within a `start_idx`))\n- [Score 0.99263](#3) (pick out max user within each brushing window)","abbdf201":"### Using np.diff to test speed up (not much effect) ","9cf08edd":"<a id='2'><\/a>\n### Adding all windows in without updating \n- Same start_idx will get all its user counts summed","ad7d7c41":"### all windows aggregated - no update ","5ab6b8e1":"### Not recounting same order in different window ","c7f9a239":"![window.jpg](attachment:window.jpg)","002438be":"<a id='2.1'><\/a>\n###  max user after aggregating all windows\n- updates Counter for each start_idx so counts are based on largest window for each start_idx\n- Makes no sense on hindsight, but gets 0.99508\n","68bf9a7b":"### Refining bisect for min_end_idx","f94c2fa9":"# Getting 1 shop for easy debugging using examples","339e1569":"### Window look back (max user in each window)  ","37a0af43":"### all windows aggregated ","d26b97dc":"# Interpretation challenges\n\n**Questions**\n- The task contains many issues to be clear of:\n    1. How to create 1hour windows (event_time being start of 1 hr vs \"at any instance\")\n    2. Aggregate highest proportion user within each window or after all windows are found for a shop\n    3. Recount same orderids\/userids that appeared in different brushing windows vs count once\n    \n  \n**Reasons**\n1. If windows only created with hour beginning at timestamp, we are losing the opportunity to exclude users (by moving the 1hour window back until just behind previous event_time) to reduce the denominator of unique users and increase chances of increasing concentration ratio. The examples provided could have been misleading because it shows multiple 1hour windows with the start being an `event_time` rather than an imaginary time. There were subtle hints _\"at any instance\" (Overview-->Description)_ and _\"Please consider all possible '1 hour' time interval\" (Examples--> Case 2b)_ that a fast reader could miss.\n\n2. If the highest proportion was calculated within each window, there would be no need for Case 4 to show 2 brushing windows. However, no matter getting max users within each or all windows, the denominator does not need to be calculated. Also, the highest proportion users from Case 4 example is the same for both ways of calculating. Case 3 used _User 201343856 had the highest proportion of orders during the order brushing period_. This hints at the method of calculating within each window.\n\n3. Because time can be shifted infinitesimally small, there are infinitely many possible brushing windows. To deal with this problem, we can think of only working with \"relevant windows\" (each unique set of orders to be enumerated). Because a user can appear in the tail of one window and the head of another window when other users transact before or after him (which creates a \"relevant window\"), generating brushing users for a shop based on calculating window statistics (both within each window (0.99263) and all windows(0.99508)) would cause the same user\/orderid to be counted multiple times for a user. Such a phenomenon of other user events increasing the brushing suspicion level of a certain user does not make sense. Thus, relevant windows should be seen as only useful for labeling each order as brushed vs not brushed. The 0.99508 solution could have more brushing users than 1.0 solution for shopid 155143347, 156883302 because of overcounting a user for the same orderid when this user appears in multiple windows. ","c05da71c":"<a id='3'><\/a>\n### Windows with looking back (max user within each window)\n- prevent too few unique users in window","0111425c":"# Clarifying bisect\n**Why is `max_end_time` using bisect_left - 1**\n- Goal of max_end_time is to find the index of largest event_time < max_end_time.\n- When value to search does not match values in array, both bisect_left\/bisect return one idx higher than the above requirement, so -1 for this case\n- When value to search match one or more(duplicated) values in array, bisect_left returns first idx of matching value, but we want a strictly smaller than max_end_time, so -1 for this case too  \n\n**Why is `min_end_time` using bisect_left without -1 if min_end_time == event_times[bisected_idx] and with -1 when `bisected_idx == array_length` or `min_end_time < event_times[bisected_idx]`** \n- Goal of min_end_time is to find the index of largest event_time <= min_end_time\n    - Note the difference from `max_end_time` is the <= here \n    - Complication here is if such largest event_time is duplicated, we want the first idx among duplications to avoid missing out rows in the window with the least orders for the current start_time\n- When value to search does not match values in array, same explanation as above for `max_end_time`\n    - Additionally, because we want the smallest possible window for min_end_time, if there are duplicate times for min_end_time, keep moving to left until 1st value (implemented as while-loop)\n- When value to search match one or more(duplicated) values in array, bisect_left returns first idx of matching value, which is exactly what's needed --> Do not -1 ","f16d4076":"# Result Summary ","1645f4d9":"<a id='1'><\/a>\n### Not recounting same orders in different windows ","6950d2a0":"# Running on full data","bdbc4797":"### Refine bisect if there's case of  event_times[bisected_idx] ==  min_end_time (do not -1)","c3604787":"# Solution strategy (same for all top 3 scores except step 4)\n\n1. Time continuous, impossible to enumerate all time windows --> just find all the sets of orders that can appear within 1hour (like enumerating combinations but within a time bound of 1hr from the first order) \n    - If orders in brushing window land exactly 1 hour apart, 1hr assumed exclusive on right side\n2. Start from every timestamp of sorted timestamps for shop and find the smallest and largest set of rows that can make a 1hr window for current timestamp, then calculate through all the windows from smallest to largest \n3. For concentrate rate to be >= 3, the window has to be at least size 3, so can start growing window from this size as minimum, but this minimum could be pulled up by the previous timestamp which controls how far back the 1hour window for current timestamp can be pushed back\n4. Save order and user information if is brushing window to accumulate later\n\n\n- Using Evaluation page formula, \n```\nnumber of 0 = x\n0.005*x + (18770-x) = 407.275\nx = number of 0 = 18445 --> number of brushing shops = 18770 - 18455 = 315\n```\n- There are 315 brushing shops expected "}}