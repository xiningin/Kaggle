{"cell_type":{"d09a93c4":"code","69bf9f03":"code","83d0e70b":"code","8b3165e2":"code","71f74be9":"code","a2ed1468":"code","1d1bd346":"code","a2771876":"code","54241107":"code","e010528b":"code","3544f150":"code","76973d51":"code","cc4a9f6f":"markdown","fc288c9d":"markdown","5944eb73":"markdown","08165e8b":"markdown","25004ed2":"markdown","d88a5016":"markdown","ebfadb03":"markdown"},"source":{"d09a93c4":"import json\nimport pandas as pd\nfrom tqdm.notebook import tqdm","69bf9f03":"# Load data\ndata = json.load(open('\/kaggle\/input\/scl-2021-da\/contacts.json', 'r'))\ndata[:5]","83d0e70b":"# Following writeup at https:\/\/drive.google.com\/file\/d\/1a9Rpy61rbZNLG2IkGxEvk134OHsV8WS7\/view\n\n# 1) - 2) Create 4 empty dictionaries ...\nid_to_user = {}\nemail_to_id = {}\nphone_to_id = {}\norderid_to_id = {}\n\n# 3) Create a class called User ...\nclass User:\n    def __init__(self):\n        self.id = -1\n        self.emails = []\n        self.phones = []\n        self.orderids = []\n        self.contacts = 0\n        self.ticketids = []\n\n# 4) Loop through each ticket ...\nfor row in tqdm(data):\n    email = row['Email']\n    phone = row['Phone']\n    orderid = row['OrderId']\n    contacts = row['Contacts']\n    ticketid = row['Id']\n    \n    # a) Create an empty list of existing userid ...\n    existing_userids = []\n    \n    # b) - d) Get the ...\n    if email and email in email_to_id:\n        existing_userids.append(email_to_id[email])\n    if phone and phone in phone_to_id:\n        existing_userids.append(phone_to_id[phone])\n    if orderid and orderid in orderid_to_id:\n        existing_userids.append(orderid_to_id[orderid])\n    \n    if not existing_userids:\n        # e) If there is no existing userid matching this ticket ...\n        current_user = User()\n        current_user.id = len(id_to_user)\n        \n        # ii) Add the existing email. Phone and orderid ...\n        current_user.emails = [email]\n        current_user.phones = [phone]\n        current_user.orderids = [orderid]\n        current_user.contacts = contacts\n        current_user.ticketids = [ticketid]\n        \n        # iv) - vi) Add the value ...\n        email_to_id[email] = current_user.id\n        phone_to_id[phone] = current_user.id\n        orderid_to_id[orderid] = current_user.id\n        \n        # vii) Add this user id to the user dictionary\n        id_to_user[current_user.id] = current_user\n    else:\n        # f) If the list of existing userids is more than 0 ...\n        \n        # i) Choose one the first existing userid ...\n        # Here is the first half of the bug\n        # Only the 'first encountered' user object is updated with 'latest' data and then pointed to\n        # 'Stale' data is still present in user objects other IDs\n        current_user = id_to_user[existing_userids[0]]\n        \n        # add this current ticket\u2019s email phone ...\n        current_user.emails += [email]\n        current_user.phones += [phone]\n        current_user.orderids += [orderid]\n        current_user.contacts += contacts\n        current_user.ticketids += [ticketid]\n        \n        # ii) Go through the rest of the existing userid and loop...\n        for other_userid in existing_userids[1:]:\n            other_user = id_to_user[other_userid]\n\n            current_user.emails += other_user.emails\n            current_user.phones += other_user.phones\n            current_user.orderids += other_user.orderids\n            current_user.contacts += other_user.contacts\n            current_user.ticketids += other_user.ticketids\n        \n    # g) Use the user object that this ticket referenced to replace ...\n    for update_email in current_user.emails:\n        email_to_id[update_email] = current_user.id\n    for update_phone in current_user.phones:\n        phone_to_id[update_phone] = current_user.id\n    for update_orderid in current_user.orderids:\n        orderid_to_id[update_orderid] = current_user.id\n\n# 5) Use the values from 3vi and 3v to get the final output ...\n# Here is the second half of the bug\n# Instead of recovering the 'latest' user object via email_to_id etc., we just iterate through all user objects\n# We may then accidentally overwrite 'latest' data from a user with small id with 'stale' data from a user with larger id\nanswers = [None for i in range(len(data))]\nfor _, user in tqdm(id_to_user.items()):\n    for ticketid in user.ticketids:\n        answers[ticketid] = '-'.join([str(i) for i in sorted(set(user.ticketids))]) + ', ' + str(user.contacts)\n        \nans_df = pd.DataFrame({'ticket_id': range(len(data)), 'ticket_trace\/contact': answers})\nans_df.head()","8b3165e2":"ans_df.to_csv('buggy_submission.csv', index=False)\n# md5sum, of 1.0 lb answer, file has no crlf\n!md5sum buggy_submission.csv","71f74be9":"ans_df.loc[ans_df['ticket_trace\/contact'].str.contains(r'^40-')]","a2ed1468":"ans_df.loc[ans_df['ticket_trace\/contact'].str.contains(r'^40-')]['ticket_trace\/contact'].value_counts()","1d1bd346":"small_breaking_testcase = [\n\t{\"Id\": 0, \"Email\": \"a@a.com\", \"Phone\": \"\", \"Contacts\": 0, \"OrderId\": \"\"},\n\t{\"Id\": 1, \"Email\": \"\", \"Phone\": \"1\", \"Contacts\": 0, \"OrderId\": \"\"},\n\t{\"Id\": 2, \"Email\": \"a@a.com\", \"Phone\": \"1\", \"Contacts\": 0, \"OrderId\": \"\"},\n\t{\"Id\": 3, \"Email\": \"a@a.com\", \"Phone\": \"1\", \"Contacts\": 0, \"OrderId\": \"\"}\n]\ndata = small_breaking_testcase","a2771876":"id_to_user = {}\nemail_to_id = {}\nphone_to_id = {}\norderid_to_id = {}\n\nclass User:\n    def __init__(self):\n        self.id = -1\n        self.emails = []\n        self.phones = []\n        self.orderids = []\n        self.contacts = 0\n        self.ticketids = []\n\nfor row in tqdm(data):\n    email = row['Email']\n    phone = row['Phone']\n    orderid = row['OrderId']\n    contacts = row['Contacts']\n    ticketid = row['Id']\n    \n    existing_userids = []\n    \n    if email and email in email_to_id:\n        existing_userids.append(email_to_id[email])\n    if phone and phone in phone_to_id:\n        existing_userids.append(phone_to_id[phone])\n    if orderid and orderid in orderid_to_id:\n        existing_userids.append(orderid_to_id[orderid])\n    \n    if not existing_userids:\n        current_user = User()\n        current_user.id = len(id_to_user)\n        \n        current_user.emails = [email]\n        current_user.phones = [phone]\n        current_user.orderids = [orderid]\n        current_user.contacts = contacts\n        current_user.ticketids = [ticketid]\n        \n        email_to_id[email] = current_user.id\n        phone_to_id[phone] = current_user.id\n        orderid_to_id[orderid] = current_user.id\n        \n        id_to_user[current_user.id] = current_user\n    else:\n        current_user = id_to_user[existing_userids[0]]\n        \n        current_user.emails += [email]\n        current_user.phones += [phone]\n        current_user.orderids += [orderid]\n        current_user.contacts += contacts\n        current_user.ticketids += [ticketid]\n        \n        for other_userid in existing_userids[1:]:\n            other_user = id_to_user[other_userid]\n\n            current_user.emails += other_user.emails\n            current_user.phones += other_user.phones\n            current_user.orderids += other_user.orderids\n            current_user.contacts += other_user.contacts\n            current_user.ticketids += other_user.ticketids\n\n    for update_email in current_user.emails:\n        email_to_id[update_email] = current_user.id\n    for update_phone in current_user.phones:\n        phone_to_id[update_phone] = current_user.id\n    for update_orderid in current_user.orderids:\n        orderid_to_id[update_orderid] = current_user.id\n\nanswers = [None for i in range(len(data))]\nfor _, user in tqdm(id_to_user.items()):\n    for ticketid in user.ticketids:\n        answers[ticketid] = '-'.join([str(i) for i in sorted(set(user.ticketids))]) + ', ' + str(user.contacts)\n        \nans_df = pd.DataFrame({'ticket_id': range(len(data)), 'ticket_trace\/contact': answers})\nans_df.head()","54241107":"for userid, user in id_to_user.items():\n    print(userid, user.ticketids)","e010528b":"# Load data\ndata = json.load(open('\/kaggle\/input\/scl-2021-da\/contacts.json', 'r'))\ndata[:5]","3544f150":"id_to_user = {}\nemail_to_id = {}\nphone_to_id = {}\norderid_to_id = {}\n\nclass User:\n    def __init__(self):\n        self.id = -1\n        self.emails = []\n        self.phones = []\n        self.orderids = []\n        self.contacts = 0\n        self.ticketids = []\n\nfor row in tqdm(data):\n    email = row['Email']\n    phone = row['Phone']\n    orderid = row['OrderId']\n    contacts = row['Contacts']\n    ticketid = row['Id']\n    \n    existing_userids = []\n    \n    if email and email in email_to_id:\n        existing_userids.append(email_to_id[email])\n    if phone and phone in phone_to_id:\n        existing_userids.append(phone_to_id[phone])\n    if orderid and orderid in orderid_to_id:\n        existing_userids.append(orderid_to_id[orderid])\n    \n    if not existing_userids:\n        current_user = User()\n        current_user.id = len(id_to_user)\n        \n        current_user.emails = [email]\n        current_user.phones = [phone]\n        current_user.orderids = [orderid]\n        current_user.contacts = contacts\n        current_user.ticketids = [ticketid]\n        \n        email_to_id[email] = current_user.id\n        phone_to_id[phone] = current_user.id\n        orderid_to_id[orderid] = current_user.id\n        \n        id_to_user[current_user.id] = current_user\n    else:\n        # Fix this bug by only updating the user object with largest id\n        # When we recover we won't accidentally overwrite the answer with stale data anymore\n        # Of course other algorithms e.g. UFDS, graph search are still correct\n        current_user = id_to_user[max(existing_userids)]\n        \n        current_user.emails += [email]\n        current_user.phones += [phone]\n        current_user.orderids += [orderid]\n        current_user.contacts += contacts\n        current_user.ticketids += [ticketid]\n        \n        for other_userid in existing_userids:\n            if other_userid == max(existing_userids):\n                continue\n                \n            other_user = id_to_user[other_userid]\n\n            current_user.emails += other_user.emails\n            current_user.phones += other_user.phones\n            current_user.orderids += other_user.orderids\n            current_user.contacts += other_user.contacts\n            current_user.ticketids += other_user.ticketids\n\n    for update_email in current_user.emails:\n        email_to_id[update_email] = current_user.id\n    for update_phone in current_user.phones:\n        phone_to_id[update_phone] = current_user.id\n    for update_orderid in current_user.orderids:\n        orderid_to_id[update_orderid] = current_user.id\n\nanswers = [None for i in range(len(data))]\nfor _, user in tqdm(id_to_user.items()):\n    for ticketid in user.ticketids:\n        answers[ticketid] = '-'.join([str(i) for i in sorted(set(user.ticketids))]) + ', ' + str(user.contacts)\n        \nans_df = pd.DataFrame({'ticket_id': range(len(data)), 'ticket_trace\/contact': answers})\nans_df.head()","76973d51":"ans_df.to_csv('fixed_submission.csv', index=False)\n# md5sum, of 0.953 lb answer, file has no crlf\n!md5sum fixed_submission.csv","cc4a9f6f":"# 1.0 LB solution with bug","fc288c9d":"# Fixed solution gets 0.95 LB","5944eb73":"23 rows were overwritten with 'stale' data after the 'latest' user object was checked, and have a shorter ticket trace, while only 3 rows have correct traces.\n\nA solution that produces this shouldn't get full score, but apparently it does.","08165e8b":"# 1.0 LB solution vs small testcase","25004ed2":"Please fix.","d88a5016":"As an example of a testcase that is wrong, look at ticket traces involving ticket 40","ebfadb03":"Correct data for rows 0, 2 and 3 came from the 'latest' user 0, while row 1 was overwritten by stale data."}}