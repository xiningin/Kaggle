{"cell_type":{"9311c602":"code","b483d51c":"code","d7eb44d4":"code","1839844d":"code","ec1a7921":"code","4f70b4e0":"code","3ca0ebfe":"code","417a1d8c":"code","f9c06322":"code","cb973d8b":"code","8c712b8f":"code","1a4c5de2":"code","aec8d242":"code","b8144dfc":"code","fff77c93":"markdown","2d41bd2c":"markdown","917eb0e7":"markdown","7c556323":"markdown","b7b41cab":"markdown","c67122b6":"markdown"},"source":{"9311c602":"import warnings\nwarnings.filterwarnings('ignore')\nimport tensorflow as tf\nimport numpy as np\nfrom sklearn.datasets import make_classification\nimport matplotlib.pyplot as plt\n%matplotlib inline","b483d51c":"NUM_SAMPLES = 1000\nNUM_FEATURES = 2","d7eb44d4":"X, y = make_classification(n_samples = NUM_SAMPLES, \n                           n_features = NUM_FEATURES, \n                           n_informative = NUM_FEATURES, \n                           n_redundant = 0, \n                           n_classes = 2, \n                           n_clusters_per_class = 1, \n                           class_sep = 0.75,\n                           random_state = 54312)","1839844d":"y = y.reshape(-1, 1)\ny.shape","ec1a7921":"ones = np.where(y == 1)   # \u0438\u043d\u0434\u0435\u043a\u0441\u044b \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u043a\u043b\u0430\u0441\u0441\u0430 '1'\nzeros = np.where(y == 0)  # \u0438\u043d\u0434\u0435\u043a\u0441\u044b \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u043a\u043b\u0430\u0441\u0441\u0430 '0'","4f70b4e0":"plt.plot(X[ones, 0], X[ones, 1], 'ob');\nplt.plot(X[zeros, 0], X[zeros, 1], 'or');","3ca0ebfe":"import string\n\ndef py_func_with_grad(func, inp, Tout, grad, name=None, stateful=False, graph=None):\n    name_prefix = ''.join(np.random.choice(list(string.ascii_letters), size = 10)) # \u0433\u0435\u043d\u0435\u0440\u0438\u0442 \u043d\u043e\u0432\u043e\u0435 \u0438\u043c\u044f\n    name = '%s_%s' % (name_prefix, name or '')\n    grad_func_name = '%s_grad' % name # \u043a \u0438\u043c\u0435\u043d\u0438 \u0438\u0437 10 \u0431\u0443\u043a\u0432 \u043f\u0440\u0435\u0431\u0430\u0432\u043b\u044f\u0435\u0442 '_grad'\n    \n    tf.RegisterGradient(grad_func_name)(grad) # \u0434\u0435\u043a\u043e\u0440\u0430\u0442\u043e\u0440 \u0434\u043b\u044f \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442\u0430 \u0434\u043b\u044f \u0442\u0438\u043f\u0430 op\n    \n    g = graph or tf.get_default_graph()\n    with g.gradient_override_map({'PyFunc': grad_func_name, \n                                  'PyFuncStateless': grad_func_name}):\n        with tf.name_scope(name, 'PyFuncOp', inp):\n            return tf.py_func(func, inp, Tout, stateful = stateful, name = name) # \u043e\u0431\u043e\u0440\u0430\u0447\u0438\u0432\u0430\u0435\u043c \u043d\u0430\u0448\u0443 \n                                                                # \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0442\u0435\u043d\u0437\u043e\u0440\u0430","417a1d8c":"def linear_op_forward(X, W, b):\n    '''\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043b\u0438\u043d\u0435\u0439\u043d\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438'''\n    return np.dot(X, W.T) + b # \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f numpy-\u043c\u0430\u0441\u0441\u0438\u0432\u0430\u043c\u0438\n\ndef linear_op_backward(op, grads):\n    '''\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442\u0430 \u043b\u0438\u043d\u0435\u0439\u043d\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438'''\n    X = op.inputs[0]  # \u0442\u0435\u043d\u0437\u043e\u0440 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\n    W = op.inputs[1]  # \u0442\u0435\u043d\u0437\u043e\u0440 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043c\u043e\u0434\u0435\u043b\u0438\n    b = op.inputs[2]\n    dX = tf.multiply(grads, W)\n    dW = tf.reduce_sum(tf.multiply(X, grads),\n                      axis = 0,\n                      keep_dims = True)\n    db = tf.reduce_sum(tf.multiply(1., grads),\n                      axis = 0,\n                      keep_dims = True)\n    return dX, dW, db\n\ndef sigmoid_op_forward(X):\n    return 1 \/ (1 + np.exp(-X))\n\ndef sigmoid_op_backward(op, grads):\n    sigmoid = op.outputs[0]\n    sigmoid_deriv = sigmoid * (1 - sigmoid)\n    d_grad = tf.reduce_sum(tf.multiply(sigmoid_deriv, grads),\n                       axis = 0,\n                       keep_dims = True)\n    return d_grad","f9c06322":"y.shape","cb973d8b":"BATCH_SIZE = NUM_SAMPLES \/\/ 10\n\nweights = None # \u0432 \u044d\u0442\u043e\u0439 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u043c\u044b \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f \u043c\u043e\u0434\u0435\u043b\u0438\nbias = None\nlearning_curve = [] # \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 \u043d\u0430 \u043a\u0430\u0436\u0434\u043e\u0439 \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0438 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f\n\nwith tf.Session(graph = tf.Graph()) as sess: # \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c \u0441\u0435\u0441\u0441\u0438\u044e \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0439\n    \n    # \u0441\u043e\u0437\u0434\u0430\u0435\u043c placeholder'\u044b, \u0447\u0435\u0440\u0435\u0437 \u043d\u0438\u0445 \u043c\u044b \u0431\u0443\u0434\u0435\u043c \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0442\u044c \u0432\u043d\u0435\u0448\u043d\u0438\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 \u0433\u0440\u0430\u0444 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0439\n    plh_X = tf.placeholder(dtype = tf.float32, shape = [None, NUM_FEATURES])\n    plh_labels = tf.placeholder(dtype = tf.float32, shape = [None, 1])\n    \n    # \u0441\u043e\u0437\u0434\u0430\u0451\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0432\u0435\u0441\u043e\u0432 \u043c\u043e\u0434\u0435\u043b\u0438\n    # \u044d\u0442\u0438 \u0432\u0435\u0441\u0430 \u0431\u0443\u0434\u0443\u0442 \u0438\u0437\u043c\u0435\u043d\u044f\u0442\u044c\u0441\u044f \u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f\n    var_W = tf.Variable(tf.random_uniform(shape = [1, NUM_FEATURES], \n                                          dtype = tf.float32, \n                                          seed = 27))\n    \n    var_b = tf.Variable(tf.random_normal(shape = [1, 1], \n                                         mean = 0.5, \n                                         dtype = tf.float32, \n                                         seed = 27))\n    \n#     var_b = tf.Variable(initial_value=1.0)\n    \n    # \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u0434\u043b\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u044f \u043c\u043e\u0434\u0435\u043b\u0438\n    var_Pred = py_func_with_grad(linear_op_forward, \n                                 [plh_X, var_W, var_b], \n                                 [tf.float32], \n                                 name = 'linear_op', \n                                 grad = linear_op_backward, \n                                 graph = sess.graph)\n    \n    # \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u0434\u043b\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438 sigmoid\n    var_Sigmoid = py_func_with_grad(sigmoid_op_forward, \n                                    [var_Pred], \n                                    [tf.float32], \n                                    name = 'sigmoid_op', \n                                    grad = sigmoid_op_backward, \n                                    graph = sess.graph)\n    \n    # \u043a\u0440\u043e\u0441\u0441-\u044d\u043d\u0442\u0440\u043e\u043f\u0438\u0439\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u043e\u0442\u0435\u0440\u044c \u0434\u043b\u044f \u0431\u0438\u043d\u0430\u0440\u043d\u043e\u0439 \u043a\u043b\u0430\u0441\u0441\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438\n    cost = tf.losses.sigmoid_cross_entropy(plh_labels, var_Sigmoid)\n    \n    # \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c \u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0430\u0442\u043e\u0440 \u0438 \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u043c \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f\n    optimizer = tf.train.GradientDescentOptimizer(learning_rate=0.4).minimize(cost)\n    \n    # \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c placeholder'\u044b \u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435\n    sess.run(tf.global_variables_initializer())\n    \n    indices = np.arange(len(X)) # \u043c\u0430\u0441\u0441\u0438\u0432 \u0438\u043d\u0434\u0435\u043a\u0441\u043e\u0432 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432\n    \n    # \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u043c \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0438 \u043f\u043e 10 \u044d\u043f\u043e\u0445\u0430\u043c\n    for epoch in range(250):\n        \n        # \u0432 \u043d\u0430\u0447\u0430\u043b\u0435 \u043a\u0430\u0436\u0434\u043e\u0439 \u044d\u043f\u043e\u0445\u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u0448\u0438\u0432\u0430\u0435\u043c \u0438\u043d\u0434\u0435\u043a\u0441\u044b\n        np.random.shuffle(indices)\n        \n        # \u0432\u043d\u0443\u0442\u0440\u0438 \u043a\u0430\u0436\u0434\u043e\u0439 \u044d\u043f\u043e\u0445\u0438 \u0434\u0430\u043d\u043d\u044b\u0435 \u0440\u0430\u0437\u0431\u0438\u0432\u0430\u044e\u0442\u0441\u044f \u043d\u0430 \u0431\u0430\u0442\u0447\u0438\n        for batch in range(len(X) \/\/ BATCH_SIZE):\n            \n            # \u0432\u044b\u0431\u0438\u0440\u0430\u0435\u043c \u0438\u043d\u0434\u0435\u043a\u0441\u044b \u043e\u0447\u0435\u0440\u0435\u0434\u043d\u043e\u0433\u043e \u0431\u0430\u0442\u0447\u0430:\n            batch_indices = indices[batch * BATCH_SIZE:(batch + 1) * BATCH_SIZE]\n            \n            # \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u043c \u0448\u0430\u0433 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f: \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043e\u0448\u0438\u0431\u043a\u0443 \u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u0432\u0435\u0441\u0430\n            loss, _ = sess.run([cost, optimizer], # \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u043c \u043a\u0430\u043a\u0438\u0435 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c\n                               feed_dict = {plh_X: X[batch_indices], # \u043f\u0435\u0440\u0435\u0434\u0430\u0435\u043c \u0432\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\n                                            plh_labels: y[batch_indices]})\n            \n            # \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u043a\u0440\u0438\u0432\u043e\u0439 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f\n            learning_curve.append(loss)\n            \n            # \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e 10-\u0433\u043e \u0448\u0430\u0433\u0430\n            steps = len(learning_curve) - 1\n            if steps % 250 == 0:\n                print ('[%03d] loss=%.3f weights=%s bias=%s' % (steps, loss, var_W.eval(), var_b.eval()))\n                \n        # \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u043e\u0431\u0443\u0447\u0435\u043d\u043d\u044b\u0435 \u0432\u0435\u0441\u0430\n        weights = var_W.eval()\n        bias = var_b.eval()\n            ","8c712b8f":"plt.xlabel('step')\nplt.ylabel('loss')\nplt.title('Learning curve')\nplt.plot(learning_curve);","1a4c5de2":"bias[0, 0]","aec8d242":"y_pred = - X[:, 0] * weights[0, 0]\/ weights[0, 1]  - bias[0, 0]\/ weights[0, 1]\n\norder = np.argsort(X[:, 0])\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.plot(X[ones, 0], X[ones, 1], 'ob',\n         X[zeros, 0], X[zeros, 1], 'or',\n         X[order, 0], y_pred[order], '-g');","b8144dfc":"X.shape","fff77c93":"## \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043b\u0438\u043d\u0435\u0439\u043d\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438","2d41bd2c":"## \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0433\u0440\u0430\u0444\u0444\u0430 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0439 \u0438 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u0435 \u043c\u043e\u0434\u0435\u043b\u0438","917eb0e7":"## \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c \u0440\u0430\u0437\u0434\u0435\u043b\u044f\u044e\u0449\u0443\u044e \u0433\u0438\u043f\u0435\u0440\u043f\u043b\u043e\u0441\u043a\u043e\u0441\u0442\u044c","7c556323":"### \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435","b7b41cab":"## \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c \u043a\u0440\u0438\u0432\u0443\u044e \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f","c67122b6":"## \u0412\u0441\u043f\u043e\u043c\u043e\u0433\u0430\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439"}}