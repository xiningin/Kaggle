{"cell_type":{"04d814e2":"code","87c99dbd":"code","e6277ffc":"code","78d9b61f":"code","65810364":"code","f1120b91":"code","0adc587c":"code","04f64ec6":"code","436e46bb":"code","05ee5485":"code","35ca1baf":"code","8b4c8278":"code","c73cefe5":"code","2a3f99e7":"code","947f8d04":"code","0bdbc079":"code","2ed5cb85":"code","5deed1be":"code","1e73f1bd":"code","46057a53":"code","14adcae3":"code","d7da8e7e":"code","060567df":"code","43c89f6d":"code","98409ec3":"code","73a16064":"code","3792eb75":"code","046b880b":"code","7ed6d616":"code","7e3aa7f8":"markdown","d4093486":"markdown","b5ac7e11":"markdown","9f20989c":"markdown","42c3836f":"markdown","1c24a4ba":"markdown","f67da10d":"markdown","69bbf14a":"markdown","e05c2fac":"markdown","0ca78072":"markdown","730451f0":"markdown","dcbc48a9":"markdown","81e0bf69":"markdown","d80f9b6a":"markdown","dfdae45f":"markdown","5c373ce5":"markdown"},"source":{"04d814e2":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport random\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import MinMaxScaler, StandardScaler\nfrom lightgbm import LGBMClassifier\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.cluster import MiniBatchKMeans\n\n\n# Pandas setting to display more dataset rows and columns\npd.set_option('display.max_rows', 150)\npd.set_option('display.max_columns', 500)\npd.set_option('display.max_colwidth', None)\npd.set_option('display.float_format', lambda x: '%.5f' % x)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","87c99dbd":"train = pd.read_csv(\"\/kaggle\/input\/tabular-playground-series-sep-2021\/train.csv\", low_memory=False)#, nrows=10000)\ntest = pd.read_csv(\"\/kaggle\/input\/tabular-playground-series-sep-2021\/test.csv\", low_memory=False)#, nrows=10000)\ntrain.info(memory_usage=\"deep\")","e6277ffc":"test.info(memory_usage=\"deep\")","78d9b61f":"# Colors to be used for plots\ncolors = [\"lightcoral\", \"sandybrown\", \"darkorange\", \"mediumseagreen\",\n          \"lightseagreen\", \"cornflowerblue\", \"mediumpurple\", \"palevioletred\",\n          \"lightskyblue\", \"sandybrown\", \"yellowgreen\", \"indianred\",\n          \"lightsteelblue\", \"mediumorchid\", \"deepskyblue\"]","65810364":"train.head()","f1120b91":"train.columns.values","0adc587c":"fig, ax = plt.subplots(figsize=(5, 5))\npie = ax.pie([len(train), len(test)],\n             labels=[\"Train dataset\", \"Test dataset\"],\n             colors=[\"salmon\", \"teal\"],\n             textprops={\"fontsize\": 15},\n             autopct='%1.1f%%')\nax.axis(\"equal\")\nax.set_title(\"Dataset length comparison\", fontsize=18)\nfig.set_facecolor('white')\nplt.show();","04f64ec6":"train.describe().T","436e46bb":"fig, ax = plt.subplots(figsize=(6, 6))\n\nbars = ax.bar(train[\"claim\"].value_counts().index,\n              train[\"claim\"].value_counts().values,\n              color=colors,\n              edgecolor=\"black\",\n              width=0.4)\nax.set_title(\"Claim (target) values distribution\", fontsize=20, pad=15)\nax.set_ylabel(\"Amount of values\", fontsize=14, labelpad=15)\nax.set_xlabel(\"Claim (target) value\", fontsize=14, labelpad=10)\nax.set_xticks(train[\"claim\"].value_counts().index)\nax.tick_params(axis=\"both\", labelsize=14)\nax.bar_label(bars, [f\"{x:2.2f}%\" for x in train[\"claim\"].value_counts().values\/(len(train)\/100)],\n                 padding=5, fontsize=15)\nax.bar_label(bars, [f\"{x:2d}\" for x in train[\"claim\"].value_counts().values],\n                 padding=-30, fontsize=15)\nax.margins(0.2, 0.12)\nax.grid(axis=\"y\")\n\nplt.show();","05ee5485":"fig, ax = plt.subplots(figsize=(16, 6))\n\nbars = ax.bar(train.isna().sum().index,\n              train.isna().sum().values,\n              color=\"lightskyblue\",\n              edgecolor=\"black\",\n              width=0.7)\nax.set_title(\"Missing feature values distribution in the train dataset\", fontsize=20, pad=15)\nax.set_ylabel(\"Missing values\", fontsize=14, labelpad=15)\nax.set_xlabel(\"Feature\", fontsize=14, labelpad=10)\nax.set_xticks([x if i%2==0 else \"\" for i, x in enumerate(train.columns.values)])\nax.tick_params(axis=\"x\", rotation=90, labelsize=8)\nax.margins(0.005, 0.12)\nax.grid(axis=\"y\")\n\nplt.show();","35ca1baf":"fig, ax = plt.subplots(figsize=(16, 6))\n\nbars = ax.bar(test.isna().sum().index,\n              test.isna().sum().values,\n              color=\"lightsteelblue\",\n              edgecolor=\"black\",\n              width=0.7)\nax.set_title(\"Missing feature values distributionin in the test dataset\", fontsize=20, pad=15)\nax.set_ylabel(\"Missing values\", fontsize=14, labelpad=15)\nax.set_xlabel(\"Feature\", fontsize=14, labelpad=10)\nax.set_xticks([x if i%2==0 else \"\" for i, x in enumerate(test.columns.values)])\nax.tick_params(axis=\"x\", rotation=90, labelsize=8)\nax.margins(0.005, 0.12)\nax.grid(axis=\"y\")\n\nplt.show();","8b4c8278":"df = pd.DataFrame()\ndf[\"n_missing\"] = train.drop([\"id\", \"claim\"], axis=1).isna().sum(axis=1)\ndf[\"claim\"] = train[\"claim\"].copy()\n\nfig, ax = plt.subplots(figsize=(12,5))\nax.hist(df[df[\"claim\"]==0][\"n_missing\"],\n        bins=40, edgecolor=\"black\",\n        color=\"darkseagreen\", alpha=0.7, label=\"claim is 0\")\nax.hist(df[df[\"claim\"]==1][\"n_missing\"],\n        bins=40, edgecolor=\"black\",\n        color=\"darkorange\", alpha=0.7, label=\"claim is 1\")\nax.set_title(\"Missing values distributionin in each target class\", fontsize=20, pad=15)\nax.set_xlabel(\"Missing values per row\", fontsize=14, labelpad=10)\nax.set_ylabel(\"Amount of rows\", fontsize=14, labelpad=10)\nax.legend(fontsize=14)\nplt.show();","c73cefe5":"df = pd.concat([train.drop([\"id\", \"claim\"], axis=1), test.drop(\"id\", axis=1)], axis=0)\ncolumns = df.columns.values\n\ncols = 4\nrows = len(columns) \/\/ cols + 1\n\nfig, axs = plt.subplots(ncols=cols, nrows=rows, figsize=(16,130), sharex=False)\n\nplt.subplots_adjust(hspace = 0.3)\ni=0\n\nfor r in np.arange(0, rows, 1):\n    for c in np.arange(0, cols, 1):\n        if i >= len(columns):\n            axs[r, c].set_visible(False)\n        else:\n            hist1 = axs[r, c].hist(train[columns[i]].values,\n                                   range=(df[columns[i]].min(),\n                                          df[columns[i]].max()),\n                                   bins=40,\n                                   color=\"deepskyblue\",\n                                   edgecolor=\"black\",\n                                   alpha=0.7,\n                                   label=\"Train Dataset\")\n            hist2 = axs[r, c].hist(test[columns[i]].values,\n                                   range=(df[columns[i]].min(),\n                                          df[columns[i]].max()),\n                                   bins=40,\n                                   color=\"palevioletred\",\n                                   edgecolor=\"black\",\n                                   alpha=0.7,\n                                   label=\"Test Dataset\")\n            axs[r, c].set_title(columns[i], fontsize=12, pad=5)\n            axs[r, c].set_yticks(axs[r, c].get_yticks())\n            axs[r, c].set_yticklabels([str(int(i\/1000))+\"k\" for i in axs[r, c].get_yticks()])\n            axs[r, c].tick_params(axis=\"y\", labelsize=10)\n            axs[r, c].tick_params(axis=\"x\", labelsize=10)\n            axs[r, c].grid(axis=\"y\")\n            axs[r, c].legend(fontsize=13)\n                                  \n        i+=1\n#plt.suptitle(\"Feature values distribution in both datasets\", y=0.99)\nplt.show();","2a3f99e7":"print(\"Features with the leas amount of unique values:\")\ntrain.drop([\"id\", \"claim\"], axis=1).nunique().sort_values().head(5)","947f8d04":"# Plot dataframe\ndf = train.drop(\"id\", axis=1).corr().round(5)\n\n# Mask to hide upper-right part of plot as it is a duplicate\nmask = np.zeros_like(df)\nmask[np.triu_indices_from(mask)] = True\n\n# Making a plot\nplt.figure(figsize=(16,16))\nax = sns.heatmap(df, annot=False, mask=mask, cmap=\"RdBu\", annot_kws={\"weight\": \"bold\", \"fontsize\":13})\nax.set_title(\"Feature correlation heatmap\", fontsize=17)\nplt.setp(ax.get_xticklabels(), rotation=90, ha=\"right\",\n         rotation_mode=\"anchor\", weight=\"normal\")\nplt.setp(ax.get_yticklabels(), weight=\"normal\",\n         rotation_mode=\"anchor\", rotation=0, ha=\"right\")\nplt.show();","0bdbc079":"df[(df[\"claim\"]>-0.001) & (df[\"claim\"]<0.001)][\"claim\"]","2ed5cb85":"features = [x for x in train.columns.values if x[0]==\"f\"]","5deed1be":"# Counting amount of missing values in each row and adding it as a new feature\ntrain['n_missing'] = train[features].isna().sum(axis=1)\ntest['n_missing'] = test[features].isna().sum(axis=1)","1e73f1bd":"# Filling missing values with median of each column\nimputer = SimpleImputer(strategy=\"median\")\nfor col in features:\n    train[col] = imputer.fit_transform(np.array(train[col]).reshape(-1,1))\n    test[col] = imputer.transform(np.array(test[col]).reshape(-1,1))","46057a53":"# New features indicating if a value is near zero or not\ntrain[\"f5_zero\"] = (train[\"f5\"] < 0.02).astype(int)\ntest[\"f5_zero\"] = (test[\"f5\"] < 0.02).astype(int)\n\ntrain[\"f50_zero\"] = (train[\"f50\"] < 0.02).astype(int)\ntest[\"f50_zero\"] = (test[\"f50\"] < 0.02).astype(int)","14adcae3":"# Scaling all values\ns_scaler = StandardScaler()\nfor col in features:\n    train[col] = s_scaler.fit_transform(np.array(train[col]).reshape(-1,1))\n    test[col] = s_scaler.transform(np.array(test[col]).reshape(-1,1))","d7da8e7e":"X = train.drop([\"id\", \"claim\"], axis=1)\nX_test = test.drop(\"id\", axis=1)\ny = train[\"claim\"]","060567df":"# def train_model_optuna(trial, X_train, X_valid, y_train, y_valid):\n#     \"\"\"\n#     A function to train a model using different hyperparamerters combinations provided by Optuna. \n#     Loss of validation data predictions is returned to estimate hyperparameters effectiveness.\n#     \"\"\"\n#     preds = 0\n    \n        \n#     #A set of hyperparameters to optimize by optuna\n#     lgbm_params = {\n#                     \"objective\": trial.suggest_categorical(\"objective\", ['binary']),\n#                     \"boosting_type\": trial.suggest_categorical(\"boosting_type\", ['gbdt']),\n#                     \"num_leaves\": trial.suggest_int(\"num_leaves\", 2, 256),\n#                     \"max_depth\": trial.suggest_int(\"max_depth\", 1, 16),\n#                     \"learning_rate\": trial.suggest_float(\"learning_rate\", 0.1, 1, step=0.01),\n#                     \"n_estimators\": trial.suggest_categorical(\"n_estimators\", [40000]),        \n#                     \"reg_alpha\": trial.suggest_float(\"reg_alpha\", 0.1, 100.0, step=0.1),\n#                     \"reg_lambda\": trial.suggest_float(\"reg_lambda\", 0.1, 100.0, step=0.1),\n#                     \"random_state\": trial.suggest_categorical(\"random_state\", [42]),\n#                     \"bagging_seed\": trial.suggest_categorical(\"bagging_seed\", [42]),\n#                     \"feature_fraction_seed\": trial.suggest_categorical(\"feature_fraction_seed\", [42]), \n#                     \"n_jobs\": trial.suggest_categorical(\"n_jobs\", [4]), \n#                     \"subsample\": trial.suggest_float(\"subsample\", 0.6, 1, step=0.01),\n#                     \"subsample_freq\": trial.suggest_int(\"subsample_freq\", 1, 7),\n#                     \"colsample_bytree\": trial.suggest_float(\"colsample_bytree\", 0.05, 1, step=0.01),\n# #                     \"device_type\": trial.suggest_categorical(\"device_type\", [\"GPU\"]),\n#                     'min_child_samples': trial.suggest_int('min_child_samples', 5, 100),\n#                     'min_child_weight': trial.suggest_categorical('min_child_weight', [256]),\n        \n#                     }\n\n\n#     # Model loading and training\n#     model = LGBMClassifier(**lgbm_params)\n#     model.fit(X_train, y_train,\n#               eval_set=[(X_valid, y_valid)],\n#               eval_metric=\"auc\",\n#               early_stopping_rounds=100,\n#               verbose=False)\n    \n#     print(f\"Number of boosting rounds: {model.best_iteration_}\")\n#     oof = model.predict_proba(X_valid)[:, 1]\n    \n#     return roc_auc_score(y_valid, oof)","43c89f6d":"# %%time\n# # Splitting data into train and valid folds using target bins for stratification\n# X_train, X_valid, y_train, y_valid = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)\n\n# # Setting optuna verbosity to show only warning messages\n# # If the line is uncommeted each iteration results will be shown\n# # optuna.logging.set_verbosity(optuna.logging.WARNING)\n\n# time_limit = 3600 * 4\n\n# study = optuna.create_study(direction='maximize')\n# study.optimize(lambda trial: train_model_optuna(trial, X_train, X_valid,\n#                                                     y_train, y_valid),\n# #                n_trials = 2\n#                timeout=time_limit\n#               )\n\n# # Showing optimization results\n# print('Number of finished trials:', len(study.trials))\n# print('Best trial parameters:', study.best_trial.params)\n# print('Best score:', study.best_value)","98409ec3":"# Model hyperparameters\nlgbm_params = {'objective': 'binary',\n               'boosting_type': 'gbdt',\n               'num_leaves': 6,\n               'max_depth': 2,\n               'learning_rate': 0.1,\n               'n_estimators': 40000,\n               'reg_alpha': 25.0,\n               'reg_lambda': 76.7,\n               'random_state': 42,\n               'bagging_seed': 42, \n               'feature_fraction_seed': 42,\n               'n_jobs': 4,\n               'subsample': 0.98,\n               'subsample_freq': 1,\n               'colsample_bytree': 0.69,\n               'min_child_samples': 54,\n               'min_child_weight': 256}","73a16064":"%%time\n# Setting up fold parameters\nsplits = 20\nskf = StratifiedKFold(n_splits=splits, shuffle=True, random_state=42)\n\n# Creating an array of zeros for storing \"out of fold\" predictions\noof_preds = np.zeros((X.shape[0],))\npreds = 0\nmodel_fi = 0\ntotal_mean_auc = 0\n\n# Generating folds and making training and prediction for each of 10 folds\nfor num, (train_idx, valid_idx) in enumerate(skf.split(X, y)):\n    X_train, X_valid = X.loc[train_idx], X.loc[valid_idx]\n    y_train, y_valid = y.loc[train_idx], y.loc[valid_idx]\n    \n    model = LGBMClassifier(**lgbm_params)\n    model.fit(X_train, y_train,\n              verbose=False,\n              # These three parameters will stop training before a model starts overfitting \n              eval_set=[(X_train, y_train), (X_valid, y_valid)],\n              eval_metric=\"auc\",\n              early_stopping_rounds=300,\n              )\n    \n    # Getting mean test data predictions (i.e. devided by number of splits)\n    preds += model.predict_proba(X_test)[:, 1] \/ splits\n    \n    # Getting mean feature importances (i.e. devided by number of splits)\n    model_fi += model.feature_importances_ \/ splits\n    \n    # Getting validation data predictions. Each fold model makes predictions on an unseen data.\n    # So in the end it will be completely filled with unseen data predictions.\n    # It will be used to evaluate hyperparameters performance only.\n    oof_preds[valid_idx] = model.predict_proba(X_valid)[:, 1]\n    \n    # Getting score for a fold model\n    fold_auc = roc_auc_score(y_valid, oof_preds[valid_idx])\n    print(f\"Fold {num} ROC AUC: {fold_auc}\")\n\n    # Getting mean score of all fold models (i.e. devided by number of splits)\n    total_mean_auc += fold_auc \/ splits\n    \nprint(f\"\\nOverall ROC AUC: {total_mean_auc}\")","3792eb75":"# Creating a dataframe to be used for plotting\ndf = pd.DataFrame()\ndf[\"Feature\"] = X.columns\n# Extracting feature importances from the trained model\ndf[\"Importance\"] = model_fi \/ model_fi.sum()\n# Sorting the dataframe by feature importance\ndf.sort_values(\"Importance\", axis=0, ascending=False, inplace=True)","046b880b":"fig, ax = plt.subplots(figsize=(13, 35))\nbars = ax.barh(df[\"Feature\"], df[\"Importance\"], height=0.4,\n               color=\"mediumorchid\", edgecolor=\"black\")\nax.set_title(\"Feature importances\", fontsize=30, pad=15)\nax.set_ylabel(\"Feature name\", fontsize=20, labelpad=15)\nax.set_xlabel(\"Feature importance\", fontsize=20, labelpad=15)\nax.set_yticks(df[\"Feature\"])\nax.set_yticklabels(df[\"Feature\"], fontsize=15)\nax.tick_params(axis=\"x\", labelsize=15)\nax.grid(axis=\"x\")\n# Adding labels on top\nax2 = ax.secondary_xaxis('top')\nax2.set_xlabel(\"Feature importance\", fontsize=20, labelpad=15)\nax2.tick_params(axis=\"x\", labelsize=15)\n\n# Inverting y axis direction so the values are decreasing\nplt.gca().invert_yaxis()","7ed6d616":"predictions = pd.DataFrame()\npredictions[\"id\"] = test[\"id\"]\npredictions[\"claim\"] = preds\n\npredictions.to_csv('submission.csv', index=False, header=predictions.columns)\npredictions.head()","7e3aa7f8":"# **EDA**","d4093486":"# **Feature importances**","b5ac7e11":"Hyperparameters used in this notebook were optimized using Optuna. The code used or that is shown below. They are commented in order to save runtime as optimization has been already done.","9f20989c":"# **Data import**","42c3836f":"As you can see, samples without any missing values are way more likely to belong to \"claim 0\" class. On the other hand, if there are any missing values it is way more likely for a sample to belong to \"claim 1\" class.\n\nLet's check feature values distribution in the both datasets.","1c24a4ba":"# **Predictions submission**","f67da10d":"Probably worth a try to drop them and check if it improves the result.","69bbf14a":"There are no categorical features in the dataset.\n\nLet's look at feature correlation.","e05c2fac":"# **Data preprocessing**","0ca78072":"# **Hyperparameters optimization**","730451f0":"# **Model training**","dcbc48a9":"As you can see, the datasets are well balanced. So target distribution should probably be the same for test predictions.","81e0bf69":"As you can see, both train and test datasets have missing values in every feature except for \"id\" and \"claim\". We should take care with them.\n\nLet's check the difference in amount of missing values per row distribution for each target class.","d80f9b6a":"The target value classes are balanced which is good.","dfdae45f":"The idea of adding the \"n_missing\" feature below is taken from [this notebook](https:\/\/www.kaggle.com\/hiro5299834\/tps-sep-2021-single-lgbm) by [BIZEN](https:\/\/www.kaggle.com\/hiro5299834).","5c373ce5":"There is very weak linear correlation between the features. There are some features with relatively low correlation with target value even comparing with other features:"}}