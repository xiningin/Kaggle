{"cell_type":{"02284713":"code","065652af":"code","a3a0fd58":"code","41314891":"code","bdc21bf9":"code","ef5bb59e":"code","9eae95e7":"code","5e7f0d49":"code","db8c0799":"code","fd5a1310":"code","02e3065b":"code","22bb9c1b":"code","6b508667":"code","ce64aee7":"code","6eaec47a":"code","ca8c4ae3":"code","7eaa0397":"code","a1c9c310":"code","dcecc02f":"code","3489dd79":"code","a3e9b3c9":"code","c755bdbe":"markdown","9d4fe124":"markdown","1d500b8f":"markdown","a83f9aa9":"markdown","774088dc":"markdown","d5e3e85e":"markdown"},"source":{"02284713":"from fastai.vision.all import *","065652af":"input_path = Path(\"..\/input\/digit-recognizer\/\")\ntrain = pd.read_csv(input_path\/\"train.csv\")","a3a0fd58":"from torchvision import transforms\n\nclass NumberDataset:\n    def __init__(self, data, transform=None):\n        self.data = data.reset_index(drop=True)\n        self.trans = transform\n    \n    def __len__(self):\n        return self.data.shape[0]\n    \n    def __getitem__(self, index):\n        \n        d = self.data.iloc[index, 1:].values.reshape(1, 28, 28)\n        \n        if self.trans:\n            d = self.trans(tensor(d))\n        else:\n            d = tensor(d)\/255\n        \n        y = self.data.iloc[index, 0]\n        \n        return d, tensor(y)","41314891":"train_idx, valid_idx = RandomSplitter()(train)\n\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n\ntrain_ds = NumberDataset(train.iloc[train_idx, :])\nvalid_ds = NumberDataset(train.iloc[valid_idx, :])\n\ntrain_dl = DataLoader(train_ds, bs=64)\nvalid_dl = DataLoader(valid_ds, bs=128)\n\ndls = DataLoaders(train_dl, valid_dl).to(device)","bdc21bf9":"class ResidualBlock(nn.Module):\n    def __init__(self, ni: int, nf: int):\n        \n        super().__init__()\n        \n        # shorcut\n        if ni < nf:\n            self.shortcut = nn.Sequential(\n                nn.Conv2d(ni, nf, kernel_size=1, stride=2),\n                nn.BatchNorm2d(nf))\n            first_stride = 2\n        else:\n            self.shortcut = lambda x: x\n            first_stride = 1\n        \n        # convnet\n        self.conv = nn.Sequential(\n            nn.Conv2d(ni, nf, kernel_size=3, stride=first_stride, padding=1),\n            nn.BatchNorm2d(nf),\n            nn.ReLU(True),\n            nn.Conv2d(nf, nf, kernel_size=3, stride=1, padding=1),\n            nn.BatchNorm2d(nf)\n        )\n    \n    def forward(self, x):\n        return F.relu(self.conv(x) + self.shortcut(x))","ef5bb59e":"def get_resnet(n_classes, n_in, n_layers, device=\"cpu\"):\n    return nn.Sequential(\n        nn.Conv2d(n_in, 64, kernel_size=7, stride=2, padding=3),\n        nn.BatchNorm2d(64),\n        nn.ReLU(),\n        nn.MaxPool2d(3, stride=2, padding=1),\n        *[ResidualBlock(64, 64)] * n_layers[0],\n        ResidualBlock(64, 128),\n        *[ResidualBlock(128, 128)] * n_layers[1],\n        ResidualBlock(128, 256),\n        *[ResidualBlock(256, 256)] * n_layers[2],\n        ResidualBlock(256, 512),\n        *[ResidualBlock(512, 512)] * n_layers[2],\n        nn.AdaptiveAvgPool2d(1),\n        nn.Flatten(),\n        nn.Linear(512, n_classes)\n    ).to(device)\n\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\nresent18_model = get_resnet(10, n_in=1, n_layers=[2, 1, 1, 1], device=device)","9eae95e7":"learn = Learner(dls, resent18_model, metrics=accuracy, \n                loss_func=nn.CrossEntropyLoss())","5e7f0d49":"learn.lr_find()","db8c0799":"learn.fit_one_cycle(5, 1e-3)","fd5a1310":"preds, targs = learn.get_preds()","02e3065b":"from sklearn.metrics import confusion_matrix\nimport seaborn as sns\n\n\nfig = plt.figure(dpi=150)\nsns.heatmap(confusion_matrix(targs, preds.argmax(1)), cmap=\"Blues\",\n            square=True, annot=True);","22bb9c1b":"class BottleneckBlock(nn.Module):\n    def __init__(self, ni: int, nf: int):\n        \n        super().__init__()\n        \n        # shortcut\n        if ni < nf:\n            stride = 1 if ni == 64 else 2\n            self.shortcut = nn.Sequential(\n                nn.Conv2d(ni, nf, kernel_size=1, stride=stride),\n                nn.BatchNorm2d(nf)\n            )\n        else:\n            self.shortcut = lambda x: x\n            stride = 1\n        \n        # convnet\n        self.conv = nn.Sequential(\n            nn.Conv2d(ni, nf\/\/4, kernel_size=1, stride=1),\n            nn.BatchNorm2d(nf\/\/4),\n            nn.ReLU(True),\n            nn.Conv2d(nf\/\/4, nf\/\/4, kernel_size=3, stride=stride, padding=1),\n            nn.BatchNorm2d(nf\/\/4),\n            nn.ReLU(True),\n            nn.Conv2d(nf\/\/4, nf, kernel_size=1, stride=1),\n            nn.BatchNorm2d(nf)\n        )\n        \n    def forward(self, x):\n        return F.relu(self.conv(x) + self.shortcut(x))","6b508667":"def get_resnet_bottleneck(n_classes, n_in, n_layer, device=\"cpu\"):\n    return nn.Sequential(\n        nn.Conv2d(n_in, 64, kernel_size=7, stride=2, padding=3),\n        nn.BatchNorm2d(64),\n        nn.ReLU(),\n        nn.MaxPool2d(3, stride=2, padding=1),\n        BottleneckBlock(64, 256),\n        *[BottleneckBlock(256, 256)] * n_layer[0],\n        BottleneckBlock(256, 512),\n        *[BottleneckBlock(512, 512)] * n_layer[1],\n        BottleneckBlock(512, 1024),\n        *[BottleneckBlock(1024, 1024)] * n_layer[2],\n        BottleneckBlock(1024, 2048),\n        *[BottleneckBlock(2048, 2048)] * n_layer[3],\n        nn.AdaptiveAvgPool2d(1),\n        nn.Flatten(),\n        nn.Linear(2048, n_classes)\n        ).to(device)\n\nresnet50_model = get_resnet_bottleneck(10, 1, [2, 3, 5, 2], device=device)","ce64aee7":"learn2 = Learner(dls, resnet50_model, metrics=accuracy, \n                loss_func=nn.CrossEntropyLoss())\nlearn2.lr_find()","6eaec47a":"learn2.fit_one_cycle(5, 1e-3)","ca8c4ae3":"preds, targs = learn2.get_preds()","7eaa0397":"fig = plt.figure(dpi=150)\nsns.heatmap(confusion_matrix(targs, preds.argmax(1)), cmap=\"Blues\",\n            square=True, annot=True);","a1c9c310":"test = pd.read_csv(input_path\/\"test.csv\")","dcecc02f":"class TestDS(NumberDataset):\n    def __getitem__(self, index):\n        \n        d = self.data.iloc[index, :].values.reshape(1, 28, 28)\n        \n        if self.trans:\n            d = self.trans(tensor(d)\/255)\n        else:\n            d = tensor(d)\/255\n        \n        return d, tensor(0)\n\n\n\ntest_ds = TestDS(test)\ntest_dl = DataLoader(test_ds, bs=128, device=device)","3489dd79":"preds, targ = learn.get_preds(dl=test_dl)","a3e9b3c9":"sub = pd.read_csv(input_path\/\"sample_submission.csv\")\nsub[\"Label\"] = np.argmax(preds, axis=1)\nsub.to_csv(\"submission.csv\", index=False)","c755bdbe":"# Build Resnet with Bottleneck Block","9d4fe124":"You can also get Resnet101 and Resnet152 by passing `n_layer=[2, 3, 22, 2]` and `n_layer=[2, 7, 35, 2]` respectively into the function.","1d500b8f":"You can get a Resnet34 model by passing `n_layer=[3, 3, 5, 2]` into the function.","a83f9aa9":"# Prepare our training data","774088dc":"# Build Resnet and Train the model","d5e3e85e":"# Make prediction on the test set"}}