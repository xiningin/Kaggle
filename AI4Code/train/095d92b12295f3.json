{"cell_type":{"9702e9d1":"code","5de7a6e6":"code","9b3e4617":"code","bb9b121d":"code","9d1677a2":"code","4ef39133":"code","294dd9d7":"code","ecb728c6":"code","85b38acc":"code","4674a264":"code","f086aceb":"code","c4e450f9":"code","68180b58":"code","adabe4ee":"code","f71c4359":"code","503efb51":"code","7d2aa91c":"code","74200cc5":"code","c0410895":"code","93c7b943":"code","f88b7d83":"code","8ebad864":"code","5e2c6a8c":"code","d1d6ecc4":"code","57ca6c31":"code","96898ce5":"code","c68a16be":"code","e55a0342":"code","167bedd3":"code","a4d37ed8":"code","6e34d182":"code","d093be01":"code","23816316":"code","162f053d":"code","c153dbe2":"code","127f3e0f":"code","4f792d43":"code","23617ccc":"code","b9511349":"code","826e5b48":"code","81854912":"code","8be128eb":"code","ab56726b":"code","61140149":"code","018fe0ca":"code","7ace6619":"code","51bfe54c":"code","293b6d7b":"code","11662d3a":"code","b87a5816":"code","cb7c5d95":"code","65a096db":"code","ee2327f9":"code","99374bf2":"code","ad872ba0":"code","ff75f320":"code","8676b407":"markdown","e2ba9ca2":"markdown","47427c42":"markdown","23841ce1":"markdown","f724f43b":"markdown","f46b7978":"markdown","0d19dcfc":"markdown","0389e2e8":"markdown","b37edf56":"markdown","a592eb66":"markdown","4badcb86":"markdown","1eaa977d":"markdown","290f491b":"markdown","9d0857de":"markdown","0dc6ef72":"markdown","11082142":"markdown","6d6234e4":"markdown","423e003e":"markdown","f1cda44f":"markdown","c95ec968":"markdown","c7addc17":"markdown","250000ee":"markdown","9970efda":"markdown","cac24b8e":"markdown","d8213e1a":"markdown"},"source":{"9702e9d1":"#setup\n%matplotlib inline\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nimport statsmodels.api as sm\nimport statsmodels.formula.api as smf\nimport matplotlib.patches as mpatches\nimport warnings\nfrom dateutil import parser\nfrom datetime import datetime, timedelta\nfrom matplotlib import rcParams\nfrom sklearn.cluster import KMeans\nfrom matplotlib.lines import Line2D\n\nwarnings.filterwarnings('ignore')\n\nrcParams['figure.figsize'] = (10, 6)\nrcParams['figure.dpi'] = 150\nrcParams['lines.linewidth'] = 2\nrcParams['axes.grid'] = False\nrcParams['axes.facecolor'] = 'white'\nrcParams['font.size'] = 14\nrcParams['patch.edgecolor'] = 'none'\n\ndef remove_border(axes=None, top=False, right=False, left=True, bottom=True):\n    \"\"\"\n    Minimize chartjunk by stripping out unnecessary plot borders and axis ticks\n    \n    The top\/right\/left\/bottom keywords toggle whether the corresponding plot border is drawn\n    \"\"\"\n    ax = axes or plt.gca()\n    ax.spines['top'].set_visible(top)\n    ax.spines['right'].set_visible(right)\n    ax.spines['left'].set_visible(left)\n    ax.spines['bottom'].set_visible(bottom)\n    \n    #turn off all ticks\n    ax.yaxis.set_ticks_position('none')\n    ax.xaxis.set_ticks_position('none')\n    \n    #now re-enable visibles\n    if top:\n        ax.xaxis.tick_top()\n    if bottom:\n        ax.xaxis.tick_bottom()\n    if left:\n        ax.yaxis.tick_left()\n    if right:\n        ax.yaxis.tick_right()","5de7a6e6":"# time series of daily cumualtive confirmed cases\ncase_df = pd.read_csv('\/kaggle\/input\/covid19-data\/time_series_covid19_confirmed_global.csv')\n\n# cleaned time series. each column is a country. each row is cum. cases since the day of first confirmed case\ncase_df_day0 = pd.read_csv('\/kaggle\/input\/covid19-data\/cum_cases_from_day0.csv')\n\n# stringency index\npolicy_df = pd.read_csv('\/kaggle\/input\/covid19-data\/OxCGRT_latest.csv')\n\n# cleaned stringency index. each column is a country\npolicy_df_day0 = pd.read_csv('\/kaggle\/input\/covid19-data\/stringency_index_from_day0.csv')\npolicy_df_day0 = policy_df_day0.set_index('days_since')\n\n# cleaned country-level data: \n# dates reaching certain thresholds of confirmed cases and country-level covariates\ncountry_df = pd.read_csv('\/kaggle\/input\/code-result\/country_background_result.csv')","9b3e4617":"# aggregate stringency index by week, into 10 even intervals\n# week 0 is the first week since the date of the first confirmed case\n# negative week numbers represent weeks before the date of first case\n\n# convert days to weeks\npolicy_df_day0['weeks_since'] = policy_df_day0.index.map(lambda n: n \/\/ 7)\n\n# calculate weekly means\nweekly = policy_df_day0.groupby('weeks_since').mean()\n\n# turn numeric values into 10 intervals\nweekly = weekly.apply(lambda col: pd.cut(col, np.arange(0.0, 110.0, 10.0), include_lowest=True), axis=0)\n\n# plot heatmap from week -5 to week 8 (other weeks omitted due to large scale of missing data )\ncounts = weekly.loc[-5:8].apply(lambda row: row.value_counts(), axis=1).transpose()\n\n# order row names\nrow_names = counts.index.tolist()\nrow_names.sort()\nrow_names.reverse()\n\ncounts = counts.reindex(index = row_names)\nsns.heatmap(counts, cmap=sns.light_palette(\"navy\"))\nplt.xlabel('Week')\n\n# remove column weeks_since\npolicy_df_day0 = policy_df_day0.drop(columns='weeks_since')","bb9b121d":"country_df.cluster5.value_counts()","9d1677a2":"# create dataset for plotting below\ndef create_df_after_N(N):    \n    \"\"\"\n    Return a subset of cumulative cases per country, starting from the date of at least N case.\n    \"\"\"\n    ls = []\n\n    for i, row in country_df.iterrows():\n        if pd.notnull(row['days_to_%i'%N]):\n            stop = int(row['days_to_%i'%N]) + 1\n            ls.append(case_df_day0[row.country][stop:].reset_index(drop=True))\n\n    return pd.concat(ls, axis=1)\n\ncase_df_after_500 = create_df_after_N(500)","4ef39133":"order_to_plot = ['Proactive', 'Swiftly Responsive', 'Responsive', 'Moderately Responsive', 'Slow Start']\nn_clusters = 5\n\nfig, axes = plt.subplots(2, n_clusters, sharey='row', figsize=(20, 8))\n\nfor j in range(n_clusters):\n    countries = country_df[country_df.cluster5==order_to_plot[j]].country\n    countries = [country for country in countries if country in case_df_after_500.columns]\n\n    # in first row, plot country stringency index\n    axes[0, j].plot(policy_df_day0.loc[-15:30, countries], color='tab:blue', alpha=0.4)\n    axes[0, j].axvline(x=0, c='black', linestyle=':')\n    axes[0, j].set_title('%s (%i)'%(order_to_plot[j], sum(country_df['cluster5']==order_to_plot[j])))\n    if j == 0:\n        axes[0, j].set_ylabel('Stringency index')\n    remove_border(axes[0, j])\n\n    # in second row, plot infection curves since 500th case\n    axes[1, j].plot(case_df_after_500[countries], color='tab:red', alpha=0.4)\n    axes[1, j].set_xlabel('Day')\n    axes[1, j].set_ylim(0, 100000)\n    if j == 0:\n        axes[1, j].set_ylabel('Cum. cases since 500th case')\n    remove_border(axes[1, j])\n    \nplt.suptitle('Typology of Early National Responses to Covid-19')","294dd9d7":"# display top three largest countries in each cluster (largest population)\ntop_three = country_df.sort_values(['cluster5', 'PopTotal'], ascending=False).groupby('cluster5').apply(lambda df: df.iloc[:3])\n\nfig, axes = plt.subplots(1, n_clusters, sharex=True, sharey='row', figsize=(20, 4))\nfor j in range(n_clusters):\n    countries = top_three[top_three.cluster5==order_to_plot[j]].country\n    countries = [country for country in countries if country in case_df_after_500.columns]\n\n    policy_df_day0.loc[-15:30, countries].plot(ax=axes[j])\n\n    axes[j].set_title(order_to_plot[j])\n    axes[j].set_xlabel('Day')\n    if j == 0:\n        axes[j].set_ylabel('Stringency Index')    \n    axes[j].legend()\n    remove_border(axes[j])","ecb728c6":"# create country group order based on their wealth and life expectancy level\ncountry_category_wealth_order = ['LowestGDPLowestLifeExp', 'LowerGDPLowerLifeExp', 'MedGDPHigherDensity', 'MedGDPHigherDensity', 'HigherGDPLongerLifeExp', 'HighestGDPLongestLifeExp']\n\nmetrics = ['GDP2018PerCapita', 'PopDensity', 'LifeExpectancy2018']\nsns.set(style='dark')\nfig, axes = plt.subplots(1, 3, sharex=True, figsize=(20, 4))\n\nfor index, metric in enumerate(metrics):\n    sns.boxenplot(x=\"country_category_name\", y=metric, data=country_df, ax=axes[index%3])\n    axes[index%3].set_xticklabels(['LowestGDP\\nLowestLifeExp', 'LowerGDP\\nLowerLifeExp', 'MedGDP\\nHigherDensity', 'MedGDP\\nHigherDensity', 'HigherGDP\\nLongerLifeExp', 'HighestGDP\\nLongestLifeExp'], rotation = 45, ha=\"right\")\n    remove_border(axes[index%3])","85b38acc":"sns.set(style='dark')\norder_to_plot = ['Proactive', 'Swiftly Responsive', 'Responsive', 'Moderately Responsive', 'Slow Start']\n\nfig, axes = plt.subplots(3, 2, sharex=True, sharey=True)\npalette = plt.get_cmap('RdPu_r')\n\nfor i in range(3):\n    for j in range(2):\n        cat = country_category_wealth_order[i*2+j] # category name\n        \n        # plot countries in each policy cluser in a separate color \n        for cluster, df in country_df[country_df.country_category_name==cat].groupby('cluster5'):\n            countries = df.country # countries in the category\n            color = palette(order_to_plot.index(cluster)*50)\n            axes[i, j].plot(case_df_after_500[countries], color=color, alpha=0.6)\n        axes[i, j].set_title(cat)\n        \n\n# customize legend\nlines = [Line2D([0], [0], color=palette(i*50), lw=2) for i in range(5)]\nfig.legend(lines, order_to_plot, loc='lower center', ncol=5)","4674a264":"# use Responsive group as baseline group\ncountry_df['cluster5_o'] = country_df.cluster5.map(lambda name: '0'+name if name=='Swiftly Responsive' else name)\n\nres = []\nres.append(smf.ols(formula='days_500_1000 ~ cluster5_o + np.log(PopTotal) + PopDensity + np.log(GDP2018) + continent', data=country_df).fit())\nres.append(smf.ols(formula='days_500_2000 ~ cluster5_o + np.log(PopTotal) + PopDensity + np.log(GDP2018) + continent', data=country_df).fit())\nres.append(smf.ols(formula='days_1000_2000 ~ cluster5_o + np.log(PopTotal) + PopDensity + np.log(GDP2018) + continent', data=country_df).fit())\n\nlabels = ['DV: days 500-1000', 'DV: days 500-2000', 'DV: days 1000-2000']\n\nfor i in range(3):\n    x = res[i].params[1:5]\n    err = (res[i].conf_int()[1] - res[i].params)[1:5]\n    plt.errorbar(x = x, y = np.arange(4)+(i-1)*0.1, xerr = err, fmt=' ', label=labels[i])\n    plt.scatter(x = x, y = np.arange(4)+(i-1)*0.1)\n\n    \nplt.yticks(np.arange(4), ['Moderately Responsive', 'Proactive', 'Responsive', 'Slow Start'])    \nplt.xlabel('Effect Size')\nplt.axvline(x=0, linestyle=':', color='black')\nplt.legend()    \nplt.title('Regression Models of National Response Types on Infection Rates \\n (with Controls)')\nremove_border()","f086aceb":"# Find if there is correlation between policy intensity and infection case number by day 55\n# if we are controling country types\n\nregression_by_country_category = country_df[['country', 'cluster5', 'country_category_name']]\n\n# Find each country's infection number by day 55\n# Because the Covid19 pandemic is still developing,\n# with the current data day 55 is one of the latest date that we have data of all the countries' infection rate\ncountry_55 = case_df_day0.transpose().reset_index().rename(columns={'index': 'country'})[['country', 55]]\n\n# Add infection number by day 55 to regression_by_country_category\nregression_by_country_category = pd.merge(regression_by_country_category, country_55, on='country', how='left')\nregression_by_country_category = regression_by_country_category.rename(columns={'cluster5': 'policy_response_type', 55: 'day_55_case_num'})","c4e450f9":"# Linear Regression for countries with less resources\nfrom statsmodels.formula.api import ols\ncountry0 = regression_by_country_category[regression_by_country_category['country_category_name']=='LowestGDPLowestLifeExp']\nfit = ols('day_55_case_num ~ C(policy_response_type)', data=country0).fit() \n\nprint(fit.summary())","68180b58":"# Linear Regression for average and wealthier countries\ncountry1to5 = regression_by_country_category[regression_by_country_category['country_category_name']!='LowestGDPLowestLifeExp']\nfit = ols('day_55_case_num ~ C(policy_response_type)', data=country1to5).fit() \n\nprint(fit.summary())","adabe4ee":"# read raw data\n\n# time series of daily cumualtive confirmed cases\ncase_df = pd.read_csv('\/kaggle\/input\/covid19-data\/time_series_covid19_confirmed_global.csv')\n\n# stringency index\npolicy_df = pd.read_csv('\/kaggle\/input\/covid19-data\/OxCGRT_latest.csv')\n\n# country-level covariates\npop_df = pd.read_csv('\/kaggle\/input\/covid19-data\/WPP2019_TotalPopulationBySex.csv')\ngdp_df = pd.read_csv('\/kaggle\/input\/covid19-data\/API_NY.GDP.MKTP.CD_DS2_en_csv_v2_988718.csv')\nregion_df = pd.read_csv('\/kaggle\/input\/covid19-data\/countryContinent.csv')\nlife_exp_df = pd.read_csv('\/kaggle\/input\/covid19-data\/LifeExpectancy.csv')","f71c4359":"# rename columns\ncase_df = case_df.rename(columns={'Province\/State': 'state', 'Country\/Region': 'country'})\n\n# some countries have separate records for its states. aggregate records by country\ncols = case_df.columns.tolist()\n\n# remove not needed columns\ncols.remove('state')\ncols.remove('Lat')\ncols.remove('Long')\n\n# aggregate\ncase_df = case_df[cols].groupby('country').sum(min_count=1).reset_index()\n\n# rename country names to match countries in case_df and policy_df\nto_rename = {\n    'Korea, South': 'South Korea',\n    'US': 'United States', \n    'Taiwan*': 'Taiwan', \n    'Czechia': 'Czech Republic',\n    'Slovakia': 'Slovak Republic'\n}\ncase_df.country = case_df.country.map(lambda s: to_rename.get(s, s))","503efb51":"# restrict sample to countries with at least 1000 confirmed cases\nprint('before:', case_df.shape[0])\ncase_df = case_df[(case_df.iloc[:, 1:] >= 1000).any(axis=1)]\nprint('after:', case_df.shape[0])","7d2aa91c":"# retrieve calendar dates. case_df columns are calendar dates\ndates = case_df.columns[1:]\n\ndef find_first_N_date(row, N):\n    \"\"\"\n    Given a row of country daily counts of covid-19 cases and the threshold N, \n    return the date when the number of confirmed cases first surpassed N.\n    \"\"\"\n    \n    vals = list(row[1:] > N) # first column is country name. skip. \n    \n    if True in vals:\n        return parser.parse(dates[vals.index(True)])\n    return None\n\n# store dates in a new dataframe\ncountry_df = pd.DataFrame({'country': case_df.country})\ncountry_df['date_1'] = case_df.apply(lambda row: find_first_N_date(row, 0), axis=1)\n\n# correct first dates for countries where pandemic started before 1\/22\ncountry_df.loc[country_df.country=='China', 'date_1'] = datetime(2019, 12, 1)\ncountry_df.loc[country_df.country=='Japan', 'date_1'] = datetime(2020, 1, 16)\ncountry_df.loc[country_df.country=='Korea, South', 'date_1'] = datetime(2020, 1, 20)\ncountry_df.loc[country_df.country=='Taiwan*', 'date_1'] = datetime(2020, 1, 21)\ncountry_df.loc[country_df.country=='Thailand', 'date_1'] = datetime(2020, 1, 13)\ncountry_df.loc[country_df.country=='US', 'date_1'] = datetime(2020, 1, 20)","74200cc5":"# finddates when the number of confirmed cases in country reached 500, 1000, and 2000\ncountry_df['date_500'] = case_df.apply(lambda row: find_first_N_date(row, 500), axis=1)\ncountry_df['date_1000'] = case_df.apply(lambda row: find_first_N_date(row, 1000), axis=1)\ncountry_df['date_2000'] = case_df.apply(lambda row: find_first_N_date(row, 2000), axis=1)\n\n# find number of days it took for the confirmed cases to grow from 1 to 500, 1000, and 2000\ncountry_df['days_to_500'] = country_df.apply(lambda row: (row['date_500'] - row['date_1']).days, axis=1)\ncountry_df['days_to_1000'] = country_df.apply(lambda row: (row['date_1000'] - row['date_1']).days, axis=1)\ncountry_df['days_to_2000'] = country_df.apply(lambda row: (row['date_2000'] - row['date_1']).days, axis=1)\n\n# find number of days between 500th case and 1000th case and so on\ncountry_df['days_500_1000'] = country_df.days_to_1000 - country_df.days_to_500\ncountry_df['days_500_2000'] = country_df.days_to_2000 - country_df.days_to_500\ncountry_df['days_1000_2000'] = country_df.days_to_2000 - country_df.days_to_1000\n\ncountry_df.head()","c0410895":"def shift_to_day0(row):\n    \"\"\"\n    Shift row of daily confirmed cases from starting on 1\/22 to starting on the day of first case confirmed. \n    \"\"\"\n    \n    # date of first case\n    day0 = country_df[country_df.country==row['country']].iloc[0]['date_1']\n    \n    # first case appeared after 1\/22 when data collection started\n    if day0 > datetime(2020, 1, 22):    \n        dates = case_df.columns.tolist()[1:] \n        start_from = dates.index(day0.strftime('%-m\/%-d\/%y')) \n        col = row[1:][start_from:]\n        col = col.reset_index(drop=True)\n        col.name = row.country\n        return col\n        \n    # first case appeared before data collection 1\/22\n    # insert None for the missing days\n    else: \n        day_first_available = (parser.parse(row[1:].index[0]) - day0).days\n        col = pd.Series([None] * (day_first_available) + row[1:].tolist(), name=row.country)\n        col = col.reset_index(drop=True)\n        return col\n        \n    return pd.Series([], name=row.country)\n\n\ncase_df_day0 = case_df.apply(shift_to_day0, axis=1).transpose()\ncase_df_day0.columns = case_df.country.values\ncase_df_day0.head()","93c7b943":"# keep track of countries in our sample in select_countries\n# only countries in both case count and policy index datasets are included in our sample\nselect_countries = [country for country in case_df_day0.columns \n                    if country in policy_df.CountryName.values]\n\n# update selected countries in dataframes\ncase_df_day0 = case_df_day0[select_countries]\ncountry_df = country_df[country_df.country.isin(select_countries)]","f88b7d83":"cols = []\n\nfor country in select_countries:\n        \n    # get entries for the country\n    data = policy_df[policy_df.CountryName==country]\n\n    # get date of first confirmed case\n    day0 = country_df[country_df.country==country].iloc[0]['date_1']\n\n    # calculate number of days between a given date and the date of first case\n    data['days_since'] = data.Date.map(lambda i: (parser.parse(str(i))-day0).days)\n    data = data.set_index('days_since')\n    col = data['StringencyIndex']\n    col.name = country\n    cols.append(col)\n    \npolicy_df_day0 = pd.concat(cols, axis=1)\npolicy_df_day0.loc[0:].head() # show data starting from day 1 of pandemic","8ebad864":"# missing from day -15 to day 30\nmissing = policy_df_day0.loc[-15:30].isnull().sum(axis=0)\nmissing[missing > 0]","5e2c6a8c":"# remove countries with more than 3 missing data points\n\nfor country in missing[missing > 3].index:\n    select_countries.remove(country)\n        \nprint('new sample size:', len(select_countries))\n\n# update sample of countries in these datasets\npolicy_df_day0 = policy_df_day0[select_countries]\ncase_df_day0 = case_df_day0[select_countries]\ncountry_df = country_df[country_df.country.isin(select_countries)]","d1d6ecc4":"# construct feature matrix X\n\n# each row is a country. each column is a feature\nX_df = policy_df_day0.loc[-15:30].transpose() # our selected observation period\nX_df = X_df.reset_index(drop=True)\nX_df = X_df.fillna(0)\n\n# to prioritize features prior to the date of first case, multiple prior features by 2\nX_df2 = X_df.copy()\nX_df2.iloc[:, 0:15] = X_df.iloc[:, 0:15]*2\nX_2 = np.matrix(X_df2)","57ca6c31":"# elbow test to determine number of clusters\nwcss = [] # within-cluster sum of squares\n    \nfor i in range(2, 25):\n    kmeans = KMeans(n_clusters=i, init='k-means++', max_iter=500, n_init=10, random_state=0)\n    kmeans.fit(X_2)\n    wcss.append(kmeans.inertia_)\n    \nplt.plot(range(2, 25), wcss, marker='.')\nplt.title('Elbow Method')\nplt.xlabel('Number of clusters')\nplt.ylabel('WCSS')\nplt.legend()\nremove_border()","96898ce5":"# kmeans clustering\nn_clusters = 5\nkmeans = KMeans(n_clusters=n_clusters, init='k-means++', max_iter=500, n_init=10, random_state=0)\ny5 = kmeans.fit_predict(X_2)\n\n# add result to country_df\ncountry_df['cluster5_num'] = y5\n\n# rename clusters\nmap_to = {0: 'Proactive',\n         1: 'Slow Start',\n         2: 'Responsive',\n         3: 'Swiftly Responsive',\n         4: 'Moderately Responsive'}\ncountry_df['cluster5'] = country_df.cluster5_num.map(lambda val: map_to[val])\ncountry_df.cluster5.value_counts()","c68a16be":"country_df","e55a0342":"population_fpath='\/kaggle\/input\/covid19-data\/WPP2019_TotalPopulationBySex.csv'\nGDP_fpath='\/kaggle\/input\/covid19-data\/API_NY.GDP.MKTP.CD_DS2_en_csv_v2_988718.csv'\nlife_expectancy_fpath='\/kaggle\/input\/covid19-data\/LifeExpectancy.csv'","167bedd3":"# clean up original data sheet\n# deleted first two rows from original data manually which would offset the form format\nGDP_df = pd.read_csv(GDP_fpath)\nGDP_df = GDP_df.loc[:,['Country Name', \"Country Code\",\"Indicator Name\", \"2018\"]]\n\n# double check currency is all in dollars before dropping the column\nprint(GDP_df['Indicator Name'].value_counts())\n\nGDP_df = GDP_df.drop([\"Indicator Name\"], axis=1)","a4d37ed8":"# find countries that we don't have data about their GDP\nfor c in country_df.country:\n    if not c in GDP_df['Country Name'].values:\n        print(c)","6e34d182":"# rename countries that have inconsistent names in the two datasheets\nto_rename = {'Egypt, Arab Rep.': 'Egypt', \n             'Iran, Islamic Rep.': 'Iran', \n             'Korea, Rep.': 'South Korea', \n             'Russian Federation': 'Russia', \n            'Brunei Darussalam': 'Brunei'}\nGDP_df['Country Name'] = GDP_df['Country Name'].map(lambda name: to_rename.get(name, name))\nGDP_df = GDP_df.rename(columns={'Country Name': 'country', '2018': 'GDP2018'})","d093be01":"country_background_df = country_df.merge(GDP_df[['country', 'Country Code', 'GDP2018']], on='country', how='left')","23816316":"# find countries with GDP data as null\n\ncountry_background_df[country_background_df.GDP2018.isnull()].country","162f053d":"# Manually fill out missing data\n# Iran GDP in 2018 454,012.77 million\n# https:\/\/data.worldbank.org\/indicator\/NY.GDP.MKTP.CD?view=map\n\nIranIndex = country_background_df[country_background_df['country']=='Iran'].index[0]\ncountry_background_df.iloc[IranIndex, country_background_df.columns.get_loc('GDP2018')] = 454012.77*10**6","c153dbe2":"life_expectancy_df = pd.read_csv(life_expectancy_fpath)\nlife_expectancy_df = life_expectancy_df.loc[:, ['Country Code', '2018']]","127f3e0f":"# find countries that we don't have data about their life expectancies\nfor c in country_background_df['Country Code']:\n    if not c in life_expectancy_df['Country Code'].values:\n        print(c)\n# none","4f792d43":"country_background_df = country_background_df.merge(life_expectancy_df[['Country Code', '2018']], on='Country Code', how='left')\ncountry_background_df = country_background_df.rename(columns={'2018': 'LifeExpectancy2018'})","23617ccc":"# find if there's any country without life expectancy data\ncountry_background_df[country_background_df.LifeExpectancy2018.isnull()]\n#none","b9511349":"# clean up population data\npopulation_df = pd.read_csv(population_fpath)\npopulation_df = population_df[population_df['Time']==2019].loc[:,['Location', 'PopTotal', 'PopDensity']]","826e5b48":"for c in country_background_df.country:\n    if not c in population_df['Location'].values:\n        print(c)","81854912":"# We observed there're two entries for U.S.A. We are going to use the mainland's data only\npopulation_df[population_df.Location.isin(['United States of America', 'United States of America (and dependencies)'])]","8be128eb":"to_rename = {\n     'Iran (Islamic Republic of)': 'Iran', \n     'Republic of Korea': 'South Korea', \n     'Russian Federation': 'Russia',\n     'United States of America': 'United States',\n     'Brunei Darussalam': 'Brunei',\n    'Czechia': 'Czech Republic',\n    'Slovakia': 'Slovak Republic',\n    'China, Taiwan Province of China': 'Taiwan',\n    'Viet Nam': 'Vietnam',\n    'Republic of Moldova': 'Moldova'\n}\n\npopulation_df['Location'] = population_df['Location'].map(lambda name: to_rename.get(name, name))\npopulation_df = population_df.rename(columns={'Location': 'country'})","ab56726b":"country_background_df = country_background_df.merge(population_df, on='country', how='left')","61140149":"from sklearn import preprocessing\n\n# Cleans up for K cluster\nkmeans_countries = country_background_df.loc[:, ['GDP2018', 'LifeExpectancy2018', 'PopDensity', 'PopTotal']]\n\nkmeans_countries","018fe0ca":"# Process data\n\n# Transfer population from thousand to single unit\nkmeans_countries['PopTotal'] = kmeans_countries['PopTotal']*1000.00\n# Get GDP per capita\nkmeans_countries['GDP2018'] = kmeans_countries['GDP2018']\/kmeans_countries['PopTotal']\n# Squaring LifeExpectancy to further differentiate data distribution\nkmeans_countries['LifeExpectancy2018'] = kmeans_countries['LifeExpectancy2018']**2\nkmeans_countries = kmeans_countries.drop(['PopTotal'], axis=1)\nkmeans_countries","7ace6619":"# elbow analysis\nfrom sklearn.cluster import KMeans\nfrom yellowbrick.cluster import KElbowVisualizer\n\nmodel = KMeans()\nvisualizer = KElbowVisualizer(model, k=(4,12))\nvisualizer.fit(kmeans_countries.dropna())\nvisualizer.show()","51bfe54c":"# Use cluster analysis to categorize countries\nfrom sklearn.cluster import KMeans\ncountry_clusters = 6\nkmeans_countries = kmeans_countries.dropna()\nkmeans = KMeans(n_clusters=country_clusters, init='k-means++', max_iter=500, n_init=10, random_state=0)\ny = kmeans.fit_predict(kmeans_countries)\n\ncountry_background_df['country_category'] = y","293b6d7b":"# We decided to use 6 as cluster for simplicity and more severe group differentiation\n# Transfer to GDP per capita\ncountry_background_df['GDP2018PerCapita'] = country_background_df['GDP2018']\/(country_background_df['PopTotal']*1000.0)","11662d3a":"# Create boxenplot for countries in each response categories\n\nmetrics = ['GDP2018PerCapita', 'PopDensity', 'LifeExpectancy2018']\nsns.set(style='whitegrid')\nfig, axes = plt.subplots(1, 3, sharex=True, figsize=(20, 4))\n\nfor index, metric in enumerate(metrics):\n    sns.boxenplot(x=\"country_category\", y=metric, data=country_background_df, ax=axes[index%3])\n    remove_border(axes[index%3])\n\ngroup_label = {\n    0: 'MedGDPLongerLifeExp',\n    1: 'LowerGDPLowerLifeExp',\n    2: 'HigherGDPLongerLifeExp',\n    3: 'MedGDPHigherDensity',\n    4: 'LowestGDPLowestLifeExp',\n    5: 'HighestGDPLongestLifeExp',\n}\n\n# create country group order based on their wealth and life expectancy level\ncountry_category_wealth_order = ['LowestGDPLowestLifeExp', 'LowerGDPLowerLifeExp', 'MedGDPHigherDensity', 'MedGDPHigherDensity', 'HigherGDPLongerLifeExp', 'HighestGDPLongestLifeExp']\n\ncountry_background_df['country_category_name'] = country_background_df['country_category'].map(group_label)","b87a5816":"# Group countries by their categories and merge with case numbers for each country\nresult = country_background_df.loc[:,['country', 'country_category_name', 'cluster5']]\nresult = result.groupby('country_category_name')\n\ncases_by_country = {}\ncase_df_after_500_transpose = case_df_after_500.transpose().reset_index().rename(columns={'index': 'country'})\nfor val in country_category_wealth_order:\n    cases_by_country[val] = pd.merge(\n        result.get_group(val).drop(columns=['country_category_name']),\n        case_df_after_500_transpose,\n        on='country', \n        how='left'\n    )","cb7c5d95":"# Plot country group's color-coded infection case development\nnew_group_label = {\n    0: 'LowestGDPLowestLifeExp',\n    1: 'LowerGDPLowerLifeExp',\n    2: 'MedGDPHigherDensity',\n    3: 'MedGDPLongerLifeExp',\n    4: 'HigherGDPLongerLifeExp',\n    5: 'HighestGDPLongestLifeExp',\n}\n\ndef get_cluster_number5(cluster):\n    if (cluster=='Proactive'):\n        return 0\n    elif (cluster=='Swiftly Responsive'):\n        return 1\n    elif (cluster=='Responsive'):\n        return 2\n    elif (cluster=='Moderately Responsive'):\n        return 3\n    elif (cluster=='Slow Start'):\n        return 4\n    else:\n        return\n\nsns.set(style='dark')\npalette = plt.get_cmap('RdPu_r')\nfig, axes = plt.subplots(3, 2, sharex=True, sharey=True, figsize=(14, 8))\n\nfor index, val in enumerate(country_category_wealth_order):\n    curr_df = cases_by_country[val].transpose().iloc[3:]\n    for column in cases_by_country[val].transpose().iloc[3:]:\n        color_num = get_cluster_number5(cases_by_country[val].transpose()[column]['cluster5'])\n        axes[index\/\/2, index%2].plot(curr_df.index, curr_df[column], color=palette(color_num*50), alpha=0.6)\n    axes[index\/\/2, index%2].set_title('Group'+str(index)+': '+val)\n    axes[index\/\/2, index%2].set_ylim([0,200000])\n    remove_border(axes[index\/\/2, index%2])\n\npatch0 = mpatches.Patch(color=palette(0), label='Proactive')\npatch1 = mpatches.Patch(color=palette(50), label='Swiftly Responsive')\npatch2 = mpatches.Patch(color=palette(100), label='Responsive')\npatch3 = mpatches.Patch(color=palette(200), label='Moderately Responsive')\npatch4 = mpatches.Patch(color=palette(150), label='Slow Start')\n\nfig.legend(loc='lower center', ncol=5, handles=[patch0, patch1, patch2, patch3, patch4])","65a096db":"# Create dataframe for regression analysis\nresponse_type_map = {\n    'Proactive': 0,\n    'Swiftly Responsive': 1,\n    'Responsive': 2,\n    'Moderately Responsive': 3,\n    'Slow Start': 4,\n}\n\nregression_by_country_category = country_background_df[['country', 'cluster5', 'country_category_name']]\nregression_by_country_category['policy_response_order'] = regression_by_country_category['cluster5'].map(response_type_map)","ee2327f9":"# double check by day 55, all countries have data\ncase_df_day0.transpose()[55].isna().sum()","99374bf2":"regression_by_country_category = pd.merge(regression_by_country_category, country_55, on='country', how='left')\nregression_by_country_category = regression_by_country_category.rename(columns={'cluster5': 'policy_response_type', 55: 'day_55_case_num'})","ad872ba0":"# Linear Regression for countries with less resources\nfrom statsmodels.formula.api import ols\ncountry0 = regression_by_country_category[regression_by_country_category['country_category_name']=='LowestGDPLowestLifeExp']\nfit = ols('day_55_case_num ~ C(policy_response_type)', data=country0).fit() \n\nfit.summary()","ff75f320":"# Linear Regression for average and wealthier countries\ncountry1to5 = regression_by_country_category[regression_by_country_category['country_category_name']!='LowestGDPLowestLifeExp']\nfit = ols('day_55_case_num ~ C(policy_response_type)', data=country1to5).fit() \n\nfit.summary()","8676b407":"**Model fitting for average and wealthier countries**","e2ba9ca2":"### Add Country-Related Background Data: GDP in 2018, population, life expectancy by birth, and sub_region","47427c42":"### Add Country GDP","23841ce1":"**Model fitting for countries with less resources**","f724f43b":"### 5.6 Cluster analysis to group countries based on their backgrounds","f46b7978":"Here we present the three countries with the largest total populations from each cluster.\n\n### 3.2 Analyse impact of response types based on country attributes\nThere exists significant disparities across countries in terms of their economic volumes and wellness levels. We would like to address this context in our analysis. We are interested in observing for similar countries implemented with varying containment and mitigation strategies, if the response type would have a more obvious impact.\n\nThere are many attributes we can use. In this study, we selected three metrics: GDP per capita, population density and life expectancy. See 5.6 for details how we generated the country categories.","0d19dcfc":"### 5.5 Merge Country-Level Covariates","0389e2e8":"### Add Population Data","b37edf56":"We present the outcome of our gression models in coefficient plots. The Swiftly Responsive group is the baseline group and thus omitted from the plot. None of the effects are statistically significant, which is expected given the small sample size. Most effects are close to zero and make the clusters nondistinguishable in terms of their impact on the infection. However, the Proactive group has two positive point estimates of size 1-2, suggesting that countries in the Proactive group may have a little advantage over the Swifly Responsive group and take about one day longer to reach 500 confirmed cases to 2,000 and from 1,000 confirmed cases to 2,000. The Moderately Responsive group has two point estimates reaching -2. Countries in this group experienced a faster infection rate than those in the Swiftly Responsive group. ","a592eb66":"Cluster analysis shows that the five-cluster solution best characterizes the heterogeneity in early national responses to Covid-19.\n\nAfter observing the patterns of policies (the first row in the figure above), we name the clusters as the follows:\n\n* Proactive (9 countries): Countries in this group started acting before any Covid-19 case was diagnosed in the nation and then slowly and steadily reached the highest level of the stringency index within one month after the date of the first confirmed case\n* Swiftly Responsive (13): Countries in this group reacted immediately after the occurence of first Covid-19 case and typically reached the highest policy intensity within two weeks after the appearance of the first confirmed case\n* Responsive (25): Coutries in this group were initially cautious to take immediate actions following the diagosis of the first case. However, they strengthened their policy responses between the 10th and 20th day after the first confirmed case and reached high level by the 30th day\n* Moderately Responsive (9): Countries in this group rose to only a medium level of policy intensity (between 40 and 80) at a slower pace, often taking more than three weeks.\n* Slow Start (18): With little proactive actions before the first confirmed case, countries in this group had the slowest response to the virus. Most of them did not reach half of the policy intensity as their counterparts in the other categories did by the end of one month.\n\n\nThe five figures in the second row each draw the infection curves of the countries in a cluster, starting from the day of the 500th confirmed case and displayed only up to 100,000 cases. As expected, the Proactive and Swiftly Responsive groups acquired fewer confirmed cases at a slower pace, despite of some outliers. The infection curves in the Responsive group started to raise moderately, indicating larger number of infection cases. The two rightmost figures show that the Moderately Responsive group and the Slow Start group experienced acute increases of the largest number of confirmed cases. ","4badcb86":"## 5. Appendix: Data Preparation and Additional Analysis\u00b6","1eaa977d":"The graph above shows each country group's infected case growth. From 0 to 5, the lower the group number the less resources and wealth the country group has on average. We also color coded their case development trajectories based on their policy response typologies. Countries with darker color tend to react more rapidly and intensively to mitigate the spread of Covid19.\n\nWealthier countries seem to perform better independent of their policy response type. We observe a strong pattern among the medium level countries where countries that implemented more stringent policies (darker lines) tend to demonstrate a slower infection growth rate. Coutries in group 1 demonstrates a complicated stories with no apparent patterns. It seems to be more complicated to predict the impact of policy effects on containing the pandemic for countries with weak economic conditions and welfare state.\n\nWe will further this dicussion with regresion analysis.","290f491b":"## 4. Summary\n\nMany factors affects the effectiveness of policies. Our analysis illustrates some degree pf correlation between a country's policy stringency level and its outcome. For an average country, timely and stringent actions seem to contribute to the mitigation of Covid19. Yet, for many countries, Covid19 is still at relatively early stage of development. A stronger correlation may emerge in the future.\n\nCountries with poor pre-existing healthcare conditions and low economic volumes are more vulnerable and may undergo more uncertainties as the Covid19 pandemic develops, in that it is more complicated to predict policy impact. For these countries deprived of resources, the current response strategies may still not be enough. It requires countries' creativity and even international support to help mitigate the situation.","9d0857de":"Considering the percentage of WCSS reduced, the size of each cluster, and the substantive meanings of the cluster solutions, we decide that four clusters are the best solution. Moreover, in the analysis not shown in this notebook, we have conducted cluster analysis using the Ward algorithm and found similar cluster solutions.","0dc6ef72":"# Typology of National Responses to the Covid-19 Pandemic\n\n## 1. Overview\nAs the Covid-19 pandemic reaches 188 countries and territories, causing more than 4.89 million cases and more than 322,000 deaths as of May 19, 2020, governments worldwide have responded with a wide range of measures. The measures adopted by each country vary by intensity and timing, and they have contributed to the differing degrees of national effectiveness to contain the virus.\n\nIn this submission we evaluate the impact of government strategies on Covid-19 infection by developing a typology of governments' early policy responses and comparing infection rates across the categories. Government responses often involve various combinations of policies, ranging from public health to economics. To compare policies across countries, we adopt the Oxford Covid-19 government response stringency index, a common index that aggregates policy scores and is comparable across countries. Furthermore, we focus on **early government actions**, that is, measures imposed during the span of two weeks before the date of the first confirmed case in a country and one month afterwards.\n\n\n### Takeaways\n\nWe derived five categories of early national responses from cluster analysis (more details in section 3.1):\n\n* Proactive\n* Swiftly Responsive\n* Responsive\n* Moderately Responsive\n* Slow Start\n\nWe then compared across the country categories the infection curves and the speed at which the infection reached certain thresholds. We controlled for country healthcare and economic differences using match and regression analysis.\n\nWe find that countries with Proactive or Responsive Covid-19 response profiles tend to experience slower infection at a smaller scale. The difference between the two groups is indistinguishable. On the other hand, countries in the Slow Start group had the fastest growth of confirmed cases, while the Moderately Responsive group lies in-between. Due to the small sample size (74 countries), only the difference between the Proactive group and the Slow Start group is statistically significant.\n\nSimilar policies seem to be less effective on countries deprived of resources. Covid19 may bring countries with pre-existing social and economic vulnerabilities an even greater degree of uncertainty. These countries require focus study with analytical models different from other countries to help better predict the influence of policies.\n\n### Caveats ### \n\nAs expected, more proactive and quicker government responses are beneficial in the fight of the Covid-19 virus. However, our analysis also yielded some counterintuitive findings, such as placing Germany in the Slow Start group along with the United States, the United Kingdom, and Spain. This misalignment suggests that the policy metric we adopted, the Oxford stringency index, may not accurately or holistically capture government responses to the pandemic, and that government policy alone may not determine the outcome of the country in the pandemic. Last but not least, as we evaluate government responses, we should keep in mind the economic and social impacts of these policies, in particular the lockdown measures, in addition to their health impacts.\n\n## 2. Data\nOne of the datasets we use in this submission comes from the UNCOVER datasets, the UNCOVER John Hopkins CSSE global confirmed cases. We accessed the data on the project's github page on May 9th (https:\/\/github.com\/CSSEGISandData\/COVID-19).\n\nThe core of our analysis is built upon the time series of the Oxford Covid-19 government response stringency index. We accessed the data on May 9th at https:\/\/covidtracker.bsg.ox.ac.uk\/\n\nWe also include a number of country-level socioeconomic variables:\n\n* UN population-related data (https:\/\/population.un.org\/wpp\/Download\/Standard\/CSV\/)\n* World Bank GDP data (https:\/\/data.worldbank.org\/indicator\/NY.GDP.MKTP.CD?view=map)\n* Kaggle country to continent (https:\/\/www.kaggle.com\/statchaitya\/country-to-continent)\n* World Bank life expectancy at birth by country (https:\/\/data.worldbank.org\/indicator\/sp.dyn.le00.in)\n\nWe have uploaded both raw and processed datasets used in this submission. In the visualization and analysis section below, we directly imported the cleaned data. In the Appendix at the end of this notebook, we demonstrated step-by-step how we cleaned up the raw data.\n\nOur final sample consists of 74 countries. Our sample choice is highly constrained by data availability. We adopt a six-week period to summarize and classify government responses. The six-week period starts from 15 days before the diagnosis of the first case to 30 days after the first confirmed case. Countries with significant missing data during this period were dropped. We also exclude from our sample countries with fewer than 1,000 cumulative confirmed cases.\n\n## 3. Analysis and Findings\n### 3.1 Typology of National Responses","11082142":"We explored the variations in policy intensity and timing in this heatmap. We first calculated a weekly mean of stringency index in each country and assigned the mean score to one of ten even intervals between 0 and 100, which is the range of the stringency index. Each cell in the heatmap represents the number of countries with mean scores falling into the given interval in the given week. With the week in which the first Covid-19 case was confirmed labelled as week 0, we show in this figure the distribution of government responses from five weeks before week 0 to 8 weeks after week 0.\n\nThis heatmap shows that countries are overwhelmingly concentrated in the bottom left corner and the top right corner. The concentration at the bottom left indicates that most countries did not take any action and have a stringency score betwen 0 and 10 in the weeks before week0. The concentration on the top right has lighter colors than the bottom left corner does. This illustrates that many countries have reached the highest level of policy stringency (scores between 90 and 100) during weeks 5-8, but there are also some countries located in the lower intervals. \n\nBased on this heatmap, we choose the period from two weeks before week 0 to 4 weeks after week 0 as the observation period of early government responses. This observation period captures large variations in governments' early policy stringency and faciliates the classification of countries through cluster analysis. ","6d6234e4":"### 5.3 Restructure Country Policy Stringency Index Data\nLike the restructured daily case counts, here we create a new dataframe with countries as columns and days as rows. Each cell is the government stringency index of the corresponding country (column name) on the given day (row index). The row index indicates the number of days from the date of the first confirmed case (day 1). For example, the index 10 means 10 days after day 1, and the index -10 means 10 days before day 1, before the pandemic started.","423e003e":"### 5.2 Restructure time series data of global confirmed cases\nEach column represents a country. Each row represents a day. The first row shows case counts on the date of the first confirmed case. The calendar date of the first case in each country varies, but we restructured the data to align all ocuntries by day 1 of the pandemic in each country.","f1cda44f":"### 3.3 Regression Analysis\n\nIn addition to descriptive analysis using visualization, we run regression models to evaluate the impact of government measures on infection rates. In this part of analysis, we operationalize infection rates in three ways: (1) the days it took as the number of confirmed cases in a country climbed from 500 to 1,000, (2) from 500 to 2,000, and (3) from 1,000 to 2,000. We regression policy categories on infection speed, while holding country-level attributes, including total population, population density, GDP, life expectancy, and continent, constant.","c95ec968":"### 5.7 Observe infection rate growth by country categories","c7addc17":"### 5.4 Create Typology of National Policy Responses Using Cluster Analysis","250000ee":"We are interested in exploring if policy impact on infection rate would be more pronounced when we separate average and wealthy countries and countries with lowest GDP and lowest life expectancies. The two regression analysis above evaluates the correlation between countries' response types and the number of cases 55 days after first infection in each country. Unfortunately we found no statistically significant results. This could happen due to the limited timeframe or our choice of dependent variables. However compared to countries in group 0 which has a p-value of 0.44, other countries seem to have a slightly better fitting model with the policy response type. We also see a bigger impact on case number reduction when switched from `Moderately Responsive` group to `Proactive` or `Swiftly Responsive` response type among average and wealthy countries.","9970efda":"Based on the boxenplot, we are categorizing the countries as follows:\n\n* LowestGDPLowestLifeExp\n* LowerGDPLowerLifeExp\n* MedGDPHigherDensity\n* MedGDPHigherDensity\n* HigherGDPLongerLifeExp\n* HighestGDPLongestLifeExp","cac24b8e":"### Add Life Expectancy","d8213e1a":"### 5.1 Find dates when each country reached first, 500th, 1000th, and 2000th confirmed cases\u00b6"}}