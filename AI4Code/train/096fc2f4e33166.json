{"cell_type":{"a028d31d":"code","ffb8fede":"code","a8876e96":"code","15ffc3f2":"code","55e9d3e3":"code","5b39155c":"code","63fcaeaa":"code","b05f35ce":"code","34f6a66e":"code","61682a2c":"code","1d5f6dd6":"code","94f37ae7":"code","f503ef81":"code","8c674829":"code","bdf8fa4f":"code","ff90df5c":"code","7663e38e":"code","110e39b7":"code","bd03a713":"code","6814e6fb":"code","96a8bfe0":"code","c0b6391e":"code","0b58b90e":"code","6cfb5e33":"code","6c4afaf5":"code","1112e31b":"code","80af001d":"code","7d4a5f8b":"code","2f53968f":"code","45122c45":"code","840c29aa":"code","26bbca3c":"markdown","38c40f22":"markdown","29adc1d4":"markdown","bd9afe35":"markdown","2fd3d392":"markdown","f73a9791":"markdown","679423f5":"markdown","aaeb7cb9":"markdown","5fdbbe9e":"markdown","38a68599":"markdown","66259864":"markdown"},"source":{"a028d31d":"from IPython.core.display import display, HTML, Javascript\n\ndef nb():\n    styles = open(\"..\/input\/intermediate-notebooks-data\/custom_green.css\", \"r\").read()\n    return HTML(\"<style>\"+styles+\"<\/style>\")\nnb()","ffb8fede":"!pip install pycomp\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport networkx as nx\nimport time\nimport cudf\nimport cuml\nimport xgboost\nimport shap\n\nfrom random import randint\nfrom pycomp.viz.insights import *\nfrom cuml.linear_model import Ridge\nfrom cuml.svm import SVR\nfrom cuml.neighbors import KNeighborsClassifier\nfrom cuml.metrics import accuracy_score,roc_auc_score as ras\nfrom cuml.preprocessing.model_selection import train_test_split\nfrom cuml.preprocessing.TargetEncoder import TargetEncoder","a8876e96":"!nvidia-smi","15ffc3f2":"!nvcc --version","55e9d3e3":"def custom_palette(custom_colors):\n    customPalette = sns.set_palette(sns.color_palette(custom_colors))\n    sns.palplot(sns.color_palette(custom_colors),size=0.8)\n    plt.tick_params(axis='both', labelsize=0, length = 0)","5b39155c":"pink = [\"#861388\",\"#E15A97\",\"#EEABC4\",\"#C799A6\",\"#4B2840\"]\nblue = [\"#C6EBBE\",\"#A9DBB8\",\"#5887FF\",\"#55C1FF\",\"#E9D2F4\"]\ncustom_palette(pink)\ncustom_palette(blue)","63fcaeaa":"train_df = cudf.read_csv('..\/input\/tabular-playground-series-mar-2021\/train.csv', index_col='id')\ntrain_df.head()","b05f35ce":"test_df = cudf.read_csv('..\/input\/tabular-playground-series-mar-2021\/test.csv', index_col='id')\ntest_df.head()","34f6a66e":"train_p = train_df.to_pandas()\ntest_p = train_df.to_pandas()\n\ndt_i=[]\ndt_fl=[]\ndt_o=[]\n\nfor col in train_p.columns:\n    x=train_p[col].dtype\n    if x=='int64':\n        dt_i.append(col)\n    elif x=='float64':\n        dt_fl.append(col)\n    else:\n        dt_o.append(col)","61682a2c":"print(dt_i)","1d5f6dd6":"print(dt_fl)","94f37ae7":"print(dt_o)","f503ef81":"plot_donut_chart(df=train_p, col='target',\n                 title='Target Value Distribution',colors=[blue[2],blue[1]])","8c674829":"def plot_cont(values,title,c):\n    plt.figure(figsize = (18, 8))\n    sns.kdeplot(values, color = pink[c])\n    plt.title(title, fontsize=15)\n    plt.show();\n\nfor i in dt_fl:\n    c = randint(0, 4)\n    values = train_p[i].value_counts().reset_index()[i].values\n    plot_cont(values,i,c)","bdf8fa4f":"def plot_cat(index,values,title):\n    if len(values)>10:\n        p=\"spring\"\n        index=index[:50]\n        values = values[:50]\n    else:\n        p=pink\n        \n    plt.figure(figsize = (18, 8))\n    sns.barplot(x = index, y = values,palette=p)\n    plt.title(title, fontsize=15)\n    plt.show();\n    \nfor i in dt_o:\n    index = train_p[i].value_counts().reset_index()[\"index\"].values\n    values = train_p[i].value_counts().reset_index()[i].values\n    plot_cat(index,values,i)","ff90df5c":"plt.figure(figsize=(30,35))\ncorr=train_p.corr()\nmask = np.triu(np.ones_like(corr, dtype=bool))\nsns.heatmap(corr, mask=mask, cmap='YlGn', vmax=.3, center=0,\n            square=True, linewidths=.5,annot=True)\nplt.show()","7663e38e":"indices = corr.index.values\ncor_matrix = np.asmatrix(corr)\nG = nx.from_numpy_matrix(cor_matrix)\nG = nx.relabel_nodes(G,lambda x: indices[x])\nG.edges(data=True)","110e39b7":"def corr_network(G, corr_direction, min_correlation):\n    H = G.copy()\n\n    for s1, s2, weight in G.edges(data=True):       \n        if corr_direction == \"positive\":\n            if weight[\"weight\"] < 0 or weight[\"weight\"] < min_correlation:\n                H.remove_edge(s1, s2)\n        else:\n            if weight[\"weight\"] >= 0 or weight[\"weight\"] > min_correlation:\n                H.remove_edge(s1, s2)\n                \n    edges,weights = zip(*nx.get_edge_attributes(H,'weight').items())\n    \n    weights = tuple([(1+abs(x))**2 for x in weights])\n   \n    d = dict(nx.degree(H))\n    nodelist=d.keys()\n    node_sizes=d.values()\n    \n    positions=nx.circular_layout(H)\n    \n    plt.figure(figsize=(15,15))\n\n    nx.draw_networkx_nodes(H,positions,node_color='#d100d1',nodelist=nodelist,\n                       node_size=tuple([x**3 for x in node_sizes]),alpha=0.8)\n\n    nx.draw_networkx_labels(H, positions, font_size=8)\n\n    if corr_direction == \"positive\":\n        edge_colour = plt.cm.cool \n    else:\n        edge_colour = plt.cm.Wistia\n        \n    nx.draw_networkx_edges(H, positions, edgelist=edges,style='solid',\n                          width=weights, edge_color = weights, edge_cmap = edge_colour,\n                          edge_vmin = min(weights), edge_vmax=max(weights))\n    plt.axis('off')\n    plt.show() ","bd03a713":"corr_network(G, corr_direction=\"positive\",min_correlation = 0.5)","6814e6fb":"corr_network(G, corr_direction=\"negative\",min_correlation = -0.3)","96a8bfe0":"%%time\nSMOOTH = 0.001\nSPLIT = 'interleaved'\nFOLDS = 5\n\nencoder = TargetEncoder(n_folds=FOLDS, smooth=SMOOTH, split_method=SPLIT)","c0b6391e":"%%time\n\nX = train_df.drop([\"target\"],axis=1)\ny = train_df[\"target\"]\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, \n                                                    shuffle=False, stratify=y)\nfor col in train_df.columns:\n    if train_df[col].dtype=='object': \n        X_train[col] = encoder.fit_transform(X_train[col],y_train)\n        X_test[col] = encoder.transform(X_test[col])\n        test_df[col] = encoder.transform(test_df[col])","0b58b90e":"def training(model, X_train, y_train, X_test, y_test, model_name):\n    t1 = time.time()\n    \n    model.fit(X_train, y_train)\n    predicts = model.predict(X_test)\n    roc = ras(y_test, predicts)\n    \n    t2 = time.time()\n    training_time = t2-t1 \n    \n    print(\"\\t\\t\\t--- Model:\", model_name,\"---\")\n    print(\"ROC: \", roc,\"\\t\\t\\t\",\"Training time:\",training_time,\"\\n\")","6cfb5e33":"ridge = Ridge(fit_intercept = True, normalize = False,solver = \"eig\")\n\nsvr = SVR(kernel='rbf', gamma='scale', C=1, epsilon=0.3)\n\nknc =  KNeighborsClassifier(n_neighbors=3)\n\nm = [ridge,svr,knc]\nmn = [\"Ridge\",\"SVR\",\"K Neighbors Classifier\"]\n\nfor i in range(0,len(m)):\n    training(model=m[i], X_train=X_train, y_train=y_train, X_test=X_test,y_test=y_test, model_name=mn[i])","6c4afaf5":"dtrain = xgboost.DMatrix(X_train,y_train)\ndval   = xgboost.DMatrix(X_test, y_test)\ndtest  = xgboost.DMatrix(test_df)\n\nparams1 = { 'objective': 'binary:logistic',\n    'booster': 'gbtree',\n    'tree_method': 'gpu_hist',\n    'eval_metric': 'auc',\n    'random_state': 42,\n    'max_depth': 15,\n    'learning_rate': 0.03,\n    'min_child_weight': 20,\n    'gamma': 0.1,\n    'alpha': 0.2,\n    'lambda': 9,\n    'colsample_bytree': 0.2,\n    'subsample': 0.8}\n\nevallist = [(dval, 'validation'), (dtrain, 'train')]\nnum_round=50","1112e31b":"%%time\n\nxgb = xgboost.train(params1, dtrain,num_round,evallist)\n\npredicts = xgb.predict(xgboost.DMatrix(X_test))\nroc = ras(y_test, predicts)\nroc","80af001d":"preds1 = xgb.predict(xgboost.DMatrix(test_df))\n\nids = cudf.read_csv('..\/input\/tabular-playground-series-mar-2021\/sample_submission.csv')[[\"id\"]].values","7d4a5f8b":"def feature_imp(model):\n    explainer = shap.TreeExplainer(model)\n    shap_values = explainer.shap_values(X_test.to_pandas())\n    shap.summary_plot(shap_values, X_test.to_pandas(), plot_type=\"bar\",color='#7bf1a8')\n\n    shap.summary_plot(shap_values, X_test.to_pandas())\n\n    shap.dependence_plot(\"cat16\", shap_values, X_test.to_pandas())\n\n    shap.dependence_plot(\"cat15\", shap_values, X_test.to_pandas())\n\n    shap.dependence_plot(\"cat1\", shap_values, X_test.to_pandas())\n\n    shap.dependence_plot(\"cat14\", shap_values, X_test.to_pandas())","2f53968f":"%%time\nfeature_imp(xgb)","45122c45":"df_sub = {'id': ids, 'target': preds1}\ndf_predictions = cudf.DataFrame(df_sub).set_index(['id'])\ndf_predictions.head(10)","840c29aa":"df_predictions.to_csv('\/kaggle\/working\/Predictions.csv')","26bbca3c":"# 2. EDA \ud83d\udcca","38c40f22":"<div>\n    <img src=\"https:\/\/i.imgur.com\/QrL4fIn.png\">\n<\/div>","29adc1d4":"Correlation","bd9afe35":"# 5. Feature Importance \ud83d\udcce","2fd3d392":"References\ud83d\udcdc\n\n* [NetworkX documentation](https:\/\/networkx.org\/documentation\/stable\/tutorial.html)\n* [Visualising stocks correlations with Networkx](https:\/\/towardsdatascience.com\/visualising-stocks-correlations-with-networkx-88f2ee25362e)\n\nInspiration \ud83d\udca1\n- [Custom Jupyter Notebook Theme with plain CSS](https:\/\/medium.com\/@formigone\/my-first-custom-theme-for-jupyter-notebook-a9c1e69efdfe) \ud83c\udfa8\n\nIllustrations tools \u26a1\n- [Canva](https:\/\/www.canva.com\/en_gb\/) \ud83d\udd8c\ufe0f\n- [Storyset](https:\/\/storyset.com\/) \ud83d\uddbc\ufe0f","f73a9791":"# 4. Model Training \ud83d\udee0\ufe0f","679423f5":"# 6. Creating the submission file \ud83d\udccb","aaeb7cb9":"<div>\n    <img src=\"https:\/\/i.imgur.com\/pl3FhXV.png\">\n <\/div>","5fdbbe9e":"# Introduction \ud83d\udcd7\n\n> Tabular Playground Series entails synthetic data based on real data, which revolves around predicting the amount of an insurance claim. The competition data is generated using CTGAN.","38a68599":"# 1. Importing libraries \ud83d\udcda","66259864":"# 3. Target Encoding \ud83c\udfaf"}}