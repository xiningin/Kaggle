{"cell_type":{"8bd13e61":"code","6ebad9d9":"code","b545ffd1":"code","ec4db7f7":"code","9e7df154":"code","f75649ac":"code","6dcac695":"code","eb9eb92e":"code","e921cd76":"code","b97e1cd0":"code","9b64bb44":"code","a152429e":"code","211fe6c4":"code","5fe69f9b":"code","7e12b7d3":"code","e98ae55b":"code","98146acb":"code","191cba4a":"code","4a6fc2ff":"code","bbd3fed0":"code","9b778098":"code","fef06cfa":"code","44e0d965":"code","8cd0cd97":"code","52ccd1a6":"code","d2386468":"code","deac915f":"code","7266f13c":"code","3996b0aa":"code","e9999b7f":"code","53e11c0d":"code","aa7b6def":"code","bb6e580d":"code","b58ea033":"code","f83f92b9":"code","8f32e8a7":"code","86a25188":"markdown","15ee5fcd":"markdown","e180e6fa":"markdown","a250afac":"markdown","3bf2d65b":"markdown","7ecbb3cd":"markdown","1accf913":"markdown","a0f23b5c":"markdown","ed430146":"markdown","7f242516":"markdown","de064fe1":"markdown","98f63054":"markdown","db3a191a":"markdown","295b5751":"markdown","409225ea":"markdown","b11614b8":"markdown","163ee4d2":"markdown","37de858e":"markdown","5a014f96":"markdown","a7a5a801":"markdown","e29c5c71":"markdown","19b23dee":"markdown","98f568e5":"markdown","1fcb7018":"markdown","b47111b9":"markdown","ab91aaf0":"markdown","b49fb33e":"markdown","4756d7c0":"markdown","5d8ffad6":"markdown","343b2702":"markdown","e2ca5491":"markdown","83422324":"markdown","e6d5bf0d":"markdown","f877e241":"markdown","1b2a6df4":"markdown"},"source":{"8bd13e61":"# import basics\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport os\nfrom glob import glob\n\n# import plotting\nfrom matplotlib import pyplot as plt\nimport matplotlib.patches as patches\nimport matplotlib\nimport seaborn as sns\n\n# import image manipulation\nfrom PIL import Image\nimport imageio\n\n! pip install --upgrade imgaug\n\n# import data augmentation\nimport imgaug as ia\nfrom imgaug import augmenters as iaa\n# import segmentation maps from imgaug\nfrom imgaug.augmentables.segmaps import SegmentationMapOnImage\nimport imgaug.imgaug","6ebad9d9":"# set paths to train and test image datasets\nTRAIN_PATH = '..\/input\/severstal-steel-defect-detection\/train_images\/'\nTEST_PATH = '..\/input\/severstal-steel-defect-detection\/test_images\/'\n\n# load dataframe with train labels\ntrain_df = pd.read_csv('..\/input\/severstal-steel-defect-detection\/train.csv')\ntrain_fns = sorted(glob(TRAIN_PATH + '*.jpg'))\ntest_fns = sorted(glob(TEST_PATH + '*.jpg'))\n\nprint('There are {} images in the train set.'.format(len(train_fns)))\nprint('There are {} images in the test set.'.format(len(test_fns)))","b545ffd1":"# plotting a pie chart which demonstrates train and test sets\nlabels = 'Train', 'Test'\nsizes = [len(train_fns), len(test_fns)]\nexplode = (0, 0.1)\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)\nax.axis('equal')\nax.set_title('Train and Test Sets')\n\nplt.show()","ec4db7f7":"train_df.head(10)","9e7df154":"print('There are {} rows with empty segmentation maps.'.format(len(train_df) - train_df.EncodedPixels.count()))","f75649ac":"# plotting a pie chart\nlabels = 'Non-empty', 'Empty'\nsizes = [train_df.EncodedPixels.count(), len(train_df) - train_df.EncodedPixels.count()]\nexplode = (0, 0.1)\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)\nax.axis('equal')\nax.set_title('Non-empty and Empty Masks')\n\nplt.show()","6dcac695":"# split column\nsplit_df = train_df[\"ImageId_ClassId\"].str.split(\"_\", n = 1, expand = True)\n\n# add new columns to train_df\ntrain_df['Image'] = split_df[0]\ntrain_df['Label'] = split_df[1]\n\n# check the result\ntrain_df.head()","eb9eb92e":"defect1 = train_df[train_df['Label'] == '1'].EncodedPixels.count()\ndefect2 = train_df[train_df['Label'] == '2'].EncodedPixels.count()\ndefect3 = train_df[train_df['Label'] == '3'].EncodedPixels.count()\ndefect4 = train_df[train_df['Label'] == '4'].EncodedPixels.count()\n\nlabels_per_image = train_df.groupby('Image')['EncodedPixels'].count()\n\nno_defects = labels_per_image[labels_per_image == 0].count()\n\nprint('There are {} defect1 images'.format(defect1))\nprint('There are {} defect2 images'.format(defect2))\nprint('There are {} defect3 images'.format(defect3))\nprint('There are {} defect4 images'.format(defect4))\nprint('There are {} images with no defects'.format(no_defects))","e921cd76":"# plotting a pie chart\nlabels = 'Defect 1', 'Defect 2', 'Defect 3', 'Defect 4', 'No defects'\nsizes = [defect1, defect2, defect3, defect4, no_defects]\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.pie(sizes, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)\nax.axis('equal')\nax.set_title('Defect Types')\n\nplt.show()","b97e1cd0":"print('The mean number of labels per image is {}'.format(labels_per_image.mean()))","9b64bb44":"fig, ax = plt.subplots(figsize=(6, 6))\nax.hist(labels_per_image)\nax.set_title('Number of Labels per Image')","a152429e":"print('There are {} images with no labels'.format(labels_per_image[labels_per_image == 0].count()))\nprint('There are {} images with 1 label'.format(labels_per_image[labels_per_image == 1].count()))\nprint('There are {} images with 2 labels'.format(labels_per_image[labels_per_image == 2].count()))\nprint('There are {} images with 3 labels'.format(labels_per_image[labels_per_image == 3].count()))","211fe6c4":"def get_image_sizes(train = True):\n    '''\n    Function to get sizes of images from test and train sets.\n    INPUT:\n        train - indicates whether we are getting sizes of images from train or test set\n    '''\n    if train:\n        path = TRAIN_PATH\n    else:\n        path = TEST_PATH\n        \n    widths = []\n    heights = []\n    \n    images = sorted(glob(path + '*.jpg'))\n    \n    max_im = Image.open(images[0])\n    min_im = Image.open(images[0])\n        \n    for im in range(0, len(images)):\n        image = Image.open(images[im])\n        width, height = image.size\n        \n        if len(widths) > 0:\n            if width > max(widths):\n                max_im = image\n\n            if width < min(widths):\n                min_im = image\n\n        widths.append(width)\n        heights.append(height)\n        \n    return widths, heights, max_im, min_im","5fe69f9b":"# get sizes of images from test and train sets\ntrain_widths, train_heights, max_train, min_train = get_image_sizes(train = True)\ntest_widths, test_heights, max_test, min_test = get_image_sizes(train = False)\n\nprint('Maximum width for training set is {}'.format(max(train_widths)))\nprint('Minimum width for training set is {}'.format(min(train_widths)))\nprint('Maximum height for training set is {}'.format(max(train_heights)))\nprint('Minimum height for training set is {}'.format(min(train_heights)))","7e12b7d3":"print('Maximum width for test set is {}'.format(max(test_widths)))\nprint('Minimum width for test set is {}'.format(min(test_widths)))\nprint('Maximum height for test set is {}'.format(max(test_heights)))\nprint('Minimum height for test set is {}'.format(min(test_heights)))","e98ae55b":"# https:\/\/www.kaggle.com\/titericz\/building-and-visualizing-masks\ndef rle2maskResize(rle):\n    # CONVERT RLE TO MASK \n    if (pd.isnull(rle))|(rle=='')|(rle=='-1'): \n        return np.zeros((256,1600) ,dtype=np.uint8)\n    \n    height= 256\n    width = 1600\n    mask= np.zeros( width*height ,dtype=np.uint8)\n\n    array = np.asarray([int(x) for x in rle.split()])\n    starts = array[0::2]-1\n    lengths = array[1::2]    \n    for index, start in enumerate(starts):\n        mask[int(start):int(start+lengths[index])] = 1\n    \n    return mask.reshape( (height,width), order='F' )","98146acb":"def plot_mask(image_filename):\n    '''\n    Function to plot an image and segmentation masks.\n    INPUT:\n        image_filename - filename of the image (with full path)\n    '''\n    img_id = image_filename.split('\/')[-1]\n    image = Image.open(image_filename)\n    train = train_df.fillna('-1')\n    rle_masks = train[(train['Image'] == img_id) & (train['EncodedPixels'] != '-1')]['EncodedPixels'].values\n    \n    defect_types = train[(train['Image'] == img_id) & (train['EncodedPixels'] != '-1')]['Label'].values\n    \n    if (len(rle_masks) > 0):\n        fig, axs = plt.subplots(1, 1 + len(rle_masks), figsize=(20, 3))\n\n        axs[0].imshow(image)\n        axs[0].axis('off')\n        axs[0].set_title('Original Image')\n\n        for i in range(0, len(rle_masks)):\n            mask = rle2maskResize(rle_masks[i])\n            axs[i + 1].imshow(image)\n            axs[i + 1].imshow(mask, alpha = 0.5, cmap = \"Reds\")\n            axs[i + 1].axis('off')\n            axs[i + 1].set_title('Mask with defect #{}'.format(defect_types[i]))\n\n        plt.suptitle('Image with defect masks')\n    else:\n        fig, axs = plt.subplots(figsize=(20, 3))\n        axs.imshow(image)\n        axs.axis('off')\n        axs.set_title('Original Image without Defects')","191cba4a":"# plot image with single defect\nplot_mask(train_fns[0])","4a6fc2ff":"# plot image without defects\nplot_mask(train_fns[1])","bbd3fed0":"# plot image example with several defects\nfor image_code in train_df.Image.unique():\n    if (train_df.groupby(['Image'])['EncodedPixels'].count().loc[image_code] > 1):\n        plot_mask(TRAIN_PATH + image_code)\n        break;","9b778098":"def get_mask(line_id):\n    '''\n    Function to visualize the image and the mask.\n    INPUT:\n        line_id - id of the line to visualize the masks\n    RETURNS:\n        np_mask - numpy segmentation map\n    '''\n    \n    # convert rle to mask\n    rle = train_df.loc[line_id]['EncodedPixels']\n    \n    np_mask = rle2maskResize(rle)\n    np_mask = np.clip(np_mask, 0, 1)\n        \n    return np_mask\n\ndef add_mask_areas(train_df):\n    '''\n    Helper function to add mask area as a new column to the dataframe\n    INPUT:\n        train_df - dataset with training labels\n    '''\n    masks_df = train_df.copy()\n    masks_df['Area'] = 0\n        \n    for i, row in masks_df.iterrows():\n        masks_df['Area'].loc[i] = np.sum(get_mask(i))\n    \n    return masks_df","fef06cfa":"masks_df = add_mask_areas(train_df)","44e0d965":"# Plot Histograms and KDE plots\nplt.figure(figsize=(15,7))\n\nplt.subplot(221)\nsns.distplot(masks_df[masks_df['Label'] == '1']['Area'].values, kde=False, label='Defect #1')\nplt.legend()\nplt.title('Mask Area Histogram : Defect #1', fontsize=15)\n\nplt.subplot(222)\nsns.distplot(masks_df[masks_df['Label'] == '2']['Area'].values, kde=False, label='Defect #2')\nplt.legend()\nplt.title('Mask Area Histogram: Defect #2', fontsize=15)\n\nplt.subplot(223)\nsns.distplot(masks_df[masks_df['Label'] == '3']['Area'].values, kde=False, label='Defect #3')\nplt.legend()\nplt.title('Mask Area Histogram : Defect #3', fontsize=15)\n\nplt.subplot(224)\nsns.distplot(masks_df[masks_df['Label'] == '4']['Area'].values, kde=False, label='Defect #4')\nplt.legend()\nplt.title('Mask Area Histogram: Defect #4', fontsize=15)\n\nplt.tight_layout()\nplt.show()","8cd0cd97":"plt.figure(figsize=(15,4))\n\nplt.subplot(111)\nsns.kdeplot(masks_df[masks_df['Label'] == '1']['Area'].values, label='Defect #1')\nsns.kdeplot(masks_df[masks_df['Label'] == '2']['Area'].values, label='Defect #2')\nsns.kdeplot(masks_df[masks_df['Label'] == '3']['Area'].values, label='Defect #3')\nsns.kdeplot(masks_df[masks_df['Label'] == '4']['Area'].values, label='Defect #4')\nplt.legend()\n\nplt.title('Mask Area KDE Plot', fontsize=15)","52ccd1a6":"def plot_image_grid(df, n_images = 5):\n    \n    fig, axs = plt.subplots(n_images, 2, figsize=(20, 10))\n    \n    for i in range(n_images):\n        image_id = np.random.randint(0,len(df),1)[0]\n\n        image = Image.open(TRAIN_PATH + df.iloc[image_id]['Image'])\n        mask = rle2maskResize(df.iloc[image_id]['EncodedPixels'])\n        \n        defect = df.iloc[image_id]['Label']\n\n        axs[i,0].imshow(image)\n        axs[i,0].axis('off')\n        axs[i,0].set_title('Original Image')\n\n        axs[i, 1].imshow(image)\n        axs[i, 1].imshow(mask, alpha = 0.5, cmap = \"Reds\")\n        axs[i, 1].axis('off')\n        axs[i, 1].set_title('Mask with defect #{}'.format(defect))\n\n    plt.suptitle('Images with defect masks')","d2386468":"# filter the dataframe, so we have only images with very large masks\nlarge_masks_df = masks_df[masks_df['Area'] > 200000]","deac915f":"# plot a grid of images with large masks\nplot_image_grid(large_masks_df, n_images = 5)","7266f13c":"from scipy.ndimage import label, generate_binary_structure\n\ndef add_mask_number(train_df):\n    '''\n    Helper function to add mask area as a new column to the dataframe\n    INPUT:\n        train_df - dataset with training labels\n    '''\n    masks_df = train_df.copy()\n    masks_df['NumMasks'] = 0\n    \n    s = generate_binary_structure(2,2)\n        \n    for i, row in masks_df.iterrows():\n        mask = get_mask(i)\n        \n        if np.sum(mask) > 0:\n            labeled_array, labels = label(mask, structure=s)\n            masks_df['NumMasks'].loc[i] = labels\n        else:\n            masks_df['NumMasks'].loc[i] = 0\n    \n    return masks_df","3996b0aa":"masks_df = add_mask_number(masks_df)","e9999b7f":"# Plot Histograms and KDE plots\nplt.figure(figsize=(15,7))\n\nplt.subplot(221)\nsns.distplot(masks_df[masks_df['Label'] == '1']['NumMasks'].values, kde=False, label='Defect #1')\nplt.legend()\nplt.title('Number of Masks Histogram : Defect #1', fontsize=15)\n\nplt.subplot(222)\nsns.distplot(masks_df[masks_df['Label'] == '2']['NumMasks'].values, kde=False, label='Defect #2')\nplt.legend()\nplt.title('Number of Masks Histogram: Defect #2', fontsize=15)\n\nplt.subplot(223)\nsns.distplot(masks_df[masks_df['Label'] == '3']['NumMasks'].values, kde=False, label='Defect #3')\nplt.legend()\nplt.title('Number of Masks Histogram : Defect #3', fontsize=15)\n\nplt.subplot(224)\nsns.distplot(masks_df[masks_df['Label'] == '4']['NumMasks'].values, kde=False, label='Defect #4')\nplt.legend()\nplt.title('Number of Masks Histogram: Defect #4', fontsize=15)\n\nplt.tight_layout()\nplt.show()","53e11c0d":"plt.figure(figsize=(15,4))\n\nplt.subplot(111)\nsns.kdeplot(masks_df[masks_df['Label'] == '1']['NumMasks'].values, label='Defect #1')\nsns.kdeplot(masks_df[masks_df['Label'] == '2']['NumMasks'].values, label='Defect #2')\nsns.kdeplot(masks_df[masks_df['Label'] == '3']['NumMasks'].values, label='Defect #3')\nsns.kdeplot(masks_df[masks_df['Label'] == '4']['NumMasks'].values, label='Defect #4')\nplt.legend()\n\nplt.title('Number of masks KDE Plot', fontsize=15)","aa7b6def":"# filter the dataframe, so we have only images with very large masks\nmany_masks_df = masks_df[masks_df['NumMasks'] > 15]","bb6e580d":"plot_image_grid(many_masks_df, n_images = 5)","b58ea033":"from scipy.ndimage.morphology import binary_dilation, binary_erosion, binary_opening\n\ndef get_mask_edges(mask):\n    \n    s = generate_binary_structure(2,2)\n    \n    mask = mask - binary_erosion(mask, structure = s)\n    mask = binary_dilation(binary_dilation(mask, structure = s))\n    \n    return mask\n\ndef plot_image_grid_edges(df, n_images = 5):\n    \n    fig, axs = plt.subplots(n_images, 2, figsize=(20, 10))\n    \n    for i in range(n_images):\n        image_id = np.random.randint(0,len(df),1)[0]\n\n        image = Image.open(TRAIN_PATH + df.iloc[image_id]['Image'])\n        mask = rle2maskResize(df.iloc[image_id]['EncodedPixels'])\n        \n        mask = get_mask_edges(mask)\n        \n        defect = df.iloc[image_id]['Label']\n\n        axs[i,0].imshow(image)\n        axs[i,0].axis('off')\n        axs[i,0].set_title('Original Image')\n\n        axs[i, 1].imshow(image)\n        axs[i, 1].imshow(mask, alpha = 0.5, cmap = \"Reds\")\n        axs[i, 1].axis('off')\n        axs[i, 1].set_title('Mask with defect #{}'.format(defect))\n\n    plt.suptitle('Images with defect masks')","f83f92b9":"plot_image_grid_edges(many_masks_df, n_images = 5)","8f32e8a7":"ia.seed(31)\nnp.random.seed(27240)\n\n# initialize augmentations\nseq = iaa.Sequential([\n    iaa.Fliplr(0.5), # horizontal flips\n    iaa.Crop(percent=(0, 0.1)), # random crops\n    # Small gaussian blur with random sigma between 0 and 0.5.\n    # But we only blur about 50% of all images.\n    iaa.Sometimes(0.5,\n        iaa.GaussianBlur(sigma=(0, 0.5))\n    ),\n    # Strengthen or weaken the contrast in each image.\n    iaa.ContrastNormalization((0.75, 1.5)),\n    # Add gaussian noise.\n    # For 50% of all images, we sample the noise once per pixel.\n    # For the other 50% of all images, we sample the noise per pixel AND\n    # channel. This can change the color (not only brightness) of the\n    # pixels.\n    iaa.AdditiveGaussianNoise(loc=0, scale=(0.0, 0.05*255), per_channel=0.5),\n    # Make some images brighter and some darker.\n    # In 20% of all cases, we sample the multiplier once per channel,\n    # which can end up changing the color of the images.\n    iaa.Multiply((0.8, 1.2), per_channel=0.2),\n    # Apply affine transformations to each image.\n    # Scale\/zoom them, translate\/move them, rotate them and shear them.\n    iaa.Affine(\n        scale={\"x\": (0.8, 1.2), \"y\": (0.8, 1.2)},\n        translate_percent={\"x\": (-0.2, 0.2), \"y\": (-0.2, 0.2)},\n        rotate=(-25, 25),\n        shear=(-8, 8)\n    )\n], random_order=True) # apply augmenters in random order\n\n# generate random index for an image\nrnd_index = np.random.choice(range(len(train_df) \/\/ 4)) * 4\n\n# open the image\nimage = np.asarray(Image.open(TRAIN_PATH + train_df.iloc[rnd_index]['Image']))\n\n# get masks for different classes\nmask_1 = rle2maskResize(train_df.iloc[rnd_index]['EncodedPixels'])\nmask_2 = rle2maskResize(train_df.iloc[rnd_index + 1]['EncodedPixels'])\nmask_3 = rle2maskResize(train_df.iloc[rnd_index + 2]['EncodedPixels'])\nmask_4 = rle2maskResize(train_df.iloc[rnd_index + 3]['EncodedPixels'])\n\n# label numpy map with 4 classes\nsegmap = np.zeros((image.shape[0], image.shape[1]), dtype=np.int32)\nsegmap = np.where(mask_1 == 1, 1, segmap)\nsegmap = np.where(mask_2 == 1, 2, segmap)\nsegmap = np.where(mask_3 == 1, 3, segmap)\nsegmap = np.where(mask_4 == 1, 4, segmap)\n\n# create a segmantation map\nsegmap = SegmentationMapOnImage(segmap, shape=image.shape, nb_classes=5)\n\n# apply augmentation for image and mask\nimage_aug, segmap_aug = seq(image=np.asarray(image), segmentation_maps=segmap)\n\n# visualize the image and map\nside_by_side = np.hstack([\n    np.asarray(segmap.draw_on_image(image)).reshape(np.asarray(image).shape),\n    np.asarray(segmap_aug.draw_on_image(image_aug)).reshape(np.asarray(image).shape)\n])\n\nfig, ax = plt.subplots(figsize=(15, 7))\nax.axis('off')\nplt.title('Segmentation maps (original and augmented image)')\n\nax.imshow(side_by_side)","86a25188":"`train.csv` file contains:\n* __4 rows__ for each image from the train set. Each row corresponds to one of the defect labels.\n* `ImageId_ClassId` is a combination of an image filename and the defect label.\n* `EncodedPixels` column contains RLE encoded mask for the particular defect type or is empty, when the defect is not found.","15ee5fcd":"Masks with large areas seem very suspicious to me, so I will try to plot several examples of images with large mask areas picked by random index:","e180e6fa":"# EDA for Steel Defect Competition","a250afac":"The production of flat steel is especially delicate. Today, Severstal uses images from high frequency cameras to power a defect detection algorithm.\nBetter __defect indentication with deep learning could make steel production more efficient__.","3bf2d65b":"Plot some image and masks examples:","7ecbb3cd":"More information on steel defects can be found here:\n[Use Machine Learning to Detect Defects on the Steel Surface](https:\/\/software.intel.com\/en-us\/articles\/use-machine-learning-to-detect-defects-on-the-steel-surface) article with example images for each possible defect type.","1accf913":"Analyse the number of labels for each defect type:","a0f23b5c":"__Conclusions:__\n* Almost half of images doesn't contain any defects;\n* __Most of images with defects contain the defects of only one type__;\n* In rare cases an image contains the defects of two different types.","ed430146":"![image](https:\/\/github.com\/Lexie88rus\/steel_defect_detection\/raw\/master\/assets\/cover_large.png)","7f242516":"Comparing to the images with large area masks, I can say that in this competition we are probably dealing with __inconsistent masking__:\n* Some images contain precisely cropped defects with very small empty space amount.\n* Some images contain large masks with both large defect and empty space areas.","de064fe1":"__Conclusions:__\n* The __dataset is very imbalanced.__\n* Data augmentation and resampling techniques will be required to perform the defect detection.","98f63054":"## Conclusions:\nIn this kernel I:\n* Explored the number of samples in train and test sets.\n* Explored the number of training samples for each defect class.\n* Visualized the examples of defects.\n* Analyzed mask areas and number masks for each defect type.\n\n__Your comments and suggestions on how to improve this kernel are highly appreciated!__","db3a191a":"Visualize the images with plenty of masks:","295b5751":"`4.` Analyze the number of masks per image:","409225ea":"I added some helper code to __view only the edges of the masks__:","b11614b8":"Define train and test paths and explore train and test sets:","163ee4d2":"`2.` Visualize masks:","37de858e":"At first, I would like to split the 1st column:","5a014f96":"I would also like to demosnstrate how it is possible to apply the data augmentation from __imgaug__ library for the images (see the example [here](https:\/\/imgaug.readthedocs.io\/en\/latest\/source\/examples_basics.html)):","a7a5a801":"Large masks seem to be okay, except for the fact that these masks seem to contain a lot of empty space without any defects","e29c5c71":"`2` Explore the labels:","19b23dee":"## Explore Labels and Masks","98f568e5":"`5.` Add some data augmentation:","1fcb7018":"`1.` Explore the image sizes:","b47111b9":"Explore the `train.csv` file:","ab91aaf0":"`3.` Analyze mask area sizes","b49fb33e":"## Analyze Images","4756d7c0":"__Conclusions:__\n* We see that all images have the same size.","5d8ffad6":"## About the Competition","343b2702":"## Load Data","e2ca5491":"`1` Explore empty masks:","83422324":"## References\n1. [Kaggle kernel](https:\/\/www.kaggle.com\/titericz\/building-and-visualizing-masks) on building and visualizing masks.\n2. [My EDA for Cloud competition](https:\/\/www.kaggle.com\/aleksandradeis\/understanding-clouds-eda) with similar code.\n3. [imgaug](https:\/\/imgaug.readthedocs.io\/en\/latest\/source\/examples_basics.html) documentation.","e6d5bf0d":"## Revision History:\n1. The initial public version.\n2. Added visualization of images with large mask areas and with many masks.\n3. Added the example of simple data augmentation pipeline.\n4. Corrected small issues.\n5. Added helper function to view only edges of defect masks.\n6. Corrected the issues with the number of labels per image.","f877e241":"Utility function to create the mask from RLE (I borrowed the implementation from [this kernel](https:\/\/www.kaggle.com\/titericz\/building-and-visualizing-masks)):","1b2a6df4":"**Conclusions:**\n1. From the plots we can see that the defect 3 is the most common defect found on steel images.\n2. Defects type 2 and 4 are very rare, but there are often multiple masks with this defect on a single image."}}