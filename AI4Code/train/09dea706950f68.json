{"cell_type":{"9e8022be":"code","773644d6":"code","3df6256b":"code","19d31603":"code","f27f1c70":"code","29ee73ea":"code","d522ce3a":"code","9d02ad4f":"code","13e0de45":"code","46ec5374":"code","4adf165c":"code","35d56c79":"code","451d17fc":"code","e16b86fd":"code","6e704785":"code","7f5fd9e4":"code","0e53f08f":"code","02be01c8":"code","6f95490d":"code","6730722f":"code","05788bce":"code","b3f1958f":"code","8bda74d1":"code","1ccbca94":"code","caeb6461":"code","0ca41663":"code","34917665":"code","a4b8a39f":"code","7143b3f7":"code","30858eb3":"code","a0d05ab6":"code","a0abba68":"code","2c04062f":"code","9a78f5f1":"code","8996a80f":"code","bb728acc":"code","50968997":"code","c1f3c42a":"code","07db52ab":"code","f2d4ccea":"code","6d38613b":"code","1425c72e":"code","9917cdf4":"code","5dabab08":"code","07028e15":"code","cf03a889":"code","34e52b28":"code","0872e13d":"code","a54c1216":"code","a4f7984b":"code","8d9ab28d":"code","415f0cfd":"code","2b8546ee":"code","7ad1f992":"code","cc9abeb1":"markdown","3b8087df":"markdown","d4094652":"markdown","fa1879fe":"markdown","928c2aba":"markdown","cc0edbb0":"markdown","33142aee":"markdown","e195cb8f":"markdown","4ce086d7":"markdown","b7dc0297":"markdown","7a59f4c0":"markdown","801aa8ef":"markdown","0c712844":"markdown","e71b396e":"markdown","6628b4aa":"markdown","002563f0":"markdown","8aa3b4ee":"markdown","736762ea":"markdown","6dd4f83b":"markdown","b57a8d76":"markdown","088cf947":"markdown"},"source":{"9e8022be":"#1\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom scipy import stats\nimport seaborn as sns; sns.set(color_codes=True)\nfrom operator import itemgetter\n%matplotlib inline\n%config InlineBackend.figure_formats=['svg']\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n","773644d6":"# Our 1st task will be to upload our IBGE dataset to Kaggle and then command it to open.\n#Below is a pretty cool video by Kaggle on Youtube showing how to upload your dataset, \n#plus the innitial commands to start using your data. Hope it helps!\n\nfrom IPython.display import HTML\nHTML('<iframe width=\"560\" height=\"315\" src=\"https:\/\/www.youtube.com\/embed\/0jQwAp7po00\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>')\n     \n     \n","3df6256b":"#it worked!!! Dataset open...Let's test it with a file.head command\ndf = pd.read_csv(\"..\/input\/data.csv\")\n","19d31603":"df.head()\n#gives you the command's default top 5 rows in your table","f27f1c70":"df.tail(10)\n#gives you the bottom 10 rows of your table","29ee73ea":"df.shape\n\n#df.shape: Gives you the #of rows and columns","d522ce3a":"df.dtypes\n\n#types of characters and spacing allowed","9d02ad4f":"df.info()\n\n#with total entries, rows and columns","13e0de45":"df.describe()\n\n#basic stats information","46ec5374":"df.columns\n\n#introduce you to the columns contained in our table","4adf165c":"for col in df:\n    if col != 'seq' and col != 'id':\n        print('')\n        print(df[col].value_counts(dropna=False).nlargest(10))\n        \ndf.describe()\n\n#!= Not Equal To","35d56c79":"df['regiao'].value_counts(dropna=False)\n\n# Absence of NaN values\n#For 'regiao' calculate how many rows there are for each of the 5 regions using value_counts()","451d17fc":"df.regiao.value_counts().plot(kind = 'bar')","e16b86fd":"df.sort_values(['regiao'], ascending = True).head(10)\n\n\n#Here we want to sort our table by 'regiao' in alphabetical ascending order, and to bring only the top 10 rows","6e704785":"df.columns","7f5fd9e4":"df.rename(columns={'cor\/raca':'cor_raca'}, inplace=True)\ndf.columns\n\n#noticed the change?","0e53f08f":"df.cor_raca.value_counts().plot.bar()\n\n#all 5 categories plotted in a bar graph","02be01c8":"x1 = list(df[df['cor_raca'] == 'Branca']['regiao'])\nx2 = list(df[df['cor_raca'] == 'Parda']['regiao'])\nx3 = list(df[df['cor_raca'] == 'Preta']['regiao'])\nx4 = list(df[df['cor_raca'] == 'Indigena']['regiao'])\nx5 = list(df[df['cor_raca'] == 'Amarela']['regiao'])\n\n# Assign colors for each race and the names\n\ncolors = ['#E69F00', '#56B4E9', '#D55E00', '#009E73', '#F0E442']\nnames = ['Branca', 'Parda', 'Preta','Indigena', 'Amarela']\n         \n# Make the histogram using a list of lists\n# Normalize the flights and assign colors and names\nplt.hist([x1, x2, x3, x4, x5], bins = 5, normed=True,\n         color = colors, label=names)\n\n# Plot formatting\nplt.legend()\n","6f95490d":"df['estado_civil'] = df['estado_civil'].map({0:'solteiro',1:'casado'})","6730722f":"df.estado_civil.value_counts().plot.bar()","05788bce":"df['idade'].value_counts()\n#For 'idade' calculate how many rows there are for all different ages using value_counts()","b3f1958f":"df['idade'].value_counts(dropna=False).nlargest(10)\n\n#We can see no NaN have come up.","8bda74d1":"(df.idade.value_counts()).shape","1ccbca94":"\n\nplt.hist(df['idade'], color = 'green', edgecolor = 'black', bins = (41))","caeb6461":"df['idade'].plot.kde()\n\n#","0ca41663":"df['sexo'].value_counts()","34917665":"df = df.replace('gestante', 'mulher')","a4b8a39f":"df['sexo'].value_counts(dropna=False)","7143b3f7":"df['salario'].value_counts(dropna=False).nlargest(10)\n\n#nlargest for the program to bring the largest 10 values\n\n#When we call a variable in Python, the program does not bring NaN values by default. For that reason \n#we need to use function dropna = True to force it to show such values.By\n#using dropna=False, Python will bring the values not filled in the dataset.\n#We can also use function fillna() to fill the the missing or NaN values in the pandas dataframe\n#with a suitable data as decided by the user.","30858eb3":"#Now, for some graph.\n\ndf['salario'].plot.hist(bins=100)\n","a0d05ab6":"df['salario'].plot.hist(bins=500, xlim=(-2000, 100000))","a0abba68":"df['salario'].value_counts(dropna=False).nlargest(7)\n","2c04062f":"df['salario'].fillna(df['salario'].median(), inplace=True)","9a78f5f1":"df['salario'].value_counts(dropna=False).nlargest(7)","8996a80f":"df['salario'].plot.hist(bins=500, xlim=(-2000, 100000))","bb728acc":"UPPER_BOUND_SALARY = 100000\n\nmask_salary = (df['salario'] > 0) & (df['salario'] < UPPER_BOUND_SALARY)\nfiltered_df = df[mask_salary]\nfiltered_df['salario'].max()","50968997":"\ndf_white_male = filtered_df[filtered_df['cor_raca'] == 'Branca']\ndf_white_male[['salario']].plot.hist(bins = 20)\nmean_white_male = df_white_male['salario'].mean()\nstd_white_male = df_white_male['salario'].std()\n\ndf_black_male = filtered_df[filtered_df['cor_raca'] == 'Preta']\ndf_black_male[['salario']].plot.hist(bins = 20)\nmean_black_male = df_black_male['salario'].mean()\nstd_black_male = df_black_male['salario'].std()\n\ndf_brown_male = filtered_df[filtered_df['cor_raca'] == 'Parda']\ndf_brown_male[['salario']].plot.hist(bins = 20)\nmean_brown_male = df_brown_male['salario'].mean()\nstd_brown_male = df_brown_male['salario'].std()\n\ndf_indigenous_male = filtered_df[filtered_df['cor_raca'] == 'Indigena']\ndf_indigenous_male[['salario']].plot.hist(bins = 20)\nmean_indigenous_male = df_indigenous_male['salario'].mean()\nstd_indigenous_male = df_indigenous_male['salario'].std()\n\ndf_yellow_male = filtered_df[filtered_df['cor_raca'] == 'Indigena']\ndf_yellow_male[['salario']].plot.hist(bins = 20)\nmean_yellow_male = df_yellow_male['salario'].mean()\nstd_yellow_male = df_yellow_male['salario'].std()\n\n","c1f3c42a":"print('White male average salary:',mean_white_male)\nprint('Black male average salary:',mean_black_male)\nprint('White males earn more, on average, than black males')\n\n#std_white_male","07db52ab":"print('White male average salary:',mean_white_male)\nprint('Brown male average salary:',mean_brown_male)\nprint('White males earn more, on average, than brown males')\n","f2d4ccea":"print('White male average salary:', mean_white_male)\nprint('Indigenous male average salary:', mean_indigenous_male)\nprint('White males earn more, on average, than indigenous males')\n","6d38613b":"print('White male average salary:', mean_white_male)\nprint('Yellow male average salaries:',mean_yellow_male)\nprint('White males earn more, on average, than yellow males')\n","1425c72e":"mask_1 = (df['sexo'] == 'mulher') & (df['salario']>=0) & (df['salario']<600000)\nmask_2 = (df['sexo'] == 'homem') & (df['salario']>=0) & (df['salario']<600000)\n\n#by limiting our returns to values >=0 & <=600k we are eliminating outliers that could disturb our analysis.","9917cdf4":"df['salario'][mask_1].describe()","5dabab08":"df['salario'][mask_2].describe()\n","07028e15":"df['salario'][mask_1].plot.kde()\n\n#In statistics, kernel density estimation (KDE) is a non-parametric way to estimate the probability density function (PDF)\n#of a random variable. This function uses Gaussian kernels and includes automatic bandwidth determination.","cf03a889":"df['salario'][mask_2].plot.kde()","34e52b28":"df_men = df[df['sexo'] == 'homem']\ndf_women = df[df['sexo'] == 'mulher']\n\n#separating gender data into two distinct dataframes (men & women)","0872e13d":"mean_salary_men= df_men['salario'].mean()\nmedian_salary_men = df_men['salario'].median()\nmode_salary_men= df_men['salario'].idxmax()\n\nmean_salary_women = df_women['salario'].mean()\nmedian_salary_women = df_women['salario'].median()\nmoda_salary_women = df_women['salario'].idxmax()\n\n#Testing our hypothesis ==> men have higher salaries than women by ways of mean, median, and mode","a54c1216":"mean_salary_men > mean_salary_women","a4f7984b":"median_salary_men > median_salary_women","8d9ab28d":"mode_salary_men > moda_salary_women","415f0cfd":"print('Men mean salary =',\"%.2f\"% mean_salary_men,'Women mean salary =',\"%.2f\"% mean_salary_women)\nprint('Men median salary =',\"%.2f\"% median_salary_men,'Women median salary =',\"%.2f\"% median_salary_women)\nprint('Most frequent salary for men =',\"%.2f\"% mode_salary_men,'Most frequent salary for women =',\"%.2f\"% moda_salary_women)","2b8546ee":"df_men.dropna(inplace=True)\ndf_women.dropna(inplace=True)","7ad1f992":"from matplotlib import pyplot\n\nbins = 100\n\nax = pyplot.hist(df_men['salario'], bins, alpha=0.5, label='Men Salary',color='blue')\nax = pyplot.hist(df_women['salario'], bins, alpha=0.5, label='Women Salary',color='red')\n\npyplot.legend(loc='upper right')\npyplot.show()","cc9abeb1":"## With our boundaries set we can now move on to testing our hypothesis.","3b8087df":"# **Testing Hypothesis on Brazil's Wage Inequalities:** \n## White vs. Other races\n## Men vs. Women \n\n\n## In a nutshell, we will be taking a closer look at Brazil's wage gaps, primarily those between genders and races. This Notebook was designed for those whom, like myself, are starting their journey into the Data Science Universe.  The goal is not only to provide insight into the persistent inequalities that permeate the Brazilian society, but also to extract value which can later be put to use for the betterment of all people. For this analysis we will use a dataset provided by The Brazilian Institute of Geography and Statistics (IBGE).\n\n## Initialy, we will breakdown some basic commands in order to have a general view from the dataset we are working with.\n##  Open and read data from the DataFrame.\n##  Create an analysis of each column inside the table through the use of value counting tools.\n\n## Later, we will elaborate and test hypothesis.\n\n# **Tools required:**\n\n## The modern world of data science offers multiple ways of analyzing and predicting patterns. **Python is the programming language used for this exercise**. I personally use it under the umbrella of the **Anaconda distribution**. I will also be hoping to learn a lot from this exercise, so feedback is very welcome.\n\n# **The main libraries that we will use are:**\n\n## Numpy: Library for multidimensional arrays with high level mathematical functions to operate them\n## Pandas: Works on top of Numpy, offer a great way of manipulate and analyse data.\n## Matblotlib: Plotting and visualization.\n## Seaborn: Works on top of matplotlib to provide a high level interface for attractive plotting and visualization.\n","d4094652":"## Still under age, we can count the frequency of occurances and find out whether there are any NaN values with the dropna=False function.","fa1879fe":"# ****Variable treatment****\n\n## Next step we will be treating variables using methods included in Pandas. This should eliminate outliers, bias and other factors that could possible disturb the randomness of our analysis. We will also introduce some cool graphs to turn our dataset into a vizualization POWERHOUSE!","928c2aba":"## Then, we can generate a basic analysis of each column's contents and include a value_counts for all of them. We will neither return  column 'id' nor column 'seq'.\n\n","cc0edbb0":"# **Marital Status**\n\n## For the variable 'estado_civil' we need to atribute values to this binary variable. For instance, for single people or 'solteiro'  we can give it a value of 0, and for married people or 'casado' we will attribute 1. We will use a map function with a dictionary to attribute those values.\n\n### Python map() function is used to apply a function on all the elements of specified iterable and return map object. Python map object is an iterator, so we can iterate over its elements. We can also convert map object to sequence objects such as list, tuple etc. using their factory functions.","33142aee":"# **Gender**\n\n## For this variable, we need to add the value \"gestante\" or pregnant to the variable \"mulher\" or woman, as follow:","e195cb8f":"## Now, we can count the amount of items in the 'age' series which we will then use to create a histogram and a KDE graphs with the right amount of bins.","4ce086d7":"##   ","b7dc0297":"# **Hypothesis 2:**\n\n## \ud835\udc3b0  = On average, men have higher salaries than women\n## \ud835\udc3b1  = On average, men have lower salaries than women","7a59f4c0":"## **Smoothing out NaN values in our Salary variable**\n\n## Looking at the value_counts of our salary variable we notice the NaN value to be the largest of them all. NaN, or 'not a number' is the return of values that were not filled for a variety of reasons (e.g. people did not know the exact figure of their salaries, or did not feel comfortable making this information available, etc). Whatever the reason might be, it is the job of the Data Scientist to not allow NaN values to disturb the harmony of our statistical analysis.\n\n## One way of doing this is by calculating the median of our the salary variable and replace the NaNs for the values found. We could have calculated the mean but because this a non-symmmetric distribution, the mean would be influenced by outliers on both ends of our distribution. The best solution then is to substitute our NaNs by the median of our salary values.\n\n### .fillna() ==> We will use this function to filter the NaN values. The parameter() is what I want to replace my NaNs.\n\n### inplace = True ==> ","801aa8ef":"# **Color of Skin & Race**\n## The 'cor\/raca' variable is also a nominal qualitative variable with 5 categories. As a matter of good practice in the coding community, we will eliminate the bar (\/) and replace it by an underline signal  ( _ ).\n\n### Then we will plot a bar graph using matplotlib.","0c712844":"## We tested our hypothesis to be true. On average, men have higher salaries than women. Also, men's median salary turned out  to be higher as well. The most frequent salary for women, however, came as higher than those for men at $1099,00.\n\n## This should become more evident in the histogram below:","e71b396e":"## Another way would be to set lower and upper boundaries to our salary variable.","6628b4aa":"## As we can see above, mathematically we can accept our \ud835\udc3b0  Null Hypothesis which states that white males earn more, on average, than other races.","002563f0":"# **Age**","8aa3b4ee":"\n## For this analysis we will be using masks. When working with data arrays masks can be extremely useful. Masks are an array of boolean values for which a condition is met. These boolean arrays are then used to sort in the original data array (say we only want values above a given value).","736762ea":"\n\n# **Hypothesis 1:**\n\n## \ud835\udc3b0  = On average, White males have higher salaries than other races\n## \ud835\udc3b1  = On average, White males have lower salaries than other races\n\n### To do that, we will conduct what is called in statistics a Central Tendency Analysis of the mean of our variable salary for white males and cross that with the other 4 race categories.\n\n","6dd4f83b":"# **Salary**\n\n## Salary, or \"salarios\" is perhaps our most important variable. It is the variable salary that will allow for the most importnt insights from this dataset. For that reason, it is important that we locate outliers and NaN values and smooth them up in order to have a balanced analysis.","b57a8d76":"## To make the visualization of our graph more pleasing, we will use function xlim to shorten the right tail of our curve by 900k. Also, we will give a negative value on the left of our x-axis in order to not have our first bin crammed on top of our y-axis. \n## We should also increase the number of bins, that way we can make the visualization more pleasing by spreading the data.\n## It is important to note that the extreme values to the right are still present; however, they have such a low frequency and will be important to vizualize at this time.","088cf947":"# **Regions**\n## The 'regiao' variable is a nominal qualitative variable with 5 categories. We will first give it a count and then graph using matplotlib kind graph."}}