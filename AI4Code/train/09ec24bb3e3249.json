{"cell_type":{"413dba54":"code","c1653a6b":"code","b1507be7":"code","7ccf3498":"code","3da4c8b9":"code","d1178312":"code","dd6a3fab":"code","2fbc79af":"code","584b68d8":"code","76c9843b":"code","447fb335":"code","10a1f604":"code","a0cffb1f":"code","1ca55cb8":"code","a06441c1":"code","7c94dd65":"code","deb7ceae":"code","e29a2bc1":"code","629cfa6b":"code","74be770e":"code","72d7b482":"code","2e3ad5dd":"code","05552b95":"code","fc42dbff":"code","ccc99485":"code","127c091f":"code","c4517571":"code","ababaedb":"code","787d12bd":"code","0f809385":"code","e074708a":"code","e97694cc":"code","2ac1c87c":"code","a8b7792f":"code","80009f29":"code","2db99fac":"code","afc4f373":"code","aa124028":"markdown","f68d90c5":"markdown","56466d62":"markdown","21f62674":"markdown","3871fdaa":"markdown","d7f1fb3e":"markdown","7256e343":"markdown","ad7ae417":"markdown","ed3386ac":"markdown","c2e8602f":"markdown","8329ece5":"markdown","c6adc8c9":"markdown","e47ce6c2":"markdown","37bf237d":"markdown","f02dc06a":"markdown","f1997d60":"markdown","ac28ffff":"markdown","a72257c3":"markdown","3cc10dfa":"markdown"},"source":{"413dba54":"# Import Dependencies\n%matplotlib inline\n\n# Start Python Imports\nimport math, time, random, datetime\n\n# Data Manipulaiton\nimport numpy as np\nimport pandas as pd\n\n# Data Visualisation\nimport matplotlib.pyplot as plt\nimport missingno\nimport seaborn as sns\nimport plotly.express as px\nplt.style.use('seaborn-whitegrid')\nfrom mpl_toolkits.mplot3d import Axes3D\n\n#Preprocessing\nfrom sklearn.preprocessing import StandardScaler\nimport os\n\n#SQL\nimport sqlite3, csv\nfrom sqlalchemy import create_engine\n\nprint(\"Setup Complete\")\n\n# Ignoring warning \nimport warnings\nwarnings.filterwarnings('ignore')","c1653a6b":"chess_filepath = \"..\/input\/chess\/games.csv\"\ngames_df = pd.read_csv(chess_filepath)\nprint(\"Import Complete\")","b1507be7":"# Distribution graphs (histogram\/bar graph) of column data\ndef plotPerColumnDistribution(df, nGraphShown, nGraphPerRow):\n    nunique = df.nunique()\n    df = df[[col for col in df if nunique[col] > 1 and nunique[col] < 50]] # For displaying purposes, pick columns that have between 1 and 50 unique values\n    nRow, nCol = df.shape\n    columnNames = list(df)\n    nGraphRow = (nCol + nGraphPerRow - 1) \/ nGraphPerRow\n    plt.figure(num = None, figsize = (6 * nGraphPerRow, 8 * nGraphRow), dpi = 80, facecolor = 'w', edgecolor = 'k')\n    for i in range(min(nCol, nGraphShown)):\n        plt.subplot(nGraphRow, nGraphPerRow, i + 1)\n        columnDf = df.iloc[:, i]\n        if (not np.issubdtype(type(columnDf.iloc[0]), np.number)):\n            valueCounts = columnDf.value_counts()\n            valueCounts.plot.bar()\n        else:\n            columnDf.hist()\n        plt.ylabel('counts')\n        plt.xticks(rotation = 90)\n        plt.title(f'{columnNames[i]} (column {i})')\n    plt.tight_layout(pad = 1.0, w_pad = 1.0, h_pad = 1.0)\n    plt.show()","7ccf3498":"# Correlation matrix\ndef plotCorrelationMatrix(df, graphWidth):\n    filename = df.dataframeName\n    df = df.dropna('columns') # drop columns with NaN\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    if df.shape[1] < 2:\n        print(f'No correlation plots shown: The number of non-NaN or constant columns ({df.shape[1]}) is less than 2')\n        return\n    corr = df.corr()\n    plt.figure(num=None, figsize=(graphWidth, graphWidth), dpi=80, facecolor='w', edgecolor='k')\n    corrMat = plt.matshow(corr, fignum = 1)\n    plt.xticks(range(len(corr.columns)), corr.columns, rotation=90)\n    plt.yticks(range(len(corr.columns)), corr.columns)\n    plt.gca().xaxis.tick_bottom()\n    plt.colorbar(corrMat)\n    plt.title(f'Correlation Matrix for {filename}', fontsize=15)\n    plt.show()","3da4c8b9":"# Scatter and density plots\ndef plotScatterMatrix(df, plotSize, textSize):\n    df = df.select_dtypes(include =[np.number]) # keep only numerical columns\n    # Remove rows and columns that would lead to df being singular\n    df = df.dropna('columns')\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    columnNames = list(df)\n    if len(columnNames) > 10: # reduce the number of columns for matrix inversion of kernel density plots\n        columnNames = columnNames[:10]\n    df = df[columnNames]\n    ax = pd.plotting.scatter_matrix(df, alpha=0.75, figsize=[plotSize, plotSize], diagonal='kde')\n    corrs = df.corr().values\n    for i, j in zip(*plt.np.triu_indices_from(ax, k = 1)):\n        ax[i, j].annotate('Corr. coef = %.3f' % corrs[i, j], (0.8, 0.2), xycoords='axes fraction', ha='center', va='center', size=textSize)\n    plt.suptitle('Scatter and Density Plot')\n    plt.show()","d1178312":"nRowsRead = 10000 # Cutting data into ~ half\n# games.csv has 20058 rows in reality, but we are only loading\/previewing the first 1000 rows\ndf1 = pd.read_csv('..\/input\/chess\/games.csv', delimiter=',', nrows = nRowsRead)\ndf1.dataframeName = 'games.csv'\nnRow, nCol = df1.shape\nprint(f'There are {nRow} rows and {nCol} columns')","dd6a3fab":"# Viewing first 5 rows\ndf1.head()","2fbc79af":"plotPerColumnDistribution(df1, 10, 5)","584b68d8":"plotCorrelationMatrix(df1, 8)","76c9843b":"plotScatterMatrix(df1, 18, 10)","447fb335":"print(\"Games has {} rows\".format(len(games_df)))","10a1f604":"games_df.isnull().sum()","a0cffb1f":"df_bin = pd.DataFrame() # for discretised continuous variables\ndf_con = pd.DataFrame() # for continuous variables\nprint(\"Variables have been set\")","1ca55cb8":"# Data types in the dataframe\ngames_df.dtypes","a06441c1":"games_df.head()","7c94dd65":"print(\"There are {} unique variables in victory_status\".format(len(games_df.victory_status.unique())))","deb7ceae":"#Adding to subset\ndf_bin['victory_status'] = games_df['victory_status']\ndf_con['victory_status'] = games_df['victory_status']\n\ndf_bin['opening_eco'] = games_df['opening_eco']\ndf_con['opening_eco'] = games_df['opening_eco']\n\ndf_bin['opening_name'] = games_df['opening_name']\ndf_con['opening_name'] = games_df['opening_name']\nprint(\"Added into subset\")","e29a2bc1":"# Adding to subset\ndf_bin['winner'] = games_df['winner']\ndf_con['winner'] = games_df['winner']\nprint(\"Added into subset\")","629cfa6b":"# Bar chart for game results\n\nplt.figure(figsize=(10,6))\n\nsns.countplot(x = 'victory_status', hue = 'winner', data = df_con)\nplt.legend()","74be770e":"df_con['white_rating'] = pd.cut(games_df['white_rating'], 8)\ndf_bin['white_rating'] = pd.cut(games_df['white_rating'], 8)\nprint(\"Added to subset\")","72d7b482":"df_con['black_rating'] = pd.cut(games_df['black_rating'], 8)\ndf_bin['black_rating'] = pd.cut(games_df['black_rating'], 8)\n\nprint(\"Added to subset\")","2e3ad5dd":"df_bin.head()","05552b95":"plt.figure(figsize=(20,5))\n\nsns.countplot(x = 'white_rating', hue = 'winner', data = df_con)\nplt.legend()\nplt.title(\"Games result vs White rating\")","fc42dbff":"plt.figure(figsize=(20,5))\nsns.countplot(x = 'black_rating', hue = 'winner', data = df_con)\nplt.legend()\nplt.title(\"Games result vs Black rating\")","ccc99485":"# Plotting jointplot comparing white rating with number of turns.\nsns.jointplot(x = games_df['turns'], y = games_df['white_rating'], shade = True, kind = 'kde')\n","127c091f":"# Plotting jointplot with black rating against the number of turns.\nsns.jointplot(x = games_df['turns'], y = games_df['black_rating'], shade = True, kind = 'kde')\n","c4517571":"# Converting CSV using pandas.DataFram.to_sql\nengine = create_engine('sqlite:\/\/',  echo = False) \ngames_df.to_sql('games_sql', con = engine) ","ababaedb":"sql_query = '''SELECT name FROM sqlite_master WHERE type='table';'''\nprint(engine.execute(sql_query).fetchall())","787d12bd":"# Creating a column for average rating and ensuring that games evaluated are close in rating (within 200)\nsql_query = (\"\"\"\n            SELECT *, (white_rating + black_rating)\/2 AS average_rating, \n                ABS(black_rating - white_rating) AS rating_diff\n            from games_sql\n            WHERE rating_diff < 201\n            \"\"\")\nadj_rating = pd.read_sql_query(sql_query, con = engine)\n\nadj_rating.to_sql('adj_rating_', con = engine)\n","0f809385":"sql_query = (\"\"\"                \n            SELECT DISTINCT opening_name, opening_ply, \n                white_rating, black_rating, COUNT(opening_name)\n                AS opening_freq\n            FROM adj_rating_\n            WHERE average_rating < 1099 AND opening_ply >= 2\n            GROUP BY opening_name\n            ORDER BY COUNT(opening_name) DESC\n            LIMIT 10; \n           \"\"\")\nbeginner = pd.read_sql_query(sql_query, con = engine)\n\nsql_query=(\"\"\"\n            SELECT DISTINCT opening_name, opening_ply, \n                white_rating, black_rating, COUNT(opening_name)\n                AS opening_freq\n            FROM adj_rating_\n            WHERE (average_rating BETWEEN 1100 AND 1599)\n                AND opening_ply >= 2\n            GROUP BY opening_name\n            ORDER BY COUNT(opening_name) DESC\n            LIMIT 10; \n           \"\"\")\nintermediate = pd.read_sql_query(sql_query, con = engine)\n\nsql_query=(\"\"\"\n            SELECT DISTINCT opening_name, opening_ply, \n                white_rating, black_rating, COUNT(opening_name)\n                AS opening_freq\n            FROM adj_rating_\n            WHERE average_rating BETWEEN 1600 AND 2099\n                AND opening_ply >= 2\n            GROUP BY opening_name\n            ORDER BY COUNT(opening_name) DESC\n            LIMIT 10; \n           \"\"\")\nadvanced = pd.read_sql_query(sql_query, con = engine) \n\nsql_query=(\"\"\"\n            SELECT DISTINCT opening_name, opening_ply, \n                white_rating, black_rating, COUNT(opening_name)\n                AS opening_freq\n            FROM adj_rating_\n            WHERE average_rating >= 2100\n                AND opening_ply >= 2\n            GROUP BY opening_name\n            ORDER BY COUNT(opening_name) DESC\n            LIMIT 10; \n           \"\"\")\nmaster = pd.read_sql_query(sql_query, con = engine)         ","e074708a":"# Black winner\nsql_query = (\"\"\"                \n            SELECT opening_name, opening_ply, winner, \n                white_rating, black_rating, COUNT(winner)\n                AS winner_freq\n            FROM adj_rating_\n            WHERE average_rating < 1099 AND opening_ply >= 2\n                AND winner LIKE '%black%'\n            GROUP BY opening_name\n            ORDER BY COUNT(winner) DESC\n            LIMIT 10; \n           \"\"\")\nbeginner_b = pd.read_sql_query(sql_query, con = engine)\n\nsql_query=(\"\"\"\n            SELECT opening_name, opening_ply, winner, \n                white_rating, black_rating, COUNT(winner)\n                AS winner_freq\n            FROM adj_rating_\n            WHERE (black_rating BETWEEN 1100 AND 1599)\n                AND opening_ply >= 2 AND winner LIKE '%black%'\n            GROUP BY opening_name\n            ORDER BY COUNT(opening_name) DESC\n            LIMIT 10; \n           \"\"\")\nintermediate_b = pd.read_sql_query(sql_query, con = engine)\n\nsql_query=(\"\"\"\n            SELECT opening_name, opening_ply, winner, \n                white_rating, black_rating, COUNT(winner)\n                AS winner_freq\n            FROM adj_rating_\n            WHERE black_rating BETWEEN 1600 AND 2099\n                AND opening_ply >= 2 AND winner LIKE '%black%'\n            GROUP BY opening_name\n            ORDER BY COUNT(opening_name) DESC\n            LIMIT 10; \n           \"\"\")\nadvanced_b = pd.read_sql_query(sql_query, con = engine) \n\nsql_query=(\"\"\"\n            SELECT opening_name, opening_ply, winner, \n                white_rating, black_rating, COUNT(winner)\n                AS winner_freq\n            FROM adj_rating_\n            WHERE black_rating >= 2100\n                AND opening_ply >= 2 AND winner LIKE '%black%'\n            GROUP BY opening_name\n            ORDER BY COUNT(opening_name) DESC\n            LIMIT 10; \n           \"\"\")\nmaster_b = pd.read_sql_query(sql_query, con = engine) \n\n#----------------------------------------------------\n# White winner\nsql_query = (\"\"\"                \n            SELECT opening_name, opening_ply, winner, \n                white_rating, black_rating, COUNT(winner)\n                AS winner_freq\n            FROM adj_rating_\n            WHERE average_rating < 1099 AND opening_ply >= 3\n                AND winner LIKE '%white%'\n            GROUP BY opening_name\n            ORDER BY COUNT(winner) DESC\n            LIMIT 10; \n           \"\"\")\nbeginner_w = pd.read_sql_query(sql_query, con = engine)\n\nsql_query=(\"\"\"\n            SELECT opening_name, opening_ply, winner, \n                white_rating, black_rating, COUNT(winner)\n                AS winner_freq\n            FROM adj_rating_\n            WHERE (black_rating BETWEEN 1100 AND 1599)\n                AND opening_ply >= 2 AND winner LIKE '%white%'\n            GROUP BY opening_name\n            ORDER BY COUNT(opening_name) DESC\n            LIMIT 10; \n           \"\"\")\nintermediate_w = pd.read_sql_query(sql_query, con = engine)\n\nsql_query=(\"\"\"\n            SELECT opening_name, opening_ply, winner, \n                white_rating, black_rating, COUNT(winner)\n                AS winner_freq\n            FROM adj_rating_\n            WHERE black_rating BETWEEN 1600 AND 2099\n                AND opening_ply >= 2 AND winner LIKE '%white%'\n            GROUP BY opening_name\n            ORDER BY COUNT(opening_name) DESC\n            LIMIT 10; \n           \"\"\")\nadvanced_w = pd.read_sql_query(sql_query, con = engine) \n\nsql_query=(\"\"\"\n            SELECT opening_name, opening_ply, winner, \n                white_rating, black_rating, COUNT(winner)\n                AS winner_freq\n            FROM adj_rating_\n            WHERE black_rating >= 2100\n                AND opening_ply >= 2 AND winner LIKE '%white%'\n            GROUP BY opening_name\n            ORDER BY COUNT(opening_name) DESC\n            LIMIT 10; \n           \"\"\")\nmaster_w = pd.read_sql_query(sql_query, con = engine) ","e97694cc":"intermediate_b.head()","2ac1c87c":"# Testing desired barplot\nsns.barplot(x = 'winner_freq', y = 'opening_name', data = beginner_b)","a8b7792f":"# Creating function to get the name of the dataframe\ndef get_df_name(data):\n    name =[x for x in globals() if globals()[x] is data][0]\n    return name","80009f29":"#Creating auto bar plot function\ndef auto_plot(data_1,data_2, data_3, figsize = (20, 20)):\n    \"\"\"\n    Function to plot a bar plot showing the top 10 most popular openings for \n    each rating tier.\n    ::param_data = target dataframe\n    ::param_figsize:: = size of figure (width, height)\n    \"\"\"\n    fig = plt.figure(figsize=figsize)\n    plt.subplot(3,1,1)\n    sns.barplot(x = 'opening_freq', y  ='opening_name', data = data_1)\n    plt.xlabel('Opening Frequency')\n    plt.ylabel('Opening Name')\n    plt.title('Frequency of openings for {} tier'.format(get_df_name(data_1)));\n    plt.subplot(3,1,2)\n    sns.barplot(x = 'winner_freq', y = 'opening_name', data = data_2)\n    plt.xlabel('Black Win Frequency')\n    plt.ylabel('Opening Name')\n    plt.title('Frequency of black winner openings for {} tier'.format(get_df_name(data_2)));\n    plt.subplot(3,1,3)\n    sns.barplot(x = 'winner_freq', y = 'opening_name', data = data_3)\n    plt.xlabel('White Win Frequency')\n    plt.ylabel('Opening Name')\n    plt.title('Frequency of white openings for {} tier'.format(get_df_name(data_3)));","2db99fac":"# Creating a search function\ndef rating_tool(rating):\n    \"\"\"\n    This function will return the barplot for the top 10 most\n    popular openings in their rating tier\n    ::param_rating = User chess rating\n    \"\"\"\n    # Beginner\n    if rating < 1100:\n        print(\"You have entered {} making you a Beiginner (<1100), is this correct? (Enter Y or N)\".format(rating))\n        answer_b=input()\n        print(answer_b)\n        if answer_b.casefold() in ['Y', 'y', 'yes', 'Yes']:\n            auto_plot(beginner, beginner_b, beginner_w)\n        else:\n            print(\"Please re-enter your correct rating in the function\")\n\n    # Intermediate\n    elif 1100 <= rating < 1600:\n        print(\"\"\"You have entered {} making you a Intermediate (Between 1100 and 1599), is this correct? (Enter Y or N)\"\"\".format(rating))\n        answer_i=input()\n        if answer_i.casefold() in ['Y', 'y', 'yes', 'Yes']:\n            auto_plot(intermediate, intermediate_b, intermediate_w)\n        else:\n            print(\"Please re-enter your correct rating in the function\")\n            \n\n    # Advanced\n    elif 1600 <= rating < 2100:\n        print(\"\"\"You have entered {} making you a Advanced (Between 1600 and 2099), is this correct? (Enter Y or N)\"\"\".format(rating))\n        answer_a=input()\n        if answer_a.casefold() in ['Y', 'y', 'yes', 'Yes']:\n            auto_plot(advanced, advanced_b, advanced_w)\n        else:\n            print(\"Please re-enter your correct rating in the function\")\n\n    # Master\n    elif rating >= 2100:\n        print(\"\"\"You have entered {} making you a Master (>2100), is this correct? (Enter Y or N)\"\"\".format(rating))\n        answer_b=input()\n        if answer_b.casefold() in ['Y', 'y', 'yes', 'Yes']:\n            auto_plot(master, master_b, advanced_w)\n        else:\n            print(\"Please re-enter your correct rating in the function\")\n\n    else:\n        print(\"That's not a number my friend! Try again...\")\n        print(\"\"\"Enter 'rating_tool(chess rating)' your chess rating must be an integer \"\"\")\n        \n    \n   ","afc4f373":"# Enter \"rating_tool(chess rating goes here)\"\nrating_tool(2100)","aa124028":"# Popular Opening Search Tool\n\nThis tool will show the top 10 most popular openings based on the rating you specify.\n\n*Please note that this black rating and wins have been used as a standard for this function*","f68d90c5":"## Data Description\n\n* Game ID\n* Rated (T\/F): Is the game rated?\n* Start Time\n* End Time\n* Number of Turns\n* Game Status: How did the game end?\n* Winner: What side won?\n* Time Increment\n* White Player ID\n* White Player Rating\n* Black Player ID\n* Black Player Rating\n* All Moves in Standard Chess Notation\n* Opening Eco: Standardised Code for any given opening\n* Opening Name\n* Opening Ply: Number of moves in the opening phase","56466d62":"### Correlation Matrix","21f62674":"# Early Exploratory Analysis","3871fdaa":"Joint distribution plot shows that the average game lasts about 50 moves with lower rated with the lower number of turns favoring the lower rated games (<= 1000) and the highest number of turns for games with an average player rating 1500 to 1800. \n\nPlot also shows that the average rating in the database ~ 1500 with suprisingly fewer player ranked < 1000 than there are those ranked > 2000.","d7f1fb3e":"# Using Chess Data to develop search functions\n\nInspired by Hikaru's and Gotham Chess' video on opening tiel list, I want to create my own search function with the data avalible from Linchess. \n* Intially I will provide a projection across ranges of rating to determine the best and most popular openings. \n* The search function will allow a user to input their rating and thus find the best and most popular opening at around their rating. \n* Another search function will allow a user to reverse search an opening anfind the win percentages for black and white across all rating or a rating they enter.\n\n*Note: I will be using **black rating** as the standard for rating for sake of simplicity*\n\n## Other intersting graphs\n\n* How many turns does the average player make based on rating and opening used? (DONE)","7256e343":"### Feature: victory_status\n\nThis feature will be one hot encoded later on for simpler coding.","ad7ae417":"### Column Distribution","ed3386ac":"\n### Feature: Rating (Black and White)","c2e8602f":"### Scatter and Density Plots","8329ece5":"## Preparing two dataframes for analysis\n\n* Discretised continuous variables (continuous varibles that have been sorted into catergories)\n* Continuous variables","c6adc8c9":"### Uploading CSV file onto SQL","e47ce6c2":"Feel free to play around with the function below to manually explore opening trends in the database :)","37bf237d":"### SQL code for most winningest openings","f02dc06a":"### SQL code for most popular openings","f1997d60":"Graphs show that players are more likely to lose to the other side when they are lower rated. Their win percentage increases with a higher rating. This observation assumes that players are playing others around their rating and does not account for outlier such as a novice challenging an IM. As matchmaking AI accounts for this in ranked games, I will drop unranked games as they will likely be outliers.","ac28ffff":"## Search Function\n\nOnce the above two steps are done, import the SQL tables onto python, plot graphs for most popular openings where opening_ply >= 3.","a72257c3":"## Missing Values","3cc10dfa":"## How long do games last across player ratings?"}}