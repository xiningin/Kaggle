{"cell_type":{"aa77a1ee":"code","ed5e4762":"code","02d2cd0e":"code","ba8be5aa":"code","f81a4442":"code","7c4bc760":"code","f7f2e64a":"code","495b7838":"code","13c6b5ec":"code","a01484e8":"code","d73f92c5":"code","e9ce395b":"code","e7e3add9":"code","4783e389":"code","2aa4868b":"code","68583ee3":"code","00cee39a":"code","de371bcf":"code","0f638521":"code","78fa3b40":"code","b0d0b99b":"code","32ab75c3":"code","b1108869":"code","ceddf6e7":"code","86e1fbd5":"code","bc671c57":"code","f73f880b":"code","277025fb":"code","9904b8fa":"code","35668696":"code","d8bd88a7":"code","d9841b92":"code","9b0afe00":"code","f248210e":"code","8b41eb06":"code","436ef0e4":"code","5d561b8d":"code","1115ccf5":"code","a2e01beb":"code","4155d4ef":"code","dfa916c4":"code","cc4b5ac5":"code","59b1cae2":"code","d4f907cf":"code","07272d9c":"code","d558ad70":"code","20957ed4":"code","61be675e":"code","5e93b330":"code","a4717f59":"code","a4ddad1d":"code","ac2fa1cd":"code","80417756":"code","53de034d":"code","831c2848":"code","59ded4be":"code","c9a24e06":"code","a0ade8dc":"code","c243b9be":"code","c1259d3e":"code","533126f7":"code","639fa71e":"code","3f333596":"code","98e86dc1":"code","e1bf98e2":"code","3d874b2b":"code","4b6a4d43":"code","002178ec":"code","65563b66":"markdown","d3d54487":"markdown","df5db157":"markdown","6235204f":"markdown","7ba5cb6e":"markdown","48961064":"markdown","cf41ea44":"markdown","d4ea4f66":"markdown","d0d5816e":"markdown","5b68e7e0":"markdown","ab7069c8":"markdown","1ec1a035":"markdown","0233832d":"markdown","b4d5ff9e":"markdown","4cb8ddfd":"markdown","ce295965":"markdown","4742372c":"markdown","76d0a415":"markdown","4ea7dc9e":"markdown","c01a4123":"markdown","b7bd705c":"markdown","8d039329":"markdown","22b88364":"markdown","71767920":"markdown","71992638":"markdown"},"source":{"aa77a1ee":"import pandas as pd\nimport math, re, os\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.utils import shuffle\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import activations\nfrom tensorflow.keras import layers,callbacks\nfrom tensorflow.keras.layers.experimental import preprocessing\nimport cv2\nfrom tensorflow.keras.layers.experimental import preprocessing\nimport copy # copy the matrix\nfrom matplotlib import pyplot, transforms\nprint(\"Tensorflow version \" + tf.__version__)","ed5e4762":"data = '..\/input\/breast-histopathology-images'\nfolder = '..\/input\/breast-histopathology-images\/'","02d2cd0e":"def Turn_into_list_dir(dir_data,dir_folder):\n    negative_class = []\n    positive_class = []\n    patient_id = []\n    patient_state = []\n    patient_path =[]\n    remove_id = ['IDC_regular_ps50_idx5'] # Remove id\n    a  = list(os.listdir(dir_data))\n    for i in remove_id:\n        a.remove(i)\n    for i in range(0,len(a)):\n        id_patient = a[i]\n        data_number = dir_folder + a[i]\n        negative = list(os.listdir(data_number+'\/0\/'))\n        positive =  list(os.listdir(data_number+'\/1\/'))\n        for i in range(0,len(negative)):\n            negative_class.append(data_number+'\/0\/'+negative[i])\n            patient_id.append(int(id_patient)) # append int for easy using\n            patient_state.append(0)\n            patient_path.append(data_number+'\/0\/'+negative[i])\n        for i in range(0,len(positive)):\n            positive_class.append(data_number+'\/1\/'+positive[i])\n            patient_id.append(int(id_patient)) # append int for easy using  \n            patient_state.append(1)\n            patient_path.append(data_number+'\/1\/'+positive[i])\n    data = {'Patient_id': patient_id, 'Patient_path': patient_path, 'Patient_state:':patient_state} \n    df = pd.DataFrame(data)  \n    return negative_class,positive_class, df","ba8be5aa":"negative_class,positive_class,data_frame = Turn_into_list_dir(data,folder)","f81a4442":"data_frame.info(),data_frame.head()","7c4bc760":"def Draw_the_image(dataframe,patient_id,start_index): # Choose the data frame and start index of the the image\n    end_index = start_index +20\n    normal_path = data_frame[(data_frame['Patient_id']==patient_id) & (data_frame['Patient_state:']==0)]['Patient_path'][start_index:end_index]\n    abnormal_path = data_frame[(data_frame['Patient_id']==patient_id) & (data_frame['Patient_state:']==1)]['Patient_path'][start_index:end_index]\n    normal_path = list(normal_path)\n    abnormal_path = list(abnormal_path)\n    \n    plt.figure(figsize=(22,15))\n    for i in range(0,20):\n        ax = plt.subplot(4,5, i + 1)\n        img = cv2.imread(normal_path[i])\n        plt.imshow(img)\n        plt.title(f'Id:{patient_id}, Idex {i}, Normal', fontsize = 14);\n        \n    \n    plt.figure(figsize=(22,15))\n    for i in range(0,20):\n        ax = plt.subplot(4,5, i + 1)\n        img = cv2.imread(abnormal_path[i])\n        plt.imshow(img)\n        plt.title(f'Id:{patient_id}, Idex {i}, Abnormal', fontsize = 14, c ='red' );\n        ","f7f2e64a":"Draw_the_image(data_frame,10295,50)","495b7838":"Draw_the_image(data_frame,10299,100)","13c6b5ec":"normal_image = len(data_frame[data_frame['Patient_state:']==0])\nabnormal_image = len(data_frame[data_frame['Patient_state:']==1])\nvalue = {'Normal_image': normal_image, 'Abnormal': abnormal_image}\n\nfig, ax = plt.subplots()\nax.bar (value.keys(), value.values(), color = ['pink','cyan']);\nax.set(title = 'Normal image and Abnormal image', xlabel='Name', ylabel = 'Number of image');","a01484e8":"patient_id  = list(os.listdir(data))\npatient_id.remove('IDC_regular_ps50_idx5')\npatient_int_id =[ int(i) for i in range(0,len(patient_id))] # turn all the element in list for plotting \nnumber_of_image_each_id = []\nfor i in patient_id:\n    number_img = len(data_frame[data_frame['Patient_id']== int(i) ])\n    number_of_image_each_id.append(number_img)\n    \nlen(number_of_image_each_id),len(patient_int_id )","d73f92c5":"color = number_of_image_each_id # Choose the color for each number","e9ce395b":"fig, ax = plt.subplots(figsize=(8,5))\nimg = ax.scatter(np.array(patient_int_id) ,np.array(number_of_image_each_id) ,c = color, cmap = 'viridis',s = 55, alpha = 0.8 );\nax.set(title = 'Number of image for each id', ylabel='Number of image',xlabel = 'Index of id');\nfig.colorbar(img);","e7e3add9":"patient_id  = list(os.listdir(data))\npatient_id.remove('IDC_regular_ps50_idx5')\npatient_int_id =[ int(i) for i in range(0,len(patient_id))] # turn all the element in list for plotting \npercent_Abnormal_in_each_id = []\nfor i in patient_id:\n    percent_of_abnormal_image = len(data_frame[(data_frame['Patient_id']== int(i)) & (data_frame['Patient_state:']== 1)])\/len(data_frame[data_frame['Patient_id']== int(i)])\n    percent_Abnormal_in_each_id.append(percent_of_abnormal_image)\n    \nlen(percent_Abnormal_in_each_id),len(patient_int_id )","4783e389":"color = percent_Abnormal_in_each_id # Choose the color for each number\n\nfig, ax = plt.subplots(figsize=(8,5))\na = ax.scatter(np.array(patient_int_id) ,np.array(percent_Abnormal_in_each_id) ,c = color, cmap = 'tab20',s = 70, alpha = 1);\nax.set( ylabel='Percentage of Abnormal image',xlabel = 'Index of id');\nfig.colorbar(a);","2aa4868b":"plt.style.use('seaborn')","68583ee3":"data_path = '..\/input\/breast-histopathology-images'\nList_percent = percent_Abnormal_in_each_id # take the percentage list above","00cee39a":"def Percentage_positve(ID,data,list_percent): # take the percentage of abnormal image in each ID \n    patient_id  = list(os.listdir(data))\n    patient_id.remove('IDC_regular_ps50_idx5')\n    index_id = patient_id.index(str(ID))\n    return list_percent[index_id]\n\ndef draw_the_plotter(patient_id,data_frame,data): # Draw the image:\n    X_value_positive = []\n    y_value_positive = []\n    X_value_negative = []\n    y_value_negative = []\n    path_positive = data_frame[(data_frame['Patient_id']==patient_id) & (data_frame['Patient_state:']==1)]['Patient_path'].values\n    path_negative = data_frame[(data_frame['Patient_id']==patient_id) & (data_frame['Patient_state:']==0)]['Patient_path'].values\n    \n    for i in path_positive:\n        value = i.replace('..\/input\/breast-histopathology-images\/','')\n        value = value.replace('_idx5','')\n        value = value.replace('_class1.png','')\n        index_x = value.find('x')\n        index_y = value.find('y')\n        x = value[index_x+1:index_x+5]\n        y = value[index_y+1:index_y+5]\n        if '_' in x or y:\n            x = x.replace('_','')\n            X_value_positive.append(int(x.replace('y','')))\n            y_value_positive.append(int(y))\n        else:\n            X_value_positive.append(int(x))\n            y_value_positive.append(int(y))\n    for i in path_negative:\n        value = i.replace('..\/input\/breast-histopathology-images\/','')\n        value = value.replace('_idx5','')\n        value = value.replace('_class0.png','')\n        index_x = value.find('x')\n        index_y = value.find('y')\n        x = value[index_x+1:index_x+5]\n        y = value[index_y+1:index_y+5]\n        if '_' in x or y:\n            x = x.replace('_','')\n            X_value_negative.append(int(x.replace('y','')))  \n            y_value_negative.append(int(y))\n        else:\n            X_value_negative.append(int(x))\n            y_value_negative.append(int(y))\n    plt.scatter(X_value_positive, y_value_positive,c ='lightcoral')\n    plt.scatter(X_value_negative, y_value_negative,c ='navy')\n    value = (np.round(Percentage_positve(patient_id,data,List_percent),2)) *100\n    if value < 50:\n        plt.title(f'Paient Id: {patient_id} \\n Percent Positive: {value}%')\n    else:  \n        plt.title(f'Paient Id: {patient_id} \\n Percent Positive: {value}%', c = 'red')\n    return X_value_positive,y_value_positive","de371bcf":"# If in the whole patient id, the percentage of Abnormal image more than 50 % the color will be red\nList_id = [10253,13616,9344,16014,13402,15903,14188,15632]\nplt.figure(figsize=(25,12))\nfor i in range(0,8):\n    ax = plt.subplot(2,4, i + 1)\n    img = draw_the_plotter(List_id[i],data_frame,data_path)\n\n","0f638521":"def Take_the_coordinate(patient_id,data_frame): # Take the coordinate to draw the image\n    X_value_positive = []\n    y_value_positive = []\n    X_value_negative = []\n    y_value_negative = []\n    path_positive_value = []\n    path_negative_value = []\n    \n    path_positive = data_frame[(data_frame['Patient_id']==patient_id) & (data_frame['Patient_state:']==1)]['Patient_path'].values\n    path_negative = data_frame[(data_frame['Patient_id']==patient_id) & (data_frame['Patient_state:']==0)]['Patient_path'].values\n    \n    for i in path_positive:\n        path_positive_value.append(i)\n        value = i.replace('..\/input\/breast-histopathology-images\/','')\n        value = value.replace('_idx5','')\n        value = value.replace('_class1.png','')\n        index_x = value.find('x')\n        index_y = value.find('y')\n        x = value[index_x+1:index_x+5]\n        y = value[index_y+1:index_y+5]\n        if '_' in x or y:\n            x = x.replace('_','')\n            X_value_positive.append(int(x.replace('y','')))\n            y_value_positive.append(int(y))\n        else:\n            X_value_positive.append(int(x))\n            y_value_positive.append(int(y))\n            \n    for i in path_negative:\n        path_negative_value.append(i)\n        value = i.replace('..\/input\/breast-histopathology-images\/','')\n        value = value.replace('_idx5','')\n        value = value.replace('_class0.png','')\n        index_x = value.find('x')\n        index_y = value.find('y')\n        x = value[index_x+1:index_x+5]\n        y = value[index_y+1:index_y+5]\n        if '_' in x or y:\n            x = x.replace('_','')\n            X_value_negative.append(int(x.replace('y','')))  \n            y_value_negative.append(int(y))\n        else:\n            X_value_negative.append(int(x))\n            y_value_negative.append(int(y))\n    dic_positive = {'X_positive':X_value_positive,'y_positive':y_value_positive,'Path_positive_value' : path_positive_value }\n    dic_negative = {'X_negative':X_value_negative, 'y_negative':y_value_negative,'Path_negative_value': path_negative_value }\n    return pd.DataFrame(dic_positive), pd.DataFrame(dic_negative)\n\ndef Turn_the_image_into_np(path): # Change the shape of the image for the matrix\n    img = cv2.imread(path)\n    return np.transpose(img,(2,0,1))\n\ndef Create_the_mask(positive_path): # Create the mask for Positive image\n    img = cv2.imread(positive_path)\n    b, g, r = cv2.split(img)\n    b= b -100   # decrease the blue value and change the order of of channel \n    red_img= cv2.merge([r,b,g])\n    return np.transpose(red_img,(2,0,1))","78fa3b40":"def Turn_the_image_into_np(path): # Change the shape of the image for the matrix\n    img = cv2.imread(path)\n    return np.transpose(img,(2,0,1))\n\ndef Create_the_mask(positive_path): # Create the mask for Positive image\n    img = cv2.imread(positive_path)\n    b, g, r = cv2.split(img)\n    b= b -100   # decrease the blue value and change the order of of channel \n    red_img= cv2.merge([r,b,g])\n    return np.transpose(red_img,(2,0,1))","b0d0b99b":"def Draw_the_image(ID,data_frame):\n    Positive_df,Negative_df = Take_the_coordinate(ID,data_frame) # Use the function to take the coordinate\n    count_wrong_image_shape = 0\n    \n    #Find out largest coordinate to of the image:\n    X_max = np.max([np.max(Positive_df.X_positive),np.max(Negative_df.X_negative)])\n    y_max = np.max([np.max(Positive_df.y_positive),np.max(Negative_df.y_negative)])\n    \n    # Take the path of the positive and negative image\n    Path_pos = Positive_df.Path_positive_value.values\n    Path_neg = Negative_df.Path_negative_value.values\n    \n    # Draw the image\n    w, h = X_max,y_max\n\n    data = np.ones((3, h+50, w+50),dtype=np.uint8)\n    data = data *245 # fill out all the matrix with gray color_ if not the image will have black background\n    '''\n    Create the image without mask \n    '''\n    value_x = Negative_df.X_negative.values # Take X_coordinate\n    value_y = Negative_df.y_negative.values # Take y_coordinate\n\n    # Since each image is (50,50,3) so we need to plus 50\n    # Each coordinate is separate 50 pixel so we do not need to scale \n    for i in range(0,Negative_df.shape[0]):\n        if Turn_the_image_into_np(Path_neg[i]).shape == (3,50,50): # Check there are any wrong image shape\n            data[:,value_y[i]:value_y[i]+ 50,value_x[i]:value_x[i]+50] = (data[:,value_y[i]:value_y[i]+ 50,value_x[i]:value_x[i]+50] -244) * (Turn_the_image_into_np(Path_neg[i]))\n        else:\n            count_wrong_image_shape = count_wrong_image_shape+1\n    value_x = Positive_df.X_positive.values\n    value_y = Positive_df.y_positive.values\n\n    for x in range(0,Positive_df.shape[0]):\n        if Turn_the_image_into_np(Path_pos[x]).shape != (3,50,50): # Check there are any wrong image shape\n            count_wrong_image_shape = count_wrong_image_shape+1\n        else:\n            data[:,value_y[x]:value_y[x]+ 50,value_x[x]:value_x[x]+50] = (data[:,value_y[x]:value_y[x]+ 50,value_x[x]:value_x[x]+50]-244)  *  (Turn_the_image_into_np(Path_pos[x]))\n    \n    '''\n    Create the image with mask:\n    '''\n    data_2 = copy.deepcopy(data)\n    value_x = Positive_df.X_positive.values\n    value_y = Positive_df.y_positive.values\n    for x in range(0,Positive_df.shape[0]):\n        if Create_the_mask(Path_pos[x]).shape != (3,50,50):\n            count_wrong_image_shape = count_wrong_image_shape+1\n        else:\n            data_2[:,value_y[x]:value_y[x]+ 50,value_x[x]:value_x[x]+50] =  Create_the_mask(Path_pos[x])\n    print(f'There are {count_wrong_image_shape} wrong image(s) size in Id: {ID}')\n    return np.transpose(data,(1,2,0)), np.transpose(data_2,(1,2,0))","32ab75c3":"def Plot_the_image(ID):\n    data_1,data_2 = Draw_the_image(ID, data_frame)\n    plt.style.use('seaborn-white')\n    #data_3 = draw_the_plotter(16014,data_frame)\n    data = [data_1,data_2]\n    plt.figure(figsize=(15,17))\n    for i in range(0,2):\n        ax = plt.subplot(1,2,i+1)\n        plt.gca().invert_yaxis()\n        plt.gca().invert_xaxis()\n        plt.imshow(data[i])\n        if i == 0:\n            plt.title(f'Patient ID { ID} without mask' )\n        else :\n            plt.title(f'Patient ID { ID} with mask',c = 'red')","b1108869":"Plot_the_image(9381)","ceddf6e7":"Plot_the_image(15632)","86e1fbd5":"Plot_the_image(12826)","bc671c57":"# Draw the histogram for each image\ndef Draw_histogram(state,id_path):\n    img = cv2.imread(id_path)\n    color = ('b','g','r')\n    Value = []\n    for i,col in enumerate(color):\n        histr = cv2.calcHist([img],[i],None,[256],[0,256])\n        Value.append(histr)\n        plt.plot(histr,color = col)\n        plt.title(f'Class: {state}')\n        plt.xlim([0,256])\n    Value = np.array(Value)\n    data ={'Blue' : Value[0,:,0],'Green': Value[1,:,0],'Red': Value[2,:,0]}\n    value = pd.DataFrame(data)\n    print(f'Max Blue:  { np.where(value.Blue == np.max(value.Blue))[0][0],np.max(value.Blue)}\\nMax Green: { np.where(value.Green == np.max(value.Green))[0][0],np.max(value.Green)}\\nMax Red:  { np.where(value.Red == np.max(value.Red))[0][0],np.max(value.Red)} ')\n    plt.show()\n    plt.imshow(img)\n  \n\n    return value","f73f880b":"a = Draw_histogram(1,'..\/input\/breast-histopathology-images\/10269\/1\/10269_idx5_x1301_y1501_class1.png')","277025fb":"a = Draw_histogram(1,'..\/input\/breast-histopathology-images\/10269\/1\/10269_idx5_x1401_y701_class1.png')","9904b8fa":"a = Draw_histogram(1,'..\/input\/breast-histopathology-images\/12822\/1\/12822_idx5_x1001_y201_class1.png')","35668696":"a = Draw_histogram(0,'..\/input\/breast-histopathology-images\/10276\/1\/10276_idx5_x1001_y1101_class1.png')","d8bd88a7":"data_frame.drop(data_frame[data_frame['Patient_id'] == 12750].index, inplace = True)\ndata_frame.drop(data_frame[data_frame['Patient_id'] == 16165].index, inplace = True)\ndata_frame.drop(data_frame[data_frame['Patient_id'] == 9381].index, inplace = True)","d9841b92":"data_frame.shape","9b0afe00":"def Take_frequency(Patient_state,data_frame):\n    Image_path = data_frame[data_frame['Patient_state:'] == Patient_state]['Patient_path'].values\n    color = ('b','g','r')\n    Blue_df = []\n    Green_df = []\n    Red_df = []\n    for x in Image_path:\n        Value = []\n        img = cv2.imread(x)\n        for i,col in enumerate(color):\n            histr = cv2.calcHist([img],[i],None,[256],[0,256])\n            Value.append(histr)\n        Value = np.array(Value)\n        data ={'Blue' : Value[0,:,0],'Green': Value[1,:,0],'Red': Value[2,:,0]}\n        value = pd.DataFrame(data)\n        Blue_df.append([np.where(value.Blue == np.max(value.Blue))[0][0],np.max(value.Blue)])\n        Green_df.append([np.where(value.Green == np.max(value.Green))[0][0],np.max(value.Green)])\n        Red_df.append([np.where(value.Red == np.max(value.Red))[0][0],np.max(value.Red)])\n    return np.array(Blue_df),np.array(Green_df),np.array(Red_df)","f248210e":"a,b,c = Take_frequency(1,data_frame)\n\n# Plot the scatter:\n\nfig, ax = plt.subplots(nrows=1, ncols= 3, figsize = (15,5))\n\n\nax[0].scatter(a[:,0], a[:,1],c ='b');\nax[0].set(title = 'Histogram of Blue Channel', ylabel='Frequency', xlabel = 'Pixel Value');\nax[1].scatter(b[:,0], b[:,1],c ='g');\nax[1].set(title = 'Histogram of Green Channel', ylabel='Frequency', xlabel = 'Pixel Value');\nax[2].scatter(c[:,0], c[:,1],c ='r');\nax[2].set(title = 'Histogram of Red Channel', ylabel='Frequency', xlabel = 'Pixel Value');\n","8b41eb06":"Image_path = data_frame[data_frame['Patient_state:'] == 1]['Patient_path'].values\nvalue = {'Fre_Peak_Blue': a[:,1],'Fre_Peak_Green': b[:,1],'Fre_Peak_Red': c[:,1],'Path':Image_path,'Class':np.ones(Image_path.shape, dtype = int)}\ndf = pd.DataFrame(value)\ndf.shape","436ef0e4":"np.random.seed(42) # use the same seed for every time trainning\nClass_1 = df[(df.Fre_Peak_Green <125)&(df.Fre_Peak_Red <125)&(df.Fre_Peak_Blue <125)]\nClass_1 = Class_1.sample(frac=1)\nClass_1 = Class_1[0:37000]","5d561b8d":"Class_1_data = []\nfor i in Class_1.Path.values:\n    image = cv2.imread(i)\n    if image.shape == (50,50,3):\n        image = cv2.resize(image,(71,71))\n        Class_1_data.append(image)\nClass_1_data = np.array(Class_1_data)\nClass_1_data.shape","1115ccf5":"# Shuffle class 0\nnp.random.seed(42)\ndf_class_0 = data_frame[data_frame['Patient_state:']==0]\ndf_class_0 = df_class_0.sample(frac=1)","a2e01beb":"Class_0_data = []\nfor i in df_class_0.Patient_path.values[0:40500]:\n    image = cv2.imread(i)\n    if image.shape == (50,50,3):\n        image = cv2.resize(image,(71,71))\n        Class_0_data.append(image)\nClass_0_data = np.array(Class_0_data)\nClass_0_data.shape","4155d4ef":"X_0 = Class_0_data[0:40000,:,:,:]\ny_0 = np.zeros(40000)\nX_1 = Class_1_data[0:35800,:,:,:]\ny_1 = np.ones(35800)","dfa916c4":"y = np.concatenate((y_0,y_1), axis = 0 )\nX = np.concatenate((X_0,X_1), axis = 0)\nX.shape,y.shape","cc4b5ac5":"np.random.seed(42)\nX_shuffle, y_shuffle = shuffle(X,y)\n","59b1cae2":"X_train = tf.convert_to_tensor(X_shuffle[0:70000,:,:,:])\/255\ny_train = tf.convert_to_tensor(y_shuffle[0:70000])\nX_val = tf.convert_to_tensor(X_shuffle[70000:70400,:,:,:])\/255\ny_val = tf.convert_to_tensor(y_shuffle[70000:70400])\nX_test = tf.convert_to_tensor(X_shuffle[70400:70800,:,:,:])\/255\ny_test = tf.convert_to_tensor(y_shuffle[70400:70800])","d4f907cf":"np.unique(y_train,return_counts = True)","07272d9c":"base_model = keras.applications.Xception(include_top=False,input_shape = (71,71,3),)\n#print(model.summary())","d558ad70":"np.random.seed(42)\n\nbase_model.trainable = False\n\nnew_model = keras.Sequential([\n    \n    # Preprocessing\n    preprocessing.RandomFlip('horizontal_and_vertical'), # flip left-to-right\n    preprocessing.RandomContrast(0.5), # contrast change by up to 50%\n    preprocessing.RandomRotation((-0.5,0.5)),\n    preprocessing.RandomCrop(71,71),\n    # To a base pretrained on ImageNet to extract features from images...\n    base_model,\n    # ... attach a new head to act as a classifier.\n    tf.keras.layers.GlobalAveragePooling2D(),\n    #tf.keras.layers.Dropout(0.3),\n    #tf.keras.layers.Dense(2000, activation='relu'),\n    #tf.keras.layers.Dense(1000, activation='relu'),\n    #tf.keras.layers.Dense(50, activation='relu'),\n    tf.keras.layers.Dense(1, activation='sigmoid'),\n])\n\n#print(new_model.summary())","20957ed4":"# Learning Rate Schedule for Fine Tuning #\ndef exponential_lr(epoch,\n                   start_lr = 0.00001, min_lr = 0.00001, max_lr = 0.00005,\n                   rampup_epochs = 5, sustain_epochs = 0,\n                   exp_decay = 0.8):\n\n    def lr(epoch, start_lr, min_lr, max_lr, rampup_epochs, sustain_epochs, exp_decay):\n        # linear increase from start to rampup_epochs\n        if epoch < rampup_epochs:\n            lr = ((max_lr - start_lr) \/\n                  rampup_epochs * epoch + start_lr)\n        # constant max_lr during sustain_epochs\n        elif epoch < rampup_epochs + sustain_epochs:\n            lr = max_lr\n        # exponential decay towards min_lr\n        else:\n            lr = ((max_lr - min_lr) *\n                  exp_decay**(epoch - rampup_epochs - sustain_epochs) +\n                  min_lr)\n        return lr\n    return lr(epoch,\n              start_lr,\n              min_lr,\n              max_lr,\n              rampup_epochs,\n              sustain_epochs,\n              exp_decay)\n\nlr_callback = tf.keras.callbacks.LearningRateScheduler(exponential_lr, verbose=True)","61be675e":"early_stopping = callbacks.EarlyStopping(\n    min_delta=0.001, # minimium amount of change to count as an improvement\n    patience=25, # how many epochs to wait before stopping\n    restore_best_weights=True,)\nfrom keras.optimizers import Adam\nopt = Adam()\nnew_model.compile(optimizer=opt,loss='binary_crossentropy',metrics=['acc'], )\n","5e93b330":"np.random.seed(42)\n\nhistory = new_model.fit(X_train, y_train,validation_data = (X_val,y_val), batch_size=20 ,epochs=12,callbacks=[early_stopping,lr_callback])","a4717f59":"new_model.evaluate(X_test,y_test)","a4ddad1d":"history_df = pd.DataFrame(history.history)\nfig, ax = plt.subplots(nrows=1, ncols= 2, figsize = (15,5))\nplt.style.use('seaborn-dark-palette')\n\nax[0].plot(history_df.loc[:, ['loss', 'val_loss']]);\nax[0].set(title = 'Model Loss', ylabel='Loss value', xlabel = 'Epochs');\nax[0].legend(['train_data','Validation']);\n\nax[1].plot(history_df.loc[:, ['acc', 'val_acc']]);\nax[1].set(title = 'Model Accuracy', ylabel='Accuracy value', xlabel = 'Epochs');\nax[1].legend(['train_data','Validation']);","ac2fa1cd":"y_pred = new_model.predict(X_test)\ny_pred = [round(float(i)) for i in y_pred ]","80417756":"#import seaborn to check the accuracy\nfrom sklearn.metrics import confusion_matrix , classification_report\nprint(classification_report(y_test,y_pred))","53de034d":"# Draw the confusion matrix\ncm = confusion_matrix(y_test ,y_pred )\ncm,np.unique(y_test,return_counts=True)","831c2848":"import seaborn as sns\n# Plot confusion matrix in a beautiful manner\nfig, ax = plt.subplots(nrows=1, ncols= 1, figsize = (10,6))\nsns.heatmap(cm, annot=True, ax = ax, fmt = 'g', cmap=\"inferno\"); #annot=True to annotate cells\n# labels, title and ticks\nax.set_xlabel('Predicted', fontsize=20)\nax.xaxis.set_label_position('top') \nax.xaxis.set_ticklabels([0,1], fontsize = 15)\nax.xaxis.tick_top()\nax.set_ylabel('True label', fontsize=20)\nax.yaxis.set_ticklabels([0,1], fontsize = 15)\nplt.show()","59ded4be":"negative_class,positive_class,data_frame = Turn_into_list_dir(data,folder)\ndata_frame.head(5)","c9a24e06":"def Take_coordinate(dataframe):\n    X_value =[]\n    y_value = []\n    Path = dataframe['Patient_path'].values\n    for i in Path:\n        i = i.replace('_class1.png','')\n        i = i.replace('_class0.png','')\n        y = i[-4:]\n        if 'y' or '_' in y:\n            y = y.replace('y','')\n            y = y.replace('_','')\n        y_value.append(int(y))\n\n        X = i[-10:-5]\n        if '_' or 'x' in x:\n            X = X.replace('_','')\n            X = X.replace('x','')\n        X_value.append(int(X))\n    dataframe['X_value'] = X_value\n    dataframe['y_value'] = y_value\n    return dataframe\n\ndef Turn_the_image_into_np(path): # Change the shape of the image for the matrix\n    img = cv2.imread(path)\n    return np.transpose(img,(2,0,1))\n\ndef Create_the_mask(positive_path): # Create the mask for Positive image\n    img = cv2.imread(positive_path)\n    b, g, r = cv2.split(img)\n    b= b -100   # decrease the blue value and change the order of of channel \n    red_img= cv2.merge([r,b,g])\n    return np.transpose(red_img,(2,0,1))\n\ndef Create_the_predicted_mask(positive_path):\n    img = cv2.imread(positive_path)\n    b, g, r = cv2.split(img)\n    g = g- 80\n    b = b + 30\n    red_img= cv2.merge([r,b,g])\n    return np.transpose(red_img,(2,0,1))","a0ade8dc":"def Draw_the_prediction(ID, model, data_frame):\n    np.random.seed(42)\n    \n    '''\n    Create the dataframe\n    '''\n    df_small = data_frame[(data_frame['Patient_id']==ID)]\n    X_0 = data_frame[(data_frame['Patient_id']==ID)& (data_frame['Patient_state:']==0)]['Patient_path'].values\n    X_1 = data_frame[(data_frame['Patient_id']==ID)& (data_frame['Patient_state:']==1)]['Patient_path'].values\n    \n    \n    '''\n    Create the dataset for the model to predict:\n    '''\n    # Training data\n    X_0_data = []\n    for i in X_0:\n        image = cv2.imread(i)\n        if image.shape == (50,50,3):\n            image = cv2.resize(image,(71,71))\n            X_0_data.append(image)\n        else:\n            df_small.drop(df_small[df_small['Patient_path'] == i].index, inplace = True) # remove the invalid image size for plotting\n    X_0_data = np.array(X_0_data)\/255\n\n    X_1_data = []\n    for i in X_1:\n        image = cv2.imread(i)\n        if image.shape == (50,50,3):\n            image = cv2.resize(image,(71,71))\n            X_1_data.append(image)\n        else:\n            df_small.drop(df_small[df_small['Patient_path'] == i].index, inplace = True) # remove the invalid image size for plotting\n    X_1_data = np.array(X_1_data)\/255\n\n    # Labeling data\n    y_0 = np.zeros((X_0_data.shape[0],1))\n    y_1 = np.ones((X_1_data.shape[0],1))\n    \n    # final data:\n    X_test = np.concatenate((X_0_data,X_1_data))\n    y_test = np.concatenate((y_0,y_1))\n    \n    '''\n    Evaluating the model:\n    '''\n    # Check the accuracy:\n    Accuracy = model.evaluate(X_test,y_test)\n    print(f'The accuracy of teh model prediction for this data set: {Accuracy}')\n    #Print the prediction \n    y_pre = model.predict(X_test)\n    y_pred = [round(float(i)) for i in y_pre]\n    uni, count = np.unique(y_pred,return_counts=True)\n    print(f'There are {count} in ID {ID}')\n    \n    '''\n    Create new data frame with the coordinate:\n    '''\n    df_small['Patient_state_predict']=y_pred\n    df_small = Take_coordinate(df_small)\n    \n    '''\n    Create the Image:\n    '''\n    count_wrong_image_shape = 0\n    #Find out largest coordinate to of the image:\n    X_max = np.max(df_small['X_value'])\n    y_max = np.max(df_small['y_value'])\n\n    # Take the path of the positive and negative image\n    Path_pos = df_small[df_small['Patient_state:']==1]['Patient_path'].values\n    Path_neg = df_small[df_small['Patient_state:']==0]['Patient_path'].values\n\n    # Draw the image\n    w, h = X_max,y_max\n\n    data = np.ones((3, h+50, w+50),dtype=np.uint8)\n    data = data *245 # fill out all the matrix with gray color_ if not the image will have black background\n    data_2 = np.ones((3, h+50, w+50),dtype=np.uint8) *245\n    '''\n    Create the image  masked  \n    '''\n    value_x = df_small[df_small['Patient_state:']==0]['X_value'].values # Take X_coordinate\n    value_y = df_small[df_small['Patient_state:']==0]['y_value'].values # Take y_coordinate\n\n    # Since each image is (50,50,3) so we need to plus 50\n    # Each coordinate is separate 50 pixel so we do not need to scale \n    for i in range(0,Path_neg.shape[0]):\n        if Turn_the_image_into_np(Path_neg[i]).shape == (3,50,50): # Check there are any wrong image shape\n            data[:,value_y[i]:value_y[i]+ 50,value_x[i]:value_x[i]+50] = (data[:,value_y[i]:value_y[i]+ 50,value_x[i]:value_x[i]+50] -244) * (Turn_the_image_into_np(Path_neg[i]))\n        else:\n            count_wrong_image_shape = count_wrong_image_shape+1\n\n    value_x = df_small[df_small['Patient_state:']==1]['X_value'].values\n    value_y = df_small[df_small['Patient_state:']==1]['y_value'].values\n\n    for x in range(0,Path_pos.shape[0]):\n        if Turn_the_image_into_np(Path_pos[x]).shape != (3,50,50): # Check there are any wrong image shape\n            count_wrong_image_shape = count_wrong_image_shape+1\n        else:\n            data[:,value_y[x]:value_y[x]+ 50,value_x[x]:value_x[x]+50] = (data[:,value_y[x]:value_y[x]+ 50,value_x[x]:value_x[x]+50]-244)  *  (Create_the_mask(Path_pos[x]))\n\n    '''\n    Create the image predicted masked  \n    '''\n    # Take the path of the positive and negative image\n    Path_pos = df_small[df_small['Patient_state_predict']==1]['Patient_path'].values\n    Path_neg = df_small[df_small['Patient_state_predict']==0]['Patient_path'].values\n\n    value_x = df_small[df_small['Patient_state_predict']==0]['X_value'].values # Take X_coordinate\n    value_y = df_small[df_small['Patient_state_predict']==0]['y_value'].values # Take y_coordinate\n\n    # Since each image is (50,50,3) so we need to plus 50\n    # Each coordinate is separate 50 pixel so we do not need to scale \n    for i in range(0,Path_neg.shape[0]):\n        if Turn_the_image_into_np(Path_neg[i]).shape == (3,50,50): # Check there are any wrong image shape\n            data_2[:,value_y[i]:value_y[i]+ 50,value_x[i]:value_x[i]+50] = (data_2[:,value_y[i]:value_y[i]+ 50,value_x[i]:value_x[i]+50] -244) * (Turn_the_image_into_np(Path_neg[i]))\n        else:\n            count_wrong_image_shape = count_wrong_image_shape+1\n\n    value_x = df_small[df_small['Patient_state_predict']==1]['X_value'].values\n    value_y = df_small[df_small['Patient_state_predict']==1]['y_value'].values\n\n    for x in range(0,Path_pos.shape[0]):\n        if Turn_the_image_into_np(Path_pos[x]).shape != (3,50,50): # Check there are any wrong image shape\n            count_wrong_image_shape = count_wrong_image_shape+1\n        else:\n            data_2[:,value_y[x]:value_y[x]+ 50,value_x[x]:value_x[x]+50] = (data_2[:,value_y[x]:value_y[x]+ 50,value_x[x]:value_x[x]+50]-244)  *  (Create_the_predicted_mask(Path_pos[x]))\n    \n    '''\n    Plot the image\n    '''\n    print(f'There are {count_wrong_image_shape} wrong image size in ID {ID}')\n    fig, ax = plt.subplots(nrows=1, ncols= 2, figsize = (15,10))\n    plt.style.use('seaborn-dark-palette')\n\n    ax[0].imshow(np.transpose(data,(1,2,0)));\n    ax[0].set(title = f'True Mask, Patient_ID: {ID}');\n\n\n    ax[1].imshow(np.transpose(data_2,(1,2,0)));\n    ax[1].set(title = f'Predicted Mask, Patient_ID: {ID}');\n    ","c243b9be":"Draw_the_prediction(13617, new_model, data_frame)","c1259d3e":"Draw_the_prediction(10254, new_model, data_frame)","533126f7":"Draw_the_prediction(16568, new_model, data_frame)","639fa71e":"Draw_the_prediction(12883, new_model, data_frame)","3f333596":"Draw_the_prediction(10305, new_model, data_frame)","98e86dc1":"Draw_the_prediction(13018, new_model, data_frame)","e1bf98e2":"Draw_the_prediction(16165, new_model, data_frame)","3d874b2b":"Draw_the_prediction(9381, new_model, data_frame)","4b6a4d43":"Draw_the_prediction(12750, new_model, data_frame)","002178ec":"Draw_the_prediction(13693, new_model, data_frame)","65563b66":"### **Create some charts for more understading about the data**","d3d54487":"###### **Draw many images in one figure**","df5db157":"### Remove id 12750, 16165, 9381 for predicting model","6235204f":"# Creating the data frame","7ba5cb6e":"#### **Through the histogram figures and some images above, we can slighly conclude that the Cancer images have some special patterns comparing to the normal one**\n1. About the color: It is more purple than the normal ones \n2. About the histogram: \n    * All the peaks of three channel is usually less than 125 ( y coordinate ( frequency))\n    * Though some Cancer image patch is opposite to the theory so I will try to plot some off them into the dataset for the model to learn too.\n    * Ofcourse there will be exception","48961064":"**Draw the the full image by creating the new array**","cf41ea44":"Class_1  = pd.concat([Class_1[0:21900],Class_1_addition[0:9000]],axis = 0)\nClass_1.shape","d4ea4f66":"**Percentage of abnormal image of each id**","d0d5816e":"**Number of image per patient**","5b68e7e0":"## **Preprocessing the image before training**","ab7069c8":"# **Evaluate the model**","1ec1a035":"## **Draw the prediction of the model into a real image**","0233832d":"## Take more look into the dataframe","b4d5ff9e":"### *Take some addition data types to train the model:*","4cb8ddfd":"# **Import some package**","ce295965":"**Draw the image of one patients cell by scatters**","4742372c":"**Normal and abnormal images**","76d0a415":"* ####  There are three id that I have not used to train the model. Now I will these ID to check the performance of my model\n* ####  These ID are 12750,16165,9381","4ea7dc9e":"##### **After plotting around more than 100 images, we can slightly conclude that the abnormal image may be more purple than normal image**","c01a4123":"###### ***The number of abnormal image is much more than the normal one***\n","b7bd705c":"np.random.seed(42)\nmodel.trainable = False\nbase_inputs = model.layers[0].input\nbase_outputs = model.layers[-2].output\nx = layers.GlobalAveragePooling2D()(base_outputs)\nx = layers.Dropout(0.3)(x)\nx = layers.Dense(1000,activation = 'relu')(x)\n#x = layers.Dense(500,activation = 'relu')(x)\n#x = layers.Dropout(0.3)(x)\nx = layers.Dense(100,activation = 'relu')(x)\nx = layers.Dense(50,activation = 'relu')(x)\nclassifier = layers.Dense(1,activation = 'sigmoid')(x)\nnew_model = keras.Model(inputs=base_inputs, outputs=classifier)\n\nprint(new_model.summary())","8d039329":"###### **Notice that there are some patients have many Anormal image ( nearly 90%) while the others only have around 10%**","22b88364":"### **Try to plot the peak positions of all the channel in the Cancer image and Non-cancer image and create the dataset**","71767920":"np.random.seed(42)\nClass_1_addition = df[(df.Fre_Peak_Green > 125)|(df.Fre_Peak_Red > 125)|(df.Fre_Peak_Blue > 125)]\nClass_1_addition = Class_1_addition.sample(frac=1)\nClass_1_addition.shape\n\n\nClass_1_addition.shape","71992638":"### **Explore some picture of the Normal class and Abnormal class**"}}