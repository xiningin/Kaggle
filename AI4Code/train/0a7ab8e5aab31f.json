{"cell_type":{"7cdf6e4a":"code","ba5adef0":"code","d2906fa1":"code","ad8bb8d6":"code","cc073a32":"code","f8111ee6":"code","8ca09285":"code","5b2d010f":"code","31294536":"code","4adf5c7d":"code","3712b9c8":"code","a01e743c":"code","138229fe":"code","e9158ab3":"code","9fd2776e":"code","a03cb06f":"code","4509e28f":"code","1e5fd847":"code","cda0d694":"code","a362ce1a":"code","ee5f9e01":"code","6638d406":"code","e611fb99":"code","51698893":"code","20f2c3ce":"code","875d8d51":"code","425b640d":"code","b9745151":"code","9812e151":"code","e379d9b1":"code","22a3c702":"code","c3ee55ed":"code","2cdee499":"code","7dbd3878":"code","0833a55e":"code","05e1e179":"code","ae622835":"code","2a9ee9ab":"code","9d5731b8":"code","bab9d480":"code","4480b752":"code","be3ccc2f":"code","ea0cf6b9":"code","0839af1c":"code","939d2cd1":"code","6f303dac":"code","8e6d5571":"code","4daed057":"code","d83232ee":"code","f0fe22da":"code","2dab3380":"code","b0df7ac9":"code","34d2ecba":"code","4d646f36":"code","97847f5e":"code","a7ace707":"code","05b46156":"code","a4d43566":"code","9fa21bbf":"code","a4422fe1":"code","7e178ad4":"code","31a39a1a":"code","f3131776":"code","133b6468":"code","ce73dc09":"code","eeb5fa51":"code","7a0bd0e3":"code","44638148":"code","bbba1eea":"code","587f4f91":"code","afa7a67a":"code","ec425726":"code","5e29c426":"code","435d5fb8":"code","a28a7a48":"code","a8487ff1":"code","bb932c35":"code","c8ef01c6":"code","dd3c969b":"code","815fee8d":"code","11843033":"markdown","4ca4ef35":"markdown","bf0f8c08":"markdown","e42068b3":"markdown","b0f75bc3":"markdown","d4eb2bb1":"markdown","e53fb66b":"markdown","c1c3ffd5":"markdown","2c878ff8":"markdown","2285b23f":"markdown","04cf8526":"markdown","f683cecb":"markdown"},"source":{"7cdf6e4a":"# Import libraries\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport seaborn as sns\n\nimport folium\nfrom folium import plugins\nfrom folium.plugins import MarkerCluster\n\nfrom sklearn import preprocessing\n\n# Importing dataset\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.linear_model import Ridge\nfrom sklearn.linear_model import Lasso\nfrom sklearn.linear_model import ElasticNet\nfrom sklearn.model_selection import train_test_split\n\nimport plotly.graph_objs as go\n\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import mean_absolute_error\nfrom math import sqrt\nfrom sklearn.metrics import r2_score\nimport numpy as np\n\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.ensemble import GradientBoostingRegressor\nimport xgboost\n\nimport plotly as plotly\nfrom plotly import __version__\nimport plotly.offline as py \nfrom plotly.offline import init_notebook_mode, plot\ninit_notebook_mode(connected=True)\nfrom plotly import tools\nimport plotly.graph_objs as go\nimport plotly.express as px\n\nprint (\"Libraries imported\")","ba5adef0":"# Read the dataset\nnyc_data_airbnb_raw = pd.read_csv('..\/input\/Airbnb_Newyork_Listings_Detailed.csv')","d2906fa1":"# Examine the dataset\nnyc_data_airbnb_raw.info()","ad8bb8d6":"# Get the number of rows and columns of the dataset\nnyc_data_airbnb_raw.shape","cc073a32":"# Check data tyes of raw data columns\nnyc_data_airbnb_raw.dtypes","f8111ee6":"# View raw data. Top three entires only\nnyc_data_airbnb_raw.head(3)","8ca09285":"# Copy dataset to save the original dataset which can be used again later\nnyc_data_airbnb = nyc_data_airbnb_raw.copy()\nprint(\"Dataset copied\")","5b2d010f":"nyc_data_airbnb.shape","31294536":"# Check unique values for string type columns\n\nfor col in nyc_data_airbnb[['experiences_offered', 'street', 'property_type', 'room_type',\n                 'bed_type','amenities']]:\n    print('Unique values in column: %s' %col)\n    print(nyc_data_airbnb[col].unique()), '\\n'","4adf5c7d":"# Removing unimportant columns based on observation\ndrop_columns = ['id','listing_url','scrape_id','last_scraped','summary','space',\n                'description','neighborhood_overview','notes','transit','access',\n                'interaction','house_rules','thumbnail_url','medium_url','picture_url',\n                'xl_picture_url','host_url','host_name','host_since','host_location',\n                'host_about','host_thumbnail_url','host_picture_url',\n                'host_verifications','host_is_superhost','host_total_listings_count','host_has_profile_pic',\n                'host_identity_verified','require_guest_profile_picture','require_guest_phone_verification',\n                'is_location_exact', 'extra_people','calendar_updated','has_availability',\n                'calendar_last_scraped','first_review','last_review','license','jurisdiction_names',\n                'calculated_host_listings_count','calculated_host_listings_count_entire_homes',\n                'calculated_host_listings_count_private_rooms','calculated_host_listings_count_shared_rooms',\n                'city','state','zipcode','market','smart_location','country_code','country',\n                'experiences_offered','street','weekly_price','monthly_price',\n                'minimum_minimum_nights','maximum_minimum_nights','minimum_maximum_nights',\n                'maximum_maximum_nights','minimum_nights_avg_ntm','maximum_nights_avg_ntm',\n                'review_scores_cleanliness','review_scores_checkin','review_scores_communication',\n                'review_scores_location','number_of_reviews_ltm','review_scores_value']\nnyc_data_airbnb.drop(columns=drop_columns,inplace=True)\n\nprint(\"Unimportant columns dropped\")","3712b9c8":"# Drop all NaN values for square_feet & host_acceptance_rate\nnyc_data_airbnb.drop(columns = {'square_feet'},inplace=True)\nnyc_data_airbnb.drop(columns = {'host_acceptance_rate'},inplace=True)\n\nprint(\"NaN columns dropped\")","a01e743c":"# Format host_response_rate, remove % sign and convert data type tp float for calculations\nnyc_data_airbnb['host_response_rate'] = nyc_data_airbnb['host_response_rate'].str.replace(\"%\", \"\").astype(\"float\")\nprint(\"host_response_rate formatted\")","138229fe":"# Printing unique values for requires_license, instant_bookable & is_business_travel_ready\n\nfor col in nyc_data_airbnb[['requires_license', 'instant_bookable', 'is_business_travel_ready']]:\n    print('Unique values in column: %s' %col)\n    print(nyc_data_airbnb[col].unique()), '\\n'","e9158ab3":"# Format requires_license, instant_bookable & is_business_travel_ready as required and also change their data types to int\nnyc_data_airbnb.loc[nyc_data_airbnb['requires_license'] == 'f',['requires_license']] = '1'\nnyc_data_airbnb.loc[nyc_data_airbnb['requires_license'] == 't',['requires_license']] = '2'\nnyc_data_airbnb.loc[nyc_data_airbnb['instant_bookable'] == 'f',['instant_bookable']] = '1'\nnyc_data_airbnb.loc[nyc_data_airbnb['instant_bookable'] == 't',['instant_bookable']] = '2'\nnyc_data_airbnb.loc[nyc_data_airbnb['is_business_travel_ready'] == 'f',['is_business_travel_ready']] = '1'\nnyc_data_airbnb.requires_license = nyc_data_airbnb.requires_license.astype(int)\nnyc_data_airbnb.instant_bookable = nyc_data_airbnb.instant_bookable.astype(int)\nnyc_data_airbnb.is_business_travel_ready = nyc_data_airbnb.is_business_travel_ready.astype(int)\nprint(\"requires_license, instant_bookable & is_business_travel_ready formatted\")","9fd2776e":"# Format price, security_deposit & cleaning_fee columns and change their type from string to float\nnyc_data_airbnb.price = nyc_data_airbnb.price.str.strip('$')\nnyc_data_airbnb.price = nyc_data_airbnb.price.str.replace(',','')\nnyc_data_airbnb.price = nyc_data_airbnb.price.astype(float)\n\nnyc_data_airbnb.security_deposit = nyc_data_airbnb.security_deposit.str.strip('$')\nnyc_data_airbnb.security_deposit = nyc_data_airbnb.security_deposit.str.replace(',','')\nnyc_data_airbnb.security_deposit = nyc_data_airbnb.security_deposit.astype(float)\n\nnyc_data_airbnb.cleaning_fee = nyc_data_airbnb.cleaning_fee.str.strip('$')\nnyc_data_airbnb.cleaning_fee = nyc_data_airbnb.cleaning_fee.str.replace(',','')\nnyc_data_airbnb.cleaning_fee = nyc_data_airbnb.cleaning_fee.astype(float)\n\nprint(\"Price related columns formatted\")","a03cb06f":"print(\"Check null values in the dataset\")\nnyc_data_airbnb.isnull().sum()","4509e28f":"# Fill empty rows with the mean value of their respective columns\nnyc_data_airbnb['name'].fillna(value=\"Default Name\", inplace=True)\nnyc_data_airbnb['bathrooms'].fillna(value=np.mean(nyc_data_airbnb['bathrooms']), inplace=True)\nnyc_data_airbnb['bedrooms'].fillna(value=np.mean(nyc_data_airbnb['bedrooms']), inplace=True)\nnyc_data_airbnb['beds'].fillna(value=np.mean(nyc_data_airbnb['beds']), inplace=True)\nnyc_data_airbnb['review_scores_rating'].fillna(value=np.mean(nyc_data_airbnb['review_scores_rating']), inplace=True)\nnyc_data_airbnb['review_scores_accuracy'].fillna(value=np.mean(nyc_data_airbnb['review_scores_accuracy']), inplace=True)\nnyc_data_airbnb['reviews_per_month'].fillna(value=np.mean(nyc_data_airbnb['reviews_per_month']), inplace=True)\nnyc_data_airbnb['security_deposit'].fillna(value=np.mean(nyc_data_airbnb['security_deposit']), inplace=True)\nnyc_data_airbnb['cleaning_fee'].fillna(value=np.mean(nyc_data_airbnb['cleaning_fee']), inplace=True)\nnyc_data_airbnb['host_response_rate'].fillna(value=np.mean(nyc_data_airbnb['host_response_rate']), inplace=True)\nnyc_data_airbnb['host_listings_count'].fillna(value=np.mean(nyc_data_airbnb['host_listings_count']), inplace=True)\nprint(\"Empty rows filled with mean\")","1e5fd847":"print(\"Check null values in the dataset after replacing with mean value\")\nnyc_data_airbnb.isnull().sum()","cda0d694":"# Relationship between price and room type\nplt.figure()\nsns.scatterplot(x='room_type', y='price', hue=\"room_type\", data=nyc_data_airbnb)\nplt.xlabel(\"Room Type\")\nplt.ylabel(\"Price\")\nplt.title(\"Room Type vs Price\", size=15, weight='bold')","a362ce1a":"# Relationship between price and neighbourhood_group_cleansed\nplt.figure()\nsns.scatterplot(x=\"neighbourhood_group_cleansed\", y=\"price\", hue=\"neighbourhood_group_cleansed\", data=nyc_data_airbnb)\nplt.xlabel(\"Neighbourhood Group\")\nplt.ylabel(\"Price\")\nplt.title(\"Neighbourhood Group vs Price\", size=15, weight='bold')","ee5f9e01":"# Relationship between price, room_type and neighbourhood_group_cleansed\nplt.figure()\nsns.scatterplot(x=\"room_type\", y=\"price\", hue=\"neighbourhood_group_cleansed\", size=\"neighbourhood_group_cleansed\", sizes=(50, 200),\n               data=nyc_data_airbnb)\nplt.xlabel(\"Room Type\")\nplt.ylabel(\"Price\")\nplt.title(\"Room Type vs Price vs Neighbourhood Group\",size=15, weight='bold')","6638d406":"# Relationship between listing count and neighbourhood_group_cleansed\nplt.figure()\nsns.countplot(nyc_data_airbnb[\"neighbourhood_group_cleansed\"])\nplt.xlabel(\"Neighbourhood Group\")\nplt.ylabel(\"Count\")\nplt.title(\"Neighbourhood Group vs Listing Count\", size=15, weight='bold')","e611fb99":"# Relationship between listing count and neighbourhood_group_cleansed\nplt.figure()\nsns.scatterplot(nyc_data_airbnb.longitude,nyc_data_airbnb.latitude,hue=nyc_data_airbnb.neighbourhood_group_cleansed)\nplt.xlabel(\"Longitute\")\nplt.ylabel(\"Latitude\")\nplt.title(\"Longitute vs Latitude vs Neighbourhood Group\", size=15, weight='bold')","51698893":"# Graph to display which neighbourhood_group_cleansed is relatively more expensive\nnda = nyc_data_airbnb[nyc_data_airbnb.price < 250]\nplt.figure()\nsns.boxplot(y=\"price\",x='neighbourhood_group_cleansed',data=nda)\nplt.xlabel(\"Neighbourhood Group\")\nplt.ylabel(\"Price\")\nplt.title(\"Neighbourhood Group Price Distribution < 250\")","20f2c3ce":"# Relationship between number of room types with each neighbourhood group\nplt.figure()\nsns.countplot(x = 'room_type',hue = \"neighbourhood_group_cleansed\",data = nyc_data_airbnb)\nplt.xlabel(\"Room Type\")\nplt.ylabel(\"Count\")\nplt.title(\"Room types occupied by the neighbourhood_group_cleansed\")","875d8d51":"# catplot room type vs price\nplt.figure()\nsns.catplot(x=\"room_type\", y=\"price\", data=nyc_data_airbnb);\nplt.xlabel(\"Room Type\")\nplt.ylabel(\"Price\")\nplt.title(\"Room type vs Price\")","425b640d":"# Plot first 1000 listings with most number of reviews on the map using folium\nmostReviewsNycData = nyc_data_airbnb.sort_values(by=['number_of_reviews'], ascending=False).head(1000)","b9745151":"print('Rooms with the most number of reviews')\nLat = 40.7128\nLong = -74.0060\n\nmapdf1=folium.Map([Lat,Long],zoom_start=10,)\n\nmapdf1_rooms_map=plugins.MarkerCluster().add_to(mapdf1)\n\nfor lat,lon,label in zip(mostReviewsNycData.latitude,mostReviewsNycData.longitude,mostReviewsNycData.name):\n    folium.Marker(location=[lat,lon],icon=folium.Icon(icon='home'),popup=label).add_to(mapdf1_rooms_map)\n\nmapdf1.add_child(mapdf1_rooms_map)\n\nmapdf1","9812e151":"#Find 1000 most expensive rooms\nmostExpensiveNyc=nyc_data_airbnb.sort_values(by=['price'],ascending=False).head(1000)","e379d9b1":"print('Most Expensive rooms')\nLong=-73.80\nLat=40.80\nmapdf1=folium.Map([Lat,Long],zoom_start=10,)\n\nmapdf1_rooms_map=plugins.MarkerCluster().add_to(mapdf1)\n\nfor lat,lon,label in zip(mostExpensiveNyc.latitude,mostExpensiveNyc.longitude,mostExpensiveNyc.name):\n    folium.Marker(location=[lat,lon],icon=folium.Icon(icon='home'),popup=label).add_to(mapdf1_rooms_map)\nmapdf1.add_child(mapdf1_rooms_map)\n\nmapdf1","22a3c702":"#Count of room types\nnyc_data_airbnb['room_type'].value_counts()","c3ee55ed":"rmtng2 = nyc_data_airbnb.groupby(['neighbourhood_group_cleansed','neighbourhood'])['price'].agg('mean')","2cdee499":"rmtng1 = pd.DataFrame(rmtng2)","7dbd3878":"rmtng1.reset_index(inplace=True)","0833a55e":"Bronx = rmtng1[rmtng1['neighbourhood_group_cleansed']=='Bronx']\nBrooklyn = rmtng1[rmtng1['neighbourhood_group_cleansed']=='Brooklyn']\nManhattan = rmtng1[rmtng1['neighbourhood_group_cleansed']=='Manhattan']\nQueens = rmtng1[rmtng1['neighbourhood_group_cleansed']=='Queens']\nStatenIsland = rmtng1[rmtng1['neighbourhood_group_cleansed']=='Staten Island']","05e1e179":"Bronx1=Bronx.sort_values(by=['price'],ascending=False).head(10)\nBrooklyn1=Brooklyn.sort_values(by=['price'],ascending=False).head(10)\nManhattan1=Manhattan.sort_values(by=['price'],ascending=False).head(10)\nQueens1=Queens.sort_values(by=['price'],ascending=False).head(10)\nStatenIsland1=StatenIsland.sort_values(by=['price'],ascending=False).head(10)","ae622835":"trace1=go.Scatter(x=Bronx1['neighbourhood'],y=Bronx1['price'],marker=dict(color=\"crimson\", size=12),mode=\"markers\",name=\"Bronx\",)\n\ntrace2=go.Scatter(x=Brooklyn1['neighbourhood'],y=Brooklyn1['price'],marker=dict(color=\"blue\", size=12),mode=\"markers\",name=\"Brooklyn\",)\n\ntrace3=go.Scatter(x=Manhattan1['neighbourhood'],y=Manhattan1['price'],marker=dict(color=\"purple\", size=12),mode=\"markers\",name=\"Manhattan\",)\n\ntrace4=go.Scatter(x=Queens1['neighbourhood'],y=Queens1['price'],marker=dict(color=\"black\", size=12),mode=\"markers\",name=\"Queens\",)\n\ntrace5=go.Scatter(x=StatenIsland1['neighbourhood'],y=StatenIsland1['price'],marker=dict(color=\"red\", size=12),mode=\"markers\",name=\"StatenIsland\",)\n\ndata = [trace1,trace2,trace3,trace4,trace5]\n\ntitles=['Most Pricey neighbourhoods-Bronx',\n        'Most Pricey neighbourhoods-Brooklyn',\n        'Most Pricey neighbourhoods-Manhattan',\n        'Most Pricey neighbourhoods-Queens',\n        'Most Pricey neighbourhoods-StatenIsland']\n\nfig =plotly.subplots.make_subplots(rows=3,cols=2,subplot_titles=titles)\n\n\nfig.append_trace(trace1,1,1)\nfig.append_trace(trace2,1,2)\nfig.append_trace(trace3,2,1)\nfig.append_trace(trace4,2,2)\nfig.append_trace(trace5,3,1)\n\n\nfig['layout'].update(height=1200,width=1000,paper_bgcolor='white')\n\npy.iplot(fig,filename='pricetypeplot')","2a9ee9ab":"#100 most reviewed listings in NYC\ntop_reviewed_listings=nyc_data_airbnb.nlargest(100,'number_of_reviews')","9d5731b8":"price_avrg=top_reviewed_listings.price.mean()\nprint('Average price per night for top 100 reviewed lisitings: {}'.format(price_avrg))","bab9d480":"#initializing empty list where we are going to put our name strings\n_names_=[]\n#getting name strings from the column and appending it to the list\nfor name in nyc_data_airbnb.name:\n    _names_.append(name)\n#setting a function that will split those name strings into separate words   \ndef split_name(name):\n    spl=str(name).split()\n    return spl\n#initializing empty list where we are going to have words counted\n_names_for_count_=[]\n#getting name string from our list and using split function, later appending to list above\nfor x in _names_:\n    for word in split_name(x):\n        word=word.lower()\n        _names_for_count_.append(word)","4480b752":"#we are going to use counter\nfrom collections import Counter\n#let's see top 30 used words by host to name their listing\n_top_30_w=Counter(_names_for_count_).most_common()\n_top_30_w=_top_30_w[0:30]","be3ccc2f":"#now let's put our findings in dataframe for further visualizations\nsub_w=pd.DataFrame(_top_30_w)\nsub_w.rename(columns={0:'Words', 1:'Count'}, inplace=True)","ea0cf6b9":"#we are going to use barplot for this visualization\nviz_5=sns.barplot(x='Words', y='Count', data=sub_w)\nviz_5.set_title('Counts of the top 30 used words for listing names')\nviz_5.set_ylabel('Count of words')\nviz_5.set_xlabel('Words')\nviz_5.set_xticklabels(viz_5.get_xticklabels(), rotation=80)","0839af1c":"# Finding out top 10 neighbourhoods\nnyc_data_airbnb.neighbourhood.value_counts().head(10)","939d2cd1":"# Categorical features coversion. We have done this at the end as we need the actual categories for various plots.\nnyc_data_airbnb.host_neighbourhood = nyc_data_airbnb.host_neighbourhood.astype('category').cat.codes\nnyc_data_airbnb.neighbourhood = nyc_data_airbnb.neighbourhood.astype('category').cat.codes\nnyc_data_airbnb.neighbourhood_cleansed = nyc_data_airbnb.neighbourhood_cleansed.astype('category').cat.codes\nnyc_data_airbnb.property_type = nyc_data_airbnb.property_type.astype('category').cat.codes\nnyc_data_airbnb.room_type = nyc_data_airbnb.room_type.astype('category').cat.codes\nnyc_data_airbnb.bed_type = nyc_data_airbnb.bed_type.astype('category').cat.codes\nnyc_data_airbnb.neighbourhood_group_cleansed = nyc_data_airbnb.neighbourhood_group_cleansed.astype('category').cat.codes\nnyc_data_airbnb.cancellation_policy = nyc_data_airbnb.cancellation_policy.astype('category').cat.codes\nnyc_data_airbnb.host_response_time = nyc_data_airbnb.host_response_time.astype('category').cat.codes\nprint(\"Categorical features converted\")","6f303dac":"#For joint plots\nnyc_data_airbnb_plot = nyc_data_airbnb.copy()","8e6d5571":"# Remove name, host_id and amenities for joint plots\nnyc_data_airbnb_plot.drop(columns = {'name','host_id','amenities'},inplace=True)","4daed057":"# Joint plots: to check the linear relationship of features with the target variable price\ncols = nyc_data_airbnb_plot.columns.values\nfor c in cols:\n    if c != \"price\":\n        sns.jointplot(x=c, y=\"price\", data=nyc_data_airbnb_plot, kind = 'reg', height = 5)\nplt.show()","d83232ee":"# Correlation heatmap applied on training set\ncorr = nyc_data_airbnb.corr() \nplt.figure(figsize=(18, 16))\n\nsns.heatmap(corr[(corr >= 0.5) | (corr <= -0.4)], \n            cmap='viridis', vmax=1.0, vmin=-1.0, linewidths=0.1,\n            annot=True, annot_kws={\"size\": 8}, square=True)","f0fe22da":"# Analysing price for removing outliers\nprint(np.mean(nyc_data_airbnb['price']))\nprint(np.max(nyc_data_airbnb['price']))\nprint(np.min(nyc_data_airbnb['price']))","2dab3380":"nyc_data_airbnb = nyc_data_airbnb_raw.copy()","b0df7ac9":"nyc_data_airbnb['amenities'].head()","34d2ecba":"np.concatenate(nyc_data_airbnb['amenities'].map(lambda amns: amns.split(\"|\")).values)","4d646f36":"features = nyc_data_airbnb[['host_listings_count', 'host_total_listings_count', 'accommodates', \n                     'bathrooms', 'bedrooms', 'beds', 'price', 'guests_included', 'number_of_reviews',\n                     'review_scores_rating']]","97847f5e":"nyc_data_airbnb['amenities'] = nyc_data_airbnb['amenities'].map(\n    lambda amns: \"|\".join([amn.replace(\"}\", \"\").replace(\"{\", \"\").replace('\"', \"\")\\\n                           for amn in amns.split(\",\")])\n)","a7ace707":"nyc_data_airbnb['amenities'].map(lambda amns: amns.split(\"|\")).head()","05b46156":"#First amenity is empty so exclude that\namenities = np.unique(np.concatenate(nyc_data_airbnb['amenities'].map(lambda amns: amns.split(\"|\"))))[1:]","a4d43566":"amenity_arr = np.array([nyc_data_airbnb['amenities'].map(lambda amns: amn in amns) for amn in amenities])\namenity_arr","9fa21bbf":"features = pd.concat([features, pd.DataFrame(data=amenity_arr.T, columns=amenities)], axis=1)","a4422fe1":"features.head(3)","7e178ad4":"features.shape","31a39a1a":"for tf_feature in ['host_is_superhost', 'host_identity_verified', 'host_has_profile_pic',\n                   'is_location_exact', 'requires_license', 'instant_bookable',\n                   'require_guest_profile_picture', 'require_guest_phone_verification']:\n    features[tf_feature] = nyc_data_airbnb[tf_feature].map(lambda s: False if s == \"f\" else True)","f3131776":"for categorical_feature in ['neighbourhood_cleansed', 'property_type', 'room_type', 'bed_type']:\n    features = pd.concat([features, pd.get_dummies(nyc_data_airbnb[categorical_feature])], axis=1)","133b6468":"for col in features.columns[features.isnull().any()]:\n    print(col)","ce73dc09":"for col in features.columns[features.isnull().any()]:\n    features[col] = features[col].fillna(features[col].median())","eeb5fa51":"features.price = features.price.str.strip('$')\nfeatures.price = features.price.str.replace(',','')\nfeatures.price = features.price.astype(float)","7a0bd0e3":"nyc_data_airbnb['host_is_superhost'].head()","44638148":"features['price'].sort_values().reset_index(drop=True).plot()","bbba1eea":"fitters = features.query('price <= 600')\nfitters.shape","587f4f91":"y = fitters['price']\nX = fitters.drop(columns = {'price'}, axis = 1)\nX.shape","afa7a67a":"# Train Test Split\n# 80-20 Split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=101)","ec425726":"import time\n# Train Linear Regression model\nlm = LinearRegression()\nt0=time.time()\nlm.fit(X_train,y_train)\nprint(\"Training time:\", round(time.time()-t0, 3), \"s\") # the time would be round to 3 decimal in seconds\nt1=time.time()\npred_linear_x = lm.predict(X_test)\nprint(\"Prediction time:\", round(time.time()-t1, 3), \"s\")\n\nerror_airbnb = pd.DataFrame({\n        'Actual Values': np.array(y_test).flatten(),\n        'Predicted Values': pred_linear_x.flatten()})\nprint(error_airbnb.head().to_string())","5e29c426":"# Train Ridge Regression model\nridge_x = Ridge(alpha = 0.01, normalize = True)\nt0=time.time()\nridge_x.fit(X_train,y_train) \nprint(\"Training time:\", round(time.time()-t0, 3), \"s\") # the time would be round to 3 decimal in seconds\nt1=time.time()\npred_ridge_x = ridge_x.predict(X_test) \nprint(\"Prediction time:\", round(time.time()-t1, 3), \"s\")\n\nerror_airbnb = pd.DataFrame({\n        'Actual Values': np.array(y_test).flatten(),\n        'Predicted Values': pred_ridge_x.flatten()})\nprint(error_airbnb.head().to_string())","435d5fb8":"# Train Lasso Regression model\nLasso_x = Lasso(alpha = 0.001, normalize =False)\nt0=time.time()\nLasso_x.fit(X_train,y_train)\nprint(\"Training time:\", round(time.time()-t0, 3), \"s\") # the time would be round to 3 decimal in seconds\nt1=time.time()\npred_Lasso_x = Lasso_x.predict(X_test) \nprint(\"Prediction time:\", round(time.time()-t1, 3), \"s\")\n\nerror_airbnb = pd.DataFrame({\n        'Actual Values': np.array(y_test).flatten(),\n        'Predicted Values': pred_Lasso_x.flatten()})\nprint(error_airbnb.head().to_string())","a28a7a48":"# Train ElasticNet Regressor model\nmodel_enet_x = ElasticNet(alpha = 0.01, normalize=False)\nt0=time.time()\nmodel_enet_x.fit(X_train,y_train) \nprint(\"Training time:\", round(time.time()-t0, 3), \"s\") # the time would be round to 3 decimal in seconds\nt1=time.time()\npred_enet_x= model_enet_x.predict(X_test)\nprint(\"Prediction time:\", round(time.time()-t1, 3), \"s\")\n\nerror_airbnb = pd.DataFrame({\n        'Actual Values': np.array(y_test).flatten(),\n        'Predicted Values': pred_enet_x.flatten()})\nprint(error_airbnb.head().to_string())","a8487ff1":"# Train Random Forest Regression model\nrandomf = RandomForestRegressor(n_estimators=200)\nt0=time.time()\nrandomf.fit(X_train,y_train)\nprint(\"Training time:\", round(time.time()-t0, 3), \"s\") # the time would be round to 3 decimal in seconds\nt1=time.time()\npred_random_x = randomf.predict(X_test)\nprint(\"Prediction time:\", round(time.time()-t1, 3), \"s\")\n\nerror_airbnb = pd.DataFrame({\n        'Actual Values': np.array(y_test).flatten(),\n        'Predicted Values': pred_random_x.flatten()})\nprint(error_airbnb.head().to_string())","bb932c35":"X_train = X_train.loc[:,~X_train.columns.duplicated()]\nX_test = X_test.loc[:,~X_test.columns.duplicated()]","c8ef01c6":"# Train Xgboost Regressor model\nxgb = xgboost.XGBRegressor(n_estimators=310,learning_rate=0.1,objective='reg:squarederror')\nt0=time.time()\nxgb.fit(X_train, y_train)\nprint(\"Training time:\", round(time.time()-t0, 3), \"s\") # the time would be round to 3 decimal in seconds\nt1=time.time()\npred_xgb_x = xgb.predict(X_test)\nprint(\"Prediction time:\", round(time.time()-t1, 3), \"s\")\n\nerror_airbnb = pd.DataFrame({\n        'Actual Values': np.array(y_test).flatten(),\n        'Predicted Values': pred_xgb_x.flatten()})\nprint(error_airbnb.head().to_string())","dd3c969b":"# Train Gradient Boosted Regressor model\nGBoost = GradientBoostingRegressor(n_estimators=3000, learning_rate=0.01)\nt0=time.time()\nGBoost.fit(X_train,y_train)\nprint(\"Training time:\", round(time.time()-t0, 3), \"s\") # the time would be round to 3 decimal in seconds\nt1=time.time()\npred_gboost_x = GBoost.predict(X_test)\nprint(\"Prediction time:\", round(time.time()-t1, 3), \"s\")\n\nerror_airbnb = pd.DataFrame({\n        'Actual Values': np.array(y_test).flatten(),\n        'Predicted Values': pred_gboost_x.flatten()})\nprint(error_airbnb.head().to_string())","815fee8d":"print('-------------Linear Regression-----------')\n\nprint('MAE: %f'% mean_absolute_error(y_test, pred_linear_x))\nprint('RMSE: %f'% np.sqrt(mean_squared_error(y_test, pred_linear_x)))   \nprint('R2 %f' % r2_score(y_test, pred_linear_x))\n\nprint('---------------Ridge Regression---------------------')\n\nprint('MAE: %f'% mean_absolute_error(y_test, pred_ridge_x))\nprint('RMSE: %f'% np.sqrt(mean_squared_error(y_test, pred_ridge_x)))   \nprint('R2 %f' % r2_score(y_test, pred_ridge_x))\n\nprint('---------------Lasso Regression-----------------------')\n\nprint('MAE: %f' % mean_absolute_error(y_test, pred_Lasso_x))\nprint('RMSE: %f' % np.sqrt(mean_squared_error(y_test, pred_Lasso_x)))\nprint('R2 %f' % r2_score(y_test, pred_Lasso_x))\n\nprint('---------------ElasticNet Regressor-------------------')\n\nprint('MAE: %f' % mean_absolute_error(y_test,pred_enet_x))\nprint('RMSE: %f' % np.sqrt(mean_squared_error(y_test,pred_enet_x)))\nprint('R2 %f' % r2_score(y_test, pred_enet_x))\n\nprint('---------------RandomForest Regressor-------------------')\n\nprint('MAE: %f' % mean_absolute_error(y_test,pred_random_x))\nprint('RMSE: %f' % np.sqrt(mean_squared_error(y_test,pred_random_x)))\nprint('R2 %f' % r2_score(y_test, pred_random_x))\n\nprint('---------------XG Boost Regressor-------------------')\n\nprint('MAE: %f' % mean_absolute_error(y_test,pred_xgb_x))\nprint('RMSE: %f' % np.sqrt(mean_squared_error(y_test,pred_xgb_x)))\nprint('R2 %f' % r2_score(y_test, pred_xgb_x))\n\nprint('---------------GradientBoosted Regressor-------------------')\n\nprint('MAE: %f' % mean_absolute_error(y_test,pred_gboost_x))\nprint('RMSE: %f' % np.sqrt(mean_squared_error(y_test,pred_gboost_x)))\nprint('R2 %f' % r2_score(y_test, pred_gboost_x))","11843033":"# Abstract\nAirbnb has been providing its guests and hosts a personalized travel experience for more than a decade and during this time they have seen an almost exponential growth of customers. By analyzing their currently available data, we can uncover interesting information regarding Airbnb\u2019s customers, locations and pricing. By using various machine learning techniques, we have built multiple regression models for predicting prices of Airbnb listings. These models include Linear Regression, Lasso Regression, Ridge Regression, Elastic Net Regression, Random Forest Regressor, XG Boosted Regressor and Gradient Boosted Regressor. Various trends related to Airbnb New York data have been disclosed. Mean Absolute Error, Root Mean Squared Error and Coefficient of Determination have been used as the evaluation metrics for regression.","4ca4ef35":"# Exploratory Data Analysis (EDA) & Pre-Processing\nThe following section contains exploratory data analysis of Airbnb Newyork dataset which includes plots for data visualization:\n* Joint plot\n* Correlation heatmap\n* Scatter plot\n* Count plot\n* Box plot\n* Bar plot\n* Cat plot\n* Folium maps\n\nThis section also contains pre-processing which is required for EDA and model building.","bf0f8c08":"# Code\nThe following section contains the complete code for exploratory data analysis and various models along with their evaluation.","e42068b3":"# Evaluation\nMetrics used for model evaluation are Mean Absolute Error (MAE) and Root Mean Squared Error (Root Mean Squared Error).\nThe unit of these evaluation metrices is dollar.\n\nAlso, coefficient of determination or r2 score is also calculated for these regression models.","b0f75bc3":"# Airbnb Exploartory Data Analysis and Listing Price Prediction using Linear Regression, Ridge Regression, ElasticNet Regression, Lasso Regression, Random Forest Regression, GradientBoosted Regression & XGBoosted Regression","d4eb2bb1":"# Experiments\n\nThe approach followed for this project consists of five phases explained below. We have shown the preprocessing for all five phases but the models are built only for the fifth phase as it gave the most promising results.\n\n### Phase 1\nIn this phase we have reduced our data set from 106 columns to 34 columns. We have removed columns that were unimportant for our price predictions. The decision for the removal of columns was based on different approaches. We removed those columns that had either no data or very small amount of rows. Removed columns that were flags to store different types of information related to the host user of Airbnb etc.\n### Phase 2\nIn phase 2, we have removed outliers based on the price variable. By displaying the joint plots of all important features we found out that most of the listings have prices below 2000 dollars. So in this phase we removed all those rows that had more than 4000 dollars price for a listing. We also removed the rows that had 0 dollars mentioned as the listing price. To deal with the missing data, we have used the mean value of the columns to replace their missing values. For categorical data, we have used integer encoding technique.\n### Phase 3\nThis phase is similar to phase 2. In this phase, we removed all those rows that had listing prices over 2000 dollars.\n### Phase 4\nIn this phase, we have performed feature reduction and feature selection based on the joints plots of that data and their correlation matrix. Joint plots represent the linearity between the price and the targeted column feature.\n### Phase 5\nIn phase 5, we filled missing values using median value of the column. Removed outlier base on price > 600 dollars and replaced categorical data using one-hot encoding.\n","e53fb66b":"# **Model Training\/Testing**","c1c3ffd5":"# **Acknowledgements**\n\nThis notebook contains code inpiration from various notebooks on Kaggle related to pre-processing, exploratory data analysis and model building of Airbnb dataset for different cities. Some of the notebooks are:\n* https:\/\/www.kaggle.com\/ibjohnsson\/predicting-listing-prices\n* https:\/\/www.kaggle.com\/mpanfil\/nyc-airbnb-data-science-ml-project\n* https:\/\/www.kaggle.com\/duygut\/airbnb-nyc-price-prediction\n* https:\/\/www.kaggle.com\/jrw2200\/unsupervised-techniques-t-sne-pca-k-means\n* https:\/\/www.kaggle.com\/nishok03\/price-prediction-with-xgb-gbr-data-exploration\n* https:\/\/www.kaggle.com\/dgomonov\/data-exploration-on-nyc-airbnb\n* https:\/\/www.kaggle.com\/chirag9073\/airbnb-analysis-visualization-and-prediction\n* https:\/\/www.kaggle.com\/residentmario\/modeling-prices\n\nSpecial thanks to all the Kagglers for their contributions on Kaggle regarding different Airbnb datasets.","2c878ff8":"# Introduction\nRegression is a technique for predicting the values of a dependent variable based on the combination of independent variables and their adjusted weights. Regression determines the statistical relationship between two or more variables where change in the dependent variable is linked to the change in one or more independent variables. When there is only one independent variable, then we apply Linear Regression. When there are more than one independent variables, then we apply Multiple Regression. \nRegression is of different types. Some of them are listed below along with their brief description:\n* Linear regression (Least Square)\n<br\/>\nLinear regression is a linear approach to modeling the relationship between a response or dependent variable and one or more explanatory or independent variables\n* Lasso regression\n<br\/>\nLasso stands for Least Absolute Shrinkage and Selection Operator. This is a type of linear regression that uses shrinkage. Data values are shrunk towards a central point. Lasso regression performs L1 regularization. L1 adds a penalty equal to the absolute value of the magnitude of coefficients.\n* Ridge regression\n<br\/>\nRidge regression is a type of linear regression that performs L2 regularization using a shrinkage estimator. L2 adds a penalty which equals the square of the magnitude of coefficients.\n* Elastic net regression\n<br\/>\nElastic net is a regularized regression method that add L1 and L2 regularization of Lasso and Ridge regression. This regression overcomes the limitations of Lasso and Ridge regression.\n* Random forest regression\n<br\/>\nRandom forest combines many decision trees into a single model. Individually, predictions made by decision trees may not be accurate, but combined together, the predictions will be closer to the mark on average. Random forest is the example of bagging technique.\n* XGBoosted regression\n<br\/>\nXGBoost stands for eXtreme Gradient Boosting. This is fast as compared to simple gradient boosted regression and generally gives better model performance. Better for structured or tabular datasets\n* Gradient boosted regression\n<br\/>\nGradient boosting is an example of boosting algorithm which is an ensemble technique. Gradient boosting is a machine learning technique for regression and classification problems, which produces a prediction model in the form of an ensemble of weak prediction models, typically decision trees.\n<br\/><br\/>\nOur main problem is to predict the listings price for Airbnb New York dataset. Using the above mentioned regression techniques, we can build models for our Airbnb New York dataset to predict the price of listings. Using this dataset we can uncover various trends for Airbnb New York. For example, \n<br\/>\n* What is the price variation for different room types for different listings?\n* What is the relationship of price with neighborhoods?\n* How many listings are in each neighborhoods?\n* What types of rooms are being offered in different neighborhoods?\n* Which listings have most number of reviews?\n* What are the most expensive rooms and to which neighborhoods they belong?\n* What are the most commonly used words in listing names? etc.\n<br\/><br\/>\nTo answer all these question, we can perform exploratory data analysis and uncover all these trends which can help Airbnb in offering different services in different neighborhoods.","2285b23f":"# Conclusion\n* XGBoosted Regression gave better price prediction accuracy among the 7 regression techniques used with R2 = 0.646\n* Brooklyn neighborhood has the most number of listings in New York (10752)\n* Manhattan neighborhood group has the most number of listings in New York (> 20000)\n* Most number of listings are for Entire home\/apt (25296)\n* Words like room, bedroom, apartment, large, sunny, park & spacious etc are most commonly used words in listing names\n* Average New York listing price is around $150","04cf8526":"# **Pre-processing**","f683cecb":"## About the Dataset\nFor this project, we will be using the dataset available at http:\/\/insideairbnb.com\/get-the-data.html for New York. The size of available data for Airbnb New York listings as of August 2019 is 48.8k x 106. Some of the important features of the dataset are listed below:\n* neighbourhood_group\n* neighbourhood\n* longitude\n* latitude\n* beds\n* room_type\n* number_of_reviews\n* minimum_nights\n* accommodates\n* availability_365\n* price (dependent variable)\n"}}