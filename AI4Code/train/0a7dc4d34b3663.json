{"cell_type":{"a64a831e":"code","6298d9c5":"code","b091a4b4":"code","ed349c59":"code","209db9d8":"code","2cca527b":"code","21171098":"code","99de147d":"code","6348826c":"code","1d21c669":"code","eaddaec2":"code","94fa3107":"code","373a6177":"code","6e30563d":"code","1e76adb0":"code","2968f251":"code","1fef7598":"code","004dae5d":"code","f4e998a3":"code","f838316a":"code","a541c06c":"code","6309140a":"code","db27aa25":"code","3c02c6e1":"code","f3815b31":"code","975ee911":"code","054b3f16":"code","6d36c02d":"code","50623c54":"code","91cbb681":"code","dde324bd":"code","d1b48039":"code","85462442":"code","b64a24b5":"code","6151f580":"code","12b9c69d":"code","d7fe40a3":"code","7e39f753":"code","d55a14f8":"code","2d95bd01":"code","e770867f":"code","db7bb489":"code","3f62390b":"code","4fc106fe":"code","e1737c62":"code","a3f77583":"code","15676639":"code","292cb692":"code","8dc89dee":"code","c272c5c1":"code","c33de7f0":"code","ce3789f9":"code","ce818f7d":"code","773f8f86":"code","842e2f25":"code","ae94dd54":"code","d0394e5f":"code","d081fd57":"code","08fe0555":"code","c8b099ec":"code","d1ab0857":"code","540c95c4":"code","896078df":"code","d85d3e16":"code","75b522ad":"code","eab482f8":"code","c1829e19":"code","6ae9c0b2":"code","c0465f43":"code","b811cdc0":"code","39caa8e5":"code","92e501f3":"code","817aef64":"code","2581788d":"code","7fb21a35":"code","ec7d97bf":"code","575233ff":"code","f514856b":"code","24121a95":"code","60199f5d":"code","232366b0":"code","f656f663":"code","0604778a":"code","ff121971":"code","8d04d2da":"code","65bc8ada":"code","4a493edb":"code","d546f809":"code","cfda8554":"code","ee3f0181":"code","4485692e":"code","45b2bd3b":"code","1f7309df":"code","51995242":"code","35df38ff":"code","37e8cafe":"code","7a95b37d":"code","ed01ae2c":"markdown","da37eed5":"markdown","0e67bfa0":"markdown","948f7115":"markdown"},"source":{"a64a831e":"%%capture\n!pip install fastbook --no-index --find-links=file:\/\/\/kaggle\/input\/fastbook\/ \nfrom fastbook import *\nfrom fastai.vision.all import *\nfrom fastai.tabular.all import *\nfrom pandas.api.types import is_string_dtype, is_numeric_dtype, is_categorical_dtype\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.ensemble import GradientBoostingRegressor\nimport xgboost as xg","6298d9c5":"df = pd.read_csv('..\/input\/petfinder-pawpularity-score\/train.csv', low_memory=False)","b091a4b4":"df.columns","ed349c59":"df.head()","209db9d8":"Path.BASE_PATH=Path('..\/input\/petfinder-pawpularity-score\/train')","2cca527b":"Images = get_image_files('..\/input\/petfinder-pawpularity-score\/train', recurse=True)","21171098":"List=[]\nfor i in range(9912):\n    List.append(''.join(re.findall(r'(.+).jpg$', Images[i].name)))","99de147d":"def get_x(a): return a['Images']\ndef get_y(a): return a['Pawpularity']","6348826c":"train = [] \nvalid = []\nfor i in range(9911):\n    if i%7==0:\n        valid.append(i)\n    else:\n        train.append(i)\n    \n","1d21c669":"def splitter(art):\n    trai = art.iloc[train] \n    vali = art.iloc[valid]\n    return train,valid\n    ","eaddaec2":"data={'Id':List,'Images':Images}\nart = pd.DataFrame(data)\nart = art.merge(df)\nart.head()","94fa3107":"pets = DataBlock(blocks = [ImageBlock, RegressionBlock()],\n                  get_x = get_x,\n                  get_y = get_y,\n                  splitter =splitter,\n                  item_tfms = [Resize(224)],\n                  batch_tfms = [*aug_transforms(flip_vert=True,size=(224)), Normalize.from_stats(*imagenet_stats)])\n\ndls = pets.dataloaders(art)\ndls.show_batch(nrows=2,ncols=3)","373a6177":"if not os.path.exists('\/root\/.cache\/torch\/hub\/checkpoints\/'):\n        os.makedirs('\/root\/.cache\/torch\/hub\/checkpoints\/')\n!cp '..\/input\/resnet34\/resnet34-b627a593.pth' '\/root\/.cache\/torch\/hub\/checkpoints\/resnet34-b627a593.pth'","6e30563d":"learn = cnn_learner(dls, resnet34, y_range=(1,100))","1e76adb0":"learn.lr_find()","2968f251":"learn.fit_one_cycle(6, 2e-3)\nlearn.unfreeze()","1fef7598":"learn.lr_find()","004dae5d":"learn.fit_one_cycle(2, lr_max=slice(1e-7,3e-7), wd=0.2)","f4e998a3":"learn.recorder.plot_loss()","f838316a":"learn.show_results(ds_idx=1, nrows=3, ncols=2, figsize=(6,8))","a541c06c":"learn.export()","6309140a":"path = Path('.\/export.pkl')\nlearn_inf = load_learner(path)","db27aa25":"_,vali = splitter(art)","3c02c6e1":"art1 = art['Images']\npre = art1.iloc[vali]","f3815b31":"%%capture\nvisual_learner = []\nfor i in pre:\n    visual_learner.append(learn_inf.predict(i)[0])","975ee911":"procs = [Categorify, FillMissing]","054b3f16":"fart = art.loc[:, art.columns!='Images']\nfart.head()","6d36c02d":"cont, cat = cont_cat_split(fart, 1, dep_var='Pawpularity')","50623c54":"to = TabularPandas(fart, procs, cat, cont, y_names='Pawpularity', splits=(list(train),list(valid)))","91cbb681":"len(to.train), len(to.valid)","dde324bd":"to.show(6)","d1b48039":"to.items.head(4)","85462442":"save_pickle(Path('.\/')\/'to.pkl',to)","b64a24b5":"to = load_pickle(Path('.\/')\/'to.pkl')","6151f580":"xs,y = to.train.xs,to.train.y\nvalid_xs,valid_y = to.valid.xs,to.valid.y","12b9c69d":"def r_mse(pred,y): return round(math.sqrt(((pred-y)**2).mean()), 6)\ndef m_rmse(m,xs,y): return r_mse(m.predict(xs),y)","d7fe40a3":"def rf(xs, y, n_estimators=4000, max_samples=4000,\n       max_features=0.5, min_samples_leaf=5, **kwargs):\n    return RandomForestRegressor(n_jobs=-1, n_estimators=n_estimators,\n                                max_samples=max_samples, max_features=max_features,\n                                min_samples_leaf=min_samples_leaf, oob_score=True).fit(xs,y)","7e39f753":"m = rf(xs, y);","d55a14f8":"m_rmse(m,xs,y), m_rmse(m,valid_xs,valid_y)","2d95bd01":"preds = np.stack([t.predict(valid_xs) for t in m.estimators_])","e770867f":"r_mse(preds.mean(0), valid_y)","db7bb489":"plt.plot([r_mse(preds[:i+1].mean(0), valid_y) for i in range(40)]);","3f62390b":"r_mse(m.oob_prediction_,y)","4fc106fe":"preds = np.stack([t.predict(valid_xs) for t in m.estimators_])","e1737c62":"preds.shape","a3f77583":"st = preds.std(0)\nst[:5]","15676639":"def rf_feat_importance(m, fart):\n    return pd.DataFrame({'cols':fart.columns, 'imp':m.feature_importances_}\n                       ).sort_values('imp', ascending=False)","292cb692":"fi = rf_feat_importance(m, xs)\nfi[:10]","8dc89dee":"def plot_fi(fi):\n    return fi.plot('cols', 'imp', 'barh', figsize=(12,7), legend=False)\n\nplot_fi(fi[:30]);","c272c5c1":"to_keep = fi[fi.imp>0.0005].cols\nlen(to_keep)","c33de7f0":"xs_imp = xs[to_keep]\nvalid_xs_imp = valid_xs[to_keep]","ce3789f9":"m = rf(xs_imp, y)","ce818f7d":"m_rmse(m, xs_imp, y), m_rmse(m, valid_xs_imp, valid_y)","773f8f86":"len(xs.columns), len(xs_imp.columns)","842e2f25":"plot_fi(rf_feat_importance(m, xs_imp));","ae94dd54":"cluster_columns(xs_imp)","d0394e5f":"%%capture\n!pip install treeinterpreter --no-index --find-links=file:\/\/\/kaggle\/input\/treeinterpreter\/ \n#!pip install waterfallchart --no-index --find-links=file:\/\/\/kaggle\/input\/waterfallchart\/ \nwarnings.simplefilter('ignore', FutureWarning)\nfrom treeinterpreter import treeinterpreter\n#from waterfallchart import plot as waterfall","d081fd57":"row = valid_xs_imp.iloc[:5]","08fe0555":"predictions, bias, contributions = treeinterpreter.predict(m, row.values)","c8b099ec":"predictions[0], bias[0], contributions[0].sum()","d1ab0857":"#waterfall(valid_xs_imp.columns, contributions[0], threshold=0.08,\n#        rotation_value=45, formatting='{:,.3f}');","540c95c4":"df_dom = pd.concat([xs_imp, valid_xs_imp])\nis_valid = np.array([0]*len(xs_imp)+[1]*len(valid_xs_imp))\nm = rf(df_dom, is_valid)\nrf_feat_importance(m, df_dom)[:6]","896078df":"m = rf(xs_imp, y)\nprint('orig', m_rmse(m, valid_xs_imp, valid_y))\n\nfor c in ('Id', 'Group', 'Occlusion'):\n    m = rf(xs_imp.drop(c,axis=1), y)\n    print(c, m_rmse(m, valid_xs_imp.drop(c,axis=1), valid_y))","d85d3e16":"time_vars = ['Id', 'Action', 'Occlusion', 'Group']\nxs_final = xs_imp.drop(time_vars, axis=1)\nvalid_xs_final = valid_xs_imp.drop(time_vars, axis=1)\n\nm = rf(xs_final, y)\nm_rmse(m, valid_xs_final, valid_y)","75b522ad":"df_nn_final = fart[list(xs_final.columns) + ['Pawpularity']]","eab482f8":"cont_nn,cat_nn = cont_cat_split(df_nn_final, max_card=6000, dep_var='Pawpularity')","c1829e19":"cont_nn","6ae9c0b2":"df_nn_final = df_nn_final.astype({'Pawpularity':np.float32})","c0465f43":"df_nn_final[cat_nn].nunique()","b811cdc0":"proc_nn = [Categorify, FillMissing, Normalize]\nto_nn = TabularPandas(df_nn_final, proc_nn, cat_nn, cont_nn, y_names='Pawpularity', splits=(list(train), list(valid)))","39caa8e5":"dls = to_nn.dataloaders(1024)","92e501f3":"y = to_nn.train.y\ny.min(), y.max()","817aef64":"learn = tabular_learner(dls, layers=[500,250], n_out=1,\n                       y_range=(1,100), loss_func=F.mse_loss)","2581788d":"learn.lr_find()","7fb21a35":"learn.fit_one_cycle(4, 4e-2, wd=0.3)","ec7d97bf":"preds,targs = learn.get_preds()\nrmse(preds, targs)","575233ff":"learn.save('nn')","f514856b":"def embed_features(learner, xs):\n    xs = xs.copy()\n    for i, feature in enumerate(learn.dls.cat_names):\n        emb = learner.model.embeds[i].to('cpu')\n        new_feat = pd.DataFrame(emb(tensor(xs[feature], dtype=torch.int64)), index=xs.index, columns=[f'{feature}_{j}' for j in range(emb.embedding_dim)])\n        xs.drop(columns=feature, inplace=True)\n        xs = xs.join(new_feat)\n    return xs","24121a95":"embeded_xs = embed_features(learn, learn.dls.train.xs)\nxs_valid = embed_features(learn, learn.dls.valid.xs)","60199f5d":"mr = rf(embeded_xs, y)\nm_rmse(mr, xs_valid, valid_y)","232366b0":"regressor = GradientBoostingRegressor(\n        max_depth=2,\n        n_estimators=3,\n        learning_rate=1.0\n)\nregressor.fit(xs_final, y)","f656f663":"errors = [r_mse(valid_y, y_pred) for y_pred in \n        regressor.staged_predict(valid_xs_final)]\n\nbest_n_estimators = np.argmin(errors)","0604778a":"best_regressor = GradientBoostingRegressor(\n            max_depth=4,\n            n_estimators=best_n_estimators,\n            learning_rate=1.0\n)\nbest_regressor.fit(xs_final, y)","ff121971":"gbm_preds = best_regressor.predict(valid_xs_final), valid_y\nrf_preds = m.predict(valid_xs_final)\nrfe_preds = mr.predict(xs_valid)\nens_preds = (to_np(preds.squeeze()) + rf_preds + rfe_preds  + gbm_preds[0])\/4           \nfinal_preds = (ens_preds + np.array(visual_learner).squeeze())\/2","8d04d2da":"r_mse(final_preds, valid_y)","65bc8ada":"test_df = pd.read_csv('..\/input\/petfinder-pawpularity-score\/test.csv')\ntime_var = ['Action', 'Occlusion', 'Group']\ntest_df = test_df.drop(time_var, axis=1)","4a493edb":"Images = get_image_files('..\/input\/petfinder-pawpularity-score\/test')","d546f809":"List=[]\nfor i in range(test_df.shape[0]):\n    List.append(''.join(re.findall(r'(.+).jpg$', Images[i].name)))","cfda8554":"data={'Id':List,'Images':Images}\ntes = pd.DataFrame(data)\ntes= tes.merge(test_df)\ntes_copy = tes.copy()\ndr = ['Images', 'Id']\ntab = tes.drop(dr, axis = 1)","ee3f0181":"from sklearn.preprocessing import LabelEncoder\n\nle = LabelEncoder()\nnew_Id = le.fit_transform(tes['Id'])\ntes['Id'] = new_Id","4485692e":"visual_preds = []\nfor i in tes['Images']:\n    visual_preds.append(learn_inf.predict(i)[0])","45b2bd3b":"dl = learn.dls.test_dl(tab, bs=8) # apply transforms\nnn_preds,  _ = learn.get_preds(dl=dl) # get prediction\nnn_preds = np.array(nn_preds).squeeze(1)","1f7309df":"xs_test = embed_features(learn, tab)","51995242":"gbm_preds = best_regressor.predict(tab)\nrf_preds = m.predict(tab)\nrfe_preds = mr.predict(xs_test)\nens_preds = (nn_preds + gbm_preds + rf_preds + rfe_preds)\/4","35df38ff":"visual_preds = np.array(visual_preds)[:,0]\nfinal_ens = (ens_preds + np.array(visual_preds).squeeze())\/2\nfinal_ens = np.round(final_ens, 2)","37e8cafe":"final_ens","7a95b37d":"submission = pd.DataFrame({'Id': tes_copy['Id'], 'Pawpularity': final_ens})\nsubmission.to_csv('submission.csv', index=False)\nsubmission","ed01ae2c":"# Training the tabular model","da37eed5":"# Training the image model","0e67bfa0":"# Test data","948f7115":"**tabular learner with nn**"}}