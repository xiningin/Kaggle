{"cell_type":{"ce5a488f":"code","df3837b7":"code","ff6c02a6":"code","9ff2b82b":"code","5cd32c03":"code","1825f2fb":"code","4385e4e4":"code","91068187":"code","2f5ec5ba":"code","23af21b8":"code","21e75a76":"code","8b96f572":"code","95124381":"code","3378bfaa":"code","d3d8e6bd":"code","2d13ec00":"code","ead29ccf":"code","fc1acef3":"code","1b374564":"code","3b394a0b":"code","3bb62e28":"code","72d9353b":"code","60e2fb2e":"code","f04a5e0b":"code","b74e48a1":"code","d17c998d":"code","cf834ed9":"code","59c7a6d5":"code","6ddd73d6":"code","70ef2826":"code","69e209da":"markdown","45733861":"markdown","05b2f129":"markdown","8be2e8ea":"markdown","beb87fa0":"markdown","d0de5e0d":"markdown","c643597a":"markdown","1ff0388b":"markdown","f7570a7b":"markdown","8de7ab72":"markdown","97285d0a":"markdown","2a839e34":"markdown","2c3731d6":"markdown","4cdf74b8":"markdown","da2e805f":"markdown","2036131f":"markdown","19c77606":"markdown","d9e5499e":"markdown","3fab64ee":"markdown"},"source":{"ce5a488f":"\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nfrom keras.layers import Dense, Conv2D,MaxPooling2D,Flatten,Dropout\nfrom keras.layers.core import Activation\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix\nfrom keras.models import Sequential\nfrom keras.utils import to_categorical\nfrom keras.callbacks import EarlyStopping ,ReduceLROnPlateau\nfrom keras.models import load_model\nfrom keras.optimizers import SGD, RMSprop\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","df3837b7":"df_train=pd.read_csv(\"..\/input\/train.csv\")\ndf_test=pd.read_csv(\"..\/input\/test.csv\")","ff6c02a6":"df_train.info()","9ff2b82b":"df_train.head()\n","5cd32c03":"predictors=np.array(df_train.drop(columns=['label']))\ntarget=np.array(df_train[\"label\"])","1825f2fb":"test=np.array(df_test)","4385e4e4":"images=predictors.reshape(-1,28,28)","91068187":"images[0].shape","2f5ec5ba":"f, axs = plt.subplots(1,10,figsize=(15,15))  \naxs.ravel()\nfor k in range(0,10):\n    axs[k].imshow(images[k],cmap=\"gray_r\")","23af21b8":"image_three=df_train[df_train[\"label\"]==3]\nimage_three=np.array(image_three.drop(columns=['label']))\nimage_three=image_three.reshape(-1,28,28)","21e75a76":"f, axs = plt.subplots(5,5,figsize=(15,15))  \naxs.ravel()\ni=0\nfor k in range(0,5):\n    for j in range(0,5):\n        axs[j,k].imshow(image_three[i],cmap=\"gray_r\")\n        i+=1","8b96f572":"model_test = Sequential()\nmodel_test.add(Conv2D(50, kernel_size=5, padding=\"same\",input_shape=(28, 28, 1),activation='relu'))","95124381":"image=image_three[0]\nplt.imshow(image,cmap=\"gray_r\")\nimage=image.reshape(-1,28,28,1)","3378bfaa":"image.shape","d3d8e6bd":"conv_image=model_test.predict(image)\nconv_image=np.squeeze(conv_image,axis=0)\nconv_image.shape","2d13ec00":"f, axs = plt.subplots(5,10,figsize=(15,15))  \naxs.ravel()\ni=0\nfor k in range(0,10):\n    for j in range(0,5):\n        axs[j,k].imshow(conv_image[:,:,i],cmap=\"gray_r\")\n        i+=1","ead29ccf":"model_test.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))\nconv_image=model_test.predict(image)\nconv_image=np.squeeze(conv_image,axis=0)\nconv_image.shape","fc1acef3":"f, axs = plt.subplots(5,10,figsize=(15,15))  \naxs.ravel()\ni=0\nfor k in range(0,10):\n    for j in range(0,5):\n        axs[j,k].imshow(conv_image[:,:,i],cmap=\"gray_r\")\n        i+=1","1b374564":"predictors=predictors\/255\ntest=test\/255","3b394a0b":"target=to_categorical(target)\nprint(target)","3bb62e28":"predictors=predictors.reshape(-1,28,28,1)\ntest=test.reshape(-1,28,28,1)\nX_train, X_test, y_train, y_test = train_test_split(predictors,target,test_size=0.2, random_state=42)","72d9353b":"model = Sequential()\nmodel.add(Conv2D(50, kernel_size=5, padding=\"same\",input_shape=(28, 28, 1), activation = 'relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))\nmodel.add(Dropout(0.2))\n\nmodel.add(Conv2D(80, kernel_size=5, padding=\"same\", activation = 'relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))\nmodel.add(Dropout(0.2))\n\nmodel.add(Flatten())\nmodel.add(Dense(500))\nmodel.add(Activation(\"relu\"))\n\nmodel.add(Dense(10))\nmodel.add(Activation(\"softmax\"))\nmodel.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])","60e2fb2e":"model.fit(X_train, y_train, epochs= 15 , batch_size=200, validation_split = 0.2)","f04a5e0b":"result_test=model.predict(predictors)","b74e48a1":"# select the index with the maximum probability\nresult_test = np.argmax(result_test,axis=1)","d17c998d":"result_test[456]","cf834ed9":"plt.imshow(predictors[456].reshape(28,28),cmap=\"gray_r\")","59c7a6d5":"results=model.predict(test)","6ddd73d6":"results=np.argmax(results,axis=1)","70ef2826":"results = pd.Series(results,name=\"Label\")\nsubmission = pd.concat([pd.Series(range(1,28001),name = \"ImageId\"),results],axis = 1)\nsubmission.to_csv(\"result.csv\",index=False)","69e209da":"The dropout layer consists in randomly dropping nodes, the aim is to avoid overfitting.<br> \nThe flatten layer consists in transforming the input array to an output array of size (*,500)","45733861":"**Classification** <br>\nEventually the output of the pooling feature is given to a fully connected layer. The purpose of this operation is to use those features to classify the input image.\nHere, this task can have ten possible outputs. In the output layer of the neural network, we use an activation function called **softmax**.  This function transforms a vector of arbitrary real values into a vector of real values where each entry is in the range (0, 1], and all the entries add up to 1. ","05b2f129":"<a id='result'>5. Result and conclusion<\/a><br>","8be2e8ea":"We save the images in a numpy array 'predictors' and the corresponding digit in the array 'target'.","beb87fa0":"**Pooling** <br>\nWe don't want our model to overfit our training data, indeed it must be capable of correctly identifying numbers from another dataset. \nIn order to avoid overfitting, we will try to decrease the level of details of our Feature map. This operation is called **Pooling** or **subsampling**. This step is quite similar to the convolution step. It consists in sliding a filter over the input image and apply a function on the window which is flown over by the filter. The most common pooling function are max or average. \n\nLet's visualize the output of this operation !","d0de5e0d":"1. [Introduction](#introduction)<br>\n2. [Visualazing images](#image)<br>\n3. [How does a Convolution Neural Network works ?](#cnn) <br>\n4. [Training our model](#training)<br>\n5. [Result and conclusion](#result)<br>","c643597a":"<a id='introduction'>1. Introduction<\/a><br>\nFrom the phone industry to military and government, cameras with artificial intelligence have become in widespread use. Phone makers have integrated this technology so that users could unlock their phone or pay just by taking a glimpse at their device, governments are using it to build giants surveillance network. I have always wondered how a computer could recognize something on an image. In this article, we will build a simple algorithm capable of recognizing handwritten numbers. Our goal is to correctly identify digits from a dataset of tens of thousands of handwritten image. In order to do so, we are going to create a neural network called Convolution Neural Network (CNN) and train it on our Dataset. They have proved to be very efficient on image recognition problem. ","1ff0388b":"We have to reshape our predictors array in order to visualize the 28x28 px images. ","f7570a7b":"If we train our model on the training set and evaluate its accuracy on the same data, our model would likely perform better than it actually does on unseen data. In order to avoid overfitting, we will split our train set in two subsets : 80% of the training set will be used for training and 20% will be used for testing our model. We use the train_test_split function to generate those subsets.","8de7ab72":"<a id='training'>4. Training our model<\/a><br>","97285d0a":"**Convolution** <br>\nThe purpose of this operation is to extract features from the input images. \nLet's consider a 5x5 image whose pixel values are 0 or 1. Now, let's consider a 3x3 matrix. The convolution consists in sliding the matrix (called **kernel** or **filter**) over the input image and multiply the matrixes which are overlapping. The number of pixels by which we slide our filter on the input matrix is called the **stride**.\nBy using different types of filter, we can identify different features in the image ( curves, edges ...). \nDuring this step, the input image will be filtered by different kernels. The output will be the result of the input image's filtering. The number of filters applied during the convolution is called the **Depth** and the output matrixes are called **Convolved features** or **Feature map** .\nAs convolution is a linear operation ( multiplication of matrixes ) and our model will be trained on non-linear data, we should apply a non linear operation to this layer's output. \n\n**Non linearity** \nThe function that is applied to Convolved Features  is called 'RELU' ( stands for Rectified Linear Unit ). It consists in replacing all the negatives pixels by 0 :\n$$ Relu=max(0,input)$$. \nRelu is a non linear operation\n\nLet's see what does a feature map look like ! We will apply this operation on an image and display the output. \n","2a839e34":"In order to visualize a set of handwritten digit 3, we will filter our training dataset and save the result in the 'image_three' array.","2c3731d6":"<a id='image'>2. Visualazing images<\/a><br>\nThe data files train.csv and test.csv contain gray-scale images of hand-drawn digits, from zero through nine. There are 42000 entries in our dataset. The first column, called \"label\", is the digit that was drawn by the user. The rest of the columns contain the pixel-values of the associated image. Each image is 28 pixels in height and 28 pixels in width, for a total of 784 pixels in total. Each pixel has a single pixel-value associated with it, indicating the lightness or darkness of that pixel, with higher numbers meaning darker. This pixel-value is an integer between 0 and 255, inclusive.","4cdf74b8":"As we can see below, our model has correctly predicted the outcome :)","da2e805f":"<a id=\"cnn\" >3. How does a Convolution Neural Network works ?<\/a>\n\nWhat's a convolution Neural Network ? \nConvolution Neural Networks are a category of neural networks that are very effective in image recognition and classification. \nA Convolutional Neural Network is typically composed by four operations : \n1. Convolution\n1. Non linearity \n1. Pooling \n1. Classification ","2036131f":"We will use the Keras library in order to build our model.","19c77606":"As Images with high pixel values would have a bigger impact on our model's training then low pixels value images, we have to normalize the data set. Hence, each image will contribute equally to our model loss. \nWe also tranform our target value ( digit ) into a vector to match the softmax function output. \n$$ 6=[0,0,0,0,0,0,1,0,0,0]$$. ","d9e5499e":"Our model can predict handwritten's digit value with 99% accuracy. Let's test our model !","3fab64ee":"Our model has predicted that the handwritten digit of the 456th image corresponds to a 5 !"}}