{"cell_type":{"dd276466":"code","57ca04d3":"code","370061f6":"code","e9cb4b0c":"markdown","d1f16b04":"markdown"},"source":{"dd276466":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","57ca04d3":"# -*- coding: utf-8 -*-\n\n\nimport cv2\nimport numpy as np\nfrom skimage import io\n\ndef zmMinFilterGray(src, r=7):\n    '''''Minimum filter, r is the filter radius'''\n    return cv2.erode(src,np.ones((2*r-1,2*r-1)))\n\n\ndef guidedfilter(I, p, r, eps):\n    '''''Bootstrap filtering, refer to someone else's code'''\n    height, width = I.shape\n    m_I = cv2.boxFilter(I, -1, (r,r))\n    m_p = cv2.boxFilter(p, -1, (r,r))\n    m_Ip = cv2.boxFilter(I*p, -1, (r,r))\n    cov_Ip = m_Ip-m_I*m_p\n\n    m_II = cv2.boxFilter(I*I, -1, (r,r))\n    var_I = m_II-m_I*m_I\n\n    a = cov_Ip\/(var_I+eps)\n    b = m_p-a*m_I\n\n    m_a = cv2.boxFilter(a, -1, (r,r))\n    m_b = cv2.boxFilter(b, -1, (r,r))\n    return m_a*I+m_b\n\ndef getV1(m, r, eps, w, maxV1):  #Input RGB image, value range [0,1]\n    '''''Calculate the atmospheric mask image V1 and illumination value A, V1 = 1-t\/A'''\n    V1 = np.min(m,2)                                         #Get the dark channel image\n    V1 = guidedfilter(V1, zmMinFilterGray(V1,7), r, eps)     #Optimization using guided filtering\n    bins = 2000\n    ht = np.histogram(V1, bins)                              #Calculate atmospheric illumination A\n    d = np.cumsum(ht[0])\/float(V1.size)\n    for lmax in range(bins-1, 0, -1):\n        if d[lmax]<=0.999:\n            break\n    A  = np.mean(m,2)[V1>=ht[1][lmax]].max()\n\n    V1 = np.minimum(V1*w, maxV1)                   #Limits the range of values\n    return V1,A\n\ndef deHaze(m, r=81, eps=0.001, w=0.95, maxV1=0.80, bGamma=False):\n    Y = np.zeros(m.shape)\n    V1,A = getV1(m, r, eps, w, maxV1)               #Get mask image and atmospheric illumination\n    for k in range(3):\n        Y[:,:,k] = (m[:,:,k]-V1)\/(1-V1\/A)           #Color correction\n    Y =  np.clip(Y, 0, 1)\n    if bGamma:\n        Y = Y**(np.log(0.5)\/np.log(Y.mean()))       #Gamma correction, which is not performed by default\n    return Y\n\nif __name__ == '__main__':\n    img1=io.imread('..\/input\/delfog\/sea.JPG')\n    io.imshow(img1)\n    m = deHaze(cv2.imread('..\/input\/delfog\/sea.JPG')\/255.0)*255\n    cv2.imwrite('defog.jpg', m)\n  ","370061f6":"img2=io.imread('.\/defog.jpg')\nio.imshow(img2)","e9cb4b0c":"Below is a rendering of the image after defogging","d1f16b04":"Image defogging based on dark channel"}}