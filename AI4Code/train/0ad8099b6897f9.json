{"cell_type":{"5ecfdc66":"code","f8e1c54d":"code","1c31b4bf":"code","3b809e31":"code","b0b66f03":"code","774e42a9":"code","3bdcbf25":"code","5f2a7c3a":"code","4766388e":"markdown","04a1e92a":"markdown","b67218e5":"markdown","9569ba01":"markdown","6eccc315":"markdown","7202347a":"markdown","d241d55f":"markdown","235d5c6f":"markdown"},"source":{"5ecfdc66":"# dataset files\nimport os\nimport numpy as np\nimport cv2 as cv\nimport struct # unpack\nimport matplotlib.pyplot as plt","f8e1c54d":"# https:\/\/jessicastringham.net\/2018\/05\/03\/smallnorb\/\n\nDATA_FOLDER = \"\/kaggle\/input\/the-small-norb-dataset-v10\/\"\n\nPREFIXES = {\n    'train': 'smallnorb-5x46789x9x18x6x2x96x96-training-',\n    'test': 'smallnorb-5x01235x9x18x6x2x96x96-testing-',\n}\n\nFILE_TYPES = ['info', 'cat', 'dat']\n\n# helper function to read int from file\ndef read_int(f):\n    num, = struct.unpack('i', f.read(4))\n    return num\n\n\n# From https:\/\/cs.nyu.edu\/~ylclab\/data\/norb-v1.0-small\/ \n# \"The magic number encodes the element type of the matrix\"\n# Note: I only copied over the ones I needed for these files.\nmap_magic_number_to_data_type = {\n    '1e3d4c55': np.uint8,\n    '1e3d4c54': np.int32,\n}\n\nloaded_data = {}\n\nfor dataset, prefix in PREFIXES.items():\n    for filetype in FILE_TYPES:\n        filename = prefix + filetype + \".mat\"\n        print('Reading {}'.format(filename))\n        \n        file_loc = os.path.join(DATA_FOLDER, filename)\n        with open( file_loc, 'rb') as f:\n            # Read the magic_num, convert it to hexadecimal, and look up the data_type\n            raw_magic_num = read_int(f)\n            magic_num = format(raw_magic_num, '02x')\n            data_type = map_magic_number_to_data_type[magic_num]\n            print('dtype', data_type)\n\n            # Read how many dimensions to expect\n            ndim = read_int(f)\n            \n            # Read at least 3 ints, or however many ndim there are\n            shape = [\n                read_int(f)\n                for i in range(max(ndim, 3))\n            ]   \n            # But in case ndims < 3, take at most n_dim elements\n            shape = shape[:ndim]\n            print('shape', shape)\n    \n            # Now load the actual data!\n            loaded_data[(dataset, filetype)] = np.fromfile(\n                f, \n                dtype=data_type, \n                count=np.prod(shape)\n            ).reshape(shape)\n            \nimages  = loaded_data[('train', 'dat')]","1c31b4bf":"plt.rcParams['figure.figsize'] = [12, 12]\nV_IMS = 4\ndef showRow( row_num, pic_list ):\n    for i,p in enumerate(pic_list) :\n        plt.subplot(V_IMS, len(pic_list),  i+ 1+ row_num*len(pic_list) )\n        plt.imshow( p )\n\ndef img_2to3( image2 ):\n    return np.moveaxis ( np.concatenate( (image2, image2[0:1]) ), 0, -1 )        ","3b809e31":"# OpenCV magic\ndef cart_and_polar_flow( image, tuner ):\n    flow = cv.calcOpticalFlowFarneback( image[0], image[1], *tuner )\n    mag, ang = cv.cartToPolar(flow[..., 0], flow[..., 1])\n    hsv         = np.zeros( flow[..., 0].shape + (3,) )\n    hsv [..., 0] = ang*180\/np.pi\/2\n    hsv [..., 1] = 255\n    hsv [..., 2] = cv.normalize(mag, None, 0, 255, cv.NORM_MINMAX)\n    \n    # normalizing of displacement\n    mx = max( flow.max(), -flow.min() )\n    n_flow = np.uint8((flow +mx) \/ mx *127 )\n    \n    polar  = cv.cvtColor( np.uint8(hsv ), cv.COLOR_HSV2BGR)\n    return (np. moveaxis ( n_flow, -1, 0 ), np. moveaxis ( polar, -1, 0 ))","b0b66f03":"for img in range (V_IMS):\n\n    # Better region handling, look at plane's wings\n    config_smooth = (None, 0.5, 3,  25,  3, 5, 1.0, cv.OPTFLOW_FARNEBACK_GAUSSIAN )\n    (flow_1, bgr_1) = cart_and_polar_flow( images[img], config_smooth )\n    \n    # Better detail\n    config_sharp = (None, None, 1,  10,  3, 5, 1.1, 0 )\n    (flow_2, bgr_2) = cart_and_polar_flow( images[img], config_sharp )\n\n    showRow( img, ( img_2to3(images[img]), np. moveaxis ( bgr_1, 0, -1 ), img_2to3(flow_1), \n                                           np. moveaxis ( bgr_2, 0, -1 ), img_2to3(flow_2), ) )\nplt.show()","774e42a9":"import random\n# OpenCV magic\ndef sparse_flow( image, ):\n    feature_params = dict( maxCorners = 100,\n                           qualityLevel = 0.01,\n                           minDistance = 3,\n                           blockSize = 3 )\n    # Parameters for lucas kanade optical flow\n    lk_params = dict( winSize  = (15, 15),\n                      maxLevel = 4,\n                      criteria = (cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, 10, 0.03))\n    color = np.random.randint(0, 255, (100, 3))\n    p0 = cv.goodFeaturesToTrack(image[0], mask = None, **feature_params)\n    \n    image3 = np.moveaxis ( np.concatenate( (image, image[0:1]) ), 0, -1 ).copy()\n    mask = np.zeros_like(image3)\n    \n    p1, st, err =  cv.calcOpticalFlowPyrLK( image[0], image[1], p0, None, **lk_params  )\n    # Select good points\n    if p1 is not None:\n        good_new = p1[st==1]\n        good_old = p0[st==1]\n    # draw the tracks\n    for i, (new, old) in enumerate(zip(good_new, good_old)):\n        a, b = new.ravel()\n        c, d = old.ravel()\n        mask = cv.line(np.zeros_like(image3), \n                       (int(a), int(b)), (int(c), int(d)), color[i].tolist(), 2)\n        image3 = cv.circle(image3, (int(a), int(b)), 1, color[i].tolist(), -1)\n        image3 = cv.add(image3, mask)\n    return np.uint8(image3)\n\n    \ndef augment( image ):\n    cols,rows = image[1].shape\n    M = np.float32([[1,0,random.randint(-15,15)],[0,1,random.randint(-15,15)]])\n    image[1] = cv.warpAffine( image[1], M, (rows,cols) )\n    return image","3bdcbf25":"for img in range (V_IMS):\n    flow_1 = sparse_flow(          images[img],          )\n    flow_2 = sparse_flow( augment( images[img].copy() ), )\n    showRow( img, ( img_2to3(images[img]), flow_1, flow_2 ) )\nplt.show()","5f2a7c3a":"for img in range (V_IMS):\n    imgL = np.uint8(images[img][0])\n    imgR = np.uint8(images[img][1])\n    stereo_1 = cv.StereoBM_create(numDisparities=16, blockSize=9)\n    disparity_1 = stereo_1.compute(imgL,imgR)\n    stereo_2 = cv.StereoSGBM_create( blockSize=5, P1 = 50, P2=100 )\n    disparity_2 = stereo_2.compute(imgL,imgR)\n    showRow( img, ( img_2to3(images[img]), disparity_1, disparity_2 ) )\nplt.show()","4766388e":"## Trying sparse, not very impressive because of low displacement","04a1e92a":"#### Show Picture Utility","b67218e5":"Loading dataset, notebook with just small_NORB loading:\nhttps:\/\/www.kaggle.com\/leshabirukov\/small-norb-load\/notebook","9569ba01":"### View result\nColumns:\n1. 'stereo' image, green zones means right channel brighter then left one\n2. Algorithm settings I\n  1. 'polar' view: intensity is displacement, hue is direction\n  2. 'cartesian' view: green shift means X shift, purple - Y shift\n3. Algorithm settings II","6eccc315":"# Dense Optical Flow with Farneback algorithm\ncv2.optflow contains several more optical flow methods, but cv2.optflow is not preinstalled here, whetever, Farneback is good.","7202347a":"### Try Depth Map with StereoMatcher\nnot very satisfying\n\nColumns:\n1. 'stereo' image, green zones means right channel brighter then left one\n2. disparity map by StereoBM algorithm\n3. disparity map by StereoSGBM algorithm","d241d55f":"# Taking optical flow with OpenCV on small NORB dataset stereo Images\n### Material used\nhttps:\/\/docs.opencv.org\/3.4\/d4\/dee\/tutorial_optical_flow.html\n\nhttps:\/\/learnopencv.com\/optical-flow-in-opencv\/\n\nhttps:\/\/docs.opencv.org\/4.x\/dd\/d53\/tutorial_py_depthmap.html\n\nSmall NORB is a stereo images dataset. First interesting thing one can do with stereo is finding difference between channels, that is, optical flow computation, second one, is finding disparancy map. OpenCV library have functions for that, and I tried them in this notebook. The result is ambiguous, may be the dataset is tough\u0431 or I simply failed to find suitable parameters. Later I plan to solve optical flow with DL, may be using OpenCV functions output for training.","235d5c6f":"### View result\nColumns:\n1. 'stereo' image, green zones means right channel brighter then left one\n2. processed As is\n3. adding random translation"}}