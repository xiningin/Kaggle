{"cell_type":{"fb4095c2":"code","63980020":"code","eb727c7a":"markdown"},"source":{"fb4095c2":"from queue import *\nclass Node:\n    \n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\n    \n    def insert(self, data):\n        if (self.data):\n            if (data < self.data):\n                if (self.left is None):\n                    self.left = Node(data)\n                else:\n                    self.left.insert(data)\n            elif (data > self.data):\n                if (self.right is None):\n                    self.right = Node(data)\n                else:\n                    self.right.insert(data)\n        else:\n            self.data = data\n            \n    def inorder(self):\n        nodelist = []\n        if self.left:\n            nodelist += self.left.inorder()\n            \n        nodelist.append(self.data)\n\n        if self.right:\n            nodelist += self.right.inorder()\n            \n        return nodelist\n    \n    def preorder(self):\n        nodelist = []\n        nodelist.append(self.data)\n        \n        if self.left:\n            nodelist += self.left.preorder()\n            \n\n        if self.right:\n            nodelist += self.right.preorder()\n            \n        return nodelist\n    \n    def postorder(self):\n        nodelist = []\n        \n        if self.left:\n            nodelist += self.left.postorder()\n            \n\n        if self.right:\n            nodelist += self.right.postorder()\n            \n        nodelist.append(self.data)\n            \n        return nodelist\n\n\n    def minimum(n):\n        curr = n\n        \n        while(curr.left != None):\n            curr = curr.left\n            \n        return curr.data\n    \n    def minimum_n(n):\n        curr = n\n        \n        while(curr.left != None):\n            curr = curr.left\n            \n        return curr\n    \n    def maximum(n):\n        curr = n\n        \n        while(curr.right != None):\n            curr = curr.right\n            \n        return curr.data\n        \n        \n    def breadth_search(self):\n\n        temp = []\n        queue = Queue()\n        queue.put(self)\n        \n        while not queue.empty():\n            self = queue.get()\n            temp.append(self.data)\n            \n            if self.left:\n                queue.put(self.left)\n                \n            if self.right:\n                queue.put(self.right)\n        \n        return temp\n        \n        \n    def find_value(self, val):\n        \n        if self.data == val or self.data is None:\n            return True\n    \n        if self.data > val:\n            return self.left.find_value(val)\n            \n        if self.data < val:\n            return self.right.find_value(val)\n        \n    def delete_node(self, val):\n        if self is None:\n            return None\n        \n        if self.left and self.data > val:\n            self.left = self.left.delete_node(val)\n            \n        if self.right and self.data < val:\n            self.right = self.right.delete_node(val)\n            \n        else:\n            # one or zero child\n            if self.left == None:\n                rep = self.right\n                self = None\n                return rep\n            \n            elif self.right == None:\n                rep = self.left\n                self = None\n                return rep\n            \n            # two child nodes\n            \n            rep = self.right.minimum_n()\n            self.data = rep.data\n            \n            self.right = self.right.delete_node(rep.data)\n                \n        return self    \n            \n        \n\ndef build_tree(elements):\n    root = Node(elements[0])\n    for i in range(1, len(elements)):\n        root.insert(elements[i])\n    \n    return root","63980020":"numbers = [15,12,7,14,27,20,23,89]\n\nnumbers_tree = build_tree(numbers)\n\ninorder_trav = numbers_tree.inorder()\nprint(\"In-order:\")\nprint(inorder_trav)\n\npreorder_trav = numbers_tree.preorder()\nprint(\"Pre-order:\")\nprint(preorder_trav)\n\npostorder_trav = numbers_tree.postorder()\nprint(\"Post-order:\")\nprint(postorder_trav)\n\nminimum_val = numbers_tree.minimum()\nprint(\"Minimum value:\")\nprint(minimum_val)\n\n\nmaximum_val = numbers_tree.maximum()\nprint(\"Maximum value:\")\nprint(maximum_val)\n\nbreadth = numbers_tree.breadth_search()\nprint(\"Breadth search:\")\nprint(breadth)\n\nprint(\"\\nSearch 7\")\nprint(numbers_tree.find_value(7))\n\nprint(\"Delete 27\")\nnumbers_tree.delete_node(27)\n\nbreadth = numbers_tree.breadth_search()\nprint(\"Breadth search:\")\nprint(breadth)","eb727c7a":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session"}}