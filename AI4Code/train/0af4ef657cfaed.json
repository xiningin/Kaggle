{"cell_type":{"85dfa4e0":"code","09181a20":"code","e8519b5c":"code","e0b2e1ce":"code","d99cacf5":"code","23d580b0":"code","9f658614":"code","3d7b1ab0":"code","9d63869d":"code","f84be756":"code","55124bbf":"code","ac0b98aa":"code","96643afe":"code","314a9b9b":"code","56004bf4":"code","79380ea4":"code","082cf51d":"code","44072b29":"code","82258cb5":"code","11af63cd":"markdown","b7713548":"markdown","04fa145d":"markdown","5d99ddc8":"markdown","9c4aa84b":"markdown","d8fbe198":"markdown","79930a48":"markdown"},"source":{"85dfa4e0":"# importation des librairies\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# lecture du fichier contenant les anomalies de temp\u00e9ratures (origine : Universit\u00e9 de Berkeley)\nfile = '..\/input\/estimated-global-landsurface-temperature-average\/Complete_TAVG_summary.txt'\ndata = np.loadtxt(file, skiprows=22, usecols=(0, 1, 2))\n\n# d\u00e9finition des variables n\u00e9cessaires au calcul d'inversion\nt = data[:, 0] # premi\u00e8re colonne = les ann\u00e9es\ntemp = data[:, 1] # deuxi\u00e8me colonne = la valeur de l'anomalie de temp\u00e9rature en \u00b0C\nunc = data[:,2] # incertitude sur le calcul des anomalies (intervalle de confiance 95%) en \u00b0C\n\n#M\u00e9thode des moindres carr\u00e9s\n# d\u00e9finition de la matrice \"donn\u00e9es\" \nd = temp.T\n\n# d\u00e9finition de la matrice \"loi physique\"  \nG = np.vstack([t, np.ones(t.size)]).T\n\n# r\u00e9solution par m\u00e9thode des moindres carr\u00e9s\nm = np.linalg.lstsq(G, d, rcond=None)\n\n# d\u00e9finition du r\u00e9sidu\nres = m[1][0]\n\n# d\u00e9finiton du r\u00e9sidu pond\u00e9r\u00e9 par le nombre de points n\nres_w = res\/140\n\n# d\u00e9finition des param\u00e8tres (a et b) optimaux issu de l'inversion\na_opt, b_opt = m[0]\n#Affichage de la s\u00e9rie temporelle\nplt.figure(figsize=(15, 8))\nplt.plot(t, a_opt * t + b_opt, 'r', label='Mod\u00e8le')  # droite de r\u00e9gression \/ mod\u00e8le ajust\u00e9\nplt.errorbar(t, temp, yerr=unc) \nplt.ylabel(\"Anomalie de temp\u00e9rature (\u00b0C)\")\nplt.xlabel('Ann\u00e9e')\nplt.title(\"Anomalie de temp\u00e9rature annuelle moyenne sur la surface des continents\")\nplt.legend()\nplt.show()\n\nprint(\"Valeur de a:\", a_opt)\nprint(\"Valeur de b:\", b_opt)\nprint(\"Valeur du r\u00e9sidu:\", res)\nprint(\"Valeur du r\u00e9sidu pond\u00e9r\u00e9:\", res_w)","09181a20":"#Diff\u00e9rence entre l'anomalie de temp\u00e9rature moyenne annuelle et le mod\u00e8le \ne = temp - (a_opt * t + b_opt)\n#Affichage de la s\u00e9rie temporelle\nplt.figure(figsize=(15, 8))\nplt.plot(t, a_opt * t + b_opt, 'r', label='Mod\u00e8le')  # droite de r\u00e9gression \/ mod\u00e8le ajust\u00e9\nplt.plot(t, e, 'g', label='Diff\u00e9rence entre l anomalie de temp\u00e9rature moyenne annuelle et le mod\u00e8le')\nplt.errorbar(t, temp, yerr=unc) \nplt.ylabel(\"Anomalie de temp\u00e9rature (\u00b0C)\")\nplt.xlabel('Ann\u00e9e')\nplt.title(\"Anomalie de temp\u00e9rature annuelle moyenne sur la surface des continents\")\nplt.legend()\nplt.show()","e8519b5c":"#M\u00e9thode des moindres carr\u00e9s avec deux tendances\nt1 = data[1:97,0]\nt2 = data[97:140,0]\ntemp1= data[1:97,1]\ntemp2= data[97:140,1]\n\n# d\u00e9finition de la matrice \"donn\u00e9es\" \nd1 = temp1.T\nd2 = temp2.T\n# d\u00e9finition de la matrice \"loi physique\"  \nG1 = np.vstack([t1, np.ones(t1.size)]).T\nG2 = np.vstack([t2, np.ones(t2.size)]).T\n# r\u00e9solution par m\u00e9thode des moindres carr\u00e9s\nm1 = np.linalg.lstsq(G1, d1, rcond=None)\nm2 = np.linalg.lstsq(G2, d2, rcond=None)\n# d\u00e9finition des param\u00e8tres (a et b) optimaux issu de l'inversion\na_opt1, b_opt1 = m1[0]\na_opt2, b_opt2 = m2[0]\n#Affichage de la s\u00e9rie temporelle\nplt.figure(figsize=(15, 8))\nplt.plot(t1, a_opt1 * t1 + b_opt1, 'r', label='Mod\u00e8le 1')  # droite de r\u00e9gression \/ mod\u00e8le ajust\u00e9\nplt.plot(t2, a_opt2 * t2 + b_opt2, 'g', label='Mod\u00e8le 2')\nplt.errorbar(t, temp, yerr=unc) \nplt.ylabel(\"Anomalie de temp\u00e9rature (\u00b0C)\")\nplt.xlabel('Ann\u00e9e')\nplt.title(\"Anomalie de temp\u00e9rature annuelle moyenne sur la surface des continents\")\nplt.legend()\nplt.show()\nprint(\"Valeur moyenne de a_opt1:\",a_opt1,\"Valeur moyenne de b_opt1:\",b_opt1)\nprint(\"Valeur moyenne de a_opt2:\",a_opt2,\"Valeur moyenne de b_opt2:\",b_opt2)","e0b2e1ce":"#MCMC\n# **************\n# * Param\u00e8tres *\n# **************\n\nt1 = data[0:97,0]\nt2 = data[97:140,0]\ntemp1= data[0:97,1]\ntemp2= data[97:140,1]\nunc1 = data[0:97,2]\nunc2 = data[97:140,2]\nprint(np.std(temp1))\nprint(np.std(temp2))\n\nn1= len(temp1)\nn2= len(temp2)\nprint(len(temp1),len(temp2))\n\nx1 = np.linspace(1,97,97)\nx2 = np.linspace(97, 140, 43)\n\n#x1 = np.linspace(0,84,84)\n#x2 = np.linspace(1964,2019)\n\nnp.random.seed(456)\n#np.random.seed(123)","d99cacf5":"# *************\n# * Fonctions * pourla premi\u00e8re tendance\n# *************\ndef droite(x1, a, b):\n    return a * x1 + b\n\n# fonction densit\u00e9 de probabilit\u00e9\ndef L(temp1, yfit, n1, unc1):\n    return np.exp( -(1\/n1) * np.sum(((temp1 - yfit) \/ unc1 ) ** 2) )\n\n# fonction r\u00e9sidu\ndef res(temp1, yfit, n1, unc1):\n    return (1\/n1) * np.sum(((temp1 - yfit) \/ unc1 ) ** 2)","23d580b0":"# information a priori sur a :\na_inf = 0\na_sup = 0.01\n\n# information a priori sur b :\nb_inf =  -1\nb_sup =  -0.3","9f658614":"# initialisation de l'inversion \n\n# a) d\u00e9finition du mod\u00e8le initial\n# La fonction random.uniform g\u00e9n\u00e9re al\u00e9atoirement un nombre compris (par d\u00e9faut) entre 0 (inclus) et 1 (exclu). Toutes \n# les valeurs \u00e0 l'int\u00e9rieur de l'intervalle ont la m\u00eame probabilit\u00e9 d'\u00eatre tir\u00e9es au sort.\n\n# param\u00e8tre a0 du mod\u00e8le initial\na_0 = a_inf + np.random.uniform() * (a_sup - a_inf)\n\n# param\u00e8tre b0 du mod\u00e8le initial\nb_0 = b_inf + np.random.uniform() * (b_sup - b_inf)\n\n# b) Calcul de la fonction de densit\u00e9 de probabilit\u00e9 associ\u00e9e\n\n# calcul du mod\u00e8le initial (=y_0) \u00e0 partir de l'\u00e9quation y = ax + b avec les param\u00e8tres a_0 et b_0\ny_0 = droite(x1, a_0, b_0)\nL_0 = L(temp1, y_0, n1, unc1)\nprint(a_0, b_0, L_0)","3d7b1ab0":"# cr\u00e9ation de la liste qui contiendra toutes les valeurs des param\u00e8tres test\u00e9s\nparam_opt1 = list()\n\n# nombre d'it\u00e9ration \nn_iter = int(2e6)\n\n# on se d\u00e9place dans l'espace des param\u00e8tres en perturbant le mod\u00e8le initial ant\u00e9rieur \nfor i in range(n_iter):\n\n    # Param\u00e9trisation de la perturbation des param\u00e8tres a et b:\n    pas_perturbation = 0.1\n    delta_a = pas_perturbation * (a_sup + a_inf ) \/ 2\n    delta_b = pas_perturbation * (b_sup + b_inf ) \/ 2\n\n    # on cr\u00e9e un nouveau mod\u00e8le y_p avec les param\u00e8tres a_p et b_p\n    # ces param\u00e8tres sont obtenus par perturbation du mod\u00e8le initial ant\u00e9rieur d\u00e9fini par les param\u00e8tres a_0 et b_0\n    a_p = a_0 + np.random.uniform(-1, 1) * delta_a\n    b_p = b_0 + np.random.uniform(-1, 1) * delta_b\n    y_p = droite(x1, a_p, b_p)\n\n    # on calcule la densit\u00e9 de probabilit\u00e9 du nouveau mod\u00e8le\n    L_p = L(temp1, y_p, n1, unc1)\n    # on calcul la valeur du r\u00e9sidu du nouveau mod\u00e8le\n    res_p = res(temp1, y_p, n1, unc1)\n    # on stocke la valeur des param\u00e8tres, la valeur de la densit\u00e9 de probabilit\u00e9 et la valeur du r\u00e9sidu\n    param_opt1.append((a_p, b_p, L_p, res_p))\n\n    # on compare sa densit\u00e9 de probabilit\u00e9 \u00e0 celle du mod\u00e8le initial ant\u00e9rieur\n    # si L_p > L_0, le mod\u00e8le y_p devient le nouveau mod\u00e8le initial\n    # si L_p < L_0, le mod\u00e8le y_0 reste le mod\u00e8le initial\n    if L_p > L_0 or np.random.uniform() < L_p \/ L_0:\n        a_0 = a_p\n        b_0 = b_p\n        L_0 = L_p\n\n# on transforme la liste des param\u00e8tres test\u00e9s en matrice        \nparam_opt1= np.asarray(param_opt1)\n\n# d\u00e9finition des param\u00e8tres test\u00e9s et densit\u00e9 de probabilit\u00e9\/r\u00e9sidu associ\u00e9s\na_opt = param_opt1[:,0]\nb_opt= param_opt1[:,1]\nL_opt = param_opt1[:,2]\nL_opt_max = param_opt1[:,2].max()\nres_opt = param_opt1[:,3]\nres_opt_max = param_opt1[:,3].max()\n\n#on affiche la moyenne et l'\u00e9cart-type des param\u00e8tres test\u00e9s (=les meilleurs mod\u00e8les)\nprint(\"Valeur moyenne de a_opt:\", round(np.mean(a_opt),2))\nprint(\"Ecart-type de a_opt:\", round(np.std(a_opt),2))\nprint()\nprint(\"Valeur moyenne de b_opt:\", round(np.mean(b_opt),2))\nprint(\"Ecart-type de b_opt:\", round(np.std(b_opt),2))","9d63869d":"# distribution des valeurs des deux param\u00e8tres a_opt et b_opt obtenues au cours de l'inversion\nplt.figure(1)\nplt.hist(a_opt, 10, histtype='step', lw=3, label='a')\nplt.hist(b_opt, 10, histtype='step', lw=3, label='b')\nplt.xlabel('Valeurs des param\u00e8tres')\nplt.title('Distribution des param\u00e8tres test\u00e9s')\nplt.legend(loc='best')\nplt.show()\n\n# distribution de la valeurs du r\u00e9sidu des mod\u00e8les test\u00e9s\n# le r\u00e9sidu est pond\u00e9r\u00e9 par le r\u00e9sidu maximal obtenu dans l'inversion\nplt.figure(1)\nplt.hist(res_opt\/res_opt_max, 10, histtype='step', lw=3, label='r\u00e9sidu')\nplt.xlabel('Valeurs du r\u00e9sidu')\nplt.title('Distribution du r\u00e9sidu des mod\u00e8les test\u00e9s')\nplt.legend()\nplt.show()\n\n# distribution de la densit\u00e9 de probabilit\u00e9 dans l'espace des param\u00e8tres constitu\u00e9 par a et b\n# la densit\u00e9 de probabilit\u00e9 est pond\u00e9r\u00e9 par la densit\u00e9 de probabilit\u00e9 maximale obtenue dans l'inversion (= le meilleur mod\u00e8le)\nplt.figure(1)\nplt.scatter(a_opt, b_opt, s=L_opt\/L_opt_max, marker='^', c=L_opt\/L_opt_max)\nplt.xlabel('axe a')\nplt.ylabel('axe b')\nplt.title(\"Distribution de la densit\u00e9 de probabilit\u00e9 des mod\u00e8les test\u00e9s\")\nplt.colorbar(label='Densit\u00e9 de probabilit\u00e9')\nplt.show()","f84be756":"# d\u00e9finition de la fonction d'autocorr\u00e9lation\ndef acf(samples, lags):\n    corr = [1. if lag == 0 else np.corrcoef(samples[lag:], samples[:-lag])[0][1] for lag in range(lags)]\n    return np.array(corr)\n\n# fonction d'autocorr\u00e9lation des param\u00e8tres a et b\nplt.plot(acf(a_opt, lags=700), label='a') # modifier lags = pour trouver acf=0\nplt.plot(acf(b_opt, lags=500), label='b') # modifier lags = pour trouver acf=0\nplt.xlabel(\"Lag\")\nplt.ylabel('ACF')\nplt.title(\"ACF des param\u00e8tres a et b\")\nplt.grid()\nplt.legend()\nplt.show()\n# valeur du lag pour acf = 0 - utilis\u00e9e pour r\u00e9-\u00e9chantillonner\nlag=150 # modifier la valeur du lag \n\n# \u00e9volution de la valeur des param\u00e8tres a et b ind\u00e9pendants pendant l'inversion\nplt.figure(1)\nplt.plot(a_opt[::lag], 'r-', markersize=10) \nplt.plot(b_opt[::lag], 'b-', markersize=10) \nplt.xlabel(\"Nombre de valeurs ind\u00e9pendantes\")\nplt.ylabel('Valeurs des param\u00e8tres')\nplt.title(\"Valeurs des param\u00e8tres a et b ind\u00e9pendants durant l'inversion\")\nplt.show()\n","55124bbf":"# distribution des valeurs des deux param\u00e8tres a_opt et b_opt ind\u00e9pendants obtenues au cours de l'inversion\n# r\u00e9-\u00e9chantillonnage de a_opt et b_opt avec la valeur du lag\nplt.figure(1)\nplt.hist(a_opt[::lag], 10, histtype='step', lw=3, label='a')\nplt.hist(b_opt[::lag], 10, histtype='step', lw=3, label='b')\nplt.xlabel('Valeurs des param\u00e8tres')\nplt.title('Distribution des param\u00e8tres test\u00e9s et ind\u00e9pendants')\nplt.legend(loc='best')\nplt.show()\n\n# distribution de la densit\u00e9 de probabilit\u00e9 dans l'espace des param\u00e8tres ind\u00e9pendants constitu\u00e9 par a et b\n# la densit\u00e9 de probabilit\u00e9 est pond\u00e9r\u00e9 par la densit\u00e9 de probabilit\u00e9 maximale obtenue dans l'inversion (= le meilleur mod\u00e8le)\n# r\u00e9-\u00e9chantillonnage de a_opt et b_opt avec la valeur du lag\nplt.figure(1)\nplt.scatter(a_opt[::lag], b_opt[::lag], s=L_opt[::lag]\/L_opt_max, marker='^', c=L_opt[::lag]\/L_opt_max)\nplt.xlabel('axe a')\nplt.ylabel('axe b')\nplt.title(\"Distribution de la densit\u00e9 de probabilit\u00e9 des mod\u00e8les test\u00e9s et ind\u00e9pendants\")\nplt.colorbar(label='Densit\u00e9 de probabilit\u00e9')\nplt.show()\n\n#on affiche la moyenne et l'\u00e9cart-type des param\u00e8tres test\u00e9s (=les meilleurs mod\u00e8les) ind\u00e9pendants\n# r\u00e9-\u00e9chantillonnage de a_opt et b_opt avec la valeur du lag\nprint(\"Valeur moyenne de a_opt:\", round(np.mean(a_opt[::lag]),5))\nprint(\"Ecart-type de a_opt:\", round(np.std(a_opt[::lag]),5))\nprint()\nprint(\"Valeur moyenne de b_opt:\", round(np.mean(b_opt[::lag]),5))\nprint(\"Ecart-type de b_opt:\", round(np.std(b_opt[::lag]),5))","ac0b98aa":"# *************\n# * Fonctions * pour la deuxi\u00e8me tendance\n# *************\ndef droite(x2, a, b):\n    return a * x2 + b\n\n# fonction densit\u00e9 de probabilit\u00e9\ndef L(temp2, yfit, n2, unc2):\n    return np.exp( -(1\/n2) * np.sum(((temp2 - yfit) \/ unc2 ) ** 2) )\n\n# fonction r\u00e9sidu\ndef res(temp2, yfit, n2, unc2):\n    return (1\/n2) * np.sum(((temp2 - yfit) \/ unc2 ) ** 2)","96643afe":"# information a priori sur a :\na_inf = 0.02\na_sup = 0.05\n\n# information a priori sur b :\nb_inf = -2\nb_sup = -5","314a9b9b":"# a) d\u00e9finition du mod\u00e8le initial\n# La fonction random.uniform g\u00e9n\u00e9re al\u00e9atoirement un nombre compris (par d\u00e9faut) entre 0 (inclus) et 1 (exclu). Toutes \n# les valeurs \u00e0 l'int\u00e9rieur de l'intervalle ont la m\u00eame probabilit\u00e9 d'\u00eatre tir\u00e9es au sort.\n\n# param\u00e8tre a0 du mod\u00e8le initial\na_0 = a_inf + np.random.uniform() * (a_sup - a_inf)\n\n# param\u00e8tre b0 du mod\u00e8le initial\nb_0 = b_inf + np.random.uniform() * (b_sup - b_inf)\n\n# b) Calcul de la fonction de densit\u00e9 de probabilit\u00e9 associ\u00e9e\n\n# calcul du mod\u00e8le initial (=y_0) \u00e0 partir de l'\u00e9quation y = ax + b avec les param\u00e8tres a_0 et b_0\ny_0 = droite(x2, a_0, b_0)\nL_0 = L(temp2, y_0, n2, unc2)\nprint(a_0, b_0, L_0)","56004bf4":"# cr\u00e9ation de la liste qui contiendra toutes les valeurs des param\u00e8tres test\u00e9s\nparam_opt = list()\n\n# nombre d'it\u00e9ration \nn_iter = int(2e6)\n\n# on se d\u00e9place dans l'espace des param\u00e8tres en perturbant le mod\u00e8le initial ant\u00e9rieur \nfor i in range(n_iter):\n\n    # Param\u00e9trisation de la perturbation des param\u00e8tres a et b:\n    pas_perturbation = 0.2\n    delta_a = pas_perturbation * (a_sup + a_inf ) \/ 2\n    delta_b = pas_perturbation * (b_sup + b_inf ) \/ 2\n\n    # on cr\u00e9e un nouveau mod\u00e8le y_p avec les param\u00e8tres a_p et b_p\n    # ces param\u00e8tres sont obtenus par perturbation du mod\u00e8le initial ant\u00e9rieur d\u00e9fini par les param\u00e8tres a_0 et b_0\n    a_p = a_0 + np.random.uniform(-1, 1) * delta_a\n    b_p = b_0 + np.random.uniform(-1, 1) * delta_b\n    y_p = droite(x2, a_p, b_p)\n\n    # on calcule la densit\u00e9 de probabilit\u00e9 du nouveau mod\u00e8le\n    L_p = L(temp2, y_p, n2, unc2)\n    # on calcul la valeur du r\u00e9sidu du nouveau mod\u00e8le\n    res_p = res(temp2, y_p, n2, unc2)\n    # on stocke la valeur des param\u00e8tres, la valeur de la densit\u00e9 de probabilit\u00e9 et la valeur du r\u00e9sidu\n    param_opt.append((a_p, b_p, L_p, res_p))\n\n    # on compare sa densit\u00e9 de probabilit\u00e9 \u00e0 celle du mod\u00e8le initial ant\u00e9rieur\n    # si L_p > L_0, le mod\u00e8le y_p devient le nouveau mod\u00e8le initial\n    # si L_p < L_0, le mod\u00e8le y_0 reste le mod\u00e8le initial\n    if L_p > L_0 or np.random.uniform() < L_p \/ L_0:\n        a_0 = a_p\n        b_0 = b_p\n        L_0 = L_p\n\n# on transforme la liste des param\u00e8tres test\u00e9s en matrice        \nparam_opt = np.asarray(param_opt)\n\n# d\u00e9finition des param\u00e8tres test\u00e9s et densit\u00e9 de probabilit\u00e9\/r\u00e9sidu associ\u00e9s\na_opt2 = param_opt[:,0]\nb_opt2 = param_opt[:,1]\nL_opt = param_opt[:,2]\nL_opt_max = param_opt[:,2].max()\nres_opt = param_opt[:,3]\nres_opt_max = param_opt[:,3].max()\n\n#on affiche la moyenne et l'\u00e9cart-type des param\u00e8tres test\u00e9s (=les meilleurs mod\u00e8les)\nprint(\"Valeur moyenne de a_opt:\", round(np.mean(a_opt2),2))\nprint(\"Ecart-type de a_opt:\", round(np.std(a_opt2),2))\nprint()\nprint(\"Valeur moyenne de b_opt:\", round(np.mean(b_opt2),2))\nprint(\"Ecart-type de b_opt:\", round(np.std(b_opt2),2))  ","79380ea4":"# distribution des valeurs des deux param\u00e8tres a_opt et b_opt obtenues au cours de l'inversion\nplt.figure(1)\nplt.hist(a_opt2, 10, histtype='step', lw=3, label='a')\nplt.hist(b_opt2, 10, histtype='step', lw=3, label='b')\nplt.xlabel('Valeurs des param\u00e8tres')\nplt.title('Distribution des param\u00e8tres test\u00e9s')\nplt.legend(loc='best')\nplt.show()\n\n# distribution de la valeurs du r\u00e9sidu des mod\u00e8les test\u00e9s\n# le r\u00e9sidu est pond\u00e9r\u00e9 par le r\u00e9sidu maximal obtenu dans l'inversion\nplt.figure(1)\nplt.hist(res_opt\/res_opt_max, 10, histtype='step', lw=3, label='r\u00e9sidu')\nplt.xlabel('Valeurs du r\u00e9sidu')\nplt.title('Distribution du r\u00e9sidu des mod\u00e8les test\u00e9s')\nplt.legend()\nplt.show()\n\n# distribution de la densit\u00e9 de probabilit\u00e9 dans l'espace des param\u00e8tres constitu\u00e9 par a et b\n# la densit\u00e9 de probabilit\u00e9 est pond\u00e9r\u00e9 par la densit\u00e9 de probabilit\u00e9 maximale obtenue dans l'inversion (= le meilleur mod\u00e8le)\nplt.figure(1)\nplt.scatter(a_opt2, b_opt2, s=L_opt\/L_opt_max, marker='^', c=L_opt\/L_opt_max)\nplt.xlabel('axe a')\nplt.ylabel('axe b')\nplt.title(\"Distribution de la densit\u00e9 de probabilit\u00e9 des mod\u00e8les test\u00e9s\")\nplt.colorbar(label='Densit\u00e9 de probabilit\u00e9')\nplt.show()","082cf51d":"# d\u00e9finition de la fonction d'autocorr\u00e9lation\ndef acf(samples, lags):\n    corr = [1. if lag == 0 else np.corrcoef(samples[lag:], samples[:-lag])[0][1] for lag in range(lags)]\n    return np.array(corr)\n\n# fonction d'autocorr\u00e9lation des param\u00e8tres a et b\nplt.plot(acf(a_opt2, lags=1000), label='a') # modifier lags = pour trouver acf=0\nplt.plot(acf(b_opt2, lags=1000), label='b') # modifier lags = pour trouver acf=0\nplt.xlabel(\"Lag\")\nplt.ylabel('ACF')\nplt.title(\"ACF des param\u00e8tres a et b\")\nplt.grid()\nplt.legend()\nplt.show()\n# valeur du lag pour acf = 0 - utilis\u00e9e pour r\u00e9-\u00e9chantillonner\nlag=750 # modifier la valeur du lag \n\n# \u00e9volution de la valeur des param\u00e8tres a et b ind\u00e9pendants pendant l'inversion\nplt.figure(1)\nplt.plot(a_opt2[::lag], 'r-', markersize=10) \nplt.plot(b_opt2[::lag], 'b-', markersize=10) \nplt.xlabel(\"Nombre de valeurs ind\u00e9pendantes\")\nplt.ylabel('Valeurs des param\u00e8tres')\nplt.title(\"Valeurs des param\u00e8tres a et b ind\u00e9pendants durant l'inversion\")\nplt.show()\n","44072b29":"# distribution des valeurs des deux param\u00e8tres a_opt et b_opt ind\u00e9pendants obtenues au cours de l'inversion\n# r\u00e9-\u00e9chantillonnage de a_opt et b_opt avec la valeur du lag\nplt.figure(1)\nplt.hist(a_opt2[::lag], 10, histtype='step', lw=3, label='a')\nplt.hist(b_opt2[::lag], 10, histtype='step', lw=3, label='b')\nplt.xlabel('Valeurs des param\u00e8tres')\nplt.title('Distribution des param\u00e8tres test\u00e9s et ind\u00e9pendants')\nplt.legend(loc='best')\nplt.show()\n\n# distribution de la densit\u00e9 de probabilit\u00e9 dans l'espace des param\u00e8tres ind\u00e9pendants constitu\u00e9 par a et b\n# la densit\u00e9 de probabilit\u00e9 est pond\u00e9r\u00e9 par la densit\u00e9 de probabilit\u00e9 maximale obtenue dans l'inversion (= le meilleur mod\u00e8le)\n# r\u00e9-\u00e9chantillonnage de a_opt et b_opt avec la valeur du lag\nplt.figure(1)\nplt.scatter(a_opt2[::lag], b_opt2[::lag], s=L_opt[::lag]\/L_opt_max, marker='^', c=L_opt[::lag]\/L_opt_max)\nplt.xlabel('axe a')\nplt.ylabel('axe b')\nplt.title(\"Distribution de la densit\u00e9 de probabilit\u00e9 des mod\u00e8les test\u00e9s et ind\u00e9pendants\")\nplt.colorbar(label='Densit\u00e9 de probabilit\u00e9')\nplt.show()\n\n#on affiche la moyenne et l'\u00e9cart-type des param\u00e8tres test\u00e9s (=les meilleurs mod\u00e8les) ind\u00e9pendants\n# r\u00e9-\u00e9chantillonnage de a_opt et b_opt avec la valeur du lag\nprint(\"Valeur moyenne de a_opt:\", round(np.mean(a_opt2[::lag]),5))\nprint(\"Ecart-type de a_opt:\", round(np.std(a_opt2[::lag]),5))\nprint()\nprint(\"Valeur moyenne de b_opt:\", round(np.mean(b_opt2[::lag]),5))\nprint(\"Ecart-type de b_opt:\", round(np.std(b_opt2[::lag]),5)) ","82258cb5":"a1 = 0.00427\na2 = 0.02941\nb1 = -0.41285\nb2 = -2.82961\n\nplt.figure(figsize=(15, 8))\nplt.errorbar (t, temp, yerr=unc)\nplt.plot(t1, a1 * x1 + b1, label='Mod\u00e8le 1')\nplt.plot (t2, a2 * x2 + b2, label='Mod\u00e8le 2')\nplt.xlabel (\"Ann\u00e9e\")\nplt.ylabel (\"Anomalie de temp\u00e9rature (\u00b0C)\")\nplt.title (\"R\u00e9gressions lin\u00e9aires sur l'anomalie de temp\u00e9rature annuelle moyenne sur la surface des continents \")\nplt.legend()","11af63cd":"# 2. Mod\u00e8le et analyse de la s\u00e9rie temporelle : une tendance","b7713548":"# Probl\u00e8mes inverses : *Devoir maison \u00e0 rendre le vendredi 08 janvier 2021 (minuit)*\n\n# Mod\u00e8les et analyses de l'augmentation de la temp\u00e9rature globale au cours du temps\n# 1. Pr\u00e9sentation de l'\u00e9tude","04fa145d":"# 3. Mod\u00e8le et analyse de la s\u00e9rie temporelle : deux tendances","5d99ddc8":"1) Gr\u00e2ce \u00e0 la m\u00e9thode des moindres carr\u00e9s on obtient un model avec un co\u00e9ficient directeur de 0.01 ce qui correpsond a une augmentation d'environ 0.01 \u00b0C par an.","9c4aa84b":"2) Avec ce model on obtient un r\u00e9sidu de 7 et une r\u00e9sidu pond\u00e9re\u00e9 de 0.05 donc tr\u00e8s proche de 0, ce qui indique que le model semble bien s'appliquer aux donn\u00e9es. Mais si on soustrait le model aux donn\u00e9es on voit que les valeurs ne sont pas \u00e9galent \u00e0 0 mais tourne autour \u00e0 plus ou moins 0.5. Cela indique que ce model n'est pas adapt\u00e9.","d8fbe198":"3)En s\u00e9parant le jeu de donn\u00e9e en deux permet de mieux adapter les diff\u00e9rents mod\u00e8les. Pour cela 1977 s\u2019av\u00e9rer \u00eatre la meilleure ann\u00e9e pour s\u00e9parer les deux tendances graphiquement car on observe une nette augmentation des anomalies de temp\u00e9rature. Pour le 1 er mod\u00e8le on observe une augmentation de la temp\u00e9rature moyenne par de 0.004 \u00b0C par an. L\u2019\u00e9cart type obtenue est plut\u00f4t faible pour le coefficient directeur on peut donc dire qu\u2019il est statiquement fiable. Pour le deuxi\u00e8me mod\u00e8le l\u2019augmentation de la temp\u00e9rature est de l\u2019ordre du 0.029\u00b0C avec un \u00e9cart type plut\u00f4t faible. Pour le deuxi\u00e8me mod\u00e8le les valeurs de l\u2019\u00e9cart type sont l\u00e9g\u00e8rement plus \u00e9lever. De plus sur les nombreuses fois on les MCMC ont tourn\u00e9s c\u2019\u00e9tait les mod\u00e8le 2 qui varier le plus  et donc le moins fiable.","79930a48":"Cet exercice a pour objectif de mod\u00e9liser et d'analyser \u00e0 l'aide des **m\u00e9thodes d'inversion** pr\u00e9sent\u00e9es en cours **l'\u00e9volution de la temp\u00e9rature moyenne annuelle mesur\u00e9e \u00e0 la surface des continents entre 1880 et 2019**. Dans l'exercice, les temp\u00e9ratures sont exprim\u00e9es en Celsius et sont report\u00e9es sous forme d'anomalies relatives \u00e0 la moyenne des temp\u00e9ratures mesur\u00e9es \u00e0 la surface des continents entre janvier 1951 et d\u00e9cembre 1980.\n\nL'augmentation de la temp\u00e9rature \u00e0 la surface du globe depuis le 19\u00e8me si\u00e8cle fait consensus dans la communaut\u00e9 scientifique. **La difficult\u00e9 actuelle r\u00e9side dans la quantification de cette augmentation.** En effet, la valeur de l'augmentation d\u00e9pend fortement des intervalles de temps consid\u00e9r\u00e9s, comme le montre cet exercice. Celui-ci s'organise en trois parties :\n1. Dans un premier temps, vous estimerez **l'augmentation de l'anomalie de temp\u00e9rature par an** \u00e0 la surface des continents pour la **p\u00e9riode 1880-2019** en d\u00e9finissant la **droite y = ax + b** passant au plus pr\u00e8s de l'ensemble des points. Vous utiliserez la m\u00e9thode des **moindres carr\u00e9s**. \n2. Dans un deuxi\u00e8me temps, vous calculerez et tracerez la **diff\u00e9rence entre l'anomalie de temp\u00e9rature moyenne annuelle et le mod\u00e8le** obtenu dans la partie 1 (i.e. la droite)? Ce mod\u00e8le explique-t-il correctement selon vous **l'ensemble de la s\u00e9rie temporelle** (i.e. la p\u00e9riode 1880-2019)? Vous justifierez votre r\u00e9ponse.\n3. Les climatologues s'accordent sur le fait que l'anomalie de temp\u00e9rature moyenne annuelle pr\u00e9sente en r\u00e9alit\u00e9 **deux tendances** en fonction de l'intervalle de temps que nous consid\u00e9rons et non une seule. En s\u00e9parant la s\u00e9rie temporelle en deux parties, on peut d\u00e9finir ces deux tendances \u00e0 l'aide de **deux droites ind\u00e9pendantes**. En utilisant **la m\u00e9thode MCMC**, vous d\u00e9finirez **s\u00e9paremment** chacune de ces deux droites et trouverez **quelle combinaison de droites** explique au mieux l'ensemble des donn\u00e9es (i.e. la p\u00e9riode 1880-2019). De cette mani\u00e8re, vous estimerez **l'augmentation de l'anomalie de temp\u00e9rature par an** associ\u00e9e \u00e0 ces deux intervalles de temps et **l'ann\u00e9e \u00e0 partir de laquelle la tendance se modifie**. Votre r\u00e9sultat est-il coh\u00e9rent avec l'augmentation de la temp\u00e9rature totale enregistr\u00e9e ces 50 derni\u00e8res ann\u00e9es \u00e0 la surface de la Terre?\n\n**Important :** Pour chaque \u00e9tape, vous devez \u00e9crire le code associ\u00e9 en vous inspirant fortement des notebooks du cours, expliquer vos choix au cours de l'inversion (espace des param\u00e8tres, pond\u00e9ration, pas d'it\u00e9ration, nombre d'it\u00e9rations, lag, etc.), d\u00e9crire et discuter les r\u00e9sultats obtenus (param\u00e8tres (moyenne, \u00e9cart-type), valeur du r\u00e9sidu, etc.) \u00e0 l'aide de graphes et de textes. L'exercice est \u00e0 r\u00e9aliser sur ce notebook que vous partagerez une fois le travail termin\u00e9. Les donn\u00e9es sont directement lues par les premi\u00e8res lignes du code ci-dessous."}}