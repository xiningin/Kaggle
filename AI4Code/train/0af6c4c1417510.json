{"cell_type":{"b1ae9261":"code","369e863c":"code","44c9db13":"code","9487de65":"code","02146124":"code","32605c7a":"code","b7acdadd":"code","12d98e0d":"code","2d1e9001":"code","d969673e":"code","9d5e3f3b":"code","20194e35":"code","31eda1d5":"code","edc4fb90":"code","19021061":"code","2dde3b8e":"code","c99893f9":"markdown","4465a113":"markdown","462f9e98":"markdown"},"source":{"b1ae9261":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\n# for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#     for filename in filenames:\n#         print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","369e863c":"import cv2\nimport matplotlib.pyplot as plt\nimport shutil\n\ndef showme(frame,title=None):\n    #window_title = \"map\"\n    cv2.namedWindow(title, cv2.WINDOW_NORMAL) #open a window\n    cv2.imshow(title, frame)                  #show the image in that widow\n    cv2.waitKey(0)                            #wait for any key\n    cv2.destroyAllWindows()                   #close everything\n\ndef showplt(image, title=None, pltnative=False, custSize=[100,10]):\n    plt.figure(figsize = (custSize))\n    if pltnative: \n        plt.imshow(image)\n    else: \n        plt.imshow(image[...,::-1])\n    plt.title(title)\n    plt.xticks([]), plt.yticks([])  # to hide tick values on X and Y axis\n    plt.show()\n\n#\ndef warpImages(img1, img2, H):\n    rows1, cols1 = img1.shape[:2]\n    rows2, cols2 = img2.shape[:2]\n    \n    list_of_points_1 = np.float32([\n        [0,0], \n        [0,rows1],\n        [cols1,rows1], \n        [cols1,0]\n    ])\n    list_of_points_1 = list_of_points_1.reshape(-1,1,2)\n\n    temp_points = np.float32([\n        [0,0], \n        [0,rows2], \n        [cols2,rows2],\n        [cols2,0]\n    ])\n    temp_points = temp_points.reshape(-1,1,2)\n    \n    list_of_points_2 = cv2.perspectiveTransform(temp_points, H)\n    \n    list_of_points = np.concatenate((list_of_points_1, list_of_points_2), axis=0)\n    \n    ##Define boundaries:\n    [x_min, y_min] = np.int32(list_of_points.min(axis=0).ravel() - 0.5)\n    [x_max, y_max] = np.int32(list_of_points.max(axis=0).ravel() + 0.5)\n    \n    translation_dist = [-x_min,-y_min]\n    \n    H_translation = np.array([[1, 0, translation_dist[0]], [0, 1, translation_dist[1]], [0,0,1]])\n    \n    output_img = cv2.warpPerspective(img2, \n                                     H_translation.dot(H), \n                                     (x_max - x_min, y_max - y_min))\n    ## Paste the image:\n    output_img[translation_dist[1]:rows1+translation_dist[1], \n               translation_dist[0]:cols1+translation_dist[0]] = img1\n    \n    return output_img\n#\ndef warp(img1, img2, min_match_count = 10):\n    sift = cv2.SIFT_create()\n    \n    # Extract the keypoints and descriptors\n    keypoints1, descriptors1 = sift.detectAndCompute(img1, None)\n    keypoints2, descriptors2 = sift.detectAndCompute(img2, None)\n    \n    # Initialize parameters for Flann based matcher\n    FLANN_INDEX_KDTREE = 0\n    index_params = dict(algorithm = FLANN_INDEX_KDTREE, trees = 5)\n    search_params = dict(checks = 50)\n    \n    # Initialize the Flann based matcher object\n    flann = cv2.FlannBasedMatcher(index_params, search_params)\n    \n    # Compute the matches\n    matches = flann.knnMatch(descriptors1, descriptors2, k=2)\n    \n    # Store all the good matches as per Lowe's ratio test\n    good_matches = []\n    for m1,m2 in matches:\n        if m1.distance < 0.7*m2.distance:\n            good_matches.append(m1)\n            \n    if len(good_matches) > min_match_count:\n        src_pts = np.float32([ keypoints1[good_match.queryIdx].pt\n                              for good_match in good_matches ]).reshape(-1,1,2)\n        \n        dst_pts = np.float32([ keypoints2[good_match.trainIdx].pt \n                              for good_match in good_matches ]).reshape(-1,1,2)\n        \n        M, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)\n        result = warpImages(img2, img1, M)\n        return result\n        #cv2.imshow('Stitched output', result)\n        #cv2.waitKey()\n    else:\n        print (\"We don't have enough number of matches between the two images.\")\n        print (\"Found only \" + str(len(good_matches)) + \" matches.\")\n        print (\"We need at least \" + str(min_match_count) + \" matches.\")\n        \n\ndef stitch_image_in_directory(input_directory, output_directory):\n    for dirname, _, filenames in os.walk(input_directory):\n        filenames = sorted(filenames)\n        path_img1 = os.path.join(dirname, filenames[0])\n        print(dirname)       \n        print('Stitching in processing')\n        image_1  = cv2.imread(path_img1)\n        firstCollage = None\n        for n_number in range(1, len(filenames), 1):\n            if n_number == 1:\n                path_img2 = os.path.join(dirname, filenames[n_number ])\n#                 print(path_img2)\n                image_2  = cv2.imread(path_img2)\n                firstCollage = warp(image_1, image_2)\n            else:\n                path_img2 = os.path.join(dirname, filenames[n_number ])\n#                 print(path_img2)  \n                image_2  = cv2.imread(path_img2)\n                firstCollage = warp(firstCollage, image_2)\n        file_name = 'image_stitched_'+filenames[-1]\n        save_image(output_directory, file_name, firstCollage)\n        file_path = os.path.join(output_directory, file_name)\n        showplt(firstCollage)\n        print(file_path)       \n        print('Stitching in done')\n\ndef save_image(directory, file_name, image):\n    if not os.path.exists(directory):\n            os.makedirs(directory)\n    cv2.imwrite(directory+'\/'+file_name, image)\n\ndef pre_process_image(input_directory, output_directory, number=10):\n    if not os.path.exists(output_directory):\n        os.makedirs(output_directory)\n    for dirname, _, filenames in os.walk(input_directory):\n        filenames = sorted(filenames)\n        for n_number in range(0, len(filenames), number):\n            directory = output_directory+'\/'+str(n_number).zfill(4);\n            if not os.path.exists(directory):\n                os.makedirs(directory)\n            for n_2 in range(n_number, n_number+number, 1):\n                n_image = n_number+n_2\n                if len(filenames) <= n_image:\n                    break\n                path_img1 = os.path.join(dirname, filenames[n_image])\n                path_img2 = os.path.join(directory, filenames[n_image])\n                shutil.copy2(path_img1, path_img2)","44c9db13":"def pre_process_image(input_directory, output_directory, number=10):\n    index = 0\n    if not os.path.exists(output_directory):\n        os.makedirs(output_directory)\n    for dirname, _, filenames in os.walk(input_directory):\n        filenames = sorted(filenames)\n        for n_number in range(0, len(filenames), number):\n            index = index+1\n            directory = output_directory+'\/'+str(index).zfill(4);\n            if not os.path.exists(directory):\n                os.makedirs(directory)\n            for n_2 in range(n_number, n_number+number, 1):\n                n_image = n_2\n                if len(filenames) <= n_image:\n                    break\n                path_img1 = os.path.join(dirname, filenames[n_image])\n                path_img2 = os.path.join(directory, filenames[n_image])\n                shutil.copy2(path_img1, path_img2)","9487de65":"def save_image(directory, file_name, image):\n    if not os.path.exists(directory):\n            os.makedirs(directory)\n    cv2.imwrite(directory+'\/'+file_name, image)","02146124":"def stitch_image_in_a_directory(input_directory, output_directory):\n    for dirname, _, filenames in os.walk(input_directory):\n        filenames = sorted(filenames)\n        path_img1 = os.path.join(dirname, filenames[0])\n        print(dirname)       \n        print('Stitching in processing')\n        image_1  = cv2.imread(path_img1)\n        firstCollage = cv2.imread(path_img1)\n        for n_number in range(1, len(filenames), 1):\n            if n_number == 1:\n                path_img2 = os.path.join(dirname, filenames[n_number ])\n#                 print(path_img2)\n                image_2  = cv2.imread(path_img2)\n                firstCollage = warp(image_1, image_2)\n            else:\n                path_img2 = os.path.join(dirname, filenames[n_number ])\n#                 print(path_img2)  \n                image_2  = cv2.imread(path_img2)\n                firstCollage = warp(firstCollage, image_2)\n        file_name = 'image_stitched_'+filenames[-1]\n        save_image(output_directory, file_name, firstCollage)\n        file_path = os.path.join(output_directory, file_name)\n        showplt(firstCollage)\n        print(file_path)       \n        print('Stitching in done') ","32605c7a":"original = '\/kaggle\/input\/image-for-stitching\/images\/original'\npre_process = '\/kaggle\/output\/working\/pre_process'\nstitched = '\/kaggle\/output\/working\/stitched'","b7acdadd":"pre_process_0001 = pre_process+'\/pre_process_0001'\nstitched_0001 = stitched+'\/stitched_0001'\npre_process_image(original,pre_process_0001,5)","12d98e0d":"!ls '\/kaggle\/output\/working\/pre_process\/pre_process_0001\/0003'","2d1e9001":"for dirname, _, filenames in sorted(os.walk(pre_process_0001)):\n    if (os.path.isdir(dirname)== True) & (dirname != pre_process_0001):\n#         filenames = sorted(filenames)\n        stitch_image_in_a_directory(dirname,stitched_0001)","d969673e":"input_directory = '\/kaggle\/input\/image-for-stitching\/images\/original\/'\noutput_directory = '\/kaggle\/output\/working\/pre_process_0000'\npre_process_image(input_directory,output_directory,10)","9d5e3f3b":"!ls pre_process_0000","20194e35":"input_directory = '\/kaggle\/output\/working\/pre_process_0000'\noutput_directory = '\/kaggle\/output\/working\/stitched_0000'\nfor dirname, _, filenames in sorted(os.walk(input_directory)):\n    if (os.path.isdir(dirname)== True) & (dirname != input_directory):\n#         filenames = sorted(filenames)\n        stitch_image_in_directory(dirname,output_directory)\n","31eda1d5":"# input_directory = '\/kaggle\/output\/working\/stitched_0000'\n# output_directory = '\/kaggle\/output\/working\/pre_process_0001'\n# pre_process_image(input_directory,output_directory,10)","edc4fb90":"# input_directory = '\/kaggle\/output\/working\/pre_process_0001'\n# output_directory = '\/kaggle\/output\/working\/stitched_0001'\n# for dirname, _, filenames in sorted(os.walk(input_directory)):\n#     if (os.path.isdir(dirname)== True) & (dirname != input_directory):\n#         stitch_image_in_directory(dirname,output_directory)\n","19021061":"# input_directory = '\/kaggle\/output\/working\/stitched_0001'\n# output_directory = '\/kaggle\/output\/working\/pre_process_0002'\n# pre_process_image(input_directory,output_directory,10)","2dde3b8e":"# input_directory = '\/kaggle\/output\/working\/pre_process_0002'\n# output_directory = '\/kaggle\/output\/working\/stitched_0002'\n# for dirname, _, filenames in sorted(os.walk(input_directory)):\n#     if (os.path.isdir(dirname)== True) & (dirname != input_directory):\n#         stitch_image_in_directory(dirname,output_directory)\n","c99893f9":"# loop in directory and stitch it, and save to new directory","4465a113":"# seperate images to directory 10 images per directory","462f9e98":"## stitch_image_in_sub_directory(pre_process_0000,stitched_0000)"}}