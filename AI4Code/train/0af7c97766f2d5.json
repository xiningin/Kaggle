{"cell_type":{"15616640":"code","2de15572":"code","5e9d0c51":"code","eb6ea817":"code","39365e79":"code","5388ef82":"code","46e9691b":"code","4519ec94":"code","3969efcf":"code","db35c285":"code","cc4bccfa":"code","68991e3a":"code","9ecd2860":"code","122459f2":"code","485e7ee5":"code","7e443725":"code","5cf2149f":"code","2711643f":"code","8134a52d":"code","457266a1":"markdown","b419836f":"markdown","235c5116":"markdown","27ff0cd6":"markdown","64da8b19":"markdown"},"source":{"15616640":"!pip install ase==3.17 schnetpack","2de15572":"import numpy as np\nimport pandas as pd\nmolecules = pd.read_csv('..\/input\/structures.csv')\nmolecules = molecules.groupby('molecule_name')\nmulliken_charges = pd.read_csv('..\/input\/mulliken_charges.csv')\nmulliken_charges = mulliken_charges.groupby('molecule_name')","5e9d0c51":"mulliken_charges.get_group('dsgdb9nsd_000003')","eb6ea817":"mulliken_charges.get_group('dsgdb9nsd_000003').mulliken_charge.sum()","39365e79":"pd.read_csv('..\/input\/mulliken_charges.csv').mulliken_charge.describe()","5388ef82":"pd.read_csv('..\/input\/mulliken_charges.csv').mulliken_charge.hist(bins=50)","46e9691b":"from ase import Atoms\nfrom ase.db import connect\n\ndef create_db(db_path, molecule_names):\n    with connect(db_path) as db:\n        for name in molecule_names:\n            mol = molecules.get_group(name)\n            atoms = Atoms(symbols=mol.atom.values,\n                          positions=[(row.x,row.y,row.z) for row in mol.itertuples()])\n            try:\n                charges = mulliken_charges.get_group(name).mulliken_charge.values.reshape(-1,1)\n                total_charge = 0.0\n            except KeyError:\n                charges = None\n                total_charge = None\n            db.write(atoms, name=name,\n                     data={'mulliken_charges': charges, 'total_charge': total_charge})","4519ec94":"train = pd.read_csv('..\/input\/train.csv')\ntrain_molecule_names = train.molecule_name.unique()\n\nchamps_path = 'CHAMPS_train.db'\ndataset_size =  len(train_molecule_names) # 12000\ndataset_molecule_names = train_molecule_names[:dataset_size]\ncreate_db(db_path=champs_path, molecule_names=dataset_molecule_names)","3969efcf":"import schnetpack\ndatabase = schnetpack.data.AtomsData(champs_path,\n                properties=['mulliken_charges', 'total_charge'])","db35c285":"import pandas as pd\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.optim import Adam\n\nimport schnetpack as spk\nimport schnetpack.atomistic as atm\nimport schnetpack.representation as rep\nfrom schnetpack.datasets import *\n\ndevice = torch.device(\"cuda\")","cc4bccfa":"# This function comes from the following script:\n# https:\/\/github.com\/atomistic-machine-learning\/schnetpack\/blob\/v0.2.1\/src\/scripts\/schnetpack_qm9.py\ndef evaluate_dataset(metrics, model, loader, device):\n    for metric in metrics:\n        metric.reset()\n\n    with torch.no_grad():\n        for batch in loader:\n            batch = {\n                k: v.to(device)\n                for k, v in batch.items()\n            }\n            result = model(batch)\n\n            for metric in metrics:\n                metric.add_batch(batch, result)\n\n    results = [\n        metric.aggregate() for metric in metrics\n    ]\n    return results","68991e3a":"from schnetpack.data import Structure\n\nclass Mulliken(atm.Atomwise):\n    def __init__(self):\n        super(Mulliken, self).__init__(return_contributions=True)\n        \n    def forward(self, inputs):\n        result = super().forward(inputs)\n        \n        atom_mask = inputs[Structure.atom_mask].byte()\n        \n        yi = inputs['mulliken_charges']\n        yi = torch.masked_select(yi.squeeze(dim=2), atom_mask)\n        inputs['mulliken_true'] = yi\n        \n        yi = result['yi']\n        yi = torch.masked_select(yi.squeeze(dim=2), atom_mask)\n        result['mulliken_pred'] = yi\n        \n        return result\n        ","9ecd2860":"def schnet_model():\n    reps = rep.SchNet(n_interactions=6)\n    output = Mulliken()\n    model = atm.AtomisticModel(reps, output)\n    model = model.to(device)\n    return model","122459f2":"def train_model(max_epochs=500):\n    # split in train and val\n    n_dataset = len(database)\n    n_val = n_dataset \/\/ 10\n    train_data, val_data, test_data = database.create_splits(n_dataset - 2*n_val, n_val)\n    train_loader = spk.data.AtomsLoader(train_data, batch_size=128, num_workers=2)\n    val_loader = spk.data.AtomsLoader(val_data, batch_size=256, num_workers=2)\n\n    # create model\n    model = schnet_model()\n\n    # create trainer\n    true_key = 'mulliken_true'\n    pred_key = 'mulliken_pred'\n    opt = Adam(model.parameters(), lr=1e-4)\n    loss = lambda b, p: F.mse_loss(p[pred_key], b[true_key])\n    metrics = [\n        spk.metrics.MeanAbsoluteError(true_key, pred_key, name='MAE_mulliken'),\n        spk.metrics.RootMeanSquaredError(true_key, pred_key, name='RMSE_mulliken'),\n    ]\n    hooks = [\n        spk.train.MaxEpochHook(max_epochs),\n        spk.train.CSVHook('log', metrics, every_n_epochs=1),\n    ]\n    trainer = spk.train.Trainer('output', model, loss,\n                            opt, train_loader, val_loader, hooks=hooks)\n\n    # start training\n    trainer.train(device)\n    \n    # evaluation\n    model.load_state_dict(torch.load('output\/best_model'))\n    test_loader = spk.data.AtomsLoader(test_data, batch_size=256, num_workers=2)\n    model.eval()\n\n    df = pd.DataFrame()\n    df['metric'] = ['MAE_mulliken', 'RMSE_mulliken']\n    df['training'] = evaluate_dataset(metrics, model, train_loader, device)\n    df['validation'] = evaluate_dataset(metrics, model, val_loader, device)\n    df['test'] = evaluate_dataset(metrics, model, test_loader, device)\n    display(df)\n    \n    return test_data","485e7ee5":"def show_history():\n    df = pd.read_csv('log\/log.csv')\n    display(df.tail())\n    max_value = None # df['RMSE_mulliken'].min()*5\n    _ = df[['MAE_mulliken','RMSE_mulliken']].plot(ylim=(0,max_value))","7e443725":"def test_prediction(dataset):\n    # create model\n    model = schnet_model()\n    \n    # load best parameters\n    model.load_state_dict(torch.load('output\/best_model'))\n    loader = spk.data.AtomsLoader(dataset, batch_size=256, num_workers=2)\n    model.eval()\n    \n    # predict mulliken charges\n    targets = []\n    predictions = []\n    with torch.no_grad():\n        for batch in loader:\n            batch = {\n                k: v.to(device)\n                for k, v in batch.items()\n            }\n            result = model(batch)\n            targets += batch['mulliken_true'].tolist()\n            predictions += result['mulliken_pred'].tolist()\n    return targets, predictions","5cf2149f":"def show_predictions(dataset):\n    targets, predictions = test_prediction(dataset)\n    df_pred = pd.DataFrame()\n    df_pred['Target'] = targets\n    df_pred['Prediction'] = predictions\n    df_pred.plot.scatter(x='Target', y='Prediction')","2711643f":"used_test_data = train_model(max_epochs=200)\nshow_history()","8134a52d":"show_predictions(used_test_data)","457266a1":"# Results","b419836f":"We need `ASE 3.17` for `SchNetPack 0.2.1`.","235c5116":"# Mulliken Charges","27ff0cd6":"# SchNet Model","64da8b19":"This kernel presents how to predict mulliken charges using SchNetPack."}}