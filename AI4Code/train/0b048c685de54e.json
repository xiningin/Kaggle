{"cell_type":{"feecac4f":"code","3c0c6403":"code","a7905b01":"code","44cb358a":"code","023749da":"code","64f6029c":"code","fbc57c6a":"code","55a7debb":"code","12be2ebb":"code","02308d69":"code","a3923001":"code","37a591dc":"code","0f290504":"code","f1dacfa2":"code","0e06a676":"code","461d2671":"code","9597bd78":"code","b9fddf17":"code","38c716d7":"code","1007bbc8":"code","c9d97dd5":"code","7d9c66fe":"code","6dd974d9":"code","536e329c":"code","3418e2d1":"code","1c11af3c":"markdown","7ee305c7":"markdown","8e6dc59d":"markdown","e129e509":"markdown","15f0bb75":"markdown","bb7d4d0d":"markdown","22cfa8bb":"markdown","89782225":"markdown","817fc79f":"markdown","8c132dc4":"markdown","582e7e93":"markdown","f7adadcc":"markdown","1978ed67":"markdown","8c430eff":"markdown","c9a23678":"markdown","082b1b73":"markdown","17639f89":"markdown","154ac0a8":"markdown","637bcddb":"markdown","ebaf4546":"markdown","2cbdabce":"markdown","29e17325":"markdown","a12f2562":"markdown","4e49e160":"markdown","3e851096":"markdown","8365e666":"markdown","8176abc9":"markdown","de06087c":"markdown","fbcf1d31":"markdown","7087daeb":"markdown","dc176ce2":"markdown","b36dab45":"markdown","b287f162":"markdown","e97fc6e5":"markdown","d8ef0626":"markdown","6d2e895b":"markdown","6e8e8376":"markdown","0585099e":"markdown","f6a5eb57":"markdown","7468de95":"markdown","174c0207":"markdown","e592a64f":"markdown","b83fe3fa":"markdown","18c0941d":"markdown","cbf8183c":"markdown"},"source":{"feecac4f":"from IPython.display import Image\nImage(\"..\/input\/figuras\/Fro_Eff.png\")","3c0c6403":"Image(\"..\/input\/figuras\/Perfis_Port.png\")","a7905b01":"import pandas as pd  \nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.optimize as sco\nimport os as os\n# from matplotlib.pylab import rcParams\n# import seaborn as sns\nplt.style.use('fivethirtyeight')\n# rcParams['figure.figsize'] = 20, 8\nnp.random.seed(777)\n%matplotlib inline","44cb358a":"# path = \"X:\/Historico_Cotacoes\/teste\/alpha_data\/\"\nnomeArq = '..\/input\/portfolio-de-ativos-da-b3-bovespa\/alphacart12018.csv'\n#pwd = os.getcwd() # guarda o path corrente\n#os.chdir(os.path.dirname(path)) # muda para o path dos arquivos\n\ndateparse = lambda dates: pd.datetime.strptime(dates, '%Y-%m-%d')\ndata = pd.read_csv(nomeArq, parse_dates=[\"datetime\"], index_col=\"datetime\",date_parser=dateparse)","023749da":"data.info()","64f6029c":"## Definindo a data de inicio das observacoes, quando todos os ativos possuem dados\nstart_date = \"2013-01-02\"\nend_date = \"2018-12-31\"\ns = data.loc[start_date:end_date] \ndata = s.copy()","fbc57c6a":"df = data.reset_index()\ndf = df[['datetime', 'CODNEG', 'adj_close']]","55a7debb":"df.head()","12be2ebb":"df.info()","02308d69":"table = df.pivot_table(index = 'datetime', columns = 'CODNEG', values = 'adj_close')\ntable.columns.name=None","a3923001":"table.head()","37a591dc":"plt.figure(figsize=(20, 10))\nfor c in table.columns.values:\n    plt.plot(table.index, table[c], lw=3, alpha=0.8, label=c)\n    \nlegend = plt.legend(loc='upper left', fontsize=14)\nplt.setp(legend.get_texts(), color='k')   \n# plt.legend(loc='upper left', fontsize=14)\nplt.title('Evolu\u00e7\u00e3o D\u00e1ria dos Pre\u00e7os de cada Ativo do Portf\u00f3lio')\nplt.ylabel('precos em BRL');","0f290504":"returns = table.pct_change() ## retornos\n\nplt.figure(figsize=(18, 10))\nplt.setp(legend.get_texts(), color='k');\n\nfor c in returns.columns.values:\n    plt.plot(returns.index, returns[c], lw=3, alpha=0.8,label=c)\n    \nlegend = plt.legend(loc='best', fontsize=10)\n\n#plt.legend(loc='lower right', fontsize=10)\nplt.title('S\u00e9rie de Retornos Percentuais do Portf\u00f3lio')\nplt.ylabel('retornos diarios')\nplt.show();","f1dacfa2":"def portfolio_annualised_performance(weights, mean_returns, cov_matrix):\n    returns = np.sum(mean_returns*weights ) *252\n    std = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights))) * np.sqrt(252)\n    return std, returns\n\ndef random_portfolios(num_portfolios, mean_returns, cov_matrix, risk_free_rate):\n    dim_res = len(table.columns) ## cuidado para n\u00e3o renomear table\n    results = np.zeros((dim_res,num_portfolios)) ## \n    weights_record = []\n    for i in range(num_portfolios):\n        weights = np.random.random(dim_res)\n        weights \/= np.sum(weights)\n        weights_record.append(weights)\n        portfolio_std_dev, portfolio_return = portfolio_annualised_performance(weights, \\\n                                              mean_returns, cov_matrix)\n        results[0,i] = portfolio_std_dev\n        results[1,i] = portfolio_return\n        results[2,i] = (portfolio_return - risk_free_rate) \/ portfolio_std_dev\n    return results, weights_record","0e06a676":"returns = table.pct_change()\nmean_returns = returns.mean()\ncov_matrix = returns.cov()\nnum_portfolios = 25000\nrisk_free_rate = 0.0345","461d2671":"def display_simulated_ef_with_random(mean_returns, cov_matrix, num_portfolios, risk_free_rate):\n    results, weights = random_portfolios(num_portfolios,mean_returns, cov_matrix, risk_free_rate)\n    \n    max_sharpe_idx = np.argmax(results[2])\n    sdp, rp = results[0,max_sharpe_idx], results[1,max_sharpe_idx]\n    max_sharpe_allocation = pd.DataFrame(weights[max_sharpe_idx],index=table.columns,columns=['allocation'])\n    max_sharpe_allocation.allocation = [round(i*100,2)for i in max_sharpe_allocation.allocation]\n    max_sharpe_allocation = max_sharpe_allocation.T\n    \n    min_vol_idx = np.argmin(results[0])\n    sdp_min, rp_min = results[0,min_vol_idx], results[1,min_vol_idx]\n    min_vol_allocation = pd.DataFrame(weights[min_vol_idx],index=table.columns,columns=['allocation'])\n    min_vol_allocation.allocation = [round(i*100,2)for i in min_vol_allocation.allocation]\n    min_vol_allocation = min_vol_allocation.T\n    \n    print (\"-\"*80)\n    print (\"Alocacao da Carteira pelo Indice de Sharpe Maximo\\n\")\n    print (\"Retorno Anualizado:\", round(rp,2))\n    print (\"Volatilidade Anualizada:\", round(sdp,2))\n    print (\"\\n\")\n    print (max_sharpe_allocation)\n    print (\"-\"*80)\n    print (\"Alocacao da Carteira pela Volatilidade Minima\\n\")\n    print (\"Retorno Anualizado:\", round(rp_min,2))\n    print (\"Volatilidade Anualizada:\", round(sdp_min,2))\n    print (\"\\n\")\n    print (min_vol_allocation)\n\n    plt.figure(figsize=(12, 7))\n    plt.scatter(results[0,:],results[1,:],c=results[2,:],cmap='YlGnBu', marker='o', s=10, alpha=0.3)\n    plt.colorbar()\n    plt.scatter(sdp,rp,marker='*',color='r',s=500, label='Indice de Sharpe Maximo')\n    plt.scatter(sdp_min,rp_min,marker='*',color='g',s=500, label='Volatilidade Minima')\n    \n    plt.title('Simulacao de Portfolio Optimizado com base na Fronteira de Eficiencia')\n    plt.xlabel('volatilidade anualizada')\n    plt.ylabel('retornos anualizados')\n    plt.legend(labelspacing=0.8)","9597bd78":"display_simulated_ef_with_random(mean_returns, cov_matrix, num_portfolios, risk_free_rate)","b9fddf17":"constraints = ({'type': 'eq', 'fun': lambda x:np.sum(x) -1})","38c716d7":"def neg_sharpe_ratio(weights, mean_returns, cov_matrix, risk_free_rate):\n    p_var, p_ret = portfolio_annualised_performance(weights, mean_returns, cov_matrix)\n    return -(p_ret - risk_free_rate) \/ p_var\n\ndef max_sharpe_ratio(mean_returns, cov_matrix, risk_free_rate):\n    num_assets = len(mean_returns)\n    args = (mean_returns, cov_matrix, risk_free_rate)\n    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})\n    bound = (0.0,1.0)\n    bounds = tuple(bound for asset in range(num_assets))\n    result = sco.minimize(neg_sharpe_ratio, num_assets * [1.\/num_assets,], args=args, method='SLSQP', bounds=bounds, constraints=constraints)\n    return result","1007bbc8":"def portfolio_volatility(weights, mean_returns, cov_matrix):\n    return portfolio_annualised_performance(weights, mean_returns, cov_matrix)[0]\n\ndef min_variance(mean_returns, cov_matrix):\n    num_assets = len(mean_returns)\n    args = (mean_returns, cov_matrix)\n    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})\n    bound = (0.0,1.0)\n    bounds = tuple(bound for asset in range(num_assets))\n    result = sco.minimize(portfolio_volatility, num_assets*[1.\/num_assets,], args=args, method='SLSQP', bounds=bounds, constraints=constraints)\n    return result","c9d97dd5":"def efficient_return(mean_returns, cov_matrix, target):\n    num_assets = len(mean_returns)\n    args = (mean_returns, cov_matrix)\n\n    def portfolio_return(weights):\n        return portfolio_annualised_performance(weights, mean_returns, cov_matrix)[1]\n    \n    constraints = ({'type': 'eq', 'fun': lambda x: portfolio_return(x) - target}, {'type': 'eq', 'fun': lambda x: np.sum(x) - 1})\n    bounds = tuple((0,1) for asset in range(num_assets))\n    result = sco.minimize(portfolio_volatility, num_assets*[1.\/num_assets,], args=args, method='SLSQP', bounds=bounds, constraints=constraints)\n    return result\n\ndef efficient_frontier(mean_returns, cov_matrix, returns_range):\n    efficients = []\n    for ret in returns_range:\n        efficients.append(efficient_return(mean_returns, cov_matrix, ret))\n    return efficients","7d9c66fe":"def display_calculated_ef_with_random(mean_returns, cov_matrix, num_portfolios, risk_free_rate):\n    results, _ = random_portfolios(num_portfolios,mean_returns, cov_matrix, risk_free_rate)\n    max_sharpe = max_sharpe_ratio(mean_returns, cov_matrix, risk_free_rate)\n    sdp, rp = portfolio_annualised_performance(max_sharpe['x'], mean_returns, cov_matrix)\n    max_sharpe_allocation = pd.DataFrame(max_sharpe.x,index=table.columns,columns=['allocation'])\n    max_sharpe_allocation.allocation = [round(i*100,2)for i in max_sharpe_allocation.allocation]\n    max_sharpe_allocation = max_sharpe_allocation.T\n\n    min_vol = min_variance(mean_returns, cov_matrix)\n    sdp_min, rp_min = portfolio_annualised_performance(min_vol['x'], mean_returns, cov_matrix)\n    min_vol_allocation = pd.DataFrame(min_vol.x,index=table.columns,columns=['allocation'])\n    min_vol_allocation.allocation = [round(i*100,2)for i in min_vol_allocation.allocation]\n    min_vol_allocation = min_vol_allocation.T\n\n    print (\"-\"*80)\n    print (\"Alocacao da Carteira pelo Indice de Sharpe Maximo\\n\")\n    print (\"Retorno Anualizado:\", round(rp,2))\n    print (\"Volatilidade Anualizada:\", round(sdp,2))\n    print (\"\\n\")\n    print (max_sharpe_allocation)\n    print (\"-\"*80)\n    print (\"Alocacao da Carteira pela Volatilidade Minima\\n\")\n    print (\"Retorno Anualizado:\", round(rp_min,2))\n    print (\"Volatilidade Anualizada:\", round(sdp_min,2))\n    print (\"\\n\")\n    print (min_vol_allocation)\n    \n    plt.figure(figsize=(12, 7))\n    plt.scatter(results[0,:],results[1,:],c=results[2,:],cmap='YlGnBu', marker='o', s=10, alpha=0.3)\n    plt.colorbar()\n    plt.scatter(sdp,rp,marker='*',color='r',s=500, label='Maximum Sharpe ratio')\n    plt.scatter(sdp_min,rp_min,marker='*',color='g',s=500, label='Minimum volatility')\n    target = np.linspace(rp_min, 0.28, 50)\n    \n    efficient_portfolios = efficient_frontier(mean_returns, cov_matrix, target)\n\n    plt.plot([p['fun'] for p in efficient_portfolios], target, linestyle='-.', color='black', label='efficient frontier')\n    plt.title('Otimiza\u00e7\u00e3o do Portfolio pelo M\u00e9todo da Fronteira Eficiente (Efficient Frontier)')\n    plt.xlabel('volatilidade anualizada')\n    plt.ylabel('retorno anualizado')\n    plt.legend(labelspacing=0.8)","6dd974d9":"display_calculated_ef_with_random(mean_returns, cov_matrix, num_portfolios, risk_free_rate)","536e329c":"def display_ef_with_selected(mean_returns, cov_matrix, risk_free_rate):\n    max_sharpe = max_sharpe_ratio(mean_returns, cov_matrix, risk_free_rate)\n    sdp, rp = portfolio_annualised_performance(max_sharpe['x'], mean_returns, cov_matrix)\n    max_sharpe_allocation = pd.DataFrame(max_sharpe.x,index=table.columns,columns=['allocation'])\n    max_sharpe_allocation.allocation = [round(i*100,2)for i in max_sharpe_allocation.allocation]\n    max_sharpe_allocation = max_sharpe_allocation.T\n\n    min_vol = min_variance(mean_returns, cov_matrix)\n    sdp_min, rp_min = portfolio_annualised_performance(min_vol['x'], mean_returns, cov_matrix)\n    min_vol_allocation = pd.DataFrame(min_vol.x,index=table.columns,columns=['allocation'])\n    min_vol_allocation.allocation = [round(i*100,2)for i in min_vol_allocation.allocation]\n    min_vol_allocation = min_vol_allocation.T  \n\n    an_vol = np.std(returns) * np.sqrt(252)\n    an_rt = mean_returns * 252  \n\n    print (\"-\"*80)\n    print (\"Alocacao da Carteira pelo Indice de Sharpe Maximo\\n\")\n    print (\"Retorno Anualizado:\", round(rp,2))\n    print (\"Volatilidade Anualizada (risco):\", round(sdp,2))\n    print (\"\\n\")\n    print (\"\\n\")\n    print (max_sharpe_allocation)\n    print (\"-\"*80)\n    print (\"Alocacao da Carteira pela Volatilidade Minima\\n\")\n    print (\"Retorno Anualizado:\", round(rp_min,2))\n    print (\"Volatilidade Anualizada (risco):\", round(sdp_min,2))\n    print (\"\\n\")\n    print (min_vol_allocation)\n    print (\"-\"*80)\n    print (\"Retornos e Volatilidade das A\u00e7oes Individualmente Referenciadas\\n\")\n    \n    for i, txt in enumerate(table.columns):\n        print (txt,\":\",\"retorno anualizado\",round(an_rt[i],2),\", volatilidade anualizada (risco):\",round(an_vol[i],2))\n    print (\"-\"*80)\n\n    fig, ax = plt.subplots(figsize=(12, 7))\n    ax.scatter(an_vol,an_rt,marker='o',s=200)\n    \n    for i, txt in enumerate(table.columns):\n        ax.annotate(txt, (an_vol[i],an_rt[i]), xytext=(10,0), textcoords='offset points')\n    ax.scatter(sdp,rp,marker='*',color='r',s=500, label='Indice de Sharpe Maximo')\n    ax.scatter(sdp_min,rp_min,marker='*',color='g',s=500, label='Volatilidade Minima (risco)')\n\n    target = np.linspace(rp_min, 0.30, 50)\n    efficient_portfolios = efficient_frontier(mean_returns, cov_matrix, target)\n\n    ax.plot([p['fun'] for p in efficient_portfolios], target, linestyle='-.', color='black', label='efficient frontier')\n    ax.set_title('Otimizacao de Carteira com Acoes Individualmente Referenciadas')\n    ax.set_xlabel('volatilidade anualizada (risco)')\n    ax.set_ylabel('retorno anualizado')\n    ax.legend(labelspacing=0.8)","3418e2d1":"display_ef_with_selected(mean_returns, cov_matrix, risk_free_rate)","1c11af3c":"- conferindo as colunas e sua posi\u00e7\u00e3o relativa no dataframe:","7ee305c7":"Tamb\u00e9m poder\u00edamos definir uma fun\u00e7\u00e3o de otimiza\u00e7\u00e3o para calcular o **portf\u00f3lio de volatilidade m\u00ednima**. Desta vez, realmente estar\u00edamos minimizando a fun\u00e7\u00e3o objetivo. Seria minimizada a volatilidade, por meio de tentativas de uso com pesos diferentes. Os \"constraints\" e \"bounds\" seriam os mesmos da fun\u00e7\u00e3o acima. Ent\u00e3o vejamos:","8e6dc59d":"Todos os ativos apresentam alta volatilidade de pre\u00e7os no per\u00edodo. Os topos e fundos se tornam mais agudos, em alguns casos. Para melhor visualiza\u00e7\u00e3o, o gr\u00e1fico individualizado seria mais adequado. Mas aqui, nosso foco \u00e9 o portf\u00f3lio. ","e129e509":"**1** - a primeira, \u00e9 o c\u00e1lculo da **volatilidade da carteira** dada pela fun\u00e7\u00e3o ** portfolio_annualised_performance**. Se procurarmos pelo trecho **portfolio standard deviation formula**, encontraremos a f\u00f3rmula a seguir:","15f0bb75":"${\\sigma}_{portfolio}$ = $\\sqrt{ {\\omega_1}^2{\\sigma_1}^2 + {\\omega_2}^2{\\sigma_2}^2 + 2\\omega_1\\omega_2Co\\nu_{1,2} }$","bb7d4d0d":"A partir do gr\u00e1fico dos portf\u00f3lios randomicamente simulados, destaca-se uma linha em forma de arco, no topo de pontos azuis agrupados. Esta linha \u00e9 chamada de **fronteira eficiente**. Trata-se da regi\u00e3o em que os pontos desta fronteira representam  o menor risco, para um determinado retorno desejado. Todos os outros pontos \u00e0 direita desta linha, representam investimentos com risco maior, mas com os mesmos retornos. Se os retornos esperados s\u00e3o os mesmos, qual seria a vantagem de tomarmos risco extra?\n\nA maneira como encontramos os dois tipos de portf\u00f3lio ideal, no gr\u00e1fico acima, foi a partir da simula\u00e7\u00e3o de m\u00faltiplas e poss\u00edveis escolhas tomadas aleatoriamente e selecionando as melhores (tanto sob a \u00f3tica do risco m\u00ednimo, quanto a do retorno m\u00e1ximo ajustado ao risco). Esta abordagem pode ser implementada a partir do uso da fun\u00e7\u00e3o optimize, da biblioteca Scipy, em Python.","22cfa8bb":"# Motiva\u00e7\u00e3o e Inspira\u00e7\u00e3o.\n\nMeu interesse pessoal em pesquisas na \u00e1rea de finan\u00e7as acabou me conduzindo ao GitHub e ao artigo de [Ricky Kim](https:\/\/github.com\/tthustla) que me inspirou a criar uma forma pr\u00e1tica e, tanto quanto poss\u00edvel did\u00e1tica, de compartilhar os conhecimentos adquiridos ao longo de minha jornada pelo entendimento e aplica\u00e7\u00e3o pr\u00e1tica da an\u00e1lise de s\u00e9ries temporais, especialmente em l\u00edngua Portuguesa. \n\nS\u00e9ries temporais comp\u00f5em um campo do conhecimento t\u00e3o vasto quanto \u00e1rido e \u00e9, atualmente, uma das habilidades menos conhecidas pelos cientistas de dados. H\u00e1 um conjunto de cursos on-line, dentre os quais destaca-se um oferecido pelo cons\u00f3rcio COURSERA, que \u00e9 composto de cinco cursos ministrados pela [Universidade de Genebra](https:\/\/www.coursera.org\/specializations\/investment-management), em parceria com o UBS. Os cursos n\u00e3o tratam especificamente da modelagem de s\u00e9ries temporais, mas abordam o assunto dentro das estrat\u00e9gias de investimento e das teorias que as cercam. O terceiro m\u00f3dulo, dos cinco que comp\u00f5em o curso, trata, especificamente, da Moderna Teoria dos Portf\u00f3lios e, em especial, do assunto que ser\u00e1 aqui tratado mais adiante, chamado de **M\u00e9todo da Fronteira Eficiente para otimiza\u00e7\u00e3o de portf\u00f3lios**. \n\nPelo que pude verificar, n\u00e3o h\u00e1, no entando, qualquer men\u00e7\u00e3o ao uso de Python nos cursos que tratam de An\u00e1lise de S\u00e9ries Temporais (Time Series Analysis), mas h\u00e1 o \u00f3timo artigo que citei no in\u00edcio deste trabalho, que esmi\u00fa\u00e7a e utiliza as principais bibliotecas Python, dispon\u00edveis para a modelagem de s\u00e9ries temporais. Agrade\u00e7o, portanto, a Ricky Kim, por esta possibilidade, que me permitiu generalizar os conceitos e ferramentas por ele apresentadas, aplicando-as a um portf\u00f3lio real, composto de ativos nacionais e originados na B3-Bovespa e, desta forma, poder compartilhar o conte\u00fado produzido.\n\n**Obs**.:A descri\u00e7\u00e3o do crit\u00e9rio de montagem e da escolha dos ativos componentes do portf\u00f3lio \u00e9 descrita na PARTE-1 deste artigo.","89782225":"- definindo o intervalo temporal de observa\u00e7\u00e3o, que vai de 01\/01\/2013 a 31\/12\/2018, com dados completos at\u00e9 31\/08\/2018:","817fc79f":"Parece que os pre\u00e7os, de uma maneira geral, apresentam tend\u00eancia de alta, ou permanecem estacion\u00e1rios no per\u00edodo, o que era de se esperar (mesmo num mercado de alta volatilidade, como \u00e9 o brasileiro), pelo fato do portf\u00f3lio ser composto por a\u00e7\u00f5es de empresas com bons fundamentos. ","8c132dc4":"- a seguir \u00e9 criada a pivot-table de todos os ativos e valores nas datas observadas:","582e7e93":"No c\u00f3digo acima, duas coisas chamam a aten\u00e7\u00e3o:","f7adadcc":"- em seguida, vamos preparar os dados para condensa\u00e7\u00e3o pivotal, com as colunas passando a ser \"povoadas\" pelos s\u00edmbolos dos ativos componentes do portf\u00f3lio, todos relacionados pela data da informa\u00e7\u00e3o de pre\u00e7o. Antes, precisamos efetuar o \"reset\" do \u00edndice:","1978ed67":"H\u00e1 algumas restri\u00e7\u00f5es ao uso do \u00edndice de Sharpe, uma vez que ele utiliza o desvio padr\u00e3o dos retornos, como denominador. Isto pressup\u00f5e que os retornos obede\u00e7am a uma distribui\u00e7\u00e3o normal (gaussiana). No entanto, no mundo real, os retornos dos ativos financeiros tendem a apresentar desvios que raramente se aproximam da normal, o que pode levar ao uso inadequado do \u00edndice de Sharpe e a interpreta\u00e7\u00f5es err\u00f4neas. Por esta raz\u00e3o, h\u00e1 m\u00e9todos alternativos que ajustam, ou transformam o \u00edndice original de Sharpe, mas que fogem ao escopo deste trabalho introdut\u00f3rio, por serem t\u00e9cnicas mais sofisticadas.","8c430eff":"### Lendo o arquivo que cont\u00e9m o portf\u00f3lio. \n\nA obten\u00e7\u00e3o e a montagem do arquivo lido a seguir, aparece descrita na PARTE-1 deste artigo no item **Anexo**. Os dados foram obtidos a partir do servi\u00e7o gratuito de dados financeiros, on-line, AlphaVantage e todo o c\u00f3digo Python necess\u00e1rio l\u00e1 aparece documentado.\n\nA seguir, o c\u00f3digo Python que disponibiliza o portof\u00f3lio como um Pandas Dataframe, indexado pela coluna \"datetime\". \n\n**Obs**.: tanto o path, como o nome do arquivo, referenciados a seguir, devem ser mudados de acordo com a localiza\u00e7\u00e3o f\u00edsica utilizada para este notebook.","c9a23678":"Outra maneira de observar ativos seria a de tra\u00e7armos os retornos di\u00e1rios (varia\u00e7\u00e3o percentual em compara\u00e7\u00e3o com o dia anterior). Ao tra\u00e7ar retornos di\u00e1rios, ao inv\u00e9s dos pre\u00e7os reais, podemos enxergar mais claramente a volatilidade dos pre\u00e7os dos ativos do portf\u00f3lio. Isto pode ser obtido usando-se o m\u00e9todo Python pct_change (varia\u00e7\u00e3o percentual), como \u00e9 mostrado a seguir:","082b1b73":"# Conceitos Usados.\n\n### Portf\u00f3lio.\n\n\u00c9 qualquer conjunto de ativos de risco. O risco do portf\u00f3lio \u00e9 uma combina\u00e7\u00e3o proporcional dos riscos dos ativos que o constituem.\n\n### Portf\u00f3lio Eficiente.\n\n\u00c9 o portf\u00f3lio cuja combina\u00e7\u00e3o de ativos proporciona o melhor expectativa poss\u00edvel de retorno, para determinado n\u00edvel de risco, em rela\u00e7\u00e3o ao retorno de um capital \"isento de risco\".\n\n### Fronteira Eficiente (ou de Efici\u00eancia).\n\n\u00c9 a linha imagin\u00e1ria, mas que pode ser representada graficamente, que delimita a por\u00e7\u00e3o do conjunto de ativos que oferece  expectativa m\u00e1xima de retorno para determinado n\u00edvel de risco, por\u00e9m, n\u00e3o apenas os de menor risco.","17639f89":"A fun\u00e7\u00e3o definida a seguir, em primeiro lugar, gera um porf\u00f3lio (carteira) aleat\u00f3rio e obt\u00e9m os resultados (retornos, volatilidade e \u00edndice de Sharpe do portf\u00f3lio) e os pesos usados para a obten\u00e7\u00e3o dos resultados correspondentes. \n\nEm segundo lugar, ap\u00f3s identificar o portf\u00f3lio que possui \u00edndices de Sharpe mais elevados, ela exibe este portf\u00f3lio de **\u00edndice de Sharpe m\u00e1ximo, em vermelho**. Realiza, ainda, tratamento an\u00e1logo para a identifica\u00e7\u00e3o do portf\u00f3lio de **volatilidade m\u00ednima e o exibe como um asterisco (estrela) verde**, na grade gr\u00e1fica. \n\nTodos os portf\u00f3lios gerados aleatoriamente s\u00e3o, tamb\u00e9m, plotados e associados a um mapa de cores, que variam de acordo com o \u00edndice de Sharpe. A cor **Mais azul**, significa **maior \u00edndice de Sharpe**. E para estes dois portf\u00f3lios \u00f3timos - **com m\u00e1ximo \u00edndice de Sharpe** e com **m\u00ednima volatilidade** - ela mostrar\u00e1 como se daria a aloca\u00e7\u00e3o percentual do or\u00e7amento, dentro destes portf\u00f3lios.","154ac0a8":"### Algumas considera\u00e7\u00f5es para refletirmos.\n\n- O conceito de Fronteira Eficiente \u00e9 baseado exclusivamente no passado. As correla\u00e7\u00f5es entre ativos componentes mudar\u00e3o constantemente. O desempenho dos \u00faltimos cinquenta anos, ser\u00e1 diferente para os pr\u00f3ximos cinquenta? S\u00f3 o tempo dir\u00e1.\n\n- Todo ano novos dados ser\u00e3o agregados e o portf\u00f3lio ideal tende a mudar. \u00c9 preciso estar atento aos ajustes necess\u00e1rios. No meu caso, para portf\u00f3loios de a\u00e7\u00f5es, uso a inspe\u00e7\u00e3o na mesma periodicidade da divulga\u00e7\u00e3o dos resultados das a\u00e7\u00f3es da carteira. Aqui no Brasil (B3 Bovespa) a periodicidade \u00e9 trimestral. Contudo, nada impede que as inspe\u00e7\u00f5es sejam  realizadas em periodicidade diferente, desde que haja informa\u00e7\u00f5es suficientes.\n\n- H\u00e1 um n\u00famero **ilimitado** de ativos que possam compor portf\u00f3lios. \n\n- Custos incorridos, como impostos, taxas de corretagem, cust\u00f3ria e emolumentos n\u00e3o s\u00e3o levadas em conta neste estudo. Elas claramente impactam o desempenho final do portfolio, mas n\u00e3o h\u00e1 forma segura de envolv\u00ea-los diretamente nos modelos sem risco de distor\u00e7\u00e3o completa.","637bcddb":"$Sharpe = \\frac{\\bar{r_p}-r_f}{\\sigma_p}$\n\nonde:<br>\n$\\bar{r_p}$ = retorno m\u00e9dio esperado do portf\u00f3lio <br>\n$r_f$ = retorno m\u00e9dio de um ativo sem risco (t\u00edtulo do tesouro amearicano, ou brasileiro, por ex.)<br>\n$\\sigma_p$ = desvio padr\u00e3o da carteira (portf\u00f3lio)","ebaf4546":"## A Fronteira Eficiente","2cbdabce":"- A seguir, primeira visualizan\u00e7\u00e3o das caracter\u00edsticas b\u00e1sicas do portf\u00f3lio, que j\u00e1 nasce indexado pela data(campo datetime) que tem periodicidade di\u00e1ria.","29e17325":"Usu\u00e1rios avan\u00e7ados do Excel, normalmente usam a fun\u00e7\u00e3o \"solver\". A fun\u00e7\u00e3o de otimiza\u00e7\u00e3o da Scipy realiza tarefa semelhante, quando se sabe o que deve ser otimizado e quais s\u00e3o as respectivas restri\u00e7\u00f5es e limites.\n\nAs fun\u00e7\u00f5es, a seguir, t\u00eam como finalidade obter a aloca\u00e7\u00e3o do **portf\u00f3lio com \u00edndice m\u00e1ximo de Sharpe**. Na fun\u00e7\u00e3o de otimiza\u00e7\u00e3o do Scipy, n\u00e3o h\u00e1 o processo \"maximizar\", por isto, como toda fun\u00e7\u00e3o objetivo, seria necess\u00e1rio passar algo a ser minimizado. Por esta raz\u00e3o, estar\u00e1 sendo calculado o \u00edndice de Sharpe negativo, ou \u201cneg_sharpe_ratio\u201d, que admite o uso desta fun\u00e7\u00e3o como fun\u00e7\u00e3o objetivo, em que se procurar\u00e1 minimizar o \u00edndice de Sharpe negativo. \n\nNa fun\u00e7\u00e3o \u201cmax_sharpe_ratio\u201d, em primeiro lugar s\u00e3o definidos os argumentos (dentre eles n\u00e3o devem estar inclu\u00eddas as vari\u00e1veis que ser\u00e3o passadas durante as tentativas do processo de otimiza\u00e7\u00e3o, neste caso, os \u201cpesos\u201d). A constru\u00e7\u00e3o das restri\u00e7\u00f5es \u00e9 meio complicada e pouco intuitiva, devido \u00e0 forma pythonizada, como o processo foi estruturado\". \u00c9 usado um 'dicion\u00e1rio' (Python dic={}) com uma fun\u00e7\u00e3o lambda.","a12f2562":"Vamos, ent\u00e3o, obter os valores dos argumentos necess\u00e1rios para o uso das nossas fun\u00e7\u00f5es. Os retornos di\u00e1rios podem ser facilmente obtidos, aplicando a fun\u00e7\u00e3o **pct_change()**, ao conjunto de dados de pre\u00e7os. Os **retornos di\u00e1rios m\u00e9dios** e a **matriz de covari\u00e2ncia dos retornos** s\u00e3o necess\u00e1rios para calcular os retornos e a volatilidade da carteira. Vamos obt\u00ea-los e gerar **25.000** portf\u00f3lios aleat\u00f3rios. \n\nFinalmente, a **taxa livre de risco** foi retirada do Tesouro Direto - t\u00edtulos p\u00f3s fixados com atualiza\u00e7\u00e3o pelo IPCA - cuja taxa de juros ofertada era de 3,45% aa, no in\u00edcio de 2018. A raz\u00e3o por tr\u00e1s desta escolha est\u00e1 no fato de que os dados de pre\u00e7os hist\u00f3ricos abrangem do per\u00edodo dos \u00faltimos 5 anos - de 2013 a 2018 - e foi assumida, como momento de an\u00e1lise, o in\u00edcio de 2018, uma vez que fornecia a taxa mais atualizada do Tesouro Direto.","4e49e160":"# Aquecendo as turbinas.\n\nInicialmente precisa ser disponibilizado o primeiro conjunto de bibliotecas Python que nos permitir\u00e1 iniciar o trabalho. A lista de \"imports\" a seguir, estabelece os primeiros requisitos funcionais (requirements). Todas as bibliotecas listadas s\u00e3o \"open-source\" e podem ser obtidas por meio do gerenciador de pacotes \"pip\", ou \"conda\", se o ambiente for Anaconda:","3e851096":"Foram obtidos quase os mesmos resultados da simula\u00e7\u00e3o onde foram eleitos os melhores portf\u00f3lios gerados aleatoriamente. A pequena diferen\u00e7a \u00e9 devida ao uso da **fun\u00e7\u00e3o \"optimize\" da biblioteca SciPy**, que **n\u00e3o alocou or\u00e7amento para algumas das a\u00e7\u00f5es, no portf\u00f3lio de \u00edndice de Sharpe m\u00e1ximo**. H\u00e1, ainda, umas poucas diferen\u00e7as nas casas decimais.\n\nAo inv\u00e9s de plotar os portf\u00f3lios gerados aleatoriamente, poder\u00edamos **plotar cada a\u00e7\u00e3o individual** no gr\u00e1fico, com os valores correspondentes do **retorno anual** e do **risco anual** de cada ativo componente. Desta forma, poder\u00edamos observar o quanto a diversifica\u00e7\u00e3o estaria diminuindo o risco do investidor, otimizando a aloca\u00e7\u00e3o.","8365e666":"### Perfis de Portf\u00f3lios.\n\nProcuram definir composi\u00e7\u00f5es que estejam adequados ao n\u00edvel de propens\u00e3o ao risco, manifestado pelo investidor.","8176abc9":"## Gera\u00e7\u00e3o Rand\u00f4mica de Portf\u00f3lios.","de06087c":"# AN\u00c1LISE DE PORTF\u00d3LIO - PARTE 2.\n# Um estudo de caso usando s\u00e9ries temporais com Python<br>\n\n## Otimizacao de Portf\u00f3lios pelo M\u00e9todo da Fronteira Eficiente, com Python\n#### Rio de Janeiro, 30\/08\/3018\n[Antonio Roberto Mendes Barber\u00e1](https:\/\/rbarbera2.wixsite.com\/backlog\/)","fbcf1d31":"- a seguir o aspecto da pivot-table de nome \"table\".","7087daeb":"**2** - a segunda, \u00e9 o uso do \u00edndice de Sharpe. Para entender o \u00edndice de Sharpe \u00e9 preciso incorporar o conceito de **retorno com risco ajustado (risk-adjusted return). O retorno com risco ajustado** \u00e9 um refinamento do retorno do investimento, medindo-se o quanto de risco est\u00e1 envolvido no retorno produzido, o que \u00e9 geralmente expresso como um n\u00famero, ou uma rela\u00e7\u00e3o. O \u00edndice de Sharpe \u00e9 uma destas rela\u00e7\u00f5es.","dc176ce2":"Como j\u00e1 foi mencionado anteriormente, podemos, tamb\u00e9m, tra\u00e7ar a \"fronteira eficiente\", que \u00e9 a linha que mostra onde procurar os retornos eficientes, conforme a propens\u00e3o do investidor ao risco. A seguir, s\u00e3o apresentadas outras fun\u00e7\u00f5es para c\u00e1lculo e visualiza\u00e7\u00e3o da fronteira eficiente. \n\nA primeira fun\u00e7\u00e3o - **efficient_return** - calcula aloca\u00e7\u00e3o do **portf\u00f3lio mais eficiente**, para um determinado **objetivo alvo** de retorno, para a carteira.\n\nA segunda fun\u00e7\u00e3o - **efficient_frontier** - fornece um **intervalo de alvos (targets)** poss\u00edveis para o retorno da carteira, e calcula um **portf\u00f3lio eficiente para cada n\u00edvel de retorno** apresentado.","b36dab45":"De maneira an\u00e1loga, como foi definido para o c\u00e1lculo do retorno anualizado, foram considerados 252 dias \u00fateis (de negocia\u00e7\u00e3o anuais), para calcularmos o desvio padr\u00e3o anualizado da carteira.","b287f162":"**Obs**.: c\u00edrculos coloridos de di\u00e2metros diferentes sugerem aloca\u00e7\u00f5es percentuais diferentes.","e97fc6e5":"## Trabalhando com a varia\u00e7\u00e3o dos pre\u00e7os.","d8ef0626":"Vamos plotar as op\u00e7\u00f5es de portf\u00f3lio - com o **\u00edndice m\u00e1ximo de Sharpe** e **volatilidade m\u00ednima** - al\u00e9m de todos os portf\u00f3lios gerados aleatoriamente. Mas, desta vez, n\u00e3o estaremos escolhendo os portf\u00f3lios \u00f3timos gerados aleatoriamente. Na realidade, estaremos calculando e usando a fun\u00e7\u00e3o \"minimize\" do Scipy. E a fun\u00e7\u00e3o abaixo ir\u00e1, tamb\u00e9m, tra\u00e7ar a linha de fronteira eficiente.","6d2e895b":"Para um portf\u00f3lio de risco m\u00ednimo, podemos ver que mais da metade do or\u00e7amento \u00e9 alocado em ABEV3, EGIE3, PSSA3, RADL3 e WEGE3. Se voltarmos e olharmos o gr\u00e1fico de retorno di\u00e1rio, no in\u00edcio, iremos lembrar que RADL3 \u00e9 a a\u00e7\u00e3o menos vol\u00e1til, dentre as 15 analisadas. Portanto, sob esta \u00f3tica, **faz todo o sentido alocar uma maior porcentagem do or\u00e7amento** nela, uma vez que se trata do  **portf\u00f3lio de risco m\u00ednimo**.\n\nPara um investidor disposto a assumir um risco maior - com chance de retorno mais alto - a aloca\u00e7\u00e3o que nos d\u00e1 o **melhor retorno ajustado ao risco** \u00e9 aquela que apresenta **\u00edndice de Sharpe m\u00e1ximo**. Neste cen\u00e1rio, estar\u00edamos alocando uma parcela mais significativa de nosso or\u00e7amento numa combina\u00e7\u00e3o de ativos mais vol\u00e1teis, segundo o gr\u00e1fico anterior de retornos di\u00e1rios. \n\nNo nosso caso, pelo motivo de ser a carteira equilibrada, as aloca\u00e7\u00f5es apresentam risco e retorno muito pr\u00f3ximos, ou seja, retorno de 19% ao ano, para um risco de 17%, contra  o retorno de 16% ao ano e risco de 16%. ","6e8e8376":"O gr\u00e1fico acima mostra que a a\u00e7\u00e3o de menor risco \u00e9 ABEV3, com em torno de 21%(0.21) a.a. Mas com a otimiza\u00e7\u00e3o do portf\u00f3lio, podemos alcan\u00e7ar um risco ainda menor e igual a 15% (0.15) e ainda obter um retorno maior, de 17% (0.17) -  a estrela verde - desde que  usemos a aloca\u00e7\u00e3o com 25.37% de ABEV3,  4.48% de CIEL3, 16.53% de EGIE3, 12.32% de GRND3, 0.81% de HGTX3, 10.45% de MDIA3, 7.27% de PSSA3, 10.23% de RADL3, 0.85% de VALE3, 11.77 de RADL3 e 0.00% de RZTC3, ITSA3, ITUB3, LREN3 e PETR3.\n\nE, se houver disposi\u00e7\u00e3o para assumir um pouco mais de risco (em torno do n\u00edvel de risco de 18% - 0.18), podemos obter um retorno anualizado de 24% (0.24), mas com aloca\u00e7\u00e3o mais concentrada, em 23.07% de GRND3, 6.2% de LREN3, 3.07% de MDIA3,   18.5% de PSSA3, 27.47% de RADL3, 2.69% de VALE3 e 19.00% de WEGE3. N\u00e3o haveria aloca\u00e7\u00f5es em ABEV3, CIEL3, EGIE3, EZTC3, HGTX3, ITSA3, ITUB3 e PETR3.","0585099e":"A express\u00e3o \"constraints =\" (descrita acima), que aparece no interior da fun\u00e7\u00e3o a seguir, estabelece que a soma de 'x' deve ser igual a 1. A constru\u00e7\u00e3o via fun\u00e7\u00e3o lambda j\u00e1 e naturalmente esquisita e o \"1\" parece ter passado do lado direito do sinal de igual, para o lado esquerdo (pela troca de sinal), como em 'np.sum (x) == 1' tornando-se 'np.sum (x) -1'. Esta constru\u00e7\u00e3o estranha significa, simplesmente, que a soma de todos os pesos deve ser igual a 1, de modo que n\u00e3o seja poss\u00edvel alocar mais de 100% do or\u00e7amento, para composi\u00e7\u00e3o do portf\u00f3lio.\n\nA vari\u00e1vel \"bounds\" estabelece outro limite para atribui\u00e7\u00e3o de pesos aleat\u00f3rios, dizendo que qualquer peso deve estar inclu\u00eddo no intervalo entre 0 e 1. Com isto, n\u00e3o se pode atribuir valor negativo e nem valores maiores do que 100% do or\u00e7amento, a uma determinada a\u00e7\u00e3o.","f6a5eb57":"Obs.: a f\u00f3rmula acima pode ser simplificada, em termos de economia de esfor\u00e7o computacional, se for usada em sua [nota\u00e7\u00e3o matricial](ver https:\/\/goo.gl\/tAst18de).","7468de95":"- a partir de \"table\", obteremos a primeira \"foto\" do portf\u00f3lio, com as s\u00e9ries de pre\u00e7os ajustados de seus ativos componentes, representados graficamente em conjunto:","174c0207":"# Conclus\u00e3o\n\nConsiderando a vastid\u00e3o que \u00e9 o campo das finan\u00e7as, h\u00e1 uma infinidade de aplica\u00e7\u00f5es para o M\u00e9todo da Fronteira Eficiente. \nMarkowitz, quando a enunciou, estabeleceu um grande diferencial ao apresentar a Moderna Teoria dos Portf\u00f3lios. Ela demonstra que o risco de um portf\u00f3lio (ou carteira de a\u00e7\u00f5es) n\u00e3o \u00e9 dado simplesmente pela m\u00e9dia do risco dos ativos individuais, pois **\u00e9 preciso considerar a correla\u00e7\u00e3o existente entre eles, no tempo. \n\nSendo assim, pode-se dizer que a \u201cpalavra-chave\u201d que permeia a teoria de Markowitz \u00e9 o conceito de **diversifica\u00e7\u00e3o**, com o intuito de reduzir risco. Markowitz desnuda, na pr\u00e1tica, a m\u00e1xima de que **\"n\u00e3o se deve colocar todos os ovos na mesma cesta\"**.\nA Teoria Moderna do Portf\u00f3lio valeu o Nobel de Economia a Markowitz, em 1990.\n\nEspero que o compartilhamento do conte\u00fado aqui exposto estimule alunos e colegas a aplicarem a teoria e os recursos do Python aqui descritos, no sentido de mudarmos o atual estado de coisas em nosso pa\u00eds e, desta forma, sensibilizar as empresas de que **\u00e9 poss\u00edvel usarmos o estado da arte da ci\u00eancia dos dados, para melhorarmos a qualidade das decis\u00f5es empresariais.\n\nAprendi muito com constru\u00e7\u00e3o desta simula\u00e7\u00e3o que, na realidade, retrata um caso real de carteira de a\u00e7\u00f5es da B3 Bovespa. Espero que aproveitem.\n\nAbra\u00e7os,\nBarber\u00e1","e592a64f":"- verificando a estrutura do portf\u00f3lio, ap\u00f3s reset do \u00edndice:","b83fe3fa":"A fun\u00e7\u00e3o **portfolio_annualised_performance** calcular\u00e1 os retornos e a volatilidade. E para tornar o c\u00e1lculo anualizado, ser\u00e1 considerado **252** como o n\u00famero de dias de negocia\u00e7\u00e3o das a\u00e7\u00f5es, em um ano. A fun\u00e7\u00e3o **random_portfolios** gerar\u00e1 carteiras com pesos aleat\u00f3rios atribu\u00eddos a cada a\u00e7\u00e3o e, se fornecido o argumento **num_portfolios**, ser\u00e1 gerado igual n\u00famero de carteiras aleat\u00f3rias.","18c0941d":"Temos 15 a\u00e7\u00f5es no portf\u00f3lio. Uma decis\u00e3o corriqueira \u00e9 a de como alocar dinheiro novo e distribu\u00ed-lo por cada uma das a\u00e7\u00f5es nele contidas. Se nosso or\u00e7amento total fosse 1 BRL, poder\u00edamos definir pesos para cada ativo componente, de modo que a soma deles fosse igual a 1. E o valor de cada peso corresponderia \u00e0 parte do or\u00e7amento que estar\u00edamos alocando especificamente a cada ativo. Por exemplo, se o peso for 0.5 para ABEV3, significa que estar\u00edamos alocando 50% de nosso or\u00e7amento para compras de a\u00e7oes ABEV3.\n\nVamos, ent\u00e3o, definir algumas fun\u00e7\u00f5es para simularem pesos aleat\u00f3rios para cada ativo do portf\u00f3lio e, em seguida, calcular os **retornos globais** e a **volatilidade** (**ambos anualizados**), para todo o portf\u00f3lio:","cbf8183c":"O **Sharpe ratio**, como \u00e9 conhecido, descreve o quanto de **excesso de retorno** est\u00e1 sendo recebido, para a **volatilidade extra suportada**, quando o investidor se mant\u00e9m \"comprado\" num ativo mais arriscado. O \u00edndice de Sharpe pode ser expresso pela seguinte f\u00f3rmula:"}}