{"cell_type":{"05ae14bb":"code","98e3bb30":"code","557d45c4":"code","ff4d2f9a":"code","5d7a987a":"code","754e10be":"code","e8e018e5":"code","441cd945":"code","0be82ea9":"code","7eeeff93":"code","67369408":"code","29cfdcce":"code","8b436e75":"code","f2037d62":"code","179da463":"code","d3384528":"code","120f76cb":"code","4e470d9a":"code","eeec2197":"code","926daaf6":"code","2513f546":"code","28491484":"markdown","329289d9":"markdown","80532d57":"markdown","18ce7074":"markdown","9f159bf0":"markdown","0cfe01ee":"markdown","ac78140f":"markdown","e44ba3df":"markdown","5aa51634":"markdown","d0778db2":"markdown","cfe1f364":"markdown"},"source":{"05ae14bb":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","98e3bb30":"!pip install openpyxl","557d45c4":"# To start with importing libraries which are essential for the case\nimport pandas as pd\nimport datetime as dt","ff4d2f9a":"# Reading the excel format data set by using \"Year 2010-2011\" sheet named.\ndf_ = pd.read_excel(\"..\/input\/online-retail-ii-data-set-from-ml-repository\/online_retail_II.xlsx\", sheet_name=\"Year 2010-2011\")\ndf = df_.copy()","5d7a987a":"# Browsing the dataset \ndf.head()","754e10be":"# Examining descriptive statistics\ndf.describe().T","e8e018e5":"# Detection of missing variables\ndf.isnull().sum()","441cd945":"# Remowing of missing variables\ndf.dropna(inplace=True)","0be82ea9":"# Removing canceled transactions from the dataset\ndf = df[~df[\"Invoice\"].str.contains(\"C\", na=False)]\ndf.describe().T","7eeeff93":"# Examining the unique variables\ndf.nunique()","67369408":"# Examining how many of each product are\ndf[\"Description\"].value_counts()","29cfdcce":"# Let's add a new variable to the data set to see the total price for each row.\ndf[\"TotalPrice\"] = df[\"Quantity\"] * df[\"Price\"]\ndf.head()","8b436e75":"# When was the last time a customer made a purchase?\ndf[\"InvoiceDate\"].max()","f2037d62":"# In order to get logical results and avoid zero values, we set 2 days later as today's date.\ntoday_date = dt.datetime(2011, 12, 11)","179da463":"# We obtain RFM metrics by grouping \"Customer IDs\" with aggregation methods that I use specific to each metric.\nrfm = df.groupby('Customer ID').agg({'InvoiceDate': lambda InvoiceDate: (today_date - InvoiceDate.max()).days,\n                                     'Invoice': lambda Invoice: Invoice.nunique(),\n                                     'TotalPrice': lambda TotalPrice: TotalPrice.sum()})","d3384528":"# We name the columns according to the metrics.\nrfm.columns = ['recency', 'frequency', 'monetary']\nrfm.head()","120f76cb":"# We create RFM scores between 1-5.\nrfm[\"recency_score\"] = pd.qcut(rfm['recency'], 5, labels=[5, 4, 3, 2, 1])\nrfm[\"frequency_score\"] = pd.qcut(rfm['frequency'].rank(method=\"first\"), 5, labels=[1, 2, 3, 4, 5])\nrfm[\"monetary_score\"] = pd.qcut(rfm['monetary'], 5, labels=[1, 2, 3, 4, 5])","4e470d9a":"# The designation of the recency_score and frequency_score variables as the RFM_SCORE variable.\nrfm[\"RFM_SCORE\"] = (rfm['recency_score'].astype(str) + rfm['frequency_score'].astype(str))\nrfm.head()","eeec2197":"# Creating segment map with regex\nseg_map = {\n    r'[1-2][1-2]': 'hibernating',\n    r'[1-2][3-4]': 'at_Risk',\n    r'[1-2]5': 'cant_loose',\n    r'3[1-2]': 'about_to_sleep',\n    r'33': 'need_attention',\n    r'[3-4][4-5]': 'loyal_customers',\n    r'41': 'promising',\n    r'51': 'new_customers',\n    r'[4-5][2-3]': 'potential_loyalists',\n    r'5[4-5]': 'champions'\n}\n\n# Let's define segments so that the generated RFM scores can be explained more clearly.\nrfm['segment'] = rfm['RFM_SCORE'].replace(seg_map, regex=True)\nrfm.head()","926daaf6":"# Let's group our dataframe by segment and look at the averages of the RFM scores.\nrfm[[\"segment\", \"recency\", \"frequency\", \"monetary\"]].groupby(\"segment\").agg([\"mean\", \"count\"])","2513f546":"# Let's examine the segments separately.\nrfm[rfm[\"segment\"] == \"need_attention\"].head()\n\n# Let's keep the information in need_attention in a separate csv.\nnew_df = pd.DataFrame()\nnew_df[\"need_attention_id\"] = rfm[rfm[\"segment\"] == \"need_attention\"].index\n\nnew_df.to_csv(\"need_attention.csv\")","28491484":"> We use the qcut function to divide into equal intervals. It can be thought of as normally we should assign high scores to high values. However, when calculating the recency_score, it is more important to us how recently he shopped.","329289d9":"> Thus, we can keep the customers we want to deal with or the customers with whom we will apply different campaign policies in a separate file.","80532d57":"> When the statistics are examined, it is seen that there are unexpected negative values in the quantity and price variables. These values represent returns in the data set. When the data set is examined, there is a \"C\" expression for returns in the \"Invoice\" variable.\n\n**During the data preparation phase, let's fix these mistakes and remove the missing values from the data set for getting much more meaningfull outcomes**.","18ce7074":"RFM is one of the most popular methods used for customer analysis and customer segmentation. It gets its name from the three metrics that make up it. These are recency, frequency and monetary.\n\n**Recency:** Usually refers to when the customer last shopped and how many days have passed since their last purchase.\n\n**Frequency:** It deals with how often the customer takes action. For example, how often she makes a purchase or how often she reviews products.\n\n**Monetary:** It deals with how much money the customer spends.\n\nBoth metrics calculated in a given period of time. In addition, when all metrics are brought together, it contributes to the formation of the ideal customer segment.\n\n**Segmentation Map:**","9f159bf0":"![image.png](attachment:e37452d5-6733-4b9c-b2ff-ded499c3760c.png)","0cfe01ee":"In this case study, I tried to segment the customers of an e-commerce company and determine marketing strategies according to these segments by using Online-Retail-II data set.\n\nThe dataset named Online-Retail-II includes the sales of an online store between 01\/12\/2009 - 09\/12\/2011.","ac78140f":"**Now that we are done with understanding and preparing the data, we can start interpreting the data.**\n\nWe make some changes to the dataset to find the RFM metrics.","e44ba3df":"> As a result, it is seen that a more meaningful data set was obtained, with values that would give us erroneous results removed from the data set.","5aa51634":"**In the interpretation of the results, I chose 3 segments. I will try to explain why these are important and what policies can be considered.**\n\n1. need_attention segment:\nWe have 187 customers. Monetary is 897.6278, almost 1\/3 of loyal customers. There is great potential here. Frequenciy of customers 52.4278. Campaigns can be sent via sms or e-mail to encourage shopping. In order to reduce the frequency of this segment, gift certificates can be sent and they can be reminded of the products.\n\n2. can't loose segment:\nWe have 63 customers there. It seems a bit less. Maybe you say there is no need for giving attention for them but they need. Monetary is 2796.1558. It is greater than need_attention segment although they are few in number. Also it is near to loyal_customer segment. But their average recency is 132.968. In addition to the methods we apply for the need_attention segment, customers can be called and questions about their shopping satisfaction can be asked. For their next shopping, a discount can be applied and a gift sample can be sent from new products.\n\n3. loyal_customers segment:\nWe have 819 customers in this segment. Monetary is 2864.2477. Recency is 33.608 and frequency is 6.4798. We can encourage this segment for the championship. When we come with offers such as free shipping for champions, this segment can also request the same earnings and push their segment up.","d0778db2":"# RFM for Customer Segmentation","cfe1f364":"# Case Study with RFM"}}