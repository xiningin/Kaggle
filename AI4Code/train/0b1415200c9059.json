{"cell_type":{"75c89837":"code","cfd18a19":"code","efee32b8":"code","fff3b928":"code","dfb3fa3a":"code","811f8805":"code","d8abe62e":"code","505da0cb":"code","58426987":"code","8da06019":"code","b45d56ab":"code","a54165d2":"code","2d682f70":"code","16279bd9":"code","a238a6f5":"code","75f0a1b9":"code","8ca4ace8":"code","22f50534":"code","3483663c":"code","264f8470":"code","dcae7d99":"code","cc4e3e7f":"code","47e60838":"markdown","819474a0":"markdown","b54b009d":"markdown","fa63da1b":"markdown","42e8271c":"markdown"},"source":{"75c89837":"#install necessary libraries\n!pip install stable-baselines3[extra]   ","cfd18a19":"#import libraries\nimport os\nimport numpy as np\nimport pandas as pd\nimport random\n\nimport gym\nfrom gym import spaces\n\nimport plotly as py\nimport plotly.graph_objects as go\nimport plotly.offline as ply\nfrom plotly.offline import init_notebook_mode\ninit_notebook_mode(connected=True)\nfrom plotly.subplots import make_subplots\n\n\nfrom collections import deque\nfrom datetime import datetime\n\nfrom stable_baselines3.common.vec_env import DummyVecEnv\nfrom stable_baselines3 import A2C, PPO","efee32b8":"print(\"np {}\".format(np.__version__))\nprint(\"pd {}\".format(pd.__version__))\nprint(\"ply {}\".format(py.__version__))\nprint(\"gym {}\".format(gym.__version__))\n","fff3b928":"#import dataset\ndataset = pd.read_csv(\"..\/input\/bitcoin-historical-data\/bitstampUSD_1-min_data_2012-01-01_to_2021-03-31.csv\")","dfb3fa3a":"#portion of data for training and testing\ndataset = dataset[4000000:4800000]\ndataset = dataset.reset_index(drop = True)","811f8805":"dataset.info()","d8abe62e":"#convert timestamp to datetime and drop unwanted columns\ndataset['Date'] = [datetime.fromtimestamp(x) for x in dataset['Timestamp']]\ndataset = dataset.drop([ \"Volume_(Currency)\", \"Timestamp\"], axis=1)\ndataset.head()","505da0cb":"#check for nan or missing values\ndataset.isnull().any()","58426987":"#darop na\ndataset = dataset.dropna()","8da06019":"dataset.head()","b45d56ab":"#normalize the data\ndef Normalizing(df_original):\n    df = df_original.copy()\n    column_names = df.columns.tolist()\n    for column in column_names[:-1]:\n        # Logging and Differencing\n        test = np.log(df[column]) - np.log(df[column].shift(1))\n        if test[1:].isnull().any():\n            df[column] = df[column] - df[column].shift(1)\n        else:\n            df[column] = np.log(df[column]) - np.log(df[column].shift(1))\n        # Min Max Scaler implemented\n        Min = df[column].min()\n        Max = df[column].max()\n        df[column] = (df[column] - Min) \/ (Max - Min)\n    return df","a54165d2":"dataset_norm = Normalizing(dataset)\ndataset_norm.head()","2d682f70":"#trading graph class\nclass TradingGraph:\n  def __init__(self, Render_range):\n    #initialize varaibles\n    self.Open = []\n    self.Close = []\n    self.High = []\n    self.Low = []\n    self.Date = []\n    self.net_worth = []\n    self.trades = []\n    self.Render_range = Render_range\n    \n    \n  def render(self, Date, Open, High, Low, Close, net_worth, trades):\n    #append data to initialized variables\n    self.Open.append(Open)\n    self.Close.append(Close)\n    self.High.append(High)\n    self.Low.append(Low)\n    self.Date.append(Date)\n    self.net_worth.append(net_worth)\n    self.trades.append(trades)\n    #render environment after process completion\n    if len(self.net_worth)==(self.Render_range-60):\n        #make subplots\n        fig = make_subplots(specs=[[{\"secondary_y\": True}]])\n        #plot a candlestick graph\n        fig.add_trace(go.Candlestick(x=self.Date,\n                open=self.Open, high=self.High, low=self.Low,\n                close=self.Close, name=\"Open and Close Price\"),secondary_y=True, \n                     )\n        #plot networth\n        fig.add_trace(go.Scatter(x=self.Date, y=self.net_worth, marker=dict(color='#A2D5F2'), name=\"Net worth\"),\n               secondary_y=False)\n        #initialize variables \n        buy = []\n        buy_date = []\n        sell = []\n        sell_date = []\n        hold = []\n        hold_date = []\n        text_sell = []\n        text_buy = []\n        text_hold = []\n        #get action type, date and percentage\n        for tradess in self.trades:\n          for trade in tradess:\n            if trade['type'] == 'buy':\n                high_low = trade['Low']-500\n                date_high_low = trade['Date']\n                text = trade['percentage']\n                buy.append(high_low)\n                buy_date.append(date_high_low)\n                text_buy.append(text)\n            elif trade['type'] == 'sell':\n                high_low = trade['High']+500\n                date_high_low = trade['Date']\n                text = trade['percentage']\n                sell.append(high_low)\n                sell_date.append(date_high_low)\n                text_sell.append(text)\n            elif trade['type'] == 'hold':\n                high_low = trade['High']+500\n                date_high_low = trade['Date']\n                text = trade['percentage']\n                hold.append(high_low)\n                hold_date.append(date_high_low)\n                text_hold.append(text)\n        #plot action types, percentage       \n        fig.add_trace(go.Scatter(x=buy_date, y=buy, mode=\"markers\", marker=dict(color=\"green\", size=5), marker_symbol=\"triangle-up\", text = text_buy, name=\"buy\"),\n                   secondary_y=True)\n        fig.add_trace(go.Scatter(x=sell_date, y=sell, mode=\"markers\", marker=dict(color=\"red\", size=5), marker_symbol=\"triangle-down\", text = text_sell, name=\"sell\"),\n                   secondary_y=True)\n        fig.add_trace(go.Scatter(x=hold_date, y=hold, mode=\"markers\", marker=dict(color=\"brown\", size=5), marker_symbol=\"circle\", text = text_hold, name=\"hold\"),\n                   secondary_y=True)\n        #update axis titles\n        fig.update_layout(title=\"Bitcoin Trading Bot\",\n                  xaxis_title=\"Date\",\n                  yaxis_title=\"Balance\")\n        fig.update_yaxes(title=\"Price\",secondary_y=True)\n        fig.show()\n        ","16279bd9":"#custom bitcoin env class\nclass BitcoinEnv(gym.Env):\n  def __init__(self, dataset_norm, dataset, initial_balance = 1000, lookback_window_size = 31, env_steps_size = 0):\n    #initialize\n    super(BitcoinEnv, self).__init__()\n    self.df = dataset_norm #normalized dataaset\n    self.df_original = dataset #non-normalized data for visualization\n    self.df_total_steps = len(self.df)-1\n    self.initial_balance = initial_balance\n    self.lookback_window_size = lookback_window_size\n    self.env_steps_size = env_steps_size\n    self.commission = 0.00001 # commission fees\n    self.columns = list(self.df.columns[:-1])\n    observation_length = len(self.columns)+ 5 \n   \n    #define action and observation space\n    self.action_space = spaces.MultiDiscrete([3, 11])\n    \n    self.observation_space = spaces.Box(low =-1 , high =1,shape = (self.lookback_window_size, observation_length), dtype = np.float32)\n\n    # Orders history contains btc transactions history for the last lookback_window_size steps\n    self.orders_history = deque(maxlen=self.lookback_window_size)\n        \n    # Market history contains the OHCL values for the last lookback_window_size prices\n    self.market_history = deque(maxlen=self.lookback_window_size)\n  \n  \n  #reset function\n  def reset(self):\n    self.visualization = TradingGraph(Render_range=self.df_total_steps) # initialize visualization i.e trading graph\n    self.trades = [] # trades list for visualization\n    self.balance = self.initial_balance\n    self.net_worth = self.initial_balance\n    self.last_price = 0\n    self.btc_held = 0\n    self.btc_sold = 0\n    self.btc_bought = 0\n    self.last_balance = self.initial_balance\n    self.last_held = 0\n    #start and end step for train and test \n    if self.env_steps_size > 0: # used for training dataset\n        self.start_step = random.randint(self.lookback_window_size, self.df_total_steps - self.env_steps_size)\n        self.end_step = self.start_step + self.env_steps_size\n    else: # used for testing dataset\n        self.start_step = self.lookback_window_size\n        self.end_step = self.df_total_steps\n\n    self.current_step = self.start_step\n    \n    #get data for lookback window \n    for i in reversed(range(self.lookback_window_size)):\n      current_step = self.current_step - i\n      #since orders history not norminalized we divide by 10000\n      self.orders_history.append([self.balance\/10000, self.net_worth\/10000, self.btc_bought\/10000, self.btc_sold\/10000, self.btc_held\/10000])\n      self.market_history.append([self.df.loc[self.current_step, column] for column in self.columns\n                                  ])\n    #concatenate market and orders history which becomes state\n    state = np.concatenate((self.market_history, self.orders_history), axis=1)\n    return state\n  \n  #step function  \n  def step(self, action):\n    #if current step > env end step(env_step size) or networth less or = o set done true\n    done = self.current_step == self.end_step or self.net_worth <= 0\n    \n    Date = self.df_original.loc[self.current_step, 'Date'] # for visualization\n    High = self.df_original.loc[self.current_step, 'High'] # for visualization\n    Low = self.df_original.loc[self.current_step, 'Low'] # for visualization\n        \n    self.btc_bought = 0\n    self.btc_sold = 0\n    \n    #get action type and amount\n    action_type = action[0]\n    amount = (action[1]*10)\/100\n\n    # Set the current price to a weighted price\n    current_price = self.df_original.loc[self.current_step, \"Weighted_Price\"]\n    \n    reward = 0#set reward to 0\n       \n    #if action type hold or amount 0(hold) \n    if action_type == 0 or amount ==0:\n      self.balance = self.last_balance\n      self.btc_held = self.last_held\n      self.trades.append({'Date' : Date, 'High' : High, 'Low' : Low, 'total': 0, 'percentage':amount, 'type': \"hold\"})\n      reward = (self.balance+(self.btc_held*current_price))-(self.last_balance+(self.last_held*self.last_price))#reward function\n    #else calculate transaction btc bought,sold, balance, held etc\n    elif (action_type == 1 and self.balance > 0) and amount>0:\n      self.btc_bought = self.balance \/ current_price * amount\n      self.balance -=  self.btc_bought * current_price * (1 + self.commission)\n      self.btc_held += self.btc_bought\n      self.trades.append({'Date' : Date, 'High' : High, 'Low' : Low, 'total': self.btc_bought, 'percentage':amount, 'type': \"buy\"})\n      reward = (self.last_balance-self.balance+(self.last_held*current_price))-(self.last_balance+self.balance+(self.last_held*current_price))\n    elif (action_type == 2 and self.btc_held > 0) and amount>0:\n      self.btc_sold = self.btc_held * amount\n      self.balance += self.btc_sold * current_price * (1-self.commission)\n      self.btc_held -= self.btc_sold\n      self.trades.append({'Date' : Date, 'High' : High, 'Low' : Low, 'total': self.btc_sold, 'percentage':amount, 'type': \"sell\"})\n      reward = (self.last_balance+self.balance+(self.last_held*current_price))-(self.last_balance-self.balance+(self.last_held*current_price))\n\n    else:#else if we have less or equal to 0 btc or balance -> done\n      done = self.btc_held<= 0 or self.balance<=0\n    \n    self.net_worth = self.balance + (self.btc_held * current_price)#calculate networth\n    \n    #append orders history for next step\n    self.orders_history.append([self.balance\/10000, self.net_worth\/10000, self.btc_bought\/10000, self.btc_sold\/10000, self.btc_held\/10000])\n   \n    obs = self._next_observation()#get next observation ptss\n    \n    self.past_step = self.current_step\n    \n    #increment step\n    self.current_step += 1\n    \n    self.last_price = current_price\n    \n    self.last_balance = self.balance\n    \n    self.last_held = self.btc_held\n\n    return obs, reward, done, {}\n\n  # Get the data points for next step\n  def _next_observation(self):\n    self.market_history.append([self.df.loc[self.current_step, column] for column in self.columns\n                                  ])\n    obs = np.concatenate((self.market_history, self.orders_history), axis=1)\n    return obs\n\n  # render environment\n  def render(self, mode = \"live\"):\n    if mode == \"live\":\n      Date = self.df_original.loc[self.past_step, 'Date']\n      Open = self.df_original.loc[self.past_step, 'Open']\n      Close = self.df_original.loc[self.past_step, 'Close']\n      High = self.df_original.loc[self.past_step, 'High']\n      Low = self.df_original.loc[self.past_step, 'Low']\n      # Render the environment to the screen\n      self.visualization.render(Date, Open, High, Low, Close, self.net_worth, self.trades)","a238a6f5":"#remove first row due to Nan in norminalized data\ndataset = dataset[1:].reset_index()\ndataset_norm = dataset_norm[1:].reset_index()\n#slice dataset for train and test and drop irrelevant columns \nslice_point = int(len(dataset_norm) * (99.981\/100))\ntrain_df_norm = dataset_norm[:slice_point].drop([\"index\"], axis =1)\ntest_df_norm = dataset_norm[slice_point:].reset_index().drop([ \"level_0\",\"index\"], axis =1)\ntrain_df = dataset[:slice_point].drop([\"index\"], axis =1)\ntest_df = dataset[slice_point:].reset_index().drop([ \"level_0\",\"index\"], axis =1)","75f0a1b9":"# It will check your custom environment and output additional warnings if needed\nfrom stable_baselines3.common.env_checker import check_env\nenv = BitcoinEnv(train_df_norm, train_df, initial_balance = 1000, lookback_window_size = 31,env_steps_size = 500)\n\ncheck_env(env)","8ca4ace8":"len(train_df)","22f50534":"len(test_df_norm)","3483663c":"len(test_df)","264f8470":"#create dummy vec env for train and test df\ntrain_env = DummyVecEnv([lambda: BitcoinEnv(train_df_norm, train_df, \n                         initial_balance = 5000, lookback_window_size = 60,env_steps_size = 1500)])\ntest_env = DummyVecEnv([lambda: BitcoinEnv(test_df_norm, test_df, \n                        initial_balance = 5000, lookback_window_size = 60,env_steps_size = 0)])","dcae7d99":"#create instance of model for learning\nmodel = PPO(\"MlpPolicy\",\n             train_env,\n             #verbose=1, \n             #tensorboard_log=\".\/tensorboard\/\"\n             )\nmodel.learn(total_timesteps=200000)#train model","cc4e3e7f":"#test model on test dataset\nobs = test_env.reset()\nlen_test_df = len(test_df)\nfor i in range(len_test_df-60):\n  action, _states = model.predict(obs)\n  obs, rewards, done, info = test_env.step(action)\n  test_env.render(mode = \"live\")","47e60838":"Next I created the custom open AI gym environment for our specific use, bitcoin trading. ","819474a0":"References: [Reinforcement learning Bitcoin trading bot by Rokas Balsys](https:\/\/pylessons.com\/RL-BTC-BOT-backbone\/)","b54b009d":"Defiine trading graph class for visualization of trading done by bot. The graph displays the net worth, OHCLV candlestick graph and the type of transaction done by the bot.","fa63da1b":"**RL_BITCOIN_BOT**","42e8271c":"This notebook is an attempt at building a BITCOIN trading bot. The dataset is gotten from a kaggle dataset available [here](https:\/\/www.kaggle.com\/mczielinski\/bitcoin-historical-data). The dataset is a minute by minute historical data of bitcoin.  For the bot i created a custom Open AI gym environment and used an an RL algorithm from stable baseline 3.\n"}}