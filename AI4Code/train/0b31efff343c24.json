{"cell_type":{"bf055258":"code","9d93f87e":"code","1cebe145":"code","83cbf38d":"code","9d03bb8a":"code","923504ad":"code","179c2062":"code","bf80de5b":"code","e296a469":"code","f92ffcea":"code","276ab0f6":"code","5ed29d04":"code","49fc77cb":"code","8aaca034":"code","3351ad3e":"code","ca8c2085":"code","1d1ffc5c":"code","329e7fb8":"code","99ca4cbe":"code","62889715":"code","4e38b414":"code","c9f6595e":"code","1084bad3":"code","e2cf2019":"code","67554c58":"code","9bb810d7":"code","8ec8b106":"code","4feafef5":"code","1c0ade54":"code","041d94f5":"code","28d534e0":"code","20bf11b8":"code","c4d38177":"code","4a7b62af":"code","140a0484":"code","891b5961":"code","6208d081":"code","fa6cb479":"code","a60a9eef":"code","c5a7e18e":"code","2abb7eed":"code","c35c0f20":"code","5e9459a1":"code","e30574fb":"code","c99320e3":"code","29a65d41":"code","2cea7e6b":"code","6f0262ef":"markdown","e385b551":"markdown","bca3e326":"markdown","3af58b41":"markdown","f0bb7f50":"markdown","45753da6":"markdown","bd06b3ce":"markdown","6748e50f":"markdown","070247fe":"markdown","05798419":"markdown","1eb15e3a":"markdown","b0d98ba0":"markdown","0dd8a1dd":"markdown","a4d7d987":"markdown","b210b034":"markdown","fdc2f11e":"markdown"},"source":{"bf055258":"import numpy as np\nimport pandas as pd \nimport os\n\ndataset = pd.read_csv('..\/input\/dataset.csv')\ndataset.head()","9d93f87e":"dataset.drop(['gameId', 'queueId', 'seasonId', 'firstBloodAssistPartId'], axis=1, inplace=True)\nfor t in range(1,3):\n    col1 = 'vilemawKillsTeam' + str(t)\n    col2 = 'dominionVictoryScoreTeam' + str(t)\n    dataset.drop([col1, col2], axis=1, inplace=True)\n    for p in range(1, 6):\n        v = 'T' + str(t) + '_P' + str(p)\n        c1 = v + '_participantId'\n        c2 = v + '_pentaKills'\n        c3 = v + '_unrealKills'\n        c4 = v + '_sightWardsBoughtInGame'\n        #print(c1, c2, c3, c4)\n        dataset.drop([c1, c2, c3, c4], axis=1, inplace=True)\nprint(dataset.columns)","1cebe145":"dataset.describe(include = ('O'))\n#20 dados categ\u00f3ricos","83cbf38d":"dataset.isnull().sum().sort_values(ascending = False)","9d03bb8a":"import seaborn as sns\nimport matplotlib.pyplot as plt","923504ad":"num = dataset\nfor t in range(1,3):\n    for p in range(1,6):\n        col1 = \"T\" + str(t) + \"_P\" + str(p) + \"_highestAchievedSeasonTier\"\n        col2 = \"T\" + str(t) + \"_P\" + str(p) + \"_lane\/role\"\n        num.drop(col1, axis= 1, inplace = True)\n        num.drop(col2, axis= 1, inplace = True)\n        \nprint(num.columns)","179c2062":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nsns.heatmap(\n    num.iloc[:,0:8].corr(),\n    annot=True,\n    ax=axes[0]\n)\nposition = 0\nfor x in range (9,28, 7):\n    position = position + 1\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )","bf80de5b":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (30, 56, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","e296a469":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (57, 84, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","f92ffcea":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (85, 112, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","276ab0f6":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (113, 140, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","5ed29d04":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (141, 168, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","49fc77cb":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (169, 196, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","8aaca034":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (197, 224, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","3351ad3e":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (225, 252, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","ca8c2085":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (253, 280, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","1d1ffc5c":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (281, 308, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","329e7fb8":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (309, 336, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","99ca4cbe":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (337, 364, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","62889715":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (365, 392, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","4e38b414":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (393, 420, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","c9f6595e":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (421, 448, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","1084bad3":"f, axes = plt.subplots(4, 1, figsize=(10, 12), sharex=True)\nposition = 0\nfor x in range (449, 476, 7):\n    size = []\n    size.append(1)\n    for i in range(x, x+7):\n        size.append(i)\n    sns.heatmap(\n    num.iloc[:, size].corr(),\n    annot=True,\n    ax=axes[position]\n    )\n    position = position + 1","e2cf2019":"sns.heatmap(\n    num.iloc[:, [1, 477, 478, 479, 480, 481, 482]].corr(),\n    annot=True\n)","67554c58":"for name in num.iloc[:, 0:50].columns:\n    sns.FacetGrid(num, col='win').map(plt.hist, name, bins=20)","9bb810d7":"for name in num.iloc[:, 51:100].columns:\n    sns.FacetGrid(num, col='win').map(plt.hist, name, bins=20)","8ec8b106":"for name in num.iloc[:, 101:150].columns:\n    sns.FacetGrid(num, col='win').map(plt.hist, name, bins=20)","4feafef5":"for name in num.iloc[:, 152:200].columns:\n    sns.FacetGrid(num, col='win').map(plt.hist, name, bins=20)","1c0ade54":"for name in num.iloc[:, 201:250].columns:\n    sns.FacetGrid(num, col='win').map(plt.hist, name, bins=20)","041d94f5":"for name in num.iloc[:, 251:300].columns:\n    sns.FacetGrid(num, col='win').map(plt.hist, name, bins=20)","28d534e0":"for name in num.iloc[:, 301:350].columns:\n    sns.FacetGrid(num, col='win').map(plt.hist, name, bins=20)","20bf11b8":"for name in num.iloc[:, 351:400].columns:\n    sns.FacetGrid(num, col='win').map(plt.hist, name, bins=20)","c4d38177":"for name in num.iloc[:, 401:450].columns:\n    sns.FacetGrid(num, col='win').map(plt.hist, name, bins=20)","4a7b62af":"for name in num.iloc[:, 451:483].columns:\n    sns.FacetGrid(num, col='win').map(plt.hist, name, bins=20)","140a0484":"cols = []\ncols.append('win')\ncols.append('firstBlood')\ncols.append('firstTower')\ncols.append('firstInhibitor')\ncols.append('firstBaron')\ncols.append('firstDragon')\ncols.append('firstRiftHerald')\nfor t in range(1, 3):\n    cols.append('towerKillsTeam' + str(t))\n    cols.append('inhibitorKillsTeam' + str(t))\n    cols.append('baronKillsTeam' + str(t))\n    cols.append('riftHeraldKillsTeam' + str(t))\n    for p in range(1, 6):\n        part = 'T' + str(t) + '_P' + str(p) + '_'\n        cols.append(part + 'kills')\n        cols.append(part + 'deaths')\n        cols.append(part + 'assists')\n        cols.append(part + 'longestTimeSpentLiving')\n        cols.append(part + 'totalDamageDealtToChampions')\n        cols.append(part + 'totalHeal')\n        cols.append(part + 'damageSelfMitigated')\n        cols.append(part + 'damageDealtToObjectives')\n        cols.append(part + 'damageDealtToTurrets')\n        cols.append(part + 'visionScore')\n        cols.append(part + 'timeCCingOthers')\n        cols.append(part + 'totalDamageTaken')\n        cols.append(part + 'goldEarned')\n        cols.append(part + 'turretKills')\n        cols.append(part + 'inhibitorKills')\n        cols.append(part + 'neutralMinionsKilled')\n        cols.append(part + 'neutralMinionsKilledEnemyJungle')\n        cols.append(part + 'totalTimeCrowdControlDealt')\n        cols.append(part + 'wardsPlaced')\n        cols.append(part + 'wardsKilled')","891b5961":"train = dataset.loc[:, cols]\nprint(train.columns)","6208d081":"# x - atributos\n# y - classe\nx = train.drop('win', axis=1)\ny = train['win']","fa6cb479":"print(x.shape)\nprint(y.shape)","a60a9eef":"\ny = y.replace(1, 0)\ny = y.replace(2, 1)\nprint(y)","c5a7e18e":"plt.scatter(y.iloc[:],\n            y.iloc[:],\n            c=list(np.array(y).ravel()),\n            s=15,\n            cmap='bwr')","2abb7eed":"from sklearn.model_selection import train_test_split\n\n# divide o dataset de trainamento em treinamento e teste, separando 25% em teste\n# x = atributos e y = classes\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25)","c35c0f20":"print(x_train.shape, y_train.shape, x_test.shape, y_test.shape)","5e9459a1":"from sklearn.tree import DecisionTreeClassifier\n# cria a arvore\ntree = DecisionTreeClassifier(criterion='gini', splitter='random', max_depth=3, random_state=0)\n#cria o modelo\nmodel = tree.fit(x_train, y_train)","e30574fb":"from sklearn.metrics import accuracy_score\n# tenta predicao dos dados de teste \npredict = model.predict(x_test)","c99320e3":"acc = accuracy_score(y_test, predict)\nprint(\"A probabilidade de acerto \u00e9: \", format(acc))","29a65d41":"import keras\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout\n\nmodel = Sequential()\n#primeira camada\n# 214+1 \/ 2 = 107\nmodel.add(Dense(units=108, init='uniform', activation='relu', input_dim=214))\nmodel.add(Dropout(p=0.1))\nmodel.add(Dense(units=108, init='uniform', activation='relu'))\nmodel.add(Dropout(p=0.1))\nmodel.add(Dense(units=108, init='uniform', activation='relu'))\nmodel.add(Dropout(p=0.1))\nmodel.add(Dense(units=1, init='uniform', activation='sigmoid'))\n\nmodel.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n\nmodel.fit(x_train, y_train, batch_size=100, epochs=400, validation_data=(x_test, y_test))","2cea7e6b":"score = model.evaluate(x_test, y_test, verbose=0)\nprint('Erro:', score[0])\nprint('Precis\u00e3o:', score[1]*100, \"%\" )","6f0262ef":"\n\n<h4>Metodologia<\/h4>\n\n*     Defini\u00e7\u00e3o do problema\n*     Dados do problema\n*     Carregamento dos dados\n*     Analise e pr\u00e9-processamento dos dados\n*     Modelo\n*     visualiza\u00e7\u00e3o e an\u00e1lise dos resultados\n*     Ajustes dos par\u00e2metros\n\n","e385b551":"<h1>1. Carregamento dos Dados<\/h1>","bca3e326":"<h2>2.1. Retirando dados que nao serao usados<\/h2>","3af58b41":"Estes dados s\u00e3o aqueles como identificadores(id) que s\u00e3o desnecess\u00e1rios para o problema em quest\u00e3o e dados que em sua totalidade s\u00e3o nulos e que n\u00e3o teriam efeito positivo","f0bb7f50":"<h3>MPL<\/h3>\nTentando...","45753da6":"<h3>Histograma<\/h3>","bd06b3ce":"<h2>2.3. Vizualiza\u00e7\u00e3o dos Dados<\/h2>","6748e50f":"<h1>2. An\u00e1lise e Pr\u00e9-Processamento dos Dados<\/h1>","070247fe":"<h2>2.2. Vizualizando dados categ\u00f3ricos e nulos<\/h2>","05798419":"<h3>Heatmap<\/h3>","1eb15e3a":"<h3>\u00c1rvore de Decis\u00e3o Simples<\/h3>","b0d98ba0":"<h2>2.5. Escolhendo dados relevantes<\/h2>\n\nAtraves da vizualizacao dos dados pelos graficos, pode-se notar que geralmente os dados que influenciam na vitoria ou derrota do time sao os que auxiliam na conquista de objetivos junto com o controle de grupo e do dano recebido.\n\nDados que nao podem faltar: \n* firstBlood\n* firstTower\n* firstInhibitor\n* firstBaron\n* firstDragon\n* firstRiftHerald\n* towerKillsTeam\n* inhibitorKillsTeam\n* baronKillsTeam\n* riftHeraldKillsTeam\n\nDados que mostraram relevancia:\n* kills\n* deaths\n* assists\n* longestTimeSpentLiving\n* totalDamageDealtToChampions\n* totalHeal\n* damageSelfMitigated\n* damageDealtToObjectives\n* timeCCingOthers\n* totalDamageTaken\n* goldEarned\n* turretKills\n* inhibitorKills\n* neutralMinionsKilled\n* neutralMinionsKilledEnemyjungle\n\nDados com certa relevancia, mas precisa rever a necessidade de se usar:\n* largestCriticalStrike\n* totalUnitsHealed\n* damageDealtToTurrets\n* visionScore\n* goldSpent\n* totalMinionsKilled\n* totalTimeCrowdControlDealt\n* champLevel\n* visionWardsBoughtInGame\n* wardsPlaced\n* wardsKilled\n* spell1Id\n* spell2Id","0dd8a1dd":"<h2>3.3. Criando o modelo<\/h2>","a4d7d987":"<h2>3.1. Separando dados para o modelo<\/h2>","b210b034":"<h2>3.2. Separando dados de treinamento e teste<\/h2>","fdc2f11e":"<h1>3. Modelo<\/h1>"}}