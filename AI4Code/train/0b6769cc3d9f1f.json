{"cell_type":{"4e56b2be":"code","ab93dc1d":"code","a8980638":"code","fcc9dec9":"code","c04d2bbe":"code","ae440a13":"code","7bbac531":"code","2e6afc72":"code","e234f277":"code","1d936dff":"code","ef42436b":"code","5c893153":"code","b1b12341":"code","6b085730":"code","95712cd1":"code","5408e7b4":"code","b6a338dd":"code","6e8b157c":"code","a8b0bb92":"code","eabdff27":"code","d83b8231":"code","953b52fe":"code","e9688a31":"code","a0525bd7":"code","9d9fd15b":"code","f6e1a5c4":"code","b42579ee":"code","e39cb834":"code","aa44bd91":"code","9ff109dc":"code","af1d06c0":"code","d5a4fd58":"code","e255fd32":"code","9a653378":"code","b153f5db":"code","0a6054f3":"code","9ad73810":"code","a5ae3b29":"code","b9fc9360":"code","6049f2d8":"code","b52fe0c3":"code","5f6ad8ec":"code","2ff2acbb":"code","5e329825":"code","5871cc77":"code","557cd729":"code","c9ce588d":"code","5509c74b":"code","bc716ff8":"code","4a46fba9":"code","f6ee5090":"code","998d4b8a":"code","3f562729":"code","e640d2f9":"code","40b15a77":"code","0e408526":"code","fad46856":"code","46055e6d":"code","5cd6b934":"code","b9301d57":"code","a538262d":"code","6659d073":"code","ac4867ce":"code","273336dd":"code","86ba2903":"code","8931ce52":"code","d4c9bdf8":"code","7077f33e":"code","ae2bffe8":"code","cef91584":"code","1ac376bf":"code","6cae668b":"code","90635a61":"code","1004d9e2":"code","ad5ecd13":"code","cb27120a":"code","de86027f":"code","dc8e7b68":"code","dd45f654":"code","f5679937":"code","982f422e":"code","5da6d9e0":"code","87a9a1ac":"code","793275e4":"code","15ed9214":"code","7d6e37e7":"code","16aa5d78":"code","4cce0e76":"code","c9480025":"code","da5baf26":"code","4df06486":"code","8e843c65":"code","12176bd3":"code","f317f1b2":"code","88204ded":"code","83552739":"code","5aaa432e":"code","be5325d1":"code","7508066a":"code","2eeb2642":"code","2a7b18e4":"code","7bf29dff":"code","e6cb4e19":"code","311a4f96":"code","66b63ed9":"code","66f0d365":"code","64fd21be":"code","152cfe14":"code","a5f70220":"code","58927a10":"code","d86e62b3":"code","4f70b887":"code","6049e078":"markdown","7daeb87f":"markdown","17810ccb":"markdown","ec0e6320":"markdown","9c581e91":"markdown","c035810f":"markdown","818e58a8":"markdown","453ae89a":"markdown","437bff4f":"markdown","2c4e3292":"markdown","158f20b0":"markdown","56ffed61":"markdown","bea5d9d6":"markdown","f2ceb760":"markdown","06f7eac2":"markdown","ac3f26f2":"markdown","8344f81c":"markdown","5fcab286":"markdown","7350af5b":"markdown","e09e5a3d":"markdown","c224d2d2":"markdown","678cb04c":"markdown","9c22da0d":"markdown","d9de4057":"markdown","dd14d931":"markdown","b8d83dd0":"markdown","4fa773d4":"markdown","8895362b":"markdown","dada9c2d":"markdown","a1dbf3ee":"markdown","2b50bbec":"markdown","08326b98":"markdown","4f96f516":"markdown","f614fe08":"markdown","198162b8":"markdown","eb845963":"markdown","70f0cb6e":"markdown","344be98a":"markdown","db6edf52":"markdown","64443b13":"markdown","c4f00f53":"markdown","90bb1b24":"markdown","590f45ed":"markdown","ee935dde":"markdown","066769ab":"markdown","52f5cf77":"markdown","c338ca28":"markdown","a6603728":"markdown","89712e1b":"markdown","64567922":"markdown","9e8ad628":"markdown","599e14ac":"markdown","09a86773":"markdown","8c58a662":"markdown","6168db8f":"markdown","43528c74":"markdown","1f24d5d6":"markdown","0c3666e9":"markdown","a1f69937":"markdown","6f09b956":"markdown","32b8c873":"markdown","a4b3b2f7":"markdown","95dc03d3":"markdown","d7bb2d89":"markdown","5c446627":"markdown","80384734":"markdown","72b165b6":"markdown","9ad3de31":"markdown","62cf414c":"markdown"},"source":{"4e56b2be":"from datetime import datetime\ntime_format = \"%d%b%Y %H:%M\"\ndatetime.now().strftime(time_format)","ab93dc1d":"from datetime import timedelta\nfrom dateutil.relativedelta import relativedelta\nimport os\nfrom pprint import pprint\nfrom fbprophet import Prophet\nfrom fbprophet.plot import add_changepoints_to_plot\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\nfrom matplotlib.ticker import ScalarFormatter\n%matplotlib inline\nimport numpy as np\nimport optuna\noptuna.logging.disable_default_handler()\nimport pandas as pd\npd.plotting.register_matplotlib_converters()\nimport seaborn as sns\nfrom scipy.integrate import solve_ivp","a8980638":"np.random.seed(2019)\nos.environ[\"PYTHONHASHSEED\"] = \"2019\"","fcc9dec9":"plt.style.use(\"seaborn-ticks\")\nplt.rcParams[\"xtick.direction\"] = \"in\"\nplt.rcParams[\"ytick.direction\"] = \"in\"\nplt.rcParams[\"font.size\"] = 11.5\nplt.rcParams[\"figure.figsize\"] = (9, 6)","c04d2bbe":"population_date = \"06Mar2020\"\n_dict = {\n    \"Global\": \"7 738 323 220\",\n    \"China\": \"1 405 371 596\",\n    \"Japan\": \"125 406 227\",\n    \"South Korea\": \"51 277 160\",\n    \"Italy\": \"59 813 196\",\n    \"Iran\": \"83 473 631\",\n}\npopulation_dict = {k: int(v.replace(\" \", \"\")) for (k, v) in _dict.items()}\ndf = pd.io.json.json_normalize(population_dict)\ndf.index = [f\"Total population on {population_date}\"]\ndf","ae440a13":"for dirname, _, filenames in os.walk(\"\/kaggle\/input\"):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","7bbac531":"def line_plot(df, title, ylabel=\"Cases\", h=None, v=None, xlim=(None, None), ylim=(0, None), math_scale=True):\n    \"\"\"\n    Show chlonological change of the data.\n    \"\"\"\n    ax = df.plot()\n    if math_scale:\n        ax.yaxis.set_major_formatter(ScalarFormatter(useMathText=True))\n        ax.ticklabel_format(style=\"sci\",  axis=\"y\",scilimits=(0, 0))\n    ax.set_title(title)\n    ax.set_xlabel(None)\n    ax.set_ylabel(ylabel)\n    ax.set_xlim(*xlim)\n    ax.set_ylim(*ylim)\n    ax.legend(bbox_to_anchor=(1.02, 0), loc=\"lower left\", borderaxespad=0)\n    if h is not None:\n        ax.axhline(y=h, color=\"black\", linestyle=\"--\")\n    if v is not None:\n        ax.axvline(x=v, color=\"black\", linestyle=\"--\")\n    plt.tight_layout()\n    plt.show()","2e6afc72":"def create_target_df(ncov_df, total_population, places=None, excluded_places=None):\n    \"\"\"\n    Select the records of the palces, calculate the number of susceptible people,\n     and calculate the elapsed time [day] from the start date of the target dataframe.\n    @ncov_df <pd.DataFrame>: the clean data\n    @total_population <int>: total population in the places\n    @places <list[tuple(<str\/None>, <str\/None>)]: the list of places\n        - if the list is None, all data will be used\n        - (str, str): both of country and province are specified\n        - (str, None): only country is specified\n        - (None, str) or (None, None): Error\n    @excluded_places <list[tuple(<str\/None>, <str\/None>)]: the list of excluded places\n        - if the list is None, all data in the \"places\" will be used\n        - (str, str): both of country and province are specified\n        - (str, None): only country is specified\n        - (None, str) or (None, None): Error\n    @return <tuple(2 objects)>:\n        - 1. start_date <pd.Timestamp>: the start date of the selected records\n        - 2. target_df <pd.DataFrame>:\n            - column T: elapsed time [min] from the start date of the dataset\n            - column Susceptible: the number of patients who are in the palces but not infected\/recovered\/died\n            - column Infected: the number of infected cases\n            - column Recovered: the number of recovered cases\n            - column Deaths: the number of death cases\n    \"\"\"\n    # Select the target records\n    df = ncov_df.copy()\n    c_series = ncov_df[\"Country\"]\n    p_series = ncov_df[\"Province\"]\n    if places is not None:\n        df = pd.DataFrame(columns=ncov_df.columns)\n        for (c, p) in places:\n            if c is None:\n                raise Exception(\"places: Country must be specified!\")\n            if p is None:\n                new_df = ncov_df.loc[c_series == c, :]\n            else:\n                new_df = ncov_df.loc[(c_series == c) & (p_series == p), :]\n            df = pd.concat([df, new_df], axis=0)\n    if excluded_places is not None:\n        for (c, p) in excluded_places:\n            if c is None:\n                raise Exception(\"excluded_places: Country must be specified!\")\n            if p is None:\n                df = df.loc[c_series != c, :]\n            else:\n                c_df = df.loc[(c_series == c) & (p_series != p), :]\n                other_df = df.loc[c_series != c, :]\n                df = pd.concat([c_df, other_df], axis=0)\n    df = df.groupby(\"Date\").sum().reset_index()\n    start_date = df.loc[df.index[0], \"Date\"]\n    # column T\n    df[\"T\"] = ((df[\"Date\"] - start_date).dt.total_seconds() \/ 60).astype(int)\n    # coluns except T\n    df[\"Susceptible\"] = total_population - df[\"Infected\"] - df[\"Recovered\"] - df[\"Deaths\"]\n    response_variables = [\"Susceptible\", \"Infected\", \"Recovered\", \"Deaths\"]\n    # Return\n    target_df = df.loc[:, [\"T\", *response_variables]]\n    return (start_date, target_df)","e234f277":"def simulation(model, initials, step_n, **params):\n    \"\"\"\n    Solve ODE of the model.\n    @model <ModelBase>: the model\n    @initials <tuple[float]>: the initial values\n    @step_n <int>: the number of steps\n    \"\"\"\n    tstart, dt, tend = 0, 1, step_n\n    sol = solve_ivp(\n        fun=model(**params),\n        # Implicit Runge-Kutta method of the Radau IIA family of order 5\n        # method=\"Radau\",\n        t_span=[tstart, tend],\n        y0=np.array(initials, dtype=np.float64),\n        t_eval=np.arange(tstart, tend + dt, dt)\n    )\n    t_df = pd.Series(data=sol[\"t\"], name=\"t\")\n    y_df = pd.DataFrame(data=sol[\"y\"].T.copy(), columns=model.VARIABLES)\n    sim_df = pd.concat([t_df, y_df], axis=1)\n    return sim_df","1d936dff":"class Estimater(object):\n    def __init__(self, model, ncov_df, total_population, places=None, excluded_places=None):\n        \"\"\"\n        Set training data.\n        @model <ModelBase>: the model\n        @the other params: See the function named create_target_df()\n        \"\"\"\n        dataset = model.create_dataset(\n            ncov_df, total_population, places=places, excluded_places=excluded_places\n        )\n        self.start_time, self.initials, self.Tend, self.train_df = dataset\n        self.total_population = total_population\n        self.model = model\n        self.param_dict = model.param_dict()\n        self.study = None\n        self.optimize_df = None\n\n    def run(self, n_trials=700):\n        \"\"\"\n        Try estimation (optimization of parameters and tau).\n        @n_trials <int>: the number of trials\n        \"\"\"\n        if self.study is None:\n            self.study = optuna.create_study(direction=\"minimize\")\n        self.study.optimize(\n            lambda x: self.objective(x),\n            n_trials=n_trials,\n            n_jobs=-1\n        )\n        param_dict = self.study.best_params.copy()\n        param_dict[\"R0\"] = self.calc_r0()\n        param_dict[\"score\"] = self.score()\n        param_dict.update(self.calc_days_dict())\n        self.param_dict = param_dict.copy()\n        return param_dict\n\n    def history_df(self):\n        \"\"\"\n        Return the hsitory of optimization.\n        @return <pd.DataFrame>\n        \"\"\"\n        optimize_df = self.study.trials_dataframe()\n        optimize_df[\"time[s]\"] = optimize_df[\"datetime_complete\"] - optimize_df[\"datetime_start\"]\n        optimize_df[\"time[s]\"] = optimize_df[\"time[s]\"].dt.total_seconds()\n        self.optimize_df = optimize_df.drop([\"datetime_complete\", \"datetime_start\"], axis=1)\n        return self.optimize_df.sort_values(\"value\", ascending=True)\n\n    def history_graph(self):\n        \"\"\"\n        Show the history of parameter search using pair-plot.\n        \"\"\"\n        if self.optimize_df is None:\n            self.history_df()\n        df = self.optimize_df.copy()\n        sns.pairplot(df.loc[:, df.columns.str.startswith(\"params_\")], diag_kind=\"kde\", markers=\"+\")\n        plt.show()\n\n    def objective(self, trial):\n        # Time\n        tau = trial.suggest_int(\"tau\", 1, 1440)\n        train_df_divided = self.train_df.copy()\n        train_df_divided[\"t\"] = (train_df_divided[\"T\"] \/ tau).astype(int)\n        # Parameters\n        p_dict = dict()\n        for (name, info) in self.param_dict.items():\n            if info[0] == \"float\":\n                param = trial.suggest_uniform(name, info[1], info[2])\n            else:\n                param = trial.suggest_int(name, info[1], info[2])\n            p_dict[name] = param\n        # Simulation\n        t_end = train_df_divided.loc[train_df_divided.index[-1], \"t\"]\n        sim_df = simulation(self.model, self.initials, step_n=t_end, **p_dict)\n        return self.error_f(train_df_divided, sim_df)\n\n    def error_f(self, train_df_divided, sim_df):\n        \"\"\"\n        We need to minimize the difference of the observed values and estimated values.\n        This function calculate the difference of the estimated value and obsereved value.\n        \"\"\"\n        df = pd.merge(train_df_divided, sim_df, on=\"t\", suffixes=(\"_observed\", \"_estimated\"))\n        diffs = [\n            # Weighted Average: the recent data is more important\n            p * np.average(abs(df[f\"{v}_observed\"] - df[f\"{v}_estimated\"]), weights=df[\"t\"])\n            for (p, v) in zip(self.model.PRIORITIES, self.model.VARIABLES)\n        ]\n        return sum(diffs) * self.total_population\n\n    def compare_df(self):\n        \"\"\"\n        Show the taining data and simulated data in one dataframe.\n        \n        \"\"\"\n        est_dict = self.study.best_params.copy()\n        tau = est_dict[\"tau\"]\n        est_dict.pop(\"tau\")\n        observed_df = self.train_df.drop(\"T\", axis=1)\n        observed_df[\"t\"] = (self.train_df[\"T\"] \/ tau).astype(int)\n        t_end = observed_df.loc[observed_df.index[-1], \"t\"]\n        sim_df = simulation(self.model, self.initials, step_n=t_end, **est_dict)\n        df = pd.merge(observed_df, sim_df, on=\"t\", suffixes=(\"_observed\", \"_estimated\"))\n        df = df.set_index(\"t\")\n        return df\n\n    def compare_graph(self):\n        \"\"\"\n        Compare obsereved and estimated values in graphs.\n        \"\"\"\n        df = self.compare_df()\n        val_len = len(self.model.VARIABLES)\n        fig, axes = plt.subplots(ncols=1, nrows=val_len, figsize=(9, 6 * val_len \/ 2))\n        for (ax, v) in zip(axes.ravel()[1:], self.model.VARIABLES[1:]):\n            df[[f\"{v}_observed\", f\"{v}_estimated\"]].plot.line(\n                ax=ax, ylim=(0, None), sharex=True,\n                title=f\"{self.model.NAME}: Comparison of observed\/estimated {v}(t)\"\n            )\n            ax.yaxis.set_major_formatter(ScalarFormatter(useMathText=True))\n            ax.ticklabel_format(style=\"sci\",  axis=\"y\",scilimits=(0, 0))\n            ax.legend(bbox_to_anchor=(1.02, 0), loc=\"lower left\", borderaxespad=0)\n        for v in self.model.VARIABLES[1:]:\n            df[f\"{v}_diff\"] = df[f\"{v}_observed\"] - df[f\"{v}_estimated\"]\n            df[f\"{v}_diff\"].plot.line(\n                ax=axes.ravel()[0], sharex=True,\n                title=f\"{self.model.NAME}: observed - estimated\"\n            )\n        axes.ravel()[0].axhline(y=0, color=\"black\", linestyle=\"--\")\n        axes.ravel()[0].yaxis.set_major_formatter(ScalarFormatter(useMathText=True))\n        axes.ravel()[0].ticklabel_format(style=\"sci\",  axis=\"y\",scilimits=(0, 0))\n        axes.ravel()[0].legend(bbox_to_anchor=(1.02, 0), loc=\"lower left\", borderaxespad=0)\n        fig.tight_layout()\n        fig.show()\n    \n    def calc_r0(self):\n        \"\"\"\n        Calculate R0.\n        \"\"\"\n        est_dict = self.study.best_params.copy()\n        est_dict.pop(\"tau\")\n        model_instance = self.model(**est_dict)\n        return model_instance.calc_r0()\n\n    def calc_days_dict(self):\n        \"\"\"\n        Calculate 1\/beta etc.\n        \"\"\"\n        est_dict = self.study.best_params.copy()\n        tau = est_dict[\"tau\"]\n        est_dict.pop(\"tau\")\n        model_instance = self.model(**est_dict)\n        return model_instance.calc_days_dict(tau)\n\n    def predict_df(self, step_n):\n        \"\"\"\n        Predict the values in the future.\n        @step_n <int>: the number of steps\n        @return <pd.DataFrame>: predicted data for measurable variables.\n        \"\"\"\n        est_dict = self.study.best_params.copy()\n        tau = est_dict[\"tau\"]\n        est_dict.pop(\"tau\")\n        df = simulation(self.model, self.initials, step_n=step_n, **est_dict)\n        df[\"Time\"] = (df[\"t\"] * tau).apply(lambda x: timedelta(minutes=x)) + self.start_time\n        df = df.set_index(\"Time\").drop(\"t\", axis=1)\n        df = (df * self.total_population).astype(int)\n        upper_cols = [n.upper() for n in df.columns]\n        df.columns = upper_cols\n        df = self.model.calc_variables_reverse(df).drop(upper_cols, axis=1)\n        return df\n\n    def predict_graph(self, step_n, name, excluded_cols=None):\n        \"\"\"\n        Predict the values in the future and create a figure.\n        @step_n <int>: the number of steps\n        @name <str>: place name\n        @excluded_cols <list[str]>: the excluded columns in the figure\n        \"\"\"\n        df = self.predict_df(step_n=step_n)\n        if excluded_cols is not None:\n            df = df.drop(excluded_cols, axis=1)\n        r0 = self.param_dict[\"R0\"]\n        title = f\"Prediction in {name} with {self.model.NAME} model: R0 = {r0}\"\n        line_plot(df, title, v= datetime.today(), h=self.total_population)\n\n    def score(self):\n        \"\"\"\n        Return the sum of differences of observed and estimated values devided by the number of steps.\n        \"\"\"\n        variables = self.model.VARIABLES[:]\n        compare_df = self.compare_df()\n        score = 0\n        for v in variables:\n            score += abs(compare_df[f\"{v}_observed\"] - compare_df[f\"{v}_estimated\"]).sum()\n        score = score \/ len(compare_df)\n        return score","ef42436b":"class ModelBase(object):\n    NAME = \"Model\"\n    VARIABLES = [\"x\"]\n    PRIORITIES = np.array([1])\n\n    @classmethod\n    def param_dict(cls):\n        \"\"\"\n        Define parameters without tau. This function should be overwritten.\n        @return <dict[name]=(type, min, max):\n            @type <str>: \"float\" or \"int\"\n            @min <float\/int>: min value\n            @max <float\/int>: max value\n        \"\"\"\n        param_dict = dict()\n        return param_dict\n\n    @staticmethod\n    def calc_variables(df):\n        \"\"\"\n        Calculate the variables of the model.\n        This function should be overwritten.\n        @df <pd.DataFrame>\n        @return <pd.DataFrame>\n        \"\"\"\n        return df\n\n    @staticmethod\n    def calc_variables_reverse(df):\n        \"\"\"\n        Calculate measurable variables using the variables of the model.\n        This function should be overwritten.\n        @df <pd.DataFrame>\n        @return <pd.DataFrame>\n        \"\"\"\n        return df\n\n    @classmethod\n    def create_dataset(cls, ncov_df, total_population, places=None, excluded_places=None):\n        \"\"\"\n        Create dataset with the model-specific varibles.\n        The variables will be divided by total population.\n        The column names (not include T) will be lower letters.\n        @params: See the function named create_target_df()\n        @return <tuple(objects)>:\n            - start_date <pd.Timestamp>\n            - initials <tuple(float)>: the initial values\n            - Tend <int>: the last value of T\n            - df <pd.DataFrame>: the dataset\n        \"\"\"\n        start_date, target_df = create_target_df(\n            ncov_df, total_population, places=places, excluded_places=excluded_places\n        )\n        df = cls.calc_variables(target_df).set_index(\"T\") \/ total_population\n        df.columns = [n.lower() for n in df.columns]\n        initials = df.iloc[0, :].values\n        df = df.reset_index()\n        Tend = df.iloc[-1, 0]\n        return (start_date, initials, Tend, df)\n\n    def calc_r0(self):\n        \"\"\"\n        Calculate R0. This function should be overwritten.\n        \"\"\"\n        return None\n\n    def calc_days_dict(self, tau):\n        \"\"\"\n        Calculate 1\/beta [day] etc.\n        This function should be overwritten.\n        @param tau <int>: tau value [hour]\n        \"\"\"\n        return dict()","5c893153":"class SIR(ModelBase):\n    NAME = \"SIR\"\n    VARIABLES = [\"x\", \"y\", \"z\"]\n    PRIORITIES = np.array([1, 1, 1])\n\n    def __init__(self, rho, sigma):\n        super().__init__()\n        self.rho = float(rho)\n        self.sigma = float(sigma)\n\n    def __call__(self, t, X):\n        # x, y, z = [X[i] for i in range(len(self.VARIABLES))]\n        # dxdt = - self.rho * x * y\n        # dydt = self.rho * x * y - self.sigma * y\n        # dzdt = self.sigma * y\n        dxdt = - self.rho * X[0] * X[1]\n        dydt = self.rho * X[0] * X[1] - self.sigma * X[1]\n        dzdt = self.sigma * X[1]\n        return np.array([dxdt, dydt, dzdt])\n\n    @classmethod\n    def param_dict(cls):\n        param_dict = super().param_dict()\n        param_dict[\"rho\"] = (\"float\", 0, 1)\n        param_dict[\"sigma\"] = (\"float\", 0, 1)\n        return param_dict\n\n    @staticmethod\n    def calc_variables(df):\n        df[\"X\"] = df[\"Susceptible\"]\n        df[\"Y\"] = df[\"Infected\"]\n        df[\"Z\"] = df[\"Recovered\"] + df[\"Deaths\"]\n        return df.loc[:, [\"T\", \"X\", \"Y\", \"Z\"]]\n\n    @staticmethod\n    def calc_variables_reverse(df):\n        df[\"Susceptible\"] = df[\"X\"]\n        df[\"Infected\"] = df[\"Y\"]\n        df[\"Recovered\/Deaths\"] = df[\"Z\"]\n        return df\n\n    def calc_r0(self):\n        r0 = self.rho \/ self.sigma\n        return round(r0, 2)\n\n    def calc_days_dict(self, tau):\n        _dict = dict()\n        _dict[\"1\/beta [day]\"] = int(tau \/ 24 \/ 60 \/ self.rho)\n        _dict[\"1\/gamma [day]\"] = int(tau \/ 24 \/ 60 \/ self.sigma)\n        return _dict","b1b12341":"class SIRD(ModelBase):\n    NAME = \"SIR-D\"\n    VARIABLES = [\"x\", \"y\", \"z\", \"w\"]\n    PRIORITIES = np.array([1, 10, 10, 1])\n\n    def __init__(self, kappa, rho, sigma):\n        super().__init__()\n        self.kappa = float(kappa)\n        self.rho = float(rho)\n        self.sigma = float(sigma)\n\n    def __call__(self, t, X):\n        # x, y, z, w = [X[i] for i in range(len(self.VARIABLES))]\n        # dxdt = - self.rho * x * y\n        # dydt = self.rho * x * y - (self.sigma + self.kappa) * y\n        # dzdt = self.sigma * y\n        # dwdt = self.kappa * y\n        dxdt = - self.rho * X[0] * X[1]\n        dydt = self.rho * X[0] * X[1] - (self.sigma + self.kappa) * X[1]\n        dzdt = self.sigma * X[1]\n        dwdt = self.kappa * X[1]\n        return np.array([dxdt, dydt, dzdt, dwdt])\n\n    @classmethod\n    def param_dict(cls):\n        param_dict = super().param_dict()\n        param_dict[\"kappa\"] = (\"float\", 0, 1)\n        param_dict[\"rho\"] = (\"float\", 0, 1)\n        param_dict[\"sigma\"] = (\"float\", 0, 1)\n        return param_dict\n\n    @staticmethod\n    def calc_variables(df):\n        df[\"X\"] = df[\"Susceptible\"]\n        df[\"Y\"] = df[\"Infected\"]\n        df[\"Z\"] = df[\"Recovered\"]\n        df[\"W\"] = df[\"Deaths\"]\n        return df.loc[:, [\"T\", \"X\", \"Y\", \"Z\", \"W\"]]\n\n    @staticmethod\n    def calc_variables_reverse(df):\n        df[\"Susceptible\"] = df[\"X\"]\n        df[\"Infected\"] = df[\"Y\"]\n        df[\"Recovered\"] = df[\"Z\"]\n        df[\"Deaths\"] = df[\"W\"]\n        return df\n\n    def calc_r0(self):\n        r0 = self.rho \/ (self.sigma + self.kappa)\n        return round(r0, 2)\n\n    def calc_days_dict(self, tau):\n        _dict = dict()\n        _dict[\"1\/alpha2 [day]\"] = int(tau \/ 24 \/ 60 \/ self.kappa)\n        _dict[\"1\/beta [day]\"] = int(tau \/ 24 \/ 60 \/ self.rho)\n        _dict[\"1\/gamma [day]\"] = int(tau \/ 24 \/ 60 \/ self.sigma)\n        return _dict","6b085730":"class SIRF(ModelBase):\n    NAME = \"SIR-F\"\n    VARIABLES = [\"x\", \"y\", \"z\", \"w\"]\n    PRIORITIES = np.array([1, 10, 10, 1])\n\n    def __init__(self, theta, kappa, rho, sigma):\n        super().__init__()\n        self.theta = float(theta)\n        self.kappa = float(kappa)\n        self.rho = float(rho)\n        self.sigma = float(sigma)\n\n    def __call__(self, t, X):\n        # x, y, z, w = [X[i] for i in range(len(self.VARIABLES))]\n        # dxdt = - self.rho * x * y\n        # dydt = self.rho * (1 - self.theta) * x * y - (self.sigma + self.kappa) * y\n        # dzdt = self.sigma * y\n        # dwdt = self.rho * self.theta * x * y + self.kappa * y\n        dxdt = - self.rho * X[0] * X[1]\n        dydt = self.rho * (1 - self.theta) * X[0] * X[1] - (self.sigma + self.kappa) * X[1]\n        dzdt = self.sigma * X[1]\n        dwdt = self.rho * self.theta * X[0] * X[1] + self.kappa * X[1]\n        return np.array([dxdt, dydt, dzdt, dwdt])\n\n    @classmethod\n    def param_dict(cls):\n        param_dict = super().param_dict()\n        param_dict[\"theta\"] = (\"float\", 0, 1)\n        param_dict[\"kappa\"] = (\"float\", 0, 1)\n        param_dict[\"rho\"] = (\"float\", 0, 1)\n        param_dict[\"sigma\"] = (\"float\", 0, 1)\n        return param_dict\n\n    @staticmethod\n    def calc_variables(df):\n        df[\"X\"] = df[\"Susceptible\"]\n        df[\"Y\"] = df[\"Infected\"]\n        df[\"Z\"] = df[\"Recovered\"]\n        df[\"W\"] = df[\"Deaths\"]\n        return df.loc[:, [\"T\", \"X\", \"Y\", \"Z\", \"W\"]]\n\n    @staticmethod\n    def calc_variables_reverse(df):\n        df[\"Susceptible\"] = df[\"X\"]\n        df[\"Infected\"] = df[\"Y\"]\n        df[\"Recovered\"] = df[\"Z\"]\n        df[\"Deaths\"] = df[\"W\"]\n        return df\n\n    def calc_r0(self):\n        r0 = self.rho * (1 - self.theta) \/ (self.sigma + self.kappa)\n        return round(r0, 2)\n\n    def calc_days_dict(self, tau):\n        _dict = dict()\n        _dict[\"alpha1 [-]\"] = round(self.theta, 2)\n        _dict[\"1\/alpha2 [day]\"] = int(tau \/ 24 \/ 60 \/ self.kappa)\n        _dict[\"1\/beta [day]\"] = int(tau \/ 24 \/ 60 \/ self.rho)\n        _dict[\"1\/gamma [day]\"] = int(tau \/ 24 \/ 60 \/ self.sigma)\n        return _dict","95712cd1":"class SIRFV(ModelBase):\n    NAME = \"SIR-FV\"\n    VARIABLES = [\"x\", \"y\", \"z\", \"w\"]\n    PRIORITIES = np.array([1, 10, 10, 1])\n\n    def __init__(self, theta, kappa, rho, sigma, omega=None, n=None, v_per_day=None):\n        \"\"\"\n        (n and v_per_day) or omega must be applied.\n        @n <float or int>: total population\n        @v_par_day <float or int>: vacctinated persons per day\n        \"\"\"\n        super().__init__()\n        self.theta = float(theta)\n        self.kappa = float(kappa)\n        self.rho = float(rho)\n        self.sigma = float(sigma)\n        if omega is None:\n            try:\n                self.omega = float(v_per_day) \/ float(n)\n            except TypeError:\n                s = \"Neither (n and va_per_day) nor omega must be applied!\"\n                raise TypeError(s)\n        else:\n            self.omega = float(omega)\n\n    def __call__(self, t, X):\n        # x, y, z, w = [X[i] for i in range(len(self.VARIABLES))]\n        # x with vacctination\n        dxdt = - self.rho * X[0] * X[1] - self.omega\n        dxdt = 0 - X[0] if X[0] + dxdt < 0 else dxdt\n        # y, z, w\n        dydt = self.rho * (1 - self.theta) * X[0] * X[1] - (self.sigma + self.kappa) * X[1]\n        dzdt = self.sigma * X[1]\n        dwdt = self.rho * self.theta * X[0] * X[1] + self.kappa * X[1]\n        return np.array([dxdt, dydt, dzdt, dwdt])\n\n    @classmethod\n    def param_dict(cls):\n        param_dict = super().param_dict()\n        param_dict[\"theta\"] = (\"float\", 0, 1)\n        param_dict[\"kappa\"] = (\"float\", 0, 1)\n        param_dict[\"rho\"] = (\"float\", 0, 1)\n        param_dict[\"sigma\"] = (\"float\", 0, 1)\n        param_dict[\"omega\"] = (\"float\", 0, 1)\n        return param_dict\n\n    @staticmethod\n    def calc_variables(df):\n        df[\"X\"] = df[\"Susceptible\"]\n        df[\"Y\"] = df[\"Infected\"]\n        df[\"Z\"] = df[\"Recovered\"]\n        df[\"W\"] = df[\"Deaths\"]\n        return df.loc[:, [\"T\", \"X\", \"Y\", \"Z\", \"W\"]]\n\n    @staticmethod\n    def calc_variables_reverse(df):\n        df[\"Susceptible\"] = df[\"X\"]\n        df[\"Infected\"] = df[\"Y\"]\n        df[\"Recovered\"] = df[\"Z\"]\n        df[\"Deaths\"] = df[\"W\"]\n        return df\n\n    def calc_r0(self):\n        r0 = self.rho * (1 - self.theta) \/ (self.sigma + self.kappa)\n        return round(r0, 2)\n\n    def calc_days_dict(self, tau):\n        _dict = dict()\n        _dict[\"alpha1 [-]\"] = round(self.theta, 2)\n        _dict[\"1\/alpha2 [day]\"] = int(tau \/ 24 \/ 60 \/ self.kappa)\n        _dict[\"1\/beta [day]\"] = int(tau \/ 24 \/ 60 \/ self.rho)\n        _dict[\"1\/gamma [day]\"] = int(tau \/ 24 \/ 60 \/ self.sigma)\n        return _dict","5408e7b4":"class Predicter(object):\n    \"\"\"\n    Predict the future using models.\n    \"\"\"\n    def __init__(self, name, estimater, date_format=\"%d%b%Y\"):\n        \"\"\"\n        @name <str>: place name\n        @estimater <Estimater>: estimater between the start date and today\n        @date_format <str>: date format to display in figures\n        \"\"\"\n        self.name = name\n        self.total_population = estimater.total_population\n        self.start_time = estimater.start_time\n        self.reverse_f = estimater.model.calc_variables_reverse\n        self.date_format = date_format\n        first_params = estimater.study.best_params.copy()\n        self.tau = first_params[\"tau\"]\n        first_params.pop(\"tau\")\n        # Set first model (between the start date and today)\n        now = datetime.now()\n        step_n = int((now - self.start_time).total_seconds() \/ self.tau \/ 60)\n        r0 = estimater.calc_r0()\n        self.sim_df = simulation(\n            estimater.model, estimater.initials, step_n=step_n,\n            **first_params\n        )\n        self.info_list = [f\"{estimater.model.NAME}({r0}, -{now.strftime(date_format)})\"]\n\n    def add(self, model, days, **param_dict):\n        \"\"\"\n        @model <ModelBase>: the epidemic model\n        @days <int>: the number of days\n        @**param_dict <dict>: keyword arguments of the model\n        \"\"\"\n        initials = self.sim_df.set_index(\"t\").iloc[-1, :]\n        param_dict.pop(\"tau\")\n        new_df = simulation(model, initials, step_n=int(days * 24 * 60 \/ self.tau), **param_dict)\n        if self.sim_df.columns.tolist() != new_df.columns.tolist():\n            raise Exception(f\"The variables must be {', '.join(self.sim_df.columns)}!\")\n        new_df[\"t\"] = new_df[\"t\"] + len(self.sim_df)\n        self.sim_df = pd.concat([self.sim_df, new_df], axis=0)\n        r0 = model(**param_dict).calc_r0()\n        last_time = self.start_time + timedelta(minutes=(len(self.sim_df) - 1) * self.tau)\n        self.info_list.append(f\"{model.NAME}({r0}, -{last_time.strftime(self.date_format)})\")\n\n    def restore_df(self):\n        \"\"\"\n        Return the dimentional simulated data.\n        @return <pd.DataFrame>\n        \"\"\"\n        df = self.sim_df.copy()\n        df[\"Time\"] = self.start_time + df[\"t\"].apply(lambda x: timedelta(minutes=x * self.tau))\n        df = df.drop(\"t\", axis=1).set_index(\"Time\") * self.total_population\n        df = df.astype(int)\n        upper_cols = [n.upper() for n in df.columns]\n        df.columns = upper_cols\n        df = self.reverse_f(df).drop(upper_cols, axis=1)\n        return df\n\n    def restore_graph(self, drop_cols=None):\n        \"\"\"\n        Show the dimentional simulate data as a figure.\n        @drop_cols <list[str]>: the columns not to be shown\n        \"\"\"\n        df = self.restore_df()\n        if drop_cols is not None:\n            df = df.drop(drop_cols, axis=1)\n        info = \", \".join(self.info_list)\n        line_plot(\n            df,\n            title=f\"{self.name}: {info}\",\n            v=datetime.today(), h=self.total_population\n        )","b6a338dd":"raw = pd.read_csv(\"\/kaggle\/input\/novel-corona-virus-2019-dataset\/covid_19_data.csv\")\nraw.tail()","6e8b157c":"raw.info()","a8b0bb92":"raw.describe()","eabdff27":"pd.DataFrame(raw.isnull().sum()).T","d83b8231":"\", \".join(raw[\"Country\/Region\"].unique().tolist())","953b52fe":"pprint(raw.loc[raw[\"Country\/Region\"] == \"Others\", \"Province\/State\"].unique().tolist(), compact=True)","e9688a31":"data_cols = [\"Infected\", \"Deaths\", \"Recovered\"]\nrate_cols = [\"Fatal per Confirmed\", \"Recovered per Confirmed\", \"Fatal per (Fatal or Recovered)\"]\nvariable_dict = {\"Susceptible\": \"S\", \"Infected\": \"I\", \"Recovered\": \"R\", \"Deaths\": \"D\"}","a0525bd7":"ncov_df = raw.rename({\"ObservationDate\": \"Date\", \"Province\/State\": \"Province\"}, axis=1)\nncov_df[\"Date\"] = pd.to_datetime(ncov_df[\"Date\"])\nncov_df[\"Country\"] = ncov_df[\"Country\/Region\"].replace({\"Mainland China\": \"China\"})\nncov_df[\"Province\"] = ncov_df[\"Province\"].fillna(\"-\").replace({\"Cruise Ship\": \"Diamond Princess cruise ship\"})\nncov_df[\"Infected\"] = ncov_df[\"Confirmed\"] - ncov_df[\"Deaths\"] - ncov_df[\"Recovered\"]\nncov_df[data_cols] = ncov_df[data_cols].astype(int)\nncov_df = ncov_df.loc[:, [\"Date\", \"Country\", \"Province\", *data_cols]]\nncov_df.tail()","9d9fd15b":"ncov_df.info()","f6e1a5c4":"ncov_df.describe(include=\"all\").fillna(\"-\")","b42579ee":"pd.DataFrame(ncov_df.isnull().sum()).T","e39cb834":"\", \".join(ncov_df[\"Country\"].unique().tolist())","aa44bd91":"total_df = ncov_df.loc[ncov_df[\"Country\"] != \"China\", :].groupby(\"Date\").sum()\ntotal_df[rate_cols[0]] = total_df[\"Deaths\"] \/ total_df[data_cols].sum(axis=1)\ntotal_df[rate_cols[1]] = total_df[\"Recovered\"] \/ total_df[data_cols].sum(axis=1)\ntotal_df[rate_cols[2]] = total_df[\"Deaths\"] \/ (total_df[\"Deaths\"] + total_df[\"Recovered\"])\ntotal_df.tail()","9ff109dc":"f\"{(total_df.index.max() - total_df.index.min()).days} days have passed from the start date.\"","af1d06c0":"line_plot(total_df[data_cols], \"Cases over time (Total except China)\")","d5a4fd58":"line_plot(total_df[rate_cols], \"Rate over time (Total except China)\", ylabel=\"\", math_scale=False)","e255fd32":"total_df[rate_cols].plot.kde()\nplt.title(\"Kernel density estimation of the rates (Total except China)\")\nplt.show()","9a653378":"total_df[rate_cols].describe().T","b153f5db":"train_start_date, train_df = create_target_df(\n    ncov_df, population_dict[\"Global\"] - population_dict[\"China\"], excluded_places=[(\"China\", None)]\n)\ntrain_start_date.strftime(time_format)","0a6054f3":"train_df.tail()","9ad73810":"df = train_df.rename(variable_dict, axis=1)\nfor (_, v) in variable_dict.items():\n    df[f\"d{v}\/dT\"] = df[v].diff() \/ df[\"T\"].diff()\ndf.set_index(\"T\").corr().loc[variable_dict.values(), :].style.background_gradient(axis=None)","a5ae3b29":"sns.lmplot(\n    x=\"I\", y=\"value\", col=\"diff\", sharex=False, sharey=False,\n    data=df[[\"I\", \"dI\/dT\", \"dR\/dT\", \"dD\/dT\"]].melt(id_vars=\"I\", var_name=\"diff\")\n)\nplt.show()","b9fc9360":"trend_df = ncov_df.loc[ncov_df[\"Country\"] != \"China\",[\"Date\", *data_cols]].groupby(\"Date\").sum().reset_index()\ntrend_df[\"Confirmed\"] = trend_df[\"Infected\"] + trend_df[\"Deaths\"] + trend_df[\"Recovered\"]\ntrend_df = trend_df.rename({\"Date\": \"ds\"}, axis=1)\ntrend_df = trend_df.loc[:, [\"ds\", \"Confirmed\", \"Deaths\", \"Recovered\"]]\ntrend_df = trend_df.set_index(\"ds\").apply(np.log10).reset_index().replace([np.inf, -np.inf], 0)\ntrend_df.columns = [\"ds\", \"Log10(Confirmed)\", \"Log10(Deaths)\", \"Log10(Recovered)\"]\ntrend_df.tail()","6049f2d8":"df = trend_df.rename({\"Log10(Confirmed)\": \"y\"}, axis=1).loc[:, [\"ds\", \"y\"]]\nmodel = Prophet(growth=\"linear\", daily_seasonality=False, n_changepoints=2)\nmodel.fit(df)\nfuture = model.make_future_dataframe(periods=0)\nforecast = model.predict(future)\nfig = model.plot(forecast)\n_ = add_changepoints_to_plot(fig.gca(), model, forecast)","b52fe0c3":"df = trend_df.rename({\"Log10(Deaths)\": \"y\"}, axis=1).loc[:, [\"ds\", \"y\"]]\nmodel = Prophet(growth=\"linear\", daily_seasonality=False, n_changepoints=2)\nmodel.fit(df)\nfuture = model.make_future_dataframe(periods=0)\nforecast = model.predict(future)\nfig = model.plot(forecast)\n_ = add_changepoints_to_plot(fig.gca(), model, forecast)","5f6ad8ec":"df = trend_df.rename({\"Log10(Recovered)\": \"y\"}, axis=1).loc[:, [\"ds\", \"y\"]]\nmodel = Prophet(growth=\"linear\", daily_seasonality=False, n_changepoints=2)\nmodel.fit(df)\nfuture = model.make_future_dataframe(periods=0)\nforecast = model.predict(future)\nfig = model.plot(forecast)\n_ = add_changepoints_to_plot(fig.gca(), model, forecast)","2ff2acbb":"train_dataset = SIR.create_dataset(\n    ncov_df, population_dict[\"Global\"] - population_dict[\"China\"], excluded_places=[(\"China\", None)]\n)\ntrain_start_date, train_initials, train_Tend, train_df = train_dataset\npprint([train_start_date.strftime(time_format), train_initials, train_Tend])","5e329825":"train_df.tail()","5871cc77":"line_plot(\n    train_df.set_index(\"T\").drop(\"x\", axis=1),\n    \"Training data: y(T), z(T)\", math_scale=False, ylabel=\"\"\n)","557cd729":"eg_r0, eg_rho = (2.5, 0.2)\neg_sigma = eg_rho \/ eg_r0\n(eg_rho, eg_sigma)","c9ce588d":"%%time\neg_df = simulation(SIR, train_initials, step_n=300, rho=eg_rho, sigma=eg_sigma)\neg_df.tail()","5509c74b":"line_plot(\n    eg_df.set_index(\"t\"),\n    title=r\"SIR: $R_0$={0} ($\\rho$={1}, $\\sigma$={2})\".format(eg_r0, eg_rho, eg_sigma),\n    ylabel=\"\",\n    h=1\n)","bc716ff8":"# Set the example conditions\neg_tau = 1440\neg_start_date = ncov_df[\"Date\"].min()\neg_total_population = 1000000\n# Create dataset in the format of ncov_df\neg_ori_df = pd.DataFrame(\n    {\n        \"Date\": (eg_df[\"t\"] * eg_tau).apply(lambda x: timedelta(minutes=x)) + eg_start_date,\n        \"Country\": \"Example\",\n        \"Province\": \"Example\"\n    }\n)\neg_ori_df[\"Infected\"] = (eg_df[\"y\"] * eg_total_population).astype(int)\neg_ori_df[\"Deaths\"] = (eg_df[\"z\"] * eg_total_population * 0.02).astype(int)\neg_ori_df[\"Recovered\"] = (eg_df[\"z\"] * eg_total_population * 0.98).astype(int)\neg_ori_df.tail()","4a46fba9":"# line_plot(eg_ori_df.set_index(\"Date\")[data_cols], \"Example data\")","f6ee5090":"# %%time\n# eg_sir_estimater = Estimater(SIR, eg_ori_df, eg_total_population, places=[(\"Example\", \"Example\")])\n# eg_sir_dict = eg_sir_estimater.run()","998d4b8a":"# eg_sir_estimater.compare_graph()","3f562729":"\"\"\"\neg_dict = {\n    \"Condition\": {\n        \"tau\": eg_tau, \"rho\": eg_rho, \"sigma\": eg_sigma,\n        \"R0\": eg_r0, \"score\": 0, **SIR(rho=eg_rho, sigma=eg_sigma).calc_days_dict(eg_tau)\n    },\n    \"Estimation\": eg_sir_dict\n}\ndf = pd.DataFrame.from_dict(eg_dict, orient=\"index\")\ndf\n\"\"\"\nNone","e640d2f9":"# eg_sir_estimater.predict_graph(step_n=500, name=\"Example area\")","40b15a77":"%%time\nsir_estimater = Estimater(SIR, ncov_df, population_dict[\"Global\"] - population_dict[\"China\"], excluded_places=[(\"China\", None)])\nsir_dict = sir_estimater.run()","0e408526":"sir_estimater.history_df().head()","fad46856":"sir_estimater.history_graph()","46055e6d":"sir_dict","5cd6b934":"sir_estimater.compare_graph()","b9301d57":"sir_estimater.predict_graph(step_n=400, name=\"Total except China\")","a538262d":"# %%time\n# sird_estimater = Estimater(\n#     SIRD, ncov_df, population_dict[\"Global\"] - population_dict[\"China\"], excluded_places=[(\"China\", None)]\n# )\n# sird_dict = sird_estimater.run()","6659d073":"# sird_estimater.history_graph()","ac4867ce":"# sird_dict","273336dd":"# sird_estimater.compare_graph()","86ba2903":"# sird_estimater.predict_graph(step_n=500, name=\"Total except China\")","8931ce52":"%%time\nsirf_estimater = Estimater(\n    SIRF, ncov_df, population_dict[\"Global\"] - population_dict[\"China\"], excluded_places=[(\"China\", None)]\n)\nsirf_dict = sirf_estimater.run()","d4c9bdf8":"sirf_estimater.history_df().head()","7077f33e":"sirf_estimater.history_graph()","ae2bffe8":"sirf_dict","cef91584":"sirf_estimater.compare_graph()","1ac376bf":"sirf_estimater.predict_graph(step_n=500, name=\"Total except China\")","6cae668b":"_dict = {\n    \"SIR\": sir_dict,\n    # \"SIR-D\": sird_dict,\n    \"SIR-F\": sirf_dict\n}\nmodel_param_df = pd.DataFrame.from_dict(_dict, orient=\"index\")\nmodel_param_df.fillna(\"-\")","90635a61":"country_df = ncov_df.pivot_table(\n    values=\"Infected\", index=\"Date\", columns=\"Country\", aggfunc=sum\n).fillna(0).astype(int)\ncountry_df = country_df.drop(\"China\", axis=1)","1004d9e2":"line_plot(\n    country_df.T.nlargest(5, country_df.index.max()).T,\n    \"Infected in top 5 countries without China\",\n    math_scale=False\n)","ad5ecd13":"_, jp_df = create_target_df(ncov_df, population_dict[\"Japan\"], places=[(\"Japan\", None)])\njp_df.tail()","cb27120a":"line_plot(jp_df.set_index(\"T\")[data_cols], \"Japan: without Susceptible\", math_scale=False)","de86027f":"%%time\njp_sirf_estimater = Estimater(SIRF, ncov_df, population_dict[\"Japan\"], places=[(\"Japan\", None)])\njp_sirf_dict = jp_sirf_estimater.run()","dc8e7b68":"jp_sirf_dict","dd45f654":"# jp_sirf_estimater.history_graph()","f5679937":"jp_sirf_estimater.compare_graph()","982f422e":"jp_sirf_estimater.predict_graph(step_n=500, name=\"Japan\")","5da6d9e0":"sk_start_date, sk_df = create_target_df(ncov_df, population_dict[\"South Korea\"], places=[(\"South Korea\", None)])\nsk_df.tail()","87a9a1ac":"line_plot(sk_df.set_index(\"T\")[data_cols], \"South Korea: without Susceptible\", math_scale=False)","793275e4":"sk_start_date + timedelta(minutes=40000)","15ed9214":"%%time\nsk_sirf_estimater = Estimater(SIRF, ncov_df, population_dict[\"South Korea\"], places=[(\"South Korea\", None)])\nsk_sirf_dict = sk_sirf_estimater.run()","7d6e37e7":"# sk_sirf_estimater.history_graph()","16aa5d78":"sk_sirf_dict","4cce0e76":"sk_sirf_estimater.compare_graph()","c9480025":"sk_sirf_estimater.predict_graph(step_n=500, name=\"South Korea\")","da5baf26":"_, it_df = create_target_df(ncov_df, population_dict[\"Italy\"], places=[(\"Italy\", None)])\nit_df.tail()","4df06486":"line_plot(it_df.set_index(\"T\")[data_cols], \"Italy: without Susceptible\", math_scale=False)","8e843c65":"%%time\nit_sirf_estimater = Estimater(SIRF, ncov_df, population_dict[\"Italy\"], places=[(\"Italy\", None)])\nit_sirf_dict = it_sirf_estimater.run()","12176bd3":"it_sirf_dict","f317f1b2":"# it_sirf_estimater.history_graph()","88204ded":"it_sirf_estimater.compare_graph()","83552739":"it_sirf_estimater.predict_graph(step_n=500, name=\"Italy\")","5aaa432e":"_, ir_df = create_target_df(ncov_df, population_dict[\"Iran\"], places=[(\"Iran\", None)])\nir_df.tail()","be5325d1":"line_plot(ir_df.set_index(\"T\")[data_cols], \"Iran: without Susceptible\", math_scale=True)","7508066a":"%%time\nir_sirf_estimater = Estimater(SIRF, ncov_df, population_dict[\"Iran\"], places=[(\"Iran\", None)])\nir_sirf_dict = ir_sirf_estimater.run()","2eeb2642":"ir_sirf_dict","2a7b18e4":"# ir_sirf_estimater.history_graph()","7bf29dff":"ir_sirf_estimater.compare_graph()","e6cb4e19":"ir_sirf_estimater.predict_graph(step_n=500, name=\"Iran\")","311a4f96":"_dict = {\n    \"Total except China\": sirf_dict,\n    \"Japan\": jp_sirf_dict,\n    \"South Korea\": sk_sirf_dict,\n    \"Italy\": it_sirf_dict,\n    \"Iran\": ir_sirf_dict,\n}\ncomp_param_df = pd.DataFrame.from_dict(_dict, orient=\"index\")\ncomp_param_df","66b63ed9":"sirf_dict","66f0d365":"country = \"Except China\"\ntotal_population = population_dict[\"Global\"] - population_dict[\"China\"]\nfirst_estimater = sirf_estimater\nparam_dict = first_estimater.study.best_params.copy()\nparam_dict","64fd21be":"predicter = Predicter(country, first_estimater)\npredicter.add(SIRF, days=30, **param_dict)\npredicter.restore_graph(\"Susceptible\")","152cfe14":"predicter = Predicter(country, first_estimater)\npredicter.add(SIRF, days=1000, **param_dict)\npredicter.restore_graph()","a5f70220":"changed_param_dict = param_dict.copy()\nchanged_param_dict[\"rho\"] = param_dict[\"rho\"] \/ 2\npredicter = Predicter(country, first_estimater)\npredicter.add(SIRF, days=1000, **changed_param_dict)\npredicter.restore_graph()","58927a10":"changed_param_dict = param_dict.copy()\nchanged_param_dict[\"rho\"] = param_dict[\"rho\"] \/ 2\npredicter = Predicter(country, first_estimater)\npredicter.add(SIRF, days=30, **changed_param_dict)\npredicter.restore_graph(\"Susceptible\")","d86e62b3":"changed_param_dict = param_dict.copy()\nchanged_param_dict[\"sigma\"] = param_dict[\"sigma\"] * 2\nchanged_param_dict[\"kappa\"] = param_dict[\"kappa\"] \/ 2\npredicter = Predicter(country, first_estimater)\npredicter.add(SIRF, days=1000, **changed_param_dict)\npredicter.restore_graph()","4f70b887":"changed_param_dict = param_dict.copy()\nchanged_param_dict[\"n\"] = total_population\nchanged_param_dict[\"v_per_day\"] = 1000000\npredicter = Predicter(country, first_estimater)\npredicter.add(SIRFV, days=1000, **changed_param_dict)\npredicter.restore_graph()","6049e078":"#### SIR-FV model","7daeb87f":"**No slope change points were found for the number of confirmed cases.**","17810ccb":"# Arrangement of dataset","ec0e6320":"### Numerical simulation\nWe will perform numerical analysis to solve the ODE using scipy.integrate.solve_ivp function.","9c581e91":"### Parameter Estimation using Optuna","c035810f":"## If lower effective contact rate since today\nWe will predict the numbers of cases in the assumption that $\\rho$ will be half as much as estimated value since today by quarantining\/wearing of masks.\n* $\\rho \\to \\cfrac{\\rho}{2}$","818e58a8":"Non-dimentional SIR\/SIR-D\/SIR-F model explained the COVID-19 data in Iran. Predicted values with the parameters estimated by model fitting is under the assumption that no new actions will be taken. If no actions will be taken, almost all peaple may be infected by this disease...","453ae89a":"## Compare country raw data except China","437bff4f":"## Trend of log10(Recovered)","2c4e3292":"### Non-dimensional SIR-D model\nSet $(S, I, R, D) = N \\times (x, y, z, z)$ and $(T, \\alpha, \\beta, \\gamma) = (\\tau t, \\tau^{-1} \\kappa, \\tau^{-1} \\rho, \\tau^{-1} \\sigma)$.  \nThis results in the ODE  \n$\\frac{\\mathrm{d}x}{\\mathrm{d}t}= - \\rho x y$  \n$\\frac{\\mathrm{d}y}{\\mathrm{d}t}= \\rho x y - (\\sigma + \\kappa) y$  \n$\\frac{\\mathrm{d}z}{\\mathrm{d}t}= \\sigma y$  \n$\\frac{\\mathrm{d}w}{\\mathrm{d}t}= \\kappa y$  \n\nWhere $N$ is the total population and $\\tau$ is a coefficient ([min], is an integer to simplify).  \n\nThe range of variables and parameters:  \n$0 < (x, y, z, \\kappa, \\rho, \\sigma) < 1$  \n$1\\leq \\tau \\leq 1440$\n\nReproduction number can be defined as  \n$R_0 = \\rho (\\sigma + \\kappa)^{-1} = \\beta (\\gamma + \\alpha)^{-1}$","158f20b0":"It is difficult to know the actual trend in China because criteria of confirmation was change twice for several reasons. In the near future, this notebook may use trend analysis by fbprophet package and so on so that we can predict the actual trend of the number of confirmed cases.","56ffed61":"## To-do list\n\n* Consider the rate of R$\\to$I.\n* Reconsider the ODEs of SIR-F model using new records\n* Discuss $R_0$ using the data of the other infectious diseases\n* Discuss how to prevent the spread using improved mathematical models","bea5d9d6":"### What is SIR-D model?\n* S: Susceptible\n* I: Infected\n* R: Recovered\n* D: Fatal\n\nModel:  \nS + I $\\overset{\\beta}{\\longrightarrow}$ 2I  \nI $\\overset{\\gamma}{\\longrightarrow}$ R  \nI $\\overset{\\alpha}{\\longrightarrow}$ D  \n\n$\\alpha$: Mortality rate [1\/hour]  \n$\\beta$: Effective contact rate [1\/hour]  \n$\\gamma$: Recovery rate [1\/hour]  \n\nOrdinary Differential Equation (ODE):   \n$\\frac{\\mathrm{d}S}{\\mathrm{d}T}= - N^{-1}\\beta S I$  \n$\\frac{\\mathrm{d}I}{\\mathrm{d}T}= N^{-1}\\beta S I - (\\gamma + \\alpha) I$  \n$\\frac{\\mathrm{d}R}{\\mathrm{d}T}= \\gamma I$  \n$\\frac{\\mathrm{d}D}{\\mathrm{d}T}= \\alpha I$  \n\nWhere $N=S+I+R+D$ is the total population, $T$ is the elapsed time from the start date.","f2ceb760":"**Note: We cannot convert $T$ to $t$ because $\\tau$ has not been determined yet.**","06f7eac2":"### Hyperparameter optimization\nUsing Optuna package, ($\\theta, \\kappa, \\rho, \\sigma, \\tau$) will be estimated by model fitting.","ac3f26f2":"## Iran","8344f81c":"With the models, we predicted the effect of actions on the numbers of cases in Iran. New medicines and vaccines are expected, but, in initial state, we must make an effort to minimize effective contact rate $\\rho$ by quarantining\/wearing of masks. This effort will reduce the number of infected cases directory.","5fcab286":"## Example of dataset to create math model\n * T means elapsed time [hour] from the start date.\n * Susceptible means the patients who are in the area but not infected\/recovered\/died.","7350af5b":"### Hyperparameter optimization\nUsing Optuna package, ($\\rho, \\sigma, \\tau$) will be estimated by model fitting.","e09e5a3d":"## Functions\nHere, we define the functions to use repeatedly in this notebook.","c224d2d2":"## Prediction with SIR-F model\nSome cases are reported as fatal cases before clinical diagnosis of COVID-19. To consider this issue, \"S + I $\\to$ Fatal + I\" will be added to the model.","678cb04c":"## Remarks","9c22da0d":"### What is SIR-F model?\n* S: Susceptible\n* S$^\\ast$: Infected but un-confirmed\n* I: Infected and confirmed\n* R: Recovered\n* F: Fatal\n\nMeasurable variables:  \nConfirmed = $I+R+F$  \nRecovered = $R$  \nDeaths = $F$  \n\nModel:  \nS $\\overset{\\beta \\mathrm{I}}{\\longrightarrow}$ S$^\\ast$ $\\overset{\\alpha_1}{\\longrightarrow}$ F  \nS $\\overset{\\beta \\mathrm{I}}{\\longrightarrow}$ S$^\\ast$ $\\overset{1 - \\alpha_1}{\\longrightarrow}$ I  \nI $\\overset{\\gamma}{\\longrightarrow}$ R  \nI $\\overset{\\alpha_2}{\\longrightarrow}$ F  \n\n$\\alpha_1$: Mortality rate of S$^\\ast$ cases [-]  \n$\\alpha_2$: Mortality rate of I cases [1\/hour]  \n$\\beta$: Effective contact rate [1\/hour]  \n$\\gamma$: Recovery rate [1\/hour]  \n\nOrdinary Differential Equation (ODE):   \n$\\frac{\\mathrm{d}S}{\\mathrm{d}T}= - N^{-1}\\beta S I$  \n$\\frac{\\mathrm{d}I}{\\mathrm{d}T}= N^{-1}(1 - \\alpha_1) \\beta S I - (\\gamma + \\alpha_2) I$  \n$\\frac{\\mathrm{d}R}{\\mathrm{d}T}= \\gamma I$  \n$\\frac{\\mathrm{d}D}{\\mathrm{d}T}= N^{-1}\\alpha_1 \\beta S I + \\alpha_2 I$  \n\nWhere $N=S+I+R+F$ is the total population, $T$ is the elapsed time from the start date.","d9de4057":"## Correlation of variables","dd14d931":"## Italy","b8d83dd0":"## Data Cleening\nNote: \"Infected\" = \"Confirmed\" - \"Deaths\" - \"Recovered\"","4fa773d4":"Only \"Infected\" suddenly arised after 18Feb2020 (especially in Church of Jesus in Daegu).","8895362b":"## Comparison of models","dada9c2d":"The model needs to be improved. It is difficult to add another varible\/parameter to the model because we can measure only 4 variables (confirmed, recovered, deaths, total population) now. To improve the accuracy, ODEs should be replaced.","a1dbf3ee":"z(t) was successfully estimated, but error of y(t) cannot be ignored.","2b50bbec":"## Total population\nPredicted current\/2020 values will be used as the total population in this notebook.  \n[Global](http:\/\/population.city\/)  \n[China](http:\/\/population.city\/china\/)\n[Japan Population](http:\/\/population.city\/japan\/)  \n[South Korea Population](http:\/\/population.city\/south-korea\/)  \n[Italy Population](http:\/\/population.city\/italy\/)  \n[Iran Population](http:\/\/population.city\/iran\/)","08326b98":"### Non-dimensional SIR model\nTo simplify the model, the units of the variables should be removed from ODE.\n\nSet $(S, I, R) = N \\times (x, y, z)$ and $(T, \\beta, \\gamma) = (\\tau t, \\tau^{-1} \\rho, \\tau^{-1} \\sigma)$.  \n\nThis results in the ODE  \n$\\frac{\\mathrm{d}x}{\\mathrm{d}t}= - \\rho x y$  \n$\\frac{\\mathrm{d}y}{\\mathrm{d}t}= \\rho x y - \\sigma y$  \n$\\frac{\\mathrm{d}z}{\\mathrm{d}t}= \\sigma y$  \n\nWhere $N$ is the total population and $\\tau$ is a coefficient ([min], is an integer to simplify).  \n\nThe range of variables and parameters:  \n$0 < (x, y, z, \\rho, \\sigma) < 1$  \n$1\\leq \\tau \\leq 1440$  \n\nBasic reproduction number, Non-dimentional parameter, is defined as  \n$R_0 = \\rho \\sigma^{-1} = \\beta \\gamma^{-1}$  \n\nEstimated Mean Values of $R_0$:  \n$R_0$ means \"the average number of secondary infections caused by an infected host\" ([Infection Modeling \u2014 Part 1](https:\/\/towardsdatascience.com\/infection-modeling-part-1-87e74645568a)).  \n(Secondary data: [Van den Driessche, P., & Watmough, J. (2002).](https:\/\/www.ncbi.nlm.nih.gov\/pmc\/articles\/PMC6002118))  \n2.06: Zika in South America, 2015-2016  \n1.51: Ebola in Guinea, 2014  \n1.33: H1N1 influenza in South Africa, 2009  \n3.5 : SARS in 2002-2003\n1.68: H2N2 influenza in US, 1957  \n3.8 : Fall wave of 1918 Spanish influenza in Genova\n1.5 : Spring wave of 1918 Spanish influenza in Genova\n\nWhen $x=\\frac{1}{R_0}$, $\\frac{\\mathrm{d}y}{\\mathrm{d}t}=0$. This means that the max value of confirmed ($=y+z$) is $1-\\frac{1}{R_0}$.","4f96f516":"# Improvement of math model\nIn this section, we will create a mathematical model derived from SIR model. The dataset of total except China will be used here as an example.","f614fe08":"### Plotting","198162b8":"# Remarks and To-do list","eb845963":"## Predicted data with SIR-F model and estimated parameters","70f0cb6e":"#### SIR model","344be98a":"* Variables ($I, R, D$) shows high correlation with each other.\n* $\\mathrm{d}I\/\\mathrm{d}T=\\frac{I_{T+\\Delta T} - I_T}{\\Delta T}$, $\\mathrm{d}R\/\\mathrm{d}T=\\frac{R_{T+\\Delta T} - R_T}{\\Delta T}$, $\\mathrm{d}D\/\\mathrm{d}T=\\frac{D_{T+\\Delta T} - D_T}{\\Delta T}$ show high correlation with I.","db6edf52":"### Dataset arrangement","64443b13":"## Prediction with SIR-D model\nBecause we can measure the number of fatal cases and recovered cases separately, we can use two variables (\"Recovered\" and \"Deaths\") instead of \"Recovered + Deaths\" in the mathematical model.","c4f00f53":"## If 100,000\/day are vaccinated (SIR-FV model) since today\nWe will predict the numbers of cases in the assumption that 1,000,000 persons will be vacctinated in one day until there are susceptible people.  \n$\\frac{\\mathrm{d}x}{\\mathrm{d}t}= - \\rho x y - \\omega$  \n$\\frac{\\mathrm{d}y}{\\mathrm{d}t}= \\rho (1-\\theta) x y - (\\sigma + \\kappa) y$  \n$\\frac{\\mathrm{d}z}{\\mathrm{d}t}= \\sigma y$  \n$\\frac{\\mathrm{d}w}{\\mathrm{d}t}= \\rho \\theta x y + \\kappa y$  \nWhere $\\omega_{(x>0)}=\\frac{1,000,000}{N}$ and $N$ is the total population.\n\nReproduction number can be defined as  \n$R_0 = \\rho (1 - \\theta) (\\sigma + \\kappa)^{-1}$","90bb1b24":"## Visualize total data except China","590f45ed":"### Example of non-dimensional SIR model\nFor example, set $R_0 = 2.5, \\rho=0.2$.","ee935dde":"## Prediction with SIR model\nTo understand the trend of infection, we will use mathematical epidemic model. We start to discuss the trend using a basic model named SIR model.","066769ab":"# How to minimize the damage\nSIR-F model seems especially suitable for Iran. Using SIR-F model with the parameters for total except China, we will discuss how to minimize the damage caused by COVID-19.","52f5cf77":"## Package","c338ca28":"### Hyperparameter optimization\nUsing Optuna package, ($\\kappa, \\rho, \\sigma, \\tau$) will be estimated by model fitting.","a6603728":"## Raw data","89712e1b":"### Prediction of the data using some models","64567922":"## Japan","9e8ad628":"# SIR-F model with other countries","599e14ac":"Thank you for reading!","09a86773":"### Test of hyperparameter optimization using example data\nTo test the hyperparameter optimization functions defeined in this notebook, we will estimate the SIR model parameters using the example data and example $\\tau=1440$ [min] and total population 1,000,000.","8c58a662":"## South Korea","6168db8f":"# Trend analysis\nUsing fbprophet package, we will find changing points of comfirmed\/deaths\/recovered.","43528c74":"## Trend of log10(Confirmed)","1f24d5d6":"### Description of math model","0c3666e9":"**Slope of the number of fatal cases was changed on 07Feb2020. This change was caused by the first report of fatal case.**","a1f69937":"#### SIR-F model","6f09b956":"## Dataset\nWe will use the dataset of total except China.","32b8c873":"## If higher recovery rate and lower mortality rate since today\nWe will predict the numbers of cases in the assumption that $\\sigma$ will be twice as much as estimated value and $\\kappa$ will be half as much as estimated value since today by effective medicines.\n\n* $\\sigma \\to 2\\sigma$\n* $\\kappa \\to \\cfrac{\\kappa}{2}$","a4b3b2f7":"## Dataset","95dc03d3":"### Non-dimensional SIR-F model\nSet $(S, I, R, D) = N \\times (x, y, z, z)$ and $(T, \\alpha_1, \\alpha_2, \\beta, \\gamma) = (\\tau t, \\theta, \\tau^{-1} \\kappa, \\tau^{-1} \\rho, \\tau^{-1} \\sigma)$.  \nThis results in the ODE  \n$\\frac{\\mathrm{d}x}{\\mathrm{d}t}= - \\rho x y$  \n$\\frac{\\mathrm{d}y}{\\mathrm{d}t}= \\rho (1-\\theta) x y - (\\sigma + \\kappa) y$  \n$\\frac{\\mathrm{d}z}{\\mathrm{d}t}= \\sigma y$  \n$\\frac{\\mathrm{d}w}{\\mathrm{d}t}= \\rho \\theta x y + \\kappa y$  \n\nWhere $N$ is the total population and $\\tau$ is a coefficient ([min], is an integer to simplify).  \n\nThe range of variables and parameters:  \n$0 < (x, y, z, \\theta, \\kappa, \\rho, \\sigma) < 1$  \n$1 \\leq \\tau \\leq 1440$  \n\nReproduction number can be defined as  \n$R_0 = \\rho (1 - \\theta) (\\sigma + \\kappa)^{-1} = \\beta (1 - \\alpha_1) (\\gamma + \\alpha_2)^{-1}$","d7bb2d89":"### What is SIR model?\nSIR model is a simple mathematical model to understand outbreak of infectious diseases.  \n[The SIR epidemic model - Learning Scientific Programming with Python](https:\/\/scipython.com\/book\/chapter-8-scipy\/additional-examples\/the-sir-epidemic-model\/)\n\n * S: Susceptible (=All - Confirmed)\n * I: Infected (=Confirmed - Recovered - Deaths)\n * R: Recovered or Died (=Recovered + Deaths)\n \nNote: THIS IS NOT THE GENERAL MODEL!  \nThough R in SIR model is \"Recovered and have immunity\", I defined \"R as Recovered or Died\". This is because mortality rate cannot be ignored in the real data of COVID-19.\n\nModel:  \nS + I $\\overset{\\beta}{\\longrightarrow}$ 2I  \nI $\\overset{\\gamma}{\\longrightarrow}$ R\n\n$\\beta$: Effective contact rate [1\/hour]  \n$\\gamma$: Recovery(+Mortality) rate [1\/hour]  \n\nOrdinary Differential Equation (ODE):   \n$\\frac{\\mathrm{d}S}{\\mathrm{d}T}= - N^{-1}\\beta S I$  \n$\\frac{\\mathrm{d}I}{\\mathrm{d}T}= N^{-1}\\beta S I - \\gamma I$  \n$\\frac{\\mathrm{d}R}{\\mathrm{d}T}= \\gamma I$  \n\nWhere $N=S+I+R$ is the total population, $T$ is the elapsed time from the start date.","5c446627":"## Trend of log10(Deaths)","80384734":"I'm in Iran.","72b165b6":"**No slope change points were found for the number of recovered cases.**","9ad3de31":"#### SIR-D model","62cf414c":"## Parameter comparsion of the countries"}}