{"cell_type":{"9dd99a22":"code","3f85bb79":"code","9db02ee5":"code","db234930":"code","b0e11d5b":"code","16a28913":"code","8f07bc0f":"code","027e37da":"code","20a292f3":"code","2a3a57dd":"code","77d8e61e":"code","acd91710":"markdown","44f95bb4":"markdown","8db8855f":"markdown","cd6d3279":"markdown","ebfc9d11":"markdown"},"source":{"9dd99a22":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom pandas import read_csv\nimport os.path as path\nimport numpy.fft as fft\nfrom scipy import signal as scisig\nfrom sklearn.linear_model import LinearRegression","3f85bb79":"dataset_path = path.join(\"..\", \"input\", \"data-without-drift\")\ncsv_name = \"train_clean.csv\"\ntrain = read_csv(path.join(dataset_path, csv_name))\ntime = train[\"time\"].values\nsignal = train[\"signal\"].values\nchannels = train[\"open_channels\"].values","9db02ee5":"# Apart 2 type\n\nsignalA = np.hstack((signal[:2000000], signal[2500000:3500000], signal[4000000:4500000]))\nchannelsA = np.hstack((channels[:2000000], channels[2500000:3500000], channels[4000000:4500000]))\n# Fill odd value to median\nsignal1 = signal[:1000000]\nchannels1 = channels[:1000000]\nmedian = np.median(signal1[channels1 == 0])\ncondition = (signal1 > -1) & (channels1 == 0)\nsignal1[condition] = median\nsignalA[:1000000] = signal1\n\n\nsignalB = np.hstack((signal[2000000:2500000], signal[4500000:]))\nchannelsB = np.hstack((channels[2000000:2500000], channels[4500000:]))","db234930":"# Visual data (type A)\n\nsignal = signalA\nchannels = channelsA\n\nc = 6   # channel size\nlabel = np.arange(len(signal))\n\nchannel_list = np.arange(c)\nn_list = np.empty(c)\nmean_list = np.empty(c)\nstd_list = np.empty(c)\nstderr_list = np.empty(c)\n\nfor i in range(c):\n    x = label[channels == i]\n    y = signal[channels == i]\n    n_list[i] = np.size(y)\n    mean_list[i] = np.mean(y)\n    std_list[i] = np.std(y)\n    plt.plot(x, y, \".\", markersize = 0.5, alpha = 0.02)\n    \nstderr_list = std_list \/ np.sqrt(n_list)\nplt.show()\n\n\n# Predict general mean\n\nw = 1 \/ stderr_list\nchannel_list = channel_list.reshape(-1, 1)\nlinreg_m = LinearRegression()\nlinreg_m.fit(channel_list, mean_list, sample_weight = w)\n\nmean_predictA = linreg_m.predict(channel_list)\n\nx = np.linspace(-0.5, 5.5, 5)\ny = linreg_m.predict(x.reshape(-1, 1))\nplt.plot(x, y, label = \"regression\")\nplt.plot(channel_list, mean_list, \".\", markersize = 8, label = \"original\")\nplt.legend()\nplt.show()\n\nprint(\"meanA :\", mean_predictA)","b0e11d5b":"# Visual data (type B)\n\nsignal = signalB\nchannels = channelsB\nlabel = np.arange(len(channels))\n\nc = 11   # channel size\n\nchannel_list = np.arange(c)\nn_list = np.empty(c)\nmean_list = np.empty(c)\nstd_list = np.empty(c)\nstderr_list = np.empty(c)\n\nfor i in range(c):\n    x = label[channels == i]\n    y = signal[channels == i]\n    n_list[i] = np.size(y)\n    mean_list[i] = np.mean(y)\n    std_list[i] = np.std(y)\n    plt.plot(x, y, \".\", markersize = 0.7, alpha = 0.03)\n    \nstderr_list = std_list \/ np.sqrt(n_list)\nplt.show()\n\n\n# Predict general mean\n\nw = 1 \/ stderr_list\nchannel_list = channel_list.reshape(-1, 1)\nlinreg_m = LinearRegression()\nlinreg_m.fit(channel_list, mean_list, sample_weight = w)\n\nmean_predictB = linreg_m.predict(channel_list)\n\nx = np.linspace(-0.5, 10.5, 5)\ny = linreg_m.predict(x.reshape(-1, 1))\nplt.plot(x, y, label = \"regression\")\nplt.plot(channel_list, mean_list, \".\", markersize = 8, label = \"original\")\nplt.legend()\nplt.show()\n\nprint(\"meanB :\", mean_predictB)","16a28913":"def Arrange_mean(signal, channels, diff, channel_range):\n    signal_out = signal.copy()\n    for i in range(channel_range):\n        signal_out[channels == i] -= diff[i]\n    return signal_out\n\ndef bandstop(x, samplerate = 1000000, fp = np.array([4925, 5075]), fs = np.array([4800, 5200])):\n    fn = samplerate \/ 2   # Nyquist frequency\n    wp = fp \/ fn\n    ws = fs \/ fn\n    gpass = 1\n    gstop = 10.0\n\n    N, Wn = scisig.buttord(wp, ws, gpass, gstop)\n    b, a = scisig.butter(N, Wn, \"bandstop\")\n    y = scisig.filtfilt(b, a, x)\n    return y\n\ndef bandpass(x, samplerate = 1000000, fp = np.array([4925, 5075]), fs = np.array([4800, 5200])):\n    fn = samplerate \/ 2   # Nyquist frequency\n    wp = fp \/ fn\n    ws = fs \/ fn\n    gpass = 1\n    gstop = 10.0\n\n    N, Wn = scisig.buttord(wp, ws, gpass, gstop)\n    b, a = scisig.butter(N, Wn, \"bandpass\")\n    y = scisig.filtfilt(b, a, x)\n    return y","8f07bc0f":"sig_A = Arrange_mean(signalA, channelsA, mean_predictA, 6)\nplt.plot(sig_A)\nplt.show()","027e37da":"sig_B = Arrange_mean(signalB, channelsB, mean_predictB, 11)\nplt.plot(sig_B)\nplt.show()","20a292f3":"signal_flat = np.hstack((sig_A, sig_B))\nsig_list = np.split(signal_flat, 9)\nfs=10000.\nfor sig_sample in sig_list:\n    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(20, 5))\n    fig.subplots_adjust(hspace = .5)\n\n    fft = np.fft.fft(sig_sample)\n    psd = np.abs(fft) ** 2\n    fftfreq = np.fft.fftfreq(len(psd),1\/fs)\n    \n    i = abs(fftfreq) < 200\n    ax.grid()\n    ax.plot(fftfreq[i], 20*np.log10(psd[i]), linewidth=.5)\n    ax.set_xlabel('Frequency (Hz)') \n    ax.set_ylabel('PSD (dB)')\n    plt.show()","2a3a57dd":"for sig_sample in sig_list:\n    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(20, 5))\n    fig.subplots_adjust(hspace = .5)\n    sig_remove = bandstop(sig_sample)\n    ax.plot(sig_sample, label = \"original\")\n    ax.plot(sig_remove, label = \"filtered\")\n    ax.legend(loc = \"upper right\")\n    ax.set_xlim(0, 10000)\n    plt.show()\n    \n    \n    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(20, 5))\n    fig.subplots_adjust(hspace = .5)\n    fft = np.fft.fft(sig_remove)\n    psd = np.abs(fft) ** 2\n    fftfreq = np.fft.fftfreq(len(psd),1\/fs)\n    \n    i = abs(fftfreq) < 200\n    ax.grid()\n    ax.plot(fftfreq[i], 20*np.log10(psd[i]), linewidth=.5)\n    ax.set_xlabel('Frequency (Hz)') \n    ax.set_ylabel('PSD (dB)')\n    plt.show()","77d8e61e":"for sig_sample in sig_list:\n    sig_remove = bandpass(sig_sample)\n    \n    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(20, 5))\n    fig.subplots_adjust(hspace = .5)\n    ax.plot(sig_sample, label = \"original\")\n    ax.plot(sig_remove, label = \"filtered\")\n    ax.legend(loc = \"upper right\")\n    ax.set_xlim(0, 10000)\n    plt.show()\n    \n    \n    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(20, 5))\n    fig.subplots_adjust(hspace = .5)\n    fft = np.fft.fft(sig_remove)\n    psd = np.abs(fft) ** 2\n    fftfreq = np.fft.fftfreq(len(psd),1\/fs)   \n    i = abs(fftfreq) < 200\n    ax.grid()\n    ax.plot(fftfreq[i], 20*np.log10(psd[i]), linewidth=.5)\n    ax.set_xlabel('Frequency (Hz)') \n    ax.set_ylabel('PSD (dB)')\n    plt.show()","acd91710":"# **Remove noise by Bandstop filter**","44f95bb4":"# **Fourier transform**\nThis data has periodic noise in addition to the gaussian noise","8db8855f":"# **Preprocessing** (useing clean data)","cd6d3279":"# **Remove\/Pick up electric? noise**\nIf you apply fourier transform to clean data, you'll found additional periodic noise.  \nThis may be a important feature. I introduce a way to treat this noise.  \nI don't know how it would affect the prediction. If you have verified, Teach me!  \n(I found the word \"Kalman filter\" several times, is it related?)\n  \nThanks to Chris Deotte for [clean data](https:\/\/www.kaggle.com\/cdeotte\/data-without-drift)!\n\n **! <span style=\"color: red; \">I changed function \"bandpass\" and \"bandstop\". The instructions are in the comments. <\/span>! **","ebfc9d11":"# **Pick up noise by Bandpass filter**"}}