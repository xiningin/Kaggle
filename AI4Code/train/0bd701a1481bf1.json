{"cell_type":{"f177f242":"code","4c40cdf0":"code","c068d7ae":"code","20906432":"code","83aceffc":"code","14a00ec2":"code","dbd5782b":"code","da13e0bb":"code","2c86317f":"code","57581248":"code","f5dc77a7":"code","26b50676":"code","7ed61e74":"code","11ce467a":"code","a45cd885":"code","604d84c9":"code","14b9335d":"code","8fb41a88":"code","3ff5cf9e":"code","7ff698ec":"code","e5be3879":"code","e65a2137":"code","175551d1":"code","99f88436":"markdown","959b731f":"markdown","0a7effbd":"markdown","626673ed":"markdown","4f5c919d":"markdown","dbb0b40a":"markdown","d7278093":"markdown","abd42573":"markdown","15719397":"markdown"},"source":{"f177f242":"import cv2\nimport os\nimport time\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nfrom mpl_toolkits.axes_grid1 import ImageGrid","4c40cdf0":"SQUARE_SIZE = 30     # how big are the squares of the checkerboard pattern (in millimeters)\nBOARD_SIZE = (11,7)  # size of the chessboard (measured from the crossing corners of the squares)","c068d7ae":"LEFT_PATH = '..\/input\/stereocamera-chessboard-pictures\/data\/imgs\/leftcamera'\nRIGHT_PATH = '..\/input\/stereocamera-chessboard-pictures\/data\/imgs\/rightcamera'\n\nprint('We have {} Images from the left camera'.format(len(os.listdir(LEFT_PATH))))\nprint('and {} Images from the right camera.'.format(len(os.listdir(RIGHT_PATH))))","20906432":"# sort the image names after their number\n# save the image names with the whole path in a list\n\nprint('Before: {}, {}, {}, ...'.format(os.listdir(LEFT_PATH)[0], os.listdir(LEFT_PATH)[1], os.listdir(LEFT_PATH)[2]))\n\ndef SortImageNames(path):\n    imagelist = sorted(os.listdir(path))\n    lengths = []\n    for name in imagelist:\n        lengths.append(len(name))\n    lengths = sorted(list(set(lengths)))\n    ImageNames, ImageNamesRaw = [], []\n    for l in lengths:\n        for name in imagelist:\n            if len(name) == l:\n                ImageNames.append(os.path.join(path, name))\n                ImageNamesRaw.append(name)\n    return ImageNames\n                \nLeft_Paths = SortImageNames(LEFT_PATH)\nRight_Paths = SortImageNames(RIGHT_PATH)\n\nprint('After: {}, {}, {}, ...'.format(os.path.basename(Left_Paths[0]), os.path.basename(Left_Paths[1]), os.path.basename(Left_Paths[2])))","83aceffc":"# let's look at an example picture pair from the left and right camera\n# the image pairs showing the same scenario at the same time, but from differnt points of view.\n\nfig = plt.figure(figsize=(20,20))\ngrid = ImageGrid(fig, 111, nrows_ncols=(1, 2), axes_pad=0.1)\n\nfor ax, im in zip(grid, [Left_Paths[15], Right_Paths[15]]):\n    ax.imshow(plt.imread(im))\n    ax.axis('off')","14a00ec2":"# we need to check if we have the correct Board Size\n\nexample_image = cv2.imread(Left_Paths[5])\nexample_image = cv2.cvtColor(example_image, cv2.COLOR_BGR2GRAY)\n\nret, _ = cv2.findChessboardCorners(example_image, BOARD_SIZE)\nif ret:\n    print('Board Size {} is correct.'.format(BOARD_SIZE))\nelse:\n    print('[ERROR] the Board Size is not correct!')\n    BOARD_SIZE = (0,0)","dbd5782b":"# we have to create the objectpoints\n# that are the local 2D-points on the pattern, corresponding \n# to the local coordinate system on the top left corner.\n\nobjpoints = np.zeros((BOARD_SIZE[0]*BOARD_SIZE[1], 3), np.float32)\nobjpoints[:,:2] = np.mgrid[0:BOARD_SIZE[0], 0:BOARD_SIZE[1]].T.reshape(-1,2)\nobjpoints *= SQUARE_SIZE","da13e0bb":"# now we have to find the imagepoints\n# these are the same points like the objectpoints but depending\n# on the camera coordination system in 3D\n# the imagepoints are not the same for each image\/camera\n\ndef GenerateImagepoints(paths):\n    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)\n    imgpoints = []\n    for name in paths:\n        img = cv2.imread(name)\n        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        ret, corners1 = cv2.findChessboardCorners(img, BOARD_SIZE)\n        if ret:\n            corners2 = cv2.cornerSubPix(gray, corners1, (4,4), (-1,-1), criteria)\n            imgpoints.append(corners2)\n    return imgpoints\n\nLeft_imgpoints = GenerateImagepoints(Left_Paths)\nRight_imgpoints = GenerateImagepoints(Right_Paths)","2c86317f":"# we also can display the imagepoints on the example pictures.\n\ndef DisplayImagePoints(path, imgpoints):\n    img = cv2.imread(path)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img = cv2.drawChessboardCorners(img, BOARD_SIZE, imgpoints, True)\n    return img\n    \nexample_image_left = DisplayImagePoints(Left_Paths[15], Left_imgpoints[15])\nexample_image_right = DisplayImagePoints(Right_Paths[15], Right_imgpoints[15])\n\nfig = plt.figure(figsize=(20,20))\ngrid = ImageGrid(fig, 111, nrows_ncols=(1, 2), axes_pad=0.1)\n\nfor ax, im in zip(grid, [example_image_left, example_image_right]):\n    ax.imshow(im)\n    ax.axis('off')","57581248":"# in this picture we now see the local coordinate system of the chessboard\n# the origin is at the top left corner\n# the orientation is like: long side = X\n\ndef PlotLocalCoordinates(img, points):\n    points = np.int32(points)\n    cv2.arrowedLine(img, tuple(points[0,0]), tuple(points[4,0]), (255,0,0), 3, tipLength=0.05)\n    cv2.arrowedLine(img, tuple(points[0,0]), tuple(points[BOARD_SIZE[0]*4,0]), (255,0,0), 3, tipLength=0.05)\n    cv2.circle(img, tuple(points[0,0]), 8, (0,255,0), 3)\n    cv2.putText(img, '0,0', (points[0,0,0]-35, points[0,0,1]-15), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2, cv2.LINE_AA)\n    cv2.putText(img, 'X', (points[4,0,0]-25, points[4,0,1]-15), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2, cv2.LINE_AA)\n    cv2.putText(img, 'Y', (points[BOARD_SIZE[0]*4,0,0]-25, points[BOARD_SIZE[0]*4,0,1]-15), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2, cv2.LINE_AA)\n    return img\n\nn = 15\nimg = cv2.imread(Left_Paths[n])\nimg = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\nimg = PlotLocalCoordinates(img, Left_imgpoints[n])\n\nfig = plt.figure(figsize=(10,10))\nplt.imshow(img)\nplt.axis('off')\nplt.show()","f5dc77a7":"Start_Time_Cal = time.perf_counter()","26b50676":"def CalibrateCamera(paths, imgpoints, objpoints):\n    CameraParams = {}\n    \n    gray = cv2.cvtColor(cv2.imread(Left_Paths[0]), cv2.COLOR_BGR2GRAY)\n    g = gray.shape[::-1]\n    \n    flags = 0\n    \n    objp = []\n    for i in range(20):\n        objp.append(objpoints)\n    (ret, mtx, dist, rvecs, tvecs) = cv2.calibrateCamera(objp, imgpoints, g, None, None, flags=flags)\n    \n    Rmtx = []; Tmtx = []; k = 0\n    for r in rvecs: \n        Rmtx.append(cv2.Rodrigues(r)[0])\n        Tmtx.append(np.vstack((np.hstack((Rmtx[k],tvecs[k])),np.array([0,0,0,1]))))\n        k += 1\n        \n    img = cv2.imread(Left_Paths[0],0)\n    h,w = img.shape[:2]\n    newmtx, roi = cv2.getOptimalNewCameraMatrix(mtx,dist,(w,h),1,(w,h))\n\n    if np.sum(roi) == 0:\n        roi = (0,0,w-1,h-1)\n        \n    CameraParams['Intrinsic'] = mtx\n    CameraParams['Distortion'] = dist\n    CameraParams['DistortionROI'] = roi\n    CameraParams['DistortionIntrinsic'] = newmtx\n    CameraParams['RotVektor'] = rvecs\n    CameraParams['RotMatrix'] = Rmtx\n    CameraParams['Extrinsics'] = Tmtx\n    CameraParams['TransVektor'] = tvecs\n    \n    return CameraParams","7ed61e74":"Left_Params = CalibrateCamera(Left_Paths, Left_imgpoints, objpoints)\nRight_Params = CalibrateCamera(Right_Paths, Right_imgpoints, objpoints)","11ce467a":"# let's look at the calibrated parameters from the left camera\n\nnp.set_printoptions(suppress=True, precision=5)\nprint('Intrinsic Matrix:')\nprint(Left_Params['Intrinsic'])\nprint('\\nDistortion Parameters:')\nprint(Left_Params['Distortion'])\nprint('\\nExtrinsic Matrix from 1.Image:')\nprint(Left_Params['Extrinsics'][0])","a45cd885":"def CalculateErrors(params, imgpoints, objpoints):\n    imgp = np.array(imgpoints)\n    imgp = imgp.reshape((imgp.shape[0], imgp.shape[1], imgp.shape[3]))\n    objp = np.array(objpoints)\n    K = np.array(params['Intrinsic'])\n    D = np.array(params['Distortion'])\n    R = np.array(params['RotVektor'])\n    T = np.array(params['TransVektor'])\n    N = imgp.shape[0]\n    \n    imgpNew = []\n    for i in range(N):\n        temp, _ = cv2.projectPoints(objp, R[i], T[i], K, D)\n        imgpNew.append(temp.reshape((temp.shape[0], temp.shape[2])))\n    imgpNew = np.array(imgpNew)\n    \n    err = []\n    for i in range(N):\n        err.append(imgp[i] - imgpNew[i])\n    err = np.array(err)\n    \n    def RMSE(err):\n        return np.sqrt(np.mean(np.sum(err**2, axis=1)))\n\n    errall = np.copy(err[0])\n    rmsePerView = [RMSE(err[0])]\n    for i in range(1,N):\n        errall = np.vstack((errall, err[i]))\n        rmsePerView.append(RMSE(err[i]))\n\n    rmseAll = RMSE(errall)\n    return rmsePerView, rmseAll","604d84c9":"Left_Errors, Left_MeanError = CalculateErrors(Left_Params, Left_imgpoints, objpoints)\nRight_Errors, Right_MeanError = CalculateErrors(Right_Params, Right_imgpoints, objpoints)\n\nprint('Reprojection Error Left:  {:.4f}'.format(Left_MeanError))\nprint('Reprojection Error Right: {:.4f}'.format(Right_MeanError))","14b9335d":"Left_Params['Imgpoints'] = Left_imgpoints\nLeft_Params['Errors'] = Left_Errors\nLeft_Params['MeanError'] = Left_MeanError\n\nRight_Params['Imgpoints'] = Right_imgpoints\nRight_Params['Errors'] = Right_Errors\nRight_Params['MeanError'] = Right_MeanError","8fb41a88":"def StereoCalibration(leftparams, rightparams, objpoints, imgpL, imgpR, Left_Paths, Right_Paths):\n    StereoParams = {}\n    \n    k1 = leftparams['Intrinsic']\n    d1 = leftparams['Distortion']\n    k2 = rightparams['Intrinsic']\n    d2 = rightparams['Distortion']\n    gray = cv2.imread(Left_Paths[0], 0)\n    g = gray.shape[::-1]\n    \n    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 1e-5)\n    flags = 0\n    flags |= cv2.CALIB_FIX_INTRINSIC\n    \n    objp = []\n    for i in range(20):\n        objp.append(objpoints)\n    \n    (ret, K1, D1, K2, D2, R, t, E, F) = cv2.stereoCalibrate(objp, imgpL, imgpR, k1, d1, k2, d2, g, criteria=criteria, flags=flags)\n    \n    T = np.vstack((np.hstack((R,t)),np.array([0,0,0,1])))\n    \n    StereoParams['Transformation'] = T\n    StereoParams['Essential'] = E\n    StereoParams['Fundamental'] = F\n    StereoParams['MeanError'] = ret\n    return StereoParams","3ff5cf9e":"Stereo_Params = StereoCalibration(Left_Params, Right_Params, objpoints, Left_imgpoints, Right_imgpoints, Left_Paths, Right_Paths)","7ff698ec":"print('Transformation Matrix:')\nprint(Stereo_Params['Transformation'])\nprint('\\nEssential Matrix:')\nprint(Stereo_Params['Essential'])\nprint('\\nFundamental Matrix:')\nprint(Stereo_Params['Fundamental'])\nprint('\\nMean Reprojection Error:')\nprint('{:.6f}'.format(Stereo_Params['MeanError']))","e5be3879":"end = time.perf_counter() - Start_Time_Cal\nprint('elapsed time for calibration process: {:.2f} seconds.'.format(end))","e65a2137":"Parameters = Stereo_Params\nParameters['SquareSize'] = SQUARE_SIZE\nParameters['BoardSize'] = BOARD_SIZE\nParameters['Objpoints'] = objpoints\n\nfor Lkey in Left_Params.keys():\n    name = 'L_'+str(Lkey)\n    Parameters[name] = Left_Params[Lkey]\n    \nfor Rkey in Right_Params.keys():\n    name = 'R_'+str(Rkey)\n    Parameters[name] = Right_Params[Rkey]","175551d1":"# save the Parameters dictionary into an npz file\n# with this file we can access the data afterwards very easy\n\nfile = 'parameters.npz'\nnp.savez(file, **Parameters)\nnpz = dict(np.load(file))\nsize = (npz['L_Imgpoints'].shape[0], npz['L_Imgpoints'].shape[1], npz['L_Imgpoints'].shape[3])\nnpz['L_Imgpoints'] = np.resize(npz.pop('L_Imgpoints'), size)\nnpz['R_Imgpoints'] = np.resize(npz.pop('R_Imgpoints'), size)\nnp.savez(file, **npz)","99f88436":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#51BC23;\n           font-size:110%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n        <p style=\"padding: 10px;\n              color:white;\">\n            Upvoting is for free ;)\n        <\/p>\n    <\/div>","959b731f":"## Stereo Camera Calibration","0a7effbd":"## Reprojection Errors","626673ed":"## Camera Calibration","4f5c919d":"## Constants","dbb0b40a":"## Look at the Data","d7278093":"## Detect the Chessboard Corners","abd42573":"# Calibrate a Stereocamera","15719397":"## Save the Parameters"}}