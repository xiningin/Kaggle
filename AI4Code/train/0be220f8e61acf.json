{"cell_type":{"d463f1ad":"code","796d99dc":"code","f99fa13c":"code","747eba31":"code","1bce42a9":"code","f3913b09":"code","ccf97818":"code","2a7cd1a8":"code","e7d79844":"code","c5f5973e":"code","11de9761":"code","e7e4f106":"code","6b837481":"code","053eaac8":"code","e3bda433":"code","7db1b7c6":"code","82e5b496":"code","fc3387bf":"code","5f4b824e":"code","dbf2e89e":"markdown","5997d541":"markdown","623a77dd":"markdown","48160b0d":"markdown","40e6f5cd":"markdown","11df25a3":"markdown","50995032":"markdown","7ebf39e6":"markdown","3de24c45":"markdown","6c23f499":"markdown","3fc88e64":"markdown","91b87e3a":"markdown","e36ccdb5":"markdown","5475f9d3":"markdown","141b6c94":"markdown","bffacc48":"markdown","e52b5923":"markdown","6e89706d":"markdown","cb66bdc9":"markdown","ef628ddf":"markdown","653c3b5c":"markdown","0120449a":"markdown"},"source":{"d463f1ad":"try:\n    import ujson as json\nexcept ImportError:\n    try:\n        import simplejson as json\n    except ImportError:\n        import json\nimport pickle\nimport numpy as np\nfrom ipykernel import kernelapp as app\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy import signal\nfrom scipy import stats\nfrom scipy.integrate import simps\nfrom scipy.spatial import ConvexHull\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.tree import DecisionTreeClassifier\n\nsns.set(font_scale=1.2)","796d99dc":"trajectory_file = '..\/input\/parkinsons-visionbased-pose-estimation-dataset\/UDysRS_UPDRS_Export\/Communication_all_export.txt'\n\nwith open(trajectory_file, 'r') as infile:\n    comm_dict = json.load(infile)\n\nprint(\"total number of records :{}\".format(len(comm_dict.keys())))","f99fa13c":"print(\"Key in Dictionary:\",comm_dict['26-1'].keys())\nsorted(comm_dict['26-1']['position'].keys())","747eba31":"%matplotlib inline\npart = \"Lank\"\nhorizontal_displacemt_array = np.array(comm_dict['26-1']['position'][part])[:,0]\nvertical_displacement_array = np.array(comm_dict['26-1']['position'][part])[:,1]\nfig = plt.figure(figsize=(15, 4))\nax = fig.add_subplot(121)\nax.plot(horizontal_displacemt_array,label='Horizental motion')\nax.legend(loc='best')\n\nax2 = fig.add_subplot(122)\nax2.plot(vertical_displacement_array,label='vertical motion')\nax2.legend(loc='best')\n\nplt.suptitle('Joint motion')\nfig.show()","1bce42a9":"def combinied_horizental_and_vertical(horizental_array, vertical_array):\n    combined_array = np.sqrt(np.square(horizental_array) + np.square(vertical_array))\n    return combined_array","f3913b09":"def convert_into_velocity(dispacement_array, plot=False):\n    velocity_array = np.diff(dispacement_array)\n    return velocity_array","ccf97818":"def convert_into_acceleration(velocity_array, plot=False):\n    accelation_array = np.diff(velocity_array)\n    return accelation_array","2a7cd1a8":"def convert_into_jerk(accelation_array, plot=False):\n    jerk_array = np.diff(accelation_array)\n    return jerk_array","e7d79844":"def get_kinetic_feature(motion):\n    max_motion = np.amax(motion, axis=0)\n    median_motion = np.median(motion)\n    mean_motion = np.mean(motion, axis=0)\n    standard_division_motion = np.std(motion)\n    IQR_range = stats.iqr(motion, interpolation = 'midpoint')\n    return [max_motion, median_motion, mean_motion, standard_division_motion, IQR_range]\n#print(get_kinetic_feature(displacemt_array))","c5f5973e":"def get_spectral_feature(signals, sample_frequancy=10, is_plot=False):\n    sf = sample_frequancy\n    win = 4 * sf\n    \n    # calcutate the Spectral entropy.\n    def spectral_entropy(psd, normalize=False):\n        psd_norm = np.divide(psd, psd.sum())\n        se = -np.multiply(psd_norm, np.log2(psd_norm)).sum()\n        if normalize:\n            se \/= np.log2(psd_norm.size)\n        return se\n    \n    # calculate the power band for given frequancy.\n    def bandpower(psd, freqs, min_freqs, max_freqs, is_plot=False):\n        # Define delta lower and upper limits\n        low, high = min_freqs, max_freqs\n\n        # Find intersecting values in frequency vector\n        idx_delta = np.logical_and(freqs >= low, freqs <= high)\n\n        if is_plot:\n            # Plot the power spectral density and fill the delta area\n            plt.figure(figsize=(7, 4))\n            plt.plot(freqs, psd, lw=2, color='k')\n            plt.fill_between(freqs, psd, where=idx_delta, color='skyblue')\n            plt.xlabel('Frequency (Hz)')\n            plt.ylabel('Power spectral density (uV^2 \/ Hz)')\n            plt.xlim([0, 10])\n            plt.ylim([0, psd.max() * 1.1])\n            plt.title(\"Welch's periodogram\")\n            sns.despine()\n\n        # Frequency resolution\n        freq_res = freqs[1] - freqs[0]  # = 1 \/ 4 = 0.25\n\n        # Compute the absolute power by approximating the area under the curve\n        delta_power = simps(psd[idx_delta], dx=freq_res)\n        #print('Absolute delta power: %.3f uV^2' % delta_power)\n        return delta_power\n\n    freqs, psd = signal.welch(signals, sf, nperseg=win)\n    if is_plot:\n        sns.set(font_scale=1.2, style='white')\n        plt.figure(figsize=(8, 4))\n        plt.plot(freqs, psd, color='k', lw=2)\n        plt.xlabel('Frequency (Hz)')\n        plt.ylabel('Power spectral density (V^2 \/ Hz)')\n        plt.ylim([0, psd.max() * 1.1])\n        plt.title(\"Welch's periodogram\")\n        plt.xlim([0, freqs.max()])\n        sns.despine()\n    #print(dir(psd))\n    features = {}\n    features[\"peak_magnitude\"] = np.sqrt(psd.max())\n    features[\"entropy\"] = spectral_entropy(psd)\n    features[\"half_point\"] = freqs.mean()\n    \n    features[\"total_power\"] = bandpower(psd, freqs, freqs.min(), freqs.max(), is_plot)\n    features[\"power_bands_0.5_to_1\"] = bandpower(psd, freqs, 0.5, 1, is_plot)\n    features[\"power_bands_0_to_2\"] = bandpower(psd, freqs, 0, 2, is_plot)\n    features[\"power_bands_0_to_4\"] = bandpower(psd, freqs, 0, 4, is_plot)\n    features[\"power_bands_0_to_6\"] = bandpower(psd, freqs, 0, 6, is_plot)\n    return features\nget_spectral_feature(vertical_displacement_array, is_plot=True)","11de9761":"# calculate the Area of Convex Hull of joint movement\ndef get_convexhull(darray):\n    hull = ConvexHull(darray)\n    return hull.area\nget_convexhull(np.array(comm_dict['26-1']['position'][\"Lank\"]))","e7e4f106":"def record_convertion(position_array, position_name, record_id=\"1-1\"):\n    position_array = np.array(position_array)\n    horizantal_position = position_array[:, 0]\n    vertical_position = position_array[:, 1]\n    displacement_array = combinied_horizental_and_vertical(horizantal_position, vertical_position) \n    velocity_array = convert_into_velocity(displacement_array)\n    accelation_array = convert_into_acceleration(velocity_array)\n    jerk_array = convert_into_jerk(accelation_array)\n    record = record_id.split(\"-\")\n\n    row = [record_id, int(record[0]), record[1], position_name]\n    row.extend(get_kinetic_feature(velocity_array))\n    row.extend(get_kinetic_feature(accelation_array))\n    row.extend(get_kinetic_feature(jerk_array))\n    spectral_feature_displacemt = get_spectral_feature(displacement_array)\n    row.extend([value for key, value in spectral_feature_displacemt.items()])\n    spectral_feature_velocity = get_spectral_feature(velocity_array)\n    row.extend([value for key, value in spectral_feature_velocity.items()])\n    convex_hull = get_convexhull(position_array)\n    row.extend([convex_hull])\n    return row","6b837481":"record_df = pd.DataFrame(columns=[\"combine_record_id\",\"record_id\", \"term\",\"position_name\",\n                                  \"speed_max\", \"speed_median\", \"speed_mean\", \"speed_std_div\", \"speed_iqr_range\",\n                                 \"acceleration_max\", \"acceleration_median\", \"acceleration_mean\", \"acceleration_std_div\", \"accelerati_iqr_range\",\n                                 \"jerk_max\", \"jerk_median\", \"jerk_mean\", \"jerk_std_div\", \"jerk_iqr_range\",\n                                 \"displacement_peak_magnitude\",\"displacement_entropy\", \"displacement_half_point\", \"displacement_total_power\",\n                                 \"displacement_power_bands_0.5_to_1\",\"displacement_power_bands_0_to_2\", \"displacement_power_bands_0_to_4\", \"displacement_power_bands_0_to_6\",\n                                 \"velocity_peak_magnitude\",\"velocity_entropy\", \"velocity_half_point\", \"velocity_total_power\",\n                                 \"velocity_power_bands_0.5_to_1\",\"velocity_power_bands_0_to_2\", \"velocity_power_bands_0_to_4\", \"velocity_power_bands_0_to_6\",\n                                 \"convexhull\"])\nindex = 0\n\nfor record_id, values in comm_dict.items():\n    positions = values[\"position\"]\n    resp = values[\"resp\"]\n    for position_name, position_array in positions.items():\n        row = record_convertion(position_array, position_name, record_id)\n        record_df.loc[index] = row\n        index += 1\n\nrecord_df.head(10)","053eaac8":"rating_file = '..\/input\/parkinsons-visionbased-pose-estimation-dataset\/UDysRS_UPDRS_Export\/UDysRS.txt'\n\nwith open(rating_file, 'r') as infile:\n    ratings = json.load(infile)\n\nratings.keys()","e3bda433":"ratings['Communication']['2']","7db1b7c6":"sub_score_dict = {\"Neck\":[\"face\"],\n        \"Larm\":[\"Lsho\", \"Lelb\", \"Lwri\"],\n        \"Rarm\":[\"Rsho\", \"Relb\", \"Rwri\"],\n        \"Trunk\":[\"Rsho\", \"Lsho\"],\n        \"Rleg\":[\"Rhip\", \"Rkne\", \"Rank\"],\n        \"Lleg\":[\"Lhip\", \"Lkne\", \"Lank\"]}\n\n#sub_score_dict\ngroups = record_df.groupby(\"combine_record_id\")\nprocessed_df = pd.DataFrame(columns=[\"combine_record_id\",\"record_id\", \"term\",\"position_name\",\"sub_score\",\n                                  \"speed_max\", \"speed_median\", \"speed_mean\", \"speed_std_div\", \"speed_iqr_range\",\n                                 \"acceleration_max\", \"acceleration_median\", \"acceleration_mean\", \"acceleration_std_div\", \"accelerati_iqr_range\",\n                                 \"jerk_max\", \"jerk_median\", \"jerk_mean\", \"jerk_std_div\", \"jerk_iqr_range\",\n                                     \"displacement_peak_magnitude\",\"displacement_entropy\", \"displacement_half_point\", \"displacement_total_power\",\n                                 \"displacement_power_bands_0.5_to_1\",\"displacement_power_bands_0_to_2\", \"displacement_power_bands_0_to_4\", \"displacement_power_bands_0_to_6\",\n                                 \"velocity_peak_magnitude\",\"velocity_entropy\", \"velocity_half_point\", \"velocity_total_power\",\n                                 \"velocity_power_bands_0.5_to_1\",\"velocity_power_bands_0_to_2\", \"velocity_power_bands_0_to_4\", \"velocity_power_bands_0_to_6\",\n                                 \"convexhull\", \"UDysRS_rating\"])\n\ndef find_rating(record_id, sub_group):\n    order = {\"Neck\":0,\n             \"Rarm\":1,\n             \"Larm\":2,\n             \"Trunk\":3,\n             \"Rleg\":4,\n             \"Lleg\":5}\n    try:\n        rating = ratings['Communication'][str(record_id)][order[sub_group]]\n    except:\n        rating = 0\n    return rating\n    \nfor record_id, group in groups:\n    #print(record_id)\n    for index, dict_ in group.iterrows():\n        position_name = dict_[\"position_name\"]\n        for sub_score, values in sub_score_dict.items():\n            if position_name in values:\n                #print(key, position_name)\n                dict_[\"sub_score\"] = sub_score\n                dict_[\"UDysRS_rating\"] = find_rating(dict_[\"record_id\"], sub_score)\n                #print(dict_)\n                processed_df = processed_df.append(dict_, ignore_index=True)\n                \n    #print(group.head(17))\nprocessed_df.head()","82e5b496":"grouped_df = processed_df.groupby(['record_id', 'sub_score']).mean().reset_index()\ngrouped_df.head(7)","fc3387bf":"sub_score_gr = grouped_df.groupby([\"sub_score\"])\nfor sub_score, sub_score_group in sub_score_gr:\n    print(sub_score)\n    y = sub_score_group[\"UDysRS_rating\"].astype('float64') \n    X = sub_score_group.drop(['record_id', 'sub_score', 'UDysRS_rating'], axis=1)\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20)\n    #print(X.head())\n    reg = LinearRegression()\n    reg.fit(X_train, y_train)\n    filename = '{}_model.sav'.format(sub_score)\n    pickle.dump(reg, open(filename, 'wb'))\n    print(reg.score(X_test, y_test))\n    ","5f4b824e":"sub_score_gr = grouped_df.groupby([\"sub_score\"])\nfor sub_score, sub_score_group in sub_score_gr:\n    print(sub_score)\n    y = sub_score_group[\"UDysRS_rating\"].astype(str)\n    X = sub_score_group.drop(['record_id', 'sub_score', 'UDysRS_rating'], axis=1)\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20)\n    #print(X.head())\n    clf = DecisionTreeClassifier()\n    clf.fit(X_train, y_train)\n    filename = '{}_decision_tree_model.sav'.format(sub_score)\n    pickle.dump(reg, open(filename, 'wb'))\n    print(clf.score(X_test, y_test))\n    \n","dbf2e89e":"# Creating Sub score of Joints","5997d541":"## Feature Extraction\n\nFor this problem we are considering Three features:\n\n1. Kinetic feature\n2. Spectral density feature\n3. Convex Hull feature","623a77dd":"Each key is a string with the format 'trial number - segment number (noise type)'. Most trials have 3 parts. Some trajectories contain noise such as occlusions or shaking. These may be omitted if you choose, although we kept all trajectories included in this data set. Camera shake has already been removed as described in the paper.\n\nAssociated with each key is another dictionary containing two parts:","48160b0d":"# 1. Trajectories\n\nA. Communication\/Drinking Tasks\nLet's try loading the data from the communication task. The format of the files for the communication and drinking tasks is the same.","40e6f5cd":"# Iterate All other records ","11df25a3":"### 3. Convex Hull Feature.\nThe final feature was the convex hull, which quantifies the area that a joint moved within.","50995032":"Horizental and vertical motion of Lank\n","7ebf39e6":"### Mean of all sub score\nfor multiple trials is taken for each paisent t\\so we average the feature per sub score","3de24c45":"Combined motion(combination of hotizental and vertical motion)","6c23f499":"### Data Visualization","3fc88e64":"#### Decision Tree ","91b87e3a":"1. Spectral Entropy: \n    Spectral Entropy is defined to be the Shannon entropy of the power spectral density (PSD) of the data:\n\n\n\n    Where P is the normalised PSD, and fs is the sampling frequency.\n\n2. BandPower:\n    how band power is calculated\n3. Peak Mangnitude: \n    Its Sqaure root of PSD Max value.\n\n4. Half Point(frequency that divides spectral power into equal halves): \n    For simplicity we have make it mean value. for future we will make the correct value.","e36ccdb5":"### 2. Spectral density feature\nThere was a total of 16 spectral features:\nPeak magnitude, Entropy, Total power, Half point (i.e.frequency that divides spectral power into equal halves), and power bands 0.5\u20131 Hz, > 2 Hz, > 4 Hz, > 6 Hz for both the displacement and velocity PSD.\n","5475f9d3":"#### c. Convert Acceleration into jerk","141b6c94":"# Model creation","bffacc48":"### Ratings\nUnified Parkinson\u2019s Disease Rating Scale \n#A. UDysRS ","e52b5923":"# Code for using Parkinson's Pose Estimation Dataset\n\nThis notebook describes the dataset accompanying, feature generation and model creation of the paper: 'Vision-Based Assessment of Parkinsonism and Levodopa-Induced Dyskinesia with Deep Learning Pose Estimation' - Li, Mestre, Fox, Taati (2017).\n\nThe data includes all movement trajectories extracted from the videos of Parkinson's assessments using Convolutional Pose Machines (CPM) (https:\/\/arxiv.org\/abs\/1602.00134), as well as the confidence values from CPM. The dataset also includes ground truth ratings of parkinsonism and dyskinesia severity using the UDysRS, UPDRS, and CAPSIT.\n\nCamera shake has been removed from trajectories as described in the paper. No other preprocessing has been performed.\n\nPlace data files in the same folder as this file (data_import_demo.py).\n\nFiles are saved in JSON format, so you'll require a JSON reading package in Python. Python comes with a package called json but we recommend ujson or simplejson (both of which are drop-in replacements for json and included in Anaconda).","6e89706d":"### Regression","cb66bdc9":"#### a. Convert Displacement into velocity","ef628ddf":"'position' is the trajectory of each joint and 'resp' is the confidence from CPM. These are each provided for 15 joints:","653c3b5c":"#### b. Convert velocity into acceleration","0120449a":"### 1. Kinetic Feature\nThere were 15 kinematic features:\nthe maximum, median, mean, standard deviation, and interquartile range of \nthe speed, magnitude of acceleration, and magnitude of jerk"}}