{"cell_type":{"afb1cf1e":"code","171aee2f":"code","0c36114d":"code","773946ad":"code","468aa60d":"code","78782bb6":"code","fe9036eb":"code","a4bf9258":"code","76c40e12":"code","9c456e0e":"code","fb88386c":"code","fc7c8d9f":"code","6394808e":"code","31367e06":"code","7e213392":"code","1e50611c":"code","569486b1":"code","3313fcc6":"code","511a18b1":"code","1b1d8b00":"code","1b5c19ce":"code","3a5c6222":"code","2ee313d4":"code","af80d69b":"code","dd3ff7d6":"code","bdf22633":"code","0a3a6d72":"code","a3a996e9":"code","f8d6a2cb":"code","cd4a3580":"code","f79f98d3":"code","162b6576":"code","d631308b":"code","3b61aaeb":"code","a1850d77":"code","16f3b0f8":"code","bdaf9db9":"code","f04f70a5":"code","7cac98d3":"code","3839c471":"code","59572f7f":"code","7d17ab59":"code","236ab82b":"code","b5e8e2d0":"code","41054ea7":"code","5cc9a346":"code","392c549d":"code","6a084409":"code","28b64a2b":"code","cd957328":"code","f3734f45":"code","544c4e5e":"code","b64bceb8":"code","b9036304":"markdown","85d2c30e":"markdown","3ef7d375":"markdown","e27aa2b8":"markdown","80e8215b":"markdown","c32f01c6":"markdown","55350bfc":"markdown"},"source":{"afb1cf1e":"import sys\nsys.path.append('..\/input\/iterative-stratification\/iterative-stratification-master')\nsys.path.append('..')\nfrom iterstrat.ml_stratifiers import MultilabelStratifiedKFold","171aee2f":"import numpy as np\nimport random\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport os\nimport copy\nimport seaborn as sn\n\nfrom sklearn import preprocessing\nfrom sklearn.metrics import log_loss\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import QuantileTransformer\nfrom sklearn.pipeline import make_pipeline,make_union\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nfrom joblib import dump, load\n\nBOOK1 = '..\/input\/daebook1c\/'","0c36114d":"def reduce_mem_usage(props):\n    start_mem_usg = props.memory_usage().sum() \/ 1024**2 \n    print(\"Memory usage of properties dataframe is :\",start_mem_usg,\" MB\")\n    NAlist = [] # Keeps track of columns that have missing values filled in. \n    for col in props.columns:\n        if props[col].dtype != object:  # Exclude strings\n            \n            # Print current column type\n            #print(\"******************************\")\n            #print(\"Column: \",col)\n            #print(\"dtype before: \",props[col].dtype)\n            \n            # make variables for Int, max and min\n            IsInt = False\n            mx = props[col].max()\n            mn = props[col].min()\n            \n            # Integer does not support NA, therefore, NA needs to be filled\n            if not np.isfinite(props[col]).all(): \n                NAlist.append(col)\n                props[col].fillna(mn-1,inplace=True)  \n                   \n            # test if column can be converted to an integer\n            asint = props[col].fillna(0).astype(np.int64)\n            result = (props[col] - asint)\n            result = result.sum()\n            if result > -0.01 and result < 0.01:\n                IsInt = True\n\n            \n            # Make Integer\/unsigned Integer datatypes\n            if IsInt:\n                if mn >= 0:\n                    if mx < 255:\n                        props[col] = props[col].astype(np.uint8)\n                    elif mx < 65535:\n                        props[col] = props[col].astype(np.uint16)\n                    elif mx < 4294967295:\n                        props[col] = props[col].astype(np.uint32)\n                    else:\n                        props[col] = props[col].astype(np.uint64)\n                else:\n                    if mn > np.iinfo(np.int8).min and mx < np.iinfo(np.int8).max:\n                        props[col] = props[col].astype(np.int8)\n                    elif mn > np.iinfo(np.int16).min and mx < np.iinfo(np.int16).max:\n                        props[col] = props[col].astype(np.int16)\n                    elif mn > np.iinfo(np.int32).min and mx < np.iinfo(np.int32).max:\n                        props[col] = props[col].astype(np.int32)\n                    elif mn > np.iinfo(np.int64).min and mx < np.iinfo(np.int64).max:\n                        props[col] = props[col].astype(np.int64)    \n            \n            # Make float datatypes 32 bit\n            else:\n                props[col] = props[col].astype(np.float32)\n            \n            # Print new column type\n           # print(\"dtype after: \",props[col].dtype)\n           # print(\"******************************\")\n    \n    # Print final result\n    print(\"___MEMORY USAGE AFTER COMPLETION:___\")\n    mem_usg = props.memory_usage().sum() \/ 1024**2 \n    print(\"Memory usage is: \",mem_usg,\" MB\")\n    print(\"This is \",100*mem_usg\/start_mem_usg,\"% of the initial size\")\n    return props, NAlist\n\ndef train_short_form_loader(feature_file,target_file,extra_target_file=None):\n    '''takes the original target and features and creates a train dataset \n    in col long format'''\n\n\n    train_features = pd.read_csv(feature_file)\n\n    train_targets = pd.read_csv(target_file)\n    train_features,_= reduce_mem_usage(train_features)\n    train_targets,_ = reduce_mem_usage(train_targets)\n\n\n    if extra_target_file is not None:\n        extra_targets = pd.read_csv(extra_target_file)\n        extra_targets,_ = reduce_mem_usage(extra_targets)\n        train_targets = pd.merge(train_targets,extra_targets,on ='sig_id')\n        del extra_targets\n\n    targets = train_targets.columns[1:]\n\n    train_melt=train_targets.merge(train_features,how=\"left\",on=\"sig_id\")\n\n\n    del train_features,train_targets\n\n\n    train_melt.set_index(\"sig_id\",inplace=True)\n\n    #train_melt[\"variable\"]= train_melt[\"variable\"].astype('category')\n    train_melt[\"cp_type\"]= train_melt[\"cp_type\"].astype('category')\n    train_melt[\"cp_dose\"]= train_melt[\"cp_dose\"].astype('category')\n\n    return train_melt , targets.to_list()\n\n\n\ndef test_short_form_loader(feature_file):\n    '''takes the original target and features and creates a train dataset \n    in col long format'''\n\n\n    train_features = pd.read_csv(feature_file)\n\n    #train_targets = pd.read_csv(target_file)\n    train_features,_= reduce_mem_usage(train_features)\n    #train_targets,_ = reduce_mem_usage(train_targets)\n\n    train_melt =  train_features.copy()\n    del train_features\n\n\n    train_melt.set_index(\"sig_id\",inplace=True)\n\n    #train_melt[\"variable\"]= train_melt[\"variable\"].astype('category')\n    train_melt[\"cp_type\"]= train_melt[\"cp_type\"].astype('category')\n    train_melt[\"cp_dose\"]= train_melt[\"cp_dose\"].astype('category')\n\n    return train_melt \n\n","773946ad":"input_directory = '..\/input\/lish-moa\/'","468aa60d":"train,target_cols = train_short_form_loader(input_directory +'train_features.csv',input_directory+'train_targets_scored.csv')\ntest = test_short_form_loader(input_directory +\"test_features.csv\")\n","78782bb6":"GENES = [col for col in train.columns if col.startswith('g-')]\nCELLS = [col for col in train.columns if col.startswith('c-')]","fe9036eb":"from sklearn.decomposition import PCA\nfrom sklearn.preprocessing import QuantileTransformer","a4bf9258":"from sklearn.compose import make_column_transformer,ColumnTransformer","76c40e12":"def seed_everything(seed=42):\n    random.seed(seed)\n    #os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n    \nseed_everything(seed=42)","9c456e0e":"from sklearn.base import BaseEstimator,TransformerMixin\n\nclass CatIntMapper( BaseEstimator, TransformerMixin ):\n    #Class constructor method that takes in a list of values as its argument\n    def __init__(self ,col,dicti):\n        self.col = col\n        self.dicti = dicti\n        \n    def fit(self, X, y = None):\n        \n        return self\n    #Return self nothing else to do here\n    def fit_transform( self, X, y = None  ):\n        \n        assert  X[self.col].isin(self.dicti.keys()).all() \n        \n       \n        return pd.concat([X.drop(self.col,axis=1),X[self.col].map(self.dicti).astype(int).rename(self.col)],axis=1) \n    \n    def transform( self, X):\n        assert  X[self.col].isin(self.dicti.keys()).all() \n        \n        return pd.concat([X.drop(self.col,axis=1),X[self.col].map(self.dicti).astype(int).rename(self.col)],axis=1) \n\nclass NamedOutTWrapper( BaseEstimator, TransformerMixin ):\n    \n    def __init__(self,transformer,columns,inplace=False,prefix='_' ):\n        \n        self.transformer = transformer\n        self.cols = columns\n        self.inplace =  inplace\n        self.prefix = prefix\n        self.transformer_name = self._get_transformer_name()\n        \n    def fit(self, X, y = None):\n            \n        self.transformer =   self.transformer.fit(X[self.cols] , y )\n            \n        return self\n    #Return self nothing else to do here\n    def fit_transform( self, X, y = None  ):\n        \n       \n        \n        transformed_columns = self.transformer.fit_transform(X[self.cols] , y )\n        out=pd.DataFrame(index=X.index)\n        \n       \n        if self.inplace:\n            out = X[self.cols]\n            out[self.cols] = transformed_columns\n            \n            return pd.concat([X.drop(self.cols,axis=1),out],axis=1)\n        else:\n           \n            for i,values in enumerate(transformed_columns.transpose()):\n            \n                out[ self.transformer_name + self.prefix + str(i)] = values\n        \n       \n        \n            return   pd.concat([X,out],axis=1)\n    \n    def transform( self, X):\n        \n        transformed_columns = self.transformer.transform(X[self.cols]  )\n        \n        out=pd.DataFrame(index=X.index)\n        \n        if self.inplace:\n            out = X[self.cols]\n            out[self.cols] = transformed_columns\n            \n            return pd.concat([X.drop(self.cols,axis=1),out],axis=1)\n        else:\n            for i,values in enumerate(transformed_columns.transpose()):\n\n                out[ self.transformer_name + self.prefix + str(i)] = values\n\n             \n        return   pd.concat([X,out],axis=1)\n            \n    \n    def _get_transformer_name(self):\n        return str(self.transformer.__class__).split('.')[-1][0:-2]\n\n\nclass IdentityTransformer:\n    '''Duummy_tansformer as a filler'''\n    def __init__(self ):\n        pass\n    def fit(self, X, y = None):\n        \n        return self\n    #Return self nothing else to do here\n    def fit_transform( self, X, y = None  ):\n        \n        return  X\n      \n    \n    def transform( self, X):\n       \n        return  X    \n\nclass SuppressControls( BaseEstimator, TransformerMixin ):\n    #Class constructor method that takes in a list of values as its argument\n    def __init__(self ):\n        pass\n    def fit(self, X, y = None):\n        return self\n    #Return self nothing else to do here\n    def fit_transform( self, X, y = None  ):\n        \n      \n        \n        return   X.loc[X['cp_type']!='ctl_vehicle'].drop('cp_type', axis=1) \n    \n    def transform( self, X):\n       \n       \n        return    X.loc[X['cp_type']!='ctl_vehicle'].drop('cp_type', axis=1)\n","fb88386c":"def multifold_indexer(train,target_columns,n_splits=10,random_state=12347,**kwargs):\n    folds = train.copy()\n\n    mskf = MultilabelStratifiedKFold(n_splits=n_splits,random_state=random_state,**kwargs)\n    folds[ 'kfold']=0\n    for f, (t_idx, v_idx) in enumerate(mskf.split(X=train, y=train[target_columns])):\n        folds.iloc[v_idx,-1] = int(f)\n\n    folds['kfold'] = folds['kfold'].astype(int)\n    return folds\n","fc7c8d9f":"class MoADataset:\n    def __init__(self, features, targets):\n        self.features = features\n        self.targets = targets\n        \n    def __len__(self):\n        return (self.features.shape[0])\n    \n    def __getitem__(self, idx):\n        dct = {\n            'x' : torch.tensor(self.features[idx, :], dtype=torch.float),\n            'y' : torch.tensor(self.targets[idx, :], dtype=torch.float)            \n        }\n        return dct\n    \n\n    \nclass TestDataset:\n    def __init__(self, features):\n        self.features = features\n        \n    def __len__(self):\n        return (self.features.shape[0])\n    \n    def __getitem__(self, idx):\n        dct = {\n            'x' : torch.tensor(self.features[idx, :], dtype=torch.float)\n        }\n        return dct\n    ","6394808e":"class DAE_Model(nn.Module):\n    def __init__(self, num_features, num_targets, hidden_size=1100,hidden_size2=1300):\n        super(DAE_Model, self).__init__()\n        self.batch_norm1 = nn.BatchNorm1d(num_features)\n        #self.dropout1 = nn.Dropout(drop_rate1)\n        self.dense1 = nn.utils.weight_norm(nn.Linear(num_features, hidden_size))\n        \n        self.batch_norm2 = nn.BatchNorm1d(hidden_size)\n      #  self.dropout2 = nn.Dropout(drop_rate2)\n        self.dense2 = nn.utils.weight_norm(nn.Linear(hidden_size, hidden_size2))\n        \n        self.batch_norm3 = nn.BatchNorm1d(hidden_size2)\n        #self.dropout3 = nn.Dropout(drop_rate2)\n        self.dense3 = nn.utils.weight_norm(nn.Linear(hidden_size2, hidden_size))\n        \n      #  self.batch_norm4 = nn.BatchNorm1d(hidden_size)\n      #  self.dropout4 = nn.Dropout(drop_rate3)\n        self.dense4 = nn.utils.weight_norm(nn.Linear(hidden_size, num_features))\n\n        \n    def forward(self, x,mode='DAE'):\n      #  x = self.batch_norm1(x)\n       # x1 = self.dropout1(x1)\n        x1 = F.relu(self.dense1(x))\n        \n            \n        x2 = self.batch_norm2(x1)\n      #  x = self.dropout2(x)\n        x2 = F.relu(self.dense2(x2))\n        \n        x3 = self.batch_norm3(x2)\n      \n        x3 = F.relu(self.dense3(x3))\n        \n        out = self.dense4(x3)\n        \n        if mode == 'DAE':\n            return out\n        else:\n            return x1,x2,x3\n    \n#     def forwardh2(self, x):\n#       #  x = self.batch_norm1(x)\n#        # x1 = self.dropout1(x1)\n#         x = F.relu(self.dense1(x))\n        \n#         return x\n    \n#     def forwardh3(self, x):\n#       #  x = self.batch_norm1(x)\n#        # x1 = self.dropout1(x1)\n#         x = F.relu(self.dense1(x))\n        \n#         return x","31367e06":"from sklearn.decomposition import PCA\nfrom sklearn.preprocessing import QuantileTransformer\nfrom sklearn.pipeline import make_pipeline,make_union\n","7e213392":"\nmap_controls = CatIntMapper('cp_type',{'ctl_vehicle': 0, 'trt_cp': 1})    \n\nmap_dose = CatIntMapper('cp_dose',{'D1': 1, 'D2': 0})    \nmap_time = CatIntMapper('cp_time',{24: 0, 48: 1, 72: 2})    \n","1e50611c":"train = pd.read_csv(f'{input_directory}\/train_features.csv')","569486b1":"GENES = [col for col in train.columns if col.startswith('g-')]\nCELLS = [col for col in train.columns if col.startswith('c-')]","3313fcc6":"#GENES","511a18b1":"Rankg_g_tansform =  NamedOutTWrapper( QuantileTransformer(n_quantiles=100,random_state=0, output_distribution=\"normal\"),columns= GENES+CELLS,inplace=True)","1b1d8b00":"PCA_g_tansform =  NamedOutTWrapper(PCA(20),columns= GENES,prefix ='_g' )","1b5c19ce":"PCA_c_tansform =  NamedOutTWrapper(PCA(20),columns= CELLS,prefix ='_c' )","3a5c6222":"#transformers_list=[map_controls,map_dose,map_time,PCA_g_tansform,PCA_c_tansform,Rankg_g_tansform]","2ee313d4":"from sklearn.base import BaseEstimator, TransformerMixin\n\nclass ColumnDropper( BaseEstimator, TransformerMixin ):\n    #Class Constructor \n    def __init__( self, cols ):\n        self.cols=cols\n    #Return self nothing else to do here    \n    def fit( self, X, y = None ):\n        return self \n    \n    #Method that describes what we need this transformer to do\n    def transform( self, X, y = None ):\n\n        return X.drop(self.cols,axis=1)\n","af80d69b":"\nCatDropper =ColumnDropper(cols=['cp_type','cp_time','cp_dose'])","dd3ff7d6":"transformers_list=[map_controls,map_dose,map_time,Rankg_g_tansform,CatDropper]","bdf22633":"exp_name = 'test_DAE_0.3_all_together'","0a3a6d72":"def run_inference(X_train,y_train,X_valid,y_valid,X_test,fold, seed,inference_only=False,**kwargs):\n    seed_everything(seed)\n    if not  inference_only:\n        train_dataset = MoADataset(X_train, y_train)\n        valid_dataset = MoADataset(X_valid, y_valid)\n        trainloader = torch.utils.data.DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)\n        validloader = torch.utils.data.DataLoader(valid_dataset, batch_size=BATCH_SIZE, shuffle=False)\n\n    testdataset = TestDataset(X_test)\n    testloader = torch.utils.data.DataLoader(testdataset, batch_size=BATCH_SIZE, shuffle=False)\n    \n    model = DAE_Model(\n        num_features= X_train.shape[1] ,\n        num_targets=  X_train.shape[1],\n       # hidden_size=hidden_size,\n        **kwargs\n    )\n    \n    \n    model.load_state_dict(torch.load( f\"{BOOK1}FOLD{fold}_{exp_name}.pth\",map_location=torch.device('cpu')))#map_location='cuda:0'))#,freeze_first_layer=True)\n    print('### LOADED FOLD%i MODEL'%fold)\n    \n    model.to(DEVICE)\n    \n    if not  inference_only:\n        oof = inference_infer_features_fn(model, validloader, DEVICE)    \n    else:\n        oof= 0\n    \n\n    predictions = infer_features_fn(model, testloader, DEVICE)\n    \n    predictions = predictions\n    \n    return oof, predictions","a3a996e9":"transformers_list","f8d6a2cb":"\nDEVICE = ('cuda' if torch.cuda.is_available() else 'cpu')\nEPOCHS = 1000\nBATCH_SIZE = 640\nLEARNING_RATE = 2e-3\nWEIGHT_DECAY = 1e-8\nNFOLDS = 10\nEARLY_STOPPING_STEPS = 10\nEARLY_STOP = False\nGAMMA=0.5\nFACTOR=0.75\n#num_features=len(feature_cols)\n#num_targets=len(target_cols)\nhidden_size=1100\nhidden_size2=1300\nPATIENCE=10\nTHRESHOLD = 5e-3","cd4a3580":"def train_fn(model, optimizer, scheduler, loss_fn, dataloader, device):\n    model.train()\n    final_loss = 0\n    \n    for data in dataloader:\n        optimizer.zero_grad()\n        inputs, targets = data['x'].to(device), data['y'].to(device)\n#         print(inputs.shape)\n        outputs = model(inputs)\n        loss = loss_fn(outputs, targets)\n        loss.backward()\n        optimizer.step()\n        \n        if not  scheduler.__class__ ==  torch.optim.lr_scheduler.ReduceLROnPlateau:\n            scheduler.step()\n        \n        final_loss += loss.item()\n        \n    final_loss \/= len(dataloader)\n    \n    return final_loss\n\n\ndef valid_fn(model, scheduler, loss_fn, dataloader, device):\n    model.eval()\n    final_loss = 0\n    valid_preds = []\n    \n    for data in dataloader:\n        inputs, targets = data['x'].to(device), data['y'].to(device)\n        outputs = model(inputs)\n        loss = loss_fn(outputs, targets)\n        \n        final_loss += loss.item()\n        valid_preds.append(outputs.sigmoid().detach().cpu().numpy())\n        \n    final_loss \/= len(dataloader)\n    valid_preds = np.concatenate(valid_preds)\n    \n    if scheduler.__class__ ==  torch.optim.lr_scheduler.ReduceLROnPlateau:\n        scheduler.step(final_loss)\n    \n    return final_loss, valid_preds\n\ndef inference_fn(model, dataloader, device):\n    model.eval()\n    preds = []\n    \n    for data in dataloader:\n        inputs = data['x'].to(device)\n\n        with torch.no_grad():\n            outputs = model(inputs)\n        \n        preds.append(outputs.sigmoid().detach().cpu().numpy())\n        \n    preds = np.concatenate(preds)\n    \n    return preds\n\n\ndef infer_features_fn(model, dataloader, device):\n    model.eval()\n    preds = []\n    \n    for data in dataloader:\n        inputs = data['x'].to(device)\n\n        with torch.no_grad():\n            outputs = model(inputs,mode='get_features')\n        \n#         print(len(outputs))\n        \n#         for i in range(len(outputs)):\n#             print(outputs[i].shape)\n            \n#         print(torch.cat(outputs,axis=1).shape)\n        \n        preds.append(torch.cat(outputs,axis=1).detach().cpu().numpy())\n        \n        \n        \n    preds = np.concatenate(preds)\n    \n    return preds\n   \n    ","f79f98d3":"#SEED = [0,12347,565657,123123,78591]\nSEED = [0]\ntrain,target_cols = train_short_form_loader('..\/input\/lish-moa\/train_features.csv','..\/input\/lish-moa\/train_targets_scored.csv')\ntest = test_short_form_loader(\"..\/input\/lish-moa\/test_features.csv\")\n\ntrain = pd.concat([train,test])\ntrain[target_cols]= train[target_cols].fillna(0)\ntest = train.copy()\n#pipeline_test = make_pipeline(*transformers_list)\n#pipeline_test.fit(train)\n#test = pipeline_test.transform(test)\n    \n\n\n\noof = np.zeros((len(train), len(target_cols)))\npredictions = np.zeros((len(test), len(target_cols)))\n\nfor seed in SEED:\n    \n    train = multifold_indexer(train,target_cols,n_splits=NFOLDS)\n    \n    #print(test_.head())\n    for fold in range(NFOLDS):\n        \n     \n        #pipeline_val = pk.load(open(f\"..\/input\/tmultiv5rnkgpcag50smth1e3unpropertrafo\/preprocessing_SEED{seed}_FOLD{fold}.pth\",'rb'))\n        \n        \n        #trn_idx = train[train['kfold'] != fold].reset_index().index\n        #val_idx = train[train['kfold'] == fold].reset_index().index\n    \n        train_df = train[train['kfold'] != fold]#.reset_index(drop=True)\n        valid_df = train[train['kfold'] == fold]#.reset_index(drop=True)\n        \n       # print(len(train_df))\n        #print(len(valid_df))\n        \n        feature_cols = [col  for col in train_df.columns if not (col in target_cols+['kfold'])]\n        \n        #print(feature_cols)\n        \n        pipeline_val = make_pipeline(*transformers_list)\n        \n        X_train, y_train  = train_df[feature_cols], train_df[target_cols]\n        X_valid, y_valid =  valid_df[feature_cols], valid_df[target_cols].values\n        \n        pipeline_val.fit(X_train)\n        \n        ###############################\n        #### SAVE\/LOAD PREPROCESSING #######\n        dump(pipeline_val,'pipeline_val2_fold%i.joblib'%fold)\n        pipeline_val = load('pipeline_val2_fold%i.joblib'%fold)\n        print('SAVED PIPELINE_VAL2_FOLD%i'%fold)\n        print(pipeline_val)\n        ###############################\n       \n        ##X_train = pipeline_val.fit_transform(X_train,y_train)\n        #X_train = pipeline_val.fit_transform(X_train)\n        \n        X_train = pipeline_val.transform(X_train)\n                \n        #feature_cols = [col  for col in X_train.columns if not (col in target_cols+['kfold'])]\n        \n        X_train = X_train.values\n        \n        \n        X_valid = pipeline_val.transform(X_valid)\n        \n        \n        \n        \n        valid_index = X_valid.index\n        X_valid = X_valid.values\n        \n        y_train = y_train.values\n        \n       \n        \n        X_test = test[feature_cols]\n            \n        \n        X_test = pipeline_val.transform(X_test).values\n        \n        #X_test = X_test.values\n        \n        \n        pred_ = run_inference(X_train,y_train,X_valid,y_valid,X_test,fold, seed,inference_only=True)\n        \n        print('## extracted features', pred_[1].shape, len(train) )\n        transformed_features = pd.DataFrame(pred_[1],index=test.index)\n        transformed_features.columns = [str(i) for i in range(len(transformed_features.columns))]\n        transformed_features.reset_index().to_feather('.\/features_0.2_altogether_fold%i.fth'%fold)\n        \n        if fold>=6: break","162b6576":"import sys\nsys.path.append('..\/input\/iterative-stratification\/iterative-stratification-master')\n\nfrom iterstrat.ml_stratifiers import MultilabelStratifiedKFold","d631308b":"from sklearn.base import BaseEstimator, TransformerMixin","3b61aaeb":"class MoADataset:\n    def __init__(self, features, targets):\n        self.features = features\n        self.targets = targets\n        \n    def __len__(self):\n        return (self.features.shape[0])\n    \n    def __getitem__(self, idx):\n        dct = {\n            'x' : torch.tensor(self.features[idx, :], dtype=torch.float),\n            'y' : torch.tensor(self.targets[idx, :], dtype=torch.float)            \n        }\n        return dct\n    \nclass TestDataset:\n    def __init__(self, features):\n        self.features = features\n        \n    def __len__(self):\n        return (self.features.shape[0])\n    \n    def __getitem__(self, idx):\n        dct = {\n            'x' : torch.tensor(self.features[idx, :], dtype=torch.float)\n        }\n        return dct\n    ","a1850d77":"def seed_everything(seed=42):\n    random.seed(seed)\n    #os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n    ","16f3b0f8":"class DaeAdder( BaseEstimator, TransformerMixin ):\n    def __init__(self,filename):\n        \n        self.filename=filename\n    \n    def fit(self,X,y=None):\n        return self\n    \n    def fit_transform(self,X,y=None):\n        \n        Dae_features = pd.read_feather(self.filename).set_index('sig_id')\n        \n        return X.merge(Dae_features,how='left', on='sig_id')\n        \n        \n    def transform(self,X):\n        \n        Dae_features = pd.read_feather(self.filename).set_index('sig_id')\n        \n        return X.merge(Dae_features,how='left', on='sig_id')\n        \n        ","bdaf9db9":"\n\nclass SupressControls( BaseEstimator, TransformerMixin ):\n    #Class constructor method that takes in a list of values as its argument\n    def __init__(self ):\n        pass\n    def fit(self, X, y = None):\n        return self\n    #Return self nothing else to do here\n    def fit_transform( self, X, y = None  ):\n        \n        X = X[X['cp_type']!=0]\n        X = X.drop('cp_type', axis=1)\n        return X \n    \n    def transform( self, X):\n        X = X[X['cp_type']!=0]\n        X = X.drop('cp_type', axis=1)\n        return X\n    \nclass CatIntMapper( BaseEstimator, TransformerMixin ):\n    #Class constructor method that takes in a list of values as its argument\n    def __init__(self ,col,dicti):\n        self.col = col\n        self.dicti = dicti\n        \n    def fit(self, X, y = None):\n        \n        return self\n    #Return self nothing else to do here\n    def fit_transform( self, X, y = None  ):\n        \n        assert  X[self.col].isin(self.dicti.keys()).all() \n        \n       \n        return pd.concat([X.drop(self.col,axis=1),X[self.col].map(self.dicti).astype(int).rename(self.col)],axis=1) \n    \n    def transform( self, X):\n        assert  X[self.col].isin(self.dicti.keys()).all() \n        \n        return pd.concat([X.drop(self.col,axis=1),X[self.col].map(self.dicti).astype(int).rename(self.col)],axis=1) \n\nclass NamedOutTWrapper( BaseEstimator, TransformerMixin ):\n    \n    def __init__(self,transformer,columns,inplace=False,prefix='_' ):\n        \n        self.transformer = transformer\n        self.cols = columns\n        self.inplace =  inplace\n        self.prefix = prefix\n        self.transformer_name = self._get_transformer_name()\n        \n    def fit(self, X, y = None):\n            \n        self.transformer =   self.transformer.fit(X[self.cols] , y )\n            \n        return self\n    #Return self nothing else to do here\n    def fit_transform( self, X, y = None  ):\n        \n       \n        \n        transformed_columns = self.transformer.fit_transform(X[self.cols] , y )\n        out=pd.DataFrame(index=X.index)\n        \n       \n        if self.inplace:\n            out = X[self.cols].copy()\n            out[self.cols] = transformed_columns\n            \n            return pd.concat([X.drop(self.cols,axis=1),out],axis=1)\n        else:\n           \n            for i,values in enumerate(transformed_columns.transpose()):\n            \n                out[ self.transformer_name + self.prefix + str(i)] = values\n        \n       \n        \n            return   pd.concat([X,out],axis=1)\n    \n    def transform( self, X):\n        \n        transformed_columns = self.transformer.transform(X[self.cols]  )\n        \n        out=pd.DataFrame(index=X.index)\n        \n        if self.inplace:\n            out = X[self.cols].copy()\n            out[self.cols] = transformed_columns\n            \n            return pd.concat([X.drop(self.cols,axis=1),out],axis=1)\n        else:\n            for i,values in enumerate(transformed_columns.transpose()):\n\n                out[ self.transformer_name + self.prefix + str(i)] = values\n\n             \n        return   pd.concat([X,out],axis=1)\n            \n    \n    def _get_transformer_name(self):\n        return str(self.transformer.__class__).split('.')[-1][0:-2]\n\n\nclass IdentityTransformer:\n    '''Duummy_tansformer as a filler'''\n    def __init__(self ):\n        pass\n    def fit(self, X, y = None):\n        \n        return self\n    #Return self nothing else to do here\n    def fit_transform( self, X, y = None  ):\n        \n        return  X\n      \n    \n    def transform( self, X):\n       \n        return  X    \n\nclass SuppressControls( BaseEstimator, TransformerMixin ):\n    #Class constructor method that takes in a list of values as its argument\n    def __init__(self ):\n        pass\n    def fit(self, X, y = None):\n        return self\n    #Return self nothing else to do here\n    def fit_transform( self, X, y = None  ):\n        \n      \n        \n        return   X.loc[X['cp_type']=='trt_cp'].drop('cp_type', axis=1) \n    \n    def transform( self, X):\n       \n       \n        return    X.loc[X['cp_type']=='trt_cp'].drop('cp_type', axis=1)\n\n\nclass ColumnDropper( BaseEstimator, TransformerMixin ):\n    #Class Constructor \n    def __init__( self, cols ):\n        self.cols=cols\n    #Return self nothing else to do here    \n    def fit( self, X, y = None ):\n        return self \n    \n    #Method that describes what we need this transformer to do\n    def transform( self, X, y = None ):\n\n        return X.drop(self.cols,axis=1)\n\n\nfrom sklearn.base import BaseEstimator,TransformerMixin\n#Custom transformer that breaks dates column into year, month and day into separate columns and\n#converts certain features to binary \nclass VarianceFilter( BaseEstimator, TransformerMixin ):\n    def __init__(self,threshold):\n        self.threshold = threshold\n    def fit(self,X,y=None):\n        mask = X.var()<= self.threshold\n        self.drop_cols = set([ col for val,col in zip(mask,X.columns) if val])\n        self.drop_cols.discard('cp_type')\n        return self\n    def transform(self,X):\n        \n        return X.drop(self.drop_cols,axis=1)\n\n\ndef apply_pipe_together(pipeline,train,test,ct=None):\n    #@add warning when intesection is not the whole\n    data = pd.concat([train,test])\n\n    #data = pipeline.fit_transform(data)\n    pipeline.fit(data)\n    \n    ###############################\n    #### SAVE\/LOAD PREPROCESSING #######\n    dump(pipeline,'pipe_together_ct%i.joblib'%ct)\n    pipeline = load('pipe_together_ct%i.joblib'%ct)\n    print('SAVE\/LOAD PIPE_TOGETHER_CT%i'%ct)\n    print(pipeline)\n    ###############################\n    \n    data = pipeline.transform(data)\n    \n    train = data.loc[data.index.intersection(train.index)]\n    test = data.loc[data.index.intersection(test.index)]\n    \n    return pipeline,train,test","f04f70a5":"\nmap_controls = CatIntMapper('cp_type',{'ctl_vehicle': 0, 'trt_cp': 1})    \n\nmap_dose = CatIntMapper('cp_dose',{'D1': 1, 'D2': 0})    \nmap_time = CatIntMapper('cp_time',{24: 0, 48: 1, 72: 2})    \n","7cac98d3":"from torch.nn.modules.loss import _WeightedLoss\nimport torch.nn.functional as F\n\nclass SmoothBCEwLogits(_WeightedLoss):\n    def __init__(self, weight=None, reduction='mean', smoothing=0.0):\n        super().__init__(weight=weight, reduction=reduction)\n        self.smoothing = smoothing\n        self.weight = weight\n        self.reduction = reduction\n\n    @staticmethod\n    def _smooth(targets:torch.Tensor, n_labels:int, smoothing=0.0):\n        assert 0 <= smoothing < 1\n        with torch.no_grad():\n            targets = targets * (1.0 - smoothing) + 0.5 * smoothing\n        return targets\n\n    def forward(self, inputs, targets):\n        targets = SmoothBCEwLogits._smooth(targets, inputs.size(-1),\n            self.smoothing)\n        loss = F.binary_cross_entropy_with_logits(inputs, targets,self.weight)\n\n        if  self.reduction == 'sum':\n            loss = loss.sum()\n        elif  self.reduction == 'mean':\n            loss = loss.mean()\n\n        return loss","3839c471":"def multifold_indexer(train,target_columns,n_splits=10,random_state=12347,**kwargs):\n    folds = train.copy()\n\n    mskf = MultilabelStratifiedKFold(n_splits=n_splits,random_state=random_state,**kwargs)\n    folds[ 'kfold']=0\n    for f, (t_idx, v_idx) in enumerate(mskf.split(X=train, y=train[target_columns])):\n        folds.iloc[v_idx,-1] = int(f)\n\n    folds['kfold'] = folds['kfold'].astype(int)\n    return folds\n","59572f7f":"class Model(nn.Module):\n    def __init__(self, num_features, num_targets, hidden_size1=388,hidden_size2=512,drop_rate1=0.0,drop_rate2=0.3,drop_rate3=0.3):\n        super(Model, self).__init__()\n        self.batch_norm1 = nn.BatchNorm1d(num_features)\n        self.dropout1 = nn.Dropout(drop_rate1)\n        self.dense1 = nn.utils.weight_norm(nn.Linear(num_features, hidden_size1))\n\n        self.batch_norm2 = nn.BatchNorm1d(hidden_size1)\n        self.dropout2 = nn.Dropout(drop_rate2)\n        self.dense2 = nn.utils.weight_norm(nn.Linear(hidden_size1, hidden_size2))\n\n        self.batch_norm3 = nn.BatchNorm1d(hidden_size2)\n        self.dropout3 = nn.Dropout(drop_rate3)\n        self.dense3 = nn.utils.weight_norm(nn.Linear(hidden_size2, num_targets))\n\n\n    def forward(self, x):\n        \n        x = self.batch_norm1(x)\n        x = self.dropout1(x)\n        x = F.relu(self.dense1(x))\n        \n        x = self.batch_norm2(x)\n        x = self.dropout2(x)\n        x = F.relu(self.dense2(x))\n        \n        x = self.batch_norm3(x)\n        x = self.dropout3(x)\n        x = self.dense3(x)\n        \n        return x","7d17ab59":"def train_fn(model, optimizer, scheduler, loss_fn, dataloader, device):\n    model.train()\n    final_loss = 0\n    \n    for data in dataloader:\n        optimizer.zero_grad()\n        inputs, targets = data['x'].to(device), data['y'].to(device)\n#         print(inputs.shape)\n        outputs = model(inputs)\n        loss = loss_fn(outputs, targets)\n        loss.backward()\n        optimizer.step()\n        \n        if not  scheduler.__class__ ==  torch.optim.lr_scheduler.ReduceLROnPlateau:\n            scheduler.step()\n        \n        final_loss += loss.item()\n        \n    final_loss \/= len(dataloader)\n    \n    return final_loss\n\n\ndef valid_fn(model, scheduler, loss_fn, dataloader, device):\n    model.eval()\n    final_loss = 0\n    valid_preds = []\n    \n    for data in dataloader:\n        inputs, targets = data['x'].to(device), data['y'].to(device)\n        outputs = model(inputs)\n        loss = loss_fn(outputs, targets)\n        \n        final_loss += loss.item()\n        valid_preds.append(outputs.sigmoid().detach().cpu().numpy())\n        \n    final_loss \/= len(dataloader)\n    valid_preds = np.concatenate(valid_preds)\n    \n    if scheduler.__class__ ==  torch.optim.lr_scheduler.ReduceLROnPlateau:\n        scheduler.step(final_loss)\n    \n    return final_loss, valid_preds\n\ndef inference_fn(model, dataloader, device):\n    model.eval()\n    preds = []\n    \n    for data in dataloader:\n        inputs = data['x'].to(device)\n\n        with torch.no_grad():\n            outputs = model(inputs)\n        \n        preds.append(outputs.sigmoid().detach().cpu().numpy())\n        \n    preds = np.concatenate(preds)\n    \n    return preds\n   \n    ","236ab82b":"exp_name = 'DAE'","b5e8e2d0":"def run_training(X_train,y_train,X_valid,y_valid,X_test,fold, seed,verbose=False,ct=None,**kwargs):\n    \n    seed_everything(seed)\n    \n   \n    \n    train_dataset = MoADataset(X_train, y_train)\n    valid_dataset = MoADataset(X_valid, y_valid)\n    trainloader = torch.utils.data.DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)\n    validloader = torch.utils.data.DataLoader(valid_dataset, batch_size=BATCH_SIZE, shuffle=False)\n    \n    model = Model(\n        num_features= X_train.shape[1] ,\n        num_targets=  y_train.shape[1],hidden_size1=hidden_size1,hidden_size2=hidden_size2,\n       **kwargs\n    )\n    \n    model.to(DEVICE)\n    \n    #initialize_from_past_model(model, f\"..\/results\/original_torch_moa_smoothed_lrplateau_5_folds_AUX_SEED{seed}_FOLD{fold}.pth\")#,freeze_first_layer=True)\n    \n    \n    optimizer = torch.optim.Adam(model.parameters(), lr=LEARNING_RATE, weight_decay=WEIGHT_DECAY)\n    #scheduler = optim.lr_scheduler.OneCycleLR(optimizer, pct_start=0.1, div_factor=1e3, \n     #                                         max_lr=1e-2, epochs=EPOCHS, steps_per_epoch=len(trainloader))\n    \n    scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer,patience=3)\n    \n    loss_val = nn.BCEWithLogitsLoss()\n    #loss_tr =  nn.BCEWithLogitsLoss()\n    loss_tr = SmoothBCEwLogits(smoothing =0.001)\n    \n    early_stopping_steps = EARLY_STOPPING_STEPS\n    early_step = 0\n    \n    #todo el guardado de los resultados se puede mover a kfold que si tiene info de los indices\n    #oof = np.zeros((len(train), target.iloc[:, 1:].shape[1]))\n    best_loss = np.inf\n    \n    \n    \n    \n    for epoch in range(EPOCHS):\n        \n        train_loss = train_fn(model, optimizer,scheduler, loss_tr, trainloader, DEVICE)\n        if verbose & (epoch%DISPLAY==0):\n            print(f\"FOLD: {fold}, EPOCH: {epoch}, train_loss: {train_loss}\")\n        valid_loss, valid_preds = valid_fn(model,scheduler, loss_val, validloader, DEVICE)\n        if verbose & (epoch%DISPLAY==0):\n            print(f\"FOLD: {fold}, EPOCH: {epoch}, valid_loss: {valid_loss}\")\n        \n        if valid_loss < best_loss:\n            \n            best_loss = valid_loss\n            oof = valid_preds\n        \n            #torch.save(model.state_dict(), f\"{exp_name}_SEED{seed}_FOLD{fold}.pth\")\n        \n        elif(EARLY_STOP == True):\n            \n            early_step += 1\n            if (early_step >= early_stopping_steps):\n                break\n            \n    \n    #--------------------- PREDICTION---------------------\n   \n    testdataset = TestDataset(X_test)\n    testloader = torch.utils.data.DataLoader(testdataset, batch_size=BATCH_SIZE, shuffle=False)\n    \n    ###############################\n    #### SAVE\/LOAD MODEL ###############\n    torch.save(model.state_dict(), f\"{exp_name}_SEED{seed}_FOLD{fold}_CT{ct}.pth\")\n    \n    model = Model(\n        num_features= X_train.shape[1] ,\n        num_targets=  y_train.shape[1],\n        hidden_size1=hidden_size1,\n        hidden_size2=hidden_size2,\n       **kwargs\n    )\n    \n    model.load_state_dict(torch.load(f\"{exp_name}_SEED{seed}_FOLD{fold}_CT{ct}.pth\"))\n    model.to(DEVICE)\n    \n    print('SAVE\/LOAD MODEL_FOLD%i_CT%i'%(fold,ct))\n    ###############################\n    \n    #predictions = np.zeros((len(test_), target.iloc[:, 1:].shape[1]))\n    \n    predictions = inference_fn(model, testloader, DEVICE)\n    \n    return oof, predictions\n","41054ea7":"#params for one cycle schedule\nDEVICE =  torch.device('cuda:0')\nEPOCHS = 36\nDISPLAY = 5\nBATCH_SIZE = 1024\nLEARNING_RATE = 1.8e-2\nWEIGHT_DECAY = 1e-5\nNFOLDS = 7              #<-- Update\nEARLY_STOPPING_STEPS = 10\nEARLY_STOP = False\n\n#num_features=len(feature_cols)\n#num_targets=len(target_cols)\n\nhidden_size1=2048\n\nhidden_size2=2048","5cc9a346":"#params ={}","392c549d":"def run_k_fold(folds,target_cols,test,transformers_list,NFOLDS, seed,verbose=False,ct=None, **kwargs):\n    \n    \n    train = folds\n    test_ = test\n    \n    #oof = np.zeros((len(folds), len(target_cols)))\n    oof = train[target_cols].copy()\n    oof = oof*0\n    predictions = pd.DataFrame(0,columns=target_cols,index=test.index)\n    \n    #print(test_.head())\n    for fold in range(NFOLDS):\n        \n        #trn_idx = train[train['kfold'] != fold].reset_index().index\n        #val_idx = train[train['kfold'] == fold].reset_index().index\n    \n        train_df = train[train['kfold'] != fold]#.reset_index(drop=True)\n        valid_df = train[train['kfold'] == fold]#.reset_index(drop=True)\n        \n       # print(len(train_df))\n        #print(len(valid_df))\n        \n        feature_cols = [col  for col in train_df.columns if not (col in target_cols+['kfold'])]\n        \n        #print(feature_cols)\n        \n        pipeline_val = make_pipeline(*transformers_list)\n        \n        X_train, y_train  = train_df[feature_cols], train_df[target_cols]\n        X_valid, y_valid =  valid_df[feature_cols], valid_df[target_cols].values\n        \n      \n            \n        # IDENTITY TRANSFORMATION DONT NEED TO SAVE\n        #######################\n        X_train = pipeline_val.fit_transform(X_train,y_train)\n        \n        feature_cols = [col  for col in X_train.columns if not (col in target_cols+['kfold'])]\n        \n        X_train = X_train.values\n        \n        \n        X_valid = pipeline_val.transform(X_valid)\n        valid_index = X_valid.index\n        X_valid = X_valid.values\n        \n        y_train = y_train.values\n        \n        X_test = pipeline_val.transform(test_)\n        test_index = X_test.index\n        X_test = X_test[feature_cols].values\n            \n        oof_, pred_ = run_training(X_train,y_train,X_valid,y_valid,X_test,fold, seed,verbose,ct=ct,**kwargs)\n        \n#         print(X_valid.shape)\n#         print(oof_.shape)\n#         print( oof.loc[valid_index].head())\n        \n        oof.loc[valid_index] = oof_\n        \n        \n        \n        predictions.loc[test_index] += pred_ \/ NFOLDS\n        \n        \n    return oof, predictions","6a084409":"params={}","28b64a2b":"# Averaging on multiple SEEDS\n#SEED = [0,12347,565657]\n#SEED = [0,12347,565657,123123,78591]\n\nk = 0\nCT = 7 # change this in feature extraction too\nSEED = [0]\n\nDae0_2 = DaeAdder(filename='features_0.2_altogether_fold%i.fth'%k)\ntransformers_list=[map_dose,map_time,Dae0_2,SuppressControls()]\ntrain,target_cols = train_short_form_loader('..\/input\/lish-moa\/train_features.csv','..\/input\/lish-moa\/train_targets_scored.csv')\ntest = test_short_form_loader(\"..\/input\/lish-moa\/test_features.csv\")\npipeline_test = make_pipeline(*transformers_list)\npipeline_test,train , test = apply_pipe_together(pipeline_test,train,test,ct=k)\n\noof = np.zeros((len(train), len(target_cols)))\npredictions = np.zeros((len(test), len(target_cols)))\n\nfor k in range(CT):\n    \n    if k!=0:\n        Dae0_2 = DaeAdder(filename='features_0.2_altogether_fold%i.fth'%k)\n        transformers_list=[map_dose,map_time,Dae0_2,SuppressControls()]\n        train,target_cols = train_short_form_loader('..\/input\/lish-moa\/train_features.csv','..\/input\/lish-moa\/train_targets_scored.csv')\n        test = test_short_form_loader(\"..\/input\/lish-moa\/test_features.csv\")\n        pipeline_test = make_pipeline(*transformers_list)\n        pipeline_test,train , test = apply_pipe_together(pipeline_test,train,test,ct=k)\n\n    transformers_list=[IdentityTransformer()]\n\n    for seed in SEED:\n   \n        folds = multifold_indexer(train,target_cols,n_splits=NFOLDS)\n        oof_, predictions_ = run_k_fold(folds,target_cols,test,transformers_list,NFOLDS, seed,verbose=True,ct=k,**params)\n        oof += oof_ \/ len(SEED) \/ CT\n        predictions += predictions_ \/ len(SEED) \/ CT\n        \n    print()\n\n        \n#train[target_cols] = oof\ntest[target_cols] = predictions","cd957328":"#valid_results = train.drop(columns=target_cols).merge(train[['sig_id']+target_cols], on='sig_id', how='left').fillna(0)\n#valid_results\n\ny_true = train[target_cols].values\ny_pred = oof\n\nscore = 0\nfor i in range(len(target_cols)):\n   # print(log_loss(y_true[:, i], y_pred[:, i])\/ len(target_cols))\n    score_ = log_loss(y_true[:, i], y_pred.iloc[:, i],labels=[0,1])\n    #score_ = log_loss(y_true[:, i], y_pred[:, i],labels=[0,1])\n    #if score_ > 0.02:\n     #   print(score_)\n    score +=( score_ \/ len(target_cols))\n    \nprint(\"CV log_loss: \", score)\n    ","f3734f45":"train,target_cols = train_short_form_loader('..\/input\/lish-moa\/train_features.csv','..\/input\/lish-moa\/train_targets_scored.csv')\ny_true = train[target_cols].values\n\ny_pred = train[target_cols].copy()\ny_pred[target_cols] = 0\ny_pred.loc[oof.index] = oof\ny_pred.loc[train.cp_type=='ctl_vehicle'] = 0\n\nscore = 0\nfor i in range(len(target_cols)):\n   # print(log_loss(y_true[:, i], y_pred[:, i])\/ len(target_cols))\n    score_ = log_loss(y_true[:, i], y_pred.iloc[:, i],labels=[0,1])\n    #if score_ > 0.02:\n     #   print(score_)\n    score +=( score_ \/ len(target_cols))\n    \nprint(\"CV log_loss: \", score)\n    ","544c4e5e":"sample_submission = pd.read_csv('..\/input\/lish-moa\/sample_submission.csv')\ntest_features = pd.read_csv('..\/input\/lish-moa\/test_features.csv')\nsample_submission.set_index('sig_id',inplace=True)\ntest_features.set_index('sig_id',inplace=True)\ntest_features = test_features.loc[sample_submission.index]\n\nsub = sample_submission.drop(columns=target_cols).merge(test[target_cols], on='sig_id', how='left').fillna(0)\n#sub.set_index('sig_id',inplace=True)\nsub.loc[test_features['cp_type']=='ctl_vehicle', target_cols] =0\nsub.to_csv('.\/submission.csv', index=True)","b64bceb8":"import matplotlib.pyplot as plt\n\nx = sub.loc[test_features['cp_type']!='ctl_vehicle', target_cols].values\nprint('MIN pred',np.min(x),'MAX pred',np.max(x))\nplt.figure(figsize=(20,4))\nplt.subplot(1,2,1)\nplt.hist( x[x<0.01], bins=100)\nplt.subplot(1,2,2)\nplt.hist( x[x>0.9], bins=100)\nplt.show()","b9036304":"## training and final prediction","85d2c30e":"# DAE Model","3ef7d375":"# feature Selection transformers","e27aa2b8":"# CV folds","80e8215b":"# Dataset Classes","c32f01c6":"## defining transformations","55350bfc":"# PREDICTION MODEL"}}