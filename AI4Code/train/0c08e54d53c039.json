{"cell_type":{"f47dd9f5":"code","08192047":"code","760733cf":"code","7dac6343":"code","05950510":"code","d0867e44":"code","f8e89da7":"code","c6e28745":"code","f6d3eb7b":"code","f7639e04":"code","d37d3270":"code","adf799db":"code","a37e137f":"code","bd5bd4dd":"code","aa885c63":"code","936710f8":"code","d8b7cc60":"code","5e51c100":"code","784e77c9":"markdown","025e569a":"markdown","13d168d8":"markdown","065600cc":"markdown","f1275388":"markdown","81d3cfdc":"markdown","9eb64003":"markdown","b06de298":"markdown","40dbaba6":"markdown","3ff4c8c0":"markdown","fa6720c7":"markdown","34e7229b":"markdown"},"source":{"f47dd9f5":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","08192047":"import pandas as pd\nimport numpy as np\nimport warnings\nwarnings.filterwarnings(action=\"ignore\")\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nfrom sklearn.preprocessing import StandardScaler \nfrom sklearn.model_selection import train_test_split \nfrom sklearn.metrics import classification_report\n#tensorflow libraries\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import MaxPooling2D, Dense, Dropout,Flatten, Conv2D\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.losses import SparseCategoricalCrossentropy\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.callbacks import TensorBoard,EarlyStopping ","760733cf":"# Creating dataframe by iterating through filepaths\ntumor_dir=r'..\/input\/brian-tumor-dataset\/Brain Tumor Data Set\/Brain Tumor Data Set\/Brain Tumor'\nhealthy_dir=r'..\/input\/brian-tumor-dataset\/Brain Tumor Data Set\/Brain Tumor Data Set\/Healthy'\nfilepaths = []\nlabels= []\ndict_list = [tumor_dir, healthy_dir]\nfor i, j in enumerate(dict_list):\n    flist=os.listdir(j)\n    for f in flist:\n        fpath=os.path.join(j,f)\n        filepaths.append(fpath)\n        if i==0:\n          labels.append('cancer')\n        else:\n          labels.append('healthy') \n    \nFseries = pd.Series(filepaths, name=\"filepaths\")\nLseries = pd.Series(labels, name=\"labels\")\ntumor_data = pd.concat([Fseries,Lseries], axis=1)\ntumor_df = pd.DataFrame(tumor_data)\nprint(tumor_df.head())\nprint(tumor_df[\"labels\"].value_counts())","7dac6343":"#shape of datatset\ntumor_df.shape","05950510":"#splitting data\ntrain_images, test_images = train_test_split(tumor_df, test_size=0.3, random_state=42)\ntrain_set, val_set = train_test_split(tumor_df, test_size=0.2, random_state=42)","d0867e44":"#shape of splitted data\nprint(train_set.shape)\nprint(test_images.shape)\nprint(val_set.shape)\nprint(train_images.shape)","f8e89da7":"#Generate batches of tensor image data with real-time data augmentation.\nimage_gen = ImageDataGenerator(preprocessing_function= tf.keras.applications.mobilenet_v2.preprocess_input)\ntrain = image_gen.flow_from_dataframe(dataframe= train_set,x_col=\"filepaths\",y_col=\"labels\",\n                                      target_size=(244,244),\n                                      color_mode='rgb',\n                                      class_mode=\"categorical\", #used for Sequential Model\n                                      batch_size=32,\n                                      shuffle=False            #do not shuffle data\n                                     )\ntest = image_gen.flow_from_dataframe(dataframe= test_images,x_col=\"filepaths\", y_col=\"labels\",\n                                     target_size=(244,244),\n                                     color_mode='rgb',\n                                     class_mode=\"categorical\",\n                                     batch_size=32,\n                                     shuffle= False\n                                    )\nval = image_gen.flow_from_dataframe(dataframe= val_set,x_col=\"filepaths\", y_col=\"labels\",\n                                    target_size=(244,244),\n                                    color_mode= 'rgb',\n                                    class_mode=\"categorical\",\n                                    batch_size=32,\n                                    shuffle=False\n                                   )","c6e28745":"classes=list(train.class_indices.keys())\nprint (classes)","f6d3eb7b":"def show_brain_images(image_gen):\n    test_dict = test.class_indices\n    classes = list(test_dict.keys())\n    images, labels=next(image_gen) # get a sample batch from the generator \n    plt.figure(figsize=(20,20))\n    length = len(labels)\n    if length<25:\n        r=length\n    else:\n        r=25\n    for i in range(r):\n        plt.subplot(5,5,i+1)\n        image=(images[i]+1)\/2 #scale images between 0 and 1\n        plt.imshow(image)\n        index=np.argmax(labels[i])\n        class_name=classes[index]\n        plt.title(class_name, color=\"green\",fontsize=16)\n        plt.axis('off')\n    plt.show()","f7639e04":"show_brain_images(train)","d37d3270":"#Defining Sequential Model\nmodel = Sequential()\n# defining conv-pool layer\nmodel.add(Conv2D(filters=32,kernel_size=(3,3),strides=(1,1), activation=\"relu\", padding=\"valid\",\n               input_shape=(244,244,3)))\nmodel.add(MaxPooling2D(pool_size=(2,2)))\n\n#adding flatten layer\nmodel.add(Flatten())\n\n#adding dense layers with dropout\nmodel.add(Dense(128, activation='relu'))\nmodel.add(Dropout(rate=0.3))\nmodel.add(Dense(64, activation=\"relu\"))\n\n#Output layer\nmodel.add(Dense(2, activation=\"sigmoid\")) #Sigmoid is used for binary. Use Softmax for Mutliclass.\n\nmodel.compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])\n#Summary\nmodel.summary()","adf799db":"#fitting model\nHistory = model.fit(train, validation_data= val, epochs=10,verbose=1)","a37e137f":"acc = History.history[\"accuracy\"] # report of model\nval_acc = History.history[\"val_accuracy\"] # history of validation data\n\nloss = History.history[\"loss\"]        # Training loss\nval_loss = History.history[\"val_loss\"] # validation loss\n\nplt.figure(figsize=(8,8))\nplt.subplot(2,1,1) # 2 rows and 1 columns\n#plotting respective accuracy\nplt.plot(acc,label=\"Training Accuracy\")\nplt.plot(val_acc, label=\"Validation Acccuracy\")\n\nplt.legend()\nplt.ylabel(\"Accuracy\", fontsize=12)\nplt.title(\"Training and Validation Accuracy\", fontsize=12)","bd5bd4dd":"plt.figure(figsize=(8,8))\nplt.subplot(2,1,1)\n \nplt.plot(loss, label=\"Training Loss\")      #Training loss\nplt.plot(val_loss, label=\"Validation Loss\") # Validation Loss\n\nplt.legend()\nplt.ylim([min(plt.ylim()),1])\nplt.ylabel(\"Loss\", fontsize=12)\nplt.title(\"Training and Validation Losses\", fontsize=12)","aa885c63":"model.evaluate(test, verbose=1)","936710f8":"pred = model.predict(test)\npred = np.argmax(pred, axis=1) #pick class with highest  probability\n\nlabels = (train.class_indices)\nlabels = dict((v,k) for k,v in labels.items())\npred2 = [labels[k] for k in pred]","d8b7cc60":"y_test = test_images.labels # set y_test to the expected output\nprint(classification_report(y_test, pred2))\nprint(\"Accuracy of the Model:\",accuracy_score(y_test, pred2)*100,\"%\")","5e51c100":"# Confusion Matrix\nfrom sklearn.metrics import confusion_matrix, accuracy_score\nplt.figure(figsize = (10,5))\ncm = confusion_matrix(y_test, pred2)\nsns.heatmap(cm, annot=True, fmt = 'g')","784e77c9":"Please UPVOTE if you find this notebook insightful!\n\nThanks in advance!","025e569a":"# Splitting Tumor Data using train_test_split","13d168d8":"![conv2d.png](attachment:b53f991e-bd49-46b4-a677-ee2dfd48ca65.png)","065600cc":"# Importing Modules","f1275388":"# Visualizing Accuracy and Loss","81d3cfdc":"![tensor.png](attachment:d10b5813-7c48-4550-9fcc-8ee42330204c.png)","9eb64003":"# Visualizing Images of Brain","b06de298":"# Dataframe","40dbaba6":"# ImageDataGenerator","3ff4c8c0":"# **Brain Tumor Classification**","fa6720c7":"Author: Purvit Vashishtha","34e7229b":"# Model Training"}}