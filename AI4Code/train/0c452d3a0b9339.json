{"cell_type":{"7cb9b69d":"code","24aa6be5":"code","28abed8d":"code","2d7e3699":"code","f2f8105a":"code","66486ff8":"code","9f77c8e9":"code","8398bd97":"code","d40df9ad":"code","88ff7f2d":"code","04a1b6fb":"code","816ecdff":"code","81680b3f":"code","c43a8f4e":"code","3ec0f5b3":"code","ccf3c295":"code","d60c38d8":"code","0cc79f5a":"code","29d8bbfa":"markdown","3e917af1":"markdown","c437b6f9":"markdown","960541d2":"markdown","5edd028f":"markdown","5b2bf9c0":"markdown","47a296ef":"markdown","47a1ecee":"markdown","57fb49a5":"markdown"},"source":{"7cb9b69d":"import os\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport plotly.express as px\nimport plotly.graph_objects as go\n\n\nfrom pprint import pprint\nfrom collections import defaultdict\nfrom plotly.subplots import make_subplots","24aa6be5":"train_df=pd.read_json('..\/input\/stanford-covid-vaccine\/train.json', lines=True)\ntrain_df=train_df[['id','seq_scored', 'seq_length', 'sequence', 'structure', 'predicted_loop_type','reactivity', 'deg_pH10', 'deg_Mg_pH10', 'deg_50C', 'deg_Mg_50C']].copy()\ntrain_df.head()","28abed8d":"base_2_idx={\n    'A': 0,\n    'U': 1,\n    'G': 2,\n    'C': 3\n}\n\nstructure_2_idx={\n    '(': 0,\n    '.': 1,\n    ')': 2\n}\n\nloop_idx= {\n    'S': 0, \n    'M': 1, \n    'I': 2, \n    'B': 3, \n    'H': 4, \n    'E': 5, \n    'X':6\n}","2d7e3699":"def getIndexes(row):\n    sequence=row.sequence\n    structure=row.structure\n    predicted_loop_type=row.predicted_loop_type\n    score_len=row.seq_scored\n    \n    nu_map=defaultdict(list)\n    looptype_map=defaultdict(list)\n    \n    bp_list=[]\n    non_bp_list=[]\n    au_bp_list=[]\n    gc_bp_list=[]\n    \n    \n    for i in range(score_len):\n        nucleotide=sequence[i]\n        loop_type=predicted_loop_type[i]\n        bp_structure=structure[i]\n        \n        nu_map[nucleotide].append(i)\n        looptype_map[loop_type].append(i)\n        \n        if bp_structure == '.':\n            non_bp_list.append(i)\n        if bp_structure == ')' or bp_structure == '(':\n            bp_list.append(i)\n        if (bp_structure == ')' or bp_structure == '(') and (nucleotide == 'A' or nucleotide=='U'):\n            au_bp_list.append(i)\n        if (bp_structure == ')' or bp_structure == '(') and (nucleotide == 'G' or nucleotide=='C'):\n            gc_bp_list.append(i)\n    return {\n        'nucleotide': nu_map,\n        'loop_type': looptype_map,\n        'bp_list': bp_list,\n        'au_bp_list':au_bp_list,\n        'gc_bp_list':gc_bp_list,\n        'non_bp_list':non_bp_list\n    }\n\n\ndef filter_by_indices(indices, filter_type, key):\n    if filter_type == 'nucleotide':\n        index=indices['nucleotide'][key]\n    elif filter_type == 'loop_type':\n        index=indices['loop_type'][key]\n    else:\n        index=indices[key]\n    return index\n\ndef getDataSetByIndices(row, index_name):\n    index=row[index_name]\n    reactivity=[ val for i,val in enumerate(row.reactivity) if i in index]\n    deg_Mg_pH10=[ val for i,val in enumerate(row.deg_Mg_pH10) if i in index]\n    deg_Mg_50C=[ val for i,val in enumerate(row.deg_Mg_50C) if i in index]\n    \n    return pd.Series({\n        'id': row.id,\n        'reactivity': reactivity,\n        'deg_Mg_pH10': deg_Mg_pH10,\n        'deg_Mg_50C': deg_Mg_50C\n    })","f2f8105a":"train_df['indices']=train_df.apply(getIndexes, axis=1)\n\nfor nucleotide in base_2_idx.keys():\n    train_df[nucleotide+'_len']=train_df.indices.apply(lambda indices: len(indices['nucleotide'][nucleotide]))    \n    train_df[nucleotide+\"_index\"]=train_df['indices'].apply(filter_by_indices,args=('nucleotide', nucleotide))\n    \nfor loop_type in loop_idx.keys():\n    train_df[loop_type+'_len']=train_df.indices.apply(lambda indices: len(indices['loop_type'][loop_type]))    \n    train_df[loop_type+\"_index\"]=train_df['indices'].apply(filter_by_indices,args=('loop_type', loop_type))\n\n\ntrain_df['bp_list_len']=train_df.indices.apply(lambda indices: len(indices['bp_list']))\ntrain_df['bp_list_index']=train_df['indices'].apply(filter_by_indices,args=('bp_list', 'bp_list'))\n\ntrain_df['au_bp_list_len']=train_df.indices.apply(lambda indices: len(indices['au_bp_list']))\ntrain_df['au_bp_list_index']=train_df.indices.apply(filter_by_indices,args=('au_bp_list', 'au_bp_list'))\n\ntrain_df['gc_bp_list_len']=train_df.indices.apply(lambda indices: len(indices['gc_bp_list']))\ntrain_df['gc_bp_list_index']=train_df.indices.apply(filter_by_indices,args=('gc_bp_list', 'gc_bp_list'))\n\n\ntrain_df['non_bp_list_len']=train_df.indices.apply(lambda indices: len(indices['non_bp_list']))\ntrain_df['non_bp_list_index']=train_df.indices.apply(filter_by_indices,args=('non_bp_list', 'non_bp_list'))","66486ff8":"loop_type_df={}\nnucleotide_df={}\n\noutput_df=train_df[['reactivity', 'deg_Mg_pH10', 'deg_Mg_50C']].copy()\n\nbp_df=train_df.apply(getDataSetByIndices, axis=1, args=('bp_list_index', )).copy()\nau_bp_df=train_df.apply(getDataSetByIndices, axis=1, args=('au_bp_list_index', )).copy()\ngc_bp_df=train_df.apply(getDataSetByIndices, axis=1, args=('gc_bp_list_index', )).copy()\nnon_bp_df=train_df.apply(getDataSetByIndices, axis=1, args=('non_bp_list_index', )).copy()\n\n\nfor nucleotide in base_2_idx.keys():\n    nucleotide_df[nucleotide]=train_df.apply(getDataSetByIndices, axis=1, args=(nucleotide+'_index', )).copy()\n\nfor loop_type in loop_idx.keys():\n    loop_type_df[loop_type]=train_df.apply(getDataSetByIndices, axis=1, args=(loop_type+'_index', )).copy()\n\n","9f77c8e9":"loop_type_df.keys()","8398bd97":"def getColumnStats(df, colnames):\n    for colname in colnames:\n        df[colname+'_mean']=df[colname].apply(lambda seq: np.mean(seq) if len(seq)>0 else np.nan )\n        df[colname+'_median'] =df[colname].apply(lambda seq: np.median(seq) if len(seq)>0 else np.nan )\n        df[colname+'_std'] =df[colname].apply(lambda seq: np.std(seq) if len(seq)>0 else np.nan )\n        df[colname+'_min'] =df[colname].apply(lambda seq: np.min(seq) if len(seq)>0 else np.nan )\n        df[colname+'_max'] =df[colname].apply(lambda seq: np.max(seq) if len(seq)>0 else np.nan )","d40df9ad":"getColumnStats(output_df, ['reactivity', 'deg_Mg_pH10', 'deg_Mg_50C'])\n\ngetColumnStats(bp_df, ['reactivity', 'deg_Mg_pH10', 'deg_Mg_50C'])\ngetColumnStats(non_bp_df, ['reactivity', 'deg_Mg_pH10', 'deg_Mg_50C'])\n\ngetColumnStats(au_bp_df, ['reactivity', 'deg_Mg_pH10', 'deg_Mg_50C'])\ngetColumnStats(gc_bp_df, ['reactivity', 'deg_Mg_pH10', 'deg_Mg_50C'])\n\ngetColumnStats(non_bp_df, ['reactivity', 'deg_Mg_pH10', 'deg_Mg_50C'])","88ff7f2d":"def countPlots(df, colnames, title):\n    data={}\n    for colname in colnames:\n        data[colname]=df[colname].sum()\n    fig=go.Figure(go.Bar(x=list(data.keys()), y=list(data.values())))\n    fig.update_layout(title=title)\n    fig.show()","04a1b6fb":"nucleotide_colnames=['A_len','U_len','G_len','C_len']\nstructure_colnames=['bp_list_len','au_bp_list_len','gc_bp_list_len','non_bp_list_len']\nloopTypeC_colnames=['S_len','M_len', 'I_len','B_len','H_len','E_len','X_len']\n\n\ncountPlots(train_df, nucleotide_colnames, 'Nucleotide')\ncountPlots(train_df, structure_colnames, 'Structure')\ncountPlots(train_df, loopTypeC_colnames, 'LoopTypes')","816ecdff":"fig=make_subplots(rows=5, cols=3, shared_xaxes=True,\n                  row_titles=['All', 'bp', 'AU-BP', 'GC-BP', 'Non-BP'],\n                  column_titles=['Reactivity Mean', 'deg_Mg_pH10 Mean', 'deg_Mg_50C Mean'],\n                  horizontal_spacing=0.1,\n                  row_heights=[50, 50, 50, 50, 50]\n                 )\n\n\nfig.add_trace(go.Box(x=output_df.reactivity_mean),row=1,col=1)\nfig.add_trace(go.Box(x=output_df.deg_Mg_pH10_mean), row=1, col=2)\nfig.add_trace(go.Box(x=output_df.deg_Mg_50C_mean), row=1, col=3)\n\n\nfig.add_trace(go.Box(x=bp_df.reactivity_mean),  row=2, col=1)\nfig.add_trace(go.Box(x=bp_df.deg_Mg_pH10_mean), row=2, col=2)\nfig.add_trace(go.Box(x=bp_df.deg_Mg_50C_mean),  row=2, col=3)\n\n\nfig.add_trace(go.Box(x=au_bp_df.reactivity_mean),  row=3, col=1)\nfig.add_trace(go.Box(x=au_bp_df.deg_Mg_pH10_mean), row=3, col=2)\nfig.add_trace(go.Box(x=au_bp_df.deg_Mg_50C_mean),  row=3, col=3)\n\n\nfig.add_trace(go.Box(x=gc_bp_df.reactivity_mean),  row=4, col=1)\nfig.add_trace(go.Box(x=gc_bp_df.deg_Mg_pH10_mean), row=4, col=2)\nfig.add_trace(go.Box(x=gc_bp_df.deg_Mg_50C_mean),  row=4, col=3)\n\nfig.add_trace(go.Box(x=non_bp_df.reactivity_mean),  row=5, col=1)\nfig.add_trace(go.Box(x=non_bp_df.deg_Mg_pH10_mean), row=5, col=2)\nfig.add_trace(go.Box(x=non_bp_df.deg_Mg_50C_mean),  row=5, col=3)\n\nfig.show()","81680b3f":"fig=make_subplots(rows=5, cols=3, shared_xaxes=True,\n                  row_titles=['All', 'bp', 'AU-BP', 'GC-BP', 'Non-BP'],\n                  column_titles=['Reactivity Mean', 'deg_Mg_pH10 Mean', 'deg_Mg_50C Mean'],\n                  horizontal_spacing=0.1,\n                  row_heights=[50, 50, 50, 50, 50]\n                 )\n\n\nfig.add_trace(go.Histogram(x=output_df.reactivity_mean),row=1,col=1)\nfig.add_trace(go.Histogram(x=output_df.deg_Mg_pH10_mean), row=1, col=2)\nfig.add_trace(go.Histogram(x=output_df.deg_Mg_50C_mean), row=1, col=3)\n\n\nfig.add_trace(go.Histogram(x=bp_df.reactivity_mean),  row=2, col=1)\nfig.add_trace(go.Histogram(x=bp_df.deg_Mg_pH10_mean), row=2, col=2)\nfig.add_trace(go.Histogram(x=bp_df.deg_Mg_50C_mean),  row=2, col=3)\n\n\nfig.add_trace(go.Histogram(x=au_bp_df.reactivity_mean),  row=3, col=1)\nfig.add_trace(go.Histogram(x=au_bp_df.deg_Mg_pH10_mean), row=3, col=2)\nfig.add_trace(go.Histogram(x=au_bp_df.deg_Mg_50C_mean),  row=3, col=3)\n\n\nfig.add_trace(go.Histogram(x=gc_bp_df.reactivity_mean),  row=4, col=1)\nfig.add_trace(go.Histogram(x=gc_bp_df.deg_Mg_pH10_mean), row=4, col=2)\nfig.add_trace(go.Histogram(x=gc_bp_df.deg_Mg_50C_mean),  row=4, col=3)\n\nfig.add_trace(go.Histogram(x=non_bp_df.reactivity_mean),  row=5, col=1)\nfig.add_trace(go.Histogram(x=non_bp_df.deg_Mg_pH10_mean), row=5, col=2)\nfig.add_trace(go.Histogram(x=non_bp_df.deg_Mg_50C_mean),  row=5, col=3)\n\nfig.show()","c43a8f4e":"def getBasePairEncoding(structure):\n    encodings=[]\n    encid=0\n    baseid=1\n\n    for idx, ch in enumerate(structure):\n        if ch == '(':\n            encodings.append({\n                'start_idx': idx\n            })\n            baseid+=1\n        elif ch==')':\n            baseid-=1\n            encodings[encid]['end_idx']=idx\n            encid+=1\n    for encoding in encodings:\n        encoding['dist']=encoding['end_idx']-encoding['start_idx']-1\n    return encodings","3ec0f5b3":"train_df['bpEncoding'] = train_df.structure.apply(getBasePairEncoding)\ntrain_df.head()","ccf3c295":"bpenc_df=train_df[['bpEncoding', 'reactivity', 'deg_Mg_pH10', 'deg_Mg_50C']].copy()\nbpenc_df.head()","d60c38d8":"reactivity_diff=[]\nph10_diff=[]\nmg_50c_diff=[]\ndist=[]\n\ndef getResponseDiff(row):\n    bpEncoding=row.bpEncoding\n    reactivity=row.reactivity\n    deg_Mg_pH10=row.deg_Mg_pH10\n    deg_Mg_50C=row.deg_Mg_50C\n    \n    reactivity_len=len(reactivity)\n    for enc in bpEncoding:\n        start_idx=enc['start_idx']\n        end_idx=enc['end_idx']\n        d=enc['dist']\n        \n        if start_idx>=reactivity_len or end_idx>=reactivity_len:\n            break\n        reactivity_diff.append( abs(reactivity[start_idx]-reactivity[end_idx]) )\n        ph10_diff.append( abs(deg_Mg_pH10[start_idx] - deg_Mg_pH10[end_idx]) )\n        mg_50c_diff.append( abs(deg_Mg_50C[start_idx] - deg_Mg_50C[end_idx]) )\n        dist.append(d)\n_=bpenc_df.apply(getResponseDiff, axis=1)","0cc79f5a":"fig=make_subplots(rows=2, cols=3)\n\nfig.add_trace(go.Box(x=reactivity_diff),row=1,col=1)\nfig.add_trace(go.Box(x=ph10_diff),row=1,col=2)\nfig.add_trace(go.Box(x=mg_50c_diff),row=1,col=3)\n\n\n\nfig.add_trace(go.Histogram(x=reactivity_diff),row=2,col=1)\nfig.add_trace(go.Histogram(x=ph10_diff), row=2, col=2)\nfig.add_trace(go.Histogram(x=mg_50c_diff), row=2, col=3)\n","29d8bbfa":"**Nucleoitides**\n1. Count(A) > Count(G) > Count(U) > Count(C)\n2. Count(U) ~ Count(C)\n\n**Structures**\n1. BasePairs and NonBasePairs had the Similar Counts.\n2. Count(A-U) < Count(G-C)\n\n\n\n**LoopTypes: Highly Skewed**\n1. High Frequency --> Stem, HairPin, Dangling Ends,\n2. Low  Frequency --> Bulge , Multiloop","3e917af1":"# Visualize the Reactivity & Degradation Stats of the basePair & nonBasePairs","c437b6f9":"Get the Difference between the values of the Nucleotides that got Paired","960541d2":"1. From the above plots Observed Significant Difference between Reactivity, Degradataion Rates of BasePairs and nonBasePairs.\n2. Few Sequences have outliers in the Non Basepairs.\n3. We can See that BasePaired means are more narrow distributions than NonBasePaired Mean distributions.\n4. Do the Pairs in the Sequence will have the Similar reactivity & degradation ","5edd028f":"# DataSets","5b2bf9c0":"# BasePair,Structure & LoopType Distributions.","47a296ef":"# Token Dictionary","47a1ecee":"# Distributions","57fb49a5":"# Check the Reactivity, Degradations for the BasePairs."}}