{"cell_type":{"11b5e93a":"code","e00cd7b6":"code","ba1ac11e":"code","f087a71f":"code","86be1023":"code","25ee597d":"code","da481e24":"code","51756f29":"code","327a0cd9":"code","735a1957":"code","bc3aecd3":"code","47535c8b":"code","c8a10df9":"code","eaed2e0b":"code","7f33d693":"code","cc9a3bda":"code","854c3fcb":"code","0c96f418":"code","dd9b43a1":"code","5222bd8b":"code","f6446d05":"code","7f409f4c":"code","6b1bba86":"code","a59c91f5":"code","36a07e9a":"code","09aa702f":"code","791aacc5":"code","12d413cd":"code","3048311e":"code","dfa4c6ed":"code","95d9f089":"code","f7d1aacf":"code","91644505":"code","6e210691":"code","1362a92b":"code","f881ac05":"code","544d29ed":"code","b4456fa6":"code","95c73734":"code","55ecbf91":"code","64a3da17":"code","ba9a3114":"code","884ff69d":"code","721005ba":"code","41b491e5":"code","bc87488c":"markdown","4cd67c6f":"markdown","de1bb1d3":"markdown","38b5d0f3":"markdown","39bf1b62":"markdown","d7206fb2":"markdown","6f20e56a":"markdown","00335e5c":"markdown","2bb3a4bc":"markdown","cadd05bc":"markdown","c7c7b4ce":"markdown"},"source":{"11b5e93a":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns","e00cd7b6":"# data = https:\/\/drive.google.com\/open?id=1Qm1L8izAJ-8NAt2ZROmtAVSf1CNEPyGH\nid = \"1Qm1L8izAJ-8NAt2ZROmtAVSf1CNEPyGH\"","ba1ac11e":"from pydrive.auth import GoogleAuth\nfrom pydrive.drive import GoogleDrive\nfrom google.colab import auth\nfrom oauth2client.client import GoogleCredentials ","f087a71f":"auth.authenticate_user()\ngauth = GoogleAuth()\ngauth.credentials = GoogleCredentials.get_application_default()\ndrive = GoogleDrive(gauth)","86be1023":"download = drive.CreateFile({'id':id})\ndownload.GetContentFile('household_power_consumption.txt')\nprint(f\"data has been download to google colab\")","25ee597d":"df = pd.read_csv('household_power_consumption.txt', sep = ';', \n                 parse_dates={'datetime':['Date','Time']},\n                 na_values=['nan','?'],\n                 index_col = 'datetime'\n                 )","da481e24":"df.head(100)","51756f29":"df.shape","327a0cd9":"df.describe(include='all')","735a1957":"df.info()","bc3aecd3":"# remove null values\ndf.isnull().sum()","47535c8b":"# bearable outliers\ndf.Global_active_power.plot(kind='box') ","c8a10df9":"# df.fillna({\n#     'Global_active_power':np.mean()\n# })\nfrom sklearn.preprocessing import Imputer\nfrom sklearn.pipeline import Pipeline","eaed2e0b":"cat_pipe = Pipeline([\n       ('imputer', Imputer(strategy='median'))              \n])\ncleaned_data = cat_pipe.fit_transform(df)","7f33d693":"clean_df = pd.DataFrame(cleaned_data,columns=df.columns)\nclean_df.isnull().sum()","cc9a3bda":"clean_df.set_index(df.index, inplace = True)","854c3fcb":"# now explore the monthly wise gloabl active power\nmonthly_resampled_data_mean = clean_df.Global_active_power.resample('M').mean()\nmonthly_resampled_data_sum = clean_df.Global_active_power.resample('M').sum()\n\nmonthly_resampled_data_mean.plot(title = 'Global_active_power resampled over month for mean')\nplt.tight_layout()\nplt.show() \n\nmonthly_resampled_data_sum.plot(title = 'Global_active_power resampled over month for sum', color = 'red')\nplt.tight_layout()\nplt.show() \n","0c96f418":"r2 = clean_df.Global_reactive_power.resample('M').agg(['mean', 'std'])\nr2.plot(subplots = True, title='Global_reactive_power resampled over day', color='red')\nplt.show()","dd9b43a1":"r2 = clean_df.Voltage.resample('M').agg(['mean', 'std'])\nr2.plot(subplots = True, title='Voltage resampled over month', color='red')\nplt.show()","5222bd8b":"# sns.pairplot(clean_df, kind = 'reg')\nsns.pairplot(clean_df)\nplt.show()\n# KDE Plot described as Kernel Density Estimate is used for visualizing the Probability Density of a continuous variable. \n# It depicts the probability density at different values in a continuous variable. \n# We can also plot a single graph for multiple samples which helps in more efficient data visualization","f6446d05":"# global active power and gloabl density are directly proportional to each other\nclean_df.Global_reactive_power.resample('W').mean().plot(color='y', legend=True)\nclean_df.Global_active_power.resample('W').mean().plot(color='r', legend=True)\nclean_df.Sub_metering_1.resample('W').mean().plot(color='b', legend=True)\nclean_df.Global_intensity.resample('W').mean().plot(color='g', legend=True)\nplt.show()","7f409f4c":"clean_df.Global_reactive_power.resample('W').mean().plot(kind = 'hist', color='y', legend=True)\nclean_df.Global_active_power.resample('W').mean().plot(kind = 'hist', color='r', legend=True)\nclean_df.Sub_metering_1.resample('W').mean().plot(kind = 'hist', color='b', legend=True)\nclean_df.Global_intensity.resample('W').mean().plot(kind = 'hist',color='g', legend=True)\nplt.show()","6b1bba86":"# find the percentage change with the previous row \ndata_returns = clean_df.pct_change()\ndata_returns","a59c91f5":"sns.jointplot(x='Voltage', y='Global_active_power', data=data_returns)  \nplt.show()","36a07e9a":"\n\ndef series_to_supervised(data, n_in=1, n_out=1, dropnan=True):\n\tn_vars = 1 if type(data) is list else data.shape[1]\n\tdff = pd.DataFrame(data)\n\tcols, names = list(), list()\n\t# input sequence (t-n, ... t-1)\n\tfor i in range(n_in, 0, -1):\n\t\tcols.append(dff.shift(i))\n\t\tnames += [('var%d(t-%d)' % (j+1, i)) for j in range(n_vars)]\n\t# forecast sequence (t, t+1, ... t+n)\n\tfor i in range(0, n_out):\n\t\tcols.append(dff.shift(-i))\n\t\tif i == 0:\n\t\t\tnames += [('var%d(t)' % (j+1)) for j in range(n_vars)]\n\t\telse:\n\t\t\tnames += [('var%d(t+%d)' % (j+1, i)) for j in range(n_vars)]\n\t# put it all together\n\tagg = pd.concat(cols, axis=1)\n\tagg.columns = names\n\t# drop rows with NaN values\n\tif dropnan:\n\t\tagg.dropna(inplace=True)\n\treturn agg\n ","09aa702f":"resamble_data_hours = clean_df.resample('h').mean() ","791aacc5":"resamble_data_hours.shape","12d413cd":"# its time to normalize the data\nfrom sklearn.preprocessing import MinMaxScaler","3048311e":"scaler = MinMaxScaler(feature_range=(0,1))\nscaled = scaler.fit_transform(resamble_data_hours)","dfa4c6ed":"scaled # normalized data","95d9f089":"# frame as supervised learning\nreframed = series_to_supervised(scaled, 1, 1)","f7d1aacf":"reframed","91644505":"# we only need var1(t) (Global Active Power) Output variabel so,\n# we should delete other(var2(t)\tvar3(t)\tvar4(t)\tvar5(t)\tvar6(t)\tvar7(t)) output varibles\n\nreframed.drop(reframed.columns[[8,9,10,11,12,13]], inplace=True, axis=1)","6e210691":"reframed.head(10)","1362a92b":"# from sklearn.model_selection import train_test_split\n","f881ac05":"# split into train and test sets\nvalues = reframed.values\n\nn_train_time = 365*24\ntrain = values[:n_train_time, :]\ntest = values[n_train_time:, :]\n##test = values[n_train_time:n_test_time, :]\n# split into input and outputs\n\ntrain_X, train_y = train[:, :-1], train[:, -1]\ntest_X, test_y = test[:, :-1], test[:, -1]\n\n# reshape input to be 3D [samples, timesteps, features]\ntrain_X = train_X.reshape((train_X.shape[0], 1, train_X.shape[1]))\ntest_X = test_X.reshape((test_X.shape[0], 1, test_X.shape[1]))\nprint(train_X.shape, train_y.shape, test_X.shape, test_y.shape) \n# We reshaped the input into the 3D format as expected by LSTMs, namely [samples, timesteps, features].","544d29ed":"import tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense,Dropout,LSTM,Conv1D,MaxPool1D\nfrom tensorflow.keras.optimizers import SGD,Adam","b4456fa6":"X_train.shape[2]","95c73734":"model = Sequential()\nmodel.add(LSTM(100, input_shape = (X_train.shape[1],X_train.shape[2])))\n\nmodel.add(Dropout(0.2))\n# model.add(LSTM(80))\n# model.add(Dropout(0.3))\n\nmodel.add(Dense(1))\nmodel.compile(optimizer='adam',loss='mse')","55ecbf91":"# now fit the model\nhistory = None\nhistory = model.fit(x=X_train,y=Y_train,batch_size=70,epochs=50,verbose=2,validation_data=(X_test,Y_test),shuffle=False)","64a3da17":"plt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title(\"Loss of Training and Validation\")\nplt.xlabel(\"Epoches\")\nplt.ylabel(\"Loss\")\nplt.legend(['Train','Test'], loc = 'upper right')\nplt.show()","ba9a3114":"from sklearn.metrics import mean_squared_error","884ff69d":"# invert predictions\n# make a prediction\nyhat = model.predict(X_test)\n\ntest_X = X_test.reshape((X_test.shape[0], 7))\n\n# # invert scaling for forecast\n# test_X[:,-6:] mean only features\n\ninv_yhat = np.concatenate((yhat, test_X[:, -6:]), axis=1)\ninv_yhat = scaler.inverse_transform(inv_yhat)\ninv_yhat = inv_yhat[:,0] #out put variable\n\n# # invert scaling for actual\n\ntest_y = Y_test.values.reshape((len(Y_test), 1))\ninv_y = np.concatenate((test_y, test_X[:, -6:]), axis=1)\ninv_y = scaler.inverse_transform(inv_y)\ninv_y = inv_y[:,0]\n# calculate RMSE\n\nrmse = np.sqrt(mean_squared_error(inv_y, inv_yhat))\nprint('Test RMSE: %.3f' % rmse)","721005ba":"# without inverse, its is normlize\ny_predict = model.predict(X_test)\nmse = np.sqrt(mean_squared_error(Y_test,y_predict))\nprint(f\"The Mean Squarred error is: {mse}\")","41b491e5":"sample = list(range(200))\nplt.figure(figsize=(10,5))\nplt.plot(sample,inv_y[:200],marker = '.', label = 'Actual')\n\nplt.plot(sample,inv_yhat[:200],marker = '.', label = 'Prediction')\nplt.ylabel('Global_active_power', size=15)\nplt.xlabel('Time step', size=20)\nplt.legend(fontsize=15)\nplt.title(\"This is not Overfitting the data\")\nplt.show()","bc87488c":"# Machine-Leaning: LSTM Data Preparation and feature engineering\n### * I will apply recurrent nueral network (LSTM) which is best suited for time-seriers and sequential problem. This approach is the best if we have large data.  \n\n###\u00a0* ***Its time to convert Time Series data  into a Supervised Learning Problem***\n\nhttps:\/\/machinelearningmastery.com\/convert-time-series-supervised-learning-problem-python\/","4cd67c6f":"# Welcome Dear !!!\n### This Jupyter Notebook will run on Google Colab :)","de1bb1d3":"#### We reshaped the input into the 3D format as expected by LSTMs, namely [samples, timesteps, features].\n\n<ol> \n<li> Samples. One sequence is one sample. A batch is comprised of one or more samples. <\/li>\n\n<li>Time Steps. One time step is one point of observation in the sample.<\/li>\n\n<li>\nFeatures. One feature is one observation at a time step.<\/li>\n<\/ol>","38b5d0f3":"### * Here I have used the LSTM neural network which is now the state-of-the-art for sequencial problems. \n\n### * In order to reduce the computation time, and get some results quickly, I took the first year of data (resampled over hour) to train the model and the rest of data to test the model.  \n\n### * I put together a very simple LSTM neural-network to show that one can obtain reasonable predictions. However numbers of rows is too high and as a result the computation is very time-consuming (even for the simple model in the above it took few mins to be run on  2.8 GHz Intel Core i7).  The Best is to write the last part of code using Spark (MLlib) running on GPU.  \n\n### * Moreover, the neural-network architecture that I have designed is a toy model. It can be easily improved by adding CNN  and dropout layers.  The CNN is useful here since there are correlations in data (CNN layer is a good way to probe the local structure of data).  ","39bf1b62":"if you have any query related to RNN, Plz feel free to ask at khizersultan007@gmail.com","d7206fb2":"### Now Its time to split the data into training and validation\n### it is time series data so we cant split randomly\n\n### * First, I split the prepared dataset into train and test sets. To speed up the training of the model (for the sake of the demonstration), we will only train the model on the first year of data, then evaluate it on the next 3 years of data.","6f20e56a":"output variables var1(t)(Global Active Power)\tvar2(t)\tvar3(t)\tvar4(t)\tvar5(t)\tvar6(t)\tvar7(t)\nwe only need var1(t) (Global Active Power) Output variabel so, we should delete other(var2(t)\tvar3(t)\tvar4(t)\tvar5(t)\tvar6(t)\tvar7(t)) output varibles","00335e5c":"## This project will analyse the time series power consumption data (2 million rows) using deep learning \n### The aim is just to show how to build the simplest Long Short-Term Memory (LSTM) recurrent neural network for the data.\n\n#### lets do!","2bb3a4bc":"# Model architecture\n\n### 1)  LSTM with 100 neurons in the first visible layer \n### 3) dropout 20%\n### 4) 1 neuron in the output layer for predicting Global_active_power. \n### 5) The input shape will be 1 time step with 7 features.\n\n### 6) I use the Mean Absolute Error (MAE) loss function and the efficient Adam version of stochastic gradient descent.\n### 7) The model will be fit for 20 training epochs with a batch size of 70.\n","cadd05bc":"### * In order to reduce the computation time, and also get a quick result to test the model.  One can resmaple the data over hour (the original data are given in minutes). This will reduce the size of data from 2075259 to 34589 but keep the overall strucure of data as shown in the above.  ","c7c7b4ce":"The description of data can be found here:\nhttp:\/\/archive.ics.uci.edu\/ml\/datasets\/Individual+household+electric+power+consumption\n\nAttribute Information:\n1.date: Date in format dd\/mm\/yyyy\n\n2.time: time in format hh:mm:ss\n\n3.global_active_power (output label): household global minute-averaged active power (in kilowatt)\n\n4.global_reactive_power: household global minute-averaged reactive power (in kilowatt)\n\n5.voltage: minute-averaged voltage (in volt)\n\n6.global_intensity: household global minute-averaged current intensity (in ampere)\n\n7.sub_metering_1: energy sub-metering No. 1 (in watt-hour of active energy). It corresponds to the kitchen, containing mainly a dishwasher, an oven and a microwave (hot plates are not electric but gas powered).\n\n8.sub_metering_2: energy sub-metering No. 2 (in watt-hour of active energy). It corresponds to the laundry room, containing a washing-machine, a tumble-drier, a refrigerator and a light.\n\n9.sub_metering_3: energy sub-metering No. 3 (in watt-hour of active energy). It corresponds to an electric water-heater and an air-conditioner."}}