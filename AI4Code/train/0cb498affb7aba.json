{"cell_type":{"5eb23de5":"code","dedb8b5b":"code","16cd0d0b":"code","1b02e0b9":"code","e9def6f2":"code","b3cc8910":"code","978dd2fc":"code","9d33263a":"code","966b1f30":"code","69b57f2f":"code","bf31dfb3":"code","db19e33a":"code","b109d3ea":"code","e1651f1e":"code","31940337":"code","9cf5e467":"markdown"},"source":{"5eb23de5":"import numpy as np\nimport pandas as pd\n\nfrom sklearn.preprocessing import OrdinalEncoder\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn import svm\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import plot_confusion_matrix\n\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\n\nimport seaborn as sns\n\nimport matplotlib.pyplot as plt\n\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go","dedb8b5b":"mushrooms_data = pd.read_csv('..\/input\/mushroom-classification\/mushrooms.csv')\nmushrooms_data.head()","16cd0d0b":"mushrooms_data.info()","1b02e0b9":"objecttype_columns = mushrooms_data.columns\n#Encode categorical data\nmushrooms_data[objecttype_columns] = mushrooms_data[objecttype_columns].astype('category')","e9def6f2":"#Encoder train set\nencoder = OrdinalEncoder()\nencoder.fit(mushrooms_data[objecttype_columns])\nmushrooms_data[objecttype_columns] = encoder.transform(mushrooms_data[objecttype_columns])\n\nmushrooms_data.head(10)","b3cc8910":"mushrooms_data['class'].unique()","978dd2fc":"\nmushrooms_x = mushrooms_data.drop('class', axis=1)","9d33263a":"correlation_mat = mushrooms_data.corr()\n\nsns.heatmap(correlation_mat, annot = True)\nsns.set(rc={'figure.figsize':(10,10)})\nplt.title(\"Matriz de Correlaci\u00f3n\")\n\nplt.show()","966b1f30":"#Separa variable a predecir\ny = mushrooms_data[\"class\"].copy()\nx = mushrooms_data.drop(\"class\", axis=1)\n\nprint(x.shape, y.shape)","69b57f2f":"#Se va a utilizar el m\u00e9todo Train\/Test para dividir los datos\n#Train 80% y Test 20% del total de datos\n\nX_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.20, random_state=42)\n\nprint(\"Tama\u00f1o del set de Entrenamiento\", X_train.shape)\nprint(\"Tama\u00f1o del set de Pruebas\", X_test.shape)","bf31dfb3":"rfmodel = RandomForestClassifier(max_depth=5,min_samples_split=100,class_weight={0:1,1:5}).fit(X_train, y_train)\n\nrfmodel_score_train = rfmodel.score(X_train, y_train)\nrfmodel_score = rfmodel.score(X_test, y_test)\n#rfmodel_cv_score = cross_val_score(rfmodel, XX_test, y, cv=5).mean()\n\nprint(f'Decision Tree -> Train: {rfmodel_score_train}, Test: {rfmodel_score}')","db19e33a":"# Plot non-normalized confusion matrix\ndisp = plot_confusion_matrix(rfmodel, x, y)\nplt.show()","b109d3ea":"model = LogisticRegression(solver='liblinear', random_state=0, penalty='l1')\n\nmodel.fit(X_train, y_train)","e1651f1e":"model_score_train = model.score(X_train, y_train)\nmodel_score = model.score(X_test, y_test)\n#rfmodel_cv_score = cross_val_score(rfmodel, XX_test, y, cv=5).mean()\n\nprint(f'Decision Tree -> Train: {model_score_train}, Test: {model_score}')","31940337":"# Plot non-normalized confusion matrix\ndisp = plot_confusion_matrix(model, X_test, y_test)\nplt.show()","9cf5e467":"# Modelo"}}