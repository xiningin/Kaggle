{"cell_type":{"a12aba7b":"code","bce40efd":"code","449f416b":"code","7784e173":"code","7da8230f":"code","2c7f7c8c":"code","72a38859":"code","e81ddde1":"code","3d94738d":"code","89c2ed95":"code","ccb9b059":"code","9e1fa6c8":"code","a71f6b99":"code","98b16133":"code","96259cb7":"code","e11fbc0c":"markdown","2f13d4c5":"markdown","b84f0592":"markdown","0ded0047":"markdown","24dd9daf":"markdown","65eb7b4c":"markdown","ad1446c5":"markdown","5799f557":"markdown"},"source":{"a12aba7b":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport cv2\nimport glob\nfrom tqdm.auto import tqdm\nfrom sklearn.model_selection import GroupKFold\n","bce40efd":"train_df = pd.read_csv(\"..\/input\/shopee-product-matching\/train.csv\")\ntest_df = pd.read_csv(\"..\/input\/shopee-product-matching\/test.csv\")\nsample_submission = pd.read_csv(\"..\/input\/shopee-product-matching\/sample_submission.csv\")","449f416b":"train_df.loc[train_df[\"image_phash\"] == \"d0c0ea37bd9acce0\"]","7784e173":"sample_image_path = train_df.loc[train_df[\"image_phash\"] == \"d0c0ea37bd9acce0\", \"image\"].values[0]\nsample_image = cv2.imread(\"..\/input\/shopee-product-matching\/train_images\/\" + sample_image_path)[:, :, ::-1]\nplt.imshow(sample_image)\nprint(\"The image of image_phash == d0c0ea37bd9acce0\")","7da8230f":"n_folds = 5","2c7f7c8c":"phash_group = train_df.groupby(\"image_phash\")","72a38859":"phash_dict = {}\nfor phash in phash_group.groups.keys():\n    label_group = phash_group.get_group(phash)[\"label_group\"].tolist()\n    phash_dict[phash] = label_group\n    \n# phash_dict","e81ddde1":"phash_group_dict = {}\ngroup_id = 0\nfor phash1, label_group1 in tqdm(phash_dict.items()):\n    ismatch = False\n    for phash2, label_group2 in phash_dict.items():\n        if phash1 == phash2:\n            continue\n        if len(set(label_group1) & set(label_group2)) > 0:\n            if phash1 in phash_group_dict:  # already decided the gruop\n                phash_group_dict[phash2] = phash_group_dict[phash1]  # same gruop\n            else:\n                phash_group_dict[phash1] = group_id\n                phash_group_dict[phash2] = group_id\n                group_id += 1\n            ismatch = True\n    if not ismatch:\n        phash_group_dict[phash1] = group_id\n        group_id += 1","3d94738d":"# phash_group_dict","89c2ed95":"train_df[\"group\"] = -1\nfor phash, group in tqdm(phash_group_dict.items()):\n    train_df.loc[train_df[\"image_phash\"] == phash, \"group\"] = group\ntrain_df","ccb9b059":"\n\ntrain_df[\"fold\"] = -1\ngkf = GroupKFold(n_splits=n_folds)\nfor fold, (train_idx, val_idx) in enumerate(gkf.split(train_df, None, train_df[\"group\"])):\n    train_df.loc[val_idx, \"fold\"] = fold\ntrain_df","9e1fa6c8":"train_df.to_csv(\"train_folds.csv\", index=False)","a71f6b99":"for fold in range(n_folds):\n    df = train_df.loc[train_df[\"fold\"]==fold]\n    print(f\"fold{fold} has {df.shape[0]} data\")\n    ","98b16133":"label_group_sets = []\nfor fold in range(n_folds):\n    df = train_df.loc[train_df[\"fold\"]==fold]\n    lg = set(df[\"label_group\"].tolist())\n    label_group_sets.append(lg)\n    \nfor fold, lgs1 in enumerate(label_group_sets):\n    for fold_, lgs2 in enumerate(label_group_sets):\n        if (lgs1 is lgs2) or fold > fold_:\n            continue\n        print(f\"The number of duplicates of label_group in fold {fold} and fold {fold_} are {len(lgs1 & lgs2)}\")","96259cb7":"phash_sets = []\nfor fold in range(n_folds):\n    df = train_df.loc[train_df[\"fold\"]==fold]\n    ph = set(df[\"image_phash\"].tolist())\n    phash_sets.append(ph)\n    \nfor fold, ph1 in enumerate(phash_sets):\n    for fold_, ph2 in enumerate(phash_sets):\n        if (ph1 is ph2) or fold > fold_:\n            continue\n        print(f\"The number of duplicates of image_phash in fold {fold} and fold {fold_} are {len(ph1 & ph2)}\")","e11fbc0c":"# About this notebook\nIn this notebook, I am going to share the way to split into train and test sets.  \nMy idea is \n* same `label_group` should be in the same fold\n* same image should be in the same fold\n\nWhile doing EDA, I noticed \n* some images that are the same `image_phash` but different `image` path\n* some images that are the same `image` but different `label_group`\n\nSo splitting only by `label_group` could lead a data leakage since there could be the same image in different folds.\n\nFor example, `image_phash = d0c0ea37bd9acce0` has 20 rows but the `label_group` is `4198148727` or `2403374241` although they are the same images. \n","2f13d4c5":"# Save the CSV","b84f0592":"# Checking the duplicates of image_phash","0ded0047":"# Checking the number of data in each fold","24dd9daf":"# Checking the duplicates of label_group","65eb7b4c":"# How to split\n\nMy approach is \n1. creating the dictionary of {\"image_phash\": label_group}\n2. finding duplicates of label_group in different \"image_phash\"s \n3. if there are duplicates, the \"image_phash\"s are regarded as the same group\n","ad1446c5":"No duplicates!","5799f557":"No duplicaes!"}}