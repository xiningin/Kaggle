{"cell_type":{"d9f3e36c":"code","b1c094b6":"code","11b73947":"code","a79fb9c2":"code","5d60b569":"code","a67a4cc5":"code","b9c086ae":"code","8367fb69":"code","80634662":"code","c57effc6":"code","1c89409a":"code","c1cdcbe1":"code","39025686":"code","7a0bfa10":"code","18ae2c54":"code","d3683f02":"code","9509ccbe":"code","9e793e93":"code","65b7b0a2":"code","a65dae0d":"code","6d97d21d":"code","5373ad86":"code","225d042c":"code","3fd733d2":"code","d01499af":"code","ff6e9457":"code","d693220e":"code","4746be8c":"code","d066e5a6":"code","4a2a3abd":"code","24fdb1b2":"code","d7422b25":"code","e131ca2f":"code","bbb70091":"code","75ffb420":"code","6686f0cc":"code","5d8c6283":"code","ab0d4495":"code","69fc4ff1":"code","5cd58e59":"code","3bc8c281":"code","ec6cc431":"code","0831c8b1":"code","d29740f3":"code","8382155e":"code","c7ccf6dc":"code","d3ac33d1":"code","34f35957":"code","d03ba3a0":"code","5593c7eb":"code","3582065d":"code","14baa831":"code","4884ac5f":"code","a43bf5ff":"code","181bd68e":"code","7c048039":"code","37e7e39d":"code","5c551236":"code","30af3b87":"code","48196d38":"code","24cc940a":"code","cb9be23a":"code","16891960":"code","c6b2bc2b":"code","6075a18a":"code","62de6530":"code","b3470501":"code","b4ceb41b":"code","42a0ae89":"code","7c5379f8":"code","2773a693":"code","f6107925":"code","ae65c4db":"code","6064b1b8":"code","d436adca":"code","a8afb13b":"code","8c65fc2e":"code","e8fef198":"code","06525721":"code","39bbf3c0":"code","012ff33d":"code","fad14354":"code","5883b6ad":"code","026a1daf":"code","08e27b75":"code","3e193196":"code","0b89e1fe":"code","9e063c7b":"code","5f6d2359":"code","660ffe81":"markdown","39c07f74":"markdown","391f2d96":"markdown","6ab51de8":"markdown","a6838acc":"markdown","bd9b2348":"markdown","fac4c7b2":"markdown","8609610a":"markdown","950ad07e":"markdown","e703f219":"markdown","05933955":"markdown","c5d995b1":"markdown","e3b989ae":"markdown","66680879":"markdown","b07597de":"markdown","ebc45172":"markdown","1f7e4b28":"markdown","9e4906b0":"markdown","a9b3cb4a":"markdown","8f519f07":"markdown","d4c885c7":"markdown","a87f6cc0":"markdown","26d51f35":"markdown","25ee52a5":"markdown","84929802":"markdown","83ce2f9a":"markdown","e1772f3e":"markdown","5b2ad6d9":"markdown","9febcd1b":"markdown","d1e70e15":"markdown","453ce56d":"markdown","fdbb1e9d":"markdown","6b495643":"markdown","ee48eda8":"markdown","51a529ba":"markdown","15eb7734":"markdown","0ba7b83d":"markdown","66e99742":"markdown","7166a010":"markdown","b09d03eb":"markdown","1624ee18":"markdown","08affe39":"markdown","2c3cd053":"markdown","2acecbb9":"markdown","2c98c50d":"markdown","970e3ff9":"markdown","3ee8de59":"markdown","d9108772":"markdown","72dc0f47":"markdown","df9e10ed":"markdown","340fe801":"markdown","be584be8":"markdown","cb913323":"markdown","d774db2c":"markdown","58ba8c57":"markdown","4885a20b":"markdown","01c73797":"markdown","a0341c6c":"markdown","cd000d0a":"markdown","e04ffae5":"markdown","40e2115d":"markdown","ff4396d5":"markdown","09208fa3":"markdown","92e6c057":"markdown","106df6ae":"markdown","054c655e":"markdown","3cdf2aeb":"markdown","899108e0":"markdown","9823183f":"markdown","34fa2e8a":"markdown","52ed8c09":"markdown","a793608a":"markdown","105dc242":"markdown","d7d6b86c":"markdown","0ef74c7d":"markdown"},"source":{"d9f3e36c":"project_name = \"IPL-data-analysis\" ","b1c094b6":"# Let us begin with importing all the required packages\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport matplotlib\nfrom collections import Counter\nimport os\n%matplotlib inline","11b73947":"if os.getcwd() != '\/kaggle\/input':\n    print(\"Changing Directory\")\n    os.chdir(\"\/\/\")\n    os.chdir(\"kaggle\/input\")\nelse:\n    print(\"Already in required Directory\")","a79fb9c2":"# Importing the matches.csv into a pandas dataframe\nipl_raw_df = pd.read_csv('ipldata\/matches.csv')\nipl_raw_df","5d60b569":"ipl_raw_df.columns","a67a4cc5":"# Importing the deliveries.csv files into a pandas dataframe\ndeliveries_raw_df = pd.read_csv('ipldata\/deliveries.csv')\ndeliveries_raw_df","b9c086ae":"deliveries_raw_df.columns","8367fb69":"ipl_matches_df = ipl_raw_df.copy()","80634662":"ipl_matches_df.shape","c57effc6":"print(\"UMPRIE 3 Describe rows count :\",ipl_matches_df['umpire3'].describe()['count'])","1c89409a":"ipl_matches_df = ipl_matches_df.drop(['umpire3','city'],axis=1)\nipl_matches_df","c1cdcbe1":"ipl_matches_df.describe()","39025686":"ipl_matches_df.info()","7a0bfa10":"ipl_matches_df['date'] = pd.to_datetime(ipl_matches_df['date'])","18ae2c54":"# Now lets check the info()\nipl_matches_df.info()","d3683f02":"ipl_matches_df['season'] = ipl_matches_df['season'].apply(lambda x: int(str(x)[-4:]))\nipl_matches_df","9509ccbe":"# Let's Check our matches dataframe\nipl_matches_df.info()","9e793e93":"# Copying the original dataframe into another dataframe.\ndeliveries_df = deliveries_raw_df.copy()\ndeliveries_df","65b7b0a2":"deliveries_df.columns","a65dae0d":"# Let us first remove all the rows with is_super_over = 1 we can see there are only 81 rows with the specific condition.\nprint(\"Number of rows having super_over as 1 :\",sum(deliveries_df.is_super_over == 1))","6d97d21d":"deliveries_df = deliveries_df[deliveries_df.is_super_over != 1]","5373ad86":"columns_to_remove = ['non_striker','wide_runs','is_super_over','bye_runs','legbye_runs','noball_runs','penalty_runs']","225d042c":"deliveries_df = deliveries_df.drop(columns_to_remove,axis=1)","3fd733d2":"deliveries_df","d01499af":"deliveries_df[deliveries_df['inning'] == 5] ","ff6e9457":"deliveries_df[deliveries_df['inning'] == 3] ","d693220e":"deliveries_df = deliveries_df[deliveries_df['inning'] != 5] \ndeliveries_df = deliveries_df[deliveries_df['inning'] != 3] ","4746be8c":"# Checking the Unique values in inning column \ndeliveries_df.inning.unique()","d066e5a6":"# # For easy interpretation of our data lets add the season column in our deliveries_df dataset from ipl_matches_df\n# # But we can see there are no common column names while the column id and match_id matches respectively \n# # Lets rename the match_id column as id first to merge the two dataset\n# deliveries_df.rename(columns = {'match_id':'id'},inplace=True)\ndeliveries_df","4a2a3abd":"deliveries_df = pd.merge(deliveries_df,ipl_matches_df[{'id','season'}],left_on = 'match_id',right_on='id')\n","24fdb1b2":"deliveries_df.drop('id', inplace=True, axis=1)\ndeliveries_df","d7422b25":"unique_matches = deliveries_df.match_id.unique()","e131ca2f":"class Process():\n    team_runs_df = pd.DataFrame(columns = ['match_id','inning','team_name','extra_runs','total_runs','players_dismissed'])\n    def __init__(self,unique_matches,deliveries_df):\n        self.unique = unique_matches\n        self.df = deliveries_df\n        self.create_df()\n        \n    def create_df(self):\n        for m_id in self.unique:\n            if m_id in self.team_runs_df[\"match_id\"]:\n                temp = self.team_runs_df[self.team_runs_df[\"match_id\"] == m_id].inning\n                if 1 in temp and 0 in temp:\n                    continue\n            match_df = self.df[self.df['match_id'] == m_id].copy()\n            team1 = match_df[match_df['inning'] == 1].copy()\n            team2 = match_df[match_df['inning'] == 2].copy()\n            i=0\n            for team in team1,team2:\n                runs = team['total_runs'].sum()\n                wickets = team['player_dismissed'].notnull().sum()\n                extras = team['extra_runs'].sum()\n                te = team.batting_team.unique() \n                if len(te) > 0:\n                    te = te[0]\n                df2 = {'match_id': m_id,'inning' : i+1,'team_name' : te,'extra_runs' : extras ,'total_runs' : runs,'players_dismissed' : wickets}\n                i+=1\n                self.team_runs_df = self.team_runs_df.append(df2,ignore_index = True)\n                \n    def get_team_stats(self):\n        return self.team_runs_df","bbb70091":"obj = Process(unique_matches,deliveries_df)\nteam_stats_df = obj.get_team_stats()","75ffb420":"team_stats_df","6686f0cc":"team_stats_df.info()","5d8c6283":"# We need to convert match_id,inning,extra_runs,total_runs and players_dismissed to int64 dtype\nteam_stats_df = team_stats_df.astype({\"match_id\":int,'inning':int,'extra_runs':int,'total_runs':int,'players_dismissed':int})","ab0d4495":"team_stats_df.info()","69fc4ff1":"# Copying our dataframe into a CSV file Team_stats.csv if device allows\ntry:\n    team_stats_df.to_csv(\"Team_stats.csv\")\nexcept:\n    pass","5cd58e59":"players = deliveries_raw_df.batsman.unique()\nplayers","3bc8c281":"class Batsman():\n    batsman_df = pd.DataFrame(columns=['player_name','total_runs','outs','balls_played','average_runs','strike_rate'])\n    def __init__(self,players,deliveries_df):\n        self.players = players\n        self.df = deliveries_df.copy()\n        \n    def create_df(self):\n        for player in self.players:\n            run = int(self.df[self.df[\"batsman\"] == player].batsman_runs.sum())\n            balls = int((self.df[\"batsman\"] == player).sum())\n            #print(balls)\n            out = int((self.df[\"player_dismissed\"] == player).sum())\n            try:\n                avg_run = run\/out # average runs = Total runs divided by total outs\n            except:\n                avg_run = 0\n            try:\n                strk_rate = (run * 100)\/balls # strike rate = run scored per 100 balls\n            except:\n                strk_rate = 0\n            df2 = {'player_name':player,'total_runs': int(run),'outs':int(out),'balls_played': int(balls),'average_runs':avg_run,'strike_rate': strk_rate}\n            self.batsman_df = self.batsman_df.append(df2,ignore_index =True)\n        return self.batsman_df","ec6cc431":"# Let us use the raw df for this dataframe as some values might be missing if the raw df is not used. \nbatsman_df = Batsman(players,deliveries_raw_df).create_df()","0831c8b1":"# Here's a glimpse of the dataframe we created\nbatsman_df","d29740f3":"batsman_df.info()","8382155e":"batsman_df = batsman_df.astype({'total_runs':int,'outs':int,\"balls_played\":int})\nbatsman_df.info()","c7ccf6dc":"# Let's Choose a Player Name and see his stats (say 'V Kohli')\nbatsman_df[batsman_df.player_name == 'V Kohli']","d3ac33d1":"# Saving the dataframe into a .csv file (say player_batting_stats.csv) For future reference if the device allows\ntry:\n    batsman_df.to_csv(\"Player_batting_stats.csv\")\nexcept:\n    pass","34f35957":"# The entire list of seasons, this will be used multipe times in our analyzations later\nseason_list = list(range(2008,2020)) \nseason_list","d03ba3a0":"sns.set_style('darkgrid')\nmatplotlib.rcParams['font.size'] = 14\n#matplotlib.rcParams['figure.figsize'] = (9, 5)\nmatplotlib.rcParams['figure.facecolor'] = '#00000000'","5593c7eb":"top_ten_avg_score = batsman_df.sort_values(\"average_runs\",ascending = False).head(10)\ntop_ten_avg_score","3582065d":"plt.figure(figsize=(14,8))\nplt.grid(True)\nplt.xticks(rotation=75)\nplt.title(\"Average Score per Player\")\nsns.barplot(x=top_ten_avg_score.player_name, y=top_ten_avg_score.average_runs);","14baa831":"top_ten_avg_score = batsman_df[batsman_df.balls_played >= 180].sort_values(\"average_runs\",ascending = False).head(10)\nplt.figure(figsize=(14,8))\nplt.grid(True)\nplt.xticks(rotation=75)\nplt.title(\"Average Score vs Player Modified\")\nsns.barplot(x=top_ten_avg_score.player_name, y=top_ten_avg_score.average_runs);","4884ac5f":"# Lets check out the first 5 values first\ntop_strk_rate = batsman_df.sort_values(\"strike_rate\",ascending = False).head(5)\ntop_strk_rate","a43bf5ff":"plt.figure(figsize=(12,8 ))\nplt.title('Strike Rate vs Balls Played')\n\nsns.scatterplot(x=batsman_df.balls_played, \n                y=batsman_df.strike_rate, \n                s=60\n               );","181bd68e":"top_strk_rate = batsman_df[batsman_df.balls_played >=300].sort_values(\"strike_rate\",ascending = False).head(10)\nplt.figure(figsize=(10,5))\nplt.xticks(rotation=75)\nplt.title(\"Strike Rate per Player\")\nsns.barplot(x=top_strk_rate.player_name, y=top_strk_rate.strike_rate);","7c048039":"highest_run = batsman_df.sort_values('total_runs',ascending = False).head(10)\nhighest_run","37e7e39d":"plt.figure(figsize= (14,5))\nplt.title(\"Total Runs vs Player.\")\nsns.barplot(x=highest_run.total_runs,y=highest_run.player_name);","5c551236":"# Let's make a list of all the bowlers in IPL\nbowlers_list = deliveries_df.bowler.unique()\nid_per_season = dict()\nfor year in season_list:\n    id_per_season[year] = list(ipl_matches_df[ipl_matches_df.season == year].id)","30af3b87":"highest_bowl = pd.DataFrame(columns ={\"name\",\"Balls_bowled\"})\nfor year in season_list:\n    sample_df = deliveries_df[deliveries_df.season == year].copy()\n    unique_bowlers = sample_df.bowler.unique()\n    bowlers_df = pd.DataFrame(columns = {\"name\",\"Balls_bowled\"})\n    for player in unique_bowlers:\n        tot = int((sample_df.bowler == player).sum())\n        bowlers_df=bowlers_df.append({\"name\":player+\" (\"+str(year)+\")\",\"Balls_bowled\":tot},ignore_index = True)\n    highest_bowl = highest_bowl.append(bowlers_df.sort_values(\"Balls_bowled\",ascending=False).head(1),ignore_index = True)\nhighest_bowl","48196d38":"plt.figure(figsize=(16,6))\nplt.xticks(rotation=75)\nplt.title(\"Most balls bowled per Season\")\nplt.xlabel(\"Player Names\")\nplt.ylabel(\"Balls Bowled\")\nplt.plot(highest_bowl.name,highest_bowl.Balls_bowled,'b-x', linewidth=4, markersize=12, markeredgewidth=4);","24cc940a":"# Let's check the dismissal kind \ndeliveries_df.dismissal_kind.unique()","cb9be23a":"# Removed all rows that could cause error in our data\nsample_df = deliveries_df[deliveries_df.dismissal_kind.notnull()].copy()\nsample_df = sample_df[sample_df.dismissal_kind != \"hit wicket\"]\nsample_df = sample_df[sample_df.dismissal_kind != \"obstructing the field\"]\nsample_df = sample_df[sample_df.dismissal_kind != \"run out\"]\nsample_df = sample_df[sample_df.dismissal_kind != \"retired hurt\"]","16891960":"bowlers = sample_df.bowler.unique()\nbowler_wicket_df = pd.DataFrame(columns = [\"name\",\"wickets\"])\nfor player in bowlers:\n    tot = (sample_df.bowler == player).sum()\n    bowler_wicket_df = bowler_wicket_df.append({\"name\": player,\"wickets\":tot},ignore_index = True)","c6b2bc2b":"highest_wicket = bowler_wicket_df.sort_values(\"wickets\",ascending = False).head(10)\n# Now as we have made the highest wicket taker list Let's Visualize how is the trend for the top 10 wicket taker\nplt.figure(figsize=(14,6))\nplt.xticks(rotation=75)\nplt.title(\"Top 10 Highest Wicket Taker\")\nsns.barplot(x=highest_wicket.name, y=highest_wicket.wickets).set(xlabel =\"Bowler Name\",ylabel = \"Wickets Taken\");","6075a18a":"# Let's use the season_list to extract season wise stats\n\numpires_df = pd.DataFrame(columns = {\"Umpire_Name\",\"Umpiring_Count\"})\nfor year in season_list:\n    sample_df = ipl_matches_df[ipl_matches_df.season == year].copy()\n    # We are using Counter function from Collections package to get the count of each umpire in a year\n    umpires = Counter(sample_df.umpire1)+Counter(sample_df.umpire2) # Combining the values returned from umpire1 and umpire2\n    # max function is used to get the key of the counter object with highest value\n    keymax = max(umpires, key=umpires.get) \n    umpires_df = umpires_df.append({\"Umpire_Name\":keymax+\" (\"+str(year)+\")\",\"Umpiring_Count\":umpires[keymax]},ignore_index=True)\n    ","62de6530":"plt.figure(figsize= (12,7))\nplt.title(\"Umpires umpired per Season\")\nsns.barplot(x=umpires_df.Umpiring_Count,y=umpires_df.Umpire_Name);","b3470501":"stadium_count = dict(Counter(ipl_matches_df.venue))\ntotal_matches = sum(list(stadium_count.values()))\nstadium_df = pd.DataFrame(columns = {\"Stadium_Name\"})\nfor stadium,count in stadium_count.items():\n    stadium_df = stadium_df.append({\"Stadium_Name\":stadium,\"Percentage\":(count*100)\/total_matches},ignore_index=True)\nstadium_df.sort_values(\"Percentage\",ascending = False, inplace =True)\nprint(\"Total Stadiums used for IPL :\",len(stadium_count))","b4ceb41b":"plt.figure(figsize= (12,6))\nplt.title(\"Most Used Stadium for IPL\")\n#plt.xticks(rotation = 75)\nsns.barplot(y=stadium_df.Stadium_Name.head(10),x=stadium_df.Percentage);","42a0ae89":"temp_li = []\nteam_df = pd.DataFrame(columns = {\"Matches_Won\",\"Team_Name\"})\nteams = ipl_matches_df.team1.unique()\nfor year in season_list:\n    temp_li.append(list(ipl_matches_df[ipl_matches_df.season == year].tail(1).winner)[0])\nwinner_freq= dict(Counter(temp_li))\nfor team in teams:\n    team_df = team_df.append({\"Matches_Won\":winner_freq.get(team,0),\"Team_Name\":team },ignore_index =True)\nteam_df.sort_values(\"Matches_Won\",ascending =False,inplace = True)\nteam_df = team_df.reset_index()[[\"Team_Name\",\"Matches_Won\"]]\nteam_df","7c5379f8":"plt.figure(figsize= (7,3))\nplt.title(\"Total Seasons won per team in IPL\")\n#plt.xticks(rotation = 75)\nsns.barplot(y=team_df.Team_Name.head(8),x=team_df.Matches_Won);","2773a693":"won= 0\nlost=0\nfor ind in ipl_matches_df.index:\n    if ipl_matches_df['toss_winner'][ind] == ipl_matches_df['winner'][ind]:\n        won+=1\n    else:\n        lost+=1   ","f6107925":"plt.figure(figsize=(8,6))\nplt.title(\"Won vs Lost after winning toss\")\nplt.pie((lost,won), labels=(\"Lost the match\",\"Won the match\"), autopct='%1.3f%%', startangle=90);","ae65c4db":"# Lets observe the unique datas in dismissal_kind column\ndeliveries_df.dismissal_kind.unique()","6064b1b8":"# To get our answer we will first remove all the null values and save the rest in a variable \ndemo_df = deliveries_df[deliveries_df.dismissal_kind.notnull()]\ndemo_df.dismissal_kind.unique()","d436adca":"# Now lets run the  code to observe our desired answer.\ndi = dict(Counter(demo_df.dismissal_kind))\nto_rem = list()\nother = 0\nfor item in di.keys():\n    if di[item] <=300:\n        other += di[item]\n        to_rem.append(item)\ndi[\"others(C&B,stmpd,rtrd hrt,hit wckt,obstructing fld)\"] = other\nfor i in to_rem:\n    di.pop(i)\nplt.figure(figsize=(14,10))\nplt.title(\"Types of Dismissals\")\nplt.pie(di.values(), labels=di.keys(), autopct='%1.3f%%', startangle=90);","a8afb13b":"resulted_matches = ipl_matches_df[ipl_matches_df.result != \"tie\"].copy() #Omitting the tied matches\nmost_win = pd.DataFrame(columns = {\"Team Name\",\"NO. Of Wins\"})\nteams = dict(Counter(resulted_matches[resulted_matches.winner.notnull()].winner))\nfor i,v in teams.items():\n    most_win=most_win.append({\"Team Name\":i,\"NO. Of Wins\":v},ignore_index=True)\nmost_win.sort_values(\"NO. Of Wins\",ascending = False,inplace = True)\nmost_win.reset_index()[[\"Team Name\",\"NO. Of Wins\"]].head(5)","8c65fc2e":"resulted_matches = resulted_matches[resulted_matches.result != \"no result\"].copy() # Omitting the matches with no results\nteams_play_count = dict(Counter(resulted_matches.team1)+Counter(resulted_matches.team2)) #total matches played by a team\nteams = dict(Counter(resulted_matches[resulted_matches.winner.notnull()].winner)) # total wins per team\nfor team in teams:\n    teams[team] = round((teams[team]*100)\/teams_play_count[team],2)\nwin_percentage = pd.DataFrame(columns = {\"Team Name\",\"Win Percentage\"})\nfor i,v in teams.items():\n    win_percentage=win_percentage.append({\"Team Name\":i,\"Win Percentage\":v},ignore_index=True)\nwin_percentage.sort_values(\"Win Percentage\",ascending = False,inplace = True)\nplt.figure(figsize= (14,6))\nplt.title(\"Win Percentage per Team\")\nplt.xticks(range(0,101,10))\nsns.barplot(y= win_percentage[\"Team Name\"] , x = win_percentage[\"Win Percentage\"]).set(xlim = (0,100));","e8fef198":"fielding_first_won = 0\nbatting_first_won = 0\ndl_matches = ipl_matches_df[ipl_matches_df.dl_applied == 1].copy()\n\n# First lets choose those teams who won toss and chose fielding first and won the game \nfielding_first_teams = dl_matches[dl_matches.toss_decision == \"field\"]\nfielding_first_teams.reset_index(inplace=True)\nfor i in range(len(fielding_first_teams)):\n    # We will check if a team fielding first won or not\n    if fielding_first_teams[\"toss_winner\"][i] == fielding_first_teams[\"winner\"][i]:\n        fielding_first_won+=1\n    else:\n        batting_first_won+=1 # The maches in which a team did not won after choosing fielding first are the matches when batting first team won \n\n#Similarly we will do the same process for batting first teams\nbatting_first_teams = dl_matches[dl_matches.toss_decision == \"bat\"]\nbatting_first_teams.reset_index(inplace=True)\nfor i in range(len(batting_first_teams)):\n    # We will check if a team fielding first won or not\n    if batting_first_teams[\"toss_winner\"][i] == batting_first_teams[\"winner\"][i]:\n        batting_first_won+=1 # The matches in which a team chose to bat first\n    else:\n        fielding_first_won+=1 # The matches in which a team chose to bat first but lost in those fielding first teams won\nprint(\"Total Matches in which D\/L are applied in IPL till now :\",len(dl_matches))","06525721":"# Now let's plot and see the resuts\nplt.figure(figsize=(6,6))\nplt.title(\"Winning Teams for D\/L Matches\")\nplt.pie((fielding_first_won,batting_first_won),labels=(\"Fielding First Teams\",\"Batting First Teams\"),autopct='%1.3f%%',startangle = 180);","39bbf3c0":"team_stats_df.describe()","012ff33d":"team_stats_with_ground = pd.merge(team_stats_df,ipl_matches_df[{'id','venue'}],left_on = 'match_id',right_on='id')\nstadiums = team_stats_with_ground.venue.unique()\nstadium_type_df = pd.DataFrame(columns = {\"Stadium Name\",\"Favoured Stadium Type\"})\nfor stadium in stadiums:\n    temp_df = team_stats_with_ground[team_stats_with_ground.venue == stadium]\n    avg = temp_df.describe()[\"total_runs\"][\"mean\"]\n    if avg<=145:\n        stadium_type_df = stadium_type_df.append({\"Stadium Name\": stadium,\"Favoured Stadium Type\": \"Bowling\"},ignore_index =True)\n    elif avg>=160:\n        stadium_type_df = stadium_type_df.append({\"Stadium Name\": stadium,\"Favoured Stadium Type\": \"Batting\"},ignore_index =True)\n    else:\n        stadium_type_df = stadium_type_df.append({\"Stadium Name\": stadium,\"Favoured Stadium Type\": \"Neutral\"},ignore_index =True)\n\nstadium_type_df.index +=1\nstadium_type_df.reset_index()[[\"Stadium Name\",\"Favoured Stadium Type\"]]","fad14354":"# Comparing how many Batting favoured, Bowling favoured and Neutral stadiums are there.\ncnt = dict(Counter(stadium_type_df[\"Favoured Stadium Type\"]))\nplt.figure(figsize=(6,6))\nplt.title(\"Types of Stadiums\")\nplt.pie(list(cnt.values()),labels=list(cnt.keys()),autopct='%1.3f%%',startangle = 180);","5883b6ad":"# At first let us remove all those match with results as NO result or tie i.e consider only matches with Normal result\nconsidered = ipl_matches_df[ipl_matches_df.result == \"normal\"]\nconsidered.reset_index(inplace = True)\n# Lets make a dictionary of ids of matches to winner of match:\nids_di = dict()\nfor i in range(len(considered)):\n    ids_di[considered[\"id\"][i]] = considered[\"winner\"][i]\nextra_more_loss = 0 #Teams for which giving more extra resulted in their defeat\nextra_more_won = 0 # Teams who won even after giving more extras\nfor i in ids_di.keys():\n    di = dict()\n    match = deliveries_df[deliveries_df.match_id == i]\n    inning1 = match[match.inning == 1]\n    inning2 = match[match.inning == 2]\n    di[inning1.extra_runs.sum()] = inning1.bowling_team.unique()[0]\n    di[inning2.extra_runs.sum()] = inning2.bowling_team.unique()[0]\n    # We need to skip those teams who gave equal extra runs\n    if len(di) == 1:\n        continue\n    ma = max(di.keys()) # Getting the teams who gave more extra run\n    # Now lets check if the team loose after giving more extra runs\n    if di[ma] != ids_di[i]:\n        # Number of teams for who giving more extra run cost the match \n        extra_more_loss +=1\n    else:\n        #Number of teams who won even after giving more extra runs\n        extra_more_won+= 1","026a1daf":"plt.figure(figsize=(6,6))\nplt.title(\"Effect of extra runs in IPL matches\")\nplt.pie((extra_more_won , extra_more_loss),labels=(\"Gave more extra runs still won match\",\"Gave more extra runs and lost match\"),autopct='%1.2f%%',startangle = 90);","08e27b75":"# At first we will see the Orange Cup Winner Season Wise\n#season_list variable is defined above\norange_cap_winners = pd.DataFrame(columns = {\"Season\",\"Player\",\"Total Runs\"})\nfor year in season_list:\n    matches_season = deliveries_df[deliveries_df.season == year]\n    player_stats = dict()\n    for batsman in matches_season.batsman.unique():\n        demo =  matches_season.loc[matches_season.batsman == batsman]\n        player_stats[batsman+\" (\"+demo.batting_team.unique()[0]+\")\"] =demo.batsman_runs.sum()\n    keymax = max(player_stats, key=player_stats.get)\n    orange_cap_winners = orange_cap_winners.append({\"Season\":year,\"Player\":keymax,\"Total Runs\":player_stats[keymax]},ignore_index = True)","3e193196":"orange_cap_winners","0b89e1fe":"# Now let's look at the purple cap award winner per season.\n# At first let us filter out those deliveries which has no dimissals from our deliveries_df\ndismissals = deliveries_df[deliveries_df.player_dismissed.notnull()].copy()\n# dismissals of type run out, retired hurt,hit wicket,obstructing the field does not count on \n# bowlers record so we will remove them\ndismissals = dismissals.loc[(dismissals.dismissal_kind != \"run out\")]\ndismissals = dismissals.loc[(dismissals.dismissal_kind != \"retired hurt\")]\ndismissals = dismissals.loc[(dismissals.dismissal_kind != \"hit wicket\")]\ndismissals = dismissals.loc[(dismissals.dismissal_kind != \"obstructing the field\")]\npurple_cap_winners = pd.DataFrame(columns = {\"Season\",\"Player\",\"Wickets Taken\"})\nfor year in season_list:\n    matches_season = dismissals[dismissals.season == year]\n    bowler_stats = dict()\n    for bowler in matches_season.bowler.unique():\n        demo =  matches_season.loc[matches_season.bowler == bowler]\n        bowler_stats[bowler+\" (\"+demo.bowling_team.unique()[0]+\")\"] =len(demo) \n        # Total Bowls in a which player was dismissed by bowler\n    keymax = max(bowler_stats, key=bowler_stats.get)\n    purple_cap_winners = purple_cap_winners.append({\"Season\":year,\"Player\":keymax,\"Wickets Taken\":bowler_stats[keymax]},ignore_index = True)\npurple_cap_winners = purple_cap_winners.reset_index()[[\"Season\",\"Player\",\"Wickets Taken\"]]","9e063c7b":"purple_cap_winners","5f6d2359":"umpires_count = dict(Counter(ipl_matches_df.umpire1)+Counter(ipl_matches_df.umpire2)) \numpire_df = pd.DataFrame(columns = {\"Umpire Name\",\"Matches Umpired\"})\nfor umpire in umpires_count:\n    umpire_df = umpire_df.append({\"Umpire Name\":umpire,\"Matches Umpired\":umpires_count[umpire]},ignore_index = True)\numpire_df.sort_values(\"Matches Umpired\",inplace=True,ascending = False)\numpire_df\nplt.figure(figsize= (10,3))\nplt.title(\"Total Matches Umpired\")\nplt.xticks(range(0,120,10))\nsns.barplot(x=umpire_df[\"Matches Umpired\"],y= umpire_df[\"Umpire Name\"].head(5));","660ffe81":"****","39c07f74":"### Bowling\nIn Cricket bowling is the act or skill of throwing the ball toward a batsman and taking a wicket to dismiss a batsman. Here we are going to look at the top charts of bowlers performance in IPL","391f2d96":"The above Data Frame shows Purple Cap Winner Award per season with their respective total wickets taken per season. _DJ Bravo_ and _B Kumar_ both managed to win Purple Cap Award two times till now. ","6ab51de8":"Even in this graph we can see `J Bairstow` retains the top spot so we can say that he is a player who is good at holding the wicket and in T-20 format an average score 55+ is considered as very good avg runs, Also from the above table we can see that he has played for only 293 balls this show that he has not played a lot of matches in IPL.","a6838acc":"From the graph we can see the highest win percentage is of the team `Rising Pune Supergiant` while `Chennai Super ` and `Mumbai Indians` still belongs in one of the top 5 teams in Win Percentage Table.","bd9b2348":"#### Now lets create a Data Frame having total runs per team per innings.","fac4c7b2":"#### No. of times each team have won a IPL Season.\nFor the analysis of the teams winning IPL match we will use a simple DataFrame as there are only a few teams in IPL and can easily be observed and identified without the need of a chart.\n\nAs we know that the last match in a IPL Season is the final match we will consider the last match of every Season and choose the winner for our result","8609610a":"At first we will make a copy of the raw dataframe so that all the changes are done in that copy.","950ad07e":"The above Data is taken from Kaggle Datasets. Refer to the link for more information about the dataset used [IPL Dataset](https:\/\/www.kaggle.com\/nowke9\/ipldata).","e703f219":"In this we can see the columns `retired hurt` , `hit wicket` and `obstructing the field` does not count on bowlers chart, also the bowler does not get credit for `run out`. So we will remove this column in a sample dataframe for our observation.","05933955":"##### Top 10 highest wicket taker of all time","c5d995b1":"#### Making a dataframe of batsman having all players name , total runs, average runs, balls played, dismissal and strike rate of each players.\n","e3b989ae":"### Umpire\n\nAfter visualizing the stats of Batsman and Bowlers lets look at some stats of the Umpires. Umpires in cricket match manages\/look over a match and gives decisions on wickets and runs scored in a match.\n#### Most used on-field Umpire per Season.\n\nAn on field umpire is the umpire which stays on the field to judge a game instantly, the 3rd umpire look over the game from outside the field using computer screen whereas umpire1 and umpire2 does most of the work within the game.","66680879":"***","b07597de":"Formulae to calculate Average run is:\n\nAverage Score = Total_Runs_Scored \/ Total_times_Dismissed\n\nWe can observe the `average runs` of `J Bairstow` and `MN van Wynk` is higher and is nearly 55 while the others have an average score of nearly 45. Therfore we can assume that that these are the players stays in field for a longer time without getting dismissed and can help holding the wicket for a team.\n\nBut to draw a conclusion from the above graph we need to consider the number of balls played, if a player have played too less matches his avg runs might be more then the players who deserved to be at the top spot, to really see whether a player a consistent with his average score let us consider all players who have at least played 30 overs(180 balls). We are selecting 30 overs assuming a consistent player gets to play atleast 30 overs even if he plays for just one season.","ebc45172":"We can see that both __Mumbai Indians__ won most number of matches with a total winning count of 107. __Chennai Super Kings__ (100 wins) is in the 2nd spot with respect to winnning matches followed by __Kolkata Knight Riders__ (92 wins).\nIt's not surprising though because these are the teams who have won 4,3 and 2 ipl Seasons respectively. But in the 4th spot we see __Royal Challengers Bangalore__ which is preety surprising given the fact that they have never won any IPL seasons. This chart gives us an idea about why _RCB_ have a big fanbase inspite of never winning a single IPL Season.\n\nThe above Table gives us an idea of how many matches each team has won in total but to get an idea of how well a team plays we have to compare how many matches each team has won vs total matches played which gives us an idea of the win ratio\/win percentage of each team and is a more better way to compare the ability of a team. That brings us to our next Question.\n\n### Q. Do the teams with highest win counts also tops in the chart of highest win percentage?\n","1f7e4b28":"### Q. Does Winning toss plays a role in winning the match?\n\nLet's answer this question by observing the dataframe ipl_matches_df. We will compare how many team won after winning toss and how many teams lost after winning the toss.\n","9e4906b0":"**********************************************************************************************","a9b3cb4a":"#### Top 10 players in the basis of runs scored till IPL 2019\nLet us plot a bar graph of Total_Runs vs Player and see the result. ","8f519f07":"We can see that all the players in this list has a good total runs of more than 4000 with `V Kohli` and `SK Raina`  having a total runs near to 5500 which is a great total , this plot can help us visualize the best player scores of all time in IPL.","d4c885c7":"Here comes the end of our Processing of Data, we have done seen two raw tables matches and deliveries from where we have extracted the data , processed it and formed four new processed dataframe `matches_df`, `deliveries_df`,`team_stats_df` and `batsman_df`.","a87f6cc0":"From the above chart we can see the most common types of dismissals are `caught`,`bowled`,`run out` and `lbw`. All of these has a chance of nearly 95% and `CATCH OUT` being the most common type of dismissal among them. Approximately 6 out of every 10 Batsmen gets dismissed by type Catch out. There is only 5 % chance of getting a player dismissed by hit wicket, stumped, obstructing the field, Caught and Bowled and retired hurt(others).","26d51f35":"Removed all the rows that had super over.","25ee52a5":"### Q. Which Stadiums are suited for batting, bowling or has a neutral pitch?\n\n","84929802":"## Fetching the dataset","83ce2f9a":"As we see the Season column can be represented in integer format so we will convert it into integer for easy interpretation.","e1772f3e":"Finally our ipl_matches_df is ready for analyzation.","5b2ad6d9":"### Q. Does Batting first\/Fielding first helps a team to win when DL is applied?\n\nD\/L or the Duckworth\u2013Lewis\u2013Stern method is a mathematical formulation designed to calculate the target score for the team batting second in a limited overs cricket match interrupted by weather or other circumstances. The method was devised by two English statisticians, Frank Duckworth and Tony Lewis, and was formerly known as the Duckworth\u2013Lewis method (D\/L). It was introduced in 1997, and adopted officially by the ICC in 1999. After the retirements of Duckworth and Lewis, Professor Steven Stern became the custodian of the method and it was renamed to its current title in November 2014. Click here [Wikipedia](https:\/\/en.wikipedia.org\/wiki\/Duckworth\u2013Lewis\u2013Stern_method) to know about D\/L method.\n","9febcd1b":"### Q. Who are the top 5 Umpires to look over matches in IPL?\n\nLet us wrap up our Analyzation by answering the last question about Umpires. As umpires play a great a role in cricket matches we will look at the top 5 umpires who umpired in IPL till now.","d1e70e15":"### Q. What are the most common types of dismissals?\n","453ce56d":"#### Data Preparation in the matches  dataframe","fdbb1e9d":"The date column helps if the Dtype of it is date-time.","6b495643":"## References and Future Works\n\nThank you for coming this far, I hope you enjoyed my analysis on IPL matches and it helped you to learn a lot more about the game you love. \n\n__Future Work__\n\nThere are lot of scopes of improvement and\/or addition in this project in future, with the data provided and adding extra datasets we can,\n* Make a better team statistics which shows Run Rate of each team and overall position or value the team has in IPL\n* Predict the costs of players in next seasons of ipl using the data of the players and with the knowledge of the cost of the players in the previous seasons.\n* Add observation for peak over to score in IPL and overs in which most dismissals takes place can be made using data manipulations.\n* Also we can add the dataset of 2020 IPL(after it ends), observe and compare how the performance of players and teams changes by modifying only few lines of code (more the data merrier the visualization).\n* Develope a Machine Learning model which can predict the best choice of the captain after winning a toss to help them win the game.\n\n__REFERENCES__\n\n* IPL 2008-2019 Dataset: https:\/\/www.kaggle.com\/nowke9\/ipldata \n\n* Kaggle Datasets (Choose Dataset of your choice): https:\/\/www.kaggle.com\/datasets \n\n* Pandas user guide: https:\/\/pandas.pydata.org\/docs\/user_guide\/index.html\n\n* Matplotlib user guide: https:\/\/matplotlib.org\/3.3.1\/users\/index.html\n\n* Seaborn user guide & tutorial: https:\/\/seaborn.pydata.org\/tutorial.html\n\n* Data analysis guide(https:\/\/jovian.ml\/aakashns\/python-pandas-data-analysis)\n\n* Stackoverflow Community (Get answers of any problems): https:\/\/stackoverflow.com\/questions\n\n* Python solutions in Geeksforgeeks (Solutions made easy): https:\/\/www.geeksforgeeks.org\/python-programming-language\/\n\n* opendatasets Python library (Choosing and using datasets in python made easy): https:\/\/github.com\/JovianML\/opendatasets\n  \n","ee48eda8":"All the columns with numeric data type seems good to work with. The id column will be used to connect with the deliveries.csv file later.","51a529ba":"From the above pie chart we can see that toss does play a little factor but thats not enough to win a match for a team, other factors like players form, venue, pitch conditions, humidity etc. can also lead to win or defeat a team.","15eb7734":"In the above chart we can see approx 52% matches depended on extra runs i.e. In 52% matches of all match ever happened in IPL the teams which gave extra runs lost the match. This shows giving more extra runs can decide the result of the match, so a team must always prevent from giving extra runs.","0ba7b83d":"We can see `Asad Rauf` got maximum oppurtunities to umpire the game as an on field umpire in the year 2011.","66e99742":"### Q. Does giving more extra runs effects in the result of the game?\n\nLet's check this question by comparing those teams who have won by giving more extra runs and those who lost by the same.","7166a010":"There are 1512 rows in our dataframe, i.e. for each match_id there are two rows (inning 1 and inning 2) so our dataframe is complete. Let us make a copy of our dataframe into a CSV file.","b09d03eb":"We can see that total_runs,outs,balls_played column is not integer type , so lets convert it to integer first.","1624ee18":"\n*****","08affe39":"### Q. Who won the orange Cap Award and Purple Cap Award each Year?\n\n__Orange Cap Award__ : The Orange Cap is presented to the leading run scorer in the Indian Premier League (IPL). It was introduced on 25 April 2008, a week after the start of the inaugural season of the IPL. The batsman with most runs in the tournament during the course of the season would wear the Orange Cap while fielding, with the overall leading run-scorer at the conclusion of the tournament winning the actual Orange Cap award on the day of the season's final. \n\n__Purple Cap Award__ : The Purple Cap is presented to the leading wicket-taker in the IPL. After the introduction of Orange Cap on 25 April 2008, the IPL announced the introduction of the Purple Cap on 13 May 2008. The bowler with most wickets in the tournament during the course of the season would wear the Purple Cap while fielding, with the overall leading wicket-taker at the conclusion of the tournament winning the actual Purple Cap award on the day of the season's final.\n\nContent-Source : [Wikipedia](https:\/\/en.wikipedia.org\/wiki\/List_of_Indian_Premier_League_awards)\n","2c3cd053":"From the above graph we can see that for more numbers of ball played the srike rate of players tends to remains in the range 130 - 150 and varies a lot when the number of balls played is too less. This shows when players plays a lot of matches the strike rates gets fixed near a nearly constant value. To see the top players with best strike rates we will see only those players who have played at least 300 balls(50 overs). ","2acecbb9":"The above analysis gives us an overview of the IPL matches, stats of different players and some more enjoyable and knowledge facts about IPL from the Starting of IPL in the year 2008 upto 2019. The above observation contains a lot of informations about a player in particular or a team as a whole. \n\nWith that, we\u2019ve come to the end of this analysis. If you are a cricket lover I am sure you have heard about IPL before, and for many of you it is one of the favourite games to enjoy with your family. It's fun as well exciting to discuss the results of the games you love and tell others the stories of the same ,after going through this notebook you will have a lot more stories to tell about IPL and brag about your knowledge on the game. Hope you enjoyed!! ","2c98c50d":"#### Top 10 players with highest Strike Rate\nStrike Rate shows the real performance of a batsman in T20 format as for only 20 overs holding the wicket is not the only option for batsman , one have to keep up the scoreboard to give a good Competition to the team.\n\nStrike Rate is Total Runs per 100 balls played i.e : _Strike Rate = (Runs * 100) \/ Total_Balls_played_","970e3ff9":"From the above DataFrame we can see that `Mumbai Indians` won most of the matches in the 12 years of IPL Seasons, We can also see all the teams that have\/had participated in IPL till now, and only `Mumbai Indians`, `Chennai Super Kings`, `Kolkata Knight Riders`, `Sunrisers Hyderabad`, `Rajasthan Royals` and `Deccan Chargers` managed to win titles in IPL .","3ee8de59":"## Table of Contents\n\n* Importing Packages\n* Fetching the dataset\n* Data Preparation and Cleaning\n\n    * Data Preparation in the matches dataframe\n    * Data Preparation for Deliveries dataframe\n    * Creating a Data Frame having total runs per team per innings.\n    * Creating a Data Frame of Batsman with their respective strike rates, avg run rate etc.  \n    \n* Exploratory Analysis and Visualization\n\n    * Batting\n        * Top 10 players with highest average runs.\n        * Top 10 players with highest strike rates.\n        * Top 10 players in the basis of runs scored till IPL 2019.\n\n    * Bowling\n        * Most balls bowled per season\/Year.\n        * Top 10 highest wicket Taker of all time.\n\n    * Umpire\n        * Most used on-field umpire Per Season.\n\n    * Team Management\n        * Top 10 most used Stadium.\n        * No. of times each team have won a IPL Season.\n    \n* Asking and Answering Questions\n    * Does Winning the toss plays a role in winning the match?\n    * What are the most common types of dismissals?\n    * Which team has won most matches of IPL till now?\n    * Do the teams with highest win counts also tops in the chart of highest win percentage?\n    * Does Batting first\/Fielding first helps a team to win when DL is applied?\n    * Which Stadiums are suited for batting, balling or has a neutral pitch?\n    * Does giving more extra runs effects in the result of the game?\n    * Who won the orange Cap Award and Purple Cap Award each Year?\n    * Who are the top 5 Umpires to look over matches in IPL?\n* Inferences and Conclusion\n* Reference and Future Works","d9108772":"From this table we can see that players who have managed to made some score without playing a lot of balls got the highest strike rates, even though mathematically the data is correct logically it would be unfair to consider the player who have not played a lot and got good stike rate.\n\n_To watch the trend how the strike rate varies with number of balls played lets plot a scatter plot._","72dc0f47":"*******","df9e10ed":"## Exploratory Analysis and Visualization\n\n* Batting\n    * Top 10 players with highest average runs.\n    * Top 10 players with highest strike rates.\n    * Top 10 players in the basis of runs scored till IPL 2019.\n    \n* Bowling\n    * Most balls bowled per season\/Year.\n    * Top 10 highest wicket Taker of all time.\n    \n* Umpire\n    * Most used on-field umpire Per Season.\n    \n* Team Management\n    * Top 10 most used Stadium.\n    * No. of times each team have won a IPL Season.","340fe801":"From the above pie chart we can see that team who chose or got _Fielding first_ or the chasing team has a clear advantage of winning on the days when DL's are applied. ","be584be8":"From the above data we can see the average score of every team in IPL till now 2019 is 155.47. For our observation we will consider any ground who has average score more than 160 can be treated as Batting pitch, average score less than 145 will be treated as Balling Pitch and the rest as Neutral.\n\nFor our observation at first we will add the venue column to the above table team_stats_df.","cb913323":"## Asking and Answering Questions\n\n### Questions\n1. Does Winning the toss plays a role in winning the match?\n2. What are the most common types of dismissals?\n3. Which team has won most matches of IPL till now?\n4. Do the teams with highest win counts also tops in the chart of highest win percentage?\n5. Does Batting first\/Fielding first helps a team to win when DL is applied?\n6. Which Stadiums are suited for batting, balling or has a neutral pitch?\n7. Does giving more extra runs effects in the result of the game?\n8. Who won the orange Cap Award and Purple Cap Award each Year?\n9. Who are the top 5 Umpires to look over matches in IPL?","d774db2c":"#### Most ball bowled per season\/Year\nThe bowler which performs best in a season are given the most balls to bowl. So let us have some visual who are the top bowlers in each season with respect to total balls bowled.","58ba8c57":"#### Top 10 players with highest Average Runs.\n\nTo Visualize the top players with highest average runs we can use a bar graph. We will use the dataframe we previously made `batsman_df` to visualize this graph. ","4885a20b":"From the graph we can see that `SL Malinga ` is the highest wicket taker of all time followed by `A Mishra`.","01c73797":"### Batting\nIn cricket batting is the act or skill of hitting the ball to score runs or to prevent from getting a wicket. Any player who is standing in the pitch and facing the bowler is considered to be a batsman. Let us get some visualization and analyzation of the best batsman charts in IPL 2008-2019.","a0341c6c":"As we see the innings 3 and 5 may be error in data entry and there are too less rows having innings as 3 and 5, we will be removing these rows. ","cd000d0a":"From the above chart we can assume that among all 41 stadiums used for the IPL matches almost `40%` of matches are played in the top 4 stadiums and among all stadiums `Eden Gardens` tops the list with a total of nearly 76 matches played so far.","e04ffae5":"![image.png](attachment:image.png)\n# IPL DATA ANALYSIS (2008 - 2019)\n\nIndian Premier League more popularly called as IPL is a Cricket Tournament hoisted by the Cricket Board of India(BCCI). Players from different countries participate in IPL making it an exciting oppurtunity to entertain cricket lovers. IPL was established in 2008 when the first season of IPL was hoisted. Since then every year the IPL game is played and celebrated as a month long cricket festival for Indians and cricket lovers throughout the world. IPL also gives opppurtunities to the young players to showcase their talent and improve their experience by playing with some of the best and experienced players of cricket. As the current season of IPL(2020) is ongoing let us all revise and analyze the performance of players in the previous Seasons.\n\nIn this project I am going to go through two datasets of IPL matches in INDIA ,observe the data, analyze and process it and going to answer few common questions about the dataset that would generally bug you. Go through the notebook carefully and enjoy the different observations made by me .\n### About the Datasets.\n\nThe given dataset was taken from the dataset bundle present in Kaggle Datasets, Refer to this link [IPL 2008-2019 Kaggle Dataset](https:\/\/www.kaggle.com\/nowke9\/ipldata) to get more information about the dataset and download it from Kaggle to work with it.\n\nWith this dataset I am trying to visualize different trends in IPL score of teams and players from 2008 to 2019, As the current season IPL 2020 is ongoing it would be fun and helpful to know the stats of teams and players visually for the last 11 years. Hope you will enjoy the visualization provided by me. \n\nThe name of the Dataset used for this projects are `matches.csv` and `deliveries.csv`. There are 756 rows in the `matches.csv` file each row containing data about a specific match. The `deliveries.csv` dataset is a huge one with over `1.79 Lakhs` of rows of data and every row represents data from each delivery from each match for the last 11 years. \n\nI will be using Python 3 for this analysis, And am doing this project in Jupyter Notebook(Kaggle and Google Collab are also good options to run this notebook and work with it). The Libraries\/Packages I will be using in this projects are as followed.\n* __jovian__ (to upload, save and share the contents of my notebook)\n* __numpy__ (as np is one of the very famous packages for working with arrays in python)\n* __pandas__ (Is greatly used in analysis of data and making dataframe)\n* __matplotlib__ (Lets make our Analyzation fun and interative with the visualization library matplotlib)\n* __seaborn__ (Adding more colours into matplotlib visualization)\n* __collections__ (specialized container datatypes providing alternatives to Python's general purpose built-in containers like dict, list etc.)","40e2115d":"*****","ff4396d5":"The above chart shows us the top 5 umpires who umpired for maximum number of times in IPL Seasons(2008-2019) .","09208fa3":"## Inferences and Conclusion\n","92e6c057":"#### Data Preparation for Deliveries dataframe","106df6ae":"The above table shows the Orange Cap Award winner of every season with their respective team name and total runs aquired per season. We can see that _DA Warner_ won the Award 3 times till 2019 and _CH Gayle_ won the same for 2 consecutive times.","054c655e":"### Team and Management\n\n#### Top 10 most used Stadium.\n\nIt would be interersting to check which stadium has hoisted an IPL match most number of times, this can give us an idea of how well organized a Stadiums Infrastructure is ","3cdf2aeb":"## Data Preparation and Cleaning\n\n","899108e0":"The above graph can show us the trend of the bowlers used in every season, we selected the most bowled ballers only because the bowlers who shows a good performance in the match gets the chance bowl in most matches. Among all these we see a great increase in the bowling numbers of `Harbhajan Singh` maybe either because more matches took place in the particular year or because the team that `Harbhajan Singh` played in went to semi finals or finals and got the chance to play more matches.","9823183f":"### Q. Which team has won most matches of IPL till now?\n\nBefore we saw who won most IPL seasons, now we will see the stats of which teams have won most match for the last 12 seasons. Though winning an IPL season cup is the biggest achievement for a team but winning most matches can also give us an idea about how good a team is, aren't you eager to know if its your favourite team on not? Let's Check\n\n\n\n","34fa2e8a":"*****","52ed8c09":"The above list contains all stadiums where IPL matches were played showing which stadiums are favoured for batting or bowling or has a neutral pitch.","a793608a":"****","105dc242":"`deliveries_df[deliveries_df['player_dismissed'].notnull().values].dismissal_kind.unique()`","d7d6b86c":"We see that there are a lot of missing values for `umpire3` column so we will remove the column to prevent any issues with our analysis. Moreover the `city` column can be ommitted as all the matches in IPL takes place in a city that is common with any one of the two teams playing , and we can get an idea of the venue from the stadiums column.","0ef74c7d":"_With these we come to an end of our Visualisation and Analysation of Data now lets answers some questions that can cross your mind while looking at the data_\n************************************"}}