{"cell_type":{"40c9ab0a":"code","d8f9a9a4":"code","209be2ec":"code","221375b3":"code","d4c3259c":"code","4896b9dc":"code","2bdf7655":"code","492598a8":"code","78e8f79e":"code","906647bb":"code","d096733a":"code","4e567ee6":"code","0641f886":"code","4d1de443":"code","e8d7a0c5":"code","2e6ea933":"code","6f92d0b3":"code","cda827ef":"code","67af8bb0":"code","a9821de3":"code","17d34df3":"code","0a7b0e95":"code","0ec661d0":"code","68a3c310":"code","ddc4e06b":"code","c99a7884":"code","0f45dcdf":"code","896a7d72":"code","7e92e9c8":"code","e03f84ba":"code","fc288e01":"code","053fa4a0":"code","46e379fe":"code","09fafa60":"code","bbc1ab06":"markdown","694d076d":"markdown","e3b13ecc":"markdown","b4e8605d":"markdown","0e371dea":"markdown","a7935691":"markdown","528bc3f1":"markdown","9f6fa361":"markdown","9bda5552":"markdown","bf3932c8":"markdown","b6d8d3bd":"markdown","7190ae85":"markdown","42d326aa":"markdown","cc41c1d0":"markdown","665f7218":"markdown"},"source":{"40c9ab0a":"import numpy as np\nimport pandas as pd\nimport os, gc\nfrom tqdm import tqdm_notebook","d8f9a9a4":"tr = pd.read_csv('..\/input\/ashrae-energy-prediction\/train.csv')\nte = pd.read_csv('..\/input\/ashrae-energy-prediction\/test.csv')","209be2ec":"tr.head()","221375b3":"te.head()","d4c3259c":"tr.groupby(['building_id','meter']).size()","4896b9dc":"tr['meter'].value_counts()","2bdf7655":"# Zoom in onto one building, and one meter.\ntr.query('building_id==0 & meter==0')","492598a8":"meta = pd.read_csv('..\/input\/ashrae-energy-prediction\/building_metadata.csv')","78e8f79e":"meta","906647bb":"for col in meta.columns:\n    if meta[col].isnull().sum() > 0: # If you have any rows with NaN in it...\n        print(col)","d096733a":"primary_use_to_id = pd.concat([pd.Series(meta['primary_use'].unique()), (pd.Series(meta['primary_use'].unique())).astype('category').cat.codes], axis=1).set_index(0).to_dict()[1]\nid_to_primary_use = pd.concat([pd.Series(meta['primary_use'].unique()), (pd.Series(meta['primary_use'].unique())).astype('category').cat.codes], axis=1).set_index(1).to_dict()[0]","4e567ee6":"primary_use_to_id","0641f886":"meta['primary_use'] = meta['primary_use'].map(primary_use_to_id).astype('int32')","4d1de443":"te['meter_reading'] = -1\ntr['row_id'] = -1\n\ntr_te = pd.concat([tr,te],axis=0,sort=True)\ndel tr,te; gc.collect()","e8d7a0c5":"timestamp_to_id = pd.concat([pd.Series(tr_te['timestamp'].unique()), (pd.Series(tr_te['timestamp'].unique())).astype('category').cat.codes], axis=1).set_index(0).to_dict()[1]\nid_to_timestamp = pd.concat([pd.Series(tr_te['timestamp'].unique()), (pd.Series(tr_te['timestamp'].unique())).astype('category').cat.codes], axis=1).set_index(1).to_dict()[0]","2e6ea933":"# The number of unique timestamps we have in train + test.\nprint(len(timestamp_to_id))","6f92d0b3":"tr_te.head()","cda827ef":"tr_te['timestamp'] = tr_te['timestamp'].map(timestamp_to_id).astype('int64')","67af8bb0":"tr_te.head()","a9821de3":"gc.collect()","17d34df3":"print('Original shape is',tr_te.shape) \ntr_te = tr_te.merge(meta, on='building_id')\nprint('Shape after merging is',tr_te.shape) ","0a7b0e95":"tr_te.head()","0ec661d0":"import matplotlib.pyplot as plt\nplt.rcParams[\"figure.figsize\"]=20,15\nimport seaborn as sns","68a3c310":"sns.kdeplot(meta['square_feet'], label='square_feet', shade=True, kernel='epa')","ddc4e06b":"sns.kdeplot(meta['year_built'], label='year_built', shade=True, kernel='epa')","c99a7884":"meta['year_built'].max(), meta['year_built'].min()","0f45dcdf":"sns.kdeplot(meta['floor_count'], label='floor_count', shade=True, kernel='epa')","896a7d72":"# sns.scatterplot(tr_te['square_feet'], tr_te['meter_reading'])\n# sns.scatterplot(tr_te['year_built'], tr_te['meter_reading'])\n# sns.scatterplot(tr_te['floor_count'], tr_te['meter_reading'])","7e92e9c8":"weather_tr = pd.read_csv('..\/input\/ashrae-energy-prediction\/weather_train.csv')\nweather_tr['timestamp'] = weather_tr['timestamp'].map(timestamp_to_id).astype('int64')\nweather_te = pd.read_csv('..\/input\/ashrae-energy-prediction\/weather_test.csv')\nweather_te['timestamp'] = weather_te['timestamp'].map(timestamp_to_id).astype('int64')\n\nweather = pd.concat([weather_tr,weather_te],axis=0)\ndel weather_tr, weather_te; gc.collect()","e03f84ba":"tr_te['building_id'] = tr_te['building_id'].astype('int8')\ntr_te['meter'] = tr_te['meter'].astype('int8')\ntr_te['row_id'] = tr_te['row_id'].astype('int32')\ntr_te['timestamp'] = tr_te['timestamp'].astype('int32')\ntr_te['site_id'] = tr_te['site_id'].astype('int8')\ntr_te['primary_use'] = tr_te['primary_use'].astype('int8')\ntr_te['square_feet'] = tr_te['square_feet'].astype('int32')\ntr_te['year_built'] = tr_te['year_built'].astype('float16')\ntr_te['floor_count'] = tr_te['floor_count'].astype('float16')\n\nweather['site_id'] = weather['site_id'].astype('int8')\nweather['timestamp'] = weather['timestamp'].astype('int32')\nweather['air_temperature'] = weather['air_temperature'].astype('float16')\nweather['cloud_coverage'] = weather['cloud_coverage'].astype('float16')\nweather['dew_temperature'] = weather['dew_temperature'].astype('float16')\nweather['precip_depth_1_hr'] = weather['precip_depth_1_hr'].astype('float16')\nweather['sea_level_pressure'] = weather['sea_level_pressure'].astype('float16')\nweather['wind_direction'] = weather['wind_direction'].astype('float16')\nweather['wind_speed'] = weather['wind_speed'].astype('float16')\n\ngc.collect()","fc288e01":"print('Original shape is',tr_te.shape) \ntr_te = tr_te.merge(weather, on=['site_id','timestamp'], how='left')\nprint('Shape after merging is',tr_te.shape) ","053fa4a0":"tr_te.dtypes","46e379fe":"primary_use_to_id","09fafa60":"tr_te.head()","bbc1ab06":"We should be careful that year_built and floor_count have Nulls. This is important for algorithms that don't tolerate Nulls.","694d076d":"Welcome to the EDA. The kernel's title, \u05d0\u05b7\u05e9\u05b0\u05c1\u05e8\u05b5\u05d9, is a joke because there is a Jewish prayer called the \"Ashrei\" which is pronounced the same way as ASHRAE.","e3b13ecc":"Nope. Just an effect of the Kernel Density Estimate.","b4e8605d":"### Let's download weather data and merge","0e371dea":"Indeed, we are seeing meter readings recorded every hour. The organizer noted that there are some gaps as well.","a7935691":"We can see that in the raw files, we are just given the building_id, and the meter type. We are also given the timestamp of the reading. Every building has different meters: one for gas, one for electricity, one for water, etc. The dataset has sampled the readings from these different meters over time. I bet if we group by building_id in the trainset, we will see the building_id comes up multiple times.","528bc3f1":"Wait, is that year_built in the future?","9f6fa361":"Before we can merge, I need to change the data types to be smaller, or else we will get a MemoryError in Kaggle kernels.","9bda5552":"### Let's see how meter_reading may change with respect to square_feet, year_built, and floor_count.","bf3932c8":"### Now let's actually begin some EDA. Let's look at how square_feet, year_built, and floor_count are distributed.","b6d8d3bd":"Before we do that, the timestamp object is really expensive to store in RAM. Let's convert it to cat codes like we did with meta's primary_use.","7190ae85":"### To begin, let's just look at the train and test.","42d326aa":"### Now let's rowbind train and test so we can merge meta onto it all at once.","cc41c1d0":"### Let's use building_metadata.csv to gain more information on these building_id's.","665f7218":"### Let's convert the categorical primary_use into integers to save RAM space."}}