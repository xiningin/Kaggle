{"cell_type":{"9ff30268":"code","b443bbe6":"code","4234ac08":"code","31f858da":"code","369aa02c":"code","7eac2fb2":"code","c1ff4ed0":"code","6e38ab7f":"code","990db182":"code","7109b6bb":"code","d02021d5":"code","cb904fa1":"code","d9450ff6":"code","74b3869b":"code","5fc14f70":"code","c8b7cbe0":"code","1eaf862d":"code","c5e723c6":"code","005de045":"code","73884126":"code","1d08801c":"code","3db2780e":"code","c9591125":"code","e393f5fc":"code","ab171d81":"code","be79a808":"code","a42915fa":"code","10324e6a":"code","6ba42e30":"code","b59ae5a3":"code","3ab41f80":"code","6493d584":"markdown","9d7447ad":"markdown","f90b5ccf":"markdown","0ae27cf3":"markdown","9cf3c34d":"markdown","921be1f9":"markdown","be979ef3":"markdown","e1de0b5e":"markdown","88c82d6f":"markdown","8e6d3cba":"markdown","641c86b5":"markdown","26a7c126":"markdown","45963d96":"markdown","aa2af917":"markdown","4cf708e4":"markdown","50aedaa2":"markdown","1581ce01":"markdown","5ef9b66d":"markdown","ba10d752":"markdown","1c162822":"markdown","be99f0d4":"markdown","72ad7130":"markdown","f5bd9eed":"markdown","5ad99414":"markdown","9dd3719e":"markdown","1aed4e07":"markdown","3cc7a7c9":"markdown","53503062":"markdown","2d059cd2":"markdown","df1cffb6":"markdown","fb037ad3":"markdown"},"source":{"9ff30268":"#global imports\nimport tensorflow as tf\nfrom tensorflow.keras import layers\nfrom tensorflow.keras import models\nfrom tensorflow.keras.utils import to_categorical\nfrom tensorflow.keras import optimizers\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\n\nimport os, shutil\nimport numpy as np\n\nimport warnings\nwarnings.filterwarnings('ignore')","b443bbe6":"x = np.array([14,12,3,41,121])\nprint(\"Dimensions of the tensor is: {0}\".format(x.ndim))","4234ac08":"#getting the data first\nfrom tensorflow.keras.datasets import mnist\n\n(train_images, train_labels), (test_images, test_labels) = mnist.load_data()","31f858da":"#Defining our network architecture\n\nbaseline_nn = models.Sequential()\nbaseline_nn.add(layers.Dense(512, activation='relu', input_shape=(28 * 28,))) #relu = max(n,0)\nbaseline_nn.add(layers.Dense(10, activation='softmax')) #softmax will return a probability score of all the digits\nbaseline_nn.compile(optimizer='rmsprop',\n                loss='categorical_crossentropy',\n                metrics=['accuracy'])\nbaseline_nn.summary()","369aa02c":"#before training,we will create a single feature axes of an image, reshaping all the values in a 1D tensor\ntrain_images = train_images.reshape((60000, 28 * 28))\ntrain_images = train_images.astype('float32') \/ 255\n\ntest_images = test_images.reshape((10000, 28 * 28))\ntest_images = test_images.astype('float32') \/ 255","7eac2fb2":"#One hot encode the train and test labels\ntrain_labels = to_categorical(train_labels)\ntest_labels = to_categorical(test_labels)","c1ff4ed0":"baseline_nn.fit(train_images, train_labels, epochs=5, batch_size=128)","6e38ab7f":"baseline_test_loss, baseline_test_acc = baseline_nn.evaluate(test_images, test_labels)","990db182":"print('BASELINE TEST ACCURACY: {0} \\nBASELINE TEST LOSS: {1}'.format(baseline_test_acc,baseline_test_loss))","7109b6bb":"#Initializing a convnet\n\nbasic_cnn = models.Sequential()\nbasic_cnn.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)))\nbasic_cnn.add(layers.MaxPooling2D((2, 2)))\nbasic_cnn.add(layers.Conv2D(64, (3, 3), activation='relu'))\nbasic_cnn.add(layers.MaxPooling2D((2, 2)))\nbasic_cnn.add(layers.Conv2D(64, (3, 3), activation='relu'))\n\nbasic_cnn.summary()","d02021d5":"#Now let's attach a convnet to a flatten layer to predict outputs\nbasic_cnn.add(layers.Flatten())\nbasic_cnn.add(layers.Dense(64, activation='relu'))\nbasic_cnn.add(layers.Dense(10, activation='softmax'))\n\nbasic_cnn.summary()","cb904fa1":"#To make the input clear, we gotta reformat the input data\n(train_images, train_labels), (test_images, test_labels) = mnist.load_data()\n\ntrain_images = train_images.reshape((60000, 28, 28, 1))\ntrain_images = train_images.astype('float32') \/ 255\n\ntest_images = test_images.reshape((10000, 28, 28, 1))\ntest_images = test_images.astype('float32') \/ 255\n\ntrain_labels = to_categorical(train_labels)\ntest_labels = to_categorical(test_labels)","d9450ff6":"basic_cnn.compile(optimizer='rmsprop',\n              loss='categorical_crossentropy',\n              metrics=['accuracy'])\nbasic_cnn.fit(train_images, train_labels, epochs=5, batch_size=64)","74b3869b":"basic_cnn_test_loss, basic_cnn_test_acc = basic_cnn.evaluate(test_images, test_labels)","5fc14f70":"print('BASIC CNN TEST ACCURACY: {0} \\nBASIC CNN TEST LOSS: {1}'.format(basic_cnn_test_acc,basic_cnn_test_loss))","c8b7cbe0":"basic_cnn_no_max_pool = models.Sequential()\nbasic_cnn_no_max_pool.add(layers.Conv2D(32, (3,3), activation='relu', input_shape=(28,28,1)))\nbasic_cnn_no_max_pool.add(layers.Conv2D(64, (3,3), activation='relu'))\nbasic_cnn_no_max_pool.add(layers.Conv2D(64, (3,3), activation='relu'))\nbasic_cnn_no_max_pool.add(layers.Flatten())\nbasic_cnn_no_max_pool.add(layers.Dense(512, activation='relu'))\nbasic_cnn_no_max_pool.add(layers.Dense(10, activation='softmax'))\nbasic_cnn_no_max_pool.summary()","1eaf862d":"#The path to the directory where the original dataset is stored(uncompressed)\noriginal_dataset_dir = '..\/input\/dogs_cats_original'\n\n#The path to the directory where we will store our smaller dataset\nbase_dir = '..\/dogs_cats_small'\nos.mkdir(base_dir)\n\n#Making directories for training, validating and testing sub-directories\nfor name in ['train', 'validation', 'test']:\n    exec(\"{0}_dir = os.path.join(base_dir,'{1}')\".format(name, name))\n    exec(\"os.mkdir({0}_dir)\".format(name))\n\n#mapper_dictionary\nmapper ={\n    \"train\": (0, 1000),\n    \"validation\": (1000, 1500),\n    \"test\": (1500, 2000)\n}\n\nlabel_mapper = {\n    \"cats\": \"cat\",\n    \"dogs\": \"dog\"\n}\n    \n    \n#Filling directories with cat and dog images\nfor subdirectory in ['train','validation','test']:\n    subdirectory_range = mapper[subdirectory]\n    for label in ['cats','dogs']:\n        exec(\"{0}_{1}_dir = os.path.join({2}_dir,'{3}')\".format(subdirectory, label, subdirectory, label))\n        exec(\"os.mkdir({0}_{1}_dir)\".format(subdirectory, label))\n        \n        fnames = ['{0}.{1}.jpg'.format(label_mapper[label],i) for i in range(subdirectory_range[0], subdirectory_range[1])]\n        for fname in fnames:\n            src = os.path.join(original_dataset_dir, fname)\n            exec(\"dst = os.path.join({0}_{1}_dir, fname)\".format(subdirectory,label))\n            shutil.copy(src, dst)","c5e723c6":"cats_dogs_scratch = models.Sequential()\ncats_dogs_scratch.add(layers.Conv2D(32, (3, 3), activation='relu',input_shape=(150, 150, 3)))\ncats_dogs_scratch.add(layers.MaxPooling2D((2, 2)))\ncats_dogs_scratch.add(layers.Conv2D(64, (3, 3), activation='relu'))\ncats_dogs_scratch.add(layers.MaxPooling2D((2, 2)))\ncats_dogs_scratch.add(layers.Conv2D(128, (3, 3), activation='relu'))\ncats_dogs_scratch.add(layers.MaxPooling2D((2, 2)))\ncats_dogs_scratch.add(layers.Conv2D(128, (3, 3), activation='relu'))\ncats_dogs_scratch.add(layers.MaxPooling2D((2, 2)))\ncats_dogs_scratch.add(layers.Flatten())\ncats_dogs_scratch.add(layers.Dense(512, activation='relu'))\ncats_dogs_scratch.add(layers.Dense(1, activation='sigmoid')) #sigmoid layer as it is a binary classification problem\n\ncats_dogs_scratch.summary()","005de045":"cats_dogs_scratch.compile(loss='binary_crossentropy',\n             optimizer=optimizers.RMSprop(lr=1e-4),\n             metrics=['acc'])","73884126":"#Rescaling images\ntrain_datagen = ImageDataGenerator(rescale=1.\/255)\ntest_datagen = ImageDataGenerator(rescale=1.\/255)\n\ntrain_generator = train_datagen.flow_from_directory(\n    #This is the target directory \n    train_dir,\n    #Resizing the images to 150x150\n    target_size=(150, 150),\n    batch_size=20,\n    #Since we use binary_crossentropy loss, we need binary labels\n    class_mode='binary')\n\nvalidation_generator = test_datagen.flow_from_directory(\n    validation_dir,\n    target_size=(150, 150),\n    batch_size=20,\n    class_mode='binary')","1d08801c":"for data_batch, labels_batch in train_generator:\n    print('data batch shape:', data_batch.shape)\n    print('labels batch shape:', labels_batch.shape)\n    break","3db2780e":"history = cats_dogs_scratch.fit(\n    train_generator,\n    steps_per_epoch=100,\n    epochs=30,\n    validation_data=validation_generator,\n    validation_steps=50)","c9591125":"#Please save model after training unless you want it to be deleted\ncats_dogs_scratch.save(\"cats_and_dogs_scratch.h5\")","e393f5fc":"import matplotlib.pyplot as plt\n\nacc = history.history['acc']\nval_acc = history.history['val_acc']\nloss = history.history['loss']\nval_loss = history.history['val_loss']\n\nepochs = range(len(acc))\n\nplt.plot(epochs,acc,'bo',label='Training acc')\nplt.plot(epochs,val_acc,'b',label=\"Validation acc\")\nplt.title(\"Training and validation accuracy\")\nplt.legend()\n\nplt.figure()\n\nplt.plot(epochs,loss,'bo',label='Training loss')\nplt.plot(epochs,val_loss,'b',label=\"Validation loss\")\nplt.title(\"Training and validation loss\")\nplt.legend()\n\nplt.show()","ab171d81":"datagen = ImageDataGenerator(\n    rotation_range=40,\n    width_shift_range=0.2,\n    height_shift_range=0.2,\n    shear_range=0.2,\n    zoom_range=0.2,\n    horizontal_flip=True,\n    fill_mode='nearest')","be79a808":"# This is module with image preprocessing utilities\nfrom tensorflow.keras.preprocessing import image\n\nfnames = [os.path.join(train_cats_dir, fname) for fname in os.listdir(train_cats_dir)]\n\n# We pick one image to \"augment\"\nimg_path = fnames[3]\n\n# Read the image and resize it\nimg = image.load_img(img_path, target_size=(150, 150))\n\n# Convert it to a Numpy array with shape (150, 150, 3)\nx = image.img_to_array(img)\n\n# Reshape it to (1, 150, 150, 3)\nx = x.reshape((1,) + x.shape)\n\n# The .flow() command below generates batches of randomly transformed images.\n# It will loop indefinitely, so we need to `break` the loop at some point!\ni = 0\nfor batch in datagen.flow(x, batch_size=1):\n    plt.figure(i)\n    imgplot = plt.imshow(image.array_to_img(batch[0]))\n    i += 1\n    if i % 4 == 0:\n        break\n\nplt.show()","a42915fa":"cats_dog_data_aug = models.Sequential()\ncats_dog_data_aug.add(layers.Conv2D(32, (3, 3), activation='relu',\n                       input_shape=(150, 150, 3)))\ncats_dog_data_aug.add(layers.MaxPooling2D((2, 2)))\ncats_dog_data_aug.add(layers.Conv2D(64, (3, 3), activation='relu'))\ncats_dog_data_aug.add(layers.MaxPooling2D((2, 2)))\ncats_dog_data_aug.add(layers.Conv2D(128, (3, 3), activation='relu'))\ncats_dog_data_aug.add(layers.MaxPooling2D((2, 2)))\ncats_dog_data_aug.add(layers.Conv2D(128, (3, 3), activation='relu'))\ncats_dog_data_aug.add(layers.MaxPooling2D((2, 2)))\ncats_dog_data_aug.add(layers.Flatten())\ncats_dog_data_aug.add(layers.Dropout(0.5))\ncats_dog_data_aug.add(layers.Dense(512, activation='relu'))\ncats_dog_data_aug.add(layers.Dense(1, activation='sigmoid'))\n\ncats_dog_data_aug.compile(loss='binary_crossentropy',\n             optimizer=optimizers.RMSprop(lr=1e-4),\n             metrics=['acc'])","10324e6a":"cats_dog_data_aug.summary()","6ba42e30":"#Training our network using the data generator\ntrain_datagen = ImageDataGenerator(\n    rescale=1.\/255,\n    rotation_range=40,\n    width_shift_range=0.2,\n    height_shift_range=0.2,\n    shear_range=0.2,\n    zoom_range=0.2,\n    horizontal_flip=True)\n\n#NOTE: VALIDATION DATA MUST NOT BE AUGMENTED!!\ntest_datagen = ImageDataGenerator(rescale=1.\/255)\n\ntrain_generator = train_datagen.flow_from_directory(\n    train_dir,\n    target_size=(150, 150),\n    batch_size=32,\n    class_mode='binary')\n\nvalidation_generator = test_datagen.flow_from_directory(\n    validation_dir,\n    target_size=(150, 150),\n    batch_size=32,\n    class_mode='binary')\n\nhistory = cats_dog_data_aug.fit(\n    train_generator,\n    steps_per_epoch=100,\n    epochs=100,\n    validation_data=validation_generator,\n    validation_steps=50)","b59ae5a3":"cats_dog_data_aug.save('cats_and_dogs_data_aug.h5')","3ab41f80":"acc = history.history['acc']\nval_acc = history.history['val_acc']\nloss = history.history['loss']\nval_loss = history.history['val_loss']\n\nepochs = range(len(acc))\n\nplt.plot(epochs, acc, 'bo', label='Training acc')\nplt.plot(epochs, val_acc, 'b', label='Validation acc')\nplt.title('Training and validation accuracy')\nplt.legend()\n\nplt.figure()\n\nplt.plot(epochs, loss, 'bo', label='Training loss')\nplt.plot(epochs, val_loss, 'b', label='Validation loss')\nplt.title('Training and validation loss')\nplt.legend()\n\nplt.show()","6493d584":"Compiling the model","9d7447ad":"### <b>Convolution Operations and Feature Maps<\/b>\n\n- Convolutions operate over 3D tensors, called `feature maps`, with `two spatial axes(height and width)` as well as a `depth or channels` axis. For RGB images, the depth axis is 3 because of the 3 colour channels: red,green and blue. For black-and-white images(like MNIST), the depth is 1\n- The convolution operation extracts patches from its input feature map and applies the same transformation to all of these patches, producing `output feature map`. This output feature map <b>is still a 3D tensor: it has width and height, but the depth can be arbitrary<\/b>, because the output depth is a parameter of the layer, and <b>the different channels in the depth axis no longer stand for specific colours, rather they stand for <i>filters<\/i><\/b>\n-Filters encode specific parts of the input data. A single filter could include the concept \"presence of face in the input\"\n-The first convolution layer is taking a feature map of a size `(28,28,1)` and outputs a feature map of size `(26, 26, 32)`: It computes 32 filters over the image. Each of these 32 output channels is of the size `26x26`, which can also be called as the <b>response map<\/b> of the filter over the input image.\n\n#### This is what feature map intuitively means, every dimension in the depth axis is a feature(or <i>filter<\/i>), and the 2D tensor `output[:,:,n]` is the 2D <i>spatial map<\/i> if the response of this filter over the input image\n![cnn_feature_map](https:\/\/i.imgur.com\/h2svNmX.png)","f90b5ccf":"### <b>How Convolution works<\/b>\n\n- A convolution works by <i>sliding<\/i> these windows of size 3x3 or 5x5 over the 3D input feature maps, stopping at every possible location and extracting the 3D patch of the surrounding features. The shape is `(window_height, window_width, input_depth)`.<br\/>\n![convolution_schematic](https:\/\/i.imgur.com\/2ERLjY7.gif)\n\n- Each such 3D patch is then transformed(via tensor product with the weight matrix) into a 1D vector of shape `(output_depth, )`.All of these are then spatially reassembled into a 3D output map of shape `(height, width, output_depth)`.\n\n- <b>NOTE: Every spatial location in the output feature map corresponds to the same location in the input feature map<\/b>\n\n![convolution_transformation](https:\/\/i.imgur.com\/ltkxf5i.png)\n\n- The output width and the height may differ from the input width and height because of 2 reasons:\n    - <i>Border effects<\/i> which can be encountered by padding the input feature map\n    - <i>Strides<\/i>","0ae27cf3":"## <b>Data preprocessing<\/b>\n\nAs you already know by now, data should be formatted into appropriately pre-processed floating point tensors before being fed into our \nnetwork. Currently, our data sits on a drive as JPEG files, so the steps for getting it into our network are roughly:\n\n* Read the picture files.\n* Decode the JPEG content to RBG grids of pixels.\n* Convert these into floating point tensors.\n* Rescale the pixel values (between 0 and 255) to the [0, 1] interval (as you know, neural networks prefer to deal with small input values).\n\nIt may seem a bit daunting, but thankfully Keras has utilities to take care of these steps automatically. Keras has a module with image \nprocessing helper tools, located at `tensorflow.keras.preprocessing.image`. In particular, it contains the class `ImageDataGenerator` which allows to \nquickly set up Python generators that can automatically turn image files on disk into batches of pre-processed tensors. This is what we \nwill use here.","9cf3c34d":"2 things:\n- It is counter intuitive to the spatial hierarchy of features. The `3x3` windows in the third layer will only contain information coming from the `3x3` windows in the initial output. The high level patterns learnt by the convnet will still be very small compared to the initial input(Try recognizing a MNIST image by just looking at 3x3 pixel). <b>We need the features from the last convolution layer to contain information about the totality of the input<\/b>\n- The final feature map has `22x22x64` = 30,976 total coefficients. To get a comparable `Dense` layer we gotta make the Dense layer bigger upto 512. This will result in a total of 15.9 million parameters!! This is far too large and will result in intense overfitting","921be1f9":"## <b>Convolutional Neural Networks<\/b>\n<br\/>![simple_cnn](https:\/\/i.imgur.com\/t0JIbMS.jpg)","be979ef3":"## <b>Using data augmentation to increase accuracy just for computer vision tasks<\/b>\n\nOverfitting is caused by having too few samples to learn from, rendering us unable to train a model able to generalize to new data. \nGiven infinite data, our model would be exposed to every possible aspect of the data distribution at hand: we would never overfit. Data \naugmentation takes the approach of generating more training data from existing training samples, by \"augmenting\" the samples via a number \nof random transformations that yield believable-looking images. The goal is that at training time, our model would never see the exact same \npicture twice. This helps the model get exposed to more aspects of the data and generalize better.\n\nIn `tensorflow.Keras`, this can be done by configuring a number of random transformations to be performed on the images read by our `ImageDataGenerator` \ninstance. Let's get started with an example:","e1de0b5e":"### <b>What is wrong with the above architecture?<\/b>","88c82d6f":"### <b>Border Effects, Padding and Strides<\/b>\n\n- Basic Convolution filter creating an output feature map. It loses a lot of input values. Pass parameter value `valid` for this in keras.model<br\/>\n![no_padding_no_strides](https:\/\/i.imgur.com\/45ZPeGJ.gif)\n\n- If you want to use the output feature map as the same spatial dimension as the input, you use `padding`. Padding consists of adding an apt no of rows and columns on each side of the feature map so as to make it possible to fit center convolution windows around every input tile.\n\n- Some of the examples of padding are:\n    - <b>Full padding<\/b>\n    ![full_padding_no_strides](https:\/\/i.imgur.com\/82gUuLr.gif)\n    - <b>Same padding<\/b>\n    ![same_padding_no_strides](https:\/\/i.imgur.com\/si7XeUH.gif)\n\n- Other factor that can influence output size are `strides`. So far it's assumed that the center tiles of the convolution windows are all contiguous. But the distance between 2 successive windows is a parameter of the convolution, called its `stride`. It is possible to have strided convolution\n<br>\n\n<b>Patches extracted by a 3x3 convolution with stride 2 over a 5x5 input (without padding)<\/b><br\/>\n![convolution_stride](https:\/\/i.imgur.com\/EpoZMN1.png)\n- Furthermore we can also merge padding and strides. Here are some of the examples of padding and strides:\n    - <b>Padding and strides<\/b>\n    ![padding_strides](https:\/\/i.imgur.com\/F8oXcum.gif)\n    - <b>Odd padding and strides<\/b>\n    ![padding_strides_odd](https:\/\/i.imgur.com\/eLdd1iQ.gif)\n\n\nIf we use stride 2 we are basically downsampling the input feature map by a factor of 2(in addition to any changes done by the border effects). But if we want to downsample feature maps, instead of strides we can use the <i>max-pooling<\/i> operation","8e6d3cba":"## <b>Example Session: Cats and Dogs<\/b>","641c86b5":"We will train a CNN on a cats dogs dataset. A binary classification problem where the total dataset size is 25000 images. But to make the challenge harder, we are going to use only 2000 images","26a7c126":"## <b>Different Types of filters and their outputs<\/b>\n## <b>Simple Box Blur<\/b><br\/>\n![simple_blur](https:\/\/i.imgur.com\/lsy7kq9.jpg)\n![simple_blur](https:\/\/i.imgur.com\/xmI6K6C.jpg)\n\n## <b>Edge Detection<\/b><br\/>\n![edge_detection](https:\/\/i.imgur.com\/lccvBzW.jpg)\n![edge_detection](https:\/\/i.imgur.com\/bOQUAYh.jpg)\n\n## <b>The Laplacian of Gaussian<\/b><br\/>\n![edge_detection](https:\/\/i.imgur.com\/aOgQVt2.jpg)\n![edge_detection](https:\/\/i.imgur.com\/VDWcPFn.jpg)","45963d96":"## <b>Tensor<\/b>\n## What is a Tensor?\n- At its core, a tensor is a container for data-almost numeric data. So it's a container for numbers.\n- Matrices are 2D tensors, and tensors can be called a generalization of matrices to an arbitrary number of dimensions\n- NOTE: In context of tensors, a dimension is often called an axis\n\n<b>Different types of tensors<\/b><br\/>![tensor](https:\/\/i.imgur.com\/l66zsJJ.jpg)","aa2af917":"![aug_model_acc](https:\/\/i.imgur.com\/tGxi0WO.png)","4cf708e4":"Let's take a look at the output of one of these generators: it yields batches of 150x150 RGB images (shape `(20, 150, 150, 3)`) and binary \nlabels (shape `(20,)`). 20 is the number of samples in each batch (the batch size). Note that the generator yields these batches \nindefinitely: it just loops endlessly over the images present in the target folder. For this reason, we need to `break` the iteration loop \nat some point.","50aedaa2":"If we train a new network using this data augmentation configuration, our network will never see twice the same input. However, the inputs \nthat it sees are still heavily intercorrelated, since they come from a small number of original images -- we cannot produce new information, \nwe can only remix existing information. As such, this might not be quite enough to completely get rid of overfitting. To further fight \noverfitting, we will also add a Dropout layer to our model, right before the densely-connected classifier:","1581ce01":"`Convnets` have 2 properties which attribute to this key characteristic:\n- `The patterns they learn are translation invariant`. After learning a certain pattern in the lower-right corner of a picture, a convnet can recognize it anywhere. This makes convnets data efficient when processing images(because the <i>visual world is fundamentally translation invarient<\/i>): they need fewer training samples to learn representations that have generalization power\n- `They can learn spatial hierarchies of patterns(see Below)`. A first convolution layer will learn small local patterns such as edges, a second convolution layer will learn longer patterns made of features of the first layers, and so on. This enables convnets to efficiently learn increasingly complex and abstract visual concepts\n\n![cnn_spatial_hierarchy](https:\/\/i.imgur.com\/d2woCA2.png)","5ef9b66d":"Let's fit our model to the data using the generator. We do it using the `fit` method. It expects as first argument a Python generator that will yield batches of inputs and targets indefinitely, like ours does. \nBecause the data is being generated endlessly, the generator needs to know example how many samples to draw from the generator before \ndeclaring an epoch over. This is the role of the `steps_per_epoch` argument: after having drawn `steps_per_epoch` batches from the \ngenerator, i.e. after having run for `steps_per_epoch` gradient descent steps, the fitting process will go to the next epoch. In our case, \nbatches are 20-sample large, so it will take 100 batches until we see our target of 2000 samples.\n\nWhen using `fit`, one may pass a `validation_data` argument. Importantly, this argument is \nallowed to be a data generator itself, but it could be a tuple of Numpy arrays as well. If you pass a generator as `validation_data`, then \nthis generator is expected to yield batches of validation data endlessly, and thus you should also specify the `validation_steps` argument, \nwhich tells the process how many batches to draw from the validation generator for evaluation.","ba10d752":"These are just a few of the options available (for more, see the Keras documentation). Let's quickly go over what we just wrote:\n\n* `rotation_range` is a value in degrees (0-180), a range within which to randomly rotate pictures.\n* `width_shift` and `height_shift` are ranges (as a fraction of total width or height) within which to randomly translate pictures \nvertically or horizontally.\n* `shear_range` is for randomly applying shearing transformations.\n* `zoom_range` is for randomly zooming inside pictures.\n* `horizontal_flip` is for randomly flipping half of the images horizontally -- relevant when there are no assumptions of horizontal \nasymmetry (e.g. real-world pictures).\n* `fill_mode` is the strategy used for filling in newly created pixels, which can appear after a rotation or a width\/height shift.\n\nLet's take a look at our augmented images:","1c162822":"## <b>Building our network<\/b>\n\nWe've already built a small convnet for MNIST in the previous example, so you should be familiar with them. We will reuse the same \ngeneral structure: our convnet will be a stack of alternated `Conv2D` (with `relu` activation) and `MaxPooling2D` layers.\n\nHowever, since we are dealing with bigger images and a more complex problem, we will make our network accordingly larger: it will have one \nmore `Conv2D` + `MaxPooling2D` stage. This serves both to augment the capacity of the network, and to further reduce the size of the \nfeature maps, so that they aren't overly large when we reach the `Flatten` layer. Here, since we start from inputs of size 150x150 (a \nsomewhat arbitrary choice), we end up with feature maps of size 7x7 right before the `Flatten` layer.\n\nNote that the depth of the feature maps is progressively increasing in the network (from 32 to 128), while the size of the feature maps is \ndecreasing (from 148x148 to 7x7). This is a pattern that you will see in almost all convnets.\n\nSince we are attacking a binary classification problem, we are ending the network with a single unit (a `Dense` layer of size 1) and a \n`sigmoid` activation. This unit will encode the probability that the network is looking at one class or the other.","be99f0d4":"Convolutions are defined by 2 key parameters:\n- <i>Size of the patches from the inputs<\/i>: These are typically 3x3 or 5x5\n- <i>Depth of the output feature map<\/i>: The number of filters computed by the convolution","72ad7130":"### <b> Why downsample at all?<\/b>\nLets check with a model with no max pooling","f5bd9eed":"<br>WE JUMPED FROM 97% TO 99% ACCURACY. AN IMPROVEMENT OF 68%(relatively)! Let's see how\n## <b>The Convolution Operation - The reason why CNNs are the champs in Computer Vision<\/b>","5ad99414":"Pointing the plot of loss and accuracy of the model over training and validation data during the training:","9dd3719e":"![convolution](https:\/\/i.imgur.com\/152lxWm.png)","1aed4e07":"<br\/>97% accuracy on a baseline model!! That's a tough one to beat","3cc7a7c9":"## <b>Building a baseline neural network<\/b>\nSo we will build a neural network using just a Dense(also called a fully connected layer) and an activation layer(in this case a softmax) to classify a basic problem like MNIST","53503062":"<br\/>This vector has 5 entries, so it's a 5-dimensional vector. <b>DONT CONFUSE A 5D VECTOR WITH A 5D TENSOR<\/b>. A 5D vector only has a single axis and 5 dimensions along its axis, whereas a 5D tensor has 5 axes and any number of dimensions along each axis. Technically, it's more correct to talk about <i>a tensor of rank 5<\/i>(where rank is the number of axes)","2d059cd2":"#### The fundamental Difference between Dense layer and a Convolution layer is that `Dense` layers learn <b>global<\/b> patterns in their input feature space(all pixels, in an example of a MNIST digit), whereas `Convolution` layers learn <b>local<\/b> patterns.","df1cffb6":"Let's look at the summary of the model","fb037ad3":"### <b>Max Pooling<\/b>\n\nIf you look at the convnet example, the size of the feature maps is halved after every `MaxPooling2D` layer. That's the job of MaxPooling - to aggressively downsample feature maps.\n![basic_cnn_architecture](https:\/\/i.imgur.com\/fU941CN.png)\n\n- Max Pooling consists of extracting windows from the input feature maps and outputting the max value of each channel. It is conceptually similar to the convolution, except that instead of transforming local patches via a learned linear transformation (the <i>convolution<\/i> kernel), they are transformed via a hardcoded `max` tensor operation.<br>\n![max_pooling](https:\/\/i.imgur.com\/gsu9jx6.gif)\n\n- A big difference from convolution is that max pooling is done with `2x2` window with stride 2, in order to downsample the feature maps by a factor of 2. On the other hand the convolution is done with `3x3` window with no stride.\n\n## <b>For an input image with size of i, kernel size of k, padding of p, and stride of s, the output image from convolution has size o:<\/b>\n![convolution_size](https:\/\/i.imgur.com\/qVTrqa3.png)"}}