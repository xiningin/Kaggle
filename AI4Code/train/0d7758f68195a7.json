{"cell_type":{"97e8eceb":"code","2a792169":"code","accf7079":"code","c703675b":"code","3db2c872":"code","6a33bcbd":"code","a73ead2f":"code","19986b41":"code","3868111d":"code","5d39a6cf":"code","7c8817af":"markdown","90ee9554":"markdown","4d82bd41":"markdown","6bd8df7e":"markdown","d52fc8d3":"markdown","18c72e19":"markdown"},"source":{"97e8eceb":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","2a792169":"#import another library and we don't need all of matplotlib, and give it a shorthand name\nimport matplotlib.pyplot as plt\n#state the plot style to be used throughout\nplt.style.use('seaborn')\n\n#create a variable to read the dataframe\ndf = pd.read_csv('..\/input\/acnhvillagers.csv')","accf7079":"#grab only the columns I want to use, assign those to a variable\naboutvillagers = df[['Name', 'Species', 'Gender', 'Personality', 'Birthday', 'Birthmonth', 'Style 1', 'Style 2']]\n#run this new variable\naboutvillagers","c703675b":"#count and graph the number of times different values appear for gender\n#genders aren't distributed equally... pretty interesting\naboutvillagers['Gender'].value_counts().plot(kind='bar')","3db2c872":"#count and graph the number of times different values appear for species\n#kind of interesting to see that there's a few more cat types of villagers\naboutvillagers['Species'].value_counts().plot(kind='bar')","6a33bcbd":"#it's interesting that these are all quite similar except for Big Sister or Smug personality types\naboutvillagers['Personality'].value_counts().plot(kind='bar')","a73ead2f":"#here I'm just trying to see what style types there are and their frequency of occurrence\naboutvillagers['Style 1'].value_counts().plot(kind='bar')","19986b41":"#set the x axis to represent birthDAY data\nx = aboutvillagers[['Birthday']]\n#set the y axis to represent birthMONTH data\ny = aboutvillagers[['Birthmonth']]\n#overlapping this data in a bar graph shows which birthdays are shared by more than one villager\nplt.scatter(x, y, alpha=0.2, color='indigo')","3868111d":"#define what terms to group under either of these variables, to be used below to evaluate likability\npositive_traits = ['Cool', 'Peppy', 'Big Sister', 'Lazy', 'Normal']\nnegative_traits = ['Cranky', 'Snooty', 'Smug', 'Jock']\n\ndef personality_evaluator(personality_type):\n    #if the personality type contains elements from the positive_traits variable\n    if personality_type in positive_traits:\n        #i'm going to categorize these as likable\n        return \"Likable\"\n    #if it contains elements from the negative_traits variable, they must be unlikable\n    elif personality_type in negative_traits:\n        return \"Unlikable\"\n    #otherwise, return an error message\n    else:\n        return \"Something has gone terribly wrong\"\n    \n#plot the data that appears after applying the function from above    \naboutvillagers['Personality'].apply(personality_evaluator).value_counts().plot(kind='pie')","5d39a6cf":"#used the code on this next line to identify all the different types of species listed so that I could add them to their own categories\n#aboutvillagers['Species'].value_counts()\n\n#i want to find a way to assign values to species types and then rank the villagers based on that\n#i created variables to hold lists of animals that I manually assigned, based on observation and subjective analysis of how users interact with villagers\n#it would be really cool to do something like this based on a Twitter analysis or some other sentimental data set\ndocile_animal = ['Cat', 'Rabbit', 'Dog', 'Mouse', 'Horse', 'Pig', 'Bird', 'Chicken', 'Hamster', 'Cow']\ncute_animal = ['Squirrel', 'Duck', 'Cub', 'Deer', 'Koala', 'Bear', 'Sheep', 'Penguin', 'Hippo', 'Rhino', 'Octopus']\nweird_animal = ['Frog', 'Wolf', 'Elephant', 'Ostrich', 'Eagle', 'Gorilla', 'Kangaroo', 'Goat', 'Alligator', 'Anteater', 'Tiger', 'Lion', 'Bull', 'Monkey']\n                \ndef animal_type(species):\n    #if the species contains elements from the docile_animal variable\n    if species in docile_animal:\n        #i'm going to categorize these as likable\n        return \"These are often kept as pets\"\n    #if it contains elements from the cute_animal variable (these are often the more popular characters among users)\n    elif species in cute_animal:\n        return \"These ones are adorable and we love them\"\n    #if it doesn't fall into household pet or cute animal territory, it's weird\n    elif species in weird_animal:\n        return \"These ones are WEIRD\"\n    #otherwise, return an error message\n    else:\n        return \"Something has gone terribly wrong\"\n    \n#create a variable to refer to all the villager species names\nwords = ['Cat', 'Rabbit', 'Dog', 'Mouse', 'Horse', 'Pig', 'Bird', 'Chicken', 'Hamster', 'Cow', 'Squirrel', 'Duck', 'Cub', 'Deer', 'Koala', 'Bear', 'Sheep', 'Penguin', 'Hippo', 'Rhino', 'Octopus', 'Frog', 'Wolf', 'Elephant', 'Ostrich', 'Eagle', 'Gorilla', 'Kangaroo', 'Goat', 'Alligator', 'Anteater', 'Tiger', 'Lion', 'Bull', 'Monkey']\n\n#create a place to house the first letter of each villagers name\n#i will refer back to this list within the \"borrowed code\" section\nfirst_char_list = []\n#for every word\nfor everyword in words:\n    #add the first character of that \n    first_char_list.append(everyword[0])\n\n#make data: I have a few groups and a bunch of subgroups but I don't want to manually list them, so I'm converting them to lists automatically\ngroup_names = ['These are often kept as pets', 'These ones are adorable and we love them', 'These ones are WEIRD']\n#this grabs the information I categorized with the animal_type function, counts it, and converts it to a list\ngroup_size = aboutvillagers['Species'].apply(animal_type).value_counts(sort=True).tolist()\nsubgroup_names = ['Cat', 'Rabbit', 'Dog', 'Mouse', 'Horse', 'Pig', 'Bird', 'Chicken', 'Hamster', 'Cow', 'Squirrel', 'Duck', 'Cub', 'Deer', 'Koala', 'Bear', 'Sheep', 'Penguin', 'Hippo', 'Rhino', 'Octopus', 'Frog', 'Wolf', 'Elephant', 'Ostrich', 'Eagle', 'Gorilla', 'Kangaroo', 'Goat', 'Alligator', 'Anteater', 'Tiger', 'Lion', 'Bull', 'Monkey']\n#these are the coresponding numbers for each subgroup size\nsubgroup_size = [23, 20, 16, 15, 15, 15, 13, 9, 8, 4, 18, 17, 16, 10, 9 , 15, 13, 13, 7, 6, 3, 18, 11, 11, 10, 9, 9, 8, 8, 7, 7, 7, 7, 6, 8]\n\n\n\n\n#START - BORROWED CODE\n#almost all of the code below (modified in some places) this is borrowed from https:\/\/python-graph-gallery.com\/163-donut-plot-with-subgroups\n#my own work is above this section\n\n#create colors\ncmap = plt.get_cmap(\"tab20c\")\nouter_colors = cmap(np.arange(3)*4)\ninner_colors = cmap(np.array([1, 2, 5, 6, 9, 10]))\n \n#first ring (outside)\nfig, ax = plt.subplots()\nax.axis('equal')\nmypie, _ = ax.pie(group_size, radius=1.3, labels=group_names, colors=outer_colors)\nplt.setp(mypie, width=0.3, edgecolor='white')\n \n#second ring (inside)\n#the labels for this will be shortened versions, since the regular names showed up messy\nmypie2, _ = ax.pie(subgroup_size, radius=1.3-0.3, labels=first_char_list, labeldistance=0.7, colors=inner_colors)\nplt.setp(mypie2, width=0.4, edgecolor='white')\nplt.margins(0,0)\n\n#added a legend \nplt.legend()\n#this creates a connection between colors in the chart and the legend\nhandles, labels = ax.get_legend_handles_labels()\n\n#the legend will show proper subgroup names\n#aligned location slightly further to the right of the pie chart\nax.set_axis_off()\nax.legend(handles[3:], words, loc=(1.2, -0.3))\n#END - BORROWED CODE","7c8817af":"Below is a snapshot of the simplified dataset that I'll be focusing on, which includes only the data (columns) that I'm interested in analyzing.","90ee9554":"# **Analyzing patterns in Animal Crossing: New Horizon's Villagers personalities**\n\nI chose this dataset because I've been playing a lot of Animal Crossing lately, and it's been interesting to observe the relationships users are building with their villagers. As villagers hold quite a bit of data under their identities, I figured it would be fun to find out what patterns exist between commonly liked villagers, or what the other lesser-known traits can tell us about the villagers we have on our islands.","4d82bd41":"# **Familiarizing myself with the data**\n\nI started this evaluation by doing some quick counts of everything. The following are just for my own reference. My goal here was to observe what patterns seemed interesting or worth further investigation.","6bd8df7e":"# **Visualization #1**\n\nFor this first one, I made a visualization to observe where different birthday\/birthmonth data points overlap to show which characters have birthdays on the same day, and which days villagers don't have birthdays at all. This required a bit of set-up prior to adding the dataset, as the dataset I had showed the birthday in different formatting. I added an extra column in Excel, copied the data into the next cell, and changed the cell format to show only \"dd\" in one and \"mm\" in the other. \n\nBy using a scatter plot with lighter opacity, I was able to see that the darker points are where the dots overlap, which is where birthdays occur on the same day for more than one villager. This may not be the traditional use of a scatter plot graph, but I thought it'd be a fun way to observe patterns in calendar dates.","d52fc8d3":"# **Visualization #2**\n\nIn this, I evaluated two different variables to include qualities popularly seen as like-able or not. For example, many \"Snooty\" characters are disliked by users whereas \"Big Sister\" types are seen in a desirable light (based on my subjective observation). Then, I created a function to evaluate the dataset for these different traits, and to mark each villager as either \"Likable\" or \"Unlikable\". This was consequently graphed in a pie chart view to show how many villagers are one type versus the other. \n\nIt appears there are a few more unlikable villagers than those that are likable, which might explain some questions about the rarity of the more likable villagers.","18c72e19":"# **Visualization #3**\n\nHere, I tried to experiment with counting and showing two sets of data in a nested pie chart. I got a little carried away with this... this is basically the product of a few different explorations. I tried to create a function to do one thing (exploring species) and it didn't give me the visualization I wanted, but it led me to create a different type of visualization altogether with the subgroups.\n\nThe first set of data is the categorization of animal types, and the second set of data is the count of each animal type. This is intended to show the different kind of data I've analyzed, what animals I grouped into which categories, and which of those animals were found most often within their subgroup. \n\nHowever, it doesn't do this yet.\n\nOne thing I really struggled with was getting the edges of the first data set to align with the second. This is still unresolved, as I did a lot of troubleshooting, but couldn't figure out why my inner ring is showing disproportionately. What I mean by that is the \"These are often kept as pets\" bar should hold the animals from Cat through Cow. However, the smaller bars do not align with the larger bar as they should. "}}