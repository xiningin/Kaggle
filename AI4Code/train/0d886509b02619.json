{"cell_type":{"4ab5ebdb":"code","00f93553":"code","bf28653e":"code","28caae01":"code","fe881079":"code","d9dd5255":"code","2300b144":"code","10b5fe18":"code","f814ffbf":"code","cff3b7c1":"code","83367763":"code","24913b42":"code","1b0b5f62":"code","361037e8":"code","1faefc13":"code","88226ce0":"code","2c6d8a7b":"code","f27c88a2":"code","bd39920c":"code","b31e520d":"markdown","79db1eca":"markdown","a374622b":"markdown","45f312df":"markdown","6453903f":"markdown","269c7948":"markdown","4f0d5fa5":"markdown","7b2fe41c":"markdown","d46c4e5a":"markdown","a31dafdd":"markdown","87dbde6d":"markdown","21ad10d6":"markdown"},"source":{"4ab5ebdb":"\n#data preprocessing\nimport pandas as pd\n#math operations\nimport numpy as np\n#machine learning\n\nfrom sklearn.preprocessing import StandardScaler\n#hyperparameter optimization\nfrom sklearn.model_selection import GridSearchCV\n#support vector machine model\nfrom keras import regularizers\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nimport os\nimport cv2\nimport keras\nfrom keras.utils import np_utils\nfrom keras.models import Sequential\nfrom keras.layers import Conv2D,MaxPooling2D,Dense,Flatten,Dropout\n            \nfrom random import shuffle\nfrom tqdm import tqdm  \nimport scipy\nimport skimage\nfrom skimage.transform import resize\nimport random","00f93553":"data=[]\nlabels=[]\nParasitized=os.listdir(\"..\/input\/cell_images\/cell_images\/Parasitized\/\")\nfor a in Parasitized:\n    try:\n        image=cv2.imread(\"..\/input\/cell_images\/cell_images\/Parasitized\/\"+a)\n        image_from_array = Image.fromarray(image, 'RGB')\n        size_image = image_from_array.resize((50, 50))\n        data.append(np.array(size_image))\n        labels.append(0)\n    except AttributeError:\n        print(\"\")\n\nUninfected=os.listdir(\"..\/input\/cell_images\/cell_images\/Uninfected\/\")\nfor b in Uninfected:\n    try:\n        image=cv2.imread(\"..\/input\/cell_images\/cell_images\/Uninfected\/\"+b)\n        image_from_array = Image.fromarray(image, 'RGB')\n        size_image = image_from_array.resize((50, 50))\n        data.append(np.array(size_image))\n        labels.append(1)\n    except AttributeError:\n        print(\"\")","bf28653e":"Cells=np.array(data)\nlabels=np.array(labels)","28caae01":"np.save(\"Cells\",Cells)\nnp.save(\"labels\",labels)","fe881079":"Cells=np.load(\"Cells.npy\")\nlabels=np.load(\"labels.npy\")","d9dd5255":"s=np.arange(Cells.shape[0])\nnp.random.shuffle(s)\nCells=Cells[s]\nlabels=labels[s]","2300b144":"num_classes=len(np.unique(labels))\nlen_data=len(Cells)\n","10b5fe18":"(x_train,x_test)=Cells[(int)(0.1*len_data):],Cells[:(int)(0.1*len_data)]\nx_train = x_train.astype('float32')\/255 # As we are working on image data we are normalizing data by divinding 255.\nx_test = x_test.astype('float32')\/255\ntrain_len=len(x_train)\ntest_len=len(x_test)","f814ffbf":"(y_train,y_test)=labels[(int)(0.1*len_data):],labels[:(int)(0.1*len_data)]","cff3b7c1":"#Doing One hot encoding as classifier has multiple classes\ny_train=keras.utils.to_categorical(y_train,num_classes)\ny_test=keras.utils.to_categorical(y_test,num_classes)","83367763":"#creating sequential model\nmodel=Sequential()\nmodel.add(Conv2D(filters=16,kernel_size=2,padding=\"same\",activation=\"relu\",input_shape=(50,50,3)))\nmodel.add(MaxPooling2D(pool_size=2))\nmodel.add(Conv2D(filters=32,kernel_size=2,padding=\"same\",activation=\"relu\"))\nmodel.add(MaxPooling2D(pool_size=2))\nmodel.add(Conv2D(filters=64,kernel_size=2,padding=\"same\",activation=\"relu\"))\nmodel.add(MaxPooling2D(pool_size=2))\nmodel.add(Flatten())\n#l2 regularizer\nmodel.add(Dense(500,kernel_regularizer=regularizers.l2(0.01),activation=\"relu\"))\nmodel.add(Dense(2,activation=\"softmax\"))#2 represent output layer neurons \n","24913b42":"#creating sequential model\nmodel=Sequential()\nmodel.add(Conv2D(filters=16,kernel_size=2,padding=\"same\",activation=\"relu\",input_shape=(50,50,3)))\nmodel.add(MaxPooling2D(pool_size=2))\nmodel.add(Conv2D(filters=32,kernel_size=2,padding=\"same\",activation=\"relu\"))\nmodel.add(MaxPooling2D(pool_size=2))\nmodel.add(Conv2D(filters=64,kernel_size=2,padding=\"same\",activation=\"relu\"))\nmodel.add(MaxPooling2D(pool_size=2))\n# 1st dropout\nmodel.add(Dropout(0.2))\nmodel.add(Flatten())\nmodel.add(Dense(500,activation=\"relu\"))\n# 2nd dropout\nmodel.add(Dropout(0.2))\nmodel.add(Dense(2,activation=\"softmax\"))#2 represent output layer neurons \n","1b0b5f62":"from keras.preprocessing.image import ImageDataGenerator\n\ndatagen = ImageDataGenerator(\n        featurewise_center=False,  # set input mean to 0 over the dataset\n        samplewise_center=False,  # set each sample mean to 0\n        featurewise_std_normalization=False,  # divide inputs by std of the dataset\n        samplewise_std_normalization=False,  # divide each input by its std\n        zca_whitening=False,  # apply ZCA whitening\n        rotation_range=10,  # randomly rotate images in the range (degrees, 0 to 180)\n        zoom_range = 0.1, # Randomly zoom image \n        width_shift_range=0.1,  # randomly shift images horizontally (fraction of total width)\n        height_shift_range=0.1,  # randomly shift images vertically (fraction of total height)\n        horizontal_flip=False,  # randomly flip images\n        vertical_flip=False)  # randomly flip images\n\ndatagen.fit(x_train)","361037e8":"from keras.callbacks import EarlyStopping\nearlystop= EarlyStopping(monitor='val_acc', patience=3)\nepochs = 20 # \nbatch_size = 256","1faefc13":"#creating sequential model\nmodel=Sequential()\nmodel.add(Conv2D(filters=16,kernel_size=2,padding=\"same\",activation=\"relu\",input_shape=(50,50,3)))\nmodel.add(MaxPooling2D(pool_size=2))\nmodel.add(Conv2D(filters=32,kernel_size=2,padding=\"same\",activation=\"relu\"))\nmodel.add(MaxPooling2D(pool_size=2))\nmodel.add(Conv2D(filters=64,kernel_size=2,padding=\"same\",activation=\"relu\"))\nmodel.add(MaxPooling2D(pool_size=2))\n# 1st dropout\nmodel.add(Dropout(0.2))\nmodel.add(Flatten())\n#l2 regularizer\nmodel.add(Dense(500,kernel_regularizer=regularizers.l2(0.01),activation=\"relu\"))\n# 2nd dropout\nmodel.add(Dropout(0.2))\nmodel.add(Dense(2,activation=\"softmax\"))#2 represent output layer neurons \nmodel.summary()\n","88226ce0":"# Compiling model\n# compile the model with loss as categorical_crossentropy and using adam optimizer you can test result by trying RMSProp as well as Momentum\nmodel.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])","2c6d8a7b":"# Fit the model\nhistory = model.fit_generator(datagen.flow(x_train,y_train, batch_size=batch_size),\n                              epochs = epochs, validation_data = (x_test,y_test),\n                              verbose = 1, steps_per_epoch=x_train.shape[0] \/\/ batch_size\n                              , callbacks=[earlystop])","f27c88a2":"from sklearn.metrics import confusion_matrix\npred = model.predict(x_test)\npred = np.argmax(pred,axis = 1) \ny_true = np.argmax(y_test,axis = 1)","bd39920c":"CM = confusion_matrix(y_true, pred)\nfrom mlxtend.plotting import plot_confusion_matrix\nfig, ax = plot_confusion_matrix(conf_mat=CM ,  figsize=(5, 5))\nplt.show()","b31e520d":"# Dropout\nThis is the one of the most interesting types of regularization techniques. It also produces very good results and is consequently the most frequently used regularization technique in the field of deep learning.\n\nTo understand dropout, let\u2019s say our neural network structure is akin to the one shown below:\n![](https:\/\/i.ibb.co\/G3PgsRs\/d1.png)\n\nSo what does dropout do? At every iteration, it randomly selects some nodes and removes them along with all of their incoming and outgoing connections as shown below.\n\n![](https:\/\/i.ibb.co\/4pdnr5r\/d2.png)\n\nSo each iteration has a different set of nodes and this results in a different set of outputs. **It can also be thought of as an ensemble technique in machine learning.**\n\nEnsemble models usually perform better than a single model as they capture more randomness. Similarly, dropout also performs better than a normal neural network model.\n\nThis probability of choosing how many nodes should be dropped is the hyperparameter of the dropout function. As seen in the image above, dropout can be applied to both the hidden layers as well as the input layers.\n\n![](https:\/\/i.ibb.co\/KydYCbp\/d3.gif)\n\nDue to these reasons, dropout is usually preferred when we have a large neural network structure in order to introduce more **randomness.**\n\nIn keras, we can implement dropout using the **keras  layer**. Below is the Dropout Implementation.\nI have introduced dropout of 0.2  as the probability of dropping in my neural network architecture after last hidden layer having 64 kernels and after first dense layer having 500 neurons.\n\n\n\n","79db1eca":"# Implementation on Malaria Cell Identification with keras\nBy this point, you should have a theoretical understanding of the different techniques we have gone through. We will now apply this knowledge to our deep learning practice problem \u2013 Identify Malaria cell. \nIn this problem I will use all the regularization techniques which I have discussed earlier i.e., \n1. L1,L2 Regularizer\n2. Dropout\n3. Data Augmentation\n4. Early Stopping\nNow Let's start firing bullets !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!","a374622b":"# Please hit Upvote if you really like this kernel.","45f312df":"One of the most common problem data science professionals face is to avoid **overfitting**. Have you come across a situation where your model performed exceptionally well on train data, but was not able to predict test data. Or you were on the top of a competition in public leaderboard, only to fall hundreds of places in the final rankings? Well \u2013 this is the kernel for you!.\n\n# Table of Contents\n1. What is Regularization?\n2. How does Regularization help in reducing Overfitting?\n3. Different Regularization techniques in Deep Learning\n    - L2 and L1 regularization\n    - Dropout\n    - Data augmentation\n    - Early stopping\n\n","6453903f":"# Different Regularization Techniques in Deep Learning\n\nNow that we have an understanding of how regularization helps in reducing overfitting, we\u2019ll learn a few different techniques in order to apply regularization in deep learning.\n\n## L2 & L1 regularization\n\nL1 and L2 are the most common types of regularization. These update the general cost function by adding another term known as the regularization term.\n\n### Cost function = Loss (say, binary cross entropy) + Regularization term\n\nDue to the addition of this regularization term, the values of weight matrices decrease because it assumes that a neural network with smaller weight matrices leads to simpler models. Therefore, it will also reduce overfitting to quite an extent.\n\nHowever, this regularization term differs in L1 and L2.\n\nIn L2, we have:\n![L2](https:\/\/i.ibb.co\/b3Dp6mL\/L2.png)\n\nHere, **lambda** is the regularization parameter. It is the hyperparameter whose value is optimized for better results. L2 regularization is also known as weight decay as it forces the weights to decay towards zero (but not exactly zero).\n\nIn L1, we have:\n\n![L2](https:\/\/i.ibb.co\/zZBJrgB\/l1.png)\n\nIn this, we penalize the absolute value of the weights. Unlike L2, the weights may be reduced to zero here. **Hence, it is very useful when we are trying to compress our model. Otherwise, we usually prefer L2 over it.**\n\nIn keras, we can directly apply regularization to any layer using the regularizers.\nBelow I have applied regularizer on dense layer having 500 neurons and relu activation function.","269c7948":"Here, **monitor** denotes the quantity that needs to be monitored and **\u2018val_err\u2019** denotes the validation error.\n\n**Patience** denotes the number of epochs with no further improvement after which the training will be stopped. For better understanding, let\u2019s take a look at the above image again. After the dotted line, each epoch will result in a higher value of validation error. Therefore, 5 epochs after the dotted line (since our patience is equal to 3), our model will stop because no further improvement is seen.\n\n**Note: It may be possible that after 3 epochs (this is the value defined for patience in general), the model starts improving again and the validation error starts decreasing as well. Therefore, we need to take extra care while tuning this hyperparameter.**","4f0d5fa5":"**Note: Here the value 0.01 is the value of regularization parameter, i.e., lambda, which we need to optimize further. We can optimize it using the grid-search method.**\n\nSimilarly, we can also apply L1 regularization.","7b2fe41c":"# Early stopping\nEarly stopping is a kind of cross-validation strategy where we keep one part of the training set as the validation set. When we see that the performance on the validation set is getting worse, we immediately stop the training on the model. This is known as **early stopping.**\n\n![](https:\/\/i.ibb.co\/CmJpR3R\/early.png)\nIn the above image, we will stop training at the dotted line since after that our model will start overfitting on the training data.\n\nIn keras, we can apply early stopping using the **callbacks** function. Below is the implementation code for it.I have applied early stopping so that it will stop immendiately if validation error will not decreased after 3 epochs.","d46c4e5a":"### !!! Great we achived 95.10% validation accuracy","a31dafdd":"# What is Regularization?\nBefore we deep dive into the topic, take a look at this image:\n![](https:\/\/i.ibb.co\/g35FMM5\/over.png)\nHave you seen this image before? As we move towards the right in this image, our model tries to learn too well the details and the noise from the training data, which ultimately results in poor performance on the unseen data.\n\nIn other words, while going towards the right, the complexity of the model increases such that the training error reduces but the testing error doesn\u2019t. This is shown in the image below.\n![](https:\/\/i.ibb.co\/0cygV4y\/Screen-Shot-2018-04-04-at-2-43-37-PM-768x592.png)\n\nIf you\u2019ve built a neural network before, you know how complex they are. This makes them more prone to overfitting.\n\n**Regularization** is a technique which makes slight modifications to the learning algorithm such that the model generalizes better. This in turn improves the model\u2019s performance on the unseen data as well.\n\n# How does Regularization help reduce Overfitting?\n\nLet\u2019s consider a neural network which is overfitting on the training data.\n![](https:\/\/i.ibb.co\/gmRzQtr\/over-fitting.png)\nIf you have studied the concept of regularization in machine learning, you will have a fair idea that **regularization penalizes the coefficients. In deep learning, it actually penalizes the weight matrices of the nodes.**\n\nAssume that our regularization coefficient is so high that some of the weight matrices are nearly equal to zero.\nThis will result in a much simpler linear network and slight underfitting of the training data.\n\nSuch a large value of the regularization coefficient is not that useful. We need to optimize the value of regularization coefficient in order to obtain a well-fitted model as shown in the image below.\n![](https:\/\/i.ibb.co\/CKBYWFK\/under.png)","87dbde6d":"# Data Augmentation\nThe simplest way to reduce overfitting is to increase the size of the training data. In machine learning, we were not able to increase the size of training data as the labeled data was too costly.\n\nBut, now let\u2019s consider we are dealing with images. In this case, there are a few ways of increasing the size of the training data \u2013 rotating the image, flipping, scaling, shifting, etc. In the below image, some transformation has been done on the handwritten digits dataset.\n![](https:\/\/i.ibb.co\/rd4FpW6\/aug.png)\n\nThis technique is known as **data augmentation**. This usually provides a big leap in improving the accuracy of the model. It can be considered as a mandatory trick in order to improve our predictions.\n\nIn keras, we can perform all of these transformations using **ImageDataGenerator**. It has a big list of arguments which you you can use to pre-process your training data.\n\nBelow is the implementation code.","21ad10d6":"Now plot confusion matrix"}}