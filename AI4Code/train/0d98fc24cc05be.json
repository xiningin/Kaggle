{"cell_type":{"861b09ce":"code","37505365":"code","596f4f6b":"code","da44dbf7":"code","d040e425":"code","d7009ca4":"code","970302e0":"code","322b72f0":"markdown"},"source":{"861b09ce":"!pip install 'kaggle-environments>=0.1.6'","37505365":"%%writefile mysubmission.py\nfrom __future__ import division\nimport random\nimport itertools\n\nbeat = {'R': 'P', 'P': 'S', 'S': 'R'}\n_map = ['R', 'P', 'S']\n_remap = {'R': 0, 'P': 1, 'S': 2}\n\nclass MarkovChain():\n\n    def __init__(self, order, decay=1.0):\n        self.decay = decay\n        self.matrix = self.create_matrix(order)\n\n    @staticmethod\n    def create_matrix(order):\n\n        def create_keys(order):\n            keys = ['R', 'P', 'S']\n            for i in range((order * 2 - 1)):\n                key_len = len(keys)\n                for i in itertools.product(keys, ''.join(keys)):\n                    keys.append(''.join(i))\n                keys = keys[key_len:]\n            return keys\n\n        keys = create_keys(order)\n        matrix = {}\n        for key in keys:\n            matrix[key] = {\n                'R': {'prob' : 1 \/ 3, 'n_obs' : 0 },\n                'P': {'prob' : 1 \/ 3, 'n_obs' : 0 },\n                'S': {'prob' : 1 \/ 3, 'n_obs' : 0 }\n            }\n        return matrix\n\n\n    def update_matrix(self, pair, input):\n        for i in self.matrix[pair]:\n            self.matrix[pair][i]['n_obs'] = self.decay * self.matrix[pair][i]['n_obs']\n\n        self.matrix[pair][input]['n_obs'] = self.matrix[pair][input]['n_obs'] + 1\n        \n        n_total = 0\n        for i in self.matrix[pair]:\n            n_total += self.matrix[pair][i]['n_obs']\n\n        for i in self.matrix[pair]:\n            self.matrix[pair][i]['prob'] = self.matrix[pair][i]['n_obs'] \/ n_total\n        \n        \n    def predict(self, pair):\n        probs = self.matrix[pair]\n        probs_items = {}\n        for x in probs.items():\n            probs_items[x[0]] = x[1]['prob']\n        max_value = max(probs_items.values())\n        min_value = min(probs_items.values())\n        if max_value == min_value:\n            return random.choice(['R', 'P', 'S'])\n        else:\n            max_keys = [k for k, v in probs_items.items() if v == max_value]\n            return random.choice(max_keys)\n\npair_diff2 = ''\npair_diff1 = ''\nmarkov_model = MarkovChain(1, 0.9)\nlast_output = random.choice(['R','P','S'])\n\ndef my_agent(observation, configuration):\n    global pair_diff1\n    global pair_diff2\n    global markov_model\n    global last_output\n\n    if observation.step > 0:\n        lastOpp = _map[int(observation.lastOpponentAction)]\n        pair_diff2 = pair_diff1\n        pair_diff1 = last_output + lastOpp\n    if pair_diff2 != '':\n        markov_model.update_matrix(pair_diff2, lastOpp)\n        output = beat[markov_model.predict(pair_diff1)]\n    else:\n        output = random.choice(['R','P','S'])\n        \n    last_output = output\n    \n    return int(_remap[output])","596f4f6b":"from kaggle_environments import evaluate, make, utils\nenv = make(\"rps\", debug=True)\nenv.render()","da44dbf7":"env.reset()\nenv.run([\"mysubmission.py\", \"reactionary\"])\nenv.render(mode=\"ipython\", width=500, height=500)","d040e425":"env.reset()\nenv.run([\"mysubmission.py\", \"copy_opponent\"])\nenv.render(mode=\"ipython\", width=500, height=500)","d7009ca4":"env.reset()\nenv.run([\"mysubmission.py\", \"counter_reactionary\"])\nenv.render(mode=\"ipython\", width=500, height=500)","970302e0":"env.reset()\nenv.run([\"mysubmission.py\", \"statistical\"])\nenv.render(mode=\"ipython\", width=500, height=500)","322b72f0":"This notebook is based on [How to win over 70% matches in Rock Paper Scissors](https:\/\/towardsdatascience.com\/how-to-win-over-70-matches-in-rock-paper-scissors-3e17e67e0dab)"}}