{"cell_type":{"f9985577":"code","1fa6d75e":"code","9ca5cd2b":"code","e1c17faf":"code","f3708678":"code","ea5a8da2":"code","4dc172d5":"code","4f225a5e":"code","28de7067":"code","6fdbce19":"code","fa9a3bc4":"code","fd187395":"code","f556ee12":"code","13954ce9":"code","07f58c70":"code","c80dfd41":"code","87a45c69":"code","8bf59d5c":"code","71d9bb52":"code","4b5b1f2d":"code","73560871":"code","ef2061fd":"code","40bfb347":"code","303b15cc":"code","3d79fba8":"code","4daf0204":"code","7880693d":"code","77d23a32":"code","546c19e8":"code","2f6a9326":"code","876572f7":"code","5c296b1f":"code","ffc03508":"code","bea1176b":"code","fad6d600":"code","48b42a17":"code","db891bf7":"code","1e0775cf":"code","12cda740":"code","ace1e0a5":"code","c78eb4ea":"code","424affe6":"code","ac960dfd":"code","715fd508":"code","8d71007e":"code","37ef5f99":"code","165df775":"markdown","bae684aa":"markdown","087d7c53":"markdown","d11d73df":"markdown","4b6deea0":"markdown","d0dad1fc":"markdown","c92ceef4":"markdown","29f1251c":"markdown","c1ef64a4":"markdown","dc091dee":"markdown","40301784":"markdown","9e47a7c4":"markdown","609045ab":"markdown","71ac813c":"markdown","d1645a73":"markdown","0660caf5":"markdown","f89eadf8":"markdown","2a8109f1":"markdown","5b5499c7":"markdown","caa25b82":"markdown","38d7de3b":"markdown","252ea13c":"markdown","af8114df":"markdown","6bbce0be":"markdown","a6d141bf":"markdown"},"source":{"f9985577":"# installing TensorFLow Version 2.3.1\nfrom IPython.display import clear_output\n!pip install -q tensorflow==2.3.1\nclear_output()","1fa6d75e":"# install tensorflow quantum\n!pip install -q tensorflow_quantum\nclear_output()","9ca5cd2b":"#install cirq\n!pip install cirq\nclear_output()","e1c17faf":"import tensorflow as tf\n\n# Data Processing tools\nimport numpy as np\nfrom sklearn.model_selection import train_test_split \n\n# QML tools\nimport tensorflow_quantum as tfq\nimport cirq\nimport sympy\n\n# Visualization Tools\nfrom cirq.contrib.svg import SVGCircuit\nimport matplotlib.pyplot as plt","f3708678":"#Lets print the version of cirq and tfq that we will use\nprint(\"We are using the TensorFlow-Quantum version {}\".format(tfq.__version__))\nprint(\"We are using the Cirq version {}\".format(cirq.__version__))","ea5a8da2":"#importing the Fashion MNIST dataset from keras\nfrom tensorflow.keras.datasets import fashion_mnist as dataset","4dc172d5":"(X_train, y_train), (X_test, y_test) = dataset.load_data()","4f225a5e":"print(\"The shape of the X_train is {}\".format( X_train.shape))\nprint(\"The shape of the y_train is {}\".format(y_train.shape))\nprint(\"The shape of the X_test is {}\".format(X_test.shape))\nprint(\"The shape of the y_test is {}\".format(y_test.shape))","28de7067":"def filter_data(x, y):\n  \"\"\"\n  Helper Function to filter the dataset\n  \"\"\"\n  #filter the data using labels\n  keep = (y == 5) | (y == 9)\n  x, y = x[keep], y[keep]\n\n  # convert labels to boolean\n  # y = True if y==5\n  # y = False if y==9\n  y = y == 5\n  return x,y","6fdbce19":"#Filter the train set\nX_train, y_train = filter_data(X_train, y_train)\n\n#Filter the test_set\nX_test, y_test = filter_data(X_test, y_test)","fa9a3bc4":"# Let's have a look at the shapes of train and test data\nprint(\"The shape of the X_train is {}\".format( X_train.shape))\nprint(\"The shape of the y_train is {}\".format(y_train.shape))\nprint(\"The shape of the X_test is {}\".format(X_test.shape))\nprint(\"The shape of the y_test is {}\".format(y_test.shape))","fd187395":"#Let's have a look at the first image from our X_train and the \n# corresponding label from y_train\nprint(\"The First Image has the label {}\".format(y_train[0]))\nplt.imshow(X_train[0])\nplt.colorbar()\nplt.title('Visualization of the Dataset')\nplt.show()","f556ee12":"#Normalizing the train and test image data\nX_train = X_train\/255.0\nX_test = X_test\/ 255.0","13954ce9":"#Let's again have a look at the first image from our X_train and\n#see if we have successfully normalized the datasets\nplt.imshow(X_train[0])\nplt.colorbar()\nplt.title('Visualization of the Dataset')\nplt.show()","07f58c70":"#Before proceeding, we need to reshape our images in the dataset\nX_train = X_train.reshape(X_train.shape[0], *(28,28,1))\nX_test = X_test.reshape(X_test.shape[0], *(28,28,1))","c80dfd41":"# Downscaling the images\nX_train = tf.image.resize(X_train, (2,2)).numpy()\nX_test = tf.image.resize(X_test, (2,2)).numpy()\n","87a45c69":"#Let's again have a look at the first image from our resized X_train\nplt.imshow(X_train[0,:,:,0])\nplt.colorbar()\nplt.title('Visualization of the Resized Dataset')\nplt.show()","8bf59d5c":"#Splitting the training fdataset into train and validation datasets\nX_train, X_valid, y_train, y_valid = train_test_split(X_train, y_train, test_size = 0.15, random_state=0)","71d9bb52":"print(\"The shape of the X_train is {}\".format(X_train.shape))\nprint(\"The shape of the y_train is {}\".format(y_train.shape))\nprint(\"The shape of the X_valid is {}\".format(X_valid.shape))\nprint(\"The shape of the y_valid is {}\".format(y_valid.shape))","4b5b1f2d":"# FLattening the images\nX_train = X_train.reshape(X_train.shape[0], *(1,4,1))\nX_valid = X_valid.reshape(X_valid.shape[0], *(1,4,1))\nX_test = X_test.reshape(X_test.shape[0], *(1,4,1))","73560871":"#Let's have a look on the first example\nprint(X_train[0])","ef2061fd":"\ndef binary_encode(X,threshold=0.5):\n  \"\"\"\n  Encodes the given datset to use binary encoding\n\n  Parameters:\n  X(array) : Image data to be processed for encoding\n  threshold(float): Threshold for binary encoding, 0.5 by default\n\n  Returns:\n  encoded_images(array): Binary encoded Image Data\n\n  \"\"\" \n  encoded_images = list()\n  for image in X:\n    # pixel value is 1 if it's greater than threshold or else zero\n    encoded_image = [1 if j>threshold else 0 for j in image[0]]\n    encoded_images.append(encoded_image)\n  return np.array(encoded_images)","40bfb347":"X_train = binary_encode(X_train)","303b15cc":"# Now, Let's have a look on the first example again\nprint(X_train[0])","3d79fba8":"print(\"The shape of the X_train is {}\".format(X_train.shape))","4daf0204":"def create_circuit_from_image(encoded_image):\n  \"\"\"\n  Returns a circuit for given encoded image\n\n  Parameters:\n  encoded_image (array): Encoded Image\n\n  Returns:\n  circuit (cirq.Circuit object): cirq circuit\n  \"\"\"\n  qubits = cirq.GridQubit.rect(2,2)\n  circuit = cirq.Circuit()\n  for i, pixel in enumerate(encoded_image):\n    if pixel:\n      circuit.append(cirq.X(qubits[i]))\n  return circuit","7880693d":"X_train = [create_circuit_from_image(encoded_image) for encoded_image in X_train]","77d23a32":"# Let's have a look at the circuit for the first image\nprint(X_train[0])","546c19e8":"X_train_tfq = tfq.convert_to_tensor(X_train)","2f6a9326":"X_valid = binary_encode(X_valid)\nX_test = binary_encode(X_test)","876572f7":"X_valid = [create_circuit_from_image(encoded_image) for encoded_image in X_valid]\nX_test = [create_circuit_from_image(encoded_image) for encoded_image in X_test]","5c296b1f":"X_valid_tfq = tfq.convert_to_tensor(X_valid)\nX_test_tfq = tfq.convert_to_tensor(X_test)","ffc03508":"class QNN():\n    def __init__(self, data_qubits, readout):\n      self.data_qubits = data_qubits\n      self.readout = readout\n\n    def add_singleQubit_gate(self,circuit, gate, qubit_index):\n      \"\"\"\n      Adds single qubit gate to the circuit\n      Parameters:\n      circuit(cirq.Circuit object): Cirq circuit\n      gate(cirq gate): gate to append to the circuit\n      qubits(list): index of qubits to apply the gate \n      Returns:\n      None\n      \"\"\"\n      for index in qubit_index:\n        circuit.append(gate(self.data_qubits[index]))\n\n    def add_twoQubit_gate(self,circuit, gate, qubit_index):\n      \"\"\"\n      Adds two qubit gate to the circuit\n      Parameters:\n      circuit(cirq.Circuit object): Cirq circuit\n      gate(cirq gate): gate to append to the circuit\n      qubits(list): index of qubits to apply the gate\n      Returns:\n      None\n      \"\"\"\n      if len(qubit_index)!=2:\n        raise Exception(\"The length of the list of indices passed for two qubit \\\n        gate operations must be equal to two\")\n      circuit.append(gate(self.data_qubits[qubit_index[0]], self.data_qubits[qubit_index[1]]))\n\n    def add_layer(self, circuit, gate, symbol_gate):\n      \"\"\"\n      Adds New Gates\/Layers to the Circuit\n      Parameters:\n      circuit(cirq.Circuit object): Cirq circuit\n      gate(cirq gate): gate to append to the circuit\n      symbol_gate(string): symbol for the gate\n      Returns:\n      None\n      \"\"\"\n      for i, qubit in enumerate(self.data_qubits):\n        symbol = sympy.Symbol(symbol_gate+ '-' + str(i))\n        circuit.append(gate(qubit, self.readout)**symbol)\n","bea1176b":"def create_qnn():\n    \"\"\"Create a QNN model circuit and readout operation to go along with it.\"\"\"\n    data_qubits = cirq.GridQubit.rect(2,2)  # a 4x4 grid.\n    readout = cirq.GridQubit(-1, -1)         # a single qubit at [-1,-1]\n    circuit = cirq.Circuit()\n\n    # Prepare the readout qubit.\n    circuit.append(cirq.X(readout))\n    circuit.append(cirq.H(readout))\n\n    qnn = QNN(\n        data_qubits = data_qubits,\n        readout=readout)\n    \n    \"\"\"\n    # Though we don't use single and double Qubit Gates in our Circuit, we provide \n    # the methods \"add_singleQubit_gate\" and \"add_twoQubit_gate\" for our Class QNN\n    # that can be used to add Single and Double Qubit Gates respectively.\n    # An exmaple is shown below:\n\n    #Add Hadamard Gates\n    qnn.add_singleQubit_gate(circuit, cirq.H, [0,1,2,3])\n\n    #Add CNOT gates\n    qnn.add_twoQubit_gate(circuit, cirq.CNOT, [0, 1])\n    qnn.add_twoQubit_gate(circuit, cirq.CNOT, [2, 3])\n    \"\"\"\n\n    # Add the ising coupling XX gate\n    qnn.add_layer(circuit, cirq.XX, \"xx\")\n    qnn.add_layer(circuit, cirq.ZZ, \"zz\")\n\n    # Finally, prepare the readout qubit.\n    circuit.append(cirq.H(readout))\n\n    return circuit, cirq.Z(readout)","fad6d600":"qmodel, model_readout = create_qnn()","48b42a17":"#Let's have a look at our Qauntum Circuit that will perform the classification\nSVGCircuit(qmodel)","db891bf7":"model = tf.keras.Sequential([\n                             \n    # The input is the data-circuit, encoded as a tf.string\n    tf.keras.layers.Input(shape=(), dtype=tf.string),\n\n    \n    # The PQC stands for Paramaterized Quantum Circuit\n    # This returns the expectation value\n    tfq.layers.PQC(qmodel, model_readout),\n])","1e0775cf":"# To use Hinge Loss, we convert the labels to 1 and -1\ny_train_h = np.array([1 if i==1 else -1 for i in y_train ])\ny_valid_h = np.array([1 if i==1 else -1 for i in y_valid ])\ny_test_h = np.array([1 if i==1 else -1 for i in y_test ])","12cda740":"# Let's have a look at the first label from the training dataset\nprint(y_train_h[0])","ace1e0a5":"# Define the custom Hinge Accuracy\ndef hinge_accuracy(y_true, y_pred):\n    y_true = tf.squeeze(y_true) > 0.0\n    y_pred = tf.squeeze(y_pred) > 0.0\n    result = tf.cast(y_true == y_pred, tf.float32)\n\n    return tf.reduce_mean(result)","c78eb4ea":"model.compile(\n    loss=tf.keras.losses.Hinge(),\n    optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),\n    metrics=[hinge_accuracy])","424affe6":"qnn_history = model.fit(\n      X_train_tfq, y_train_h,\n      batch_size=64,\n      epochs=10,\n      verbose=1,\n      validation_data=(X_valid_tfq, y_valid_h))","ac960dfd":"model.evaluate(X_test_tfq, y_test_h)","715fd508":"# Visualize Accuracy\nplt.plot(qnn_history.history['hinge_accuracy'])\nplt.plot(qnn_history.history['val_hinge_accuracy'])\nplt.title('Model Accuracy')\nplt.xlabel('Epoch')\nplt.ylabel('Accuracy')\nplt.legend(['train','test'],loc=\"best\")\nplt.show()","8d71007e":"# Visualize Loss\nplt.plot(qnn_history.history['loss'])\nplt.plot(qnn_history.history['val_loss'])\nplt.title('Model Loss')\nplt.xlabel('Epoch')\nplt.ylabel('Loss')\nplt.legend(['train','test'],loc=\"best\")\nplt.show()","37ef5f99":"#Saving the weights\nmodel.save_weights('\/content\/sample_data\/QModelWeights')","165df775":"## Refernces","bae684aa":"Steps involved in Data Encoding:\n\n* Processing pixel values for binary encoding\n\n* Converting Cirq Circuits to tfq tensors","087d7c53":"Recall that the values for the first image were 0,0,1,1. This implies that we should apply X or NOT gate the last two qubuts since all the qubits are intially in the 0 states. Applying a X gate will change this state from zero to one. Therefore, we shall apply X Gate on the last two qubits. We have initialized the four qubits in a rectangular grid. Therefore, the initialized qubits are (0,0), (0,1), (1,0) and (1,1). In the above circuit diagram, note that we have a X gate on the qubits (1,0) and (1,1) which are the last two qubits. Hence, we have successfully created circuit for our image. ","d11d73df":"## Installing required packages","4b6deea0":"## Save The Model Weights","d0dad1fc":"### Processing X_valid and X_test","c92ceef4":"From the colorbar in the above visualization, it is clear that we have grayscale images in the dataset and hence their values range from 0 to 255. However, we would like to scale these pixel values in our dataset so that the values range from 0 to 1. This will help us to converge our CNN training faster","29f1251c":"### Build the QNN","c1ef64a4":"Today's(NISQ Era) Quantum Computer are not very powerful and have various limitations. Also, the field of Quantum Machine Learning is currently evolving. To keep things simple, we will modify the Fashion MNIST dataset by making classification on only two classes - Sandal and Ankle boot. The reason to choose these classes is that they are similar to each other and therefore, it ascertains that the classification problem doesn't become very easy. The image shape in the provided dataset is (28,28), but we need to downscale the images to classify them using QML due to the hardware restrictions. We will downscale the images so that they have the shape (4,4).","dc091dee":"## Visualize the Results","40301784":"**Step 2: Converting Cirq Circuits to tfq Tensors**","9e47a7c4":"We shall perform QML on Fashion MNIST dataset using TensorFLow Quantum and Cirq. \n\n[TensorFlow-Quantum](https:\/\/www.tensorflow.org\/quantum\/tutorials) is a great place to start learning QML and get into this amazing field. TensorFlow Quantum (TFQ) is a quantum machine learning library for rapid prototyping of hybrid quantum-classical ML models.TensorFlow Quantum focuses on quantum data and building hybrid quantum-classical models. It integrates quantum computing algorithms and logic designed in Cirq, and provides quantum computing primitives compatible with existing TensorFlow APIs, along with high-performance quantum circuit simulators. \n\n[Cirq](https:\/\/quantumai.google\/cirq) is a Python software library for writing, manipulating, and optimizing quantum circuits, and then running them on quantum computers and quantum simulators. Cirq provides useful abstractions for dealing with today\u2019s noisy intermediate-scale quantum computers, where details of the hardware are vital to achieving state-of-the-art results.","609045ab":"## Importing the dataset and required packages","71ac813c":"## Preprocessing the Dataset","d1645a73":"The original MNIST dataset contains a lot of handwritten digits. People from AI\/ML\/Data Science community love this dataset and use it as a benchmark to validate their algorithms. In fact, MNIST is often the first dataset they would try on. ***\u201cIf it doesn\u2019t work on MNIST, it won\u2019t work at all\u201d***, they said. ***\u201cWell, if it does work on MNIST, it may still fail on others.\u201d*** Fashion-MNIST is intended to serve as a direct drop-in replacement for the original MNIST dataset to benchmark machine learning algorithms, as it shares the same image size and the structure of training and testing splits.","0660caf5":"### Train the QNN","f89eadf8":"Number of Images in the Train Dataset - 10200\n\nNumber of Images in the Validation Dataset - 1800\n\nNumber of Images in the Test Dataset - 2000\n\nSize of each Image - (2,2)\n\nType of Image - Grayscale Image\n\nNumber of Labels - 2\n\n\n~~~\nLabel\tDescription\n5\t    Sandal\n9\t    Ankle boot\n~~~","2a8109f1":"# Image Classification on Fashion MNIST with TensorFlow-Quantum and Cirq","5b5499c7":"**Step 1: Processing Pixel Values for Binary Encoding**","caa25b82":"## Quantum Neural Network","38d7de3b":"## Data Encoding","252ea13c":"Building the Quantum Neural Network involves two steps\n\n* build a class that adds gates layer by layer\n\n* define the QNN using the class from the above step","af8114df":"### Processing X_train","6bbce0be":"## About the Dataset and QML","a6d141bf":"* https:\/\/www.tensorflow.org\/quantum\/tutorials\/mnist\n* https:\/\/quantumai.google\/cirq\/tutorials\n* [Paper by Farhi et al.](https:\/\/arxiv.org\/pdf\/1802.06002.pdf)\n* [Paper by Dmitri Maslov](https:\/\/www.google.com\/url?sa=t&source=web&rct=j&url=https:\/\/arxiv.org\/pdf\/1603.07678&ved=2ahUKEwi86KbBlfvuAhUmzDgGHfteCIsQFjAJegQIHhAC&usg=AOvVaw04beRgWLMZhYBV6GpyygHF)"}}