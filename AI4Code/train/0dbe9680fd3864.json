{"cell_type":{"4c65b8b2":"code","75b34c68":"code","2601993b":"code","20241bde":"code","776d5d66":"code","c3d8e9bf":"code","5f7c9bdb":"code","ec9856f1":"code","8c79ad32":"markdown"},"source":{"4c65b8b2":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\n# for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#     for filename in filenames:\n#         print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","75b34c68":"import keras\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nimport os\nfrom  keras.preprocessing.image import *","2601993b":"no_dir = '\/kaggle\/input\/brain-mri-images-for-brain-tumor-detection\/no'\nyes_dir = '\/kaggle\/input\/brain-mri-images-for-brain-tumor-detection\/yes'","20241bde":"img_to_array(load_img(os.path.join(no_dir , os.listdir(no_dir)[5]))).shape","776d5d66":"dst = pd.DataFrame()\ndst['answer'] = ['1'] * len(os.listdir(yes_dir)) + ['0'] * len(os.listdir(no_dir))\n\nsns.countplot(x='answer', data=dst)","c3d8e9bf":"plt.figure(figsize=(15, 15))\nplt.subplot(4, 4, 1)\nplt.imshow(load_img(os.path.join(yes_dir , os.listdir(yes_dir)[0])))\nplt.title('yes')\nplt.subplot(4, 4, 2)\nplt.imshow(load_img(os.path.join(yes_dir , os.listdir(yes_dir)[1])))\nplt.title('yes')\n\nplt.subplot(4, 4, 3)\nplt.imshow(load_img(os.path.join(yes_dir , os.listdir(yes_dir)[2])))\nplt.title('yes')\n\nplt.subplot(4, 4, 4)\nplt.imshow(load_img(os.path.join(yes_dir , os.listdir(yes_dir)[3])))\nplt.title('yes')\n\nplt.subplot(4, 4, 5)\nplt.imshow(load_img(os.path.join(yes_dir , os.listdir(yes_dir)[4])))\nplt.title('yes')\n\nplt.subplot(4, 4, 6)\nplt.imshow(load_img(os.path.join(yes_dir , os.listdir(yes_dir)[5])))\nplt.title('yes')\n\nplt.subplot(4, 4, 7)\nplt.imshow(load_img(os.path.join(yes_dir , os.listdir(yes_dir)[6])))\nplt.title('yes')\n\nplt.subplot(4, 4, 8)\nplt.imshow(load_img(os.path.join(yes_dir , os.listdir(yes_dir)[7])))\nplt.title('no')\n\nplt.subplot(4, 4, 9)\nplt.imshow(load_img(os.path.join(no_dir , os.listdir(no_dir)[0])))\nplt.title('no')\nplt.subplot(4, 4, 10)\nplt.imshow(load_img(os.path.join(no_dir , os.listdir(no_dir)[1])))\nplt.title('no')\n\nplt.subplot(4, 4, 11)\nplt.imshow(load_img(os.path.join(no_dir , os.listdir(no_dir)[2])))\nplt.title('no')\n\nplt.subplot(4, 4, 12)\nplt.imshow(load_img(os.path.join(no_dir , os.listdir(no_dir)[3])))\nplt.title('no')\n\nplt.subplot(4, 4, 13)\nplt.imshow(load_img(os.path.join(no_dir , os.listdir(no_dir)[4])))\nplt.title('no')\n\nplt.subplot(4, 4, 14)\nplt.imshow(load_img(os.path.join(no_dir , os.listdir(no_dir)[5])))\nplt.title('no')\n\nplt.subplot(4, 4, 15)\nplt.imshow(load_img(os.path.join(no_dir , os.listdir(no_dir)[6])))\nplt.title('no')\n\nplt.subplot(4, 4, 16)\nplt.imshow(load_img(os.path.join(no_dir , os.listdir(no_dir)[7])))\nplt.title('no')\nplt.show()","5f7c9bdb":"base_dir = '..\/input\/brain-mri-images-for-brain-tumor-detection\/brain_tumor_dataset'\n\ndatagen = ImageDataGenerator(rescale=1\/255,\n                             rotation_range=20,\n                             horizontal_flip=True,\n                             height_shift_range=0.1,\n                             width_shift_range=0.1,\n                             shear_range=0.1,\n                             brightness_range=[0.3, 1.5],\n                             validation_split=0.2\n                            )\n\ntrain_gen= datagen.flow_from_directory(base_dir,\n                                       target_size=(224,224),\n                                       class_mode='binary',\n                                       subset='training'\n                                      )\nval_gen = datagen.flow_from_directory( base_dir,\n                                       target_size=(224,224),\n                                       class_mode='binary',\n                                       subset='validation'\n                                      )","ec9856f1":"from keras.models import *\nfrom keras.layers import *\n\nfrom keras.applications import VGG16\n\nVGG = VGG16(\n    weights = 'imagenet',\n    include_top = False,\n    input_shape = (224,224, 3)\n)\n\nVGG.trainable = False\nmodel = Sequential()\nmodel.add(VGG)\nmodel.add(Flatten())\nmodel.add(Dense(128, activation = 'relu'))\nmodel.add(Dropout(0.2))\nmodel.add(BatchNormalization())\nmodel.add(Dense(1, activation = 'sigmoid'))\n\nmodel.compile(loss = 'binary_crossentropy', metrics = ['accuracy'])\n\n\nhistory = model.fit(\n    train_gen,\n    epochs = 20,\n    batch_size = 32,\n    validation_data = val_gen\n)\n\nplt.figure(figsize=(15, 15))\n\nplt.subplot(2,2, 1)\nsns.lineplot(data = history.history, x = range(20), y = 'val_accuracy')\nsns.lineplot(data = history.history, x = range(20), y = 'accuracy')\nplt.legend()\n\nplt.subplot(2,2, 2)\nsns.lineplot(data = history.history, x = range(20), y = 'val_loss')\nsns.lineplot(data = history.history, x = range(20), y = 'loss')\nplt.legend()\n\nfrom keras import optimizers\n\nVGG.trainable = True\nset_trainable = False\n\nfor layer in VGG.layers:\n    if layer.name == 'block5_conv1':\n        set_trainable = True\n    if set_trainable:\n        layer.trainable = True\n    else:\n        layer.trainable = False\n\nfrom keras import optimizers\n\nmodel.compile(\n    optimizer = optimizers.RMSprop(lr = 1e-5),\n    loss = 'binary_crossentropy',\n    metrics= ['accuracy']\n)\n\nhistory = model.fit(\n    train_gen,\n    batch_size = 20,\n    epochs = 30,\n    validation_data = val_gen\n)\n\nplt.subplot(2,2, 3)\nsns.lineplot(data = history.history, x = range(30), y = 'val_accuracy')\nsns.lineplot(data = history.history, x = range(30), y = 'accuracy')\nplt.legend()\n\nplt.subplot(2,2, 4)\nsns.lineplot(data = history.history, x = range(30), y = 'val_loss')\nsns.lineplot(data = history.history, x = range(30), y = 'loss')\nplt.legend()","8c79ad32":"it's realy small dataset and our network just can't train and show us cool results cause I use ready_made solution VGG16"}}