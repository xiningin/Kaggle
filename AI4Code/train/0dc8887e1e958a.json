{"cell_type":{"f9c803a3":"code","d2d0b725":"code","5ce974fb":"code","aab6090f":"code","b890ed82":"code","d729bcb3":"code","a9afdbae":"code","3f82f734":"code","cee3d796":"code","8ecbad57":"code","2869fa02":"code","c34f2fbb":"code","2ffd6093":"code","71f6b3ab":"code","9daf2eb9":"code","f0659321":"code","b3a7e246":"code","c8830340":"markdown","f4bc6d46":"markdown","6aa50a96":"markdown","383ebd88":"markdown","112dee87":"markdown","0d5006c7":"markdown"},"source":{"f9c803a3":"# Load libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\n\n%matplotlib inline\nsns.set()\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","d2d0b725":"train_df = pd.read_csv('..\/input\/train_V2.csv')\ntest_df  = pd.read_csv('..\/input\/test_V2.csv')\n\nsubmission_df = pd.DataFrame()\nsubmission_df['Id'] = test_df[\"Id\"].copy()","5ce974fb":"train_df.info()","aab6090f":"def null_percentage(column):\n    df_name = column.name\n    nans = np.count_nonzero(column.isnull().values)\n    total = column.size\n    frac = nans \/ total\n    perc = int(frac * 100)\n    print('%d%% or %d missing values from [ %s ] column.' % (perc, nans, df_name))\n\ndef check_nan(df):\n    columns = df.columns\n    for col in columns: null_percentage(df[col])","b890ed82":"check_nan(train_df)","d729bcb3":"# Just one missing value exists, DROP it.\ntrain_df = train_df.dropna()\ntrain_df.reset_index(drop=True)\ntrain_df.describe().T","a9afdbae":"# Drop columns\ntrain_df2 = train_df.drop(columns=['Id', 'groupId', 'matchId'])\ntest_df2 = test_df.drop(columns=['Id', 'groupId', 'matchId'])","3f82f734":"corr_df = train_df2.drop(columns=['matchType'])","cee3d796":"_, ax = plt.subplots(figsize=(20, 20))\nsns.heatmap(corr_df.corr(), annot=True, linewidths=.5, fmt= '.1f',ax=ax)","8ecbad57":"corr_matrix = corr_df.corr().abs()\n\n# Select upper triangle of correlation matrix\nupper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(np.bool))\n\n# Find index of feature columns with correlation greater than 0.95\nto_drop = [column for column in upper.columns if any(upper[column] > 0.95)]","2869fa02":"train_df3 = train_df2.drop(to_drop, axis=1)\ntest_df3 = test_df2.drop(to_drop, axis=1)","c34f2fbb":"from sklearn.preprocessing import LabelEncoder\n\nle = LabelEncoder()\ntrain_df3['matchType'] = le.fit_transform(train_df3['matchType'].astype(str))\ntest_df3['matchType'] = le.fit_transform(test_df3['matchType'].astype(str))","2ffd6093":"# Split training dataset into train\/validation set (ratio = 7:3)\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_absolute_error\n\nX = train_df3.iloc[:, 0:-1]; y = train_df3.iloc[:, -1]\nX_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.3, random_state=1040941203)","71f6b3ab":"from catboost import CatBoostRegressor\n\ncbr = CatBoostRegressor(iterations=1000,\n                        learning_rate=0.05,\n                        depth=16,\n                        loss_function='MAE',\n                        eval_metric='MAE',\n                        bootstrap_type='Bayesian',\n                        random_seed = 1040941203,\n                        bagging_temperature = 0.4,\n                        od_type='Iter',\n                        od_wait=10,\n                        use_best_model=True,\n                        rsm = 0.2)","9daf2eb9":"cbr.fit(X_train, y_train,\n        eval_set=(X_val, y_val),\n        cat_features=[X_train.columns.get_loc('matchType')],\n        use_best_model=True,\n        verbose=True)","f0659321":"y_pred_cbr = cbr.predict(test_df3)","b3a7e246":"submission_df['winPlacePerc'] = y_pred_cbr\nsubmission_df.to_csv('submission_cbr.csv', index=False)","c8830340":"### * Imputing Data","f4bc6d46":"# Preprocessing Data","6aa50a96":"### * Constructing Models","383ebd88":"### * Encoding Data","112dee87":"### * Reomving highly correlated features","0d5006c7":"# Importing Data"}}