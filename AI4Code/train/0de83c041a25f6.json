{"cell_type":{"c28f0218":"code","6630e7d4":"code","93a0e603":"code","4bd9d5dd":"code","27ee8d3a":"code","caf72eda":"code","9325d3ba":"code","90bdfbb7":"code","de9229ef":"code","06775aa9":"code","600cb994":"code","d7687ee6":"code","1b7d3038":"code","32a13b76":"code","d9bdda47":"code","43b4968e":"code","d8831af8":"code","db5f48b9":"code","4c958951":"code","5ec18380":"code","3e047252":"markdown","b97767fe":"markdown","394b2536":"markdown","b31c37db":"markdown","9e358158":"markdown","82218899":"markdown"},"source":{"c28f0218":"# Adding imports that will be used\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# The following code takes all files in the given directory and print the paths of the files\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","6630e7d4":"from IPython.core.debugger import set_trace","93a0e603":"# Definition of the tuples that will be read from the input files. These tuples of three positions represent the item index, its value and its weight\nimport sys\nimport csv\ncsv.field_size_limit(sys.maxsize)\nfrom collections import namedtuple\nItem = namedtuple(\"Item\", ['index', 'value', 'weight'])","4bd9d5dd":"# This method checks that the solution is a valid solution. It is that the selected list of items does not weight more than the knapsack capacity\ndef check_solution(capacity, items, taken):\n    weight = 0\n    value = 0\n    for item in items:\n        if taken[item.index]== 1:\n            weight += item.weight\n            value += item.value\n    if weight> capacity:\n        print(\"soluci\u00f3n incorrecta, se supera la capacidad de la mochila (capacity, weight):\", capacity, weight)\n        return 0\n    return value","27ee8d3a":"def from_data_to_items(input_data):\n    lines = input_data.split('\\n')\n\n    firstLine = lines[0].split()\n    item_count = int(firstLine[0])\n    capacity = int(firstLine[1])\n\n    items = []\n\n    for i in range(1, item_count+1):\n        line = lines[i]\n        parts = line.split()\n        items.append(Item(i-1, int(parts[0]), int(parts[1])))\n    \n    return items, capacity","caf72eda":"class_example =\"\"\"3 10\n        45 5\n        48 8\n        35 3\n        \"\"\"","9325d3ba":"items, capacity = from_data_to_items(class_example)","90bdfbb7":"items","de9229ef":"from pprint import pformat\n\nclass Node:\n    def __init__(self, index, path, value, room):\n        self.index = index\n        self.path = path\n        self.value = value\n        self.room = room\n        \n    def __repr__(self):\n        return pformat(vars(self))\n        \n    def estimate(self, items):\n        return self.value + sum(item.value for item in items[self.index:])","06775aa9":"def solve_branch_and_bound(items, capacity):\n    root_node = Node(0, [], 0, capacity)\n    alive = []\n    alive.append(root_node)\n    \n    best_value = 0\n    \n    while (len(alive)>0):\n        current = alive.pop()\n            \n        current_estimate = current.estimate(items)\n        \n        if current_estimate <= best_value:\n            continue\n        \n        if current.value > best_value:\n            best_value = current.value\n            best = current\n        \n        if current.index >= len(items):\n            continue\n            \n        right_node = Node(current.index+1, current.path.copy(), current.value, current.room)\n        alive.append(right_node)\n        \n        enough_room = current.room-items[current.index].weight\n        if enough_room>0:\n            left_path = current.path.copy()\n            left_path.append(current.index) #xi =0\n            left_node = Node(current.index+1, \n                         left_path, \n                         current.value + items[current.index].value,\n                         enough_room)\n            alive.append(left_node)\n        \n        \n    taken = [0]*len(items)\n        \n    for i in best.path:\n        taken[items[i].index]= 1\n            \n        \n    return best_value, taken","600cb994":"def solve_naive(items, capacity):\n    # a trivial greedy algorithm for filling the knapsack\n    # it takes items in-order until the knapsack is full\n    value = 0\n    weight = 0\n    taken = [0]*len(items)\n\n    for item in items:\n        if weight + item.weight <= capacity:\n            taken[item.index] = 1\n            value += item.value\n            weight += item.weight\n            \n    return value, taken\n    ","d7687ee6":"from nose.tools import *","1b7d3038":"def test_solution_taken():\n    capacity = 10\n    items = [Item(index=0, value=45, weight=5),\n                                 Item(index=1, value=48, weight=8),\n                                 Item(index=2, value=35, weight=3)]\n\n    value, taken = solve_branch_and_bound(items, capacity)\n    assert_equal(taken, [1, 0, 1])","32a13b76":"test_solution_taken()","d9bdda47":"# This function takes input data that describes a specific problem of TSP and solve it\ndef solve_it(input_data):\n    # Modify this code to run your optimization algorithm\n    # parse the input\n    \n    items, capacity = from_data_to_items(input_data)\n    \n    #value, taken = solve_naive(items, capacity)\n    \n    value, taken = solve_branch_and_bound(items, capacity)\n            \n    # prepare the solution in the specified output format\n    output_data = str(value) + ' ' + str(0) + '\\n'\n    output_data += ' '.join(map(str, taken))\n    return output_data, check_solution(capacity, items, taken)","43b4968e":"# For each input file, solve_it is called and the result serialized in the ouputs for kaggle and moodle\nstr_output_kaggle = [[\"Filename\",\"Max_value\"]]\nstr_output_moodle = [[\"Filename\",\"Max_value\", \"Solution\"]]\n\nfilter_filenames = ['ks_19_0']\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        if filename in filter_filenames:\n            full_name = dirname+'\/'+filename\n            with open(full_name, 'r') as input_data_file:\n                input_data = input_data_file.read()\n                output, value = solve_it(input_data)\n                print(full_name, value)\n                str_output_kaggle.append([filename,str(value)])\n                str_output_moodle.append([filename,str(value), output.split('\\n')[1]])","d8831af8":"output","db5f48b9":"from IPython.display import FileLink\ndef submission_generation(filename, str_output):\n    os.chdir(r'\/kaggle\/working')\n    with open(filename, 'w', newline='') as file:\n        writer = csv.writer(file)\n        for item in str_output:\n            writer.writerow(item)\n    return  FileLink(filename)","4c958951":"submission_generation('NAME_starter_kaggle.csv', str_output_kaggle)","5ec18380":"# The file generated by this method must be uploaded in the task of the \"campus virtual\". The file to upload in the \"campus virtual\" must be the one related to one submitted to Kaggle. That is, both submitted files must be generated in the same run\nsubmission_generation('NAME_starter_moodle.csv', str_output_moodle)","3e047252":"![imagen.png](attachment:imagen.png)","b97767fe":"ks_19_0: '12248 0\\n0 0 1 0 0 1 0 1 0 0 0 0 1 1 0 0 0 0 0'**","394b2536":"![imagen.png](attachment:imagen.png)","b31c37db":"Ejemplo de definici\u00f3n de test de unidad en Jupyter, a diferencia de pyCharm, donde us\u00e1bamos 'import unittest', en Jupyter vamos a usar nose.\n\nEn Jupyter, n\u00f3tese la diferencia entre *self.assertEqual(...)* en pyCharm y '*assert_equal(...)*'","9e358158":"![imagen.png](attachment:imagen.png)","82218899":"![imagen.png](attachment:imagen.png)"}}