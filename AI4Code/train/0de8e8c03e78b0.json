{"cell_type":{"c52bc26b":"code","ad4fefeb":"code","ec77d35a":"code","c05f926f":"code","18caeb90":"code","d0a03ca4":"code","89aa15ad":"code","23e78ce0":"code","96a5dc6d":"code","4c18c24f":"code","5544c370":"code","85e1c696":"code","04f88587":"code","65fcb11d":"markdown","ff86af7d":"markdown","84b92509":"markdown","a0eec4d0":"markdown","2a5d0231":"markdown","f569b3b9":"markdown","3bfa6174":"markdown","dcb45c05":"markdown","0ad6152a":"markdown","4d4b13aa":"markdown"},"source":{"c52bc26b":"import sys\nimport numpy as np\nimport pandas as pd\nfrom joblib import Parallel, delayed\nimport matplotlib.pyplot as plt\n\nfrom sklearn.model_selection import GridSearchCV\nfrom scipy.optimize import curve_fit","ad4fefeb":"df_train = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-4\/train.csv', parse_dates=['Date'])\ndf_train = df_train.replace(np.nan, '', regex=True) # replace nan in Province_State with empty string\nagg_unit = ['Country_Region', 'Province_State'] # an argument of the groupby method\n\ndf_pops = pd.read_csv('\/kaggle\/input\/population-by-country-2020\/population_by_country_2020.csv')\npops = dict(zip(df_pops['Country (or dependency)'], df_pops['Population (2020)']))\npops['US'] = pops['United States']\npops['Korea, South'] = pops['South Korea']\npops['Congo (Brazzaville)'] = pops['DR Congo']\npops['Congo (Kinshasa)'] = pops['DR Congo']\npops['Taiwan*'] = pops['Taiwan']\npops['Saint Vincent and the Grenadines'] = pops['St. Vincent & Grenadines']\npops['Saint Kitts and Nevis'] = pops['Saint Kitts & Nevis']\npops['Czechia'] = pops['Czech Republic (Czechia)']\npops['Cote d\\'Ivoire'] = pops['C\u00f4te d\\'Ivoire']\npops['Diamond Princess'] = 3000\npops['Burma'] = pops['Myanmar']\npops['West Bank and Gaza'] = pops['State of Palestine']\npops['Kosovo'] = 1847708\npops['MS Zaandam'] = 3000\npops['Sao Tome and Principe'] = pops['Sao Tome & Principe']\n\nunmapped_countries = list(df_train['Country_Region'].unique()) - pops.keys()\nif len(unmapped_countries) > 0:\n    print('warn: There are unmapped population data: ', end='', file=sys.stderr)\n    print(*unmapped_countries, sep=', ', file=sys.stderr)","ec77d35a":"# fix non-cumulative records\ndf_train[['ConfirmedCases', 'Fatalities']] = df_train.groupby(agg_unit)[['ConfirmedCases', 'Fatalities']].transform('cummax')","c05f926f":"# set the first confirmed date to each rows\ndf_train['FirstConfirmedDateCountry'] = df_train.query('ConfirmedCases>0').groupby(agg_unit)['Date'].transform('min')\ndf_train['FirstDeceasedDateCountry'] = df_train.query('Fatalities>0').groupby(agg_unit)['Date'].transform('min')","18caeb90":"df_train['DaysSinceFirstConfirmed'] = (df_train['Date'] - df_train['FirstConfirmedDateCountry']).dt.days\ndf_train['DaysSinceFirstDeceased'] = (df_train['Date'] - df_train['FirstDeceasedDateCountry']).dt.days","d0a03ca4":"# preparing an output dataframe\ndf_test = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-4\/test.csv', parse_dates=['Date'])\ndf_test = df_test.replace(np.nan, '', regex=True)\ndf_test['ConfirmedCases'] = 0\ndf_test['Fatalities'] = 0","89aa15ad":"class LogisticCurve:\n    def __init__(self, k_init=1, c_init=1,\n                 k_lower=-np.inf, k_upper=np.inf,\n                 c_lower=-np.inf, c_upper=np.inf):\n        self.k_init = k_init\n        self.c_init = c_init\n        self.k_lower, self.k_upper = k_lower, k_upper\n        self.c_lower, self.c_upper = c_lower, c_upper\n        self.k = k_init\n        self.b = c_init\n        self.c = c_init\n\n\n    def logistic_func(self, x, k, b, c):\n        return c \/ (b * np.exp(-k * x) + 1)\n\n    def fit(self, xs, ys):\n        from scipy.optimize import curve_fit\n        p0 = [self.k_init, self.c_init, self.c_init]\n        bounds = [(self.k_lower, self.c_lower, self.c_lower), (self.k_upper, self.c_upper, self.c_upper)]\n        try:\n            params, pcov = curve_fit(self.logistic_func, xs, ys, p0=p0, bounds=bounds, maxfev=100000)\n            self.k, self.b, self.c = params\n        except RuntimeError:\n            pass\n        return self\n\n    def predict(self, xs):\n        return self.logistic_func(xs, self.k, self.b, self.c)\n\n    def get_params(self, deep=False):\n        return { \n            'k_init': self.k_init,\n            'c_init': self.c_init,\n            'k_lower': self.k_lower,\n            'k_upper': self.k_upper,\n            'c_lower': self.c_lower,\n            'c_upper': self.c_upper\n        }\n    \n    def set_params(self, **params):\n        for param, value in params.items():\n            setattr(self, param, value)\n        return self\n\n    def get_estimated_params(self):\n        return [self.k, self.b, self.c]\n\n    def set_curve_params(self, k, b, c):\n        self.k = k\n        self.b = b\n        self.c = c\n        return self","23e78ce0":"def estimate_column_params(df, xcol, ycol, maximum):\n    try:\n        init_count = df[df[xcol] == 0][ycol].iloc[0]\n    except IndexError:\n        return None\n    \n    rows = df[df[xcol] >= 0]\n\n    mcv = LogisticCurve(c_lower=0, c_upper=maximum)\n    mcv.fit(rows[xcol], rows[ycol])\n    return mcv.get_estimated_params()\n\n    cv = [(list(range(len(train_data))), list(range(len(train_data), len(rows))))]\n    mcv = GridSearchCV(LogisticCurve(k_lower=1e-18, c_lower=0, c_upper=maximum), { 'k_init': [0.1, 1], 'k_upper': [1, 10], 'c_init': [0, init_count] }, cv=cv, scoring='neg_root_mean_squared_error')\n    mcv.fit(rows[xcol], rows[ycol])\n    return mcv.best_estimator_.get_estimated_params()\n    \ndef estimate_params(df, maximum):\n    return [estimate_column_params(df, 'DaysSinceFirstConfirmed', 'ConfirmedCases', maximum), estimate_column_params(df, 'DaysSinceFirstDeceased', 'Fatalities', maximum)]","96a5dc6d":"# estimate params with parallelism, then map result to corresponding region.\nestimated_params = dict(Parallel(n_jobs=-1, verbose=8)([delayed(lambda label, df, maximum: [label, estimate_params(df, maximum)])((country, state), df, pops[country]) for (country, state), df in df_train.groupby(agg_unit)]))","4c18c24f":"# make prediction with estimaed params\nfor (country, state), df in df_train.groupby(agg_unit):\n    cparams, fparams = estimated_params[(country, state)]\n    \n    try:\n        first_confirmed_on = df[df['DaysSinceFirstConfirmed'] == 0]['Date'].iloc[0]\n        df_test.loc[(df_test['Country_Region'] == country) & (df_test['Province_State'] == state), 'FirstConfirmedDate'] = first_confirmed_on\n        df_test['DaysSinceFirstConfirmed'] = (df_test['Date'] - df_test['FirstConfirmedDate']).dt.days\n        if cparams is not None:\n            mcv1 = LogisticCurve().set_curve_params(*cparams)\n            df_train.loc[(df_train['Country_Region'] == country) & (df_train['Province_State'] == state), 'PredictedConfirmedCases'] = mcv1.predict(df_train.loc[(df_train['Country_Region'] == country) & (df_train['Province_State'] == state), 'DaysSinceFirstConfirmed'])\n            df_test.loc[(df_test['Country_Region'] == country) & (df_test['Province_State'] == state), 'ConfirmedCases'] = mcv1.predict(df_test.loc[(df_test['Country_Region'] == country) & (df_test['Province_State'] == state), 'DaysSinceFirstConfirmed'])\n    except IndexError:\n        continue\n    \n    try:\n        first_deceased_on = df[df['DaysSinceFirstDeceased'] == 0]['Date'].iloc[0]\n        df_test.loc[(df_test['Country_Region'] == country) & (df_test['Province_State'] == state), 'FirstDeceasedDate'] = first_deceased_on\n        df_test['DaysSinceFirstDeceased'] = (df_test['Date'] - df_test['FirstDeceasedDate']).dt.days\n        if fparams is not None:\n            mcv2 = LogisticCurve().set_curve_params(*fparams)\n            df_train.loc[(df_train['Country_Region'] == country) & (df_train['Province_State'] == state), 'PredictedFatalities'] = mcv2.predict(df_train.loc[(df_train['Country_Region'] == country) & (df_train['Province_State'] == state), 'DaysSinceFirstDeceased'])\n            df_test.loc[(df_test['Country_Region'] == country) & (df_test['Province_State'] == state), 'Fatalities'] = mcv2.predict(df_test.loc[(df_test['Country_Region'] == country) & (df_test['Province_State'] == state), 'DaysSinceFirstDeceased'])\n    except IndexError:\n        continue","5544c370":"# picking up countries to visualize\nfor (country, state), df in df_train.groupby(agg_unit):\n    if country not in ['Italy', 'Spain', 'Japan', 'Russia']:\n        continue\n    \n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 5))\n    fig.suptitle(f'{country} {state}')\n    \n    c = df.query('DaysSinceFirstConfirmed>=0').set_index('DaysSinceFirstConfirmed').sort_index()\n    if len(c) == 0:\n        continue\n    c['ConfirmedCases'].plot(label='Actual', ax=ax1)\n    c['PredictedConfirmedCases'].plot(label='Fitted', ax=ax1)\n    ax1.legend()\n    \n    c = df.query('DaysSinceFirstDeceased>=0').set_index('DaysSinceFirstDeceased').sort_index()\n    if len(c) == 0:\n        continue\n    c['Fatalities'].plot(label='Actual', ax=ax2)\n    c['PredictedFatalities'].plot(label='Fitted', ax=ax2)\n    ax1.legend()","85e1c696":"df_eval = pd.merge(df_train.rename(columns={ 'ConfirmedCases': 'c1', 'Fatalities': 'f1' }), df_test.rename(columns={ 'ConfirmedCases': 'c2', 'Fatalities': 'f2' }), on=['Country_Region', 'Province_State', 'Date'])\n\nerror = 0\nfor (err, actual, pred) in [('cerr', 'c1', 'c2'), ('ferr', 'f1', 'f2')]:\n    df_eval[err] = np.square(np.log(df_eval[actual] + 1) - np.log(df_eval[pred] + 1))\n    colerr = np.sqrt(df_eval[err].sum() \/ len(df_eval))\n    error += colerr\n    print(f'RMSLE({err}):', colerr)\n\nprint('RMSLE:', error)","04f88587":"df_test.to_csv('submission.csv', index=False, columns=['ForecastId', 'ConfirmedCases', 'Fatalities'])","65fcb11d":"Finally, we write out the prediction into a file.","ff86af7d":"## Model Definition\n\nNow we use logistic curve as a model to fit.\n\nLogistic model can be defined the below equation:\n\n$$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = k\\left(1 - \\frac{y}{c}\\right) y\n$$\n\nThe variable $c$ is called carrying capacity.\n\nBy solving this differential equation, we can get following equation as a logistic function.\n\n$$\ny = \\frac{c}{be^{-kt} + 1}\n$$\n\nWhat to do next is estimating the constants $k$, $b$, and $c$.\n\nThe below class is an estimator for these constants using `scipy.optimize.curve_fit` by specifing some parameters.","84b92509":"After parameter estimation, we predict the number of cases.","a0eec4d0":"## Preprocessing","2a5d0231":"Next, let us make some figures to check the estimated parameters.","f569b3b9":"## Load Data","3bfa6174":"## Fitting and Prediction\nLet us estimate constants of logistic curve for each regions.\n\nWe use joblib to parallelize the estimation process of each regions to make our code run fast!\n\nFirst, we define the estimating function to pass runner:","dcb45c05":"## Evaluation and Submit","0ad6152a":"By using above function, let us start estimation.","4d4b13aa":"In this Notebook, we attempt to fit the number of confirmed and deceased cases by a logistic curve."}}