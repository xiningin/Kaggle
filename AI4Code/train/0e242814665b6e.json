{"cell_type":{"9a0468a7":"code","fc76dab9":"code","f20a4c6f":"code","a8758407":"code","d9e9dae9":"code","578b998c":"code","fa535f40":"code","105d6436":"code","67854ab3":"code","a16a8a4e":"code","cdad47da":"code","2c220641":"code","9ee55c17":"code","20a179a0":"code","578a8c7d":"code","d99d243f":"code","cbaa4537":"code","4cd5ecfc":"code","a3b64485":"code","1919cb7b":"code","3a0a6f2f":"code","baa1c428":"code","fea1fa65":"code","4019d84d":"code","8ac45d1a":"code","82518eff":"code","c0e9e108":"code","13a89206":"code","02ae7ec1":"code","281f2a19":"code","a900c733":"code","94990c16":"code","3ea61fb2":"code","24d737f8":"code","780ce5b4":"code","c828bc51":"code","47a1ac6d":"code","9b497c60":"code","8ed2abb8":"code","37fd62e5":"code","bbdb4ef7":"code","3cb663c1":"code","54e90f80":"code","fbfe3f3c":"code","e39b67ff":"code","e5ef9aa3":"code","d830a217":"code","650a5e89":"code","0a6d6b9f":"code","7983e273":"code","2908c22b":"code","b20b1448":"code","7c50e1ac":"code","91246749":"code","05121bee":"code","22f088c2":"code","89ad5039":"code","e0f87379":"code","6bdd0dd9":"code","f718dbdf":"code","71146731":"code","6e13aafb":"code","27f1da08":"code","480e7212":"code","e5a13c6e":"code","fd8bf645":"code","15ad89a8":"code","53924848":"code","1061412d":"markdown","c4f4ee64":"markdown","c364f42e":"markdown","c9fc05e8":"markdown","7cebb73a":"markdown","b78827b5":"markdown","08e97699":"markdown","9994e706":"markdown","32de07e4":"markdown","f138c707":"markdown","a7e32281":"markdown","a3e2a676":"markdown","9ee44747":"markdown","072d56e5":"markdown","2a46e541":"markdown","49e1af00":"markdown","2d6995b3":"markdown","894d91ae":"markdown","714fa61b":"markdown","6818102a":"markdown","b13ff956":"markdown","7dc6e34b":"markdown","4dddd0c8":"markdown","e845a763":"markdown","e1f62030":"markdown","6416e68b":"markdown","10e326a7":"markdown","54bf15b1":"markdown","b70af4f7":"markdown","77601db6":"markdown","e15a4114":"markdown","51ef5d9e":"markdown","c9060957":"markdown","3672a6b5":"markdown","00254510":"markdown","c798fc50":"markdown","5b0ad748":"markdown","8d82d64b":"markdown","0591deb9":"markdown","b5d7aa21":"markdown","e5d6287e":"markdown"},"source":{"9a0468a7":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom plotnine import *\nimport seaborn as sns\n\nfrom sklearn.metrics import roc_auc_score\n\nfrom xgboost import XGBClassifier\nfrom lightgbm import LGBMClassifier\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n# Any results you write to the current directory are saved as output.","fc76dab9":"data = pd.read_excel(\"\/kaggle\/input\/covid19\/dataset.xlsx\")","f20a4c6f":"data.shape","a8758407":"data.head()","d9e9dae9":"data = data.drop(columns=[\"Patient ID\"])","578b998c":"old_names = ['Patient addmited to intensive care unit (1=yes, 0=no)',\n             'Patient addmited to semi-intensive unit (1=yes, 0=no)',\n             'Patient addmited to regular ward (1=yes, 0=no)',\n             'SARS-Cov-2 exam result']\nnew_names = [\"int_care\", \"semiint_care\", \"reg_ward\", \"infected\"]\ncolname_mapper = dict(zip(old_names, new_names))\ndata = data.rename(columns=colname_mapper)\n\ndata[\"infected\"] = 1*(data[\"infected\"] == \"positive\")\n\ndata[new_names].melt().groupby('variable').value.mean()","fa535f40":"df_plot = data.isna().sum().sort_values(ascending=False).reset_index(name=\"count\")#.tail(10)\n# df_plot.loc[int(0.1*len(df_plot)):int(0.9*len(df_plot)),'index'] = '.'\ndf_plot[\"percent_missing\"] = df_plot[\"count\"]\/len(data)\n# df_plot[\"label\"] = df_plot[\"percent\"]\n# df_plot.loc[df_plot.index.values % 10 == 0, \"label\"] = df_plot[\"percent\"]\n# df_plot.loc[\"index\"] = df_plot[\"index\"].apply(lambda x: str(x)[:12] + \"...\")\ndf_plot[\"index\"] = pd.Categorical(df_plot[\"index\"], categories=df_plot[\"index\"])","105d6436":"(ggplot(df_plot, aes(\"index\", \"percent_missing\")) +\n    geom_bar(stat=\"identity\", fill=\"#1B9E77\") +\n#     geom_text(aes(label=\"np.round(label,2)\", y=\"percent-0.01\"), size=6, color=\"yellow\", ) +\n    theme_minimal() +\n    coord_flip() +\n    theme(axis_text_y=element_text(size=5)) +\n    labs(title=\"Missing value distribution\", y=\"Feature\", x=\"Missing value percentage\"))","67854ab3":"pd.concat([df_plot.head(10), pd.DataFrame([[\"...\"]*3], columns=df_plot.columns), df_plot.tail(10)])","a16a8a4e":"data = data[df_plot.loc[len(data) - df_plot[\"count\"] > 10, \"index\"]]","cdad47da":"df_plot = data.isna()\npercent_na = df_plot.sum()\/len(data)\ndf_plot = df_plot.loc[:,(percent_na < 0.97) & (percent_na > 0.01)]","2c220641":"from scipy.cluster import hierarchy\nfrom scipy.spatial import distance\n#increase recursion limit to run clustermap\nimport sys\nsys.setrecursionlimit(10000)\n\ndef nans_cluster():\n    row_linkage = hierarchy.linkage(\n        distance.pdist(df_plot.T), method='complete', metric=\"hamming\")\n\n    col_linkage = hierarchy.linkage(\n        distance.pdist(df_plot), method='complete', metric=\"hamming\")\n\n    d = hierarchy.distance.pdist(df_plot)\n    col_clusters = pd.Series(hierarchy.fcluster(col_linkage, 5, 'distance'), name=\"cluster\")\n    row_clusters = pd.Series(hierarchy.fcluster(row_linkage, 25, 'distance'), name=\"cluster\")\n    # colormap = pd.Series(sns.color_palette(\"Set2\", col_clusters.max()+1).as_hex())\n    colormap = pd.Series([\"yellow\", \"red\", \"green\", \"blue\", \"black\"])\n    col_colors = col_clusters.map(colormap)\n    col_colors.index = df_plot.index\n\n    row_colors = row_clusters.map(colormap)\n    row_colors.index = df_plot.columns\n\n    data[\"cluster\"] = col_clusters\n\n    return sns.clustermap(df_plot.T, row_linkage=row_linkage, col_linkage=col_linkage, \n                   row_colors=row_colors, col_colors=col_colors,\n                   method=\"complete\", metric=\"hamming\",\n                   figsize=(13, 13))\n\nnans_cluster()","9ee55c17":"data.groupby(\"cluster\")[\"infected\"].mean()","20a179a0":"obj_columns = data.columns[data.dtypes == \"object\"]\ndata[obj_columns].head()","578a8c7d":"obj_description = data[obj_columns].describe().T.sort_values(\"unique\", ascending=False)\nobj_description","d99d243f":"data[\"Urine - Leukocytes\"].dropna().sort_values()","cbaa4537":"data[\"Urine - Leukocytes\"] = data[\"Urine - Leukocytes\"].str.replace(\"<\", \"1\").astype(float)","4cd5ecfc":"data[\"Urine - pH\"].dropna()#.astype(\"float\")","a3b64485":"data.loc[data[\"Urine - pH\"] == \"N\u00e3o Realizado\", \"Urine - pH\"] = np.nan\ndata[\"Urine - pH\"] = data[\"Urine - pH\"].astype(float)","1919cb7b":"data[\"Strepto A\"].drop_duplicates()","3a0a6f2f":"data.loc[data[\"Strepto A\"] == \"not_done\", \"Strepto A\"] = np.nan","baa1c428":"data[\"Urine - Hemoglobin\"].drop_duplicates()","fea1fa65":"data.loc[data[\"Urine - Hemoglobin\"] == \"not_done\", \"Urine - Hemoglobin\"] = np.nan","4019d84d":"obj_columns = data.columns[data.dtypes == \"object\"]\nobj_description = data[obj_columns].describe().T.sort_values(\"unique\", ascending=False)\nobj_description","8ac45d1a":"cols = obj_description.query(\"top=='not_detected'\").index.values\nfor c in cols:\n    data.loc[data[c]==\"not_detected\", c] = 0\n    data.loc[data[c]==\"detected\", c] = 1\n    data[c] = data[c].astype(\"float\")","82518eff":"cols = obj_description.query(\"top=='absent'\").index.values\nfor c in cols:\n    data.loc[data[c]==\"absent\", c] = 0\n    data.loc[data[c]==\"present\", c] = 1\n    data.loc[data[c]==\"not_done\", c] = np.nan\n    data[c] = data[c].astype(\"float\")","c0e9e108":"cols = obj_description.query(\"top=='normal'\").index.values\nfor c in cols:\n    data.loc[data[c]==\"normal\", c] = 1\n    data.loc[data[c]==\"not_done\", c] = np.nan\n    data[c] = data[c].astype(\"float\")","13a89206":"cols = obj_description.query(\"top=='negative'\").index.values\nfor c in cols:\n    data.loc[data[c]==\"negative\", c] = 0\n    data.loc[data[c]==\"positive\", c] = 1\n    data[c] = data[c].astype(\"float\")","02ae7ec1":"# data = data.drop(columns=[\"Urine - Nitrite\"])","281f2a19":"obj_columns = data.columns[data.dtypes == \"object\"]\nobj_description = data[obj_columns].describe().T.sort_values(\"unique\", ascending=False)\nobj_description","a900c733":"categorical_features = obj_description.index.tolist()","94990c16":"from lightgbm import LGBMClassifier\nfrom sklearn.model_selection import GridSearchCV, train_test_split, cross_val_predict","3ea61fb2":"def fix_non_ascii_space(x):\n    \"\"\" Fixes non-ascii space characters\"\"\"\n    return ''.join([i if ord(i) < 128 else ' ' for i in x])\n\n        \ndata.columns = [fix_non_ascii_space(x) for x in data.columns]\ndata.columns = data.columns.str.replace(\",\", \"\")","24d737f8":"X_train, X_test, y_train, y_test = train_test_split(\n    data.drop(columns=['int_care', 'semiint_care', 'reg_ward', 'infected']),\n    data['infected'],\n    test_size=0.02,\n    random_state=42)","780ce5b4":"for c in categorical_features:\n    X_train[c] = X_train[c].astype(\"category\")","c828bc51":"params = {\n    \"max_depth\": [2, 3, 4, 5, 10],\n    \"num_leaves\": [31, 100],\n    \"colsample_bytree\": [0.6, 0.8, 1.]\n}\n\nlgb = LGBMClassifier()\n\ngs = GridSearchCV(lgb, params, scoring=[\"neg_log_loss\", \"roc_auc\"], cv=5, refit=False)\ngs.fit(X_train, y_train)","47a1ac6d":"(pd.DataFrame(gs.cv_results_)\n .sort_values('mean_test_roc_auc')\n [[\"params\", \"mean_test_neg_log_loss\", \"mean_test_roc_auc\", \"std_test_neg_log_loss\"]])","9b497c60":"chosen_params = {'colsample_bytree': 0.8, 'max_depth': 3, 'num_leaves': 31}\nlgb = LGBMClassifier(**chosen_params)","8ed2abb8":"fitted_columns = X_train.drop(columns=['cluster']).columns.tolist()\nlgb.fit(X_train[fitted_columns], y_train) # fitted model not used now, but will be used later","37fd62e5":"preds = cross_val_predict(lgb, X_train[fitted_columns],\n                          y_train, cv=5, method=\"predict_proba\")","bbdb4ef7":"X_train['predictions'] = preds[:,1]\nX_train['target'] = y_train.astype(\"str\").values","3cb663c1":"nans_cluster()","54e90f80":"df_temp = pd.concat([\n    X_train.groupby('cluster').target.apply(lambda x: x.astype(int).mean()),\n    X_train.groupby('cluster').apply(lambda x: roc_auc_score(x.target, x.predictions))],\n    1)\ndf_temp.columns = [\"precentage_of_infected\", \"ROC_AUC\"]\ndf_temp","fbfe3f3c":"print(ggplot(X_train, aes(\"predictions\")) +\n    geom_histogram(bins=10, fill=\"#008ABC\") + \n    scale_y_log10() +\n    facet_wrap(\"~cluster\") +\n    labs(x=\"Predicted probability\", title=\"Output probabilities per cluster\") +\n    theme_538())","e39b67ff":"(ggplot(X_train, aes(\"predictions\", fill=\"target\")) +\n    geom_histogram(position=\"fill\", bins=10) +\n    facet_wrap(\"~cluster\") +\n    scale_fill_brewer(type=\"qual\", palette=\"Set1\") +\n    labs(x=\"Predicted probability\", title=\"Class separation per cluster\") +\n    theme_538())","e5ef9aa3":"subset_tests = [\"Patient age quantile\", \"Mean platelet volume \", \"Hematocrit\",\n                \"Hemoglobin\", \"Monocytes\", \"Red blood cell distribution width (RDW)\",\n                \"Platelets\", \"Mean corpuscular volume (MCV)\", \"Eosinophils\",\n                \"Mean corpuscular hemoglobin (MCH)\", \"Basophils\", \"Leukocytes\", \n                \"Mean corpuscular hemoglobin concentration (MCHC)\", \n                \"Red blood Cells\", \"Lymphocytes\"]\n\nchosen_params = {'colsample_bytree': 0.6, 'max_depth': 5, 'num_leaves': 31}\nlgb_subset = LGBMClassifier(**chosen_params)\n\nX_subset = X_train[subset_tests].dropna()\ny_subset = y_train[X_subset.index]\n\nlgb_subset.fit(X_subset, y_subset) #fit this for later use with shap\nX_subset[\"predictions\"] = cross_val_predict(lgb_subset, X_subset,\n                                            y_subset, cv=5, method=\"predict_proba\")[:,1]\n\nX_subset[\"target\"] = y_subset.astype(str)\n\nauc = roc_auc_score(X_subset.target, X_subset.predictions)\n\nprint(f\"====== ROC AUC {np.round(auc, 3)} =======\")\n\nprint(ggplot(X_subset, aes(\"predictions\")) +\n    geom_histogram(bins=10, fill=\"#008ABC\") + \n    scale_y_log10() +\n    labs(x=\"Predicted probability\", title=\"Output probabilities for subset model\") +\n    theme_538())\n\n(ggplot(X_subset, aes(\"predictions\", fill=\"target\")) +\n    geom_histogram(position=\"fill\", bins=10) +\n    scale_fill_brewer(type=\"qual\", palette=\"Set1\") +\n    labs(x=\"Predicted probability\", title=\"Class separation for subset model\") +\n    theme_538())","d830a217":"X_train['non_missing'] = X_train.notna().sum(1)","650a5e89":"(ggplot(X_train, aes('non_missing', 'predictions')) +\n    geom_point(alpha=0.2) +\n    geom_smooth(method='lm') +\n    facet_wrap('~cluster'))","0a6d6b9f":"def feature_importance(lgb, importance_type=\"gain\", return_df=False):\n\n    importances = lgb.booster_.feature_importance(importance_type='gain')\n    names = lgb.booster_.feature_name()\n    df = pd.DataFrame({\"names\": names, importance_type: importances})\n\n    df = df.sort_values(importance_type, ascending=True)\n    df = df.tail(20)\n    df[\"names\"] = pd.Categorical(df[\"names\"], categories=df[\"names\"])\n\n    if return_df:\n        return df\n    else: \n        return (ggplot(df, aes(\"names\", importance_type)) +\n        geom_bar(stat=\"identity\") +\n        coord_flip())","7983e273":"feature_importance(lgb)","2908c22b":"def histogram_target(df, variable, target, labels={}):\n    df = df.copy()\n    \n#     if df[variable].nunique() < 25:\n#         gg = (ggplot(df, aes(variable, fill=target)) +\n#               geom_bar(position=\"fill\"))\n#     else:\n    df = df[[variable, target]].dropna()\n    gg = (ggplot(df, aes(variable, fill=target)) +\n          geom_histogram(position=\"fill\"))\n\n    return (\n        gg +\n        scale_fill_brewer(type=\"qual\", palette=\"Set1\") +\n        theme_minimal() +\n        labs(title=variable)\n    )\n\n\nfeatures_to_plot = (feature_importance(lgb, return_df=True)\n                    .sort_values(\"gain\", ascending=False)\n                    .names\n                    .str\n                    .replace(\"_\", \" \")\n                    .head(10)\n                    .tolist()\n                   )\n\nfor f in features_to_plot:\n    print(histogram_target(X_train, f, \"target\"))","b20b1448":"import shap\n\nshap.initjs()","7c50e1ac":"explainer = shap.TreeExplainer(lgb_subset)\nshap_values = explainer.shap_values(X_subset[subset_tests])[1]\n\nfor f in subset_tests:\n    shap.dependence_plot(f, shap_values, X_subset[subset_tests])","91246749":"def plot_2feats(df, x, y):\n    return(ggplot(df, aes(x, y, color=\"target\")) + \n          geom_point(alpha=0.8) +\n          scale_color_brewer(type=\"qual\", palette=\"Set1\") +\n          labs(title=f\"{x} vs {y}\") +\n          theme_minimal())\n\nprint(plot_2feats(X_train, \"Hematocrit\", \"Leukocytes\"))\nprint(plot_2feats(X_train, \"Basophils\", \"Leukocytes\"))\nprint(plot_2feats(X_train, \"Hematocrit\", \"Platelets\"))","05121bee":"X_subset_test = X_test[subset_tests].dropna()\ny_subset_test = y_test[X_subset_test.index]","22f088c2":"(pd.DataFrame({\"target\": y_subset_test,\n              \"predictions\": lgb_subset.predict_proba(X_subset_test)[:,1]})\n .reset_index(drop=True)\n .sort_values(\"predictions\"))","89ad5039":"i=1","e0f87379":"shap_values = explainer.shap_values(X_subset_test)[1]\n\nshap.force_plot(explainer.expected_value[1], shap_values[1,:], X_subset_test.iloc[1,:])","6bdd0dd9":"(plot_2feats(X_train, \"Eosinophils\", \"Leukocytes\") +\n    geom_point(data=X_subset_test.iloc[i:(i+1),:], color=\"orange\", alpha=0.7, size=10) +\n    labs(title=\"Zoom in Subject 1\"))","f718dbdf":"i=0","71146731":"shap.force_plot(explainer.expected_value[1], shap_values[i,:], X_subset_test.iloc[i,:])","6e13aafb":"(plot_2feats(X_train, \"Mean corpuscular hemoglobin (MCH)\", \"Mean corpuscular hemoglobin concentration (MCHC)\") +\n    geom_point(data=X_subset_test.iloc[i:(i+1),:], color=\"orange\", alpha=0.7, size=10) +\n    labs(title=\"Zoom in Subject 2\"))","27f1da08":"i=4","480e7212":"shap.force_plot(explainer.expected_value[1], shap_values[i,:], X_subset_test.iloc[i,:])","e5a13c6e":"(plot_2feats(X_train, \"Eosinophils\", \"Leukocytes\") +\n    geom_point(data=X_subset_test.iloc[i:(i+1),:], color=\"orange\", alpha=0.7, size=10) +\n    labs(title=\"Zoom in Subject 3\"))","fd8bf645":"i=7","15ad89a8":"shap.force_plot(explainer.expected_value[1], shap_values[i,:], X_subset_test.iloc[i,:])","53924848":"(plot_2feats(X_train, \"Eosinophils\", \"Leukocytes\") +\n    geom_point(data=X_subset_test.iloc[i:(i+1),:], color=\"orange\", alpha=0.7, size=10) +\n    labs(title=\"Zoom in Subject 4\"))","1061412d":"I would do it for the full model but I have no time to debug issues I'm having :)","c4f4ee64":"\n## Missing values","c364f42e":"<b> Top and bottom missing variables","c9fc05e8":"The relation is not clear, but let's come back to this later. Moving to feature importances:","7cebb73a":"### Binarize columns","b78827b5":"#### Subject 4","08e97699":"## Data cleaning and related EDA","9994e706":"## Interpretable predictions","32de07e4":"<b> COVID positive per cluster <\/b>","f138c707":"<b> Clean Strepto A","a7e32281":"#### Retrain and do out-of-fold predictions with the optimal hyperparams","a3e2a676":"<b> Subset model <\/b>\n\nLet's check the performance of a model trained on a subset of the tests:","9ee44747":"<b> AUC: 0.6828","072d56e5":"The subject data is highlighted in yellow.","2a46e541":"## Results Analysis","49e1af00":"#### Subject 2","2d6995b3":"We can see that we do a much better job at predicting for individuals that have values for features in the green cluster of features.","894d91ae":"<b> Clean Urine - pH","714fa61b":"We will come back to this later, but for now we can clearly see clusters of patients and tests. These are, of course, result of decisions made by the doctors on which tests to ask based on each individual situation.","6818102a":"<b> Classes balance","b13ff956":"This is boring. Just skip it.","7dc6e34b":"<b> Clean Urine - Hemoglobin","4dddd0c8":"Based on these plots we can already find some interesting relations:","e845a763":"#### Hyperparameter search","e1f62030":"We can also check if the high probabilities are correlated with high number of nonmissing values (meaning more test performed):","6416e68b":"### Preprocessing categorical variables","10e326a7":"#### Subject 1","54bf15b1":"In this notebook I will try to present an analysis of the COVID data focused in ideas of what can be useful or not for doctors. The models the community was able to create don't reach outstanding results (ROC AUC under 0.7) so these models will at best be an additional tool that doctors can use in order to make better judgments.\n\nI apologise for the lack of comments and structure, but the limited submission time prevented me from working further on it. Also, I remain open to continue helping and discussing strategies for this problem with the team in the future.\n\n\n<h2> I recommend to start at the \"Let's build a LGBM model\" section!","b70af4f7":"<h3> Closer look at important variables","77601db6":"<b> Remove features with less than 10 non-missing values:","e15a4114":"<b> Clean Urine - pH","51ef5d9e":"Let's refresh the missing values heatmap:","c9060957":"It seems like doctors tend to not ask for tests other than virus tests for patients very unlikely to be infected.","3672a6b5":"#### Clustering\n\nLet's check which features go missing together","00254510":"Very little data, but the model was flawless! (under a 0.5 threshold)","c798fc50":"# SHAP analysis for subset model","5b0ad748":"Red, gree, blue and black stand for clusters 1-4, respectively.\n\nLet's focus on the clusters of observations. We can see that the patients can be divided in:\n\n- Cluster 1: Viral tests\n- Cluster 2: Viral tests + blood tests\n- Cluster 3: Very few tests\n- Cluster 4: Blood tests\n\nOf course the less data we have, the worse the model will perform. Also, and I cannot emphasize enough, \n\n<h3> The mere fact that we know that some variable is not missing encode information of the decision process made by doctors. If a patient has done many tests, someone decided that these tests were necessary, probably because the patient is likely infected. This represent a huge bias in this modelling. <\/h3>\n\nLet's consider the model performance per cluster:","8d82d64b":"Rather than to create a overoptimized and accurate model, I would like to use it to extend our understanding of the problem.","0591deb9":"#### Subject 3","b5d7aa21":"<b> Remaining categorical features:","e5d6287e":"# Let's build a LGBM model"}}