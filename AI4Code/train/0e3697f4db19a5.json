{"cell_type":{"521fda1d":"code","3dc7be63":"code","3d809874":"code","28fb1743":"code","4c11f14d":"code","23ef2e77":"code","4ea40807":"code","a03fa449":"code","9de5a2bf":"code","716f7ae8":"code","aace9998":"code","66c73e36":"code","fdb430f3":"code","36058caf":"code","73205833":"code","cbbf6b4f":"code","bc3b6253":"code","2616b09b":"code","8d541c4f":"code","d1959274":"code","248db6f8":"code","ea920bb4":"markdown","fb371fd2":"markdown","6f9fdc40":"markdown","183ffa2d":"markdown","81e97d91":"markdown","0d29cf58":"markdown","d77aa6ac":"markdown","08f6ee7f":"markdown","d26c4de2":"markdown","d25a2701":"markdown","2e8919d9":"markdown","6eb314fa":"markdown","d8940161":"markdown"},"source":{"521fda1d":"# install sent2vec\n!pip install git+https:\/\/github.com\/epfml\/sent2vec","3dc7be63":"!pip freeze > kaggle_image_requirements.txt","3d809874":"import random\nimport pandas as pd\n\n## Read-in the reviews and print some basic descriptions of them\n\n!wget -q \"http:\/\/ai.stanford.edu\/~amaas\/data\/sentiment\/aclImdb_v1.tar.gz\"\n!tar xzf aclImdb_v1.tar.gz","28fb1743":"Nsamp = 1000 # number of samples to generate in each class - 'spam', 'not spam'\nmaxtokens = 200 # the maximum number of tokens per document\nmaxtokenlen = 100 # the maximum length of each token","4c11f14d":"def tokenize(row):\n    if row is None or row is '':\n        tokens = \"\"\n    else:\n        tokens = row.split(\" \")[:maxtokens]\n    return tokens","23ef2e77":"import re\n\ndef reg_expressions(row):\n    tokens = []\n    try:\n        for token in row:\n            token = token.lower() # make all characters lower case\n            token = re.sub(r'[\\W\\d]', \"\", token)\n            token = token[:maxtokenlen] # truncate token\n            tokens.append(token)\n    except:\n        token = \"\"\n        tokens.append(token)\n    return tokens","4ea40807":"import nltk\n\nnltk.download('stopwords')\nfrom nltk.corpus import stopwords\nstopwords = stopwords.words('english')    \n\n# print(stopwords) # see default stopwords\n# it may be beneficial to drop negation words from the removal list, as they can change the positive\/negative meaning\n# of a sentence\n# stopwords.remove(\"no\")\n# stopwords.remove(\"nor\")\n# stopwords.remove(\"not\")","a03fa449":"def stop_word_removal(row):\n    token = [token for token in row if token not in stopwords]\n    token = filter(None, token)\n    return token","9de5a2bf":"import time\nimport sent2vec\n\nmodel = sent2vec.Sent2vecModel()\nstart=time.time()\nmodel.load_model('..\/input\/sent2vec\/wiki_unigrams.bin')\nend = time.time()\nprint(\"Loading the sent2vec embedding took %d seconds\"%(end-start))","716f7ae8":"def assemble_embedding_vectors(data):\n    out = None\n    for item in data:\n        vec = model.embed_sentence(\" \".join(item))\n        if vec is not None:\n            if out is not None:\n                out = np.concatenate((out,vec),axis=0)\n            else:\n                out = vec                                            \n        else:\n            pass\n        \n        \n    return out","aace9998":"import os\nimport numpy as np\n\n# shuffle raw data first\ndef unison_shuffle_data(data, header):\n    p = np.random.permutation(len(header))\n    data = data[p]\n    header = np.asarray(header)[p]\n    return data, header\n\n# load data in appropriate form\ndef load_data(path):\n    data, sentiments = [], []\n    for folder, sentiment in (('neg', 0), ('pos', 1)):\n        folder = os.path.join(path, folder)\n        for name in os.listdir(folder):\n            with open(os.path.join(folder, name), 'r') as reader:\n                  text = reader.read()\n            text = tokenize(text)\n            text = stop_word_removal(text)\n            text = reg_expressions(text)\n            data.append(text)\n            sentiments.append(sentiment)\n    data_np = np.array(data)\n    data, sentiments = unison_shuffle_data(data_np, sentiments)\n    \n    return data, sentiments\n\ntrain_path = os.path.join('aclImdb', 'train')\ntest_path = os.path.join('aclImdb', 'test')\nraw_data, raw_header = load_data(train_path)\n\nprint(raw_data.shape)\nprint(len(raw_header))","66c73e36":"# Subsample required number of samples\nrandom_indices = np.random.choice(range(len(raw_header)),size=(Nsamp*2,),replace=False)\ndata_train = raw_data[random_indices]\nheader = raw_header[random_indices]\n\nprint(\"DEBUG::data_train::\")\nprint(data_train)","fdb430f3":"unique_elements, counts_elements = np.unique(header, return_counts=True)\nprint(\"Sentiments and their frequencies:\")\nprint(unique_elements)\nprint(counts_elements)","36058caf":"EmbeddingVectors = assemble_embedding_vectors(data_train)\nprint(EmbeddingVectors)","73205833":"data = EmbeddingVectors\n\nidx = int(0.7*data.shape[0])\n\n# 70% of data for training\ntrain_x = data[:idx,:]\ntrain_y = header[:idx]\n# # remaining 30% for testing\ntest_x = data[idx:,:]\ntest_y = header[idx:] \n\nprint(\"train_x\/train_y list details, to make sure it is of the right form:\")\nprint(len(train_x))\nprint(train_x)\nprint(train_y[:5])\nprint(len(train_y))","cbbf6b4f":"from sklearn.linear_model import LogisticRegression\n\ndef fit(train_x,train_y):\n    model = LogisticRegression()\n\n    try:\n        model.fit(train_x, train_y)\n    except:\n        pass\n    return model\n\nmodel = fit(train_x,train_y)","bc3b6253":"predicted_labels = model.predict(test_x)\nprint(\"DEBUG::The logistic regression predicted labels are::\")\nprint(predicted_labels)","2616b09b":"from sklearn.metrics import accuracy_score\n\nacc_score = accuracy_score(test_y, predicted_labels)\n\nprint(\"The logistic regression accuracy score is::\")\nprint(acc_score)","8d541c4f":"# Load scikit's random forest classifier library\nfrom sklearn.ensemble import RandomForestClassifier\n\n# Create a random forest Classifier. By convention, clf means 'Classifier'\nclf = RandomForestClassifier(n_jobs=1, random_state=0)\n\n# Train the Classifier to take the training features and learn how they relate\n# to the training y (spam, not spam?)\nstart_time = time.time()\nclf.fit(train_x, train_y)\nend_time = time.time()\nprint(\"Training the Random Forest Classifier took %3d seconds\"%(end_time-start_time))\n\npredicted_labels = clf.predict(test_x)\nprint(\"DEBUG::The RF predicted labels are::\")\nprint(predicted_labels)\n\nacc_score = accuracy_score(test_y, predicted_labels)\n\nprint(\"DEBUG::The RF testing accuracy score is::\")\nprint(acc_score)","d1959274":"from IPython.display import HTML\ndef create_download_link(title = \"Download file\", filename = \"data.csv\"):  \n    html = '<a href={filename}>{title}<\/a>'\n    html = html.format(title=title,filename=filename)\n    return HTML(html)\n\n#create_download_link(filename='GBMimportances.svg')","248db6f8":"!rm -rf aclImdb\n!rm aclImdb_v1.tar.gz","ea920bb4":"# Download IMDB Movie Review Dataset\nDownload IMDB dataset","fb371fd2":"**Stop-word removal**\n\nStop-words are also removed. Stop-words are words that are very common in text but offer no useful information that can be used to classify the text. Words such as is, and, the, are are examples of stop-words. The NLTK library contains a list of 127 English stop-words and can be used to filter our tokenized strings.","6f9fdc40":"Write requirements to file, anytime you run it, in case you have to go back and recover dependencies.\n\nLatest known such requirements are hosted for each notebook in the companion github repo, and can be pulled down and installed here if needed. Companion github repo is located at https:\/\/github.com\/azunre\/transfer-learning-for-nlp","183ffa2d":"# Define Tokenization, Stop-word and Punctuation Removal Functions\nBefore proceeding, we must decide how many samples to draw from each class. We must also decide the maximum number of tokens per email, and the maximum length of each token. This is done by setting the following overarching hyperparameters","81e97d91":"**Featurize and Create Labels**","0d29cf58":"**Use regular expressions to remove unnecessary characters**\n\nNext, we define a function to remove punctuation marks and other nonword characters (using regular expressions) from the emails with the help of the ubiquitous python regex library. In the same step, we truncate all tokens to hyperparameter maxtokenlen defined above.","d77aa6ac":"# Random Forests","08f6ee7f":"**Tokenization**","d26c4de2":"Display sentiments and their frequencies in the dataset, to ensure it is roughly balanced between classes","d25a2701":"# Assemble Embedding Vectors\n\nThe following functions are used to extract sent2vec embedding vectors for each review","2e8919d9":"# Putting It All Together To Assemble Dataset\n\nNow, putting all the preprocessing steps together we assemble our dataset...","6eb314fa":"# Preliminaries","d8940161":"# Logistic Regression Classifier"}}