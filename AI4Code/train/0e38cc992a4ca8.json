{"cell_type":{"c2f44369":"code","1652fcf3":"code","78187c86":"code","4481a02a":"code","6901ed53":"code","0375a2fb":"code","2f6fbed9":"code","529985d2":"code","db75f91a":"code","43b0ed5c":"code","a2ed0e32":"code","c66a4751":"code","1cb2ab7a":"code","b6942c25":"code","df062b04":"code","1c259369":"code","652fdd38":"code","9376d0a2":"code","bca00062":"code","248e9411":"code","ee6c9e04":"code","d397c59e":"code","74c259ea":"code","b64d32f8":"code","3d0547ca":"code","9201967d":"markdown","dedc5288":"markdown","ab7074b0":"markdown","d069cf99":"markdown","9aa13fda":"markdown","4e060c87":"markdown","40142935":"markdown","5df77666":"markdown","22359e22":"markdown","b09714f8":"markdown","f259a427":"markdown","6e8a640d":"markdown"},"source":{"c2f44369":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nplt.style.use('fivethirtyeight')\nsns.set_style('whitegrid')\n\nfrom string import punctuation\nimport nltk\nfrom nltk.corpus import stopwords\n\n#Preprocessing\nfrom scipy.stats import uniform\nfrom scipy import interp\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn import feature_extraction, linear_model, model_selection, preprocessing\nfrom sklearn.model_selection import train_test_split, RandomizedSearchCV, StratifiedKFold\nfrom sklearn.feature_extraction.text import TfidfTransformer\nfrom sklearn.pipeline import Pipeline\n\n\n#predictive model\nfrom xgboost import XGBClassifier\nfrom sklearn.ensemble import RandomForestClassifier\n\n#metrics\nfrom sklearn.metrics import accuracy_score, classification_report, confusion_matrix, roc_curve, auc\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","1652fcf3":"#get the data\ndf = pd.read_csv('..\/input\/amazon-music-reviews\/Musical_instruments_reviews.csv')","78187c86":"#show the dataframe\ndf.head()","4481a02a":"#show feature data types\ndf.info()","6901ed53":"#show decriptive stats of ratings\ndf.groupby('overall').describe()","0375a2fb":"df.isnull().sum()","2f6fbed9":"plt.figure(figsize=(10,5))\nplt.title('DISTRIBUTION OF RATINGS', fontsize=18)\nsns.countplot(df.overall, palette='deep')\nplt.xlabel('Rating')","529985d2":"#show columns\ndf.columns","db75f91a":"df.drop(['reviewerID', 'asin', 'reviewerName', 'helpful', 'unixReviewTime', 'reviewTime'], axis=1, inplace=True)\n#show new dataframe\ndf.head()","43b0ed5c":"#combining summary and reviewtext feature\ndf['review'] = df['reviewText'] + df['summary']\ndf.drop(['reviewText', 'summary'], axis=1, inplace=True)","a2ed0e32":"#replace the ratings to sentiments\n\ndef num_to_sent(x):\n    if (int(x) == 1 or int(x)==2 or int(x)==3):\n        return 0\n    else:\n        return 1\ndf['overall'] = df.overall.apply(num_to_sent)","c66a4751":"#show value counts\nplt.figure(figsize=(10,5))\nplt.title('COUNTPLOT OF LABELS')\nsns.barplot(df.overall.value_counts().index,df.overall.value_counts().values, palette='deep')","1cb2ab7a":"#get the stopwords and punctuation\nstop = stopwords.words('english')\npunc = list(punctuation)","b6942c25":"#remove stop words\ntext_clean = []\nfor i in range(len(df.review)):\n    char_clean = []\n    for char in str(df['review'][i]).split():\n        char = char.lower()\n        if char not in stop:\n            char_clean.append(char)\n        else:\n            continue\n    char_clean = ' '.join(char_clean)\n    text_clean.append(char_clean)\ndf['review'] = text_clean","df062b04":"#remove punctuations\ntext_clean = []\nfor i in range(len(df.review)):\n    char_clean = []\n    for char in df['review'][i]:\n        char = char.lower()\n        if char not in punc:\n            char_clean.append(char)\n        else:\n            continue\n    char_clean = ''.join(char_clean)\n    text_clean.append(char_clean)\ndf['review'] = text_clean","1c259369":"#show text sample\ndf.review[2]","652fdd38":"#split the data\nX = df.review\ny = df.overall\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=101)","9376d0a2":"\n#RandomSearchCV\n# define the parameters to tune\nparam_dist = {\"learning_rate\": uniform(0, 2),\n              \"gamma\": uniform(1, 0.000001),\n              \"max_depth\": range(1,50),\n              \"n_estimators\": range(1,300),\n              \"min_child_weight\": range(1,10),\n              'n_jobs': range(1,5)}\n#instance of RandomSearchCV\nrs = RandomizedSearchCV(XGBClassifier(), param_distributions=param_dist, n_iter=3) #25 iterations","bca00062":"model  = Pipeline([\n    ('count', CountVectorizer()),\n    ('tfidf', TfidfTransformer()),\n    ('model', rs)\n])","248e9411":"#fit the data\nmodel.fit(X_train, y_train)","ee6c9e04":"#predict the test data\npredictions=model.predict(X_test)","d397c59e":"print('Model Accuracy: ', round(accuracy_score(y_test, predictions)*100,2), '%')","74c259ea":"print(classification_report(y_test, predictions))","b64d32f8":"#roc plot function\ndef plot_roc(X_df, y, estemator,n_splits, lns = 100):\n    #creating an instance of KFold\n    kfold = StratifiedKFold(n_splits=n_splits,shuffle=False)\n    #define estemator\n    rf = estemator\n    #deifne figuresize\n    plt.rcParams['figure.figsize'] = (10,5)\n    \n    tprs = []\n    aucs = []\n    mean_fpr = np.linspace(0,1,lns)\n    i = 1\n\n    for train,test in kfold.split(X,y):\n        #get prediction\n        prediction = rf.fit(X.iloc[train],y.iloc[train]).predict_proba(X.iloc[test])\n        #get the true pos. rate, false positive rate and thresh \n        fpr, tpr, t = roc_curve(y[test], prediction[:, 1])\n        tprs.append(interp(mean_fpr, fpr, tpr))\n        #get the area under the curve\n        roc_auc = auc(fpr, tpr)\n        aucs.append(roc_auc)\n        #plot the tpr and fpr\n        plt.plot(fpr, tpr, lw=2, alpha=0.3, label='ROC fold %d (AUC = %0.2f)' % (i, roc_auc))\n        i= i+1\n\n    #plot the mean ROC\n    plt.plot([0,1],[0,1],linestyle = '--',lw = 2,color = 'black')\n    mean_tpr = np.mean(tprs, axis=0)\n    mean_auc = auc(mean_fpr, mean_tpr)\n    plt.plot(mean_fpr, mean_tpr, color='gold',\n    label=r'Mean ROC (AUC = %0.2f )' % (mean_auc),lw=2, alpha=1)\n\n    #setup the labels\n    plt.legend(bbox_to_anchor=(1, 1))\n    plt.title('ROC PLOT', fontsize=16)\n    plt.xlabel('False Positive Rate', fontsize=12)\n    plt.ylabel('True Positive Rate', fontsize=12)\n","3d0547ca":"from sklearn.ensemble import RandomForestClassifier\nmodel_rf  = Pipeline([\n    ('count', CountVectorizer()),\n    ('tfidf', TfidfTransformer()),\n    ('model', RandomForestClassifier())\n])\n\n#plotting roc curve with 5 number of splits\nplot_roc(X, y, estemator=model_rf, n_splits=5)","9201967d":"> ### DATA CLEANING & FEATURE SELECTION","dedc5288":"#### CLASSIFICATION REPORT","ab7074b0":"#### CHECK NULL VALUES","d069cf99":"## DATA BASIC INFORMATION\n---","9aa13fda":"#### CREATE A DATA PIPELINE","4e060c87":"#### HYPER PARAMETER TUNING","40142935":"## OVERVIEW\n---\n* Text Preprocessing\n* XGBoost HyperParameter Tuning\n* Data Pipeline\n* Plotting ROC Curve\n* Comparison of predictive models.","5df77666":"### XGB CLASSIFIER","22359e22":"## PREDICTIVE MODELLING\n---","b09714f8":"### RANDOM FOREST WITH ROC CURVE","f259a427":"### DATA DISTRIBUTION","6e8a640d":"## TEXT PREPROCESSING\n---"}}