{"cell_type":{"19ad904e":"code","9a10f533":"code","6b410193":"code","c553cf27":"code","628b35cb":"code","284d2c43":"code","4e6353ed":"code","6ad65be1":"code","0c322f0d":"code","d79be436":"code","9432d290":"code","c0a002e6":"code","ca900649":"code","d681b820":"code","79e3a3e9":"code","ab9cbc38":"code","d65d2377":"code","83e57b24":"code","da4a441a":"code","97676385":"code","bfc214a7":"code","c51fe0e1":"code","c4a84c7e":"code","b38ec35f":"code","dad2ed8d":"markdown","d0f97988":"markdown","c871914d":"markdown","017a4a6e":"markdown","4ed619b0":"markdown","f2b0007b":"markdown","b5922439":"markdown","ea336775":"markdown"},"source":{"19ad904e":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\nfrom tqdm import tqdm_notebook as tqdm\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","9a10f533":"fpath = '\/kaggle\/input\/santa-2019-workshop-scheduling\/family_data.csv'\ndata = pd.read_csv(fpath, index_col='family_id')\n\nfpath = '\/kaggle\/input\/santa-2019-workshop-scheduling\/sample_submission.csv'\nsubmission = pd.read_csv(fpath, index_col='family_id')","6b410193":"data.head()","c553cf27":"submission.head()","628b35cb":"family_size_dict = data[['n_people']].to_dict()['n_people']\n\ncols = [f'choice_{i}' for i in range(10)]\nchoice_dict = data[cols].to_dict()\n\nN_DAYS = 100\nMAX_OCCUPANCY = 300\nMIN_OCCUPANCY = 125\n\n# from 100 to 1\ndays = list(range(N_DAYS,0,-1))","284d2c43":"def cost_function(prediction):\n\n    penalty = 0\n\n    # We'll use this to count the number of people scheduled each day\n    daily_occupancy = {k:0 for k in days}\n    \n    # Looping over each family; d is the day for each family f\n    for f, d in enumerate(prediction):\n\n        # Using our lookup dictionaries to make simpler variable names\n        n = family_size_dict[f]\n        choice_0 = choice_dict['choice_0'][f]\n        choice_1 = choice_dict['choice_1'][f]\n        choice_2 = choice_dict['choice_2'][f]\n        choice_3 = choice_dict['choice_3'][f]\n        choice_4 = choice_dict['choice_4'][f]\n        choice_5 = choice_dict['choice_5'][f]\n        choice_6 = choice_dict['choice_6'][f]\n        choice_7 = choice_dict['choice_7'][f]\n        choice_8 = choice_dict['choice_8'][f]\n        choice_9 = choice_dict['choice_9'][f]\n\n        # add the family member count to the daily occupancy\n        daily_occupancy[d] += n\n\n        # Calculate the penalty for not getting top preference\n        if d == choice_0:\n            penalty += 0\n        elif d == choice_1:\n            penalty += 50\n        elif d == choice_2:\n            penalty += 50 + 9 * n\n        elif d == choice_3:\n            penalty += 100 + 9 * n\n        elif d == choice_4:\n            penalty += 200 + 9 * n\n        elif d == choice_5:\n            penalty += 200 + 18 * n\n        elif d == choice_6:\n            penalty += 300 + 18 * n\n        elif d == choice_7:\n            penalty += 300 + 36 * n\n        elif d == choice_8:\n            penalty += 400 + 36 * n\n        elif d == choice_9:\n            penalty += 500 + 36 * n + 199 * n\n        else:\n            penalty += 500 + 36 * n + 398 * n\n\n    # for each date, check total occupancy\n    #  (using soft constraints instead of hard constraints)\n    for _, v in daily_occupancy.items():\n        if (v > MAX_OCCUPANCY) or (v < MIN_OCCUPANCY):\n            penalty += 100000000\n\n    # Calculate the accounting cost\n    # The first day (day 100) is treated special\n    accounting_cost = (daily_occupancy[days[0]]-125.0) \/ 400.0 * daily_occupancy[days[0]]**(0.5)\n    # using the max function because the soft constraints might allow occupancy to dip below 125\n    accounting_cost = max(0, accounting_cost)\n    \n    # Loop over the rest of the days, keeping track of previous count\n    yesterday_count = daily_occupancy[days[0]]\n    for day in days[1:]:\n        today_count = daily_occupancy[day]\n        diff = abs(today_count - yesterday_count)\n        accounting_cost += max(0, (daily_occupancy[day]-125.0) \/ 400.0 * daily_occupancy[day]**(0.5 + diff \/ 50.0))\n        yesterday_count = today_count\n\n    penalty += accounting_cost\n\n    return penalty","4e6353ed":"best = submission['assigned_day'].tolist()\ncost = cost_function(best)\nprint(cost_function(best))","6ad65be1":"%timeit cost_function(best)","0c322f0d":"family_size_ls = list(family_size_dict.values())\nchoice_dict = data[cols].T.to_dict()\nchoice_dict_num = [{vv:i for i, vv in enumerate(di.values())} for di in choice_dict.values()]\n\n# Computer penalities in a list\npenalties_dict = {\n    n: [\n        0,\n        50,\n        50 + 9 * n,\n        100 + 9 * n,\n        200 + 9 * n,\n        200 + 18 * n,\n        300 + 18 * n,\n        300 + 36 * n,\n        400 + 36 * n,\n        500 + 36 * n + 199 * n,\n        500 + 36 * n + 398 * n\n    ]\n    for n in range(max(family_size_dict.values())+1)\n} ","d79be436":"def cost_function(prediction):\n    penalty = 0\n\n    # We'll use this to count the number of people scheduled each day\n    daily_occupancy = np.zeros(N_DAYS + 1)\n    \n    # Looping over each family; d is the day, n is size of that family, \n    # and choice is their top choices\n    for n, d, choice in zip(family_size_ls, prediction, choice_dict_num):\n        # add the family member count to the daily occupancy\n        daily_occupancy[d-1] += n\n\n        # Calculate the penalty for not getting top preference\n        if d not in choice:\n            penalty += penalties_dict[n][-1]\n        else:\n            penalty += penalties_dict[n][choice[d]]\n\n    accounting_cost = 0\n    n_out_of_range = 0\n    daily_occupancy[-1] = daily_occupancy[-2]\n    yesterday_count = daily_occupancy[:-1]\n    today_count = daily_occupancy[1:]\n    diff = np.abs(today_count - yesterday_count)\n    n_out_of_range += np.sum((daily_occupancy > MAX_OCCUPANCY) | (daily_occupancy < MIN_OCCUPANCY))\n    accounting_cost += np.sum(np.clip((daily_occupancy[:-1]-125)\/400.0* daily_occupancy[:-1]**(0.5+diff\/50.0), 0, None))\n    \n    penalty += accounting_cost\n\n    return penalty","9432d290":"assert cost == cost_function(best)","c0a002e6":"%timeit cost_function(best)","ca900649":"from numba import jit, prange\nfrom numba import types, int16, int64, float32, float64","d681b820":"choice_arr = []\nfor choice in choice_dict_num:\n    c = [None for _ in choice]\n    for k in choice:\n        c[choice[k]] = k\n    choice_arr.append(c)\nchoice_arr = np.array(choice_arr, dtype=np.int64)\n\nfamily_size_arr = np.array(family_size_ls, dtype=np.int64)\n\npenalties_arr = [None for i in range(max(penalties_dict.keys())+1)]\nfor k in penalties_dict:\n    penalties_arr[k] = penalties_dict[k]\npenalties_arr = np.array(penalties_arr, dtype=np.float32)\n\n@jit(parallel=False)\ndef cost_function(prediction, choice, family_size, penalties):\n    penalty = 0.\n\n    # We'll use this to count the number of people scheduled each day\n    daily_occupancy = [0 for k in range(N_DAYS + 1)]\n    \n    # Looping over each family; d is the day, n is size of that family, \n    # and choice is their top choices\n    for i in prange(5000):\n        # add the family member count to the daily occupancy\n        daily_occupancy[prediction[i]-1] += family_size[i]\n        \n        # Calculate the penalty for not getting top preference\n        idx = 10\n        for j in range(10):\n            if prediction[i] == choice[i,j]:\n                idx = j\n        penalty += penalties_arr[family_size[i],idx]\n\n    accounting_cost = 0\n    n_out_of_range = 0\n    daily_occupancy[-1] = daily_occupancy[-2]\n    for day in range(N_DAYS):\n        n_next = daily_occupancy[day + 1]\n        n = daily_occupancy[day]\n        n_out_of_range += (n > MAX_OCCUPANCY) or (n < MIN_OCCUPANCY)\n        diff = abs(n - n_next)\n        accounting_cost += max(0, (n-125.0) \/ 400.0 * n**(0.5 + diff \/ 50.0))\n\n    penalty += accounting_cost\n\n    return penalty","79e3a3e9":"best = np.array(best)\nassert cost == cost_function(best, choice_arr, family_size_arr, penalties_arr)","ab9cbc38":"%timeit cost_function(best, choice_arr, family_size_arr, penalties_arr)","d65d2377":"def compute_cost_change(prediction, daily_occupancy, family_id, new_choice):\n    penalty = 0\n    \n    # old penalty\n    size = family_size_ls[family_id]\n    old_choice = prediction[family_id]\n    choice = choice_dict_num[family_id]\n    if old_choice not in choice:\n        penalty -= penalties_dict[size][-1]\n    else:\n        penalty -= penalties_dict[size][choice[old_choice]]\n        \n    # new penalty\n    if new_choice not in choice:\n        penalty += penalties_dict[size][-1]\n    else:\n        penalty += penalties_dict[size][choice[new_choice]]\n\n    old_accounting_cost = 0\n    n_out_of_range = 0\n    daily_occupancy = [_ for _ in daily_occupancy]\n    daily_occupancy[-1] = daily_occupancy[-2]\n\n    for d in set((old_choice-1, old_choice, new_choice-1, new_choice)):\n        if d < 1: continue\n        n_next = daily_occupancy[d]\n        n = daily_occupancy[d-1]\n        n_out_of_range -= (n > MAX_OCCUPANCY) or (n < MIN_OCCUPANCY)\n        diff = abs(n - n_next)\n        old_accounting_cost += max(0, (n-125.0) \/ 400.0 * n**(0.5 + diff \/ 50.0))\n        \n    new_accounting_cost = 0\n    daily_occupancy[old_choice-1] -= size\n    daily_occupancy[new_choice-1] += size\n    daily_occupancy[-1] = daily_occupancy[-2]\n    \n    for d in list(set((old_choice-1, old_choice, new_choice-1, new_choice))):\n        if d < 1: continue\n        n_next = daily_occupancy[d]\n        n = daily_occupancy[d-1]\n        n_out_of_range += (n > MAX_OCCUPANCY) or (n < MIN_OCCUPANCY)\n        diff = abs(n - n_next)\n        new_accounting_cost += max(0, (n-125.0) \/ 400.0 * n**(0.5 + diff \/ 50.0))\n    \n    penalty += new_accounting_cost - old_accounting_cost + n_out_of_range * 1000000\n\n    return penalty","83e57b24":"best = submission['assigned_day'].tolist()\ncost0 = cost_function(best, choice_arr, family_size_arr, penalties_arr)\nnew = best.copy()\nnew[0] = 1\ncost1 = cost_function(new, choice_arr, family_size_arr, penalties_arr)\ndiff = cost1 - cost0\nprint(diff)","da4a441a":"best = submission['assigned_day'].tolist()\ndaily_occupancy = np.zeros(N_DAYS + 1, dtype=np.int)\nfor i in prange(len(best)):\n    # add the family member count to the daily occupancy\n    daily_occupancy[best[i]-1] += family_size_arr[i]\nprint(compute_cost_change(best, daily_occupancy, 0, 1))\nprint(abs(diff - compute_cost_change(best, daily_occupancy, 0, 1)))\nassert abs(diff - compute_cost_change(best, daily_occupancy, 0, 1)) < 1e-6","97676385":"%timeit compute_cost_change(best, daily_occupancy, 0, 1)","bfc214a7":"choice_arr = []\nfor choice in choice_dict_num:\n    c = [None for _ in choice]\n    for k in choice:\n        c[choice[k]] = k\n    choice_arr.append(c)\nchoice_arr = np.array(choice_arr, dtype=np.int64)\n\nfamily_size_arr = np.array(family_size_ls, dtype=np.int64)\n\npenalties_arr = [None for i in range(max(penalties_dict.keys())+1)]\nfor k in penalties_dict:\n    penalties_arr[k] = penalties_dict[k]\npenalties_arr = np.array(penalties_arr, dtype=np.float32)\n\n@jit(nopython=True)\ndef compute_cost_change(prediction, choice, family_size, penalties, daily_occupancy, family_id, new_choice):\n    penalty = 0.\n    \n    # old penalty\n    size = family_size[family_id]\n    old_choice = prediction[family_id]\n    \n    idx0 = 10\n    idx1 = 10\n    for j in range(10):\n        if old_choice == choice[family_id, j]:\n            idx0 = j\n        if new_choice == choice[family_id, j]:\n            idx1 = j\n    penalty += penalties[size,idx1] - penalties[size,idx0]\n    \n    old_accounting_cost = 0\n    n_out_of_range = 0\n    daily_occupancy = [_ for _ in daily_occupancy]\n    daily_occupancy[-1] = daily_occupancy[-2]\n\n    for d in set((old_choice-1, old_choice, new_choice-1, new_choice)):\n        if d < 1: continue\n        n_next = daily_occupancy[d]\n        n = daily_occupancy[d-1]\n        n_out_of_range -= (n > MAX_OCCUPANCY) or (n < MIN_OCCUPANCY)\n        diff = abs(n - n_next)\n        old_accounting_cost += max(0, (n-125.0) \/ 400.0 * n**(0.5 + diff \/ 50.0))\n        \n    new_accounting_cost = 0\n    daily_occupancy[old_choice-1] -= size\n    daily_occupancy[new_choice-1] += size\n    daily_occupancy[-1] = daily_occupancy[-2]\n    \n    for d in list(set((old_choice-1, old_choice, new_choice-1, new_choice))):\n        if d < 1: continue\n        n_next = daily_occupancy[d]\n        n = daily_occupancy[d-1]\n        n_out_of_range += (n > MAX_OCCUPANCY) or (n < MIN_OCCUPANCY)\n        diff = abs(n - n_next)\n        new_accounting_cost += max(0, (n-125.0) \/ 400.0 * n**(0.5 + diff \/ 50.0))\n    \n    penalty += new_accounting_cost - old_accounting_cost + n_out_of_range * 1000000\n\n    return penalty","c51fe0e1":"best = submission['assigned_day'].values\ncost0 = cost_function(best, choice_arr, family_size_arr, penalties_arr)\nnew = best.copy()\nnew[0] = 1\ncost1 = cost_function(new, choice_arr, family_size_arr, penalties_arr)\ndiff = cost1 - cost0\nprint(diff)\n\ndaily_occupancy = np.zeros(N_DAYS + 1, dtype=np.int)\nfor i in prange(len(best)):\n    # add the family member count to the daily occupancy\n    daily_occupancy[best[i]-1] += family_size_arr[i]\nprint(compute_cost_change(best, choice_arr, family_size_arr, penalties_arr, daily_occupancy, 0, 1))\nassert abs(diff - compute_cost_change(best, choice_arr, family_size_arr, penalties_arr, daily_occupancy, 0, 1)) < 1e-6","c4a84c7e":"best = submission['assigned_day'].values\ncost0 = cost_function(best, choice_arr, family_size_arr, penalties_arr)\nnew = best.copy()\nnew[0] = 99\ncost1 = cost_function(new, choice_arr, family_size_arr, penalties_arr)\ndiff = cost1 - cost0\nprint(diff)\n\ndaily_occupancy = np.zeros(N_DAYS + 1, dtype=np.int)\nfor i in prange(len(best)):\n    # add the family member count to the daily occupancy\n    daily_occupancy[best[i]-1] += family_size_arr[i]\nprint(compute_cost_change(best, choice_arr, family_size_arr, penalties_arr, daily_occupancy, 0, 99))\nassert abs(diff - compute_cost_change(best, choice_arr, family_size_arr, penalties_arr, daily_occupancy, 0, 99)) < 1e-6","b38ec35f":"%timeit compute_cost_change(best, choice_arr, family_size_arr, penalties_arr, daily_occupancy, 0, 99)","dad2ed8d":"## python based cost_function","d0f97988":"## Create some lookup dictionaries and define constants\n\nYou don't need to do it this way. :-)","c871914d":"## Original cost_function\n\nOriginal cost_funciton from the starter notebook.","017a4a6e":"## compute cost change only (numba)","4ed619b0":"## Numba based cost_function","f2b0007b":"## compute cost change only","b5922439":"(Excellent) Original Kernel: https:\/\/www.kaggle.com\/inversion\/santa-s-2019-starter-notebook and\nhttps:\/\/www.kaggle.com\/xhlulu\/santa-s-2019-4x-faster-cost-function\n\nExplored different `cost_function` approaches to make it run fast. Using numba, evaluation of the whole prediction can be lowered as 70 us. By only evaluating the cost change of the new choice, the cost evaluation can be done in less than 10 us.","ea336775":"## Read in the family information and sample submission"}}