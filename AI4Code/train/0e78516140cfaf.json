{"cell_type":{"fa9256a0":"code","3a24ae73":"code","e2dd2ecf":"code","51c5f24a":"code","1fac2e6d":"code","b10d92bd":"code","e14e1ae2":"code","1120fa51":"code","a5599ade":"code","164442b6":"code","1f47ba48":"code","1f1069ca":"code","5757791e":"markdown","7efdf26b":"markdown","881e8b38":"markdown","375843aa":"markdown","374b9824":"markdown","fb9528ad":"markdown","26aacf56":"markdown"},"source":{"fa9256a0":"\nimport numpy as np \nimport pandas as pd \nimport os\n\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import log_loss\n \nimport tensorflow as tf\nimport tensorflow_addons as tfa\nimport tensorflow.keras.backend as K\nimport tensorflow.keras.layers as L\nimport tensorflow.keras.models as M","3a24ae73":"test_df = pd.read_csv('..\/input\/lish-moa\/test_features.csv')\ntrain_df = pd.read_csv('..\/input\/lish-moa\/train_features.csv')\ntrain_target_df = pd.read_csv('..\/input\/lish-moa\/train_targets_scored.csv')\nsub = pd.read_csv('..\/input\/lish-moa\/sample_submission.csv')\n\ntarget_cols = train_target_df.columns[1:]\nN_TARGETS = len(target_cols)","e2dd2ecf":"SEED = 2020\nEPOCHS = 30\nBATCH_SIZE = 128\nFOLDS = 5\nREPEATS = 5\nLR = 0.00045\nN_TARGETS = len(target_cols)","51c5f24a":"def seed_everything(seed):\n    np.random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    tf.random.set_seed(seed)","1fac2e6d":"def multi_log_loss(y_true, y_pred):\n    losses = []\n    for col in y_true.columns:\n        losses.append(log_loss(y_true.loc[:, col], y_pred.loc[:, col]))\n    return np.mean(losses)","b10d92bd":"def preprocess_df(data):\n    data['cp_type'] = (data['cp_type'] == 'trt_cp').astype(int)\n    data['cp_dose'] = (data['cp_dose'] == 'D2').astype(int)\n    return data","e14e1ae2":"x_train = preprocess_df(train_df.drop(columns=\"sig_id\"))\nx_test =preprocess_df(test_df.drop(columns=\"sig_id\"))\ny_train = train_target_df.drop(columns=\"sig_id\")\nN_FEATURES = x_train.shape[1]","1120fa51":"def create_model():\n    model = tf.keras.Sequential([\n    tf.keras.layers.Input(N_FEATURES),\n    tf.keras.layers.BatchNormalization(),\n    tf.keras.layers.Dropout(0.3),\n    tfa.layers.WeightNormalization(tf.keras.layers.Dense(1024, activation=\"relu\")),\n    tf.keras.layers.BatchNormalization(),\n    tf.keras.layers.Dropout(0.4),\n    #tfa.layers.WeightNormalization(tf.keras.layers.Dense(1024, activation=\"relu\")),\n    #tf.keras.layers.BatchNormalization(),\n    #tf.keras.layers.Dropout(0.4),\n    tfa.layers.WeightNormalization(tf.keras.layers.Dense(1024, activation=\"relu\")),  \n    tf.keras.layers.BatchNormalization(),\n    tf.keras.layers.Dropout(0.3),\n    tfa.layers.WeightNormalization(tf.keras.layers.Dense(N_TARGETS, activation=\"sigmoid\"))\n    ])\n    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate = LR), loss='binary_crossentropy', metrics=[\"accuracy\"])\n    return model","a5599ade":"def build_train(resume_models = None, repeat_number = 0, folds = 7, skip_folds = 0):\n    \n    models = []\n    oof_preds = y_train.copy()\n    \n\n    kfold = KFold(folds, shuffle = True)\n    for fold, (train_ind, val_ind) in enumerate(kfold.split(x_train)):\n        print('\\n')\n        print('-'*50)\n        print(f'Training fold {fold + 1}')\n        \n        cb_lr_schedule = tf.keras.callbacks.ReduceLROnPlateau(monitor = 'binary_crossentropy', factor = 0.4, patience = 2, verbose = 1, min_delta = 0.0001, mode = 'auto')\n        checkpoint_path = f'repeat:{repeat_number}_Fold:{fold}.hdf5'\n        cb_checkpt = tf.keras.callbacks.ModelCheckpoint(checkpoint_path, monitor = 'val_loss', verbose = 0, save_best_only = True, save_weights_only = True, mode = 'min')\n\n        model = create_model()\n        model.fit(x_train.values[train_ind],\n              y_train.values[train_ind],\n              validation_data=(x_train.values[val_ind], y_train.values[val_ind]),\n              callbacks = [cb_lr_schedule, cb_checkpt],\n              epochs=EPOCHS, batch_size=BATCH_SIZE, verbose=2\n             )\n        model.load_weights(checkpoint_path)\n        oof_preds.loc[val_ind, :] = model.predict(x_train.values[val_ind])\n        models.append(model)\n\n    return models, oof_preds","164442b6":"models = []\noof_preds = []\n# seed everything\nseed_everything(SEED)\nfor i in range(REPEATS):\n    m, oof = build_train(repeat_number = i, folds=FOLDS)\n    models = models + m\n    oof_preds.append(oof)\n\n","1f47ba48":"mean_oof_preds = y_train.copy()\nmean_oof_preds.loc[:, target_cols] = 0\nfor i, p in enumerate(oof_preds):\n    print(f\"Repeat {i + 1} OOF Log Loss: {multi_log_loss(y_train, p)}\")\n    mean_oof_preds.loc[:, target_cols] += p[target_cols]\n\nmean_oof_preds.loc[:, target_cols] \/= len(oof_preds)\nprint(f\"Mean OOF Log Loss: {multi_log_loss(y_train, mean_oof_preds)}\")\nmean_oof_preds.loc[x_train['cp_type'] == 0, target_cols] = 0\nprint(f\"Mean OOF Log Loss (ctl adjusted): {multi_log_loss(y_train, mean_oof_preds)}\")","1f1069ca":"test_preds = sub.copy()\ntest_preds[target_cols] = 0\nfor model in models:\n    test_preds.loc[:,target_cols] += model.predict(x_test)\ntest_preds.loc[:,target_cols] \/= len(models)\ntest_preds.loc[x_test['cp_type'] == 0, target_cols] = 0\ntest_preds.to_csv('submission.csv', index=False)","5757791e":"### Encode Categoricals to Binary","7efdf26b":"### Define Model Architecture","881e8b38":"### Main CV and Model Training Function","375843aa":"### Make Test Predictions and Save Submission","374b9824":"### Import Libraries","fb9528ad":"### Read Data","26aacf56":"### Basic Setup and Helpers"}}