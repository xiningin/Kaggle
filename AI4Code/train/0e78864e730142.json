{"cell_type":{"a2d29a19":"code","7ece6ea1":"code","6e368aeb":"code","c6b209c8":"code","bce365ec":"code","69d8d757":"code","725379a2":"code","81333cb1":"code","ed846c2c":"code","15b7f38b":"code","e62c15dd":"code","c79b4cd3":"code","875f4223":"code","e6d2950e":"code","ded786f1":"code","85a24548":"code","f95a672c":"code","72c36c0e":"markdown","f1e6cafe":"markdown","eee72f46":"markdown","b22b59b9":"markdown","3680f56a":"markdown","22252a1c":"markdown","9f0bd5b5":"markdown","e66fb80f":"markdown","2eb593ba":"markdown","bff67019":"markdown","37e4b5d9":"markdown","07be41e2":"markdown","6f737928":"markdown","25d012f3":"markdown","d0ae3ca4":"markdown","7a0aba17":"markdown","94d2a2cb":"markdown","331cc073":"markdown","b35d0ede":"markdown","ac28cae2":"markdown","fafdf6a6":"markdown","f6e61733":"markdown"},"source":{"a2d29a19":"%reset","7ece6ea1":"import datetime\nimport os\nimport random\nimport numpy as np\nimport pandas as pd\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom scipy.io import loadmat\nfrom scipy import signal\nfrom scipy.signal import medfilt\nimport pywt\nfrom pywt import wavedec\n# >---------------------------------------------------------------------\n\n# >------ parent db directory ------------------------------------------\nDATASET_DIR = '..\/input\/shaoxing-and-ningbo-first-hospital-database\/WFDB_ShaoxingUniv'\nprint('DATASET DIR ::',DATASET_DIR)\n\n# >------ global variables  ------------------------------------------\ng_DATA = '.mat'\ng_HEAD = '.hea'\ng_leads = ['I','II','III','aVR','aVL','aVF','V1','V2','V3','V4','V5','V6' ]\nBASIC_SRATE = 500 #Hz\nprint('Basic sampling rate(Hz):',BASIC_SRATE)","6e368aeb":"rec_list = os.listdir(DATASET_DIR)\nrec_count = 0 \nrec_count_expected = int(len(rec_list)\/2)\nrec_name_sep = ','\nrec_file = open('RECORDS.csv','w')\nrec_file.write(str(rec_count_expected))\nfor f in rec_list:\n    if f.endswith(g_HEAD):\n        rec_name = f[0:-4]\n        rec_file.write(rec_name_sep+rec_name) #<---- use skiprows=1 in np.loadtxt()\n        rec_count+=1\nrec_file.close()\nassert(rec_count_expected == rec_count) # should be equal )\nprint(rec_count)","c6b209c8":"load_txt = np.loadtxt('.\/RECORDS.csv', delimiter=',', dtype='str')\nrec_count = int(load_txt[0])\nrec_list = load_txt[1:]\nprint(rec_count,len(rec_list))","bce365ec":"class ecg_segment:\n    # represent a 10 sec signal of ecg from 12 leads\n    \n    def __init__(self, seg_name):\n        self.name = seg_name\n        self.file_mat = os.path.join(DATASET_DIR,self.name+'.mat')\n        self.file_hea = os.path.join(DATASET_DIR,self.name+'.hea')\n        self.load_data()\n        self.load_header()\n        \n        \n    def load_data(self):\n        self.signals=loadmat(self.file_mat)['val'].astype(np.float64)\n        self.signald = {}\n        for i in range(0,len(g_leads)):\n            self.signald[g_leads[i]] = self.signals[i,:]\n        # an array of shape (12, 5000) each row is a lead in g_leads\n        return\n    \n    def load_header(self):\n        with open(self.file_hea,'r') as f:\n            hlines=f.readlines() # each line ends with newline char\n            #JS34506 12 500 5000 28-Mar-2021 04:58:01  \n            #0    (6x1) < from row0 extract everything\n            tl = (hlines[0][0:-1]).split(\" \")\n            assert (tl[0] == self.name)\n            assert (tl[1] == '12')\n            assert (tl[2] == '500')\n            assert (tl[3] == '5000')\n            #self.timestamp = datetime.datetime.strptime(\"%d-%b-%Y_%H:%M:%S\", tl[4]+'_'+tl[5])\n            for i in range(1,12):\n                assert ((hlines[i][0:-1]).split(\" \")[8] == g_leads[i-1])\n                assert ((hlines[i][0:-1]).split(\" \")[8] == g_leads[i-1])\n                \n            self.age = int(hlines[13][0:-1].split(\" \")[1])\n            self.gender = hlines[14][0:-1].split(\" \")[1]\n            self.Dx = (hlines[15][0:-1].split(\" \")[1])\n            self.Rx = (hlines[16][0:-1].split(\" \")[1])\n            self.Hx = (hlines[17][0:-1].split(\" \")[1])\n            self.Sx = (hlines[18][0:-1].split(\" \")[1])\n            \n        return \n    \n    def info(self):\n        print(self.name,self.gender,self.age)\n        return","69d8d757":"recn = np.random.choice(rec_list, size=1)[0]  # total records = rec_count\necg = ecg_segment(recn)\necg.info()\n","725379a2":"_lr,_lc = 3,4\n_leads = [\n    [['I'],['aVR'],['V1'],['V4']],\n    [['II'],['aVL'],['V2'],['V5']],\n    [['III'],['aVF'],['V3'],['V6']]\n]\n\n\nfig,ax = plt.subplots(_lr,_lc, figsize=(_lr*7,_lc*4))\n#fig.set_dpi(150)\nfor i in range(0,3):\n    for j in range(0,4):\n        _key = _leads[i][j][0]\n        ax[i,j].set_title(_key)\n        ax[i,j].plot(ecg.signald[_key], color='black', linewidth=0.6)\n        ax[i,j].set_ylim((-1500,1500))\n        ax[i,j].set_xlim((0,5000))\n        ax[i,j].hlines(0,0,5000,color='black',linestyle='dotted')\n\n\nplt.show()","81333cb1":"fig,ax = plt.subplots(12,1, figsize=(20,12*4))\n#fig.set_dpi(150)\nfor i in range(0,12):\n    _key = g_leads[i]\n    #ax[i].set_title(_key)\n    ax[i].plot(ecg.signald[_key], color='black', linewidth=0.6)\n    ax[i].set_ylim((-1500,1500))\n    ax[i].set_xticks(   np.arange(0,5001,500)  )   \n    ax[i].set_xticklabels(   np.arange(0,5001,500)\/BASIC_SRATE  )   \n    ax[i].grid(axis='x')\n    ax[i].annotate(_key,(-200,0))\n    #ax[i].set_xlabel('Time(sec)')\n    #ax[i].set_ylabel('mV')\n    ax[i].hlines(0,0,5000,color='black', linewidth=0.3)\n\n\nplt.show()","ed846c2c":"signal = ecg.signald['I']  #<<---- choosen Lead\n\nplt.figure(figsize=(40,6))\nplt.plot(signal, color='black', linewidth=0.6)\nplt.hlines(0,0,5000,color='black', linewidth=0.3)","15b7f38b":"def denoise_signal(X, dwt_transform, dlevels, cutoff_low, cutoff_high):\n    coeffs = wavedec(X, dwt_transform, level=dlevels)   # wavelet transform 'bior4.4'\n    # scale 0 to cutoff_low \n    for ca in range(0,cutoff_low):\n        coeffs[ca]=np.multiply(coeffs[ca],[0.0])\n    # scale cutoff_high to end\n    for ca in range(cutoff_high, len(coeffs)):\n        coeffs[ca]=np.multiply(coeffs[ca],[0.0])\n    Y = pywt.waverec(coeffs, dwt_transform) # inverse wavelet transform\n    return Y  \n\n\nsignal_den = denoise_signal(signal,'bior4.4', 9 , 1 , 7) #<--- trade off - the less the cutoff - the more R-peak morphology is lost\nplt.figure(figsize=(40,6))\n\nplt.plot(signal, color='tab:olive', linewidth=0.6,label = 'input')\nplt.plot(signal_den, color='black', linewidth=0.9,label = 'denoised')\nplt.hlines(0,0,5000,color='black', linewidth=0.4)\nplt.legend()\nplt.show()\n\nplt.figure(figsize=(40,6))\nplt.plot(signal_den, color='black', linewidth=0.9,label = 'denoised')\nplt.fill_between(np.arange(0,5000,1),signal,signal_den,color='gold',label = 'diff')\nplt.hlines(0,0,5000,color='black', linewidth=0.4)\nplt.legend()\nplt.show()","e62c15dd":"def get_median_filter_width(sampling_rate, duration):\n    res = int( sampling_rate*duration )\n    res += ((res%2) - 1) # needs to be an odd number\n    return res\n# baseline fitting by filtering\n# === Define Filtering Params for Baseline fitting Leads======================\nms_flt_array = [0.2,0.6]    #<-- length of baseline fitting filters (in seconds)\nmfa = np.zeros(len(ms_flt_array), dtype='int')\nfor i in range(0, len(ms_flt_array)):\n    mfa[i] = get_median_filter_width(BASIC_SRATE,ms_flt_array[i])\n\ndef filter_signal(X):\n    global mfa\n    X0 = X  #read orignal signal\n    for mi in range(0,len(mfa)):\n        X0 = medfilt(X0,mfa[mi]) # apply median filter one by one on top of each other\n    X0 = np.subtract(X,X0)  # finally subtract from orignal signal\n    return X0\n\n\n\nsignal_flt = filter_signal(signal_den)\nplt.figure(figsize=(40,6))\n\nplt.plot(signal_den, color='tab:purple', linewidth=0.6,label = 'input')\nplt.plot(signal_flt, color='black', linewidth=0.9,label = 'filtered')\nplt.hlines(0,0,5000,color='black', linewidth=0.4)\nplt.legend()\nplt.show()\n\nplt.figure(figsize=(40,6))\nplt.plot(signal_flt, color='black', linewidth=0.9,label = 'filtered')\nplt.fill_between(np.arange(0,5000,1),signal_den,signal_flt,color='tab:pink',label = 'diff')\nplt.hlines(0,0,5000,color='black', linewidth=0.4)\nplt.legend()\nplt.show()","c79b4cd3":"s1 = denoise_signal(filter_signal(signal),'bior4.4', 9 , 1 , 7) # first filtered then denoised\ns2 = filter_signal(denoise_signal(signal,'bior4.4', 9 , 1 , 7)) #first denoised then filtered\n\nplt.figure(figsize=(40,6))\n\n#plt.plot(signal, color='black', linewidth=0.4,label = 'input')\nplt.fill_between(np.arange(0,5000,1),s1,s2,color='gold',label = 'diff')\nplt.plot(s1, color='red',label = 'flt->den')\nplt.plot(s2, color='black',label = 'den->flt')\nplt.hlines(0,0,5000,color='black', linewidth=0.4)\nplt.legend()\nplt.show()","875f4223":"pip install py-ecg-detectors","e6d2950e":"from ecgdetectors import Detectors\ndetectors = Detectors(BASIC_SRATE)","ded786f1":"signal_pad_samples = 10\nsignal_pad = np.zeros(signal_pad_samples) # pad one sec to detect initial peaks properly\nsignalf = signal_flt\ndetectors = Detectors(BASIC_SRATE)\n\ndetectors = {\n            'pan_tompkins_detector':[detectors.pan_tompkins_detector, []],\n            'hamilton_detector':[detectors.hamilton_detector, []],\n            'christov_detector':[detectors.christov_detector, []],\n            'engzee_detector':[detectors.engzee_detector, []],\n            'swt_detector':[detectors.swt_detector, []],\n            'two_average_detector':[detectors.two_average_detector, []],\n            }\n\n\nfor kd in detectors.keys():\n    vd = detectors[kd]\n    r_peaks = np.array(vd[0](np.hstack((signal_pad,signal_flt)))) - signal_pad_samples\n    vd[1] = r_peaks\n    plt.figure(figsize=(40,6))\n    plt.title(kd)\n    plt.plot(signalf,color='tab:blue',linewidth=0.8)\n    plt.hlines(0,0,5000,color='black', linewidth=0.4)\n    plt.xticks(r_peaks)\n    plt.grid(axis='x')\n    plt.show()\n\n\n","85a24548":"print(detectors.keys())","f95a672c":"data_signal = signalf\ndata_peaks = detectors['christov_detector'][1]\n\nplt.figure(figsize=(40,6))\nplt.title('Orignal ECG Data')\nplt.plot(signal,color='black',linewidth=0.8)\nplt.hlines(0,0,5000,color='black', linewidth=0.4)\nplt.xticks(data_peaks)\nplt.grid(axis='x')\nplt.show()\n\nplt.figure(figsize=(40,6))\nplt.title('Final ECG Data')\nplt.plot(data_signal,color='black',linewidth=0.8)\nplt.hlines(0,0,5000,color='black', linewidth=0.4)\nplt.xticks(data_peaks)\nplt.grid(axis='x')\nplt.show()\n\n","72c36c0e":"# Raw Signal View","f1e6cafe":"# ECG Pre-Processing\n\n**This note book demonstrates the following pre-processing techniques on ECG signals:**\n * Denoising\n * Baseline Fitting\n * R-Peak Detection \n ","eee72f46":"# The End","b22b59b9":"**Remarks**\n\n* This is a fair amount of denoising without loss of peak morphology\n* One may try changing the wavelet tranform arguments (dwt_transform, dlevels, cutoff_low, cutoff_high)\n* Wavelet transform seems to have an effect on the baseline","3680f56a":"# [1] Load record list","22252a1c":"# Which one to do first - Denoise or Fit baseline ?\n\n* Does it make a difference?","9f0bd5b5":"**Concluding Remarks**\n\n**Steps of ECG Preprocessing**\n * Denoising - Denoised ECG using bior4.4 wavelet transform - there is a trade off between 'cutoff' limits and preservation of wave morphology\n * Baseline Wander - Fitted baseline using Median Filters of 200ms and 600ms - fitting baseline after denoising seems to work better\n * Peak Detection - Tried various known R-peak detection algorithms - christov_detector seem to work best for most records\n \n \n*TODO*\n * Beats are not labeled, try testing with previous models and assert the results manually ","e66fb80f":"# [2] Select a record","2eb593ba":"**Remarks**\n\n* **christov_detector** seems to work the best for most cases\n* results vary for different leads and patients","bff67019":"# Remove Baseline Wander\n\n* using median filtering - use 200ms filter followed by 600ms filter","37e4b5d9":"# Final Data","07be41e2":"# R-Peak Detection\n\n* https:\/\/pypi.org\/project\/py-ecg-detectors\/","6f737928":"# [2.2] Plot Horizontally","25d012f3":"# Detect R-Peaks\n\n* using known algorithms","d0ae3ca4":"# Denoise\n\n* use bior4.4 wavelet transform","7a0aba17":"**Remarks**\n\n* Baseline seems to be fitted fairly\n* we first denoised the signal and then fitted the baseline","94d2a2cb":"# [*] Build record list\n\n* **one time call to build and export the record list**","331cc073":"**Remarks:**\n\n1. Data is Noisy\n2. Baseline Wander Present","b35d0ede":"# [*] Represent records as objects\n\n* **load signal data**\n* **prepare a dictionary of 'lead name' v\/s 'signal data'**\n* **load header files**\n* **extract and verify relevant header data**","ac28cae2":"**Remarks**\n\n* Denoising first and then fitting the baseline seems to work better","fafdf6a6":"# [2.1] Plot Signal in Traditional Format\n\n![](https:\/\/upload.wikimedia.org\/wikipedia\/commons\/3\/33\/Contiguous_leads.svg)","f6e61733":"# [0] Global"}}