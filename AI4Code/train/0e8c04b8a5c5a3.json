{"cell_type":{"1005dc76":"code","f4a1c257":"code","e6348206":"code","2fd71230":"code","14be9a55":"code","f51b3457":"code","8d75ccfd":"code","614cb50c":"code","9faff977":"code","9da22c46":"code","64b2d245":"code","9d43536f":"code","04400c76":"markdown","5f486389":"markdown","64eeedee":"markdown","5c656c8f":"markdown"},"source":{"1005dc76":"from tensorflow.keras.applications.xception import Xception\nfrom tensorflow.keras.preprocessing import image\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.layers import Dense, GlobalAveragePooling2D,LeakyReLU,Input\nimport tensorflow as tf\nfrom PIL import Image\nimport numpy as np\nimport glob\nfrom keras_preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.callbacks import Callback, ReduceLROnPlateau, ModelCheckpoint, TensorBoard\nimport gc\nfrom tensorflow.keras.optimizers import Adam\nimport pandas as pd #\nimport json\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","f4a1c257":"KAGGLE=True\nPATH=\"\/kaggle\/input\/cassava-leaf-disease-classification\/\" if KAGGLE else \".\/\"\nTRAIN_PATH=PATH+\"train_images\/\"\nTEST_PATH=PATH+\"test_images\/\"\n\n\n\nn_classes=5\nimg_size=(512,512)\nbatch_size=32\ncolor_channels=3\n\ntop_epochs=3\nfine_tuning_epochs=5","e6348206":"train_df=pd.read_csv('\/kaggle\/input\/cassava-leaf-disease-classification\/train.csv')\ntrain_df[\"label\"] = train_df[\"label\"].astype(\"string\")\n\ntrain_df","2fd71230":"y=pd.get_dummies(train_df.label)\ny","14be9a55":"train_datagen = ImageDataGenerator(\n    rescale=1.\/255,\n    shear_range=0.2,\n    zoom_range=0.2,\n    rotation_range=90,\n    width_shift_range = 0.2,\n    height_shift_range = 0.2, \n    horizontal_flip=True,\n    fill_mode=\"nearest\",\n    vertical_flip=True,\n    brightness_range=[0.5,1.5],\n    validation_split=0.2\n\n)\n    \ntest_datagen = ImageDataGenerator(rescale=1.\/255,validation_split=0.2)\n\ntrain_generator = train_datagen.flow_from_dataframe(\n    train_df,\n    TRAIN_PATH,\n    target_size=img_size,\n    batch_size=batch_size,\n    class_mode='categorical',\n    x_col = \"image_id\",\n    y_col = \"label\",\n    shuffle = True,\n    seed=42,\n    subset = \"training\"\n)\n\nvalidation_generator = test_datagen.flow_from_dataframe(\n    train_df,\n    TRAIN_PATH,\n    target_size=img_size,\n    batch_size=batch_size,\n    class_mode='categorical',\n    x_col = \"image_id\",\n    y_col = \"label\",\n    shuffle = True,\n    subset = \"validation\",\n    seed=42\n\n)","f51b3457":"optimizer = Adam(learning_rate=0.001)\ncheckpoint = ModelCheckpoint(\".\/best_model\", monitor='val_accuracy', verbose=1, save_best_only=True,mode='max')\nreduce_lr = ReduceLROnPlateau(\n                    monitor='val_loss', \n                    factor=0.5,\n                    patience= 2, \n                    verbose = 1,\n                    cooldown = 1,\n                    min_lr=0.0001)\n","8d75ccfd":"new_input = Input(shape=(img_size[0],img_size[1], color_channels))","614cb50c":"base=Xception(weights='imagenet',include_top=False,\n                 input_tensor=new_input)\nx=base.output\npooling=GlobalAveragePooling2D()(x)\nout=Dense(1024)(pooling)\nout=LeakyReLU(alpha=0.2)(out)\nout=Dense(n_classes,activation=\"softmax\")(out)\nmodel=Model(inputs=base.input,outputs=out)\nmodel.summary()","9faff977":"for layer in base.layers:\n    layer.trainable=False","9da22c46":"model.compile(optimizer=optimizer,loss='categorical_crossentropy',metrics=['accuracy'])","64b2d245":"epochs=10","9d43536f":"history = model.fit(\n    train_generator,\n    epochs = epochs,\n    validation_data = validation_generator,\n    verbose = 1,\n    callbacks = [\n        reduce_lr,\n        checkpoint\n    ]\n)","04400c76":"def load_image(img_path, resize=img_size):\n\n    pil_img = Image.open(img_path).convert(\"RGB\")\n    img = np.asarray(pil_img) \/ 255\n    img_tensor = tf.convert_to_tensor(img)\n    img_final = tf.image.resize(img_tensor, resize)\n    return img_final.numpy()","5f486389":"def train(model,epochs):\n    data=datagen()\n    for x in range(int(train_df.shape[0]\/batch_size)):\n        data_batch=data.__next__()\n        X,y=data_batch[0],data_batch[1]\n        model.fit(X,y,batch_size=batch_size,epochs=epochs)","64eeedee":"def datagen(IsTrain=True):\n    global PATH\n    global batch_size\n    global y\n    folder= \"train_images\/\" if IsTrain else \"test_images\/\"\n    df= \"train.csv\" if IsTrain else \"sample_submission.csv\"\n    imgs_path=PATH+folder\n    df_path=PATH+df\n    data=[]\n    train_df=pd.read_csv(df_path)\n    y_idx=0\n    batchlen=0\n    for img_id in train_df['image_id']:\n        data.append(load_image(imgs_path+img_id))\n        batchlen+=1\n        if batchlen==batch_size:\n            yield (np.asarray(data),(y.iloc[y_idx:(y_idx+batch_size),:]))\n            del data\n            y_idx=batch_size+y_idx\n            data=[]\n            batchlen=0","5c656c8f":"def load_imgs(IsTrain=True):\n    global PATH\n    folder= \"train_images\/\" if IsTrain else \"test_images\/\"\n    df= \"train.csv\" if IsTrain else \"sample_submission.csv\"\n    imgs_path=PATH+folder\n    df_path=PATH+df\n    data=[]\n    for img_id in pd.read_csv(df_path)['image_id']:\n        data.append(load_image(imgs_path+img_id))\n    return data"}}