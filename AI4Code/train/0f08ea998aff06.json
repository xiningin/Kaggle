{"cell_type":{"21262e1d":"code","38320867":"code","c5ade735":"code","949de747":"code","a10b047b":"code","a4a3ed5e":"code","e346687a":"code","66e6ade5":"code","70d5914c":"code","9d35043b":"code","cb2044b5":"code","8f8a7dbc":"code","1f1646a1":"code","5e3558e6":"code","6bccf4d5":"code","ffb9b33a":"code","0a74ae6c":"code","67c87f83":"code","9c44382b":"code","5adaeaca":"code","7f6ab751":"code","25ff4036":"code","2303e463":"code","f03b23c6":"code","60bf8d0f":"code","229413aa":"code","e4cbb7dd":"code","48638954":"code","020baaaa":"code","085d6240":"code","f319a8f8":"code","95b493f3":"code","e5f30770":"code","32c70b3f":"code","aeb4903c":"code","9d07d852":"code","2147cfc2":"code","7ae12839":"code","1a91b159":"code","ae964335":"code","faddeed9":"code","c1780350":"code","53021d9b":"code","a0699a9f":"code","8cb17966":"code","9ed76411":"code","e9c48052":"code","2954e26f":"code","5056febf":"code","4729911b":"markdown","75a07831":"markdown","66de34b0":"markdown","022cd2e9":"markdown","76097694":"markdown","ec03b17d":"markdown","6a94d956":"markdown","81d9f472":"markdown","d75b3bf4":"markdown","de633048":"markdown","9624b936":"markdown","20601121":"markdown","8be7556c":"markdown","109d6fe6":"markdown","8a264754":"markdown","7c0caa32":"markdown","9d2c6ba3":"markdown","36757a43":"markdown","20ab4daa":"markdown","55f6c07d":"markdown","fe81c537":"markdown","50b4bb27":"markdown","bff13216":"markdown","0ca01e7c":"markdown","04e3ef3a":"markdown","bf56b2fc":"markdown","619e5da7":"markdown","3096dc53":"markdown","f1f5c8ef":"markdown","95c079da":"markdown","b1ccc01e":"markdown","d9cd14ce":"markdown","67c23870":"markdown","f98f2d36":"markdown","9daeb839":"markdown","546af331":"markdown","eeededd0":"markdown","6ea5a567":"markdown","4a9339ad":"markdown","14e8a9d8":"markdown","a884ecbb":"markdown","734c8c90":"markdown","3d0d708f":"markdown","b0899f35":"markdown","3a77637f":"markdown","3a1b7a54":"markdown","30237ce3":"markdown","0dbca1f0":"markdown","f535dce9":"markdown","77c4e09b":"markdown"},"source":{"21262e1d":"import gc\nimport numpy as np \nimport pandas as pd \nimport scipy\nimport time\n\nfrom tqdm import tqdm\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity","38320867":"#Read the relevant files\nquestions =  pd.read_csv(\"..\/input\/questions.csv\")\ntags = pd.read_csv(\"..\/input\/tags.csv\")\ntag_questions= pd.read_csv('..\/input\/tag_questions.csv')\nprofessionals = pd.read_csv(\"..\/input\/professionals.csv\")\nanswers = pd.read_csv(\"..\/input\/answers.csv\")\ntag_users = pd.read_csv('..\/input\/tag_users.csv')","c5ade735":"questions2 = questions.copy()","949de747":"professionals.head(10)","a10b047b":"# Preprocessing of text data\ntextfeats = [\"questions_title\",\"questions_body\"]\nfor cols in textfeats:\n    questions[cols] = questions[cols].astype(str) \n    questions[cols] = questions[cols].astype(str).fillna('') \n    questions[cols] = questions[cols].str.lower() \n    questions[cols] = questions[cols].str.replace('nan','')\n\nquestions['Text'] = questions['questions_title'] + ' ' + questions['questions_body']","a4a3ed5e":"cols = ['Text']\nn_features = [5000]","e346687a":"for c_i, c in tqdm(enumerate(cols)):\n    \n    # The function TfidfVectorizer converts a collection of raw documents \n    # to a matrix of TF-IDF features\n    tfidf = TfidfVectorizer(\n        max_features=n_features[c_i],\n        strip_accents='unicode',\n         analyzer='word',\n         lowercase=True, # Convert all uppercase to lowercase\n         stop_words='english',\n        norm='l2',\n        )\n    tfidf.fit(questions[c])\n    tfidf_feature_names = tfidf.get_feature_names()\n    tfidf_train = np.array(tfidf.transform(questions[c]).toarray(), dtype=np.float16)\n\n    for i in range(n_features[c_i]):\n        questions[c + '_tfidf_' + tfidf_feature_names[i]] = tfidf_train[:, i]\n        \n    del tfidf, tfidf_train\n    gc.collect()\n","66e6ade5":"questions_profile = questions.drop(['Text','questions_author_id',\n                                           'questions_title','questions_date_added',\n                                           'questions_body'], axis=1)","70d5914c":"questions_profile.iloc[10:20,300:310]","9d35043b":"questions3 = questions2","cb2044b5":"questions_tags = pd.merge(questions3, tag_questions,\n                          how= 'left', \n                          left_on = 'questions_id', \n                          right_on = 'tag_questions_question_id')\n\nquestions_tags_name = pd.merge(questions_tags, tags,\n                               how= 'left', \n                               left_on = 'tag_questions_tag_id', \n                               right_on = 'tags_tag_id')","8f8a7dbc":"questions_profile_tags = questions_tags_name[['questions_id','tags_tag_name']]\nquestions_profile_tags['NumberOfEntries'] = 1\nquestions_profile_tags_original = questions_profile_tags.copy()","1f1646a1":"n =  50\ntopn_tags = questions_profile_tags_original.groupby(['tags_tag_name'])['tags_tag_name']. \\\ncount(). \\\nsort_values(ascending = False).head(n)","5e3558e6":"notintopn_tags = ~questions_profile_tags_original['tags_tag_name'].isin(topn_tags.index)\nquestions_profile_tags_original = questions_profile_tags_original[notintopn_tags]","6bccf4d5":"start = time.time()\nquestions_profile_tags = pd.pivot_table(questions_profile_tags, \n                                        values='NumberOfEntries', \n                                        index = ['questions_id'], \n                                        columns=['tags_tag_name'], \n                                        aggfunc=np.sum)\nend = time.time()\nend - start","ffb9b33a":"questions_profile_tags = questions_profile_tags.reset_index()\nquestions_profile_tags = questions_profile_tags.fillna(0)\n\nquestions_profile_complete = pd.merge(questions_profile,questions_profile_tags,\n                                      left_on = 'questions_id', \n                                      right_on = 'questions_id')","0a74ae6c":"questions_profile_complete.iloc[10:20,7000:7010]","67c87f83":"professionals_questions = pd.merge(professionals, answers, \n                                   how = 'left' ,\n                                   left_on = 'professionals_id', \n                                   right_on = 'answers_author_id')","9c44382b":"#Function to get all questions answered by a professional\ndef get_questions(professional):\n    \n    \"\"\"\n    Summary\n    --------------\n    Function to get all questions answered by a professional\n    \n    professional  =  the professional id\n   \n    \"\"\"\n    questions = professionals_questions[professionals_questions.professionals_id == professional].answers_question_id\n    questions = pd.DataFrame(questions).rename(index=str, columns={\"answers_question_id\": \"question_id\"})\n    return(questions)   ","5adaeaca":"questions_profile_complete = questions_profile_complete.set_index('questions_id')","7f6ab751":"#Function to recommend questions for the professional\ndef recommend_questions(questions,topn = 100,topn1 = 50):\n    \n    \"\"\"\n    Summary\n    --------------\n    recommend_questions recommends questions for the professional\n    \n    questions  =  the questions which the professional has answered\n    topn       =  the top n cosine values to be considered\n    toppn1     =  the number of questions to be recommended for each question\n    \n    returns the recommended questions for the professional\n    \n    \"\"\"\n    questions_list = []\n    cosine_values = []\n    len_questions = len(questions)\n    \n    #Check to see if the professional has answered questions\n    if(len_questions > 0):\n        #Create a sparse matrix of the COMPLETE question profile consisting of title , body  and tags\n        b = scipy.sparse.csr_matrix(questions_profile_complete)\n        \n    for i in range(len_questions):\n        #get the question from the question profile\n        try:\n            question = questions_profile_complete.loc[questions.iloc[i].question_id]        \n        except KeyError:\n            # do nothing\n            pass\n        \n        #Create a sparse matrix of the question profile consisting of title , body  and tags\n        a = scipy.sparse.csr_matrix(question.values)\n        # Find the cosine similarities\n        cosine_similarities = cosine_similarity(a,b)\n        # Find the similar indices\n        similar_indices = cosine_similarities.argsort().flatten()[-topn:]\n        similar_questions = sorted([(questions_profile_complete.iloc[i,:],cosine_similarities[0,i]) for i in similar_indices],key=lambda x: -x[1])\n             \n        question_name = questions.iloc[i].question_id\n        \n        if(len(similar_questions) > topn1):\n            length_similar = topn1\n        else:\n            length_similar = len(similar_questions)\n        \n        for j in range(length_similar):\n            if(similar_questions[j][0].name != question_name):\n                questions_list.append(similar_questions[j][0].name)\n                cosine_values.append(similar_questions[j][1])\n                \n    return(questions_list,cosine_values)   ","25ff4036":"professional = '0c673e046d824ec0ad0ebe012a0673e4'\nquestions_all = get_questions(professional)\nquestions_all.head()","2303e463":"len(questions_all)","f03b23c6":"questions = pd.DataFrame(questions_all.head(10))\nquestions.head()","60bf8d0f":"questions_list,cosine_values = recommend_questions(questions)\ncols_dictionary = {'questions': questions_list,'cosine_values': cosine_values}","229413aa":"questions_list_df = pd.DataFrame(cols_dictionary)\nquestions_list_df = questions_list_df.sort_values('cosine_values', ascending = False)\nquestions_list_df.head(10)","e4cbb7dd":"questions_list_set =  set(questions_list) \nlen(questions_list_set.intersection(questions_all.question_id))","48638954":"profile_tags = pd.merge(professionals, tag_users,\n                          how= 'left', \n                          left_on = 'professionals_id', \n                          right_on = 'tag_users_user_id')\n\nprofile_tags_name = pd.merge(profile_tags, tags,\n                               how= 'left', \n                               left_on = 'tag_users_tag_id', \n                               right_on = 'tags_tag_id')\n\nprofile_tags_name = profile_tags_name[['professionals_id','tags_tag_name']]\n\nprofile_tags_name = profile_tags_name.fillna(0)","020baaaa":"profile_tags_name.head()","085d6240":"def recommend_questions_using_tags(professional,questions_list = []):\n    \n    \"\"\"\n    This function recommends questions using the tags of the professional\n    and the tags associated with the questions.          \n    \n    \"\"\"\n    professional_tags = profile_tags_name[profile_tags_name.professionals_id == professional]\n    tags =pd.DataFrame(pd.unique(profile_tags_name[profile_tags_name.professionals_id == professional].tags_tag_name))\n    tags['tags_tag_name'] = tags[0]\n    print(tags)\n    questions = pd.merge(tags,questions_profile_tags_original, \n                                   how = 'inner' ,\n                                   left_on = 'tags_tag_name', \n                                   right_on = 'tags_tag_name')\n    questions_list_tags = questions.questions_id.tolist()\n    questions_list.extend(questions_list_tags)\n    questions_set = set(questions_list)\n    \n    return(questions_set)","f319a8f8":"list_qs = list(questions.question_id)","95b493f3":"questions_set = recommend_questions_using_tags(professional,list_qs)","e5f30770":"len(questions_set)","32c70b3f":"len(questions_set.intersection(questions_all.question_id))","aeb4903c":"professional = '977428d851b24183b223be0eb8619a8c'\nquestions_all = get_questions(professional)\nquestions_all","9d07d852":"questions = pd.DataFrame(questions_all.head(5))\nquestions","2147cfc2":"questions_list,cosine_values = recommend_questions(questions)\ncols_dictionary = {'questions': questions_list,'cosine_values': cosine_values}","7ae12839":"questions_list_df = pd.DataFrame(cols_dictionary)\nquestions_list_df = questions_list_df.sort_values('cosine_values', ascending = False)\nquestions_list_df.head(10)","1a91b159":"questions_list_set =  set(questions_list) \nquestions_list_set.intersection(questions_all.question_id)","ae964335":"list_qs = list(questions.question_id)","faddeed9":"list_qs","c1780350":"questions_set = recommend_questions_using_tags(professional,list_qs)","53021d9b":"len(questions_set)","a0699a9f":"professional = '81999d5ad93549dab55636a545e84f2a'\nquestions_all = get_questions(professional)\nquestions_all","8cb17966":"data = {'question_id': ['2c7bb1973510493aa8daf75e08bbe773']}\nquestions = pd.DataFrame.from_dict(data)\nquestions.head()","9ed76411":"questions_list,cosine_values = recommend_questions(questions)\ncols_dictionary = {'questions': questions_list,'cosine_values': cosine_values}\nquestions_list_df = pd.DataFrame(cols_dictionary)\nquestions_list_df = questions_list_df.sort_values('cosine_values', ascending = False)\nquestions_list_df.head(10)","e9c48052":"questions_list_set =  set(questions_list) \nquestions_list_set.intersection(questions_all.question_id)","2954e26f":"list_qs = list(questions.question_id)\nquestions_set = recommend_questions_using_tags(professional,list_qs)\nlen(questions_set)","5056febf":"len(questions_set.intersection(questions_all.question_id))","4729911b":"A professional may have answered some questions. We build a matrix of professionals and questions. We would use the fact that if a professional has answered a question, then the professional can be recommended **Similiar Questions**","75a07831":"`Using 10 questions , we could recommend 9 more questions out of 39 questions.` This shows the technique works.","66de34b0":"# Summary       \nWe have made a **Content based recommender** and seen how we can recommend questions using the similarity of questions answered by the professional. If the professional has not answered any questions, then we match the tags of the professional with the tags associated with the questions to recommend questions.         \n\n## Implementation details and Future Explorations\nThis can be deployed in **Production** easily to get results.  The Three scenarios prove that there is merit in using this technique for more focussed recommendations. The code tries to follow the PEP8 documentation standards and would help the implementers to comphrehend easily.\n\nThe questions profile calculation( the question profile has all the questions title , body , tags ) does not take much time. For production this can be precalculated. If a new question arrives, the question feature vector can be calculated and added to the full question profile vector.\n\nCareer Village can clean the tags associated with the questions and professionals for much better accuracy.","022cd2e9":"The questions data has Title and Body. **TF-IDF** technique is used to extract meaningful features from the **questions title and text**\n\nA **document** in this case is the combination of questions title and text. \n\nFrom the book [5 Algorithms Every Web Developer Can Use and Understand](https:\/\/lizrush.gitbooks.io\/algorithms-for-webdevs-ebook\/content\/chapters\/tf-idf.html)     \n>    TF-IDF computes a weight which represents the importance of a term inside a document. \n>    It does this by comparing the frequency of usage inside an individual document as opposed to the entire data set (a collection of documents).\n\nThe importance increases proportionally to the number of times a word appears in the individual document itself--this is called Term Frequency. However, if multiple documents contain the same word many times then you run into a problem. That's why TF-IDF also offsets this value by the frequency of the term in the entire document set, a value called Inverse Document Frequency.\n\n## The Math\n\n>  TF(t) = (Number of times term t appears in a document) \/ (Total number of terms in the document)         \n\nIDF(t) = log_e(Total number of documents \/ Number of documents with term t in it).         \n\nValue = TF * IDF","76097694":"**Glimpse of the professionals data**             \n\nThis is to display the professionals data. This will be used for recommending questions to the professionals ","ec03b17d":"# Step 6 - Recommend using Professional tags and Question Tags","6a94d956":"<hr\/>\n*  **Question - Did you decide to predict Pros given a Question, or predict Questions given a Pro? Why?   **           \n\nThe model chooses to predict Questions given a Professional. The idea came when I joined as a professional, I was recommended certain questions.Now when a new question arrives , the program can run and can recommend this question to professionals.         \n\n<hr\/>\n*  **Question - Does your model address the \"cold start\" problem for Professionals who just signed up but have not yet answered any questions? How'd you approach that challenge?**       \n\nStep 6 of the algorithm addresses the cold start problem. The professionals are associated with Tags. The questions are also associated with Tags. In this step, we recommend questions based on the same tags associated with professionals and questions. This last step also helps professionals who have not started answering any questions.     \n<hr\/>\n* **Question - Did your model have any novel approaches to ensuring that \"no question gets left behind\"?  **      \n\nThe last step ensures that the matching of the tags of the professional and the questions ensures that no questions are left behind.\n\n<hr\/>\n\n* **Question - What types of models did you try, and why did you pick the model architecture that you picked?  **    \n\nThe models tried were the **Content Based Recommender** with Professionals and Questions tag matching  and the **Collaborative Filtering** method. The first method **Content Based Recommender** with Professionals and Questions tag matching gave better accuracy.         \n\n<hr\/>\n* **Question -  Did you engineer any new data features? Which ones worked well for your model? **\n\nIn the Content Based Recommender, we engineered TF-IDF features from the Questions Body and Title. This we had combined with the Questions tags. This helps us to extract important words from the Questions Body and Title.\n\n<hr\/>\n\n* **Question -  Is there anything built into your approach to protect certain Professionals from being \"overburdened\" with a disproportionately high share of matches?**          \n\nIn Step 6 , we match the Professionals tag with the Questions tag. In order that the Professionals are not overburdened, we remove the Top N tags of the questions from matching. This is presently configured to 50. The developer at Career Village can configure this to any desired value. This ensures that Professionals from being \"overburdened\" with a disproportionately high share of matches\n\n<hr\/>\n\n* **Question -  What do you wish you could use in the future (that perhaps we could try out on our own as an extension of your work)?**\n\nThis program could be deployed in Production. Career Village can clean the tags associated with the questions and professionals for much better accuracy. In future more templatized questions will help in doing better question similarity\n\n","81d9f472":"**Hit Rate of the Recommendation**","d75b3bf4":"**Hit rate after considering Tags matching**","de633048":"# Scenario 2      \nHere we choose a professional with professional id `977428d851b24183b223be0eb8619a8c` and run through the steps mentioned above to recommend questions","9624b936":"# Step 3 - Create Questions Feature Vector  \nMerge the question tags with the question feature matrix made before of various words from question title and question text","20601121":"**Hit Rate of the Recommendation**","8be7556c":"## Glimpse of the questions profile    \n\nThe following shows a glimpse of the questions which is made of features of question body and question title   \n","109d6fe6":"A derived column `Text` is made up of the questions Title and questions Body.","8a264754":"**Recommend using Professional tags and Question Tags**","7c0caa32":"This section merges the questions data along with the tags data. A question is associated with various tags","9d2c6ba3":"We now find the questions which have been recommended by the professionals.","36757a43":"# Introduction","20ab4daa":"We retain the question profile tags dataframe to contain tags which are **NOT the most n popular**","55f6c07d":"# Step  1  - Preprocessing - Questions Title and Body","fe81c537":"We now find the questions which have been recommended by the professionals.","50b4bb27":"# Another approach - Collaborative filtering     \n\nWe use the Collaborative filtering method to recommend questions [here](https:\/\/www.kaggle.com\/ambarish\/careervillage-collaborativefiltering). However the results are not promising using collaborative filtering.","bff13216":"## Scenario 1 ","0ca01e7c":"# Step 4 - Questions answered by a Professional","04e3ef3a":"Using tags, the number of questions increases to **121**","bf56b2fc":"Here we choose a professional with professional id `0c673e046d824ec0ad0ebe012a0673e4` and run through the steps mentioned above to recommend questions","619e5da7":"`After the professionals tag matching with the questions tag matching, we could match the other questions correctly`","3096dc53":"**Hit Rate after Tags matching**","f1f5c8ef":"# Proof through Scenarios       \n\nThe above mentioned steps have been coded below. This is also demonstrated with **Three Scenarios**. The demonstration with the three examples provide proof that this strategy works","95c079da":"The cosine similarity did not provide any matching recommendation","b1ccc01e":"# Recommended Questions","d9cd14ce":"We now recommend the questions for the professional using the 1 question","67c23870":"We modify the professional questions by choosing only 5 question instead of 22 questions answered by the professional. This is done to check if the professional answers these 5 questions, can we recommend correctly the questions answered by the professional","f98f2d36":" # Step 2 - Preprocessing Questions Tags","9daeb839":"# Professionals and Tags","546af331":"This professional has answered 3 questions.We modify the professional questions by choosing only 1 question instead of 3 questions answered by the professional. This is done to check if the professional answers these 1 question, can we recommend correctly the questions answered by the professional","eeededd0":"### Hit rate of the recommendation","6ea5a567":"Suppose a professional joins Career Village. The person has not answered any question. We can still recommend questions to the professional by matching the tags of the professional with the tags of the questions.","4a9339ad":"The professional had answered `22` questions. We used `5` of the questions answered by the professional and was able to recommend `8` other questions which the professional had answered. This again proves the technique of Cosine similarity is fruitful in recommending questions to professionals        ","14e8a9d8":"Using the Professionals tags and the Questions tags, more questions were matched. The cosine similarity technique along with the Tag matching of professionals and questions therefore works.","a884ecbb":"Most common tags in Questions","734c8c90":"We modify the professional questions by choosing only 10 questions instead of 39 questions answered by the professional. This is done to check if the professional answers these 10 questions, can we recommend correctly the questions answered by the professional","3d0d708f":"# Questions and Answers","b0899f35":"# Scenario 3   \n\nHere we choose a professional with professional id `81999d5ad93549dab55636a545e84f2a` and run through the steps mentioned above to recommend questions","3a77637f":"CareerVillage.org is a nonprofit that crowdsources career advice for underserved youth. Founded in 2011 in four classrooms in New York City, the platform has now served career advice from 25,000 volunteer professionals to over 3.5M online learners. The platform uses a Q&A style similar to StackOverflow or Quora to provide students with answers to any question about any career.                     \n\nIn this competition, we develop a **Content Based Recommender**  to recommend relevant questions to the professionals who are most likely to answer them.                     \n\nThe Contentbased recommender makes use of the concept that if a professional has answered a question, then the professional would be recommended **SIMILAR questions**.\n\n**Step 1 - Preprocessing - Questions Title and Body**            \nExtract features using the Question Body and Title. Make a feature vector with these attributes for each of the questions              \n\n**Step 2 - Preprocessing Questions Tags**        \nGet the tags associated with the questions. Create a Tags vector for each of the questions\n\n**Step 3 - Create the Questions Feature Vector**   \nCreate a feature vector consisting of Question Body , Title and Tags by merging the Questions Body , Title and Tags\n\nAt the end of Step 3, we have for all questions a feature vector consisting of Body, Title and Tags\n\n**Step 4 - Get Questions answered by a professional**              \nGet all the questions associated with a professional.\n\n**Step 5 -  Find Similiar Questions**              \nFind Similiar Questions which have been answered by the professional. **Cosine Similarity** is used to calculate the similarity between the questions.\n\n**Step 6 - Questions based on Professional Tags**       \nThe professionals are associated with Tags. The questions are also associated with Tags. In this step, we recommend questions based on the same tags associated with professionals and questions. This last step also helps professionals who have not started answering any questions.            ","3a1b7a54":"# Step 5 - Similarity Between Questions","30237ce3":"The number of questions answered by the professional is shown below","0dbca1f0":"**Recommend using Professional tags and Question Tags**","f535dce9":"# Create the TF-IDF matrix    \n\nWe create the TF-IDF Matrix using the column Text and the number of features is 5000. This is configurable through the variable `n_features`     ","77c4e09b":"This section merges the professionals data along with the tags data. A user in `Career Village` has the option of associating with various tags"}}