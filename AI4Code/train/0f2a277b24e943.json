{"cell_type":{"527b8e79":"code","b1fe6321":"code","1d9821e9":"code","ec355b62":"code","9f3b5ec9":"code","4f719703":"code","0f833618":"code","703c681f":"code","79ce46dc":"code","d01fe5c1":"code","20a47080":"code","de9063c0":"code","bbb35f26":"code","8ec4c1af":"code","3f237da5":"code","96a37ea1":"code","6acb6a65":"code","a7652ffe":"code","cda370f0":"code","0120118a":"code","f3aecd96":"code","fc19fbe7":"code","3469499c":"code","167a5f94":"code","ff492a5b":"code","cad42e80":"code","ff0ec861":"code","4b835fa9":"code","8c30f308":"code","9df7cf68":"code","7617e779":"code","b78b9cf7":"code","ad78de8a":"code","462797e3":"code","602cb2be":"code","aac89bc0":"code","2fbb61e8":"code","d78ac994":"markdown","10a90068":"markdown","f94cb642":"markdown","d21b2d1f":"markdown","f59215c7":"markdown","2c34a9b3":"markdown","664b3869":"markdown","8beece2e":"markdown","58207388":"markdown","b5ee4a7e":"markdown","ebaf3654":"markdown","b00f8dba":"markdown","03a93f7a":"markdown","b4863f7d":"markdown","a34dae1c":"markdown","ecdbc6e4":"markdown","d0e72898":"markdown","5ae10134":"markdown","93530d5d":"markdown","fcb125a7":"markdown","580efc39":"markdown","40f7182d":"markdown","a1f4527e":"markdown","8008f993":"markdown","63ce8b25":"markdown"},"source":{"527b8e79":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","b1fe6321":"import pandas as pd\nimport numpy as np\nimport datetime as dt\n\npd.set_option('display.max_columns', None)\npd.set_option('display.float_format', lambda x: '%.5f' % x)\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nwarnings.simplefilter(action='ignore', category=FutureWarning)","1d9821e9":"pip install openpyxl","ec355b62":"df_ = pd.read_excel(\"..\/input\/online-retail-ii-data-set-from-ml-repository\/online_retail_II.xlsx\", \n                    sheet_name=\"Year 2009-2010\", engine='openpyxl') \ndf = df_.copy()\ndf.head()","9f3b5ec9":"def check_df(dataframe):\n    print(\"##################### Shape #####################\")\n    print(dataframe.shape)\n    print(\"##################### Types #####################\")\n    print(dataframe.dtypes)\n    print(\"##################### Head #####################\")\n    print(dataframe.head(5))\n    print(\"##################### Tail #####################\")\n    print(dataframe.tail(5))\n    print(\"##################### NA #####################\")\n    print(dataframe.isnull().sum())\n    print(\"##################### Quantiles #####################\")\n    print(dataframe.quantile([0, 0.05, 0.50, 0.95, 0.99, 1]).T)","4f719703":"check_df(df)","0f833618":"# drop null values\n\ndf.dropna(inplace=True)","703c681f":"# check one randomly picked customer's shopping history\n\ndf.loc[df['Customer ID'] == 13085.00000]","79ce46dc":"# number of unique customers\n\ndf['Customer ID'].nunique()","d01fe5c1":"# which countries are the customers from\n\ndf['Country'].value_counts()","20a47080":"# customers without country information\n\ndf.loc[df['Country'] == \"Unspecified\", \"Customer ID\"].value_counts()\n","de9063c0":"missing_country = [16320.00000,14265.00000,12470.00000,12351.00000,15357.00000]\n\ndf.loc[df['Customer ID'].isin(missing_country)].head(5)\n","bbb35f26":"#do each StockCode belong to a specific Item\n\ndf.groupby('StockCode').agg({'Description': \"nunique\"}).sort_values(by='Description', ascending=False).head()","8ec4c1af":"df.loc[df['StockCode'] == 22384, 'Description'].unique()","3f237da5":"# check the observations that have negative value for Quantity \n\ndf.loc[df['Quantity'] < 0].head(10)","96a37ea1":"# check the Invoices that starts with the letter \"C\"\n\ndf.loc[df['Invoice'].str.startswith(\"C\",na=False), [\"Quantity\",\"Price\"]].describe()","6acb6a65":"# get rid of refund invoices\n\ndf = df[~df[\"Invoice\"].str.contains(\"C\", na=False)]","a7652ffe":"df.describe().T","cda370f0":"# derive a new variable by multiplying the price per unit with Quantity\n\ndf['TotalPrice'] = df['Quantity'] * df['Price']","0120118a":"df.head()","f3aecd96":"today_date = df['InvoiceDate'].max() + dt.timedelta(days=2)","fc19fbe7":"# 2 days will be added to \"today's date\" to eliminate the local time differences between stores and to make sure\n# that Recency is always above 0\n\ntoday_date = df['InvoiceDate'].max() + dt.timedelta(days=2)\ntoday_date","3469499c":"rfm = df.groupby('Customer ID').agg({'InvoiceDate': lambda date: (today_date - date.max()).days,\n                                    'Invoice': lambda inv: inv.nunique(),\n                                    'TotalPrice': lambda price: price.sum()})","167a5f94":"rfm.columns = ['Recency', 'Frequency', 'Monetary']","ff492a5b":"rfm.head()","cad42e80":"check_df(rfm)","ff0ec861":"from sklearn.preprocessing import MinMaxScaler\nfrom sklearn.cluster import KMeans\n\nsc = MinMaxScaler((0, 1))\ndf = sc.fit_transform(rfm)","4b835fa9":"df[0:5]","8c30f308":"# a random number of cluster is being given as a parameter\n\nkmeans = KMeans(n_clusters=4)\nk_fit = kmeans.fit(df)","9df7cf68":"# centeroids for the 4 clusters\n\nk_fit.cluster_centers_","7617e779":"import matplotlib.pyplot as plt\n# number of clusters between range(1,30) will be given as parameters within KMeans object\n\nkmeans = KMeans()\nssd = []\nK = range(1, 30)\n\nfor k in K:\n    kmeans = KMeans(n_clusters=k).fit(df)\n    ssd.append(kmeans.inertia_)\n    \nplt.plot(K, ssd, \"bx-\")\nplt.xlabel(\"Distance Residual Sums per Different k Values\")\nplt.title(\"Elbow Method for Optimum Number of Clusters\")\nplt.show()","b78b9cf7":"from yellowbrick.cluster import KElbowVisualizer\n\nkmeans = KMeans()\nvisu = KElbowVisualizer(kmeans, k=(2, 20))\nvisu.fit(df)\nvisu.show();","ad78de8a":"kmeans = KMeans(n_clusters= 6, init= 'k-means++', max_iter= 1000)\nkmeans.fit(df)\nclusters = kmeans.labels_","462797e3":"# segment labels for the first 30 customers\n\nclusters[0:30]","602cb2be":"# customer id's and the segment numbers\n\npd.DataFrame({\"Customer ID\": rfm.index, \"Clusters\": clusters})","aac89bc0":"# add cluster numbers as a variable to rfm dataframe\n# add 1 to cluster segment number so that it starts with 1\n\nrfm[\"Cluster\"] = clusters\nrfm[\"Cluster\"] = rfm[\"Cluster\"] + 1","2fbb61e8":"rfm.head(15)","d78ac994":"![miniiiij.jpeg](attachment:cee0bd54-21ba-4da7-91bc-82ae16c9d592.jpeg)","10a90068":"When a customer makes a purchase, the Invoice is duplicated and each unique item that has been purchased are transformed into seperate observations.","f94cb642":"Invoices that start with \"C\" are refunds, the Quantity values are below 0.","d21b2d1f":"<a id=\"section-three-four\"><\/a>\n### 3.4. Total Price","f59215c7":"<a id=\"section-three-one\"><\/a>\n### 3.1. Country","2c34a9b3":"* Instead of using a pre-defined number of clusters, the customers will be segmented according to their purchasing behaviours.  \n* The logic behind K-Means is to cluster every observation with regards to their similarities using Sum of Squared Distances (SSD).","664b3869":"Monetary values range from 0 to 349164 whereas Recency and Frequency values range form 1 to a 3 digit number. By using MinMaxScaler, all the values are ranging from 0 to 1 (its default parameter). ","8beece2e":"<a id=\"section-three\"><\/a>\n## 3. Exploratory Data Analysis ","58207388":"<a id=\"section-two\"><\/a>\n## 2. Load Dataset","b5ee4a7e":"<a id=\"section-one\"><\/a>\n## 1. Import Library and Set Configurations","ebaf3654":"* **Recency** shows how recent the customer has purchased. So that is the duration between today and the last date that the customer has purchased. Today will be the last date within the dataset.  \n* **Frequency** shows how frequent the customer purchases. So the number of unique Invoices will be the number of times that he\/she purchased.\n* **Monetary** shows the total amount of money that the customer has spent.\n","b00f8dba":"# Table of Content\n\n1. [Import Library and Set Configurations](#section-one)  \n2. [Load Dataset](#section-two)  \n3. [Exploratory Data Analysis](#section-three) \n    * 3.1. [Country](#section-three-one)  \n    * 3.2. [StockCode & Description](#section-three-two)  \n    * 3.3. [Price & Quantity](#section-three-three)  \n    * 3.4. [Total Price](#section-three-four)  \n4. [RFM Metrics](#section-four)  \n5. [K-Means](#section-five)  \n    * 5.1. [Determining the Optimum Number of Clusters](#section-five-one)\n\n\n    \n    \n    ","03a93f7a":"<a id=\"section-three-two\"><\/a>\n### 3.2. StockCode & Description","b4863f7d":"* \u2018k-means++\u2019 parameter selects initial cluster centers for k-mean clustering in a smart way to speed up convergence.  \n* 'max_iter' parameter for the maximum number of iterations of the k-means algorithm for a single run. It is given in order to avoid an endless loop.","a34dae1c":"<a id=\"section-five-one\"><\/a>\n### 5.1. Determining the Optimum Number of Clusters","ecdbc6e4":"<a id=\"section-four\"><\/a>\n## 4. RFM Metrics ","d0e72898":"<a id=\"section-three-three\"><\/a>\n### 3.3. Price & Quantity","5ae10134":"<a id=\"section-five\"><\/a>\n##  5.K-Means","93530d5d":"Elbow Method will be used to determine the optimum number of clusters for rfm dataframe","fcb125a7":"at first glance:\n* Customer ID is duplicated\n* null values in Description and Customer ID variables\n* Customer ID's will be used for identifying customers on customer segmentation, so null values is both variables will be dropped.\n* Price and Quantity variables have values below zero, which is not possible.\n* Prices range from 0 to 25111","580efc39":"As an example, 4 item names above refer to the same item and StockCode. This duplicate may be due to manuel entry. StockCode is a better variable to analyze items.","40f7182d":"no negative values, no null values","a1f4527e":"# RFM - Customer Segmentation Using K-Means Clustering","8008f993":"5 customers' Country variables are empty, we won't be using Country information for segmentation so we'll leave them as is.","63ce8b25":"According to Elbow Method, the optimum number of cluster is 6."}}