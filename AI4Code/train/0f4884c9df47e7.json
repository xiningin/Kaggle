{"cell_type":{"c24af1a5":"code","df2f3360":"code","e62aeb70":"code","7700e193":"code","b274ad0f":"code","1c3f79f2":"code","7a1e2e88":"code","5bdbc1c8":"code","021a4146":"code","ad7937e4":"code","66510999":"code","0ec0a53f":"code","35196722":"code","7a6afd03":"code","16693390":"code","894d4a52":"code","35ffc79e":"code","5798c063":"code","7383035f":"code","66de3834":"code","da8e0bd9":"code","e13608a0":"code","a6a78e32":"code","5a64075a":"code","679832a8":"code","3cb28d79":"code","9df923b8":"code","7c429b62":"code","3874d352":"code","05179f5d":"code","04c4f57d":"code","90914620":"code","8b79638e":"code","de14aeff":"code","8b7f546d":"code","abdda6ae":"code","27129bc9":"code","af99a35a":"code","47fed20d":"code","48586a67":"code","21da9995":"markdown","53ed9bde":"markdown","3e6eb226":"markdown","c4b1742d":"markdown","393982d6":"markdown","6338f856":"markdown","80b87ca0":"markdown","8827a763":"markdown","1c76cd34":"markdown","a39f24f6":"markdown","f07d4cc8":"markdown","535d9234":"markdown","bbc447fa":"markdown","d9bb5e74":"markdown","3de81fa6":"markdown","0a2e123f":"markdown","37eebb64":"markdown","87949986":"markdown","c308337d":"markdown","7ee31640":"markdown","59a675d2":"markdown","b21b366b":"markdown","858e7ee0":"markdown","c7a5509a":"markdown","a85217c1":"markdown"},"source":{"c24af1a5":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\n\n%matplotlib inline","df2f3360":"known_behaviors = pd.read_csv(\"https:\/\/raw.githubusercontent.com\/vberaudi\/utwt\/master\/known_behaviors2.csv\")\nknown_behaviors.head()","e62aeb70":"a = known_behaviors[known_behaviors.Mortgage == 1]\nb = known_behaviors[known_behaviors.Pension == 1]\nc = known_behaviors[known_behaviors.Savings == 1]\nprint(\"Number of clients: %d\" %len(known_behaviors))\nprint(\"Number of clients predicted to buy mortgage accounts: %d\" %len(a))\nprint(\"Number of clients predicted to buy pension accounts: %d\" %len(b))\nprint(\"Number of clients predicted to buy savings accounts: %d\" %len(c))","7700e193":"known_behaviors[\"nb_products\"] = known_behaviors.Mortgage + known_behaviors.Pension + known_behaviors.Savings","b274ad0f":"abc = known_behaviors[known_behaviors.nb_products > 1]\nprint(\"We have %d clients who bought several products\" %len(abc))\nabc = known_behaviors[known_behaviors.nb_products == 3]\nprint(\"We have %d clients who bought all the products\" %len(abc))","1c3f79f2":"products = [\"Savings\", \"Mortgage\", \"Pension\"]","7a1e2e88":"def plot_cloud_points(df):\n    figure = plt.figure(figsize=(20, 5))\n    my_cm  = ListedColormap(['#bb0000', '#00FF00'])\n    axes = {p : ('age', 'income') if p != \"Mortgage\"else ('members_in_household', 'loan_accounts') for p in products}\n    for product in products:\n        ax = plt.subplot(1, len(products), products.index(product)+1)\n        ax.set_title(product)\n        axe = axes[product]\n        plt.xlabel(axe[0])\n        plt.ylabel(axe[1])\n        ax.scatter(df[axe[0]], df[axe[1]], c=df[product], cmap=my_cm, alpha=0.5)","5bdbc1c8":"plot_cloud_points(known_behaviors)","021a4146":"known_behaviors.columns","ad7937e4":"cols = ['age', 'income', 'members_in_household', 'loan_accounts']","66510999":"X = known_behaviors[cols]\nys = [known_behaviors[p] for p in products]","0ec0a53f":"X.head()","35196722":"from sklearn import svm\nfrom sklearn import ensemble","7a6afd03":"classifiers = []\nfor i,p in enumerate(products):\n    clf = ensemble.GradientBoostingClassifier()\n    clf.fit(X, ys[i])\n    classifiers.append(clf)","16693390":"unknown_behaviors = pd.read_csv(\"https:\/\/raw.githubusercontent.com\/vberaudi\/utwt\/master\/unknown_behaviors.csv\")","894d4a52":"for c in unknown_behaviors.columns:\n    assert c in known_behaviors.columns","35ffc79e":"to_predict = unknown_behaviors[cols]","5798c063":"print(\"Number of new customers: %d\" %len(unknown_behaviors))","7383035f":"import warnings\nwarnings.filterwarnings('ignore')","66de3834":"predicted = [classifiers[i].predict(to_predict) for i in range(len(products))]\nfor i,p in enumerate(products):\n    to_predict[p] = predicted[i]\nto_predict[\"id\"] = unknown_behaviors[\"customer_id\"]","da8e0bd9":"offers = to_predict\noffers.head()","e13608a0":"offers = offers.rename_axis('index_nb').reset_index()","a6a78e32":"a = offers[offers.Mortgage == 1]\nb = offers[offers.Pension == 1]\nc = offers[offers.Savings == 1]\nprint(\"Number of new customers: %d\" %len(offers))\nprint(\"Number of customers predicted to buy mortgages: %d\" %len(a))\nprint(\"Number of customers predicted to buy pensions: %d\" %len(b))\nprint(\"Number of customers predicted to buy savings: %d\" %len(c))","5a64075a":"to_predict[\"nb_products\"] = to_predict.Mortgage + to_predict.Pension + to_predict.Savings\n\nabc = to_predict[to_predict.nb_products > 1]\nprint(\"We predicted that %d clients would buy more than one product\" %len(abc))\nabc = to_predict[to_predict.nb_products == 3]\nprint(\"We predicted that %d clients would buy all three products\" %len(abc))","679832a8":"# How much revenue is earned when selling each product\nproductValue = [200, 300, 400]\nvalue_per_product = {products[i] : productValue[i] for i in range(len(products))}\n\n# Total available budget\navailableBudget = 25000\n\n# For each channel, cost of making a marketing action and success factor\nchannels =  pd.DataFrame(data=[(\"gift\", 20.0, 0.20), \n                               (\"newsletter\", 15.0, 0.05), \n                               (\"seminar\", 23.0, 0.30)], columns=[\"name\", \"cost\", \"factor\"])\n\noffersR = range(0, len(offers))\nproductsR = range(0, len(products))\nchannelsR = range(0, len(channels))","3cb28d79":"gsol = pd.DataFrame()\ngsol['id'] = offers['id']\n\nbudget = 0\nrevenue = 0\n\nfor product in products:\n    gsol[product] = 0\n\nnoffers = len(offers)\n\n# ensure the 10% per channel by choosing the most promising per channel\nfor c in channelsR: #, channel in channels.iterrows():\n    i = 0;\n    while (i< ( noffers \/\/ 10 ) ):\n        # find a possible offer in this channel for a customer not yet done\n        added = False\n        for o  in offersR:\n            already = False\n            for product in products:   \n                if gsol.get_value(index=o, col=product) == 1:\n                    already = True\n                    break\n            if already:\n                continue\n            possible = False\n            possibleProduct = None\n            for product in products:\n                if offers.get_value(index=o, col=product) == 1:\n                    possible = True\n                    possibleProduct = product\n                    break\n            if not possible:\n                continue\n            #print \"Assigning customer \", offers.get_value(index=o, col=\"id\"), \" with product \", product, \" and channel \", channel['name']\n            gsol.set_value(index=o, col=possibleProduct, value=1)\n            i = i+1\n            added = True\n            budget = budget + channels.get_value(index=c, col=\"cost\")\n            revenue = revenue + channels.get_value(index=c, col=\"factor\")*value_per_product[product]            \n            break\n        if not added:\n            print(\"NOT FEASIBLE\")\n            break","9df923b8":"# add more to complete budget       \nwhile (True):\n    added = False\n    for c, channel in channels.iterrows():\n        if (budget + channel.cost > availableBudget):\n            continue\n        # find a possible offer in this channel for a customer not yet done\n        for o  in offersR:\n            already = False\n            for product in products:   \n                if gsol.get_value(index=o, col=product) == 1:\n                    already = True\n                    break\n            if already:\n                continue\n            possible = False\n            possibleProduct = None\n            for product in products:\n                if offers.get_value(index=o, col=product) == 1:\n                    possible = True\n                    possibleProduct = product\n                    break\n            if not possible:\n                continue\n            #print \"Assigning customer \", offers.get_value(index=o, col=\"id\"), \" with product \", product, \" and channel \", channel['name']\n            gsol.set_value(index=o, col=possibleProduct, value=1)\n            i = i+1\n            added = True\n            budget = budget + channel.cost\n            revenue = revenue + channel.factor*value_per_product[product]            \n            break\n    if not added:\n        print(\"FINISH BUDGET\")\n        break\n    \nprint(gsol.head())","7c429b62":"a = gsol[gsol.Mortgage == 1]\nb = gsol[gsol.Pension == 1]\nc = gsol[gsol.Savings == 1]\n\nabc = gsol[(gsol.Mortgage == 1) | (gsol.Pension == 1) | (gsol.Savings == 1)]\n\nprint(\"Number of clients: %d\" %len(abc))\nprint(\"Numbers of Mortgage offers: %d\" %len(a))\nprint(\"Numbers of Pension offers: %d\" %len(b))\nprint(\"Numbers of Savings offers: %d\" %len(c))\nprint(\"Total Budget Spent: %d\" %budget)\nprint(\"Total revenue: %d\" %revenue)\n\n\ncomp1_df = pd.DataFrame(data=[[\"Greedy\", revenue, len(abc), len(a), len(b), len(c), budget]], columns=[\"Algorithm\",\"Revenue\",\"Number of clients\",\"Mortgage offers\",\"Pension offers\",\"Savings offers\",\"Budget Spent\"])","3874d352":"from __future__ import print_function\nfrom ortools.linear_solver import pywraplp\n\nsolver = pywraplp.Solver('SolveMCProblemMIP',\n                           pywraplp.Solver.CBC_MIXED_INTEGER_PROGRAMMING)","05179f5d":"channelVars = {}\n\n# variables\nfor o in offersR:\n    for p in productsR:\n        for c in channelsR:\n            channelVars[o,p,c] = solver.BoolVar('channelVars[%i,%i,%i]' % (o,p,c))","04c4f57d":"# constraints\n# At most 1 product is offered to each customer\nfor o in offersR:\n    solver.Add(solver.Sum(channelVars[o,p,c] for p in productsR for c in channelsR) <=1)\n\n# Do not exceed the budget\nsolver.Add(solver.Sum(channelVars[o,p,c]*channels.get_value(index=c, col=\"cost\") \n                                           for o in offersR \n                                           for p in productsR \n                                           for c in channelsR)  <= availableBudget)\n\n# At least 10% offers per channel\nfor c in channelsR:\n    solver.Add(solver.Sum(channelVars[o,p,c] for p in productsR for o in offersR) >= len(offers) \/\/ 10)","90914620":"print(f'Number of constraints : {solver.NumConstraints()}' )\nprint(f'Number of variables   : {solver.NumVariables()}')","8b79638e":"# objective \nobj = 0\n\nfor c in channelsR:\n    for p in productsR:\n        product=products[p]\n        coef = channels.get_value(index=c, col=\"factor\") * value_per_product[product]\n        obj += solver.Sum(channelVars[o,p,c] * coef * offers.get_value(index=o, col=product) for o in offersR)\n\nsolver.Maximize(obj)","de14aeff":"# time limit\n#solver.set_time_limit = 100.0","8b7f546d":"sol = solver.Solve()","abdda6ae":"totaloffers = solver.Sum(channelVars[o,p,c] for o in offersR for p in productsR for c in channelsR)\n\nbudgetSpent = solver.Sum(channelVars[o,p,c]*channels.get_value(index=c, col=\"cost\") \n                                           for o in offersR \n                                           for p in productsR \n                                           for c in channelsR)\n\nprint(f'Total offers : {totaloffers.solution_value()}')\nprint(f'Budget Spent : {budgetSpent.solution_value()}')\n\nfor c, n in zip(channelsR, list(channels.name)):\n    channel_kpi = solver.Sum(channelVars[o,p,c] for p in productsR for o in offersR)\n    print(f'{n} : {channel_kpi.solution_value()}')\n\nfor p, n in zip(productsR, products):\n    product = products[p]\n    product_kpi = solver.Sum(channelVars[o,p,c] for c in channelsR for o in offersR)\n    print(f'{n} : {product_kpi.solution_value()}')\n\nprint(f'It has taken {solver.WallTime()} milliseconds to solve the optimization problem.')","27129bc9":"from itertools import product as prod\n\nresults = []\n\nfor o, p, c in prod(list(range(len(offers))),list(range(len(products))), list(range(len(channels)))):\n    if channelVars[(o, p, c)].solution_value() > 0:\n        #print(f'{o} : {products[p]}')\n        results.append([o, products[p]])\n\nresults = pd.DataFrame(results, columns=['index_nb', 'product'])","af99a35a":"results.head()","47fed20d":"results['product'].value_counts()","48586a67":"all_results = offers.merge(results, on='index_nb', how='inner')\nall_results.head()","21da9995":"***Solve the Decision Optimization***","53ed9bde":"***Predict behaviors of the new customers***","3e6eb226":"***Check the 2016 customers***","c4b1742d":"***Package new data with predictions for optimization***","393982d6":"We will reset index, we will use index number.","6338f856":"***Define the decision variables***\n\n* The integer decision variables channelVars, represent whether or not a customer will be made an offer for a particular product via a particular channel.\n* The integer decision variable totaloffers represents the total number of offers made.\n* The continuous variable budgetSpent represents the total cost of the offers made.","80b87ca0":"# Get business decisions on the 2017 data\n\n## Assign campaigns to customers\n* We have predicted who will buy what in the list of new customers.\n* However, we do not have the budget to contact all of them. We have various contact channels with different costs and effectiveness.\n* Furthermore, if we contact somebody, we don't want to frustrate them by proposing multiple products; we want to propose only one product per customer.\n\n***Some input data for optimization***","8827a763":"Whole dataset:","1c76cd34":"***Do some visual analysis of the historical data***\n\nIt's possible to use pandas plotting capabilities, but it would require a new version of it. This Notebook relies on matplotlib as it is present everywhere.","a39f24f6":"The greedy algorithm only gives a revenue of \\$50.8K.\n\n## Replicating IBM Decision Optimization CPLEX Modeling with OR-Tools\n\nLet's create the optimization model to select the best ways to contact customers and stay within the limited budget.","f07d4cc8":"## Understanding the 2016 customers\n\nWe can see that:\n\n* The greater a customer's income, the more likely it is s\/he will buy a savings account.\n* The older a customer is, the more likely it is s\/he will buy a pension account.\n* There is a correlation between the number of people in a customer's household, the number of loan accounts held by the customer, and the likelihood a customer buys a mortgage account. To see the correlation, look at the upper right and lower left corners of the mortgage chart.","535d9234":"The predicted data has the same semantic as the base data, with even more clear frontiers:\n\n* for savings, there is a clear frontier at $50K revenue.\n* for pension, there is a clear frontier at 55 years old customers.\n\nThe training data contains customers who bought more than one product, let's see our prediction","bbc447fa":"**Using a greedy algorithm**\n\n* We create a custom algorithm that ensures 10% of offers are made per channel by choosing the most promising per channel. The algorithm then continues to add offers until the budget is reached.","d9bb5e74":"***Set up the constraints***\n\n* Offer only one product per customer.\n* Compute the budget and set a maximum on it.\n* Compute the number of offers to be made.\n* Ensure at least 10% of offers are made via each channel.","3de81fa6":"# Predict the 2017 customer behavior\n\n**Create and train a simple machine-learning algorithm to predict what the new clients will buy.**","0a2e123f":"***Express the objective***\n\nWe want to maximize expected revenue, so we take into account the predicted behavior of each customer for each product.","37eebb64":"# Understand the historical data\n\nLoad 2016 historical data, analyze it visually, and train a classifier to predict 2017 sales.\n\n***Load the historical customer data with their purchases (Mortgage, Savings, and Pension).***","87949986":"## New customer data and predictions\n\nLoad new customer data, predict behaviors using trained classifier, and do some visual analysis. We have all the characteristics of the new customers, as for the 2016 clients, but the new customers did not buy any product yet.\n\n***Load new customer data***","c308337d":"# How decision optimization can help\n\nPrescriptive analytics (decision optimization) technology recommends actions that are based on desired outcomes. It takes into account specific scenarios, resources, and knowledge of past and current events. With this insight, your organization can make better decisions and have greater control of business outcomes.\n\nPrescriptive analytics is the next step on the path to insight-based actions. It creates value through synergy with predictive analytics, which analyzes data to predict future outcomes.\n\nPrescriptive analytics takes that prediction to the next level by suggesting the optimal way to handle that future situation. Organizations gain a strong competitive advantage by acting quickly in dynamic conditions and making superior decisions in uncertain environments.\n\n* Automate complex decisions and trade-offs to better manage your limited resources.\n* Take advantage of a future opportunity or mitigate a future risk.\n* Proactively update recommendations based on changing events.\n* Meet operational goals, increase customer loyalty, prevent threats and fraud, and optimize business processes.","7ee31640":"In the following visualization, you can see the behavior of the 2016 customers for the three products. The green color indicates that a customer bought a product; red indicates a customer did not buy a product. The depth of the color indicates the number of purchases or non-purchases.","59a675d2":"***Do some visual analysis of the predicted data***","b21b366b":"We use a standard basic support gradient boosting algorithm to predict whether a customer might by product A, B, or C.","858e7ee0":"# Promoting financial products to bank customers\n\nThis kernel is a replication of [CPLEX solution](https:\/\/github.com\/IBMDecisionOptimization\/DOforDSX-MarketingCampaigns-example\/blob\/master\/jupyter\/MarketingCampaigns.ipynb) with an open-source optimization package OR-Tools.\n\nIn 2016, a retail bank sold several products (mortgage account, savings account, and pension account) to its customers. It kept a record of all historical data, and this data is available for analysis and reuse. Following a merger in 2017, the bank has new customers and wants to start some marketing campaigns.\n\nThe budget for the campaigns is limited. The bank wants to contact a customer and propose only one product.\n\nThe marketing department needs to decide:\n\n* Who should be contacted?\n* Which product should be proposed? Proposing too many products is counter productive, so only one product per customer contact.\n* How will a customer be contacted? There are different ways, with different costs and efficiency.\n* How can they optimally use the limited budget?\n* Will such campaigns be profitable?\n\n## Predictive and prescriptive workflow\n\nFrom the historical data, we can train a machine learning product-based classifier on customer profile (age, income, account level, ...) to predict whether a customer would subscribe to a mortgage, savings, or pension account.\n\nWe can apply this predictive model to the new customers data to predict for each new customer what they will buy.\nOn this new data, we decide which offers are proposed. Which product is offered to which customer through which channel:\na. with a greedy algorithm that reproduces what a human being would do\nb. using an optimization model wih IBM Decision Optimization.\nThe solutions can be displayed, compared, and analyzed.\n\nTable of contents:\n\n* Understand the historical data\n* Predict the 2017 customer behavior\n* Get business decisions on the 2017 data\n* Conclusion on the decision making\n\nThis notebook takes some time to run because multiple optimization models are solved and compared in the part dedicated to what-if analysis. The time it takes depends on your subscription type, which determines what optimization service configuration is used.","c7a5509a":"# Remarks on the prediction\n\nThe goal is to contact the customers to sell them only one product, so we cannot select all of them. This increases the complexity of the problem: we need to determine the best contact channel, but also need to select which product will be sold to a given customer.\n\nIt may be hard to compute this. In order to check, we will use two techniques:\n\n* a greedy algorithm\n* OR-Tools, an open-source alternative for optimization(we have replicated CPLEX solution)","a85217c1":"***Allocation Products to Customers***"}}