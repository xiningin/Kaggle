{"cell_type":{"3a1b271e":"code","96ed0cd5":"code","c5e65602":"code","62c79e70":"code","47b3c3a9":"code","0b9586e5":"code","64865676":"code","54510b14":"code","ad1e8bc3":"code","289d26a0":"code","69ba3d4d":"markdown","1c3374b2":"markdown","3b2ae6e3":"markdown","b94e6ea9":"markdown","aa036dd2":"markdown","471eb506":"markdown","c33122f5":"markdown","6b788dd3":"markdown","66b6246a":"markdown","eb2dba0e":"markdown","1d97598a":"markdown","ec189413":"markdown","31d47303":"markdown","1c62a097":"markdown","edcdf5bd":"markdown"},"source":{"3a1b271e":"%%javascript\nIPython.OutputArea.prototype._should_scroll = function(lines) {\n    return false;\n}","96ed0cd5":"import pandas as pd\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\nimport nltk\nfrom nltk.corpus import stopwords\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings('ignore')","c5e65602":"DATA_PATH = \"..\/input\"\n\n## Data Read and Join\ndata = pd.read_csv(os.path.join(DATA_PATH,\"AppleStore.csv\"))\ndescription_data = pd.read_csv(os.path.join(DATA_PATH,\"appleStore_description.csv\"))\n\ndata = data.set_index(\"id\")\ndescription_data = description_data.set_index(\"id\")\n\nfull_data = data.join(description_data,lsuffix='_left', rsuffix='')\n\nfull_data[\"size_bytes\"] = full_data[\"size_bytes_left\"]\ndel full_data[\"size_bytes_left\"],full_data[\"track_name_left\"],full_data[\"Unnamed: 0\"]\n\n## Relevance as absolute measure and relevance by genre\nfull_data[\"abs_relevance\"] = 0\nfull_data[\"genre_relevance\"] = 0\n\ngenres = full_data['prime_genre'].unique().tolist()\nfor el in genres:\n    full_data.loc[full_data[\"prime_genre\"] == el,\"genre_relevance\"] = \\\n    (full_data[full_data[\"prime_genre\"] == el][\"rating_count_tot\"] \/ full_data[full_data[\"prime_genre\"] == el][\"rating_count_tot\"].max() \\\n    + full_data[full_data[\"prime_genre\"] == el][\"user_rating\"] \/ full_data[full_data[\"prime_genre\"] == el][\"user_rating\"].max() )\/ 2\n\nfull_data[\"abs_relevance\"] = (full_data[\"rating_count_tot\"]\/full_data[\"rating_count_tot\"].max()+full_data[\"user_rating\"]\/full_data[\"user_rating\"].max())\/2\nprint(full_data.head())","62c79e70":"fig = plt.figure()\nfig.set_figheight(5)\nfig.set_figwidth(10)\nsns.countplot(full_data[\"user_rating\"])\nplt.show()","47b3c3a9":"fig = plt.figure()\nfig.set_figheight(5)\nfig.set_figwidth(10)\nsns.countplot(y=\"prime_genre\", data=full_data,orient=\"v\")\nplt.show()\nprint(len(full_data[full_data[\"prime_genre\"] == \"Games\"])\/len(full_data))","0b9586e5":"full_data[\"coded_genres\"] = pd.Categorical(full_data[\"prime_genre\"]).codes\nfig = plt.figure()\nfig.set_figheight(5)\nfig.set_figwidth(10)\nsns.heatmap(full_data[[\"abs_relevance\",\"genre_relevance\",\"price\",\n                       \"rating_count_tot\",\"user_rating\",\n                       \"coded_genres\",\"sup_devices.num\",\n                       \"lang.num\",\"size_bytes\"]].corr(),annot=True)\nplt.show()","64865676":"from sklearn.ensemble import RandomForestRegressor\nrgr = RandomForestRegressor()\n\n#prepare training X, Y data set\ntrain_y = full_data[\"abs_relevance\"]\n#drop unused fields\ntrain_x = full_data[[\"price\",\"coded_genres\",\"sup_devices.num\",\n                       \"lang.num\",\"size_bytes\"]]  \n\nrgr.fit(train_x, train_y)\nprint(\"Score of the Regressor:\")\nprint(rgr.score(train_x, train_y))\n# display the relative importance of each attribute\nimportances = rgr.feature_importances_\n\nsorted_feature_importance = sorted(zip(importances, list(train_x)), reverse=True)\nfeature_imp = pd.DataFrame(sorted_feature_importance,columns=[\"importance\",\"feature\"])\nsns.barplot(x=\"feature\", y=\"importance\", data=feature_imp)\nfig = plt.figure()\nfig.set_figheight(5)\nfig.set_figwidth(10)\nplt.show()","54510b14":"## Select the genres\ngenres = full_data['prime_genre'].unique().tolist()\n\ndef frequency_dist(genres_list,name=False,description=True):\n    for i,el in enumerate(genres_list):\n        fig = plt.figure()\n        fig.set_figheight(5)\n        fig.set_figwidth(10)\n\n        ## Filter the dataframe by genre\n        genre_data = full_data[full_data[\"prime_genre\"] == el]\n\n        ## Filter by Rating > 0.5\n        genre_data = genre_data[genre_data[\"genre_relevance\"] > 0.5]\n\n        ## Tokenize the sentences of the description or name\n        if description:\n            genre_data[\"description_list\"] = genre_data[\"app_desc\"].apply(lambda x: nltk.word_tokenize(x.lower()))    \n        elif name:\n            genre_data[\"description_list\"] = genre_data[\"track_name\"].apply(lambda x: nltk.word_tokenize(x.lower()))\n        else:\n            print(\"Incorrect Flags value\")\n            return 0\n        list_of_words = genre_data[\"description_list\"].tolist()\n        list_of_words = [item for sublist in list_of_words for item in sublist]\n\n        ## Remove stopwords\n        list_of_words = [word for word in list_of_words if word not in stopwords.words('english')]\n\n        ## Filter by nouns\n        is_noun = lambda pos: pos[:2] == 'NN'\n        list_of_words = [word for (word, pos) in nltk.pos_tag(list_of_words) if is_noun(pos)] \n\n        ## Remove some special chars from the words list\n        for char in \" {}[]^`\u00b4-_\u00b7@|\u00bf?\u00a1!'+*\\\"?.!\/;:<>\u2019\u2022\u201c\u201d\u2013\u00bb%\u25a0\":\n            while char in list_of_words:\n                list_of_words.remove(char)\n\n        ## Create the frequency distribution\n        fdist = nltk.FreqDist(list_of_words)\n        \n        ## Sort the dataframe by Rating\n        write_genre_data = genre_data[[\"track_name\",\"genre_relevance\"]]\n        write_genre_data = write_genre_data.sort_values(\"genre_relevance\",ascending=False)\n\n        ## Print the outputs\n        print(el)\n        print(\"-----------------------\")\n        print(write_genre_data[[\"track_name\",\"genre_relevance\"]].head())\n        fdist.plot(50,cumulative=False,title=el)\n\n        ## If someone wants to write the outputs\n        #write_genre_data.to_csv(os.path.join(DATA_PATH,el+\".csv\"),sep=\";\")\n        \nfrequency_dist(genres_list=[\"Games\"],name=False,description=True)","ad1e8bc3":"frequency_dist(genres_list=[\"Games\"],name=True,description=False)","289d26a0":"import seaborn as sns\nfig = plt.figure()\nfig.set_figheight(5)\nfig.set_figwidth(10)\ngaming_data = full_data[full_data[\"prime_genre\"] == \"Games\"]\ngaming_data[\"rating_count_perc\"] = gaming_data[\"rating_count_tot\"]\/gaming_data[\"rating_count_tot\"].max()\ngaming_data[\"user_rating_perc\"] = gaming_data[\"user_rating\"]\/gaming_data[\"user_rating\"].max()\n\ngaming_data[\"rating\"] = (gaming_data[\"rating_count_perc\"]+gaming_data[\"user_rating_perc\"])\/2\ngaming_data = gaming_data[gaming_data[\"rating\"] > 0.5]\n\nsns.countplot(y=\"price\", data=gaming_data,orient=\"v\")\nplt.show()","69ba3d4d":"## Prediction <a id=\"Prediction\"><\/a>\n","1c3374b2":"I assume that *game, games and play* are not that interesting because all the games can share these words.\n\nBut, from the previous plot, one can see that in a videogame's description, the following words can be interesting:\n* world\n* levels\n* items\n* friends\n* experience\n* money\n* skills\n* graphics\n* battle\n* adventures\n\n\nThese concepts can be in some sense related to RPG games? or strategy games?\n\nSo an **RPG game** can be a good topic if we want to create a gaming App.\n\nContinuating with the **Text Analysis** topic, which can be the name of this gaming App?","3b2ae6e3":"## Conclusions <a id=\"Conclusions\"><\/a>\n\nAll comments and observations are welcome of course!!\n\n* The kernel under construction, I will make uploads related to:\n     * Predict Relevance of Apps","b94e6ea9":"First of all let me read the data and do some operations with the dataset to be able to work easily during the whole kernel. Also I will create the variables that I defined as **relevance**.","aa036dd2":"## Word Embeddings <a id=\"Word Embeddings\"><\/a>\n\nAt this point I decided to use the nouns in the description and the name of the App as variables to predict the relevance of an App. So I decided to use a word embedding to be able to code these nouns as vectors, and later use those numerical variables as predictors. \n\nThe best word embeddings are usually pre-built learning from Wikipedia, Google Datasets, dictionaries and many other sources of information, and trained with very powerful data centers (I do not want to load a pre-built embedding because their size is huge for a Kaggle kernel). \n\nI will try to train only with the given dataset a **word2vec model** using eager tensorflow, and see if I can achieve coherent results.\n\n* Future uploads...","471eb506":"So finally and as what the common sense says, nowadays the most popular idea will be an RPG game that contains dungeons, levels, items, and challenges that one can share with friends, everything for 0 USD. This does not mean that we can not make money out of our RPG game, because this dataset does not include the money make out of micro-payments, adds, internal stores, etc.\n\nThis analysis gives us an idea of what kind of application can we develop if we want to have a good **Relevance**, which for me has sense.","c33122f5":"## Words frequency analysis <a id=\"Words frequency analysis\"><\/a>\nHere is the code to plot the frequency distributions of the nouns in the App descriptions splitted by genre.","6b788dd3":"Surprisingly, at least for me, more than a 50% of the Apps are Games. So probably if we want to develop a new App, a Game is the trendy option now.\n\nNow, we are going to see a heatmap of the correlations between the following variables:\n* price\n* rating_count_tot\n* user_rating\n* prime_genre (as categorical variable)\n* sup_devices.num\n* lang.num\n* size_bytes\n* abs_relevance\n* genre_relevance\n","66b6246a":"The previous plot represents the distribution of the ratings overall the dataset. Is quite logic that many Apps have rating 0, as is where you start when you upload a new App (so this 900 Apps are \"indie\" Apps with rating 0 probably). All other bars are also quite logic, the distribution is not a normal distribution but makes sense that only good rated Apps remain available in the App Store. \n\nNow we are going to see how the dataset is splitted in terms of the **prime_genre** variable.","eb2dba0e":"This is another way to see the features to do a little bit of feature engineering for the posterior **Predictions** in the kernel.\n\nFrom now, we are going to start with the **Text Analysis** part of the kernel, so because of simplicity and because of the percentatge of data, we are going to work mainly with **Games** data.","1d97598a":"## Preliminar analysis <a id=\"Preliminar analysis\"><\/a>\n\nFirstly the most important, the table describing the data of **appleStore.csv**:\n\n| column name | description | values |\n| ----------- | ----------- | ------ |\n| id | Identifier of the App | Integer |\n| track_name | Name of the App | String |\n| size_bytes | Size of the App in Bytes | Integer |\n| currency | Basically USD | String |\n| price | Price of the App | Float |\n| rating_count_tot | Number of ratings over all versions | Integer |\n| rating_count_ver | Number of ratings on the current version | Integer |\n| ver | Current version of the App | Integer |\n| cont_rating | Rating of the Content | String |\n|prime_genre| Genre of the App (Entertainment, Games, etc.) | String |\n| sup_devices.num | Number of supported devices | Integer |\n|ipadSc_urls.num| Number of screenshots showed in the display | Integer |\n|lang.num| Number of supported languages | Integer |\n|vpp_lic| Vpp Device Based Licensing Enabled | String |\n\nAnd also, the table describing the data of **appleStore_description.csv**:\n\n| column name | description | values |\n| ----------- | ----------- | ------ |\n| id | Identifier of the App | Integer |\n| track_name | Name of the App | String |\n| size_bytes | Size of the App in Bytes | Integer |\n| app_desc | Little text with the description of the App | String |\n\nNow all of us know what we are talking about, I wanted to know a measure of relevance or importance, but it is not explicitly here, because all the original data is objective. Then I decided to measure the relevance $\\mathcal{R}$ as:\n\n$$\\mathcal{R} = \\frac{\\frac{rating\\_count\\_tot}{max(rating\\_count\\_tot)} + \\frac{user\\_rating}{max(user\\_rating)}}{2}$$\n\nObviously, $\\mathcal{R} \\in \\{0,1\\}$, and if hypothetically the App $\\mathcal{A}$ had the maximum number of $rating\\_count\\_tot$ and a $user\\_rating$ of $5$, then $\\mathcal{A}$ will have a $\\mathcal{R}$ of $1$. \n\nTo turn to the heart of the matter, lets load some libraries and see some plots of the data...\n<!--\nI considered that a **concept** is a noun in the description or naming of an App.\n-->","ec189413":"# Text Analysis on Apps Data\n**This is my first kernel and I hope that this tiny work can be helpful for someone.**\n\nBasically what I tried to do in this kernel is an analysis of the dataset, a little bit focused on the Text Analysis part. Finally I tried to do predictions based on the previous analysis.  \n\n1. [Preliminar analysis](#Preliminar analysis)\n2. [Words frequency analysis](#Words frequency analysis)\n3. [Word Embeddings](#Word Embeddings)\n4. [Prediction](#Prediction)\n5. [Conclusions](#Conclusions)","31d47303":"With this print, we check that we have joined the databases correctly, and we also have created the relevance columns in a proper manner.","1c62a097":"The conclusions of this plot are the following:\n* Obviusly user_rating and rating_count_tot are correlated with relevances by the construction of the relevance variables\n* price is not really correlated with the relevance which has sense in my personal opinion (many Apps have internal stores where you spend the money but their price is 0)\n* genre_relevance and abs_relevance are really correlated due to the percentatge of Apps that are Games.\n* lang.num is related with relevance, which is interesting.\n* lang.num is quite related with many variables, so probably it can be a good predictor of the relevance of the App (we will see this later in this kernel).\n\nAnother way to see the importances of the variables with respect to the **relevance** is to use a RFC (Random Forest Classifier).","edcdf5bd":"**zombies kingdom rpg** or **machines war infinity edition**...\n\nThe important fact is that the names that appear in the previous plot are also related to the **RPG Games** so this confirms a little bit our hypothesis that an RPG Game can be a good option if we want to update an App to the AppStore.\n\nAnother important feature that we want to know about our new game is, how many dollars should it cost if we want to have good relevance ratios?"}}