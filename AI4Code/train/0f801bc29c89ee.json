{"cell_type":{"06e574ba":"code","5ceafbe6":"code","16b72dc1":"code","082978bc":"code","7df9eaf8":"code","e3879d83":"code","7b6ade3c":"code","962d179b":"code","be945e4e":"code","d96f98b7":"code","cc2b13be":"code","f5f95403":"code","276a9ad3":"code","42bbe5ca":"code","b5b8e1fc":"code","f5efbf22":"code","7b593c52":"code","214f6b13":"code","a2c16681":"code","a493d916":"code","61d19ed4":"code","e446221c":"code","2bb27f9b":"code","8a920c37":"code","518eabba":"code","3e91b14b":"code","c9fe9b0e":"code","bd7a16fe":"code","fa21f9eb":"code","c388d0d2":"code","b20fd81d":"code","2cd30eec":"code","6b6996c6":"code","eed281f4":"code","a5de2a97":"code","e21b6437":"code","878bab44":"code","5963bb62":"code","3957c1d9":"code","01715db1":"code","67fec7d3":"code","fda93e18":"code","752ba660":"code","ee3fb20e":"code","4d4d2b30":"code","986d8ee9":"code","dd35e410":"code","07cff104":"markdown","a3bbd008":"markdown","c671e183":"markdown","6c70a696":"markdown","8ac2f3c0":"markdown","98cf3776":"markdown","7767ffa8":"markdown","0db67925":"markdown","ec4e3311":"markdown","f4f5a075":"markdown","2ace7e85":"markdown","76c19324":"markdown","5ef9ab5a":"markdown","90e78b7e":"markdown","5dfa2502":"markdown","dd9286c5":"markdown","5a9e6054":"markdown","26999fb3":"markdown","5a76362c":"markdown","7b5f18c0":"markdown","689979ac":"markdown","281f5d18":"markdown","ee2fba78":"markdown","cfcb0c8e":"markdown","169a76e4":"markdown","b6cad54a":"markdown","852f5936":"markdown","c5077cc6":"markdown","3c936c89":"markdown","4a8c7da9":"markdown","57ddd298":"markdown","3f2b12c0":"markdown","cda9697e":"markdown","d7438cd9":"markdown","d861fda6":"markdown"},"source":{"06e574ba":"from matplotlib import pyplot as plt\n\ndef show_image(image, title='Image', cmap_type='gray'): \n  plt.imshow(image, cmap=cmap_type)\n  plt.title(title)\n  plt.axis('off')\n  plt.show()","5ceafbe6":"# show a image of a rocket\nfrom skimage import data \nrocket_image = data.rocket()\nshow_image(rocket_image, 'A rocket')","16b72dc1":"from skimage import color\nrocket_image_gray = color.rgb2gray(rocket_image)\nshow_image(rocket_image_gray)","082978bc":"import numpy as np\n\nflipped_rocket_image = np.flipud(rocket_image)\nshow_image(flipped_rocket_image, 'Flipped rocket')","7df9eaf8":"red = rocket_image[:,:,0]\ngreen = rocket_image[:,:,1]\nblue = rocket_image[:,:,2]\n\nshow_image(red, 'Red channel')\nshow_image(green, 'Green channel')\nshow_image(blue, 'Blue channel')","e3879d83":"rocket_image.shape # the third argument in parenthesis indicates that there are three channels in that image","7b6ade3c":"rocket_image.size # the size of a image is the total count of pixels: 427x640","962d179b":"red = rocket_image[:, :, 0] # using the red channel of the rocket image.\n\nplt.hist(red.ravel(), bins=256) # plot its histogram with 256 bins, the number of possible values of a pixel.\nplt.title('Red Histogram')\nplt.show","be945e4e":"cameraman_image = data.camera()\nshow_image(cameraman_image, 'Original cameraman')\n\nthresh = 120 # set a random thresh value\n\nbinary_high = cameraman_image > thresh\nbinary_low = cameraman_image <= thresh\n\nshow_image(binary_high, 'Tresholded high values')\nshow_image(binary_low, 'Tresholded low values')","d96f98b7":"text_image = data.page()\n\nshow_image(text_image, 'Text image')","cc2b13be":"from skimage.filters import try_all_threshold\n\nfig, ax = try_all_threshold(text_image, verbose=False)","f5f95403":"from skimage.filters import threshold_otsu\n\nthresh = threshold_otsu(text_image)\n\ntext_binary_otsu = text_image > thresh\n\nshow_image(text_binary_otsu, 'Otsu algorithm')","276a9ad3":"from skimage.filters import threshold_local\n\nblock_size = 35 # define the size of the region to apply the binarization\n\nlocal_thresh = threshold_local(text_image, block_size, offset=10) # apply the function\n\nbinary_local = text_image > local_thresh\n\nshow_image(binary_local)","42bbe5ca":"def plot_comparison(original, filtered, title_filtered):\n  fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(8, 6), sharex=True, sharey=True)\n  ax1.imshow(original, cmap=plt.cm.gray) \n  ax1.set_title('original') \n  ax1.axis('off')\n  ax2.imshow(filtered, cmap=plt.cm.gray) \n  ax2.set_title(title_filtered) \n  ax2.axis('off')","b5b8e1fc":"from skimage.filters import sobel\n\ncoins_image = data.coins() # use the coins image as an example\n\nedge_coins_image = sobel(coins_image) # apply the filter\n\nplot_comparison(coins_image, edge_coins_image, 'Edge coins')","f5efbf22":"from skimage.filters import gaussian\n\ncat_image = data.chelsea()\n\nsmmooth_cat_image = gaussian(cat_image, multichannel=True) # you have to specify the multichannel\n\nplot_comparison(cat_image, smmooth_cat_image, 'Smooth cat')","7b593c52":"from skimage import exposure\n\nmoon_image = data.moon()\n\nequalized_image_moon = exposure.equalize_hist(moon_image)\n\nplot_comparison(moon_image, equalized_image_moon, 'Histogram equalization')","214f6b13":"from skimage import exposure\n\nadapthits_image_moon = exposure.equalize_adapthist(moon_image)\n\nplot_comparison(moon_image, adapthits_image_moon, 'Adaptive Histogram equalization')","a2c16681":"from skimage.transform import rotate\n\ncoffe_image = data.coffee()\n\nrotate_coffe_image = rotate(coffe_image, -90) # rotate clockwise\n\nshow_image(rotate_coffe_image)","a493d916":"from skimage.transform import rescale\n\nrescale_coffe_image = rescale(coffe_image, 1\/2, anti_aliasing=True, multichannel=True) # rescaling by 1\/2 of the original image\n\nshow_image(coffe_image)\nprint(coffe_image.shape)\n\nshow_image(rescale_coffe_image)\nprint(rescale_coffe_image.shape)\n\n","61d19ed4":"from skimage.transform import rescale\n\nrescale_coffe_image = rescale(coffe_image, 5, anti_aliasing=True, multichannel=True) # rescaling by 1\/2 of the original image\n\nshow_image(coffe_image)\nprint(coffe_image.shape) # the shape of the original image\n\nshow_image(rescale_coffe_image)\nprint(rescale_coffe_image.shape) # the shape of the rescaled image","e446221c":"from skimage.transform import resize\n\nheight = 600 \nwidth = 1000\n\nresized_coffe_image = resize(coffe_image, (height, width), anti_aliasing=True)\n\nshow_image(coffe_image)\nprint(coffe_image.shape) # the shape of the original image\n\nshow_image(resized_coffe_image)\nprint(resized_coffe_image.shape) # the shape of the resized image","2bb27f9b":"from skimage import morphology\n\nhorse_image = data.horse()\n\neroded_horse_image = morphology.binary_erosion(horse_image)\n\nplot_comparison(horse_image, eroded_horse_image, 'Eroded image')","8a920c37":"dilated_horse_image = morphology.binary_dilation(horse_image)\n\nplot_comparison(horse_image, dilated_horse_image, 'Dilated image')","518eabba":"from skimage.util import random_noise\n\ncat_image = data.chelsea()\n\nnoisy_cat_image = random_noise(cat_image)\n\nplot_comparison(cat_image, noisy_cat_image, 'Noisy image')","3e91b14b":"from skimage.restoration import denoise_tv_chambolle\n\ndenoised_cat_image = denoise_tv_chambolle(noisy_cat_image, weight=0.1,multichannel=True)\n\nplot_comparison(noisy_cat_image, denoised_cat_image, 'Denoised image')","c9fe9b0e":"from skimage.restoration import denoise_bilateral\n\ndenoised_cat_image = denoise_bilateral(noisy_cat_image, multichannel=True)\n\nplot_comparison(noisy_cat_image, denoised_cat_image, 'Denoised image')","bd7a16fe":"coins_image = data.coins()\n\nthresh = 90 # set a random thresh value\n\nsegmented_coins_image = coins_image > thresh\n\nplot_comparison(coins_image, segmented_coins_image, 'Segmented image')","fa21f9eb":"from skimage.segmentation import slic # import te slic function\n\nfrom skimage.color import label2rgb # import te label2rgb function\n\nsegments_400 = slic(coffe_image, n_segments = 400) # segmentation with 400 regions\n\nsegmented_image_400 = label2rgb(segments_400, coffe_image, kind='avg')\n\nsegments_40 = slic(coffe_image, n_segments = 40) # segmentation with 400 regions\n\nsegmented_image_40 = label2rgb(segments_40, coffe_image, kind='avg')\n\nshow_image(segmented_image_400, '400 regions of segmentation')\n\nshow_image(segmented_image_40, '40 regions of segmentation')","c388d0d2":"# A function to show the contour of the image \ndef show_image_contour(image, contours):\n    plt.figure()\n    for n, contour in enumerate(contours):\n        plt.plot(contour[:, 1], contour[:, 0], linewidth=3)\n    plt.imshow(image, interpolation='nearest', cmap='gray_r')\n    plt.title('Contours')\n    plt.axis('off')\n    plt.show()","b20fd81d":"from skimage import measure\n\nhorse_image = data.horse()\n\ncontours_horse_image = measure.find_contours(horse_image, 0.8)\n\nshow_image_contour(horse_image, contours_horse_image)","2cd30eec":"from PIL import Image\nfrom numpy import asarray\n\ndices_image = Image.open('\/content\/drive\/My Drive\/Notebooks\/dices.png')\n\ndices_image = asarray(dices_image)\n\nshow_image(dices_image)","6b6996c6":"from skimage import filters\n\ndices_image_gray = color.rgb2gray(dices_image)\n\nthresh = filters.threshold_otsu(dices_image_gray)\n\nbinary_dices_image = dices_image_gray > thresh\n\ncontours = measure.find_contours(binary_dices_image, 0.8)\n\nshow_image_contour(binary_dices_image, contours)","eed281f4":"from skimage.feature import canny\n\ncoins_image = data.coins()\n\ncoins_image_gray = color.rgb2gray(coins_image)\n\ncanny_coins_image = canny(coins_image_gray)\n\nshow_image(canny_coins_image)","a5de2a97":"bulding_image = Image.open('\/content\/drive\/My Drive\/Notebooks\/corners_building_top.jpg')\n\nbulding_image = asarray(bulding_image)\n\nshow_image(bulding_image)","e21b6437":"from skimage.feature import corner_harris, corner_peaks\n\nbulding_image_gray = color.rgb2gray(bulding_image)\n\ncorner_bulding_image_gray = corner_harris(bulding_image_gray) \n\nshow_image(corner_bulding_image_gray) \n\ncoords = corner_peaks(corner_bulding_image_gray, min_distance=5) # find de coordinates of the corners\n\nprint(\"A total of\", len(coords), \"corners were detected.\")","878bab44":"def show_image_with_corners(image, coords, title=\"Corners detected\"): \n  plt.imshow(image, interpolation='nearest', cmap='gray') \n  plt.title(title)\n  plt.plot(coords[:, 1], coords[:, 0], '+r', markersize=15) \n  plt.axis('off')\n  plt.show()","5963bb62":"show_image_with_corners(corner_bulding_image_gray, coords)","3957c1d9":"from skimage.feature import Cascade\n\ntrained_file = data.lbp_frontal_face_cascade_filename() # load the training file\n\ndetector = Cascade(trained_file) # initialize the detector cascade.","01715db1":"astronaut_image = data.astronaut()\n\n# Apply detector on the image\ndetected = detector.detect_multi_scale(img=astrounaut_image, \n                                       scale_factor=1.2,\n                                        step_ratio=1,\n                                        min_size=(10, 10), max_size=(200, 200))\n\nprint(detected)","67fec7d3":"from matplotlib import patches\n\ndef show_detected_face(result, detected, title=\"Face image\"):\n    plt.figure()\n    plt.imshow(result)\n    img_desc = plt.gca()\n    plt.set_cmap('gray')\n    plt.title(title)\n    plt.axis('off')\n\n    for patch in detected:\n        \n        img_desc.add_patch(\n            patches.Rectangle(\n                (patch['c'], patch['r']),\n                patch['width'],\n                patch['height'],\n                fill=False,\n                color='r',\n                linewidth=2)\n        )\n    plt.show()","fda93e18":"show_detected_face(astronaut_image, detected)","752ba660":"from PIL import Image\nfrom numpy import asarray\n\nflamengo_image = Image.open('\/content\/drive\/My Drive\/Notebooks\/flamengo.jpg')\n\nflamengo_image = asarray(flamengo_image)\n\ndetected = detector.detect_multi_scale(img=flamengo_image, \n                                       scale_factor=1.2,\n                                        step_ratio=1,\n                                        min_size=(10, 10), max_size=(200, 200))\n\nshow_detected_face(flamengo_image, detected)\n","ee3fb20e":"image = data.astronaut()\n\ndef getFaceRectangle(d):\n    ''' Extracts the face from the image using the coordinates of the detected image '''\n    # X and Y starting points of the face rectangle\n    x, y  = d['r'], d['c']\n    \n    # The width and height of the face rectangle\n    width, height = d['r'] + d['width'],  d['c'] + d['height']\n    \n    # Extract the detected face\n    face = image[ x:width, y:height]\n    return face","4d4d2b30":"detected = detector.detect_multi_scale(img=image, \n                                       scale_factor=1.2,\n                                        step_ratio=1,\n                                        min_size=(10, 10), max_size=(200, 200))","986d8ee9":"\ndef mergeBlurryFace(original, gaussian_image):\n     # X and Y starting points of the face rectangle\n    x, y  = d['r'], d['c']\n    # The width and height of the face rectangle\n    width, height = d['r'] + d['width'],  d['c'] + d['height']\n  \n    original[x:width, y:height] =  gaussian_image\n    return original\n","dd35e410":"from skimage.filters import gaussian\n\n#image.setflags(write=1)\n\nfor d in detected: \n  face = getFaceRectangle(d)\n  \n  gaussian_face = gaussian(face, multichannel=True, sigma = 1) # Apply gaussian filter to extracted face\n  \n  resulting_image = mergeBlurryFace(image, gaussian_face) # Merge this blurry face to our final image and show it\n\nshow_image(resulting_image, \"Blurred faces\")\n ","07cff104":"### Contrast Enhancement\n\nEnhance an image can show some features not present in the original data. We can enhace an image changing its contrast or doing whats is called histogram equalization.\n\nThe histogram equalization makes the histogram of the image flat. It changes the pixel values and makes some parts of the image more exposed compared to the original image. \n\nThe histogram equalization is achieved using the equalize_hist() function from skmigage.exposure library.\n","a3bbd008":"Finally we apply the gaussian filter in each face:","c671e183":"Then detect the faces:","6c70a696":"### Noise and Denoising\nNoise are common distortions in images. A common noise we is te salt and pepper noise. We can simulate this noise by applying the random_noise function to the image.","8ac2f3c0":"# Image Processing in Python\n\nThis notebook presents some image processing techniques with python. The objective is to show some easy techniques to apply as pre-processing to use in images from datasets to train\/test some Machine Learning models. \n\nThe summary of the notebook:\n\n\n1.   What is image processing;\n2.   NumPy on image processing;\n3.   Histogram with Matplotlib;\n3.   Thresholding algorithms;\n4.   Filters;\n5.   Contrast enhancement;\n6.   Transformation;\n7.   Morphology operations;\n9.   Noise e denoising;\n10.  Segmentation;\n11.  Finding contours;\n12.  Finding edges;\n13.  Corner detection;\n14.  Face detection;\n15.  Blurring faces for privacy protection.\n\n","98cf3776":"The image above shows the corner as white points. But we can match those corners and show them.\n\nBut first we need do this.\n","7767ffa8":"To filter the noise out, we can use the denoise_tv_chambolle() function of the skimage.restoration library.","0db67925":"To thresh a image is normally called \"binarization\" of the image. This technique is widely used to provide a better look in some images. As an axample take a look in the next image.","ec4e3311":"### Filters\nA filter is a mathematical function applied to images. It can enhancing an image, emphasize or remove features, smooth an image or detect edges, for example. \n\nAs an example, take a look in the Sobel Filter and its edge detection. To use that filter, we need the library skimage.filters ant its function called sobel().\n\nBut first, lets ma=ke a function to compare original images to processed images.\n","f4f5a075":"NumPy can also show the shape and size of images:","2ace7e85":"### Blurring faces for privacy protection.\n\nOne application using some knowledge we that we obtained is to blur faces detected in ah image.\n\nTo do that we first get the faces presented in an image then apply a filter. The last step is to put back the faces in the original image. \n\nFirst extract the face rectangle from the image using the coordinates of the detected:\n","76c19324":"### Corner Detection\nA corner can be defined as the intersection of two edges. A corner can also be defined as a point for which there are two dominant and different edge directions in a local neighbourhood of the point. An interest point is a point in an image which has a well-defined position and can be robustly detected\n\nCorners can be found by using the function corner_harris() and corner_peaks() from skimage.feature library.\n\n","5ef9ab5a":"### Finding Edges\nEdge detection includes a variety of mathematical methods that aim at identifying points in a digital image at which the image brightness changes sharply or, more formally, has discontinuities.\n\nA famous function to find edges is called canny. This functions is found in the skimage.feature library.\n","90e78b7e":"We can use filters to smooth an image too. To see this feature, use the gaussian() filter function.","5dfa2502":"## NumPy on image processing\n\nThe NumPy library has some famous features. Some of those features are used in image processing too.\n\nAs a first demonstration, flip images:","dd9286c5":"### Thresholding algorithms\n\nHistograms are tipically used to to see the range of pixels values in a image. Using those pixel values, we can threshold then to a limit value:","5a9e6054":"## What is image processing?\nImage processing is to apply of some operations to images, like enhance an image, extract useful information and analyze it and make decisions. \n\nWe can list some applications for image processing: medical image analysis, artificial intelligence, image restoration and geospatial computing.\n\nAn image is made up of pixels. Each pixel has a position and a value that refers to its color. An image may be gray scale or colored. Gray scale images have just a channel with its pixels value ranging from 0 to 255. Colored images have three channels of color, one to red, oter to blue and other to green (the rgb set), with its pixels value ranging from 0 to 255 for each channel.\n\nThe skimage library has some good features we can use to manipulate images. The first we will see is to import some images.\n\nBut first, lets create a function to show images with better view.","26999fb3":"We can also detec more than one face:","5a76362c":"To apply the optimal thresh we can use the Otsu algorithm:\n","7b5f18c0":"From a colored image we can reach a gray scaled image using color function:","689979ac":"Create a function to show de detected face:","281f5d18":"### Morphological operations\nMorphological operations provide some dilations and erosion on the images. \n\nThose operations can be done using the skimage.morphology library.","ee2fba78":"But, we can segement an image by more meaningful regions. It can be done applying the superpixel segmentation. With this function, we can chose the number of regions to segment the image. This segmentations is done using unsupervised K-means algorithm.","cfcb0c8e":"For the Text image, we can provide a better loking in its rigth conner. To do this the binarization is a good way. But, the value of thresh has to be defined. To do this, some algorithms are present in the skimage library. We can try all those algorithms using the function try_all_threshold() from skimage.filters library.","169a76e4":"### Transformation\n\nTransform a image can provide some pre-processing tools to better understand informations presents in the image. Some commun transformations of an image is to rotate, rescaling and resize. \n\nThe library skimage.transform as some good functions to make transform images. ","b6cad54a":"There ara some others algorithms to equalize the histogram, like adaptive histogram equalization:","852f5936":"### Finding contours\nFinding contours of an image is a good way to explore its features. We can measure size, classify shapes ande also Determine the number of objects by just using the shape of the image. \n\nFirst lets find the contours of an image.","c5077cc6":"NumPy also can be used to show the rgb channels of a image:","3c936c89":"### Histogram with Matplotlib\n\nMatplotLib is a famous library from python used to plot graphs and show images. I has used this library to create the function show_image().\n\nBut this library can also show the histogram of a image. Histograms show the count of each pixel value:","4a8c7da9":"We can now count the numbers showed in the dices. ","57ddd298":"### Segmentation\n\nImage segmentation is the process of assigning a label to every pixel in an image such that pixels with the same label share certain characteristics.\n\nA simple thresholding of an image can provide an segmentation:","3f2b12c0":"### Face detection\nFace detection is a computer technology being used in a variety of applications that identifies human faces in digital images. Face detection also refers to the psychological process by which humans locate and attend to faces in a visual scene.\n\nThe function we will use to face detection is named detect_multi_scale() from skimage.feature library. \n\nAfter a classifier is trained, it can be applied to a region of interest (of the same size as used during the training) in an input image. The classifier outputs a \u201c1\u201d if the region is likely to show the object (i.e., face\/car), and \u201c0\u201d otherwise. To search for the object in the whole image one can move the search window across the image and check every location using the classifier. The classifier is designed so that it can be easily \u201cresized\u201d in order to be able to find the objects of interest at different sizes, which is more efficient than resizing the image itself. So, to find an object of an unknown size in the image the scan procedure should be done several times at different scales.\n\nMore informations about this algorithm can be found at this site [Haar Feature-based Cascade Classifier for Object Detection](https:\/\/docs.opencv.org\/2.4\/modules\/objdetect\/doc\/cascade_classification.html).\n","cda9697e":"Other way to denoise an image is to apply the denoise_bilateral() function, also from skimage.restoration library.","d7438cd9":"## The End\n\nThank you so much for reading this notebook. I hope I helped you understand image processing.\n\nAny problem, please, talk to me!\n\nBye!","d861fda6":"As we can see by the use of those algorithms, the right corner don't show the words as we expected. To solve that problem, we have to apply the binariation to regions of the image. To do that we use the function threshold_local() from skimage.filters library."}}