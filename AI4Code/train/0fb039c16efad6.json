{"cell_type":{"1cb1c221":"code","e25c840f":"code","495ff548":"code","ed20631a":"code","eb6fe03e":"code","ba378311":"code","ced17b6b":"code","af81b6c9":"code","e3f69c2a":"code","42847b69":"code","8c9bb67a":"code","c8ed6f67":"markdown","2976ee91":"markdown","28b1ed03":"markdown"},"source":{"1cb1c221":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","e25c840f":"from scipy.optimize import basinhopping\nfunc = lambda x: np.cos(14.5 * x - 0.3) + (x + 0.2) * x\n\nx0=[1.]","495ff548":"#In numerical optimization, the Broyden\u2013Fletcher\u2013Goldfarb\u2013Shanno (BFGS) algorithm is an iterative method for solving unconstrained nonlinear optimization problems.\nminimizer_kwargs = {\"method\": \"BFGS\"}","ed20631a":"basinhopping(func, x0, minimizer_kwargs=minimizer_kwargs, niter=200)","eb6fe03e":"ret = basinhopping(func, x0, minimizer_kwargs=minimizer_kwargs, niter=200)\nprint(\"global minimum: x = %.4f, f(x0) = %.4f\" % (ret.x, ret.fun))","ba378311":"x = np.arange(-4*np.pi,4*np.pi,0.1)   # start,stop,step\ny = np.cos(14.5 * x - 0.3) + (x + 0.2) * x\nimport matplotlib.pyplot as plt\nplt.plot(x,y)\nplt.show()","ced17b6b":"def func2d(x):\n  f = np.cos(14.5 * x[0] - 0.3) + (x[1] + 0.2) * x[1] + (x[0] + 0.2) * x[0]\n  df = np.zeros(2)\n  df[0] = -14.5 * np.sin(14.5 * x[0] - 0.3) + 2. * x[0] + 0.2\n  df[1] = 2. * x[1] + 0.2\n  return f, df","af81b6c9":"minimizer_kwargs = {\"method\":\"L-BFGS-B\", \"jac\":True}","e3f69c2a":"x0 = [1.0, 1.0]","42847b69":"basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs, niter=200)","8c9bb67a":"ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs, niter=200)\nprint(\"global minimum: x = [%.4f, %.4f], f(x0) = %.4f\" % (ret.x[0],\n                                                          ret.x[1],\n                                                          ret.fun))","c8ed6f67":"Next consider a 2-D minimization problem. Also, this time, we will use gradient information to significantly speed up the search.","2976ee91":"Find the global minimum of a function using the basin-hopping algorithm","28b1ed03":"We\u2019ll also use a different local minimization algorithm. Also, we must tell the minimizer that our function returns both energy and gradient (Jacobian)."}}