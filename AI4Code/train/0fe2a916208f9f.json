{"cell_type":{"0d7d0638":"code","c834fbef":"code","452a7df3":"code","a570ea73":"code","cc532918":"code","a72bed21":"code","527c73c8":"code","ffce3909":"code","c4772ad9":"code","18917ead":"code","eca2be8c":"code","45926c9e":"code","87ddb8d5":"code","050cd8d0":"code","99116401":"code","777516cb":"code","a3f6882c":"code","ded72bc9":"code","02c71727":"code","e91efa35":"code","3fd4eb70":"code","79d68910":"code","6d6a2691":"code","cd1154cb":"code","d027f4fc":"markdown","7ee1b0e4":"markdown","ff100be5":"markdown","44e1c634":"markdown","113e50d1":"markdown"},"source":{"0d7d0638":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport os\nimport random\nimport cv2\nimport tensorflow as tf\nfrom math import ceil, floor\nfrom copy import deepcopy\nfrom tqdm.notebook import tqdm\nfrom imgaug import augmenters as iaa\nimport tensorflow.keras as keras\nimport tensorflow.keras.backend as K\nfrom tensorflow.keras.callbacks import Callback, ModelCheckpoint\nfrom tensorflow.keras.layers import Dense, Flatten, Dropout\nfrom tensorflow.keras.models import Model, load_model\nfrom tensorflow.keras.utils import Sequence\nfrom tensorflow.keras.losses import binary_crossentropy\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.metrics import AUC, Recall, Precision, BinaryCrossentropy\nfrom tensorflow.keras.applications.densenet import DenseNet121\nfrom tensorflow.keras.layers import *\nfrom sklearn.utils.class_weight import compute_class_weight\nfrom prettytable import PrettyTable\nfrom sklearn.metrics import roc_auc_score, accuracy_score, precision_score, recall_score, f1_score\nfrom sklearn.metrics import precision_recall_curve\nfrom sklearn.metrics import average_precision_score\nfrom sklearn.metrics import roc_curve, auc, roc_auc_score\nfrom sklearn.metrics import multilabel_confusion_matrix\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay\nimport seaborn as sns\n\n\n\ndef calculating_class_weights(y_true):  #  input : true labels  \n                                        # output : weights of each class\n    number_dim = np.shape(y_true)[1]\n    weights = np.empty([number_dim, 2])\n    for i in range(number_dim):\n        weights[i] = compute_class_weight('balanced', classes=np.unique(y_true[:, i]), y=y_true[:, i])\n    return weights\n\n\ndef _read(path, SHAPE):  # input : path of specific image and the shape that we want convert image to.\n                         # output : readed image\/255\n    img = cv2.imread('..\/input\/rsna-cq500-abnormal-data\/'+path)\n    img = cv2.resize(img, dsize=(256, 256))\n    return img\/255.0\n\n\n# Image Augmentation\nsometimes = lambda aug: iaa.Sometimes(0.25, aug) \n\naugmentation = iaa.Sequential([ iaa.Fliplr(0.25),          \n                                iaa.Flipud(0.10),\n                                sometimes(iaa.Crop(px=(0, 25), keep_size = True, sample_independently = False))   \n                            ], random_order = True)       \n        \n    \n# Generators\nclass TrainDataGenerator(keras.utils.Sequence):\n    def __init__(self, dataset, class_names, batch_size = 16, img_size = (256, 256, 3), augment = False, shuffle = True, *args, **kwargs): # initialize datagenerator\n        self.dataset = dataset\n        self.ids = self.dataset['imgfile'].values\n        self.labels = self.dataset[class_names].values\n        self.batch_size = batch_size\n        self.img_size = img_size\n        self.augment = augment\n        self.shuffle = shuffle\n        self.on_epoch_end()\n\n    def __len__(self):      # size of datagenerator (number of batchs)\n        return int(ceil(len(self.ids) \/ self.batch_size))\n\n    def __getitem__(self, index):   # input : index of a batch\n                                    # output : specific batch with input index\n        indices = self.indices[index*self.batch_size:(index+1)*self.batch_size]\n        X, Y = self.__data_generation(indices)\n        return X, Y\n\n    def augmentor(self, image):  # input : image\n                                 # output : augmented image\n        augment_img = augmentation        \n        image_aug = augment_img.augment_image(image) \n        return image_aug\n\n    def on_epoch_end(self):    \n        self.indices = np.arange(len(self.ids))\n        if self.shuffle:\n            np.random.shuffle(self.indices)\n\n    def __data_generation(self, indices): # creating augmented images and their labels.\n                                          # input : \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n                                          # output : augmented images and their labels.\n        X = np.empty((self.batch_size, *self.img_size))\n        Y = np.empty((self.batch_size, len(class_names)), dtype=np.float32)\n        \n        for i, index in enumerate(indices):\n            ID = self.ids[index]\n            image = _read(ID, self.img_size)\n            if self.augment:\n                X[i,] = self.augmentor(image)\n            else:\n                X[i,] = image\n            Y[i,] = self.labels[index]        \n        return X, Y\n\ndef ModelCheckpointFull(model_name): # save weights of the model that has the best result.\n    return ModelCheckpoint(model_name, \n                            monitor = 'val_loss', \n                            verbose = 1, \n                            save_best_only = True, \n                            save_weights_only = True, \n                            mode = 'min', \n                            period = 1)\n\n\n\n# Create Model\ndef create_model(num_classes): # input : num of classes\n                               # output : pretrained densenet121 to classify num_classes classes.\n    K.clear_session()\n    input_shape = (256, 256, 3)\n    img_input = Input(shape=input_shape)\n    base_model = DenseNet121(\n        include_top=False,\n        input_tensor=img_input,\n        input_shape=input_shape,\n        weights='imagenet',\n        pooling=\"avg\"\n    )\n    x = base_model.output\n    x = Dropout(0.15)(x)\n    predictions = Dense(num_classes, activation='sigmoid', name=\"new_predictions\")(x)\n    model = Model(inputs=img_input, outputs=predictions)\n\n    return model\n\n\n\ndef metrics_define(num_classes): \n    metrics_all = ['accuracy',\n    AUC(curve='PR',multi_label=True,name='auc_pr'),\n    AUC(multi_label=True, name='auc_roc'),\n    Recall(),\n    Precision(),\n    BinaryCrossentropy(name='bi_crent')\n    ]\n\n    return metrics_all\n\n\n\n\ndef get_weighted_loss(weights):    # input : weights of classes\n                                   # output : loss (weighted loss)\n    def weighted_loss(y_true, y_pred):\n        return K.mean((weights[:,0]**(1-y_true))*(weights[:,1]**(y_true))*K.binary_crossentropy(y_true, y_pred), axis=-1)\n    return weighted_loss\n\n\n\n\ndef print_metrics_table(y_true, y_hat, y_pred, class_names): # input : true labels, predicted labels, array of class names, y hat \n                                                             # output : a table of results (roc_auc_score, precision_score, f1_score, recall_xcore, accuracy_score)\n    myTable = PrettyTable([\"Class Name\", \"ROC_AUC\", \"Precsion\", \"Recall\", \"F1_Score\", \"Accuracy\"])\n\n    for i in range(len(class_names)) :\n        \n        myTable.add_row([class_names[i], \"%.4f\" % roc_auc_score(y_true[:, i], y_hat[:, i]),\n                        \"%.4f\" % precision_score(y_true[:, i], y_pred[:, i]), \"%.4f\" % recall_score(y_true[:, i], y_pred[:, i]),\n                        \"%.4f\" % f1_score(y_true[:, i], y_pred[:, i]), \"%.4f\" % accuracy_score(y_true[:, i], y_pred[:, i])\n                        ])\n\n    myTable.add_row(['Average', \"%.4f\" % roc_auc_score(y_true, y_hat),\n                    \"%.4f\" % precision_score(y_true, y_pred, average='macro'), \"%.4f\" % recall_score(y_true, y_pred, average='macro'),\n                    \"%.4f\" % f1_score(y_true, y_pred, average='macro'), \"%.4f\" % accuracy_score(y_true, y_pred)\n                    ])\n    print(myTable)\n\n    \n    \n    \ndef print_precision_recall_curves(y_true, y_hat, y_pred, class_names):  # input : true labels, predicted labels, array of class names, y hat \n                                                                        # print precision and recall curves\n        # For each class\n    precision = dict()\n    recall = dict()\n    average_precision = dict()\n    for i in range(len(class_names)):\n        precision[i], recall[i], _ = precision_recall_curve(y_true[:, i],\n                                                            y_hat[:, i])\n        average_precision[i] = average_precision_score(y_true[:, i], y_hat[:, i])\n\n    # A \"micro-average\": quantifying score on all classes jointly\n    precision[\"micro\"], recall[\"micro\"], _ = precision_recall_curve(y_true.ravel(),\n        y_hat.ravel())\n    average_precision[\"micro\"] = average_precision_score(y_true, y_hat,\n                                                        average=\"micro\")\n    print('Average precision score, micro-averaged over all classes: {0:0.2f}'\n        .format(average_precision[\"micro\"]))\n    plt.figure()\n    plt.step(recall['micro'], precision['micro'], where='post')\n    plt.plot([0, 1], [0, 1], 'k--')\n    plt.xlabel('Recall')\n    plt.ylabel('Precision')\n    plt.ylim([0.0, 1.05])\n    plt.xlim([0.0, 1.0])\n    plt.title(\n        'Average precision score, micro-averaged over all classes: AP={0:0.2f}'\n        .format(average_precision[\"micro\"]))\n    plt.show()\n    for i in range(len(class_names)):\n        plt.figure()\n        plt.plot(recall[i], precision[i], label='Precision-recall for class {0} (area = {1:0.2f})'.format(i, average_precision[i]))\n        plt.plot([0, 1], [0, 1], 'k--')\n        plt.xlim([0.0, 1.0])\n        plt.ylim([0.0, 1.05])\n        plt.xlabel('Recall')\n        plt.ylabel('Precision')\n        plt.title('Precision-Recall Curve for Class {}'.format(class_names[i]))\n        plt.legend(loc=\"lower right\")\n        plt.show()\n\n        \n        \n        \ndef print_auc_curves(y_true, y_hat, y_pred, class_names):  # input : true labels, predicted labels, array of class names, y hat \n                                                           # print auc curves\n    fpr = dict()\n    tpr = dict()\n    roc_auc = dict()\n    roc_auc_sc = dict()\n    for i in range(len(class_names)):\n        fpr[i], tpr[i], _ = roc_curve(y_true[:, i], y_hat[:, i])\n        roc_auc[i] = auc(fpr[i], tpr[i])\n        roc_auc_sc[i] = roc_auc_score(y_true[:, i], y_hat[:, i])\n\n    # Compute micro-average ROC curve and ROC area\n    fpr[\"micro\"], tpr[\"micro\"], _ = roc_curve(y_true.ravel(), y_hat.ravel())\n    roc_auc[\"micro\"] = auc(fpr[\"micro\"], tpr[\"micro\"])\n    for i in range(len(class_names)):\n        plt.figure()\n        plt.plot(fpr[i], tpr[i], label='ROC curve (area = %0.2f)' % roc_auc[i])\n        plt.plot([0, 1], [0, 1], 'k--')\n        plt.xlim([0.0, 1.0])\n        plt.ylim([0.0, 1.05])\n        plt.xlabel('False Positive Rate')\n        plt.ylabel('True Positive Rate')\n        plt.title('Receiver operating characteristic for class {}'.format(class_names[i]))\n        plt.legend(loc=\"lower right\")\n        plt.show()\n\n        \n        \n        \ndef print_confusion_matrix(y_true, y_hat, y_pred, class_names): # input : true labels, predicted labels, array of class names, y hat. \n                                                                # print confusion matrixes.\n    print(multilabel_confusion_matrix(y_true, y_pred))\n\n    \n    \n    \ndef print_on_vs_all_cmatrix(y_true, y_hat, y_pred, class_names):  # input : true labels, predicted labels, array of class names, y hat\n                                                                  # print confusion matrix plots.\n    confusion = multilabel_confusion_matrix(y_true, y_pred)\n\n    # Plot confusion matrix \n    fig = plt.figure(figsize = (14, 8))\n    for i, (label, matrix) in enumerate(zip(class_names[0:6], confusion[0:6])):\n        plt.subplot(f'23{i+1}')\n        labels = [f'not_{label}', label]\n        cm = matrix.astype('float') \/ matrix.sum(axis=1)[:, np.newaxis]\n        sns.heatmap(cm, annot = True, square = True, cbar = False, cmap = 'Blues', \n                    xticklabels = labels, yticklabels = labels, linecolor = 'black', linewidth = 1)\n        plt.title(labels[0])\n\n    plt.tight_layout()\n    plt.show()","c834fbef":"train_df = pd.read_csv('..\/input\/kfold-splits-rsna-cq500\/Train_f4.csv')  # Train_f4.csv as train dataframe.\nval_df = pd.read_csv('..\/input\/kfold-splits-rsna-cq500\/Validation_f4.csv') # Validation_f4.csv as validation dataframe.\n\n\n# just CQ500 images :\ntrain_df = pd.DataFrame( train_df.loc[i] for i in range(0, len(train_df)) if 'CQ500' in train_df.loc[i]['imgfile']  ) \nval_df = pd.DataFrame( val_df.loc[i] for i in range(0, len(val_df)) if 'CQ500' in val_df.loc[i]['imgfile']  ) \n\n\nHEIGHT = 256\nWIDTH = 256\nCHANNELS = 3\nTRAIN_BATCH_SIZE = 32\nVALID_BATCH_SIZE = 64\nSHAPE = (HEIGHT, WIDTH, CHANNELS)\n\nclass_names = ['epidural', 'intraparenchymal', 'intraventricular', 'subarachnoid', 'subdural']\n\nweights = calculating_class_weights((train_df[class_names].values).astype(np.float32))\nprint(weights)\n\ndata_generator_train = TrainDataGenerator(train_df,\n                                          class_names,\n                                          TRAIN_BATCH_SIZE,\n                                          SHAPE,\n                                          augment = True,\n                                          shuffle = True)\ndata_generator_val = TrainDataGenerator(val_df,\n                                        class_names, \n                                        VALID_BATCH_SIZE, \n                                        SHAPE,\n                                        augment = False,\n                                        shuffle = True\n                                        )\n\nTRAIN_STEPS = int(len(data_generator_train)\/10)\nprint(TRAIN_STEPS)\nVal_STEPS = int(len(data_generator_val)\/10)\nprint(Val_STEPS)\nLR = 5e-5","452a7df3":"train_df","a570ea73":"val_df","cc532918":"Metrics = metrics_define(len(class_names))\n\nmodel = create_model(len(class_names)) # create pretrained on imagenet denseNet121\n# model.load_weights('..\/input\/rsna-cq500-abnormal-weight\/model.h5')\nmodel.compile(optimizer = Adam(learning_rate = LR),\n              loss = get_weighted_loss(weights),\n              metrics = Metrics)","a72bed21":"history = model.fit(data_generator_train,\n                    validation_data = data_generator_val,\n                    validation_steps = Val_STEPS,\n                    steps_per_epoch = TRAIN_STEPS,\n                    epochs = 20,\n                    callbacks = [ModelCheckpointFull('model_densenet_fold4.h5')],\n                    verbose = 1, workers=4\n                    )","527c73c8":"plt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title('model loss')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.legend(['train', 'val'], loc='upper left')\nplt.show()","ffce3909":"plt.plot(history.history['auc_pr'])\nplt.plot(history.history['val_auc_pr'])\nplt.title('model auc_precision')\nplt.ylabel('auc_pr')\nplt.xlabel('epoch')\nplt.legend(['train', 'val'], loc='upper left')\nplt.show()","c4772ad9":"model.load_weights('model_densenet_fold4.h5')","18917ead":"val_df = pd.read_csv('..\/input\/kfold-splits-rsna-cq500\/Validation_f4.csv')\nval_df = pd.DataFrame( val_df.loc[i] for i in range(0, len(val_df)) if 'CQ500' in val_df.loc[i]['imgfile']  ) \n\nprint(len(val_df))\n\nHEIGHT = 256\nWIDTH = 256\nCHANNELS = 3\nVALID_BATCH_SIZE = 64\nSHAPE = (HEIGHT, WIDTH, CHANNELS)\n\nclass_names = ['epidural', 'intraparenchymal', 'intraventricular', 'subarachnoid', 'subdural']\ndata_generator_test = TrainDataGenerator(val_df,\n                                        class_names, \n                                        VALID_BATCH_SIZE, \n                                        SHAPE,\n                                        augment = False,\n                                        shuffle = False\n                                        )\n\ny_true = val_df[class_names].values\ny_hat = model.predict(data_generator_test, verbose=1)\n\ny_hat = y_hat[0:len(y_true)]\ny_pred = np.round(y_hat)","eca2be8c":"val_df","45926c9e":"print_metrics_table(y_true, y_hat, y_pred, class_names)","87ddb8d5":"print_precision_recall_curves(y_true, y_hat, y_pred, class_names)","050cd8d0":"print_auc_curves(y_true, y_hat, y_pred, class_names)","99116401":"print_confusion_matrix(y_true, y_hat, y_pred, class_names)","777516cb":"print_on_vs_all_cmatrix(y_true, y_hat, y_pred, class_names)","a3f6882c":"val_df = pd.read_csv('..\/input\/kfold-splits-rsna-cq500\/CQ500_Validation_f0.csv')  #  CQ500_Validation_f0.csv as validation dataframe\nprint(len(val_df))\n\nHEIGHT = 256\nWIDTH = 256\nCHANNELS = 3\nVALID_BATCH_SIZE = 64\nSHAPE = (HEIGHT, WIDTH, CHANNELS)\n\nclass_names = ['epidural', 'intraparenchymal', 'intraventricular', 'subarachnoid', 'subdural']\ndata_generator_test = TrainDataGenerator(val_df,\n                                        class_names, \n                                        VALID_BATCH_SIZE, \n                                        SHAPE,\n                                        augment = False,\n                                        shuffle = False\n                                        )\n\n\ny_true = val_df[class_names].values\ny_hat = model.predict(data_generator_test, verbose=1)\n\ny_hat = y_hat[0:len(y_true)]\ny_pred = np.round(y_hat)","ded72bc9":"print_metrics_table(y_true, y_hat, y_pred, class_names)","02c71727":"print_precision_recall_curves(y_true, y_hat, y_pred, class_names)","e91efa35":"print_auc_curves(y_true, y_hat, y_pred, class_names)","3fd4eb70":"print_confusion_matrix(y_true, y_hat, y_pred, class_names)","79d68910":"print_on_vs_all_cmatrix(y_true, y_hat, y_pred, class_names)","6d6a2691":"model.summary()","cd1154cb":"model","d027f4fc":"Train the model","7ee1b0e4":"test model on another dataframe","ff100be5":"results","44e1c634":"make train and validation dataframe","113e50d1":"validate the model"}}