{"cell_type":{"85b61831":"code","c77aa29f":"code","1f938c13":"code","a8e947b1":"code","6900cab6":"code","232c6f42":"code","d26d2eea":"code","cc2734d1":"code","72cc6d7a":"code","643da35e":"markdown","8913815e":"markdown","9e62b0ac":"markdown","0543154c":"markdown","49165f82":"markdown","99d3cd39":"markdown","de12f4f0":"markdown","89c85bad":"markdown","a963d492":"markdown","0cede947":"markdown","728c5dbd":"markdown","6d7ab41f":"markdown","295372a3":"markdown","d402002e":"markdown","c3cac870":"markdown","7f6fadee":"markdown","bbb9cf54":"markdown","bf4a6abf":"markdown","565ad7e5":"markdown","7738738a":"markdown","95e515bd":"markdown","24e7be10":"markdown","b22d7869":"markdown","6fc09a98":"markdown","fb03c452":"markdown","69d7ab55":"markdown","4ab9ccee":"markdown","b4b869ac":"markdown","ccb54930":"markdown","1eab29aa":"markdown","a3324f2a":"markdown","e75125d8":"markdown"},"source":{"85b61831":"## Install the Latest Version of Trax\n!pip install --upgrade trax","c77aa29f":"import trax","1f938c13":"data_pipeline = trax.data.Serial(\n    trax.data.TFDS('imdb_reviews', keys=('text', 'label'), train=True),\n    trax.data.Tokenize(vocab_dir='gs:\/\/trax-ml\/vocabs\/', vocab_file='en_8k.subword', keys=[0]),\n    trax.data.Log(only_shapes=False)\n  )\nexample = data_pipeline()\nprint(next(example))","a8e947b1":"data_pipeline = trax.data.Serial(\n    trax.data.TFDS('imdb_reviews', keys=('text', 'label'), train=True),\n    trax.data.Tokenize(vocab_dir='gs:\/\/trax-ml\/vocabs\/', vocab_file='en_8k.subword', keys=[0]),\n    trax.data.Log(only_shapes=True)\n  )\nexample = data_pipeline()\nprint(next(example))","6900cab6":"sentence = ['Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?',\n            'But I must explain to you how all this mistaken idea of denouncing pleasure and praising pain was born and I will give you a complete account of the system, and expound the actual teachings of the great explorer of the truth, the master-builder of human happiness. No one rejects, dislikes, or avoids pleasure itself, because it is pleasure, but because those who do not know how to pursue pleasure rationally encounter consequences that are extremely painful. Nor again is there anyone who loves or pursues or desires to obtain pain of itself, because it is pain, but because occasionally circumstances occur in which toil and pain can procure him some great pleasure. To take a trivial example, which of us ever undertakes laborious physical exercise, except to obtain some advantage from it? But who has any right to find fault with a man who chooses to enjoy a pleasure that has no annoying consequences, or one who avoids a pain that produces no resultant pleasure?',\n            'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum',\n            'At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium voluptatum deleniti atque corrupti quos dolores et quas molestias excepturi sint occaecati cupiditate non provident, similique sunt in culpa qui officia deserunt mollitia animi, id est laborum et dolorum fuga. Et harum quidem rerum facilis est et expedita distinctio. Nam libero tempore, cum soluta nobis est eligendi optio cumque nihil impedit quo minus id quod maxime placeat facere possimus, omnis voluptas assumenda est, omnis dolor repellendus. Temporibus autem quibusdam et aut officiis debitis aut rerum necessitatibus saepe eveniet ut et voluptates repudiandae sint et molestiae non recusandae. Itaque earum rerum hic tenetur a sapiente delectus, ut aut reiciendis voluptatibus maiores alias consequatur aut perferendis doloribus asperiores repellat.']\n\ndef sample_generator(x):\n  for i in x:\n    yield i\n\nexample_shuffle = list(trax.data.inputs.shuffle(sample_generator(sentence), queue_size = 2))\nexample_shuffle","232c6f42":"import numpy as np\n\ntensors = np.array([(1.,2.),\n           ((3.,4.),(5.,6.))])\npadded_tensors = trax.data.inputs.pad_to_max_dims(tensors=tensors, boundary=3)\npadded_tensors","d26d2eea":"data_pipeline = trax.data.Serial(\n    trax.data.TFDS('imdb_reviews', keys=('text', 'label'), train=True),\n    trax.data.Tokenize(vocab_dir='gs:\/\/trax-ml\/vocabs\/', vocab_file='en_8k.subword', keys=[0]),\n    trax.data.BucketByLength(boundaries=[32, 128, 512, 2048],\n                             batch_sizes=[512, 128,  32,    8, 1],\n                             length_keys=[0]),\n    trax.data.Log(only_shapes=True)\n  )\nexample = data_pipeline()\nprint(next(example))","cc2734d1":"Filtered = trax.data.Serial(\n    trax.data.TFDS('imdb_reviews', keys=('text', 'label'), train=True),\n    trax.data.Tokenize(vocab_dir='gs:\/\/trax-ml\/vocabs\/', vocab_file='en_8k.subword', keys=[0]),\n    trax.data.BucketByLength(boundaries=[32, 128, 512, 2048],\n                             batch_sizes=[512, 128,  32,    8, 1],\n                             length_keys=[0]),\n    trax.data.FilterByLength(max_length=2048, length_keys=[0]),\n    trax.data.Log(only_shapes=True)\n  )\nfiltered_example = Filtered()\nprint(next(filtered_example))","72cc6d7a":"data_pipeline = trax.data.Serial(\n    trax.data.TFDS('imdb_reviews', keys=('text', 'label'), train=True),\n    trax.data.Tokenize(vocab_dir='gs:\/\/trax-ml\/vocabs\/', vocab_file='en_8k.subword', keys=[0]),\n    trax.data.Shuffle(),\n    trax.data.FilterByLength(max_length=2048, length_keys=[0]),\n    trax.data.BucketByLength(boundaries=[  32, 128, 512, 2048],\n                             batch_sizes=[512, 128,  32,    8, 1],\n                             length_keys=[0]),\n    trax.data.AddLossWeights(),\n    trax.data.Log(only_shapes=True)\n  )\n\nexample = data_pipeline()\nprint(next(example))","643da35e":"# \ud83d\udce6 Creating Buckets","8913815e":"# \ud83d\udecd Filter by Length","9e62b0ac":"## batch","0543154c":"# \ud83d\udea7 Pad to Maximum Dimensions","49165f82":"Trax offers two generator functions to add shuffle functionality in our input pipelines. \n\n1. The `shuffle` function shuffles a given stream\n2. The `Shuffle` function returns a shuffle function instead","99d3cd39":"```\n\ntrain_generator = trax.data.inputs.add_loss_weights(\n    data_generator(batch_size, x_train, y_train,vocab['<PAD>'], True),\n    id_to_mask=vocab['<PAD>'])\n\n\n```\n\nFor example, in this case I used the `add_loss_weights` function to add padding while implementing Named Entity Recogntion using the Reformer Architecture. You can read more about the project [here](https:\/\/www.kaggle.com\/sauravmaheshkar\/trax-ner-using-reformer).","de12f4f0":"```\ndef add_loss_weights(generator, id_to_mask=None):\n  for example in generator:\n    if len(example) > 3 or len(example) < 2:\n      assert id_to_mask is None, 'Cannot automatically mask this stream.'\n      yield example\n    else:\n      if len(example) == 2:\n        weights = np.ones_like(example[1]).astype(np.float32)\n      else:\n        weights = example[2].astype(np.float32)\n      mask = 1.0 - np.equal(example[1], id_to_mask).astype(np.float32)\n      weights *= mask\n      yield (example[0], example[1], weights)\n```\n---\n\nThis function essentially adds a loss mask (tensor of ones of the same shape) to the input stream. \n\n**Masking** is essentially a way to tell sequence-processing layers that certain timesteps in an input are missing, and thus should be skipped when processing the data.\n\nThus, it adds 'weights' to the system. \n\n---\n\n### Parameters\n\n1. **generator:** The input data generator\n2. **id_to_mask:** The value with which to mask. Can be used as `<PAD>` in NLP.","89c85bad":"# \ud83c\udccf Shuffling our datasets","a963d492":"## AddLossWeights","0cede947":"```\ndef bucket_by_length(generator, length_fn, boundaries, batch_sizes,strict_pad_on_len=False):\n  buckets = [[] for _ in range(len(batch_sizes))]\n  boundaries = boundaries + [math.inf] \n  for example in generator:\n    length = length_fn(example)\n    bucket_idx = min([i for i, b in enumerate(boundaries) if length <= b])\n    buckets[bucket_idx].append(example)\n    if len(buckets[bucket_idx]) == batch_sizes[bucket_idx]:\n      batched = zip(*buckets[bucket_idx])\n      boundary = boundaries[bucket_idx]\n      boundary = None if boundary == math.inf else boundary\n      padded_batch = tuple(\n          pad_to_max_dims(x, boundary, strict_pad_on_len) for x in batched)\n      yield padded_batch\n      buckets[bucket_idx] = []\n```\n---\n\nThis function can be summarised as:\n\n* Create buckets as per the lengths given in the `batch_sizes` array\n\n* Assign sentences into buckets if their length matches the bucket size\n\n* If padding is required, we use the `pad_to_max_dims` function\n\n---\n\n### Parameters\n\n1. **generator:** The input generator function\n2. **length_fn:** A custom length function for determing the length of functions, not necessarily `len()`\n3. **boundaries:** A python list containing corresponding bucket boundaries\n4. **batch_sizes:** A python list containing batch sizes\n5. **strict_pad_on_len:**  A python boolean variable (`True` or `False`). If set to true then the function pads on the length dimension, where dim[0] is strictly a multiple of boundary.\n ","728c5dbd":"```\ndef shuffle(samples, queue_size):\n  if queue_size < 1:\n    raise ValueError(f'Arg queue_size ({queue_size}) is less than 1.')\n  if queue_size == 1:\n    logging.warning('Queue size of 1 results in no shuffling.')\n  queue = []\n  try:\n      queue.append(next(samples))\n      i = np.random.randint(queue_size)\n      yield queue[i]\n      queue[i] = sample\n  except StopIteration:\n    logging.warning(\n        'Not enough samples (%d) to fill initial queue (size %d).',\n        len(queue), queue_size)\n  np.random.shuffle(queue)\n  for sample in queue:\n    yield sample\n```\n\n\nThe `shuffle` function takes two inputs, the data stream and the queue size (minimum number of samples within which the shuffling takes place). Apart from the usual warnings, for negative and unity queue sizes, this generator function shuffles the given stream using [`np.random.randint()`](https:\/\/docs.python.org\/3\/library\/random.html#random.randint) by randomly picks out integers using the `queue_size` as a range and then shuffle this new stream again using the [`np.random.shuffle()`](https:\/\/docs.python.org\/3\/library\/random.html#random.shuffle)","6d7ab41f":"```\ndef Log(n_steps_per_example=1, only_shapes=True):\n  def log(stream):\n    counter = 0\n    for example in stream:\n      item_to_log = example\n      if only_shapes:\n        item_to_log = fastmath.nested_map(shapes.signature, example)\n      if counter % n_steps_per_example == 0:\n        logging.info(str(item_to_log))\n        print(item_to_log)\n      counter += 1\n      yield example\n  return log\n```\nEvery Deep Learning Framework needs to have a logging component for efficient debugging. \n\n`trax.data.Log` generator uses the `absl` package for logging. It uses a [`fastmath.nested_map`](https:\/\/github.com\/google\/trax\/blob\/c38a5b1e4c5cfe13d156b3fc0bfdb83554c8f799\/trax\/fastmath\/numpy.py#L80) function that maps a certain function recursively inside a object. In the case depicted below, the function maps the `shapes.signature` recursively inside the input stream, thus giving us the shapes of the various objects in our stream.\n\n---\n\nThe following two cells show the difference between when we set the `only_shapes` variable to `False`","295372a3":"## BucketByLength","d402002e":"## Batch","c3cac870":"# \u2b07\ufe0f Serial Fn","7f6fadee":"For training Recurrent Neural Networks, with large vocabulary a method called Bucketing is usually applied. \n\nThe usual technique of using padding ensures that all occurences within a mini-batch are of the same length. But this reduces the inter-batch variability and intuitively puts similar sentences into the same batch therefore, reducing the overall robustness of the system. \n\nThus, we use Bucketing where multiple buckets are created depending on the length of the sentences and these occurences are assigned to buckets on the basis of which bucket corresponds to it's length. We need to ensure that the bucket sizes are large for adding some variablity to the system.","bbb9cf54":"# Introduction","bf4a6abf":"In Trax, we use combinators to build input pipelines, much like building deep learning models. The `Serial` combinator applies layers serially using function composition and uses stack semantics to manage data. \n\nTrax has the following definition for a `Serial` combinator.\n\n```\ndef Serial(*fns):\n  def composed_fns(generator=None):\n    for f in fastmath.tree_flatten(fns):\n      generator = f(generator)\n    return generator\n  return composed_fns\n  ```\n\nThe `Serial` function has the following structure:\n\n* It takes as **input** arbitrary number of functions\n* Convert the structure into lists\n* Iterate through the list and apply the functions Serially\n\n---\n\nThe [`fastmath.tree_flatten()`](https:\/\/github.com\/google\/trax\/blob\/c38a5b1e4c5cfe13d156b3fc0bfdb83554c8f799\/trax\/fastmath\/numpy.py#L195) function, takes a tree as a input and returns a flattened list. This way we can use various generator functions like Tokenize and Shuffle, and apply them serially by '*iterating*' through the list. \n\nInitially, we've defined `generator` to `None`. Thus, in the first iteration we have no input and thus the first step executes the first function in our tree structure. In the next iteration, the `generator` variable is updated to be the output of the next function in the list.\n","565ad7e5":"```\ndef BucketByLength(boundaries, batch_sizes,length_keys=None, length_axis=0, strict_pad_on_len=False):\n  length_keys = length_keys or [0, 1]\n  length_fn = lambda x: _length_fn(x, length_axis, length_keys)\n  return lambda g: bucket_by_length(g, length_fn, boundaries, batch_sizes, strict_pad_on_len)\n```\n---\n\nThis function, is usually used inside input pipelines(*combinators*) and uses the afforementioned `bucket_by_length`. It applies a predefined `length_fn` which chooses the maximum shape on length_axis over length_keys.\n\nIt's use is illustrated below","7738738a":"## bucket_by_length\n\n","95e515bd":"# \ud83d\uddc4 Adding Loss Weights","24e7be10":"## add_loss_weights","b22d7869":"This function, creates batches for the input generator function.\n\n```\ndef batch(generator, batch_size):\n  if batch_size <= 0:\n    raise ValueError(f'Batch size must be positive, but is {batch_size}.')\n  buf = []\n  for example in generator:\n    buf.append(example)  \n    if len(buf) == batch_size:\n      batched_example = tuple(np.stack(x) for x in zip(*buf))\n      yield batched_example\n      buf = []\n```\n\nIt keeps adding objects from the generator into a list until the size becomes equal to the `batch_size` and then creates batches using the `np.stack()` function.\n\nIt also raises an error for non-positive batch_sizes.\n","6fc09a98":"## shuffle","fb03c452":"## Shuffle","69d7ab55":"```\ndef Shuffle(queue_size=1024): \n  return lambda g: shuffle(g, queue_size)\n```\n\nThis function returns the aforementioned `shuffle` function and is mostly used in input pipelines.\n","4ab9ccee":"# \ud83d\udd8a Log Function","b4b869ac":"This function performs the afforementioned `add_loss_weights` to the data stream. \n\n```\ndef AddLossWeights(id_to_mask=None):\n  return lambda g: add_loss_weights(g,id_to_mask=id_to_mask)\n```\n","ccb54930":"This function is used to pad a tuple of tensors to a joint dimension and return their batch.\n\nFor example, in this case a pair of tensors (1,2) and ( (3,4) , (5,6) ) is changed to (1,2,0) and ( (3,4) , (5,6) , 0)","1eab29aa":"# \ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66 Batch Generators","a3324f2a":"```\n    def Batch(batch_size):  \n      return lambda g: batch(g, batch_size)\n```\n\nThis Function returns the aforementioned `batch` function with given batch size.","e75125d8":"```\ndef FilterByLength(max_length,length_keys=None, length_axis=0):\n  length_keys = length_keys or [0, 1]\n  length_fn = lambda x: _length_fn(x, length_axis, length_keys)\n  def filtered(gen):\n    for example in gen:\n      if length_fn(example) <= max_length:\n        yield example\n  return filtered\n```\n---\n\nThis function used the same predefined `length_fn` to only include those instances which are less than the given `max_length` parameter.\n"}}