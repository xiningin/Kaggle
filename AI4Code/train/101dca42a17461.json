{"cell_type":{"2572bd7d":"code","cd661519":"code","0dea70ff":"code","323c5574":"code","6e7465a8":"code","a8bdfa00":"code","3867bc51":"code","2c6f60f0":"code","36382238":"code","66308e11":"code","b34575d2":"code","e69301e9":"markdown","1f8b3fd6":"markdown","65870a5b":"markdown","7f500163":"markdown","5f51683c":"markdown","bf1d0cb8":"markdown"},"source":{"2572bd7d":"import numpy as np\nimport random\nimport math","cd661519":"C = \"abcdegsacbdcefabafgaaa\"\nfeature_size = 10\nZ = [random.randint(0,feature_size-1) for z in range(len(C))]\nn = len(C)\nZ","0dea70ff":"char_to_ix = {}\nfor char in C:\n    if char not in char_to_ix:\n        char_to_ix[char] = len(char_to_ix)\nlen(char_to_ix)\nprint(char_to_ix)","323c5574":"#P(C) and P(C.i|C.i-1)\nPC = np.zeros( len(char_to_ix))\ncond_PC = np.zeros(( len(char_to_ix), len(char_to_ix)) )\n\nfor e,c in enumerate(C):\n    ix = char_to_ix[c]\n    PC[ix] += 1 \n    if( e > 0 ):\n        cond_PC[char_to_ix[ C[e-1] ], char_to_ix[ C[e] ] ] += 1\n        \nfor row in range( len(char_to_ix) ):\n    cond_PC[row] = cond_PC[row]\/np.sum(cond_PC[row])\n\nprint(cond_PC)","6e7465a8":"#p(z|c)\npz = np.zeros( ( feature_size, len(char_to_ix) ) )\nfor e,c in enumerate(C):\n    pz[ Z[e], char_to_ix[c] ] += 1\n\nfor row in range( feature_size ):\n    pz[row] = pz[row]\/( 0.0001 + np.sum(pz[row]) )\n\nprint(pz)","a8bdfa00":"n = 10\nZ_new = [ random.randint(0, feature_size-1) for z in range(n)]\nprint(Z_new)","3867bc51":"#Initialize structures\nlength = 0\nwords = [ [] for i in range( len(char_to_ix) ) ]\nlen_path = np.zeros( len(char_to_ix) )","2c6f60f0":"#First layer\nfor ix,c in enumerate(char_to_ix):\n    len_path[ix] = -math.log( PC[ix] + 0.001 ) - math.log( pz[ Z_new[0]][ix] + 0.001 )\n    words[ ix ].append(c)\n    print( words[ix], len_path[ ix] )\nprint(words)","36382238":"for i in range(1, n):\n    new_len_path = np.zeros( len(char_to_ix) )\n    for ch in char_to_ix:\n        min_len_path = 100000000\n        best = 0\n        for c in char_to_ix:\n            cand =  len_path[ char_to_ix[c] ] - math.log( cond_PC[char_to_ix[c]][char_to_ix[ch]] + 0.01) -math.log( pz[i][ char_to_ix[c] ] + 0.01 )\n            if cand < min_len_path:\n                min_len_path = cand\n                best = c\n        words[char_to_ix[ch]].append(best)\n        new_len_path[ char_to_ix[ch] ] = min_len_path\n    len_path = new_len_path.copy()","66308e11":"print( len_path)","b34575d2":"print(words)","e69301e9":"**QUERY**","1f8b3fd6":"**Instructions**","65870a5b":"**Computing the probabilities**","7f500163":"http:\/\/www.cim.mcgill.ca\/~latorres\/Viterbi\/va_alg.htm","5f51683c":"**Preparing data**","bf1d0cb8":"Having data\n1. Assume that characters are dependent only on corresponding features. On others they are independent.\n2. Compute probabilities that a chareacter c occurs. P(c) = n_c\/length_of_word\n3. Compute conditional probabilities P(c.i|c.i-1). Again, take frequency.\n4. Compute conditional probabilities p(z.i|c.i). Again, take frequency.\n\nAnswering\n1. Take Z = z1, z2, ..., zn inputs, which are features.\n2. Want to find a sequence C, such that P(C|Z) is maximum. P(C|Z) = p(Z|C)*P(C)\/P(Z), so enough to find C such that p(Z|C)*P(C) is maximum.\n3. Can logarithm the latter. From independence of c.i and z.j (i != j) have log p(z.1|c.1) + log p(z.2|c.2) + ... + p(z.n|c.n) + logP(c.0) + logP(c.1|c.0) + ... + logP(c.n|c.n-1) and want to find C that maximizes it.\nc.0 is an abstract 0 character. P(c.1|c.0) = P(c.1).\n4. Can find C, such that minimizes sum( -log p(z.i|c.i) - logP(c.i|c.i-1) )\n5. Create a graph with layers L0, L1, ..., Ln. For i>0, Li = {char.1, char.2, ..., char.M}, and edge connecting char.i with char.j from L.k to L.k+1 has weight ( -log p(z.j | char.j) - logP(char.j | char.j+1) ).\n6. For each layer and for each node in it, find the shortest path leading to it.\n"}}