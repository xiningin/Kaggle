{"cell_type":{"f05b1d94":"code","4568830f":"code","7410ab6f":"code","2bb20a46":"code","792bf8a3":"code","cd9954e2":"code","784fc1d6":"code","471f3bcf":"code","462afe77":"code","b82db47c":"markdown","c60997f7":"markdown","fe6a1a23":"markdown","cf514953":"markdown","8a076baf":"markdown","b478566a":"markdown","ef85177f":"markdown","aed19930":"markdown","4dbfc336":"markdown","c3da6844":"markdown"},"source":{"f05b1d94":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly.graph_objects as go\nimport plotly.offline as pyo\nimport statsmodels.api as sm\nimport ipywidgets as widgets\nimport pylab\nimport warnings\nimport os\nimport sys\n\nfrom scipy import stats\nfrom IPython.display import display\n\nwarnings.filterwarnings('ignore')\npyo.init_notebook_mode()","4568830f":"df = pd.read_csv('..\/input\/song-popularity-prediction\/train.csv', index_col='id')\n\nout1 = widgets.Output()\nout2 = widgets.Output()\nout3 = widgets.Output()\n\nwith out1:\n    print(f'Shape of the data : {df.shape}')\n    display(df.head(30))\n    \nwith out2:\n    display(df.info())\n    \nwith out3:\n    display(df.describe())\n\n\ntab_contents = [out1, out2, out3]\ntab = widgets.Tab()\ntab.children = tab_contents\ntab.set_title(0, 'The Data')\ntab.set_title(1, 'Data Information')\ntab.set_title(2, 'Data Description')\ntab\n","7410ab6f":"out3 = widgets.Output()\nout4 = widgets.Output()\n\nwith out3:\n    display(pd.DataFrame(df.isna().sum() \/ df.isna().count() * 100).rename(columns={0:'% missing'}).sort_values(by='% missing', ascending=False))\n    \nwith out4:\n    plt.figure(figsize=(12, 10))\n    sns.heatmap(df.isnull(), cbar=False)\n    plt.show()\n    \n    print(\"\"\" The white color bar represents the missing value in the data\"\"\")\n    \ntab_contents2 = [out3, out4]\ntab2 = widgets.Tab()\ntab2.children = tab_contents2\ntab2.set_title(0, 'Missing Information')\ntab2.set_title(1, 'Missing Location')\ntab2","2bb20a46":"out5 = widgets.Output()\nout6 = widgets.Output()\nout7 = widgets.Output()\n\nwith out5:\n    \n    fig1, ax1 = plt.subplots(2, 5, figsize=(10, 5), gridspec_kw={\n        'top' : 1.5,\n        'hspace' : .6,\n        'right' : 2.4\n    })\n    \n    # Visualizing all the continuous numerical features.\n    ax1[0, 0].set_title('song_duration_ms')\n    sns.kdeplot(data=df, x=\"song_duration_ms\", ax=ax1[0, 0], color='goldenrod', fill=True, alpha=.32)\n    \n    ax1[1, 0].set_title('acousticness')\n    sns.kdeplot(data=df, x=\"acousticness\", ax=ax1[1, 0], color=\"darkolivegreen\", fill=True, alpha=.32)\n    \n    ax1[0, 1].set_title('danceability')\n    sns.kdeplot(data=df, x=\"danceability\", ax=ax1[0, 1], color='indianred', fill=True, alpha=.32)\n    \n    ax1[1, 1].set_title('energy')\n    sns.kdeplot(data=df, x=\"energy\", ax=ax1[1, 1], color=\"cornflowerblue\", fill=True, alpha=.32)\n    \n    ax1[0, 2].set_title('instrumentalness')\n    sns.kdeplot(data=df, x=\"instrumentalness\", ax=ax1[0, 2], color=\"darkorchid\", fill=True, alpha=.32)\n    \n    ax1[1, 2].set_title('liveness')\n    sns.kdeplot(data=df, x=\"liveness\", ax=ax1[1, 2], color=\"indigo\", fill=True, alpha=.32)\n    \n    ax1[0, 3].set_title('loudness')\n    sns.kdeplot(data=df, x=\"loudness\", ax=ax1[0, 3], color=\"orangered\", fill=True, alpha=.32)\n    \n    ax1[1, 3].set_title('speechiness')\n    sns.kdeplot(data=df, x=\"speechiness\", ax=ax1[1, 3], color=\"sienna\", fill=True, alpha=.32)\n    \n    ax1[0, 4].set_title('tempo')\n    sns.kdeplot(data=df, x=\"tempo\", ax=ax1[0, 4], color=\"sandybrown\", fill=True, alpha=.32)\n    \n    ax1[1, 4].set_title('audio_valence')\n    sns.kdeplot(data=df, x=\"audio_valence\", ax=ax1[1, 4], color=\"slateblue\", fill=True, alpha=.32)\n    \n    plt.show()\n    \n    print(\"\"\" \n    \n    1) The `song_duration_ms` looks more like a normal distribution data. \\n\n    2) The `danceability` shows that most of the songs has the groove on it. \\n\n    3) The `instrumentalness`, `liveness`, and `speechiness` data distributions are heavily right-skewed. So a log-transformation will be good?\\n\n    4) The `acousticness` feature data distribution shows that most of the songs have very little acousticness.[It's more like a bimodal distribution]\\n\n    5) The `energy` feature data distribution shows that most of the songs are full of energy. [Here also data looks like a left-skewed bimodal distribution]\\n\n    6) The `audio_valence` and `tempo` shows data in a multimodal distribution.\n    \n    \n    \"\"\")\n    \nwith out6:\n    \n    fig2, ax2 = plt.subplots(1, 3, figsize=(10, 5), gridspec_kw={\n        'top': 1.5,\n        'right' : 2.4\n    })\n    \n    key_counts = pd.DataFrame(df.groupby(['key']).size() \/ df.shape[0] * 100).rename(columns={0:'Percentage'}).reset_index()\n    audio_counts = pd.DataFrame(df.groupby(['audio_mode']).size() \/ df.shape[0] * 100).rename(columns={0:'Percentage'}).reset_index()\n    time_counts = pd.DataFrame(df.groupby(['time_signature']).size() \/ df.shape[0] * 100).rename(columns={0:'Percentage'}).reset_index()\n    \n    sns.barplot(x='key', y=\"Percentage\", data=key_counts, ax=ax2[0])\n    sns.barplot(x='audio_mode', y=\"Percentage\", data=audio_counts, ax=ax2[1])\n    sns.barplot(x='time_signature', y=\"Percentage\", data=time_counts, ax=ax2[2])\n    \n    plt.show()\n    \n    \nwith out7:\n    fig3, ax3 = plt.subplots(figsize=(10, 5))\n    target_counts = pd.DataFrame(df.groupby(['song_popularity']).size() \/ df.shape[0] * 100).rename(columns={0:'Percentage'}).reset_index()\n    sns.barplot(x=\"song_popularity\", y=\"Percentage\", data=target_counts, ax=ax3)\n    plt.show()\n    print(\"\"\" \n    \n    It can be seen from the Target variable that there is some imbalance in the data labels. So we need be cautious while modeling the data.\n    \n    \"\"\")\n    \ntab_contents_3 = [out5, out6, out7]\ntab3 = widgets.Tab()\ntab3.children = tab_contents_3\ntab3.set_title(0, \"Continuous Numerical Features\")\ntab3.set_title(1, \"Categorical\/Ordinal Features\")\ntab3.set_title(2, \"Target\")\ntab3","792bf8a3":"def normality(data, feature, color=\"cornflowerblue\", figsize=(10, 5)):\n    \n    fig, ax = plt.subplots(3, 2, figsize=figsize)\n    plt.subplots_adjust(top=2.8, right=1.4)\n    \n    log_vals = np.log(data[feature].dropna()).dropna()\n    log_vals[log_vals == -np.inf] = 1\n    \n    ax[0, 0].set_title('Log Transformation (KDE-Plot)')\n    sns.kdeplot(data[feature].dropna(), color=color, fill=True, alpha=0.35, ax=ax[0, 0], log_scale=True)\n    ax[0, 1].set_title('Log Transformation (QQ-Plot)')\n    sm.qqplot(log_vals, ax=ax[0, 1], line='45', fit=True, dist=stats.norm)\n    \n    ax[1, 0].set_title('Reciprocal Transformation (KDE-Plot)')\n    sns.kdeplot(1\/data[feature].dropna(), color=color, fill=True, alpha=0.35, ax=ax[1, 0])\n    ax[1, 1].set_title('Reciprocal Transformation (QQ-Plot)')\n    sm.qqplot(1\/data[feature].dropna(), line='45', fit=True, dist=stats.norm, ax=ax[1, 1])\n    \n    \n    data['box_cox'], lmb = stats.boxcox(data[feature] + (np.abs(np.min(data[feature])) + 1e-11))\n    ax[2, 0].set_title('Box-Cox Transformation (KDE-Plot)')\n    sns.kdeplot(data['box_cox'].dropna(), color=color, fill=True, alpha=0.35, ax=ax[2, 0])\n    ax[2, 1].set_title('Box-Cox Transformation (QQ-Plot)')\n    sm.qqplot(data['box_cox'].dropna(), line='45', fit=True, dist=stats.norm, ax=ax[2, 1])\n    \n    fig.suptitle(feature.capitalize(), y=3.0, x=.75, fontstyle=\"oblique\", fontsize=24)\n    \n    \nout8 = widgets.Output()\nout9 = widgets.Output()\nout10 = widgets.Output()\nout11 = widgets.Output()\nout12 = widgets.Output()\nout13 = widgets.Output()\nout14 = widgets.Output()\nout15 = widgets.Output()\nout16 = widgets.Output()\n\nwith out8:\n    normality(df.copy(), 'danceability', color=\"indianred\")\n    plt.show()\n    \nwith out9:\n    normality(df.copy(), 'instrumentalness', color='darkorchid')\n    plt.show()\n    \nwith out10:\n    normality(df.copy(), 'loudness', color='orangered')\n    plt.show()\n    \nwith out11:\n    normality(df.copy(), 'tempo', color='sandybrown')\n    plt.show()\n    \nwith out12:\n    normality(df.copy(), 'acousticness', color='darkolivegreen')\n    plt.show()\n    \nwith out13:\n    normality(df.copy(), 'energy', color='cornflowerblue')\n    plt.show()\n    \nwith out14:\n    normality(df.copy(), 'liveness', color='indigo')\n    plt.show()\n    \nwith out15:\n    normality(df.copy(), 'speechiness', color='sienna')\n    plt.show()\n    \nwith out16:\n    normality(df.copy(), 'audio_valence', color='slateblue')\n    plt.show()\n    \ntab_contents_4 = [out8, out9, out10, out11, out12, out13, out14, out15, out16]\ntab4 = widgets.Tab()\ntab4.children = tab_contents_4\n\ntab4.set_title(0, 'Danceability')\ntab4.set_title(1, 'Instrumentalness')\ntab4.set_title(2, 'Loudness')\ntab4.set_title(3, 'Tempo')\ntab4.set_title(4, 'Acousticness')\ntab4.set_title(5, 'Energy')\ntab4.set_title(6, 'Liveness')\ntab4.set_title(7, 'Speechiness')\ntab4.set_title(8, 'Audio Valence')\n\ntab4","cd9954e2":"plt.figure(figsize=(12, 8))\nplt.title('Correlation between the Features')\nsns.heatmap(df.dropna().corr(), vmin=-1, vmax=1.0, cmap='coolwarm', mask=np.triu(df.dropna().corr()))\nplt.show()","784fc1d6":"df_copy = df.copy()\ndf.dropna(inplace=True)","471f3bcf":"fig, ax = plt.subplots(2, 5, figsize=(10, 5))\nplt.subplots_adjust(top=1.5, right=2.4, hspace=.6)\n\nax[0, 0].set_title('Song Duration (in ms)')\nsns.kdeplot(df['song_duration_ms'], fill=True, alpha=0.35, hue=df['song_popularity'], ax=ax[0, 0], palette='Paired')\n\nax[1, 0].set_title('Danceability')\nsns.kdeplot(df['danceability'], fill=True, alpha=0.35, hue=df['song_popularity'], ax=ax[1, 0], palette='Paired')\n\nax[0, 1].set_title('Instrumentalness')\nsns.kdeplot(df['instrumentalness'], fill=True, alpha=0.35, hue=df['song_popularity'], ax=ax[0, 1], palette='Paired')\n\nax[1, 1].set_title('Loudness')\nsns.kdeplot(df['loudness'], fill=True, alpha=0.35, hue=df['song_popularity'], ax=ax[1, 1], palette='Paired')\n\nax[0, 2].set_title('Liveness')\nsns.kdeplot(df['liveness'], fill=True, alpha=0.35, hue=df['song_popularity'], ax=ax[0, 2], palette='Paired')\n\nax[1, 2].set_title('Audio Valence')\nsns.kdeplot(df['audio_valence'], fill=True, alpha=0.35, hue=df['song_popularity'], ax=ax[1, 2], palette='Paired')\n\nax[0, 3].set_title('Speechiness')\nsns.kdeplot(df['speechiness'], fill=True, alpha=0.35, hue=df['song_popularity'], ax=ax[0, 3], palette='Paired')\n\nax[1, 3].set_title('Tempo')\nsns.kdeplot(df['tempo'], fill=True, alpha=0.35, hue=df['song_popularity'], ax=ax[1, 3], palette='Paired')\n\nax[0, 4].set_title('Energy')\nsns.kdeplot(df['energy'], fill=True, alpha=0.35, hue=df['song_popularity'], ax=ax[0, 4], palette='Paired')\n\nax[1, 4].set_title('Acousticness')\nsns.kdeplot(df['acousticness'], fill=True, alpha=0.35, hue=df['song_popularity'], ax=ax[1, 4], palette='Paired')\n\nplt.show()","462afe77":"fig, ax = plt.subplots(1, 3, figsize=(10, 5))\n\nplt.subplots_adjust(top=1.5, right=2.9, wspace=.3)\n\nax[0].set_title('Energy vs Acousticness', fontstyle='oblique', fontsize=24)\nsns.scatterplot(x='energy', y='acousticness', data=df, hue='song_popularity', ax=ax[0], alpha=.67)\n\nax[1].set_title('Energy vs Loudness', fontstyle='oblique', fontsize=24)\nsns.scatterplot(x='energy', y='loudness', data=df, hue='song_popularity', ax=ax[1], alpha=.67)\n\n\nax[2].set_title('Acousticness vs Loudness', fontstyle='oblique', fontsize=24)\nsns.scatterplot(x='acousticness', y='loudness', data=df, hue='song_popularity', ax=ax[2], alpha=.67)\n\nplt.show()","b82db47c":"<a id=\"data_transform\"\/><br\/>\n# Data Transformation\n\nHere we check the application of different data transformation on the **numerical continuous input features** to convert it into normal distribution. \n\nThe data transformation which we applied are as follow:\n1. [Log Transformation](https:\/\/onlinestatbook.com\/2\/transformations\/log.html)\n2. Reciprocal Transformation\n3. [Box-Cox Transformation](https:\/\/onlinestatbook.com\/2\/transformations\/box-cox.html)\n\nWe used the QQ-plot to validate whether the data distribution has been fruitful or not.\n\nTo get more idea please visit this [link](https:\/\/towardsdatascience.com\/types-of-transformations-for-better-normal-distribution-61c22668d3b9)","c60997f7":"<a id=\"corr_map\"\/><br\/>\n# Correlation Map","fe6a1a23":"<a id=\"feature_target\"\/><br\/>\n# Feature-Target Interactions","cf514953":"<a id=\"load_data\"\/><br\/>\n# Quick view of the data","8a076baf":"<a id=\"feature_feature_target\"\/><br\/>\n# Feature-Feature-Target Interactions","b478566a":"# !!! DISCLAIMER !!!\n\nThis notebook is the Pythonic version of the **HEADS or TAILS** live session [EDA notebook](https:\/\/www.kaggle.com\/headsortails\/song-popularity-eda-live-coding-fun). \nAll the steps mentioned in the above notebook has been covered in here, also some extra code has been added in here.\n\nSo if you find this notebook useful (as a Python version) please do give it an **upvote**.\n\nEnough with that, let's jump into the competetion code.","ef85177f":"<a id=\"load_package\"\/><br\/>\n# Load Packages ","aed19930":"# Introduction\n\nWelcome to one of the Kaggle community hosted competetion **Song Popularity Prediction** hosted by **MLSpace**. This competetion is focused to be more beginner specific that provides an introduction to Machine Learning (ML) in Data Science (DS). \n\nThe data consists of the standard Kaggle `train.csv` and `test.csv`, along with `sample.csv` to show how the structure of the submition file should be. \n\nThe **evaluation** metric for this competetion is [AUC-ROC Score](https:\/\/www.analyticsvidhya.com\/blog\/2020\/06\/auc-roc-curve-machine-learning\/).\n\nTable of Contents:\n1. [Load Packages](#load_package)\n2. [Quick view of the Data](#load_data)\n3. [Missing Value and it's context](#missing)\n4. [Feature Visualization](#feature_visual)\n5. [Data Transformation](#data_transform)\n6. [Correlation Map](#corr_map)\n7. [Feature Target Interaction](#feature_target)\n8. [Feature-Feature-Target](#feature_feature_target)\n\n","4dbfc336":"<a id=\"missing\"\/><br\/>\n# Missing Value","c3da6844":"<a id=\"feature_visual\"\/><br\/>\n# Feature Visualization"}}