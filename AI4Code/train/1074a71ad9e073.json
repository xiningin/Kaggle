{"cell_type":{"ddf29105":"code","afc5783c":"code","b0f1650c":"code","3b6c145d":"code","3864f2a1":"code","877e5b84":"code","46e56f42":"markdown","b41f88b1":"markdown","725c7aad":"markdown","708348be":"markdown","407f0574":"markdown","72f30f2c":"markdown","ae4abeae":"markdown","a5967bb7":"markdown","b637032e":"markdown"},"source":{"ddf29105":"# for scientific computations\nimport numpy as np\n\n# for plotting\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# cleaner than calling these modules directly\nfrom numpy import cos, sin, pi\nfrom matplotlib.animation import FuncAnimation\nfrom IPython.display import HTML\n\n%matplotlib inline\n\nsns.set_theme()\nplt.style.use(\"dark_background\")","afc5783c":"vector = (4, 2)\norigin = np.array([[0, 0, 0],[0, 0, 0]]) # origin point\nfig = plt.figure()\nax = fig.add_subplot(aspect=1)\n\nplt.quiver(*origin, *vector, color='red', angles='xy', scale_units='xy', scale=1)\nplt.xlim(-6, 6)\nplt.ylim(-6, 6)\nplt.show()","b0f1650c":"def get_rotation_matrix(shift_angle):\n    ''' returns rotation matrix for shift_angle '''\n\n    # convert to radians for numpy's cos and sin functions\n    shift_angle = shift_angle * pi \/ 180\n\n    return np.array([\n        [cos(shift_angle), -sin(shift_angle)],\n        [sin(shift_angle), cos(shift_angle)]\n    ])\n\n\ndef get_rotation_animation(start_x, start_y, x_magnitude, y_magnitude, shift_angle):\n    ''' \n        returns a graphical animation of a vector being rotated.\n        \n        parameters:\n            start_x - the starting x-coordinate of the vector\n            start_y - the starting y-coordinate of the vector\n            x_magnitude - the length of the vector along the x-axis\n            y_magnitude - the length of the vector along the y-axis\n            shift_angle - the angle to shift the vector by\n    '''\n    \n    # our animation will be drawn up on this figure\n    fig = plt.figure()\n    ax = fig.add_subplot(aspect=1)\n\n    # NOTE: ax.quiver graphically allows us to represents a vector\n    orig_quiver = ax.quiver(start_x, start_y, x_magnitude, y_magnitude, \n                            color=\"green\", angles='xy', scale_units='xy', scale=1)\n    rotating_quiver = ax.quiver(start_x, start_y, x_magnitude, y_magnitude, \n                                color=\"lightgreen\", angles='xy', scale_units='xy', scale=1)\n    \n    # notice that since the vector is rotating,\n    # max scale = vector's distance from origin\n    #           = sqrt((x_magnitude - 0)^2 + (y_magnitude - 0)^2)\n    max_scale = (x_magnitude ** 2 + y_magnitude ** 2) ** 0.5\n    \n    # scale x-axis and y-axis based on vector length\n    ax.set_xlim(-max_scale, max_scale)\n    ax.set_ylim(-max_scale, max_scale)\n    \n    # linear algebra notation of vector (what is its dimensions?)\n    vector = np.array([\n        [x_magnitude],\n        [y_magnitude]\n    ])\n    \n    def update_animation(theta):\n        ''' updates the rotation animation'''\n        \n        # don't worry about this line, it is of little consequence for us\n        nonlocal rotating_quiver, vector\n\n        # here, we @pply the rotation to the vector\n        rotate = get_rotation_matrix(theta)\n        rotated_vector =  rotate @ vector\n        \n        # get the x and y magnitudes after rotation\n        new_x_magnitude = rotated_vector[0]\n        new_y_magnitude = rotated_vector[1]\n\n        # update the graphical representation of the vector to the next frame\n        rotating_quiver.remove()\n        rotating_quiver = ax.quiver(start_x, start_y, new_x_magnitude, new_y_magnitude, \n                                    color=\"lightgreen\", angles='xy', scale_units='xy', scale=1)\n\n    # matplotlib.animation's FuncAnimation allows us to use our\n    # update_animation function to animate!\n    anim = FuncAnimation(fig, update_animation, \n                         frames=np.linspace(0, shift_angle, 200), interval=20)\n    \n    # this line is of little consequence, but it\n    # avoids outputting the original fig (to ensure that we only get the animation)\n    plt.close()\n    \n    # convert to notebook-friendly animation\n    result_animation = HTML(anim.to_jshtml())\n    \n    return result_animation","3b6c145d":"get_rotation_animation(start_x = 0, start_y = 0, x_magnitude = 1, y_magnitude = 0,\n                       shift_angle = 90)","3864f2a1":"get_rotation_animation(start_x = 0, start_y = 0, x_magnitude = 0, y_magnitude = 1,\n                       shift_angle = 90)","877e5b84":"#### REVERSING A ROTATION ####\n","46e56f42":"# On a different note, let's look at this thing:","b41f88b1":"![image.png](attachment:f2fe20f6-860a-4a4a-92ec-11440741788f.png)","725c7aad":"### NOW, if we look one level deeper...","708348be":"### Let's say we wanted to figure out how to rotate the vectors (1, 0) and (0, 1) by 90 degrees.","407f0574":"### OKAY. Let's move on to some statistics.","72f30f2c":"## Welcome, welcome. This notebook goes over some of the math behind AI. Feel free to ping me on Discord if you have any questions about its contents!","ae4abeae":"### Let's start by thinking about \"vectors\". If you've heard the term before, try to think about some contexts you've seen them being used in.","a5967bb7":"![image.png](attachment:dddcb6b2-bc34-418e-9ba8-3cbacc70fb4b.png)","b637032e":"#### NOTE: the number of input and output nodes in the network above are not to scale"}}