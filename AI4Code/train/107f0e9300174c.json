{"cell_type":{"adeac1e2":"code","cc6dedf9":"code","0449f248":"code","556c3bdf":"code","90143855":"code","a358e9f3":"code","885a3a8e":"code","f06c7c06":"code","1c24e630":"code","7a75abbe":"code","22bfbb73":"code","55ceea70":"code","e3b05539":"code","c8884607":"code","79199985":"code","8d6a7c01":"code","9c812a2a":"code","2f29c728":"code","1734fe7e":"code","4e3800d4":"code","0f46e1ef":"code","9a6f85a0":"code","e16f4795":"code","1ad625cc":"code","525e458b":"code","8d4d4cde":"code","a5b0d4f6":"markdown","3625597a":"markdown","7d7a733d":"markdown","6f18f0f8":"markdown","8bb7393e":"markdown","dc904af4":"markdown","236958fa":"markdown","418e481c":"markdown","31cba206":"markdown","c72867f7":"markdown","032c0f0d":"markdown","13fb8f24":"markdown"},"source":{"adeac1e2":"import numpy as np\nfrom keras.datasets import mnist\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import Dropout\nfrom keras.layers import Flatten\nfrom keras.layers.convolutional import Conv2D\nfrom keras.layers.convolutional import MaxPooling2D\nfrom keras.layers.convolutional import AveragePooling2D\nfrom keras.layers import Activation\nfrom keras.layers.normalization import BatchNormalization\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.utils import np_utils\nfrom keras.models import load_model\nfrom keras import optimizers\nfrom sklearn.metrics import confusion_matrix\nimport pandas as pd\nimport seaborn as sns\nimport json\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\n\nplt.style.use('ggplot')","cc6dedf9":"from numpy import genfromtxt\n\ntrain = genfromtxt(\"..\/input\/train.csv\",delimiter=',', skip_header=1)\ntest = genfromtxt(\"..\/input\/test.csv\",delimiter=',', skip_header=1)","0449f248":"X = train[:,1:]\ny = train[:,0]\n\nprint(\"X_train shape: {}\".format(X.shape))\nprint(\"y_train shape: {}\".format(y.shape))\nprint(\"X_test shape: {}\".format(test.shape))\n\nprint(\"Classes: {}\".format(np.unique(y)))\n\nnum_classes = len(np.unique(y))\nprint(\"Number of classes: {}\".format(num_classes))\n","556c3bdf":"X_reshaped = X.reshape((X.shape[0],28,28,1))\nX_test_reshaped = test.reshape((test.shape[0],28,28,1))\n\n# normalize inputs from 0-255 to 0-1\nX_reshaped = X_reshaped\/ 255\nX_test_reshaped = X_test_reshaped \/ 255\n\n# one hot encode outputs\ny_oh = np_utils.to_categorical(y)\n\nnum_classes = y_oh.shape[1]\n","90143855":"X_train, X_val, y_train, y_val = train_test_split(X_reshaped, y_oh, test_size=0.1, random_state=42)","a358e9f3":"#visualize first 9 images in training set\n\nfig, ax = plt.subplots(3, 3, sharex='col', sharey='row', figsize=(4,4))\nfig.subplots_adjust(hspace=0.5)\nindex = 0\n\nfor i in range(3):\n    for j in range(3):\n        ax[i, j].imshow(X_train[index,:,:,0], cmap=plt.get_cmap('gray'))\n        ax[i, j].set_title(\"Label: {}\".format(np.argmax(y[index])))\n        index +=1\n\nplt.show()","885a3a8e":"def create_lenet():\n  # LeNet\n\n  seed = 7\n  np.random.seed(seed)\n\n\n  # build the model\n  # create Lenet model. Use same padding for 1st layer so that output size remains at 28 x 28 similar to Lenet output layer 1\n  lenet_model = Sequential()\n  lenet_model.add(Conv2D(6, kernel_size = (5, 5), strides = (1,1), input_shape=(28,28,1), padding = \"same\", activation='tanh'))\n  lenet_model.add(AveragePooling2D(pool_size=(2, 2), strides = (2,2), padding = 'valid'))\n\n  lenet_model.add(Conv2D(16, kernel_size = (5, 5), strides = (1,1), padding = \"valid\", activation='tanh'))\n  lenet_model.add(AveragePooling2D(pool_size=(2, 2), strides = (2,2), padding = 'valid'))\n\n  lenet_model.add(Conv2D(120, kernel_size = (5, 5), strides = (1,1), padding = \"valid\", activation='tanh'))\n\n  lenet_model.add(Flatten())\n  lenet_model.add(Dense(84, activation='tanh'))\n  lenet_model.add(Dense(num_classes, activation='softmax'))\n  \n  return lenet_model\n","f06c7c06":"lenet_model= create_lenet()\n\n# Compile model\nlenet_model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])\n\n# Fit the model\nlenet_model_history = lenet_model.fit(X_train, y_train, validation_data=(X_val, y_val), epochs=30, \n                                      batch_size=128, verbose=2, shuffle=True)\n          ","1c24e630":"# evaluates model by comparing training and validation accuracy and losses\n\ndef model_evaluate(history):\n\n  f, (ax1,ax2) = plt.subplots(2,1,sharex=True, figsize = (8,8))\n  f.subplots_adjust(hspace=0.3)\n  \n  ax1.plot(history.history['acc'], 'r', linewidth=1)\n  ax1.plot(history.history['val_acc'], 'b', linewidth=1)\n\n  # Plot legend and use the best location automatically: loc = 0.\n  ax1.legend([\"Train Acc.\", \"Validation Acc.\"], loc = 0)\n  ax1.set_title(\"Training\/Validation Acc. per Epoch\")\n  ax1.set_ylabel(\"Accuracy\")\n     \n  text = \"Final Training Accuracy:{:.2f}%\\nFinal Val. Accuracy:{:.2f}%\".format(history.history['acc'][-1]*100,\n                                                                            history.history['val_acc'][-1]*100)\n  ax1.text(0.5, 0.5,text, transform=ax1.transAxes, fontsize=12)\n  \n  ax2.plot(history.history['loss'], 'r', linewidth=1)\n  ax2.plot(history.history['val_loss'], 'b', linewidth=1)\n  \n  # Plot legend and use the best location automatically: loc = 0.\n  ax2.legend([\"Train loss\", \"Validation loss\"], loc = 0)\n  ax2.set_title(\"Training\/Validation loss per Epoch\")\n  ax2.set_xlabel(\"Epoch\")\n  ax2.set_ylabel(\"Loss\")\n  \n  plt.show()\n  \n  ","7a75abbe":"#save trained model and model history\ndef save_files(model, model_name, model_history):\n  model.save(model_name+\".h5\")\n  files.download(model_name+\".h5\")\n  \n  with open(model_name+\".json\", 'w') as f:\n    json.dump(model_history.history, f)\n  files.download(model_name+\".json\")","22bfbb73":"model_evaluate(lenet_model_history)\n#save_files(lenet_model, \"lenet_model\", lenet_model_history)","55ceea70":"def create_lenet_dropout():\n\n  seed = 7\n  np.random.seed(seed)\n\n\n  # build the model\n  # create Lenet model. Use same padding for 1st layer so that output size remains at 28 x 28 similar to Lenet output layer 1\n  lenet_model = Sequential()\n  lenet_model.add(Conv2D(6, kernel_size = (5, 5), strides = (1,1), input_shape=(28,28,1), padding = \"same\", activation='relu'))\n  lenet_model.add(AveragePooling2D(pool_size=(2, 2), strides = (2,2), padding = 'valid'))\n\n  \n  lenet_model.add(Conv2D(16, kernel_size = (5, 5), strides = (1,1), padding = \"valid\", activation='relu'))\n  lenet_model.add(AveragePooling2D(pool_size=(2, 2), strides = (2,2), padding = 'valid'))\n  lenet_model.add(Dropout(0.2))\n  \n  lenet_model.add(Conv2D(120, kernel_size = (5, 5), strides = (1,1), padding = \"valid\", activation='relu'))\n  \n  lenet_model.add(Flatten())\n  lenet_model.add(Dropout(0.2))\n  lenet_model.add(Dense(84, activation='relu'))\n  lenet_model.add(Dense(num_classes, activation='softmax'))\n  \n  return lenet_model\n\n\nlenet_dropout_model= create_lenet_dropout()\n\n# Compile model\nlenet_dropout_model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])\n\n\n# Fit the model\nlenet_dropout_model_history = lenet_dropout_model.fit(X_train, y_train, validation_data=(X_val, y_val), epochs=30, batch_size=128, verbose=2, shuffle=True)\n          \n","e3b05539":"model_evaluate(lenet_dropout_model_history)\n#save_files(lenet_dropout_model, \"lenet_dropout_model\", lenet_dropout_model_history)","c8884607":"lenet_model_dataAug= create_lenet()\n\n# Compile model\nlenet_model_dataAug.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])\n","79199985":"# create image generator to create augmented data from X_train\ngen = ImageDataGenerator(rotation_range=5, width_shift_range=0.05, shear_range=0.2,\n                         height_shift_range=0.05, zoom_range=0.05)\n\n\ntrain_generator = gen.flow(X_train, y_train, batch_size=128)\n\nlenet_model_dataAug_history = lenet_model_dataAug.fit_generator(train_generator, steps_per_epoch=60000\/\/128, epochs=30, validation_data=(X_val, y_val), verbose=2)","8d6a7c01":"model_evaluate(lenet_model_dataAug_history)\n#save_files(lenet_model_dataAug, \"lenet_model_dataAug\", lenet_model_dataAug_history)","9c812a2a":"def create_model_4Conv_3FC():\n  seed = 7\n  np.random.seed(seed)\n  \n  model = Sequential()\n  model.add(Conv2D(12, kernel_size = (5, 5), strides = (1,1), input_shape=(28,28,1), padding=\"same\", activation='relu'))\n  model.add(MaxPooling2D(pool_size=(3, 3), strides = (2,2)))\n  model.add(BatchNormalization())\n\n  model.add(Conv2D(48, kernel_size = (3, 3), strides = (1,1), padding = \"same\", activation='relu'))\n  model.add(Conv2D(48, kernel_size = (3, 3), strides = (1,1), padding = \"same\", activation='relu'))\n  model.add(Conv2D(32, kernel_size = (3, 3), strides = (1,1), padding = \"same\", activation='relu'))\n  model.add(MaxPooling2D(pool_size=(3, 3), strides = (2,2)))\n  model.add(Dropout(0.4))\n\n  model.add(Flatten())\n  model.add(Dense(512, activation='relu'))\n\n  model.add(Dropout(0.4))\n  model.add(Dense(512, activation='relu'))\n\n  model.add(Dense(num_classes, activation='softmax'))\n\n\n  return model\n\n","2f29c728":"model_4Conv_3FC = create_model_4Conv_3FC()\n\nadam = optimizers.Adam(lr=1e-4)\n\nmodel_4Conv_3FC.compile(loss='categorical_crossentropy', optimizer= adam, metrics=['accuracy'])\n\n# vanilla model with original training set gave lower validation accuracy\n#model_4Conv_3FC_history = model_4Conv_3FC.fit(X_train, y_train, validation_data=(X_val, y_val), epochs=30, batch_size=128, verbose=2, shuffle=True)          \n\n#with data augmentation  \nmodel_4Conv_3FC_history = model_4Conv_3FC.fit_generator(train_generator, steps_per_epoch=60000\/\/128, epochs=30, validation_data=(X_val, y_val), verbose=2)","1734fe7e":"#save_files(model_4Conv_3FC, \"model_4Conv_3FC\", model_4Conv_3FC_history)\n\nmodel_evaluate(model_4Conv_3FC_history)","4e3800d4":"def create_model_6Conv_3FC():\n  seed = 7\n  np.random.seed(seed)\n  \n  model = Sequential()\n  model.add(Conv2D(24, kernel_size = (3, 3), strides = (1,1), input_shape=(28,28,1), activation='relu', padding='same'))\n  model.add(Conv2D(24, kernel_size = (3, 3), strides = (1,1), activation='relu', padding='same'))\n  model.add(Conv2D(24, kernel_size = (3, 3), strides = (1,1), activation='relu', padding='same'))\n  model.add(MaxPooling2D(pool_size=(2, 2), strides = (2,2)))\n  model.add(BatchNormalization())\n  \n  model.add(Conv2D(24, kernel_size = (3, 3), strides = (1,1), activation='relu', padding='same'))\n  model.add(Conv2D(24, kernel_size = (3, 3), strides = (1,1), activation='relu', padding='same'))\n  model.add(Conv2D(24, kernel_size = (3, 3), strides = (1,1), activation='relu', padding='same'))\n  model.add(MaxPooling2D(pool_size=(2, 2), strides = (2,2)))\n  model.add(BatchNormalization())\n\n  model.add(Flatten())\n  model.add(Dropout(0.2))\n  model.add(Dense(512, activation='relu'))\n  model.add(Dropout(0.2))\n  model.add(Dense(512, activation='relu'))\n  model.add(Dense(num_classes, activation='softmax'))\n\n\n  return model\n\n","0f46e1ef":"model_6Conv_3FC = create_model_6Conv_3FC()\n\nadam = optimizers.Adam(lr=1e-4)\n\nmodel_6Conv_3FC.compile(loss='categorical_crossentropy', optimizer=adam, metrics=['accuracy'])\n\n# vanilla model with original data set\n#model_6Conv_3FC_history = model_6Conv_3FC.fit(X_train, y_train, validation_data=(X_val, y_val),\n#                                                  epochs=30, batch_size=128, verbose=2, shuffle=True)\n\n#data augmentation\nmodel_6Conv_3FC_history = model_6Conv_3FC.fit_generator(train_generator, steps_per_epoch=60000\/\/128, epochs=30, validation_data=(X_val, y_val), verbose=2)         ","9a6f85a0":"model_evaluate(model_6Conv_3FC_history)\n#save_files(model_6Conv_3FC, \"model_6Conv_3FC\", model_6Conv_3FC_history)","e16f4795":"index = [\"lenet_model\",\"lenet_dropout_model\",\"lenet_model_dataAug\",\n          \"model_4Conv_3FC\", \"model_6Conv_3FC\"]\nmodel_history = [lenet_model_history.history,lenet_dropout_model_history.history,\n                 lenet_model_dataAug_history.history,\n                 model_4Conv_3FC_history.history, \n                 model_6Conv_3FC_history.history]\nmodels = [lenet_model,lenet_dropout_model,lenet_model_dataAug,\n          model_4Conv_3FC, model_6Conv_3FC]\n\ntrainingAcc = []\nvalAcc = []\ntrainingLoss = []\nvalLoss = []\nnumParams = []\n\nfor model, hist in zip(models, model_history):\n  trainingAcc.append(round(hist['acc'][-1],4))\n  valAcc.append(round(hist['val_acc'][-1],4))\n  trainingLoss.append(round(hist['loss'][-1],4))\n  valLoss.append(round(hist['val_loss'][-1],4))\n  numParams.append(model.count_params())\n\ndf = pd.DataFrame(list(zip(trainingAcc, valAcc, trainingLoss, valLoss, numParams)), \n               columns =['trainingAcc', 'valAcc', 'trainingLoss', 'valLoss', 'numParams'], \n                 index = index) \n  \n","1ad625cc":"df","525e458b":"predictions = model_4Conv_3FC.predict(X_test_reshaped)\npredictions_classes = np.argmax(predictions, axis=1)\nfilename = \"submission.csv\"\n\npredictions_df = pd.DataFrame({'ImageId': np.arange(1,len(predictions_classes)+1), 'Label': predictions_classes})\npredictions_df.to_csv(filename, index=False)","8d4d4cde":"files.download(\"submission.csv\")\n","a5b0d4f6":"With dropout, the validation accuracy improved to 98.8%, which suggests that this model generalizes better. ","3625597a":"**a) CNN with 4 Conv Layers + 3 FCs** \n\nAlexNet has 5 Conv Layers + 3 FCs and takes in images of 227x227 pixels to give 1000 possible output classes. \n\nThe inputs to the 2nd Conv layer in AlexNet are 27 x 27 pixels, similar in size to the MNIST data (28 x 28) and the MNIST data set is less complex (only 10 classes). A model architecture was therefore adapted loosely from AlexNet with the first Conv layer removed leaving 4 Conv Layers + 3 FCs \n\nDue to the relative simplicity of the MNIST data, the number of filters was also reduced to keep the number of parameters low without compromising prediction accuracy.  ","7d7a733d":"**LeNet Architecture**\n\nA model based on the LeNet CNN architecture was trained using Adam optimizer. ","6f18f0f8":"**Objective**\nThis is a classification task which takes as input gray scale images of hand-written numbers and predicts which of 10 numbers it shows. \n\nThe input images are 28 x 28 pixels (784 features) while the output variable gives the ground-truth label of the input images and takes values between 0 - 10. \n\nA classifier utilizing CNN will be trained on (X_train, y_train). (X_test, y_test) will be used as the validation set.\n\n**Data preprocessing**\nTo apply CNNs, the data will be reshaped into 4D-arrays of (m, 28, 28, 1), where m denotes the number of samples in each data set. Furthermore, all  inputs will be normalized by 255 (the max intensity value) to minimize the effect of varying image intensity across images.\n\nOne-hot encoding will be applied to y labels","8bb7393e":"**2) LeNet with data augmentation**\nTo reduce overfitting, Keras ImageDataGenerator was used to sample training data and augment them, effectively giving a large pool of training samples to train the base LeNet model","dc904af4":"The model with 6 Conv + 3 FC layers has a validation accuracy of 99.28%,  comparable to some of rhe earlier models. Similar to the CNN with 4Conv layers, the learning rate was reduced to 1e-4 to produce stabler loss curves to aid in confirmation that the model had been optimized. ","236958fa":"**3) Experiments with other CNN Architectures:**\nTo see if further improvements in prediction accuracy could be made, experiments were conducted using different model architectures based loosely on AlexNet and VGGNet","418e481c":"**b) CNN with 6 Conv Layers + 3 FCs** \n\nSimilar to the previous model, a scaled down version of the VGGnet architecture was used. The l VGGnet utilizes only 3x3 filters for conv layers and 2x2 pooling layers. In consideration of the complexity(or lack thereof) of the MNIST data set and the smaller image sizes, fewer convolutional layers were employed for this model.","31cba206":"**1) Add dropout layers and use ReLu Activation**\n\nTo minimize the overfitting, dropout layers were added to the Lenet architecture. ReLu activation was used instead of tanh","c72867f7":"With data augmentation (i.e. a larger training set), the base LeNet model does generalize better to the validation data,  with an improvement in validation accuracy to 98.8%, comparable to the model with dropout.\n\n","032c0f0d":"The model with 4 Conv + 3 FC layers gives an appreciable improvement in validation accuracy to 99.36%.\n\nIn training this model, learning rate was lowered to 1e-4, as the default value of 1e-3 resulted in noisy loss curves for which it was difficult to determine whether the training had converged. Dropout values were also tuned and data augmentation was used to reduce overfitting.","13fb8f24":"For the LeNet model, batch sizes of 128 and 256 were tried but it was found that the results were similar. The result above shows the trained model using a batch size of 128.\n\nThe validation accuracy is 97.9%, 2% lower than the traiing accuracy.  This suggests that the model may be slightly overfitting on the training set. \n\nTo mitigate the overfitting on the LeNet model, three options were explored:\n1) Add dropout layers to the mode\n2) Use data augmentation to increase the size of the training set\n3) Explore different CNN architectures"}}