{"cell_type":{"b6ae3bee":"code","aba0e33a":"code","284486db":"code","2e55a2b4":"code","5f067253":"code","bf9537e0":"code","32d659c1":"code","2b5ec33d":"code","c5169cc1":"code","fd2d6a0c":"code","54e9d0fd":"code","ba15577c":"code","4d427403":"code","6748953c":"code","426de1a9":"code","50519b1b":"code","54082323":"code","980758a2":"code","192e4449":"code","6dd03a68":"code","f78a9d2c":"code","fcc7e535":"code","e6a60e63":"code","cdd7a56a":"code","c08e20bb":"code","a3ea0295":"code","94547758":"code","346be8b6":"code","ec87bc98":"code","31770cd5":"code","a9a18281":"code","51ca8421":"code","1f698504":"code","964d16ab":"code","5438ed12":"code","28595f57":"markdown","cb1a528e":"markdown","4220914d":"markdown","151f5fac":"markdown","b97721e7":"markdown","7594dbf2":"markdown","a2a69f3e":"markdown","e32ead02":"markdown","1b4c6cec":"markdown","c968926b":"markdown","7fc8394f":"markdown","8436bc5c":"markdown","18724c6f":"markdown","32b92240":"markdown","e7a578b8":"markdown","7f28a079":"markdown","6bf85c0a":"markdown","abe07084":"markdown"},"source":{"b6ae3bee":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt","aba0e33a":"!head -n 5 \/kaggle\/input\/daily-climate-time-series-data\/DailyDelhiClimateTrain.csv","284486db":"train_df = pd.read_csv('\/kaggle\/input\/daily-climate-time-series-data\/DailyDelhiClimateTrain.csv', header=0, index_col=0, parse_dates=True, squeeze=True)\ntrain_df.head()","2e55a2b4":"train_df.shape","5f067253":"def get_df_feature(df, new_features, append_features=False, drop_index=False):\n    if append_features:\n        df = pd.concat([df, time_features])\n        if drop_index:\n            df = df.reset_index(drop=True)\n        return df\n    return new_features","bf9537e0":"def get_time_features(df, append_features=False, drop_index=False, feature_extractors={}):\n    '''Creates the time based features and returns the features as a dataframe.\n    Args: \n        df             : Dataframe with time index\n        append_features: defaults to False, appends the features to the dataframe if True \n        drop_index     : defaults to False, drops the datetime index if True. Only applied if append_features is True.     \n        feature_extractors: Defaults to an empty dict. Can be used to pass in feature extractor methods. The methods should be passed as a dict {'feature_name': 'feature_extractor_method'}\n        \n    Returns: \n        return new time features if append_features = False. If True, return the original dataframe with the new time features appended.\n    '''\n    features = ['dayofweek', 'dayofyear', 'day','year','month','daysinmonth','is_leap_year','is_month_end','is_quarter_end', 'is_year_end', 'is_month_start', 'is_month_start','is_quarter_start','is_year_start','quarter','week']\n    time_features = pd.DataFrame()\n    dates = df.reset_index(drop=False)['date']\n    for p in features: time_features[p] = dates.apply(lambda x: getattr(x, p))\n    for f_name, func in feature_extractors.items():\n        time_features[f_name] = dates.apply(func)\n    return get_df_feature(df, time_features, append_features, drop_index)","32d659c1":"get_time_features(train_df)","2b5ec33d":"def is_odd_date(feature):\n    return True if feature.day % 2 == 0 else False\n\nget_time_features(train_df, feature_extractors={'is_odd_date': is_odd_date})","c5169cc1":"def get_lag_features(df, lag=1, append_features=False, drop_index=False):\n    '''Creates and returns lag features. Lag features in Time series are the observations at previous time steps. \n    '''\n    feature_names = df.columns.tolist()\n    lag_features = pd.DataFrame()\n    for l in range(lag,0,-1):\n        for feat in feature_names:\n            lag_features[f'{feat}_lag_{l}'] = df[feat].shift(l).copy(deep=True)\n    \n    return get_df_feature(df, lag_features, append_features, drop_index)","fd2d6a0c":"get_lag_features(train_df, lag=4)","54e9d0fd":"def get_rolling_window_features(df, width=3, columns=[], append_features=False,feature_extractors={}):\n    '''Creates and returns features calculated over a rolling window of specified width.\n    \n    Args:\n        df : input dataframe\n        width: (default=3) window size for rolling statistics\n        columns: (default=[]). By default, uses all the features to generate rolling window features.\n                When feature list is specified, the specified features are used.\n        append_features: appends the generated features to the input dataframe when True, default False.\n        feature_extractors: a dict of {'feature_name': feature_extractor_method}\n    '''\n    features = ['min', 'max','mean', 'median']\n    shifted = df.shift(width-1)\n    rw_features = pd.DataFrame()\n    if not columns: \n        columns = df.columns.tolist()\n    for col in columns:\n        rolling_col = shifted[col].rolling(window=width)\n        for feat in features:\n            rw_features[f'{col}_roll_{feat}_w{width}'] = getattr(rolling_col, feat)()\n        for feat, func in feature_extractors.items():\n            rw_features[f'{col}_roll_{feat}_w{width}'] = rolling_col.apply(func)\n    return get_df_feature(df, rw_features, append_features)","ba15577c":"get_rolling_window_features(train_df)","4d427403":"def get_expanding_window_features(df, columns=[], append_features=False, feature_extractors={}):\n    \"\"\"Creates and returns expanding window features for the specified columns.\n    Args:\n        df: input dataframe\n        columns: (default=[]). By default, uses all the features to generate expanding window features.\n                When feature list is specified, the specified features are used.\n        append_features: appends the generated features to the input dataframe when True, default False.\n        feature_extractors: a dict of {'feature_name': feature_extractor_method}\n    \"\"\"\n    features = ['min', 'max','mean', 'median']\n    expanding_features = pd.DataFrame()\n    # Shifting the data by one time step to ensure the output is not included in the window\n    shifted = df.shift(1) \n    if not columns: \n        columns = df.columns.tolist()\n    for col in columns:\n        expanding_col = shifted[col].expanding()\n        for feat in features:\n            expanding_features[f'{col}_expanding_{feat}'] = getattr(expanding_col, feat)()\n        for feat, func in feature_extractors.items():\n            expanding_features[f'{col}_expanding_{feat}'] = expanding_col.apply(func)\n    return get_df_feature(df, expanding_features, append_features)\n    ","6748953c":"get_expanding_window_features(train_df, columns=['meantemp']).head(10)","426de1a9":"axes = plt.subplots(2,2,constrained_layout=True, figsize=(15,10))\naxes = axes[1].flatten()\nfor col,ax in zip(train_df.columns,axes):\n    train_df[col].plot(style='b.', alpha=0.2, ax=ax)\n    ax.set_title(f'{col} vs Time')\nplt.show()","50519b1b":"plt.figure(figsize=(15,6))\ntrain_df.meanpressure.plot(style='r.', alpha=0.2)\nplt.ylim(800,1200)\nplt.title('Mean Pressure vs Time')\nplt.show()","54082323":"def plot_groups(feature_name, freq='A', title='', ylim=None):\n    groups = train_df[feature_name].groupby(pd.Grouper(freq=freq))\n    years = pd.concat([pd.DataFrame({name.year: group.values}) for name, group in groups], axis=1)\n    axes = years.plot(subplots=True, legend=True, figsize=(14,8),title=title)\n    if ylim:\n        [ax.set_ylim(ylim[0],ylim[1]) for ax in axes]\n    plt.show()","980758a2":"plot_groups('meantemp', title='Mean Temperature vs Time')","192e4449":"plot_groups('meanpressure', ylim=[980, 1030], title='Mean Pressure vs Time')","6dd03a68":"plot_groups('wind_speed', title='Wind-Speed vs Time')","f78a9d2c":"plot_groups('humidity', title=\"Humidity vs Time\")","fcc7e535":"fig,axes=plt.subplots(1,2, figsize=(14,7))\ntrain_df['meantemp'].hist(bins=40, ax=axes[0])\ntrain_df['meantemp'].plot(kind='kde', ax=axes[1])\nplt.show()","e6a60e63":"fig,axes=plt.subplots(1,2, figsize=(14,7))\ntrain_df['meanpressure'].hist(bins=40, ax=axes[0])\ntrain_df['meanpressure'].plot(kind='kde', ax=axes[1])\nplt.show()","cdd7a56a":"fig,axes=plt.subplots(1,2, figsize=(14,7))\ntrain_df['humidity'].hist(bins=40, ax=axes[0])\ntrain_df['humidity'].plot(kind='kde', ax=axes[1])\nplt.show()","c08e20bb":"fig,axes=plt.subplots(1,2, figsize=(14,7))\ntrain_df['wind_speed'].apply(np.sqrt).hist(bins=30,ax=axes[0])\ntrain_df['wind_speed'].apply(np.sqrt).plot(kind='kde',ax=axes[1])\nplt.show()","a3ea0295":"def get_box_and_whiskers(df, feature, freq='M',title='', ylim=None):\n    groups = df[feature].groupby(pd.Grouper(freq=freq))\n    years = pd.concat([pd.DataFrame({f'{name.month}_{name.year}':group.values}) for name,group in groups])\n    years.boxplot(figsize=(20,8))\n    plt.xticks(rotation=90)\n    plt.title(title)\n    if ylim:\n        plt.ylim(ylim[0],ylim[1])\n    plt.show()","94547758":"get_box_and_whiskers(train_df, 'meantemp', title='Plot of mean temperature over time')","346be8b6":"get_box_and_whiskers(train_df, 'meanpressure',title='Plot of mean pressure over time',ylim=(990,1030))","ec87bc98":"get_box_and_whiskers(train_df, 'humidity', title='Plot of Humidity over time')","31770cd5":"get_box_and_whiskers(train_df, 'wind_speed', title='Plot of Wind Speed over Time')","a9a18281":"def get_heat_maps_by_year(df, feature,clip=None):\n    groups = df[feature].groupby(pd.Grouper(freq='A'))\n    years = pd.concat([pd.DataFrame({name.year: group.values}) for name, group in groups], axis=1)\n    years = years.T\n    years = years.drop(2017)\n    if clip: years = years.clip(**clip)\n    plt.matshow(years, interpolation=None, aspect='auto',cmap='viridis')\n    plt.colorbar()\n    plt.show()","51ca8421":"get_heat_maps_by_year(train_df, 'meantemp')","1f698504":"get_heat_maps_by_year(train_df, 'meanpressure', clip={'lower':990, 'upper':1030})","964d16ab":"get_heat_maps_by_year(train_df, 'humidity')","5438ed12":"get_heat_maps_by_year(train_df, 'wind_speed',clip={'lower':0,'upper':20})","28595f57":"# Introduction\n\nThis notebook is an implementation and documentation of everything that I am learning as I am learning Time Series Forecasting. I have tried to created methods for each feature extractions. The notebook is a work in progress and will be updated constantly. All the code in the notebook will be refactored in time.\n\n>Please provide feedback in comments and shoot out in the comments if I am going wrong or you need some clarifications. ","cb1a528e":"## 3.Box and Whiskers Plots by interval","4220914d":"## 1. Line Plots","151f5fac":"### 3. Creating Rolling Window Features\n\nRolling Window Features are the features that are generated by extracting statistical information from a moving window with a specified window size. \n","b97721e7":"# Building Features","7594dbf2":"# Loading the Data","a2a69f3e":"To understand the distribution of the features, we can plot the histograms and density plots. This helps us understand the distribution and also the kind of transforms that can be applied to it.","e32ead02":"### 4. Creating Expanding Window Features.","1b4c6cec":"Box and whiskers plots give us a good idea of where majority of our data lies. It also helps find the outliers which can be further analysed to understand the outliers.\n\nThe box shows the 25th percentile to 75th percentile of the data and the whiskers show the IQR of the data","c968926b":"# Data Visualization","7fc8394f":"We can clearly see the seasonality in the Mean temperature, windspeed, and humidity. The mean pressure has a few outliers. Removing these may give us a closer look.\n\nWe can see below that removing the outlier and zooming in on the pressure data shows clear seasonality","8436bc5c":"We will be looking at the following plots: \n1. Lineplots\n2. Histograms.\n3. Box and whiskers plots\n4. Lag plots\n5. Heat Maps\n6. Autocorrelation Plots","18724c6f":"We can also compare the data from different periods; like each year, each month etc. Lets look at plotting the graphs for each year","32b92240":"### 2. Creating Lag Features","e7a578b8":"We can use the get_time_features function to create more time features than the ones in the features array. All we have to do is to write a simple `feature_extractor` function and pass it to the get_time_features along with a `feature name` in a dict as follows:","7f28a079":"## 2. Histograms and Density Plots","6bf85c0a":"## 4. Heat Maps","abe07084":"### 1. Creating Time Features"}}