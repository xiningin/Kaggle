{"cell_type":{"cb92bf56":"code","919a4112":"code","58585aad":"code","ad0880a1":"code","5ebb1492":"code","6c2554d6":"code","02424722":"code","a0c35ab3":"code","7cc54e8e":"code","d9f970c8":"code","90b96f7c":"code","bebafc5a":"code","ca0fb8c1":"code","40253c7b":"code","2b8e95eb":"code","c50f735d":"code","369ccbde":"code","2828daa0":"code","472d640d":"code","26a73e28":"code","b3565203":"code","575b3f6c":"code","3727be3e":"code","37bbb84d":"code","0cb21acc":"code","05c70a68":"markdown","8f02a08d":"markdown","7b1358f6":"markdown","e08d1a86":"markdown","7cba739c":"markdown","6a749283":"markdown"},"source":{"cb92bf56":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","919a4112":"from sklearn.preprocessing import Imputer\nfrom sklearn.metrics import accuracy_score","58585aad":"data_train = pd.read_csv('\/kaggle\/input\/titanic\/train.csv')\ny_train = data_train['Survived']\nx_train = data_train.loc[:,data_train.columns != 'Survived']","ad0880a1":"object_features = []\nfor col in x_train.columns:\n    if x_train[col].dtype == 'object':\n        x_train[col + '_cat'] = x_train[col].astype('category').cat.codes\n        object_features.append(col)","5ebb1492":"x_train.drop(object_features, axis = 1, inplace = True)\n\nimp = Imputer()\nx_train = imp.fit_transform(x_train)","6c2554d6":"data_test","02424722":"data_test = pd.read_csv('\/kaggle\/input\/titanic\/test.csv')\nx_test = data_test\n\nobject_features = []\nfor col in x_test.columns:\n    if x_test[col].dtype == 'object':\n        x_test[col + '_cat'] = x_test[col].astype('category').cat.codes\n        object_features.append(col)\n\nx_test.drop(object_features, axis = 1, inplace = True)\n\nimp = Imputer()\nx_test = imp.fit_transform(x_test)","a0c35ab3":"import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport torch.optim as torch_optim\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torchvision import models","7cc54e8e":"class TitancDataset(Dataset):\n    def __init__(self, data, y):\n        self.x_train = data\n        self.y_train = y\n        \n        self.x_train = self.x_train\n        self.y_train = np.array(self.y_train)\n        \n    def __len__(self):\n        return len(self.x_train)\n    \n    def __getitem__(self, idx):\n        return (self.x_train[idx], self.y_train[idx])","d9f970c8":"class TitancDataset_test(Dataset):\n    def __init__(self, data):\n        self.x_test = data\n        \n        self.x_test = self.x_test\n        \n    def __len__(self):\n        return len(self.x_test)\n    \n    def __getitem__(self, idx):\n        return (self.x_test[idx], _)","90b96f7c":"dataset_train = TitancDataset(x_train, y_train)","bebafc5a":"iterdata = iter(dataset_train)","ca0fb8c1":"next(iterdata)","40253c7b":"trainloader = DataLoader(dataset_train, batch_size = 64, num_workers = 0, shuffle = True)","2b8e95eb":"dataset_test = TitancDataset_test(x_test)\ntestloader = DataLoader(dataset_test, batch_size = 64, num_workers = 0, shuffle = False)","c50f735d":"# Simple Neural network \ninput_size = 11\nhidden_size = 128\nnum_classes = 1 \nnum_epochs = 5\nlearning_rate = 0.001\nBATCH_SIZE_1 = 101 #train_loader as it has 404 observations\nBATCH_SIZE_2 = 51 #test_loader as it has 102 observations","369ccbde":"device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\nkwargs = {'num_workers': 1, 'pin_memory': True} if device=='cuda' else {}","2828daa0":"class LinearModel(nn.Module):\n    def __init__(self, input_size, hidden_size, num_classes):\n        super(LinearModel, self).__init__()\n        self.fc1 = nn.Linear(input_size, hidden_size)\n        self.fc2 = nn.Linear(hidden_size, num_classes)\n        self.relu = nn.ReLU()\n                           \n    def get_weights(self):\n        return self.weight\n    \n    def forward(self,x):\n        out = self.fc1(x)\n        out = self.relu(out)\n        out = F.sigmoid(self.fc2(out)) #sigmoid as we use BCELoss\n        return out","472d640d":"def train(model, device, train_loader, optimizer):\n    model.train()\n    y_true = []\n    y_pred = []\n    for i in train_loader:\n        \n        #LOADING THE DATA IN A BATCH\n        data, target = i\n \n        #MOVING THE TENSORS TO THE CONFIGURED DEVICE\n        data, target = data.to(device), target.to(device)\n       \n        #FORWARD PASS\n        output = model(data.float())\n#         loss = criterion(output, target.unsqueeze(1))\n        loss = criterion(output, target.float())\n        \n        #BACKWARD AND OPTIMIZE\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n        \n        # PREDICTIONS \n        pred = np.round(output.detach())\n        target = np.round(target.detach())             \n        y_pred.extend(pred.tolist())\n        y_true.extend(target.tolist())\n        \n    print(\"Accuracy on training set is\" ,accuracy_score(y_true,y_pred))","26a73e28":"#TESTING THE MODEL\ndef test(model, device, test_loader):\n    #model in eval mode skips Dropout etc\n    model.eval()\n#     y_true = []\n    y_pred = []\n    \n    # set the requires_grad flag to false as we are in the test mode\n    with torch.no_grad():\n        for i in test_loader:\n            \n            #LOAD THE DATA IN A BATCH\n            data,target = i\n            \n            # moving the tensors to the configured device\n            data, t = data.to(device), _\n            \n            # the model on the data\n            output = model(data.float())\n                       \n            #PREDICTIONS\n            pred = np.round(output)\n#             target = target.float()\n#             y_true.extend(target.tolist()) \n            y_pred.extend(pred.reshape(-1).tolist())\n    \n    return y_pred\n            \n#     print(\"Accuracy on test set is\" , accuracy_score(y_true,y_pred))\n#     print(\"***********************************************************\")","b3565203":"# Creating model and setting loss and optimizer.\nmodel = LinearModel(input_size, hidden_size, num_classes).to(device)\ncriterion = nn.BCELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)","575b3f6c":"num_epochs = 100\nfor epoch in range(num_epochs):\n        train(model,device,trainloader,optimizer)\n#         test(model,device,test_loader)","3727be3e":"y_pred = test(model,device,testloader)","37bbb84d":"from collections import Counter\n\nCounter(y_pred)","0cb21acc":"my_submission = pd.DataFrame({'PassengerId' :data_test['PassengerId'], 'Survived': y_pred})\nmy_submission.to_csv('submission.csv', index=False)","05c70a68":"# torch modelling","8f02a08d":"# categorical data test","7b1358f6":"# Data Augmentation","e08d1a86":"# train model","7cba739c":"1. * # categorical data train","6a749283":"# Model definition and params"}}