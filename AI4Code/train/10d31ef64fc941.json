{"cell_type":{"bb9c16b2":"code","76237acc":"code","6ee3d8e6":"code","39f353aa":"code","30b6d243":"code","4dd3c953":"code","c41750a0":"code","82ab6ecd":"code","34a48d0e":"code","5027ff6d":"code","4f4a5fc4":"code","9ece31b0":"code","91a971bc":"code","28a8e259":"code","5c4b062f":"code","62663c08":"code","1b6fe257":"code","a7d9b54d":"code","d9453776":"code","8926b277":"code","00e57104":"code","91efb828":"code","506515c4":"code","e857378d":"code","670e86f5":"code","7f9dd5da":"code","61dbec48":"code","505edc99":"code","56eee950":"code","04396f22":"code","3f9a223d":"code","244278d4":"code","d95ca3c5":"code","71312f9b":"code","e8151c72":"code","d914943b":"code","e4b432b0":"code","56a8d57c":"code","337d70d3":"code","15627625":"code","ea8560a4":"code","77d8abb4":"code","220c6095":"code","2a7ebdd9":"code","1104a7a5":"markdown","1eb77322":"markdown","771c7c5e":"markdown"},"source":{"bb9c16b2":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n#Updating to follow flow in Course v3\n#https:\/\/github.com\/fastai\/course-v3\/blob\/master\/nbs\/dl1\/lesson1-pets.ipynb","76237acc":"%reload_ext autoreload\n%autoreload 2\n%matplotlib inline","6ee3d8e6":"# This file contains all the main external libs we'll use - fastai v1\nfrom fastai import *\nfrom fastai.vision import *\nfrom fastai.metrics import error_rate","39f353aa":"path = Path(\"\/kaggle\/input\/dog-breed-identification\/\")\n# 32 when testing 224 when for real - better way from course is to reduce the batch size to 32\n#sz=32 \nbs = 16\nsz=224\nTMP_PATH = \"\/tmp\/tmp\"\nMODEL_PATH = \"\/tmp\/model\/\"\narch = 'resnet34'\ncomp_name = \"dog_breed\"","30b6d243":"path.ls()","4dd3c953":"label_df = pd.read_csv(path\/'labels.csv')","c41750a0":"#what does the csv file look like id is the file name (minus .jpg), breed is the classification\nlabel_df.head()","82ab6ecd":"# GPU required\ntorch.cuda.is_available()","34a48d0e":"torch.backends.cudnn.enabled","5027ff6d":"# Fix to enable Resnet to live on Kaggle - creates a writable location for the models\ncache_dir = os.path.expanduser(os.path.join('~', '.torch'))\nif not os.path.exists(cache_dir):\n    os.makedirs(cache_dir)\n   # print(\"directory created :\" .cache_dir)\nmodels_dir = os.path.join(cache_dir, 'models')\nif not os.path.exists(models_dir):\n    os.makedirs(models_dir)\n  #  print(\"directory created :\" . cache_dir)","4f4a5fc4":"#copying model to writable location\n#cd \/kaggle\/working\nshutil.copy(\"\/kaggle\/input\/resnet34\/resnet34.pth\", \"\/tmp\/.torch\/models\/resnet34-333f7ec4.pth\")","9ece31b0":"#crashes with too many workers (remove numworkers while testing with a small image size ~ 64), keep for the bigger images for accuracy\ntfms = get_transforms(do_flip=True, max_zoom=1.1)\n\ndata = ImageDataBunch.from_csv(path, ds_tfms=tfms, folder=\"train\", test='test', suffix='.jpg', bs=bs, size=sz, num_workers=0).normalize(imagenet_stats) \n#data = ImageDataBunch.from_csv(PATH, ds_tfms=tfms, folder=\"train\", test='test', suffix='.jpg', size=sz)","91a971bc":"data.show_batch(rows=3, figsize=(7,6))","28a8e259":"#label_df.pivot_table(index='breed', aggfunc=len).sort_values('id', ascending=False) - show the summary from the table\n#To save space:\nprint(data.classes)\nlen(data.classes),data.c","5c4b062f":"#img = plt.imread(f'{PATH}train\/{label_df.iloc[0,0]}.jpg')\nimg = plt.imread(path\/f'train\/{label_df.iloc[0,0]}.jpg')\nplt.imshow(img);","62663c08":"img.size","1b6fe257":"#Look at the distribution of the size of the images\nsize_d = {}\nfor index, row in label_df.iterrows():\n    size_d[index] = PIL.Image.open(path\/f'train\/{row[0]}.jpg').size","a7d9b54d":"row_sz,col_sz = list(zip(*size_d.values()))","d9453776":"row_sz=np.array(row_sz);col_sz=np.array(col_sz)","8926b277":"row_sz[:5]","00e57104":"col_sz[:5]","91efb828":"plt.hist(row_sz[row_sz<1000])","506515c4":"plt.hist(col_sz[col_sz<1000])","e857378d":"len(data.classes), data.classes[:5]","670e86f5":"learn = cnn_learner(data, models.resnet34, metrics=error_rate, model_dir=MODEL_PATH)","7f9dd5da":"learn.fit_one_cycle(4)","61dbec48":"#learn.save('stage-1')","505edc99":"interp = ClassificationInterpretation.from_learner(learn)\n\nlosses,idxs = interp.top_losses()\n\nlen(data.valid_ds)==len(losses)==len(idxs)","56eee950":"interp.plot_top_losses(9, figsize=(15,11))","04396f22":"interp.most_confused(min_val=2)","3f9a223d":"learn.unfreeze()","244278d4":"learn.fit_one_cycle(1)","d95ca3c5":"#learn.load('stage-1');\nlearn.lr_find()","71312f9b":"learn.recorder.plot()","e8151c72":"learn.lr_find()\nlearn.recorder.plot()","d914943b":"learn.unfreeze()\nlearn.fit_one_cycle(2, max_lr=slice(1e-6,1e-5))","e4b432b0":"#learn.fit_one_cycle(4,max_lr=(1e-2, (1e-2)\/2, (1e-2)\/3))\n#learn.fit_one_cycle(1,max_lr=(1e-2, (1e-2)\/2, (1e-2)\/3)) # for testing\n#learn.recorder.plot_losses()","56a8d57c":"preds,y,losses = learn.get_preds(with_loss=True)\ninterp = ClassificationInterpretation(learn, preds, y, losses)\ninterp.plot_top_losses(9, figsize=(14,14))","337d70d3":"predictions = learn.get_preds(ds_type=DatasetType.Test)","15627625":"test_df = pd.read_csv(path\/'sample_submission.csv')","ea8560a4":"submission_columns = data.classes.copy()\nsubmission_columns.insert(0, 'id')\ndf = pd.DataFrame(columns=submission_columns)","77d8abb4":"for idx in range(len(predictions[0])):\n#for idx in range(3):\n    probs = predictions[0][idx].tolist()\n    formatted_probs = [\"%.17f\" % member for member in probs]\n    filename = [test_df['id'][idx]]\n    df.loc[idx] = filename + formatted_probs","220c6095":"df.head()","2a7ebdd9":"# Submission\ndf.to_csv(f\"sub_{comp_name}_{arch}.csv\", index=False)","1104a7a5":"Unfreezing, fine-tuning, and learning rates\n\nSince our model is working as we expect it to, we will unfreeze our model and train some more.","1eb77322":"**Initial model**","771c7c5e":"[Dog breed identification](https:\/\/www.kaggle.com\/c\/dog-breed-identification) using Fast ai v1 "}}