{"cell_type":{"be001d8f":"code","a7b3a440":"code","563f5ead":"code","a88e8c9a":"code","36c40b0c":"code","e8e1b201":"code","f5765e01":"code","08b7fb14":"code","7163a3c1":"code","c53e4167":"code","2c56e84d":"code","b52394cd":"code","3ad7027e":"code","e6cc9486":"markdown","7c46f9e3":"markdown","24363310":"markdown","59f4a347":"markdown"},"source":{"be001d8f":"# ~400 .dcm files have Transfer Syntax UID : JPEG Lossless, Nonhierarchical, First- Order Prediction \n# therefore, GDCM must be installed beforehand, in order to decode it.\n# The other files have 'Explicit VR Little Endian', which is supported by pydicom alone.\n# GDCM package available: +Add data -> gdcm-conda-forge -> Add\n!tar -xvf ..\/input\/gdcm-conda-install\/gdcm.tar\n!conda install ..\/working\/gdcm\/conda-4.8.4-py37hc8dfbb8_2.tar.bz2\n!conda install ..\/working\/gdcm\/gdcm-2.8.9-py37h71b2a6d_0.tar.bz2\n!conda install ..\/working\/gdcm\/libjpeg-turbo-2.0.3-h516909a_1.tar.bz2","a7b3a440":"import os\nimport glob\nfrom tqdm import tqdm\nfrom pathlib import Path\n\nimport pandas as pd\nimport numpy as np\n\n# from pydicom.pixel_data_handlers.util import apply_voi_lut\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom collections import Counter\n\nfrom PIL import Image\nimport gdcm\nimport pydicom\n\nimport cv2\nimport random","563f5ead":"HOME = Path('\/kaggle\/input\/siim-covid19-detection\/')\nSTUDY_ANN = Path('train_study_level.csv')\nIMG_ANN = Path('train_image_level.csv')\n\nTRAIN = '\/kaggle\/input\/siim-covid19-detection\/train\/'","a88e8c9a":"img_ann = pd.read_csv(HOME\/IMG_ANN)\nimg_ann.head(3)","36c40b0c":"# The equivalent of utils.py\ndef rescale_dcm(dcm_px):\n    zero_one = (dcm_px - dcm_px.min())\/((dcm_px.max() - dcm_px.min()))\n    rescaled = (zero_one * 255).astype(np.uint8)\n    return rescaled\n\ndef apply_hist_equalization(array):\n    clahe = cv2.createCLAHE(clipLimit = 2, tileGridSize = (8,8))\n    cl_array = clahe.apply(array)\n    return cl_array","e8e1b201":"# The overall mean and standard deviation were calculated:\nSAMPLE_MEAN = 134.0\nSAMPLE_STD = 56.0","f5765e01":"# Sample 6 images from the annotation file\nsample_df = img_ann.sample(6)\n\n# Plot\nfig, ax = plt.subplots(nrows = 6, ncols = 4, figsize = (25,30))\nr = 0\nc = 0\n\nfor idx, image in tqdm(sample_df.iterrows(), total = len(sample_df)):\n    dcm_path = glob.glob(os.path.join(TRAIN, \n                                      image.StudyInstanceUID, \n                                      \"*\",\n                                      image.id.split(\"_\")[0]+\".dcm\"))[0]\n    \n    # Read the .dcm metadata\n    dcm = pydicom.dcmread(dcm_path)\n      \n    # Get the pixel array\n    dcm_px = dcm.pixel_array\n\n    if dcm.PhotometricInterpretation == \"MONOCHROME1\":\n        dcm_px = np.amax(dcm_px) - dcm_px\n    \n    # Rescale the values in the 0-255 range\n    dcm_rescaled = rescale_dcm(dcm_px)\n    \n    #Histogram equalization\n    cl_array = apply_hist_equalization(dcm_rescaled)\n    \n#     std_array = (cl_array - SAMPLE_MEAN)\/ SAMPLE_STD\n#     std_array = cv2.resize(std_array, (512,512))\n    \n\n    ax[r, c].imshow(dcm_rescaled)\n    ax[r, 0].set_ylabel(\"Rescaled pixel array\")\n    ax[r, c+1].hist(dcm_rescaled.flatten(), bins = 100)\n    \n    ax[r+1, c].imshow(cl_array)\n    ax[r+1, 0].set_ylabel(\"CLAHE\")\n    ax[r+1, c+1].hist(cl_array.flatten(), bins = 100)\n    \n    \n    c = c + 2\n    if c%4 == 0:\n        c = 0\n        r = r+2","08b7fb14":"DESTINATION_RESIZED = 'resized_512_train'\nif os.path.exists(DESTINATION_RESIZED):\n    print(\"{} folder exists.\".format(DESTINATION_RESIZED))\nelse:\n    os.makedirs(DESTINATION_RESIZED)","7163a3c1":"# os.rmdir(DESTINATION_RESIZED)\n# import shutil\n# shutil.rmtree(DESTINATION_RESIZED)","c53e4167":"for idx, image in tqdm(img_ann[0:5].iterrows(), total = len(img_ann[0:5])):\n    dcm_path = glob.glob(os.path.join(TRAIN, \n                                      image.StudyInstanceUID, \n                                      \"*\",\n                                      image.id.split(\"_\")[0]+\".dcm\"))[0]\n    \n    # Read the .dcm metadata\n    dcm = pydicom.dcmread(dcm_path)\n      \n    # Get the pixel array\n    dcm_px = dcm.pixel_array\n\n    # Harmonize the images to match MONOCHROME2\n    if dcm.PhotometricInterpretation == \"MONOCHROME1\":\n        dcm_px = np.amax(dcm_px) - dcm_px\n    \n    # Rescale the values in the 0-255 range\n    dcm_rescaled = rescale_dcm(dcm_px)\n    \n    # Apply histogram equalization as a transformation step\n    cl_array = apply_hist_equalization(dcm_rescaled)\n    \n    # Standardize to 0 mean and 1 standard deviation?\n    # For this purpose, first determine the mean and standard deviation of the overall train data\n#     std_array = (cl_array - SAMPLE_MEAN)\/ SAMPLE_STD\n    \n#     # Maybe resize the images\n    resized_array = cv2.resize(cl_array, (512,512))\n\n    Image.fromarray(resized_array).save(os.path.join(DESTINATION_RESIZED, str(image.id) + \".jpg\"))","2c56e84d":"os.listdir(DESTINATION_RESIZED)","b52394cd":"!tar -czf train_images_512.tar.gz resized_512_train\n!du -h train_images_512.tar.gz","3ad7027e":"from IPython.display import FileLink\nFileLink(r'train_images_512.tar.gz')","e6cc9486":"## Sources:\n\n1. CLAHE: https:\/\/towardsdatascience.com\/clahe-and-thresholding-in-python-3bf690303e40\n2. @avinashrai for saving the transformed images","7c46f9e3":"# Visual inspection of the dcm\n\nThe chosen transformations of the raw pixel arrays are:\n- harmonize the meaning of each pixel value by chosing the baseline Photometric Interpretation;\n- scale the pixel values in the 0-255 range;\n- CLAHE for histogram equalization;\n    The purpose is trying to remove some of the noise in the images, and obtaining a better view of the X-rays. Applying histogram equalization generates an improvement in how the images look like. \n- Standardize the values to have mean 0 and unit standard deviation.","24363310":"# Data Preprocessing","59f4a347":"# Transform data"}}