{"cell_type":{"eb67c3d8":"code","d58be709":"code","d85720fa":"code","cc55992d":"code","d03a7c8b":"code","cdf7a37e":"code","b60dbee7":"code","bdbe5161":"code","ad5ea3b6":"code","76201cca":"code","a3670f35":"code","c75cf33c":"code","d9443b95":"code","d1c0a970":"code","4a7ce4c4":"code","025aeeb7":"code","e7dbed77":"code","12a382db":"code","f6ddfffb":"code","aac569ce":"code","7d57e88a":"code","fb703686":"code","328fc0ea":"code","a24e7060":"code","8ecdad3e":"code","cb3c8950":"code","2d76721d":"markdown","220b7bfb":"markdown","d5ab0f81":"markdown","2cf67051":"markdown"},"source":{"eb67c3d8":"! apt-get install --no-install-recommends git cmake build-essential libboost-dev libboost-system-dev libboost-filesystem-dev -y","d58be709":"!rm -r \/opt\/conda\/lib\/python3.6\/site-packages\/lightgbm","d85720fa":"!git clone --recursive https:\/\/github.com\/Microsoft\/LightGBM","cc55992d":"%%bash\ncd LightGBM\nrm -r build\nmkdir build\ncd build\ncmake -DUSE_GPU=1 -DOpenCL_LIBRARY=\/usr\/local\/cuda\/lib64\/libOpenCL.so -DOpenCL_INCLUDE_DIR=\/usr\/local\/cuda\/include\/ ..\nmake -j$(nproc)","d03a7c8b":"!cd LightGBM\/python-package\/;python3 setup.py install --precompile","cdf7a37e":"!mkdir -p \/etc\/OpenCL\/vendors && echo \"libnvidia-opencl.so.1\" > \/etc\/OpenCL\/vendors\/nvidia.icd\n!rm -r LightGBM","b60dbee7":"# Latest Pandas version\n#!pip install -q 'pandas==0.25' --force-reinstall#","bdbe5161":"import lightgbm as lgb","ad5ea3b6":"#model = lgb.LGBMRegressor(device_type='gpu')","76201cca":"import pandas as pd","a3670f35":"#train = pd.read_csv('..\/input\/ventilator-pressure-prediction\/train.csv')","c75cf33c":"#X_train, y_train = train.drop('pressure',axis=1) , train['pressure']","d9443b95":"#model.fit(X_train,y_train)","d1c0a970":"DEBUG = False\n\ntrain = pd.read_csv('..\/input\/ventilator-pressure-prediction\/train.csv')\ntest = pd.read_csv('..\/input\/ventilator-pressure-prediction\/test.csv')\nsubmission = pd.read_csv('..\/input\/ventilator-pressure-prediction\/sample_submission.csv')\n\nif DEBUG:\n    train = train[:80*1000]","4a7ce4c4":"#train = train.head(80000)","025aeeb7":"import numpy as np\n\ndef reduce_mem_usage(df, verbose=True):\n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    start_mem = df.memory_usage().sum() \/ 1024**2\n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)\n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n\n    end_mem = df.memory_usage().sum() \/ 1024**2\n    print('Memory usage after optimization is: {:.2f} MB'.format(end_mem))\n    print('Decreased by {:.1f}%'.format(100 * (start_mem - end_mem) \/ start_mem))\n\n    return df","e7dbed77":"def add_features(df):\n    df['area'] = df['time_step'] * df['u_in']\n    df['area'] = df.groupby('breath_id')['area'].cumsum()\n    \n    df['u_in_cumsum'] = (df['u_in']).groupby(df['breath_id']).cumsum()\n    \n    df['step_num'] = df.groupby('breath_id')['id'].cumcount()\n    \n    df['u_in_lag1'] = df.groupby('breath_id')['u_in'].shift(1)\n    df['u_out_lag1'] = df.groupby('breath_id')['u_out'].shift(1)\n    df['u_in_lag_back1'] = df.groupby('breath_id')['u_in'].shift(-1)\n    df['u_out_lag_back1'] = df.groupby('breath_id')['u_out'].shift(-1)\n    df['u_in_lag2'] = df.groupby('breath_id')['u_in'].shift(2)\n    df['u_out_lag2'] = df.groupby('breath_id')['u_out'].shift(2)\n    df['u_in_lag_back2'] = df.groupby('breath_id')['u_in'].shift(-2)\n    df['u_out_lag_back2'] = df.groupby('breath_id')['u_out'].shift(-2)\n    df['u_in_lag3'] = df.groupby('breath_id')['u_in'].shift(3)\n    df['u_out_lag3'] = df.groupby('breath_id')['u_out'].shift(3)\n    df['u_in_lag_back3'] = df.groupby('breath_id')['u_in'].shift(-3)\n    df['u_out_lag_back3'] = df.groupby('breath_id')['u_out'].shift(-3)\n    df['u_in_lag4'] = df.groupby('breath_id')['u_in'].shift(4)\n    df['u_out_lag4'] = df.groupby('breath_id')['u_out'].shift(4)\n    df['u_in_lag_back4'] = df.groupby('breath_id')['u_in'].shift(-4)\n    df['u_out_lag_back4'] = df.groupby('breath_id')['u_out'].shift(-4)\n    df['u_in_lag5'] = df.groupby('breath_id')['u_in'].shift(5)\n    df['u_out_lag5'] = df.groupby('breath_id')['u_out'].shift(5)\n    df['u_in_lag_back5'] = df.groupby('breath_id')['u_in'].shift(-5)\n    df['u_out_lag_back5'] = df.groupby('breath_id')['u_out'].shift(-5)\n    df['u_in_lag6'] = df.groupby('breath_id')['u_in'].shift(6)\n    df['u_out_lag6'] = df.groupby('breath_id')['u_out'].shift(6)\n    df['u_in_lag_back6'] = df.groupby('breath_id')['u_in'].shift(-6)\n    df['u_out_lag_back6'] = df.groupby('breath_id')['u_out'].shift(-6)\n    \n    \n    \n    df = df.fillna(0)\n    df = reduce_mem_usage(df)\n    \n    df['breath_id__u_in__max'] = df.groupby(['breath_id'])['u_in'].transform('max')\n    df['breath_id__u_out__max'] = df.groupby(['breath_id'])['u_out'].transform('max')\n    df['breath_id__u_out__first'] = df.groupby(['breath_id'])['u_out'].transform('first')\n    df['breath_id__u_out__difffirst'] = df.groupby(['breath_id'])['u_out'].transform('first') - df['u_out']\n    \n    df = df.fillna(0)\n    \n    \n    df['u_in_diff1'] = df['u_in'] - df['u_in_lag1']\n    df['u_out_diff1'] = df['u_out'] - df['u_out_lag1']\n    df['u_in_diff2'] = df['u_in'] - df['u_in_lag2']\n    df['u_out_diff2'] = df['u_out'] - df['u_out_lag2']\n    df['u_in_diff3'] = df['u_in'] - df['u_in_lag3']\n    df['u_out_diff3'] = df['u_out'] - df['u_out_lag3']\n    \n    \n    df['breath_id__u_in__diffmax'] = df.groupby(['breath_id'])['u_in'].transform('max') - df['u_in']\n    df['breath_id__u_in__diffmean'] = df.groupby(['breath_id'])['u_in'].transform('mean') - df['u_in']\n    \n    df['breath_id__u_in__first'] = df.groupby(['breath_id'])['u_in'].transform('first')\n    \n    \n    df = df.fillna(0)\n    df = reduce_mem_usage(df)\n     \n    \n    df['breath_id__u_in__diff_first'] = df.groupby(['breath_id'])['u_in'].transform('first')- df['u_in']\n    \n    df['breath_id__time__diff'] = df.groupby(['breath_id'])['time_step'].diff()\n    df['breath_id__time__diff_2step'] = df.groupby(['breath_id'])['breath_id__time__diff'].transform(lambda s: s.rolling(2).sum())\n    df['breath_id__time__diff_3step'] = df.groupby(['breath_id'])['breath_id__time__diff'].transform(lambda s: s.rolling(3).sum())#.apply(lambda x: x['breath_id__time__diff'].rolling(3).sum())\n    \n    df['breath_id__u_in__derivative'] = df['u_in_diff1'] \/ df['breath_id__time__diff']\n    df['breath_id__u_in__derivative_2step'] = df['u_in_diff2'] \/ (df['breath_id__time__diff_2step'])\n    df['breath_id__u_in__derivative_3step'] = df['u_in_diff3'] \/ (df['breath_id__time__diff_3step'])\n    \n    \n    df['breath_id__time__u_out__crossover_max'] = df.groupby(['breath_id'],group_keys=False).apply(lambda x: x.loc[x['u_out']==1,'time_step'].min())\n    df['breath_id__time__u_out__crossover_min'] = df.groupby(['breath_id'],group_keys=False).apply(lambda x: x.loc[x['u_out']==0,'time_step'].max())\n    \n    \n    df['breath_id__time__u_out__crossover_max__diff_time'] = df['time_step']-df['breath_id__time__u_out__crossover_max']\n    df['breath_id__time__u_out__crossover_min__diff_time'] = df['time_step']-df['breath_id__time__u_out__crossover_min']\n    \n    \n    df['breath_id__step_num__u_out__crossover_max'] = df.groupby(['breath_id'],group_keys=False).apply(lambda x: x.loc[x['u_out']==1,'step_num'].min())\n    df['breath_id__step_num__u_out__crossover_min'] = df.groupby(['breath_id'],group_keys=False).apply(lambda x: x.loc[x['u_out']==0,'step_num'].max())\n    \n    \n    df['breath_id__step_num__u_out__crossover_max__diff_time'] = df['step_num']-df['breath_id__step_num__u_out__crossover_max']\n    df['breath_id__step_num__u_out__crossover_min__diff_time'] = df['step_num']-df['breath_id__step_num__u_out__crossover_min']\n    \n    \n    \n    \n    \n    df['breath_id__u_in__integral'] = df.groupby(['breath_id'],group_keys=False).apply(lambda x: (x['breath_id__time__diff'] *x['u_in'] ).cumsum())\n    \n    df = df.fillna(0)\n    df = reduce_mem_usage(df)\n    \n    \n    df['u_in_diff3'] = df['u_in'] - df['u_in_lag3']\n    df['u_out_diff3'] = df['u_out'] - df['u_out_lag3']\n    df['u_in_diff4'] = df['u_in'] - df['u_in_lag4']\n    df['u_out_diff4'] = df['u_out'] - df['u_out_lag4']\n    df['cross']= df['u_in']*df['u_out']\n    df['cross2']= df['time_step']*df['u_out']\n    \n    df['R'] = df['R'].astype(str)\n    df['C'] = df['C'].astype(str)\n    df['R__C'] = df[\"R\"].astype(str) + '__' + df[\"C\"].astype(str)\n    df = pd.get_dummies(df)\n    return df\n# Add as a feature the time of the crossing (u_out becomes 1) , time since the crossing, duration of the crossing\n# distance to the max and to the min in time.\ntrain = add_features(train)\ntest = add_features(test)","12a382db":"pd.__version__","f6ddfffb":"targets = train[['pressure']].to_numpy()\ntrain.drop(['pressure', 'id', 'breath_id'], axis=1, inplace=True)\ntest = test.drop(['id', 'breath_id'], axis=1)","aac569ce":"#test = test.drop(['id', 'breath_id'], axis=1)","7d57e88a":"train = reduce_mem_usage(train)\ntest = reduce_mem_usage(test)","fb703686":"train.head()","328fc0ea":"train.shape","a24e7060":"from joblib import dump, load\nimport gc\nfrom sklearn.model_selection import KFold","8ecdad3e":"NUM_FOLDS=5","cb3c8950":"kf = KFold(n_splits=NUM_FOLDS, shuffle=True, random_state=2021)\ntest_preds = []\nfor fold, (train_idx, test_idx) in enumerate(kf.split(train, targets)):\n    print('-'*15, '>', f'Fold {fold+1}', '<', '-'*15)\n    X_train, X_valid = train.iloc[train_idx], train.iloc[test_idx]\n    y_train, y_valid = targets[train_idx], targets[test_idx]\n   \n    train_dataset=lgb.Dataset(X_train,y_train)\n    val_dataset = lgb.Dataset(X_valid,y_valid)\n    \n    del X_train, X_valid\n    del y_train, y_valid\n    params = dict(first_metric_only=True,learning_rate=0.5,n_estimators=700,num_leaves=256,\n                  min_gain_to_split=0.1,device_type='gpu',objective='huber',boosting='goss', metric = 'huber,l1')\n    model=lgb.train(params=params,train_set=train_dataset,valid_sets=[val_dataset,train_dataset],valid_names=['val','train'])\n    \n    #model = lgb.LGBMRegressor(learning_rate=0.05,n_estimators=700,num_leaves=128,min_gain_to_split=0.1,device_type='gpu',objective='regression_l1')\n    #model.fit(X_train,y_train,eval_set=[(X_train,y_train),(X_valid,y_valid)],eval_names=['train','val'],early_stopping_rounds=15)\n    \n    \n    dump(model,f'model_lgb_{fold}.joblib')\n    test_preds.append(model.predict(test))\n    del model\n    gc.collect()","2d76721d":"This kernel demonstrates a way of using LightGBM with GPU support in Kaggle kernels.\nIt has been updated from the original IEEE Fraud detection kernel to work with newer lightgbm versions.\n\n","220b7bfb":"## LightGBM GPU Installation","d5ab0f81":"### Build and re-install LightGBM with GPU support","2cf67051":"## FE"}}