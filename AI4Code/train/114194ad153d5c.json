{"cell_type":{"45f62b41":"code","1ecd0360":"code","35a950c7":"code","f519d196":"code","85082d42":"code","72958cbb":"code","a41c7595":"code","21307893":"code","88d55c75":"code","fd10fad3":"code","3a07e568":"code","3aadb2f0":"code","b1f91a1d":"code","a6c299e9":"markdown","f64c06b7":"markdown","0bcb00e4":"markdown","af8f6414":"markdown","d07959b2":"markdown","ba669f1e":"markdown","2931fdf2":"markdown","030612dc":"markdown","32660934":"markdown","723fc62e":"markdown","56d63061":"markdown","02875a8a":"markdown"},"source":{"45f62b41":"from sklearn.datasets import fetch_california_housing\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nimport tensorflow as tf","1ecd0360":"housing_datasets = fetch_california_housing()","35a950c7":"x_train_full, x_test, y_train_full, y_test = train_test_split(housing_datasets.data, housing_datasets.target)\nx_train, x_validation, y_train, y_validation = train_test_split(x_train_full, y_train_full)","f519d196":"scaler = StandardScaler()\nx_train = scaler.fit_transform(x_train)\nx_validation = scaler.fit_transform(x_validation)\nx_test = scaler.fit_transform(x_test)","85082d42":"model = tf.keras.Sequential([tf.keras.layers.Dense(30, activation = 'relu', input_shape = x_train.shape[1:]),\n                            tf.keras.layers.Dense(1)])\n","72958cbb":"model.compile(loss = tf.losses.mean_squared_error,\n             optimizer = 'sgd')","a41c7595":"hostory = model.fit(x_train, y_train, epochs=20,\n                   validation_data=(x_validation, y_validation))","21307893":"mean_squared_error_test = model.evaluate(x_test, y_test)\nx_new = x_test[:3] # New instance\ny_pred = model.predict(x_new)\ny_pred","88d55c75":"input_a = tf.keras.layers.Input(shape = [5], name = 'wide_input')\ninput_b = tf.keras.layers.Input(shape = [6], name = 'deep_input')\nhidden1 = tf.keras.layers.Dense(30, activation = 'relu')(input_b)\nhidden2 = tf.keras.layers.Dense(30, activation = 'relu')(hidden1)\nconcat = tf.keras.layers.concatenate([input_a, hidden2])\noutput = tf.keras.layers.Dense(1, name = 'output')(concat)","fd10fad3":"model = tf.keras.Model(inputs = [input_a, input_b], outputs = [output])","3a07e568":"model.compile(loss = tf.losses.mean_squared_error,\n             optimizer = tf.keras.optimizers.SGD(lr = 1e-3))","3aadb2f0":"x_train_a, x_train_b = x_train[:, :5], x_train[:, 2:]\nx_validation_a, x_validation_b = x_validation[:, :5], x_validation[:, 2:]\nx_test_a, x_test_b = x_test[:, :5], x_test[:, 2:]\nx_new_a, x_new_b = x_test_a[:3], x_test_b[:3]","b1f91a1d":"history = model.fit((x_train_a, x_train_b), y_train, epochs=20, validation_data=((x_validation_a, x_validation_b), y_validation))\nmean_squared_error_test = model.evaluate((x_test_a, x_test_b), y_test)\ny_pred = model.predict((x_new_a, x_new_b))","a6c299e9":"# Fit the Model","f64c06b7":"# Compile The Model","0bcb00e4":"Using the Sequential API to build, train, evaluate, and use a regression MLP to make\npredictions is quite similar to what we did for classification. The main differences are\nthe fact that the output layer has a single neuron (since we only want to predict a single\nvalue) and uses no activation function, and the loss function is the mean squared\nerror. Since the dataset is quite noisy, we just use a single hidden layer with fewer\nneurons than before, to avoid overfitting:","af8f6414":"# Create Sequential API model","d07959b2":"Both models are pretty close \ud83d\udcda","ba669f1e":"As you can see, the Sequential API is quite easy to use. However, although Sequen\ntial models are extremely common, it is sometimes useful to build neural networks\nwith more complex topologies, or with multiple inputs or outputs. For this purpose,\nKeras offers the Functional API.","2931fdf2":"# Build a Neural Network to Handel the California Housing Datasets problem:","030612dc":"# Functional API\n\nThe <b style=\"color:blue\"> functional API <\/b> can handle models with non-linear topology, shared layers, and even multiple inputs or outputs. The main idea is that a deep learning model is usually a directed acyclic graph (DAG) of layers. So the functional API is a way to build graphs of layers.\n\n<img src=\"https:\/\/i.stack.imgur.com\/WCess.png\" alt = \"Functional API and Sequential API\">","32660934":"# Why we use StandardScaler()\n\nStandardScaler removes the mean and scales each feature\/variable to unit variance. This operation is performed feature-wise in an independent way. StandardScaler can be influenced by outliers (if they exist in the dataset) since it involves the estimation of the empirical mean and standard deviation of each feature.","723fc62e":"# <b style=\"color:blue\">MultiLayer Perceptron<\/b>\nA multilayer perceptron is a class of feedforward artificial neural network. The term MLP is used ambiguously, sometimes loosely to any feedforward ANN, sometimes strictly to refer to networks composed of multiple layers of perceptrons.\n\n<img src=\"https:\/\/www.researchgate.net\/profile\/Dominique_Guerillot3\/publication\/314106922\/figure\/fig11\/AS:653106945724416@1532724238105\/Example-of-multilayer-perceptron-with-two-hidden-layers.png\" alt = \"MLP\">","56d63061":"# Building Complex Models Using The Functional API","02875a8a":"# Test the model"}}