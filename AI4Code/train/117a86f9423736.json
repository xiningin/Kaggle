{"cell_type":{"5d24cc09":"code","8e3b37a9":"code","e4293b51":"code","c2c643fb":"code","6f3fd60b":"code","72dcf374":"code","26fddd88":"code","022da8ac":"code","ccf9c76c":"code","411bd19d":"code","68815338":"code","c3780f6a":"code","2617d29e":"code","a6f9dfdd":"markdown","ea47a220":"markdown","46c4fbb8":"markdown","814a14f4":"markdown","ae91cf9a":"markdown","e8bd01fa":"markdown","ab94b164":"markdown","b64eac0a":"markdown","25a2e987":"markdown","0e86f0ee":"markdown","a4ce3855":"markdown","9c6cf43d":"markdown","cabd4845":"markdown","295020b2":"markdown","08430561":"markdown"},"source":{"5d24cc09":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport random\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","8e3b37a9":"deck = 4 * ([str(i) for i in range(2, 11)] + ['J', 'Q', 'K', 'A'])\n\nprint(deck)","e4293b51":"global_cards_count = 0\ndebug = 0","c2c643fb":"def shuffle_cards(shoe_size=8):\n    \"\"\"\n    Return a 'shoe' with 'shoe_size' decks, shuffled.\n    \n    In casinos, the dealer uses several decks (usually 6 to 8).\n    We can change this later to check how this affects the odds.\n    \"\"\"\n    global global_cards_count\n    \n    new_shoe = shoe_size * deck\n    random.shuffle(new_shoe)\n    \n    # NEW - Whenever the shoe is shuffled, global count is reset\n    global_cards_count = 0\n    \n    return new_shoe\n\n\ndef hand_value(hand):\n    value = 0    \n    num_aces = sum([i == 'A' for i in hand])\n    \n    for card in hand:\n        if card.isnumeric():\n            value += int(card)\n        elif card in ['J', 'Q', 'K']:\n            value += 10\n        else: # Aces are treated as 1 at first; later they can be \"upgraded\"\n            value += 1\n    \n    if num_aces and (value <= 11):\n        value += 10 # Ace value = 11\n        \n    return value\n    ","6f3fd60b":"def card_count_value(card): # return a single card's value for counting\n    if card in ['2', '3', '4', '5', '6']:\n        return 1\n    elif card in ['7', '8', '9']:\n        return 0\n    else:\n        return -1\n    \ndef hand_count_value(hand): # return a hand's value for counting\n    value = 0\n    \n    for card in hand:\n        value += card_count_value(card)\n        \n    #print(hand, value)\n        \n    return value\n","72dcf374":"def dealer_action(player_hand, dealer_hand):\n    if hand_value(dealer_hand) < 17:\n        action = 'HIT'\n    else:\n        action = 'STAND'\n        \n    #print('Dealer ', action)\n    return action\n","26fddd88":"table_soft_totals = [ # use when player hand has at least one ace\n    # 0   1   2   3   4   5   6   7   8   9   10  A\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #0\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #1\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #2\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #3\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #4\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #5\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #6\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #7\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #8\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #9\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #10\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #11\n    [' ',' ','H','H','H','H','H','H','H','H','H','H'], #12\n    [' ',' ','H','H','H','D','D','H','H','H','H','H'], #13\n    [' ',' ','H','H','H','D','D','H','H','H','H','H'], #14\n    [' ',' ','H','H','D','D','D','H','H','H','H','H'], #15\n    [' ',' ','H','H','D','D','D','H','H','H','H','H'], #16\n    [' ',' ','H','D','D','D','D','H','H','H','H','H'], #17\n    [' ',' ','D','D','D','D','D','S','S','H','H','H'], #18\n    [' ',' ','S','S','S','S','D','S','S','S','S','S'], #19\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #20\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #21\n]    \n\ntable_hard_totals = [ # use when there are no aces\n    # 0   1   2   3   4   5   6   7   8   9   10  A\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #0\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #1\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #2\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #3\n    [' ',' ','H','H','H','H','H','H','H','H','H','H'], #4\n    [' ',' ','H','H','H','H','H','H','H','H','H','H'], #5\n    [' ',' ','H','H','H','H','H','H','H','H','H','H'], #6\n    [' ',' ','H','H','H','H','H','H','H','H','H','H'], #7\n    [' ',' ','H','H','H','H','H','H','H','H','H','H'], #8\n    [' ',' ','H','D','D','D','D','H','H','H','H','H'], #9\n    [' ',' ','D','D','D','D','D','D','D','D','H','H'], #10\n    [' ',' ','D','D','D','D','D','D','D','D','D','D'], #11\n    [' ',' ','H','H','S','S','S','H','H','H','H','H'], #12\n    [' ',' ','S','S','S','S','S','H','H','H','H','H'], #13\n    [' ',' ','S','S','S','S','S','H','H','H','H','H'], #14\n    [' ',' ','S','S','S','S','S','H','H','H','H','H'], #15\n    [' ',' ','S','S','S','S','S','H','H','H','H','H'], #16\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #17\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #18\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #19\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #20\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #21\n]    \n\ntable_splits = [ # used to decide if will split or not\n    # 0   1   2   3   4   5   6   7   8   9   10  A\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #0\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #1\n    [' ',' ','Y','Y','Y','Y','Y','Y','N','N','N','N'], #2\n    [' ',' ','Y','Y','Y','Y','Y','Y','N','N','N','N'], #3\n    [' ',' ','N','N','N','Y','Y','N','N','N','N','N'], #4\n    [' ',' ','N','N','N','N','N','N','N','N','N','N'], #5\n    [' ',' ','Y','Y','Y','Y','Y','N','N','N','N','N'], #6\n    [' ',' ','Y','Y','Y','Y','Y','Y','N','N','N','N'], #7\n    [' ',' ','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y'], #8\n    [' ',' ','Y','Y','Y','Y','Y','N','Y','Y','N','N'], #9\n    [' ',' ','N','N','N','N','N','N','N','N','N','N'], #10\n    [' ',' ','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y'], #11 (A)\n]\n\n# I could have used the codes directly, but when I decided to use the tables I had already written\n# most of the action functions. Creating a dictionary was easier than rewriting the code.\naction = {'H':'HIT', 'S':'STAND', 'D':'DOUBLE'}","022da8ac":"def can_split(hand):\n    return (len(hand) == 2) and (hand_value([hand[0]]) == hand_value([hand[1]]))\n\ndef player_action_full(player_hand, dealer_hand):\n    # Now with EVERYTHING!!!\n    player_aces = sum([i == 'A' for i in player_hand])\n\n    player_total = hand_value(player_hand)\n    dealer_total = hand_value(dealer_hand)\n\n    if can_split(player_hand):\n        card = hand_value([player_hand[0]])\n        if table_splits[card][dealer_total] == 'Y':\n            return 'SPLIT'\n    \n    if player_aces == 1:\n        result = action[table_soft_totals[player_total][dealer_total]]\n    else:\n        result = action[table_hard_totals[player_total][dealer_total]]\n    return result\n","ccf9c76c":"def simulate_one_game (shoe, bet, action_function):\n    # since we will consider splits and double-downs the concept of wins\/losses does not apply anymore.\n    # instead, we will return the final balance.\n    \n    global global_cards_count\n    global debug\n    \n    player_initial_hand = []\n    dealer_hand = []\n    \n    # deal initial cards\n    player_initial_hand.append(shoe.pop())\n    player_initial_hand.append(shoe.pop())\n        \n    dealer_hand.append(shoe.pop())\n\n    # to handle splits we will have to consider a list of player hands.\n    # everytime a SPLIT happens this list increases\n    hands_list = [player_initial_hand]\n    \n    # dealer\u00b4s actions will only happen once, so we need to keep the final hand states to compare\n    final_hands = []\n    bets = []\n    \n    # choose which function to use. Will allow us to compare different strategies\n    player_action = action_function\n\n    all_hands_busted = 1\n    while len(hands_list) > 0:\n        current_bet = bet\n        player_hand = hands_list.pop()\n        \n        # run player actions\n        # first test: should I split?\n        if player_action(player_hand, dealer_hand) == 'SPLIT':\n            #print('SPLIT')\n            \n            # create 2 new hands and append to hands list\n            hand_1 = [player_hand[0]]\n            hand_1.append(shoe.pop())\n            \n            hand_2 = [player_hand[1]]\n            hand_2.append(shoe.pop())\n            \n            hands_list.append(hand_1)\n            hands_list.append(hand_2)\n            \n            continue # start handling hands list again\n            \n        # no split here, so let\u00b4s process until player stands or bust\n        while (hand_value(player_hand) <= 21) and (player_action(player_hand, dealer_hand) != 'STAND'):\n            action = player_action(player_hand, dealer_hand)\n            \n            if (action == 'HIT'):\n                player_hand.append(shoe.pop())\n            elif (action == 'DOUBLE'):\n                # doubles bet and draws last card\n                current_bet = bet * 2\n                player_hand.append(shoe.pop())\n                break\n        \n        # ended the loop, so include hand and bet in final lists\n        final_hands.append(player_hand)\n        bets.append(current_bet)\n        \n        # if at least one hand didn't bust the dealer will have to draw cards\n        if hand_value(player_hand) <= 21:\n            all_hands_busted = 0\n                \n    # run dealer actions\n    while (dealer_action(player_hand, dealer_hand) != 'STAND'):\n        dealer_hand.append(shoe.pop())\n        if all_hands_busted:\n            break\n\n    if debug:\n        print(final_hands, dealer_hand, bets)\n        \n    # evaluate results\n    final_balance = 0\n    \n    for i, hand in enumerate(final_hands):\n        current_bet = bets[i]\n        \n        if hand_value(hand) > 21: # player busted\n            if debug: print('Player busted!')\n            final_balance -= current_bet\n        elif hand_value(dealer_hand) > 21:\n            if debug: print('Dealer busted!')\n            \n            if hand_value(hand) == 21 and len(hand) == 2:\n                if debug: print('Blackjack!')\n                final_balance += 1.5 * current_bet\n            else:                \n                final_balance += current_bet\n                \n        elif hand_value(dealer_hand) == hand_value(hand):\n            if debug: print ('Draw')\n            # balance stays the same (do nothing)\n        \n        elif hand_value(dealer_hand) < hand_value(hand):\n            if hand_value(hand) == 21 and len(hand) == 2:\n                if debug: print('Blackjack!')\n                final_balance += 1.5 * current_bet\n            else:\n                if debug: print('Player won!')\n                final_balance += current_bet\n        else:\n            if debug: print('Player lost!')\n            final_balance -= current_bet\n            \n        # NEW - add each hand's value to global count\n        global_cards_count += hand_count_value(hand)\n    \n    # NEW - count dealer's hand\n    global_cards_count += hand_count_value(dealer_hand)\n    \n    return final_balance    ","411bd19d":"def simulate_games_counting(n_games, action_function, shoe_size, count=True):\n    global global_cards_count\n    global debug\n    \n    n_decks = shoe_size\n    shoe = shuffle_cards(n_decks)\n\n    reshuffle_rate = 0.25 # when shoe hits this percentage dealer will reshuffle.\n    reshuffle_point = len(shoe) * reshuffle_rate \n    \n    balance = 0\n\n    for i in range(n_games):\n        shoe_left = len(shoe)\/52\n        true_count = round(global_cards_count \/ shoe_left, 0)\n        \n        if count:\n            bet_value = calc_bet_value(global_cards_count, shoe)\n        else:\n            bet_value = 1\n\n        if debug:\n            print('\\n\\nGAME ', i)\n            print('current count: ', global_cards_count)\n            print('cards left:', len(shoe))\n            print('true count:', true_count)\n            print('bet:', bet_value)\n        \n        balance += simulate_one_game(shoe, bet_value, action_function)\n\n        if debug:\n            print('Current balance: ',balance)\n\n        if len(shoe) <= reshuffle_point:\n            #print('\\n\\nShuffling cards...\\n\\n')\n            shoe = shuffle_cards(n_decks)\n    \n    return balance","68815338":"def calc_bet_value(current_count, shoe): # return the amount you should bet given the global count\n    \n    true_count = round(current_count \/ (len(shoe) \/ 52),0)\n    \n    # Using a range between 1 and 12, depending on true count\n    if true_count <= 1:\n        return 1\n    elif true_count == 2:\n        return 2\n    elif true_count == 3:\n        return 4\n    elif true_count == 4:\n        return 8\n    else:\n        return 12","c3780f6a":"def calc_win_rate(balance, n_games):\n    # calculates the equivalent win rate from the final balance.\n    win_ratio = (balance + n_games) \/ 2 \/ n_games\n    \n    return win_ratio","2617d29e":"# testing\nn_games = 1000000\n\ndebug = 0\n\n# First simulation without counting\nvalue_no_counting = simulate_games_counting(n_games, player_action_full, 6, False)\nprint('No counting:\\t{}%'.format(calc_win_rate(value_no_counting, n_games)*100))\n\n# Then make simulations with different number of decks\nvalue_2_decks = simulate_games_counting(n_games, player_action_full, 2)\nprint('2 decks:\\t{}%'.format(calc_win_rate(value_2_decks, n_games)*100))\n\nvalue_3_decks = simulate_games_counting(n_games, player_action_full, 3)\nprint('3 decks:\\t{}%'.format(calc_win_rate(value_3_decks, n_games)*100))\n\nvalue_4_decks = simulate_games_counting(n_games, player_action_full, 4)\nprint('4 decks:\\t{}%'.format(calc_win_rate(value_4_decks, n_games)*100))\n\nvalue_6_decks = simulate_games_counting(n_games, player_action_full, 6)\nprint('6 decks:\\t{}%'.format(calc_win_rate(value_6_decks, n_games)*100))","a6f9dfdd":"One of the key items of the cards counting strategy is dynamic betting. In short, you count the cards to know when the odds are in your favor, and bet big when that happens.\n\nThe function below implemented one of many strategies I found online.","ea47a220":"I decided to improve [my notebook on the Blackjack Microchallenge](https:\/\/www.kaggle.com\/tauffer\/blackjack-advanced-techiniques) to include CARDS COUNTING!\n\nLet's see how much we could take from the casinos...\n\nTo do that I had to implement the whole game, so I could include some new actions in the original problem - not only the cards counting, but also splits, double-downs and the ability to change the bet values, which is mandatory for this technique to work.\n\nMost of the code and text are very similar to my previous notebook; whenever I introduce something new for the cards counting I will highlight it.","46c4fbb8":"Now the simulations.\nThe function below does most of the heavy lifting; it simulates one game, receiving the current shoe and the action function to be used as parameters.\n\nI also included a parameter to define the bet value, since dynamic betting is mandatory to implement cards counting.","814a14f4":"**CONCLUSION**\n\nEven with the \"perfect strategy\", without counting the house still has a 0.5% edge.\n\nBut when we implemented counting...\nWE BROKE THE BANK!!!\n\nEven for shoes with more decks, we were able to consistently get positive results.","ae91cf9a":"Next function calls simulate_one_game several times, reshuffling the shoe everytime it gets to a defined threshold.\nI also included the shoe size as a parameter to see its impact in the overall result. Lower shoe sizes should increase the player's odds significantly.\n\nIf I want to disable cards counting I just have to include \"count\" parameter as False","e8bd01fa":"The original exercise was supposed to be solved using several conditional statements. But for more complex strategies I found it easier to use lookup tables.\n\nThe ones I used below can be found [here](http:\/\/www.blackjackapprenticeship.com\/blackjack-strategy-charts\/).\n\nI created them with paddings to make it easier to lookup.","ab94b164":"With everything ready, now we run the simulations.\nI ran several games with different shoe sizes to see how it affects the final results.\n\n**TIP** If you want to see the simulator running just change the \"debug\" variable in the code below. (I suggest also changing the n_games variable to something smaller).\n","b64eac0a":"**NEW** Created a new global variable to hold current count","25a2e987":"Even though the win rate doesn't make sense anymore, we need to create a way to compare it to the Microchallenge. So I created this function to calculate the equivalent rate, based on the final balance.","0e86f0ee":"**NEXT STEPS**\n\n* Double check the code for errors\n* Test different strategies (based on other tables like the ones I used)\n* Data Visualization (I still didn't get to that lesson... :) )\n\nPlease share your thoughts... any help is appreciated!","a4ce3855":"**NEW** Cards counting is pretty straigthforward: (there are some very good explanations online, like [this](https:\/\/www.888casino.com\/blog\/blackjack-strategy-guide\/blackjack-card-counting), [this](https:\/\/the-datascientist.com\/blackjack-crash-course-how-to-count-cards\/) and [this](https:\/\/medium.com\/@macaugamblinghk\/how-to-win-at-blackjack-card-counting-9b04d3682e7)).\n\n1. Each card has a value (-1 for 2 to 6, 0 for 7 to 9 or 1 to Aces and tens)\n1. Whenever a card is drawn, we add its value to a global count\n1. The higher the global count, the higher should be your bet\n\nBelow we created some helper functions for that.","9c6cf43d":"For the dealer, we will use the same strategy as listed in the Microchallenge. This will make it easy to compare if the complex model works better or not.\nI am including the player_hand as a parameter because we can change the dealer\u00b4s action depending on that later (e.g.: stop if hand already beats the player's hand)\n\nThe rules for the dealer are:\n- The player is dealt two face-up cards. The dealer is dealt one face-up card.\n(...)\n- The dealer then deals additional cards to himself until either:\n    - The sum of the dealer's cards exceeds 21, in which case the player wins the round, or\n    - The sum of the dealer's cards is greater than or equal to 17.","cabd4845":"Create a single deck. Most of the casinos use 6 to 8 decks in a Blackjack table ([they call it a shoe](http:\/\/https:\/\/en.wikipedia.org\/wiki\/Shoe_(cards)); we will see later if this increases the house odds.","295020b2":"Below I created some additional helper functions.","08430561":"In my previous notebook I wanted to compare the difference between using just the standard STAY\/HIT actions and more advanced techniques, like SPLITs and DOUBLE DOWNs. To make it easier I decided to pass the different functions as a parameter to the simulator.\n\nSince this is not the point here I am using just the final function, with everything in it. If you want to see the other functions in action or the explanations on what those are you can check it [here](https:\/\/www.kaggle.com\/tauffer\/blackjack-advanced-techiniques)."}}