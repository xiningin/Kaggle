{"cell_type":{"c3203ad5":"code","e603a7d0":"code","c812dfd1":"code","61bef6d9":"code","3801abcb":"markdown"},"source":{"c3203ad5":"import random\nimport numpy as np\nimport pandas as pd\nfrom collections import Counter, defaultdict","e603a7d0":"def stratified_group_k_fold(X, y, groups, k, seed=None):\n    labels_num = np.max(y) + 1\n    y_counts_per_group = defaultdict(lambda: np.zeros(labels_num))\n    y_distr = Counter()\n    for label, g in zip(y, groups):\n        y_counts_per_group[g][label] += 1\n        y_distr[label] += 1\n\n    y_counts_per_fold = defaultdict(lambda: np.zeros(labels_num))\n    groups_per_fold = defaultdict(set)\n\n    def eval_y_counts_per_fold(y_counts, fold):\n        y_counts_per_fold[fold] += y_counts\n        std_per_label = []\n        for label in range(labels_num):\n            label_std = np.std([y_counts_per_fold[i][label] \/ y_distr[label] for i in range(k)])\n            std_per_label.append(label_std)\n        y_counts_per_fold[fold] -= y_counts\n        return np.mean(std_per_label)\n    \n    groups_and_y_counts = list(y_counts_per_group.items())\n    random.Random(seed).shuffle(groups_and_y_counts)\n\n    for g, y_counts in sorted(groups_and_y_counts, key=lambda x: -np.std(x[1])):\n        best_fold = None\n        min_eval = None\n        for i in range(k):\n            fold_eval = eval_y_counts_per_fold(y_counts, i)\n            if min_eval is None or fold_eval < min_eval:\n                min_eval = fold_eval\n                best_fold = i\n        y_counts_per_fold[best_fold] += y_counts\n        groups_per_fold[best_fold].add(g)\n\n    all_groups = set(groups)\n    for i in range(k):\n        train_groups = all_groups - groups_per_fold[i]\n        test_groups = groups_per_fold[i]\n\n        train_indices = [i for i, g in enumerate(groups) if g in train_groups]\n        test_indices = [i for i, g in enumerate(groups) if g in test_groups]\n\n        yield train_indices, test_indices","c812dfd1":"train_x = pd.read_csv('..\/input\/train\/train.csv')\ntrain_y = train_x.AdoptionSpeed.values\ngroups = np.array(train_x.RescuerID.values)\n\ndef get_distribution(y_vals):\n        y_distr = Counter(y_vals)\n        y_vals_sum = sum(y_distr.values())\n        return [f'{y_distr[i] \/ y_vals_sum:.2%}' for i in range(np.max(y_vals) + 1)]","61bef6d9":"distrs = [get_distribution(train_y)]\nindex = ['training set']\n\nfor fold_ind, (dev_ind, val_ind) in enumerate(stratified_group_k_fold(train_x, train_y, groups, k=5)):\n    dev_y, val_y = train_y[dev_ind], train_y[val_ind]\n    dev_groups, val_groups = groups[dev_ind], groups[val_ind]\n    \n    assert len(set(dev_groups) & set(val_groups)) == 0\n    \n    distrs.append(get_distribution(dev_y))\n    index.append(f'development set - fold {fold_ind}')\n    distrs.append(get_distribution(val_y))\n    index.append(f'validation set - fold {fold_ind}')\n\ndisplay('Distribution per class:')\npd.DataFrame(distrs, index=index, columns=[f'Label {l}' for l in range(np.max(train_y) + 1)])","3801abcb":"# Stratified Group k-Fold Cross-Validation\n\n<div class=\"alert alert-block alert-success\">\n    <p><b>Just for the record!<\/b><\/p><p>The below method is now implemented in scikit-learn since the release 0.24.2 (see the PR <a href=\"https:\/\/github.com\/scikit-learn\/scikit-learn\/pull\/18649\">scikit-learn#18649<\/a>) \ud83c\udf89.<\/p>\n    <p>The documentation can be found here: <a href=\"https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.model_selection.StratifiedGroupKFold.html\">sklearn.model_selection.StratifiedGroupKFold<\/a>.<\/p>\n<\/div>\n\nProvides train\/test indices to split data into train\/test sets. Data are splitted in a way to fulfil the following criteria:\n * Folds are made by preserving the percentage of samples for each class.\n * The same group will not appear in two different folds."}}