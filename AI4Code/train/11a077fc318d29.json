{"cell_type":{"fa4da089":"code","430541c4":"code","f8023397":"code","d819d864":"code","a4fb10b9":"code","c85a0eb8":"code","e3dd9bac":"code","095c69f9":"code","c30975b6":"code","fbcda134":"code","efa38927":"code","739db308":"code","d4a05f71":"code","e495b075":"code","33d51d62":"code","c235d055":"code","5bb55d01":"code","7d04bf8d":"code","32332186":"code","745f2908":"markdown"},"source":{"fa4da089":"!pip install sentence-transformers","430541c4":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom sentence_transformers import SentenceTransformer\nimport random\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\nfrom sklearn.preprocessing import MinMaxScaler\nimport re\nimport os\nimport pprint\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","f8023397":"# download Roberta stsb model for sentence embeddings \n\nmodel = SentenceTransformer(\"sentence-transformers\/stsb-roberta-base-v2\")","d819d864":"# Download IMDB movie data\ndata = pd.read_csv(\"\/kaggle\/input\/tmdb-movie-metadata\/tmdb_5000_movies.csv\")\ndata = data[(~data['overview'].isna()) & (data.overview.str.len() > 30)].reset_index(drop=True)\nprint(data.shape)\ndata.head(5)\n","a4fb10b9":"# Processing data to extract Genre and Release decade\n\ndata[\"release_year\"] = data.release_date.fillna(2000).apply(lambda x: int(str(x)[:4]) )\ndata[\"genre_extracted\"] = data.genres.apply(lambda x: \" \".join(re.findall(\"name\\\": \\\"(\\w+)\\\"\",x) ))\n","c85a0eb8":"# Save to dict at index level for fast retrieval\nmovies = {}\nfor i, d in enumerate(data[['original_title','overview','release_date','genre_extracted']].values):\n    #print(d)\n    movies[i] = {'name': d[0],\n                 'desc':d[1],\n                 'date':d[2],\n                 'genre':d[3]}\nmovies[0]","e3dd9bac":"# Select list of movies based on certain features (budget, release date, popularity) for evaluation later\nlst_movies = []\nlst_movies.extend(data.sort_values(\"release_date\").index[:2].tolist())\nlst_movies.extend(data.sort_values(\"release_date\", ascending=False).index[:2].tolist())\nlst_movies.extend(data.sort_values(\"budget\").index[:2].tolist())\nlst_movies.extend(data.sort_values(\"budget\", ascending=False).index[:2].tolist())\nlst_movies.extend(data.sort_values(\"popularity\").index[:2].tolist())\nlst_movies.extend(data.sort_values(\"popularity\", ascending=False).index[:2].tolist())\nlst_movies.extend(data.sort_values(\"vote_count\").index[:2].tolist())\nlst_movies.extend(data.sort_values(\"vote_count\", ascending=False).index[:2].tolist())\n\n[movies[x][\"name\"] for x in lst_movies]","095c69f9":"# Release date encoding - Give more weight to recent movies \n\nprint(data[\"release_year\"].value_counts())\ndata[\"release_year_minmax\"] = MinMaxScaler().fit_transform(data[\"release_year\"].values.reshape(-1, 1))\ndata[\"release_year_minmax\"].value_counts()\n","c30975b6":"# Release date is given priority based on release date - so just repeat across rows\n\nrelease_year_sim = np.repeat(data[\"release_year_minmax\"].values.reshape(1,-1),\n                              repeats=len(data), axis=0)\nrelease_year_sim","fbcda134":"# Genre encoding \n\ncf = CountVectorizer()\ngenre_matrix = cf.fit_transform(data[\"genre_extracted\"].tolist()).todense()\nprint(genre_matrix.shape)\ncf.vocabulary_\n#data[[\"row\",\"genre_extracted\"]].explode(\"genre_extracted\").pivot(columns=\"genre_extracted\").reset_index(drop=True)","efa38927":"# Similarity using genre encoding\ngenre_matrix_sim = cosine_similarity(genre_matrix)\ngenre_matrix_sim","739db308":"# Sentence transformer encoding using movie description\n\nmovie_encoding = model.encode(data.overview.astype('str').tolist(), normalize_embeddings=True)","d4a05f71":"# Similarity using movie description encoding\n\nmovies_sim = np.dot(movie_encoding, movie_encoding.T)\n","e495b075":"# 3 approaches with different weights to each\n\n# Most similar movies using movie description\nsim1 = movies_sim.argsort(axis=1)[:,::-1][:,:4]\n\n# Most similar movies using movie description + genre encoding\ncombined_sim2 = movies_sim*0.75 + genre_matrix_sim*0.25\nsim2 = combined_sim2.argsort(axis=1)[:,::-1][:,:4]\n\n# Most similar movies using movie description + genre encoding + prioritize by release date\ncombined_sim3 = movies_sim*0.5 + genre_matrix_sim*0.25 + release_year_sim*0.25\nsim3 = combined_sim3.argsort(axis=1)[:,::-1][:,:4]\n","33d51d62":"min_sim_threshold = 0.45\n\nfor id_ in lst_movies:\n    print(\"*\"*40 + \" \" + movies[id_]['name'] + \" \"+\"*\"*40 )\n    print(\"Description: \" + str(movies[id_]['desc']))\n    print(\"Release date: \" + str(movies[id_]['date']))\n    print(\"Genre: \" + str(movies[id_]['genre']))\n    \n    print(\"\\n\" + \"*\"*10 + \" \" + \"Similar movie using movie description ONLY\")\n    for x in sim1[id_,:]:\n        #print(movies_sim[id_,x])\n        if (movies_sim[id_,x] > min_sim_threshold) & (id_ != x):\n            print(\" - \" + movies[x]['name'])\n            print(\"   - \" + str(movies[x]['desc']))\n            print(\"   - \" + str(movies[x]['date']))\n            print(\"   - \" + str(movies[x]['genre']))\n            print(\"\\n\")\n    \n    print(\"\\n\" + \"*\"*10 + \" \" + \"Similar movie using movie description + Genre\")\n    for x in sim2[id_,:]:\n        #print(movies_sim[id_,x])\n        if (combined_sim2[id_,x] > min_sim_threshold) & (id_ != x):\n            print(\" - \" + movies[x]['name'])\n            print(\"   - \" + str(movies[x]['desc']))\n            print(\"   - \" + str(movies[x]['date']))\n            print(\"   - \" + str(movies[x]['genre']))\n            print(\"\\n\")\n    \n    print(\"\\n\" + \"*\"*10 + \" \" + \"Similar movie using movie description + Genre + release date (latest movie have high priority)\")\n    for x in sim3[id_,:]:\n        #print(movies_sim[id_,x])\n        if (combined_sim3[id_,x] > min_sim_threshold) & (id_ != x):\n            print(\" - \" + movies[x]['name'])\n            print(\"   - \" + str(movies[x]['desc']))\n            print(\"   - \" + str(movies[x]['date']))\n            print(\"   - \" + str(movies[x]['genre']))\n            print(\"\\n\")\n    ","c235d055":"def recommendation(user_movies:list, weight_movie_desc:int, weight_genre:int, weight_release_yr:int):\n    \n    print(\"Movies seen: \")\n    for o in user_movies:\n        print(\" \" +movies[o]['name'])\n    # Most similar movies using movie description + genre encoding + prioritize by release date\n    combined_sim_ = (movies_sim*weight_movie_desc + genre_matrix_sim*weight_genre + release_year_sim*weight_release_yr ) \/ (weight_movie_desc+weight_genre+weight_release_yr)\n    combined_sim_max = combined_sim_[user_movies,:].mean(axis=0).argsort(axis=0)[-1*(len(user_movies)+3):]\n    print(\"\\nRecommendations: \")\n    for m in combined_sim_max:\n        if m not in user_movies:\n            pprint.pprint(movies[m])\n","5bb55d01":"recommendation(user_movies = [2,3], weight_movie_desc=0.5, weight_genre=0.3, weight_release_yr=0.2)","7d04bf8d":"recommendation(user_movies = [2,3], weight_movie_desc=0.2, weight_genre=0.3, weight_release_yr=0.5)","32332186":"recommendation(user_movies = [2000,3000,900], weight_movie_desc=0.7, weight_genre=0.3, weight_release_yr=0.0)","745f2908":"# Movie recommendations using transformer embeddings \n## Find similar movies based on movie description\n## Find similar movies based on movie description + Genre features\n## Find similar movies based on movie description + Genre features + prioritize by release date\n\n\n## Contents: \n### - Similarity matrix for each type\n### - Demonstration\n### - Recommendation function based on user seen movies"}}