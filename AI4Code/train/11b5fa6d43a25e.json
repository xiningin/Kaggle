{"cell_type":{"d80ae1f0":"code","dedf7e12":"code","18fb86b1":"code","13afd1ae":"code","1370c39f":"code","61bc705a":"code","ba5976b2":"code","70a1ab37":"code","1011e38a":"code","ccc5895d":"code","5aaeee86":"code","69c29e26":"code","e8201ed0":"code","a3dd3f77":"code","1b07fd91":"code","74a410ea":"code","135bae06":"code","3cb92bcd":"code","150244fb":"code","c82c3b48":"markdown","bbbb0686":"markdown","97880a1a":"markdown","8cbfb27c":"markdown","54997b42":"markdown","7576066a":"markdown","19817a5d":"markdown","e3bd188c":"markdown","e388aaea":"markdown","f53fa410":"markdown","5b1b90c7":"markdown","5f776501":"markdown","98e605f6":"markdown","c4403a70":"markdown","1f0e594b":"markdown","41696aee":"markdown","459312ea":"markdown","f8321933":"markdown","8dce2c4c":"markdown","db6198d2":"markdown","55e543bf":"markdown","403e9d7c":"markdown","ca3e437d":"markdown"},"source":{"d80ae1f0":"import json\nfrom pathlib import Path\n\nsample_data_directory = Path(\"\/kaggle\/input\/read-your-network-of-friends-in-facebook-examples\/\")\nfilename = sample_data_directory.joinpath(\"my_anonymized_network.json\")\n\nwith open(filename, \"r\", encoding=\"utf-8\") as file:\n    network = json.load(file)","dedf7e12":"import networkx as nx\n\n\n\ngraph = nx.Graph()\ngraph.add_nodes_from([\n    (\n        friend[\"user_id\"],\n        dict(name=friend[\"name\"], gender=friend[\"gender\"])\n    ) \n    for friend in network[\"friend_list\"]\n])","18fb86b1":"edges = []\nfor friend_id, mutual_friends in network[\"mutual_friends\"].items():\n    edges += [\n        (\n            friend_id,\n            mutual_friend[\"user_id\"]\n        ) for mutual_friend in mutual_friends\n    ]\n    \ngraph.add_edges_from(edges)","13afd1ae":"nx.draw(\n    graph,\n    node_size=45\n)","1370c39f":"biggest_component_nodes = max(nx.connected_components(graph), key=len)\ngraph = graph.subgraph(biggest_component_nodes)","61bc705a":"nx.draw(\n    graph,\n    node_size=45\n)","ba5976b2":"from matplotlib import cm\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n\ndef draw_graph(graph, node_scores=None, node_communities=None, label_proportion=0.1):\n    \n    def communities_to_node_community_map():\n        node_community_map = {}\n        for i, community in enumerate(node_communities, start=1):\n            node_community_map.update({node: i for node in community})\n\n        return pd.Series(node_community_map).reindex(graph.nodes).fillna(0).astype(\"int64\")\n    \n    def get_random_labels(p):\n        labels = {}\n        for userid, name in nx.get_node_attributes(graph, 'name').items():\n            if np.random.binomial(1, p) == 1:\n                labels[userid] = name\n\n        return labels\n\n    cmap = cm.get_cmap(\"Paired\")\n    num_colors = len(cmap.colors)\n    \n    fig, ax = plt.subplots(1, 1, figsize=(20, 20))\n\n    color = None\n\n    if node_scores is not None:\n        node_scores_series = pd.Series(node_scores).loc[list(self.graph.nodes)]\n        threshold_quantile = 1 - label_proportion\n        nodes_with_score_higher_than_threshold = node_scores_series[\n            node_scores_series >= node_scores_series.quantile(threshold_quantile)\n        ].index\n        labels = {\n            node: graph.nodes[node][\"name\"]\n            for node in nodes_with_score_higher_than_threshold\n        }\n        color = node_scores_series\n    else:\n        labels = get_random_labels(label_proportion)\n        if node_communities is not None:\n            node_community_map = communities_to_node_community_map()\n            color = cmap(node_community_map.values % num_colors)\n\n    return nx.draw(\n        graph,\n        pos=node_positions,\n        node_size=45,\n        node_color=color,\n        edge_color=(0, 0, 0, 0.1),\n        ax=ax,\n        with_labels=True,\n        labels=labels\n    )\n\nnode_positions = nx.spring_layout(graph, seed=0)","70a1ab37":"draw_graph(graph, label_proportion=0)","1011e38a":"from IPython import display\n\ndisplay.Image(sample_data_directory.joinpath(\"VisualCommunities.png\"))","ccc5895d":"import itertools\nfrom networkx.algorithms.community.centrality import girvan_newman\n\n\ncommunity_divisions_generator = girvan_newman(graph)\n\nmax_number_of_communities = 10\n\ncommunity_divisions = {\n    num_communities: communities\n    for num_communities, communities in enumerate(\n        itertools.islice(community_divisions_generator, max_number_of_communities - 1),\n        start=2\n    )\n}","5aaeee86":"num_communities = 10\ndraw_graph(graph, node_communities=community_divisions[num_communities], label_proportion=0)","69c29e26":"from networkx.algorithms.community.asyn_fluid import asyn_fluidc\n\ncommunity_division = list(asyn_fluidc(graph, 6))\ndraw_graph(graph, node_communities=community_division, label_proportion=0)","e8201ed0":"def get_friends(node, graph):\n    return pd.Series([friend for _, friend in graph.edges(node)]).unique()\n\n\ndef communities_to_node_community_map(graph, communities):\n    node_community_map = {}\n    for i, community in enumerate(communities, start=1):\n        node_community_map.update({node: i for node in community})\n\n    return pd.Series(node_community_map).reindex(graph.nodes).fillna(0).astype(\"int64\")\n\n\ndef node_community_map_to_communities(node_community_map):\n    return [set(group.index) for group_id, group in node_community_map.groupby(node_community_map)]\n\n\ndef get_proportion_of_friends_in_group(node, group_id):\n    friends = get_friends(node, graph)\n    \n    group = node_community_map.loc[node_community_map == group_id].index\n    group_size = len(group)\n    \n    friends_in_group = [friend for friend in friends if friend in group]\n    proportion = len(friends_in_group) \/ group_size\n    \n    return proportion\n\n\ndef bring_nodes_to_community(community_id):\n    def is_small_community():\n        return community_sizes[community_id] < minimum_size\n    \n    community_members = get_community_members(community_id)\n    friends = get_friends(community_members, graph)\n    \n    if is_small_community():\n        big_enough_communities = community_sizes.loc[community_sizes > minimum_size].index\n    else:\n        big_enough_communities = community_sizes.loc[community_sizes > community_sizes[community_id]].index\n    \n    node_big_community_map = node_community_map.loc[node_community_map.isin(big_enough_communities)]\n    big_community_friends = node_big_community_map.reindex(friends).dropna().index\n    \n    proportions = {}\n    for friend in big_community_friends:\n        proportion = get_proportion_of_friends_in_group(friend, community_id)\n        proportions[friend] = proportion\n\n    proportions = pd.Series(proportions, dtype=\"float64\")\n\n    if proportions.empty:\n        return None\n    \n    return proportions.idxmax()\n\n        \ndef get_community_members(community_id):\n    return node_community_map.loc[node_community_map == community_id].index\n\n\ndef get_community_sizes():\n    return node_community_map.groupby(node_community_map).count()","a3dd3f77":"import math\n\nminimum_size = math.floor(graph.number_of_nodes() \/ len(community_division))\n\nnode_community_map = communities_to_node_community_map(graph, community_division)\n\ncommunity_sizes = get_community_sizes()\n\nbig_communities = [id for id, size in community_sizes.items() if size > minimum_size]\nnode_big_community_map = node_community_map.loc[node_community_map.isin(big_communities)]\n\ncommunity_ids = node_community_map.unique()        \n\nwhile any(community_sizes < minimum_size):\n    old_community_sizes = community_sizes.copy()\n    for community_id in community_ids:\n        nodes_to_bring = bring_nodes_to_community(community_id)\n        if nodes_to_bring:\n            node_community_map[nodes_to_bring] = community_id\n            community_sizes = get_community_sizes()\n    \n    if community_sizes.equals(old_community_sizes):\n        break\n","1b07fd91":"new_communities = node_community_map_to_communities(node_community_map)\ndraw_graph(graph, node_communities=new_communities, label_proportion=0)","74a410ea":"import plotly\nimport plotly.graph_objects as go\nimport plotly.express as px\nplotly.offline.init_notebook_mode(connected=True)","135bae06":"positions = [position for _, position in node_positions.items()]\n\nx, y = zip(*positions)","3cb92bcd":"lines = []\nfor a, b in graph.edges():\n    xa, ya = node_positions[a]\n    xb, yb = node_positions[b]\n    \n    lines.append(\n        go.Scatter(\n            x=[xa, xb],\n            y=[ya, yb],\n            line_color=\"black\",\n            line_width=1,\n            opacity=0.2,\n            showlegend=False,\n            hovertemplate=None,\n            mode=\"lines\"\n        )\n    )","150244fb":"node_communities = communities_to_node_community_map(graph, community_division)\n\ncmap = px.colors.qualitative.Plotly\n\ngo.Figure(\n    data=lines + [\n        go.Scatter(\n            x=x,\n            y=y,\n            mode=\"markers\",\n            marker=dict(\n                color=node_communities.values,\n                cmin=1,\n                cmax=len(cmap),\n                colorscale=cmap,\n            ),\n            customdata=node_communities,\n            text=[name for _, name in nx.get_node_attributes(graph, \"name\").items()],\n            hovertemplate=\"%{text} (%{customdata})<extra><\/extra>\",\n            showlegend=False,\n        )\n    ],\n    layout=go.Layout(\n        xaxis=go.layout.XAxis(\n            showticklabels=False,\n            showgrid=False,\n            zeroline=False,\n        ),\n        yaxis=go.layout.YAxis(\n            showticklabels=False,\n            showgrid=False,\n            zeroline=False,\n        ),\n        width=1000,\n        height=1000\n    )\n)","c82c3b48":"<h1>Table of Contents<span class=\"tocSkip\"><\/span><\/h1>\n<div class=\"toc\"><ul class=\"toc-item\"><li><span><a href=\"#Load-network\" data-toc-modified-id=\"Load-network-1\"><span class=\"toc-item-num\">1&nbsp;&nbsp;<\/span>Load network<\/a><\/span><\/li><li><span><a href=\"#Finding-communities\" data-toc-modified-id=\"Finding-communities-2\"><span class=\"toc-item-num\">2&nbsp;&nbsp;<\/span>Finding communities<\/a><\/span><ul class=\"toc-item\"><li><span><a href=\"#Girvan\u2013Newman-algorithm\" data-toc-modified-id=\"Girvan\u2013Newman-algorithm-2.1\"><span class=\"toc-item-num\">2.1&nbsp;&nbsp;<\/span>Girvan\u2013Newman algorithm<\/a><\/span><\/li><li><span><a href=\"#Fluid-Communities-algorithm\" data-toc-modified-id=\"Fluid-Communities-algorithm-2.2\"><span class=\"toc-item-num\">2.2&nbsp;&nbsp;<\/span>Fluid Communities algorithm<\/a><\/span><\/li><li><span><a href=\"#Adjusted-Fluid-Communities-algorithm\" data-toc-modified-id=\"Adjusted-Fluid-Communities-algorithm-2.3\"><span class=\"toc-item-num\">2.3&nbsp;&nbsp;<\/span>Adjusted Fluid Communities algorithm<\/a><\/span><\/li><\/ul><\/li><li><span><a href=\"#Improve-visualization\" data-toc-modified-id=\"Improve-visualization-3\"><span class=\"toc-item-num\">3&nbsp;&nbsp;<\/span>Improve visualization<\/a><\/span><\/li><\/ul><\/div>","bbbb0686":"# Improve visualization\n\nIt would be nice to be able to see the names of the people in the network but showing them would clutter the image.\nA solution to this is to use an interactive graph, so when you place the mouse over any node, the name appears.\n\nUnfortunately, NetworkX does not offer that functionality (at least that I am aware of).\nHowever, we can build our own visualization with [Plotly](https:\/\/plotly.com\/).","97880a1a":"Uhmmmm... a little strange right? Take a look at the image. There are a few nodes in the periphery that are barely connected to other nodes of the network. Those are your friends with whom you have none or almost no connections in common. They are probably people who you only met once and have not represented any influence in your life since they are not friends with any other of your friends.\n\nIn the center of the image, there are the rest of my friends, which are tightly connected. In this big \"island\" of the center, every node can reach every other node jumping through common friends. However, the little \"islands\" in the periphery, which are composed of one or very few nodes, cannot reach anyone else. They are completely isolated.\n\nA group of nodes where all of them can reach every other node through some path of connections (no matter how long it is), what I called an \"island\", is really known as a **connected component**.\n\nFrom now on we are going to remove the isolated friends from the periphery, since they do not add interesting information. I order to do that, we just need to find the biggest component (the one in the center) and keep it.","8cbfb27c":"Then we are going to create a simple undirected graph with NetworkX.\nA graph is simply a network. The members of the network (your Facebook friends in this case) are the nodes. Each node must have a label, which will be a unique identifier, this is, there are no two nodes with the same label.\n\nEach node can have attributes that describe it.\nIn our case, the label for each node will be the `user_id` and as attributes we will load the name and the gender:","54997b42":"But this task that the human brain is so good at, is not so straightforward to solve for a computer. We need some algorithm that emulates our mind.\n\n## Girvan\u2013Newman algorithm\n\nThe algorithm we are going to look at is the <a href=\"https:\/\/en.wikipedia.org\/wiki\/Girvan%E2%80%93Newman_algorithm\">Girvan-Newman algorithm<\/a>.\n\nIts principle is simple. You take the network, seek out the most important connection (edge), and remove it. If the network has been divided into two islands (connected components), then you have found two communities! Congratulations. However, if not, you just find the most important connection from the remaining ones and remove it. And so on until the number of connected components increases from 1 to 2.\nWhat if I want to divide my nodes in 3 communities? You just find 2 communities first, and then keep removing edges by descending order of importance.\n\nBut wait. What is an important connection? How do you measure importance? In general, in any way that comes to your mind. But usually, the algorithm uses what it is known as **betweenness centrality**.\nEvery edge\/connection of the graph has a score known as betweenness centrality. It measures how much removing that edge would impact the network.\n\nThe way to calculate it is this. You take every possible pair of nodes of the network, and for each pair pretend that one node wants to send a message to the other. If they are connected, they just need to use the edge between them. However, if they are not, they will need to find a path through other nodes. The best path is the shortest path, this is, the one with less intermediary nodes.\n\nThe betweenness centrality of an edge is the proportion of shortest paths that pass through the edge. In other words, the most important edge, the one with the highest betweenness centrality, is the one that, if removed, would force more node pairs to find a new shortest path between them.\n\nAll this wordy explanation contrasts with the simplicity of the <a href=\"https:\/\/networkx.org\/documentation\/stable\/reference\/algorithms\/generated\/networkx.algorithms.community.centrality.girvan_newman.html\">code<\/a> needed to apply the algorithm:","7576066a":"As we see, not all communities have the same size, but at least they are more equal than in the Girvan-Newmann algorithm","19817a5d":"Well, now what? Now we are able to face the problem at hand: How do we divide those nodes (persons) in different tables?\n\n\n# Finding communities\n\nThe problem of dividing people in tables is just an excuse to informally introduce the more formal concept of community. A community is just a group of nodes that are \"close\" to each other. When I say \"close\" it can sound somewhat vague, but it is not my intention to hide a more formal and rigorous definition. It is just that there is not a unique definition of community. There are multiple criteria one can follow, and each one leads to a different solution. The only thing they have in common is that nodes in a community should be \"close\" to each other.\n\nWe are going to use some simple ones that are easy to understand and work very well. But first, let's follow a more informal approach. How would you divide the network above? Even if we do not have yet an unambiguous definition of community, we can clearly see that are groups of nodes that are more tightly connected than the rest.\n\nMost people would have no problem finding different communities from the image above and will reach approximately the same community configuration:","e3bd188c":"## Adjusted Fluid Communities algorithm","e388aaea":"NOTE: This notebook is also published as blog article in [here](https:\/\/www.listeningtothedata.com\/posts\/organize-your-wedding-with-social-network-analysis-in-python\/).\n***","f53fa410":"# Load network\n\nIf you have followed the instructions on the other [article](https:\/\/www.listeningtothedata.com\/posts\/read-your-network-of-friends-in-facebook-by-scraping-with-python\/), you will have end up with a text file in json format that will look like this:","5b1b90c7":"There is, nonetheless, a little problem. Remember our original problem? We want to put these people in tables, but the biggest community we found has 69 people. I have never seen a table with so many seats.\n\nIdeally, we would want a way of finding communities but limiting the size of them.","5f776501":"And this is it! Contratulations for arriving until the end. Now you can explore more network algorithms in the NetworkX page (or using another library) and come up with new ways of visualize it.","98e605f6":"We did it!!!\n\nAs we can see, removing the most important edge until you get 10 connected components (communities) gives a good intuitive division that is very similar to what we would have done visually. You can experiment with more or less connected components.","c4403a70":"A graph, besides nodes, it also has edges, which are connections between nodes. There must be and edge between all your friends who are also friends between them.\nNetworX allows to load edges from a list of 2-item tuples, where each of the two elements are the node labels of the two nodes that are connected.","1f0e594b":"Just by reading the title you must think these are the words of a crazy man. Of course, I am half joking, but half talking seriously. We are going to use a common, down to Earth problem, as an excuse to introduce some of the techniques and algorithms used network analysis and how immediate and easy it is to start applying them to real datasets with Python and the <a href=\"https:\/\/networkx.org\/\">NetworkX<\/a> library. Without further delay, let us start our crazy adventure.\n\nIf you have ever been to a wedding before, it is highly likely that, after a nice ceremony in the church where everyone behaved with elegance and grace, then you have eaten an absurdly high amount of food. That is usually my favorite part. You get to sit and eat for hours until your body suddenly feels 30 years older.\n\nAnd you ate that food sitting in a table with other people. If you are lucky, you like those people and conversation is fluid. Usually, you do not get to sit wherever you want. Usually, it is the bride and the groom who have carefully chosen who gets to sit with whom. And most often than not they choose wisely, and you end up spending your time with your family, or friends, or your coworkers.\n\nLet\u2019s pretend you are the one who is getting married. How do you divide your wedding guests in different tables? You must follow some criteria. Placing them at random can be fun for sure, but it is not the distribution that is going to make your guests feel more comfortable or appreciated. \nUnless you are the biggest troll on Earth, you would put people who know each other at the same table.\n\nSo you sit down with your laptop, take the list of guests, and starts dividing them into groups of people who is close to each other. It is a necessary task, but it must be a boring one. What if we could do it with less effort? What if we could use some algorithm to create the different groups?\nHere is where network analysis comes to help.\n\nIf you have at your disposal the list of guests and know which of them know each other, you can model this information mathematically as a graph or a network (both terms are mathematically equivalent, although sometimes one is used in some contexts more than the other).\nIn general terms, a network is a group of vertices or nodes connected between them by edges or links. In our case, the nodes are our wedding guests and there is a link connecting a pair of nodes if those two people already know each other.\n\nOnce you have your guest\u2019s connections modelled appropriately as a network, you will be able to apply some sort of algorithm that will find groups of nodes who are densely connected to each other, and hence could be comfortably sat at the same table.\n\nIn network nomenclature, those groups are called communities or clusters, and there are lots of different algorithms of finding them. Each algorithm uses a different criterion for what is the optimal division of the nodes into communities. Some of them are easier to understand than others, and some of them are more closely related to our problem at hand than others.\nIt is not my intention to review them, because it is an infinite field.\nHowever, we are going to review some simple ones with extensive use that have proved over and over to work very well in practical situations.\n\nAll of this sounds nice, but now we need to do it. This is the difficult but interesting part.\nWe need to do mainly two things: getting our guest network and finding the communities.\nThanks to the powerful interface of <a href=\"https:\/\/networkx.org\/\">NetworkX<\/a>, finding the communities in a network is very straightforward and I will spend more time explaining the algorithm than actually writing the code. You\u2019ll see it is very simple.\n\nSurprisingly (or maybe not), the difficult part is to come up with a way of creating a guest network that is automatic and unambiguous. Writing it manually is not an option. I mean, it is an option, but a tedious one.\nThe solution that came to my mind was using an online social network, specifically Facebook. Most of your guests are likely going to be your friends in that network, apart from your aunt who does not know what YouTube is. And if they know each other (because they are friends, cousins, coworkers or whatever), they will also be friends in Facebook and you can know that because they will appear as mutual friends.\nTherefore, your guest network will be your Facebook network (don\u2019t forget to complete the network manually with your aunt who does not even have a smartphone).\n\nGreat! We solved it! Not so fast. I don\u2019t know if you noticed before, but there is not button on Facebook with the name \u201cDownload network\u201d. It would be nice, but there isn\u2019t. We need to scrape that information before. As this task itself is complex enough to deserve its own project, you can read my other article [Read your network of friends in Facebook by scraping with Python](https:\/\/www.listeningtothedata.com\/posts\/read-your-network-of-friends-in-facebook-by-scraping-with-python\/) (or its [Kaggle notebook](https:\/\/www.kaggle.com\/rubchume\/read-your-network-of-friends-in-facebook) version) to see how to do it. It will teach you how to apply web scraping with Python (using <a href=\"https:\/\/www.selenium.dev\/\"> Selenium<\/a> library) to get the mutual friendship network.\n\nGo [there](https:\/\/www.listeningtothedata.com\/posts\/read-your-network-of-friends-in-facebook-by-scraping-with-python\/) and come back when you have completed it. You finished? Great, let\u2019s continue.\n\n**Note**\nIf you only want to do it but are not interested in learning how, you can also download a web app I developed using Django that does all this. Download it from the GitHub [repository](https:\/\/github.com\/rubchume\/FacebookFriendNetworkAnalyzer) and follow the instructions in the `Readme.md` file.","41696aee":"To achieve same size communities without messing it too much, we must get creative.\nI am going to propose a simple algorithm that would run after the usual fluid communities algorithm in order to adjust the sizes.\n\nIt is not very sophisticated, but it does the work and, at least with my group of friends, it worked well. I mean, the resulting table configuration was not incoherent at all.\n\nThe approach is the next. First, we calculate what is the minimum number of members each group must have. You can set the minimum to any number, but it must be always equal or less than\n$$\n\\left\\lfloor{\\frac{N}{k}}\\right\\rfloor\n$$\nwhere $N$ is the number of nodes and $k$ the number of groups.\n\nThen we iterate through every group that is smaller than it should be. For each one, we get the friends of any member of the small group that belong to some group that has more members than the minimum required. Bring to the group the one that has the highest proportion of friends in the small group. Repeat the process until the small group has achieved the minimum number required.\nIf it is impossible to achieve the minimum size because all the friends are in also small groups, then move to another small group.\n\nRepeat the process for all groups until all of them have achieved the minimum size. ","459312ea":"```\n{\n    \"friend_list\": [\n        {\n            \"user_id\": \"12345\",\n            \"name\": \"My best friend name\",\n            \"link\": \"https:\/\/www.facebook.com\/mybestfriend\",\n            \"gender\": \"MALE\"\n        },\n        {\n            \"user_id\": \"67890\",\n            \"name\": \"Jessica Rabbit\",\n            \"link\": \"https:\/\/www.facebook.com\/jessicarabbit\",\n            \"gender\": \"FEMALE\"\n        },\n        ...\n    ],\n    \"mutual_friends\": {\n        \"12345\": [\n            {\n                \"user_id\": \"245345\",\n                \"name\": \"My other best friend\",\n                \"link\": \"https:\/\/www.facebook.com\/youcouldbemorecreative\",\n                \"gender\": \"MALE\"\n            },\n        ],\n        \"67890\": [\n            {\n                \"user_id\": \"245345\",\n                \"name\": \"Gandalf\",\n                \"link\": \"https:\/\/www.facebook.com\/greywizard\",\n                \"gender\": \"MALE\"\n            },\n            {\n                \"user_id\": \"999876\",\n                \"name\": \"Hermione\",\n                \"link\": \"https:\/\/www.facebook.com\/mugglewizard\",\n                \"gender\": \"FEMALE\"\n            }\n        ]\n    }\n} \n```","f8321933":"Great! Now our graph is created. We just need to visualize it with the `draw` function.","8dce2c4c":"This is much better! Now we can see in more detail the underlying structure of my social connections.\n\nSidenote: as visualizations can be tricky to use, from now on I am going to use a custom function to plot graphs. It is simply a convenient wrapper for the `draw` function. You don't need to use it, but I like it for its convenience. Also, I am going to pre-compute the position of the nodes in the 2D representation so we can keep it through all the plots instead of generating new positions each time we plot.","db6198d2":"Unfortunately, I don't know of an algorithm in the NetworkX API that has the property of keeping al communities with the same size.\n\nHowever, there is an algorithm that accomplishes something kind of similar. It is called <a href=\"https:\/\/networkx.org\/documentation\/stable\/reference\/algorithms\/generated\/networkx.algorithms.community.asyn_fluid.asyn_fluidc.html\">Fluid Communities algorithm<\/a>. The explanation of this algorithm usually uses the metaphor of a fluid filling all the network.\n\nIn simple words, what the algorithm does is to initialize k nodes to k different communities. Then, it iterates through all the nodes in a random order and assigns to them the community where its connections represent a higher proportion relative to the size of the community. It repeats the process until no more updates occur. In other words, the algorithm stops when all the nodes are in the community where its friends represent a higher proportion.\n\nIn the table analogy, every person is assigned to the table where, given that a person is picked at random, it has the highest chance of being a friend of the person. It is a nice idea, right? \n\nIn the simplest words I can think of, with this approach we are maximizing the probability of begin seated next to a friend. No more, no less.","55e543bf":"That is all the information we need to create a network representation and load it into NetworkX. The first step is reading the file and loading the information into a dictionary, since the translation from a json file into a Python dictionary is straightforward and convenient:","403e9d7c":"## Fluid Communities algorithm","ca3e437d":"It has a very basic schema. It is an object with two fields: `friend_list` and `mutual_friends`. `friend_list` is an array of users that are friends with you, where each user is represented by an object with four fields:\n- `user_id`. Unique identifier of user in Facebook.\n- `name`. Name of the user.\n- `link`. URL of the user's profile.\n- `gender`. Gender of the user.\n\n`mutual_friends` is an object where each field has one of your friends' `user_id` as the key and the value is an array of users that you and your friend have in common, this is, mutual friends. For example, in the example above, my best friend and I have only one mutual friend, which is my other best friend. And my friend Jessica Rabbit and I have as mutual friends Gandalf and Hermione. However, that does not imply that Hermione and Gandalf are friends, it just means that they are both friends with Jessica Rabbit."}}