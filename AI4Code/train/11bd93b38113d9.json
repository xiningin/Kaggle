{"cell_type":{"14ec445c":"code","5dfc6b80":"code","a2576f0a":"code","0121ae3f":"code","aacf16e7":"code","4af27be7":"code","623ca119":"code","1c2be052":"code","a7e0afbb":"code","55e9c782":"code","1248cbd9":"code","34469453":"code","32df0d21":"code","ba073aec":"code","dee472ae":"code","b95d281f":"code","f8af3cea":"markdown","abee2ffc":"markdown","7846e0e5":"markdown","5b4d4aad":"markdown","7ac11905":"markdown","2f4bd5d7":"markdown"},"source":{"14ec445c":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport matplotlib.pyplot as plt\nimport seaborn as sbor # for visualization \n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.\n","5dfc6b80":"# 'NBA player of the week' data been chosen as the trial data (Player of the week data from 1984-1985 to 2017-2018)\ndata = pd.read_csv('..\/input\/NBA_player_of_the_week.csv')\n# get the data info\ndata.info()","a2576f0a":"# data correlation in tabular format?\ndata.corr()\n\n# as expected, correlation within numbered items only (4xint64 and 1xfloat64)\n# some high correlations do occur:\n# - Seasons in league <-> Age\n# - Real_value <-> Draft Year (negative)\n# - Draft Year <-> Season short\n# - Seasons short <-> Real_value (negative)","0121ae3f":"# correlation map\nf,ax = plt.subplots(figsize=(14, 14))\nsbor.heatmap(data.corr(), annot=True, linewidths=.2, fmt= '.1f',ax=ax)\nplt.show()\n\n# dark ones are the negative correlations (mutual relations)\n# light creme ones (apart from the white-ish diagonal relations) are the\n#                               positive correlations (mutual relations)\n","aacf16e7":"print(data.head(10))   #first 10 rows\nprint(data.tail(10))   #last 10 rows\n\ndata.columns   #name of columns, or \"features\", namely","4af27be7":"#feature\/column name format improvments: (I will check a smarter way to write a method to clean the naming mess:\n#                          split methods for 2 and for 3 words, made below in a very strange way, but it works!)\ndata.columns = [each.lower() for each in data.columns];  #all letters in lower\n# string concat operations\ndata.columns = [each.split()[0]+\"_\"+each.split()[1]+\"_\"+each.split()[2] if(len(each.split())>2) else each for each in data.columns];\ndata.columns = [each.split()[0]+\"_\"+each.split()[1] if(len(each.split())>1) else each for each in data.columns];\nprint(data.columns);\n\n# Another way would be to re-assign the column names of the data frame, after correcting them manually\n# Not a nice way to do, but for a limited subset of column names, it may help to move quick\n# alternative assignment is given below (commented out, not functional):\n\n#data.columns = ['age', 'conference', 'date', 'draft_year', 'height', 'player',\n#       'position', 'season', 'season_short', 'seasons_in_league', 'team',\n#       'weight', 'real_value'\n\n","623ca119":"# Line Plot\n# color = color, label = label, linewidth = width of line, alpha = opacity, grid = grid, linestyle = sytle of line\ndata.age.plot(kind = 'line', color = 'g',label = 'Age',linewidth=1,alpha = 0.5,grid = True,linestyle = ':')\ndata.real_value.plot(color = 'b',label = 'Real Value',linewidth=1, alpha = 0.5,grid = True,linestyle = '-.')\ndata.seasons_in_league.plot(color = 'r',label = 'Seasons in League',linewidth=1, alpha = 0.5,grid = True)\nplt.legend(loc='upper right')     # legend = puts label into plot\nplt.xlabel('x axis')              # label = name of label\nplt.ylabel('y axis')\nplt.title('Line Plot')            # title = title of plot\nplt.show()","1c2be052":"# Scatter Plot \n# x = attack, y = defense\ndata.plot(kind='scatter', x='season_short', y='real_value',alpha = 0.5,color = 'red')\nplt.xlabel('Season Short')              # label = name of label\nplt.ylabel('Real Value')\nplt.title('Real Value Distribution versus The Season Year')            # title = title of plot\nplt.show()       # explanation for the real_value distribution given in the original data set: If two awards given at the same week [East & West]\n#                   the player got 0.5, else 1 point.  Thus, below Plot shows that, although very naive & crude simple, after ","a7e0afbb":"# Histogram    Choosing a proper feature to be shown by Histogram makes the visualization much clear, proper and readable.\n# bins = number of bar in figure\ndata.age.plot(kind = 'hist',bins = 40,figsize = (10,10))\nplt.show()","55e9c782":"#Create multiple dictionaries from the same csv file and look its keys and values\n\n#Index(['age', 'conference', 'date', 'draft_year', 'height', 'player',\n#       'position', 'season', 'season_short', 'seasons_in_league', 'team',\n#       'weight', 'real_value'],\n#      dtype='object')\n\n# Some examples of dictionaries created from the DataFrame of the file 'NBA_player_of_the_week.csv'\n\n# first, a query to check the uniqueness in keys (player as an example):\ndata[\"player\"].unique()\nlen(data[\"player\"].unique())\n\ndict_Of_Age = {} #dictionary of 'player' (index:5) and 'age'(index:0) relationship (the call len(data[\"player\"].unique()) gives 274 unique player's name, \n                    # but person-age relationship -although a little weird- depends on the year in which that specific player won the point(real_value)\n                    # so dimension reduction is not meaningfull cause we loose the player's age info at that year \n                    # and to make it more complex: it can all be calculated just after the first entry, but too heavy I guess for that homework :)\ndict_Of_Age = {row[5] : row[0] for _, row in data.iterrows()}\nlen(dict_Of_Age)    # unfortunately, stuck with unique 274 records! But which ones? Presumably first entries by default...\n\ndict_Of_Height = {} #dictionary of 'player'(index:5) and 'height'(index4) relationship\ndict_Of_Height = {row[5] : row[4] for _, row in data.iterrows()}\nlen(dict_Of_Height)    # unfortunately, stuck with unique 274 records! But which ones? Presumably first entries by default...\n\ndict_Of_Players_Real_Value = {} # the only \"rationaly full\" list-dictionary by 'player'(index:5) and 'real_value'(index12). \ndict_Of_Players_Real_Value = {row[5] : row[12] for _, row in data.iterrows()}\nlen(dict_Of_Players_Real_Value)    # unfortunately, stuck with unique 274 records! But which ones? Presumably first entries by default...\n\n# Keys have to be immutable objects like string, boolean, float, integer or tubles\n# List is not immutable\n# Keys are unique\n\ndict_Of_Age.clear()                   # remove all entries in dict\ndict_Of_Height.clear()                   # remove all entries in dict\n#dict_Of_Players_Real_Value.clear()                   # remove all entries in dict BUT not executed to be used in below loop\/while work\n\n\n","1248cbd9":"# data = pd.read_csv('..\/input\/NBA_player_of_the_week.csv') \n# I didn't want to reload the dataframe cause, I've already made category naming modifications (lower case and concat operations)\n\nseries = data['age']        # data['age'] = series\nprint(type(series))\ndata_frame = data[['age']]  # data[['Defense']] = data frame\nprint(type(data_frame))","34469453":"# 1 - Filtering Pandas data frame\nx = data['age']>30     # There are 166 entries with over 30 years of age, but repetitions do occur due to the nature of the data\ndata[x]","32df0d21":"# 2 - Filtering pandas with logical_and\n# There are 26 entries over 30's and plays in G (Guard) position ('and' operation of '>int64'(age) with 'equal?'string\/object(G as Guard)  )\ndata[np.logical_and(data['age']>30, data['position'] == \"G\" )]","ba073aec":"# This is also same with previous code line. Therefore we can also use '&' for filtering.\ndata[(data['age']>30) & (data['position'] == \"G\")]","dee472ae":"# Stay in loop if condition( i is not equal 5) is true\ni = 0\nwhile i != 5 :\n    print('i is: ',i)\n    i +=1 \nprint(i,'is:  5')","b95d281f":"# Stay in loop if condition( i is not equal 5) is true\nlis = [11,12,13,14,15]\nfor i in lis:\n    print('i is: ',i)\n#print('')   # I didn't get the use of it?\n\n# Enumerate index and value of list\n# index : value = 0:11, 1:12, 2:13, 3:14, 4:15\nfor index,value in enumerate(lis):\n    print(index,\" : \",value)\nprint('')   \n\n# For dictionaries\n# We can use for loop to achive key and value of dictionary. We learnt key and value at dictionary part.\n\n#dict_Of_Players_Real_Value\nfor key,value in dict_Of_Players_Real_Value.items():\n    print(key,\" : \",value)\nprint('')\n\n# For pandas we can achieve index and value\nfor index,value in data[['age']][0:20].iterrows():   #first 20 entries\n    print(index,\" : \",value)","f8af3cea":"**Matplotlib work**\n","abee2ffc":"**Dictionary\n**","7846e0e5":"High correlations mean **inter-dependency** of variables\/features. I guess, as an example, 'Seasons in league' and 'Age' may have somehow a linear inter-dependency by which (after a proper statistical evaluation) we may be excluding one of them from the further investigation.\n\n","5b4d4aad":"**WHILE and FOR LOOPS**","7ac11905":"**   PANDAS**\n","2f4bd5d7":"**data details:**\n\n1145 items, 13 columns, 8 string types, 4 integer types, 1 float type\nOnly conference feature (row, item?) has missing values, remaining all are full"}}