{"cell_type":{"bf8f52cf":"code","1d4e2a19":"code","638e5e42":"code","178d8cb0":"code","205143f7":"code","769588c3":"code","aa320466":"code","dd58454c":"code","41ddd231":"code","291505bc":"code","ca425f33":"code","217d4e82":"code","3b3d1064":"code","474aa3c9":"code","bd9e8d60":"code","be2b643b":"code","688c76df":"code","ab75e6dd":"code","74c9974d":"code","c239b300":"code","aaeae243":"code","792c7589":"code","e110485f":"code","92813419":"code","a6daf1a8":"code","9369ab16":"code","a0afbb36":"code","7928eb5e":"markdown","91338905":"markdown","e197a0d1":"markdown","02f6bdec":"markdown","8971133b":"markdown","be6f6790":"markdown","e1ed8434":"markdown","01151017":"markdown","442086bb":"markdown","873d3042":"markdown","c3e1e85a":"markdown","cfecf664":"markdown"},"source":{"bf8f52cf":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","1d4e2a19":"import numpy as np\nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport seaborn as sns; sns.set()\nfrom tqdm.notebook import tqdm","638e5e42":"df_train = pd.read_csv('\/kaggle\/input\/digit-recognizer\/train.csv')\ndf_test = pd.read_csv('\/kaggle\/input\/digit-recognizer\/test.csv')","178d8cb0":"df_train.head()","205143f7":"feature_names = ['pixel' + str(i) for i in range(784)]\ntarget = df_train['label'].to_numpy()\ndigits = df_train[feature_names].to_numpy()","769588c3":"digits = digits.reshape(digits.shape[0], 28, 28)\ndigits.shape","aa320466":"def visualize_digits(digits, labels, labels_pred=None, probabilities=None, rows=10, cols=10, take_random=False):\n    '''\n    digits - 2d array of pixels\n    labels - array of true values denoting digits in the images\n    labels_pred - array of predicted values denoting digits in the images\n    probabilities - shows how confident the model is about the predicted values\n    rows - amount of rows\n    cols - amount of cols\n    take_random - take random digits from the provided dataset or take first (rows * cols) digits\n    '''\n    fig, ax = plt.subplots(rows, cols, figsize=(rows, cols))\n    \n    # Simple check of the consistency of the dimensionality of the provided arrays \n    if len(digits) != len(labels):\n        print(f'lengths of digits ({len(digits)}) and labels ({len(labels)}) arrays should be the same')\n        return\n    if labels_pred is not None and len(labels) != len(labels_pred):\n        print(f'length of labels ({len(labels)}) and labels_pred ({len(labels_pred)}) arrays should be the same')\n        return\n    \n    size = np.min([len(labels), rows * cols])\n    \n    # What digits to take from array by the value of the take_random parameter\n    if take_random:\n        indexes = np.random.choice(list(range(len(labels))), size=size, replace=False)\n    else:\n        indexes = list(range(size))\n        \n    # Plotting the matrix of digits\n    for row in range(rows):\n        for col in range(cols):\n            ax[row, col].axis('off')\n            ax[row, col].grid('off')\n            \n            if row * rows + col > size - 1:\n                continue\n            \n            i = indexes[row * rows + col]\n            \n            ax[row, col].imshow(digits[i], cmap='Greys')\n            \n            if labels_pred is not None:\n                if labels_pred[i] == labels[i]:\n                    clr = 'green'\n                    s = f'{labels[i]}'\n                else:\n                    clr = 'red'\n                    s = f'{labels_pred[i]}\/{labels[i]}'\n                if probabilities is not None:\n                    ax[row, col].text(15, 0, f'{probabilities[i].max():.0f}%', color=clr)\n            else:\n                clr = 'grey'\n                s = f'{labels[i]}'\n            \n            ax[row, col].text(0, 0, s, color=clr)","dd58454c":"visualize_digits(digits, target, take_random=True)","41ddd231":"from sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split \n\n# Reshaping array of features back to 1d array\ndigits = digits.reshape(digits.shape[0], 28 * 28)\nrfc = RandomForestClassifier()\nX_train, X_test, y_train, y_test = train_test_split(digits, target, train_size=0.8)\n\nrfc.fit(X_train, y_train)\ny_pred = rfc.predict(X_test)","291505bc":"y_pred_proba = rfc.predict_proba(X_test)","ca425f33":"def plot_digit_prob(digit, pp, text=None):\n    '''\n    digit - array of digit image\n    pp - list of predict proba\n    '''\n    fig, ax = plt.subplots(1, 2, figsize=(10, 5))\n    ax[0].imshow(digit, cmap='Greys');\n    ax[0].axis('off')\n    ax[0].grid('off')\n    \n    if text:\n        ax[0].text(0, 0, text)\n    sns.barplot(ax=ax[1], x=list(range(10)), y=pp)","217d4e82":"digit = X_test[0].reshape(28, 28)\npp = y_pred_proba[0]\nplot_digit_prob(digit, pp)","3b3d1064":"# finding first incorrectly recognized digit\ndigit = X_test[y_test != y_pred][0].reshape(28, 28)\npp = y_pred_proba[y_test != y_pred][0]\n\n# True value and (wrongly) predicted value \ntrue_value = y_test[y_test != y_pred][0]\npredicted_value = y_pred[y_test != y_pred][0]\ntext = f'True value: {true_value}\\nPredicted value: {predicted_value}'","474aa3c9":"plot_digit_prob(digit, pp, text)","bd9e8d60":"X_test_3d = X_test.reshape(X_test.shape[0], 28, 28)","be2b643b":"visualize_digits(\n    X_test_3d, \n    np.array(y_test), \n    y_pred, \n    probabilities=100 * y_pred_proba, \n    take_random=True,\n)","688c76df":"# Lets print out only wrongly recognized digits\nX_wrong = X_test_3d[y_test != y_pred]\ny_test_wrong = y_test[y_test != y_pred]\ny_pred_wrong = y_pred[y_test != y_pred]","ab75e6dd":"visualize_digits(\n    X_wrong, \n    np.array(y_test_wrong), \n    y_pred_wrong, \n    take_random=True\n)","74c9974d":"from sklearn.metrics import confusion_matrix\nc_mtrx = confusion_matrix(y_test, y_pred)\n\nfig, ax = plt.subplots(figsize=(10, 10))\n\nmask = np.identity(n=c_mtrx.shape[0], dtype=bool)\nsns.heatmap(ax=ax, data=c_mtrx, annot=True, fmt='.0f', cmap='Blues', square=True, linecolor='k', linewidth=1, cbar=False, mask=mask);\nax.set_xlabel('recognized');\nax.set_ylabel('true value');","c239b300":"c_mtrx_zerodiag = c_mtrx.copy()\nnp.fill_diagonal(c_mtrx_zerodiag, 0)\n\naccuracy_score_digits = dict(\n    zip(\n        list(range(10)),\n        np.round(\n            100 * (1 - np.array([np.sum(row) for row in c_mtrx_zerodiag]) \/ np.array([np.sum(row) for row in c_mtrx])), \n            3)\n    )\n)\n\naccuracy_score_digits_sorted = {k: v for k, v in sorted(accuracy_score_digits.items(), key=lambda item: item[1])}\nfor key in accuracy_score_digits_sorted.keys():\n    print(f'{key}:\\t{accuracy_score_digits_sorted[key]:.1f}%')","aaeae243":"ax = sns.barplot(x=list(accuracy_score_digits.keys()), y=list(accuracy_score_digits.values()), color='darkcyan');\nax.set_ylim((85, 100));\nax.set_xlabel('digit');\nax.set_ylabel('probability');","792c7589":"feature_importances = rfc.feature_importances_\n\nfeature_importances = feature_importances.reshape(28, 28)\n\nplt.imshow(feature_importances, cmap='Greys');\nplt.grid('off');\nplt.axis('off');","e110485f":"df_train_encoded = pd.get_dummies(df_train, prefix='digit', columns=['label'])\ndf_train_encoded.head()","92813419":"features = ['pixel' + str(i) for i in range(784)]\nlabels = ['digit_' + str(i) for i in range(10)]","a6daf1a8":"rfr_for_each_digit = RandomForestClassifier(n_estimators=100)\n\nfeature_importances = []\nfor digit in tqdm(range(10)):\n    rfr_for_each_digit.fit(df_train_encoded[features], df_train_encoded[labels[digit]])\n    feature_importances.append(rfr_for_each_digit.feature_importances_.reshape(28, 28))","9369ab16":"def plot_pixel_importances(feature_importances):\n    rows, cols = 2, 5\n    fig, ax = plt.subplots(rows, cols, figsize=(25, 10))\n    \n    for digit in range(10):\n        row, col = digit \/\/ cols, digit % cols \n        ax[row, col].imshow(feature_importances[digit], cmap='RdBu') \n        ax[row, col].text(0, 0, digit, color='green')\n        ax[row, col].grid('off');\n        ax[row, col].axis('off');","a0afbb36":"plot_pixel_importances(feature_importances)","7928eb5e":"Let's implement Random Forest Classification model and apply it to the data","91338905":"Let's plot a confusion matrix to see which digits are most oftenly confused by the model.","e197a0d1":"Let's split the dataset in two: the one containing the features, the other containing the target","02f6bdec":"Let's find some example of poorly recognized digit. It is clearly seen how the model make wrong decision, wrongfully recognize digit '4' as '8'.","8971133b":"Reshaping the features as 28x28 pixel matrix","be6f6790":"For example, let's see on the first digit in test sample. Prediction probabilities could be visualized with barplot, each bar shows the probability this digit could be recognized with particular label.","e1ed8434":"Lets look at the most important features","01151017":"How particular digit recognized","442086bb":"Accuracy score shows mean probability to get correct answer. Ofcourse, not all digits recognized with the same probability. The histogram below shows the probability for each digit to be successfully recognized.","873d3042":"Random Forest Classifier provides prediction probability values. This means that you can see how the model provides the classification result. Prediction probability in this case is a list of probabilities that the image can be recognized as a specific digit. ","c3e1e85a":"Printing random images from the dataset with prediction probabilities.","cfecf664":"This function visualizes digits as matplotlib images"}}