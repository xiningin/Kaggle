{"cell_type":{"e2fda183":"code","bd62bf4c":"code","11919ecc":"code","c7d87ebd":"code","3a631a3f":"code","0460a2fe":"code","1d8e7e52":"code","33ffe19b":"code","f8a152e3":"code","5c914cca":"code","dd76f37c":"code","3d620002":"markdown"},"source":{"e2fda183":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","bd62bf4c":"#Reading attempt_range:\nattempt_range = pd.read_csv('..\/input\/train_submissions.csv')","11919ecc":"attempt_range.head()","c7d87ebd":"\ndata_matrix = np.zeros((3571,6544))\nfor line in attempt_range.itertuples():\n    data_matrix[int(line[1].split(\"_\")[1])-1,  int(line[2].split(\"_\")[1])-1] = line[3]","3a631a3f":"data_matrix","0460a2fe":"#Let us define a function to predict the ratings given by the user to all the movies which are not rated by him\/her.\nclass MF():\n\n    # Initializing the user-movie rating matrix, no. of latent features, alpha and beta.\n    def __init__(self, R, K, alpha, beta, iterations):\n        self.R = R\n        self.num_users, self.num_items = R.shape\n        self.K = K\n        self.alpha = alpha\n        self.beta = beta\n        self.iterations = iterations\n\n    # Initializing user-feature and movie-feature matrix \n    def train(self):\n        self.P = np.random.normal(scale=1.\/self.K, size=(self.num_users, self.K))\n        self.Q = np.random.normal(scale=1.\/self.K, size=(self.num_items, self.K))\n\n        # Initializing the bias terms\n        self.b_u = np.zeros(self.num_users)\n        self.b_i = np.zeros(self.num_items)\n        self.b = np.mean(self.R[np.where(self.R != 0)])\n\n        # List of training samples\n        self.samples = [\n        (i, j, self.R[i, j])\n        for i in range(self.num_users)\n        for j in range(self.num_items)\n        if self.R[i, j] > 0\n        ]\n\n        # Stochastic gradient descent for given number of iterations\n        training_process = []\n        for i in range(self.iterations):\n            np.random.shuffle(self.samples)\n            self.sgd()\n            mse = self.mse()\n            training_process.append((i, mse))\n            if (i+1) % 20 == 0:\n                print(\"Iteration: %d ; error = %.4f\" % (i+1, mse))\n\n        return training_process\n\n    # Computing total mean squared error\n    def mse(self):\n        xs, ys = self.R.nonzero()\n        predicted = self.full_matrix()\n        error = 0\n        for x, y in zip(xs, ys):\n            error += pow(self.R[x, y] - predicted[x, y], 2)\n        return np.sqrt(error)\n\n    # Stochastic gradient descent to get optimized P and Q matrix\n    def sgd(self):\n        for i, j, r in self.samples:\n            prediction = self.get_rating(i, j)\n            e = (r - prediction)\n\n            self.b_u[i] += self.alpha * (e - self.beta * self.b_u[i])\n            self.b_i[j] += self.alpha * (e - self.beta * self.b_i[j])\n\n            self.P[i, :] += self.alpha * (e * self.Q[j, :] - self.beta * self.P[i,:])\n            self.Q[j, :] += self.alpha * (e * self.P[i, :] - self.beta * self.Q[j,:])\n\n    # Ratings for user i and moive j\n    def get_rating(self, i, j):\n        prediction = self.b + self.b_u[i] + self.b_i[j] + self.P[i, :].dot(self.Q[j, :].T)\n        return prediction\n\n    # Full user-movie rating matrix\n    def full_matrix(self):\n        return mf.b + mf.b_u[:,np.newaxis] + mf.b_i[np.newaxis:,] + mf.P.dot(mf.Q.T)\n","1d8e7e52":"#Now let us predict all the missing ratings. Let\u2019s take K=20, alpha=0.001, beta=0.01 and iterations=100.\nmf = MF(data_matrix, K=20, alpha=0.001, beta=0.01, iterations=100)\ntraining_process = mf.train()\nprint()\nprint(\"P x Q:\")\nprint(mf.full_matrix())\nfull_matrix=mf.full_matrix()","33ffe19b":"test=pd.read_csv('..\/input\/test_submissions_NeDLEvX.csv')\n","f8a152e3":"test","5c914cca":"test_attempts_range=np.zeros((66555,1))\nfor line in test.itertuples():\n    test_attempts_range[line[0]]=int(full_matrix[int(line[2].split(\"_\")[1])-1,  int(line[3].split(\"_\")[1])-1])\n","dd76f37c":"submission=pd.DataFrame()\nsubmission['ID']=test['ID']\n\nsubmission['attempts_range']=test_attempts_range\nsubmission.to_csv('submission_mf.csv',index=False)","3d620002":"##Building a recommendation engine using matrix factorization"}}