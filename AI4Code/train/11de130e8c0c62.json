{"cell_type":{"529eeb17":"code","10ee65e1":"code","aae9fee9":"code","b87ae9f7":"code","1635cf9f":"code","e9fea0c2":"code","06cbca5d":"code","3134beb4":"code","30604c50":"code","91b8042b":"code","e8685683":"code","5a451d1e":"code","27756df2":"code","f9743f6c":"code","b579fae6":"code","0b8921f9":"code","c3cb37ef":"code","5cc7c434":"code","77eb8c39":"code","175837de":"code","b93670dd":"code","0cc059da":"code","a6261634":"code","88981c3a":"code","2d03ca5a":"code","efa5650e":"code","6f197e2b":"code","4aea9513":"code","94c5442a":"code","fd92c002":"code","6c29b95c":"code","b3bea6f2":"code","ebaab0ed":"code","30ca8d24":"code","d0009189":"code","6d9b8413":"code","d394c25d":"code","4ce0f139":"code","c115ae4e":"markdown","c8d29869":"markdown","6d830b50":"markdown","3beae4cd":"markdown","7fabf32a":"markdown","8527f95d":"markdown","c03c9340":"markdown","39dc6596":"markdown","857905d5":"markdown","dc07feb6":"markdown","8e6acdc2":"markdown","a6c3151e":"markdown","ec55b545":"markdown","902da242":"markdown","bce1f9df":"markdown","cd6f1f7a":"markdown","499cc07e":"markdown","377035ff":"markdown","a1e3cb66":"markdown","fdef1a90":"markdown","41bc8af0":"markdown","23ad73bd":"markdown","71cb5728":"markdown","ee486d96":"markdown","03cfb56a":"markdown","c684457d":"markdown","facee596":"markdown","fcf96aeb":"markdown","989a2e4f":"markdown","8b0fbc6f":"markdown","e140c674":"markdown","471c754d":"markdown","bc07583a":"markdown","26600b25":"markdown","d4e16126":"markdown","f8eeecb6":"markdown","97875d99":"markdown","b00e6aec":"markdown","b086b6eb":"markdown","c4ac7351":"markdown","58e10a97":"markdown","4a1628d6":"markdown","a8c7d5fd":"markdown","f6d8ae63":"markdown","9d10ba5a":"markdown","79a737f2":"markdown","f89e3b26":"markdown","60223489":"markdown","d1b11404":"markdown","b039d8dc":"markdown","36097e2b":"markdown"},"source":{"529eeb17":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates  \nimport seaborn as sns\nfrom datetime import datetime\nfrom datetime import timedelta\nimport plotly.graph_objects as go\nfrom fbprophet.plot import plot_plotly, plot_components_plotly\nfrom plotly.offline import iplot\nimport plotly.express as px\nimport time\nimport warnings\nwarnings.filterwarnings('ignore')","10ee65e1":"import datatable as dt","aae9fee9":"crypto_df = dt.fread('..\/input\/g-research-crypto-forecasting\/train.csv').to_pandas()\ncrypto_df.head(10)","b87ae9f7":"# def reduce_mem_usage(df, verbose=True):\n#     numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n#     start_mem = df.memory_usage().sum() \/ 1024**2\n#     for col in df.columns:\n#         col_type = df[col].dtypes\n#         if col_type in numerics:\n#             c_min = df[col].min()\n#             c_max = df[col].max()\n#             if str(col_type)[:3] == 'int':\n#                 if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n#                     df[col] = df[col].astype(np.int8)\n#                 elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n#                     df[col] = df[col].astype(np.int16)\n#                 elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n#                     df[col] = df[col].astype(np.int32)\n#                 elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n#                     df[col] = df[col].astype(np.int64)\n#             else:\n#                 if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n#                     df[col] = df[col].astype(np.float16)\n#                 elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n#                     df[col] = df[col].astype(np.float32)\n#                 else:\n#                     df[col] = df[col].astype(np.float64)\n\n#     end_mem = df.memory_usage().sum() \/ 1024**2\n#     print('Memory usage after optimization is: {:.2f} MB'.format(end_mem))\n#     print('Decreased by {:.1f}%'.format(100 * (start_mem - end_mem) \/ start_mem))\n\n#     return df","1635cf9f":"crypto_df.info()","e9fea0c2":"# crypto_df = reduce_mem_usage(crypto_df)","06cbca5d":"asset_details = pd.read_csv('..\/input\/g-research-crypto-forecasting\/asset_details.csv')\nasset_details.sort_values(\"Weight\", ascending=False)","3134beb4":"for n in range(14):\n    print(\"Asset_ID =\",n)\n    crypto_n = crypto_df[crypto_df[\"Asset_ID\"]==n]\n    print(crypto_n.isna().sum())\n    print('')","30604c50":"print(crypto_df.duplicated().sum())","91b8042b":"crypto_merge = pd.merge(crypto_df, asset_details, how=\"left\", on=\"Asset_ID\")\ncrypto_merge['datetime'] = pd.to_datetime(crypto_merge['timestamp'], unit='s') #Step1\ncrypto_merge['datetime_d'] = crypto_merge['datetime'].dt.strftime(\"%Y-%m-%d\")  #Step2\ndf_g = crypto_merge.groupby(by = [\"Asset_Name\", 'datetime_d']).mean()          #Step3\ncrypto_mergee=df_g.reset_index()                                               #Step4\ncrypto_mergee.drop(['timestamp'],axis='columns', inplace=True)                 #Step5\ncrypto_mergee.head()","e8685683":"def lineplot(df,varible):\n\n    fig, ax = plt.subplots(figsize=(20,10))\n\n    sns.lineplot(x='datetime_d', y=varible, hue='Asset_Name', \n                       data=df,legend='brief').set_title(\"Cryptocurrency \"+ varible)\n    plt.ylabel(varible+ ' Price')\n    plt.xticks(rotation = 25)\n    ax.xaxis.set_major_locator(mdates.AutoDateLocator())\n    plt.legend(title_fontsize='20')","5a451d1e":"lineplot(crypto_mergee,'Open')","27756df2":"lineplot(crypto_mergee,'Close')","f9743f6c":"fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(12, 6))\n\ncrypto_mean=crypto_mergee[[\"Asset_Name\",\"Close\"]].groupby(\"Asset_Name\")[\"Close\"].agg([\"mean\"])\ncrypto_mean=crypto_mean.sort_values(by='mean',ascending=False)\nmy_cmap = plt.get_cmap(\"viridis\")\ncrypto_mean.plot(kind=\"bar\", ax=ax, color=my_cmap.colors, title=\"Mean Open Price\")","b579fae6":"df_exclud=crypto_mergee[~crypto_mergee['Asset_Name'].isin(['Bitcoin'])]\nlineplot(df_exclud,'Open')\n","0b8921f9":"lineplot(crypto_mergee,'Volume')","c3cb37ef":"labels= crypto_merge['Asset_Name'].value_counts().index\n\nf, ax = plt.subplots(figsize=(15, 6))\nsns.countplot(x='Asset_Name', data=crypto_merge,\n              order = labels,\n              palette=\"Set2\"\n           )\nplt.xticks(rotation= 45,fontsize=12 )\nax.set_ylabel('Asset count', fontsize=15, color='r')\nax.set_xlabel('Asset', fontsize=14, color='r')","5cc7c434":"labels = asset_details['Asset_Name']\nvalues = asset_details['Weight']\n\nfig = go.Figure(data=[go.Pie(labels=labels, values=values, textinfo='label+percent',\n                             insidetextorientation='radial',title='Weights for each cryptocurrency'\n                            )])\nfig.show()","77eb8c39":"grouped = crypto_mergee.groupby('Asset_Name')\nfor name,group in grouped:\n\n            \n    # plot the open price\n    \n    x = group['datetime_d']\n    y = group[\"Open\"]\n    \n    fig = go.Figure()\n    \n    fig.add_trace(go.Scatter(x=x, y=y))\n    \n    # Set title\n    fig.update_layout(\n        title_text=\"Time series plot of \" +name+ \" Open Price\",\n    )\n    \n    fig.update_layout(\n        xaxis=dict(\n            rangeselector=dict(\n                buttons=list(\n                    [\n                        dict(count=1, label=\"1m\", step=\"month\", stepmode=\"backward\"),\n                        dict(count=6, label=\"6m\", step=\"month\", stepmode=\"backward\"),\n                        dict(count=1, label=\"YTD\", step=\"year\", stepmode=\"todate\"),\n                        dict(count=1, label=\"1y\", step=\"year\", stepmode=\"backward\"),\n                        dict(step=\"all\"),\n                    ]\n                )\n            ),\n            rangeslider=dict(visible=True),\n            type=\"date\",\n        )\n    )\n    \n    iplot(fig)\n    ","175837de":"btc = crypto_df[crypto_df[\"Asset_ID\"]==1].set_index(\"timestamp\") # Asset_ID = 1 for Bitcoin\nbtc_mini = btc.iloc[-200:] # Select recent data rows","b93670dd":"import plotly.graph_objects as go\n\nfig = go.Figure(data=[go.Candlestick(x=btc_mini.index, open=btc_mini['Open'], high=btc_mini['High'], low=btc_mini['Low'], close=btc_mini['Close'])])\nfig.show()","0cc059da":"def check_gaps(df):\n    gap_list = []\n    for asset in df['Asset_Name'].unique():\n        coin_df = df[df['Asset_Name']==asset].set_index('timestamp')\n        df_asset = (coin_df.index[1:]-coin_df.index[:-1]).value_counts().reset_index()\n        n_gaps = df_asset[df_asset[\"index\"]!=60][\"timestamp\"].sum()\n        max_gap = df_asset[\"index\"].max()\n        gap_list.append([asset, n_gaps, max_gap])\n    gap_df = pd.DataFrame(gap_list)\n    gap_df.columns = [\"Asset_Name\", \"number_of_gaps\", \"max_gap_in_seconds\"]\n    return gap_df","a6261634":"check_gaps(crypto_merge)","88981c3a":"df_train = pd.DataFrame([])\nfor asset in crypto_merge['Asset_Name'].unique():\n    df_asset = crypto_merge[crypto_merge['Asset_Name']==asset].set_index('timestamp')\n    df_asset = df_asset.reindex(range(df_asset.index[0], df_asset.index[-1]+60, 60), method='ffill')\n    df_train = pd.concat([df_train, df_asset])\ndf_train.reset_index(level=0, inplace=True)","2d03ca5a":"df_train.head()","efa5650e":"check_gaps(df_train)","6f197e2b":"df_train['OC_diff']=df_train['Close']-df_train['Open']","4aea9513":"plt.figure(figsize=(15,8))\ndf_train1 = df_train.set_index('datetime')\nBitcoin = df_train1[df_train1[\"Asset_Name\"]=='Bitcoin']\nethe = df_train1[df_train1[\"Asset_Name\"]=='Ethereum']\nbtc_cash = df_train1[df_train1[\"Asset_Name\"]=='Bitcoin Cash']\nmone = df_train1[df_train1[\"Asset_Name\"]=='Monero']\n\n(Bitcoin['OC_diff']).plot(color='darkorange', label='Bitcoin')\n(mone['OC_diff']).plot(color='yellow', label='Monero')\n(ethe['OC_diff']).plot(color='cyan', label='Ethereum')\n(btc_cash['OC_diff']).plot(color='green', label='Bitcoin Cash')\n\nplt.xlabel('time')\nplt.ylabel('price in USD')\nplt.title('Historical difference between opening price and closing price of top 4 Crypto since 2018')\nplt.legend()\nplt.show()","94c5442a":"# calculate daily average price\ndf_train['daily_avg'] = (df_train['Open'] + df_train['High'] + df_train['Low'] + df_train['Close']) \/ 4","fd92c002":"# df_train['year'] = df_train.index.year\ndf_train['quarter'] = df_train.index.quarter\ndf_train['month'] = df_train.index.month\ndf_train['weekofyear'] = df_train.index.weekofyear\ndf_train['dayofyear'] = df_train.index.dayofyear\ndf_train['weekday'] = df_train.index.weekday","6c29b95c":"# define function to compute log returns\ndef log_return(series, periods=1):\n    # Copied from https:\/\/www.kaggle.com\/cstein06\/tutorial-to-the-g-research-crypto-competition\n    return np.log(series).diff(periods=periods)\n\n\nfor i, asset_id in enumerate(asset_details.Asset_ID):\n    df_train[('lret',  asset_id)] = log_return(df_train.Close)","b3bea6f2":"def upper_shadow(df):\n    return df['High'] - np.maximum(df['Close'], df['Open'])\n\ndef lower_shadow(df):\n    return np.minimum(df['Close'], df['Open']) - df['Low']\n","ebaab0ed":"# A utility function to build features from the original df\n# It works for rows to, so we can reutilize it.\n\ndf_train['Upper_Shadow'] = upper_shadow(df_train)\ndf_train['Lower_Shadow'] = lower_shadow(df_train)","30ca8d24":"df_train[\"high_div_low\"] = df_train[\"High\"] \/ df_train[\"Low\"]\ndf_train[\"open_sub_close\"] = df_train[\"Open\"] - df_train[\"Close\"]","d0009189":"totimestamp = lambda s: np.int32(time.mktime(datetime.strptime(s, \"%d\/%m\/%Y\").timetuple()))   \nassets_df = pd.DataFrame([])\nfor asset in crypto_merge['Asset_Name'].unique():\n    df_asset = crypto_merge[crypto_merge['Asset_Name']==asset].set_index('timestamp')\n    df_asset.loc[totimestamp('01\/07\/2021'):totimestamp('21\/09\/2021')]# check corr last 3 months in dataset\n    close_values = df_asset[\"Close\"].fillna(0)\n    close_values.name = asset\n    assets_df = assets_df.join(close_values, how=\"outer\")","6d9b8413":"plt.figure(figsize=(12,6))\nsns.heatmap(assets_df.corr(),vmin=0, vmax=1, cmap='coolwarm', annot=True)\nplt.title('Correlation Heatmap between Cryptos')\nplt.show()","d394c25d":"df_train = df_train[df_train.index < '2021-06-13 00:00:00']\n#df_train.tail()","4ce0f139":"!python3 -m pip install datatable --upgrade\nimport datatable as dt\ndt.Frame(df_train).to_jay(\"df_train.jay\")","c115ae4e":"Based on the heatmap as well as some of the previous plots, we can say that Bitcoin and Ethereum prices does have strong impact to other cryptocurrencies.\n\n- As the transaction volume of BitCoin and Ethereum increased, the volume of the other cryptocurrencies also increased.\n- Prices of other cryptocurrency have strong positive correaltion with price of BitCoin","c8d29869":"# Dataset description\n\nNow, let's dive into the data! We start by loading the competition's dataset and inspecting its basic properties. ","6d830b50":"#### D-Upper and lower shadow : From [competition tutorial](https:\/\/www.kaggle.com\/cstein06\/tutorial-to-the-g-research-crypto-competition)","3beae4cd":"## Check Duplicated Values","7fabf32a":"### 2-Feature Engineering ","8527f95d":"We also view the asset information, including the list of all assets, the Asset_ID to asset mapping, and the weight of each asset used to weigh their relative importance in the evaluation metric","c03c9340":"## Correlation between assets\nCheck Pearson correlation coefficient to prove if BitCoin price influences price of other cryptocurrencies","39dc6596":"#### A-Difference between opening and closing price & daily average price","857905d5":"## sections\n1. [ Introduction](#introduction)\n2. [ Data_Quality_Assessment](#Data_Quality_Assessment)\n3. [ EDA](#EDA)\n4. [Preprocessing](#Preprocessing)\n5.[Forecasting](#Forecasting)<br>\n\n> ## Another Notebooks :[Crypo-LSTM-(2022 Actual Price :91%acc)](https:\/\/www.kaggle.com\/yassershrief\/crypo-lstm-2022-actual-price-91-acc\/edit) ,<br>[LGBM Regressor Forecasting and Evaluation](https:\/\/www.kaggle.com\/yassershrief\/lgbm-regressor-forecasting-and-evaluation\/edit)\n","dc07feb6":"## Data features\nWe can see the different features included in the dataset. Specifically, the features included per asset are the following:\n*   **timestamp**: All timestamps are returned as second Unix timestamps (the number of seconds elapsed since 1970-01-01 00:00:00.000 UTC). Timestamps in this dataset are multiple of 60, indicating minute-by-minute data.\n*   **Asset_ID**: The asset ID corresponding to one of the crytocurrencies (e.g. `Asset_ID = 1` for Bitcoin). The mapping from `Asset_ID` to crypto asset is contained in `asset_details.csv`.\n*   **Count**: Total number of trades in the time interval (last minute).\n*   **Open**:\tOpening price of the time interval (in USD).\n*   **High**:\tHighest price reached during time interval (in USD).\n*   **Low**: Lowest price reached during time interval (in USD).\n*   **Close**:\tClosing price of the time interval (in USD).\n*   **Volume**:\tQuantity of asset bought or sold, displayed in base currency USD.\n*   **VWAP**: The average price of the asset over the time interval, weighted by volume. VWAP is an aggregated form of trade data.\n*   **Target**: Residual log-returns for the asset over a 15 minute horizon. \n\nThe first two columns define the time and asset indexes for this data row. The 6 middle columns are feature columns with the trading data for this asset and minute in time. The last column is the prediction target, which we will get to later in more detail.\n\nWe also view the asset information, including the list of all assets, the `Asset_ID` to asset mapping, and the weight of each asset used to weigh their relative importance in the evaluation metric.","8e6acdc2":"We simply cannot implement it on the dataframe because the currencies are randomly located.<br>\nSo we will fill in the missing data for each currency separately and then collect them again in one dataframe","a6c3151e":"#### B-Time Features","ec55b545":"- The missing data in the Target column only\n- Bitcoin has the least number of missing target values and Monero the most.\n","902da242":"Finally i will drop the data after `2021-06-13` for traning processing... to understand why kindly refer to the [topic](https:\/\/www.kaggle.com\/c\/g-research-crypto-forecasting\/discussion\/285505)","bce1f9df":"**Question:**  <span style=\"color:#FE1C0A;\">What is the total Timestamps[entries] in this dataset for each asset? Are they equal? <\/span><br>","cd6f1f7a":"# Data_Quality_Assessment","499cc07e":"We see that from our plot there are two major spikes that might be influential on our model.<br>\nWe can also tell that the fluctuation in our price exaggerates as year increases.","377035ff":"# Forecasting\n### Building the prediction model:","a1e3cb66":"I will do the following for faster and easier EDA, This will greatly help us reduce the time and memory used:\n- Using the **merge()** function, for each of the rows in the `crypto_df` table, the corresponding coordinates are added from the `asset_details` table.\n-  resample the minute Unix timestamps to daily timestamps. This reduces the amount of samples from 24,236,806 to 18102.<br>\n  **Step1** create new time column with (mm.dd.yyyy) and (H:MM:SS) format using `pd.to_datetime`<br>\n  **Step2** convert the previous column to column with (mm.dd.yyyy) format using `dt.strftime`<br>\n  **Step3** because the different currencies are randomly located in our dataset then we use `groupby()` function to split the data into groups based on `Asset_Name`, `datetime_d`<br>\n  **Step4** For a dataframe with a MultiIndex, `reset_index()` function is used to generate a new DataFrame with the index reset<br>\n  **Step5** drop `timestamp` column<br>\n  ","fdef1a90":"We can visualize a slice of the Bitcoin prices using the `plotly` library. The bottom part of the plot shows a rangeslider, which you can use to zoom in the plot.","41bc8af0":"**It seems that there is a strong correlation between the currencies each other**","23ad73bd":"## Check Missing Values","71cb5728":"## Candlestick charts\n\nThe trading data format is an aggregated form of market data including for`Open, High, Low and Close`. We can visualize this data through the commonly used candlestick bar chart, which allows traders to perform technical analysis on intraday values. The bar's body length represents the price range between the `open` and `close` of that day's trading. When the bar is **red**, it means the `close` was lower than the `open`, and **green** otherwise. These are also referred to as bullish and bearish candlesticks. The wicks above and below the bars show the `high` and `low` prices of that interval's trading.","ee486d96":"# Preprocessing\n","03cfb56a":"#### E-Technical Indicators Features :\n- It is a Technical Analysis library useful to do feature engineering from financial time series datasets (Open, Close, High, Low, Volume)\n- **Ta** is very helpful library, but kernel doesn't support. You can learn more about the library [here](https:\/\/github.com\/bukosabino\/ta)\n- There is more than 42 indicators i will try to implement it manually later","c684457d":"#### Insights\n- nothing really happened before July 2020, 2021 was seemingly a popularity year for the **Dogecoin** .<br>\n","facee596":"**Question:** \n<span style=\"color:#FE1C0A;\">What is the difference between the highest and lowest trading price for a particular currency?<\/span><br>","fcf96aeb":"# EDA","989a2e4f":"**We can create a function to plot data :** ","8b0fbc6f":"There is no duplicated appointments record in this data set.","e140c674":"\n## Forecasting returns\n\nA fundamental task in financial modeling is predicting how prices will behave in the near future. Using the time-series of historical prices as training data, we want to predict if prices will go up or down, and by how much, namely the asset *returns*.\n\nIn this competition,the challenge is build machine learning models to predict the returns of `14 popular cryptocurrencies`, in the time scale of minutes to hours. You will have access to millions of rows of minute-by-minute cryptocurrency trading data, with which you'll design your forecasting models for all 14 assets simultaneously. Your predictions will be evaluated by how much they correlate with real market data collected during the three-month evaluation period after the competition has closed. \n\n","471c754d":"#### Check... ","bc07583a":"#### C-Lag Features","26600b25":"**Question:** <span style=\"color:#FE1C0A;\"> How far is the average price of Bitcoin from other cryptocurrencies, in descending order? <\/span><br>","d4e16126":"<a id=\"1\"><\/a> <br>\n#  Introduction","f8eeecb6":"### To be Continue.....<br>\n### [Machine Learning Models](https:\/\/www.kaggle.com\/yassershrief\/lgbm-regressor\/edit)","97875d99":"#### Insights\n- As we can see from open and close plots, nothing really happened before 2021 (Only Bitcoin had some transactions), 2021 was seemingly a breakthrough year for the cryptocurrency ecosystem.<br>\n- As the price of BitCoin increased, the price of the other cryptocurrencies also increased.","b00e6aec":"**Question:** <span style=\"color:#FE1C0A;\"> What is the quantity of assets bought or sold overtime? <\/span><br>\n","b086b6eb":"![bitcoin-drop.jpg](attachment:ee209154-c92c-41df-b04c-911cff1ca287.jpg)","c4ac7351":"**Question:** <span style=\"color:#FE1C0A;\"> What is the different price scales between the different cryptocurrencies over time? <\/span><br>\n","58e10a97":" let\u2019s do a quick visualization of our price column using the **plotly library**, which provides interactivity.","4a1628d6":"**Question:** \n<span style=\"color:#FE1C0A;\">What are the changes in currency prices separately in different time periods (a month, 6 months or a year)<\/span><br>","a8c7d5fd":"**Our data is quite large...**","f6d8ae63":"**Datatable** (heavily inspired by R's data.table) can read large datasets fairly quickly and is often faster than pandas. It is specifically meant for data processing of tabular datasets with emphasis on speed and support for large sized data. \ud83d\udc4c","9d10ba5a":"Notice that there are many gaps in the data. To work with most time series models, we should preprocess our data into a format without time gaps. To fill the gaps, we can use the `.reindex()` method for **forward filling**, filling gaps with the previous valid value.<br>\n\nWe know that the data is collected once every 60 seconds. If we have a gap of more than one minute between consecutive rows, then it indicates that the data is missing in between. Let us check that for each of the coins.\nThanks for [clarifying](https:\/\/www.kaggle.com\/sudalairajkumar\/simple-exploration-notebook-crypto-forecasting).","79a737f2":"#### Save dataframe into jay file <br>\nMay I recommend the [notebook](https:\/\/www.kaggle.com\/rohanrao\/tutorial-on-reading-large-datasets#Format:-jay) and this [topic](https:\/\/www.kaggle.com\/c\/g-research-crypto-forecasting\/discussion\/285291) to reading and saving large datasets","f89e3b26":"By plotting the difference between daily opening and closing price, we found that:\n\n- Daily opening price and closing price of BitCoin and BitCoin Cash varies the most, the differences can range from 1000 to more than 3000 dollars.\n- The rest of the cryptocurrencies that we selected tends to be fairly stable","60223489":"## Load the training set","d1b11404":"## 1-Dealing with missing data","b039d8dc":"**Question:** <span style=\"color:#FE1C0A;\"> What is the correlation between other currencies apart from Bitcoin? <\/span><br>\n","36097e2b":"**Question:** \n<span style=\"color:#FE1C0A;\">What's the percentage of weights given to each asset ?<\/span><br>\nusing **plotly library** with one single line"}}