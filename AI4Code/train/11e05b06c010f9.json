{"cell_type":{"ef9dfa8a":"code","252a2df7":"code","55effaa1":"code","82d34ee3":"code","bcf76749":"code","2bb42d8e":"code","70bd02b7":"code","27302e51":"code","468b4d34":"code","cf23f4c5":"code","06794845":"code","980a2154":"code","2d356ba1":"code","a6838da4":"code","d7736e39":"code","c20ca1f6":"code","0ebce973":"code","42a33b5f":"code","9134e7e4":"code","57a8fd46":"code","25aa1923":"code","6bc2fa0d":"code","02806fd9":"code","2ce62ae4":"code","ec745802":"code","6a08ce7d":"code","e24f2954":"code","4de97a40":"code","fa8043bd":"code","f56059c4":"code","1eeb6c82":"code","7b9a2a44":"code","3335b843":"code","1e9c3612":"code","e192e145":"code","2e1280d1":"code","a13c7a70":"code","5f222306":"code","c516f08d":"code","38840c8a":"code","c84a732f":"code","3504a2e6":"code","4b0bc98a":"code","8c86166c":"code","c1597fb5":"code","02bea1b3":"code","469e4cfc":"code","eeec0d08":"code","c704bc6c":"code","cec4bd8f":"code","0e80269d":"code","b8f1fbcf":"code","611f488d":"code","6e7e93df":"code","68ceb25a":"code","07fec29d":"code","20a42ea4":"code","3115c21a":"code","59cd31fe":"code","26e47ea9":"code","096b5080":"code","1a1a8395":"code","85dfc32f":"code","abfea566":"code","cc0826a3":"code","8e5692d0":"code","03ca2b59":"code","dfb2eff7":"code","b897f8d5":"code","239b27fb":"code","ea8416ec":"code","bfce1695":"code","c8352864":"code","50d27400":"code","ad246a9b":"code","e43ba4ef":"code","579db64a":"code","4d245cf4":"code","48dc72a6":"code","8615ac5d":"code","18e11d06":"code","003ac2c1":"code","92cab057":"code","e4299134":"code","ba50eb25":"code","33538048":"code","63b77a45":"code","f8b43610":"code","2d51c179":"code","243b219a":"code","16c87ad8":"code","1f172e87":"code","a207c62f":"code","e9bd5d0a":"code","dbb546ea":"code","d89e994f":"code","198ee128":"code","851b51b2":"code","ff604c38":"code","943f1615":"code","9388a034":"code","f4e2f153":"code","0bd4357f":"code","da777c46":"code","d1a5e866":"code","f70e0c5c":"code","28056de1":"code","3e112f70":"code","331b9ca8":"code","d4fd5eb7":"code","0cf79ddf":"code","7eee77ba":"code","4b5201f9":"code","36a7359c":"code","9fc5343d":"code","51ca98e3":"code","db37cd5a":"code","c16ae613":"code","35653cd7":"code","5c5e9b69":"code","2b8ec698":"code","b3c7c64d":"code","58090838":"code","5a9e53c1":"code","3120a024":"code","c67bee8d":"code","80a86aa8":"code","2d385200":"code","963d0f72":"markdown","55bb2626":"markdown","577fc1d1":"markdown","c609e490":"markdown","abc74bac":"markdown","52185847":"markdown","6b302609":"markdown","cac33592":"markdown","109fa1d1":"markdown","ba02d702":"markdown","fc759350":"markdown","1a1da6ab":"markdown","eeb78b18":"markdown","a5afb69e":"markdown","b9d24104":"markdown","787d3588":"markdown","45b8feb1":"markdown","df1c31d1":"markdown","5357ed91":"markdown","dcd9745f":"markdown","97001e27":"markdown","20957275":"markdown","c45303d5":"markdown","3cf10ef2":"markdown","3a1ba1cb":"markdown","c7af09b6":"markdown","8a406bf1":"markdown","0bce28d2":"markdown","b7c815a3":"markdown"},"source":{"ef9dfa8a":"import numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\n#sns.set() #To set style\n\nimport warnings\nwarnings.filterwarnings('ignore')","252a2df7":"np.array([10,20,30],dtype=float)","55effaa1":"np.zeros(10)","82d34ee3":"np.zeros((3,3))","bcf76749":"np.ones(10)","2bb42d8e":"np.ones((3,3))","70bd02b7":"np.full(3,3.14)","27302e51":"np.full((3,3),3.14)","468b4d34":"np.eye(3)","cf23f4c5":"np.arange(0,10,2)","06794845":"np.linspace(0,10) #By default 50","980a2154":"np.linspace(0,10,10) #Giving 10 equally spaced value between 0 and 10","2d356ba1":"np.random.random(5) #Uniformly distributed random number between 0 and 1","a6838da4":"np.random.random((3,3))","d7736e39":"np.random.randint(0,10) #Random Integer between 0 and 10","c20ca1f6":"np.random.randint(0,10,3)","0ebce973":"np.random.randint(0,10,(3,3))","42a33b5f":"np.random.randn(5) #5 normally distributed numbers","9134e7e4":"np.random.randn(3,3)","57a8fd46":"np.empty(3)  #an empty array of default values","25aa1923":"np.empty((3,3))","6bc2fa0d":"x1=np.random.randint(10,size=6)\nx2=np.random.randint(10,size=(3,4))\nx3=np.random.randint(10,size=(3,4,5))#3,4*5 matrix ","02806fd9":"x1","2ce62ae4":"x2","ec745802":"x3","6a08ce7d":"x3.shape","e24f2954":"x3.ndim","4de97a40":"x3.size","fa8043bd":"x3.itemsize #size of each block","f56059c4":"x3.nbytes #total memory size","1eeb6c82":"grid=np.arange(0,9).reshape(3,3)","7b9a2a44":"grid","3335b843":"x=np.array([1,2,3])","1e9c3612":"x.reshape((1,3)) #it converted in to 2D Array","e192e145":"x[np.newaxis,:] #added extra axis rowise","2e1280d1":"x[:,np.newaxis] #Added extra axis columnwise","a13c7a70":"x=x\ny=np.array([3,2,1])","5f222306":"np.concatenate([x,y]) #Combining 2 array together","c516f08d":"grid=np.array([[1,2,3],\n              [4,5,6]])\ngrid","38840c8a":"np.concatenate([grid,grid])","c84a732f":"np.concatenate([grid,grid],axis=1)","3504a2e6":"np.vstack([x,grid])","4b0bc98a":"y=np.array([[99],\n           [99]])","8c86166c":"np.hstack([grid,y])","c1597fb5":"arr=np.arange(10)\narr","02bea1b3":"np.split(arr,[3,5])  #Spliting intial array on index 3 and 5","469e4cfc":"grid=np.arange(16).reshape((4,4))\ngrid","eeec0d08":"upper,lower=np.vsplit(grid,[2])\nprint(upper)\nprint(\"\\n\")\nprint(lower)","c704bc6c":"left,right=np.hsplit(grid,[2])\nprint(left)\nprint(\"\\n\")\nprint(right)","cec4bd8f":"np.add(x,2)  #it is similar to x+2, Universal Functions","0e80269d":"x=np.array([5-2j,4-3j])  #abs will return magnitude of complex number\nnp.abs(x)","b8f1fbcf":"x=np.arange(5)\ny=np.empty(5)\n\nnp.multiply(x,10,out=y) #multiplying x with 10 and then putting the answer in y to save memory\n\ny","611f488d":"y=np.zeros(10)\n\nnp.power(2,x,out=y[::2])\n\ny","6e7e93df":"x=np.arange(1,6)\nx","68ceb25a":"np.add.reduce(x)  #reducing array up to end of element and adding simuntanously","07fec29d":"np.add.accumulate(x) #we can see how it is accumulating to result","20a42ea4":"np.multiply.reduce(x)","3115c21a":"np.multiply.accumulate(x)","59cd31fe":"np.cumsum(x)  #Cummulative sum","26e47ea9":"np.cumprod(x)","096b5080":"x=np.arange(1,6)\nx","1a1a8395":"np.multiply.outer(x,x) #See the pattern to find out what it is doing","85dfc32f":"m=np.random.random((3,4))\nm","abfea566":"m.sum()   #returning whole sum","cc0826a3":"m.sum(axis=0)  #sum of all colums","8e5692d0":"m.sum(axis=1) #along row","03ca2b59":"a=np.array([1,2,3])\nb=np.array([4,5,6])\n\na+b","dfb2eff7":"a+5 #adding scaller to another size array","b897f8d5":"arr=np.ones((3,3))\narr","239b27fb":"arr+a #adding 1,2,3 in each row, broadcasting smaller array over higher dimension","ea8416ec":"a=np.arange(3)\nb=np.arange(3)[:,np.newaxis]","bfce1695":"print(a)\nprint(\"\\n\")\nprint(b)","c8352864":"a+b #adding 0 to first column of b then 1 to first column and so on","50d27400":"import matplotlib.pyplot as plt\n%matplotlib inline\n\nx=np.linspace(0,10,50)\ny=np.linspace(10,20,50)[:,np.newaxis]\nz=x**2+y**2\n\nplt.imshow(z,cmap='viridis')","ad246a9b":"x=np.array([1,2,3,4,5])\nx","e43ba4ef":"2*x==x**2","579db64a":"x=np.random.randint(10,size=(3,4))\nx","4d245cf4":"x<6","48dc72a6":"np.count_nonzero(x<6) #9 Values less than 6","8615ac5d":"np.sum(x<6,axis=0) #counting true x<6 columnwise","18e11d06":"np.sum(x<6,axis=1) #Counting <6 rowise","003ac2c1":"np.any(x<6) #Are there any value less than 6?","92cab057":"np.all(x<6) #Are all the value less than 6?","e4299134":"np.any(x<6,axis=0) #Are there any value less than 6 in each column?","ba50eb25":"np.any(x<6,axis=1) #Are there any value less than 6 in each row?","33538048":"x[x<5]  #selecting only those value with less than 5","63b77a45":"bool(42)","f8b43610":"bool(0)","2d51c179":"bool(42) and bool(0)","243b219a":"bool(42) or bool(0)","16c87ad8":"bin(42)","1f172e87":"bin(59)","a207c62f":"bin(42 & 59)","e9bd5d0a":"bin(42 | 59)","dbb546ea":"A=np.array([0,1,0,1,0,1])\nB=np.array([1,0,1,0,1,0])\nprint(A)\nprint(\"\\n\")\nprint(B)","d89e994f":"A & B #this is okay because we are applying on bits, but using A and B will raise an error","198ee128":"#A and B #This error is because we are applyinh and operator on bits which is impossible.","851b51b2":"x=np.random.randint(100,size=10)\nx","ff604c38":"x[[1,2,6]] #Printing value at index 1,2 and 6","943f1615":"index=np.array([[3,7],\n                [4,5]])\nindex","9388a034":"x[index] #it is filling value at these position from value at those position in that array","f4e2f153":"x=np.arange(0,12).reshape((3,4))\nx","0bd4357f":"x[2,[2,0,1]] #selecting from 2nd row, 2th,0th & 1th column value","da777c46":"x=np.random.randn(100,2)\nx[:5,:]","d1a5e866":"indices=np.random.choice(x.shape[0],20,replace=False) #Selecting 20 random points between 0 to 100\nindices","f70e0c5c":"sub_array=x[indices,:] #We can see we only have those indices which we have given\nsub_array","28056de1":"x=np.arange(10)\ni=np.array([2,1,8,4])\nx[i]=99  #Changing value at 2th,1th,8th and 4th position to 99\nprint(x)","3e112f70":"i=[2,3,3,4,4,4]\nx=np.zeros(10)\nnp.add.at(x,i,1)  #Add 1 at ith position\nprint(x)","331b9ca8":"i=[2,3,3,4,4,4]\nx=np.zeros(10)\nx[i]+=1  #Add 1 at ith position, But here addition is not happening multiple times\nprint(x)","d4fd5eb7":"np.random.seed(42)\nx=np.random.randn(100)\nx[0:5]\n\n#Compute Histogram by Hand\nbins=np.linspace(-5,5,20)\ncounts=np.zeros_like(bins) #Returns array like bins with zeros\n\n#finding an appropriate bin for each x\ni=np.searchsorted(bins,x)\n\nnp.add.at(counts,i,1)\n\nplt.plot(bins,counts,ls='steps')","0cf79ddf":"sns.distplot(x,bins=20,kde=False) #You can see same work with just one line of code","7eee77ba":"def selection_sort(x):\n    for i in range(len(x)):\n        swap=i+np.argmin(x[i:])\n        (x[i],x[swap])=(x[swap],x[i])\n    return x","4b5201f9":"x=np.array([40,30,20,10])\nselection_sort(x)\nprint(x)","36a7359c":"x=np.array([45,52,56,2,3,4])\nnp.sort(x) #Note this is just printing, not changing intial array","9fc5343d":"x.sort() #Now this will change initial array\nprint(x)","51ca98e3":"x=np.random.randint(10,size=10)\nx","db37cd5a":"np.argsort(x) #This is returning indices of sorted array in increasing order","c16ae613":"print(x.argsort(),\"\\n\")\nprint(\"Please do not confuse that initial x will change in this also\")\nprint(x)","35653cd7":"x=np.random.randint(10,size=(6,4))\nx","5c5e9b69":"np.sort(x,axis=0) #Along column","2b8ec698":"np.sort(x,axis=1) #Along Row","b3c7c64d":"x.sort(axis=0) #This will change initial array also\nx","58090838":"x=np.random.randint(10,size=10)\nx","5a9e53c1":"np.partition(x,3) #First 3 elements are smallest and after that in arbitrary order","3120a024":"x=np.random.randint(10,size=(4,6))\nx","c67bee8d":"np.partition(x,3,axis=1) #ALong row","80a86aa8":"np.partition(x,3,axis=0) #Along Column","2d385200":"np.argpartition(x,3,axis=1) #Similar to argsort but returning in partition","963d0f72":"Broadcasting is simply a\nset of rules for applying binary ufuncs (addition, subtraction, multiplication, etc.) on\narrays of different sizes.","55bb2626":"**Partial Sorting**","577fc1d1":"**There is a common confusion between and,or AND &,|...... Not &,| works on bits of numbers**","c609e490":"**Combining Fancy and Simple Indexing**","abc74bac":"**Sorting Along row and column for multidimensional array**","52185847":"# Fancy Indexing\n\nFancy  indexing  is  like  the  simple  indexing  we\u2019ve  already  seen,  but  we  passarrays  of  indices  in  place  of  single  scalars.  This  allows  us  to  very  quickly  access  andmodify complicated subsets of an array\u2019s values.","6b302609":"# Sorting Array","cac33592":"# Concatenate & Split","109fa1d1":"Rules of Broadcasting\n\nBroadcasting in NumPy follows a strict set of rules to determine the interaction\nbetween the two arrays:\n\n\u2022 Rule 1: If the two arrays differ in their number of dimensions, the shape of the\none with fewer dimensions is padded with ones on its leading (left) side.\n\n\u2022 Rule 2: If the shape of the two arrays does not match in any dimension, the array\nwith shape equal to 1 in that dimension is stretched to match the other shape.\n\n\u2022 Rule 3: If in any dimension the sizes disagree and neither is equal to 1, an error is\nraised.","ba02d702":"**We can use others aggregate functions as well in same manner for multidimensional array**","fc759350":"# Boolean Arrays as Masks\nIn  the  preceding  section,  we  looked  at  aggregates  computed  directly  on  Booleanarrays. A more powerful pattern is to use Boolean arrays as masks, to select particularsubsets  of  the  data  themselves.  Returning  to  our  x  array  from  before,  suppose  wewant an array of all values in the array that are less than, say, 5:","1a1da6ab":"**np.percentile(heights, 25))**\n*np.median(heights))*\n**np.percentile(heights, 75))**","eeb78b18":"**Selection Sort**","a5afb69e":"**With  fancy  indexing,  the  shape  of  the  result  reflects  the  shape  of  the  index  arraysrather than the shape of the array being indexed:**","b9d24104":"**any ufunc can compute the output of all pairs of two different inputs using\nthe outer method. This allows you, in one line, to do things like create a multiplica\u2010\ntion table:**","787d3588":"# Thank You\n**Thank you for reading this kernel, I hope this helped you to improve your numpy**\n*Please do an upvote*","45b8feb1":"**Dry Run**\n\n[40,30,20,10]\n\n\nFirst pass: i=0\nswap=0+3=3\n[10,30,20,40]\n\n\nsecond pass: i=1\nswap=1+1=2\nswap index 2 and 1\n[10,20,30,40]\n.\n.\n.\n.","df1c31d1":"**Modifying Value with Fancy Indexing**","5357ed91":"**There are many sorting algorithm, Fortunately Python built in are much more efficient.**","dcd9745f":"# Random Function","97001e27":"**Selecting Random Points using Fancy Indexing, which may help with working subset data from large dataset**","20957275":"Comparisons, Masks, and Boolean LogicThis  section  covers  the  use  of  Boolean  masks  to  examine  and  manipulate  valueswithin NumPy arrays. Masking comes up when you want to extract, modify, count, orotherwise  manipulate  values  in  an  array  based  on  some  criterion:  for  example,  youmight wish to count all values greater than a certain value, or perhaps remove all out\u2010liers  that  are  above  some  threshold.  In  NumPy,  Boolean  masking  is  often  the  mostefficient way to accomplish these types of tasks.","c45303d5":"# Ufuncs","3cf10ef2":"**Plotting 2D function(F(x,y)) using numpy and matplotlib**","3a1ba1cb":"# Basics","c7af09b6":"To count the number of True entries in a Boolean array, np.count_nonzero is useful:","8a406bf1":"***Note***\n\n**simple indices (e.g., arr[0]), slices (e.g., arr[:5]), and Boolean masks (e.g., arr[arr> 0])**","0bce28d2":"**Create Histogram using Numpy**\n\n**Note this is Optional, Everybody uses seaborn etc. for these type of works**\n\nWhy?\n\nBecause on smaller data is faster than default version of numpy, seaborn and matplotlib.","b7c815a3":"# Imp. Fucntions"}}