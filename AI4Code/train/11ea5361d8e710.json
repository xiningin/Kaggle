{"cell_type":{"c710ce65":"code","be3c1e28":"code","b25337c1":"code","51b6fb13":"code","d0710e08":"code","446a606c":"code","3a86a528":"code","de93e2f9":"code","7f6db02e":"code","59d38d8d":"code","7a0bb473":"code","15919af5":"code","d89460f9":"code","7262fb56":"code","2e48eb02":"code","9626cd96":"code","77864ebd":"code","5a3d969c":"code","c2502ae3":"code","61c219e2":"code","bc5cb447":"code","d875efb0":"code","c63028f5":"code","043b6a6f":"code","2add9e21":"code","0a876730":"code","1b9015e2":"code","1594dad6":"code","5200238d":"code","266a9855":"code","0c35481b":"code","b5821b84":"code","506b5701":"code","66732514":"code","a11e9e09":"code","aba81795":"code","c6a4c271":"code","6de2158b":"code","c2d8c5e2":"code","e2abcc63":"code","7434162b":"code","4dc36e29":"markdown","cfd67465":"markdown","68fefa12":"markdown","6baec0f4":"markdown","e37085c3":"markdown","5824d8a8":"markdown","e7272b6b":"markdown","804e4074":"markdown","aa0ee1c3":"markdown","4c6d2319":"markdown","969f4333":"markdown","c0d691a5":"markdown","8b221277":"markdown","dfbdf9d5":"markdown","bf31211b":"markdown","79a2d419":"markdown","bd7450cd":"markdown","092d390e":"markdown","64ef2cb0":"markdown","a272f418":"markdown","4480e219":"markdown","927dc16b":"markdown","a67e5731":"markdown","6f4e347b":"markdown","f32f6423":"markdown","6f02436e":"markdown","38b0c58b":"markdown","78c24d77":"markdown"},"source":{"c710ce65":"import pandas as pd\nimport numpy as np\nfrom datetime import datetime\nfrom lightgbm import LGBMRegressor\nimport gresearch_crypto\nimport traceback\nimport time\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nimport plotly.graph_objects as go\nfrom sklearn.model_selection import GridSearchCV\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split","be3c1e28":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","b25337c1":"path = \"\/kaggle\/input\/g-research-crypto-forecasting\/\"\ndf_train = pd.read_csv(path + \"train.csv\")\ndf_test = pd.read_csv(path + \"example_test.csv\")\ndf_asset_details = pd.read_csv(path + \"asset_details.csv\")\ndf_supp_train = pd.read_csv(path + \"supplemental_train.csv\")","51b6fb13":"# Checking Train data \ndf_train.head()","d0710e08":"df_train.shape","446a606c":"# Checking Test data set\ndf_test.head()","3a86a528":"df_test.shape","de93e2f9":"df_train.describe()","7f6db02e":"# Checking Test data sets\ndf_test.describe()","59d38d8d":"df_train.isnull().sum()","7a0bb473":"df_test.isnull().sum()","15919af5":"df_train.info()","d89460f9":"df_test.info()","7262fb56":"df_asset_details","2e48eb02":"df_supp_train","9626cd96":"df_supp_train.info()","77864ebd":"df_supp_train.isnull().sum()","5a3d969c":"# auxiliary function, from datetime to timestamp\ntotimestamp = lambda s: np.int32(time.mktime(datetime.strptime(s, \"%d\/%m\/%Y\").timetuple()))","c2502ae3":"df_train.Asset_ID.unique()","61c219e2":"df_train.Asset_ID.value_counts()","bc5cb447":"df_train[df_train['Asset_ID'] == 1].set_index(\"timestamp\")","d875efb0":"btc = df_train[df_train['Asset_ID'] == 1].set_index(\"timestamp\")","c63028f5":"datetime.fromtimestamp(btc.index[0])","043b6a6f":"# Starting Date Time\n# %A= day,%B = Month, %d = month number, %Y  = Year,%I =hours , %M =minutes starting date, %S = seconds\ndatetime.fromtimestamp(btc.index[0]).strftime(\"%A, %B %d, %Y  %I: %M: %S\")","2add9e21":"# Above function store in a starting date formate\nbeg_btc = datetime.fromtimestamp(btc.index[0]).strftime(\"%A, %B %d, %Y  %I: %M: %S\")","0a876730":"# Ending Date time\ndatetime.fromtimestamp(btc.index[-1]).strftime(\"%A, %B %d, %Y %I : %M : %S\")","1b9015e2":"end_btc = datetime.fromtimestamp(btc.index[-1]).strftime(\"%A, %B %d, %Y %I : %M : %S\")","1594dad6":"print('Bitcoin data goes from ', beg_btc, ' to ', end_btc)","5200238d":"## Checking Time Range\nbtc = df_train[df_train[\"Asset_ID\"]==1].set_index(\"timestamp\") # Asset_ID = 1 for Bitcoin\neth = df_train[df_train[\"Asset_ID\"]==6].set_index(\"timestamp\") # Asset_ID = 6 for Ethereum\nbnb = df_train[df_train[\"Asset_ID\"]==0].set_index(\"timestamp\") # Asset_ID = 0 for Binance Coin\nada = df_train[df_train[\"Asset_ID\"]==3].set_index(\"timestamp\") # Asset_ID = 3 for Cardano\n\nbeg_btc = datetime.fromtimestamp(btc.index[0]).strftime(\"%A, %B %d, %Y %I:%M:%S\") \nend_btc = datetime.fromtimestamp(btc.index[-1]).strftime(\"%A, %B %d, %Y %I:%M:%S\") \nbeg_eth = datetime.fromtimestamp(eth.index[0]).strftime(\"%A, %B %d, %Y %I:%M:%S\") \nend_eth = datetime.fromtimestamp(eth.index[-1]).strftime(\"%A, %B %d, %Y %I:%M:%S\")\nbeg_bnb = datetime.fromtimestamp(eth.index[0]).strftime(\"%A, %B %d, %Y %I:%M:%S\") \nend_bnb = datetime.fromtimestamp(eth.index[-1]).strftime(\"%A, %B %d, %Y %I:%M:%S\")\nbeg_ada = datetime.fromtimestamp(eth.index[0]).strftime(\"%A, %B %d, %Y %I:%M:%S\") \nend_ada = datetime.fromtimestamp(eth.index[-1]).strftime(\"%A, %B %d, %Y %I:%M:%S\")\n\nprint('Bitcoin data goes from ', beg_btc, ' to ', end_btc) \nprint('Ethereum data goes from ', beg_eth, ' to ', end_eth)\nprint('Binance coin data goes from ', beg_bnb, ' to ', end_bnb) \nprint('Cardano data goes from ', beg_ada, ' to ', end_ada)","266a9855":"plt.figure(figsize=(8,6))\nsns.heatmap(btc[['Count','Open','High','Low','Close','Volume','VWAP','Target']].corr(), \n            vmin=-1.0, vmax=1.0, annot=True, cmap='coolwarm', linewidths=0.1)\nplt.show()","0c35481b":"btc.iloc[-1440:]","b5821b84":"eth.iloc[-1440:]","506b5701":"# Checking 1 day candle stick chart 24hrs = 1440 mins\nbtc_mini = btc.iloc[-1440:]\neth_mini = eth.iloc[-1440:]\n\n# index = timestamp,\nfig = go.Figure(data=[go.Candlestick(x=btc_mini.index, open=btc_mini['Open'], high=btc_mini['High'], low=btc_mini['Low'], close=btc_mini['Close'])])\nfig.update_xaxes(title_text=\"$\")\nfig.update_yaxes(title_text=\"Index\")\nfig.update_layout(title=\"Bitcoin Price, Last 24 hours\")\nfig.show()\n\nfig = go.Figure(data=[go.Candlestick(x=eth_mini.index, open=eth_mini['Open'], high=eth_mini['High'], low=eth_mini['Low'], close=eth_mini['Close'])])\nfig.update_xaxes(title_text=\"$\")\nfig.update_yaxes(title_text=\"Index\")\nfig.update_layout(title=\"Ethereum Price,Last 24 hours\")\nfig.show()","66732514":"f = plt.figure(figsize=(15,4))\n\n# fill NAs for BTC and ETH\nbtc = btc.reindex(range(btc.index[0],btc.index[-1]+60,60),method='pad')\neth = eth.reindex(range(eth.index[0],eth.index[-1]+60,60),method='pad')\n\nax = f.add_subplot(121)\nplt.plot(btc['Close'], color='yellow', label='BTC')\nplt.legend()\nplt.xlabel('Time (timestamp)')\nplt.ylabel('Bitcoin')\n\nax2 = f.add_subplot(122)\nax2.plot(eth['Close'], color='purple', label='ETH')\nplt.legend()\nplt.xlabel('Time (timestamp)')\nplt.ylabel('Ethereum')\n\nplt.tight_layout()\nplt.show()","a11e9e09":"data =df_train[-10080:]\ncheck = pd.DataFrame()\nfor i in data.Asset_ID.unique():\n    check[i] = data[data.Asset_ID==i]['Target'].reset_index(drop=True) \n    \nplt.figure(figsize=(10,8))\nsns.heatmap(check.dropna().corr(), vmin=-1.0, vmax=1.0, annot=True, cmap='coolwarm', linewidths=0.1)\nplt.show()","aba81795":"def hlco_ratio(df): \n    return (df['High'] - df['Low'])\/(df['Close']-df['Open'])\ndef upper_shadow(df):\n    return df['High'] - np.maximum(df['Close'], df['Open'])\ndef lower_shadow(df):\n    return np.minimum(df['Close'], df['Open']) - df['Low']\n\ndef get_features(df):\n    df_feat = df[['Count', 'Open', 'High', 'Low', 'Close', 'Volume', 'VWAP']].copy()\n    df_feat['Upper_Shadow'] = upper_shadow(df_feat)\n    df_feat['hlco_ratio'] = hlco_ratio(df_feat)\n    df_feat['Lower_Shadow'] = lower_shadow(df_feat)\n    return df_feat","c6a4c271":"# Training data set\ntrain_data = df_train\ntrain_data","6de2158b":"def get_Xy_and_model_for_asset(df_train, asset_id):\n    df = df_train[df_train[\"Asset_ID\"] == asset_id]\n    \n    df = df.sample(frac=0.2)\n    df_proc = get_features(df)\n    df_proc['y'] = df['Target']\n    df_proc.replace([np.inf, -np.inf], np.nan, inplace=True)\n    df_proc = df_proc.dropna(how=\"any\")\n    \n    \n    X = df_proc.drop(\"y\", axis=1)\n    y = df_proc[\"y\"]   \n    model = LGBMRegressor()\n    model.fit(X, y)\n    return X, y, model\n\n\nXs = {}\nys = {}\nmodels = {}\n\nfor asset_id, asset_name in zip(df_asset_details['Asset_ID'], df_asset_details['Asset_Name']):\n    print(f\"Training model for {asset_name:<16} (ID={asset_id:<2})\")\n    X, y, model = get_Xy_and_model_for_asset(train_data, asset_id)       \n    try:\n        Xs[asset_id], ys[asset_id], models[asset_id] = X, y, model\n    except: \n        Xs[asset_id], ys[asset_id], models[asset_id] = None, None, None ","c2d8c5e2":"parameters = {\n    # 'max_depth': range (2, 10, 1),\n    'num_leaves': range(21, 161, 10),\n    'learning_rate': [0.1, 0.01, 0.05]\n}\n\nnew_models = {}\nfor asset_id, asset_name in zip(df_asset_details['Asset_ID'], df_asset_details['Asset_Name']):\n    print(\"GridSearchCV for: \" + asset_name)\n    grid_search = GridSearchCV(\n        estimator=get_Xy_and_model_for_asset(df_train, asset_id)[2], # bitcoin\n        param_grid=parameters,\n        n_jobs = -1,\n        cv = 5,\n        verbose=True\n    )\n    grid_search.fit(Xs[asset_id], ys[asset_id])\n    new_models[asset_id] = grid_search.best_estimator_\n    grid_search.best_estimator_","e2abcc63":"# Checking the Model interface\nfor asset_id, asset_name in zip(df_asset_details['Asset_ID'], df_asset_details['Asset_Name']):\n    print(f\"Tuned model for {asset_name:<1} (ID={asset_id:})\")\n    print(new_models[asset_id])","7434162b":"env = gresearch_crypto.make_env()\niter_test = env.iter_test()\n\nfor i, (df_test, df_pred) in enumerate(iter_test):\n    for j , row in df_test.iterrows():        \n        if new_models[row['Asset_ID']] is not None:\n            try:\n                model = new_models[row['Asset_ID']]\n                x_test = get_features(row)\n                y_pred = model.predict(pd.DataFrame([x_test]))[0]\n                df_pred.loc[df_pred['row_id'] == row['row_id'], 'Target'] = y_pred\n            except:\n                df_pred.loc[df_pred['row_id'] == row['row_id'], 'Target'] = 0\n                traceback.print_exc()\n        else: \n            df_pred.loc[df_pred['row_id'] == row['row_id'], 'Target'] = 0  \n    \n    env.predict(df_pred)","4dc36e29":"* Interestingly, in the last 1-weak we have several coins that are highly correlated with one another.","cfd67465":"# Submission","68fefa12":"# Ploting the Btc & Etherium","6baec0f4":"## **Loading Data**","e37085c3":"### **EDA**\n* Let's continue describing and analyzing the data ","5824d8a8":"* By checking train data and test data there is some missing values in train data set","e7272b6b":"* We can also confirm through another visual observation that, within the 4 recent years, BTC and ETH prices are correlated.","804e4074":"* By visualising Train and Test data set (train.csv) except contains less rows.","aa0ee1c3":"# Coin corelation for 1-weak","4c6d2319":"\n### **<span>Dataset Structure<\/span>**\n\n> **train.csv** - The training set\n> \n> 1.  timestamp - A timestamp for the minute covered by the row.\n> 2.  Asset_ID - An ID code for the cryptoasset.\n> 3.  Count - The number of trades that took place this minute.\n> 4.  Open - The USD price at the beginning of the minute.\n> 5.  High - The highest USD price during the minute.\n> 6.  Low - The lowest USD price during the minute.\n> 7.  Close - The USD price at the end of the minute.\n> 8.  Volume - The number of cryptoasset u units traded during the minute.\n> 9.  VWAP - The volume-weighted average price for the minute.\n> 10. Target - 15 minute residualized returns. See the 'Prediction and Evaluation section of this notebook for details of how the target is calculated.\n> 11. Weight - Weight, defined by the competition hosts [here](https:\/\/www.kaggle.com\/cstein06\/tutorial-to-the-g-research-crypto-competition)\n> 12. Asset_Name - Human readable Asset name.\n> \n>\n> **example_test.csv** - An example of the data that will be delivered by the time series API.\n> \n> **example_sample_submission.csv** - An example of the data that will be delivered by the time series API. The data is just copied from train.csv.\n> \n> **asset_details.csv** - Provides the real name and of the cryptoasset for each Asset_ID and the weight each cryptoasset receives in the metric.\n> \n> **supplemental_train.csv** - After the submission period is over this file's data will be replaced with cryptoasset prices from the submission period. In the Evaluation phase, the train, train supplement, and test set will be contiguous in time, apart from any missing data. The current copy, which is just filled approximately the right amount of data from train.csv is provided as a placeholder.\n>\n> - \ud83d\udccc There are 14 coins in the dataset\n>\n> - \ud83d\udccc There are 4 years  in the [full] dataset","969f4333":"#### **Btc**","c0d691a5":"# **Importing Libraries**","8b221277":"* There are total 14 unque coins","dfbdf9d5":"# Splitting","bf31211b":"# Selecting 4-Coins\n* Bitcoin  = btc\n* Etherium = eth\n* Binance  = bnb\n* Cardano  = ada","79a2d419":"## Timestamp\n* We define a helper function that will turn a date format into a timestamp to use for indexing.","bd7450cd":"# Hyperparam Tuning\n* We will perform GridSearch for each LGBM model of 14 coins.","092d390e":"**Bitcoin**","64ef2cb0":"# **LBGM**\n* LightGBM is a gradient boosting framework that uses tree based learning algorithms. It is designed to be distributed and efficient with the following advantages:\n* Faster training speed and higher efficiency (6 times faster than XGBoost)\n* Lower memory usage.\n* Better accuracy.\n* Support of parallel, distributed, and GPU learning.\n* Capable of handling large-scale data.","a272f418":"### ****Checking Time range****","4480e219":"### **Importing Data**","927dc16b":"* We can Observe the corelation b\/w two coins","a67e5731":"# Checking candle chart b\/w 2-coins Btc,Eth","6f4e347b":"# Checking candle stick for Etherium for last 24 hrs","f32f6423":"* seems like the VWAP column has NaN values we will check it later","6f02436e":"* Here we have 4-Years of data range 2018-2021","38b0c58b":"# Feature Extraction\n* we add some features for our future predection","78c24d77":"# Checking corelation of each individual coin\n* By using heatmap"}}