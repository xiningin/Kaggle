{"cell_type":{"8b21dfc8":"code","00f6d98c":"code","bf66ed69":"code","d1c0d29e":"code","be51b305":"code","daa573b8":"code","920da0bd":"code","f39cc24a":"code","9645a577":"code","c7137b74":"code","1382cb17":"markdown","abc49da9":"markdown","f5fbc2e1":"markdown","cbd3d3d6":"markdown","27c6a91b":"markdown","0a124d3f":"markdown","2afd3839":"markdown","a87cdd1f":"markdown","18c8d445":"markdown","0b6fd5a4":"markdown","4c9d0329":"markdown","30a0ef48":"markdown"},"source":{"8b21dfc8":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression","00f6d98c":"df = pd.read_csv(\"..\/input\/autos.csv\", encoding = \"iso8859-1\")\n\ndf = df.drop([\"dateCrawled\", \"abtest\", \"dateCreated\", \"nrOfPictures\", \"lastSeen\", \"postalCode\", \"seller\", \"offerType\", \"model\"], axis = 1)\n\n\ndf[\"monthOfRegistration\"] = np.where(df[\"monthOfRegistration\"] == 0, 6, df[\"monthOfRegistration\"])\ndf[\"registration\"] = df[\"yearOfRegistration\"] + (df[\"monthOfRegistration\"] -1) \/12\ndf = df.drop([\"yearOfRegistration\", \"monthOfRegistration\"], axis = 1)\n\ndf = df.drop(df[(df[\"powerPS\"] == 0) | (df[\"price\"] == 0)].index)\n\ndf[\"notRepairedDamage\"] = np.where(df[\"notRepairedDamage\"] == \"ja\", 1, df[\"notRepairedDamage\"])\ndf[\"notRepairedDamage\"] = np.where(df[\"notRepairedDamage\"] == \"nein\", 0, df[\"notRepairedDamage\"])\ndf = df[df[\"notRepairedDamage\"].notnull()]\n#convert values to integer so I can work with them \/ visualize them more easiliy\ndf[\"notRepairedDamage\"] = pd.to_numeric(df[\"notRepairedDamage\"])\n \ndf = df[(df[\"price\"] < 100000) & (df[\"powerPS\"] < 2000) & (df[\"registration\"] <= 2019)]","bf66ed69":"g = sns.pairplot(df.sample(300))\nplt.show()","d1c0d29e":"print(\"cars with unrepaired damage: \" + str(len(df[df[\"notRepairedDamage\"] == 1])))\nprint(\"cars without unrepaired damage: \" + str(len(df[df[\"notRepairedDamage\"] == 0])))\nprint(\"total cars: \" + str(245541 + 29962))\nprint(\"percentage with unrepaired damage: \" + str(100 \/ 275503 * 29962) + \"%\")\nprint(\"percentage without unrepaired damage: \" + str(100 \/ 275503 * 245541) + \"%\")\nlabels = 'no unrepaired damage', 'unrepaired damage'\nsizes = [89.12461933263884, 10.875380667361155]\nfig1, ax1 = plt.subplots()\nax1.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)\nax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.\nplt.title(\"Distribution of unrepaired damaged cars in data\", fontweight=\"bold\")\n\nplt.show()","be51b305":"print(df[df[\"notRepairedDamage\"]==1][\"price\"].mean())\nprint(df[df[\"notRepairedDamage\"]==0][\"price\"][:29962].mean())","daa573b8":"df2 = pd.get_dummies(df, columns = [\"vehicleType\", \"gearbox\", \"fuelType\", \"brand\"])\ndf2.head()","920da0bd":"df2 = df2[(df2[\"price\"] > 500) & (df2[\"price\"] < 20000)]","f39cc24a":"df2.head()","9645a577":"y = df2[[\"price\"]].values\nX = df2.drop([\"price\", \"name\"], axis = 1).values\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state = 0, test_size = 0.25)","c7137b74":"model = LinearRegression()\nmodel.fit(X_train, y_train)\nprint(model.score(X_test, y_test))","1382cb17":"**filter common cars and faulty prices**\n\nThe prices in the dataset are based on the amount the private seller has set in the specific field on eBay. There are people that set the amount to an extremely low amount, such as 1 euro and then write the real price down in the description, which we can't recognize. \n\nTo filter *common* cars and remove the faults I mentioned, I will filter the price once again and set the scale between 500 and 20000 for a *common* used cars. This means that the model will only work for those!","abc49da9":"### Conclusion:\n\nWe managed to achieve a coefficient of determination of around 62% with the model, which is okay but not very good. Sadly, as I mentioned the data has a lot of flaws, such as that the prices are not based on the market, but based on what private sellers type in the specific field on eBay. I tried to filter the data and narrow it down the remove faulty values and only include cars that can be categorized as *common*.\n\nThere can be still done some things, such as include the postal Code and find out whether the locations have an impact on the price. Maybe people have more money in one town and pay more for the same used car? This, for example, can be done through clustering.","f5fbc2e1":"**train model and calculate r2 score**","cbd3d3d6":"# Predict prices of commonly used cars on eBay using linear regression\n\n### Structure\n- import libraries\n- load and prepare the dataset\n- explore data \n- linear regression\n- coefficient of determination\n- conclusion","27c6a91b":"### Explore data\n\n**Pairplot to get a distribution overview and detect first correlations between columns**\n\n- reduce sample volume to 300 to get a clearer visualization\n- use seaborn to create a pairplot with all columns that contain metric data\n\nInsights:\n- The higher the PS, the higher the price\n- The higher the kilometer count, the lower the price\n- The higher the registration date\/year, the higher the price","0a124d3f":"### Load and prepare dataset\n\n- remove columns that I do not want to fit the model with\n- replace or remove 0 and NaN values\n- calculate and create new column \"registration\" with year and month of registration in year.month form starting with year.0 from january\n- filter the DataFrame with common car prices\/ps and remove rows with faulty registration dates that are in the future (over 2019)","2afd3839":"**train-test-split**\n- split data into train and test data so I will be able to test the accuracy of my model with data it has not seen yet.","a87cdd1f":"### Linear Regression\n\n* one hot encoding\n* filter common cars and faulty prices\n* train-test-split\n* linear regression\n* r2 score","18c8d445":"So do I still fit my model with this column?\n\nYes, because it is obvious that cars that have unrepaired damages lose value and thus are meaningful for my model to predict prices for common cars. Also, if I cut the number of cars that have no unrepaired damage to the total number of cars that have unrepaired damages and then compare the prices, the mean price is a lot lower on cars with unrepaired damages.","0b6fd5a4":"**One hot encoding**\n- create new columns based on the nomial values in \"vehicleType\", \"gearbox\", \"fuelType\", \"brand\" with 1 and 0 values (depending on if the values\/parameters are given in the car) to be able to fit them into the linear regression.","4c9d0329":"**Not repaired Damages**\n\nDue to the fact that I have a lot less data on cars that have not repaired Damages than cars that don't have unrepaired damages the graph is not meaningful enough for that column. The reason is that around 80% of the data contain cars that have no unrepaired damage.\n\nOne way to solve that would be to compare identical cars with exactly the same parameters (kilometer, registration, ps, etc.) and see if there are any changes in the price if they have unrepaired damages or not.\n\nSadly the data does not contain enough resources to do that.","30a0ef48":"### import Libaries"}}