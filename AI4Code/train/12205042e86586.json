{"cell_type":{"096a7e9e":"code","293eace8":"code","cba322d0":"code","fb28ae5e":"code","63338628":"code","6d1dca9e":"code","c2f81e6c":"code","f35afc44":"code","9bd213d2":"code","00155692":"code","a144110e":"code","e43cc23d":"code","62a354cb":"code","7c2e2ced":"code","af4e7229":"code","0bc7bd78":"code","e90144d4":"code","bef8a505":"code","6105b1f6":"code","987e0953":"code","03ca0401":"code","695dd99d":"code","2ca3e262":"code","a997f59c":"markdown","a0963578":"markdown","ceee24c9":"markdown","53169596":"markdown","802c7fda":"markdown","e67b7d85":"markdown","36d94c17":"markdown","59bbe51b":"markdown"},"source":{"096a7e9e":"import numpy as np \nimport pandas as pd \n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n# Any results you write to the current directory are saved as output.","293eace8":"pokemon = pd.read_csv('..\/input\/pokemon\/Pokemon.csv')","cba322d0":"pokemon.head()","fb28ae5e":"pokemon.info()","63338628":"Legend = pd.get_dummies(pokemon['Legendary'],drop_first=True)","6d1dca9e":"pokemon.drop(['#','Legendary'],axis=1,inplace=True)\npokemon = pd.concat([pokemon,Legend],axis=1)\npokemon.rename({True:'Legend'},axis=1, inplace=True)","c2f81e6c":"pokemon.head()","f35afc44":"def type_numbering(string) : \n    if string == 'Normal' :\n        return 1\n    elif string== 'Fire' :\n        return 2\n    elif string == 'Fighting' :\n        return 3\n    elif string == 'Water' :\n        return 4\n    elif string == 'Flying' :\n        return 5\n    elif string == 'Grass' :\n        return 6\n    elif string == 'Poison' :\n        return 7\n    elif string == 'Electric' :\n        return 8\n    elif string == 'Ground' :\n        return 9\n    elif string == 'Psychic' :\n        return 10\n    elif string == 'Rock' :\n        return 11\n    elif string == 'Ice' :\n        return 12\n    elif string == 'Bug' :\n        return 13\n    elif string == 'Dragon' :\n        return 14\n    elif string == 'Ghost' :\n        return 15\n    elif string == 'Dark' :\n        return 16\n    elif string == 'Steel' :\n        return 17\n    elif string == 'Fairy' :\n        return 18\n    else :\n        return 0","9bd213d2":"pokemon['Type 1'] = pokemon['Type 1'].apply(type_numbering)\npokemon['Type 2'] = pokemon['Type 2'].apply(type_numbering)","00155692":"pokemon.head()","a144110e":"indices = pd.Series(pokemon.index, index=pokemon['Name'])","e43cc23d":"pokematrix = pokemon.drop('Name',axis=1)","62a354cb":"def recommendation(pkm):\n    idx = indices[pkm]\n    sim_scores = []\n    for i in range(pokemon.shape[0]):\n        sim_scores.append(np.linalg.norm(pokematrix.loc[idx]-pokematrix.loc[i]))\n    sim_scores = list(enumerate(sim_scores))\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=False)\n    sim_scores = sim_scores[1:31]\n    pkm_indices = [i[0] for i in sim_scores]\n    sim_pkm = pokemon.iloc[pkm_indices].head(10)\n    return sim_pkm","7c2e2ced":"recommendation('Pikachu')","af4e7229":"from sklearn.metrics.pairwise import cosine_similarity","0bc7bd78":"cosine_sim = cosine_similarity(pokematrix,pokematrix)","e90144d4":"def recommendation_2(pkm):\n    idx = indices[pkm]\n    sim_scores = list(enumerate(cosine_sim[idx]))\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n    sim_scores = sim_scores[1:31]\n    pkm_indices = [i[0] for i in sim_scores]    \n    sim_pkm = pokemon.iloc[pkm_indices].head(10)\n    return sim_pkm","bef8a505":"recommendation_2('Pikachu')","6105b1f6":"def check_type(x,a,b):\n    pkm_type_1 = x['Type 1']\n    pkm_type_2 = x['Type 2']\n    if (pkm_type_1 == a) and (pkm_type_2 == b):\n        return 1\n    elif (pkm_type_1 == a) or (pkm_type_2 == b):\n        return 0.5\n    else:\n        return 0","987e0953":"def enhanced_recommendation(pkm):\n    idx = indices[pkm]\n    pkm_type1= pokematrix.loc[idx]['Type 1']\n    pkm_type2= pokematrix.loc[idx]['Type 2']\n    sim_scores = list(enumerate(cosine_sim[idx]))\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n    sim_scores = sim_scores[1:31]\n    pkm_indices = [i[0] for i in sim_scores]\n    \n    sim_pkm = pokemon.iloc[pkm_indices].copy()\n    sim_pkm['sim_type'] = sim_pkm.apply(lambda x: check_type(x,pkm_type1,pkm_type2), axis=1)\n    sim_pkm = sim_pkm.sort_values('sim_type', ascending=False).head(10)\n    return sim_pkm","03ca0401":"enhanced_recommendation('Pikachu')","695dd99d":"enhanced_recommendation('Charizard')","2ca3e262":"enhanced_recommendation('Bulbasaur')","a997f59c":"<p>The result seems not as my expectation as only Voltorb is an electric pokemon.<\/p>\n<p>So I decide to use **Cosine Similarity** to calculate the similarity between two pokemons:<\/p>\n<p>Mathematically, it is defined as follows:<\/p>\n<p>$cosine(x,y) = \\frac{x. y^\\intercal}{||x||.||y||} $<\/p>\n","a0963578":"<p>Yes!!! The result seems quite good. \nElekid, Tynamo, Pichu, Raichu are quite similar to Pikachu<\/p>","ceee24c9":"# 1. Import and clean our data","53169596":"<p>At the very first, I am thinking about consider the pokemons as vectors. And to find the similar pokemons, we are going to calculate the Euclidean distance between them and sort to get top 10<\/p>\n<p>Here is the link if you do not know: [Wiki for Euclidean distance](https:\/\/en.wikipedia.org\/wiki\/Euclidean_distance)<\/p>\n<p>In numpy we can use: numpy.linalg.norm(a,b)<\/p>","802c7fda":"# 2. Building our recommender system","e67b7d85":"I think it is enough for today. I will enhance the system later.\n<p>Thank you.<\/p>","36d94c17":"<p>The result is getting better, I can see more electric pokemon. But it would be even better if the system can show pokemons having same type with Pikachu on top.<\/p>\n<p>Let build a score for types of pokemon like below:<\/p>","59bbe51b":"Today I am going to try to build a basic recommendation system for a Pokemon. I am still learning how to make my notebook clean and well-structed. If you have any suggestion, please comment below. Thank you so much. "}}