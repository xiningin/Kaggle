{"cell_type":{"eb4625d0":"code","8a8bed21":"code","94a2bdf5":"code","5a3afc9d":"code","03d06579":"code","fbfd0cbb":"code","56d8603c":"code","2799c4f5":"code","5bdece02":"code","84ebea55":"code","c7b6055a":"code","33ab0658":"code","7352b3c8":"code","827acfd1":"code","01277643":"code","6ee43a93":"code","98c05edf":"code","d6007603":"code","9af13d3f":"code","c42b599c":"code","c1323c26":"code","3b104d58":"code","0a5a964d":"markdown","36b90d4e":"markdown","60c78648":"markdown","3824a0d6":"markdown","2159f48d":"markdown","1371bbca":"markdown","2d546203":"markdown","8071df72":"markdown","99b9b0c2":"markdown","8b15ee7a":"markdown","91676e3d":"markdown","17281535":"markdown","0a5cfcb8":"markdown","6cf28169":"markdown","2f77d01f":"markdown","ecea1237":"markdown","65e59fb6":"markdown","8def0ea0":"markdown","aeaea915":"markdown","8a9e80c9":"markdown","5698ebbf":"markdown","9fc64e41":"markdown","994f5098":"markdown","47b47e6e":"markdown","57b2f18b":"markdown","6e6dfcb8":"markdown","41155124":"markdown","1ab1e581":"markdown","8e3ac59e":"markdown","ffe96bdb":"markdown","51d7fba1":"markdown","8faf53ab":"markdown","9fb2f4ce":"markdown","b7f480f8":"markdown"},"source":{"eb4625d0":"import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport cv2\nimport tensorflow as tf\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tqdm import tqdm\nimport os\nfrom sklearn.utils import shuffle\nfrom sklearn.model_selection import train_test_split\nfrom tensorflow.keras.applications import EfficientNetB0\nfrom tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, TensorBoard, ModelCheckpoint\nfrom sklearn.metrics import classification_report,confusion_matrix\nimport ipywidgets as widgets\nimport io\nfrom PIL import Image\nfrom IPython.display import display,clear_output\nfrom warnings import filterwarnings\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","8a8bed21":"colors_dark = [\"#1F1F1F\", \"#313131\", '#636363', '#AEAEAE', '#DADADA']\ncolors_red = [\"#331313\", \"#582626\", '#9E1717', '#D35151', '#E9B4B4']\ncolors_green = ['#01411C','#4B6F44','#4F7942','#74C365','#D0F0C0']\n\nsns.palplot(colors_dark)\nsns.palplot(colors_green)\nsns.palplot(colors_red)","94a2bdf5":"labels = ['glioma_tumor','no_tumor','meningioma_tumor','pituitary_tumor']","5a3afc9d":"X_train = []\ny_train = []\nimage_size = 128\nfor i in labels:\n    folderPath = os.path.join('..\/input\/brain-tumor-classification-mri','Training',i)\n    for j in tqdm(os.listdir(folderPath)):\n        img = cv2.imread(os.path.join(folderPath,j))\n        img = cv2.resize(img,(image_size, image_size))\n        X_train.append(img)\n        y_train.append(i)\n        \nfor i in labels:\n    folderPath = os.path.join('..\/input\/brain-tumor-classification-mri','Testing',i)\n    for j in tqdm(os.listdir(folderPath)):\n        img = cv2.imread(os.path.join(folderPath,j))\n        img = cv2.resize(img,(image_size,image_size))\n        X_train.append(img)\n        y_train.append(i)\n        \nX_train = np.array(X_train)\ny_train = np.array(y_train)","03d06579":"k=0\nfig, ax = plt.subplots(1,4,figsize=(20,20))\nfig.text(s='Sample Image From Each Label',size=18,fontweight='bold',\n             fontname='monospace',color=colors_dark[1],y=0.62,x=0.4,alpha=0.8)\nfor i in labels:\n    j=0\n    while True :\n        if y_train[j]==i:\n            ax[k].imshow(X_train[j])\n            ax[k].set_title(y_train[j])\n            ax[k].axis('off')\n            k+=1\n            break\n        j+=1","fbfd0cbb":"X_train, y_train = shuffle(X_train,y_train, random_state=101)","56d8603c":"X_train.shape","2799c4f5":"datagen = ImageDataGenerator(\n    rotation_range=30,\n    width_shift_range=0.1,\n    height_shift_range=0.1,\n    zoom_range=0.2,\n    horizontal_flip=True)\n\ndatagen.fit(X_train)\nX_train.shape","5bdece02":"X_train,X_test,y_train,y_test = train_test_split(X_train,y_train, test_size=0.1,random_state=101)","84ebea55":"y_train_new = []\nfor i in y_train:\n    y_train_new.append(labels.index(i))\ny_train = y_train_new\ny_train = tf.keras.utils.to_categorical(y_train)\n\n\ny_test_new = []\nfor i in y_test:\n    y_test_new.append(labels.index(i))\ny_test = y_test_new\ny_test = tf.keras.utils.to_categorical(y_test)","c7b6055a":"from tensorflow.keras.applications import ResNet152V2\nresnet = ResNet152V2(weights='imagenet', include_top=False,input_shape=(image_size,image_size,3))\n","33ab0658":"#effnet = EfficientNetB0(weights='imagenet',include_top=False,input_shape=(image_size,image_size,3))","7352b3c8":"model = resnet.output\nmodel = tf.keras.layers.GlobalAveragePooling2D()(model)\nmodel = tf.keras.layers.Dropout(rate=0.5)(model)\nmodel = tf.keras.layers.Dense(4,activation='softmax')(model)\nmodel = tf.keras.models.Model(inputs=resnet.input, outputs = model)","827acfd1":"model.summary()","01277643":"model.compile(loss='categorical_crossentropy',optimizer = 'Adam', metrics= ['accuracy'])","6ee43a93":"tensorboard = TensorBoard(log_dir = 'logs')\ncheckpoint = ModelCheckpoint(\"resnet152v1.h5\",monitor=\"val_accuracy\",save_best_only=True,mode=\"auto\",verbose=1)\nreduce_lr = ReduceLROnPlateau(monitor = 'val_accuracy', factor = 0.4, patience = 2, min_delta = 0.001,\n                              mode='auto',verbose=1)","98c05edf":"history = model.fit(X_train,y_train,validation_split=0.1, epochs =25, verbose=1, batch_size=32,\n                   callbacks=[tensorboard,checkpoint,reduce_lr])","d6007603":"filterwarnings('ignore')\n\nepochs = [i for i in range(25)]\nfig, ax = plt.subplots(1,2,figsize=(14,7))\ntrain_acc = history.history['accuracy']\ntrain_loss = history.history['loss']\nval_acc = history.history['val_accuracy']\nval_loss = history.history['val_loss']\n\nfig.text(s='Epochs vs. Training and Validation Accuracy\/Loss',size=18,fontweight='bold',\n             fontname='monospace',color=colors_dark[1],y=1,x=0.28,alpha=0.8)\n\nsns.despine()\nax[0].plot(epochs, train_acc, marker='o',markerfacecolor=colors_green[2],color=colors_green[3],\n           label = 'Training Accuracy')\nax[0].plot(epochs, val_acc, marker='o',markerfacecolor=colors_red[2],color=colors_red[3],\n           label = 'Validation Accuracy')\nax[0].legend(frameon=False)\nax[0].set_xlabel('Epochs')\nax[0].set_ylabel('Accuracy')\n\nsns.despine()\nax[1].plot(epochs, train_loss, marker='o',markerfacecolor=colors_green[2],color=colors_green[3],\n           label ='Training Loss')\nax[1].plot(epochs, val_loss, marker='o',markerfacecolor=colors_red[2],color=colors_red[3],\n           label = 'Validation Loss')\nax[1].legend(frameon=False)\nax[1].set_xlabel('Epochs')\nax[1].set_ylabel('Training & Validation Loss')\n\nfig.show()","9af13d3f":"pred = model.predict(X_test)\npred = np.argmax(pred,axis=1)\ny_test_new = np.argmax(y_test,axis=1)","c42b599c":"print(classification_report(y_test_new,pred))","c1323c26":"fig,ax=plt.subplots(1,1,figsize=(14,7))\nsns.heatmap(confusion_matrix(y_test_new,pred),ax=ax,xticklabels=labels,yticklabels=labels,annot=True,\n           cmap=colors_green[::-1],alpha=0.7,linewidths=2,linecolor=colors_dark[3])\nfig.text(s='Heatmap of the Confusion Matrix',size=18,fontweight='bold',\n             fontname='monospace',color=colors_dark[1],y=0.92,x=0.28,alpha=0.8)\n\nplt.show()","3b104d58":"def img_pred(upload):\n    for name, file_info in uploader.value.items():\n        img = Image.open(io.BytesIO(file_info['content']))\n    opencvImage = cv2.cvtColor(np.array(img), cv2.COLOR_RGB2BGR)\n    img = cv2.resize(opencvImage,(150,150))\n    img = img.reshape(1,150,150,3)\n    p = model.predict(img)\n    p = np.argmax(p,axis=1)[0]\n\n    if p==0:\n        p='Glioma Tumor'\n    elif p==1:\n        print('The model predicts that there is no tumor')\n    elif p==2:\n        p='Meningioma Tumor'\n    else:\n        p='Pituitary Tumor'\n\n    if p!=1:\n        print(f'The Model predicts that it is a {p}')","0a5a964d":"# Data Preperation","36b90d4e":"In this, <br>\n0 - Glioma Tumor<br>\n1 - No Tumor<br>\n2 - Meningioma Tumor<br>\n3 - Pituitary Tumor<br>","60c78648":"# Evaluation","3824a0d6":"In this notebook, I performed Image Classification with the help of CNN using Transfer Learning which gave an accuracy of around 98%.<br>\nI also made widgets which can make predictions on an image from your local machine!","2159f48d":"**GlobalAveragePooling2D** -> This layer acts similar to the Max Pooling layer in CNNs, the only difference being is that it uses the Average values instead of the Max value while *pooling*. This really helps in decreasing the computational load on the machine while training.\n<br><br>\n**Dropout** -> This layer omits some of the neurons at each step from the layer making the neurons more independent from the neibouring neurons. It helps in avoiding overfitting. Neurons to be ommitted are selected at random. The **rate** parameter is the liklihood of a neuron activation being set to 0, thus dropping out the neuron\n\n**Dense** -> This is the output layer which classifies the image into 1 of the 4 possible classes. It uses the **softmax** function which is a generalization of the sigmoid function.","1371bbca":"# Transfer Learning","2d546203":"---","8071df72":"# <center>Thank You!","99b9b0c2":"In this notebook, I've used **CNN** to perform Image Classification on the Brain Tumor dataset.<br>\nSince this dataset is small, if we train a neural network to it, it won't really give us a good result.<br>\nTherefore, I'm going to use the concept of **Transfer Learning** to train the model to get really accurate results.","8b15ee7a":"---","91676e3d":"---","17281535":"---","0a5cfcb8":"# Importing Libraries","6cf28169":"---","2f77d01f":"---","ecea1237":"# Prediction","65e59fb6":"Dividing the dataset into **Training** and **Testing** sets.","8def0ea0":"---","aeaea915":"We finally compile our model.","8a9e80c9":"---","5698ebbf":"---","9fc64e41":"We start off by appending all the images from the  directories into a Python list and then converting them into numpy arrays after resizing it.","994f5098":"# Conclusion","47b47e6e":"### Note","57b2f18b":"<img src=\"https:\/\/miro.medium.com\/max\/2800\/1*TUF_YfybJPQ8WA0siWeJTg@2x.jpeg\" alt=\"Brain\" style=\"width: 800px;\">","6e6dfcb8":"I've used the *argmax function* as each row from the prediction array contains four values for the respective labels. The **maximum** value which is in each row depicts the predicted output out of the 4 possible outcomes.<br>\nSo with *argmax*, I'm able to find out the index associated with the predicted outcome.","41155124":"# Introduction","1ab1e581":"**Image Data Augmentation**: Image data augmentation is a technique that can be used to artificially expand the size of a training dataset by creating modified versions of images in the dataset. It uses techniques such as flipping, zooming, padding, cropping, etc.<br><br>\nData augmentation makes the model more robust to slight variations, and hence *prevents the model from overfitting.*\n<br><br>\nTo do so using Keras, we use the function **ImageDataGenerator** ","8e3ac59e":"---","ffe96bdb":"Performing **One Hot Encoding** on the labels after converting it into numerical values:","51d7fba1":"# Color","8faf53ab":"Deep convolutional neural network models may take days or even weeks to train on very large datasets.\n\nA way to short-cut this process is to re-use the model weights from pre-trained models that were developed for standard computer vision benchmark datasets, such as the ImageNet image recognition tasks. Top performing models can be downloaded and used directly, or integrated into a new model for your own computer vision problems.\n\nIn this notebook, I'll be using the **EfficientNetB0** model which will use the weights from the **ImageNet** dataset.\n\nThe include_top parameter is set to *False* so that the network doesn't include the top layer\/ output layer from the pre-built model which allows us to add our own output layer depending upon our use case!","9fb2f4ce":"**Callbacks** -> Callbacks can help you fix bugs more quickly, and can help you build better models. They can help you visualize how your model\u2019s training is going, and can even help prevent overfitting by implementing early stopping or customizing the learning rate on each iteration.<br><br>\nBy definition, \"A callback is a set of functions to be applied at given stages of the training procedure. You can use callbacks to get a view on internal states and statistics of the model during training.\"\n\nIn this notebook, I'll be using **TensorBoard, ModelCheckpoint and ReduceLROnPlateau** callback functions","b7f480f8":"# Training The Model"}}