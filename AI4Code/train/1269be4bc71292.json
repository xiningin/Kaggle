{"cell_type":{"7e5a6261":"code","16f467e2":"code","298bad65":"code","e09c7f0b":"code","1321cf8c":"code","192ed17f":"code","aa2ecb8d":"code","7b4230e4":"code","5b804eee":"code","68906c70":"code","3ad5755f":"code","3c452dc6":"code","aebf7170":"markdown","28659d5f":"markdown","10a745b4":"markdown","480e8a05":"markdown","6e89e065":"markdown","49915bcf":"markdown","4e2564ab":"markdown","90a1c7ef":"markdown"},"source":{"7e5a6261":"import numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import pairwise_distances\nimport seaborn as sns\nimport random\n%matplotlib inline\nimport re","16f467e2":"u_cols = ['user_id', 'age', 'sex', 'occupation', 'zip_code']\nusers = pd.read_csv('..\/input\/movielens-100k-dataset\/ml-100k\/u.user', sep='|', names=u_cols) \nusers.head()","298bad65":"r_cols = ['user_id', 'movie_id', 'rating', 'unix_timestamp']\nratings = pd.read_csv('..\/input\/movielens-100k-dataset\/ml-100k\/u.data', sep='\\t', names=r_cols)\nratings.drop( \"unix_timestamp\", inplace = True, axis = 1 ) \nratings.head()","e09c7f0b":"ratings.shape","1321cf8c":"#ignoring the 19 fields for now in this exercise\ndef clean_title(title):\n    return re.sub(\"[\\(\\[].*?[\\)\\]]\", \"\",title)\n\ndef genre(series):\n    genres = series.index[6:-2]\n    \n    text = []\n    for i in genres:\n        if series[i] == 1:\n            text.append(i)\n            break\n    return \", \".join(text)\n\nm_cols = ['movie_id', 'title', 'release_date', 'video_release_date', 'imdb_url']\ngenre_cols = ['unknown', 'Action', 'Adventure', 'Animation','Childrens', 'Comedy', 'Crime',\n              'Documentary', 'Drama', 'Fantasy','Film-Noir','Horror', 'Musical', 'Mystery', \n              'Romance','Sci-Fi','Thriller' , 'War' , 'Western' ]\n \nmovies = pd.read_csv('..\/input\/movielens-100k-dataset\/ml-100k\/u.item', sep='|', names=m_cols+genre_cols,\n                     encoding='latin-1')\n\nmovies['title'] = movies['title'].apply(clean_title)\nmovies['title'] = movies['title'].str.strip()\n\nmovies['genre'] = movies.apply(genre,axis=1)\n\nmovies.drop(movies.columns[[2,3,4]], inplace = True, axis = 1 )\nmovies.drop(genre_cols,axis=1,inplace=True)\n\nmovies.head()","192ed17f":"movie_ratings = pd.merge(movies, ratings)\ndf = pd.merge(movie_ratings, users)\ndf.drop(df.columns[5::], axis=1, inplace=True)\n\ndf.head()","aa2ecb8d":"def get_popular_10_movies():\n    \n    ratings_avg= pd.DataFrame(df.groupby('title')['rating'].mean())\n    ratings_avg['rating_count'] = df.groupby('title')['rating'].count()\n    \n    def weighted_rate(x):\n    \n        v = x['rating']\n        R = x['rating_count']\n    \n        return (v\/(v+m) * R) + (m\/(m+v) * C)\n    \n    C = ratings_avg['rating'].mean()\n    m = ratings_avg['rating_count'].quantile(0.90)\n\n    ratings_avg['score'] = ratings_avg.apply(weighted_rate,axis=1)\n    \n    ratings_avg = ratings_avg.sort_values(ascending=False,by='score')\n    return ratings_avg.head(10)\n\npopular_movies = get_popular_10_movies()\nprint(\"Popular 10 movies:\\n\")\nprint(popular_movies)","7b4230e4":"def recommendation_sys():\n    n_users = users.shape[0]\n    n_movies = movies.shape[0]\n\n    data_matrix = np.zeros((n_users, n_movies))\n\n    data_matrix = df.pivot_table(index='user_id',columns='movie_id',values='rating').reset_index(drop=True)\n    data_matrix.fillna( 0, inplace = True )\n\n    user_distances = pairwise_distances(data_matrix, metric=\"cosine\")\n\n    # \".T\" below is to transpose our 2D matrix.\n    data_matrix_transpose = data_matrix.T\n    movie_distances = pairwise_distances(data_matrix_transpose, metric=\"cosine\")\n\n    display(user_distances)\n\n    user_similarity = 1 - user_distances\n    movie_similarity = 1 - movie_distances\n    \n    return user_similarity,movie_similarity\n\n\nuser_similarity,movie_similarity = recommendation_sys()\n","5b804eee":"def get_movie_recommendation(title,n):\n    \n    inp=movies[movies.title==title].index.tolist()\n    \n    movie_idx=inp[0]\n\n    movies['similarity'] = movie_similarity[movie_idx,:]\n        \n    movies_recommend = movies.sort_values([\"similarity\"], ascending = False )[1:n]\n    \n    return(movies_recommend.title)\n    \nn = 10\n\ntitle = random.choice(movies.title)\n\nprint(\"Recommended movies similar to :\",title)\nmovie_recommend = get_movie_recommendation(title,n)\nprint(\"\\n\".join(map(str,movie_recommend)))","68906c70":"def get_genre_recommendation(title,n):\n    \n    inp=movies[movies.title==title].index.tolist()\n    \n    movie_idx=inp[0]\n\n    movies['similarity'] = movie_similarity[movie_idx,:]\n        \n    movies_recommend = movies.sort_values([\"similarity\"], ascending = False )[1:n]\n    \n    return(movies_recommend.title)\n    \nn = 10\n\ntitle = random.choice(movies.title)\n\nprint(\"Recommended movies similar to :\",title)\nmovie_recommend = get_movie_recommendation(title,n)\nprint(\"\\n\".join(map(str,movie_recommend)))","3ad5755f":"def get_user_fav(id):\n    user_rec = df[(df.user_id == id)].sort_values(['rating'],ascending=False)[0:7]\n        \n    return (user_rec.title.values)\n    \ndef get_user_recommendation(id):\n    \n    inp=users[users['user_id']==id].index.tolist()\n    \n    inp=inp[0]\n        \n    users['similarity'] = user_similarity[inp,:]\n        \n    usr_id = users.sort_values( [\"similarity\"], ascending = False )[1:5]\n        \n    return(usr_id.user_id.values)\n    \ndef find_common(u,u_id):\n    \n    x = df[df.user_id==u_id] # inp user\n    \n    recommend_movies = []\n    \n    for i in u:\n        \n        y = df[(df.user_id == i) & (df.rating >=4)] #similar\n        \n        movie_for_user = y.loc[~y['title'].isin(x['title']),:] #no need to recommend movies already watched by user\n       \n        movie_for_user = movie_for_user.sort_values(['rating'],ascending=False)[0:7] #just keeping top 7 movies for each user\n       \n        recommend_movies.extend(movie_for_user['title'].values)\n        recommend_movies = list(dict.fromkeys(recommend_movies)) #remove duplicate movies\n    \n    return recommend_movies","3c452dc6":"u_id = random.choice(users['user_id'])\n\nusr_fav = get_user_fav(u_id)\nprint(\"Favourite movies of user {id} are: \\n {fav}\\n\".format(id=u_id,fav=\", \".join(map(str,usr_fav))))\n\nprint(\"Users similar are:\")\n\nu = get_user_recommendation(u_id)\nprint(u,\"\\n\")\nprint(\"Your recommendation based on user similarity:\")\nuser_recommend = find_common(u,u_id)\nprint(\"\\n\".join(map(str,user_recommend)))","aebf7170":"# User-Based Collaborative Filtering\n    User-Based Collaborative Filtering is a technique used to predict the items that a user might like on the basis of ratings given \n    to that item by the other users who have similar taste with that of the target user.","28659d5f":"     u.data --\n        The full u data set, 100000 ratings by 943 users on 1682 items. Each user has rated at least 20 movies. \n        Users and items are numbered consecutively from 1. The data is randomly ordered. This is a tab separated list of\n                user id | item id | rating | timestamp.\n        The time stamps are unix seconds since 1\/1\/1970 UTC","10a745b4":"    WeightedRating(WR)=   v           m\n                        _____ * R +  _____ * C\n                        v + m        v + m  \n                    \n                    \n    v is the number of votes for the movie;\n\n    m is the minimum votes required to be listed in the chart;\n\n    R is the average rating of the movie;\n\n    C is the mean vote across the whole report.               ","480e8a05":"# Simple Recommender","6e89e065":"    u.user -- \n        Demographic information about the users; this is a tabseparated list of\n                user id | age | gender | occupation | zip code\n        The user ids are the ones used in the u.data data set.","49915bcf":"    u.item -- \n        Information about the items (movies); this is a tab separated list of\n                movie id | movie title | release date | video release date | IMDb URL | unknown | Action | Adventure | \n                Animation | Children's | Comedy | Crime | Documentary | Drama | Fantasy | Film-Noir | Horror | Musical | \n                Mystery | Romance | Sci-Fi | Thriller | War | Western \n        The last 19 fields are the genres, a 1 indicates the movie is of that genre, a 0 indicates it is not; movies can \n        be is several genres at once. The movie ids are the ones used in the u.data data set.","4e2564ab":"# Item-Based Collaborative Filtering\n    Item based collaborative filtering is a technique used to look for items that are similar to the items that user has \n    already rated and recommend most similar items.","90a1c7ef":"![image.png](attachment:68d54c71-4ad4-4817-8b5d-09547b650575.png)"}}