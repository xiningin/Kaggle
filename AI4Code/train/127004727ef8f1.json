{"cell_type":{"0139eb01":"code","5512b901":"code","bda44c6c":"code","1cca11b5":"code","d50c09cd":"code","e0093235":"code","226cc25d":"code","61947378":"code","1663bca0":"code","1ac55980":"code","af16410a":"markdown","d891b2f9":"markdown","92fd8646":"markdown","3884327c":"markdown","06a60b1f":"markdown","a73a817c":"markdown","3096e2df":"markdown","d47384ff":"markdown","573ed302":"markdown"},"source":{"0139eb01":"import os\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nimport datetime as dt\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neural_network import MLPRegressor\n\nimport warnings\nwarnings.simplefilter('ignore')","5512b901":"FOLDER = '..\/input\/'\nOUTPUT = '..\/preprocessed\/'\nos.listdir(FOLDER)","bda44c6c":"df_structures = pd.read_csv(os.path.join(FOLDER, 'structures.csv'))","1cca11b5":"%%time\ndf_distance = df_structures.merge(df_structures, how = 'left', on= 'molecule_name', suffixes = ('_0', '_1'))\n# remove same molecule\ndf_distance = df_distance.loc[df_distance['atom_index_0'] != df_distance['atom_index_1']]","d50c09cd":"%%time\ndf_distance['distance'] = np.linalg.norm(df_distance[['x_0','y_0', 'z_0']].values - \n                                           df_distance[['x_1', 'y_1', 'z_1']].values, axis=1, ord = 2)\n","e0093235":"df_distance.head(10)","226cc25d":"def get_interaction_data_frame(df_distance, num_nearest = 5):\n    time_start = dt.datetime.now()\n    print(\"START\", time_start)\n    \n    # get nearest 5 (num_nearest) by distances\n    df_temp = df_distance.groupby(['molecule_name', 'atom_index_0', 'atom_1'])['distance'].nsmallest(num_nearest)\n    \n    # make it clean\n    df_temp = pd.DataFrame(df_temp).reset_index()[['molecule_name', 'atom_index_0', 'atom_1', 'distance']]\n    df_temp.columns = ['molecule_name', 'atom_index', 'atom', 'distance']\n    \n    time_nearest = dt.datetime.now()\n    print(\"Time Nearest\", time_nearest-time_start)\n    \n    # get rank by distance\n    df_temp['distance_rank'] = df_temp.groupby(['molecule_name', 'atom_index', 'atom'])['distance'].rank(ascending = True, method = 'first').astype(int)\n    \n    time_rank = dt.datetime.now()\n    print(\"Time Rank\", time_rank-time_nearest)\n    \n    # pivot to get nearest distance by atom type \n    df_distance_nearest = pd.pivot_table(df_temp, index = ['molecule_name','atom_index'], columns= ['atom', 'distance_rank'], values= 'distance')\n    \n    time_pivot = dt.datetime.now()\n    print(\"Time Pivot\", time_pivot-time_rank)\n    del df_temp\n    \n    columns_distance_nearest =  np.core.defchararray.add('distance_nearest_', \n                                          np.array(df_distance_nearest.columns.get_level_values('distance_rank')).astype(str) +  \n                                          np.array(df_distance_nearest.columns.get_level_values('atom')) )\n    df_distance_nearest.columns = columns_distance_nearest\n    \n    # 1 \/ r^2 to get the square inverse same with the previous kernel\n    df_distance_sq_inv_farthest = 1 \/ (df_distance_nearest ** 2)\n    \n    columns_distance_sq_inv_farthest = [col.replace('distance_nearest', 'distance_sq_inv_farthest') for col in columns_distance_nearest]\n\n    df_distance_sq_inv_farthest.columns = columns_distance_sq_inv_farthest\n    time_inverse = dt.datetime.now()\n    print(\"Time Inverse Calculation\", time_inverse-time_pivot)\n    \n    df_interaction = pd.concat([df_distance_sq_inv_farthest, df_distance_nearest] , axis = 1)\n    df_interaction.reset_index(inplace = True)\n    \n    time_concat = dt.datetime.now()\n    print(\"Time Concat\", time_concat-time_inverse)\n    \n    return df_interaction","61947378":"first_100_molecules = df_structures['molecule_name'].unique()[:100]","1663bca0":"%%time\ndf_interaction = get_interaction_data_frame(df_distance.loc[df_distance['molecule_name'].isin(first_100_molecules)])","1ac55980":"df_interaction.head(20)","af16410a":"## Load the data","d891b2f9":"I use self join instead of distance matrix to get the distance of atoms among molecule because I want to avoid looping per molecule\n","92fd8646":"The result is same with http:\/\/https:\/\/www.kaggle.com\/rio114\/coulomb-interaction \njust need to join to train dataset","3884327c":"We can use ```df_distance``` to join to train and test dataset ","06a60b1f":"## Compute Distance","a73a817c":"This kernel is inspired by *rio114* kernel http:\/\/https:\/\/www.kaggle.com\/rio114\/coulomb-interaction\n> get distances from each atom belonging to the molecule and pickup 'num = 5' nearest regarding to each atom [H, C, N, O, F]\n\nI try to utilize pandas to calculate those interesting features instead of looping per molecule.\n\nIt speed up 56x faster from **216.16 s ** to **3.84 s** for first 100 molecules","3096e2df":"Computing **N smallest object** is take a lot of time compare to others step. \n\nWe need to tackle that compuation, because it still to long if we want to run for all molecule","d47384ff":"## Interaction Data Frame","573ed302":"Hope This is helps for our feature engineering\n\nCheers :D  "}}