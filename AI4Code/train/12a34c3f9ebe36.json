{"cell_type":{"b384cdaa":"code","2419e36a":"code","78266449":"code","8df9c953":"code","6c7a37cf":"code","e117528a":"code","fe3df70e":"code","3f785792":"code","36b7613f":"code","e076bb8f":"code","42711065":"code","c04227cf":"code","68a58b30":"code","66676e04":"code","2d9afd17":"code","ecb7024b":"code","37fb0c78":"code","17671a49":"code","77049491":"code","a933b28d":"code","7a4e28de":"code","4d99892f":"code","1bb2ed26":"code","f34d4dd8":"code","debbc3c5":"code","ee42ec37":"code","d44c0420":"code","8001a9aa":"code","065aff3c":"code","ab1d19c9":"code","4e273cce":"code","bc863084":"code","fe57a55f":"code","19d26ff7":"code","5b23ff41":"code","059313b2":"markdown","6be689b5":"markdown","e18b849b":"markdown","2662c878":"markdown","e5b4d2f7":"markdown","4241bb41":"markdown","4a7460fd":"markdown","cd44e31c":"markdown","f05caa30":"markdown","4f4864f2":"markdown"},"source":{"b384cdaa":"# !pip install yandex_search","2419e36a":"# import yandex_search\nimport requests\nfrom bs4 import BeautifulSoup\n\nimport datetime\nfrom joblib import Parallel, delayed\nimport joblib\n\nimport getpass\nimport pandas as pd\nimport numpy as np\nimport threading\n\nimport matplotlib.pylab as plt\n%matplotlib inline","78266449":"# api_user = getpass.getpass()","8df9c953":"# api_key = getpass.getpass()","6c7a37cf":"# yandex = yandex_search.Yandex(api_user=api_user, api_key=api_key)","e117528a":"# yandex.search('\"ale-l23\" android').items","fe3df70e":"def search_first_url_on_site(yandex, query, site):\n    try:\n        search_results = yandex.search(\"site:{} {}\".format(site, query))\n        if search_results is None or len(search_results.items) == 0:\n            return link\n    \n        return search_results.items[0]['url']\n    except KeyboardInterrupt:\n        raise\n    except:\n        pass\n    return None\n\n# search_first_url_on_site(yandex, 'p5006a', 'www.handsetdetection.com')","3f785792":"def read_data():\n    train_identity = pd.read_csv('\/kaggle\/input\/ieee-fraud-detection\/train_identity.csv')\n    test_identity = pd.read_csv('\/kaggle\/input\/ieee-fraud-detection\/test_identity.csv')\n    train_transaction = pd.read_csv('\/kaggle\/input\/ieee-fraud-detection\/train_transaction.csv')\n    test_transaction = pd.read_csv('\/kaggle\/input\/ieee-fraud-detection\/test_transaction.csv')\n\n    train = train_transaction.merge(train_identity, how='left', left_index=True, right_index=True)\n    del train_transaction, train_identity\n\n    y_train = train['isFraud'].astype(\"uint8\").copy()\n    train = train.drop('isFraud', axis=1)\n    \n    test = test_transaction.merge(test_identity, how='left', left_index=True, right_index=True)\n    del test_transaction, test_identity\n\n    return train, test, y_train","36b7613f":"train, test, y_train = read_data()\ncommon_df = pd.concat([train, test])\n\ntarget = np.concatenate([y_train, np.full(test.shape[0], -1)])\ncommon_df['target'] = target","e076bb8f":"common_df['DeviceInfo'] = common_df['DeviceInfo'].astype('str')\ncommon_df['ClearDeviceInfo'] = np.vectorize(lambda x : x.lower().split('build')[0].strip())(common_df['DeviceInfo'])\ncommon_df['ClearDeviceInfo'] = common_df['ClearDeviceInfo'].astype('str')","42711065":"common_df['ClearDeviceInfo'].value_counts().nlargest(30)","c04227cf":"incomplete_devices = ['Windows', 'iOS Device', 'MacOS', 'SAMSUNG', 'Trident\/7.0', 'nan']\nincomplete_devices = [t.lower() for t in incomplete_devices]","68a58b30":"rest = common_df[(~common_df['ClearDeviceInfo'].str.lower().isin(incomplete_devices))\\\n                 & (~common_df['ClearDeviceInfo'].str.contains('rv:'))]\nprint(common_df.shape, rest.shape, len(rest['ClearDeviceInfo'].value_counts()))","66676e04":"def remove_non_alpha(text):\n    return \"\".join(c for c in text if c.isalpha() or c.isdigit())\n\ndef clear_text(text):\n    return remove_non_alpha(text).strip()","2d9afd17":"clear_text('azumi_doshi_a5 5_ql')","ecb7024b":"def is_each_word_contained(text_to_find_for_it, text_to_find_in_it):\n    chars = [' ', '.', '-', '_', '(', ')']\n    words = [text_to_find_for_it.strip()]\n    \n    for char in chars:\n        next_iter_words = []\n        for word in words:\n            next_iter_words.extend(word.split(char))\n        words = next_iter_words\n    \n    for word in words:\n        if clear_text(word) not in clear_text(text_to_find_in_it):\n            return False\n    \n    return True","37fb0c78":"is_each_word_contained(\"blade v8\", 'https:\/\/\/zte\/blade-v8-v0800')","17671a49":"# phones_sites = ['www.handsetdetection.com']\n\n# phones_sites_path = ['https:\/\/www.handsetdetection.com\/device-detection-database\/devices\/']\n# phone_specs_links = {}\n\n# not_found_phones = {}\n\n# for model_i, model in enumerate(rest['ClearDeviceInfo'].unique()):\n#     if model_i % 50 == 0:\n#         print(model_i, len(phone_specs_links))\n    \n#     urls = []\n\n#     for site, site_path in zip(phones_sites, phones_sites_path):\n#         url = search_first_url_on_site(yandex, model, site)\n#         if url is not None and site_path in url and is_each_word_contained(model, url):\n#             phone_specs_links[model] = url\n#             break\n#         urls.append(url)\n    \n#     if model not in phone_specs_links:\n#         not_found_phones[model] = urls","77049491":"phone_specs_links = joblib.load('\/kaggle\/input\/phone-to-spec-link\/phone_specs_links.joblib')\n# joblib.dump(phone_specs_links, 'phone_specs_links.joblib')","a933b28d":"def get_manufacturer(url):\n    if url is not None and 'handsetdetection' in url:\n        return url.split('\/devices\/')[1].split('\/', 1)[0]\n    else:\n        return \"\"\n    \nget_manufacturer('https:\/\/www.handsetdetection.com\/device-detection-database\/devices\/samsung\/sm-g892a\/')","7a4e28de":"rest['manufacturer'] = rest['ClearDeviceInfo'].apply(lambda model \\\n                                : get_manufacturer(phone_specs_links.get(model, \"\")))","4d99892f":"samsung_df = common_df[common_df['ClearDeviceInfo'].str.lower().isin(['samsung'])]","1bb2ed26":"samsung_df['manufacturer'] = 'samsung'","f34d4dd8":"rest = pd.concat([rest, samsung_df])","debbc3c5":"rest['manufacturer'].value_counts().nlargest(20)","ee42ec37":"dic = {}\n\nkey = 'manufacturer'\n\ntrain_rest = rest[rest['target'] >= 0]\n\ntop_values = rest[key].value_counts().nlargest(20).keys()\n\nfor value in train_rest[key].unique():\n    if value in top_values:\n        dic[value] = train_rest[train_rest[key] == value]['target'].mean()\n    \nplt.figure(figsize=(15, 5))\nplt.bar(dic.keys(), dic.values())","d44c0420":"def get_non_empty_children(children):\n    for child in children:\n        if len(str(child).strip()) != 0:\n            yield child","8001a9aa":"def get_specs(link):\n    values = {}\n    \n    if link is None or 'handsetdetection.com\/device-detection-database\/devices' not in link:\n        return values\n    \n#     try:\n    if True:\n        page = requests.get(link)\n        soup = BeautifulSoup(page.content, \"html.parser\")\n\n        for table in soup.find_all('table'):\n            for t_table in get_non_empty_children(table.children):\n                if t_table.name != 'tbody':\n                    continue\n                \n                for row in get_non_empty_children(t_table.children):\n                    for cell_i, cell in enumerate(get_non_empty_children(row.children)):\n                        for field_i, field in enumerate(get_non_empty_children(cell.children)):\n                            if field_i == 0:\n#                                 print(cell_i, cell.text.split('\\n', 1)[0].strip())\n                                if cell_i == 0:\n                                    spec_name = cell.text.split('\\n', 1)[0].strip()\n                                elif cell_i == 1:\n                                    spec_value = cell.text.split('\\n', 1)[0].strip()\n\n                    values[spec_name] = spec_value\n                      \n#     except:\n#         pass\n       \n    return values\n    ","065aff3c":"get_specs('https:\/\/www.handsetdetection.com\/device-detection-database\/devices\/samsung\/sm-g892a\/')","ab1d19c9":"# start_time = datetime.datetime.now()\n\n# backend = 'threading'\n# model_and_specs = Parallel(n_jobs=-1, backend=backend)\\\n#     (delayed(lambda model_and_url : (model_and_url[0], get_specs(model_and_url[1])))(model_and_url) \\\n#          for model_and_url in phone_specs_links.items())\n\n# end_time =  datetime.datetime.now()\n# print(end_time - start_time)","4e273cce":"# model_and_specs = { k: v for k, v in model_and_specs}\n# joblib.dump(model_and_specs, 'model_and_specs_info.joblib')\n\nmodel_and_specs = joblib.load('\/kaggle\/input\/phone-specs\/model_and_specs_info.joblib')","bc863084":"def try_get_ram(text):\n    parts = text.split(',')\n    if len(parts) != 2:\n        return \"\"\n    else:\n        return parts[1].strip()\n    \ntry_get_ram('128GB, 4GB RAM')","fe57a55f":"device_params_keys = ['memory internal']\n\nfor key in device_params_keys:\n    rest[key] = rest['ClearDeviceInfo'].apply(lambda x :\\\n                        try_get_ram(model_and_specs.get(x, {key:\",\"}).get(key, \",\")))","19d26ff7":"rest[device_params_keys[0]].value_counts().nlargest(30)","5b23ff41":"fig, ax = plt.subplots(1,1, figsize=(16, 6))\n\ndic = {}\n\nkey = device_params_keys[0]\n\nrest_and_samsung_df=rest\ntrain_rest = rest_and_samsung_df[rest_and_samsung_df['target'] >= 0]\n\ntop10_manufacturer = rest_and_samsung_df[key].value_counts().nlargest(10).to_dict().keys()\n\nfor manufacturer in train_rest[key].unique():\n    if manufacturer in top10_manufacturer:\n        dic[manufacturer] = train_rest[train_rest[key] == manufacturer]['target'].mean()\n\nplt.figure(figsize=(15, 5))\nax.bar(dic.keys(), dic.values())\nax.set_label(key)\n# plt.show()\n# ax.legend()\n\nax.set_ylabel('Fraud')\nax.set_title(key)\nax.legend()\n\nplt.show()","059313b2":"Start with using yandex-search:","6be689b5":"We use yandex-search to finding specific page for each device and after it check existanse of each part of device-info in link. ","e18b849b":"I saved this dict in pkl, you can just load it.","2662c878":"Let's dig deeper! - Parse all specs from handsetdetection.com","e5b4d2f7":"And we can extract manufactor from url:","4241bb41":"Hi guys!\n\nThis kernel is about how I find almost all devices from the datasets.\n\nI have used yandex-search for this task.\n\/\/ Yandex allows 10k searches per day when registered with a validated (international) mobile number.\n\nTo repeat this code you should read https:\/\/pypi.org\/project\/yandex-search\/ and have a valid account on yandex.\n\nBut if you don't I have just leave my scraped data below.\n\nHave a fun!\n","4a7460fd":"Let's use it for device-info:","cd44e31c":"For example, add RAM to dataframe:","f05caa30":"Device info often consist of several parts - model, short name of manufactorer and others.\nAnd on sites these parts mb separated - lets find each of parts.","4f4864f2":"We can use all of specs from handsetdetection as features.\n\nThanks!"}}