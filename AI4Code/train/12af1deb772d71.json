{"cell_type":{"5c9a29d9":"code","e173cd53":"code","5eec62cf":"code","05840f63":"code","0069a389":"code","0ad855c8":"code","8bc9dfce":"code","1469f676":"code","ae5d12f1":"code","90087479":"code","9251162a":"code","81a4e9c1":"code","90fde02a":"code","3ca00746":"code","eec2155b":"code","1901153b":"code","6d201865":"code","1008decf":"code","f40dde56":"code","1fad7632":"code","7e1192db":"code","dd2667c9":"code","6a1367ce":"code","ca4f6d24":"code","1b27b0be":"code","689aee4c":"code","13d3b6d5":"code","e35848da":"code","4732ef5c":"code","69a0610d":"code","cead0319":"code","4e8c271d":"code","f01b1fde":"code","0724317a":"code","3283ff0d":"code","0b516674":"code","ce97cd4e":"code","88f90401":"code","31fd76d0":"code","adb21e5f":"code","90cd1dbc":"code","108b3f83":"code","d299f5f6":"code","94780bbc":"code","c3a51f1d":"code","76111458":"code","5d5e3fba":"code","fdc1409e":"markdown","63c237c3":"markdown","73233dac":"markdown","1dae9ebf":"markdown","29aff6a4":"markdown","a9feef1e":"markdown","abb0f97a":"markdown","631643a2":"markdown","731d9d77":"markdown","a9a330d4":"markdown","73abf42d":"markdown","b227c953":"markdown","a0d72b47":"markdown"},"source":{"5c9a29d9":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os # The OS module in python provides functions for interacting with the operating system\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","e173cd53":"pip install transformers","5eec62cf":"import pandas as pd # data processing\nimport numpy as np ## linear algebra\nfrom tqdm import tqdm, trange# for progress bar","05840f63":"data = pd.read_csv(\"..\/input\/entity-annotated-corpus\/ner_dataset.csv\", encoding=\"latin1\").fillna(method=\"ffill\")\n#This is the extract from GMB corpus which is tagged, annotated and built specifically to train the classifier to predict named entities such as name, location, etc.\n#Total Words Count = 1354149\n#Target Data Column: \"tag\"\n\ndata.tail(10)# show last 10 rows","0069a389":"data.info()","0ad855c8":"data.isnull()","8bc9dfce":"data.describe()","1469f676":"data['POS'].value_counts()","ae5d12f1":"data['Tag'].value_counts()","90087479":"data['Tag'].unique()","9251162a":"data['POS'].unique()","81a4e9c1":"class SentenceGetter(object):\n\n    def __init__(self, data):\n        self.n_sent = 1\n        self.data = data\n        self.empty = False\n        agg_func = lambda s: [(w, p, t) for w, p, t in zip(s[\"Word\"].values.tolist(),\n                                                           s[\"POS\"].values.tolist(),\n                                                           s[\"Tag\"].values.tolist())]\n        self.grouped = self.data.groupby(\"Sentence #\").apply(agg_func)\n        self.sentences = [s for s in self.grouped]\n\n    def get_next(self):\n        try:\n            s = self.grouped[\"Sentence: {}\".format(self.n_sent)]\n            self.n_sent += 1\n            return s\n        except:\n            return None\n#to retrieve sentences with their POS and tags (target is tag)","90fde02a":"getter = SentenceGetter(data)#Get all sentences","3ca00746":"sentences = [[word[0] for word in sentence] for sentence in getter.sentences]  ##This is how the sentences in the dataset look like.\nsentences[0]","eec2155b":"labels = [[s[2] for s in sentence] for sentence in getter.sentences]##this is how labels look like.\nprint(labels[0])","1901153b":"tag_values = list(set(data[\"Tag\"].values))#Create dictionary of tags to map labels to numbers.\ntag_values.append(\"PAD\")\ntag2idx = {t: i for i, t in enumerate(tag_values)}","6d201865":"tag_values","1008decf":"tag2idx","f40dde56":"import torch##is a python package that provides two high-level features: -Tensor computation (like numpy) with strong GPU acceleration - \n#Deep Neural Networks built on a tape-based autograd system\n\nfrom torch.utils.data import TensorDataset, DataLoader, RandomSampler, SequentialSampler\n#DL=Split our data into batches &Shuffle our data ,RS=Samples elements randomly. If without replacement, then sample from a shuffled dataset.,\n##SS=keeps Elements in the sample order, always in the same order.\nfrom transformers import BertTokenizer, BertConfig\n###This tokenizer inherits from PreTrainedTokenizer which contains most of the methods. Users should refer to the superclass for more information regarding methods.\n##It is used to instantiate an BERT model according to the specified arguments, defining the model architecture.\n\nfrom keras.preprocessing.sequence import pad_sequences\nfrom sklearn.model_selection import train_test_split\n\ntorch.__version__\n","1fad7632":"MAX_LEN = 75 #We will limit our sequence length to 75 tokens and we will use a batch size of 32 as suggested by the Bert paper. \n#Note, that Bert natively supports sequences of up to 512 tokens.\nbs = 32","7e1192db":"device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nn_gpu = torch.cuda.device_count()","dd2667c9":"torch.cuda.get_device_name(0)","6a1367ce":"tokenizer = BertTokenizer.from_pretrained('bert-base-cased', do_lower_case=False) \n## 12-layer, 768-hidden, 12-heads, 110M parameters.Trained on cased English text.\n\n##The Bert implementation comes with a pretrained tokenizer and a definied vocabulary. We load the one related to the smallest pre-trained model bert-base-cased. ","ca4f6d24":"def tokenize_and_preserve_labels(sentence, text_labels):\n    tokenized_sentence = []\n    labels = []\n\n    for word, label in zip(sentence, text_labels):\n\n        # Tokenize the word and count # of subwords the word is broken into\n        tokenized_word = tokenizer.tokenize(word)\n        n_subwords = len(tokenized_word)\n\n        # Add the tokenized word to the final tokenized word list\n        tokenized_sentence.extend(tokenized_word)\n\n        # Add the same label to the new list of labels `n_subwords` times\n        labels.extend([label] * n_subwords)\n\n    return tokenized_sentence, labels\n","1b27b0be":"tokenized_texts_and_labels = [\n    tokenize_and_preserve_labels(sent, labs)\n    for sent, labs in zip(sentences, labels)\n]","689aee4c":"tokenized_texts_and_labels","13d3b6d5":"tokenized_texts = [token_label_pair[0] for token_label_pair in tokenized_texts_and_labels]\nlabels = [token_label_pair[1] for token_label_pair in tokenized_texts_and_labels]\n","e35848da":"input_ids = pad_sequences([tokenizer.convert_tokens_to_ids(txt) for txt in tokenized_texts],\n                          maxlen=MAX_LEN, dtype=\"long\", value=0.0,\n                          truncating=\"post\", padding=\"post\")","4732ef5c":"tags = pad_sequences([[tag2idx.get(l) for l in lab] for lab in labels],\n                     maxlen=MAX_LEN, value=tag2idx[\"PAD\"], padding=\"post\",\n                     dtype=\"long\", truncating=\"post\")\n","69a0610d":"attention_masks = [[float(i != 0.0) for i in ii] for ii in input_ids]\n","cead0319":"tr_inputs, val_inputs, tr_tags, val_tags = train_test_split(input_ids, tags,\n                                                            random_state=2018, test_size=0.1)\ntr_masks, val_masks, _, _ = train_test_split(attention_masks, input_ids,\n                                             random_state=2018, test_size=0.1)","4e8c271d":"tr_inputs = torch.tensor(tr_inputs)\nval_inputs = torch.tensor(val_inputs)\ntr_tags = torch.tensor(tr_tags)\nval_tags = torch.tensor(val_tags)\ntr_masks = torch.tensor(tr_masks)\nval_masks = torch.tensor(val_masks)\n","f01b1fde":"train_data = TensorDataset(tr_inputs, tr_masks, tr_tags)\ntrain_sampler = RandomSampler(train_data)\ntrain_dataloader = DataLoader(train_data, sampler=train_sampler, batch_size=bs)\n\nvalid_data = TensorDataset(val_inputs, val_masks, val_tags)\nvalid_sampler = SequentialSampler(valid_data)\nvalid_dataloader = DataLoader(valid_data, sampler=valid_sampler, batch_size=bs)","0724317a":"import transformers\nfrom transformers import BertForTokenClassification, AdamW ## is an optimizer with weight decay fixed that can be used to fine-tuned models, \n#Bert Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g. for Named-Entity-Recognition (NER) tasks.\n\ntransformers.__version__\n","3283ff0d":"model = BertForTokenClassification.from_pretrained(\n    \"bert-base-cased\",\n    num_labels=len(tag2idx),\n    output_attentions = False,\n    output_hidden_states = False\n)\n","0b516674":"model.cuda(); #Now we have to pass the model parameters to the GPU.\n\n","ce97cd4e":"FULL_FINETUNING = True\nif FULL_FINETUNING:\n    param_optimizer = list(model.named_parameters())\n    no_decay = ['bias', 'gamma', 'beta']\n    optimizer_grouped_parameters = [\n        {'params': [p for n, p in param_optimizer if not any(nd in n for nd in no_decay)],\n         'weight_decay_rate': 0.01},\n        {'params': [p for n, p in param_optimizer if any(nd in n for nd in no_decay)],\n         'weight_decay_rate': 0.0}\n    ]\nelse:\n    param_optimizer = list(model.classifier.named_parameters())\n    optimizer_grouped_parameters = [{\"params\": [p for n, p in param_optimizer]}]\n\noptimizer = AdamW(\n    optimizer_grouped_parameters,\n    lr=3e-5,\n    eps=1e-8\n)\n","88f90401":"from transformers import get_linear_schedule_with_warmup\n\nepochs = 3\nmax_grad_norm = 1.0\n\n# Total number of training steps is number of batches * number of epochs.\ntotal_steps = len(train_dataloader) * epochs\n\n# Create the learning rate scheduler.\nscheduler = get_linear_schedule_with_warmup(\n    optimizer,\n    num_warmup_steps=0,\n    num_training_steps=total_steps\n)\n","31fd76d0":"pip install seqeval","adb21e5f":"from seqeval.metrics import f1_score, accuracy_score","90cd1dbc":"## Store the average loss after each epoch so we can plot them.\nloss_values, validation_loss_values = [], []\n\nfor _ in trange(epochs, desc=\"Epoch\"):\n    # ========================================\n    #               Training\n    # ========================================\n    # Perform one full pass over the training set.\n\n    # Put the model into training mode.\n    model.train()\n    # Reset the total loss for this epoch.\n    total_loss = 0\n\n    # Training loop\n    for step, batch in enumerate(train_dataloader):\n        # add batch to gpu\n        batch = tuple(t.to(device) for t in batch)\n        b_input_ids, b_input_mask, b_labels = batch\n        \n         ###############Bug fix code####################\n        b_input_ids = b_input_ids.type(torch.LongTensor)\n        b_input_mask = b_input_mask.type(torch.LongTensor)\n        b_labels = b_labels.type(torch.LongTensor)\n\n        b_input_ids = b_input_ids.to(device)\n        b_input_mask = b_input_mask.to(device)\n        b_labels = b_labels.to(device)\n         ############################################\n            \n            \n        # Always clear any previously calculated gradients before performing a backward pass.\n        model.zero_grad()\n        # forward pass\n        # This will return the loss (rather than the model output)\n        # because we have provided the `labels`.\n        outputs = model(b_input_ids, token_type_ids=None,\n                        attention_mask=b_input_mask, labels=b_labels)\n        # get the loss\n        loss = outputs[0]\n        # Perform a backward pass to calculate the gradients.\n        loss.backward()\n        # track train loss\n        total_loss += loss.item()\n        # Clip the norm of the gradient\n        # This is to help prevent the \"exploding gradients\" problem.\n        torch.nn.utils.clip_grad_norm_(parameters=model.parameters(), max_norm=max_grad_norm)\n        # update parameters\n        optimizer.step()\n        # Update the learning rate.\n        scheduler.step()\n\n    # Calculate the average loss over the training data.\n    avg_train_loss = total_loss \/ len(train_dataloader)\n    print(\"Average train loss: {}\".format(avg_train_loss))\n\n    # Store the loss value for plotting the learning curve.\n    loss_values.append(avg_train_loss)\n\n\n    # ========================================\n    #               Validation\n    # ========================================\n    # After the completion of each training epoch, measure our performance on\n    # our validation set.\n\n    # Put the model into evaluation mode\n    model.eval()\n    # Reset the validation loss for this epoch.\n    eval_loss, eval_accuracy = 0, 0\n    nb_eval_steps, nb_eval_examples = 0, 0\n    predictions , true_labels = [], []\n    for batch in valid_dataloader:\n        batch = tuple(t.to(device) for t in batch)\n        b_input_ids, b_input_mask, b_labels = batch\n\n        # Telling the model not to compute or store gradients,\n        # saving memory and speeding up validation\n        with torch.no_grad():\n            # Forward pass, calculate logit predictions.\n            # This will return the logits rather than the loss because we have not provided labels.\n            outputs = model(b_input_ids, token_type_ids=None,\n                            attention_mask=b_input_mask, labels=b_labels)\n        # Move logits and labels to CPU\n        logits = outputs[1].detach().cpu().numpy()\n        label_ids = b_labels.to('cpu').numpy()\n\n        # Calculate the accuracy for this batch of test sentences.\n        eval_loss += outputs[0].mean().item()\n        predictions.extend([list(p) for p in np.argmax(logits, axis=2)])\n        true_labels.extend(label_ids)\n\n    eval_loss = eval_loss \/ len(valid_dataloader)\n    validation_loss_values.append(eval_loss)\n    print(\"Validation loss: {}\".format(eval_loss))\n    pred_tags = [tag_values[p_i] for p, l in zip(predictions, true_labels)\n                                 for p_i, l_i in zip(p, l) if tag_values[l_i] != \"PAD\"]\n    valid_tags = [tag_values[l_i] for l in true_labels\n                                  for l_i in l if tag_values[l_i] != \"PAD\"]\n    print(\"Validation Accuracy: {}\".format(accuracy_score(pred_tags, valid_tags)))\n    print(\"Validation F1-Score: {}\".format(f1_score(pred_tags, valid_tags)))\n    print()\n","108b3f83":"import matplotlib.pyplot as plt\n%matplotlib inline\n\nimport seaborn as sns\n\n# Use plot styling from seaborn.\nsns.set(style='darkgrid')\n\n# Increase the plot size and font size.\nsns.set(font_scale=1.5)\nplt.rcParams[\"figure.figsize\"] = (12,6)\n\n# Plot the learning curve.\nplt.plot(loss_values, 'b-o', label=\"training loss\")\nplt.plot(validation_loss_values, 'r-o', label=\"validation loss\")\n\n# Label the plot.\nplt.title(\"Learning curve\")\nplt.xlabel(\"Epoch\")\nplt.ylabel(\"Loss\")\nplt.legend()\n\nplt.show()","d299f5f6":"test_sentence = \"\"\"\nMr. Trump\u2019s tweets began just moments after a Fox News report by Mike Tobin, a \nreporter for the network, about protests in Minnesota and elsewhere. \n\"\"\"","94780bbc":"tokenized_sentence = tokenizer.encode(test_sentence)\ninput_ids = torch.tensor([tokenized_sentence]).cuda()","c3a51f1d":"with torch.no_grad():\n    output = model(input_ids)\nlabel_indices = np.argmax(output[0].to('cpu').numpy(), axis=2)","76111458":"# join bpe split tokens\ntokens = tokenizer.convert_ids_to_tokens(input_ids.to('cpu').numpy()[0])\nnew_tokens, new_labels = [], []\nfor token, label_idx in zip(tokens, label_indices[0]):\n    if token.startswith(\"##\"):\n        new_tokens[-1] = new_tokens[-1] + token[2:]\n    else:\n        new_labels.append(tag_values[label_idx])\n        new_tokens.append(token)","5d5e3fba":"for token, label in zip(new_tokens, new_labels):\n    print(\"{}\\t{}\".format(label, token))","fdc1409e":"Now we tokenize all sentences","63c237c3":"# Named entity recognition with Bert","73233dac":"First we define some metrics, we want to track while training. We use the f1_score from the seqeval package. You can find more details here. And we use simple accuracy on a token level comparable to the accuracy in keras.","1dae9ebf":"The Bert model supports something called attention_mask, which is similar to the masking in keras. So here we create the mask to ignore the padded elements in the sequences.","29aff6a4":"# Load the data","a9feef1e":"The pytorch-pretrained-bert package provides a BertForTokenClassification class for token-level predictions. BertForTokenClassification is a fine-tuning model that wraps BertModel and adds token-level classifier on top of the BertModel. The token-level classifier is a linear layer that takes as input the last hidden state of the sequence. We load the pre-trained bert-base-uncased model and provide the number of possible labels.","abb0f97a":"# Apply the model to a new sentenceApply the model to a new sentence","631643a2":"# Fit BERT for named entity recognition","731d9d77":"Next, we cut and pad the token and label sequences to our desired length.","a9a330d4":"# Visualize the training loss","73abf42d":"# Apply Bert\n# Prepare the sentences and labels","b227c953":"##Before we can start the fine-tuning process, we have to setup the optimizer and add the parameters it should update. A common choice is the AdamW optimizer. We also add some weight_decay as regularization to the main weight matrices. If you have limited resources, you can also try to just train the linear classifier on top of BERT and keep all other weights fixed. This will still give you a good performance.","a0d72b47":"# Setup the Bert model for finetuning"}}