{"cell_type":{"e3a4cdc7":"code","65d7b105":"code","0cc722ee":"code","b2b2820d":"code","570b3e9c":"code","9fec97e3":"code","7a5c25f6":"code","53124607":"code","3e7c832f":"code","1486f126":"code","4e31c7de":"code","90279599":"code","247cb069":"code","b1bff1ef":"code","78270511":"code","1b7c207e":"code","553573cf":"code","2fd72a2f":"code","46945d74":"code","4e61227e":"code","4d72c26e":"code","f043ef63":"code","b5ec5966":"code","e398f641":"code","35d5e2d7":"code","10c0b028":"code","7813b091":"code","2232fbff":"code","ac84fa4c":"code","2605e1b8":"code","9eb121ba":"code","99ea92f3":"code","5bb173f2":"code","330c7183":"code","7972c02c":"code","86ed7330":"code","99d030da":"code","4206fc15":"code","0397f7b9":"code","bc2561ce":"code","c90b8ef0":"code","35af2574":"code","37e3547b":"code","51c6bcbb":"code","babc76dc":"code","6487f675":"code","181a58ce":"code","2994cda2":"code","42dbf106":"code","9de1b753":"code","1e4d5373":"code","2b4cfa66":"code","1229eeb1":"code","82bcea4a":"code","6b174744":"code","235fa260":"code","fd9d6b7b":"code","3842e2af":"code","e0c7f067":"code","bd26b088":"code","1bccc921":"code","be968e96":"code","ae4c5ca6":"code","23d730cf":"code","935e42c2":"code","12c09247":"code","0142ac9f":"code","55bd2885":"code","1935ab9d":"code","6cf11149":"code","a282ff91":"code","7dfd6091":"code","d73d5d71":"code","370ca69e":"code","3789c525":"code","67e82b01":"code","71f0b2f3":"code","090915d9":"code","c6979bbd":"code","b158ff27":"markdown","e56ba008":"markdown","119a9946":"markdown","a4b84761":"markdown","dbf30997":"markdown","53eea258":"markdown","afb34426":"markdown","0f056fbc":"markdown","c8e2d901":"markdown","74a1dcd4":"markdown","08797889":"markdown","96cc3f88":"markdown","3d5db924":"markdown","ee9568de":"markdown","c45af966":"markdown","eaacb466":"markdown","c7f8c641":"markdown","0102f592":"markdown","3cd61ef3":"markdown","b81741d1":"markdown","8829713f":"markdown","8187a3fc":"markdown","d8776fb6":"markdown","774af36a":"markdown","c2c69acb":"markdown","59d11046":"markdown","28e5e48f":"markdown","64050fed":"markdown","da956c63":"markdown","f444d21d":"markdown","183c0250":"markdown"},"source":{"e3a4cdc7":"#Importing required libraries\nimport numpy as np\nimport pandas as pd\n\nfrom geopy.geocoders import Nominatim\ntry:\n    import geocoder\nexcept:\n    !pip install geocoder\n    import geocoder\n\nimport requests\nfrom bs4 import BeautifulSoup\n\ntry:\n    import folium\nexcept:\n    !pip install folium\n    import folium\n    \nfrom sklearn.cluster import KMeans\n\nfrom sklearn import preprocessing\n\nfrom sklearn.model_selection import train_test_split\n\nfrom sklearn.neighbors import KNeighborsClassifier\n\nfrom sklearn import metrics\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt","65d7b105":"# install wordcloud\n!pip install wordcloud\n# import package and its set of stopwords\nfrom wordcloud import WordCloud, STOPWORDS\n\nprint ('Wordcloud is installed and imported!')","0cc722ee":"#Getting the location of Bangalore city using the geocoder package\ng = geocoder.arcgis('Bangalore, India')\nblr_lat = g.latlng[0]\nblr_lng = g.latlng[1]\nprint(\"The Latitude and Longitude of Bangalore is {} and {}\".format(blr_lat, blr_lng))","b2b2820d":"#Scraping the Wikimedia webpage for list of localities present in Bangalore city\nneig = requests.get(\"https:\/\/commons.wikimedia.org\/wiki\/Category:Suburbs_of_Bangalore\").text","570b3e9c":"#parsing the scraped content\nsoup = BeautifulSoup(neig, 'html.parser')","9fec97e3":"#Creating a list to store neighborhood data\nneighborhoodlist = []","7a5c25f6":"#Searching the localities using class labels and appending it to the neighborhood list\nfor i in soup.find_all('div', class_='mw-category')[0].find_all('a'):\n    neighborhoodlist.append(i.text)\n\n#Creating a dataframe from the list\nneig_df = pd.DataFrame({\"Locality\": neighborhoodlist})\nneig_df.head()","53124607":"#Shape of dataframe neig_df\nneig_df.shape","3e7c832f":"#Defining a function to get the location of the localities\ndef get_location(localities):\n    g = geocoder.arcgis('{}, Bangalore, India'.format(localities))\n    get_latlng = g.latlng\n    return get_latlng","1486f126":"#Creating an empty list\nco_ordinates = []\n#Getting the co-ordinates of each locality using the function defined above\nfor i in neig_df[\"Locality\"].tolist():\n    co_ordinates.append(get_location(i))\nprint(co_ordinates)","4e31c7de":"co_ordinates[:5]","90279599":"#Creating a dataframe from the list of location co-ordinates\nco_ordinates_df = pd.DataFrame(co_ordinates, columns=['Latitudes', 'Longitudes'])","247cb069":"#Adding co-ordinates of localities to neig_df dataframe\nneig_df[\"Latitudes\"] = co_ordinates_df[\"Latitudes\"]\nneig_df[\"Longitudes\"] = co_ordinates_df[\"Longitudes\"]","b1bff1ef":"print(\"The shape of neig_df is {}\".format(neig_df.shape))\nneig_df.head()","78270511":"#Creating a map\nblr_map = folium.Map(location=[blr_lat, blr_lng],zoom_start=11)\n\n#adding markers to the map for localities\n#marker for Bangalore\nfolium.Marker([blr_lat, blr_lng], popup='<i>Bangalore<\/i>', color='red', tooltip=\"Click to see\").add_to(blr_map)\n\n#markers for localities\nfor latitude,longitude,name in zip(neig_df[\"Latitudes\"], neig_df[\"Longitudes\"], neig_df[\"Locality\"]):\n    folium.CircleMarker(\n        [latitude, longitude],\n        radius=6,\n        color='blue',\n        popup=name,\n        fill=True,\n        fill_color='#3186ff'\n    ).add_to(blr_map)\n\nblr_map","1b7c207e":"#Foursquare Credentials\n# @hidden_cell\nCLIENT_ID = 'CLIENT_ID'\nCLIENT_SECRET = 'CLIENT_SECRET'\nVERSION = '20180605' # Foursquare API version","553573cf":"#Getting the top 100 venues in each locality\nradius = 2000\nLIMIT = 100\n\nvenues = []\n\nfor lat, lng, locality in zip(neig_df[\"Latitudes\"], neig_df[\"Longitudes\"], neig_df[\"Locality\"]):\n    url = 'https:\/\/api.foursquare.com\/v2\/venues\/explore?client_id={}&client_secret={}&ll={},{}&v={}&radius={}&limit={}'.format(CLIENT_ID, CLIENT_SECRET, lat, lng, VERSION, radius, LIMIT)\n    results = requests.get(url).json()['response']['groups'][0]['items']\n\n    for venue in results:\n        venues.append((locality, lat, lng, venue['venue']['name'], venue['venue']['location']['lat'], venue['venue']['location']['lng'], venue['venue']['categories'][0]['name'], venue['venue']['id']))","2fd72a2f":"#Looking at the first venue\nvenues[0]","46945d74":"#Convert the venue list into dataframe\nvenues_df = pd.DataFrame(venues)\nvenues_df.columns = ['Locality', 'Latitude', 'Longitude', 'Venue name', 'Venue Lat', 'Venue Lng', 'Venue Category', 'Venue ID']\nvenues_df.head()","4e61227e":"venues_df.shape","4d72c26e":"#Getting the list of all the categories of all the restaurant present in venues_df dataframe\nres_df = pd.DataFrame({'Venue Category': venues_df['Venue Category'], 'Strength': venues_df['Venue Category']})\nres_df = res_df.groupby(['Venue Category']).count()\nres_df = res_df.sort_values(['Strength'], ascending=False)\nprint(res_df.head())\nprint(\"We can see that most restaurants belongs to Indian Restaurant category i.e. {}\".format(res_df['Strength'][0]))","f043ef63":"res_df.shape","b5ec5966":"demo1_df = pd.DataFrame({'Venue Category':res_df.index[:50]})\ncategory_strength=[]\nfor i in range(50):\n    category_strength.append(res_df['Strength'][i])\ndemo2_df = pd.DataFrame(category_strength, columns=['Strength'])\ndemo_df = pd.DataFrame({'Venue Category': demo1_df['Venue Category'], 'Strength': demo2_df['Strength']})\ndemo_df.head()","e398f641":"word_string = ''\nfor i in range(50):\n    tmp = demo_df['Venue Category'][i]\n    if len(tmp.split(' ')) == 1:\n        word_string = word_string + (tmp + ' ')*demo_df['Strength'][i]\n    else:\n        part = tmp.split(' ')\n        tmp = part[0]+'_'+part[1]\n        word_string = word_string + (tmp + ' ')*demo_df['Strength'][i]","35d5e2d7":"wordcloud = WordCloud(width=800, height=400, collocations=False).generate(word_string)\nprint('Word cloud created!')\n# Open a plot of the generated image.\n\nplt.figure( figsize=(10,9), facecolor='k')\nplt.imshow(wordcloud)\nplt.axis(\"off\")\nplt.tight_layout(pad=0)\nplt.show()","10c0b028":"#List of 50 most common categories of restuarants in Bangalore City\ncat_res_list = res_df.index[0:50]\ncat_res_list","7813b091":"#creating a dataframe from the list of common categories created above\nvenue_etables = venues_df[venues_df['Venue Category'].isin(['Indian Restaurant', 'Caf\u00e9', 'Ice Cream Shop', 'Fast Food Restaurant',\n       'Pizza Place', 'Coffee Shop', 'Hotel', 'Chinese Restaurant', 'Lounge',\n       'Italian Restaurant', 'Bakery', 'Pub', 'Restaurant',\n       'Asian Restaurant', 'Breakfast Spot', 'Bar', 'Brewery', 'Burger Joint',\n       'Shopping Mall', 'Sandwich Place', 'Vegetarian \/ Vegan Restaurant',\n       'BBQ Joint', 'Snack Place', 'Park', 'Juice Bar',\n       'South Indian Restaurant', 'Tea Room',\n       'Middle Eastern Restaurant', 'Dessert Shop', 'Donut Shop', 'Bookstore',\n       'Multiplex', 'Cocktail Bar',\n       'Seafood Restaurant', 'Mexican Restaurant', 'French Restaurant',\n       'Andhra Restaurant', 'Korean Restaurant', 'Cupcake Shop',\n       'Karnataka Restaurant', 'Steakhouse', 'Boutique', 'Liquor Store',\n       'Arcade', 'Deli \/ Bodega', 'Bus Station'])]","2232fbff":"#Function for calculating the tipcount for each venue\ndef addingtip(venue_id):\n    url = 'https:\/\/api.foursquare.com\/v2\/venues\/{}?client_id={}&client_secret={}&v={}&radius={}&limit={}'.format(venue_id, CLIENT_ID, CLIENT_SECRET, VERSION, radius, LIMIT)\n    stats = requests.get(url).json()['response']\n    tipcount = stats['venue']['stats']['tipCount']\n    return tipcount","ac84fa4c":"#calling the addingtip function for each venue\ntip_count = []\nfor i in venue_etables[\"Venue ID\"]:\n    venue_id = venue_etables['Venue ID'].iloc[i]\n    tipcount = addingtip(venue_id)\n    tip_count.append(tipcount)","2605e1b8":"#Converting the list into a dataframe\ndf_tipcount = pd.DataFrame(tip_count)","9eb121ba":"#Changing the column name of df_tipcount dataframe\ndf_tipcount.columns = [\"Tip count\"]\ndf_tipcount.head()","99ea92f3":"#Attaching the tip_count to the venue_etables and creating a new dataframe\nvenue_etables[\"Tip count\"] = df_tipcount[\"Tip count\"]\nvenue_etables.head()","5bb173f2":"#creating one hot encoding\nblr_onehot = pd.get_dummies(venues_df[['Venue Category']], prefix=\"\", prefix_sep=\"\")\n\nblr_onehot['Locality'] = venues_df['Locality']\n\n#moving the locality column to the front\nblr_onehot = blr_onehot[ [ 'Locality' ] + [ col for col in blr_onehot.columns if col!='Locality' ] ]\nblr_onehot.head()","330c7183":"blr_grouped = blr_onehot.groupby(['Locality']).mean().reset_index()\nprint(blr_grouped.shape)\nblr_grouped.head()","7972c02c":"#numbers of localities having Italian Restaurants\nlen(blr_grouped[blr_grouped['Italian Restaurant'] > 0])","86ed7330":"blr_italian = blr_grouped[['Locality', 'Italian Restaurant']]\nblr_italian.head()","99d030da":"#Creating a map\nblr_map = folium.Map(location=[blr_lat, blr_lng],zoom_start=11)\n\n#adding markers to the map for localities\n#marker for Bangalore\nfolium.Marker([blr_lat, blr_lng], popup='<i>Bangalore<\/i>', color='red', tooltip=\"Click to see\").add_to(blr_map)\n\n#markers for localities\nfor latitude,longitude,name,strength in zip(neig_df[\"Latitudes\"], neig_df[\"Longitudes\"], neig_df[\"Locality\"], blr_italian[\"Italian Restaurant\"]):\n    folium.CircleMarker(\n        [latitude, longitude],\n        radius=strength*300,\n        color='green',\n        popup=name,\n        fill=True,\n        fill_color='#3186ff'\n    ).add_to(blr_map)\n\nblr_map","4206fc15":"#K-means clustering\ncluster = 3 \n\n#Dataframe for clustering\nblr_clustering = blr_italian.drop(['Locality'], 1)\n\n#run K-means clustering\nk_means = KMeans(init=\"k-means++\", n_clusters=cluster, n_init=12).fit(blr_clustering)\n\n#getting the labels for first 10 locality \nprint(k_means.labels_[0:10])","0397f7b9":"#Creating a copy of blr_italian dataframe\nblr_labels = blr_italian.copy()\n\n#adding label to blr_labels\nblr_labels[\"Cluster Label\"] = k_means.labels_\n\nblr_labels.head()","bc2561ce":"#Merging the blr_labels and neig_df dataframes to get the latitude and longitudes for each locality\nblr_labels = blr_labels.join(neig_df.set_index('Locality'), on='Locality')\nblr_labels.head()","c90b8ef0":"#Grouping the localities according to their Cluster Labels\nblr_labels.sort_values([\"Cluster Label\"], inplace=True)\nblr_labels.head()","35af2574":"#Cleaning the dataframe for mapping the localities according to their cluster labels\nblr_only_labels = blr_labels.drop(columns=['Italian Restaurant','Latitudes','Longitudes'])\nblr_only_labels.head()","37e3547b":"#Plot the cluster on map\ncluster_map = folium.Map(location=[blr_lat, blr_lng],zoom_start=11)\n\n#marker for Bangalore\nfolium.Marker([blr_lat, blr_lng], popup='<i>Bangalore<\/i>', color='red', tooltip=\"Click to see\").add_to(cluster_map)\n\n#Getting the colors for the clusters\ncol = ['red', 'green', 'blue']\n\n#markers for localities\nfor latitude,longitude,name,clus in zip(blr_labels[\"Latitudes\"], blr_labels[\"Longitudes\"], blr_labels[\"Locality\"], blr_labels[\"Cluster Label\"]):\n    label = folium.Popup(name + ' - Cluster ' + str(clus+1))\n    folium.CircleMarker(\n        [latitude, longitude],\n        radius=6,\n        color=col[clus],\n        popup=label,\n        fill=False,\n        fill_color=col[clus],\n        fill_opacity=0.3\n    ).add_to(cluster_map)\n       \ncluster_map","51c6bcbb":"#Cluster 1\n#Dataframe containing localities with cluster label 0, which corresponds to localities with no Italian Restaurant\ncluster_1 = blr_labels[blr_labels['Cluster Label'] == 0]\nprint(\"There are {} localities in cluster-1\".format(cluster_1.shape[0]))\nmean_presence_1 = cluster_1['Italian Restaurant'].mean()\nprint(\"The mean occurence of Italian restaurant in cluster-1 is {0:.2f}\".format(mean_presence_1))\ncluster_1.head()","babc76dc":"#Cluster 2\n#Dataframe containing localities with cluster label 1, which corresponds to localities with high density of Italian Restaurant\ncluster_2 = blr_labels[blr_labels['Cluster Label'] == 1]\nprint(\"There are {} localities in cluster-2\".format(cluster_2.shape[0]))\nmean_presence_2 = cluster_2['Italian Restaurant'].mean()\nprint(\"The mean occurence of Italian restaurant in cluster-2 is {0:.2f}\".format(mean_presence_2))\ncluster_2.head()","6487f675":"#Cluster 3\n#Dataframe containing localities with cluster label 2, which corresponds to localities with low density of Italian Restaurant\ncluster_3 = blr_labels[blr_labels['Cluster Label'] == 2]\nprint(\"There are {} localities in cluster-3\".format(cluster_3.shape[0]))\nmean_presence_3 = cluster_3['Italian Restaurant'].mean()\nprint(\"The mean occurence of Italian restaurant in cluster-3 is {0:.2f}\".format(mean_presence_3))\ncluster_3.head()","181a58ce":"#Function for getting the cluster label of each locality\ndef get_clus_label(locality):\n    loca = locality\n    for i in range(blr_only_labels.shape[0]):\n        value = blr_only_labels.iloc[i]\n        value_locality = value[0]\n        value_cluster_label = value[1]\n        if value_locality == loca:\n            return value_cluster_label","2994cda2":"#Getting the cluster label and appending it to \"cluster_label\" list\ncluster_labels = []\nfor locality in venue_eatables['Locality']:\n    label = get_clus_label(locality)\n    cluster_labels.append(label)","42dbf106":"#adding the cluster_label to the venue_eatables dataframe\ncluster_labels_df = pd.DataFrame(cluster_labels, columns=['Cluster Label'])\nvenue_eatables['Cluster Labels'] = cluster_labels_df['Cluster Label']\nvenue_eatables.head()","9de1b753":"#creating a dataframe with empty columns for surrounding venues which will contain 30 surrounding venues\nfor i in range(30):\n    tag = \"SV \"\n    tag = tag + str(i+1) \n    venue_eatables[tag] = \"\"\nvenue_eatables.head()","1e4d5373":"#Separating the venue_eatables dataframe into two, one for the localities containing Italian restaurants and the other for localities \n#that does not contains Italian restaurants\nvenue_eatables_without_italian = venue_eatables[~venue_eatables['Venue Category'].isin(['Italian Restaurant'])]\nvenue_eatables_without_italian.reset_index(inplace=True, drop=True)\nvenue_eatables_with_italian = venue_eatables[venue_eatables['Venue Category'].isin(['Italian Restaurant'])]\nvenue_eatables_with_italian.reset_index(inplace=True, drop=True)","2b4cfa66":"#Setting the radius and LIMIT of the results from foursquare API\nradius = 2000\nLIMIT = 30","1229eeb1":"# Getting the 30 nearest venues around the given venue in localities with Italian restaurant\n# and adding it to the venue_eatables_without_italian dataframe\nfor i in range(venue_eatables_with_italian.shape[0]):\n    venue = venue_eatables_with_italian.loc[i,'Venue name']\n    venue_lat = venue_eatables_with_italian.loc[i,'Venue Lat']\n    venue_lng = venue_eatables_with_italian.loc[i,'Venue Lng']\n    \n    url = 'https:\/\/api.foursquare.com\/v2\/venues\/explore?client_id={}&client_secret={}&ll={},{}&v={}&radius={}&limit={}'.format(CLIENT_ID, CLIENT_SECRET, venue_lat, venue_lng, VERSION, radius, LIMIT)\n    results = requests.get(url).json()\n    \n    for j in range(30):\n        sv_index = \"SV \" + str(j+1)\n        try:\n            cat = results['response']['groups'][0]['items'][j]['venue']['categories'][0]['name']\n        except:\n            cat = np.nan\n        venue_eatables_with_italian.loc[i, sv_index] = cat","82bcea4a":"pd.set_option('display.max_columns', 40)\npd.set_option('display.max_rows', 5000)","6b174744":"# Getting the 30 nearest venues around the given venue in localities without Italian restaurant\n# and adding it to the venue_eatables_without_italian dataframe\nfor i in range(venue_eatables_without_italian.shape[0]):\n    venue = venue_eatables_without_italian.loc[i,'Venue name']\n    venue_lat = venue_eatables_without_italian.loc[i,'Venue Lat']\n    venue_lng = venue_eatables_without_italian.loc[i,'Venue Lng']\n    \n    url = 'https:\/\/api.foursquare.com\/v2\/venues\/explore?client_id={}&client_secret={}&ll={},{}&v={}&radius={}&limit={}'.format(CLIENT_ID, CLIENT_SECRET, venue_lat, venue_lng, VERSION, radius, LIMIT)\n    results = requests.get(url).json()\n    \n    for j in range(30):\n        sv_index = \"SV \" + str(j+1)\n        try:\n            cat = results['response']['groups'][0]['items'][j]['venue']['categories'][0]['name']\n        except:\n            cat = np.nan\n        venue_eatables_without_italian.loc[i, sv_index] = cat","235fa260":"#Creating the dataframe neig_df with empty columns for 30 venues in that locality\nfor i in range(30):\n    tag = \"SV \"\n    tag = tag + str(i+1) \n    neig_df[tag] = \"\"\nneig_df.head()","fd9d6b7b":"# Getting the list of 30 venues in each locality in Bangalore\nfor i in range(neig_df.shape[0]):\n    venue = neig_df.loc[i,'Locality']\n    venue_lat = neig_df.loc[i,'Latitudes']\n    venue_lng = neig_df.loc[i,'Longitudes']\n    \n    url = 'https:\/\/api.foursquare.com\/v2\/venues\/explore?client_id={}&client_secret={}&ll={},{}&v={}&radius={}&limit={}'.format(CLIENT_ID, CLIENT_SECRET, venue_lat, venue_lng, VERSION, radius, LIMIT)\n    results = requests.get(url).json()\n    \n    for j in range(30):\n        sv_index = \"SV \" + str(j+1)\n        try:\n            cat = results['response']['groups'][0]['items'][j]['venue']['categories'][0]['name']\n        except:\n            cat = np.nan\n        neig_df.loc[i, sv_index] = cat","3842e2af":"#concatenatig the two dataframes \"venue_eatables_with_italian\" and \"venue_eatables_without_italian\" to create one dataframe\nvenue_eatables_with_sv = pd.concat([venue_eatables_with_italian, venue_eatables_without_italian])\nprint(venue_eatables_with_sv.shape)\nvenue_eatables_with_sv.head()","e0c7f067":"#cleaning the train_df for only relevant columns for training the model\nvenue_eatables_with_sv = venue_eatables_with_sv.drop(columns=['Locality','Latitude','Longitude','Venue name','Venue Lat','Venue Lng','Venue ID','Tip count','Cluster Labels'])\nvenue_eatables_with_sv.reset_index(inplace = True, drop = True) \nvenue_eatables_with_sv.head()","bd26b088":"#cleaning the neig_df_with_sv for only relevant columns for prediction.\nneig_df_with_sv = neig_df_with_sv.drop(columns=['Latitudes','Longitudes'])\n#saving this intermediate dataframe for using to compare the prediction \nneig_df_with_sv_interm = neig_df_with_sv\nneig_df_with_sv = neig_df_with_sv.drop(columns=['Locality'])\nneig_df_with_sv.head()","1bccc921":"#Getting the categories of venues present in the datasets and indexing them \n#so that categories can be replaced with respective index for training the model\ncategory_list_df = pd.DataFrame({'Venue Category': venues_df['Venue Category'], 'Venue Cat': venues_df['Venue Category']})\ncategory_list_df = category_list_df['Venue Category'].unique()\ncategory_list_df = category_list_df.tolist()\ncategory_dict = { category_list_df[i] : i for i in range(len(category_list_df))}","be968e96":"#Replacing the categories in dataframe \"venue_eatables_with_sv\" with their respective index\nvenue_eatables_with_sv = venue_eatables_with_sv.applymap(lambda x: category_dict.get(x) if x in category_dict else x)\nvenue_eatables_with_sv.head()","ae4c5ca6":"#finding missing categories in venue_eatables_with_sv\nmissing_cat = []\nfor i in range(venue_eatables_with_sv.shape[0]):\n    for j in range(venue_eatables_with_sv.shape[1]):\n        if isinstance(venue_eatables_with_sv.iloc[i][j], str) and venue_eatables_with_sv.iloc[i][j] not in missing_cat:\n            missing_cat.append(venue_eatables_with_sv.iloc[i][j])\n\nprint(missing_cat)","23d730cf":"#Appending the missing venue categories with index to the category_dict dictionary\nmissing_cat.append('Wings Joint')\ncategory_list_df = category_list_df+missing_cat\ncategory_dict = { category_list_df[i] : i for i in range(len(category_list_df))}\nprint(category_dict)","935e42c2":"#Replacing the categories in dataframe \"venue_eatables_with_sv\" with their respective code\nvenue_eatables_with_sv = venue_eatables_with_sv.applymap(lambda x: category_dict.get(x) if x in category_dict else x)\nvenue_eatables_with_sv = venue_eatables_with_sv.fillna(300)\nvenue_eatables_with_sv.head()","12c09247":"#Replacing the categories in dataframe \"neig_df_with_sv\" with their respective code\nneig_df_with_sv = neig_df_with_sv.applymap(lambda x: category_dict.get(x) if x in category_dict else x)\nneig_df_with_sv = neig_df_with_sv.fillna(300)\nneig_df_with_sv.head()","0142ac9f":"#creating X and Y array for input and output values\nX = venue_eatables_with_sv[['SV 1', 'SV 2', 'SV 3', 'SV 4', 'SV 5', 'SV 6', 'SV 7', 'SV 8', 'SV 9', 'SV 10', 'SV 11', 'SV 12', 'SV 13', 'SV 14', 'SV 15', 'SV 16', 'SV 17', 'SV 18', 'SV 19', 'SV 20', 'SV 21', 'SV 22', 'SV 23', 'SV 24', 'SV 25', 'SV 26', 'SV 27', 'SV 28', 'SV 29', 'SV 30']].values\nY = venue_eatables_with_sv[['Venue Category']].values","55bd2885":"X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=4)\nprint('Train Set:',X_train.shape, Y_train.shape)\nprint('Test Set:',X_test.shape, Y_test.shape)","1935ab9d":"#Cheking accuracy for different value of Ks.\nks=11\nmean_acc = np.zeros(ks-1)\nstd_acc = np.zeros(ks-1)\n\nfor i in range(1, ks):\n    \n    #training model and predicting\n    clf = KNeighborsClassifier(n_neighbors=i).fit(X_train, Y_train.ravel())\n    yhat = clf.predict(X_test)\n    mean_acc[i-1] = metrics.accuracy_score(Y_test, yhat)\n    std_acc[i-1] = np.std(yhat==Y_test)\/np.sqrt(yhat.shape[0])","6cf11149":"print(mean_acc)","a282ff91":"#Plotting the accuracy for different values of K\nplt.plot(range(1,ks),mean_acc,'g')","7dfd6091":"#To avoid overfitting of the model we are taking K=3\n#Creating the model and training it with train data\nk=3\nclf = KNeighborsClassifier(n_neighbors=k).fit(X_train,Y_train.ravel())\nclf","d73d5d71":"#predicting\nyhat = clf.predict(X_test)","370ca69e":"#accuracy evaluation\nprint(\"Test set accuracy : \", metrics.accuracy_score(Y_test, yhat))","3789c525":"#Training the model with whole dataset\nk=3\nclf1 = KNeighborsClassifier(n_neighbors=k).fit(X,Y.ravel())\nclf1","67e82b01":"#predicting the probable localities usnig the above trained model\npred = clf1.predict(neig_df_with_sv)\nprint(pred)","71f0b2f3":"#defining the function to get the keys from the values, from category_dict dictionary\ndef get_key(val):\n    for key, value in category_dict.items():\n        if value == val:\n            return key\n#Using the dictionary \"category_dict\", we'll change the indices predicted by the model back to the name of the categories\n#Creating new variable \"pred_cat\" for predicted categories\npred_cat = []\nfor i in range(len(pred)):\n    pred_cat.append(get_key(pred[i]))","090915d9":"#changing the list pred_cat to a dataframe\npred_cat_df = pd.DataFrame(pred_cat, columns=['Prediction'])\n#adding the prediction column from pred_cat_df to neig_df_with_sv_interm\nneig_df_with_sv_interm[\"Prediction\"] = pred_cat_df[\"Prediction\"]\n#moving the prediction column to the front\nneig_df_with_sv_interm = neig_df_with_sv_interm[ [ 'Prediction' ] + [ col for col in neig_df_with_sv_interm.columns if col!='Prediction' ] ]\nneig_df_with_sv_interm[50:55]","c6979bbd":"#Plot the cluster on map\ncluster_map = folium.Map(location=[blr_lat, blr_lng],zoom_start=11)\n\n#marker for Bangalore\nfolium.Marker([blr_lat, blr_lng], popup='<i>Bangalore<\/i>', color='red', tooltip=\"Click to see\").add_to(cluster_map)\n\n#predicted locality\npred_locality = None\nfor locality, prediction in zip(neig_df_with_sv_interm['Locality'], neig_df_with_sv_interm['Prediction']):\n    if prediction == \"Italian Restaurant\":\n        pred_locality = locality\n\n#Getting the colors for the clusters\ncol = ['red', 'green', 'blue']\n\n#markers for localities\nfor latitude,longitude,name,clus in zip(blr_labels[\"Latitudes\"], blr_labels[\"Longitudes\"], blr_labels[\"Locality\"], blr_labels[\"Cluster Label\"]):\n    label = folium.Popup(name + ' - Cluster ' + str(clus+1))\n    if name==pred_locality:\n        folium.Marker([latitude, longitude], popup=name, color='orange', tooltip=\"This is the predicted locality for opening a new Italian Restaurant.\").add_to(cluster_map)\n    else:\n        folium.CircleMarker(\n            [latitude, longitude],\n            radius=6,\n            color=col[clus],\n            popup=label,\n            fill=False,\n            fill_color=col[clus],\n            fill_opacity=0.3\n        ).add_to(cluster_map)\n       \ncluster_map","b158ff27":"<h3>13. Clearing the datasets for training the model<\/h3>","e56ba008":"<t>This project will use data from : <\/t>\n<ul>\n    <li>Geopy - For getting the co-ordinated of different locations.<\/li>\n    <li>Foursquare API - To get the list of vanues and their details around a given location.<\/li>\n<\/ul>","119a9946":"<h3>6. Using Foursquare API to explore the localities<\/h3>","a4b84761":"<h3>12. Getting the surrounding venues for each respective venue and adding them to dataframe<\/h3>","dbf30997":"<b>Results for the Machine Learning Model<\/b>\nOur model has been trained, based on 30 other venues present in a locality which has atleast one Italian restaurant. We then also collected 30 venues from each locality that does not contain any Italian restaurant. The model then predicts the best locality by matching the combination of venues present in other localities that is already sustaining other Italian restaurant.\nThe outcome from the Machine learning suggests that \"UB City\" Locality in Bangalore can be one of the suitable location for opening a New Italian Restaurant. Though, Thubarahalli belongs to Cluster-3(shown in blue color) which medium density of existing Italian restaurant, the combination of already present venues will be able to attract customer and maintain footfall, as done in other locations with similar composition of venues.\nAlso by choosing a locality in Cluster-3, we can avoid un-neccessary competition already present in Cluster-2 and scarcity of footfall in Cluster-1.","53eea258":"<h3>16. Conclusion<\/h3>","afb34426":"<h1>Capstone Project - Battle of Neighborhoods (week 2)<\/h1>\n<h2>Applied Data Science Capstone<\/h2>","0f056fbc":"<h3>1. Importing required libraries<\/h3>","c8e2d901":"<h3>10. Creating the venue_eatables dataframe with cluster number.<\/h3>","74a1dcd4":"<h3>14. Predicting Using the Model<\/h3>","08797889":"<h3>5. Plotting the Localities on map<\/h3>","96cc3f88":"<ul>\n    <li>From above analysis we can infer that cluster-1(shown with red color) has no existing Italian Restaurant with the highest numbers of the same in cluster-2(shown with green color) and moderate number of Italian Restaurants are present in cluster-3(shown with blue color) located in the central part of the city.<\/li>\n    <li>This analysis presents a great opportunity to entrepreneurs to tap into the unutilized potential of the outer parts of the city of Bangalore by opening Italian Restaurants.<\/li>\n    <li>It is also evident that cluster-2(around the central part of the city) is suffering from high competition and over supply, hence investment in this area should be avoided by developers. <\/li>\n    <li>Developers with unique selling propositions that can stand out from the moderate competiton in cluste-3 and can take moderate risk and attract the customers already visiting the locality of this cluster because of the existing Italian Restaurant.<\/li>\n<\/ul>","3d5db924":"<h3>7. Analyzing the Localities according to the venues<\/h3>\n<h4>Creating one hot encoding<\/h4>","ee9568de":"<h3>8. Clustering The Localities<\/h3>","c45af966":"Using K-means clustering for clustering the locality in Bangalore base on the density of Italian restaurants present in each locality by using the above dataframe created.","eaacb466":"<h3>13. Creating a Machine Learning model and training it.<\/h3>","c7f8c641":"<h4>Opening a new Italian Restaurant in Bangalore, Karnataka<\/h4>","0102f592":"<h3>2. Getting the location<\/h3>","3cd61ef3":"<h3>3. Getting the List of Neighborhoods in Bangalore from Wikipedia<\/h3>","b81741d1":"<h3>11. Getting the surrounding venues of each respective Venue in the dataframe.<\/h3>","8829713f":"<h3>Methodology<\/h3>","8187a3fc":"<h3>9. Analyzing The Cluster<\/h3>","d8776fb6":"<h3>Introduction to Business Problem<\/h3>","774af36a":"<t>The objective of this report is to determine the best possible location to open an Italian Restaurant in Bangalore, Karnataka based on the different localities of the city, already established Italian restaurant in varios geographical location and ease of accessibility by maximum number of people so that the revenue from the latest venture can be maximized.<\/t>","c2c69acb":"<h3>15. Plotting the predicted Locality<\/h3>","59d11046":"<h3>4. Getting the location of the Localities<\/h3>","28e5e48f":"<ol>\n    <li>Getting the co-ordinates of the target city.<\/li>\n    <li>Getting the list of neighborhoods and their co-ordinates.<\/li>\n    <li>Exploring the most visited venues in the target localities.<\/li>\n    <li>Clustering the localities.<\/li>\n    <li>Analyzing the clusters formed.<\/li>\n    <li>Collecting information about the type of restaurants already present in a locality.<\/li>\n    <li>Creating a machine learning model based on data acquired.<\/li>\n    <li>Using the model to predict the locality best suited for upcoming Italian Resataurant.<\/li>\n<\/ol>","64050fed":"<h3>Data<\/h3>","da956c63":"\"Italian Restaurant\" prediction is coming for \"UB City\" which is a part of Cluster-3(shown in blue color) which medium density of existing italian restaurant.","f444d21d":"<h4>Grouping the categories<\/h4>","183c0250":"<b>About Data Normalization<\/b>\n<br \/>\n<i>We will not be doing data normalization for this dataset containing the indices of venue categories as the values are in the same range.<\/i>"}}