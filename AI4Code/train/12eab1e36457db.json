{"cell_type":{"955648c4":"code","75208395":"code","1cc8642c":"code","6f7b3e8e":"code","ec619dfc":"code","5ffe090c":"code","7f792144":"code","fc91bb21":"code","e135f793":"code","a4e8dce2":"code","0b326461":"code","fe8b90ab":"code","ef28f548":"code","a1dc1d0a":"code","2b4550d2":"code","33b10fa1":"code","0fa13df2":"code","cffc855a":"code","5a19c27b":"code","1c3da23c":"code","a37d433d":"code","9ba85d77":"code","55be8f07":"code","4f1fe912":"code","67de8453":"code","36e6fd91":"code","ae3a0639":"code","3bf8ebae":"code","983672e7":"markdown","133d00bd":"markdown","08b951c3":"markdown","891cebe3":"markdown","e0ee3f00":"markdown","39a497b2":"markdown","a47d574a":"markdown","a0d0024c":"markdown","63b9069f":"markdown"},"source":{"955648c4":"import numpy as np # linear algebra\nfrom scipy.stats import pearsonr\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom pandas.api.types import union_categoricals\nfrom matplotlib import pyplot as plt \nimport seaborn as sns\n\nfrom os import listdir\nfrom os import path\nfrom sklearn.decomposition import KernelPCA\n","75208395":"train_data = pd.read_csv(path.join(\"..\", \"input\", \"learn-together\", \"train.csv\"))","1cc8642c":"soil_cols = []\nother_cols = []\nfor x in train_data.columns:\n    if x.startswith('Soil'):\n        soil_cols.append(x)\n    else:\n        other_cols.append(x)\n","6f7b3e8e":"train_data.head()","ec619dfc":"train_descriptives = train_data.describe()\nprint(train_descriptives.filter(items = other_cols))","5ffe090c":"#Missingness check \nprint('It is {:s} that there are missing data.'.format(\n    str(any(train_descriptives.loc['count'] != train_descriptives.loc['count'].Id))))","7f792144":"sns.distplot(train_data.Cover_Type, kde = False, rug = False)","fc91bb21":"#Are there any patches where there are multiple soil types?\nsoil_frame_train = train_data.filter(items = soil_cols)\nprint('It is {:s} that each patch has one and only one soil type.'.format(str(all(soil_frame_train.agg('sum', axis = 'columns') == 1))))","e135f793":"(soil_frame_train.agg('mean')).sort_values()","a4e8dce2":"pearsonr(train_data.Soil_Type32, train_data.Soil_Type33)","0b326461":"#Elevation histogram\nsns.distplot(train_data.Elevation, kde = False, rug = True)","fe8b90ab":"wilderness_category = (train_data.filter(like = \"Wildern\").apply(axis = 1, func = np.flatnonzero) )\nwilderness_category = (wilderness_category.astype('int32')).astype('category')\ntrain_data['wilderness_cat'] = wilderness_category","ef28f548":"sns.boxplot(data = train_data, x = \"wilderness_cat\", y = \"Elevation\", notch = True)","a1dc1d0a":"sns.swarmplot(data = train_data, x = \"wilderness_cat\", y = \"Elevation\")","2b4550d2":"#Aspect histogram\nsns.distplot(train_data.Aspect, kde = False, rug = False)","33b10fa1":"#Slope histogram\nsns.distplot(train_data.Slope  , kde = True, rug = False)","0fa13df2":"sns.pairplot(train_data.filter(items = ['Horizontal_Distance_To_Hydrology', 'Vertical_Distance_To_Hydrology', 'Horizontal_Distance_To_Roadways','Horizontal_Distance_To_Fire_Points', 'Elevation']))","cffc855a":"(train_data.filter(items = ['Horizontal_Distance_To_Hydrology', 'Vertical_Distance_To_Hydrology', 'Horizontal_Distance_To_Roadways','Horizontal_Distance_To_Fire_Points','Elevation'])).corr()","5a19c27b":"sns.pairplot(train_data.filter(items = ['Aspect', 'Slope', 'Hillshade_9am', 'Hillshade_Noon', 'Hillshade_3pm']))","1c3da23c":"(train_data.filter(items = ['Aspect', 'Slope', 'Hillshade_9am', 'Hillshade_Noon', 'Hillshade_3pm'])).corr()","a37d433d":"(train_data.filter(items = ['Aspect', 'Slope', 'Hillshade_9am', 'Hillshade_Noon', 'Hillshade_3pm'])).cov()","9ba85d77":"pca = KernelPCA(\n                n_components = 3)\nsolar_pca = pca.fit_transform(train_data.filter(items = ['Aspect', 'Slope', 'Hillshade_9am', 'Hillshade_Noon', 'Hillshade_3pm']))","55be8f07":"pca.lambdas_","4f1fe912":"sns.pairplot(pd.DataFrame(solar_pca))","67de8453":"def crosstabber(soil_column):#\n    ## add try catch for \n    try:\n        return(np.ravel(pd.crosstab(train_data[soil_column], train_data.Cover_Type).iloc[1].astype('int')))\n    except: \n        return(np.zeros(7).astype('int'))","36e6fd91":"print(crosstabber(\"Soil_Type3\"))\n","ae3a0639":"soil_dictionary = {}\nfor stype in soil_cols:\n    soil_dictionary[stype] = crosstabber(stype)\n\nsoil_tabulation  = (pd.DataFrame(soil_dictionary)).T","3bf8ebae":"soil_tabulation","983672e7":"Each patch has one and only one soil type, so the multinomial distribution is appropriate here; this means that there's an intrinsic covariance between soil types. For example, soil type 32 has mean 0.045635 and soil type 33 has mean 0.040741, so they both have a variance of about $0.96 \\times 0.04 = 0.038$ and a covariance of approximately $-1 \\times\\left( 0.04\\right)^2 = -0.0016$ so they'll be correlated at roughly $-\\frac{0.04}{0.96}$, or about $-0.04$, which is highly statistically significant in this dataset, despite not telling us anything other than that a patch has only one soil type. ","133d00bd":"# New Features","08b951c3":"The distribution of cover types is relatively uniform, so we won't have to worry about bias due to class imbalance.","891cebe3":"The elevation histogram _looks_ trimodal; maybe the modes reflect the different wilderness areas.","e0ee3f00":"Because of the physical layout of each patch, there's correlation between their horizontal & vertical distances to hydrology, as well as their elevation. Distances to fire points seems independent of those things.","39a497b2":"The distribution of slopes has an odd peak at around 30 degrees.","a47d574a":"The distribution of aspects is bimodal with a trough at around 270 degrees.","a0d0024c":"Mapping this to the three modes of elevation is actually relatively straightforward, although wilderness areas 0 and 2 (here, which are Rawah and Comanche Peak, respectively) show substantial overlap in elevations.","63b9069f":"The relationships among aspect, slope, and different measures of hillshade have some kind of nonlinear constraints that cause them to be related. Correlation coefficients are able to account for some of these relationships. Kernel PCA might achieve some dimension reduction here."}}