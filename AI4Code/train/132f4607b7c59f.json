{"cell_type":{"a8ed111a":"code","45ae5838":"code","b4158a9a":"code","f84313a8":"code","b0acee81":"markdown","dc88ead7":"markdown","05049125":"markdown","d047a4cf":"markdown","f1ab0c2a":"markdown"},"source":{"a8ed111a":"def read_codons():\n    f = open('..\/input\/codons\/codons.txt', 'r') # Imports the relevant file in read mode using 'r'\n    raw_data = f.read()                         # Reads the file as a string, and saves the whole thing as a string\n    lines = raw_data.split('\\n')                # Makes a list of lines divided by \\n\n\n    # this is the same as the fruits code from class\n    codons = {}\n    for line in lines:\n        columns = line.split()\n        codons[columns[0]] = columns[1]\n    return codons\n        \ndef mrna_to_protein(mrna_in):\n    protein_out = \"\"                # make a string to add on to\n    num_codons = len(mrna_in)\/\/3    # there are 3 bases per codon, so I'm taking the length of my string divided by 3 and rounding down to get the number to look for\n    for i in range(num_codons): \n        codon_start = 3*i                            # Each codon is spaced 3 characters apart\n        codon_end   = codon_start + 3                # Each codon is 3 bases long, so it ends at start + e\n        this_codon  = mrna_in[codon_start:codon_end] # Get the 3-character substring from the input\n        new_AA      = codons[this_codon]             # Look up the codon in our dictionary\n        if new_AA == 'Stop':                         # Don't append the word \"Stop\" to the end\n            break\n        protein_out += new_AA                        # Add the new amino acid to our protein string\n    return protein_out\n\ndef dna_to_mrna(dna_in):\n    return dna_in.replace(\"T\",\"U\") # From the previous problems\n\ndef dna_to_protein(dna_in):\n    mrna = dna_to_mrna(dna_in)     # Convert DNA into RNA\n    return mrna_to_protein(mrna)   # Run mrna_to_protein on the converted string and return the result\n\n\ncodons=read_codons()\ndna_to_protein(\"AATCTCTACGGAAGTAGGTCAGTACTGATCGATCAGTCGATCGGGCGGCGATTTCGATCTGATTGTACGGCGGGCTAG\")","45ae5838":"def read_fasta(file_in):\n    f = open(file_in, 'r')      # Imports the relevant file in read mode using 'r'\n    raw_data = f.read()         # Reads the file as a string, and saves the whole thing as a string\n    lines = raw_data.split('>') # Makes a list of lines divided by >\n    \n    d = {}                      # An empty dictionary to feed results into\n    for line in lines[1:]:      # Loop through every entry. Because it starts with >, we can skip the first empty entry in lines\n        name,seq = line.split('\\n',1) # Use split to pull off the first entry before a \\n as name, and the rest as seq\n        seq = seq.replace('\\n','')    # Get rid of all the rest of the \\n characters\n        d[name]=seq             # save the name-->seq pair\n    return d\n\ndnas = read_fasta('..\/input\/codons\/PS2Q2.fasta')\n\nfor dna_key in dnas:\n    print(dna_key+\": \"+dna_to_protein(dnas[dna_key]))","b4158a9a":"# The following code builds 4 lists which track the numbers of each base. It then takes the highest value among the 4 lists to be the 'consensus' base for that position\n# Make print statements in this cell or in a new cell below to explore what's in each variable.\n\ndnas = read_fasta('..\/input\/codons\/PS2Q3.fasta')\nseq_list = list(dnas.values())  # Got this by Googling how to get values from a dict\n\n# make empty lists to count each base\na_list=[]\nt_list=[]\nc_list=[]\ng_list=[]\n\nseq_length = len(seq_list[0]) # Not strictly necessary, but makes the code a bit easier to read\n\n# fill each list with as many zeroes as there are bases in the sequence\n# By the end of the loop each list is [0,0,0,0...0,0]\nfor base_index in range(seq_length):\n    a_list.append(0)\n    t_list.append(0)\n    c_list.append(0)\n    g_list.append(0)\n\n# go through each sequence and add tally A,T,C,G in each position\nfor seq in seq_list:\n    for base_index in range(seq_length):\n        if seq[base_index] is 'A':\n            a_list[base_index] += 1    # Remember that += 1 means add one to the value.\n        if seq[base_index] is 'T':\n            t_list[base_index] += 1\n        if seq[base_index] is 'C':\n            c_list[base_index] += 1\n        if seq[base_index] is 'G':\n            g_list[base_index] += 1\n\n# make the consensus sequence\nconsensus=\"\"\nfor base_index in range(seq_length):\n    comparison_group = [a_list[base_index],t_list[base_index],c_list[base_index],g_list[base_index]] # get the values at this index for all 4 lists\n    maxVal = max(comparison_group) # find the most common base\n    d={0:'A',1:'T',2:'C',3:'G'}    # define a dictionary to correlate position in comparison_group with a base name. This is probably awful, but it works\n    consensus += d[comparison_group.index(maxVal)] # Add the base whose index is the maximum among the comparison group\n    \nprint(consensus)","f84313a8":"dnas = read_fasta('..\/input\/codons\/PS2Q4.fasta')\n\ndef longest_common_sequence(dna_dict):\n    seq_list = list(dnas.values()) # Same as above. Get just the DNA sequences\n\n    # Take the first sequence and divide it into all possible substrings  \n    search_list = []               # this list will hold all combinations of bases that appear in the first sequence\n    seq_len     = len(seq_list[1]) # length of the sequences\n    first_seq   = seq_list[1]      # easier to read version of first sequence name\n    \n    for subset_length in range(1,seq_len+1):       # Start at 1-base strings and grow to size of whole sequence\n        for pos in range(0,seq_len,subset_length): # Move the start of the subset by increasingly large steps\n            search_list.append(first_seq[pos:pos+subset_length]) # Add the string to the search list\n    \n    # I wanted to search from big to small so I sorted my search list\n    # found through Google: https:\/\/stackoverflow.com\/questions\/2587402\/sorting-python-list-based-on-the-length-of-the-string\n    search_list.sort(key=len) \n    \n    for search_seq in search_list[::-1]: # Go through, starting with the biggest substring\n        found_longest = True             # Just like the prime finder, assume you found it, then look for counterexamples\n        for seq in seq_list:             # Loop through each of the other sequences\n            if search_seq not in seq:    # If the search sequence isn't in the other sequences, then it isn't common, so mark false and break this loop\n                found_longest = False\n                break\n        if found_longest:                # If we make it to this point with found_longest still true, then we've found our winner\n            return(search_seq)\n\nlongest_common_sequence(dnas)","b0acee81":"## Question 1\nWhen the mRNA is translated to a protein sequence, each set of three nucleotides, called a **codon**, is translated into a single amino acid. For example, the codon ``UUC`` translates to the amino acid *Phenylalanine*. Each amino acid can be represented by a single letter - for example Phenylalanine is represented by the letter ``F``. A protein, which is formed from a sequence of amino acids, can therefore be written as a sequence of letters in the same way as DNA or mRNA, but using more of the letters of the alphabet since there are more than four amino acids.\n\nThe [..\/input\/codons\/codons.txt](..\/input\/codons\/codons.txt) file contains two columns. The first column gives a list of codons, and the second column gives the corresponding amino acid (represented by a single letter). Certain codons do not correspond to an amino acid, but instead indicate that the amino acid sequence is finished. These are indicated by ``Stop``.\n\nWrite a function ``mrna_to_protein`` that takes an mRNA sequence (as a string) and returns the sequence of amino acids (as a string), stopping the first time a ``Stop`` codon is encountered. Make sure that the file is only read once when running the script (and not every time you want to translate a codon). You will likely need to use a Python dictionary to help.\n\nFinally, write a function ``dna_to_protein`` that takes a DNA sequence (as a string) and returns the sequence of amino acids (as a string), making use of the functions that you wrote previously.\n\nPrint out the amino acid sequence for the following DNA sequence:\n\n    AATCTCTACGGAAGTAGGTCAGTACTGATCGATCAGTCGATCGGGCGGCGATTTCGATCTGATTGTACGGCGGGCTAG\n    ","dc88ead7":"# Chem 291\n## Python practice problems 2\n\nComplete the following questions, using any resources you like (including each other). Questions 3 and 4 are a bit tricky, so don't feel like you need to finish them. Work through as much as you can, and let me know how it goes. When you're done, download the completed code using File --> Download, and upload the .ipynb file to Moodle.\n\nQuestions modified from [Python 4 Scientists](https:\/\/astrofrog.github.io\/py4sci\/)","05049125":"## Question 4\nIn some cases, it is useful to be able to identify the longest common sub-sequence between two sequences. For example, in the sequences ``ACTGCT`` and ``TGCCCT``, the longest common sub-sequence is ``TGC`` (AC**TGC**T and **TGC**CCT). Note that these do not have to be at the same positon in each sequence.\n\nWrite a function, ``longest_common_sequence``, that takes a dictionary of sequences (such as the one returned by ``read_fasta``) and returns the longest common sub-sequence found in all the sequences.\n\nRead the [..\/input\/codons\/PS2Q4.fasta](..\/input\/codons\/PS2Q4.fasta) file, and print out the longest common sequence between all the sequences.","d047a4cf":"## Question 2\nUp to now, we have been specifying the DNA sequence by hand, but DNA sequences are usually long and are stored in files. A common file format is the FASTA format which looks similar to this:\n\n    >label1\n    ACTGTATCGATGCTAGCTACGTAGCTAGCTAGCTAGCTGACGTA\n    ACGATGTGCGAGGGTCATGGGACGCGAGCGAGTCTAGCACGATC\n    >label2\n    ACTGGGCTTGACTACGGCGGTATCTGACGGGCGAGCTGTACGAG\n    ACGGACTAGGGCGCGGCGGGGCGGATTTTCGAGTCGAGCGTTAT\n\nThe first line starts with a > which is immediately followed by a label (which might be the name of the gene for example). The sequence then starts on the second line, and may continue on several lines. It is common to limit the length of each line to 80, but this may vary from file to file. The sequence stops once either the file ends, or a line starts with >, which indicates that a new sequence is being given. There may be any number of sequences in a file.\n\nWrite a function `read_fasta`, that takes the name of a file (as a string) and returns a Python dictionary containing all the sequences from the file, with the keys in the dictionary corresponding to the label. If a sequence is given over several lines, you should remove any line returns and spaces. You should then be able to access the DNA for label1 with d['label1'] for example (if d is the name of the dictionary).\n\nUse this function and the functions you have written above to read in the ..\/input\/codons\/PS2Q2.fasta file and print out, for each sequence, the label, followed by the amino acid sequence (not the DNA sequence!).\n","f1ab0c2a":"## Question 3\nGiven several sequences with the same length, but which may include point mutations (i.e. individual nucleotides are changed), we want to try and find the most likely original sequence. For example, if we have the following sequences:\n\n    sequence 1: A C T C T\n    sequence 2: A C T C G\n    sequence 3: G C C C T\n    sequence 2: A C T C T\n    sequence 4: A T G C T\n    \nwe can go through each position and find the most common nucleotide. To do this, we can first construct a matrix that looks like:\n    \n             A: 4 0 0 0 0\n             C: 0 4 1 5 0\n             G: 1 0 1 0 1\n             T: 0 1 3 0 4\n             \nwhich indicates how many nucleotides of each type are found at each position, and from this we can see that the most common first base is A, the most common second base is C, and so on. The most common sequence is then ``ACTCT``. This is the [**consensus sequence**](http:\/\/en.wikipedia.org\/wiki\/Consensus_sequence).\n\nWrite a function ``consensus_sequence`` that takes a dictionary of sequences (such as the one returned by ``read_fasta``), and computes then returns the consensus sequence. Read the [..\/input\/codons\/PS2Q3.fasta](..\/input\/codons\/PS2Q3.fasta) file using the function you wrote previsouly, and print out the corresponding consensus sequence. All the sequences in this file are the same length."}}