{"cell_type":{"ac555232":"code","5e490a66":"code","a4bae609":"code","e14f2682":"code","2059cd76":"code","85a90539":"code","70af689b":"code","109f2f13":"code","2db8220f":"code","11589351":"code","788ee69e":"code","ca9b0517":"code","0767613a":"code","40534966":"code","8e8ebc4d":"code","8acc34d5":"code","5445b65e":"code","b1157a92":"code","baffa3fc":"code","6973594b":"code","406a9913":"code","334022e9":"code","60bf87b0":"code","6c4d45bf":"code","9b299d98":"code","54646cb1":"code","2b04f3d5":"code","38f6aeae":"code","e8828352":"code","0ac3a112":"code","7dfefe74":"code","74a24d2c":"code","33b4b4bc":"code","129fa117":"code","2250096f":"code","a7e209a1":"code","fefa9013":"code","dd580427":"code","edb52800":"code","8cc2ae8e":"code","59032418":"code","3ce4ec55":"code","7d61dc8f":"code","3e803c2f":"code","c4e2830a":"code","43958bb1":"code","5a28ed23":"code","c89900ff":"code","3ad91427":"code","181f8733":"code","f8caa4a0":"code","fadbe704":"code","4682a5ab":"code","d5249293":"code","a2bfac9c":"code","64ee8b68":"markdown","82ff8c56":"markdown","f9890cc3":"markdown","ca828c99":"markdown","329fe5a1":"markdown","e9dc72a1":"markdown","e335b1e5":"markdown","866102b6":"markdown","97a2f094":"markdown","014762ba":"markdown","926e85f2":"markdown","12f8afc8":"markdown","89dba4b3":"markdown","e6a20b46":"markdown","348d6697":"markdown","b01c5deb":"markdown","5eed4f82":"markdown","7f33036e":"markdown","dcf2945a":"markdown","da7a0213":"markdown","69543634":"markdown","0d7d39f0":"markdown","d865b17f":"markdown","a4955ccf":"markdown","8139bdb0":"markdown","f8830eb9":"markdown","307654b4":"markdown","e4bd2ee2":"markdown","a7f00058":"markdown","c0f2d363":"markdown","647ed5b2":"markdown","4ac844b1":"markdown","cdfeea1b":"markdown","12cbbd21":"markdown","d07e2a04":"markdown","b7e374e5":"markdown","3d614baa":"markdown"},"source":{"ac555232":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport glob\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport json\n\nfrom dataclasses import dataclass\nimport scipy.signal as signal\n\nfrom PIL import Image, ImageOps\nfrom skimage import io\nfrom skimage.color import rgba2rgb, rgb2xyz\nfrom tqdm import tqdm\nfrom dataclasses import dataclass\nfrom math import floor, ceil\nimport cv2\n\nimport warnings\nwarnings.filterwarnings('ignore')","5e490a66":"f = open(\"..\/input\/indoor-location-navigation\/test\/00ff0c9a71cc37a2ebdd0f05.txt\", \"r\")\nprint(\"Dataframe Info:\\n\")\nfor line in range(10):\n    print(f.readline())","a4bae609":"print(\"Dataframe head in txt form:\\n\")\nfor line in range(5):\n    print(f.readline())","e14f2682":"ss = pd.read_csv(\"..\/input\/indoor-location-navigation\/sample_submission.csv\")\nss.head()","2059cd76":"spt = ss.site_path_timestamp.values\nspliter = lambda id_spt: id_spt.split('_')\nspt = np.array([spliter(id_spt) for id_spt in spt])\nspt = pd.DataFrame(spt, columns=[\"Site\", \"Path\", \"Timestamp\"])\nspt.head()","85a90539":"test_sites = spt[\"Site\"].unique()\nlen_sites = len(test_sites)\nprint(f\"There are {len_sites} sites in the test(submission) file:\") \nprint(test_sites)\nprint()\n\ntest_paths = spt[\"Path\"].unique()\nlen_paths = len(test_paths)\nprint(f\"There are {len_paths} paths in the test(submission) file\") ","70af689b":"spt['Datetime'] = pd.to_datetime(spt['Timestamp'].astype('int64'), unit='ms')\nspt['Datetime'] = spt['Datetime'].apply( lambda d : d.time() ) \nspt.head(10)","109f2f13":"FLOOR_MAP = {\"B2\": -2, \n             \"B1\": -1, \n             \"F1\": 0, \n             \"F2\": 1, \n             \"F3\": 2, \n             \"F4\": 3, \n             \"F5\": 4, \n             \"F6\": 5, \n             \"F7\": 6, \n             \"F8\": 7, \n             \"F9\": 8,\n             \"1F\": 0, \"2F\": 1, \"3F\": 2, \"4F\": 3, \"5F\": 4, \"6F\": 5, \"7F\": 6, \"8F\": 7, \"9F\": 8}","2db8220f":"!git clone --depth 1 https:\/\/github.com\/location-competition\/indoor-location-competition-20 indoor_location_competition_20","11589351":"from indoor_location_competition_20.io_f import read_data_file","788ee69e":"from indoor_location_competition_20.compute_f import split_ts_seq\nfrom indoor_location_competition_20.compute_f import correct_trajectory\nfrom indoor_location_competition_20.compute_f import correct_positions\nfrom indoor_location_competition_20.compute_f import init_parameters_filter\nfrom indoor_location_competition_20.compute_f import get_rotation_matrix_from_vector\nfrom indoor_location_competition_20.compute_f import get_orientation\nfrom indoor_location_competition_20.compute_f import compute_steps\nfrom indoor_location_competition_20.compute_f import compute_stride_length\nfrom indoor_location_competition_20.compute_f import compute_headings\nfrom indoor_location_competition_20.compute_f import compute_step_heading\nfrom indoor_location_competition_20.compute_f import compute_rel_positions\nfrom indoor_location_competition_20.compute_f import compute_step_positions","ca9b0517":"!cp -r ..\/input\/indoor-locationnavigation-2021\/indoor-location-competition-20-master\/indoor-location-competition-20-master\/* .\/\n\nfrom main import calibrate_magnetic_wifi_ibeacon_to_position\nfrom main import extract_magnetic_strength\nfrom main import extract_wifi_rssi\nfrom main import extract_ibeacon_rssi\nfrom main import extract_wifi_count","0767613a":"# GitHub functions\nfrom visualize_f import visualize_trajectory\nfrom visualize_f import visualize_heatmap","40534966":"#ex_building = \"5cd56b6fe2acfd2d33b5a386\"\n#ex_floor = \"F1\"\n#ex_path = \"5cf4f05d14ddfa0008131970\"\n\nex_building = \"5a0546857ecc773753327266\"\nex_floor = \"F4\"\nex_path = \"5d11dc28ffe23f0008604f67\"\n\nex_file_path = f\"..\/input\/indoor-location-navigation\/train\/{ex_building}\/{ex_floor}\/{ex_path}.txt\"\n\nex_file = open(ex_file_path, \"r\")\ncol_names = list()\nfor i in range(10):\n    ex_file.readline()\n    col_names.append(f\"col_{i}\")\nex_site = pd.read_csv(ex_file, names=col_names, delimiter='\\t')\nex_site.head()","8e8ebc4d":"ex_db = read_data_file(ex_file_path) #create a sample database\n\nprint(\"Structure and Shape: \")\nprint(\"acce: {}\".format(ex_db.acce.shape), \"\\n\" +\n      \"acacce_uncalice: {}\".format(ex_db.acce_uncali.shape), \"\\n\" +\n      \"ahrs: {}\".format(ex_db.ahrs.shape), \"\\n\" +\n      \"gyro: {}\".format(ex_db.gyro.shape), \"\\n\" +\n      \"gyro_uncali: {}\".format(ex_db.gyro_uncali.shape), \"\\n\" +\n      \"ibeacon: {}\".format(ex_db.ibeacon.shape), \"\\n\" +\n      \"magn: {}\".format(ex_db.magn.shape), \"\\n\" +\n      \"magn_uncali: {}\".format(ex_db.magn_uncali.shape), \"\\n\" +\n      \"waypoint: {}\".format(ex_db.waypoint.shape), \"\\n\" +\n      \"wifi: {}\".format(ex_db.wifi.shape))","8acc34d5":"ex_acce = pd.DataFrame(ex_db.acce, columns=['time','x','y','z'])\nex_gyro = pd.DataFrame(ex_db.gyro, columns=['time','x','y','z'])\nex_magn = pd.DataFrame(ex_db.magn, columns=['time','x','y','z'])\nex_ahrs = pd.DataFrame(ex_db.ahrs, columns=['time','x','y','z'])\n\nex_waypoints = pd.DataFrame(ex_db.waypoint, columns=['time','X','Y'])\n\nex_acce.head()","5445b65e":"def plot_sensor_info(df, name):    \n    cols = [\"x\", \"y\", \"z\"]\n    plt.subplots(3, 3, sharex='col', sharey='row', figsize=(16,10))\n    plt.suptitle(name, fontsize=22)\n    for i in range(3):\n        col=cols[i]\n        plt.subplot(3, 3, i+1)\n        sns.distplot(df[col], axlabel=col+\"_axis\")\n        \n        plt.subplot(3, 3, i+4)\n        sns.boxplot(df[col], color=\"#96bcfa\")\n        \n    plt.subplot(3, 1, 3)\n    plt.plot(df['z'], color='#69cf83', label='z_axis')\n    plt.plot(df['y'], color='#d6b258', label='y_axis')\n    plt.plot(df['x'], color='#96bcfa', label='x_axis')\n    plt.xlabel('Time')\n    plt.ylabel('Sensor Value')\n    plt.legend()\n    plt.show()","b1157a92":"plot_sensor_info(ex_acce, \"ACCE\")","baffa3fc":"plot_sensor_info(ex_gyro, \"GYRO\")","6973594b":"plot_sensor_info(ex_magn, \"MAGN\")","406a9913":"plot_sensor_info(ex_ahrs, \"AHRS\")","334022e9":"mwi = calibrate_magnetic_wifi_ibeacon_to_position([ex_file_path])","60bf87b0":"mwi_df = pd.DataFrame(mwi).T\nmwi_df.head()","6c4d45bf":"magnetic_strength = extract_magnetic_strength(mwi)","9b299d98":"magn_df = pd.DataFrame(magnetic_strength, index=[0]).T\nmagn_df.columns = [\"magn\"]\nmagn_df.head()","54646cb1":"wifi_rssi = extract_wifi_rssi(mwi)","2b04f3d5":"wifi_bssid = list(wifi_rssi.keys())\nwifi_rssi_df = pd.DataFrame(dict(wifi_rssi[wifi_bssid[0]])).T\nwifi_rssi_df.columns=[\"RSSI\", \"old_count\"]\nwifi_rssi_df.head()","38f6aeae":"wifi_counts = extract_wifi_count(mwi)","e8828352":"wifi_counts_df = pd.DataFrame(wifi_counts, index=[0]).T\nwifi_counts_df.columns = [\"count\"]\nwifi_counts_df.head()","0ac3a112":"ibeacon_rssi = extract_ibeacon_rssi(mwi)","7dfefe74":"iBeacon_ummid = list(ibeacon_rssi.keys())\niBeacon_rssi_df = pd.DataFrame(dict(ibeacon_rssi[iBeacon_ummid[0]])).T\niBeacon_rssi_df.columns=[\"RSSI\", \"old_count\"]\niBeacon_rssi_df.head()","74a24d2c":"def show_site_png(site):\n    '''This functions outputs the visualization of the .png images available\n    in the metadata.\n    sites: the code coresponding to 1 site (or building)'''\n    \n    base = '..\/input\/indoor-location-navigation'\n    site_path = f\"{base}\/metadata\/{site}\/*\/floor_image.png\"\n    floor_paths = glob.glob(site_path)\n    n = len(floor_paths)\n\n    # Create the custom number of rows & columns\n    ncols = [ceil(n \/ 3) if n > 4 else 4][0]\n    nrows = [ceil(n \/ ncols) if n > 4 else 1][0]\n\n    plt.figure(figsize=(20, 10))\n    plt.suptitle(f\"Site no. '{site}'\", fontsize=18)\n\n    # Plot image for each floor\n    for k, floor in enumerate(floor_paths):\n        plt.subplot(nrows, ncols, k+1)\n\n        image = Image.open(floor)\n\n        plt.imshow(image)\n        plt.axis(\"off\")\n        title = floor.split(\"\/\")[5]\n        plt.title(title, fontsize=15)\n        ","33b4b4bc":"#This site has a lot of floors so it is a good example\nshow_site_png(site='5cd56b64e2acfd2d33b592b3')","129fa117":"trajectory = ex_db.waypoint\ntrajectory = trajectory[:, 1:3]\n\nex_png_path = f\"..\/input\/indoor-location-navigation\/metadata\/{ex_building}\/{ex_floor}\/floor_image.png\"\nex_json_path = f\"..\/input\/indoor-location-navigation\/metadata\/{ex_building}\/{ex_floor}\/floor_info.json\"\n\nwith open(ex_json_path) as json_file:\n    json_data = json.load(json_file)\n    \nwidth_meter = json_data[\"map_info\"][\"width\"]\nheight_meter = json_data[\"map_info\"][\"height\"]\n\nvisualize_trajectory(trajectory = trajectory,\n                     floor_plan_filename = ex_png_path,\n                     width_meter=width_meter,\n                     height_meter=height_meter,\n                     title=\"Waypoint Path\",\n                     g_size=750,\n                     point_color='#76C1A0',\n                     start_color='#007B51',\n                     end_color='#9B0000')","2250096f":"heat_positions = np.array(list(magnetic_strength.keys()))\nheat_values = np.array(list(magnetic_strength.values()))\n\nvisualize_heatmap(heat_positions, \n                  heat_values, \n                  ex_png_path,\n                  width_meter, \n                  height_meter, \n                  colorbar_title='strength', \n                  title='Magnetic Strength',\n                  g_size=750,\n                  colorscale='temps')\n","a7e209a1":"heat_positions = np.array(list(wifi_counts.keys()))\nheat_values = np.array(list(wifi_counts.values()))\n# filter out positions that no wifi detected\nmask = heat_values != 0\nheat_positions = heat_positions[mask]\nheat_values = heat_values[mask]\n\n# The heatmap\nvisualize_heatmap(heat_positions, \n                  heat_values, \n                  ex_png_path, \n                  width_meter, \n                  height_meter, \n                  colorbar_title=' WiFi Counts', \n                  title=f'WiFi Count',\n                  g_size=755,\n                  colorscale='temps')\n","fefa9013":"print(f'This floor has {len(wifi_rssi.keys())} wifis.')\n\nwifi_bssid = list(wifi_rssi.keys())\ntarget_wifi = wifi_bssid[0]\nheat_positions = np.array(list(wifi_rssi[target_wifi].keys()))\nheat_values = np.array(list(wifi_rssi[target_wifi].values()))[:, 0]\n\n# The heatmap\nvisualize_heatmap(heat_positions, \n                  heat_values, \n                  ex_png_path, \n                  width_meter, \n                  height_meter, \n                  colorbar_title='dBm', \n                  title=f'WiFi RSSI ({target_wifi})',\n                  g_size=755,\n                  colorscale='temps')","dd580427":"print(f'This floor has {len(ibeacon_rssi.keys())} ibeacons.')\n\nibeacon_ummids = list(ibeacon_rssi.keys())\ntarget_ibeacon = ibeacon_ummids[0]\nheat_positions = np.array(list(ibeacon_rssi[target_ibeacon].keys()))\nheat_values = np.array(list(ibeacon_rssi[target_ibeacon].values()))[:, 0]\n\n# The heatmap\nvisualize_heatmap(heat_positions, \n                  heat_values, \n                  ex_png_path, \n                  width_meter, \n                  height_meter, \n                  colorbar_title='dBm', \n                  title=f'iBeacon RSSI ({target_ibeacon})',\n                  g_size=755,\n                  colorscale='temps')","edb52800":"sensor_df = pd.DataFrame()","8cc2ae8e":"step_timestamps, step_indexs, step_acce_max_mins = compute_steps(ex_db.acce)","59032418":"sensor_df = pd.DataFrame(step_acce_max_mins, index=step_indexs)\nsensor_df.columns = [\"timestamp\", \"acce_max\", \"acce_min\", \"acce_std\"]\nsensor_df.head()","3ce4ec55":"stride_lengths = compute_stride_length(step_acce_max_mins)","7d61dc8f":"sensor_df[\"stride_length\"] = stride_lengths[:, 1]\nsensor_df.head()","3e803c2f":"headings = compute_headings(ex_db.ahrs)","c4e2830a":"headings.shape","43958bb1":"step_headings = compute_step_heading(step_timestamps, headings)","5a28ed23":"sensor_df[\"step_heading\"] = step_headings[:, 1]\nsensor_df.head()","c89900ff":"rel_positions = compute_rel_positions(stride_lengths, step_headings)","3ad91427":"sensor_df[\"rel_pos_x\"] = rel_positions[:, 1]\nsensor_df[\"rel_pos_y\"] = rel_positions[:, 2]\nsensor_df.head()","181f8733":"step_positions = compute_step_positions(ex_db.acce, ex_db.ahrs, ex_db.waypoint)","f8caa4a0":"sensor_df[\"step_pos_x\"] = step_positions[:, 1]\nsensor_df[\"step_pos_y\"] = step_positions[:, 2]\nsensor_df.head()","fadbe704":"#Fix timestamp\ndef time_float_to_str(time):\n    return str(int(time))\n\nsensor_df[\"timestamp\"] = sensor_df[\"timestamp\"].apply(time_float_to_str)\nsensor_df","4682a5ab":"def plot_sensor_info(df, name='Computed Sensor Info'):\n    plt.subplots(6, 2, figsize=(18,24))\n    plt.suptitle(name, fontsize=22)\n    \n    plt.subplot(6, 1, 1)\n    plt.plot(df['acce_max'], color='#db5046', label='acce_max')\n    plt.plot(df['acce_min'], color='#96bcfa', label='acce_min')\n    plt.xlabel('Time')\n    plt.ylabel('Value')\n    plt.title('ACCE Max & Min Over Time')\n    plt.legend(loc='upper left')\n    \n    plt.subplot(6, 2, 3)\n    plt.title('ACCE Max Boxplot')\n    sns.boxplot(df['acce_min'], color=\"#db5046\").set(xlabel=None)\n    \n    plt.subplot(6, 2, 4)\n    plt.title('ACCE Min Boxplot')\n    sns.boxplot(df['acce_min'], color=\"#96bcfa\").set(xlabel=None)\n    \n    plt.subplot(6, 1, 3)\n    plt.plot(df['stride_length'], color='#69cf83')\n    plt.xlabel('Time')\n    plt.ylabel('Length')\n    plt.title('Stride Length Over Time')\n    \n    plt.subplot(6, 2 , 7)\n    sns.distplot(df['acce_std'], color='#eba834', axlabel='acce_std')\n    plt.title('acce_std')\n    \n    plt.subplot(6, 2, 8)\n    sns.distplot(df['step_heading'], color='#34c8ed', axlabel='step_heading')\n    plt.title('step_heading')\n    \n    plt.subplot(6, 1, 5)\n    plt.plot(df['rel_pos_x'], color='#96bcfa', label='rel_pos_x')\n    plt.plot(df['rel_pos_y'], color='#db5046', label='rel_pos_y')\n    plt.legend(loc='upper left')\n    plt.title('rel_pos')\n    \n    plt.subplot(6, 1, 6)\n    plt.plot(df['step_pos_x'], color='#96bcfa', label='step_pos_x')\n    plt.plot(df['step_pos_y'], color='#db5046', label='step_pos_y')\n    plt.legend(loc='upper left')\n    plt.title('step_pos')\n    \n    plt.show()","d5249293":"plot_sensor_info(sensor_df)","a2bfac9c":"sensor_df.describe()","64ee8b68":"# Data Reader with io_f.py\n\nLets start by just reading in the data. For this, we will use the read_data_file from the io_f script.","82ff8c56":"### WiFi","f9890cc3":"### Compute Steps\nTakes in acce_datas from io_f.py. Computes the step_acce max, min, and std.","ca828c99":"### Compute Step Positions\nTakes in acce_datas, ahrs_datas, and posi_datas from io_f.py. Computes step positions.","329fe5a1":"### Compute Stride Length\nTakes in step_acce_max_min from compute_steps. Computes stride length.","e9dc72a1":"Lets break this down and make it more understandable with the rest of the functions in main.py\n### Magnetic Strength","e335b1e5":"# Structure of the Data\n\nThe datasets are orginially in a txt file format.\n\nHere is the strucutre of the directory that includes all the original data:\n\n![image.png](attachment:image.png)","866102b6":"### Visualize Floors of a Building","97a2f094":"# Computing with compute_f.py","014762ba":"The floor map defined below can be used to convert between the train data floor labels and the numerical floor output you need in the test set.","926e85f2":"# Magnetic, WiFi, iBeacon (mwi) Dataset with main.py\nThe function below in the main function of the github can create a \ngreat dataset with magnetic, WiFi, and iBeacon data","12f8afc8":"# Importing GitHub Scripts\n\nBy using this magical line of code you now are able to import classes and method from the preprocessing scripts on the GitHub Repo for this competition.\nI also have the indoor-locationnavigation-2021 dataset which includes all the github scripts","89dba4b3":"### iBeacon","e6a20b46":"### Understanding The First Column: site_path_timestamp","348d6697":"### Visualize iBeacon","b01c5deb":"### Compute Headings and Compute Step Headings\nTakes in ahrs_datas from io_f.py. Computes headings.\n\nTakes in step_timestamps from compute_steps and headings from compute_headings. Computes step headings.","5eed4f82":"# Understanding the Submission File and Output\n\nHere I am going to explore the sample_submission.csv in depth. This should clear up any confusion about the output file.","7f33036e":"Example of an iBeacon ummid","dcf2945a":"### Visualize Waypoints","da7a0213":"### All Individual Imports","69543634":"# Final Thoughts","0d7d39f0":"### Taking a Look at a Text File","d865b17f":"I did not include the split_ts_seq, correct_trajectory or correct_positions although I may add these in the future. I actually indirectly used them by calling other functions which called them. I also did not include init_parameters_filter, get_rotation_matrix_from_vector, and get_orientation as I am still figuring out how to properly use them. If you have any advice on how to use these functions comment below.\n\nLet me know if I used any function incorrectly or if I could improve in any way. \n\nI hope you find this notebook helpful in understanding the GitHub functions and comment how you plan to use these functions. Good luck!","a4955ccf":"# Overview\nI have seen notebooks that use scattered gitHub functions throughout this competition. In this nootebook, I have decided to demostrate how to use almost all the provided functions. I also explain the basic structure before using the gitHub.  \n\nEvery function in the GitHub does 1 of 3 things: generates feature(s), adjusts information, or creates visualizations.\n\nThe functions are separated into 4 primary files: io_f.py which reads in the data, main.py which creates the mwi dataset, visualize_f.py which allows you to see the building and features on the building, and compute_f.py which has a series of computations for feature generation and postprocessing.\n\nHere is a [begginer EDA notebook](https:\/\/www.kaggle.com\/andradaolteanu\/indoor-navigation-complete-data-understanding\/notebook) and [postprocessing notebook](https:\/\/www.kaggle.com\/saitodevel01\/indoor-post-processing-by-cost-minimization) that are also great applications of the gitHub and I learned a lot from them.\n\n[This is a link to the gitHub](https:\/\/github.com\/location-competition\/indoor-location-competition-20\/tree\/75f05960cde0eb30ea62dd4dcc75cc0359cb9589)\n\nLeave a comment if you have any questions and upvote if this notebook helps you.","8139bdb0":"# Visualizing with Visualize_f.py","f8830eb9":"WiFi Couunts","307654b4":"I will be using these data frames throught this anaysis","e4bd2ee2":"### Visualize Magnetic Strength","a7f00058":"I like to use the main and visualize functions from the indoor-locationnavigation-2021 dataset (they are almost exactly the same as the gitHub)","c0f2d363":"### Compute Rel Positions\nTakes in stride_lengths from compute_stride_length and step_headings from compute_step_headings. Computes relative positions","647ed5b2":"Example of a BSSID WiFi Feature","4ac844b1":"If the timestamp look confusing to you, putting them into datetime form should clear up what it means. The test datasets do not have a date or month, so I will only display the time.","cdfeea1b":"This is a mess. So what can we do to read in the data in a clean and usable format? Well the competitions io_f.py script contains functions effective at reading in the data.","12cbbd21":"### Examining our Computed Values","d07e2a04":"### Visualize WiFi","b7e374e5":"### Floors","3d614baa":"The site is the building id. The path is the id of a single walk that a person took. The timestamp is the time."}}