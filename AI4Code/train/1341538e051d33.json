{"cell_type":{"5d043445":"code","eb585820":"code","560cd4e4":"code","efd5581a":"code","2d93f541":"code","8cb70687":"code","11db8c87":"code","322cf356":"code","59e7fef5":"code","5ba9f15b":"code","753de4d9":"code","3224c182":"markdown","deeb3aef":"markdown","a45c0811":"markdown","bc54aed1":"markdown"},"source":{"5d043445":"import warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport numpy as np\nimport pandas as pd ","eb585820":"train = pd.read_csv('..\/input\/tabular-playground-series-apr-2021\/train.csv')\ntrain.head()","560cd4e4":"train['Age'].fillna(train['Age'].mean(), inplace = True)\ntrain['Fare'].fillna(train['Fare'].mean(), inplace = True)\ntrain['Embarked'].fillna(train['Embarked'].mode()[0], inplace = True)","efd5581a":"train.describe()","2d93f541":"train.dtypes","8cb70687":"train.drop(['Name','Ticket','Cabin','PassengerId'], axis = 1, inplace = True)","11db8c87":"discrete_cols = [c for c in train.columns.values if train[c].dtype in ['object', 'int64']]\nprint(discrete_cols)","322cf356":"import torch\nfrom torch import optim\nfrom torch.nn import functional\nfrom torch.nn import BatchNorm1d, Dropout, LeakyReLU, Linear, Module, ReLU, Sequential\nfrom sklearn.exceptions import ConvergenceWarning\nfrom sklearn.mixture import BayesianGaussianMixture\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.utils._testing import ignore_warnings\n\nclass ConditionalGenerator(object):\n    def __init__(self, data, output_info, log_frequency):\n        self.model = []\n\n        start = 0\n        skip = False\n        max_interval = 0\n        counter = 0\n        for item in output_info:\n            if item[1] == 'tanh':\n                start += item[0]\n                skip = True\n                continue\n\n            elif item[1] == 'softmax':\n                if skip:\n                    skip = False\n                    start += item[0]\n                    continue\n\n                end = start + item[0]\n                max_interval = max(max_interval, end - start)\n                counter += 1\n                self.model.append(np.argmax(data[:, start:end], axis=-1))\n                start = end\n\n            else:\n                assert 0\n\n        assert start == data.shape[1]\n\n        self.interval = []\n        self.n_col = 0\n        self.n_opt = 0\n        skip = False\n        start = 0\n        self.p = np.zeros((counter, max_interval))\n        for item in output_info:\n            if item[1] == 'tanh':\n                skip = True\n                start += item[0]\n                continue\n            elif item[1] == 'softmax':\n                if skip:\n                    start += item[0]\n                    skip = False\n                    continue\n                end = start + item[0]\n                tmp = np.sum(data[:, start:end], axis=0)\n                if log_frequency:\n                    tmp = np.log(tmp + 1)\n                tmp = tmp \/ np.sum(tmp)\n                self.p[self.n_col, :item[0]] = tmp\n                self.interval.append((self.n_opt, item[0]))\n                self.n_opt += item[0]\n                self.n_col += 1\n                start = end\n            else:\n                assert 0\n\n        self.interval = np.asarray(self.interval)\n\n    def random_choice_prob_index(self, idx):\n        a = self.p[idx]\n        r = np.expand_dims(np.random.rand(a.shape[0]), axis=1)\n        return (a.cumsum(axis=1) > r).argmax(axis=1)\n\n    def sample(self, batch):\n        if self.n_col == 0:\n            return None\n\n        batch = batch\n        idx = np.random.choice(np.arange(self.n_col), batch)\n\n        vec1 = np.zeros((batch, self.n_opt), dtype='float32')\n        mask1 = np.zeros((batch, self.n_col), dtype='float32')\n        mask1[np.arange(batch), idx] = 1\n        opt1prime = self.random_choice_prob_index(idx)\n        opt1 = self.interval[idx, 0] + opt1prime\n        vec1[np.arange(batch), opt1] = 1\n\n        return vec1, mask1, idx, opt1prime\n\n    def sample_zero(self, batch):\n        if self.n_col == 0:\n            return None\n\n        vec = np.zeros((batch, self.n_opt), dtype='float32')\n        idx = np.random.choice(np.arange(self.n_col), batch)\n        for i in range(batch):\n            col = idx[i]\n            pick = int(np.random.choice(self.model[col]))\n            vec[i, pick + self.interval[col, 0]] = 1\n\n        return vec\n\nclass Discriminator(Module):\n\n    def calc_gradient_penalty(self, real_data, fake_data, device='cpu', pac=10, lambda_=10):\n\n        alpha = torch.rand(real_data.size(0) \/\/ pac, 1, 1, device=device)\n        alpha = alpha.repeat(1, pac, real_data.size(1))\n        alpha = alpha.view(-1, real_data.size(1))\n\n        interpolates = alpha * real_data + ((1 - alpha) * fake_data)\n\n        disc_interpolates = self(interpolates)\n\n        gradients = torch.autograd.grad(\n            outputs=disc_interpolates, inputs=interpolates,\n            grad_outputs=torch.ones(disc_interpolates.size(), device=device),\n            create_graph=True, retain_graph=True, only_inputs=True\n        )[0]\n\n        gradient_penalty = ((\n            gradients.view(-1, pac * real_data.size(1)).norm(2, dim=1) - 1\n        ) ** 2).mean() * lambda_\n\n        return gradient_penalty\n\n    def __init__(self, input_dim, dis_dims, pack=10):\n        super(Discriminator, self).__init__()\n        dim = input_dim * pack\n        self.pack = pack\n        self.packdim = dim\n        seq = []\n        for item in list(dis_dims):\n            seq += [Linear(dim, item), LeakyReLU(0.2), Dropout(0.5)]\n            dim = item\n\n        seq += [Linear(dim, 1)]\n        self.seq = Sequential(*seq)\n\n    def forward(self, input):\n        assert input.size()[0] % self.pack == 0\n        return self.seq(input.view(-1, self.packdim))\n\n\nclass Residual(Module):\n    def __init__(self, i, o):\n        super(Residual, self).__init__()\n        self.fc = Linear(i, o)\n        self.bn = BatchNorm1d(o)\n        self.relu = ReLU()\n\n    def forward(self, input):\n        out = self.fc(input)\n        out = self.bn(out)\n        out = self.relu(out)\n        return torch.cat([out, input], dim=1)\n\n\nclass Generator(Module):\n    def __init__(self, embedding_dim, gen_dims, data_dim):\n        super(Generator, self).__init__()\n        dim = embedding_dim\n        seq = []\n        for item in list(gen_dims):\n            seq += [Residual(dim, item)]\n            dim += item\n        seq.append(Linear(dim, data_dim))\n        self.seq = Sequential(*seq)\n\n    def forward(self, input):\n        data = self.seq(input)\n        return data\n\nclass Sampler(object):\n    \"\"\"docstring for Sampler.\"\"\"\n\n    def __init__(self, data, output_info):\n        super(Sampler, self).__init__()\n        self.data = data\n        self.model = []\n        self.n = len(data)\n\n        st = 0\n        skip = False\n        for item in output_info:\n            if item[1] == 'tanh':\n                st += item[0]\n                skip = True\n            elif item[1] == 'softmax':\n                if skip:\n                    skip = False\n                    st += item[0]\n                    continue\n\n                ed = st + item[0]\n                tmp = []\n                for j in range(item[0]):\n                    tmp.append(np.nonzero(data[:, st + j])[0])\n\n                self.model.append(tmp)\n                st = ed\n            else:\n                assert 0\n\n        assert st == data.shape[1]\n\n    def sample(self, n, col, opt):\n        if col is None:\n            idx = np.random.choice(np.arange(self.n), n)\n            return self.data[idx]\n\n        idx = []\n        for c, o in zip(col, opt):\n            idx.append(np.random.choice(self.model[c][o]))\n\n        return self.data[idx]\n\nclass DataTransformer(object):\n    \"\"\"Data Transformer.\n    Model continuous columns with a BayesianGMM and normalized to a scalar\n    [0, 1] and a vector.\n    Discrete columns are encoded using a scikit-learn OneHotEncoder.\n    Args:\n        n_cluster (int):\n            Number of modes.\n        epsilon (float):\n            Epsilon value.\n    \"\"\"\n\n    def __init__(self, n_clusters=10, epsilon=0.005):\n        self.n_clusters = n_clusters\n        self.epsilon = epsilon\n\n    @ignore_warnings(category=ConvergenceWarning)\n    def _fit_continuous(self, column, data):\n        gm = BayesianGaussianMixture(\n            self.n_clusters,\n            weight_concentration_prior_type='dirichlet_process',\n            weight_concentration_prior=0.001,\n            n_init=1\n        )\n        gm.fit(data)\n        components = gm.weights_ > self.epsilon\n        num_components = components.sum()\n\n        return {\n            'name': column,\n            'model': gm,\n            'components': components,\n            'output_info': [(1, 'tanh'), (num_components, 'softmax')],\n            'output_dimensions': 1 + num_components,\n        }\n\n    def _fit_discrete(self, column, data):\n        ohe = OneHotEncoder(sparse=False)\n        ohe.fit(data)\n        categories = len(ohe.categories_[0])\n\n        return {\n            'name': column,\n            'encoder': ohe,\n            'output_info': [(categories, 'softmax')],\n            'output_dimensions': categories\n        }\n\n    def fit(self, data, discrete_columns=tuple()):\n        self.output_info = []\n        self.output_dimensions = 0\n\n        if not isinstance(data, pd.DataFrame):\n            self.dataframe = False\n            data = pd.DataFrame(data)\n        else:\n            self.dataframe = True\n\n        self.meta = []\n        for column in data.columns:\n            column_data = data[[column]].values\n            if column in discrete_columns:\n                meta = self._fit_discrete(column, column_data)\n            else:\n                meta = self._fit_continuous(column, column_data)\n\n            self.output_info += meta['output_info']\n            self.output_dimensions += meta['output_dimensions']\n            self.meta.append(meta)\n\n    def _transform_continuous(self, column_meta, data):\n        components = column_meta['components']\n        model = column_meta['model']\n\n        means = model.means_.reshape((1, self.n_clusters))\n        stds = np.sqrt(model.covariances_).reshape((1, self.n_clusters))\n        features = (data - means) \/ (4 * stds)\n\n        probs = model.predict_proba(data)\n\n        n_opts = components.sum()\n        features = features[:, components]\n        probs = probs[:, components]\n\n        opt_sel = np.zeros(len(data), dtype='int')\n        for i in range(len(data)):\n            pp = probs[i] + 1e-6\n            pp = pp \/ pp.sum()\n            opt_sel[i] = np.random.choice(np.arange(n_opts), p=pp)\n\n        idx = np.arange((len(features)))\n        features = features[idx, opt_sel].reshape([-1, 1])\n        features = np.clip(features, -.99, .99)\n\n        probs_onehot = np.zeros_like(probs)\n        probs_onehot[np.arange(len(probs)), opt_sel] = 1\n        return [features, probs_onehot]\n\n    def _transform_discrete(self, column_meta, data):\n        encoder = column_meta['encoder']\n        return encoder.transform(data)\n\n    def transform(self, data):\n        if not isinstance(data, pd.DataFrame):\n            data = pd.DataFrame(data)\n\n        values = []\n        for meta in self.meta:\n            column_data = data[[meta['name']]].values\n            if 'model' in meta:\n                values += self._transform_continuous(meta, column_data)\n            else:\n                values.append(self._transform_discrete(meta, column_data))\n\n        return np.concatenate(values, axis=1).astype(float)\n\n    def _inverse_transform_continuous(self, meta, data, sigma):\n        model = meta['model']\n        components = meta['components']\n\n        u = data[:, 0]\n        v = data[:, 1:]\n\n        if sigma is not None:\n            u = np.random.normal(u, sigma)\n\n        u = np.clip(u, -1, 1)\n        v_t = np.ones((len(data), self.n_clusters)) * -100\n        v_t[:, components] = v\n        v = v_t\n        means = model.means_.reshape([-1])\n        stds = np.sqrt(model.covariances_).reshape([-1])\n        p_argmax = np.argmax(v, axis=1)\n        std_t = stds[p_argmax]\n        mean_t = means[p_argmax]\n        column = u * 4 * std_t + mean_t\n\n        return column\n\n    def _inverse_transform_discrete(self, meta, data):\n        encoder = meta['encoder']\n        return encoder.inverse_transform(data)\n\n    def inverse_transform(self, data, sigmas):\n        start = 0\n        output = []\n        column_names = []\n        for meta in self.meta:\n            dimensions = meta['output_dimensions']\n            columns_data = data[:, start:start + dimensions]\n\n            if 'model' in meta:\n                sigma = sigmas[start] if sigmas else None\n                inverted = self._inverse_transform_continuous(meta, columns_data, sigma)\n            else:\n                inverted = self._inverse_transform_discrete(meta, columns_data)\n\n            output.append(inverted)\n            column_names.append(meta['name'])\n            start += dimensions\n\n        output = np.column_stack(output)\n        if self.dataframe:\n            output = pd.DataFrame(output, columns=column_names)\n\n        return output\n\nclass CTGANSynthesizer(object):\n    \"\"\"Conditional Table GAN Synthesizer.\n    This is the core class of the CTGAN project, where the different components\n    are orchestrated together.\n    For more details about the process, please check the [Modeling Tabular data using\n    Conditional GAN](https:\/\/arxiv.org\/abs\/1907.00503) paper.\n    Args:\n        embedding_dim (int):\n            Size of the random sample passed to the Generator. Defaults to 128.\n        gen_dim (tuple or list of ints):\n            Size of the output samples for each one of the Residuals. A Residual Layer\n            will be created for each one of the values provided. Defaults to (256, 256).\n        dis_dim (tuple or list of ints):\n            Size of the output samples for each one of the Discriminator Layers. A Linear Layer\n            will be created for each one of the values provided. Defaults to (256, 256).\n        l2scale (float):\n            Wheight Decay for the Adam Optimizer. Defaults to 1e-6.\n        batch_size (int):\n            Number of data samples to process in each step.\n    \"\"\"\n\n    def __init__(self, embedding_dim=128, gen_dim=(256, 256), dis_dim=(256, 256),\n                 l2scale=1e-6, batch_size=500):\n\n        self.embedding_dim = embedding_dim\n        self.gen_dim = gen_dim\n        self.dis_dim = dis_dim\n\n        self.l2scale = l2scale\n        self.batch_size = batch_size\n        self.device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n        self.trained_epoches = 0\n\n    def _apply_activate(self, data):\n        data_t = []\n        st = 0\n        for item in self.transformer.output_info:\n            if item[1] == 'tanh':\n                ed = st + item[0]\n                data_t.append(torch.tanh(data[:, st:ed]))\n                st = ed\n            elif item[1] == 'softmax':\n                ed = st + item[0]\n                data_t.append(functional.gumbel_softmax(data[:, st:ed], tau=0.2))\n                st = ed\n            else:\n                assert 0\n\n        return torch.cat(data_t, dim=1)\n\n    def _cond_loss(self, data, c, m):\n        loss = []\n        st = 0\n        st_c = 0\n        skip = False\n        for item in self.transformer.output_info:\n            if item[1] == 'tanh':\n                st += item[0]\n                skip = True\n\n            elif item[1] == 'softmax':\n                if skip:\n                    skip = False\n                    st += item[0]\n                    continue\n\n                ed = st + item[0]\n                ed_c = st_c + item[0]\n                tmp = functional.cross_entropy(\n                    data[:, st:ed],\n                    torch.argmax(c[:, st_c:ed_c], dim=1),\n                    reduction='none'\n                )\n                loss.append(tmp)\n                st = ed\n                st_c = ed_c\n\n            else:\n                assert 0\n\n        loss = torch.stack(loss, dim=1)\n\n        return (loss * m).sum() \/ data.size()[0]\n\n    def fit(self, train_data, discrete_columns=tuple(), epochs=300, log_frequency=True):\n        \"\"\"Fit the CTGAN Synthesizer models to the training data.\n        Args:\n            train_data (numpy.ndarray or pandas.DataFrame):\n                Training Data. It must be a 2-dimensional numpy array or a\n                pandas.DataFrame.\n            discrete_columns (list-like):\n                List of discrete columns to be used to generate the Conditional\n                Vector. If ``train_data`` is a Numpy array, this list should\n                contain the integer indices of the columns. Otherwise, if it is\n                a ``pandas.DataFrame``, this list should contain the column names.\n            epochs (int):\n                Number of training epochs. Defaults to 300.\n            log_frequency (boolean):\n                Whether to use log frequency of categorical levels in conditional\n                sampling. Defaults to ``True``.\n        \"\"\"\n\n        if not hasattr(self, \"transformer\"):\n            self.transformer = DataTransformer()\n            self.transformer.fit(train_data, discrete_columns)\n        train_data = self.transformer.transform(train_data)\n\n        data_sampler = Sampler(train_data, self.transformer.output_info)\n\n        data_dim = self.transformer.output_dimensions\n\n        if not hasattr(self, \"cond_generator\"):\n            self.cond_generator = ConditionalGenerator(\n                train_data,\n                self.transformer.output_info,\n                log_frequency\n            )\n\n        if not hasattr(self, \"generator\"):\n            self.generator = Generator(\n                self.embedding_dim + self.cond_generator.n_opt,\n                self.gen_dim,\n                data_dim\n            ).to(self.device)\n\n        if not hasattr(self, \"discriminator\"):\n            self.discriminator = Discriminator(\n                data_dim + self.cond_generator.n_opt,\n                self.dis_dim\n            ).to(self.device)\n\n        if not hasattr(self, \"optimizerG\"):\n            self.optimizerG = optim.Adam(\n                self.generator.parameters(), lr=2e-4, betas=(0.5, 0.9),\n                weight_decay=self.l2scale\n            )\n\n        if not hasattr(self, \"optimizerD\"):\n            self.optimizerD = optim.Adam(\n                self.discriminator.parameters(), lr=2e-4, betas=(0.5, 0.9))\n\n        assert self.batch_size % 2 == 0\n        mean = torch.zeros(self.batch_size, self.embedding_dim, device=self.device)\n        std = mean + 1\n\n        steps_per_epoch = max(len(train_data) \/\/ self.batch_size, 1)\n        for i in range(epochs):\n            self.trained_epoches += 1\n            for id_ in range(steps_per_epoch):\n                fakez = torch.normal(mean=mean, std=std)\n\n                condvec = self.cond_generator.sample(self.batch_size)\n                if condvec is None:\n                    c1, m1, col, opt = None, None, None, None\n                    real = data_sampler.sample(self.batch_size, col, opt)\n                else:\n                    c1, m1, col, opt = condvec\n                    c1 = torch.from_numpy(c1).to(self.device)\n                    m1 = torch.from_numpy(m1).to(self.device)\n                    fakez = torch.cat([fakez, c1], dim=1)\n\n                    perm = np.arange(self.batch_size)\n                    np.random.shuffle(perm)\n                    real = data_sampler.sample(self.batch_size, col[perm], opt[perm])\n                    c2 = c1[perm]\n\n                fake = self.generator(fakez)\n                fakeact = self._apply_activate(fake)\n\n                real = torch.from_numpy(real.astype('float32')).to(self.device)\n\n                if c1 is not None:\n                    fake_cat = torch.cat([fakeact, c1], dim=1)\n                    real_cat = torch.cat([real, c2], dim=1)\n                else:\n                    real_cat = real\n                    fake_cat = fake\n\n                y_fake = self.discriminator(fake_cat)\n                y_real = self.discriminator(real_cat)\n\n                pen = self.discriminator.calc_gradient_penalty(\n                    real_cat, fake_cat, self.device)\n                loss_d = -(torch.mean(y_real) - torch.mean(y_fake))\n\n                self.optimizerD.zero_grad()\n                pen.backward(retain_graph=True)\n                loss_d.backward()\n                self.optimizerD.step()\n\n                fakez = torch.normal(mean=mean, std=std)\n                condvec = self.cond_generator.sample(self.batch_size)\n\n                if condvec is None:\n                    c1, m1, col, opt = None, None, None, None\n                else:\n                    c1, m1, col, opt = condvec\n                    c1 = torch.from_numpy(c1).to(self.device)\n                    m1 = torch.from_numpy(m1).to(self.device)\n                    fakez = torch.cat([fakez, c1], dim=1)\n\n                fake = self.generator(fakez)\n                fakeact = self._apply_activate(fake)\n\n                if c1 is not None:\n                    y_fake = self.discriminator(torch.cat([fakeact, c1], dim=1))\n                else:\n                    y_fake = self.discriminator(fakeact)\n\n                if condvec is None:\n                    cross_entropy = 0\n                else:\n                    cross_entropy = self._cond_loss(fake, c1, m1)\n\n                loss_g = -torch.mean(y_fake) + cross_entropy\n\n                self.optimizerG.zero_grad()\n                loss_g.backward()\n                self.optimizerG.step()\n\n            l_average = (loss_g.item() + loss_d.item()) \/ 2\n            print(\"Epoch %d, Loss G: %.4f, Loss D: %.4f, Loss A: %.4f\" %\n                  (self.trained_epoches, loss_g.detach().cpu(), loss_d.detach().cpu(), l_average),\n                  flush=True)\n\n    def sample(self, n, condition_column=None, condition_value=None):\n        \"\"\"Sample data similar to the training data.\n        Args:\n            n (int):\n                Number of rows to sample.\n        Returns:\n            numpy.ndarray or pandas.DataFrame\n        \"\"\"\n\n        if condition_column is not None and condition_value is not None:\n            condition_info = self.transformer.covert_column_name_value_to_id(\n                condition_column, condition_value)\n            global_condition_vec = self.cond_generator.generate_cond_from_condition_column_info(\n                condition_info, self.batch_size)\n        else:\n            global_condition_vec = None\n\n        steps = n \/\/ self.batch_size + 1\n        data = []\n        for i in range(steps):\n            mean = torch.zeros(self.batch_size, self.embedding_dim)\n            std = mean + 1\n            fakez = torch.normal(mean=mean, std=std).to(self.device)\n\n            if global_condition_vec is not None:\n                condvec = global_condition_vec.copy()\n            else:\n                condvec = self.cond_generator.sample_zero(self.batch_size)\n\n            if condvec is None:\n                pass\n            else:\n                c1 = condvec\n                c1 = torch.from_numpy(c1).to(self.device)\n                fakez = torch.cat([fakez, c1], dim=1)\n\n            fake = self.generator(fakez)\n            fakeact = self._apply_activate(fake)\n            data.append(fakeact.detach().cpu().numpy())\n\n        data = np.concatenate(data, axis=0)\n        data = data[:n]\n\n        return self.transformer.inverse_transform(data, None)\n\n    def save(self, path):\n        assert hasattr(self, \"generator\")\n        assert hasattr(self, \"discriminator\")\n        assert hasattr(self, \"transformer\")\n\n        # always save a cpu model.\n        device_bak = self.device\n        self.device = torch.device(\"cpu\")\n        self.generator.to(self.device)\n        self.discriminator.to(self.device)\n\n        torch.save(self, path)\n\n        self.device = device_bak\n        self.generator.to(self.device)\n        self.discriminator.to(self.device)\n\n    @classmethod\n    def load(cls, path):\n        model = torch.load(path)\n        model.device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n        model.generator.to(model.device)\n        model.discriminator.to(model.device)\n        return model","59e7fef5":"model = CTGANSynthesizer()\n\nmodel.fit(train, discrete_cols)","5ba9f15b":"from joblib import dump, load\n\ndump(model, 'ctgan_dump')\nmodel = load('ctgan_dump')","753de4d9":"samples = model.sample(10000)\nsamples.to_csv('ctgan_aug.csv', index = False)","3224c182":"# CTGAN","deeb3aef":"# Training","a45c0811":"# Save Model","bc54aed1":"# Data Augmentation"}}