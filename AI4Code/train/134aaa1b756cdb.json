{"cell_type":{"75279f6a":"code","28f4d1ad":"code","41fa8807":"code","bbbc671e":"code","6dd4a83b":"code","789ac72d":"code","e928eb72":"code","89801085":"code","561d7496":"code","fad3e403":"markdown","b755ee71":"markdown","77a280bf":"markdown","b6994332":"markdown","27772511":"markdown","07b66f66":"markdown","1fc2f350":"markdown"},"source":{"75279f6a":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nfrom sklearn.model_selection import train_test_split\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.autograd import Variable\n\nimport os\nprint(os.listdir(\"..\/input\"))","28f4d1ad":"%%time\ntrain = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')\n\nprint(train.shape, test.shape)","41fa8807":"y = train['target'].values\nX = train.drop(['ID_code', 'target'], axis=1).values\n\nX_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.33, random_state=42)","bbbc671e":"print(len(X_train), len(X_val))\nprint(len(y_train), len(y_val))","6dd4a83b":"#Seed\ntorch.manual_seed(1234)\n\n#hyperparameters\nhl = 10\nlr = 0.01\nnum_epoch = 100\n\n#Model\nclass Net(nn.Module):\n\n    def __init__(self):\n        super(Net, self).__init__()\n        self.fc1 = nn.Linear(200, 10)\n        self.fc2 = nn.Linear(10, 2)\n\n    def forward(self, x):\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        return x\nnet = Net()\n\n#choose optimizer and loss function\ncriterion = nn.CrossEntropyLoss()\noptimizer = torch.optim.SGD(net.parameters(), lr=lr)","789ac72d":"%%time\n#train\nfor epoch in range(num_epoch):\n    X = Variable(torch.Tensor(X_train).float())\n    Y = Variable(torch.Tensor(y_train).long())\n\n    #feedforward - backprop\n    optimizer.zero_grad()\n    out = net(X)\n    loss = criterion(out, Y)\n    loss.backward()\n    optimizer.step()\n\n    if (epoch) % 10 == 0:\n        print ('Epoch [%d\/%d] Loss: %.4f' \n                   %(epoch+1, num_epoch, loss.item()))","e928eb72":"%%time\n\n#Validation\nX = Variable(torch.Tensor(X_val).float())\nY = torch.Tensor(y_val).long()\nout = net(X)\n\n_, predicted = torch.max(out.data, 1)\n\n#get accuration\nprint('Accuracy of the network %d %%' % (100 * torch.sum(Y==predicted) \/ len(y_val)))","89801085":"%%time\n\n#Test\nX_test = test.drop(['ID_code'], axis=1).values\n\nX = Variable(torch.Tensor(X_test).float())\nout = net(X)\n\n_, predicted = torch.max(out.data, 1)","561d7496":"ID_code = test['ID_code']\ntarget = predicted.data.numpy()\n\nmy_submission = pd.DataFrame({'ID_code': ID_code, 'target': target})\nmy_submission.to_csv('submission.csv', index=False)\n\nmy_submission.head()","fad3e403":"Perform prediction on test dataset","b755ee71":"Validate the NN","77a280bf":"Train the NN","b6994332":"Read the training and test[](http:\/\/) datasets","27772511":"Output prediction to CSV","07b66f66":"Split the training dataset for training and validation","1fc2f350":"Construct a 2-Layer NN"}}