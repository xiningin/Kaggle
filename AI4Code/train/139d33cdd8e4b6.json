{"cell_type":{"d27a7bc7":"code","23cfbbae":"code","6f46e2fc":"code","ca5bf38a":"code","1e99d964":"code","5f1426f8":"code","fc365c8a":"code","2fd76578":"code","af207d1c":"code","f1784498":"code","fe67baff":"code","fc86438b":"code","abd6c3cf":"code","d6e2edc1":"code","66bf527a":"code","dddda6db":"code","ea50f6c6":"code","cfd5314f":"code","5123c9aa":"code","89729e3c":"code","b791bbef":"code","d57be9fd":"code","4b2e03eb":"code","02e83ac0":"code","850586b5":"code","2ad3e068":"code","0d4d0773":"code","9a6174d3":"code","be94e6e4":"markdown","f76e3bc9":"markdown","9f429d14":"markdown","05c34250":"markdown","b6f77a9d":"markdown","2210d72d":"markdown","d7d5ae0e":"markdown","1f2b0809":"markdown","78eb44ff":"markdown","bf5df75a":"markdown","2b5e3f0d":"markdown","94ad880c":"markdown","c9fb0d4a":"markdown","59391de1":"markdown","53679e37":"markdown","b6e4c067":"markdown","0af57ce4":"markdown","1eaeb043":"markdown","d117cb17":"markdown","f17448b8":"markdown","2ef834a6":"markdown","fca2e205":"markdown","608aba3d":"markdown","005fe687":"markdown","2b0f46fb":"markdown","f2ae2e09":"markdown","d869f878":"markdown","38e8f78c":"markdown","a162921b":"markdown"},"source":{"d27a7bc7":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nfrom IPython.display import display # Allows the use of display() for DataFrames\nfrom time import time\nimport matplotlib.pyplot as plt\nimport seaborn as sns # Plotting library\nimport keras\nfrom keras.preprocessing import image\nfrom keras.preprocessing.image import ImageDataGenerator, img_to_array\nfrom keras.utils import np_utils\nfrom sklearn.datasets import load_files   \nfrom tqdm import tqdm\nfrom collections import Counter\n\n\nprint(os.listdir(\"..\/input\"))","23cfbbae":"data_train_path = '..\/input\/skin-lesion-analysis-towards-melanoma-detection\/train\/train'\ndata_valid_path = '..\/input\/skin-lesion-analysis-towards-melanoma-detection\/valid\/valid'\ndata_test_path = '..\/input\/skin-lesion-analysis-towards-melanoma-detection\/test\/test'","6f46e2fc":"# define function to load train, test, and validation datasets\ndef load_data_raw (path):\n    data = load_files(path)\n    files = np.array(data['filenames'])\n    targets = np_utils.to_categorical(np.array(data['target']), 3)\n    \n    return files, targets\n\ntrain_filenames, train_targets = load_data_raw(data_train_path)","ca5bf38a":"filenames_trimmed = [filename.split('\/')[-2] for filename in train_filenames]\nclasses_count = Counter(filenames_trimmed)\n\n# Plot the classes\nplt.bar(classes_count.keys(), classes_count.values(), color=['blue', 'orange', 'green'])","1e99d964":"def plot_n_samples(filenames):\n    filenames_trimmed = [filename.split('\/')[-2] for filename in filenames]\n    classes_count = Counter(filenames_trimmed)\n\n    # Plot the classes\n    plt.bar(classes_count.keys(), classes_count.values(), color=['blue', 'orange', 'green'])","5f1426f8":"from sklearn.utils import resample, shuffle\n\n# Choose one of the 3 for the feature_name\nfeature_names = {0: 'melanoma', 1: 'nevus', 2: 'seborrheic_keratosis'}\n\ndef upsample(filenames, targets, feature_name, n_samples = 1372):\n    upsample_idx = []\n    \n\n    # Find all the indices for nevus\n    for i, path in enumerate(filenames):\n        # If feature matches, save the index\n        if feature_name in path.split('\/'):\n            upsample_idx.append(i)\n    \n    # Remove selected features from filenames to add the upsampled after\n    new_filenames = [filename for i, filename in enumerate(filenames) if i not in upsample_idx]\n    new_targets = [target for i, target in enumerate(targets) if i not in upsample_idx]\n\n    # Upsample\n    resampled_x, resampled_y = resample(filenames[upsample_idx], targets[upsample_idx], n_samples=n_samples, random_state=0)\n\n    # Add the upsampled features to new_filenames and new_targets\n    new_filenames += list(resampled_x)\n    new_targets += list(resampled_y) \n    \n    return np.array(new_filenames), np.array(new_targets)\n    \n# We upsample twice: once for each feature we want upsampled\nupsample_train_x, upsample_train_y = upsample(train_filenames, train_targets, feature_names[0])\nupsample_train_x, upsample_train_y = upsample(upsample_train_x, upsample_train_y, feature_names[2])\n\nplot_n_samples(upsample_train_x)","fc365c8a":"'''\n# Use only if not using the up-sampling function\ndef downsample(filenames, targets, n_samples = 370):\n    nevus_idx = []\n    \n    # Find all the indices for nevus\n    for i, path in enumerate(filenames):\n        # If nevus, save the index\n        if 'nevus' in path.split('\/'):\n            nevus_idx.append(i)\n    \n    nevus_idx = np.sort(shuffle(nevus_idx)[n_samples:]) # shuffle indices\n\n    # Downsample\n    new_filenames = [filename for i, filename in enumerate(filenames) if i not in nevus_idx]\n    new_targets = [target for i, target in enumerate(targets) if i not in nevus_idx]\n    \n    \n    return new_filenames, new_targets\n            \ndownsample_train_x, downsample_train_y = downsample(train_filenames, train_targets)\n\nplot_n_samples(downsample_train_x)\n'''","2fd76578":"from keras.preprocessing import image   \n\n# Convert the image paths to tensors Manually\ndef path_to_tensor(img_path):\n    # loads RGB image as PIL.Image.Image type\n    img = image.load_img(img_path, target_size=(224,224))\n    # convert PIL.Image.Image type to 3D tensor with shape (224, 224, 3)\n    x = image.img_to_array(img)\n    # convert 3D tensor to 4D tensor with shape (1, 224, 224, 3) and return 4D tensor\n    return np.expand_dims(x, axis=0)\n\ndef paths_to_tensor(img_paths):\n    list_of_tensors = [path_to_tensor(img_path) for img_path in tqdm(img_paths)]\n    return np.vstack(list_of_tensors)\n\n\ntrain_filenames = paths_to_tensor(upsample_train_x)\ntrain_targets = upsample_train_y","af207d1c":"batch_size=60\n\n# Transforms\ndatagen_train = ImageDataGenerator(\n    rescale=1.\/255,\n    rotation_range=40,\n    width_shift_range=0.1,  # randomly shift images horizontally \n    height_shift_range=0.1,  # randomly shift images vertically\n    horizontal_flip=True)\n\ndatagen_valid = ImageDataGenerator(\n    rescale=1.\/255,\n    rotation_range=40,\n    width_shift_range=0.1,  # randomly shift images horizontally\n    height_shift_range=0.1,  # randomly shift images vertically\n    horizontal_flip=True)\n\ndatagen_test = ImageDataGenerator(\n    rescale=1.\/255)","f1784498":"# Generators\n'''\ntrain_generator = datagen_train.flow_from_directory(\n        data_train_path,\n        target_size=(224, 224),\n        batch_size=batch_size,\n        class_mode='categorical')\n'''\n\ntrain_generator = datagen_train.flow(train_filenames, train_targets, batch_size=batch_size)\n\nvalid_generator = datagen_valid.flow_from_directory(\n        data_valid_path,\n        target_size=(224, 224),\n        batch_size=batch_size,\n        class_mode='categorical',\n        shuffle=False)\n\ntest_generator = datagen_test.flow_from_directory(\n        data_test_path,\n        target_size=(224, 224),\n        batch_size=1,\n        class_mode='categorical',\n        shuffle=False)","fe67baff":"num_train = len(train_filenames)\nnum_valid = len(valid_generator.filenames)\nnum_test = len(test_generator.filenames)\n\nprint(num_train, num_valid, num_test)","fc86438b":"# Class name to the index\n#class_2_indices = train_generator.class_indices\nclass_2_indices = {'melanoma': 0, 'nevus': 1, 'seborrheic_keratoses': 2}\nprint(\"Class to index:\", class_2_indices)\n\n# Reverse dict with the class index to the class name\nindices_2_class = {v: k for k, v in class_2_indices.items()}\nprint(\"Index to class:\", indices_2_class)","abd6c3cf":"# Lets have a look at some of our images\nimages, labels = train_generator.next()\n\nfig = plt.figure(figsize=(20,10))\nfig.subplots_adjust(wspace=0.2, hspace=0.4)\n\n# Lets show the first 32 images of a batch\nfor i, img in enumerate(images[:32]):\n    ax = fig.add_subplot(4, 8, i + 1, xticks=[], yticks=[])\n    ax.imshow(img)\n    image_idx = np.argmax(labels[i])\n    ax.set(title=indices_2_class[image_idx])","d6e2edc1":"from keras.models import Sequential\nfrom keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout, Activation, BatchNormalization, GlobalAveragePooling2D\nfrom keras.applications import ResNet50\nfrom keras.models import Model\nfrom keras_tqdm import TQDMNotebookCallback\n\nbase_model = ResNet50(weights='imagenet', include_top=False)\n\n# add a global spatial average pooling layer\nx = base_model.output\nx = GlobalAveragePooling2D()(x)\n# x = MaxAveragePooling2D()(x)\n# let's add a fully-connected layer\nx = Dense(1024, activation='elu')(x)\nx = Dropout(0.95)(x)\n# and a logistic layer\npredictions = Dense(3, activation='softmax')(x)\n\n# this is the model we will train\nmodel = Model(inputs=base_model.input, outputs=predictions)\n\n# first: train only the top layers (which were randomly initialized)\nfor layer in base_model.layers:\n    layer.trainable = True\n\n#model.summary()","66bf527a":"'''\nmodel = Sequential()\n\n### TODO: Define your architecture.\nmodel.add(Conv2D(filters=16, kernel_size=2, padding='same',\n                  input_shape=(224,224,3), kernel_initializer='he_normal'))\n\nmodel.add(Conv2D(32, (3,3)))\nmodel.add(MaxPooling2D(pool_size=2))\nmodel.add(Conv2D(64, (3,3)))\nmodel.add(Conv2D(128, (3,3)))\nmodel.add(MaxPooling2D(pool_size=2))\nmodel.add(Conv2D(256, (3,3)))\nmodel.add(MaxPooling2D(pool_size=2))\n\nmodel.add(Flatten())\nmodel.add(Dense(1000))\nmodel.add(Activation('elu'))\nmodel.add(BatchNormalization())\nmodel.add(Dropout(0.5))\nmodel.add(Dense(500))\nmodel.add(Activation('elu'))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(3))\nmodel.add(BatchNormalization())\nmodel.add(Activation('softmax'))\n\n          \nmodel.summary()\n'''","dddda6db":"from keras.optimizers import Adam\n\n# compile the model (should be done *after* setting layers to non-trainable)\nmodel.compile(optimizer=Adam(lr=0.0001), loss='categorical_crossentropy',\n             metrics=['accuracy'])","ea50f6c6":"from sklearn.utils import class_weight\n\n# Convert one hot encoded labels to ints\ntrain_targets_classes = [np.argmax(label) for label in train_targets]\n\n# Compute the weights\nclass_weights = class_weight.compute_class_weight('balanced',\n                                                  np.unique(train_targets_classes),\n                                                  train_targets_classes)\n\nclass_weights_dict = dict(enumerate(class_weights))\nprint(class_weights_dict)","cfd5314f":"from keras.callbacks import ModelCheckpoint, ReduceLROnPlateau, EarlyStopping\n\n# train the model\ncheckpointer = ModelCheckpoint(filepath='aug_model.weights.best.hdf5', verbose=1, \n                               save_best_only=True)\n\nscheduler = ReduceLROnPlateau(monitor='val_loss', factor=0.1,\n                              patience=5, min_lr=1e-8, verbose=1)\n\nearly_stopper = EarlyStopping(monitor='val_loss', patience=10,\n                              verbose=0, restore_best_weights=True)\n\nhistory = model.fit_generator(train_generator,\n                    class_weight= class_weights_dict,\n                    steps_per_epoch=num_train\/\/batch_size,\n                    epochs=40,\n                    verbose=0,\n                    callbacks=[checkpointer, scheduler, TQDMNotebookCallback(), early_stopper],\n                    validation_data=valid_generator,\n                    validation_steps=num_valid\/\/batch_size)","5123c9aa":"# load the weights that yielded the best validation accuracy\nmodel.load_weights('aug_model.weights.best.hdf5')","89729e3c":"score = model.evaluate_generator(test_generator, steps=num_test\/\/1, verbose=1)\nprint('\\n', 'Test accuracy:', score[1])","b791bbef":"predictions = model.predict_generator(test_generator, steps=num_test)\n\ntask_1 = pd.DataFrame(data=[desease[0] for desease in predictions])\ntask_2 = pd.DataFrame(data=[desease[2] for desease in predictions])","d57be9fd":"from sklearn.metrics import roc_auc_score, accuracy_score\n\nground_truth = pd.read_csv(\"..\/input\/udacitydermatologistai\/repository\/udacity-dermatologist-ai-2ec0ca9\/ground_truth.csv\")\nlabels = np_utils.to_categorical(np.array(test_generator.classes), 3)\n\nroc_auc_all = roc_auc_score(labels, predictions)\nroc_auc_task_1 = roc_auc_score(ground_truth['task_1'], task_1)\nroc_auc_task_2 = roc_auc_score(ground_truth['task_2'], task_2)\n\nprint('Roc auc score for all data is: {}'.format(roc_auc_all))\nprint('Roc auc score for task 1 is: {}'.format(roc_auc_task_1))\nprint('Roc auc score for task 2 is: {}'.format(roc_auc_task_2))","4b2e03eb":"test_filenames, test_targets = load_data_raw(data_test_path)","02e83ac0":"def plot_prediction(img_file, img_target):\n\n    img = image.load_img(img_file, target_size=(224,224))\n    img = image.img_to_array(img)\/255\n    img_expand = np.expand_dims(img, axis=0)\n    \n    # Make a prediction\n    prediction = model.predict(img_expand, steps=1)\n    image_idx = np.argmax(prediction[0])\n    prediction_string = indices_2_class[image_idx]\n    \n    # Get the real label's name\n    label_idx = np.argmax(img_target)\n    real_label = indices_2_class[label_idx]\n    \n    # Plot predictions\n    title = \"Prediction: {}\\nReal: {}\".format(prediction_string, real_label)\n    \n    plt.imshow(img)\n    plt.title(title)\n    \n    pred_df = pd.DataFrame({'Cancer type':['melanoma', 'nevus', 'seborrheic keratosis'], 'val':prediction[0]})\n    ax = pred_df.plot.barh(x='Cancer type', y='val', title=\"Predictions\", grid=True)\n    \nrandom_index = np.random.randint(0, len(test_generator.filenames))\nplot_prediction(test_filenames[random_index], test_targets[random_index])","850586b5":"plts, (ax1, ax2) = plt.subplots(1,2, figsize=(20,5))\n\n# summarize history for accuracy\nax1.plot(history.history['acc'])\nax1.plot(history.history['val_acc'])\nax1.set_title('model accuracy')\nax1.set(xlabel='epoch', ylabel='accuracy')\nax1.legend(['train', 'val'], loc='upper left')\n\nax2.plot(history.history['loss'])\nax2.plot(history.history['val_loss'])\nax2.set_title('model loss')\nax2.set(xlabel='epoch', ylabel='loss')\nax2.legend(['train', 'val'], loc='upper left')","2ad3e068":"# submission\nsubmission = pd.read_csv(\"..\/input\/udacitydermatologistai\/repository\/udacity-dermatologist-ai-2ec0ca9\/sample_predictions.csv\")\nsubmission['task_1'] = task_1\nsubmission['task_2'] = task_2\nsubmission.to_csv(\"submission_dermatologist.csv\", index=False)\ndisplay(submission.head())","0d4d0773":"from sklearn.metrics import confusion_matrix\n\n# Confusion matrix for all classes\ny_true = test_generator.classes\ny_pred = [np.argmax(x) for x in predictions]\n\nlabels = [\"melanoma\", \"nevus\", \"keratoses\"]\ncm = confusion_matrix(y_true, y_pred)\ncm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis] # Normalize confusion matrix\nax = sns.heatmap(cm, annot=True)\nax.xaxis.set_ticklabels(labels)\nax.yaxis.set_ticklabels(labels)","9a6174d3":"def plot_distribution(pred_target_y, filenames):\n    melanoma_idx = []\n      \n    # Find all the indices for nevus\n    for i, path in enumerate(filenames):\n        # If feature matches, save the index\n        if 'melanoma' in path.split('\/'):\n            melanoma_idx.append(i)\n            \n    bening_preds = [pred for i, pred in enumerate(pred_target_y) if i not in melanoma_idx]\n    malignant_preds = [pred for i, pred in enumerate(pred_target_y) if i in melanoma_idx]\n    \n    fig, ax = plt.subplots(1,1,figsize=(15,6))\n    \n    ax.set_title('Malignant vs. Bening')\n    sns.distplot(bening_preds, hist=True, kde=True, label=\"Benign\", bins=35)\n    sns.distplot(malignant_preds, hist=True, kde=True, label=\"Malignant\", bins=35, axlabel=\"Probability Malignant\")\n    ax.legend()\n    ax.xaxis.set_ticks(np.arange(0, 1.1, 0.1))\n\nplot_distribution(task_1.values, test_generator.filenames)","be94e6e4":"**Upsampling function for imbalanced data**\n\nUsing scikit learn's resample function I will create new samples of the under-represented data.","f76e3bc9":"# Detecting Melanoma with a Convolutional Neural Network\n\nIn this mini project, I will design an algorithm that can visually diagnose [melanoma](https:\/\/www.skincancer.org\/skin-cancer-information\/melanoma), the deadliest form of skin cancer. In particular, the algorithm will distinguish this malignant skin tumor from two types of benign lesions ([nevis](http:\/\/missinglink.ucsf.edu\/lm\/dermatologyglossary\/nevus.html)  and [seborrheic keratoses](https:\/\/www.aad.org\/public\/diseases\/bumps-and-growths\/seborrheic-keratoses)).","9f429d14":"**Train the model**","05c34250":"# 3.Train the model","b6f77a9d":"**Confusion Matrix**","2210d72d":"**Downsampling function for imbalanced data**","d7d5ae0e":"**RocAuc Score**","1f2b0809":"**Lets visualize some of our predictions**","78eb44ff":"**Insights**\n\nWe can see the a little the separation between malignant and bening lesions. This plot could be used to find the best threshold that maximizes the amount of people that have malignant lesions.\n* The model predicts that about 50% of the malignant lesions are bening (Really close to 0%)\n* The model predicts correctly 50% of the malignant lesions as malignant (as we can see in the confusion matrix)\n* In the event that we had to choose a threshold (this is dangerous because a lot of our malignant lesions are very near the 0), we could say that a \"good\" threshold is around 0.05, where it identifies a lot of malignant lesions (more than 50% at least) and leaves back most benign lesions (more than 90%)","bf5df75a":"Get the class indices\n\nTo get the label we find the index of the 1 in the one hot encoded vector which should match the index in a dictionary. Eg:\n* label = `[1,0,0]` ---> class_index = `0`\n* label = `[0,1,0]` ---> class_index = `1`\n* label = `[0,0,1]` ---> class_index = `2`","2b5e3f0d":"**Assign weights to imbalanced classes**\n\nThe dataset shows an imbalance. By assigning bigger weights to the misrepresented classes in the dataset we will help to correct this issue.","94ad880c":"# 4. Test model","c9fb0d4a":"Due to the nature of the problem, it is very important that we make no mistake when identifying a patient as _not sick_. We prefer to send someone who is not sick for more tests, rather than someone who is sick home. This is what we know as recall, and we want a value for recall as close to 1 as possible. To improve recall what we can do is set a lower threshold to idenfify someone as sick or not sick, therefore only the pateients with a really low probability of melanoma will be let go, any others with a higher predicted chance will be held for more tests.","59391de1":"# 2. Create the model","53679e37":"**Compile the model**","b6e4c067":"**Performance curves**","0af57ce4":"**Load the data**","1eaeb043":"**Predictions for the test data**\n\n* `task_1`: the model's predicted probability that the image depicts **melanoma**\n* `task_2`: the model's predicted probability that the image depicts **seborrheic keratosis**","d117cb17":"### Table of Contents\n\n1. Load Images and Data Augmentation\n2. Create Model\n3. Train Model\n4. Test Model\n5. Submission\n6. Conclussion","f17448b8":"# 6. Conclussion","2ef834a6":"![](https:\/\/d17h27t6h515a5.cloudfront.net\/topher\/2017\/November\/5a18789d_skin-disease-classes\/skin-disease-classes.png)","fca2e205":"**Define the model architecture**","608aba3d":"**Load the model with the best Validation Accuracy**","005fe687":"There are a lot more samples of nevus compared to the other two. This might cause the network to be biased. It will try to maximize the error function, and by classifying everything as nevus it will accomplish that.\n\nFor this problem we will need to be careful with the accuracy metric. I will try to balance the data in the model.","2b0f46fb":"# 5. Submission","f2ae2e09":"**Log**\n\n```\n> Used VGG19 pre-trained (frozen layers) with 2 fully connected layers and got no improvement over 50%.\n\n> Used InceptionV3 pre-trained (frozen layers) with 2 fully connected layers and got no improvement over 50%.\n\n> Used InceptionV3 pre-trained, (de-frosted layers lol) and with 3 fully connected layers and got no improvement over 50%.\n\n> Used ResNet50 ... same.\n\n> Changed Flatten layer to GlobalAveragePooling and it seems to perform better.\n\n> Added class_weights to help balance the classes.\n\n> Downsampled the data with the most occurrences (nevus). I am not getting everything predicted as nevus anymore, but I still get low ROC AUC scores (even below 0.5, which would actually kill people!!!).\n\n> ResNet50 with 1 hidden layer and 0.95 Dropout. Accuracy has improved slightly to ~ 0.65. RocAuc scores still bad.\n\n> Keras .flow's property shuffle was set to True by default. Changed it as it was the cause for getting such horrible ROC AUC scores. Now the Auc Scores look a lot better.\n\n> Tried oversampling by repeating some of the downsampled images. Results improved. Better results than performing undersampling.\n```","d869f878":"**Trying out a custom made model for debugging**","38e8f78c":"# 1. Load the data\n","a162921b":"**EDA**\n\nLets find out how many samples we have for each category."}}