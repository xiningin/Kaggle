{"cell_type":{"65efde8f":"code","3865df4a":"code","d3dde433":"code","c7713ab7":"code","66144a40":"code","c6d07088":"code","c8eaf161":"code","4cd7b317":"code","5d442a96":"code","67252c38":"code","3776b73d":"code","bf5657d8":"code","16bdb8d3":"markdown","ae6defa3":"markdown","2aa21d87":"markdown","7eaf3887":"markdown","cd0244f7":"markdown","63b9c8f0":"markdown","404d39ac":"markdown","2b811edb":"markdown","630ecda6":"markdown","9cb2502b":"markdown","b7bad0a3":"markdown","6c81ae14":"markdown"},"source":{"65efde8f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport cv2\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","3865df4a":"image = cv2.imread('\/kaggle\/input\/chinese-fine-art\/Dataset\/Liu_Yuan_Shou_\u5289\u5143\u58fd\/Liu_Yuanshou_01.jpeg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\nplt.figure(figsize=(20, 20))\nplt.subplot(1, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\n\n# Create our shapening kernel, we don't normalize since the \n# the values in the matrix sum to 1\nkernel_sharpening = np.array([[-1,-1,-1], \n                              [-1,9,-1], \n                              [-1,-1,-1]])\n\n# applying different kernels to the input image\nsharpened = cv2.filter2D(image, -1, kernel_sharpening)\n\n\nplt.subplot(1, 2, 2)\nplt.title(\"Image Sharpening\")\nplt.imshow(sharpened)\n\nplt.show()","d3dde433":"# Load our new image\nimage = cv2.imread('\/kaggle\/input\/chinese-fine-art\/Dataset\/Liu_Yuan_Shou_\u5289\u5143\u58fd\/Liu_Yuanshou_11.jpg', 0)\n\nplt.figure(figsize=(30, 30))\nplt.subplot(3, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\n\n# Values below 127 goes to 0 (black, everything above goes to 255 (white)\nret,thresh1 = cv2.threshold(image, 127, 255, cv2.THRESH_BINARY)\n\nplt.subplot(3, 2, 2)\nplt.title(\"Threshold Binary\")\nplt.imshow(thresh1)\n\n# It's good practice to blur images as it removes noise\nimage = cv2.GaussianBlur(image, (3, 3), 0)\n\n# Using adaptiveThreshold\nthresh = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 3, 5) \n\nplt.subplot(3, 2, 3)\nplt.title(\"Adaptive Mean Thresholding\")\nplt.imshow(thresh)\n\n\n_, th2 = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\n\nplt.subplot(3, 2, 4)\nplt.title(\"Otsu's Thresholding\")\nplt.imshow(th2)\n\n\nplt.subplot(3, 2, 5)\n# Otsu's thresholding after Gaussian filtering\nblur = cv2.GaussianBlur(image, (5,5), 0)\n_, th3 = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\nplt.title(\"Guassian Otsu's Thresholding\")\nplt.imshow(th3)\nplt.show()","c7713ab7":"image = cv2.imread('\/kaggle\/input\/chinese-fine-art\/Dataset\/Liu_Yuan_Shou_\u5289\u5143\u58fd\/Liu_Yuanshou_10.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\nplt.figure(figsize=(20, 20))\nplt.subplot(3, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\n\n# Let's define our kernel size\nkernel = np.ones((5,5), np.uint8)\n\n# Now we erode\nerosion = cv2.erode(image, kernel, iterations = 1)\n\nplt.subplot(3, 2, 2)\nplt.title(\"Erosion\")\nplt.imshow(erosion)\n\n# \ndilation = cv2.dilate(image, kernel, iterations = 1)\nplt.subplot(3, 2, 3)\nplt.title(\"Dilation\")\nplt.imshow(dilation)\n\n\n# Opening - Good for removing noise\nopening = cv2.morphologyEx(image, cv2.MORPH_OPEN, kernel)\nplt.subplot(3, 2, 4)\nplt.title(\"Opening\")\nplt.imshow(opening)\n\n# Closing - Good for removing noise\nclosing = cv2.morphologyEx(image, cv2.MORPH_CLOSE, kernel)\nplt.subplot(3, 2, 5)\nplt.title(\"Closing\")\nplt.imshow(closing)","66144a40":"image = cv2.imread('\/kaggle\/input\/chinese-fine-art\/Dataset\/Liu_Yuan_Shou_\u5289\u5143\u58fd\/Liu_Yuanshou_09.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\nheight, width,_ = image.shape\n\n# Extract Sobel Edges\nsobel_x = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=5)\nsobel_y = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=5)\n\nplt.figure(figsize=(20, 20))\n\nplt.subplot(3, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\n\nplt.subplot(3, 2, 2)\nplt.title(\"Sobel X\")\nplt.imshow(sobel_x)\n\nplt.subplot(3, 2, 3)\nplt.title(\"Sobel Y\")\nplt.imshow(sobel_y)\n\nsobel_OR = cv2.bitwise_or(sobel_x, sobel_y)\n\nplt.subplot(3, 2, 4)\nplt.title(\"sobel_OR\")\nplt.imshow(sobel_OR)\n\nlaplacian = cv2.Laplacian(image, cv2.CV_64F)\n\nplt.subplot(3, 2, 5)\nplt.title(\"Laplacian\")\nplt.imshow(laplacian)\n\n# Canny Edge Detection uses gradient values as thresholds\n# The first threshold gradient\ncanny = cv2.Canny(image, 50, 120)\n\nplt.subplot(3, 2, 6)\nplt.title(\"Canny\")\nplt.imshow(canny)","c6d07088":"image = cv2.imread('\/kaggle\/input\/chinese-fine-art\/Dataset\/Liu_Yuan_Shou_\u5289\u5143\u58fd\/Liu_Yuanshou_08.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\nplt.figure(figsize=(20, 20))\n\nplt.subplot(1, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\n\n# Cordinates of the 4 corners of the original image\npoints_A = np.float32([[320,15], [700,215], [85,610], [530,780]])\n\n# Cordinates of the 4 corners of the desired output\n# We use a ratio of an A4 Paper 1 : 1.41\npoints_B = np.float32([[0,0], [420,0], [0,594], [420,594]])\n \n# Use the two sets of four points to compute \n# the Perspective Transformation matrix, M    \nM = cv2.getPerspectiveTransform(points_A, points_B)\n\n\nwarped = cv2.warpPerspective(image, M, (420,594))\n\nplt.subplot(1, 2, 2)\nplt.title(\"warpPerspective\")\nplt.imshow(warped)\n    ","c8eaf161":"image = cv2.imread('\/kaggle\/input\/chinese-fine-art\/Dataset\/Liu_Yuan_Shou_\u5289\u5143\u58fd\/Liu_Yuanshou_13.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\nplt.figure(figsize=(20, 20))\n\nplt.subplot(2, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\n\n# Let's make our image 3\/4 of it's original size\nimage_scaled = cv2.resize(image, None, fx=0.75, fy=0.75)\n\nplt.subplot(2, 2, 2)\nplt.title(\"Scaling - Linear Interpolation\")\nplt.imshow(image_scaled)\n\n# Let's double the size of our image\nimg_scaled = cv2.resize(image, None, fx=2, fy=2, interpolation = cv2.INTER_CUBIC)\n\nplt.subplot(2, 2, 3)\nplt.title(\"Scaling - Cubic Interpolation\")\nplt.imshow(img_scaled)\n\n# Let's skew the re-sizing by setting exact dimensions\nimg_scaled = cv2.resize(image, (900, 400), interpolation = cv2.INTER_AREA)\n\nplt.subplot(2, 2, 4)\nplt.title(\"Scaling - Skewed Size\")\nplt.imshow(img_scaled)","4cd7b317":"image = cv2.imread('\/kaggle\/input\/chinese-fine-art\/Dataset\/Liu_Yuan_Shou_\u5289\u5143\u58fd\/Liu_Yuanshou_06.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\nplt.figure(figsize=(20, 20))\n\nplt.subplot(2, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\n\nheight, width = image.shape[:2]\n\n# Let's get the starting pixel coordiantes (top  left of cropping rectangle)\nstart_row, start_col = int(height * .25), int(width * .25)\n\n# Let's get the ending pixel coordinates (bottom right)\nend_row, end_col = int(height * .75), int(width * .75)\n\n# Simply use indexing to crop out the rectangle we desire\ncropped = image[start_row:end_row , start_col:end_col]\n\n\nplt.subplot(2, 2, 2)\nplt.title(\"Cropped\")\nplt.imshow(cropped)","5d442a96":"image = cv2.imread('\/kaggle\/input\/chinese-fine-art\/Dataset\/Liu_Yuan_Shou_\u5289\u5143\u58fd\/Liu_Yuanshou_04.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\nplt.figure(figsize=(20, 20))\n\nplt.subplot(2, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\n\n# Creating our 3 x 3 kernel\nkernel_3x3 = np.ones((3, 3), np.float32) \/ 9\n\n# We use the cv2.fitler2D to conovlve the kernal with an image \nblurred = cv2.filter2D(image, -1, kernel_3x3)\n\nplt.subplot(2, 2, 2)\nplt.title(\"3x3 Kernel Blurring\")\nplt.imshow(blurred)\n\n# Creating our 7 x 7 kernel\nkernel_7x7 = np.ones((7, 7), np.float32) \/ 49\n\nblurred2 = cv2.filter2D(image, -1, kernel_7x7)\n\nplt.subplot(2, 2, 3)\nplt.title(\"7x7 Kernel Blurring\")\nplt.imshow(blurred2)","67252c38":"# Let's load a simple image with 3 black squares\nimage = cv2.imread('\/kaggle\/input\/chinese-fine-art\/Dataset\/Liu_Yuan_Shou_\u5289\u5143\u58fd\/Liu_Yuanshou_02.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\nplt.figure(figsize=(20, 20))\n\nplt.subplot(2, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\n\n\n# Grayscale\ngray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)\n\n# Find Canny edges\nedged = cv2.Canny(gray, 30, 200)\n\nplt.subplot(2, 2, 2)\nplt.title(\"Canny Edges\")\nplt.imshow(edged)\n\n# Finding Contours\n# Use a copy of your image e.g. edged.copy(), since findContours alters the image\ncontours, hierarchy = cv2.findContours(edged, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n\nplt.subplot(2, 2, 3)\nplt.title(\"Canny Edges After Contouring\")\nplt.imshow(edged)\n\nprint(\"Number of Contours found = \" + str(len(contours)))\n\n# Draw all contours\n# Use '-1' as the 3rd parameter to draw all\ncv2.drawContours(image, contours, -1, (0,255,0), 3)\n\nplt.subplot(2, 2, 4)\nplt.title(\"Contours\")\nplt.imshow(image)\n\n","3776b73d":"# Load image and keep a copy\nimage = cv2.imread('\/kaggle\/input\/chinese-fine-art\/Dataset\/Liu_Yuan_Shou_\u5289\u5143\u58fd\/Liu_Yuanshou_07.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\nplt.figure(figsize=(20, 20))\n\nplt.subplot(2, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\n\norig_image = image.copy()\n\n\n# Grayscale and binarize\ngray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\nret, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY_INV)\n\n# Find contours \ncontours, hierarchy = cv2.findContours(thresh.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)\n\n# Iterate through each contour and compute the bounding rectangle\nfor c in contours:\n    x,y,w,h = cv2.boundingRect(c)\n    cv2.rectangle(orig_image,(x,y),(x+w,y+h),(0,0,255),2)    \n    plt.subplot(2, 2, 2)\n    plt.title(\"Bounding Rectangle\")\n    plt.imshow(orig_image)\n    \ncv2.waitKey(0) \n    \n# Iterate through each contour and compute the approx contour\nfor c in contours:\n    # Calculate accuracy as a percent of the contour perimeter\n    accuracy = 0.03 * cv2.arcLength(c, True)\n    approx = cv2.approxPolyDP(c, accuracy, True)\n    cv2.drawContours(image, [approx], 0, (0, 255, 0), 2)\n    \n    plt.subplot(2, 2, 3)\n    plt.title(\"Approx Poly DP\")\n    plt.imshow(image)\n\nplt.show()\n    \n# Convex Hull\n\n\nimage = cv2.imread('\/kaggle\/input\/opencv-samples-images\/hand.jpg')\ngray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\nplt.figure(figsize=(20, 20))\n\nplt.subplot(1, 2, 1)\nplt.title(\"Original Image\")\nplt.imshow(image)\n\n\n# Threshold the image\nret, thresh = cv2.threshold(gray, 176, 255, 0)\n\n# Find contours \ncontours, hierarchy = cv2.findContours(thresh.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)\n    \n# Sort Contors by area and then remove the largest frame contour\nn = len(contours) - 1\ncontours = sorted(contours, key=cv2.contourArea, reverse=False)[:n]\n\n# Iterate through contours and draw the convex hull\nfor c in contours:\n    hull = cv2.convexHull(c)\n    cv2.drawContours(image, [hull], 0, (0, 255, 0), 2)\n\n    plt.subplot(1, 2, 2)\n    plt.title(\"Convex Hull\")\n    plt.imshow(image)","bf5657d8":"#codes from Endi Niu @niuddd\nimg = cv2.imread('\/kaggle\/input\/chinese-fine-art\/Dataset\/Liu_Yuan_Shou_\u5289\u5143\u58fd\/Liu_Yuanshou_03.jpg')\nimg = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\nfig = plt.figure(figsize=(8,8))\nplt.imshow(img)\n","16bdb8d3":"# Codes from Bulent Siyah  https:\/\/www.kaggle.com\/bulentsiyah\/learn-opencv-by-examples-with-python","ae6defa3":"Approximating Contours and Convex Hull","2aa21d87":"Blurring","7eaf3887":"Kaggle Notebook Runner: Mar\u00edlia Prata @mpwolke","cd0244f7":"Scaling, re-sizing and interpolations","63b9c8f0":"Contours","404d39ac":"Edge Detection & Image Gradients","2b811edb":"Dilation, Erosion, Opening and Closing","630ecda6":"Perpsective Transform","9cb2502b":"Cropping","b7bad0a3":"Sharpening","6c81ae14":"Thresholding, Binarization & Adaptive Thresholding"}}