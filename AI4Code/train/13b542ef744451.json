{"cell_type":{"b1940f04":"code","37d5c1c6":"code","52cc8cdb":"code","dd144f05":"code","dc588f2c":"code","895adc8c":"code","28154300":"code","66e3d965":"code","16aa108f":"code","5d2a1356":"code","b8b26751":"code","a76e0b5a":"code","2014fc35":"code","bc641ee6":"code","72ec2be8":"code","701b0c0e":"code","24aa1928":"markdown","0ad55005":"markdown","70297d1b":"markdown","0cbc108f":"markdown","ea9b8b44":"markdown"},"source":{"b1940f04":"import numpy as np\nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport seaborn as sns \nfrom tqdm import tqdm \nimport time, os, pickle, json, random  \nfrom PIL import Image \nimport cv2 \nfrom sklearn.metrics import f1_score, accuracy_score, recall_score, precision_score, roc_auc_score\nfrom sklearn.model_selection import train_test_split \nimport requests \nfrom statistics import mean \n\nimport torch \nfrom torch.utils.data import DataLoader \nfrom torchvision import transforms \nimport torch.nn as nn ","37d5c1c6":"# Const \nSEED = 42 \nROOT = \"..\/input\/rsna-process\/\"\nLR = 0.0005\nBATCH_SIZE = 32 \nEPOCH = 20\n\ndevice = \"cuda:0\" if torch.cuda.is_available() else \"cpu\"\ntorch.manual_seed(SEED)\nnp.random.seed(SEED)","52cc8cdb":"train_df = pd.read_csv(ROOT+\"output\/train.csv\")\ntest_df = pd.read_csv(ROOT+\"output\/test.csv\")\n\ntrain_df, val_df = train_test_split(train_df, random_state=SEED, test_size=0.3, stratify=train_df.labels)\nprint(train_df.shape[0], val_df.shape[0], test_df.shape[0])","dd144f05":"train_df.head()","dc588f2c":"mp_mri_type = ['FLAIR', 'T1w', 'T1wCE', 'T2w']\n\nclass Dataset():\n    def __init__(self, df, is_train=\"train\"):\n        self.df = df\n        self.is_train = is_train \n        self.transform1 = transforms.Compose([\n                                             transforms.ToTensor(),\n                                             transforms.RandomRotation(degrees=(-20, 20))\n        ])\n        self.transfrom2 = transforms.Compose([transforms.ToTensor()])\n        \n    def transpose(self, x):\n        a, b, c = x.shape \n        frame = min(a, b, c)\n        if frame == a:\n            return x.transpose(1, 2, 0)\n        elif frame == b:\n            return x.transpose(0, 2, 1)\n        elif frame == c:\n            return x.transpose(0, 1, 2)\n\n    def load_npy(self, f):\n        x = np.load(f) \n        x = self.transpose(x) # (w, h, f)\n        if self.is_train == \"train\" and random.random() > 0.5:\n            x = self.transform1(x)\n        else:\n            x = self.transfrom2(x)\n        return x # (64, 224, 224)\n\n    def __getitem__(self, idx):\n        x = self.df.iloc[[idx]]\n        result = {}\n        for mri_type in mp_mri_type:\n            result[mri_type] = self.load_npy(str(ROOT)+str(x[mri_type].values[0])) # PATH\u306e\u4fee\u6b63\n        if self.is_train in [\"train\", \"val\"]:\n            result[\"labels\"] = torch.tensor(x[\"labels\"].values[0], dtype=torch.float)\n        result = {k: v.to(device) for k, v in result.items()}\n        return result \n    def __len__(self):\n        return self.df.shape[0]\n","895adc8c":"sample_ds = Dataset(train_df)\nsample_scan_id = 0\nsample_num_frame = 8\n\nfig, axes = plt.subplots(8, 4, figsize=(7, 14))\nax = axes.ravel()\nfor f in range(sample_num_frame):\n    for i, mri_type in enumerate(mp_mri_type):\n        ax[4*f+i].imshow(sample_ds[sample_scan_id][mri_type][f].detach().cpu(), cmap=\"gray\")      \n        ax[4*f+i].set_xticks([])\n        ax[4*f+i].set_yticks([])        \n        if f == 0:\n            ax[4*f+i].set_title(mri_type, c=\"g\")\nplt.subplots_adjust(wspace=0, hspace=0)","28154300":"class Net(nn.Module):\n    def __init__(self, n_classes=1):\n        super(Net, self).__init__()\n        self.layer0 = self.conv2normRelu(64, 128)\n        self.layer1 = self.conv2normRelu(128, 256)\n        self.layer2 = self.conv2normRelu(256, 512)\n        \n        self.fc0 = nn.Linear(25088, 512)\n        self.drop = nn.Dropout(0.2)\n        self.fc1 = nn.Linear(512, 1)\n        \n    def conv2normRelu(self, in_c, out_c, kernel_size=3, stride=1, padding=0):\n        layer = []\n        layer.append(nn.Conv2d(in_c, out_c, kernel_size, stride, padding=padding))\n        layer.append(nn.LeakyReLU(0.3, inplace=True))\n        layer.append(nn.MaxPool2d((3, 3)))\n        layer.append(nn.BatchNorm2d(out_c))\n        return nn.Sequential(*layer)\n    \n    def forward(self, x):\n        out = self.layer2(self.layer1(self.layer0(x)))\n        out = out.view(x.size()[0], -1)\n        out = self.fc1(self.drop(self.fc0(out)))\n        return out ","66e3d965":"def train_batch(train_dl, mri_type, net, criterion, optimizer, is_train=True):\n    total_loss = []\n    for data in train_dl:\n        x = data[mri_type]\n        t = data[\"labels\"]\n        if is_train:\n            out = net(x)\n        else:\n            with torch.no_grad():\n                out = net(x)\n        loss = criterion(out.view(-1), t)\n        if is_train:\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n        total_loss.append(loss.item())\n        del x, t, loss \n    return mean(total_loss)\n\ndef train_epoch(train_dl, val_dl, mri_type):\n    net = Net()\n    net.train()\n    net.to(device)\n    criterion = nn.BCEWithLogitsLoss()\n    optimizer = torch.optim.Adam(net.parameters(), lr=LR)\n    tr_loss, va_loss = [], []\n    best_net, best_loss_va = None, np.inf\n    for e in range(EPOCH):\n        loss_tr = train_batch(train_dl, mri_type, net, criterion, optimizer)\n        loss_va = train_batch(val_dl, mri_type, net, criterion, None, False)\n        tr_loss.append(loss_tr)\n        va_loss.append(loss_va)\n        logger(loss_tr, mri_type, e, \"train\")\n        logger(loss_va, mri_type, e, \"val\")\n        checkpoint(mri_type, net, e)\n        if best_loss_va > loss_va:\n            best_net = net \n            best_loss_va = loss_va \n    del net \n    checkpoint(mri_type, best_net, \"best\")\n    results = {\n        \"train_loss\": tr_loss, \n        \"val_loss\": va_loss, \n        \"best_loss\": best_loss_va,\n        \"type\": mri_type,\n        \"epoch\": e \n    }\n    logger(results, mri_type, None, None, is_print=False)\n    show_losses(tr_loss, va_loss, mri_type)\n\ndef train_type(train_df, val_df):\n    train_ds = Dataset(train_df)\n    val_ds = Dataset(val_df, is_train=\"val\")\n    train_dl = DataLoader(train_ds, batch_size=BATCH_SIZE, shuffle=True)\n    val_dl = DataLoader(val_ds, batch_size=BATCH_SIZE, shuffle=False)\n    start = time.time()\n    for mri_type in mp_mri_type:\n        train_epoch(train_dl, val_dl, mri_type)\n    now = time.time()\n    torch.cuda.empty_cache()\n    print(f\"dulation time: {now-start}s\")\n\n\ndef checkpoint(mri_type, net, e):\n    os.makedirs(f\".\/models\/{mri_type}\", exist_ok=True)\n    torch.save(net.state_dict(), f\".\/models\/{mri_type}\/{e}.pth\")\n    print(\"successed saving model\")\n\n\ndef logger(loss, mri_type, e, mode, is_print=True):\n    if is_print:\n        print(f\"MRI: {mri_type} | EPOCH: {e+1} | MODE: {mode} | LOSS: {loss:.4f} |\")\n    else:\n        os.makedirs(f\".\/log\/{mri_type}\", exist_ok=True)\n        with open(f\".\/log\/{mri_type}\/train.log\", \"wb\") as f:\n            pickle.dump([loss], f)\n    \ndef show_losses(tr_loss, va_loss, mri_type):\n    plt.figure(figsize=(16, 6))\n    plt.plot(np.arange(len(tr_loss)).tolist(), tr_loss, c=\"r\")\n    plt.plot(np.arange(len(va_loss)).tolist(), va_loss, c=\"b\")\n    plt.legend([\"Train\", \"Val\"])\n    plt.grid()\n    plt.title(mri_type)\n    plt.xlabel(\"Epoch\")\n    plt.ylabel(\"Loss\")\n    plt.show()","16aa108f":"train_type(train_df, val_df)","5d2a1356":"def load_net(mri_type):\n    net = Net()\n    net.load_state_dict(torch.load(f\"models\/{mri_type}\/best.pth\", map_location={\"cuda:0\": \"cpu\"}))\n    net.to(device)\n    net.eval()\n    return net \n\ndef metrics_score(pred, corr):\n    f1 = f1_score(pred, corr)\n    prec = precision_score(pred, corr)\n    rec = recall_score(pred, corr)\n    acc = accuracy_score(pred, corr)\n    roc = roc_auc_score(pred, corr)\n    return f1, prec, rec, acc, roc \n\ndef val_batch(val_dl, mri_type):\n    with torch.no_grad():\n        net = load_net(mri_type)\n        predict_proba, predict, correct = [], [], []\n        for data in val_dl:\n            x = data[mri_type].to(device)\n            t = data[\"labels\"].to(device)\n\n            out = net(x)\n            out = torch.sigmoid(out).cpu().numpy().squeeze()\n            for p in np.where(out > 0.5, 1, 0):\n                predict.append(p)\n            for c in t.detach().cpu().numpy().tolist():\n                correct.append(c)\n            for p in out:\n                predict_proba.append(p)\n        f1, prec, rec, acc, roc = metrics_score(predict, correct)\n        result = [f1, prec, rec, acc, roc]\n        del x, t\n    del net \n    return result, np.array(predict_proba), correct \n    \n\ndef val_type(val_df):\n    val_ds = Dataset(val_df)\n    val_dl = DataLoader(val_ds, batch_size=BATCH_SIZE, shuffle=False)\n    results, all_proba = [], []\n    for mri_type in mp_mri_type:\n        result, proba, correct = val_batch(val_dl, mri_type)\n        results.append(result)\n        all_proba.append(proba)\n        \n    all_pred = np.where(np.mean(all_proba, axis=0) > 0.5, 1, 0).tolist()\n    f1, prec, rec, acc, roc = metrics_score(all_pred, correct)\n    results.append([f1, prec, rec, acc, roc])\n    del all_pred \n    \n    index = ['FLAIR', 'T1w', 'T1wCE', 'T2w', \"All\"]\n    columns = [\"f1_score\", \"Precision\", \"recall\", \"accuracy\", \"roc_score\"]\n    df = pd.DataFrame(results, index=index, columns=columns)\n    df.to_csv(\"result.csv\", index=False)\n    \n    torch.cuda.empty_cache()\n    return df, all_proba ","b8b26751":"df, val_proba = val_type(val_df)","a76e0b5a":"sns.histplot(val_proba)\nplt.title(\"Val\")\nplt.legend(mp_mri_type)\nplt.show()","2014fc35":"df.style.background_gradient(cmap=\"coolwarm\")","bc641ee6":"def test_batch(test_dl, mri_type):\n    net = load_net(mri_type)\n    proba = []\n    for data in test_dl:\n        x = data[mri_type]\n        \n        with torch.no_grad():\n            out = net(x)\n            out = torch.sigmoid(out).squeeze().detach().cpu().numpy().tolist()\n            for o in out:\n                proba.append(o)\n        del x \n    del net \n    return np.array(proba) \n\ndef test_type(test_df):\n    test_ds = Dataset(test_df, \"test\")\n    test_dl = DataLoader(test_ds, batch_size=BATCH_SIZE, shuffle=False)\n    total_proba = []\n    for mri_type in mp_mri_type:\n        proba = test_batch(test_dl, mri_type)\n        total_proba.append(proba)\n    # All mean \n    total_proba = np.mean(total_proba, axis=0).tolist()\n    return total_proba  \n\ndef test_type_flair(test_df):\n    test_ds = Dataset(test_df, \"test\")\n    test_dl = DataLoader(test_ds, batch_size=BATCH_SIZE, shuffle=False)\n    proba = test_batch(test_dl, mp_mri_type[0])\n    return proba.tolist()\n    \n\ndef submit(test_df):\n    proba = test_type(test_df)\n    submission = pd.read_csv(\"..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/sample_submission.csv\", index_col=\"BraTS21ID\")\n    submission[\"MGMT_value\"] = proba \n    submission[\"MGMT_value\"].to_csv(\"submission.csv\")\n    print(\"successed submit\")\n    return proba ","72ec2be8":"test_proba = submit(test_df)","701b0c0e":"sns.histplot(test_proba)\nplt.title(\"Test\")\nplt.show()","24aa1928":"# Preprocess Class","0ad55005":"# Evaluate","70297d1b":"# Model","0cbc108f":"# Const ","ea9b8b44":"# Train "}}