{"cell_type":{"8e21758a":"code","9df06036":"code","2696445a":"code","616d0257":"code","f16d0be8":"code","76377640":"code","e549f34b":"code","63a1087f":"code","b5bfabda":"code","afb8814b":"code","aba7dd8d":"code","d3558e2c":"code","ad828a90":"code","4e9ec947":"code","d42f5f7c":"code","c8ab5e1c":"code","e7246661":"code","ed324db1":"code","57f39502":"code","8de897f5":"code","9d8bff31":"code","4b41df6d":"markdown","bb87590b":"markdown","9babcfd4":"markdown","31553d72":"markdown","170202e1":"markdown","1b73bf70":"markdown","bdaa9975":"markdown","eff8bac5":"markdown","f738584a":"markdown","7443147f":"markdown","b00793b3":"markdown","ad1e1bc6":"markdown","eef4b15f":"markdown","177502ed":"markdown","9524cc2b":"markdown","03689ae3":"markdown","0b6c53e5":"markdown","2969a4c3":"markdown","5bbb54fc":"markdown","3c3be40f":"markdown","496f4164":"markdown","0334811e":"markdown","3d1ea377":"markdown","6bf4ca4b":"markdown","387da3f6":"markdown","26752125":"markdown","cd59a797":"markdown","93404f51":"markdown","de5c431f":"markdown","6332e562":"markdown"},"source":{"8e21758a":"!pip install openvino-dev[onnx,tensorflow2]==2021.4.*","9df06036":"from openvino.inference_engine import IECore\n\nie = IECore()","2696445a":"devices = ie.available_devices\nfor device in devices:\n    device_name = ie.get_metric(device, \"FULL_DEVICE_NAME\")\n    print(f\"{device}: {device_name}\")","616d0257":"from openvino.inference_engine import IECore\n\nie = IECore()\nclassification_model_xml = \"\/kaggle\/input\/openvinoapiassets\/classification.xml\"\nnet = ie.read_network(model=classification_model_xml)\nexec_net = ie.load_network(network=net, device_name=\"CPU\")","f16d0be8":"from openvino.inference_engine import IECore\n\nie = IECore()\nonnx_model = \"\/kaggle\/input\/openvinoapiassets\/segmentation.onnx\"\nnet_onnx = ie.read_network(model=onnx_model)\nexec_net_onnx = ie.load_network(network=net_onnx, device_name=\"CPU\")","76377640":"from openvino.inference_engine import IECore\n\nie = IECore()\nclassification_model_xml = \"\/kaggle\/input\/openvinoapiassets\/classification.xml\"\nnet = ie.read_network(model=classification_model_xml)\nnet.input_info","e549f34b":"input_layer = next(iter(net.input_info))\ninput_layer","63a1087f":"print(f\"input layout: {net.input_info[input_layer].layout}\")\nprint(f\"input precision: {net.input_info[input_layer].precision}\")\nprint(f\"input shape: {net.input_info[input_layer].tensor_desc.dims}\")","b5bfabda":"from openvino.inference_engine import IECore\n\nie = IECore()\nclassification_model_xml = \"\/kaggle\/input\/openvinoapiassets\/classification.xml\"\nnet = ie.read_network(model=classification_model_xml)\nnet.outputs","afb8814b":"output_layer = next(iter(net.outputs))\noutput_layer","aba7dd8d":"print(f\"output layout: {net.outputs[output_layer].layout}\")\nprint(f\"output precision: {net.outputs[output_layer].precision}\")\nprint(f\"output shape: {net.outputs[output_layer].shape}\")","d3558e2c":"from openvino.inference_engine import IECore\n\nie = IECore()\nclassification_model_xml = \"\/kaggle\/input\/openvinoapiassets\/classification.xml\"\nnet = ie.read_network(model=classification_model_xml)\nexec_net = ie.load_network(network=net, device_name=\"CPU\")\ninput_layer = next(iter(net.input_info))\noutput_layer = next(iter(net.outputs))","ad828a90":"import cv2\n\nimage_filename = \"\/kaggle\/input\/openvinoapiassets\/coco_hollywood.jpg\"\nimage = cv2.imread(image_filename)\nimage.shape","4e9ec947":"# N,C,H,W = batch size, number of channels, height, width\nN, C, H, W = net.input_info[input_layer].tensor_desc.dims\n# OpenCV resize expects the destination size as (width, height)\nresized_image = cv2.resize(src=image, dsize=(W, H))\nresized_image.shape","d42f5f7c":"import numpy as np\n\ninput_data = np.expand_dims(np.transpose(resized_image, (2, 0, 1)), 0).astype(np.float32)\ninput_data.shape","c8ab5e1c":"result = exec_net.infer({input_layer: input_data})\nresult","e7246661":"output = result[output_layer]\noutput.shape","ed324db1":"from openvino.inference_engine import IECore\n\nie = IECore()\nsegmentation_model_xml = \"\/kaggle\/input\/openvinoapiassets\/segmentation.xml\"\nsegmentation_net = ie.read_network(model=segmentation_model_xml)\nsegmentation_input_layer = next(iter(segmentation_net.input_info))\nsegmentation_output_layer = next(iter(segmentation_net.outputs))\n\nprint(\"~~~~ ORIGINAL MODEL ~~~~\")\nprint(f\"input layout: {segmentation_net.input_info[segmentation_input_layer].layout}\")\nprint(f\"input shape: {segmentation_net.input_info[segmentation_input_layer].tensor_desc.dims}\")\nprint(f\"output shape: {segmentation_net.outputs[segmentation_output_layer].shape}\")\n\nnew_shape = (1, 3, 544, 544)\nsegmentation_net.reshape({segmentation_input_layer: new_shape})\nsegmentation_exec_net = ie.load_network(network=segmentation_net, device_name=\"CPU\")\n\nprint(\"~~~~ RESHAPED MODEL ~~~~\")\nprint(f\"net input shape: {segmentation_net.input_info[segmentation_input_layer].tensor_desc.dims}\")\nprint(\n    f\"exec_net input shape: \"\n    f\"{segmentation_exec_net.input_info[segmentation_input_layer].tensor_desc.dims}\"\n)\nprint(f\"output shape: {segmentation_net.outputs[segmentation_output_layer].shape}\")","57f39502":"from openvino.inference_engine import IECore\n\nie = IECore()\nsegmentation_model_xml = \"\/kaggle\/input\/openvinoapiassets\/segmentation.xml\"\nsegmentation_net = ie.read_network(model=segmentation_model_xml)\nsegmentation_input_layer = next(iter(segmentation_net.input_info))\nsegmentation_output_layer = next(iter(segmentation_net.outputs))\nsegmentation_net.batch_size = 2\nsegmentation_exec_net = ie.load_network(network=segmentation_net, device_name=\"CPU\")\n\nprint(f\"input layout: {segmentation_net.input_info[segmentation_input_layer].layout}\")\nprint(f\"input shape: {segmentation_net.input_info[segmentation_input_layer].tensor_desc.dims}\")\nprint(f\"output shape: {segmentation_net.outputs[segmentation_output_layer].shape}\")","8de897f5":"import numpy as np\nfrom openvino.inference_engine import IECore\n\nie = IECore()\nsegmentation_model_xml = \"\/kaggle\/input\/openvinoapiassets\/segmentation.xml\"\nsegmentation_net = ie.read_network(model=segmentation_model_xml)\nsegmentation_input_layer = next(iter(segmentation_net.input_info))\nsegmentation_output_layer = next(iter(segmentation_net.outputs))\ninput_data = np.random.rand(*segmentation_net.input_info[segmentation_input_layer].tensor_desc.dims)\nsegmentation_net.batch_size = 2\nsegmentation_exec_net = ie.load_network(network=segmentation_net, device_name=\"CPU\")\nresult_batch = segmentation_exec_net.infer({segmentation_input_layer: input_data})\n\nprint(f\"input data shape: {input_data.shape}\")\nprint(f\"result data data shape: {result_batch[segmentation_output_layer].shape}\")","9d8bff31":"import numpy as np\nfrom openvino.inference_engine import IECore\n\nie = IECore()\nsegmentation_model_xml = \"\/kaggle\/input\/openvinoapiassets\/segmentation.xml\"\nsegmentation_net = ie.read_network(model=segmentation_model_xml)\nsegmentation_input_layer = next(iter(segmentation_net.input_info))\nsegmentation_output_layer = next(iter(segmentation_net.outputs))\nsegmentation_net.batch_size = 2\ninput_data = np.random.rand(*segmentation_net.input_info[segmentation_input_layer].tensor_desc.dims)\nsegmentation_exec_net = ie.load_network(network=segmentation_net, device_name=\"CPU\")\nresult_batch = segmentation_exec_net.infer({segmentation_input_layer: input_data})\n\nprint(f\"input data shape: {input_data.shape}\")\nprint(f\"result data shape: {result_batch[segmentation_output_layer].shape}\")","4b41df6d":"## Getting Information about a Model\n\nThe OpenVINO IENetwork instance stores information about the model. Information about the inputs and outputs of the model are in `net.input_info` and `net.outputs`. These are also properties of the ExecutableNetwork instance. Where we use `net.input_info` and `net.outputs` in the cells below, you can also use `exec_net.input_info` and `exec_net.outputs`.","bb87590b":"The cell above shows that the model loaded expects one input, with the name _input_. If you loaded a different model, you may see a different input layer name, and you may see more inputs.\n\nIt is often useful to have a reference to the name of the first input layer. For a model with one input, `next(iter(net.input_info))` gets this name.","9babcfd4":"**Preparation: load network**","31553d72":"Model output info is stored in `net.outputs`. The cell above shows that the model returns one output, with the name _MobilenetV3\/Predictions\/Softmax_. If you loaded a different model, you will probably see a different output layer name, and you may see more outputs.\n\nSince this model has one output, follow the same method as for the input layer to get its name.","170202e1":"### ONNX Model\n\nAn ONNX model is a single file. Reading and loading an ONNX model works the same way as reading and loading an IR model. The `model` argument points to the ONNX filename.","1b73bf70":"### Model Inputs","bdaa9975":"This cell output shows that the model returns outputs with a shape of [1, 1001], where 1 is the batch size (N) and 1001 the number of classes (C). The output is returned as 32-bit floating point.","eff8bac5":"This cell output tells us that the model expects inputs with a shape of [1,3,224,224], and that this is in NCHW layout. This means that the model expects input data with a batch size (N) of 1, 3 channels (C), and images of a height (H) and width (W) of 224. The input data is expected to be of FP32 (floating point) precision.","f738584a":"Getting the output layout, precision and shape is similar to getting the input layout, precision and shape.","7443147f":"**Do inference**\n\nNow that the input data is in the right shape, doing inference is one simple command:","b00793b3":"### Model Outputs","ad1e1bc6":"Information for this input layer is stored in `input_info`. The next cell prints the input layout, precision and shape.","eef4b15f":"## Loading a Model\n\nAfter initializing Inference Engine, first read the model file with `read_network()`, then load it to the specified device with `load_network()`. \n\n### IR Model\n\nAn IR (Intermediate Representation) model consists of an .xml file, containing model information, and a .bin file, containing the weights. `read_network()` expects the weights file to be located in the same directory as the xml file, with the same filename, and the extension .bin: `model_weights_file == Path(model_xml).with_suffix(\".bin\")`. If this is the case, specifying the weights file is optional. If the weights file has a different filename, it can be specified with the `weights` parameter to `read_network()`.\n\nSee the [tensorflow-to-openvino](..\/101-tensorflow-to-openvino\/101-tensorflow-to-openvino.ipynb) and [pytorch-onnx-to-openvino](..\/102-pytorch-onnx-to-openvino\/102-pytorch-onnx-to-openvino.ipynb) notebooks for information on how to convert your existing Tensorflow, PyTorch or ONNX model to OpenVINO's IR format.","177502ed":"## Reshaping and Resizing\n\n### Change Image Size","9524cc2b":"**Preparation: load image and convert to input shape**\n\nTo propagate an image through the network, it needs to be loaded into an array, resized to the shape that the network expects, and converted to the network's input layout.","03689ae3":"The output shape is (1,1001), which we saw is the expected shape of the output. This output shape indicates that the network returns probabilities for 1001 classes. To transform this into meaningful information, check out the [hello world notebook](..\/001-hello-world\/001-hello-world.ipynb).","0b6c53e5":"# OpenVINO API Tutorial","2969a4c3":"### Change Batch Size","5bbb54fc":"The output shows that the if the batch size is 2, the network output will have a batch size of 2, even if only one image was propagated through the network. Regardless of batch size, you can always do inference on one image. In that case, only the first network output contains meaningful information.\n\nVerify that inference on two images works by creating random data with a batch size of 2:","3c3be40f":"## Load Inference Engine and Show Info\n\nInitialize Inference Engine with IECore()","496f4164":"`.infer()` returns a dictionary, mapping output layers to data. Since we know this network returns one output, and we stored the reference to the output layer in the `output_layer` variable, we can get the data with `result[output_layer]`","0334811e":"The image has a shape of (663,994,3). It is 663 pixels in height, 994 pixels in width, and has 3 color channels. We get a reference to the height and width that the network expects and resize to that size","3d1ea377":"We can also use `.reshape()` to set the batch size, by increasing the first element of _new_shape_. For example, to set a batch size of two, set `new_shape = (2,3,544,544)` in the cell above. If you only want to change the batch size, you can also set the `batch_size` property directly. ","6bf4ca4b":"Inference Engine can load a network on a device. A device in this context means a CPU, an Intel GPU, a Neural Compute Stick 2, etc. The `available_devices` property shows the devices that are available on your system. The \"FULL_DEVICE_NAME\" option to `ie.get_metric()` shows the name of the device.\n\nIn this notebook the CPU device is used. To use an integrated GPU, use `device_name=\"GPU\"` instead. Note that loading a network on GPU will be slower than loading a network on CPU, but inference will likely be faster.","387da3f6":"## Doing Inference on a Model\n\nTo do inference on a model, call the `infer()` method of the _ExecutableNetwork_, the `exec_net` that we loaded with `load_network()`. `infer()` expects one argument: _inputs_. This is a dictionary, mapping input layer names to input data.","26752125":"The output shows that by setting the batch size to 2, the first element (N) of the input and output shape now has a value of 2. Let's see what happens if we propagate our input image through the network:","cd59a797":"This notebook explains the basics of the OpenVINO Inference Engine API. It covers:\n\n- [Load Inference Engine and Show Info](#Load-Inference-Engine-and-Show-Info)\n- [Loading a Model](#Loading-a-Model)\n  - [IR Model](#IR-Model)\n  - [ONNX Model](#ONNX-Model)\n- [Getting Information about a Model](#Getting-Information-about-a-Model)\n  - [Model Inputs](#Model-Inputs)\n  - [Model Outputs](#Model-Outputs)\n- [Doing Inference on a Model](#Doing-Inference-on-a-Model)\n- [Reshaping and Resizing](#Reshaping-and-Resizing)\n  - [Change Image Size](#Change-Image-Size)\n  - [Change Batch Size](#Change-Batch-Size)\n    \nThe notebook is divided into sections with headers. Each section is standalone and does not depend on previous sections. A segmentation and classification IR model and a segmentation ONNX model are provided as examples. You can replace these model files with your own models. The exact outputs will be different, but the process is the same. ","93404f51":"The input shape for the segmentation network is [1,3,512,512], with an NHCW layout: the network expects 3-channel images with a width and height of 512 and a batch size of 1. We reshape the network to make it accept input images with a width and height of 544 with the `.reshape()` method of `IENetwork`. This segmentation network always returns arrays with the same width and height as the input width and height, so setting the input dimensions to 544x544 also modifies the output dimensions. After reshaping, load the network to the device again.","de5c431f":"Now the image has the width and height that the network expects. It is still in H,C,W format. We change it to N,C,H,W format (where N=1) by first calling `np.transpose()` to change to C,H,W and then adding the N dimension by calling `np.expand_dims()`. Convert the data to FP32 with `np.astype()`.","6332e562":"Instead of reshaping the image to fit the model, you can also reshape the model to fit the image. Note that not all models support reshaping, and models that do may not support all input shapes. The model accuracy may also suffer if you reshape the model input shape.\n\nWe first check the input shape of the model, and then reshape to the new input shape."}}