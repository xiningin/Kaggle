{"cell_type":{"fb4cda43":"code","5d936e76":"code","155644fe":"code","3b7f3638":"code","b017addb":"code","7e0e8cd0":"code","3568298d":"code","35ee5506":"code","3561038e":"code","7be1bb76":"code","fa58bf61":"code","4c0ced7e":"code","2ec78fed":"code","77cda2e9":"code","d1ca98c4":"code","c78d80d5":"code","7677b8bb":"code","0ebf7d05":"code","8e6227ed":"code","06f4db8d":"code","97cdce5e":"code","eb9fd4cd":"code","89930895":"code","df623b40":"code","f68a3847":"code","1e783843":"code","440f4a0d":"code","d8509ede":"code","c5fca9ea":"code","aa7629a7":"code","66a85bad":"code","40ed7337":"code","72c2b090":"code","03e58a44":"markdown"},"source":{"fb4cda43":"# Muestro el estado del jugador en partidas de clasificatoria\n# ==============================================================\n#my_ranked_stats = lol_watcher.league.by_summoner(my_region, me['id'])\n#my_ranked_stats","5d936e76":"# Muestro las partidas del jugador\n# ==============================================================\n#my_matches = lol_watcher.match.matchlist_by_account(my_region, me['accountId'])\n#my_matches","155644fe":"#Librerias Necesarias Para comenzar\n# Tratamiento de datos\n# ==============================================================\nimport pandas as pd\nimport numpy as np\n\n# Gr\u00e1ficos\n# ==============================================================\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# EDA Complementario\n# ==============================================================\nfrom pandas_profiling import ProfileReport\n\n# Preprocesado y modelado\n# ==============================================================\n\nfrom sklearn.model_selection import train_test_split\nfrom category_encoders import OneHotEncoder, OrdinalEncoder\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom xgboost import XGBClassifier\n\n# Importancia de las variables\n# ==============================================================\nfrom sklearn.metrics import roc_curve, roc_auc_score\nfrom sklearn.metrics import plot_confusion_matrix\nfrom sklearn.inspection import permutation_importance\n\n# Se Carga el csv con el dataset\n# ==============================================================\nimport csv\ndf_LOL = pd.read_csv('high_diamond_ranked_10min.csv')","3b7f3638":"#Echamos un vistazo a las dimensiones del dataset\n# ==============================================================\nprint(df_LOL.shape)\n\n# Primer vistazo a la estructura del dataset\n# ==============================================================\ndf_LOL.head()","b017addb":"# Tipo de dato en cada columna\n# ==============================================================\ndf_LOL.info()","7e0e8cd0":"# Revisamos N\u00famero de datos ausentes por variable\n# ==============================================================\ndf_LOL.isna().sum()","3568298d":"#pip install -U pandas-profiling\n# Con el pandas profile Report se puede obtener un reporte completo de todas las variables\n# y apoyar as\u00ed al an\u00e1lisis EDA. Queda adjunto como archivo anexo debido a la extensi\u00f3n\n# y a lo que tarda en cargar el c\u00f3digo.\n# ==============================================================\n\n#from pandas_profiling import ProfileReport\n#profile = ProfileReport(df_LOL, title='EDA_LOL_Complementario.html')\n#profile.to_notebook_iframe()","35ee5506":"# Con esta opci\u00f3n se exporta para poder revisarlo de una forma m\u00e1s c\u00f3moda.\n# Este archivo ser\u00e1 adjuntado como un anexo por la carga que supone en el c\u00f3digo.\n# ================================================================================\n\n#profile.to_file(output_file=\"EDA_LOL_Complementario.html\")","3561038e":"# Variable gameID pasa a convertirse en \u00edndice del dataset.\n# ==============================================================\n\ndf_LOL = pd.read_csv('high_diamond_ranked_10min.csv', index_col='gameId')\ndf_LOL.head()","7be1bb76":"# Transformacion - Eliminaci\u00f3n de columnas que no aportan informaci\u00f3n relevante\n\n# Pasamos los nombres de las columnas a minusculas para facilitar\n# la transcripci\u00f3n.\n# ==============================================================\ndf_LOL.columns = map(str.lower, df_LOL.columns)\n\n# Se agrupan todas dentro de la variable \"deleted\" y se eliminan\n# ==============================================================\n\ndeleted = ['redfirstblood',\n            'redkills',\n            'reddeaths',\n            'redgolddiff',\n            'redexperiencediff',\n            'redcspermin',\n            'redgoldpermin',\n            'redheralds',\n            'blueavglevel',\n            'bluecspermin',\n            'bluegoldpermin',\n            'bluegolddiff',\n            'blueexperiencediff',\n            'redavglevel']\ndf_LOL1 = df_LOL.drop(deleted, axis=1)\n\n# Se comprueba dicha eliminacion comparando las dimensiones de los datasets\n# ==========================================================================\nprint(df_LOL.shape)\nprint(df_LOL1.shape)","fa58bf61":"#Se comprueba la distribuci\u00f3n de la variable objetivo.\n# ==============================================================\n\ndf_LOL1.bluewins.value_counts()","4c0ced7e":"# Dividimos los set de train y test\n# ==============================================================\n\nfrom sklearn.model_selection import train_test_split\ntrain , test = train_test_split (df_LOL1, test_size = .09, random_state=7, stratify=df_LOL1['bluewins'])","2ec78fed":"print(test.shape)\ntest.head()","77cda2e9":"corr = train[train.columns[1:]].apply(lambda x: x.corr(train['bluewins']))\ncols = []\nfor col in corr.index:\n    if (corr[col]>0.2 or corr[col]<-0.2):\n        cols.append(col)\n        \ncols","d1ca98c4":"# Se asegura que test tiene el mismo n\u00famero de variables\n# que el set de entrenamiento.\n# ==============================================================\n\ntestcols = cols + ['bluewins']","c78d80d5":"test = test[testcols]\ndf_new = train[cols]\nprint(df_new.shape)\ndf_new.head()","7677b8bb":"# Division de Train\/Test para entrenar.\n# ==============================================================\n\nX = df_new\ny = train['bluewins']\n\nX_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state = 7)","0ebf7d05":"# Se comprueba el Baseline Accuracy\n# ==============================================================\n\nprint('Baseline Accuracy:', y_train.value_counts(normalize=True).max())","8e6227ed":"# Modelo b\u00e1sico Decission Tree\n# ==============================================================\n\nmodelo_DT = make_pipeline(\n    OrdinalEncoder(),\n    StandardScaler(),\n    DecisionTreeClassifier(random_state=7, max_depth=4)\n)\n\nmodelo_DT.fit(X_train, y_train)\n","06f4db8d":"print('Training Accuracy:', modelo_DT.score(X_train, y_train))\nprint('Validation Accuracy:', modelo_DT.score(X_val, y_val))","97cdce5e":"# Modelo Random Forest\n# ==============================================================\n\nmodelo_RF = make_pipeline(\n    OrdinalEncoder(),\n    StandardScaler(),\n    RandomForestClassifier(random_state=7, max_depth=4)\n)\n\nmodelo_RF.fit(X_train, y_train)","eb9fd4cd":"print('Training Accuracy:', modelo_RF.score(X_train, y_train))\nprint('Validation Accuracy:', modelo_RF.score(X_val, y_val))","89930895":"# Modelo Gradient Boost (XGB)\n# ==============================================================\n\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom xgboost import XGBClassifier\n\nmodelo_XGB = make_pipeline(\n    OrdinalEncoder(),\n    StandardScaler(),\n    XGBClassifier(random_state= 7, n_jobs=16, max_depth=6, learning_rate=0.003)\n)\n\nmodelo_XGB.fit(X_train, y_train)","df623b40":"print('Training Accuracy:', modelo_XGB.score(X_train, y_train))\nprint('Validation Accuracy:', modelo_XGB.score(X_val, y_val))","f68a3847":"# El mejor modelo obtenido para el test, en este caso XGBoost ser\u00e1 el elegido\n# ============================================================================\n\ny_test = test['bluewins'] \nX_test = test[cols]\n\nprint('Training Accuracy:', modelo_XGB.score(X_train, y_train))\nprint('Testing Accuracy:', modelo_XGB.score(X_test, y_test))","1e783843":"encoder = OrdinalEncoder()\nX_test_encoded = encoder.fit_transform(X_test, y_test)\nprint(X_test_encoded.shape)","440f4a0d":"X_test_encoded.iloc[[81]]","d8509ede":"modelo_definitivo = modelo_XGB","c5fca9ea":"# Preparaci\u00f3n Curva ROC\n# ==============================================================\n\nfrom sklearn.metrics import roc_curve, roc_auc_score\n\npred_prob = modelo_definitivo.predict_proba(X_val)[:, -1]\nfpr_t, tpr_t, thresholds_t = roc_curve(y_val, pred_prob)\nprint(pred_prob)","aa7629a7":"plt.plot(fpr_t, tpr_t, label = 'XGBoost', color='red')\nplt.title('ROC Curve')\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.legend();\nprint('XGBoost ROC-AUC:', roc_auc_score(y_val, pred_prob))","66a85bad":"# Matriz de confusion\n# ==============================================================\n\nfrom sklearn.metrics import plot_confusion_matrix\nplot_confusion_matrix(modelo_definitivo, X_val, y_val,\n                      values_format='.0f',\n                      display_labels=['Blue Wins', 'Blue Loses']);","40ed7337":"# Con la permutaci\u00f3n de importancias se puede obtener en tabla y de forma gr\u00e1fica \n# la media y la desviaci\u00f3n t\u00edpica, las cuales servir\u00e1n para ver de forma ordenada\n# una clasificaci\u00f3n de las variables ordenadas por su importancia en el modelo.\n# =======================================================================================\n\nfrom sklearn.inspection import permutation_importance\n\npi = permutation_importance(modelo_definitivo, X_val, y_val, n_jobs=16)\n\npi.keys()\n\ndata = {'importances_mean': np.round(pi['importances_mean'], 6),\n       'importances_std': pi['importances_std']}\n\ndf_pi = pd.DataFrame(data, index= X_val.columns).sort_values(by='importances_mean', ascending=False)\n\n# Se muestra la tabla\n# ==============================================================\ndf_pi","72c2b090":"# Grafico importancia variables\n# ==============================================================\n\nimport plotly.express as px\n\nfig = px.bar(df_pi['importances_mean'])\nfig.show()","03e58a44":"#Conexi\u00f3n con la API\n\n#Instalamos RiotWatcher.\n# ==============================================================\n#!pip3 install riotwatcher\n#from riotwatcher import LolWatcher, ApiError\n\n#Cargamos la clave. Esta clave es de desarrollador, personal e intransferible.\n# ==============================================================\n#lol_watcher = LolWatcher('RGAPI-KEY')\n\n# Cargamos la regi\u00f3n que corresponde al jugador \n# del que realizamos la exploraci\u00f3n.\n# ==============================================================\n#my_region = 'euw1'\n\n#Cargamos los datos del jugador que queremos.\n# ==============================================================\n#me = lol_watcher.summoner.by_name(my_region, 'player game')\n#me\n\n\n"}}