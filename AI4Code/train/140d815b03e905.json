{"cell_type":{"7d48113b":"code","8d46ae38":"code","ca183f86":"code","c2f3a756":"code","a5fb9c27":"code","f4026f4b":"code","779f2d40":"code","c1c6f69b":"code","8cd91872":"code","3b842bcb":"code","476c6831":"code","ea7b6aab":"code","c0abec46":"code","9f9552d6":"code","02760fce":"code","e54ebe22":"code","4cceb7f1":"code","d050fba4":"code","a3ab43c5":"code","26a8e8b3":"code","03786e2d":"code","28763927":"code","6d36e8e3":"code","fd655872":"code","bd8594ff":"code","b9915b04":"code","e422a4f8":"code","fe4cec29":"code","b2be805e":"code","f7452d8e":"code","1de260b7":"code","6643a056":"code","a053030d":"code","a0218dc9":"code","d7bd5660":"code","85ec141c":"code","82f213df":"code","500181b6":"code","d19b779f":"code","b0bb19c0":"code","783963c5":"code","39aac3f7":"code","f61aa798":"code","25e1a0a1":"code","8df2b14d":"code","e78f8fd7":"code","f5b7fc77":"code","f927133a":"code","0cfe89df":"code","d77e545b":"code","330e57ea":"code","449b252a":"markdown","d08308d6":"markdown","20d68d95":"markdown","d6e10cbc":"markdown","3487829a":"markdown","f40f003f":"markdown","374bd586":"markdown","dba05e35":"markdown","fb4f0827":"markdown","c11e1058":"markdown","5779a372":"markdown","d1a0d8e7":"markdown","923c93a5":"markdown","d73546ab":"markdown"},"source":{"7d48113b":"!pip install imutils","8d46ae38":"# import the necessary packages\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\n\nfrom tensorflow.keras.utils import to_categorical\nfrom sklearn.preprocessing import LabelBinarizer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom IPython.display import FileLink\nfrom imutils import paths\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\nnp.random.seed(0)\n\nimport random\nimport shutil\nimport cv2\nimport os\n","ca183f86":"dataset_path = '.\/dataset'","c2f3a756":"%%bash\nrm -rf dataset\nmkdir -p dataset\/covid\nmkdir -p dataset\/normal","a5fb9c27":"samples = 25","f4026f4b":"covid_dataset_path = '..\/input\/covid-chest-xray'","779f2d40":"# construct the path to the metadata CSV file and load it\ncsvPath = os.path.sep.join([covid_dataset_path, \"metadata.csv\"])\ndf = pd.read_csv(csvPath)\n\n# loop over the rows of the COVID-19 data frame\nfor (i, row) in df.iterrows():\n    # if (1) the current case is not COVID-19 or (2) this is not\n    # a 'PA' view, then ignore the row\n    if row[\"finding\"] != \"COVID-19\" or row[\"view\"] != \"PA\":\n        continue\n\n    # build the path to the input image file\n    imagePath = os.path.sep.join([covid_dataset_path, \"images\", row[\"filename\"]])\n\n    # if the input image file does not exist (there are some errors in\n    # the COVID-19 metadeta file), ignore the row\n    if not os.path.exists(imagePath):\n        continue\n\n    # extract the filename from the image path and then construct the\n    # path to the copied image file\n    filename = row[\"filename\"].split(os.path.sep)[-1]\n    outputPath = os.path.sep.join([f\"{dataset_path}\/covid\", filename])\n\n    # copy the image\n    shutil.copy2(imagePath, outputPath)","c1c6f69b":"pneumonia_dataset_path ='..\/input\/chest-xray-pneumonia\/chest_xray'","8cd91872":"basePath = os.path.sep.join([pneumonia_dataset_path, \"train\", \"NORMAL\"])\nimagePaths = list(paths.list_images(basePath))\n\n# randomly sample the image paths\nrandom.seed(42)\nrandom.shuffle(imagePaths)\nimagePaths = imagePaths[:samples]\n\n# loop over the image paths\nfor (i, imagePath) in enumerate(imagePaths):\n    # extract the filename from the image path and then construct the\n    # path to the copied image file\n    filename = imagePath.split(os.path.sep)[-1]\n    outputPath = os.path.sep.join([f\"{dataset_path}\/normal\", filename])\n\n    # copy the image\n    shutil.copy2(imagePath, outputPath)","3b842bcb":"def ceildiv(a, b):\n    return -(-a \/\/ b)\n\ndef plots_from_files(imspaths, figsize=(10,5), rows=1, titles=None, maintitle=None):\n    \"\"\"Plot the images in a grid\"\"\"\n    f = plt.figure(figsize=figsize)\n    if maintitle is not None: plt.suptitle(maintitle, fontsize=10)\n    for i in range(len(imspaths)):\n        sp = f.add_subplot(rows, ceildiv(len(imspaths), rows), i+1)\n        sp.axis('Off')\n        if titles is not None: sp.set_title(titles[i], fontsize=16)\n        img = plt.imread(imspaths[i])\n        plt.imshow(img)","476c6831":"normal_images = list(paths.list_images(f\"{dataset_path}\/normal\"))\ncovid_images = list(paths.list_images(f\"{dataset_path}\/covid\"))","ea7b6aab":"normal_images","c0abec46":"covid_images","9f9552d6":"plots_from_files(normal_images, rows=5, maintitle=\"Normal X-ray images\")","02760fce":"plots_from_files(covid_images, rows=5, maintitle=\"Covid-19 X-ray images\")","e54ebe22":"# grab the list of images in our dataset directory, then initialize\n# the list of data (i.e., images) and class images\n\nprint(\"[INFO] loading images...\")\nimagePaths = list(paths.list_images(dataset_path))\n\ndata = []\nlabels = []\n\n# loop over the image paths\nfor imagePath in imagePaths:\n    # extract the class label from the filename\n    label = imagePath.split(os.path.sep)[-2]\n    # load the image, swap color channels, and resize it to be a fixed\n    # 224x224 pixels while ignoring aspect ratio\n    image = cv2.imread(imagePath)\n    image = cv2.cvtColor(image, cv2.IMREAD_GRAYSCALE)\n    image = cv2.resize(image, (224, 224))\n    # update the data and labels lists, respectively\n    image_np = (image).flatten()\n    data.append(image_np)\n    labels.append(label)\n    \n# convert the data and labels to NumPy arrays while scaling the pixel\n# intensities to the range [0, 1]\ndata_train = np.array(data) \/ 255\nlabels_train = np.array(labels)","4cceb7f1":"data","d050fba4":"len(data)","a3ab43c5":"labels","26a8e8b3":"len(labels)","03786e2d":"data_train","28763927":"labels_train","6d36e8e3":"# perform one-hot encoding on the labels\nlb = LabelBinarizer()\nlabels_train_y = lb.fit_transform(labels_train)\nlabels_train_cat = to_categorical(labels_train_y)\n\n# partition the data into training and testing splits using 80% of\n# the data for training and the remaining 20% for testing\n\n(X_train, X_test, y_train, y_test) = train_test_split(data, labels, test_size=0.20, stratify=labels, random_state=42)\n\n","fd655872":"X_train","bd8594ff":"y_train","b9915b04":"from sklearn.naive_bayes import GaussianNB\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import LinearSVC\nfrom sklearn.calibration import calibration_curve\n\n\n\n# Create classifiers\nlr = LogisticRegression(max_iter=10000)\ngnb = GaussianNB()\nsvc = LinearSVC(C=1.0, max_iter=10000)\nrfc = RandomForestClassifier()\n\n\n\n","e422a4f8":"LR_Model = lr.fit(X_train, y_train)\n","fe4cec29":"GNB_Model = gnb.fit(X_train, y_train)\n","b2be805e":"SVC_Model = svc.fit(X_train, y_train)\n","f7452d8e":"RFC_Model = rfc.fit(X_train, y_train)","1de260b7":"import pickle\n\nwith open('LR_model.pkl', 'wb') as f1:\n    pickle.dump(LR_Model,f1)\n    f1.close()\n\nwith open('GNB_model.pkl', 'wb') as f2:\n    pickle.dump(GNB_Model,f2)\n    f2.close()\n\nwith open('SVM_model.pkl', 'wb') as f3:\n    pickle.dump(SVC_Model,f3)\n    f3.close()\n\nwith open('RF_model.pkl', 'wb') as f4:\n    pickle.dump(RFC_Model,f4)\n    f4.close()\n\n\n    \n","6643a056":"from IPython.display import FileLink\n\nFileLink(r'LR_model.pkl')\n","a053030d":"FileLink(r'GNB_model.pkl')\n","a0218dc9":"FileLink(r'SVM_model.pkl')\n","d7bd5660":"FileLink(r'RF_model.pkl')","85ec141c":"from sklearn.metrics import accuracy_score\n\n\nLR_y_pred = LR_Model.predict(X_test)\nGNB_y_pred = GNB_Model.predict(X_test)\nSVC_y_pred = SVC_Model.predict(X_test)\nRFC_y_pred = RFC_Model.predict(X_test)\n\n\n# accuracy_score(y_true, y_pred)\n","82f213df":"LR_acc_sc = accuracy_score(y_test, LR_y_pred)\nLR_acc_sc","500181b6":"GNB_acc_sc = accuracy_score(y_test, GNB_y_pred)\nGNB_acc_sc","d19b779f":"SVC_acc_sc = accuracy_score(y_test, SVC_y_pred)\nSVC_acc_sc","b0bb19c0":"RFC_acc_sc = accuracy_score(y_test, RFC_y_pred)\nRFC_acc_sc","783963c5":"print('LogisticRegression score: %f' % LR_Model.score(X_test, y_test))\nprint('Naive Bayes score: %f' % GNB_Model.score(X_test, y_test))\nprint('SVM score: %f' % SVC_Model.score(X_test, y_test))\nprint('Random Forest score: %f' % RFC_Model.score(X_test, y_test))","39aac3f7":"import itertools","f61aa798":"def plot_confusion_matrix(cm, classes, normalize=False,title='Confusion matrix', cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    \n    plt.figure(figsize=(8,8), dpi=100)\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')\n    \n    savefilename = title+'.png'\n        \n    plt.savefig(savefilename)\n    ","25e1a0a1":"cm_plot_labels = ['covid -ve','covid +ve']","8df2b14d":"cm_lr = confusion_matrix(y_test, LR_y_pred)\nplot_confusion_matrix(cm=cm_lr, classes=cm_plot_labels, title='Logistic Regression Confusion Matrix')\n","e78f8fd7":"cm_nb = confusion_matrix(y_test, GNB_y_pred)\nplot_confusion_matrix(cm=cm_lr, classes=cm_plot_labels, title='Gaussian Naive Bayes Confusion Matrix')\n","f5b7fc77":"cm_svc = confusion_matrix(y_test, SVC_y_pred)\nplot_confusion_matrix(cm=cm_nb, classes=cm_plot_labels, title='Support Vector Machine Regression Confusion Matrix')\n","f927133a":"cm_rf = confusion_matrix(y_test, RFC_y_pred)\nplot_confusion_matrix(cm=cm_rf, classes=cm_plot_labels, title='Random Forest Confusion Matrix')\n","0cfe89df":"# #############################################################################\n# Plot calibration plots\n\nplt.figure(figsize=(10, 10))\nax1 = plt.subplot2grid((3, 1), (0, 0), rowspan=2)\nax2 = plt.subplot2grid((3, 1), (2, 0))\n\nax1.plot([0, 1], [0, 1], \"k:\", label=\"Perfectly calibrated\")\nfor clf, name in [(lr, 'Logistic'),\n                  (gnb, 'Naive Bayes'),\n                  (svc, 'Support Vector Classification'),\n                  (rfc, 'Random Forest')]:\n    clf.fit(X_train, y_train)\n    if hasattr(clf, \"predict_proba\"):\n        prob_pos = clf.predict_proba(X_test)[:, 1]\n    else:  # use decision function\n        prob_pos = clf.decision_function(X_test)\n        prob_pos = \\\n            (prob_pos - prob_pos.min()) \/ (prob_pos.max() - prob_pos.min())\n    fraction_of_positives, mean_predicted_value = \\\n        calibration_curve(y_test, prob_pos, n_bins=10)\n\n    ax1.plot(mean_predicted_value, fraction_of_positives, \"s-\",\n             label=\"%s\" % (name, ))\n\n    ax2.hist(prob_pos, range=(0, 1), bins=10, label=name,\n             histtype=\"step\", lw=2)\n\nax1.set_ylabel(\"Fraction of positives\")\nax1.set_ylim([-0.05, 1.05])\nax1.legend(loc=\"lower right\")\nax1.set_title('Calibration plots  (reliability curve)')\n\nax2.set_xlabel(\"Mean predicted value\")\nax2.set_ylabel(\"Count\")\nax2.legend(loc=\"upper center\", ncol=2)\n\nplt.tight_layout()\nplt.show()\n","d77e545b":"\n\ntest_image = cv2.imread('..\/input\/covid-chest-xray\/images\/1-s2.0-S1684118220300608-main.pdf-002.jpg')\ntest_image = cv2.cvtColor(test_image, cv2.IMREAD_GRAYSCALE)\ntest_image = cv2.resize(test_image, (224, 224))\ntest_img = test_image.flatten().reshape(1, -1)\n\n\nLR_pred = LR_Model.predict(test_img)\nprint(LR_pred)\n\nGNB_pred = GNB_Model.predict(test_img)\nprint(GNB_pred)\n\nSVC_pred = SVC_Model.predict(test_img)\nprint(SVC_pred)\n\nRFC_pred = RFC_Model.predict(test_img)\nprint(RFC_pred)\n\n","330e57ea":"\n\ntest_image = cv2.imread('..\/input\/chest-xray-pneumonia\/chest_xray\/test\/NORMAL\/IM-0003-0001.jpeg')\ntest_image = cv2.cvtColor(test_image, cv2.IMREAD_GRAYSCALE)\ntest_image = cv2.resize(test_image, (224, 224))\ntest_img = test_image.flatten().reshape(1, -1)\n\n\nLR_pred = LR_Model.predict(test_img)\nprint(LR_pred)\n\nGNB_pred = GNB_Model.predict(test_img)\nprint(GNB_pred)\n\nSVC_pred = SVC_Model.predict(test_img)\nprint(SVC_pred)\n\nRFC_pred = RFC_Model.predict(test_img)\nprint(RFC_pred)\n\n","449b252a":"# Metrics","d08308d6":"## Build Dataset","20d68d95":"Helper function to plot the images in a grid","d6e10cbc":"Test on normal image:","3487829a":"# FIT MODELS","f40f003f":"### Covid xray dataset","374bd586":"## Comparison of Calibration of Classifiers","dba05e35":"Test on covid image:","fb4f0827":"> \/opt\/conda\/lib\/python3.7\/site-packages\/sklearn\/svm\/_base.py:977: ConvergenceWarning: Liblinear failed to converge, increase the number of iterations.\n>   \"the number of iterations.\", ConvergenceWarning)","c11e1058":"## Plot x-rays","5779a372":"### Build normal xray dataset","d1a0d8e7":"## Data preprocessing","923c93a5":"# Now save the model","d73546ab":"# Confusion Matrix"}}