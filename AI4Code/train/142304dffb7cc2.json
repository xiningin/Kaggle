{"cell_type":{"6a727474":"code","98e3d7e3":"code","1789da7b":"code","6c0a29f8":"code","808453b6":"code","a729f440":"code","ef5496bd":"code","6dd1e0f8":"code","1f201beb":"code","7216effc":"code","f15f26d5":"code","e612dbbb":"code","90e6d9eb":"code","ac6babe5":"code","4e1579a2":"code","cd3df438":"code","06052600":"code","74ca5839":"code","c8bfc29f":"code","ae706fe2":"code","b712d842":"code","edb86858":"code","78485731":"code","15ab9cb5":"code","6153b3c4":"code","885672d3":"code","e72ac218":"code","95bc704f":"code","a0ca89ce":"code","89f7cd86":"code","6fffadb5":"code","8b79862c":"code","693021cd":"code","ad3d16e4":"code","24ac7b43":"code","6c1e36cf":"code","f9c43f56":"code","4c64df33":"code","9d68923d":"code","c1a20817":"code","972dde3a":"code","f5b8e7e9":"code","d059e065":"code","008038ab":"markdown","4b636fd5":"markdown","76784988":"markdown","89d1e86c":"markdown","432fd46b":"markdown","38f3ebe0":"markdown","563d3448":"markdown","b61ac354":"markdown","e71d3434":"markdown","4111c76b":"markdown","34b7d866":"markdown","00dc0467":"markdown","119a2a86":"markdown","e33f50f0":"markdown"},"source":{"6a727474":"import os\nprint(os.listdir(\"..\/input\"))","98e3d7e3":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)","1789da7b":"!pip install git+https:\/\/github.com\/fastai\/fastai2 \nfrom fastai2.vision.all import *","6c0a29f8":"! pip install efficientnet-pytorch -q\nfrom efficientnet_pytorch import EfficientNet","808453b6":"# train and test csv\n\ntrain = pd.read_csv(\"..\/input\/uploaded-dataset\/train.csv\")\ntest = pd.read_csv(\"..\/input\/uploaded-dataset\/test.csv\")\n\n\n# paths leading to images\ntrain_path = Path(\"..\/input\/uploaded-dataset\/train\/train\")\ntest_path = Path(\"..\/input\/uploaded-dataset\/test\/test\")","a729f440":"# add the category to filename for easier usage with fastai API\ntrain['filename'] = train.apply(lambda x: str(x.category).zfill(2) + '\/' + x.filename, axis=1)\ntrain","ef5496bd":"# train in a 10% subset of the data\n# to speed up experimentation\n# comment these lines out to increase accuracy (but necessitates longer training time)\n\n\n# from sklearn.model_selection import train_test_split\n# _, train = train_test_split(train, test_size=0.05, stratify=train.category)","6dd1e0f8":"#Run this to see base augmentation\n# aug_transforms??","1f201beb":"#Run this to see base normalization\n# Normalize.from_stats??","7216effc":"item_tfms = [RandomResizedCrop(299, min_scale=0.75)] #before 224 not 456\nbatch_tfms = [*aug_transforms(), Normalize.from_stats(*imagenet_stats)]\ndef get_dls_from_df(df):\n    df = df.copy()\n    options = {\n        \"item_tfms\": item_tfms,\n        \"batch_tfms\": batch_tfms,\n        \"bs\": 32,\n    }\n    dls = ImageDataLoaders.from_df(df, train_path, **options)\n    return dls","f15f26d5":"dls = get_dls_from_df(train)\n# dls.show_batch()","e612dbbb":"# pretrained models https:\/\/www.kaggle.com\/mhiro2\/pytorch-pretrained-models (model)\n# https:\/\/stackoverflow.com\/questions\/42703500\/best-way-to-save-a-trained-model-in-pytorch (load model)\n# https:\/\/github.com\/Cadene\/pretrained-models.pytorch#inception","90e6d9eb":"import torch\nimport torchvision","ac6babe5":"!pip install pretrainedmodels","4e1579a2":"import pretrainedmodels\nprint(pretrainedmodels.model_names)","cd3df438":"model_name = 'inceptionv4' # could be fbresnet152 or inceptionresnetv2\nmodel = pretrainedmodels.__dict__[model_name](num_classes=1000, pretrained='imagenet')","06052600":"# model = EfficientNet.from_pretrained(\"efficientnet-b5\")\nhead = nn.Sequential(\n    AdaptiveConcatPool2d(),\n    Flatten(),\n    nn.BatchNorm1d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True),\n    nn.Dropout(p=0.25),\n    nn.Linear(in_features=1024, out_features=512,bias = True),\n    nn.ReLU(inplace=True),\n    nn.BatchNorm1d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True),\n    nn.Dropout(p=0.5),\n    nn.Linear(in_features=512, out_features=42)\n)\nlearn = Learner(dls, model, metrics=accuracy, custom_head = head)\nlearn.model_dir =  Path('..')\nprint(learn.model_dir)\nlearn = learn.load('\/kaggle\/input\/modelssss\/inceptionv4  2 epoch v2')","74ca5839":"# base_lr = 2e-3\n# learn.freeze()\n# learn.fit_one_cycle(2,slice(base_lr), pct_start=0.99)\n\n# test_images = test.filename.apply(lambda fn: test_path\/fn)\n# test_dl = dls.test_dl(test_images)\n\n# preds = learn.get_preds(dl=test_dl, with_decoded=True)\n# preds\n\n# # save raw predictions\n# torch.save(preds, \"rawpreds\")\n\n# submission  = test[[\"filename\"]]\n# submission[\"category\"] = preds[2]\n\n\n# # zero-pad the submissions\n# submission[\"category\"] = submission.category.apply(lambda c: str(c).zfill(2))\n\n# # save the submissions as CSV\n# submission.to_csv(\"submission_one_cycle.csv\")\n\n\n# learn.export(Path(\"\/kaggle\/working\/export_one_cycle.pkl\"))\n# learn.model_dir='\/kaggle\/working\/'\n# learn.save('model_one_cycle')","c8bfc29f":"learn.unfreeze()\nlearn.fit_one_cycle(2)\n\ntest_images = test.filename.apply(lambda fn: test_path\/fn)\ntest_dl = dls.test_dl(test_images)\n\npreds = learn.get_preds(dl=test_dl, with_decoded=True)\npreds\n\n# save raw predictions\ntorch.save(preds, \"rawpreds\")\n\nsubmission  = test[[\"filename\"]]\nsubmission[\"category\"] = preds[2]\n\n\n# zero-pad the submissions\nsubmission[\"category\"] = submission.category.apply(lambda c: str(c).zfill(2))\n\n# save the submissions as CSV\nsubmission.to_csv(\"submission_two_cycle.csv\")\n\n\nlearn.export(Path(\"\/kaggle\/working\/export_two_cycle.pkl\"))\nlearn.model_dir='\/kaggle\/working\/'\nlearn.save('model_two_cycle')","ae706fe2":"with open('inceptionv4v2_final_pred.pkl', 'wb') as f:\n    pickle.dump(preds[0], f)","b712d842":"# learn.unfreeze()\n# learn.fit_one_cycle(1)\n\n# test_images = test.filename.apply(lambda fn: test_path\/fn)\n# test_dl = dls.test_dl(test_images)\n\n# preds = learn.get_preds(dl=test_dl, with_decoded=True)\n# preds\n\n# # save raw predictions\n# torch.save(preds, \"rawpreds\")\n\n# submission  = test[[\"filename\"]]\n# submission[\"category\"] = preds[2]\n\n\n# # zero-pad the submissions\n# submission[\"category\"] = submission.category.apply(lambda c: str(c).zfill(2))\n\n# # save the submissions as CSV\n# submission.to_csv(\"submission_one_cycle.csv\")\n\n\n# learn.export(Path(\"\/kaggle\/working\/export_one_cycle.pkl\"))\n# learn.model_dir='\/kaggle\/working\/'\n# learn.save('model_one_cycle')","edb86858":"# learn.fit_one_cycle(1)\n\n# test_images = test.filename.apply(lambda fn: test_path\/fn)\n# test_dl = dls.test_dl(test_images)\n\n# preds = learn.get_preds(dl=test_dl, with_decoded=True)\n# preds\n\n# # save raw predictions\n# torch.save(preds, \"rawpreds\")\n\n# submission  = test[[\"filename\"]]\n# submission[\"category\"] = preds[2]\n\n\n# # zero-pad the submissions\n# submission[\"category\"] = submission.category.apply(lambda c: str(c).zfill(2))\n\n# # save the submissions as CSV\n# submission.to_csv(\"submission_two_cycle.csv\")\n\n\n# learn.export(Path(\"\/kaggle\/working\/export_two_cycle.pkl\"))\n# learn.model_dir='\/kaggle\/working\/'\n# learn.save('model_two_cycle')","78485731":"# learn.fit_one_cycle(1)\n\n# test_images = test.filename.apply(lambda fn: test_path\/fn)\n# test_dl = dls.test_dl(test_images)\n\n# preds = learn.get_preds(dl=test_dl, with_decoded=True)\n# preds\n\n# # save raw predictions\n# torch.save(preds, \"rawpreds\")\n\n# submission  = test[[\"filename\"]]\n# submission[\"category\"] = preds[2]\n\n\n# # zero-pad the submissions\n# submission[\"category\"] = submission.category.apply(lambda c: str(c).zfill(2))\n\n# # save the submissions as CSV\n# submission.to_csv(\"submission_three_cycle.csv\")\n\n\n# learn.export(Path(\"\/kaggle\/working\/export_three_cycle.pkl\"))\n# learn.model_dir='\/kaggle\/working\/'\n# learn.save('model_three_cycle')","15ab9cb5":"##Maybe try stratified Kfold https:\/\/www.kaggle.com\/muellerzr\/resnet152-with-tta-and-fine-tune-fastai2 ","6153b3c4":"\n\n# learn = cnn_learner(dls, resnet34, metrics=accuracy)\n# learn.fine_tune(2)\n# learn.fit(4)\n# learn.fit_one_cycle(4)","885672d3":"\"\"\"\n\ndef fine_tune(self:Learner, epochs, base_lr=2e-3, freeze_epochs=1, lr_mult=100,\n              pct_start=0.3, div=5.0, **kwargs):\n    \"Fine tune with `freeze` for `freeze_epochs` then with `unfreeze` from `epochs` using discriminative LR\"\n    self.freeze()\n    self.fit_one_cycle(freeze_epochs, slice(base_lr), pct_start=0.99, **kwargs)\n    base_lr \/= 2\n    self.unfreeze()\n    self.fit_one_cycle(epochs, slice(base_lr\/lr_mult, base_lr), pct_start=pct_start, div=div, **kwargs)\n    \n    \n\"\"\"","e72ac218":"# model = EfficientNet.from_pretrained(\"efficientnet-b5\")\n# num_ftrs = model._fc.in_features\n\n\n# model._fc = nn.Sequential(nn.Linear(num_ftrs, 1000),\n#                               nn.ReLU(),\n#                              \"\" nn.Dropout(),\n#                               nn.Linear(1000, dls.c))","95bc704f":"# head = nn.Sequential(\n#     AdaptiveConcatPool2d(),\n#     Flatten(),\n#     nn.BatchNorm1d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True),\n#     nn.Dropout(p=0.25),\n#     nn.Linear(in_features=1024, out_features=512,bias = True),\n#     nn.ReLU(inplace=True),\n#     nn.BatchNorm1d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True),\n#     nn.Dropout(p=0.5),\n#     nn.Linear(in_features=512, out_features=42)\n# )\n# learn = Learner(dls, model, metrics=accuracy, custom_head = head)\n# learn.fine_tune(epochs = 2, freeze_epochs = 2)","a0ca89ce":"# interp = ClassificationInterpretation.from_learner(learn)","89f7cd86":"# interp.plot_confusion_matrix(figsize=(15,15), dpi=60)","6fffadb5":"# get the most confused labels with at least 10 incorrect predictions\n# interp.most_confused(10)","8b79862c":"test_images = test.filename.apply(lambda fn: test_path\/fn)\ntest_dl = dls.test_dl(test_images)","693021cd":"#https:\/\/www.kaggle.com\/muellerzr\/resnet152-with-tta-and-fine-tune-fastai2 fastai tta\ny,_ = learn.tta(dl = test_dl)","ad3d16e4":"final_predictions_tta = []\nfor i in range(y.shape[0]):\n    final_predictions_tta.append(y[i].argmax().tolist())\nfinal_predictions_tta","24ac7b43":"preds = learn.get_preds(dl=test_dl, with_decoded=True)\npreds","6c1e36cf":"count = 0\nfor idx,p in enumerate(final_predictions_tta):\n    if p == preds[2][idx]:\n        count+=1\nprint(count)","f9c43f56":"len(final_predictions)","4c64df33":"# save raw predictions\ntorch.save(preds, \"rawpreds\")","9d68923d":"submission  = test[[\"filename\"]]\nsubmission[\"category\"] = preds[2]","c1a20817":"# zero-pad the submissions\nsubmission[\"category\"] = submission.category.apply(lambda c: str(c).zfill(2))","972dde3a":"# preview\nsubmission","f5b8e7e9":"# save the submissions as CSV\nsubmission.to_csv(\"submission.csv\")","d059e065":"learn.export(Path(\"\/kaggle\/working\/export.pkl\"))\nlearn.model_dir='\/kaggle\/working\/'\nlearn.save('model')","008038ab":"This is a simple starter notebook for this challenge using the fastai2 library. \n\nAs someone new to Deep Learning, I know how hard it is just to setup a working pipeline. Therefore, this is just a simple demonstraation of how you might do a whole pipeline from loading data until generating submissions.\n\nFeel free to modify and improve on this code.\n\n*PS: you might be able to get 0.6 - 0.7 accuracy using this (even more when training with the whole dataset, not just 10% like below and also training for more epochs)*","4b636fd5":"* preds[0] -> probabilities\n* preds[1] -> ground truth (None in this case as we are training on the test set)\n* preds[2] -> decoded probabilities AKA our category\/label predictions","76784988":"# ----------------------------------","89d1e86c":"# Continue Training","432fd46b":"Plot confusion matrix to see how well our model classify specific categories.","38f3ebe0":"## Modeling, Training and Interpretation","563d3448":"## Submission","b61ac354":"# Read more about fastai\n# Fine-tune: https:\/\/github.com\/fastai\/fastai2\/blob\/master\/fastai2\/callback\/schedule.py#L151\n# Fine-tune: https:\/\/github.com\/enzokro\/clck10\/blob\/5a3f9c0657ff282e906a225e836f8b0d49aca292\/_notebooks\/2020-03-25-fastaiFineTune.ipynb\n# Pipeline (\u0e44\u0e17\u0e22) https:\/\/github.com\/gnoparus\/bualabs\/blob\/master\/nbs\/01i_image_classification_pets_fastai2.ipynb\n# Stratified KFold : https:\/\/www.kaggle.com\/muellerzr\/resnet152-with-tta-and-fine-tune-fastai2 \n\n","e71d3434":"## Loading Data","4111c76b":"We need to then zero-pad the submissions ('01' instead of '1').","34b7d866":"We load the images easily using fastai2's API. We then crop and resize the image to 224x224 (the size the pre-trained model we will use was trained on) and then do some basic data augmentation and normalization (to ImageNet stats)","00dc0467":"Create Test Dataloader from an existing dataloader (so that you can do TTA if you want to) .","119a2a86":"Use a pretrained ResNet-34 model. Training is done in 2 steps:\n* Train only our custom head(42 classes) for 1 epoch\n* Train the whole thing for another epoch\n\nYou can definitely train for more than these 2 epochs to get better accuracy. Using bigger models will help too.","e33f50f0":"## Predictions"}}