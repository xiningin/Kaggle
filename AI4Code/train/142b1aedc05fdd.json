{"cell_type":{"7332bd2c":"code","eb367214":"code","e7a8b827":"code","db187588":"code","229e064d":"code","2dd9975e":"code","922d360f":"code","44f7c0fc":"code","25d1c54b":"code","e0392952":"code","10fe7548":"code","4ccbd9d4":"code","162865b5":"code","8db9ec48":"code","7474d380":"code","4e973cda":"code","a94de414":"code","6cd16a20":"code","824d077a":"markdown","6f032ae3":"markdown","9bf35da4":"markdown","9caa47f0":"markdown","95cc52a9":"markdown","8a626785":"markdown","20e034b5":"markdown","b9b48c67":"markdown","33905ccc":"markdown","1899f457":"markdown","243a160d":"markdown"},"source":{"7332bd2c":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","eb367214":"#importing libraries\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler","e7a8b827":"#Loading the Data Set\ndf =pd.read_csv('\/kaggle\/input\/telco-customer-churn\/WA_Fn-UseC_-Telco-Customer-Churn.csv')","db187588":"df.head()","229e064d":"df.shape","2dd9975e":"df.info()","922d360f":"#Sum of missing observations in the data set\ndf.isnull().sum()","44f7c0fc":"#Descriptive statistics of the dataset\ndf.describe().T","25d1c54b":"#type change\ndf['TotalCharges'] = pd.to_numeric(df['TotalCharges'],errors='coerce')","e0392952":"#Giving new values to the \"Contract\" variable\n\ndf[\"Contract\"].replace(\"Month-to-month\",1,inplace=True)\ndf[\"Contract\"].replace(\"One year\",12,inplace=True)\ndf[\"Contract\"].replace(\"Two year\",24,inplace=True)\ndf[\"Contract\"] = df[\"Contract\"].astype(int)","10fe7548":"df[\"new_totalcharges\"]=df[\"MonthlyCharges\"]*df[\"Contract\"]\ndf[[\"new_totalcharges\",\"TotalCharges\"]].head()","4ccbd9d4":"#Number of transactions\ndf[\"Transection\"]=df[\"TotalCharges\"]\/df[\"MonthlyCharges\"]\ndf['Transection']=round( df['Transection'],0)","162865b5":"\n#Customer Lifetime Value calculation\n\ndef cltv_c(dataframe, profit=0.10):\n\n    cltv_c = dataframe.groupby('customerID').agg({'Contract': lambda x: x.sum(),\n                                                   'Transection': lambda x: x.sum(),\n                                                   'TotalCharges': lambda x: x.sum()})\n\n    cltv_c.columns = ['total_transaction', 'total_unit', 'total_price']\n\n    # Avg_order_value\n    cltv_c['avg_order_value'] = cltv_c['total_price'] \/ cltv_c['total_transaction']\n\n    # Purchase_Frequency\n    cltv_c[\"purchase_frequency\"] = cltv_c['total_transaction'] \/ cltv_c.shape[0]\n\n    # Repeat rate & Churn rate\n    repeat_rate = cltv_c[cltv_c.total_transaction > 1].shape[0] \/ cltv_c.shape[0]\n    churn_rate = 1 - repeat_rate\n\n    # Profit_margin\n    cltv_c['profit_margin'] = cltv_c['total_price'] * profit\n\n    # Customer Value\n    cltv_c['customer_value'] = (cltv_c['avg_order_value'] * cltv_c[\"purchase_frequency\"])\n\n    # Customer Lifetime Value\n    cltv_c['cltv'] = (cltv_c['customer_value'] \/ churn_rate) * cltv_c['profit_margin']\n\n    scaler = MinMaxScaler(feature_range=(0, 1))\n    scaler.fit(cltv_c[[\"cltv\"]])\n    cltv_c[\"scaled_cltv\"] = scaler.transform(cltv_c[[\"cltv\"]])\n\n    # Segment\n    cltv_c[\"segment\"] = pd.qcut(cltv_c[\"scaled_cltv\"], 4, labels=[\"D\", \"C\", \"B\", \"A\"])\n\n    return cltv_c\n\nfinal_df = cltv_c(df)","8db9ec48":"final_df.reset_index().head()","7474d380":"#averages of scaled_cltv in segment breakdown\nfinal_df.groupby(\"segment\").agg({\"scaled_cltv\": \"mean\"})","4e973cda":"#Number of customers in group A segment\nfinal_df[final_df[\"segment\"]==\"A\"].shape","a94de414":"#Number of customers in group D segment\nfinal_df[final_df[\"segment\"]==\"D\"].shape","6cd16a20":"#number of customers with churn in the dataset\ndf[df[\"Churn\"]==\"Yes\"].shape","824d077a":"Customer Lifetime Value :It is the monetary value that a customer will bring to this company during her\/his relationship-communication with a company.","6f032ae3":"# Telco Customer- Customer Lifetime Value ","9bf35da4":"Purpose: to find its value in the company by comparing the behavior of all customers in our company and considering the buying habits of a single customer.","9caa47f0":"# Conclusion","95cc52a9":"# Customer Lifetime Value calculation","8a626785":"# General information about the dataset\n","20e034b5":"![](https:\/\/unscrambl.com\/wp-content\/uploads\/2021\/02\/Capture3-1536x953.png)","b9b48c67":"Churn refers to the number of customers that the business lost in a period.","33905ccc":"I thought that when we multiply the monthly amount collected from the customer and the contract period of the customer, we can find the total amount to be paid.I created a new variable called \u201cnew_totalcharges\u201d.When I compared this new variable with the \u201cTotalCharges\u201d variable, I saw that the two were different.","1899f457":"Customers in segment A have the highest returns.","243a160d":"\nWe divided our customers into segments by making a sorting according to the CLTV values \u200b\u200bto be calculated for each customer and by dividing at certain points according to the CLTV values \u200b\u200band creating groups."}}