{"cell_type":{"40dab185":"code","34bf262a":"code","5920a34d":"code","b7b6e496":"code","8cb949a6":"code","9dec7cff":"code","cc52d76f":"code","ba4ffec3":"code","6b45149b":"code","e26381c7":"code","b1687fcd":"code","9102a5d7":"code","615f3ff2":"code","35249d6c":"code","27efe438":"markdown","49504cb0":"markdown","3ce91fe8":"markdown","7f39c956":"markdown","0a802323":"markdown","a91d71d4":"markdown","eb9223e8":"markdown","286037ad":"markdown"},"source":{"40dab185":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\nimport os\nfrom tqdm.notebook import tqdm\nfrom scipy.integrate import solve_ivp\nimport numpy\nimport datetime\nfrom datetime import timedelta\nfrom matplotlib import dates\nimport plotly.graph_objects as go\nfrom scipy.optimize import minimize\nfrom sklearn.metrics import mean_squared_log_error, mean_squared_error\nfrom plotly.subplots import make_subplots\nimport plotly.express as px\nimport plotly.offline as ply\nply.init_notebook_mode(connected=True)\n\n#%matplotlib inline","34bf262a":"train = pd.read_csv('..\/input\/novel-corona-virus-2019-dataset\/covid_19_data.csv') \ntrain['Date_datetime'] = train['ObservationDate'].apply(lambda x: (datetime.datetime.strptime(x, \"%m\/%d\/%Y\"))) \npop_info = pd.read_csv('\/kaggle\/input\/covid19-population-data\/population_data.csv') ","5920a34d":"train.tail(25)","b7b6e496":"train = train.rename(columns={'Country\/Region': 'Country_Region', 'Confirmed': 'ConfirmedCases', 'Deaths': 'Fatalities', 'Province\/State': 'Province_State'})\n","8cb949a6":"train = train.query(\"Province_State != 'Faroe Islands'\")\ntrain = train.query(\"Province_State != 'Greenland'\")\ntrain = train.query('ConfirmedCases > 1').copy() \n","9dec7cff":"denmark = train[train['Country_Region']=='Denmark']\nfig = go.Figure()\nfig.update_layout(width=800, height=500)\nfig.add_trace(go.Scatter(x=denmark['Date_datetime'], \n                         y=denmark['ConfirmedCases'],name=\"Confirmed Cases\"))\nfig.add_trace(go.Scatter(x=denmark['Date_datetime'], \n                         y=denmark['Fatalities'],name=\"Fatalities\"))\nfig.update_layout(template='seaborn',title=\"Dataset\")\nfig.show()","cc52d76f":"def seir_d(t, y, N, beta, rho, alpha, theta): \n    S, E, I, R, D = y\n    if callable(beta) == True :\n        dSdt = -beta(t) * S * I \n        dEdt = beta(t) * S * I  - alpha * E\n    else : \n        dSdt = -beta * S * I \n        dEdt = beta  * S * I - alpha * E\n    dIdt = alpha * E -(rho+theta\/(1-theta)*rho) * I\n    dRdt = rho * I\n    dDdt = theta \/ (1-theta) * rho * I\n    \n    return dSdt, dEdt, dIdt, dRdt, dDdt","ba4ffec3":"def model_decay(params, data, population, return_solution=False, full_validation=True, forecast_days=0):\n    R_0, theta, k, L, R_t, D_rec, D_inc = params # R_0, fatality rate, k form, L shape, R end\n    N = population # Population of each country\n    \n    n_infected = data['ConfirmedCases'].iloc[0] \n    n_recovered = data['Recovered'].iloc[0]\n    n_dead = data['Fatalities'].iloc[0]\n    max_days = len(data) + forecast_days \n    rho = 1.0 \/ D_rec\n    alpha = 1.0 \/ D_inc    \n    \n    y0 = N - n_infected, 0, n_infected, 0 ,0  \n\n    def beta(t):\n        return (((R_0-R_t) \/ (1 + (t\/L)**k)+R_t) * rho ) \/ N\n\n    t = np.arange(max_days)\n\n    # Solve the SEIR differential equation.\n    sol = solve_ivp(seir_d, [0, max_days],y0,  args=(N, beta, rho, alpha, theta),t_eval=t)\n    sus, exp, inf, rec, dead = sol.y    \n        \n    # Predict confirmedcases\n    y_pred_cases = inf + rec + dead\n    y_true_cases = data['ConfirmedCases'].values\n    \n    # Predict fatalities\n    y_pred_dead = dead\n    y_true_dead = data['Fatalities'].values    \n \n    \n    optim_days = 20 # Days to optimise for\n\n    #weights = 1 \/ np.arange(1, optim_days+1)[::-1]  # Recent data is more heavily weighted\n    #weights = np.linspace(0,1,20)\n    # using mean squre log error to evaluate\n    msle_conf = mean_squared_log_error(y_true_cases[-optim_days:], y_pred_cases[-optim_days:])\n    msle_dead = mean_squared_log_error(y_true_dead[-optim_days:], y_pred_dead[-optim_days:])\n    if full_validation == True :\n        msle = np.mean([msle_conf,msle_dead])\n    else : \n        msle = msle_conf\n        \n    if return_solution:\n        return sol\n    else:\n        return msle","6b45149b":"# Use a constant reproduction number\ndef model_const(params, data, population, return_solution=False, full_validation=True, forecast_days=0):\n    R_0_start, theta, D_rec, D_inc = params # Paramaters, R0 and alpha \n    N = population # Population of each country\n    \n    n_infected = data['ConfirmedCases'].iloc[0] \n    n_recovered = data['Recovered'].iloc[0]\n    n_dead = data['Fatalities'].iloc[0]    \n    max_days = len(data) + forecast_days # How many days want to predict\n    rho = 1.0 \/ D_rec\n    alpha = 1.0 \/ D_inc    \n    beta = (R_0_start * rho)\/N   # R_0 = beta \/ Rho\n    \n    S0, E0, I0, R0, D0 = N - n_infected, 0, n_infected, 0 ,0  \n    y0 = S0, E0, I0, R0, D0 # Initial conditions vector\n\n    t = np.arange(max_days)\n\n    # Solve the SEIR differential equation.\n    sol = solve_ivp(seir_d, [0, max_days],y0,  args=(N, beta, rho, alpha, theta),t_eval=t)\n    sus, exp, inf, rec, dead = sol.y    \n        \n    # Predict confirmedcases\n    y_pred_cases = inf + rec + dead\n    y_true_cases = data['ConfirmedCases'].values \n\n    # Predict fatalities\n    y_pred_dead = dead\n    y_true_dead = data['Fatalities'].values    \n    \n    optim_days = 20  # Days to optimise for finds the lowest num. \n\n    weights = 1 \/ np.arange(1, optim_days+1)[::-1]  # Recent data is more heavily weighted\n    # using mean squre log error to evaluate\n        \n    msle_conf = mean_squared_log_error(y_true_cases[-optim_days:], y_pred_cases[-optim_days:])\n    msle_dead = mean_squared_log_error(y_true_dead[-optim_days:], y_pred_dead[-optim_days:])\n    \n    if full_validation == True :\n        msle = np.mean([msle_conf,msle_dead])\n    else : \n        msle = msle_conf\n\n    if return_solution:\n        return sol\n    else:\n        return msle","e26381c7":"def fit_seir_model(data, country, forecast_days = 14, make_plot = True, validation = True, full_validation = True, decay_mode = None):\n    country_data = data[data['Country_Region'] == country]\n    country_data = country_data.query('ConfirmedCases > 0').copy() \n        \n    # Train - test split\n    x = 2 ## Validation days.\n    if validation : # \n        valid_data = country_data[-x:].copy() ##\n        train_data = country_data[:-x].copy() ## \n    else : \n        valid_data = country_data.copy() ## \n        train_data = country_data.copy() ## k\n    \n    # \n    try:\n        population = pop_info[pop_info['Name']==country]['Population'].tolist()[0]\n    except IndexError:\n        print ('country not in population set, '+str(country))\n            \n    n_infected = train_data['ConfirmedCases'].iloc[0]\n        \n    # \n    \n    #  R_0, theta, D_rec, D_inc\n    model_const_res = minimize(model_const, [1.8, 0.04,15,4.9], \n                        bounds=((0, 6.49), (0.01, 0.15),(3.48,18),(4.9,5.9)),\n                        args=(train_data, population, False,full_validation),\n                        method='L-BFGS-B')\n    \n    # R_0, fatality rate, k form, L shape, Rt end, D_rec, D_inc\n    model_decay_res = minimize(model_decay, [1.8, 0.04, 2, 20, 1 ,15, 4.9], \n                    bounds=((0, 6.49), (0.01, 0.15), (0, 5), (0, 200),(0,6.49),(3.48,18),(4.9,5.9)),\n                    args=(train_data, population, False,full_validation),\n                    method='L-BFGS-B')\n    \n\n    test_end = train['Date_datetime'].max() \n    train_min = train_data.Date_datetime.min()\n    train_max = train_data.Date_datetime.max()\n    test_period =(test_end - train_max).days \n    \n    dates_all = pd.to_datetime(np.arange(train_min, test_end+timedelta(1)+timedelta(forecast_days), dtype='datetime64[D]'))\n    \n    \n    print(f'msle: model_const_res {model_const_res.fun:0.5f}  model_decay_res {model_decay_res.fun:0.5f}')\n\n    if model_decay_res.fun < model_const_res.fun :\n        sol = model_decay(model_decay_res.x, train_data, population, True,full_validation, test_period+forecast_days)\n        res = model_decay_res\n        R_0,alpha,k,L,R_t, D_rec, D_inc = res.x\n        sus, exp, inf, rec, dead = sol.y\n   \n        t = np.arange(len(dates_all))\n        R_t = pd.Series((R_0-R_t) \/ (1 + (t\/L)**k) + R_t, dates_all)\n        R_t_median = pd.Series(np.median(R_t), dates_all)\n        print(f'R_0_start {res.x[0]:0.5f} theta {res.x[1]:0.5f} k {res.x[2]:0.5f} L {res.x[3]:0.5f} R_t_end {res.x[4]:0.5f} D_rec {res.x[5]:0.5f} D_inc {res.x[6]:0.5f}')\n        if validation : \n            valid_msle = model_decay_res.fun\n        else :\n            valid_msle = 0\n    else :\n        sol = model_const(model_const_res.x, train_data, population, True,full_validation, test_period+forecast_days)\n        res = model_const_res\n        R_0_start, alpha, D_rec, D_inc = res.x\n        sus, exp, inf, rec, dead = sol.y\n      \n        t = np.arange(len(dates_all))\n        R_t = pd.Series([model_const_res.x[0]] * len(dates_all), dates_all)\n        print(f'using constant r0 {res.x[0]:0.5f} theta {res.x[1]:0.5f} D_rec {res.x[2]:0.5f} D_inc {res.x[3]:0.5f}')\n        if validation : \n            valid_msle = model_decay_res.fun\n        else :\n            valid_msle = 0\n\n\n    y_pred = pd.DataFrame({\n        'ConfirmedCases': np.diff((inf + (rec + dead) ),prepend=0).cumsum(),\n        'Recovered': np.around(rec,0),\n        'Fatalities': np.around(dead,0),\n        'R': R_t,\n    })\n    \n \n    y_pred_valid = y_pred.iloc[len(train_data):len(train_data)+len(valid_data)]\n\n    y_true_valid = valid_data[['ConfirmedCases']]\n    y_true_valid3 = valid_data[['Fatalities']]\n\n    msle_val_conf = mean_squared_log_error(y_true_valid['ConfirmedCases'].values, y_pred_valid['ConfirmedCases'][:len(train_data)].values)\n    msle_val_death = mean_squared_log_error(y_true_valid3['Fatalities'].values, y_pred_valid['Fatalities'][:len(train_data)].values)\n    msle_val = np.mean([msle_val_conf,msle_val_death])\n    print('msle_validation ' + str(msle_val))\n    \n\n\n\n    if make_plot:\n        print(f'Validation MSLE: {valid_msle:0.5f}, Median R over perioden: {R_t.median():0.5f}, Raten for fatale tilf\u00e6lde: {res.x[1]:0.5f} ')\n        \n        fig = make_subplots(specs=[[{\"secondary_y\": True}]])\n        \n        fig.add_trace(\n            go.Scatter(x=dates_all, y=np.around(exp,0),line_color=\"coral\", name=\"Eksponerede\"),\n            secondary_y=False,\n        )\n        fig.add_trace(\n            go.Scatter(x=dates_all, y=np.around(inf,0),line_color=\"indianred\", name=\"Infekti\u00f8se\"),\n            secondary_y=False,\n        )\n        fig.add_trace(\n            go.Scatter(x=dates_all, y=np.around(rec,0),line_color=\"mediumseagreen\", name=\"Raske\"),\n            secondary_y=False,\n        )\n        fig.add_trace(\n            go.Scatter(x=dates_all, y=np.around(dead,0), name=\"D\u00f8de\",line=dict(color='black', width=2)),\n            secondary_y=False,\n        )\n        fig.add_trace(\n            go.Scatter(x=dates_all, y=R_t, name=\"R\",line=dict(color='cyan', width=2, dash='dash')),\n            secondary_y=True,\n        )\n                \n        fig.add_trace(\n            go.Scatter(x=dates_all, y=R_t_median, name=\"R Median\",line=dict(color='purple', width=2, dash='dash')),\n            secondary_y=True,\n        )\n        \n        fig.update_layout(\n            title_text=\"<b>SEIR-D<\/b> model i \"+ str(country) +' med ' + str(forecast_days) + ' dages forudsigelse'\n        )\n\n        # Set x-axis title\n        fig.update_xaxes(title_text=\"Datoer\")\n\n        # Set y-axes titles\n        fig.update_yaxes(title_text=\"<b>Population<\/b>\", secondary_y=False)\n        fig.update_yaxes(title_text=\"<b>Effektiv<\/b> R\", secondary_y=True)\n        \n        fig.update_layout(hovermode=\"x\")\n\n        fig.show()\n        \n        fig = go.Figure()\n        fig.add_trace(\n            go.Scatter(x=train_data['Date_datetime'], y=np.around(train_data['ConfirmedCases'],0), name=\"Data C\",line=dict(color='indianred', width=2)),\n        )\n        fig.add_trace(\n            go.Scatter(x=dates_all, y=np.around(y_pred['ConfirmedCases'],0), name=\"Model C\",line=dict(color='coral', width=2)),\n        )\n        \n        fig.add_trace(\n            go.Scatter(x=train_data['Date_datetime'], y=np.around(train_data['Fatalities'],0), name=\"Data D\",line=dict(color='black', width=2)),\n        )\n        \n        fig.add_trace(\n            go.Scatter(x=dates_all, y=np.around(y_pred['Fatalities'],0), name=\"Model D\",line=dict(color='Gray', width=2)),\n        )\n\n        if validation : \n            fig.add_trace(\n            go.Scatter(x=valid_data['Date_datetime'], y=np.around(y_true_valid['ConfirmedCases'],0), name=\"Data C (valid)\",line=dict(color='indianred', width=2,dash='dot')),\n        )\n            fig.add_trace(\n        go.Scatter(x=valid_data['Date_datetime'], y=np.around(y_pred_valid['ConfirmedCases'][:len(train_data)],0), name=\"Model C(valid)\",line=dict(color='coral', width=2,dash='dot')),\n        )\n        # fig.add_trace(\n        # go.Scatter(x=valid_data['Date_datetime'], y=y_true_valid2['Recovered'], name=\"Data R (valid)\"),\n        #   )\n        #fig.add_trace(\n        #go.Scatter(x=valid_data['Date_datetime'], y=y_pred_valid['Recovered'][:len(train_data)], name=\"Model R (valid)\"),\n        #)\n            fig.add_trace(\n            go.Scatter(x=valid_data['Date_datetime'], y=np.around(y_true_valid3['Fatalities'],0), name=\"Data D (valid)\",line=dict(color='black', width=2,dash='dot')),\n        )\n            fig.add_trace(\n        go.Scatter(x=valid_data['Date_datetime'], y=np.around(y_pred_valid['Fatalities'][:len(train_data)],0), name=\"Model D (valid)\",line=dict(color='Gray', width=2,dash='dot')),\n        )\n        \n        # Add figure title\n        fig.update_layout(\n            title_text=\"<b>Model<\/b> sammenlignet med tr\u00e6ningsset\" +' med ' + str(forecast_days) + ' dages forudsigelse'\n        )\n        \n        # Set x-axis title\n        fig.update_xaxes(title_text=\"Datoer\")\n\n        # Set y-axes titles\n        fig.update_yaxes(title_text=\"<b>Population<\/b>\")\n        \n        fig.update_layout(hovermode=\"x\")\n            \n        fig.show()\n    \n            ","b1687fcd":"fit_seir_model(train,'Denmark',forecast_days=30 ,make_plot=True,validation=True,full_validation=True)","9102a5d7":"fit_seir_model(train,'Norway',forecast_days=0,make_plot=True,validation=True,full_validation=True)","615f3ff2":"fit_seir_model(train,'Finland',forecast_days=0,make_plot=True,validation=True,full_validation=True)","35249d6c":"fit_seir_model(train,'Sweden',forecast_days=0,make_plot=True,validation=True,full_validation=True)","27efe438":"# Scandinavian countries","49504cb0":"# SEIR-D","3ce91fe8":"# COVID-19 in Denmark and the world prediction with SEIR-D model","7f39c956":" ### Data Cleaning","0a802323":"* # Visualization of dataset","a91d71d4":"where L is a description of the rate of decay, either the time until half decay or the time until full decay (see above), and k is a shape parameter (no dimension).","eb9223e8":"Thanks to \n* anjum48 https:\/\/www.kaggle.com\/anjum48\/seir-hcd-model for a great kernel that served as inspiration for this study","286037ad":"# Machine learning"}}