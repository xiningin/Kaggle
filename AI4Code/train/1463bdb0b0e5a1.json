{"cell_type":{"5d078d8f":"code","b4e2e1e4":"code","680a5b8a":"code","28eece30":"code","ebad0add":"code","7ae3f128":"markdown","0d9c7841":"markdown"},"source":{"5d078d8f":"# Imports\nimport json\nimport queue\nimport csv\nfrom collections import defaultdict","b4e2e1e4":"# Read the input json file\nINPUT_FILE = '\/kaggle\/input\/scl-2021-da\/contacts.json'\nwith open(INPUT_FILE, 'r') as f:\n    data = json.load(f)","680a5b8a":"# Create a dictionary from email to a list of all tickets with that email.\n# Create a dictionary from phone number to a list of all tickets with that phone number.\n# Create a dictionary from order-id to a list of all tickets with that order-id.\n\n# These dictionaries will help us quickly find all neighbors of a ticket.\n\ndef read_by(data, key):\n    dict_by_key = defaultdict(list)\n    for ticket in data:\n        ticket_key = ticket[key]\n        if ticket_key is not '':\n            dict_by_key[ticket_key].append(ticket)\n    return dict_by_key\n\ndict_by_email = read_by(data, 'Email')\ndict_by_phone = read_by(data, 'Phone')\ndict_by_order_id = read_by(data, 'OrderId')","28eece30":"# We now define a breath-first-search function that finds all the ticket ids\n# connected to the ticket provided in the argument. The function also keeps \n# track of the total contacts of the connected tickets.\n\n# Learn more about breadth-first-search here:\n# https:\/\/www.geeksforgeeks.org\/connected-components-in-an-undirected-graph\/\n\ndef bfs(ticket, dict_by_email, dict_by_phone, dict_by_order_id):\n    visited = set() # set of ticket id\n    q = queue.Queue() # queue used for breath-first-search\n    q.put(ticket)\n    total_contacts = 0\n    \n    while not q.empty():\n        ticket = q.get()\n        \n        # If we have visited a ticket, we should not visit it again.\n        if ticket['Id'] in visited:\n            continue \n\n        total_contacts += ticket['Contacts']\n        visited.add(ticket['Id'])\n        \n        # If the email, phone, or order-id is the same is ticket, it is \n        # treated as a neighbor.\n        \n        if ticket['Email'] is not '':\n            email_neighbors = dict_by_email[ticket['Email']]\n            for email_neighbor in email_neighbors:\n                q.put(email_neighbor)\n                \n        if ticket['Phone'] is not '':\n            phone_neighbors = dict_by_phone[ticket['Phone']]\n            for phone_neighbor in phone_neighbors:\n                q.put(phone_neighbor)\n                \n        if ticket['OrderId'] is not '':\n            order_id_neighbors = dict_by_order_id[ticket['OrderId']]\n            for order_id_neighbor in order_id_neighbors:\n                q.put(order_id_neighbor)\n    \n    return list(visited), total_contacts","ebad0add":"# Open and write the header to the output file\nOUTPUT_FILE = '\/kaggle\/working\/output.csv'\nwith open(OUTPUT_FILE, 'w') as f:\n    writer = csv.writer(f, delimiter=',')\n    writer.writerow([\"ticket_id\", \"ticket_trace\/contact\"])\n    \n    # for each ticket, we use the breadth-first-search function defined earlier\n    # to find all tickets with the same customers.\n    for ticket in data:\n        related_ids, related_contacts = bfs(ticket, dict_by_email, dict_by_phone,\n                                            dict_by_order_id)\n        \n        # sort all the tickets with the same customers by id\n        # and then join it with the number of contacts\n        part1 = '-'.join(map(str, sorted(related_ids)))\n        part2 = related_contacts\n        ans = f\"{part1}, {part2}\"\n        \n        # write the output to csv\n        writer.writerow([ticket['Id'], ans])","7ae3f128":"This notebook provides a graph theory solution of the Multi-Channel Contacts problem (Shopee Code League 2021). This notebook is intended for people who struggled with this problem.\n\nWe create a graph where each ticket is a vertex. Then, we draw an edge between two tickets if they share the same email, phone, or order-id. This way, two tickets are from the same customer if and only if there is a path from one to another in the graph, that is, if the tickets are connected. Given a ticket, we can find all tickets with the same customer (all the connected vertices) using graph search algorithms such as breadth first search. This is what the problem asks for, so we format the solution properly and we are done.\n\nThe submission has been modified for clarity.","0d9c7841":"A smart reader might have noticed that we could remember the answer for a ticket and reuse the answer with its connected tickets. This would speed up the code considerably. We did not do this because it would add to the complexity.\n\nHope you enjoy our solution and see you on the leaderboard! - Santi and ILoveNino team"}}