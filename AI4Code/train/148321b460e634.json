{"cell_type":{"634c4c42":"code","44666f0f":"code","e9e8a199":"code","eebb707c":"code","1298ed78":"code","edefe76c":"code","273a75e0":"code","c2e70cab":"code","214e9c6c":"code","d2711e2c":"markdown","44fae91b":"markdown","c14ee0c5":"markdown","230df30f":"markdown","31f1ed7e":"markdown","fba62394":"markdown","1ed6d401":"markdown","71652978":"markdown","1388490e":"markdown","c24ea502":"markdown","71e28222":"markdown","37a5e6ee":"markdown"},"source":{"634c4c42":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n!pip install music21\n!pip install python-highcharts\nfrom highcharts import Highchart\nfrom music21 import *\nimport math","44666f0f":"# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session\nBeethoven = \"\/kaggle\/input\/ode-to-joy\/Beethoven_Symphony_No._9_Choral_in_D_Minor_Op._125_IV._Allegro_assai_Ode_to_Joy_Alla_marcia_Excerpts.mxl\"\nDvorak = \"\/kaggle\/input\/dvorak-serenade-xml\/Antonin_Dvorak_Serenade_for_String_Orchestra_in_E_major_Op.22_II._Tempo_di_Valse.mxl\"\n","e9e8a199":"class Analyzer:\n    # a constant field that is important to the analysis, data from Harmony Perception by Periodicity Detection by Frieder Stolzenburg\u2020\n    # unison is altered from 1 to 0.5 for better results\n    interval_sonance = {0: 0.4085, 1: 0.183, 2: 0.393, 3: 0.495, 4: 0.570, 5: 0.701, 6: 0.327, 7: 0.737, 8: 0.520, 9: 0.526,\n                       10: 0.449, 11: 0.242, 12: 1}\n\n    # processed because negative values are needed to consider weights\n    for key in interval_sonance:\n        interval_sonance[key] -= 0.4085\n    \n    # automatically runs the analysis and store the results into fields.\n    def __init__(self, filepath, name):\n        self.name = name # title of the piece\n        self.music = converter.parse(filepath).chordify() # now chords can be easily extracted\n        self.tempo = self.music.metronomeMarkBoundaries()[0][2].number # tempo of a piece\n        self.dur = self.find_duration() # duration of a piece\n        self.measure_num = self.count_measure() # number of measures in this piece\n        self.x_labels = [((self.dur\/self.measure_num)*(i-1)) for i in range(1, self.measure_num+1)] # cumulative seconds of each measure \n        self.happiness_score = self.analyze_happiness() # a list of emotion scores\n        self.strength_score = self.analyze_strength() # a list of strength scores\n        self.density_score = self.analyze_density() # a list of density scores\n        self.happiness_median = self.find_median(list(filter(None.__ne__, self.happiness_score))) # the median of emotion scores\n        self.strength_median = self.find_median(list(filter(None.__ne__, self.strength_score))) # the median of strength scores\n        self.density_median = self.find_median(list(filter(None.__ne__, self.density_score))) # the median of density scores\n        self.happiness_mean = self.mean(list(filter(None.__ne__, self.happiness_score))) # the mean of emotion scores\n        self.strength_mean = self.mean(list(filter(None.__ne__, self.strength_score))) # the mean of strength scores\n        self.density_mean = self.mean(list(filter(None.__ne__, self.density_score))) # the mean of density scores\n\n    # return the number of measures\n    def count_measure(self):\n        count = 0\n        for thisMeasure in self.music.recurse().getElementsByClass('Measure'):\n            count+=1\n        return count\n    \n    # find the duration based on tempo of each measure\n    def find_duration(self):\n        output = 0\n        for thisMeasure in self.music.recurse().getElementsByClass('Measure'):\n            measure_tempo = thisMeasure.metronomeMarkBoundaries()[0][2].number\n            output = thisMeasure.quarterLength*60\/measure_tempo\n        return output\n\n    \n    # analysis helper methods------------------------------------------------\n    # helper method of analyze_emotion()\n    # returns a list of numbers which are the steps away from the root of the chord\n    def interval_from_root(self,thischord):\n        l = []\n        h = []\n        root = thischord.root().midi\n        for p in thischord.pitches:\n            l.append(p.midi)\n        for i in range(len(l)):\n            if l[i] - root != 0 and abs(l[i] - root) % 12 == 0:\n                h.append(12)\n            else:\n                h.append(abs(root - l[i]) % 12)\n        return h\n    \n    # the basic part of analyze_emotion(), returns double\n    def sonance(self, achord):\n        l = []\n        for p in achord.pitches:\n            l.append(p)\n        ifr = self.interval_from_root(achord)\n        if (len(achord.pitches) == 1):\n            return None\n        score = 0\n        for i in ifr:\n            score += i * self.interval_sonance.get(i)\n        return score\n    \n    # helper method for analyze_emotion() and analyze_strength(), returns double\n    # alters the weight of a score\n    def duration(self, chord, score, input_tempo):\n        length = chord.quarterLength*60\/input_tempo\n        score *= (length)\n        return score\n    \n    # helper method for analyze_emotion(), returns double\n    # alters the weight of a score\n    def volume_weight(self, chord, score):\n        if chord.volume != None:\n            vol = (chord.volume.getRealized()) * 128\n            score *= vol\n        else:\n            print(\"VOLUME NOT AVAILABLE, ANALYZE EMOTION WILL NOT TAKE VOLUME INTO ACCOUNT\")\n        return score\n\n    # the basic part of analyze_strength(), returns double\n    def volume_base(self, chord):\n        if chord.volume != None:\n            vol = (chord.volume.getRealized()) * 128\n            score = vol\n        else:\n            score=None\n            print(\"VOLUME NOT AVAILABLE, ANALYZE STRENGTH FAILED\")\n        return score\n\n    # helper method for analyze_emotion(), returns double\n    # alters the weight of a score\n    def pitch(self,chord, score):\n        p = chord.pitches\n        num = len(p)\n        avg = 0\n        for k in range(0, num):\n            value = p[k].diatonicNoteNum\n            avg += value\n        avg \/= 10\n        avg = avg \/ num\n        return score * math.sqrt(avg) #factor usually ranges from 1.4 to 2.0\n\n    # the basic part of analyze_density(), returns double\n    def density(self, measure):\n        measuredensity = 0\n        for thisChord in measure.recurse().getElementsByClass('Chord'):\n            num = len(thisChord.pitches)\n            measuredensity += num\n        return measuredensity\n    \n    # analysis methods-------------------------------------------------\n    # emotion analysis, returns list\n    def analyze_happiness(self):\n        HappinessScore = []\n        ChordScore = []\n        chords = []\n\n        for thisMeasure in self.music.recurse().getElementsByClass('Measure'):\n            measurescore = 0\n            measure_tempo = thisMeasure.metronomeMarkBoundaries()[0][2].number\n            for thisChord in thisMeasure.recurse().getElementsByClass('Chord'):\n                chords.append(thisChord)\n                if (len(thisChord.pitches) == 1):\n                    ChordScore.append(None)\n                    continue\n                thisChordScore = self.sonance(thisChord) \/ len(thisChord.pitches)\n                thisChordScore = self.duration(thisChord, thisChordScore, measure_tempo)\n                thisChordScore = self.volume_weight(thisChord, thisChordScore)\n                thisChordScore = self.pitch(thisChord, thisChordScore)\n                ChordScore.append(thisChordScore)\n                measurescore += thisChordScore\n\n            if measurescore == 0:\n                HappinessScore.append(None)\n            else:\n                HappinessScore.append(measurescore)\n        return HappinessScore\n\n    # strength analysis, returns list\n    def analyze_strength(self):\n        StrengthScore = []\n        ChordScore = []\n        chords = []\n        for thisMeasure in self.music.recurse().getElementsByClass('Measure'):\n            measurescore = 0\n            measure_tempo = thisMeasure.metronomeMarkBoundaries()[0][2].number\n\n            for thisChord in thisMeasure.recurse().getElementsByClass('Chord'):\n                chords.append(thisChord)\n                thisChordScore = self.volume_base(thisChord)\n                thisChordScore = self.duration(thisChord, thisChordScore, measure_tempo)\n                ChordScore.append(thisChordScore)\n                measurescore += thisChordScore\n                \n            if measurescore == 0:\n                StrengthScore.append(None)\n            else:\n                StrengthScore.append(measurescore)\n        return StrengthScore\n\n    # density analysis, returns list\n    def analyze_density(self):\n        DensityScore = []\n        chords = []\n        for thisMeasure in self.music.recurse().getElementsByClass('Measure'):\n            count = 0\n            chordcount = 0\n            for thisChord in thisMeasure.recurse().getElementsByClass('Chord'):\n                chords.append(thisChord)\n                num = len(thisChord.pitches)\n                count += num\n                chordcount+=1\n            if count == 0 or chordcount==1:\n                DensityScore.append(None)\n            else:\n                DensityScore.append(count)\n        return DensityScore\n    \n    # graphing helper methods-------------------------------------------\n    # proccess scores data so the curve is smoothed and has less fluctuation \n    # the larger the gap, the smoother the curve will be, by default, three lines with gap 1, 2, 5 will be drawn\n    # returns list\n    def draw_lines(self, gap, input):\n        output = []\n        x = []\n        for i in range(0, len(input) - 1, gap):\n            sum = 0\n            count = 0\n            start = i\n            end = 0\n            if i + gap <= len(input):\n                end = i + gap\n                for j in range(i, i + gap):\n                    if input[j] != None:\n                        sum += input[j]\n                        count += 1\n            else:\n                end = len(input)\n                for j in range(i, len(input)):\n                    if input[j] != None:\n                        sum += input[j]\n                        count += 1\n            if count >= gap \/ 2:\n                avg = sum \/ count\n            else:\n                avg = None\n            x.append((start + end) \/ 2)\n            output.append(avg)\n        data = []\n        for n in range(len(x)):\n            data.append([x[n], output[n]])\n        return data\n    \n    # proccess scores data so it can be the input to the line chart\n    # returns 2D list\n    def y_to_data(self, input_y):\n        output = []\n        for i in range(len(input_y)):\n            output.append([i+1, input_y[i]])\n        return output\n    \n    # find median of a list\n    # return double\n    def find_median(self,input):  \n        input.sort()\n        number_of_data = len(input)\n        if number_of_data % 2 == 0:\n            median = (input[(number_of_data \/\/ 2)] + input[(number_of_data \/\/ 2 - 1)]) \/ 2\n        else:\n            median = input[(number_of_data \/\/ 2)]\n        return median\n    \n    # find mean of a list\n    # return double\n    def mean(self, input):\n        sum = 0\n        for i in range(len(input)):\n            sum+=input[i]\n        avg = sum\/len(input)\n        return avg","eebb707c":"filepath=\"\/kaggle\/input\/dvorak-serenade-xml\/Antonin_Dvorak_Serenade_for_String_Orchestra_in_E_major_Op.22_II._Tempo_di_Valse.mxl\"\nA1 = Analyzer(Dvorak, \"Dvorak E Major Serenade\")\nprint(\"analysis successful\")","1298ed78":"# I was going to make the following into draw_line_chart() and put it inside the class. However, for some reasons, calling the draw_line_chart() doens't do anything. So I had to separate it from the class.\ntarget = A1\ncolors = [\"rgba(254, 92, 54, 0.5)\",\"rgba(84, 175, 188, 1)\",\"rgba(255, 180, 73, 1)\"]\nH1 = Highchart(width=800, height=500)\ny = target.y_to_data(target.happiness_score)\ny1 = target.draw_lines(2,target.happiness_score)\ny2 = target.draw_lines(5,target.happiness_score)\n\noptions = {\n    'chart': {\n        'zoomType': 'xy'\n    },\n    'title': {\n        'text': 'Happiness Progression'\n    },\n    'subtitle': {\n        'text': target.name\n    },\n         'xAxis': [{\n    #     'plotBands': [{ # visualize breaks\n    #             'from': 4.5,\n    #             'to': 6.5,\n    #             'color': 'rgba(68, 170, 213, .2)'\n    #         },\n    #             {'from': 14.5,\n    #             'to': 16.5,\n    #             'color': 'rgba(68, 170, 213, .2)'}]\n             'title': {\n            'enabled': True,\n            'text': 'Measure Number'\n        },\n         }],\n\n    'yAxis': [\n\n        {'labels': {\n            'enabled':False,\n            'format': '{value}',\n            'style': {\n                'color': 'FFFFFF'\n            }\n        },\n            'title': {\n                'text': 'happiness score',\n                'style': {\n                }\n            },\n            'opposite': False\n        },\n\n    ],\n    'tooltip': {\n        'shared': True,\n\n    },\n    'legend': {\n        'layout': 'vertical',\n        'align': 'left',\n        'verticalAlign': 'top',\n        'floating': True,\n        'backgroundColor': \"(Highcharts.theme && Highcharts.theme.legendBackgroundColor) || '#FFFFFF'\"\n    },\n}\nH1.set_dict_options(options)\n\nH1.add_data_set(y, 'spline', 'measure gap 1', yAxis=0, enableMouseTracking=False, lineWidth=1,\n                tooltip={\n                    'valueSuffix': '',\n                },\n                marker={\n                    'enabled': False\n                })\nH1.add_data_set(y1, 'spline', 'measure gap 2', yAxis=0, enableMouseTracking=False,lineWidth=2, \n                tooltip={\n                    'valueSuffix': ''\n                },\n                marker={\n                    'enabled': False\n                })\nH1.add_data_set(y2, 'spline', 'measure gap 5', yAxis=0, lineWidth=3,enableMouseTracking=False\n            ,\n                tooltip={\n                    'valueSuffix': ''\n                },\n                marker={\n                    'enabled': False\n                })\nH1","edefe76c":"H2 = Highchart(width=800, height=500)\n\ny = target.y_to_data(A1.strength_score)\ny1 = target.draw_lines(2, A1.strength_score)\ny2 = target.draw_lines(5, A1.strength_score)\n\noptions = {\n'chart': {\n    'zoomType': 'xy'\n},\n'title': {\n    'text': 'Strength Progression'\n},\n'subtitle': {\n    'text': target.name\n},\n         'xAxis': [{\n    #     'plotBands': [{ # visualize breaks\n    #             'from': 4.5,\n    #             'to': 6.5,\n    #             'color': 'rgba(68, 170, 213, .2)'\n    #         },\n    #             {'from': 14.5,\n    #             'to': 16.5,\n    #             'color': 'rgba(68, 170, 213, .2)'}]\n             'title': {\n            'enabled': True,\n            'text': 'Measure Number'\n        },\n         }],\n\n'yAxis': [\n\n    {'labels': {\n        'enabled':False,\n        'format': '{value}',\n        'style': {\n            'color': 'FFFFFF'\n        }\n    },\n        'title': {\n            'text': 'strength score',\n            'style': {\n            }\n        },\n        'opposite': False\n    },\n\n],\n'tooltip': {\n    'shared': True,\n\n},\n'legend': {\n    'layout': 'vertical',\n    'align': 'left',\n    'verticalAlign': 'top',\n    'floating': True,\n    'backgroundColor': \"(Highcharts.theme && Highcharts.theme.legendBackgroundColor) || '#FFFFFF'\"\n},\n}\nH2.set_dict_options(options)\n\n\nH2.add_data_set(y,\n            'spline',\n            'measure gap 1',\n            yAxis=0,\n            enableMouseTracking=False\n            ,\n            tooltip={\n                'valueSuffix': '',\n            },\n            marker={\n                'enabled': False\n            }, lineWidth=1\n            )\nH2.add_data_set(y1,\n            'spline',\n            'measure gap 2',\n            enableMouseTracking=False\n            ,\n            yAxis=0,\n            tooltip={\n                'valueSuffix': ''\n            },\n            marker={\n                'enabled': False\n            },\n            lineWidth=2)\n\nH2.add_data_set(y2,\n            'spline',\n            'measure gap 5',\n            yAxis=0,enableMouseTracking=False\n            ,\n            tooltip={\n                'valueSuffix': ''\n            },\n            marker={\n                'enabled': False\n            },\n            lineWidth=3)\n\n\nH2","273a75e0":"H3 = Highchart(width=800, height=500)\n\ny = target.y_to_data(A1.density_score)\ny1 = target.draw_lines(2, A1.density_score)\ny2 = target.draw_lines(5, A1.density_score)\n\noptions = {\n'chart': {\n    'zoomType': 'xy'\n},\n'title': {\n    'text': 'Density Progression'\n},\n'subtitle': {\n    'text': target.name\n},\n         'xAxis': [{\n    #     'plotBands': [{ # visualize breaks\n    #             'from': 4.5,\n    #             'to': 6.5,\n    #             'color': 'rgba(68, 170, 213, .2)'\n    #         },\n    #             {'from': 14.5,\n    #             'to': 16.5,\n    #             'color': 'rgba(68, 170, 213, .2)'}]\n             'title': {\n            'enabled': True,\n            'text': 'Measure Number'\n        },\n         }],\n\n'yAxis': [\n\n    {'labels': {\n        'enabled':False,\n        'format': '{value}',\n        'style': {\n            'color': 'FFFFFF'\n        }\n    },\n        'title': {\n            'text': 'density score',\n            'style': {\n            }\n        },\n        'opposite': False\n    },\n\n],\n'tooltip': {\n    'shared': True,\n\n},\n'legend': {\n    'layout': 'vertical',\n    'align': 'left',\n    'verticalAlign': 'top',\n    'floating': True,\n    'backgroundColor': \"(Highcharts.theme && Highcharts.theme.legendBackgroundColor) || '#FFFFFF'\"\n},\n}\nH3.set_dict_options(options)\n\nH3.add_data_set(y,\n            'spline',\n            'measure gap 1',\n            yAxis=0,\n            enableMouseTracking=False\n            ,\n            tooltip={\n                'valueSuffix': '',\n            },\n            marker={\n                'enabled': False\n            }, lineWidth=1\n            )\nH3.add_data_set(y1,\n            'spline',\n            'measure gap 2',\n            enableMouseTracking=False\n            ,\n            yAxis=0,\n            tooltip={\n                'valueSuffix': ''\n            },\n            marker={\n                'enabled': False\n            },\n            lineWidth=2)\nH3.add_data_set(y2,\n            'spline',\n            'measure gap 5', enableMouseTracking=True\n            ,\n            yAxis=0,\n            tooltip={\n                'valueSuffix': ' notes per measure'\n            },\n            marker={\n                'enabled': False\n            },\n            lineWidth=3)\nH3","c2e70cab":"A2 = Analyzer(Beethoven, \"Ode to Joy\")\nprint(\"analysis successful\")","214e9c6c":"P = Highchart(width=500, height=500)\nlabels = [\"Happiness\", \"Strength\", \"Density\",\"Ruler Happiness\", \"Ruler Strength\", \"Ruler Density\"]\noptions =  {\n\n    'chart': {\n        'polar': True\n    },\n\n    'title': {\n        'text': 'Comparison Between Two Pieces'\n    },\n\n    'subtitle': {\n        'text': target.name + ' vs. ' + A2.name\n    },\n\n    'pane': {\n        'size': '100%',\n\n\n    },\n\n    'xAxis': {\n        'categories': labels,\n                'tickmarkPlacement': 'on',\n\n    },\n\n    \n'yAxis': [\n\n    {'labels': {\n        'enabled':False,\n        'format': '{value}',\n        'style': {\n            'color': 'FFFFFF'\n        }\n    },\n        'title': {\n            'text': '',\n            'style': {\n            }\n        },\n        'opposite': False\n    },\n\n],\n        'tooltip': {\n        'shared': True\n    },\n};\n\nP.set_dict_options(options)\nd1 =  [A1.happiness_median\/A2.happiness_median,A1.strength_median\/A2.strength_median,A1.density_median\/A2.density_median]\nd2 = [1,1,1]\nd3 = [A1.happiness_mean\/A2.happiness_mean,A1.strength_mean\/A2.strength_mean,A1.density_mean\/A2.density_mean]\nP.add_data_set(d2, 'area', A2.name, enableMouseTracking=True)\n\nP.add_data_set(d1, 'column', \"median score of \" + A1.name, enableMouseTracking=False)\nP.add_data_set(d3, 'column', \"mean score of \" + A1.name, enableMouseTracking=False)\n\n\nP","d2711e2c":"* The next cell draws the happiness line chart. \n* Higher happiness score (y value) indicates happier music.\n* Note: the y values are arbitrary, only the trend matters. ","44fae91b":"# Graphs","c14ee0c5":"* The next cell generates a polar chart comparing the piece above to another piece.\n* The \"ruler\" piece will have three scores normalized to 1, so it is easier to compare the difference.","230df30f":"**Comparing 2 pieces**\n* The next cell creates another analyzer with a piece that is the \"ruler\" in this comparison.\n* You can change file input to compare any two songs you like.\n* by default, A2 (created in the next cell) analyzes Beethoven's Ode to Joy.","31f1ed7e":"* The program takes music xml files as input. \n* By running the next cell, you will see the file path of xml files that has been already uploaded to this program. \n* You can upload more files if you want.","fba62394":"# Analysis\nThe next cell is the class Analyzer.","1ed6d401":"* The next cell draws strength line chart. \n* Higher strength score (y value) indicates louder music.\n* Note: the y values are arbitrary, only the trend matters. ","71652978":"This program uses two libraries, music21 and highcharts, that will be downloaded if you run the next cell. ","1388490e":"# Introduction\n* A program that calculates and **visualizes the fluctuation in emotion** of a song based on tempo, frequency of notes, intervals, scales, etc.\n* The purpose is to give people a clear, easy overview of the **emotion progression** of the song since most classical music have obscure titles that don\u2019t tell how the song sounds like or what emotion it conveys.\n* The program can identify when those fluctions occur (when is the piece happy or sad?) and compare different pieces (is this piece happier than the other piece?).\n* Acknowledgements: \n * since the program analyzes based on intervals, it can't analyze pure melodic pieces. \n * I have not tried this program on non-classical music.","c24ea502":"**Functional Specifications: https:\/\/docs.google.com\/document\/d\/1Q73N3U_xWZ4bxEUQqxtX_t-tbhpq3j8llMki1VP07bw\/edit?usp=sharing**","71e28222":"* The next cell draws density line chart.\n* Higher density score (y value) indicates more notes per measure.","37a5e6ee":"**Create an Analyzer**\n* An analyzer with a certain xml file will be created by running the next cell.\n* You can change the file path to other songs that you like (given that they are uploaded to this program).\n* A1 now analyzes the second movement of Dvorak's E major serenade. music see here https:\/\/musescore.com\/thecactus\/scores\/3872606"}}