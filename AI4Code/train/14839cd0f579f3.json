{"cell_type":{"b5090770":"code","1253fe78":"code","7159f89d":"code","e847e06e":"code","a2d2519c":"code","bccde9f4":"code","9862801a":"code","ebc7c22c":"code","a37cc34a":"code","7df0697f":"code","f6fe4978":"code","34d580c2":"code","70f92fb8":"code","524577d5":"code","c625c818":"code","71db99ef":"code","e044ae34":"code","40444f3f":"code","d91d97d4":"code","7fb74586":"code","ffcf4d1e":"code","a68b6b7c":"code","f79b9c5b":"code","ae8e10d0":"code","e9faf6b6":"code","a72b6bee":"code","37638db1":"code","6e19d42a":"code","0f921914":"code","53f99902":"markdown","771869f9":"markdown","546b9cf1":"markdown","1d1364d5":"markdown","3c7da954":"markdown","10063edb":"markdown","d8d8eb23":"markdown","81fddd25":"markdown","ab308259":"markdown","30e4ae3e":"markdown","3bcd78b6":"markdown","4c833020":"markdown","b3b59677":"markdown","38fa7fab":"markdown","b69cb4b5":"markdown","b4041455":"markdown","22d1b43d":"markdown","9b03bdf7":"markdown","989c55b4":"markdown","fe06977b":"markdown","68c7d69c":"markdown","de855fd3":"markdown","6388a83e":"markdown","76ec55ea":"markdown","9d4fabf3":"markdown","38c85a6c":"markdown","750fe49b":"markdown","486223c9":"markdown","cf9cddb1":"markdown","a8eabef0":"markdown","def5f14f":"markdown","e7e2a290":"markdown","cb2e8337":"markdown","590405d4":"markdown","1c9f6473":"markdown","87ddbe62":"markdown","d494890d":"markdown","5705d302":"markdown","2468bbd4":"markdown","a4cc9467":"markdown"},"source":{"b5090770":"from mpl_toolkits.mplot3d import Axes3D\nfrom sklearn.preprocessing import StandardScaler\nimport matplotlib.pyplot as plt # plotting\nimport numpy as np # linear algebra\nimport os # accessing directory structure\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom sklearn.model_selection import train_test_split # Import train_test_split from sklearn library\n\n\nfrom sklearn import model_selection #models selection importing\nfrom sklearn import metrics #selection metrics\nfrom sklearn.metrics import confusion_matrix #confusion matrix\nfrom sklearn.linear_model import LogisticRegression #Logistic regression\nfrom sklearn.model_selection import cross_val_score #cross validarion import\nfrom sklearn.metrics import classification_report #classification report import\nfrom sklearn.ensemble import ExtraTreesClassifier\nfrom sklearn.feature_selection import SelectFromModel\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.feature_selection import RFECV\nfrom sklearn.metrics import roc_auc_score #import the ROC curve \nfrom sklearn.metrics import roc_curve","1253fe78":"# Distribution graphs (histogram\/bar graph) of column data\ndef plotPerColumnDistribution(df, nGraphShown, nGraphPerRow):\n    nunique = df.nunique()\n    df = df[[col for col in df if nunique[col] > 1 and nunique[col] < 50]] # For displaying purposes, pick columns that have between 1 and 50 unique values\n    nRow, nCol = df.shape\n    columnNames = list(df)\n    nGraphRow = (nCol + nGraphPerRow - 1) \/ nGraphPerRow\n    plt.figure(num = None, figsize = (6 * nGraphPerRow, 8 * nGraphRow), dpi = 80, facecolor = 'w', edgecolor = 'k')\n    for i in range(min(nCol, nGraphShown)):\n        plt.subplot(nGraphRow, nGraphPerRow, i + 1)\n        columnDf = df.iloc[:, i]\n        if (not np.issubdtype(type(columnDf.iloc[0]), np.number)):\n            valueCounts = columnDf.value_counts()\n            valueCounts.plot.bar()\n        else:\n            columnDf.hist()\n        plt.ylabel('counts')\n        plt.xticks(rotation = 90)\n        plt.title(f'{columnNames[i]} (column {i})')\n    plt.tight_layout(pad = 1.0, w_pad = 1.0, h_pad = 1.0)\n    plt.show()\n","7159f89d":"# Correlation matrix\ndef plotCorrelationMatrix(df, graphWidth):\n    filename = df.dataframeName\n    df = df.dropna('columns') # drop columns with NaN\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    if df.shape[1] < 2:\n        print(f'No correlation plots shown: The number of non-NaN or constant columns ({df.shape[1]}) is less than 2')\n        return\n    corr = df.corr()\n    plt.figure(num=None, figsize=(graphWidth, graphWidth), dpi=80, facecolor='w', edgecolor='k')\n    corrMat = plt.matshow(corr, fignum = 1)\n    plt.xticks(range(len(corr.columns)), corr.columns, rotation=90)\n    plt.yticks(range(len(corr.columns)), corr.columns)\n    plt.gca().xaxis.tick_bottom()\n    plt.colorbar(corrMat)\n    plt.title(f'Correlation Matrix for {filename}', fontsize=15)\n    plt.show()\n","e847e06e":"# Scatter and density plots\ndef plotScatterMatrix(df, plotSize, textSize):\n    df = df.select_dtypes(include =[np.number]) # keep only numerical columns\n    # Remove rows and columns that would lead to df being singular\n    df = df.dropna('columns')\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    columnNames = list(df)\n    if len(columnNames) > 10: # reduce the number of columns for matrix inversion of kernel density plots\n        columnNames = columnNames[:10]\n    df = df[columnNames]\n    ax = pd.plotting.scatter_matrix(df, alpha=0.75, figsize=[plotSize, plotSize], diagonal='kde')\n    corrs = df.corr().values\n    for i, j in zip(*plt.np.triu_indices_from(ax, k = 1)):\n        ax[i, j].annotate('Corr. coef = %.3f' % corrs[i, j], (0.8, 0.2), xycoords='axes fraction', ha='center', va='center', size=textSize)\n    plt.suptitle('Scatter and Density Plot')\n    plt.show()\n","a2d2519c":"nRowsRead = 1000 # specify 'None' if want to read whole file\n# Churn_Modelling.csv has 10000 rows in reality, but we are only loading\/previewing the first 1000 rows\ndf1 = pd.read_csv('..\/input\/Churn_Modelling.csv', delimiter=',', nrows = nRowsRead)\ndf1.dataframeName = 'Churn_Modelling.csv'\nnRow, nCol = df1.shape\nprint(f'There are {nRow} rows and {nCol} columns')","bccde9f4":"print(os.listdir('..\/input'))","9862801a":"plotPerColumnDistribution(df1, 10, 5)","ebc7c22c":"plotCorrelationMatrix(df1, 8)","a37cc34a":"plotScatterMatrix(df1, 20, 10)","7df0697f":"df1.head()","f6fe4978":"#As we are predicting the exit status of the customer we need to see how some important features are collerated with the predictive feature\n#plt.bar(df1.Balance,df1.Exited)","34d580c2":"#checking the correlation between age and balance!\nnp.corrcoef(df1.Balance,df1.Age)","70f92fb8":"#copying the original dataset\ndf2=df1.copy()\ndf2['Zero_Balance']=np.where(df2['Balance']==0, 1, 0)\ngender1=np.array(df2.groupby(['Gender'])['HasCrCard','IsActiveMember','Exited','Zero_Balance'].mean().reset_index())\nGeography1=np.array(df2.groupby(['Geography'])['HasCrCard','IsActiveMember','Exited','Zero_Balance'].mean().reset_index())","524577d5":"#This method plot the the statistics of given entry\ndef plotData(data,row,label,subplt,fig):\n    ax = fig.add_subplot(subplt)\n    N = 4\n    gen = data[row,1:]\n    ind = np.array(['HasCard','IsActive','Exited','Zero_Balance'])    # the x locations for the groups\n    p2 = ax.bar(ind, gen, 0.6, color=(0.2588,0.4433,1.0))\n    p1 = ax.bar(ind, 1-gen, 0.6,color=(1.0,0.5,0) ,bottom=gen)\n    plt.ylabel(\"Level\")\n    plt.title(\"%s statistics\" %label)","c625c818":"#plotting the gender statistics\nfig = plt.figure(figsize=(10,6))\nplotData(gender1,0,\"Female\",121,fig)\nplotData(gender1,1,\"Male\",122,fig)\n#plotting the Geography statistics\nfig2 = plt.figure(figsize=(15,6))\nplotData(Geography1,0,\"France\",131,fig2)\nplotData(Geography1,1,\"Germany\",132,fig2)\nplotData(Geography1,2,\"Spain\",133,fig2)","71db99ef":"df=df1.copy()\ndf.columns","e044ae34":"gend=pd.get_dummies(df.Gender)\ngeo=pd.get_dummies(df.Geography)","40444f3f":"#combining the object so we can concatenate with the bigger dataframe\nobj=[df,gend,geo]\ndf=pd.concat(obj, axis=1)","d91d97d4":"#creating the dataset we will be using \n#this contain only helpfull feature by ignoring the Gender and geography columns\ndf3 = df[['CreditScore','Female','Male','France','Germany','Spain','Age','Tenure','NumOfProducts','HasCrCard','IsActiveMember','Balance','EstimatedSalary','Exited']]","7fb74586":"X=df3[['CreditScore','Female','Male','France','Germany','Spain','Age','Tenure','NumOfProducts','HasCrCard','IsActiveMember','EstimatedSalary','Balance']]\nY=df3[['Exited']]","ffcf4d1e":"# random_state below is a metric that is used by the function to shuffle datas while splitting. This is chosen randomly.\nX_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, random_state = 2) # 0.2 test_size means 20% for testing\n\nprint(X_train.shape, y_train.shape)\nprint(X_test.shape, y_test.shape)","a68b6b7c":"kfold = model_selection.KFold(n_splits=5, random_state=2)\nmodelCV = LogisticRegression()\nscoring = 'accuracy'\nresults = model_selection.cross_val_score(modelCV, X_train, y_train.values.ravel(), cv=kfold, scoring=scoring)\nprint(\"10-fold cross validation average accuracy: %.3f\" % (results.mean()))","f79b9c5b":"#getting the Logistic Regression model\nlogreg = LogisticRegression()\n#fitting the data\nlogreg.fit(X_train, y_train.values.ravel())\n#predicting \ny_pred = logreg.predict(X_test)\n#printing the accuracy\nprint('Accuracy of logistic regression classifier on test set:'+str(format(logreg.score(X_test, y_test))))\n#confusion matrix\nconf_matrix = confusion_matrix(y_test, y_pred)\nconf_matrix\nprint(conf_matrix)\nfig = plt.figure()\nax = fig.add_subplot(111)\n#printing the confusion matrix graphic\ncax = ax.matshow(conf_matrix)\nplt.title('Confusion matrix of the classifier')\nfig.colorbar(cax)\n\nplt.xlabel('Predicted')\nplt.ylabel('True')\nplt.show()\n","ae8e10d0":"print(classification_report(y_test, y_pred))","e9faf6b6":"#USING THE TREE CLASSIFIER\nclf = ExtraTreesClassifier()\n#fitting the features \nclf = clf.fit(X_train, y_train.values.ravel())\n#\nclf.feature_importances_  \nmodel = SelectFromModel(clf, prefit=True)\nX_new = model.transform(X)\n#extracting the selected features\nfeature_idx=model.get_support()\nfeature_name=X.columns[feature_idx]\n#Getting the new features extracted \nX_test_new=X_test.loc[:,feature_idx]\nX_train_new=X_train.loc[:,feature_idx]\n","a72b6bee":"#Those are more important features then I will reuse them again in the model\nfeature_name","37638db1":"logre = LogisticRegression()\nlogre.fit(X_train_new ,y_train.values.ravel())\n\ny_pred = logre.predict(X_test_new)\nprint('Accuracy of logistic regression classifier on test set:'+str(format(logre.score(X_test_new, y_test))))\nconf_matrix = confusion_matrix(y_test, y_pred)\nconf_matrix\nprint(conf_matrix)\nfig = plt.figure()\nax = fig.add_subplot(111)\ncax = ax.matshow(conf_matrix)\nplt.title('Confusion matrix of the classifier IMPROVED')\nfig.colorbar(cax)\nplt.xlabel('Predicted')\nplt.ylabel('True')\nplt.show()\ny= (conf_matrix[0,0]+conf_matrix[1,1])\/(conf_matrix[0,0]+conf_matrix[0,1]+conf_matrix[1,0]+conf_matrix[1,1])\nprint('Accurracy= '+str(y))\nprint(classification_report(y_test, y_pred))","6e19d42a":"from sklearn.svm import SVC \nmodel = SVC(probability=True)  \n# Fitting the model\nmodel = model.fit(X_train_new, y_train)  \n# Predictions\/probs on the test dataset\npredicted = pd.DataFrame(model.predict(X_test_new))  \n# Store metrics\naccuracy = metrics.accuracy_score(y_test, predicted)\nprint(\"Support vector machine acuuracy is \",accuracy)","0f921914":"# The  number of correct classifications\nclf_rf_4 = RandomForestClassifier() \nrfecv = RFECV(estimator=clf_rf_4, step=1, cv=5,scoring='accuracy')   #5-fold cross-validation\n#fitting the classifier\nrfecv = rfecv.fit(X_train_new, y_train.values.ravel())\n\nprint('Optimal number of features :', rfecv.n_features_)\nprint('Best features :', X_train_new.columns[rfecv.support_])\n\n# Plot number of features VS. cross-validation scores\n\nplt.figure()\nplt.xlabel(\"Number of features selected\")\nplt.ylabel(\"Cross validation score of number of selected features\")\nplt.plot(range(1, len(rfecv.grid_scores_) + 1), rfecv.grid_scores_)\nplt.show()\n\n\n#random forest classifier with n_estimators=10 (default)\nclf_rf = RandomForestClassifier(random_state=43)      \nclr_rf = clf_rf.fit(X_train_new,y_train.values.ravel())\n#printing the score \nypred_new=clf_rf.predict(X_test_new)\nac = accuracy_score(y_test,ypred_new)\nprint('Accuracy is: ',ac)","53f99902":"Considering the size of data this kind of occuracy is good ","771869f9":"Distribution graphs (histogram\/bar graph) of sampled columns:","546b9cf1":"# #Splitting data","1d1364d5":"As we can see some of the features are not so more important like others. I choose to use extra tree classifier. This technique implements a meta estimator that fits a number of randomized decision trees (a.k.a. extra-trees) on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting.","3c7da954":"From the above figures we can easily get the insight on what is in the data regarding some potential identifiers on account balances and how it goes with being active or Exited accross the countries given. This will help me understand the feature importances in selection. For example for Germany.. No customer has zero balance and yet It has a higher percentage of exited customers..  Thus is more important feature to consider when building model. ","10063edb":"**Now on as we are going to build model we need to identify which is a dependent(Predictive) variable and Independent. For our case dependent is \"Exited \" column and  other are predictors**","d8d8eb23":"# # 2. USING RANDOM FOREST","81fddd25":"# Feature extractions","ab308259":"Wow! O.82 for this SVM is an improvment. It improved my the model by 0.4%. Which is good somehow. Let me try to use Random forest.\n**The random forest is the powerful one for binary classification predictions.**","30e4ae3e":"#Because we will be using Gender and Geography columns which have string values we need to assign some dummie  values to each of the entry of those column.\nThere are two ways of doing this:\n1. By defaults I'm assignning like:\n- Female= 1\n- Male=0\nOr use the dummie function to get the expanded columns of each of the entries \n\nAgain for the Geography case we can use the dummie function as by using the mormal assigning for the case  we have many countries it can bias our prediction.\nThus I will use the dummie function too.\n","3bcd78b6":"# !!! Accuracy is:  0.86 WHICH IS AN IMPROVEMENT!!!!","4c833020":"## Conclusion 1`\nThis concludes your starter analysis! To go forward from here, click the blue \"Fork Notebook\" button at the top of this kernel. This will create a copy of the code and environment for you to edit. Delete, modify, and add code as you please. Happy Kaggling!","b3b59677":"# #My work start from here!","38fa7fab":"The next hidden code cells define functions for plotting data. Click on the \"Code\" button in the published kernel to reveal the hidden code.","b69cb4b5":"Let's take a quick look at what the data looks like:","b4041455":"Correlation matrix:","22d1b43d":"There is 1 csv file in the current version of the dataset:\n","9b03bdf7":"# Fitting the Logistic Regression again!!","989c55b4":"The above changes didn't really improves our model performance comparing to when using all the 13 features!\n\nDue to the above results let me try to use The random forest classification methods to improve the performnce.","fe06977b":"## Exploratory Analysis\nTo begin this exploratory analysis, first import libraries and define functions for plotting the data using `matplotlib`. Depending on the data, not all plots will be made. (Hey, I'm just a simple kerneling bot, not a Kaggle Competitions Grandmaster!)","68c7d69c":"***Score of 78.4% is good for our dataset to build our model.*****","de855fd3":"There are several techniques to use for this problem byut we keep in mind that we are predicting a binary classification problem. There are some appropriate model to use for this problem:\n- Logistic regression\n- Support vector  machine\n- Decision tree classification\n- Random forest classification\n- KNN classification.\n\nSome of them are more complex but they don't really improves the performance! I will be starting using Logistic regression","6388a83e":"Now you're ready to read in the data and use the plotting functions to visualize the data.","76ec55ea":"Cross-validation is a technique for evaluating ML models by training several ML models on subsets of the available input data and evaluating them on the complementary subset of the data. Use cross-validation to detect overfitting, ie, failing to generalize a pattern.\n\nYou can use the k-fold cross-validation method to perform cross-validation. In k-fold cross-validation, you split the input data into k subsets of data (also known as folds). You train an ML model on all but one (k-1) of the subsets, and then evaluate the model on the subset that was not used for training. This process is repeated k times, with a different subset reserved for evaluation (and excluded from training) each time.  \/\/source: Amazon.com\n\n#This techniques prevent overfitting of the training dataset! \/\/Following is for Logistic Regression","9d4fabf3":"### Let's check 1st file: ..\/input\/Churn_Modelling.csv","38c85a6c":"# Feature prunning","750fe49b":"# #Precision & recall**","486223c9":"# #Support vector machine","cf9cddb1":"Conclusion:\nConsidering the size of dataset we got and the data structure we had I can confidently say that 86% ACCURACY is good. I am very sure that if I would be having more sufficent data and time to preprocess and to train well my model I would reach up to 98% accuracy!.","a8eabef0":"From the Above analysis we can see that the trend is likely to be the same for men and women in a way of being active or having a card or not but as we can see the Female are more likely to exit comparing to the men.\n","def5f14f":"The precision is intuitively the ability of the classifier to not label a sample as positive if it is negative.The recall is intuitively the ability of the classifier to find all the positive samples.\nThe F-beta score weights the recall more than the precision by a factor of beta. beta = 1.0 means recall and precision are equally important. The support is the number of occurrences of each class in y_test.","e7e2a290":"# # 1. Logistic regression MODEL ","cb2e8337":"Oh! in real life I was expecting these two variables to be more correlated but they are not!!\nThis gives me an idea on how the data might hold some new different amazing relationship! ","590405d4":"## Introduction\nGreetings from the Kaggle bot! This is an automatically-generated kernel with starter code demonstrating how to read in the data and begin exploring. If you're inspired to dig deeper, click the blue \"Fork Notebook\" button at the top of this kernel to begin editing.","1c9f6473":"# Cross-validation","87ddbe62":"1. # #MODEL SELECTION\nAs we have the pre-defined label then we will be doing a **Supervised learning**","d494890d":"From the dataset we have we can easily throw out the unimportant columns for our prediction..\nFollowing are column that are obvious that has no help on prediction:\n- RowNumber\n- CustomerId\n- Surname\n\nWe will simply ignore them and they might come back when we want to identify what customer we've predicted","5705d302":"Scatter and density plots:","2468bbd4":"Supervised learning is the task of inferring a function from labeled training data. By fitting to the labeled training set, we want to find the most optimal model parameters to predict unknown labels on other objects.","a4cc9467":"As now we have the idea on what is in the data basically, We know that in machine learning, before running any algorithm in our dataset we need to divide our dataset into two sets one called training_set and another test_set. This splitting helps us to prevent Overfiiting or Underfitting of our machine learning model."}}