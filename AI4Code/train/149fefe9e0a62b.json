{"cell_type":{"93adcce1":"code","c06434b1":"code","99ff5640":"code","d5bf900e":"code","5590dde0":"code","2c45faf2":"code","38fcc23d":"code","7b35a129":"code","e20e0cd1":"code","7b0f463d":"code","c0a88eb0":"code","91e343b8":"code","cc721bc8":"code","7b71b11f":"code","89dd2cd4":"code","be1d7fea":"code","261401e8":"code","ba2823aa":"code","e812e4ef":"code","6ef6512a":"code","a0689a22":"code","010b6e60":"code","4b8d4fb1":"code","9e08f3bc":"code","c30d90af":"code","c534dbf2":"markdown","2dec8381":"markdown","9ef0a703":"markdown","1f51de59":"markdown","c9fb43c1":"markdown","9e8d1c01":"markdown"},"source":{"93adcce1":"import numpy as np\nimport pandas as pd\nimport datetime\nfrom catboost import CatBoostClassifier\nfrom time import time\nfrom tqdm import tqdm_notebook as tqdm\nfrom collections import Counter\nfrom scipy import stats","c06434b1":"from sklearn.metrics import confusion_matrix\n# this function is the quadratic weighted kappa (the metric used for the competition submission)\ndef qwk(act,pred,n=4,hist_range=(0,3)):\n    \n    # Calculate the percent each class was tagged each label\n    O = confusion_matrix(act,pred)\n    # normalize to sum 1\n    O = np.divide(O,np.sum(O))\n    \n    # create a new matrix of zeroes that match the size of the confusion matrix\n    # this matriz looks as a weight matrix that give more weight to the corrects\n    W = np.zeros((n,n))\n    for i in range(n):\n        for j in range(n):\n            # makes a weird matrix that is bigger in the corners top-right and botton-left (= 1)\n            W[i][j] = ((i-j)**2)\/((n-1)**2)\n            \n    # make two histograms of the categories real X prediction\n    act_hist = np.histogram(act,bins=n,range=hist_range)[0]\n    prd_hist = np.histogram(pred,bins=n,range=hist_range)[0]\n    \n    # multiply the two histograms using outer product\n    E = np.outer(act_hist,prd_hist)\n    E = np.divide(E,np.sum(E)) # normalize to sum 1\n    \n    # apply the weights to the confusion matrix\n    num = np.sum(np.multiply(W,O))\n    # apply the weights to the histograms\n    den = np.sum(np.multiply(W,E))\n    \n    return 1-np.divide(num,den)\n    ","99ff5640":"train = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/train.csv')\ntrain_labels = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/train_labels.csv')\nspecs = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/specs.csv')\ntest = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/test.csv')\nsubmission = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/sample_submission.csv')","d5bf900e":"# encode title\n# make a list with all the unique 'titles' from the train and test set\nlist_of_user_activities = list(set(train['title'].value_counts().index).union(set(test['title'].value_counts().index)))\n# make a list with all the unique 'event_code' from the train and test set\nlist_of_event_code = list(set(train['event_code'].value_counts().index).union(set(test['event_code'].value_counts().index)))\n# create a dictionary numerating the titles\nactivities_map = dict(zip(list_of_user_activities, np.arange(len(list_of_user_activities))))\nactivities_labels = dict(zip(np.arange(len(list_of_user_activities)), list_of_user_activities))\n\n# replace the text titles withing the number titles from the dict\ntrain['title'] = train['title'].map(activities_map)\ntest['title'] = test['title'].map(activities_map)\ntrain_labels['title'] = train_labels['title'].map(activities_map)","5590dde0":"train[\"event_code\"].value_counts()","2c45faf2":"# I didnt undestud why, but this one makes a dict where the value of each element is 4100 \nwin_code = dict(zip(activities_map.values(), (4100*np.ones(len(activities_map))).astype('int')))\n# then, it set one element, the 'Bird Measurer (Assessment)' as 4110, 10 more than the rest\nwin_code[activities_map['Bird Measurer (Assessment)']] = 4110","38fcc23d":"win_code[activities_map['Bird Measurer (Assessment)']]","7b35a129":"# convert text into datetime\ntrain['timestamp'] = pd.to_datetime(train['timestamp'])\ntest['timestamp'] = pd.to_datetime(test['timestamp'])","e20e0cd1":"train.head()","7b0f463d":"time_spent_each_act = {actv: 0 for actv in list_of_user_activities}\nprint(time_spent_each_act)","c0a88eb0":"# this is the function that convert the raw data into processed features\ndef get_data(user_sample, test_set=False):\n    '''\n    The user_sample is a DataFrame from train or test where the only one \n    installation_id is filtered\n    And the test_set parameter is related with the labels processing, that is only requered\n    if test_set=False\n    '''\n    # Constants and parameters declaration\n    last_activity = 0\n    user_activities_count = {'Clip':0, 'Activity': 0, 'Assessment': 0, 'Game':0}\n    \n    # news features: time spent in each activity\n    time_spent_each_act = {actv: 0 for actv in list_of_user_activities}\n    event_code_count = {eve: 0 for eve in list_of_event_code}\n    last_session_time_sec = 0\n    \n    accuracy_groups = {0:0, 1:0, 2:0, 3:0}\n    all_assessments = []\n    accumulated_accuracy_group = 0\n    accumulated_accuracy=0\n    accumulated_correct_attempts = 0 \n    accumulated_uncorrect_attempts = 0 \n    accumulated_actions = 0\n    counter = 0\n    time_first_activity = float(user_sample['timestamp'].values[0])\n    durations = []\n    \n    # itarates through each session of one instalation_id\n    for i, session in user_sample.groupby('game_session', sort=False):\n        # i = game_session_id\n        # session is a DataFrame that contain only one game_session\n        \n        # get some sessions information\n        session_type = session['type'].iloc[0]\n        session_title = session['title'].iloc[0]\n        \n        # get current session time in seconds\n        if session_type != 'Assessment':\n            time_spent = int(session['game_time'].iloc[-1] \/ 1000)\n            time_spent_each_act[activities_labels[session_title]] += time_spent\n        \n        # for each assessment, and only this kind off session, the features below are processed\n        # and a register are generated\n        if (session_type == 'Assessment') & (test_set or len(session)>1):\n            # search for event_code 4100, that represents the assessments trial\n            all_attempts = session.query(f'event_code == {win_code[session_title]}')\n            # then, check the numbers of wins and the number of losses\n            true_attempts = all_attempts['event_data'].str.contains('true').sum()\n            false_attempts = all_attempts['event_data'].str.contains('false').sum()\n            # copy a dict to use as feature template, it's initialized with some itens: \n            # {'Clip':0, 'Activity': 0, 'Assessment': 0, 'Game':0}\n            features = user_activities_count.copy()\n            features.update(time_spent_each_act.copy())\n            features.update(event_code_count.copy())\n            # add title as feature, remembering that title represents the name of the game\n            features['session_title'] = session['title'].iloc[0] \n            # the 4 lines below add the feature of the history of the trials of this player\n            # this is based on the all time attempts so far, at the moment of this assessment\n            features['accumulated_correct_attempts'] = accumulated_correct_attempts\n            features['accumulated_uncorrect_attempts'] = accumulated_uncorrect_attempts\n            accumulated_correct_attempts += true_attempts \n            accumulated_uncorrect_attempts += false_attempts\n            # the time spent in the app so far\n            if durations == []:\n                features['duration_mean'] = 0\n            else:\n                features['duration_mean'] = np.mean(durations)\n            durations.append((session.iloc[-1, 2] - session.iloc[0, 2] ).seconds)\n            # the accurace is the all time wins divided by the all time attempts\n            features['accumulated_accuracy'] = accumulated_accuracy\/counter if counter > 0 else 0\n            accuracy = true_attempts\/(true_attempts+false_attempts) if (true_attempts+false_attempts) != 0 else 0\n            accumulated_accuracy += accuracy\n            # a feature of the current accuracy categorized\n            # it is a counter of how many times this player was in each accuracy group\n            if accuracy == 0:\n                features['accuracy_group'] = 0\n            elif accuracy == 1:\n                features['accuracy_group'] = 3\n            elif accuracy == 0.5:\n                features['accuracy_group'] = 2\n            else:\n                features['accuracy_group'] = 1\n            features.update(accuracy_groups)\n            accuracy_groups[features['accuracy_group']] += 1\n            # mean of the all accuracy groups of this player\n            features['accumulated_accuracy_group'] = accumulated_accuracy_group\/counter if counter > 0 else 0\n            accumulated_accuracy_group += features['accuracy_group']\n            # how many actions the player has done so far, it is initialized as 0 and updated some lines below\n            features['accumulated_actions'] = accumulated_actions\n            \n            # there are some conditions to allow this features to be inserted in the datasets\n            # if it's a test set, all sessions belong to the final dataset\n            # it it's a train, needs to be passed throught this clausule: session.query(f'event_code == {win_code[session_title]}')\n            # that means, must exist an event_code 4100 or 4110\n            if test_set:\n                all_assessments.append(features)\n            elif true_attempts+false_attempts > 0:\n                all_assessments.append(features)\n                \n            counter += 1\n        \n        # this piece counts how many actions was made in each event_code so far\n        n_of_event_codes = Counter(session['event_code'])\n        \n        for key in n_of_event_codes.keys():\n            event_code_count[key] += n_of_event_codes[key]\n\n        # counts how many actions the player has done so far, used in the feature of the same name\n        accumulated_actions += len(session)\n        if last_activity != session_type:\n            user_activities_count[session_type] += 1\n            last_activitiy = session_type\n    # if it't the test_set, only the last assessment must be predicted, the previous are scraped\n    if test_set:\n        return all_assessments[-1]\n    # in the train_set, all assessments goes to the dataset\n    return all_assessments","91e343b8":"# here the get_data function is applyed to each installation_id and added to the compile_data list\ncompiled_data = []\n# tqdm is the library that draws the status bar below\nfor i, (ins_id, user_sample) in tqdm(enumerate(train.groupby('installation_id', sort=False)), total=17000):\n    # user_sample is a DataFrame that contains only one installation_id\n    compiled_data += get_data(user_sample)","cc721bc8":"# the compiled_data is converted to DataFrame and deleted to save memmory\nnew_train = pd.DataFrame(compiled_data)\ndel compiled_data\nnew_train.shape","7b71b11f":"pd.set_option('display.max_columns', None)\nnew_train[:10]","89dd2cd4":"# this list comprehension create the list of features that will be used on the input dataset X\n# all but accuracy_group, that is the label y\nall_features = [x for x in new_train.columns if x not in ['accuracy_group']]\n# this cat_feature must be declared to pass later as parameter to fit the model\ncat_features = ['session_title']\n# here the dataset select the features and split the input ant the labels\nX, y = new_train[all_features], new_train['accuracy_group']\ndel train\nX.shape","be1d7fea":"# this function makes the model and sets the parameters\n# for configure others parameter consult the documentation below:\n# https:\/\/catboost.ai\/docs\/concepts\/python-reference_catboostclassifier.html\ndef make_classifier(iterations=6000):\n    clf = CatBoostClassifier(\n                               loss_function='MultiClass',\n                                eval_metric=\"WKappa\",\n                               task_type=\"CPU\",\n                               #learning_rate=0.01,\n                               iterations=iterations,\n                               od_type=\"Iter\",\n                                #depth=4,\n                               early_stopping_rounds=500,\n                                #l2_leaf_reg=10,\n                                #border_count=96,\n                               random_seed=42,\n                                #use_best_model=use_best_model\n                              )\n        \n    return clf","261401e8":"# CV\nfrom sklearn.model_selection import KFold\n# oof is an zeroed array of the same size of the input dataset\noof = np.zeros(len(X))\nNFOLDS = 5\n# here the KFold class is used to split the dataset in 5 diferents training and validation sets\n# this technique is used to assure that the model isn't overfitting and can performs aswell in \n# unseen data. More the number of splits\/folds, less the test will be impacted by randomness\nfolds = KFold(n_splits=NFOLDS, shuffle=True, random_state=2019)\ntraining_start_time = time()\nmodels = []\nfor fold, (trn_idx, test_idx) in enumerate(folds.split(X, y)):\n    # each iteration of folds.split returns an array of indexes of the new training data and validation data\n    start_time = time()\n    print(f'Training on fold {fold+1}')\n    # creates the model\n    clf = make_classifier()\n    # fits the model using .loc at the full dataset to select the splits indexes and features used\n    clf.fit(X.loc[trn_idx, all_features], y.loc[trn_idx], eval_set=(X.loc[test_idx, all_features], y.loc[test_idx]),\n                          use_best_model=True, verbose=500, cat_features=cat_features)\n    \n    # then, the predictions of each split is inserted into the oof array\n    oof[test_idx] = clf.predict(X.loc[test_idx, all_features]).reshape(len(test_idx))\n    models.append(clf)\n    print('Fold {} finished in {}'.format(fold + 1, str(datetime.timedelta(seconds=time() - start_time))))\n    print('____________________________________________________________________________________________\\n')\n    #break\n    \nprint('-' * 30)\n# and here, the complete oof is tested against the real data using que metric (quadratic weighted kappa)\nprint('OOF QWK:', qwk(y, oof))\nprint('-' * 30)","ba2823aa":"# train model on all data once\n#clf = make_classifier()\n#clf.fit(X, y, verbose=500, cat_features=cat_features)\n\ndel X, y","e812e4ef":"# process test set, the same that was done with the train set\nnew_test = []\nfor ins_id, user_sample in tqdm(test.groupby('installation_id', sort=False), total=1000):\n    a = get_data(user_sample, test_set=True)\n    new_test.append(a)\n    \nX_test = pd.DataFrame(new_test)\ndel test","6ef6512a":"# make predictions on test set once\npredictions = []\nfor model in models:\n    predictions.append(model.predict(X_test))\npredictions = np.concatenate(predictions, axis=1)\nprint(predictions.shape)\npredictions = stats.mode(predictions, axis=1)[0].reshape(-1)\nprint(predictions.shape)\n#del X_test","a0689a22":"submission['accuracy_group'] = np.round(predictions).astype('int')\nsubmission.to_csv('submission.csv', index=None)\nsubmission.head()","010b6e60":"from IPython.display import HTML\nimport pandas as pd\nimport numpy as np\nimport base64\n\n# function that takes in a dataframe and creates a text link to  \n# download it (will only work for files < 2MB or so)\ndef create_download_link(df, title = \"Download CSV file\", filename = \"sample_submission9.csv\"):  \n    csv = df.to_csv()\n    b64 = base64.b64encode(csv.encode())\n    payload = b64.decode()\n    html = '<a download=\"{filename}\" href=\"data:text\/csv;base64,{payload}\" target=\"_blank\">{title}<\/a>'\n    html = html.format(payload=payload,title=title,filename=filename)\n    return HTML(html)\n\n# create a random sample dataframe\n# df = pd.DataFrame(np.random.randn(50, 4), columns=list('ABCD'))\n\n# create a link to download the dataframe\ncreate_download_link(submission)","4b8d4fb1":"submission['accuracy_group'].plot(kind='hist')","9e08f3bc":"train_labels['accuracy_group'].plot(kind='hist')","c30d90af":"pd.Series(oof).plot(kind='hist')","c534dbf2":"## Make submission","2dec8381":"## Model","9ef0a703":"### Kernel creator notes  \n\nI had posted my very naive baseline at https:\/\/www.kaggle.com\/mhviraf\/a-baseline-for-dsb-2019. In that kernel I only used the mode label for each Assessment and I thought it should be very easy to beat. This kernel shows how you can beat that baseline by actually applying a model. In this kernel via `get_data()` function, I go over each `installation_id` and try to extract some features based on his\/her behavior prior to the assessment. I will then train a `Catboost` classifier on it and make predictions on the test set. Note that the features I made in this kernel are so very basic and you can easily add many more to it. Good luck and happy kaggling. Don't forget to upvote if you found it useful ;)","1f51de59":"### Commentator notes  \n\nThis kernel isn't mine, so, if you liked it, upvote this official one made by Massoud Hosseinali: https:\/\/www.kaggle.com\/mhviraf\/a-new-baseline-for-dsb-2019-catboost-model  \nI find this kernel so good and elegant, and also is the top score public on this competition, then I decided to use it as baseline for my attempts, so I have scrutinated the whole notebook and left comments on almost each line.  \nI think this comments can help who wants to use it as baseline aswell, I hope you enjoy the comments and forgive me the english errors.  \n  \nMassoud, if you see any problem doing this, or any error in my comments, tell me please. And congratulations for this kernel.   ","c9fb43c1":"### Update notes  \n\nI have added some new very simple features to this kernel:  \n1. How much time was spent in each Title  \n2. How many actions was registered in each event_code  ","9e8d1c01":"Below are the features I have generated. Note that all of them are **prior** to each event. For example, the first row shows **before** this assessment, the player have watched 3 clips, did 3 activities, played 4 games and solved 0 assessments, so on so forth."}}