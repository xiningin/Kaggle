{"cell_type":{"ca2b3320":"code","8b97b7b3":"code","0fa12dcd":"code","c8c7eb09":"code","5634bd25":"code","220b6d35":"code","3f4c2bd4":"code","72fdf583":"code","9293f34f":"code","048c0045":"code","099628a0":"code","32dc8c94":"code","e489bd6b":"code","486d7dba":"code","3a859207":"code","aca3f529":"code","ea847549":"code","d742ff17":"code","c08f8cf5":"code","360f373b":"code","7039d9d0":"code","665106fa":"code","85fc9684":"markdown","d8f3023f":"markdown","37d18f56":"markdown","3f5b47bd":"markdown","24639c05":"markdown","b718c52d":"markdown","5810f1d5":"markdown","d2579ec1":"markdown","53811719":"markdown","10808dc8":"markdown","c4c936e5":"markdown","9912a3dc":"markdown","a56e1c0e":"markdown","1ece097b":"markdown","4b7f791b":"markdown"},"source":{"ca2b3320":"import torch \nimport torch.nn as nn\nimport torchvision\nimport torchvision.transforms as transforms\nimport torchvision.datasets as dsets\nimport torch.nn.functional as F\nimport matplotlib.pylab as plt\nimport numpy as np\ntorch.manual_seed(2)\n\nimport warnings\nwarnings.filterwarnings('ignore')","8b97b7b3":"class Net(nn.Module):\n    \n    # Constructor\n    def __init__(self, D_in, H1, H2, D_out):\n        super(Net, self).__init__()\n        self.linear1 = nn.Linear(D_in, H1)\n        self.linear2 = nn.Linear(H1, H2)\n        self.linear3 = nn.Linear(H2, D_out)\n    \n    # Prediction\n    def forward(self,x):\n        x = torch.sigmoid(self.linear1(x)) \n        x = torch.sigmoid(self.linear2(x))\n        x = self.linear3(x)\n        return x","0fa12dcd":"class NetTanh(nn.Module):\n    \n    # Constructor\n    def __init__(self, D_in, H1, H2, D_out):\n        super(NetTanh, self).__init__()\n        self.linear1 = nn.Linear(D_in, H1)\n        self.linear2 = nn.Linear(H1, H2)\n        self.linear3 = nn.Linear(H2, D_out)\n    \n    # Prediction\n    def forward(self, x):\n        x = torch.tanh(self.linear1(x))\n        x = torch.tanh(self.linear2(x))\n        x = self.linear3(x)\n        return x","c8c7eb09":"class NetRelu(nn.Module):\n    \n    # Constructor\n    def __init__(self, D_in, H1, H2, D_out):\n        super(NetRelu, self).__init__()\n        self.linear1 = nn.Linear(D_in, H1)\n        self.linear2 = nn.Linear(H1, H2)\n        self.linear3 = nn.Linear(H2, D_out)\n    \n    # Prediction\n    def forward(self, x):\n        x = torch.relu(self.linear1(x))  \n        x = torch.relu(self.linear2(x))\n        x = self.linear3(x)\n        return x","5634bd25":"def train(model, criterion, train_loader, validation_loader, optimizer, epochs=100):\n    i = 0\n    useful_stuff = {'training_loss': [], 'validation_accuracy': []}  \n    \n    for epoch in range(epochs):\n        for i, (x, y) in enumerate(train_loader):\n            optimizer.zero_grad()\n            z = model(x.view(-1, 28 * 28))\n            loss = criterion(z, y)\n            loss.backward()\n            optimizer.step()\n            useful_stuff['training_loss'].append(loss.data.item())\n        \n        correct = 0\n        for x, y in validation_loader:\n            z = model(x.view(-1, 28 * 28))\n            _, label = torch.max(z, 1)\n            correct += (label == y).sum().item()\n    \n        accuracy = 100 * (correct \/ len(validation_loader))\n        useful_stuff['validation_accuracy'].append(accuracy)\n    \n    return useful_stuff","220b6d35":"train_set = torchvision.datasets.FashionMNIST(\".\/data\", download=True, transform=\n                                                transforms.Compose([transforms.ToTensor()]))\ntest_set = torchvision.datasets.FashionMNIST(\".\/data\", download=True, train=False, transform=\n                                               transforms.Compose([transforms.ToTensor()]))","3f4c2bd4":"train_loader = torch.utils.data.DataLoader(train_set, batch_size=100)\nvalidation_loader = torch.utils.data.DataLoader(test_set, batch_size=100)","72fdf583":"def output_label(label):\n    output_mapping = {\n                 0: \"T-shirt\/Top\",\n                 1: \"Trouser\",\n                 2: \"Pullover\",\n                 3: \"Dress\",\n                 4: \"Coat\", \n                 5: \"Sandal\", \n                 6: \"Shirt\",\n                 7: \"Sneaker\",\n                 8: \"Bag\",\n                 9: \"Ankle Boot\"\n                 }\n    input = (label.item() if type(label) == torch.Tensor else label)\n    return output_mapping[input]","9293f34f":"a = next(iter(train_loader))\na[0].size()","048c0045":"len(train_set)","099628a0":"image, label = next(iter(train_set))\nplt.imshow(image.squeeze(), cmap=\"gray\")\nprint(label)","32dc8c94":"demo_loader = torch.utils.data.DataLoader(train_set, batch_size=10)\n\nbatch = next(iter(demo_loader))\nimages, labels = batch\nprint(type(images), type(labels))\nprint(images.shape, labels.shape)","e489bd6b":"grid = torchvision.utils.make_grid(images, nrow=10)\n\nplt.figure(figsize=(15, 20))\nplt.imshow(np.transpose(grid, (1, 2, 0)))\nprint(\"labels: \", end=\" \")\nfor i, label in enumerate(labels):\n    print(output_label(label), end=\", \")","486d7dba":"criterion = nn.CrossEntropyLoss()","3a859207":"input_dim = 28 * 28\nhidden_dim1 = 50\nhidden_dim2 = 50\noutput_dim = 10","aca3f529":"cust_epochs = 10","ea847549":"learning_rate = 0.01\nmodel = Net(input_dim, hidden_dim1, hidden_dim2, output_dim)\noptimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)\ntraining_results = train(model, criterion, train_loader, validation_loader, optimizer, epochs=cust_epochs)","d742ff17":"print(training_results)","c08f8cf5":"learning_rate = 0.01\nmodelRelu = NetRelu(input_dim, hidden_dim1, hidden_dim2, output_dim)\noptimizer = torch.optim.SGD(modelRelu.parameters(), lr=learning_rate)\ntraining_results_relu = train(modelRelu, criterion, train_loader, validation_loader, optimizer, epochs=cust_epochs)","360f373b":"learning_rate = 0.01\nmodelTanh = NetTanh(input_dim, hidden_dim1, hidden_dim2, output_dim)\noptimizer = torch.optim.SGD(modelRelu.parameters(), lr=learning_rate)\ntraining_results_tanh = train(modelRelu, criterion, train_loader, validation_loader, optimizer, epochs=cust_epochs)","7039d9d0":"plt.figure(figsize=(8,4))\nplt.plot(training_results_tanh['training_loss'], label='tanh')\nplt.plot(training_results['training_loss'], label='sigmoid')\nplt.plot(training_results_relu['training_loss'], label='relu')\nplt.ylabel('loss')\nplt.xlabel('Samples of Training')\nplt.title('training loss iterations')\nplt.legend()\nplt.show()","665106fa":"plt.figure(figsize=(8,4))\nplt.grid()\nplt.plot(training_results_tanh['validation_accuracy'], label = 'tanh')\nplt.plot(training_results['validation_accuracy'], label = 'sigmoid')\nplt.plot(training_results_relu['validation_accuracy'], label = 'relu') \nplt.ylabel('validation accuracy')\nplt.title('Accuracy Using different Activation Functions')\nplt.xlabel('Iteration')   \nplt.legend()\nplt.show()","85fc9684":"# Neural Network Module and Training Function","d8f3023f":"Load the testing dataset by setting the parameters train to False and convert it to a tensor by placing a transform object int the argument transform","37d18f56":"# Training fro Tanh Function","3f5b47bd":"# Analyzing Results","24639c05":"# 1 - Class with Sigmoid","b718c52d":"Load the training dataset by setting the parameters train to True and convert it to a tensor by placing a transform object int the argument transform","5810f1d5":"# Training fro ReLu Function","d2579ec1":"<h3><center> <font color='maroon'> Upvote , if it helps you :-) <\/center><\/font> <\/h3>","53811719":"# 3 - Class with ReLU","10808dc8":"# Training for Sigmoid Function","c4c936e5":"Define a function to train the model, in this case the function returns a Python dictionary to store the training loss and accuracy on the validation data","9912a3dc":"# 2 - Class with the Tanh","a56e1c0e":"<h3><center> <font color='maroon'> Upvote , if it helps you :-) <\/center><\/font> <\/h3>","1ece097b":"# Apply PyTorch on Fashion MNIST Using ReLU, Sigmoid, Tanh","4b7f791b":"# Define Neural Network, Criterion function, Optimizer and Train the Model"}}