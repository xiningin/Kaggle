{"cell_type":{"8ac578d1":"code","31d13c16":"code","63279c3a":"code","9ad0f6f6":"code","a928d149":"code","1b6755fd":"code","c1de1331":"code","88b7118f":"code","968dca9b":"code","64880aeb":"code","fc9e43bd":"code","3bb9e8e7":"code","f1db9104":"code","b6c3a4fd":"code","b3c2363d":"code","4efefdd9":"code","303bf47c":"code","14cc0535":"code","a58d8add":"code","9474ce9c":"code","e3ecfb36":"code","e3aa1f2a":"code","b971713d":"code","51fd479b":"code","2878218e":"code","d693e044":"code","7df32c01":"code","737f066c":"code","90b08f16":"code","ed2f9e06":"code","f2481ee1":"code","07a02a29":"code","d5bb795b":"code","59fa8f4b":"code","107eabcf":"code","51ba1cf9":"code","d5c06082":"code","1bfdd6f7":"code","6be8688c":"code","310179d5":"code","60561d09":"code","9651399f":"code","93dcb1c2":"code","3b78121f":"code","636f44fe":"code","88a24076":"code","6eec3f72":"code","d8a98bd0":"markdown","b1975daa":"markdown","ddfaf197":"markdown","ea32f44a":"markdown","73a508d0":"markdown","fc6fb85c":"markdown","d4c6636c":"markdown","c50232bd":"markdown","a9d01539":"markdown","f9288711":"markdown","bfab4f51":"markdown","797a9777":"markdown","08f39b5f":"markdown","9d7a1210":"markdown","62ba8722":"markdown","ce9e7de7":"markdown","402bc512":"markdown","78f1e4d4":"markdown","fc97cf3d":"markdown","b69812c7":"markdown","58f43405":"markdown","e7d26cb8":"markdown","8cd68a6d":"markdown","70fafec1":"markdown","62f5d34f":"markdown","625d15d2":"markdown","1c17ee27":"markdown","e7d2bebd":"markdown","a218cfa2":"markdown","b64277c2":"markdown","8a6fc51f":"markdown","ac3e326f":"markdown","fef10e3a":"markdown","dae26757":"markdown"},"source":{"8ac578d1":"import pandas as pd\nimport numpy as np\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nplt.style.use('seaborn')\nsns.set(font_scale=1.8)\n\nimport plotly.offline as py\nfrom plotly import tools\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport missingno as msno\nimport random\n\nfrom plotly import tools\n\n# Supress unnecessary warnings so that presentation looks clean\nimport warnings\nwarnings.filterwarnings(\"ignore\")","31d13c16":"df_app = pd.read_csv('..\/input\/AppleStore.csv')\ndf_description = pd.read_csv('..\/input\/appleStore_description.csv')","63279c3a":"df_app.isnull().sum()","9ad0f6f6":"df_description.head()","a928d149":"df_description.isnull().sum()","1b6755fd":"df_app['app_desc'] = df_description['app_desc']","c1de1331":"df_app = df_app.iloc[:, 1:]","88b7118f":"df_app.head()","968dca9b":"df_app['size_bytes_in_MB'] = df_app['size_bytes'] \/ (1024 * 1024.0)","64880aeb":"df_app['isNotFree'] = df_app['price'].apply(lambda x: 1 if x > 0 else 0)","fc9e43bd":"df_app['isNotFree'].value_counts().plot.bar()\nplt.xlabel('IsNotFree(Free == 0, NotFree == 1)')\nplt.ylabel('Count')\nplt.show()","3bb9e8e7":"df_app_notfree = df_app[df_app['isNotFree'] == 1]\ndf_app_free = df_app[df_app['isNotFree'] == 0]\n\nprint('There are {} Not-Free Apps in this dataset'.format(df_app_notfree.shape[0]))\nprint('There are {} Free Apps in this dataset'.format(df_app_free.shape[0]))","f1db9104":"def random_color_generator(number_of_colors):\n    color = [\"#\"+''.join([random.choice('0123456789ABCDEF') for j in range(6)])\n                 for i in range(number_of_colors)]\n    return color\n\ncnt_srs = df_app['prime_genre'].value_counts()\ntext = ['{:.2f}%'.format(100 * (value \/ cnt_srs.sum())) for value in cnt_srs.values]\n\ntrace = go.Bar(\n    x = cnt_srs.index,\n    y = cnt_srs.values,\n    text = text,\n    marker = dict(\n        color = random_color_generator(100),\n        line = dict(color='rgb(8, 48, 107)',\n                    width = 1.5)\n    ),\n    opacity = 0.7\n)\ndata = [trace]\n\nlayout = go.Layout(\n    title = 'Prime genre',\n    margin = dict(\n        l = 100\n    ),\n    xaxis = dict(\n        title = 'Genre'\n    ),\n    yaxis = dict(\n        title = 'Count'\n    ),\n    width = 800,\n    height = 500\n)\n\nfig = go.Figure(data=data, layout=layout)\npy.iplot(fig)","b6c3a4fd":"cnt_srs1 = df_app_free['prime_genre'].value_counts()\ntext1 = ['{:.2f}%'.format(100 * (value \/ cnt_srs1.sum())) for value in cnt_srs1.values]\n\ntrace1 = go.Bar(\n    x = cnt_srs1.index,\n    y = cnt_srs1.values,\n    text = text1,\n    marker = dict(\n        color = random_color_generator(100),\n        line = dict(color='rgb(8, 48, 107)',\n                    width = 1.5)\n    ),\n    opacity = 0.7\n)\n\ncnt_srs2 = df_app_notfree['prime_genre'].value_counts()\ntext2 = ['{:.2f}%'.format(100 * (value \/ cnt_srs2.sum())) for value in cnt_srs2.values]\n\ntrace2 = go.Bar(\n    x = cnt_srs2.index,\n    y = cnt_srs2.values,\n    text = text2,\n    marker = dict(\n        color = random_color_generator(100),\n        line = dict(color='rgb(8, 48, 107)',\n                    width = 1.5)\n    ),\n    opacity = 0.7\n)\n\ntrace3 = go.Bar(\n    x = cnt_srs1.index,\n    y = cnt_srs1.values,\n    text = text1,\n    opacity = 0.7,\n    name='Free'\n)\n\n\ntrace4 = go.Bar(\n    x = cnt_srs2.index,\n    y = cnt_srs2.values,\n    text = text2,\n    opacity = 0.7,\n    name='Not-Free'\n)\n\n\n\nfig = tools.make_subplots(rows=2, cols=2, specs = [[{}, {}], [{'colspan':2}, None]], \n                          subplot_titles=('(1) Countplot for Prime_genre of Free', '(2) Countplot for Prime_genre of Not-Free', \n                                          '(3) Grouped barplot containing Free(green) and Not-Free(red)'), print_grid=False)\nfig.append_trace(trace1, 1, 1)\nfig.append_trace(trace2, 1, 2)\nfig.append_trace(trace3, 2, 1)\nfig.append_trace(trace4, 2, 1)\n\nfig['layout']['yaxis1'].update(title='Count')\nfig['layout']['yaxis2'].update(title='Count')\nfig['layout']['yaxis3'].update(title='Count')\n\nfig['layout'].update(showlegend=False, width=800, height=800)\n\npy.iplot(fig)","b3c2363d":"for app in df_app.loc[(df_app['isNotFree'] == 1) & (df_app['prime_genre'] == 'Social Networking'), 'track_name'].values:\n    print(app)","4efefdd9":"cnt_srs = df_app[['prime_genre', 'user_rating']].groupby('prime_genre').mean()['user_rating'].sort_values(ascending=False)\n\ntrace = go.Bar(\n    x = cnt_srs.index,\n    y = cnt_srs.values,\n    marker = dict(\n        color = random_color_generator(100),\n        line = dict(color='rgb(8, 48, 107)',\n                    width = 1.5)\n    ),\n    opacity = 0.7\n)\ndata = [trace]\n\nlayout = go.Layout(\n    title = 'User rating depending on Prime genre',\n    margin = dict(\n        l = 100\n    ),\n    xaxis = dict(\n        title = 'Genre'\n    ),\n    yaxis = dict(\n        title = 'Mean User Rating'\n    ),\n    width = 800,\n    height = 500\n)\n\nfig = go.Figure(data=data, layout=layout)\npy.iplot(fig)","303bf47c":"cnt_srs1 = df_app_free[['prime_genre', 'user_rating']].groupby('prime_genre').mean()['user_rating'].sort_values(ascending=False)\ntext1 = ['{:.2f}%'.format(100 * (value \/ cnt_srs1.sum())) for value in cnt_srs1.values]\n\ntrace1 = go.Bar(\n    x = cnt_srs1.index,\n    y = cnt_srs1.values,\n    marker = dict(\n        color = random_color_generator(100),\n        line = dict(color='rgb(8, 48, 107)',\n                    width = 1.5)\n    ),\n    opacity = 0.7\n)\n\ncnt_srs2 = df_app_notfree[['prime_genre', 'user_rating']].groupby('prime_genre').mean()['user_rating'].sort_values(ascending=False)\ntext2 = ['{:.2f}%'.format(100 * (value \/ cnt_srs2.sum())) for value in cnt_srs2.values]\n\ntrace2 = go.Bar(\n    x = cnt_srs2.index,\n    y = cnt_srs2.values,\n    marker = dict(\n        color = random_color_generator(100),\n        line = dict(color='rgb(8, 48, 107)',\n                    width = 1.5)\n    ),\n    opacity = 0.7\n)\n\ntrace3 = go.Bar(\n    x = cnt_srs1.index,\n    y = cnt_srs1.values,\n    opacity = 0.7,\n    name='Free'\n)\n\n\ntrace4 = go.Bar(\n    x = cnt_srs2.index,\n    y = cnt_srs2.values,\n    opacity = 0.7,\n    name='Not-Free'\n)\n\n\n\nfig = tools.make_subplots(rows=2, cols=2, specs = [[{}, {}], [{'colspan':2}, None]], \n                          subplot_titles=('(1) Mean user rating of Free', '(2) Mean user rating of Not-Free', \n                                          '(3) Grouped barplot containing Free(green) and Not-Free(red)'), print_grid=False)\nfig.append_trace(trace1, 1, 1)\nfig.append_trace(trace2, 1, 2)\nfig.append_trace(trace3, 2, 1)\nfig.append_trace(trace4, 2, 1)\n\nfig['layout']['yaxis1'].update(title='Mean User Rating')\nfig['layout']['yaxis2'].update(title='Mean User Rating')\nfig['layout']['yaxis3'].update(title='Mean User Rating')\nfig['layout'].update(showlegend=False, width=800, height=800)\n\npy.iplot(fig)","14cc0535":"cnt_srs = df_app[['prime_genre', 'size_bytes_in_MB']].groupby('prime_genre').mean()['size_bytes_in_MB'].sort_values(ascending=False)\ntext = ['{:.2f}'.format(value) for value in cnt_srs.values]\n\ntrace = go.Bar(\n    x = cnt_srs.index,\n    y = cnt_srs.values,\n    marker = dict(\n        color = random_color_generator(100),\n        line = dict(color='rgb(8, 48, 107)',\n                    width = 1.5)\n    ),\n    opacity = 0.7\n)\ndata = [trace]\n\nlayout = go.Layout(\n    title = 'Mean App size(MB) depending on Prime genre',\n    margin = dict(\n        l = 100\n    ),\n    xaxis = dict(\n        title = 'Genre'\n    ),\n    yaxis = dict(\n        title = 'Mean App size'\n    ),\n    width = 800,\n    height = 500\n)\n\nfig = go.Figure(data=data, layout=layout)\npy.iplot(fig)","a58d8add":"cnt_srs1 = df_app_free[['prime_genre', 'size_bytes_in_MB']].groupby('prime_genre').mean()['size_bytes_in_MB'].sort_values(ascending=False)\ntext1 = ['{:.2f}%'.format(100 * (value \/ cnt_srs1.sum())) for value in cnt_srs1.values]\n\ntrace1 = go.Bar(\n    x = cnt_srs1.index,\n    y = cnt_srs1.values,\n    text = text1,\n    marker = dict(\n        color = random_color_generator(100),\n        line = dict(color='rgb(8, 48, 107)',\n                    width = 1.5)\n    ),\n    opacity = 0.7\n)\n\ncnt_srs2 = df_app_notfree[['prime_genre', 'size_bytes_in_MB']].groupby('prime_genre').mean()['size_bytes_in_MB'].sort_values(ascending=False)\ntext2 = ['{:.2f}%'.format(100 * (value \/ cnt_srs2.sum())) for value in cnt_srs2.values]\n\ntrace2 = go.Bar(\n    x = cnt_srs2.index,\n    y = cnt_srs2.values,\n    text = text2,\n    marker = dict(\n        color = random_color_generator(100),\n        line = dict(color='rgb(8, 48, 107)',\n                    width = 1.5)\n    ),\n    opacity = 0.7\n)\n\ntrace3 = go.Bar(\n    x = cnt_srs1.index,\n    y = cnt_srs1.values,\n    text = text1,\n    opacity = 0.7,\n    name='Free'\n)\n\n\ntrace4 = go.Bar(\n    x = cnt_srs2.index,\n    y = cnt_srs2.values,\n    text = text2,\n    opacity = 0.7,\n    name='Not-Free'\n)\n\n\n\nfig = tools.make_subplots(rows=2, cols=2, specs = [[{}, {}], [{'colspan':2}, None]], subplot_titles=('Free', 'Not-Free', 'third'), print_grid=False)\nfig = tools.make_subplots(rows=2, cols=2, specs = [[{}, {}], [{'colspan':2}, None]], \n                          subplot_titles=('(1) Mean App size(MB) of Free', '(2) Mean App size(MB) of Not-Free', \n                                          '(3) Grouped barplot containing Free(green) and Not-Free(red)'), print_grid=False)\n\nfig.append_trace(trace1, 1, 1)\nfig.append_trace(trace2, 1, 2)\nfig.append_trace(trace3, 2, 1)\nfig.append_trace(trace4, 2, 1)\n\nfig['layout']['yaxis1'].update(title='Mean App size(MB)')\nfig['layout']['yaxis2'].update(title='Mean App size(MB)')\nfig['layout']['yaxis3'].update(title='Mean App size(MB)')\nfig['layout'].update(showlegend=False, width=800, height=800)\n\npy.iplot(fig)","9474ce9c":"cnt_srs = df_app_notfree[['prime_genre', 'price']].groupby('prime_genre').mean()['price'].sort_values(ascending=False)\ntext = ['{:.2f}%'.format(100 * (value \/ cnt_srs.sum())) for value in cnt_srs.values]\n\ntrace = go.Bar(\n    x = cnt_srs.index,\n    y = cnt_srs.values,\n    text = text,\n    marker = dict(\n        color = random_color_generator(100),\n        line = dict(color='rgb(8, 48, 107)',\n                    width = 1.5)\n    ),\n    opacity = 0.7\n)\ndata = [trace]\n\nlayout = go.Layout(\n    title = 'Mean App price of Not-Free Apps',\n    margin = dict(\n        l = 100\n    ),\n    yaxis = dict(\n        title = 'Mean App price'\n    ),\n    width = 800,\n    height = 500\n)\n\nfig = go.Figure(data=data, layout=layout)\npy.iplot(fig)","e3ecfb36":"sns.lmplot(x='user_rating', y='user_rating_ver', hue='isNotFree', data=df_app)","e3aa1f2a":"df_temp = df_app.drop('id', axis=1)","b971713d":"data = [\n    go.Heatmap(\n        z = df_temp.corr().values,\n        x = df_temp.corr().columns.values,\n        y = df_temp.corr().columns.values,\n        colorscale='YlGnBu',\n        reversescale=False,\n    )\n]\n\nlayout = go.Layout(\n    title='Pearson Correlation of float-type features',\n    xaxis = dict(ticks=''),\n    yaxis = dict(ticks='' ),\n    width = 800, height = 800,\n    margin = dict(\n        l = 100\n    )\n)\n\nfig = go.Figure(data=data, layout=layout)\npy.iplot(fig, filename='labelled-heatmap')","51fd479b":"df_corr = df_app.drop('id', axis=1).corr()","2878218e":"df_corr['user_rating'].sort_values(ascending=False)","d693e044":"df_corr['price'].sort_values(ascending=False)","7df32c01":"plt.scatter(df_app['user_rating'], df_app['rating_count_ver'])","737f066c":"foo = df_app['app_desc'][0].split(' ')","90b08f16":"import nltk\nfrom nltk.corpus import stopwords","ed2f9e06":"%%time\nfor i in range(df_app.shape[0]):\n    temp_desc = df_app['app_desc'][i]\n    temp_word_list = nltk.word_tokenize(temp_desc)\n    temp_word_list = [word.lower() for word in temp_word_list if word not in stopwords.words('english')]\n    for char in \" {}()#&[]^`\u00b4-_\u00b7@|\u00bf?\u00a1!'+*\\\"?.!\/;:<>\u2019\u2022\u201c\u201d\u2013\u00bb%\u25a0,\":\n        for ele in temp_word_list:\n            if char in ele:\n                temp_word_list.remove(ele)\n    fdist = nltk.FreqDist(temp_word_list)\n    temp_srs = pd.Series(fdist).sort_values(ascending=False)\n    try:\n        df_app.loc[i, 'most_freq_word_1'] = temp_srs.index[0]\n        df_app.loc[i, 'most_freq_word_2'] = temp_srs.index[1]\n        df_app.loc[i, 'most_freq_word_3'] = temp_srs.index[2]\n    except:\n        df_app.loc[i, 'most_freq_word_1'] = temp_srs.index[0]","f2481ee1":"df_app.loc[df_app['user_rating'] > 4, 'most_freq_word_3'].value_counts().head(20).plot.bar()","07a02a29":"freq_total = nltk.FreqDist(df_app['most_freq_word_1'].tolist() + \n              df_app['most_freq_word_2'].tolist() +\n             df_app['most_freq_word_3'].tolist())","d5bb795b":"freq_total = pd.Series(freq_total).sort_values(ascending=False)","59fa8f4b":"freq_total.head(20).plot.bar()","107eabcf":"from sklearn.metrics import confusion_matrix\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.model_selection import train_test_split\nimport xgboost as xgb","51ba1cf9":"df_app['rating_count_before'] = df_app['rating_count_tot'] - df_app['rating_count_ver']","d5c06082":"df_app.head()","1bfdd6f7":"df_train = df_app[['size_bytes_in_MB', 'isNotFree', 'price', 'rating_count_before', 'sup_devices.num', 'ipadSc_urls.num', 'lang.num', 'vpp_lic', 'prime_genre']]\ntarget = df_app['user_rating']\n\ndf_train = pd.get_dummies(df_train)\n\ndef categorize_rating(x):\n    if x <= 4:\n        return 0\n    else:\n        return 1\n\ntarget = target.apply(categorize_rating)\n\ntarget.astype(str).hist()","6be8688c":"X_train, X_test, y_train, y_test = train_test_split(df_train.values, target, test_size=0.2, random_state=1989, stratify=target)\n\nprint('X_train shape:', X_train.shape)\nprint('X_test shape:', X_test.shape)","310179d5":"from sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import cross_val_score, cross_validate","60561d09":"from sklearn.ensemble import RandomForestClassifier\nfrom lightgbm import LGBMClassifier\nfrom xgboost import XGBClassifier","9651399f":"models = [RandomForestClassifier(), LGBMClassifier(), XGBClassifier()]\n\nkfold = KFold(n_splits=5, random_state=1989)\n\nclf_comparison = pd.DataFrame(columns=['Classfier_name', 'train_score', 'test_score'])\n\nfor i, model in enumerate(models):\n    clf = model\n    cv_result = cross_validate(model, X_train, y_train, cv=kfold, scoring='accuracy')\n    clf_comparison.loc[i, 'Classfier_name'] = model.__class__.__name__\n    clf_comparison.loc[i, 'train_score'] = cv_result['train_score'].mean()\n    clf_comparison.loc[i, 'test_score'] = cv_result['test_score'].mean()\n\nclf_comparison","93dcb1c2":"df_app.loc[:, 'isGame'] = df_app['app_desc'].apply(lambda x: 1 if 'game' in x.lower() else 0)","3b78121f":"df_app.loc[:, 'descLen'] = df_app['app_desc'].apply(lambda x: len(x.lower()))","636f44fe":"df_train = df_app[['size_bytes_in_MB', 'isNotFree', 'price', 'rating_count_before', 'sup_devices.num', 'ipadSc_urls.num', 'lang.num', 'vpp_lic', 'prime_genre', 'isGame', 'descLen']]\ntarget = df_app['user_rating']\n\ndf_train = pd.get_dummies(df_train)\n\ndef categorize_rating(x):\n    if x <= 4:\n        return 0\n    else:\n        return 1\n\ntarget = target.apply(categorize_rating)\n\ntarget.astype(str).hist()","88a24076":"X_train, X_test, y_train, y_test = train_test_split(df_train.values, target, test_size=0.2, random_state=1989, stratify=target)\n\nprint('X_train shape:', X_train.shape)\nprint('X_test shape:', X_test.shape)","6eec3f72":"models = [RandomForestClassifier(), LGBMClassifier(), XGBClassifier()]\n\nkfold = KFold(n_splits=5, random_state=1989)\n\nclf_comparison = pd.DataFrame(columns=['Classfier_name', 'train_score', 'test_score'])\n\nfor i, model in enumerate(models):\n    clf = model\n    cv_result = cross_validate(model, X_train, y_train, cv=kfold, scoring='accuracy')\n    clf_comparison.loc[i, 'Classfier_name'] = model.__class__.__name__\n    clf_comparison.loc[i, 'train_score'] = cv_result['train_score'].mean()\n    clf_comparison.loc[i, 'test_score'] = cv_result['test_score'].mean()\n\nclf_comparison","d8a98bd0":"- With not considering 'isNotFree', Medical App has the largest size of ~400MB, followed by Games(~300MB).","b1975daa":"### Figure 1\n- For Free App, Top 3 is below.\n\n(1) Games (2) Entertainments (3) Photo & Video\n### Figure 2\n\n- For Not-Free App, Top 3 is below\n\n(1) Games (2) Education (3) Entertainments\n### Figure 3\n\n- Many social network App is free.","ddfaf197":"- We can merge df_app with description based on 'id'.","ea32f44a":"## 2.3 App size based on price_genre","73a508d0":"## 2.1 Countplot for each type of Prime_genre","fc6fb85c":"- When considering only Not-Free apps, Medical App is the most expensive, near to 14$.","d4c6636c":"- There aren't null data in the df_description.","c50232bd":"# 4. Simple feature engineering and preparation","a9d01539":"# Conclusion\n- At the beginning, I set a multi class classfication problem to predict user_rating using this dataset. I categorized user ratings into 5 groups, (1) 0~1 (2) 1~2 (3) 2~3 (4) 3~4 (5) 4~5.\n- But, the output was bad.","f9288711":"- There aren't null data in the df_app.","bfab4f51":"- With not considering 'isNotFree', Games are the most numerous, followed by Entertainment, Education, Photo & Video.","797a9777":"- As you can see, there are many free Apps. It will be interesting to analyze the df_app depending on free ore not free.\n- Let's make the two dataframes for free and not-free.","08f39b5f":"- Delete 'Unnamed: 0'.","9d7a1210":"## 2.4 App price based on prime_genre","62ba8722":"- Add isNotFree column.","ce9e7de7":"# 6. Success prediction with description variable","402bc512":"# 4. Float columns","78f1e4d4":"# 5. Success prediction","fc97cf3d":"## 1.1 Read dataset","b69812c7":"# 3. Rating change","58f43405":"- With not considering 'isNotFree', The Apps for Productivity, Music and Photo & Vidio have higher mean user rating.\n- The mean user rating of Book, Finance and Catalogs are less than 2.5.","e7d26cb8":"## 1.2 Merge datasets","8cd68a6d":"- Medical App is the most expensive, near to 9\\$.\n- The Apps (Business, Reference, Music, Productivity, Navigation, Education) have the mean price near to 5$.","70fafec1":"- For convenience, Change the unit of size_bytes into Megabytes.","62f5d34f":"- below are Not-free social networking App. Do you know these Apps?","625d15d2":"# 1. Check dataset","1c17ee27":"## 2.2 User rating depending on price_genre","e7d2bebd":"# 4. Description","a218cfa2":"# 2. Prime_genre","b64277c2":"### Figure 1\n- For Free App, Top 3 is below.\n\n(1) Productivity (2) Music (3) Photo & Video\n### Figure 2\n\n- For Not-Free App, Top 3 is below\n\n(1) Catalogs (2) Shopping (3) Productivity\n### Figure 3\n\n- Book, Catalogs and Navigation Apps have much higher ratings when they are Not-free.","8a6fc51f":"## 1.3 Add new columns","ac3e326f":"# 1.4 Free, Non Free","fef10e3a":"- For now, I set a binary classfication problem to predict success of apps. I supposed that app which has more than 4 user_rating is succeful. \n- For this approach, the prediction accuracy is about 70%. It is not bad.\n- I'm planning to add more features to improve the performance.","dae26757":"### Figure 1\n- For Free App, Top 3 is below.\n\n(1) Games (2) Medical (3) Education\n### Figure 2\n\n- For Not-Free App, Top 3 is below\n\n(1) Medical (2) Games (3) Book\n### Figure 3\n\n- The bytesize of Not-Free Book, Catalogs and Medical Apps are more than 2 times than that of Free Book, Catalogs and Medical Apps.\n- Because the service form of  those 3 Apps is information, the price for Apps have a relationship with the amount of information.\n- For Games, I think the price is responsible for high quality graphic, good interface, etc."}}