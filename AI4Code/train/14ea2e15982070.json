{"cell_type":{"5c25d5a5":"code","19caf13c":"code","22c75860":"code","4ca879f2":"code","24e3e77c":"code","2d518c60":"code","29a24304":"code","c3ad2246":"code","83631e6e":"code","310d8fd3":"code","ae32fde5":"code","589615d1":"code","9e1a9f25":"markdown","2a3ec5a4":"markdown","ff786fb8":"markdown","364585a5":"markdown","0f4962b5":"markdown","6816747a":"markdown","39975021":"markdown","15b85e51":"markdown","79a07910":"markdown","a146196d":"markdown","b502cd9c":"markdown"},"source":{"5c25d5a5":"import cv2\nimport matplotlib.pyplot as plt\nfrom skimage import measure, morphology\nfrom skimage.color import label2rgb\nfrom skimage.measure import regionprops","19caf13c":"img = cv2.imread('..\/input\/sigdoc\/in1.jpg', cv2.IMREAD_GRAYSCALE)\nprint('image mean value :',img.mean())\nprint(img)\nplt.imshow(img, cmap='gray')","22c75860":"img = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)[1] \nprint('image mean value :',img.mean())\nprint(img)\nplt.imshow(img, cmap='gray')","4ca879f2":"blobs = img > img.mean()\nprint(blobs)\nplt.imshow(blobs, cmap='gray')","24e3e77c":"import numpy as np\nblobs_labels = measure.label(blobs, background=1)\nprint(np.unique(blobs_labels))\nprint(len(np.unique(blobs_labels)))","2d518c60":"image_label_overlay = label2rgb(blobs_labels, image=img)\nplt.figure(figsize=(10,10))\nplt.imshow(image_label_overlay)","29a24304":"print(len(regionprops(blobs_labels)))","c3ad2246":"the_biggest_component = 0\ntotal_area = 0\ncounter = 0\naverage = 0.0\nfor region in regionprops(blobs_labels):\n    if (region.area > 10):\n        total_area = total_area + region.area\n        counter = counter + 1\n    print('region.area  :',region.area) # (for debugging)\n    if (region.area >= 1000):\n        if (region.area > the_biggest_component):\n            the_biggest_component = region.area\n            print('the_biggest_component **************: ',the_biggest_component)\nprint('number of region with more than 10 pixels',counter)\nprint('total pixels that belong to a region with more than 10 pixels',total_area)","83631e6e":"average = (total_area\/counter)\nprint(\"the_biggest_component: \" , the_biggest_component)\nprint(\"average: \" , average)","310d8fd3":"constant = average\/img.shape[0]*img.shape[1]*7.75\nprint(\"a4_constant: \" ,constant)","ae32fde5":"b = morphology.remove_small_objects(blobs_labels, constant)\nplt.figure(figsize=(10,10))\nplt.imshow(b,cmap='gray')","589615d1":"'''\nplt.imsave('pre_version.png', b)\n# read the pre-version\nd = cv2.imread('pre_version.png', 0)\nout = cv2.threshold(d, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]\n# save the the result\nplt.figure(figsize=(10,10))\nplt.imshow(out,cmap='gray')\n'''","9e1a9f25":"here we will give for every block of 8-connected same value starting from 1\n8-connectivity    \n[ ]  [ ]  [ ]  \n\n   \\  |  \/     \n   \n[ ]--[x]--[ ] \n\n   \/  |  \\   \n   \n[ ]  [ ]  [ ]\n\n\nignore all pixels with value 1 as background pixels, and label them as 0.\n\nprint(len(np.unique(blobs_labels))) will give us the number of connected components","2a3ec5a4":"a blob is a region of an image in which some properties are constant or approximately constant. Blob extraction is generally performed on the resulting binary image from a thresholding step","ff786fb8":"a4_constant is used as a threshold value to remove connected pixels are smaller than a4_constant for A4 size scanned documents\nmodify it for your cases \n\ntry something like:\nax_constant = ((average\/constant_parameter_1) * constant_parameter_2) + constant_parameter_3","364585a5":"region.area is the number of pixels of the region.\n","0f4962b5":"![image.png](attachment:image.png)","6816747a":"morphology.remove_small_objects Remove objects smaller than the specified size(2nd arg)\n\nreturn ndarray, same shape and type as input array(values True or False). The input array with small connected components removed.","39975021":"regionprops return list of region,Each item describes one labeled region.\nlength of the list is len(np.unique(blobs_labels)) - 1 because we ignore region 0","15b85e51":"apply treshold to ensure binary","79a07910":"read the input image","a146196d":"Return an RGB image where color-coded labels are painted over the image","b502cd9c":"this project is for extracting signature from images. this project works fine for A4 document you might need to do some modification to calculate the treshold value"}}