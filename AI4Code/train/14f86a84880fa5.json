{"cell_type":{"22b07229":"code","7c8ed1a8":"code","4d4979b9":"code","575117ee":"code","bd41277f":"code","5e05238e":"code","049ef2e7":"code","a1f494ff":"code","013ee55a":"code","cc69fbe0":"code","50b74232":"code","1adffafc":"code","38e5cbd3":"code","f4c02c17":"code","62ee1835":"code","24bb866e":"code","fd385a85":"code","9a24009b":"code","31507f0d":"code","6aeaffed":"code","b58630a3":"code","5de6c3a7":"code","73589b6f":"code","3d70e674":"code","ba5cc25b":"code","f3258dc4":"code","19eadc80":"code","c4f806d5":"code","8cbb49f5":"markdown","5fdb6738":"markdown"},"source":{"22b07229":"%matplotlib inline\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndf = pd.read_csv(\"..\/input\/popular-movies-and-tv-shows-amazon-prime-netflix\/Popular Movies TV shows from Prime Videos Netflix version_3.csv\")\ndf.head()","7c8ed1a8":"df.info()","4d4979b9":"# From these values, Rating column seems to be defining the age restriction(recommendation) rather than a movie rating(these ratings are defined in the IMDb and Rotten Tomatoes Columns)\n\ndf.Rating.unique()","575117ee":"# There seems to be a large amount of nan values in the Rating column, therefore we should see through the potential ratings(it can be converted to either 'all' or avarege value)\n\ndf.Rating.isna().sum()","bd41277f":"# The genres are the same, so nan values are equal to missing values rather than 'all' category\n\ndfUnrated = df[df.Rating.isna()]\nprint(\"Unique genres overall:\", df.Genre.unique())\nprint(\"Unique genres overall:\", dfUnrated.Genre.unique())","5e05238e":"# With numerical values we can make more accurate analysis\n\nconvert = {'18+': 18, '13+': 13, '7+': 7, '16+': 16, 'all': 0}\ndf.Rating = df.Rating.map(convert)\ndf.Rating.unique()","049ef2e7":"# The dataset seems to be made by only movies and TV shows that are on either Netflix or Amazon Prime, so for a better understanding we can have a column, that specifies the streaming service rather than have 2 columns for this value \n\ntempDF = df[(df.Netflix == 1) & (df[\"Amazon Prime Video\"] == 1)]\nprint(f'On both services: {len(tempDF)}')\ntempDF = df[(df.Netflix == 0) & (df[\"Amazon Prime Video\"] == 0)]\nprint(f'On neither of these services: {len(tempDF)}')\n\n","a1f494ff":"streamingService = []\n\nfor i in df.Netflix:\n    if i == 1:\n        streamingService.append(\"Netflix\")\n    else:\n        streamingService.append(\"Amazon Prime Video\")\n\ndf['StreamingService'] = streamingService\ndel df['Netflix']\ndel df['Amazon Prime Video']","013ee55a":"# Most of these entries are from Amazon Prime Video, but we can still do some analytics for Netflix as well\n\nfrom collections import Counter\n\ncounter = Counter(df.StreamingService)\nprint(counter.most_common())","cc69fbe0":"# There is a d;} value in the IMDb column, which seems to be a missing value or some kind entry \n\ndf.IMDb.unique()","50b74232":"# The rating of d;} doesn't occour often, therefore it is best to replace the value with nan \n\nprint(len(df[df.IMDb == 'd;}']))\n\ndf['IMDb'] = df['IMDb'].replace(to_replace='d;}', value=np.nan)\n\nprint(len(df[df.IMDb == 'd;}']))","1adffafc":"# Ratings on Rotten Tomtoes and IMDb were object entries, converting them to floats will enable further analysis\n\ndf.IMDb = df.IMDb.astype(float)","38e5cbd3":"df['IMDb'] = df['IMDb'].replace(to_replace=np.nan, value=np.mean(df['IMDb']))\n","f4c02c17":"df.info()","62ee1835":"df['Rotten Tomatoes'] = df['Rotten Tomatoes'].replace(to_replace='na', value=np.nan)\n\ndf['Rotten Tomatoes'] = df['Rotten Tomatoes'].astype(float)\n\ndf['Rotten Tomatoes'] = df['Rotten Tomatoes'].replace(to_replace=np.nan, value=np.mean(df['Rotten Tomatoes']))\n","24bb866e":"#Netflix shows and movies seem to have a better overall rating on both platforms \n\navarage = df[df.StreamingService == 'Netflix'].IMDb.mean() \nprint(f'Avarage score for a Netflix shows is(IMDb): {round(avarage, 2)}')\navarage = df[df.StreamingService == 'Amazon Prime Video'].IMDb.mean() \nprint(f'Avarage score for an Amazon shows is(IMDb): {round(avarage, 2)}')\n\navarage = df[df.StreamingService == 'Netflix']['Rotten Tomatoes'].mean() \nprint(f'Avarage score for a Netflix shows is(Rotten Tomatoes): {round(avarage, 2)}')\navarage = df[df.StreamingService == 'Amazon Prime Video']['Rotten Tomatoes'].mean() \nprint(f'Avarage score for an Amazon shows is(Rotten Tomatoes): {round(avarage, 2)}')\n","fd385a85":"# In the next two tables, we can see that these two pages have users with absolutely different tastes. \n# In the top 10, there isn't even one movie or show that is in both pages\n\ndf.sort_values(by=['IMDb'], ascending=False).head(10)","9a24009b":"# On IMDb, the top movies are usually Documentaries, while on Rotten Tomatoes the Leading Genre seems to be Action & Adventure\n# This suggest that Rotten Tomatoes is used mostly by younger generations\n# The high ranked movies on Rotten Tomatoes have usually good rankings in Imdb as well while the top movies on IMDb have awfull ratings on Rotten Tomatoes\n\ndf.sort_values(by=['Rotten Tomatoes'], ascending=False).head(10)","31507f0d":"# From this scatterplot, the ratings seem really chaotic, with this information, we've decided on using these ratings seperately    \n\nsns.scatterplot(df.IMDb, df['Rotten Tomatoes'], color='red')","6aeaffed":"# In these genres, there is also US and Japanese animation, which are not genres, but can be used for analytics\n\ndf.Genre.unique()","b58630a3":"# Anime has got only 16 titles, therefore there isn't a point in doing any analytics with it\n\nfor i in df.Genre.unique():\n    print(\"Number of titles in \" + i + \": \" + str(len(df[df.Genre == i])))","5de6c3a7":"df = df[df.Genre != \"Anime\"]","73589b6f":"df.info()","3d70e674":"# When it comes to IMDb, older movies are getting a really high ratings, on the other hand, on Rotten Tomatoes, this pattern seems to be opposite and older movies are getting worse ratings\n\nsns.scatterplot('Year', 'IMDb', data=df)\nplt.show()\nsns.scatterplot('Year', 'Rotten Tomatoes', data=df)\nplt.show()","ba5cc25b":"# Preferance in age ratings is slightly different depending on site \n\nprint(\"Ratings IMDb\")\nprint()\nfor i in df[df.Rating != np.nan].Rating.unique():\n    print(\"Avarage rating for category \" + str(i) + \"+ is: \" + str(np.average(df[df.Rating == i].IMDb)))","f3258dc4":"# Ratings on Rotten Tomatoes seem to be little different in some categories\n\nprint(\"Ratings Rotten Tomatoes\")\nprint()\nfor i in df[df.Rating != np.nan].Rating.unique():\n    print(\"Avarage rating for category \" + str(i) + \"+ is: \" + str(np.average(df[df.Rating == i]['Rotten Tomatoes'])))","19eadc80":"# Finally, the list of top movies regarding their genres on both platforms\nprint(\"Top ratings Rotten Tomatoes\")\nprint()\n\nfor genre in df.Genre.unique():\n\n    print(genre)\n    print(\"Top movies:\")\n    for i in df[df.Genre == genre].sort_values(by=['Rotten Tomatoes'], ascending=False).Title[:10]:\n        rating = np.mean(df[df.Title == i]['Rotten Tomatoes'])\n        print(i + \", \" + str(rating))\n        \n    print()","c4f806d5":"print(\"Top movies IMDb\")\nprint()\n\nfor genre in df.Genre.unique():\n    print(genre)\n    print(\"Top movies:\")\n    for i in df[df.Genre == genre].sort_values(by=['IMDb'], ascending=False).Title[:10]:\n        rating = np.mean(df[df.Title == i]['IMDb'])\n        print(i + \", \" + str(rating))\n        \n    print()","8cbb49f5":"# Workplace setup","5fdb6738":"# Analytics"}}