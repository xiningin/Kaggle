{"cell_type":{"46233b5f":"code","05a02d73":"code","aee1f75e":"code","7bfc70c7":"code","310b88f0":"code","ffb35bab":"code","b931c792":"code","a2b018f8":"code","85b6a200":"code","0357bdcb":"code","da729c75":"code","94a1110a":"code","e14a5b1f":"code","42125d79":"code","a2988749":"code","3368d0c5":"code","227cae8a":"code","0bfd5f20":"code","4fd83d14":"code","4bc86172":"code","9a6bb00c":"code","7d6aab2f":"code","681b285f":"markdown","db0ff2d8":"markdown","5c9da5e2":"markdown","a55269dd":"markdown","ceece4f1":"markdown","c2f911d9":"markdown","b970473d":"markdown"},"source":{"46233b5f":"!conda install -y -c openbabel openbabel \nimport openbabel as ob","05a02d73":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport openbabel as ob\nobConversion = ob.OBConversion()","aee1f75e":"Xtrain = pd.read_csv('..\/input\/train.csv')\nstructures = pd.read_csv('..\/input\/structures.csv')","7bfc70c7":"Xtrain['type_0'] = Xtrain['type'].apply(lambda x: x[0]).astype(int)\nXtrain['type_1'] = Xtrain['type'].apply(lambda x: x[2:3])\nXtrain['type_2'] = Xtrain['type'].apply(lambda x: x[3:4])","310b88f0":"Xtrain.head()","ffb35bab":"sns.violinplot(x=\"type_2\", y=\"atom_index_1\",\n               split=True, data=Xtrain)","b931c792":"sns.violinplot(x=\"type_1\", y=\"atom_index_0\",\n               split=True, data=Xtrain)","a2b018f8":"\ndef read_ob_molecule(molecule_name, datadir=\"..\/input\/structures\"):\n    mol = ob.OBMol()\n    path = f\"{datadir}\/{molecule_name}.xyz\"\n    if not obConversion.ReadFile(mol, path):\n        raise FileNotFoundError(f\"Could not read molecule {path}\")\n    return mol","85b6a200":"#Xtrain = Xtrain.iloc[:100000] # for speedup\nXtrain = Xtrain.sample(100000) # for speedup\ndf_structures = pd.read_csv('..\/input\/structures.csv')\nstructures_idx = df_structures.set_index([\"molecule_name\"])\nmolecule_names = Xtrain.molecule_name.unique()\nob_natoms = []\nob_heavyatoms = []\nob_molweight = []\nob_molecule_name = []\nob_atom_index = []\nfor i,molecule_name in enumerate(molecule_names):\n    if i%10000 ==0:\n        print(\"OB molecule %d\"%(i))\n        \n    # fill data for output DF\n    ms = structures_idx.loc[molecule_name].sort_index()\n    natoms = len(ms)\n    ob_molecule_name.extend([molecule_name] * natoms)\n    ob_atom_index.extend(ms.atom_index.values)\n    \n    # calculate open babel charge for each method\n    mol = read_ob_molecule(molecule_name)\n    assert (mol.NumAtoms() == natoms)\n    mw = mol.GetMolWt()\n    ob_heavyatoms.extend([mol.NumHvyAtoms()]*natoms)\n    ob_natoms.extend([natoms]*natoms)\n    ob_molweight.extend([mw]*natoms)\n    \nob_data = pd.DataFrame({'molecule_name':ob_molecule_name,'natoms':ob_natoms,'nheavyatoms':  ob_heavyatoms, 'mw':ob_molweight,'atom_index':ob_atom_index})\nob_data.head(10)\n    ","0357bdcb":"Xtrain_ob = pd.merge(Xtrain, ob_data, how='left',\n                        left_on=['molecule_name', 'atom_index_0'],\n                        right_on=['molecule_name', 'atom_index'],suffixes=('_at1', '_at2'))","da729c75":"Xtrain_ob.head()","94a1110a":"sns.violinplot(x=\"atom_index_0\", y=\"natoms\",\n               split=True, data=Xtrain_ob)","e14a5b1f":"Xtrain_ob.head()","42125d79":"Xtrain_ob['atom_index_sum'] = Xtrain_ob['atom_index_0']+Xtrain_ob['atom_index_1']\nXtrain_ob['atom_index_diff'] = Xtrain_ob['atom_index_0']-Xtrain_ob['atom_index_1']\nXtrain_ob['atom_index_abs'] = np.fabs(Xtrain_ob['atom_index_0']-Xtrain_ob['atom_index_1'])","a2988749":"def map_atom_info(df, structures, atom_idx):\n    df = pd.merge(df, structures, how='left',\n                  left_on=['molecule_name', f'atom_index_{atom_idx}'],\n                  right_on=['molecule_name', 'atom_index'])\n\n    df = df.drop('atom_index', axis=1)\n    df = df.rename(columns={'atom': f'atom_{atom_idx}',\n                            'x': f'x_{atom_idx}',\n                            'y': f'y_{atom_idx}',\n                            'z': f'z_{atom_idx}'})\n    return df","3368d0c5":"Xtrain_ob = Xtrain_ob.drop('atom_index', axis=1)\nXtrain_ob.head()","227cae8a":"\nXtrain_ob = map_atom_info(Xtrain_ob, structures, 0)\nXtrain_ob = map_atom_info(Xtrain_ob, structures, 1)","0bfd5f20":"Xtrain_ob.head()","4fd83d14":"train_p_0 = Xtrain_ob[['x_0', 'y_0', 'z_0']].values\ntrain_p_1 = Xtrain_ob[['x_1', 'y_1', 'z_1']].values\n","4bc86172":"Xtrain_ob['dist'] = np.linalg.norm(train_p_0 - train_p_1, axis=1)","9a6bb00c":"sns.violinplot(x=\"atom_index_sum\", y=\"natoms\",\n               split=True, data=Xtrain_ob)","7d6aab2f":"sns.violinplot(x=\"atom_index_sum\", y=\"natoms\",\n               split=False, data=Xtrain_ob.loc[Xtrain_ob.type=='2JHH'])","681b285f":"For JHH there is some correlation with average natoms?","db0ff2d8":"Open babel code thanks to this kernel: https:\/\/www.kaggle.com\/asauve\/v7-estimation-of-mulliken-charges-with-open-babel","5c9da5e2":"atom_index_0 are connected to higher indices ","a55269dd":"There is some correlation with the average number of atoms at least for larger indices. ","ceece4f1":"Now creating some open babel data on number of atoms","c2f911d9":"> \n**Some features containing the atom_indices have high importance (but they should not be relevant!?)**\n\n* Usually only heavy atoms are stored by cheminformatics software. Explicit Hydrogens are added\nafter the last heavy atoms and have a larger atom index.\n\n* It seems they (i.e. atom_index_0) contain some info on minimum and average molecule size...\n","b970473d":"atom_index_1 (the heavy atoms only except for the HH coupling) have lower indices "}}