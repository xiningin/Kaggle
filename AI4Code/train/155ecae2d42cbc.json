{"cell_type":{"c833bafb":"code","484b291b":"code","4763d59c":"code","701991e3":"code","124ecbc8":"code","23c9e570":"code","c4842029":"code","61f36cf9":"code","e0c2a01d":"code","1230caa4":"code","6689e1a0":"code","f9573ed0":"markdown","6f51e95f":"markdown","429ee904":"markdown","528e8eab":"markdown","f01426db":"markdown","7958b810":"markdown","ec7b97b3":"markdown","872c9df0":"markdown","7345a402":"markdown"},"source":{"c833bafb":"import math\nimport operator\nimport datetime\nimport warnings\nwarnings.filterwarnings('ignore')\n\nimport numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt \nimport plotly.graph_objects as go\n\nfrom sklearn.metrics import mean_squared_error\n\nfrom scipy.signal import find_peaks\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error, r2_score\nfrom sklearn.preprocessing import PolynomialFeatures\n\n#\/kaggle\/input\/covid19-daily-reports-by-country\/FO.csv","484b291b":"prediction_days =  300\n\ndef logistic_funct(x = 1, L = 2, a = 0, k = 3.7):\n    return L\/(1 + math.e**(-k*(x - a)))     \n\ndef get_logistic_df(x_range = [], L = 2, a = 0, k = 3.7):\n    logistic_df = pd.DataFrame(columns = ['x', 'y'])\n    logistic_df['x'] = x_range\n    logistic_df['y'] = [logistic_funct(n, L, a, k) for n in x_range]\n    return logistic_df\n\ndef get_growth_factors(y):\n    return np.array([x \/ y[i - 1] for i, x in enumerate(y) if i > 0])\n        \ndef get_growth_factor_idx(n, limit):\n    x1 = 0\n    y1 = 0.01\n    growth_factor = 2\n    x = 1\n\n    while growth_factor > limit:\n        y = (n*x)**2\n        growth_factor = y \/ y1\n        x += 1\n        y1 = y\n    return x        \n    \n\ndef plot_curve(data, title):\n    \n    fig = go.Figure()\n    for key in data.keys():\n        df = data[key]\n        fig.add_trace(go.Scatter(x=df['x'], y=df['y'], mode='lines', name=key))\n\n    fig.update_layout(\n        title_text=title\n    )\n    fig.show()\n    \n    \n\ndef get_exp_curve(start, stop, num):\n    x_range = np.linspace(start, stop, num)\n    df = pd.DataFrame(columns = ['x', 'y'])\n    df['x'] = x_range\n    df['y'] = [x2_funct(n) for n in x_range]\n\n    # Move to origin\n    y_min = df['y'].min()\n    x_min = df.loc[df['y'] == df['y'].min()]['x'].min()\n    x = -x_min\n    y = -y_min\n    df['x'] = df['x'].apply(lambda value: value + x)\n    df['y'] = df['y'].apply(lambda value: value + y)\n\n\n    df = df.loc[(df['x'] > 0) & (df['y'] > 0)]\n\n    return df.reset_index(drop = True)\n\n\ndef get_log_exp(L = 2, a = 0, k = 1):\n    x_range = np.linspace(0, prediction_days*2, num=2000)\n\n    logistic_df = get_logistic_df(x_range, L = L, a = a, k = k)\n    logistic_df = logistic_df.loc[(logistic_df['y'] >= 0.01)].reindex()\n\n    return logistic_df\n\n\ndef get_logistic_func(L = 2, a = 0, k = 1):\n    x_range = np.arange(-prediction_days, prediction_days) \n\n    logistic_df = get_logistic_df(x_range, L = L, a = a, k = k)\n\n    return logistic_df\n\ndef move_to_origin(df):\n    # Move to origin\n    y_min = df['y'].min()\n    x_min = df.loc[df['y'] == df['y'].min()]['x'].min()\n    x = -x_min\n    y = -y_min\n    df['x'] = df['x'].apply(lambda value: value + x)\n    df['y'] = df['y'].apply(lambda value: value + y)\n\n\n    df = df.loc[(df['x'] > 0) & (df['y'] > 0)]\n\n    return df.reset_index(drop = True)\n\n\nfrom sklearn.model_selection import train_test_split\n\ndef to_polinomyal(x):\n    polynomial_features= PolynomialFeatures(degree=2)\n    x = x[:, np.newaxis]\n\n    return polynomial_features.fit_transform(x)\n\ndef build_model(x, y):\n    x = to_polinomyal(x)\n    y = to_polinomyal(y)\n\n    X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=300)\n\n    model = LinearRegression()\n    return model.fit(X_train, y_train)\n\ndef get_predictions(model, x_predic): \n    x_predic = to_polinomyal(x_predic)\n    y_predic = model.predict(x_predic)\n\n    predictions = pd.DataFrame(columns=['x', 'y'])\n    predictions['x'] = x_predic[:, 1]\n    predictions['y'] = y_predic[:, 1]\n\n    return predictions","4763d59c":"dataset = pd.read_csv('\/kaggle\/input\/covid19-daily-reports-by-country\/CO.csv')\ndataset['Report_Date'] = pd.to_datetime(dataset['Report_Date'])\ndataset[['Confirmed', 'Deaths', 'Recovered']] = dataset[['Confirmed', 'Deaths', 'Recovered']].fillna(0)\ndataset['x'] = np.arange(0, dataset.shape[0])\ndataset.tail()\n","701991e3":"cases_by_day_df = dataset[['x', 'Confirmed']]\ncases_by_day_df.rename(columns = {'Confirmed': 'y'}, inplace=True)\ncases_by_day_df.loc[:,'y'] = cases_by_day_df['y'].diff()\n\ndata = {\n    'Cases by day': cases_by_day_df\n}\n\nplot_curve(data, 'Cases by day')","124ecbc8":"aggregated_cases_df = dataset[['x', 'Confirmed']]\naggregated_cases_df.rename(columns = {'Confirmed': 'y'}, inplace=True)\n\ndata = {\n    'Aggregated cases': aggregated_cases_df\n}\n\nplot_curve(data, 'Aggregated cases')","23c9e570":"def get_parabole_segment(n, start, end, num):\n    df = pd.DataFrame(columns = ['x', 'y'])\n    df['x'] = np.linspace(start, end, num)\n    df['y'] = (n*df['x'])**2\n    return df\n\ndef get_logistic_segment(L, a, k, start, end, num):\n    x_range = np.linspace(start, end, num)\n    logistic_df = get_logistic_df(x_range, L = L, a = a, k = k)\n    #logistic_df = logistic_df.loc[(logistic_df['y'] >= 0.01)].reindex()\n\n    return logistic_df\n\ndef diff_area(curve1, curve2):\n    x_start_curve1 = curve1['x'].min()\n    x_end_curve1 = curve1['x'].max()\n\n    x_start_curve2 = curve2['x'].min()\n    x_end_curve2 = curve2['x'].max()\n    \n    x_start = x_start_curve1 if x_start_curve1 > x_start_curve2 else x_start_curve2\n    x_end = x_end_curve1 if x_end_curve1 < x_end_curve2 else x_end_curve2\n\n    curve1 = curve1.loc[(curve1['x'] > x_start) & (curve1['x'] < x_end)]\n    curve2 = curve2.loc[(curve2['x'] > x_start) & (curve2['x'] < x_end)]\n    \n    curve1_area = np.trapz(curve1['y'],curve1['x'])\n    curve2_area = np.trapz(curve2['y'],curve2['x'])\n    return np.abs(curve2_area - curve1_area)\n\n\ndef fit_curve(data_points):\n    area_results = {}\n    start = data_points['x'].min()\n    end = data_points['x'].max()\n    num = end\n    n_range = [x for x in np.arange(0, 5, 0.05)]\n    \n    for n in n_range:\n        with warnings.catch_warnings():\n            warnings.filterwarnings('error')\n            try:       \n                data_points_2 = get_parabole_segment(n, start, end, num)\n                \n                area = diff_area(data_points, data_points_2)\n                area_results[str(n)] = str(area)\n            except Warning:\n                pass      \n    area_results_df = pd.DataFrame.from_dict(area_results, orient='index').reset_index()\n    area_results_df = area_results_df.astype(float)\n    area_results_df.columns = ['n', 'area']\n\n    min_area = area_results_df['area'].min()\n    min_area = area_results_df.loc[area_results_df['area'] == min_area]\n    return min_area['n'].min()\n\ndef calculate_k(n, L, x_inflection):\n    parabole_segment = get_parabole_segment(n, 1, x_inflection, 100) \/ 5\n    logistic_curves = []\n    area_results = {}\n    x_range = [x for x in np.arange(0, 2, 0.01)]\n    for k in x_range:\n        with warnings.catch_warnings():\n            warnings.filterwarnings('error')\n            try:      \n                log_exp = get_logistic_segment(L = L, a = x_inflection, k = k, start = 1, end = x_inflection, num = 100)\n                log_exp = log_exp\/5\n                \n                area = diff_area(log_exp, parabole_segment)\n                logistic_curves += [(k, log_exp, area)]\n                \n                area_results[str(k)] = str(area)\n            except Warning:\n                pass    \n    \n    area_results_df = pd.DataFrame.from_dict(area_results, orient='index').reset_index()\n    area_results_df = area_results_df.astype(float)\n    area_results_df.columns = ['k', 'area']\n\n    min_area = area_results_df['area'].min()\n    min_area = area_results_df.loc[area_results_df['area'] == min_area]\n    k = float(min_area['k'].min())\n    return k\n","c4842029":"train_df = aggregated_cases_df[:aggregated_cases_df.shape[0]]\nmodel = build_model(train_df['x'], train_df['y'])\npredictions = get_predictions(model, np.arange(0, prediction_days))\n    \nfig = go.Figure()\nfig.add_trace(go.Scatter(x=aggregated_cases_df['x'], y=aggregated_cases_df['y'], mode='lines+markers', name='Confirmed cases'))\nfig.add_trace(go.Scatter(x=predictions['x'], y=predictions['y'], mode='lines', name='Projection'))\n\nfig.update_layout(\n    title_text=\"Confirmed cases vs Predictions\"\n)\nfig.show()","61f36cf9":"steps = predictions['y']\ngrowth_factor = np.array([x \/ steps[i - 1] for i, x in enumerate(steps) if i > 0])\ngrowth_factor = np.concatenate((np.array([0]), growth_factor))\npredictions['growth_factor'] = growth_factor\npeaks, _ = find_peaks(predictions['growth_factor'], height=0)\n'''\ninit_x = peaks[-1] if len(peaks) > 0 else 0\npredictions = predictions[init_x:]\npredictions.reset_index(drop = True, inplace = True)\n'''\nfig = go.Figure()\n#fig.add_trace(go.Scatter(x=predictions['x'], y=predictions['y'], mode='lines', name=''))\nfig.add_trace(go.Scatter(x=predictions['x'], y=predictions['growth_factor'], mode='lines', name=''))\n\nfig.update_layout(\n    title_text=\"Growth factor\"\n)\nfig.show()\nprint(peaks)","e0c2a01d":"inflection_row = predictions[predictions['growth_factor'] > 1].tail(1)\ndisplay(inflection_row)\ninflection_idx = inflection_row.index[0]\ninflection_x = inflection_row['x'].max()\ninflection_y = inflection_row['y'].max()\nL = inflection_y*2\n\nprint(f'inflection_idx: {inflection_idx}')\nprint(f'inflection_x: {inflection_x}')\nprint(f'inflection_y: {inflection_y}')\nprint(f'L: {L}')\n","1230caa4":"pred = predictions.iloc[:inflection_idx+1]\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=pred['x'], y=pred['y'], line=dict(dash='dash'), name = 'Projection'))\n\nfig.update_layout(\n   \n)\n\nfig.show()","6689e1a0":"predictions_inv = predictions[:inflection_idx + 1][::-1].copy()\npredictions_b = predictions_inv.copy()\n\npredictions_b['x'] = np.arange(inflection_idx, inflection_idx*2+1)\npredictions_b['y'] = predictions_b['y'].apply(lambda y: L - y)\n\nfull_predictions = predictions[:inflection_idx]\nfull_predictions = full_predictions.append(predictions_b)\n\naggregated_cases_df.loc[:,'date'] = pd.date_range(start='3\/6\/2020', periods=aggregated_cases_df.shape[0])\nfull_predictions.loc[:,'date'] = pd.date_range(start='3\/6\/2020', periods=full_predictions.shape[0])\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=aggregated_cases_df['date'], y=aggregated_cases_df['y'], mode='lines+markers', line=dict(width=1), name='Confirmed cases'))\nfig.add_trace(go.Scatter(x=full_predictions['date'], y=full_predictions['y'], line=dict(dash='dash'), name = 'Projection'))\n\nfig.update_layout(\n    title_text=\"Confirmed cases vs Predictions\"\n)\n\nfig.show()","f9573ed0":"# Aggregated cases","6f51e95f":"\n##\u00a0Get the inflection point for the logistic function","429ee904":"# Assumptions\n\n\n\n*   Pandemics shows a logistical growth, it speeds up at the begining and then slows down to find a growth limit. This behaviour can be represented with a logistic function.\n*   Before the inflection point for the logistic function, the growth is exponential.\n*   After tthe inflection point for the logistic function, the growth starts to decrease.\n","528e8eab":"# Build logistic function","f01426db":"# Modeling predictions for Covid-19 Colombia\n\nThe goal for this excercise is try to predict the growth of confirmed cases for Covid-19 in Colombia.\n\n","7958b810":"# Metodology.\n\nGiven the assumptions, the proposed metodology to create a model to proyect the growth of cases is as follows:\n\n\n\n1.   Find and exponential curve that better fits the aggregated confirmed cases.\n\n2.   Use the exponential curve to calculate when it's growth factor downs near to 1. That will be assumed to be the inflection point.\n4.   Find the y value at the inflection point and multiply it by 2 to get L (Maximum value for the logistic function).\n5.   With the values of L and the inflection point use several values for k to find a logistic curve that better fits the exponential curve.\n","ec7b97b3":"# Cases by day","872c9df0":"##\u00a0Build base logistic function","7345a402":"# Dataset\n\nThe data used for this excercies is a curated dataset from [Johns Hopkins CSSE Github's repository](https:\/\/github.com\/CSSEGISandData\/COVID-19.git)."}}