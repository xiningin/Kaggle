{"cell_type":{"cdd588f5":"code","ee0ca673":"code","b53f69d9":"code","4d0feb8e":"code","8fb07864":"code","1afadeb4":"code","83afe082":"code","25ea568f":"code","7b61281d":"code","e2a2622d":"code","230bf1f4":"code","bd84f458":"code","658c5338":"code","4bd6ce9b":"code","13049b7c":"code","f2ee5056":"code","4ce5c615":"code","307c6ebe":"code","b048f1fc":"code","fb628d9a":"code","39dd52ed":"code","17fbb8c6":"code","22f0ef03":"code","e2fb69bf":"code","cd4b2eb3":"code","303a8e6d":"code","cbab2789":"code","68c09bdf":"markdown","e67c2aa0":"markdown","b97a936d":"markdown","9e38d0fb":"markdown","04e6a2cc":"markdown","cf634ea7":"markdown","4b2cd791":"markdown","59c85d0f":"markdown","1a19f5fd":"markdown","0b0bc4e3":"markdown","e40eb6e6":"markdown"},"source":{"cdd588f5":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport seaborn as sns\nsns.set_style(\"darkgrid\")\nplt.style.use(\"dark_background\")\n\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\nCOMPETITION_NAME = 'severstal-steel-defect-detection'\nimport os\n\n# Any results you write to the current directory are saved as output.\n\ndf = pd.read_csv(os.path.join('\/kaggle\/input', COMPETITION_NAME, 'train.csv'))\ndf.head()","ee0ca673":"img_df = df['ImageId_ClassId'].str.split('_', expand=True).rename({0: 'ImageID', 1: 'ClassID'}, axis=1)\nimg_df['ClassID'] = img_df['ClassID'].astype(int)\nimg_df.head()","b53f69d9":"print(\n    'The observation level is (image, class)? -- ',\n    img_df.groupby('ImageID')['ClassID'].apply(lambda x: sorted(x.tolist()) == [1, 2, 3, 4]).all()\n)","4d0feb8e":"img_df['ImageID'].unique().shape","8fb07864":"full_df = pd.concat([df, img_df], axis=1, sort=True)\nfull_df.head()","1afadeb4":"full_df.groupby('ClassID')['EncodedPixels'].count()\\\n    .plot(kind='bar', title='Number of defects by type', figsize=(13, 8));","83afe082":"full_df.groupby('ClassID')['EncodedPixels'].apply(lambda x: x.count() \/ x.shape[0])\\\n    .plot(kind='bar', title='Pct defective by type', figsize=(13, 8));","25ea568f":"def read_img(name, test=False, base_dir='..\/input\/severstal-steel-defect-detection\/'):\n    subdir = 'test_images' if test else 'train_images'\n    img_path = os.path.join(base_dir, subdir, name)\n    img = mpimg.imread(img_path)\n    return img\n    \nIMG_NAME = '5e581254c.jpg'\nimg = read_img(IMG_NAME)\ndisplay(img.shape)\nbase_img_shape = (img.shape[0], img.shape[1])","7b61281d":"for i in range(img.shape[-1]):\n    plt.figure(figsize=(18,8))\n    plt.imshow(img[:,:,i], cmap='nipy_spectral')\n    plt.show()","e2a2622d":"def all_eq(img):\n    return np.all([\n        np.array_equal(img[:,:,i], img[:,:,0]) for i in range(img.shape[-1])\n    ])\nall_eq(img)","230bf1f4":"for i, f in enumerate(os.listdir('..\/input\/severstal-steel-defect-detection\/train_images\/')):\n    if not all_eq(read_img(f)):\n        print('error with', f)\n    if i >= 599:\n        break\nprint('ALL DONE')","bd84f458":"def _get_encoding_mask(encoded_pixels, mask=None, shape=base_img_shape):\n    if mask is None:\n        mask = np.zeros(shape[0] * shape[1])\n    splt_pix = list(map(int, encoded_pixels.split(' ')))\n    pixel_map = list(zip(splt_pix[::2], splt_pix[1::2]))\n    for start, dur in pixel_map:\n        mask[start:start+dur] = 1\n    return mask\ntmp = _get_encoding_mask(full_df.loc[18550]['EncodedPixels'])","658c5338":"def get_encoding_mask(img_df, shape=base_img_shape):\n    n_classes = img_df.shape[0]\n    mask = np.zeros(shape[0] * shape[1] * n_classes).reshape((-1, n_classes))\n    for _, row in img_df.iterrows():\n        if isinstance(row['EncodedPixels'], str) and len(row['EncodedPixels']) > 0:\n            _get_encoding_mask(\n                row['EncodedPixels'],\n                mask[:, row['ClassID'] - 1],\n                shape=shape\n            )\n    return np.swapaxes(mask.reshape((shape[1], shape[0], n_classes)), 0, 1)\nmask = get_encoding_mask(full_df.query(f'ImageID == \"{IMG_NAME}\"'))","4bd6ce9b":"def plot_img(img, mask=None, mask_index=None, greyscale=False):\n    if not greyscale:\n        img = img[:, :, 0]\n    plt.figure(figsize=(18,8))\n    plt.imshow(img, cmap='nipy_spectral')\n    plt.grid(None)\n    plt.show()\n    if greyscale:  # for multiplication later\n        img = img[:, :, 0]\n    if mask is not None:\n        if mask_index is not None:\n            lst = [mask_index]\n        else:\n            lst = range(mask.shape[-1])\n        for i in lst:\n            plt.figure(figsize=(18,8))\n            plt.imshow(mask[:,:,i] * img, cmap='nipy_spectral')\n            plt.grid(None)\n            plt.title('Mask for class: ' + str(i+1))\n            plt.show()\nplot_img(img, mask, mask_index=2)","13049b7c":"def load_and_plot(img_name, mask_index=None, test=False, df=full_df,\n                  greyscale=False, base_dir='..\/input\/severstal-steel-defect-detection\/'):\n    img = read_img(img_name, test=test, base_dir=base_dir)\n    shape = (img.shape[0], img.shape[1])\n    mask = get_encoding_mask(df.query(f'ImageID == \"{img_name}\"'),\n                             shape=shape)\n    plot_img(img, mask, mask_index=mask_index, greyscale=greyscale)\nload_and_plot(IMG_NAME, greyscale=True)","f2ee5056":"load_and_plot('18cc39190.jpg')","4ce5c615":"for class_id in full_df['ClassID'].unique():\n    img_name = full_df.loc[full_df['EncodedPixels'].notnull() & (full_df['ClassID'] == class_id),\n                           'ImageID'].iloc[0]\n    print(class_id, img_name)\n    load_and_plot(img_name)","307c6ebe":"class_id = 1\nimg_names = full_df.loc[full_df['EncodedPixels'].notnull() & (full_df['ClassID'] == class_id),\n                        'ImageID'].iloc[:3]\nfor img_name in img_names:\n    print(class_id, img_name)\n    load_and_plot(img_name, mask_index=class_id - 1)","b048f1fc":"class_id = 2\nimg_names = full_df.loc[full_df['EncodedPixels'].notnull() & (full_df['ClassID'] == class_id),\n                        'ImageID'].iloc[:3]\nfor img_name in img_names:\n    print(class_id, img_name)\n    load_and_plot(img_name, mask_index=class_id - 1)","fb628d9a":"class_id = 3\nimg_names = full_df.loc[full_df['EncodedPixels'].notnull() & (full_df['ClassID'] == class_id),\n                        'ImageID'].iloc[:3]\nfor img_name in img_names:\n    print(class_id, img_name)\n    load_and_plot(img_name, mask_index=class_id - 1)","39dd52ed":"class_id = 4\nimg_names = full_df.loc[full_df['EncodedPixels'].notnull() & (full_df['ClassID'] == class_id),\n                        'ImageID'].iloc[:3]\nfor img_name in img_names:\n    print(class_id, img_name)\n    load_and_plot(img_name, mask_index=class_id - 1)","17fbb8c6":"load_and_plot('0025bde0c.jpg')","22f0ef03":"load_and_plot('002af848d.jpg')","e2fb69bf":"def num_pix_classes(img_df, shape=base_img_shape):\n    n_classes = img_df.shape[0]\n    mask = np.zeros(shape[0] * shape[1] * n_classes).reshape((-1, n_classes))\n    for _, row in img_df.iterrows():\n        if isinstance(row['EncodedPixels'], str) and len(row['EncodedPixels']) > 0:\n            _get_encoding_mask(\n                row['EncodedPixels'],\n                mask[:, row['ClassID'] - 1],\n                shape=shape\n            )\n    vals, cnts = np.unique(mask.sum(axis=-1).astype(int), return_counts=True)\n    return pd.Series(cnts, index=vals)\nmask = num_pix_classes(full_df.query(f'ImageID == \"{IMG_NAME}\"'))\nmask","cd4b2eb3":"counts = full_df.groupby('ImageID').apply(num_pix_classes).unstack()\ncounts.head()","303a8e6d":"tmp = counts.dropna()\n(tmp[1] \/ (tmp.sum(axis=1))).plot(kind='hist', bins=100, figsize=(18,8),\n                                  title='Number of Images vs Pct Defective')\ndel tmp","cbab2789":"(counts.fillna(0)[1] \/ (counts.sum(axis=1))).plot(kind='hist', bins=100, figsize=(18,8),\n                                                  title='Number of Images vs Pct Defective');","68c09bdf":"# How many images are there?","e67c2aa0":"# Let's plot some pics!","b97a936d":"# Misbalanced Classes\n\nWe know the classes are going to be misbalanced, but how misbalanced are they?","9e38d0fb":"To answer this, I'll over kill it pretty hardcore. We'll instead answer the question, how much of each image is covered by how many different classes? In particular, the number of pixels covered by two or more classes answers our question. But this also tells us about how much of a needle in a haystack are we looking at here (on a per-image basis).\n\nWe already have about how many images have errors. This is just one level deeper.","04e6a2cc":"## Yes","cf634ea7":"Below is a histogram of the percentage of defective pixels in images. So the frequency is the number of images (subset to those with at least one defective pixel) for a given percent defective.","4b2cd791":"It certainly looks like it... Let's see if this is true for a few more images?","59c85d0f":"# Q1\n## What does each row correspond to?\nAs a follow-up, why are only some rows populated with `EncodedPixels`.\n\n## Theory:\n### Each image has a single observation per class.\n\nTo test this, we'll see if every image has exactly the 4 classes associated.","1a19f5fd":"# Are classes mutually exclusive for a given pixel?","0b0bc4e3":"After checking 600 images, it seems like they are all in grey scale.","e40eb6e6":"## Are the images in grey-scale?\n\nIt looks like all three bands are identical. Let's see if that's true."}}