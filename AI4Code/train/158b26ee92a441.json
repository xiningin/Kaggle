{"cell_type":{"5154c905":"code","0e6bd00c":"code","404efb27":"code","bdaf3e1d":"code","81a294f0":"code","598f5ba8":"code","a431f8a3":"code","4cd3a785":"code","55009f8b":"code","83d1fbc7":"code","4acda1a0":"code","e8d3525b":"code","059cedad":"code","b1168724":"code","bbe56cc0":"code","3c2fa6ce":"code","1cbf546b":"code","07d5b58f":"code","b790f7cf":"code","29b2c88e":"code","24864be9":"code","58083bab":"code","91791082":"code","9eafc920":"code","9cb07779":"code","ec6daed8":"code","738505d7":"code","ffa06d20":"code","710362a9":"code","80894650":"code","9eed9134":"code","3e9dcf74":"code","333e0c2b":"code","7de88508":"code","f341fede":"code","6f91ef43":"code","0e495ac9":"code","80db6b93":"markdown","36ab3e2b":"markdown","6639f3f8":"markdown","876145f1":"markdown","d331f513":"markdown","31322015":"markdown","3b0fadc9":"markdown","41238bdb":"markdown","79b33ae9":"markdown","041ab9ca":"markdown","9e276ffc":"markdown","5ddac2f8":"markdown","ac0974f3":"markdown","b851e46e":"markdown","8b0367f1":"markdown","828af6d6":"markdown","93d5325f":"markdown","d30d016e":"markdown","7f12ef4d":"markdown","b2438a49":"markdown","77ca5ba3":"markdown","ed8f2337":"markdown","3caeeea2":"markdown","dc1d82d0":"markdown","85664f0d":"markdown","55382ad1":"markdown","5f64d29e":"markdown","66fae01e":"markdown","6dc76229":"markdown","481159b8":"markdown","d4b0b174":"markdown","0c45f30f":"markdown","1915b5eb":"markdown","8c294f48":"markdown","79920112":"markdown","f211f80c":"markdown"},"source":{"5154c905":"import os\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport ipywidgets as widgets\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom IPython.display import display # For widgets\nfrom wordcloud import WordCloud # For wordcloud visualization\n\n%matplotlib inline\n\n\n# The following modules will assist in acquiring the IMDb data\nfrom io import StringIO # For creation of string inputs to be read as '.tsv' by pandas\nimport re # For separation of netflix_df.country strings into lists\nimport gzip # For extraction of IMDB datasets\nimport urllib.request","0e6bd00c":"ndf = pd.read_csv('..\/input\/netflix-shows\/netflix_titles.csv', index_col='show_id', low_memory=False)","404efb27":"ndf.head(5)","bdaf3e1d":"ndf.info()","81a294f0":"# Download IMDB files from official repository\nurllib.request.urlretrieve('https:\/\/datasets.imdbws.com\/title.ratings.tsv.gz', 'title.ratings.tsv.gz');\nurllib.request.urlretrieve('https:\/\/datasets.imdbws.com\/title.basics.tsv.gz', 'title.basics.tsv.gz');\n\n#extract files as text\nwith gzip.open('title.ratings.tsv.gz', 'rt', encoding='utf8') as reader:\n    ratings_contents = reader.read()\n\nwith gzip.open('title.basics.tsv.gz', 'rt', encoding='utf8') as reader:\n    basics_contents = reader.read()\n    \n# Create text strings to be loaded into panda.read_csv as a tab separated file\nratings_data = StringIO(ratings_contents)\nbasics_data = StringIO(basics_contents)\n\n# Create pandas dataframe from tab separated file for ratings\nimdb_ratings_df_raw = pd.read_csv(ratings_data, sep='\\t', low_memory=False)\n\n# Create pandas dataframe from tab separated file for titles\nimdb_titles_df_raw = pd.read_csv(basics_data, sep='\\t', low_memory=False)\n\n# We will make a copy of our raw data, dropping any duplicate rows in the process\nimdb_ratings_df = imdb_ratings_df_raw.copy().drop_duplicates()\nimdb_titles_df = imdb_titles_df_raw.copy().drop_duplicates()","598f5ba8":"imdb_ratings_df.sample(5)","a431f8a3":"imdb_ratings_df.info()","4cd3a785":"imdb_titles_df.sample(5)","55009f8b":"imdb_titles_df.info()","83d1fbc7":"idf = pd.merge(imdb_titles_df.set_index('tconst'), imdb_ratings_df.set_index('tconst'), left_index=True, right_index=True, how='inner').drop_duplicates()\nidf.sample(5)","4acda1a0":"idf.info()","e8d3525b":"idf = idf[idf.startYear.apply(lambda x: str(x).isnumeric())]\nidf['startYear'] = idf['startYear'].astype(int)","059cedad":"ndf['title'] = ndf['title'].str.lower()\nidf['primaryTitle'] = idf['primaryTitle'].str.lower()","b1168724":"df = pd.merge(ndf, idf, left_on=['title', 'release_year'], right_on=['primaryTitle', 'startYear'], how='inner').drop_duplicates().reset_index()\ndf = df.drop('index', axis=1)\ndf.sample(5)","bbe56cc0":"type(df['date_added'].iloc[0])","3c2fa6ce":"df = df[df.date_added.isna() == False].reset_index()\ndf = df.drop(\"index\", axis=1)","1cbf546b":"#Changing 'date_added' columnn to datetime dtype and creating columnn for each part\ndf.date_added = pd.to_datetime(df.date_added)\ndf['year_added'] = pd.DatetimeIndex(df.date_added).year.astype(int)\ndf['month_added'] = pd.DatetimeIndex(df.date_added).month.astype(int)\ndf['day_added'] = pd.DatetimeIndex(df.date_added).day.astype(int)","07d5b58f":"# Add a numeric column for the number of countries each title was released to\nmyList = []\nfor i in range(df.country.size):\n    myList.append(str(df.country[i]).strip().split(','))","b790f7cf":"# Make a pandas Series from 'country' list\ncountry = pd.Series(myList)\n\n# Create 'country_count' column using map and lambda function involving 'country' Series\ndf['country_count'] = country.map(lambda x: len(x))","29b2c88e":"df.info()","24864be9":"df = df.fillna(\"Unknown\")","58083bab":"sns.set_style('darkgrid')\nmatplotlib.rcParams['font.size'] = 15\nmatplotlib.rcParams['figure.figsize'] = (9, 5)\nmatplotlib.rcParams['figure.facecolor'] = '00000000'","91791082":"xplt = df[df[\"type\"] == \"Movie\"].groupby('country').count().sort_values('title', ascending=False).reset_index().country.head(10)\nyplt = df[df[\"type\"] == \"Movie\"].groupby('country').count().sort_values('title', ascending=False).reset_index().title.head(10)\n\nxplt2 = df[df[\"type\"] == \"TV Show\"].groupby('country').count().sort_values('title', ascending=False).reset_index().country.head(10)\nyplt2 = df[df[\"type\"] == \"TV Show\"].groupby('country').count().sort_values('title', ascending=False).reset_index().title.head(10)\n\nplt.figure(figsize=(16, 8))\nplt.fontsize = 20\nplt.xticks(rotation=75)\nplt.title(label='Number of Titles Available by Country (Movies in Blue)')\nplt.xlabel(\"Country\")\nplt.ylabel(\"Number of Titles\")\nsns.barplot(x=xplt, y=yplt, color=\"Blue\");\nsns.barplot(x=xplt2, y=yplt2, color=\"Red\");","9eafc920":"# Group by year added\nmovie_ratings = df[df.type == 'Movie'].groupby('year_added')['averageRating'].mean()\ntv_ratings = df[df.type == 'TV Show'].groupby('year_added')['averageRating'].mean()\n\nmovie_ratings2 = df[df.type == 'Movie'].groupby('release_year')['averageRating'].mean()\ntv_ratings2 = df[df.type == 'TV Show'].groupby('release_year')['averageRating'].mean()\n\nfig, axes = plt.subplots(1, 2, figsize=(20, 8))\n\nsns.lineplot(x=movie_ratings.index[:-1], y=movie_ratings[:-1], ax=axes[0]);\nsns.lineplot(x=tv_ratings.index[:-1], y=tv_ratings[:-1], ax=axes[0]);\naxes[0].set_title('Movie and TV Show Ratings Over Time by Year Added')\naxes[0].set_xlabel(\"Year Added\")\naxes[0].set_ylabel(\"Average Rating\")\naxes[0].legend(labels=['Movies', 'TV Shows']);\n\n\nsns.lineplot(x=movie_ratings2.index[:-1], y=movie_ratings2[:-1], ax=axes[1]);\nsns.lineplot(x=tv_ratings2.index[:-1], y=tv_ratings2[:-1], ax=axes[1]);\naxes[1].set_title('Movie and TV Show Ratings Over Time by Release Year')\naxes[1].set_xlabel(\"Release Year\")\naxes[1].set_ylabel(\"Average Rating\")\naxes[1].legend(labels=['Movies', 'TV Shows']);\n\nplt.tight_layout(pad = 5);","9cb07779":"country_list = df[(df.country.isna() == False) & (df.country_count == 1)].country.sort_values().unique().tolist()\n\ncountry_select = widgets.Dropdown(\n                    options = country_list,\n                    value = 'United States',\n                    description = 'Countries',\n                    disabled = False)\n\ndisplay(country_select)\n\nbutton = widgets.Button(description=\"Plot\")\noutput = widgets.Output()\n\nmatplotlib.rcParams[\"font.size\"] = 15\n\ndisplay(button, output)\n\ndef on_button_clicked(b):\n    avg_ratings_df = pd.DataFrame()\n    country = country_select.value\n    tv_avg = df[(df.country.str.contains(country)) & (df.type == 'TV Show')].groupby('year_added').averageRating.mean()\n    movie_avg = df[(df.country.str.contains(country)) & (df.type == 'Movie')].groupby('year_added').averageRating.mean()\n    with output:\n        plt.figure(figsize=(16, 8));\n        sns.lineplot(x=movie_avg.index[:-1], y=movie_avg[:-1]);\n        sns.lineplot(x=tv_avg.index[:-1], y=tv_avg[:-1]);\n        plt.title(label=country + ' Ratings Over Time')\n        plt.legend(labels=['Movies', 'TV Shows']);\n\nbutton.on_click(on_button_clicked)","ec6daed8":"movies_added = df[df.type == 'Movie'].groupby('year_added').title.count()\ntv_added = df[df.type == 'TV Show'].groupby('year_added').title.count()\n\nyears = [2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020]\nshows = []\nmovies = []\nfor year in years:\n    shows.append([year, df[(df.type == 'TV Show') & (df.year_added == year)].title.count()])\n    movies.append([year, df[(df.type == 'Movie') & (df.year_added == year)].title.count()])\nshows = np.array(shows)\nmovies = np.array(movies)\n\nfig, axes = plt.subplots(1, 2, figsize=(20,8))\n\nsns.lineplot(x=movies_added.index[:-1], y=movies_added[:-1], ax=axes[0]);\nsns.lineplot(x=tv_added.index[:-1], y=tv_added[:-1], ax=axes[0]);\naxes[0].set_title(label='Type of Content Added by Netflix Over Time')\naxes[0].set_xlabel(\"Year\");\naxes[0].set_ylabel(\"Number of Titles\");\naxes[0].legend(labels=['Movies', 'TV Shows']);\n\nblue_bar = movies[:,1]\norange_bar = shows[:,1]\n\nind = np.arange(2008,2021)\n\nwidth = 0.3       \n\n# Plotting\naxes[1].bar(ind[:-1], blue_bar[:-1], width, label='Movies', color=\"blue\", edgecolor=\"cyan\");\naxes[1].bar((ind + width)[:-1], orange_bar[:-1], width, label='TV Shows', color=\"red\", edgecolor=\"magenta\");\n\naxes[1].set_xlabel(\"Year\")\naxes[1].set_ylabel('Number of Titles')\naxes[1].set_title('Amount of Content Added by Type and Year')\naxes[1].set_xticks(ind + width \/ 2, minor=years)\naxes[1].legend();\n\nplt.tight_layout(pad=5)","738505d7":"years = [2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020]\nshows = []\nmovies = []\nfor year in years:\n    shows.append([year, df[(df.type == 'TV Show') & (df.year_added <= year)].title.count()])\n    movies.append([year, df[(df.type == 'Movie') & (df.year_added <= year)].title.count()])\nshows = np.array(shows)\nmovies = np.array(movies)\n\n\n# Create axes for subplots\nfig, axes = plt.subplots(1, 2, figsize=(20,8));\n\nmatplotlib.rcParams[\"font.size\"] = 15\n\n# Set up lineplot on axes[0]\nsns.lineplot(x=movies[:-1,0], y=movies[:-1,1], ax=axes[0]);\nsns.lineplot(x=shows[:-1,0], y=shows[:-1,1], ax=axes[0]);\naxes[0].set_title(label='Amount of Content by Type and Year (Cumulative)')\naxes[0].set_xlabel(\"Year\");\naxes[0].set_ylabel(\"Number of Titles\");\naxes[0].legend(labels=['Movies', 'TV Shows']);\n\n# Set up bar graph\nblue_bar = movies[:,1]\norange_bar = shows[:,1]\nind = np.arange(2008,2021)\nwidth = 0.3       \n\n# Plotting bar graph on axes[1]\naxes[1].bar(ind[:-1], blue_bar[:-1] , width, label='Movies', color=\"Blue\", edgecolor=\"Cyan\");\naxes[1].bar((ind + width)[:-1], orange_bar[:-1], width, label='TV Shows', color=\"Red\", edgecolor=\"Magenta\");\naxes[1].set_xlabel('Year');\naxes[1].set_ylabel('Number of Titles');\naxes[1].set_title('Amount of Content by Type and Year (Cumulative)');\naxes[1].legend([\"Movies\", \"TV Shows\"]);\n\naxes[1].set_xticks(ind + width \/ 2, minor=years);\n\nplt.tight_layout(pad=2);","ffa06d20":"fig, axes = plt.subplots(1, 2, figsize=(18, 10))\nmatplotlib.rcParams[\"font.size\"] = 15\n\naxes[0].set_title(\"Content Available by Type\")\naxes[0].pie(df.groupby(\"type\")[\"title\"].count(), labels=df[\"type\"].unique(), autopct=\"%1.1f%%\", startangle=180, shadow=True);\n\naxes[1].set_title(\"Content Available by MPAA Rating\")\nmatplotlib.rcParams[\"font.size\"] = 12\naxes[1].pie(df[df[\"rating\"] != \"Unknown\"].groupby(\"rating\")[\"title\"].count(), labels=df[df[\"rating\"] != \"Unknown\"][\"rating\"].unique(), autopct=\"%1.1f%%\", startangle=180, shadow=True);\n\nplt.tight_layout()","710362a9":"print(f\"Netflix is available in {len(df[df.country_count == 1].country.unique())} countries.\")","80894650":"fig, axes = plt.subplots(1, 2, figsize=(20, 8))\n\nfig.fontsize = 15\n\nmatplotlib.rcParams[\"font.size\"] = 15\n\naxes[0].hist(df[df[\"type\"] == \"Movie\"][\"averageRating\"], color=\"Blue\");\naxes[0].hist(df[df[\"type\"] == \"TV Show\"][\"averageRating\"], color=\"Red\");\naxes[0].set_title(\"Distribution of User Ratings\")\naxes[0].set_xlabel(\"Average Rating\")\naxes[0].set_ylabel(\"Frequency\")\naxes[0].legend(labels=[\"Movies\", \"TV Shows\"]);\n\nsns.distplot(df[df[\"type\"] == \"Movie\"][\"averageRating\"], color=\"Blue\", ax=axes[1]);\nsns.distplot(df[df[\"type\"] == \"TV Show\"][\"averageRating\"], color=\"Red\", ax=axes[1]);\naxes[1].set_title(\"Density Plot of User Ratings\")\naxes[1].set_xlabel(\"Average Rating\")\naxes[1].set_ylabel(\"Density\")\naxes[1].legend(labels=[\"Movies\", \"TV Shows\"]);\n\nplt.tight_layout(pad=5);","9eed9134":"movie_ratings = dict.fromkeys(df[(df.country_count == 1) & (df.country.isna() == False)].country.sort_values().unique())\ntv_ratings = dict.fromkeys(df[(df.country_count == 1) & (df.country.isna() == False)].country.sort_values().unique())\n\nfor country in movie_ratings.keys():\n    movie_ratings[country] = df[(df.country.str.contains(country)) & (df.type == 'Movie')].averageRating.mean()\n\nmovie_ratings = pd.DataFrame.from_dict(movie_ratings, orient='index', columns=['ratings'])\n\nfor country in tv_ratings.keys():\n    tv_ratings[country] = df[(df.country.str.contains(country)) & (df.type == 'TV Show')].averageRating.mean()\n\ntv_ratings = pd.DataFrame.from_dict(tv_ratings, orient='index', columns=['ratings'])\n\nfig, axes = plt.subplots(1, 2, figsize=(24, 12))\n\naxes[0].set_title('Average Movie Ratings by Country')\nsns.barplot(x=movie_ratings.ratings.sort_values(ascending=False), y=movie_ratings.sort_values('ratings', ascending=False).index, ax=axes[0]);\n\naxes[1].set_title('Average TV Show Ratings by Country')\nsns.barplot(x=tv_ratings.ratings.sort_values(ascending=False), y=tv_ratings.sort_values('ratings', ascending=False).index, ax=axes[1]);\n\nplt.tight_layout(pad=5)","3e9dcf74":"# Create dataframe with necessary data columns\nrating_df = df.groupby([\"country\", \"rating\", \"year_added\"]).agg({\"averageRating\":\"mean\", \"title\":\"count\", \"numVotes\":\"sum\"}).reset_index()\n\n# Creating the dataframe for the averageRating heatmap\nheatmap_df = rating_df.groupby([\"year_added\", \"rating\"])[\"numVotes\"].sum().reset_index()\nratings_pivot = pd.DataFrame(heatmap_df.pivot(\"rating\", \"year_added\", \"numVotes\"))\n\n# Creating the dataframe for the title_count heatmap\nheatmap_df2 = rating_df.groupby([\"year_added\", \"rating\"])[\"title\"].sum().reset_index()\nratings_pivot2 = pd.DataFrame(heatmap_df2.pivot(\"rating\", \"year_added\", \"title\"))\n\nfig, axes = plt.subplots(1, 2, figsize=(20, 8))\n\nsns.heatmap(ratings_pivot2, cmap=\"Blues\", ax=axes[0]);\naxes[0].set_title(\"Amount of Content Added by MPAA Rating and Year\")\naxes[0].set_xlabel(\"Year Added\")\naxes[0].set_ylabel(\"MPAA Rating\")\n\nsns.heatmap(ratings_pivot, cmap=\"Blues\", ax=axes[1]);\naxes[1].set_title(\"User Engagement (Number of Votes) with Content by Type and Year\")\naxes[1].set_xlabel(\"Year Added\")\naxes[1].set_ylabel(\"MPAA Rating\")\n\nplt.tight_layout(pad=5)","333e0c2b":"director_df = df.groupby([\"country\", \"rating\", \"year_added\", \"director\"]).agg({\"averageRating\":\"mean\", \"title\":\"count\"}).reset_index()\ndirector_df = pd.DataFrame(director_df[director_df[\"director\"] != \"Unknown\"].groupby(\"director\")[\"title\"].sum().sort_values(ascending=False)).reset_index().head(10)\ndirector_df = director_df.rename({\"title\":\"number_of_titles\"}, axis=1)\ndirector_df.style.hide_index()","7de88508":"director_df = df.groupby([\"country\", \"rating\", \"year_added\", \"director\"]).agg({\"averageRating\":\"mean\", \"title\":\"count\"}).reset_index()\ndirector_df = pd.DataFrame(director_df[(director_df[\"director\"] != \"Unknown\") & (director_df[\"title\"] >= 5)].groupby(\"director\")[\"averageRating\"].mean().sort_values(ascending=False)).reset_index().head(10)\ndirector_df.style.hide_index()","f341fede":"test_df2 = df[df[\"type\"] == \"Movie\"].sort_values([\"release_year\", \"averageRating\"], ascending=False)\n\nmax_df = pd.DataFrame()\n\nfor year in df[\"release_year\"].unique():\n  max_df = pd.concat([max_df, test_df2[test_df2[\"release_year\"] == year].sort_values(\"averageRating\", ascending=False).iloc[[0]]])\n\ntest_df = df[df[\"type\"] == \"Movie\"].groupby(\"release_year\")[\"averageRating\"].mean().sort_values(ascending=False).reset_index()\ntest_df[\"best_movie\"] = test_df[\"release_year\"].map(lambda x: max_df[max_df[\"release_year\"] == x][\"title\"].item())\ntest_df[\"director\"] = test_df[\"release_year\"].map(lambda x: max_df[max_df[\"release_year\"] == x][\"director\"].item())\ntest_df[\"best_movie_user_rating\"] = test_df[\"release_year\"].map(lambda x: max_df[max_df[\"release_year\"] == x][\"averageRating\"].item())\ntest_df[\"best_movie_country\"] = test_df[\"release_year\"].map(lambda x: max_df[max_df[\"release_year\"] == x][\"country\"].item())\ntest_df[\"num_votes\"] = test_df[\"release_year\"].map(lambda x: max_df[max_df[\"release_year\"] == x][\"numVotes\"].item())\ntest_df[\"num_movies_released_this_year\"] = test_df[\"release_year\"].map(lambda x: df[(df[\"type\"] == \"Movie\") & (df[\"release_year\"] == x)].groupby(\"release_year\")[\"title\"].count().item())\n\ntest_df.head(10)","6f91ef43":"country_list = df[(df.country.isna() == False) & (df.country_count == 1)].country.sort_values().unique().tolist()\n\ncountry_select = widgets.Dropdown(\n                    options = country_list,\n                    value = 'United States',\n                    description = 'Countries',\n                    disabled = False)\n\ndisplay(country_select)\n\nbutton = widgets.Button(description=\"TV Shows\")\nbutton1 = widgets.Button(description=\"Movies\")\noutput = widgets.Output()\noutput1 = widgets.Output()\n\nmatplotlib.rcParams[\"font.size\"] = 15\n\ndisplay(button, output)\ndisplay(button1, output1)\n\ndef on_button_clicked(b):\n    tv_df = df[(df.country.str.contains(country_select.value)) & (df.type == 'TV Show')].sort_values('numVotes', ascending=False)\n    with output:\n        if tv_df.index.size == 0:\n          print(\"Cannot Graph.\")\n        else:\n          plt.title(label='Popular TV Shows in ' + country_select.value)\n          sns.barplot(x=tv_df.averageRating.head(5), y=tv_df.title.head(5))\n        \ndef on_button_clicked1(b):\n    movie_df = df[(df.country.str.contains(country_select.value)) & (df.type == 'Movie')].sort_values('numVotes', ascending=False)\n    with output1:\n        if movie_df.index.size == 0:\n          print(\"Cannot Graph.\")\n        else:\n          plt.title(label='Popular Movies in ' + country_select.value)\n          sns.barplot(x=movie_df.averageRating.head(5), y=movie_df.title.head(5))\n\nbutton.on_click(on_button_clicked)\nbutton1.on_click(on_button_clicked1)","0e495ac9":"plt.figure(figsize=(20,10))\nwordcloud = WordCloud(background_color='Black',\n                      width=1920,\n                      height=1080\n                      ).generate(\" \".join(df.description))\nplt.imshow(wordcloud)\nplt.axis('off')\nplt.savefig('cast.png')\nplt.show()","80db6b93":"### There are a couple of different ways we can choose to join the IMDb and Netflix dataframes so that the data lines up correctly.  I have chosen to combine them where idf['primaryTitle', 'startYear'] and ndf['title', 'release_year'] match; this will minimize mismatched rows.\n### Recall (and you can see just above) that idf[startYear] is of Dtype 'object'; we need to drop any non-numeric values and convert the column to 'int64' in order to compare the values with those of the Netflix dataframe.","36ab3e2b":"### All of the columns are of dtype 'object' and we do not get a null count.  This might present problems later in our analysis, but we will cross that bridge when we come to it.\n### Let's combine our two IMDb dataframes into a single dataframe, matching titles with their user ratings.  We will accomplish this by joining them on their 'tconst' column and making this the index of the resulting dataframe.","6639f3f8":"#### We can use a heatmap to visualize the amount of content uploaded per year for each MPAA rating.","876145f1":"### User ratings TV Shows appear to exceed those for Movies, especially in recent years.  Let's see if this observation holds across regions.  We can use IpyWidgets to make choosing a region easier.","d331f513":"### Let's check the info","31322015":"## How much of each type of content is available?","3b0fadc9":"# Exploratory Analysis and Visualization","41238bdb":"### We can visualize this with a wordcloud","79b33ae9":"### The Netflix download does not include any information on viewers' ratings; the 'rating' column in the above info refers to MPAA rating.  We can get users' rating info from IMDB.  They make their data available at https:\/\/datasets.imdbws.com.","041ab9ca":"## How do ratings vary by region?","9e276ffc":"## What are the distribution and density of user ratings?","5ddac2f8":"### Has this trend affected the type of content Netflix has been adding?","ac0974f3":"## How has the prevalence of MPAA ratings and users' opinions of them changed over time?","b851e46e":"## What are the most popular shows from each region?\n### Use the Dropdown menu below to select a country.","8b0367f1":"### In which years were the most highly rated movies released?","828af6d6":"## Data Creation and Cleaning","93d5325f":"### Let's convert all titles to lowercase to avoid misses and join the two dataframes","d30d016e":"### Who are the ten directors with the most content on Netflix?","7f12ef4d":"### Who are the ten most highly rated directors (with at least 5 titles on Netflix) according to IMDb rating?","b2438a49":"### Lots of TV content with \"Unknown\" as its country...  We'll explore this further in a future analysis.","77ca5ba3":"### We should parse the categorical 'date_added' column and make a numerical column from each of its constituent parts.  Let's get rid of any Null values.\n","ed8f2337":"## We can plot how ratings have changed over time.  We don't have timestamps from IMDb for when users cast input their rating, so let's use date added to Netflix and release year.","3caeeea2":"# Future Work","dc1d82d0":"# Analysis of Netflix Data with IMDB Ratings","85664f0d":"### The Dtypes of 'imdb_ratings_df' look correct and there appear to be no null entries.  Let's check 'imdb_titles_df'.","55382ad1":"## Use NLP for a recommendation system","5f64d29e":"##### \"Stopwords\" are removed and we are left with a visual representation of the frequency of words in the descriptions.","66fae01e":"### We'll create our dataframe using the attached data source.","6dc76229":"### The Null values are all in categorical columns.  I don't want to lose these titles if we don't have to; there may be some interesting patterns to uncover in a future, more in depth, exploration.  Let's change them to the string \"Unknown\".","481159b8":"### Next, getting a count of the number of countries involved in a title's release will help our analysis down the line.","d4b0b174":"## How many regions is Netflix available in?","0c45f30f":"## What words are most commonly used in the descriptions?","1915b5eb":"## Implement N-grams for actor\/director combinations to make predictions on user ratings.","8c294f48":"<table>\n    <tr>\n        <td>\n            <img src=\"https:\/\/media.wearemotto.com\/wp-content\/uploads\/2018\/11\/11001644\/Netflix-Hero-Bingwatch.jpg\">\n        <\/td>\n        <td>\n            <p style=\"font-size:80px; font-weight:bold;\">+<\/p>\n        <\/td>\n        <td>\n            <img src=\"https:\/\/www.pngkey.com\/png\/full\/343-3433435_facebook-imdb-icon.png\" style=\"width:50%\">\n        <\/td>\n    <\/tr>\n<\/table>","79920112":"## Visualize things like most prolific director, actor, etc.","f211f80c":"### Since the IMDB database is so vast, it comes in multiple files.  I only grabbed the two that I need to make a connection to the Netflix data: 'title.ratings.tsv' and 'title.basics.tsv'.  Let's have a look at the two IMDb dataframes separately and make sure the data is valid."}}