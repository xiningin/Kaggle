{"cell_type":{"697ec0e5":"code","e97e5bc4":"code","e11768a2":"code","76b833f3":"code","d5eb6173":"code","44655ac7":"code","80aab939":"code","8c9414ed":"code","df998e27":"code","0d86ba9b":"code","14429f0c":"code","88145111":"code","7085bb4c":"code","51e48741":"code","a16bbffa":"code","3bbc16b9":"code","a7b7f34f":"code","c33a2847":"code","77b39d37":"markdown","dcf837b9":"markdown","7629583e":"markdown","76733b52":"markdown","3848ec96":"markdown","8cae6942":"markdown","9aca729b":"markdown"},"source":{"697ec0e5":"from collections import OrderedDict\nfrom pathlib import Path\nimport operator as op\nfrom functools import reduce\n\nimport pandas as pd\nimport numpy as np\nfrom tqdm import tqdm\nimport matplotlib.pyplot as plt\nimport seaborn as sns","e97e5bc4":"ROOT = Path('\/kaggle\/input\/random-shopping-cart\/')\n\nMIN_SUPPORT = 0.1","e11768a2":"def generate_c1(basket):\n    c1 = OrderedDict()\n    num_transactions = len(basket)\n    \n    # Find and count all the items in the basket\n    for transaction in basket:\n        for item in transaction:\n            if tuple([item]) in c1.keys():\n                c1[tuple([item])] += 1 \/ num_transactions\n            else:\n                c1[tuple([item])] = 0\n\n    return c1\n\ndef ncr(n, r):\n    r = min(r, n-r)\n    numer = reduce(op.mul, range(n, n-r, -1), 1)\n    denom = reduce(op.mul, range(1, r+1), 1)\n    return numer \/\/ denom\n\ndef is_acceptable(list_of_lk, list_of_items):\n    len_list_of_items = len(list_of_items)\n    num_comb = ncr(len_list_of_items, len_list_of_items-1)\n    if len(list_of_lk) < num_comb:\n        return False\n\n    set_of_items = set(list_of_items)\n\n    i = 0\n    for candidate in list_of_lk:\n        if set(candidate).issubset(set_of_items):\n            i += 1\n\n    if i == num_comb:\n        return True\n    else:\n        return False\n\ndef generate_ck(basket, lk_minus_1):\n    list_of_lk_minus_1 = list(lk_minus_1.keys())\n    len_list_of_lk_minus_1 = len(list_of_lk_minus_1)\n    num_transactions = len(basket)\n    \n    ck = OrderedDict()\n\n    for i in range(len_list_of_lk_minus_1 - 1):\n        for j in range(i + 1, len_list_of_lk_minus_1):\n            first_list = sorted(list_of_lk_minus_1[i])\n            second_list = sorted(list_of_lk_minus_1[j])\n            \n            if first_list[:-1] == second_list[:-1]:\n                new_list = sorted(list(first_list) + [second_list[-1]])\n\n                # Pruning\n                if is_acceptable(list_of_lk_minus_1, new_list):\n                    # Count the number of occurrences\n                    k = 0\n                    for transaction in basket:\n                        if set(new_list).issubset(transaction):\n                            k += 1 \/ num_transactions\n\n                    ck[tuple(new_list)] = k\n\n    return ck\n\ndef get_lk(ck_minus_1, min_sup):\n    return {k: v for k, v in ck_minus_1.items() if v >= min_sup}","76b833f3":"df = pd.read_csv(ROOT \/ 'dataset_group.csv', header=None, names=['date', 'transaction_id', 'item'])","d5eb6173":"df","44655ac7":"basket = []\n\nfor transaction_id in tqdm(df.transaction_id.unique()):\n    items = []\n    for item in df[df.transaction_id == transaction_id].item:\n        items.append(item)\n        \n    basket.append(items)","80aab939":"len_trans = [len(tran) for tran in basket]","8c9414ed":"print('min:', min(len_trans))\nprint('max:', max(len_trans))\nsns.distplot(len_trans)\nplt.show()","df998e27":"ci = generate_c1(basket)\nli = get_lk(ci, MIN_SUPPORT)\n\nall_l = li.copy()\n\nwhile len(li) > 0:\n    print(len(li))\n    li_minus_1 = li.copy()\n    ci = generate_ck(basket, li)\n    li = get_lk(ci, MIN_SUPPORT)\n    \n    all_l.update(li)","0d86ba9b":"# for list_of_items, support in li_minus_1.items():\n#     print(f'{list_of_items} | {support}')","14429f0c":"result_dict = {}\n\nfor idx, col in enumerate(np.array(list(li_minus_1.keys())).T):\n    result_dict[f'item {idx+1}'] = col\n    \nresult_dict['support'] = list(li_minus_1.values())","88145111":"result_df = pd.DataFrame(result_dict).sort_values('support', ascending=False, ignore_index=True)","7085bb4c":"result_df","51e48741":"l1 = {k: v for k, v in all_l.items() if len(k) == 1}\nl2 = {k: v for k, v in all_l.items() if len(k) == 2}","a16bbffa":"confidence_dict = dict()\n\nfor list_of_items, support in l2.items():\n    for item in list_of_items:\n        confidence_dict[tuple([item] + list(set(list_of_items) - set([item])))] = support \/ l1[(item,)]","3bbc16b9":"# confidence_dict","a7b7f34f":"confidence_df = pd.DataFrame({\n    'rule': [' => '.join(pair) for pair in confidence_dict.keys()],\n    'confidence': list(confidence_dict.values())\n}).sort_values('confidence', ascending=False, ignore_index=True)","c33a2847":"confidence_df","77b39d37":"# Import libraries","dcf837b9":"# Define helper-functions","7629583e":"# Start the Apriori algorithm","76733b52":"# Configure hyper-parameters","3848ec96":"# Get data","8cae6942":"Create the basket","9aca729b":"# Try to extract rules from L2"}}