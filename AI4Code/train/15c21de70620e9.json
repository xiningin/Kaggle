{"cell_type":{"b1146737":"code","b3a6ee38":"code","9365f30e":"code","84a96f30":"code","90f68bf4":"code","29ee586f":"code","f4131346":"code","9a890672":"code","6c4814c1":"code","29fe5ab1":"code","c48a54d4":"code","c5727024":"code","51e89ce5":"code","1451c628":"code","89456b1d":"code","0f500f6a":"code","55951b3a":"code","b3648da3":"markdown","dcfe5f2a":"markdown","c1d24a50":"markdown","27e8a388":"markdown","ccccc783":"markdown","56243123":"markdown","8018b596":"markdown","040406e4":"markdown","155c5d5f":"markdown","ded7525b":"markdown","676a42f7":"markdown"},"source":{"b1146737":"seed = 42\nnfold = 5","b3a6ee38":"import numpy as np \nimport pandas as pd \nimport os\nfrom sklearn.cluster import KMeans\nfrom tqdm import tqdm\nfrom sklearn.preprocessing import LabelEncoder\nfrom collections import Counter, defaultdict\nfrom sklearn.utils import check_random_state","9365f30e":"train = pd.read_csv('..\/input\/ranzcr-clip-catheter-line-classification\/train.csv')\ntrain.head()","84a96f30":"train.nunique()","90f68bf4":"train.PatientID.value_counts()","29ee586f":"class RepeatedStratifiedGroupKFold():\n\n    def __init__(self, n_splits=5, n_repeats=1, random_state=None):\n        self.n_splits = n_splits\n        self.n_repeats = n_repeats\n        self.random_state = random_state\n        \n    def split(self, X, y=None, groups=None):\n        k = self.n_splits\n        def eval_y_counts_per_fold(y_counts, fold):\n            y_counts_per_fold[fold] += y_counts\n            std_per_label = []\n            for label in range(labels_num):\n                label_std = np.std(\n                    [y_counts_per_fold[i][label] \/ y_distr[label] for i in range(k)]\n                )\n                std_per_label.append(label_std)\n            y_counts_per_fold[fold] -= y_counts\n            return np.mean(std_per_label)\n            \n        rnd = check_random_state(self.random_state)\n        for repeat in range(self.n_repeats):\n            labels_num = np.max(y) + 1\n            y_counts_per_group = defaultdict(lambda: np.zeros(labels_num))\n            y_distr = Counter()\n            for label, g in zip(y, groups):\n                y_counts_per_group[g][label] += 1\n                y_distr[label] += 1\n\n            y_counts_per_fold = defaultdict(lambda: np.zeros(labels_num))\n            groups_per_fold = defaultdict(set)\n        \n            groups_and_y_counts = list(y_counts_per_group.items())\n            rnd.shuffle(groups_and_y_counts)\n\n            for g, y_counts in sorted(groups_and_y_counts, key=lambda x: -np.std(x[1])):\n                best_fold = None\n                min_eval = None\n                for i in range(k):\n                    fold_eval = eval_y_counts_per_fold(y_counts, i)\n                    if min_eval is None or fold_eval < min_eval:\n                        min_eval = fold_eval\n                        best_fold = i\n                y_counts_per_fold[best_fold] += y_counts\n                groups_per_fold[best_fold].add(g)\n            \n            all_groups = set(groups)\n            for i in range(k):\n                train_groups = all_groups - groups_per_fold[i]\n                test_groups = groups_per_fold[i]\n\n                train_indices = [i for i, g in enumerate(groups) if g in train_groups]\n                test_indices = [i for i, g in enumerate(groups) if g in test_groups]\n\n                yield train_indices, test_indices","f4131346":"# let's first concat all the labels \n# e.g 00000000010   \ntarget_cols = train.drop(['StudyInstanceUID', 'PatientID'],axis=1).columns.values.tolist()\ntargets = train[target_cols].astype(str)\n# create a new col to store the label\ntrain['combined_tar'] = ''\nfor i in tqdm(range(targets.shape[1])):\n    train['combined_tar'] += targets.iloc[:,i]\n# take a look at it\ntrain.combined_tar.value_counts()","9a890672":"train['combined_tar'] = LabelEncoder().fit_transform(train['combined_tar'])","6c4814c1":"train['fold'] = -1\nrskf = RepeatedStratifiedGroupKFold(n_splits=nfold, random_state=42)\nfor i, (train_idx, valid_idx) in enumerate(rskf.split(train, train.combined_tar, train.PatientID)): #(df, targets, group)\n    train.loc[valid_idx, 'fold'] = int(i)","29fe5ab1":"train.query('fold==0').combined_tar.value_counts()","c48a54d4":"train.query('fold==1').combined_tar.value_counts()","c5727024":"train.query('fold==2').combined_tar.value_counts()","51e89ce5":"np.intersect1d(train.query('fold==0').PatientID.unique(), train.query('fold==1').PatientID.unique())","1451c628":"np.intersect1d(train.query('fold==1').PatientID.unique(), train.query('fold==2').PatientID.unique())","89456b1d":"np.intersect1d(train.query('fold==2').PatientID.unique(), train.query('fold==3').PatientID.unique())","0f500f6a":"train.drop('combined_tar', axis=1)","55951b3a":"train.drop('combined_tar', axis=1).to_csv('train_folds.csv', index=False)","b3648da3":"## Utils","dcfe5f2a":"No patient has appeared in two folds.","c1d24a50":"It seems that the label is very nicely stratified. Now let's check groups.","27e8a388":"## Params","ccccc783":"As we can see, we only have 3255 patients. We want to make sure that each patient's images do not appear in multiple folds to avoid data leakage.","56243123":"## Sanity Check\nYou wanna make sure this split makes sense. We can do that by checking the stratification and groups.","8018b596":"## Split folds\nIdeas:\n1. make sure that the labels are stratified\n2. one patient's images are grouped in one fold","040406e4":"## Imports","155c5d5f":"## Save final CSV","ded7525b":"Some patient has 172 images and some only has 1.","676a42f7":"## Basic EDA"}}