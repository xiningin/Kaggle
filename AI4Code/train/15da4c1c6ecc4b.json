{"cell_type":{"abd4955f":"code","a3ca3020":"code","1402d326":"code","b9b7c08d":"code","8fdeef05":"code","b528b27a":"code","471ff3d7":"code","552a2474":"code","776bb9e7":"code","a9ea3ff0":"code","68d3f16e":"code","ad38b63a":"code","f3df4835":"code","b17d283a":"markdown","83cb779e":"markdown","b2f5f161":"markdown","41140926":"markdown"},"source":{"abd4955f":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom sklearn.preprocessing import MinMaxScaler\n\nfrom tensorflow.keras.callbacks import ReduceLROnPlateau , ModelCheckpoint\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, BatchNormalization, Dropout, Activation\nfrom tensorflow.keras.layers import LSTM , GRU\nfrom tensorflow.keras.optimizers import Adam, SGD, RMSprop\n\nimport math, time","a3ca3020":"df = pd.read_csv('..\/input\/nyse\/prices-split-adjusted.csv')\ndf.head()","1402d326":"df.describe().T","b9b7c08d":"df.info()","8fdeef05":"df['symbol'].unique()","b528b27a":"securities = pd.read_csv('..\/input\/nyse\/securities.csv')\nsecurities.head()","471ff3d7":"securities.info()","552a2474":"securities.columns","776bb9e7":"def plot_graph(code):\n    global closing_stock\n    global opening_stock\n    f, axs = plt.subplots(2,2,figsize=(8,8))\n    plt.subplot(212)\n    company = df[df['symbol']==code]\n    company = company.open.values.astype('float32')\n    company = company.reshape(-1, 1)\n    opening_stock = company\n    plt.grid(True)\n    plt.xlabel('Time')\n    plt.ylabel(code + \" open stock prices\")\n    plt.title('prices Vs Time')\n    plt.plot(company , 'g')\n    \n    plt.subplot(211)\n    company_close = df[df['symbol']==code]\n    company_close = company_close.close.values.astype('float32')\n    company_close = company_close.reshape(-1, 1)\n    closing_stock = company_close\n    plt.xlabel('Time')\n    plt.ylabel(code + \" close stock prices\")\n    plt.title('prices Vs Time')\n    plt.grid(True)\n    plt.plot(company_close , 'b')\n    plt.show()","a9ea3ff0":"def process_data(data , n_features):\n    X, Y = [], []\n    for i in range(len(data)-n_features-1):\n        a = data[i:(i+n_features), 0]\n        X.append(a)\n        Y.append(data[i + n_features, 0])\n    return np.array(X), np.array(Y)","68d3f16e":"def model_score(model, X_train, y_train, X_test, y_test):\n    trainScore = model.evaluate(X_train, y_train, verbose=0)\n    print('Train Score: %.5f MSE , %.2f RMSE' % (trainScore[0], math.sqrt(trainScore[0])))\n    testScore = model.evaluate(X_test, y_test, verbose=0)\n    print('Test Score: %.5f MSE , %.2f RMSE' % (testScore[0], math.sqrt(testScore[0])))\n    return trainScore[0], testScore[0]","ad38b63a":"def MODEL():\n    input_name = input('Enter Company Name: ')\n    input_symbol = input('Enter corresponding Ticker Symbol: ')\n    print(\"\\n\\nStarting Process for: \", input_name)\n    plot = securities.loc[(securities.Security == input_name), [\"Ticker symbol\"] ][\"Ticker symbol\"]\n\n    # Plotting Stock Price and Volume\n    plt.figure(figsize=(15, 5));\n    plt.subplot(1,2,1);\n    plt.plot(df[df.symbol == input_symbol].open.values, color='red', label='open')\n    plt.plot(df[df.symbol == input_symbol].close.values, color='green', label='close')\n    plt.plot(df[df.symbol == input_symbol].low.values, color='blue', label='low')\n    plt.plot(df[df.symbol == input_symbol].high.values, color='black', label='high')\n    plt.title('stock price')\n    plt.xlabel('time [days]')\n    plt.ylabel('price')\n    plt.legend(loc='best')\n\n    plt.subplot(1,2,2);\n    plt.plot(df[df.symbol == input_symbol].volume.values, color='black', label='volume')\n    plt.title('stock volume')\n    plt.xlabel('time [days]')\n    plt.ylabel('volume')\n    plt.legend(loc='best')\n\n    for x in plot:\n        plot_graph(x)\n\n    stocks = closing_stock[: , 0]\n    print(\"Stocks: \",stocks,\"\\n\")\n    stocks = stocks.reshape(len(stocks) , 1)\n    scaler = MinMaxScaler(feature_range=(0, 1))\n    stocks = scaler.fit_transform(stocks)\n\n    train = int(len(stocks) * 0.80)\n    test = len(stocks) - train\n\n    train = stocks[0:train]\n    test = stocks[len(train) : ]\n    train = train.reshape(len(train) , 1)\n    test = test.reshape(len(test) , 1)\n\n    n_features = 2\n    Xtrain, Ytrain = process_data(train, n_features)\n    Xtest, Ytest = process_data(test, n_features)\n    print(Xtrain.shape , Ytrain.shape , Xtest.shape , Ytest.shape)\n\n    Xtrain = Xtrain.reshape(Xtrain.shape[0] , 1 ,Xtrain.shape[1])\n    Xtest = Xtest.reshape(Xtest.shape[0] , 1 ,Xtest.shape[1])\n\n    #   filepath=input_filepath\n    lrr = ReduceLROnPlateau(monitor='val_loss', factor=0.1, min_delta=0.0001, patience=1, verbose=1)\n    checkpoint = ModelCheckpoint(filepath, monitor='val_loss', verbose=1, save_best_only=True, mode='max')\n\n    model = Sequential()\n    model.add(GRU(256, input_shape = (1, n_features), return_sequences=True))\n    model.add(Dropout(0.4))\n    model.add(LSTM(256))\n    model.add(Dropout(0.4))\n    model.add(Dense(64 ,  activation = 'relu'))\n    model.add(Dense(1))\n\n    print(\"Model Summary:\\n\", model.summary(), \"\\n\\n\")\n\n    start = time.time()\n    model.compile(loss='mean_squared_error', optimizer=Adam(lr = 0.0005) , metrics = ['mean_squared_error'])\n    history = model.fit(Xtrain, Ytrain, epochs=100 , batch_size = 128 , \n        callbacks = [checkpoint , lrr] , validation_data = (Xtest,Ytest))\n\n    plt.figure(figsize=(7, 5))\n    plt.plot(history.history['mean_squared_error'])\n    plt.plot(history.history['val_mean_squared_error'])\n    plt.title('model (Mean Squared Error)')\n    plt.ylabel('Accuracy')\n    plt.xlabel('Epoch')\n    plt.legend(['train', 'test'], loc='upper right')\n    plt.show()\n\n    plt.figure(figsize=(7, 5))\n    plt.plot(history.history['loss'])\n    plt.plot(history.history['val_loss'])\n    plt.title('Model loss')\n    plt.ylabel('Loss')\n    plt.xlabel('Epoch')\n    plt.legend(['train', 'test'], loc='upper right')\n    plt.show()\n\n    model_score(model, Xtrain, Ytrain , Xtest, Ytest)\n\n    Ytest = Ytest.reshape(Ytest.shape[0] , 1)\n    Ytest = scaler.inverse_transform(Ytest)\n\n    pred = model.predict(Xtest)\n    pred = scaler.inverse_transform(pred)\n\n    print(\"Red - Predicted Stock Prices  ,  Blue - Actual Stock Prices\")\n    plt.rcParams[\"figure.figsize\"] = (15,7)\n    plt.plot( Ytest , 'b')\n    plt.plot(pred , 'r')\n    plt.xlabel('Time')\n    plt.ylabel('Stock Prices')\n    plt.title('Check the accuracy of the model with time')\n    plt.legend(['Actual Stock Prices ', ' Predicted Stock Prices'], loc='upper right')\n    plt.grid(True)\n    plt.show()","f3df4835":"MODEL()","b17d283a":"# Defining Functions for further stock visualizations and predicting prices using LSTM","83cb779e":"# Importing Necessary Libraries","b2f5f161":"**No null values**","41140926":"# Importing and preprocessing data"}}