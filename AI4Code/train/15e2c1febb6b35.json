{"cell_type":{"40d07e21":"code","9d0be414":"code","80527c9b":"code","57bdf266":"code","5ef0ffe6":"code","a920ee97":"code","35f64730":"code","149e461b":"code","693d1dc3":"code","f9c6c43b":"code","89649b3e":"code","46eb7c7a":"code","e0cc0084":"code","f30b2ea5":"code","26464022":"code","9eddb0f5":"code","b2403af8":"code","3fcd514e":"code","c42e8d3e":"code","098e4aae":"code","185da4fe":"code","33aba365":"code","a79d5909":"code","3bbb4640":"code","0c0b2c3c":"code","48d49ca3":"markdown","dcd80287":"markdown","7534f638":"markdown","9f25f8ee":"markdown","59040c51":"markdown","fa14a25a":"markdown","d6baca68":"markdown","185dea2a":"markdown","9c150ba1":"markdown","5dd040c3":"markdown","ee8e6f1d":"markdown","91b74341":"markdown"},"source":{"40d07e21":"!pip install hdbscan","9d0be414":"\nimport matplotlib.pyplot as plt\n\n\nimport pandas as pd\nimport numpy as np\n\nfrom sklearn.cluster import KMeans, DBSCAN\nfrom sklearn.metrics import silhouette_score\nfrom sklearn.neighbors import KNeighborsClassifier\n\nimport hdbscan\nimport folium\nimport re\n\n\ncols = ['#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4',\n        '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff', \n        '#9a6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', \n        '#000075', '#808080']*10","80527c9b":"data=pd.read_csv(\"..\/input\/taxi_data.csv\")\ndata.head()","57bdf266":"data.duplicated(subset=['LON','LAT']).values.any()","5ef0ffe6":"data.isnull().values.any()","a920ee97":"print(f'Before dropping NaNs and dupes\\t:\\tdf.shape = {data.shape}')\ndata.dropna(inplace=True)\ndata.drop_duplicates(subset=['LON','LAT'],keep='first',inplace=True)\nprint(f'After dropping NaNs and dupes\\t:\\tdf.shape = {data.shape}')","35f64730":"X=np.array(data[['LON','LAT']],dtype='float64')\nplt.scatter(X[:,0],X[:,1],alpha=0.2,s=50)\nplt.grid(True)","149e461b":"plt_map=folium.Map(location=[data.LAT.mean(),data.LON.mean()],zoom_start=10,\n             tiles='OpenStreetMap')\nfor _,row in data.iterrows():\n    folium.CircleMarker(\n        location=[row.LAT,row.LON],\n        radius=5,\n        popup=re.sub(r'[^a-zA-Z ]+','',row.NAME),\n        color='blue',\n        fill=True\n    ).add_to(plt_map)\nplt_map","693d1dc3":"k_range=range(5,150,5)\nkmeans_per_k=[]\nfor k in k_range:\n    kmeans=KMeans(n_clusters=k,random_state=42).fit(X)\n    kmeans_per_k.append(kmeans)","f9c6c43b":"silh_scores=[silhouette_score(X,model.labels_) for model in kmeans_per_k]\nbest_index = np.argmax(silh_scores)\nbest_k = k_range[best_index]\nbest_score = silh_scores[best_index]\nprint(\"best k value:\",best_k)\nprint(\"silhouette score:\",best_score)\n\nplt.figure(figsize=(8, 3))\nplt.grid(True)\nplt.plot(k_range, silh_scores, \"bo-\")\nplt.xlabel(\"k\", fontsize=14)\nplt.ylabel(\"Silhouette score\", fontsize=14)\nplt.plot(best_k, best_score, \"rs\")\nplt.show()\n","89649b3e":"inertias = [model.inertia_ for model in kmeans_per_k]\nbest_inertia = inertias[best_index]\n\nplt.figure(figsize=(8, 3.5))\nplt.grid(True)\nplt.plot(k_range, inertias, \"bo-\")\nplt.xlabel(\"$k$\", fontsize=14)\nplt.ylabel(\"Inertia\", fontsize=14)\nplt.plot(best_k, best_inertia, \"rs\")\nplt.show()\n","46eb7c7a":"k=70\nmodel=KMeans(n_clusters=k,random_state=17).fit(X)\npred=model.predict(X)\ndata[f'CLUSTER_kmeans']=pred","e0cc0084":"def create_map(data,cluster_col):\n    m = folium.Map(location=[data.LAT.mean(), data.LON.mean()], zoom_start=9, tiles='openstreetmap')\n\n    for _, row in data.iterrows():\n\n        # get a colour\n        if row[cluster_col]==-1:\n            cluster_colour='black'\n        else:\n            cluster_colour = cols[row[cluster_col]]\n\n        folium.CircleMarker(\n            location=[row.LAT,row.LON],\n            radius=5,\n            popup= row[cluster_col],\n            color=cluster_colour,\n            fill=True,\n            fill_color=cluster_colour\n        ).add_to(m)\n    return m\n\nplt_map=create_map(data,'CLUSTER_kmeans')   \nprint(f'Silhouette Score: {silhouette_score(X, pred)}')\nplt_map.save('kmeans_map.html')\nplt_map","f30b2ea5":"\ndummy = np.array([-1, -1, -1, 2, 3, 4, 5, -1])\nnew=np.array([(counter+2)*x if x==-1 else x for counter,x in enumerate(dummy)])\nnew","26464022":"model=DBSCAN(eps=0.01,min_samples=5).fit(X)\nclass_predictions=model.labels_\ndata['Clusters_dbscan']=class_predictions\ndata.head()","9eddb0f5":"\nprint(f'Number of clusters found: {len(np.unique(class_predictions))}')\nprint(f'Number of outliers found: {len(class_predictions[class_predictions==-1])}')\n\nprint(f'Silhouette ignoring outliers: {silhouette_score(X[class_predictions!=-1], class_predictions[class_predictions!=-1])}')\n\nno_outliers = 0\nno_outliers = np.array([(counter+2)*x if x==-1 else x for counter, x in enumerate(class_predictions)])\nprint(f'Silhouette outliers as singletons: {silhouette_score(X, no_outliers)}')\nplt_map=create_map(data,'Clusters_dbscan')\nplt_map.save('DBSCAN_map.html')\nplt_map","b2403af8":"model=hdbscan.HDBSCAN(min_cluster_size=5,min_samples=2,cluster_selection_epsilon=0.01)\nclass_predictions=model.fit_predict(X)\ndata['CLUSTER_hdbscan']=class_predictions\ndata.head()","3fcd514e":"\nprint(f'Number of clusters found: {len(np.unique(class_predictions))-1}')\nprint(f'Number of outliers found: {len(class_predictions[class_predictions==-1])}')\n\nprint(f'Silhouette ignoring outliers: {silhouette_score(X[class_predictions!=-1], class_predictions[class_predictions!=-1])}')\n\nno_outliers = np.array([(counter+2)*x if x==-1 else x for counter, x in enumerate(class_predictions)])\nprint(f'Silhouette outliers as singletons: {silhouette_score(X, no_outliers)}')\n\nm=create_map(data,'CLUSTER_hdbscan')\nplt_map.save(\"HDBSCAN_map.html\")\nplt_map","c42e8d3e":"classifier=KNeighborsClassifier(n_neighbors=3)","098e4aae":"data_train=data[data.CLUSTER_hdbscan!=-1]\ndata_predict=data[data.CLUSTER_hdbscan==-1]","185da4fe":"X_train=np.array(data_train[['LON','LAT']],dtype='float64')\ny_train=np.array(data_train['CLUSTER_hdbscan'])\n\nX_predict=np.array(data_predict[['LON',\"LAT\"]],dtype='float64')","33aba365":"classifier.fit(X_train,y_train)\npred=classifier.predict(X_predict)\npred","a79d5909":"data['CLUSTER_hybrid']=data['CLUSTER_hdbscan']\ndata.loc[data.CLUSTER_hdbscan==-1,'CLUSTER_hybrid']=pred\ndata.head()","3bbb4640":"class_predictions=data.CLUSTER_hybrid\nprint(f'Number of clusters found: {len(np.unique(class_predictions))}')\nprint(f'Silhouette: {silhouette_score(X, class_predictions)}')\nplt_map=create_map(data,'CLUSTER_hybrid')\nplt_map.save('hybrid_map.html')\nplt_map","0c0b2c3c":"data['CLUSTER_hybrid'].value_counts().plot.hist(bins=70,alpha=0.5,label='hybrid')\ndata['CLUSTER_kmeans'].value_counts().plot.hist(bins=70,alpha=0.5,label='kmeans')\n\nplt.legend()\n\nplt.grid(True)\nplt.title('Comparing Hybrid and K-Means Approaches')\nplt.xlabel('cluster sizes')","48d49ca3":"#### To find out the optimal number of clusters, I have used two metrics inertias and silhouette scores.Silhouetter scores range between -1 and 1 a silhouette score closer to one and greater than 0 indicates accurate clustering and sufficent distance between other clusters and itself.","dcd80287":"#### As you can see there is a substantial decrease in no. of outliers from 289 to 102. We will see how to handle them in the next section.","7534f638":"<a id='1'><\/a>\n# Exploratory Data Analysis","9f25f8ee":"# Clustering Geolocation Data\n\nWe have taxi rank locations, and want to define key clusters of these taxis where we can build service stations for all taxis operating in that region.I begin with EDA and DataViz and proceed using KMeans,DBSCAN,HDBSCAN and then finally address the outliers.\n\n\n## Outline\n\n[Exploratory Data Analysis](#1)\n\n[Visualizing Geographical Data](#2)\n\n[K-Means Clustering](#3)\n\n[DBSCAN](#4)\n\n[HDBSCAN](#5)\n\n[Addressing Outliers](#6)\n\n","59040c51":"#### Inertia is the sum of the squared distances between each training instance and its closest centroidi.e. lower is better.Here we can see that inertia has lowered significantly after 60 clusters and there is no significant change after 60.Thus taking k=115 is too high causing unecessary cutting of clusters. Thus k=70 would be a reasonably good value of k. You will see that other algorithms produce almost same numner of clusters.","fa14a25a":"<a id='4'><\/a>\n# DBSCAN \n#### Density-Based Spatial Clustering of Applications with Noise. DBSCAN assigns value -1 to any outliers.To find silhouette scores I have changed these vlaues. The below code is an example as to how I have done it.","d6baca68":"#### Even though the silhouette score decreased ,the hybrid approach has generally larger clusters which suggests that we are dealing with more information that is relevant and a better approach because as it is based on a density approach ,these clusters have more value so as to build service stations","185dea2a":"<a id='3'><\/a>\n# K-Means Clustering","9c150ba1":"<a id='2'><\/a>\n# Visualizing Geographical Data\n","5dd040c3":"<a id='6'><\/a>\n# Addressing Outliers\n#### One way to handle outliers is to apply a K nearest neighbor classifier on the outliers and assign them to the clusters which belong to their k nearest neighbor.For simplicity I have taken the  k value as 3.","ee8e6f1d":"<a id='5'><\/a>\n# HDBSCAN\n#### Hierarchical DBSCAN uses different set of hyperparameters to find different levels of density,usually reducing outliers.","91b74341":"#### I have named this as a hybrid model and added it to the dataframe."}}