{"cell_type":{"a1d8c392":"code","2c8a29cf":"code","8047ab91":"code","07fee8f0":"code","34684746":"code","f9913655":"code","bfbb270e":"code","2011bc32":"code","664ac1a6":"code","40a5d803":"code","98038aed":"code","96033921":"code","e1eb11b8":"code","9cc1bd9b":"code","a54592c6":"markdown","94d3fd82":"markdown","b6bc663d":"markdown"},"source":{"a1d8c392":"import itertools\nimport pandas as pd\nimport numpy as np","2c8a29cf":"mandatory = ['54'+''.join(x) for x in itertools.permutations(['1','2','3','6','7'], 5)]\n\nnon_mandatory = []\nall_permu = [''.join(x) for x in itertools.permutations(['1','2','3','4','5','6','7'], 7)]\nfor permu in all_permu:\n    if permu not in mandatory:\n        non_mandatory.append(permu)","8047ab91":"all_permu = mandatory + mandatory + mandatory + non_mandatory","07fee8f0":"size_dict = len(non_mandatory) + 3*len(mandatory)\ndist = np.empty((size_dict, size_dict), dtype=int)","34684746":"for k, permu in enumerate(all_permu):\n    for l, permu2 in enumerate(all_permu):\n        if permu == permu2:\n            continue\n        distance = 7\n        for i in range (1,7):\n            if permu2[:i] == permu[-i:]:\n                distance = 7 - i\n        dist[k,l] = distance","f9913655":"dist","bfbb270e":"\"\"\"Vehicles Routing Problem (VRP).\"\"\"\n\nfrom ortools.constraint_solver import pywrapcp\n\n\ndef get_routes(solution, routing, manager):\n    \"\"\"Get vehicle routes from a solution and store them in an array.\"\"\"\n    # Get vehicle routes and store them in a two dimensional array whose\n    # i,j entry is the jth location visited by vehicle i along its route.\n    routes = []\n    for route_nbr in range(routing.vehicles()):\n        index = routing.Start(route_nbr)\n        route = [manager.IndexToNode(index)]\n        while not routing.IsEnd(index):\n            index = solution.Value(routing.NextVar(index))\n            route.append(manager.IndexToNode(index))\n        routes.append(route)\n    return routes\n\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data['distance_matrix'] = dist\n    data['num_vehicles'] = 3\n    data['starts'] = [0, 120, 240]\n    data['ends'] = [0, 120, 240]\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    \"\"\"Prints solution on console.\"\"\"\n    print(f'Objective: {solution.ObjectiveValue()}')\n    max_route_distance = 0\n    for vehicle_id in range(data['num_vehicles']):\n        index = routing.Start(vehicle_id)\n        plan_output = 'Route for vehicle {}:\\n'.format(vehicle_id)\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += ' {} -> '.format(manager.IndexToNode(index))\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id)\n        plan_output += '{}\\n'.format(manager.IndexToNode(index))\n        plan_output += 'Distance of the route: {}m\\n'.format(route_distance)\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print('Maximum of the route distances: {}m'.format(max_route_distance))\n\ndef solve():\n    \"\"\"Solve the VRP problem.\"\"\"\n    \n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(len(data['distance_matrix']),\n                                           data['num_vehicles'], data['starts'],\n                                           data['ends'])\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n    \n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data['distance_matrix'][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n    # Add Distance constraint.\n    dimension_name = 'Distance'\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        3000,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name)\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n\n    # Set default search parameters.\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.time_limit.seconds = 300\n\n    # set mandatory locations SetAllowedVehiclesForIndex\n    for location_index in range(len(mandatory)):\n        routing.SetAllowedVehiclesForIndex([0], location_index) # vehicle 0\n    for location_index in range(len(mandatory), 2*len(mandatory)):\n        routing.SetAllowedVehiclesForIndex([1], location_index) # vehicle 1\n    for location_index in range(2*len(mandatory), 3*len(mandatory)):\n        routing.SetAllowedVehiclesForIndex([2], location_index) # vehicle 2\n    \n    # Solve the problem.\n    solution = routing.SolveWithParameters(search_parameters)\n    \n    # Print solution on console.\n    routes = False\n    if solution:\n        print('Solution after search:')\n        print_solution(data, manager, routing, solution)\n        routes = get_routes(solution, routing, manager)\n        \n    return routes","2011bc32":"routes = solve()","664ac1a6":"def get_string(my_route):\n    string = ''\n    for i, item in enumerate(my_route):\n        if i == 0:\n            string0 = all_permu[item]\n        else:\n            item_before = my_route[i-1]\n            dist_range = dist[item_before, item]\n            add_string = all_permu[item][-dist_range:]\n            string += add_string\n    print('length', len(string))\n    return string","40a5d803":"if routes:\n    string1 = get_string(routes[0])\n    string2 = get_string(routes[1])\n    string3 = get_string(routes[2])\nelse:\n    print ('No routes')\n    string1 = ''\n    string2 = ''\n    string3 = ''","98038aed":"all_permutations = [''.join(x) for x in itertools.permutations(['1','2','3','4','5','6','7'], 7)]\n\nfor p in all_permutations:\n    if p not in string1 and p not in string2 and p not in string3:\n        print(p)","96033921":"for p in mandatory:\n    if p not in string1:\n        print('string1', p)\n    if p not in string2:\n        print('string2', p)\n    if p not in string3:\n        print('string3', p)","e1eb11b8":"# Convert numbers to emojis\nreplace_dict = {\n '5': '\ud83c\udf85',\n '4': '\ud83e\udd36',\n '8': '\ud83c\udf1f',\n '1': '\ud83e\udd8c',\n '2': '\ud83e\udddd',\n '3': '\ud83c\udf84',\n '6': '\ud83c\udf81',\n '7': '\ud83c\udf80'}\n\nfor k,v in replace_dict.items():\n    string1 = string1.replace(k, v)\n    string2 = string2.replace(k, v)\n    string3 = string3.replace(k, v)","9cc1bd9b":"sub = pd.DataFrame()\nsub['schedule'] = [string1, string2, string3]\nsub.to_csv('submission.csv',index=False)\nsub.head()","a54592c6":"As described by @cdeotte [here](https:\/\/www.kaggle.com\/c\/santa-2021\/discussion\/288995), we can solve Santa 2021 as a routing problem. Here we solve it with Google OR-Tools using 3 vehicles so we will get 3 different routes. Then we convert each route to string to create the submission csv filve.","94d3fd82":"### Write Submission CSV","b6bc663d":"### Verify"}}