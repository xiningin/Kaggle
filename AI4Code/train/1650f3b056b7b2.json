{"cell_type":{"8a0645cf":"code","d75baa1a":"code","d8a1dde4":"code","bd5a90cf":"code","ef4d5e32":"code","25c84b36":"code","b07e1f9a":"code","e336db09":"code","9a8f3afc":"code","2983c040":"code","a787bfb4":"code","c72fcd3a":"code","cdc354f5":"code","ea02b597":"code","23ed25aa":"code","27e4943c":"code","6f0b8367":"code","e78c0128":"code","35e4f8de":"code","efe40a91":"code","a8ea07d0":"code","2e3f3fb9":"code","b43cbbc0":"code","0a77d2aa":"code","8e458166":"code","0368ed2a":"code","b04ee3a8":"code","e5d59282":"code","efb398a6":"code","a65aeacb":"code","db50cfcd":"markdown","38bfa700":"markdown","8191472b":"markdown","4d038597":"markdown"},"source":{"8a0645cf":"# DATA_PATH = '..\/input\/'\nDATA_PATH = '..\/input\/shopee-product-matching\/'\n\nimport psutil","d75baa1a":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport cv2, matplotlib.pyplot as plt\nfrom tqdm import tqdm_notebook\nimport gc\n\n# import cudf, cuml, cupy\n# from cuml.feature_extraction.text import TfidfVectorizer\n# from cuml.neighbors import NearestNeighbors\n\ndef getMetric(col):\n    def f1score(row):\n        n = len( np.intersect1d(row.target,row[col]) )\n        return 2*n \/ (len(row.target)+len(row[col]))\n    return f1score","d8a1dde4":"def stopwords(col):\n    col = col.apply(lambda x: [item for item in x if item not in stop])\n    return col","bd5a90cf":"COMPUTE_CV = False\n\ntest = pd.read_csv(DATA_PATH + 'test.csv')\nif len(test)>3: COMPUTE_CV = False\nelse: print('this submission notebook will compute CV score, but commit notebook will not')","ef4d5e32":"#COMPUTE_CV = False\n\nif COMPUTE_CV:\n    train = pd.read_csv(DATA_PATH + 'train.csv')\n    train['image'] = DATA_PATH + 'train_images\/' + train['image']\n    tmp = train.groupby('label_group').posting_id.agg('unique').to_dict()\n    train['target'] = train.label_group.map(tmp)\n    # train_gf = cudf.read_csv(DATA_PATH + 'train.csv')\nelse:\n    train = pd.read_csv(DATA_PATH + 'test.csv')\n    train['image'] = DATA_PATH + 'test_images\/' + train['image']\n    # train_gf = cudf.read_csv(DATA_PATH + 'test.csv')\n    \nprint('train shape is', train.shape )\ntrain.head()","25c84b36":"tmp = train.groupby('image_phash').posting_id.agg('unique').to_dict()\ntrain['oof_hash'] = train.image_phash.map(tmp)","b07e1f9a":"if COMPUTE_CV:\n    train['f1'] = train.apply(getMetric('oof_hash'),axis=1)\n    print('CV score for baseline =',train.f1.mean())","e336db09":"# train['title_word'] = train['title'].apply(lambda x: x.lower().split(' '))\n\n# from gensim.test.utils import get_tmpfile\n# from gensim.models import KeyedVectors\n\n# vectors = KeyedVectors.load_word2vec_format(\"..\/input\/glove2word2vec\/glove_w2v.txt\") # import the data file","9a8f3afc":"# title_feats = []\n# for title in tqdm_notebook(train['title_word'].values[:]):\n#     title_feat = []\n#     for word in title:\n#         if word in vectors:\n#             title_feat.append(vectors[word])\n#     if len(title_feat) == 0:\n#         title_feat = np.random.rand(200)\n#     else:\n#         title_feat = np.vstack(title_feat).max(0)\n#     title_feats.append(title_feat)\n#     # break\n    \n# del vectors;","2983c040":"# from sklearn.preprocessing import normalize\n\n# # l2 norm to kill all the sim in 0-1\n# title_feats = np.vstack(title_feats)\n# title_feats = normalize(title_feats)","a787bfb4":"# preds = []\n# CHUNK = 1024*4\n\n# title_feats = cupy.array(title_feats)\n\n# print('Finding similar images...')\n# CTS = len(title_feats)\/\/CHUNK\n# if len(title_feats)%CHUNK!=0: CTS += 1\n# for j in range( CTS ):\n    \n#     a = j*CHUNK\n#     b = (j+1)*CHUNK\n#     b = min(b, len(title_feats))\n#     print('chunk',a,'to',b)\n    \n#     distances = cupy.matmul(title_feats, title_feats[a:b].T).T\n#     # distances = np.dot(imagefeat[a:b,], imagefeat.T)\n    \n#     for k in range(b-a):\n#         IDX = cupy.where(distances[k,]>0.90)[0]\n#         # IDX = np.where(distances[k,]>0.95)[0][:]\n#         o = train.iloc[cupy.asnumpy(IDX)].posting_id.values\n#         preds.append(o)\n        \n# # del imagefeat, imgmodel","c72fcd3a":"# train['oof_w2v'] = preds\n\n# if COMPUTE_CV:\n#     train['f1'] = train.apply(getMetric('oof_w2v'),axis=1)\n#     print('CV score for baseline =',train.f1.mean())","cdc354f5":"from PIL import Image\n\nimport torch\ntorch.manual_seed(0)\ntorch.backends.cudnn.deterministic = False\ntorch.backends.cudnn.benchmark = True\n\nimport torchvision.models as models\nimport torchvision.transforms as transforms\nimport torchvision.datasets as datasets\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torch.autograd import Variable\nfrom torch.utils.data.dataset import Dataset\n\nclass ShopeeImageDataset(Dataset):\n    def __init__(self, img_path, transform):\n        self.img_path = img_path\n        self.transform = transform\n        \n    def __getitem__(self, index):\n        img = Image.open(self.img_path[index]).convert('RGB')\n        img = self.transform(img)\n        return img\n    \n    def __len__(self):\n        return len(self.img_path)","ea02b597":"\nclass ScaleIntensities():\n    def __init__(self, in_range, out_range):\n        \"\"\" Scales intensities. For example [-1, 1] -> [0, 255].\"\"\"\n        self.in_range = in_range\n        self.out_range = out_range\n\n    def __oldcall__(self, tensor):\n        tensor.mul_(255)\n        return tensor\n\n    def __call__(self, tensor):\n        tensor = (\n            tensor - self.in_range[0]\n        ) \/ (\n            self.in_range[1] - self.in_range[0]\n        ) * (\n            self.out_range[1] - self.out_range[0]\n        ) + self.out_range[0]\n        return tensor\n    \nclass Identity(): # used for skipping transforms\n    def __call__(self, im):\n        return im","23ed25aa":"rgb_to_bgr = False \nintensity_scale = [[0, 1], [0, 1]]\nmean = [0.485, 0.456, 0.406]\nstd = [0.229, 0.224, 0.225]\nsz_crop = 256\nsz_resize = 288\n\nimagedataset = ShopeeImageDataset(\n    train['image'].values,\n  transforms.Compose([\n        RGBToBGR() if rgb_to_bgr else Identity(),\n        #transforms.RandomRotation(rotate) if COMPUTE_CV and (not isinstance(rotate, numbers.Number)) else Identity(),\n        transforms.RandomResizedCrop(sz_crop) if COMPUTE_CV else Identity(),\n        transforms.Resize(sz_resize) if not COMPUTE_CV else Identity(),\n        transforms.CenterCrop(sz_crop) if not COMPUTE_CV else Identity(),\n        transforms.RandomHorizontalFlip() if COMPUTE_CV else Identity(),\n        transforms.ToTensor(),\n        ScaleIntensities(\n            *intensity_scale) if intensity_scale is not None else Identity(),\n        transforms.Normalize(\n            mean=mean,\n            std=std,\n        )\n    ]))\n    \nimageloader = torch.utils.data.DataLoader(\n    imagedataset,\n    batch_size=40, shuffle=False, num_workers=2\n)","27e4943c":"import torchvision.models as models\nimport torch.nn as nn\nimport torch\nimport numpy as np\nimport torch.nn.functional as F\n\nclass Feature(nn.Module):\n    def __init__(self, model='resnet50', pool='avg', use_lnorm=False):\n        nn.Module.__init__(self)\n        self.model = model\n\n        self.base = models.__dict__[model](pretrained=True)\n        if pool == 'avg':\n            self.pool = nn.AdaptiveAvgPool2d((1, 1))        \n        elif pool == 'max':\n            self.pool = nn.AdaptiveMaxPool2d((1, 1))\n        else:\n            raise Exception('pool: %s pool must be avg or max', str(pool))\n\n        self.lnorm = None\n        if use_lnorm:\n            self.lnorm = nn.LayerNorm(2048, elementwise_affine=False).cuda()\n\n    def forward(self, x):\n        x = self.base.conv1(x)\n        x = self.base.bn1(x)\n        x = self.base.relu(x)\n        x = self.base.maxpool(x)\n\n        x = self.base.layer1(x)\n        x = self.base.layer2(x)\n        x = self.base.layer3(x)\n        x = self.base.layer4(x)\n        x1 = self.pool(x)\n        x = x1\n        x = x.reshape(x.size(0), -1)\n\n        if self.lnorm != None:\n            x = self.lnorm(x)\n\n        return x\n\nclass Feat_resnet50_max(Feature):\n     def __init__(self):\n        Feature.__init__(self, model='resnet50', pool='max')\n\nclass Feat_resnet50_avg(Feature):\n     def __init__(self):\n        Feature.__init__(self, model='resnet50', pool='avg')\n\nclass Feat_resnet50_max_n(Feature):\n     def __init__(self):\n        Feature.__init__(self, model='resnet50', pool='max', use_lnorm=True)\n\nclass Feat_resnet50_avg_n(Feature):\n     def __init__(self):\n        Feature.__init__(self, model='resnet50', pool='avg', use_lnorm=True)","6f0b8367":"!mkdir -p \/root\/.cache\/torch\/hub\/checkpoints\/\n!cp ..\/input\/pretrained-pytorch-models\/resnet18-5c106cde.pth \/root\/.cache\/torch\/hub\/checkpoints\/\n!cp ..\/input\/pretrained-pytorch-models\/resnet50-19c8e357.pth \/root\/.cache\/torch\/hub\/checkpoints\/","e78c0128":"DEVICE = 'cuda'#turn to cuda for gpu \n\nfeat = Feat_resnet50_max_n()\nfeat.eval()\nin_sz = feat(torch.rand(1, 3, 256, 256)).squeeze().size(0)\nemb = torch.nn.Linear(in_sz, 2048)\nmodel = torch.nn.Sequential(feat, emb)\nmodel = torch.nn.DataParallel(model)\nPATH = \"..\/input\/proxxy\/shopee_shopee_trainval_0.pt\"\n#PATH = PATH.to(DEVICE)\nmodel.load_state_dict(torch.load(PATH)) \nmodel.eval()\n\nimgmodel = model.cuda() #delete hash for gpu usage\nimagefeat = []\nwith torch.no_grad():\n    for data in tqdm_notebook(imageloader):\n        data = data.to(DEVICE)\n        feat = imgmodel(data)\n        feat = feat.reshape(feat.shape[0], feat.shape[1])\n        feat = feat.data.cpu().numpy()\n        \n        imagefeat.append(feat)","35e4f8de":"from sklearn.preprocessing import normalize\n\n# l2 norm to kill all the sim in 0-1\nimagefeat = np.vstack(imagefeat)\nimagefeat = normalize(imagefeat)","efe40a91":"imagefeat = torch.from_numpy(imagefeat)\nimagefeat = imagefeat.cuda()","a8ea07d0":"preds = []\nCHUNK = 1024*4\n\n\nprint('Finding similar images...')\nCTS = len(imagefeat)\/\/CHUNK\nif len(imagefeat)%CHUNK!=0: CTS += 1\nfor j in range( CTS ):\n    \n    a = j*CHUNK\n    b = (j+1)*CHUNK\n    b = min(b, len(imagefeat))\n    print('chunk',a,'to',b)\n    \n    distances = torch.matmul(imagefeat, imagefeat[a:b].T).T\n    distances = distances.data.cpu().numpy()\n    # distances = np.dot(imagefeat[a:b,], imagefeat.T)\n    \n    for k in range(b-a):\n        # IDX = cupy.where(distances[k,]>0.95)[0]\n        IDX = np.where(distances[k,]>0.93)[0][:]\n        o = train.iloc[IDX].posting_id.values\n#         o = train.iloc[cupy.asnumpy(IDX)].posting_id.values\n        preds.append(o)\n        \ndel imagefeat, imgmodel","2e3f3fb9":"train['oof_cnn'] = preds\n\nif COMPUTE_CV:\n    train['f1'] = train.apply(getMetric('oof_cnn'),axis=1)\n    print('CV score for baseline =',train.f1.mean())\n    \n    \n# 0.6527899883424048 0.95\n# 0.6686372611222741 0.94\n# 0.6762305764407363 0.93","b43cbbc0":"train","0a77d2aa":"from sklearn.feature_extraction.text import TfidfVectorizer\nmodel = TfidfVectorizer(stop_words=None, binary=True, max_features=55000)\ntext_embeddings = model.fit_transform(train.title).toarray()\nprint('text embeddings shape',text_embeddings.shape)","8e458166":"text_embeddings = torch.from_numpy(text_embeddings)\ntext_embeddings = text_embeddings.cuda()","0368ed2a":"preds = []\nCHUNK = 1024*4\n\nprint('Finding similar titles...')\nCTS = len(train)\/\/CHUNK\nif len(train)%CHUNK!=0: CTS += 1\nCTS_index = 0\nfor j in range( CTS ):\n    \n    a = j*CHUNK\n    b = (j+1)*CHUNK\n    b = min(b,len(train))\n    print('chunk',a,'to',b)\n    \n    # COSINE SIMILARITY DISTANCE\n    # cts = np.dot( text_embeddings, text_embeddings[a:b].T).T\n    cts = torch.matmul(text_embeddings, text_embeddings[a:b].T).T\n    cts = cts.data.cpu().numpy()\n    print(cts.shape)\n    for k in range(b-a):\n        # IDX = np.where(cts[k,]>0.7)[0]\n        IDX = np.where(cts[k,]>0.58)[0]\n        o = train.iloc[IDX].posting_id.values\n        preds.append(o)\n        CTS_index += 1","b04ee3a8":"train['oof_text'] = preds\n\nif COMPUTE_CV:\n    train['f1'] = train.apply(getMetric('oof_text'),axis=1)\n    print('CV score for baseline =',train.f1.mean())\n    \n    \n# 0.6137154152579091 0.7\n# 0.6507316994356058 0.6","e5d59282":"def combine_for_sub(row):\n    #x = np.concatenate([row.oof_text,row.oof_cnn, row.oof_hash])\n    x = np.concatenate([row.oof_cnn])\n    return ' '.join( np.unique(x) )\n\ndef combine_for_cv(row):\n    x = np.concatenate([row.oof_text,row.oof_cnn, row.oof_hash])\n    return np.unique(x)","efb398a6":"if COMPUTE_CV:\n    tmp = train.groupby('label_group').posting_id.agg('unique').to_dict()\n    train['target'] = train.label_group.map(tmp)\n    train['oof'] = train.apply(combine_for_cv,axis=1)\n    train['f1'] = train.apply(getMetric('oof'),axis=1)\n    print('CV Score =', train.f1.mean() )\n\ntrain['matches'] = train.apply(combine_for_sub,axis=1)","a65aeacb":"train[['posting_id','matches']].to_csv('submission.csv',index=False)\nsub = pd.read_csv('submission.csv')\nsub.head()","db50cfcd":"# title TFIDF","38bfa700":"# image hash","8191472b":"# text word2vec","4d038597":"# image CNN"}}