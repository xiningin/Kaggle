{"cell_type":{"45dd0cec":"code","50762921":"code","1713d30c":"code","a0e48f36":"code","7ee4e189":"code","d25fa59f":"code","662b7e59":"code","45d2d023":"code","effaa416":"code","22dbf490":"code","6f645745":"code","5d4c8014":"code","9f3980cb":"code","6099737b":"code","616fcb63":"code","fe21ab3d":"markdown","48bb96e5":"markdown","d9431550":"markdown","d16023b4":"markdown","88c1fb91":"markdown"},"source":{"45dd0cec":"from time import time\nimport matplotlib.pyplot as plt\nimport sklearn\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.datasets import fetch_lfw_people\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.decomposition import PCA\nfrom sklearn.svm import SVC\nimport os\n\n# libraries to support custom function for copying.\n\nimport errno\nimport shutil","50762921":"def copy(src, dest):\n    try:\n        shutil.copytree(src, dest)\n    except OSError as e:\n        # If the error was caused because the source wasn't a directory\n        if e.errno == errno.ENOTDIR:\n            shutil.copy(src, dest)\n        else:\n            print('Directory not copied. Error: %s' % e)\n            \n","1713d30c":"src = '..\/input\/'\ndest = '..\/LFW\/lfw_home'\ncopy(src,dest)","a0e48f36":"# verifying the contents of src and dest folder\n\nprint(os.listdir('..\/input'))\nprint(os.listdir('..\/LFW\/lfw_home'))\n# path = '..\/LFW\/lfw_home\/'\npath = '..\/LFW\/'","7ee4e189":"# Load data\nlfw_dataset = sklearn.datasets.fetch_lfw_people(data_home = path, min_faces_per_person=100,  download_if_missing = False)\n\n#download_if_missing = False ; it prevents downloading, and generates IOError if file is missing, by dfualt value = true\n# lfw_dataset = ","d25fa59f":"n_samples, h, w = lfw_dataset.images.shape\n# for machine learning we use the 2 data directly (as relative pixel\n# positions info is ignored by this model)\nX = lfw_dataset.data\nn_features = X.shape[1]\n\n# the label to predict is the id of the person\ny = lfw_dataset.target\ntarget_names = lfw_dataset.target_names\nn_classes = target_names.shape[0]\n","662b7e59":"print(\"Total dataset size:\")\nprint(\"n_samples: %d\" % n_samples)\nprint(\"n_features: %d\" % n_features)\nprint(\"n_classes: %d\" % n_classes)","45d2d023":"# #############################################################################\n# Split into a training set and a test set using a stratified k fold \n# split into a training and testing set\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.25, random_state=42)","effaa416":"# #############################################################################\n# Compute a PCA (eigenfaces) on the face dataset (treated as unlabeled\n# dataset): unsupervised feature extraction \/ dimensionality reduction\n\nn_components = 150\n\nprint(\"Extracting the top %d eigenfaces from %d faces\"\n      % (n_components, X_train.shape[0]))\nt0 = time()\npca = PCA(n_components=n_components, svd_solver='randomized',\n          whiten=True).fit(X_train)\nprint(\"done in %0.3fs\" % (time() - t0))\n","22dbf490":"eigenfaces = pca.components_.reshape((n_components, h, w))\nprint(\"Projecting the input data on the eigenfaces orthonormal basis\")\nt0 = time()\nX_train_pca = pca.transform(X_train)\nX_test_pca = pca.transform(X_test)\nprint(\"done in %0.3fs\" % (time() - t0))\n","6f645745":"#  #############################################################################\n# Train a SVM classification model\n\nprint(\"Fitting the classifier to the training set\")\nt0 = time()\nparam_grid = {'C': [1e3, 5e3, 1e4, 5e4, 1e5],\n              'gamma': [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.1], }\nclf = GridSearchCV(SVC(kernel='rbf', class_weight='balanced'), param_grid)\nclf = clf.fit(X_train_pca, y_train)\nprint(\"done in %0.3fs\" % (time() - t0))\nprint(\"Best estimator found by grid search:\")\nprint(clf.best_estimator_)\n","5d4c8014":"# #############################################################################\n# Quantitative evaluation of the model quality on the test set\n\nprint(\"Predicting people's names on the test set\")\nt0 = time()\ny_pred = clf.predict(X_test_pca)\nprint(\"done in %0.3fs\" % (time() - t0))\n\nprint(classification_report(y_test, y_pred, target_names=target_names))\nprint(confusion_matrix(y_test, y_pred, labels=range(n_classes)))","9f3980cb":"# #############################################################################\n# Qualitative evaluation of the predictions using matplotlib\n\ndef plot_gallery(images, titles, h, w, n_row=3, n_col=4):\n    \"\"\"Helper function to plot a gallery of portraits\"\"\"\n    plt.figure(figsize=(1.8 * n_col, 2.4 * n_row))\n    plt.subplots_adjust(bottom=0, left=.01, right=.99, top=.90, hspace=.35)\n    for i in range(n_row * n_col):\n        plt.subplot(n_row, n_col, i + 1)\n        plt.imshow(images[i].reshape((h, w)), cmap=plt.cm.gray)\n        plt.title(titles[i], size=12)\n        plt.xticks(())\n        plt.yticks(())","6099737b":"\neigenface_titles = [\"eigenface %d\" % i for i in range(eigenfaces.shape[0])]\nplot_gallery(eigenfaces, eigenface_titles, h, w)\n\nplt.show()","616fcb63":"\ndef title(y_pred, y_test, target_names, i):\n    pred_name = target_names[y_pred[i]].rsplit(' ', 1)[-1]\n    true_name = target_names[y_test[i]].rsplit(' ', 1)[-1]\n    return 'predicted: %s\\ntrue:      %s' % (pred_name, true_name)\n\nprediction_titles = [title(y_pred, y_test, target_names, i)\n                     for i in range(y_pred.shape[0])]\n\nplot_gallery(X_test, prediction_titles, h, w)","fe21ab3d":"#### Visualizing the Eigen Faces (reduced components of faces).","48bb96e5":"### Data loading only.","d9431550":"### copying the contents of src folder: files + directory...","d16023b4":"#### Visualising the prediction by plotting with Faces and train-test Prediction pairs.","88c1fb91":"#### Remember that PCA produces eigenvectors. We can reshape those eigenvectors into images and visualize the eigenfaces."}}