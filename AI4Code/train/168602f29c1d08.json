{"cell_type":{"d662a3d6":"code","1b84a3f1":"code","57768995":"code","20b48391":"code","b7b489da":"code","230755db":"code","38809feb":"code","b848892a":"code","6d8a7093":"code","3ac4fcd4":"code","fd696d1b":"code","322166ad":"code","bdb89761":"code","f3b89f74":"code","efc67ce3":"code","f369f286":"markdown"},"source":{"d662a3d6":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","1b84a3f1":"data = pd.read_csv(\"\/kaggle\/input\/kaggle-survey-2021\/kaggle_survey_2021_responses.csv\")\ndata","57768995":"data.applymap(lambda x: x.replace('\"', '') if (isinstance(x, str)) else x)\ndata.applymap(lambda x: x.replace(\"'\", \"\") if (isinstance(x, str)) else x)","20b48391":"print('Number of missing values across columns-\\n', data.isnull().sum())","b7b489da":"Jobtitle = data[\"Q5\"].value_counts()\nJobtitle","230755db":"Education = data[\"Q4\"].value_counts()\nEducation","38809feb":"sns.displot(data=data, x=\"Q5\", kde=True)","b848892a":"F1 = data.iloc[1:]\nF1","6d8a7093":"\n\nAGE_GROUP_ORDER = ['< 1 years', '1-3 years', '3-5 years', '5-10 years', '10-20 years', '20+ years']\n\nq_descriptions = {}\nfor (c, q) in zip(df.columns.values, df.iloc[0, :].values):\n    q_descriptions[c] = q\n\ndef group_by(df, q):\n    \"\"\"\n    A custom groupby function that behaves differently depending on what kind of question its passed.\n    \"\"\"\n    grouped_df = None\n    n_people = df.shape[0]\n    q_cols = [c for c in df.columns if q in c]\n    \n    if q_cols == 1:\n        pass\n    else:\n        options = [q_descriptions[c].split(' - ')[-1] for c in q_cols]\n        vals = []\n        \n        for i, c in enumerate(q_cols):\n            option_freq = sum(df[c] == options[i])\n            vals.append(round((option_freq \/ n_people) * 100, 2))\n        \n        grouped_df = pd.DataFrame({\n            'Option': options,\n            'Percentage': vals\n        }).sort_values('Percentage', ascending=False)\n    \n    return grouped_df\n\n","3ac4fcd4":"\n\nproglang_daily_by_exp = data.groupby('Q6').apply(lambda data: group_by(data, 'Q7')).reset_index().drop(['level_1'], axis=1)\nproglang_daily_by_exp = proglang_daily_by_exp.rename({'Q6': 'Experience'}, axis='columns')\n\n","fd696d1b":"proglang_daily_by_exp","322166ad":"proglang_daily_by_exp.Option.unique()","bdb89761":"Program = proglang_daily_by_exp.groupby(['Option', 'Percentage']).count()","f3b89f74":"proglang_daily_by_exp['Option'].value_counts()","efc67ce3":"sns.displot(Program),mydata.hist(by='Option',column = 'Percentage')","f369f286":"NOTEBOOK IN PROGRESS "}}