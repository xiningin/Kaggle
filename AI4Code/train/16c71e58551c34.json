{"cell_type":{"0f81a22f":"code","a59b2e1e":"code","ced35e61":"code","61bf606c":"code","df3c0d73":"code","298a415a":"code","dc6826c8":"code","e32073a5":"code","cb8d4190":"code","d9b3001b":"code","2f80cee0":"code","d55d30d5":"code","7ef733ee":"code","764a1c32":"code","4a156083":"code","279c0a62":"code","c8f88a1a":"code","0680ce53":"code","969005ba":"code","7ee130d3":"code","47bf289d":"code","83614153":"code","a9e139dd":"code","9b86cdfc":"code","9839d0e8":"code","655566ea":"code","4bbe136f":"markdown","e283ba1a":"markdown","5525db8c":"markdown","ec654945":"markdown","ee094df8":"markdown","4a43d8ff":"markdown","daa5fd84":"markdown","f9a56fad":"markdown","02ce8ffd":"markdown","5e832f06":"markdown","c7557609":"markdown","8204fe3a":"markdown","1f265a9f":"markdown"},"source":{"0f81a22f":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt","a59b2e1e":"df=pd.read_csv('..\/input\/g-research-crypto-forecasting\/train.csv')\ndf.replace([np.inf, -np.inf], np.nan, inplace=True)","ced35e61":"df=df.dropna(how='any')","61bf606c":"df.isna().value_counts()","df3c0d73":"asset=pd.read_csv('..\/input\/g-research-crypto-forecasting\/asset_details.csv')","298a415a":"asset_map=lambda x : asset[asset.Asset_ID==x].Asset_Name.tolist()[0]","dc6826c8":"dfs={}\nfor i in np.unique(df.Asset_ID):\n    dfs[i]=df[df.Asset_ID==i].reset_index(drop=True)\n    dfs[i]=dfs[i].drop(['Asset_ID'],axis=1)\n    dfs[i]['date']=pd.to_datetime(dfs[i].timestamp,unit='s')\n    dfs[i]=dfs[i].set_index('date')\n","e32073a5":"dfs[0].head(3)","cb8d4190":"dfs[0].tail(3)","d9b3001b":"num_forecast_steps=60*24*3  #3 days\n\nyear='2020'","2f80cee0":"fig = plt.figure(figsize=(12, 6))\nax = fig.add_subplot(1, 1, 1)\nfor k,v in dfs.items():\n    sns.lineplot(x=dfs[k].loc[year].index[:num_forecast_steps],y='Target',\n                 data=dfs[k].loc[year][:num_forecast_steps],ax=ax,label=asset_map(k))\nax.set_ylabel(\"Return\")\nax.set_xlabel(\"time\")\nfig.suptitle('A day of returns',fontsize=15)\n\nfig.autofmt_xdate()\nplt.legend(loc='upper right')","d55d30d5":"import tensorflow as tf\nimport tensorflow_probability as tfp\n\nfrom tensorflow_probability import distributions as tfd  #distribution\nfrom tensorflow_probability import sts  #Bayesian structural time series models.","7ef733ee":"def plot_forecast(x, y,\n                  forecast_mean, forecast_scale, forecast_samples,\n                  title, x_locator=None, x_formatter=None):\n    \n    #x:dates\n    \n    #y:target\n    colors = sns.color_palette()\n    c1, c2 = colors[0], colors[1]\n    fig = plt.figure(figsize=(12, 6))\n    ax = fig.add_subplot(1, 1, 1)\n    num_steps = len(y)\n    num_steps_forecast = forecast_mean.shape[-1]\n    \n    num_steps_train = num_steps - num_steps_forecast\n    \n    ax.plot(x, y, lw=2, color=c1, label='ground truth')\n    \n    forecast_steps=x[num_steps_train:]\n    \n    ax.plot(forecast_steps, forecast_samples.T, lw=1, color=c2, alpha=0.1)\n\n    ax.plot(forecast_steps, forecast_mean, lw=2, ls='--', color=c2,\n           label='forecast')\n    ax.fill_between(forecast_steps,\n                   forecast_mean-2*forecast_scale,\n                   forecast_mean+2*forecast_scale, color=c2, alpha=0.2)\n\n    ymin, ymax = min(np.min(forecast_samples), np.min(y)), max(np.max(forecast_samples), np.max(y))\n    yrange = ymax-ymin\n    ax.set_ylim([ymin - yrange*0.1, ymax + yrange*0.1])\n    ax.set_title(\"{}\".format(title))\n    ax.legend()\n\n    if x_locator is not None:\n        ax.xaxis.set_major_locator(x_locator)\n        ax.xaxis.set_major_formatter(x_formatter)\n        fig.autofmt_xdate()\n\n    return fig, ax","764a1c32":"def plot_components(dates,\n                    component_means_dict,\n                    component_stddevs_dict,\n                    x_locator=None,\n                    x_formatter=None):\n    colors = sns.color_palette()\n    c1, c2 = colors[0], colors[1]\n\n    axes_dict = collections.OrderedDict()\n    num_components = len(component_means_dict)\n    fig = plt.figure(figsize=(12, 2.5 * num_components))\n    for i, component_name in enumerate(component_means_dict.keys()):\n        component_mean = component_means_dict[component_name]\n        component_stddev = component_stddevs_dict[component_name]\n\n        ax = fig.add_subplot(num_components,1,1+i)\n        ax.plot(dates, component_mean, lw=2)\n        ax.fill_between(dates,\n                     component_mean-2*component_stddev,\n                     component_mean+2*component_stddev,\n                     color=c2, alpha=0.5)\n        ax.set_title(component_name)\n        if x_locator is not None:\n            ax.xaxis.set_major_locator(x_locator)\n            ax.xaxis.set_major_formatter(x_formatter)\n        axes_dict[component_name] = ax\n    fig.autofmt_xdate()\n    fig.tight_layout()\n    return fig, axes_dict","4a156083":"def plot_one_step_predictive(dates, observed_time_series,\n                             one_step_mean, one_step_scale,\n                             x_locator=None, x_formatter=None):\n    colors = sns.color_palette()\n    c1, c2 = colors[0], colors[1]\n\n    fig=plt.figure(figsize=(12, 6))\n    ax = fig.add_subplot(1,1,1)\n    num_timesteps = one_step_mean.shape[-1]\n    ax.plot(dates, observed_time_series, label=\"observed time series\", color=c1)\n    ax.plot(dates, one_step_mean, label=\"one-step prediction\", color=c2)\n    ax.fill_between(dates,\n                  one_step_mean - one_step_scale,\n                  one_step_mean + one_step_scale,\n                  alpha=0.1, color=c2)\n    ax.legend()\n\n    if x_locator is not None:\n        ax.xaxis.set_major_locator(x_locator)\n        ax.xaxis.set_major_formatter(x_formatter)\n        fig.autofmt_xdate()\n    fig.tight_layout()\n    return fig, ax","279c0a62":"def build_model(observed_time_series,num_seasons):  \n    trend = sts.LocalLinearTrend(observed_time_series=observed_time_series)\n    \n    seasonal = tfp.sts.Seasonal(num_seasons=num_seasons, observed_time_series=observed_time_series)\n    \n    model = sts.Sum([trend, seasonal], observed_time_series=observed_time_series)\n    \n    return model","c8f88a1a":"#since data  is minutes wise, season is an hour\n\nasset=1 #bitcoin\nyear='2020'\nnum_seasons=60 #60 minutes--> 1 hours\nnum_obs=600 #600 minutes observation --> 10 hours\n\nmodel=build_model(dfs[asset].loc[year][:num_obs].Target,num_seasons)\n\n\n# Build the variational surrogate posteriors `qs`.\nvariational_posteriors = sts.build_factored_surrogate_posterior(model=model)","0680ce53":"num_variational_steps = 100  #update steps\n\n#optimize observation \n\nloss_curve = tfp.vi.fit_surrogate_posterior(\n    \n    target_log_prob_fn=model.joint_log_prob(observed_time_series=dfs[asset].loc[year].Target[:num_obs]),\n    \n    surrogate_posterior=variational_posteriors,\n    \n    optimizer=tf.optimizers.Adam(learning_rate=0.1),\n    \n    num_steps=num_variational_steps)\n\nplt.plot(loss_curve)\nplt.show()","969005ba":"# Draw samples from the variational posterior.\nq_samples = variational_posteriors.sample(1000)","7ee130d3":"print(\"Inferred parameters:\")\nfor param in model.parameters:\n    print(\"{}: {} +- {}\".format(param.name,\n                              np.mean(q_samples[param.name], axis=0),\n                              np.std(q_samples[param.name], axis=0)))","47bf289d":"num_forecast_steps=60*5 #5 hour forecast\n\nforecast_dist = sts.forecast(\n    model,\n    observed_time_series=dfs[asset].loc[year].Target[:num_obs],\n    parameter_samples=q_samples,\n    num_steps_forecast=num_forecast_steps)","83614153":"num_samples=100  #generate n forecast samples\n\nforecast_mean, forecast_scale, forecast_samples = (\n    forecast_dist.mean().numpy()[..., 0],\n    forecast_dist.stddev().numpy()[..., 0],\n    forecast_dist.sample(num_samples).numpy()[..., 0])","a9e139dd":"forecast_mean.shape,forecast_scale.shape","9b86cdfc":"forecast_samples.shape","9839d0e8":"fig, ax = plot_forecast(\n    dfs[asset].loc[year].index[:num_obs+num_forecast_steps],\n    dfs[asset].loc[year].Target[:num_obs+num_forecast_steps],\n    forecast_mean, forecast_scale, forecast_samples,\n    x_locator=None,\n    x_formatter=None,\n    title=f\"Returns in {year}\")\n\n\nax.legend(loc=\"upper left\")\nax.set_ylabel(f\"Returns\")\nax.set_xlabel(\"minutes\")\nfig.autofmt_xdate()","655566ea":"y_true= dfs[asset].loc[year].Target[num_obs:num_obs+num_forecast_steps]\ny_pred=forecast_mean\n\ntf.keras.metrics.mean_squared_error(y_true,y_pred)","4bbe136f":"* Plot the contributions of posterior components in a single figure.","e283ba1a":"* Asset","5525db8c":"* I will learn more about tfp library and try more statistical model then update the version","ec654945":"* Build model\n\n    Local-Linear Trend model + minute-of-hour seasonal effect","ee094df8":"* Plot a forecast distribution against the 'true' time series","4a43d8ff":"## Functions","daa5fd84":"* Plot a time series against a model's one-step predictions","f9a56fad":"* Plot trend (There's some data missing)","02ce8ffd":"# Data","5e832f06":"## Example :  LocalLinearTrend Model\n\n   * Forecast only by single variable \n\n   * Given Target Observation (2020 , first 600 minutes data)\n   \n   * Forecast next unseen Target (2020 ,next 300 minutes data)","c7557609":"* Group\n\n","8204fe3a":"# Modeling","1f265a9f":"* All 100 series and mean and std of each time"}}