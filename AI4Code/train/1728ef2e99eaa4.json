{"cell_type":{"e88734a2":"code","b595cc75":"code","58e0b36b":"code","65a0cccc":"code","36b4b7b5":"code","8dfcaa60":"code","f8bb1f98":"code","dd5d2a5c":"code","12e130ad":"code","5ac9c4ca":"code","9a7d12ac":"code","3068d9d2":"code","e08316cc":"code","51e07acb":"code","4d0f9341":"code","2f92f157":"markdown","06bccd00":"markdown","10e1708e":"markdown","b601c67c":"markdown","edab9569":"markdown","4628dd61":"markdown","610e1adc":"markdown","90b4012b":"markdown","7d170ae3":"markdown","f39b62be":"markdown","d07a0cb3":"markdown","c4519aa5":"markdown"},"source":{"e88734a2":"from pathlib import Path\n\nDATA_DIR = Path(\"\/kaggle\/input\")\nif (DATA_DIR \/ \"ucfai-core-fa19-deep-rl\").exists():\n    DATA_DIR \/= \"ucfai-core-fa19-deep-rl\"\nelif DATA_DIR.exists():\n    # no-op to keep the proper data path for Kaggle\n    pass\nelse:\n    # You'll need to download the data from Kaggle and place it in the `data\/`\n    #   directory beside this notebook.\n    # The data should be here: https:\/\/kaggle.com\/c\/ucfai-core-fa19-deep-rl\/data\n    DATA_DIR = Path(\"data\")","b595cc75":"import gym\nimport numpy as np \nimport torch\nfrom torch import nn\nfrom torch.autograd import Variable\nfrom torch import optim\nfrom torch.nn import functional as F\nimport matplotlib.pyplot as plt","58e0b36b":"def one_hot(ids, nb_digits):\n    \"\"\"\n    ids: (list, ndarray) shape:[batch_size]\n    \"\"\"\n    if not isinstance(ids, (list, np.ndarray)):\n        raise ValueError(\"ids must be 1-D list or array\")\n        \n    batch_size = len(ids)\n    ids = torch.LongTensor(ids).view(batch_size, 1)\n    out_tensor = Variable(torch.FloatTensor(batch_size, nb_digits))\n    out_tensor.data.zero_()\n    out_tensor.data.scatter_(dim=1, index=ids, value=1.)\n    return out_tensor","65a0cccc":"def uniform_linear_layer(linear_layer):\n    linear_layer.weight.data.uniform_()\n    linear_layer.bias.data.fill_(-0.02)","36b4b7b5":"lake = gym.make('FrozenLake-v0')","8dfcaa60":"lake.reset()\nlake.render()","f8bb1f98":"s1, r, d, _ = lake.step(2)\nlake.render()","dd5d2a5c":"s1, r, d, _ = lake.step(1)\nlake.render()","12e130ad":"print(r)\nprint(d)","5ac9c4ca":"class Agent(nn.Module):\n  \n    \"\"\"\n    Observation Space - How big is the state that the agent needs to observe?\n    In this case, the only thing that changes about the lake is the position of the agent.\n    Therefore, the observation space is 1\n    \n    Action Space - Similar to the O-Space, we can move up, down, left, and right \n    Because we need to measure the Q-value of every action, the action space in this \n    case will be 4\n    \"\"\"\n    def __init__(self, observation_space_size, action_space_size):\n        super(Agent, self).__init__()\n        self.observation_space_size = observation_space_size\n        self.hidden_size = observation_space_size\n        \n        # What is the difference between observation and state space?\n         \n        \"\"\"\n        Let's build the nueral network. In RL, you'll find that large networks \n        are largely unessesary. Oftentimes, you can get away with just 1 or 2 hidden layers\n        The reason should be intuitive. What makes something a cat or a dog has many, many variables\n        But \"wich direction should I walk on a 2D grid\" has a lot fewer.\n        \n        As you can see, the output layer is our action space size. This will be a table\n        of our possible actions, each with a q-value\n        \"\"\"\n\n        ## Create a simple 3 layer network using the observation space size as the input\n        ## And the action space size as the output\n\n        # YOUR CODE HERE\n        raise NotImplementedError()\n        \n        # Why might a nueral network for deep RL be relatively smaller than what you might expect in something like image classification\n    \n    # Forward feed of our network\n    def forward(self, state):\n        obs_emb = one_hot([int(state)], self.observation_space_size)\n        out1 = F.sigmoid(self.l1(obs_emb))\n        return self.l2(out1).view((-1)) # 1 x ACTION_SPACE_SIZE == 1 x 4  =>  4","9a7d12ac":"class Trainer:\n    def __init__(self):\n        self.agent = Agent(lake.observation_space.n, lake.action_space.n)\n        self.optimizer = optim.Adam(params=self.agent.parameters())\n        self.success = []\n        self.jList = []\n        self.running_success = []\n    \n    def train(self, epoch):\n      \n      # Let's start by resetting our enviroment\n      # We don't want to just wander back and forth forever when the simulation starts\n      # Therefore, we use a j value that stops our agent from taking more than 200 \n      # actions in a simulation\n        for i in range(epoch):\n            s = lake.reset()\n            j = 0\n\n            \"\"\"\n            # Rearrange these in the correct order\n                self.optimizer.zero_grad()\n                s = s1\n                target_q = r + 0.99 * torch.max(self.agent(s1).detach()) \n                self.optimizer.step()\n                if d == True: break\n                a = self.choose_action(s)\n                j += 1\n                loss = F.smooth_l1_loss(self.agent(s)[a], target_q)\n                s1, r, d, _ = lake.step(a)\n                loss.backward()\n                if d == True and r == 0: r = -1\n            \"\"\"\n            while j < 200:\n                \n                # YOUR CODE HERE\n                raise NotImplementedError()\n            # append results onto report lists\n            if d == True and r > 0:\n                self.success.append(1)\n            else:\n                self.success.append(0)\n            \n            self.jList.append(j)\n            \n            if i % 100 == 0:\n                print(\"last 100 epoches success rate: \" + str(sum(self.success[-100:])) + \"%\")\n                self.running_success.append(sum(self.success[-100:]))\n\n    def choose_action(self, s):\n        # 0.1 is our epsilon\n        # Normally, we want some fancy way to degrade this (over time, we should\n        #   be taking fewer random actions)\n        # We will cover this a little more, but for this really, really simple\n        #   example, we can just use a set epsilon\n        if (np.random.rand(1) < 0.1): \n            return lake.action_space.sample()\n        # Now, if we don't want to act randomly, we are going to feed forward\n        #   the network\n        # Then, we take the action that has the highest Q-value (max index)\n        else:\n            agent_out = self.agent(s).detach()\n            _, max_index = torch.max(agent_out, 0)\n            return int(max_index.data.numpy())","3068d9d2":"t = Trainer()\nt.train(5000)","e08316cc":"plt.plot(t.success)","51e07acb":"plt.plot(t.jList)","4d0f9341":"plt.plot(t.running_success)","2f92f157":"As you can see, we died, so we went back to where we started. We can show this by looking at the done value","06bccd00":"Next, we will write a function that can take some batch of data and return a one-hot encoded `Tensor`. One-hot that instead of the integer representing some Nth option, we create a vector of 0s equal to the number of options, and the Nth entry is a 1.\n\nFor example, instead of inputting \"5\" into the network to represent state #5 out of 16 possible states, I input the vector:\n```\n[0, 0, 0, 0, 1, 0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n```","10e1708e":"Now, let's create the frozen lake enviroment. As mentioned in the slides, frozen lake is simply a NxN grid in which an agent wants to go from the top left square to the bottom right square without falling in any holes. Occasionally, wind will cause you to move in random directions.\n","b601c67c":"\nLet's take a step and see what it looks like. \n\n- 0 - Left\n- 1 - Down\n- 2 - Right\n- 3 - Up\n\n**Note**: If you (or even I) end up somewhere different than where it says we should be, it's because this enviroment is stochastic, meaning that it occasionally randomly places you somehwere you didn't want to go. This forces the model to deal with randomness\n\n**Question:** Why might stochastic be better than deterministic when training agents?","edab9569":"As you can see, we died, so we went back to where we started. We can show this by looking at the done value","4628dd61":"Now, let's write the trainer that will actually train the agent to navigate the lake.\n\nFor this cell, everything inside of train has been jumbled and switched around. Carefully review the steps to the deep-rl process and rearrange them in the correct order.","610e1adc":"Let's start with imports\n","90b4012b":"We can go ahead and see what this enviroment looks like ","7d170ae3":"## Some questions to think about:\n\n- What does it formally mean for an agent to explore?\n- Why does an agent need to explore?\n- What are some ways we can allow for exploration?\n- What exactly is the limitation for using a traditional table for reinforcement\n  learning for something like Doom?\n- If you could only replace state space or action space with a nueral network,\n  which would make more sense to replace?","f39b62be":"<img\n    style=\"border-radius: 0.5em;\"\n    src=\"https:\/\/ucfai.org\/groups\/core\/fa19\/deep-rl\/banner.png\">\n\n<div class=\"col-12\">\n    <h1> Learning by Doing, This Time with Neural Networks <\/h1>\n    <hr>\n<\/div>\n\n<div style=\"line-height: 2em;\">\n    <p>by: \n        <a href=\"https:\/\/ucfai.org\/authors\/ahkerrigan\">@ahkerrigan<\/a> and\n        <a href=\"https:\/\/ucfai.org\/authors\/ionlights\">@ionlights<\/a> on Nov 13, 2019<\/p>\n<\/div>","d07a0cb3":"For this enviroment, the only time a reward other than 0 is recieved is when you complete the goal, in which you recieve one. We are going to reset regardless of whether the randomness put us where we wanted to go or not. Now, let's build our agent.","c4519aa5":"Next, just for simplicity, we are going to write a funtion that will uniformly set the weights of any Neural Network layer to a uniform value. We do this because you can imagine that when trying to learn something through trial and error, you don't want to start with any assumptions.\n\nNote: This is simply a possible intuition of why starting with uniform weights is the better option. There is no proof that it is in fact better, experiments have simply shown it leads to better results."}}