{"cell_type":{"69064350":"code","e64ced19":"code","b63fa92c":"code","79cdd5ad":"code","9713e63a":"code","59a55ded":"code","9f3ed459":"code","6933cfea":"code","6855ac57":"code","e22db306":"code","386c3169":"code","456a0d3e":"code","7b488681":"code","45abee7a":"markdown","730f50d5":"markdown","be1cf97f":"markdown","144af504":"markdown","b6e5b427":"markdown","4520f883":"markdown","5637f792":"markdown","f45059ce":"markdown","e8c2ee91":"markdown","2e5a9836":"markdown","1b8a8897":"markdown","29ecd320":"markdown","d871dc0b":"markdown"},"source":{"69064350":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, log_loss\n\n\nd = pd.read_csv('..\/input\/inspections_train.csv', parse_dates=['inspection_date'])\nx_train0, x_test0 = train_test_split(d, test_size=0.25)","e64ced19":"from sklearn.ensemble import RandomForestClassifier","b63fa92c":"# import the venue_stats file\nvenue_stats = pd.read_csv('..\/input\/venues.csv').set_index('camis')\nvenue_stats.head()","79cdd5ad":"# import the violations file\nviolations = pd.read_csv('..\/input\/violations.csv', parse_dates=['inspection_date'])\n\nx_train3 = x_train0.merge(venue_stats, 'left', left_on='camis', right_index=True)\nx_test3 = x_test0.merge(venue_stats, 'left', left_on='camis', right_index=True)\n\nviolation_counts = violations.groupby(['camis', 'inspection_date']).size()\nviolation_counts = violation_counts.reset_index().set_index(['camis', 'inspection_date'])\nviolation_counts.columns = ['n_violations']\n\nx_train3 = x_train3.merge(violation_counts, 'left', left_on=['camis', 'inspection_date'], right_index=True)\nx_test3 = x_test3.merge(violation_counts, 'left', left_on=['camis', 'inspection_date'], right_index=True)","9713e63a":"x_train3['re_inspect'] = x_train3.inspection_type.str.contains('re-', regex=False, case=False).map(int)\nx_train3['initial_inspect'] = x_train3.inspection_type.str.contains('initial', regex=False, case=False).map(int)\n\nx_test3['re_inspect'] = x_test3.inspection_type.str.contains('re-', regex=False, case=False).map(int)\nx_test3['initial_inspect'] = x_test3.inspection_type.str.contains('initial', regex=False, case=False).map(int)","59a55ded":"boro_dict = {\n    'Missing': 0,\n    'STATEN ISLAND': 0,\n    'BROOKLYN': 1,\n    'MANHATTAN': 1,\n    'BRONX': 2,\n    'QUEENS': 2    \n}\n\nx_train3['boro_idx'] = [boro_dict[_] for _ in x_train3.boro]\nx_test3['boro_idx'] = [boro_dict[_] for _ in x_test3.boro]","9f3ed459":"x_train3['inspection_month'] = (x_train3.inspection_date.dt.strftime('%m').map(int) + 6) % 12\nx_test3['inspection_month'] = (x_test3.inspection_date.dt.strftime('%m').map(int) + 6) % 12","6933cfea":"cuisine_hitrates = x_train3.groupby(['cuisine_description']).agg({'passed':'mean', 'id':'count'}).\\\n        rename(columns={'id':'ct'}).sort_values('passed')[['passed']]\ncuisine_hitrates.columns = ['cuisine_hr']\n\n    \nx_train3 = x_train3.merge(cuisine_hitrates, 'left', left_on='cuisine_description', right_index=True).fillna(0.67)\nx_test3 = x_test3.merge(cuisine_hitrates, 'left', left_on='cuisine_description', right_index=True).fillna(0.67)","6855ac57":"model_features = ['n_violations', 'inspection_month', 'cuisine_hr', 'boro_idx', 're_inspect', 'initial_inspect']","e22db306":"clf0 = RandomForestClassifier(n_estimators=50)\nclf0.fit(x_train3[model_features], x_train3.passed)\ntest_solution3 = clf0.predict_proba(x_test3[model_features])\nloss3a = log_loss(x_test3.passed.values, test_solution3)\nprint(f'log loss: {loss3a:.3f}')","386c3169":"clf1 = RandomForestClassifier(n_estimators=50, max_depth=10, min_samples_leaf=10)\nclf1.fit(x_train3[model_features], x_train3.passed)\ntest_solution4 = clf1.predict_proba(x_test3[model_features])\nloss3b = log_loss(x_test3.passed.values, test_solution4)\nprint(f'log loss: {loss3b:.3f}')","456a0d3e":"# change these parameters!\nparameters = {\n    'n_estimators': 50,\n    'max_depth': 10,\n    'min_samples_leaf': 10\n}\n\n# we use the ** operator to expand the parameters dictionary\nclf_custom = RandomForestClassifier(**parameters)\nclf_custom.fit(x_train3[model_features], x_train3.passed)\ntest_solution_cusotm = clf_custom.predict_proba(x_test3[model_features])\nloss3_custom = log_loss(x_test3.passed.values, test_solution_cusotm)\nprint(f'log loss: {loss3_custom:.3f}')","7b488681":"# load the test data\ntest_data = pd.read_csv('..\/input\/inspections_test.csv', parse_dates=['inspection_date'])\n\n# replicate all of our feature engineering for the test data\ntest_data = test_data.merge(violation_counts, 'left', left_on=['camis', 'inspection_date'], right_index=True)\ntest_data = test_data.merge(venue_stats, 'left', left_on='camis', right_index=True)\ntest_data['re_inspect'] = test_data.inspection_type.str.contains('re-', regex=False, case=False).map(int)\ntest_data['initial_inspect'] = test_data.inspection_type.str.contains('initial', regex=False, case=False).map(int)\ntest_data['boro_idx'] = [boro_dict[_] for _ in test_data.boro]\ntest_data['inspection_month'] = (test_data.inspection_date.dt.strftime('%m').map(int) + 6) % 12\ntest_data = test_data.merge(cuisine_hitrates, 'left', left_on='cuisine_description', right_index=True).fillna(0.67)\n\n\n# create a `Predicted` column\n# for this example, we're using the model we previously trained\ntest_data['Predicted'] = [_[1] for _ in clf_custom.predict_proba(test_data[model_features])]\n\n# take just the `id` and `n_violations` columns (since that's all we need)\nsubmission = test_data[['id', 'Predicted']].copy()\n\n# IMPORTANT: Kaggle expects you to name the columns `Id` and `Predicted`, so let's make sure here\nsubmission.columns = ['Id', 'Predicted']\n\n# write the submission to a csv file so that we can submit it after running the kernel\nsubmission.to_csv('submission3.csv', index=False)\n\n# let's take a look at our submission to make sure it's what we want\nsubmission.head()","45abee7a":"Finally, we'll encode the cuisine description as a numeric variable based on the pass frequency we see corresponding to that cuisine in the training data.","730f50d5":"That's a significant improvement! By make our model a bit less powerful, we beat our best score. ","be1cf97f":"Maybe it would be helpful to include a binary variable that tells us whether the inspection we're looking at is an initial or re-inspection. We can add those easily here.","144af504":"In addition to those tools, we're also going to import **the Random Forest machine learing model**, which is very popular in the data science community (view the documentation [**here**](https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.ensemble.RandomForestClassifier.html)). ","b6e5b427":"Want to try your own parameters? Sometimes it's helpful to store them as a dictionary to keep things organized. Try tweaking these values and training the model again!","4520f883":"We'll create some additional features and train a more powerful model. First let's merge the inspections with the data about each venue, and also add the violation counts that we previously calculated.","5637f792":"## kernel 3: feature engineering and the hazards of overfitting\n#### Is increasing the power of our model always a good thing?\n\n\n\nAs a first step, we're going to import some useful tools and load the data. If this step is unfamiliar to you, try going back to [**kernel_0**](https:\/\/www.kaggle.com\/nicknormandin\/cuny-data-challenge-kernel0).","f45059ce":"We might also be interested in knowing which borough the inspection takes place in. From a quick look at the table, I've lumped the six possible options into three categories that roughly correspond to the pass frequency that we see in the training data. Note that this is a way to **encode** categorical features- but not necessarily the smartest way.","e8c2ee91":"Surprisingly, our results are terrible. We've actually done worse than just guessing $0.67$ for every answer. This is the result of overfitting, and is an extremely common issue in machine learning and data science tasks. How do we fix it? We **regularize** the model. In this case, I'll set a maximum depth parameter and a minimum samples per leaf parameter, which prevents the model from getting too complicated. Hopefully this means that it will have predictions that **generalize** to the test data better, rather than overfitting our training data.","2e5a9836":"Maybe the month of the inspection has some impact on pass frequency? Let's add a variable encoding the month of the year (again, this isn't necessarily the optimal way to encode this into the feature set).","1b8a8897":"We'll use the extremely popular and flexible Random Forest model to generate our predictions. Here we use the default settings of the model to train and generate predictions.","29ecd320":"### Submitting our solution\nIn this kernel we've developed a new way to generate solutions. Now we need to generate solutions for each row in the test data, which we find in inspections_test.csv. The steps are:","d871dc0b":"We'll make a list of all of the features we've created so that we can pass them to the model for training."}}