{"cell_type":{"0e4cd935":"code","815c46db":"code","f69f52ac":"code","ce7c24b7":"code","90456842":"code","67374f6c":"code","b3dd57bf":"code","4a3842a9":"code","cc8779be":"code","a2afd2de":"code","ca4e6089":"code","49d1568f":"code","766e1512":"code","64823709":"code","cae6a698":"code","00954ffd":"code","f82d4bac":"code","cab80901":"markdown","28fe16d2":"markdown"},"source":{"0e4cd935":"import numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt \nfrom collections import Counter\nfrom sklearn.metrics import confusion_matrix\nimport itertools\nimport seaborn as sns\n%matplotlib inline","815c46db":"train = pd.read_csv(\"..\/input\/train.csv\")\ntest= pd.read_csv(\"..\/input\/test.csv\")","f69f52ac":"# train.head()\n# train.shape\n# test.head()\n# test.shape\n\ntrain['label'].value_counts()","ce7c24b7":"x_train = (train.iloc[:,1:].values).astype('float32')\ny_train = train.iloc[:,0].values.astype('int32') \nx_test = test.values.astype('float32')","90456842":"x_train = x_train\/255.0\nx_test = x_test\/255.0","67374f6c":"print(x_train.shape)\nprint(y_train.shape)\nprint(x_test.shape)","b3dd57bf":"X_train = x_train.reshape(x_train.shape[0], 28, 28,1)\nX_test = x_test.reshape(x_test.shape[0], 28, 28,1)","4a3842a9":"print(x_train.shape)\nprint(x_test.shape)","cc8779be":"import keras\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D\nfrom keras.layers.normalization import BatchNormalization\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.callbacks import ReduceLROnPlateau\nfrom sklearn.model_selection import train_test_split\nbatch_size = 64\nclasses = 10\nepochs = 15\ninput_shape = (28, 28, 1)","a2afd2de":"y_train = keras.utils.to_categorical(y_train, classes)\nX_train, X_val, Y_train, Y_val = train_test_split(X_train, y_train, test_size = 0.1, random_state=42)","ca4e6089":"# tpu = tf.distribute.cluster_resolver.TPUClusterResolver.connect()\n# tpu_strategy = tf.distribute.experimental.TPUStrategy(tpu)\n# with tpu_strategy.scope():\n\n    model = Sequential()\n    model.add(Conv2D(32, kernel_size=(3, 3),activation='relu',kernel_initializer='he_normal',input_shape=input_shape))\n    model.add(Conv2D(32, kernel_size=(3, 3),activation='relu',kernel_initializer='he_normal'))\n    model.add(MaxPool2D((2, 2)))\n    model.add(Dropout(0.20))\n    model.add(Conv2D(64, (3, 3), activation='relu',padding='same',kernel_initializer='he_normal'))\n    model.add(Conv2D(64, (3, 3), activation='relu',padding='same',kernel_initializer='he_normal'))\n    model.add(MaxPool2D(pool_size=(2, 2)))\n    model.add(Dropout(0.25))\n    model.add(Conv2D(128, (3, 3), activation='relu',padding='same',kernel_initializer='he_normal'))\n    model.add(Dropout(0.25))\n    model.add(Flatten())\n    model.add(Dense(128, activation='relu'))\n    model.add(BatchNormalization())\n    model.add(Dropout(0.25))\n    model.add(Dense(classes, activation='softmax'))\n\n    model.compile(loss=keras.losses.categorical_crossentropy,\n              optimizer=keras.optimizers.RMSprop(),\n              metrics=['accuracy'])\n\n    callback = ReduceLROnPlateau(monitor='val_acc', \n                                            patience=3, \n                                            verbose=1, \n                                            factor=0.3, \n                                            min_lr=0.0001)\n\n    datagen = ImageDataGenerator(\n        rotation_range=15,\n        zoom_range = 0.1, \n        width_shift_range=0.1,\n        height_shift_range=0.1) ","49d1568f":"model.summary()","766e1512":"datagen.fit(X_train)\nh = model.fit_generator(datagen.flow(X_train,Y_train, batch_size=batch_size),\n                              epochs = epochs, validation_data = (X_val,Y_val),\n                              verbose = 1, steps_per_epoch=X_train.shape[0] \/\/ batch_size\n                              , callbacks=[callback],)","64823709":"final_loss, final_acc = model.evaluate(X_val, Y_val, verbose=0)\nprint(final_loss)\nprint(final_acc)","cae6a698":"#This code is taken straight from the SKLEARN website, an nice way of viewing confusion matrix.\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')\n\n","00954ffd":"Y_pred = model.predict(X_val)\nY_pred_classes = np.argmax(Y_pred, axis = 1) \nY_true = np.argmax(Y_val, axis = 1) \nconfusion_mtx = confusion_matrix(Y_true, Y_pred_classes) \nplot_confusion_matrix(confusion_mtx, classes = range(10))","f82d4bac":"predicted_classes = model.predict_classes(X_test)\nsubmissions=pd.DataFrame({\"ImageId\": list(range(1,len(predicted_classes)+1)),\n                         \"Label\": predicted_classes})\nsubmissions.to_csv(\"vb.csv\", index=False, header=True)","cab80901":"## Loading The Dataset","28fe16d2":"## Basic Simple Plot And Evaluation"}}