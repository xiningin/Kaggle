{"cell_type":{"c26e1956":"code","20ea42e0":"code","884f7c34":"code","9b27ddc4":"code","6a685863":"code","e2f86c9f":"code","9339b1a6":"code","4ed426ab":"code","e0345a0a":"code","e7cbf85a":"code","702f94f8":"code","de71a8f5":"code","5d8d0e9b":"code","f64aa29f":"code","709562d3":"code","0c187ca8":"code","2be8a560":"code","676dae8e":"markdown","d7bde637":"markdown","ec91c9a0":"markdown","99126d20":"markdown","e2aa9454":"markdown","e3be1c4b":"markdown","4b1e4fa0":"markdown","43397658":"markdown","9bda4671":"markdown","21621e44":"markdown","2f06681a":"markdown","def1c3a7":"markdown","465cf4b3":"markdown","c02d9a44":"markdown","eec7f4b6":"markdown","5f87b1dd":"markdown","42385f26":"markdown","59f7baaf":"markdown","ec6b607a":"markdown","b7debe98":"markdown","e4ab6a38":"markdown","0c5e6583":"markdown","4903ec5f":"markdown","796164c1":"markdown","39e0f073":"markdown"},"source":{"c26e1956":"import re\nimport numpy as np\nimport pandas as pd\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set_style('white')\n\nfrom sklearn.model_selection import cross_validate\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.model_selection import StratifiedKFold\n\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import StandardScaler\n\nimport random\nimport time\nfrom datetime import datetime\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\n%matplotlib inline\n\npd.options.display.max_rows = 99\npd.options.display.max_columns = 99\n\ntrain = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')","20ea42e0":"whole = train.append(test)\nwhole = whole[train.columns]\nwhole.drop(['Fare', 'Cabin', 'Embarked'], axis=1, inplace=True)\ndef get_title(string):\n    return re.findall('\\,\\ (.*?)\\.', string)[0]\n\ndef get_family_name(string):\n    return string[:string.index(',')]\n\nwhole['Title'] = whole.Name.apply(get_title)\ntitle_mapping = {\n    'Dr': 'Mr',\n    'Don': 'Mr',\n    'Rev' : 'Mr',\n    'Jonkheer' : 'Mr',\n    'Major' : 'Mr',\n    'Col' : 'Mr',\n    'Capt' : 'Mr',\n    'Sir' : 'Mr',\n    'Ms' : 'Miss',\n    'Mlle' : 'Miss',\n    'Lady' : 'Mrs',\n    'Mme' : 'Mrs',\n    'the Countess' : 'Mrs',\n    'Dona' : 'Mrs',\n}\nwhole.Title.replace(title_mapping, inplace=True)\nwhole.loc[(whole.Title=='Dr') & (whole.Sex == 'female'), 'Title'] = 'Mrs'\n\nwhole['FamilyName'] = whole.Name.apply(get_family_name)\nwhole['FamilySize'] = whole['SibSp'] + whole['Parch']\n\nwhole.head(5)","884f7c34":"ticket_freq = whole.Ticket.value_counts()\nduplicated_tickets = ticket_freq[ticket_freq > 1]\nduplicated_tickets.shape[0]","9b27ddc4":"grouped = duplicated_tickets.sum()\nungrouped = whole.shape[0] - grouped\n\nplt.figure(figsize=(6,6))\nplt.rc('font', size=14)\nplt.pie([ungrouped, grouped], explode=[0, .05], labels=['individual', 'grouped'], \n        autopct='%1.0f%%', startangle=82)\nplt.title('Grouped People are 46% of the entire passengers')\nplt.show()","6a685863":"duplicated_tickets.hist(bins=9, align='left')\nplt.title('Group Size Histogram')\nplt.show()","e2f86c9f":"whole[whole.Ticket == duplicated_tickets.index[0]]","9339b1a6":"whole[whole.Ticket == duplicated_tickets.index[5]]","4ed426ab":"whole[whole.Ticket == duplicated_tickets.index[9]]","e0345a0a":"whole[whole.Ticket == duplicated_tickets.index[15]]","e7cbf85a":"group_dict = {'ticket':[], 'size':[], 'color':[], 'survival':[]}\n\nfor ticket in duplicated_tickets.index:\n    group_dict['ticket'].append(ticket)\n    group_dict['size'].append((whole.Ticket == ticket).sum())\n    \n    # get group color: Homogeneous vs Heterogeneous\n    uniq_fn = whole.loc[whole.Ticket == ticket, 'FamilyName'].nunique()\n    if uniq_fn == 1:\n        group_dict['color'].append('Homo')\n    else:\n        group_dict['color'].append('Hetero')\n        \n    # get survival rate: Survived(all survived), Perished(all perished), Mixed(some survived)\n    non_null_count = len(whole[(whole.Ticket == ticket) & (whole.Survived.notnull())])\n    survived = whole.loc[whole.Ticket == ticket, 'Survived'].sum()\n    \n    if non_null_count <= 1:\n        group_dict['survival'].append('Mixed') # only one known value -> mixed\n    elif survived == 0:\n        group_dict['survival'].append('Perished')\n    elif non_null_count == survived:\n        group_dict['survival'].append('Survived')\n    else:\n        group_dict['survival'].append('Mixed')\n        \n\ngroup_df = pd.DataFrame(group_dict)\ngroup_df.head(5)","702f94f8":"_, (ax0, ax1) = plt.subplots(1, 2, figsize=(14, 4))\nsns.countplot(x='color', data=group_df, ax=ax0)\nax0.set_title('Counts per Group Color')\nsns.countplot(x='survival', data=group_df, ax=ax1)\nax1.set_title('Counts per Group Survival')\nplt.show()","de71a8f5":"plt.figure(figsize=(10, 5))\nsns.violinplot(x='survival', y='size', data=group_df)\nplt.title('Group Size')\nplt.show()","5d8d0e9b":"whole['GroupSize'] = 1\nfor tick in duplicated_tickets.index:\n    size = (whole.Ticket == tick).sum()\n    whole.loc[whole.Ticket == tick, 'GroupSize'] = size\n    \n_, (ax0, ax1) = plt.subplots(1, 2, figsize=(14,5))\n\nwhole.groupby(by='FamilySize').Survived.agg(np.mean).plot.bar(ax=ax0)\nax0.set_title('Survival Rate per Family Size')\n\nwhole.groupby(by='GroupSize').Survived.agg(np.mean).plot.bar(ax=ax1)\nax1.set_title('Survival Rate per Companion Group Size')\n\nplt.show()","f64aa29f":"whole['Grouped'] = (whole.GroupSize > 1).astype('int8')\nsns.barplot(x='Sex', y='Survived', hue='Grouped', data=whole)\nplt.title('Survival Rate')\nplt.show()","709562d3":"# create two features\nwhole['GroupColor'] = whole.Ticket.apply(lambda ticket: group_dict['color'][group_dict['ticket'].index(ticket)] if ticket in group_dict['ticket'] else 'NoGroup')\nwhole['GroupSurvival'] = whole.Ticket.apply(lambda ticket: group_dict['survival'][group_dict['ticket'].index(ticket)] if ticket in group_dict['ticket'] else 'NoGroup')\n\n# remove non-numeric columns\ncorr_df = whole.drop(['PassengerId', 'Name', 'Ticket', 'Title', 'FamilyName'], axis=1)\n\n# numerize categorical columns\ncorr_df.Sex.replace({'male': 0, 'female': 1}, inplace=True)\ncorr_df.GroupColor.replace({'NoGroup': 0, 'Homo': 1, 'Hetero': 2}, inplace=True)\ncorr_df.GroupSurvival.replace({'NoGroup': -1, 'Perished': 0, 'Mixed': 1, 'Survived': 2}, inplace=True)\n\n# Chunking GroupSize\n# The correlation value is not changed when I chunk the group size or not, so comment them for just now\n# It may be worth when we apply this in models\n\n# cut_points = [-1, 0, 3, 7, 20]\n# label_names = ['No', 'Small', 'Big', 'Huge']\n# corr_df['GroupSize'] = pd.cut(corr_df['GroupSize'], cut_points, labels=label_names)\n# corr_df['GroupSize'].replace({'No': 0, 'Small': 1, 'Big':2, 'Huge':3}, inplace=True)\n\n# show the heatmap\nplt.figure(figsize=(12,12))\nsns.heatmap(corr_df.corr(), cmap='RdBu_r', annot=True, center=0.0, fmt='.2g')\nplt.title('Correlations between features')\nplt.show()","0c187ca8":"class TitanicPreprocessor:\n    \n    def __init__(self, train, test):\n        # store the length of train dataset to split merget dataframe again\n        self.train_len = train.shape[0]\n        \n        # merge two dataframes into one\n        self.whole = train.append(test)\n        self.whole = self.whole[train.columns]  # keep the column order\n        \n    @staticmethod\n    def get_title(string):\n        return re.findall('\\,\\ (.*?)\\.', string)[0]\n    \n    def __create_features(self):\n        '''Create new features: Title and FS(family size)'''\n        # Now we use Title feature for only filling missing values of Age feature\n        self.whole['Title'] = self.whole.Name.apply(self.get_title)\n        \n        title_mapping = {\n            'Dr': 'Mr',\n            'Don': 'RareMale',\n            'Rev' : 'RareMale',\n            'Jonkheer' : 'RareMale',\n            'Major' : 'RareMale',\n            'Col' : 'RareMale',\n            'Capt' : 'RareMale',\n            'Sir' : 'Mr',\n            'Ms' : 'RareFemale',\n            'Mlle' : 'RareFemale',\n            'Lady' : 'RareFemale',\n            'Mme' : 'RareFemale',\n            'the Countess' : 'RareFemale',\n            'Dona' : 'RareFemale',\n        }\n        self.whole.Title.replace(title_mapping, inplace=True)\n        \n        # There is one female whose Title is Dr\n        self.whole.loc[(self.whole.Title=='Dr') & (self.whole.Sex == 'female'), 'Title'] = 'Mrs'\n\n        # Family Size\n        self.whole['FS'] = self.whole['SibSp'] + self.whole['Parch']\n\n    def __fill_missing_values(self):\n        '''Deal with missing values(Age, Embarked, Fare, and Cabin)'''\n        # Fill Age with the average age of the same class and title group.\n        for index, row in self.whole[self.whole.Age.isnull()].iterrows():\n            avg = self.whole.loc[(self.whole['Pclass'] == row['Pclass']) & (self.whole['Title'] == row['Title']), 'Age'].mean()\n            if np.isnan(avg): # for rare case, there is no sample for the average of age.\n                avg = self.whole.loc[self.whole['Title'] == row['Title'], 'Age'].mean()\n            self.whole.loc[index, 'Age'] = avg\n            \n        # Fill Embarked and Fare with average values\n        self.whole.Embarked.fillna(self.whole.Embarked.mode()[0], inplace=True)\n        self.whole.Fare.fillna(self.whole.Fare.mean(), inplace=True)\n        \n        # We are not interested at Cabin which has so many missing values\n        self.whole.drop('Cabin', axis=1, inplace=True)\n        \n    def __get_group_features(self):\n        '''\n        This method is to implement the proposed features \n        '''\n        self.whole['FamilyName'] = self.whole.Name.apply(lambda x: x[:x.index(',')])\n\n        ticket_freq = self.whole.Ticket.value_counts()\n        duplicated_tickets = ticket_freq[ticket_freq > 1]        \n\n        group_dict = {'ticket':[], 'size':[], 'color':[], 'survival':[]}\n\n        for ticket in duplicated_tickets.index:\n            group_dict['ticket'].append(ticket)\n            group_dict['size'].append((self.whole.Ticket == ticket).sum())\n\n            # get group color: Homogeneous vs Heterogeneous\n            uniq_fn = self.whole.loc[self.whole.Ticket == ticket, 'FamilyName'].nunique()\n            if uniq_fn == 1:\n                group_dict['color'].append('Homo')\n            else:\n                group_dict['color'].append('Hetero')\n\n            # get survival rate: Survived(all survived), Perished(all perished), Mixed(some survived)\n            non_null_count = len(self.whole[(self.whole.Ticket == ticket) & (self.whole.Survived.notnull())])\n            survived = self.whole.loc[self.whole.Ticket == ticket, 'Survived'].sum()\n\n            if non_null_count <= 1:\n                group_dict['survival'].append('Mixed') # only one known value -> mixed\n            elif survived == 0:\n                group_dict['survival'].append('Perished')\n            elif non_null_count == survived:\n                group_dict['survival'].append('Survived')\n            else:\n                group_dict['survival'].append('Mixed')\n\n\n        self.whole['GroupColor'] = self.whole.Ticket.apply(lambda ticket: group_dict['color'][group_dict['ticket'].index(ticket)] if ticket in group_dict['ticket'] else 'NoGroup')\n        self.whole['GroupSurvival'] = self.whole.Ticket.apply(lambda ticket: group_dict['survival'][group_dict['ticket'].index(ticket)] if ticket in group_dict['ticket'] else 'NoGroup')\n        \n        group_df = pd.DataFrame(group_dict)\n\n        self.whole['GroupSize'] = 1\n        for tick in duplicated_tickets.index:\n            size = (self.whole.Ticket == tick).sum()\n            self.whole.loc[self.whole.Ticket == tick, 'GroupSize'] = size\n            \n        self.whole['Grouped'] = (self.whole.GroupSize > 1).astype('int8')\n        self.whole.GroupColor.replace({'NoGroup': 0, 'Homo': 1, 'Hetero': 2}, inplace=True)\n        self.whole.GroupSurvival.replace({'NoGroup': -1, 'Perished': 0, 'Mixed': 1, 'Survived': 2}, inplace=True)\n        \n        cut_points = [-1, 0, 3, 7, 20]\n        label_names = ['No', 'Small', 'Big', 'Huge']\n        self.whole['GroupSize'] = pd.cut(self.whole['GroupSize'], cut_points, labels=label_names)\n        self.whole['GroupSize'].replace({'No': 0, 'Small': 1, 'Big':2, 'Huge':3}, inplace=True)\n    \n\n    def __encoding(self):\n        '''Converting categorical features into numerical ones.'''\n        label = LabelEncoder()\n\n        # Divide Fare into 3 groups and Age into 4 groups\n        self.whole['FareCode'] = label.fit_transform(pd.qcut(self.whole.Fare, 3))\n        self.whole['AgeCode'] = label.fit_transform(pd.qcut(self.whole.Age, 4))\n        \n        self.whole.Sex.replace({'male': 0, 'female': 1}, inplace=True)\n        self.whole = pd.concat([self.whole, pd.get_dummies(self.whole.Title, prefix='Title')], axis=1)\n\n    def get_processed(self):\n        \n        '''Processing all the feature engineering'''\n        \n        # feature engineering processes\n        self.__create_features()\n        self.__fill_missing_values()\n        # new step for the proposed featuers\n        self.__get_group_features()\n        self.__encoding()\n        \n        # drop useless features\n        self.whole.drop(['Name', 'Ticket', 'Embarked', 'Title', 'FamilyName'], axis=1, inplace=True)\n        \n        # get dataframes\n        features = self.whole.columns.tolist()\n        target = 'Survived'\n        features.remove(target)\n        features.remove('PassengerId')\n\n        X = self.whole[:self.train_len][features]\n        y = self.whole[:self.train_len]['Survived']\n        test_X = self.whole[self.train_len:][features]\n        \n        # scaling\n        std_scaler = StandardScaler()\n        X = std_scaler.fit_transform(X)\n        test_X = std_scaler.transform(test_X)\n        \n        return (X, y, test_X, features)\n\n        \ndef fit_and_predict(model, train_X, train_y, test_X):\n    # We got average score and average prediction\n    score_sum = 0\n    predict_sum = np.zeros(len(test_X))\n\n    folds = 5\n    skf = StratifiedKFold(n_splits=folds, shuffle=True, random_state=0)\n\n\n    # For each fold\n    for train_index, test_index in skf.split(train_X, train_y):\n        X_train, X_test = X[train_index], X[test_index]\n        y_train, y_test = y[train_index], y[test_index]    \n\n        # fit & predict\n        model.fit(X_train, y_train)\n        predict = model.predict(X_test)\n\n        # this is not a score but an error rate(MAE)\n        score = np.sum(np.abs(predict - y_test)) \/ len(predict)\n        score_sum += score\n\n        # prediction averaging is a great help\n        predict = model.predict(test_X)\n        predict_sum += predict\n        \n    # average the results from folds\n    avg_score = 1 - (score_sum \/ folds)\n    avg_predict = predict_sum \/ folds\n    \n    return (avg_score, avg_predict)\n\ndef draw_feature_importance(model, features):\n    df = pd.DataFrame({'feature': features, 'importance': model.feature_importances_})\n    df.sort_values(by='importance', ascending=True, inplace=True)\n    df.plot(x='feature', y='importance', kind='barh')\n    plt.title('Feature Importance')\n    plt.show()","2be8a560":"pp = TitanicPreprocessor(train, test)\nX, y, test_X, features = pp.get_processed()\n\n# We got this model from GridCV\nmodel = RandomForestClassifier(criterion = 'entropy', \n                               max_depth = 10, \n                               max_features = 'log2', \n                               min_samples_leaf = 1, \n                               min_samples_split = 5, \n                               n_estimators = 6, \n                               random_state = 9)\n\nscore, pred = fit_and_predict(model, X, y, test_X)\nprint('CV Score:', score)\ndraw_feature_importance(model, features)\n\n# submit the result\nresult_df = pd.DataFrame({'PassengerId': test['PassengerId'], 'Survived': pred})\nresult_df.Survived = result_df.Survived.astype('uint8')\nresult_df.to_csv('submission-{0}-{1:.3f}.csv'.format(datetime.now().strftime('%y%m%d-%H%M'), score), index=False)","676dae8e":"\ud83d\udd2f ** Insight #1: 46% of passengers were included in 216 companion groups.**","d7bde637":"<a id='2'><\/a>\n# [2. Inside Companion Groups](#99)\n\nThe `traveling companion group` here means the group of people who started the journey together. It is decided by the ticket number: people who share the same ticket number are in the same traveling companion group.\n\nFor the investigation, we get title and family names:","ec91c9a0":"Great!!! Look!\n\n\ud83d\udd2f **Insight #6: Companion group features have relatively high correlations to the `Survived`.**\n\n\n`GroupSize` is related to the `Survived` 4 times more than `FamilySize`.","99126d20":"<a id='23'><\/a>\n## [2.3 Survival Rate](#99)","e2aa9454":"<a id='3'><\/a>\n# [3. Test & Validation](#99)\n\nOur research shows that companion group features are useful for prediction of `Survived`. But it would remain as a hypothesis until it is proved in the practice.\n\nFor this, we compared the accuracy of the model which contains the proposed features with the original model.\n","e3be1c4b":"<a id='4'><\/a>\n# [4. Conclusion](#99)\n\nWe have focused on the companion group features of Titanic passengers. From this study we found the following insights:\n\n1. 46% of passengers were included in 216 companion groups.\n1. There are 3 kinds of companion group: 1) pure family, 2) family with servants, and 3) friends.\n1. Groups were: 1) all perished, 2) All survived, or 3) Some survived.\n1. Small groups are inclined to be survived.\n1. Grouped passengers are more inclined to be survived.\n1. Companion group features have relatively high correlations to the Survived.\n\nOur experiment shows that companion group features can improve the CV score 0.005(from 0.969 to 0.974) and the public score 0.005(from 0.78468 to 0.78947).\n\nUnfortunately, this improvement is far less than we expected from EDA. This unexpected little improvement may be caused by our poor model or the bias of data.\n\nBut as our study aimed not to improve the public score but to mine a new feature, it doesn't disappoint us and we only hope this kernel and our study can help you Kagglers' work!!!\n","4b1e4fa0":"<a id='24'><\/a>\n## [2.4 Correlation](#99)\nWe saw that companion group features are worth to be considered. Then let's see how much they are related to the `Survived` column.","43397658":"\ud83d\udd2f **Insight #4: Small groups are inclined to be survived.**","9bda4671":"<a id='5'><\/a>\n# [5. References](#99)\n","21621e44":"<a id='99'><\/a>\n# Focusing on Companion Groups\n\n********\n\nDo you enjoy traveling alone? For my case, not at all. On Titanic, many people were traveling in groups, nearly half of the passengers were in groups.\n\nThe `family size` feature, which is calculated by `SibSp + Parch`, has been discussed in many kernels and showed its effect on the accuracy of models. But I noticed that there are more about passenger groups than family. \n\nFor example, let's see the passengers who shared the same ticket `16966`. There are 5 people: \n* Mr. Spedden Frederic Oakley, the host(45 years old)\n* Mrs. Spedden, the hostess(40 years old)\n* Master. Spedden Douglas, their son(6 years old)\n* Miss. Wilson Helen Alice, the personal maid to Mrs. Spedden(31 years old)\n* Miss. Burns Margaret, the nursemaid to Master. Spedden(41 years old)\n\nLike the family above, many families in the 1st class were accompanied by their servants or other family staffs. Except for families, there were some groups of young people and I guess they were friends.\n\nSome groups all survived or perished, and others some of them are survived. If family size can contribute to the model, what about the companion group size? In this kernel, I studied on traveling companion groups of Titanic passengers and how it affects the survival rate.\n\n<img src='https:\/\/media.graytvinc.com\/images\/810*455\/titanic25.jpg' align='right' width='450' \/>\n\n\n### Contents\n\n1. [Loading Libraries & Data](#1)\n1. [Inside Companion Groups](#2)\n    1. [How many groups are there?](#21)\n    1. [What kinds of groups?](#22)\n    1. [Survival Rate](#23)\n    1. [Correlation](#24)\n1. [Test & Validation](#3)\n1. [Conclusion](#4)\n1. [References](#5)\n1. [ChangeLog](#6)\n\n","2f06681a":"<a id='1'><\/a>\n# [1. Loading Libraries & Data](#99)","def1c3a7":"<a id='21'><\/a>\n## [2.1 How many groups are there?](#99)","465cf4b3":"<a id='6'><\/a>\n# [6. ChangeLog](#99)","c02d9a44":"This is a big family companion: father Sage, Mr. John George, mother Sage, Mrs. John (Annie Bullen) and their 9 children. They seem to be all perished.","eec7f4b6":"**I love your feedbacks even a typo!!**","5f87b1dd":"<a id='22'><\/a>\n## [2.2 What kinds of groups?](#99)","42385f26":"They are one family, and some of them were survived and others perished. Men had perished and women were all survived. We can see here the \"**Women and Children First!**\" myth.","59f7baaf":"1. V1: Original work.\n1. V7: Changed fit_and_predict() function to use StratifiedKFold and average prediction results from all folds. This resulted in the increase of public score from 0.78947 to 0.80382.\n1. V10: Add some comments in the codes.","ec6b607a":"1. Megan Risdal, [\"Exploring Survival on the Titanic\"](https:\/\/www.kaggle.com\/mrisdal\/exploring-survival-on-the-titanic)\n1. Sediment, [\"Group - A Feature specifying one's companion\"](https:\/\/www.kaggle.com\/sediment\/group-a-feature-specifying-one-s-companion)\n1. Ben Hamner, [\"Random Forest Benchmark (R)\"](https:\/\/www.kaggle.com\/benhamner\/random-forest-benchmark-r)","b7debe98":"This is a group of young. I guess they were 3 Hickman brothers and their friends. They seem to be all perished too.","e4ab6a38":"Here, 3 `Widener`s were family members, Miss. Geiger and Mr. Keeping were maid and servant respectively. We can't know how many of them were survived as there is only one known `Survived` value. It's one of the troubles in digging companion groups.\n\nWe decided to consider this type of group(with only one `Survived` value) as the type with some survived and some perished.","0c5e6583":"Survival rate by group size is similar to the one by family size but a little bit different. Families of 1~3 size and groups of 2~4 size have a high survival rate. \n\n* Divide family size into nofamily(0), small(1~3), big(4+), and huge(7+).\n* Divide group size into nogroup(1), small(2~4), big(5~8), and huge(9+).","4903ec5f":"\ud83d\udd2f **Insight #5: Grouped passengers are more inclined to be survived.**","796164c1":"\ud83d\udd2f **Insight #2: There are 3 kinds of companion group: 1) pure family, 2) family with servants, and 3) friends.**\n\n\ud83d\udd2f **Insight #3: Groups were: 1) all perished, 2) All survived, or 3) Some survived.**","39e0f073":"There were 216 travelling companions on Titanic."}}