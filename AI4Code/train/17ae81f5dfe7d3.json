{"cell_type":{"d2532cab":"code","040bc37f":"code","ae6c8653":"code","ebf93bd0":"code","c4fe5fe5":"code","1b96eafa":"code","3ee3bc7b":"code","31db8c86":"code","67bf9fc7":"code","a26b2b20":"code","521eb5e9":"code","788513e6":"code","2b2d9ad4":"code","66065377":"code","f927c927":"code","1d010432":"code","3fbef421":"code","3095d55a":"code","00b18af3":"code","6f950e9d":"code","ea0e5bab":"code","ea9d86f0":"code","99d1c4ea":"code","c7690203":"code","1f5bc462":"code","52fb2627":"code","93a6b999":"code","78a66e62":"code","a2402d3f":"code","7b0cadf4":"code","aafdd362":"code","6f163ec2":"code","e66d1cf9":"code","5548862d":"code","ed1e9d61":"code","2bf1cdf5":"code","750de08d":"markdown","86186f91":"markdown","82d3e292":"markdown","f9cf4906":"markdown","3fad4757":"markdown","269c510b":"markdown","dab667db":"markdown","a62f1c0c":"markdown","a3c212bb":"markdown","8e2e8040":"markdown","4eb783cd":"markdown"},"source":{"d2532cab":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","040bc37f":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport math","ae6c8653":"train_data = pd.read_csv(\"..\/input\/X_train.csv\")","ebf93bd0":"print(train_data.shape)\ntrain_data.head()","c4fe5fe5":"train_data['series_id'].nunique()","1b96eafa":"train_labels = pd.read_csv(\"..\/input\/y_train.csv\")","3ee3bc7b":"print(train_labels.shape)\nprint(train_labels['surface'].nunique())\ntrain_labels.head()","31db8c86":"train_data.info()","67bf9fc7":"def get_range(data_list):\n    \n    return max(data_list)-min(data_list)","a26b2b20":"plt.figure(figsize=(10,4))\nplt.subplot(221)\nplt.hist(train_data.groupby('series_id')['orientation_X'].apply(get_range))\nplt.xlabel('orientation_X_range')\nplt.subplot(222)\nplt.hist(train_data.groupby('series_id')['orientation_Y'].apply(get_range))\nplt.xlabel('orientation_Y_range')\nplt.subplot(223)\nplt.hist(train_data.groupby('series_id')['orientation_Z'].apply(get_range))\nplt.xlabel('orientation_Z_range')\nplt.subplot(224)\nplt.hist(train_data.groupby('series_id')['orientation_W'].apply(get_range))\nplt.xlabel('orientation_W_range')\nplt.tight_layout()","521eb5e9":"def plot_feature_variations(series_n_data, series_number, surface_type):\n    \n    plt.figure(figsize=(15,4))\n\n    plt.subplot(231)\n    plt.plot(series_n_data['measurement_number'],series_n_data['angular_velocity_X'])\n    plt.xlabel('measurement_number')\n    plt.ylabel('angular_velocity_X')\n\n    plt.subplot(232)\n    plt.plot(series_n_data['measurement_number'],series_n_data['angular_velocity_Y'])\n    plt.xlabel('measurement_number')\n    plt.ylabel('angular_velocity_Y')\n\n    plt.subplot(233)\n    plt.plot(series_n_data['measurement_number'],series_n_data['angular_velocity_Z'])\n    plt.xlabel('measurement_number')\n    plt.ylabel('angular_velocity_Z')\n\n    plt.subplot(234)\n    plt.plot(series_n_data['measurement_number'],series_n_data['linear_acceleration_X'])\n    plt.xlabel('measurement_number')\n    plt.ylabel('linear_acceleration_X')\n\n    plt.subplot(235)\n    plt.plot(series_n_data['measurement_number'],series_n_data['linear_acceleration_Y'])\n    plt.xlabel('measurement_number')\n    plt.ylabel('linear_acceleration_Y')\n\n    plt.subplot(236)\n    plt.plot(series_n_data['measurement_number'],series_n_data['linear_acceleration_Z'])\n    plt.xlabel('measurement_number')\n    plt.ylabel('linear_acceleration_Z')\n\n    plt.tight_layout()","788513e6":"series_0_data=train_data[train_data['series_id']==0]\nsurface_type=train_labels['surface'][0]\nprint(\"Feature Variations for Surface Type {}\".format(surface_type))\nplot_feature_variations(series_0_data, 0 , surface_type)\n\n\nseries_1_data=train_data[train_data['series_id']==1]\nsurface_type=train_labels['surface'][1]\nprint(\"Feature Variations for Surface Type {}\".format(surface_type))\nplot_feature_variations(series_1_data, 1 , surface_type)\n\nseries_4_data=train_data[train_data['series_id']==4]\nsurface_type=train_labels['surface'][4]\nprint(\"Feature Variations for Surface Type {}\".format(surface_type))\nplot_feature_variations(series_4_data, 4 , surface_type)","2b2d9ad4":"x = np.arange(9)\ncounts = train_labels['surface'].value_counts()\n \nplt.figure(figsize=(15,4))\nplt.bar(x, counts, align='center', alpha=0.5)\nplt.xticks(x, train_labels['surface'].value_counts().index.tolist())\nplt.ylabel('Counts in Training Data')\nplt.title('Surface Data Occurences')\n\nprint(train_labels['surface'].value_counts())\n\ny=train_labels['surface'].values","66065377":"group_ids=train_labels['group_id']\nprint(group_ids.shape)\nprint(group_ids.nunique())\n\ngroup_ids=np.array(group_ids)","f927c927":"from sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.ensemble import RandomForestClassifier","1d010432":"train_features=train_data.drop(['row_id','measurement_number'],axis=1)","3fbef421":"train_features.columns","3095d55a":"sc= MinMaxScaler()\n\ndef feature_transform(features_data):\n    all_features=pd.DataFrame()\n    \n    features_data['orientation']=np.sqrt(features_data['orientation_X']**2+features_data['orientation_Y']**2+\n                                         features_data['orientation_Z']**2+features_data['orientation_W']**2)\n    \n    features_data['ang_vel_mag']=np.sqrt(features_data['angular_velocity_X']**2 + \n                                features_data['angular_velocity_Y']**2 + features_data['angular_velocity_Z']**2)\n    \n    features_data['lin_acc_mag']=np.sqrt(features_data['linear_acceleration_X']**2 + \n                                features_data['linear_acceleration_Y']**2 + features_data['linear_acceleration_Z']**2)\n    \n    \n    for col in features_data.columns:\n        if col=='series_id':\n            continue\n        all_features[col+'_mean']=features_data.groupby('series_id')[col].mean()\n        all_features[col+'_median']=features_data.groupby('series_id')[col].median()\n        all_features[col+'_min']=features_data.groupby('series_id')[col].min()\n        all_features[col+'_max']=features_data.groupby('series_id')[col].max()\n        all_features[col+'_std']=features_data.groupby('series_id')[col].std()\n        #all_features[col+'_q25']=features_data.groupby('series_id')[col].quantile(0.25)\n        #all_features[col+'_q50']=features_data.groupby('series_id')[col].quantile(0.5)\n        #all_features[col+'_q75']=features_data.groupby('series_id')[col].quantile(0.75)\n        all_features[col+'_maxByMin']=all_features[col+'_max']\/all_features[col+'_min']\n        all_features[col+'_range']=all_features[col+'_max']-all_features[col+'_min']\n       \n        \n    all_features=all_features.reset_index()\n    all_features=all_features.drop(['series_id'],axis=1)\n    all_features=sc.fit_transform(all_features)\n    \n    return all_features","00b18af3":"all_train_features=feature_transform(train_features)","6f950e9d":"enc = LabelEncoder()\ny_transformed=enc.fit_transform(np.reshape(y,(-1,1)))","ea0e5bab":"y_transformed[:25]","ea9d86f0":"X=np.array(all_train_features)\ny=y_transformed","99d1c4ea":"test_data= pd.read_csv(\"..\/input\/X_test.csv\")","c7690203":"test_data.shape","1f5bc462":"test_features=test_data.drop(['row_id','measurement_number'],axis=1)","52fb2627":"all_test_features=feature_transform(test_features)","93a6b999":"all_test_features=np.array(all_test_features)\n\nprint(len(all_test_features))\nprint(len(all_test_features[0]))","78a66e62":"folds = StratifiedKFold(n_splits=5, shuffle=True, random_state=20)\npredicted = np.zeros((len(all_test_features),9))\nmeasured= np.zeros(len(X))\nscore = 0\n\nmodel = RandomForestClassifier(n_estimators=500, random_state=123, max_depth=15, min_samples_split=5)\n\nfor t, (trn_idx, val_idx) in enumerate(folds.split(X,y)):    \n    model.fit(X[trn_idx],y[trn_idx])\n    measured[val_idx] = model.predict(X[val_idx])\n    predicted += model.predict_proba(all_test_features)\/folds.n_splits\n    score += model.score(X[val_idx],y[val_idx])\n    print(\"Fold: {} score: {}\".format(t,model.score(X[val_idx],y[val_idx])))","a2402d3f":"print(confusion_matrix(measured,y))","7b0cadf4":"print('Average Accuracy is ',score\/folds.n_splits)","aafdd362":"submission_file=pd.read_csv(\"..\/input\/sample_submission.csv\")","6f163ec2":"results=pd.DataFrame(enc.inverse_transform(predicted.argmax(axis=1)))","e66d1cf9":"results.head()","5548862d":"final_submission=submission_file.drop(['surface'],axis=1)","ed1e9d61":"final_submission=pd.concat([final_submission,results],axis=1,ignore_index=True)","2bf1cdf5":"final_submission.to_csv(\"submission_final.csv\",header=['series_id','surface'],index=False)","750de08d":"The group_ids indicate the batches in which the training was conducted while recording the data. There are 73 such groups.","86186f91":"**By: Prabhat Kumar Sahu**","82d3e292":"# Model Evaluation","f9cf4906":"# Feature Extraction","3fad4757":"# Submission File","269c510b":"I have used StratifiedKFold validation as the classes are greatly imbaalanced in the training dataset.","dab667db":"So, there are 3810 actual tested cases on 9 different categories of surfaces. We can see below that there is no missing data.","a62f1c0c":"The three sections of plots above show the velocity and acceleration data for three different series based on flooring type namely: fine_concrete, concrete, soft_tiles. One major observation from the above plots is that the time-series values have some inherent patterns and especially the 'angular_velocity_Z' seems to vary drastically with the flooring type.\n\nTo capture these variations in values across a series, we shall make use of multiple descriptive statistics features like mean, median, std, etc. and use them as features to train our classifier.","a3c212bb":"One key observation here is that the data is highly imbalanced with very less examples of hard_tiles in particular. So, this needs to be taken care of while splitting the data for cross-validation.","8e2e8040":"# EDA","4eb783cd":"As we can see from the above histograms, the values of 'orientation' in a given series do not vary much (as the 'range' values are very small here)."}}