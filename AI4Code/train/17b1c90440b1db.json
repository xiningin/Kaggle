{"cell_type":{"2154b082":"code","016ce846":"code","4012ceab":"code","23eea439":"code","388e552a":"code","4487d2ed":"code","ea9e0aef":"code","a2586911":"code","28ce8bed":"code","12dbe184":"code","a7d85821":"code","ff727a24":"code","bb54c054":"code","5653f727":"code","ea0f3df9":"code","08909b12":"code","b9f9b2b7":"code","6ce91bde":"code","46db40c0":"markdown","003487b4":"markdown","12b7df8d":"markdown","18937f6b":"markdown","01f2719a":"markdown","77d99694":"markdown","f43a8722":"markdown","915fb691":"markdown","f421405f":"markdown","5c3b325f":"markdown","1c533edd":"markdown","a927be5f":"markdown","39c2aa89":"markdown","5c5e2950":"markdown","9b90706c":"markdown","b9ec872d":"markdown"},"source":{"2154b082":"import matplotlib.pyplot as plt # visualization\nimport seaborn as sns # visualization\nimport pandas as pd\nimport warnings\nwarnings.filterwarnings('ignore')\n%matplotlib inline\n\n\n\ndf = pd.read_csv('..\/input\/creditcard.csv')\ndf.head()","016ce846":"df.columns","4012ceab":"df.dtypes","23eea439":"df.describe()","388e552a":"df.info()","4487d2ed":"df.isnull().any()","ea9e0aef":"c = df['Class']\nax = sns.countplot(c, label='Frequency')\nV, F = c.value_counts()\n\nprint('Number of Fraudulent: ', F)\nprint('Number of Valid: ', V)","a2586911":"df.hist(figsize=(20,20), color = \"green\")\nplt.show()","28ce8bed":"# Correlation matrix\n\ncorr = df.corr()\n\nfig = plt.figure(figsize=(12, 9))\n\nsns.heatmap(corr, vmax=.8, cmap=sns.diverging_palette(180,10,as_cmap=True),square=True)\nplt.show()","12dbe184":"corr = df.corrwith(df['Class']).reset_index()\ncorr.columns = ['Index','Correlations']\ncorr = corr.set_index('Index')\ncorr = corr.sort_values(by=['Correlations'], ascending = False)\nplt.figure(figsize=(4,15))\nfig = sns.heatmap(corr, annot=True, fmt=\"g\", cmap='RdYlGn')\nplt.title(\"Correlation of Variables with Class\")\nplt.show()","a7d85821":"plt.figure(figsize=(8,4))\nfig = plt.scatter(x=df[df['Class'] == 1]['Time'], y=df[df['Class'] == 1]['Amount'], color=\"red\")\nplt.title(\"Time vs Transaction Amount in Fraud Cases\")\nplt.show()","ff727a24":"plt.figure(figsize=(8,4))\nfig = plt.scatter(x=df[df['Class'] == 0]['Time'], y=df[df['Class'] == 0]['Amount'], color=\"green\")\nplt.title(\"Time vs Transaction Amount in Legit Cases\")\nplt.show()","bb54c054":"# importing the model\nfrom sklearn.ensemble import IsolationForest\nfrom sklearn.model_selection import train_test_split","5653f727":"valid = df[df.Class==0]\nvalid = valid.drop(['Class'], axis=1)\nfraud = df[df.Class==1]\nfraud = fraud.drop(['Class'], axis=1)\nvalid_train, valid_test = train_test_split(valid, test_size=0.30, random_state=42)","ea0f3df9":"valid_train.head()","08909b12":"valid_test.head()","b9f9b2b7":"model = IsolationForest()\nmodel.fit(df.drop(['Class'], axis=1))\nvalid_pred_test = model.predict(valid_test)\nfraud_pred = model.predict(fraud)","6ce91bde":"print(\"Accuracy in Detecting Valid Cases:\", list(valid_pred_test).count(1)\/valid_pred_test.shape[0])\nprint(\"Accuracy in Detecting Fraud Cases:\", list(fraud_pred).count(-1)\/fraud_pred.shape[0])","46db40c0":"This notebook will test Isolation forest algorithm to find anomalies in transaction dataset.","003487b4":"**Explore the Dataset**","12b7df8d":"**Isolation Forest**","18937f6b":"The algorithm was accurate to 90% in detecting the valid transactions and 88% in detecting the fraudulent transactions.","01f2719a":"Plotting Time vs Transaction amount for fraud and valid transactions ","77d99694":"Check for nulls","f43a8722":"**Import necessary packages**","915fb691":"Splitting valid and fraud cases","f421405f":"The isolation forest method returns the anomaly scores as well. It isolates the observation by randomly selecting a feature and then randomly selecting a split value between the maximum and minimum values of the selected feature. So, we're going to have all the different columns here to be considered a feature. Since recursive partitioning can be represented by a tree structure, the number of splitting required to isolate a sample is equivalent to the path length from the root node to the terminating node.\n\nSo this path length averaged over a a force of such as these random trees is a measure of normality and our decision function. So random partitioning produces noticeably shorter pass for anomalies. Hence when a forest of random trees collectively produce shorter path lengths for a particular sample they are highly likely to be anomalies.","5c3b325f":"## Credit card fraud detection","1c533edd":"Corrlation of different variables with Class variable","a927be5f":"**Checking the Target Classes**","39c2aa89":"Plot histogram to see the distribution among features","5c5e2950":"Fitting the model","9b90706c":"**Modelling**","b9ec872d":"**Correlation matrix**"}}