{"cell_type":{"354380a1":"code","178d0df9":"code","bfa37010":"code","63048f4c":"code","1b715b3f":"code","ba0e47bb":"code","4b6559a7":"code","e8081c93":"code","912d8ffb":"code","310eec37":"code","4420ec14":"code","d4405f7d":"code","ff930ff5":"code","a5458892":"code","abd6cfe5":"code","79706aa4":"code","77cd30e9":"code","bd8cafdf":"code","1173d6d1":"code","f017192f":"code","972f550b":"code","1d3b3cbf":"code","fda60ad8":"code","ec9e4206":"code","ea06a767":"code","424033ee":"code","9eb1ae36":"code","6800fe56":"code","5c3dc491":"markdown","39b0a406":"markdown","1f0f47a1":"markdown","9436959d":"markdown"},"source":{"354380a1":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly.graph_objects as go\n\n# # Input data files are available in the read-only \"..\/input\/\" directory\n# # For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\n# import os\n# for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#     for filename in filenames:\n#         print(os.path.join(dirname, filename))\n\n# # You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# # You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session\n\n# pd.set_option('display.max_rows', 100)\n# pd.set_option('display.max_columns', 400)","178d0df9":"from abc import ABC, abstractmethod\nfrom enum import Enum\nfrom typing import List, Type\n\nimport numpy as np\nimport pandas as pd\n\n\nclass Mapping(Enum):\n    \"\"\"\n    Contains dicts mapping values found in the surveys to values we want to replace with.\n    \"\"\"\n    COMPENSATION = {\n        '$0-999': '0-10k',\n        '1,000-1,999': '0-10k',\n        '2,000-2,999': '0-10k',\n        '3,000-3,999': '0-10k',\n        '4,000-4,999': '0-10k',\n        '5,000-7,499': '0-10k',\n        '7,500-9,999': '0-10k',\n        '10,000-14,999': '10-20k',\n        '15,000-19,999': '10-20k',\n        '20,000-24,999': '20-30k',\n        '25,000-29,999': '20-30k',\n        '30,000-39,999': '30-40k',\n        '40,000-49,999': '40-50k',\n        '50,000-59,999': '50-60k',\n        '60,000-69,999': '60-70k',\n        '70,000-79,999': '70-80k',\n        '80,000-89,999': '80-90k',\n        '90,000-99,999': '90-100k',\n        '100,000-124,999': '100-125k',\n        '125,000-149,999': '125-150k',\n        '150,000-199,999': '150-200k',\n        '200,000-249,999': '200-250k',\n        '300,000-500,000': '300-500k',\n        '> $500,000': '500-500k',\n        '0-10,000': '0-10k',\n        '10-20,000': '10-20k',\n        '20-30,000': '20-30k',\n        '30-40,000': '30-40k',\n        '40-50,000': '40-50k',\n        '50-60,000': '50-60k',\n        '60-70,000': '60-70k',\n        '70-80,000': '70-80k',\n        '80-90,000': '80-90k',\n        '90-100,000': '90-100k',\n        '100-125,000': '100-125k',\n        '125-150,000': '125-150k',\n        '150-200,00': '150-200k',\n        '200-250,000': '200-250k',\n        '300-400,000': '300-500k',\n        '400-500,000': '300-500k',\n        '500,000+': '500-500k',\n    }\n    JOB_TITLE = {\n        'Data Scientist': 'Data Scientist',\n        'Software Engineer': 'Software Engineer',\n        'Data Analyst': 'Data Analyst',\n        'Other': 'Other',\n        'Research Scientist': 'Research Scientist\/Statistician',\n        'Research Assistant': 'Research Scientist\/Statistician',\n        'Principal Investigator': 'Research Scientist\/Statistician',\n        'Business Analyst': 'Business Analyst',\n        'Marketing Analyst': 'Business Analyst',\n        'Product\/Project Manager': 'Product\/Project Manager',\n        'Program\/Project Manager': 'Program\/Project Manager',\n        'Product Manager': 'Program\/Project Manager',\n        'Data Engineer': 'Data Engineer\/DBA',\n        'Machine Learning Engineer': 'Machine Learning Engineer',\n        'Statistician': 'Research Scientist\/Statistician',\n        'Manager': 'Manager\/C-level',\n        'DBA\/Database Engineer': 'Data Engineer\/DBA',\n        'Chief Officer': 'Manager\/C-level',\n        'Consultant': 'Other',\n        'Salesperson': 'Other',\n        'Data Journalist': 'Other',\n        'Developer Advocate': 'Other',\n        'Developer Relations\/Advocacy': 'Other',\n        'Not employed': 'Currently not employed',\n        'Currently not employed': 'Currently not employed',\n        'Student': 'Student',\n    }\n    GENDER = {\n        'Male': 'Male',\n        'Female': 'Female',\n        'Man': 'Male',\n        'Woman': 'Female',\n    }\n    AGE = {\n        '18-21': '18-21',\n        '22-24': '22-24',\n        '25-29': '25-29',\n        '30-34': '30-34',\n        '35-39': '35-39',\n        '40-44': '40-44',\n        '45-49': '45-49',\n        '50-54': '50-54',\n        '55-59': '55-59',\n        '60-69': '60-69',\n        '70+': '70+',\n        '70-79': '70+',\n        '80+': '70+'\n    }\n    EDUCATION = {\n        'Master\u2019s degree': 'Master\u2019s',\n        'Bachelor\u2019s degree': 'Bachelor\u2019s',\n        'Some college\/university study without earning a bachelor\u2019s degree': 'College & below',\n        'Doctoral degree': 'Doctoral',\n        'Professional degree': 'Professional',\n        'Professional doctorate': 'Professional',\n        'No formal education past high school': 'College & below'\n    }\n    YEARS_WRITING_CODE = {\n        '< 1 years': '0-1 years',\n        '< 1 year': '0-1 years',\n        '1-2 years': '1-3 years',\n        '1-3 years': '1-3 years',\n        '3-5 years': '3-5 years',\n        '5-10 years': '5-10 years',\n        '10-20 years': '10+ years',\n        '20+ years': '10+ years',\n        '20-30 years': '10+ years',\n        '30-40 years': '10+ years',\n        '40+ years': '10+ years',\n    }\n    RECOMMENDED_LANGUAGE = {\n        'Python': 'Python',\n        'R': 'R',\n        'SQL': 'SQL',\n        'C++': 'C++',\n        'MATLAB': 'MATLAB',\n        'Other': 'Other',\n        'Java': 'Java',\n        'C': 'C',\n        'None': 'None',\n        'Javascript': 'Javascript',\n        'Julia': 'Julia',\n        'Scala': 'Other',\n        'SAS': 'Other',\n        'Bash': 'Bash',\n        'VBA': 'Other',\n        'Go': 'Other',\n        'Swift': 'Swift',\n        'TypeScript': 'Other'\n    }\n    LANGUAGES = {\n        'SQL': 'SQL',\n        'R': 'R',\n        'Java': 'Java',\n        'MATLAB': 'MATLAB',\n        'Python': 'Python',\n        'Javascript\/Typescript': 'Javascript\/Typescript',\n        'Bash': 'Bash',\n        'Visual Basic\/VBA': 'VBA',\n        'Scala': 'Scala',\n        'PHP': 'Other',\n        'C\/C++': 'C\/C++',\n        'Other': 'Other',\n        'C#\/.NET': 'Other',\n        'Go': 'Other',\n        'SAS\/STATA': 'Other',\n        'Ruby': 'Other',\n        'Julia': 'Julia',\n        'Javascript': 'Javascript\/Typescript',\n        'TypeScript': 'Javascript\/Typescript',\n        'C': 'C\/C++',\n        'C++': 'C\/C++',\n        'Swift': 'Swift'\n    }\n    YEARS_USING_ML = {\n        '< 1 year': '0-1 years',\n        '< 1 years': '0-1 years',\n        'Under 1 year': '0-1 years',\n        '1-2 years': '1-3 years',\n        '2-3 years': '1-3 years',\n        '3-4 years': '3-5 years',\n        '4-5 years': '3-5 years',\n        '5-10 years': '5-10 years',\n        '10-15 years': '10+ years',\n        '10-20 years': '10+ years',\n        '20+ years': '10+ years',\n        '20 or more years': '10+ years',\n    }\n    PRIMARY_TOOL = {\n        'Local development environments (RStudio, JupyterLab, etc.)': 'Local or hosted development environments',\n        'Basic statistical software (Microsoft Excel, Google Sheets, etc.)': 'Basic statistical software',\n        'Local or hosted development environments (RStudio, JupyterLab, etc.)': 'Local or hosted development environments',\n        'Cloud-based data software & APIs (AWS, GCP, Azure, etc.)': 'Cloud-based data software & APIs',\n        'Other': 'Other',\n        'Advanced statistical software (SPSS, SAS, etc.)': 'Advanced statistical software',\n        'Business intelligence software (Salesforce, Tableau, Spotfire, etc.)': 'Business intelligence software',\n        np.nan: 'None',\n    }\n    COUNTRY = {\n        'Other': 'Other',\n        'India': 'India',\n        'United States of America': 'United States',\n        'Brazil': 'Brazil',\n        'Japan': 'Japan',\n        'Russia': 'Russia',\n        'United Kingdom of Great Britain and Northern Ireland': 'United Kingdom',\n        'Germany': 'Germany',\n        'China': 'China',\n        'Spain': 'Spain',\n        'France': 'France',\n    }\n    IDE = {\n        'MATLAB': 'MATLAB',\n        'RStudio': 'RStudio',\n        'Jupyter\/IPython': 'Jupyter\/IPython',\n        'PyCharm': 'PyCharm',\n        'Atom': 'Vim\/Emacs\/Atom',\n        'Visual Studio': 'Visual Studio',\n        'Notepad++': 'Notepad++\/Sublime',\n        'Sublime Text': 'Notepad++\/Sublime',\n        'IntelliJ': 'PyCharm',\n        'Spyder': 'Spyder',\n        'Visual Studio Code': 'Visual Studio',\n        'Vim': 'Vim\/Emacs\/Atom',\n        'Other': 'Other',\n        'nteract': 'Other',\n        'Vim \/ Emacs': 'Vim\/Emacs\/Atom',\n        'Jupyter (JupyterLab, Jupyter Notebooks, etc)': 'Jupyter\/IPython',\n        'Jupyter Notebook': 'Jupyter\/IPython',\n        'Visual Studio \/ Visual Studio Code': 'Visual Studio',\n        'Visual Studio Code (VSCode)': 'Visual Studio',\n    }\n    CLOUD = {\n        'I have not used any cloud providers': \"None\",\n        'Microsoft Azure': 'Azure',\n        'Google Cloud Platform (GCP)': 'GCP',\n        'Amazon Web Services (AWS)': 'AWS',\n        'IBM Cloud': 'IBM\/Red Hat',\n        'Other': 'Other',\n        'Alibaba Cloud': 'Alibaba',\n        'Salesforce Cloud': 'Other',\n        'Red Hat Cloud': 'IBM\/Red Hat',\n        'VMware Cloud': 'Other',\n        'Alibaba Cloud': 'Alibaba',\n        'SAP Cloud': 'Other',\n        'IBM Cloud': 'IBM\/Red Hat',\n        'Oracle Cloud': 'Other',\n        'IBM Cloud \/ Red Hat': 'IBM\/Red Hat',\n        'Tencent Cloud': 'Other',\n    }\n    ML_FRAMEWORKS = {\n        'Prophet': 'Prophet',\n        'Scikit-Learn': 'Scikit-learn',\n        'Keras': 'Keras',\n        'TensorFlow': 'TensorFlow',\n        'Spark MLlib': 'Spark MLlib',\n        'Spark MLib': 'Spark MLlib',\n        'Xgboost': 'Xgboost',\n        'randomForest': 'Other',\n        'lightgbm': 'LightGBM',\n        'Caret': 'Caret',\n        'mlr': 'Other',\n        'PyTorch': 'PyTorch',\n        'Mxnet': 'Other',\n        'CNTK': 'Other',\n        'Caffe': 'Other',\n        'H20': 'H2O',\n        'catboost': 'CatBoost',\n        'Fastai': 'Fast.ai',\n        'Other': 'Other',\n        'Scikit-learn': 'Scikit-learn',\n        'RandomForest': 'Other',\n        'Xgboost': 'Xgboost',\n        'LightGBM': 'LightGBM',\n        'Fast.ai': 'Fast.ai',\n        'Tidymodels': 'Other',\n        'CatBoost': 'CatBoost',\n        'JAX': 'Other',\n        'Prophet': 'Prophet',\n        'H2O 3': 'H2O',\n        'MXNet': 'Other',\n        'PyTorch Lightning': 'PyTorch Lightning',\n        'Huggingface': 'Huggingface',\n    }\n    ML_STATUS = {\n        'No (we do not use ML methods)': 'Do not use ML \/ Do not know',\n        'I do not know': 'Do not use ML \/ Do not know',\n        'We recently started using ML methods (i.e., models in production for less than 2 years)': 'Recently started using ML',\n        'We have well established ML methods (i.e., models in production for more than 2 years)':  'Well established ML',\n        'We are exploring ML methods (and may one day put a model into production)': 'Exploring ML',\n        'We use ML methods for generating insights (but do not put working models into production)': 'Use ML for generating insights',\n        np.nan: 'Do not use ML \/ Do not know',\n    }\n    COURSES = {\n        \"Coursera\": \"Coursera\",\n        \"Udemy\": \"Udemy\",\n        \"DataCamp\": \"DataCamp\",\n        \"Kaggle Learn Courses\": \"Kaggle Learn\",\n        \"Kaggle Learn\": \"Kaggle Learn\",\n        \"Kaggle Courses (i.e. Kaggle Learn)\": \"Kaggle Learn\",\n        \"edX\": \"edX\",\n        \"University Courses (resulting in a university degree)\": \"University\",\n        \"Udacity\": \"Udacity\",\n        \"LinkedIn Learning\": \"Other\",\n        \"Fast.ai\": \"Other\",\n        \"Cloud-certification programs (direct from AWS, Azure, GCP, or similar)\": \"Other\",\n        \"Online University Courses\": \"Other\",\n        \"Fast.AI\": \"Other\",\n        \"DataQuest\": \"Other\",\n        \"developers.google.com\": \"Other\",\n        \"TheSchool.AI\": \"Other\",\n        \"Other\": \"Other\",\n    }\n    VIZ = {\n        'Matplotlib': 'Matplotlib',\n        'Seaborn': 'Seaborn',\n        'Ggplot \/ ggplot2': 'ggplot2',\n        'ggplot2': 'ggplot2',\n        'Plotly \/ Plotly Express': 'Plotly',\n        'Plotly': 'Plotly',\n        'Shiny': 'Shiny',\n        'Bokeh': 'Bokeh',\n        'D3': 'D3',\n        'D3 js': 'D3',\n        'D3.js': 'D3',\n        'Geoplotlib': 'Other',\n        'Leaflet \/ Folium': 'Other',\n        'Leaflet': 'Other',\n        'Altair': 'Other',\n        'Lattice': 'Other',\n        'Other': 'Other',\n    }\n    MEDIA = {\n        \"Kaggle (notebooks, forums, etc)\": \"Kaggle\",\n        \"Kaggle (forums, blog, social media, etc)\": \"Kaggle\",\n        \"Kaggle forums\": \"Kaggle\",\n        \"YouTube (Kaggle YouTube, Cloud AI Adventures, etc)\": \"YouTube\",\n        \"YouTube (Cloud AI Adventures, Siraj Raval, etc)\": \"YouTube\",\n        \"Siraj Raval YouTube Channel\": \"YouTube\",\n        \"Cloud AI Adventures (YouTube)\": \"YouTube\",\n        \"Blogs (Towards Data Science, Analytics Vidhya, etc)\": \"Blogs\",\n        \"Blogs (Towards Data Science, Medium, Analytics Vidhya, KDnuggets etc)\": \"Blogs\",\n        \"Medium Blog Posts\": \"Blogs\",\n        \"KDnuggets Blog\": \"Blogs\",\n        \"FastML Blog\": \"Blogs\",\n        \"Journal Publications (peer-reviewed journals, conference proceedings, etc)\": \"Journals\",\n        \"Journal Publications (traditional publications, preprint journals, etc)\": \"Journals\",\n        \"Journal Publications\": \"Journals\",\n        \"ArXiv & Preprints\": \"Journals\",\n        \"Email newsletters (Data Elixir, O'Reilly Data & AI, etc)\": \"Newsletters\",\n        \"O'Reilly Data Newsletter\": \"Newsletters\",\n        \"Slack Communities (ods.ai, kagglenoobs, etc)  \": \"Slack\",\n        \"Course Forums (forums.fast.ai, Coursera forums, etc)\": \"Course Forums\",\n        \"Course Forums (forums.fast.ai, etc)\": \"Course Forums\",\n        \"Fastai forums\": \"Course Forums\",\n        \"Reddit (r\/machinelearning, etc) \": \"Reddit\",\n        \"Reddit (r\/machinelearning, r\/datascience, etc)\": \"Reddit\",\n        \"Podcasts (Chai Time Data Science, O\u2019Reilly Data Show, etc) \": \"Podcasts\",\n        \"Podcasts (Chai Time Data Science, Linear Digressions, etc) \": \"Podcasts\",\n        \"The Data Skeptic Podcast\": \"Podcasts\",\n        \"Linear Digressions Podcast\": \"Podcasts\",\n        \"Partially Derivative Podcast\": \"Podcasts\",\n        \"None\/I do not know\": \"None\",\n    }\n\n\nclass BaseSurvey(ABC):\n    \"\"\"\n    Base class to handle cleaning and transformation of datasets from different years.\n    \"\"\"\n    def __init__(self) -> None:\n        self.df = None\n        self.non_professionals = [\"Student\", \"Currently not employed\", np.nan]\n        self.cols_to_rename = {}\n        self.questions_to_combine = []\n        self.survey_year = None\n\n    def rename_columns(self) -> None:\n        \"\"\"\n        Renames columns using mapping\n        \"\"\"\n        self.df.rename(columns=self.cols_to_rename, inplace=True)\n\n    @property\n    def questions_to_keep(self) -> List[str]:\n        \"\"\"\n        Select which questions we should keep in the dataframe using the mapping keys\n        \"\"\"\n        return list(self.cols_to_rename.keys())\n\n    def select_questions(self) -> pd.DataFrame:\n        \"\"\"\n        Selects only the relevant questions from each survey year\n        \"\"\"\n        self.df = self.df[self.questions_to_keep]\n        return self.df\n\n    @abstractmethod\n    def filter_question_columns(self, question: str) -> List[str]:\n        raise NotImplementedError\n\n    def remove_non_professionals(self) -> pd.DataFrame:\n        \"\"\"\n        Non-professionals were defined as students, unemployed and NaNs.\n        Also removed those who didn\"t disclose compensation.\n        \"\"\"\n        self.df = self.df[~self.df[\"Job Title\"].isin(self.non_professionals)]\n        return self.df\n\n    def combine_answers_into_list(self, question: str) -> pd.DataFrame:\n        \"\"\"\n        This function will create a new column in the dataframe adding\n        all answers to a list and removing nans and None.\n        \"\"\"\n        filtered_columns = self.filter_question_columns(question)\n        for c in filtered_columns:\n            self.df[c] = self.df[c].str.strip()\n        self.df[question] = self.df[filtered_columns].values.tolist()\n        self.df[question] = self.df[question].apply(\n            lambda lst: [x for x in lst if pd.notnull(x) and x != \"None\"])\n        return self.df\n\n    def batch_combine_answers_into_list(self) -> pd.DataFrame:\n        \"\"\"\n        Applies combine_answers_into_list to multiple columns\n        \"\"\"\n        for question in self.questions_to_combine:\n            self.combine_answers_into_list(question)\n        return self.df\n\n    def do_mapping(self, column: str, mapping: Mapping, fill: str = None) -> pd.DataFrame:\n        \"\"\"\n        Maps values to have same classes across all years\n        \"\"\"\n        self.df[column] = self.df[column].map(mapping.value)\n        if fill is not None:\n            self.df[column] = self.df[column].fillna(fill)\n        return self.df\n\n    def do_list_mapping(self, column: str, mapping: Mapping) -> pd.DataFrame:\n        \"\"\"\n        Maps values to have same classes across all years\n        for columns that are list type\n        \"\"\"\n        def _clean_list(lst):\n            new_lst = set()\n            for x in lst:\n                if mapping.value.get(x):\n                    if mapping.value[x] != \"None\":\n                        new_lst.add(mapping.value[x])\n                else:\n                    new_lst.add(\"Other\")\n            return list(new_lst)\n\n        self.df[column] = self.df[column].apply(_clean_list)\n        return self.df\n\n    def add_numeric_average_compensation(self) -> pd.DataFrame:\n        \"\"\"\n        Create a numeric value for compensation in thousand of dollars,\n        taking the average between the max and min values for each class\n\n        We are summing up the lowest and highest value for each category,\n        and then dividing by 2.\n        Some regex needed to clean the text\n        \"\"\"\n        compensation = (\n            self.df[\"Compensation\"]\n            .str.replace(r\"(?:(?!\\d|\\-).)*\", \"\", regex=True)\n            .str.split(\"-\")\n        )\n        self.df[\"Compensation Value\"] = compensation.apply(\n            lambda x: (int(x[0]) + int(x[1])) \/ 2 if x == x else x)\n        return self.df\n\n    def add_survey_year_column(self) -> pd.DataFrame:\n        \"\"\"\n        Adds the year the survey was taken\n        \"\"\"\n        self.df[\"Survey Year\"] = self.survey_year\n        return self.df\n\n    @staticmethod\n    def _get_profile(values: tuple) -> str:\n        years_code, years_ml = values\n        if (\n            years_code in [\"0-1 years\", \"1-3 years\"]\n            and years_ml in [\"0-1 years\", \"1-3 years\"]\n        ):\n            return \"Beginners\"\n        elif (\n            years_code in [\"3-5 years\", \"5-10 years\"]\n            and years_ml in [\"3-5 years\", \"5-10 years\"]\n        ):\n            return \"Modern DS\"\n        elif (\n            years_code == \"10+ years\"\n            and years_ml in [\"0-1 years\", \"1-3 years\"]\n        ):\n            return \"Coders\"\n        elif (\n            years_code == \"10+ years\"\n            and years_ml == \"10+ years\"\n        ):\n            return \"ML Veterans\"\n        return \"Others\"\n\n    def create_profiles(self) -> None:\n        \"\"\"\n        This function creates a new column with profiles for professionals\n        adapted from the work developed by Teresa Kubacka on last years survey\n        https:\/\/www.kaggle.com\/tkubacka\/a-story-told-through-a-heatmap\n        \"\"\"\n        self.df[\"Profile\"] = self.df[[\"Years Writing Code\", \"Years Using ML\"]].apply(\n            self._get_profile, axis=1)\n\n    def transform(self) -> pd.DataFrame:\n        \"\"\"\n        Process and clean the dataset\n        \"\"\"\n        self.df.drop(0, axis=0, inplace=True)\n\n        self.batch_combine_answers_into_list()\n        self.select_questions()\n        self.rename_columns()\n        self.remove_non_professionals()\n    \n        self.do_mapping(column=\"Compensation\", mapping=Mapping.COMPENSATION)\n        self.do_mapping(column=\"Gender\", mapping=Mapping.GENDER)\n        self.do_mapping(column=\"Education\", mapping=Mapping.EDUCATION)\n        self.df.dropna(subset=[\"Compensation\", \"Gender\", \"Education\"], inplace=True)\n        self.df.reset_index(drop=True, inplace=True)\n\n        self.do_mapping(column=\"Age\", mapping=Mapping.AGE)\n        self.do_mapping(column=\"Country\", mapping=Mapping.COUNTRY, fill=\"Other\")\n        self.do_mapping(column=\"Job Title\", mapping=Mapping.JOB_TITLE)\n        self.do_mapping(column=\"Years Writing Code\", mapping=Mapping.YEARS_WRITING_CODE, fill=\"None\")\n        self.do_mapping(column=\"Recommended Language\", mapping=Mapping.RECOMMENDED_LANGUAGE, fill=\"None\")\n        self.do_mapping(column=\"Years Using ML\", mapping=Mapping.YEARS_USING_ML, fill=\"None\")\n        self.do_mapping(column=\"Primary Tool\", mapping=Mapping.PRIMARY_TOOL)\n        self.do_mapping(column=\"ML Status in Company\", mapping=Mapping.ML_STATUS)\n\n        self.do_list_mapping(column=\"Languages\", mapping=Mapping.LANGUAGES)\n        self.do_list_mapping(column=\"IDEs\", mapping=Mapping.IDE)\n        self.do_list_mapping(column=\"Data Visualization Libraries\", mapping=Mapping.VIZ)\n        self.do_list_mapping(column=\"ML Frameworks\", mapping=Mapping.ML_FRAMEWORKS)\n        self.do_list_mapping(column=\"Cloud Computing Platforms\", mapping=Mapping.CLOUD)\n        self.do_list_mapping(column=\"Data Science Courses\", mapping=Mapping.COURSES)\n        self.do_list_mapping(column=\"Media Sources\", mapping=Mapping.MEDIA)\n\n        self.create_profiles()\n        self.add_numeric_average_compensation()\n        self.add_survey_year_column()\n        return self.df\n\n\nclass Survey2021(BaseSurvey):\n    \"\"\"\n    Processing and cleaning 2021 Dataset\n    \"\"\"\n    def __init__(self) -> None:\n        BaseSurvey.__init__(self)\n        self.survey_year = 2021\n        self.df = pd.read_csv(\"\/kaggle\/input\/kaggle-survey-2021\/kaggle_survey_2021_responses.csv\", low_memory=False)\n        self.cols_to_rename = {\n            \"Q1\": \"Age\",\n            \"Q2\": \"Gender\",\n            \"Q3\": \"Country\",\n            \"Q4\": \"Education\",\n            \"Q5\": \"Job Title\",\n            \"Q6\": \"Years Writing Code\",\n            \"Q7\": \"Languages\",\n            \"Q8\": \"Recommended Language\",\n            \"Q9\": \"IDEs\",\n            \"Q10\": \"Hosted Notebooks\",\n            \"Q14\": \"Data Visualization Libraries\",\n            \"Q15\": \"Years Using ML\",\n            \"Q16\": \"ML Frameworks\",\n            \"Q23\": \"ML Status in Company\",\n            \"Q24\": \"Daily activities\",\n            \"Q25\": \"Compensation\",\n            \"Q27_A\": \"Cloud Computing Platforms\",\n            \"Q28_A\": \"Cloud Computing Products\",\n            \"Q31_A\": \"ML Products\",\n            \"Q32_A\": \"Big Data Products\",\n            \"Q40\": \"Data Science Courses\",\n            \"Q41\": \"Primary Tool\",\n            \"Q42\": \"Media Sources\",\n        }\n        self.questions_to_combine = [\n            \"Q7\", \"Q9\", \"Q10\", \"Q14\", \"Q16\", \"Q24\", \"Q27_A\", \"Q28_A\", \"Q31_A\", \"Q32_A\", \"Q40\", \"Q42\"\n        ]\n\n    def filter_question_columns(self, question: str) -> List[str]:\n        \"\"\"\n        Filters only questions that starts with the question_number\n        and do not end with the string _OTHER\n        \"\"\"\n        return [\n            col for col in self.df.columns\n            if col.startswith(f\"{question}_P\")\n            and not col.endswith(\"_OTHER\")\n        ]\n\n\nclass Survey2020(BaseSurvey):\n    \"\"\"\n    Processing and cleaning 2020 Dataset\n    \"\"\"\n    def __init__(self) -> None:\n        BaseSurvey.__init__(self)\n        self.survey_year = 2020\n        self.df = pd.read_csv(\"\/kaggle\/input\/kaggle-survey-2020\/kaggle_survey_2020_responses.csv\", low_memory=False)\n        self.cols_to_rename = {\n            \"Q1\": \"Age\",\n            \"Q2\": \"Gender\",\n            \"Q3\": \"Country\",\n            \"Q4\": \"Education\",\n            \"Q5\": \"Job Title\",\n            \"Q6\": \"Years Writing Code\",\n            \"Q7\": \"Languages\",\n            \"Q8\": \"Recommended Language\",\n            \"Q9\": \"IDEs\",\n            \"Q10\": \"Hosted Notebooks\",\n            \"Q14\": \"Data Visualization Libraries\",\n            \"Q15\": \"Years Using ML\",\n            \"Q16\": \"ML Frameworks\",\n            \"Q22\": \"ML Status in Company\",\n            \"Q23\": \"Daily activities\",\n            \"Q24\": \"Compensation\",\n            \"Q26_A\": \"Cloud Computing Platforms\",\n            \"Q27_A\": \"Cloud Computing Products\",\n            \"Q28_A\": \"ML Products\",\n            \"Q29_A\": \"Big Data Products\",\n            \"Q37\": \"Data Science Courses\",\n            \"Q38\": \"Primary Tool\",\n            \"Q39\": \"Media Sources\",\n        }\n        self.questions_to_combine = [\n            \"Q7\", \"Q9\", \"Q10\", \"Q14\", \"Q16\", \"Q23\", \"Q26_A\", \"Q27_A\", \"Q28_A\", \"Q29_A\", \"Q37\", \"Q39\"\n        ]\n\n    def filter_question_columns(self, question: str) -> List[str]:\n        \"\"\"\n        Filters only questions that starts with the question_number\n        and do not end with the string _OTHER\n        \"\"\"\n        return [\n            col for col in self.df.columns\n            if col.startswith(f\"{question}_P\")\n            and not col.endswith(\"_OTHER\")\n        ]\n\n\nclass Survey2019(BaseSurvey):\n    \"\"\"\n    Processing and cleaning 2019 Dataset\n    \"\"\"\n    def __init__(self) -> None:\n        BaseSurvey.__init__(self)\n        self.survey_year = 2019\n        self.df = pd.read_csv(\"\/kaggle\/input\/kaggle-survey-2019\/multiple_choice_responses.csv\", low_memory=False)\n        self.cols_to_rename = {\n            \"Q1\": \"Age\",\n            \"Q2\": \"Gender\",\n            \"Q3\": \"Country\",\n            \"Q4\": \"Education\",\n            \"Q5\": \"Job Title\",\n            \"Q15\": \"Years Writing Code\",\n            \"Q18\": \"Languages\",\n            \"Q19\": \"Recommended Language\",\n            \"Q16\": \"IDEs\",\n            \"Q17\": \"Hosted Notebooks\",\n            \"Q20\": \"Data Visualization Libraries\",\n            \"Q23\": \"Years Using ML\",\n            \"Q28\": \"ML Frameworks\",\n            \"Q8\": \"ML Status in Company\",\n            \"Q9\": \"Daily activities\",\n            \"Q10\": \"Compensation\",\n            \"Q29\": \"Cloud Computing Platforms\",\n            \"Q30\": \"Cloud Computing Products\",\n            \"Q32\": \"ML Products\",\n            \"Q31\": \"Big Data Products\",\n            \"Q13\": \"Data Science Courses\",\n            \"Q14\": \"Primary Tool\",\n            \"Q12\": \"Media Sources\",\n        }\n        self.questions_to_combine = [\n            \"Q18\", \"Q16\", \"Q17\", \"Q20\", \"Q28\", \"Q9\", \"Q29\", \"Q30\", \"Q32\", \"Q31\", \"Q13\", \"Q12\"\n        ]\n\n    def filter_question_columns(self, question: str) -> List[str]:\n        \"\"\"\n        Filters only questions that starts with the question_number\n        and do not end with the string _OTHER_TEXT\n        \"\"\"\n        return [\n            col for col in self.df.columns\n            if col.startswith(f\"{question}_P\")\n            and not col.endswith(\"_OTHER_TEXT\")\n        ]\n\n\nclass Survey2018(BaseSurvey):\n    \"\"\"\n    Processing and cleaning 2018 Dataset\n    \"\"\"\n    def __init__(self) -> None:\n        BaseSurvey.__init__(self)\n        self.survey_year = 2018\n        self.df = pd.read_csv(\"\/kaggle\/input\/kaggle-survey-2018\/multipleChoiceResponses.csv\", low_memory=False)\n        self.cols_to_rename = {\n            \"Q2\": \"Age\",\n            \"Q1\": \"Gender\",\n            \"Q3\": \"Country\",\n            \"Q4\": \"Education\",\n            \"Q6\": \"Job Title\",\n            \"Q24\": \"Years Writing Code\",\n            \"Q16\": \"Languages\",\n            \"Q18\": \"Recommended Language\",\n            \"Q13\": \"IDEs\",\n            \"Q14\": \"Hosted Notebooks\",\n            \"Q21\": \"Data Visualization Libraries\",\n            \"Q25\": \"Years Using ML\",\n            \"Q19\": \"ML Frameworks\",\n            \"Q10\": \"ML Status in Company\",\n            \"Q11\": \"Daily activities\",\n            \"Q9\": \"Compensation\",\n            \"Q15\": \"Cloud Computing Platforms\",\n            \"Q27\": \"Cloud Computing Products\",\n            \"Q28\": \"ML Products\",\n            \"Q30\": \"Big Data Products\",\n            \"Q36\": \"Data Science Courses\",\n            \"Q12_MULTIPLE_CHOICE\": \"Primary Tool\",\n            \"Q38\": \"Media Sources\",\n        }\n        self.questions_to_combine = [\n            \"Q16\", \"Q13\", \"Q14\", \"Q21\", \"Q19\", \"Q11\", \"Q15\", \"Q27\", \"Q28\", \"Q30\", \"Q36\", \"Q38\"\n        ]\n\n    def filter_question_columns(self, question: str) -> List[str]:\n        \"\"\"\n        Filters only questions that starts with the question_number\n        and do not end with the string _OTHER_TEXT\n        \"\"\"\n        return [\n            col for col in self.df.columns\n            if col.startswith(f\"{question}_P\")\n            and not col.endswith(\"_OTHER_TEXT\")\n        ]\n\n\nclass CombinedSurvey:\n    \"\"\"\n    This class combines surveys from multiple years into a concatenated dataframe.\n    \"\"\"\n    def __init__(self, surveys=[Survey2018, Survey2019, Survey2020, Survey2021]) -> None:\n        self.surveys = surveys\n        self._cached_df = None\n\n    @property\n    def df(self) -> pd.DataFrame:\n        \"\"\"\n        If df was already processed get it from cache, otherwise process it and saves to cache.\n        \"\"\"\n        if isinstance(self._cached_df, type(None)):\n            self._cached_df = self._concat_surveys()\n        return self._cached_df\n\n    def _concat_surveys(self) -> List[pd.DataFrame]:\n        \"\"\"\n        Applies the transform method for each survey and return the dfs in a list\n        \"\"\"\n        return pd.concat([survey().transform() for survey in self.surveys], ignore_index=True)","bfa37010":"from typing import List\n\nimport pandas as pd\nimport plotly.graph_objects as go\nimport plotly.offline as pyo\nfrom plotly.subplots import make_subplots\nfrom collections import namedtuple\n\nCATEGORIES = {\n    \"Survey Year\": [2018, 2019, 2020, 2021],\n    \"Job Title\": [\n        \"Other\", \"Manager\/C-level\", \"Product\/Project Manager\",\n        \"Business Analyst\", \"Data Analyst\",\n        \"Research Scientist\/Statistician\",\n        \"Data Scientist\", \"Machine Learning Engineer\",\n        \"Data Engineer\/DBA\", \"Software Engineer\"\n    ],\n    \"Gender\": [\"Male\", \"Female\"],\n    \"Age\": [\n        \"18-21\", \"22-24\", \"25-29\", \"30-34\", \"35-39\", \"40-44\",\n        \"45-49\", \"50-54\", \"55-59\", \"60-69\", \"70+\"\n    ],\n    \"Years Writing Code\": [\n        \"None\", \"0-1 years\", \"1-3 years\", \"3-5 years\", \"5-10 years\", \"10+ years\"\n    ],\n    \"Years Using ML\": [\n        \"None\", \"0-1 years\", \"1-3 years\", \"3-5 years\", \"5-10 years\", \"10+ years\"\n    ],\n    \"Education\": [\n        \"College & below\", \"Professional\",\n        \"Bachelor\u2019s\", \"Master\u2019s\", \"Doctoral\"\n    ],\n    \"Profile\": [\"Others\", \"Beginners\", \"Modern DS\", \"Coders\", \"ML Veterans\"],\n}\n\n\nCOLORS = {\n    \"Average\": \"#1f77b4\",\n    \"None\": \"darkblue\",\n\n    \"Female\": \"#ff9896\",\n    \"Male\": \"#1f77b4\",\n\n    \"22-24\": \"#FE9933\",\n    \"40-44\": \"#179B3A\",\n\n    \"Data Scientist\": \"#13A4B4\",\n    \"Product\/Project Manager\": \"#D70947\",\n    \"Software Engineer\": \"#E8743B\",\n    \"Data Analyst\": \"#BF399E\",\n    \"Data Engineer\/DBA\": \"#144B7F\",\n\n    \"0-1 years\": \"#98df8a\",\n    \"10+ years\": \"#2ca02c\",\n\n    \"Python\": \"#17becf\",\n    \"SQL\": \"#ff9896\",\n    \"R\": \"#bcbd22\",\n\n    \"Scikit-learn\": \"#bcbd22\",\n    \"TensorFlow\": \"#d62728\",\n    \"Keras\": \"#ff9896\",\n    \"PyTorch\": \"#1f77b4\",\n\n    \"Matplotlib\": \"#bcbd22\",\n    \"Seaborn\": \"#2ca02c\",\n\n    \"AWS\": \"#F79500\",\n    \"GCP\": \"#1AA746\",\n    \"Azure\": \"#3278B1\",\n\n    \"Jupyter\/IPython\": \"#EC7426\",\n    \"Visual Studio\": \"#349FED\",\n    \"RStudio\": \"#ff9896\",\n\n    \"Coursera\": \"#F79500\",\n    \"Kaggle Learn\": \"#1AA746\",\n\n    \"Journals\": \"#F79500\",\n    \"Kaggle\": \"#1AA746\",\n\n    \"Basic statistical software\": \"#0D7036\",\n    \"Local or hosted development environments\": \"#36B5E2\",\n    \n    \"Well established ML\": \"dodgerblue\",\n    \"Do not use ML \/ Do not know\": \"slategrey\",\n    \"Exploring ML\": \"lightseagreen\",\n    \"Recently started using ML\": \"forestgreen\"\n}\n\n\nMetricData = namedtuple(\n    \"MetricData\",\n    [\n        \"subplot_name\", \"trace_name\", \"y_values\", \"x_values\",\n        \"subplot_col\", \"subplot_row\", \"highlighted_traces\",\n    ]\n)\n\n_STYLE = {\n    \"Change\": {\n        \"ytitle\": \"Change in Avg Annual Compensation\",\n        \"yticks\": [-0.5, -0.25, 0, 0.25, 0.5],\n        \"yticks_template\": \"{:.0%}\",\n        \"hover_template\": \"%{y:.1%}\",\n        \"annotation_template\": \"{:.1%}\",\n        \"annotation_mode\": 0,\n    },\n    \"Compensation Value\": {\n        \"ytitle\": \"Avg Annual Compensation USD\",\n        \"yticks\": [20, 40, 60],\n        \"yticks_template\": \"${}K\",\n        \"hover_template\": \"$%{y:.1f}K\",\n        \"annotation_template\": \"${:.1f}K\",\n        \"annotation_mode\": 1,\n    },\n    \"Prop\": {\n        \"ytitle\": \"% Respondents\",\n        \"yticks\": [0, 0.2, 0.4, 0.6, 0.8],\n        \"yticks_template\": \"{:.0%}\",\n        \"hover_template\": \"%{y:.1%}\",\n        \"annotation_template\": \"{:.1%}\",\n        \"annotation_mode\": 2,\n    },\n}\n\n\ndef compute_prop(df, column, color, items):\n    source = []\n    for i in items:\n        _df = df[['Survey Year', column]].copy()\n        if i == \"None\":\n            _df[i] = df[color].apply(lambda lst: not lst).astype(int)\n        else:\n            _df[i] = df[color].apply(lambda lst: i in lst).astype(int)\n\n        _agg_df = _df.groupby(['Survey Year', column], as_index=False)[i].sum()\n        _agg_df.rename(columns={i: \"Count\"}, inplace=True)\n        _agg_df[color] = i\n        source.append(_agg_df)\n    source = pd.concat(source, ignore_index=True)\n\n    _df1 = df.groupby(['Survey Year', column], as_index=False).size()\n    _df1.rename(columns={\"size\": \"Total\"}, inplace=True)\n    source = pd.merge(source, _df1, on=['Survey Year', column])\n    source[\"Prop\"] = source[\"Count\"] \/ source[\"Total\"]\n    return source\n\n\ndef _to_categorical(df: pd.DataFrame, col: str) -> pd.DataFrame:\n    df[col] = df[col].apply(lambda x: x if x in CATEGORIES[col] else \"Other\")\n    cat_dtype = pd.api.types.CategoricalDtype(\n        categories=CATEGORIES[col], ordered=True)\n    df[col] = df[col].astype(cat_dtype)\n    return df\n\n\nclass LinePlot:\n    \"\"\"\n    Creates a plotly plot\n    \"\"\"\n    def __init__(\n        self,\n        df: pd.DataFrame,\n        x: str,\n        y: str,\n        column: str,\n        color: str,\n        title: str,\n        ytitle: str = None,\n        yticks: List[float] = None,\n        yticks_template: str = None,\n        hover_template: str = None,\n        annotation_template: str = None,\n        annotation_mode: int = 0,\n        x_nticks: int = 3,\n        shared_yaxes: bool = True,\n        highlighted_traces: list = [],\n    ) -> None:\n        pyo.init_notebook_mode()\n\n        df = _to_categorical(df, x)\n        df = _to_categorical(df, column)\n\n        self.df = df\n        self.x = x\n        self.y = y\n        self.column = column\n        self.color = color\n        self.title = title\n\n        self.ytitle = ytitle or _STYLE[y][\"ytitle\"]\n        self.yticks = yticks or _STYLE[y][\"yticks\"]\n        self.yticks_template = yticks_template or _STYLE[y][\"yticks_template\"]\n        self.hover_template = hover_template or _STYLE[y][\"hover_template\"]\n        self.annotation_template = annotation_template or _STYLE[y][\"annotation_template\"]\n        self.annotation_mode = annotation_mode or _STYLE[y][\"annotation_mode\"]\n\n        self.x_nticks = x_nticks\n        self.shared_yaxes = shared_yaxes\n        self.highlighted_traces = highlighted_traces\n\n        self.subplots_names = CATEGORIES[self.column]\n        self.n_subplots = len(self.subplots_names)\n        self.traces = self.get_traces()\n\n        self.figure = go.Figure()\n        self.range = (0, 0)\n\n    def get_traces(self):\n        self.df[\"subplot_row\"] = 1\n        self.df[\"subplot_col\"] = self.df[self.column].cat.codes + 1\n\n        lst = []\n        for _, row in self.df.iterrows():\n            filtered_df = self.df[self.df[self.column] == row[self.column]]\n            filtered_df = filtered_df[filtered_df[self.color] == row[self.color]]\n\n            metric_data = MetricData(\n                subplot_name=row[self.column],\n                trace_name=row[self.color],\n                y_values=filtered_df[self.y].values,\n                x_values=filtered_df[self.x].values,\n                subplot_row=row[\"subplot_row\"],\n                subplot_col=row[\"subplot_col\"],\n                highlighted_traces=row[self.color] in self.highlighted_traces\n            )\n            lst.append(metric_data)\n        return lst\n\n    def make_subplots(self) -> None:\n        \"\"\"\n        Creates subplots in the figure and add titles\n        \"\"\"\n        self.figure = make_subplots(\n            cols=self.n_subplots,\n            rows=1,\n            subplot_titles=self.subplots_names,\n            specs=[[{\"type\": \"scatter\"}] * self.n_subplots],\n            shared_yaxes=self.shared_yaxes,\n            shared_xaxes=True\n        )\n\n        for idx, subplot_title in enumerate(self.figure[\"layout\"][\"annotations\"]):\n            subplot_title[\"font\"] = dict(size=14, color=\"grey\")\n            subplot_title[\"align\"] = \"left\"\n            subplot_title[\"xanchor\"] = \"left\"\n            subplot_title[\"x\"] = 0\n            subplot_title[\"xref\"] = \"x\" if idx == 0 else f\"x{idx + 1}\"\n\n    def update_common_layout(self) -> None:\n        \"\"\"\n        Updates general layout characteristics\n        \"\"\"\n        self.figure.update_layout(\n            showlegend=False,\n            plot_bgcolor=\"white\",\n            title_text=self.title,\n            title_font_size=15,\n            margin_t=200,\n            height=600,\n            width=800,\n            yaxis_range=self.range\n        )\n\n    def highlight_color(self, trace: MetricData) -> str:\n        \"\"\"\n        Returns the highlight color\n        \"\"\"\n        return COLORS[trace.trace_name]\n\n    def add_data(self) -> None:\n        \"\"\"\n        Adds a trace to the figure following the same standard for each trace\n        \"\"\"\n        # Add all non-highlighted traces.\n        for trace in self.traces:\n            self.add_trace(trace=trace)\n            self.update_range(data=trace.y_values)\n\n    def add_trace(self, trace: MetricData) -> None:\n        \"\"\"\n        Adds a new trace to a figure\n        \"\"\"\n        self.figure.add_trace(\n            go.Scatter(\n                x=trace.x_values,\n                y=trace.y_values,\n                mode=\"lines\",\n                name=trace.trace_name,\n                hoverinfo=\"name+text+y\",\n                hovertemplate=self.hover_template,\n                text=trace.x_values,\n                line_color=(\n                    self.highlight_color(trace=trace) if trace.highlighted_traces\n                    else \"lightslategrey\"\n                ),\n                showlegend=False,\n                opacity=0.8 if trace.highlighted_traces else 0.25,\n                line_shape=\"linear\",\n                line_width=1.6 if trace.highlighted_traces else 0.6,\n                connectgaps=True\n            ),\n            trace.subplot_row,\n            trace.subplot_col\n        )\n\n    def update_range(self, data: List[float]) -> None:\n        \"\"\"\n        Updates the range to be 90% of minimum values and 110% of maximum value of all traces\n        \"\"\"\n        if len(data) == 0:\n            return\n\n        max_range = max(data) * 1.2\n        min_range = min(data) * 0.8\n        self.range = (min(min_range, self.range[0]), max(max_range, self.range[1]))\n\n    def get_annotation_text(self, trace: MetricData, idx: int) -> str:\n        \"\"\"\n        Calculates the annotation text to be added to the plot\n        \"\"\"\n        if (\n            (trace.subplot_col == 1 and idx == 0)\n            or self.annotation_mode == 3\n        ):\n            template = \"{}<br>\" + f\"{self.annotation_template}\"\n            return template.format(trace.trace_name, trace.y_values[idx])\n        else:\n            return self.annotation_template.format(trace.y_values[idx])\n\n    def _add_annotation(\n        self, trace: MetricData, idx: int,\n        xshift=None, xanchor=None, yshift=None, yanchor=None,\n        text=None,\n    ) -> None:\n        \"\"\"\n        Adds annotation to the plot\n        \"\"\"\n        self.figure.add_annotation(\n            xref=f\"x{trace.subplot_col}\",\n            yref=f\"y{trace.subplot_col}\",\n            font=dict(\n                size=11,\n                color=self.highlight_color(trace=trace)\n            ),\n            opacity=0.8,\n            align=\"right\",\n            xshift=xshift,\n            xanchor=xanchor,\n            yshift=yshift,\n            yanchor=yanchor,\n            x=trace.x_values.codes[idx],\n            y=trace.y_values[idx],\n            text=text if text is not None else self.get_annotation_text(trace=trace, idx=idx),\n            showarrow=False\n        )\n\n    def add_annotations(self) -> None:\n        \"\"\"\n        Adds annotations to the plot\n        \"\"\"\n        if self.annotation_mode == 0:\n            for trace in self.traces:\n                if trace.highlighted_traces:\n                    self._add_annotation(trace, -1, xshift=3, yshift=0, xanchor=\"right\", yanchor=\"bottom\")\n        elif self.annotation_mode == 1:\n            for trace in self.traces:\n                if trace.highlighted_traces:\n                    self._add_annotation(\n                        trace, 0, xshift=0, yshift=8, xanchor=\"left\", yanchor=\"bottom\")\n                    self._add_annotation(\n                        trace, -1, xshift=3, yshift=-8, xanchor=\"right\", yanchor=\"top\")\n        elif self.annotation_mode == 2:\n            for trace in self.traces:\n                if trace.highlighted_traces:\n                    if trace.subplot_col == 1:\n                        self._add_annotation(\n                            trace, 0, xshift=0, yshift=5, xanchor=\"left\", yanchor=\"bottom\",\n                            text=trace.trace_name)\n        elif self.annotation_mode == 3:\n            for trace in self.traces:\n                if trace.highlighted_traces:\n                    self._add_annotation(trace, 0, xshift=-3, yshift=0, xanchor=\"right\")\n                    self._add_annotation(trace, -1, xshift=3, yshift=0, xanchor=\"left\")\n        else:\n            raise NotImplementedError\n\n    def add_subplot_axis_annotation(self) -> None:\n        \"\"\"\n        Add subplot axis annotation\n        \"\"\"\n        self.figure.add_annotation(\n            xref=\"x\",\n            yref=\"paper\",\n            font=dict(\n                size=14,\n                # color=\"lightgrey\"\n            ),\n            align=\"left\",\n            x=0,\n            xanchor=\"left\",\n            y=1.05,\n            yanchor=\"bottom\",\n            text=f\"{self.column}\",\n            showarrow=False\n        )\n\n    def update_subplots_layout(self) -> None:\n        \"\"\"\n        Updates scatter subplots layout characteristics\n        \"\"\"\n        for subplot_idx in range(self.n_subplots):\n            self.figure.update_xaxes(\n                type=\"category\",\n                color=\"lightgrey\",\n                showgrid=False,\n                visible=subplot_idx == 0,  # Visible only for first subplot\n                row=1,\n                dtick=3,\n                col=subplot_idx + 1,  # 1-based\n            )\n            self.figure.update_yaxes(\n                showgrid=False,\n                visible=subplot_idx == 0 or not self.shared_yaxes,\n                title=self.ytitle if subplot_idx == 0 else None,\n                # color=\"grey\",\n                row=1,\n                col=subplot_idx + 1,\n                tickvals=self.yticks,\n                ticktext=[self.yticks_template.format(i) for i in self.yticks],\n                tickmode=\"array\",\n                tickfont_color=\"lightgrey\",\n                autorange=True\n            )\n\n    def show(self) -> None:\n        \"\"\"\n        Renders and shows the plot\n        \"\"\"\n        self.make_subplots()\n        self.update_common_layout()\n        self.add_data()\n        self.add_annotations()\n        self.add_subplot_axis_annotation()\n        self.update_subplots_layout()\n        self.figure.show()\n","63048f4c":"combined_survey = CombinedSurvey()\ndf = combined_survey.df\nprint(df.shape)\n\nbase_year = 2018\nx = \"Survey Year\"","1b715b3f":"column = \"Gender\"\ncolor = \"Country\"\nvalue = \"Compensation Value\"\n\ndf1 = df.groupby([x, column, color], as_index=False)[value].mean()\ndf2 = df.groupby([x, column], as_index=False)[value].mean()\ndf2[color] = \"Average\"\ndf1 = pd.concat([df1, df2], ignore_index=True)\n\n_df1 = df1[df1[x] == base_year][[column, color, value]].copy()\nbase_col = f\"{value} {base_year}\"\n_df1.rename(columns={value: base_col}, inplace=True)\nsource = pd.merge(df1, _df1, on=[column, color])\nsource[\"Change\"] = source[value] \/ source[base_col] - 1","ba0e47bb":"LinePlot(\n    df=source,\n    x=x,\n    y=\"Change\",\n    column=column,\n    color=color,\n    highlighted_traces=[\"Average\"],\n    title=(\n        \"\"\"\n        <b>Average annual compensation decreases across the board in 2021 during the pandemic.<\/b>\n        <br>The drop seems to be more severe for women.\n        <br><span style=\"font-size:14px;color:grey\"><i>Base Year=2018<\/i><\/span>\n        \"\"\"\n    ),\n).show()","4b6559a7":"column = \"Gender\"\ncolor = \"Age\"\nvalue = \"Compensation Value\"\n\ndf1 = df.groupby([x, column, color], as_index=False)[value].mean()\n\n_df1 = df1[df1[x] == base_year][[column, color, value]].copy()\nbase_col = f\"{value} {base_year}\"\n_df1.rename(columns={value: base_col}, inplace=True)\nsource = pd.merge(df1, _df1, on=[column, color])\nsource[\"Change\"] = source[value] \/ source[base_col] - 1","e8081c93":"LinePlot(\n    df=source,\n    x=x,\n    y=\"Change\",\n    column=column,\n    color=color,\n    highlighted_traces=[\"22-24\", \"40-44\"],\n    title=(\n        \"\"\"\n        <b>The younger age group suffers a bigger reduction in pay regardless of gender.<\/b>\n        <br><span style=\"font-size:14px;color:grey\"><i>Base Year=2018<\/i><\/span>\n        \"\"\"\n    ),\n).show()","912d8ffb":"column = \"Education\"\ncolor = \"Gender\"\nvalue = \"Compensation Value\"\n\ndf1 = df.groupby([x, column, color], as_index=False)[value].mean()\n\n_df1 = df1[df1[x] == base_year][[column, color, value]].copy()\nbase_col = f\"{value} {base_year}\"\n_df1.rename(columns={value: base_col}, inplace=True)\nsource = pd.merge(df1, _df1, on=[column, color])\nsource[\"Change\"] = source[value] \/ source[base_col] - 1","310eec37":"LinePlot(\n    df=source,\n    x=x,\n    y=\"Change\",\n    column=column,\n    color=color,\n    highlighted_traces=[\"Female\", \"Male\"],\n    title=(\n        \"\"\"\n        <b>Most women saw bigger reduction in pay during the pandemic across education groups.<\/b>\n        <br><span style=\"font-size:14px;color:grey\"><i>Base Year=2018<\/i><\/span>\n        \"\"\"\n    ),\n).show()","4420ec14":"column = \"Profile\"\ncolor = \"Gender\"\nvalue = \"Compensation Value\"\n\ndf1 = df.groupby([x, column, color], as_index=False)[value].mean()\n\n_df1 = df1[df1[x] == base_year][[column, color, value]].copy()\nbase_col = f\"{value} {base_year}\"\n_df1.rename(columns={value: base_col}, inplace=True)\nsource = pd.merge(df1, _df1, on=[column, color])\nsource[\"Change\"] = source[value] \/ source[base_col] - 1","d4405f7d":"LinePlot(\n    df=source,\n    x=x,\n    y=\"Change\",\n    column=column,\n    color=color,\n    highlighted_traces=[\"Female\", \"Male\"],\n    title=(\n        \"\"\"\n        <b>But women who are `Beginners` and `Others` saw bigger reduction in pay.<\/b>\n        <br><span style=\"font-size:14px;color:grey\"><i>Base Year=2018<\/i><\/span>\n        \"\"\"\n    ),\n).show()","ff930ff5":"column = \"Profile\"\ncolor = \"Job Title\"\nvalue = \"Compensation Value\"\n\ndf1 = df.groupby([x, column, color], as_index=False)[value].mean()\n\n_df1 = df1[df1[x] == base_year][[column, color, value]].copy()\nbase_col = f\"{value} {base_year}\"\n_df1.rename(columns={value: base_col}, inplace=True)\nsource = pd.merge(df1, _df1, on=[column, color])\nsource[\"Change\"] = source[value] \/ source[base_col] - 1","a5458892":"LinePlot(\n    df=source,\n    x=x,\n    y=\"Change\",\n    column=column,\n    color=color,\n    highlighted_traces=[\"Software Engineer\", \"Data Engineer\/DBA\"],\n    title=(\n        \"\"\"\n        <b>Reduction in pay seems to be worse for software engineers.<\/b>\n        <br><span style=\"font-size:14px;color:grey\"><i>Base Year=2018<\/i><\/span>\n        \"\"\"\n    ),\n).show()","abd6cfe5":"column = \"Profile\"\ncolor = \"Languages\"\n\nsource = compute_prop(\n    df, column, color, list(set(Mapping.LANGUAGES.value.values())) + [\"None\"]\n)","79706aa4":"LinePlot(\n    df=source,\n    x=x,\n    y=\"Prop\",\n    column=column,\n    color=color,\n    highlighted_traces=[\"Python\", \"SQL\", \"R\"],\n    title=(\n        \"\"\"\n        <b>Python remains the most widely used tool across the years while R has seen a drop.<\/b>\n        <br><span style=\"font-size:14px;color:grey\"><i>Base Year=2018<\/i><\/span>\n        \"\"\"\n    ),\n).show()","77cd30e9":"column = \"Profile\"\ncolor = \"IDEs\"\n\nsource = compute_prop(\n    df, column, color, list(set(Mapping.IDE.value.values())) + [\"None\"]\n)","bd8cafdf":"LinePlot(\n    df=source,\n    x=x,\n    y=\"Prop\",\n    column=column,\n    color=color,\n    highlighted_traces=[\"Jupyter\/IPython\", \"Visual Studio\", \"RStudio\"],\n    title=(\n        \"\"\"\n        <b>Similarly, Jupyter\/IPython is still the most popular IDE while RStudio has dropped.<\/b>\n        <br><span style=\"font-size:14px;color:grey\"><i>Base Year=2018<\/i><\/span>\n        \"\"\"\n    ),\n).show()","1173d6d1":"column = \"Profile\"\ncolor = \"ML Frameworks\"\n\nsource = compute_prop(\n    df, column, color, list(set(Mapping.ML_FRAMEWORKS.value.values())) + [\"None\"]\n)","f017192f":"LinePlot(\n    df=source,\n    x=x,\n    y=\"Prop\",\n    column=column,\n    color=color,\n    highlighted_traces=[\"Scikit-learn\", \"TensorFlow\", \"PyTorch\", \"Keras\"],\n    title=(\n        \"\"\"\n        <b>Scikit-learn remains the most widely used tool while PyTorch has been gaining new ground.<\/b>\n        <br><span style=\"font-size:14px;color:grey\"><i>Base Year=2018<\/i><\/span>\n        \"\"\"\n    ),\n).show()","972f550b":"column = \"Profile\"\ncolor = \"Data Visualization Libraries\"\n\nsource = compute_prop(\n    df, column, color, list(set(Mapping.VIZ.value.values())) + [\"None\"]\n)","1d3b3cbf":"LinePlot(\n    df=source,\n    x=x,\n    y=\"Prop\",\n    column=column,\n    color=color,\n    highlighted_traces=[\"Matplotlib\", \"Seaborn\"],\n    title=(\n        \"\"\"\n        <b>Matplotlib and Seaborn are the favourite data visualization libraries.<\/b>\n        <br><span style=\"font-size:14px;color:grey\"><i>Base Year=2018<\/i><\/span>\n        \"\"\"\n    ),\n).show()","fda60ad8":"column = \"Profile\"\ncolor = \"Cloud Computing Platforms\"\n\nsource = compute_prop(\n    df, column, color, list(set(Mapping.CLOUD.value.values())) + [\"None\"]\n)","ec9e4206":"LinePlot(\n    df=source,\n    x=x,\n    y=\"Prop\",\n    column=column,\n    color=color,\n    highlighted_traces=[\"AWS\", \"Azure\", \"GCP\"],\n    title=(\n        \"\"\"\n        <b>AWS is still the most popular cloud computing platform but many are not using any.<\/b>\n        <br><span style=\"font-size:14px;color:grey\"><i>Base Year=2018<\/i><\/span>\n        \"\"\"\n    ),\n).show()","ea06a767":"column = \"Profile\"\ncolor = \"Data Science Courses\"\n\nsource = compute_prop(\n    df, column, color, list(set(Mapping.COURSES.value.values())) + [\"None\"]\n)","424033ee":"LinePlot(\n    df=source,\n    x=x,\n    y=\"Prop\",\n    column=column,\n    color=color,\n    highlighted_traces=[\"Coursera\", \"Kaggle Learn\"],\n    title=(\n        \"\"\"\n        <b>Coursera has been a favourite place for data science courses but Kaggle Learn has been gaining popularity.<\/b>\n        <br><span style=\"font-size:14px;color:grey\"><i>Base Year=2018<\/i><\/span>\n        \"\"\"\n    ),\n).show()","9eb1ae36":"column = \"Profile\"\ncolor = \"Media Sources\"\n\nsource = compute_prop(\n    df, column, color, list(set(Mapping.MEDIA.value.values())) + [\"None\"]\n)","6800fe56":"LinePlot(\n    df=source,\n    x=x,\n    y=\"Prop\",\n    column=column,\n    color=color,\n    highlighted_traces=[\"Journals\", \"Kaggle\"],\n    title=(\n        \"\"\"\n        <b>Kaggle has been a favourite information source but Journals are also important for ML Veterans.<\/b>\n        <br><span style=\"font-size:14px;color:grey\"><i>Base Year=2018<\/i><\/span>\n        \"\"\"\n    ),\n).show()","5c3dc491":"## Eight charts on commonly used tools","39b0a406":"## Five charts on impact of pandemic on compensation","1f0f47a1":"# 2018-21 Kaggle ML\/DS Survey\n\nThe code is adapted from [andresionek\/one-chart-many-answers-kaggle-surveys-in-slopes](https:\/\/www.kaggle.com\/andresionek\/one-chart-many-answers-kaggle-surveys-in-slop) as well as [tkubacka\/a-story-told-through-a-heatmap](https:\/\/www.kaggle.com\/tkubacka\/a-story-told-through-a-heatmap).","9436959d":"### Definition of Profile\n\nInspired by [tkubacka\/a-story-told-through-a-heatmap](https:\/\/www.kaggle.com\/tkubacka\/a-story-told-through-a-heatmap), we use the values of `Years Writing Code` and `Years Using ML` to create a new feature called `profile`\n\n- `Beginners`: Years Writing Code between 0-3 years, Years Using ML between 0-3 years\n- `Modern DS`: Years Writing Code between 3-10 years, Years Using ML between 3-10 years\n- `Coders`: Years Writing Code for 10+ years, Years Using ML between 0-3 years\n- `ML Veterans`: Years Writing Code for 10+ years, Years Using ML for 10+ years"}}