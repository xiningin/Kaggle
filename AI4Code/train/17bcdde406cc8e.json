{"cell_type":{"0d55d35d":"code","870863ea":"code","4265b4e4":"code","0237df3a":"markdown","b61b8e67":"markdown","2b4dea3b":"markdown","e12620ec":"markdown"},"source":{"0d55d35d":"!nvcc --version\n!pip install git+git:\/\/github.com\/andreinechaev\/nvcc4jupyter.git\n%load_ext nvcc_plugin","870863ea":"%%cu\n\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\n__device__ unsigned int plus_scan(int *x)\n{\n    unsigned int i = threadIdx.x; \/\/ id of thread executing this instance\n    unsigned int n = blockDim.x;  \/\/ total number of threads in this block\n    unsigned int offset;          \/\/ distance between elements to be added\n\n    for( offset = 1; offset < n; offset *= 2) {\n        unsigned int t;\n\n        if ( i >= offset ) \n            t = x[i-offset];\n        \n        __syncthreads();\n\n        if ( i >= offset ) \n            x[i] = t + x[i];      \/\/ i.e., x[i] = x[i] + x[i-1]\n\n        __syncthreads();\n    }\n    return x[i];\n}\n\n\n__device__ void partition_by_bit(int *values, unsigned int bit)\n{\n    unsigned int i = threadIdx.x;\n    unsigned int size = blockDim.x;\n    unsigned int x_i = values[i];          \/\/ value of integer at position i\n    unsigned int p_i = (x_i >> bit) & 1;   \/\/ value of bit at position bit\n    \n\n    \/\/ Replace values array so that values[i] is the value of bit bit in\n    \/\/ element i.\n    values[i] = p_i;  \n\n    \/\/ Wait for all threads to finish this.\n    __syncthreads();\n\n    unsigned int T_before = plus_scan(values);\n\n\n    unsigned int T_total  = values[size-1];    \/\/total number of ones\n\n    unsigned int F_total  = size - T_total;    \/\/total number of zeros\n\n    __syncthreads();\n\n    if ( p_i )\n        values[T_before-1 + F_total] = x_i;\n    else\n        values[i - T_before] = x_i;\n}\n\n\n__global__ void radix_sort(int *values)\n{\n    int  bit;\n    for( bit = 0; bit < 32; ++bit )\n    {\n        partition_by_bit(values, bit);\n        __syncthreads();\n    }\n}\n\n\nint main()\n{\n    int n = 16, m = 3;\n    \n        \n    int harr[n];    \/\/ = {45, 8, 3, 1, 23, 56, 78, 9, 23, 24, 56, 22, 12, 59, 89, 14};\n    int hbrr[m];    \/\/ = {0, 4, 13};\n    \n    ifstream in (\"\/kaggle\/input\/question1-input\/A.txt\");\n    for(int i = 0; i < n; i++) in >> harr[i];\n    in.close();\n    in.clear();    \/\/t use the same variable \"in\", you need to call .clear() to clear the object's flags before you reuse it\n    \n    in.open(\"\/kaggle\/input\/question1-input\/B.txt\");\n    for(int i = 0; i < m; i++) in >> hbrr[i];\n    \n    \n    \n    int *darr;\n    \n    cudaMalloc(&darr, n * sizeof(int));\n    cudaMemcpy(darr, harr, n * sizeof(int), cudaMemcpyHostToDevice);\n    \n    \n    cudaStream_t stream[m];\n    for(int i = 0; i < m-1; i++)\n    {\n        cudaStreamCreate(&stream[i]);\n        radix_sort<<<1, hbrr[i+1]-hbrr[i], 0, stream[i]>>>(&darr[hbrr[i]]);\n    }\n    radix_sort<<<1, n-hbrr[m-1], 0, stream[m-1]>>>(&darr[hbrr[m-1]]);\n    \n    cudaMemcpy(harr, darr, n * sizeof(int), cudaMemcpyDeviceToHost);\n    \n    \n    ofstream out (\"C.txt\", ios::trunc); \/\/ if already exist then delete prev content\n    for(int i = 0; i < n; i++)\n    {\n        out << harr[i] << ' ';\n        cout << harr[i] << \" \\n\"[i == n-1];\n    }\n    \n    return 0;\n}","4265b4e4":"%%cu\n\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\n__device__ unsigned int plus_scan(int *x)\n{\n    unsigned int i = threadIdx.x; \/\/ id of thread executing this instance\n    unsigned int n = blockDim.x;  \/\/ total number of threads in this block\n    unsigned int offset;          \/\/ distance between elements to be added\n\n    for( offset = 1; offset < n; offset *= 2) {\n        unsigned int t;\n\n        if ( i >= offset ) \n            t = x[i-offset];\n        \n        __syncthreads();\n\n        if ( i >= offset ) \n            x[i] = t + x[i];      \/\/ i.e., x[i] = x[i] + x[i-1]\n\n        __syncthreads();\n    }\n    return x[i];\n}\n\n\n__device__ void partition_by_bit(int *values, unsigned int bit)\n{\n    unsigned int i = threadIdx.x;\n    unsigned int size = blockDim.x;\n    unsigned int x_i = values[i];          \/\/ value of integer at position i\n    unsigned int p_i = (x_i >> bit) & 1;   \/\/ value of bit at position bit\n    \n\n    \/\/ Replace values array so that values[i] is the value of bit bit in\n    \/\/ element i.\n    values[i] = p_i;  \n\n    \/\/ Wait for all threads to finish this.\n    __syncthreads();\n\n    unsigned int T_before = plus_scan(values);\n\n\n    unsigned int T_total  = values[size-1];    \/\/total number of ones\n\n    unsigned int F_total  = size - T_total;    \/\/total number of zeros\n\n    __syncthreads();\n\n    if ( p_i )\n        values[T_before-1 + F_total] = x_i;\n    else\n        values[i - T_before] = x_i;\n}\n\n\n__global__ void radix_sort(int *values, int n)\n{\n    extern __shared__ int svalues[];\n    unsigned int i = threadIdx.x;\n    svalues[i] = values[i];   \/\/copying from global memory to shared memory for speed\n    __syncthreads();\n    \n    int  bit;\n    for( bit = 0; bit < 32; ++bit )\n    {\n        partition_by_bit(svalues, bit);\n        __syncthreads();\n    }\n    \n    values[i] = svalues[i];    \/\/copying back to global memory\n}\n\n\nint main()\n{\n    int n = 16, m = 3;\n    \n        \n    int harr[n];    \/\/ = {45, 8, 3, 1, 23, 56, 78, 9, 23, 24, 56, 22, 12, 59, 89, 14};\n    int hbrr[m];    \/\/ = {0, 4, 13};\n    \n    ifstream in (\"\/kaggle\/input\/question1-input\/A.txt\");\n    for(int i = 0; i < n; i++) in >> harr[i];\n    in.close();\n    in.clear();    \/\/t use the same variable \"in\", you need to call .clear() to clear the object's flags before you reuse it\n    \n    in.open(\"\/kaggle\/input\/question1-input\/B.txt\");\n    for(int i = 0; i < m; i++) in >> hbrr[i];\n    \n    \n    int *darr;\n    \n    cudaMalloc(&darr, n * sizeof(int));\n    cudaMemcpy(darr, harr, n * sizeof(int), cudaMemcpyHostToDevice);\n    \n    \n    cudaStream_t stream[m];\n    for(int i = 0; i < m-1; i++)\n    {\n        cudaStreamCreate(&stream[i]);\n        radix_sort<<<1, hbrr[i+1] - hbrr[i], (hbrr[i+1] - hbrr[i]) * sizeof(int), stream[i]>>>(&darr[hbrr[i]], hbrr[i+1] - hbrr[i]);\n    }\n    radix_sort<<<1, n - hbrr[m-1], (n - hbrr[m-1]) * sizeof(int), stream[m-1]>>>(&darr[hbrr[m-1]], n - hbrr[m-1]);\n    \n    cudaMemcpy(harr, darr, n * sizeof(int), cudaMemcpyDeviceToHost);\n    \n    ofstream out (\"C.txt\", ios::trunc); \/\/ if already exist then delete prev content\n    for(int i = 0; i < n; i++)\n    {\n        out << harr[i] << ' ';\n        cout << harr[i] << \" \\n\"[i == n-1];\n    }\n    \n    return 0;\n}","0237df3a":"**The algorithm i've used for sorting in this question is radix sort, which only works for positive numbers because negetive numbers are represented as 2's complement in binary**","b61b8e67":"# **Using Global Memory**","2b4dea3b":"# **CS516 - Assignment 1**\nRudraksh Kashyap - 11840970","e12620ec":"# **Using shared memory**"}}