{"cell_type":{"f5c87b72":"code","11e97303":"code","8b4a7ec5":"code","b4ce0171":"code","f756f208":"code","2bc3e2e3":"code","1b4e2c11":"code","959d5ee6":"code","674598df":"code","44e663f3":"code","5fb9bb5f":"code","4b95b3b7":"code","5536f88c":"code","1c1d4bd3":"code","aba86de4":"code","8f31bb3b":"code","918c35dd":"code","b351071c":"code","452d92bd":"code","bc78e2db":"code","23d7f554":"code","bbc26aa0":"code","64f34d1f":"markdown","6a225ba5":"markdown","951f7ae1":"markdown","df6f2507":"markdown","c1c70291":"markdown","de07f8cc":"markdown","da582092":"markdown","34a067d7":"markdown","2038cc3f":"markdown","007173c0":"markdown","346aec02":"markdown"},"source":{"f5c87b72":"from kaggle_secrets import UserSecretsClient\n\n# Retrieving API keys\nuser_secrets = UserSecretsClient()\nclient_id = user_secrets.get_secret(\"cliend_id\")\nclient_secret = user_secrets.get_secret(\"client_secret\")","11e97303":"# Installing spotipy library\n!pip install spotipy --upgrade","8b4a7ec5":"import os\n\n# Setting the API variables in the environment\nos.environ['SPOTIPY_CLIENT_ID'] = client_id\nos.environ['SPOTIPY_CLIENT_SECRET'] = client_secret\n\n# Connecting the API\n# Spotipy\nimport spotipy\nfrom   spotipy.oauth2 import SpotifyOAuth\nfrom   spotipy.oauth2 import SpotifyClientCredentials\nimport spotipy.util as util\n\nauth_manager = SpotifyClientCredentials()\nspotify = spotipy.Spotify(auth_manager=auth_manager)","b4ce0171":"# Data handling\nimport numpy as np\nimport pandas as pd\nimport json\n\n# Dynamic data Visualization\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go","f756f208":"URLs = {'Top 50 - Italy' : 'https:\/\/open.spotify.com\/playlist\/37i9dQZEVXbIQnj7RRhdSX',\n        'Top 50 - Global' : 'https:\/\/open.spotify.com\/playlist\/37i9dQZEVXbNG2KDcFcKOF',\n        'Legendary Rock': 'https:\/\/open.spotify.com\/playlist\/37i9dQZF1DWWGFQLoP9qlv',\n        'Run Wild' : 'https:\/\/open.spotify.com\/playlist\/37i9dQZF1DX35oM5SPECmN',\n        'Chilled Jazz': 'https:\/\/open.spotify.com\/playlist\/37i9dQZF1DX2vYju3i0lNX'}","2bc3e2e3":"# With this small function you can retrieve the data using directly the playlist name.\n# Remember to update the URLs dictionary before trying to access a new playlist!\n\ndef set_env(title, URL_dict):\n    \n    if title in URL_dict.keys():\n        return title, URL_dict[title]\n    else:\n        print('Playlist not indexed!')\n        \ntitle_plot, URL_search = set_env('Top 50 - Global', URLs)\nprint('Playlist: ', title_plot, '\\nURL: ', URL_search, sep = '')","1b4e2c11":"# Retrieve all the tracks in the playlist\ntracks = spotify.playlist_tracks(URL_search)","959d5ee6":"pd.DataFrame.from_dict(tracks['items'])\n\nwith open('data.json', 'w', errors='ignore') as f:\n    json.dump(tracks, f, ensure_ascii=False, indent=4)\n\n# Load data using Python JSON module\nwith open('data.json', 'r') as f:\n    data = json.loads(f.read())","674598df":"songs = pd.json_normalize(data, record_path=['items']).drop_duplicates('track.id')\n\nsongs = songs[[ 'added_at', 'track.name', 'track.album.id', 'track.album.release_date', 'track.duration_ms', \n                'track.id','track.album.name', 'track.popularity', 'track.explicit' ]]\n\nsongs['track.duration_ms'] = songs['track.duration_ms']\/1000\n\nsongs.rename(columns= { 'added_at' : 'Added Date', \n                        'track.name' : 'Track Name',\n                        'track.album.id' : 'Album ID', \n                        'track.album.release_date' : 'Album Release Date', \n                        'track.duration_ms' : 'Track Duration (s)', \n                        'track.id' : 'Track ID',\n                        'track.album.name' : 'Album Name', \n                        'track.popularity' : 'Track Popularity',\n                        'track.explicit' : 'Explicit Content' },\n                inplace=True)\n\nprint(f'First five songs in your playlist. Data frame shape: {songs.shape}\\n')\nsongs.head(5)","44e663f3":"artists = pd.json_normalize(data, \n                            record_path=['items', 'track', 'album', 'artists'], \n                            meta= [['items', 'track', 'id']]).drop_duplicates('items.track.id')\n\nartists = artists[['id', 'name', 'external_urls.spotify', 'items.track.id']]\n\nartists.rename( columns= {  'id' : 'Artist ID', \n                            'name' : 'Artist Name', \n                            'external_urls.spotify' : 'Artist Page', \n                            'items.track.id' : 'Track ID' },\n                inplace=True)\n\nprint(f'First five artists in your playlist. Data frame shape: {songs.shape}\\n')\n\nartists.head(5)","5fb9bb5f":"features = pd.json_normalize(spotify.audio_features(songs['Track ID']))\nfeatures = features.drop_duplicates('id')\nfeatures.drop(columns = ['type', 'uri', 'track_href', 'duration_ms', 'analysis_url', 'time_signature'],\n              inplace=True)\n\nnew_col_names = dict(zip(features.columns, features.columns.str.capitalize()))\n\nfeatures.rename( columns= new_col_names,\n                inplace=True)\n\nfeatures.rename( columns= {'Id' : 'Track ID'}, inplace=True)\n\nprint(f'First five features of the song in your playlist. Data frame shape: {features.shape}\\n')\n\nfeatures.head(5)","4b95b3b7":"# Merging all the information together\n\nfirst_step = pd.merge(   \n                        songs,\n                        artists,\n                        how=\"left\",\n                        left_on='Track ID',\n                        right_on='Track ID',\n                        sort=True,\n                        validate= 'one_to_many'\n                    )\n\nfinal_df = pd.merge(   \n                        first_step,\n                        features,\n                        how=\"left\",\n                        left_on='Track ID',\n                        right_on='Track ID',\n                        sort=True,\n                        validate= 'one_to_many'\n                    )\n","5536f88c":"# Selecting only the useful columns\n\ncolumn_names = ['Added Date', 'Track ID', 'Track Name', 'Track Duration (s)', 'Danceability', \n                'Energy', 'Key', 'Loudness', 'Mode', 'Speechiness', 'Acousticness', \n                'Instrumentalness', 'Liveness', 'Valence', 'Tempo', 'Explicit Content', \n                'Track Popularity', 'Artist ID', 'Artist Name', \n                'Artist Page', 'Album ID', 'Album Name', 'Album Release Date',\n                ]\n\nfinal_df['Added Date'] = pd.to_datetime(final_df['Added Date']).dt.strftime('%m-%d-%Y')\nfinal_df = final_df.reindex(columns=column_names)\n\nprint(f'First five observations of the final dataset. Shape: {final_df.shape}\\n')\n\nfinal_df.head(5)","1c1d4bd3":"def dashboard_1():\n    template = \"plotly_white\"\n\n    color = '#415ae8'\n\n    theta  = [  'Danceability', 'Energy', 'Mode', 'Speechiness', \n                'Acousticness', 'Instrumentalness', 'Liveness', \n                'Valence' ]\n\n    track_n = len(final_df['Track ID'].unique())\n    artist_n = len(final_df['Artist ID'].unique())\n\n    fig = make_subplots(\n        rows=2, cols=2,\n        specs=[[{\"type\": \"xy\"}, {\"type\": \"polar\"}],\n               [{\"type\": \"xy\"}, {\"type\": \"domain\"}]],\n        subplot_titles=(\"Song Length (s)\", \"Song Features\", \"Explicit Content\", \"Top 10 Songs\"))\n\n    fig['layout']['annotations'][0]['yanchor'] = 'top'\n    fig['layout']['annotations'][0]['y'] = 1.07\n    fig['layout']['annotations'][1]['yanchor'] = 'top'\n    fig['layout']['annotations'][1]['y'] = 1.07\n    fig['layout']['annotations'][2]['yanchor'] = 'top'\n    fig['layout']['annotations'][2]['y'] = 0.45\n    fig['layout']['annotations'][3]['yanchor'] = 'top'\n    fig['layout']['annotations'][3]['y'] = 0.45\n\n    n_explicit = sum(final_df['Explicit Content'] == True)\n    n_not_explicit = sum(final_df['Explicit Content'] == False)\n\n    df_table = final_df[['Track Name', 'Artist Name', 'Track Popularity']].sort_values(by = 'Track Popularity', \n                                                                                       ascending=False).head(10)\n\n    headerColor = color\n    rowEvenColor = 'rgba(65,129,232,0.5)'\n    rowOddColor = 'rgba(0,0,0,0)'\n\n    fig.add_trace(go.Box(   x=final_df['Track Duration (s)'],\n                            opacity = .9,\n                            marker_color=color,\n                            boxpoints='all',\n                            jitter=0.3,\n                            name='Songs'),\n                            row=1, col=1)\n\n    for idx in range(final_df[theta].shape[0]):\n        dat = final_df[theta].iloc[idx]\n        fig.add_trace(go.Scatterpolar(  r=dat.values,\n                                        theta=theta,\n                                        fill='toself',\n                                        line_color = color,\n                                        line_shape = 'spline', \n                                        line_smoothing = .2,\n                                        mode = 'lines',\n                                        opacity = .1,\n                                        showlegend=False),\n                    row=1, col=2)\n\n    fig.add_trace(go.Bar(x = ['Not Explicit', 'Explicit'],\n                         y = [n_not_explicit, n_explicit],\n                                opacity = .9,\n                                marker_color=color),\n                                row=2, col=1)\n\n    fig.add_trace(go.Table(header=dict(values=['Track Name', 'Artist Name', 'Track Popularity'],\n                                       align=['left','left','left'],\n                                       fill_color=headerColor,\n                                       font_color = 'white'),\n                     cells=dict(values=[df_table['Track Name'], df_table['Artist Name'], df_table['Track Popularity']],\n                                align=['left','left', 'left'],\n                                fill_color = [[rowOddColor, rowEvenColor, rowOddColor, rowEvenColor, rowOddColor, \n                                               rowEvenColor, rowOddColor, rowEvenColor, rowOddColor, rowEvenColor]*3])),\n                  row=2, col=2)\n\n    fig.update_layout(  title={\n            'text': f'{title_plot}, Playlist Analysis <br><sup>Total Songs: {track_n}, Total Artists: {artist_n}<\/sup>',\n            'y':0.96,\n            'x':0.5,\n            'xanchor': 'center',\n            'yanchor': 'top',\n            'font_size' : 24,\n            'font_color' : color},\n                        height=900, \n                        showlegend=False,\n                        template=template,\n                        )\n\n    fig.show()\n\ndashboard_1()","aba86de4":"# Retrieving all the related artists for each artist in the playlist\ndef retrieve_artists(final_df):\n    related_artists = pd.DataFrame(columns = ['id', 'name'])\n    \n    for artist in final_df['Artist ID'].unique():\n        try:\n            new_artists = spotify.artist_related_artists(artist)\n            related_artists = related_artists.append(pd.DataFrame.from_dict(new_artists['artists'])[['id', 'name']])\n        except:\n            pass\n           \n    related_artists = related_artists.drop_duplicates('id')\n    print(f'{len(related_artists)} new artists have been found!\\n')\n    \n    return related_artists\n\nrelated_artists = retrieve_artists(final_df)    \n\nprint(f'First five observations of the related_artists dataset. Shape: {related_artists.shape}\\n')\n\nrelated_artists.head(5)","8f31bb3b":"# Retrieving the top songs from all the related artists\ndef retrieve_songs(related_artists):\n    new_songs = pd.DataFrame(columns = ['id', 'name', 'artist id'])\n    \n    for artist in related_artists['id'].unique():\n        try:\n            new_song = spotify.artist_top_tracks(artist)\n            new_song = pd.DataFrame.from_dict(new_song['tracks'])[['id', 'name']]\n            new_song['artist id'] = artist\n            new_songs = new_songs.append(new_song)\n        except:\n            pass\n        \n    new_songs = new_songs.drop_duplicates('id')\n    print(f'{len(new_songs)} new songs have been found!\\n')\n    \n    return new_songs\n\nnew_songs = retrieve_songs(related_artists)    \n\nprint(f'First five observations of the new_songs dataset. Shape: {new_songs.shape}\\n')\n\nnew_songs.head(5)","918c35dd":"# Creating batches\nlist_df = np.array_split(new_songs, 100)","b351071c":"def retrieve_new_features(list_df):\n    \n    new_feat = pd.DataFrame(columns = ['Danceability', 'Energy', 'Key', 'Loudness', 'Mode',\n                                        'Speechiness', 'Acousticness', 'Instrumentalness', 'Liveness',\n                                        'Valence', 'Tempo', 'Track ID'])\n    \n    for i in range(len(list_df)):\n        try:\n            new_features = pd.json_normalize(spotify.audio_features(list_df[i]['id']))\n            new_features = new_features.drop_duplicates('id')\n\n            new_features.drop(columns = ['type', 'uri', 'track_href', 'duration_ms', 'analysis_url', 'time_signature'],\n                          inplace=True)\n\n            col_names = dict(zip(new_features.columns, new_features.columns.str.capitalize()))\n\n            new_features.rename( columns= col_names,\n                                 inplace=True)\n\n            new_features.rename( columns= {'Id' : 'Track ID'}, inplace=True)\n\n            new_feat = new_feat.append(new_features)\n            new_feat.drop_duplicates('Track ID')\n        except:\n            pass\n        \n    return new_feat\n        \nnew_features = retrieve_new_features(list_df)\n\nprint(f'First five features of the song retrieved. Data frame shape: {new_features.shape}\\n')\nnew_features.head()","452d92bd":"# Merging all the information together\n\nfirst_artist_step = pd.merge(   \n                                related_artists,\n                                new_songs,\n                                how=\"left\",\n                                left_on='id',\n                                right_on='artist id',\n                                sort=True,\n                                validate= 'one_to_many'\n                            )\n\nfirst_artist_step.drop('artist id', \n                       axis = 1, \n                       inplace = True)\n\nfirst_artist_step.rename( columns= {'id_x'   : 'Artist ID',\n                                    'name_x' : 'Artist Name',\n                                    'id_y'   : 'Track ID',\n                                    'name_y' : 'Track Name'}, \n                          inplace=True)\n\nfirst_artist_step.drop_duplicates('Track ID',\n                                  inplace = True)\n\nprint(f'First five features of the first step. Data frame shape: {first_artist_step.shape}\\n')\nfirst_artist_step.head()","bc78e2db":"final_song_df = pd.merge(   \n                            first_artist_step,\n                            new_features,\n                            how=\"left\",\n                            left_on='Track ID',\n                            right_on='Track ID',\n                            sort=True,\n                            validate= 'one_to_many'\n                        )\n\nfinal_song_df = final_song_df.dropna()\n\n# Remember to remove the songs that were also in the playlist!\nfinal_song_df = final_song_df[~final_song_df['Track ID'].isin(final_df['Track ID'])]\n\nprint(f'First five features of the final data frame. Data frame shape: {final_song_df.shape}\\n')\nfinal_song_df.head()","23d7f554":"from sklearn.metrics.pairwise import cosine_similarity,cosine_distances\n\n# Computing cosine similarity\ndata_playlist = pd.DataFrame(final_df[[   'Danceability', 'Energy', 'Loudness', 'Mode', \n                                          'Speechiness', 'Acousticness', 'Instrumentalness', \n                                          'Liveness', 'Valence', 'Tempo']].mean()).T\n\ndata_new_songs = final_song_df[[  'Danceability', 'Energy', 'Loudness', 'Mode', \n                                  'Speechiness', 'Acousticness', 'Instrumentalness', \n                                  'Liveness', 'Valence', 'Tempo']]\n\nresult = cosine_similarity(data_playlist, data_new_songs).T\nresult_df = final_song_df\nresult_df['Score'] = np.round(result,10)\nresult_df = result_df.sort_values('Score', ascending  = False)\nreccomendations = result_df.head(10)\nreccomendations","bbc26aa0":"def dashboard_2():\n    \n    template = \"plotly_white\"\n\n    color = '#415ae8'\n\n    theta  = [  'Danceability', 'Energy', 'Mode', 'Speechiness', \n                'Acousticness', 'Instrumentalness', 'Liveness', \n                'Valence' ]\n\n    track_n = len(reccomendations['Track ID'].unique())\n    artist_n = len(reccomendations['Artist ID'].unique())\n\n    fig = make_subplots(\n        rows=1, cols=2,\n        specs=[[{\"type\": \"polar\"}, {\"type\": \"domain\"}]],\n        subplot_titles=((\"Song Features\", \"Top 10 Songs\")))\n\n    fig['layout']['annotations'][0]['yanchor'] = 'top'\n    fig['layout']['annotations'][0]['y'] = 1.07\n    fig['layout']['annotations'][1]['yanchor'] = 'top'\n    fig['layout']['annotations'][1]['y'] = 1.07\n\n\n    df_table = reccomendations[['Track Name', 'Artist Name', 'Score']]\n\n    headerColor = color\n    rowEvenColor = 'rgba(65,129,232,0.5)'\n    rowOddColor = 'rgba(0,0,0,0)'\n\n    for idx in range(reccomendations[theta].shape[0]):\n        dat = reccomendations[theta].iloc[idx]\n        fig.add_trace(go.Scatterpolar(  r=dat.values,\n                                        theta=theta,\n                                        fill='toself',\n                                        line_color = color,\n                                        line_shape = 'spline', \n                                        line_smoothing = .2,\n                                        mode = 'lines',\n                                        opacity = .1,\n                                        showlegend=False,\n                                        name  = df_table.iloc[idx]['Track Name']),\n                    row=1, col=1)\n\n   \n    fig.add_trace(go.Table(header=dict(values=['Track Name', 'Artist Name', 'Score'],\n                                       align=['left','left','left'],\n                                       fill_color=headerColor,\n                                       font_color = 'white'),\n                     cells=dict(values=[reccomendations['Track Name'], reccomendations['Artist Name'], reccomendations['Score']],\n                                align=['left','left', 'left'],\n                                fill_color = [[rowOddColor, rowEvenColor, rowOddColor, rowEvenColor, rowOddColor, \n                                               rowEvenColor, rowOddColor, rowEvenColor, rowOddColor, rowEvenColor]*3])),\n                  row=1, col=2)\n\n    fig.update_layout(  title={\n            'text': f'Reccomendations based on your playlist <br><sup>Total Songs: {track_n}, Total Artists: {artist_n}<\/sup>',\n            'y':0.96,\n            'x':0.5,\n            'xanchor': 'center',\n            'yanchor': 'top',\n            'font_size' : 24,\n            'font_color' : color},\n                        height=900, \n                        showlegend=False,\n                        template=template,\n                        )\n\n    fig.show()\n\ndashboard_2()","64f34d1f":"# 1.1 Getting access to the API\n\nIn order to get access to the API you need a [*Spotify for developers*](https:\/\/developer.spotify.com\/dashboard\/login) account. You can use the same credentials of your Spotify account, and does not require Spotify Premium. Once you have created your account you need to create a new APP from the main dashboard.\n\n<br>\n<center>\n<div>\n<img src=\"https:\/\/i.imgur.com\/Ls4V5SQ.png\" width=\"800\"\/>\n<\/div>\n<\/center>\n<br>\n\nOnce you have your app ready click on it and you can get a *client ID* and a *client secret* for the app. Both of these will be required to authenticate with the Spotify web API for our application.\n\n<br>\n<center>\n<div>\n<img src=\"https:\/\/i.imgur.com\/pMmIEyx.png\" width=\"600\"\/>\n<\/div>\n<\/center>\n<br>\n\nNow you can use the Kaggle `Secrets` functionality to store the keys and load them for a safe use.\n\n<br>\n<center>\n<div>\n<img src=\"https:\/\/i.imgur.com\/vk5wNJQ.png\" width=\"400\"\/>\n<\/div>\n<\/center>\n<br>\n\n\n<br>\n<center>\n<div>\n<img src=\"https:\/\/i.imgur.com\/sMDVcbX.png\" width=\"500\"\/>\n<\/div>\n<\/center>\n<br>\n","6a225ba5":"# 2.2 Creating the interactive dashboard","951f7ae1":"# 3.1 Providing recommendations","df6f2507":"# 2.1 Data gathering\n\n### Libraries","c1c70291":"### Playlist\n\nHere you can add the link of the playlist you want to analyze. Remember that the playlist *must* be public!","de07f8cc":"There are 12 audio features for each track, including confidence measures like acousticness, liveness, speechiness, and instrumentalness, perceptual measures like energy, loudness, danceability, and valence (positiveness), and descriptors like duration, tempo, key, and mode. The recommender system will suggest you 10 songs based on the features of the songs in the playlist and from the same artists.\n\nThe songs will be recommended in the following way:\n\n- First of all related artists to the artist in the playlist are identified (Get Spotify catalog information about artists similar to an identified artist. Similarity is based on analysis of the Spotify community\u2019s listening history)\n\n- A data frame containing all the top songs of the related artists is created (notice that the songs in the playlist are dropped from this data frame)\n\n- A similarity score is computed between the average features of the playlist and the feature of each song in the new data frame\n\n- The top 3 similar songs are finally suggested","da582092":"<div class=\"alert alert-block alert-info\"> \ud83d\udccc Spotify API does not handle large download of features data. For this reason the database is divided into batches.<\/div>","34a067d7":"# 1.3 Adjusting settings and API connection\n\nIn order to use the API it is better to use the [**Client Credentials flow**](https:\/\/spotipy.readthedocs.io\/en\/2.12.0\/#client-credentials-flow).\nThe method makes it possible to authenticate your requests to the Spotify Web API and to obtain a higher rate limit than you would with the Authorization Code flow. The Client Credentials flow is used in server-to-server authentication. Only endpoints that do not access user information can be accessed. The advantage here in comparison with requests to the Web API made without an access token, is that a higher rate limit is applied.\n\nAs opposed to the Authorization Code Flow, you will not need to set SPOTIPY_REDIRECT_URI, which means you will never be redirected to the sign in page in your browser:\n\n```\nexport SPOTIPY_CLIENT_ID='your-spotify-client-id'\nexport SPOTIPY_CLIENT_SECRET='your-spotify-client-secret'\n```","2038cc3f":"<h1>\n    <p style=\"text-align:center; font-size:180%\"> Analyzing playlists with spotipy and Spotify API<\/p> \n<\/h1>\n\n<h2>\n    <p \n       style=\"text-align:center; font-family:Verdana; letter-spacing:0.5px; font-size:120%\"> Dynamic Dashboarding and Recommender System\n    <\/p>\n<\/h2> \n    \n\n<center>\n    <img src=\"https:\/\/b.kisscc0.com\/20180814\/kae\/kisscc0-musical-note-sound-musical-composition-sheet-music-flowing-notes-5-5b73932c0bee79.9482805915343009720489.png\"> \n<\/center>\n\n<br><br>","007173c0":"# Introduction\n\nIn this notebook you will explore how to:\n\n* Register to *Spotify for developers*\n* Connect to the API with `spotipy`\n* Retrieve data from the json provided by the API\n* Create databases from playlists containing:\n    * Artists (with details)\n    * Album (with details)\n    * Songs (and song features)\n* Create an interactive dashboard with the main information about the selected playlist\n* Build a simple reccommender system based on the selected playlist","346aec02":"# 1.2 Installing spotipy\n\nHere you can find the reference guide of `spotipy`: https:\/\/spotipy.readthedocs.io\/en\/2.12.0\/\n\nYou need to use the following command to correctly install the package\n\n```\n$ !pip install spotipy --upgrade\n```"}}