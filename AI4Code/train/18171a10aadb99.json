{"cell_type":{"60d4763c":"code","a5181d73":"code","3b82457f":"code","475965f5":"markdown","77849c88":"markdown","1f02aa78":"markdown"},"source":{"60d4763c":"import random\nimport math    # cos() for Rastrigin\nimport copy    # array-copying convenience\nimport sys     # max float\n# ------------------------------------\ndef show_vector(vector):\n  for i in range(len(vector)):\n    if i % 8 == 0: # 8 columns\n      print(\"\\n\", end=\"\")\n    if vector[i] >= 0.0:\n      print(' ', end=\"\")\n    print(\"%.4f\" % vector[i], end=\"\") # 4 decimals\n    print(\" \", end=\"\")\n  print(\"\\n\")\ndef error(position):\n  err = 0.0\n  for i in range(len(position)):\n    xi = position[i]\n    err += (xi * xi) - (10 * math.cos(2 * math.pi * xi)) + 10\n  return err\n# ------------------------------------\nclass Particle:\n  def __init__(self, dim, minx, maxx, seed):\n    self.rnd = random.Random(seed)\n    self.position = [0.0 for i in range(dim)]\n    self.velocity = [0.0 for i in range(dim)]\n    self.best_part_pos = [0.0 for i in range(dim)]\n    for i in range(dim):\n      self.position[i] = ((maxx - minx) *\n        self.rnd.random() + minx)\n      self.velocity[i] = ((maxx - minx) *\n        self.rnd.random() + minx)\n    self.error = error(self.position) # curr error\n    self.best_part_pos = copy.copy(self.position) \n    self.best_part_err = self.error # best error\ndef Solve(max_epochs, n, dim, minx, maxx):\n  rnd = random.Random(0)\n  # create n random particles\n  swarm = [Particle(dim, minx, maxx, i) for i in range(n)] \n  best_swarm_pos = [0.0 for i in range(dim)] # not necess.\n  best_swarm_err = sys.float_info.max # swarm best\n  for i in range(n): # check each particle\n    if swarm[i].error < best_swarm_err:\n      best_swarm_err = swarm[i].error\n      best_swarm_pos = copy.copy(swarm[i].position) \n  epoch = 0\n  w = 0.729    # inertia\n  c1 = 1.49445 # cognitive (particle)\n  c2 = 1.49445 # social (swarm)\n  while epoch < max_epochs:\n    \n    if epoch % 2 == 0 and epoch > 1:\n      print(\"Epoch = \" + str(epoch) +\n        \" best error = %.30f\" % best_swarm_err)\n    for i in range(n): # process each particle\n      \n      # compute new velocity of curr particle\n      for k in range(dim): \n        r1 = rnd.random()    # randomizations\n        r2 = rnd.random()\n    \n        swarm[i].velocity[k] = ( (w * swarm[i].velocity[k]) +\n          (c1 * r1 * (swarm[i].best_part_pos[k] -\n          swarm[i].position[k])) +  \n          (c2 * r2 * (best_swarm_pos[k] -\n          swarm[i].position[k])) )  \n        if swarm[i].velocity[k] < minx:\n          swarm[i].velocity[k] = minx\n        elif swarm[i].velocity[k] > maxx:\n          swarm[i].velocity[k] = maxx\n      # compute new position using new velocity\n      for k in range(dim): \n        swarm[i].position[k] += swarm[i].velocity[k]\n  \n      # compute error of new position\n      swarm[i].error = error(swarm[i].position)\n      # is new position a new best for the particle?\n      if swarm[i].error < swarm[i].best_part_err:\n        swarm[i].best_part_err = swarm[i].error\n        swarm[i].best_part_pos = copy.copy(swarm[i].position)\n      # is new position a new best overall?\n      if swarm[i].error < best_swarm_err:\n        best_swarm_err = swarm[i].error\n        best_swarm_pos = copy.copy(swarm[i].position)\n    \n    # for-each particle\n    epoch += 1\n  # while\n  return best_swarm_pos\n# end Solve\nprint(\"\\nBegin particle swarm optimization using Python demo\\n\")\ndim = 3\nprint(\"Goal is to solve Rastrigin's function in \" +\n str(dim) + \" variables\")\nprint(\"Function has known min = 0.0 at (\", end=\"\")\nfor i in range(dim-1):\n  print(\"0, \", end=\"\")\nprint(\"0)\")\nnum_particles = 50\nmax_epochs = 100\nprint(\"Setting num_particles = \" + str(num_particles))\nprint(\"Setting max_epochs    = \" + str(max_epochs))\nprint(\"\\nStarting PSO algorithm\\n\")\nbest_position = Solve(max_epochs, num_particles,\n dim, -10.0, 10.0)\nprint(\"\\nPSO completed\\n\")\nprint(\"\\nBest solution found:\")\nshow_vector(best_position)\nerr = error(best_position)\nprint(\"Error of best solution = %.6f\" % err)\nprint(\"\\nEnd particle swarm demo\\n\")\n","a5181d73":"import random\nimport math    # sqrt\n# ------------------------------------\ndef show_vector(vector):\n  for i in range(len(vector)):\n    if i % 8 == 0: # 8 columns\n      print(\"\\n\", end=\"\")\n    if vector[i] >= 0.0:\n      print(' ', end=\"\")\n    print(\"%.4f\" % vector[i], end=\"\") # 4 decimals\n    print(\" \", end=\"\")\n  print(\"\\n\")\n# ------------------------------------\ndef error(position):\n  # Euclidean distance to (0, 0, .. 0)\n  dim = len(position)\n  target = [0.0 for i in range(dim)]\n  dist = 0.0\n  for i in range(dim):\n    dist += (position[i] - target[i])**2\n  return math.sqrt(dist)\n# ------------------------------------\nclass Point:\n  def __init__(self, dim, minx, maxx):\n    self.position = [0.0 for i in range(dim)]\n    for i in range(dim):\n      self.position[i] = ((maxx - minx) *\n        random.random() + minx)\n    self.error = error(self.position) # curr error\n# ------------------------------------\ndef Solve(dim, max_epochs, minx, maxx):\n  points = [Point(dim, minx, maxx) for i in range(3)] # 3 points\n  for i in range(dim): points[0].position[i] = minx\n  for i in range(dim): points[2].position[i] = maxx\n  best_idx = -1\n  other_idx = -1\n  worst_idx = -1\n  centroid = [0.0 for i in range(dim)]\n  expanded = [0.0 for i in range(dim)]\n  reflected = [0.0 for i in range(dim)]\n  contracted = [0.0 for i in range(dim)]\n  arbitrary = [0.0 for i in range(dim)]\n  epoch = 0\n  while epoch < max_epochs:\n    epoch += 1\n        \n    # identify best, other, worst\n    if (points[0].error < points[1].error and\n    points[0].error < points[2].error):\n      if points[1].error < points[2].error:\n        best_idx = 0; other_idx = 1; worst_idx = 2\n      else:\n        best_idx = 0; other_idx = 2; worst_idx = 1\n    elif (points[1].error < points[0].error and\n    points[1].error < points[2].error):\n      if points[0].error < points[2].error:\n        best_idx = 1; other_idx = 0; worst_idx = 2\n      else:\n        best_idx = 1; other_idx = 2; worst_idx = 0\n    else:\n      if points[0].error < points[1].error:\n        best_idx = 2; other_idx = 0; worst_idx = 1\n      else:\n        best_idx = 2; other_idx = 1; worst_idx = 0\n    if epoch <= 9 or epoch >= 30:\n      print(\"--------------------\")\n      print(\"epoch = \" + str(epoch) + \" \", end=\"\")\n      print(\"best error = \", end=\"\")\n      print(\"%.6f\" % points[best_idx].error, end=\"\")\n    if epoch == 10:\n      print(\"--------------------\")\n      print(\" . . . \")\n    if points[best_idx].error < 1.0e-4:\n      if epoch <= 9 or epoch >= 30:\n        print(\" reached small error. halting\")\n      break;\n    # make the centroid\n    for i in range(dim):\n      centroid[i] = (points[other_idx].position[i] +\n      points[best_idx].position[i]) \/ 2.0\n    # try the expanded point\n    for i in range(dim):\n      expanded[i] = centroid[i] + (2.0 * (centroid[i] -\n      points[worst_idx].position[i]))\n    expanded_err = error(expanded)\n    if expanded_err < points[worst_idx].error:\n      if epoch <= 9 or epoch >= 30:\n        print(\" expanded found better error than worst error\")\n      for i in range(dim): \n        points[worst_idx].position[i] = expanded[i]\n      points[worst_idx].error = expanded_err\n      continue\n    # try the reflected point\n    for i in range(dim):\n      reflected[i] = centroid[i] + (1.0 * (centroid[i] -\n      points[worst_idx].position[i]))\n    reflected_err = error(reflected)\n    if reflected_err < points[worst_idx].error:\n      if epoch <= 9 or epoch >= 30:\n        print(\" reflected found better error than worst error\")\n      for i in range(dim):\n        points[worst_idx].position[i] = reflected[i]\n      points[worst_idx].error = reflected_err\n      continue\n    # try the contracted point\n    for i in range(dim):\n      contracted[i] = centroid[i] + (-0.5 * (centroid[i] -\n      points[worst_idx].position[i]))\n    contracted_err = error(contracted)\n    if contracted_err < points[worst_idx].error:\n      if epoch <= 9 or epoch >= 30:\n        print(\" contracted found better error than worst error\")\n      for i in range(dim):\n        points[worst_idx].position[i] = contracted[i]\n      points[worst_idx].error = contracted_err\n      continue\n    # try a random point\n    for i in range(dim):\n      arbitrary[i] = ((maxx - minx) * random.random() + minx)\n    arbitrary_err = error(arbitrary)\n    if arbitrary_err < points[worst_idx].error:\n      if epoch <= 9 or epoch >= 30:\n        print(\" arbitrary found better error than worst error\")\n      for i in range(dim):\n        points[worst_idx].position[i] = arbitrary[i]\n      points[worst_idx].error = arbitrary_err\n      continue\n    # could not find better point so shrink worst and other\n    if epoch <= 9 or epoch >= 30:\n      print(\" shrinking\")\n    # 1. worst -> best\n    for i in range(dim):\n      points[worst_idx].position[i] = (points[worst_idx].position[i]\n      + points[best_idx].position[i]) \/ 2.0\n    points[worst_idx].error = error(points[worst_idx].position)\n    # 2. other -> best\n    for i in range(dim):\n      points[other_idx].position[i] = (points[other_idx].position[i]\n      + points[best_idx].position[i]) \/ 2.0\n    points[other_idx].error = error(points[other_idx].position)\n  # end-while\n  print(\"--------------------\")\n  print(\"\\nBest position found=\")\n  show_vector(points[best_idx].position)\n# ------------------------------------\nprint(\"\\nBegin simplex optimization using Python demo\\n\")\ndim = 5\nrandom.seed(0)\nprint(\"Goal is to solve the Sphere function in \" +\n str(dim) + \" variables\")\nprint(\"Function has known min = 0.0 at (\", end=\"\")\nfor i in range(dim-1):\n  print(\"0, \", end=\"\")\nprint(\"0)\")\nmax_epochs = 1000\nprint(\"Setting max_epochs    = \" + str(max_epochs))\nprint(\"\\nStarting simplex algorithm\\n\")\nSolve(dim, max_epochs, -10.0, 10.0)\nprint(\"\\nSimplex algorithm complete\")\nprint(\"\\nEnd simplex optimization demo\\n\")","3b82457f":"import random\nimport copy    # array-copying convenience\nimport sys     # max float\n# ------------------------------------\ndef show_path(path):\n  for i in range(len(path)-1):\n    print(str(path[i]) + \" -> \", end=\"\")\n  print(path[len(path)-1])\n# ------------------------------------\ndef error(path):\n  d = 0.0  # total distance between cities\n  for i in range(len(path)-1):\n    if path[i] < path[i+1]:\n      d += (path[i+1] - path[i]) * 1.0\n    else:\n      d += (path[i] - path[i+1]) * 1.5\n  minDist = len(path)-1\n  return d - minDist\n# ------------------------------------\nclass Bee:\n  def __init__(self, nc, seed):\n    #self.rnd = random.Random(seed)\n    self.status = 0  # 0 = inactive, 1 = active, 2 = scout\n    self.path = [0 for i in range(nc)]  # potential solution\n    \n    for i in range(nc):\n      self.path[i] = i  # [0,1,2, ...]\n    \n    random.shuffle(self.path)\n    self.error = error(self.path) # bee's current error\n# ------------------------------------\ndef solve(nc, nb, max_epochs):\n  # solve TSP for nc cities using nb bees\n  # optimal soln is [0,1,2, . . n-1]\n  # assumes dist between adj cities is 1.0 or 1.5 \n  # create nb random bees\n  hive = [Bee(nc, i) for i in range(nb)] \n  best_err = sys.float_info.max  # dummy init value\n  for i in range(nb):  # check each random bee\n    if hive[i].error < best_err:\n      best_err = hive[i].error\n      best_path = copy.copy(hive[i].path)\n  \n  # assign initial statuses\n  numActive = int(nb * 0.50)\n  numScout = int(nb * 0.25)\n  numInactive = nb - (numActive + numScout)\n  for i in range(nb):\n    if i < numInactive:\n      hive[i].status = 0\n    elif i < numInactive + numScout:\n      hive[i].status = 2\n    else:\n      hive[i].status = 1\n  \n  epoch = 0\n  while epoch < max_epochs:\n    if best_err == 0.0: break\n    for i in range(nb):  # process each bee\n      if hive[i].status == 1:    # active bee\n        # find a neighbor path and associated error\n        neighbor_path = copy.copy(hive[i].path)\n        ri = random.randint(0, nc-1)  # random index\n        ai = 0  # adjacent index. assume last->first\n        if ri < nc-1: ai = ri + 1\n        tmp = neighbor_path[ri]\n        neighbor_path[ri] = neighbor_path[ai]\n        neighbor_path[ai] = tmp\n        neighbor_err = error(neighbor_path)\n        # check if neighbor path is better\n        p = random.random()  # [0.0 to 1.0)\n        if (neighbor_err < hive[i].error or\n         (neighbor_err >= hive[i].error and p < 0.05)):\n          hive[i].path = neighbor_path\n          hive[i].error = neighbor_err\n          # new best?\n          if hive[i].error < best_err:\n            best_err = hive[i].error\n            best_path = hive[i].path\n            print(\"epoch = \" + str(epoch) +\n              \" new best path found \", end=\"\")\n            print(\"with error = \" + str(best_err))\n        # active bee code\n      elif hive[i].status == 2:  # scout bee\n        # make random path and error\n        random_path = [0 for j in range(nc)]\n        for j in range(nc):\n          random_path[j] = j\n        random.shuffle(random_path)\n        random_err = error(random_path)\n        # is it better?\n        if random_err < hive[i].error:\n          hive[i].path = random_path  # ref assignmnt\n          hive[i].error = random_err\n          # new best?\n          if hive[i].error < best_err:\n            best_err = hive[i].error\n            best_path = hive[i].path\n            print(\"epoch = \" + str(epoch) +\n              \" new best path found \", end=\"\")\n            print(\"with error = \" + str(best_err))\n      elif hive[i].status == 0:  # inactive\n        pass  # null statement\n    # for-each bee\n    \n    epoch += 1\n  # while\n  \n  print(\"\\nBest path found:\")\n  show_path(best_path)\n  print(\"\\nError of best path = \" + str(best_err))\n# ------------------------------------\nprint(\"\\nBegin simulated bee colony optimization using Python demo\\n\")\nprint(\"Goal is to solve a dummy Traveling Salesman Problem\")\nprint(\"\\nDistance between cities A and B is (B-A) * 1.0 if B > A\")\nprint(\" or (A-B) * 1.5 if A > B. For example, d(3,5) = 2.0\")\nprint(\" and d(8,3) = 7.5. In a real scenario you'd have a lookup table\")\nprint(\"\\nFor n cities, the optimal path is 0 -> 1 -> . . -> (n-1)\")\nprint(\" with a total path distance of n-1.\\n\") \nnum_cities = 20\nnum_bees = 50\nmax_epochs =10000\nprint(\"Setting num_cities = \" + str(num_cities))\nprint(\"Setting num_bees   = \" + str(num_bees))\nprint(\"Setting max_epochs = \" + str(max_epochs) + \"\\n\")\nrandom.seed(1)\nsolve(num_cities, num_bees, max_epochs)\nprint(\"\\nEnd simulated bee colony demo\\n\")","475965f5":"# Simplex Optimisation","77849c88":"# Bee Colony Simulation Optimisation","1f02aa78":"# Particle Swarm Optimisation"}}