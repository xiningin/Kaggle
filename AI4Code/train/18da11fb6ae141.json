{"cell_type":{"f386e04d":"code","3364e847":"code","cb6a57f2":"code","7a31fbcb":"code","7974569f":"code","81c00de4":"code","79815df5":"code","e8ac9877":"code","0351c294":"code","9eb27642":"code","29ea29d2":"code","79be5aee":"code","de0f0f4c":"code","032d6eb1":"code","14bd4e8f":"code","4ceaeb7a":"code","72915b3f":"code","f3a32142":"code","a68e6bb6":"code","fa07ccae":"code","d33e012a":"code","0a6626a5":"code","facdd6db":"code","894a30eb":"code","4aa141fd":"code","cba94598":"code","b9e117de":"code","97850183":"code","5dd11344":"code","97f5ebcc":"code","034d4787":"code","baae5ae9":"code","739410cb":"code","b9879db4":"code","9904c1f2":"code","79a4967a":"code","62b5901f":"code","ec049a31":"code","1d2145fa":"code","eab34695":"code","90c959ec":"code","724b01a5":"code","08126739":"code","3358dc54":"code","5b1cd8b5":"markdown","eb92e7fb":"markdown","ecbff648":"markdown","67240211":"markdown","d1ffa408":"markdown","8b8dbceb":"markdown","e8752dec":"markdown","86389254":"markdown","ac312191":"markdown","f0551c27":"markdown","73b3b0df":"markdown","d770925b":"markdown","5b435b89":"markdown","2a9b87de":"markdown","57bf7943":"markdown","f49a9fb8":"markdown","0aa4e28b":"markdown","dc0b5879":"markdown","adadc3fd":"markdown","aae81e0d":"markdown","03222afc":"markdown"},"source":{"f386e04d":"print(\"Image Source (https:\/\/commons.wikimedia.org\/wiki\/Surfing#\/media\/File:Surfing_in_Hawaii.jpg); License: Public Domain\")\nfrom PIL import Image\nimport requests\nImage.open(requests.get('https:\/\/tensorflow.org\/images\/surf.jpg', stream=True).raw)","3364e847":"import tensorflow as tf\n\n# You'll generate plots of attention in order to see which parts of an image\n# our model focuses on during captioning\nimport matplotlib.pyplot as plt\n\nimport collections\nimport random\nimport numpy as np\nimport os\nimport time\nimport json\n\nfrom tqdm.notebook import tqdm","cb6a57f2":"annotation_file = '..\/input\/coco-2017-dataset\/coco2017\/annotations\/captions_train2017.json'\nPATH = '..\/input\/coco-2017-dataset\/coco2017\/train2017\/'","7a31fbcb":"with open(annotation_file, 'r') as f:\n    annotations = json.load(f)","7974569f":"# Group all captions together having the same image ID.\nimage_path_to_caption = collections.defaultdict(list)\nfor val in annotations['annotations']:\n    caption = f\"<start> {val['caption']} <end>\"\n    image_path = PATH + '%012d.jpg' % (val['image_id'])\n    image_path_to_caption[image_path].append(caption)","81c00de4":"# view the first 5 values in image_path_to_caption\nfor i, (k, v) in enumerate(image_path_to_caption.items()):\n    print(k, v)\n    if i > 5:\n        break","79815df5":"image_paths = list(image_path_to_caption.keys())\nrandom.shuffle(image_paths)\n\n# Select the first 6000 image_paths from the shuffled set.\n# Approximately each image id has 5 captions associated with it, so that will\n# lead to 30,000 examples.\ntrain_image_paths = image_paths[:6000]\nprint(len(train_image_paths))","e8ac9877":"# check that the first 5 images can be found in our training images folder\nfor imPath in train_image_paths[:5]:\n    print(os.path.isfile(imPath), imPath)","0351c294":"train_captions = []\nimg_name_vector = []\n\nfor image_path in train_image_paths:\n    # for the image path, get the captions\n    caption_list = image_path_to_caption[image_path]\n    # add captions to list 'train_captions'\n    train_captions.extend(caption_list)\n    # add image path to list 'img_name_vector', if we have 5 captions to an image than duplicate the image path 5 times, etc.\n    img_name_vector.extend([image_path] * len(caption_list))","9eb27642":"print(\"Last value of caption_list in for loop: \", caption_list)\nprint(\"Last length of caption_list in for loop: \", len(caption_list))\nprint(\"\")\nprint(\"First value of train_captions: \", train_captions[0])\nprint(\"Length of train_captions: \", len(train_captions))\nprint(\"\")\nprint(\"First value of img_name_vector: \", img_name_vector[0])\nprint(\"Length of img_name_vector: \", len(img_name_vector))","29ea29d2":"print(train_captions[0])\nImage.open(img_name_vector[0])","79be5aee":"print(\"Image shape:\")\nnp.array(Image.open(img_name_vector[0])).shape","de0f0f4c":"def load_image(image_path):\n    img = tf.io.read_file(image_path)\n    img = tf.image.decode_jpeg(img, channels=3)\n    img = tf.image.resize(img, (299, 299))\n    img = tf.keras.applications.inception_v3.preprocess_input(img)\n    return img, image_path","032d6eb1":"image_model = tf.keras.applications.InceptionV3(include_top=False,\n                                                weights='imagenet')\nnew_input = image_model.input\nhidden_layer = image_model.layers[-1].output\n\nimage_features_extract_model = tf.keras.Model(new_input, hidden_layer)","14bd4e8f":"# Get unique images\nencode_train = sorted(set(img_name_vector))\n\n# Feel free to change batch_size according to your system configuration\nimage_dataset = tf.data.Dataset.from_tensor_slices(encode_train)\nimage_dataset = image_dataset.map(\n    load_image, num_parallel_calls=tf.data.AUTOTUNE).batch(16)\n\nfor img, path in tqdm(image_dataset):\n    batch_features = image_features_extract_model(img)\n    batch_features = tf.reshape(batch_features,\n                                (batch_features.shape[0], -1, batch_features.shape[3])\n                               )\n    for bf, p in zip(batch_features, path):\n        # tensorflow to numpy string\n        path_of_feature = p.numpy().decode(\"utf-8\")\n        # get image name\n        im_name = path_of_feature.split('\/')[-1][:-4]\n        # save as numpy file\n        np.save(im_name, bf.numpy())","4ceaeb7a":"# Find the maximum length of any caption in our dataset\ndef calc_max_length(tensor):\n    return max(len(t) for t in tensor)","72915b3f":"# Choose the top 5000 words from the vocabulary\ntop_k = 5000\ntokenizer = tf.keras.preprocessing.text.Tokenizer(num_words=top_k,\n                                                  oov_token=\"<unk>\",\n                                                  filters='!\"#$%&()*+.,-\/:;=?@[\\]^_`{|}~ ')\ntokenizer.fit_on_texts(train_captions)","f3a32142":"tokenizer.word_index['<pad>'] = 0\ntokenizer.index_word[0] = '<pad>'","a68e6bb6":"# Create the tokenized vectors\ntrain_seqs = tokenizer.texts_to_sequences(train_captions)\n\nprint(\"train_seqs type: \", type(train_seqs))\nprint(\"View first 5 values of 'train_seqs': \")\ntrain_seqs[:5]","fa07ccae":"# Pad each vector to the max_length of the captions\n# If you do not provide a max_length value, pad_sequences calculates it automatically\ncap_vector = tf.keras.preprocessing.sequence.pad_sequences(train_seqs, padding='post')\n\nprint(\"cap_vector type: \", type(train_seqs))\nprint(\"View first value of 'cap_vector': \", cap_vector[0])","d33e012a":"# Calculates the max_length, which is used to store the attention weights\nmax_length = calc_max_length(train_seqs)\nprint(\"Max length: \", max_length)","0a6626a5":"img_to_cap_vector = collections.defaultdict(list)\nfor img, cap in zip(img_name_vector, cap_vector):\n    img_to_cap_vector[img].append(cap)\n\n# view the first few values in img_to_cap_vector\nfor i, (k, v) in enumerate(img_to_cap_vector.items()):\n    print(k, v)\n    if i > 1:\n        break","facdd6db":"# Create training and validation sets using an 80-20 split randomly.\nimg_keys = list(img_to_cap_vector.keys())\nrandom.shuffle(img_keys)\n\n# view resulting object\nprint(\"First 5 values of 'img_keys': \")\nimg_keys[:5]","894a30eb":"slice_index = int(len(img_keys)*0.8)\nprint(\"slice_index: \", slice_index)\nimg_name_train_keys, img_name_val_keys = img_keys[:slice_index], img_keys[slice_index:]\nprint(\"\")\nprint(\"First value of img_name_train_keys: \", img_name_train_keys[0])\nprint(\"img_name_train_keys length: \", len(img_name_train_keys))\nprint(\"\")\nprint(\"First value of img_name_val_keys: \", img_name_val_keys[0])\nprint(\"img_name_val_keys length: \", len(img_name_val_keys))","4aa141fd":"img_name_train = []\ncap_train = []\nfor imgt in img_name_train_keys:\n    capt_len = len(img_to_cap_vector[imgt])\n    img_name_train.extend([imgt] * capt_len)\n    cap_train.extend(img_to_cap_vector[imgt])\n\nprint(\"First value of cap_train: \", cap_train[0])\nprint(\"Length of cap_train: \", len(cap_train))\nprint(\"\")\nprint(\"First value of img_name_train: \", img_name_train[0])\nprint(\"Length of img_name_train: \", len(img_name_train))\n    \nimg_name_val = []\ncap_val = []\nfor imgv in img_name_val_keys:\n    capv_len = len(img_to_cap_vector[imgv])\n    img_name_val.extend([imgv] * capv_len)\n    cap_val.extend(img_to_cap_vector[imgv])\n\nprint(\"\")\nprint(\"First value of cap_val: \", cap_val[0])\nprint(\"Length of cap_val: \", len(cap_val))\nprint(\"\")\nprint(\"First value of img_name_val: \", img_name_val[0])\nprint(\"Length of img_name_val: \", len(img_name_val))","cba94598":"len(img_name_train), len(cap_train), len(img_name_val), len(cap_val)","b9e117de":"# Feel free to change these parameters according to your system's configuration\n\nBATCH_SIZE = 64\nBUFFER_SIZE = 1000\nembedding_dim = 256\nunits = 512\nvocab_size = top_k + 1\nnum_steps = len(img_name_train) \/\/ BATCH_SIZE\n# Shape of the vector extracted from InceptionV3 is (64, 2048)\n# These two variables represent that vector shape\nfeatures_shape = 2048\nattention_features_shape = 64","97850183":"# Load the numpy files\ndef map_func(img_name, cap):\n    str_in_nm = img_name.decode('utf-8')\n    image_name = str_in_nm.split('\/')[-1][:-4]\n    img_tensor = np.load(image_name+'.npy')\n    return img_tensor, cap","5dd11344":"dataset = tf.data.Dataset.from_tensor_slices((img_name_train, cap_train))\n\n# Use map to load the numpy files in parallel\ndataset = dataset.map(lambda item1, item2: tf.numpy_function(\n          map_func, [item1, item2], [tf.float32, tf.int32]),\n          num_parallel_calls=tf.data.AUTOTUNE)\n\n# Shuffle and batch\ndataset = dataset.shuffle(BUFFER_SIZE).batch(BATCH_SIZE)\ndataset = dataset.prefetch(buffer_size=tf.data.AUTOTUNE)","97f5ebcc":"class BahdanauAttention(tf.keras.Model):\n    def __init__(self, units):\n        super(BahdanauAttention, self).__init__()\n        self.W1 = tf.keras.layers.Dense(units)\n        self.W2 = tf.keras.layers.Dense(units)\n        self.V = tf.keras.layers.Dense(1)\n    \n    def call(self, features, hidden):\n        # features(CNN_encoder output) shape == (batch_size, 64, embedding_dim)\n        \n        # hidden shape == (batch_size, hidden_size)\n        # hidden_with_time_axis shape == (batch_size, 1, hidden_size)\n        hidden_with_time_axis = tf.expand_dims(hidden, 1)\n        \n        # attention_hidden_layer shape == (batch_size, 64, units)\n        attention_hidden_layer = (tf.nn.tanh(self.W1(features) +\n                                             self.W2(hidden_with_time_axis)))\n        \n        # score shape == (batch_size, 64, 1)\n        # This gives you an unnormalized score for each image feature.\n        score = self.V(attention_hidden_layer)\n        \n        # attention_weights shape == (batch_size, 64, 1)\n        attention_weights = tf.nn.softmax(score, axis=1)\n        \n        # context_vector shape after sum == (batch_size, hidden_size)\n        context_vector = attention_weights * features\n        context_vector = tf.reduce_sum(context_vector, axis=1)\n        \n        return context_vector, attention_weights","034d4787":"class CNN_Encoder(tf.keras.Model):\n    # Since you have already extracted the features and dumped it\n    # This encoder passes those features through a Fully connected layer\n    def __init__(self, embedding_dim):\n        super(CNN_Encoder, self).__init__()\n        # shape after fc == (batch_size, 64, embedding_dim)\n        self.fc = tf.keras.layers.Dense(embedding_dim)\n\n    def call(self, x):\n        x = self.fc(x)\n        x = tf.nn.relu(x)\n        return x","baae5ae9":"class RNN_Decoder(tf.keras.Model):\n    def __init__(self, embedding_dim, units, vocab_size):\n        super(RNN_Decoder, self).__init__()\n        self.units = units\n\n        self.embedding = tf.keras.layers.Embedding(vocab_size, embedding_dim)\n        self.gru = tf.keras.layers.GRU(self.units,\n                                       return_sequences=True,\n                                       return_state=True,\n                                       recurrent_initializer='glorot_uniform')\n        self.fc1 = tf.keras.layers.Dense(self.units)\n        self.fc2 = tf.keras.layers.Dense(vocab_size)\n\n        self.attention = BahdanauAttention(self.units)\n        \n    def call(self, x, features, hidden):\n        # defining attention as a separate model\n        context_vector, attention_weights = self.attention(features, hidden)\n\n        # x shape after passing through embedding == (batch_size, 1, embedding_dim)\n        x = self.embedding(x)\n\n        # x shape after concatenation == (batch_size, 1, embedding_dim + hidden_size)\n        x = tf.concat([tf.expand_dims(context_vector, 1), x], axis=-1)\n\n        # passing the concatenated vector to the GRU\n        output, state = self.gru(x)\n\n        # shape == (batch_size, max_length, hidden_size)\n        x = self.fc1(output)\n\n        # x shape == (batch_size * max_length, hidden_size)\n        x = tf.reshape(x, (-1, x.shape[2]))\n\n        # output shape == (batch_size * max_length, vocab)\n        x = self.fc2(x)\n\n        return x, state, attention_weights\n\n    def reset_state(self, batch_size):\n        return tf.zeros((batch_size, self.units))","739410cb":"encoder = CNN_Encoder(embedding_dim)\ndecoder = RNN_Decoder(embedding_dim, units, vocab_size)","b9879db4":"optimizer = tf.keras.optimizers.Adam()\nloss_object = tf.keras.losses.SparseCategoricalCrossentropy(\n    from_logits=True, \n    reduction='none'\n)\n\ndef loss_function(real, pred):\n    mask = tf.math.logical_not(tf.math.equal(real, 0))\n    loss_ = loss_object(real, pred)\n    \n    mask = tf.cast(mask, dtype=loss_.dtype)\n    loss_ *= mask\n    \n    return tf.reduce_mean(loss_)","9904c1f2":"checkpoint_path = \".\/checkpoints\/train\"\nckpt = tf.train.Checkpoint(encoder=encoder,\n                           decoder=decoder,\n                           optimizer=optimizer)\nckpt_manager = tf.train.CheckpointManager(ckpt, checkpoint_path, max_to_keep=5)","79a4967a":"start_epoch = 0\nif ckpt_manager.latest_checkpoint:\n    start_epoch = int(ckpt_manager.latest_checkpoint.split('-')[-1])\n    # restoring the latest checkpoint in checkpoint_path\n    ckpt.restore(ckpt_manager.latest_checkpoint)","62b5901f":"# adding this in a separate cell because if you run the training cell\n# many times, the loss_plot array will be reset\nloss_plot = []","ec049a31":"@tf.function\ndef train_step(img_tensor, target):\n    loss = 0\n    \n    # initializing the hidden state for each batch\n    # because the captions are not related from image to image\n    hidden = decoder.reset_state(batch_size=target.shape[0])\n    \n    dec_input = tf.expand_dims([tokenizer.word_index['<start>']] * target.shape[0], 1)\n    \n    with tf.GradientTape() as tape:\n        features = encoder(img_tensor)\n        \n        for i in range(1, target.shape[1]):\n            # passing the features through the decoder\n            predictions, hidden, _ = decoder(dec_input, features, hidden)\n            \n            loss += loss_function(target[:, i], predictions)\n            \n            # using teacher forcing\n            dec_input = tf.expand_dims(target[:, i], 1)\n        \n    total_loss = (loss \/ int(target.shape[1]))\n    trainable_variables = encoder.trainable_variables + decoder.trainable_variables\n    gradients = tape.gradient(loss, trainable_variables)\n    optimizer.apply_gradients(zip(gradients, trainable_variables))\n    return loss, total_loss","1d2145fa":"EPOCHS = 20\n\nfor epoch in range(start_epoch, EPOCHS):\n    start = time.time()\n    total_loss = 0\n\n    for (batch, (img_tensor, target)) in enumerate(dataset):\n        batch_loss, t_loss = train_step(img_tensor, target)\n        total_loss += t_loss\n\n        if batch % 100 == 0:\n            average_batch_loss = batch_loss.numpy()\/int(target.shape[1])\n            print(f'Epoch {epoch+1} Batch {batch} Loss {average_batch_loss:.4f}')\n    # storing the epoch end loss value to plot later\n    loss_plot.append(total_loss \/ num_steps)\n\n    if epoch % 5 == 0:\n        ckpt_manager.save()\n\n    print(f'Epoch {epoch+1} Loss {total_loss\/num_steps:.6f}')\n    print(f'Time taken for 1 epoch {time.time()-start:.2f} sec\\n')","eab34695":"plt.plot(loss_plot)\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.title('Loss Plot')\nplt.show()","90c959ec":"def evaluate(image):\n    attention_plot = np.zeros((max_length, attention_features_shape))\n\n    hidden = decoder.reset_state(batch_size=1)\n\n    temp_input = tf.expand_dims(load_image(image)[0], 0)\n    img_tensor_val = image_features_extract_model(temp_input)\n    img_tensor_val = tf.reshape(img_tensor_val, (img_tensor_val.shape[0],\n                                                 -1,\n                                                 img_tensor_val.shape[3]))\n\n    features = encoder(img_tensor_val)\n\n    dec_input = tf.expand_dims([tokenizer.word_index['<start>']], 0)\n    result = []\n\n    for i in range(max_length):\n        predictions, hidden, attention_weights = decoder(dec_input,\n                                                         features,\n                                                         hidden)\n\n        attention_plot[i] = tf.reshape(attention_weights, (-1, )).numpy()\n\n        predicted_id = tf.random.categorical(predictions, 1)[0][0].numpy()\n        result.append(tokenizer.index_word[predicted_id])\n\n        if tokenizer.index_word[predicted_id] == '<end>':\n            return result, attention_plot\n\n        dec_input = tf.expand_dims([predicted_id], 0)\n\n    attention_plot = attention_plot[:len(result), :]\n    return result, attention_plot","724b01a5":"def plot_attention(image, result, attention_plot):\n    temp_image = np.array(Image.open(image))\n\n    fig = plt.figure(figsize=(10, 10))\n\n    len_result = len(result)\n    for i in range(len_result):\n        temp_att = np.resize(attention_plot[i], (8, 8))\n        grid_size = max(np.ceil(len_result\/2), 2)\n        ax = fig.add_subplot(grid_size, grid_size, i+1)\n        ax.set_title(result[i])\n        img = ax.imshow(temp_image)\n        ax.imshow(temp_att, cmap='gray', alpha=0.6, extent=img.get_extent())\n\n    plt.tight_layout()\n    plt.show()","08126739":"# captions on the validation set\nrid = np.random.randint(0, len(img_name_val))\nimage = img_name_val[rid]\nreal_caption = ' '.join([tokenizer.index_word[i]\n                        for i in cap_val[rid] if i not in [0]])\nresult, attention_plot = evaluate(image)\n\nprint('Real Caption:', real_caption)\nprint('Prediction Caption:', ' '.join(result))\nplot_attention(image, result, attention_plot)","3358dc54":"image_url = 'https:\/\/tensorflow.org\/images\/surf.jpg'\nimage_extension = image_url[-4:]\nimage_path = tf.keras.utils.get_file('image'+image_extension, origin=image_url)\n\nresult, attention_plot = evaluate(image_path)\nprint('Prediction Caption:', ' '.join(result))\nplot_attention(image_path, result, attention_plot)\n# opening the image\nImage.open(image_path)","5b1cd8b5":"#### Preprocess the images using regular image preprocessing + InceptionV3\n\n - Next, you will use InceptionV3 (which is pretrained on Imagenet) to classify each image. You will extract features from the last convolutional layer.\n \n- First, you will convert the images into InceptionV3's expected format by resizing the image to 299px by 299px ,preprocess the images using the preprocess_input method to normalize the image so that it contains pixels in the range of -1 to 1 (which matches the format of the images used to train InceptionV)","eb92e7fb":"# Train Test Split","ecbff648":"#### Check that the images in our dictionary can be found on disk","67240211":"# Imports","d1ffa408":"#### Cap training to 6000 images (to reduce runtime, just for tutorial)","8b8dbceb":"#### View resulting dictionary","e8752dec":"#### Initialize InceptionV3 and load the pretrained Imagenet weights\n\n- Now you'll create a tf.keras model where the output layer is the last convolutional layer in the InceptionV3 architecture. The shape of the output of this layer is 8x8x2048. You use the last convolutional layer because you are using attention in this example. You don't perform this initialization during training because it could become a bottleneck.\n\n- You forward each image through the network and store the resulting vector in a dictionary (image_name --> feature_vector).\n \n- After all the images are passed through the network, you save the dictionary to disk.","86389254":"# Caption!\n- The evaluate function is similar to the training loop, except you don't use teacher forcing here. The input to the decoder at each time step is its previous predictions along with the hidden state and the encoder output.\n- Stop predicting when the model predicts the end token.\n- And store the attention weights for every time step.","ac312191":"#### Group the target values (captions) with the image paths","f0551c27":"#### Create a tf.data dataset for training\n\nOur images and captions are ready! Next, let's create a tf.data dataset to use for training our model.","73b3b0df":"# Get Image & Target Value Locations","d770925b":"#### Caching the features extracted from InceptionV3\n\n- You will pre-process each image with InceptionV3 and cache the output to disk. Caching the output in RAM would be faster but also memory intensive, requiring 8 * 8 * 2048 floats per image. At the time of writing, this exceeds the memory limitations of Colab (currently 12GB of memory).\n\n- Performance could be improved with a more sophisticated caching strategy (for example, by sharding the images to reduce random access disk I\/O), but that would require more code.\n\n- The caching will take about 10 minutes to run in Colab with a GPU. If you'd like to see a progress bar, you can use tqdm.","5b435b89":"#### Stats and View of Training Images & Targets","2a9b87de":"# Preprocessing","57bf7943":"#### Add image paths and target captions to Python lists","f49a9fb8":"#### Preprocess and tokenize the captions\n- First, you'll tokenize the captions (for example, by splitting on spaces). This gives us a vocabulary of all of the unique words in the data (for example, \"surfing\", \"football\", and so on).\n- Next, you'll limit the vocabulary size to the top 5,000 words (to save memory). You'll replace all other words with the token \"UNK\" (unknown).\n- You then create word-to-index and index-to-word mappings.\n- Finally, you pad all sequences to be the same length as the longest one.","0aa4e28b":"# Training\n\n- You extract the features stored in the respective .npy files and then pass those features through the encoder.\n- The encoder output, hidden state(initialized to 0) and the decoder input (which is the start token) is passed to the decoder.\n- The decoder returns the predictions and the decoder hidden state.\n- The decoder hidden state is then passed back into the model and the predictions are used to calculate the loss.\n- Use teacher forcing to decide the next input to the decoder.\n- Teacher forcing is the technique where the target word is passed as the next input to the decoder.\n- The final step is to calculate the gradients and apply it to the optimizer and backpropagate.","dc0b5879":"# Image captioning with visual attention\n\n**Description:**\n- Given an image like the example below, our goal is to generate a caption such as \"a surfer riding on a wave\".\n- To accomplish this, you'll use an attention-based model, which enables us to see what parts of the image the model focuses on as it generates a caption.\n- The model architecture is similar to Show, Attend and Tell: Neural Image Caption Generation with Visual Attention.\n\n**Revisions:**\n- Using COCO 2017 dataset instead of 2014\n- Tutorial is refactored to run on Kaggle (e.g. no dataset download, etc.)\n- Addded for output for transparency\n\n**Resources:**\n- https:\/\/arxiv.org\/abs\/1502.03044\n- https:\/\/www.tensorflow.org\/tutorials\/text\/image_captioning","adadc3fd":"#### Read in the target values","aae81e0d":"# Model\n\n- Fun fact: the decoder below is identical to the one in the example for Neural Machine Translation with Attention.\n- The model architecture is inspired by the Show, Attend and Tell paper.\n- In this example, you extract the features from the lower convolutional layer of InceptionV3 giving us a vector of shape (8, 8, 2048).\n- You squash that to a shape of (64, 2048).\n- This vector is then passed through the CNN Encoder (which consists of a single Fully connected layer).\n- The RNN (here GRU) attends over the image to predict the next word.","03222afc":"# More Preprocessing"}}