{"cell_type":{"14cba791":"code","6f0bb66f":"code","4c791a85":"code","deaf063f":"code","aec0c526":"code","9f368ab8":"code","ca5b7e72":"code","f774984e":"code","0771b586":"code","810ee60a":"code","81f78dac":"code","5dbf45ce":"code","a897031e":"code","16034672":"markdown","2c139bba":"markdown","b6eebb9e":"markdown","3a1d3d56":"markdown","be6cd401":"markdown","38cbe8d2":"markdown","287c930f":"markdown","87fb1284":"markdown","2222f75b":"markdown","443c29fe":"markdown","91795113":"markdown","d35079bf":"markdown","816b8a4b":"markdown","b4e51235":"markdown","b60618bf":"markdown","da50e0f1":"markdown","20e8cc59":"markdown","6da4b418":"markdown","17ff5202":"markdown"},"source":{"14cba791":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n\nimport re\nimport json\nimport textwrap as text\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndf = pd.read_csv('\/kaggle\/input\/us-videos\/USvideos.csv',\n                 parse_dates=['trending_date'])\n\nwith open('\/kaggle\/input\/categories\/category_ids.json') as f:\n    cat_ids = json.load(f)\n\n# Just want { id: title }\ncat_ids = { int(item['id']): item['snippet']['title'] for item in cat_ids['items'] }","6f0bb66f":"most_trending = df['title'].value_counts()[:5]\n\nprint(most_trending)","4c791a85":"df = df.drop_duplicates(subset='title', keep='last')","deaf063f":"most = {\n    'viewed': 'views',\n    'commented': 'comment_count',\n    'liked': 'likes',\n    'disliked': 'dislikes'\n}\n\nfor k, v in most.items():\n    largest = df.nlargest(1, v)\n    \n    print(text.dedent(f\"\"\"\n        Most {k.title()}: {largest['title'].values[0]}\n        Channel: {largest['channel_title'].values[0]}\n        Total {k.title()}: {largest[v].values[0] :,}\n    \"\"\"))","aec0c526":"from collections import defaultdict\nimport heapq\n\ntag_counts = defaultdict(int)\n\n# Process a tag list (as string) and return list of tags\ndef process_tlist(l):\n    if l == '[none]':\n        return None\n    \n    # remove quotes and split on pipes |\n    l = l.replace('\"','').split('|')\n    return l\n\nfor t_list in df['tags']:\n    tlist = process_tlist(t_list)\n    \n    if tlist is None:\n        continue\n    \n    for tag in tlist:\n        tag_counts[tag] += 1\n\ntop_tags = heapq.nlargest(10, tag_counts, key=tag_counts.get)\nprint(f'Top Tags: {top_tags}')","9f368ab8":"import seaborn as sns \n\n# Map ids to category names\ndf['category'] = df['category_id'].map(cat_ids)\n\n# Top categories by view count\ntop_categories = df['category'].value_counts()[:5]\n\nfiltered_df = df[df['category'].isin(top_categories.index)]\n\nax = sns.catplot(x='category',\n                y='views',\n                hue='category', \n                data=filtered_df,\n                height=7,\n                aspect=1.5)\nax.set(title='Views by Top Categories')\nplt.show()\nax.savefig('\/kaggle\/working\/ViewsByTopCategories.png')","ca5b7e72":"import seaborn as sns \n\n# Top channels\ntop_channels = df['channel_title'].value_counts()[:5]\n\nfiltered_df = df[df['channel_title'].isin(top_channels.index)]\n\n# Views by top channels\nax = sns.catplot(x='channel_title', \n                y='views', \n                hue='channel_title', \n                data=filtered_df,\n                height=7,\n                aspect=1.5)\nax.set(title='Views by Top Channels')\n\nprint(top_channels)\nplt.show()\n\nax.savefig('\/kaggle\/working\/ViewsByTopChannels.png')","f774984e":"# import os, shutil, requests, time\n\n# if not os.path.exists('\/kaggle\/working\/images\/'):\n#     os.mkdir('\/kaggle\/working\/images\/')\n\n# # Mildly edited from https:\/\/www.kaggle.com\/abinesh100\/easy-download-images-in-25-lines-py3\n# # Downloads images into input\/images\/image.jpg\n# def fetch_image(path):\n#     url=path\n#     response=requests.get(url, stream=True)\n#     with open('\/kaggle\/working\/images\/image.jpg', 'wb') as out_file:\n#         shutil.copyfileobj(response.raw, out_file)\n#     del response\n    \n# links = df['thumbnail_link']\n\n# print('fetching images...')\n# i = 0\n# for link in links:\n#     # Prevent unneccessary redownload of images\n# #     if os.path.exists(f'\/kaggle\/working\/images\/{i}.jpg'):\n# #         i += 1\n# #         continue\n        \n#     fetch_image(link)\n#     os.rename('\/kaggle\/working\/images\/image.jpg', f'\/kaggle\/working\/images\/{i}.jpg')\n    \n#     i += 1\n    \n# print('images fetched!')","0771b586":"import cv2\nimport os\n\n# cv2 cascade classifier path\n# Using most relaxed default\nclassifier_path = '..\/input\/haar-cascades-for-face-detection\/haarcascade_frontalface_default.xml'\nclassifier = cv2.CascadeClassifier(classifier_path)\n\n# Generator of image paths\n# Default length is all the images in \/images\/\n# Bad practice :( but simple to code\ndef image_paths(length=False):\n    length = len(df) if not length else length\n    \n    for i in range(length):\n        yield f'..\/input\/youtube-thumbnails\/{i}.jpg'\n\n# Tweaking values with known facial images\n# known = [0, 3, 4, 5]\n# for n in known:\n#     image = cv2.imread(f'\/kaggle\/working\/images\/{n}.jpg')\n#     gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n#     faces = classifier.detectMultiScale(\n#         gray,\n#         minNeighbors=2,\n#         minSize=(5, 5),\n#     )\n\n#     print(f'Image {n}, Detected Faces: {len(faces)}')\nhas_face = []\n\nprint('classifying images')\nfor image_path in image_paths():\n    image = cv2.imread(image_path)\n    \n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n                        \n    faces = classifier.detectMultiScale(\n        gray,\n        minNeighbors=5,\n        minSize=(5, 5),\n    )\n    \n    has_face.append(len(faces) > 0)\nprint('done classifying')\n\n# len(has_face) == len(df) # sanity check","810ee60a":"df['has_face'] = pd.Series(has_face)\n\n# Top categories by view count\ntop_categories = df['category'].value_counts()[:6]\n\nfiltered_df = df[df['category'].isin(top_categories.index)]\n\nface_mask = filtered_df['has_face'] == True\n\nfor cat in top_categories.index:\n    cat_mask = filtered_df['category'] == cat\n    yes = len(filtered_df[face_mask][cat_mask])\n    no = len(filtered_df.drop(filtered_df[face_mask].index)[cat_mask])\n    print(text.dedent(f'''\n        Category: {cat}\n        Has (at least 1) face: {yes}\n        No face: {no}\n        Proportion: {yes\/no :.2f}\n    '''))\n\nsns.set(font_scale=1.2)\ng = sns.catplot(\n    x = 'has_face',\n    y = 'views',\n    col = 'category',\n    col_wrap = 3,\n    data = filtered_df\n)\ng.savefig('\/kaggle\/working\/ViewsByCategoryAndFaces.png')","81f78dac":"# Category: Howto & Style\ng = sns.catplot(\n    x = 'category',\n    y = 'views',\n    hue = 'has_face',\n    data = filtered_df[filtered_df['category'] == 'Howto & Style']\n)","5dbf45ce":"# Category: People & Blogs\ng = sns.catplot(\n    x = 'category',\n    y = 'views',\n    hue = 'has_face',\n    data = filtered_df[filtered_df['category'] == 'People & Blogs']\n)","a897031e":"import re\nfrom functools import reduce\n\n# Return proportion of capital words (converted to characters) to total characters\n# Ignores singular I's to remove some false positives\ndef proportion(s):\n    # length of all capital words in a string\n    # splits string on non-word characters\n    all_caps = [ w for w in re.split(r\"\\W\", s.replace('\"', '')) if w.isupper() and w != 'I' ]\n    total_caps = reduce(lambda x, y: x + len(y), all_caps, 0)\n    \n    return total_caps \/ len(s)\n\n# Limit the category\nentertainment = df[df['category'] == 'Entertainment']\n\ntitles = entertainment['title']\n\n# Record proportion for every row\nprop = []\nfor title in titles:\n    prop.append(proportion(title))\n    \nentertainment['caps_prop'] = prop\n\nplt.figure(figsize=(12,6))\ng = sns.scatterplot(\n    data = entertainment,\n    x = 'caps_prop',\n    y = 'views'\n)\ng.set(title='Caps_prop versus Views')\nplt.show()","16034672":"# General setup","2c139bba":"## Drop duplicates\n\nI won't be using duplicates in my exploration for now.","b6eebb9e":"## Most...","3a1d3d56":"## Most trending video (by time on list)","be6cd401":"### Script to fetch thumbnail images\nDownload takes ~100 seconds; didn't add self rate-limiting","38cbe8d2":"## Views by Top Channels","287c930f":"## Classifying\n\n- Using default classifier from cv2, haarcascade_frontalface_default\n- Takes ~1 minute","87fb1284":"# Introduction\nThe purpose of this notebook was to explore 2017-2018 daily trending YouTube data and play around with some hypotheses.","2222f75b":"## ATTENTION?\nLet's see if the proportion of capital words might affect view count...\nBut this time I'll limit the category to Entertainment.\n\nNote: there will be false positives, like \"SNL\"","443c29fe":"## Views By Top Categories","91795113":"## Most Popular Tags","d35079bf":"# Exploring the data","816b8a4b":"## What do the data show?","b4e51235":"## Enhance","b60618bf":"### Thoughts\nI would have expected a more lopsided view distribution from \"Howto & Style\" and \"People & Blogs\". \nGranted, this experiment could have gone better; the facial recognition could have been tuned finer, images could have been upscaled (maybe). A simple logistic regression might reveal insights that are not displayed in the figure, as well as other methods of separating the data.\n\nHowever, at this point, I am ready to assume that having your face in the thumbnail does not significantly impact your view count (for trending videos). \n\nBut would AN ALL-CAPS TITLE GRAB YOUR...","da50e0f1":"# Ideas to Explore\n- Faces in thumbnail versus views (OpenCV) \n    - Might be hard, thumbnail links to very small images\n- Clickbait (i.e. proportion of ALL CAPS in title)\n    - Would need to remove (official videos \/ official music videos) or restrict to a category","20e8cc59":"### Notes\n- During testing, the default cascade classifer included with OpenCV2 was not able to correctly classify many images, perhaps due to their small size and poor resolution.\n- It is unlikely that the thumbnail links in the data are the original thumbnails and rather, have been scaled down (and converted to jpg).\n- Despite these setbacks, lets move on.","6da4b418":"Nice job Logan Paul, lots of comments! You're doin' grea.. oh.","17ff5202":"Not to bash Jimmy Fallon or anything, but I've always preferred James Corden. Something about fake laughs..."}}