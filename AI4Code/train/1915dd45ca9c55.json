{"cell_type":{"695b2049":"code","51471956":"code","3a9b1213":"code","fef8907b":"code","2b8ea8c6":"code","bbfa0c4e":"code","79c721ab":"code","9ec5db24":"code","bd88c4b5":"code","6611ead8":"code","33bd6686":"code","fa2462cd":"code","a519759e":"code","7c840592":"code","eab20902":"code","2bd183f7":"code","e39e9bb8":"code","c1b6a3ae":"code","1ff54cf9":"code","0e18d6fc":"code","b552f924":"code","84220bb2":"code","c2302975":"code","ad905633":"code","1dcd9a53":"code","6956f795":"code","cb81aa76":"code","5111584f":"code","24989abb":"code","43ddd8de":"code","f71d62df":"code","582584aa":"code","4bd18e84":"code","454a2291":"code","8d55d0ba":"code","e7c998a3":"code","1db6bc15":"markdown","fc075b81":"markdown","5b26301e":"markdown","db0a8c35":"markdown","e71c060c":"markdown","64658091":"markdown","d111a8e3":"markdown","90e83294":"markdown","a78c3dc5":"markdown","6267a6e7":"markdown"},"source":{"695b2049":"!pip install kaggle","51471956":"!pip install -U lightautoml","3a9b1213":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport torch\nfrom lightautoml.automl.presets.tabular_presets import TabularAutoML\nfrom lightautoml.tasks import Task\n\nimport os\n# for dirname, _, filenames in os.walk('\/kaggle\/input'):\n    # for filename in filenames:\n        # print(os.path.join(dirname, filename))\n\n# Warning\u306e\u7121\u52b9\u5316\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# \u30c7\u30fc\u30bf\u30d5\u30ec\u30fc\u30e0colum\u306e\u5168\u8868\u793a\npd.set_option('display.max_columns', None)\n# pd.set_option('display.max_rows', None)","fef8907b":"N_THREADS = 4\nN_FOLDS = 5\nRANDOM_STATE = 42\nTIMEOUT = 72000\nTARGET_NAME = 'pressure'","2b8ea8c6":"# for reproducibility\nnp.random.seed(RANDOM_STATE)\ntorch.set_num_threads(N_THREADS)","bbfa0c4e":"from google.colab import files\n\nuploaded = files.upload()\n\nfor fn in uploaded.keys():\n    print('User uploaded file \"{name}\" with length {length} bytes'.format(\n        name=fn, length=len(uploaded[fn])))\n\n# Then move kaggle.json into the folder where the API expects to find it. ##\n!mkdir -p ~\/.kaggle\/ && mv kaggle.json ~\/.kaggle\/ && chmod 600 ~\/.kaggle\/kaggle.json","79c721ab":"!kaggle competitions list","9ec5db24":"!kaggle competitions download -c ventilator-pressure-prediction","bd88c4b5":"DEBUG = False","6611ead8":"# train = pd.read_csv('..\/input\/ventilator-pressure-prediction\/train.csv')\n# test  = pd.read_csv('..\/input\/ventilator-pressure-prediction\/test.csv')\n# submission = pd.read_csv('..\/input\/ventilator-pressure-prediction\/sample_submission.csv')","33bd6686":"train = pd.read_csv(r'..\/content\/train.csv.zip')\ntest  = pd.read_csv(r'..\/content\/test.csv.zip')\nsubmission = pd.read_csv(r'..\/content\/sample_submission.csv.zip')","fa2462cd":"if DEBUG:\n    train = train[:80*1000]","a519759e":"train.shape, test.shape, submission.shape","7c840592":"train","eab20902":"train.describe()","2bd183f7":"test['pressure'] = 0","e39e9bb8":"test","c1b6a3ae":"test.describe()","1ff54cf9":"def add_features(df):\n    df['area'] = df['time_step'] * df['u_in']\n    df['area'] = df.groupby('breath_id')['area'].cumsum()\n    \n    df['u_in_cumsum'] = (df['u_in']).groupby(df['breath_id']).cumsum()\n    \n    df['u_in_lag1'] = df.groupby('breath_id')['u_in'].shift(1)\n    df['u_out_lag1'] = df.groupby('breath_id')['u_out'].shift(1)\n    df['u_in_lag_back1'] = df.groupby('breath_id')['u_in'].shift(-1)\n    df['u_out_lag_back1'] = df.groupby('breath_id')['u_out'].shift(-1)\n    df['u_in_lag2'] = df.groupby('breath_id')['u_in'].shift(2)\n    df['u_out_lag2'] = df.groupby('breath_id')['u_out'].shift(2)\n    df['u_in_lag_back2'] = df.groupby('breath_id')['u_in'].shift(-2)\n    df['u_out_lag_back2'] = df.groupby('breath_id')['u_out'].shift(-2)\n    df['u_in_lag3'] = df.groupby('breath_id')['u_in'].shift(3)\n    df['u_out_lag3'] = df.groupby('breath_id')['u_out'].shift(3)\n    df['u_in_lag_back3'] = df.groupby('breath_id')['u_in'].shift(-3)\n    df['u_out_lag_back3'] = df.groupby('breath_id')['u_out'].shift(-3)\n    df['u_in_lag4'] = df.groupby('breath_id')['u_in'].shift(4)\n    df['u_out_lag4'] = df.groupby('breath_id')['u_out'].shift(4)\n    df['u_in_lag_back4'] = df.groupby('breath_id')['u_in'].shift(-4)\n    df['u_out_lag_back4'] = df.groupby('breath_id')['u_out'].shift(-4)\n    df = df.fillna(0)\n    \n    df['breath_id__u_in__max'] = df.groupby(['breath_id'])['u_in'].transform('max')\n    df['breath_id__u_out__max'] = df.groupby(['breath_id'])['u_out'].transform('max')\n    \n    df['u_in_diff1'] = df['u_in'] - df['u_in_lag1']\n    df['u_out_diff1'] = df['u_out'] - df['u_out_lag1']\n    df['u_in_diff2'] = df['u_in'] - df['u_in_lag2']\n    df['u_out_diff2'] = df['u_out'] - df['u_out_lag2']\n    \n    df['breath_id__u_in__diffmax'] = df.groupby(['breath_id'])['u_in'].transform('max') - df['u_in']\n    df['breath_id__u_in__diffmean'] = df.groupby(['breath_id'])['u_in'].transform('mean') - df['u_in']\n    \n    df['breath_id__u_in__diffmax'] = df.groupby(['breath_id'])['u_in'].transform('max') - df['u_in']\n    df['breath_id__u_in__diffmean'] = df.groupby(['breath_id'])['u_in'].transform('mean') - df['u_in']\n    \n    df['u_in_diff3'] = df['u_in'] - df['u_in_lag3']\n    df['u_out_diff3'] = df['u_out'] - df['u_out_lag3']\n    df['u_in_diff4'] = df['u_in'] - df['u_in_lag4']\n    df['u_out_diff4'] = df['u_out'] - df['u_out_lag4']\n    df['cross']= df['u_in']*df['u_out']\n    df['cross2']= df['time_step']*df['u_out']\n    \n    df['R'] = df['R'].astype(str)\n    df['C'] = df['C'].astype(str)\n    df['R__C'] = df[\"R\"].astype(str) + '__' + df[\"C\"].astype(str)\n    df = pd.get_dummies(df)\n    return df","0e18d6fc":"train = add_features(train)\ntest = add_features(test)","b552f924":"train","84220bb2":"train.shape","c2302975":"train.info()","ad905633":"test","1dcd9a53":"test.shape","6956f795":"task = Task('reg', loss='mae', metric='mae')","cb81aa76":"roles = {\n    'drop': 'id',\n    'group': 'breath_id', # for group k-fold\n    'target': TARGET_NAME\n}","5111584f":"%%time\n# Fitting\nautoml = TabularAutoML(task=task, \n                       timeout=TIMEOUT,\n                       cpu_limit=N_THREADS,\n                       reader_params={'n_jobs': N_THREADS, 'cv': N_FOLDS, 'random_state': RANDOM_STATE},\n                       general_params={'use_algos': [['lgb', 'lgb_tuned', 'linear_l2']]},\n                       tuning_params={'max_tuning_time': 1800}\n                      )\nautoml.fit_predict(train, roles=roles)","24989abb":"# Prediction\ntest_pred = automl.predict(test)","43ddd8de":"test_pred","f71d62df":"submission[TARGET_NAME] = test_pred.data[:, 0]","582584aa":"fi_score = automl.get_feature_scores('fast').sort_values('Importance', ascending=True)","4bd18e84":"plt.figure(figsize=(10, 30))\nfi_score.set_index('Feature')['Importance'].plot.barh(fontsize=16)\nplt.title('Feature importance', fontsize=18)\nplt.show()","454a2291":"submission","8d55d0ba":"submission.to_csv('submission.csv', index=False)\nprint('.\/submission.csv')","e7c998a3":"!kaggle competitions submit -c ventilator-pressure-prediction -f submission.csv -m \"Message\"","1db6bc15":"## Libraries","fc075b81":"#### Task setup\nOn the cell below we create Task object - the class to setup what task LightAutoML model should solve with specific loss and metric if necessary (more info can be found here in our documentation):\n\nadd Codeadd Markdown","5b26301e":"![lautoml.PNG](attachment:cf1dfdc2-c77c-4124-bc63-721451d1e6d0.PNG)","db0a8c35":"## LightAutoML model building","e71c060c":"## Export","64658091":"#### Feature roles setup\nTo solve the task, we need to setup columns roles. The only role you must setup is target role, everything else (drop, numeric, categorical, group, weights etc.) is up to user - LightAutoML models have automatic columns typization inside:","d111a8e3":"## Load Data","90e83294":"#### Feature importance\nFor feature importances calculation we have 2 different methods in LightAutoML:\n\n- Fast (fast) - this method uses feature importances from feature selector LGBM model inside LightAutoML. It works extremely fast and almost always (almost because of situations, when feature selection is turned off or selector was removed from the final models with all GBM models). no need to use new labelled data.\n- Accurate (accurate) - this method calculate features permutation importances for the whole LightAutoML model based on the new labelled data. It always works but can take a lot of time to finish (depending on the model structure, new labelled dataset size etc.).","a78c3dc5":"Here we setup the constants to use in the kernel:\n\n- N_THREADS - number of vCPUs for LightAutoML model creation\n- N_FOLDS - number of folds in LightAutoML inner CV\n- RANDOM_STATE - random seed for better reproducibility\n- TIMEOUT - limit in seconds for model to train\n- TARGET_NAME - target column name in dataset","6267a6e7":"## Add Feature"}}