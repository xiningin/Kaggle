{"cell_type":{"5a2bd1ae":"code","229cf0ae":"code","748fe852":"code","864718bd":"code","65dda779":"code","f1b2b341":"code","31970957":"code","92058fbe":"code","cf4fb7ca":"code","e5096b14":"markdown","434810e4":"markdown","7aa0c9af":"markdown","61990b8e":"markdown","fe272ce4":"markdown","85520529":"markdown","5d5cd7e5":"markdown","7288ecaa":"markdown","76102ed9":"markdown"},"source":{"5a2bd1ae":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","229cf0ae":"from PIL import Image\nfrom torchvision import transforms\nfrom matplotlib import pyplot as plt\nimport os\n\npreprocess = transforms.Compose([\n   transforms.Resize(224),\n   transforms.ToTensor(),\n])\n\nkaggle_dir = \"\/kaggle\/input\/myimages\"\ntensor_dict = {}\nfor fn in sorted(os.listdir(kaggle_dir)):\n    name, ext = os.path.splitext(fn)\n    if not ext.lower() in ['.jpg', 'jpeg']:\n        continue\n    t_img = Image.open(os.path.join(kaggle_dir, fn))\n    t_tensor = preprocess(t_img)[None,:,:,:]\n    tensor_dict[name] = t_tensor\n\nfig = plt.figure(figsize=(5, 40))\nfor fn_idx, name in enumerate(tensor_dict):\n    ax = fig.add_subplot(len(tensor_dict), 1, fn_idx+1)\n    ax.title.set_text(name)\n    # plot image (note that numpy using HWC whereas Pytorch user CHW, so we need to convert)\n    ax.imshow(tensor_dict[name][0].numpy().transpose(1,2,0))\n\n","748fe852":"import torch\nimport torch.nn as nn\nfrom torchvision.models import resnet\n\n# simple Module to normalize an image\nclass Normalize(nn.Module):\n    def __init__(self, mean, std):\n        super(Normalize, self).__init__()\n        self.mean = torch.Tensor(mean)\n        self.std = torch.Tensor(std)\n    def forward(self, x):\n        return (x - self.mean.type_as(x)[None,:,None,None]) \/ self.std.type_as(x)[None,:,None,None]\n\n# values are standard normalization for ImageNet images, \n# from https:\/\/github.com\/pytorch\/examples\/blob\/master\/imagenet\/main.py\nnorm = Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])\n\n# load pre-trained ResNet50, and put into evaluation mode (necessary to e.g. turn off batchnorm)\nmodel = resnet.resnet50(pretrained=True)\nmodel.eval()\nprint(\"Model RESNET50 - Successfully Loaded\")\n","864718bd":"import json\nwith open(\"\/kaggle\/input\/models\/imagenet_class_index.json\") as f:\n    imagenet_classes = {int(i):x[1] for i,x in json.load(f).items()}\nimagenet_class_idxs = {cls: cls_idx for cls_idx, cls in imagenet_classes.items()}\n\n# form predictions\nprint(\"Predicting %s\" % (list(tensor_dict.keys())))\npred_dict = {}\nfor name, t_tensor in tensor_dict.items():\n    t_pred = model(norm(t_tensor))\n    cls_idx = t_pred.max(dim=1)[1].item()\n    pred_dict[name] = cls_idx\n    cls = imagenet_classes[cls_idx]\n    tensor = tensor_dict[name]\n    loss = nn.CrossEntropyLoss()(model(norm(tensor)),torch.LongTensor([cls_idx])).item()\n    print('\\t%s:\\tpredicted as %s (id %d) (cross entropy loss %5.5lf)' % (name, cls, cls_idx, loss))\n","65dda779":"import numpy as np\nimport seaborn as sns\nimport itertools\n\nsorted_names = sorted(pred_dict.keys())\nsorted_classes = sorted(set([imagenet_classes[cls_idx] for cls_idx in pred_dict.values()]))\nsorted_cls_idxs = [imagenet_class_idxs[cls] for cls in sorted_classes]\nloss_matrix = np.zeros((len(sorted_names), len(sorted_cls_idxs)))\nrow_idx, col_idx = 0, 0\nfor name in sorted_names:\n    loss_row = []\n    for cls_idx in sorted_cls_idxs:\n        loss = nn.CrossEntropyLoss()(model(norm(tensor_dict[name])),torch.LongTensor([cls_idx])).item()\n        loss_matrix[row_idx, len(loss_row)] = loss\n        loss_row.append(loss)\n    row_idx += 1\n    print(\"%s --> %s\" % (name, ', '.join(['%4.4lf' % loss for loss in loss_row])))\n    \nax = sns.heatmap(loss_matrix, linewidth=0.5, xticklabels=sorted_classes, yticklabels=sorted_names)\n\nplt.show()","f1b2b341":"import torch.optim as optim\nepsilon = 2.\/255\nmin_steps, max_steps = 30, 100\n# min_steps, max_steps = 10, 20 # USE FOR QUICK EXECUTION\nloss_threshold = 20\n\nadversarial_tensors = {}\nfor img_idx, (name, tensor) in enumerate(tensor_dict.items()):\n    true_class_idx = pred_dict[name]\n    true_class = imagenet_classes[true_class_idx]\n    print(\"Creating adversarial example from image %s %d\/%d (evade class %s)\" % (name, img_idx+1, len(tensor_dict), true_class))\n    delta = torch.zeros_like(tensor, requires_grad=True)\n    opt = optim.SGD([delta], lr=1e-1)\n    \n    true_Y = torch.LongTensor([true_class_idx])\n    step = 1\n    while True:\n        step_tensor = tensor + delta\n        step_norm_tensor = norm(step_tensor) \n        step_pred = model(step_norm_tensor)\n        step_loss = nn.CrossEntropyLoss()(step_pred, true_Y)\n        step_loss_val = step_loss.item()\n        step_opposite_loss_gradient = -step_loss\n        \n        if step % 5 == 0:\n            print(\"\\tStep %.3d\/%d - loss (from %s) %8.8lf\" % (step, max_steps, true_class, step_loss_val))\n    \n        opt.zero_grad()\n        step_opposite_loss_gradient.backward()\n        opt.step()\n        # Project to the epsilon ball\n        delta.data.clamp_(-epsilon, epsilon)\n        \n        step += 1\n        \n        if step < min_steps:\n            continue\n        if step > max_steps:\n            break\n        if step_loss_val >= loss_threshold:\n            break\n            \n    # Experiment done - print summary\n    true_class_succ_prob = nn.Softmax(dim=1)(step_pred)[0,true_class_idx].item()\n    max_class_idx = step_pred.max(dim=1)[1].item()\n    max_class = imagenet_classes[max_class_idx]\n    max_class_prob = nn.Softmax(dim=1)(step_pred)[0,max_class_idx].item()\n    \n    if step_loss_val >= loss_threshold:\n        print(\"%s: Awesome Adversarial example ready by %d steps\" % (name, step))\n        print(\"\\tMax Class %s (%d) prob %4.4lf\" % (max_class, max_class_idx, max_class_prob))\n        print(\"\\tInstead of True Class %s (%d) prob %4.4lf (loss %8.8lf)\" % (true_class, true_class_idx, true_class_succ_prob, step_loss_val))\n    elif not max_class_idx == true_class_idx:\n        print(\"%s: Medium Adversarial example ready by %d steps\" % (name, step))\n        print(\"\\tMax Class %s (%d) prob %4.4lf\" % (max_class, max_class_idx, max_class_prob))\n        print(\"\\tInstead of True Class %s (%d) prob %4.4lf (loss %8.8lf)\" % (true_class, true_class_idx, true_class_succ_prob, step_loss_val))\n    else:\n        print(\"%s: Adversarial example FAILED\" % name)\n        print(\"\\tMax Class == True Class %s (%d) prob %4.4lf\" % (max_class, max_class_idx, max_class_prob))\n        assert true_class == max_class and true_class_idx == max_class_idx and true_class_succ_prob == max_class_prob\n        # print(\"\\tTrue Class %s (%d) prob %4.4lf\" % (true_class, true_class_idx, true_class_succ_prob))\n    adversarial_tensors[name] = (step_loss_val >= loss_threshold, not max_class_idx == true_class_idx, \\\n                                 step_tensor, step_tensor-tensor, \\\n                                 step, \\\n                                 true_class, step_loss_val, true_class_succ_prob, \\\n                                 max_class, max_class_prob \\\n                                )\n","31970957":"fig = plt.figure(figsize=(15, 50))\nname_idx = 0\n\nfor name, tup in adversarial_tensors.items():\n    is_success, is_success2, \\\n    new_tensor, diff_tensor, \\\n    step_num, \\\n    true_class, true_class_loss_val, true_class_succ_prob, \\\n    max_class, max_class_prob = tup\n    \n    orig_tensor = new_tensor - diff_tensor\n\n    succ_str = \"AWESOME SUCCESS\" if is_success else (\"SUCCESS\" if is_success2 else \"FAILURE\")\n    ax = fig.add_subplot(len(adversarial_tensors), 3, 3*name_idx+1)\n    title = '%s (%s --> * ) %s \\n %d steps to prob %4.4lf loss %4.4lf \\n Identified as %s prob %4.4lf \\n Perturbation Norm %2.2lf' % \\\n        (name, true_class, succ_str, step_num, true_class_succ_prob, true_class_loss_val, \\\n         max_class, max_class_prob, torch.norm(diff_tensor).item())\n    ax.title.set_text(title)\n    ax.imshow(new_tensor[0].detach().numpy().transpose(1,2,0))\n\n    ax = fig.add_subplot(len(adversarial_tensors), 3, 3*name_idx+2)\n    ax.title.set_text(\"The Perturbation (multipled x 50) \\n Norm %2.2lf\" % torch.norm(diff_tensor).item())\n    # ax.imshow((50*diff_tensor+0.5)[0].detach().numpy().transpose(1,2,0))\n    ax.imshow((50*diff_tensor)[0].detach().numpy().transpose(1,2,0))\n\n    ax = fig.add_subplot(len(adversarial_tensors), 3, 3*name_idx+3)\n    ax.title.set_text(\"Original Image\")\n    orig_tensor = tensor_dict[name]\n    ax.imshow((orig_tensor)[0].detach().numpy().transpose(1,2,0))\n\n    name_idx += 1","92058fbe":"import random\n\ntarget_class_idxs = [random.randrange(1000) for i in range(3)]\ntarget_classes = [imagenet_classes[cls_idx] for cls_idx in target_class_idxs]\nprint(\"Trying to create targetted attack towards classes %s\" % target_classes)\n\nmin_steps, max_steps = 50, 200\nloss_threshold_factor = 5\n# min_steps, max_steps = 10, 20\n\ntargeted_adversarial_tensors = {}\nfor name, tensor in tensor_dict.items():\n    true_class_idx = pred_dict[name]\n    true_class = imagenet_classes[true_class_idx]\n    \n    targeted_adversarial_tensors[name] = {}\n\n    for trgt_cls_idx, target_class in zip(target_class_idxs, target_classes):\n        print(\"Creating adversarial example from %s (%s --> %s)\" % (name, true_class, target_class))\n        delta = torch.zeros_like(tensor, requires_grad=True)\n        opt = optim.SGD([delta], lr=5e-3)\n    \n        true_Y = torch.LongTensor([true_class_idx])\n        target_Y = torch.LongTensor([trgt_cls_idx])\n        step = 0\n        \n        while True:\n            step_diff_norm = torch.norm(delta).item()\n            step_tensor = tensor + delta\n            step_norm_tensor = norm(step_tensor) \n            step_pred = model(step_norm_tensor)\n            step_loss_for_true = nn.CrossEntropyLoss()(step_pred, true_Y)\n            step_loss_for_target = nn.CrossEntropyLoss()(step_pred, target_Y)\n            step_gradient = step_loss_for_target - step_loss_for_true\n            \n            step_loss_target_val = step_loss_for_target.item()\n            step_loss_true_val = step_loss_for_true.item()\n                \n            if step % 5 == 0:\n                print(\"\\t%d steps - cross_entropy_loss (true %s) %8.8lf - cross_entropy_loss (target %s) %8.8lf (perturbation norm %2.2lf)\" % \\\n                      (step, true_class, step_loss_for_true, target_class, step_loss_for_target, step_diff_norm))\n    \n            opt.zero_grad()\n            step_gradient.backward()\n            opt.step()\n\n            # Project to the epsilon ball\n            delta.data.clamp_(-epsilon, epsilon)\n            step += 1\n        \n            if step < min_steps:\n                continue\n            if step > max_steps:\n                break\n            if step_loss_target_val < loss_threshold_factor * step_loss_true_val:\n                break\n            \n            \n        true_class_succ_prob = nn.Softmax(dim=1)(step_pred)[0,true_class_idx].item()\n        target_class_succ_prob = nn.Softmax(dim=1)(step_pred)[0,trgt_cls_idx].item()\n        max_class_idx = step_pred.max(dim=1)[1].item()\n        max_class = imagenet_classes[max_class_idx]\n        max_class_prob = nn.Softmax(dim=1)(step_pred)[0,max_class_idx].item()\n        if max_class_idx == trgt_cls_idx:\n            print(\"%s: Awesome Adversarial example ready %s --> %s\" % (name, true_class, target_class))\n            print(\"\\tMax Class %s (%d) prob %4.4lf\" % (max_class, max_class_idx, max_class_prob))\n            print(\"\\tInstead of True Class %s (%d) prob %lf\" % (true_class, true_class_idx, true_class_succ_prob))\n        elif not max_class_idx == true_class_idx:\n            print(\"%s: Medium Adversarial example ready %s --> %s (instead of %s)\" % (name, true_class, max_class, target_class))\n            print(\"\\tMax Class %s (%d) prob %4.4lf\" % (max_class, max_class_idx, max_class_prob))\n            print(\"\\tInstead of True Class %s (%d) prob %lf\" % (true_class, true_class_idx, true_class_succ_prob))            \n        else:\n            print(\"%s: Adversarial example FAILED %s --> %s\" % (name, true_class, target_class))\n            print(\"\\tMax Class %s (%d) prob %4.4lf\" % (max_class, max_class_idx, max_class_prob))\n            print(\"\\tTrue Class %s (%d) prob %lf\" % (true_class, true_class_idx, true_class_succ_prob))\n\n        targeted_adversarial_tensors[name][target_class] = (\\\n            max_class_idx == trgt_cls_idx, not max_class_idx == true_class_idx, \\\n            step_tensor, step_tensor-tensor, \\\n            step, \\\n            true_class, true_class_succ_prob, step_loss_true_val, \\\n            target_class, target_class_succ_prob, step_loss_target_val, \\\n            max_class, max_class_prob \\\n        )","cf4fb7ca":"fig = plt.figure(figsize=(18, 70))\nrow_num = len(targeted_adversarial_tensors)\ncol_num = len(list(targeted_adversarial_tensors.values())[0])\nnext_img = 1\nfor img_name, d in targeted_adversarial_tensors.items():\n    for target_class, tup in d.items():\n        is_success, is_success2, new_tensor, tensor_diff, step_num, \\\n            true_class, true_class_succ_prob, true_loss_val, \\\n            target_class, target_class_succ_prob, target_loss_val, max_class, max_class_prob = tup\n\n        ax = fig.add_subplot(row_num, col_num, next_img)\n        next_img += 1\n        succ_str = \"AWESOME SUCCESS\" if is_success else (\"MEDIUM SUCCESS\" if is_success2 else \"FAILURE\")\n        title = '%s \\n (%s --> %s) %s! \\n %d steps (perturbation norm %2.2lf) \\n true_prob %2.2lf (target prob %4.4lf) \\n true_loss %2.2lf (target loss %2.2lf) \\n Identified as %s prob %2.2lf' % \\\n            (img_name, true_class, target_class, succ_str, step_num, torch.norm(tensor_diff).item(), true_class_succ_prob, target_class_succ_prob, true_loss_val, target_loss_val, max_class, max_class_prob)\n        ax.title.set_text(title)\n        ax.imshow(new_tensor[0].detach().numpy().transpose(1,2,0))\n","e5096b14":"Based on Adversarial Machine Learning tutorial at https:\/\/adversarial-ml-tutorial.org\/introduction\/","434810e4":"# Load RESNET50 model","7aa0c9af":"# Load Images","61990b8e":"# Present files in the environment","fe272ce4":"# Model Evasion","85520529":"# Run RESNET50 predictions on images","5d5cd7e5":"# Cross prediction for all images x all classes","7288ecaa":"[](http:\/\/)","76102ed9":"# View the perturbated images"}}