{"cell_type":{"ff509014":"code","a8c4aa33":"code","4f6d592a":"code","0ba1d9ea":"code","63eab47c":"code","1e3c3dc8":"code","a3226c58":"code","879f7abc":"code","cd96c7a9":"code","c22e1663":"code","db272e63":"code","7919c407":"code","16f5880f":"code","ab40a008":"code","e6e854cf":"code","1d6ff7f0":"code","fb80589a":"code","761d95bb":"code","97a0bfe8":"code","fd1c758a":"code","1b976146":"code","7492e715":"code","188f10d7":"code","cf3f6a49":"code","b6ee975d":"code","0e93d672":"code","c78e2ab2":"code","7263c902":"code","cb906f8a":"code","dfa95022":"code","e7163b6a":"code","8e7d6558":"code","e3c4f12e":"code","b73a2d3d":"code","82cbb70d":"code","bd3b646f":"code","b34df25a":"code","0dea197c":"code","baaea3c8":"code","6d8b0a50":"code","6480026b":"code","af7d21fb":"code","cf2449b1":"code","33580894":"code","3826c51f":"markdown","a4b87f62":"markdown","65578895":"markdown"},"source":{"ff509014":"#current directory \n# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.\n","a8c4aa33":"# Load Movies Metadata\n\nmovies = pd.read_csv('..\/input\/tmdb_5000_movies.csv', low_memory=False)\ncredit = pd.read_csv('..\/input\/tmdb_5000_credits.csv', low_memory=False)\n","4f6d592a":"# Print the first three rows : movies \nmovies.head(3)","0ba1d9ea":"# Print the first three rows : credits\ncredit.head(3)","63eab47c":"# Simple Recommender : IMDb Top 250    \n\n# As a first step, let's calculate the value of C, the mean rating across all movies:\n\n# Calculate C\n\nC =  movies['vote_average'].mean()\nprint(C)\n\n\n","1e3c3dc8":"#The average rating of a movie on IMDB is around 6.09, on a scale of 10.\n#Next, let's calculate the number of votes, m, received by a movie in the 90th percentile. \n#The pandas library makes this task extremely trivial using the .quantile() method of a pandas Series:\n\n\n# Calculate the minimum number of votes required to be in the chart, m\nm = movies['vote_count'].quantile(0.90)\nprint(m)\n\n#the minimum number of votes required to be in the in the chart is equal to 1838.","a3226c58":"# Filter out all qualified movies into a new DataFrame  q_movies\nq_movies = movies.copy().loc[movies['vote_count'] >= m]\nq_movies.shape\n\n\n#There are 481 movies qualified, i.e that have a vote count > 1838  ( 90% percentile)","879f7abc":"# Function that computes the weighted rating of each movie\ndef weighted_rating(x, m=m, C=C):\n    v = x['vote_count']\n    R = x['vote_average']\n    # Calculation based on the IMDB formula\n    return (v\/(v+m) * R) + (m\/(m+v) * C)","cd96c7a9":"# Define a new feature 'score' and calculate its value with `weighted_rating()`\nq_movies['score'] = q_movies.apply(weighted_rating, axis=1)\n\n#Sort movies based on score calculated above\nq_movies = q_movies.sort_values('score', ascending=False)","c22e1663":"#Print the top 10 movies\nq_movies[['title', 'vote_count', 'vote_average', 'score']].head(10)\n","db272e63":"\n#We have to say that this recommender reflect more the popularity audience, \n#since it does not go deep with a better understanding of our attributes such as  overview, \n#keywords, genres , cast or crew. \n","7919c407":"\n#In this section, we  build a system that recommends movies that are similar \n#to a particular movie. More specifically, we will compute pairwise similarity \n#scores for all movies based on their plot descriptions ( overview) and \n#recommend movies based on that similarity score.\n\n\n#Print plot overviews of the first 5 movies.\nmovies['overview'].head(5)","16f5880f":"'''\nIn its current form, it is not possible to compute the similarity between any two overviews. To do this, you need to compute the word vectors of each overview or document, as it will be called from now on.\n\nwe compute Term Frequency-Inverse Document Frequency (TF-IDF) vectors for each document. This will give you a matrix where each column represents a word in the overview vocabulary (all the words that appear in at least one document) and each column represents a movie, as before.\n\nIn its essence, the TF-IDF score is the frequency of a word occurring in a document, down-weighted by the number of documents in which it occurs. \nThis is done to reduce the importance of words that occur frequently in plot overviews and therefore, their significance in computing the final similarity score.\n\nscikit-learn gives us a built-in TfIdfVectorizer class that produces the TF-IDF matrix .\n'''\n\n#Import TfIdfVectorizer from scikit-learn\nfrom sklearn.feature_extraction.text import TfidfVectorizer\n\n#Define a TF-IDF Vectorizer Object. Remove all english stop words such as 'the', 'a'\ntfidf = TfidfVectorizer(stop_words='english')\n\n\n#Replace NaN with an empty string\nmovies['overview'] = movies['overview'].fillna('')\n","ab40a008":"#Construct the required TF-IDF matrix by fitting and transforming the data\ntfidf_matrix = tfidf.fit_transform(movies['overview'])\n\n\n#Output the shape of tfidf_matrix\ntfidf_matrix.shape\n\n\n#tfidf_matrix.todense()\n\n# we see that over 20978 different words were used to describe the 4803 movies in our dataset.\n","e6e854cf":"#Since we have used the TF-IDF vectorizer, \n#calculating the dot product will directly give you the cosine similarity score. \n#we use sklearn's linear_kernel() instead of cosine_similarities() since it is faster.\n\n\n# Import linear_kernel\nfrom sklearn.metrics.pairwise import linear_kernel\n\n# Compute the cosine similarity matrix\ncosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)\ncosine_sim","1d6ff7f0":"# recommender model creation  \n\n'''\nwe are going to define a function that takes in a movie title as an input and outputs \na list of the 10 most similar movies. Firstly, we need a reverse mapping of movie titles \nand DataFrame indices. In other words, we need a mechanism to identify the index of a movie in the\nmovie DataFrame, given its title.\n'''\n\n#Construct a reverse map of indices and movie titles\nindices = pd.Series(movies.index, index=movies['title']).drop_duplicates()\nindices","fb80589a":"# Function that takes in movie title as input and outputs most similar movies\n# The steps are explained in Team38.pdf3\n\ndef get_recommendations(title, cosine_sim=cosine_sim):\n    \n    # Get the index of the movie that matches the title\n    idx = indices[title]\n\n    # Get the pairwsie similarity scores of all movies with that movie\n    sim_scores = list(enumerate(cosine_sim[idx]))\n\n    # Sort the movies based on the similarity scores\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n\n    # Get the scores of the 10 most similar movies\n    sim_scores = sim_scores[1:11]\n\n    # Get the movie indices\n    movie_indices = [i[0] for i in sim_scores]\n\n\n    # Return the top 10 most similar movies\n    return movies['title'].iloc[movie_indices]","761d95bb":"get_recommendations('Pulp Fiction') ","97a0bfe8":"get_recommendations('Titanic') ","fd1c758a":"get_recommendations('The Dark Knight Rises')","1b976146":"#we observe that the system has done a decent job of finding movies\n#with similar plot descriptions, however the quality of the recommendations\n#can be ameliorate.\n\n#For example ,\"The Dark Knight Rises\" returns all Batman movies while it's more\n#likely that the people who liked that movie are more inclined to enjoy other Christopher Nolan\n#movies. This is something that cannot be captured by the present recommender. Thats why we are going\n#to investigate  other metadata such as keywords, genres and credits  to build an improved recommender system.","7492e715":"\n#It goes without saying that the quality of your recommender would be increased with the usage of better metadata. \n#That is exactly what you are going to do in this section. \n#You are going to build a recommender based on the following metadata: \n#the 3 top actors, the director, related genres and the movie plot keywords. \n","188f10d7":"credit.info()\n","cf3f6a49":"# Convert IDs to int. Required for merging\n\ncredit.rename(columns={'movie_id': 'id'}, inplace=True)\n\ncredit['id'] = credit['id'].astype('int')\nmovies['id'] = movies['id'].astype('int')","b6ee975d":"# Merge credits into your main movie dataframe\n\nmovies_full = movies.merge(credit, on=['id' , 'title'])\n\nmovies_full.info()\nmovies_full.describe()","0e93d672":"#From the new features, cast, crew and keywords, we need to extract the three most \n#important actors, the director and the keywords associated with that movie.\n#Right now, our data is present in the form of \"stringified\" lists. \n#we need to convert them into a form that is usable .\n\n# Parse the stringified features into their corresponding python objects\nfrom ast import literal_eval\n\nfeatures = ['cast', 'crew', 'keywords', 'genres']\nfor feature in features:\n    movies_full[feature] = movies_full[feature].apply(literal_eval)\n\n","c78e2ab2":"#Next, we write functions that will help us to extract the required information \n#from each feature. First, we'll import the NumPy package to get access to its NaN constant.\n#Next, we can use it to write the get_director() function:\n\n\n# Import Numpy \nimport numpy as np\n\n# Get the director's name from the crew feature. If director is not listed, return NaN\ndef get_director(x):\n    for i in x:\n        if i['job'] == 'Director':\n            return i['name']\n    return np.nan\n","7263c902":"# Returns the list top 3 elements or entire list; whichever is more.\n    \ndef get_list(x):\n    if isinstance(x, list):\n        names = [i['name'] for i in x]\n        #Check if more than 3 elements exist. If yes, return only first three. If no, return entire list.\n        if len(names) > 3:\n            names = names[:3]\n        return names\n\n    #Return empty list in case of missing\/malformed data\n    return []","cb906f8a":"# Define new director, cast, genres and keywords features that are in a suitable form.\nmovies_full['director'] = movies_full['crew'].apply(get_director)\n\nfeatures = ['cast', 'keywords', 'genres']\nfor feature in features:\n    movies_full[feature] = movies_full[feature].apply(get_list)","dfa95022":"# Print the new features of the first 3 films\n\nmovies_full[['title', 'cast', 'director', 'keywords', 'genres']].head(3)\n\n","e7163b6a":"'''\nThe next step would be to convert the names and keyword instances into lowercase and strip all the spaces between them. \nThis is done so that your vectorizer doesn't count the Johnny of \"Johnny Depp\" and \"Johnny Galecki\" as the same.\nAfter this processing step, the aforementioned actors will be represented as \"johnnydepp\" and \"johnnygalecki\" and \nwill be distinct to your vectorizer.\n'''\n\n\n# Function to convert all strings to lower case and strip names of spaces\ndef clean_data(x):\n    if isinstance(x, list):\n        return [str.lower(i.replace(\" \", \"\")) for i in x]\n    else:\n        #Check if director exists. If not, return empty string\n        if isinstance(x, str):\n            return str.lower(x.replace(\" \", \"\"))\n        else:\n            return ''\n","8e7d6558":"# Apply clean_data function to your features.\nfeatures = ['cast', 'keywords', 'director', 'genres']\n\nfor feature in features:\n    movies_full[feature] = movies_full[feature].apply(clean_data)\n    ","e3c4f12e":"#We are now in a position to create your \"metadata soup\", which is a string that \n#contains all the metadata that you want to feed to your vectorizer (namely actors, director and keywords).    \n\nmovies_full.head(10)\n\ndef create_soup(x):\n    return ' '.join(x['keywords']) + ' ' + ' '.join(x['cast']) + ' ' + x['director'] + ' ' + ' '.join(x['genres'])\n\n","b73a2d3d":"# Create a new soup feature\nmovies_full['soup'] = movies_full.apply(create_soup, axis=1)    \n\nmovies_full[['title','director', 'soup']].head(3)","82cbb70d":"'''\nThe next steps are the same as what we did with our plot description based recommender. \nOne important difference is that you use the CountVectorizer() instead of TF-IDF. \nThis is because you do not want to down-weight the presence of an actor\/director \nif he or she has acted or directed in relatively more movies. \nIt doesn't make much intuitive sense.\n'''\n\n\n# Import CountVectorizer and create the count matrix\nfrom sklearn.feature_extraction.text import CountVectorizer\n\ncount = CountVectorizer(stop_words='english')\ncount_matrix = count.fit_transform(movies_full['soup'])\n\n\n# Compute the Cosine Similarity matrix based on the count_matrix\nfrom sklearn.metrics.pairwise import cosine_similarity\n\ncosine_sim2 = cosine_similarity(count_matrix, count_matrix)\ncosine_sim2","bd3b646f":"# Reset index of your main DataFrame and construct reverse mapping as before\nmovies_full = movies_full.reset_index() \nindices = pd.Series(movies_full.index, index=movies_full['title'])\n\n\nmovies_full[['title','genres']].head(5)","b34df25a":"get_recommendations('Titanic', cosine_sim2)","0dea197c":"#We can now reuse your get_recommendations() function by passing in the new cosine_sim2 matrix as your second argument.\n\nget_recommendations('The Dark Knight Rises', cosine_sim2)\n","baaea3c8":"\n#we observe that our recommender has been successful in capturing more information due to more metadata and has given us (arguably) better recommendations.\n#for example, the recommender for the Dark knight rises doesn't output all the Batman movies anymore. \n#The recommendations seem to have recognized other Christopher Nolan movies (due to the high weightage given to director) and put them as top recommendations. \n\n\n#One thing that we notice about our recommendation system is that it recommends movies regardless of ratings and popularity.\n#It is true that Catwoman has a lot of similar characters as compared to The Batman begins but it was a terrible movie that shouldn't be recommended to anyone.\n#Many critics consider it to be one of the worst films of all time.(https:\/\/en.wikipedia.org\/wiki\/Catwoman_(film)#cite_note-4)\n\n#Therefore, we will add a mechanism to remove bad movies and return movies which are popular and have had a good critical response.\n\n#I will take the top 25 movies based on similarity scores and calculate the vote of the 60th percentile movie. \n#Then, using this as the value of $m$, we will calculate the weighted rating of each movie using IMDB's formula like we did in the Simple Recommender section.\n","6d8b0a50":"movies_full.info()","6480026b":"pd.options.mode.chained_assignment = None\n\ndef improved_recommendations(title):\n    idx = indices[title]\n    sim_scores = list(enumerate(cosine_sim2[idx]))\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n    sim_scores = sim_scores[1:26]\n    movie_indices = [i[0] for i in sim_scores]\n    \n    movie = movies_full.iloc[movie_indices][['title', 'vote_count', 'vote_average', 'release_date']]\n    vote_counts = movie[movie['vote_count'].notnull()]['vote_count'].astype('int')\n    vote_averages = movie[movie['vote_average'].notnull()]['vote_average'].astype('int')\n    C = vote_averages.mean()\n    m = vote_counts.quantile(0.60)\n    qualified = movie[(movie['vote_count'] >= m) & (movie['vote_count'].notnull()) & (movie['vote_average'].notnull())]\n    qualified['vote_count'] = qualified['vote_count'].astype('int')\n    qualified['vote_average'] = qualified['vote_average'].astype('int')\n    qualified['wr'] = qualified.apply(weighted_rating, axis=1)\n    qualified = qualified.sort_values('wr', ascending=False).head(10)\n    return qualified","af7d21fb":"improved_recommendations('Titanic')","cf2449b1":"improved_recommendations('The Dark Knight Rises')","33580894":"\n#Now we can see that the recommendations seem to have recognized not only other Christopher Nolan movies , not only fill with \n#the 3 top actors, the director, related genres and the movie plot keywords characteristics,  but also the popularity of the movie.\n\n#you can find these ideas implemented in the following github repo : https:\/\/github.com\/rounakbanik\/movies\/blob\/master\/movies_recommender.ipynb","3826c51f":"# simple recommender ( IMDb Top 250 formula)","a4b87f62":"# genres, keywords, credits (cast & crew) recommender","65578895":"# Plot description based recommender (movie overview)"}}