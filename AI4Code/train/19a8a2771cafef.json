{"cell_type":{"9403889e":"code","1708ad63":"code","27e1cb6f":"code","5d7b3690":"code","5101d35b":"code","8f3a9dbe":"code","43a35219":"code","fb31ac10":"code","ae0cbeab":"code","b5fa0f19":"code","75541924":"code","33cdf0c8":"code","c9bbdf8a":"code","cd67c432":"code","43cc5043":"code","30f965b4":"code","6f093e29":"code","db2d002c":"code","a6e8919c":"code","91f4ec15":"code","06840b18":"code","3a670004":"code","50e02fbf":"code","f66b8658":"code","fb4bfcd6":"code","1e0b29ce":"code","fb186d78":"code","2ec7d36d":"code","759a331b":"code","2b33f697":"code","564b0c56":"code","d0881972":"code","0d8384d2":"code","fa2b5cd3":"code","e75fc5b4":"code","b37df0ea":"code","d1e052d8":"code","9f19c8de":"code","48b690f6":"code","6b9f3d7b":"code","6828bf98":"code","67baa225":"code","70907a47":"code","d2388bd3":"code","ee959ba3":"code","568059c6":"code","b767cdca":"code","774b0834":"code","73150c0a":"code","88824c5f":"code","f0d4c345":"code","3f42cd52":"code","7d3a8d69":"code","9e348f8f":"code","c92375ad":"code","40e97320":"code","d4fc005e":"code","b81bf3ab":"code","b2cc99d7":"code","e9826fae":"code","2524f499":"code","3c5cc903":"code","fe430e18":"code","cd1a4aac":"code","21bb6cd2":"code","e28f3a26":"code","c2d40606":"code","93465786":"markdown","e959baf2":"markdown","70213815":"markdown","ad70eba0":"markdown","129429da":"markdown","89159174":"markdown","5e4a4352":"markdown","1cac1d90":"markdown","005e8f71":"markdown","02eed574":"markdown","6ebf350e":"markdown","7fe91d1b":"markdown","cf852b98":"markdown","22755b2a":"markdown","e69cf137":"markdown"},"source":{"9403889e":"import os\nimport gc\nimport json\nimport numpy as np\nimport pandas as pd\nfrom PIL import Image\nimport geoplot\nimport geopandas as gpd\nfrom tqdm import tqdm\nfrom scipy.fft import fft, ifft\nimport matplotlib.image as mpimg\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\npd.options.display.max_columns = None","1708ad63":"!pip install detecta","27e1cb6f":"exp_ls = '..\/input\/indoor-location-navigation\/metadata\/5a0546857ecc773753327266'\nos.listdir(exp_ls)","5d7b3690":"os.listdir(exp_ls + '\/F1')","5101d35b":"B1_png = exp_ls + '\/F2' + '\/floor_image.png'\nimg = mpimg.imread(B1_png)\nplt.figure(figsize=(20, 10))\nplt.title('B1')\nplt.imshow(img);","8f3a9dbe":"with open(exp_ls + '\/F1' + '\/floor_info.json') as f:\n    data_hw = json.load(f)\n    print(data_hw)\n    \ndf_gpd = gpd.read_file(exp_ls + '\/F1' + '\/geojson_map.json')\ndisplay(df_gpd.head())","43a35219":"# there are some details of big .png picture\n# geoplot.polyplot(df_gpd, figsize=(8, 4));\ndf_gpd['geometry'][1]","fb31ac10":"exp_train = '..\/input\/indoor-location-navigation\/train\/5a0546857ecc773753327266'\nlen(os.listdir(exp_train + '\/B1'))","ae0cbeab":"full_lines = []\nfor txt_files in tqdm(os.listdir(exp_train + '\/B1')):\n    with open (exp_train + '\/B1\/' + txt_files) as f:\n        lines = f.readlines()\n    lines = [i.rstrip('\\n').split('\\t') for i in lines]\n    full_lines += lines","b5fa0f19":"len(full_lines)","75541924":"full_lines[-80:]","33cdf0c8":"# wifi = []\n# ac = []\n# for i in tqdm(full_lines):\n#     if i[1] == 'TYPE_WIFI':\n#         wifi.append(i[6])\n#     if i[1]=='TYPE_ACCELEROMETER':\n#         ac.append(i[0])","c9bbdf8a":"# len(full_lines)","cd67c432":"# print(min(ac), max(ac))\n# print(min(wifi), max(wifi))","43cc5043":"coords = []\nfor line in full_lines:\n    if line[1] == 'TYPE_WAYPOINT':\n        coords.append(line)","30f965b4":"coords = pd.DataFrame(coords)\ncoords.columns = ['ts', 'type', 'x', 'y']\ncoords['ts'] = pd.to_datetime(coords['ts'], unit='ms') #timestamp in ms format\ncoords['diff_ts'] = coords['ts'].diff()\ncoords['x'] = coords['x'].astype('float64')\ncoords['y'] = coords['y'].astype('float64')","6f093e29":"B1_png = exp_ls + '\/F2' + '\/floor_image.png'\nimg = mpimg.imread(B1_png)\nplt.figure(figsize=(30, 20))\nn = 11\nplt.plot(coords.head(n)['x'], coords.head(n)['y'])\nplt.scatter(coords.head(n)['x'], coords.head(n)['y'], c='b')\n\n    \nplt.title('B1')\nplt.imshow(img);","db2d002c":"coords.head()","a6e8919c":"coords = []\ncoord_line = ''\nacc_n, mag_n, gyro_n, rot_n = 0, 0, 0, 0\nacc1, acc2, acc3 = [], [], []\nfor i, line in tqdm(enumerate(full_lines)):\n    if line[1] == 'TYPE_WAYPOINT':\n        if coord_line:\n            if acc1:\n                features = [max(acc1), min(acc1)]\n            else:\n                features = [0, 0]\n            coords.append(coord_line + [line[0], line[2], line[3]] + [acc_n, mag_n, gyro_n, rot_n, i] + features)\n        coord_line = line\n        acc_n, mag_n, gyro_n, rot_n = 0, 0, 0, 0\n        acc1c, acc2c, acc3c = acc1.copy(), acc2.copy(), acc3.copy()\n        acc1, acc2, acc3 = [], [], []\n    elif line[1] == 'TYPE_ACCELEROMETER':\n        acc_n +=1\n        acc1.append(float(line[2])), acc2.append(float(line[3])), acc3.append(float(line[4]))\n    elif line[1] == 'TYPE_MAGNETIC_FIELD':\n        mag_n +=1\n    elif line[1] == 'TYPE_GYROSCOPE':\n        gyro_n +=1\n    elif line[1] == 'TYPE_ROTATION_VECTOR':\n        rot_n +=1","91f4ec15":"coords = pd.DataFrame(coords)\ncoords.columns = ['ts_start', 'type_start', 'x_start', 'y_start',\n                  'ts_end', 'x_end', 'y_end', \n                  'acc_n', 'mag_n', 'gyro_n', 'rot_n', 'i', 'acc1_max', 'acc1_min']\ncoords['ts_start'] = pd.to_datetime(coords['ts_start'], unit='ms') #timestamp in ms format\ncoords['ts_end'] = pd.to_datetime(coords['ts_end'], unit='ms') #timestamp in ms format\n\n# coords['diff_ts'] = coords['ts_start'].diff()\ncoords['x_start'] = coords['x_start'].astype('float64')\ncoords['x_end'] = coords['x_end'].astype('float64')\ncoords['y_start'] = coords['y_start'].astype('float64')\ncoords['y_end'] = coords['y_end'].astype('float64')\n\ncoords['between_ts'] = coords['ts_end'] - coords['ts_start']","06840b18":"coords.tail()","3a670004":"coords[['x_start', 'y_start', 'x_end', 'y_end', 'acc_n']].iloc[-1]","50e02fbf":"B1_png = exp_ls + '\/F2' + '\/floor_image.png'\nimg = mpimg.imread(B1_png)\nplt.figure(figsize=(20, 10))\ncor_loc = coords.iloc[-1]\nplt.plot([cor_loc['x_start'], cor_loc['x_end']], [cor_loc['y_start'], cor_loc['y_end']])\nplt.scatter([cor_loc['x_start'], cor_loc['x_end']], [cor_loc['y_start'], cor_loc['y_end']], c='b')\n\n    \nplt.title('B1')\nplt.imshow(img[:300,:300]);","f66b8658":"plt.figure(figsize=(12,5))\nplt.plot(acc1c, label='acc1');\nplt.plot(acc2c, label='acc2');\nplt.plot(acc3c, label='acc3');\nplt.legend();","fb4bfcd6":"from detecta import detect_peaks\n# peaks counts\ndetect_peaks(acc1c, show=True, mpd=30, valley=True)\ndetect_peaks(acc1c, show=True, mpd=30, valley=False)","1e0b29ce":"# how much rows without data\ncoords[coords.acc_n==0].shape","fb186d78":"coords.tail(4)","2ec7d36d":"# B1_png = exp_ls + '\/F2' + '\/floor_image.png'\n# img = mpimg.imread(B1_png)\n# plt.figure(figsize=(30, 20))\n# n = 5\n# plt.plot(coords.head(n)['x'], coords.head(n)['y'])\n# plt.scatter(coords.head(n)['x'], coords.head(n)['y'], c='b')    \n# plt.title('B1')\n# plt.imshow(img);","759a331b":"def get_feats(*acc, flag=3):\n    if flag==3:\n        if acc[0]:\n            acc1, acc2, acc3 = acc[0], acc[1], acc[2]\n            acc1_f = [\n                      max(acc1), min(acc1), np.mean(acc1), np.std(acc1), np.median(acc1),\n                      np.quantile(acc1, .1), np.quantile(acc1, .15), np.quantile(acc1, .20),\n                      np.quantile(acc1, .25), np.quantile(acc1, .3), np.quantile(acc1, .4),\n                      np.quantile(acc1, .6), np.quantile(acc1, .65), np.quantile(acc1, .7), \n                      np.quantile(acc1, .75), np.quantile(acc1, .8), np.quantile(acc1, .9)\n                     ]\n            acc2_f = [\n                      max(acc2), min(acc2), np.mean(acc2), np.std(acc2), np.median(acc2),\n                      np.quantile(acc2, .1), np.quantile(acc2, .15), np.quantile(acc2, .20),\n                      np.quantile(acc2, .25), np.quantile(acc2, .3), np.quantile(acc2, .4),\n                      np.quantile(acc2, .6), np.quantile(acc2, .65), np.quantile(acc2, .7), \n                      np.quantile(acc2, .75), np.quantile(acc2, .8), np.quantile(acc2, .9)\n                     ]\n            acc3_f = [\n                      max(acc3), min(acc3), np.mean(acc3), np.std(acc3), np.median(acc3),\n                      np.quantile(acc3, .1), np.quantile(acc3, .15), np.quantile(acc3, .20),\n                      np.quantile(acc3, .25), np.quantile(acc3, .3), np.quantile(acc3, .4),\n                      np.quantile(acc3, .6), np.quantile(acc3, .65), np.quantile(acc3, .7), \n                      np.quantile(acc3, .75), np.quantile(acc3, .8), np.quantile(acc3, .9)\n                     ]\n            acc_lens = [len(acc1)]\n            acc_peaks = []\n            for mp in [30, 40]:\n                for df in [acc1, acc2, acc3]:\n    #                 for vall in [True, False]:\n                        acc_peaks.append(\n                            detect_peaks(df, mpd=mp, valley=True).shape[0]\n                        )\n\n            return acc1_f + acc2_f + acc3_f + acc_lens + acc_peaks\n        else:\n            return [0]*17*3\n    else:\n        acc1 = acc[0]\n        if acc1:\n            acc1_f = [\n                      max(acc1), min(acc1), np.mean(acc1), np.std(acc1), np.median(acc1),\n                      np.quantile(acc1, .1), np.quantile(acc1, .15), np.quantile(acc1, .20),\n                      np.quantile(acc1, .25), np.quantile(acc1, .3), np.quantile(acc1, .4),\n                      np.quantile(acc1, .6), np.quantile(acc1, .65), np.quantile(acc1, .7), \n                      np.quantile(acc1, .75), np.quantile(acc1, .8), np.quantile(acc1, .9)\n                     ]\n            acc_peaks = []\n            for mp in [30, 40]:\n                for df in [acc1]:\n    #                 for vall in [True, False]:\n                        acc_peaks.append(\n                            detect_peaks(df, mpd=mp, valley=True).shape[0]\n                        )\n            return acc1_f + acc_peaks\n        else:\n            return [0]*17\n    \n# get_feats(acc1c, acc2c, acc3c)","2b33f697":"# peaks counts\ns1 = detect_peaks(acc1c, show=True, mpd=50, valley=True)\ns2 = detect_peaks(acc1c, show=True, mpd=50, valley=False)\nprint(s1.shape[0], s2.shape[0])","564b0c56":"# coords = []\n# coord_line = ''\n# acc_n, mag_n, gyro_n, rot_n = 0, 0, 0, 0\n# acc1, acc2, acc3 = [], [], []\n# for i, line in tqdm(enumerate(full_lines)):\n#     if line[1] == 'TYPE_WAYPOINT':\n#         if coord_line:\n#             if acc1:\n#                 features = [max(acc1), min(acc1)]\n#             else:\n#                 features = [0, 0]\n#             coords.append(coord_line + [line[0], line[2], line[3]] + [acc_n, mag_n, gyro_n, rot_n, i] + features)\n#         coord_line = line\n#         acc_n, mag_n, gyro_n, rot_n = 0, 0, 0, 0\n#         acc1c, acc2c, acc3c = acc1.copy(), acc2.copy(), acc3.copy()\n#         acc1, acc2, acc3 = [], [], []\n#     elif line[1] == 'TYPE_ACCELEROMETER':\n#         acc_n +=1\n#         acc1.append(float(line[2])), acc2.append(float(line[3])), acc3.append(float(line[4]))\n#     elif line[1] == 'TYPE_MAGNETIC_FIELD':\n#         mag_n +=1\n#     elif line[1] == 'TYPE_GYROSCOPE':\n#         gyro_n +=1\n#     elif line[1] == 'TYPE_ROTATION_VECTOR':\n#         rot_n +=1","d0881972":"coords = []\ncoords_wifi = []\nfull_feats_df = []\ntrain_path = '..\/input\/indoor-location-navigation\/train'\n\n# all paths = 204\nfor path in tqdm(os.listdir(train_path)[:]):\n#     full_lines = []\n    # get all raw lines\n    os_floors = os.listdir(train_path + '\/' + path)\n    for floor in os_floors:\n        for trajs in os.listdir(train_path + '\/' + path + '\/' + floor):\n            full_lines = []\n            xy_timestamp = []\n            with open (train_path + '\/' + path + '\/' + floor + '\/' + trajs) as f:\n                lines = f.readlines()\n            lines = [i.rstrip('\\n').split('\\t') for i in lines]\n            full_lines += lines\n            # collect all features together: \n            coord_line = ''\n            acc_n, mag_n, gyro_n, rot_n = 0, 0, 0, 0\n#             acc_unn, mag_unn, gyro_unn = 0, 0, 0\n            acc1, acc2, acc3 = [], [], []\n            # collect features\n            for i, line in enumerate(full_lines):\n                if (line[1] == 'TYPE_WAYPOINT'):\n                    # add waypoint time for wifi-features\n                    xy_timestamp.append(line[0])\n                    if coord_line:\n                        acc_feats = get_feats(acc1, acc2, acc3)\n                        mag_feats = get_feats(mag1, mag2, mag3)\n                        gyro_feats = get_feats(gyro1, gyro2, gyro3)\n                        rot_feats = get_feats(rot1, rot2, rot3)\n                        \n#                         acc_feats_un = get_feats(acc1un, acc2un, acc3un)\n#                         mag_feats_un = get_feats(mag1un, mag2un, mag3un)\n#                         gyro_feats_un = get_feats(gyro1un, gyro2un, gyro3un)\n                        features = acc_feats + mag_feats + gyro_feats + rot_feats\n#                              acc_feats_un + mag_feats_un + gyro_feats_un\n    \n                        coords.append(coord_line + [line[0], line[2], line[3], floor] + features)\n                    coord_line = line\n                    acc_n = 0\n                    # acc1c, acc2c, acc3c = acc1.copy(), acc2.copy(), acc3.copy()\n                    acc1, acc2, acc3, mag1, mag2, mag3 = [], [], [], [], [], []\n                    gyro1, gyro2, gyro3, rot1, rot2, rot3 = [], [], [], [], [], []\n                    \n                    acc1un, acc2un, acc3un, mag1un, mag2un, mag3un = [], [], [], [], [], []\n                    gyro1un, gyro2un, gyro3un = [], [], []\n                elif line[1] == 'TYPE_ACCELEROMETER':\n                    acc_n +=1\n                    acc1.append(float(line[2])), acc2.append(float(line[3])), acc3.append(float(line[4]))\n                elif line[1] == 'TYPE_MAGNETIC_FIELD':\n                    mag_n +=1\n                    mag1.append(float(line[2])), mag2.append(float(line[3])), mag3.append(float(line[4]))\n                elif line[1] == 'TYPE_GYROSCOPE':\n                    gyro_n +=1\n                    gyro1.append(float(line[2])), gyro2.append(float(line[3])), gyro3.append(float(line[4]))\n                elif line[1] == 'TYPE_ROTATION_VECTOR':\n                    rot_n +=1\n                    try:\n                        rot1.append(float(line[2])), rot2.append(float(line[3])), rot3.append(float(line[4]))\n                    except IndexError:\n                        rot1.append(0), rot2.append(0), rot3.append(0)\n            \n            xy_ts = 0\n            coord_line_wifi1, coord_line_wifi2 = [], []\n            for i, line in enumerate(full_lines):\n                if (line[1] == 'TYPE_WIFI'):\n                    if line[0] < xy_timestamp[xy_ts]:\n                        coord_line_wifi1.append(float(line[4]))\n                        coord_line_wifi2.append(float(line[5]))\n                    else:\n                        feat_wifi_1 = get_feats(coord_line_wifi1, flag=1)\n                        feat_wifi_2 = get_feats(coord_line_wifi2, flag=1)\n                        coords_wifi.append([xy_timestamp[xy_ts]] + feat_wifi_1 + feat_wifi_2)\n                        xy_ts += 1\n                        if xy_ts >= len(xy_timestamp):\n                            break","0d8384d2":"base_wifi = ['ts_start']\nnfeats_wf = [str(i)*3 for i in range(len(features), len(features) + len(feat_wifi_1 + feat_wifi_2))]\ncoords_wifi = pd.DataFrame(coords_wifi)\ncoords_wifi.columns = base_wifi + nfeats_wf\n\nbase_targ = ['ts_start', 'type_start', 'x_start', 'y_start', 'ts_end', 'x_end', 'y_end', 'floor']\nnfeats = [str(i)*3 for i in range(len(features))]\n\ncoords = pd.DataFrame(coords)\ncoords.columns = base_targ + nfeats\n# merge all features\ncoords = coords.merge(coords_wifi, on='ts_start', how='inner')","fa2b5cd3":"coords_wifi.shape","e75fc5b4":"print(coords_wifi.shape)\ncoords_wifi.head()","b37df0ea":"print(coords.shape)\ncoords.head()","d1e052d8":"def floor_code(x):\n    res = -100\n    if (x=='F2' or x=='2F'):\n        res = 1\n    elif (x=='F1' or x=='1F'):\n        res = 0\n    elif (x=='B1' or x=='1B'):\n        res = -1\n    elif (x=='B2' or x=='2B'):\n        res = -2\n    return res","9f19c8de":"coords['floor'] = coords['floor'].apply(lambda x: floor_code(x))","48b690f6":"coords['floor'].value_counts()","6b9f3d7b":"coords['x_start'] = coords['x_start'].astype('float64')\ncoords['x_end'] = coords['x_end'].astype('float64')\ncoords['y_start'] = coords['y_start'].astype('float64')\ncoords['y_end'] = coords['y_end'].astype('float64')","6828bf98":"# coords['target_x'] = coords['x_end'] - coords['x_start']\n# coords['target_y'] = coords['y_end'] - coords['y_start']","67baa225":"from catboost import CatBoostRegressor, CatBoostClassifier","70907a47":"# coords.drop(['ts_start', 'type_start', 'x_start', 'y_start', 'ts_end', 'x_end', 'y_end'], axis=1, inplace=True)\ncoords.fillna(0, inplace=True)","d2388bd3":"X_train, X_test, y_train, y_test = train_test_split(coords.iloc[:,8:],\n                                                    coords['x_end'],\n                                                    test_size=0.2,\n                                                    random_state=42)","ee959ba3":"X_train.shape","568059c6":"%%time\nmodel_x = CatBoostRegressor(n_estimators=5000, loss_function='RMSE', eval_metric='RMSE',\n                            early_stopping_rounds=200, verbose=200);\nmodel_x.fit(X_train, y_train,\n            eval_set=(X_test, y_test), use_best_model=True\n           );","b767cdca":"X_train, X_test, y_train, y_test = train_test_split(coords.iloc[:,8:],\n                                                    coords['y_end'],\n                                                    test_size=0.2,\n                                                    random_state=42)","774b0834":"%%time\nmodel_y = CatBoostRegressor(n_estimators=5000, loss_function='RMSE', eval_metric='RMSE',\n                            early_stopping_rounds=200, verbose=200);\nmodel_y.fit(X_train, y_train,\n            eval_set=(X_test, y_test), use_best_model=True\n           );","73150c0a":"X_train, X_test, y_train, y_test = train_test_split(coords[coords.floor!=-100].iloc[:,8:],\n                                                    coords[coords.floor!=-100]['floor'],\n                                                    test_size=0.2,\n                                                    random_state=42)","88824c5f":"%%time\nmodel_fl = CatBoostClassifier(n_estimators=5000, loss_function='MultiClass',\n          eval_metric='MultiClass', early_stopping_rounds=200, verbose=200);\nmodel_fl.fit(X_train, y_train,\n            eval_set=(X_test, y_test), use_best_model=True\n           );","f0d4c345":"subs = pd.read_csv('..\/input\/indoor-location-navigation\/sample_submission.csv')","3f42cd52":"subs['site'] = subs['site_path_timestamp'].apply(lambda x: x.split('_')[0])\nsubs['path'] = subs['site_path_timestamp'].apply(lambda x: x.split('_')[1])\nsubs['timestamp'] = subs['site_path_timestamp'].apply(lambda x: x.split('_')[2])","7d3a8d69":"subs.head()","9e348f8f":"full_feats_df = []\nfull_wifi_dfraw = []\ntest_path = '..\/input\/indoor-location-navigation\/test'\ncoords = []\nind = 0\n# acc1un, acc2un, acc3un, mag1un, mag2un, mag3un = [], [], [], [], [], []\n# gyro1un, gyro2un, gyro3un = [], [], []\n\nfor path in tqdm(os.listdir(test_path)[:]):\n    full_lines = []\n    # get all raw lines\n    with open (test_path + '\/' + path) as f:\n        lines = f.readlines()\n    lines = [i.rstrip('\\n').split('\\t') for i in lines]\n    full_lines += lines\n    \n    # parse raw lines to features\n    buffer_df = []\n    buffer_df.append(full_lines[1][1].split(':')[1])\n    buffer_df.append(path.split('.')[0])\n        \n    # set buffer timestamp\n    if subs[(subs['site']==buffer_df[0]) & (subs['path']==buffer_df[1])].shape[0] == 0:\n        continue\n    buff_ts = subs[(subs['site']==buffer_df[0]) & (subs['path']==buffer_df[1])]\\\n        .sort_values(by='timestamp')['timestamp'].astype('int64').tolist()\n    buff_ts = [0] + buff_ts\n    \n    # collect features:\n    coords = []\n    acc_n, mag_n, gyro_n, rot_n = 0, 0, 0, 0\n#     acc_unn, mag_unn, gyro_unn = 0, 0, 0\n\n    # set timestmap\n    I = 1\n    ts0, ts1 = buff_ts[I-1], buff_ts[I]\n    for i, line in enumerate(full_lines):\n        if (line[1] == 'TYPE_ACCELEROMETER'):\n            if (int(line[0]) > ts1):\n                # generate features\n                acc_feats = get_feats(acc1, acc2, acc3)\n                                      \n                # add correct site_path_timestamp value\n                site_path_ts = buffer_df[0] + '_' + buffer_df[1] + '_' + str(ts1).rjust(13, '0')\n                coords.append([site_path_ts, 'acc'] + acc_feats)\n                                      \n                acc_n = 0\n                acc1, acc2, acc3 = [], [], []\n            else:\n                acc_n +=1\n                acc1.append(float(line[2])), acc2.append(float(line[3])), acc3.append(float(line[4]))\n                \n        elif (line[1] == 'TYPE_MAGNETIC_FIELD'):\n            if (int(line[0]) > ts1):\n                # generate features\n                mag_feats = get_feats(mag1, mag2, mag3)\n                # add correct site_path_timestamp value\n                site_path_ts = buffer_df[0] + '_' + buffer_df[1] + '_' + str(ts1).rjust(13, '0')\n                coords.append([site_path_ts, 'mag'] + mag_feats)\n                # take to zero\n                mag_n = 0\n                mag1, mag2, mag3 = [], [], []\n            else:\n                mag_n +=1\n                mag1.append(float(line[2])), mag2.append(float(line[3])), mag3.append(float(line[4]))\n                \n        elif (line[1] == 'TYPE_GYROSCOPE'):\n            if (int(line[0]) > ts1):\n                # generate features\n                gyro_feats = get_feats(gyro1, gyro2, gyro3)\n                                      \n                # add correct site_path_timestamp value\n                site_path_ts = buffer_df[0] + '_' + buffer_df[1] + '_' + str(ts1).rjust(13, '0')\n                coords.append([site_path_ts, 'gyro'] + gyro_feats)\n                                      \n                gyro_n = 0\n                gyro1, gyro2, gyro3 = [], [], []\n            else:\n                gyro_n +=1\n                gyro1.append(float(line[2])), gyro2.append(float(line[3])), gyro3.append(float(line[4]))\n\n        elif (line[1] == 'TYPE_ROTATION_VECTOR'):\n            if (int(line[0]) > ts1):\n                # generate features\n                rot_feats = get_feats(rot1, rot2, rot3)\n                                      \n                # add correct site_path_timestamp value\n                site_path_ts = buffer_df[0] + '_' + buffer_df[1] + '_' + str(ts1).rjust(13, '0')\n                coords.append([site_path_ts, 'rot'] + rot_feats)\n\n                # buffer values set to zero\n                I = I+1\n                try:\n                    ts0, ts1 = buff_ts[I-1], buff_ts[I]\n                except IndexError:\n                    break\n                \n                rot_n = 0\n                rot1, rot2, rot3 = [], [], []\n            else:\n                rot_n +=1\n                rot1.append(float(line[2])), rot2.append(float(line[3])), rot3.append(float(line[4]))\n                \n\n    coords_wifi = []\n    wfi1, wfi2 = [], []\n    I = 1\n    ts0, ts1 = buff_ts[I-1], buff_ts[I]\n    for i, line in enumerate(full_lines):\n        if (line[1] == 'TYPE_WIFI'):\n            if (int(line[0]) > ts1):\n                wifi_feats1 = get_feats(wfi1, flag=1)\n                wifi_feats2 = get_feats(wfi2, flag=1)\n                site_path_ts = buffer_df[0] + '_' + buffer_df[1] + '_' + str(ts1).rjust(13, '0')\n                coords_wifi.append([site_path_ts, 'wifi'] + wifi_feats1 + wifi_feats2)\n\n                # buffer values set to zero\n                I = I+1\n                try:\n                    ts0, ts1 = buff_ts[I-1], buff_ts[I]\n                except IndexError:\n                    break\n\n                wfi1, wfi2 = [], []\n            else:\n                wfi1.append(float(line[4])), wfi2.append(float(line[5]))\n\n\n#         elif (line[1] == 'TYPE_MAGNETIC_FIELD_UNCALIBRATED'):\n#             if (int(line[0]) > ts1):\n#                 mag_feats_un = get_feats(mag1un, mag2un, mag3un)\n\n#                 site_path_ts = buffer_df[0] + '_' + buffer_df[1] + '_' + str(ts1).rjust(13, '0')\n#                 coords.append([site_path_ts, 'mag_un'] + mag_feats_un)\n\n#                 mag_unn = 0\n#                 mag1un, mag2un, mag3un = [], [], []\n#             else:\n#                 mag_unn +=1\n#                 mag1un.append(float(line[2])), mag2un.append(float(line[3])), mag3un.append(float(line[4]))\n                \n#         elif (line[1] == 'TYPE_GYROSCOPE_UNCALIBRATED'):\n#             if (int(line[0]) > ts1):\n#                 gyro_feats_un = get_feats(gyro1un, gyro2un, gyro3un)\n                                      \n#                 site_path_ts = buffer_df[0] + '_' + buffer_df[1] + '_' + str(ts1).rjust(13, '0')\n#                 coords.append([site_path_ts, 'gyro_un'] + gyro_feats_un)\n                                      \n#                 gyro_unn = 0\n#                 gyro1un, gyro2un, gyro3un = [], [], []\n#             else:\n#                 gyro_unn +=1\n#                 gyro1un.append(float(line[2])), gyro2un.append(float(line[3])), gyro3un.append(float(line[4]))\n                \n#         elif (line[1] == 'TYPE_ACCELEROMETER_UNCALIBRATED'):\n#             if (int(line[0]) > ts1):\n#                 acc_feats_un = get_feats(acc1un, acc2un, acc3un)\n                                      \n#                 site_path_ts = buffer_df[0] + '_' + buffer_df[1] + '_' + str(ts1).rjust(13, '0')\n#                 coords.append([site_path_ts, 'acc_un'] + acc_feats_un)\n                         \n#                 # buffer values set to zero\n#                 I = I+1\n#                 try:\n#                     ts0, ts1 = buff_ts[I-1], buff_ts[I]\n#                 except IndexError:\n#                     break\n                    \n#                 acc_unn = 0\n#                 acc1un, acc2un, acc3un = [], [], []\n#             else:\n#                 acc_unn +=1\n#                 acc1un.append(float(line[2])), acc2un.append(float(line[3])), acc3un.append(float(line[4]))\n\n    full_feats_df += coords\n    full_wifi_dfraw += coords_wifi","c92375ad":"# full_feats_df.fillna(0, inplace=True)\n# full_feats_df = pd.DataFrame(full_feats_df)","40e97320":"full_feats_df = pd.DataFrame(full_feats_df)\nfull_feats_df.columns = [str(i)*3 for i in range(full_feats_df.shape[1])]\ntest_lst = []\nfor sitepath in tqdm(full_feats_df['000'].unique()):\n    ww = full_feats_df[full_feats_df['000']==sitepath]\n    t = ww.iloc[:,2:].values.tolist()\n    test_lst.append([sitepath] + [item for sublist in t for item in sublist])","d4fc005e":"%%time\ntest_lst = pd.DataFrame(test_lst)\ntest_lst.columns=[str(i)*3 for i in range(test_lst.shape[1])]\nress = test_lst.merge(subs, how='right', left_on='000', right_on='site_path_timestamp')\nress.drop(['site_path_timestamp','floor','x','y','site','path','timestamp'], axis=1, inplace=True)\n\nprint(subs.shape, test_lst.shape, ress.shape)\nprint(ress.shape)\nress.head()","b81bf3ab":"full_wifi_df = pd.DataFrame(full_wifi_dfraw)\nfull_wifi_df.columns = ['000', 'WIFI'] + [str(i)*3 for i in range(1,39)]\nfull_wifi_df.drop(['WIFI'], axis=1, inplace=True)\nprint(full_wifi_df.shape)\nfull_wifi_df.head()","b2cc99d7":"fulls = ress.merge(full_wifi_df, on='000', how='left')\nfulls.columns = ['time_path_site'] + [str(i)*3 for i in range(X_train.shape[1])]\nprint(fulls.shape)","e9826fae":"fulls[['000','111','222','333']] = fulls[['000','111','222','333']].fillna(method='bfill')\nfulls.fillna(0, inplace=True)","2524f499":"test_data = fulls.iloc[:,1:X_train.shape[1]+1]\ntest_data.columns = [str(i)*3 for i in range(X_train.shape[1])]","3c5cc903":"x_preds = model_x.predict(test_data)\ny_preds = model_y.predict(test_data)\nflr = model_fl.predict(test_data)","fe430e18":"subs = pd.read_csv('..\/input\/indoor-location-navigation\/sample_submission.csv')","cd1a4aac":"subs['x'], subs['y'], subs['floor'] = x_preds, y_preds, flr","21bb6cd2":"subs['site'] = subs['site_path_timestamp'].apply(lambda x: x.split('_')[0])\n# subs['path'] = subs['site_path_timestamp'].apply(lambda x: x.split('_')[1])","e28f3a26":"subs['site'] = subs['site_path_timestamp'].apply(lambda x: x.split('_')[0])\nflr_merge = subs[['site','floor']].groupby(['site']).agg(lambda x:x.value_counts().index[0]).reset_index()\nflr_merge.columns = ['site', 'flr']\n\nsubs = flr_merge.merge(subs, how='inner', on='site')\nsubs = subs[['site_path_timestamp', 'flr', 'x', 'y']]\nsubs.columns = ['site_path_timestamp', 'floor', 'x', 'y']","c2d40606":"subs.to_csv(\"submission_204un_floor.csv\", index=False)","93465786":"## Train model","e959baf2":"Visualize path:","70213815":"Collect test features to pandas DataFrame:","ad70eba0":"### Predict x coordinate","129429da":"### Predict floor","89159174":"## Look at raw accelerometers data:","5e4a4352":"Some values not merged, so try to fillna values with previous data:","1cac1d90":"### Predict y coordinate","005e8f71":"## Main features extraction function","02eed574":"Main imports","6ebf350e":"Example of data:","7fe91d1b":"Now see train_file consists:","cf852b98":"# Make submission","22755b2a":"Firstly, define what type of data we have. Take first row `5a0546857ecc773753327266` as example:","e69cf137":"## Make features from train dataset"}}