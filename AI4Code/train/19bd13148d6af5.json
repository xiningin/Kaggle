{"cell_type":{"4a69c7a0":"code","58e58aa7":"code","ebe06549":"code","ce4b6397":"code","70673527":"code","46ce92c7":"code","0df13a47":"code","e547b557":"code","516c9622":"code","a145f7e4":"code","f0d9405e":"code","1ea950da":"code","072d8ce2":"markdown","1a8f3588":"markdown","49c66693":"markdown","3a224499":"markdown","f72a6538":"markdown","58161dd2":"markdown","68917aa4":"markdown","5a17be3f":"markdown","da206c15":"markdown"},"source":{"4a69c7a0":"import os\nimport pandas as pd\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom keras.layers import Input, Dense, Bidirectional, Dropout\nfrom keras.layers.recurrent import LSTM\nfrom keras.models import Model\nfrom keras.callbacks import EarlyStopping\n\nimport numpy as np","58e58aa7":"os.listdir(\"..\/input\/\")","ebe06549":"coin_dataframes = {}\n\ndef convert_comma_int(field):\n    try:\n        return int(field.replace(',', ''))\n    except ValueError:\n        return None\n    \nfor fn in os.listdir(\"..\/input\/\"):\n    if \"bitcoin_cache\" in fn:\n        continue\n    if fn.endswith(\"_price.csv\"):\n        coin_name = fn.split(\"_\")[0]\n        df = pd.read_csv(os.path.join(\"..\/input\/\", fn), parse_dates=[\"Date\"])\n        df['Market Cap'] = df['Market Cap'].map(convert_comma_int)\n        coin_dataframes[coin_name] = df.sort_values('Date')","ce4b6397":"coin_dataframes.keys()","70673527":"coin_dataframes['nem'].head()","46ce92c7":"# import plotly.plotly as py\n# import plotly.graph_objs as go\n\n# from datetime import datetime\n# # import pandas_datareader.data as web\n\n# data = [go.Scatter(x=coin_dataframes['bitcoin'].Date, y=coin_dataframes['bitcoin'].Date)]\n\n# py.iplot(data)\n\nplt.figure(figsize=(20,8))\ncoin_dataframes['bitcoin'].plot(x='Date', y='Close')\nplt.show()","0df13a47":"def add_relative_columns(df):\n    day_diff = df['Close'] - df['Open']\n    df['rel_close'] = day_diff \/ df['Open']\n    df['high_low_ratio'] = df['High'] \/ df['Low']\n    df['rel_high'] = df['High'] \/ df['Close']\n    df['rel_low'] = df['Low'] \/ df['Close']\n    \n    \nfor df in coin_dataframes.values():\n    add_relative_columns(df)\n    \ncoin_dataframes[\"nem\"].head()","e547b557":"def create_history_frames(coin_dataframes):\n    history_frames = {}\n    for coin_name, df in coin_dataframes.items():\n        history_frames[coin_name], x_cols = create_history_frame(df)\n    return history_frames, x_cols\n        \n\ndef create_history_frame(df):\n    feature_cols = ['rel_close', 'rel_high', 'rel_low', 'high_low_ratio']\n    y_col = ['rel_close']\n    x_cols = []\n    days = 10\n    history = df[['Date'] + y_col].copy()\n    for n in range(1, days+1):\n        for feat_col in feature_cols:\n            colname = '{}_{}'.format(feat_col, n)\n            history[colname] = df[feat_col].shift(n)\n            x_cols.append(colname)\n    history = history[days:]\n    return history, x_cols\n\ny_col = 'rel_close'\ncoin_history, x_cols = create_history_frames(coin_dataframes)","516c9622":"def create_model():\n    input_layer = Input(batch_shape=(None, len(x_cols), 1))\n    layer = Bidirectional(LSTM(128, return_sequences=True))(input_layer)\n    layer = Bidirectional(LSTM(128))(layer)\n    out = Dense(1, activation=\"sigmoid\")(layer)\n    m = Model(inputs=input_layer, outputs=out)\n    m.compile(\"rmsprop\", loss='mean_squared_error')\n    return m\n\ndef create_train_test_mtx(history):\n    X = history[x_cols].as_matrix()\n    y = history[y_col].as_matrix()\n    X = X.reshape(X.shape[0], X.shape[1], 1)\n    rand_mtx = np.random.permutation(X.shape[0])\n    train_split = int(X.shape[0] * 0.9)\n    train_indices = rand_mtx[:train_split]\n    test_indices = rand_mtx[train_split:]\n\n    X_train = X[train_indices]\n    X_test = X[test_indices]\n    y_train = y[train_indices]\n    y_test = y[test_indices]\n    \n    return X_train, X_test, y_train, y_test\n\ndef train_model(model, X, y):\n    ea = EarlyStopping(monitor='val_loss', patience=2)\n    val_loss = model.fit(X, y, epochs=500, batch_size=64, callbacks=[ea], verbose=1, validation_split=.1)\n    return val_loss","a145f7e4":"rmse = {}\npred = {}\ntest = {}\n\nfor coin_name, history in coin_history.items():\n    model = create_model()\n    X_train, X_test, y_train, y_test = create_train_test_mtx(history)\n    train_model(model, X_train, y_train)\n    test[coin_name] = y_test\n    \n    # run prediction on test set\n    pred[coin_name] = model.predict(X_test)\n    # compute test loss\n    rmse[coin_name] = np.sqrt(np.mean((pred[coin_name] - y_test)**2))\n    print(coin_name, rmse[coin_name])","f0d9405e":"pred_sign = {coin_name: np.sign(pred[coin_name]) * np.sign(test[coin_name]) for coin_name in pred.keys()}\nfor coin, val in sorted(pred_sign.items()):\n    cnt = np.unique(pred_sign[coin], return_counts=True)[1]\n    print(\"[{}] pos\/neg change guessed correctly: {}, incorrectly: {}, correct%: {}\".format(\n        coin, cnt[0], cnt[1], cnt[0]\/ (cnt[0]+cnt[1]) * 100))","1ea950da":"pred_sign = {coin_name: np.sign(pred[coin_name]) for coin_name in pred.keys()}\nfor coin, val in sorted(pred_sign.items()):\n    e, cnt = np.unique(val, return_counts=True)\n    print(\"[{}] guesses: {}\".format(coin, dict(zip(e, cnt))))","072d8ce2":"## Create historical training data\n\nThe history tables will have values for the last 10 days for each day.","1a8f3588":"# Define model\n\nWe will train a separate model for each currency. The models' architecture  identical.","49c66693":"## Train a model for each currency\n\nWe save RMSE as well as the predictions on each test set.","3a224499":"# Load data\n\nWe load each currency into a separate dataframe and store the dataframes in a dictionary.","f72a6538":"## Bitcoin value growth\n\nJust for fun.","58161dd2":"# Compute relative growth and other relative values\n\nWe add these values as new columns to the dataframes:","68917aa4":"Each dataframe looks like this:","5a17be3f":"## Did we guess anything useful at all?","da206c15":"## Do our models predict the signum of the value change correctly?"}}