{"cell_type":{"a9fa498c":"code","0070401f":"code","044b96e8":"code","398e5728":"code","49b5c37b":"code","88a16704":"code","15f1f84e":"code","beceab0b":"code","7358aafe":"code","6e6a5d5f":"code","6bf7ec34":"code","21826c09":"code","c78a1e94":"code","7983b086":"code","2feaf9d7":"code","128c4776":"code","d300f831":"code","21f1e847":"code","27f1beb8":"code","f024911a":"code","057eabe8":"code","ff4f10c5":"code","89d2856a":"code","4b811724":"code","98f70ff3":"code","41fd8011":"code","787d0ed5":"code","7a4f8378":"code","6237e0dd":"code","993c7fda":"code","290e6824":"code","12fc0215":"code","6fcf3940":"code","4c83d663":"code","a4c3db33":"code","5c2df147":"code","0f844f22":"code","860ebd37":"code","deea713c":"code","e1d8958b":"code","712644b7":"code","b4ed9e29":"code","d2465d44":"code","d5ded3a1":"code","b65f7d1b":"code","51b3fd5f":"code","6c1b0642":"code","578c229d":"code","1b94cfea":"code","822e80eb":"code","b4df5429":"code","274c2b26":"code","5f2c0abc":"code","81f95575":"code","7e2562d9":"code","afe99f11":"code","c3ae9a23":"code","807ad463":"code","0fa7a999":"code","607071d7":"code","cad87bc7":"markdown","2867e1a1":"markdown","45c0855c":"markdown","3443792c":"markdown","1d9cdf50":"markdown","db0aa5db":"markdown","4e3d10dd":"markdown","4e6268de":"markdown","366967be":"markdown","0febff1d":"markdown","2e5da24d":"markdown","2f9c5366":"markdown","f5d571cd":"markdown","74c57eb9":"markdown","9d103a92":"markdown","1395ce97":"markdown","126e70b8":"markdown","19729b71":"markdown","45605b0c":"markdown","2b350ed9":"markdown","30f58367":"markdown","20caeaae":"markdown","6b38e7d1":"markdown","30ccd306":"markdown","ea2e5579":"markdown","a63f7271":"markdown","bd1316ad":"markdown","39f7af52":"markdown","4aa7f622":"markdown","4a1bef8c":"markdown","027f779a":"markdown","4100e512":"markdown","841df04e":"markdown","e418b012":"markdown","5a205b2a":"markdown","289c713c":"markdown","cd2d8cf0":"markdown","4ed9bebd":"markdown","cb17b468":"markdown","1b40f721":"markdown","ce15857d":"markdown","73f0534d":"markdown","0a5b7c00":"markdown","ab3ede78":"markdown","a7ccf3a3":"markdown","befb9caa":"markdown","d2d25564":"markdown","28771a0b":"markdown","fb361aa0":"markdown","d93254a5":"markdown","a9170b3a":"markdown","aafdc342":"markdown","4d16de7a":"markdown","ee805c91":"markdown","6c2be978":"markdown"},"source":{"a9fa498c":"import json\nimport pandas as pd\n#___________________________\ndef load_tmdb_movies(path):\n    df = pd.read_csv(path)\n    df['release_date'] = pd.to_datetime(df['release_date']).apply(lambda x: x.date())\n    json_columns = ['genres', 'keywords', 'production_countries',\n                    'production_companies', 'spoken_languages']\n    for column in json_columns:\n        df[column] = df[column].apply(json.loads)\n    return df\n#___________________________\ndef load_tmdb_credits(path):\n    df = pd.read_csv(path)\n    json_columns = ['cast', 'crew']\n    for column in json_columns:\n        df[column] = df[column].apply(json.loads)\n    return df\n#___________________\nLOST_COLUMNS = [\n    'actor_1_facebook_likes',\n    'actor_2_facebook_likes',\n    'actor_3_facebook_likes',\n    'aspect_ratio',\n    'cast_total_facebook_likes',\n    'color',\n    'content_rating',\n    'director_facebook_likes',\n    'facenumber_in_poster',\n    'movie_facebook_likes',\n    'movie_imdb_link',\n    'num_critic_for_reviews',\n    'num_user_for_reviews']\n#____________________________________\nTMDB_TO_IMDB_SIMPLE_EQUIVALENCIES = {\n    'budget': 'budget',\n    'genres': 'genres',\n    'revenue': 'gross',\n    'title': 'movie_title',\n    'runtime': 'duration',\n    'original_language': 'language',\n    'keywords': 'plot_keywords',\n    'vote_count': 'num_voted_users'}\n#_____________________________________________________\nIMDB_COLUMNS_TO_REMAP = {'imdb_score': 'vote_average'}\n#_____________________________________________________\ndef safe_access(container, index_values):\n    # return missing value rather than an error upon indexing\/key failure\n    result = container\n    try:\n        for idx in index_values:\n            result = result[idx]\n        return result\n    except IndexError or KeyError:\n        return pd.np.nan\n#_____________________________________________________\ndef get_director(crew_data):\n    directors = [x['name'] for x in crew_data if x['job'] == 'Director']\n    return safe_access(directors, [0])\n#_____________________________________________________\ndef pipe_flatten_names(keywords):\n    return '|'.join([x['name'] for x in keywords])\n#_____________________________________________________\ndef convert_to_original_format(movies, credits):\n    tmdb_movies = movies.copy()\n    tmdb_movies.rename(columns=TMDB_TO_IMDB_SIMPLE_EQUIVALENCIES, inplace=True)\n    tmdb_movies['title_year'] = pd.to_datetime(tmdb_movies['release_date']).apply(lambda x: x.year)\n    # I'm assuming that the first production country is equivalent, but have not been able to validate this\n    tmdb_movies['country'] = tmdb_movies['production_countries'].apply(lambda x: safe_access(x, [0, 'name']))\n    tmdb_movies['language'] = tmdb_movies['spoken_languages'].apply(lambda x: safe_access(x, [0, 'name']))\n    tmdb_movies['director_name'] = credits['crew'].apply(get_director)\n    tmdb_movies['actor_1_name'] = credits['cast'].apply(lambda x: safe_access(x, [1, 'name']))\n    tmdb_movies['actor_2_name'] = credits['cast'].apply(lambda x: safe_access(x, [2, 'name']))\n    tmdb_movies['actor_3_name'] = credits['cast'].apply(lambda x: safe_access(x, [3, 'name']))\n    tmdb_movies['genres'] = tmdb_movies['genres'].apply(pipe_flatten_names)\n    tmdb_movies['plot_keywords'] = tmdb_movies['plot_keywords'].apply(pipe_flatten_names)\n    return tmdb_movies","0070401f":"from subprocess import check_output\nprint(check_output([\"ls\", \"..\/input\/tmdb-movie-metadata\/\"]).decode(\"utf8\"))","044b96e8":"import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport math, nltk, warnings\nfrom nltk.corpus import wordnet\nfrom sklearn import linear_model\nfrom sklearn.neighbors import NearestNeighbors\nfrom fuzzywuzzy import fuzz\nfrom wordcloud import WordCloud, STOPWORDS\nplt.rcParams[\"patch.force_edgecolor\"] = True\nplt.style.use('fivethirtyeight')\nmpl.rc('patch', edgecolor = 'dimgray', linewidth=1)\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"last_expr\"\npd.options.display.max_columns = 50\n%matplotlib inline\nwarnings.filterwarnings('ignore')\nPS = nltk.stem.PorterStemmer()\n#__________________\n# load the dataset\ncredits = load_tmdb_credits(\"..\/input\/tmdb-movie-metadata\/tmdb_5000_credits.csv\")\nmovies = load_tmdb_movies(\"..\/input\/tmdb-movie-metadata\/tmdb_5000_movies.csv\")\ndf_initial = convert_to_original_format(movies, credits)\nprint('Shape:',df_initial.shape)\n#__________________________________________\n# info on variable types and filling factor\ntab_info=pd.DataFrame(df_initial.dtypes).T.rename(index={0:'column type'})\ntab_info=tab_info.append(pd.DataFrame(df_initial.isnull().sum()).T.rename(index={0:'null values'}))\ntab_info=tab_info.append(pd.DataFrame(df_initial.isnull().sum()\/df_initial.shape[0]*100).T.\n                         rename(index={0:'null values (%)'}))\ntab_info","398e5728":"set_keywords = set()\nfor liste_keywords in df_initial['plot_keywords'].str.split('|').values:\n    if isinstance(liste_keywords, float): continue  # only happen if liste_keywords = NaN\n    set_keywords = set_keywords.union(liste_keywords)\n#_________________________\n# remove null chain entry\nset_keywords.remove('')","49b5c37b":"def count_word(df, ref_col, liste):\n    keyword_count = dict()\n    for s in liste: keyword_count[s] = 0\n    for liste_keywords in df[ref_col].str.split('|'):        \n        if type(liste_keywords) == float and pd.isnull(liste_keywords): continue        \n        for s in [s for s in liste_keywords if s in liste]: \n            if pd.notnull(s): keyword_count[s] += 1\n    #______________________________________________________________________\n    # convert the dictionary in a list to sort the keywords by frequency\n    keyword_occurences = []\n    for k,v in keyword_count.items():\n        keyword_occurences.append([k,v])\n    keyword_occurences.sort(key = lambda x:x[1], reverse = True)\n    return keyword_occurences, keyword_count","88a16704":"keyword_occurences, dum = count_word(df_initial, 'plot_keywords', set_keywords)\nkeyword_occurences[:5]","15f1f84e":"#_____________________________________________\n# Function that control the color of the words\n#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n# WARNING: the scope of variables is used to get the value of the \"tone\" variable\n# I could not find the way to pass it as a parameter of \"random_color_func()\"\n#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\ndef random_color_func(word=None, font_size=None, position=None,\n                      orientation=None, font_path=None, random_state=None):\n    h = int(360.0 * tone \/ 255.0)\n    s = int(100.0 * 255.0 \/ 255.0)\n    l = int(100.0 * float(random_state.randint(70, 120)) \/ 255.0)\n    return \"hsl({}, {}%, {}%)\".format(h, s, l)\n#_____________________________________________\n# UPPER PANEL: WORDCLOUD\nfig = plt.figure(1, figsize=(18,13))\nax1 = fig.add_subplot(2,1,1)\n#_______________________________________________________\n# I define the dictionary used to produce the wordcloud\nwords = dict()\ntrunc_occurences = keyword_occurences[0:50]\nfor s in trunc_occurences:\n    words[s[0]] = s[1]\ntone = 55.0 # define the color of the words\n#________________________________________________________\nwordcloud = WordCloud(width=1000,height=300, background_color='black', \n                      max_words=1628,relative_scaling=1,\n                      color_func = random_color_func,\n                      normalize_plurals=False)\nwordcloud.generate_from_frequencies(words)\nax1.imshow(wordcloud, interpolation=\"bilinear\")\nax1.axis('off')\n#_____________________________________________\n# LOWER PANEL: HISTOGRAMS\nax2 = fig.add_subplot(2,1,2)\ny_axis = [i[1] for i in trunc_occurences]\nx_axis = [k for k,i in enumerate(trunc_occurences)]\nx_label = [i[0] for i in trunc_occurences]\nplt.xticks(rotation=85, fontsize = 15)\nplt.yticks(fontsize = 15)\nplt.xticks(x_axis, x_label)\nplt.ylabel(\"Nb. of occurences\", fontsize = 18, labelpad = 10)\nax2.bar(x_axis, y_axis, align = 'center', color='g')\n#_______________________\nplt.title(\"Keywords popularity\",bbox={'facecolor':'k', 'pad':5},color='w',fontsize = 25)\nplt.show()","beceab0b":"missing_df = df_initial.isnull().sum(axis=0).reset_index()\nmissing_df.columns = ['column_name', 'missing_count']\nmissing_df['filling_factor'] = (df_initial.shape[0] \n                                - missing_df['missing_count']) \/ df_initial.shape[0] * 100\nmissing_df.sort_values('filling_factor').reset_index(drop = True)","7358aafe":"df_initial['decade'] = df_initial['title_year'].apply(lambda x:((x-1900)\/\/10)*10)\n#__________________________________________________________________\n# function that extract statistical parameters from a grouby objet:\ndef get_stats(gr):\n    return {'min':gr.min(),'max':gr.max(),'count': gr.count(),'mean':gr.mean()}\n#______________________________________________________________\n# Creation of a dataframe with statitical infos on each decade:\ntest = df_initial['title_year'].groupby(df_initial['decade']).apply(get_stats).unstack()","6e6a5d5f":"sns.set_context(\"poster\", font_scale=0.85)\n#_______________________________\n# funtion used to set the labels\ndef label(s):\n    val = (1900 + s, s)[s < 100]\n    chaine = '' if s < 50 else \"{}'s\".format(int(val))\n    return chaine\n#____________________________________\nplt.rc('font', weight='bold')\nf, ax = plt.subplots(figsize=(11, 6))\nlabels = [label(s) for s in  test.index]\nsizes  = test['count'].values\nexplode = [0.2 if sizes[i] < 100 else 0.01 for i in range(11)]\nax.pie(sizes, explode = explode, labels=labels,\n       autopct = lambda x:'{:1.0f}%'.format(x) if x > 1 else '',\n       shadow=False, startangle=0)\nax.axis('equal')\nax.set_title('% of films per decade',\n             bbox={'facecolor':'k', 'pad':5},color='w', fontsize=16);\ndf_initial.drop('decade', axis=1, inplace = True)","6bf7ec34":"genre_labels = set()\nfor s in df_initial['genres'].str.split('|').values:\n    genre_labels = genre_labels.union(set(s))","21826c09":"keyword_occurences, dum = count_word(df_initial, 'genres', genre_labels)\nkeyword_occurences[:5]","c78a1e94":"words = dict()\ntrunc_occurences = keyword_occurences[0:50]\nfor s in trunc_occurences:\n    words[s[0]] = s[1]\ntone = 100 #\u00a0define the color of the words\nf, ax = plt.subplots(figsize=(14, 6))\nwordcloud = WordCloud(width=550,height=300, background_color='black', \n                      max_words=1628,relative_scaling=0.7,\n                      color_func = random_color_func,\n                      normalize_plurals=False)\nwordcloud.generate_from_frequencies(words)\nplt.imshow(wordcloud, interpolation=\"bilinear\")\nplt.axis('off')\nplt.show()","7983b086":"df_duplicate_cleaned = df_initial","2feaf9d7":"# Collect the keywords\n#----------------------\ndef keywords_inventory(dataframe, colonne = 'plot_keywords'):\n    PS = nltk.stem.PorterStemmer()\n    keywords_roots  = dict()  # collect the words \/ root\n    keywords_select = dict()  #\u00a0association: root <-> keyword\n    category_keys = []\n    icount = 0\n    for s in dataframe[colonne]:\n        if pd.isnull(s): continue\n        for t in s.split('|'):\n            t = t.lower() ; racine = PS.stem(t)\n            if racine in keywords_roots:                \n                keywords_roots[racine].add(t)\n            else:\n                keywords_roots[racine] = {t}\n    \n    for s in keywords_roots.keys():\n        if len(keywords_roots[s]) > 1:  \n            min_length = 1000\n            for k in keywords_roots[s]:\n                if len(k) < min_length:\n                    clef = k ; min_length = len(k)            \n            category_keys.append(clef)\n            keywords_select[s] = clef\n        else:\n            category_keys.append(list(keywords_roots[s])[0])\n            keywords_select[s] = list(keywords_roots[s])[0]\n                   \n    print(\"Nb of keywords in variable '{}': {}\".format(colonne,len(category_keys)))\n    return category_keys, keywords_roots, keywords_select","128c4776":"keywords, keywords_roots, keywords_select = keywords_inventory(df_duplicate_cleaned,\n                                                               colonne = 'plot_keywords')","d300f831":"# Plot of a sample of keywords that appear in close varieties \n#------------------------------------------------------------\nicount = 0\nfor s in keywords_roots.keys():\n    if len(keywords_roots[s]) > 1: \n        icount += 1\n        if icount < 15: print(icount, keywords_roots[s], len(keywords_roots[s]))","21f1e847":"# Replacement of the keywords by the main form\n#----------------------------------------------\ndef remplacement_df_keywords(df, dico_remplacement, roots = False):\n    df_new = df.copy(deep = True)\n    for index, row in df_new.iterrows():\n        chaine = row['plot_keywords']\n        if pd.isnull(chaine): continue\n        nouvelle_liste = []\n        for s in chaine.split('|'): \n            clef = PS.stem(s) if roots else s\n            if clef in dico_remplacement.keys():\n                nouvelle_liste.append(dico_remplacement[clef])\n            else:\n                nouvelle_liste.append(s)       \n        df_new.set_value(index, 'plot_keywords', '|'.join(nouvelle_liste)) \n    return df_new","27f1beb8":"# Replacement of the keywords by the main keyword\n#-------------------------------------------------\ndf_keywords_cleaned = remplacement_df_keywords(df_duplicate_cleaned, keywords_select,\n                                               roots = True)","f024911a":"# Count of the keywords occurences\n#----------------------------------\nkeywords.remove('')\nkeyword_occurences, keywords_count = count_word(df_keywords_cleaned,'plot_keywords',keywords)\nkeyword_occurences[:5]","057eabe8":"# get the synomyms of the word 'mot_cle'\n#--------------------------------------------------------------\ndef get_synonymes(mot_cle):\n    lemma = set()\n    for ss in wordnet.synsets(mot_cle):\n        for w in ss.lemma_names():\n            #_______________________________\n            # We just get the 'nouns':\n            index = ss.name().find('.')+1\n            if ss.name()[index] == 'n': lemma.add(w.lower().replace('_',' '))\n    return lemma   ","ff4f10c5":"# Exemple of a list of synonyms given by NLTK\n#---------------------------------------------------\nmot_cle = 'alien'\nlemma = get_synonymes(mot_cle)\nfor s in lemma:\n    print(' \"{:<30}\" in keywords list -> {} {}'.format(s, s in keywords,\n                                                keywords_count[s] if s in keywords else 0 ))","89d2856a":"# check if 'mot' is a key of 'key_count' with a test on the number of occurences   \n#----------------------------------------------------------------------------------\ndef test_keyword(mot, key_count, threshold):\n    return (False , True)[key_count.get(mot, 0) >= threshold]","4b811724":"keyword_occurences.sort(key = lambda x:x[1], reverse = False)\nkey_count = dict()\nfor s in keyword_occurences:\n    key_count[s[0]] = s[1]\n#__________________________________________________________________________\n# Creation of a dictionary to replace keywords by higher frequency keywords\nremplacement_mot = dict()\nicount = 0\nfor index, [mot, nb_apparitions] in enumerate(keyword_occurences):\n    if nb_apparitions > 5: continue  #\u00a0only the keywords that appear less than 5 times\n    lemma = get_synonymes(mot)\n    if len(lemma) == 0: continue     # case of the plurals\n    #_________________________________________________________________\n    liste_mots = [(s, key_count[s]) for s in lemma \n                  if test_keyword(s, key_count, key_count[mot])]\n    liste_mots.sort(key = lambda x:(x[1],x[0]), reverse = True)    \n    if len(liste_mots) <= 1: continue       # no replacement\n    if mot == liste_mots[0][0]: continue    # replacement by himself\n    icount += 1\n    if  icount < 8:\n        print('{:<12} -> {:<12} (init: {})'.format(mot, liste_mots[0][0], liste_mots))    \n    remplacement_mot[mot] = liste_mots[0][0]\n\nprint(90*'_'+'\\n'+'The replacement concerns {}% of the keywords.'\n      .format(round(len(remplacement_mot)\/len(keywords)*100,2)))","98f70ff3":"# 2 successive replacements\n#---------------------------\nprint('Keywords that appear both in keys and values:'.upper()+'\\n'+45*'-')\nicount = 0\nfor s in remplacement_mot.values():\n    if s in remplacement_mot.keys():\n        icount += 1\n        if icount < 10: print('{:<20}\u00a0-> {:<20}'.format(s, remplacement_mot[s]))\n\nfor key, value in remplacement_mot.items():\n    if value in remplacement_mot.keys():\n        remplacement_mot[key] = remplacement_mot[value]                    ","41fd8011":"# replacement of keyword varieties by the main keyword\n#----------------------------------------------------------\ndf_keywords_synonyms = \\\n            remplacement_df_keywords(df_keywords_cleaned, remplacement_mot, roots = False)   \nkeywords, keywords_roots, keywords_select = \\\n            keywords_inventory(df_keywords_synonyms, colonne = 'plot_keywords')","787d0ed5":"# New count of keyword occurences\n#-------------------------------------\nkeywords.remove('')\nnew_keyword_occurences, keywords_count = count_word(df_keywords_synonyms,\n                                                    'plot_keywords',keywords)\nnew_keyword_occurences[:5]","7a4f8378":"# deletion of keywords with low frequencies\n#-------------------------------------------\ndef remplacement_df_low_frequency_keywords(df, keyword_occurences):\n    df_new = df.copy(deep = True)\n    key_count = dict()\n    for s in keyword_occurences: \n        key_count[s[0]] = s[1]    \n    for index, row in df_new.iterrows():\n        chaine = row['plot_keywords']\n        if pd.isnull(chaine): continue\n        nouvelle_liste = []\n        for s in chaine.split('|'): \n            if key_count.get(s, 4) > 3: nouvelle_liste.append(s)\n        df_new.set_value(index, 'plot_keywords', '|'.join(nouvelle_liste))\n    return df_new","6237e0dd":"# Creation of a dataframe where keywords of low frequencies are suppressed\n#-------------------------------------------------------------------------\ndf_keywords_occurence = \\\n    remplacement_df_low_frequency_keywords(df_keywords_synonyms, new_keyword_occurences)\nkeywords, keywords_roots, keywords_select = \\\n    keywords_inventory(df_keywords_occurence, colonne = 'plot_keywords')    ","993c7fda":"# New keywords count\n#-------------------\nkeywords.remove('')\nnew_keyword_occurences, keywords_count = count_word(df_keywords_occurence,\n                                                    'plot_keywords',keywords)\nnew_keyword_occurences[:5]","290e6824":"# Graph of keyword occurences\n#----------------------------\nfont = {'family' : 'fantasy', 'weight' : 'normal', 'size'   : 15}\nmpl.rc('font', **font)\n\nkeyword_occurences.sort(key = lambda x:x[1], reverse = True)\n\ny_axis = [i[1] for i in keyword_occurences]\nx_axis = [k for k,i in enumerate(keyword_occurences)]\n\nnew_y_axis = [i[1] for i in new_keyword_occurences]\nnew_x_axis = [k for k,i in enumerate(new_keyword_occurences)]\n\nf, ax = plt.subplots(figsize=(9, 5))\nax.plot(x_axis, y_axis, 'r-', label='before cleaning')\nax.plot(new_x_axis, new_y_axis, 'b-', label='after cleaning')\n\n# Now add the legend with some customizations.\nlegend = ax.legend(loc='upper right', shadow=True)\nframe = legend.get_frame()\nframe.set_facecolor('0.90')\nfor label in legend.get_texts():\n    label.set_fontsize('medium')\n            \nplt.ylim((0,25))\nplt.axhline(y=3.5, linewidth=2, color = 'k')\nplt.xlabel(\"keywords index\", family='fantasy', fontsize = 15)\nplt.ylabel(\"Nb. of occurences\", family='fantasy', fontsize = 15)\n#plt.suptitle(\"Nombre d'occurences des mots cl\u00e9s\", fontsize = 18, family='fantasy')\nplt.text(3500, 4.5, 'threshold for keyword delation', fontsize = 13)\nplt.show()","12fc0215":"f, ax = plt.subplots(figsize=(12, 9))\n#_____________________________\n# calculations of correlations\ncorrmat = df_keywords_occurence.dropna(how='any').corr()\n#________________________________________\nk = 17 # number of variables for heatmap\ncols = corrmat.nlargest(k, 'num_voted_users')['num_voted_users'].index\ncm = np.corrcoef(df_keywords_occurence[cols].dropna(how='any').values.T)\nsns.set(font_scale=1.25)\nhm = sns.heatmap(cm, cbar=True, annot=True, square=True,\n                 fmt='.2f', annot_kws={'size': 10}, linewidth = 0.1, cmap = 'coolwarm',\n                 yticklabels=cols.values, xticklabels=cols.values)\nf.text(0.5, 0.93, \"Correlation coefficients\", ha='center', fontsize = 18, family='fantasy')\nplt.show()","6fcf3940":"df_var_cleaned = df_keywords_occurence.copy(deep = True)","4c83d663":"missing_df = df_var_cleaned.isnull().sum(axis=0).reset_index()\nmissing_df.columns = ['column_name', 'missing_count']\nmissing_df['filling_factor'] = (df_var_cleaned.shape[0] \n                                - missing_df['missing_count']) \/ df_var_cleaned.shape[0] * 100\nmissing_df = missing_df.sort_values('filling_factor').reset_index(drop = True)\nmissing_df","a4c3db33":"y_axis = missing_df['filling_factor'] \nx_label = missing_df['column_name']\nx_axis = missing_df.index\n\nfig = plt.figure(figsize=(11, 4))\nplt.xticks(rotation=80, fontsize = 14)\nplt.yticks(fontsize = 13)\n\nN_thresh = 5\nplt.axvline(x=N_thresh-0.5, linewidth=2, color = 'r')\nplt.text(N_thresh-4.8, 30, 'filling factor \\n < {}%'.format(round(y_axis[N_thresh],1)),\n         fontsize = 15, family = 'fantasy', bbox=dict(boxstyle=\"round\",\n                   ec=(1.0, 0.5, 0.5),\n                   fc=(0.8, 0.5, 0.5)))\nN_thresh = 17\nplt.axvline(x=N_thresh-0.5, linewidth=2, color = 'g')\nplt.text(N_thresh, 30, 'filling factor \\n = {}%'.format(round(y_axis[N_thresh],1)),\n         fontsize = 15, family = 'fantasy', bbox=dict(boxstyle=\"round\",\n                   ec=(1., 0.5, 0.5),\n                   fc=(0.5, 0.8, 0.5)))\n\nplt.xticks(x_axis, x_label,family='fantasy', fontsize = 14 )\nplt.ylabel('Filling factor (%)', family='fantasy', fontsize = 16)\nplt.bar(x_axis, y_axis);","5c2df147":"df_filling = df_var_cleaned.copy(deep=True)\nmissing_year_info = df_filling[df_filling['title_year'].isnull()][[\n            'director_name','actor_1_name', 'actor_2_name', 'actor_3_name']]\nmissing_year_info[:10]","0f844f22":"df_filling.iloc[4553]","860ebd37":"def fill_year(df):\n    col = ['director_name', 'actor_1_name', 'actor_2_name', 'actor_3_name']\n    usual_year = [0 for _ in range(4)]\n    var        = [0 for _ in range(4)]\n    #_____________________________________________________________\n    # I get the mean years of activity for the actors and director\n    for i in range(4):\n        usual_year[i] = df.groupby(col[i])['title_year'].mean()\n    #_____________________________________________\n    # I create a dictionnary collectinf this info\n    actor_year = dict()\n    for i in range(4):\n        for s in usual_year[i].index:\n            if s in actor_year.keys():\n                if pd.notnull(usual_year[i][s]) and pd.notnull(actor_year[s]):\n                    actor_year[s] = (actor_year[s] + usual_year[i][s])\/2\n                elif pd.isnull(actor_year[s]):\n                    actor_year[s] = usual_year[i][s]\n            else:\n                actor_year[s] = usual_year[i][s]\n        \n    #______________________________________\n    # identification of missing title years\n    missing_year_info = df[df['title_year'].isnull()]\n    #___________________________\n    # filling of missing values\n    icount_replaced = 0\n    for index, row in missing_year_info.iterrows():\n        value = [ np.NaN for _ in range(4)]\n        icount = 0 ; sum_year = 0\n        for i in range(4):            \n            var[i] = df.loc[index][col[i]]\n            if pd.notnull(var[i]): value[i] = actor_year[var[i]]\n            if pd.notnull(value[i]): icount += 1 ; sum_year += actor_year[var[i]]\n        if icount != 0: sum_year = sum_year \/ icount \n\n        if int(sum_year) > 0:\n            icount_replaced += 1\n            df.set_value(index, 'title_year', int(sum_year))\n            if icount_replaced < 10: \n                print(\"{:<45} -> {:<20}\".format(df.loc[index]['movie_title'],int(sum_year)))\n    return ","deea713c":"fill_year(df_filling)","e1d8958b":"icount = 0\nfor index, row in df_filling[df_filling['plot_keywords'].isnull()].iterrows():\n    icount += 1\n    liste_mot = row['movie_title'].strip().split()\n    new_keyword = []\n    for s in liste_mot:\n        lemma = get_synonymes(s)\n        for t in list(lemma):\n            if t in keywords: \n                new_keyword.append(t)                \n    if new_keyword and icount < 15: \n        print('{:<50}\u00a0-> {:<30}'.format(row['movie_title'], str(new_keyword)))\n    if new_keyword:\n        df_filling.set_value(index, 'plot_keywords', '|'.join(new_keyword)) ","712644b7":"cols = corrmat.nlargest(9, 'num_voted_users')['num_voted_users'].index\ncm = np.corrcoef(df_keywords_occurence[cols].dropna(how='any').values.T)\nsns.set(font_scale=1.25)\nhm = sns.heatmap(cm, cbar=True, annot=True, square=True,\n                 fmt='.2f', annot_kws={'size': 10}, \n                 yticklabels=cols.values, xticklabels=cols.values)\nplt.show()","b4ed9e29":"sns.set(font_scale=1.25)\ncols = ['gross', 'num_voted_users']\nsns.pairplot(df_filling.dropna(how='any')[cols],diag_kind='kde', size = 2.5)\nplt.show();","d2465d44":"def variable_linreg_imputation(df, col_to_predict, ref_col):\n    regr = linear_model.LinearRegression()\n    test = df[[col_to_predict,ref_col]].dropna(how='any', axis = 0)\n    X = np.array(test[ref_col])\n    Y = np.array(test[col_to_predict])\n    X = X.reshape(len(X),1)\n    Y = Y.reshape(len(Y),1)\n    regr.fit(X, Y)\n    \n    test = df[df[col_to_predict].isnull() & df[ref_col].notnull()]\n    for index, row in test.iterrows():\n        value = float(regr.predict(row[ref_col]))\n        df.set_value(index, col_to_predict, value)","d5ded3a1":"variable_linreg_imputation(df_filling, 'gross', 'num_voted_users')","b65f7d1b":"df = df_filling.copy(deep = True)\nmissing_df = df.isnull().sum(axis=0).reset_index()\nmissing_df.columns = ['column_name', 'missing_count']\nmissing_df['filling_factor'] = (df.shape[0] \n                                - missing_df['missing_count']) \/ df.shape[0] * 100\nmissing_df = missing_df.sort_values('filling_factor').reset_index(drop = True)\nmissing_df","51b3fd5f":"df = df_filling.copy(deep=True)\ndf.reset_index(inplace = True, drop = True)","6c1b0642":"gaussian_filter = lambda x,y,sigma: math.exp(-(x-y)**2\/(2*sigma**2))","578c229d":"def entry_variables(df, id_entry): \n    col_labels = []    \n    if pd.notnull(df['director_name'].iloc[id_entry]):\n        for s in df['director_name'].iloc[id_entry].split('|'):\n            col_labels.append(s)\n            \n    for i in range(3):\n        column = 'actor_NUM_name'.replace('NUM', str(i+1))\n        if pd.notnull(df[column].iloc[id_entry]):\n            for s in df[column].iloc[id_entry].split('|'):\n                col_labels.append(s)\n                \n    if pd.notnull(df['plot_keywords'].iloc[id_entry]):\n        for s in df['plot_keywords'].iloc[id_entry].split('|'):\n            col_labels.append(s)\n    return col_labels","1b94cfea":"def add_variables(df, REF_VAR):    \n    for s in REF_VAR: df[s] = pd.Series([0 for _ in range(len(df))])\n    colonnes = ['genres', 'actor_1_name', 'actor_2_name',\n                'actor_3_name', 'director_name', 'plot_keywords']\n    for categorie in colonnes:\n        for index, row in df.iterrows():\n            if pd.isnull(row[categorie]): continue\n            for s in row[categorie].split('|'):\n                if s in REF_VAR: df.set_value(index, s, 1)            \n    return df","822e80eb":"def recommand(df, id_entry):    \n    df_copy = df.copy(deep = True)    \n    liste_genres = set()\n    for s in df['genres'].str.split('|').values:\n        liste_genres = liste_genres.union(set(s))    \n    #_____________________________________________________\n    # Create additional variables to check the similarity\n    variables = entry_variables(df_copy, id_entry)\n    variables += list(liste_genres)\n    df_new = add_variables(df_copy, variables)\n    #____________________________________________________________________________________\n    # determination of the closest neighbors: the distance is calculated \/ new variables\n    X = df_new.as_matrix(variables)\n    nbrs = NearestNeighbors(n_neighbors=31, algorithm='auto', metric='euclidean').fit(X)\n\n    distances, indices = nbrs.kneighbors(X)    \n    xtest = df_new.iloc[id_entry].as_matrix(variables)\n    xtest = xtest.reshape(1, -1)\n\n    distances, indices = nbrs.kneighbors(xtest)\n\n    return indices[0][:]\n    ","b4df5429":"def extract_parameters(df, liste_films):     \n    parametres_films = ['_' for _ in range(31)]\n    i = 0\n    max_users = -1\n    for index in liste_films:\n        parametres_films[i] = list(df.iloc[index][['movie_title', 'title_year',\n                                        'imdb_score', 'num_user_for_reviews', \n                                        'num_voted_users']])\n        parametres_films[i].append(index)\n        max_users = max(max_users, parametres_films[i][4] )\n        i += 1\n        \n    title_main = parametres_films[0][0]\n    annee_ref  = parametres_films[0][1]\n    parametres_films.sort(key = lambda x:critere_selection(title_main, max_users,\n                                    annee_ref, x[0], x[1], x[2], x[4]), reverse = True)\n\n    return parametres_films ","274c2b26":"def sequel(titre_1, titre_2):    \n    if fuzz.ratio(titre_1, titre_2) > 50 or fuzz.token_set_ratio(titre_1, titre_2) > 50:\n        return True\n    else:\n        return False","5f2c0abc":"def critere_selection(title_main, max_users, annee_ref, titre, annee, imdb_score, votes):    \n    if pd.notnull(annee_ref):\n        facteur_1 = gaussian_filter(annee_ref, annee, 20)\n    else:\n        facteur_1 = 1        \n\n    sigma = max_users * 1.0\n\n    if pd.notnull(votes):\n        facteur_2 = gaussian_filter(votes, max_users, sigma)\n    else:\n        facteur_2 = 0\n        \n    if sequel(title_main, titre):\n        note = 0\n    else:\n        note = imdb_score**2 * facteur_1 * facteur_2\n    \n    return note","81f95575":"def add_to_selection(film_selection, parametres_films):    \n    film_list = film_selection[:]\n    icount = len(film_list)    \n    for i in range(31):\n        already_in_list = False\n        for s in film_selection:\n            if s[0] == parametres_films[i][0]: already_in_list = True\n            if sequel(parametres_films[i][0], s[0]): already_in_list = True            \n        if already_in_list: continue\n        icount += 1\n        if icount <= 5:\n            film_list.append(parametres_films[i])\n    return film_list","7e2562d9":"def remove_sequels(film_selection):    \n    removed_from_selection = []\n    for i, film_1 in enumerate(film_selection):\n        for j, film_2 in enumerate(film_selection):\n            if j <= i: continue \n            if sequel(film_1[0], film_2[0]): \n                last_film = film_2[0] if film_1[1] < film_2[1] else film_1[0]\n                removed_from_selection.append(last_film)\n\n    film_list = [film for film in film_selection if film[0] not in removed_from_selection]\n\n    return film_list   ","afe99f11":"def find_similarities(df, id_entry, del_sequels = True, verbose = False):    \n    if verbose: \n        print(90*'_' + '\\n' + \"QUERY: films similar to id={} -> '{}'\".format(id_entry,\n                                df.iloc[id_entry]['movie_title']))\n    #____________________________________\n    liste_films = recommand(df, id_entry)\n    #__________________________________\n    # Create a list of 31 films\n    parametres_films = extract_parameters(df, liste_films)\n    #_______________________________________\n    # Select 5 films from this list\n    film_selection = []\n    film_selection = add_to_selection(film_selection, parametres_films)\n    #__________________________________\n    # delation of the sequels\n    if del_sequels: film_selection = remove_sequels(film_selection)\n    #______________________________________________\n    # add new films to complete the list\n    film_selection = add_to_selection(film_selection, parametres_films)\n    #_____________________________________________\n    selection_titres = []\n    for i,s in enumerate(film_selection):\n        selection_titres.append([s[0].replace(u'\\xa0', u''), s[5]])\n        if verbose: print(\"n\u00ba{:<2}     -> {:<30}\".format(i+1, s[0]))\n\n    return selection_titres","c3ae9a23":"dum = find_similarities(df, 12, del_sequels = False, verbose = True)","807ad463":"dum = find_similarities(df, 12, del_sequels = True, verbose = True)","0fa7a999":"dum = find_similarities(df, 2, del_sequels = True, verbose = True)","607071d7":"selection = dict()\nfor i in range(0, 20, 3):\n    selection[i] = find_similarities(df, i, del_sequels = True, verbose = True)","cad87bc7":"___\n#### 2.2.2 Groups of *synonyms*\n\nClean the list of keywords in two steps. As a first step, suppress the keywords that appear less than 5 times and replace them by a synomym of higher frequency. As a second step,  suppress all the keywords that appear in less than 3 films","2867e1a1":"The **title_year** variable indicates when films were released. In order to have a global look at the way films are distributed according to this variable,  group the films by decades:","45c0855c":"Then, load in a single place all the packages that are required  throughout the notebook and then load the dataset. Then,give some information on the columns types and the number of missing values.","3443792c":"and then define a function that counts the number of times each of them appear:","1d9cdf50":" **Function adding variables to the dataframe**: the function *add\\_variables()* add a list of variables to the dataframe given in input and initialize these variables at 0 or 1 depending on the correspondance with the description of the films and the content of the REF_VAR variable given in input.","db0aa5db":"___\n### 2.2 Correlations","4e3d10dd":"___\n## 1. Exploration\n\n First, we define a few functions to create an interface with the new structure of the dataset.\n The code below is entirely taken from [Sohier's kernel](https:\/\/www.kaggle.com\/sohier\/film-recommendation-engine-converted-to-use-tmdb):","4e6268de":"**Main function**: create a list of 5 films that will be recommended to the user.","366967be":"In this matrix, the $a_{ij}$ coefficients take either the value 0 or 1 depending on the correspondance between the significance of column $j$ and the content of film $i$. For exemple, if \"keyword 1\" is in film $i$, we will have $a_{ij}$ = 1 and 0 otherwise. Once this matrix has been defined, we determine the distance between two films according to:\n\n\\begin{eqnarray}\nd_{m, n} = \\sqrt{  \\sum_{i = 1}^{N} \\left( a_{m,i}  - a_{n,i} \\right)^2  } \n\\end{eqnarray}\n\nAt this stage, we just have to select the N films which are the closest from the entry selected by the user.\n\n#### 3.1.2 Popularity\n\nAccording to similarities between entries, we get a list of $N$ films. At this stage,  select 5 films from this list and, to do so, give a score for every entryand  decide de compute the score according to 3 criteria:\n- the IMDB score\n- the number of votes the entry received\n- the year of release\n\nThe two first criteria will be a direct measure of the popularity of the various entries in IMDB. For the third criterium, I introduce the release year since the database spans films from the early $XX^{th}$ century up to now. I assume that people's favorite films will be most of the time from the same epoch.\n\nThen, I calculate the score according to the formula:","0febff1d":" **Function giving marks to films**: the *critere\\_selection()* function gives a mark to a film depending on its IMDB score,  the title year and the number of users who have voted for this film.","2e5da24d":"___\n###  2.3 Missing values\nExamine the number of missing values in each variable and then choose a methodology to complete the dataset.","2f9c5366":"and represent the results in a pie chart:","f5d571cd":"___\n### 3.2 Definition of the engine functions","74c57eb9":"___\n### 1.1 Keywords","9d103a92":"___\n### 1.2 Filling factor: missing values\n\nThe dataset consists in 5043 films or TV series which are described by 28 variables. As in every analysis, at some point, we will have to deal with the missing values and as a first step, determine the amount of data which is missing in every variable:","1395ce97":"___\n## 2. Cleaning\n___","126e70b8":"According to the values reported above,  delete a few variables from the dataframe and then re-order the columns.","19729b71":"and then counting how many times each of them occur:","45605b0c":"#### 2.3.3 Imputing from regressions\n\nIn Section 2.4, have  a look at the correlation between variables and find that  few of them showed some degree of correlation, with a Pearson's coefficient > 0.5:","2b350ed9":"This function takes the dataframe as input, as well as the names of two columns. A linear fit is performed between those two columns which is used to fill the holes in the first column that was given:","30f58367":"Finally, the result is shown as a wordcloud:","20caeaae":" **Function filtering sequels**: the *remove\\_sequels()* function remove sequels from the list if more that two films from a serie are present. The older one is kept.","6b38e7d1":"For votes, get the maximum number of votes among the $N$ films and I set $\\sigma_1 = c_1 = m$. For years, I put $\\sigma_1 = 20$ and  center the gaussian on the title year of the film selected by the user. With the gaussians, put more weight to the entries with a large number of votes and to the films whose release year is close to the title selected by the user.","30ccd306":"To develop the recommendation engine, plan to make an extensive use of the keywords that describe the films. Indeed, a basic assumption is that the  films described by similar keywords should have similar contents. Hence,  plan to have a close look at the way keywords are defined and as a first step, quickly characterize what's already in there. To do so, first list the keywords which are in the dataset:","ea2e5579":"Unfortunately, if we build the engine according to the functionalities described in Section 3.1, this is what we are told !!\n\nThe origin of that issue is quite easily understood: many blockbusters have sequels that share the same director, actors and keywords ... Most of the time, the fact that sequels exist mean that it was a \"fair\" box-office success, which is a synonym of a good IMDB score. Usually, there's an inheritence of success among sequels which entail that according to the way the current engine is built, it is quite probable that if the engine matches one film of a serie, it will end recommending various of them. In the previous exemple, we see that the engine recommends the three films of the *\"Lord of the ring\"* trilogy, as well as *\"Thor\"* and *\"Thor: the dark world\"*.well,I would personnaly not make that kind of recommendations to a friend ... \n\nHence,  tried to find a way to prevent that kind of behaviour and concluded that the quickest way to do it would be to work on the film's titles.  use the **fuzzywuzzy** package to build the *remove_sequels()* function. This function defines the degree of similarity of two film titles and if too close, the most recent film is removed from the list of recommendations. Using this function on the previous exemple, we end with the following recommendations:","a63f7271":"# **Recommendation engine**\nThis notebook aims at building a recommendation engine from the content of the TMDB dataset that contains around 5000 movies and TV series.Basically, the engine will work as follows: after the user has provided the name of a film he liked, the engine should be able to select in the database a list of 5 films that the user will enjoy. In practice, recommendation engines are of three kinds:\n- **popularity-based** engines: usually the most simple to implement be also the most impersonal\n- **content-based** engines: the recommendations are based on the description of the products\n- **collaborative filtering** engines: records from various users provide recommendations based on user similarities\n\nIn the current case, since the dataset only describe the content of the films and TV series, collaborative filtering is excluded and I will thus build an engine that uses both the content and the popularity of the entries.\n___\nThis notebook is organized as follows:\n\n**1. Exploration**\n- 1.1 Keywords\n- 1.2 Filling factor: missing values\n- 1.3 Number of films per year\n- 1.4 Genres\n\n** 2. Cleaning**\n- 2.1 Cleaning of the keywords\n    * 2.1.1 Grouping by roots\n    * 2.1.2 Groups of synonyms\n- 2.2 Correlations\n- 2.3 Missing values\n    * 2.3.1 Setting missing title years\n    * 2.3.2 Extracting keywords from the title\n    * 2.3.3 Imputing from regressions\n    \n**3. Recommendation Engine**\n- 3.1 Basic functioning of the engine \n    * 3.1.1 Similarity\n    * 3.1.2 Popularity\n- 3.2 Definition of the recommendation engine functions\n- 3.3 Making meaningfull recommendations\n- 3.4 Exemple of recommendation: test-case","bd1316ad":"___\n### 2.1 Cleaning of the keywords\n\nKeywords will play an important role in the functioning of the engine. Indeed, recommendations will be based on similarity between films and to gauge such similarities, we will look for films described by the same keywords. Hence, the content of the **plot_keywords** variable deserves some attention since it will be extensively used.\n","39f7af52":"\n\\begin{eqnarray}\n\\mathrm{score} = IMDB^2 \\times \\phi_{\\sigma_1, c_1} \\times  \\phi_{\\sigma_2, c_2}\n\\end{eqnarray}\n\nwhere $\\phi$ is a gaussian function:\n\n\\begin{eqnarray}\n\\phi_{\\sigma, c}(x) \\propto \\mathrm{exp}\\left(-\\frac{(x-c)^2}{2 \\, \\sigma^2}\\right)\n\\end{eqnarray}","4aa7f622":"At this stage, the list of keywords has been created and we know the number of times each of them appear in the dataset. In fact, this list can be used  to have a feeling of the content of the *most popular movies*. A fancy manner to give that information makes use of the *wordcloud* package. In this kind of representation, all the words are arranged in a figure with sizes that depend on their respective frequencies. Instead of a wordcloud, we can use histograms to give the same information. This allows to have a figure where the keywords are ordered by occurence and most importantly, this gives the number of times they appear, an information that can not be retrieved from the wordcloud representation. In the following figure, compare both types of representations:","4a1bef8c":"|  movie title |director   |actor 1   |actor 2   |actor 3   | keyword 1  | keyword 2   | genre 1 | genre 2 | ... |\u00a0genre k |\n|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n|Film 1   | $a_{11}$  |  $a_{12}$ |   |   |  ... |   |   |   |   | $a_{1q}$  |\n|...   |   |   |   |   | ...  |   |   |   |   |   |\n|Film i   |  $a_{i1}$ | $a_{i2}$ |   |   | $a_{ij}$  |   |   |   |   |  $a_{iq}$ |\n|...   |   |   |   |   | ...  |   |   |   |   |   |\n| Film p   |$a_{p1}$   | $a_{p2}$  |   |   | ...  |   |   |   |   | $a_{pq}$  |","027f779a":"Here, the user selected a film from the James Bond serie, *'Spectre'*, and the engine recommends him two other James Bond films, *'Casino Royale'* and *'Skyfall'*. guess that people who enjoyed *'Spectre'* will know that there is not a unique film featuring James Bond, and the current recommendation thus looks a bit irrelevant ...","4100e512":"___\n### 3.4 Exemple of recommendation: test-case","841df04e":"___\n### 3.3 Making meaningful recommendations","e418b012":"___\n#### 2.1.1 Grouping by *roots*\n\nCollect the keywords that appear in the **plot\\_keywords** variable. This list is then cleaned using the NLTK package. Finally, look for the number of occurence of the various keywords.","5a205b2a":"We can see that most of the variables are well filled since only 2 of them have a filling factor below 93%.","289c713c":" **Function creating a list of films**: the *recommand()* function create a list of N (= 31) films similar to the film selected by the user.","cd2d8cf0":" **Function adding films**: the *add\\_to\\_selection()* function complete the *film\\_selection* list which contains 5 films that will be recommended to the user. The films are selected from the *parametres\\_films* list and are taken into account only if the title is different enough from other film titles. ","4ed9bebd":"Finally,examine which amount of data is still missing in the dataframe:","cb17b468":"and we see that in the worst case, the filling factor is around 96% (excluding the **homepage** and **tagline** variables).","1b40f721":"___\n## 3. RECOMMENDATION ENGINE","ce15857d":"While building the recommendation engine, we are quickly faced to a big issue: the existence of sequels make that some recommendations may seem quite dumb ... As an exemple, somebody who enjoyed *\"Pirates of the Caribbean: Dead Man's Chest\"* would probably not like to be adviced to watch this: ","73f0534d":" **Function extracting some parameters from a list of films**: the *create\\_film\\_selection()* function extracts some variables of the dataframe given in input and returns this list for a selection of N films. This list is ordered according to criteria established in the *critere\\_selection()* function.","0a5b7c00":" **Function comparing 2 film titles**: the sequel *sequel()* function compares the 2 titles passed in input and defines if these titles are similar or not.","ab3ede78":"The **genres** variable will surely be important while building the recommendation engines since it describes the content of the film (i.e. Drama, Comedy, Action, ...). To see exactly which genres are the most popular, use the same approach as for the keywords (hence using similar lines of code), first making a census of the genres:","a7ccf3a3":"___\n#### 2.3.2 Extracting keywords from the title\n\nAs previously outlined, keywords will play an important role in the functioning of the engine. Hence, try to fill missing values in the **plot_keywords** variable using the words of the title. To do so, create the list of synonyms of all the words contained in the title and check if any of these synonyms are already in the keyword list.in that  case, add this keyword to the entry:","befb9caa":"___\n#### 2.3.1 Setting missing title years\n\n To infer the title year,  use the list of actors and the director. For each of them, determine the mean year of activity, using the current dataset.Then average the values obtained to estimate the title year.","d2d25564":"First, define a function that impute the missing value from a linear fit of the data:","28771a0b":"which seems far more reasonable !! \n\nBut, well, nothing is perfect. This way of discarding some recommendations assumes that there is a continuity in the names of films pertaining to a serie. This is however not always the case:","fb361aa0":"___\n### 1.4 Genres","d93254a5":"The content of this table is now represented:","a9170b3a":" **Function collecting some variables content**: the *entry\\_variables()* function returns the values taken by the variables *'director\\_name', 'actor\\_N\\_name'* (N $\\in$ [1:3]) and *'plot\\_keywords'* for the film selected by the user.","aafdc342":" use this to find and fill the missing values of the **gross**, **num_critic_for_reviews**, **num\\_voted\\_users** , and **num_user_for_reviews** variables. To do so, make regressions on pairs of correlated variables:","4d16de7a":"Note that this function will be used again in other sections of this notebook, when exploring the content of the *'genres'* variable and subsequently while cleaning the keywords. Finally, calling this function gives access to a list of keywords which are sorted by decreasing frequency:","ee805c91":"___\n###\u00a01.3 Number of films per year","6c2be978":"___\n### 3.1 Basic functioning of the engine \n order to build the recommendation engine, I will basically proceed in two steps:\n- 1\/ determine $N$ films with a content similar to the entry provided by the user\n- 2\/ select the 5 most popular films among these $N$ films\n\n#### 3.1.1 Similarity\nWhen builing the engine, the first step thus consists in defining a criteria that would tell us how close two films are. To do so,start from the description of the film that was selected by the user: from it,  get the director name, the names of the actors and a few keywords. then build a matrix where each row corresponds to a film of the database and where the columns correspond to the previous quantities (director + actors + keywords) plus the *k* genres that were described in section 1.4:\n"}}