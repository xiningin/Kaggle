{"cell_type":{"71480740":"code","64df854f":"code","6c5dc7cc":"code","b08ed313":"code","3ecfb556":"code","cabfb0c0":"code","b0d0bdc3":"code","08538de4":"code","f9ba7910":"code","f01d6b9b":"code","382144d9":"code","598deec4":"code","31dc34ec":"code","e9fdb661":"code","28855a62":"code","ab352483":"code","76973a32":"code","962d9819":"code","fb75721f":"code","91db2c98":"code","3b6553ad":"code","1a27f4b8":"code","9448be0a":"code","05c6d293":"code","4a31db45":"code","b5da3fa4":"code","f2af6422":"code","7a88c220":"code","62750830":"code","16b9c360":"code","5f230d5f":"code","6426676e":"code","57146c5f":"code","0169c1e9":"code","1359dad4":"code","96bd8489":"code","1c1597b2":"code","7bd4c953":"code","b57560f0":"code","ee9d2de3":"code","5f4f8192":"code","2250b93c":"code","c5d9a6c3":"code","1abf7241":"code","c0cf542a":"code","06da75ab":"code","40e436d3":"code","b5fdc659":"code","cfe5f072":"code","f83539af":"code","4e3f9047":"code","209c5286":"code","f565cdd5":"code","0e496b76":"code","e41d1ce4":"code","6962d6c6":"code","b5263156":"code","0b398456":"code","7242e3c7":"code","57631e47":"code","76aaf6d4":"code","7d0591cf":"code","1a8448dd":"code","10a4fe57":"code","b9a22666":"code","261f8d37":"code","a6e02bee":"code","49eef329":"code","9c19d29e":"code","407207e1":"code","ee43be8d":"code","a0b59a25":"code","f7f5e296":"code","8aba4d8c":"code","d36a8805":"code","5ff24871":"code","e460a0b1":"code","4faf19c1":"code","777e6c74":"code","add48b11":"code","8407fdcc":"code","ef195f45":"code","c59830aa":"code","80ed0951":"code","e915620f":"code","7975224a":"code","bd78a18d":"code","5ececb29":"code","ff9e1eba":"code","b0e2a40b":"code","bfb5cbe8":"code","a996a515":"code","63f8b959":"code","b90bb227":"code","dda98b48":"code","cd97d188":"code","3f2ae1a9":"code","09f9e498":"code","ffa6c192":"code","939e8e8e":"code","c47a975a":"code","c40cb4e6":"code","b9a7e991":"code","7ec64882":"code","7c759b3f":"code","267c190c":"code","678d121a":"code","ad89c205":"code","c3a2e865":"code","82e79bfd":"code","da3e63d4":"code","601f417e":"code","1bb8e1a5":"code","e65c7e4e":"code","ed2b00ee":"code","1d2936c4":"code","32cf5b5d":"code","7530b370":"code","b90924d3":"code","24501f50":"code","21549131":"code","9558540c":"code","7f9b2557":"code","4099b715":"code","605dc103":"code","f3063ea5":"code","ea351c9c":"code","7290d5c8":"code","7453daed":"code","eb722b4f":"code","c31de59e":"code","5195488d":"code","c6f9a840":"code","8fb88a6b":"code","7d2cc146":"code","c8e888b3":"code","2ec32015":"code","0eae5d32":"code","1106d565":"code","ac4e385c":"code","59bf61f6":"code","3fa9ee82":"code","30e65fe5":"code","51a1f424":"code","ff768df5":"code","59686ef0":"code","9ba47dee":"code","2bc525b6":"code","490d1ccc":"code","1062a625":"code","b4dada1c":"code","2a942d7c":"code","2ae9882d":"code","43187fc1":"code","51cdc22f":"code","ec66dc60":"code","f0b02175":"code","ab0c76ac":"code","70870151":"code","6948e987":"code","8280c417":"code","502e1841":"code","877cf7f9":"code","f57f35ec":"code","7d97d354":"code","898c7d09":"code","fa1216e4":"code","b8f51359":"code","2f1dc8c3":"code","b438e49f":"code","6914b354":"code","d86cb26b":"code","88310673":"code","642bc771":"code","bb69fa60":"code","c6d67bb7":"code","f9bd067c":"code","399b0610":"code","fd8fc6cd":"code","409a0831":"code","9dcdcc19":"code","0e4e62bb":"code","425a8ded":"code","3ef58b45":"code","83551a47":"code","74aa318c":"code","741c9ffa":"code","40ec1388":"code","309b4c30":"code","86800f68":"code","86736c3a":"code","56954ee7":"code","5a22b22f":"code","8241c869":"code","4dd0fdfb":"code","34510670":"code","c609244c":"code","5f1811b8":"code","0135fd67":"code","c374c81b":"code","43535b86":"code","ac136176":"code","de68f405":"code","f7d135bc":"code","59d5f697":"code","620ce29e":"code","9abc34f2":"code","4d5a41cf":"code","bdb62f6f":"code","defb3444":"code","57d6f5c1":"code","282238f6":"code","52dd246a":"code","910c3549":"code","3da456a0":"code","828aca46":"code","40c9be15":"code","6bc98685":"code","095590ba":"code","2a875353":"code","f13c018c":"code","f7578933":"code","91523908":"code","2fbf4f74":"code","5368844c":"code","043c598e":"code","796f77af":"code","d9a5c078":"code","b8126f8d":"code","54127b42":"code","ba67c7bb":"code","df031ca0":"code","47980af5":"code","74ae2877":"code","03811882":"code","dbb4947f":"code","fda8f96f":"code","1d4ca9bd":"code","a151bd3b":"code","262d2925":"code","739e1efc":"code","0733b747":"code","46d56fb3":"code","32c23421":"code","db15a984":"code","ac12b97a":"code","4e4f1c0f":"markdown","52632dba":"markdown","1bca7075":"markdown","9aa90c06":"markdown","bd0b9a00":"markdown","a21c182c":"markdown","b287ca28":"markdown","e154f7b9":"markdown","60f18168":"markdown","eb43127e":"markdown","2d065534":"markdown","01980931":"markdown","26d6ca64":"markdown","b3b098e3":"markdown","3cacc767":"markdown","6f1fa665":"markdown","ccafe702":"markdown","1a9b1476":"markdown","8ae17531":"markdown","cc8e7827":"markdown","1e946050":"markdown","84ab24b4":"markdown","48f6ad8f":"markdown","d8bdc418":"markdown","50ac0eea":"markdown","12a4e26f":"markdown","e3819fa9":"markdown","ea93dcc1":"markdown","c192fb8e":"markdown","c73ecd6f":"markdown","3afeeba1":"markdown","257ea74b":"markdown","6a52deac":"markdown","fcb9155b":"markdown","bb78ab51":"markdown","9b8f279a":"markdown","21639bfb":"markdown","701e6c7a":"markdown","f488133a":"markdown","e8cde5a7":"markdown","e31879bb":"markdown","360c45d1":"markdown","45f65968":"markdown","34bfe9d5":"markdown","cf23e2ec":"markdown","622e2d1c":"markdown","788801e8":"markdown","df28e679":"markdown","b328baee":"markdown","eb551002":"markdown","23cb5a19":"markdown","985defe1":"markdown","fabf0f48":"markdown","9b1e0e91":"markdown","e71cef52":"markdown","eec0e116":"markdown","9a512564":"markdown","3cc6ee82":"markdown","df57893f":"markdown","a78a67aa":"markdown","17321330":"markdown","29c7f995":"markdown","c38507c0":"markdown","55601a99":"markdown","3fbca3c7":"markdown","f3f7372b":"markdown","adac0558":"markdown","fe29e8bf":"markdown","de06aa5c":"markdown","96a96000":"markdown","885c878f":"markdown","11572068":"markdown","7104c30c":"markdown","e904754d":"markdown","d15114a3":"markdown","88f34485":"markdown","1b2dff3a":"markdown","a28ea52c":"markdown","51675edb":"markdown","e8979695":"markdown","68486098":"markdown"},"source":{"71480740":"import numpy as np","64df854f":" np.version.version","6c5dc7cc":"np.array([1,2,3,4,5])","b08ed313":"# type np. and then press tab to see all components\nnp","3ecfb556":"# to view numpy documentation\nnp?","cabfb0c0":"# a list in python\nl=list(range(10))\nl","b0d0bdc3":"type(l)","08538de4":"type(l[0])","f9ba7910":"l1=[str(c) for c in l]\nl1","f01d6b9b":"type(l1)","382144d9":"type(l1[0])","598deec4":"l2=[2,1,'1',bool,True]\np2=[type(c) for c in l2]","31dc34ec":"p2","e9fdb661":"import array","28855a62":"l=list(range(10))","ab352483":"Array=array.array('i',l)\nArray\n# here 'i' represents it is a array of type integer","76973a32":"import numpy as np","962d9819":"# using a list to create an array\nnp.array([1,2,3,4,5])","fb75721f":"# all the types in numpy array should be same if not values are upcasted if possible\nnp.array([1.0,2,3,4,5])\n# converts everyone integer to floating point","91db2c98":"np.array([1,2,3,4,'5'])","3b6553ad":"# if we want to set data type of a array explicitly\nnp.array([1,2,3,4,5],dtype='float32')","1a27f4b8":"# creating a multidimensional array in numpy\nx=np.array([range(3)])\nprint(x)\nnp.array([range(i,i+3) for i in [2,4,6]])","9448be0a":"# create a size specified array of only 0, np.zeros()\nnp.zeros(10)","05c6d293":"# mention data type of array explicitly\nnp.zeros(10,dtype=int)","4a31db45":"# create a 3x5 array filled with one,np.ones()\nnp.ones((3,5),dtype=float)","b5da3fa4":"# a 3x5 matrix filled with zeros\nnp.zeros((3,5),dtype=int)","f2af6422":"# create a np array filled with 3.14,np.full()\nnp.full(10,3.14)","7a88c220":"np.full((3,5),3.14)","62750830":"# Create an array filled with a linear sequence\n# Starting at 0, ending at 20, stepping by 2\nnp.arange(0,20,2)","16b9c360":"# create a equi spaced array from 0 to 1 with 5 elements\nnp.linspace(0,1,5)","5f230d5f":"# create a 3x3 array filled with random value between 0 and 1\nnp.random.random((3,5))","6426676e":"# create a 3x3e array with mean 0 and standard deviation 1\nnp.random.normal(0,1,(3,3))","57146c5f":"# mean 2 and standard deviation 2\nnp.random.normal(2,2,(3,3))","0169c1e9":"# create a 3x3 array fileed with random values from 0 to 10\nnp.random.randint(0,10,(3,3))","1359dad4":"# create a 3x3 identity matrix\nnp.eye(3,dtype=int)","96bd8489":"# create a empty array of size 3 ,gets filled with whatever values are already exist\nnp.empty((3,3))","1c1597b2":"np.empty(3)","7bd4c953":"np.zeros(10,dtype=int)","b57560f0":"np.zeros(10,dtype=float)","ee9d2de3":"np.zeros(10,dtype='int16')","5f4f8192":"np.zeros(10,dtype=np.int16)","2250b93c":"# refer page 41 of the book to view more supported dtypes","c5d9a6c3":"np.random.seed(0)\nx1=np.random.randint(10,size=6)","1abf7241":"# every np array has attributes ndim,shape,size for its dimension,shape, and total size\nx1.ndim","c0cf542a":"x1.shape","06da75ab":"x1.size","40e436d3":"x2=np.random.randint(10,size=(2,3))","b5fdc659":"x2.ndim","cfe5f072":"x2.shape","f83539af":"x2.size","4e3f9047":"# we also have dtype to see data type of array\nx2.dtype","209c5286":"x2.itemsize","f565cdd5":"x2.nbytes","0e496b76":"# accessing array elememts\nx1","e41d1ce4":"x1[0]","6962d6c6":"# to index from the end use -1 and so on\nx1[-1]","b5263156":"x1[-2]","0b398456":"x2","7242e3c7":"# to access elements in a multidim array\nprint(x2[0,0])\nprint(x2[(0,0)])","57631e47":"print(x2[0,1])","76aaf6d4":"## modify values using abov notation\nx2[0,1]=10","7d0591cf":"x2","1a8448dd":"# if we assign a float value it will be truncated because its a int array\nx2[0,0]=99.15\nx2","10a4fe57":"x=np.arange(10)\nx","b9a22666":"# get first 5 element subarray\nx[:5]","261f8d37":"x[2:5]","a6e02bee":"x[5:]","49eef329":"# steps of 2\nx[::2]","9c19d29e":"x[1::2]","407207e1":"# if step value is negative , start and stop are swapped, easy way to reverse an array\nx[::-1]","ee43be8d":"x[5::-2]","a0b59a25":"x2=np.random.randint(20,size=(3,4))","f7f5e296":"x2","8aba4d8c":"x2[:,:]","d36a8805":"# upto second row and second column\nx2[:2,:2]","5ff24871":"# all rows alternate columns\nx2[:,::2]","e460a0b1":"# reversin array altogether\nx2[::-1,::-1]","4faf19c1":"# accessing 1st column of an array\nprint(x2)\nprint(x2[:,0])","777e6c74":"# print first row of x2\nprint(x2[0,:])","add48b11":"# also can be used\nprint(x2[0])","8407fdcc":"print(x2)","ef195f45":"x2_sub=x2[:2,:2]","c59830aa":"x2_sub","80ed0951":"x2_sub[0,0]=45","e915620f":"# we see that x2 is changed as well despite making changes only in x2_sub, \n# this is because np array slicing return views instead of copy of array data\nprint(x2)","7975224a":"# to create copy we use copy()\nx2_sub_copy=x2[:2,:2].copy()","bd78a18d":"x2_sub_copy","5ececb29":"x2_sub_copy[0,0]=100","ff9e1eba":"# x2 has no change in this case\nx2","b0e2a40b":"np.arange(9)","bfb5cbe8":"# to reshape easiest way is to use reshape()\nnp.arange(9).reshape((3,3))","a996a515":"# note that for this to work size of original array should match the size of the new array\nnp.arange(9).reshape((3,4))","63f8b959":"#Another common reshaping pattern is the conversion of a one-dimensional array\n#into a two-dimensional row or column matrix. You can do this with the reshape\n#method, or more easily by making use of the newaxis keyword within a slice operation:\nx=np.array([1,2,3])\nx.reshape((1,3))","b90bb227":"#can also use np.newaxis in slicing mode\nx[np.newaxis,:]","dda98b48":"x.reshape((3,1))","cd97d188":"x[:,np.newaxis]","3f2ae1a9":"x=np.array([1,2,3])\ny=np.array([4,5,6])\nnp.concatenate([x,y])","09f9e498":"z=np.array([7,8,9])\nnp.concatenate([x,y,z])","ffa6c192":"p=np.array([[1,2,3],[4,5,6]])\nq=np.array([[7,8,9],[10,11,12]])\nnp.concatenate([p,q])","939e8e8e":"np.concatenate([p,q],axis=1)","c47a975a":"# vertical stack\nx=np.array([1,2,3])\ny=np.array([[4,5,6],[7,8,9]])\nnp.vstack([x,y])","c40cb4e6":"x=np.array([[99],[99]])\nnp.hstack([x,y])","b9a7e991":"x=np.array([1,2,3,4,5,6,7,8,9])","7ec64882":"#Notice that N split points lead to N + 1 subarrays.\ny1,y2,y3=np.split(x,[3,5])","7c759b3f":"y1","267c190c":"y2","678d121a":"y3","ad89c205":"y1,y2,y3,y4=np.split(x,[3,5,8])\nprint(y1)\nprint(y2)\nprint(y3)\nprint(y4)","c3a2e865":"grid=np.arange(16).reshape([4,4])","82e79bfd":"grid","da3e63d4":"upper,lower=np.vsplit(grid,[2])\n# try changing value of 2 to see result change","601f417e":"print(upper)\nprint(lower)","1bb8e1a5":"left,right=np.hsplit(grid,[2])\ngrid","e65c7e4e":"print(left)\nprint(right)","ed2b00ee":"# lets calculate reciprocal of an array elements\nl=np.random.randint(1,10,size=5)\nl","1d2936c4":"def reciprocal(l):\n    output=np.empty(len(l))\n    for i in range(len(l)):\n        output[i]=1\/l[i]\n    (output)","32cf5b5d":"# lets calculate time taken for this loop for 5 elements by using timeit\n%timeit reciprocal(l)","7530b370":"# lets calculate for 1000000 elements\nl=np.arange(1,1000001)\nprint(len(l))","b90924d3":"# this takes lot of time to compute\n%timeit reciprocal(l)","24501f50":"%timeit reciprocal(l)","21549131":"# directly performing operation on array\n%timeit (1.0\/l)","9558540c":"np.arange(5)\/np.arange(1,6)","7f9b2557":"x=np.arange(9).reshape((3,3))\nx","4099b715":"#each element replaced by 2^that element\n2**x","605dc103":"# each element^2\nx**2","f3063ea5":"x=np.arange(1,5)\nx","ea351c9c":"print(\"x+5=\",x+5)","7290d5c8":"print(\"x-5=\",x-5)","7453daed":"print(\"x\/2=\",x\/2)","eb722b4f":"print(\"x*2=\",x*2)","c31de59e":"print(\"x\/\/2=\",x\/\/2)","5195488d":"# ** for exponent\n# % for modulus\nprint(x**2)\nprint(x%2)","c6f9a840":"# In addition, these can be strung together however you wish, and the standard order\n# of operations is respected:\n-(.5*x+1)**2","8fb88a6b":"# arithmetic operations implemented in numpy\nprint(x)\nprint(np.add(x,2)) # x+2\nprint(np.subtract(x,2)) #x-2\nprint(np.negative(x)) #-x\nprint(np.multiply(x,2)) #x*2\nprint(np.divide(x,2)) #x\/2\nprint(np.floor_divide(x,2)) #x\/\/2\nprint(np.power(x,2)) #x^2\nprint(np.mod(x,2)) #x%2\n# we will also see boolean and bitwise operations later","7d2cc146":"# inbuilt absolute function\ny=np.array([-1,-2,-3,-4])\nprint(abs(y))\nprint(np.absolute(y))\nprint(np.abs(y))","c8e888b3":"theta=np.linspace(0,np.pi,3)\ntheta","2ec32015":"x=np.sin(theta)\nx","0eae5d32":"np.cos(theta)","1106d565":"np.tan(theta)","ac4e385c":"#The values are computed to within machine precision, which is why values that\n#should be zero do not always hit exactly zero. Inverse trigonometric functions are also\n#available:\n\nnp.arcsin(x)","59bf61f6":"# exponential  \nnp.exp(x) #e^x","3fa9ee82":"x=np.array([1,0,2]) #2^x\nnp.exp2(x)","30e65fe5":"np.power(3,x)\n#3^x","51a1f424":"# log functions\nx=np.array([1,2,3,4])\nnp.log(x) #ln(x)","ff768df5":"np.log2(x) #log2(x)","59686ef0":"np.log10(x) #log10(x)","9ba47dee":"# when x is very small ,use this function istead of above discussed..these are expm1 and log1p as they give more accurate result for smaller value\nx=np.array([0,0.1,0.01,0.001])","2bc525b6":"np.expm1(x) #exp(x)-1","490d1ccc":"np.log1p(x) # log(1+x)","1062a625":"x=np.arange(5)\nprint(\"value in x =\",x)\ny=np.empty(5,dtype=int)\nnp.multiply(x,2,out=y)\nprint(\"value of y =\",y)","b4dada1c":"#This can even be used with array views. For example, we can write the results of a\n#computation to every other element of a specified array:\n\ny=np.zeros(10)\nnp.power(2,x,out=y[::2])\nprint(y)","2a942d7c":"x=np.arange(1,6)\nprint(x)\nnp.add.reduce(x)","2ae9882d":"np.multiply.reduce(x)","43187fc1":"# if we like to store all the intermediate values , we can use accumulate\nnp.add.accumulate(x)","51cdc22f":"np.multiply.accumulate(x)","ec66dc60":"x=np.arange(1,6)\nnp.multiply.outer(x,x)","f0b02175":"np.add.outer(x,x)","ab0c76ac":"#As a quick example, consider computing the sum of all values in an array. Python\n#itself can do this using the built-in sum function:\nx=np.random.randint(1,100,size=10000)\nsum(x)","70870151":"# numpy sum function\nnp.sum(x)","6948e987":"# However, because it executes the operation in compiled code, NumPy\u2019s version of the\n#operation is computed much more quickly:\n%timeit sum(x)","8280c417":"%timeit np.sum(x)","502e1841":"x=np.arange(50,100000)","877cf7f9":"# python inbuilt min and numpy min ,again where numpy implementation is much fatser\nprint(min(x))\nnp.min(x)","f57f35ec":"print(max(x))\nnp.max(x)","7d97d354":"%timeit min(x)","898c7d09":"%timeit np.min(x)","fa1216e4":"# we can also use methods of array objects\nx.min(),x.max()","b8f51359":"x=np.random.random((3,4))\nx","2f1dc8c3":"# by default over entire table\nx.sum()","b438e49f":"# The function returns four values, corresponding to the four columns of numbers.\nx.sum(axis=0)","6914b354":"x.sum(axis=1)","d86cb26b":"# to find max value within each row\nx.max(axis=1)","88310673":"np.sum(x)","642bc771":"# nan support sum aggregate\nnp.nansum(x)","bb69fa60":"x=np.array([1,2,3,4])\ny=np.array([5,6,7,8])","c6d67bb7":"x+y","f9bd067c":"x+5","399b0610":"arr=np.arange(9).reshape((3,3))","fd8fc6cd":"arr","409a0831":"z=[1,2,3]\narr+z","9dcdcc19":"a=np.arange(3)\na","0e4e62bb":"b=np.arange(3)[:,np.newaxis]\nb","425a8ded":"a+b\n","3ef58b45":"# example where one array is broadcasted\nm=np.ones((3,3))","83551a47":"a=np.arange(3)\n# a is broadcasted","74aa318c":"m+a","741c9ffa":"# example where both arrays are broadcasted","40ec1388":"m=np.array([0,1,2])","309b4c30":"n=np.array([0,1,2]).reshape((3,1))","86800f68":"m+n","86736c3a":"# example where 2 arrays are not compatible","56954ee7":"m=np.ones((3,2))\nn=np.arange(3)","5a22b22f":"m+n","8241c869":"x=np.array([1,2,3,4])\nx<3","4dd0fdfb":"x>3","34510670":"x<=3","c609244c":"x>=3","5f1811b8":"x!=3","0135fd67":"x==3","c374c81b":"x*2==x**2","43535b86":"# works on 2d array\nx=np.random.randint(0,10,(3,3))","ac136176":"x","de68f405":"x<4","f7d135bc":"# To count the number of True entries in a Boolean array, np.count_nonzero is useful\nnp.count_nonzero(x<4)","59d5f697":"np.sum(x<4)","620ce29e":"#The benefit of sum() is that like with other NumPy aggregation functions, this summation\n# can be done along rows or columns as well:\n\n## how many values less than 4 in each row?\nnp.sum(x<4,axis=1)\n# This counts the number of values less than 4 in each row of the matrix.","9abc34f2":"# If we\u2019re interested in quickly checking whether any or all the values are true, we can\n# use (you guessed it) np.any() or np.all():\nnp.any(x<6)","4d5a41cf":"np.all(x<6)","bdb62f6f":"np.any(x<6,axis=1)","defb3444":"x=np.arange(0,10,2)","57d6f5c1":"np.sum((x>3) & (x<6))","282238f6":"np.bitwise_and(x,1)","52dd246a":"x=np.arange(9).reshape((3,3))","910c3549":"x<5","3da456a0":"x[x<5]","828aca46":"bool(42),bool(0)","40c9be15":"bool(42 and 0)","6bc98685":"42 and 0","095590ba":"42 and 11","2a875353":"1 and 2","f13c018c":"2 and 1","f7578933":"42 & 20","91523908":"3 & 1","2fbf4f74":"1 & 3","5368844c":"3 | 2","043c598e":"4|2","796f77af":"bin(2)","d9a5c078":"bin(4)","b8126f8d":"bin(6)","54127b42":"bin(4|2)","ba67c7bb":" #When you have an array of Boolean values in NumPy, this can be thought of as a\n#string of bits where 1 = True and 0 = False, and the result of & and | operates in a\n#similar manner as before:\n\na=np.array([1,0,1,0,1])\nb=np.array([0,1,1,1,0])\na|b","df031ca0":"a=np.array([1,0,1,0,1],dtype=bool)\nb=np.array([0,1,1,1,0],dtype=bool)\na|b","47980af5":"a=np.array([1,0,1,0,1],dtype=bool)\nb=np.array([0,1,1,1,0],dtype=bool)\na&b","74ae2877":"a |b","03811882":"x=np.random.randint(100,size=20)","dbb4947f":"x","fda8f96f":"# suppose we want to access 3 different element \n[x[2],x[9],x[17]]","1d4ca9bd":"ind=[2,9,17]\nx[ind]","a151bd3b":"ind=np.array([[1,2],[3,4]])\nx[ind]","262d2925":"# fancy indexing also works on multiple dimension\nx=np.arange(12).reshape((3,4))\nx","739e1efc":"row=np.array([0,1,2])\ncol=np.array([1,2,3])\nx[row,col]\n# first value is x[0,1] then x[1,2] then x[2,3]","0733b747":"x[row[:,np.newaxis],col]","46d56fb3":"x","32c23421":"x[2,[0,1,2]]","db15a984":"x[1:,[2,0,1]]","ac12b97a":"# we can combine fancy indexing with masking\nmask=np.array([1,0,1,0],dtype=bool)\nx[row[:,np.newaxis],mask]","4e4f1c0f":"Aggregation functions take an additional argument specifying the axis along which\nthe aggregate is computed. For example, we can find the minimum value within each\ncolumn by specifying axis=0:","52632dba":"The opposite of concatenation is splitting, which is implemented by the functions\nnp.split, np.hsplit, and np.vsplit. For each of these, we can pass a list of indices\ngiving the split points:","1bca7075":"## array attributes","9aa90c06":"Up until now, we have been discussing some of the basic nuts and bolts of NumPy; in\nthe next few sections, we will dive into the reasons that NumPy is so important in the\nPython data science world. Namely, it provides an easy and flexible interface to optimized\ncomputation with arrays of data.\nComputation on NumPy arrays can be very fast, or it can be very slow. The key to\nmaking it fast is to use vectorized operations, generally implemented through Num\u2010\nPy\u2019s universal functions (ufuncs). This section motivates the need for NumPy\u2019s ufuncs,\nwhich can be used to make repeated calculations on array elements much more efficient.\nIt then introduces many of the most common and useful arithmetic ufuncs\navailable in the NumPy package.","bd0b9a00":"The way the axis is specified here can be confusing to users coming from other languages.\nThe axis keyword specifies the dimension of the array that will be collapsed,\nrather than the dimension that will be returned. So specifying axis=0 means that the\nfirst axis will be collapsed: for two-dimensional arrays, this means that values within\neach column will be aggregated.","a21c182c":"## Using the Keywords and\/or Versus the Operators &\/|","b287ca28":"### multidimensional aggregates","e154f7b9":"Often when you are faced with a large amount of data, a first step is to compute summary\nstatistics for the data in question. Perhaps the most common summary statistics\nare the mean and standard deviation, which allow you to summarize the \u201ctypical\u201d values\nin a dataset, but other aggregates are useful as well (the sum, product, median,\nminimum and maximum, quantiles, etc.).\n\nNumPy has fast built-in aggregation functions for working on arrays; we\u2019ll discuss\nand demonstrate some of them here.","60f18168":"Vectorized operations in NumPy are implemented via ufuncs, whose main purpose is\nto quickly execute repeated operations on values in NumPy arrays. Ufuncs are\nextremely flexible\u2014before we saw an operation between a scalar and an array, but we\ncan also operate between two arrays:","eb43127e":"## array concatination and splitting","2d065534":"Broadcasting allows these types of binary operations to be performed on arrays of different\nsizes\u2014for example, we can just as easily add a scalar (think of it as a zerodimensional\narray) to an array:","01980931":"## fancy indexing","26d6ca64":"We can think of this as an operation that stretches or duplicates the value 5 into the\narray [5, 5, 5, 5], and adds the results. The advantage of NumPy\u2019s broadcasting is that\nthis duplication of values does not actually take place, but it is a useful mental model\nas we think about broadcasting.","b3b098e3":"Similarly, Python has built-in min and max functions, used to find the minimum value\nand maximum value of any given array:","3cacc767":"As in the case of arithmetic operators, the comparison operators are implemented as\nufuncs in NumPy; for example, when you write x < 3, internally NumPy uses\nnp.less(x, 3). A summary of the comparison operators and their equivalent ufunc\nis shown here:\nOperator    Equivalent ufunc\n\n== np.equal\n\n!= np.not_equal\n\n< np.less\n\n<= np.less_equal\n\n, > np.greater\n\n, >= np.greater_equal","6f1fa665":"Be careful, though: the sum function and the np.sum function are not identical, which\ncan sometimes lead to confusion! In particular, their optional arguments have different\nmeanings, and np.sum is aware of multiple array dimensions, as we will see in the\nfollowing section.","ccafe702":"### splitting array","1a9b1476":"Just as we can use square brackets to access individual array elements, we can also use\nthem to access subarrays with the slice notation, marked by the colon (:) character.\nThe NumPy slicing syntax follows that of the standard Python list; to access a slice of\nan array x, use this:\nx[start:stop:step]\nIf any of these are unspecified, they default to the values start=0, stop=size of\ndimension, step=1.","8ae17531":"## aggregations: min, max and everything in between","cc8e7827":"## exploring numpy's ufuncs ","1e946050":"# numpy arrays","84ab24b4":"## reshaping arrays","48f6ad8f":"np.sum np.nansum Compute sum of elements\n\nnp.prod np.nanprod Compute product of elements\n\nnp.mean np.nanmean Compute median of elements\n\nnp.std np.nanstd Compute standard deviation\n\nnp.var np.nanvar Compute variance\n\nnp.min np.nanmin Find minimum value\n\nnp.max np.nanmax Find maximum value\n\nnp.argmin np.nanargmin Find index of minimum value\n\nnp.argmax np.nanargmax Find index of maximum value\n\nnp.median np.nanmedian Compute median of elements\n\nnp.percentile np.nanpercentile Compute rank-based statistics of elements\n\nnp.any N\/A Evaluate whether any elements are true\n\nnp.all N\/A Evaluate whether all elements are true","d8bdc418":"### trigonometric functions","50ac0eea":"One important\u2014and extremely useful\u2014thing to know about array slices is that they\nreturn views rather than copies of the array data. This is one area in which NumPy\narray slicing differs from Python list slicing: in lists, slices will be copies.","12a4e26f":"# difference between a python list and numpy array","e3819fa9":"While these examples are relatively easy to understand, more complicated cases can\ninvolve broadcasting of both arrays. Consider the following example:","ea93dcc1":"### create copies","c192fb8e":"Finally, any ufunc can compute the output of all pairs of two different inputs using\nthe outer method. This allows you, in one line, to do things like create a multiplication\ntable:","c73ecd6f":"Looking at the execution time for our big array, we see that it completes orders of\nmagnitude faster than the Python loop:\nFor many types of operations, NumPy provides a convenient interface into just this\nkind of statically typed, compiled routine. This is known as a vectorized operation.\nYou can accomplish this by simply performing an operation on the array, which will\nthen be applied to each element. This vectorized approach is designed to push the\nloop into the compiled layer that underlies NumPy, leading to much faster execution.","3afeeba1":"Rules of Broadcasting\nBroadcasting in NumPy follows a strict set of rules to determine the interaction\nbetween the two arrays:\n\n\u2022 Rule 1: If the two arrays differ in their number of dimensions, the shape of the\none with fewer dimensions is padded with ones on its leading (left) side.\n\n\u2022 Rule 2: If the shape of the two arrays does not match in any dimension, the array\nwith shape equal to 1 in that dimension is stretched to match the other shape.\n\n\u2022 Rule 3: If in any dimension the sizes disagree and neither is equal to 1, an error is\nraised.","257ea74b":"Concatenation, or joining of two arrays in NumPy, is primarily accomplished\nthrough the routines np.concatenate, np.vstack, and np.hstack. np.concatenate\ntakes a tuple or list of arrays as its first argument, as we can see here:","6a52deac":"We saw in the previous section how NumPy\u2019s universal functions can be used to vectorize\noperations and thereby remove slow Python loops. Another means of vectorizing\noperations is to use NumPy\u2019s broadcasting functionality. Broadcasting is simply a\nset of rules for applying binary ufuncs (addition, subtraction, multiplication, etc.) on\narrays of different sizes.","fcb9155b":"## computation on arrays : broadcasting","bb78ab51":"#  this tutorial refers 'python data science handbook'","9b8f279a":"Another way to get at this\ninformation is to use np.sum; in this case, False is interpreted as 0, and True is interpreted\nas 1:","21639bfb":"It takes several seconds to compute these million operations and to store the result!\nWhen even cell phones have processing speeds measured in Giga-FLOPS (i.e., billions\nof numerical operations per second), this seems almost absurdly slow. It turns\nout that the bottleneck here is not the operations themselves, but the type-checking\nand function dispatches that CPython must do at each cycle of the loop. Each time\nthe reciprocal is computed, Python first examines the object\u2019s type and does a\ndynamic lookup of the correct function to use for that type. If we were working in\ncompiled code instead, this type specification would be known before the code executes\nand the result could be computed much more efficiently.","701e6c7a":"We saw that using +, -, *, \/,\nand others on arrays leads to element-wise operations. NumPy also implements comparison\noperators such as < (less than) and > (greater than) as element-wise ufuncs.\nThe result of these comparison operators is always an array with a Boolean data type.\nAll six of the standard comparison operations are available:","f488133a":"A Python Integer Is More Than Just an Integer\nThe standard Python implementation is written in C. This means that every Python\nobject is simply a cleverly disguised C structure, which contains not only its value, but\nother information as well. For example, when we define an integer in Python, such as\nx = 10000, x is not just a \u201craw\u201d integer. It\u2019s actually a pointer to a compound C structure,\nwhich contains several values. Looking through the Python 3.4 source code, we\nfind that the integer (long) type definition effectively looks like this (once the C macros\nare expanded):\n\nstruct _longobject {\nlong ob_refcnt;\nPyTypeObject *ob_type;\nsize_t ob_size;\nlong ob_digit[1];\n};\nA single integer in Python 3.4 actually contains four pieces:\n\u2022 ob_refcnt, a reference count that helps Python silently handle memory allocation\nand deallocation\n\u2022 ob_type, which encodes the type of the variable\n\u2022 ob_size, which specifies the size of the following data members\n\u2022 ob_digit, which contains the actual integer value that we expect the Python variable\nto represent\n","e8cde5a7":"When you use & and | on integers, the expression operates on the bits of the element,\napplying the and or the or to the individual bits making up the number:","e31879bb":"#  basics of numpy array","360c45d1":"Fancy indexing is conceptually simple: it means passing an array of indices to access\nmultiple array elements at once. For example, consider the following array:","45f65968":"Whenever possible, make sure that you are using the NumPy version of these aggregates\nwhen operating on NumPy arrays!","34bfe9d5":"It is also possible to do an element-by-element comparison of two arrays, and to\ninclude compound expressions:","cf23e2ec":"We can similarly extend this to arrays of higher dimension. Observe the result when\nwe add a one-dimensional array to a two-dimensional array:","622e2d1c":"### concatenation of arrays","788801e8":"# advanced ufuncs features","df28e679":"So remember this: and and or perform a single Boolean evaluation on an entire\nobject, while & and | perform multiple Boolean evaluations on the content (the individual\nbits or bytes) of an object. For Boolean NumPy arrays, the latter is nearly\nalways the desired operation.","b328baee":"This section\nwill present several examples using NumPy array manipulation to access data\nand subarrays, and to split, reshape, and join the arrays.","eb551002":"### multidimensional array slicing","23cb5a19":"# in built in array module for fixed type ,efficient data","985defe1":"And ufunc operations are not limited to one-dimensional arrays\u2014they can act on\nmultidimensional arrays as well:","fabf0f48":"## boolean array as masks","9b1e0e91":"One common point of confusion is the difference between the keywords and and or\non one hand, and the operators & and | on the other hand. When would you use one\nversus the other?\nThe difference is this: and and or gauge the truth or falsehood of entire object, while &\nand | refer to bits within each object.\nWhen you use and or or, it\u2019s equivalent to asking Python to treat the object as a single\nBoolean entity. In Python, all nonzero integers will evaluate as True. Thus:","e71cef52":"But this flexibility comes at a cost: to allow these flexible types, each item in the list\nmust contain its own type info, reference count, and other information\u2014that is, each\nitem is a complete Python object. In the special case that all variables are of the same\ntype, much of this information is redundant: it can be much more efficient to store\ndata in a fixed-type array. The difference between a dynamic-type list and a fixed-type\n(NumPy-style) array is illustrated in Figure 2-2.\nAt the implementation level, the array essentially contains a single pointer to one contiguous\nblock of data. The Python list, on the other hand, contains a pointer to a\nblock of pointers, each of which in turn points to a full Python object like the Python\ninteger we saw earlier. Again, the advantage of the list is flexibility: because each list\nelement is a full structure containing both data and type information, the list can be\nfilled with data of any desired type. Fixed-type NumPy-style arrays lack this flexibility,\nbut are much more efficient for storing and manipulating data.","eec0e116":"In the preceding section, we looked at aggregates computed directly on Boolean\narrays. A more powerful pattern is to use Boolean arrays as masks, to select particular\nsubsets of the data themselves. Returning to our x array from before, suppose we\nwant an array of all values in the array that are less than, say, 5:","9a512564":"For binary ufuncs, there are some interesting aggregates that can be computed\ndirectly from the object. For example, if we\u2019d like to reduce an array with a particular\noperation, we can use the reduce method of any ufunc. A reduce repeatedly applies a\ngiven operation to the elements of an array until only a single result remains.\n\n\nFor example, calling reduce on the add ufunc returns the sum of all elements in the\narray:","3cc6ee82":"### introducing broadcasting","df57893f":"# to create a array in numpy","a78a67aa":"### specifying output","17321330":"All of the preceding routines worked on single arrays. It\u2019s also possible to combine\nmultiple arrays into one, and to conversely split a single array into multiple arrays.\nWe\u2019ll take a look at those operations here.","29c7f995":"#  create a numpy array from scratch","c38507c0":"Ufuncs exist in two flavors: unary ufuncs, which operate on a single input, and binary\nufuncs, which operate on two inputs. We\u2019ll see examples of both these types of functions\nhere.","55601a99":"### minimum and maximum","3fbca3c7":"### summing values in array","f3f7372b":"Here the one-dimensional array a is stretched, or broadcast, across the second\ndimension in order to match the shape of M.","adac0558":"& np.bitwise_and\n\n| np.bitwise_or\n\n^ np.bitwise_xor\n\n~ np.bitwise_not","fe29e8bf":"### outer product","de06aa5c":"## array slicing,sub arrays","96a96000":"### array arithmetic","885c878f":"## computation on numpy arrays","11572068":"#  numpy standard data types","7104c30c":"## boolean operation","e904754d":"One common type of aggregation operation is an aggregate along a row or column.\nSay you have some data stored in a two-dimensional array:","d15114a3":"### other aggregate functions","88f34485":"# to check which version we are using\nnp.version.version","1b2dff3a":"In the previous sections, we saw how to access and modify portions of arrays using\nsimple indices (e.g., arr[0]), slices (e.g., arr[:5]), and Boolean masks (e.g., arr[arr> 0] )\n\nIn this section, we\u2019ll look at another style of array indexing, known as fancy\nindexing. Fancy indexing is like the simple indexing we\u2019ve already seen, but we pass\narrays of indices in place of single scalars. This allows us to very quickly access and\nmodify complicated subsets of an array\u2019s values.","a28ea52c":"NumPy provides many other aggregation functions, but we won\u2019t discuss them in\ndetail here. Additionally, most aggregates have a NaN-safe counterpart that computes\nthe result while ignoring missing values, which are marked by the special IEEE\nfloating-point NaN value\nSome of these NaN-safe functions were not added until\nNumPy 1.8, so they will not be available in older NumPy versions.","51675edb":"For large calculations, it is sometimes useful to be able to specify the array where the\nresult of the calculation will be stored. Rather than creating a temporary array, you\ncan use this to write computation results directly to the memory location where you\u2019d\nlike them to be. For all ufuncs, you can do this using the out argument of the\nfunction:","e8979695":"### aggregates","68486098":"### combined indexing"}}