{"cell_type":{"df7915a5":"code","0db7a1f9":"code","b43faf6e":"code","07487c5f":"code","fcc82a17":"code","b4763b8b":"code","8ae76355":"code","d0c5bf65":"code","4a2ba399":"code","35424f73":"code","244a43f4":"code","118f04ed":"code","e66ece49":"code","9157be38":"code","6a733a99":"code","10087755":"code","2967d52b":"code","d57b3796":"code","c7202ced":"code","b33d4a74":"code","bef6da36":"code","442fb43a":"code","046e0bc2":"code","613d10d7":"code","a815e2ff":"code","4e32f0c3":"code","58dffebd":"code","24f4bb4b":"code","a451f102":"code","8785a36d":"code","f5e5ca1c":"code","55afad69":"code","f8a3c396":"code","211dc3a9":"code","0b21cdc1":"code","38ed6cef":"code","bb8be7e7":"code","2dc47045":"code","2f8726d1":"code","e2bd2a37":"code","5881603d":"code","b1f23bd6":"code","1d8535a9":"code","e1a74d1d":"code","d813ed3f":"code","926d15f0":"code","6086339f":"code","b404f497":"code","054b25af":"code","6f9d7a12":"code","bee890bb":"code","1a332904":"code","828761c5":"code","cf67c11f":"code","bdffefb0":"code","6645ac4e":"code","29f85b1f":"code","c863ce54":"code","20d30f0f":"code","b70d50eb":"code","c4a996f1":"code","f4278857":"code","0a1b2e5e":"code","92fb7ffb":"code","58f2163c":"markdown","b5224500":"markdown","caf12087":"markdown","9fe482f0":"markdown","4266ab37":"markdown","93f8fa4a":"markdown","90472050":"markdown","0865b49a":"markdown","10912cd9":"markdown","8b406720":"markdown","45b4e11e":"markdown","083f53fa":"markdown","bdc8fd5e":"markdown","feba3410":"markdown","1e509691":"markdown","e8decad3":"markdown","2e9f1532":"markdown","ee3e3c2f":"markdown","c43bb231":"markdown","ffb5d9d6":"markdown","e2f5a1e0":"markdown","75e7aa76":"markdown","9565bb72":"markdown","a6c79d4d":"markdown","638f9a59":"markdown","b701918e":"markdown","261cb05b":"markdown","2c25c937":"markdown","78f1e771":"markdown","8df828b5":"markdown","d44cb03b":"markdown","0c764300":"markdown","6d7c8338":"markdown","62d99156":"markdown","b2e63dd4":"markdown","4d50239f":"markdown","27d4f5ab":"markdown","8d637474":"markdown"},"source":{"df7915a5":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.datasets import load_boston","0db7a1f9":"boston=load_boston()\ndata=pd.DataFrame(boston.data)","b43faf6e":"data.columns=boston.feature_names\ndata.head()","07487c5f":"data.columns=boston.feature_names\ndata.head()","fcc82a17":"#Adding target variable \ndata['Price']=boston.target\ndata.head()\n# Median value of owner-occupied homes in $1000s","b4763b8b":"sns.pairplot(data)\n","8ae76355":"data.isna().sum()\n","d0c5bf65":"data.nunique()\n","4a2ba399":"data.describe()\n","35424f73":"data['Price'].describe(percentiles=[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.95,1])\n","244a43f4":"# Generate and visualize the correlation matrix\ncorr = data.corr().round(2)\n\n# Mask for the upper triangle\nmask = np.zeros_like(corr, dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\n\n# Set figure size\nf, ax = plt.subplots(figsize=(20, 20))\n\n# Define custom colormap\ncmap = sns.diverging_palette(220, 10, as_cmap=True)\n\n# Draw the heatmap\nsns.heatmap(corr, mask=mask, cmap=cmap, vmin=-1, vmax=1, center=0,\n            square=True, linewidths=.5, cbar_kws={\"shrink\": .5}, annot=True)\n\nplt.tight_layout()","118f04ed":"plt.figure(figsize=(20,20))\nsns.heatmap(data.corr(), cmap='Blues', annot=True)\nplt.tight_layout()","e66ece49":"plt.figure(figsize=(10,10))\nsns.kdeplot(data.Price, shade=True, Label=\"Price\")\nplt.xlabel('Price')\nplt.ylabel('Probability Density')\nplt.show()","9157be38":"plt.figure(figsize=(10,10))\nsns.kdeplot(data['Price'], data['RM'], color='b', shade=True, Labels='Price', shade_lowest=False, cmap='Reds')\nplt.show()","6a733a99":"plt.figure(figsize=(10,10))\nsns.kdeplot(data['Price'], data['RM'], color='b', shade=True, Labels='Price', shade_lowest=False, cmap='Reds')\n\nsns.kdeplot(data['Price'], data['LSTAT'], color='b', shade=True, Labels='Price', shade_lowest=False, cmap='Greens')\nplt.show()","10087755":"data['Price'].plot(kind='box')\n","2967d52b":"Q1 = np.percentile(data['Price'], 25, interpolation = 'midpoint') \nQ2 = np.percentile(data['Price'], 50, interpolation = 'midpoint') \nQ3 = np.percentile(data['Price'], 75, interpolation = 'midpoint') \n  \nprint('Q1 25 percentile of the given data is, ', Q1)\nprint('Q1 50 percentile of the given data is, ', Q2)\nprint('Q1 75 percentile of the given data is, ', Q3)\n  \nIQR = Q3 - Q1 \nprint('Interquartile range is', IQR)","d57b3796":"low_lim = Q1 - 1.5 * IQR\nup_lim = Q3 + 1.5 * IQR\nprint('low_limit is', low_lim)\nprint('up_limit is', up_lim)","c7202ced":"outlier =[]\nfor x in data['Price']:\n    if ((x> up_lim) or (x<low_lim)):\n         outlier.append(x)\nprint(' outlier in the dataset is', outlier)","b33d4a74":"#Spliting the dataset\nX=data.drop(['Price'], axis=1)\ny=data['Price']","bef6da36":"from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test=train_test_split(X,y, test_size=0.3, random_state=7)","442fb43a":"from sklearn.linear_model import LinearRegression\nlm=LinearRegression()\n\nlm.fit(X_train, y_train)","046e0bc2":"coefficients=pd.DataFrame([X_train.columns, lm.coef_]).T\ncoefficients=coefficients.rename(columns={0:'Attributes',1:'Coefficients'})\ncoefficients","613d10d7":"y_pred=lm.predict(X_train)\n","a815e2ff":"from sklearn import metrics","4e32f0c3":"print(\"R^2\",metrics.r2_score(y_train, y_pred))\nprint(\"Adusted R^2\", 1-(1-metrics.r2_score(y_train, y_pred))*(len(y_train)-1)\/(len(y_train)-X_train.shape[1]-1))\nprint(\"MAE\", metrics.mean_absolute_error(y_train, y_pred))\nprint(\"MSE\", metrics.mean_squared_error(y_train, y_pred))\nprint(\"RMSE\",np.sqrt(metrics.mean_squared_error(y_train, y_pred)))","58dffebd":"metrics.max_error(y_train, y_pred)\n","24f4bb4b":"# metrics.mean_squared_log_error(y_train, y_pred)--can't use as target has negative value\nmetrics.mean_absolute_percentage_error(y_train, y_pred)\n# metrics.mean_poisson_deviance(y_train, y_pred)--can't use as target has negative value","a451f102":"\n# visualize the difference between the actual and predicted price \nplt.scatter(y_train, y_pred)\nplt.xlabel(\"Price\")\nplt.ylabel(\"Predicted Price\")\nplt.title(\"Predicted Vs Prices\")\nplt.show()","8785a36d":"# PLotting the residual Values\nplt.scatter(y_pred, y_train-y_pred)\nplt.xlabel(\"Prediced price\")\nplt.ylabel(\"Residual values\")\nplt.title(\"Residual Vs Predicted Prices\")\nplt.show()","f5e5ca1c":"# Checking for the Normality Errors\nsns.distplot(y_train-y_pred)\nplt.xlabel(\"Residual\")\nplt.ylabel(\"Frequency\")\nplt.title(\"Histogram of residula\")\nplt.show()","55afad69":"# Predicting the Test data with model \ny_test_pred=lm.predict(X_test)","f8a3c396":"lin_acc=metrics.r2_score(y_test, y_test_pred)\nprint(\"R^2\",lin_acc)\nprint(\"Adusted R^2\", 1-(1-metrics.r2_score(y_test, y_test_pred))*(len(y_test)-1)\/(len(y_test)-X_test.shape[1]-1))\nprint(\"MAE\", metrics.mean_absolute_error(y_test, y_test_pred))\nprint(\"MSE\", metrics.mean_squared_error(y_test, y_test_pred))\nprint(\"RMSE\",np.sqrt(metrics.mean_squared_error(y_test, y_test_pred)))","211dc3a9":"from sklearn.ensemble import RandomForestRegressor\n\nreg=RandomForestRegressor()\n\nreg.fit(X_train, y_train)","0b21cdc1":"y_pred=reg.predict(X_train)","38ed6cef":"# Model Evaluation for Random Forest\nprint(\"R^2\",metrics.r2_score(y_train, y_pred))\nprint(\"Adusted R^2\", 1-(1-metrics.r2_score(y_train, y_pred))*(len(y_train)-1)\/(len(y_train)-X_train.shape[1]-1))\nprint(\"MAE\", metrics.mean_absolute_error(y_train, y_pred))\nprint(\"MSE\", metrics.mean_squared_error(y_train, y_pred))\nprint(\"RMSE\",np.sqrt(metrics.mean_squared_error(y_train, y_pred)))","bb8be7e7":"# visualize the difference between the actual and predicted price \nplt.scatter(y_train, y_pred)\nplt.xlabel(\"Price\")\nplt.ylabel(\"Predicted Price\")\nplt.title(\"Predicted Vs Prices\")\nplt.show()","2dc47045":"# PLotting the residual Values\nplt.scatter(y_pred, y_train-y_pred)\nplt.xlabel(\"Prediced price\")\nplt.ylabel(\"Residual values\")\nplt.title(\"Residual Vs Predicted Prices\")\nplt.show()","2f8726d1":"# Checking for the Normality Errors\nsns.distplot(y_train-y_pred)\nplt.xlabel(\"Residual\")\nplt.ylabel(\"Frequency\")\nplt.title(\"Histogram of residula\")\nplt.show()","e2bd2a37":"\n# Predicting the Test data with model \ny_test_pred=reg.predict(X_test)","5881603d":"rf_acc=metrics.r2_score(y_test, y_test_pred)\nprint(\"R^2\",rf_acc)\nprint(\"Adusted R^2\", 1-(1-metrics.r2_score(y_test, y_test_pred))*(len(y_test)-1)\/(len(y_test)-X_test.shape[1]-1))\nprint(\"MAE\", metrics.mean_absolute_error(y_test, y_test_pred))\nprint(\"MSE\", metrics.mean_squared_error(y_test, y_test_pred))\nprint(\"RMSE\",np.sqrt(metrics.mean_squared_error(y_test, y_test_pred)))","b1f23bd6":"# visualize the difference between the actual and predicted price \nplt.scatter(y_test, y_test_pred)\nplt.xlabel(\"Price\")\nplt.ylabel(\"Predicted Price\")\nplt.title(\"Predicted Vs Prices\")\nplt.show()","1d8535a9":"# PLotting the residual Values\nplt.scatter(y_test_pred, y_test-y_test_pred)\nplt.xlabel(\"Prediced price\")\nplt.ylabel(\"Residual values\")\nplt.title(\"Residual Vs Predicted Prices\")\nplt.show()","e1a74d1d":"# Checking for the Normality Errors\nsns.distplot(y_test-y_test_pred)\nplt.xlabel(\"Residual\")\nplt.ylabel(\"Frequency\")\nplt.title(\"Histogram of residula\")\nplt.show()","d813ed3f":"from xgboost import XGBRegressor\n\nxreg=XGBRegressor()\n\nxreg.fit(X_train, y_train)","926d15f0":"y_pred=xreg.predict(X_train)\n","6086339f":"# Model Evaluation for Random Forest\nprint(\"R^2\",metrics.r2_score(y_train, y_pred))\nprint(\"Adusted R^2\", 1-(1-metrics.r2_score(y_train, y_pred))*(len(y_train)-1)\/(len(y_train)-X_train.shape[1]-1))\nprint(\"MAE\", metrics.mean_absolute_error(y_train, y_pred))\nprint(\"MSE\", metrics.mean_squared_error(y_train, y_pred))\nprint(\"RMSE\",np.sqrt(metrics.mean_squared_error(y_train, y_pred)))","b404f497":"# visualize the difference between the actual and predicted price \nplt.scatter(y_train, y_pred)\nplt.xlabel(\"Price\")\nplt.ylabel(\"Predicted Price\")\nplt.title(\"Predicted Vs Prices\")\nplt.show()","054b25af":"# PLotting the residual Values\nplt.scatter(y_pred, y_train-y_pred)\nplt.xlabel(\"Prediced price\")\nplt.ylabel(\"Residual values\")\nplt.title(\"Residual Vs Predicted Prices\")\nplt.show()","6f9d7a12":"# Checking for the Normality Errors\nsns.distplot(y_train-y_pred)\nplt.xlabel(\"Residual\")\nplt.ylabel(\"Frequency\")\nplt.title(\"Histogram of residula\")\nplt.show()","bee890bb":"# Predicting the Test data with model \ny_test_pred=xreg.predict(X_test)","1a332904":"xgb_acc=metrics.r2_score(y_test, y_test_pred)\nprint(\"R^2\",xgb_acc)\nprint(\"Adusted R^2\", 1-(1-metrics.r2_score(y_test, y_test_pred))*(len(y_test)-1)\/(len(y_test)-X_test.shape[1]-1))\nprint(\"MAE\", metrics.mean_absolute_error(y_test, y_test_pred))\nprint(\"MSE\", metrics.mean_squared_error(y_test, y_test_pred))\nprint(\"RMSE\",np.sqrt(metrics.mean_squared_error(y_test, y_test_pred)))","828761c5":"#Spliting the dataset\nXX=data.drop(['Price'], axis=1)\nyy=data['Price']","cf67c11f":"from sklearn.model_selection import train_test_split\nXX_train, XX_test, yy_train, yy_test=train_test_split(XX,yy, test_size=0.3, random_state=7)","bdffefb0":"from sklearn.preprocessing import StandardScaler\nsc=StandardScaler()\nXX_train=sc.fit_transform(XX_train)\nXX_test=sc.fit_transform(XX_test)","6645ac4e":"from sklearn import svm\n\nregg=svm.SVR()","29f85b1f":"regg.fit(XX_train,yy_train)","c863ce54":"y_pred=regg.predict(XX_train)","20d30f0f":"# Model Evaluation for Random Forest\nprint(\"R^2\",metrics.r2_score(yy_train, y_pred))\nprint(\"Adusted R^2\", 1-(1-metrics.r2_score(yy_train, y_pred))*(len(yy_train)-1)\/(len(yy_train)-XX_train.shape[1]-1))\nprint(\"MAE\", metrics.mean_absolute_error(yy_train, y_pred))\nprint(\"MSE\", metrics.mean_squared_error(yy_train, y_pred))\nprint(\"RMSE\",np.sqrt(metrics.mean_squared_error(yy_train, y_pred)))","b70d50eb":"# visualize the difference between the actual and predicted price \nplt.scatter(yy_train, y_pred)\nplt.xlabel(\"Price\")\nplt.ylabel(\"Predicted Price\")\nplt.title(\"Predicted Vs Prices\")\nplt.show()","c4a996f1":"# PLotting the residual Values\nplt.scatter(y_pred, yy_train-y_pred)\nplt.xlabel(\"Prediced price\")\nplt.ylabel(\"Residual values\")\nplt.title(\"Residual Vs Predicted Prices\")\nplt.show()","f4278857":"y_test_pred=regg.predict(XX_test)\n","0a1b2e5e":"svm_acc=metrics.r2_score(yy_test, y_test_pred)\nprint(\"R^2\",svm_acc)\nprint(\"Adusted R^2\", 1-(1-metrics.r2_score(yy_test, y_test_pred))*(len(yy_test)-1)\/(len(yy_test)-XX_test.shape[1]-1))\nprint(\"MAE\", metrics.mean_absolute_error(yy_test, y_test_pred))\nprint(\"MSE\", metrics.mean_squared_error(yy_test, y_test_pred))\nprint(\"RMSE\",np.sqrt(metrics.mean_squared_error(yy_test, y_test_pred)))","92fb7ffb":"models=pd.DataFrame({\n    'Model':['Linear Regression', 'Random Forest', 'XGBoost', 'Support Vector Machine'],\n    'R_squared Score':[lin_acc*100, rf_acc*100, xgb_acc*100, svm_acc*100]\n})\nmodels.sort_values(by='R_squared Score', ascending=False)","58f2163c":"# Model Evaluation","b5224500":"# Statistical table ","caf12087":"* bootstrap- Method of generating a new dataset form the orginal one (dim new < original dim) done by sampling with replacement. some of feature will be common to new datasets . it is called bootstrap samples\n* Entropy - Measure of randomness. Entropy can be defined as a measure of the purity of the sub split. Entropy always lies between 0 to 1.The algorithm calculates the entropy of each feature after every split and as the splitting continues on, it selects the best feature and starts splitting according to it\n* Gini Impurity- Gini impurity is also somewhat similar to the working of entropy. both are used for building the tree by splitting as per the appropriate features but there is quite a difference in the computation of both the methods. \n","9fe482f0":"# Evaluation Comparisoon of the all model","4266ab37":"# Finding null values","93f8fa4a":"To predict the house price using the boston house price dataset.\nI have used multiple regressor model in order to achieve the best accuracy result according to that we wil use that model whose performance is quite high and eassy implementation.\n* . Linear Regression\n*.  Random Forest\n*.  XGBoost \n*.  SVM\nThe visulaization has been done in order to get better about the feature,\nHere the description of the dataset\nThe Boston Housing Dataset\n\nThe Boston Housing Dataset is a derived from information collected by the U.S. Census Service concerning housing in the area of Boston MA. The following describes the dataset columns:\n\n* CRIM - per capita crime rate by town\n* ZN - proportion of residential land zoned for lots over 25,000 sq.ft.\n* INDUS - proportion of non-retail business acres per town.\n* CHAS - Charles River dummy variable (1 if tract bounds river; 0 otherwise)\n* NOX - nitric oxides concentration (parts per 10 million)\n* RM - average number of rooms per dwelling\n* AGE - proportion of owner-occupied units built prior to 1940\n* DIS - weighted distances to five Boston employment centres\n* RAD - index of accessibility to radial highways\n* TAX - full-value property-tax rate per $10,000\n* PTRATIO - pupil-teacher ratio by town\n\n* B - 1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town\n\n* LSTAT - % lower status of the population\n* MEDV - Median value of owner-occupied homes in $1000's","90472050":"# XGBoost Regressor","0865b49a":"* Counting of the outliers","10912cd9":"# Random Forest Regressor\n> As it is regression problem so we use regressor\n","8b406720":"# R-squared\n>R-squared = (TSS-RSS)\/TSS\n\n                = Explained variation\/ Total variation\n\n                = 1 \u2013 Unexplained variation\/ Total variation\n*A higher R-squared value indicates a higher amount of variability being explained by our model and vice-versa. If we had a really low RSS value, it would mean that the regression line was very close to the actual points. high RSS value, it would mean that the regression line was far away from the actual points. independent variables fail to explain the majority of variation in the target variable. Give us a really low R-squared value.","45b4e11e":"* The model evaluation of the test data is almost same as the model evealuation of the training data , As the difference is very less.\n* Now We can say that the model is not overfitting","083f53fa":"* No pattern is observed as datas are equally distributed around the zero","bdc8fd5e":"* Trying to visualize PRICE vs RM as both are correlated ","feba3410":"* The model is performing very good as train dataset . Hence again No overfitting","1e509691":"# Kde-Plot \n* Kernel Density Estimate is used for visualizing the Probability Density of a continuous variable.\n* depicts the probability density at different values in a continuous variable.\n* KDE Plot to visualize the PRICE of the dataset.\n* Maximum Desnsity of PRICE of house is distributed within 15 to 30","e8decad3":"# Model Prediction and Evaluation","2e9f1532":"# Unique value of each featured columns","ee3e3c2f":"# Heatmap\n*  graphical representation of data using colors to visualize the value of the matrix.\n* to represent more common values or higher activities brighter colors basically blues colors are used and to represent less common or activity values, light colors are preferred\n* Heatmap is also defined by the name of the shading matrix.\n","c43bb231":"# For test Data","ffb5d9d6":"* ZN: proportion of residential land zoned for lots over 25,000 sq.ft.\n* INDUS: proportion of non-retail business acres per town\n* CHAS: Charles River dummy variable (= 1 if tract bounds river; 0 otherwise)\n* NOX: nitric oxides concentration (parts per 10 million)\n>1https:\/\/archive.ics.uci.edu\/ml\/datasets\/Housing 123 20.2. Load the Dataset 124\n* \n* RM: average number of rooms per dwelling\n* AGE: proportion of owner-occupied units built prior to 1940\n* DIS: weighted distances to \ufb01ve Boston employment centers\n* RAD: index of accessibility to radial highways\n* TAX: full-value property-tax rate per $10,000\n* PTRATIO: pupil-teacher ratio by town 12.\n* B: 1000(Bk\u22120.63)2 where Bk is the proportion of blacks by town 13.\n* LSTAT: % lower status of the population\n* MEDV: Median value of owner-occupied homes in $1000s\n* We can see that the input attributes have a mixture of units.","e2f5a1e0":"# test Dataset","75e7aa76":"* Follow the Normality Assumption","9565bb72":"# Model Evaluation","a6c79d4d":"# Box-plot\n* It is used to visualize the outlier of price \n* Anything above and below the whiskers are called outliers","638f9a59":"# Correlation Matrix-Visualization\n* A correlation matrix is a table containing correlation coefficients between variables.\n* Each cell in the table represents the correlation between two variables.\n","b701918e":"# Model Evaluation","261cb05b":"* Errors are normally distributed . Hence Normality Assumption is satisfied","2c25c937":"# Problems with R-squared statistic\n* The R-squared statistic isn\u2019t perfect. In fact, it suffers from a major flaw. Its value never decreases no matter the number of variables we add to our regression model.\n* That is, even if we are adding redundant variables to the data, the value of R-squared does not decrease.\n* It either remains the same or increases with the addition of new independent variables.\n* This clearly does not make sense because some of the independent variables might not be useful in determining the target variable. \n# Adjusted R-squared statistic\n* The Adjusted R-squared takes into account the number of independent variables used for predicting the target variable.\n* In doing so, we can determine whether adding new variables to the model actually increases the model fit.\n* if R-squared does not increase significantly on the addition of a new independent variable, then the value of Adjusted R-squared will actually decrease.\n* On the other hand, if on adding the new independent variable we see a significant increase in R-squared value, then the Adjusted R-squared value will also increas","78f1e771":"# Variation of the Target columns","8df828b5":"# Visualization \n* Pairplot helps to know the relationship among the numerical features of dataset i.e. we get the correlation among the features","d44cb03b":"# For test Data- XGBoost","0c764300":"# Linear Regression","6d7c8338":"* The above plot is not quite useful as we re not getting any infference ","62d99156":"# Conclusion '\nAs we can se that \n* Least performing model is Linear Regression as form there we cam conclude that the dataset is not linear \n* Best performing model is XGBoost .XGBoost is an algorithm that has recently been dominating applied machine learning and Kaggle competitions for structured or tabular data.\n* XGBoost is an implementation of gradient boosted decision trees designed for speed and performance.\n* Random forest is a flexible, easy to use machine learning algorithm that produces, even without hyper-parameter tuning, a great result most of the time.\n* It is also one of the most used algorithms, because of its simplicity and diversity \n* One of the biggest advantages of random forest is its versatility. It can be used for both regression and classification tasks\n* it\u2019s also easy to view the relative importance it assigns to the input features.\n* Random forest is also a very handy algorithm because the default hyperparameters it uses often produce a good prediction result.\n\n","b2e63dd4":"# SVM Regressor","4d50239f":"# Test dataset ","27d4f5ab":"# Method of calculating the outliers\n* Q1- 25% percentile data\n* Q2- 50% percentile data\n* Q3- 75% percentile data\n* IQR- Inter qurtile range ","8d637474":"# Inference \nSince the 90% price is within $ 34*1000 . This is the distrinution of the price "}}