{"cell_type":{"f9fd8217":"code","b5d41089":"code","0ef73232":"code","60ad0109":"code","4fdd61b9":"code","10408d14":"code","696ffaf3":"code","1bb1314d":"code","76c01c06":"code","bd82a7de":"code","ca349c6e":"code","b1d790cf":"code","0c7e97f6":"code","8225ef21":"code","cfbba43c":"code","fdc787ad":"code","7ecab1c7":"code","8c6c647a":"code","50850250":"code","dacb2aa8":"code","d98faba3":"code","e986cbe6":"code","aa0971fd":"code","9b9fdc19":"code","c1fd114e":"code","d88c6c57":"code","5896a6ee":"code","0ecc6ad4":"code","d7695562":"code","7a650f5c":"code","edfcf146":"code","3cb5bca4":"code","61bbb21a":"code","c91e9e79":"code","88c2a42c":"code","ff02d2ee":"code","c83aa2e9":"code","4505a33f":"code","e66ef2f8":"code","4173ba40":"code","9ceee15f":"code","77afa363":"code","e1f60e29":"code","4c7c41c7":"code","03288474":"code","3007e5df":"code","2b456308":"markdown","ccea8ab8":"markdown","b5069636":"markdown","e5ad027a":"markdown","8e6662a0":"markdown","cb9be9ea":"markdown","39b4d6fe":"markdown"},"source":{"f9fd8217":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom scipy.stats import levene, f_oneway, kruskal\nfrom statsmodels.stats.multicomp import pairwise_tukeyhsd#, MultipleComparison\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","b5d41089":"import re\n\nhouse_prices_path = \"\/kaggle\/input\/house-prices-advanced-regression-techniques\/\"\nhouse_prices_trainset = os.path.join(house_prices_path, \"train.csv\")\nhouse_prices_description = os.path.join(house_prices_path, \"data_description.txt\")\ndescription_file = open(house_prices_description, 'r')\ndescription = description_file.read()\n\ndef what_is(term):\n    if term in description:\n        res = re.search(f\"{term}:.*?(\\\\n(?=\\w*:)|\\Z)\", description, re.DOTALL)\n        if res is not None:\n            print(res[0])\n            return\n    print(f\"Term {term} not found\")","0ef73232":"full_data = pd.read_csv(\"..\/input\/house-prices-advanced-regression-techniques\/train.csv\", index_col=\"Id\")\nfull_data.info()","60ad0109":"test_data = pd.read_csv(\"..\/input\/house-prices-advanced-regression-techniques\/test.csv\", index_col=\"Id\")\ntest_data.info()","4fdd61b9":"import missingno\n\ndef get_missing(df):\n    count = int(np.ceil(len(df.columns)\/28))\n    for i in range(0, count):\n        start = i*28\n        end = start + 27\n        missingno.matrix(df.iloc[:,start:end])\n\ndef find_null_info(df):\n    null_list = []\n    for c in df.columns:\n        no_null = df.isnull().sum()\n        if no_null[c] > 0:\n            null_list.append(c)\n            print(c, \"\\t\", no_null[c])\n#             what_is(c)\n    return null_list\n\ndef get_mean(df, feat, verbose=False):\n    types = df[feat].unique()\n    if verbose:\n        print(types)\n    means = {}\n    for t in types:\n        mean = df[df[feat]==t].SalePrice.mean()\n        means[t] = mean\n        if verbose:\n            print(\"%s:\\t%f\" %(t, mean))\n        \n    return means\n\ndef sort_dict(df):\n    scale_vars = []\n    all_args = []\n    features = df.columns\n    for cf in features:\n        scale_vars.append(cf)\n        if cf != 'SalePrice':\n            means = get_mean(df, cf)\n            t = {k:v for k, v in sorted(means.items(), key=lambda item: item[1])}\n            print(\"%s: %s\" %(cf, tuple([*t])))\n            all_args.append(tuple([*t]))\n    return scale_vars, all_args\n\ndef cat_to_scale(df, col_name, *args):\n    '''Need to be fed arguments in increasing order'''\n    s = pd.Series(pd.Categorical(df[col_name]))\n    if len(args) != len(s.cat.categories):\n        s = s.cat.add_categories(set(args) ^ set(s.cat.categories))\n    print(f\"Renaming {col_name}: \\t{[*args]} to: {list(i for i in range(len(args)))}\")\n    s = s.cat.rename_categories({arg : i for i, arg in enumerate(args)})\n    return s","10408d14":"log_price = np.log(full_data.SalePrice)\nfull_data['SalePrice'] = log_price\nsns.distplot(full_data['SalePrice'])","696ffaf3":"combined = pd.concat([full_data, test_data])\ncombined.info()","1bb1314d":"get_missing(combined)","76c01c06":"clean_data = combined.copy()\ncat_feat = clean_data.select_dtypes(include=['object'])\ncat_feat['SalePrice'] = clean_data['SalePrice']\ncat_feat.info()","bd82a7de":"train_clean = full_data.copy()\nmeans = get_mean(train_clean, 'LotShape')\nmeans","ca349c6e":"# scale_vars, all_args = sort_dict(cat_feat)","b1d790cf":"# for (var, args) in zip(scale_vars, all_args):\n#     renamed_col = cat_to_scale(clean_data, var, *args)\n#     clean_data[var] = renamed_col.values\n    \n# clean_data","0c7e97f6":"clean_data.info()","8225ef21":"# for c in clean_data.columns:\n#     if str(clean_data[c].dtypes) == 'category':\n#         clean_data[c] = clean_data[c].astype(int)\n\n# clean_data.info()","cfbba43c":"train_clean = clean_data[clean_data['SalePrice'].notnull()]\ntrain_clean.info()","fdc787ad":"house_style = \"HouseStyle\"\nhouse_styles = train_clean[house_style].unique()\nhouse_styles","7ecab1c7":"what_is(house_style)","8c6c647a":"sns.boxplot(x=house_style, y=\"SalePrice\", palette=\"GnBu_d\", data=train_clean)","50850250":"def unequal_var(df, feature, features):\n    num_cols = 3\n    num_feats = int(np.ceil(len(features)\/num_cols))\n    fig, ax = plt.subplots(num_feats, num_cols, figsize=(num_cols*10,num_feats*7))\n\n    i = 0\n    j = 0\n    feat_arr = []\n    for f in features:\n        if j==num_cols:\n            j = 0\n            i += 1\n        price = df[df[feature]==f].SalePrice\n        feat_arr.append(np.array(price))\n        sns.distplot(price, ax=ax[i][j])\n        plt.setp(ax[i][j], ylabel=f)\n        j += 1\n    \n    feat_tup = tuple(feat_arr)\n    stat, p = levene(*feat_tup)\n    print(\"Stat: %f; p-value: %.2e; Unequal variance: %s\" %(stat, p, ('Yes' if p < 0.05 else 'No')))\n    plt.legend()\n    plt.show()\n    \nunequal_var(train_clean, house_style, house_styles)","dacb2aa8":"price = train_clean[train_clean[house_style]==5].SalePrice\nsns.distplot(price)","d98faba3":"copy_data = train_clean.copy()\n# log_price = np.log(copy_data.SalePrice)\n# copy_data['SalePrice'] = log_price\nsns.distplot(copy_data['SalePrice'])","e986cbe6":"house_style = \"HouseStyle\"\nhouse_styles = train_clean[house_style].unique()\nunequal_var(copy_data, house_style, house_styles)","aa0971fd":"eq_var = []\n\ndef uv(df, feature, features):\n    eq_var = []\n    feat_arr = []\n    for f in features:\n        price = df[df[feature]==f].SalePrice\n        feat_arr.append(np.array(price))\n    \n    feat_tup = tuple(feat_arr)\n    stat, p = levene(*feat_tup)\n    print(\"%s p-value: %.2e; Unequal variance: %s\" %(feature, p, ('Yes' if p < 0.05 else 'No')))\n    \n    if p > 0.05:\n        eq_var.append(feature)\n        return (True, feature)\n    else:\n        return (False, feature)\n\neq_vars = []\nuneq_vars = []\nfor cf in copy_data.columns:\n    feats = copy_data[cf].unique()\n    v, f = uv(copy_data, cf, feats)\n    if v:\n        eq_vars.append(f)\n    else:\n        uneq_vars.append(f)\n    \nprint(eq_vars)","9b9fdc19":"feat = \"MSZoning\"\nfeats = copy_data[feat].unique()\nunequal_var(copy_data, feat, feats)","c1fd114e":"feat = \"SaleCondition\"\nfeats = copy_data[feat].unique()\nunequal_var(copy_data, feat, feats)","d88c6c57":"what_is(\"MSSubClass\")","5896a6ee":"feat = \"MSSubClass\"\nfeats = copy_data[feat].unique()\nunequal_var(copy_data, feat, feats)","0ecc6ad4":"what_is(\"YrSold\")","d7695562":"feat = \"YrSold\"\nfeats = copy_data[feat].unique()\nunequal_var(copy_data, feat, feats)","7a650f5c":"def mult_comp(df, feature, features):\n    feat_arr = []\n    for f in features:\n        price = df[df[feature]==f].SalePrice\n        feat_arr.append(np.array(price))\n    \n    feat_tup = tuple(feat_arr)\n    stat, p = f_oneway(*feat_tup)\n    print(\"%s p-value: %.2e; Unequal mean: %s\" %(feature, p, ('Yes' if p < 0.05 else 'No')))\n    \n    if p < 0.05:\n        return feature\n    else:\n        return None\n\ngood_feats = []\nfor nv in eq_vars:\n    feats = copy_data[nv].unique()\n    v = mult_comp(copy_data, nv, feats)\n    if v != None:\n        good_feats.append(v)\n    \nprint(good_feats)","edfcf146":"sns.boxplot(data=copy_data, x='Street', y='SalePrice')","3cb5bca4":"sns.boxplot(data=copy_data, x='YrSold', y='SalePrice')","61bbb21a":"sns.boxplot(data=copy_data, x='Heating', y='SalePrice')","c91e9e79":"what_is(\"SaleCondition\")","88c2a42c":"good_feats","ff02d2ee":"pairwise = []\nfor gf in good_feats:\n    if len(copy_data[gf].unique()) < 50:\n        pairwise.append(gf)\n#         print(\"%s: %d\" %(gf, len(copy_data[gf].unique())))\n        \npairwise","c83aa2e9":"sns.scatterplot(data=copy_data, x=\"LotArea\", y=\"SalePrice\")","4505a33f":"for cv in pairwise:\n    print(\"%s: \" %(cv))\n    print(pairwise_tukeyhsd(copy_data.SalePrice, copy_data[cv]))","e66ef2f8":"sns.boxplot(x=\"Condition2\", y=\"SalePrice\", palette=\"GnBu_d\", data=full_data)","4173ba40":"get_mean(copy_data, \"SaleCondition\")","9ceee15f":"feat = \"SaleCondition\"\nfeats = copy_data[feat].unique()\nunequal_var(copy_data, feat, feats)","77afa363":"print(good_feats)","e1f60e29":"def kw_test(df, feature, features):\n    feat_arr = []\n    for f in features:\n        price = df[df[feature]==f].SalePrice\n        feat_arr.append(np.array(price))\n    \n    feat_tup = tuple(feat_arr)\n    stat, p = kruskal(*feat_tup)\n    print(\"%s p-value: %.2e; Unequal mean: %s\" %(feature, p, ('Yes' if p < 0.05 else 'No')))\n    \n    if p < 0.05:\n        return feature\n    else:\n        return None","4c7c41c7":"good_feats1 = []\nfor nv in uneq_vars:\n    feats = copy_data[nv].unique()\n    v = kw_test(copy_data, nv, feats)\n    if v != None:\n        good_feats1.append(v)\n    \nprint(good_feats1)","03288474":"feat = \"FireplaceQu\"\nfeats = copy_data[feat].unique()\nunequal_var(copy_data, feat, feats)","3007e5df":"test_clean = clean_data[clean_data['SalePrice']==0]\ntest_clean.info()","2b456308":"# Levene test for Unequal Variance\n\nAlso known as the Brown Forsythe test for unequal variance.\n\nTo start, let's look at the feature called 'HouseStyle' and how the sale price is affected by each different style:","ccea8ab8":"# Tukey's Multiple Comparison","b5069636":"Here, the box plots visualize where the average sale prices are:","e5ad027a":"# Kruskal-Wallis test\n\nFor samples with unequal variance, we use the Kruskal-Wallis test to test for unequal means.","8e6662a0":"This function uses the Levene test for unequal variance and creates distribution plots for each category in the feature:","cb9be9ea":"# Test Data Predictions","39b4d6fe":"# Preprocessing"}}