{"cell_type":{"bf4814a7":"code","961fc193":"code","39290994":"code","f69c4369":"code","52b95a12":"code","a30747f2":"code","0d3467bc":"code","7db27bde":"code","6fb202b5":"code","da71568d":"code","d44a8152":"code","995811f4":"code","45ba0aeb":"code","602ca383":"code","74417511":"code","4d55ccf7":"code","eff8ac60":"code","bd933942":"code","a356881b":"code","fcd482b3":"code","492570e9":"code","379b8ac1":"code","6c471ba9":"code","f1faf4d7":"code","c53ce2c5":"markdown","10cb025d":"markdown","a5da759f":"markdown","8bce97b9":"markdown","9345057e":"markdown","f0cf2154":"markdown","963c413a":"markdown","bbed6a54":"markdown"},"source":{"bf4814a7":"!pip install -U autowoe","961fc193":"%matplotlib inline\n\nimport pandas as pd\nimport numpy as np\n\nfrom sklearn.metrics import accuracy_score, f1_score\nfrom sklearn.model_selection import train_test_split, StratifiedKFold\nfrom matplotlib import pyplot as plt\n\nfrom autowoe import AutoWoE, ReportDeco","39290994":"INPUT_PATH = '..\/input\/tabular-playground-series-apr-2021\/'\ntrain_data = pd.read_csv(INPUT_PATH + 'train.csv')\ntrain_data","f69c4369":"test_data = pd.read_csv(INPUT_PATH + 'test.csv')\ntest_data","52b95a12":"submission = pd.read_csv(INPUT_PATH + 'sample_submission.csv')\nsubmission","a30747f2":"print('TRAIN TARGET MEAN = {:.3f}'.format(train_data['Survived'].mean()))","0d3467bc":"import joblib\noofs, test_preds = joblib.load('..\/input\/catboost-run-pseudolabel-to-recieve-oof\/predictions_newcb_as_pseudo.pkl')\ntrain_data['preds'] = oofs\ntest_data['preds'] = test_preds","7db27bde":"train_data","6fb202b5":"test_data","da71568d":"def create_extra_features_1(data_0):\n    data = data_0.copy()\n    data.Cabin = data.Cabin.map(lambda x: str(x)[0].strip())\n    \n    data['Ticket1'] = data.Ticket.map(lambda x:str(x).split()[0] if len(str(x).split()) > 1 else np.nan)\n    data['Ticket2'] = data.Ticket.str.replace('\\.','', regex=True).\\\n                    str.replace('(\\d+)', '', regex=True).\\\n                    str.replace(' ', '', regex=True).\\\n                    replace(r'^\\s*$', 'X', regex=True)\n    \n    data['FamilySize'] = data['SibSp'] + data['Parch'] + 1\n    \n    data['FirstName'] = data.Name.map(lambda x: str(x).split(',')[0])\n    data['Surname'] = data.Name.map(lambda x: str(x).split(',')[1])\n    \n    for col in ['Name', 'FirstName', 'Surname']:\n        data['Counter_' + col] = data[col].map(data.groupby(col)['PassengerId'].count().to_dict())\n        \n    data.drop(columns = ['Name', 'Surname', 'Ticket'], inplace = True)\n    \n    for pair in [('Ticket1', 'Cabin'), ('Ticket2', 'Cabin'), \n                 ('Cabin', 'Parch'), ('Ticket1', 'Parch'), ('Ticket2', 'Parch'),\n                 ('Cabin', 'Embarked'), ('Ticket1', 'Embarked'), ('Ticket2', 'Embarked'), ('Embarked', 'Parch')\n                ]:\n        data[pair[0] + '_' + pair[1]] = data[pair[0]].astype(str) + '_' + data[pair[1]].astype(str)\n        \n    return data\n\ndef create_extra_features_2(data_0):\n    data = data_0.copy()\n    data.Cabin = data.Cabin.map(lambda x: str(x)[0].strip())\n    data.Ticket = data.Ticket.map(lambda x:str(x).split()[0] if len(str(x).split()) > 1 else np.nan)\n    \n    data['FamilySize'] = data['SibSp'] + data['Parch'] + 1\n    \n    data['FirstName'] = data.Name.map(lambda x: str(x).split(',')[0])\n    data['Surname'] = data.Name.map(lambda x: str(x).split(',')[1])\n    \n    for col in ['Name', 'FirstName', 'Surname']:\n        data['Counter_' + col] = data[col].map(data.groupby(col)['PassengerId'].count().to_dict())\n        \n    data.drop(columns = ['Name', 'Surname'], inplace = True)\n    \n    return data\n\n\nall_df = pd.concat([train_data, test_data]).reset_index(drop = True)\nprint(all_df.shape)","d44a8152":"TARGET = 'Survived'\n\ndef get_model():\n    return AutoWoE(monotonic=False,\n                     vif_th=20.,\n                     imp_th=0,\n                     th_const=32,\n                     force_single_split=True,\n                     min_bin_size = 0.01,\n                     oof_woe=True,\n                     n_folds=10,\n                     n_jobs=4,\n                     regularized_refit=True,\n                     verbose=2\n            )\n\ndef fit_autowoe(data, model_name):\n    auto_woe = get_model()\n    auto_woe.fit(data.drop('PassengerId', axis = 1), target_name=TARGET)\n    train_pred = auto_woe.predict_proba(data)\n    print('\\t{}: ACCURACY ON TRAIN = {:.5f}'.format(model_name, accuracy_score(data[TARGET], (train_pred > 0.5).astype(int))))\n    return auto_woe\n\ndef cv_autowoe(data, \n               test_data, \n               n_folds = 5, \n               sex = 'Unknown'):\n    \n    print('=' * 50)\n    print('Start model for sex = {}'.format(sex))\n    \n    oof_pred = np.array([0.0] * len(data))\n    test_pred = np.array([0.0] * len(test_data))\n    \n    skf = StratifiedKFold(n_splits = n_folds, shuffle = True, random_state = 13)\n    models = []\n    for fold, (train_index, test_index) in enumerate(skf.split(data[TARGET], data[TARGET])):\n        print('\\tStart model sex = {}, fold = {}'.format(sex, fold))\n        train_data = data.iloc[train_index, :]\n        valid_data = data.iloc[test_index, :]\n        \n        model_name = 'Model_{}_{}'.format(sex, fold)\n        model = fit_autowoe(train_data, model_name)\n        models.append(model)\n        \n        val_pred = model.predict_proba(valid_data)\n        oof_pred[test_index] = val_pred\n        print('\\t{}: ACCURACY ON VALID = {:.5f}'.format(model_name, accuracy_score(valid_data[TARGET], (val_pred > 0.5).astype(int))))\n        \n        test_pred += model.predict_proba(test_data) \/ n_folds\n        print('\\t' + '*' * 50)\n        \n    print('ACCURACY ON OOF = {:.5f}'.format(accuracy_score(data[TARGET], (oof_pred > 0.5).astype(int))))\n        \n    return models, oof_pred, test_pred\n\ndef build_model_split_by_sex(train_data, test_data, n_folds):\n    male_models, male_oof_pred, male_test_pred = cv_autowoe(train_data[train_data['Sex'] == 'male'], test_data, n_folds, 'male')\n    print('=' * 50 + '\\n' + '=' * 50)\n    female_models, female_oof_pred, female_test_pred = cv_autowoe(train_data[train_data['Sex'] == 'female'], test_data, n_folds, 'female')\n    \n    oof_preds = np.array([0.0] * len(train_data))\n    oof_preds[train_data['Sex'] == 'male'] = male_oof_pred\n    oof_preds[train_data['Sex'] == 'female'] = female_oof_pred\n    \n    test_preds = np.where(test_data['Sex'] == 'male', male_test_pred, female_test_pred)\n    return oof_preds, test_preds","995811f4":"all_df.head()","45ba0aeb":"%%time\n\ngen_feats = create_extra_features_1(all_df)\ntrain_data, test_data = gen_feats[:len(train_data)], gen_feats[len(train_data):]\nprint(train_data.shape, test_data.shape)\noof_preds_1, test_preds_1 = build_model_split_by_sex(train_data, test_data, 10)","602ca383":"print('ACCURACY = {:.5f}'.format(accuracy_score(train_data[TARGET], (oof_preds_1 > 0.5).astype(int))))","74417511":"# pos_data = np.where(train_data[TARGET] == 1)[0]\n# neg_data = np.where(train_data[TARGET] == 0)[0]\n# full_target = train_data[TARGET].values\n\n# N = 25000\n# res = []\n# for _ in range(100): \n#     pos_part = int(np.round(0.34911 * N))\n#     neg_part = N - pos_part\n\n#     pos_rnd_idx = np.random.randint(0, len(pos_data), pos_part)\n#     neg_rnd_idx = np.random.randint(0, len(neg_data), neg_part)\n\n#     target = np.array(list(full_target[pos_rnd_idx]) + list(full_target[neg_rnd_idx]))\n#     preds = np.array(list(oof_preds_1[pos_rnd_idx]) + list(oof_preds_1[neg_rnd_idx]))\n#     bound = pd.Series(preds).sort_values(ascending = False).head(pos_part).values[-1]\n#     preds = (preds > bound).astype(int)\n#     res.append(accuracy_score(target, preds))\n    \n# print(np.array(res))\n# print(np.mean(res))","4d55ccf7":"%%time\n\ngen_feats = create_extra_features_2(all_df)\ntrain_data, test_data = gen_feats[:len(train_data)], gen_feats[len(train_data):]\nprint(train_data.shape, test_data.shape)\noof_preds_2, test_preds_2 = build_model_split_by_sex(train_data, test_data, 10)","eff8ac60":"print('ACCURACY = {:.5f}'.format(accuracy_score(train_data[TARGET], (oof_preds_2 > 0.5).astype(int))))","bd933942":"best_score = -1\nbest_w = None\nfor w in np.arange(0, 1.01, 0.01):\n    comb_pred = w * oof_preds_1 + (1 - w) * oof_preds_2\n    score = accuracy_score(train_data[TARGET], (comb_pred > 0.5).astype(int))\n    \n    if score > best_score:\n        best_score = score\n        best_w = w\n    \n    print('{:.2f} ACCURACY = {:.5f}'.format(w, score))","a356881b":"print('BEST W = {:.2f}, BEST ACCURACY = {:.5f}'.format(best_w, best_score))","fcd482b3":"preds = best_w * test_preds_1 + (1 - best_w) * test_preds_2","492570e9":"bound = pd.Series(preds).sort_values(ascending = False).head(34911).values[-1]\nbound","379b8ac1":"submission['Survived'] = (preds > bound).astype(int)\nsubmission.to_csv('AutoWoE_submission_combo.csv', index = False)","6c471ba9":"submission['Survived'].mean()","f1faf4d7":"import joblib\njoblib.dump((oof_preds_1, test_preds_1, oof_preds_2, test_preds_2), 'both_preproc_preds.pkl')","c53ce2c5":"# Load OOFs and Test predictions","10cb025d":"# Appendix","a5da759f":"# Imports ","8bce97b9":"# Train 2 separate models for Sex on full train and pseudolabelled test","9345057e":"# Extra features functions creation","f0cf2154":"# Create submissions","963c413a":"# Data loading","bbed6a54":"#### Please upvote if you find the notebook interesting\/useful :)\n\n## We can see:\n- from version 4 - we can recieve **0.81420** without pseudolabelling\n- from version 6 - **0.81549** if we add OOF and test preds from [catboost model](https:\/\/www.kaggle.com\/gomes555\/tps-apr2021-catboost-run-pseudo-label)\n\nLet's modify the version 6 using our best submit with score 0.81581 as a pseudo for Catboost.\n\n#### Please upvote Fellipe's kernel for his great work as well - really appreciate it!\n\n# Install [AutoWoe](https:\/\/github.com\/sberbank-ai-lab\/AutoMLWhitebox) library\n\nThis library is a part of [LightAutoML](https:\/\/github.com\/sberbank-ai-lab\/LightAutoML) framework and is used in Whitebox preset, but here we will show how to use it separately"}}