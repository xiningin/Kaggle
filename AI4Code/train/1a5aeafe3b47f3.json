{"cell_type":{"9742a446":"code","2c85a035":"code","b96e039a":"code","15b1e924":"code","9f9f6095":"code","f210d9e1":"code","9d378df4":"code","4fbebcc2":"code","9eb663bb":"code","f6df780b":"code","8cf74daa":"code","25a1c7d2":"code","94c623ac":"code","4b7d2f4b":"code","8d43d13c":"code","71f4485e":"code","282170d0":"code","b46ccde1":"code","a2d1eeb5":"code","7a85173d":"code","24d6e9ae":"code","349034a0":"code","4bde5108":"code","ad673db6":"code","294d79a2":"code","c2a63b79":"code","c54e6ceb":"code","02d469ae":"code","5edcad09":"code","c4280110":"code","101993bd":"code","81b1312f":"code","47639a29":"markdown","3a3a375c":"markdown","e1fe325c":"markdown","6436db5c":"markdown","bd6169aa":"markdown","ce8923e6":"markdown","745c3b7a":"markdown","bb0b68fb":"markdown","d5c99d63":"markdown","06b2cc1a":"markdown","3bbab152":"markdown","42b594ba":"markdown","c77135cc":"markdown","7583e51f":"markdown","2b26583e":"markdown","dc94b11c":"markdown","dbf931fd":"markdown"},"source":{"9742a446":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import linear_kernel\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","2c85a035":"df = pd.read_csv('..\/input\/goodreads-best-books-ever-with-recommendations\/Goodreads_BestBooksEver_1-10000.csv')","b96e039a":"df.head()","15b1e924":"df.drop_duplicates(subset = ['bookTitle'], keep = 'first', inplace = True, ignore_index = True) #Delete all duplicates based on book title, keeping the first instance only","9f9f6095":"df.dropna(subset = ['bookTitle', 'bookAuthors', 'bookGenres', 'bookDesc','recommendations'], inplace = True) #drop all the NaN values in columns that we use later","f210d9e1":"df.reset_index(inplace = True)","9d378df4":"def split_genre(genres):\n    return genres.split(\"|\")[0].split(\"\/\")[0]\n\ndf['cleaned_bookGenres'] = df[\"bookGenres\"].apply(split_genre)","4fbebcc2":"import ast\ndef split_recommendations(recommendations):\n    recommendations = ast.literal_eval(recommendations)\n    l = []\n    for recommendation in recommendations:\n        l.append(recommendation.split(\"|\")[0])\n    return l\n\ndf['cleaned_recommendations'] = df[\"recommendations\"].apply(split_recommendations)","9eb663bb":"tf = TfidfVectorizer(analyzer='word',ngram_range=(1, 2),min_df=0, stop_words='english')\ntfidf_matrix = tf.fit_transform(df['bookAuthors'])\ncosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)","f6df780b":"titles = df['bookTitle']\nindices = pd.Series(df.index, index=df['bookTitle'])\n\n# Function that get book recommendations based on the cosine similarity score of book authors\ndef authors_recommendations(title):\n    idx = indices[title]\n    sim_scores = list(enumerate(cosine_sim[idx]))\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n    sim_scores = sim_scores[1:20]\n    book_indices = [i[0] for i in sim_scores]\n    return titles.iloc[book_indices]","8cf74daa":"list(authors_recommendations('Pride and Prejudice').head(18)) #first 18 most similar books based on our engine","25a1c7d2":"list(df[df['bookTitle'] == 'Pride and Prejudice']['cleaned_recommendations'])[0] #18 books recommended by Goodreads","94c623ac":"set(list(authors_recommendations('The Hunger Games').head(18))).intersection(list(df[df['bookTitle'] == 'The Hunger Games']['cleaned_recommendations'])[0])","4b7d2f4b":"authors_comparison = [len(set(list(authors_recommendations(df.bookTitle[i]).head(18))).intersection(list(df[df['bookTitle'] == df.bookTitle[i]]['cleaned_recommendations'])[0]))\/18 for i in range(len(df))]","8d43d13c":"from scipy import stats\nstats.describe(authors_comparison)","71f4485e":"sns.set_context('notebook')\nax = sns.displot(authors_comparison, color = 'seagreen')\nax.fig.set_figwidth(15)\nax.fig.set_figheight(10)\nplt.title('Author based Recommender Performance', size = 20)","282170d0":"tf = TfidfVectorizer(analyzer='word',ngram_range=(1, 2),min_df=0, stop_words='english')\ntfidf_matrix = tf.fit_transform(df['cleaned_bookGenres'])\ncosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)","b46ccde1":"titles = df['bookTitle']\nindices = pd.Series(df.index, index=df['bookTitle'])\n\n# Function that get book recommendations based on the cosine similarity score of book authors\ndef genre_recommendations(title):\n    idx = indices[title]\n    sim_scores = list(enumerate(cosine_sim[idx]))\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n    sim_scores = sim_scores[1:20]\n    book_indices = [i[0] for i in sim_scores]\n    return titles.iloc[book_indices]","a2d1eeb5":"genre_recommendations('The Hunger Games').head(18)","7a85173d":"genre_comparison = [len(set(list(genre_recommendations(df.bookTitle[i]).head(18))).intersection(list(df[df['bookTitle'] == df.bookTitle[i]]['cleaned_recommendations'])[0]))\/18 for i in range(len(df))]","24d6e9ae":"stats.describe(genre_comparison)","349034a0":"sns.set_context('notebook')\nax = sns.displot(genre_comparison, color = 'seagreen')\nax.fig.set_figwidth(15)\nax.fig.set_figheight(10)\nplt.title('Genre based Recommender Performance', size = 20)","4bde5108":"tf = TfidfVectorizer(analyzer='word',ngram_range=(1, 2),min_df=0, stop_words='english')\ntfidf_matrix = tf.fit_transform(df['bookDesc'])\ncosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)","ad673db6":"titles = df['bookTitle']\nindices = pd.Series(df.index, index=df['bookTitle'])\n\n# Function that get book recommendations based on the cosine similarity score of book authors\ndef desc_recommendations(title):\n    idx = indices[title]\n    sim_scores = list(enumerate(cosine_sim[idx]))\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n    sim_scores = sim_scores[1:20]\n    book_indices = [i[0] for i in sim_scores]\n    return titles.iloc[book_indices]","294d79a2":"desc_comparison = [len(set(list(desc_recommendations(df.bookTitle[i]).head(18))).intersection(list(df[df['bookTitle'] == df.bookTitle[i]]['cleaned_recommendations'])[0]))\/18 for i in range(len(df))]","c2a63b79":"stats.describe(desc_comparison)","c54e6ceb":"sns.set_context('notebook')\nax = sns.displot(desc_comparison, color = 'seagreen')\nax.fig.set_figwidth(15)\nax.fig.set_figheight(10)\nplt.title('Description based Recommender Performance', size = 20)","02d469ae":"df['corpus'] = pd.Series(df[['bookAuthors', 'cleaned_bookGenres', 'bookDesc']].fillna('').values.tolist()).str.join(' ')","5edcad09":"tf = TfidfVectorizer(analyzer='word',ngram_range=(1, 2),min_df=0, stop_words='english')\ntfidf_matrix = tf.fit_transform(df['corpus'])\ncosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)\ntitles = df['bookTitle']\nindices = pd.Series(df.index, index=df['bookTitle'])\n\n# Function that get book recommendations based on the cosine similarity score of book authors\ndef final_recommendations(title):\n    idx = indices[title]\n    sim_scores = list(enumerate(cosine_sim[idx]))\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n    sim_scores = sim_scores[1:20]\n    book_indices = [i[0] for i in sim_scores]\n    return titles.iloc[book_indices]","c4280110":"final_comparison = [len(set(list(final_recommendations(df.bookTitle[i]).head(18))).intersection(list(df[df['bookTitle'] == df.bookTitle[i]]['cleaned_recommendations'])[0]))\/18 for i in range(len(df))]\nstats.describe(final_comparison)","101993bd":"sns.set_context('notebook')\nax = sns.displot(data = final_comparison, color = 'seagreen')\nax.fig.set_figwidth(15)\nax.fig.set_figheight(10)\nplt.title('Authors + Genre + Description based Recommender Performance', size = 20)","81b1312f":"sns.set_context('notebook')\n\nsns.kdeplot(authors_comparison)\nsns.kdeplot(genre_comparison)\nsns.kdeplot(desc_comparison)\nsns.kdeplot(final_comparison)\nplt.legend(labels=['author-based', 'genre-based', 'description-based','all'])\n#ax.fig.set_figwidth(15)\n#ax.fig.set_figheight(10)","47639a29":"# Recommendation based on Description","3a3a375c":"# Data Cleaning","e1fe325c":"# Recommendation based on Genre","6436db5c":"There's no shared book between the two lists. Quite a bummer! Let's do this for all books and look at the stats. We will count how many books are the same between the two recommenders for each title. Note that we will normalize the result so that a score of 1 would mean 18\/18 books in common for example. ","bd6169aa":"# Recommendation based on Author name","ce8923e6":"The recommendation by Goodreads includes of 18 books for each title. Next up we will create recommendation engines that also recommend the 18 most similar books to each title on the list. ","745c3b7a":"# Recommendation based on Authors, Genres, and Description","bb0b68fb":"Best looking (subjectively) distribution plot so far with clear bins but a lower mean than the genre-based engine and only maxes out at 7\/18 books.","d5c99d63":"First let's try a (real) simple recommendation engine based on Author Name(s). Using this engine, we would expect to get recommended books from the same author when we look at a particular book.","06b2cc1a":"Next we will clean the **bookGenres** column so that it will show only the most voted genre. This is based on the fact that many books have genres that are only voted by a few people that it should be deemed insignificant. Moreover, many books only have one genre attached to it so to make life easy we will just take the first (and\/or most voted) genre that appears in the list.","3bbab152":"# Comparison between the engines","42b594ba":"This engines maxes out at 10\/18 books but has a much better mean than the author-based engine. Looking at the distribution plot, we can also see more clearly the bins between the min and the max values. ","c77135cc":"A quick look reveals that the best result is 15 out of 18 books, but most of the time there's little to no similarity between our engine and the Goodreads' recommendation.","7583e51f":"Comparing the 2 lists:","2b26583e":"For an example, let's look at one of the books on the list \"The Hunger Games\"","dc94b11c":"Similarly we will clean the **recommendations** column, but we will just remove the URL and keep the book titles for later reference ","dbf931fd":"It is hard to decide which one of these 4 engines perform the best. Based on the mean alone, the genre-based engine produces the best results. It is also the engine with the fewest 0\/18 results. By contrast the author-based performs the worst with the most 0\/18 results, as can be seen clearly on the plot above.\n\nWhat we learn and know for sure after this is that Goodreads may not exactly use the kind of simple (or naive) recommendation system that we have here. There could be more sophisticated engine that they use or they could simply base their recommendations on users' history (i.e. if most people who like book A also like book B), or a combination of both. "}}