{"cell_type":{"ffee8c6a":"code","c61475ad":"code","728ca4d2":"code","2337fc55":"code","e88cb6b2":"code","a576389d":"code","ce229abf":"code","b24fa9c0":"code","43fcdd7b":"code","bcf49a40":"code","82c9415b":"code","01a01e97":"code","412abce9":"code","4d6b0b7e":"code","8aa1c4ed":"code","4012d6ce":"markdown","8090ac1e":"markdown","8afaf634":"markdown","cc4494f9":"markdown","6e1e5be4":"markdown","800eac5e":"markdown","2ae06de2":"markdown"},"source":{"ffee8c6a":"!pip install kaggle-environments --upgrade -q","c61475ad":"import time\nimport math\nimport glob\nimport re\nimport os\nimport itertools\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nimport numpy as np\n\nfrom collections import defaultdict\nfrom joblib import Parallel, delayed\nfrom kaggle_environments import evaluate, make, utils","728ca4d2":"agent_files = glob.glob('..\/input\/**\/*.py') + glob.glob('..\/input\/*\/*\/*.py')\nsubmission_dirs = [ \n    os.path.dirname(file) \n    for file in agent_files \n    if file.endswith('submission.py')\n]\nexcludes = [\n    file\n    for file in agent_files\n    if not file.endswith('submission.py')\n       and not 'rps-dojo' in file\n       and os.path.dirname(file) in submission_dirs\n]\nexcludes += [ \"react.py\" ]  \nprint(excludes)\n\nagent_files = [ name for name in agent_files if not any( exclude in name for exclude in excludes ) ]\nagent_names = map(lambda name: re.sub('\\.\\.\/input\/|\/submission.py','', name), agent_files)\nagent_names = map(lambda name: re.sub('^((rps|rock|paper|scissors|roshambo|comp)[.-]?)+|-agent|\\.py$','', name), agent_names)\nagent_names = map(lambda name: re.sub('\/', ' \\n ', name), agent_names)\nagents = { k: v for k, v in zip(agent_files, agent_names) }\nagents","2337fc55":"!rm -rf .\/agents\n!rsync -r ..\/input .\/agents\n!find .\/agents\/ -type f -not -name '*.py' -delete\n!find .\/agents\/ -type d -name '__results___files' -delete\n# !find .\/agents","e88cb6b2":"%%time\ndef evaluate_mab(i1, i2, agent1, agent2):\n    print(i1, i2, agent1, agent2)\n    try:\n        result = evaluate(\"rps\", [ agent1, agent2 ])\n        result = np.array(result).flatten()\n    except:\n        result = np.array([0,0])\n    return (i1, i2, result)\n    \n\nif os.environ.get('KAGGLE_KERNEL_RUN_TYPE','') == 'Interactive':\n    agents = { key: agents[key] for key in sorted(agents.keys())[-4:] } # for debugging\n    display(agents)\n\nsafety_time  = 3*60*60\nmax_notebook = 9*60*60\ntime_end     = time.perf_counter() + max_notebook - safety_time\nresults      = []\nwhile time.perf_counter() < time_end:\n    results += Parallel(-1)( \n        delayed(evaluate_mab)(i1, i2, agent1, agent2) \n        for i1, agent1 in enumerate(agents.keys())\n        for i2, agent2 in enumerate(agents.keys())\n    )\n    if os.environ.get('KAGGLE_KERNEL_RUN_TYPE','') == 'Interactive': break\n    if os.environ.get('KAGGLE_KERNEL_RUN_TYPE','') == 'Batch':       continue\n\n# results","a576389d":"def df_half(df, ratio=0.5):\n    rows = int(len(df) * ratio)\n    cols = df.columns[:rows]\n    return df[:rows][cols]\n\ndef df_sort(df, by=None, ascending=False):\n    by = df if by is None else by\n    for axis in [0,1]:\n        df = df.reindex( by.mean().sort_values(ascending=ascending).index, axis=axis)\n    return df\n\ndef winrate_score(score1, score2):\n    try:\n        if score1 == score2: return  0\n        if score1 is None:   return -1\n        if score2 is None:   return  1\n        if score1 >  score2: return  1\n        if score1 <  score2: return -1\n    except: pass\n    return 0\n    \n\nscores_agent = defaultdict(list)\nscores_total = np.zeros(( len(agents), len(agents) ), dtype=np.int)\nscores_diff  = np.zeros(( len(agents), len(agents) ), dtype=np.float)\nwinrates     = np.zeros(( len(agents), len(agents) ), dtype=np.int)\n\nfor (i1, i2, result) in results:\n    scores_total[i1,i2] += (result[0] or 0)\n    scores_total[i2,i1] += (result[1] or 0)\n    scores_diff[i1,i2]  += (result[0] or 0) - (result[1] or 0) \n    scores_diff[i2,i1]  += (result[1] or 0) - (result[0] or 0)\n    winrates[i1,i2]     += winrate_score(result[0], result[1])\n    winrates[i2,i1]     += winrate_score(result[1], result[0])\n    scores_agent[ list(agents.values())[i1] ].append( result[0] )\n    scores_agent[ list(agents.values())[i2] ].append( result[1] )\n    \ndf_scores_total = pd.DataFrame(\n    scores_total, \n    index   = list(agents.values()), \n    columns = list(agents.values()),\n)\ndf_scores_diff = pd.DataFrame(\n    scores_diff, \n    index   = list(agents.values()), \n    columns = list(agents.values()),\n)\ndf_winrates = pd.DataFrame(\n    winrates, \n    index   = list(agents.values()), \n    columns = list(agents.values()),\n)\ndf_scores_agent = pd.DataFrame(scores_agent)\n\n# Sort by mean score\ndf_scores_total = df_sort(df_scores_total, by=df_scores_agent)\ndf_scores_diff  = df_sort(df_scores_diff,  by=df_scores_agent)\ndf_winrates     = df_sort(df_winrates,     by=df_scores_agent)\ndf_scores_agent = df_scores_agent.reindex( df_scores_agent.mean().sort_values(ascending=False).index, axis=1)\n\ndisplay(df_scores_agent.T)\ndisplay(df_scores_agent.T.mean(axis=1))","ce229abf":"def plot_df_heatmap(df, title, doublelabel=False, **kwargs):\n    plt.figure(figsize=(df.shape[1], df.shape[0]))\n    plt.title(title)\n    sns.heatmap(\n        df, annot=True, cbar=False, \n        cmap='coolwarm', linewidths=1, \n        linecolor='black', \n        fmt='.0f',\n        **kwargs\n    )\n    plt.tick_params(labeltop=doublelabel, labelright=doublelabel)\n    plt.xticks(rotation=90, fontsize=max(10,df.shape[0]\/\/1.5))\n    plt.yticks(rotation=0,  fontsize=max(10,df.shape[0]\/\/1.5))\n    print(title)\n    print(df.mean(axis=1).sort_values(ascending=False))","b24fa9c0":"plot_df_heatmap(df_scores_total, 'Total Scores')","43fcdd7b":"plot_df_heatmap(df_sort(df_half(df_scores_total), ascending=True), 'Total Scores', doublelabel=False)","bcf49a40":"plot_df_heatmap(df_scores_diff, 'Relative Scores')","82c9415b":"plot_df_heatmap(df_sort(df_half(df_scores_diff), ascending=True), 'Relative Scores', doublelabel=False)","01a01e97":"plot_df_heatmap(df_sort(df_winrates, ascending=True), 'Winrates')","412abce9":"plot_df_heatmap(df_sort(df_half(df_winrates), ascending=True), 'Winrates', doublelabel=True)","4d6b0b7e":"def batch(iterable, n=1):\n    l = len(iterable)\n    for ndx in range(0, l, n):\n        yield iterable[ndx:min(ndx + n, l)]\n\ndef plot_df_boxplot(df, title, columns=8, boxplot_args={}, stripplot_args={}):\n    df_orig = df\n    n_rows    = math.ceil( len(df.columns) \/ columns )\n    n_columns = math.ceil( len(df.columns) \/ n_rows  )\n    for cols in batch(df.columns, n_columns):\n        df = df_orig[cols]\n        plt.figure(figsize=(n_columns*2, n_rows*6))\n        plt.title(title, loc=\"center\")\n\n        stripplot_args = { \"facecolor\": 'white', **boxplot_args }\n        ax = sns.boxplot(data=df, **boxplot_args)\n        plt.setp(ax.artists, edgecolor='grey', facecolor='w')\n        plt.setp(ax.lines, color='grey')\n\n        stripplot_args = { \"jitter\": 0.25, \"size\": 5, **stripplot_args }\n        ax = sns.stripplot(data=df, **stripplot_args)\n\n        # ax = sns.swarmplot(data=df_scores_agent)\n        plt.xticks(rotation=90, fontsize=15)\n        plt.yticks(rotation=0,  fontsize=15)\n        pass","8aa1c4ed":"plot_df_boxplot(df_scores_agent, \"All Matchmaking Scores\")","4012d6ce":"# Agents","8090ac1e":"# Boxplots","8afaf634":"# Rock Paper Scissors - Agents Comparison\n\nThis notebook attempts to compare the various public notebooks for this competition.\n\nIf you have a public notebook not included here, please leave a comment and a link for inclusion, else fork and simply add your own private notebooks as a dataset and rerun.\n\nInspired by:\n- https:\/\/www.kaggle.com\/ihelon\/rock-paper-scissors-agents-comparison\n- https:\/\/www.kaggle.com\/naokimaeda\/local-evaluation\n\nThis is a direct fork of my Santa 2020 Agents Comparison notebook \n- https:\/\/www.kaggle.com\/jamesmcguigan\/santa-2020-agents-comparison","cc4494f9":"# Winrates\n\nUltimately you only need to need to score one point higher than your opponent, so this plot shows how the leaderboard would actually respond to agents.","6e1e5be4":"# Total Scores\n\nThis shows the total score of each agent, showing how many resources it can extract before the opponent.","800eac5e":"# Relative Scores\n\nWinning this game doesn't actually depend on getting a high total score, simply getting a higher score than your opponent.","2ae06de2":"# Evaluation"}}