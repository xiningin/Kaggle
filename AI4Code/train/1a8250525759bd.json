{"cell_type":{"dc0e04a1":"code","f118fb13":"code","4f756608":"code","c0f3bebc":"code","c017f806":"code","f0d7aa0e":"code","1c61d1f9":"code","25d2147c":"code","01e5cd50":"code","80ee115c":"code","53f9b60e":"code","addebf6a":"markdown"},"source":{"dc0e04a1":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n","f118fb13":"train_cat = \"..\/input\/training_set\/training_set\/cats\"\ntrain_dog= \"..\/input\/training_set\/training_set\/dogs\"\ntest_cat= \"..\/input\/test_set\/test_set\/cats\"\ntest_dog= \"..\/input\/test_set\/test_set\/dogs\"\nimage_size = 128","4f756608":"Image.open(train_cat+\"\/\"+\"cat.1.jpg\")","c0f3bebc":"Image.open(\"..\/input\/training_set\/training_set\/dogs\/dog.1.jpg\")","c017f806":"minh, minv = 100000,100000\n\nfor p in range(1,4001):\n    pic = Image.open(train_cat+\"\/\"+\"cat.\"+str(p)+\".jpg\")\n    if pic.size[0] < minh:\n        minh = pic.size[0]\n    if pic.size[1] < minv:\n        minv = pic.size[1]\nfor u in range(1,4001):\n    pic = Image.open(train_dog+\"\/\"+\"dog.\"+str(u)+\".jpg\")\n    if pic.size[0] < minh:\n        minh = pic.size[0]\n    if pic.size[1] < minv:\n        minv = pic.size[1]\nprint(minh)\nprint(minv)","f0d7aa0e":"train_cat_list = []\nfor p in range(1,4001):\n    image = Image.open(train_cat+\"\/\"+\"cat.\"+str(p)+\".jpg\")\n    image = image.resize((minh, minv))\n    image = image.convert(mode=\"L\")\n    train_cat_list.append(image)\ntrain_dog_list = []\nfor u in range(1,4001):\n    image = Image.open(train_dog+\"\/\"+\"dog.\"+str(u)+\".jpg\")\n    image = image.resize((minh, minv))\n    image = image.convert(mode=\"L\")\n    train_dog_list.append(image)","1c61d1f9":"x = np.empty((4001+4001, minh * minv))\nindex = 0\nfor pl in train_cat_list:\n    x[index] = np.array(pl).reshape(minh * minv)\n    index += 1\nfor ul in train_dog_list:\n    x[index] = np.array(ul).reshape(minh * minv)\n    index += 1    \np = np.ones(4001)\nu = np.zeros(4001)\ny = np.concatenate((p,u),axis = 0).reshape(x.shape[0],1)","25d2147c":"from sklearn.model_selection import train_test_split\nx_train, x_test, y_train, y_test = train_test_split(x,y, test_size = 0.2, random_state = 42)\nx_train = x_train.T\nx_test = x_test.T\ny_train = y_train.T\ny_test = y_test.T","01e5cd50":"x_train = (x_train-np.min(x_train))\/(np.max(x_train)-np.min(x_train))\nx_test = (x_test-np.min(x_test))\/(np.max(x_test)-np.min(x_test))","80ee115c":"def initialize_weights_and_bias(dimension):\n    w = np.full((dimension,1),0.01)\n    b = 0.0\n    return w, b\n\ndef sigmoid(z):\n    y_head = 1\/(1+np.exp(-z))\n    return y_head\n\ndef forward_backward_propagation(w,b,x_train,y_train):\n    # forward propagation\n    z = np.dot(w.T,x_train) + b\n    y_head = sigmoid(z)\n    loss = -y_train*np.log(y_head)-(1-y_train)*np.log(1-y_head)\n    cost = (np.sum(loss))\/x_train.shape[1]\n    # backward propagation\n    derivative_weight = (np.dot(x_train,((y_head-y_train).T)))\/x_train.shape[1]\n    derivative_bias = np.sum(y_head-y_train)\/x_train.shape[1]\n    gradients = {\"derivative_weight\": derivative_weight,\"derivative_bias\": derivative_bias}\n    return cost,gradients\n\ndef update(w, b, x_train, y_train, learning_rate,number_of_iterarion):\n    cost_list = []\n    cost_list2 = []\n    index = []\n    \n    for i in range(number_of_iterarion):\n        \n        cost,gradients = forward_backward_propagation(w,b,x_train,y_train)\n        cost_list.append(cost)\n        \n        w = w - learning_rate * gradients[\"derivative_weight\"]\n        b = b - learning_rate * gradients[\"derivative_bias\"]\n        if i % 250 == 0:\n            cost_list2.append(cost)\n            index.append(i)\n            print (\"Cost after iteration %i: %f\" %(i, cost))\n    \n    parameters = {\"weight\": w,\"bias\": b}\n    plt.plot(index,cost_list2)\n    plt.xticks(index,rotation='vertical')\n    plt.xlabel(\"Number of Iterarion\")\n    plt.ylabel(\"Cost\")\n    plt.show()\n    return parameters, gradients, cost_list\n\ndef predict(w,b,x_test):\n    \n    z = sigmoid(np.dot(w.T,x_test)+b)\n    Y_prediction = np.zeros((1,x_test.shape[1]))\n\n    for i in range(z.shape[1]):\n        if z[0,i]<= 0.5:\n            Y_prediction[0,i] = 0\n        else:\n            Y_prediction[0,i] = 1\n\n    return Y_prediction\n\ndef logistic_regression(x_train, y_train, x_test, y_test, learning_rate ,  num_iterations):\n\n    dimension =  x_train.shape[0]\n    w,b = initialize_weights_and_bias(dimension)\n\n    parameters, gradients, cost_list = update(w, b, x_train, y_train, learning_rate,num_iterations)\n    \n    y_prediction_test = predict(parameters[\"weight\"],parameters[\"bias\"],x_test)\n    y_prediction_train = predict(parameters[\"weight\"],parameters[\"bias\"],x_train)\n    \n    print(\"Test Accuracy: {} %\".format(round(100 - np.mean(np.abs(y_prediction_test - y_test)) * 100,2)))\n    print(\"Train Accuracy: {} %\".format(round(100 - np.mean(np.abs(y_prediction_train - y_train)) * 100,2)))","53f9b60e":"logistic_regression(x_train, y_train, x_test, y_test,learning_rate = 0.002, num_iterations = 5001)","addebf6a":"Now we have to create x(pixels) and y(class) axis for each image"}}