{"cell_type":{"018e95c2":"code","8d8421d7":"code","0306313e":"code","ed9c8861":"code","759cdbeb":"code","0e2802de":"code","9213d233":"code","e59d4c39":"code","8eab87c1":"code","913363cf":"code","51a5a199":"code","6b524283":"code","644190a6":"code","bd850838":"code","c6c38548":"code","497f24d0":"code","8690d9a1":"code","099f09ac":"code","35d23ecc":"code","933352ff":"code","85f60185":"code","f32faefa":"code","01bb9034":"code","e1fe28a0":"code","16fe9824":"code","7ebf80ef":"code","8a64708e":"code","539228e1":"code","90f6e60f":"code","beebf582":"code","d3834baf":"code","aa6b2a78":"code","cc51e50f":"markdown","22c6039f":"markdown","a15aff11":"markdown","799b0182":"markdown","c9bec778":"markdown"},"source":{"018e95c2":"# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","8d8421d7":"# import libraries\nimport pandas as pd\nfrom pandas.api.types import CategoricalDtype\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport math\nfrom sklearn.model_selection import train_test_split, GridSearchCV\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.metrics import accuracy_score, plot_confusion_matrix, plot_roc_curve, confusion_matrix, classification_report","0306313e":"file = \"\/kaggle\/input\/pima-indians-diabetes-database\/diabetes.csv\"\ndiabetes = pd.read_csv(file)\ndiabetes.head()","ed9c8861":"diabetes.shape","759cdbeb":"diabetes.describe(include=\"all\")","0e2802de":"# check null values\ndiabetes.isnull().sum()","9213d233":"# check how many zeros in each column\n(diabetes == 0).astype(int).sum(axis=0)","e59d4c39":"# Replace zero to np.nan\nfor col in diabetes.iloc[:,1:6]:\n    diabetes[col].replace(0, np.nan, inplace=True)\n    \nimport missingno as msno\n# check missing data types: MCAR, MAR or MNAR\nsorted = diabetes.sort_values(\"Insulin\")\nmsno.matrix(sorted)\n","8eab87c1":"### check if there is correlations between midding data variables\n# msno.heatmap(sorted)\n# msno.dendrogram(sorted) <-- The dendrogram allows you to more fully correlate variable completion","913363cf":"mean_table = diabetes.groupby(\"Outcome\").mean()\nmean_table","51a5a199":"median_table = diabetes.groupby(\"Outcome\").median()\nmedian_table","6b524283":"# Replace null values with its mean of each outcome\ncol_names = ['Glucose', 'BloodPressure', 'SkinThickness', 'Insulin','BMI']\nfor col in col_names:\n    diabetes.loc[(diabetes.Outcome == 0) & (diabetes[col].isnull()), col] = median_table.loc[0, col]\n    diabetes.loc[(diabetes.Outcome == 1) & (diabetes[col].isnull()), col] = median_table.loc[1, col]","644190a6":"diabetes.info()","bd850838":"# Add range columns\n# Create conditions of each range assignment\nGlucose_conditions = [(diabetes[\"Glucose\"] <= 50),\n                      (diabetes[\"Glucose\"] > 50) & (diabetes[\"Glucose\"] <= 100),\n                      (diabetes[\"Glucose\"] > 100) & (diabetes[\"Glucose\"] <= 150),\n                      (diabetes[\"Glucose\"] > 150) & (diabetes[\"Glucose\"] <= 200),\n                     ]\nBMI_conditions = [(diabetes[\"BMI\"] <= 20),\n                      (diabetes[\"BMI\"] > 20) & (diabetes[\"BMI\"] <= 40),\n                      (diabetes[\"BMI\"] > 40) & (diabetes[\"BMI\"] <= 60),\n                      (diabetes[\"BMI\"] > 60) & (diabetes[\"BMI\"] <= 80),\n                     ]\nAge_conditions = [(diabetes[\"Age\"] >= 20) & (diabetes[\"Age\"] < 30),\n                  (diabetes[\"Age\"] >= 30) & (diabetes[\"Age\"] < 40),\n                  (diabetes[\"Age\"] >= 40) & (diabetes[\"Age\"] < 50),\n                  (diabetes[\"Age\"] >= 50) & (diabetes[\"Age\"] < 60),\n                  (diabetes[\"Age\"] >= 60) & (diabetes[\"Age\"] < 70),\n                  (diabetes[\"Age\"] >= 70) & (diabetes[\"Age\"] < 80),\n                  (diabetes[\"Age\"] >= 80) & (diabetes[\"Age\"] < 90),\n                     ]\n\n# create a list of the values we want to assign for each condition\nGlucose_values = [\"0-50\", \"51-100\",\"101-150\",\"151-200\"]\nBMI_values = [\"0-20\", \"21-40\",\"41-60\",\"61-80\"]\nAge_values = [\"20-29\",\"30-39\",\"40-49\",\"50-59\",\"60-69\",\"70-79\",\"80-89\"]\n\n# create columns that map conditions with its values\ndiabetes[\"GlucoseRange\"] = np.select(Glucose_conditions, Glucose_values)\ndiabetes[\"BMIRange\"]= np.select(BMI_conditions, BMI_values)\ndiabetes[\"AgeRange\"]= np.select(Age_conditions, Age_values)\n\n# Convert data type of range columns to category type with order\nGlucose_level = CategoricalDtype(categories=Glucose_values, ordered=True)\nBMI_level = CategoricalDtype(categories=BMI_values, ordered=True)\nAge_level = CategoricalDtype(categories=Age_values, ordered=True)\ndiabetes[\"GlucoseRange\"] = diabetes[\"GlucoseRange\"].astype(Glucose_level)\ndiabetes[\"BMIRange\"] = diabetes[\"BMIRange\"].astype(BMI_level)\ndiabetes[\"AgeRange\"] = diabetes[\"AgeRange\"].astype(Age_level)\n\n# print first 6 rows of new df\nprint(diabetes.dtypes)","c6c38548":"# plot histgram of each variable\ndef get_histograms(df, cols=1):\n    rows = math.ceil(len(df.columns)\/cols)\n    figwidth = cols * 4\n    fidheight = rows * 4\n   \n    fig, ax = plt.subplots(\n        figsize = (figwidth,fidheight),\n        nrows = rows,\n        ncols = cols\n    )\n    ax = ax.flatten()  # ax need to be flattened first in order to iterate through subplots.\n    for i, col in enumerate(df.columns):\n        ax[i].hist(df[col],\n                   color = \"#45ADA8\",\n                   alpha = 1\n                  )\n        ax[i].set_title(f\"{df[col].name}\", fontsize=14)\n    \n    fig.suptitle(f\"Histograms for all variables in the Data\", fontsize=16)\n    fig.tight_layout()\n    fig.subplots_adjust(bottom=0, top=0.8)\n    \n    plt.show()\n    return\n\nget_histograms(diabetes.iloc[:, 0:9], cols=3)    ","497f24d0":"# check correlation between different variables\ndef corr_heat(df, title = None):\n    plt.figure(figsize=(8, 6))\n    sns.set(font_scale=1)\n    matrix = df.corr()\n    mask = np.triu(np.ones_like(matrix, dtype=bool))\n    cmap = sns.diverging_palette(220, 15, s=80, n=9, as_cmap=True, center=\"light\")\n    \n    with sns.axes_style(\"white\"):\n        sns.heatmap(matrix, mask=mask, annot=True, cmap=cmap, square=True, fmt='.2f',linewidth=.6, center=0, vmin=-0.15, vmax=0.65)\n    if title: plt.title(f\"\\n{title}\\n\", fontsize=14)\n    \ncorr_heat(diabetes, \"Diabetes Data: Variable correlations\" )","8690d9a1":"#Plot a cross tab to check how Glucose and BMI level related to Outcome\ndef cross(col1, col2, value_col):\n    cross = pd.crosstab(col1, col2, values = value_col, aggfunc=\"sum\", margins=True, margins_name=\"Total\", normalize='all')\n    sns.heatmap(cross, cmap=\"BuGn\", annot=True, cbar=False)\n    plt.xlabel = col1\n    plt.ylabel = col2\n    plt.yticks(rotation=0)\n\ncross(diabetes.GlucoseRange, diabetes.AgeRange, diabetes.Outcome)\n\n","099f09ac":"cross(diabetes.GlucoseRange, diabetes.BMIRange, diabetes.Outcome)","35d23ecc":"# add noises to y axis for the better visualisation\nSkinThickness_jitter = diabetes.SkinThickness + np.random.normal(0,2,len(diabetes.SkinThickness))\ninsulin_jitter = diabetes.Insulin + np.random.normal(0,2, len(diabetes.Insulin))\nBloodPressure_jitter = diabetes.BloodPressure + np.random.normal(0,2, len(diabetes.BloodPressure))\n\n# plot multiple subplots to validate correlations\nfig, axs = plt.subplots(3, 2, figsize=(10,10))\naxs[0, 0].plot(diabetes.Age, diabetes.Pregnancies, marker=\"o\", linestyle=\"\", markersize=1.2, alpha=.7)\naxs[0, 0].set_title('Age vs Pregnancies')\naxs[0, 1].plot(diabetes.BMI, SkinThickness_jitter, marker=\"o\", linestyle=\"\", markersize=1.1, alpha=.7)\naxs[0, 1].set_title('BMI vs SkinThickness')\naxs[1, 0].plot(diabetes.Glucose, insulin_jitter, marker=\"o\", linestyle=\"\", markersize=1.1, alpha=.7)\naxs[1, 0].set_title('Glucose vs Insulin')\naxs[1, 1].plot(diabetes.BMI, BloodPressure_jitter, marker=\"o\", linestyle=\"\", markersize=1.2, alpha=.7)\naxs[1, 1].set_title('BMI vs BloodPressure')\naxs[2, 0].plot(SkinThickness_jitter, insulin_jitter, marker=\"o\", linestyle=\"\", markersize=1.2, alpha=.7)\naxs[2, 0].set_title('SkinThickness vs Insulin')\nfig.tight_layout()","933352ff":"diabetes = diabetes.drop(['GlucoseRange',\n       'BMIRange', 'AgeRange'], axis=1)","85f60185":"# Outcome vs other features\nplt.figure(figsize = (15, 15))\nplotnumber = 1\nfor col in diabetes.iloc[:, 0:8]:\n    ax = plt.subplot(3, 3, plotnumber)\n    sns.boxplot(x=diabetes[\"Outcome\"], y=diabetes[col], data=diabetes)\n    plotnumber += 1\nplt.show()","f32faefa":"# Handle outliers with Z score\nfrom scipy import stats\nz = np.abs(stats.zscore(diabetes))\nprint(z)\nthreshold = 3\nnp.where(z>threshold)\ndiabetes_cleaned = diabetes[(z < 3).all(axis=1)]\nprint(diabetes_cleaned.shape)\nprint(diabetes.shape)","01bb9034":"# Outcome vs other features\nplt.figure(figsize = (15, 15))\nplotnumber = 1\nfor col in diabetes_cleaned.iloc[:, 0:8]:\n    ax = plt.subplot(3, 3, plotnumber)\n    sns.boxplot(x=diabetes_cleaned[\"Outcome\"], y=diabetes_cleaned[col], data=diabetes_cleaned)\n    plotnumber += 1\nplt.show()","e1fe28a0":"#sns.pairplot(diabetes, vars = ['Glucose', 'BMI',\"BloodPressure\", \"Insulin\", \"Pregnancies\",\"Age\"], hue=\"Outcome\")","16fe9824":"#Seperate dataset to features and target\nX = diabetes_cleaned.drop([\"Outcome\"], axis=1).values\ny = diabetes_cleaned[\"Outcome\"].values\n# Split the dataset to training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X,y, test_size = .3, stratify=y, random_state=21)","7ebf80ef":"def Model(modelname, model):\n  # Setup the pipeline steps: steps\n  steps = [(\"scaler\", StandardScaler()),\n         (modelname, model)\n        ]\n  pipeline = Pipeline(steps)\n  pipeline.fit(X_train,y_train)\n  score=pipeline.score(X_test,y_test)\n  y_pred=pipeline.predict(X_test)\n  cm = confusion_matrix(y_test,y_pred)\n  cr = classification_report(y_test, y_pred)\n  print('Testing Score \\n',score)\n  print(cr)\n  plot_confusion_matrix(pipeline,X_test,y_test,cmap='OrRd')\n  plot_roc_curve(pipeline, X_test, y_test)","8a64708e":"# Find the best param of Knn\n# Setup the pipeline steps: steps\nknn = KNeighborsClassifier()\n\n# Set pipeline steps\nsteps = [(\"scaler\", StandardScaler()),\n         (\"knn\", KNeighborsClassifier())\n        ]\npipeline = Pipeline(steps)\n\n# Set n_neighbors range\nparameters = {\"knn__n_neighbors\":np.arange(1,50)}\n\n# Search best params n_neighbors\nknn_cv = GridSearchCV(pipeline, param_grid=parameters, cv=5)\nknn_cv.fit(X_train, y_train)\nprint(\"The best param: \" + str(knn_cv.best_params_)) \n\n# Using the best parames to calculate R square\n#y_pred = knn_cv.predict(X_test)\n#score = knn_cv.score(X_test, y_test)","539228e1":"Model(\"knn\", KNeighborsClassifier(13))","90f6e60f":"Model(\"logreg\", LogisticRegression())","beebf582":"Model(\"dt\", DecisionTreeClassifier(max_depth=3, random_state=1))","d3834baf":"\"\"\"\n# Scale features\nfrom sklearn.preprocessing import scale\nX_scaled = scale(X)\n\n#Visual EDA, similar to pairplot\n#_ = pd.plotting.scatter_matrix(X, c=y, figsize=[15,15], s=150, marker=\".\", alpha=0.2)\n\n# Handle outliers with IQR\nq1 = diabetes.iloc[:, 1:8].quantile(0.25)\nq3 = diabetes.iloc[:, 1:8].quantile(0.75)\nIQR = q3 - q1\nprint(IQR)\noutliers = (diabetes < q1 - 1.5 * IQR) | (diabetes > q3 + 1.5 * IQR)\ndiabetes_new2 = diabetes[~outliers.any(axis=1)]\nprint(diabetes_new2.shape)\nprint(diabetes.shape)\n\n#Fill dummy values\nfrom numpy.random import rand\ndef fill_dummy_values(df, scaling_factor=0.1):\n  df_dummy = df.copy(deep=True)\n  for col_name in df_dummy:\n    col = df_dummy[col_name] \n    col_null = col.isnull()\n    # Calculate number of missing values in column \n    num_nulls = col_null.sum()\n    # Calculate column range\n    col_range = col.max() - col.min()\n    # Scale the random values to scaling_factor times col_range\n    dummy_values = (rand(num_nulls) - 2) * col_range * scaling_factor + col.min()\n    col[col_null] = dummy_values\n  return df_dummy\n\n# Fill dummy values in diabetes_dummy\ndiabetes_dummy = fill_dummy_values(diabetes)\n# Sum the nullity of Insulin and SkinThickness\nnullity = diabetes['Insulin'].isnull() + diabetes['SkinThickness'].isnull()\n\n# Create a scatter plot of Insulin and SkinThickness\nsns.scatterplot(diabetes_dummy.Insulin, diabetes_dummy.SkinThickness, hue=nullity)\n\"\"\"","aa6b2a78":"\"\"\"\n#'BloodPressure', 'SkinThickness', 'Insulin' are missing big portions of its data points, mean might not be the best method for these variables.\n# Impute with the most frequent value\nfrom sklearn.impute import SimpleImputer\nimp = SimpleImputer(strategy =\"most_frequent\")\ncolumns = ['BloodPressure', 'SkinThickness', 'Insulin']\nfor col in columns:\n    diabetes[col] = imp.fit_transform(diabetes[col].values.reshape(-1,1))\n\"\"\"","cc51e50f":"# 3. EDA: Visualization","22c6039f":"# 4. Build models","a15aff11":"# 2. Checking and handling missing data","799b0182":"Goal : EDA of Pima Indians Diabetes Database before predict the onset of diabetes based on diagnostic measures.\n\nData Variables:\n* Pregnancies: Number of times pregnant\n* Glucose: Plasma glucose concentration a 2 hours in an oral glucose tolerance test\n* BloodPressure: Diastolic blood pressure (mm Hg)\n* SkinThickness: Triceps skin fold thickness (mm)\n* Insulin: 2-Hour serum insulin (mu U\/ml)\n* BMI: Body mass index (weight in kg\/(height in m)^2)\n* DiabetesPedigreeFunction: Diabetes pedigree function\n* Age (years)\n* Outcome: Class variable (0 or 1)","c9bec778":"# 1. Basic EDA"}}