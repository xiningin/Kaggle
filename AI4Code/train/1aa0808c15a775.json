{"cell_type":{"1d16db58":"code","d3e5c555":"code","50342f1b":"code","3ea2896e":"code","10ed0af9":"code","4102343a":"code","c988fc7a":"code","6e21b550":"code","dc2ed352":"code","b61e110a":"code","d92df28f":"code","6c4e7472":"code","cac506e5":"code","9eb47858":"code","45ef8320":"code","e0e84259":"code","8ce2596e":"code","e6f33225":"code","8b9bb986":"code","adf210c4":"code","63c5f946":"code","90a29704":"code","3a52ebcc":"code","53be734c":"code","048816d1":"code","79ea06eb":"code","64c69ffb":"code","b993cddb":"markdown","efadcfa2":"markdown","7fda5f39":"markdown","6c736eb4":"markdown","9ca28168":"markdown","cf915a00":"markdown","f2e5948d":"markdown","e9f76ba4":"markdown"},"source":{"1d16db58":"seed = 29\nparams = {\n    'learning_rate': 0.1,        \n    'lambda_l1': 2,\n    'lambda_l2': 7,\n    'num_leaves': 800,\n    'min_sum_hessian_in_leaf': 20,\n    'feature_fraction': 0.8,\n    'feature_fraction_bynode': 0.8,\n    'bagging_fraction': 0.9,\n    'bagging_freq': 42,\n    'min_data_in_leaf': 700,\n    'max_depth': 4,\n    'seed': seed,\n    'feature_fraction_seed': seed,\n    'bagging_seed': seed,\n    'drop_seed': seed,\n    'data_random_seed': seed,\n    'objective': 'rmse',\n    'boosting': 'gbdt',\n    'verbosity': -1,\n    'n_jobs': -1,\n} ","d3e5c555":"import os\nimport glob\nfrom joblib import Parallel, delayed\nimport pandas as pd\nimport numpy as np\nimport scipy as sc\nfrom sklearn.model_selection import KFold\nimport lightgbm as lgb\nimport warnings\nwarnings.filterwarnings('ignore')\npd.set_option('max_columns', 300)","50342f1b":"# Function to calculate first WAP\ndef calc_wap1(df):\n    wap = (df['bid_price1'] * df['ask_size1'] + df['ask_price1'] * df['bid_size1']) \/ (df['bid_size1'] + df['ask_size1'])\n    return wap\n\n# Function to calculate second WAP\ndef calc_wap2(df):\n    wap = (df['bid_price2'] * df['ask_size2'] + df['ask_price2'] * df['bid_size2']) \/ (df['bid_size2'] + df['ask_size2'])\n    return wap\n\n# Function to calculate the log of the return\n# Remember that logb(x \/ y) = logb(x) - logb(y)\ndef log_return(series):\n    return np.log(series).diff()\n\n# Calculate the realized volatility\ndef realized_volatility(series):\n    return np.sqrt(np.sum(series**2))\n\n# Function to count unique elements of a series\ndef count_unique(series):\n    return len(np.unique(series))","3ea2896e":"data_dir = '..\/input\/optiver-realized-volatility-prediction\/'","10ed0af9":"# Function to read our base train and test set\ndef read_train_test():\n    train = pd.read_csv(data_dir + 'train.csv')\n    test = pd.read_csv(data_dir + 'test.csv')\n    # Create a key to merge with book and trade data\n    train['row_id'] = train['stock_id'].astype(str) + '-' + train['time_id'].astype(str)\n    test['row_id'] = test['stock_id'].astype(str) + '-' + test['time_id'].astype(str)\n    print(f'Our training set has {train.shape[0]} rows')\n    return train, test","4102343a":"# Function to preprocess book data (for each stock id)\ndef book_preprocessor(file_path):\n    df = pd.read_parquet(file_path)\n    # Calculate Wap\n    df['wap1'] = calc_wap1(df)\n    df['wap2'] = calc_wap2(df)\n    # Calculate log returns\n    df['log_return1'] = df.groupby(['time_id'])['wap1'].apply(log_return)\n    df['log_return2'] = df.groupby(['time_id'])['wap2'].apply(log_return)\n    # Calculate wap balance\n    df['wap_balance'] = abs(df['wap1'] - df['wap2'])\n    # Calculate spread\n    df['price_spread'] = (df['ask_price1'] - df['bid_price1']) \/ ((df['ask_price1'] + df['bid_price1']) \/ 2)\n    df['price_spread2'] = (df['ask_price2'] - df['bid_price2']) \/ ((df['ask_price2'] + df['bid_price2']) \/ 2)\n    df['bid_spread'] = df['bid_price1'] - df['bid_price2']\n    df['ask_spread'] = df['ask_price1'] - df['ask_price2']\n    df[\"bid_ask_spread\"] = abs(df['bid_spread'] - df['ask_spread'])\n    df['total_volume'] = (df['ask_size1'] + df['ask_size2']) + (df['bid_size1'] + df['bid_size2'])\n    df['volume_imbalance'] = abs((df['ask_size1'] + df['ask_size2']) - (df['bid_size1'] + df['bid_size2']))\n    \n    # Dict for aggregations\n    create_feature_dict = {\n        'wap1': [np.sum, np.mean, np.std],\n        'wap2': [np.sum, np.mean, np.std],\n        'log_return1': [np.sum, realized_volatility, np.mean, np.std],\n        'log_return2': [np.sum, realized_volatility, np.mean, np.std],\n        'wap_balance': [np.sum, np.mean, np.std],\n        'price_spread':[np.sum, np.mean, np.std],\n        'price_spread2':[np.sum, np.mean, np.std],\n        'bid_spread':[np.sum, np.mean, np.std],\n        'ask_spread':[np.sum, np.mean, np.std],\n        'total_volume':[np.sum, np.mean, np.std],\n        'volume_imbalance':[np.sum, np.mean, np.std],\n        \"bid_ask_spread\":[np.sum, np.mean, np.std],\n    }\n    \n    # Function to get group stats for different windows (seconds in bucket)\n    def get_stats_window(seconds_in_bucket, add_suffix = False):\n        # Group by the window\n        df_feature = df[df['seconds_in_bucket'] >= seconds_in_bucket].groupby(['time_id']).agg(create_feature_dict).reset_index()\n        # Rename columns joining suffix\n        df_feature.columns = ['_'.join(col) for col in df_feature.columns]\n        # Add a suffix to differentiate windows\n        if add_suffix:\n            df_feature = df_feature.add_suffix('_' + str(seconds_in_bucket))\n        return df_feature\n    \n    # Get the stats for different windows\n    # \u304d\u3063\u3068100\u79d2\u523b\u307f\u306f\u3044\u3044\u7d50\u679c\u3092\u5f97\u308c\u306a\u304b\u3063\u305f\u306e\u3060\u308d\u3046\n    df_feature = get_stats_window(seconds_in_bucket = 0, add_suffix = False)\n    df_feature_450 = get_stats_window(seconds_in_bucket = 450, add_suffix = True)\n#     df_feature_500 = get_stats_window(seconds_in_bucket = 500, add_suffix = True)\n#     df_feature_400 = get_stats_window(seconds_in_bucket = 400, add_suffix = True)\n    df_feature_300 = get_stats_window(seconds_in_bucket = 300, add_suffix = True)\n#     df_feature_200 = get_stats_window(seconds_in_bucket = 200, add_suffix = True)\n    df_feature_150 = get_stats_window(seconds_in_bucket = 150, add_suffix = True)\n\n    # Merge all\n    df_feature = df_feature.merge(df_feature_450, how = 'left', left_on = 'time_id_', right_on = 'time_id__450')\n    df_feature = df_feature.merge(df_feature_300, how = 'left', left_on = 'time_id_', right_on = 'time_id__300')\n#     df_feature = df_feature.merge(df_feature_300, how = 'left', left_on = 'time_id_', right_on = 'time_id__300')\n    df_feature = df_feature.merge(df_feature_150, how = 'left', left_on = 'time_id_', right_on = 'time_id__150')\n#     df_feature = df_feature.merge(df_feature_100, how = 'left', left_on = 'time_id_', right_on = 'time_id__100')\n    # Drop unnecesary time_ids\n    df_feature.drop(['time_id__450', 'time_id__300', 'time_id__150'], axis = 1, inplace = True)\n    \n    \n    # Create row_id so we can merge\n    stock_id = file_path.split('=')[1]\n    df_feature['row_id'] = df_feature['time_id_'].apply(lambda x: f'{stock_id}-{x}')\n    df_feature.drop(['time_id_'], axis = 1, inplace = True)\n    return df_feature\n","c988fc7a":"# Function to preprocess trade data (for each stock id)\ndef trade_preprocessor(file_path):\n    df = pd.read_parquet(file_path)\n    df['log_return'] = df.groupby('time_id')['price'].apply(log_return)\n    \n    # Dict for aggregations\n    create_feature_dict = {\n        'log_return':[realized_volatility],\n        'seconds_in_bucket':[count_unique],\n        'size':[np.sum, realized_volatility, np.mean, np.std, np.max, np.min],\n        'order_count':[np.mean,np.sum,np.max],\n    }\n    \n    # Function to get group stats for different windows (seconds in bucket)\n    def get_stats_window(seconds_in_bucket, add_suffix = False):\n        # Group by the window\n        df_feature = df[df['seconds_in_bucket'] >= seconds_in_bucket].groupby(['time_id']).agg(create_feature_dict).reset_index()\n        # Rename columns joining suffix\n        df_feature.columns = ['_'.join(col) for col in df_feature.columns]\n        # Add a suffix to differentiate windows\n        if add_suffix:\n            df_feature = df_feature.add_suffix('_' + str(seconds_in_bucket))\n        return df_feature\n    \n\n    # Get the stats for different windows\n    df_feature = get_stats_window(seconds_in_bucket = 0, add_suffix = False)\n    df_feature_450 = get_stats_window(seconds_in_bucket = 450, add_suffix = True)\n#     df_feature_500 = get_stats_window(seconds_in_bucket = 500, add_suffix = True)\n#     df_feature_400 = get_stats_window(seconds_in_bucket = 400, add_suffix = True)\n    df_feature_300 = get_stats_window(seconds_in_bucket = 300, add_suffix = True)\n#     df_feature_200 = get_stats_window(seconds_in_bucket = 200, add_suffix = True)\n    df_feature_150 = get_stats_window(seconds_in_bucket = 150, add_suffix = True)\n    \n    #\n    # \u3053\u3053\u304b\u30b9\u30b3\u30a2\u306b\u76f8\u5f53\u5f71\u97ff\u3057\u3066\u308b\u3068\u8a18\u8f09\u3057\u3066\u308b\n    # \u306a\u3093\u3067\u3053\u308c\u304c\u52b9\u3044\u3066\u308b\u304b\u306f\u3044\u307e\u306e\u3068\u3053\u308d\u4e0d\u660e\n    # \u304a\u3063\u3066\u8abf\u3079\u308b\u3053\u3068\u306b\u3059\u308b\u3002\n    #\n    \n    def tendency(price, vol):    \n        df_diff = np.diff(price)\n        # \u5dee\u5206\u3092\u52d5\u3044\u305f\u5f8c\u306e\u4fa1\u683c\u3067\u5272\u3063\u3066*100\u3057\u3066\u308b\n        # \u5909\u52d5\u984d\u3092\u5909\u52d5\u5f8c\u306e\u4fa1\u683c\u3067\u5272\u308b\u3053\u3068\u3067\u6bd4\u7387\u306b\u3057\u3066\u3044\u308b(\u5c0f\u3055\u3044\u4fa1\u683c\u3060\u3068\u3053\u306e\u5024\u306f\u304a\u304a\u304d\u304f\u306a\u308b)\n        val = (df_diff\/price[1:])*100\n        # \u305d\u308c\u306bvol\u3092\u304b\u3051\u3066\u308b\u306e\u3067\u5909\u52d5\u6bd4\u7387\u306b\u5927\u304d\u3055\u3092\u304b\u3051\u308b\u306e\u3067\u3053\u306e\u5024\u304c\u5927\u304d\u3044\u3068\u5024\u306e\u6bd4\u7387\u304c\u5927\u304d\u304f\u52d5\u3044\u305f\u3053\u3068\u306b\u306a\u308b\n        power = np.sum(val*vol[1:])\n        return(power)\n    \n    lis = []\n    # time_id\u306b\u5bfe\u5fdc\u3059\u308bdf\u3092\u629c\u304d\u51fa\u3059\u3002\n    # time_id\u306b\u7d71\u8a08\u6307\u6a19\u306a\u306e\u3067\u30ea\u30fc\u30af\u3057\u3066\u3044\u308b\n    \n    for n_time_id in df['time_id'].unique():\n        df_id = df[df['time_id'] == n_time_id]\n        \n        # power\u3063\u3066\u547c\u3070\u308c\u308b\u6307\u6a19\u3092\u5f97\u308b\u3002\n        tendencyV = tendency(df_id['price'].values, df_id['size'].values)      \n        \n        # \u5e73\u5747\u4ee5\u4e0a\u306eprice\u306e\u5408\u8a08\u3068\u5e73\u5747\u4ee5\u4e0b\u306eprice\u306e\u5408\u8a08\u5024\n        # \u5168\u304f\u3082\u3063\u3066\u3044\u3089\u306a\u3044\u30c7\u30fc\u30bf\u306b\u3057\u304b\u898b\u3048\u306a\u3044\u3002\n        # \u5916\u308c\u5024\u306e\u5f71\u97ff\u5f15\u304f\u6c17\u304c\u3059\u308b\u3057\n        f_max = np.sum(df_id['price'].values > np.mean(df_id['price'].values))\n        f_min = np.sum(df_id['price'].values < np.mean(df_id['price'].values))\n        \n        #\n        # \u6b63\u306e\u5dee\u5206\u306e\u5408\u8a08\u5024\u3068\u8ca0\u306e\u5dee\u5206\u306e\u5408\u8a08\u5024\n        # \u3044\u308b\u306e\u304b\u3053\u308c\n        df_max =  np.sum(np.diff(df_id['price'].values) > 0)\n        df_min =  np.sum(np.diff(df_id['price'].values) < 0)\n        \n        \n        # \u504f\u5dee\u306e\u4e2d\u592e\u5024\n        abs_diff = np.median(np.abs(df_id['price'].values - np.mean(df_id['price'].values)))  \n        # \u4fa1\u683c\u306e\u4e8c\u4e57\u306e\u5e73\u5747\u5024\n        energy = np.mean(df_id['price'].values**2)\n        # \u7b2c3-\u7b2c\uff11\n        iqr_p = np.percentile(df_id['price'].values,75) - np.percentile(df_id['price'].values,25)\n        \n        # size\u306b\u5bfe\u3057\u3066\u3082\u3046\u3048\u3068\u540c\u69d8\u306e\u3053\u3068\n        abs_diff_v = np.median(np.abs(df_id['size'].values - np.mean(df_id['size'].values)))        \n        energy_v = np.sum(df_id['size'].values**2)\n        iqr_p_v = np.percentile(df_id['size'].values,75) - np.percentile(df_id['size'].values,25)\n        \n        lis.append({'time_id':n_time_id,'tendency':tendencyV,'f_max':f_max,'f_min':f_min,'df_max':df_max,'df_min':df_min,\n                   'abs_diff':abs_diff,'energy':energy,'iqr_p':iqr_p,'abs_diff_v':abs_diff_v,'energy_v':energy_v,'iqr_p_v':iqr_p_v})\n        \n    df_lr = pd.DataFrame(lis)\n        \n   \n    df_feature = df_feature.merge(df_lr, how = 'left', left_on = 'time_id_', right_on = 'time_id')\n    \n    # Merge all\n    df_feature = df_feature.merge(df_feature_450, how = 'left', left_on = 'time_id_', right_on = 'time_id__450')\n    df_feature = df_feature.merge(df_feature_300, how = 'left', left_on = 'time_id_', right_on = 'time_id__300')\n#     df_feature = df_feature.merge(df_feature_300, how = 'left', left_on = 'time_id_', right_on = 'time_id__300')\n    df_feature = df_feature.merge(df_feature_150, how = 'left', left_on = 'time_id_', right_on = 'time_id__150')\n#     df_feature = df_feature.merge(df_feature_100, how = 'left', left_on = 'time_id_', right_on = 'time_id__100')\n    # Drop unnecesary time_ids\n    df_feature.drop(['time_id__450', 'time_id__300', 'time_id__150','time_id'], axis = 1, inplace = True)\n    \n    \n    \n    df_feature = df_feature.add_prefix('trade_')\n    stock_id = file_path.split('=')[1]\n    df_feature['row_id'] = df_feature['trade_time_id_'].apply(lambda x:f'{stock_id}-{x}')\n    df_feature.drop(['trade_time_id_'], axis = 1, inplace = True)\n    return df_feature\n","6e21b550":"# Function to get group stats for the stock_id and time_id\ndef get_time_stock(df):\n    # Get realized volatility columns\n    vol_cols = ['log_return1_realized_volatility', 'log_return2_realized_volatility', 'log_return1_realized_volatility_450', 'log_return2_realized_volatility_450', \n                'log_return1_realized_volatility_300', 'log_return2_realized_volatility_300', 'log_return1_realized_volatility_150', 'log_return2_realized_volatility_150', \n                'trade_log_return_realized_volatility', 'trade_log_return_realized_volatility_450', 'trade_log_return_realized_volatility_300', 'trade_log_return_realized_volatility_150']\n#     vol_cols = ['log_return1_realized_volatility', 'log_return2_realized_volatility',\n#                 'log_return1_realized_volatility_600', 'log_return2_realized_volatility_600', \n#                 'log_return1_realized_volatility_400', 'log_return2_realized_volatility_400',\n# #                 'log_return1_realized_volatility_300', 'log_return2_realized_volatility_300', \n#                 'log_return1_realized_volatility_200', 'log_return2_realized_volatility_200',\n# #                 'log_return1_realized_volatility_100', 'log_return2_realized_volatility_100', \n#                 'trade_log_return_realized_volatility',\n#                 'trade_log_return_realized_volatility_600', \n#                 'trade_log_return_realized_volatility_400',\n# #                 'trade_log_return_realized_volatility_300',\n# #                 'trade_log_return_realized_volatility_100',\n#                 'trade_log_return_realized_volatility_200']\n\n    # Group by the stock id\n    df_stock_id = df.groupby(['stock_id'])[vol_cols].agg(['mean', 'std', 'max', 'min', ]).reset_index()\n    # Rename columns joining suffix\n    df_stock_id.columns = ['_'.join(col) for col in df_stock_id.columns]\n    df_stock_id = df_stock_id.add_suffix('_' + 'stock')\n\n    # Group by the stock id\n    df_time_id = df.groupby(['time_id'])[vol_cols].agg(['mean', 'std', 'max', 'min', ]).reset_index()\n    # Rename columns joining suffix\n    df_time_id.columns = ['_'.join(col) for col in df_time_id.columns]\n    df_time_id = df_time_id.add_suffix('_' + 'time')\n    \n    # Merge with original dataframe\n    df = df.merge(df_stock_id, how = 'left', left_on = ['stock_id'], right_on = ['stock_id__stock'])\n    df = df.merge(df_time_id, how = 'left', left_on = ['time_id'], right_on = ['time_id__time'])\n    df.drop(['stock_id__stock', 'time_id__time'], axis = 1, inplace = True)\n    return df\n    \n# Funtion to make preprocessing function in parallel (for each stock id)\ndef preprocessor(list_stock_ids, is_train = True):\n    \n    # Parrallel for loop\n    def for_joblib(stock_id):\n        # Train\n        if is_train:\n            file_path_book = data_dir + \"book_train.parquet\/stock_id=\" + str(stock_id)\n            file_path_trade = data_dir + \"trade_train.parquet\/stock_id=\" + str(stock_id)\n        # Test\n        else:\n            file_path_book = data_dir + \"book_test.parquet\/stock_id=\" + str(stock_id)\n            file_path_trade = data_dir + \"trade_test.parquet\/stock_id=\" + str(stock_id)\n    \n        # Preprocess book and trade data and merge them\n        df_tmp = pd.merge(book_preprocessor(file_path_book), trade_preprocessor(file_path_trade), on = 'row_id', how = 'left')\n        \n        # Return the merge dataframe\n        return df_tmp\n    \n    # Use parallel api to call paralle for loop\n    df = Parallel(n_jobs = -1, verbose = 1)(delayed(for_joblib)(stock_id) for stock_id in list_stock_ids)\n    # Concatenate all the dataframes that return from Parallel\n    df = pd.concat(df, ignore_index = True)\n    return df\n\n# Function to calculate the root mean squared percentage error\ndef rmspe(y_true, y_pred):\n    return np.sqrt(np.mean(np.square((y_true - y_pred) \/ y_true)))\n\n# Function to early stop with root mean squared percentage error\ndef feval_rmspe(y_pred, lgb_train):\n    y_true = lgb_train.get_label()\n    return 'RMSPE', rmspe(y_true, y_pred), False","dc2ed352":"# Function to calculate the root mean squared percentage error\ndef rmspe(y_true, y_pred):\n    return np.sqrt(np.mean(np.square((y_true - y_pred) \/ y_true)))\n\n# Function to early stop with root mean squared percentage error\ndef feval_rmspe(y_pred, lgb_train):\n    y_true = lgb_train.get_label()\n    return 'RMSPE', rmspe(y_true, y_pred), False","b61e110a":"# \u91cd\u8981\u5ea6\u89e3\u6790\ndef calc_model_importance(model, feature_names=None, importance_type='gain'):\n    importance_df = pd.DataFrame(model.feature_importance(importance_type=importance_type),\n                                 index=feature_names,\n                                 columns=['importance']).sort_values('importance')\n    return importance_df","d92df28f":"def calc_mean_importance(importance_df_list):\n    mean_importance = np.mean(\n        np.array([df['importance'].values for df in importance_df_list]), axis=0)\n    mean_df = importance_df_list[0].copy()\n    mean_df['importance'] = mean_importance\n    \n    return mean_df","6c4e7472":"# \u753b\u50cf\u4fdd\u5b58\u7528\nimport matplotlib.pyplot as plt\ndef plot_importance(importance_df, title='',\n                    save_filepath=None, figsize=(8, 12)):\n    fig, ax = plt.subplots(figsize=figsize)\n    importance_df.plot.barh(ax=ax)\n    if title:\n        plt.title(title)\n    plt.tight_layout()\n    if save_filepath is None:\n        plt.show()\n    else:\n        plt.savefig(save_filepath)\n    plt.close()","cac506e5":"# Read train and test\ntrain, test = read_train_test()\n\n# Get unique stock ids \ntrain_stock_ids = train['stock_id'].unique()\n# Preprocess them using Parallel and our single stock id functions\ntrain_ = preprocessor(train_stock_ids, is_train = True)\ntrain = train.merge(train_, on = ['row_id'], how = 'left')\n\n# Get unique stock ids \ntest_stock_ids = test['stock_id'].unique()\n# Preprocess them using Parallel and our single stock id functions\ntest_ = preprocessor(test_stock_ids, is_train = False)\ntest = test.merge(test_, on = ['row_id'], how = 'left')\n\n# Get group stats of time_id and stock_id\ntrain = get_time_stock(train)\ntest = get_time_stock(test)","9eb47858":"train.shape","45ef8320":"pd.to_pickle(train,'train(307)_notau_noKNN.pkl')","e0e84259":"train = pd.read_pickle('.\/train(307)_notau_noKNN.pkl')\ntrain.shape","8ce2596e":"seed = 29\nparams = {\n    'learning_rate': 0.1,        \n    'lambda_l1': 2,\n    'lambda_l2': 7,\n    'num_leaves': 800,\n    'min_sum_hessian_in_leaf': 20,\n    'feature_fraction': 0.8,\n    'feature_fraction_bynode': 0.8,\n    'bagging_fraction': 0.9,\n    'bagging_freq': 42,\n    'min_data_in_leaf': 700,\n    'max_depth': 4,\n    'seed': seed,\n    'feature_fraction_seed': seed,\n    'bagging_seed': seed,\n    'drop_seed': seed,\n    'data_random_seed': seed,\n    'objective': 'rmse',\n    'boosting': 'gbdt',\n    'verbosity': -1,\n    'n_jobs': -1,\n} ","e6f33225":"# # Split features and target\n# x = train.drop(['row_id', 'target', 'time_id'], axis = 1)\n# y = train['target']\n# #x_test = test.drop(['row_id', 'time_id'], axis = 1)\n# # Transform stock id to a numeric value\n# x['stock_id'] = x['stock_id'].astype(int)\n# #x_test['stock_id'] = x_test['stock_id'].astype(int)\n\n# # Create out of folds array\n# oof_predictions = np.zeros(x.shape[0])\n# # Create test array to store predictions\n# #test_predictions = np.zeros(x_test.shape[0])","8b9bb986":"# x.head()","adf210c4":"# gain_importance_list = []\n# split_importance_list = []\n# # Create a KFold object\n# kfold = KFold(n_splits = 5, random_state = 66, shuffle = True)\n# # Iterate through each fold\n# for fold, (trn_ind, val_ind) in enumerate(kfold.split(x)):\n#     print(f'Training fold {fold + 1}')\n#     x_train, x_val = x.iloc[trn_ind], x.iloc[val_ind]\n#     y_train, y_val = y.iloc[trn_ind], y.iloc[val_ind]\n#     # Root mean squared percentage error weights\n#     train_weights = 1 \/ np.square(y_train)\n#     val_weights = 1 \/ np.square(y_val)\n#     train_dataset = lgb.Dataset(x_train, y_train, weight = train_weights)\n#     val_dataset = lgb.Dataset(x_val, y_val, weight = val_weights)\n#     model = lgb.train(params = params, \n#                       train_set = train_dataset, \n#                       categorical_feature = ['stock_id'],\n#                       valid_sets = [train_dataset, val_dataset], \n#                       num_boost_round = 5000, \n#                       early_stopping_rounds = 30, \n#                       verbose_eval = 100,\n#                       feval = feval_rmspe)\n\n#     # \u3053\u306e\u66f8\u304d\u65b9\u3059\u308b\u3053\u3068\u3067\u3001\u5168\u30c7\u30fc\u30bf\u3092OOf\u306b\u3057\u3066rmspe\u304c\u6c42\u3081\u3089\u308c\u308b\u3001\n#     # \u899a\u3048\u3066\u304a\u3044\u305f\u65b9\u304c\u3044\u3044\n#     oof_predictions[val_ind] = model.predict(x_val)\n#     # Predict the test set\n#     #test_predictions += model.predict(x_test) \/ 5\n\n#     feature_names = x_train.columns.values.tolist()\n#     gain_importance_df = calc_model_importance(\n#         model, feature_names=feature_names, importance_type='gain')\n#     gain_importance_list.append(gain_importance_df)\n\n#     split_importance_df = calc_model_importance(\n#         model, feature_names=feature_names, importance_type='split')\n#     split_importance_list.append(split_importance_df)\n\n# rmspe_score = rmspe(y, oof_predictions)\n# print(f'Our out of folds RMSPE is {rmspe_score}')","63c5f946":"# mean_gain_df = calc_mean_importance(gain_importance_list)\n# mean_gain_df = mean_gain_df.reset_index().rename(columns={'index': 'feature_names'})\n# mean_gain_df.to_csv('gain_importance_mean kfold 306.csv', index=False)","90a29704":"# Split features and target\nx = train.drop(['row_id', 'target', 'time_id'], axis = 1)\ny = train['target']\nx_test = test.drop(['row_id', 'time_id'], axis = 1)\n# Transform stock id to a numeric value\nx['stock_id'] = x['stock_id'].astype(int)\nx_test['stock_id'] = x_test['stock_id'].astype(int)\n\n# Create out of folds array\noof_predictions = np.zeros(x.shape[0])\n# Create test array to store predictions\ntest_predictions = np.zeros(x_test.shape[0])","3a52ebcc":"oof = pd.DataFrame()                 # out-of-fold result\nmodels = []                          # models\nscores = 0.0                         # validation score\n\ngain_importance_list = []\nsplit_importance_list = []\n\nfrom sklearn.model_selection import GroupKFold\ngroup = train['time_id']\nkf = GroupKFold(n_splits=5)\n# Iterate through each fold\nfor fold, (trn_ind, val_ind) in enumerate(kf.split(x, groups=group)):\n    print(f'Training fold {fold + 1}')\n    x_train, x_val = x.iloc[trn_ind], x.iloc[val_ind]\n    y_train, y_val = y.iloc[trn_ind], y.iloc[val_ind]\n    # Root mean squared percentage error weights\n    train_weights = 1 \/ np.square(y_train)\n    val_weights = 1 \/ np.square(y_val)\n    train_dataset = lgb.Dataset(x_train, y_train, weight = train_weights)\n    val_dataset = lgb.Dataset(x_val, y_val, weight = val_weights)\n    model = lgb.train(params = params, \n                      train_set = train_dataset, \n                      categorical_feature = ['stock_id'],\n                      valid_sets = [train_dataset, val_dataset], \n                      num_boost_round = 5000, \n                      early_stopping_rounds = 30, \n                      verbose_eval = 100,\n                      feval = feval_rmspe)\n\n    # \u3053\u306e\u66f8\u304d\u65b9\u3059\u308b\u3053\u3068\u3067\u3001\u5168\u30c7\u30fc\u30bf\u3092OOf\u306b\u3057\u3066rmspe\u304c\u6c42\u3081\u3089\u308c\u308b\u3001\n    # \u899a\u3048\u3066\u304a\u3044\u305f\u65b9\u304c\u3044\u3044\n    oof_predictions[val_ind] = model.predict(x_val)\n    # Predict the test set\n    test_predictions += model.predict(x_test) \/ 5\n\n    feature_names = x_train.columns.values.tolist()\n    gain_importance_df = calc_model_importance(\n        model, feature_names=feature_names, importance_type='gain')\n    gain_importance_list.append(gain_importance_df)\n\n    split_importance_df = calc_model_importance(\n        model, feature_names=feature_names, importance_type='split')\n    split_importance_list.append(split_importance_df)\n\nrmspe_score = rmspe(y, oof_predictions)\nprint(f'Our out of folds RMSPE is {rmspe_score}')","53be734c":"test_predictions","048816d1":"mean_gain_df = calc_mean_importance(gain_importance_list)\nmean_gain_df = mean_gain_df.reset_index().rename(columns={'index': 'feature_names'})\nmean_gain_df.to_csv('gain_importance_mean groupkfold 306.csv', index=False)","79ea06eb":"test['target'] = test_predictions\ntest[['row_id', 'target']].to_csv('submission.csv',index = False)","64c69ffb":"test[['row_id', 'target']]","b993cddb":"#  \u8003\u5bdf\ngorupKold\u3092\u4f7f\u3046\u3053\u3068\u3067cv\u306f\u3055\u304c\u308b\u304c\u3001\u6848\u306e\u5b9aLB\u306b\u306f\u5927\u304d\u3044\u5909\u52d5\u306f\u306a\u304b\u3063\u305f  \n\u4e0a\u4f4d\u306e\u65b9\u306f\u3042\u307e\u308a\u6c17\u306b\u305b\u305aKflod\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u304c\u3001CV\u304c\u4f4e\u304f\u306a\u308b\u306e\u306f\u5f53\u7136\u3067\u3042\u308aLB\u306b\u5bfe\u3057\u3066\u3082\u30ea\u30fc\u30af\u304c\u767a\u751f\u3057\u3066\u3044\u308b\u305f\u3081\u30b9\u30b3\u30a2\u304c\u4f4e\u304f\u306a\u308b\u3068\u8003\u3048\u3089\u308c\u308b\u3002  \n\u5b9f\u969b\u306e\u30b3\u30f3\u30da\u306e\u8a55\u4fa1\u65b9\u6cd5\u304c\u66d6\u6627\u306e\u305f\u3081\u3001\u3069\u3061\u3089\u3092\u9078\u3076\u304b\u306f\u81ea\u5df1\u8cac\u4efb\u3068\u3044\u3063\u305f\u3068\u3053\u308d\u306a\u306e\u3060\u308d\u3046\u304b...  \n\u30ab\u30fc\u30cd\u30eb\u3092\u898b\u308b\u3068\u7d50\u69cb\u610f\u898b\u304c\u5225\u308c\u3066\u3044\u308b\u306e\u3067\u3001\u6c17\u306b\u306a\u308b\u3068\u3053\u308d","efadcfa2":"## groupKfold","7fda5f39":"# \u30d9\u30fc\u30b9\u30e9\u30a4\u30f3\n\n\u304b\u306a\u308a\u7d30\u304b\u3044\u3068\u3053\u308d\u306b\u306a\u308b\u306e\u3067\u3001\u3067\u304d\u308c\u3070\u6bce\u56de\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u3059\u308b\u3079\u304d\u306a\u3093\u3060\u3051\u308c\u3069\u3082\u4e00\u56de\u7f6e\u3044\u3066\u304a\u304f\u3002","6c736eb4":"# \u901a\u5e38\n\ntime_id\u3092\u843d\u3068\u3057\u3066\u691c\u8a3c  \ntime_id\u306e\u6307\u6a19\u306f\u751f\u304d\u3066\u308b","9ca28168":"# group_kfold\u306b\u3064\u3044\u3066\n## \u76ee\u7684\ntime_id\u306e\u7d71\u8a08\u6307\u6a19\u3092\u7528\u3044\u3066\u3044\u308b\u305f\u3081\u3001time_ID\u6bce\u306b\u3057\u306a\u3044\u3068\u30ea\u30fc\u30af\u304c\u767a\u751f\u3057\u3066\u3044\u308b\u53ef\u80fd\u6027\u304c\u9ad8\u3044  \n\u3082\u3057CV\u304c\u4f4e\u304f\u3001LB\u304c\u9ad8\u3044\u5834\u5408\u53ef\u80fd\u6027\u306f\u9ad8\u3044\u3002  \n\u904e\u9069\u5408\u3055\u305b\u305f\u304f\u306a\u3044\u306e\u3067\u3069\u306e\u7a0b\u5ea6\u306e\u5f71\u97ff\u304b\u63a2\u308b\n\n## \u8ffd\u52a0\nstock_ID\u306e\u7d71\u8a08\u6307\u6a19\u3082\u6c42\u3081\u3066\u3044\u308b\u304c\u3001\u3053\u308c\u304c\u30ea\u30fc\u30af\u306b\u306a\u308b\u304b\u306f\u304b\u306a\u308a\u30b0\u30ec\u30fc  \nstock_ID\u81ea\u4f53\u306f\u672a\u6765\u306e\u60c5\u5831\u3092\u542b\u3080\u304c\u3001\u9298\u67c4\u4e8b\u306b\u7279\u5fb4\u304c\u3042\u308b\u306e\u306f\u306a\u3093\u3089\u9593\u9055\u3044\u3067\u306f\u306a\u3044\u3057\u3001\u305d\u3082\u305d\u3082\u30c7\u30fc\u30bf\u304c\u306a\u3044\u306e\u3067\u305d\u3046\u3059\u308b\u3057\u304b\u306a\u3044\u3002\n\n### \u4f7f\u7528\u3059\u308b\u7279\u5fb4\u91cf\n- tau\u306f\u306a\u3057\n- \u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u6307\u6a19\u306a\u3057\n","cf915a00":"cv : 0.20000  \nLB : 0.20991\nimportance\u3092\u307f\u308b\u3068\u3001\u304b\u306a\u308a\u4e0a\u306e\u65b9\u3067time_id\u306e\u6307\u6a19\u304c\u6765\u3066\u3044\u308b","f2e5948d":"# \u81ea\u4f5c\u30ab\u30fc\u30cd\u30eb\n\u78ba\u304b\u3081\u305f\u3044\u3053\u3068\n- groupk_fold\u306e\u52b9\u679c\n- \u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u6307\u8a55\u306e\u52b9\u679c\n- \u9069\u5207\u306a\u79d2\u6570\u533a\u5207\u308a(\u304a\u305d\u3089\u304f150.300.450)\n- \u7279\u5fb4\u91cf\u306esum. mean, std\u3042\u305f\u308a\u306e\u3044\u3089\u306a\u3044\u6307\u6a19\u306e\u524a\u6e1b","e9f76ba4":"CV : 0.2253  \nLB : 0.21227\n\n\u666e\u901a\u306eKflod\u306b\u5bfe\u3057\u3066\u306f\u7cbe\u5ea6\u304b\u306a\u308a\u60aa\u304f\u306a\u3063\u305f\u3002  \ntime_id\u6bce\u306e\u7d71\u8a08\u91cf\u4ee5\u5916\u4f55\u3082\u5909\u3048\u3066\u306a\u3044\u306e\u3067\u307e\u3041\u3053\u3046\u306a\u308b\u3088\u306d\u3063\u3066\u3044\u3046\u70b9\u6570"}}