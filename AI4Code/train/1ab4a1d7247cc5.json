{"cell_type":{"d4eda70d":"code","986f15c6":"code","7361065a":"code","d90be4aa":"code","6bf09d61":"code","d9cbd143":"code","dd3b64c4":"code","5dd42f16":"code","973ae4a4":"code","fb813610":"code","d47ec5d0":"code","442a6e31":"code","a93db503":"code","fc5f9ec4":"code","12cbca8d":"code","2e4a3dd8":"code","893b622c":"code","4caf80f6":"code","0248223e":"code","ecf1c8c1":"code","ae34c9bf":"code","3a56098d":"code","a2dabb9a":"code","97d9dd2d":"code","70d7c1b6":"code","53564285":"code","ac021190":"code","8d0768c5":"code","dca5f1f2":"code","07ee5edb":"code","4fd94e6f":"code","8d99f879":"code","880d2306":"code","cd1d1bb4":"code","726d927c":"code","c0db66d0":"code","1c1924b8":"code","02a09a78":"code","0ecd7dc8":"code","98fddfdd":"markdown","105c316f":"markdown","5b398170":"markdown","dc8f9590":"markdown","4028035b":"markdown","e186de5f":"markdown","9cd79053":"markdown","4131a4e0":"markdown","bf62ca8a":"markdown","e3365524":"markdown","5f5fcb5c":"markdown","14f2519e":"markdown","0ea2d8d4":"markdown","b4e53d55":"markdown","231ca6dc":"markdown","cf1cce41":"markdown","d1382a1c":"markdown","0157e278":"markdown","ab5ad145":"markdown","3c29943b":"markdown","560f1a8d":"markdown","4f08686a":"markdown","93feae4c":"markdown","83d38bc9":"markdown","58ce36a4":"markdown","c6a7abb7":"markdown","ef9aaeb7":"markdown","e4c59334":"markdown","e83d2d2c":"markdown","f05e7f21":"markdown","cb09c7e1":"markdown","e11b6137":"markdown","1a77e100":"markdown","256c37da":"markdown","ba213fc0":"markdown","f305366a":"markdown","45e2382c":"markdown","5887cf9b":"markdown","ec24437d":"markdown","2feb6b46":"markdown","924815d8":"markdown","73cf033b":"markdown","a0b78b79":"markdown","34368f68":"markdown","46f46d3b":"markdown","bab01f75":"markdown","e1aeb2ec":"markdown","98069d30":"markdown","74cdf61b":"markdown","69e38e3b":"markdown","b0171224":"markdown","c362fdca":"markdown","5277fc27":"markdown"},"source":{"d4eda70d":"from IPython.display import IFrame, YouTubeVideo\nYouTubeVideo('dIpoDkv4GHE',width=600, height=400)","986f15c6":"pip install h5py","7361065a":"pip install nilearn","d90be4aa":"pip install plotly","6bf09d61":"pip install joypy","d9cbd143":"#essentials\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport statistics as s \n\n#special libraries\nfrom nilearn import plotting, image \nimport nilearn as nl\nimport nibabel as nb\nimport h5py\nimport plotly.graph_objs as go\nfrom IPython.display import Image, display","dd3b64c4":"df_icn = pd.read_csv('\/kaggle\/input\/trends-assessment-prediction\/ICN_numbers.csv')\ndf_fnc = pd.read_csv('\/kaggle\/input\/trends-assessment-prediction\/fnc.csv')\ndf_loading = pd.read_csv('\/kaggle\/input\/trends-assessment-prediction\/loading.csv')\ndf_reveal = pd.read_csv('\/kaggle\/input\/trends-assessment-prediction\/reveal_ID_site2.csv')\ndf_sample = pd.read_csv('\/kaggle\/input\/trends-assessment-prediction\/sample_submission.csv')\ndf_train = pd.read_csv('\/kaggle\/input\/trends-assessment-prediction\/train_scores.csv')","5dd42f16":"brain_mask = nb.load('\/kaggle\/input\/trends-assessment-prediction\/fMRI_mask.nii')\nplotting.plot_roi(brain_mask, title='fMRI_mask.nii');","973ae4a4":"test_mat1 = h5py.File('\/kaggle\/input\/trends-assessment-prediction\/fMRI_train\/10001.mat', mode='r')\ntest_mat1 = np.array(test_mat1.get('SM_feature'))\n\n## Let's also load a second participant\ntest_mat2 = h5py.File('\/kaggle\/input\/trends-assessment-prediction\/fMRI_train\/10002.mat', mode='r')\ntest_mat2 = np.array(test_mat2.get('SM_feature'))","fb813610":"#get all fnc unique values ()\nfnc_names = pd.Series(df_fnc.columns)\nfnc_names = fnc_names.drop(0)\nfnc_names = fnc_names.str.split(\"_\", n = 1, expand = True) \nfnc_names[1] = fnc_names[1].str.slice(3,11,1)\nfnc_names = fnc_names[0].append(fnc_names[1])\nfnc_names = fnc_names.unique()\nfnc_names = pd.Series(fnc_names)\nfnc_names = fnc_names.sort_values().reset_index(drop = True)","d47ec5d0":"# Network index:\nntwk_idx = {}\nnetwork_names = np.unique([i[:3] for i in fnc_names])\nfor ii in network_names:\n    ntwk_idx[ii] = np.unique([np.int(i.split('(')[-1].split(')')[0]) for i in fnc_names if ii in i])\n    \n# Look up matrix index\nicn_number = pd.read_csv('\/kaggle\/input\/trends-assessment-prediction\/ICN_numbers.csv')\nicn_idx = {}\n\nfor jj in ntwk_idx.keys():\n    icn_idx[jj] = np.array(icn_number.index[icn_number.ICN_number.isin(ntwk_idx[jj])])\n    \ndef map_for_plotting(mat, brain_mask):\n    # Assuming that we provide a 3D image\n    # image.new_img_like creates a nifti by applying informaiton from the soure image (here brain_mask),\n    # like the affine to a matrix.\n    return image.new_img_like(brain_mask, mat.transpose([2, 1, 0]))\n    \n# Let's extract the indices for the different average networks\nsample_maps1 = {}\nsample_maps2 = {}\nfor ii in icn_idx.keys():\n    # indices -1 because matlab\n    sample_maps1[ii] = map_for_plotting(test_mat1[icn_idx[ii] -1].mean(0), brain_mask)\n    sample_maps2[ii] = map_for_plotting(test_mat2[icn_idx[ii] -1].mean(0), brain_mask)","442a6e31":"fig, axes = plt.subplots(len(sample_maps1), 2, figsize=(20, 10))\n\nfor n, ii in enumerate(sample_maps1.keys()):\n    # We are plotting glass brains here - a nice way to visualize brain maps\n    plotting.plot_glass_brain(sample_maps1[ii], title=ii, axes=axes[n, 0], plot_abs=False)\n    plotting.plot_glass_brain(sample_maps2[ii], title=ii, axes=axes[n, 1], plot_abs=False)\naxes[0, 0].set_title('Networks for Participant 1');\naxes[0, 1].set_title('Networks for Participant 2');","a93db503":"print(df_loading.shape)\ndf_loading.head(10)","fc5f9ec4":"import joypy\n\ntargets = df_loading.columns[1:]\n\n#plot\nplt.figure(figsize=(16,10), dpi= 150)\nfig, axes = joypy.joyplot(df_loading, column=list(targets), ylim='own', figsize=(14,10))","12cbca8d":"print(df_fnc.shape)\ndf_fnc.head(10)","2e4a3dd8":"def corr_of_subject(Id):\n    \n    #get all fnc unique values ()\n    x = pd.Series(df_fnc.columns)\n    x = x.drop(0)\n    x = x.str.split(\"_\", n = 1, expand = True) \n    x[1] = x[1].str.slice(3,11,1)\n    x = x[0].append(x[1])\n    x = x.unique()\n    x = pd.Series(x)\n    x = x.sort_values().reset_index(drop = True)\n    \n    #create empty correlation matrix\n    df_corr = pd.DataFrame(np.zeros((53, 53)), columns = x, index = x)\n    \n    #fill in the correlation matrix\n    for i in x: \n        for j in x:\n            #define columns and index to pull from df_fnc\n            col_from_fnc1 = str(str(i) + '_vs_' + str(j))\n            col_from_fnc2 = str(str(j) + '_vs_' + str(i))\n            index = df_fnc.index[df_fnc['Id'] == Id]\n            \n            #assign the correct value\n            if col_from_fnc1 in df_fnc.columns:\n                df_corr.at[str(i),str(j)] = df_fnc.loc[index, col_from_fnc1]\n            elif col_from_fnc2 in df_fnc.columns: \n                df_corr.at[str(i),str(j)] = df_fnc.loc[index, col_from_fnc2]\n            else:\n                df_corr.at[str(i),str(j)] = 1\n    return(df_corr)","893b622c":"#plot settings\nsns.set(font_scale=.75)\nplt.figure(figsize = (18,15))\n\nax = sns.heatmap(corr_of_subject(10001), vmin = -1, cmap = 'RdYlBu', fmt='.2f', square = True, linewidths = .6)\n","4caf80f6":"#create average of df_fnc, takes quite awhile though, must be inefficent \ndf_fnc_avg = pd.DataFrame(np.zeros((1, 1379)), columns = df_fnc.columns.values)\nfor i in range(1379): \n    df_fnc_avg.iloc[0, i] = df_fnc.mean()[i]\ndf_fnc_avg","0248223e":"#same code as before but just reference to the df_fnc_avg instead\ndef avg_corr_of_subject():\n    \n    #get all fnc unique values ()\n    x = pd.Series(df_fnc.columns)\n    x = x.drop(0)\n    x = x.str.split(\"_\", n = 1, expand = True) \n    x[1] = x[1].str.slice(3,11,1)\n    x = x[0].append(x[1])\n    x = x.unique()\n    x = pd.Series(x)\n    x = x.sort_values().reset_index(drop = True)\n\n    #create empty correlation matrix\n    df_corr_avg = pd.DataFrame(np.zeros((53, 53)), columns = x, index = x)\n    \n    #fill in the correlation matrix\n    for i in x: \n        for j in x:\n            #define columns and index to pull from df_fnc\n            col_from_fnc1 = str(str(i) + '_vs_' + str(j))\n            col_from_fnc2 = str(str(j) + '_vs_' + str(i))\n            index = 0\n            \n            #assign the correct value\n            if col_from_fnc1 in df_fnc_avg.columns:\n                df_corr_avg.at[str(i),str(j)] = df_fnc_avg.loc[index, col_from_fnc1]\n            elif col_from_fnc2 in df_fnc_avg.columns: \n                df_corr_avg.at[str(i),str(j)] = df_fnc_avg.loc[index, col_from_fnc2]\n            else:\n                df_corr_avg.at[str(i),str(j)] = 1\n    return(df_corr_avg)","ecf1c8c1":"#plot settings\nsns.set(font_scale=.75)\nplt.figure(figsize = (18,15))\n\nax_avg = sns.heatmap(avg_corr_of_subject(), vmin = -1, cmap = 'RdYlBu', fmt='.2f', square = True, linewidths = .6)","ae34c9bf":"#plot settings\nfig, (ax, ax_avg) = plt.subplots(1,2,figsize=(18,8))\nfig.subplots_adjust(hspace=0.4, wspace=0.7)\n\nsns.heatmap(corr_of_subject(10001), vmin = -1, cmap = 'RdYlBu', fmt='.2f', square = True, linewidths = .6, ax = ax)\nsns.heatmap(avg_corr_of_subject(), vmin = -1, cmap = 'RdYlBu', fmt='.2f', square = True, linewidths = .6, ax = ax_avg)","3a56098d":"print(df_train.shape)\ndf_train.head(10)","a2dabb9a":"#plot settings\nsns.set(style = 'darkgrid')\nplt.figure(figsize = (10, 10))\n\n#plot pairwise graphs\nax = sns.PairGrid(df_train, vars=['age', 'domain1_var1', 'domain1_var2', 'domain2_var1', 'domain2_var2'])\nax.map_upper(sns.scatterplot, s = 15, color = 'm', marker = '+',)\nax.map_lower(sns.kdeplot, color = 'm')\nax.map_diag(sns.kdeplot, color = 'm', lw=3, legend=False)","97d9dd2d":"df_fnc.info()","70d7c1b6":"df_loading.info()","53564285":"df_train.info()","ac021190":"#imputer, outputs 2d array\nfrom sklearn.impute import KNNImputer\n\n#separate Id column and attributes\ndf_train2 = df_train[['age', 'domain1_var1', 'domain1_var2', 'domain2_var1', 'domain2_var2']]\n\n#impute\nimputer = KNNImputer(n_neighbors = 3, weights=\"uniform\")\ndf_train2 = imputer.fit_transform(df_train2)\n\n#convert the 2d array back to the dataframe\ndf_train2 = pd.DataFrame(df_train2, columns = ['age', 'domain1_var1', 'domain1_var2', 'domain2_var1', 'domain2_var2'])\ndf_train2 = pd.concat([df_train['Id'], df_train2], axis =1)\n\n# %% [code]\ndf_train2.info()","8d0768c5":"df_combine = df_loading.join(df_train.set_index('Id'), on = 'Id')\ndf_combine = df_combine.dropna()","dca5f1f2":"#only ic train\nX = df_combine.iloc[:,0:27].round(4)\nX2 = X.drop(columns = ['Id'])\n\ny = df_combine.iloc[:, -5:].round(4)\ny_age = df_combine.iloc[:,-5].round(4)\ny_1_1 = df_combine.iloc[:,-4].round(4)\ny_1_2 = df_combine.iloc[:,-3].round(4)\ny_2_1 = df_combine.iloc[:,-2].round(4)\ny_2_2 = df_combine.iloc[:,-1].round(4)","07ee5edb":"from sklearn.preprocessing import StandardScaler\n\n#run the scale\nscaler = StandardScaler()\nX_std_np = scaler.fit_transform(X2)","4fd94e6f":"X_std = pd.DataFrame(X_std_np, columns = X2.columns.values)","8d99f879":"import matplotlib.pyplot as plt\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.feature_selection import RFECV\n\n# Create the RFE object and compute a cross-validated score.\nmodel = LinearRegression()\nrfecv = RFECV(estimator=model, step=1, cv=3, scoring='neg_mean_absolute_error')\nrfecv.fit(X_std, y_age)\n\nprint(\"Optimal number of features : %d\" % rfecv.n_features_)\n\n#Plot number of features VS. cross-validation score\nsns.set(style = 'darkgrid')\n\nplt.figure()\nplt.xlabel(\"Number of features selected\")\nplt.ylabel(\"Cross validation score (neg_mean_absolute_error)\")\nplt.plot(range(1, len(rfecv.grid_scores_) + 1), rfecv.grid_scores_)\nplt.show()","880d2306":"from sklearn.model_selection import cross_val_score\nfrom sklearn.linear_model import LinearRegression\n\nmodel = LinearRegression()\ncross_val = cross_val_score(model, X_std, y_age, cv = 3, scoring = 'neg_mean_absolute_error')\ncross_val_avg = s.mean(cross_val)\n\nperformance = str(round(cross_val_avg,5)) + ' +\/- ' + str(round((cross_val.max()-cross_val_avg),5))\nperformance","cd1d1bb4":"from sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\n\n#specify targets and weight for scoring\ntargets = [y_age, y_1_1, y_1_2, y_2_1, y_2_2]\nweights = [.3, .175, .175, .175, .175]\n\nscores_storage = []\n\nfor i in targets:\n    #split the data\n    X_train, X_test, y_train, y_test = train_test_split(X_std, i, test_size=0.66, random_state=0)\n    \n    #run the model\n    model = LinearRegression()\n    model.fit(X_train, y_train)\n    y_pred = model.predict(X_test)\n\n    #get scores of each target\n    unweighted_score = (abs(y_test-y_pred)).sum()\/y_pred.sum()\n    scores_storage.append(unweighted_score)\n\n#multiple scores with weights and sum for final score\ngrand_score = [scores_storage[i] * weights[i] for i in range(len(scores_storage))]\nsum(grand_score)","726d927c":"#get the ID's of the submission\ndf_sub_id = df_sample.copy()\n\ndf_sub_id['Id'] = df_sub_id['Id'].str.slice(0,5,1)\ndf_sub_id = df_sub_id['Id'].unique()\n\ndf_sub_id = pd.DataFrame({'Id' : df_sub_id , 'hold' : np.zeros(len(df_sub_id))})\ndf_sub_id['Id'] = df_sub_id['Id'].astype(int)","c0db66d0":"#create the featuresdataframe \ndf_sub_combine = df_loading.join(df_sub_id.set_index('Id'), on = 'Id')\ndf_sub_combine = df_sub_combine.dropna()\n\n#create the features only dataframe \ndf_sub_test = df_sub_combine.drop(columns = ['Id', 'hold'])","1c1924b8":"from sklearn.preprocessing import StandardScaler\n\n#run the scale\nscaler = StandardScaler()\ndf_sub_test_pp = scaler.fit_transform(df_sub_test)\n\n#put back into dataframe structure\ndf_sub_test_pp = pd.DataFrame(df_sub_test_pp, columns = df_sub_test.columns.values)","02a09a78":"targets = [y_age, y_1_1, y_1_2, y_2_1, y_2_2]\ntargets_names = ['y_age', 'domain1_var1', 'domain1_var2', 'domain2_var1', 'domain2_var2']\nint_index = [0, 1, 2, 3, 4]\n\n#create empty submission dataframe\nsubmission = pd.DataFrame()\n\n#create submission \nfor i in int_index:\n    #for i in targets:\n    #split the data of the training set\n    X_train, X_test, y_train, y_test = train_test_split(X_std, targets[i], test_size=0.66, random_state=0)\n    \n    #train the model on the training set\n    model = LinearRegression()\n    model.fit(X_train, y_train)\n\n    #predict \n    y_pred = model.predict(df_sub_test_pp)\n    \n    #add predictions by column\n    submission[targets_names[i]] = y_pred\n    \nsubmission","0ecd7dc8":"#turn dataframe prediction values into one long series\npredicted = pd.Series([], dtype = 'float')\nfor i in range(submission.shape[0]):\n    row_values = pd.Series(submission.iloc[i].values)\n    predicted = predicted.append(row_values, ignore_index= True)\n\n#add the series to the submission file\ndf_submission_linear = df_sample.copy()\ndf_submission_linear['Predicted'] = predicted\ndf_submission_linear.to_csv('submission_linear.csv', index = False)\ndf_submission_linear","98fddfdd":"Lets load the csv files","105c316f":"The `df_train.csv` file contains the attributes we are attempting to predict. A training set were the attributes are known correpsonding to each patient ID is given. We need to predict the other half of the located in `sample_submission.csv`.","5b398170":"Now, we will state the dependent and independant variables. X being all the column values except for age, domain1_var1 and etc. And the y's will be age, domain1_var1, and etc.","dc8f9590":"Every brain is different in terms of size and location of each functional network. Also there are slight variations during each fMRI scan due to head movement, and other variations. So inorder, to standardize the data, an fMRI mask is obtained below. ","4028035b":"We have 26 features available. We can see if we need all them in our model using recursive feature elimination. This test outputs the change in performance as we vary the number of features used.","e186de5f":"# Preprocessing <a id = 'preprocessing'><\/a>","9cd79053":"# Exploratory Data Analysis <a id = 'eda'><\/a>","4131a4e0":"### Other Kaggle Notebooks\n\nFrom Rohit Singh, great for just starting out\n- https:\/\/www.kaggle.com\/rohitsingh9990\/trends-eda-visualization-simple-baseline\n\nFrom srs, great for explaining the project as a whole, contains indepth domain knowledge\n- https:\/\/www.kaggle.com\/srsteinkamp\/trends-eda\n\nFrom Ahmet Erdem, great modelling \nhttps:\/\/www.kaggle.com\/aerdem4\/rapids-svm-on-trends-neuroimaging","bf62ca8a":"# Table of Contents\n1. [Objective](#objective)\n2. [Introduction](#intro)\n3. [The Dataset](#data)\n4. [Import Data and Libraries](#lib)\n5. [Exploratory Data Analysis](#eda)\n6. [Preprocessing](#preprocessing)\n7. [Model](#model)\n8. [References](#ref)","e3365524":"Now import all the essentials and the installed python libraries. ","5f5fcb5c":"# References  <a id = 'ref'><\/a>","14f2519e":"### CSV Files","0ea2d8d4":"Let's put the correlation graphs side by side.","b4e53d55":"### fMRI Visuals","231ca6dc":"Interesting. We can see that for this participant, that the FNCs tend to be more correlated along the diagonal. That makes sense since those areas of the brain are more part of the larger subgroup such as ADN. Perhaps we can use this knowledge in our preprocessing and feature selection. \n\nWe can also get an average of all the participants in the dataset.","cf1cce41":"We can see the distribution of the dataset below.","d1382a1c":"Let's take a look at the correlation and distribution of the dependent variables.","0157e278":"### Introduction to fMRI Video","ab5ad145":"![unnamed_resized.jpg](attachment:unnamed_resized.jpg)","3c29943b":"Lets check for missing values and impute them using sklearn's KNNImputer.\n","560f1a8d":"# Model <a id = 'model'><\/a>","4f08686a":"The code below is obtained from 'srs', another Kaggler, from the notebook:\n\nhttps:\/\/www.kaggle.com\/srsteinkamp\/trends-eda\n","93feae4c":"We start with an initial model for now and see what our score. After running the model several times with varying number of folds, I find that the performance is best at 3. If we increase it, we will be using more of the dataset for training our model, overfitting it, thus reducing the performance. ","83d38bc9":"Blood cells contains hemoglobin, which contains iron, a molecular structure that can bind oxygen. When the blood cells become oxygenated, (oxygen bonded to the iron) they are less susceptible to a magnetic field (not magnetic). However, when blood flows over the neurons and is consumed, the blood cells become deoxygenated, becoming much more susceptible to a magnetic field. \n\nAn fMRI is able to detect these regional changes in oxygenation and deoxygenation of hemoglobin, pinpointing areas of increased activity in the brain. \n\nThe brain is mapped out to several components that typically is associated with a specific control, such as processing visual stimuli, the Visual Network. These areas are called the functional networks and are illustrated below.\n","58ce36a4":"# Objective <a id = 'objectve'><\/a>","c6a7abb7":"# Submission","ef9aaeb7":"We can also plot each participants fMRI scan grouped by the functional networks.","e4c59334":"The following three are the main csv data files. \n\n- `fnc.csv` as df_fnc\n- `loading.csv` as df_loading\n- `train_scores.csv` as df_train","e83d2d2c":"The first set of features, located in the file `loading.csv`, are the source-based morphometry (SGM) loading values of each Independent Component (IC) of the brain from the fMRI scans. I am not a neuroscientist, but I believe the BOLD signals are acquired from the fMRI scan and an algorithm separates the data into these independent components, see 'Independent Components' section under References.\n\nThe second set of features, located in the file `fnc.csv`, are the correlation values between each predefined functional network of the brain. There are 53 networks, these networks fall into an umbrella group such as the visual network or auditory network. Each of the networks have a correlation value which was obtained from a General Linear Model. \n\nThe third set of features, located in the `fMRI_train` .mat files, are essentially the visualizations of FNC values (before correlation) projected onto a base template of brain. Since the .mat files are derived from the FNC values, we should only use one or the other to avoid collinearity in our models.\n\n### Main Data Files\n- `fnc.csv` - static FNC correlation features for both train and test samples\n- `loading.csv` - sMRI SBM loadings for both train and test samples\n- `train_scores.csv` - age and assessment values for train samples\n\n### Visual fMRI Results\n- `fMRI_train` - a folder containing 53 3D spatial maps for each participant in .mat format\n- `fMRI_test` - a folder containing 53 3D spatial maps for each participant in .mat format\n- `fMRI_mask.nii` - a 3D binary spatial map\n\n### Misc\n- `ICN_numbers.txt` - intrinsic connectivity network numbers for each fMRI spatial map; matches FNC names\n- `reveal_ID_site2.csv` - a list of subject IDs whose data was collected with a different scanner \n\n### Submission\n- `sample_submission.csv` - a sample submission file in the correct format\n\n\nThe `.mat` files for this competition can be read in python using `h5py`, and the `.nii` file can be read in python using `nilearn`.","f05e7f21":"This notebook will concentrate on explaining the project, visualizations, insights, and an initial model. An in-depth analysis of the model building process will be contained in subsequent notebooks.","cb09c7e1":"Lets see our score.","e11b6137":"\nfMRI (General Info)\n- https:\/\/en.wikipedia.org\/wiki\/Functional_magnetic_resonance_imaging\n- https:\/\/www.ncbi.nlm.nih.gov\/pmc\/articles\/PMC3073717\/\n- https:\/\/www.ncbi.nlm.nih.gov\/pmc\/articles\/PMC2731480\/\n \nResting State fMRI (fMRI with no visual stimulus)\n- https:\/\/en.wikipedia.org\/wiki\/Resting_state_fMRI#Functional\n \nDefault Mode Network (Connections in the Brain)\n- https:\/\/en.wikipedia.org\/wiki\/Default_mode_network\n \nIndepedent Components\n- https:\/\/www.ncbi.nlm.nih.gov\/pmc\/articles\/PMC2925426\/\n\nFNC - Zero vs First order FNC variation (Changes in correlation of FNC over time vs averages)\n- https:\/\/www.frontiersin.org\/articles\/10.3389\/fnins.2019.00634\/full\n ","1a77e100":"Since the FNC, loading, and train scores have ID's we can merge them into 1 table. This new dataframe will be our modelling set. We will only use the `loading.csv` file for now in our model.","256c37da":"If we are going to solve this problem, we must first understand what fMRI's are and how they work. Please look at the References section for more information.\n\nFunction Magnetic Resonance Imaging (fMRI) is a non-invasive relatively new technology that can map out the interconnectivity of the human brain. \n\nThis imaging technology works by taking advantage of the Blood Oxygenated Level Dependent hemodynamic (BOLD HDR) response of the human brain. The cells in our body work by taking in glucose. The more the cells work, the more glucose it needs. The muscles in our body have a readily available storage located in the muscles themselves. However, our brains do not, and have to compensate this by increasing the blood flow over the neurons during times of increase usage. This is illustrated below by the BOLD response.\n","ba213fc0":"Replicate the model from the Model section. ","f305366a":"Before we can look at our dataset, we need to install and import the necessary libraries for this project.\n\n`h5py` and `nilearn` will be needed to read the fMRI scans. We will also use `plotly` for added flexibility in our EDA.","45e2382c":"Sample preprocessing step as before.","5887cf9b":"# The Dataset <a id = 'data'><\/a>","ec24437d":"Okay now we create submission file.","2feb6b46":"# Import Data and Libraries <a id = 'lib'><\/a>","924815d8":"We should also standardize the X dataframe so that less important variables are given less weight.\n","73cf033b":"# Introduction <a id = 'intro'><\/a>","a0b78b79":"The data is of the resting state where the participant is not exposed to any stimuli. They just lay in the fMRI machine and are told to stay still and close their eyes. An fMRI measures obtains slices of the brain in voxels. That is a 3D cube and each cube is assigned a value depending on the BOLD response. There is also a 4th dimension, time. Values change over time, so a sum and average are obtained for each voxel, also each IC of the brain. A correlation between each IC is also obtained.","34368f68":"Let's visualize the correlation of an individual participant. We already have the correlation values in the fnc file. We just need to extract the values into a correlation matrix.","46f46d3b":"It looks like we have mostly a normal distribution in each variable. The density plots show no clusters. However, the plots of domain2_var1 vs domain2_var2 are quite interesting, there are what appears to be streaks running diagonal from bottom left to top right. They seem to be slightly correlated.","bab01f75":"The `df_loading.csv` file contains all the values of each part of the brain, Independent Components (ICs) during the fMRI scan. ","e1aeb2ec":"There are some missing values in the domain columns. Let's impute them.\n","98069d30":"Brain activity is complex, not one area is associated with one function, instead many of these sections are correlated with one another. By understanding these patterns across the brain, we can predict many states and qualities of a person such as psychological disorders, depression, IQ, and even age. This is the scope of our project: to predict the mental qualities of a participant given fMRI results. ","74cdf61b":"The goal of this research project is to predict the age and several other unlabeled variables of a participant, given the 3D fMRI scans, the FNC (functional network connectivity) matrices, and the SBM (source-based morphometry) loading values from resting state fMRI scans. \n\nVariables to Predict\n* `age`\n* `domain1_var1`\n* `domain1_var2`\n* `domain2_var1`\n* `domain2_var2`","69e38e3b":"The `fnc.csv` file shows the correlation between each functional network connection (FNC).","b0171224":"![HDR.png](attachment:HDR.png)\n","c362fdca":"The ICs are made up of a larger sub groups and are shown in the figure with the groups being:\n\n- DMN - Default Mode Network\n- SMN - Sensorimotor Network\n- VSN - Visual Network\n- CON - Cognitive Network\n- ADN - Auditory Network\n- CBN - Cerebellar Network\n- SCN - Sub-cortical Network\n","5277fc27":"Interesting. So, the looking at the average graph (to the right), the FNC correlations tend to be less correlated the farther it is from the diagonal. That is, FNC subunits are more correlated under the same FNC group. For example, ADN21 and ADN 56 are more correlated with each other than ADN21 to VSN(93)."}}