{"cell_type":{"8c7b0cee":"code","340e1fe5":"code","1d95f37c":"code","b3ae8ecf":"code","35d3fe8b":"code","58fab291":"code","63e787d6":"code","c4a4d8be":"code","add4255b":"code","9cfcfd33":"code","bed68650":"code","88c56343":"code","b372de22":"code","798637d3":"code","3c02fc13":"code","071a3865":"code","9fd76916":"code","556b210e":"code","c8269a11":"code","e6adc333":"code","c9f10316":"code","dfd2d191":"code","a052359a":"code","f702bcf4":"code","dcdc8c77":"code","b93d420b":"code","8bae27d5":"code","7254d794":"code","684ed724":"code","bcff0c7f":"code","fcd27c86":"code","6cc1d8a4":"code","22052879":"code","2ecf7f8a":"code","654413f9":"code","8e0335c6":"code","49db3ae3":"code","e2f49732":"code","29ae0b0e":"code","10474968":"code","2d4c653f":"code","6064b5a2":"code","c0e2e994":"code","a73825df":"code","fd545d4c":"code","ef375d3d":"code","a2cb1747":"code","1f530eb4":"markdown","9ee69941":"markdown","f843f625":"markdown","58990e85":"markdown","1b3456ad":"markdown","aab85af9":"markdown","5a44d523":"markdown","414e5de5":"markdown","aab54a74":"markdown","f005ddd4":"markdown","44a963e6":"markdown","343001d4":"markdown","2cf00e33":"markdown","b7ffcba2":"markdown","d7acde91":"markdown","0d2e56b4":"markdown","f287b0e5":"markdown","c9cd4bd7":"markdown","616082b4":"markdown","95fb55ea":"markdown"},"source":{"8c7b0cee":"import pandas as pd\nimport numpy as np\n\n\"..\/input\/\"\nX_full = pd.read_csv(\"..\/input\/learn-together\/train.csv\", \n                index_col=0)\ntest = pd.read_csv(\"..\/input\/learn-together\/test.csv\", \n                   index_col=0)\n\nTARGET = 'Cover_Type'\n#X_full[TARGET] = X_full[TARGET].transform(str)\nX = X_full.copy()\ny = X_full[TARGET]","340e1fe5":"print(X.shape)\nX.head()","1d95f37c":"y.value_counts()","b3ae8ecf":"X.dtypes","35d3fe8b":"X.describe()","58fab291":"X.isna().sum().sum()","63e787d6":"import seaborn as sns\nimport matplotlib.pyplot as plt\n\nX['Euclidean_distance_to_hydro'] = (X.Vertical_Distance_To_Hydrology**2 + X.Horizontal_Distance_To_Hydrology**2)**.5\n\nf, axes = plt.subplots(1, 3, figsize=(15, 5), sharex=True, sharey=True)\n\nsns.distplot(X.Horizontal_Distance_To_Hydrology, color=\"b\", ax=axes[0])\nsns.distplot(X.Vertical_Distance_To_Hydrology, color=\"b\", ax=axes[1])\nsns.distplot(X['Euclidean_distance_to_hydro'], color=\"g\", ax=axes[2])\n","c4a4d8be":"def euclidean(df):\n    df['Euclidean_distance_to_hydro'] = (df.Vertical_Distance_To_Hydrology**2 \n                                         + df.Horizontal_Distance_To_Hydrology**2)**.5\n\n    return df\n\nX = euclidean(X)\ntest = euclidean(test)\n","add4255b":"from itertools import combinations\n\ndef distances(df):\n    cols = [\n        'Horizontal_Distance_To_Roadways',\n        'Horizontal_Distance_To_Fire_Points',\n        'Horizontal_Distance_To_Hydrology',\n    ]\n    \n    df['distance_mean'] = df[cols].mean(axis=1)\n    df['distance_sum'] = df[cols].sum(axis=1)\n    df['distance_road_fire'] = df[cols[:2]].mean(axis=1)\n    df['distance_hydro_fire'] = df[cols[1:]].mean(axis=1)\n    df['distance_road_hydro'] = df[[cols[0], cols[2]]].mean(axis=1)\n    \n    df['distance_sum_road_fire'] = df[cols[:2]].sum(axis=1)\n    df['distance_sum_hydro_fire'] = df[cols[1:]].sum(axis=1)\n    df['distance_sum_road_hydro'] = df[[cols[0], cols[2]]].sum(axis=1)\n    \n    df['distance_dif_road_fire'] = df[cols[0]] - df[cols[1]]\n    df['distance_dif_hydro_road'] = df[cols[2]] - df[cols[0]]\n    df['distance_dif_hydro_fire'] = df[cols[2]] - df[cols[1]]\n    \n    # Vertical distances measures\n    colv = ['Elevation', 'Vertical_Distance_To_Hydrology']\n    \n    df['Vertical_dif'] = df[colv[0]] - df[colv[1]]\n    df['Vertical_sum'] = df[colv].sum(axis=1)\n    \n    return df\n\nX = distances(X)\ntest = distances(test)","9cfcfd33":"f, axes = plt.subplots(1, 3, figsize=(15, 5), sharex=True, sharey=True)\n\nsns.distplot(X['Hillshade_9am'], color=\"y\", ax=axes[0])\nsns.distplot(X['Hillshade_Noon'], color=\"b\", ax=axes[1])\nsns.distplot(X['Hillshade_3pm'], color=\"g\", ax=axes[2])\n","bed68650":"X[['Hillshade_9am', 'Hillshade_Noon', 'Hillshade_3pm']].kurt()","88c56343":"def shade(df):\n    SHADES = ['Hillshade_9am', 'Hillshade_Noon', 'Hillshade_3pm']\n    \n    df['shade_noon_diff'] = df['Hillshade_9am'] - df['Hillshade_Noon']\n    df['shade_3pm_diff'] = df['Hillshade_Noon'] - df['Hillshade_3pm']\n    df['shade_all_diff'] = df['Hillshade_9am'] - df['Hillshade_3pm']\n    df['shade_sum'] = df[SHADES].sum(axis=1)\n    df['shade_mean'] = df[SHADES].mean(axis=1)\n    return df\n\nX = shade(X)\ntest = shade(test)","b372de22":"# create a dict that map soil type with rockness\n# 0=unknow 1=complex 2=rubbly, 3=stony, \n# 4=very stony, 5=extremely stony 6=extremely bouldery\nsoils = [\n    [7, 15, 8, 14, 16, 17,\n     19, 20, 21, 23], #unknow and complex \n    [3, 4, 5, 10, 11, 13],   # rubbly\n    [6, 12],    # stony\n    [2, 9, 18, 26],      # very stony\n    [1, 24, 25, 27, 28, 29, 30,\n     31, 32, 33, 34, 36, 37, 38, \n     39, 40, 22, 35], # extremely stony and bouldery\n]\n\nsoil_dict = dict()\nfor index, values in enumerate(soils):\n    for v in values:\n        soil_dict[v] = index\n        \n        \ndef soil(df, soil_dict=soil_dict):\n    df['Rocky'] =  sum(i * df['Soil_Type'+ str(i)] for i in range(1, 41))\n    df['Rocky'] = df['Rocky'].map(soil_dict) \n\n    return df\n\nX = soil(X)\ntest = soil(test)","798637d3":"sns.violinplot(x=TARGET, y='Rocky', data=X)\n","3c02fc13":"sns.violinplot(x=TARGET, y='Elevation', data=X)","071a3865":"f, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='Hillshade_9am', y='Elevation', \n                hue=TARGET, data=X, y_jitter=True)","9fd76916":"f, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='Hillshade_Noon', y='Elevation', \n                hue=TARGET, data=X, y_jitter=True)","556b210e":"f, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='Hillshade_3pm', y='Elevation', \n                hue=TARGET, data=X, y_jitter=True)","c8269a11":"\nf, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='Euclidean_distance_to_hydro', y='Elevation', \n                hue=TARGET, data=X)","e6adc333":"def elevation(df):\n    df['ElevationHydro'] = df['Elevation'] - 0.25 * df['Euclidean_distance_to_hydro']\n    return df\n\nX = elevation(X)\ntest = elevation(test)\nf, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='Euclidean_distance_to_hydro', y='ElevationHydro', \n                hue=TARGET, data=X)","c9f10316":"f, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='Vertical_Distance_To_Hydrology', y='Elevation', \n                hue=TARGET, data=X)","dfd2d191":"def elevationV(df):\n    df['ElevationV'] = df['Elevation'] - df['Vertical_Distance_To_Hydrology']\n    return df\n\nX = elevationV(X)\ntest = elevationV(test)\nf, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='Vertical_Distance_To_Hydrology', y='ElevationV', \n                hue=TARGET, data=X)","a052359a":"f, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='Horizontal_Distance_To_Hydrology', y='Elevation', \n                hue=TARGET, data=X)","f702bcf4":"def elevationH(df):\n    df['ElevationH'] = df['Elevation'] - 0.19 * df['Horizontal_Distance_To_Hydrology']\n    return df\n\nX = elevationH(X)\ntest = elevationH(test)\nf, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='Horizontal_Distance_To_Hydrology', y='ElevationH', \n                hue=TARGET, data=X)","dcdc8c77":"f, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='Horizontal_Distance_To_Roadways', y='Elevation', \n                hue=TARGET, data=X)","b93d420b":"f, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='Horizontal_Distance_To_Fire_Points', y='Elevation', \n                hue=TARGET, data=X)","8bae27d5":"f, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='distance_road_fire', y='Elevation', \n                hue=TARGET, data=X)","7254d794":"def kernel_features(df):\n    df['Elevation2'] = df['Elevation']**2\n    df['ElevationLog'] = np.log1p(df['Elevation'])\n    return df\n\nX = kernel_features(X)\ntest = kernel_features(test)","684ed724":"f, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='Aspect', y='Elevation', \n                hue=TARGET, data=X)","bcff0c7f":"f, axes = plt.subplots(1, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(x='Slope', y='Elevation', \n                hue=TARGET, data=X)","fcd27c86":"X[['Slope', 'Aspect']].describe()","6cc1d8a4":"\nf, axes = plt.subplots(3, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(y='Slope', x='Hillshade_9am', \n                hue='Aspect', data=X, ax=axes[0])\nsns.scatterplot(y='Slope', x='Hillshade_Noon', \n                hue='Aspect', data=X, ax=axes[1])\nsns.scatterplot(y='Slope', x='Hillshade_3pm', \n                hue='Aspect', data=X, ax=axes[2])\n","22052879":"def degree(df):\n    df['Aspect_cos'] = np.cos(np.radians(df.Aspect))\n    df['Aspect_sin'] = np.sin(np.radians(df.Aspect))\n    #df['Slope_sin'] = np.sin(np.radians(df.Slope))\n    df['Aspectcos_Slope'] = df.Slope * df.Aspect_cos\n    #df['Aspectsin_Slope'] = df.Slope * df.Aspect_sin\n    \n    return df\n\nX = degree(X)\ntest = degree(test)\n\n","2ecf7f8a":"\nf, axes = plt.subplots(3, 1, figsize=(15, 15), sharex=True, sharey=True)\nsns.scatterplot(y='Slope', x='Hillshade_9am', \n                hue='Aspect_sin', data=X, ax=axes[0])\nsns.scatterplot(y='Slope', x='Hillshade_Noon', \n                hue='Aspect_sin', data=X, ax=axes[1])\nsns.scatterplot(y='Slope', x='Hillshade_3pm', \n                hue='Aspect_sin', data=X, ax=axes[2])\n","654413f9":"from bisect import bisect\n\ncardinals = [i for i in range(45, 361, 90)]\n\npoints = ['N', 'E', 'S', 'W']\n\ndef cardinal(df):\n    df['Cardinal'] = df.Aspect.apply(lambda x: points[bisect(cardinals, x) % 4])\n    return df\n\nX = cardinal(X)\ntest = cardinal(test)\n\n","8e0335c6":"f, axes = plt.subplots(5, 1, figsize=(15, 25), sharex=True, sharey=True)\nsns.scatterplot(x='Slope', y='Hillshade_3pm', \n                hue=TARGET, data=X[X.Cardinal=='E'], ax=axes[0])\nsns.scatterplot(x='Slope', y='Hillshade_3pm', \n                hue=TARGET, data=X[X.Cardinal=='W'], ax=axes[1])\nsns.scatterplot(x='Slope', y='Hillshade_3pm', \n                hue=TARGET, data=X[X.Cardinal=='N'], ax=axes[2])\nsns.scatterplot(x='Slope', y='Hillshade_3pm', \n                hue=TARGET, data=X[X.Cardinal=='S'], ax=axes[3])\nsns.scatterplot(x='Slope', y='Hillshade_3pm', \n                hue=TARGET, data=X, ax=axes[4])","49db3ae3":"def cardinal_num(df):\n    d = {'N': 0, 'E': 1, 'S': 0, 'W':-1}\n    df['Cardinal'] = df.Cardinal.apply(lambda x: d[x])\n    return df\n\nX = cardinal_num(X)\ntest = cardinal_num(test)","e2f49732":"X['w'] = sum(i * X['Wilderness_Area'+ str(i)] for i in range(1, 5))\ntest['w'] = sum(i * test['Wilderness_Area'+ str(i)] for i in range(1, 5))\n\ncols = [\n    'ElevationH', 'Vertical_dif', 'Euclidean_distance_to_hydro', \n    'Aspectcos_Slope', 'distance_dif_hydro_road', 'Hillshade_9am'\n]\nn = ['Elev', 'Vert_d', 'Eucli', 'AspSlo', 'dist_hr', 'hillshade']\n\nstats = X.groupby('w')[cols].describe()\n\nfor i, col in enumerate(cols):\n    name = n[i] + '_mean'\n    d = {r: stats[col]['50%'][r] for r in range(1, 5)}\n    X[name] = X.w.apply(lambda r: d[r])\n    test[name] = test.w.apply(lambda r: d[r])\n\n    \nX.drop('w', inplace=True, axis=1)\ntest.drop('w', inplace=True, axis=1)\n","29ae0b0e":"# drop label \nif TARGET in X.columns:\n    X.drop(TARGET, axis=1, inplace=True)\n","10474968":"from sklearn.ensemble import (\n    RandomForestClassifier,\n    ExtraTreesClassifier,\n    AdaBoostClassifier,\n)\nfrom lightgbm import LGBMClassifier\nfrom mlxtend.classifier import StackingCVClassifier\nimport warnings\n\nwarnings.simplefilter(action='ignore', category=FutureWarning)\n\nSEED = 2007\n\nmodels = {\n    'LGBM': LGBMClassifier(n_estimators=370,\n                           metric='multi_logloss',\n                           num_leaves=100,\n                           verbosity=0,\n                           random_state=SEED,\n                           n_jobs=-1), \n    'Random Forest': RandomForestClassifier(n_estimators=500,\n                                            n_jobs=-1,\n                                            random_state=SEED),\n    'Extra Tree': ExtraTreesClassifier(\n           max_depth=400, \n           n_estimators=450, n_jobs=-1,\n           oob_score=False, random_state=SEED, \n           warm_start=True)\n\n}\n","2d4c653f":"clf = models['Random Forest']\n\ndef feature_importances(clf, X, y, figsize=(18, 6)):\n    clf = clf.fit(X, y)\n    \n    importances = pd.DataFrame({'Features': X.columns, \n                                'Importances': clf.feature_importances_})\n    \n    importances.sort_values(by=['Importances'], axis='index', ascending=False, inplace=True)\n\n    fig = plt.figure(figsize=figsize)\n    sns.barplot(x='Features', y='Importances', data=importances)\n    plt.xticks(rotation='vertical')\n    plt.show()\n    return importances\n    \nimportances = feature_importances(clf, X, y)    ","6064b5a2":"def select(importances, edge):\n    c = importances.Importances >= edge\n    cols = importances[c].Features.values\n    return cols\n\ncol = select(importances, 0.0003)\nX = X[col]\ntest = test[col]    ","c0e2e994":"# cross validation\nfrom sklearn.model_selection import KFold, cross_val_score\n\n# model selection functions\n\ncv = KFold(n_splits=5, shuffle=True, random_state=SEED)\n\ndef cross_val(models, X=X, y=y):\n    r = dict()\n    for name, model in models.items():\n        cv_results = cross_val_score(model, X, y,\n                             cv=cv, \n                             scoring='accuracy')\n        r[name] = cv_results\n        print(name, 'Accuracy Mean {0:.4f}, Std {1:.4f}'.format(\n              cv_results.mean(), cv_results.std()))\n    return r\n    \ndef choose_best(results):\n    errors = dict()\n\n    for name, arr in results.items():\n        errors[name] = arr.mean()\n\n    best_model =  [m for m, e in errors.items() \n                   if e == max(errors.values())][0]\n    return best_model","a73825df":"results = cross_val(models)\n","fd545d4c":"best_model_name = choose_best(results)\n\n\nmodel = models[best_model_name]","ef375d3d":"def predict(model, filename, X=X, y=y, test=test):\n    model.fit(X, y)\n    predicts = model.predict(test)\n\n    output = pd.DataFrame({'ID': test.index,\n                       TARGET: predicts})\n    output.to_csv(filename+'.csv', index=False)\n    return predicts\n","a2cb1747":"estimators = [m for m in models.values()]\n\nstack = StackingCVClassifier(classifiers=estimators,\n                             meta_classifier=model,\n                             cv=cv,\n                             use_probas=True,\n                             use_features_in_secondary=True,\n                             verbose=1,\n                             random_state=SEED,\n                             n_jobs=-1)\n\npredict_stack = predict(stack, 'stacked')\nprint('Ready!')","1f530eb4":"## Soil analysis\n\n1=rubbly, 2=stony, 3=very stony, 4=extremely stony\n","9ee69941":"Excellent!! all features are numeric\n`Soil_TypeX` and `Wilderness_AreaX` are OHE features of categorical variables. Hence they are binary columns.","f843f625":"Beautiful!!\n\nThis graphic is revealing.\n\nAt 9am, the sunlight is more intense on the slopes facing east, (darker points) and clearly, the larger the slope, the greater the difference in light between the east and west sides (light points).\n\n\u00a0 The north and south points have intermediate light values and their variability continues to rise in relation to the slope.\n\nAt noon, all points seem to intermingle, this is because the sun is more distributed on all sides of the mountain.\n\nBy 3pm the difference is marked, this time you can visualize beautifully in this graph as the east side has much less light than the west side.","58990e85":"### Interpretation\nThe first plot (horizontal distance to hydrology)\nAs expected, vegetation seems to be more abundant near hydrology.\n\nThe second plot (vertical distance), it seems that the negative values \u200b\u200bcould be vegetation superior to hydrology and the positive ones are vegetation inferior to hydrology. Most of the vegetation is in the downhill from hydrology with a huge amount of vegetation concentrated near 0 (high kurtosis), which means that much vegetation is at almost the same level of water.\n\nWhen calculating the Euclidean distance to hydrology as a heuristic measure, we see that our third graph looks like the first, this is because the horizontal distance has a wider distribution compared to the horizontal distance where almost all values \u200b\u200bare close to zero. However, this Euclidean distance is also better suited to the line, which will improve our model.","1b3456ad":"## Wilderness Area","aab85af9":"### Stacked model","5a44d523":"x1, y1 =   'Horizontal_Distance_To_Hydrology', 'ElevationH'\nHUE = TARGET  # 'Euclidean_distance_to_hydro'\nf, axes = plt.subplots(2, 2, figsize=(25, 25), sharex=True, sharey=True)\nsns.scatterplot(x1, y1, hue=HUE, data=X[X.Wilderness_Area1 == 1], ax=axes[0][0])\nsns.scatterplot(x1, y1, hue=HUE, data=X[X.Wilderness_Area2 == 1], ax=axes[0][1])\nsns.scatterplot(x1, y1, hue=HUE, data=X[X.Wilderness_Area3 == 1], ax=axes[1][0])\nsns.scatterplot(x1, y1, hue=HUE, data=X[X.Wilderness_Area4 == 1], ax=axes[1][1])\n","414e5de5":"## Elevation analysis\n\nElevation is the most important feature (see feature importance section). Hence we would compare this with other features (bivariate analysis), and make some transformations creating new features that help our tree algos to make better splits.","aab54a74":"There are 54 columns or features and 15120 observations.\nThe dataset is balanced, there are only 7 values for the label (Cover_Type), and each type have same sample size (2160 rows)\n\nIt is a multi classification problem.","f005ddd4":"## Slope and Aspect analysis\nSlope and Aspect are degrees features, from 0 to 360 degrees\n\nFirst the slope, the min slope is 0 and the max slope is 52, is vertical inclination respect to the horizon. \n\nNow, Aspect, this feature is in degrees from 0 to 360, I guess refers to cardinal direction of the slope (this is a particular guess). \nI guess 0 refer to North direction for slope, and 180 to the south and so on.\n\nGenerally, the sun moves from east to west (since our optical), hence in a mountain at morning the east side is illuminated and the west is still shade, at noon maybe both sides are illuminated, and by afternoon the west side receives more light than the east side.\n\nNorth and South sides of the mountain, are sides that maximize the sunlight received, and have similar behavior.","44a963e6":"Here we observe the relationship between slope, aspect, shadow and time.\n\nAt 9 am, all the flat land (slope near zero) receives the same amount of sunlight (approximately 220),\nAt noon it goes up to 240 and at 3 pm it goes down to 155.\n\nIn addition, we observe how the shadow increases the variability in the same way that the slope increases.\nAt 9 am, the aspect between 0 and 150 receives more light, and at 3 pm the relationship has changed. ","343001d4":"There is no NANs!!!\nLets train our first model\n","2cf00e33":"### Interpretation\n\nHere we can see the variation in the amount of sunlight among three different day hours.\nBetween 9 am and noon, we see how the sunlight is increasing with a high positive kurtosis (>1) a huge peak in approx 225, that is almost the max value measurable (254). \n\nBy the 3 pm, there is a significant reduction of the light is some zones, (maybe by some hill), now the kurtosis is close to 0.\n","b7ffcba2":"f, axes = plt.subplots(1, 1, figsize=(15, 15), \n                       sharex=True, sharey=True)\nsns.scatterplot(x=TARGET, y='Elevation', \n                hue='Rocky', data=X)\n\nc_7 = (X.Cover_Type == 7)\nr_4 = X.Rocky != 4\n\n\nX['Soil_Type'] = sum(X['Soil_Type' + str(i)] * i for i in range(1, 41))\nX[c_7][r_4].Soil_Type.value_counts()\n\nX[X['Soil_Type']==35].Cover_Type.value_counts()\nX[X['Soil_Type']==23].Cover_Type.value_counts()\nX[X['Soil_Type']==4].Cover_Type.value_counts()\nX[X['Soil_Type']==21].Cover_Type.value_counts()","d7acde91":"### Make a model","0d2e56b4":"## Feautures importances","f287b0e5":"## Aspect Binning\n ","c9cd4bd7":"Let's validate our model(s)","616082b4":"## Shade analysis","95fb55ea":"## Distances analysis\n\nDistances features are: \n- Vertical_Distance_To_Hydrology\n- Horizontal_Distance_To_Hydrology\n- Horizontal_Distance_To_Roadways\n- Horizontal_Distance_To_Fire_Points"}}