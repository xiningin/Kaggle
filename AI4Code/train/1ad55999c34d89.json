{"cell_type":{"38bd2679":"code","5959de68":"code","d26fc731":"code","7fc8abec":"code","11d80e1e":"code","74819032":"code","b9c36296":"code","866edaba":"code","3ed9ba8b":"code","3105328c":"code","60560b3b":"code","fe0b1acc":"code","d8c9c87c":"code","38b42032":"code","3a2e99f2":"code","708ed3a8":"code","ff1634ff":"code","795b77ee":"code","796203b0":"code","df47c5d1":"code","c3842e45":"code","54f1dc92":"code","e32b7a6c":"code","54571c9e":"code","0c6ca73a":"code","525a5e53":"code","daf08488":"code","e995439f":"code","2017f0b3":"code","440709b0":"code","6c0188de":"code","b7975877":"code","a1ff2842":"code","f90b63dc":"code","77f07061":"code","f70c3315":"code","3c98b485":"code","bb05d38d":"code","b42d8d82":"code","336641ff":"code","62de5190":"code","82e1f67b":"code","21f83d3e":"markdown","4062edc8":"markdown","728b757d":"markdown","473e4d05":"markdown","723baf2e":"markdown","e174caf8":"markdown","5bd50531":"markdown","ba5ddc57":"markdown","2e5b7e75":"markdown","b347a811":"markdown","3d99fc83":"markdown","421783f1":"markdown","632b3ec2":"markdown","4a95cae3":"markdown","1e6b8900":"markdown","9421aa2a":"markdown","37495fa4":"markdown","2fb55424":"markdown","7fbc0cc4":"markdown","483b1097":"markdown","ad815df9":"markdown","6049500d":"markdown","4f476b3c":"markdown","82372727":"markdown","48f42607":"markdown","a2c970b9":"markdown","256e86c6":"markdown","4f73f4e7":"markdown","0fb00eb4":"markdown","e91d0cfa":"markdown","2a18f00d":"markdown","5a498308":"markdown","21106a37":"markdown","cf9fddd6":"markdown","df8db3d6":"markdown","c9be4ec6":"markdown","139594a8":"markdown","97552f32":"markdown","c5d31888":"markdown","1a0efd4f":"markdown","f3f22fdc":"markdown","4b8c69e5":"markdown","107437f4":"markdown","9f99f247":"markdown","b0007e23":"markdown","d6d7c4a8":"markdown","1f8718a6":"markdown","b160af3f":"markdown","533a6637":"markdown","def44262":"markdown","851d8c8e":"markdown","46bd1247":"markdown","a0459485":"markdown","7fdb8a87":"markdown"},"source":{"38bd2679":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os","5959de68":"import matplotlib.pyplot as plt\nfrom matplotlib import transforms\nfrom mpl_toolkits.axisartist.axislines import AxesZero\nimport subprocess\nimport sys\nimport re\n\nimport warnings\nimport arviz as az\nimport pymc3 as pm\nwarnings.simplefilter(action=\"ignore\", category=FutureWarning)\n###\n%config InlineBackend.figure_format = 'retina'\naz.style.use(\"arviz-darkgrid\")\nprint(f\"Running on ArviZ v{az.__version__}\")\n\n###\nimport io\nfrom PIL import Image\nimport matplotlib as mpl","d26fc731":"mpl.__version__","7fc8abec":"def doall(EqTitle,OneEq,locEq=0.2,FC=\"white\"):\n    # Colors used in Matplotlib online documentation.\n    mpl_blue_rvb = (191. \/ 255., 209. \/ 256., 212. \/ 255.)\n    mpl_orange_rvb = (202. \/ 255., 121. \/ 256., 0. \/ 255.)\n    mpl_grey_rvb = (51. \/ 255., 51. \/ 255., 51. \/ 255.)\n\n    # Creating figure and axis.\n    plt.figure(figsize=(7, 0.8))\n    plt.axes([0.01, 0.01, 0.98, 0.90], facecolor=FC, frameon=True)\n    plt.gca().set_xlim(0., 1.)\n    plt.gca().set_ylim(0., 1.)\n    plt.gca().set_title(EqTitle,\n                        color=mpl_grey_rvb, fontsize=24, weight='bold')\n    plt.gca().set_xticklabels(\"\", visible=False)\n    plt.gca().set_yticklabels(\"\", visible=False)\n\n    # Plotting formula\n    plt.annotate(OneEq,\n                 xy=(locEq,0.3),\n                 color=mpl_orange_rvb, ha='center', fontsize=35)\n    plt.show()","11d80e1e":"## A plot with physics --\nx = np.array([0.,0.,0.,0.,0.,0.])\ny = np.array([0.,0.,0.,0.,0.,0.])\nr = np.array([0.1,0.2,0.3,0.4,0.5,0.6])\n\nphi = np.linspace(0.0,2*np.pi,100)\nna=np.newaxis\n\n\n# the first axis of these arrays varies the angle, \n# the second varies the circles\nx_line = x[na,:]+r[na,:]*np.sin(phi[:,na])\ny_line = y[na,:]+r[na,:]*np.cos(phi[:,na])\n\n### For the Hyperbolas -t^2 + x^2 = -b^2\nbp=[0.1,0.2,0.3,0.4,0.5,0.6]\nx_paraB1 = np.linspace(-1,1,100)\n\nx_paraB = np.transpose([x_paraB1 for tk in bp])\nt_paraB = np.transpose([np.sqrt(x_paraB1**2 + tk**2) for tk in bp])\nt_paraBN = - t_paraB\n#\n    \n \nfig = plt.figure(figsize = (25, 17))\nax = fig.add_subplot(4,1,1, axes_class=AxesZero, aspect=0.7)\n\n\n## Some Transformation\nbase = plt.gca().transData\n\nfor direction in [\"xzero\", \"yzero\"]:\n    ax.axis[direction].set_axisline_style(\"-|>\")\n    ax.axis[direction].set_visible(True)\n\n\n## Square of the plot \nxl,xh = -1.2, 1.8\nyl,yh = xl,xh\nplt.xlim(xl,xh)\nplt.ylim(yl,yh)\n\n## The Hyperbolas,\nplt.plot(x_paraB, t_paraB,'-')\nplt.plot(x_paraB, t_paraBN,'-')\n\n# Move left y-axis and bottim x-axis to centre, passing through (0,0)\nax.set_xticklabels(\"\", visible=False)\nax.set_yticklabels(\"\", visible=False)\n\n\n## Rotated y axe\nangle_t = -20\nrot_t = transforms.Affine2D().rotate_deg(angle_t)\nx_tail = 0.\ny_tail = 0.\ny_head = yh*0.9\nx_head = 0.\ndx = x_head - x_tail \ndy = y_head - y_tail\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.02, \n         head_length=0.05, fc='darkorange', ec='darkorange', transform= rot_t + base) #\n## Some points (y axe)\nxhAb=np.array([0.2, 0.4, 0.6])\nplt.plot([0,0,0],xhAb,'ro')\n## SR theory\nt1=(1\/np.sqrt(1-np.tan(angle_t*np.pi\/(180))**2))*xhAb  # (1\/pow(1-pow(np.tan(-20*np.pi\/(180)),2),1\/2))*0.3\nx1=np.sqrt(-xhAb**2 + t1**2)                           # pow(-pow(0.3,2)+pow(t1,2),1\/2)\n##\nplt.plot(x1,t1,'ro')\n\n\n## Rotated x axe\nangle_x = (-1)*angle_t\nrot_x = transforms.Affine2D().rotate_deg(angle_x)\ny_tail = 0.\nx_tail = 0.\nx_head = xh*0.9\ny_head = 0.\ndx = x_head - x_tail \ndy = y_head - y_tail\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.02, \n         head_length=0.05, fc='darkorange', ec='darkorange', transform= rot_x + base\n        )\n## Some points (x axe)\nplt.plot(xhAb,[0,0,0],'ro')\n## SR theory (switch  [t <-> x] )\nplt.plot(t1,x1,'ro')\n\n# Rotated t' and x'\nplt.annotate('x\\'',(0.9*xh*np.cos(angle_x*np.pi\/(180)), 0.65*xh*np.sin(angle_x*np.pi\/(180))),  fontsize=20)\nplt.annotate('t\\'',(0.9*xh*np.cos(np.pi\/2-angle_x*np.pi\/(180)), 0.8*xh*np.sin(np.pi\/2-angle_x*np.pi\/(180))),  fontsize=20)\n# Ploting t,x --\nplt.annotate(\"x\",(0.9*xh, -0.2),  fontsize=20)\nplt.annotate(\"t\",(-0.1, 0.8*yh),  fontsize=20)\n\n\n# angle text\nt1=t1[-1]\nx1=x1[-1]\n###\nplt.annotate('$\\phi$',(x1*0.5,t1*1.2),  fontsize=14)\n#\nplt.annotate('$\\phi$',(t1*1.5,x1*0.5),  fontsize=14)\n\n\n## One thick red line for v=c\nangle_c = 45\nrot_c = transforms.Affine2D().rotate_deg(angle_c)\ny_tail = 0.\nx_tail = 2*xl\nx_head = xh*2.\ny_head = 0.\ndx = x_head - x_tail \ndy = y_head - y_tail\nax.arrow(x_tail, y_tail, x_head+dx, y_head+dy, head_width=0.02, lw=1.2,\n         head_length=0.05, fc='darkred', ec='darkred', transform= rot_c + base\n        )\n# SR theory v = c \nplt.annotate('$v=c$',(xh*0.7,yh*0.64),  fontsize=16)\n######################################################################################\n\n## A Title\nplt.title(\"Minkowski space - rotation\",  fontsize=30)\n\n#################################################################################################\n###################### Segunda figura ...\n#################################################################################################\nax = fig.add_subplot(4,2,1, axes_class=AxesZero, aspect=1)\n\n## Some Transformation\nangle_rot=30\nbase = plt.gca().transData\nrot = transforms.Affine2D().rotate_deg(angle_rot)\n\nfor direction in [\"xzero\", \"yzero\"]:\n    ax.axis[direction].set_axisline_style(\"-|>\")\n    ax.axis[direction].set_visible(True)\n\n## Square o the plot \nxl,xh = -.9, .9\nyl,yh = xl,xh\nplt.xlim(xl,xh)\nplt.ylim(yl,yh)\n\n## The circles,\nplt.plot(x_line,y_line,'-')\n\n\n\n## Some points (y axe)\nxhAb=np.array([0.2, 0.4, 0.6])\nplt.plot([0,0,0],xhAb,'ro')\nplt.plot([0,0,0],xhAb,'ro' , transform= rot + base)\n## Some points (x axe)\nplt.plot(xhAb,[0,0,0],'ro')\nplt.plot(xhAb,[0,0,0],'ro' , transform= rot + base)\n\n# Move left y-axis and bottim x-axis to centre, passing through (0,0)\nax.set_xticklabels(\"\", visible=False)\nax.set_yticklabels(\"\", visible=False)\n\n## Rotated y axe\nx_tail = 0.\ny_tail = yl\nx_head = 0.\ny_head = yh*0.5\ndx = x_head - x_tail\ndy = y_head - y_tail\nax.arrow(x_tail, y_tail, x_head+dx, y_head+dy, head_width=0.02, \n         head_length=0.05, fc='darkorange', ec='darkorange', transform= rot + base\n        )\n## Rotated x axe\ny_tail = 0.\nx_tail = xl\ny_head = 0.\nx_head = xh*0.5\ndx = x_head - x_tail \ndy = y_head - y_tail\nax.arrow(x_tail, y_tail, x_head+dx, y_head+dy, head_width=0.02, \n         head_length=0.05, fc='darkorange', ec='darkorange',  transform= rot + base\n        )\n# Rotated angles\nplt.annotate(\"x\",(0.9*xh, -0.1),  fontsize=20)\nplt.annotate(\"y\",(-0.1, 0.8*yh),  fontsize=20)\nplt.annotate('x\\'',(xh*np.cos(angle_rot*np.pi\/(180)), 1.2*xh*np.sin(angle_rot*np.pi\/(180))),  fontsize=20)\nplt.annotate('y\\'',(0.9*xh*np.cos(np.pi\/2+angle_rot*np.pi\/(180)), xh*np.sin(np.pi\/2+angle_rot*np.pi\/(180))),  fontsize=20)\n\n# angle text\n#t1=xhAb[-1]*np.sin(angle_rot*np.pi\/(180))\n#x1=0.3*xhAb[-1]*np.cos(angle_rot*np.pi\/(180))\nplt.annotate('$\\phi$',(-0.15,0.5),  fontsize=15)\nplt.annotate('$\\phi$',(0.48,0.13),  fontsize=15)\n\n## A Title\nplt.title(\"Euclidean space - rotation\",  fontsize=30)\n\n#plt.legend()\nplt.show()","74819032":"fig = plt.figure(figsize = (10, 13))\nax = fig.add_subplot(1,1,1, axes_class=AxesZero, aspect=0.8)\n\n\n## Some Transformation\nbase = plt.gca().transData\n\nfor direction in [\"xzero\", \"yzero\"]:\n    ax.axis[direction].set_axisline_style(\"-|>\")\n    ax.axis[direction].set_visible(True)\n\n## Square of the plot \nxl,xh = 0., 10.\nyl,yh = xl,6.\nplt.xlim(xl,xh)\nplt.ylim(yl,yh)\n\n########################################################################################\n## Rotated y axe\nangle_t = -20\nrot_t = transforms.Affine2D().rotate_deg(angle_t)\nx_tail = 0.\ny_tail = 0.\ny_head = yh*0.98\nx_head = 0.\ndx = x_head - x_tail \ndy = y_head - y_tail\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.09, lw=2.5,\n         head_length=0.1, fc='darkorange', ec='darkorange', transform= rot_t + base) #\n\n########################################################################################\n## Some points (y axe)\nxhAb=np.array([1, 2, 3])\n## SR theory\nt1=(1\/np.sqrt(1-np.tan(angle_t*np.pi\/(180))**2))*xhAb\nx1=np.sqrt(-xhAb**2 + t1**2)\n##\nsymbol=[\"1\",\"2\",\"3\"]\nfor i,l in enumerate(symbol):\n    #plt.plot(x1[i],t1[i],'go', marker=r\"$ {} $\".format(l), markersize=12)\n    tm = mpl.markers.MarkerStyle(marker='|')\n    tm._transform = tm.get_transform().rotate_deg(55)\n    plt.plot(x1[i],t1[i],'g', marker=tm, markersize=25)\n    plt.annotate(str(xhAb[i]),(x1[i],t1[i]),  fontsize=13)\n########################################################################################\n\n###\n########################################################################################\n## Rotated x axe\nangle_x = -angle_t\nrot_x = transforms.Affine2D().rotate_deg(angle_x)\nx_tail = 0.\ny_tail = 0.\nx_head = yh*1.6\ny_head = 0.\ndx = x_head - x_tail \ndy = y_head - y_tail\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.09, lw=2.5,\n         head_length=0.1, fc='darkorange', ec='darkorange', transform= rot_x + base) #\n\n########################################################################################\n## Some points (x axe)\n## SR theory\nt1=(1\/np.sqrt(1-np.tan(angle_t*np.pi\/(180))**2))*xhAb\nx1=np.sqrt(-xhAb**2 + t1**2)\n##\nfor i,l in enumerate(symbol):\n    #plt.plot(x1[i],t1[i],'go', marker=r\"$ {} $\".format(l), markersize=12)\n    tm = mpl.markers.MarkerStyle(marker='|')\n    tm._transform = tm.get_transform().rotate_deg(35)\n    plt.plot(t1[i],x1[i],'g', marker=tm, markersize=25)\n    plt.annotate(str(xhAb[i]),(t1[i],x1[i]),  fontsize=13)\nplt.vlines(t1[1],0.,x1[1], linestyle='--', color='r')\nplt.annotate('$\\gamma$',(t1[1]*1.05,0.25),  fontsize=15)\n########################################################################################\n\n\n## Anotate axes\nplt.annotate(\"x\",(0.95*xh, 0.07),  fontsize=20)\nplt.annotate(\"ct\",(0.06, 0.95*yh),  fontsize=20)\n# Rotated ct' & x'\nplt.annotate('x\\'',(0.8*xh*np.cos(angle_x*np.pi\/(180)), 0.7*xh*np.sin(angle_x*np.pi\/(180))),  fontsize=20)\nplt.annotate('ct\\'',(yh*np.cos(np.pi\/2-angle_x*np.pi\/(180)), yh*np.sin(np.pi\/2-angle_x*np.pi\/(180))),  fontsize=20)\n\n\n## H&V Lines\nx1=5\ny1=3\nplt.hlines(y1,0.,11., linestyle='--')\nplt.annotate('constant $ct$',(2.0,3.1),  fontsize=12)\nplt.vlines(x1,0.,11., linestyle='--')\nplt.annotate('constant $x$',(4.7,1.1),  fontsize=12)\n## point intersec\nplt.plot([x1],[y1],'ro')\nplt.annotate('($x, ct$)',(x1*1.05,y1*.93),  fontsize=12)\nplt.annotate('($x\\', ct\\'$)',(x1*1.05,y1*.84),  fontsize=12)\n\n\n## Ploting two lines of simultaneity --\nplt.plot([0.,x1],[1.15,y1],'k',linestyle='--')\nplt.annotate('constant $ct\\'$',(1.4,2.1),  fontsize=12)\nplt.plot([3.7,x1],[0.,y1],'k',linestyle='--')\nplt.annotate('constant $x\\'$',(2.9,0.3),  fontsize=12)\n\n########################################################################################\n########################################################################################\n## Notes\nax.annotate(r'$ct = \\frac{x}{\\beta}$  Worldline of observer'+\" O\\'\", \n            xy=(1.6,4),#(0.3*yh*np.cos(np.pi\/2-angle_x*np.pi\/(180)), 0.8*yh*np.sin(np.pi\/2-angle_x*np.pi\/(180))), \n            xytext=(6, 4),   fontsize=15,\n            arrowprops=dict(arrowstyle=\"->\",lw=2.5))\n##\nax.annotate(r'$ct = \\beta x$  Lines of simultaneity for'+\" O\\'\", \n            xy=(6,2.3), \n            xytext=(6, 3.45),   fontsize=15,\n            arrowprops=dict(arrowstyle=\"->\",lw=2.5))\n##\nax.annotate(\"$ct\\'$\"+r\"$= \\gamma(ct-\\beta x)$\", \n            (7.5, 2.1*0.8),   fontsize=20,\n            )\n##\nax.annotate(\"$x\\'$\"+r\"$ = \\gamma(x-\\beta ct)$\", \n            (7.5, 1.5*0.8),   fontsize=20,\n            )\n##\nax.annotate(r\"$\\beta = \\frac{v}{c}$\", \n            (6.5, .5),   fontsize=15,\n            )\n##\nax.annotate(r\"$\\gamma = \\frac{1}{\\sqrt{1-\\beta^2}}$\", \n            (8., .5),   fontsize=15,\n            )\n########################################################################################\n########################################################################################\n\n\nplt.show()","b9c36296":"## Here we write the Eq.\nmpl_blue_rvb = (191. \/ 255., 209. \/ 256., 212. \/ 255.)\nmyEq1={1: \n    r\"$ds^2 = \"\n    r\"\\eta_{\\mu \\nu}dx^{\\mu}dx^{\\nu} = \"\n    r\"-c^2t^2 + dx^2$\",\n    2:\n    r\"$ct'= \\gamma(ct-\\beta x)$\",\n    3:\n    r\"$x'= \\gamma(x-\\beta ct)$\",\n    4:\n    r\"$\\eta_{\\mu \\nu} ~~\\to~~ \\binom{-1~~~0}{~~0~~~1}$\",\n    5: \n    r\"$ds'^2 = \"\n    r\"\\eta_{\\mu \\nu}dx'^{\\mu}dx'^{\\nu} = \"\n    r\"-c^2t'^2 + dx'^2 =\"\n    r\"ds^2$\",\n}\nmyTitle='Invariant interval'    \n## Here we plot it    \ndoall(myTitle,myEq1[1])\n## metric\ndoall('',myEq1[4],0.2)\ndoall('',myEq1[2])\ndoall('',myEq1[3])\ndoall('',myEq1[5])","866edaba":"fig = plt.figure(figsize = (20, 17))\nax = fig.add_subplot(4,1,1, axes_class=AxesZero, aspect=0.8)\n\n## Square of the plot \nxl,xh = 0., 1.\nyl,yh = xl,xh\nplt.xlim(xl,xh)\nplt.ylim(yl,yh)\n\n\n# Move left y-axis and bottim x-axis to centre, passing through (0,0)\nax.set_xticklabels(\"\", visible=False)\nax.set_yticklabels(\"\", visible=False)\n\n\n########################################################################################\n########################################################################################\n## Notes\n##\nax.annotate(\"Proper time elapsed        $\\Delta t' = T_0$\", \n            (0.1,0.9),   fontsize=17,\n            )\n##\nax.annotate(\"Apparent time elapsed    $\\Delta t = T$\", \n            (0.1,0.8),   fontsize=17,\n            )\n##\nax.annotate(\"$\\Delta s^2_{AB} = - (c\\Delta t')^2 = - (c\\Delta t)^2  + \\Delta x^2$\", \n            (0.1,0.65),   fontsize=17,\n            )\n##\nax.annotate(\"But,   $\\Delta x=v \\Delta t$\", \n            (0.1,0.55),   fontsize=17,\n            )\n##\nax.annotate(r\"$\\Rightarrow \\Delta t'^2= \\Delta t^2 (1-\\beta^2)=\\frac{\\Delta t^2}{\\gamma^2}$\", \n            (0.1,0.4),   fontsize=20,\n            )\n##\nax.annotate(r\"$\\Rightarrow T=\\gamma T_0$\", \n            (0.1,0.3),   fontsize=20,\n            )\n\n######  End Notes ...\n########################################################################################\n\n\n\n#########################################################################################################################\n#########################################################################################################################\n### Right part for annnotations ( 2 )\n\nax = fig.add_subplot(4,2,1, axes_class=AxesZero, aspect=0.85)\n## Some Transformation\nbase = plt.gca().transData\n\nfor direction in [\"xzero\", \"yzero\"]:\n    ax.axis[direction].set_axisline_style(\"-|>\")\n    ax.axis[direction].set_visible(True)\n\n## Square of the plot \nxl,xh = 0., 1.\nyl,yh = xl,xh\nplt.xlim(xl,xh)\nplt.ylim(yl,yh)\n\nax.set_xticklabels(\"\", visible=False)\nax.set_yticklabels(\"\", visible=False)\n########################################################################################\n## Rotated y axe\nangle_t = -20\nrot_t = transforms.Affine2D().rotate_deg(angle_t)\nx_tail = 0.\ny_tail = 0.\ny_head = yh*0.98\nx_head = 0.\ndx = x_head - x_tail \ndy = y_head - y_tail\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.03, lw=2.5,\n         head_length=0.05, fc='darkorange', ec='darkorange', transform= rot_t + base) #\n########################################################################################\n## Rotated x axe\nangle_x = -angle_t\nrot_x = transforms.Affine2D().rotate_deg(angle_x)\nx_tail = 0.\ny_tail = 0.\nx_head = yh*1.\ny_head = 0.\ndx = x_head - x_tail \ndy = y_head - y_tail\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.03, lw=2.5,\n         head_length=0.05, fc='darkorange', ec='darkorange', transform= rot_x + base) #\n########################################################################################\n########################################################################################\n\n## Anotate axes\nplt.annotate(\"x\",(0.95*xh, 0.07),  fontsize=20)\nplt.annotate(\"ct\",(0.06, 0.95*yh),  fontsize=20)\n# Rotated ct' & x'\nplt.annotate('x\\'',(0.8*xh*np.cos(angle_x*np.pi\/(180)), 0.65*xh*np.sin(angle_x*np.pi\/(180))),  fontsize=20)\nplt.annotate('ct\\'',(1.1*yh*np.cos(np.pi\/2-angle_x*np.pi\/(180)), yh*np.sin(np.pi\/2-angle_x*np.pi\/(180))),  fontsize=20)\n\n\n## H&V Lines\nx1=0.55\ny1=0.65\nplt.hlines(y1,0.,11., linestyle='--')\nplt.hlines(y1*0.6,0.,11., linestyle='--')\nplt.vlines(x1,0.,11., linestyle='--')\n## point intersec\nplt.plot([x1],[y1],'ko')\nplt.annotate('A',(x1*0.9,y1*1.05),  fontsize=12,weight=\"bold\")\nplt.plot([x1*0.83],[(y1*0.6)],'ko')\nplt.annotate('B',(x1*0.76,(y1*0.6)*1.05),  fontsize=12,weight=\"bold\")\nplt.annotate(\"$c\\Delta t'$\",(x1*0.7,(y1*0.76)*1.05),  fontsize=14,weight=\"bold\")\nplt.annotate(\"$c\\Delta t$\",(x1*1.05,(y1*0.76)*1.05),  fontsize=14,weight=\"bold\")\n\n# a Triangle\npivot_left = (x1*0.83, y1*0.6)\npivot_right = (x1,y1*0.6)\npivot_top = (x1, y1)\npoints = np.array([pivot_left, pivot_right, pivot_top])\npivot = plt.Polygon(points, closed=True, fill=False, edgecolor='r', lw=4.)\nax.add_patch(pivot)\n\n##############################################################################################\n##############################################################################################\n## Ploting two lines of simultaneity --\n##############################################################################################\n## Rotated x axe\nangle_x = -angle_t\nrot_x = transforms.Affine2D().rotate_deg(angle_x)\nx_tail = 0.\ny_tail = 0.423\nx_head = yh*1.5\ny_head = 0.\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.0, lw=0.9, alpha=0.2,\n         head_length=0.0, fc='k', ec='k', transform= rot_x + base) #\n## Rotated x axe\nangle_x = -angle_t\nrot_x = transforms.Affine2D().rotate_deg(angle_x)\nx_tail = 0.\ny_tail = 0.25\nx_head = yh*1.5\ny_head = 0.\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.0, lw=0.9, alpha=0.2,\n         head_length=0.0, fc='k', ec='k', transform= rot_x + base) #\n##############################################################################################\n## Rotated t axe\nangle_x = angle_t\nrot_x = transforms.Affine2D().rotate_deg(angle_x)\nx_tail = 0.295\ny_tail = 0.\ny_head = yh*1.5\nx_head = 0.\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.0, lw=0.9, alpha=0.2,\n         head_length=0.0, fc='k', ec='k', transform= rot_x + base) #\n## Rotated t axe\nangle_x = angle_t\nrot_x = transforms.Affine2D().rotate_deg(angle_x)\nx_tail = 0.45\ny_tail = 0.\ny_head = yh*1.5\nx_head = 0.\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.0, lw=0.9, alpha=0.2,\n         head_length=0.0, fc='k', ec='k', transform= rot_x + base) #\n##############################################################################################\n##############################################################################################\n\nplt.show()","3ed9ba8b":"fig = plt.figure(figsize = (22, 22))\nax = fig.add_subplot(4,1,1, axes_class=AxesZero, aspect=0.6)\n\n## Square of the plot \nxl,xh = 0., 1.\nyl,yh = xl,xh\nplt.xlim(xl,xh)\nplt.ylim(yl,yh)\n\n\n# Move left y-axis and bottim x-axis to centre, passing through (0,0)\nax.set_xticklabels(\"\", visible=False)\nax.set_yticklabels(\"\", visible=False)\n\n\n########################################################################################\n########################################################################################\n## Notes\n##\nax.annotate(\"Proper length        $\\Delta x' = L_0$\", \n            (0.1,0.9),   fontsize=17,\n            )\n##\nax.annotate(\"Apparent length    $\\Delta x = L$\", \n            (0.1,0.8),   fontsize=17,\n            )\n##\nax.annotate(\"$\\Delta s^2_{AB} =  \\Delta x^2 = - (\\Delta x')^2  - (c\\Delta t')^2$\", \n            (0.1,0.65),   fontsize=17,\n            )\n##\nax.annotate(\"$\\Delta s^2_{AC} =  \\Delta x'^2 = (\\Delta x+v\\Delta t)^2 - (c\\Delta t)^2 $\", \n            (0.1,0.55),   fontsize=17,\n            )\n##\nax.annotate(\"and...   $\\Delta t = \\gamma \\Delta t'$\", \n            (0.1,0.45),   fontsize=17,\n            )\n##\nax.annotate(\"After a bit of Baldor...\", \n            (0.1,0.35),   fontsize=17,\n            )\n##\nax.annotate(r\"$\\Rightarrow L = \\frac{L_0}{\\gamma}$\", \n            (0.2,0.16),   fontsize=30,\n            )\n\n######  End Notes ...\n########################################################################################\n\n\n\n#########################################################################################################################\n#########################################################################################################################\n### Right part for annnotations ( 2 )\n\nax = fig.add_subplot(4,3,1, axes_class=AxesZero, aspect=0.9)\n## Some Transformation\nbase = plt.gca().transData\n\nfor direction in [\"xzero\", \"yzero\"]:\n    ax.axis[direction].set_axisline_style(\"-|>\")\n    ax.axis[direction].set_visible(True)\n\n## Square of the plot \nxl,xh = 0., 1.\nyl,yh = xl,xh\nplt.xlim(xl,xh)\nplt.ylim(yl,yh)\n\nax.set_xticklabels(\"\", visible=False)\nax.set_yticklabels(\"\", visible=False)\n########################################################################################\n## Rotated y axe\nangle_t = -20\nrot_t = transforms.Affine2D().rotate_deg(angle_t)\nx_tail = 0.\ny_tail = 0.\ny_head = yh*0.98\nx_head = 0.\ndx = x_head - x_tail \ndy = y_head - y_tail\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.03, lw=2.5,\n         head_length=0.05, fc='darkorange', ec='darkorange', transform= rot_t + base) #\n########################################################################################\n## Rotated x axe\nangle_x = -angle_t\nrot_x = transforms.Affine2D().rotate_deg(angle_x)\nx_tail = 0.\ny_tail = 0.\nx_head = yh*1.\ny_head = 0.\ndx = x_head - x_tail \ndy = y_head - y_tail\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.03, lw=2.5,\n         head_length=0.05, fc='darkorange', ec='darkorange', transform= rot_x + base) #\n########################################################################################\n########################################################################################\n\n## Anotate axes\nplt.annotate(\"x\",(0.95*xh, 0.07),  fontsize=20)\nplt.annotate(\"ct\",(0.06, 0.95*yh),  fontsize=20)\n# Rotated ct' & x'\nplt.annotate('x\\'',(0.8*xh*np.cos(angle_x*np.pi\/(180)), 0.65*xh*np.sin(angle_x*np.pi\/(180))),  fontsize=20)\nplt.annotate('ct\\'',(1.1*yh*np.cos(np.pi\/2-angle_x*np.pi\/(180)), yh*np.sin(np.pi\/2-angle_x*np.pi\/(180))),  fontsize=20)\n\n\n## H&V Lines\nx1=0.75\ny1=0.61\nplt.vlines(x1,0.,11., linestyle='--')\nplt.vlines(x1*0.6,0.,11., linestyle='--')\n\n## point intersec\nplt.plot([x1*0.6],[y1],'ko')\nplt.annotate('A',(x1*0.55,y1*1.05),  fontsize=12,weight=\"bold\")\nplt.plot([x1],[(y1)],'ko')\nplt.annotate('B',(x1*0.95,y1*1.05),  fontsize=12,weight=\"bold\")\nplt.plot([x1*1.07],[y1*1.21],'ko')\nplt.annotate('C',(x1*1.07*1.02,y1*1.21*1.03),  fontsize=12,weight=\"bold\")\nplt.annotate(\"$\\Delta x'$\",(x1*0.75,(y1*1.13)),  fontsize=14,weight=\"bold\")\nplt.annotate(\"$c\\Delta t'$\",(x1*1.07,(y1*1.11)),  fontsize=14,weight=\"bold\")\nplt.annotate(\"$\\Delta x$\",(x1*0.74,(y1*0.92)),  fontsize=14,weight=\"bold\")\n\n# a Triangle\npivot_left = (x1*0.6,y1)\npivot_right = (x1,y1)\npivot_top = (x1*1.07,y1*1.21)\npoints = np.array([pivot_left, pivot_right, pivot_top])\npivot = plt.Polygon(points, closed=True, fill=False, edgecolor='r', lw=6.)\nax.add_patch(pivot)\n# a Segment\npivot_left = (x1*0.34,y1*0.15)\npivot_right = (x1*0.82,y1*0.37)\npoints = np.array([pivot_left, pivot_right])\npivot = plt.Polygon(points, closed=False, fill=False, edgecolor='g', lw=6.)\nax.add_patch(pivot)\nplt.annotate(\"$L_0$\",(x1*0.45,y1*0.25),  fontsize=14,weight=\"bold\")\n\n\n## Notes\nax.annotate('World lines of the rod', \n            xy=(0.51,0.8), \n            xytext=(0.01, 0.8),   fontsize=12,\n            arrowprops=dict(arrowstyle=\"->\",lw=2.5))\n## Notes\nax.annotate('                                  ', \n            xy=(0.83,0.82), \n            xytext=(0.01, 0.81),   fontsize=12,\n            arrowprops=dict(arrowstyle=\"->\",lw=2.5))\n\n\n##############################################################################################\n##############################################################################################\n## Ploting two lines of simultaneity --\n##############################################################################################\n## Rotated x axe\nangle_x = -angle_t\nrot_x = transforms.Affine2D().rotate_deg(angle_x)\nx_tail = 0.\ny_tail = 0.423\nx_head = yh*1.5\ny_head = 0.\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.0, lw=0.9, alpha=0.2,\n         head_length=0.0, fc='k', ec='k', transform= rot_x + base) #\n## Rotated x axe\nangle_x = -angle_t\nrot_x = transforms.Affine2D().rotate_deg(angle_x)\nx_tail = 0.\ny_tail = 0.25\nx_head = yh*1.5\ny_head = 0.\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.0, lw=0.9, alpha=0.2,\n         head_length=0.0, fc='k', ec='k', transform= rot_x + base) #\n##############################################################################################\n## Rotated t axe\nangle_x = angle_t\nrot_x = transforms.Affine2D().rotate_deg(angle_x)\nx_tail = 0.21\ny_tail = 0.\ny_head = yh*1.5\nx_head = 0.\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.0, lw=0.9, alpha=0.2,\n         head_length=0.0, fc='k', ec='k', transform= rot_x + base) #\n## Rotated t axe\nangle_x = angle_t\nrot_x = transforms.Affine2D().rotate_deg(angle_x)\nx_tail = 0.5\ny_tail = 0.\ny_head = yh*1.5\nx_head = 0.\n# t' axis\nax.arrow(x_tail, y_tail, x_head, y_head, head_width=0.0, lw=0.9, alpha=0.2,\n         head_length=0.0, fc='k', ec='k', transform= rot_x + base) #\n##############################################################################################\n##############################################################################################\n\nplt.show()","3105328c":"fig = plt.figure(figsize = (20, 20))\nax = fig.add_subplot(4,1,1, axes_class=AxesZero, aspect=0.6)\n\n## Square of the plot \nxl,xh = 0., 1.\nyl,yh = xl,xh\nplt.xlim(xl,xh)\nplt.ylim(yl,yh)\n\n\n# Move left y-axis and bottim x-axis to centre, passing through (0,0)\nax.set_xticklabels(\"\", visible=False)\nax.set_yticklabels(\"\", visible=False)\n\n\n########################################################################################\n########################################################################################\n\n## Notes\ny1=0.5\nx1=0.05\nax.annotate('Inertial mass', \n            xy=(x1*4.1,y1*1.15), \n            xytext=(x1*1.1, y1*1.4),   fontsize=23,\n            arrowprops=dict(arrowstyle=\"->\",lw=2.5, color='darkorange'))\n\nax.annotate(\"$F=m_I a$\", \n            (x1,y1),   fontsize=47,\n            )\n## Grav charge\ny1=0.5\nx1=0.45\nax.annotate('Gravitational charge', \n            xy=(x1*1.8,y1*1.2), \n            xytext=(x1*1.1, y1*1.4),   fontsize=23,\n            arrowprops=dict(arrowstyle=\"->\",lw=2.5, color='g'))\n\nax.annotate(r\"$F_G=-G \\frac{m_G M}{r^2} \\hat{r}$\", \n            (x1,y1),   fontsize=47,\n            )\n##\ny1=0.25\nx1=0.3\nax.annotate(r\"$m_I = m_G $\", \n            (x1,y1),   fontsize=47, color='g'\n            )\n\n\n\n######  End Notes ...\n########################################################################################\nplt.title(\"Equivalence Principle (Newtonian)\",  fontsize=40)\n\n\n\nplt.show()","60560b3b":"fig = plt.figure(figsize = (20, 20))\nax = fig.add_subplot(4,1,1, axes_class=AxesZero, aspect=0.5)\n\n## Square of the plot \nxl,xh = 0., 1.\nyl,yh = xl,xh\nplt.xlim(xl,xh)\nplt.ylim(yl,yh)\n\n\n# Move left y-axis and bottim x-axis to centre, passing through (0,0)\nax.set_xticklabels(\"\", visible=False)\nax.set_yticklabels(\"\", visible=False)\n\n\n########################################################################################\n########################################################################################\n## Notes\ny1=0.49\nx1=0.05\nax.annotate('Coriolis', \n            xy=(x1+0.35,y1*1.2), \n            xytext=(x1+0.35, y1*1.4),   fontsize=15,\n            arrowprops=dict(arrowstyle=\"->\",lw=2.5, color='darkorange'))\nax.annotate('Uniform acceleration', \n            xy=(x1*4.4,y1*1.15), \n            xytext=(x1*1.1, y1*1.4),   fontsize=15,\n            arrowprops=dict(arrowstyle=\"->\",lw=2.5, color='r'))\nax.annotate('Centripital', \n            xy=(x1+0.7,y1*1.2), \n            xytext=(x1+0.7, y1*1.4),   fontsize=15,\n            arrowprops=dict(arrowstyle=\"->\",lw=2.5, color='blue'))\n\nax.annotate(r\"$\\ddot{x}_{NI}=-a - [2 \\omega \\times \\dot{x}] - [\\omega \\times (\\omega \\times x)]$\", \n            (x1,y1),   fontsize=33,\n            )\n########\ny1=0.84\nx1=0.05\nax.annotate(\"The pseudo forces experienced  in a non-inertial frame \\n \\\nare automatically proportional to the inertial mass\",\n            (x1,y1),   fontsize=19, color='g'\n            )\n\n########\ny1=0.1\nx1=0.05\nax.annotate(\"We readily accept that Coriolis and Centripital forces are due to \\n \\\nus being in a non-internal frame tied to the surface of the Earth. \\n \\\nIf we also accept that inertial observers should be in free-fall, \\n \\\nthen gravity is also a pseudo force!\",\n            (x1,y1),   fontsize=19, color='k'\n            )\n\n\n######  End Notes ...\n########################################################################################\nplt.title(\"Pseudo forces in a non-inertial frames (Newtonian)\",  fontsize=28)\n\n\n\nplt.show()","fe0b1acc":"%matplotlib inline\n\n# General imports\nfrom itertools import product\nimport matplotlib\nimport numba\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom IPython.display import display, Math\n\n# Basic imports and functions\nfrom sympy import latex, symbols, sin, cos, pi, simplify, lambdify, Matrix\nfrom scipy.integrate import solve_ivp\n\nfrom sympy.diffgeom import (\n    Manifold,\n    Patch,\n    CoordSystem,\n    metric_to_Christoffel_2nd,\n    TensorProduct as TP\n)\n\ndef lprint(v):\n    display(Math(latex(v)))","d8c9c87c":"# Create a manifold.\nM = Manifold('M', 4)\n\n# Create a patch.\npatch = Patch('P', M)\n\n# Basic symbols\nc, acc = symbols('c acc')\n\n# Coordinate system\ncartes_coord = CoordSystem('cartesian', patch, ['t', 'x', 'y', 'z'])\n\n# Get the coordinate functions\nt, x, y, z = cartes_coord.coord_functions()\n\n# Get the base one forms.\ndt, dx, dy, dz = cartes_coord.base_oneforms()\n\n# Auxiliar terms for the metric.\ndt_2 = TP(dt, dt)\ndx_2 = TP(dx, dx)\ndy_2 = TP(dy, dy)\ndz_2 = TP(dz, dz)\nfactor = (1 + 2*acc*z \/ c**2)\n\n# Build the metric\nmetric = -factor * c ** 2 * dt_2 + dx_2 + dy_2 + dz_2\n\n# Get the Christoffel symbols of the second kind.\nchristoffel = metric_to_Christoffel_2nd(metric)\n# Let's print this in an elegant way ;)\nfor i, j, k in product(range(4), range(4), range(4)):\n    if christoffel[i, j, k] != 0:\n        display(Math(f'\\Gamma^{i}_{{{j},{k}}} = ' + latex(christoffel[i, j, k])))","38b42032":"## Here we write the Eq.\nmyEq1={1: \"\\\"For this bending of light:\\\"\",\n       2: \n    r\"$ds^2 = -c^2 \\left(1+\\frac{2a_z z}{c^2}  \\right) dt^2 + dx^2 +dy^2 +dz^2$\",\n       3: \n    r\"$\\frac{d^2x^{\\mu}}{ds^2} + \\Gamma^{\\mu}_{\\alpha\\beta}  \\frac{dx^{\\alpha}}{ds} \\frac{dx^{\\beta}}{ds} = 0 $\"\n}\n#\nmyTitle='Geodesic Equation'    \n## Here we plot it \ndoall(myTitle,myEq1[1])\ndoall(\"\",myEq1[2])\ndoall(\"\",myEq1[3])","3a2e99f2":"g_func = lambdify((c, acc, z), christoffel, modules='numpy')\n\n## Specify c and r_s\ndef F(t, y):\n    u = np.array(y[0:4])\n    v = np.array(y[4:8])\n\n    chris = g_func(1, 1, u[3])\n\n    du = v\n    dv = -np.dot(np.dot(chris, v), v)\n\n    return np.concatenate((du, dv))","708ed3a8":"T = 60\npos_init=[0.001, 0.3, 0.1, 6.]\nvel_init=[0.55, (1), 0., 0.]\n## The solver --\nsol_Bend_of_light = solve_ivp(F, [0, T], (pos_init+vel_init), t_eval=np.linspace(0, T, int(T * 123 + 1)))","ff1634ff":"# Variables to plot\nzplot=sol_Bend_of_light.y[3]\nxplot=sol_Bend_of_light.y[1]\n\n# New figure\nfig=plt.figure(figsize=(10, 8),)\nax = fig.subplots(1, 1,  sharex=True, sharey=True)\n\n# Extract solution \nplt.plot(xplot, zplot, lw=4., c='k')\nplt.plot(xplot[::25], zplot[::25], 'ro', fillstyle='none', markersize=15)\n\nax = plt.gca()\n\nax.axhline(0, color=\"red\", ls='--', lw=2)\n\n#plt.grid()\nplt.xlabel(r\"x'($\\tau$)\",fontsize=40)\nplt.xticks(fontsize=20)\nplt.ylabel(r\"z'($\\tau$)\",fontsize=40)\nplt.yticks(fontsize=20)\n\n## Borders\nplt.rcParams[\"axes.edgecolor\"] = \"black\"\nplt.rcParams[\"axes.linewidth\"] = 1\n\nplt.show()","795b77ee":"fig = plt.figure(figsize = (20, 30))\nax = fig.add_subplot(4,1,1, axes_class=AxesZero, aspect=0.5)\n\n## Square of the plot \nxl,xh = 0., 1.\nyl,yh = xl,xh\nplt.xlim(xl,xh)\nplt.ylim(yl,yh)\n\n\n# Move left y-axis and bottim x-axis to centre, passing through (0,0)\nax.set_xticklabels(\"\", visible=False)\nax.set_yticklabels(\"\", visible=False)\n\n\n########################################################################################\n########################################################################################\n########\ny1=0.84\nx1=0.05\nax.annotate(\"Geodesics in Riemannian geometry generalize the concept of straight lines. \\n \\\nThey extremism the interval between events, and keep heading in the \\n \\\nsame direction (parallel transport their tangent vectors)\",\n            (x1,y1),   fontsize=19, color='g'\n            )\n\n## Notes\ny1=0.65\nx1=0.05\nax.annotate(r\"$S = \\int^B_A {\\sqrt{-ds^2}} =\"\nr\"\\int^{\\lambda_B}_{\\lambda_A} \\left( -g_{\\alpha\\beta} \\frac{dx^{\\alpha}}{d\\lambda} \\frac{dx^{\\beta}}{d\\lambda} d\\lambda \\right)^{1\/2}=\"\n            r\"\\int^{\\lambda_B}_{\\lambda_A} L (x^{\\mu}, \\frac{dx^{\\nu}}{d\\lambda})d\\lambda$\", \n            (x1,y1),   fontsize=33,\n            )\n\n## Notes\ny1=0.51\nx1=0.05\nax.annotate(r\"Euler-Lagrange:    \"\n            r\"$ \\frac{d}{d\\lambda} \\left(  \\frac{\\partial L}{\\partial(dx^{\\mu}\/d\\lambda) }   \\right)=\"\n            r\"  \\frac{\\partial L}{\\partial x^{\\mu} }  $\", \n            (x1,y1),   fontsize=36,\n            )\n\n\n## Notes\ny1=0.35\nx1=0.05\nax.annotate(r\"$\\Rightarrow  \\frac{d^2x^{\\alpha}}{d\\lambda^2} =\"\n            r\"-\\frac{1}{2}g^{\\alpha\\beta} ( g_{\\beta\\mu,\\nu} + g_{\\beta\\nu,\\mu}  - g_{\\mu\\nu,\\beta} ) \\frac{dx^{\\mu}}{d\\lambda}\\frac{dx^{\\nu}}{d\\lambda}=\"\n            r\"-\\Gamma^{\\alpha}_{\\mu\\nu}  \\frac{dx^{\\mu}}{d\\lambda} \\frac{dx^{\\nu}}{d\\lambda}$\", \n            (x1,y1),   fontsize=36,\n            )\n\n## Notes\ny1=0.2\nx1=0.01\nax.annotate(r\"If we introduce covariant derivates $\\Rightarrow$  \"\n            r\"$\\nabla_{\\beta} u^{\\alpha} = u_{,\\beta}^{\\alpha} + u^{\\nu}\\Gamma_{\\beta\\nu}^{\\alpha}$\",\n            (x1,y1),   fontsize=33,\n            )\n\n## Notes\ny1=0.08\nx1=0.01\nax.annotate(    \n            r\"and the 4-velocity $u=\\frac{dx^{\\alpha}}{d\\lambda}$\"\n            r\" $\\Rightarrow$   $u^{\\beta}  \\nabla_{\\beta} u^{\\alpha}=0 $\", \n            (x1,y1),   fontsize=36,\n            )\n\n######  End Notes ...\n########################################################################################\nplt.title(\"Riemannian Geometry and Geodesics\",  fontsize=30)\n\n\n\nplt.show()","796203b0":"# Create a manifold.\nM = Manifold('M', 4)\n\n# Create a patch.\npatch = Patch('P', M)\n\n# Basic symbols\nc, r_s = symbols('c r_s')\n\n# Coordinate system\nschwarzchild_coord = CoordSystem('schwarzchild', patch, ['t', 'r', 'theta', 'phi'])\n\n# Get the coordinate functions\nt, r, theta, phi = schwarzchild_coord.coord_functions()\n\n# Get the base one forms.\ndt, dr, dtheta, dphi = schwarzchild_coord.base_oneforms()\n\n# Auxiliar terms for the metric.\ndt_2 = TP(dt, dt)\ndr_2 = TP(dr, dr)\ndtheta_2 = TP(dtheta, dtheta)\ndphi_2 = TP(dphi, dphi)\nfactor = (1 - r_s \/ r)\n\n# Build the metric\nmetric = factor * c ** 2 * dt_2 - 1 \/ factor * dr_2 - r ** 2 * (dtheta_2 + sin(theta)**2 * dphi_2)\nmetric = metric \/ c ** 2\n\n# Get the Christoffel symbols of the second kind.\nchristoffel = metric_to_Christoffel_2nd(metric)","df47c5d1":"# Let's print this in an elegant way ;)\nfor i, j, k in product(range(4), range(4), range(4)):\n    if christoffel[i, j, k] != 0:\n        display(Math(f'\\Gamma^{i}_{{{j},{k}}} = ' + latex(christoffel[i, j, k])))","c3842e45":"!pip install einsteinpy","54f1dc92":"import numpy as np\n\nfrom einsteinpy.geodesic import Timelike\nfrom einsteinpy.plotting.geodesic import GeodesicPlotter","e32b7a6c":"position = [40., np.pi \/ 2, 0.]\nmomentum = [0., 0., 3.83405]\na = 0.\nsteps = 2000\ndelta = 1.","54571c9e":"geod = Timelike(\n    metric=\"Schwarzschild\",\n    metric_params=(a,),\n    position=position,\n    momentum=momentum,\n    steps=steps,\n    delta=delta,\n    return_cartesian=True\n)","0c6ca73a":"gpl = GeodesicPlotter()\ngpl.plot(geod)\ngpl.show()","525a5e53":"az.style.use(\"arviz-darkgrid\")\n## Here we write the Eq.\nmyEq1={1:r\"Do they look similar to Electrodynamics? ...\",\n       2: \n    r\"$G_{\\mu \\nu} = 8 \\pi T_{\\mu \\nu}$\"\n}\n#\nmyTitle='Fundamentals of Bayesian Statistics'    \n## Here we plot it \ndoall(myTitle,myEq1[1])","daf08488":"az.style.use(\"arviz-darkgrid\")\n## Here we write the Eq.\nmyEq1={1:r\"From priors to posteriors ...\",\n       2: \n    r\"$\\langle \\theta ^j \\rangle = \\int \\theta ^j p({\\bf \\theta} | {\\bf d}, \\mathcal{H}) d {\\bf \\theta}$\",\n       3: \n    r\"$p( \\theta ^j ) = \\int  p({\\bf \\theta} | {\\bf d}, \\mathcal{H}) \\prod _{k \\neq j} d {\\bf \\theta }^k$\",\n       4:\n       r\"$p( \\theta ^i, \\theta ^j ) = \\int  p({\\bf \\theta} | {\\bf d}, \\mathcal{H}) \\prod _{k \\neq i,j} d {\\bf \\theta }^k$\"\n}\n#\nmyTitle='Fundamentals of Bayesian Statistics'    \n## Here we plot it \ndoall(myTitle,myEq1[1])\ndoall(\"\",myEq1[2])\ndoall(\"\",myEq1[3])\ndoall(\"\",myEq1[4])","e995439f":"!ls ..\/input\/laconga-bhs-collisions-pics\/bayesian-parametric-population-models-master\/bayesian-parametric-population-models-master","2017f0b3":"!pip install -U ..\/input\/laconga-bhs-collisions-pics\/bayesian-parametric-population-models-master\/bayesian-parametric-population-models-master\/","440709b0":"%matplotlib inline\nimport numpy\n#import matplotlib\nmatplotlib.use(\"Agg\")\nfrom matplotlib import gridspec\n#import matplotlib.pyplot as plt\nimport scipy.stats\nimport scipy.special\n\nimport pprint\nfrom pop_models.coordinate import Coordinate, CoordinateSystem\nfrom pop_models.population import Population\nfrom pop_models.poisson_mean import PoissonMean\nfrom pop_models.detection import Detection\nnumpy.set_printoptions(threshold=10)\nseed = 42\nrandom = numpy.random.RandomState(seed)\nsqrt2 = numpy.sqrt(2.0)\n\n\n\n\n# Define a single coordinate called \"x\"\nX = Coordinate(\"x\")\n# Define a 1-dimensional coordinate system containing only \"x\"\ncoord_system = CoordinateSystem(X)\n\n\nparam_names = (\"rate\", \"mean\", \"var\")\ndef accept(prob, random_state=random):\n        \"\"\"\n        Returns ``True`` with probability ``prob``.\n        \"\"\"\n        p = random_state.uniform()\n        return p < prob\n    \n    \n\nclass SimplePopulation(Population):\n    \"\"\"\n    Defines a simple population with a single observable (\"x\"), which obey a\n    Gaussian distribution with unknown mean \"mean\" and known unit variance.\n    Normalization of this distribution is given by an unknown parameter \"rate\".\n    \"\"\"\n    def __init__(self):\n        # No special information needed, just pass the CoordinateSystem to the\n        # parent's constructor method.\n        super().__init__(coord_system, param_names)\n\n    def normalization(self, parameters, where=True, **kwargs):\n        # The normalization of the intensity function is just the \"rate\"\n        # parameter.\n        return parameters[\"rate\"]\n    \n\n    def pdf(self, observables, parameters, where=True, **kwargs):\n        # First argument is a list of observables, but there's only one, \"x\", so\n        # we pull that out of the list.\n        #print(observables[0])\n        x, = observables\n        \n        # The only parameter that affects the PDF is the \"mean\", so we extract\n        # that.\n        mean = parameters[\"mean\"]\n        var = parameters[\"var\"]\n\n        # PDF is a normal distribution with unit variance.  This is the\n        # functional form for such a distribution.  Note that by using\n        # `numpy.subtract.outer(mean, x)` instead of `mean - x`, we compute\n        # all combinations of `mean[i_1,...,i_n] - x[j_1,...,j_m]`, and the\n        # shape of the output array is `numpy.shape(mean) + numpy.shape(x)`.\n        # Handling array shapes like this is a requirement of the PopModels API.\n        delta = numpy.subtract.outer(mean, x)\/var\n        return (\n            numpy.exp(-0.5*numpy.square(delta)) \/\n            (var*numpy.sqrt(2.0*numpy.pi))\n            \n        )\n\n\n\nclass SimpleExpectedDetections(PoissonMean):\n    \"\"\"\n    We assume a perfect survey, so the expected number of detections is just the\n    event rate multiplied by the observing time.\n    \"\"\"\n    def __init__(self, obs_time, population):\n        super().__init__(population)\n        self.obs_time = obs_time\n\n    def __call__(self, parameters, where=True, **kwargs):\n        mu = parameters[\"mean\"]\n        sigma = parameters[\"var\"]\n        \n        return (\n            self.population.normalization(parameters, where=where) *\n            self.obs_time * 0.25 * (3.0 + scipy.special.erf(-mu \/ (sqrt2*sigma)))\n        )\n    \n\n\nclass SimpleDetection(Detection):\n    \"\"\"\n    We assume detections with perfect measurements, so all posterior samples are\n    of the correct value, and if the `likelihood` method were implemented, it\n    would be a delta function at the true value (which would not integrate well\n    numerically, so we must use `posterior_samples` since that makes a Monte\n    Carlo integral perfectly adaptive).\n    \"\"\"\n    def __init__(self, x_true):\n        # Parent constructor needs to know the coordinate system.\n        super().__init__(coord_system)\n        # In addition, we need to know the true value.\n        self.x_true = x_true\n\n    def posterior_samples(self, n_samples, random_state=None):\n        # Return the true value repeated once for each requested sample.\n        x_samples = numpy.broadcast_to(self.x_true, n_samples)\n        # CoordinateSystem is 1-D so we return a 1-element list.\n        post_samples = [x_samples]\n        # Specify that the prior is uniform.\n        prior_samples = None\n\n        return post_samples, prior_samples","6c0188de":"obs_time = 10.0\npopulation = SimplePopulation()\nexpval = SimpleExpectedDetections(obs_time, population)\n    \n\n# Synthetic Parameters \nrate_true = 1.0\nmean_true = 0.0\nvar_true = 1.0\n\n# Names of the parameters.\nparameters_true = {\"rate\": rate_true, \"mean\": mean_true, \"var\": var_true}\n\n\nexpval_true = expval(parameters_true)\n\n\n## Here the simulation of the total detection ..\nn_detections = scipy.stats.poisson(expval_true).rvs(1, random_state=random)\n\n\n\n## Drawing the synthetic values of \"x\" from a normal distribution with variance=1.\nx_truths = (\n    scipy.stats.norm(mean_true, 1.0)\n    .rvs(n_detections, random_state=random)\n)\n\n\n\n## Parameters for plotting ..\nn_plotting = 500\n\nx_min_plotting = -10.0\nx_max_plotting = +10.0\nx_plotting = numpy.linspace(x_min_plotting, x_max_plotting, n_plotting)\n\n\n## Apply selection effects, rejecting positive values with probability 50% ##\nx_plotting = numpy.array([\n            lamb\n            for lamb in x_plotting\n            if lamb <= 0.0 or accept(0.50)\n            ])","b7975877":"fig_pop, ax_pop = plt.subplots(figsize=(10,8))\n# Plot the population's intensity function.\nax_pop.plot(\n    x_plotting,\n    population.intensity((x_plotting,), parameters=parameters_true),\n    lw=5\n)\n\n## Maximum in y\n_, ax_pop_ymax = ax_pop.get_ylim()\n\n# Plot the detected events, and where they lie on the population.\nfor x_truth in x_truths:\n    ax_pop.plot(\n        [x_truth, x_truth], [0.0, 0.1*ax_pop_ymax],\n        color=\"darkorange\", linestyle=\"solid\", alpha=0.4, lw=2\n    )\n\nax_pop.set_xlabel(r\"$x$\",fontsize=25)\nax_pop.set_ylabel(r\"$\\rho(x | \\Lambda_{\\mathrm{true}})$\",fontsize=25)\nax_pop.tick_params(axis='both', which='major', labelsize=20)\nfig_pop.show()","a1ff2842":"n_walkers = 8\nhalf_n_samples = 64\nn_samples = 2*half_n_samples\n\noutput_directory = \"posterior_samples\"\n# File to store cleaned posterior samples in.\noutput_samples_filename = \"posterior_samples.hdf5\"\n\nchunk_size = 16","f90b63dc":"!rm {output_samples_filename}\n!rm -r {output_directory}\n!ls","77f07061":"from pop_models.detection import ReweightedPosteriorsDetectionLikelihood\nfrom pop_models.integrators import AdaptiveMCIntegrator\n\n# Detections, based in the detection model class \"SimpleDetection\".\ndetections = [SimpleDetection(x_true) for x_true in x_truths]\n\nmc_integrator = AdaptiveMCIntegrator(\n    iter_start=1, iter_max=2,\n)\n\ndetection_likelihoods = [\n    ReweightedPosteriorsDetectionLikelihood(\n        population, detection,\n        mc_integrator=mc_integrator,\n    )\n    for detection in detections\n]","f70c3315":"rate_min_prior = 0.01\nrate_max_prior = 3.50\nmean_min_prior = -1.5\nmean_max_prior = +1.0\nvar_min_prior = +0.5\nvar_max_prior = +3.0\n\n\n## Defining the priors ########################################\ndef log_prior(parameters, *args, **kwargs):\n    \"\"\"\n    Assume a prior uniform in rate and mean.\n    \"\"\"\n    rate = parameters[\"rate\"]\n    mean = parameters[\"mean\"]\n    var = parameters[\"var\"]\n\n    has_support = (\n        (rate >= rate_min_prior) &\n        (rate <= rate_max_prior) &\n        (mean >= mean_min_prior) &\n        (mean <= mean_max_prior) &\n        (var >= var_min_prior) &\n        (var <= var_max_prior)\n    )\n\n    return numpy.where(has_support, 0.0, -numpy.inf)\n###############################################################\n\n\n\nrate_init = random.uniform(rate_min_prior, rate_max_prior, n_walkers)\nmean_init = random.uniform(mean_min_prior, mean_max_prior, n_walkers)\nvar_init = random.uniform(var_min_prior, var_max_prior, n_walkers)\ninit_state = numpy.column_stack((rate_init, mean_init, var_init))","3c98b485":"from pop_models.posterior import H5RawPosteriorSamples\nfrom pop_models.posterior import PopulationInferenceEmceeSampler\n\n# Create object for storing posterior samples, with an HDF5 backend.\npost_samples = H5RawPosteriorSamples.create(\n    output_directory,\n    population.param_names,\n    init_state,\n    chunk_size=chunk_size,\n)\n\npop_inference = PopulationInferenceEmceeSampler(\n    post_samples,\n    expval, detection_likelihoods, log_prior,\n    random_state=random,\n    verbose=True,\n)\n\n## Summary\npost_samples.summary()","bb05d38d":"samples = pop_inference.posterior_samples(half_n_samples)\n\n\nsamples_equiv = post_samples.get_samples(slice(-half_n_samples, None))\n\n## testing if they are equal!\nnumpy.testing.assert_equal(\n    samples,\n    samples_equiv,\n)\n############################\n\ninit_state_equiv = post_samples.get_samples(0)\nsamples_all = post_samples.get_samples(...)\n\n\n## testing if they are equal!\nnumpy.testing.assert_equal(\n    init_state,\n    samples_all[0],\n)\nnumpy.testing.assert_equal(\n    samples,\n    samples_all[1:],\n)\n############################\n\n\n\n# Close the old ``H5RawPosteriorSamples`` object.\npost_samples.close()\n\n\n# Create a new ``H5RawPosteriorSamples`` object, picking up where we left off.\npost_samples = H5RawPosteriorSamples(output_directory, \"r+\")\n# Create another ``PopulationInference`` object, which doesn't care if this is\n# the beginning of a new run, or a resuming of an old run.  It just uses the\n# last sample in ``post_samples`` as a starting point.\npop_inference = PopulationInferenceEmceeSampler(\n    post_samples,\n    expval, detection_likelihoods, log_prior,\n    random_state=random,\n    verbose=True,\n)\n\n\npop_inference.posterior_samples(half_n_samples)\nlog_post_samples = post_samples.get_posterior_log_prob(slice(-n_samples, None))\nlog_prior_samples = post_samples.get_prior_log_prob(slice(-n_samples, None))","b42d8d82":"post_samples.summary()","336641ff":"assert numpy.count_nonzero(log_prior_samples) == 0\nparameter_samples = post_samples.get_params(slice(-10, None))\n\npprint.pprint(parameter_samples)","62de5190":"fig_chains, axes_chains = post_samples.plot_chains()\n\nfig_chains.show()","82e1f67b":"from pop_models.posterior import H5CleanedPosteriorSamples\n\npost_samples_cleaned = H5CleanedPosteriorSamples.from_raw_manual(\n    output_samples_filename,\n    post_samples,\n    burnin=int(0.6*n_samples), thinning=1,\n)\n\n\nfig_post = post_samples_cleaned.plot_corner(\n    levels=[0.50, 0.90], truths=parameters_true,\n)\nfig_post.show()","21f83d3e":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:310%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n Posterior distributions, Bayesian Learning and Model Evidence\n\n <\/p>\n<\/div>","4062edc8":"# (MCMC) Running parameters (1)","728b757d":"***","473e4d05":"# Running the MCMC","723baf2e":"# Computing the Geodesic","e174caf8":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\">   \n\n# \ud83d\udccc Lab session #4\n    \n<\/div> ","5bd50531":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:310%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n Gravitational Waves (some equations)\n\n <\/p>\n<\/div>","ba5ddc57":"# Geodesic with Schwarchild's metric:","2e5b7e75":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:310%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n Riemannian Geometry and Geodesics\n\n <\/p>\n<\/div>","b347a811":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:310%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n Time Dilation\n\n <\/p>\n<\/div>","3d99fc83":"***","421783f1":"![](https:\/\/upload.wikimedia.org\/wikipedia\/en\/thumb\/2\/23\/Aerial_view_of_LIGO_facility_in_Hanford%2C_Washington.jpg\/220px-Aerial_view_of_LIGO_facility_in_Hanford%2C_Washington.jpg)\n\nCredit: Wikipedia","632b3ec2":"# PyCBC - Gravitational Waves software\nhttps:\/\/github.com\/gwastro\/PyCBC-Tutorials\n\n# Tutorial 1: Accesing Gravitational waves data:\nhttps:\/\/colab.research.google.com\/github\/gwastro\/pycbc-tutorials\/blob\/master\/tutorial\/1_CatalogData.ipynb\n\n# Tutorial 2: Data visualization and basic signal processing:\nhttps:\/\/colab.research.google.com\/github\/gwastro\/pycbc-tutorials\/blob\/master\/tutorial\/2_VisualizationSignalProcessing.ipynb","4a95cae3":"# Black Holes collisions - LaCoNGA (June 29, 2021)\n\n![](https:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/d\/d1\/Black_Hole_Merger.jpg\/800px-Black_Hole_Merger.jpg)\n\nCredit: Wikipedia\n\n<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:210%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n This is the black holes collision part of the course\n (2021).\n \n    by: J.M, Ram\u00edrez\n\n <\/p>\n<\/div>","1e6b8900":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\">   \n\n#### \ud83d\udccc This is exactly what Einstein reasoned: \u201cI was sitting in a chair in the patent office in Bern when all of a sudden a thought occurred to me: \u2018If a person falls freely he will not feel his own weight\u2019. I was startled. This simple thought made a deep impression upon me. It impelled me towards a theory of gravitation\u201d\n    \n<\/div> \n    ","9421aa2a":"We will follow an [old version of this scenario](https:\/\/git.ligo.org\/daniel.wysocki\/bayesian-parametric-population-models) (not available on the web anymore):","37495fa4":"# Let's work on a Gaussian population\n\nWe would like to\nextract the parameters (mean and variance) of a synthetic\npopulation (normally distributed).\nWe apply an efficiency function, which\ncauses positive-valued samples to only be detected 50% of the time, and\nnegative-valued samples to always be detected.\n\nPoisson posterior formula\n-----------------------------------------------------\n\nThe probability density function (pdf) is\n\n\\begin{align}\\rho(\\lambda\\mid\\Lambda) = \\mathcal{R} \\mathcal{N}(\\lambda; \\mu, \\sigma^2)\\end{align}\n\nwhere $\\Lambda = (\\mathcal{R}, \\mu, \\sigma^2)$.\n\nThe expected number of detections in an observing time $T$ is\n\n\\begin{align}\\mu(\\Lambda) =\n   T \\int_{-\\infty}^{+\\infty} \\mathrm{d}\\lambda \\,\n     \\eta(\\lambda) \\, \\rho(\\lambda\\mid\\Lambda)\\end{align}\n\nwhere $\\eta(\\lambda)$ is the efficiency function\n\n\\begin{align}\\eta(\\lambda) =\n  \\begin{cases}\n    1\/2, & \\text{if } \\lambda > 0,\n    \\\\\n    1, & \\text{otherwise.}\n  \\end{cases}\\end{align}\n\nWe can evaluate $\\mu(\\Lambda)$ analytically to be\n\n\\begin{align}\\mu(\\Lambda) =\n   \\frac{T \\cdot \\mathcal{R}}{4}\n   \\left[ 3 + \\mathrm{erf}\\left(-\\frac{\\mu}{\\sqrt{2\\sigma^2}}\\right)\\right]\\end{align}\n\nWe assume a prior which is uniform in $\\log_{10}\\mathcal{R}$, $\\mu$,\nand $\\log_{10}(\\sigma^2)$\n\n\\begin{align}\\pi(\\Lambda) =\n   \\mathcal{U}(\n     \\log_{10}\\mathcal{R};\n     \\log_{10}\\mathcal{R}_{\\mathrm{min}}, \\log_{10}\\mathcal{R}_{\\mathrm{max}}\n   )\n   \\mathcal{U}(\n     \\log_{10}\\mu;\n     \\log_{10}\\mu_{\\mathrm{min}}, \\log_{10}\\mu_{\\mathrm{max}}\n   )\n   \\mathcal{U}(\n     \\log_{10}(\\sigma^2);\n     \\log_{10}(\\sigma^2)_{\\mathrm{min}}, \\log_{10}(\\sigma^2)_{\\mathrm{max}}\n   )\\end{align}\n\nWe also assume that our measurements of each detection have infinite precision,\nwhich makes the both the likelihood and posterior a Dirac delta function\ncentered at the true value for that event, $\\lambda_n$, so long as the\nprior has support there (which any reasonable prior would). We then only need\none posterior sample from each event \u2013 the true value \u2013 in order to describe it\naccurately, and we set the prior samples to ``None``, which instructs the code\nto perform no division by the prior, equivalent to a uniform prior (in the function posterior_samples).\n\n\nSynthesizing our data set\n-------------------------\n\nWe assume an event rate $\\mathcal{R}$, and an observing time $T$,\nwhich correspond to an *intrinsic* mean number of events\n$\\mathcal{R} \\times T$ in that time. The *intrinsic* number of events\nwhich actually occur is determined by a Poisson random variable\n\n\\begin{align}N_{\\mathrm{int}} \\sim \\mathrm{Poi}(\\mathcal{R} \\times T)\\end{align}\n\nWe draw one sample for $N_{\\mathrm{int}}$. With this number in hand, we\ndraw $N_{\\mathrm{int}}$ samples from our intrinsic population distribution\n\n\\begin{align}\\lambda_i \\sim \\mathcal{N}(\\mu, \\sigma^2)\\end{align}\n\nfor some assumed values for $(\\mu, \\sigma^2)$, and for\n$i \\in \\{1, \\ldots, N_{\\mathrm{int}}\\}$. Due to our detection efficiency\n$\\eta(\\lambda)$ described above, we then must discard positive-valued\nsamples with 50% probability each. Note: this does not necessarily mean we\ndiscard half of the samples, as each sample is considered independently, and its\nacception\/rejection is random. In principle we could wind up discarding none of\nthem, all of them, half of them, or anywhere inbetween \u2013 though the expected\nvalue is half. This leaves us with a (likely) smaller number of samples,\n$\\lambda_i$ for $i \\in \\{1, \\ldots, N\\}$, where $N$ is the\nnumber of samples after the rejection procedure, which satisfies\n$0 \\leq N \\leq N_{\\mathrm{int}}$.\n\n\nPopulation inference\n--------------------\n\nPutting together the pieces of the inhomogeneous Poisson posterior function, as\nwell as our $N$ synthesized detections, we perform a Markov chain Monte\nCarlo using several classes and methods found [here](https:\/\/git.ligo.org\/daniel.wysocki\/bayesian-parametric-population-models). \nWe initialize the MCMC by drawing\nsamples from our prior $\\pi(\\Lambda)$. We evolve the chain using\n``n_walkers`` in parallel, each obtaining ``n_samples``. We then remove the\nfirst ``half_n_samples`` samples from each chain (to remove the effects of burnin).\nThese are set to fixed numbers for simplicity, though in\nprinciple they should be determined empirically from the data. With all of the\nposterior samples $\\Lambda_0, \\Lambda_1, \\ldots, \\Lambda_S$ in hand, we\ncreate a ``post_samples_cleaned.plot_corner`` of the samples, with the\ntrue values overplotted. If the code is working properly, there is a high\nprobability that the true values will lie in a region of high density.","2fb55424":"# Chain runs","7fbc0cc4":"# Simulated data parameters","483b1097":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:310%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n Relativity and Geometry\n\n <\/p>\n<\/div>","ad815df9":"# (log-Priors) Running parameters (2)","6049500d":"# \"Corner\" Plot of the joint and marginal posteriors","4f476b3c":"# Markov Chain summary","82372727":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:310%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n Equivalence Principle (Newtonian)\n\n <\/p>\n<\/div>","48f42607":"***","a2c970b9":"# Initial conditions and parameters","256e86c6":"***","4f73f4e7":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:310%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n Gravity as Geometry\n\n <\/p>\n<\/div>","0fb00eb4":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:310%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n Invariant interval\n\n <\/p>\n<\/div>","e91d0cfa":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:310%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n Gravitational waves - LIGO and PyCBC\n\n <\/p>\n<\/div>","2a18f00d":"# Figure of the synthetic distribution of \"x\"","5a498308":"# [EinsteinPy Project](https:\/\/einsteinpy.org)","21106a37":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:310%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n Length Contraction\n\n <\/p>\n<\/div>","cf9fddd6":"# Plotting","df8db3d6":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\">   \n\n# \ud83d\udccc Lab session #3\n    \n<\/div> ","c9be4ec6":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:310%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n Pseudo forces in a non-inertial frames (Newtonian)\n\n <\/p>\n<\/div>","139594a8":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\">   \n\n#### \ud83d\udccc \u201cIt was most unsatisfactory to me that, although the relation between inertia and energy is so beautifully derived [in Special Relativity], there is no relation between inertia and weight. I suspected that this relationship was inexplicable by means of Special Relativity\u201d\nAlbert Einstein, 1922\n    \n<\/div> ","97552f32":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\">   \n\n#### \ud83d\udccc This indeed confirms that photons do follow parabolic paths in the x-z spacetime plane.\n    \n<\/div> ","c5d31888":"***","1a0efd4f":"***","f3f22fdc":"***","4b8c69e5":"<div style=\"color:white;\n           display:fill;\n           border-radius:5px;\n           background-color:#42c497;\n           font-size:310%;\n           font-family:Verdana;\n           letter-spacing:0.5px\">\n\n<p style=\"padding: 10px;\n              color:white;\">\n Relativity and Geometry\n\n <\/p>\n<\/div>","107437f4":"# Hands-on for this course (in Colab)\n\n# [Corner plots of GW150914](https:\/\/colab.research.google.com\/github\/gwastro\/pycbc-tutorials\/blob\/master\/tutorial\/inference_5_results_io\/IntroToPyCBCInference.ipynb)\n\n\n![Corner1.png](attachment:23a71b90-dab4-4663-bcd4-6155c4746f9d.png)","9f99f247":"***","b0007e23":"![Gravitational_Wave_2021_LaConga_Pics.003.png](attachment:367e60dc-4e66-445c-8e57-10cbd35b263f.png)","d6d7c4a8":"## Running parameters","1f8718a6":"![Separate_slides.001.png](attachment:e7e9c468-da62-4384-a146-2d416762ca7a.png)","b160af3f":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\">   \n\n# \ud83d\udccc Lab session #1\n    \n<\/div> ","533a6637":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\">   \n\n# Special relativity is encoded in the geometry of Minkowski space \ud83d\udccc\n    \n<\/div>    ","def44262":"***","851d8c8e":"***","46bd1247":"![Rocket_2021_small.png](attachment:40856869-dd1e-45c4-8267-ca3514beeaf5.png)","a0459485":"***","7fdb8a87":"<div class=\"alert alert-block alert-info\" style=\"font-size:24px; font-family:verdana; line-height: 1.7em;\">   \n\n# \ud83d\udccc Lab session #2\n    \n<\/div> "}}