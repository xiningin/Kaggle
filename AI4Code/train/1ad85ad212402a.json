{"cell_type":{"108cc57c":"code","9b48b1e7":"code","78c8ce33":"code","aefc4f17":"code","867fb21f":"code","7eeae1ff":"code","8ced2c07":"code","d98ff9a3":"code","c0791626":"code","94533a5e":"code","dfcc4546":"code","91f9b743":"code","0b05aa60":"code","807bf6bc":"code","ce054787":"code","440a3e53":"code","3748d3bd":"code","7b21909d":"code","cc30efa0":"code","32f298f8":"code","d70d9ae8":"code","4686fc99":"code","9b4b0ae0":"code","c945e2d5":"code","d197b4b5":"code","e63bc35d":"code","c02ae3ae":"code","38572ece":"code","772350e0":"markdown","384c70b1":"markdown","d3125366":"markdown"},"source":{"108cc57c":"import re\nimport os\nimport json\nimport pandas as pd\nfrom pathlib import Path","9b48b1e7":"from plotly import graph_objects as go\nimport seaborn as sns\nimport plotly.express as px\nfrom plotly.subplots import make_subplots","78c8ce33":"from transformers import AutoTokenizer","aefc4f17":"from collections import defaultdict, Counter","867fb21f":"pd.set_option(\"display.max_colwidth\", 300)","7eeae1ff":"DATA_DIR = Path(\"\/kaggle\/input\/chaii-hindi-and-tamil-question-answering\/\")\ntrain_data = pd.read_csv(DATA_DIR \/ \"train.csv\")\ntest_data = pd.read_csv(DATA_DIR \/ \"test.csv\")\nsubmission_data = pd.read_csv(DATA_DIR \/ \"sample_submission.csv\")","8ced2c07":"train_data.head(2)","d98ff9a3":"test_data.head(2)","c0791626":"train_data.language.value_counts()","94533a5e":"test_data.language.value_counts()","dfcc4546":"languages = [\"tamil\", \"hindi\"]\nselect_language = lambda x, y: x[x.language == y]","91f9b743":"def clean_data(text):\n    text = re.sub(r\"[a-zA-Z_+-]+\", \"\", text)\n    text = re.sub(r\"\\[\\d+\\]\", \"\", text)\n    text = re.sub(r\"\\([\\d\\s \u00d7]+\\)\", \"\", text)\n    text = re.sub(r\"\\(\\s*\\)\", \"\", text)\n    text = re.sub(r\"\\n\", \" \", text)\n    return text","0b05aa60":"train_data.context = train_data.context.apply(lambda x: clean_data(x))","807bf6bc":"train_data.head(2)","ce054787":"from IPython.display import HTML\nimport altair as alt\nfrom  altair.vega import v5","440a3e53":"# Defining functions for visualizations: \n\ndef pie_plot(labels, values, colors, title):\n    fig = {\n      \"data\": [\n        {\n          \"values\": values,\n          \"labels\": labels,\n          \"domain\": {\"x\": [0, .48]},\n          \"name\": \"Job Type\",\n          \"sort\": False,\n          \"marker\": {'colors': colors},\n          \"textinfo\":\"percent+label\",\n          \"textfont\": {'color': '#FFFFFF', 'size': 10},\n          \"hole\": .6,\n          \"type\": \"pie\"\n        } ],\n        \"layout\": {\n            \"title\":title,\n            \"annotations\": [\n                {\n                    \"font\": {\n                        \"size\": 25,\n\n                    },\n                    \"showarrow\": False,\n                    \"text\": \"\"\n\n                }\n            ]\n        }\n    }\n    return fig","3748d3bd":"##-----------------------------------------------------------\n# This whole section \nvega_url = 'https:\/\/cdn.jsdelivr.net\/npm\/vega@' + v5.SCHEMA_VERSION\nvega_lib_url = 'https:\/\/cdn.jsdelivr.net\/npm\/vega-lib'\nvega_lite_url = 'https:\/\/cdn.jsdelivr.net\/npm\/vega-lite@' + alt.SCHEMA_VERSION\nvega_embed_url = 'https:\/\/cdn.jsdelivr.net\/npm\/vega-embed@3'\nnoext = \"?noext\"\n\npaths = {\n    'vega': vega_url + noext,\n    'vega-lib': vega_lib_url + noext,\n    'vega-lite': vega_lite_url + noext,\n    'vega-embed': vega_embed_url + noext\n}\n\nworkaround = \"\"\"\nrequirejs.config({{\n    baseUrl: 'https:\/\/cdn.jsdelivr.net\/npm\/',\n    paths: {}\n}});\n\"\"\"\n\n#------------------------------------------------ Defs for future rendering\ndef add_autoincrement(render_func):\n    # Keep track of unique <div\/> IDs\n    cache = {}\n    def wrapped(chart, id=\"vega-chart\", autoincrement=True):\n        if autoincrement:\n            if id in cache:\n                counter = 1 + cache[id]\n                cache[id] = counter\n            else:\n                cache[id] = 0\n            actual_id = id if cache[id] == 0 else id + '-' + str(cache[id])\n        else:\n            if id not in cache:\n                cache[id] = 0\n            actual_id = id\n        return render_func(chart, id=actual_id)\n    # Cache will stay outside and \n    return wrapped\n            \n@add_autoincrement\ndef render(chart, id=\"vega-chart\"):\n    chart_str = \"\"\"\n    <div id=\"{id}\"><\/div><script>\n    require([\"vega-embed\"], function(vg_embed) {{\n        const spec = {chart};     \n        vg_embed(\"#{id}\", spec, {{defaultStyle: true}}).catch(console.warn);\n        console.log(\"works?\");\n    }});\n    console.log(\"recheck to see if it works?\");\n    <\/script>\n    \"\"\"\n    return HTML(\n        chart_str.format(\n            id=id,\n            chart=json.dumps(chart) if isinstance(chart, dict) else chart.to_json(indent=None)\n        )\n    )\n\n\n\nHTML(\"\".join((\n    \"<script>\",\n    workaround.format(json.dumps(paths)),\n    \"<\/script>\")))\n","7b21909d":"# Wordcloud function\n\n\ndef word_cloud(df, pixwidth=6000, pixheight=350, column=\"index\", counts=\"count\"):\n    data= [dict(name=\"dataset\", values=df.to_dict(orient=\"records\"))]\n    wordcloud = {\n        \"$schema\": \"https:\/\/vega.github.io\/schema\/vega\/v5.json\",\n        \"width\": pixwidth,\n        \"height\": pixheight,\n        \"padding\": 0,\n        \"title\": \"Hover to see number of occureances from all the sequences\",\n        \"data\": data\n    }\n    scale = dict(\n        name=\"color\",\n        type=\"ordinal\",\n        range=[\"cadetblue\", \"royalblue\", \"steelblue\", \"navy\", \"teal\"]\n    )\n    mark = {\n        \"type\":\"text\",\n        \"from\":dict(data=\"dataset\"),\n        \"encode\":dict(\n            enter=dict(\n                text=dict(field=column),\n                align=dict(value=\"center\"),\n                baseline=dict(value=\"alphabetic\"),\n                fill=dict(scale=\"color\", field=column),\n                tooltip=dict(signal=\"datum.count + ' occurrances'\")\n            )\n        ),\n        \"transform\": [{\n            \"type\": \"wordcloud\",\n            \"text\": dict(field=column),\n            \"size\": [pixwidth, pixheight],\n            \"font\": \"Helvetica Neue, Arial\",\n            \"fontSize\": dict(field=\"datum.{}\".format(counts)),\n            \"fontSizeRange\": [10, 60],\n            \"padding\": 2\n        }]\n    }\n    wordcloud[\"scales\"] = [scale]\n    wordcloud[\"marks\"] = [mark]\n    \n    return wordcloud\n\n\n\ndef wordcloud_create(df, field):\n    ult = {}\n    corpus = df[field].values.tolist()\n    final = defaultdict(int) #Declaring an empty dictionary for count (Saves ram usage)\n    for words in corpus:\n        for word in words:\n             final[word]+=1\n    temp = Counter(final)\n    print(\"Number of distinct tokens: \", len(temp))\n    for k, v in  temp.most_common(300):\n        ult[k] = v\n    corpus = pd.Series(ult) #Creating a dataframe from the final default dict\n    return render(word_cloud(corpus.to_frame(name=\"count\").reset_index(), pixheight=600, pixwidth=900))","cc30efa0":"def analyse_tokenizer(tokenizer_path, train_data):\n    tokenizer = AutoTokenizer.from_pretrained(tokenizer_path)\n\n    train_data['tokens'] = train_data['context'].apply(lambda x: tokenizer.tokenize(x))\n\n    train_data[\"num_tokens\"] = train_data['tokens'].apply(lambda x: len(x))\n\n    languages = [\"tamil\", \"hindi\"]\n    select_language = lambda x, y: x[x.language == y]\n\n    fig = make_subplots(rows= 1, cols= 2,\n                        x_title=\"Number of words\", y_title=\"Number of context\")\n    for idx, lang in enumerate(languages):\n        fig.add_trace(\n            go.Histogram(\n                x = list(select_language(train_data, lang).num_tokens),\n                name = lang.upper()\n            ),\n            row = 1,\n            col = idx + 1,\n        )\n    fig.update_layout(title=\"Distribution of Sequence length\", title_x=0.5)\n    fig.show()\n    \n    for idx, lang in enumerate(languages):\n        # Find number of distinct tokens\n        words_freq = Counter([word for sample in select_language(train_data, lang)[\"tokens\"] for word in sample])\n        print(\"Number of distinct tokens: \", len(words_freq))\n\n        # Plot top tokens to check if it has more tokens\n        x,y = zip(*words_freq.most_common(60))\n        fig = go.Figure()\n        fig.add_trace(go.Bar(x=x, y=y))\n        fig.update_layout(\n            title=\"Frequent words distribution\",\n            title_x=0.5,\n            xaxis_title=\"Tokens\",\n            yaxis_title=\"Frequency\",\n        )\n        fig.show()","32f298f8":"xlmr_train_data = train_data.copy()\nanalyse_tokenizer(\"deepset\/xlm-roberta-large-squad2\", xlmr_train_data)","d70d9ae8":"wordcloud_create(select_language(xlmr_train_data, \"hindi\"), \"tokens\")","4686fc99":"wordcloud_create(select_language(xlmr_train_data, \"tamil\"), \"tokens\")","9b4b0ae0":"muril_train_data = train_data.copy()\nanalyse_tokenizer(\"google\/muril-base-cased\", muril_train_data)","c945e2d5":"wordcloud_create(select_language(muril_train_data, \"tamil\"), \"tokens\")","d197b4b5":"wordcloud_create(select_language(muril_train_data, \"hindi\"), \"tokens\")","e63bc35d":"indicbert_train_data = train_data.copy()\nanalyse_tokenizer(\"ai4bharat\/indic-bert\", indicbert_train_data)","c02ae3ae":"wordcloud_create(select_language(indicbert_train_data, \"tamil\"), \"tokens\")","38572ece":"wordcloud_create(select_language(indicbert_train_data, \"hindi\"), \"tokens\")","772350e0":"### Conclusion\nThough XLM-Roberta have tokens of 100 of languages, it has more tokens than indic-bert trained on Indian languages.\nMuril-bert have context richness but it has more unknown words","384c70b1":"## Evaluation against different pretrained tokenizers","d3125366":"Copied Wordcloud Visualization script from [here](https:\/\/www.kaggle.com\/hoshi7\/chaii-interactive-wordclouds?scriptVersionId=72235241&cellId=8). Thanks [Shivam Ralli](https:\/\/www.kaggle.com\/hoshi7)"}}