{"cell_type":{"9cb9d55d":"code","771aa02e":"code","56cc2964":"code","657d63f9":"code","22f145e0":"code","1ccf9cc5":"code","1a1f1778":"code","9bff6562":"code","9e06ee81":"code","95c133ab":"code","0c1feeb7":"code","fdb57f62":"code","2442ecc8":"code","a947309e":"code","1a1fa879":"code","1e936548":"code","92d006a7":"code","788cac4f":"code","38af8a0f":"code","dbf74bc2":"code","52c06d6f":"code","a8827576":"code","89bf6cea":"code","73e7d674":"code","f8343e6c":"code","5f7c5b77":"code","8dfbc062":"code","b43c5990":"code","7a7a9925":"code","5e9a39f3":"code","4abb9c38":"code","206beedb":"code","1483e1b2":"code","a30b5eea":"code","0afdb517":"code","e18ed5da":"code","18832303":"code","c87e49b6":"code","0bafa9ae":"code","8b21ddd3":"code","7bb0be0f":"code","c08f152c":"code","78321cc8":"code","87aac7ab":"code","42748dc1":"code","1e007818":"markdown","6dd5c17a":"markdown","aec3192d":"markdown","65220c92":"markdown","dd1692f0":"markdown","6a57b698":"markdown","e19220fa":"markdown","c6232e31":"markdown","4fc17261":"markdown","4cfe9b91":"markdown","588c4a3b":"markdown","c1c6a146":"markdown","187cc9ca":"markdown","65dc93a2":"markdown","05a619fe":"markdown","5fbccb6a":"markdown","307efcbc":"markdown","1497d4e6":"markdown","f8255c02":"markdown","a72112b0":"markdown","2fb4979b":"markdown","6017e648":"markdown","e4128418":"markdown","30718e3d":"markdown","4e25d305":"markdown","60f9bc00":"markdown","68e32cdd":"markdown","0bb2d657":"markdown","a1d5eaaf":"markdown","052821a5":"markdown","a572a286":"markdown","d336fc0f":"markdown","be0a1256":"markdown","9ef4090f":"markdown","2d08dc02":"markdown","6317b2da":"markdown","65bbf027":"markdown","073096d9":"markdown","af355cad":"markdown","199b7443":"markdown","4bc2e045":"markdown","0a364ea4":"markdown","fdf3b8fc":"markdown"},"source":{"9cb9d55d":"import pandas as pd, numpy as np\nimport matplotlib.pyplot as plt, seaborn as sns, plotly.express as px, plotly.figure_factory as ff\nimport scipy\nfrom tqdm import tqdm\nimport warnings\nwarnings.filterwarnings('ignore')","771aa02e":"data = pd.read_csv('..\/input\/ukrainian-market-mobile-phones-data\/phones_data.csv')","56cc2964":"data = data.drop(columns='Unnamed: 0')","657d63f9":"data.head()","22f145e0":"data.shape","1ccf9cc5":"data.isna().sum()","1a1f1778":"data[data.battery_size.isna()]","9bff6562":"class SimilarPhones():\n    \n    def __init__(self, rec_data):\n        self.data_ = rec_data.copy(True)\n        self.numeric_cols = data.select_dtypes(include=['int16', 'int32', 'int64', 'float16', 'float32', 'float64']).columns\n        \n    def get_numeric_indeces(self, num_cols, missing_cols):\n        result = []\n        for col in num_cols:\n            if col in missing_cols:\n                continue\n            result.append(list(self.data_.columns.values).index(col))\n        return result\n        \n    def normalize_data(self):\n        for col in self.numeric_cols:\n            max_d = self.data_[col].max()\n            min_d = self.data_[col].min()\n            self.data_[col] = (self.data_[col] - min_d)\/(max_d - min_d)\n        return self.data_\n        \n    def get_best(self, phone_idx, missing_cols = [], phones_amount=5,):\n        distances = []\n        phone = self.data_.iloc[phone_idx]\n        ind = self.get_numeric_indeces(self.numeric_cols, missing_cols)\n        res_data = self.data_.drop(columns=[])\n        for p in res_data.values:\n            dist = 0\n            for col in range(len(res_data.columns)):\n                if not col in ind:\n                    continue\n                dist = dist + np.absolute(float(p[col]) - float(phone[col]))\n            distances.append(dist)\n        res_data['distance'] = distances\n        res_data = res_data.sort_values('distance')\n        return res_data[1:phones_amount+1].index\n        ","9e06ee81":"finder = SimilarPhones(data)","95c133ab":"b_idxs = data[data.battery_size.isna()].index\nfinder.normalize_data()","0c1feeb7":"for idx in b_idxs:\n    name = data.iloc[idx].model_name\n    result = data.iloc[finder.get_best(idx, ['battery_size'], 4)]\n    result = result.battery_size.values\n    print(\"Phone : {}, missing data from similar phones : {}\".format(name,  result))\n    ","fdb57f62":"b_size = []\nfor idx in b_idxs:\n    result = data.iloc[finder.get_best(idx, ['battery_size'], 4)].battery_size.values\n    b_size.append(scipy.stats.mode(result)[0][0])\nb_size","2442ecc8":"temp = data[data.battery_size.isna()]\ntemp.battery_size = b_size\ndata[data.battery_size.isna()] = temp","a947309e":"data.isna().sum()","1a1fa879":"data[data.os.isna()]","1e936548":"temp = data[data.os.isna()]\ntemp.os = temp.os.fillna('Other')\ndata[data.os.isna()] = temp","92d006a7":"data.isna().sum()","788cac4f":"temp = data[data.lowest_price.isna()]\ntemp.lowest_price = temp.best_price\ntemp.highest_price = temp.best_price\ndata[data.lowest_price.isna()] = temp","38af8a0f":"data.isna().sum()","dbf74bc2":"data[data.screen_size.isna()]","52c06d6f":"s_idxs = data[data.screen_size.isna()].index\ns_size = []\n\nfor idx in s_idxs:\n    name = data.iloc[idx].model_name\n    result = data.iloc[finder.get_best(idx, ['screen_size'], 4)].screen_size.values\n    print(\"Phone : {}, missing data from similar phones : {}\".format(name,  result))\n    s_size.append(scipy.stats.mode(result)[0][0])","a8827576":"temp = data[data.screen_size.isna()]\ntemp.screen_size = s_size\ndata[data.screen_size.isna()] = temp","89bf6cea":"data.isna().sum()","73e7d674":"data[data.memory_size.isna()]","f8343e6c":"m_idxs = data[data.memory_size.isna()].index\n\nfor idx in m_idxs:\n    name = data.iloc[idx].model_name\n    result = data.iloc[finder.get_best(idx, ['memory_size'], 4)].memory_size.values\n    print(\"Phone : {}, missing data from similar phones : {}\".format(name,  result))","5f7c5b77":"data[data.memory_size.isna()].best_price.max()","8dfbc062":"data = data.fillna(0.032)","b43c5990":"data.isna().sum()","7a7a9925":"px.histogram(x=data.best_price, labels={'x': 'Best price'})","5e9a39f3":"px.histogram(x=data.lowest_price, labels={'x': 'Lowest price'})","4abb9c38":"px.histogram(x=data.highest_price, labels={'x': 'Highest price'})","206beedb":"px.histogram(x=data.screen_size, color_discrete_sequence=['lightgreen'], labels={'x': 'Screen size'})","1483e1b2":"px.histogram(x=data.battery_size, color_discrete_sequence=['lightgreen'], labels={'x': 'Battery size'})","a30b5eea":"memory_data = data.copy(True)\nmemory_data = memory_data.groupby('memory_size').count()\nmemory_data['memory'] = memory_data.index.astype('str')","0afdb517":"plt.figure(figsize=(19, 8))\nplt.bar(memory_data.memory, memory_data.release_date, color='lightgreen')\nplt.ylabel(\"Amount of phones\")\nplt.xlabel(\"Memory size\")\nplt.show()","e18ed5da":"d_data = data.copy(True)\nd_data = d_data.groupby('release_date').count()\nd_data['rel'] = d_data.index\nrel = d_data.index\nnew_rel = []\nfor d in rel:\n    if len(d) < 7:\n        temp = '0'+d\n    else:\n        temp = d\n    new_rel.append(float(temp.split('-')[1]+'.'+temp.split('-')[0]))\nd_data['rel'] = new_rel\nd_data = d_data.sort_values('rel')","18832303":"px.bar(x = d_data.index, y = d_data.brand_name, color_discrete_sequence=['lightgreen'], labels={'x': 'Month', 'y': 'Phones amount'})","c87e49b6":"s_data = data.copy(True)\ns_data = s_data.groupby('os').count()\ns_data = s_data.sort_values('brand_name', ascending=False)","0bafa9ae":"px.bar(x = s_data.index, y = s_data.brand_name, color_discrete_sequence=['orange'], \n       labels={'x': 'Operating System', 'y': 'Phones amount'})","8b21ddd3":"br_data = data.copy(True)\nbr_data = br_data.groupby('brand_name').count()\nbr_data = br_data.sort_values('model_name', ascending=False)","7bb0be0f":"px.bar(x = br_data.index, y = br_data.model_name, color_discrete_sequence=['orange'], \n       labels={'x': 'Brand', 'y': 'Phones amount'})","c08f152c":"p_data = data.copy(True)\np_data = p_data.sort_values('popularity', ascending=False)[:40]","78321cc8":"px.bar(x = p_data.model_name, y = p_data.popularity, color_discrete_sequence=['orange'], \n       labels={'x': 'Phone model', 'y': 'Popularity'})","87aac7ab":"plt.subplots(figsize=(12, 8))\nsns.heatmap(data.corr(), annot=True, square=True)\nplt.show()","42748dc1":"plt.subplots(figsize=(20, 8))\nsns.heatmap(scipy.stats.spearmanr(data)[0], annot=True, square=True, xticklabels=data.columns, yticklabels=data.columns)\nplt.show()","1e007818":"# <b><center>Thank you for reading this notebook! ","6dd5c17a":"<br>No we don't have any missing data for battery_size column. Let's move on.<br><br>","aec3192d":"## <b>Characteristics<br>","65220c92":"<br>As we can see, maximum price is 1558 hrivnyas, which is'nt really much, and a smartphone might cost much more. These phones might be all push-button. Moreover, they are similar to each other, as there are lots of nan values below.\nThat means, that they can't have lots of memory. As the most popular variant of memory size from output below is 0.032 GB, we will fill missing data with this value.<br><br>","dd1692f0":"<br>Pearson correlation says us, that the prices corellates between themselves mostly ideal. \n<br>Let's also check Spearman correlation.<br><br>","6a57b698":"As we can't predict lowest_price and highest_price with only best_price, we will guess, that these values are missing simply fill it with best_price values","e19220fa":"<br>We can see that several similar phones could have the same battery_size. We will simply choose the mode of each of this lists.<br><br>","c6232e31":"# <center><b>Hello guys!<br>\n   ","4fc17261":"### <br>Well, what can be seen from these plots:\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 highest_price and best_price distributions looks pretty similar;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 lowest_price's distribution differs a little bit from highest_price and best_price distributions, it could probably be so, because this data also &nbsp;&nbsp;&nbsp;&nbsp;contains used phones;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 such similarity can also be caused by the way we filled missing data for these columns;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 most of the phones have the price under 10000 hrivnyas;","4cfe9b91":"<br>Let's create an object of our class.<br><br>","588c4a3b":"<br>Check if everything worked fine.<br><br>","c1c6a146":"# <center><b><br>Correlation analysis","187cc9ca":"<br>As we can see, battery data is missing for two iPhone model's with different characteristics and for 4 Android model's.","65dc93a2":"# <center>Good luck!","05a619fe":"<br>Let's take a look at battery_sizes of the phones which are similar to ours.<br><br>","5fbccb6a":"<br>Let's take a look at the same phones for our phones with missing battery_size data.<br><br>","307efcbc":"<br>We have dealt with missing data, let's move on.<br><br>","1497d4e6":"## <br> <b>Popularity<br>","f8255c02":"<br>Let's fill missing data with these values.<br><br>","a72112b0":"Well, Spearman correlation thinks that only greatly highest_price correlates with lowest_price.\n<br>That could mean that dependence between these two columns might be stable.","2fb4979b":"## <center>This notebook was created to make it easier for you to understand Mobile Phones Market Data dataset and its character.\n        ","6017e648":"# <center><b> Preparing data","e4128418":"##   <center>Let's move on!","30718e3d":"<br>Let's use our SimilarPhones class to fill missing data in screen_size and memory_size columns. We will also choose the mode as we did before.<br><br>","4e25d305":"Let's create a method which will find 5 most similar phones for the phones with missing data. This way we will understand, which characteristics do have the similar phones.<br><br>","60f9bc00":"## <center>I hope it will be useful and interesting for you!\n          ","68e32cdd":"## <b> screen_size","0bb2d657":"Seems like we have work to do :)","a1d5eaaf":"# <b><center>Missing data","052821a5":"<br>Everything is ok, let's move on.","a572a286":"## <b> os","d336fc0f":"## <b>battery_size","be0a1256":"### <br>What can be seen from these plots:\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 screen_size varies mostly between 5 and 7 inches, there are also many phone with the size of screen 1.4-3 inches, which could be &nbsp;&nbsp;&nbsp;&nbsp;press-button phones;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 3k, 4k, and 5k mAh are the most popular sizes of the phone's batteries;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 most phones have its memory_size in the range of 16-256 GB, where 64 and 128 are the most popular memory_size;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 many phones also have 0.032 memory_size, which can be caused by previous missing data filling with this value;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 most phones have its memory_size in the range of 16-256 GB, where 64 and 128 are the most popular memory_size;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 many phones also have 0.032 memory_size, which can be caused by previous missing data filling with this value;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 more phones are being released as the time goes;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 october of 2020 had the highest amount of released phones.","9ef4090f":"Let's take a look at missing data.","2d08dc02":"<center><img src=\"https:\/\/i.cdn.newsbytesapp.com\/images\/l142_5951592045581.jpg\" width=700><\/img><\/center> ","6317b2da":"### <br>lowest_price and highest_price","65bbf027":"### <br>What can be seen from these plots:\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 the most of phones have Android OS;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 the amount of phones whith OxygenOS, WindowsPhone, EMUI and KAIOS is extremely low, which can mean, they aren't popular at all;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 Samsung, Xiaomi, Apple, Motorola and Sigma mobile are top-5 brands by number of phone models;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\u2022 iPhones, Google Pixel, Xiaomi Redmi along with Xiaomi Mi, Samsung Galaxy and Poco phones are the most popular phones.<br>","073096d9":"# <center> <b>EDA and visualization","af355cad":"<br>Check if it worked.<br><br>","199b7443":"<br>Check if everything worked.<br><br>","4bc2e045":"## <b>Prices<br>","0a364ea4":"<br>As we can't predict OS correctly (if we do, wrong predictions will seriously affect our data), we will fill missing values with 'Other'.<br><br>","fdf3b8fc":"<br><br>"}}