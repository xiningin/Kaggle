{"cell_type":{"14a52af5":"code","f2958251":"code","f582f737":"code","886e3163":"code","7b5c65ac":"code","97770fa7":"code","df712ea0":"code","80b7d993":"code","00858875":"code","3b095d7b":"code","d8437477":"markdown","cbca13bb":"markdown","bfd36a8d":"markdown","d7fdd453":"markdown","beb4c874":"markdown","36d043af":"markdown","1f7216cd":"markdown"},"source":{"14a52af5":"import os\nimport numpy as np\nimport pandas as pd\n\ndirectory = '..\/input\/g-research-crypto-forecasting'\nfile_path = os.path.join(directory, 'train.csv')\ndtypes = {\n    'timestamp': np.int64,\n    'Asset_ID': np.int8,\n    'Count': np.int32,\n    'Open': np.float64,\n    'High': np.float64,\n    'Low': np.float64,\n    'Close': np.float64,\n    'Volume': np.float64,\n    'VWAP': np.float64,\n    'Target': np.float64,\n}\ndata = pd.read_csv(file_path, dtype=dtypes)\ndata['Time'] = pd.to_datetime(data['timestamp'], unit='s')\ndata.drop('timestamp', axis=1, inplace=True)\n\nfile_path = os.path.join(directory, 'asset_details.csv')\ndetails = pd.read_csv(file_path)","f2958251":"price_column = 'Close'\nids = list(details.Asset_ID)\nchunks = []\nfor id in ids:    \n    asset = data[data.Asset_ID == id].copy()\n    asset.sort_values(by='Time', inplace=True)\n    asset.set_index(keys='Time', inplace=True)\n    asset['p1'] = asset[price_column].shift(freq='-1T')\n    asset['p16'] = asset[price_column].shift(freq='-16T')\n    asset['r'] = np.log(asset.p16\/asset.p1)\n    asset.drop(['p1', 'p16'], axis=1, inplace=True)\n    asset.reset_index(inplace=True)\n    chunks.append(asset)\n\ndata = pd.concat(chunks)\ndata.sort_values(by='Time', inplace=True)","f582f737":"data['w'] = data['Asset_ID'].map(details.set_index(keys='Asset_ID')['Weight'])\nweight_sum = details.Weight.sum()\n\ndata['weighted_asset_r'] = data.w * data.r\ntime_group = data.groupby('Time')\n\nm = time_group['weighted_asset_r'].sum() \/ time_group['w'].sum()\n#m = time_group['weighted_asset_r'].sum() \/ weight_sum\n\ndata.set_index(keys=['Time'], inplace=True)\ndata['m'] = m\ndata.reset_index(inplace=True)","886e3163":"data['m2'] = data.m ** 2\ndata['mr'] = data.r * data.m\n\nchunks = []\nfor id in ids:\n    # type: pd.DataFrame\n    asset = data[data.Asset_ID == id].copy()\n    asset.sort_values(by='Time', inplace=True)\n    asset.set_index(keys='Time', inplace=True)\n    #asset['mr_rolling'] = asset['mr'].rolling(window='3750T', min_periods=1).mean()\n    asset['mr_rolling'] = asset['mr'].rolling(window='3750T', min_periods=3750).mean()\n    #asset['m2_rolling'] = asset['m2'].rolling(window='3750T', min_periods=1).mean()\n    asset['m2_rolling'] = asset['m2'].rolling(window='3750T', min_periods=3750).mean()\n    asset.reset_index(inplace=True)\n    chunks.append(asset)\n    debug = 1\n\ndata = pd.concat(chunks)\ndata.sort_values(by='Time', inplace=True)\ndata['beta'] = data['mr_rolling'] \/ data['m2_rolling']","7b5c65ac":"data['Target_recreated'] = data['r'] - data['beta'] * data['m']","97770fa7":"data['Target_diff'] = np.abs(data['Target'] - data['Target_recreated'])\n\nprint(f'Average absolute error {data.Target_diff.mean()}')\nprint(f'Max absolute error {data.Target_diff.max()}')","df712ea0":"data['Target'].agg(['min', 'max'])","80b7d993":"(data.Target_recreated < -0.509351).sum()","00858875":"(data.Target_recreated > 0.96417).sum()","3b095d7b":"data['betaNA']=data['beta'].isna().astype('int')\ndata.groupby('Asset_ID').betaNA.mean()","d8437477":"Next, assign weight for each row. And calculate M(t). Note that M(t) is the same for all assets and depend only on time.\n\n$$M(t) = \\frac{\\sum_a w^a R^a(t)}{\\sum_a w^a}$$\n\nWe do not know if ${\\sum_a w^a}$ should be calculated for all assets or only for assets having data at time t.\n","cbca13bb":"Now we compare given and recreated Target.","bfd36a8d":"Then calculate return as per formula below. \n\n$$R^a(t) = log (P^a(t+16)\\ \/\\ P^a(t+1))$$\n\nThis is done for each asset separately. We do not know which price should be used. There are five different prices: Open, High, Low, Close, and VWAP. Probably there is a mix like Open price for time + 1 min, and Close for time + 16 min. We use **Close** price in calculation below.","d7fdd453":"After that, Beta is calculated. Bracket $\\langle .\\rangle$ represent the rolling average over time (3750 minute windows).\n\n$$\\beta^a = \\frac{\\langle M \\cdot R^a \\rangle}{\\langle M^2 \\rangle}$$","beb4c874":"How Many Row with N=0","36d043af":"And finallly Target is calculated.\n$$\\text{Target}^a(t) = R^a(t) - \\beta^a M(t)$$","1f7216cd":"Fork from https:\/\/www.kaggle.com\/alexfir\/recreating-target with min_periods=3750 in rolling, when the previous 3750 rows there is a gap in the data \u03b2M(t) = 0 \n\nIn this notebook we try to recreate Target calculation described in [Tutorial to the G-Research Crypto Competition](https:\/\/www.kaggle.com\/cstein06\/tutorial-to-the-g-research-crypto-competition\/notebook#Building-your-prediction-model).\n"}}