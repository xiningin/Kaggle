{"cell_type":{"1d786bfb":"code","2300567b":"code","aafb4049":"code","f904d1e3":"code","a079ec5a":"code","f34a6796":"code","901fd636":"code","7d2a071b":"code","c75e2cee":"code","46fe08e3":"code","c0f5cdf1":"code","8dc3aa66":"markdown","0a8b9361":"markdown","da964b77":"markdown","0f8e93bd":"markdown","a2b30cf1":"markdown","aaf4aeb2":"markdown"},"source":{"1d786bfb":"# Import data and relevant libraries\n\nimport sqlite3\nimport xml.etree.ElementTree as ET\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nimport geopandas as gpd\nimport descartes as dscrts\nimport io\n\nfrom matplotlib import pyplot as plt\nfrom matplotlib.colors import rgb2hex\nfrom bokeh.io import save, show, output_file, output_notebook, reset_output, export_png\nfrom bokeh.plotting import figure\nfrom bokeh.palettes import brewer\nfrom bokeh import palettes\nfrom bokeh.models.callbacks import CustomJS\nfrom bokeh.models.widgets import Div\nfrom bokeh.layouts import widgetbox, row, column\nfrom bokeh.models import (\n    GeoJSONDataSource, ColumnDataSource, ColorBar, Slider, Spacer,\n    HoverTool, TapTool, Panel, Tabs, Legend, Toggle, LegendItem,\n)\n\n# Create your connection.\ncnx = sqlite3.connect('..\/input\/soccer\/database.sqlite')\n\n# Import tables from football database\n\ndf_match = pd.read_sql_query(\"SELECT * FROM Match\", cnx)\ndf_league = pd.read_sql_query(\"SELECT * FROM League;\", cnx)\ndf_team = pd.read_sql_query(\"SELECT * FROM Team;\", cnx)\n\n\n### DATA PREPARATION\n\n## The data does not have any missing values as each game has all the statistics needed for my analysis\n\n# Add countries to League dataset\n\ncountries = ['Belgium', 'United Kingdom', 'France', 'Germany', 'Italy', 'Netherlands', 'Poland', 'Portugal', 'Scotland', 'Spain', 'Switzerland']\n\ndf_league['country'] = pd.Series(countries)\n\n# Import Europe shape file for map\n\ndf_europe = gpd.read_file('..\/input\/eushapefile\/NUTS_RG_20M_2016_3035_LEVL_0.shp')\ndf_europe = df_europe.to_crs({'init':'epsg:2154'})\n\n# Import country codes csv for Europe shape file\n\ndf_countrycodes = pd.read_csv('..\/input\/eushapefile\/Ccodes.csv')\n\n# Create a result variable\n\ndef get_result(row):\n    \"\"\"Calculate game result based on home and away goals\"\"\"\n    \n    if row['home_team_goal'] == row['away_team_goal']:\n        val = 0\n    elif row['home_team_goal'] > row['away_team_goal']:\n        val = 1\n    elif row['home_team_goal'] < row['away_team_goal']:\n        val = -1\n    else:\n        value = 99\n    return val\n\ndf_match['result'] = df_match.apply(get_result, axis=1)\n\n\n## Create a map with home win percentages for all the leagues in our database\n\ndf_map = df_match.loc[:, ['league_id','season','result']]\n\n# Calculate number of home wins\n\ndf_map['result'] = [\"Hw\" if x ==1 else \"Oth\" for x in df_map['result']]\n\n# Create crosstab of wome wins per league and season\n\ndf_map = pd.crosstab([df_map['league_id'],df_map['season']], df_map['result'])\n\ndf_map.reset_index(inplace=True)\n\n# Calculate home win percentage\n\ndf_map['Hwin_perc'] = (df_map['Hw'] *100)\/(df_map['Oth'] + df_map['Hw'])\n\n# Create a dictionary with legue ids and country names from league dataframe\n\nlgname_dict = pd.Series(df_league.name.values,index=df_league.country_id).to_dict()\n\n# Add league names to our Europe shapefile dataframe\n\n# df_map['league_name'] = df_map['league_id'].map(lgname_dict)\n\n## Attach league win data to Europe shapefile\n\n# Remove unneeded columns from Europe shapefile\n\ndf_europe = df_europe.drop(df_europe.columns[[0, 1, 2, 3]], axis=1)\n\n# Merge with country codes dataframe\n\ndf_europe = df_europe.merge(df_countrycodes, left_on='FID', right_on='Code')\n\n# Create a dictionary with legue ids and country names from league dataframe\n\nlg_dict = pd.Series(df_league.name.values,index=df_league.country).to_dict()\n\n# Add league names to our Europe shapefile dataframe\n\ndf_europe['league'] = df_europe['Name'].map(lg_dict)\n\n# Pivot our league home win percentage dataframe so it can be merged with shapefile\n\ndf_map = df_map.pivot(index='league_id', columns='season', values='Hwin_perc')\n\n# Create inverted mapping to add league ids to shapefile\n\ninv_map = {v: k for k, v in lgname_dict.items()}\n\n# Add league id column to shapefile\n\ndf_europe['league_id'] = df_europe['league'].map(inv_map)\n\n# Merge home win percentage on league id column\n\ndf_europe = pd.merge(df_europe, df_map, on='league_id', how='left')\n\n# Drop unneeded columns used for merging\n\ndf_europe = df_europe.drop(df_europe.columns[[0, 3, 4, 6]], axis=1)\n\n# Melt data into long format so each season has a seperate row\n\ndf_europe = pd.melt(df_europe,id_vars=['Name','league','geometry'],var_name='season', value_name='hwin_perc')\n\n#Replace NaN values to string 'No data'.\n# df_europe.hwin_perc.fillna('No data', inplace = True)\n\n# Add in years in order to have numerical season values\nseasons = df_europe.season.unique().tolist()\nyears = range(2009,2017)\nyear_dict = dict(zip(seasons, years))\ndf_europe['year'] = df_europe['season'].map(year_dict)\n\n# Rename United Kingdom to England\ndf_europe['Name'] = df_europe['Name'].replace({'United Kingdom': 'England'})\n\n# Remove distant territories from France and Portugal to make a concise map of Europe\n\ndef remove_multi(cloc, cname):\n    \"\"\"Remove extra territories from geopolygon such as distant islands.\"\"\"\n    \n    mp = df_europe.geometry.loc[cloc]\n    mp_updated = mp[0:1]\n    df_europe['geometry'] = np.where((df_europe.Name == cname),mp_updated,df_europe.geometry)\n\nremove_multi(3, \"France\")\nremove_multi(19, \"Portugal\")\nremove_multi(0, \"Spain\")","2300567b":"# Set figure size\n\nplt.rcParams[\"figure.figsize\"] = (10,6)\n\n# Create a horizontal bar graph to visualize distribution of results\n\nfig, ax = plt.subplots()\n\n# Create labels\n\nlbls1 = ['Away Win', 'Draw', 'Home Win']\ny_pos = np.arange(len(lbls1))\n\n# Create results count\n\nrslts = df_match['result'].value_counts().sort_values(ascending=True)\n\n# Set chart parameters\n\nax.barh(y_pos, rslts, align='center')\nax.set_yticks(y_pos)\nax.set_yticklabels(lbls1)\n\nax.set_xlabel('Number of games')\nax.set_title('Distribution of results', size = 14)\n\n\n\nfor i, v in enumerate(rslts):\n    ax.text(v - 1000, i, str(v),  fontsize='12', color = \"white\")\n\nplt.show()","aafb4049":"fig1, ax1 = plt.subplots()\nax1.pie(df_match['result'].value_counts(), labels = [\"Home Win\",\"Draw\",\"Away Win\"], startangle=90, autopct='%.1f%%', shadow=True)\nax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.\n\nplt.show()","f904d1e3":"# Set figure size\n\nplt.rcParams[\"figure.figsize\"] = (15,8)\n\n# Create a crosstab of leagues and match results\n\ndf_lgrslts = pd.crosstab(df_match['league_id'], df_match['result'])\n\n# Transform the absolute values into normalized percentage values\n\ntotals = [i+j+k for i,j,k in zip(df_lgrslts.iloc[:,0], df_lgrslts.iloc[:,1], df_lgrslts.iloc[:,2])]    \nHloss = [i \/ j * 100 for i,j in zip(df_lgrslts.iloc[:,0], totals)]\nDraw = [i \/ j * 100 for i,j in zip(df_lgrslts.iloc[:,1], totals)]\nHwin = [i \/ j * 100 for i,j in zip(df_lgrslts.iloc[:,2], totals)]\n\n# Setting up variables for stacked bar chart\n\ndf_lgrslts.index = df_lgrslts.index.map(str)    \n    \nleagues = df_lgrslts.index\nnames = df_league['name']\nr = [0,1,2,3,4,5,6,7,8,9,10]\n\n# Plot bars (one on top of another)\n\nplt.bar(r, Hwin, width=0.8, label='Home Wins', color='#115AEC')\nplt.bar(r, Draw,  bottom=Hwin, width=0.8, label='Draws', color='#11CBEC')\nplt.bar(r, Hloss, bottom=[i+j for i,j in zip(Hwin, Draw)], width=0.8, label='Away Wins', color='#A6E5C5')\n\n# Set other graph parameters\n\nplt.xticks(r, names, rotation = 45, ha='right')\nplt.ylabel(\"Percentage of Games\", size = '14')\nplt.xlabel(\"Leagues\", size = '14')\nplt.legend(loc=\"upper right\")\nplt.title(\"Distribution of results across European Leagues\", size = '16')\n\n# Plot percent values on bars\n\nfor a,b in zip(r, Hwin):\n    plt.text(a - 0.22, b - 25, str(round(b, 1)), color = 'white', size = '13')\n    \nfor a,b in zip(r, Hloss):\n    plt.text(a - 0.22, b + 55, str(round(b, 1)), color = 'black', size = '13')\n    \nfor a,b in zip(r, Draw):\n    plt.text(a - 0.22, b + 32, str(round(b, 1)), color = 'white', size = '13')\n\n# Show plot\n\nplt.show()","a079ec5a":"# Create bins to color each country\nbins = range(32,58,2)\n# create stylish labels\nbin_labels = [f'\u2264{bins[1]}%'] + [f'{bins[i]}-{bins[i+1]}%' for i in range(1,len(bins)-2)] + [f'>{bins[-2]}%']\n# assign each row to a bin\ndf_europe['bin'] = pd.cut(\n    df_europe['hwin_perc'], bins=bins, right=True, include_lowest=True, precision=0, labels=bin_labels,\n).astype(str)\n\n# Add a 'No data' bin for countries without data\ndf_europe.loc[df_europe['hwin_perc'].isna(), 'bin'] = 'No data'\ndf_europe.hwin_perc.fillna('No data', inplace = True)\n\n# Define a color palette\npalette = palettes.Blues256[::20]\npalette = palette[::-1]\n\n# Assign home win percentage to a color\ndef val_to_color(value, nan_color='#d9d9d9'):\n    \"\"\"Assigns a color to each value from our palette range.\"\"\"\n    \n    if isinstance(value, str): return nan_color\n    for i in range(1,len(bins)):\n        if value <= bins[i]:\n            return palette[i-1]\n\ndf_europe['color'] = df_europe['hwin_perc'].apply(val_to_color)\n\n# Assign x coordinates\ndef bin_to_cbar_x(value):\n    \"\"\"Assigns x co-ordinates to create bars for each bin\"\"\"\n    \n    if value == 'No data': return -2\n    for i,b in enumerate(bin_labels):\n        if value == b:\n            return 5*(i)\n\ndf_europe['cbar_x'] = df_europe['bin'].apply(bin_to_cbar_x)\n# Assign width\ndf_europe['cbar_w'] = df_europe['hwin_perc'].apply(lambda x: 2 if x == 'No data' else 2.7)\n\n# Create color palette for the graph\ncountries = sorted(df_europe[df_europe[\"bin\"] != \"No data\"][\"Name\"].unique())\nn_country = len(countries)\n# print(\"%d countries to plot\" % n_country)\ncmap = plt.get_cmap('gist_ncar', n_country)\ncountry_palette = [rgb2hex(cmap(i)[:3]) for i in range(cmap.N)]","f34a6796":"# define the Output file\nreset_output()\noutput_notebook()\n#output_file(\"hwin_trends.html\", title=\"Home Win Percentage across seasons\", mode=\"inline\")\n\n# Input sources\ndf_europe.sort_values(by=[\"Name\",\"year\"], inplace=True)\n# source that will contain all necessary data for the map\ngeosource = GeoJSONDataSource(geojson=df_europe.to_json())\n# source that contains the data that is actually shown on the map (for a given year)\ndisplayed_src = GeoJSONDataSource(geojson=df_europe[df_europe['year'].isin(['No data', 2009])].to_json())\n# source that will be used for the graph (we don't need the countries shapes for this)\ncountry_source = ColumnDataSource(df_europe[df_europe['Name'] == \"France\"].drop(columns=[\"geometry\"]))\n\n# Define the Tools\n\n# slider to select the year\nslider = Slider(title='Year',start=2009, end=2016, step=1, value=2009)\n\n# hover tool for the map\nmap_hover = HoverTool(tooltips=[\n    ('League','@league'),\n    ('Home Win Percentage (%)', '@hwin_perc')\n])\n\n# hover tool for the graph\ngraph_hover = HoverTool(tooltips=[\n    ('League','@league'),\n    ('Home Win Percentage (%)', '@hwin_perc'),\n    ('Year', '@year')\n])\n\n# button for the animation\nanim_button = Toggle(label=\"\u25b6 Play\", button_type=\"success\", width=50, active=False)\n\n#################\n\n\n# create map figure\np = figure(\n    title = 'Home win percentage in top European leagues',\n    plot_height=400 , plot_width=600,\n    toolbar_location=\"right\", tools=\"tap,pan,wheel_zoom,box_zoom,save,reset\", toolbar_sticky=False,\n    active_scroll=\"wheel_zoom\",\n)\np.title.text_font_size = '16pt'\np.xgrid.grid_line_color = None\np.ygrid.grid_line_color = None\np.axis.visible = False\n\n# Add hover tool\np.add_tools(map_hover)\n\n# Add patches (countries) to the figure\npatches = p.patches(\n    'xs','ys', source=displayed_src,\n    fill_color='color',\n    line_color='black', line_width=0.25, fill_alpha=1,\n    hover_fill_color='color',\n)\n# outline when we hover over a country\npatches.hover_glyph.line_color = '#3bdd9d'\npatches.hover_glyph.line_width = 3\npatches.nonselection_glyph = None\n\n\n# create the interactive colorbar\np_bar = figure(\n    title=None, plot_height=80 , plot_width=750,\n    tools=\"tap\", toolbar_location=None\n)\np_bar.xgrid.grid_line_color = None\np_bar.ygrid.grid_line_color = None\np_bar.outline_line_color = None\np_bar.yaxis.visible = False\n\n# set the title and ticks of the colorbar\np_bar.xaxis.axis_label = \"% Home Wins\"\np_bar.xaxis.ticker = sorted(df_europe['cbar_x'].unique())\np_bar.xaxis.major_label_overrides = dict([(i[0],i[1]) for i in df_europe.groupby(['cbar_x','bin']).describe().index])\np_bar.xaxis.axis_label_text_font_size = \"10pt\"\np_bar.xaxis.major_label_text_font_size = \"8pt\"\n\n\n# activate the hover but hide tooltips\nhover_bar = HoverTool(tooltips=None)\np_bar.add_tools(hover_bar)\n\n# plot the rectangles for the colorbar\ncbar = p_bar.rect(x='cbar_x', y=0, width='cbar_w', height=1,\n    color='color', source=displayed_src,\n    hover_line_color='#3bdd9d', hover_fill_color='color')\n\n# outline when we hover over the colorbar legend\ncbar.hover_glyph.line_width = 4\ncbar.nonselection_glyph = None\n\n#################\n\n# create the graph figure\np_country = figure(\n    title=\"Home win rate in European leagues\", plot_height=500 , plot_width=800,\n    tools=\"pan,wheel_zoom,save\", active_scroll=\"wheel_zoom\", toolbar_location=\"right\",\n)\np_country.title.text_font_size = '14pt'\np_country.xaxis.axis_label = \"Season\"\np_country.yaxis.axis_label = \"Home Win Percentage (%)\"\np_country.axis.major_label_text_font_size = \"12pt\"\np_country.axis.axis_label_text_font_size = \"14pt\"\n\n# plot data on the figure\nline_plots = {}\nlegend_items = {}\nfor i, country in enumerate(countries):\n    # get subset of data corresponding to a country\n    country_source = ColumnDataSource(df_europe[df_europe['Name'] == country].drop(columns=[\"geometry\"]))\n    # plot\n    line = p_country.line(\"year\", \"hwin_perc\", source=country_source,\n                      color=country_palette[i], line_width=2)\n    circle = p_country.circle(\"year\", \"hwin_perc\", source=country_source,\n                          line_color=\"darkgrey\", fill_color=country_palette[i], size=8)\n    # used later in the interactive callbacks\n    line_plots[country] = [line, circle]\n    legend_items[country] = LegendItem(label=country, renderers=[line, circle])\n    # # only display France at first\n    # if country != \"France\":\n    #     line.visible = False\n    #     circle.visible = False\n\ndefault_legend = [\n    (\"Belgium\", line_plots[\"Belgium\"]),\n    (\"England\", line_plots[\"England\"]),              \n    (\"France\", line_plots[\"France\"]),\n    (\"Germany\", line_plots[\"Germany\"]),\n    (\"Italy\", line_plots[\"Italy\"]),\n    (\"Netherlands\", line_plots[\"Netherlands\"]),\n    (\"Poland\", line_plots[\"Poland\"]),\n    (\"Portugal\", line_plots[\"Portugal\"]),\n    (\"Spain\", line_plots[\"Spain\"]),\n    (\"Switzerland\", line_plots[\"Switzerland\"])    \n]\nlegend = Legend(items=default_legend, location=\"top_center\")\nlegend.click_policy = \"hide\"\np_country.add_layout(legend, 'right')\n\n# Add hover tool\np_country.add_tools(graph_hover)\n\n#######################\n\n\n# JS callbacks\n\n# Update the map on slider change\nslider_callback = CustomJS(args=dict(slider=slider, source=geosource, displayed_src=displayed_src), code=\"\"\"\n    var year = slider.value;\n    var show = [year, 'No data'];\n    var data = {};\n    columns = Object.keys(source.data);\n    columns.forEach(function(key) {\n        data[key] = [];\n    });\n    for (var i = 0; i < source.get_length(); i++){\n        if (show.includes(source.data['year'][i])){\n            columns.forEach(function(key) {\n                data[key].push(source.data[key][i])\n            });\n        }\n    }\n    displayed_src.data = data;\n    displayed_src.change.emit();\n\"\"\")\nslider.js_on_change('value', slider_callback)\n\n\n# Add callback on country click\nplot_callback = CustomJS(args=dict(\n    csource=country_source, source=geosource, displayed_src=displayed_src, line_plots=line_plots, legend=legend, legend_items=legend_items), code=\"\"\"\n    \/\/ only continue if a country was selected\n    var ixs = displayed_src.selected.indices;\n    if (ixs.length == 0) { return; }\n    \n    \/\/ init\n    var data = {};\n    var items = [];\n    countries = [];\n    columns = Object.keys(source.data);\n    columns.forEach(function(key) {\n        data[key] = [];\n    });\n    \n    \/\/ hide all plots\n    for (var country in line_plots) {\n        var line = line_plots[country][0];\n        var circle = line_plots[country][1];\n        line.visible = false;\n        circle.visible = false;\n    }\n    \n    \/\/ loop over the selected countries\n    ixs.forEach(function(ix) {\n        \/\/ identify corresponding country\n        country = displayed_src.data[\"Country\"][ix];\n        countries.push(country);\n    });\n    \/\/ sort them in order\n    countries.sort()\n    \/\/ display the corresponding glyphs and legend\n    countries.forEach(function(country) {\n        line = line_plots[country][0];\n        circle = line_plots[country][1];\n        line.visible = true;\n        circle.visible = true;\n        items.push(legend_items[country]);\n        \n        for (var i = 0; i < source.get_length(); i++){\n            if (source.data['Country'][i] == country) {\n                columns.forEach(function(key) {\n                    data[key].push(source.data[key][i])\n                });\n            }\n        }\n    });\n    legend.items = items;\n    csource.data = data;\n    csource.change.emit();\n\"\"\")\ndisplayed_src.selected.js_on_change('indices', plot_callback)\n\n# add animation\nupdate_interval = 500 # in ms\nanim_callback = CustomJS(args=dict(slider=slider, update_interval=update_interval), code=\"\"\"\n    var button = cb_obj;\n    if (button.active == true){\n        button.label = \"\u25fc Stop\";\n        button.button_type = \"danger\";\n        mytimer = setInterval(update_year, update_interval);           \n    } else {\n        button.label = \"\u25b6 Play\";\n        button.button_type = \"success\";\n        clearInterval(mytimer);\n    }\n\n    function update_year() {\n        year = slider.value;\n        if (year < 2016) {\n            slider.value += 1;\n        } else {\n            slider.value = 2009;\n        }\n    }\n\"\"\")\nanim_button.callback = anim_callback\n\n","901fd636":"# arrange display with tabs\ntab_map = Panel(title=\"Map\",\n    child=column(\n        p, # map\n        p_bar, # colorbar\n        row(widgetbox(anim_button), Spacer(width=10), widgetbox(slider)) # animation button and slider\n    ))\ntab_chart = Panel(title=\"Chart\", child=column(p_country))\ntabs = Tabs(tabs=[ tab_map, tab_chart ])\n\n# Save the document\nfooter = Div(text=\"\"\"\nYear corresponds to season end i.e. 2009 corresponds to season 2008-2009<\/br >\n\"\"\")\nlayout = column(tabs, footer)\nshow(layout)","7d2a071b":"## Create league table rankings by season for EPL\n\n# Isolate EPL matches\n\nEPL = df_match[df_match['league_id'] == 1729]\n\n## For home matches\n\n# Create \n\nEPL_home = pd.pivot_table(EPL,index=['season', 'home_team_api_id', 'stage'],values = ['home_team_goal','away_team_goal'])\n\n# Create a points variable for home games\n\ndef hpoints(row):\n    \"\"\"Calculate points for a team's home games based on result\"\"\"\n    if row['home_team_goal'] == row['away_team_goal']:\n        val = 1\n    elif row['home_team_goal'] > row['away_team_goal']:\n        val = 3\n    elif row['home_team_goal'] < row['away_team_goal']:\n        val = 0\n    else:\n        value = 99\n    return val\n\n# Create a points variable for away games (scoring is reversed as away team gets 3 points)\n\ndef apoints(row):\n    \"\"\"Calculate points for a team's home games based on result\"\"\"\n    if row['home_team_goal'] == row['away_team_goal']:\n        val = 1\n    elif row['home_team_goal'] > row['away_team_goal']:\n        val = 0\n    elif row['home_team_goal'] < row['away_team_goal']:\n        val = 3\n    else:\n        value = 99\n    return val\n\n# Calculate home points\n\nEPL_home['hpoints'] = EPL_home.apply(hpoints, axis=1)\n\n# Sum home points\n\nEPL_home = pd.pivot_table(EPL_home,index=['season', 'home_team_api_id'],values = ['hpoints'], aggfunc=np.sum)\n\n## For away matches\n\nEPL_away = pd.pivot_table(EPL,index=['season', 'away_team_api_id', 'stage'],values = ['home_team_goal','away_team_goal'])\n\n# Create a result variable\n\nEPL_away['apoints'] = EPL_away.apply(apoints, axis=1)\n\n# Sum away points by team\n\nEPL_away = pd.pivot_table(EPL_away,index=['season', 'away_team_api_id'],values = ['apoints'], aggfunc=np.sum)\n\n## Combine home and away points into one consolidated dataframe\n\ndf_EPL = pd.DataFrame(EPL_home)\n\n# Test to make sure away points are in correct order (should be same for both columns)\n\ndf_EPL['apoints'] = EPL_away['apoints']\n\n# Create away points column in consolidated dataframe and copy in values from away games dataframe\n\ndf_EPL['apoints'].equals(EPL_away['apoints'])\n\n# Calculate total points\n\ndf_EPL['tpoints'] = df_EPL['hpoints'] + df_EPL['apoints']\n\n# Sort dataframe by season and points to mimic league table standings by season\n\ndf_EPL.sort_values(by=['season','tpoints'], inplace=True, ascending = False)\n\n# Convert index values to columns\n\ndf_EPL.reset_index(inplace=True)\n\n# Rename column\n\ndf_EPL = df_EPL.rename(columns={'home_team_api_id': 'team_id'})\n\n# Create a dictionary with team ids and names from team dataframe\n\nteam_dict = pd.Series(df_team.team_long_name.values,index=df_team.team_api_id).to_dict()\n\n# Add team names to our EPL_home dataframe\n\ndf_EPL['team_name'] = df_EPL['team_id'].map(team_dict)","c75e2cee":"# Set figure size\n\nplt.rcParams[\"figure.figsize\"] = (10,10)\n\nimport statistics\n\n# Initialize empty listss\n\nposition = list(range(0,20))\nhpoints = []\napoints = []\ntpoints = []\n\n# Calculate average points by each position\n\nfor i in range(20):\n        tpoints.append(statistics.mean(df_EPL['tpoints'][i::20]))\n        hpoints.append(statistics.mean(df_EPL['hpoints'][i::20]))\n        apoints.append(statistics.mean(df_EPL['apoints'][i::20]))\n\n# Create a dataframe from our lists        \n        \nframe = { 'position': position, 'hpoints': hpoints, 'apoints': apoints, 'tpoints': tpoints } \n\ndf_avg = pd.DataFrame(frame) \n\n## Create a dumbbell chart for average points per EPL position\n\ndf_avg = df_avg.sort_values(by='tpoints')\nmy_range=range(1,len(df_avg.index)+1)\nplt.hlines(y=my_range, xmin=df_avg['hpoints'], xmax=df_avg['apoints'], color='grey', alpha=0.4)\nplt.scatter(df_avg['apoints'], my_range, color='navy', alpha=1, label='Away points')\nplt.scatter(df_avg['hpoints'], my_range, color='gold', alpha=0.8 , label='Home points')\nplt.legend()\n\n# Vertical Lines\nplt.vlines(x=0, ymin=0, ymax=26, color='black', alpha=1, linewidth=1, linestyles='dotted')\nplt.vlines(x=10, ymin=0, ymax=26, color='black', alpha=1, linewidth=1, linestyles='dotted')\nplt.vlines(x=20, ymin=0, ymax=26, color='black', alpha=1, linewidth=1, linestyles='dotted')\nplt.vlines(x=30, ymin=0, ymax=26, color='black', alpha=1, linewidth=1, linestyles='dotted')\nplt.vlines(x=40, ymin=0, ymax=26, color='black', alpha=1, linewidth=1, linestyles='dotted')\nplt.vlines(x=50, ymin=0, ymax=26, color='black', alpha=1, linewidth=1, linestyles='dotted')\n\n# Add title and axis names\nplt.yticks(my_range, list(range(20,0,-1)))\nplt.title('Average points per final league position in EPL', loc='left')\nplt.xlabel('Number of points')\nplt.show()","46fe08e3":"# Initialize empty listss\n\nposition = list(range(0,20))\nhpoints = []\napoints = []\ntpoints = []\n\n# Calculate total points by each position\n\nfor i in range(20):\n        tpoints.append(sum(df_EPL['tpoints'][i::20]))\n        hpoints.append(sum(df_EPL['hpoints'][i::20]))\n        apoints.append(sum(df_EPL['apoints'][i::20]))\n\n# Create a dataframe from our lists        \n        \nframe = { 'position': position, 'hpoints': hpoints, 'apoints': apoints, 'tpoints': tpoints } \n\ndf_sum = pd.DataFrame(frame) \n\ndf_sum['diff'] = df_sum['hpoints'] - df_sum['apoints']\ndf_sum['prop'] = (df_sum['hpoints'] \/ df_sum['tpoints']) *100\n\n#####\n\n# libraries\nimport pandas as pd\nimport matplotlib.pyplot as plt\n \n\n# Reorder it following the values:\ndf_sum = df_sum.sort_values(by='position', ascending = 'True')\nmy_range=range(1,len(df_sum.index)+1)\n \n# Create a color if the group is \"B\"\n# my_color=np.where(df_sum ['group']=='B', 'orange', 'skyblue')\n# my_size=np.where(df_sum ['group']=='B', 70, 30)\n \n# The vertival plot is made using the hline function\n# I load the seaborn library only to benefit the nice looking feature\nimport seaborn as sns\nplt.hlines(y=my_range, xmin=0, xmax=df_sum['prop'], alpha=0.4)\nplt.scatter(df_sum['prop'], my_range, alpha=1)\n \n# Add title and axis names\nplt.yticks(my_range, df_sum['position']+1)\nplt.title(\"Proportion of points won at home\", loc='left')\nplt.xlabel('Percentage of points')\nplt.ylabel('Position')","c0f5cdf1":"# Set figure size\n\nplt.rcParams[\"figure.figsize\"] = (8,8)\n\ndef plot_dumbell_chart(season):\n    \"\"\"Plots dumbbell chart comparing home and away points for all 20 teams in a given season.\"\"\"\n\n    \n    df_season = df_EPL[df_EPL['season'] == season]\n    df_season = df_season.sort_values(by='tpoints')\n    my_range=range(1,len(df_season.index)+1)\n    plt.hlines(y=my_range, xmin=df_season['hpoints'], xmax=df_season['apoints'], color='grey', alpha=0.4)\n    plt.scatter(df_season['apoints'], my_range, color='navy', alpha=1, label='Away points')\n    plt.scatter(df_season['hpoints'], my_range, color='gold', alpha=0.8 , label='Home points')\n    plt.legend()\n\n# Vertical Lines\n    plt.vlines(x=0, ymin=0, ymax=26, color='black', alpha=1, linewidth=1, linestyles='dotted')\n    plt.vlines(x=10, ymin=0, ymax=26, color='black', alpha=1, linewidth=1, linestyles='dotted')\n    plt.vlines(x=20, ymin=0, ymax=26, color='black', alpha=1, linewidth=1, linestyles='dotted')\n    plt.vlines(x=30, ymin=0, ymax=26, color='black', alpha=1, linewidth=1, linestyles='dotted')\n    plt.vlines(x=40, ymin=0, ymax=26, color='black', alpha=1, linewidth=1, linestyles='dotted')\n    plt.vlines(x=50, ymin=0, ymax=26, color='black', alpha=1, linewidth=1, linestyles='dotted')    \n    \n# Add title and axis names\n    plt.yticks(my_range, df_season['team_name'])\n    plt.title(season, loc='left')\n    plt.xlabel('Number of points')\n    plt.show()\n\nseason_vals = sorted(df_EPL.season.unique())\n\nfor i in season_vals:\n  plot_dumbell_chart(i)","8dc3aa66":"We see that from our total of 25,979 about 46% are home wins, 29% are draws and the away team wins only 25% of the time. On average it is twice as likely for a home team to win as the away team for a randomly selected game.","0a8b9361":"### Variations across league\n\nWe see that most of the major leagues exhibit the same general trends when it comes to home team advantage. There are some slight variations with home teams in Spain being particularly formidable whilst away teams in Scotland enjoy the most wins, but we can't see any significant differences.","da964b77":"### Appendix:\n\nFor anyone looking to reminisce I plotted out dumbbell charts comparing home and away points by PL season from 2008-09 to 2015-16.\n\n","0f8e93bd":"# Exploring Home Advantage in European Football\n\n\n\n\n\n![Football](https:\/\/images.pexels.com\/photos\/47730\/the-ball-stadion-football-the-pitch-47730.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260)\n\n\n\n\nAs with most sports, football games often do not take place in a neutral venue with one team playing in its home stadium. The home team gets to play in familiar surroundings, enjoys the support of the home crowd and does not have to travel far. Meanwhile the away team might has to contend with the weather (\"[can they do it on a cold rainy night in Stoke?](https:\/\/www.bbc.com\/sport\/football\/35672813)\"), different time zones and possible [referee bias](https:\/\/www.tandfonline.com\/doi\/full\/10.1080\/02640410601038576).\n\nBut, just how important is home advantage and how much of a role does it play? This question is of interest to anyone involved with football teams, as well fans who might bet games and of course the gambling industry itself. If playing at home affects the outcome of a game then betting odds should reflect this fact.\n\n\nIn order to probe this question I used data from the leagues in eleven European countries, covering eight seasons (2012-2016). The dataset is publically available here - https:\/\/www.kaggle.com\/hugomathien\/soccer.\n\nI am looking to answer the following questions in this blog:\n\n* To what extent does home advantage affect results?\n* Are there any geographical or temporal trends?\n* In the English Premier League, how does home advantage vary with final league position?\n\n\nFirst I took a look at the distibution of results across the whole dataset. Remember that in football a game can end in a home win, away win or draw.\n\n\n\n### To what extent does home advantage affect results?\n","a2b30cf1":"### Geographic and temporal trends\n\nI thought that perhaps I could discover some sort of geographic pattern to the home win percentage, but the map above doesn't seem to indicate one. A plausible explanation for this is that home advantage is affected by a lot of factors that vary from year to year across different leagues.\n\nOn the other hand we see that home win percentage does seem to decline over the course of the eight seasons. There are a variety of reasons for this shift. For one thing improvements in travel infrastructure have made going to away games safer, quicker and more comfortable. Tactics have also evolved, with many [managers opting for counterattaking tactics](http:\/\/backpagefootball.com\/shifting-sands-football-tactics-rise-counter-attack\/114638\/) which are more effective away from home. The [trend of declining atmosphers in top stadiums](https:\/\/www.vice.com\/en_us\/article\/53xwp8\/squeezed-fans-silent-stadiums-the-myth-of-premier-league-atmosphere) has also made it less intimidating to play on hostile territory.","aaf4aeb2":"### Variation by final league position in EPL\n\n\nI also wondered how home advantage varies with a team's final league position. Do relegation scrappers depend on their home form to stay in the league? Is the title won by winning away at your rivals?\n\nPlotting out the average home and away points by final league position over the 8 seasons shows that all teams, regardless of their final league position, scored more points at home than away. \n\nHowever there are some interesting patterns at play. For starters we notice that there is not a lot of difference in away points on average between the top two, but there is a significant different in home points. The team that won the league scored 51 points on average at home, indicating that the stadium of the champions would be transformed into a home fortress. The data suggests that any team aiming to win the title should ensure it wins at home and avoids defeat in top-of-the-table clashes.\n\nWe also see the importance of home points at the bottom of the table. For relegations battlers there is not a significant difference between positions and to when it comes to away points. In fact winning a couple of extra games is often the difference between safety and relagation."}}