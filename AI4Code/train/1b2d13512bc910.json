{"cell_type":{"585c00e0":"code","1cca0950":"code","cb392046":"code","3a45240e":"code","b6dc9c10":"code","a1eeb357":"code","f496fa75":"code","307c7666":"code","de310d1f":"code","1aaff771":"code","5e07a4c6":"code","109cf191":"code","f36b1c30":"code","d4219745":"code","b3d2512e":"code","da562bbf":"code","c747ca68":"code","51acc1a5":"code","d3e6c3df":"code","f1c47a50":"code","cee2cac4":"code","3ca6493e":"code","57a30f94":"code","9f787fcb":"code","43444e35":"code","806d30ab":"code","ffa37616":"code","5e5e64f6":"code","a4ea29f9":"code","2c99b119":"code","b15011f3":"code","9410a071":"markdown","e4bf7e13":"markdown","8b5244d9":"markdown"},"source":{"585c00e0":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","1cca0950":"train_dt = pd.read_csv('..\/input\/train.csv', dtype={'acoustic_data': np.int16, 'time_to_failure': np.float32})","cb392046":"print(train_dt.head())\nprint(train_dt.tail())","3a45240e":"train_acoustic_small = train_dt['acoustic_data'].values[::50]\ntrain_ttf_small = train_dt['time_to_failure'].values[::50]","b6dc9c10":"train_acoustic_small.shape","a1eeb357":"fig, ax1 = plt.subplots(figsize=(16, 8))\nplt.title('Acoustic_data and time_to_failure (sampled)')\nplt.plot(train_acoustic_small, color='b')\nax1.set_ylabel('acoustic_data', color='b')\nplt.legend(['acoustic_data'])\nax2 = ax1.twinx()\nplt.plot(train_ttf_small, color='r')\nax2.set_ylabel('time_to_failure', color='r')\nplt.legend(['time_to_failure'], loc=(0.875, 0.9))\nplt.grid(False)\n","f496fa75":"del train_ttf_small\ndel train_acoustic_small","307c7666":"train_ttf_epoch = train_dt['time_to_failure'].values[:100000]\ntrain_acoustic_epoch = train_dt['acoustic_data'].values[:100000]","de310d1f":"fig, ax1 = plt.subplots(figsize=(16, 8))\nplt.title('Acoustic_data and time_to_failure(s) (sampled)')\nplt.plot(train_acoustic_epoch, color='b')\nax1.set_ylabel('acoustic_data', color='b')\nplt.legend(['acoustic_data'])\nax2 = ax1.twinx()\nplt.plot(train_ttf_epoch, color='r')\nax2.set_ylabel('time_to_failure', color='r')\nplt.legend(['time_to_failure'], loc=(0.875, 0.9))\nplt.grid(False)\n","1aaff771":"#train_ttf_epoch[:100]\n# occurance of ttf == \n# 1.4690996: 108,\n# 1.4690998: 109,\n# 1.4690999: 108,\n# 1.4691: 41\nunique, counts = np.unique(train_ttf_epoch[:1000], return_counts=True)\ndict(zip(unique, counts))","5e07a4c6":"#delete train_ttf\/acoustic_epoch\ndel train_ttf_epoch\ndel train_acoustic_epoch","109cf191":"# sample first 1% of the data\nonepercent = int(len(train_dt)*0.01)\ntrain_ttf_one = train_dt['time_to_failure'].values[:onepercent]\ntrain_acoustic_one = train_dt['acoustic_data'].values[:onepercent]","f36b1c30":"fig, ax1 = plt.subplots(figsize=(16, 8))\nplt.title('Acoustic_data and time_to_failure(s) (sampled) one percent')\nplt.plot(train_acoustic_one, color='b')\nax1.set_ylabel('acoustic_data', color='b')\nplt.legend(['acoustic_data'])\nax2 = ax1.twinx()\nplt.plot(train_ttf_one, color='r')\nax2.set_ylabel('time_to_failure', color='r')\nplt.legend(['time_to_failure'], loc=(0.875, 0.9))\nplt.grid(False)\n","d4219745":"#8th percent\ntrain_ttf_one = train_dt['time_to_failure'].values[onepercent*7:onepercent*8]\ntrain_acoustic_one = train_dt['acoustic_data'].values[onepercent*7:onepercent*8]\ntrain_acoustic_one.shape","b3d2512e":"fig, ax1 = plt.subplots(figsize=(16, 8))\nplt.title('Acoustic_data and time_to_failure(s) (sampled) one percent')\nplt.plot(train_acoustic_one, color='b')\nax1.set_ylabel('acoustic_data', color='b')\nplt.legend(['acoustic_data'])\nax2 = ax1.twinx()\nplt.plot(train_ttf_one, color='r')\nax2.set_ylabel('time_to_failure', color='r')\nplt.legend(['time_to_failure'], loc=(0.875, 0.9))\nplt.grid(False)\n","da562bbf":"# returns time difference between ttf is minmum and when acoustic data is unusually high\ndef timegap(acoustic,ttf):\n    ttf_spike = np.argmax(np.abs(acoustic))\n    ttf_min = np.argmin(ttf)\n    return {\"min_ttf\":ttf[ttf_min],\n           \"ttf_spike\":ttf[ttf_spike],\n           \"difference\":np.abs(ttf[ttf_min]-ttf[ttf_spike])}","c747ca68":"timegaps = []\ntimegaps.append(timegap(train_acoustic_one,train_ttf_one))\nprint(timegaps)","51acc1a5":"fig, ax1 = plt.subplots(figsize=(16, 8))\nplt.title('Acoustic_data and time_to_failure (sampled)')\nplt.plot(train_acoustic_small, color='b')\nax1.set_ylabel('acoustic_data', color='b')\nplt.legend(['acoustic_data'])\nax2 = ax1.twinx()\nplt.plot(train_ttf_small, color='r')\nax2.set_ylabel('time_to_failure', color='r')\nplt.legend(['time_to_failure'], loc=(0.875, 0.9))\nplt.grid(False)\n","d3e6c3df":"# going to filter out low amplitude by changing to 0\n# takes in acoustic data and an int amplitude\n# will change acoustic data to 0 if less than amplitude value\ndef low_amp_filter(acou,amp):\n    toReturn = []\n    i=0\n    while i < len(acou):\n        if np.abs(acou[i])<amp:\n            toReturn.append(0)\n        else: # when value is higher than amp\n            #print(acou[i])\n            toReturn.append(acou[i])\n        i+=1\n    return toReturn","f1c47a50":"acou_filtered = low_amp_filter(train_acoustic_small,800)\nacou_filtered_np = np.array(acou_filtered)","cee2cac4":"fig, ax1 = plt.subplots(figsize=(16, 8))\nplt.title('Acoustic_data and time_to_failure (sampled & filtered)')\nplt.plot(acou_filtered, color='b')\nax1.set_ylabel('acoustic_data', color='b')\nplt.legend(['acoustic_data'])\nax2 = ax1.twinx()\nplt.plot(train_ttf_small, color='r')\nax2.set_ylabel('time_to_failure', color='r')\nplt.legend(['time_to_failure'], loc=(0.875, 0.9))\nplt.grid(False)\n","3ca6493e":"# get indices of ttf when it reaches the minimum\n# when ttf value increases \ndef ttf_low(ttf):\n    toreturn = []\n    i = 0\n    while i < len(ttf)-2:\n        diff = ttf[i+1]-ttf[i]\n        #print(diff)\n        if diff > 1.0:\n            #store the index and the ttf value\n            tmp = np.array([i,ttf[i]])\n            toreturn.append(tmp)\n        i+=1\n    return toreturn\n\n\nttf_low_idx = ttf_low(train_ttf_small)\nttf_low_idx = np.array(ttf_low_idx)\nttf_low_idx.shape\n\n#indices of ttf when it is right before reaching 0\nttf_low_idx[:,0]","57a30f94":"# counts the number of high acoustic values before ttf reaches 0\n\"\"\"\nacou: filtered acoustic data\nttf_idx: array of indices of ttf right before it resets\n\"\"\"\ndef acou_counter(acou,ttf_idx,ttf):\n    i=0\n    toreturn = []\n    for indices in ttf_idx:\n        #indices = index of ttf right before it resets\n        tmp = []\n        ttf_ind = int(indices)\n        while i < ttf_ind:\n            #loop thru right before i == indices -1\n            #get the index of acou where not 0\n            if acou[i] != 0:\n                acou_dict = {\n                    \"index\": i,\n                    \"acoustic_value\": acou[i],\n                    \"acou_ttf\": ttf[i],\n                    \"this.ttf\": ttf[ttf_ind],\n                    \"this.ttf_ind\": ttf_ind\n                }\n                tmp.append(acou_dict)\n            i+=1\n            \n        toreturn.append(tmp)\n    return toreturn","9f787fcb":"acou_idx = acou_counter(np.array(acou_filtered),ttf_low_idx[:,0],train_ttf_small)","43444e35":"acou_idx[0]","806d30ab":"acou_idx[0][0]\nprint(type(acou_idx),type(acou_idx[0]),type(acou_idx[0][0]))","ffa37616":"for i in range(len(acou_idx)):\n    acou0 = acou_idx[i]\n    print(str(i+1)+\"th\")\n    for d in range(len(acou0)):\n        print(acou0[d][\"acou_ttf\"] - acou0[d][\"this.ttf\"])\ndel acou0    ","5e5e64f6":"#acou_diction = list(list(dict))\ndef timegap_avg(acou_diction):\n    toreturn = []\n    for sublist in acou_diction:\n        dif_list = []\n        for diction in sublist:\n            dif_list.append(diction[\"acou_ttf\"] - diction[\"this.ttf\"])\n        toreturn.append(np.mean(dif_list))\n    return toreturn","a4ea29f9":"timeavg = timegap_avg(acou_idx)","2c99b119":"timeavg","b15011f3":"acou_idx[0][0].keys()","9410a071":"# loop backward and find ttf values for when it is lowest and collects the time when acoustic is not 0 (After filtered)","e4bf7e13":"# seems like there is a certain time gap between the ttf reaches 0 and acoustic data has high value\n","8b5244d9":"<p>we can see there are some time differences between the spikes(wether it is a spike right before or not)<\/p>\n<p>therefore we need to get rid when acoustic is not right before ttf is lowest<\/p>"}}