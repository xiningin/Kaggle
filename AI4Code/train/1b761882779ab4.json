{"cell_type":{"ab17e293":"code","edae8298":"code","c76aaa01":"code","a6e56142":"code","0f8d7b73":"code","f61878b9":"code","f53e18c4":"code","66347625":"code","f175d257":"code","d5ae8692":"code","b36d0275":"code","aebd876e":"code","7219e831":"code","01db0739":"code","5eb40506":"code","71e21157":"code","21e57088":"code","2ccdbaba":"code","80a6d9bc":"code","4d2a8f87":"code","ff0d0bab":"markdown","5a7481c6":"markdown","7b8836bb":"markdown","6df31044":"markdown","44485224":"markdown","0cf8c8ca":"markdown","a837ec8a":"markdown","e8015508":"markdown","6a21563e":"markdown"},"source":{"ab17e293":"import torch\nimport torchvision","edae8298":"# Device configuration\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\ndevice","c76aaa01":"from torchvision import datasets\nfrom torchvision.transforms import ToTensor\n\ntrain_data = datasets.CIFAR10(root='data', train=True,  transform = ToTensor(), download=True)\ntest_data  = datasets.CIFAR10(root='data', train=False, transform = ToTensor())","a6e56142":"print(train_data)\nprint(test_data)","0f8d7b73":"from torch.utils.data import DataLoader\n\nbatch_size = 100\ntrainloader = torch.utils.data.DataLoader(train_data, batch_size=batch_size, shuffle=True, num_workers=1)\ntestloader  = torch.utils.data.DataLoader(test_data, batch_size=batch_size, shuffle=True, num_workers=1)\n\nclasses = ['plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck']","f61878b9":"import matplotlib.pyplot as plt","f53e18c4":"# plot one train_data\nplt.imshow(train_data.data[0])\nplt.title('%s' % classes[train_data.targets[0]])\nplt.show()","66347625":"# plot multiple train_data\nfigure = plt.figure(figsize=(10, 8))\ncols, rows = 5, 5\nfor i in range(1, cols * rows + 1):\n    sample_idx = torch.randint(len(train_data), size=(1,)).item()\n    classid = train_data[sample_idx][1]\n    figure.add_subplot(rows, cols, i)\n    plt.title(classes[classid])\n    plt.axis(\"off\")\n    plt.imshow(train_data.data[sample_idx])\nplt.show()","f175d257":"from torch import nn\nimport torch.nn.functional as F","d5ae8692":"class CNN(nn.Module):    \n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d( 3, 32, 5)\n        self.conv2 = nn.Conv2d(32, 64, 5)\n        self.relu = nn.ReLU()\n        self.pool = nn.MaxPool2d(2)\n        self.fl = nn.Flatten()\n        self.fc1 = nn.Linear(64 *5 *5, 512) # kernel=5 : 1600, kernel=3 : 2304\n        self.fc2 = nn.Linear(512, 64)\n        self.fc3 = nn.Linear(64, 10)\n\n    def forward(self, x):\n        x = self.pool(self.relu(self.conv1(x)))\n        x = self.pool(self.relu(self.conv2(x)))\n        x = self.fl (x)\n        x = self.fc1(x)\n        x = self.fc2(x)\n        x = self.fc3(x)\n        return x","b36d0275":"net = CNN()\ncriterion = torch.nn.CrossEntropyLoss()\noptimizer = torch.optim.Adam(net.parameters(), lr=1e-3)\n#optimizer = torch.optim.SGD(net.parameters(), lr=0.001, momentum=0.9)","aebd876e":"!pip install torch-summary","7219e831":"from torchsummary import summary\nsummary(net, (3, 32, 32))","01db0739":"import tqdm","5eb40506":"num_epochs = 30\n\nnet.train() # set to training model\nfor epoch in range(num_epochs):\n    for images, labels in tqdm.notebook.tqdm(trainloader):\n        images = images.to(device) # for GPU\n        labels = labels.to(device) # for GPU\n        outputs = net(images)\n        loss = criterion(outputs, labels)        \n        optimizer.zero_grad()  # clear gradients for this training step        \n        loss.backward()        # backpropagation, compute gradients\n        optimizer.step()       # apply graidents\n        # accuracy\n        pred_y = torch.max(outputs, 1)[1].data.squeeze()\n        accuracy = (pred_y == labels).sum().item() \/ float(labels.size(0))\n    print(\"Epoch {}\/{}, Loss: {:.4f}, Accuracy: {:.3f}\".format(epoch+1, num_epochs, loss.item(), accuracy))","71e21157":"torch.save(net.state_dict(), 'cifar10_cnn.pth')","21e57088":"net.eval() # set to evaluate model\nwith torch.no_grad():\n    for images, labels in testloader:\n        images = images.to(device) # for GPU\n        labels = labels.to(device) # for GPU\n        outputs = net(images)\n        pred_y = torch.max(outputs, 1)[1].data.squeeze()\n        accuracy = (pred_y == labels).sum().item() \/ float(labels.size(0))\n    print('Model accuracy of the %5d test images = %.3f' % (len(test_data), accuracy))","2ccdbaba":"sample = next(iter(testloader))\nimgs, lbls = sample","80a6d9bc":"# first 10 predictions\nactual_y = lbls[:10].numpy()\nprint(actual_y)","4d2a8f87":"images = imgs[:10]\nimages = images.to(device) # for GPU\noutputs = net(images)\npred_y = torch.max(outputs, 1)[1].data.cpu().numpy().squeeze()\nprint(f'Predict: {pred_y}')\nprint(f'Actual : {actual_y}')","ff0d0bab":"### Model Summary","5a7481c6":"## Train Model","7b8836bb":"## Build Network","6df31044":"# CIFAR-10 CNN in PyTorch","44485224":"## Visualization of MNIST dataset","0cf8c8ca":"### test first 10 samples","a837ec8a":"## Prepare Dataset","e8015508":"## Save Model","6a21563e":"## Test Model"}}