{"cell_type":{"4dbfe869":"code","3f6634c4":"code","361a47a1":"code","6d6a83eb":"code","40a8f799":"code","c722ac4d":"code","9b8215d0":"markdown","890249a3":"markdown","5b51a0a8":"markdown","e929b8b0":"markdown","af230632":"markdown","b797556e":"markdown"},"source":{"4dbfe869":"str1=\"1263547216354726135472631547263514726354172635412357641235746123547612354672135467231546723514672354167235461723546127354612736451276345217634527163452761345276314527634152763412537642153764251376425317642537164253761425376124537612345762134576231457623415762345176234571623457124635712465732146573241657324615732465173246571324657123467521346752314675234167523461752346715234671237645123674512536741256734125634721563472516347256134725631472563417256341257634127653421765342716534276153427651342765314276531246537126753412673542167354261735426713542673154267351426735124675312657342165734261573426517342657134265731426573124756312574361254763215476325147632541763254716325476132547612453672145367241536724513672453167245361724536127463512753642175364271536427513642753164275361427536124573612547362154736251473625417362547136254731625473125647312567431254673126437512436752143675241367524316752436175243671524367125436721543672514367254136725431672543617254361275436123456712356741273456217345627134562731456273415627345162734512673451276543217654327165432761543276514327654132765412367541236547213654723165472361547236514723654172365412734651256374123745612375461237564213756423175642371564237516423756142375612473652147365241736524713652473165247361524736124357612437651234765126473512654732165473261547326514732654173265471326547123657421365742316574236157423651742365714236571243657214365724136572431657243615724365172436512743651264357216435726143572641357264315726435172643512764352176435271643527614352764135276431527643125746312573461256437125364712674532167453261745326714532674153267451326745123647512635741263754126754312457631245637214563724156372451637245613724563172456312736541237654213765423176542371654237615423765142376512374651247653124375612456731264573124673512647532164753261475326417532647153264751326475126347512674351265437216543726154372651437265413726543172654312653741273564125374612534761243567123475612346572134657231465723416572346157234651723465125736421573642517364257136425731642573614257361254637125437612653471264537216453726145372641537264513726453172645312763542176354271635427613542763154276351427635124763521476352417635247163524761352476315247631275643127563421756342715634275163427561342756314275631275346127546321754632715463275146327541632754613275461263745127645312534671235647124735612463751236457126345712657431257643127435612746531274563127453612475362147536241753624715362475136247531624753\"\nWILDCARD_POS = 0\nMIN_COSTLY_DISTANCE = 4\nMAX_ELEMENTS_BRUTE_FORCE = 10","3f6634c4":"import itertools\nall_perms = set(itertools.permutations(range(1, 8), 7))\nmandatory_perms = set((1, 2) +  _ for _ in itertools.permutations(range(3, 8), 5))\nnon_mandatory_perms = all_perms - mandatory_perms\nctsp_perms = list(mandatory_perms) + list(mandatory_perms) + list(mandatory_perms) + list(non_mandatory_perms)","361a47a1":"def perm_dist_no_wildcards(p, q, wildcard=False):\n    \"\"\"\n    Computes overlapping distance between two lists of integer\n    between 1 and 7. 8 is wildcard\n    \"\"\"\n    p = list(p)\n    q = list(q)\n        \n    if p==q:\n        return 0\n    \n    # Nope\n    if 8 in q and 8 in p:\n        # Dist between 1238567 and 1278543 or reverse\n        return 7\n    \n    if 8 in q:\n        min_dist = 8\n        for i in range(1,8):\n            q2 = list(q)\n            q2[q2.index(8)] = i\n            for j in range(1,8):\n                if p[j:]==q2[:-j]:\n                    if min_dist > j:\n                        min_dist = j\n                        break\n        return min_dist\n                \n    if 8 in p:\n        min_dist = 8\n        for i in range(1,8):\n            p2 = list(p)\n            p2[p2.index(8)] = i\n            for j in range(1,8):\n                if p2[j:]==q[:-j]:\n                    if min_dist > j:\n                        min_dist = j\n                        break\n        return min_dist\n            \n    i = p.index(q[0])\n    return i if p[i:] == q[:7-i] else 7\n\n\ndef perm_dist(p, q, string_number, use_wildcards=True):\n    \"\"\"\n    Computes overlapping distance between two lists of integer\n    between 1 and 7. 8 is wildcard\n    \"\"\"\n    p = list(p)\n    q = list(q)\n    \n    \n    if p==q:\n        return 0\n    \n    if use_wildcards and wildcards[string_number]:\n        # Apply wildcards\n        for j in range(2):\n            if p == list(wildcards[string_number][j]):\n                p[WILDCARD_POS] = 8\n            if q == list(wildcards[string_number][j]):\n                q[WILDCARD_POS] = 8    \n    \n    # Nope\n    if 8 in q and 8 in p:\n        return 7\n    \n    if 8 in q:\n        min_dist = 8\n        for i in range(1,8):\n            q2 = list(q)\n            q2[q2.index(8)] = i\n            for j in range(1,8):\n                if p[j:]==q2[:-j]:\n                    if min_dist > j:\n                        min_dist = j\n                        break\n        return min_dist\n                \n    if 8 in p:\n        min_dist = 8\n        for i in range(1,8):\n            p2 = list(p)\n            p2[p2.index(8)] = i\n            for j in range(1,8):\n                if p2[j:]==q[:-j]:\n                    if min_dist > j:\n                        min_dist = j\n                        break\n        return min_dist\n            \n    i = p.index(q[0])\n    return i if p[i:] == q[:7-i] else 7\n\ndef perms_to_string(perms, string_number, use_wildcards=True):\n    \"\"\"\n    Given list of permutations, compacts them to string\n    via removing overlaps\n    \"\"\"\n    perms = list(perms)\n    s = [*perms[0]]\n    for p, q in zip(perms, perms[1:]):\n        d = perm_dist(p[-7:], q[:7], string_number, use_wildcards)\n        s.extend(q[7-d:])\n        if use_wildcards:\n            if q == wildcards[string_number][0]:\n                s[-(7-WILDCARD_POS)] = 8\n            elif q == wildcards[string_number][1]:\n                s[-(7-WILDCARD_POS)] = 8\n    return s\n\ndef distances_matrix(perms, string_number, depot=False, use_wildcards=True):\n    \"\"\"\n    Computes distance matrix for TSP\n    \"\"\"\n    if depot:\n        m = np.zeros((len(perms)+1, len(perms)+1), dtype='int8')\n    else:\n        m = np.zeros((len(perms), len(perms)), dtype='int8')\n    for i, p in enumerate(perms):\n        for j, q in enumerate(perms):\n            if depot:\n                m[i+1, j+1] = perm_dist(p[-7:], q[:7], string_number, use_wildcards) + len(q) - 7\n            else:\n                m[i,j] = perm_dist(p[-7:], q[:7], string_number, use_wildcards) + len(q) - 7\n    if depot:\n        m[0,:]=0\n        m[:,0]=0\n    return m\n\ndef distances_matrix_ctsp(perms, depot=False):\n    \"\"\"\n    Computes distance matrix for TSP\n    \"\"\"\n    if depot:\n        m = np.zeros((len(perms)+1, len(perms)+1), dtype='int8')\n    else:\n        m = np.zeros((len(perms), len(perms)), dtype='int8')\n    for i, p in enumerate(perms):\n        for j, q in enumerate(perms):\n            if 0 <= i < 120:\n                string_number = 0\n            elif 120 <= i < 240:\n                string_number = 1\n            else:\n                if 0 <= j < 120:\n                    string_number = 0\n                elif 120 <= j < 240:\n                    string_number = 1\n                else:\n                    string_number = 2\n            if depot:\n                m[i+1, j+1] = perm_dist(p[-7:], q[:7], string_number) + len(q) - 7\n            else:\n                m[i,j] = perm_dist(p[-7:], q[:7], string_number) + len(q) - 7\n    if depot:\n        m[0,:]=0\n        m[:,0]=0\n    return m\n\ndef sym_distances_matrix(matrix, constant=True):\n    \"\"\"\n    Given an N x N distance matrix for ATSP, obtains a 2N x 2N matrix for\n    SymTSP, where the extra N nodes are \"virtual\" and should be ommitted\n    from the resulting circuit.\n    paper: http:\/\/home.eng.iastate.edu\/~rkumar\/PUBS\/atsp.pdf\n    \"\"\"\n    if constant:\n        # Obtain D prime\n        d_max = np.max(matrix)\n        np.fill_diagonal(matrix, 100)\n        d_min = np.min(matrix)\n        np.fill_diagonal(matrix, 0)\n        if d_max \/ d_min < 4\/3:\n            Dprime = matrix\n        else:\n            Dprime = matrix + 3*d_max - 4*d_min + 1\n            np.fill_diagonal(Dprime, 0)\n    else:\n        Dprime = matrix\n    \n    # Obtain D bar\n    Dbar = np.empty((Dprime.shape[0]*2, Dprime.shape[1]*2))\n    Dbar[:Dprime.shape[0], :Dprime.shape[0]] = 100\n    Dbar[Dprime.shape[0]:, :Dprime.shape[0]] = Dprime\n    Dbar[:Dprime.shape[0], Dprime.shape[0]:] = np.transpose(Dprime)\n    Dbar[Dprime.shape[0]:, Dprime.shape[0]:] = 100\n    \n    # Add depot\n    Dbar2 = np.empty((Dbar.shape[0]+1, Dbar.shape[1]+1))\n    Dbar2[1:,1:] = Dbar\n    Dbar2[0, :] = 0\n    Dbar2[:, 0] = 0\n    Dbar = Dbar2\n    \n    np.round(Dbar, 0)\n    Dbar = Dbar.astype(int)\n    return Dbar\n\ndef find_remaining(l):\n    \"\"\"\n    Given 6 different numbers from 1 to 7, returns\n    the remaining one.\n    \"\"\"\n    s = {1,2,3,4,5,6,7}\n    return list(s - set(l))[0]\n\ndef reduce_perms(perms, factor=2, exclude_mandatory=True, seed=397):\n    \"\"\"\n    Given a list of permutations and a reduction factor, \n    returns a list of \"glued permutations\" with smaller size.\n    \"\"\"\n    seen = set()\n    result = set()\n    perms = list(perms)\n    random.Random(seed).shuffle(perms)\n    for perm in perms:\n        if (exclude_mandatory and perm[1]==1 and perm[2]==2):\n            seen.add(perm)\n            result.add(perm)\n        if perm in seen:\n            continue\n        seen.add(perm)\n        l = list(perm)\n        for _ in range(factor-1):\n            remaining = find_remaining(l[-6:])\n            l.append(remaining)\n            if(tuple(l[-7:]) in seen) or (exclude_mandatory and l[-7]==1 and l[-6]==2):\n                l.pop()\n                break\n            seen.add(tuple(l[1:]))\n        l = tuple(l)\n        result.add(l)\n    return result    \n\ndef write_params_file(name=\"mtsp\"):\n    \"\"\"\n    Sets solver parameters. If multi == True, attempts a multi-solve\n    \"\"\"\n    with open(f'{name}.par', 'w') as f:\n        print(f'PROBLEM_FILE = {name}.mtsp', file=f)\n        print(f'TOUR_FILE = {name}.txt', file=f)\n        print(f'INITIAL_TOUR_FILE = {name}.txt', file=f)\n        #print('INITIAL_TOUR_ALGORITHM = MTSP', file=f)\n        print('PATCHING_C = 4', file=f)\n        print('PATCHING_A = 3', file=f)\n        print('GAIN23 = YES', file=f)\n        print('SEED = 69', file=f)\n        print('MAX_TRIALS = 100000', file=f)\n        print(f'TIME_LIMIT = {TIME_LIMIT}', file=f) #seconds\n        print('TRACE_LEVEL = 1', file=f)\n\n\ndef write_problem_file(distances,name=\"mtsp\"):\n    \"\"\"\n    Writes problem.\n    \"\"\"\n    with open(f'{name}.mtsp', 'w') as f:\n        print('TYPE: ATSP', file=f)\n        print(f'DIMENSION: {len(distances)}', file=f)\n        print('EDGE_WEIGHT_TYPE: EXPLICIT', file=f)\n        print('EDGE_WEIGHT_FORMAT: FULL_MATRIX\\n', file=f)\n        print('EDGE_WEIGHT_SECTION', file=f)\n        for row in distances:\n            print(' '.join(str(_) for _ in row), file=f)\n            \ndef write_initial_tour_file(perms):\n    \"\"\"\n    Writes starting tour\n    \"\"\"\n    with open('initial_tour.txt', 'w') as f:\n        print('TOUR_SECTION', file=f)\n        print(' '.join(str(_) for _ in range(1, len(perms)+1)), -1, file=f)\n\ndef read_output_tour(perms,name=\"best_tour\"):\n    \"\"\"\n    Reads resulting tour\n    \"\"\"\n    perms = list(perms)\n    with open(f'{name}.txt') as f:\n        lines = f.readlines()\n    tour = lines[lines.index('TOUR_SECTION\\n')+2:-2]\n    return [perms[int(_) - 2] for _ in tour]\n\ndef read_output_tour_mtsp(perms, filename):\n    \"\"\"\n    Reads resulting tour, returning 3-tuple of tour indices\n    \"\"\"\n    perms = list(perms)\n    tour = [[],[],[]]\n    dimension = 1 + len(perms)\n    with open(filename) as f:\n        lines = f.readlines()\n    i=-1\n    for node_tag in lines[lines.index('TOUR_SECTION\\n')+1:-2]:\n        tag = int(node_tag)\n        if tag == 1 or tag == dimension+1 or tag == dimension+2:\n            i+=1\n        else:\n            tour[i].append(perms[tag-2]) # Sub extra to ignore depot\n    return tuple(tour)\n\ndef read_output_tour_ctsp(perms, filename, flip=False):\n    \"\"\"\n    Reads resulting tour, returning 3-tuple of tour indices\n    \"\"\"\n    perms = list(perms)\n    tour = [[],[],[]]\n    dimension = 1 + 2*len(perms)\n    prev = None\n    with open(filename) as f:\n        lines = f.readlines()\n    i=-1\n    L = lines[lines.index('TOUR_SECTION\\n')+1:-2]\n    for node_tag in L:\n        tag = int(node_tag)\n        if tag == 1 or tag == dimension+1 or tag == dimension+2:\n            i+=1\n        else:\n            if tag >=2 and (perms[(tag-2)%len(perms)] not in tour[i]):\n                tour[i].append(perms[(tag-2)%len(perms)]) # Sub extra to ignore depot\n        if tag > 1+len(perms) and tag != prev+len(perms):\n            continue\n            print(f\"Careful with {tag}\")\n        elif tag <= 1+len(perms):\n            prev = tag\n    return tuple(tour)\n    \ndef solve_atsp(perms, name=\"santa.par\"):\n    \n    # Run LKH-3 to solve ATSP instance\n    !touch lkh.log\n    !.\/LKH $name >> lkh.log\n    #tour = read_output_tour(perms)\n    #return perms_to_string(tour)\ndef check_validity(str1, str2, str3):\n    all_perms = set(itertools.permutations(range(1, 8), 7))\n    mandatory_perms = set((1, 2) +  _ for _ in itertools.permutations(range(3, 8), 5))\n\n    strings_perms = [perms_in_string(str1), perms_in_string(str2), perms_in_string(str3)]\n    for i, s in enumerate(strings_perms):\n        if mandatory_perms - s:\n            print(f'String #{i} is missing {mandatory_perms - s}.')\n            return False\n    if all_perms - set.union(*strings_perms):\n        print(f\"missing:{len(all_perms - set.union(*strings_perms))}\")\n        print(f'Strings are missing {all_perms - set.union(*strings_perms)}.')\n        return False\n    return True\n\ndef perms_in_string_list(string_as_list):\n    perms = []\n    for i in range(len(string_as_list)):\n        perm = tuple(string_as_list[i:i+7])\n        if len(set(perm))==7:\n            if 8 not in perm:\n                perms.append(perm)\n            else:\n                if perm.count(8) > 1:\n                    continue\n                for i in range(1,8):\n                    perm2 = list(perm)\n                    perm2[perm2.index(8)] = i\n                    if len(set(perm2))==7:\n                        perms.append(tuple(perm2))\n                \n    return perms\n\ndef perms_in_string(string_as_list):\n    perms = set()\n    for i in range(len(string_as_list)):\n        perm = tuple(string_as_list[i:i+7])\n        if len(set(perm))==7:\n            if 8 not in perm:\n                perms.add(perm)\n            else:\n                if perm.count(8) > 1:\n                    continue\n                for i in range(1,8):\n                    perm2 = list(perm)\n                    perm2[perm2.index(8)] = i\n                    if len(set(perm2))==7:\n                        perms.add(tuple(perm2))\n                \n    return perms\ndef concat_perms(perms):\n    perms_flat = []\n    for e in perms:\n        for i in e:\n            perms_flat.append(i)\n    return perms_flat","6d6a83eb":"def get_distances_from_prev_node(perms, str_id):\n    # First node has prev_distance = -inf\n    return [-float('inf')] + [perm_dist(perms[i-1], perms[i], str_id, use_wildcards=False) for i in range(1, len(perms))]\n\nclass CostlyMandatory:\n    def __init__(self, perm, distance_from_prev, candidates_min_distance, n_candidates, n_candidates_not_already_before_mandatory, candidates_avg_distances, candidates_not_already_avg_distances):\n        self.perm = perm\n        self.distance_from_prev = distance_from_prev  # distance from prev node\n        self.candidates_min_distance = candidates_min_distance  # min distance of candidates to this perm\n        self.n_candidates = n_candidates\n        self.n_candidates_not_already_before_mandatory = n_candidates_not_already_before_mandatory\n        self.candidates_avg_distances = candidates_avg_distances\n        self.candidates_not_already_avg_distances = candidates_not_already_avg_distances\n    \n    def __lt__(self, other):\n        return (-self.distance_from_prev,\n                self.candidates_min_distance, \n                -self.n_candidates_not_already_before_mandatory, \n                -self.candidates_not_already_avg_distances, \n                -self.n_candidates, \n                -self.candidates_avg_distances) < (-other.distance_from_prev,\n                                                   other.candidates_min_distance, \n                                                   -other.n_candidates_not_already_before_mandatory, \n                                                   -other.candidates_not_already_avg_distances, \n                                                   -other.n_candidates, \n                                                   -other.candidates_avg_distances)\n\ndef choose_wildcards(string, str_id, verbose=False):\n    perms = perms_in_string_list(string)\n    distances_from_prev = get_distances_from_prev_node(perms, str_id)\n    costly_mandatory_perms = [(perms[i], distances_from_prev[i]) for i in range(len(perms)) \n                                          if perms[i] in mandatory_perms and distances_from_prev[i] >= MIN_COSTLY_DISTANCE]\n    \n    if verbose:\n        print(f'Total costly mandatory perms: {len(costly_mandatory_perms)}')\n        print(f'Costly mandatory perms: {costly_mandatory_perms}')\n            \n    \n    costly_mandatory_ordered = []\n    wildcards = []\n    for perm, distance_from_prev in costly_mandatory_perms:\n        # Add wildcard to desired position\n        perm_with_wildcard = list(perm)\n        perm_with_wildcard[WILDCARD_POS] = 8\n        distances = [perm_dist(perms[i], perm_with_wildcard, str_id, use_wildcards=False) for i in range(len(perms))]\n        candidates_min_distance = min(distances)\n        # Choose candidates with potential distance = min_distance to perm\n        candidates = [(i, perms[i]) for i in range(len(perms)) if distances[i] == candidates_min_distance] \n        candidates_not_already_before_mandatory = [(index, candidate) for index, candidate in candidates if perms[index+1] not in mandatory_perms]\n        # Compute avg distances of the involved candidates from prev node and to next node\n        if len(candidates) > 0:\n            candidates_avg_distances = sum([distances_from_prev[index] + distances_from_prev[index+1] for index, _ in candidates]) \/ (2*len(candidates))\n        else:\n            candidates_avg_distances = 0\n        if len(candidates_not_already_before_mandatory) > 0:\n            candidates_not_already_avg_distances = sum([distances_from_prev[index] + distances_from_prev[index+1] for index, _ in candidates_not_already_before_mandatory]) \/ (2*len(candidates_not_already_before_mandatory))\n        else:\n            candidates_not_already_avg_distances = 0\n        if verbose:\n            print(f'\\t{perm} has {len(candidates)} candidates with dist={candidates_min_distance} (avg_dist_prevnext={candidates_avg_distances}), {len(candidates_not_already_before_mandatory)} not already before other mandatory (avg_dist_prevnext={candidates_not_already_avg_distances})')\n\n        costly_mandatory_ordered.append(CostlyMandatory(perm, distance_from_prev, candidates_min_distance, len(candidates), len(candidates_not_already_before_mandatory), candidates_avg_distances, candidates_not_already_avg_distances))\n\n    costly_mandatory_ordered.sort()\n    wildcards = [costly_mandatory.perm for costly_mandatory in costly_mandatory_ordered[:MAX_ELEMENTS_BRUTE_FORCE]]\n    wildcards = list(itertools.combinations(wildcards, 2))\n    if verbose:\n        print(f'Chosen wildcards pairs: {wildcards}')\n    \n    return wildcards","40a8f799":"str1 = [int(e) for e in str1]\n\nwildcards_pairs = choose_wildcards(str1, str_id=0, verbose=True)","c722ac4d":"import pandas as pd\nsubmission = pd.read_csv('..\/input\/santa-2021-best-submission\/submission.csv')\nsubmission.to_csv('submission.csv', index=False)\nsubmission.head()","9b8215d0":"# Aux functions","890249a3":"I designed a heuristic that ordered candidates based on the following principles:\n\n1. *distance_from_prev*: current distance from the previous permutation in the current string.\n2. *candidates_min_distance*: minimum distance of all the permutations to the mandatory permutation. \n3. *n_candidates_not_already_before_mandatory*: number of candidates that could go before the mandatory permutation with distance=*candidates_min_distance* that are not already before another mandatory permutation.\n4. *candidates_not_already_avg_distances*: average distance to the next permutation in their current place at the string of the candidates of the previous point.\n5. *n_candidates*: number of candidates that could go before the mandatory permutation with distance=*candidates_min_distance*.\n6. *candidates_avg_distances*: average distance to the next permutation in their current place at the string of the candidates of the previous point.\n\nThe reasoning behind these points, which are ordered by importance, is the following. Maximizing \"1\" is the natural greedy approach, hoping that the distance from the previous node can be changed to 1 with a wildcard. Apart from trying to apply the wildcard to a permutation that is adding a lot of distance, we have to take the candidates that could help reduce this distance into account. Therefore, \"2\" should be ideally 1, so there is at least a candidate in the string with distance 1 to the mandatory permutation. However, we do not want to solve a problem to create another one somewhere else in the string. Thus, the rest of the points in the heuristic take into account how many candidates are available and what is their current distance to their next permutation. Special attention is paid to those candidates that are not being used before another mandatory permutation.","5b51a0a8":"# Compute wildcards","e929b8b0":"This notebook implements a heuristic to choose the best candidates where wildcards should be used. For an intelligent way to apply the wildcards after selecting the best, visit [this notebook](https:\/\/www.kaggle.com\/miguelgonzalez2\/santa-2021-wildcard-insertion-lkh). For a complete pipeline where best pairs of wildcards are selected and applied to the string to reduce its length, please visit [this notebook](https:\/\/www.kaggle.com\/atmguille\/kaggle-2021-global-optimizer).","af230632":"Add submission file to output","b797556e":"Input the string, the position of the wildcard, the minimum distance for a permutation to be considered as a candidate and the max elements to be used for building the best pairs of wildcards."}}