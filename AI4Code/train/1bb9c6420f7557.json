{"cell_type":{"637fe1e7":"code","40cf2091":"code","65e9e548":"code","dfd2aac2":"code","7e0b41da":"code","306815f6":"code","ec1c8d01":"code","7dcb9457":"code","30d04576":"code","bd4f6ca6":"code","89346e99":"code","e4cb6b79":"code","6d40d4aa":"code","b6da3a02":"code","e7dc84b8":"code","79f1acd4":"code","8a8b95db":"code","4e1820bc":"code","78132edf":"code","70d45b82":"code","ca2740dc":"code","023be614":"code","fce1da31":"code","057ac9f0":"code","6a020061":"code","2fe761ac":"code","b5fb48c9":"code","8c28f4ff":"code","a646c82c":"code","d5c77caa":"code","5287f449":"code","98fec8c9":"code","c8230705":"code","36c197b6":"code","d865017c":"code","c546dbe8":"code","7612c930":"code","b28a2160":"code","9c002583":"code","ac586a75":"code","b6e59cd7":"code","0b6fae90":"code","68ca664a":"code","69fa0de3":"code","b256770f":"code","a0b236ee":"code","89449544":"code","7f7fe5e3":"code","291d1cb7":"code","5d971f31":"code","b028bb16":"code","f67cbe21":"code","ad1486e3":"code","cccd7061":"code","5b6a6cb9":"code","31580b71":"code","fd3709f7":"code","e24803bb":"code","8ddbbfbc":"markdown","4bb57559":"markdown","57063871":"markdown","05292857":"markdown","89bd5f13":"markdown","a35980cd":"markdown","98e40044":"markdown","0cbe057b":"markdown","7e72ca85":"markdown","234683ac":"markdown","c12e2db6":"markdown","fbb8b186":"markdown","9d6e913b":"markdown","10a0309b":"markdown","af8aea8f":"markdown","8944dba7":"markdown","b9b34849":"markdown","74bc3a3b":"markdown","53666926":"markdown","f833cbf2":"markdown","ad730074":"markdown","5ed87fc7":"markdown","454dbcc8":"markdown","4136683e":"markdown","fa88ad74":"markdown","76c8738a":"markdown","90449541":"markdown","8210f6a3":"markdown","6d9d2166":"markdown","cab6ca97":"markdown","1c83e812":"markdown","a6f2708c":"markdown","81d2a600":"markdown","a87b3d59":"markdown"},"source":{"637fe1e7":"# Import the tools for data analysis\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nsns.set_style('darkgrid')","40cf2091":"# Read the data\ntrain_df = pd.read_csv('..\/input\/titanic\/train.csv')\ntest_df = pd.read_csv('..\/input\/titanic\/test.csv')","65e9e548":"# size\ntrain_df.shape, test_df.shape","dfd2aac2":"train_df.head(2)","7e0b41da":"test_df.head(2)","306815f6":"train_df.isnull().sum()","ec1c8d01":"test_df.isnull().sum()","7dcb9457":"comp_df = pd.concat([train_df, test_df])\ncomp_df.reset_index(drop=True, inplace=True)","30d04576":"comp_df.head(1)","bd4f6ca6":"# Check for missing data\ncomp_df.isnull().sum()","89346e99":"# Descriptive statistic of the data\ncomp_df.describe()","e4cb6b79":"comp_df.dtypes","6d40d4aa":"comp_df.drop('PassengerId',axis=1, inplace=True)\ncomp_df.drop('Cabin',axis=1,inplace=True)\ncomp_df.drop(\"Ticket\",axis=1, inplace=True)","b6da3a02":"sns.countplot('Survived',data=comp_df)","e7dc84b8":"fig ,(ax1, ax2,ax3)= plt.subplots(3,1,figsize=(7,13))\npd.crosstab(comp_df.Sex, comp_df.Survived).plot.bar(ax=ax1)\npd.crosstab(comp_df.Pclass, comp_df.Survived).plot.bar(ax=ax2)\npd.crosstab(comp_df.Embarked, comp_df.Survived).plot.bar(ax=ax3)\nplt.show()","79f1acd4":"# Correlation graph\nplt.figure(figsize=(10,6))\nsns.heatmap(comp_df.corr(),annot=True,cmap='Reds')\nplt.title('Correlation among numerical columns')","8a8b95db":"plt.figure(figsize=(12,2))\nsns.boxplot(comp_df.Age)","4e1820bc":"fig, (ax1,ax2,ax3) = plt.subplots(1,3,figsize=(13,3))\nsns.boxplot(x='Survived',y='Age',data=comp_df,ax=ax1, width=0.5)\nsns.boxplot(x='Sex', y='Age', data=comp_df,ax=ax2, width=0.5)\nsns.boxplot(x='Pclass', y='Age', data=comp_df,ax=ax3, width=0.5)","78132edf":"# Fill the missing value according to their pclass\np1 = comp_df[comp_df.Pclass==1]['Age'].median() \np2 = comp_df[comp_df.Pclass==2]['Age'].median() \np3 = comp_df[comp_df.Pclass==3]['Age'].median() \ndef fill_age(row):\n    if np.isnan(row.Age):\n        if row.Pclass == 1:\n            return p1\n        elif row.Pclass == 2:\n            return p2\n        elif row.Pclass == 3:\n            return p3\n    else:\n        return row.Age\ncomp_df.Age = comp_df.apply(fill_age, axis=1)","70d45b82":"# Drop the extreme outliers\ncomp_df = comp_df[comp_df.Age<80]","ca2740dc":"# Distribution of numerical data\nfig, (ax1,ax2) = plt.subplots(2,1,figsize=(10,6), sharex=True)\nsns.boxplot('Fare',data=comp_df, width=0.5,ax=ax1)\nsns.distplot(comp_df.Fare,ax=ax2)","023be614":"comp_df.Fare.isnull().sum()","fce1da31":"comp_df.Fare.fillna(comp_df.Fare.median(), inplace=True)","057ac9f0":"from scipy.stats import iqr\n\nupper_limit = comp_df.Fare.quantile(0.75) + (1.5 * iqr(comp_df.Fare))\nlower_limit = comp_df.Fare.quantile(0.25) - (1.5 * iqr(comp_df.Fare))","6a020061":"# Number of outliers\ncomp_df[(comp_df.Fare>upper_limit ) & (comp_df.Survived.notnull())].shape","2fe761ac":"comp_df[(comp_df.Fare>100 ) & (comp_df.Survived.notnull())].shape","b5fb48c9":"#Lets drop the outliers\ntrain_df = comp_df[comp_df.Survived.notnull()]\ntest_df = comp_df[comp_df.Survived.isnull()]","8c28f4ff":"train_df.shape, test_df.shape\ntrain_df = train_df[train_df.Fare<=100]\ncomp_df = pd.concat([train_df,test_df])","a646c82c":"comp_df.shape","d5c77caa":"sns.countplot(comp_df.Embarked)","5287f449":"comp_df.Embarked.isnull().sum()","98fec8c9":"# Fill the missing value\ncomp_df.Embarked.value_counts()","c8230705":"comp_df.Embarked.fillna('S',inplace=True)","36c197b6":"comp_df.isnull().sum()","d865017c":"comp_df['family_size'] = comp_df.SibSp + comp_df.Parch","c546dbe8":"pd.crosstab(comp_df.family_size, comp_df.Survived).plot.bar(figsize=(6,4))\nplt.xticks(rotation=None)\nplt.ylabel('Number of passenager')","7612c930":"# now we drop the columns of sibsp and parch\ncomp_df.drop(['SibSp','Parch'], axis=1, inplace=True)","b28a2160":"# Extract title from name\ncomp_df['title'] = comp_df.Name.str.extract(r'([\\w]+[.])')","9c002583":"# check any missing value\ncomp_df.title.isnull().sum()","ac586a75":"# plot the title\nplt.figure(figsize=(15,4))\nsns.countplot(comp_df.title)","b6e59cd7":"pd.crosstab(comp_df.title, comp_df.Survived).plot.bar(figsize=(15,4))\nplt.xticks(rotation=None)","0b6fae90":"# label encoding\n# age male to 1, female to 0\ncomp_df.Sex = comp_df.Sex.map({'male':1,'female':0})\n# Embarked to 0,1,2\ncomp_df.Embarked = comp_df.Embarked.map({'C':0, 'Q':1,'S':2})","68ca664a":"# Group family size > 10 to 4\n#comp_df.drop('family_size',axis=1,inplace=True)\ncomp_df.family_size= comp_df.apply(lambda x:4 if x.family_size>4 else x.family_size,axis=1)","69fa0de3":"# Formatting the title\n# To Mr.\ncomp_df['title'] = comp_df['title'].str.replace(r'Sir.', 'Mr.')\ncomp_df['title'] = comp_df['title'].str.replace(r'Rev.','Mr.')\n\n# To Ms\ncomp_df['title'] = comp_df['title'].str.replace(r'Lady.','Ms.')\ncomp_df['title'] = comp_df['title'].str.replace(r'Mrs.','Ms.')\ncomp_df['title'] = comp_df['title'].str.replace(r'Miss.','Ms.')\n\n# to other\ncomp_df['title'] = comp_df['title'].str.replace(r'Mlle.','other')\ncomp_df['title'] = comp_df['title'].str.replace(r'Mme.','other')\ncomp_df['title'] = comp_df['title'].str.replace(r'Dona.','other')\ncomp_df['title'] = comp_df['title'].str.replace(r'Countess.','other')\ncomp_df['title'] = comp_df['title'].str.replace(r'Major.','other')\ncomp_df['title'] = comp_df['title'].str.replace(r'Jonkheer.','other')\ncomp_df['title'] = comp_df['title'].str.replace(r'Col.','other')\ncomp_df['title'] = comp_df['title'].str.replace(r'Capt.','other')\n\n# to scholar\ncomp_df['title'] = comp_df['title'].str.replace(r'Master.','scholar')\ncomp_df['title'] = comp_df['title'].str.replace(r'Dr.','scholar')\ncomp_df['title'] = comp_df['title'].str.replace('Don.','scholar')","b256770f":"comp_df.drop('Name',axis=1, inplace=True)","a0b236ee":"# label encoding the title\ncomp_df.title = comp_df.title.map({'other':0, 'scholar':1, 'Ms.':2, 'Mr.':3})","89449544":"bins = 7\nfig, (ax1,ax2) = plt.subplots(2,1,figsize=(7,7))\nsns.distplot(comp_df[comp_df.Survived==1].Age, bins=bins, label='Survived',ax=ax1)\nsns.distplot(comp_df[comp_df.Survived==0].Age,bins=bins,label='Not Survived',ax=ax1)\nax1.legend()\n\nsns.distplot(comp_df[comp_df.Survived==1].Fare, bins=bins, label='Survived',ax=ax2)\nsns.distplot(comp_df[comp_df.Survived==0].Fare,bins=bins,label='Not Survived',ax=ax2)\nax2.legend()","7f7fe5e3":"# Binnings the Age and Fare\ncomp_df.Age = pd.cut(comp_df.Age, 7, labels=[0,1,2,3,4,5,6])\ncomp_df.Fare = pd.cut(comp_df.Fare, 7, labels=[0,1,2,3,4,5,6])\ncomp_df.Age = comp_df.Age.astype('int')\ncomp_df.Fare = comp_df.Fare.astype('int')","291d1cb7":"# final check for datatype\ncomp_df.dtypes","5d971f31":"comp_df","b028bb16":"train_df = comp_df[comp_df.Survived.notnull()]\ntest_df = comp_df[comp_df.Survived.isnull()]","f67cbe21":"test_df.drop('Survived',axis=1, inplace=True)","ad1486e3":"x_train = train_df.drop('Survived',axis=1)\ny_train = train_df.Survived","cccd7061":"from sklearn.model_selection import GridSearchCV, cross_val_score, RepeatedStratifiedKFold, train_test_split\nfrom xgboost import XGBClassifier\nfrom sklearn.metrics import classification_report","5b6a6cb9":"# Fit to the model without any tuning\nmodel = XGBClassifier()\ncv = RepeatedStratifiedKFold(n_splits=10, n_repeats=5, random_state=11)\nscores = cross_val_score(model, x_train, y_train, cv=cv, n_jobs=-1, verbose=True, scoring='roc_auc')\nprint(np.mean(scores),np.std(scores))","31580b71":"#model = XGBClassifier(random_state=11)\n#cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=11)\n#params = {\n    #'n_estimators':[50,100,200,500],\n    #'max_depth':[3,6,9],\n    #'subsample':[0.3,0.5,0.7,1],\n    #'learning_rate':[0.0001,0.001,0.01,0.1,1],\n    #'colsample_bytree':[0.3,0.5,0.7,1]\n#}\n#model_grid = GridSearchCV(model, params, cv=cv,n_jobs=-1, verbose=1, scoring='roc_auc')\n#model_grid.fit(x_train, y_train)\n#print('Best mark:',model_grid.best_score_, '\\nBest params:',model_grid.best_params_)","fd3709f7":"### Plot the learning curve of the model with best params\nbest_model = XGBClassifier(n_estimators=100, \n                           subsample=0.7, \n                           max_depth=3, \n                           learning_rate=0.01, \n                           colsample_bytree=1)","e24803bb":"best_model.fit(x_train,y_train)\nanswer = pd.DataFrame(best_model.predict(test_df))\ntest_file  = pd.read_csv('..\/input\/titanic\/test.csv')\nanswer['PassengerId']= test_file.PassengerId.tolist()\nanswer.set_index('PassengerId',inplace=True)\nanswer.columns=['Survived']\nanswer.Survived = answer.Survived.astype('int')\nanswer.to_csv('answer_xgb_binning_new02_bin7_familysize02.csv')","8ddbbfbc":"## Split train set to x and y","4bb57559":"### Fare ","57063871":"#### Family size \n- family size > 4 --> 4","05292857":"#### Drop the passengerID and Cabin column","89bd5f13":"- There is over 1000 missing data in 'Cabin' column, I will drop this column.\n- over 250 in Age\n- Ignore the missing data in 'Survived' column","a35980cd":"## Start training model","98e40044":"# Basic Data analysis","0cbe057b":"### Combined the data for preprocessing","7e72ca85":"Age and Pclass has a more obvious negative correlation, now fill the missing age according to their pclass","234683ac":"There 116 rows of outliers in training set, I don't want to drop too much row, lets make the threshold higher to 100.","c12e2db6":"# Save the output","fbb8b186":"The variance of Fare is quite high.","9d6e913b":"#### Number of survival vs not survival","10a0309b":"## Split back to train and test set","af8aea8f":"# Data EDA and filling missing data.","8944dba7":"# Titanic Survival Classification project\n\n- Just finished my GBT tutorial, try to apply what I have learnt to this project.\n\n\n### Problems identification\n- Given the passagers' dataset, try the predict whether they survive or not in the accident.\n\n### Data\n#### Data downloaded from kaggle\n\n#### training set (train.csv)\n#### test set (test.csv)\n- The training set should be used to build your machine learning models. For the training set, we provide the outcome (also known as the \u201cground truth\u201d) for each passenger. Your model will be based on \u201cfeatures\u201d like passengers\u2019 gender and class. You can also use feature engineering to create new features.\n\n- The test set should be used to see how well your model performs on unseen data. For the test set, we do not provide the ground truth for each passenger. It is your job to predict these outcomes. For each passenger in the test set, use the model you trained to predict whether or not they survived the sinking of the Titanic.\n\n#### Data Dictionary\n- survival:Survival (0 = No, 1 = Yes)\n- pclass: Ticket class (1 = 1st, 2 = 2nd, 3 = 3rd)\n- sex: Sex\n- Age: Age in years\n- sibsp: # of siblings \/ spouses aboard the Titanic\n- parch: # of parents \/ children aboard the Titanic\n- ticket: Ticket number\n- fare: Passenger fare\n- cabin: Cabin number\n- embarked: Port of Embarkation (C = Cherbourg, Q = Queenstown, S = Southampton)\n- More info: see-> https:\/\/www.kaggle.com\/c\/titanic\/data","b9b34849":"#### Correlation","74bc3a3b":"### Name\n- extracting title from name and create new column for it.","53666926":"# Basic information of the data","f833cbf2":"### Binning the age and fare","ad730074":"# Features Engineering","5ed87fc7":"The passenager with family size 0 has lower rate of survivral than other group,","454dbcc8":"### Combine SibSp and Parch into 'family_size' column","4136683e":"- There are many outliers in Fare column ,I am going to filter out it.","fa88ad74":"### Embarked","76c8738a":"### Survived vs Sex, Pclass, Embarled","90449541":"- There are missing data in Fare column, we fill it with median\n","8210f6a3":"# Predict the answer","6d9d2166":"### Grid search the hyperparameters","cab6ca97":"### Age","1c83e812":"#### No more missing values now.","a6f2708c":"#### Label encoding : Sex, embarked","81d2a600":"Like gender, the survival rate of Mr. is lower than Miss. or Mrs.","a87b3d59":"- Female survivral rate > male\n- Pclass 3 survivral rate < other pclass\n- People embarked at S have lower survival rate than other"}}