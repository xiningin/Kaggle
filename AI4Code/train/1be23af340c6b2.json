{"cell_type":{"0d0d8946":"code","d924b264":"code","1d114387":"code","360c561c":"code","a13e3692":"code","10c49fc3":"code","c0222c40":"code","ba889640":"code","e9a5693f":"code","f953d5ef":"code","e892f5d1":"code","0109c9c8":"code","30cdfa7a":"code","1f738f2e":"code","7f9cc8f1":"code","0177b4f8":"code","4eeb905a":"code","82e965a2":"code","2f577781":"code","72140e91":"code","abfd8b58":"code","4976f5a2":"code","22dc0d62":"code","a1f7b969":"code","eb9a7142":"code","49620a21":"code","08a23c96":"code","1fa01a54":"markdown","3670931f":"markdown","6a384047":"markdown","ebf5d695":"markdown","8f94497c":"markdown","8e843f8c":"markdown","110e32da":"markdown","0ccc726f":"markdown","9f32e781":"markdown","bde2554f":"markdown","2f2136bc":"markdown","dfb6d19b":"markdown","f863e611":"markdown","828f37f9":"markdown","ce59c7e4":"markdown","22dad691":"markdown","2cb0bc1c":"markdown","cb292335":"markdown","63c33c1a":"markdown","11540d3d":"markdown","cb79538b":"markdown"},"source":{"0d0d8946":"# can comment out after executing\n# !unzip processed_celeba_small.zip","d924b264":"#import os\n#for dirname in os.walk('\/kaggle\/input'):\n   # print(dirname[:15])","1d114387":"data_dir = '\/kaggle\/input\/facegenerationdata\/processed_celeba_small\/processed_celeba_small\/'\n\n# import module we'll need to import our custom module\nfrom shutil import copyfile\n\n# copy our file into the working directory (make sure it has .py suffix)\n# copyfile(src = \"\/kaggle\/input\/assets\/helper.py\", dst = \"..\/working\/helper.py\")\ncopyfile(src = \"\/kaggle\/input\/facegenerationdata\/assets\/problem_unittests.py\", dst = \"..\/working\/problem_unittests.py\")\n\"\"\"\nDON'T MODIFY ANYTHING IN THIS CELL\n\"\"\"\nimport pickle as pkl\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport problem_unittests as tests\n#import helper\n\n%matplotlib inline","360c561c":"# necessary imports\n\nimport torch\nfrom torchvision import datasets\nfrom torchvision import transforms","a13e3692":"def get_dataloader(batch_size, image_size, data_dir='\/kaggle\/input\/facegenerationdata\/processed_celeba_small\/processed_celeba_small\/'):\n    \"\"\"\n    Batch the neural network data using DataLoader\n    :param batch_size: The size of each batch; the number of images in a batch\n    :param img_size: The square size of the image data (x, y)\n    :param data_dir: Directory where image data is located\n    :return: DataLoader with batched data\n    \"\"\"\n    \n    # This Below Code is written for Center Cropping the Images               \n    transform = transforms.Compose([\n        transforms.Resize(image_size),\n        transforms.CenterCrop(image_size),\n        transforms.ToTensor(),\n        #transforms.Normalize(mean=(0.5, 0.5, 0.5), std=(0.5, 0.5, 0.5))\n    ])               \n    \n    dataset = datasets.ImageFolder(data_dir, transform=transform)\n    \n    # TODO: Implement Function and Return a DataLoader\n    image_transforms = transforms.Compose([transforms.Resize(image_size),\n                                           transforms.ToTensor(),\n                                          ])\n    dataloader = torch.utils.data.DataLoader(datasets.ImageFolder(data_dir, transform=image_transforms)\n                                             , shuffle=True, batch_size=batch_size)\n    \n    return dataloader","10c49fc3":"# Define function hyperparameters\nbatch_size = 30\nimg_size = 32\n\n\"\"\"\nDON'T MODIFY ANYTHING IN THIS CELL THAT IS BELOW THIS LINE\n\"\"\"\n# Call your function and get a dataloader\nceleba_train_loader = get_dataloader(batch_size, img_size)\n","c0222c40":"celeba_train_loader","ba889640":"# helper display function\ndef imshow(img):\n    npimg = img.numpy()\n    plt.imshow(np.transpose(npimg, (1, 2, 0)))\n\n\"\"\"\nDON'T MODIFY ANYTHING IN THIS CELL THAT IS BELOW THIS LINE\n\"\"\"\n# obtain one batch of training images\ndataiter = iter(celeba_train_loader)\nimages, _ = dataiter.next() # _ for no labels\n\n# plot the images in the batch, along with the corresponding labels\nfig = plt.figure(figsize=(20, 4))\nplot_size=20\nfor idx in np.arange(plot_size):\n    ax = fig.add_subplot(2, plot_size\/2, idx+1, xticks=[], yticks=[])\n    imshow(images[idx])","e9a5693f":"# TODO: Complete the scale function\ndef scale(x, feature_range=(-1, 1)):\n    \n    ''' Scale takes in an image x and returns that image, scaled\n       with a feature_range of pixel values from -1 to 1. \n       This function assumes that the input x is already scaled from 0-1.'''\n    \n    # assume x is scaled to (0, 1)\n    # scale to feature_range and return scaled x\n    min, max = feature_range\n    \n   # Print(x)\n    x = x * (max - min) + min\n    # You can Write the Above Syntax as here ---> x*(feature_range[1] - feature_range[0]) + feature_range[0]\n    \n    return x\n","f953d5ef":"\"\"\"\nDON'T MODIFY ANYTHING IN THIS CELL THAT IS BELOW THIS LINE\n\"\"\"\n# check scaled range\n# should be close to -1 to 1\nimg = images[0]\nscaled_img = scale(img)\n\nprint('Min: ', scaled_img.min())\nprint('Max: ', scaled_img.max())","e892f5d1":"import torch.nn as nn\nimport torch.nn.functional as F","0109c9c8":"# Hepler Convoluitonal Function\ndef conv(in_channels, out_channels, kernel_size, stride=2, padding=1, batch_norm=True):\n    \n    \"\"\"\n        Creates a Convolutional Layer, with Optional Batch Normalization.\n    \"\"\"\n    \n    layers = []\n    conv_layer = nn.Conv2d(in_channels, out_channels, \n                           kernel_size, stride, padding, bias=False)\n    \n    # Append Convolutional Layer\n    layers.append(conv_layer)\n\n    if batch_norm:\n        \n        # Append Batch Normalization Layer\n        layers.append(nn.BatchNorm2d(out_channels))\n    \n    # Using Sequential Container\n    return nn.Sequential(*layers)","30cdfa7a":"class Discriminator(nn.Module):\n\n    def __init__(self, conv_dim):\n        \"\"\"\n        Initialize the Discriminator Module\n        :param conv_dim: The depth of the first convolutional layer\n        \"\"\"\n        super(Discriminator, self).__init__()\n\n        # complete init function\n        self.conv_dim = conv_dim\n        \n        # Define All Convolutional Layers\n        # Should Accept RGB as Input & Output a Single Value\n        \n        # For Input of 32x32 & For First Layer, no batch_norm\n        self.conv1 = conv(3, conv_dim, 4, batch_norm=False)\n        \n        # For Output of 16x16\n        self.conv2 = conv(conv_dim, conv_dim*2, 4)\n        \n        # For Output of 8x8\n        self.conv3 = conv(conv_dim*2, conv_dim*4, 4)\n        \n        # For Output of 4x4\n        self.conv4 = conv(conv_dim*4, conv_dim*8, 4)\n        \n        # For Output of 2x2\n        # Now Final, Fully-Connected Layer\n        self.fc = nn.Linear(conv_dim*8*2*2, 1)\n        \n        # For Final Output Apply Sigmoid Activation Function\n        self.out = nn.Sigmoid()\n        \n        # Apply Dropout If Needed\n        self.dropout = nn.Dropout(0.5)\n\n        \n    def forward(self, x):\n        \"\"\"\n        Forward propagation of the neural network\n        :param x: The input to the neural network     \n        :return: Discriminator logits; the output of the neural network\n        \"\"\"\n       # Define Feed-Forward Behaviour\n        # All Hidden Layers & ReLu Activation Function\n        out = F.leaky_relu(self.conv1(x), 0.2)\n        out = F.leaky_relu(self.conv2(out), 0.2)\n        out = F.leaky_relu(self.conv3(out), 0.2)\n        out = F.leaky_relu(self.conv4(out), 0.2)\n        \n        # Flatten the Ouput\n        out = out.view(-1, self.conv_dim*8*2*2)\n        \n        # Final Output Layer\n        x = self.fc(out)\n        \n        # Return the Final Ouput\n        return x\n\n\n\"\"\"\nDON'T MODIFY ANYTHING IN THIS CELL THAT IS BELOW THIS LINE\n\"\"\"\ntests.test_discriminator(Discriminator)","1f738f2e":"# For Deconvolutional Function\n\ndef deconv(in_channels, out_channels, kernel_size, stride=2, padding=1, batch_norm=True):\n    \n    layers=[]\n    transpose_conv_layer = nn.ConvTranspose2d(in_channels, out_channels,\n                                             kernel_size, stride, padding, bias=False)\n    \n    # Append Transpose Convolutional Layer\n    layers.append(transpose_conv_layer)\n    \n    if batch_norm:\n        \n        # Append Batch Normalization Layer\n        layers.append(nn.BatchNorm2d(out_channels))\n    \n    # Using Sequential Container\n    return nn.Sequential(*layers)","7f9cc8f1":"class Generator(nn.Module):\n    \n    def __init__(self, z_size, conv_dim):\n        \"\"\"\n        Initialize the Generator Module\n        :param z_size: The length of the input latent vector, z\n        :param conv_dim: The depth of the inputs to the *last* transpose convolutional layer\n        \"\"\"\n        super(Generator, self).__init__()\n\n        # complete init function\n        self.conv_dim = conv_dim\n        \n        # First, Fully-Connected Layer\n        self.fc = nn.Linear(z_size, conv_dim*8*2*2)\n\n        # Transpose Covlolutional Layer\n        self.deconv1 = deconv(conv_dim*8, conv_dim*4, 4)\n        self.deconv2 = deconv(conv_dim*4, conv_dim*2, 4)\n        self.deconv3 = deconv(conv_dim*2, conv_dim, 4)\n        self.deconv4 = deconv(conv_dim, 3, 4, batch_norm=False)\n        # print('z_size', z_size) Find what does this Means\n\n    def forward(self, x):\n        \"\"\"\n        Forward Propogation of the Neural Network\n        :param x: The input to the Neural Network     \n        :return: A 32x32x3 Tensor Image as Output\n        \"\"\"\n        # Define Feed-Forward Behaviour\n        # Fully-Connected Layer & Reshape the deconv Layer\n        out = self.fc(x)\n        \n        # View the Ouput of the Fully-Connected & Reshape (batch_size, depth, 4, 4)\n        out = out.view(-1, self.conv_dim*8, 2, 2)\n        \n        # Hidden Transpose Convolutional Layers\n        # Apply the ReLu Activation Function Output\n        out = F.relu(self.deconv1(out))\n        out = F.relu(self.deconv2(out))\n        out = F.relu(self.deconv3(out))\n        \n        # Last Layer of the deconv\n        # Apply 'tanh' Activation Function to the Output\n        out = self.deconv4(out)\n        x = torch.tanh(out)\n        \n        # Return the Final Output\n        return x\n\n\"\"\"\nDON'T MODIFY ANYTHING IN THIS CELL THAT IS BELOW THIS LINE\n\"\"\"\ntests.test_generator(Generator)","0177b4f8":"def weights_init_normal(m):\n    \"\"\"\n    Applies initial weights to certain layers in a model .\n    The weights are taken from a normal distribution \n    with mean = 0, std dev = 0.02.\n    :param m: A module or layer in a network    \n    \"\"\"\n    \n    # Classname will be something like: `Conv`, `BatchNorm2d`, `Linear`, etc.\n    classname = m.__class__.__name__\n    \n    # TODO: Apply Initial Weights to Convolutional & Linear Layers\n    if hasattr(m, 'weight') and (classname.find('Conv') != -1 or classname.find('Linear') != -1):\n        m.weight.data.normal_(0.0, 0.02)\n        \n        # The Bias Terms, if they exist, Set to 0\n        if hasattr(m, 'bias') and m.bias is not None:\n            m.bias.data.zero_()\n    ","4eeb905a":"\"\"\"\nDON'T MODIFY ANYTHING IN THIS CELL THAT IS BELOW THIS LINE\n\"\"\"\ndef build_network(d_conv_dim, g_conv_dim, z_size):\n    \n    # define discriminator and generator\n    D = Discriminator(d_conv_dim)\n    G = Generator(z_size=z_size, conv_dim=g_conv_dim)\n\n    # initialize model weights\n    D.apply(weights_init_normal)\n    G.apply(weights_init_normal)\n\n    print(D)\n    print()\n    print(G)\n    \n    return D, G","82e965a2":"# Define model hyperparams\nd_conv_dim = 64\ng_conv_dim = 64\nz_size = 100\n\n\"\"\"\nDON'T MODIFY ANYTHING IN THIS CELL THAT IS BELOW THIS LINE\n\"\"\"\nD, G = build_network(d_conv_dim, g_conv_dim, z_size)","2f577781":"\"\"\"\nDON'T MODIFY ANYTHING IN THIS CELL\n\"\"\"\nimport torch\n\n# Check for a GPU if is Available\ntrain_on_gpu = torch.cuda.is_available()\nif not train_on_gpu:\n    print('No GPU found. Please use a GPU to train your neural network.')\nelse:\n    print('Training on GPU!')","72140e91":"import random\nfrom random import randrange, uniform\n\ndef real_loss(D_out, smooth=False):\n    \n    '''\n    Calculates How Close Discriminator Outputs are to Being Real.\n    param, D_out: Discriminator logits\n    return: real loss\n    '''\n    batch_size = D_out.size(0)\n    \n    # Label Smoothing\n    if smooth:\n        # Smooth, Real Labels = 0.9\n        labels = torch.ones(batch_size)*0.9\n    else:\n        # Real Labels = 1\n        labels = torch.ones(batch_size)\n    \n    # Move Labels to GPU if is Available\n    if train_on_gpu:\n        labels = labels.cuda()\n    \n    # Binary Cross-Entropy with Logits Loss\n    criterion = nn.BCEWithLogitsLoss()\n    \n    # Calculate Loss\n    loss = criterion(D_out.squeeze(), labels)\n    \n    # Return the Calculated Loss\n    return loss\n\ndef fake_loss(D_out):\n    '''\n    Calculates How Close Discriminator Outputs are to Being Fake.\n    param, D_out: Discriminator Logits\n    return: Fake Loss\n    '''\n    batch_size = D_out.size(0)\n    \n    # Fake Labels = 0\n    labels = torch.zeros(batch_size)\n    \n    # Move Labels to GPU if is Available\n    if train_on_gpu:\n        labels = labels.cuda()\n    \n    # Binary Cross-Entropy with Logits Loss\n    criterion = nn.BCEWithLogitsLoss()\n    \n    # Calculate Loss\n    loss = criterion(D_out.squeeze(), labels)\n    \n    # Return the Calculated Loss\n    return loss","abfd8b58":"import torch.optim as optim\n\n# Create Optimizers for the Discriminator D and Generator G\nd_optimizer = optim.Adam(D.parameters(), lr=0.0005, betas=(0.4, 0.999))\ng_optimizer = optim.Adam(G.parameters(), lr=0.0005, betas=(0.4, 0.999))","4976f5a2":"def train(D, G, n_epochs, print_every=50):\n    '''Trains adversarial networks for some number of epochs\n       param, D: the discriminator network\n       param, G: the generator network\n       param, n_epochs: number of epochs to train for\n       param, print_every: when to print and record the models' losses\n       return: D and G losses'''\n    \n    # move models to GPU\n    if train_on_gpu:\n        D.cuda()\n        G.cuda()\n\n    # keep track of loss and generated, \"fake\" samples\n    samples = []\n    losses = []\n\n    # Get some fixed data for sampling. These are images that are held\n    # constant throughout training, and allow us to inspect the model's performance\n    sample_size=16\n    fixed_z = np.random.uniform(-1, 1, size=(sample_size, z_size))\n    fixed_z = torch.from_numpy(fixed_z).float()\n    # move z to GPU if available\n    if train_on_gpu:\n        fixed_z = fixed_z.cuda()\n\n    # epoch training loop\n    for epoch in range(n_epochs):\n\n        # batch training loop\n        for batch_i, (real_images, _) in enumerate(celeba_train_loader):\n\n            batch_size = real_images.size(0)\n            real_images = scale(real_images)\n\n            # ===============================================\n            #         YOUR CODE HERE: TRAIN THE NETWORKS\n            # ===============================================\n            \n            # 1. Train the discriminator on real and fake images\n            \n            d_optimizer.zero_grad()\n            \n            # Check If GPU is Available\n            if train_on_gpu:\n                real_images = real_images.cuda()\n            \n            # 1. Train the Discriminator on Real and Fake Images\n            \n            # Compute the Discriminator Losses on Real Images\n            D_real = D(real_images)\n            d_real_loss = real_loss(D_real)\n            \n            # Generate Fake Images\n            z_fake = np.random.uniform(-1, 1, size=(batch_size, z_size))\n            z_fake = torch.from_numpy(z_fake).float()\n            \n            # Move to GPU if is Available\n            if train_on_gpu:\n                z_fake = z_fake.cuda()\n            fake_images = G(z_fake)\n            \n            # Compute the Discriminator Losses on Fake Images\n            D_fake = D(fake_images)\n            d_fake_loss = fake_loss(D_fake)\n            \n            # Add Up Loss and Perform Back Propagation\n            d_loss = d_real_loss + d_fake_loss\n            d_loss.backward()\n            d_optimizer.step()\n\n            # 2. Train the Generator with an Adversarial Loss\n            g_optimizer.zero_grad()\n            \n            # Generate Fake Images\n            z_fake = np.random.uniform(-1, 1, size=(batch_size, z_size))\n            z_fake = torch.from_numpy(z_fake).float()\n            \n            # Check If GPU is Available\n            if train_on_gpu:\n                z_fake = z_fake.cuda()\n            fake_images = G(z_fake)\n            \n            # Compute the Discriminator Losses on Fake Images\n            D_fake = D(fake_images)\n            \n            # Use Real Loss to Flip Labels\n            g_loss = real_loss(D_fake, True)\n            \n            # Perform Back Propagation\n            g_loss.backward()\n            g_optimizer.step()\n            \n            \n            # ===============================================\n            #              END OF YOUR CODE\n            # ===============================================\n\n            # Print Some Loss Stats\n            if batch_i % print_every == 0:\n                \n                # Append Discriminator Loss and Generator Loss\n                losses.append((d_loss.item(), g_loss.item()))\n                \n                # Print Discriminator and Generator Loss\n                print('Epoch [{:5d}\/{:5d}] | d_loss: {:6.4f} | g_loss: {:6.4f}'.format(\n                        epoch+1, n_epochs, d_loss.item(), g_loss.item()))\n\n\n      \n        ## AFTER EACH EPOCH##    \n        # this code assumes your generator is named G, feel free to change the name\n        # generate and save sample, fake images\n        G.eval() # for generating samples\n        samples_z = G(fixed_z)\n        samples.append(samples_z)\n        G.train() # back to training mode\n\n    # Save training generator samples\n    with open('train_samples.pkl', 'wb') as f:\n        pkl.dump(samples, f)\n    \n    # finally return losses\n    return losses","22dc0d62":"# set number of epochs \nn_epochs = 20\n\n\n\"\"\"\nDON'T MODIFY ANYTHING IN THIS CELL\n\"\"\"\n# call training function\nlosses = train(D, G, n_epochs=n_epochs)","a1f7b969":"fig, ax = plt.subplots()\nlosses = np.array(losses)\nplt.plot(losses.T[0], label='Discriminator', alpha=0.5)\nplt.plot(losses.T[1], label='Generator', alpha=0.5)\nplt.title(\"Training Losses\")\nplt.legend()","eb9a7142":"# helper function for viewing a list of passed in sample images\ndef view_samples(epoch, samples):\n    fig, axes = plt.subplots(figsize=(16,4), nrows=2, ncols=8, sharey=True, sharex=True)\n    for ax, img in zip(axes.flatten(), samples[epoch]):\n        img = img.detach().cpu().numpy()\n        img = np.transpose(img, (1, 2, 0))\n        img = ((img + 1)*255 \/ (2)).astype(np.uint8)\n        ax.xaxis.set_visible(False)\n        ax.yaxis.set_visible(False)\n        im = ax.imshow(img.reshape((32,32,3)))","49620a21":"# Load samples from generator, taken while training\nwith open('train_samples.pkl', 'rb') as f:\n    samples = pkl.load(f)","08a23c96":"_ = view_samples(-1, samples)","1fa01a54":"**Answer:** (Write your answer in this cell)","3670931f":"Set your number of training epochs and train your GAN!","6a384047":"#### Exercise: Complete the training function\n\nKeep in mind that, if you've moved your models to GPU, you'll also have to move any model inputs to GPU.","ebf5d695":"---\n## Training\n\nTraining will involve alternating between training the discriminator and the generator. You'll use your functions `real_loss` and `fake_loss` to help you calculate the discriminator losses.\n\n* You should train the discriminator by alternating on real and fake images\n* Then the generator, which tries to trick the discriminator and should have an opposing loss function\n\n\n#### Saving Samples\n\nYou've been given some code to print out some loss statistics and save some generated \"fake\" samples.","8f94497c":"## Optimizers\n\n#### Exercise: Define optimizers for your Discriminator (D) and Generator (G)\n\nDefine optimizers for your models with appropriate hyperparameters.","8e843f8c":"### Training on GPU\n\nCheck if you can train on GPU. Here, we'll set this as a boolean variable `train_on_gpu`. Later, you'll be responsible for making sure that \n>* Models,\n* Model inputs, and\n* Loss function arguments\n\nAre moved to GPU, where appropriate.","110e32da":"## Generator\n\nThe generator should upsample an input and generate a *new* image of the same size as our training data `32x32x3`. This should be mostly transpose convolutional layers with normalization applied to the outputs.\n\n#### Exercise: Complete the Generator class\n* The inputs to the generator are vectors of some length `z_size`\n* The output should be a image of shape `32x32x3`","0ccc726f":"Next, you can view some images! You should seen square images of somewhat-centered faces.\n\nNote: You'll need to convert the Tensor images into a NumPy type and transpose the dimensions to correctly display an image, suggested `imshow` code is below, but it may not be perfect.","9f32e781":"## Visualize the CelebA Data\n\nThe [CelebA](http:\/\/mmlab.ie.cuhk.edu.hk\/projects\/CelebA.html) dataset contains over 200,000 celebrity images with annotations. Since you're going to be generating faces, you won't need the annotations, you'll only need the images. Note that these are color images with [3 color channels (RGB)](https:\/\/en.wikipedia.org\/wiki\/Channel_(digital_image)#RGB_Images) each.\n\n### Pre-process and Load the Data\n\nSince the project's main focus is on building the GANs, we've done *some* of the pre-processing for you. Each of the CelebA images has been cropped to remove parts of the image that don't include a face, then resized down to 64x64x3 NumPy images. This *pre-processed* dataset is a smaller subset of the very large CelebA data.\n\n> There are a few other steps that you'll need to **transform** this data and create a **DataLoader**.\n\n#### Exercise: Complete the following `get_dataloader` function, such that it satisfies these requirements:\n\n* Your images should be square, Tensor images of size `image_size x image_size` in the x and y dimension.\n* Your function should return a DataLoader that shuffles and batches these Tensor images.\n\n#### ImageFolder\n\nTo create a dataset given a directory of images, it's recommended that you use PyTorch's [ImageFolder](https:\/\/pytorch.org\/docs\/stable\/torchvision\/datasets.html#imagefolder) wrapper, with a root directory `processed_celeba_small\/` and data transformation passed in.","bde2554f":"# Face Generation\n\nIn this project, you'll define and train a DCGAN on a dataset of faces. Your goal is to get a generator network to generate *new* images of faces that look as realistic as possible!\n\nThe project will be broken down into a series of tasks from **loading in data to defining and training adversarial networks**. At the end of the notebook, you'll be able to visualize the results of your trained Generator to see how it performs; your generated samples should look like fairly realistic faces with small amounts of noise.\n\n### Get the Data\n\nYou'll be using the [CelebFaces Attributes Dataset (CelebA)](http:\/\/mmlab.ie.cuhk.edu.hk\/projects\/CelebA.html) to train your adversarial networks.\n\nThis dataset is more complex than the number datasets (like MNIST or SVHN) you've been working with, and so, you should prepare to define deeper networks and train them for a longer time to get good results. It is suggested that you utilize a GPU for training.\n\n### Pre-processed Data\n\nSince the project's main focus is on building the GANs, we've done *some* of the pre-processing for you. Each of the CelebA images has been cropped to remove parts of the image that don't include a face, then resized down to 64x64x3 NumPy images. Some sample data is show below.\n\n<img src='assets\/processed_face_data.png' width=60% \/>\n\n> If you are working locally, you can download this data [by clicking here](https:\/\/s3.amazonaws.com\/video.udacity-data.com\/topher\/2018\/November\/5be7eb6f_processed-celeba-small\/processed-celeba-small.zip)\n\nThis is a zip file that you'll need to extract in the home directory of this notebook for further loading and processing. After extracting the data, you should be left with a directory of data `processed_celeba_small\/`","2f2136bc":"## Generator samples from training\n\nView samples of images from the generator, and answer a question about the strengths and weaknesses of your trained models.","dfb6d19b":"---\n## Discriminator and Generator Losses\n\nNow we need to calculate the losses for both types of adversarial networks.\n\n### Discriminator Losses\n\n> * For the discriminator, the total loss is the sum of the losses for real and fake images, `d_loss = d_real_loss + d_fake_loss`. \n* Remember that we want the discriminator to output 1 for real images and 0 for fake images, so we need to set up the losses to reflect that.\n\n\n### Generator Loss\n\nThe generator loss will look similar only with flipped labels. The generator's goal is to get the discriminator to *think* its generated images are *real*.\n\n#### Exercise: Complete real and fake loss functions\n\n**You may choose to use either cross entropy or a least squares error loss to complete the following `real_loss` and `fake_loss` functions.**","f863e611":"## Create a DataLoader\n\n#### Exercise: Create a DataLoader `celeba_train_loader` with appropriate hyperparameters.\n\nCall the above function and create a dataloader to view images. \n* You can decide on any reasonable `batch_size` parameter\n* Your `image_size` **must be** `32`. Resizing the data to a smaller size will make for faster training, while still creating convincing images of faces!","828f37f9":"#### Exercise: Define model hyperparameters","ce59c7e4":"### Submitting This Project\nWhen submitting this project, make sure to run all the cells before saving the notebook. Save the notebook file as \"dlnd_face_generation.ipynb\" and save it as a HTML file under \"File\" -> \"Download as\". Include the \"problem_unittests.py\" files in your submission.","22dad691":"### Question: What do you notice about your generated samples and how might you improve this model?\nWhen you answer this question, consider the following factors:\n* The dataset is biased; it is made of \"celebrity\" faces that are mostly white\n* Model size; larger models have the opportunity to learn more features in a data feature space\n* Optimization strategy; optimizers and number of epochs affect your final result\n","2cb0bc1c":"#### Exercise: Pre-process your image data and scale it to a pixel range of -1 to 1\n\nYou need to do a bit of pre-processing; you know that the output of a `tanh` activated generator will contain pixel values in a range from -1 to 1, and so, we need to rescale our training images to a range of -1 to 1. (Right now, they are in a range from 0-1.)","cb292335":"## Initialize the weights of your networks\n\nTo help your models converge, you should initialize the weights of the convolutional and linear layers in your model. From reading the [original DCGAN paper](https:\/\/arxiv.org\/pdf\/1511.06434.pdf), they say:\n> All weights were initialized from a zero-centered Normal distribution with standard deviation 0.02.\n\nSo, your next task will be to define a weight initialization function that does just this!\n\nYou can refer back to the lesson on weight initialization or even consult existing model code, such as that from [the `networks.py` file in CycleGAN Github repository](https:\/\/github.com\/junyanz\/pytorch-CycleGAN-and-pix2pix\/blob\/master\/models\/networks.py) to help you complete this function.\n\n#### Exercise: Complete the weight initialization function\n\n* This should initialize only **convolutional** and **linear** layers\n* Initialize the weights to a normal distribution, centered around 0, with a standard deviation of 0.02.\n* The bias terms, if they exist, may be left alone or set to 0.","63c33c1a":"## Training loss\n\nPlot the training losses for the generator and discriminator, recorded after each epoch.","11540d3d":"## Build complete network\n\nDefine your models' hyperparameters and instantiate the discriminator and generator from the classes defined above. Make sure you've passed in the correct input arguments.","cb79538b":"---\n# Define the Model\n\nA GAN is comprised of two adversarial networks, a discriminator and a generator.\n\n## Discriminator\n\nYour first task will be to define the discriminator. This is a convolutional classifier like you've built before, only without any maxpooling layers. To deal with this complex data, it's suggested you use a deep network with **normalization**. You are also allowed to create any helper functions that may be useful.\n\n#### Exercise: Complete the Discriminator class\n* The inputs to the discriminator are 32x32x3 tensor images\n* The output should be a single value that will indicate whether a given image is real or fake\n"}}