{"cell_type":{"eb0b6b42":"code","80779cb8":"code","34760ac8":"code","45324394":"code","8b2cdac0":"code","98197b97":"code","6ce0bcdb":"code","0f068cd6":"code","cee828b2":"code","8ebe53c0":"code","8df2ead4":"code","4aa138bf":"code","21fd05dc":"code","c6699bc1":"code","889d424e":"code","b7aea9c0":"code","1029a42d":"code","08d2bfa7":"code","b806881b":"code","3344214b":"code","5c65216e":"code","5c379c16":"code","c59ad142":"code","2206baef":"code","3346bfbd":"code","1ebad360":"code","1689d50b":"code","98e868c7":"code","43d2027f":"code","7cd8763a":"code","3d893907":"code","8bfd4e89":"code","20862e41":"code","161cb6cb":"code","3d4a2440":"code","1f1ca0e3":"code","8c7e281d":"code","9dcb4d32":"code","066abb12":"code","b91a330c":"code","29afd4d9":"code","5052d597":"code","481b8603":"code","6e4ff11f":"code","3488f1b8":"code","d4138146":"code","1861b497":"code","cbc2a064":"code","3a3605e2":"code","0bfd7a07":"code","630f95c1":"code","1a43104a":"code","f6751035":"code","e7dc99f6":"code","7ccfcbe0":"markdown","71e53b25":"markdown","89018b75":"markdown","740bd58f":"markdown","969d8b6a":"markdown","354d6d59":"markdown","8a0eb261":"markdown","e3f3f61c":"markdown","b22df06f":"markdown","cfbb8973":"markdown","b7e5dbf9":"markdown","452a7c01":"markdown","229bfa53":"markdown","a4b35ef3":"markdown","85465187":"markdown","699ffef5":"markdown","a2d6db3a":"markdown","eaacb047":"markdown","819cd657":"markdown","abf60786":"markdown","f0ff68a8":"markdown","82db027e":"markdown","ccde8dbc":"markdown","43c3bf2e":"markdown","7c7c8b7f":"markdown","90db067d":"markdown","e2efac7b":"markdown","86e42962":"markdown","8ebe97ff":"markdown","64229cdd":"markdown","ee9d6a53":"markdown","a3a66005":"markdown","b87f7410":"markdown","e0c28f2a":"markdown","5faec84d":"markdown","5076b430":"markdown","5a72f1e6":"markdown","92338bce":"markdown","7a95c803":"markdown","8842eaee":"markdown","9f80b082":"markdown","b5ece178":"markdown","8c073a1f":"markdown","f68a2119":"markdown","d2b14f94":"markdown","43b9eb80":"markdown","21357bfb":"markdown","652eb0da":"markdown","cc5ad8f8":"markdown","4bbfe43f":"markdown","282724dc":"markdown","60ace6df":"markdown","7e11d251":"markdown","c1527207":"markdown","882b16d0":"markdown","a59b47f1":"markdown","cd37fc4f":"markdown"},"source":{"eb0b6b42":"#import linear algebra and data manipulation libraries\nimport numpy as np\nimport pandas as pd\n\n#import date manipulation\nimport datetime as dt\nfrom datetime import date, timedelta\n\n#import standard visualization\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n#import machine learning\nfrom sklearn.linear_model import LinearRegression\nimport xgboost\n\nfrom sklearn.model_selection import train_test_split #split\nfrom sklearn.metrics import r2_score, mean_squared_error #metrics\n\n# import helpers\nimport re","80779cb8":"kernels = pd.read_csv('..\/input\/meta-kaggle\/Kernels.csv')\nkernel_lang = pd.read_csv('..\/input\/meta-kaggle\/KernelLanguages.csv')\nkernel_tags = pd.read_csv('..\/input\/meta-kaggle\/KernelTags.csv')\nkernel_votes = pd.read_csv('..\/input\/meta-kaggle\/KernelVotes.csv')\nkernel_versions = pd.read_csv('..\/input\/meta-kaggle\/KernelVersions.csv')\nkernel_competitions = pd.read_csv('..\/input\/meta-kaggle\/KernelVersionCompetitionSources.csv')\nkernel_users = pd.read_csv('..\/input\/meta-kaggle\/Users.csv')\ndatasets = pd.read_csv('..\/input\/meta-kaggle\/Datasets.csv')\nkernel_datasets = pd.read_csv('..\/input\/meta-kaggle\/KernelVersionDatasetSources.csv')\ndataset_versions = pd.read_csv('..\/input\/meta-kaggle\/DatasetVersions.csv')\ntags = pd.read_csv('..\/input\/meta-kaggle\/Tags.csv')\ncompetitions = pd.read_csv('..\/input\/meta-kaggle\/Competitions.csv')\nmessages = pd.read_csv('..\/input\/meta-kaggle\/ForumMessages.csv')","34760ac8":"total_kernels = len(kernels['Id'].unique())\nprint('Total number of kernels: {total_kernels}'.format(total_kernels = total_kernels))\n\ntotal_public = len(kernels[pd.notnull(kernels['MadePublicDate'])])\nprint('Total number of public kernels: {total_public_kernels}'.format(total_public_kernels = total_public))\n\ntotal_upvoted = len(kernels[ kernels['TotalVotes'] > 0])\nprint('Total number of kernels with upvotes: {total_upvoted}'.format(total_upvoted = total_upvoted))\n\ntotal_awarded = len(kernels[np.isfinite(kernels['Medal'])])\nprint('Total number of kernels with any medal: {total_awarded}'.format(total_awarded = total_awarded))\n\ntotal_no_upvotes = total_public - total_upvoted\nprint('Total number of public kernels with no upvotes: {total_no_upvotes}'.format(total_no_upvotes = total_no_upvotes))\n\ntotal_private = total_kernels - total_public\nprint('Total number of private kernels: {total_private}'.format(total_private = total_private))\n\ntotal_upvoted_not_awarded = total_upvoted - total_awarded\nprint('Total number of upvoted, but not awarded: {total_upvoted_not_awarded}'.format(total_upvoted_not_awarded = total_upvoted_not_awarded))","45324394":"#plot statistics with matplotlib\n\nlabels = 'Private', 'Public with no upvotes', 'Upvoted but not awarded', 'Awarded'\nsizes = [total_private, total_no_upvotes, total_upvoted_not_awarded, total_awarded]\nexplode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\nfig1, ax1 = plt.subplots()\nax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',\n        shadow=True, startangle=180)\nax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.\n\nfig1.set_figheight(7)\nfig1.set_figwidth(7)\n\nplt.title('Statistics for upvoted and awarded kernels')\n\nplt.show()","8b2cdac0":"#columns to find out correlation\ncols = ['TotalViews', 'TotalComments', 'TotalVotes']\n\n#Find out correlation between columns and plot\ncorrs = np.corrcoef(kernels[cols].values.T)\nsns.set(font_scale=1)\nsns.set(rc={'figure.figsize':(7,7)})\nhm=sns.heatmap(corrs, cbar = True, annot=True, square = True, fmt = '.2f',\n              yticklabels = cols, xticklabels = cols).set_title('Correlations heatmap')\n\nfig = hm.get_figure()\nfig.savefig('correlations.png')","98197b97":"#get average number of votes per number of views\nvotes_by_views = kernels.groupby('TotalViews').mean().reset_index()[['TotalViews', 'TotalVotes']]\nvotes_by_views = votes_by_views.sort_values(by = 'TotalViews', ascending = True)\n\n# fit a linear regression model on views and votes data\nmodel = LinearRegression()\nmodel.fit(votes_by_views['TotalViews'].values.reshape(-1, 1), votes_by_views['TotalVotes'].values.reshape(-1, 1))\n\ninputs = np.linspace(1, 1200000, num=50)\npredictions = model.predict(inputs.reshape(-1,1))","6ce0bcdb":"#plot with matplotlib along with predictions from the linear regression model\n\nplt.scatter(votes_by_views['TotalViews'], votes_by_views['TotalVotes'])\nplt.plot(inputs, predictions, color='green')\n\nplt.title(\"Number of votes per number of views\")\nplt.xlabel(\"Views\")\nplt.ylabel(\"Votes\")\n\nplt.show()","0f068cd6":"#get average number of votes per number of comments\nvotes_by_comments = kernels.groupby('TotalComments').mean().reset_index()[['TotalComments', 'TotalVotes']]\nvotes_by_comments = votes_by_comments.sort_values(by = 'TotalComments', ascending = True)\n\n# fit a linear regression model on comments and votes data\nmodel = LinearRegression()\nmodel.fit(votes_by_comments['TotalComments'].values.reshape(-1, 1), votes_by_comments['TotalVotes'].values.reshape(-1, 1))\n\ninputs = np.linspace(1, 1000, num=50)\npredictions = model.predict(inputs.reshape(-1,1))","cee828b2":"#plot with matplotlib along with predictions from the linear regression model\n\nplt.scatter(votes_by_comments['TotalComments'], votes_by_comments['TotalVotes'])\nplt.plot(inputs, predictions, color='green')\n\nplt.title(\"Number of votes per number of views\")\nplt.xlabel(\"Comments\")\nplt.ylabel(\"Votes\")\n\nplt.show()","8ebe53c0":"#merge kernels with users\nkernel_users_renamed = kernel_users.rename(columns={'Id': 'AuthorUserId'})\nkernels_user_tiers = kernels.merge(kernel_users_renamed, on = 'AuthorUserId')\n\n#get average number of votes per number of comments\nvotes_by_usertier= kernels_user_tiers.groupby('PerformanceTier').mean().reset_index()[['PerformanceTier', 'TotalVotes']]\nvotes_by_usertier = votes_by_usertier.sort_values(by = 'PerformanceTier', ascending = True)","8df2ead4":"#plot with matplotlib along with predictions from the linear regression model\n\nplt.plot(votes_by_usertier['PerformanceTier'], votes_by_usertier['TotalVotes'])\n\nplt.title(\"Average number of votes per kernel depending on user performance tier\")\nplt.xlabel(\"Performance Tier\")\nplt.ylabel(\"Average number of votes per kernel\")\n\nplt.show()","4aa138bf":"#prepare data for the analysis\n\nkernels_truncated = kernels[['Id' , 'CurrentKernelVersionId', 'TotalVotes']]\nkernels_truncated = kernels_truncated.rename(columns={'Id': 'KernelId', 'TotalVotes':'TotalKernelVotes',\n                                                      'CurrentKernelVersionId':'KernelVersionId'})\n\nkernel_datasets_truncated = kernel_datasets[['KernelVersionId', 'SourceDatasetVersionId']]\n\ndataset_versions_truncated = dataset_versions[['DatasetId', 'DatasourceVersionId']]\ndataset_versions_truncated = dataset_versions_truncated.rename(columns={'DatasourceVersionId': 'SourceDatasetVersionId'})\n\ndatasets_truncated = datasets[['Id', 'TotalVotes', 'TotalDownloads']]\ndatasets_truncated = datasets_truncated.rename(columns={'Id': 'DatasetId', 'TotalVotes':'TotalDatasetVotes',\n                                                      'TotalDownloads':'TotalDatasetDownloads'})\n\ndf_merge = kernels_truncated.merge(kernel_datasets_truncated, on = 'KernelVersionId')\ndf_merge = df_merge.merge(dataset_versions_truncated, on = 'SourceDatasetVersionId')\ndf_merge = df_merge.merge(datasets_truncated, on = 'DatasetId')","21fd05dc":"#columns to find out correlation\ncols = ['TotalKernelVotes', 'TotalDatasetVotes', 'TotalDatasetDownloads']\n\n#Find out correlation between columns and plot\ncorrs = np.corrcoef(df_merge[cols].values.T)\nsns.set(font_scale=1)\nsns.set(rc={'figure.figsize':(7,7)})\nhm=sns.heatmap(corrs, cbar = True, annot=True, square = True, fmt = '.2f',\n              yticklabels = cols, xticklabels = cols).set_title('Correlations heatmap')\n\nplt.yticks(rotation=0)\nfig = hm.get_figure()\nfig.savefig('correlations.png')","c6699bc1":"#get average number of votes per number of dataset votes\nvotes_by_dvotes = df_merge.groupby('TotalDatasetVotes').mean().reset_index()[['TotalDatasetVotes', 'TotalKernelVotes']]\nvotes_by_dvotes = votes_by_dvotes.sort_values(by = 'TotalDatasetVotes', ascending = True)","889d424e":"#plot with matplotlib\n\nplt.scatter(votes_by_dvotes['TotalDatasetVotes'], votes_by_dvotes['TotalKernelVotes'])\n\nplt.title(\"Number of votes per number of votes for related dataset\")\nplt.xlabel(\"Dataset Votes\")\nplt.ylabel(\"Kernel Votes\")\n\nplt.show()","b7aea9c0":"#get average number of votes per number of dataset downloads\nvotes_by_downloads = df_merge.groupby('TotalDatasetDownloads').mean().reset_index()[['TotalDatasetDownloads', 'TotalKernelVotes']]\nvotes_by_downloads = votes_by_downloads.sort_values(by = 'TotalDatasetDownloads', ascending = True)","1029a42d":"#plot with matplotlib\n\nplt.scatter(votes_by_downloads['TotalDatasetDownloads'], votes_by_downloads['TotalKernelVotes'])\n\nplt.title(\"Number of votes per number of downloads for related dataset\")\nplt.xlabel(\"Dataset Downloads\")\nplt.ylabel(\"Kernel Votes\")\n\nplt.show()","08d2bfa7":"kernel_lang","b806881b":"#prepare the data for the analysis\n\nkernels_trc = kernels[['Id' , 'TotalVotes', 'CurrentKernelVersionId']]\nkernels_trc = kernels_trc.rename(columns = {'Id': 'ScriptId', 'CurrentKernelVersionId' : 'VersionId'})\n\nkernel_versions_trc = kernel_versions[['Id', 'ScriptId', 'ScriptLanguageId']]\nkernel_versions_trc = kernel_versions_trc.rename(columns = {'Id' : 'VersionId'})\n\nkernel_lang_ren = kernel_lang.rename(columns = {'Id' : 'ScriptLanguageId'})\n\nkernels_trc_lang = kernels_trc.merge(kernel_versions_trc, on = ['VersionId', 'ScriptId'])\nkernels_trc_lang = kernels_trc_lang.merge(kernel_lang_ren, on = 'ScriptLanguageId')","3344214b":"#get average number of votes per language name\nvotes_by_lang = kernels_trc_lang.groupby('Name').mean().reset_index()[['Name', 'TotalVotes']]\nvotes_by_lang = votes_by_lang.sort_values(by = 'Name', ascending = True)\nvotes_by_lang = votes_by_lang.rename(columns = {'TotalVotes' : 'Average Votes'})","5c65216e":"#plot bar chart with matplotlib\n\nplt.figure(figsize=(13,7))\nplt.bar(votes_by_lang['Name'], votes_by_lang['Average Votes'])\nplt.xticks(votes_by_lang['Name'])\nplt.xticks(rotation=60)\n\nplt.xlabel('Language Name')\nplt.ylabel('Average Number of Votes')\n\nplt.title('Average number of votes per kernel language')\n\nplt.show()","5c379c16":"#prepare data\n\nkernels_trc_tag = kernels[['Id' , 'TotalVotes']]\nkernels_trc_tag = kernels_trc_tag.rename(columns = {'Id' : 'KernelId'})\n\ntags_trc = tags[['Id', 'Name', 'DatasetCount', 'CompetitionCount', 'KernelCount']]\ntags_trc = tags_trc.rename(columns = {'Id' : 'TagId'})\n\nkernels_trc_tag = kernels_trc_tag.merge(kernel_tags[['KernelId', 'TagId']], on='KernelId')\nkernels_trc_tag = kernels_trc_tag.merge(tags_trc, on = 'TagId')","c59ad142":"#get average number of votes per number of tage usages in datasets\nvotes_by_tag_dataset = kernels_trc_tag.groupby('DatasetCount').mean().reset_index()[['DatasetCount', 'TotalVotes']]\nvotes_by_tag_dataset = votes_by_tag_dataset.sort_values(by = 'DatasetCount', ascending = True)","2206baef":"#plot with matplotlib\n\nplt.scatter(votes_by_tag_dataset['DatasetCount'], votes_by_tag_dataset['TotalVotes'])\nplt.title(\"Number of votes per number of tag usages in datasets\")\nplt.xlabel(\"Tag usage for datasets\")\nplt.ylabel(\"Votes\")\n\nplt.show()","3346bfbd":"#get average number of votes per number of tage usages in competitions\nvotes_by_tag_competition = kernels_trc_tag.groupby('CompetitionCount').mean().reset_index()[['CompetitionCount', 'TotalVotes']]\nvotes_by_tag_competition = votes_by_tag_competition.sort_values(by = 'CompetitionCount', ascending = True)","1ebad360":"#plot with matplotlib\n\nplt.scatter(votes_by_tag_competition['CompetitionCount'], votes_by_tag_competition['TotalVotes'])\nplt.title(\"Number of votes per number of tag usages in competitions\")\nplt.xlabel(\"Tag usage for competitions\")\nplt.ylabel(\"Votes\")\n\nplt.show()","1689d50b":"#get average number of votes per number of tage usages in kernels\nvotes_by_tag_kernel = kernels_trc_tag.groupby('KernelCount').mean().reset_index()[['KernelCount', 'TotalVotes']]\nvotes_by_tag_kernel = votes_by_tag_kernel.sort_values(by = 'KernelCount', ascending = True)","98e868c7":"#plot with matplotlib\n\nplt.scatter(votes_by_tag_kernel['KernelCount'], votes_by_tag_kernel['TotalVotes'])\nplt.title(\"Number of votes per number of tag usages in kernels\")\nplt.xlabel(\"Tag usage for kernels\")\nplt.ylabel(\"Votes\")\n\nplt.show()","43d2027f":"#find out total usage of the tag and store in TotalCount column\ntags_total = tags_trc.copy()\n\ntags_total['TotalCount'] = tags_total['DatasetCount'] + tags_total['CompetitionCount'] + tags_total['KernelCount']\n\n#find out top-20 most popular tags\ntags_total = tags_total.sort_values('TotalCount', ascending = False)\ntags_total = tags_total[:20]\n\n#find average number of votes for each tag\nvotes_by_tag = kernels_trc_tag.groupby('Name').mean().reset_index()[['Name', 'TotalVotes']]\n\n#filter votes by tag for only top-20 most popular tags\nvotes_by_tag_popular = votes_by_tag[votes_by_tag['Name'].isin(tags_total['Name'].values.tolist())]","7cd8763a":"#plot bar chart with matplotlib\n\nplt.figure(figsize=(20,7))\nplt.barh(votes_by_tag_popular['Name'], votes_by_tag_popular['TotalVotes'])\nplt.yticks(votes_by_tag_popular['Name'])\n\nplt.ylabel('Tag Name')\nplt.xlabel('Average Number of Votes')\n\nplt.title('Average number of votes per tag')\n\nplt.show()","3d893907":"#sort votes_by_tag by average number of votes and take top-20\n\nvotes_by_tag_aver = votes_by_tag.sort_values('TotalVotes', ascending = False)[:20]","8bfd4e89":"#plot bar chart with matplotlib\n\nplt.figure(figsize=(20,7))\nplt.barh(votes_by_tag_aver['Name'], votes_by_tag_aver['TotalVotes'])\nplt.yticks(votes_by_tag_aver['Name'])\n\nplt.ylabel('Tag Name')\nplt.xlabel('Average Number of Votes')\n\nplt.title('Average number of votes per tag')\n\nplt.show()","20862e41":"# create msg_ref dataframe by removing rows with empty messages from the original dataset\nmsg_ref = messages[['Id', 'Message']].dropna(subset = ['Message'])\n\n# filter rows: find rows with messages which contain references to kaggle\nmsg_ref = msg_ref[msg_ref.Message.str.match('.*https:\/\/www.kaggle.com\/(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+.*')]","161cb6cb":"def get_referenced_object(row):\n    '''\n    Function returns the last part of the url.\n    Example:\n        input: 'https:\/\/www.kaggle.com\/aleksandradeis\/how-to-get-upvotes-for-a-kernel-on-kaggle'\n        returns: 'how-to-get-upvotes-for-a-kernel-on-kaggle'\n    '''\n    # extract url from message\n    url = re.findall('https:\/\/www.kaggle.com\/(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'\\\n                         , row['Message'])[0]\n    \n    # remove tags\n    cleanr = re.compile('<.*?>')\n    clean_url= re.sub(cleanr, '', url)\n    \n    # get the last part of url, which corresponds to kernel title\n    ref = clean_url.split('\/')[-1]\n    \n    return ref\n\ndef get_author(row):\n    '''\n    Function returns the last part of the url.\n    Example:\n        input: 'https:\/\/www.kaggle.com\/aleksandradeis\/how-to-get-upvotes-for-a-kernel-on-kaggle'\n        returns: 'aleksandradeis'\n    '''\n    # extract url from message\n    url = re.findall('https:\/\/www.kaggle.com\/(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'\\\n                         , row['Message'])[0]\n    \n    # remove tags\n    cleanr = re.compile('<.*?>')\n    clean_url= re.sub(cleanr, '', url)\n    \n    # get the last part of url, which corresponds to kernel title\n    author = clean_url.split('\/')[-2]\n    \n    return author\n\n# create column 'Ref' with the last part of the url\n# which is the title of the kernel (in case of url to a kernel)\nmsg_ref['Ref'] = msg_ref.apply(lambda row: get_referenced_object(row),axis=1)\nmsg_ref['Ref_author'] = msg_ref.apply(lambda row: get_author(row),axis=1)","3d4a2440":"msg_ref.head()","1f1ca0e3":"# merge kernel votes and kernel titles (for current kernel version)\nkernel_title = kernels[['Id', 'AuthorUserId', 'CurrentKernelVersionId', 'TotalVotes']]\\\n.merge(kernel_versions[['Id', 'Title']].rename(columns={\"Id\": \"CurrentKernelVersionId\"}))","8c7e281d":"# merge kernel votes and kernel authors\nkernel_title = kernel_title.merge(kernel_users[['Id', 'UserName']].rename(columns={\"Id\":\"AuthorUserId\"}))","9dcb4d32":"def process_kernel_title(row):\n    '''\n    Function removes symbols from title, translates to lower case,\n    and replaces spaces with '-'\n    Example:\n        input: 'How to get upvotes for a kernel on Kaggle?'\n        returns: 'how-to-get-upvotes-for-a-kernel-on-kaggle'\n    '''\n    try:\n        title = row['Title']\n\n        # remove specific symbols and translate to lower case\n        title_cleaned = re.sub('[!@#$%?*,.;:()]', '', title).lower()\n\n        # replace spaces with '-'\n        title_cleaned = title_cleaned.replace(' ', '-')\n    except:\n        return ' '\n    return title_cleaned\n\n# create column title_cleaned with preprocessed title as in url\nkernel_title['title_cleaned'] = kernel_title.apply(lambda row: process_kernel_title(row),axis=1)","066abb12":"kernel_title.head()","b91a330c":"# merge kernels and messages (outer)\npromotions = pd.merge(msg_ref, kernel_title, how='outer', left_on='Ref', right_on='title_cleaned',\n         suffixes=('_messages', '_kernels'), copy=True)\n\n# remove rows with NaN\npromotions = promotions.dropna()\n\n# remove rows with title_cleaned in ['', 'competitions', 'rules']\npromotions = promotions[~promotions['title_cleaned'].isin(['', 'competitions', 'rules'])]\n\n# remove rows where authors don't match\n\npromotions = promotions[promotions['Ref_author'] == promotions['UserName']]\npromotions.head()","29afd4d9":"n_promotions = promotions[['Id_kernels', 'CurrentKernelVersionId', 'TotalVotes']]\\\n.groupby('Id_kernels').count().reset_index()[[\"Id_kernels\", \"CurrentKernelVersionId\"]]\\\n.rename(columns = {'CurrentKernelVersionId' : 'Promotions'})","5052d597":"n_kernel_promotions = kernels[['Id', 'TotalVotes', 'Medal']].merge(n_promotions.rename(columns = {'Id_kernels' : 'Id'})\\\n                                                          , how = 'outer')\nn_kernel_promotions = n_kernel_promotions.fillna(0)","481b8603":"# fit a linear regression model on mentions and votes data\nmodel = LinearRegression()\nmodel.fit(n_kernel_promotions['Promotions'].values.reshape(-1, 1), n_kernel_promotions['TotalVotes'].values.reshape(-1, 1))\n\ninputs = np.linspace(1, 20, num=50)\npredictions = model.predict(inputs.reshape(-1,1)).reshape(50)","6e4ff11f":"#plot with matplotlib\n\nplt.scatter(n_kernel_promotions['Promotions'], n_kernel_promotions['TotalVotes'])\nplt.plot(inputs, predictions, color='green')\n\nplt.title(\"Number of votes per number of mentions\")\nplt.xlabel(\"Number of mentions in Kaggle forum messages\")\nplt.ylabel(\"Votes\")\n\nplt.show()","3488f1b8":"#columns to find out correlation\ncols = ['TotalVotes', 'Promotions']\n\n#Find out correlation between columns and plot\ncorrs = np.corrcoef(n_kernel_promotions[cols].values.T)\nsns.set(font_scale=1)\nsns.set(rc={'figure.figsize':(7,7)})\nhm=sns.heatmap(corrs, cbar = True, annot=True, square = True, fmt = '.2f',\n              yticklabels = cols, xticklabels = cols).set_title('Correlations heatmap')\n\nfig = hm.get_figure()","d4138146":"#columns to find out correlation\ncols = ['Medal', 'Promotions']\n\n#Find out correlation between columns and plot\ncorrs = np.corrcoef(n_kernel_promotions[cols].values.T)\nsns.set(font_scale=1)\nsns.set(rc={'figure.figsize':(7,7)})\nhm=sns.heatmap(corrs, cbar = True, annot=True, square = True, fmt = '.2f',\n              yticklabels = cols, xticklabels = cols).set_title('Correlations heatmap (medals)')\n\nfig = hm.get_figure()","1861b497":"votes_with_mentions = n_kernel_promotions[n_kernel_promotions['Promotions'] > 0]['TotalVotes'].mean()\nprint('Average number of votes for advertised kernels: {}'.format(votes_with_mentions))\n\nkernels_with_promotions = n_kernel_promotions[n_kernel_promotions['Promotions'] > 0]['Promotions'].count()\nprint('Total number of kernels mentioned in forum messages: {}'.format(kernels_with_promotions))\n\nvotes_no_mentions = n_kernel_promotions[n_kernel_promotions['Promotions'] == 0]['TotalVotes'].mean()\nprint('Average number of votes for non advertised kernels: {}'.format(votes_no_mentions))","cbc2a064":"medals_with_mentions = n_kernel_promotions[n_kernel_promotions['Promotions'] > 0]['Medal'].mean()\nprint('Average medal rank for advertised kernels: {}'.format(medals_with_mentions))\n\nmedals_no_mentions = n_kernel_promotions[n_kernel_promotions['Promotions'] == 0]['Medal'].mean()\nprint('Average medal rank for non advertised kernels: {}'.format(medals_no_mentions))","3a3605e2":"#prepare data\n\ndef has_tag(row, tag):\n    ''' Function returns 1 of tag id found in row['Tags'] column '''\n    \n    for row_tag in row['Tags'].replace(' ','').replace('{','').replace('}','').split(','):\n        if row_tag == tag:\n            return 1\n    return 0\n\ndef is_forked(row):\n    ''' Functions returns 0 if row['ForkParentKernelVersionId'] is nan, 1 - otherwise '''\n    if np.isnan(row['ForkParentKernelVersionId']):\n        return 0\n    else:\n        return 1\n\ndef has_linked_topic(row):\n    ''' Functions returns 0 if row['ForumTopicId'] is nan, 1 - otherwise '''\n    if np.isnan(row['ForumTopicId']):\n        return 0\n    else:\n        return 1\n    \ndef get_days_from_registration(row):\n    '''Function returns number of days since users registration date'''\n    \n    today = dt.datetime.now().date()\n    days = (today - dt.datetime.strptime(row['RegisterDate'], \"%m\/%d\/%Y\").date()).days\n    \n    return days\n\ndef get_days_from_kernel_creation(row):\n    '''Function returns number of days since kernel creation date'''\n    \n    today = dt.datetime.now().date()\n    \n    days = (today - dt.datetime.strptime(row['CreationDate'], \"%m\/%d\/%Y %H:%M:%S\").date()).days\n    \n    return days\n\ndef prepare_data(kernels, kernel_lang, kernel_tags, kernel_versions, kernel_users, kernel_datasets, datasets, dataset_versions, tags, competitions, kernel_competitions):\n    '''\n    Function to prepare meta Kaggle data to be used in regression models\n    \n    INPUTS:\n    1. kernels - Kernels.csv dataset, \n    2. kernel_lang - KernelLanguages.csv dataset,\n    3. kernel_tags - KernelTags.csv dataset,\n    4. kernel_versions - KernelVersions.csv dataset,\n    5. kernel_users - KernelUsers.csv dataset,\n    6. kernel_datasets - KernelVersionDatasetSources.csv dataset,\n    7. datasets - Datasets.csv dataset,\n    8. dataset_versions - DatasetVersions.csv dataset,\n    9. tags - Tags.csv dataset.\n    \n    RETURNS:\n    df - dataset, wchich contains preprocessed data\n    '''\n    #1. merge datasets\n    \n    #remove irrelevant columns from dataset and rename other columns to perform merge\n    df = kernels[['Id', 'CurrentKernelVersionId' , 'ForkParentKernelVersionId', 'ForumTopicId', 'TotalVotes', 'AuthorUserId', 'CreationDate']].rename(columns = \n                                                                                                                      {'Id': 'KernelId', \n                                                                                                           'TotalVotes': 'TotalKernelVotes', \n                                                                                                                      'CurrentKernelVersionId':'KernelVersionId'})\n    \n    # create new column for age of the kernel (number of days since the kernel creation)\n    # and drop old column CreationDate\n    df[['CreationDate']] = df[['CreationDate']].fillna(value=dt.datetime.now().strftime('%m\/%d\/%Y %H:%M:%S'))\n    df['KernelAge'] = df.apply(lambda row: get_days_from_kernel_creation(row),axis=1)\n    df = df.drop('CreationDate', axis = 1)\n    \n    #merge with users to add PerformanceTier of the author and number of days since author's registration on Kaggle\n    kernel_users['DaysSinceRegistration'] = kernel_users.apply(lambda row: get_days_from_registration(row),axis=1)\n    kernel_users_renamed = kernel_users[['Id', 'PerformanceTier', 'DaysSinceRegistration']].rename(columns={'Id': 'AuthorUserId',\n                                                                                  'PerformanceTier' : 'AuthorPerformanceTier'})\n    df = df.merge(kernel_users_renamed, on = 'AuthorUserId').drop('AuthorUserId', axis = 1)\n    \n    \n    \n    \n    \n    ########################\n#     #prepare the data for the analysis\n\n# kernels_trc = kernels[['Id' , 'TotalVotes', 'CurrentKernelVersionId']]\n# kernels_trc = kernels_trc.rename(columns = {'Id': 'ScriptId', 'CurrentKernelVersionId' : 'VersionId'})\n\n# kernel_versions_trc = kernel_versions[['Id', 'ScriptId', 'ScriptLanguageId']]\n# kernel_versions_trc = kernel_versions_trc.rename(columns = {'Id' : 'VersionId'})\n\n# kernel_lang_ren = kernel_lang.rename(columns = {'Id' : 'ScriptLanguageId'})\n\n# kernels_trc_lang = kernels_trc.merge(kernel_versions_trc, on = ['VersionId', 'ScriptId'])\n# kernels_trc_lang = kernels_trc_lang.merge(kernel_lang_ren, on = 'ScriptLanguageId')\n#     #######################\n    \n    \n    \n    \n    \n    \n    #merge with versions to add VersionNumber and KernelLanguageId\n    kernel_versions_renamed = kernel_versions[['Id', 'ScriptId', 'ScriptLanguageId', 'VersionNumber']].rename(columns = {'Id':'KernelVersionId', 'ScriptId':'KernelId'})\n    df = df.merge(kernel_versions_renamed, on = ['KernelVersionId', 'KernelId'])\n    \n    #merge with datasets to add TotalDatasetVotes and TotalDatasetDownloads\n    kernel_datasets_truncated = kernel_datasets[['KernelVersionId', 'SourceDatasetVersionId']]\n\n    dataset_versions_truncated = dataset_versions[['DatasetId', 'DatasourceVersionId']]\n    dataset_versions_truncated = dataset_versions_truncated.rename(columns={'DatasourceVersionId': 'SourceDatasetVersionId'})\n\n    datasets_truncated = datasets[['Id', 'TotalVotes', 'TotalDownloads']]\n    datasets_truncated = datasets_truncated.rename(columns={'Id': 'DatasetId', 'TotalVotes':'TotalDatasetVotes',\n                                                      'TotalDownloads':'TotalDatasetDownloads'})\n\n    df = df.merge(kernel_datasets_truncated, on = 'KernelVersionId')\n    df = df.merge(dataset_versions_truncated, on = 'SourceDatasetVersionId')\n    df = df.merge(datasets_truncated, on = 'DatasetId').drop(['SourceDatasetVersionId', 'DatasetId'], axis = 1)\n    \n    # merge with type of competition\n    # if kernel is not linked to a competition - NaN\n    competitions_type = competitions[['Id', 'HostSegmentTitle']].rename(columns={'Id': 'SourceCompetitionId'})\n    kernel_competition_type = kernel_competitions.merge(competitions_type, on='SourceCompetitionId')[['KernelVersionId', 'HostSegmentTitle']] # merge kernel versions with competitions\n    df = df.merge(kernel_competition_type, on = 'KernelVersionId', how='outer')\n    df = df.drop('KernelVersionId', axis = 1)\n    \n    #create dummy variables for competition types and drop HostSegmentTitle\n    df = pd.get_dummies(df, columns = ['HostSegmentTitle'], prefix = 'comp', dummy_na = True)\n       \n    #merge with tags\n    tags_trc = tags[['Id', 'Name']]\n    tags_trc = tags_trc.rename(columns = {'Id' : 'TagId', 'Name' : 'TagName'})\n    df = df.merge(kernel_tags, on = 'KernelId').drop(['Id'], axis = 1)\n    df = df.merge(tags_trc, on = 'TagId')\n    \n    #find most popular tags\n    top20_tags = tags[['Id', 'Name', 'DatasetCount', 'CompetitionCount', 'KernelCount']].rename(columns={'Id':'TagId'})\n    top20_tags['TotalCount'] = top20_tags['DatasetCount'] + top20_tags['CompetitionCount'] + top20_tags['KernelCount']\n    top20_tags = top20_tags.sort_values('TotalCount', ascending = False)\n    top20_tags = top20_tags[:20].drop(['DatasetCount', 'CompetitionCount' , 'KernelCount'], axis = 1)\n    \n    #filter-out rows only for most popular tags\n    df = df[df['TagId'].isin(top20_tags['TagId'].values.tolist())]\n    df = df.drop('TagId', axis = 1)\n    \n    #introduce column 'Tags' with set of most popular tags used for kernel\n    df_1 = df.groupby('KernelId')['TagName'].apply(lambda x: \"{%s}\" % ', '.join(x)).reset_index().rename(columns = {'TagName':'Tags'})\n    df = df.drop('TagName', axis = 1)\n    df = df_1.merge(df, on='KernelId')\n    \n    #create dummy columns for top-20 tags\n    for top20_tag in top20_tags['Name'].values.tolist():\n        df['tag_' + str(top20_tag)] = df.apply(lambda row: has_tag(row, top20_tag),axis=1)\n        \n    df = df.drop('Tags', axis = 1)\n    \n    #2. process column values\n    \n    #introduce column IsForked for kernels forked from other and drop original column\n    df['IsForked'] = df.apply(lambda row: is_forked(row),axis=1)\n    df = df.drop('ForkParentKernelVersionId', axis = 1)\n    \n    #introduce colum HasForumTopic for kernels linked to forum topic id and drop original column\n    df['HasForumTopic'] = df.apply(lambda row: has_linked_topic(row),axis=1)\n    df = df.drop(['ForumTopicId', 'KernelId'], axis = 1)\n    \n     \n    return df\n\ndf = prepare_data(kernels, kernel_lang, kernel_tags, kernel_versions, kernel_users, kernel_datasets, datasets, dataset_versions, tags, competitions, kernel_competitions)\n\ndf.head(5)","0bfd7a07":"#split into train and test\nTEST_SIZE = 0.3\nRAND_STATE = 42\n\nX = df.drop(columns = 'TotalKernelVotes')\ny = df[['TotalKernelVotes']]\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = TEST_SIZE, random_state=RAND_STATE)","630f95c1":"#train XGBoost model\nxgb = xgboost.XGBRegressor(n_estimators=100, learning_rate=0.08, gamma=0, subsample=0.75,\n                           colsample_bytree=1, max_depth=7)\nxgb.fit(X_train,y_train)\n\n#calculate and print scores for the model for top 15 features\ny_train_preds = xgb.predict(X_train)\ny_test_preds = xgb.predict(X_test)\n\nprint('MSE train: %.3f, test: %.3f' % (\n        mean_squared_error(y_train, y_train_preds),\n        mean_squared_error(y_test, y_test_preds)))\nprint('R^2 train: %.3f, test: %.3f' % (\n        r2_score(y_train, y_train_preds),\n        r2_score(y_test, y_test_preds)))","1a43104a":"#plot bar chart with matplotlib\nplt.figure(figsize=(7,10))\n\ny_pos = np.arange(len(X.columns))\n\nplt.barh(y_pos, xgb.feature_importances_, align='center', alpha=0.5)\nplt.yticks(y_pos, X.columns)\n\nplt.ylabel('Features')\nplt.xlabel('Feature Importance')\n\nplt.title('Feature importances')\n\nplt.show()","f6751035":"data = np.array([30, 2, 365, 8, 1, 30, 2070, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\ncolumns = X_train.columns.values\n\nbm_kernel = pd.DataFrame(data = [data], columns = columns)","e7dc99f6":"predict_votes = xgb.predict(bm_kernel)\npredict_votes","7ccfcbe0":"### 1. Explore basic statistics for number of kernels","71e53b25":"### 8. Does \"advertising\" of your kernel on Kaggle forums help to gain votes?","89018b75":"## Import datasets related to kernels","740bd58f":"We can see that tags with the greatest average number of votes don't really match with the most popular tags, so I guess my assumption that using popular tags in kernels will help to gain more votes is wrong.","969d8b6a":"I have recently joined Kaggle and started to create public kernels. My kernels have a lot of views, but no upvotes. So I decided to analyze Meta Kaggle dataset to find out:\n* Statistics for kernels, which have votes.\n* How different factors affect the number of votes (for example, characteristics of the author, source dataset etc.)?\n* And finally, make the recommendations on how to make the kernel useful, so other kagglers would cast upvotes.","354d6d59":"At first let's look at correlations between TotalKernelVotes, TotalDatasetVotes and\tTotalDatasetDownloads.","8a0eb261":"The process of obtaining the number of mentions in forum messages is illustrated on figure below:\n1. Analyze the ForumMessages table:\n    * Find all messages which contain urls.\n    * Extract kernel name and name of the author from the url address.\n2. Merge Kernels, KernelVersions and Users tables:\n    * Find name of the author for the kernel.\n    * Find the title of the kernel.\n    * Translate the title as in url address.\n3. Merge kernel titles and titles from url addresses where the names of the authors match. Count the number of rows for each kernel. ","e3f3f61c":"`4.` Group by kernel id to find number of metions in forum messages:","b22df06f":"So we can really see that __more proficient users gain more votes for kernels__.","cfbb8973":"### 4. How does dataset related to kernel affects the number of votes?","b7e5dbf9":"We can explain some of the results:\n* __Kernel version number__: this feature may be related to the kernel quality, the kernel with lot's of versions may be updated and improved,\n* __Forum topic__: the importance of this feature indicates that a forum topic helps to promote the kernel,\n* __Related competition__: we can see that the fact that there is a competition related to a kernel plays a vital role in the number of votes. Probably related competition helps to promote the kernel among the users.\n* __Author performance tier__: this feature is essential because more experienced authors create better kernels and have more followers.","452a7c01":"As we can see there is no correlation between number of kernel votes and number of votes or downloads for a dataset.\n<br> Let's also make scatter plots:","229bfa53":"The model used to predict around 6 votes for this dataframe. Let's see what actually happens.","a4b35ef3":"In conclusion, I would like to summarize all the findings and recommendations from this analysis:\n\n1. __It is hard to create a really helpful kernel, which will be appreciated and upvoted by Kagglers__: only 38% of kernels have upvotes and only 9% of kernels have awards (have more than 5 upvotes).\n2. __Views and comments bring upvotes__: consider adding a captivating title to the kernel and sharing the link to the kernel with others, the more people will view the kernel - the more people will find it useful.\n3. __Active authors have more votes__: try to be an active author and gain visibility, experience in writing kernels and feedback from the others will eventually help to get votes.\n4. __It doesn't really matter what topic the kernel is related to, but it matters how the kernel material is presented__: notebooks tend to be more appreciated by Kagglers.","85465187":"`6.` Analyze correlation between the number of votes and number of mentions in forum messages:","699ffef5":"### 3. How does the status of the author affect number of votes per kernel?","a2d6db3a":"2. Tag usage for competitions:","eaacb047":"`2.` Merge kernel votes with kernel titles and preprocess kernel title as in url:","819cd657":"The last thing left to do is to try to create regression model, which predicts the number of votes for a kernel.","abf60786":"I suppose that more active users and the users with higher visibility gain votes for kernels:\n* So how does performance tier of the user affect the number of upvotes?","f0ff68a8":"### 2. How does number of views and number of comments affect number of votes?","82db027e":"Let's check the correlation coefficient:","ccde8dbc":"3. Tag usage for kernels:","43c3bf2e":"`1.` Find all forum messages with urls to Kaggle and extract possible kernel titles from urls:","7c7c8b7f":"Plot statistics for number of kernels:","90db067d":"Finally, some numbers considering the number of mentions of the kernels on Kaggle forum:","e2efac7b":"I have an assumption that Kaggle users may be attracted by most popular tags, so using them will help to gain more votes. That is why I will try to plot average number of votes against number of datasets\/competitions\/kernels, where kernel tag is used.\n\n1. Tag usage for datasets:","86e42962":"Now we will look at the kernels' tags:\n* Are there any kernel tags, which are more specific to more popular kernels?","8ebe97ff":"![engineering steps](https:\/\/github.com\/Lexie88rus\/kaggle_kernel_votes_analysis\/blob\/master\/kernel_promotions.png?raw=true)","64229cdd":"Here we can't see a clear dependency of kernel votes on dataset's number of votes. So I suppose that we can create a really helpful and popular kernel for an unpopular dataset and vice versa.","ee9d6a53":"<b> Conclusions: <\/b>\n\n* There is no strong correlation between the number of mentions in Kaggle messages and the number of votes.\n* The average number of votes for advertised kernels is higher than the number of votes for non-advertised kernels.\n* The average medal rank for advertised kernels is higher than the average medal rank for non-advertised kernels.\n\n\n<br>My experience tells me that promoting your kernel on Kaggle forum helps to gain votes, but the analysis doesn't show that. Probably, this happens because the number of kernels mentioned in forum messages (and identified by me) is tiny, so we don't have enough data for the analysis. <\/br>","a3a66005":"### 6. How does kernel language affect the number of votes?","b87f7410":"Both plots for the views and the comments show us that there is linear dependency between number of votes and number of views\/comments.","e0c28f2a":"We can really see that number of votes varies greatly even for the most popular tags.\n<br> It is also interesting to find out tags, which have the greatest average number of votes:","5faec84d":"First of all let's plot the number of votes against the number of promotions in forum messages:","5076b430":"## Introduction","5a72f1e6":"### 7. How do kernel tags affect the number of votes?","92338bce":"Find out correlation between number of views, number of comments and number of votes:","7a95c803":"It seems that notebooks are more appreciated with Kaggle users. ","8842eaee":"Let's see the feature importances:","9f80b082":"`3.` Merge kernels and mentions in urls:","b5ece178":"So now we can try to predict, how many votes will score __[one of my recent kernels](https:\/\/www.kaggle.com\/aleksandradeis\/bank-marketing-analysis)__:","8c073a1f":"* How many kernels are there? \n* How many of them are public? \n* How many kernels have upvotes? \n* How many kernels have any medal?","f68a2119":"What kernel types gain more votes?","d2b14f94":"## Machine learning to predict number of votes for kernel","43b9eb80":"We can see that votes, comments and views are __highly correlated__. So my first assumption would be that __we should get as many views of the kernels as possible to gain votes__.\n<br> Let's try to visualize dependency between views and votes:","21357bfb":"`5.` Merge number of promotions with total votes:","652eb0da":"## Conclusion","cc5ad8f8":"Comparison of medal rank for kernels with mentions on Kaggle forums and kenels without mentions:","4bbfe43f":"## Explore statistics for kernel votes","282724dc":"The picture looks similar to the previous one. There is also no clear dependency.","60ace6df":"* Is there a correlation between number of views and number of comments with number of votes?\n* Plot dependencies between number of views, comments and number of votes.","7e11d251":"Looks like the popularity of the tag doesn't really affect the number of votes.\n<br> I would also like to look at average number of votes for the most popular tags:","c1527207":"Mentioning a kernel in forum messages can potentially help to promote the kernel among kagglers and eventually get more votes. Let's analyze the correlation between the number of mentions of a kernel with its number of votes.","882b16d0":"I suppose that there might be some 'hot' datasets on Kaggle and kernels related to those datasets might optain more votes. So we should find out:\n* How does the number of votes for a dataset affect the number of votes for related kernel?\n* How does the number of downloads of a dataset affect the number of votes for related kernel?","a59b47f1":"Find out the correlation between the medal rank and the number of mentions of the kernel:","cd37fc4f":"Visualization of dependency between comments and votes:"}}