{"cell_type":{"6132e04c":"code","7b1db1f7":"code","84204e4f":"code","6dc3eb60":"code","412ba423":"code","1f273e03":"code","83b79597":"code","4145e0a4":"code","ab545247":"code","2e39e3a3":"code","de78ddf4":"code","5393e3a3":"code","00011ff6":"code","178127ef":"code","43736da9":"code","32be7b12":"code","0d8720aa":"code","2500eeca":"code","d048e09e":"code","bff16f45":"code","4e925844":"code","9645f9dc":"code","7d9db948":"code","e92672f3":"code","08c304c8":"code","de308194":"code","16b2ff08":"code","51dbb6b8":"code","459cae0e":"code","ae27ab90":"code","97166de8":"code","f156947d":"code","ff9ee530":"markdown","2f40cf09":"markdown","f348790c":"markdown","69c64bd8":"markdown","1cba0fd6":"markdown","b6560d12":"markdown","b3b4b2c8":"markdown","5172abce":"markdown","6ad8578a":"markdown","8985b871":"markdown","418f38b7":"markdown","7e403222":"markdown","6a1e8bb4":"markdown","d3acab5e":"markdown","d4fc52a8":"markdown","bc3dd4ba":"markdown","d618d5a5":"markdown","37e929f9":"markdown","b773a18c":"markdown","8bfce87c":"markdown","b522213f":"markdown","8290c45d":"markdown","747116fb":"markdown","d98626f5":"markdown","63618ed5":"markdown","a5b2bdb8":"markdown","99893741":"markdown"},"source":{"6132e04c":"# import all of the important libraries in this kernel\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport time\nimport datetime\nfrom plotly.offline import init_notebook_mode, iplot\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\nimport seaborn as sns\nimport lightgbm as lgb\ncmap = sns.color_palette()","7b1db1f7":"# import the data to use in this kernel\ndf = pd.read_csv('..\/input\/g-research-crypto-forecasting\/train.csv')\nasset_details = pd.read_csv('..\/input\/g-research-crypto-forecasting\/asset_details.csv')\ndf_test = pd.read_csv('..\/input\/g-research-crypto-forecasting\/example_test.csv')","84204e4f":"# casually checking the data\ndf.head(13)","6dc3eb60":"asset_details","412ba423":"df.isnull().sum()","1f273e03":"#sort the asset_id data by using Weight as reference.\nasset_details = asset_details.sort_values('Weight',ascending=False)\nasset_details","83b79597":"asset_names_dict = {row[\"Asset_Name\"]:row[\"Asset_ID\"] for ind, row in asset_details.iterrows()}\nasset_names_dict","4145e0a4":"def add_asset_name(stdata, join):\n    return stdata.merge(\n        join, how=\"left\",on=\"Asset_ID\"\n    )\n\ndf = add_asset_name(df,asset_details)","ab545247":"df['Real_Time'] = pd.to_datetime(df['timestamp'],unit='s')","2e39e3a3":"df.head(10)","de78ddf4":"(df['Asset_Name'].value_counts()\/df.shape[0])*100","5393e3a3":"countpie = df['Asset_Name'].value_counts()\n\nfig = {\n  \"data\": [\n    {\n      \"values\": countpie.values,\n      \"labels\": countpie.index,\n      \"domain\": {\"x\": [0, .5]},\n      \"name\": \"Currency types\",\n      \"hoverinfo\":\"label+percent+name\",\n      \"hole\": .7,\n      \"type\": \"pie\"\n    },],\n  \"layout\": {\n        \"title\":\"Pie chart of all the Currency types ratio\",\n    }\n}\niplot(fig)","00011ff6":"# This is what I normally write my plotly code but because the number of data is very big so it take too much time.\n# It might easier to write but it takes too much time to run the graph.\n\n#px.histogram(df, x=\"Asset_Name\", color=\"Asset_Name\")","178127ef":"# This is the better way to run a histogram plot by \"Sanskar Hasija\"\nasset_count= []\nfor i in range(14):\n    count = (df[\"Asset_ID\"]==i).sum()\n    asset_count.append(count)","43736da9":"# The output is basically the same as the code above but it run much more faster\nfig = px.histogram(x = asset_details.sort_values(\"Asset_ID\")[\"Asset_Name\"],\n                   y = asset_count , \n             color = asset_details.sort_values(\"Asset_ID\")[\"Asset_Name\"])\nfig.update_xaxes(title=\"Currency types\")\nfig.update_yaxes(title = \"Number of Rows\")\nfig.show()","32be7b12":"volumesum = df.groupby(['Asset_ID'])['Volume'].sum()\nvolumesum","0d8720aa":"fig = px.histogram(x = asset_details.sort_values(\"Asset_ID\")[\"Asset_Name\"],\n                   y = volumesum, \n                   color = asset_details.sort_values(\"Asset_ID\")[\"Asset_Name\"])\nfig.update_xaxes(title=\"Currency types\")\nfig.update_yaxes(title = \"Sum of the volumes\")\nfig.update_layout(showlegend = True,\n    title = {\n        'text': 'Quantity of asset bought or sold based on USD',\n        'y':0.95,\n        'x':0.45,\n        'xanchor': 'center',\n        'yanchor': 'top'})\nfig.show()","2500eeca":"assetindex = asset_details.sort_values(\"Asset_ID\")[\"Asset_Name\"].values","d048e09e":"assetindex","bff16f45":"plt.figure(figsize=(40,80))\ngs = gridspec.GridSpec(7, 2)\nfor i in range(14):\n    ax = plt.subplot(gs[i])\n    ax = sns.scatterplot(x='Close',y='Open',data=df[df['Asset_ID'] == i],color=cmap[i%10])\n    ax.set_xlabel('')\n    ax.set_title('Scatter plot of currency name: ' + assetindex[i] +' in USD')\nplt.show()\n\n\n","4e925844":"f = plt.figure(figsize=(15,30))\n\nfor ind, coin in enumerate(list(assetindex)):\n    coin_df = df[df[\"Asset_ID\"]==asset_names_dict[coin]].set_index(\"Real_Time\")\n    # fill missing values \n    ax = f.add_subplot(7,2,ind+1)\n    plt.plot(coin_df['Close'], label=coin, color=cmap[ind%10])\n    plt.legend()\n    plt.xlabel('Time')\n    plt.ylabel(coin)\n    plt.title(coin)\n\nplt.tight_layout()\nplt.show()","9645f9dc":"all_assets_df = pd.DataFrame([])\nfor ind, coin in enumerate(list(assetindex)):\n    coin_df = df[df[\"Asset_ID\"]==asset_names_dict[coin]].set_index(\"Real_Time\")\n    # fill missing values\n    close_values = coin_df[\"Close\"].fillna(0)\n    close_values.name = coin\n    all_assets_df = all_assets_df.join(close_values, how=\"outer\")\n\n\ncorrmat = all_assets_df.corr()\nfig, ax = plt.subplots(figsize=(14, 14))\nsns.heatmap(corrmat, vmax=1., square=True, cmap=\"rocket_r\")\nplt.title(\"Cryptocurrency correlation map on actual price values\", fontsize=15)\nplt.show()\n","7d9db948":"btctemp = df[df['Asset_Name']=='Bitcoin'].set_index(\"Real_Time\")\nbtctemp = btctemp.iloc[-2000:,] # I want only the lastest 2000 rows from the bottme\nbtctemp","e92672f3":"fig = go.Figure(data=[go.Candlestick(x=btctemp.index, open=btctemp['Open'], high=btctemp['High'], low=btctemp['Low'], close=btctemp['Close'])])\nfig.update_xaxes(title_text = 'Time',\n                             rangeslider_visible = True)\n\nfig.update_layout(\n     title = {\n        'text': ' Candelstick Chart: Bitcoin',\n        'y':0.90,\n        'x':0.5,\n        'xanchor': 'center',\n        'yanchor': 'top'})\n\nfig.update_yaxes(title_text = 'Price in USD', ticksuffix = '$')\n\n\n\n\nfig.show()","08c304c8":"def crypto_df(AssetName,fdata=df):\n    currencydf = fdata[fdata['Asset_Name']== AssetName].set_index(\"Real_Time\")\n    currencydf = currencydf.iloc[-2000:,] # I want only the lastest 2000 rows from the bottme\n    return(currencydf)","de308194":"ethtemp = crypto_df('Ethereum')","16b2ff08":"def latestcandle(coindata,coinname):  \n        fig = go.Figure(data=[go.Candlestick(x=coindata.index, open=coindata['Open'], high=coindata['High'], low=coindata['Low'], close=coindata['Close'])])\n        fig.update_xaxes(title_text = 'Time',\n                                rangeslider_visible = True)\n\n        fig.update_layout(\n        title = {\n                'text': ' Candelstick Chart: {:}'.format(coinname),\n                'y':0.90,\n                'x':0.5,\n                'xanchor': 'center',\n                'yanchor': 'top'})\n\n        fig.update_yaxes(title_text = 'Price in USD', ticksuffix = '$')\n\n        fig.show()","51dbb6b8":"latestcandle(ethtemp,'Ethereum')","459cae0e":"def latestcandle(coinname,fdata=df):  \n        \n        currencydf = fdata[fdata['Asset_Name']== coinname].set_index(\"Real_Time\")\n        currencydf = currencydf.iloc[-2000:,] # I want only the lastest 2000 rows from the bottme\n        \n        fig = go.Figure(data=[go.Candlestick(x=currencydf.index, open=currencydf['Open'], high=currencydf['High'], low=currencydf['Low'], close=currencydf['Close'])])\n        fig.update_xaxes(title_text = 'Time',\n                                rangeslider_visible = True)\n\n        fig.update_layout(\n        title = {\n                'text': ' Candelstick Chart: {:}'.format(coinname),\n                'y':0.90,\n                'x':0.5,\n                'xanchor': 'center',\n                'yanchor': 'top'})\n\n        fig.update_yaxes(title_text = 'Price in USD', ticksuffix = '$')\n\n        fig.show()","ae27ab90":"latestcandle('Ethereum Classic') #just fill in the name of a coin so you could get the plot of those","97166de8":"latestcandle('Litecoin')","f156947d":"latestcandle('Dogecoin')","ff9ee530":"I want to know the correlation between each coin.","2f40cf09":"Just for checking that the dataset that we want is exactly we're looking for.","f348790c":"**Key Takeaways**\n\n- In the trading world, they tend to use Candlestick charts to determine possible price movement based on last patterns. \n- Candlesticks are useful when trading as they show four price poinits (open, close, high and low) throughout the period of thime the trader specifies. \n- Trading is often dictated by emotion, which can be read in candlestick charts.\n\nCheck out for more information and reference: https:\/\/www.investopedia.com\/trading\/candlestick-charting-what-is-it\/","69c64bd8":"# G-Research Crypto Forecasting - Cleaning, EDA and Prediction","1cba0fd6":"### Correlation between the currency","b6560d12":"Data features\nWe can see the different features included in the dataset. Specifically, the features included per asset are the following:\n\n- timestamp: All timestamps are returned as second Unix timestamps (the number of seconds elapsed since 1970-01-01 00:00:00.000 UTC). Timestamps in this dataset are multiple of 60, indicating minute-by-minute data.\n- Asset_ID: The asset ID corresponding to one of the crytocurrencies (e.g. Asset_ID = 1 for Bitcoin). The mapping from Asset_ID to crypto asset is contained in asset_details.csv.\n- Count: Total number of trades in the time interval (last minute).\n- Open: Opening price of the time interval (in USD).\n- High: Highest price reached during time interval (in USD).\n- Low: Lowest price reached during time interval (in USD).\n- Close: Closing price of the time interval (in USD).\n- Volume: Quantity of asset bought or sold, displayed in base currency USD.\n- VWAP: The average price of the asset over the time interval, weighted by volume. VWAP is an aggregated form of trade data.\n- Target: Residual log-returns for the asset over a 15 minute horizon.","b3b4b2c8":"### Correlation Map","5172abce":"### Volume","6ad8578a":"## Column Description","8985b871":"Checking all of the currency percentage in the dataset.","418f38b7":"Create the Real_Time column by changing from \"Timestamp\" column","7e403222":"### Easiest function for use!\n\nWe have already created the function that use to build the latest 2000 rows dataset of a coin and plot the candle bar seperately so why I shouldn't build it together for further analyze.\n\nRemember if you plot or write the same line of code a lot, try to create a new function.","6a1e8bb4":"Create the function to plot the latest 2000 rows of data","d3acab5e":"## Virtualization","d4fc52a8":"Most of all the data have no outliers or less than 1% that might slightly out of place.","bc3dd4ba":"It's a bit strange that most people buy and sale for Tron, Dogecoin, Stellar and Cardano. Not put the investment in Bitcoin or Ethereum. I might not understanding the **Volume** variables correctly","d618d5a5":"### Percentage of every type of coins in the dataframe","37e929f9":"The missing value have in the VWAP and Target columns","b773a18c":"# Summary\n\nThis is all of the exploratory data analysis part. I will show you the other part of LGBM Machine Learning later. Which is very interesting because I haven't used this library before.\n\nIf you enjoy this kernel please upvote for me and feel free to comment so I could know my mistakes and other to improve myself. Thanks!","8bfce87c":"# Basic data handling and inspection","b522213f":"Adding the \"Asset_Name\" columns from asset_details to df","8290c45d":"### Candlestick Charts","747116fb":"Checking the price at low and high from the start to an end of the dataset that has some manipulation or outliers or not","d98626f5":"## Checking the missing value","63618ed5":"I want to analyze more in other coin types so I should create function to make it easier to use not have to change the code again and again everytime.","a5b2bdb8":"# Exploratory Data Analysis","99893741":"## Reference\nThis kernel can't happen if I haven't studied from (Reference List): <br>\n**https:\/\/www.kaggle.com\/odins0n\/g-research-plots-eda** <br>\n**https:\/\/www.kaggle.com\/cstein06\/tutorial-to-the-g-research-crypto-competition** <br>\n**https:\/\/www.kaggle.com\/sudalairajkumar\/simple-exploration-notebook-crypto-forecasting\/notebook**\n\n\nThanks so much for my new virtualization with plotly, the knowledge in time-series analysis and in crypto market."}}