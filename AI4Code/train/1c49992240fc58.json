{"cell_type":{"abf433fe":"code","ff269231":"code","4fbba587":"code","c9a580ad":"code","6b9d946f":"code","bda9bd76":"code","faff9afa":"code","6ebce868":"code","e1365527":"code","b9ebb8fa":"code","9b19949a":"code","f563c17c":"code","2d7f312f":"code","a910e37e":"code","50fdc3f6":"code","f98d7897":"code","baffb133":"code","c9651b02":"code","e380c213":"code","aedf2ce3":"code","2b60a996":"code","73fe5d0e":"code","3b8fa34c":"code","a37ebdc8":"code","6e77ec9d":"code","d83323ef":"code","0815b4fc":"code","2372f0ac":"code","5f0158e8":"code","dba49f8c":"code","34d68201":"markdown","bea32643":"markdown","3cd34988":"markdown","8f28f23a":"markdown","c6200dd2":"markdown","0a2ab66c":"markdown","b74018dd":"markdown","ce0ea3e3":"markdown","c5dd7ff6":"markdown"},"source":{"abf433fe":"!pip install ase==3.17 schnetpack","ff269231":"!ls ..\/input","4fbba587":"import numpy as np\nimport pandas as pd\nmolecules = pd.read_csv('..\/input\/structures.csv')\nmolecules = molecules.groupby('molecule_name')\nenergies = pd.read_csv('..\/input\/potential_energy.csv')\ndipoles = pd.read_csv('..\/input\/dipole_moments.csv')\ndipoles['scalar'] = np.sqrt(np.square(dipoles[['X', 'Y', 'Z']]).sum(axis=1))","c9a580ad":"molecules.ngroups","6b9d946f":"energies.head()","bda9bd76":"len(energies)","faff9afa":"energy_series = pd.Series(energies.set_index('molecule_name')['potential_energy'])\nenergy_series.describe()","6ebce868":"ax = energy_series.hist(bins=50)\n_ = ax.set_xlabel(\"Potential Energy\")","e1365527":"dipoles.head()","b9ebb8fa":"len(dipoles)","9b19949a":"dipole_series = pd.Series(dipoles.set_index('molecule_name')['scalar'])\ndipole_series.describe()","f563c17c":"ax = dipole_series.hist(bins=50)\n_ = ax.set_xlabel(\"Dipole Moment\")","2d7f312f":"train = pd.read_csv('..\/input\/train.csv')\ntrain.head()","a910e37e":"train_molecule_names = train.molecule_name.unique()\nlen(train_molecule_names)","50fdc3f6":"from ase import Atoms\nfrom ase.db import connect\n\ndef create_db(db_path, molecule_names):\n    with connect(db_path) as db:\n        for name in molecule_names:\n            mol = molecules.get_group(name)\n            atoms = Atoms(symbols=mol.atom.values,\n                          positions=[(row.x,row.y,row.z) for row in mol.itertuples()])\n            db.write(atoms, name=name,\n                     potential_energy=energy_series.get(name, default=float('nan')),\n                     scalar_dipole=dipole_series.get(name, default=float('nan'))\n                    )","f98d7897":"champs_path = 'CHAMPS_train.db'\ndataset_size = len(train_molecule_names) # 20000\ndataset_molecule_names = train_molecule_names[:dataset_size]\ncreate_db(db_path=champs_path, molecule_names=dataset_molecule_names)","baffb133":"with connect(champs_path) as db:\n    print(len(db))","c9651b02":"import schnetpack\n\nproperties=['potential_energy', 'scalar_dipole']\n\ndataset = dict()\nfor p in properties:\n    dataset[p] = schnetpack.data.AtomsData(champs_path, properties=[p])","e380c213":"for p in properties:\n    print(p, len(dataset[p]))","aedf2ce3":"import pandas as pd\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.optim import Adam\n\nimport schnetpack as spk\nimport schnetpack.atomistic as atm\nimport schnetpack.representation as rep\nfrom schnetpack.datasets import *\n\ndevice = torch.device(\"cuda\")","2b60a996":"# This function comes from the following script:\n# https:\/\/github.com\/atomistic-machine-learning\/schnetpack\/blob\/v0.2.1\/src\/scripts\/schnetpack_qm9.py\ndef evaluate_dataset(metrics, model, loader, device):\n    for metric in metrics:\n        metric.reset()\n\n    with torch.no_grad():\n        for batch in loader:\n            batch = {\n                k: v.to(device)\n                for k, v in batch.items()\n            }\n            result = model(batch)\n\n            for metric in metrics:\n                metric.add_batch(batch, result)\n\n    results = [\n        metric.aggregate() for metric in metrics\n    ]\n    return results","73fe5d0e":"def schnet_model(property):\n    reps = rep.SchNet(n_interactions=6)\n    if 'dipole' in property:\n        print('use dipole moment')\n        output = atm.DipoleMoment(n_in=128, predict_magnitude=True)\n    else:\n        output = atm.Atomwise()\n    model = atm.AtomisticModel(reps, output)\n    model = model.to(device)\n    \n    return model","3b8fa34c":"def train_model(property, max_epochs=500):\n    # split in train and val\n    n_dataset = len(dataset[property])\n    n_val = n_dataset \/\/ 10\n    train_data, val_data, test_data = dataset[property].create_splits(n_dataset-n_val*2, n_val)\n    train_loader = spk.data.AtomsLoader(train_data, batch_size=128, num_workers=2)\n    val_loader = spk.data.AtomsLoader(val_data, batch_size=256, num_workers=2)\n\n    # create model\n    model = schnet_model(property)\n\n    # create trainer\n    opt = Adam(model.parameters(), lr=2e-4, weight_decay=1e-6)\n    loss = lambda b, p: F.mse_loss(p[\"y\"], b[property])\n    metrics = [\n        spk.metrics.MeanAbsoluteError(property, \"y\"),\n        spk.metrics.RootMeanSquaredError(property, \"y\"),\n    ]\n    hooks = [\n        spk.train.MaxEpochHook(max_epochs),\n        spk.train.CSVHook(property+'\/log', metrics, every_n_epochs=1),\n    ]\n    trainer = spk.train.Trainer(property+'\/output', model, loss,\n                            opt, train_loader, val_loader, hooks=hooks)\n\n    # start training\n    trainer.train(device)\n    \n    # evaluation\n    model.load_state_dict(torch.load(property+'\/output\/best_model'))\n    test_loader = spk.data.AtomsLoader(test_data, batch_size=256, num_workers=2)\n    model.eval()\n\n    df = pd.DataFrame()\n    df['metric'] = ['MAE', 'RMSE']\n    df['training'] = evaluate_dataset(metrics, model, train_loader, device)\n    df['validation'] = evaluate_dataset(metrics, model, val_loader, device)\n    df['test'] = evaluate_dataset(metrics, model, test_loader, device)\n    display(df)\n    \n    return test_data","a37ebdc8":"def show_history(property):\n    df = pd.read_csv(property+'\/log\/log.csv')\n    display(df.tail())\n    max_value = None # df['RMSE_'+property].min()*5\n    _ = df[['MAE_'+property,'RMSE_'+property]].plot(ylim=(0,max_value))","6e77ec9d":"def test_prediction(dataset, property):\n    # create model\n    model = schnet_model(property)\n    \n    # load the best parameters\n    model.load_state_dict(torch.load(property+'\/output\/best_model'))\n    loader = spk.data.AtomsLoader(dataset, batch_size=256, num_workers=2)\n    model.eval()\n    \n    # predict molecular properties\n    targets = []\n    predictions = []\n    with torch.no_grad():\n        for batch in loader:\n            batch = {\n                k: v.to(device)\n                for k, v in batch.items()\n            }\n            result = model(batch)\n            targets += batch[property].squeeze().tolist()\n            predictions += result['y'].squeeze().tolist()\n    return targets, predictions","d83323ef":"def show_predictions(dataset, property):\n    targets, predictions = test_prediction(dataset, property)\n    df_pred = pd.DataFrame()\n    df_pred['Target'] = targets\n    df_pred['Prediction'] = predictions\n    df_pred.plot.scatter(x='Target', y='Prediction', title=property)","0815b4fc":"used_test_data = dict()\nfor p in properties:\n    print(p)\n    used_test_data[p] = train_model(p, max_epochs=100)\n    show_history(p)","2372f0ac":"for p in properties:\n    show_predictions(used_test_data[p], p)","5f0158e8":"!mv potential_energy\/log\/log.csv log_potential.csv\n!mv scalar_dipole\/log\/log.csv log_dipole.csv\n!mv potential_energy\/output\/best_model best_model_potential\n!mv scalar_dipole\/output\/best_model best_model_dipole\n!rm -r potential_energy\n!rm -r scalar_dipole","dba49f8c":"!ls","34d68201":"# Results","bea32643":"# ASE Database\n\nA dataset object used in SchNetPack is built on an ASE database. Please see the document of the ASE database:\n\nhttps:\/\/wiki.fysik.dtu.dk\/ase\/ase\/db\/db.html","3cd34988":"# SchNet Model\n\nPlease see the SchNetPack API document:\n\nhttps:\/\/schnetpack.readthedocs.io\/en\/stable\/modules\/index.html","8f28f23a":"# CHAMPS data","c6200dd2":"### Dipole Moment","0a2ab66c":"The total number of molecules:","b74018dd":"We need `ASE 3.17` for `SchNetPack 0.2.1`.","ce0ea3e3":"### Potential Energy","c5dd7ff6":"This kernel presents how to build an ASE database from CHAMPS data and create a dataset, and then uses it for molecular property predictions.\n\nFirst, please see an SchNet tutorial on QM9:\n\n[SchNet QM9](https:\/\/www.kaggle.com\/tonyyy\/schnet-qm9)\n\nwhich contains references of the SchNet architecture.\n\nThis kernel uses only potential energies and dipole moments in CHAMPS data. Mulliken charges and magnetic shielding tensors are used in the following kernels:\n* [SchNet Mulliken Charges](https:\/\/www.kaggle.com\/tonyyy\/schnet-mulliken-charges)\n* [SchNet Magnetic Shielding](https:\/\/www.kaggle.com\/tonyyy\/schnet-magnetic-shielding)"}}