{"cell_type":{"a8093f0f":"code","9479036a":"code","edf27752":"code","c86af8bd":"code","d6eb4640":"code","c240951a":"code","37fb9488":"code","b230b981":"code","add76b9a":"code","749cf048":"code","b3ac0d43":"markdown","06d21679":"markdown","8c1d6d31":"markdown","e42c5219":"markdown","d4ba726c":"markdown","22048aca":"markdown","219f3343":"markdown","ef899a1f":"markdown","ce35cc84":"markdown"},"source":{"a8093f0f":"import numpy as np\nimport pandas as pd\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings('ignore')","9479036a":"from sklearn.metrics import confusion_matrix , classification_report\nfrom sklearn.cluster import KMeans\nimport sklearn.metrics as cma\nfrom sklearn.model_selection import KFold\nfrom sklearn import model_selection\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.model_selection import train_test_split","edf27752":"df2 = pd.read_csv('..\/input\/vertebralcolumndataset\/column_3C.csv')\ndf2.describe()\ndf2.info()\ndf2['class'] = df2['class'].map({'Normal': 0, 'Hernia': 1, 'Spondylolisthesis': 2})","c86af8bd":"sns.pairplot(df2, hue=\"class\", size=3, diag_kind=\"kde\")","d6eb4640":"def euclidian(p1, p2): \n    dist = 0\n    for i in range(len(p1)):\n        dist = dist + np.square(p1[i]-p2[i])\n    dist = np.sqrt(dist)\n    return dist;\n\ndef manhattan(p1, p2): \n    dist = 0\n    for i in range(len(p1)):\n        dist = dist + abs(p1[i]-p2[i])\n    return dist;\n","c240951a":"def dNN_2(X_train,y_train, X_test,dist='euclidian',q=2):\n    pred = []\n    if isinstance(X_test, np.ndarray):\n        X_test=pd.DataFrame(X_test)\n    if isinstance(X_train, np.ndarray):\n        X_train=pd.DataFrame(X_train)\n    vetMean = df2.reset_index().groupby( [ \"class\"],as_index=False ).agg({'pelvic_incidence': [np.mean],\n                            'pelvic_tilt': [np.mean],\n                            'lumbar_lordosis_angle': [np.mean],\n                            'sacral_slope': [np.mean],\n                            'pelvic_radius': [np.mean],\n                            'degree_spondylolisthesis': [np.mean]\n                          }, as_index=False )\n    \n    for i in range(len(X_test)):    \n        # Calculando as dist\u00e2ncias para nosso test-point\n        novadist = np.zeros(len(y_train))\n        novadistc0 = np.zeros(len(y_train))\n        novadistc1 = np.zeros(len(y_train))\n        novadistc2 = np.zeros(len(y_train))\n        \n        if dist=='euclidian':\n            for l in range(len(y_train)):\n                for j1 in range(len(vetMean)):\n                    novadistc0[l] = euclidian(vetMean.iloc[0,1:], X_test.iloc[i,:])\n                    novadistc1[l] = euclidian(vetMean.iloc[1,1:], X_test.iloc[i,:])\n                    novadistc2[l] = euclidian(vetMean.iloc[2,1:], X_test.iloc[i,:])\n                    \n                    novadist[l] = np.minimum(novadistc2[l]  , np.minimum( novadistc0[l],novadistc1[l]  )  )\n\n            if novadistc0[l] <= novadistc1[l] and  novadistc0[l] <= novadistc2[l]:\n                pred.append(0)\n            elif novadistc1[l] <= novadistc0[l] and  novadistc1[l] <= novadistc2[l]:\n                pred.append(1)\n            else:\n                novadistc2[l] <= novadistc0[l] and  novadistc2[l] <= novadistc1[l]\n                pred.append(2)\n        novadist = np.array([novadist, y_train])\n    return pred","37fb9488":"def kNN(X_train,y_train, X_test, k, dist='euclidian',q=2):\n    pred = []\n    # Testando o tipo de dado recebido\n    if isinstance(X_test, np.ndarray):\n        X_test=pd.DataFrame(X_test)\n    if isinstance(X_train, np.ndarray):\n        X_train=pd.DataFrame(X_train)\n        \n    for i in range(len(X_test)):    \n        # Calculando as distancias para os pontos de teste\n        novadist = np.zeros(len(y_train))\n\n        if dist=='euclidian':\n            for j in range(len(y_train)):\n                novadist[j] = euclidian(X_train.iloc[j,:], X_test.iloc[i,:])\n    \n        novadist = np.array([novadist, y_train])\n\n        ## Encontrando os k vizinhos mais pr\u00f3ximos\n        idx = np.argsort(novadist[0,:])\n\n        # Sorteio de todos novadist\n        novadist = novadist[:,idx]\n\n        # Contando os labels vizinhos e pegando o label com max count\n        # Define um dict para os counts\n        c = {'0':0,'1':0,'2':0 }\n        # Update counts no dict \n        for j in range(k):\n            c[str(int(novadist[1,j]))] = c[str(int(novadist[1,j]))] + 1\n\n        key_max = max(c.keys(), key=(lambda k: c[k]))\n        pred.append(int(key_max))\n    return pred","b230b981":"all_X = df2[['pelvic_incidence','pelvic_tilt','lumbar_lordosis_angle','sacral_slope', 'pelvic_radius','degree_spondylolisthesis']]\nall_y = df2['class']\n\n\ndf2=df2[['pelvic_incidence','pelvic_tilt','lumbar_lordosis_angle','sacral_slope', 'pelvic_radius','degree_spondylolisthesis', 'class']]\ntrain_data,test_data = train_test_split(df2,train_size = 0.8,random_state=2)\nX_train = train_data[['pelvic_incidence','pelvic_tilt','lumbar_lordosis_angle','sacral_slope', 'pelvic_radius','degree_spondylolisthesis']]\ny_train = train_data['class']\nX_test = test_data[['pelvic_incidence','pelvic_tilt','lumbar_lordosis_angle','sacral_slope', 'pelvic_radius','degree_spondylolisthesis']]\ny_test = test_data['class']\n\ndef transform2(i):\n    if i == 0:\n        return 'Normal'\n    if i == 1:\n        return 'Hernia'\n    if i == 2:\n        return 'Spondylolisthesis'","add76b9a":"x = all_X.values\ny = all_y.values\n\nscores = []\ncv = KFold(n_splits=5, random_state=42, shuffle=False)\nfor train_index, test_index in cv.split(x):\n    X_train, X_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]\n    best_svr =  dNN_2(X_train,y_train, X_test)\n    cm = confusion_matrix(y_test, best_svr)\n    scores.append(cm)        \n\nprint('Confusion Matrix ',scores)\nprint('\\n')\na = cm.shape\ncorrPred = 0\nfalsePred = 0\n\nfor row in range(a[0]):\n    for c in range(a[1]):\n        if row == c:\n            corrPred +=cm[row,c]\n        else:\n            falsePred += cm[row,c]\nprint('True pred: ', corrPred)\nprint('False pred', falsePred)  ","749cf048":"x = all_X.values\ny = all_y.values\n\nscores = []\ncv = KFold(n_splits=5, random_state=42, shuffle=False)\nfor train_index, test_index in cv.split(x):\n\n    X_train, X_test, y_train, y_test = x[train_index], x[test_index], y[train_index], y[test_index]\n    best_svr =  kNN(X_train,y_train, X_test, 5, dist='euclidian',q=5)\n    cm = confusion_matrix(y_test, best_svr)\n    scores.append(cm)        \nprint('Confusion Matrix ',scores)\nprint('\\n')\na = cm.shape\ncorrPred = 0\nfalsePred = 0\n\nfor row in range(a[0]):\n    for c in range(a[1]):\n        if row == c:\n            corrPred +=cm[row,c]\n        else:\n            falsePred += cm[row,c]\nprint('True pred: ', corrPred)\nprint('False pred', falsePred)  ","b3ac0d43":"### DNN","06d21679":"# Modeling ","8c1d6d31":"## 5NN Result","e42c5219":"# Algorithms from scrath","d4ba726c":"### KNN","22048aca":"# Metrics","219f3343":"# In progress ","ef899a1f":"## DNN Result","ce35cc84":"# Final"}}