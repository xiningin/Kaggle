{"cell_type":{"73d7fd65":"code","5716a3bd":"code","88d1ca40":"code","e95e4449":"code","8e23bcff":"code","7a832fd3":"code","7c986719":"code","1fd031bd":"code","09daf98e":"code","af30f728":"code","b665ce82":"code","0ead157c":"code","a666a4ee":"code","7272dfec":"code","5b52b22b":"code","6f89313e":"markdown","abfefd55":"markdown","187aed01":"markdown","7f4683b0":"markdown","ca01d5be":"markdown","07c877b9":"markdown","716a5ef6":"markdown","acdf012b":"markdown","cc024bbe":"markdown","4f67341a":"markdown","0c4a36f4":"markdown","3e5ce1ab":"markdown","33b42578":"markdown","2ea5b296":"markdown","b213dda5":"markdown"},"source":{"73d7fd65":"import numpy as np\nimport pandas as pd\nimport math\nimport plotly.express as px\n#Trabalho desenvolvido por Ronald Albert","5716a3bd":"class Tabuleiro:\n    #Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o da classe tabuleiro, temos 3 par\u00e2metros, sendo somente necess\u00e1rio passar um deles\n    #O par\u00e2metro n representa a quantidade de rainha no tabuleiro assim como o tamanho do tabuleiro (n x n)\n    #O par\u00e2metro queens \u00e9 a representa\u00e7\u00e3o do tabuleiro em forma de vetor de tamanho n, sendo cada index do vetor\n    #uma das colunas do tabuleiro e cada valor a linha em que a rainha presente naquela coluna se encontra\n    #O par\u00e2metro binString \u00e9 a mesma representa\u00e7\u00e3o do tabuleiro do que o par\u00e2metro queens s\u00f3 que na forma de uma\n    #string binaria\n    def __init__(self, n, queens=[], binString=''):\n        self.n = n\n        if(not np.array_equal(queens, []) and binString == ''):\n            self.queens = queens\n            self.binString = self.representacaoBinaria(1, self.n)\n        elif (np.array_equal(queens, []) and binString != ''):\n            self.binString = binString\n            self.queens = self.gerarTabuleiroDeBin(self.binString)\n        elif (not np.array_equal(queens, []) and binString != ''):\n            self.queens = queens\n            self.binString = binString\n        else:\n            self.queens = self.gerarTabuleiro()\n            self.binString = self.representacaoBinaria(1, self.n)\n            \n    #Fun\u00e7\u00e3o para gerar um tabuleiro aleat\u00f3rio.            \n    def gerarTabuleiro(self):\n        queens = np.random.randint(1, self.n + 1, size=(self.n))\n        return queens\n    \n    #Fun\u00e7\u00e3o para gerar o tabuleiro a partir da vari\u00e1vel stringBin que pode ter sido passsada na declara\u00e7\u00e3o da\n    #classe.\n    def gerarTabuleiroDeBin(self, queens):\n        nBits = math.ceil(math.log(self.n, 2))\n        tabuleiro = [(int(queens[i:i+nBits], 2) + 1) for i in range(0, len(queens), nBits)]\n        return tabuleiro\n    \n    #Fun\u00e7\u00e3o para retornar uma representa\u00e7\u00e3o bin\u00e1ria do tabuleiro a partir da vari\u00e1vel\n    #queens que pode ter sido passada como par\u00e2metro para a fun\u00e7\u00e3o no lugar da string binaria\n    def representacaoBinaria(self, minValue, maxValue):\n        binString = ''\n        nBits = math.ceil(math.log(self.n, 2))\n        for e in self.queens:\n            binString += bin(e - minValue)[2:].zfill(nBits)\n        return binString\n    \n    #Fun\u00e7\u00e3o de avalia\u00e7\u00e3o do tabuleiro\n    #a fun\u00e7\u00e3o come\u00e7a calculando o total de pares de rainhas n\u00e3o atacantes\n    #no caso de nenhuma das rainhas poderem se atacar\n    #esse calculo \u00e9 dado pela combina\u00e7\u00e3o do n\u00famero de rainhas\n    #dois a dois, a partir disso basta subtrair esse valor da quantidade de\n    #ataques entre as rainhas que encontramos o n\u00famero de pares de rainhas n\u00e3o\n    #atacantes no tabuleiro.\n    def avaliarTabuleiro(self):\n        if hasattr(self, 'n_pares_nao_atacantes'):\n            return self.n_pares_nao_atacantes\n        \n        n_pares_nao_atacantes = (self.n*(self.n-1))\/2\n        for i in range(0, self.n):\n            for j in range(i + 1, self.n):\n                if self.queens[i] == self.queens[j]:\n                    n_pares_nao_atacantes -= 1\n                elif self.queens[i] + (j - i) == self.queens[j]:\n                    n_pares_nao_atacantes -= 1\n                elif self.queens[i] - (j - i) == self.queens[j]:\n                    n_pares_nao_atacantes -= 1\n        self.n_pares_nao_atacantes = n_pares_nao_atacantes\n        return n_pares_nao_atacantes\n    \n    #Fun\u00e7\u00e3o para printar o tabuleiro:\n    def print_tabuleiro(self):\n        matriz_rainha = np.zeros((self.n,self.n))\n        for i in range(self.n):\n            for j in range(self.n):\n                matriz_rainha[i][j] = 0\n        for i in range(self.n):            \n            for j in range(self.n):\n                if self.queens[j] == i+1:                \n                    matriz_rainha[i][j] = 1 \n        matriz_texto = \"+\"\n        for i in range(self.n):\n            matriz_texto += \"---\"\n        matriz_texto += \"+\\n|\"\n        for i in range(self.n):\n            matriz_texto += \"\"\n            for j in range(self.n):\n                if matriz_rainha[i][j] == 0:\n                    matriz_texto += \" . \"\n                else:\n                    matriz_texto += \" Q \"\n                if j == self.n-1:\n                    if i == self.n-1:\n                        matriz_texto += \"|\\n\"\n                    else:\n                        matriz_texto += \"|\\n|\"\n        matriz_texto += \"+\"\n        for i in range(self.n):\n            matriz_texto += \"---\"\n        matriz_texto += \"+\\n\"\n        matriz_texto += \"|\"\n        for i in range(self.n):\n            matriz_texto += \"   \"\n        matriz_texto += \"|\\n\"\n        matriz_texto += \"+\"\n        for i in range(self.n):\n            matriz_texto += \"---\"\n        matriz_texto += \"+\\n\"\n        print(matriz_texto)","88d1ca40":"class Populacao:\n    #Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o da popula\u00e7\u00e3o, que al\u00e9m de definir os tabuleiros que a comp\u00f5em, tamb\u00e9m\n    #calcula a popula\u00e7\u00e3o intermedi\u00e1ria ap\u00f3s serem aplicados os operadores\n    def __init__(self, n, size, pc, pm, elitismo=False, tabuleiros = []):\n        self.n = n\n        self.size = size\n        self.pc = pc\n        self.pm = pm\n        self.elitismo = elitismo\n        self.tabuleiros = tabuleiros if not np.array_equal(tabuleiros, []) else self.gerarPopulacao()\n        self.probabilidades = self.construirRoletaViciada()\n        self.popIntermediaria = self.construirPopulacaoIntermediaria()\n        self.popIntermediaria = self.realizarCrossover()\n        self.popIntermediaria = self.realizarMutacao()\n        \n    #Fun\u00e7\u00e3o para gerar uma popula\u00e7\u00e3o ale\u00e1toria, chamada no caso de n\u00e3o forem passados tabuleiros\n    #como par\u00e2metro para a classe.\n    def gerarPopulacao(self):\n        tabuleiros = []\n        for i in range(0, self.n):\n            tabuleiros.append(list(Tabuleiro(self.size).queens))\n        return tabuleiros\n    \n    #Fun\u00e7\u00e3o para construir uma roleta viciada, que se baseia em um vetor com cada um dos intervalos de probabilidade\n    #poss\u00edveis, de maneira que todos os valores desse vetor somam 1.\n    #Como esse fun\u00e7\u00e3o itera por todos os tabuleiros da popula\u00e7\u00e3o, j\u00e1 aproveitamos para tamb\u00e9m encontrar o \n    #individuo de melhor adapta\u00e7\u00e3o da popula\u00e7\u00e3o\n    def construirRoletaViciada(self):\n        probabilidades = []\n        totalSum = 0\n        self.melhorTabuleiro = self.tabuleiros[0]\n        for i in self.tabuleiros:\n            totalSum += Tabuleiro(self.size, queens=i).avaliarTabuleiro()\n            probabilidades.append(totalSum)\n            if(self.elitismo):\n                self.melhorTabuleiro = i if Tabuleiro(self.size, queens=i).avaliarTabuleiro() > Tabuleiro(self.size, queens=self.melhorTabuleiro).avaliarTabuleiro() else self.melhorTabuleiro\n        \n        probabilidades = list(map(lambda x: x\/totalSum, probabilidades))\n        self.probabilidades = probabilidades\n        return probabilidades\n    \n    #Fun\u00e7\u00e3o para constru\u00e7\u00e3o da popula\u00e7\u00e3o intermedi\u00e1ria, a cada itera\u00e7\u00e3o \u00e9 gerado um n\u00famero ale\u00e1torio\n    #e a fun\u00e7\u00e3o se baseia em determinar em qual dos intervalos do vetor de probabilidades est\u00e1 esse n\u00famero \n    #aleat\u00f3rio, como cada um desses intervalos est\u00e1 associado a um tabuleiro da popula\u00e7\u00e3o, esse tabuleiro, \u00e9 ent\u00e3o\n    #adicionado a popula\u00e7\u00e3o intermediaria\n    #Se o elitismo da popula\u00e7\u00e3o est\u00e1 habilitado o melhor ind\u00edviduo \u00e9 transmitido diretamente para a popula\u00e7\u00e3o\n    #intermedi\u00e1ria.\n    def construirPopulacaoIntermediaria(self):\n        tabuleiros = []\n        for i in range(0, self.n):\n            randomNumber = np.random.random()\n            for i in range(0, len(self.probabilidades)):\n                if(self.probabilidades[i] > randomNumber):\n                    tabuleiros.append(self.tabuleiros[i])\n                    break\n                    \n        if(self.elitismo):\n            tabuleiros[0] = self.melhorTabuleiro\n        \n        return tabuleiros\n    \n    #Fun\u00e7\u00e3o para atualizar a popula\u00e7\u00e3o intermedi\u00e1ria ap\u00f3s o cross over ser realizado\n    #Se o elitismo da popula\u00e7\u00e3o est\u00e1 habilitado o melhor ind\u00edviduo \u00e9 transmitido diretamente para a popula\u00e7\u00e3o\n    #intermedi\u00e1ria\n    def realizarCrossover(self):\n        tabuleiros = []\n        for i in range(0, self.n, 2):\n            randomNumber = np.random.random()\n            if(randomNumber < self.pc):\n                randomIndex = np.random.randint(1, self.size)\n                novoTabuleiro1 = self.popIntermediaria[i][:(randomIndex)] + self.popIntermediaria[i + 1][(randomIndex):]\n                novoTabuleiro2 = self.popIntermediaria[i + 1][:(randomIndex)] + self.popIntermediaria[i][(randomIndex):]\n                tabuleiros.append(novoTabuleiro1)\n                tabuleiros.append(novoTabuleiro2)\n            else:\n                tabuleiros.append(self.popIntermediaria[i])\n                tabuleiros.append(self.popIntermediaria[i + 1])\n                \n        if(self.elitismo):\n            tabuleiros[0] = self.melhorTabuleiro\n        \n        return tabuleiros\n    \n    #Fun\u00e7\u00e3o para atualizar a popula\u00e7\u00e3o intermedi\u00e1ria ap\u00f3s a muta\u00e7\u00e3o para cada um dos elementos\n    #Se o elitismo da popula\u00e7\u00e3o est\u00e1 habilitado o melhor ind\u00edviduo \u00e9 transmitido diretamente para a popula\u00e7\u00e3o\n    #intermedi\u00e1ria\n    def realizarMutacao(self):\n        tabuleiros = []\n        for i in self.popIntermediaria:\n            randomNumber = np.random.random()\n            novoTabuleiro = i\n            if(randomNumber < self.pm):\n                randomIndex = np.random.randint(0, self.size)\n                novoTabuleiro[randomIndex] = np.random.randint(1, self.size + 1)\n            tabuleiros.append(novoTabuleiro)\n        \n        if(self.elitismo):\n            tabuleiros[0] = self.melhorTabuleiro\n        \n        return tabuleiros","e95e4449":"class PopulacaoBinario:\n    def __init__(self, n, size, pc, pm, elitismo=False, tabuleiros = []):\n        self.n = n\n        self.size = size\n        self.pc = pc\n        self.pm = pm\n        self.elitismo = elitismo\n        self.tabuleiros = tabuleiros if not np.array_equal(tabuleiros, []) else self.gerarPopulacao()\n        self.probabilidades = self.construirRoletaViciada()\n        self.popIntermediaria = self.construirPopulacaoIntermediaria()\n        self.popIntermediaria = self.realizarCrossover()\n        self.popIntermediaria = self.realizarMutacao()\n    \n    def gerarPopulacao(self):\n        tabuleiros = []\n        for i in range(0, self.n):\n            tabuleiros.append(Tabuleiro(self.size).binString)\n        \n        return tabuleiros\n    \n    def construirRoletaViciada(self):\n        probabilidades = []\n        totalSum = 0\n        self.melhorTabuleiro = self.tabuleiros[0]\n        for i in self.tabuleiros:\n            totalSum += Tabuleiro(self.size, binString=i).avaliarTabuleiro()\n            probabilidades.append(totalSum)\n            if(self.elitismo):\n                self.melhorTabuleiro = i if Tabuleiro(self.size, binString=i).avaliarTabuleiro() > Tabuleiro(self.size, binString=self.melhorTabuleiro).avaliarTabuleiro() else self.melhorTabuleiro\n        \n        probabilidades = list(map(lambda x: x\/totalSum, probabilidades))\n        return probabilidades\n        \n    def construirPopulacaoIntermediaria(self):\n        tabuleiros = []\n        for i in range(0, self.n):\n            randomNumber = np.random.random()\n            for i in range(0, len(self.probabilidades)):\n                if(self.probabilidades[i] > randomNumber):\n                    tabuleiros.append(self.tabuleiros[i])\n                    break\n        \n        if(self.elitismo):\n            tabuleiros[0] = self.melhorTabuleiro\n            \n        return tabuleiros\n    \n    def realizarCrossover(self):\n        tabuleiros = []\n        nBits = math.ceil(math.log(self.size, 2))\n        for i in range(0, self.n, 2):\n            randomNumber = np.random.random()\n            if(randomNumber < self.pc):\n                randomIndex = np.random.randint(1, self.size)\n                novaStringBin1 = self.popIntermediaria[i][:(randomIndex * nBits)] + self.popIntermediaria[i + 1][(randomIndex * nBits):]\n                novaStringBin2 = self.popIntermediaria[i + 1][:(randomIndex * nBits)] + self.popIntermediaria[i][(randomIndex * nBits):]\n                tabuleiros.append(novaStringBin1)\n                tabuleiros.append(novaStringBin2)\n            else:\n                tabuleiros.append(self.popIntermediaria[i])\n                tabuleiros.append(self.popIntermediaria[i + 1])\n                \n        if(self.elitismo):\n            tabuleiros[0] = self.melhorTabuleiro\n        \n        return tabuleiros\n    \n    def realizarMutacao(self):\n        tabuleiros = []\n        nBits = math.ceil(math.log(self.size, 2))\n        for i in self.popIntermediaria:\n            randomNumber = np.random.random()\n            novaBinString = i\n            if(randomNumber < self.pm):\n                randomIndex = np.random.randint(0, nBits * self.size)\n                listBinString = list(novaBinString)\n                listBinString[randomIndex] =  '1' if listBinString[randomIndex] == '0' else '0'\n                novaBinString = \"\".join(listBinString)\n            tabuleiros.append(novaBinString)\n            \n        if(self.elitismo):\n            tabuleiros[0] = self.melhorTabuleiro\n        \n        return tabuleiros","8e23bcff":"def algoritmoGeneticoBinario(n_it, tamanho_pop, tamanho_tab, p_cross, p_mut, elitismo=False):\n    popCorrente = PopulacaoBinario(tamanho_pop, tamanho_tab, p_cross, p_mut, elitismo)\n    for i in range(0, n_it):\n        popCorrente = PopulacaoBinario(tamanho_pop, tamanho_tab, p_cross, p_mut, elitismo, popCorrente.popIntermediaria)\n        \n    return popCorrente","7a832fd3":"def algoritmoGenetico(n_it, tamanho_pop, tamanho_tab, p_cross, p_mut, elitismo=False):\n    popCorrente = Populacao(tamanho_pop, tamanho_tab, p_cross, p_mut, elitismo)\n    for i in range(0, n_it):\n        popCorrente = Populacao(tamanho_pop, tamanho_tab, p_cross, p_mut, elitismo, popCorrente.popIntermediaria)\n        \n    return popCorrente","7c986719":"tamanhoTeste = [4, 8, 16, 32]\npopulacaoTeste = [10, 50, 100]\niteracoesTeste = [10, 20, 50, 100]\ncrossTeste = [0.3, 0.5, 0.7, 0.9]\nmutacaoTeste = [0, 0.05, 0.1, 0.5]\nelitismoTeste = [False, True]\n\n\ndef testarAlgoritmoGenetico():\n    dfAlgoritmoGenetico = pd.DataFrame()\n    for tam in tamanhoTeste:\n        for pop in populacaoTeste:\n            for it in iteracoesTeste:\n                for pc in crossTeste:\n                    for pm in mutacaoTeste:\n                        for el in elitismoTeste:\n                            resultado = algoritmoGenetico(it, pop, tam, pc, pm, el)\n                            dfAlgoritmoGenetico = dfAlgoritmoGenetico.append({\n                                \"tamanho_tab\": tam,\n                                 \"populacao\":  pop,\n                                 \"iteracoes\": it,\n                                 \"probabilidade_crossing\": pc,\n                                 \"probabilidade_mutacao\": pm,\n                                 \"elitismo\": el,\n                                 \"media\": calcularMediaEDesvioPadroaDaPopulacao(resultado, tam)[0],\n                                 \"desvio padr\u00e3o\": calcularMediaEDesvioPadroaDaPopulacao(resultado, tam)[1] \n                            }, ignore_index=True)\n    return dfAlgoritmoGenetico\n\ndef testarAlgoritmoGeneticoBinario():\n    dfAlgoritmoGenetico = pd.DataFrame()\n    for tam in tamanhoTeste:\n        for pop in populacaoTeste:\n            for it in iteracoesTeste:\n                for pc in crossTeste:\n                    for pm in mutacaoTeste:\n                        for el in elitismoTeste:\n                            resultado = algoritmoGeneticoBinario(it, pop, tam, pc, pm, el)\n                            dfAlgoritmoGenetico = dfAlgoritmoGenetico.append({\n                                \"tamanho_tab\": tam,\n                                 \"populacao\":  pop,\n                                 \"iteracoes\": it,\n                                 \"probabilidade_crossing\": pc,\n                                 \"probabilidade_mutacao\": pm,\n                                 \"elitismo\": el,\n                                 \"media\": calcularMediaEDesvioPadroaDaPopulacaoBinario(resultado, tam)[0],\n                                 \"desvio padr\u00e3o\": calcularMediaEDesvioPadroaDaPopulacaoBinario(resultado, tam)[1] \n                            }, ignore_index=True)\n    return dfAlgoritmoGenetico\n\ndef calcularMediaEDesvioPadroaDaPopulacao(pop, tam):\n    a = []\n    for tab in pop.tabuleiros:\n        a.append( Tabuleiro(tam, queens=tab).avaliarTabuleiro() )\n    \n    return (np.mean(a), np.std(a))\n\ndef calcularMediaEDesvioPadroaDaPopulacaoBinario(pop, tam):\n    a = []\n    for tab in pop.tabuleiros:\n        a.append( Tabuleiro(tam, binString=tab).avaliarTabuleiro() )\n    \n    return (np.mean(a), np.std(a))\n\ndfAlgoritmoGenetico = testarAlgoritmoGenetico()\ndfAlgoritmoGeneticoBinario = testarAlgoritmoGeneticoBinario()","1fd031bd":"dfAlgoritmoGeneticoTab4 = dfAlgoritmoGenetico[dfAlgoritmoGenetico['tamanho_tab'].eq(4)]\n\nfig = px.scatter(dfAlgoritmoGeneticoTab4, x=\"media\", y=\"desvio padr\u00e3o\", color=\"elitismo\",\n                 size='populacao', hover_data=['probabilidade_crossing', 'probabilidade_mutacao', 'iteracoes'])\nfig.show()","09daf98e":"dfAlgoritmoGeneticoTab8 = dfAlgoritmoGenetico[dfAlgoritmoGenetico['tamanho_tab'].eq(8)]\n\nfig = px.scatter(dfAlgoritmoGeneticoTab8, x=\"media\", y=\"desvio padr\u00e3o\", color=\"elitismo\",\n                 size='populacao', hover_data=['probabilidade_crossing', 'probabilidade_mutacao', 'iteracoes'])\nfig.show()","af30f728":"dfAlgoritmoGeneticoTab16 = dfAlgoritmoGenetico[dfAlgoritmoGenetico['tamanho_tab'].eq(16)]\n\nfig = px.scatter(dfAlgoritmoGeneticoTab16, x=\"media\", y=\"desvio padr\u00e3o\", color=\"elitismo\",\n                 size='populacao', hover_data=['probabilidade_crossing', 'probabilidade_mutacao', 'iteracoes'])\nfig.show()","b665ce82":"dfAlgoritmoGeneticoTab32 = dfAlgoritmoGenetico[dfAlgoritmoGenetico['tamanho_tab'].eq(32)]\n\nfig = px.scatter(dfAlgoritmoGeneticoTab32, x=\"media\", y=\"desvio padr\u00e3o\", color=\"elitismo\",\n                 size='populacao', hover_data=['probabilidade_crossing', 'probabilidade_mutacao', 'iteracoes'])\nfig.show()","0ead157c":"dfAlgoritmoGeneticoBinarioTab4 = dfAlgoritmoGeneticoBinario[dfAlgoritmoGeneticoBinario['tamanho_tab'].eq(4)]\n\nfig = px.scatter(dfAlgoritmoGeneticoBinarioTab4, x=\"media\", y=\"desvio padr\u00e3o\", color=\"elitismo\",\n                 size='populacao', hover_data=['probabilidade_crossing', 'probabilidade_mutacao', 'iteracoes'])\nfig.show()","a666a4ee":"dfAlgoritmoGeneticoBinarioTab8 = dfAlgoritmoGeneticoBinario[dfAlgoritmoGeneticoBinario['tamanho_tab'].eq(8)]\n\nfig = px.scatter(dfAlgoritmoGeneticoBinarioTab8, x=\"media\", y=\"desvio padr\u00e3o\", color=\"elitismo\",\n                 size='populacao', hover_data=['probabilidade_crossing', 'probabilidade_mutacao', 'iteracoes'])\nfig.show()","7272dfec":"dfAlgoritmoGeneticoBinarioTab16 = dfAlgoritmoGeneticoBinario[dfAlgoritmoGeneticoBinario['tamanho_tab'].eq(16)]\n\nfig = px.scatter(dfAlgoritmoGeneticoBinarioTab16, x=\"media\", y=\"desvio padr\u00e3o\", color=\"elitismo\",\n                 size='populacao', hover_data=['probabilidade_crossing', 'probabilidade_mutacao', 'iteracoes'])\nfig.show()","5b52b22b":"dfAlgoritmoGeneticoBinarioTab32 = dfAlgoritmoGeneticoBinario[dfAlgoritmoGeneticoBinario['tamanho_tab'].eq(32)]\n\nfig = px.scatter(dfAlgoritmoGeneticoBinarioTab32, x=\"media\", y=\"desvio padr\u00e3o\", color=\"elitismo\",\n                 size='populacao', hover_data=['probabilidade_crossing', 'probabilidade_mutacao', 'iteracoes'])\nfig.show()","6f89313e":"# Os seguintes gr\u00e1ficos s\u00e3o para a execu\u00e7\u00e3o na forma de vetor do problema","abfefd55":"# Gr\u00e1fico do tabuleiro 32x32\n\nO seguinte gr\u00e1fico representa o gr\u00e1fico da m\u00e9dia pelo desvio padr\u00e3o dos tabuleiros 32x32, ambas as cores representam se o\nelitismo foi ou n\u00e3o aplicado e passando o mouse sobre cada um dos pontos pode se ver as entrada para aquela execu\u00e7\u00e3o","187aed01":"# A classe PopulacaoBinario\nA classe 'PopulacaoBinario' funciona da mesma maneira que a classe 'Populacao', com \na exce\u00e7\u00e3o de que a representa\u00e7\u00e3o armazenada na popula\u00e7\u00e3o \u00e9 uma string de binarios.","7f4683b0":"# O algoritmo gen\u00e9tico\nSeguem abaixo as implementa\u00e7\u00f5es de cada um dos algor\u00edtmos gen\u00e9ticos (para as classes 'Populacao' e 'PopulacaoBinario')<br>\nAmbas a implementa\u00e7\u00f5es do algoritmo bin\u00e1rio possuem 6 par\u00e2metros.<br>\nO par\u00e2metro n_it \u00e9 o n\u00famero de itera\u00e7\u00f5es executado pelo algoritmo gen\u00e9tico at\u00e9 que a execu\u00e7\u00e3o pare.<br>\nO par\u00e2metro tamanho_pop \u00e9 o tamanho da popula\u00e7\u00e3o que ser\u00e1 avaliada pelo algoritmo gen\u00e9tico.<br>\nO par\u00e2metro tamanho_tab \u00e9 o tamanho dos tabuleiros que comp\u00f5em a popula\u00e7\u00e3o avaliada pelo algoritmo gen\u00e9rico.<br>\nO par\u00e2metro p_cross \u00e9 a probabilidade de executar o crossing over.<br>\nO par\u00e2metro p_mut \u00e9 a probabilidade de executar a muta\u00e7\u00e3o.<br>\nO par\u00e2metro elitismo \u00e9 se o elitismo ser\u00e1 aplicado as popula\u00e7\u00f5es.","ca01d5be":"# Gr\u00e1fico do tabuleiro 4x4\n\nO seguinte gr\u00e1fico representa o gr\u00e1fico da m\u00e9dia pelo desvio padr\u00e3o dos tabuleiros 4x4, ambas as cores representam se o\nelitismo foi ou n\u00e3o aplicado e passando o mouse sobre cada um dos pontos pode se ver as entrada para aquela execu\u00e7\u00e3o","07c877b9":"# Gr\u00e1fico do tabuleiro 8x8\n\nO seguinte gr\u00e1fico representa o gr\u00e1fico da m\u00e9dia pelo desvio padr\u00e3o dos tabuleiros 8x8, ambas as cores representam se o\nelitismo foi ou n\u00e3o aplicado e passando o mouse sobre cada um dos pontos pode se ver as entrada para aquela execu\u00e7\u00e3o","716a5ef6":"# Gr\u00e1fico do tabuleiro 16x16\n\nO seguinte gr\u00e1fico representa o gr\u00e1fico da m\u00e9dia pelo desvio padr\u00e3o dos tabuleiros 16x16, ambas as cores representam se o\nelitismo foi ou n\u00e3o aplicado e passando o mouse sobre cada um dos pontos pode se ver as entrada para aquela execu\u00e7\u00e3o","acdf012b":"# A classe tabuleiro\nA classe armazena a defini\u00e7\u00e3o de um tabuleiro do problema, a representa\u00e7\u00e3o por vetores \u00e9 definida sendo cada um dos elementos do vetor representado a posi\u00e7\u00e3o da rainha naquela coluna <br>\nA classe tamb\u00e9m armazena o valor do tabuleiro como uma string de binarios <br>","cc024bbe":"# Testes\n\nS\u00e3o definidas listas para cada uma das poss\u00edveis entradas do algor\u00edtmo gen\u00e9tico e a partir disso a fun\u00e7\u00e3o 'testarAlgoritmoGenetico' executa o algoritmo gen\u00e9tico para cada uma das entradas definidas com o resultado sendo plotado pelo gr\u00e1fico abaixo. <br>\nAnalogamente a fun\u00e7\u00e3o 'testarAlgoritmoGenetico' temos tamb\u00e9m 'testarAlgoritmoGeneticoBinario', para o algoritmo gen\u00e9tico na representa\u00e7\u00e3o bin\u00e1ria do problema,<br>\nOs gr\u00e1ficos apresentados apresentam uma rela\u00e7\u00e3o entre a m\u00e9dia e o desvio padr\u00e3o dos resultados das fun\u00e7\u00f5es de adapta\u00e7\u00e3o de cada uma das execu\u00e7\u00f5es do algoritmo gen\u00e9tico, dado, determinada entrada","4f67341a":"# A classe Populacao \nOs par\u00e2metros da classe popula\u00e7\u00e3o s\u00e3o\nO par\u00e2metro n representa a quantidade de tabuleiros na popula\u00e7\u00e3o<br>\nO par\u00e2metro size representa a quantidade de rainhas nos tabuleiros dessa popula\u00e7\u00e3o assim como o tamanho desses\ntabuleiros (size x size)<br>\nO par\u00e2metro pc \u00e9 a probabilidade de crossing over<br>\nO par\u00e2metro pm \u00e9 a probabilidade de muta\u00e7\u00e3o<br>\nO par\u00e2metro elitismo \u00e9 um booleano que representa se o elitismo vai ser aplicado a popula\u00e7\u00e3o<br>\nO par\u00e2metro tabuleiros que pode ser passado ou n\u00e3o \u00e9 de fato a popula\u00e7\u00e3o que essa classe representa, esse par\u00e2metro pode ser de um vetor de tabuleiro, representados como o vetor de tabuleiros definido na classe tabuleiro, ou para o caso da 'PopulacaoBinario' representados como uma string de binarios<br>\n","0c4a36f4":"# Gr\u00e1fico do tabuleiro 4x4\n\nO seguinte gr\u00e1fico representa o gr\u00e1fico da m\u00e9dia pelo desvio padr\u00e3o dos tabuleiros 4x4, ambas as cores representam se o\nelitismo foi ou n\u00e3o aplicado e passando o mouse sobre cada um dos pontos pode se ver as entrada para aquela execu\u00e7\u00e3o","3e5ce1ab":"# Gr\u00e1fico do tabuleiro 16x16\n\nO seguinte gr\u00e1fico representa o gr\u00e1fico da m\u00e9dia pelo desvio padr\u00e3o dos tabuleiros 16x16, ambas as cores representam se o\nelitismo foi ou n\u00e3o aplicado e passando o mouse sobre cada um dos pontos pode se ver as entrada para aquela execu\u00e7\u00e3o","33b42578":"# Gr\u00e1fico do tabuleiro 32x32\n\nO seguinte gr\u00e1fico representa o gr\u00e1fico da m\u00e9dia pelo desvio padr\u00e3o dos tabuleiros 32x32, ambas as cores representam se o\nelitismo foi ou n\u00e3o aplicado e passando o mouse sobre cada um dos pontos pode se ver as entrada para aquela execu\u00e7\u00e3o","2ea5b296":"# Os seguintes gr\u00e1ficos s\u00e3o para as execu\u00e7\u00f5es na forma bin\u00e1ria do problema","b213dda5":"# Gr\u00e1fico do tabuleiro 8x8\n\nO seguinte gr\u00e1fico representa o gr\u00e1fico da m\u00e9dia pelo desvio padr\u00e3o dos tabuleiros 8x8, ambas as cores representam se o\nelitismo foi ou n\u00e3o aplicado e passando o mouse sobre cada um dos pontos pode se ver as entrada para aquela execu\u00e7\u00e3o"}}