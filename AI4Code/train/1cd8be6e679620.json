{"cell_type":{"a72c06b2":"code","77f66281":"code","c6f51f0b":"code","803757af":"code","9dba3d82":"code","0c3b1786":"code","e3263e7e":"code","19c69027":"code","360fb1e6":"code","5c675b6a":"code","0c40af06":"code","09f16f29":"code","5d927ee7":"code","8a435327":"code","5d10c083":"code","711eebde":"code","df7ca1d1":"code","c957a2c4":"code","acb168e6":"code","153b9b83":"code","53271338":"code","e444ac72":"code","795f35e3":"code","296eb812":"code","be446beb":"code","f5256c5a":"code","b5cecb1c":"code","8fd42a5d":"code","b23456dc":"code","581b9fbd":"code","cc488edf":"code","a7b9dee5":"code","6fb79fea":"code","3fd53417":"code","7319d8eb":"markdown","f30d1409":"markdown","5df0e619":"markdown","bc9dfe1d":"markdown","340d8252":"markdown","90b5f47a":"markdown","5a0740f1":"markdown","ba4b4cbd":"markdown","28b005f0":"markdown","5fe9ade6":"markdown","18562d3a":"markdown","2571187b":"markdown","210d9f39":"markdown","86133822":"markdown","adc0effc":"markdown","75a91106":"markdown","fa9f90b3":"markdown","28437a56":"markdown","c1c7484e":"markdown","5505ff17":"markdown","ad4e5ce7":"markdown","4a0830c4":"markdown","6cf7cf06":"markdown","481a9cd7":"markdown"},"source":{"a72c06b2":"%%capture\n!pip install forgi\n!yes Y |conda install -c bioconda viennarna","77f66281":"import os, math, random\nfrom collections import Counter\n\nimport RNA\nimport subprocess\nfrom forgi.graph import bulge_graph\nimport forgi.visual.mplotlib as fvm\nfrom IPython.display import Image, SVG\n\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom colorama import Fore, Back, Style","c6f51f0b":"path = '\/kaggle\/input\/stanford-covid-vaccine'\ntrain_df = pd.read_json(f'{path}\/train.json',lines=True)\ntest_df = pd.read_json(f'{path}\/test.json', lines=True)\nsub_df = pd.read_csv(f'{path}\/sample_submission.csv')\n\nprint('Train set sequences: ', train_df.shape)\nprint('Test set sequences: ', test_df.shape)","803757af":"train_df.head()","9dba3d82":"def data_info(_id, df):\n    print(Fore.YELLOW)\n    print(\"ID = \",_id)\n    sample_data = df.loc[df['id'] == _id]\n    print(Fore.MAGENTA)\n    print(\"Secquence : \\n\\n\",sample_data['sequence'].values[0])\n    print(dict(Counter(sample_data['sequence'].values[0])))\n    print(\"Secquence Length : \",len(sample_data['sequence'].values[0]))\n    print(Fore.CYAN)\n    print(\"Structure : \\n\",sample_data['structure'].values[0])\n    print(dict(Counter(sample_data['structure'].values[0])))\n    print(\"Structure Length : \",len(sample_data['structure'].values[0]))\n    print(Fore.WHITE)\n    print(\"predicted_loop_type : \\n\\n\",sample_data['predicted_loop_type'].values[0])\n    print(dict(Counter(sample_data['predicted_loop_type'].values[0])))\n    print(\"predicted_loop_type Length : \",len(sample_data['predicted_loop_type'].values[0]))\n    print(Fore.GREEN)\n    print(\"seq_length :\",sample_data['seq_length'].values)\n    print(\"seq_scored :\",sample_data['seq_scored'].values)\n    print(Style.RESET_ALL)","0c3b1786":"data_info(\"id_001f94081\",train_df)","e3263e7e":"plt.figure(figsize=(12,5))\nn, bins, patches = plt.hist(x=train_df['signal_to_noise'], bins='auto', color='#0504aa', alpha=1, rwidth=0.80)\nplt.grid(axis='y', alpha=0.75)\nplt.xlabel('signal_to_noise')\nplt.ylabel('Frequency')\nplt.title('signal_to_noise Histogram')\nplt.text(12, 110, f\"(SN_filter == 1)  : {train_df['SN_filter'].value_counts()[0]}\", fontsize=15)\nplt.text(12, 85, f\"(SN_filter == 0) : {train_df['SN_filter'].value_counts()[1]}\", fontsize=15)\nplt.show()","19c69027":"train_df.seq_length.value_counts()","360fb1e6":"train_df.seq_scored.value_counts()","5c675b6a":"test_df.head()","0c40af06":"data_info(\"id_000ae4237\",test_df)","09f16f29":"test_df.seq_length.value_counts()","5d927ee7":"test_df.seq_scored.value_counts()","8a435327":"def character_count(row):\n    _dictionary = {'G': 0,'A': 0, 'C': 0, 'U': 0, '.': 0, '(': 0, ')': 0, 'E': 0, 'S': 0, 'H': 0, 'B': 0, 'X': 0,'I': 0,'M':0}\n    _dictionary = {**_dictionary, **dict(Counter(row['sequence']))}\n    _dictionary = {**_dictionary, **dict(Counter(row['structure']))}\n    _dictionary = {**_dictionary, **dict(Counter(row['predicted_loop_type']))}\n    return list(_dictionary.values())","5d10c083":"## Train-Data\nfeature_columns = ['G','A', 'C', 'U', '.', '(', ')', 'E', 'S', 'H', 'B', 'X','I','M']\ntrain_df[feature_columns] = train_df.apply(character_count,axis=1,result_type=\"expand\")","711eebde":"fig, _ax = plt.subplots(nrows=4,ncols=4,figsize=(20,20))\nfig.suptitle(\"Train Data New Features Histograms\", fontsize=20,)\nfor i,_ax in enumerate(_ax.ravel()[:14]):\n    mean_value = train_df[feature_columns[i]].mean()\n    max_value_index,max_value = Counter(train_df[feature_columns[i]]).most_common(1)[0]\n    \n    _ax.hist(x=train_df[feature_columns[i]],bins='auto', color='#0504aa', alpha=1, rwidth=1)\n    _ax.set(ylabel=f\"'{feature_columns[i]}' Frequency\", title= f\"'{feature_columns[i]}' Histogram\")\n    _ax.axvline(x=mean_value, color='r', label= 'Average',linewidth=2)\n    _ax.axvline(x=max_value_index, color='y', label= 'Max',linewidth=2)\n    _ax.legend([f\"Average : {mean_value:0.2f}\",f\"Max Frequency : {max_value}\", \"Hist\"], loc =\"upper right\")\nplt.show()","df7ca1d1":"# Train Data New Features correlation\ncorr = train_df[feature_columns].corr()\nsns.set_context(\"notebook\", font_scale=1.0, rc={\"lines.linewidth\": 2.5})\nplt.figure(figsize=(13,7))\nplt.title(\"Train Data New Features correlation : \")\nmask = np.zeros_like(corr)\nmask[np.triu_indices_from(mask, 1)] = True\na = sns.heatmap(corr,mask=mask, annot=True, fmt='.2f')\nrotx = a.set_xticklabels(a.get_xticklabels(), rotation=90)\nroty = a.set_yticklabels(a.get_yticklabels(), rotation=30)","c957a2c4":"## Test-Data\nfeature_columns = ['G','A', 'C', 'U', '.', '(', ')', 'E', 'S', 'H', 'B', 'X','I','M']\ntest_df[feature_columns] = test_df.apply(character_count,axis=1,result_type=\"expand\")","acb168e6":"fig, _ax = plt.subplots(nrows=4,ncols=4,figsize=(20,20))\nfig.suptitle(\"Test Data New Features Histograms\", fontsize=20,)\nfor i,_ax in enumerate(_ax.ravel()[:14]):\n    mean_value = test_df[feature_columns[i]].mean()\n    max_value_index,max_value = Counter(test_df[feature_columns[i]]).most_common(1)[0]\n    \n    _ax.hist(x=test_df[feature_columns[i]],bins='auto', color='#0504aa', alpha=1, rwidth=1)\n    _ax.set(ylabel=f\"'{feature_columns[i]}' Frequency\", title= f\"'{feature_columns[i]}' Histogram\")\n    _ax.axvline(x=mean_value, color='r', label= 'Average',linewidth=2)\n    _ax.axvline(x=max_value_index, color='y', label= 'Max',linewidth=2)\n    _ax.legend([f\"Average : {mean_value:0.2f}\",f\"Max Frequency : {max_value}\", \"Hist\"], loc =\"upper right\")\nplt.show()","153b9b83":"# Test Data New Features correlation\ncorr = test_df[feature_columns].corr()\nsns.set_context(\"notebook\", font_scale=1.0, rc={\"lines.linewidth\": 2.5})\nplt.figure(figsize=(13,7))\nplt.title(\"Test Data New Features correlation : \")\nmask = np.zeros_like(corr)\nmask[np.triu_indices_from(mask, 1)] = True\na = sns.heatmap(corr,mask=mask, annot=True, fmt='.2f')\nrotx = a.set_xticklabels(a.get_xticklabels(), rotation=90)\nroty = a.set_yticklabels(a.get_yticklabels(), rotation=30)","53271338":"Select_id = \"id_001f94081\"","e444ac72":"Sequence = train_df[train_df['id'] == Select_id][\"sequence\"].values[0]\nstructure = train_df[train_df['id'] == Select_id][\"structure\"].values[0]\npredicted_loop_type = train_df[train_df['id'] == Select_id][\"predicted_loop_type\"].values[0]\nprint(\"Sequence :\",Sequence)\nprint(\"structure :\",structure)\nprint(\"predicted_loop_type :\",predicted_loop_type)","795f35e3":"bg, = bulge_graph.BulgeGraph.from_fasta_text('>seq\\n' + Sequence + '\\n' + structure)\n\nplt.figure(figsize=(10,10))\nfvm.plot_rna(bg, text_kwargs={\"fontweight\":\"black\"}, lighten=0.7,\n             backbone_kwargs={\"linewidth\":3})\nplt.show()","296eb812":"def render_neato(s, format='png', dpi=100):\n    p = subprocess.Popen(['neato', '-T', format, '-o', '\/dev\/stdout', '-Gdpi={}'.format(dpi)], \n                         stdout=subprocess.PIPE, stdin=subprocess.PIPE)\n    image, _ = p.communicate(bytes(s, encoding='utf-8'))\n    return image","be446beb":"Image(render_neato(bg.to_neato_string(), dpi=60), format='png')","f5256c5a":"def get_couples(structure):\n    \"\"\"\n    For each closing parenthesis, I find the matching opening one and store their index in the couples list.\n    The assigned list is used to keep track of the assigned opening parenthesis\n    \"\"\"\n    opened = [idx for idx, i in enumerate(structure) if i == '(']\n    closed = [idx for idx, i in enumerate(structure) if i == ')']\n\n    assert len(opened) == len(closed)\n\n\n    assigned = []\n    couples = []\n\n    for close_idx in closed:\n        for open_idx in opened:\n            if open_idx < close_idx:\n                if open_idx not in assigned:\n                    candidate = open_idx\n            else:\n                break\n        assigned.append(candidate)\n        couples.append([candidate, close_idx])\n        \n    assert len(couples) == len(opened)\n    \n    return couples","b5cecb1c":"def build_matrix(couples, size):\n    mat = np.zeros((size, size))\n    \n    for i in range(size):  # neigbouring bases are linked as well\n        if i < size - 1:\n            mat[i, i + 1] = 1\n        if i > 0:\n            mat[i, i - 1] = 1\n    \n    for i, j in couples:\n        mat[i, j] = 1\n        mat[j, i] = 1\n        \n    return mat","8fd42a5d":"couples = get_couples(structure)\nmat = build_matrix(couples, len(structure))\n\nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(11.35, 5))\n\nim = axes[0].imshow(mat, interpolation='none',cmap='gray')\naxes[0].set_title('Graph of the structure')\n# axes[0].pcolormesh(adj_mat, )\n\nbpp = np.load(path +f\"\/bpps\/{Select_id}.npy\")\n\nim = axes[1].imshow(bpp, interpolation='none',cmap='gray')\naxes[1].set_title('BPP Matrix')\n\nplt.show()","b23456dc":"Select_id = \"id_000ae4237\"","581b9fbd":"Sequence = test_df[test_df['id'] == Select_id][\"sequence\"].values[0]\nstructure = test_df[test_df['id'] == Select_id][\"structure\"].values[0]\npredicted_loop_type = test_df[test_df['id'] == Select_id][\"predicted_loop_type\"].values[0]\nprint(\"Sequence :\",Sequence)\nprint(\"structure :\",structure)\nprint(\"predicted_loop_type :\",predicted_loop_type)","cc488edf":"bg, = bulge_graph.BulgeGraph.from_fasta_text('>seq\\n' + Sequence + '\\n' + structure)\n\nplt.figure(figsize=(20,10))\nfvm.plot_rna(bg, text_kwargs={\"fontweight\":\"black\"}, lighten=0.8,\n             backbone_kwargs={\"linewidth\":3})\nplt.show()","a7b9dee5":"def render_neato(s, format='png', dpi=100):\n    p = subprocess.Popen(['neato', '-T', format, '-o', '\/dev\/stdout', '-Gdpi={}'.format(dpi)], \n                         stdout=subprocess.PIPE, stdin=subprocess.PIPE)\n    image, _ = p.communicate(bytes(s, encoding='utf-8'))\n    return image","6fb79fea":"Image(render_neato(bg.to_neato_string(), dpi=60), format='png')","3fd53417":"couples = get_couples(structure)\nmat = build_matrix(couples, len(structure))\n\nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(11.35, 5))\n\nim = axes[0].imshow(mat, interpolation='none',cmap='gray')\naxes[0].set_title('Graph of the structure')\n\nbpp = np.load(path +f\"\/bpps\/{Select_id}.npy\")\n\nim = axes[1].imshow(bpp, interpolation='none',cmap='gray')\naxes[1].set_title('BPP Matrix')\n\nplt.show()","7319d8eb":"## signal_to_noise Histogram","f30d1409":"## Data Import","5df0e619":"## Install Packages\n\n---\n- Reference\n\n    1. [https:\/\/anaconda.org\/bioconda\/viennarna](https:\/\/anaconda.org\/bioconda\/viennarna)\n    2. [https:\/\/github.com\/ViennaRNA\/forgi](https:\/\/github.com\/ViennaRNA\/forgi)","bc9dfe1d":"## Visualize RNA-2D Structure","340d8252":"---\n\n* **fiveprime**: The unpaired nucleotides at the 5\u2019 end of a molecule\/ chain. Name always starts with \u2018f\u2019 (e.g. \u2018f0\u2019).\n* **threeprime**: The unpaired nucleotides at the 3\u2019 end of a molecule\/ chain. Name always start with \u2018t\u2019 (e.g. \u2018t0\u2019)\n\n* **stem**: Regions of contiguous canonical Watson-Crick base-paired nucleotides. By default, stems have at least 2 consecutive basepairs. Always start with \u2018s\u2019 (e.g., \u2018s0\u2019, \u2018s1\u2019, \u2018s2\u2019, \u2026)\n\n* **interior loop**: Bulged out nucleotides and interior loops. An interior loop can contain unpaired bases on either strand or on both strands, flanked by stems on either side. Always start with \u2018i\u2019 (\u2018i0\u2019, \u2018i1\u2019, \u2018i2\u2019,\u2026)\n\n* **multiloop segment**: Single-stranded regions bewteen two stems. Always start with \u2018m\u2019. (\u2018m0\u2019, \u2018m1\u2019, \u2018m2\u2019\u2026)\n    In the current version of forgi, pseudo-knots and exterior loops segments between stems are treated as multiloop segments.\n\n* **hairpin loop**: Always starts with \u2018h\u2019.\n","90b5f47a":"## Generating Graph Matrices from the Structures\n   * [Referance](https:\/\/www.kaggle.com\/theoviel\/generating-graph-matrices-from-the-structures)","5a0740f1":"### Example-2 (Test Data)","ba4b4cbd":"![vaccine-image.jpg](attachment:vaccine-image.jpg)","28b005f0":"### Example-1 (from Train data)","5fe9ade6":"## Detailed Analysis","18562d3a":"## Train Data Overview","2571187b":"## Method for Graph Representation of RNA structure","210d9f39":"### \ud83e\udd37\u200d\u2642\ufe0f: '**E**', '**S**' , '**)**' , '**(**'  are highly correlated","86133822":"* In 2D-Visualization it is difficult to picture which section is which part of RNA. To make it easier, we will generate a Graph Structure. The neato method can take that as input and create a nice visualization of the graph:","adc0effc":"* In Test data seq_length = 107 have seq_scored = 68   #[629]\n* In Test data seq_length = 130 have seq_scored = 91   #[3005]","75a91106":"## Library Imports","fa9f90b3":"## Data Info Method","28437a56":"## Visualize RNA-2D Structure","c1c7484e":"**What do we have**?\n\nWe have a subset of an Eterna dataset comprising over 3000 RNA molecules (which span a panoply of sequences and structures) and their degradation rates at each position.\n\nThere are multiple ground truth values provided in the training data. While the submission format requires all 5 to be predicted, only the following are scored: reactivity, deg_Mg_pH10, and deg_Mg_50C.\nFiles\n\n*     train.json - the training data\n*     test.json - the test set, without any columns associated with the ground truth.\n*     sample_submission.csv - a sample submission file in the correct format\n\n**Columns**\n\n*     `id` - An arbitrary identifier for each sample.\n\n*     `seqscored` - (68 in Train and Public Test, 91 in Private Test) Integer value denoting the number of positions used in scoring with predicted values. This should match the length of reactivity, deg and error* columns. Note that molecules used for the Private Test will be longer than those in the Train and Public Test data, so the size of this vector will be different.\n\n*     `seq_length` - (107 in Train and Public Test, 130 in Private Test) Integer values, denotes the length of sequence. Note that molecules used for the Private Test will be longer than those in the Train and Public Test data, so the size of this vector will be different.\n\n*     `sequence` - (1x107 string in Train and Public Test, 130 in Private Test) Describes the RNA sequence, a combination of A, G, U, and C for each sample. Should be 107 characters long, and the first 68 bases should correspond to the 68 positions specified in seq_scored (note: indexed starting at 0).\n\n*     `structure` - (1x107 string in Train and Public Test, 130 in Private Test) An array of (, ), and . characters that describe whether a base is estimated to be paired or unpaired. Paired bases are denoted by opening and closing parentheses e.g. (....) means that base 0 is paired to base 5, and bases 1-4 are unpaired.\n\n*     `reactivity` - (1x68 vector in Train and Public Test, 1x91 in Private Test) An array of floating point numbers, should have the same length as seq_scored. These numbers are * reactivity values for the first 68 bases as denoted in sequence, and used to determine the likely secondary structure of the RNA sample.\n\n*     `deg_pH10` - (1x68 vector in Train and Public Test, 1x91 in Private Test) An array of floating point numbers, should have the same length as seq_scored. These numbers are reactivity values for the first 68 bases as denoted in sequence, and used to determine the likelihood of degradation at the base\/linkage after incubating without magnesium at high pH (pH 10).\n\n*     `deg_Mg_pH10` - (1x68 vector in Train and Public Test, 1x91 in Private Test) An array of floating point numbers, should have the same length as seq_scored. These numbers are reactivity values for the first 68 bases as denoted in sequence, and used to determine the likelihood of degradation at the base\/linkage after incubating with magnesium in high pH (pH 10).\n\n*     `deg_50C` - (1x68 vector in Train and Public Test, 1x91 in Private Test) An array of floating point numbers, should have the same length as seq_scored. These numbers are reactivity values for the first 68 bases as denoted in sequence, and used to determine the likelihood of degradation at the base\/linkage after incubating without magnesium at high temperature (50 degrees Celsius).\n\n*     `deg_Mg_50C` - (1x68 vector in Train and Public Test, 1x91 in Private Test) An array of floating point numbers, should have the same length as seq_scored. These numbers are reactivity values for the first 68 bases as denoted in sequence, and used to determine the likelihood of degradation at the base\/linkage after incubating with magnesium at high temperature (50 degrees Celsius).\n\n*     `error` - An array of floating point numbers, should have the same length as the corresponding reactivity or deg* columns, calculated errors in experimental values obtained in reactivity and deg* columns.\n\n*     `predicted_loop_type` - (1x107 string) Describes the structural context (also referred to as 'loop type')of each character in sequence. Loop types assigned by bpRNA from Vienna RNAfold 2 structure. From the bpRNA_documentation: S: paired \"Stem\" M: Multiloop I: Internal loop B: Bulge H: Hairpin loop E: dangling End X: eXternal loop","5505ff17":"---\n\n## RNA Detailed Analysis \ud83e\uddec ","ad4e5ce7":"### \ud83e\udd37\u200d\u2642\ufe0f unlike training data 'E' is not highly correlated with '(' , ')'.","4a0830c4":"## OpenVaccine: COVID-19 mRNA Vaccine Degradation Prediction","6cf7cf06":"## Graph Representation of RNA structure","481a9cd7":"## Test Data Overview"}}