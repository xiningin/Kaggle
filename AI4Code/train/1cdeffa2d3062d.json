{"cell_type":{"57b61436":"code","fbc8a71b":"code","627ce1ca":"code","c1bada02":"code","fcd78aa9":"code","04a279ab":"code","f99eb6f4":"code","6cd5e11a":"code","156fb3dd":"code","7deecd90":"code","239350d3":"code","c97c331a":"code","ed10999e":"code","a6874340":"code","5a68c81b":"code","6a4791c4":"code","aa250f1b":"code","01573c0a":"code","9ace2ad9":"code","3000a42b":"code","9d11c37c":"code","de80c230":"code","17ebb56f":"code","5fe7104f":"code","d859c79f":"code","f1839202":"code","f1172df3":"code","12d08ee5":"code","d9c7ae04":"code","fc2053de":"code","fafb608c":"code","f96c3b13":"code","a3fb3826":"code","80556be8":"code","82817133":"code","30c9cc0d":"code","805272c1":"code","88575d52":"code","acbdb0be":"code","8b7ccc14":"code","51c10112":"code","2aa5a0da":"code","a9377c6a":"code","fc07bf40":"code","57de9cb0":"code","dfa253f5":"code","a9f15962":"markdown","7a72aa9b":"markdown","278019b4":"markdown","a7f1fb94":"markdown","bc299868":"markdown","a137ff2a":"markdown","b4ac0188":"markdown","b302bc79":"markdown","b163a849":"markdown","3af4affe":"markdown","df56a440":"markdown","64680495":"markdown","ee58908a":"markdown","7a5f03a9":"markdown","cc8ac66a":"markdown","6f535605":"markdown","416339a5":"markdown","44416171":"markdown","81137ac4":"markdown","529275d4":"markdown","fc8cfc57":"markdown","8104c838":"markdown","f7ef6089":"markdown","17b1e482":"markdown","141a3bb1":"markdown","187b0ac0":"markdown","d7127ec6":"markdown","1d4ce8e3":"markdown","809bf038":"markdown","506594eb":"markdown","18926834":"markdown","2f8a5d17":"markdown","f0c1a8cf":"markdown","5bc87d0d":"markdown","cf008277":"markdown","96a37438":"markdown","07906b74":"markdown","bbc4e2aa":"markdown","ff6750ed":"markdown","58f0c1d4":"markdown","08e2e8f0":"markdown","027e9e7f":"markdown","44c3964e":"markdown","ace84d34":"markdown","2a7ff6dd":"markdown","ea91c362":"markdown","4ea4a101":"markdown","617265aa":"markdown","dc941f23":"markdown","e5054d9a":"markdown","20dbd972":"markdown","aecd5d0b":"markdown","66f120c1":"markdown","242c41b3":"markdown","80710306":"markdown","2ba6970f":"markdown","2ecd6609":"markdown","cf80e239":"markdown","ba7fef33":"markdown","5815d2ff":"markdown","d1635067":"markdown","b3e79ca2":"markdown","6b845081":"markdown","cc8d36f1":"markdown","a29aa619":"markdown","6dbdf704":"markdown","f54cdae0":"markdown","fc93b0d1":"markdown","93bf5650":"markdown","d5944c58":"markdown","94859db3":"markdown","37e34e85":"markdown","781edfed":"markdown","0f174037":"markdown","be81c8eb":"markdown","8654fe76":"markdown","8f22b410":"markdown","2c322990":"markdown","2959ffa6":"markdown","db67d150":"markdown","36ddd348":"markdown","62c70fbf":"markdown"},"source":{"57b61436":"\n# @title Tutorial slides\n\n# @markdown These are the slides for the videos in this tutorial\nfrom IPython.display import IFrame\nIFrame(src=f\"https:\/\/mfr.ca-1.osf.io\/render?url=https:\/\/osf.io\/7um6p\/?direct%26mode=render%26action=download%26mode=render\", width=854, height=480)","fbc8a71b":"# @title Install dependencies\n!apt-get install -y ffmpeg --quiet\n!pip install imageio-ffmpeg --quiet\n\n!pip install git+https:\/\/github.com\/NeuromatchAcademy\/evaltools --quiet\nfrom evaltools.airtable import AirtableForm\n\natform = AirtableForm('appn7VdPRseSoMXEG','W1D5_T2', 'https:\/\/portal.neuromatchacademy.org\/api\/redirect\/to\/a76f99c1-9005-4566-8bcd-bed4e53d21f1')","627ce1ca":"# Imports\nfrom __future__ import print_function\n\nimport copy\nimport torch\nimport random\nimport pathlib\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch.nn.functional as F\n\nfrom torchvision import datasets, transforms\nfrom torchvision.datasets import ImageFolder\nfrom torch.optim.lr_scheduler import StepLR\n\nfrom tqdm.auto import tqdm\nfrom IPython.display import HTML, display","c1bada02":"# @title Figure Settings\nimport ipywidgets as widgets\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nplt.style.use(\"https:\/\/raw.githubusercontent.com\/NeuromatchAcademy\/content-creation\/main\/nma.mplstyle\")","fcd78aa9":"# @title Loading Animal Faces data\nimport requests, os\nfrom zipfile import ZipFile\n\nprint(\"Start downloading and unzipping `AnimalFaces` dataset...\")\nname = 'afhq'\nfname = f\"{name}.zip\"\nurl = f\"https:\/\/osf.io\/kgfvj\/download\"\n\nif not os.path.exists(fname):\n  r = requests.get(url, allow_redirects=True)\n  with open(fname, 'wb') as fh:\n    fh.write(r.content)\n\n  if os.path.exists(fname):\n    with ZipFile(fname, 'r') as zfile:\n      zfile.extractall(f\".\")\n      os.remove(fname)\n\nprint(\"Download completed.\")","04a279ab":"# @title Loading Animal Faces Randomized data\nfrom IPython.display import clear_output\n\nprint(\"Start downloading and unzipping `Randomized AnimalFaces` dataset...\")\n\nnames = ['afhq_random_32x32', 'afhq_10_32x32']\nurls = [\"https:\/\/osf.io\/9sj7p\/download\",\n        \"https:\/\/osf.io\/wvgkq\/download\"]\n\n\nfor i, name in enumerate(names):\n  url = urls[i]\n  fname = f\"{name}.zip\"\n\n  if not os.path.exists(fname):\n    r = requests.get(url, allow_redirects=True)\n    with open(fname, 'wb') as fh:\n      fh.write(r.content)\n\n    if os.path.exists(fname):\n      with ZipFile(fname, 'r') as zfile:\n        zfile.extractall(f\".\")\n        os.remove(fname)\n\nprint(\"Download completed.\")","f99eb6f4":"# @title Plotting functions\n\n\ndef imshow(img):\n  img = img \/ 2 + 0.5  # unnormalize\n  npimg = img.numpy()\n  plt.imshow(np.transpose(npimg, (1, 2, 0)))\n  plt.axis(False)\n  plt.show()\n\n\ndef plot_weights(norm, labels, ws, title='Weight Size Measurement'):\n  plt.figure(figsize=[8, 6])\n  plt.title(title)\n  plt.ylabel('Frobenius Norm Value')\n  plt.xlabel('Model Layers')\n  plt.bar(labels, ws)\n  plt.axhline(y=norm,\n              linewidth=1,\n              color='r',\n              ls='--',\n              label='Total Model F-Norm')\n  plt.legend()\n  plt.show()\n\n\ndef visualize_data(dataloader):\n\n  for idx, (data,label) in enumerate(dataloader):\n    plt.figure(idx)\n    # Choose the datapoint you would like to visualize\n    index = 22\n\n    # choose that datapoint using index and permute the dimensions\n    # and bring the pixel values between [0,1]\n    data = data[index].permute(1, 2, 0) * \\\n           torch.tensor([0.5, 0.5, 0.5]) + \\\n           torch.tensor([0.5, 0.5, 0.5])\n\n    # Convert the torch tensor into numpy\n    data = data.numpy()\n\n    plt.imshow(data)\n    plt.axis(False)\n    image_class = classes[label[index].item()]\n    print(f'The image belongs to : {image_class}')\n\n  plt.show()","6cd5e11a":"# @title Helper functions\n\n## Network Class - Animal Faces\nclass AnimalNet(nn.Module):\n  def __init__(self):\n    super(AnimalNet, self).__init__()\n    self.fc1 = nn.Linear(3 * 32 * 32, 128)\n    self.fc2 = nn.Linear(128, 32)\n    self.fc3 = nn.Linear(32, 3)\n\n  def forward(self, x):\n    x = x.view(x.shape[0], -1)\n    x = F.relu(self.fc1(x))\n    x = F.relu(self.fc2(x))\n    x = self.fc3(x)\n    output = F.log_softmax(x, dim=1)\n    return output\n\n\n# Simple Net\nclass Net(nn.Module):\n  def __init__(self):\n    super(Net, self).__init__()\n\n    self.fc1 = nn.Linear(1, 300)\n    self.fc2 = nn.Linear(300, 500)\n    self.fc3 = nn.Linear(500, 1)\n\n  def forward(self, x):\n    x = F.leaky_relu(self.fc1(x))\n    x = F.leaky_relu(self.fc2(x))\n    output = self.fc3(x)\n    return output\n\n\n# Network Class - Animal Faces\nclass BigAnimalNet(nn.Module):\n  def __init__(self):\n    super(BigAnimalNet, self).__init__()\n    self.fc1 = nn.Linear(3*32*32, 124)\n    self.fc2 = nn.Linear(124, 64)\n    self.fc3 = nn.Linear(64, 3)\n\n  def forward(self, x):\n    x = x.view(x.shape[0],-1)\n    x = F.leaky_relu(self.fc1(x))\n    x = F.leaky_relu(self.fc2(x))\n    x = self.fc3(x)\n    output = F.log_softmax(x, dim=1)\n    return output\n\n\ndef train(args, model, train_loader, optimizer, epoch,\n          reg_function1=None, reg_function2=None, criterion=F.nll_loss):\n  \"\"\"\n  Trains the current inpur model using the data\n  from Train_loader and Updates parameters for a single pass\n  \"\"\"\n\n  device = args['device']\n  model.train()\n  for batch_idx, (data, target) in enumerate(train_loader):\n    data, target = data.to(device), target.to(device)\n    optimizer.zero_grad()\n    output = model(data)\n    # L2 regularization\n    if reg_function1 is None and reg_function2 is not None:\n      loss = criterion(output, target) + args['lambda']*reg_function2(model)\n    # L1 regularization\n    elif reg_function2 is None and reg_function1 is not None:\n      loss = criterion(output, target) + args['lambda']*reg_function1(model)\n    # No regularization\n    elif reg_function1 is None and reg_function2 is None:\n      loss = criterion(output, target)\n    # Both L1 and L2 regularizations\n    else:\n      loss = criterion(output, target) + args['lambda1']*reg_function1(model) + args['lambda2']*reg_function2(model)\n    loss.backward()\n    optimizer.step()\n\n  return model\n\n\ndef test(model, test_loader, loader='Test', criterion=F.nll_loss,\n         device='cpu'):\n  \"\"\"\n  Tests the current Model\n  \"\"\"\n  model.eval()\n  test_loss = 0\n  correct = 0\n  with torch.no_grad():\n    for data, target in test_loader:\n      data, target = data.to(device), target.to(device)\n      output = model(data)\n      test_loss += criterion(output, target, reduction='sum').item()  # sum up batch loss\n      pred = output.argmax(dim=1, keepdim=True)  # get the index of the max log-probability\n      correct += pred.eq(target.view_as(pred)).sum().item()\n\n  test_loss \/= len(test_loader.dataset)\n  def __init__(self):\n    super(BigAnimalNet, self).__init__()\n    self.fc1 = nn.Linear(3*32*32, 124)\n    self.fc2 = nn.Linear(124, 64)\n    self.fc3 = nn.Linear(64, 3)\n\n  def forward(self, x):\n    x = x.view(x.shape[0],-1)\n    x = F.leaky_relu(self.fc1(x))\n    x = F.leaky_relu(self.fc2(x))\n    x = self.fc3(x)\n    output = F.log_softmax(x, dim=1)\n    return output\n  return 100. * correct \/ len(test_loader.dataset)\n\n\ndef main(args, model, train_loader, val_loader, test_data,\n         reg_function1=None, reg_function2=None, criterion=F.nll_loss):\n  \"\"\"\n  Trains the model with train_loader and tests the learned model using val_loader\n  \"\"\"\n\n  device = args['device']\n\n  model = model.to(device)\n  optimizer = optim.SGD(model.parameters(), lr=args['lr'], momentum=args['momentum'])\n\n  val_acc_list, train_acc_list,param_norm_list = [], [], []\n  for epoch in tqdm(range(args['epochs'])):\n    trained_model = train(args, model, train_loader, optimizer, epoch,\n                          reg_function1=reg_function1,\n                          reg_function2=reg_function2)\n    train_acc = test(trained_model, train_loader, loader='Train', device=device)\n    val_acc = test(trained_model, val_loader, loader='Val', device=device)\n    param_norm = calculate_frobenius_norm(trained_model)\n    train_acc_list.append(train_acc)\n    val_acc_list.append(val_acc)\n    param_norm_list.append(param_norm)\n\n  return val_acc_list, train_acc_list, param_norm_list, model\n\n\ndef calculate_frobenius_norm(model):\n    norm = 0.0\n    # Sum the square of all parameters\n    for name,param in model.named_parameters():\n        norm += torch.norm(param).data**2\n    # Return a square root of the sum of squares of all the parameters\n    return norm**0.5\n\n\ndef early_stopping_main(args, model, train_loader, val_loader, test_data):\n\n  device = args['device']\n\n  model = model.to(device)\n  optimizer = optim.SGD(model.parameters(), lr=args['lr'], momentum=args['momentum'])\n\n  best_acc  = 0.0\n  best_epoch = 0\n\n  # Number of successive epochs that you want to wait before stopping training process\n  patience = 20\n\n  # Keps track of number of epochs during which the val_acc was less than best_acc\n  wait = 0\n\n  val_acc_list, train_acc_list = [], []\n  for epoch in tqdm(range(args['epochs'])):\n    trained_model = train(args, model, device, train_loader, optimizer, epoch)\n    train_acc = test(trained_model, train_loader, loader='Train', device=device)\n    val_acc = test(trained_model, val_loader, loader='Val', device=device)\n    if (val_acc > best_acc):\n      best_acc = val_acc\n      best_epoch = epoch\n      best_model = copy.deepcopy(trained_model)\n      wait = 0\n    else:\n      wait += 1\n    if (wait > patience):\n      print(f'early stopped on epoch: {epoch}')\n      break\n    train_acc_list.append(train_acc)\n    val_acc_list.append(val_acc)\n\n  return val_acc_list, train_acc_list, best_model, best_epoch","156fb3dd":"# @title Set random seed\n# @markdown Executing `set_seed(seed=seed)` you are setting the seed\n\n# for DL its critical to set the random seed so that students can have a\n# baseline to compare their results to expected results.\n# Read more here: https:\/\/pytorch.org\/docs\/stable\/notes\/randomness.html\n\n# Call `set_seed` function in the exercises to ensure reproducibility.\nimport random\nimport torch\n\ndef set_seed(seed=None, seed_torch=True):\n  if seed is None:\n    seed = np.random.choice(2 ** 32)\n  random.seed(seed)\n  np.random.seed(seed)\n  if seed_torch:\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.benchmark = False\n    torch.backends.cudnn.deterministic = True\n\n  print(f'Random seed {seed} has been set.')\n\n\n# In case that `DataLoader` is used\ndef seed_worker(worker_id):\n  worker_seed = torch.initial_seed() % 2**32\n  np.random.seed(worker_seed)\n  random.seed(worker_seed)","7deecd90":"# @title Set device (GPU or CPU). Execute `set_device()`\n# especially if torch modules used.\n\n# inform the user if the notebook uses GPU or CPU.\n\ndef set_device():\n  device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n  if device != \"cuda\":\n    print(\"WARNING: For this notebook to perform best, \"\n        \"if possible, in the menu under `Runtime` -> \"\n        \"`Change runtime type.`  select `GPU` \")\n  else:\n    print(\"GPU is enabled in this notebook.\")\n\n  return device","239350d3":"SEED = 2021\nset_seed(seed=SEED)\nDEVICE = set_device()","c97c331a":"# @title Dataloaders for the Dataset\n## Dataloaders for the Dataset\nbatch_size = 128\nclasses = ('cat', 'dog', 'wild')\n\ntrain_transform = transforms.Compose([\n     transforms.ToTensor(),\n     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))\n     ])\ndata_path = pathlib.Path('.')\/'afhq' # using pathlib to be compatible with all OS's\nimg_dataset = ImageFolder(data_path\/'train', transform=train_transform)\n\n\n####################################################\ng_seed = torch.Generator()\ng_seed.manual_seed(SEED)\n\n\n##Dataloaders for the  Original Dataset\nimg_train_data, img_val_data,_ = torch.utils.data.random_split(img_dataset,\n                                                               [100, 100, 14430])\n\n#Creating train_loader and Val_loader\ntrain_loader = torch.utils.data.DataLoader(img_train_data,\n                                           batch_size=batch_size,\n                                           worker_init_fn=seed_worker,\n                                           num_workers=2,\n                                           generator=g_seed)\nval_loader = torch.utils.data.DataLoader(img_val_data,\n                                         batch_size=1000,\n                                         num_workers=2,\n                                         worker_init_fn=seed_worker,\n                                         generator=g_seed)\n\n#creating test dataset\ntest_transform = transforms.Compose([\n     transforms.ToTensor(),\n     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))\n     ])\nimg_test_dataset = ImageFolder(data_path\/'val', transform=test_transform)\n\n\n####################################################\n\n## Dataloaders for the  Random Dataset\n\n# splitting randomized data into training and validation data\ndata_path = pathlib.Path('.')\/'afhq_random_32x32\/afhq_random' # using pathlib to be compatible with all OS's\nimg_dataset = ImageFolder(data_path\/'train', transform=train_transform)\nrandom_img_train_data, random_img_val_data,_ = torch.utils.data.random_split(img_dataset, [100,100,14430])\n\n#Randomized train and validation dataloader\nrand_train_loader = torch.utils.data.DataLoader(random_img_train_data,\n                                                batch_size=batch_size,\n                                                num_workers=2,\n                                                worker_init_fn=seed_worker,\n                                                generator=g_seed)\nrand_val_loader = torch.utils.data.DataLoader(random_img_val_data,\n                                              batch_size=1000,\n                                              num_workers=2,\n                                              worker_init_fn=seed_worker,\n                                              generator=g_seed)\n\n####################################################\n\n## Dataloaders for the Partially Random Dataset\n\n# Splitting data between training and validation dataset for partially randomized data\ndata_path = pathlib.Path('.')\/'afhq_10_32x32\/afhq_10' # using pathlib to be compatible with all OS's\nimg_dataset = ImageFolder(data_path\/'train', transform=train_transform)\npartially_random_train_data, partially_random_val_data, _ = torch.utils.data.random_split(img_dataset, [100,100,14430])\n\n#Training and Validation loader for partially randomized data\npartial_rand_train_loader = torch.utils.data.DataLoader(partially_random_train_data,\n                                                        batch_size=batch_size,\n                                                        num_workers=2,\n                                                        worker_init_fn=seed_worker,\n                                                        generator=g_seed)\npartial_rand_val_loader = torch.utils.data.DataLoader(partially_random_val_data,\n                                                      batch_size=1000,\n                                                      num_workers=2,\n                                                      worker_init_fn=seed_worker,\n                                                      generator=g_seed)","ed10999e":"# @title Video 1: L1 and L2 regression\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV19h41167H7\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"oQNdloKdysM\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 1: L1 and L2 regression')\n\ndisplay(out)","a6874340":"# @markdown #### Dataloaders for Regularization\ndata_path = pathlib.Path('.')\/'afhq' # using pathlib to be compatible with all OS's\nimg_dataset = ImageFolder(data_path\/'train', transform=train_transform)\n\n# Splitting dataset\nreg_train_data, reg_val_data,_ = torch.utils.data.random_split(img_dataset,\n                                                               [30, 100, 14500])\ng_seed = torch.Generator()\ng_seed.manual_seed(SEED)\n\n# Creating train_loader and Val_loader\nreg_train_loader = torch.utils.data.DataLoader(reg_train_data,\n                                               batch_size=batch_size,\n                                               worker_init_fn=seed_worker,\n                                               num_workers=2,\n                                               generator=g_seed)\nreg_val_loader = torch.utils.data.DataLoader(reg_val_data,\n                                             batch_size=1000,\n                                             worker_init_fn=seed_worker,\n                                             num_workers=2,\n                                             generator=g_seed)","5a68c81b":"# Set the arguments\nargs = {\n    'epochs': 150,\n    'lr': 5e-3,\n    'momentum': 0.99,\n    'device': DEVICE,\n}\n\n# intialize the model\nset_seed(seed=SEED)\nmodel = AnimalNet()\n\n# Train the model\nval_acc_unreg, train_acc_unreg, param_norm_unreg, _ = main(args,\n                                                           model,\n                                                           reg_train_loader,\n                                                           reg_val_loader,\n                                                           img_test_dataset)\n\n# Train and Test accuracy plot\nplt.figure(figsize=(8, 6))\nplt.plot(val_acc_unreg, label='Val Accuracy', c='red', ls='dashed')\nplt.plot(train_acc_unreg, label='Train Accuracy', c='red', ls='solid')\nplt.axhline(y=max(val_acc_unreg), c='green', ls='dashed')\nplt.title('Unregularized Model')\nplt.ylabel('Accuracy (%)')\nplt.xlabel('Epoch')\nplt.legend()\nplt.show()\nprint('maximum Validation Accuracy reached:%f' % max(val_acc_unreg))","6a4791c4":"def l1_reg(model):\n  \"\"\"\n    Inputs: Pytorch model\n    This function calculates the l1 norm of the all the tensors in the model\n  \"\"\"\n  l1 = 0.0\n  ####################################################################\n  # Fill in all missing code below (...),\n  # then remove or comment the line below to test your function\n  raise NotImplementedError(\"Complete the l1_reg function\")\n  ####################################################################\n  for param in model.parameters():\n    l1 += ...\n\n  return l1\n\n# add event to airtable\natform.add_event('Coding Exercise 1.1: L1 Regularization')\n\nset_seed(seed=SEED)\n## uncomment to test\n# net = nn.Linear(20, 20)\n# print(f'L1 norm of the model: {l1_reg(net)}')","aa250f1b":"# Set the arguments\nargs = {\n    'epochs': 150,\n    'lr': 5e-3,\n    'momentum': 0.99,\n    'device': DEVICE,\n    'lambda': 0.0  # <<<<<<<< Tune the hyperparameter lambda\n}\n\n# intialize the model\nset_seed(seed=SEED)\nmodel = AnimalNet()\n\n# Train the model\nval_acc_l1reg, train_acc_l1reg, param_norm_l1reg, _ = main(args,\n                                                           model,\n                                                           reg_train_loader,\n                                                           reg_val_loader,\n                                                           img_test_dataset,\n                                                           reg_function1=l1_reg)\n\n# Train and Test accuracy plot\nplt.figure(figsize=(8, 6))\nplt.plot(val_acc_l1reg, label='Val Accuracy L1 Regularized',\n         c='red', ls='dashed')\nplt.plot(train_acc_l1reg, label='Train Accuracy L1 regularized',\n         c='red', ls='solid')\nplt.axhline(y=max(val_acc_l1reg), c='green', ls='dashed')\nplt.title('L1 regularized model')\nplt.ylabel('Accuracy (%)')\nplt.xlabel('Epoch')\nplt.legend()\nplt.show()\nprint('maximum Validation Accuracy reached:%f'%max(val_acc_l1reg))","01573c0a":"def l2_reg(model):\n\n  \"\"\"\n    Inputs: Pytorch model\n    This function calculates the l2 norm of the all the tensors in the model\n  \"\"\"\n\n  l2 = 0.0\n  ####################################################################\n  # Fill in all missing code below (...),\n  # then remove or comment the line below to test your function\n  raise NotImplementedError(\"Complete the l2_reg function\")\n  ####################################################################\n  for param in model.parameters():\n    l2 += ...\n\n  return l2\n\n# add event to airtable\natform.add_event('Coding Exercise 1.2: L2 Regularization')\n\nset_seed(SEED)\n## uncomment to test\n# net = nn.Linear(20, 20)\n# print(f'L2 norm of the model: {l2_reg(net)}')","9ace2ad9":"# Set the arguments\nargs = {\n    'test_batch_size': 1000,\n    'epochs': 150,\n    'lr': 5e-3,\n    'momentum': 0.99,\n    'device': DEVICE,\n    'lambda': 0.0  # <<<<<<<< Tune the hyperparameter lambda\n}\n\n# intialize the model\nset_seed(seed=SEED)\nmodel = AnimalNet()\n\n# Train the model\nval_acc_l2reg, train_acc_l2reg, param_norm_l2reg, model = main(args,\n                                                               model,\n                                                               train_loader,\n                                                               val_loader,\n                                                               img_test_dataset,\n                                                               reg_function2=l2_reg)\n\n## Train and Test accuracy plot\nplt.figure(figsize=(8, 6))\nplt.plot(val_acc_l2reg, label='Val Accuracy L2 regularized',\n         c='red', ls='dashed')\nplt.plot(train_acc_l2reg, label='Train Accuracy L2 regularized',\n         c='red', ls='solid')\nplt.axhline(y=max(val_acc_l2reg), c='green', ls='dashed')\nplt.title('L2 Regularized Model')\nplt.ylabel('Accuracy (%)')\nplt.xlabel('Epoch')\nplt.legend()\nplt.show()\nprint('maximum Validation Accuracy reached:%f'%max(val_acc_l2reg))","3000a42b":"# @markdown #### Visualize all of them together (Run Me!)\nargs = {'test_batch_size': 1000,\n        'epochs': 150,\n        'lr': 5e-3,\n        'momentum': 0.99,\n        'device': DEVICE,\n        'lambda1': 0.001,\n        'lambda2': 0.001\n        }\n\n# Intialize the model\nset_seed(seed=SEED)\nmodel = AnimalNet()\nval_acc_l1l2reg, train_acc_l1l2reg, param_norm_l1l2reg, _ = main(args,\n                                                                 model,\n                                                                 train_loader,\n                                                                 val_loader,\n                                                                 img_test_dataset,\n                                                                 reg_function1=l1_reg,\n                                                                 reg_function2=l2_reg)\n\nplt.figure(figsize=(12, 6))\nplt.plot(val_acc_l2reg, c='red', ls='dashed')\nplt.plot(train_acc_l2reg, label='L2 regularized', c='red', ls='solid')\nplt.axhline(y=max(val_acc_l2reg), c='red', ls='dashed')\nplt.plot(val_acc_l1reg, c='green', ls = 'dashed')\nplt.plot(train_acc_l1reg, label='L1 regularized', c='green', ls='solid')\nplt.axhline(y=max(val_acc_l1reg), c='green', ls='dashed')\nplt.plot(val_acc_unreg, c='blue', ls = 'dashed')\nplt.plot(train_acc_unreg, label='Unregularized', c='blue', ls='solid')\nplt.axhline(y=max(val_acc_unreg), c='blue', ls='dashed')\nplt.plot(val_acc_l1l2reg, c='orange', ls='dashed')\nplt.plot(train_acc_l1l2reg, label='L1+L2 regularized', c='orange', ls='solid')\nplt.axhline(y=max(val_acc_l1l2reg), c='orange', ls = 'dashed')\n\nplt.title('Unregularized Vs L1-Regularized vs L2-regularized Vs L1+L2 regularized')\nplt.xlabel('epoch')\nplt.ylabel('Accuracy(%)')\nplt.legend()\nplt.show()","9d11c37c":"# @markdown #### Visualize Norm of the Models (Train Me!)\nplt.figure(figsize=(8, 6))\nplt.plot(param_norm_unreg, label='Unregularized', c='blue')\nplt.plot(param_norm_l1reg, label='L1 Regularized', c='green')\nplt.plot(param_norm_l2reg, label='L2 Regularized', c='red')\nplt.plot(param_norm_l1l2reg, label='L1+L2 Regularized', c='orange')\nplt.title('Parameter Norm as a function of training Epoch')\nplt.xlabel('epoch')\nplt.ylabel('Parameter Norms')\nplt.legend()\nplt.show()","de80c230":"# @title Video 2: Dropout\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1gU4y1G7V2\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"UZfUzawej3A\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 2: Dropout')\n\ndisplay(out)","17ebb56f":"# Network Class - 2D\nclass NetDropout(nn.Module):\n  def __init__(self):\n    super(NetDropout, self).__init__()\n\n    self.fc1 = nn.Linear(1, 300)\n    self.fc2 = nn.Linear(300, 500)\n    self.fc3 = nn.Linear(500, 1)\n    # We add two dropout layers\n    self.dropout1 = nn.Dropout(0.4)\n    self.dropout2 = nn.Dropout(0.2)\n\n  def forward(self, x):\n    x = F.leaky_relu(self.dropout1(self.fc1(x)))\n    x = F.leaky_relu(self.dropout2(self.fc2(x)))\n    output = self.fc3(x)\n    return output","5fe7104f":"# @markdown #### Run to train the default network\nset_seed(seed=SEED)\n# creating train data\nX = torch.rand((10, 1))\nX.sort(dim = 0)\nY = 2*X + 2*torch.empty((X.shape[0], 1)).normal_(mean=0, std=1)  # adding small error in the data\n\nX = X.unsqueeze_(1)\nY = Y.unsqueeze_(1)\n\n# creating test dataset\nX_test = torch.linspace(0, 1, 40)\nX_test = X_test.reshape((40, 1, 1))\n\n# train the network on toy dataset\nmodel = Net()\ncriterion = nn.MSELoss()\noptimizer = optim.Adam(model.parameters(), lr=1e-4)\nmax_epochs = 10000\niters = 0\n\nrunning_predictions = np.empty((40, (int)(max_epochs\/500 + 1)))\n\ntrain_loss = []\ntest_loss = []\nmodel_norm = []\n\nfor epoch in tqdm(range(max_epochs)):\n\n  #training\n  model_norm.append(calculate_frobenius_norm(model))\n  model.train()\n  optimizer.zero_grad()\n  predictions = model(X)\n  loss = criterion(predictions,Y)\n  loss.backward()\n  optimizer.step()\n\n  train_loss.append(loss.data)\n  model.eval()\n  Y_test = model(X_test)\n  loss = criterion(Y_test, 2*X_test)\n  test_loss.append(loss.data)\n\n  if (epoch % 500 == 0 or epoch == max_epochs - 1):\n    running_predictions[:, iters] = Y_test[:, 0, 0].detach().numpy()\n    iters += 1","d859c79f":"# train the network on toy dataset\n\n# Intialize the model\nset_seed(seed=SEED)\nmodel = NetDropout()\ncriterion = nn.MSELoss()\noptimizer = optim.Adam(model.parameters(), lr=1e-4)\nmax_epochs = 10000\niters = 0\n\nrunning_predictions_dp = np.empty((40, (int)(max_epochs \/ 500)))\n\ntrain_loss_dp = []\ntest_loss_dp = []\nmodel_norm_dp = []\n\nfor epoch in tqdm(range(max_epochs)):\n\n  # training\n  model_norm_dp.append(calculate_frobenius_norm(model))\n  model.train()\n  optimizer.zero_grad()\n  predictions = model(X)\n  loss = criterion(predictions, Y)\n  loss.backward()\n  optimizer.step()\n\n  train_loss_dp.append(loss.data)\n  model.eval()\n  Y_test = model(X_test)\n  loss = criterion(Y_test, 2*X_test)\n  test_loss_dp.append(loss.data)\n\n  if (epoch % 500 == 0 or epoch == max_epochs):\n    running_predictions_dp[:, iters] = Y_test[:, 0, 0].detach().numpy()\n    iters += 1","f1839202":"# @markdown #### Animation! (Run Me!)\nset_seed(seed=SEED)\n\nfig = plt.figure(figsize=(8, 6))\nax = plt.axes()\ndef frame(i):\n  ax.clear()\n  ax.scatter(X[:, 0, :].numpy(), Y[:, 0, :].numpy())\n  plot = ax.plot(X_test[:, 0, :].detach().numpy(),\n                 running_predictions_dp[:, i])\n  title = f\"Epoch: {i*500}\"\n  plt.title(title)\n  ax.set_xlabel(\"X axis\")\n  ax.set_ylabel(\"Y axis\")\n  return plot\n\n\nanim = animation.FuncAnimation(fig, frame, frames=range(20),\n                               blit=False, repeat=False,\n                               repeat_delay=10000)\nhtml_anim = HTML(anim.to_html5_video());\nplt.close()\ndisplay(html_anim)","f1172df3":"# @markdown #### Plot the train and test losses\nplt.figure(figsize=(8, 6))\nplt.plot(test_loss_dp, label='test_loss dropout', c='blue', ls='dashed')\nplt.plot(test_loss, label='test_loss', c='red', ls='dashed')\nplt.ylabel('loss')\nplt.xlabel('epochs')\nplt.title('dropout vs without dropout')\nplt.legend()\nplt.show()","12d08ee5":"# @markdown #### Plot the train and test losses\nplt.figure(figsize=(8, 6))\nplt.plot(train_loss_dp, label='train_loss dropout', c='blue', ls='dashed')\nplt.plot(train_loss, label='train_loss', c='red', ls='dashed')\nplt.ylabel('loss')\nplt.xlabel('epochs')\nplt.title('dropout vs without dropout')\nplt.legend()\nplt.show()","d9c7ae04":"# @markdown #### Plot model weights with epoch\nplt.figure(figsize=(8, 6))\nplt.plot(model_norm_dp, label='dropout')\nplt.plot(model_norm, label='no dropout')\nplt.ylabel('norm of the model')\nplt.xlabel('epochs')\nplt.legend()\nplt.title('Size of the model vs Epochs')\nplt.show()","fc2053de":"# Network Class - Animal Faces\nclass AnimalNetDropout(nn.Module):\n  def __init__(self):\n    super(AnimalNetDropout, self).__init__()\n    self.fc1 = nn.Linear(3*32*32, 248)\n    self.fc2 = nn.Linear(248, 210)\n    self.fc3 = nn.Linear(210, 3)\n    self.dropout1 = nn.Dropout(p=0.5)\n    self.dropout2 = nn.Dropout(p=0.3)\n\n  def forward(self, x):\n    x = x.view(x.shape[0], -1)\n    x = F.leaky_relu(self.dropout1(self.fc1(x)))\n    x = F.leaky_relu(self.dropout2(self.fc2(x)))\n    x = self.fc3(x)\n    output = F.log_softmax(x, dim=1)\n    return output","fafb608c":"# Set the arguments\nargs = {\n    'test_batch_size': 1000,\n    'epochs': 200,\n    'lr': 5e-3,\n    'batch_size': 32,\n    'momentum': 0.9,\n    'device': DEVICE,\n    'log_interval': 100\n}\n\n# intialize the model\nset_seed(seed=SEED)\nmodel = AnimalNetDropout()\n\n# Train the model with Dropout\nval_acc_dropout, train_acc_dropout, _, model_dp = main(args,\n                                                       model,\n                                                       train_loader,\n                                                       val_loader,\n                                                       img_test_dataset)\n\n# intialize the BigAnimalNet model\nset_seed(seed=SEED)\nmodel = BigAnimalNet()\n\n# Train the model\nval_acc_big, train_acc_big, _, model_big = main(args,\n                                                model,\n                                                train_loader,\n                                                val_loader,\n                                                img_test_dataset)\n\n\n# Train and Test accuracy plot\nplt.plot(val_acc_big, label='Val - Big', c='blue', ls='dashed')\nplt.plot(train_acc_big, label='Train - Big', c='blue', ls='solid')\nplt.plot(val_acc_dropout, label='Val - DP', c='magenta', ls='dashed')\nplt.plot(train_acc_dropout, label='Train - DP', c='magenta', ls='solid')\nplt.title('Dropout')\nplt.ylabel('Accuracy (%)')\nplt.xlabel('Epoch')\nplt.legend()\nplt.show()","f96c3b13":"# @title Video 3: Data Augmentation\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1Xw411d7Pz\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"nm44FhjL3xc\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 3: Data Augmentation')\n\ndisplay(out)","a3fb3826":"# @markdown ####  Data Loader without Data Augmentation\n\n# For reproducibility\ng_seed = torch.Generator()\ng_seed.manual_seed(SEED)\n\n\ntrain_transform = transforms.Compose([\n     transforms.ToTensor(),\n     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))\n     ])\ndata_path = pathlib.Path('.')\/'afhq' # using pathlib to be compatible with all OS's\nimg_dataset = ImageFolder(data_path\/'train', transform=train_transform)\n\n# Splitting dataset\nimg_train_data, img_val_data,_ = torch.utils.data.random_split(img_dataset, [250,100,14280])\n\n# Creating train_loader and Val_loader\ntrain_loader = torch.utils.data.DataLoader(img_train_data,\n                                           batch_size=batch_size,\n                                           num_workers=2,\n                                           worker_init_fn=seed_worker,\n                                           generator=g_seed)\nval_loader = torch.utils.data.DataLoader(img_val_data,\n                                         batch_size=1000,\n                                         num_workers=2,\n                                         worker_init_fn=seed_worker,\n                                         generator=g_seed)","80556be8":"# Data Augmentation using transforms\nnew_transforms = transforms.Compose([\n                                     transforms.RandomHorizontalFlip(p=0.1),\n                                     transforms.RandomVerticalFlip(p=0.1),\n                                     transforms.ToTensor(),\n                                     transforms.Normalize((0.5, 0.5, 0.5),\n                                                          (0.5, 0.5, 0.5))\n                                     ])\n\ndata_path = pathlib.Path('.')\/'afhq'  # using pathlib to be compatible with all OS's\nimg_dataset = ImageFolder(data_path\/'train', transform=new_transforms)\n# Splitting dataset\nnew_train_data, _,_ = torch.utils.data.random_split(img_dataset,\n                                                    [250, 100, 14280])\n\n# For reproducibility\ng_seed = torch.Generator()\ng_seed.manual_seed(SEED)\n\n# Creating train_loader and Val_loader\nnew_train_loader = torch.utils.data.DataLoader(new_train_data,\n                                               batch_size=batch_size,\n                                               worker_init_fn=seed_worker,\n                                               generator=g_seed)","82817133":"# Set the arguments\nargs = {\n    'epochs': 250,\n    'lr': 1e-3,\n    'momentum': 0.99,\n    'device': DEVICE,\n}\n\n# Intialize the model\nset_seed(seed=SEED)\nmodel_aug = AnimalNet()\n\n# train the model\nval_acc_dataaug, train_acc_dataaug, param_norm_datadug, _ = main(args,\n                                                                 model_aug,\n                                                                 new_train_loader,\n                                                                 val_loader,\n                                                                 img_test_dataset)\n# Intialize the model\nset_seed(seed=SEED)\nmodel_pure = AnimalNet()\n\nval_acc_pure, train_acc_pure, param_norm_pure, _, = main(args,\n                                                         model_pure,\n                                                         train_loader,\n                                                         val_loader,\n                                                         img_test_dataset)\n\n\n# Train and Test accuracy plot\nplt.figure(figsize=(8, 6))\nplt.plot(val_acc_pure, label='Val Accuracy Pure',\n         c='red', ls='dashed')\nplt.plot(train_acc_pure, label='Train Accuracy Pure',\n         c='red', ls='solid')\nplt.plot(val_acc_dataaug, label='Val Accuracy data augment',\n         c='blue', ls='dashed')\nplt.plot(train_acc_dataaug, label='Train Accuracy data augment',\n         c='blue', ls='solid')\nplt.axhline(y=max(val_acc_pure), c='red', ls='dashed')\nplt.axhline(y=max(val_acc_dataaug), c='blue', ls='dashed')\nplt.title('Data Augmentation')\nplt.ylabel('Accuracy (%)')\nplt.xlabel('Epoch')\nplt.legend()\nplt.show()","30c9cc0d":"# Plot together: without and with augmenetation\nplt.figure(figsize=(8, 6))\nplt.plot(param_norm_pure, c='red', label='Without Augmentation')\nplt.plot(param_norm_datadug, c='blue', label='With Augmentation')\nplt.title('Norm of parameters as a function of training epoch')\nplt.xlabel('epoch')\nplt.ylabel('Norm of model parameters')\nplt.legend()\nplt.show()","805272c1":"# @title Student Response\nfrom ipywidgets import widgets\n\n\ntext=widgets.Textarea(\n   value='Type your answer here and click on `Submit!`',\n   placeholder='Type something',\n   description='',\n   disabled=False\n)\n\nbutton = widgets.Button(description=\"Submit!\")\n\ndisplay(text,button)\n\ndef on_button_clicked(b):\n   atform.add_answer(q1, text.value)\n   print(\"Submission successful!\")\n\n\nbutton.on_click(on_button_clicked)","88575d52":"# @title Video 4: SGD\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1nM4y1K7wP\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"rjzlFvJhNqE\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 4: SGD')\n\ndisplay(out)","acbdb0be":"# @markdown #### Generating Data Loaders\n\n# For reproducibility\ng_seed = torch.Generator()\ng_seed.manual_seed(SEED)\n\nbatch_size = 128\ntrain_transform = transforms.Compose([\n     transforms.ToTensor(),\n     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))\n     ])\n\ndata_path = pathlib.Path('.')\/'afhq' # using pathlib to be compatible with all OS's\nimg_dataset = ImageFolder(data_path\/'train', transform=train_transform)\nimg_train_data, img_val_data, = torch.utils.data.random_split(img_dataset, [11700,2930])\n\nfull_train_loader = torch.utils.data.DataLoader(img_train_data,\n                                                batch_size=batch_size,\n                                                num_workers=2,\n                                                worker_init_fn=seed_worker,\n                                                generator=g_seed)\nfull_val_loader = torch.utils.data.DataLoader(img_val_data,\n                                              batch_size=1000,\n                                              num_workers=2,\n                                              worker_init_fn=seed_worker,\n                                              generator=g_seed)\n\ntest_transform = transforms.Compose([\n     transforms.ToTensor(),\n     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))    # [TO-DO]\n     ])\nimg_test_dataset = ImageFolder(data_path\/'val', transform=test_transform)\n# img_test_loader = DataLoader(img_test_dataset, batch_size=batch_size,shuffle=False, num_workers=1)\nclasses = ('cat', 'dog', 'wild')","8b7ccc14":"# Set the arguments\nargs = {\n    'test_batch_size': 1000,\n    'epochs': 350,\n    'batch_size': 32,\n    'momentum': 0.99,\n    'device': DEVICE\n}\n\nlearning_rates = [5e-4, 1e-3, 5e-3]\nacc_dict = {}\n\nfor i, lr in enumerate(learning_rates):\n    # Initialize the model\n    set_seed(seed=SEED)\n    model = AnimalNet()\n    # Learning rate\n    args['lr'] = lr\n    # Train the model\n    val_acc, train_acc, param_norm, _ = main(args,\n                                             model,\n                                             train_loader,\n                                             val_loader,\n                                             img_test_dataset)\n    # store the outputs\n    acc_dict[f'val_{i}'] = val_acc\n    acc_dict[f'train_{i}'] = train_acc\n    acc_dict[f'param_norm_{i}'] = param_norm","51c10112":"# @markdown #### Plot Train and Validation accuracy (Run me)\nplt.figure(figsize=(8, 6))\nplt.plot(acc_dict['val_0'], linestyle='dashed',\n         label='lr = 5e-4 - validation',\n         c='blue')\nplt.plot(acc_dict['train_0'], label = '5e-4 - train', c='blue')\nplt.plot(acc_dict['val_1'], linestyle='dashed',\n         label='lr = 1e-3 - validation',\n         c='green')\nplt.plot(acc_dict['train_1'], label='1e-3 - train', c='green')\nplt.plot(acc_dict['val_2'], linestyle='dashed',\n         label='lr = 5e-3 - validation',\n         c='purple')\nplt.plot(acc_dict['train_2'],label = '5e-3 - train', c='purple')\nplt.title('Optimal Learning Rate')\nplt.ylabel('Accuracy (%)')\nplt.xlabel('Epoch')\n\nprint(f\"Maximum Test Accuracy obtained with lr = 5e-4: {max(acc_dict['val_0'])}\")\nprint(f\"Maximum Test Accuracy obtained with lr = 1e-3: {max(acc_dict['val_1'])}\")\nprint(f\"Maximum Test Accuracy obtained with lr = 5e-3: {max(acc_dict['val_2'])}\")\nplt.legend()\nplt.show()","2aa5a0da":"# @markdown #### Plot parametric norms (Run me)\nplt.figure(figsize=(8, 6))\nplt.plot(acc_dict['param_norm_0'],label='lr = 5e-4',c='blue')\nplt.plot(acc_dict['param_norm_1'],label = 'lr = 1e-3',c='orange')\nplt.plot(acc_dict['param_norm_2'],label ='lr = 5e-3', c='magenta')\nplt.legend()\nplt.xlabel('epoch')\nplt.ylabel('parameter norms')\nplt.show()","a9377c6a":"# @title Video 5: Hyperparameter tuning\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1E44y127Sn\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"HgkiKRYc-3A\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 5: Hyperparameter tuning')\n\ndisplay(out)","fc07bf40":"# @title Student Response\nfrom ipywidgets import widgets\n\n\ntext=widgets.Textarea(\n   value='Type your answer here and click on `Submit!`',\n   placeholder='Type something',\n   description='',\n   disabled=False\n)\n\nbutton = widgets.Button(description=\"Submit!\")\n\ndisplay(text,button)\n\ndef on_button_clicked(b):\n   atform.add_answer(q2, text.value)\n   print(\"Submission successful!\")\n\n\nbutton.on_click(on_button_clicked)","57de9cb0":"# @title Airtable Submission Link\nfrom IPython import display as IPydisplay\nIPydisplay.HTML(\n   f\"\"\"\n <div>\n   <a href= \"{atform.url()}\" target=\"_blank\">\n   <img src=\"https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/blob\/main\/tutorials\/static\/SurveyButton.png?raw=1\"\n alt=\"button link end of day Survey\" style=\"width:410px\"><\/a>\n   <\/div>\"\"\" )","dfa253f5":"# @title Video 6: Adversarial Attacks\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n    def __init__(self, id, page=1, width=400, height=300, **kwargs):\n      self.id=id\n      src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n      super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV19o4y1X74u\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"LzPPoiKi5jE\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 6: Adversarial Attacks')\n\ndisplay(out)","a9f15962":" #### Plot parametric norms (Run me)\n","7a72aa9b":"Data augmentation is often used to increase the number of training samples. Now we will explore the effects of data augmentation on regularization. Here regularization is achieved by adding noise into training data after every epoch.\n\nPytorch's torchvision module provides a few built-in data augmentation techniques, which we can use on image datasets. Some of the techniques we most frequently use are:\n\n\n*   Random Crop\n*   Random Rotate\n*   Vertical Flip\n*   Horizontal Flip\n\n","278019b4":" #### Plot model weights with epoch\n","a7f1fb94":"What value of Lambda worked for L2 Regularization?","bc299868":"##  Figure Settings\n","a137ff2a":"##  Video 4: SGD\n","b4ac0188":"##  Airtable Submission Link\n","b302bc79":"### Coding Exercise 1.1: L1 Regularization\n\nWrite a function which calculates the L1 norm of all the tensors of a Pytorch model.","b163a849":"What value of $\\lambda$, i.e., `lambda`, worked for L1 Regularization?","3af4affe":"Now let's revisit the toy dataset that we generated above to visualize how the dropout stabilizes training on a noisy dataset. We will slightly modify the architecture we used above to add dropout layers.","df56a440":"---\n# Section 3: Data Augmentation\n\n*Time estimate: ~15 mins*\n","64680495":"---\n# Setup\nNote that some of the code for today can take up to an hour to run. We have therefore \"hidden\" that code and shown the resulting outputs.\n","ee58908a":"L2 Regularization, sometimes referred to as \u201cWeight Decay\u201d, is widely used. It works by adding a quadratic penalty term to the Cross Entropy Loss Function  L, which results in a new Loss Function $L_R$  given by:\n\n\\begin{equation}\nL_R = L + \\lambda \\sum \\left( w^{(r)}_{ij} \\right)^2\n\\end{equation}\n\nIn order to get further insight into L2 Regularization, we investigate its effect on the Gradient Descent based update equations for the weight and bias parameters. Taking the derivative on both sides of the above equation, we obtain\n\n\\begin{equation}\n\\frac{\\partial L_R}{\\partial w^{(r)}_{ij}}=\\frac{\\partial L}{\\partial w^{(r)}_{ij}} + 2\\lambda w^{(r)}_{ij}\n\\end{equation}\n\nThus the weight update rule becomes:\n\n\\begin{equation}\nw^{(r)}_{ij}\u2190w^{(r)}_{ij}\u2212\u03b7\\frac{\\partial L}{\\partial w^{(r)}_{ij}}\u22122 \\eta \\lambda w^{(r)}_{ij}=(1\u22122 \\eta \\lambda)w^{(r)}_{ij} \u2212 \\eta \\frac{\\partial L}{\\partial w^{(r)}_{ij}}\n\\end{equation}\n\nwhere, $\\eta$ is learning rate.","7a5f03a9":" #### Visualize Norm of the Models (Train Me!)\n","cc8ac66a":"##  Plotting functions\n","6f535605":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D5_Regularization\/solutions\/W1D5_Tutorial2_Solution_a308b739.py)\n\n","416339a5":"##  Video 5: Hyperparameter tuning\n","44416171":"---\n# Section 4: Stochastic Gradient Descent\n\n*Time estimate: ~20 mins*","81137ac4":"## Section 2.1: Dropout Implementation Caveats","529275d4":"---\n# Bonus: Adversarial  Attacks\n\n*Time estimate: ~15 mins*","fc8cfc57":"When do you think dropouts can perform bad and do you think their placement within a model matters?","8104c838":" #### Plot Train and Validation accuracy (Run me)\n","f7ef6089":" #### Generating Data Loaders\n","17b1e482":"##  Video 3: Data Augmentation\n","141a3bb1":"\n\nHyper-Parameter tuning is often difficult and time consuming.  It is a key part of training any Deep Learning model to give good generalization. There are a few techniques that we can use to guide us during the search. \n\n\n\n*   Grid Search: Try all possible combinations of hyperparameters\n*   Random Search: Randomly try different combinations of hyperparameters\n*   Coordinate-wise Gradient Descent: Start at one set of hyperparameters and try changing one at a time, accept any changes that reduce your validation error\n*   Bayesian Optimization\/ Auto ML:  Start from a set of hyperparameters that have worked well on a similar problem, and then do some sort of local exploration (e.g., gradient descent) from there.\n\nThere are lots of choices, like what range to explore over, which parameter to optimize first, etc. Some hyperparameters don\u2019t matter much (people use a dropout of either 0.5 or 0, but not much else).  Others can matter a lot more (e.g., size and depth of the neural net). The key is to see what worked on similar problems.\n\nOne can automate the process of tuning the network Architecture using \"Neural Architecture Search\", which designs new architectures using a few building blocks (Linear, Convolutional, Convolution Layers, etc.) and optimizes the design based on performance using a wide range of techniques such as Grid Search, Reinforcement Learning, GD, Evolutionary Algorithms, etc. This obviously requires very high computer power. Read this [article](https:\/\/lilianweng.github.io\/lil-log\/2020\/08\/06\/neural-architecture-search.html) to learn more about NAS.    \n","187b0ac0":"\n*  Dropout is used only during training, during testing the complete model weights are used and hence it is important to use model.eval() before testing the model. \n\n* Dropout reduces the capacity of the model during training and hence as a general practice wider networks are used when using dropout. If you are using a dropout with a random probability of 0.5 then you might want to double the number of hidden neurons in that layer.","d7127ec6":"Now we'll train a classifier which uses L2 regularization. Tune the hyperparameter `lambda` such that the val accuracy is higher than that of the unregularized model.","1d4ce8e3":"##  Install dependencies\n","809bf038":" #### Plot the train and test losses\n","506594eb":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D5_Regularization\/solutions\/W1D5_Tutorial2_Solution_98c16d72.py)\n\n","18926834":"**Our 2021 Sponsors, including Presenting Sponsor Facebook Reality Labs**\n\n<p align='center'><img src='https:\/\/github.com\/NeuromatchAcademy\/widgets\/blob\/master\/sponsors.png?raw=True'\/><\/p>","2f8a5d17":"---\n# Section 2: Dropout\n\n*Time estimate: ~25 mins*\n","f0c1a8cf":"In the above plots, you should have seen that even after the model achieves 100% train accuracy the val accuracies are fluctuating. This suggests that the model is still trying to learn something. Why would this be the case?","5bc87d0d":"##  Loading Animal Faces data\n","cf008277":"```\nRandom seed 2021 has been set.\nL2 norm of the model: 7.328375816345215\n```","96a37438":"Now, let's visualize what these different regularization does to the parameters of the model. We observe the effect by computing the size (technically, the Frobenius norm) of the model parameters","07906b74":"<a href=\"https:\/\/colab.research.google.com\/github\/NeuromatchAcademy\/course-content-dl\/blob\/main\/tutorials\/W1D5_Regularization\/student\/W1D5_Tutorial2.ipynb\" target=\"_blank\"><img alt=\"Open In Colab\" src=\"https:\/\/colab.research.google.com\/assets\/colab-badge.svg\"\/><\/a>","bbc4e2aa":"##  Set device (GPU or CPU). Execute `set_device()`\n","ff6750ed":"###  Student Response\n","58f0c1d4":"---\n# Summary\n\nCongratulations! The first week of NMA-DL has ended! In this tutorial, you learned more techniques of regulariation, i.e., L1 and L2 regularization, Dropout, and Data Augmenetation. Finally, you have seen the learning rate of SGD can act as a reularizer. An iteresting paper can be found [here](https:\/\/arxiv.org\/abs\/1611.03530). \n\nIf you have time left, see the bonus material on *Adversarial Attacks*!","08e2e8f0":"## Section 1.3: L2 \/ Ridge Regularization","027e9e7f":"Now, let's see how dropout fares on the Animal Faces Dataset. We first modify the existing model to include dropout and then train the model.","44c3964e":"## Section 1.2: L1 Regularization","ace84d34":"## Section 1.1: Unregularized Model","2a7ff6dd":"Define a DataLoader using [torchvision.transforms](https:\/\/pytorch.org\/docs\/stable\/torchvision\/transforms.html) which randomly augments the data for us. ","ea91c362":"Do you think this performed better than the initial model?","4ea4a101":"In dropout, we literally drop out (zero out) some neurons during training. Throughout training, on each iteration, standard dropout zeros out some fraction (usually 1\/2) of the nodes in each layer before calculating the subsequent layer. Randomly selecting different subsets to dropout introduces noise into the process and reduces overfitting.\n\n<center><img src=\"https:\/\/d2l.ai\/_images\/dropout2.svg\" alt=\"Dropout\" width=\"600\"\/><\/center>\n","617265aa":"####  Student Response\n","dc941f23":" #### Animation! (Run Me!)\n","e5054d9a":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D5_Regularization\/solutions\/W1D5_Tutorial2_Solution_519e352b.py)\n\n","20dbd972":"Now let's train a model without any regularization and keep it aside as our benchmark for this section.","aecd5d0b":"## Think! 5: Overview of regularization techniques\n\nWhich regularization technique today do you think had the biggest effect on the network? Why might do you think so? Can you apply all of the regularization methods on the same network?","66f120c1":"##  Video 1: L1 and L2 regression\n","242c41b3":"# Tutorial 2: Regularization techniques part 2\n**Week 1, Day 5: Regularization**\n\n**By Neuromatch Academy**\n\n\n__Content creators:__ Ravi Teja Konkimalla, Mohitrajhu Lingan Kumaraian, Kevin Machado Gamboa, Kelson Shilling-Scrivo, Lyle Ungar\n\n__Content reviewers:__ Piyush Chauhan, Siwei Bai, Kelson Shilling-Scrivo\n\n__Content editors:__ Roberto Guidotti, Spiros Chavlis\n\n__Production editors:__ Saeed Salehi, Spiros Chavlis","80710306":"##  Helper functions\n","2ba6970f":"---\n# Section 5: Hyperparameter Tuning\n\n*Time estimate: ~5 mins*\n","2ecd6609":"## Section 4.1: Learning Rate\nIn this section, we will see how learning rate can act as regularizer while training a neural network. In summary:\n\n\n*   Smaller learning rates regularize less. They slowly converge to deep minima. \n*   Larger learning rates regularizes more by missing local minima and converging to broader, flatter minima, which often generalize better.\n\nBut beware, a very large learning rate may result in overshooting or finding a really bad local minimum.\n\n\n\nIn the block below, we will train the Animal Net model with different learning rates and see how that affects the regularization.","cf80e239":"---\n# Tutorial Objectives\n\n1.   Regularization as shrinkage of overparameterized models: L1, L2\n2.   Regularization by Dropout\n3.   Regularization by Data Augmentation\n4.   Perils of Hyper-Parameter Tuning\n5.   Rethinking generalization","ba7fef33":"##  Loading Animal Faces Randomized data\n","5815d2ff":"Now that we have finished training, let's see how the model has evolved over the training process.","d1635067":" #### Run to train the default network\n","b3e79ca2":"Some of you might have already come across L1 and L2 regularization before in other courses. L1 and L2 are the most common types of regularization. These update the general cost function by adding another term known as the regularization term.\n\n***Cost function = Loss (say, binary cross entropy) + Regularization term***\n\nThis regularization term makes the parameters smaller, giving simpler models that will overfit less.","6b845081":"##  Video 6: Adversarial Attacks\n","cc8d36f1":" #### Plot the train and test losses\n","a29aa619":" #### Visualize all of them together (Run Me!)\n","6dbdf704":"L1 (or \"LASSO\") Regularization uses a penalty which is the sum of the absolute value of all the weights in the DLN, resulting in the following loss function (L  is the usual Cross Entropy loss):\n\n\\begin{equation}\nL_R=L + \\lambda \\sum \\left| w^{(r)}_{ij} \\right|\n\\end{equation}\n\nAt a high level, L1 Regularization is similar to L2 Regularization since it leads to smaller weights. (You will see the analogy in the next subsection.) It results in the following weight update equation when using Stochastic Gradient Descent:\n\n\\begin{equation}\nw^{(r)}_{ij}\u2190w^{(r)}_{ij}\u2212\\eta \\lambda \\text{sgn}\\left(w^{(r)}_{ij}\\right)\u2212\\eta \\frac{\\partial L}{\\partial w_{ij}^{r}} \n\\end{equation}\n\nwhere  $\\text{sgn}(\\cdot)$ is the sign function, such that\n\n\\begin{equation}\n\\text{sgn(w)} = \n\\left\\{\n  \\begin{array}{ll}\n  +1 & \\mbox{if  } w > 0 \\\\\n  -1 & \\mbox{if  } w < 0 \\\\\n  0 & \\mbox{if  } w = 0\n  \\end{array}\n\\right.\n\\end{equation}","f54cdae0":"In the model above, we observe something different from what we expected. Why do you think this is happening?","fc93b0d1":"Now, let's train a classifier which uses L1 regularization. Tune the hyperparameter `lambda` such that the validation accuracy is higher than that of the unregularized model.","93bf5650":"Discuss among your teammates whether the above assumption is good or bad?","d5944c58":" ####  Data Loader without Data Augmentation\n","94859db3":"##  Video 2: Dropout\n","37e34e85":"---\n# Section 1: L1 and L2 Regularization\n\n*Time estimate: ~30 mins*\n","781edfed":"```\nRandom seed 2021 has been set.\nL1 norm of the model: 48.445133209228516\n```","0f174037":"### Think! 3.1: Thought Question\nWhy does it work better to regularize an overparameterized ANN than to start with a smaller one? Think about  the regularization  methods you know.\nEach group has a 10 min discussion.","be81c8eb":" #### Dataloaders for Regularization\n","8654fe76":" Executing `set_seed(seed=seed)` you are setting the seed\n","8f22b410":"##  Set random seed\n","2c322990":"Designing perturbations to the input data to trick a machine learning model is called an \"adversarial attack\". These attacks are an inevitable consequence of learning in high dimensional space with complex decision boundaries. Depending on the application, these attacks can be very dangerous.\n\n\n<img src=\"https:\/\/raw.githubusercontent.com\/NeuromatchAcademy\/course-content-dl\/main\/tutorials\/static\/AdversarialAttacks_w1d5t2.png\">\n\nHence, it is important for us to build models which can defend against such attacks. One possible way to do it is by regularizing the networks, which smooths the decision boundaries. A few ways of building models robust to such attacks are:\n\n\n\n*   [Defensive Distillation](https:\/\/deepai.org\/machine-learning-glossary-and-terms\/defensive-distillation) : Models trained via distillation are less prone to such attacks as they are trained on soft labels as there is an element of randomness in the training process.\n*   [Feature Squeezing](https:\/\/evademl.org\/squeezing\/): Identifies adversarial attacks for on-line classifiers whose model is being used by comparing model's perdiction before and after squeezing the input. \n* [SGD](https:\/\/arxiv.org\/abs\/1706.06083) You can also pick weight to minimize what the adversary is trying to maximize via SGD.\n\n\nRead more about adversarial attacks [here](https:\/\/openai.com\/blog\/adversarial-example-research\/)\n","2959ffa6":"### Coding Exercise 1.2: L2 Regularization\n\nWrite a function which calculates the L2 norm of all the tensors of a Pytorch model. (What did we call this before?)","db67d150":"Can you think of more ways of augmenting training data? (Think of other problems beyond object recogition.)","36ddd348":"##  Dataloaders for the Dataset\n","62c70fbf":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D5_Regularization\/solutions\/W1D5_Tutorial2_Solution_726ea359.py)\n\n"}}