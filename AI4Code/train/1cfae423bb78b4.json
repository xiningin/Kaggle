{"cell_type":{"e9bf8af1":"code","4bb65aa9":"code","1d88ea63":"code","a0aff51d":"code","ee6a1e52":"code","1b18eba3":"code","5a9966e3":"code","af2f021d":"code","b3f0ba02":"code","06dd1f2a":"code","3c6e619a":"code","fcad001c":"code","3e82e4ff":"code","7fcce239":"code","5f4f5351":"code","002b2745":"code","9995f04d":"code","4e348b7d":"code","f5f46b5a":"code","4765fcd1":"code","7c08f2f9":"code","83c6ed3d":"code","a92c38ba":"code","5e0034b7":"code","2e412cf7":"code","06106ed2":"code","e9bba7e1":"code","7e2f8557":"code","88d90302":"code","d847ac52":"markdown","437c3f44":"markdown","7f49eca9":"markdown","c5f54029":"markdown","6a43fc88":"markdown","0dfda335":"markdown","95ba364d":"markdown","287610b3":"markdown","4cabb1ee":"markdown","214f437e":"markdown","89735781":"markdown","ccd195b2":"markdown"},"source":{"e9bf8af1":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline","4bb65aa9":"apps = pd.read_csv('..\/input\/google-play-store-apps\/googleplaystore.csv')","1d88ea63":"sns.set_style('whitegrid')","a0aff51d":"# Values in row 10472 are displaced. Fixing that\nfor i in range(11, 0, -1):\n    apps.iloc[10472,i+1] = apps.iloc[10472,i]\n\napps.loc[10472,'Category'] = 'PHOTOGRAPHY'\napps.loc[10472,'Genres'] = 'Photography'","ee6a1e52":"# Removing redundant duplicated rows\napps.drop_duplicates(inplace = True)","1b18eba3":"# Changing types of columns.\napps['Reviews'] = apps['Reviews'].astype('int')\napps['Rating'] = apps['Rating'].astype('float')\napps['Price'] = apps['Price'].str.replace('$', '').astype('float')\napps['Installs'] = apps['Installs'].str.replace(',', '').str.replace('+', '').astype('int')\napps['Size'] = apps['Size'].str.replace('M', 'e+6').str.replace('k', 'e+3').str.replace('Varies with device', '0').astype('float')\napps['Last Updated'] = pd.to_datetime(apps['Last Updated'])\napps['Category'] = apps['Category'].astype('category')\n# Filling missing values and changing column type\napps['Type'] = apps['Type'].fillna('Free').str.replace('Free', '0').str.replace('Paid', '1').astype('category')\n","5a9966e3":"# Filing missing values in Size column with mean sizes in every category \nfor i, row in apps[apps['Size'] == 0].iterrows():\n    apps.loc[i, 'Size'] = apps.groupby(['Category'])['Size'].mean()[row['Category']]","af2f021d":"# Dividing genres in 2 seprate columns within specific positions\napps.insert(10, 'Genre 1', apps['Genres'].apply(lambda genre: genre.split(';')[0]))\napps.insert(11, 'Genre 2', apps['Genres'].apply(lambda genre: genre.split(';')[1] if len(genre.split(';')) > 1 else np.nan))\napps['Genre 2'].fillna('Not specified', inplace = True)\n# Removing original Genres column and saving it in a separate variable\nGenres = apps.pop('Genres')","b3f0ba02":"# Filling missing values in versions columns\napps['Current Ver'].fillna('Varies with device', inplace = True)\napps['Android Ver'].fillna('Varies with device', inplace = True)\n\n# Implementing a replacement for Android versions due to year of last update\nfor i, row in apps[apps['Android Ver'] == 'Varies with device'].iterrows():\n    apps.loc[i, 'Android Ver'] = apps.groupby(apps['Last Updated'].dt.year)['Android Ver'].value_counts()[row['Last Updated'].year].idxmax()\n\n# Replacing Wearable version with general one\napps['Android Ver'] = apps['Android Ver'].str.replace('4.4W and up', '4.4 and up')\n\n# Creating new column with only lower versioning limitation\napps['Min Android Ver'] = apps['Android Ver'].apply(lambda ver: ver.split(' ')[0])\n\n# Removing original Android ver column and saving it in a separate variable\nAndroid_Ver = apps.pop('Android Ver')","06dd1f2a":"apps.head()","3c6e619a":"apps.info()","fcad001c":"apps.describe()","3e82e4ff":"apps.corr()","7fcce239":"sns.distplot(apps['Rating'], bins = 15)","5f4f5351":"sns.countplot(apps['Type'])","002b2745":"plt.figure(figsize = (12,6))\nsns.countplot(apps['Content Rating'])","9995f04d":"# Category with the biggest number of applications offered\napps.groupby(['Category'])['App'].count().sort_values().tail(1)","4e348b7d":"plt.figure(figsize = (12,6))\nbar = sns.barplot(apps.groupby(['Category'])['App'].count().index, apps.groupby(['Category'])['App'].count().values)\nbar.set_xticklabels(bar.get_xticklabels(), rotation=90)\nbar.set_title('Amount of applications per category', size = 20)\nbar.set_xlabel('Categories')\nbar.set_ylabel('Number of games')","f5f46b5a":"# Category with the biggest number of installs\napps.groupby(['Category'])['Installs'].sum().sort_values().tail(1)","4765fcd1":"apps.groupby(['Category'])['Installs'].sum()\/1000000","7c08f2f9":"plt.figure(figsize = (12,6))\nbar = sns.barplot((apps.groupby(['Category'])['Installs'].sum()\/1000000000).index, (apps.groupby(['Category'])['Installs'].sum()\/1000000000).values)\nbar.set_xticklabels(bar.get_xticklabels(), rotation=90)\nbar.set_title('Number of installs per category', size = 20)\nbar.set_xlabel('Categories')\nbar.set_ylabel('Number of installs (in Billions)')","83c6ed3d":"# Looking for biggest size value\napps['Size'].max()","a92c38ba":"sns.distplot(apps['Size'], bins = 30)","5e0034b7":"# Looking for corresponding apps\napps[apps['Size'] == apps['Size'].max()]","2e412cf7":"# Setting reference date\nref = apps['Last Updated'].max()\nref","06106ed2":"# Calculating differences between reference date and update dates\napps['Last Updated'].apply(lambda date: ref - date).sort_values(ascending = False)","e9bba7e1":"# Application that hasn't been updated for 3001 days\napps.loc[7479]","7e2f8557":"# Looking for applications with biggest number of installs\napps[apps['Installs'] == apps['Installs'].max()]","88d90302":"# Looking for applications with biggest number of reviews\napps[apps['Reviews'] == apps['Reviews'].max()]","d847ac52":"# Data preparation","437c3f44":"Thank you for your reading.","7f49eca9":"# Purpose\n\nMy main goals in this notebook will be to run EDA and to find:\n1. Most popular category\n2. Application with largest size\n3. Application that hasn't been updated for a while\n4. Application that has the biggest number of installs\n5. Application that was reviewed the most often","c5f54029":"So far we can notice that:\n- mean Rating is 4.19 and median is 4.3, which means that this distribution is left skewed. Most probably people rate those apps, that they like. It this case we will find, that there are more positive feedbacks in reviews dataset. If people don't like the app, maybe they just delete it without leaving rating. \n- the opposite picture is about number of reviews - here distribution has positive skew, which is logical, as most apps have not so many feedbacks. We can also notice correlation between reviews and number of installs, which means that the more popular is app, the more reviews it has. \n- mostly apps are over 1M size.\n- installations are very widely distributed.\n- percentile values for Price variable show that biggest part of apps are free.\n\nLet's create some visuals.","6a43fc88":"# EDA","0dfda335":"# 2. Application with largest size","95ba364d":"# 1. Most popular category","287610b3":"# 4. Application that has the biggest number of installs","4cabb1ee":"# 3. Application that hasn't been updated for a while\n","214f437e":"There are two way to define popular category:\n- popular category is the one, where number of applications is the biggest one. Here I'll count number of applications offered in each category.\n- popular category is the one, where people download appd the most often. In this case I'll use number of install to find out, which app is the most popular one. ","89735781":"# 5. Application that was reviewed the most often","ccd195b2":"Data preparation is done here with minium comments, as everything was described in a separate [notebook](https:\/\/www.kaggle.com\/juliakhokhanovska\/google-play-store-apps-data-cleaning). Please review it, if you have any questions."}}