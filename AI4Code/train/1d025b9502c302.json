{"cell_type":{"36e86239":"code","4b060faf":"code","d17e33f1":"code","8c70a8aa":"code","5afc1f08":"code","a8733b64":"code","bd511996":"code","d7bba10b":"code","70603dd2":"code","288aa3bb":"code","05f7be3c":"code","e9acccf9":"code","a14b9f9a":"markdown"},"source":{"36e86239":"%matplotlib inline\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\nfrom keras import models, layers\nfrom keras.utils import to_categorical\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom sklearn.model_selection import train_test_split\nfrom pathlib import Path\nfrom sklearn.metrics import classification_report, confusion_matrix\n\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = 'all'","4b060faf":"#get data and import it using pathlib\nroot_path = Path(\"..\/input\/a-large-scale-fish-dataset\/Fish_Dataset\")\nsub_paths = root_path.glob(r'**\/*.png')\n#converting to list, will deal with generator later\nsub_paths = list(sub_paths)\n\n#creating temporary list to handle generator\ndata = []\nfor i in range(len(sub_paths)):\n    #get the 2nd from last directory name\n    label = os.path.split(os.path.split(sub_paths[i])[0])[1]\n    data.append([str(sub_paths[i]), label])\n    \n#Appending data to dataframe\ndf = pd.DataFrame(data, columns=['path', 'label'])\n#Removing ground truths \ndf = df[df['label'].apply(lambda x: x[-2:] != 'GT')].reset_index(drop=True)","d17e33f1":"pd.set_option('display.max_colwidth', None)\ndf.head(5)","8c70a8aa":"#plot the first 16 images to verify correctness\nfig, axes = plt.subplots(nrows=4, ncols=4, figsize=(12, 12))\nfor index, ax in enumerate(axes.flat):\n    #supress output that isn't related to images by using _\n    _ = ax.imshow(plt.imread(df.path[index]))\n    _ = ax.set_title(df.label[index])","5afc1f08":"#Verify the correct amount of values exist\ndf.describe()\ndf.isnull().any()\ndf['label'].value_counts()","a8733b64":"#Splitting into training, validation, and testing data\ntrain_df, test_df = train_test_split(df, test_size=0.2, random_state=2, shuffle=True)\ntrain_df.count()\ntest_df.count()","bd511996":"#Importing images using image data preprocessing provided from keras\ntrain_generator = ImageDataGenerator(validation_split=0.2)\ntest_generator = ImageDataGenerator()\n\ntrain_imgs = train_generator.flow_from_dataframe(\n    dataframe = train_df,\n    x_col = \"path\",\n    y_col = \"label\",\n    target_size = (224, 224),\n    color_mode = \"rgb\",\n    class_mode = \"categorical\",\n    batch_size = 32,\n    shuffle = True,\n    subset = \"training\"\n)\n\nval_imgs = train_generator.flow_from_dataframe(\n    dataframe = train_df,\n    x_col = \"path\",\n    y_col = \"label\",\n    target_size = (224, 224),\n    color_mode = \"rgb\",\n    class_mode = \"categorical\",\n    batch_size = 32,\n    shuffle = True,\n    subset = \"validation\"\n)\n\ntest_imgs = test_generator.flow_from_dataframe(\n    dataframe = test_df,\n    x_col = \"path\",\n    y_col = \"label\",\n    target_size = (224, 224),\n    color_mode = \"rgb\",\n    class_mode = \"categorical\",\n    batch_size = 32,\n    shuffle = False\n)","d7bba10b":"#setup model\nmodel = models.Sequential()\n\nmodel.add(layers.Conv2D(32, (3,3), padding=\"Same\", activation=\"relu\", input_shape=(224, 224, 3)))\nmodel.add(layers.MaxPooling2D((2, 2)))\nmodel.add(layers.Conv2D(64, (3, 3), padding=\"Same\", activation='relu'))\nmodel.add(layers.MaxPooling2D((2, 2)))\nmodel.add(layers.Conv2D(64, (3, 3), padding=\"Same\", activation='relu'))\nmodel.add(layers.MaxPooling2D((2, 2)))\nmodel.add(layers.Conv2D(128, (3, 3), padding=\"Same\", activation='relu'))\n\nmodel.add(layers.Flatten())\nmodel.add(layers.Dense(64, activation='relu'))\nmodel.add(layers.Dropout(0.2))\nmodel.add(layers.Dense(9, activation='softmax'))\n\nmodel.compile(\n    optimizer='rmsprop',\n    loss='categorical_crossentropy',\n    metrics=['accuracy']\n)\n\nmodel.summary()\n\n#flattening and softmax to show probability for each class","70603dd2":"#train model\neps = 6\nhistory = model.fit(train_imgs, epochs=eps, batch_size=32, validation_data=val_imgs)","288aa3bb":"#plot graphs to check model efficacy\nhistory_dic = history.history\ntrain_acc = history_dic['accuracy']\ntrain_loss = history_dic['loss']\nval_acc = history_dic['val_accuracy']\nval_loss = history_dic['val_loss']\nepochs = range(1, len(train_acc) + 1)\n\nfigure, axis = plt.subplots(1, 2, figsize=(20, 10))\naxis[0].plot(epochs, train_acc, label=\"train\")\naxis[0].plot(epochs, val_acc, label=\"val\")\naxis[0].set_title('Accuracy')\naxis[0].legend()\naxis[1].plot(epochs, train_loss, label=\"train\")\naxis[1].plot(epochs, val_loss, label=\"val\")\naxis[1].set_title('Loss')\naxis[1].legend()\n\nplt.show(); #suppressing output ","05f7be3c":"#check predictions on test set\npred = model.predict(test_imgs)","e9acccf9":"#output index\noutput = np.argmax(pred, axis=1)\nlabels = test_imgs.class_indices\n\nlabeled_pred = []\n#reverse dictionary\npred_labels = dict((v, k) for k, v in labels.items())\n#assign labels based on index\nfor i in range(0, len(output)):\n    labeled_pred.append(pred_labels[output[i]])\n\n#print classification report and confusion matrix\nprint(classification_report(test_df.label, labeled_pred))\nprint(confusion_matrix(test_df.label, labeled_pred))","a14b9f9a":"This notebook contains a Keras based CNN aimed at classifying the different fish categories"}}