{"cell_type":{"e2f4a357":"code","40fe2110":"code","dea84cc4":"code","2fc66226":"code","8e4cfc0d":"code","0bec591c":"code","b6c51d8c":"code","f75ed556":"code","74c95617":"code","96a09402":"code","b28b99a2":"code","c9109c0d":"code","7e8a99cc":"markdown","a2a8dd36":"markdown","7552d2f3":"markdown","9e4b1f4d":"markdown","b2bd23ee":"markdown","eaa5960d":"markdown","3ba3b194":"markdown","239286eb":"markdown","c960d331":"markdown","410d2cb5":"markdown","86d1ea00":"markdown","84b29751":"markdown"},"source":{"e2f4a357":"# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session\n\n# To create temporary directory, type in following in the Console\n# os.chdir(\"\/kaggle\/\")\n# !mkdir temp\n# os.listdir()\n\n# Any results we write to the current directory are saved as output in '\/kaggle\/working\/' directory\nprint()\nprint(os.listdir('..'))\nprint(os.listdir('\/kaggle\/input'))\nprint(os.listdir('\/kaggle\/working\/'))\n# print(os.listdir('\/kaggle\/temp\/'))\n","40fe2110":"# Importing needed libraries\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport h5py\nimport cv2\n","dea84cc4":"# Opening dataset from HDF5 binary file\n# Initiating File object\n# Opening file in reading mode by 'r'\nwith h5py.File('\/kaggle\/input\/traffic-signs-1-million-images-for-classification\/dataset_ts_original.hdf5', 'r') as f:\n    # Showing all keys in the HDF5 binary file\n    print(list(f.keys()))\n    \n    # Extracting saved arrays for training by appropriate keys\n    # Saving them into new variables    \n    x_train = f['x_train']  # HDF5 dataset\n    y_train = f['y_train']  # HDF5 dataset\n    # Converting them into Numpy arrays\n    x_train = np.array(x_train)  # Numpy arrays\n    y_train = np.array(y_train)  # Numpy arrays\n    \n    \n    # Extracting saved arrays for validation by appropriate keys\n    # Saving them into new variables \n    x_validation = f['x_validation']  # HDF5 dataset\n    y_validation = f['y_validation']  # HDF5 dataset\n    # Converting them into Numpy arrays\n    x_validation = np.array(x_validation)  # Numpy arrays\n    y_validation = np.array(y_validation)  # Numpy arrays\n    \n    \n    # Extracting saved arrays for testing by appropriate keys\n    # Saving them into new variables \n    x_test = f['x_test']  # HDF5 dataset\n    y_test = f['y_test']  # HDF5 dataset\n    # Converting them into Numpy arrays\n    x_test = np.array(x_test)  # Numpy arrays\n    y_test = np.array(y_test)  # Numpy arrays\n\n    \n# Check point\n# Showing shapes of arrays after splitting\nprint(x_train.shape)\nprint(y_train.shape)\n\nprint(x_validation.shape)\nprint(y_validation.shape)\n\nprint(x_test.shape)\nprint(y_test.shape)\n","2fc66226":"# Concatenating arrays vertically\nx_train = np.concatenate((x_train, x_validation, x_test), axis=0)\ny_train = np.concatenate((y_train, y_validation, y_test), axis=0)\n\n\n# Check point\n# Showing shapes of concatenated arrays\nprint(x_train.shape)\nprint(y_train.shape)\n","8e4cfc0d":"# Plotting histogram to show distribution of images among classes\n\n\n# Magic function that renders the figure in a jupyter notebook\n# instead of displaying a figure object\n%matplotlib inline\n\n\n# Setting default size of the plot\nplt.rcParams['figure.figsize'] = (10.0, 7.0)\nplt.rcParams['font.family'] = 'Times New Roman'\n\n\n# Calculating number of images for every class\n# Iterating all classes' indexes in 'y_train' array\n# Using Numpy function 'unique'\n# Returning sorted unique elements and their frequencies\nclassesIndexes, classesFrequency = np.unique(y_train, return_counts=True)\n\n\n# Printing frequency (number of images) for every class\nprint('classes indexes:' , classesIndexes)\nprint()\nprint('classes frequency:', classesFrequency)\n\n\n# Plotting histogram of 43 classes with their number of images\n# Defining a figure object \nfigure = plt.figure()\n\n\n# Plotting Bar chart\nplt.bar(classesIndexes, classesFrequency, align='center', alpha=0.6)\n\n\n# Giving names to axes\nplt.ylabel('Frequency', fontsize=18)\nplt.xlabel('Class', fontsize=18)\n\n\n# Giving names to every Bar along X axis\nplt.xticks(classesIndexes, fontsize=11)\n\n\n# Giving name to the plot\nplt.title('Histogram of Original Version for Traffic Signs Dataset', fontsize=18)\n\n\n# Saving the plot\nfigure.savefig('histogram_ts_original.png', dpi=500)\n\n\n# Showing the plot\nplt.show()\n","0bec591c":"# Opening dataset from HDF5 binary file\n# Initiating File object\n# Opening file in reading mode by 'r'\nwith h5py.File('\/kaggle\/input\/traffic-signs-1-million-images-for-classification\/dataset_ts_light_version.hdf5', 'r') as f:\n    # Showing all keys in the HDF5 binary file\n    print(list(f.keys()))\n    \n    # Extracting saved arrays for training by appropriate keys\n    # Saving them into new variables    \n    x_train = f['x_train']  # HDF5 dataset\n    y_train = f['y_train']  # HDF5 dataset\n    # Converting them into Numpy arrays\n    x_train = np.array(x_train)  # Numpy arrays\n    y_train = np.array(y_train)  # Numpy arrays\n    \n    \n    # Extracting saved arrays for validation by appropriate keys\n    # Saving them into new variables \n    x_validation = f['x_validation']  # HDF5 dataset\n    y_validation = f['y_validation']  # HDF5 dataset\n    # Converting them into Numpy arrays\n    x_validation = np.array(x_validation)  # Numpy arrays\n    y_validation = np.array(y_validation)  # Numpy arrays\n    \n    \n    # Extracting saved arrays for testing by appropriate keys\n    # Saving them into new variables \n    x_test = f['x_test']  # HDF5 dataset\n    y_test = f['y_test']  # HDF5 dataset\n    # Converting them into Numpy arrays\n    x_test = np.array(x_test)  # Numpy arrays\n    y_test = np.array(y_test)  # Numpy arrays\n\n    \n# Check point\n# Showing shapes of arrays after splitting\nprint(x_train.shape)\nprint(y_train.shape)\n\nprint(x_validation.shape)\nprint(y_validation.shape)\n\nprint(x_test.shape)\nprint(y_test.shape)\n","b6c51d8c":"# Concatenating arrays vertically\nx_train = np.concatenate((x_train, x_validation, x_test), axis=0)\ny_train = np.concatenate((y_train, y_validation, y_test), axis=0)\n\n\n# Check point\n# Showing shapes of concatenated arrays\nprint(x_train.shape)\nprint(y_train.shape)\n","f75ed556":"# Plotting histogram to show distribution of images among classes\n\n\n# Magic function that renders the figure in a jupyter notebook\n# instead of displaying a figure object\n%matplotlib inline\n\n\n# Setting default size of the plot\nplt.rcParams['figure.figsize'] = (10.0, 7.0)\nplt.rcParams['font.family'] = 'Times New Roman'\n\n\n# Calculating number of images for every class\n# Iterating all classes' indexes in 'y_train' array\n# Using Numpy function 'unique'\n# Returning sorted unique elements and their frequencies\nclassesIndexes, classesFrequency = np.unique(y_train, return_counts=True)\n\n\n# Printing frequency (number of images) for every class\nprint('classes indexes:' , classesIndexes)\nprint()\nprint('classes frequency:', classesFrequency)\n\n\n# Plotting histogram of 43 classes with their number of images\n# Defining a figure object \nfigure = plt.figure()\n\n\n# Plotting Bar chart\nplt.bar(classesIndexes, classesFrequency, align='center', alpha=0.6)\n\n\n# Giving names to axes\nplt.ylabel('Frequency', fontsize=18)\nplt.xlabel('Class', fontsize=18)\n\n\n# Giving names to every Bar along X axis\nplt.xticks(classesIndexes, fontsize=11)\n\n\n# Giving name to the plot\nplt.title('Histogram of Light Version for Traffic Signs Dataset', fontsize=18)\n\n\n# Saving the plot\nfigure.savefig('histogram_ts_light_version.png', dpi=500)\n\n\n# Showing the plot\nplt.show()\n","74c95617":"# # Opening dataset from HDF5 binary file\n# # Initiating File object\n# # Opening file in reading mode by 'r'\n# with h5py.File('\/kaggle\/input\/traffic-signs-1-million-images-for-classification\/dataset_ts_hard_version.hdf5', 'r') as f:\n#     # Showing all keys in the HDF5 binary file\n#     print(list(f.keys()))\n    \n#     # Extracting saved arrays for training by appropriate keys\n#     # Saving them into new variables    \n#     x_train = f['x_train']  # HDF5 dataset\n#     y_train = f['y_train']  # HDF5 dataset\n#     # Converting them into Numpy arrays\n#     x_train = np.array(x_train)  # Numpy arrays\n#     y_train = np.array(y_train)  # Numpy arrays\n    \n    \n#     # Extracting saved arrays for validation by appropriate keys\n#     # Saving them into new variables \n#     x_validation = f['x_validation']  # HDF5 dataset\n#     y_validation = f['y_validation']  # HDF5 dataset\n#     # Converting them into Numpy arrays\n#     x_validation = np.array(x_validation)  # Numpy arrays\n#     y_validation = np.array(y_validation)  # Numpy arrays\n    \n    \n#     # Extracting saved arrays for testing by appropriate keys\n#     # Saving them into new variables \n#     x_test = f['x_test']  # HDF5 dataset\n#     y_test = f['y_test']  # HDF5 dataset\n#     # Converting them into Numpy arrays\n#     x_test = np.array(x_test)  # Numpy arrays\n#     y_test = np.array(y_test)  # Numpy arrays\n\n    \n# # Check point\n# # Showing shapes of arrays after splitting\n# print(x_train.shape)\n# print(y_train.shape)\n\n# print(x_validation.shape)\n# print(y_validation.shape)\n\n# print(x_test.shape)\n# print(y_test.shape)\n","96a09402":"# # Concatenating arrays vertically\n# x_train = np.concatenate((x_train, x_validation, x_test), axis=0)\n# y_train = np.concatenate((y_train, y_validation, y_test), axis=0)\n\n\n# # Check point\n# # Showing shapes of concatenated arrays\n# print(x_train.shape)\n# print(y_train.shape)\n","b28b99a2":"# # Plotting histogram to show distribution of images among classes\n\n\n# # Magic function that renders the figure in a jupyter notebook\n# # instead of displaying a figure object\n# %matplotlib inline\n\n\n# # Setting default size of the plot\n# plt.rcParams['figure.figsize'] = (10.0, 7.0)\n# plt.rcParams['font.family'] = 'Times New Roman'\n\n\n# # Calculating number of images for every class\n# # Iterating all classes' indexes in 'y_train' array\n# # Using Numpy function 'unique'\n# # Returning sorted unique elements and their frequencies\n# classesIndexes, classesFrequency = np.unique(y_train, return_counts=True)\n\n\n# # Printing frequency (number of images) for every class\n# print('classes indexes:' , classesIndexes)\n# print()\n# print('classes frequency:', classesFrequency)\n\n\n# # Plotting histogram of 43 classes with their number of images\n# # Defining a figure object \n# figure = plt.figure()\n\n\n# # Plotting Bar chart\n# plt.bar(classesIndexes, classesFrequency, align='center', alpha=0.6)\n\n\n# # Giving names to axes\n# plt.ylabel('Frequency', fontsize=18)\n# plt.xlabel('Class', fontsize=18)\n\n\n# # Giving names to every Bar along X axis\n# plt.xticks(classesIndexes, fontsize=11)\n\n\n# # Giving name to the plot\n# plt.title('Histogram of Hard Version for Traffic Signs Dataset', fontsize=18)\n\n\n# # Saving the plot\n# figure.savefig('histogram_ts_hard_version.png', dpi=500)\n\n\n# # Showing the plot\n# plt.show()\n","c9109c0d":"# Magic function that renders the figure in a jupyter notebook\n# instead of displaying a figure object\n%matplotlib inline\n\n\n# Setting default size of the plot\nplt.rcParams['figure.figsize'] = (10.0, 60.0)\nplt.rcParams['font.family'] = 'Times New Roman'\n\n\n# Defining a figure object with number of needed subplots\n# ax is a (25, 4) numpy array\n# To access specific subplot we call it by ax[0, 0]\nfigure, ax = plt.subplots(nrows=25, ncols=4)\n\n\n# Plotting 100 examples along 25 rows and 4 columns\nfor i in range(25):\n    for j in range(4):\n        # Preparing random index\n        ii = np.random.randint(low=0, high=x_train.shape[0])\n        \n        # Plotting current subplot\n        ax[i, j].imshow(x_train[ii].astype('uint8'))\n        \n        # Giving name to current subplot\n        # according to class's name in list 'labels'\n        ax[i, j].set_title('Class ' + str(y_train[ii]), fontsize=16)\n        \n        # Hiding axis\n        ax[i, j].axis('off')\n\n\n# Adjusting distance between subplots\nplt.tight_layout()\n\n\n# Saving the plot\nfigure.savefig('plot_100_ts_images.png', dpi=500)\n\n\n# Showing the plot\nplt.show()\n","7e8a99cc":"# \ud83d\udcc2 Reading Hard Version of Traffic Signs dataset\n## \u2757 To open hard version, it is needed more memory","a2a8dd36":"* Histogram of **Original** Version\n* Histogram of **Light** Version\n* Histogram of **Hard** Version","7552d2f3":"# \ud83c\udf93 Related course for classification tasks","9e4b1f4d":"# \u26d4\ufe0f Verification of Traffic Signs Dataset","b2bd23ee":"# \ud83d\udcc2 Reading Original Version of Traffic Signs dataset","eaa5960d":"**Design**, **Train** & **Test** deep CNN for Image Classification.\n\n**Join** the course & enjoy new opportunities to get deep learning skills:\n\n\n[https:\/\/www.udemy.com\/course\/convolutional-neural-networks-for-image-classification\/](https:\/\/www.udemy.com\/course\/convolutional-neural-networks-for-image-classification\/?referralCode=12EE0D74A405BF4DDE9B)\n\n\n![](https:\/\/github.com\/sichkar-valentyn\/1-million-images-for-Traffic-Signs-Classification-tasks\/blob\/main\/images\/slideshow_classification.gif?raw=true)","3ba3b194":"# \ud83d\udce5 Importing needed libraries","239286eb":"# \ud83d\udcca Histogram of Light Version","c960d331":"# \ud83d\uddbc\ufe0f 100 random examples from Traffic Signs dataset","410d2cb5":"# \ud83d\udcca Histogram of Hard Version\n## \u2757 To open hard version, it is needed more memory","86d1ea00":"# \ud83d\udcca Histogram of Original Version","84b29751":"# \ud83d\udcc2 Reading Light Version of Traffic Signs dataset"}}