{"cell_type":{"5b40cd3a":"code","f967a677":"code","d4370fdf":"code","8f8fa5a0":"code","16be1abb":"code","306296ad":"code","a041eebf":"markdown","a0fbb6ad":"markdown","3b39cfec":"markdown","3df6d824":"markdown","2528a868":"markdown"},"source":{"5b40cd3a":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport torch\nimport torch.nn.functional as F\nimport torchvision.models\nfrom torch import nn\nimport logging\nfrom tqdm import tqdm\nfrom torch.utils.data import Dataset, DataLoader\nfrom PIL import Image\nfrom typing import Any, Callable, Dict, List, Optional, Tuple\nimport os\nfrom torchvision import transforms","f967a677":"# Setup logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(level=logging.DEBUG)\nformatter = logging.Formatter('%(asctime)s - %(levelname)s  - %(message)s',\n                    datefmt='%m\/%d %H:%M:%S')\n\nfile_handler = logging.FileHandler('test.log',mode='a')\nfile_handler.setLevel(level=logging.INFO)\nfile_handler.setFormatter(formatter)\n\nstream_handler = logging.StreamHandler()\nstream_handler.setLevel(logging.INFO)\nstream_handler.setFormatter(formatter)\n\nlogger.addHandler(file_handler)\nlogger.addHandler(stream_handler)","d4370fdf":"class XRaysDataset(Dataset):\n    \"\"\"\n    example:\n        trainset = XRaysDataset(\"..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/train\/\",\n                           transform = transform)\n    \"\"\"\n    def __init__(self,\n                 root: str,\n                 transform: Optional[Callable] = None) -> None:\n        self.transform = transform\n        self.data = pd.DataFrame(self.get_multiclass_data(root), columns=['image_path','label'])\n    def __len__(self):\n        return len(self.data)\n    def __getitem__(self, index):\n        row = self.data.iloc[index, :]\n        img = np.array(Image.open(row['image_path']).convert('RGB'))\n        label = row['label']\n        if self.transform is not None:\n            img = self.transform(img)\n        return img,label\n    \n    def get_data(self, folder):\n        \"\"\"\n        \u751f\u6210\u4e8c\u5206\u7c7b\u6807\u7b7e\uff0c\u60a3\u6709\u80ba\u708e\u4e3a\u6b63\u6837\u672c\n        \u8868\u683c\u6bcf\u4e00\u5217\u7684\u5c5e\u6027\u4e3a:\n        \u56fe\u7247\u8def\u5f84|\u56fe\u7247\u6807\u7b7e\n        \"\"\"\n        frame = []\n        for folderName in os.listdir(folder):\n            if not folderName.startswith('.'):\n                label = 0 if folderName == 'NORMAL' else 1\n\n                temp_path = os.path.join(folder, folderName)\n                for image_filename in os.listdir(temp_path):\n                    if image_filename.endswith('.jpeg'):\n                        frame += [[os.path.join(temp_path,image_filename), label]]\n        return frame\n    def get_multiclass_data(self, folder):\n        \"\"\"\n        \u751f\u6210\u591a\u5206\u7c7b\u6807\u7b7e\uff0cnormal-0,bacteria-1,virus-2\n        \u8868\u683c\u6bcf\u4e00\u5217\u5c5e\u6027\u4e3a:\n        image_path|label\n        \"\"\"\n        frame = []\n        for folderName in os.listdir(folder):\n            if not folderName.startswith('.'):\n                temp_path = os.path.join(folder, folderName)\n                for image_filename in os.listdir(temp_path):\n                    if image_filename.endswith('.jpeg'):\n                        s = image_filename.split('_')\n                        label=0 #\u6b63\u5e38\n                        if len(s)>=2:\n                            if s[1]=='bacteria':\n                                label = 1\n                            elif s[1]=='virus':\n                                label = 2\n                            else:\n                                raise ValueError('wrong image name: {}'.format(image_filename))\n                        frame += [[os.path.join(temp_path,image_filename), label]]\n        return frame\n","8f8fa5a0":"class DenseNet(nn.Module):\n    \"\"\"Model modified.\n\n    The architecture of our model is the same as standard DenseNet121\n    except the classifier layer which has an additional sigmoid function.\n\n    \"\"\"\n    def __init__(self, out_size):\n        super(DenseNet, self).__init__()\n        self.densenet121 = torchvision.models.densenet121(pretrained=False)\n        num_ftrs = self.densenet121.classifier.in_features\n        self.densenet121.classifier = nn.Sequential(\n            nn.Linear(num_ftrs, out_size),\n            nn.Sigmoid()\n        )\n\n    def forward(self, x):\n        x = self.densenet121(x)\n        return x","16be1abb":"def train(model, device, train_loader, optimizer, epoch):\n    model.train()\n    totalLoss, i = 0, 0\n    for data, target in train_loader:\n        data, target = data.to(device), target.to(device)\n        optimizer.zero_grad()\n        output = model(data)\n        loss = F.cross_entropy(output, target.long())\n        # loss = F.binary_cross_entropy(output, target.view_as(output).float())\n        totalLoss += loss.item()\n        loss.backward()\n        optimizer.step()\n        i += 1\n    logger.info(\"Train Epoch: {}\\t Loss:{:.6f}\".format(epoch, totalLoss\/i))\n\n\ndef test(model, device, test_loader):\n    model.eval()\n    test_loss = 0\n    correct = 0\n    with torch.no_grad():\n        for data, target in test_loader:\n            data, target = data.to(device), target.to(device)\n            output:torch.Tensor = model(data)\n            test_loss += F.cross_entropy(output, target.long(),\n                                    reduction='sum').item()  # \u5c06\u4e00\u6279\u7684\u635f\u5931\u76f8\u52a0\n            pred = output.max(1, keepdim=True)[1]  # \u627e\u5230\u6982\u7387\u6700\u5927\u7684\u4e0b\u6807\n            # test_loss = F.binary_cross_entropy(output, target.view_as(output).float(),\n            #                                    reduction='sum').item()\n            # pred = output.ge(0.5)\n            \n            \n            correct += pred.eq(target.view_as(pred)).sum().item()\n\n    test_loss \/= len(test_loader.dataset)\n    logger.info('Test set: Average loss: {:.4f}, Accuracy: {}\/{} ({:.0f}%)\\n'.format(\n        test_loss, correct, len(test_loader.dataset),\n        100. * correct \/ len(test_loader.dataset)))","306296ad":"train_dir = \"..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/train\/\"\ntest_dir =  \"..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/test\/\"\nval_dir = \"..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/val\/\"\nbatch_size = 16\nlearning_rate = 0.00005\nepoch = 10\n\nnormalize = transforms.Normalize(mean=[0.485, 0.456, 0.406],\n                                 std=[0.229, 0.224, 0.225])\ntrain_transform = transforms.Compose([transforms.ToPILImage(), \n                    transforms.Resize((256,256)),\n                    transforms.RandomCrop(224),\n                    transforms.RandomHorizontalFlip(),\n                    transforms.ToTensor(),\n                    normalize])\n\ntest_transform = transforms.Compose([transforms.ToPILImage(), \n                    transforms.Resize((256,256)),\n                    transforms.CenterCrop(224),\n                    transforms.ToTensor(),\n                    normalize])\n\ntrain_dataset = XRaysDataset(train_dir,transform = train_transform)\ntest_dataset = XRaysDataset(test_dir,transform = test_transform)\nval_dataset = XRaysDataset(val_dir,transform = test_transform)\ntrain_loader = DataLoader(train_dataset, batch_size, shuffle=True)\ntest_loader = DataLoader(test_dataset, batch_size)\nval_loader = DataLoader(val_dataset, batch_size)\n\ndevice = torch.device(\n    \"cuda\") if torch.cuda.is_available() else torch.device(\"cpu\")\nprint(f'\\ndevice: {device}')\n\nmodel = DenseNet(out_size=3).to(device)\nif os.path.exists('.\/model.pth'):\n    print('load model')\n    model.load_state_dict(torch.load('.\/model.pth'))\n# Adam\u4f18\u5316\u5668\noptimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)\n\nlogger.info(\"\"\"\nTraining parameter:\nbatch size:{}\nLearning Rate:{}\noptimizer:\n{}\n\"\"\".format(batch_size, learning_rate, optimizer.__str__()))\nfor i in range(1, epoch + 1):\n    train(model, device, train_loader, optimizer, i)\n    test(model, device, train_loader)\n    test(model, device, test_loader)\n    \n    torch.save(model.state_dict(),'.\/model.pth')\n        \n\n# torch.save(model.state_dict(),'.\/model.pth')\n# test(model, device, test_loader)\nprint('\\nEnd')","a041eebf":"#### \u5b9a\u4e49DenseNet","a0fbb6ad":"#### \u914d\u7f6e\u8bad\u7ec3\u51fd\u6570\u4e0e\u6d4b\u8bd5\u51fd\u6570","3b39cfec":"#### \u8bbe\u7f6e\u8f93\u51fa\u65e5\u5fd7","3df6d824":"#### \u5f00\u59cb\u8bad\u7ec3","2528a868":"#### \u5b9a\u4e49Dataset"}}