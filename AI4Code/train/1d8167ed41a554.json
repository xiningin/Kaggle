{"cell_type":{"696d87e4":"code","c2dac66c":"code","ce5a31dd":"code","286c118d":"code","c2db4e7a":"code","2e9b7526":"code","9b513cf0":"code","e2ab33ff":"code","508592c1":"code","9b3158fc":"code","30ba9f5b":"code","7ad8f6cf":"code","84bc1514":"code","c9f8d12d":"code","9ec32c75":"code","bd83fd43":"code","46f2d82d":"code","20663eeb":"code","51037ac1":"code","d4b27c44":"code","88f3fc4f":"code","f464dd87":"code","2adc5867":"code","5b5cd055":"code","00e4f267":"markdown","dfd28ec9":"markdown","82584fa4":"markdown","4e75ac2d":"markdown","994d7bd5":"markdown","de2cf858":"markdown","32662cce":"markdown","de4e3b6d":"markdown","861f0d75":"markdown","5bc43dd7":"markdown","750f9524":"markdown","d5b024bc":"markdown","253b40a8":"markdown","96036e81":"markdown","214d5671":"markdown","2714f2d9":"markdown","8ff0cc8c":"markdown"},"source":{"696d87e4":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\nimport os\nfrom tqdm.notebook import tqdm\nfrom scipy.integrate import solve_ivp\n\n%matplotlib inline","c2dac66c":"# Susceptible equation\ndef dS_dt(S, I, R_t, T_inf):\n    return -(R_t \/ T_inf) * I * S\n\n# Exposed equation\ndef dE_dt(S, E, I, R_t, T_inf, T_inc):\n    return (R_t \/ T_inf) * I * S - (T_inc**-1) * E\n\n# Infected equation\ndef dI_dt(I, E, T_inc, T_inf):\n    return (T_inc**-1) * E - (T_inf**-1) * I\n\n# Recovered\/deceased equation\ndef dR_dt(I, T_inf):\n    return (T_inf**-1) * I\n\ndef SEIR_model(t, y, R_t, T_inf, T_inc):\n    \n    if callable(R_t):\n        reproduction = R_t(t)\n    else:\n        reproduction = R_t\n    \n    S, E, I, R = y\n    S_out = dS_dt(S, I, reproduction, T_inf)\n    E_out = dE_dt(S, E, I, reproduction, T_inf, T_inc)\n    I_out = dI_dt(I, E, T_inc, T_inf)\n    R_out = dR_dt(I, T_inf)\n    return [S_out, E_out, I_out, R_out]","ce5a31dd":"N = 100000  # Population size\nn_infected = 1\nmax_days = 200\n\n# State at time = 0 for SEIR model\na = (N - n_infected)\/ N\nb = 0\nc = n_infected \/ N\nd = 0.","286c118d":"def plot_model(solution, title='SEIR model'):\n    sus, exp, inf, rec = solution.y\n\n    f = plt.figure(figsize=(8,5)) \n    plt.plot(sus, 'b', label='Susceptible');\n    plt.plot(exp, 'y', label='Exposed');\n    plt.plot(inf, 'r', label='Infected');\n    plt.plot(rec, 'c', label='Recovered\/deceased');\n    plt.title(title)\n    plt.xlabel(\"Days\", fontsize=10);\n    plt.ylabel(\"Fraction of population\", fontsize=10);\n    plt.legend(loc='best');","c2db4e7a":"T_inc = 5.2  # average incubation period\nT_inf = 2.9  # average infectious period\nR_0 = 2.2  # reproduction number\n\nsol = solve_ivp(SEIR_model, [0, max_days], [a, b, c, d], args=(R_0, T_inf, T_inc), \n                t_eval=np.arange(max_days))\n\nplot_model(sol, 'SEIR Model (without intervention)')","2e9b7526":"T_inc = 5.2  # average incubation period\nT_inf = 2.9  # average infectious period\nR_0 = 2.2  # reproduction number without intervention\nR_t = 0.7  # reproduction number after intervention\nintervention_day = 80\n\ndef time_varying_reproduction(t):\n    if t > intervention_day:\n        return R_t\n    else:\n        return R_0\n\nsol2 = solve_ivp(SEIR_model, [0, max_days], [a, b, c, d], args=(time_varying_reproduction, T_inf, T_inc), \n                t_eval=np.arange(max_days))\n\nplot_model(sol2, f'SEIR Model (with intervention on day {intervention_day})')","9b513cf0":"_, exp, inf, _ = sol.y\n_, exp2, inf2, _ = sol2.y\n\nf = plt.figure(figsize=(8,5)) \nplt.plot(exp, 'r.', label='Exposed');\nplt.plot(inf, 'r', label='Infected');\nplt.plot(exp2, 'g.', label='Exposed with intervention');\nplt.plot(inf2, 'g', label='Infected with intervention');\nplt.title(f'Comparison of the effect of the intervention on day {intervention_day}')\nplt.xlabel(\"Days\", fontsize=10);\nplt.ylabel(\"Fraction of population\", fontsize=10);\nplt.legend(loc='best');","e2ab33ff":"from IPython.display import Image\nfrom IPython.core.display import HTML \nImage(url= \"https:\/\/raw.githubusercontent.com\/wiki\/SwissTPH\/openmalaria\/img\/graphs\/decay-functions.png\")","508592c1":"data_path = Path('\/kaggle\/input\/covid19-global-forecasting-week-1\/')\n\ntrain = pd.read_csv(data_path \/ 'train.csv', parse_dates=['Date'])\ntest = pd.read_csv(data_path \/'test.csv', parse_dates=['Date'])\nsubmission = pd.read_csv(data_path \/'submission.csv', index_col=['ForecastId'])\n\n# Load the population data into lookup dicts\npop_info = pd.read_csv('\/kaggle\/input\/covid19-population-data\/population_data.csv')\ncountry_pop = pop_info.query('Type == \"Country\/Region\"')\nprovince_pop = pop_info.query('Type == \"Province\/State\"')\ncountry_lookup = dict(zip(country_pop['Name'], country_pop['Population']))\nprovince_lookup = dict(zip(province_pop['Name'], province_pop['Population']))\n\ntrain['FatalityRate'] = train['Fatalities'] \/ train['ConfirmedCases']\ntrain['Area'] = train['Province\/State'].fillna(train['Country\/Region'])\ntest['Area'] = test['Province\/State'].fillna(test['Country\/Region'])\n\n# Remove the leaking data\nvalid = train[train['Date'] >= test['Date'].min()]\ntrain = train[train['Date'] < test['Date'].min()]\n\ntrain.set_index(['Area', 'Date'], inplace=True)\nvalid.set_index(['Area', 'Date'], inplace=True)\ntest.set_index(['Area', 'Date'], inplace=True)\n\nsubmission['ConfirmedCases'] = 0\nsubmission['Fatalities'] = 0\n\ntrain.shape, test.shape, submission.shape","9b3158fc":"from scipy.optimize import minimize\nfrom sklearn.metrics import mean_squared_log_error, mean_squared_error","30ba9f5b":"# Use a constant reproduction number\ndef eval_model_const(params, data, population, return_solution=False, forecast_days=0):\n    R_0, cfr = params\n    N = population\n    n_infected = data['ConfirmedCases'].iloc[0]\n    max_days = len(data) + forecast_days\n    a, b, c, d = (N - n_infected)\/ N, 0, n_infected \/ N, 0\n               \n    sol = solve_ivp(SEIR_model, [0, max_days], [a, b, c, d], args=(R_0, T_inf, T_inc),\n                    t_eval=np.arange(0, max_days))\n    \n    y_pred_cases = np.diff((sol.y[2] + sol.y[3])*N, prepend=n_infected).cumsum()\n    y_pred_cases = np.clip(y_pred_cases, 0, np.inf)\n    y_true_cases = data['ConfirmedCases'].values\n    y_pred_fat = np.clip(sol.y[3]*N, 0, np.inf) * cfr\n    y_true_fat = data['Fatalities'].values\n    \n    optim_days = min(14, len(data))  # Days to optimise for\n    weights = 1 \/ np.arange(1, optim_days+1)[::-1]  # Recent data is more heavily weighted\n    \n    msle_cases = mean_squared_log_error(y_true_cases[-optim_days:], y_pred_cases[-optim_days:], weights)\n    msle_fat = mean_squared_log_error(y_true_fat[-optim_days:], y_pred_fat[-optim_days:], weights)\n    msle_final = np.mean([msle_cases, msle_fat])\n    \n    if return_solution:\n        return msle_final, sol\n    else:\n        return msle_final","7ad8f6cf":"# Use a Hill decayed reproduction number\ndef eval_model_decay(params, data, population, return_solution=False, forecast_days=0):\n    R_0, cfr, k, L = params  \n    N = population\n    n_infected = data['ConfirmedCases'].iloc[0]\n    max_days = len(data) + forecast_days\n    a, b, c, d = (N - n_infected)\/ N, 0, n_infected \/ N, 0\n    \n    # https:\/\/github.com\/SwissTPH\/openmalaria\/wiki\/ModelDecayFunctions   \n    # Hill decay. Initial values: R_0=2.2, k=2, L=50\n    def time_varying_reproduction(t): \n        return R_0 \/ (1 + (t\/L)**k)\n            \n    sol = solve_ivp(SEIR_model, [0, max_days], [a, b, c, d], args=(time_varying_reproduction, T_inf, T_inc),\n                    t_eval=np.arange(0, max_days))\n    \n    y_pred_cases = np.diff((sol.y[2] + sol.y[3])*N, prepend=n_infected).cumsum()\n    y_pred_cases = np.clip(y_pred_cases, 0, np.inf)\n    y_true_cases = data['ConfirmedCases'].values\n    y_pred_fat = np.clip(sol.y[3]*N, 0, np.inf) * cfr\n    y_true_fat = data['Fatalities'].values\n    \n    optim_days = min(14, len(data))  # Days to optimise for\n    weights = 1 \/ np.arange(1, optim_days+1)[::-1]  # Recent data is more heavily weighted\n    \n    msle_cases = mean_squared_log_error(y_true_cases[-optim_days:], y_pred_cases[-optim_days:], weights)\n    msle_fat = mean_squared_log_error(y_true_fat[-optim_days:], y_pred_fat[-optim_days:], weights)\n    msle_final = np.mean([msle_cases, msle_fat])\n    \n    if return_solution:\n        return msle_final, sol\n    else:\n        return msle_final","84bc1514":"def use_last_value(train_data, valid_data, test_data):\n    lv = train_data[['ConfirmedCases', 'Fatalities']].iloc[-1].values\n        \n    y_pred_valid = np.ones((len(valid_data), 2)) * lv.reshape(1, 2)\n    y_true_valid = valid_data[['ConfirmedCases', 'Fatalities']]\n    \n    msle_cases = mean_squared_log_error(y_true_valid['ConfirmedCases'], y_pred_valid[:, 0])\n    msle_fat = mean_squared_log_error(y_true_valid['Fatalities'], y_pred_valid[:, 1])\n    msle_final = np.mean([msle_cases, msle_fat])\n    \n    forecast_ids = test_data['ForecastId']\n    submission.loc[forecast_ids, ['ConfirmedCases', 'Fatalities']] = lv\n    \n    return msle_final","c9f8d12d":"def fit_model(area_name, initial_guess=[2.2, 0.02, 2, 50], \n              bounds=((1, 20), (0, 0.15), (1, 3), (1, 100)), make_plot=True):\n        \n    train_data = train.loc[area_name].query('ConfirmedCases > 0')\n    valid_data = valid.loc[area_name]\n    test_data = test.loc[area_name]\n    \n    try:\n        population = province_lookup[area_name]\n    except KeyError:\n        population = country_lookup[area_name]\n        \n    cases_per_million = train_data['ConfirmedCases'].max() * 10**6 \/ population\n    n_infected = train_data['ConfirmedCases'].iloc[0]\n        \n    if cases_per_million < 1:\n        return use_last_value(train_data, valid_data, test_data)\n                \n    res_const = minimize(eval_model_const, [2.2, 0.02], bounds=((1, 20), (0, 0.15)),\n                         args=(train_data, population, False),\n                         method='L-BFGS-B')\n    \n    res_decay = minimize(eval_model_decay, initial_guess, bounds=bounds,\n                         args=(train_data, population, False),\n                         method='L-BFGS-B')\n    \n    dates_all = train_data.index.append(test_data.index)\n    dates_val = train_data.index.append(valid_data.index)\n    \n    \n    # If using a constant R number is better, use that model\n    if res_const.fun < res_decay.fun:\n        msle, sol = eval_model_const(res_const.x, train_data, population, True, len(test_data))\n        res = res_const\n        R_t = pd.Series([res_const.x[0]] * len(dates_val), dates_val)\n    else:\n        msle, sol = eval_model_decay(res_decay.x, train_data, population, True, len(test_data))\n        res = res_decay\n        \n        # Calculate the R_t values\n        t = np.arange(len(dates_val))\n        R_0, cfr, k, L = res.x   \n        R_t = pd.Series(R_0 \/ (1 + (t\/L)**k), dates_val)\n        \n    sus, exp, inf, rec = sol.y\n    \n    y_pred = pd.DataFrame({\n        'ConfirmedCases': np.diff((inf + rec) * population, prepend=n_infected).cumsum(),\n        'Fatalities': np.clip(rec, 0, np.inf) * population * res.x[1]\n    }, index=dates_all)\n    \n    y_pred_valid = y_pred.iloc[len(train_data): len(train_data)+len(valid_data)]\n    y_pred_test = y_pred.iloc[len(train_data):]\n    y_true_valid = valid_data[['ConfirmedCases', 'Fatalities']]\n        \n    valid_msle_cases = mean_squared_log_error(y_true_valid['ConfirmedCases'], y_pred_valid['ConfirmedCases'])\n    valid_msle_fat = mean_squared_log_error(y_true_valid['Fatalities'], y_pred_valid['Fatalities'])\n    valid_msle = np.mean([valid_msle_cases, valid_msle_fat])\n    \n    if make_plot:\n        print(f'Validation MSLE: {valid_msle:0.5f}', res.x)\n                \n        f = plt.figure(figsize=(8, 5)) \n        train_data['ConfirmedCases'].plot(label='Confirmed Cases (train)', c='g')\n        valid_data['ConfirmedCases'].plot(label='Confirmed Cases (valid)', c='b')\n        y_pred.loc[train_data.index, 'ConfirmedCases'].plot(label='Cumulative modeled infections', c='r')\n        y_pred.loc[valid_data.index, 'ConfirmedCases'].plot(label='Cumulative modeled infections (forecast)', c='orange', linestyle='-')\n        plt.legend(loc='best');\n        R_t.plot(label='Reproduction number', c='c', linestyle='-', secondary_y=True)\n        plt.legend(loc='best');\n        \n    # Put the forecast in the submission\n    forecast_ids = test_data['ForecastId']\n    submission.loc[forecast_ids, ['ConfirmedCases', 'Fatalities']] = y_pred_test.values\n    \n    return valid_msle\n            ","9ec32c75":"fit_model('Italy')","bd83fd43":"fit_model('Iran')","46f2d82d":"fit_model('Korea, South', bounds=((1, 20), (0, 0.15), (1, 100), (1, 200)))","20663eeb":"fit_model('Japan', bounds=((1, 20), (0, 0.15), (1, 10), (1, 200)))","51037ac1":"fit_model('Kuwait')","d4b27c44":"fit_model('Hubei')","88f3fc4f":"train.loc['California'].tail()","f464dd87":"validation_scores = []\n\nfor c in tqdm(test.index.levels[0].values):\n    try:\n        if c in ['Japan', 'Korea, South']:\n            score = fit_model(c, make_plot=False, bounds=((1, 20), (0, 0.15), (1, 100), (1, 200)))\n        else:\n            score = fit_model(c, make_plot=False)\n        validation_scores.append({'Country': c, 'MSLE': score})\n        print(f'{c} {score:0.5f}')\n    except IndexError as e:\n        print(c, 'has no cases in train')\n\nvalidation_scores = pd.DataFrame(validation_scores)\nprint(f'Mean validation score: {validation_scores[\"MSLE\"].mean():0.5f}')","2adc5867":"# Find which areas are not being predicted well\nvalidation_scores.sort_values(by=['MSLE'], ascending=False).head(20)","5b5cd055":"submission.to_csv('submission.csv')","00e4f267":"The function below evaluates a model with a constant R number and case fatality ratio, CFR. CFR is used to estimate the number of fatalities from the Recovered\/deceased compartment in the SEIR model","dfd28ec9":"The data fo the US states is not as good due to testing protocols. A jump from zero to 144 cases on the 10th of March is too difficult to model accurately with compartment models like SEIR","82584fa4":"The function below is essentially the same as above, by R is decayed using a Hill decay function. This model requires 4 parameters to be optimized, `R_0`, `CFR`, `k` & `L`","4e75ac2d":"Let's compare the infection rate between the two cases","994d7bd5":"# Model with intervention\nLets assume that there is some intervention that causes the reproduction number (`R_0`) to fall to a lower value (`R_t`) at a certain time (e.g. physical distancing). Note that the actual drop will occur some time after the intervention measures are implemented.\n\nThis could be modified to take any function of `R_t(t)` values to model the reproduction number as a time varying variable","de2cf858":"Above you can see the model optimized on the last 14 days of data from Italy which has been weighted to put more importance on recent data\n\nThe numbers show that `R_0` was around 3.5 and a constant value was a better fit for this data. This means that (for this time period) the measures Italy had in place are unfortunately not showing a reduction in the data just yet.\n\nLet's try Iran, South Korea and Japan. I chose these countries since they are probably the most challenging to model","32662cce":"One of the big questions of the outbreak was how did Japan limit the spread? `R_0` in this case is 2.09 which is on the low side compared to what we have seen in other countries.","de4e3b6d":"# SEIR Model\nThis is a working example of a [SIER](https:\/\/en.wikipedia.org\/wiki\/Compartmental_models_in_epidemiology#The_SEIR_model) model with the effects of societal intervention included.\n\nI have taken the equations from this great web app: http:\/\/gabgoh.github.io\/COVID\/index.html\n\nThanks to this kernel for the inspiration: https:\/\/www.kaggle.com\/saga21\/covid-global-forecast-sir-model","861f0d75":"# Model without intervention\nLet's see what the model looks like without any intervention, i.e. `R_0` is a contant value","5bc43dd7":"You can see that after the intervention on day 80, the peak infections is lower than if there was no intervention","750f9524":"South Korea is unusual due to the super-human efforts to stop the spread. In order to model this, I had to allow the `k` values in the Hill decay to go to higher than normal values (using wider boundary conditions) which allowed an extremely rapid decay of the reproduction number, but it still isn't enough.","d5b024bc":"The function below fits a SEIR model for each area, either using a constant R or a decayed R, whichever is better. If the total cases\/1M pop is below 1, then the last value is used.","253b40a8":"Kuwait was one of the first countries to be affected by cases in Iran. Most of the recent cases have been Kuwaitis being repatriated from the UK, which is very difficult to model.","96036e81":"An unusual feature of the Iranian data is how linear it is, as opposed to log-linear as with Italy's data.","214d5671":"# Calculate for all countries","2714f2d9":"The plot for Hubei looks really good. In fact the data for most of the Chinese provinces is really good and the SEIR model works well","8ff0cc8c":"# Fitting the model to data\nThere are certain variables that we can play with to fit the model to real data:\n* Average incubation period, `T_inc`\n* Average infection period, `T_inf`\n* Reproduction number, `R_0` or `R_t`\n* Case fatality rate, `CFR`\n\nThe first two are likely to be constants specific to the virus. The latter two are likely to be time dependent variables dependent on factors such as:\n* When a government intervened\n* Peoples behaviours (do people actively self-isolate, not visit religious shrines etc.)\n* Population demographic of a country (is a significant proportion of the population old?)\n* Heathcare system capacity (hostpital beds per capita)\n* Number of tests\n\nWe have already used two different reproduction numbers above. Let's see if we can derive a time-dependent `R_t` and `CFR` from the data. \n\nWe will also compare this to just using a single reproduction number. This might actaully be more suitable in countries where the outbreak has just started or they are struggling to limit the spread.\n\nThere are lots of ways to decay a parameter in epidemiology. I'm going to use a Hill decay, which has 2 parameters, `k` and `L` (the half decay constant):"}}