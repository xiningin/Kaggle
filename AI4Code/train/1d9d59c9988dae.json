{"cell_type":{"50d5dff8":"code","6ae7aede":"code","f46dae59":"code","463379c2":"code","5c3af6c7":"code","8f4b6cb2":"code","a15d8c48":"code","819286de":"code","b1874a54":"code","8308929b":"code","2fb2a353":"code","7f0ae973":"code","84b8a7e0":"code","77e4d8fc":"code","adf0f85d":"code","10425f39":"code","808b43b3":"code","efb33695":"markdown","891c045b":"markdown","3c45cbda":"markdown","1d24dcaf":"markdown","920e6d82":"markdown","5b6ddc9b":"markdown","944c5355":"markdown","5fd605f4":"markdown"},"source":{"50d5dff8":"# Import the famous library from Python \nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nimport cv2\nimport matplotlib.pyplot as plt\n\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","6ae7aede":"# %cd \/kaggle\/working\n# %cd ..\/input\/celeba-spoof-for-face-antispoofing\n# !pwd","f46dae59":"def get_ratio_bbox_and_image(full_img_path, bound_box_path):\n    img = cv2.imread(full_img_path)\n    real_h, real_w, _ = img.shape\n    area_image = real_h * real_w\n    x1, y1, w1, h1 = get_area_bbox_indices(bound_box_path, real_w, real_h)\n    area_bbox = w1*h1\n    return area_bbox \/ area_image\n\n\ndef standard_width_height_scaling(real_w, real_h, bbox0, bbox1, bbox2, bbox3):\n    x1 = int(int(bbox0)*(float(real_w) \/ 224)) # bbox[0]\n    y1 = int(int(bbox1)*(float(real_h) \/ 224)) # bbox[1]\n    w1 = int(int(bbox2)*(float(real_w) \/ 224)) # bbox[2]\n    h1 = int(int(bbox3)*(float(real_h) \/ 224)) # bbox[3]\n    return x1, y1, w1, h1\n\n\ndef get_area_bbox_indices(bound_box_path, real_w, real_h):\n    bound_box_read = open(bound_box_path, \"r\")\n    bound_box_indices = list()\n    for i in bound_box_read:\n        bound_box_indices.append(i)\n    bbox = bound_box_indices[0].split()\n    x1, y1, w1, h1 = standard_width_height_scaling(real_w, real_h, \n                                                   bbox[0], bbox[1], bbox[2], bbox[3])\n    return x1, y1, w1, h1\n\n\ndef get_padding_bbox_indices(x1, y1, w1, h1, real_w, real_h, ratio_bbox_and_image, option):\n    '''\n    @option is used to choose the padding or not \n    if option is 1 => Padding \n    if option is 0 => Non-padding\n    '''\n    if option == 1:\n        x1_padding = x1 - int((w1) * (1+ratio_bbox_and_image))\n        y1_padding = y1 - int((h1) * (1+ratio_bbox_and_image))\n        w1_padding = w1 + int((w1) * (1+ratio_bbox_and_image))\n        h1_padding = h1 + int((h1) * (1+ratio_bbox_and_image))\n        if x1_padding < 0: \n            x1_padding = 0\n        if y1_padding < 0:\n            y1_padding = 0\n        if w1_padding > real_w:\n            w1_padding = real_w\n        if h1_padding > real_h:\n            h1_padding = real_h\n        return x1_padding, y1_padding, w1_padding, h1_padding\n    elif option == 0: \n        return x1, y1, w1, h1\n    else: \n        print(\"Option is inputted is wrong => Need to be interger number 0 or 1\")\n    \n    \ndef read_crop_img_with_bbox(full_img_path, bound_box_path):\n    img = cv2.imread(full_img_path)\n    real_w = img.shape[1]\n    real_h = img.shape[0]\n    x1, y1, w1, h1 = get_area_bbox_indices(bound_box_path, real_w, real_h)\n#     print(f'x1={x1}, y1={y1}, w1={w1}, and h1={h1}')\n    return x1, y1, w1, h1, img, real_w, real_h","463379c2":"# Live Storage\noriginal_cropped_storage = []\npadding_cropped_storage = []\nimg_names = []\noriginal_cropped_labels = []\npadding_cropped_labels = []\n\ncount_live = 0\ncount_spoof = 0\ndim = (32, 32)\ncount_limit_live = 10\ncount_limit_spoof = 10\n\nrootdir_train = '\/kaggle\/input\/celeba-spoof-for-face-antispoofing\/CelebA_Spoof_\/CelebA_Spoof\/Data\/train'\nfor file in os.listdir(rootdir_train):\n#     file = '1'\n    # file is 1, 1000, ..... 10029,...... => Name of folder \n    d = os.path.join(rootdir_train, file)\n    if os.path.isdir(d):\n        for e in os.listdir(d):\n            # e is \"live\" of \"spoof\"\n            imgs_path = d + '\/' + e + '\/'\n#             print(imgs)\n            for img_path in os.listdir(imgs_path):\n#                 print(img_path)\n#                 imgs_path = '000184.jpg'\n                if (img_path.endswith(\".jpg\")):\n                    full_img_path = imgs_path + img_path\n                    bound_box_path = full_img_path[0:-4] + '_BB.txt'\n                    x1, y1, w1, h1, img, real_w, real_h = read_crop_img_with_bbox(full_img_path, bound_box_path)\n                    ratio_bbox_and_image = get_ratio_bbox_and_image(full_img_path, bound_box_path)\n                    x1_padding, y1_padding, w1_padding, h1_padding = get_padding_bbox_indices(x1, y1, w1, h1, \n                                                                                              real_w, real_h,\n                                                                                              ratio_bbox_and_image, \n                                                                                              option=0)\n                    padding_img = img[y1_padding:y1+h1_padding, x1_padding:x1+w1_padding]\n                    try:\n                        if (e == 'live' and count_live >= count_limit_live) or (e == 'spoof' and count_spoof >= count_limit_spoof):\n                            continue\n                        resized_padding_img = cv2.resize(padding_img, dim, interpolation = cv2.INTER_AREA)\n                        padding_cropped_storage.append(resized_padding_img)\n                        if e == 'live':\n                            count_live = count_live + 1\n                            padding_cropped_labels.append(1)\n                        elif e == 'spoof':\n                            count_spoof = count_spoof + 1\n                            padding_cropped_labels.append(0)\n                    except:\n                        continue\n                        \n#                     original_img = img[y1:y1+h1,x1:x1+w1]\n#                     try: \n#                         resized_original_img= cv2.resize(original_img, dim, interpolation = cv2.INTER_AREA)\n#                         original_cropped_storage.append(resized_original_img)\n#                         if e == 'live':\n#                             count_live = count_live + 1\n#                             original_cropped_labels.append(1)\n#                         elif e == 'spoof':\n#                             count_spoof = count_spoof + 1\n#                             original_cropped_labels.append(0)\n#                     except:\n#                         continue\n                    img_names.append(img_path)\n                    if (count_live==count_limit_live and e=='live') or (count_spoof==count_limit_spoof and e=='spoof'):\n                        break\n#                 if count_live == count_limit_live and count_spoof == count_limit_spoof:\n#                     break\n            if count_live >= count_limit_live and count_spoof >= count_limit_spoof:\n                break\n    if count_live >= count_limit_live and count_spoof >= count_limit_spoof:\n        print(\"DONE Extracting \")\n        break\n","5c3af6c7":"# Save the numpy to NUMPYZ \nX = np.asarray(padding_cropped_storage)\ny = np.asarray(padding_cropped_labels)\nnp.savez('anti_spoofing_data.npz', X, y)\nprint(\"DONE SAVING DATA WITH NPZ\")","8f4b6cb2":"anti_spoofing_data = np.load('..\/input\/face-anti-spoofing\/anti_spoofing_data.npz')\n# anti_spoofing_data = np.load('anti_spoofing_data.npz')\nX, y = anti_spoofing_data['arr_0'], anti_spoofing_data['arr_1']\ntemp = set(y)\ncheck_live_label = 0\ncheck_spoof_label = 0\nfor i in y: \n    if i == 1:\n        check_live_label += 1\n    elif i == 0:\n        check_spoof_label += 1\nprint(f\"There are 2 classes including number of live is {check_live_label} and number of spoof is {check_spoof_label}\")","a15d8c48":"plt.figure(figsize=(10,10))\nfor i in range(25):\n    plt.subplot(5,5,i+1)\n    plt.xticks([])\n    plt.yticks([])\n    plt.grid(False)\n#     plt.imshow(original_cropped_storage[i])\n    plt.imshow(X[i])\n#     plt.xlabel(class_names[train_labels[i][0]])\nplt.show()","819286de":"from sklearn.model_selection import train_test_split\nimport numpy as np\n\n# X = np.asarray(padding_cropped_storage)\n# y = np.asarray(padding_cropped_labels)\nprint(X.shape)\nprint(y.shape)\nX_train, X_valid, y_train, y_valid = train_test_split(X, y, test_size=0.3, random_state=42)\nX_valid, X_test, y_valid, y_test = train_test_split(X_valid, y_valid, test_size=0.5, random_state=42)\nprint(f'Training dataset size of X_train: {len(X_train)}')\nprint(f'Testing dataset size of X_test: {len(X_test)}')\nprint(f'Validation dataset size of X_valid: {len(X_valid)}')\nprint(f'Testing dataset size of y_train: {len(y_train)}')\nprint(f'Testing dataset size of y_test: {len(y_test)}')\nprint(f'Testing dataset size of y_valid: {len(y_valid)}')","b1874a54":"# rootdir_train_json = '..\/input\/celeba-spoof-for-face-antispoofing\/CelebA_Spoof_\/CelebA_Spoof\/metas\/intra_test\/train_label.json'\n\n# patients_df = pd.read_json(rootdir_train_json)\n# patients_df.head()\n# patients_df.iloc[:,0:19]","8308929b":"%%capture\n!pip install wandb\nimport wandb\nfrom wandb.keras import WandbCallback\n\nwandb.login()\n# Key: c6938827241c279765c88e7642be8d04bdc0c3ac","2fb2a353":"import tensorflow as tf\nfrom tensorflow.keras.callbacks import Callback\nfrom wandb.keras import WandbCallback\nfrom tensorflow.keras import datasets, layers, models\nimport matplotlib.pyplot as plt\n\nnumber_of_class = 2\nmodel = models.Sequential()\nmodel.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3)))\nmodel.add(layers.MaxPooling2D((2, 2)))\nmodel.add(layers.Conv2D(64, (3, 3), activation='relu'))\nmodel.add(layers.MaxPooling2D((2, 2)))\nmodel.add(layers.Conv2D(64, (3, 3), activation='relu'))\nmodel.add(layers.Flatten())\nmodel.add(layers.Dense(64, activation='relu'))\nmodel.add(layers.Dense(number_of_class, activation=\"softmax\"))\n\nmodel.summary()\n\nrun = wandb.init(project='my-keras-integration',\n           config={\n              \"learning_rate\": 0.005,\n              \"epochs\": 20,\n              \"batch_size\": 16,\n              \"optimizer\": \"adam\",\n              \"loss_function\": \"sparse_categorical_crossentropy\",\n              \"architecture\": \"CNN\",\n              \"dataset\": \"Celec Anti Spoofing\"\n           })\nconfig = wandb.config\n\n\nmodel.compile(optimizer=config.optimizer,\n              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),\n              metrics=['accuracy'])\n# X_train, X_test, y_train, y_test\nhistory = model.fit(X_train, y_train, \n                    epochs=config.epochs,\n                    batch_size=config.batch_size,\n                    validation_data=(X_valid, y_valid),\n                    callbacks=[WandbCallback()])\nmodel.save(\".\/my_model.h5\") # Saving with Keras Format \nsaved_model_path = model.save(f\".\/tmp\/1\", save_format='tf') # Saving with Tensorflow Format \n\n\n","7f0ae973":"run.join()","84b8a7e0":"plt.plot(history.history['accuracy'], label='accuracy')\nplt.plot(history.history['val_accuracy'], label = 'val_accuracy')\nplt.xlabel('Epoch')\nplt.ylabel('Accuracy')\nplt.ylim([0.5, 1])\nplt.legend(loc='lower right')\n\ntest_loss, test_acc = model.evaluate(X_test,  y_test, verbose=2)","77e4d8fc":"from sklearn.metrics import ConfusionMatrixDisplay\nfrom sklearn.metrics import confusion_matrix\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom tensorflow import keras\n\n# model = keras.models.load_model('..\/input\/face-anti-spoofing\/my_model.h5')\nmodel = keras.models.load_model('my_model.h5')\n\ny_predict = model.predict(X_test)\ny_predict_argmax = np.argmax(y_predict, axis=1)\n\ncm = confusion_matrix(y_predict_argmax, y_test)\nlabels = [\"Spoof\", \"Live\"]\ndisp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=labels)\ndisp.plot(cmap=plt.cm.Blues)\nplt.show()","adf0f85d":"from sklearn.metrics import ConfusionMatrixDisplay\nfrom sklearn.metrics import confusion_matrix\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom tensorflow import keras\n\n# model = keras.models.load_model('..\/input\/face-anti-spoofing\/my_model.h5')\nmodel = keras.models.load_model('..\/input\/20210915-mymodel')\n\nrun = wandb.init(project='my-keras-visualization',\n           config={\n              \"learning_rate\": 0.005,\n              \"epochs\": 20,\n              \"batch_size\": 16,\n              \"optimizer\": \"adam\",\n              \"loss_function\": \"sparse_categorical_crossentropy\",\n              \"architecture\": \"CNN\",\n              \"dataset\": \"Celec Anti Spoofing\"\n           })\n\n\ny_predict = model.predict(X_test)\ny_predict_argmax = np.argmax(y_predict, axis=1)\nlabels = [\"Spoof\", \"Live\"]\nwandb.log({\"conf_mat\" : wandb.plot.confusion_matrix(probs=None,\n                        y_true=y_test, preds=y_predict_argmax,\n                        class_names=labels)})\nrun.join()","10425f39":"from sklearn.metrics import classification_report\n\ny_true = y_test\ny_pred = y_predict_argmax\ntarget_names = ['Class Spoof', 'Class Live']","808b43b3":"!zip -r tmp.zip tmp\n","efb33695":"### Print out the testing result","891c045b":"### Build a simple CNN Model for training, validating and testing","3c45cbda":"## ===========================================================================================","1d24dcaf":"### Checking the number of Live Samples and Spoof Samples after extracting ","920e6d82":"### Saving the data in the NPZ file","5b6ddc9b":"## SKlearn used for Splitting Training and Testing dataset","944c5355":"### Plot Confusion Matrix","5fd605f4":"## Read JSON file "}}