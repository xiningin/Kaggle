{"cell_type":{"8d1714bc":"code","1354a918":"code","f46f470c":"code","7551606f":"code","609179ba":"code","0c86c2c7":"code","bdd6958f":"code","ddebd372":"code","bede3e55":"code","5bd2416a":"code","8244e9a1":"code","7c406e91":"code","d6221502":"code","0b4d0dd8":"code","86bede87":"code","f4c864a8":"markdown","9c177ce1":"markdown","37705661":"markdown"},"source":{"8d1714bc":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport shutil\nfrom sklearn.model_selection import train_test_split\nimport tensorflow as tf\nfrom sklearn.model_selection import train_test_split\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","1354a918":"# getting the labels corresponding to the image\nlabel_df = pd.read_csv('\/kaggle\/input\/crowd-counting\/labels.csv')\nlabel_df.columns = ['id' , 'people']\nlabel_df.head()","f46f470c":"# loading the images in vector format\nimg = np.load('\/kaggle\/input\/crowd-counting\/images.npy')\n#img = img.reshape(img.shape[0], img.shape[1], img.shape[2], img.shape[3],1)\nimg.shape","7551606f":"labels = np.array(label_df['people'])\nlabels","609179ba":"# setting features and target value\n\nx_train, x_test, y_train, y_test = train_test_split(img, labels, test_size=0.1)\nprint(x_train.shape[0])\nprint(x_test.shape[0])","0c86c2c7":"\"\"\"\nx_train, x_test = x_train \/ 255.0, x_test \/ 255.0\n\"\"\"","bdd6958f":"# create model \n\nmodel = tf.keras.Sequential([\n    \n    tf.keras.layers.Conv2D(64, (3,3), input_shape=(480,640,3), activation=tf.keras.activations.relu),\n    tf.keras.layers.MaxPool2D(2,2),\n    tf.keras.layers.Conv2D(128, (3,3), activation=tf.keras.activations.relu),\n    tf.keras.layers.MaxPool2D(2,2),\n    tf.keras.layers.Dropout(0.2),\n    tf.keras.layers.Flatten(),\n    tf.keras.layers.Dense(128, activation=tf.keras.activations.relu),\n    tf.keras.layers.Dense(1)\n    \n])\n\nmodel.compile(loss=tf.keras.losses.Huber(), optimizer=tf.keras.optimizers.Adam(), metrics=['mae'])\nmodel.summary()","ddebd372":"# add a learning rate monitor to get the lr with smoothest prediction\n\nlr_monitor = tf.keras.callbacks.LearningRateScheduler(\n                lambda epochs : 1e-8 * 10 ** (epochs\/20))\n","bede3e55":"# train the model \n\nhistory = model.fit(x_train, y_train, validation_data=(x_test, y_test), epochs=50, batch_size=32, callbacks=[lr_monitor])","5bd2416a":"# plot mae\nplt.semilogx(history.history['lr'], history.history['loss'])\nplt.axis([np.min(history.history['lr']), np.max(history.history['lr']), np.min(history.history['loss']), 15])\nplt.show()","8244e9a1":"np.max(history.history['lr'])","7c406e91":"# change the learning rate to 1e-5 and re-run the model\n\nmodel.compile(loss=tf.keras.losses.MeanSquaredError(), optimizer=tf.keras.optimizers.Adam(lr=1e-6), metrics=['mae'])\nmodel.summary()","d6221502":"# train the model \n\nhistory = model.fit(x_train, y_train, validation_data=(x_test, y_test), epochs=100, batch_size=32)","0b4d0dd8":"# plot mae\nplt.plot(history.history['mae'])\nplt.plot(history.history['val_mae'])\nplt.legend(['mae', 'val_mae'])\nplt.ylim(1, 4)\nplt.xlim(0, 50)\n\nplt.xticks(np.arange(0,50, 5))\n\nplt.xlabel('epochs')\nplt.ylabel('mean absolute error')\nplt.title('Mae in every epoch')\nplt.show()","86bede87":"import matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\n\n# set figure size\n\nfig = plt.figure(figsize=(15,15))\ngrid = ImageGrid(\n        fig, 111,\n        nrows_ncols=(2,2),\n        axes_pad=0.5\n)\n\nfor x in range(0,4):\n    \n    grid[x].set_title('Number of people => ' + str(labels[x]))\n    grid[x].imshow(img[x])\n    ","f4c864a8":"***IMPORTANT - if you have a higher compute power then uncomment the cell below to normalize the values else dnt normalize since the notebook will crash due to memory error***","9c177ce1":"***for practical implementation set the threashold to 20 people or so depending on the area the camera covers***\n\n**and if a certain threshold is reached then raise a red flag and clear the area**\n\n**practice social distancing and be safe**","37705661":"***seems like the model gives smooth results for (lr = 1e-6)***"}}