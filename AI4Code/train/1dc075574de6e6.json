{"cell_type":{"cfe0d6fb":"code","94c88663":"code","e16e8669":"code","ceffd356":"code","c3e3c778":"code","afc95820":"code","7b3449d1":"code","c96f8e5e":"code","02daa890":"code","5c8f97f9":"code","338c211a":"code","eac3e5b4":"code","80e7fa76":"code","91b7698b":"code","dddba40b":"code","02e1f129":"code","d973fc8f":"code","933cc6e7":"code","d3bc61c9":"code","f4593573":"markdown","ddef05c8":"markdown","37230688":"markdown","75dcb750":"markdown","7c5b256f":"markdown","db21fdf2":"markdown","5ee6df2c":"markdown","63672552":"markdown","49a27d92":"markdown"},"source":{"cfe0d6fb":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.preprocessing import StandardScaler, LabelEncoder, OneHotEncoder\nfrom sklearn.metrics import confusion_matrix, accuracy_score\nfrom sklearn.model_selection import train_test_split\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")","94c88663":"data=pd.read_csv('..\/input\/stroke-prediction-dataset\/healthcare-dataset-stroke-data.csv')","e16e8669":"data","ceffd356":"data.drop(\"id\",axis=1,inplace=True)","c3e3c778":"data.head(4)","afc95820":"# data plot function\ndef plot_bar(temp1):\n    for temp in temp1:\n        data_temp=data[[temp,'stroke']].groupby([temp] , as_index=False).mean().sort_values(by='stroke', ascending=False)\n        plt.bar(data_temp[temp],data_temp.stroke)\n        plt.ylabel('stroke')\n        plt.xlabel(temp)\n        plt.subplot()\n        plt.show()","7b3449d1":"plot_bar([\"gender\",'work_type','Residence_type','smoking_status','ever_married','heart_disease','hypertension'])","c96f8e5e":"categorical = (data.dtypes == \"object\")\ncategorical_list = list(categorical[categorical].index)\nprint(categorical_list)","02daa890":"gender_encode=LabelEncoder()\nmarried_encode=LabelEncoder()\nwork_type_encode=LabelEncoder()\nResidence_type_encode=LabelEncoder()\nsmoking_status_encode=LabelEncoder()\ndata['gender']=gender_encode.fit_transform(data['gender'])\ndata['ever_married']=married_encode.fit_transform(data['ever_married'])\ndata['work_type']=work_type_encode.fit_transform(data['work_type'])\ndata['Residence_type']=Residence_type_encode.fit_transform(data['Residence_type'])\ndata['smoking_status']=smoking_status_encode.fit_transform(data['smoking_status'])\ndata.head(5)","5c8f97f9":"plt.figure(figsize=(19,12)) \nsns.heatmap(data.corr(), annot=True, cmap='Dark2_r', linewidths = 2)","338c211a":"data.isnull().sum()","eac3e5b4":"data['bmi'] = data['bmi'].fillna(0)\ndata1=data[data['bmi']!=0]\ndata2=data[data['bmi']==0]\ntemp1_Y=data1['bmi']\ntemp1_X=data1.drop(['bmi'] , axis=1)\ntemp2_Y=data2['bmi']\ntemp2_X=data2.drop(['bmi'] , axis=1)\n\nsk=StandardScaler()\ntemp1_X = sk.fit_transform(temp1_X)\ntemp2_X = sk.transform(temp2_X)\n\nfrom sklearn.ensemble import RandomForestRegressor\nmod=RandomForestRegressor()\n\nmod.fit(temp1_X,temp1_Y)\npred=mod.predict(temp2_X)\n\nk=0\nfor i in range(len(data['bmi'])):\n    if(data['bmi'][i]==0.0):\n        data['bmi'][i]=pred[k]\n        k=k+1","80e7fa76":"data.isnull().sum()","91b7698b":"data['age'] = data['age'].apply(lambda x : round(x))","dddba40b":"Y = data[\"stroke\"]\nX=data.drop(['stroke'] , axis=1)","02e1f129":"class evaluate_all_model:\n    from sklearn.model_selection import train_test_split\n    from sklearn.linear_model import LinearRegression\n    from sklearn.neighbors import KNeighborsClassifier\n    from sklearn.linear_model import LogisticRegression\n    from sklearn.tree import DecisionTreeClassifier\n    from sklearn.ensemble import RandomForestClassifier\n    from sklearn.svm import SVC\n    from sklearn.naive_bayes import GaussianNB\n    from sklearn.naive_bayes import MultinomialNB\n    from sklearn.naive_bayes import BernoulliNB\n    from sklearn.naive_bayes import CategoricalNB\n    from sklearn.cluster import KMeans\n    from sklearn.ensemble import GradientBoostingClassifier\n    from sklearn.preprocessing import StandardScaler\n    from xgboost import XGBClassifier\n    from sklearn.metrics import confusion_matrix, accuracy_score\n    from sklearn.model_selection import train_test_split\n\n    import time\n    def __init__(self,x,y):\n        self.x=x\n        self.y=y\n        self.train_test_split()\n        self.define_models()\n        self.evaluate_model()\n        print(\"best model base on Accuracy\")\n        print(self.best_model)\n        \n    def train_test_split(self):\n        self.X_train, self.X_test, self.y_train,self.y_test = train_test_split(self.x, self.y, test_size=0.33, random_state=3)\n        sc=StandardScaler()\n        self.X_train = sc.fit_transform(self.X_train)\n        self.X_test = sc.transform(self.X_test)\n    def define_models(self):\n        self.models={'LogisticRegression': self.LogisticRegression(),\n    'RandomForestClassifier': self.RandomForestClassifier(),\n     'KNeighborsClassifier': self.KNeighborsClassifier(),\n    'DecisionTreeClassifier': self.DecisionTreeClassifier(),\n    'SupportVectorMachine':self.SVC(),\n    'GaussianNB': self.GaussianNB(),\n    'BernoulliNB': self.BernoulliNB(),\n    'GradientBoostingClassifier': self.GradientBoostingClassifier()\n                    }\n        \n        self.modelNames =['LogisticRegression', 'RandomForestClassifier','KNeighborsClassifier','DecisionTreeClassifier','SupportVectorMachine',\n                         'GaussianNB','BernoulliNB','GradientBoostingClassifier']\n        self.trainScores = []\n        self.testScores = []\n        self.Time_taken=[]\n        self.best_model_score=0\n        self.best_model={}\n        self.less_time=123\n        \n        \n    def evaluate_model(self):\n        for i in self.models:\n            start = self.time.time()\n            \n            model=self.models[i]\n            model.fit(self.X_train,self.y_train)\n            train_score = model.score(self.X_train, self.y_train)\n            self.trainScores.append(train_score)\n            print(f'Model:- {i}')\n            print(f'training score:- {train_score}')\n            test_score = model.score(self.X_test, self.y_test)\n            self.testScores.append(test_score)\n            print(f'test Score:- {test_score}')\n            \n            y_predictions = model.predict(self.X_test)\n            conf_matrix = confusion_matrix(y_predictions, self.y_test)\n            print(f'Confussion Matrix: \\n{conf_matrix}\\n')\n            \n            tn = conf_matrix[0,0]\n            fp = conf_matrix[0,1]\n            tp = conf_matrix[1,1]\n            fn = conf_matrix[1,0]\n            accuracy  = (tp + tn) \/ (tp + fp + tn + fn)\n            precision = tp \/ (tp + fp)\n            recall    = tp \/ (tp + fn)\n            f1score  = 2 * precision * recall \/ (precision + recall)\n            specificity = tn \/ (tn + fp)\n            print(f'Accuracy : {accuracy}')\n            print(f'Precision: {precision}')\n            print(f'Recall   : {recall}')\n            print(f'F1 score : {f1score}')\n            print(f'Specificity : {specificity}')\n\n            end = self.time.time()\n            time_taken=end-start\n            self.Time_taken.append(time_taken)\n            print(f'Time required {end-start}')\n            print(\"***************************************************************************\")\n            print(\"____________________________________________________________________________\")\n            print(\"\\n\\n\\n\")\n            if(float(test_score)>self.best_model_score):\n                self.best_model[\"model Name\"]=i\n                self.best_model[\"Time Required on train and test\"]=time_taken\n                self.best_model[\"Accuracy on train data\"]=train_score\n                self.best_model[\"Accuracy on test data\"]=accuracy\n                self.best_model_score=test_score\n                \n            if(time_taken<self.less_time):\n                self.less_time=time_taken\n    def plot_bar(self):\n        plt.bar(np.arange(len(self.trainScores)), self.trainScores, color='blue', width=0.25, edgecolor='white', label='train')\n        plt.bar([x + 0.25 for x in np.arange(len(self.trainScores))], self.testScores, color='red', width=0.25, edgecolor='white', label='Test')\n        plt.xlabel('Models', fontweight='bold', size = 24)\n        plt.ylabel('Scores', fontweight='bold', size = 24)\n        plt.xticks([r - 0.25 for r in range(len(self.trainScores))], self.modelNames, rotation = 60)\n        plt.legend()\n        plt.show()\n    def get_data(self):\n        self.temp_dict={}\n        self.temp_dict[\"Model\"]=self.modelNames\n        self.temp_dict[\"Training Score\"]=self.trainScores\n        self.temp_dict[\"Accuracy on Test\"]=self.testScores\n        self.temp_dict[\"Time Taken\"]=self.Time_taken\n        return self.temp_dict   \n    def get_dataframe(self):\n        return pd.DataFrame.from_dict(self.get_data()) \n            ","d973fc8f":"atul=evaluate_all_model(X,Y)","933cc6e7":"atul.get_dataframe()","d3bc61c9":"atul.plot_bar()","f4593573":"REPLACE NULL VAUES","ddef05c8":"ROUND OFF THE AGE","37230688":"Drop unnecessary index","75dcb750":"Read data from csv","7c5b256f":"Fin all the catagorical data","db21fdf2":"**FIND BEST MODEL**","5ee6df2c":"Visualize the data","63672552":"FIND NULL VALUES","49a27d92":"Importing requirements"}}