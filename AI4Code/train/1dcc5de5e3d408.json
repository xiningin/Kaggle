{"cell_type":{"1704a0a1":"code","8ee5ba01":"code","2d8449cd":"code","6680e720":"code","22d9a909":"markdown","d31133e7":"markdown","896a28fe":"markdown","a6fa5aeb":"markdown"},"source":{"1704a0a1":"import matplotlib.pyplot as plt \nimport numpy as np   \nimport matplotlib \nfrom shapely.geometry import Polygon","8ee5ba01":"W1 = 1;   #half width of link 1\nL1 = 0.1; #half thickness of link 1\n\nW2 = 0.5; #half width of link 2\nL2 = 0.1; #half thickness of link 2\n\nobstacle1 = Polygon([(1,1), (1.5,1), (1.5,1.5), (1, 1.5)])\nobstacle2 = Polygon([(-1,0), (-3,0), (-3,-0.8), (-1, -0.8), (0.1, -0.4)])\n# obstacle2 = Polygon([(-2,-0.5), (-2.5,-2), (-2.5,-2.5), (-2, -2.5)])\n\n# Making Polygon as a obstacle\nobs1 = [(1,1), (1.5,1), (1.5,1.5), (1, 1.5)]\nobs1.append(obs1[0])   #repeating the first point to create a 'closed loop'\nxs1, ys1 = zip(*obs1)  #creating lists of x and y values\n\nobs2 = [(-1,0), (-3,0), (-3,-0.8), (-1, -0.8), (0.1, -0.4)]\n# obs2 = [(-2,-0.5), (-2.5,-2), (-2.5,-2.5), (-2, -2.5)]\nobs2.append(obs2[0])  #repeating the first point to create a 'closed loop'\nxs2, ys2 = zip(*obs2) #creating lists of x and y values\n\ntheta1 = 30\ntheta2 = 20\ni = (theta1*(np.pi))\/180   #converting theta1 degree to radians for theta1\nj = (theta2*(np.pi))\/180   #converting theta2 degree to radians for theta1\n# Finding corresponding four vertices of the each link_1 and link_2\n# Link_1 has four vertices pt1, pt2 ,pt3 and pt4 \npt1_x = -L1*np.sin(i) \npt1_y = L1*np.cos(i)\npt4_x = L1*np.sin(i)\npt4_y = -L1*np.cos(i)\npt2_x = (2*W1*np.cos(i)) - L1*np.sin(i)\npt2_y = (2*W1*np.sin(i)) + L1*np.cos(i)\npt3_x = (2*W1*np.cos(i)) + L1*np.sin(i)\npt3_y = (2*W1*np.sin(i)) - L1*np.cos(i)\n\n# Link_2 has four vertices pt5, pt6 ,pt7 and pt8 \npt5_x = -L2*np.sin(i+j) + (2*W1*np.cos(i)) \npt5_y =  L2*np.cos(i+j) + (2*W1*np.sin(i)) \npt8_x =  L2*np.sin(i+j) + (2*W1*np.cos(i))\npt8_y = -L2*np.cos(i+j) + (2*W1*np.sin(i))\npt6_x = (2*W2*np.cos(i+j)) - L2*np.sin(i+j) + (2*W1*np.cos(i))\npt6_y = (2*W2*np.sin(i+j)) + L2*np.cos(i+j) + (2*W1*np.sin(i))\npt7_x = (2*W2*np.cos(i+j)) + L2*np.sin(i+j) + (2*W1*np.cos(i))\npt7_y = (2*W2*np.sin(i+j)) - L2*np.cos(i+j) + (2*W1*np.sin(i))\n\n\n# for first Link (Link_1) storing the vertices in a 2D array\nfirst_link = [(pt1_x , pt1_y), (pt2_x, pt2_y), (pt3_x, pt3_y), (pt4_x, pt4_y)]\nfirst_link.append(first_link[0]) \nxs3, ys3 = zip(*first_link) \n\n# for second Link (Link_2) storing the vertices in a 2D array\nsecond_link = [(pt5_x , pt5_y), (pt6_x, pt6_y), (pt7_x, pt7_y), (pt8_x, pt8_y)]\nsecond_link.append(second_link[0]) \nxs4, ys4 = zip(*second_link) \n\n# Drawing the plot of robot world to display the robot and some polygonal obstacle_1 and obstacle_2\nplt.figure()\nplt.grid()\nplt.fill(xs1,ys1, 'r') \nplt.fill(xs2,ys2, 'b')\nplt.fill(xs3,ys3, 'k')\nplt.fill(xs4,ys4, 'k') \nplt.xlabel('X -(distance)') \nplt.ylabel('Y -(distance)') \nplt.title('Robot World where obstacle_1(red), obstacle_2(blue), and 2 R Manipulator(red)') \nplt.show()","2d8449cd":"\n# An array named theta1 storing the angles from 0 to 2PI in increment of 0.1 radians \ntheta1 = np.arange(0, 2*(np.pi), 0.1)\n#theta1 = np.arange(0, (np.pi)\/2, 0.1)\n#theta2 = np.arange(0, (np.pi), 0.1)\ntheta2 = np.arange(0, 2*(np.pi), 0.1) #similarly for theta2\n\nl1 = 2*W1\nl2 = 2*W2\n# An array storing all the values of coodinate corresponding to theta1 and theta2  \nX = []\nY = []\nfor i in theta1:\n    for j in theta2:\n\t    X.append(l1 * np.cos(i) + l2 * np.cos(i + j))  \n\t    Y.append(l1 * np.sin(i) + l2 * np.sin(i + j))  \n   \nplt.plot(X, Y) \n# naming the x axis \nplt.xlabel('X (distance) -->') \n# naming the y axis \nplt.ylabel('Y (distance) -->') \n# giving a title to my graph \nplt.title('Robot End Effector Workspace') \nplt.grid()\nplt.show()","6680e720":"# An array named theta1 storing the angles from 0 to 2PI in increment of 0.06 radians \ntheta1 = np.arange(0, 2*(np.pi), 0.06)\ntheta2 = np.arange(0, 2*(np.pi), 0.06)\n\nTHETA1 = [] # array containing the values of theta1 where collision occurs with the obstacle of link \nTHETA2 = [] # array containing the values of theta2 where collision occurs with the obstacle of link\n\nfor i in theta1:\n    for j in theta2:\n    \t# find the corresponding coordinate of vertices of link_1 and Link_2 in ground frame\n\t    pt1_x = -L1*np.sin(i) \n\t    pt1_y = L1*np.cos(i)\n\t    pt4_x = L1*np.sin(i)\n\t    pt4_y = -L1*np.cos(i)\n\t    pt2_x = (2*W1*np.cos(i)) - L1*np.sin(i)\n\t    pt2_y = (2*W1*np.sin(i)) + L1*np.cos(i)\n\t    pt3_x = (2*W1*np.cos(i)) + L1*np.sin(i)\n\t    pt3_y = (2*W1*np.sin(i)) - L1*np.cos(i)\n\n\t    pt5_x = -L2*np.sin(i+j) + (2*W1*np.cos(i)) \n\t    pt5_y =  L2*np.cos(i+j) + (2*W1*np.sin(i)) \n\t    pt8_x =  L2*np.sin(i+j) + (2*W1*np.cos(i))\n\t    pt8_y = -L2*np.cos(i+j) + (2*W1*np.sin(i))\t    \n\t    pt6_x = (2*W2*np.cos(i+j)) - L2*np.sin(i+j) + (2*W1*np.cos(i))\n\t    pt6_y = (2*W2*np.sin(i+j)) + L2*np.cos(i+j) + (2*W1*np.sin(i))\n\t    pt7_x = (2*W2*np.cos(i+j)) + L2*np.sin(i+j) + (2*W1*np.cos(i))\n\t    pt7_y = (2*W2*np.sin(i+j)) - L2*np.cos(i+j) + (2*W1*np.sin(i))\n\n\t    rod1 = Polygon([(pt1_x, pt1_y), (pt2_x, pt2_y), (pt3_x, pt3_y), (pt4_x, pt4_y)])\n\t    rod2 = Polygon([(pt5_x, pt5_y), (pt6_x, pt6_y), (pt7_x, pt7_y), (pt8_x, pt8_y)])\n\t    if rod1.intersects(obstacle1)  or rod2.intersects(obstacle1) :\n\t        THETA1.append(i*(180\/(np.pi)))\n\t        THETA2.append(j*(180\/(np.pi)))  \n        \nplt.plot(THETA1, THETA2, 'ro') \n\nTHETA1 = [] # array containing the values of theta1 where collision occurs with the obstacle of link \nTHETA2 = [] # array containing the values of theta2 where collision occurs with the obstacle of link\n\nfor i in theta1:\n    for j in theta2:\n    \t# find the corresponding coordinate of vertices of link_1 and Link_2 in ground frame\n\t    pt1_x = -L1*np.sin(i) \n\t    pt1_y = L1*np.cos(i)\n\t    pt4_x = L1*np.sin(i)\n\t    pt4_y = -L1*np.cos(i)\n\t    pt2_x = (2*W1*np.cos(i)) - L1*np.sin(i)\n\t    pt2_y = (2*W1*np.sin(i)) + L1*np.cos(i)\n\t    pt3_x = (2*W1*np.cos(i)) + L1*np.sin(i)\n\t    pt3_y = (2*W1*np.sin(i)) - L1*np.cos(i)\n\n\t    pt5_x = -L2*np.sin(i+j) + (2*W1*np.cos(i)) \n\t    pt5_y =  L2*np.cos(i+j) + (2*W1*np.sin(i)) \n\t    pt8_x =  L2*np.sin(i+j) + (2*W1*np.cos(i))\n\t    pt8_y = -L2*np.cos(i+j) + (2*W1*np.sin(i))\t    \n\t    pt6_x = (2*W2*np.cos(i+j)) - L2*np.sin(i+j) + (2*W1*np.cos(i))\n\t    pt6_y = (2*W2*np.sin(i+j)) + L2*np.cos(i+j) + (2*W1*np.sin(i))\n\t    pt7_x = (2*W2*np.cos(i+j)) + L2*np.sin(i+j) + (2*W1*np.cos(i))\n\t    pt7_y = (2*W2*np.sin(i+j)) - L2*np.cos(i+j) + (2*W1*np.sin(i))\n\n\t    rod1 = Polygon([(pt1_x, pt1_y), (pt2_x, pt2_y), (pt3_x, pt3_y), (pt4_x, pt4_y)])\n\t    rod2 = Polygon([(pt5_x, pt5_y), (pt6_x, pt6_y), (pt7_x, pt7_y), (pt8_x, pt8_y)])\n\t    if rod1.intersects(obstacle2)  or rod2.intersects(obstacle2) :\n\t        THETA1.append(i*(180\/(np.pi)))\n\t        THETA2.append(j*(180\/(np.pi)))  \n        \n\nplt.plot(THETA1, THETA2, 'bo') \nplt.grid()\nplt.xlabel('\\u03B81  (in degrees)') \nplt.ylabel('\\u03B82  (in degrees)')  \nplt.title('Configuration Space ') \nplt.show()","22d9a909":"# **3. Generating Configuration Space**","d31133e7":"#  1. Generating Robot World with obstacles and the robot","896a28fe":"# **2. Generating Robot End Effector WorkSpace**","a6fa5aeb":"\nWe have a two-arm manipulator with two revolute joints.\nFirst step would be to import pyplot function from matplotlib library.\nThen we would need to import the numpy, matplotlib libraries, and polygonal shape from the shapely library."}}