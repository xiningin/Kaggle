{"cell_type":{"b5de2f38":"code","b5e45b08":"code","1076315e":"code","fac6011f":"code","28601dd1":"code","ea8f1da6":"code","0a21041e":"code","6a7c2098":"code","3f88de61":"code","82fc54ff":"code","d8aee0a9":"code","99843f13":"code","2e61924b":"code","eb08f685":"code","6b954781":"code","d086403a":"code","59914f71":"code","831f7577":"code","c190be10":"code","b9279384":"markdown","0e94fdf6":"markdown","0a02faa1":"markdown","3ca83d5d":"markdown"},"source":{"b5de2f38":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport os","b5e45b08":"#submission1 = pd.read_csv('\/kaggle\/input\/009383\/submission (17).csv')\n#submission2 = pd.read_csv('\/kaggle\/input\/009354\/submission (25).csv')\nsubmission1 = pd.read_csv('\/kaggle\/input\/tfidf\/submission (27).csv')\nsubmission2 = pd.read_csv('..\/input\/tpuinference-super-fast-xlmroberta\/submission (47).csv')","1076315e":"sns.set()\nplt.hist(submission1['toxic'],bins=100)\nplt.show()","fac6011f":"sns.set()\nplt.hist(submission2['toxic'],bins=100)\nplt.show()","28601dd1":"s = []\ns1 = submission1['toxic'].tolist()\ns2 = submission2['toxic'].tolist()\nfor i in range(len(s1)):\n    if s1[i]>0.5 and s2[i]<0.5:\n        s.append(s1[i])\n    else: s.append(s2[i])\nsubmission1['toxic'] = s","ea8f1da6":"#submission1['toxic'] = submission1['toxic']*0.05 + submission2['toxic']*0.95","0a21041e":"submission1.to_csv('submission.csv', index=False)","6a7c2098":"sub_path = \"..\/input\/blending\"\nall_files = os.listdir(sub_path)\nall_files","3f88de61":"outs = [pd.read_csv(os.path.join(sub_path, f), index_col=0) for f in all_files]\nconcat_sub = pd.concat(outs, axis=1)\ncols = list(map(lambda x: \"jigsaw\" + str(x), range(len(concat_sub.columns))))\nconcat_sub.columns = cols\nconcat_sub.reset_index(inplace=True)\nconcat_sub.head()\nncol = concat_sub.shape[1]","82fc54ff":"# check correlation\nconcat_sub.iloc[:,1:ncol].corr()","d8aee0a9":"corr = concat_sub.iloc[:,1:7].corr()\nmask = np.zeros_like(corr, dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\n\n# Set up the matplotlib figure\nf, ax = plt.subplots(figsize=(11, 9))\n\n# Generate a custom diverging colormap\ncmap = sns.diverging_palette(220, 10, as_cmap=True)\n\n# Draw the heatmap with the mask and correct aspect ratio\nsns.heatmap(corr, mask=mask, cmap=cmap, vmax=.3, center=0,\n            square=True, linewidths=.5, cbar_kws={\"shrink\": .5})","99843f13":"# get the data fields ready for stacking\nconcat_sub['jigsaw_max'] = concat_sub.iloc[:, 1:ncol].max(axis=1)\nconcat_sub['jigsaw_min'] = concat_sub.iloc[:, 1:ncol].min(axis=1)\nconcat_sub['jigsaw_mean'] = concat_sub.iloc[:, 1:ncol].mean(axis=1)\nconcat_sub['jigsaw_median'] = concat_sub.iloc[:, 1:ncol].median(axis=1)","2e61924b":"concat_sub.describe()","eb08f685":"cutoff_lo = 0.7\ncutoff_hi = 0.3","6b954781":"concat_sub['toxic'] = concat_sub['jigsaw_mean']\nconcat_sub[['toxic']].to_csv('submission2.csv', \n                                        index=False, float_format='%.6f')","d086403a":"concat_sub['toxic'] = concat_sub['jigsaw_median']\nconcat_sub[['toxic']].to_csv('submission1.csv', \n                                        index=False, float_format='%.6f')","59914f71":"concat_sub['toxic'] = np.where(np.all(concat_sub.iloc[:,1:ncol] > cutoff_lo, axis=1), 1, \n                                    np.where(np.all(concat_sub.iloc[:,1:ncol] < cutoff_hi, axis=1),\n                                             0, concat_sub['jigsaw_median']))\nconcat_sub[['toxic']].to_csv('submission3.csv', \n                                        index=False, float_format='%.6f')","831f7577":"concat_sub['toxic'] = np.where(np.all(concat_sub.iloc[:,1:ncol] > cutoff_lo, axis=1), \n                                    concat_sub['jigsaw_max'], \n                                    np.where(np.all(concat_sub.iloc[:,1:ncol] < cutoff_hi, axis=1),\n                                             concat_sub['jigsaw_min'], \n                                             concat_sub['jigsaw_mean']))\nconcat_sub[['toxic']].to_csv('submission4.csv', \n                                        index=False, float_format='%.6f')","c190be10":"concat_sub['toxic'] = np.where(np.all(concat_sub.iloc[:,1:ncol] > cutoff_lo, axis=1), \n                                    concat_sub['jigsaw_max'], \n                                    np.where(np.all(concat_sub.iloc[:,1:ncol] < cutoff_hi, axis=1),\n                                             concat_sub['jigsaw_min'], \n                                             concat_sub['jigsaw_median']))\nconcat_sub[['toxic']].to_csv('submission5.csv', \n                                        index=False, float_format='%.6f')","b9279384":"# phase 1 [Ensemble]","0e94fdf6":"# THIS KERNAL IS BLEND OF So awesome kernels present Right now\n# Vote if you love blend. \n# 214 forks and 55 votes !o_o!\n\n![](http:\/\/2.bp.blogspot.com\/-rO_aqkor58M\/XqZHiAN1v9I\/AAAAAAAAG5M\/VkEfBStZS90Q8nT2R9oPRT9mspMItX9WACK4BGAYYCw\/s1600\/fork.PNG)\n\n## Kernels used comming from these awesome people:\n\n[[TPU-Inference] Super Fast XLMRoberta](https:\/\/www.kaggle.com\/shonenkov\/tpu-inference-super-fast-xlmroberta)\n\n[Jigsaw TPU: BERT with Huggingface and Keras](https:\/\/www.kaggle.com\/miklgr500\/jigsaw-tpu-bert-with-huggingface-and-keras)\n\n[inference of bert tpu model ml w\/ validation](https:\/\/www.kaggle.com\/abhishek\/inference-of-bert-tpu-model-ml-w-validation)","0a02faa1":"# phase 2 [Stacking]","3ca83d5d":"# Hist Graph of scores"}}