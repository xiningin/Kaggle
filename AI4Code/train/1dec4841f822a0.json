{"cell_type":{"6d717969":"code","98ae4f77":"code","b8f518c7":"code","07c6d415":"code","70963a6c":"code","48fab1ae":"code","d994a06d":"code","f73564f4":"code","d720405c":"code","cb6e3eef":"code","c4e43219":"code","166ee6f7":"code","288c0f56":"code","5a2c7aa9":"code","fdec72c7":"code","8bca678d":"code","a6c26608":"code","063df44b":"code","5e754b9d":"code","03dee3f6":"code","02860806":"code","c5927672":"code","c7c5f833":"code","d92ca730":"code","1afdd3be":"code","982e4a38":"code","d7dd04f9":"code","cc0b1759":"code","03251478":"code","02a31f5b":"markdown","450e90c0":"markdown","da7af4e1":"markdown","cbf4aa8a":"markdown","a717dbb7":"markdown","0ef84b3b":"markdown","e3be9ef3":"markdown","3c11b476":"markdown","a5775bc6":"markdown","4dd4027d":"markdown","91f6dfcb":"markdown","08de4175":"markdown","8644c734":"markdown","d8f9c4e3":"markdown","ea0f3bc6":"markdown","4433f139":"markdown","c03911c4":"markdown","7778b617":"markdown","f5ed85a5":"markdown","43b05b3e":"markdown","2fc14c4c":"markdown","25675f34":"markdown","12e81da2":"markdown","2b910d2f":"markdown","47a05e28":"markdown","f33f95a2":"markdown"},"source":{"6d717969":"!pip install pyspark","98ae4f77":"\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","b8f518c7":"from pyspark.sql import SparkSession\n\nspark = SparkSession.builder.appName('ml-bank').getOrCreate()\nsdf = spark.read.csv('..\/input\/bankbalanced\/bank.csv', header = True, inferSchema = True)\nsdf.printSchema()","07c6d415":"sdf.count()","70963a6c":"import pandas as pd\n\npd.DataFrame(sdf.take(5), columns=sdf.columns).transpose()","48fab1ae":"sdf.toPandas().groupby(['deposit']).size()","d994a06d":"numeric_features = [t[0] for t in sdf.dtypes if t[1] == 'int']\nsdf.select(numeric_features).describe().toPandas().transpose()","f73564f4":"\nnumeric_data = sdf.select(numeric_features).toPandas()\naxs = pd.plotting.scatter_matrix(numeric_data, figsize=(8, 8));\nn = len(numeric_data.columns)\n\nfor i in range(n):\n    v = axs[i, 0]\n    v.yaxis.label.set_rotation(0)\n    v.yaxis.label.set_ha('right')\n    v.set_yticks(())\n    h = axs[n-1, i]\n    h.xaxis.label.set_rotation(90)\n    h.set_xticks(())","d720405c":"sdf = sdf.select(\n    'age', 'job', 'marital', 'education', 'default', 'balance', 'housing', 'loan', \n    'contact', 'duration', 'campaign', 'pdays', 'previous', 'poutcome', 'deposit'\n)\ncols = sdf.columns\nsdf.printSchema()","cb6e3eef":"from pyspark.ml.feature import OneHotEncoderEstimator, StringIndexer, VectorAssembler\n\nstages = []\ncategoricalColumns = [\n    'job', 'marital', 'education', 'default', 'housing', 'loan', 'contact', 'poutcome'\n]\n\nfor categoricalCol in categoricalColumns:\n    stringIndexer = StringIndexer(inputCol = categoricalCol, outputCol = categoricalCol + 'Index')\n    encoder = OneHotEncoderEstimator(\n        inputCols=[stringIndexer.getOutputCol()], \n        outputCols=[categoricalCol + \"classVec\"]\n    )\n    stages += [stringIndexer, encoder]\n    \nlabel_stringIdx = StringIndexer(inputCol = 'deposit', outputCol = 'label')\nstages += [label_stringIdx]\nnumericCols = ['age', 'balance', 'duration', 'campaign', 'pdays', 'previous']\nassemblerInputs = [c + \"classVec\" for c in categoricalColumns] + numericCols\nassembler = VectorAssembler(inputCols=assemblerInputs, outputCol=\"features\")\nstages += [assembler]","c4e43219":"from pyspark.ml import Pipeline\n\npipeline = Pipeline(stages = stages)\npipelineModel = pipeline.fit(sdf)\nsdf = pipelineModel.transform(sdf)\nselectedCols = ['label', 'features'] + cols\nsdf = sdf.select(selectedCols)\nsdf.printSchema()","166ee6f7":"pdf = pd.DataFrame(sdf.take(5), columns=sdf.columns)\npdf.iloc[:,0:2] \n","288c0f56":"len(pdf.features[0])","5a2c7aa9":"train, test = sdf.randomSplit([0.7, 0.3], seed = 2018)\nprint(\"Training Dataset Count: \" + str(train.count()))\nprint(\"Test Dataset Count: \" + str(test.count()))","fdec72c7":"from pyspark.ml.classification import LogisticRegression\n\nlr = LogisticRegression(featuresCol = 'features', labelCol = 'label', maxIter=10)\nlrModel = lr.fit(train)","8bca678d":"import matplotlib.pyplot as plt\nimport numpy as np\n\nbeta = np.sort(lrModel.coefficients)\nplt.plot(beta)\nplt.ylabel('Beta Coefficients')\nplt.show()","a6c26608":"trainingSummary = lrModel.summary\nlrROC = trainingSummary.roc.toPandas()\n\nplt.plot(lrROC['FPR'],lrROC['TPR'])\nplt.ylabel('False Positive Rate')\nplt.xlabel('True Positive Rate')\nplt.title('ROC Curve')\nplt.show()\n\nprint('Training set areaUnderROC: ' + str(trainingSummary.areaUnderROC))","063df44b":"pr = trainingSummary.pr.toPandas()\nplt.plot(pr['recall'],pr['precision'])\nplt.ylabel('Precision')\nplt.xlabel('Recall')\nplt.show()","5e754b9d":"lrPreds = lrModel.transform(test)\nlrPreds.select('age', 'job', 'label', 'rawPrediction', 'prediction', 'probability').show(10)","03dee3f6":"lrPreds.show()","02860806":"from pyspark.ml.evaluation import BinaryClassificationEvaluator\n\nlrEval = BinaryClassificationEvaluator()\nprint('Test Area Under ROC', lrEval.evaluate(lrPreds))","c5927672":"from pyspark.ml.classification import DecisionTreeClassifier\n\ndt = DecisionTreeClassifier(featuresCol = 'features', labelCol = 'label', maxDepth = 3)\ndtModel = dt.fit(train)\ndtPreds = dtModel.transform(test)\ndtPreds.select('age', 'job', 'label', 'rawPrediction', 'prediction', 'probability').show(10)","c7c5f833":"dtEval = BinaryClassificationEvaluator()\ndtROC = dtEval.evaluate(dtPreds, {dtEval.metricName: \"areaUnderROC\"})\nprint(\"Test Area Under ROC: \" + str(dtROC))","d92ca730":"from pyspark.ml.classification import RandomForestClassifier\n\nrf = RandomForestClassifier(featuresCol = 'features', labelCol = 'label')\nrfModel = rf.fit(train)\nrfPreds = rfModel.transform(test)\nrfPreds.select('age', 'job', 'label', 'rawPrediction', 'prediction', 'probability').show(10)","1afdd3be":"rfEval = BinaryClassificationEvaluator()\nrfROC = rfEval.evaluate(rfPreds, {rfEval.metricName: \"areaUnderROC\"})\nprint(\"Test Area Under ROC: \" + str(rfROC))","982e4a38":"from pyspark.ml.classification import GBTClassifier\n\ngbt = GBTClassifier(maxIter=10)\ngbtModel = gbt.fit(train)\ngbtPreds = gbtModel.transform(test)\ngbtPreds.select('age', 'job', 'label', 'rawPrediction', 'prediction', 'probability').show(10)","d7dd04f9":"gbtEval = BinaryClassificationEvaluator()\ngbtROC = gbtEval.evaluate(gbtPreds, {gbtEval.metricName: \"areaUnderROC\"})\nprint(\"Test Area Under ROC: \" + str(gbtROC))","cc0b1759":"print(gbt.explainParams())","03251478":"from pyspark.ml.tuning import ParamGridBuilder, CrossValidator\n\nparamGrid = (ParamGridBuilder()\n             .addGrid(gbt.maxDepth, [2, 4, 6])\n             .addGrid(gbt.maxBins, [20, 60])\n             .addGrid(gbt.maxIter, [10, 20])\n             .build())\n\ncv = CrossValidator(estimator=gbt, estimatorParamMaps=paramGrid, evaluator=gbtEval, numFolds=5)\n\n# Run cross validations.  \n# This can take some minutes since it is training over 20 trees!\ncvModel = cv.fit(train)\ncvPreds = cvModel.transform(test)\ngbtEval.evaluate(cvPreds)","02a31f5b":"### Pipeline\n\nWe use <code>Pipeline<\/code> to chain multiple Transformers and Estimators together to specify the **Machine Learning** workflow. A <code>Pipeline<\/code>\u2019s stages are specified as an ordered array.","450e90c0":"### Make predictions on the test set","da7af4e1":"We now have <code>features<\/code> column and <code>label<\/code> column.","cbf4aa8a":"**[Apache Spark](https:\/\/spark.apache.org\/)**, once a component of the **[Hadoop](http:\/\/hadoop.apache.org\/)** ecosystem, is now becoming the Big-Data platform of choice for enterprises. It is a powerful open source engine that provides real-time stream processing, interactive processing, graph processing, in-memory processing as well as batch processing with very fast speed, ease of use and standard interface.","a717dbb7":"**Gradient-Boosted Tree** achieved the best results, we will try tuning this model with the <code>ParamGridBuilder<\/code> and the <code>CrossValidator<\/code>. \n\nBefore that we can use <code>explainParams()<\/code> to print a list of all params and their definitions to understand what params available for tuning.","0ef84b3b":"### Evaluate the Random Forest Classifier","e3be9ef3":"Dataset classes are perfect balanced.","3c11b476":"### Summary statistics for numeric variables","a5775bc6":"## Preparing Dataset for Machine Learning\n\nThe process includes **Category Indexing**, **One-Hot Encoding** and **VectorAssembler** (a feature transformer that merges multiple columns into a vector column).\n\nThis  code  indexes each categorical column using the <code>StringIndexer<\/code>, then converts the indexed categories into *one-hot encoded* variables. The resulting output has the binary vectors appended to the end of each row. We use the <code>StringIndexer<\/code> again to encode our labels to label indices. Next, we use the <code>VectorAssembler<\/code>  to combine all the feature columns into a single vector column.","4dd4027d":"**Input variables:** age, job, marital, education, default, balance, housing, loan, contact, day, month, duration, campaign, pdays, previous, poutcome\n\n**Output variable:** deposit","91f6dfcb":"## Decision Tree Classifier\n\n**Decision trees** are widely used since they are easy to interpret, handle categorical features, extend to the multi-class classification, do not require feature scaling, and are able to capture non-linearities and feature interactions.","08de4175":"### Evaluate the Logistic Regression model","8644c734":"### Evaluate the Gradient-Boosted Tree Classifier","d8f9c4e3":"## Logistic Regression Model\n","ea0f3bc6":"## Gradient-Boosted Tree Classifier","4433f139":"## Random Forest Classifier","c03911c4":"### Evaluate the Decision Tree model\n\nOne simple decision tree performed poorly because it is too weak given the range of different features. The prediction accuracy of decision trees can be improved by Ensemble methods, such as Random Forest and Gradient-Boosted Tree.","7778b617":"It\u2019s obvious that there aren\u2019t highly correlated numeric variables. Therefore, we will keep all of them for the model. \n\nHowever, day and month columns are not really useful, we will remove these two columns.","f5ed85a5":"## Exploring Dataset\n\nWe will use the same data set when we built a [Logistic Regression](https:\/\/towardsdatascience.com\/building-a-logistic-regression-in-python-step-by-step-becd4d56c9c8\/) in Python, and it is related to direct marketing campaigns (phone calls) of a Portuguese banking institution. The classification goal is to predict whether the client will subscribe (Yes\/No) to a term deposit. The dataset can be downloaded from [Kaggle](https:\/\/www.kaggle.com\/rouseguy\/bankbalanced\/data).","43b05b3e":"# Machine Learning with PySpark and MLlib: Solving a Binary Classification Problem\n\nHere, we will learn how to build a **Binary Classification** application using **PySpark** and **MLlib Pipelines API**. \n\nWe tried **Logistic Regression**, **Decision Tree**, **Random Forest**, and **Gradient-Boosted Tree** algorithms and **Gradient Boosting Tree**  performed best on the data set.","2fc14c4c":"We can obtain the coefficients by using <code>LogisticRegressionModel<\/code>\u2019s attributes.","25675f34":"### Correlations between independent variables","12e81da2":"Summarize the model over the training set, we can also obtain the **ROC Receiver-Operating Characteristic)** and the **Area under ROC** (<code>areaUnderROC<\/code>).","2b910d2f":"### Precision and recall","47a05e28":"Have a peek of the first five observations. Pandas data frame is prettier than Spark DataFrame show() method.","f33f95a2":"### Split dataset into train and test set\n\nRandomly split data into train and test sets, and set seed for reproducibility."}}