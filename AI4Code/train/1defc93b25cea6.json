{"cell_type":{"e48297c0":"code","ef5411ca":"code","a9cccc24":"code","61f3558d":"code","8d92e8c4":"code","5becfd71":"code","3e201d21":"code","fd0efe1a":"code","b1039f2c":"code","4f7822ac":"markdown","2d6b9170":"markdown","17fef9df":"markdown","9a546b1c":"markdown","388af73d":"markdown"},"source":{"e48297c0":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom subprocess import check_output\n\n# Load the csv \ndf = pd.read_csv('..\/input\/developers-and-programming-languages\/user-languages.csv')\n\n# Remove names, to have only float values\ntry: \n    del(df['user_id'])\nexcept Exception:\n    print (\"Error\", Exception)\n    \ndf_corr = df.corr()\n\n","ef5411ca":"\"\"\"\nSelect those tecnologies which correlation to 'machine-learning' term \nis above 0.032 (3 % aprox) \n\"\"\"\nTECHNOLOGY = \"machine-learning\"\ndf_related_technologies = df_corr.loc[df_corr[TECHNOLOGY] > 0.032  ][[TECHNOLOGY]].sort_values(TECHNOLOGY)\n","a9cccc24":"tecnologies_list = df_related_technologies.index.tolist()\n\n\ndf_ml = pd.DataFrame()\ndf_ml_pivot = pd.DataFrame()\nthis_skill = pd.DataFrame()\n\n\"\"\"\nClean the data frame from those tecnologies NOT related to machine-learning\nor being too broad to have an specific meaning\n\"\"\"\n\nTOO_BROAD_TECHNOLOGIES = ['sum','graph' , 'network' , 'software', 'programming', 'curated' , 'algorithm']\nfor tecnology in tecnologies_list  :\n    if tecnology in TOO_BROAD_TECHNOLOGIES : continue \n    try: \n        df_ml[tecnology] = df[tecnology]\n    except Exception:\n        continue\n\n#this_skill =  df_ml[TECHNOLOGY]\n#del(df_ml[TECHNOLOGY])\n    \n\"\"\"\nRemove the users who do not have any of these technologies greather than a umbral\n\"\"\"\n\ndf_ml['sum'] = df_ml.sum(axis=1)\n\n\"\"\"\n We filter by : at least 25% of the skill of an user have to be \n machine learning related , excluding python (that is a too frecuent skill)\n\"\"\"\ndf_ml = df_ml.loc[df_ml['sum'] > (0.30 + df_ml['python']) ]\n# df_ml[TECHNOLOGY] =   this_skill\n    \n\n\"\"\"\n We renormalize, so each row (frecuency of all skill of a single user ) sum = 1\n Recreate sum column, because we have removed several columns\n\"\"\"\ndel(df_ml['sum'])\ndf_ml['sum'] = df_ml.sum(axis=1)\nfor index,row in df_ml.iterrows():\n    df_ml.loc[index] = row \/ row[len(row)-1]\n\n    \ndel(df_ml['sum'])\n\ndf_ml\n","61f3558d":"from string import ascii_letters\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n\"\"\"\nCompute the correlation matrix\n\"\"\" \ncorr = df_ml.corr()\n\n\n\n\"\"\"\n Chart from seaborn documentation: https:\/\/seaborn.pydata.org\/examples\/many_pairwise_correlations.html\n\"\"\"\nsns.set(style=\"white\")\n\n# Generate a mask for the upper triangle\nmask = np.zeros_like(corr, dtype=np.bool)\nmask[np.triu_indices_from(mask)] = False\n\n# Set up the matplotlib figure\nf, ax = plt.subplots(figsize=(13,11))\n\n# Generate a custom diverging colormap\ncmap = sns.diverging_palette(220, 10, as_cmap=True)\n\n# Draw the heatmap with the mask and correct aspect ratio\nsns.heatmap(corr, mask=mask, cmap=cmap, vmax=.3, center=0,\n            square=True, linewidths=.5, cbar_kws={\"shrink\": .5})\n\n\n\n","8d92e8c4":"from sklearn.metrics import silhouette_samples, silhouette_score\nfrom sklearn.cluster import KMeans\n\ndf_reduced = df_ml\n\nscores = [None,None]\nfor n_clusters in range(2,13):\n    kmeans = KMeans(n_clusters = n_clusters, random_state = 0).fit(df_reduced)\n    labels = kmeans.labels_\n    silhouette_avg = silhouette_score(df_reduced, labels)\n    print(\"For n_clusters =\", n_clusters, \"The average silhouette_score is :\", silhouette_avg)\n    scores.append(silhouette_avg)\n    \nscores\n","5becfd71":"import matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\nall_scores = scores\nplt.plot((all_scores))\nplt.title('Silhouette scores, for number of clusters')\n\nplt.show()\n","3e201d21":"import operator\nimport pandas as pd\nfrom sklearn.cluster import KMeans\n\ndf = df_ml \n\nn_clusters = 5\nkmeans = KMeans(n_clusters = n_clusters, random_state = 0).fit(df)\nlabels = kmeans.labels_#\n#   \nroles = pd.DataFrame()# Glue back to originaal data\n#\ndf['clusters'] = labels\nlabel_df = []\nfor cluster in range(n_clusters):\n    sub_df = df[df['clusters'] == cluster]\n    dict_tags = {}\n    for column in sub_df.columns:\n        if sub_df[column].sum() > 0: dict_tags[column] = sub_df[column].sum()#\n    dict_tags.pop('clusters', None)\n    sorted_dict_tags = sorted(dict_tags.items(), key = operator.itemgetter(1))\n    my_type = pd.DataFrame.from_dict(sorted_dict_tags).tail(10)\n    my_type.columns = ['Skill' , 'Weight' ]\n    print(\"Type: \", cluster , \" \" ,sub_df.shape[0]\/df.shape[0]*100 ,\" % of users\" )#\n    print(my_type)\n    new_role_element = pd.DataFrame.from_dict(sorted_dict_tags).tail(10).T.iloc[0: 2]\n    new_role_element.columns = pd.DataFrame.from_dict(sorted_dict_tags).tail(10).T.iloc[0]\n    total =  float(sub_df.shape[0])\n    new_role_element  = new_role_element.iloc[1: 2] \/ total\n    roles = pd.concat((new_role_element, roles))\n    \nroles.fillna(0, inplace=True)\n","fd0efe1a":"from math import pi\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom IPython.display import display, HTML\n\n\n\n\ndef show_graph(cat, values, title,index):\n    N = len(cat)\n    \n    COLORS=['tab:blue', 'tab:orange', 'tab:green', 'tab:red', 'tab:purple', 'tab:brown', 'tab:pink', 'tab:gray', 'tab:olive', 'tab:cyan']\n    x_as = [n \/ float(N) * 2 * pi for n in range(N)]\n\n    # Because our chart will be circular we need to append a copy of the first \n    # value of each list at the end of each list with data\n    values += values[:1]\n    x_as += x_as[:1]\n\n    # Set color of axes\n    plt.rc('axes', linewidth=0.5, edgecolor=\"#888888\")\n\n    # Create polar plot\n    plt.figure(figsize=(15,7.5))\n    ax = plt.subplot(111, polar=True)\n\n    # Set clockwise rotation. That is:\n    ax.set_theta_offset(pi \/ 2)\n    ax.set_theta_direction(-1)\n\n    # Set position of y-labels\n    ax.set_rlabel_position(0)\n\n    # Set color and linestyle of grid\n    ax.xaxis.grid(True, color=\"#888888\", linestyle='solid', linewidth=0.5)\n    ax.yaxis.grid(True, color=\"#888888\", linestyle='solid', linewidth=0.5)\n\n    # Set number of radial axes and remove labels\n    plt.xticks(x_as[:-1], [])\n\n    # Set yticks\n    #plt.yticks([20, 40, 60, 80, 100], [\"20\", \"40\", \"60\", \"80\", \"100\"])\n\n    # Plot data\n    ax.plot(x_as, values, linewidth=0, linestyle='solid', zorder=3)\n\n    # Fill area\n    ax.fill(x_as, values, 'b', alpha=0.3,color=COLORS[index])\n\n    # Set axes limits\n    plt.ylim(0,max(values))\n    plt.title(\"Skills of the developer type : \" + title)\n\n    # Draw ytick labels to make sure they fit properly\n    for i in range(N):\n        angle_rad = i \/ float(N) * 2 * pi\n\n        if angle_rad == 0:\n            ha, distance_ax = \"center\", 10\n        elif 0 < angle_rad < pi:\n            ha, distance_ax = \"left\", 1\n        elif angle_rad == pi:\n            ha, distance_ax = \"center\", 1\n        else:\n            ha, distance_ax = \"right\", 1\n        ax.text(angle_rad, max(values) + distance_ax, cat[i], size=8, horizontalalignment=ha, verticalalignment=\"center\")\n\n    # Show polar plot\n    plt.show()\n    \n    \ndef Get_Description(cat) :\n    # Return developer description for a given skill set\n    DEVELOPER_TYPES = [\n        \"Jupyter fan\",\n        \"Scala with Spark\",\n        \"C++ type\",\n        \"Python \/ Deep Learning\",\n        \"Matlab\",\n        \"Unknown\"]\n    type_index = len(DEVELOPER_TYPES)-1 # Default value\n    first = cat[len(cat)-1]\n    if \"models\"          in cat : type_index = 0\n    if \"hadoop\"          in cat : type_index = 1\n    if \"tex\"             in cat and \"torch\" in cat : type_index = 2        \n    if \"neural-network\"  in cat : type_index = 3\n    if \"computer-vision\" in cat : type_index = 4\n\n    return DEVELOPER_TYPES[type_index]\n\n\nrole_index = []    \nj = 0\nfor index, row in roles.iterrows():\n    cat = []\n    values = []\n    for column in roles.columns: \n        if  row[column] > 0 :\n            cat.append(column)\n            values.append( row[column] \/ np.sum(row) * 100  )\n    developer_description = Get_Description(cat[:10])\n    skills = pd.DataFrame()\n    skills['Skill']  = cat[:10]\n    skills['Weight'] = values[:10]\n    print (\"Developer type : \" , developer_description)\n    role_index.append(developer_description)\n    display(skills.sort_values('Weight', ascending = False ))\n                               \n    show_graph(cat = cat[:10], values = values[:10], title = developer_description,index=j )\n    j = j +1 \n    \n","b1039f2c":"from scipy.spatial.distance import squareform, pdist\nroles.index = role_index\ndisplay(roles)\n\nres = pdist(roles, 'euclidean')\nsquareform(res)\nroles_dist = pd.DataFrame(squareform(res), index=role_index, columns=role_index)\nroles_dist\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nf,ax = plt.subplots(figsize=(18, 18))\nplt.title(\"Developer type heatmap\")\nsns.heatmap(roles_dist , annot=True, linewidths=.5, fmt= '.1f',ax=ax , cmap='viridis' )","4f7822ac":"We are going to use cluster = 5, because with cluster =3 we are not going to have enough differences for the the limited skillset.\n","2d6b9170":"# Conclussion #\n\nWe have found 5 types of ML developers.\n\n*         Jupyter fan\n*         Scala with Spark\n*         C++ type\n*         Python \/ Deep Learning\n*         Matlab\n        \n- Unfortunately, 'R' language is not included in the dataset, so probably there is at least another type.\n- Deep learning is represented by tensorflow, torch, theano and keras labels.\n- Jupyter notebooks are well represented thanks to the native support in gihub.com.\n\nThanks for reading","17fef9df":"From now on, we are going to follow the steps from the kernel \"[Types of developers](https:\/\/www.kaggle.com\/jaimevalero\/types-of-developers)\"","9a546b1c":"# Find technologies related to machine learning\nWe do not have any knowledge about ML skill list, we start with the term 'machine-learning' and we will find correlated tecnologies.\nThat also means that we could change the term to find profiles for any given technology.\n","388af73d":"# Types of ML developer in github.com\n\nThe idea here is to find what type of machine learning developer types are, according their skills on github.com\n\n## Process ##\n\n- We are going to extract ML labels form the skillset of github.com. \n- Then we extract those users that have the ML labels above a thresold.\n- We clusterize by kmeans algorythm (after estimate number of cluster by silhouette method) to find how many ML developer types there are.\n- Display results and conclussion\n"}}