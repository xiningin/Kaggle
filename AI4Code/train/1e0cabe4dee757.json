{"cell_type":{"ad219e6b":"code","f1359177":"code","6d289498":"code","0f579005":"code","3ca0a123":"code","e5e4d4f8":"code","4537584c":"code","3169be94":"code","764f79be":"code","55ccada6":"markdown"},"source":{"ad219e6b":"import pandas as pd\nimport numpy as np\npd.set_option(\"display.max_rows\", None, \"display.max_columns\", None)\n\ntest_data = pd.read_csv ('\/kaggle\/input\/titanic\/test.csv')\ntrain_data = pd.read_csv(\"\/kaggle\/input\/titanic\/train.csv\")\n\nfor df in [train_data, test_data]:\n    df['Name'] = df['Name'].str.upper()\n    df['Surname'] = [df.iloc[i]['Name'].split(',')[0] for i in range(len(df))]\n    df['FirstName'] = [df.iloc[i]['Name'].split('.')[1].split('(')[0].strip() for \\\n                                                            i in range(len(df))]\n\ncombined=train_data.append(test_data)","f1359177":"##Let us try to find out all Husband\/wives on the ship. One way to\n##do it is to take each male name and search it in all the female \n##names for a match. Define the function first\n\ndef findSpouses(row):\n    findmatch=combined[(combined.Sex=='female') & (combined.Name.str.contains('\\)')) & \\\n            (combined.Surname==row['Surname']) & (combined.FirstName==row['FirstName'])]\n\n    if len(findmatch) == 1:\n        coupleid='Couple_'+ row['Surname'] + \"_\" + str(findmatch.iloc[0]['PassengerId']) \\\n                                                        + \"_\" + str(row['PassengerId'])\n        combined.loc[combined.PassengerId==findmatch.iloc[0]['PassengerId'],'Couple']=coupleid\n        combined.loc[combined.PassengerId==row['PassengerId'], 'Couple'] = coupleid\n\n        ##Also, just curious to see some anamolies..Ideally there should not be such instances\n        print('Diff Ticket: ', row['Name']) if (row['Ticket'] != findmatch.iloc[0] \\\n                                                            ['Ticket']) else None\n        print('Diff Embarked: ', row['Name']) if (row['Embarked'] != findmatch.iloc[0] \\\n                                                            ['Embarked']) else None\n        print('Diff Pclass: ', row['Name']) if (row['Pclass'] != findmatch.iloc[0] \\\n                                                            ['Pclass']) else None\n\n    elif len(findmatch) > 1:\n        print('Thankfully no such cases')\n\n##For all males, do findspouses function\ncombined[combined.Sex=='male'].apply(findSpouses, axis=1)\n\nprint('Spouses Found: ', len(combined[~combined.Couple.isnull()]))\nprint ('To be investigated:')\ncombined[~combined.Couple.isnull()].groupby('Couple').filter(lambda x: len(x)!=2)","6d289498":"##There is one case where the spouse is travelling on a different ticket\n\n##The Dodge family there is child with same name as father. Correct this anamoly manually\ncombined.loc[combined.PassengerId==1185, 'Couple'] = 'Couple_Dodge_1266_1185'.upper()\ncombined.loc[combined.PassengerId==1266, 'Couple'] = 'Couple_Dodge_1266_1185'.upper()\ncombined.loc[combined.PassengerId==446, 'Couple'] = None\n\n##We get 95 couples. Let us run one more sanity check\ncombined[(~combined.Couple.isnull()) & (combined.SibSp==0)]\n##The Ware couple seems to have incorrect SibSp. Should be 1 for the Mrs and not 0. \n##There is another genetleman with Ware surname(1298) and interestingly his SibSp is 1\n##So should we mark 1298 and 1170 as Siblings or 1254 and 1170 as couple? There are \n##equal chances for both but considering people more closely related would travel on \n##the same Ticket we assume that 1254 and 1170 are a couple.","0f579005":"##Let us draw up a list of possible couples who still need to be investigated.\n##This time we use female names as a starting point and iterate. We will check\n##across tickets like last time and not be limited to ticket groups\npossibles=combined[(combined.Sex=='female') & (combined.Couple.isnull()) & \\\n        (~combined.Name.str.contains(\"Miss\".upper())) & (combined.SibSp!=0)]\n\nprint('Possible additional couples: ', len(possibles))\n##AAh 28 possible couples. Let us investigate. Let us define the investigate \n##function first in order to call it\n\ndef investigate(row):\n    ##One option is that 'part' of the husband's name is given as wife's name\n    df=combined[(combined.Surname==row['Surname']) & (combined.Sex=='male') & (~combined.Name \\\n            .str.contains('Master'.upper())) & (combined.Name.str.contains(row['FirstName']))]\n\n    if len(df)==1:\n        print (\"First Pass: \", row['Name'],': ', row['Age'] ,'\\n', df['Name'].values[0],': ', \\\n                                                                   df['Age'].values[0], '\\n')\n        coupleid='Couple_'+ row['Surname'] + \"_\" + str(row['PassengerId']) + \"_\" + str \\\n                                                                (df['PassengerId'].values[0])\n        combined.loc[combined.PassengerId==df['PassengerId'].values[0], 'Couple'] = coupleid\n        combined.loc[combined.PassengerId==row['PassengerId'], 'Couple'] = coupleid\n        ##We get 9 couples who could be husband\/wife combination. All except Ford look correct\n        ##There is also 1 couple on separate tickets 11755 & PC 17485. Need to investigate \n        ##Ford in details later. For now rollback as this looks suspect\n        combined.loc[combined.Surname=='Ford'.upper(), 'Couple'] = np.nan\n        return\n\n    elif len(df)>1:\n        print('\\n',\"First Pass manual check:\",row['Name'],'\\n', df[['Name','SibSp','Parch']])\n        ##One case where the child too has the father's name. Let us update this manually\n        coupleid='Couple_'+ row['Surname'] + \"_\" + str(row['PassengerId']) + \"_\" + '1234'\n        combined.loc[combined.PassengerId==1234, 'Couple'] = coupleid\n        combined.loc[combined.PassengerId==row['PassengerId'], 'Couple'] = coupleid\n        return\n        ##Done with first pass. We discovered 8 new couples in all\n\n    ##Next pass is more liberal and includes cases where husband name is NOT in wifes first name\n    df=combined[(combined.Couple.isnull())&(combined.Surname==row['Surname']) & (combined.Sex \\\n                            =='male') & (~combined.Name.str.contains('Master'.upper()))]\n    if len(df)==1:\n        coupleid='Couple_'+ row['Surname'] + \"_\" + str(row['PassengerId']) + \"_\" + str( \\\n                                                                df['PassengerId'].values[0])\n        ##Assume 18 and above as valid age for marriage\n        if (df['Age'].values[0] > 18):\n            print (\"Second Pass: \", row['Name'],': ', row['Ticket'] ,'\\n', df['Name'].values \\\n                                                       [0],': ',df['Ticket'].values[0], '\\n')\n\n            ##Looks like all 4 cases are legit. Update them as couple\n            combined.loc[combined.PassengerId==df['PassengerId'].values[0], 'Couple']=coupleid\n            combined.loc[combined.PassengerId==row['PassengerId'], 'Couple'] = coupleid\n            return\n\n    elif len(df)>1:\n        print('2nd Pass - Manual check', row['Name'], '\\n', df[['Name','SibSp','Parch']],'\\n')\n        ##Both look suspect. Dont do anything for now\n\npossibles.apply(investigate, axis=1)\n\n##Neat. We get 12 additional couples taking the count to 107. The Ford, Hocking and Thomas data\n##do not point out to a husband-wife pair logically speaking\n##Any more?","3ca0a123":"#Let us get men who have () in their names containing more than one string\n##A single string indicates the name they are normally called by. So anything\n##more than 1 string needs to be investigated\ncombined[(combined.Sex=='male') & (combined.Name.str.contains('\\('))]['Name'].apply(lambda x: \\\n                            [print (x.split('(')[1]) if ' ' in x.split('(')[1] else False] )\n\n##There are 16 names which might need a bit of manual investigation\n##A quick manual check on the dataset columns shows no additional relationship can be \n##conclusively established for 14 of them based on ticket num, Parch, SibSp etc\n##Mr and Mrs Morgan are already connected by Duff Gordon surname\n##Rosenshine seems to have a old surname of Thorne. Under same ticket that Thorne is\n##travelling, there is a Mrs Thorne. However SibSp for both is 0. Could this be an error? \n##We will go ahead and assume they are a husband-wife pair as they are travellng on same ticket \n##and Thorne surname is common.\ncombined.loc[combined.PassengerId==257, 'Couple'] = 'Couple_Thorne_257_1219'.upper()\ncombined.loc[combined.PassengerId==1219, 'Couple'] = 'Couple_Thorne_257_1219'.upper()","e5e4d4f8":"##Then there are few maiden names for non-Mrs title. Let us quickly investigate\ncombined[(combined.Sex=='female') & (combined.Name.str.contains('\\('))]['Name'].apply(lambda x: [print (x.split('(')[1]) if 'Mrs'.upper() in x.split('(')[1] else False] )\n##Mrs Harbeck (248746 and 248747 are linked) and Mrs Marshall & Morley seem to be linked (250655)\n##and\u00a0as regards to Mrs DeVillers, we cant ascertain any link with anybody for sure with the \n##available data. However a\u00a0search on the same fare leads to Artagaveytia Surname though this\n##could be pure coincidence. Excluding DeVillers we have deduced 3 couples who are not related\n##directly by Surname - Thorne, Marshall and Harbeck but when studying the full name, it becomes\n##fairly apparent that they are couples travelling together and so their fate must be linked\n\n##They can be considered as married couple by looking at the whole names. Of course this is my \n##interpretation and assumption considering my end goal to create similar clusters of passengers\ncombined.loc[combined.PassengerId==200, 'Couple'] = 'Couple_Harbeck_200_1265'.upper()\ncombined.loc[combined.PassengerId==1265, 'Couple'] = 'Couple_Harbeck_200_1265'.upper()\ncombined.loc[combined.PassengerId==428, 'Couple'] = 'Couple_Marshall_428_706'.upper()\ncombined.loc[combined.PassengerId==706, 'Couple'] = 'Couple_Marshall_428_706'.upper()","4537584c":"##Any couple we missed out? \npossibles=combined[(combined.Sex=='female') & (combined.Couple.isnull()) & (~combined.Name.str.contains(\"Miss\".upper())) & (combined.SibSp==0)]\n\nlen(possibles)\n##There are 82 married females travelling alone (SibSp=0). Any chance SibSp is incorrect. Can we\n##run a sanity check? Let us define the function first\n\ndef investigateagain(row):\n    ##For this Surname are there any adult males travelling?\n    df=combined[(combined.Surname==row['Surname'])  & (combined.Couple.isnull()) & \\\n                (combined.Parch ==row['Parch']) & (combined.Sex=='male') & \\\n                (~combined.Name.str.contains('Master'.upper()))]\n\n    if len(df)>0:\n        print(row['Name'],':', row['Age'] ,'\\n',df['Name'].values,':',df['Age'].values,'\\n')\n        ##We get 7 potential couples\n        ##It is tricky but let us assume an 20 year age gap between married couple at max\n        if (abs(row['Age']-df['Age'].values[0])<20):\n            print ('< than 20 year gap', row['Name'],':',row['Age'],'\\n',df['Name'].values \\\n                                                        [0],':   ',df['Age'].values[0], '\\n')\n            ##There is only one potential and these have diff Pclass so they cant be couple\n            ##There is one more age=nan case - Reisin and this seems to be spouse as they \n            ##have same ticket and husbands partial name is in wife's name\n            ##Due to incorrect SibSp, they werent caught earlier. This is a find!\n            \npossibles.apply(investigateagain, axis=1)\n\ncombined.loc[combined.PassengerId==539, 'Couple'] = 'Couple_Risien_1274_539'.upper()\ncombined.loc[combined.PassengerId==1274, 'Couple'] = 'Couple_Risien_1274_539'.upper()","3169be94":"print('Num of couples on the Titanic: ', round(len(combined[~combined.Couple.isnull()])\/2))","764f79be":"##Yikes. This is the dreaded Nelson number. 111.. Not a good number for many cricket buffs\n##Bad coincidence\n##Logic dictaes that in any of these 111 couples - if husband survives, the wife should survive\n\ncounter=0\n\ndef survivallogic(row):\n    global counter\n    \n    print ('Exceptions to the rule: ', row) if len(combined[(combined.Couple==row['Couple']) \\\n        & (combined.Sex=='female') & (~combined.Survived.isnull()) & (combined.Survived!=1)]) \\\n        !=0 else print('No exceptions !')\n    counter+=len(combined[(combined.Couple==row['Couple']) & (combined.Sex=='female') & \\\n        (~combined.Survived.isnull())])\n    \ncond=(~combined.Couple.isnull()) & (combined.Survived==1)\ncombined[cond & (combined.Sex=='male')].apply(survivallogic, axis=1)\nprint('Number of husbands who survived:', len(combined[cond & (combined.Sex=='male')]))\nprint('Spouses of the above whose survival data is known and who have survived', counter)","55ccada6":"This is a light notebook of less than 25-30 lines where for curiosity's sake I attempted to build the couple data aboard the Titanic. Though I didnt find Jack and Rose, I ended up discovering that there were EXACTLY 111 couples aboard the Titanic (of course in the Kaggle data set). 111 is an unlucky number in cricket and if umpire David Shepherd were aboard the Titanic, he would have executed a whole retinue of peculiar mannerisms to ward off the impending bad luck. Cricket buffs would know what I am talking about :)\n\nNote: The couple data is collated from the Kaggle dataset alone without referring to external sources. In 99% of the cases it is programatically done. In remaining 1% manual check of the Kaggle dataset (other columns) was done and conclusion derived accordingly. So this may or may not tally with real world data"}}