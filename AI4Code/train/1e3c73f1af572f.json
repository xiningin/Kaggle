{"cell_type":{"c1a256df":"code","66bcc875":"code","230a447a":"code","91673a39":"code","d405ef66":"code","b115ac5a":"code","e9e2d235":"code","7fc4bada":"code","2f874fe5":"code","66f22f09":"code","5482c7c1":"code","9caa1808":"code","6655b15c":"code","db4bb379":"code","8182bec3":"code","d96c5a14":"code","c03a6466":"code","c532f195":"code","765d89e4":"code","f843f6e1":"code","4245b2e5":"code","a6acd34e":"code","c7dabec6":"code","f5bc117e":"code","14ce96a6":"code","3bf7f6fb":"code","048f7b49":"markdown","8ffcde71":"markdown","e61a98ed":"markdown","577bf3ed":"markdown","14a47696":"markdown","7b47672d":"markdown","78799eb7":"markdown","233efcb8":"markdown","5c0535bf":"markdown","1b1beb4e":"markdown","8dde9e4d":"markdown","511471b1":"markdown","a7f24f7f":"markdown","ba95c2ac":"markdown","6a564e1f":"markdown"},"source":{"c1a256df":"import os\nimport cv2\nimport time\nimport pandas as pd\nimport numpy as np\nimport re\nimport csv\n\nfrom PIL import Image\nimport torch\nimport torchvision\nimport torchvision.transforms as T\nfrom torchvision.models.detection.faster_rcnn import FastRCNNPredictor\nfrom torch.utils.data import DataLoader, Dataset\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pathlib","66bcc875":"EPOCHS = 1 #100\nTHRESHOLD = 0.5\n\nCSV_OUT = 'submission.csv'\nDIR_INPUT = \"\/kaggle\/input\/extendedlabels\/\"\nDIR_IMAGES = DIR_INPUT + \"images\/train\/\"\n\nDIR_TEST_IMAGES = \"\/kaggle\/input\/bms-molecular-translation\/train\/0\/0\/0\/\"\n# DIR_TEST_IMAGES = \"\/kaggle\/input\/bms-molecular-translation\/test\/0\/0\/\"\n\n\n### Loading Dataset\ndf = pd.read_csv(DIR_INPUT + \"images\/train_labels.csv\")\ndisplay(df.head())\ndf.describe()","230a447a":"### Null Values, Unique Values\n\nunq_values = df[\"filename\"].unique()\nprint(\"Total Records: \", len(df))\nprint(\"Unique Images: \", len(unq_values))\n\nnull_values = df.isnull().sum(axis=0)\nprint(\"\\n> Null Values in each column <\")\nprint(null_values)\n\n### Total Classes\n\nclasses = df[\"class\"].unique()\nprint(\"Total Classes: \", len(classes))\nprint(\"\\n> Classes <\\n\", classes)\n\n### Visualizing Class Distribution\n\nplt.figure(figsize=(14,8))\nplt.title('Class Distribution', fontsize=20)\nsns.countplot(x=\"class\", data=df)","91673a39":"### Function to plot image\n\ndef plot_img(image_name, image_dir, df_labels, verbose=1):\n    \n    fig, ax = plt.subplots(1, 2, figsize = (14, 14))\n    ax = ax.flatten()\n    \n    df = df_labels\n    bbox = df[df['filename'] == image_name]\n    img_path = os.path.join(image_dir, image_name)\n    \n    image = cv2.imread(img_path, cv2.IMREAD_COLOR)\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB).astype(np.float32)\n    image \/= 255.0\n    image2 = image\n    \n    ax[0].set_title('Original Image')\n    ax[0].imshow(image)\n    \n    for idx, row in bbox.iterrows():\n        x1 = row['xmin']\n        y1 = row['ymin']\n        x2 = row['xmax']\n        y2 = row['ymax']\n        label = row['class']\n        if verbose == 1:\n            print(x1, y1, x2, y2, label)\n        else: \n            pass\n        \n        cv2.rectangle(image2, (int(x1),int(y1)), (int(x2),int(y2)), (255,0,0), 1)\n        font = cv2.FONT_HERSHEY_SIMPLEX\n        cv2.putText(image2, label, (int(x1),int(y1-10)), font, 0.5, (255,0,0), 1)\n    \n    ax[1].set_title('Image with Boundary Box')\n    ax[1].imshow(image2)\n\n    plt.show()","d405ef66":"### Pass any image name as parameter\ncount = 0\nfor image in unq_values:\n    if len(image) > 9: \n        plot_img(image, DIR_IMAGES, df, verbose=0)\n        count += 1\n        if count > 5:\n            break","b115ac5a":"### Class <-> Int\n\n_classes = np.insert(classes, 0, 'background', axis=0) # adding a background class for Faseter R-CNN\nclass_to_int = {_classes[i] : i for i in range(len(_classes))}\nint_to_class = {i : _classes[i] for i in range(len(_classes))}\nprint(\"class_to_int : \\n\", class_to_int)\nprint(\"\\nint _to_class : \\n\", int_to_class)","e9e2d235":"### Creating Data (Labels & Targets) for Faster R-CNN\n\ndef get_transform():\n    return T.Compose([T.ToTensor()])\n\nclass MoleculeDetectionDataset(Dataset):\n    \n    def __init__(self, dataframe, image_dir, mode='train', transforms=None ):\n        # if mode='train' then dataframe is a dataframe with labels(classes and rectangles)\n        # if mode = 'test' then dataframe = None, model will be used for prediction \\\n        # Example for training:\n        # MoleculeDetectionDataset(image_dir, transforms=function(), dataframe=df_labels, mode='train')\n        \n        super().__init__()\n        \n        self.paths = None\n        \n        if mode == 'train':\n            self.image_names = dataframe[\"filename\"].unique()\n            \n        else: # mode == 'test'\n            if dataframe == None:\n                paths = [x for x in list(pathlib.Path(image_dir).rglob('*.png'))]\n                self.paths = paths\n                self.image_names = np.asarray([x.name for x in paths], dtype=object)\n                \n            else:\n                raise ValueError(\"Ignore input parameter 'dataframe' in a 'test' mode\")\n                \n        self.df = dataframe\n        self.image_dir = image_dir\n        self.transforms = transforms\n        self.mode = mode\n        \n    def __getitem__(self, index: int):\n        \n\n        if self.mode == 'train':\n            \n            # Retrive Image name and its records (x1, y1, x2, y2, classname) from df\n            image_name = self.image_names[index]\n\n            # Loading Image\n            image = cv2.imread(self.image_dir + image_name, cv2.IMREAD_COLOR)\n            image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB).astype(np.float32)\n            image \/= 255.0\n            \n            # # # # # # # #\n            \n            records = self.df[self.df[\"filename\"] == image_name]\n            # Get bounding box co-ordinates for each box\n            boxes = records[['xmin','ymin','xmax','ymax']].values\n            \n            # Getting labels for each box\n            temp_labels = records[['class']].to_numpy() #.value\n            labels = []\n            for label in temp_labels:\n                label = class_to_int[label[0]]\n                labels.append(label)\n                \n            # Converting boxes & labels into torch tensor\n            boxes = torch.as_tensor(boxes, dtype=torch.float32)\n            labels = torch.as_tensor(labels, dtype=torch.int64)\n            \n            # Creating target\n            target = {}\n            target['boxes'] = boxes\n            target['labels'] = labels\n            \n            # Transforms\n            if self.transforms:\n                image = self.transforms(image)\n              \n            return image, target, image_name\n        \n        elif self.mode == 'test':\n            \n            # Retrive Image name and its records (x1, y1, x2, y2, classname) from df\n            image_path = self.paths[index]\n            image_name = image_path.name\n\n            # Loading Image\n            image = cv2.imread(str(image_path), cv2.IMREAD_COLOR) \n            image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB).astype(np.float32) \n            image \/= 255.0\n            \n            #-#-#-#-#-#-#\n            \n            if self.transforms:\n                image = self.transforms(image)\n                \n            return image, image_name\n        \n    def __len__(self):\n        return len(self.image_names)\n    \n\n# test\ndataset = MoleculeDetectionDataset(image_dir=DIR_IMAGES, \n                                   transforms=get_transform(), \n                                   dataframe=df, \n                                   mode='train' )\ndataset.__getitem__(0)","7fc4bada":"### Preparing data for Train & Validation\n\ndef collate_fn(batch):\n    return tuple(zip(*batch))\n\n# Dataset object\ndataset = MoleculeDetectionDataset(dataframe=df, \n                                   image_dir=DIR_IMAGES, \n                                   transforms=get_transform(),\n                                    mode='train')\n\nindices = torch.randperm(len(dataset)).tolist()\n\ntrain_dataset = torch.utils.data.Subset(dataset, indices)\n\n# Preparing data loaders\ntrain_data_loader = DataLoader(\n    train_dataset,\n    batch_size=1, \n    shuffle=True,\n    num_workers=4, \n    collate_fn=collate_fn\n)","2f874fe5":"### Utilize GPU if available\n\n# device = torch.device('cpu') \n# device = torch.device('cuda') \ndevice = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')\ntorch.cuda.empty_cache()","66f22f09":"### Create \/ load model\n\n# Faster - RCNN Model - pretrained on COCO\nmodel = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=True)\nnum_classes = len(class_to_int)\n\n# get number of input features for the classifier\nin_features = model.roi_heads.box_predictor.cls_score.in_features\n\n# replace the pre-trained head with a new one\nmodel.roi_heads.box_predictor =  FastRCNNPredictor(in_features, num_classes)","5482c7c1":"### Preparing model for training\n\n#Retriving all trainable parameters from model (for optimizer)\nparams = [p for p in model.parameters() if p.requires_grad]\n\n#Defininig Optimizer\n# optimizer = torch.optim.SGD(params, lr = 0.25, momentum = 0.9)\noptimizer = torch.optim.SGD(params, lr = 0.005, momentum = 0.9)\n\n\nmodel.to(device)\n\n#No of epochs\nepochs = EPOCHS # 30","9caa1808":"### Training model\nimport tensorflow as tf\n\nPATH_LOAD = pathlib.Path(\"\/kaggle\/input\/modelsave\/checkpoint_save_330ext2\")\n\n\n## Save\/Load state_dict()\n# model.load_state_dict(torch.load(PATH_LOAD))\n# model.eval()\n\n## Save\/Load Entire Model\n# model = torch.load(PATH_LOAD)\n# model.eval()\n# model.train()\n\ndef load_checkpoint(PATH, \n                   model, \n                   optimizer):\n    checkpoint = torch.load(PATH, map_location=device)\n    \n    model.load_state_dict(checkpoint['model_state_dict'])\n    optimizer.load_state_dict(checkpoint['optimizer_state_dict'])\n    epoch = checkpoint['epoch']\n    loss = checkpoint['loss']\n    \n    return epoch, loss\n\n## Loading a checkpoint\n# preferred\nepoch, loss = load_checkpoint(PATH_LOAD, model, optimizer)\n\nitr = 1\ntotal_train_loss = []\n\nfor epoch in range(epochs):\n    \n    start_time = time.time()\n    train_loss = []\n\n    #Retriving Mini-batch\n    for images, targets, image_names in train_data_loader:\n        \n        #Loading images & targets on device\n        images = list(image.to(device) for image in images)\n        targets = [{k: v.to(device) for k, v in t.items()} for t in targets]\n        \n        #Forward propagation\n        out = model(images, targets)\n        losses = sum(loss for loss in out.values())\n        \n        #Reseting Gradients\n        optimizer.zero_grad()\n        \n        #Back propagation\n        losses.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1)\n        optimizer.step()\n        \n        #Average loss\n        loss_value = losses.item()\n        train_loss.append(loss_value)\n\n        \n        if itr % 25 == 0:\n            print(f\"\\n Iteration #{itr} loss: {out} \\n\")\n\n        itr += 1\n    \n    epoch_train_loss = np.mean(train_loss)\n    total_train_loss.append(epoch_train_loss)\n    print(f'Epoch train loss is {epoch_train_loss:.4f}')\n\n    \n    time_elapsed = time.time() - start_time\n    print(\"Time elapsed: \",time_elapsed)","6655b15c":"fig, axes = plt.subplots()\nfig.suptitle('Training Metrics')\n\naxes.set_ylabel(\"Loss\", fontsize=14)\naxes.plot(total_train_loss)\n\nplt.show()","db4bb379":"sum([param.nelement() for param in model.parameters()])","8182bec3":"import pathlib \nimport tensorflow as tf\n\npathlib.Path(\"\/kaggle\/working\/model\").mkdir(parents=True, exist_ok=True)\n\n# Saving a model\nPATH_SAVE = pathlib.Path('\/kaggle\/working\/model\/checkpoint_save')\n\n# ## Saving only a checkpoint\ntorch.save({\n    'epoch': epoch,\n    'model_state_dict': model.state_dict(),\n    'optimizer_state_dict': optimizer.state_dict(),\n    'loss': epoch_train_loss,},\n    PATH_SAVE)","d96c5a14":"### Preparing data for Tests\n# I try to make validation on dataset, based on code from training\n# The difference is only in the mode of data and model\n\n# Dataset object\ndataset = MoleculeDetectionDataset(dataframe=None, \n                                   image_dir=DIR_TEST_IMAGES, \n                                   mode='test', \n                                   transforms=get_transform())\n\nindices = torch.randperm(len(dataset)).tolist()\n\nvalid_dataset = torch.utils.data.Subset(dataset, indices)\n\nvalid_data_loader = DataLoader(\n    valid_dataset,\n    batch_size=4, #1,\n    shuffle=True,\n    num_workers=4, #1,\n    collate_fn=collate_fn\n)","c03a6466":"threshold = THRESHOLD # unnecessary parameter\n\n# Indicator of iterations\nitr = 1\n\n# This sets model for prediction mode, not for training\nmodel.eval()\n\nmodel.to(device) \n\nlist_ = []\ndict_row = {}\nj = 0\n    \nstart_time = time.time()\n    \n#Retriving Mini-batch\nfor images, image_names in valid_data_loader:\n     \n    #Loading images & targets on device\n    images = list(image.to(device) for image in images)\n    # Prediction based on already trained model\n    out = model(images)\n    \n    for i in range(len(out)):\n        # Converting tensors to array\n        boxes = out[i]['boxes'].data.cpu().numpy()\n        scores = out[i]['scores'].data.cpu().numpy()\n        labels = out[i]['labels'].data.cpu().numpy()\n\n        # Thresholding\n        boxes_th = boxes[scores >= threshold].astype(np.int32)\n        scores_th = scores[scores >= threshold]\n\n        # int_to_class - labels\n        labels_th = []\n        for x in range(len(labels)):\n            if scores[x] > threshold:\n                labels_th.append(int_to_class[labels[x]])\n\n        # Appending results to csv\n        for y in range(len(boxes_th)):\n\n            # Bboxes, classname & image name\n            xmin = boxes_th[y][0]\n            ymin = boxes_th[y][1]\n            xmax = boxes_th[y][2]\n            ymax = boxes_th[y][3]\n            class_name = labels_th[y]\n\n            # Creating row for df\n            dict_row[j] = {\"filename\": image_names[i], \"xmin\" : xmin, \"ymin\" : ymin, \n                   \"xmax\" : xmax, \"ymax\" : ymax, \"class\" : class_name}\n            j += 1\n\n            list_.append(image_names[i])\n            \n    itr += 1\n    \n    if itr % 50 == 0:\n        print('itr = ', itr)\n\nsubmission = pd.DataFrame.from_dict(dict_row, \"index\") # very fast approach        \ntime_elapsed = time.time() - start_time\nprint(\"Time elapsed: \",time_elapsed)","c532f195":"# list(set(list_))","765d89e4":"print('threshold = ', threshold)\ndisplay(submission.describe())\ndisplay(submission.head())","f843f6e1":"def submission_to_inchi(submission):\n    classes = ['h', 'p', 'n', 'o', 'c', 'cl', 's', 'b', 'si', 'i', 'f', 'br']\n    #CHBBrClFINOPSSi\n    ordered_output = ['c', 'h', 'b', 'br', 'cl', 'f', 'i', 'n', 'o', 'p', 's', 'si']\n    \n    list_output = [] # (file, inchi)\n        \n    files = submission['filename'].unique().tolist()\n    for file in files:\n        df = submission.loc[submission['filename'] == file]\n        labels = df['class'].tolist()\n        dictionary = {}\n        \n        for label in classes:\n            if labels.count(label) == 0:\n                continue\n            elif label == 'h':\n                dictionary[label] = ''\n            elif labels.count(label) == 1:\n                dictionary[label] = ''\n            else:\n                dictionary[label] = labels.count(label)\n                \n        formula = ''\n        for item in ordered_output:\n            if item in dictionary:\n                formula += item.title()\n                formula += str(dictionary[item])\n        \n        m = re.search(r'(.*)\\.[^.]+$', file)\n        file_name = m.group(1)\n        \n        list_output.append((file_name, 'InChI=1S\/' + formula + '\/c1\/h'))\n        \n    return list_output","4245b2e5":"# Write inchi to disk\nlist_submission = submission_to_inchi(submission)\n\n\nwith open(CSV_OUT, 'w') as out:\n    csv_out = csv.writer(out, quotechar=None)\n    csv_out.writerow(['image_id', 'InChI'])\n    for row in list_submission:\n        csv_out.writerow(row)","a6acd34e":"## Displaying Test Images\nfilepath_image_list = list(pathlib.Path(DIR_TEST_IMAGES).rglob('*.png'))\nfilepath_image_list.sort()\nimage_test = [x.name for x in filepath_image_list]\n\ncount = 0\nfor image in image_test:\n    if len(image) > 9: \n        plot_img(image, DIR_TEST_IMAGES, submission, verbose=0)\n        print(image)\n        count += 1\n        # limit output files to ...\n        if count > 5:\n            break","c7dabec6":"raise SystemExit(\"Stop right there!\")","f5bc117e":"import re\nimport pandas as pd\nimport unittest\n\nclass Test02(unittest.TestCase):\n    def test_01(self):\n        submission = pd.DataFrame({'filename': [\n                        '003781e47d63.png', \n                       '003781e47d63.png',\n                       '003781e47d63.png',\n                       '002781e47d63.png',\n                       '003781e47d63.png'],\n            'class': ['c', 'c', 'h', 'h', 'c'],\n           'xmin': [159, 191, 197, 159, 75],\n           'ymin': [115, 41, 114, 44, 112],\n           'xmax': [187, 225, 229, 186, 108],\n           'ymax': [142, 72, 143, 76, 140]\n          })\n        \n        list_ = submission_to_inchi(submission)\n        print(list_)\n        \n    def test_02(self):\n        submission = pd.DataFrame({'filename': [\n                        '003781e47d63.png', \n                       '003781e47d63.png',\n                       '003781e47d63.png',\n                       '003781e47d63.png',\n                       '003781e47d63.png'],\n            'class': ['c', 'c', 'p', 'p', 'c'],\n           'xmin': [159, 191, 197, 159, 75],\n           'ymin': [115, 41, 114, 44, 112],\n           'xmax': [187, 225, 229, 186, 108],\n           'ymax': [142, 72, 143, 76, 140]\n          })\n        \n        list_ = submission_to_inchi(submission)\n        print(list_)\n        \n        \nunittest.main(argv=[''], verbosity=2, exit=False)","14ce96a6":"submission.to_csv('submission.csv', index=False)","3bf7f6fb":"# Clear the directory\n\nimport os\nimport glob\n\nfiles = glob.glob('\/kaggle\/working\/*')\nfor f in files:\n    os.remove(f)","048f7b49":"## Table of Contents\n* [Introduction](#introduction)\n* [Details of the Problem](#details-of-the-problem)\n* [Visualise Random Images with Boundary Box](#visualise-random-images)\n* [Preparing Dataset for Training](#preparing-dataset-training)\n* [Create Model - ResNet50(Faster R-CNN)](#create-model-resnet50)\n* [Preparing Model for Training](#preparing-model-for-training)\n* [Training](#let's-train-it)\n* [Calculation on unlabeled data](#calculation-on-unlabeled-data)","8ffcde71":"### Training<a class=\"anchor\" id=\"let's-train-it\"><\/a>","e61a98ed":"For labeling I used 2 tools, easy to use.\n\n[labelImg](https:\/\/github.com\/tzutalin\/labelImg)\n\n[xml_to_csv](https:\/\/github.com\/EdjeElectronics\/TensorFlow-Object-Detection-API-Tutorial-Train-Multiple-Objects-Windows-10\/blob\/master\/xml_to_csv.py)","577bf3ed":"**Hydrogen in molecular formula.** Hydrogen can't be detected from the picture, there is no signs for hydrogen. I don't mean chemical groups such as NH, NH2, OH, ... Hydrogen that is connected to carbon has no signs. It should be calculated.\n\nCaclulation of hydrogen needs information about structure of a molecule. So, calculation of hydrogen is a complex task, much harder, than caclulation of carbon atoms!\n\nI think, it is too complex to solve it. That is why I didn't print hydrogen amount.","14a47696":"### Create Model - ResNet50(Faster R-CNN)<a class=\"anchor\" id=\"create-model-resnet50\"><\/a>","7b47672d":"## Introduction<a class=\"anchor\" id=\"introduction\"><\/a>","78799eb7":"\nAll organic molecules have one of the twelve atoms:\n\n'C', 'H', 'O', 'S', 'N', 'Br', 'F', 'Cl', 'P', 'Si', 'B', 'I'","233efcb8":"<img src=\"https:\/\/cdn.pixabay.com\/photo\/2014\/07\/31\/21\/42\/industry-406905_960_720.jpg\" width=\"900px\">","5c0535bf":"Recognizing molecules and composing the full inchi solution seemed to be a very complex task.\nInchi has several levels of information. Being self-assured is not a successful mindset.\nI decided to accomplish the first part of inchi, the molecular formula.\nSo I concentrated my efforts on uncovering the molecular formula.\nMy problem is to recognize atoms, make some calculations, return molecular formula.\nSo the problem is mostly about object detection. \n\nSeems very easy. \nBut there are a lot of options. Which objects are the most useful, what objects should be recognized?\nThere are many of them. I thought about it for a long time. Finally, I realized that I am capable of accomplishing of something very simple.\nComplexity makes the code much larger. \nMy model is to recognize atoms from the depiction of a molecule.","1b1beb4e":"### Details of the Problem<a class=\"anchor\" id=\"details-of-the-problem\"><\/a>","8dde9e4d":"## Calculation on Unlabeled Data<a class=\"anchor\" id=\"calculation-on-unlabeled-data\"><\/a>","511471b1":"ResNet is one the latest successful architectures, probably the better solution is DenseNet. I compared the scores of neural networks. \n\nFor everybody who is new to Faster R-CNN, I insert a couple of links. \n\n[Faster R-CNN: Towards Real-Time ObjectDetection with Region Proposal Networks](https:\/\/arxiv.org\/pdf\/1506.01497.pdf)\n\n[TorchVision](https:\/\/pytorch.org\/tutorials\/intermediate\/torchvision_tutorial.html)","a7f24f7f":"## Visualise Random Images with Boundary Box<a class=\"anchor\" id=\"visualise-random-images\"><\/a>","ba95c2ac":"### Preparing Model for Training<a class=\"anchor\" id=\"preparing-model-for-training\"><\/a>","6a564e1f":"### Preparing Dataset for Training<a class=\"anchor\" id=\"preparing-dataset-training\"><\/a>"}}