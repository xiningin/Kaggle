{"cell_type":{"5378d5e4":"code","0b26b831":"code","f357073c":"code","c0653e82":"code","81cf90c9":"code","cea38ef2":"code","dc983cb8":"code","70746227":"code","44aa3828":"code","a7fa5ed2":"code","fde12f22":"code","40edd22f":"code","e70d49cf":"code","1121a420":"code","39bd2c69":"code","afc41d21":"code","8587269f":"code","00dca015":"code","b9adff17":"code","07322465":"code","b189b9a9":"code","73c9ea76":"code","93525f84":"code","31bf7399":"code","427cb305":"code","36b283cd":"code","4fb10a32":"code","8e5ecdef":"code","a6e9cc2f":"code","1d003104":"code","5311f5a4":"code","8a92d10d":"code","1ba17ce9":"code","a5085806":"code","2089d56b":"code","dc975b93":"code","e50435c4":"code","054d9ac5":"code","14cdfd44":"code","15dbf94e":"code","04533000":"code","280da4c0":"code","cd885fb8":"code","eb91f22e":"code","3831e19c":"code","bc35666b":"code","a3b032c2":"code","f6915679":"code","90862a1c":"code","bf730229":"code","0c9bce55":"code","d81e4c0d":"code","d7446794":"code","c6ead024":"code","13c3419e":"code","9b063a89":"code","430eda40":"code","05978fe4":"code","339d97cb":"code","1ef7cf21":"code","e60d26bf":"code","4b0b2017":"code","c986b534":"code","bf316e24":"code","b3f9a040":"code","bdc20708":"code","9fafbfc8":"code","2d5eef95":"code","c81c9fe2":"code","375fd7d9":"code","3bb4b0d0":"markdown","f4a37766":"markdown","e664d414":"markdown","a3900256":"markdown","3e2a1d4a":"markdown","91126c93":"markdown","6d6e2efb":"markdown","7a3aa657":"markdown","6ce310a3":"markdown","7806f16d":"markdown","b8bc7e46":"markdown","cf5976dc":"markdown","b467fa2c":"markdown","5c55675a":"markdown","ef1ac87e":"markdown","b56b2831":"markdown","6239e865":"markdown","2d770f1e":"markdown","5ebb5423":"markdown","a173f0d2":"markdown","c1cbec47":"markdown","8a585427":"markdown","ff16a080":"markdown","4abf596b":"markdown","22af2a27":"markdown","9a4cf65c":"markdown","8f49d0d2":"markdown","133f431f":"markdown","46d61d29":"markdown","cd428948":"markdown","302aa636":"markdown","12e7e5c4":"markdown","c7f6ecd2":"markdown","ebec1ceb":"markdown","2be66225":"markdown","89026bc4":"markdown","c885b271":"markdown"},"source":{"5378d5e4":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\n# linear algebra\nimport numpy as np \n\n# data processing, CSV file I\/O (e.g. pd.read_csv)\nimport pandas as pd \n\n# plotting modules\nimport matplotlib.pyplot as plt \n# %matplotlib inline \n# ^to display the map within the notebook\nimport seaborn as sns # visualisation library\npd.options.display.max_columns = None\npd.plotting.register_matplotlib_converters() # to ensure that pandas datatypes can be used in matplotlib plots \n\n# for Box-cox Transformation\nfrom scipy import stats\n\n# for min_max scaling\nfrom mlxtend.preprocessing import minmax_scaling\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","0b26b831":"# Add dataset to Kaggle nitebook using sidebar (Add data) first\nTC_raw = pd.read_csv(\"..\/input\/ashrae-global-thermal-comfort-database-ii\/ashrae_db2.01.csv\")","f357073c":"# Using shape attribute to check how large (dimensions) the DataFrame is\nTC_raw.shape","c0653e82":"# Info method prints information about a DataFrame including the index dtype and columns, non-null values and memory usage.\nTC_raw.info()","81cf90c9":"# Examining the contents of first 5 rows using .head() command\n# The command truncates the columns for shorter display as there are 70 of them in this datasaet\n# To show all columns, I used set_option() command that sets the printing options for the code\npd.set_option('display.max_columns', None)\nTC_raw.head() \nTC_raw.tail()","cea38ef2":"TC = TC_raw[['Season','Climate', 'City', 'Country',\n       'Building type', 'Cooling startegy_building level',\n       'Cooling startegy_operation mode for MM buildings','Heating strategy_building level', 'Age', 'Sex','Thermal sensation',\n       'Thermal sensation acceptability', 'Thermal preference','Air movement acceptability', 'Air movement preference',\n       'Thermal comfort','Met','Clo','Air temperature (C)', 'Operative temperature (C)', 'Radiant temperature (C)', 'Globe temperature (C)', 'Relative humidity (%)', 'Humidity preference',\n       'Humidity sensation', 'Air velocity (m\/s)','Subject\u00abs height (cm)', 'Subject\u00abs weight (kg)',\n       'Fan', 'Window', 'Heater','Outdoor monthly air temperature (C)']]","dc983cb8":"Koppen = list(TC_raw['Koppen climate classification'].unique())\nClim = list(TC_raw['Climate'].unique())\nlen(Clim)\nlen(Koppen)\nprint(TC_raw['Cooling startegy_operation mode for MM buildings'].unique())\nTC_raw['Heater'].unique()","70746227":"TC.describe()\nTC['Season'].describe() #String\nTC['Thermal sensation acceptability'].describe() # Numerical\nTC['Thermal sensation acceptability'].mean() #Numerical","44aa3828":"TC['Cooling startegy_building level'].dtypes\nTC.dtypes\nTC.index.dtype","a7fa5ed2":"# The columns are like propertes of the dataframe\n# To access the property say 'Season', we can use the indexing [] operator\n# It is similar to accessing values in a python dictionary\n\nTC['Season'] == TC.iloc[:, TC.columns.get_loc('Season')]\n\n# A particular row in this coloumn can be selected by another indexing operator OR\n# iloc: selecting data based on its numerical position in the data (row-first, column-second)\n\nTC['Season'][5] == TC.iloc[5, TC.columns.get_loc('Season')] == TC['Season'].iloc[5]\n","fde12f22":"(TC['Cooling startegy_building level'].isin(['Naturally Ventilated', 'Mixed Mode'])) == ((TC['Cooling startegy_building level'] == 'Mixed Mode') | (TC['Cooling startegy_building level'] == 'Naturally Ventilated'))","40edd22f":"# get the number of missing data points per column\nTC1.isnull().sum()","e70d49cf":"# how many total missing values do we have?\ntotal_cells = np.product(TC1.shape)\ntotal_missing = (TC1.isnull().sum()).sum()\n\n# percentage of missing data\npercent_missing = (total_missing\/total_cells)*100\nprint(percent_missing)","1121a420":"# # I can also create a dataset out of only those rows that have no null values in a particular column \nTC_noNullCol = TC1[pd.notnull(TC1['Heating strategy_building level'])]\nTC_noNullCol.head()","39bd2c69":"# Remove all rows that contain a missing value\nTC1.dropna()\n\n# OOPS it has removed all the data! This is because every row in our dataset had at least one missing value. ","afc41d21":"# remove all columns with at least one missing value\nTC1.dropna(axis=1).head()\n\n# how much data did we lose?\nprint(\"Columns in original dataset: %d \\n\" % TC1.shape[1])\nprint(\"Columns with na's dropped: %d\" % (TC1.dropna(axis=1).head()).shape[1])","8587269f":"print('Before applying fillna - ')\nprint(TC1['Heating strategy_building level'].unique())\n\nTC1['Heating strategy_building level'].fillna(\"Unknown\", inplace=True)\nprint('After applying fillna - ')\nprint(TC1['Heating strategy_building level'].unique())","00dca015":"print('Various cooling strategies are:', TC['Cooling startegy_building level'].unique(), '\\n')\n\nprint('The room settings in Mixed mode building is:', TC['Cooling startegy_operation mode for MM buildings'].unique(), '\\n')\n\nprint('Data values if we disregard the Mixed mode rooms is:\\n', TC['Cooling startegy_building level'].value_counts(dropna=False), '\\n')\n\nprint('More values can be added to the dataset if we include MM scenarios in AC and NV:\\n', TC['Cooling startegy_operation mode for MM buildings'].value_counts(), '\\n')","b9adff17":"#Check 1:  Are there any rooms that are not MM but still have an MM value? (No there aren't. All fields in MM are null except for mixed mode rooms.)\nTC[(TC['Cooling startegy_building level'] != 'Mixed Mode') & (pd.notnull(TC['Cooling startegy_operation mode for MM buildings']))]","07322465":"# Replacing 'Mixed Mode' values in 'Cooling strategy' as either AC or NV\n\n# Using apply function \n# I am passing each row of the dataframe into the apply function. In each row the cell in 'CombinedStrat' takes 'row['Cooling startegy_operation mode for MM buildings']' value as per the if else clause. For more elaborate explanations on apply an dmap functions, refer to https:\/\/www.kaggle.com\/ttalwar\/map-and-apply-discussion\/edit\n\n# TC.head().apply(lambda row: print(row), axis=0) # A quick debugging step. \nTC['CombinedStrat'] = TC.apply(lambda row: row['Cooling startegy_operation mode for MM buildings'] if row['Cooling startegy_building level'] == 'Mixed Mode' else row['Cooling startegy_building level'], axis=1)\n\n# After filtering only 'mixed mode' rooms, a visual inspection of dataframe shows that the new CombinedStrat column has accurate values\nTC[TC['Cooling startegy_building level'] == 'Mixed Mode']\n\n# Final value counts of CombinedStrat column are summations of column 'Cooling startegy_building level' and 'Cooling startegy_operation mode for MM buildings'\nTC['CombinedStrat'].value_counts(dropna=False)\n","b189b9a9":"# Dropping the original cooling strategy and MM columns\nTC1 = TC.drop(['Cooling startegy_building level', 'Cooling startegy_operation mode for MM buildings'], axis=1)\n\n# Renaming 'CombinedStrat' column to 'Cooling strategy_room'. Make sure inplace=True to modify the dataframe \nTC1.rename(columns = {'CombinedStrat': 'Cooling strategy_room'}, inplace = True)\n\n# Dropping rows with unknown room cooling strategy or mechanically ventilated rooms\nTC1 = TC1[(TC1['Cooling strategy_room'] == 'Air Conditioned') | (TC1['Cooling strategy_room'] == 'Naturally Ventilated')]\n\nTC1['Cooling strategy_room'].value_counts(dropna=False)","73c9ea76":"# An argument for dropping seasons and not considering building heating. \n\n# While we convniently dropped NaN entries in the column 'Cooling startegy_building level', we inadvertantly removed data of those buildings that 'may not require cooling but only heating' or those buildings that 'may not have values for cooling strategy but did for mechanical heating'. \n\n# There are a total of 37765 values for Mechanical Heating \nTC['Heating strategy_building level'].value_counts(dropna=False)\n\n# Out of these,there are 1010 buildings that have information on only Mechanical Heating.  \n# As can be expected, they are only for places where cooling strategies may be secondary to Heating strategies\nTC[(TC['Heating strategy_building level']=='Mechanical Heating') & (pd.isnull(TC['Cooling startegy_building level']))].shape\n# BUT even though winter is the most prominent season in this 'mechanical heating' dataframe, we observe that only two climate categories are affected by this data, neither of which are extreme cold zones.\nTC[(TC['Heating strategy_building level']=='Mechanical Heating') & (pd.isnull(TC['Cooling startegy_building level']))].groupby('Season').Season.count()\nTC[(TC['Heating strategy_building level']=='Mechanical Heating') & (pd.isnull(TC['Cooling startegy_building level']))].groupby('Climate').Climate.count()\n\n# On comparing outdoor temperature during different seasons in the two dataframes (TC and TC1) we notice unexpected minimum temperatures during some seasons (like -5.7C in autumn). This could be due to erroneous values or may require additional data\/research for explanation. \nTC[(TC['Heating strategy_building level']=='Mechanical Heating') & (pd.isnull(TC['Cooling startegy_building level']))].groupby('Season')['Outdoor monthly air temperature (C)'].min()\n\n# Also, since AC does not change modes in different seasons i.e. no data whether it will be switched on during summers and\/or switched off to be replaced by heater, no detailed insights can be drawn on the two columns.\n\n# For these reasons, we will constrict our study of 'geographical location' as per climate and not seasons. Also, the classification of buildings will not include heating.\n# TC1 = TC1.drop(['Season', 'Heating strategy_building level'], axis=1)\n","93525f84":"# Creating two datasets for AC and NV rooms\nTC1_AC = TC1[TC1['Cooling strategy_room']=='Air Conditioned']\nTC1_NV = TC1[TC1['Cooling strategy_room']=='Naturally Ventilated']\n\nprint(TC1_AC['Cooling strategy_room'].value_counts())\nprint(TC1_NV['Cooling strategy_room'].value_counts())","31bf7399":"# Before being able to work on these dataframes, we need to check and clean the immportant columns.\n# Starting with Thermal sensation, comfort and preference. \n\nTC1_AC.columns\nTC1_AC['Thermal sensation'].unique()\nTC1_AC['Thermal comfort'].unique()\nTC1_AC['Thermal preference'].unique()","427cb305":"# Expected value should be integer or float.\nTC1_AC['Thermal sensation'].dtype ","36b283cd":"# Expected value should be integer or float.\nTC1_AC['Thermal comfort'].dtype\n# it is dtype('O') i.e. object or a mix of integers, strings or NaN\n\n# The unique values show that some number are strings like '2.6'. There are also empty strings ' '. Though a string numeral can be converted to integer, the empty string cannot. \n\n# Replacing empty strings by NaN value using 'loc'\nTC1_AC.loc[TC1_AC['Thermal comfort']==' ', 'Thermal comfort'] = np.NaN\n\n# Changing strings to numerals\nTC1_AC['Thermal comfort'] = TC1_AC['Thermal comfort'].astype(float)\n\nTC1_AC['Thermal comfort'].dtype","4fb10a32":"# Expected value should be integer or float.\nTC1_NV['Thermal comfort'].dtype\n# it is dtype('O') i.e. object or a mix of integers, strings or NaN\nTC1_NV['Thermal comfort'].unique()\n# The unique values show that some number are strings like '2.6'. There are also an unexpected 'Na'. Though a string numeral can be converted to integer, 'Na' needs to be removed.\n\n# Replacing 'Na' strings by NaN value using 'loc'\nTC1_NV.loc[TC1_NV['Thermal comfort']=='Na', 'Thermal comfort'] = np.NaN\nTC1_NV.loc[TC1_NV['Thermal comfort']==' ', 'Thermal comfort'] = np.NaN\n\n# Changing strings to numerals\nTC1_NV['Thermal comfort'] = TC1_NV['Thermal comfort'].astype(float)\n\nTC1_NV['Thermal comfort'].dtype","8e5ecdef":"# Expected value should be integer or float.\nTC1_AC['Thermal preference'].dtype\n# it is dtype('O') i.e. object or a mix of integers, strings or NaN\n\n# The unique values show that there are three strings but also NaN which maybe why the type is object. Check again after dropping NaN\n","a6e9cc2f":"print('AC Dataframe with null values is:', TC1_AC.shape)\nprint('NV Dataframe with null values is:', TC1_NV.shape)\n\n# Dropping null values in Thermal sensation\nTC2_AC = TC1_AC[pd.notnull(TC1_AC['Thermal sensation'])]\nTC2_NV = TC1_NV[pd.notnull(TC1_NV['Thermal sensation'])]\n\n# Dropping null values in Thermal comfort (from the dataframe in the previous line ie TC2_AC once null values in Thermal sensation have been removed)\nTC2_AC = TC2_AC[pd.notnull(TC2_AC['Thermal comfort'])]\nTC2_NV = TC2_NV[pd.notnull(TC2_NV['Thermal comfort'])]\n\n# Dropping null values in Thermal preference\nTC2_AC = TC2_AC[pd.notnull(TC2_AC['Thermal preference'])]\nTC2_NV = TC2_NV[pd.notnull(TC2_NV['Thermal preference'])]\n\nprint('AC Dataframe without null values is:', TC2_AC.shape)\nprint('NV Dataframe without null values is:', TC2_NV.shape)","1d003104":"TC2_AC.groupby('Climate')['Climate'].count()\nTC2_AC.groupby('Climate').Country.unique()\nTC2_AC.groupby('Country').Climate.nunique()","5311f5a4":"# groupby is a special object that is comparable to a bunch of dataframes put together. \nm = list(TC2_AC.groupby('Country'))\nprint(m[0])","8a92d10d":"print(TC2_AC.groupby('Climate').apply(lambda df: df['Outdoor monthly air temperature (C)'].min()))\n\nTC2_AC.groupby('Climate')['Outdoor monthly air temperature (C)'].agg([len, min, max])","1ba17ce9":"TC2_AC.groupby(['Climate', 'Season'])['Outdoor monthly air temperature (C)'].min()\n\n# TC2_AC.groupby(['Climate','Building type'])['Building type'].size()\n\nTC2_AC['Outdoor monthly air temperature (C)'].value_counts(bins=5, sort=False)\n\nTC2_AC[(TC2_AC['Outdoor monthly air temperature (C)'] < TC2_AC['Air temperature (C)']) & (TC2_AC['Season']=='Summer')]['Country'].value_counts()","a5085806":"Multi_Index = TC2_AC.groupby(['Climate', 'Season'])['Air temperature (C)'].agg([len, min, max])\nprint(type(Multi_Index.index))\nprint(Multi_Index.iloc[:5], '\\n')\n\n\nSingle_Indice = Multi_Index.reset_index()\nprint(type(Single_Indice.index))\nprint(Single_Indice.iloc[:5])\n","2089d56b":"# To sort values by a column, here 'min'\nSingle_Indice.sort_values(by='min')\n\n#T0 sort by the column but in descending order\nSingle_Indice.sort_values(by='min', ascending=False)\n\n# To sort by index values, use the companion method `sort_index()`. This method has the same arguments and default order:\nSingle_Indice.sort_index\n\n# To sort with more than one column. First the list is sorted by Climate, and because there is a repetition in that column, it gets sorted by 'min'\nSingle_Indice.sort_values(by=['Climate', 'min'])","dc975b93":"TC2_AC.columns","e50435c4":"TC2_AC['Fan'].value_counts(dropna=False)\nTC2_NV['Fan'].value_counts(dropna=False)\n\nTC2_AC.groupby(['Fan','Climate'])['Climate'].count()","054d9ac5":"TC2_AC['Fan'].dtypes\nTC2_AC_FON = TC2_AC[TC2_AC['Fan'] == 1.]\nTC2_AC_FOFF = TC2_AC[TC2_AC['Fan'] == 0.]\nTC2_NV_FON = TC2_AC[TC2_AC['Fan'] == 1.]\nTC2_NV_FOFF = TC2_AC[TC2_AC['Fan'] == 0.]","14cdfd44":"# 'Thermal sensation', 'Thermal sensation acceptability', 'Thermal preference'\nTC2_AC_FON.columns\nTC2_AC_FON['Thermal sensation'].unique()\nTC2_AC_FON.shape","15dbf94e":"TC2_AC_FON['Fan'].unique()","04533000":"# ERROR \n# sns.factorplot(\"Fan\", \"Thermal sensation\", col='Climate', col_order=['Humid subtropical', 'Hot semi-arid', 'Tropical wet savanna',\n#        'Monsoon-influenced humid subtropical'], data=TC2_AC, kind='bar');\n\n# sns.factorplot(\"Fan\", \"Thermal comfort\", col='Climate', col_order=['Humid subtropical', 'Hot semi-arid', 'Tropical wet savanna',\n#        'Monsoon-influenced humid subtropical'], data=TC2_AC, kind='bar');\n\n# sns.factorplot(\"Fan\", \"Thermal preference\", col='Climate', col_order=['Humid subtropical', 'Hot semi-arid', 'Tropical wet savanna',\n#        'Monsoon-influenced humid subtropical'], data=TC2_AC, kind='bar');\n\n# sns.factorplot(\"Fan\", \"Thermal sensation\", col='Climate', data=TC2_AC, kind='bar');","280da4c0":"concatenated = pd.concat([TC2_AC_FON.assign(dataset = 'TC2_AC_FON'), TC2_AC_FOFF.assign(dataset = 'TC2_AC_FOFF')])\nsns.scatterplot(x = 'Thermal comfort', y = 'Thermal sensation', data = concatenated, style = 'dataset')\nplt.show()","cd885fb8":"concatenated = pd.concat([TC2_AC_FON.assign(dataset = 'TC2_AC_FON'), TC2_AC_FOFF.assign(dataset = 'TC2_AC_FOFF')])\nsns.scatterplot(x = 'Thermal comfort', y = 'Air temperature (C)', data = concatenated, style = 'dataset')\nplt.show()","eb91f22e":"TC2_NV.groupby(['Fan','Climate'])['Climate'].count()\n\n# We will do the same process for naturally ventilated buildings","3831e19c":"# Thermal sensation: Fans ON\n\nTSense_FON = TC2_AC_FON['Thermal sensation'].value_counts(bins=[-4, -3, -2, -1, 0, 1, 2, 3]).sort_index().rename_axis('TSense Range').reset_index(name='counts')\ntype(TSense_FON)\nTSense_FON.dtypes\n\nTSense_FON['TSense Range'].dtypes\nTSense_FON['TSense'] = TSense_FON['TSense Range'].map(lambda p: p.right)\nTSense_FON['counts'].sum() #1340\nTSense_FON['TSensePR'] = TSense_FON['counts']\/TSense_FON['counts'].sum()\nTSense_FON","bc35666b":"# Thermal sensation: Fans OFF\n\nTSense_FOFF = TC2_AC_FOFF['Thermal sensation'].value_counts(bins=[-4, -3, -2, -1, 0, 1, 2, 3]).sort_index().rename_axis('TSense Range').reset_index(name='counts')\ntype(TSense_FOFF)\nTSense_FOFF.dtypes\n\nTSense_FOFF['TSense Range'].dtypes\nTSense_FOFF['TSense'] = TSense_FOFF['TSense Range'].map(lambda p: p.right)\nTSense_FOFF['counts'].sum() #1340\nTSense_FOFF['TSensePR'] = TSense_FOFF['counts']\/TSense_FOFF['counts'].sum()\nTSense_FOFF","a3b032c2":"# Thermal sensation: Fans OFF\n\nTSense_FOFF = TC2_AC_FOFF['Thermal sensation'].value_counts(bins=[-4, -3, -2, -1, 0, 1, 2, 3]).sort_index().rename_axis('TSense Range').reset_index(name='counts')\ntype(TSense_FON)\nTSense_FOFF.dtypes\n\nTSense_FOFF['TSense Range'].dtypes\nTSense_FOFF['TSense'] = TSense_FOFF['TSense Range'].map(lambda p: p.right)\nTSense_FOFF['counts'].sum() \nTSense_FOFF['TSensePR'] = TSense_FOFF['counts']\/TSense_FOFF['counts'].sum()\nTSense_FOFF","f6915679":"# Thermal Sensation PROBABILITY DENSITY FUNCTION plot\n\nsns.lineplot(x='TSense', y='TSensePR', data=TSense_FON, label='Fan ON', color='orange')\nsns.lineplot(x='TSense', y='TSensePR', data=TSense_FOFF, label='Fan OFF', color='blue')\n\nTSense_FON['TSensePR'].sum(),TSense_FOFF['TSensePR'].sum()","90862a1c":"sns.boxplot( y=TC2_AC[\"Thermal sensation\"], x=TC2_AC[\"Fan\"]);\nplt.show()","bf730229":"# Function to extract and create a dataframe for 'Thermal sensation' column\n\ndef ThermalSensationPDF(dataframe):\n    SenseDF = dataframe['Thermal sensation'].value_counts(bins=[-4, -3, -2, -1, 0, 1, 2, 3]).sort_index().rename_axis('TSense Range').reset_index(name='counts') # dataframe of thermal sensation ranges made from it's value_counts series\n    SenseDF['TSense'] = SenseDF['TSense Range'].map(lambda p: p.right) # adding column with high values of thermal sensation range\n    SenseDF['TSensePR'] = SenseDF['counts']\/SenseDF['counts'].sum() # adding a column of probablity of each count\n    return SenseDF\n\nTSense_FOFF_func = ThermalSensationPDF(TC2_AC_FOFF)\nTSense_FOFF","0c9bce55":"# Thermal comfort: Fans ON\n\nTComf_FON = TC2_AC_FON['Thermal comfort'].value_counts(bins=[0, 1, 2, 3, 4, 5, 6]).sort_index().rename_axis('TComf Range').reset_index(name='counts')\ntype(TComf_FON)\nTComf_FON.dtypes\n\nTComf_FON['TComf Range'].dtypes\nTComf_FON['TComf'] = TComf_FON['TComf Range'].map(lambda p: p.right)\nTComf_FON['counts'].sum() \nTComf_FON['TComfPR'] = TComf_FON['counts']\/TComf_FON['counts'].sum()\nTComf_FON['TComfPR'].sum()\nTComf_FON","d81e4c0d":"# Function to extract and create a dataframe for 'Thermal comfort' column\n\ndef ThermalComfortPDF(dataframe):\n    ComfDF = dataframe['Thermal comfort'].value_counts(bins=[0, 1, 2, 3, 4, 5, 6]).sort_index().rename_axis('TComf Range').reset_index(name='counts') # dataframe of thermal comfort ranges made from it's value_counts series\n    ComfDF['TComf'] = ComfDF['TComf Range'].map(lambda p: p.right) # adding column with high values of thermal comfort range\n    ComfDF['TComfPR'] = ComfDF['counts']\/ComfDF['counts'].sum() # adding a column of probablity of each count\n    return ComfDF\n\nTComf_FON_func = ThermalComfortPDF(TC2_AC_FON)\nTComf_FON","d7446794":"# Thermal preference: Fans ON\n\nTPref_FON = TC2_AC_FON['Thermal preference'].value_counts().sort_index().rename_axis('TPref').reset_index(name='counts')\n\nTPref_FON['counts'].sum() \nTPref_FON['TPrefPR'] = TPref_FON['counts']\/TPref_FON['counts'].sum()\nTPref_FON['TPrefPR'].sum()\nTPref_FON","c6ead024":"# Function to extract and create a dataframe for 'Thermal preference' column\n\ndef ThermalPreferencePDF(dataframe):\n    PrefDF = dataframe['Thermal preference'].value_counts().sort_index().rename_axis('TPref').reset_index(name='counts') # dataframe of thermal preference ranges made from it's value_counts series\n    PrefDF['TPrefPR'] = PrefDF['counts'] \/ PrefDF['counts'].sum() # adding a column of probablity of each count\n    return PrefDF\n\nTPref_FON_func = ThermalPreferencePDF(TC2_AC_FON)\nTPref_FON","13c3419e":"# Creating a dictionary of dataframes according to different climates. This is done for both Fan scenarios\n\n# Dictionary for FAN ON scenario\nTC2_AC_FON_dict = {}\nfor climate_name, df in TC2_AC_FON.groupby('Climate'):\n    TC2_AC_FON_dict[climate_name] = df\n\n# Listing all keys in the dictionary i.e. climates for which the Fan On data is available\nTC2_AC_FON_dict.keys()\nprint('The geogarpahical locations (climates) available for \"Fan switched ON scenario is\":')\nnum = 0\nfor clim in TC2_AC_FON_dict.keys():\n    num +=1\n    print(str(num)+ '.' + str(clim))\n\n# line break\nprint('')\n\n# Dictionary for FAN OFF scenario\nTC2_AC_FOFF_dict = {}\nfor climate_name, df in TC2_AC_FOFF.groupby('Climate'):\n    TC2_AC_FOFF_dict[climate_name] = df\n\n# Listing all keys in the dictionary i.e. climates for which the Fan Off data is available\nprint('The geogarpahical locations (climates) available for \"Fan switched OFF scenario is\":')\nnum = 0\nfor clim in TC2_AC_FOFF_dict.keys():\n    num +=1\n    print(str(num)+ '.' + str(clim))\n\nprint('\\nWe have four common geographical locations to compare the data. We move ahead by deleting \"Temperate Oceanic\" from Fan OFF dictionary')\n\n# Deleting data for 'Temperate oceanic'\ndel TC2_AC_FOFF_dict['Temperate oceanic']","9b063a89":"# Creating a dictionary of dataframes according to different climates. This is done for both Fan scenarios\n\n# Dictionary for FAN ON scenario\nTC2_NV_FON_dict = {}\nfor climate_name, df in TC2_NV_FON.groupby('Climate'):\n    TC2_NV_FON_dict[climate_name] = df\n\n# Listing all keys in the dictionary i.e. climates for which the Fan On data is available\nTC2_NV_FON_dict.keys()\nprint('The geogarpahical locations (climates) available for \"Fan switched ON scenario is\":')\nnum = 0\nfor clim in TC2_NV_FON_dict.keys():\n    num +=1\n    print(str(num)+ '.' + str(clim))\n\n# line break\nprint('')\n\n# Dictionary for FAN OFF scenario\nTC2_NV_FOFF_dict = {}\nfor climate_name, df in TC2_NV_FOFF.groupby('Climate'):\n    TC2_NV_FOFF_dict[climate_name] = df\n\n# Listing all keys in the dictionary i.e. climates for which the Fan Off data is available\nprint('The geogarpahical locations (climates) available for \"Fan switched OFF scenario is\":')\nnum = 0\nfor clim in TC2_NV_FOFF_dict.keys():\n    num +=1\n    print(str(num)+ '.' + str(clim))\n\nprint('\\nWe have four common geographical locations to compare the data. We move ahead by deleting \"Temperate Oceanic\" from Fan OFF dictionary')\n\n# Deleting data for 'Temperate oceanic'\n# del TC2_AC_FOFF_dict['Temperate oceanic']","430eda40":"##### THERMAL SENSATION Graphs for each Climate\n\n# Looping in the each climate i.e. keys of the any one of the dictionaries\npltLoc = -1\nfig, axes = plt.subplots(1, 4, figsize=(20,4))\nsns.set_style(\"whitegrid\")\nplt.tight_layout() \nfor climate in TC2_AC_FON_dict.keys():\n#     print(climate)\n    # making a Thermal sensation PDF dataframe for both scenarios using the function we wrote\n    TC2_AC_FON_PDF = ThermalSensationPDF(TC2_AC_FON_dict[climate])\n    TC2_AC_FOFF_PDF = ThermalSensationPDF(TC2_AC_FOFF_dict[climate])\n    # making PDF graph for each\n    pltLoc += 1\n    plt.figure() # we write this before so that the graphs in the next two lines are in the same facet\n    sns.lineplot(x='TSense', y='TSensePR', data=TC2_AC_FON_PDF, label='Fan ON', color='orange', ax=axes[pltLoc]).set(xlim=(-3.2,3.2),ylim=(0,0.7), xlabel='Thermal Sensation', ylabel='Density')\n    sns.lineplot(x='TSense', y='TSensePR', data=TC2_AC_FOFF_PDF, label='Fan OFF', color='blue', ax=axes[pltLoc]).set_title(climate)\n    ","05978fe4":"##### THERMAL SENSATION Graphs for each Climate\n\n# Looping in the each climate i.e. keys of the any one of the dictionaries\npltLoc = -1\nfig, axes = plt.subplots(1, 4, figsize=(20,4))\nsns.set_style(\"whitegrid\")\nplt.tight_layout() \nfor climate in TC2_NV_FON_dict.keys():\n#     print(climate)\n    # making a Thermal sensation PDF dataframe for both scenarios using the function we wrote\n    TC2_NV_FON_PDF = ThermalSensationPDF(TC2_NV_FON_dict[climate])\n    TC2_NV_FOFF_PDF = ThermalSensationPDF(TC2_NV_FOFF_dict[climate])\n    # making PDF graph for each\n    pltLoc += 1\n    plt.figure() # we write this before so that the graphs in the next two lines are in the same facet\n    sns.lineplot(x='TSense', y='TSensePR', data=TC2_NV_FON_PDF, label='Fan ON', color='orange', ax=axes[pltLoc]).set(xlim=(-3.2,3.2),ylim=(0,0.7), xlabel='Thermal Sensation', ylabel='Density')\n    sns.lineplot(x='TSense', y='TSensePR', data=TC2_NV_FOFF_PDF, label='Fan OFF', color='blue', ax=axes[pltLoc]).set_title(climate)\n    ","339d97cb":"##### THERMAL COMFORT Graphs for each Climate\n\n# Looping in the each climate i.e. keys of the any one of the dictionaries\npltLoc = -1\nfig, axes = plt.subplots(1, 4, figsize=(20,4))\nsns.set_style(\"whitegrid\")\nplt.tight_layout() \nfor climate in TC2_AC_FON_dict.keys():\n#     print(climate)\n    # making a Thermal comfort PDF dataframe for both scenarios using the function we wrote\n    TC2_AC_FON_PDF = ThermalComfortPDF(TC2_AC_FON_dict[climate])\n    TC2_AC_FOFF_PDF = ThermalComfortPDF(TC2_AC_FOFF_dict[climate])\n    # making PDF graph for each\n    pltLoc += 1\n    plt.figure() # we write this before so that the graphs in the next two lines are in the same facet\n    sns.lineplot(x='TComf', y='TComfPR', data=TC2_AC_FON_PDF, label='Fan ON', color='orange', ax=axes[pltLoc]).set(xlim=(1,6.1),ylim=(0,1), xlabel='Thermal Sensation', ylabel='Density')\n    sns.lineplot(x='TComf', y='TComfPR', data=TC2_AC_FOFF_PDF, label='Fan OFF', color='blue', ax=axes[pltLoc]).set_title(climate)\n    ","1ef7cf21":"# Comparing the PDFs with the same box plots(created by the team). TRPOICAL WET SAVANNA seems a little different in the two graphs but actually isnt.\n\n# TC2_AC_FOFF_dict['Tropical wet savanna']\n# TC2_AC_FON_dict['Tropical wet savanna']['Thermal sensation'].describe()\nTC2_AC_FON_dict['Tropical wet savanna']['Thermal sensation'].sort_values().reset_index()['Thermal sensation'].plot()\nTC2_AC_FOFF_dict['Tropical wet savanna']['Thermal sensation'].sort_values().reset_index()['Thermal sensation'].plot()\n\n# TC2_AC_FON_dict['Tropical wet savanna']['Thermal sensation'].plot.box()\n# TC2_AC_FON_dict['Tropical wet savanna']['Thermal sensation'].describe\n\nTC2_AC_FOFF_dict['Tropical wet savanna']['Thermal sensation'].sort_values().reset_index().iloc[150]","e60d26bf":"# Creating a PROBABILITY DISTRIBUTION FUNCTION for prefered temperature ranges to achieve maximum thermal comfort.\n\nTC2_AC_f = TC2_AC[TC2_AC['Thermal comfort'] >= 5]\nsns.set_style(\"whitegrid\") \nfor climate, df in TC2_AC_f.groupby('Climate'):\n    series = df['Air temperature (C)'].value_counts(bins=[i for i in range(15,30)]).sort_index() # the listed for-loop in value_counts() creates bins at 1 degree intervals\n    pdf = series \/ series.sum()\n\n    try:\n        print(climate, df.shape, series.max(), series.idxmax())\n    except:\n        continue\n    \n    pdf.plot(xlabel = 'Air temperature', ylabel = 'Probability Density')\nsns.set(rc={'figure.figsize':(20,10)})\n\n# TC2_AC_f['Air temperature (C)'].value_counts().sort_index().plot()\nplt.legend()\n# TC2_AC[pd.notnull(TC2_AC['Air temperature (C)'])]['Climate'].value_counts()","4b0b2017":"TC2_AC_f = TC2_AC[TC2_AC['Thermal comfort'] >= 5]\n\nclimates = ['Cool-summer mediterranean', \n            'Monsoon-influenced humid subtropical', \n            'Tropical wet savanna',\n             'Hot semi-arid']\n\nfor climate, df in TC2_AC_f.groupby('Climate'):\n    if climate not in climates:\n        continue\n\n    series = df['Air temperature (C)'].value_counts(bins=[i for i in range(15,30)]).sort_index()\n    pdf = series \/ series.sum()\n\n    try:\n        print(climate, df.shape, series.max(), series.idxmax())\n    except:\n        continue\n    \n    pdf.plot(label=climate, xlabel = 'Air temperature', ylabel = 'Probability Density')\nsns.set_style(\"whitegrid\")\nplt.legend()","c986b534":"# Creating a PROBABILITY DISTRIBUTION FUNCTION for prefered temperature ranges to achieve maximum thermal comfort.\n\nTC2_NV_f = TC2_NV[TC2_NV['Thermal comfort'] >= 5]\n\nfor climate, df in TC2_NV_f.groupby('Climate'):\n    series = df['Air temperature (C)'].value_counts(bins=[i for i in range(15,30)]).sort_index() # the listed for-loop in value_counts() creates bins at 1 degree intervals\n    pdf = series \/ series.sum()\n\n    try:\n        print(climate, df.shape, series.max(), series.idxmax())\n    except:\n        continue\n    \n    pdf.plot(label=climate, xlabel = 'Air temperature', ylabel = 'Probability Density')\n\n# TC2_AC_f['Air temperature (C)'].value_counts().sort_index().plot()\nplt.legend()\n# TC2_AC[pd.notnull(TC2_AC['Air temperature (C)'])]['Climate'].value_counts()","bf316e24":"TC2_NV_f = TC2_NV[TC2_NV['Thermal comfort'] >= 5]\n\nclimates = ['Cool-summer mediterranean', \n            'Monsoon-influenced humid subtropical', \n            'Tropical wet savanna',\n             'Hot semi-arid']\nfor climate, df in TC2_NV_f.groupby('Climate'):\n    if climate not in climates:\n        continue\n\n    series = df['Air temperature (C)'].value_counts(bins=[i for i in range(15,30)]).sort_index()\n    pdf = series \/ series.sum()\n\n    try:\n        print(climate, df.shape, series.max(), series.idxmax())\n    except:\n        continue\n    \n    pdf.plot(label=climate, xlabel = 'Air temperature', ylabel = 'Probability Density')\n\nplt.legend()\nplt.figure()","b3f9a040":"TC2_NV_f = TC2_NV[TC2_NV['Thermal comfort'] >= 5]\nsns.set_style(\"whitegrid\")\nclimates = ['Cool-summer mediterranean'\n           ]\nfor climate, df in TC2_NV_f.groupby('Climate'):\n    if climate not in climates:\n        continue\n\n    series = df['Air temperature (C)'].value_counts(bins=[i for i in range(15,30)]).sort_index()\n    pdf = series \/ series.sum()\n\n    try:\n        print(climate, df.shape, series.max(), series.idxmax())\n    except:\n        continue\n    \n    pdf.plot(label= 'Naturally ventilated', xlabel = 'Air temperature', ylabel = 'Probability Density')\n\nTC2_AC_f = TC2_AC[TC2_AC['Thermal comfort'] >= 5]\n\nfor climate, df in TC2_AC_f.groupby('Climate'):\n    if climate not in climates:\n        continue\n\n    series = df['Air temperature (C)'].value_counts(bins=[i for i in range(15,30)]).sort_index()\n    pdf = series \/ series.sum()\n\n    try:\n        print(climate, df.shape, series.max(), series.idxmax())\n    except:\n        continue\n    \n    pdf.plot(label= 'Air conditioned', linestyle='dashed', xlabel = 'Air temperature', ylabel = 'Probability Density', title = climate)\nsns.set(rc={'figure.figsize':(5,5)})\nplt.legend()","bdc20708":"TC2_NV_f = TC2_NV[TC2_NV['Thermal comfort'] >= 5]\nsns.set_style(\"whitegrid\")\nclimates = [\n            'Hot semi-arid'\n           ]\nfor climate, df in TC2_NV_f.groupby('Climate'):\n    if climate not in climates:\n        continue\n\n    series = df['Air temperature (C)'].value_counts(bins=[i for i in range(15,30)]).sort_index()\n    pdf = series \/ series.sum()\n\n    try:\n        print(climate, df.shape, series.max(), series.idxmax())\n    except:\n        continue\n    \n    pdf.plot(label= 'Naturally ventilated', xlabel = 'Air temperature', ylabel = 'Probability Density')\n\nTC2_AC_f = TC2_AC[TC2_AC['Thermal comfort'] >= 5]\n\nfor climate, df in TC2_AC_f.groupby('Climate'):\n    if climate not in climates:\n        continue\n\n    series = df['Air temperature (C)'].value_counts(bins=[i for i in range(15,30)]).sort_index()\n    pdf = series \/ series.sum()\n\n    try:\n        print(climate, df.shape, series.max(), series.idxmax())\n    except:\n        continue\n    \n    pdf.plot(label= 'Air conditioned', linestyle='dashed', xlabel = 'Air temperature', ylabel = 'Probability Density', title = climate)\nsns.set(rc={'figure.figsize':(5,5)})\nplt.legend()","9fafbfc8":"TC2_NV_f = TC2_NV[TC2_NV['Thermal comfort'] >= 5]\nsns.set(rc={'figure.figsize':(10,5)})\nsns.set_style(\"whitegrid\")\nclimates = [\n            'Tropical wet savanna'\n           ]\nfor climate, df in TC2_NV_f.groupby('Climate'):\n    if climate not in climates:\n        continue\n\n    series = df['Air temperature (C)'].value_counts(bins=[i for i in range(15,30)]).sort_index()\n    pdf = series \/ series.sum()\n\n    try:\n        print(climate, df.shape, series.max(), series.idxmax())\n    except:\n        continue\n    \n    pdf.plot(label= 'Naturally ventilated', xlabel = 'Air temperature', ylabel = 'Probability Density')\n\nTC2_AC_f = TC2_AC[TC2_AC['Thermal comfort'] >= 5]\n\nfor climate, df in TC2_AC_f.groupby('Climate'):\n    if climate not in climates:\n        continue\n\n    series = df['Air temperature (C)'].value_counts(bins=[i for i in range(15,30)]).sort_index()\n    pdf = series \/ series.sum()\n\n    try:\n        print(climate, df.shape, series.max(), series.idxmax())\n    except:\n        continue\n    \n    pdf.plot(label= 'Air conditioned', linestyle='dashed', xlabel = 'Air temperature', ylabel = 'Probability Density', title = climate)\n\nplt.legend()","2d5eef95":"# mix-max scale the data between 0 and 1\nscaled_data = minmax_scaling(TC2_AC['Thermal comfort'], columns=[0])\n\n# plot both together to compare\nfig, ax = plt.subplots(1,2)\nsns.distplot(TC2_AC['Thermal comfort'], ax=ax[0])\nax[0].set_title(\"Original Data\")\nsns.distplot(scaled_data, ax=ax[1])\nax[1].set_title(\"Scaled data\")\n\n# mix-max scale the data between 0 and 1\nscaled_data = minmax_scaling(TC2_AC['Thermal sensation'], columns=[0])\n\n# plot both together to compare\nfig, ax = plt.subplots(1,2)\nsns.distplot(TC2_AC['Thermal sensation'], ax=ax[0])\nax[0].set_title(\"Original Data\")\nsns.distplot(scaled_data, ax=ax[1])\nax[1].set_title(\"Scaled data\")","c81c9fe2":"# generate 1000 data points randomly drawn from an exponential distribution\noriginal_data = np.random.exponential(size=1000)\n\n# normalize the exponential data with boxcox\nnormalized_data = stats.boxcox(original_data)\n\n# plot both together to compare\nfig, ax=plt.subplots(1,2)\nsns.distplot(original_data, ax=ax[0])\nax[0].set_title(\"Original Data\")\nsns.distplot(normalized_data[0], ax=ax[1])\nax[1].set_title(\"Normalized data\")","375fd7d9":"TC_raw.columns","3bb4b0d0":"## Does Fan affect Thermal comfort\/sensation?","f4a37766":"### DATA ANALYIS FOR THERMAL COMFORT, SENSATION AND PREFERENCE","e664d414":"Another `groupby()` method worth mentioning is `agg()`, which lets you run a bunch of different functions on your DataFrame simultaneously. For example, we can generate a simple statistical summary of the dataset as above\n\nFor even more fine-grained control, you can also group by more than one column. For an example, here's how we would pick out the minimum temperature by climate and season:","a3900256":"### Sorting\n\nWhen outputting the result of a `groupby`, the order of the rows is dependent on the values in the index, not in the data.\n\nTo get data in the order want it in we can sort it ourselves.  The `sort_values()` method is handy for this.","3e2a1d4a":"### Exploring Data type\n\nThe data type for a column in a DataFrame or a Series is known as the **dtype**.\n\nYou can use the `dtype` property to grab the type of a specific column.\n\nAlternatively, the `dtypes` property returns the `dtype` of _every_ column in the DataFrame:","91126c93":"### Scaling and Normalisation\n\nOne of the reasons that it's easy to get confused between scaling and normalization is because the terms are sometimes used interchangeably and, to make it even more confusing, they are very similar! In both cases, you're transforming the values of numeric variables so that the transformed data points have specific helpful properties. The difference is that:\n- in **scaling**, you're changing the *range* of your data, while \n- in **normalization**, you're changing the *shape of the distribution* of your data. ","6d6e2efb":"### Accessing sective data\n\n#### Choosing between `loc` and `iloc`\n\nWhen choosing or transitioning between `loc` and `iloc`, there is one \"gotcha\" worth keeping in mind, which is that the two methods use slightly different indexing schemes.\n\n`iloc` uses the Python stdlib indexing scheme, where the first element of the range is included and the last one excluded. So `0:10` will select entries `0,...,9`. `loc`, meanwhile, indexes inclusively. So `0:10` will select entries `0,...,10`.\n\nWhy the change? Remember that loc can index any stdlib type: strings, for example. If we have a DataFrame with index values `Apples, ..., Potatoes, ...`, and we want to select \"all the alphabetical fruit choices between Apples and Potatoes\", then it's a lot more convenient to index `df.loc['Apples':'Potatoes']` than it is to index something like `df.loc['Apples', 'Potatoet']` (`t` coming after `s` in the alphabet).\n\nThis is particularly confusing when the DataFrame index is a simple numerical list, e.g. `0,...,1000`. In this case `df.iloc[0:1000]` will return 1000 entries, while `df.loc[0:1000]` return 1001 of them! To get 1000 elements using `loc`, you will need to go one lower and ask for `df.loc[0:999]`. \n\nOtherwise, the semantics of using `loc` are the same as those for `iloc`.","7a3aa657":"Is data not recorded or does not exist?","6ce310a3":"This DataFrame is accessible to us directly using the `apply()` method, and we can then manipulate the data in any way we see fit. For example, here's one way of selecting the maximum and minimum temperature for each climate in the dataset:","7806f16d":"Notice that the shape of our data has changed. Before normalizing it was almost L-shaped. But after normalizing it looks more like the outline of a bell (hence \"bell curve\").","b8bc7e46":"**Figure out why this data is missing**  \n\nFor dealing with missing values, you'll need to use your intution to figure out why the value is missing. One of the most important questions you can ask yourself to help figure this out is this:\n\n> **Is this value missing because it wasn't recorded or because it doesn't exist?**\n\nIf a value is missing becuase it doesn't exist (like the height of the oldest child of someone who doesn't have any children) then it doesn't make sense to try and guess what it might be. These values you probably do want to keep as `NaN`. On the other hand, if a value is missing because it wasn't recorded, then you can try to guess what it might have been based on the other values in that column and row. This is called **imputation**","cf5976dc":"Notice that the *shape* of the data doesn't change, but that instead of ranging from 1to6 or -3to3, it now ranges from 0 to 1.\n\n**Normalization**\n\nScaling just changes the range of your data. Normalization is a more radical transformation. The point of normalization is to change your observations so that they can be described as a normal distribution.\n\n> **[Normal distribution:](https:\/\/en.wikipedia.org\/wiki\/Normal_distribution)** Also known as the \"bell curve\", this is a specific statistical distribution where a roughly equal observations fall above and below the mean, the mean and the median are the same, and there are more observations closer to the mean. The normal distribution is also known as the Gaussian distribution.\n\nIn general, you'll normalize your data if you're going to be using a machine learning or statistics technique that assumes your data is normally distributed. Some examples of these include linear discriminant analysis (LDA) and Gaussian naive Bayes. (Pro tip: any method with \"Gaussian\" in the name probably assumes normality.)\n\nThe method we're using to normalize here is called the [Box-Cox Transformation](https:\/\/en.wikipedia.org\/wiki\/Power_transform#Box%E2%80%93Cox_transformation). Let's take a quick peek at what normalizing some data looks like:\n\n*Since there are no columns in our dataset to accuratly represent a non-bell curve values, I am generating a random set of numbers and normalising them*","b467fa2c":"In naturally ventillated buildings, we observe that temperature preferences for a very comfortable space varies greatly as compared to air conditioned spaces. \n##### INSIGHT: The temperature ranges for a thermally comfortable space also reflect the standards of ambient temperature i.e. 18-27C. \n\nNext, we look closely at a few climates to get more clarity. ","5c55675a":"## Geographical location  ==  Climate. Why the choice?\n\nWe needed a common variable in different geographical locations to compare people's responses of thermal comfort and sensitivity. The data frame offers variables such as Season, Climate, Country and City. \n    - Seasons vary in different hemispheres and will not accurately allow us to compare responses within the same season\n    - Countries are vast administrative regions with various climate zones for which we have to create subgroups while analysing the data\n    - Cities, each of which has one climate, may prove to be a suitable variable but the number of cities are far too many to assimilate the data as a compressive whole.\nHence, we chose Climate zones as primary classifier for geographical locations. Various outdoor conditions and seasons tend to be consitent in different regions of the same climate zone.","ef1ac87e":"Since the data is suitable, we will work on AC rooms OF A PARTICULAR CLIMATE, we compare thermal comfort with and without the fan switched on. \nThe comparison is done for four common climates (all except 'Temperate oceanic')","b56b2831":"When dealing with a column\/data that is expected to be numerical, it is always good to check the type.  \n\nIt's possible to convert a column of one type into another wherever such a conversion makes sense by using the `astype()` function. ","6239e865":"##### INSIGHT: We observe that in Hot-semi arid climate people feel most comfortable in a larger range of indoor temperature (21C to 26C) as compared to cool summer mediterranean where temperature preference lies in a two degree difference (22C to 24C)","2d770f1e":"## Groupby\n\nBelow in the first line of code,`groupby()` created a group for each climate. Then, for each of these groups, it grabbed the `Climate` column and counted how many times it appeared.  `value_counts()` is just a shortcut to this `groupby()` operation. \n\u200b\nWe can use any of the summary functions we've used before with this data. For example, to get list of unique countries in each climate category, we can use uniqe() and nunique() number of countries.","5ebb5423":"## In different geographical locations, how does the temperature range of a very comfortable space differ?\n\nASHRAE Standard 55-2017, Thermal Environmental Conditions for Human Occupancy, notes that for thermal comfort purposes, temperature\ncould range from between approximately 67 and 82 \u00b0F. In Celcius it lies between 18-27 degrees. \n\nUnder this section, we explore a hypothesis that people living in different geographical location may have feel most comfortable under different temperature ranges.\n\n#### I. Case of Air conditioned buildings\n\nWe start by assessing the temperature ranges for thermal comfort votes above 5. At first let's see the data for all climates. ","a173f0d2":"### Multi Indexes\nIn all cases thus far we've been working with DataFrame or Series objects with a single-label index. `groupby()` is slightly different in the fact that, depending on the operation we run, it will sometimes result in what is called a multi-index.\n\nA multi-index differs from a regular index in that it has multiple levels. For example, check the index type of the 'Multi_Index' below.\n\nMulti-indices have several methods for dealing with their tiered structure which are absent for single-level indices. They also require two levels of labels to retrieve a value. The use cases for a multi-index are detailed alongside instructions on using them in the [MultiIndex \/ Advanced Selection](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/advanced.html) section of the pandas documentation.\n\nHowever, in general the multi-index can be converted back to a regular index by the `reset_index()` method:","c1cbec47":"#### Missing Data\n\nEntries missing values are given the value `NaN`, short for \"Not a Number\". For technical reasons these `NaN` values are always of the `float64` dtype.\n\nPandas provides some methods specific to missing data. To select `NaN` entries you can use `pd.isnull()` (or its companion `pd.notnull()`).","8a585427":"### Summary functions\n\nPandas provides many simple \"summary functions\" (not an official name) which restructure the data in some useful way. \n\nThe `describe()` method generates a high-level summary of the attributes of the given column. It is type-aware, meaning that its output changes based on the data type of the input. The output above only makes sense for numerical data\n\nTo see the mean of the points allotted (e.g. how well an averagely rated wine does), we can use the `mean()` function\n\nTo see a list of unique values we can use the `unique()` function","ff16a080":"**Scaling**\n\nThis means that you're transforming your data so that it fits within a specific scale, like 0-100 or 0-1.  You want to scale data when you're using methods based on measures of how far apart data points are, like [support vector machines (SVM)](https:\/\/en.wikipedia.org\/wiki\/Support_vector_machine) or [k-nearest neighbors (KNN)](https:\/\/en.wikipedia.org\/wiki\/K-nearest_neighbors_algorithm). With these algorithms, a change of \"1\" in any numeric feature is given the same importance. \n\nFor example, you might be looking at the prices of some products in both Yen and US Dollars. One US Dollar is worth about 100 Yen, but if you don't scale your prices, methods like SVM or KNN will consider a difference in price of 1 Yen as important as a difference of 1 US Dollar! This clearly doesn't fit with our intuitions of the world. With currency, you can convert between currencies. But what about if you're looking at something like height and weight? It's not entirely clear how many pounds should equal one inch (or how many kilograms should equal one meter).\n\nBy scaling your variables, you can help compare different variables on equal footing.\n\n*Let's say, just for the sake of example of this data, we need to compare thermal sensation (range -3 to 3) and thermal comfort (range 1 to 6) so make both of them within the range of 0,1. Now this will not make sense in reality but it's the only two numerical series with us right now.*","4abf596b":"**Fixing missing values**\n\n1. `dropna()`\nIf you're in a hurry or don't have a reason to figure out why your values are missing, one option you have is to just remove any rows or columns that contain missing values. (Note: I don't generally recommend this approch for important projects! It's usually worth it to take the time to go through your data and really look at all the columns with missing values one-by-one to really get to know your dataset.)  ","22af2a27":"The graph above plots the density of people and room temperature ranges that reported maximum comfort (>5). If we notice the peaks for each line, it varies between 21C to 25C.\n##### INSIGHT : This shows that in an air conditioned room, across all climates, people feel very comfortable in when temperatures are set between 21-25 degree celcius.\n\nLet's zoom into a few climates to get a clearer idea.","9a4cf65c":"You can think of each group we generate as being a slice of our DataFrame containing only data with values that match. When I try to convert it into a list, one element of the list is a dataframe of that particular group. For eg. here when i group by 'country', the first element in the list is a dataframe of all rows where the 'country' column had the value 'Australia'.","8f49d0d2":"## Thermal Comfort theory and discussion\n\n![image.png](attachment:a964d791-6dbd-4b2c-a368-1416785a86c5.png)\n\nResearch objective 1: Expected thermal comfort (according to phsychometric analysis and guidelines) vs surveyed thermal comfort (according to responses) i.e. How do building occupant's assessment of 'acceptability' compare with the intent of the standards?\n\nScenario possibility 1 : How should XYZ company change strategy for product placement in Singapore and US\n\nScenario possibility 2 : Usually thermal comfort is assessed after a building is occupied. Changes in indoor environment (like fanspeed, AC temp etc) are done after a general survey. We can build a product\/model that tells designers whether meets acceptable thermal comfort standards.\n\nBesides dry-bulb air temperature, mean radiant temperature, and air velocity, factors affecting thermal comfort are: Metabolic rate. Clothing insulation. Humidity.\n\nASHRAE 55 defines thermal comfort as \u201cthat condition of mind that expresses satisfaction with the thermal environment\u201d,\n\n![image.png](attachment:b18c3cd6-78ef-4a3b-bfda-44c34931508d.png)\n\nReferences:\n<br> 1. https:\/\/www.hpac.com\/heating\/article\/20927877\/thermal-comfort-more-than-just-air-temperature\n<br> 2. https:\/\/escholarship.org\/content\/qt5n94s9hz\/qt5n94s9hz_noSplash_4ac268a941e801f384c5aa67ebd34caf.pdf\n<br> 3. https:\/\/www.hse.gov.uk\/temperature\/thermal\/factors.htm\n\n\n\n","133f431f":"### DATA CLASSIFICATION BASED ON ROOM COOLING\n\nVarious cooling strategies are: ['Air Conditioned' 'Naturally Ventilated' 'Mixed Mode' nan, 'Mechanically Ventilated'] \n\nThe room settings in Mixed mode building is: [nan 'Air Conditioned' 'Naturally Ventilated' 'Unknown'] \n\nData values if we disregard the Mixed mode rooms is:\n<br>Naturally Ventilated:       47285\n<br>Air Conditioned:            32372\n<br>Mixed Mode:                 26519\n<br>NaN:                         1227\n<br>Mechanically Ventilated:      180\n<br>Name-Cooling startegy_building level \n\nMore values can be added to the dataset if we include MM scenarios in AC and NV:\n<br>Naturally Ventilated:     6433\n<br>Air Conditioned:         11690\n<br>Unknown:                  8396\n<br>Name: Cooling startegy_operation mode for MM buildings\n\n","46d61d29":"2. `fillna()`\nWe can instead try replacing the missing values with either more meanigful values or any other string\/number using fillna(). For example, we replace each `NaN` with an `\"Unknown\"`","cd428948":"Similar to the trend we observed in AC buildings, Hot-semi arid climate people feel most comfortable in a larger range of indoor temperature (19C to 25C) as compared to cool summer mediterranean where temperature preference lies in a two degree difference (22C to 25C)\n\nNext, we compare the AC and naturally ventillated buildings for these two climate zones. ","302aa636":"#### II. Case of Naturally ventilated buildings\n\nWe start by assessing the temperature ranges for thermal comfort votes above 5. At first let's see the data for all climates. ","12e7e5c4":"#### Conditional selectors `&`, `|`, `isin`, `notnull` \n\nWe can use the ampersand (`&`) to bring the two questions together i.e. AND\n\nWe can use the pipe (`|`) to choose between the two questions i.e. OR\n\n`isin` is lets you select data whose value \"is in\" a list of values. It is similar to using == and then making a dataframe out of it (look at the cell below for example)\n\n`isnull` (and its companion `notnull`). These methods let you highlight values which are (or are not) empty (`NaN`).\n\n\n\n\n","c7f6ecd2":"## Limitations of the dataset:\n\n1. No clarity of whether the cooling and heating strategies were in use while the survey was conducted. \n    - There are rows in which both air conditioning and mechanical heating had values which seems like an unlikey scenario in real life. Also, there are rows where values of 'Heater' column are 1.0 (On) along with mention of air condition in cooling strategy.\n    - For our research we assumed that mention of air conditioned meant that it was switched on and disregarded mechanical heating altogether. This assumption implies that our study does not contain surveys of rooms in cold wweathers. \n    \n    \n2. The dataframe does not mention whether multiple participants of the same room had been surveyed, either at the same time or during different seasons. \n    - While we can obtain this insight on cross-checking with the publication, it is an additional step that could be just another column in the dataframe. \n    - This data maybe required to shed light on the PMV and PPD columns in the data\n    \n    \n3. Qualitative measures like sensation and preference should be discrete as per the defined categories and not floats.\n\n\n","ebec1ceb":"Data types tell us something about how pandas is storing the data internally. `float64` means that it's using a 64-bit floating point number; `int64` means a similarly sized integer instead, and so on.\n\nOne peculiarity to keep in mind (and on display very clearly here) is that columns consisting entirely of strings do not get their own type; they are instead given the `object` type.\n\nIt's possible to convert a column of one type into another wherever such a conversion makes sense by using the `astype()` function. We'll see more of it in the coming sections.","2be66225":"Since there are no overlaps in the two columns, they can be combined.","89026bc4":"### WHAT ABOUT HEATING?","c885b271":"While comparing the most comfortable temperature ranges in rooms of different cooling strategies, we observe that people in naturally ventilated spaces report higher tolerance of 1-2C compared to air conditioned rooms. This trend can be seen in the two graphs plotted for Cool-summer mediterannean and Hot-arid climates."}}