{"cell_type":{"87cd5a10":"code","bcf98d34":"code","bdc49324":"code","d2b42ee7":"code","9b58fd6a":"code","b78a6cda":"code","af6e2dca":"code","52b275ee":"code","c447633c":"code","db40b762":"code","6f539f06":"code","83a35bfe":"code","53ed14d8":"code","0b6054e1":"code","6d567126":"code","1586cac0":"code","ac35ea62":"code","38e04cca":"code","fc4c82c5":"code","1085a462":"markdown","5eb19018":"markdown","f1983035":"markdown","bd58531b":"markdown","41d4de50":"markdown","e6c58293":"markdown","9cf9631c":"markdown","6fce2a48":"markdown","32dbbd0f":"markdown"},"source":{"87cd5a10":"import os\nimport sys \nimport json\nimport glob\nimport random\nimport collections\nimport time\nimport re\n\nimport numpy as np\nimport pandas as pd\nimport pydicom\nfrom pydicom.pixel_data_handlers.util import apply_voi_lut\nimport cv2\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport torch\nfrom torch import nn\nfrom torch.utils import data as torch_data\nfrom sklearn import model_selection as sk_model_selection\nfrom torch.nn import functional as torch_functional\nimport torch.nn.functional as F\n\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.metrics import roc_auc_score","bcf98d34":"if os.path.exists(\"..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\"):\n    data_directory = '..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification'\n    pytorch3dpath = \"..\/input\/efficientnetpyttorch3d\/EfficientNet-PyTorch-3D\"\nelse:\n    data_directory = '\/media\/roland\/data\/kaggle\/rsna-miccai-brain-tumor-radiogenomic-classification'\n    pytorch3dpath = \"EfficientNet-PyTorch-3D\"\n    \nmri_types = ['FLAIR','T1w','T1wCE','T2w']\n\n## U Can chosse larger parameters it's safe.\nSIZE = 256\nNUM_IMAGES = 128 \/\/ 4 # NUM_IMAGES per Type\nBS = 8 # Batch Size\nEPOCHS = 10\n\nSEED = 42\n\noutput_files_name = '.\/bst_files.pkl'\n\nsys.path.append(pytorch3dpath)\nfrom efficientnet_pytorch_3d import EfficientNet3D","bdc49324":"def load_dicom_image(path, img_size=SIZE, voi_lut=True, rotate=0):\n    dicom = pydicom.read_file(path)\n    data = dicom.pixel_array\n    if voi_lut:\n        data = apply_voi_lut(dicom.pixel_array, dicom)\n    else:\n        data = dicom.pixel_array\n        \n    if rotate > 0:\n        rot_choices = [0, cv2.ROTATE_90_CLOCKWISE, cv2.ROTATE_90_COUNTERCLOCKWISE, cv2.ROTATE_180]\n        data = cv2.rotate(data, rot_choices[rotate])\n        \n    data = cv2.resize(data, (img_size, img_size))\n    return data\n\n\ndef load_dicom_images_3d(scan_id, mri_type=\"FLAIR\", split=\"train\", rotate=0, num_imgs=NUM_IMAGES, img_size=SIZE,):\n\n    files = sorted(glob.glob(f\"{data_directory}\/{split}\/{scan_id}\/{mri_type}\/*.dcm\"), \n               key=lambda var:[int(x) if x.isdigit() else x for x in re.findall(r'[^0-9]|[0-9]+', var)])\n\n    middle = len(files)\/\/2\n    num_imgs2 = num_imgs\/\/2\n    p1 = max(0, middle - num_imgs2)\n    p2 = min(len(files), middle + num_imgs2)\n    img3d = np.stack([load_dicom_image(f, rotate=rotate) for f in files[p1:p2]]).T \n    if img3d.shape[-1] < num_imgs:\n        n_zero = np.zeros((img_size, img_size, num_imgs - img3d.shape[-1]))\n        img3d = np.concatenate((img3d,  n_zero), axis = -1)\n        \n    if np.min(img3d) < np.max(img3d):\n        img3d = img3d - np.min(img3d)\n        img3d = img3d \/ np.max(img3d)\n            \n    return np.expand_dims(img3d,0)\n\na = load_dicom_images_3d(\"00000\")\nprint(a.shape)\nprint(np.min(a), np.max(a), np.mean(a), np.median(a))\n\nplt.imshow(a[0, :, :, 3]);","d2b42ee7":"# ALL MRI TYPES ONCE\ndef load_all_types_imgs_3d(scan_id, mri_types=mri_types, split=\"train\", rotate=0, shuffle=True):\n    imgs3d_ = [load_dicom_images_3d(scan_id=scan_id, mri_type=x, split=split, rotate=rotate) for x in mri_types]\n    imgs3d = np.concatenate((imgs3d_), axis = -1)\n    \n    if shuffle:\n        X = imgs3d\n        #np.random.seed(SEED)\n        return np.take(X, np.random.rand(X.shape[-1]).argsort(), axis=-1, out=X)\n    \n    return imgs3d\n\nb = load_all_types_imgs_3d(\"00000\", shuffle=True)\nprint(b.shape)\nprint(np.min(b), np.max(b), np.mean(b), np.median(b))\n\nplt.imshow(b[0, :, :, 3]);","9b58fd6a":"def set_seed(seed):\n    random.seed(seed)\n    os.environ[\"PYTHONHASHSEED\"] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    if torch.cuda.is_available():\n        torch.cuda.manual_seed_all(seed)\n        torch.backends.cudnn.deterministic = True\n\nset_seed(SEED)","b78a6cda":"train_df = pd.read_csv(f\"{data_directory}\/train_labels.csv\")\ndisplay(train_df)\n\n\nN_SPLITS = 5\nskf = sk_model_selection.StratifiedKFold(n_splits=N_SPLITS, shuffle=True, random_state=SEED)","af6e2dca":"train_df['MGMT_value'].value_counts()","52b275ee":"class Dataset(torch_data.Dataset):\n    def __init__(self, paths, targets=None, label_smoothing=0.01, split=\"train\", augment=False):\n        self.paths = paths\n        self.targets = targets\n        self.label_smoothing = label_smoothing\n        self.split = split\n        self.augment = augment\n          \n    def __len__(self):\n        return len(self.paths)\n    \n    def __getitem__(self, index):\n        scan_id = self.paths[index]\n        if self.targets is None:\n            #data = load_dicom_images_3d(str(scan_id).zfill(5), mri_type=self.mri_type[index], split=self.split)\n            data = load_all_types_imgs_3d(str(scan_id).zfill(5), split=self.split)\n        else:\n            if self.augment:\n                rotation = np.random.randint(0,4)\n            else:\n                rotation = 0\n\n            #data = load_dicom_images_3d(str(scan_id).zfill(5), mri_type=self.mri_type[index], split=\"train\", rotate=rotation)\n            data = load_all_types_imgs_3d(str(scan_id).zfill(5), split=\"train\", rotate=rotation)\n\n        if self.targets is None:\n            return {\"X\": torch.tensor(data).float(), \"id\": scan_id}\n        else:\n            y = torch.tensor(abs(self.targets[index]-self.label_smoothing), dtype=torch.float)\n            return {\"X\": torch.tensor(data).float(), \"y\": y}\n","c447633c":"class Model(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.net = EfficientNet3D.from_name(\"efficientnet-b0\", override_params={'num_classes': 2}, in_channels=1)\n        n_features = self.net._fc.in_features\n        self.net._fc = nn.Linear(in_features=n_features, out_features=1, bias=True)\n    \n    def forward(self, x):\n        out = self.net(x)\n        return out\n    ","db40b762":"class Trainer:\n    def __init__(\n        self, \n        model, \n        device, \n        optimizer, \n        criterion\n    ):\n        self.model = model\n        self.device = device\n        self.optimizer = optimizer\n        self.criterion = criterion\n\n        self.best_valid_score = np.inf\n        self.n_patience = 0\n        self.lastmodel = None\n        \n    def fit(self, epochs, train_loader, valid_loader, save_path, patience):        \n        for n_epoch in range(1, epochs + 1):\n            self.info_message(\"EPOCH: {}\", n_epoch)\n            \n            train_loss, train_time = self.train_epoch(train_loader)\n            valid_loss, valid_auc, valid_time = self.valid_epoch(valid_loader)\n            \n            self.info_message(\n                \"[Epoch Train: {}] loss: {:.4f}, time: {:.2f} s            \",\n                n_epoch, train_loss, train_time\n            )\n            \n            self.info_message(\n                \"[Epoch Valid: {}] loss: {:.4f}, auc: {:.4f}, time: {:.2f} s\",\n                n_epoch, valid_loss, valid_auc, valid_time\n            )\n\n            # if True:\n            #if self.best_valid_score < valid_auc: \n            if self.best_valid_score > valid_loss: \n                self.save_model(n_epoch, save_path, valid_loss, valid_auc)\n                self.info_message(\n                     \"auc improved from {:.4f} to {:.4f}. Saved model to '{}'\", \n                    self.best_valid_score, valid_loss, self.lastmodel\n                )\n                self.best_valid_score = valid_loss\n                self.n_patience = 0\n            else:\n                self.n_patience += 1\n            \n            if self.n_patience >= patience:\n                self.info_message(\"\\nValid auc didn't improve last {} epochs.\", patience)\n                break\n            \n    def train_epoch(self, train_loader):\n        self.model.train()\n        t = time.time()\n        sum_loss = 0\n\n        for step, batch in enumerate(train_loader, 1):\n            X = batch[\"X\"].to(self.device)\n            targets = batch[\"y\"].to(self.device)\n            self.optimizer.zero_grad()\n            outputs = self.model(X).squeeze(1)\n            \n            loss = self.criterion(outputs, targets)\n            loss.backward()\n\n            sum_loss += loss.detach().item()\n\n            self.optimizer.step()\n            \n            message = 'Train Step {}\/{}, train_loss: {:.4f}'\n            self.info_message(message, step, len(train_loader), sum_loss\/step, end=\"\\r\")\n        \n        return sum_loss\/len(train_loader), int(time.time() - t)\n    \n    def valid_epoch(self, valid_loader):\n        self.model.eval()\n        t = time.time()\n        sum_loss = 0\n        y_all = []\n        outputs_all = []\n\n        for step, batch in enumerate(valid_loader, 1):\n            with torch.no_grad():\n                X = batch[\"X\"].to(self.device)\n                targets = batch[\"y\"].to(self.device)\n\n                outputs = self.model(X).squeeze(1)\n                loss = self.criterion(outputs, targets)\n\n                sum_loss += loss.detach().item()\n                y_all.extend(batch[\"y\"].tolist())\n                outputs_all.extend(torch.sigmoid(outputs).tolist())\n\n            message = 'Valid Step {}\/{}, valid_loss: {:.4f}'\n            self.info_message(message, step, len(valid_loader), sum_loss\/step, end=\"\\r\")\n            \n        y_all = [1 if x > 0.5 else 0 for x in y_all]\n        auc = roc_auc_score(y_all, outputs_all)\n        \n        return sum_loss\/len(valid_loader), auc, int(time.time() - t)\n    \n    def save_model(self, n_epoch, save_path, loss, auc):\n        self.lastmodel = f\"{save_path}-e{n_epoch}-loss{loss:.3f}-auc{auc:.3f}.pth\"\n        torch.save(\n            {\n                \"model_state_dict\": self.model.state_dict(),\n                \"optimizer_state_dict\": self.optimizer.state_dict(),\n                \"best_valid_score\": self.best_valid_score,\n                \"n_epoch\": n_epoch,\n            },\n            self.lastmodel,\n        )\n    \n    @staticmethod\n    def info_message(message, *args, end=\"\\n\"):\n        print(message.format(*args), end=end)","6f539f06":"device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\ndef train_mri_type(df_train, df_valid, fold):\n    #display(df_train.head())\n    print(f'Training Fold-{fold}...')\n    print(df_train.shape, df_valid.shape)\n\n    train_data_retriever = Dataset(\n        df_train[\"BraTS21ID\"].values, \n        df_train[\"MGMT_value\"].values, \n        #df_train[\"MRI_Type\"].values,\n        augment=True\n    )\n\n    valid_data_retriever = Dataset(\n        df_valid[\"BraTS21ID\"].values, \n        df_valid[\"MGMT_value\"].values,\n        #df_valid[\"MRI_Type\"].values\n    )\n\n    train_loader = torch_data.DataLoader(\n        train_data_retriever,\n        batch_size=BS,\n        shuffle=True,\n        num_workers=8,pin_memory = True\n    )\n\n    valid_loader = torch_data.DataLoader(\n        valid_data_retriever, \n        batch_size=BS\/\/2,\n        shuffle=False,\n        num_workers=8,pin_memory = True\n    )\n\n    model = Model()\n    model.to(device)\n\n\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.01)\n    #optimizer = torch.optim.SGD(model.parameters(), lr=0.001, momentum=0.9)\n\n    criterion = torch_functional.binary_cross_entropy_with_logits\n\n    trainer = Trainer(\n        model, \n        device, \n        optimizer, \n        criterion\n    )\n\n    history = trainer.fit(\n        EPOCHS, \n        train_loader, \n        valid_loader, \n        f\"fold-{fold}-all_types\", \n        6,\n    )\n    \n    return trainer.lastmodel","83a35bfe":"bst_files = {}\nfor fold, (trn_idx, val_idx) in enumerate(skf.split(train_df, train_df[\"MGMT_value\"])): \n    df_train, df_valid = train_df.iloc[trn_idx], train_df.iloc[val_idx]\n    bst_file = train_mri_type(df_train, df_valid, fold)\n    bst_files[f'FOLD-{fold}'] = bst_file\n    print(bst_file)\n    \n    break # Train only one fold ","53ed14d8":"# save bst files\nimport pickle\n\na_file = open(output_files_name, \"wb\")\npickle.dump(bst_files, a_file)\na_file.close()\n\nprint(f'Best Weights Saved to {output_files_name}')","0b6054e1":"def predict(modelfile, df, split):\n    print(\"Predict:\", modelfile, df.shape)\n    data_retriever = Dataset(\n        df.index.values, \n        #mri_type=df[\"MRI_Type\"].values,\n        split=split\n    )\n\n    data_loader = torch_data.DataLoader(\n        data_retriever,\n        batch_size=BS\/\/2,\n        shuffle=False,\n        num_workers=8,\n    )\n   \n    model = Model()\n    model.to(device)\n    \n    checkpoint = torch.load(modelfile)\n    model.load_state_dict(checkpoint[\"model_state_dict\"])\n    model.eval()\n    \n    y_pred = []\n    ids = []\n\n    for e, batch in enumerate(data_loader,1):\n        print(f\"{e}\/{len(data_loader)}\", end=\"\\r\")\n        with torch.no_grad():\n            tmp_pred = torch.sigmoid(model(batch[\"X\"].to(device))).cpu().numpy().squeeze()\n            if tmp_pred.size == 1:\n                y_pred.append(tmp_pred)\n            else:\n                y_pred.extend(tmp_pred.tolist())\n            ids.extend(batch[\"id\"].numpy().tolist())\n            \n    preddf = pd.DataFrame({\"BraTS21ID\": ids, \"MGMT_value\": y_pred}) \n    preddf = preddf.set_index(\"BraTS21ID\")\n    return preddf","6d567126":"#output_path = '.\/'\n#modelfiles = glob.glob(output_path+'*pth')\n\n#modelfiles","1586cac0":"a_file = open(output_files_name, \"rb\")\noutput = pickle.load(a_file)\n\nmodelfiles = list(output.values())\nprint(f'Best Weights Loaded from {output_files_name}')\nmodelfiles","ac35ea62":"df_valid = df_valid.set_index(\"BraTS21ID\")\ndf_valid[\"MGMT_pred\"] = 0\nfor m in modelfiles:    \n    pred = predict(m, df_valid, \"train\")\n    df_valid[\"MGMT_pred\"] += pred[\"MGMT_value\"]\ndf_valid[\"MGMT_pred\"] \/= len(modelfiles)\n    \nauc = roc_auc_score(df_valid[\"MGMT_value\"], df_valid[\"MGMT_pred\"])\nprint(f\"Validation ensemble AUC: {auc:.4f}\")\nsns.displot(df_valid[\"MGMT_pred\"])","38e04cca":"submission = pd.read_csv(f\"{data_directory}\/sample_submission.csv\", index_col=\"BraTS21ID\")\n\nsubmission[\"MGMT_value\"] = 0\nfor m in modelfiles:\n    pred = predict(m, submission, split=\"test\")\n    submission[\"MGMT_value\"] += pred[\"MGMT_value\"]\n\nsubmission[\"MGMT_value\"] \/= len(modelfiles)\nsubmission[\"MGMT_value\"].to_csv(\"submission.csv\")","fc4c82c5":"submission","1085a462":"## train models","5eb19018":"## Use stacked images (3D) and Efficientnet3D model\n\nAcknowledgements:\n\n- https:\/\/www.kaggle.com\/ihelon\/brain-tumor-eda-with-animations-and-modeling\n- https:\/\/www.kaggle.com\/furcifer\/torch-efficientnet3d-for-mri-no-train\n- https:\/\/github.com\/shijianjian\/EfficientNet-PyTorch-3D\n- https:\/\/www.kaggle.com\/rluethy\/efficientnet3d-with-one-mri-type\n    \n    \n**Advantages:**\n- Run Faster\n- Use larger batch size\n\n**Update:**<br>\n\n**V3**:\n- Increase NUM_IMAGES\n- Shuffle images based on types\n- Save model based on AUC (not loss)<br>\n\n**V5**\n- Add 5 folds","f1983035":"<center><h3 style='color:red'>PyTorch | all [MRI TYPES] once is what u need<\/h3><br>BY ELCAISERI@KASSEM<hr><\/center>","bd58531b":"## Model and training classes","41d4de50":"## Ensemble for validation","e6c58293":"## Predict function","9cf9631c":"## Functions to load images","6fce2a48":"## train \/ test splits","32dbbd0f":"## Ensemble for submission"}}