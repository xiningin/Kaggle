{"cell_type":{"21b16ec4":"code","db861cd6":"code","eac74e65":"code","82743514":"code","cdff7649":"code","8da7008b":"code","add4caf2":"code","69159cef":"code","811827b0":"code","fc946417":"code","2f7fd8cb":"markdown","5f9e8a64":"markdown","b175d763":"markdown","739f822e":"markdown","0653fac6":"markdown","f097168e":"markdown","5ea0d14e":"markdown","c330784e":"markdown","d5f9c496":"markdown","488c822c":"markdown","8661f3a8":"markdown"},"source":{"21b16ec4":"import pytest\n\nfrom decimal import Decimal, getcontext\nfrom collections import defaultdict, OrderedDict\n\nPRECISION = Decimal(1 ** - (getcontext().prec - 2))\n\nACE = None\nACE_LOW = None\nACE_DIFF = None\nCARDS = None\nP_ACE_LOW = None\nSCORE_MAX = None\nSCORE_DEALER_STOP = None\n\n\ndef INIT_GAME(cards, score_max=None, ace=None, ace_low=None, score_dealer_stop=None):\n    assert len(cards) > 1, 'Can\\'t play game with 1 card only'\n    global ACE, ACE_LOW, ACE_DIFF, CARDS, P_ACE_LOW, SCORE_MAX, SCORE_DEALER_STOP\n    CARDS = cards\n    c = sorted(cards.keys())\n    ACE = ace or c[-1]\n    ACE_LOW = ace_low or 1\n    ACE_DIFF = ACE - ACE_LOW\n    P_ACE_LOW = cards[ACE]\n    SCORE_MAX = score_max or c[-1] + c[-2]\n    SCORE_DEALER_STOP = score_dealer_stop or round(ACE * 1.55)","db861cd6":"def generate_hands(score_max, hand=None, hand_sum=0):\n    hand = hand or []\n    for c in CARDS:\n        hsum = hand_sum + c\n        if hsum > score_max:\n            if hsum - ACE_DIFF <= score_max:\n                if c == ACE:\n                    c = ACE_LOW\n                    hsum -= ACE_DIFF\n                    h = list(hand)\n                else:\n                    try:\n                        i_ace = hand.index(ACE)\n                        h = list(hand)\n                        h[i_ace] = ACE_LOW\n                        hsum -= ACE_DIFF\n                    except ValueError:\n                        continue\n            else:\n                continue\n        else:\n            h = list(hand)\n        h.append(c)\n        yield h, hsum\n        if hsum < score_max:\n            for h, hsum in generate_hands(score_max, h, hsum):\n                yield h, hsum\n\n\ndef test_generate_hands(hands):\n    n_hands = 0\n    for h, hsum in generate_hands(SCORE_MAX):\n        th = tuple(h)\n        assert hsum <= SCORE_MAX\n        assert th in hands, th\n        hands.remove(th)\n        n_hands += 1\n    assert not hands, 'Some valid hands where not generated: %s' % hands\n    return n_hands\n\n# Test case 1: card deck with 2 cards only, maximal_score = 5\np = Decimal(1) \/ Decimal(2)\ncards = {2: p, 3: p}\nINIT_GAME(cards, score_max=5)\nall_hands = {\n    (2,), (3,), \n    (2,2), (2,3), (3,1), (3,2), \n    (2,2,1), (3,1,1), (1,1,2), \n    (1,1,2,1)\n}\n\nn_hands = test_generate_hands(all_hands)\n\nprint(\n    'Total possible hands for configuration (cards=%s, blackjack_score=%d, ace_card=%d): %d' % (\n        list(CARDS), SCORE_MAX, ACE, n_hands\n    )\n)\n\n# Test case 2: card deck with 3 cards, maximal_score = 7\n\np = Decimal(1) \/ Decimal(3)\ncards = {2: p, 3: p, 4: p}\nINIT_GAME(cards, score_max=7)\nall_hands = {\n    (2,), (3,), (4,), \n    (2,2), (2,3), (2,4), (3,2), (3,3), (3,4), (4,2), (4,3), (4,1),\n    (1,1,3), (1,2,2), (1,2,3), \n    (2,1,2), (2,1,3), (2,2,1), (2,2,2), (2,2,3), (2,3,1), (2,3,2), (2,4,1), \n    (3,2,1), (3,2,2), (3,3,1), \n    (4,1,1), (4,1,2), (4,2,1),\n    (1,1,1,2), (1,1,1,3), (1,1,3,1), (1,1,3,2), (1,2,2,1), (1,2,2,2), (1,2,3,1), \n    (2,1,2,1), (2,1,2,2), (2,1,3,1), (2,2,1,1), (2,2,1,2), (2,2,2,1), (2,3,1,1), \n    (3,2,1,1), \n    (4,1,1,1),\n    (1,1,1,2,1), (1,1,1,2,2), (1,1,1,3,1), (1,1,3,1,1), (1,2,2,1,1), \n    (2,1,2,1,1), (2,2,1,1,1),\n    (1,1,1,2,1,1)\n}\n\nINIT_GAME(cards)\nn_hands = test_generate_hands(all_hands)\nprint(\n    'Total possible hands for configuration (cards=%s, blackjack_score=%d, ace_card=%d): %d' % (\n        list(CARDS), SCORE_MAX, ACE, n_hands\n    )\n)\n","eac74e65":"p = Decimal(1)\/Decimal(13)\np10 = Decimal(4)\/Decimal(13)\ncards = {2:p, 3:p, 4:p, 5:p, 6:p, 7:p, 8:p, 9:p, 10:p10, 11:p}\nINIT_GAME(cards)\n\nassert 21 == SCORE_MAX\nassert 17 == SCORE_DEALER_STOP\nassert 11 == ACE\nassert 1 == ACE_LOW\n\nGAME_HANDS = tuple((tuple(h), hsum) for h, hsum in generate_hands(SCORE_MAX))\n\nprint(\n    'Total possible hands for configuration (cards=%s, blackjack_score=%d, ace_card=%d): %d' % (\n        list(CARDS), SCORE_MAX, ACE, len(GAME_HANDS)\n    )\n)","82743514":"# Some tests to check if hands were generated correctly\n\nassert ((2, 2), 4) in GAME_HANDS\nassert ((11, 10), 21) in GAME_HANDS\nassert ((11, 8, 1), 20) in GAME_HANDS\nassert ((2, 2, 2, 2, 2, 2, 2, 2, 2, 2), 20) in GAME_HANDS\nassert ((2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1), 21) in GAME_HANDS\nassert ((1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), 21) not in GAME_HANDS\nassert ((11, 2, 2, 2, 2, 2), 21) in GAME_HANDS\nassert ((7, 7, 7), 21) in GAME_HANDS\nassert ((11, 1), 12) in GAME_HANDS\nassert ((1, 5, 3, 3, 2), 14) in GAME_HANDS\nassert ((10, 10, 1), 21) in GAME_HANDS\nassert ((8, 10, 1, 2), 21) in GAME_HANDS\n\nprint('Tests passed: generate_hands()')","cdff7649":"def prob_hand(hand):\n    result = Decimal(1)\n    for c in hand:\n        result *= CARDS.get(c, P_ACE_LOW)\n    return result\n\nassert Decimal(4) \/ Decimal(13**2) == pytest.approx(prob_hand([10, 11]), abs=PRECISION)\nassert Decimal(4) \/ Decimal(13**3) == pytest.approx(prob_hand([9, 10, 2]), abs=PRECISION)\nassert Decimal(1) \/ Decimal(13**3) == pytest.approx(prob_hand([1, 6, 9]), abs=PRECISION)\nassert Decimal(1) \/ Decimal(13**10) == pytest.approx(prob_hand([2] * 10), abs=PRECISION)\n\ntp = defaultdict(Decimal)\nhand_count = defaultdict(int)\n\nfor h, hsum in GAME_HANDS:\n    lh = len(h)\n    tp[lh] += prob_hand(h)\n    hand_count[lh] += 1\n\nfor n_cards in tp:\n    if n_cards <= 2:\n        assert tp[n_cards] == pytest.approx(1, abs=PRECISION)\n    else:\n        assert tp[n_cards] < 1\n    print(\n        'Total hands with %d card(s) = %d with total probability = %s' % (\n            n_cards, hand_count[n_cards], tp[n_cards]\n        )\n    )\n\nprint('Tests passed: prob_hand()')","8da7008b":"def is_dealer_hand(hand, hsum=None):\n    if not hsum:\n        hsum = sum(hand)\n    if hsum < SCORE_DEALER_STOP or hsum > SCORE_MAX:\n        return False\n    s = 0\n    low_ace_count = 0\n    for c in hand[:-1]:\n        if c == ACE_LOW:\n            low_ace_count += 1\n            c = ACE\n        s += c\n        if SCORE_DEALER_STOP <= s <= SCORE_MAX:\n            return False\n    return s - ACE_DIFF * low_ace_count < SCORE_DEALER_STOP\n\nassert not is_dealer_hand([3, 4]), 'Sum is too low'\nassert not is_dealer_hand([3, 10, 2]), 'Sum is too low'\nassert is_dealer_hand([3, 4, 10])\nassert not is_dealer_hand([3, 4, 10, 2]), 'Should have stopped collecting cards after 10'\nassert not is_dealer_hand([3] * 7), 'Should have stopped collecting cards after first 6 threes'\nassert is_dealer_hand([3] * 6)\nassert is_dealer_hand([11, 5, 5])\nassert not is_dealer_hand([1, 5, 5, 5, 5]), 'Should have stopped collecting cards after second 5'\nassert is_dealer_hand([1, 5, 10, 2]), 'Initial ace should have been converted to low'\nassert not is_dealer_hand([1, 1, 10, 3, 3, 2]), 'Should have stopped after second 3'\nassert not is_dealer_hand([1, 1, 4, 10]), 'Sum is too low'\nassert is_dealer_hand([1, 1, 4, 10, 1])\nassert is_dealer_hand([1, 1, 4, 10, 2])\nassert not is_dealer_hand([1, 1, 4, 10, 2, 3]), 'Should have stopped after 2'\nassert not is_dealer_hand([11, 1, 1, 1, 4, 2]), 'Should have stopped after 4'\nassert not is_dealer_hand([11, 1, 6, 2]), 'Should have stopped after 6'\nassert is_dealer_hand([1, 1, 6, 10])\n\nprint('Tests passed: is_dealer_hand()')","add4caf2":"# P_INIT is the probability of obtaining a 2-card hand with a given score \n# (probability of the player's initial hand score)\n\nP_INIT = defaultdict(Decimal)\nP = defaultdict(Decimal)\nPROB_DEALER = defaultdict(Decimal)\n\nfor hand, hsum in GAME_HANDS:\n    p = prob_hand(hand)\n    if len(hand) >= 2:\n        P[hsum] += p\n        if len(hand) == 2:\n            P_INIT[hsum] += p\n    if is_dealer_hand(hand):\n        first_card = hand[0]\n        if first_card == ACE_LOW:\n            first_card = ACE\n        PROB_DEALER[first_card, hsum] += p \/ CARDS[first_card]\n\nfor k in sorted(PROB_DEALER):\n    print(k, PROB_DEALER[k])","69159cef":"def prob_win_stay(player_score, dealer_card):\n    return 1 - sum(\n        PROB_DEALER[dealer_card, score]  \n        for score in range(max(SCORE_DEALER_STOP, player_score), SCORE_MAX + 1)\n    )\n\nP_WIN_STAY = defaultdict(Decimal)\n\npossible_player_scores = list(range(4, SCORE_MAX + 1))\n\nfor player_score in possible_player_scores:\n    for dealer_card in CARDS:\n        P_WIN_STAY[player_score, dealer_card] = prob_win_stay(player_score, dealer_card)\n        assert 0 < P_WIN_STAY[player_score, dealer_card] < 1\n\n# Tests\nfor dealer_card in CARDS:\n    p_prev = 0\n    for player_score in possible_player_scores:\n        assert P_WIN_STAY[player_score, dealer_card] >= p_prev, \\\n            'Odds of winning should not decrease with increasing player score'\n        p_prev = P_WIN_STAY[player_score, dealer_card]\n\n# Test against actual game data\ndef p_stay(player_score, prob=P):\n    return prob[player_score] * sum(\n        dealer_card_prob * P_WIN_STAY[player_score, dealer_card]\n        for dealer_card, dealer_card_prob in CARDS.items()\n    )\n\n# TODO: use 2 stddev instead of 5 percentage range\npct = Decimal(5) \/ Decimal(100)\n# actual_win_rate taken from actual game simulations, iter=1e6\nfor ps, actual_win_rate in [\n    (4,  Decimal(0.001724)),\n    (5,  Decimal(0.003379)),\n    (6,  Decimal(0.005087)),\n    (7,  Decimal(0.006960)),\n    (8,  Decimal(0.009181)),\n    (9,  Decimal(0.011334)),\n    (10, Decimal(0.013465)),\n    (11, Decimal(0.016264)),\n    (12, Decimal(0.036160)),\n    (13, Decimal(0.038669)),\n    (14, Decimal(0.039808)),\n    (15, Decimal(0.041533)),\n    (16, Decimal(0.043268)),\n    (17, Decimal(0.044566)),\n    (18, Decimal(0.070093)),\n    (19, Decimal(0.096658)),\n    (20, Decimal(0.159679)),\n    (21, Decimal(0.156376)),\n]:\n    expected_win_rate = pytest.approx(p_stay(ps), rel=pct)\n    assert expected_win_rate == actual_win_rate, (ps, expected_win_rate, actual_win_rate)\n\n# Test simple strategy: no hits\n\nstay_strategy_score = sum(p_stay(ps, prob=P_INIT) for ps in possible_player_scores)\n\nassert pytest.approx(stay_strategy_score, rel=Decimal(1)\/Decimal(100)) == Decimal(0.38)\n\nprint('Win rate if stay with initial hand: %s' % stay_strategy_score)\n    \nprint('Tests passed: p_stay()')\n        \nfor k in sorted(P_WIN_STAY):\n    print(k, P_WIN_STAY[k])\n        ","811827b0":"def prob_win_hit(player_score, dealer_card, has_ace):\n    result = Decimal(0)\n    for card in CARDS:\n        total_score = player_score + card\n        if total_score <= SCORE_MAX:\n            result += CARDS[card] * P_WIN_STAY[total_score, dealer_card]\n        elif has_ace:\n            total_score -= ACE - ACE_LOW\n            if total_score <= SCORE_MAX:\n                result += CARDS[card] * P_WIN_STAY[total_score, dealer_card]\n    return result  \n\nP_WIN_HIT_NO_ACE = defaultdict(Decimal)\nP_WIN_HIT_ACE = defaultdict(Decimal)\n\nfor player_score in possible_player_scores:\n    for dealer_card in CARDS:\n        P_WIN_HIT_NO_ACE[player_score, dealer_card] = prob_win_hit(player_score, dealer_card, False)\n        P_WIN_HIT_ACE[player_score, dealer_card] = prob_win_hit(player_score, dealer_card, True)\n        assert 0 <= P_WIN_HIT_NO_ACE[player_score, dealer_card] <= P_WIN_HIT_ACE[player_score, dealer_card] < 1\n\nassert 0 == P_WIN_HIT_NO_ACE[SCORE_MAX, 2]\nassert P_WIN_STAY[SCORE_MAX, 2] > P_WIN_HIT_ACE[SCORE_MAX, 2]\nassert 0 == P_WIN_HIT_NO_ACE[SCORE_MAX - 1, 2]\nassert P_WIN_STAY[SCORE_MAX - 1, 2] > P_WIN_HIT_ACE[SCORE_MAX - 1, 2]\nassert pytest.approx(CARDS[2] * P_WIN_STAY[SCORE_MAX, 2]) == P_WIN_HIT_NO_ACE[SCORE_MAX - 2, 2]\nassert pytest.approx(\n    CARDS[2] * P_WIN_STAY[SCORE_MAX - 1, 2] + CARDS[3] * P_WIN_STAY[SCORE_MAX, 2]\n) == P_WIN_HIT_NO_ACE[SCORE_MAX - 3, 2]\n\nassert P_WIN_HIT_NO_ACE[2, 2] == P_WIN_HIT_ACE[2, 2] == P_WIN_STAY[2, 2]\nassert P_WIN_HIT_NO_ACE[10, 2] > P_WIN_STAY[10, 2]\nassert P_WIN_HIT_NO_ACE[10, 2] == P_WIN_HIT_ACE[10, 2]\n\nprint('Tests passed: prob_win_hit()')","fc946417":"import numpy as np\nimport pandas as pd\n\nresult_no_ace = np.empty((18, 10), dtype=str)\nresult_ace = np.empty((18, 10), dtype=str)\n\nfor player_score in possible_player_scores:\n    for dealer_card in CARDS:\n        p_stay = P_WIN_STAY[player_score, dealer_card]\n        p_hit_no_ace = P_WIN_HIT_NO_ACE[player_score, dealer_card]\n        if round(p_hit_no_ace - p_stay, ndigits=12) >= 0:\n            result_no_ace[player_score - 4, dealer_card - 2] = 'H'\n        else:\n            result_no_ace[player_score - 4, dealer_card - 2] = 'S'\n            \n        p_hit_ace = P_WIN_HIT_ACE[player_score, dealer_card]\n        if round(p_hit_ace - p_stay, ndigits=12) >= 0:\n            result_ace[player_score - 4, dealer_card - 2] = 'H'\n        else:\n            result_ace[player_score - 4, dealer_card - 2] = 'S'\n\ndef print_decision_table(result):\n    d = pd.DataFrame(\n        result, \n        columns=['D-%d' % d for d in CARDS],\n        index=['P-%d' % p for p in possible_player_scores]\n    )\n    d = d.style.applymap(lambda val: 'background-color: red' if val == 'S' else 'background-color: green')\n    display(d)\n    \nd1 = print_decision_table(result_no_ace)\nd2 = print_decision_table(result_ace)","2f7fd8cb":"Now that we've successfully tested the hand generation logic, let's compute the actual hands possible in the original blackjack game.","5f9e8a64":"**0. Game initialization**\n\nIt would be hard to test our ideas if we try to simulate the original game from the start. For example it would be practically impossible to test that the function that generates card hands works correctly on the original game. Therefore we need to be able to test the hand generation on simpler games (with fewer cards). The global variables below and the initialization function is used to make the games customizable.","b175d763":"** 3.2. Player odds of winning if stays with current hand **","739f822e":"** 3.1. Dealer odds of obtaining a score given initial card **\n\nTo figure out the odds of the dealer obtaining a score given an initial card we need to be able to separate the list of valid dealer hands from the set of total hands we generated and stored in `GAME_HANDS`. Then we could filter the list of hands and add the hand probabilities for each `(dealer_card, dealer_total)` combination.","0653fac6":"**4. Best strategy**\n\nThe idea is that for any given (player_score, dealer_card) combination we compute the max(P_WIN_STAY, P_WIN_HIT) where P_WIN_HIT is either P_WIN_HIT_NO_ACE or P_WIN_HIT_ACE.","f097168e":"**1. Generate all possible hands**\n\nA valid game hand consists of cards that sum up to at most `SCORE_MAX`. We should also take into account the conversion of `ACE` card into `ACE_LOW` if the score exceeds `SCORE_MAX`. To test the validity of the function we will check whether we are able to generate all hands for simpler games.","5ea0d14e":"We need to compute 2 kinds of probabilities of winning:\n1. Player stays with his current hand. In this case the player wins only if his score is greater than the dealer's score. Therefore the probability of winning can be expressed by the following formula:\n\n$$ p\\_win\\_stay(player\\_score, dealer\\_card) = 1 - \\sum_{dealer\\_score=\\max\\{17, player\\_score\\}}^{21}{prob\\_dealer(dealer\\_card, dealer\\_score)}$$\n\nDealer score can never be smaller than 17 (`SCORE_DEALER_STOP`)\n2. Player asks for another card. In this case the probability can be expressed as the sum of probabilities of winning with the new hand total times the probability of receiving each possible card. Note that the new total score could be adjusted if the the player has a high ace and the new total score is greater than `SCORE_MAX`.\n\n$$ p\\_win\\_hit(player\\_score, dealer\\_card, has\\_ace) = \\sum_{card=2}^{11}{P[card] * p\\_win\\_stay(player\\_new\\_score, dealer\\_card)}$$\n\n$$ \nplayer\\_new\\_score = \n\\begin{cases} \nplayer\\_score + card,& \\text{if } player\\_score + card \\leq 21 \\\\\nplayer\\_score - 10 + card,& \\text{if } player\\_score + card \\gt 21 \\land has\\_ace\n\\end{cases}\n$$\n\n$$\np\\_win\\_stay(player\\_new\\_score, dealer\\_card) = 0,\\text{ if } player\\_new\\_score \\gt 21 \\text{ (player busts) }\n$$\n\nThe action plan therefore is:\n1. Compute `prob_dealer()`\n2. Compute `p_win_stay()`\n3. Compute `p_hit_stay()`","c330784e":"The goal of this notebook is to identify the optimal strategy for playing the simplified blackjack game described in [booleans and conditionals tutorial](https:\/\/www.kaggle.com\/colinmorris\/booleans-and-conditionals) from the [introductory python course](https:\/\/www.kaggle.com\/learn\/python).\n\nTo achieve the result we'll accomplish the following steps:\n1. Generate all possible hands in the game.\n2. Compute probabilities for the hands.\n3. Use the probabilities computed above to identify the odds of winning for the player and dealer in specific scenarios.\nValidate the formulas by selecting simple game strategies and comparing the theoretical results computed for the strategies with actual game simulations.\n4. Identify the best strategy to play the game.","d5f9c496":"**3. Player Odds of Winning**\n\nThe player's choice at any point in the game is whether he should stay with the current hand or should get another card with the goal of improving the total without busting. Therefore we need to compute the odds of winning when the player stops collecting cards vs the odds of winning when he is dealt another card. In all cases the probability is affected by the dealer's score\/card.","488c822c":"**2. Compute probabilities for the hands**\n","8661f3a8":"** 3.3. Player odds of winning if hits with current hand **"}}