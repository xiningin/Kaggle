{"cell_type":{"f766aa49":"code","bdbc73b0":"code","a3fac5c5":"code","fd015f42":"code","9545e987":"code","93fe4497":"code","7d3a3860":"code","93f8dfb9":"code","0e098ba3":"code","6caf12b6":"code","1e4c4543":"code","3741fc5f":"code","8c21533a":"code","c252878d":"code","c0696501":"code","639750f7":"code","c5d1b2b2":"code","9c93e571":"code","300401cb":"markdown","0eaf363e":"markdown","1c3658d5":"markdown","fc207400":"markdown","54a262ba":"markdown","49218922":"markdown","a23f00c5":"markdown","180ad4d5":"markdown"},"source":{"f766aa49":"import cv2\nimport os\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport random","bdbc73b0":"tot_size = len(os.listdir('\/kaggle\/input\/captcha-images\/'))\nnum = random.randint(0, tot_size)\nprint(num)\nalli = list(os.listdir('\/kaggle\/input\/captcha-images\/'))\nfile = alli[num]\nprint(file)","a3fac5c5":"solution = file.split('.')[0]\nsolution","fd015f42":"hi = cv2.imread('\/kaggle\/input\/captcha-images\/' + file)","9545e987":"plt.imshow(hi, cmap=\"gray\")\nplt.axis('off')\nplt.show()","93fe4497":"# convert to RGB\nimage = cv2.cvtColor(hi, cv2.COLOR_BGR2RGB)\n# convert to grayscale\ngray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)","7d3a3860":"# create a binary thresholded image\n_, binary = cv2.threshold(gray, 225, 255, cv2.THRESH_BINARY_INV)\n# show it\nplt.imshow(binary, cmap=\"gray\")\nplt.axis('off')\nplt.show()","93f8dfb9":"# find the contours from the thresholded image\ncontours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n# draw all contours\nimage = cv2.drawContours(image, contours, -1, (0, 255, 0), 2)","0e098ba3":"# show the image with the drawn contours\nplt.imshow(image)\nplt.axis('off')\nplt.show()","6caf12b6":"x = {}\nfor m in range(len(contours)):\n    mini = 1000\n    for k in range(len(contours[m])):\n        first = contours[m][k][0][0]\n        if first < mini:\n            mini = first\n    mini1 = mini\n    #print(mini1)\n    \n    mini = 1000\n    for k in range(len(contours[m])):\n        first = contours[m][k][0][1]\n        if first < mini:\n            mini = first\n    mini2 = mini\n    #print(mini2)\n    \n    maxi = 0\n    for k in range(len(contours[m])):\n        first = contours[m][k][0][1]\n        if first > maxi:\n            maxi = first\n    maxi2 = maxi\n    #print(maxi2)\n    \n    maxi = 0\n    for k in range(len(contours[m])):\n        first = contours[m][k][0][0]\n        if first > maxi:\n            maxi = first\n    maxi1 = maxi\n    #print(maxi1)\n    x[m] = maxi2 - mini2","1e4c4543":"biggie = sorted(x, key=x.get)","3741fc5f":"s = {}\ndef plotting(num):\n    m = biggie[num]\n    mini = 1000\n    for k in range(len(contours[m])):\n        first = contours[m][k][0][0]\n        if first < mini:\n            mini = first\n    mini1 = mini\n    #print(mini1)\n\n    mini = 1000\n    for k in range(len(contours[m])):\n        first = contours[m][k][0][1]\n        if first < mini:\n            mini = first\n    mini2 = mini\n   # print(mini2)\n\n    maxi = 0\n    for k in range(len(contours[m])):\n        first = contours[m][k][0][1]\n        if first > maxi:\n            maxi = first\n    maxi2 = maxi\n    #print(maxi2)\n\n    maxi = 0\n    for k in range(len(contours[m])):\n        first = contours[m][k][0][0]\n        if first > maxi:\n            maxi = first\n    maxi1 = maxi\n    #print(maxi1)\n    ret = [mini2, maxi2, mini1, maxi1]\n    s[num] = mini1\n    return ret","8c21533a":"fig, axs = plt.subplots(2, 5)\nwow = plotting(-1)\naxs[0, 0].imshow(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2], cmap = 'gray')\naxs[0,0].axis('off')\nwow = plotting(-2)\naxs[0, 1].imshow(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2], cmap = 'gray')\naxs[0,1].axis('off')\nwow = plotting(-3)\naxs[0,2].imshow(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2], cmap = 'gray')\naxs[0,2].axis('off')\nwow = plotting(-4)\naxs[0,3].imshow(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2], cmap = 'gray')\naxs[0,3].axis('off')\nwow = plotting(-5)\naxs[0,4].imshow(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2], cmap = 'gray')\naxs[0,4].axis('off')\nwow = plotting(-6)\naxs[1,0].imshow(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2], cmap = 'gray')\naxs[1,0].axis('off')\nwow = plotting(-7)\naxs[1,1].imshow(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2], cmap = 'gray')\naxs[1,1].axis('off')\nwow = plotting(-8)\naxs[1,2].imshow(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2], cmap = 'gray')\naxs[1,2].axis('off')\nwow = plotting(-9)\naxs[1,3].imshow(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2], cmap = 'gray')\naxs[1,3].axis('off')\nwow = plotting(-10)\naxs[1,4].imshow(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2], cmap = 'gray')\naxs[1,4].axis('off')\nwow = plotting(-11)\n","c252878d":"siggie = sorted(s, key=s.get)","c0696501":"def checkforerror(wow):\n    white = cv2.countNonZero(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2])\n    total = (binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2]).shape[0] * (binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2]).shape[1]\n    div = white\/total\n    if div > 0.63: \n        if (wow[1] - wow[0]) - (wow[3] - wow[2]) > -5:\n            return True\n    elif div < 0.29:\n        return True\n    else: return False\ndef checkforerrorout(wow):\n    white = cv2.countNonZero(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2])\n    total = (binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2]).shape[0] * (binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2]).shape[1]\n    div = white\/total\n    return div\ndef checkfordoubles(wow):\n    if (wow[1] - wow[0]) - (wow[3] - wow[2]) < -4: \n        if checkforerrorout(wow) < 0.56: return True\n    elif (wow[1] - wow[0]) - (wow[3] - wow[2]) < 1:\n        if checkforerrorout(wow) < 0.40: return True\n    else: return False","639750f7":"wow = plotting(siggie[0])\nplt.imshow(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2], cmap = 'gray')\nprint('test 1', checkforerror(wow))\nprint((wow[1] - wow[0]) - (wow[3] - wow[2]) < -4)\nprint(checkforerrorout(wow))\n\nprint((wow[1] - wow[0]) - (wow[3] - wow[2]) < 1)\nprint('test 2', checkfordoubles(wow))","c5d1b2b2":"pos = 0\na = 0\nim = 0\ndesired = 10\nfig, axs = plt.subplots(2, 5)\nfirst = False\nwhile a < desired:\n    print('a = ', a, 'desired = ', desired)\n    \n    n1 = pos \/\/ 5\n    n2 = pos % 5\n    print('using position', n1, n2)\n    wow = plotting(siggie[im])\n    print('trying to plot ', im, 'checking for errors...')\n    err = checkforerror(wow)\n    errs = checkfordoubles(wow)\n    print('% = ', checkforerrorout(wow))\n    if err:\n        print('Error 1 at', a)\n        #plt.imshow(binary[wow[0]-2:wow[1] + 2, wow[2]-2:wow[2] + half +7], cmap = 'gray')\n        #inp = str(input('Skip this image? '))\n        im += 1\n        print('im bumped to', im)\n        wow = plotting(siggie[im])\n        print('trying to plot ', im, 'checking for errors...')\n        err = checkforerror(wow)\n        errs = checkfordoubles(wow)\n        print('% = ', checkforerrorout(wow))\n        if errs:\n            \n            \n            print('Error 2 at bumped image')\n            if first == False:\n                half = abs(wow[0] - wow[1]) \/\/ 2\n                axs[n1, n2].imshow(binary[wow[0]-2:wow[1] + 2, wow[2]-2:wow[2] + half +7], cmap = 'gray')\n                xx = checkforerrorout(wow)\n                axs[n1,n2].set_title(solution[pos]+' '+ str(int(xx * 100)))\n                axs[n1,n2].axis('off')\n                im -= 1\n                first = True\n            else:\n                axs[n1, n2].imshow(binary[wow[0]-2:wow[1] + 2, wow[2] + half + 7:wow[3]+2], cmap = 'gray')\n                xx = checkforerrorout(wow)\n                axs[n1,n2].set_title(solution[pos]+' '+ str(int(xx * 100)))\n                axs[n1,n2].axis('off')\n                first = False\n\n        \n        \n        else:\n            print('No errors in bumped image')\n            axs[n1, n2].imshow(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2], cmap = 'gray')\n            #xx = checkforerrorout(wow)\n            axs[n1,n2].set_title(solution[pos]+' '+ str(int(xx * 100)))\n            axs[n1,n2].axis('off')\n    elif errs:\n        print('Error 2 at', a)\n        if first == False:\n            half = abs(wow[0] - wow[1]) \/\/ 2\n            axs[n1, n2].imshow(binary[wow[0]-2:wow[1] + 2, wow[2]-2:wow[2] + half +8], cmap = 'gray')\n            xx = checkforerrorout(wow)\n            axs[n1,n2].set_title(solution[pos]+' '+ str(int(xx * 100)))\n            axs[n1,n2].axis('off')\n            im -= 1\n            first = True\n        else:\n            axs[n1, n2].imshow(binary[wow[0]-2:wow[1] + 2, wow[2] + half + 8:wow[3]+2], cmap = 'gray')\n            xx = checkforerrorout(wow)\n            axs[n1,n2].set_title(solution[pos]+' '+ str(int(xx * 100)))\n            axs[n1,n2].axis('off')\n            first = False\n            \n    else:\n        print('No errors found!')\n        axs[n1, n2].imshow(binary[wow[0]-2:wow[1]+2, wow[2]-2:wow[3]+2], cmap = 'gray')\n        xx = checkforerrorout(wow)\n        axs[n1,n2].set_title(solution[pos]+' '+ str(int(xx * 100)))\n        axs[n1,n2].axis('off')\n        print('DONE PLOTTING - im', im)\n\n    a += 1\n    pos += 1\n    im += 1","9c93e571":"plt.imshow(hi, cmap=\"gray\")\nplt.show()","300401cb":"### Sort left to right","0eaf363e":"### Conclusion\nThe above segmentation looks good. We can move on to the next file, captchas_saving.ipynb, where we will save to disk each segmentation in its appropriate directory. \nThank you for reading, and if you enjoyed my work please don't forget to leave an upvote!","1c3658d5":"# CAPTCHA EDA\n## By Sergei Issaev\n### Introduction\nThis notebook is part of the preprocessing pipeline which takes in CAPTCHA images and outputs the solution. This is the first notebook in the four part series, which can be used as an EDA, and wherein I define step-by-step the preprocessing performed in order to invert, segment and save each of the 10 alphanumerics. For a more complete description, please see my article published at: https:\/\/medium.com\/@sergei740.","fc207400":"### Compare the above segmentations with the original image","54a262ba":"### Import Libraries","49218922":"### Load Data","a23f00c5":"### Sort Contours","180ad4d5":"### Preprocessing"}}