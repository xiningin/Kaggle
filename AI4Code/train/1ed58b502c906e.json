{"cell_type":{"e0dc30b1":"code","b2f2861f":"code","277e45ec":"code","2d186a9a":"code","0dd58f4a":"code","0c4613b8":"code","038b99a3":"code","d3e0664b":"code","251c49d8":"code","19a6f512":"code","c4e97218":"code","3c4eab88":"code","ea3dfb22":"code","92502290":"code","a77f0dc2":"code","95ddc99b":"code","f9110969":"code","1a14211b":"code","e2d2254f":"code","50081910":"code","65c802bf":"code","fce15d68":"code","8d0db18c":"code","91999760":"code","93ba08da":"code","d1032b6e":"code","ac0ef918":"code","f8a396c0":"code","f988c316":"code","b7115965":"code","b5acafd4":"code","9a1889e5":"code","cd4ec15c":"code","4cdae178":"code","3a17d525":"code","731ec5ac":"code","c053a232":"code","6803b090":"code","aaecb8be":"code","f3443302":"code","b4202f31":"code","7fb4157e":"code","ea853afd":"code","01d93194":"code","91489bbd":"code","2b6a8e42":"code","0c39d8c3":"code","0d0c9f0b":"code","02d955e2":"code","63c63f0d":"code","858d335b":"code","5fc95b84":"code","0fcc1903":"code","a4c464e6":"code","0db0d0a6":"code","09c26c9c":"code","bbf5ac7c":"code","c060c385":"code","9f67fbeb":"code","6a2553ef":"code","c7f19c29":"code","2f49ed9f":"code","64b9376d":"code","bff705b0":"code","dbfe3aa4":"markdown","da50b532":"markdown","fcb76281":"markdown","f57ce1b2":"markdown","7a2bdfb8":"markdown","874a218f":"markdown","257c27d8":"markdown","18ae787a":"markdown","fd4bead9":"markdown","06ea0b8f":"markdown","1cf4542d":"markdown","a9bbd4ee":"markdown","b702a2ce":"markdown","ce859b59":"markdown","14ee9e10":"markdown","924ec7bf":"markdown","28f1f82b":"markdown","e5269817":"markdown","6c8ddb10":"markdown","c549d780":"markdown","6dd05c49":"markdown","0055eedc":"markdown","b6dc7246":"markdown","90bdb147":"markdown","9bbbc610":"markdown","485ef9fb":"markdown","1acf4ae3":"markdown"},"source":{"e0dc30b1":"import pandas as pd\nimport numpy as np\nfrom pathlib import Path\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom sklearn import metrics as sm","b2f2861f":"PATH_TO_DATA = Path('\/kaggle\/input\/data-extraction-from-json-additional-features')","277e45ec":"train_df = pd.read_pickle(PATH_TO_DATA\/'train_extracted.pkl')\ntest_df = pd.read_pickle(PATH_TO_DATA\/'test_extracted.pkl')\ntarget = pd.read_pickle(PATH_TO_DATA\/'target.pkl')","2d186a9a":"train_df.head(3)","0dd58f4a":"target.head(3)","0c4613b8":"f'Train set\\'s shape is {train_df.shape}, of the test set is {test_df.shape} and targer set\\'s shape is {target.shape}.'","038b99a3":"# There are no missed values for the train set\nfor i in train_df.columns:\n    if train_df[i].isnull().sum() > 0:\n        print(i, train_df[i].isnull().sum())","d3e0664b":"# So as for the test set\nfor i in test_df.columns:\n    if test_df[i].isnull().sum() > 0:\n        print(i, test_df[i].isnull().sum())","251c49d8":"full_df = pd.concat([train_df, test_df], sort=False)\nfull_df.shape","19a6f512":"if all(train_df.columns == test_df.columns):\n    print('Train and test features are identical')\n\nif len(full_df.index.unique()) == len(full_df.index):\n    print('There is no repeating games in the train and test datasets.')","c4e97218":"def gini(fpr, tpr):\n    \"\"\"\n    Function calculates Gini coefficient.\n    fpr - the vector of class labels;\n    tpr - the vector of feature(s) values.\n    \"\"\"\n    return -(2 * sm.roc_auc_score(fpr, tpr) - 1)","3c4eab88":"gini_df = {}\nfor i in [x for x in list(train_df.columns) if x not in list(train_df.filter(like = 'item').columns)]:\n    gini_df[i] = gini(target['radiant_win'].values, train_df[i])\ngini_df = pd.DataFrame.from_dict(gini_df, orient = 'index',columns = ['gini'])\ngini_df['gini_abs'] = abs(gini_df['gini'])\ngini_df = gini_df.sort_values('gini_abs', ascending = False)","ea3dfb22":"# top 10, baracks_kills and tower_kills are promising\ngini_df.head(10)","92502290":"# 10 loosers\ngini_df.tail(10).index","a77f0dc2":"# Let's plot our data.\nimport seaborn as sns\nfrom matplotlib import pyplot as plt","95ddc99b":"#Just a slight disbalance\nsns.countplot(target['radiant_win'])\nplt.title('Result distribution')\nplt.show();","f9110969":"# Seems pretty the same for both samples.\nfig, ax = plt.subplots(1, 2, figsize=(12, 5), squeeze=False)\nsns.distplot(train_df['game_time'], ax = ax[0][0])\nsns.distplot(test_df['game_time'], ax = ax[0][1])\nax[0][0].set_title('Train')\nax[0][1].set_title('Test')\nplt.show();","1a14211b":"sns.distplot(target.duration)\nplt.title('Duration')\nplt.show();","e2d2254f":"train_avg_time = round(train_df['game_time'].mean(),2)\ntest_avg_time = round(test_df['game_time'].mean(),2)\ntrain_std_time = round(train_df['game_time'].std(),2)\ntest_std_time = round(test_df['game_time'].std(),2)\nprint(f'Average game_time for train - {train_avg_time}, test - {test_avg_time}.')\nprint(f'Standard deviation for train = {train_std_time}, for test = {test_std_time}.')","50081910":"fig, ax = plt.subplots(1, 2, figsize=(12, 5), squeeze=False)\nsns.distplot(train_df[target['radiant_win'] == 1]['game_time'], hist = False, label = 'R_WIN',ax = ax[0][0])\nsns.distplot(train_df[target['radiant_win'] == 0]['game_time'], hist = False, label = 'D_WIN', ax = ax[0][0])\nsns.distplot(target[target['radiant_win'] == 1]['duration'], hist = False, label = 'R_WIN', ax = ax[0][1])\nsns.distplot(target[target['radiant_win'] == 0]['duration'], hist = False, label = 'D_WIN', ax = ax[0][1])\nplt.legend()\nplt.show();","65c802bf":"# Quite a low value of index\ng_game_time = gini(target['radiant_win'].values, train_df['game_time'])\ng_duration = gini(target['radiant_win'].values, target['duration'])\nprint(f'Gini for game_time  = {g_game_time}')\nprint(f'Gini for duration  = {g_duration}') ","fce15d68":"# What about game_mode?\nfig, ax = plt.subplots(1, 2, figsize=(12, 5), squeeze=False)\na = sns.countplot(train_df['game_mode'], ax = ax[0][0])\nfor p in a.patches:\n    a.annotate(format(p.get_height()), (p.get_x() + p.get_width() \/ 2., p.get_height()),\\\n                ha = 'center', va = 'center', xytext = (0, 10), textcoords = 'offset points')\nb = sns.countplot(test_df['game_mode'], ax = ax[0][1])\nfor p in b.patches:\n    b.annotate(format(p.get_height()), (p.get_x() + p.get_width() \/ 2., p.get_height()),\\\n                ha = 'center', va = 'center', xytext = (0, 10), textcoords = 'offset points')\nax[0][0].set_title('Train')\nax[0][1].set_title('Test')\nplt.show();","8d0db18c":"fig = plt.figure(figsize=(8, 5)) \nsns.countplot(train_df['game_mode'], hue = target['radiant_win'])\nplt.show();","91999760":"pd.crosstab(train_df['game_mode'], target['radiant_win'], normalize = 'index').sort_values(1)","93ba08da":"pd.crosstab(train_df['game_mode'], columns = target['radiant_win'], values = target['duration'], aggfunc = 'mean')","d1032b6e":"pd.crosstab(train_df['game_mode'], columns = target['radiant_win'], values = target['game_time'], aggfunc = 'mean')","ac0ef918":"train_df['lobby_type'].value_counts(normalize = True)","f8a396c0":"test_df['lobby_type'].value_counts(normalize = True)","f988c316":"# Radiant_win rate by lobby_type distribution in game_time\nfig, ax = plt.subplots(1, 2, figsize=(12, 5), squeeze=False)\nsns.distplot(train_df[train_df['lobby_type'] == 0]['game_time'], hist = False, label = '0', ax = ax[0][0])\nsns.distplot(train_df[train_df['lobby_type'] == 7]['game_time'], hist = False, label = '7', ax = ax[0][0])\nsns.distplot(test_df[test_df['lobby_type'] == 0]['game_time'], hist = False, label = '0', ax = ax[0][1])\nsns.distplot(test_df[test_df['lobby_type'] == 7]['game_time'], hist = False, label = '7', ax = ax[0][1])\nax[0][0].set_title('Train')\nax[0][1].set_title('Test')\nplt.legend()\nplt.show();","b7115965":"# Objective_len\nfig, ax = plt.subplots(1, 2, figsize=(12, 5), squeeze=False)\na = sns.countplot(train_df['objectives_len'], ax = ax[0][0])\na.set_xticklabels(a.get_xticklabels(),rotation=90, horizontalalignment='right')\nb = sns.countplot(test_df['objectives_len'], ax = ax[0][1])\nb.set_xticklabels(b.get_xticklabels(),rotation=90, horizontalalignment='right')\nax[0][0].set_title('Train')\nax[0][1].set_title('Test')\nplt.show();","b5acafd4":"train_df[train_df.iloc[:,:5].columns].corr()","9a1889e5":"fig, ax = plt.subplots(1, 2, figsize=(12, 5), squeeze=False)\na = sns.scatterplot(train_df['chat_len'], train_df['chat_len'], ax = ax[0][0])\nb = sns.scatterplot(test_df['chat_len'], test_df['chat_len'], ax = ax[0][1])\nax[0][0].set_title('Train')\nax[0][1].set_title('Test')\nplt.show();","cd4ec15c":"train_df.filter(like = 'chat').columns","4cdae178":"g_chat_len = gini(target['radiant_win'].values, train_df['chat_len'].values)\ng_radiant_chat_len = gini(target['radiant_win'].values, train_df['radiant_chat_len'].values)\ng_dire_chat_len = gini(target['radiant_win'].values, train_df['dire_chat_len'].values)\ng_diff_chat_len = gini(target['radiant_win'].values, train_df['diff_chat_len'].values)\ng_radiant_chat_memb = gini(target['radiant_win'].values, train_df['radiant_chat_memb'].values)\ng_dire_chat_memb = gini(target['radiant_win'].values, train_df['dire_chat_memb'].values)\ng_diff_chat_memb = gini(target['radiant_win'].values, train_df['diff_chat_memb'].values)\nprint(f'Gini for chat_len = {g_chat_len}, radiant_chat_len = {g_radiant_chat_len}, dire_chat_len = {g_dire_chat_len}, diff_chat_len = {g_diff_chat_len}')\nprint(f'radiant_chat_memb = {g_radiant_chat_memb}, dire_chat_memb = {g_dire_chat_memb}, diff_chat_memb = {g_diff_chat_memb}')","3a17d525":"train_size = train_df.shape[0]\nhero_columns = [c for c in full_df.columns if '_hero_' in c]\ntrain_hero_id = train_df[hero_columns]\ntrain_hero_id.head(3)","731ec5ac":"for team in 'r', 'd':\n    players = [f'{team}{i}' for i in range(1, 6)]\n    hero_columns = [f'{player}_hero_id' for player in players]\n    d = pd.get_dummies(full_df[hero_columns[0]])\n    for c in hero_columns[1:]:\n        d += pd.get_dummies(full_df[c])\n    full_df = pd.concat([full_df, d.add_prefix(f'{team}_hero_')], axis=1)\n    full_df.drop(columns=hero_columns, inplace=True)\n    \ntrain_df = full_df.iloc[:train_size, :]\ntest_df = full_df.iloc[train_size:, :]","c053a232":"if all(train_df.filter(like = 'hero').columns == test_df.filter(like = 'hero').columns):\n    print('hero_ids in the train sample are the same as in the test sample.')","6803b090":"train_df[train_df.filter(like = 'hero').columns].corrwith(target.radiant_win).abs().sort_values(ascending=False).head(12)","aaecb8be":"train_df[train_df.filter(like = 'hero').columns].corrwith(target.radiant_win).abs().sort_values(ascending=False).tail(12)","f3443302":"heroes = pd.DataFrame(train_df[train_df.filter(like = 'hero').columns].sum().sort_values(ascending = False)\n    , columns = ['Train']).merge(pd.DataFrame(test_df[test_df.filter(like = 'hero').columns].sum()\n    , columns = ['Test']), left_index = True, right_index = True)\nheroes['train_occ'] = round(heroes['Train']\/train_df.shape[0]*100,2)\nheroes['test_occ'] = round(heroes['Test']\/test_df.shape[0]*100,2)\nheroes.head(12)","b4202f31":"# Kinda good news\nheroes[['train_occ', 'test_occ']].corr()","7fb4157e":"# What about our most succesful hero_ids?\nheroes.loc[['d_hero_32','r_hero_32','r_hero_22','r_hero_19',\n      'd_hero_22','d_hero_19','d_hero_92','d_hero_91',\n      'd_hero_73','r_hero_92','r_hero_91']]","ea853afd":"train_df.filter(like = 'r1').columns","01d93194":"#let's make our life simplier\ndef combine_numeric_features (df, feature_suffixes):\n    for feat_suff in feature_suffixes:\n        for team in 'r', 'd':\n            players = [f'{team}{i}' for i in range(1, 6)] # r1, r2...\n            player_col_names = [f'{player}_{feat_suff}' for player in players] # e.g. r1_gold, r2_gold\n            \n            df[f'{team}_{feat_suff}_max'] = df[player_col_names].max(axis=1) # e.g. r_gold_max\n            df[f'{team}_{feat_suff}_mean'] = df[player_col_names].mean(axis=1) # e.g. r_gold_mean\n            df[f'{team}_{feat_suff}_min'] = df[player_col_names].min(axis=1) # e.g. r_gold_min\n            df[f'{team}_{feat_suff}_sum'] = df[player_col_names].sum(axis=1)\n            df[f'{team}_{feat_suff}_std'] = df[player_col_names].std(axis=1)\n            \n            df.drop(columns=player_col_names, inplace=True) # remove raw features from the dataset\n            \n    return df","91489bbd":"numeric_features = ['kills', 'deaths', 'assists', 'denies', 'gold', 'xp', 'health', \n                    'max_health', 'max_mana', 'level', 'towers_killed', 'stuns', 'creeps_stacked', \n                    'camps_stacked', 'lh', 'rune_pickups', 'firstblood_claimed', 'teamfight_participation', \n                    'roshans_killed', 'obs_placed', 'sen_placed', 'dam_diff', 'ability_upgrades']","2b6a8e42":"train_df = combine_numeric_features(train_df, numeric_features)\ntest_df = combine_numeric_features(test_df, numeric_features)","0c39d8c3":"train_df.head(3)","0d0c9f0b":"# Creating vectors of x and y\nx_values = []\ny_values = []\nfor team in 'r','d':\n    players = [f'{team}{i}' for i in range(1, 6)]\n    for i in players:\n        x_values += list(train_df[f'{i}_x'])\n        y_values += list(train_df[f'{i}_y'])\ncoord_df = pd.DataFrame(x_values, columns = ['x'])\ncoord_df['y'] = y_values\ncoord_df['radiant_win'] = list(target['radiant_win'])*10\ncoord = pd.pivot_table(data = coord_df, index = 'y', columns = 'x', values = 'radiant_win', aggfunc = 'mean').fillna(0)","02d955e2":"fig, ax = plt.subplots(figsize=(20,10))\nsns.heatmap(coord.sort_index(ascending = False), ax = ax);","63c63f0d":"def make_coordinate_features(df):\n    for team in 'r', 'd':\n        players = [f'{team}{i}' for i in range(1, 6)] # r1, r2...\n        for player in players:\n            df[f'{player}_distance'] = np.sqrt(df[f'{player}_x']**2 + df[f'{player}_y']**2)\n            df.drop(columns=[f'{player}_x', f'{player}_y'], inplace=True)\n    return df","858d335b":"train_df = make_coordinate_features(train_df)\ntest_df = make_coordinate_features(test_df)","5fc95b84":"train_df = combine_numeric_features(train_df, ['distance'])\ntest_df = combine_numeric_features(test_df, ['distance'])","0fcc1903":"# As expected baracks_kills feature is quite strong\nbaracks = pd.crosstab(train_df['diff_baracks_kills'],target['radiant_win'], normalize = 'index')\nsns.lineplot(y = baracks.index, x=baracks[1]);","a4c464e6":"# But baracks are killed mostly in the end of the game, so often diff_baracks_kills = 0\ntrain_df['diff_baracks_kills'].value_counts()","0db0d0a6":"towers = pd.crosstab(train_df['diff_tower_kills'],target['radiant_win'], normalize = 'index')\nsns.lineplot(y = towers.index, x=towers[1]);","09c26c9c":"# A bit better with towers\ntrain_df['diff_tower_kills'].value_counts()","bbf5ac7c":"aegis = pd.crosstab(train_df['diff_aegis'],target['radiant_win'], normalize = 'index')\nsns.lineplot(y = aegis.index, x=aegis[1]);","c060c385":"def add_items_dummies(df_train, df_test):\n    \n    full_df = pd.concat([df_train, df_test], sort=False)\n    train_size = df_train.shape[0]\n\n    for team in 'r', 'd':\n        players = [f'{team}{i}' for i in range(1, 6)]\n        item_columns = [f'{player}_items' for player in players]\n\n        d = pd.get_dummies(full_df[item_columns[0]].apply(pd.Series).stack()).sum(level=0, axis=0)\n        dindexes = d.index.values\n\n        for c in item_columns[1:]:\n            d = d.add(pd.get_dummies(full_df[c].apply(pd.Series).stack()).sum(level=0, axis=0), fill_value=0)\n            d = d.ix[dindexes]\n\n        full_df = pd.concat([full_df, d.add_prefix(f'{team}_item_')], axis=1, sort=False)\n        full_df.drop(columns=item_columns, inplace=True)\n\n    df_train = full_df.iloc[:train_size, :]\n    df_test = full_df.iloc[train_size:, :]\n\n    return df_train, df_test","9f67fbeb":"def drop_consumble_items(df_train, df_test):\n    \n    full_df = pd.concat([df_train, df_test], sort=False)\n    train_size = df_train.shape[0]\n\n    for team in 'r', 'd':\n        consumble_columns = ['tango', 'tpscroll', \n                             'bottle', 'flask',\n                            'enchanted_mango', 'clarity',\n                            'faerie_fire', 'ward_observer',\n                            'ward_sentry']\n        \n        starts_with = f'{team}_item_'\n        consumble_columns = [starts_with + column for column in consumble_columns]\n        full_df.drop(columns=consumble_columns, inplace=True)\n\n    df_train = full_df.iloc[:train_size, :]\n    df_test = full_df.iloc[train_size:, :]\n\n    return df_train, df_test","6a2553ef":"train_df, test_df = add_items_dummies(train_df, test_df)\ntrain_df, test_df = drop_consumble_items(train_df, test_df)","c7f19c29":"train_df.columns","2f49ed9f":"train_df[train_df.filter(like = 'item').columns].corrwith(target.radiant_win).abs().sort_values(ascending=False).head(20)","64b9376d":"gini_df = {}\nfor i in [x for x in list(train_df.columns) if x not in list(train_df.filter(like = 'item').columns)]:\n    gini_df[i] = gini(target['radiant_win'].values, train_df[i])\ngini_df = pd.DataFrame.from_dict(gini_df, orient = 'index',columns = ['gini'])\ngini_df['gini_abs'] = abs(gini_df['gini'])\ngini_df = gini_df.sort_values('gini_abs', ascending = False)","bff705b0":"gini_df.head(40)","dbfe3aa4":"Less numerous game_modes have lower radiant_win rate on average. May be additional reason for game_mode mergings.","da50b532":"Worth noticing, there is no 16th game_mode in test sample. Consider dropping. 22nd game_mode is the most popular. Some mergings of game_modes are possible.","fcb76281":"### <center> Players' features","f57ce1b2":"Let's try to analyse inventories. My high recommendation [Hero_Items Guide](https:\/\/www.kaggle.com\/grazder\/hero-items-guide).","7a2bdfb8":" [Gini coefficient](https:\/\/en.wikipedia.org\/wiki\/Gini_coefficient) is a good tool to see how good is the feature in terms of class separation. Often used in Credit Scoring to analyse the power of model for default and non-default accounts discrimination. Coefficient is defined below and used for analysis.","874a218f":"Let's calculate gini for all features before preprocessing.","257c27d8":"Quite a strange dependance from diff_aegis feature ","18ae787a":"Objectives_len most often equals 1. Interesting to see what is this objective. Assume this is 'First_blood' message as this message is first almost all the time. First_blood may be useful in predicting. Let's check whether objectives_len correlates with game_time.","fd4bead9":"As can be seen, as nearer players to upper right corner, as bigger probability of radiant_win. Vice versa, if players near lower left corner (radiant base), radiant_win prob is lower. But how to aggregate coordiantes? For a good start - [Combine hero features into team ones - basic](https:\/\/www.kaggle.com\/daemonis\/combine-hero-features-into-team-ones-basic).","06ea0b8f":"Oh, you reached the end of the kernel. Hope it was useful. Please don't forget to upvote.","1cf4542d":"## Data description\n\nWe have the following files:\n\n- `train_extracted.pkl`, `train_extracted.pkl`: features extracted from json files (details in [\nData extraction from json- additional features](https:\/\/www.kaggle.com\/karthur10\/data-extraction-from-json-additional-features))\n- `targets.pkl`: results of training games (including the winner)","a9bbd4ee":"Seems like Dire's team more often wins in longer games. Notice, the game starts before 0. So, I assume 0 is the time of first creaps wave. Try to additionally analyse game_time yourself before using it in your model, there are obvious mistakes in data which can spoil it. ","b702a2ce":"Chats are quite long. So, players communicate much. We have few ouliers. I guess, chat_len as a feature is rather noisy here. Just a voise of a common sense. The feature doesn't show us even which team communicates more. That's why in [Data extraction from json- additional features](https:\/\/www.kaggle.com\/karthur10\/data-extraction-from-json-additional-features) new features for chats were created. Let's check them out.","ce859b59":"\nWhat about the weakest ones?","14ee9e10":"Yet, seems like aegis is very important. What's interesting is that by first sight different items are important for different teams. Let's now look at our gini.","924ec7bf":"# <center> Dota 2 winner prediction competition\n\n##### <center> By Artur Kolishenko (@payonear)\n     \n<center> <img src='https:\/\/whyigame.files.wordpress.com\/2015\/05\/dota2header.jpg?w=1163&h=364&crop=1.jpeg'>\n","28f1f82b":" Let's see the correlation of each hero_id with radiant_win variable. Seems, that heroes with id: 32,22,19, 91, 92 have quite a high correlation with the result. Maybe these heroes are strong?","e5269817":"## Exploratory Data Analysis\nLet's look at our data to understand it and generate some ideas for future model.","6c8ddb10":"Not a huge difference, but 'diff_chat_len' is better feature than simle 'chat_len'. Anyway gini coefficient value is rather low. Consider dropping.","c549d780":"Obviously, it does. So, the message here is that objectives_len shows almost the same as game_time. We may check the point in time when the first_blood occured. Earlier first_blood may cause more agressive game, maybe it has impact on the result. Interesting note, chat_len doesn't correlate much with game_time. Which means, that chatting is not quite regular in the game.","6dd05c49":"Be careful, many features are highly correlated. That's important especially in case of linear models. Now, I propose to look at coordinate features, as they've already shown high gini coef values.","0055eedc":"Let's analyse player's features. It's very important to understand, that the sequence of players plays no role. Which means doesn't matter whether the player with the same statistics is r_1 or r_2 etc. So we should consider methods of feature aggregations for the whole team. The very first feature is hero_id. Let's create dummies for hero_ids and analyse what kind of heroes we have.","b6dc7246":"There are 5 non-player features:\n* game_time;\n* game_mode;\n* lobby_type;\n* objectives_len;\n* chat_len.","90bdb147":"Look at other player's features. As in case of hero_ids there is no sense in players' sequence. We should consider some ways to avoid 'r1', 'r2' etc. I propose to calculate statistics like max, mean, min, std per team and feature. First of all it'll help to avoid the sequence issue, secondly, reduce dimensionality.","9bbbc610":"As can be seen, heroes 14,11,32,8,74,35 etc. are very popular amongst players. 14 is chosen in more than 40% of games (hero may be chosen just by one team in the same game). Obviously, train and test samples have almost the same hero_id distribution and that's a good news. But, worth noticing, that there is a huge difference in hero_id occurances. 66th hero_id barely appears just in 1% of the games. So, maybe could be useful to use not every hero-id dummy.","485ef9fb":"Obviously, Dires win longer games on average. Btw, notice, 23rd game_mode is the shortest game_mode.","1acf4ae3":"Lobby_types have different time distribution, but still the effect on the result is not obvious. As a result low gini value."}}