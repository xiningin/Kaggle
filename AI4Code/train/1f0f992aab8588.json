{"cell_type":{"233cdceb":"code","67a926b3":"code","bb70bec8":"code","f132f481":"code","c10478be":"code","8ed48830":"code","60d546f1":"code","f9d2826a":"code","ce803d66":"code","cb8cbd5f":"markdown","d4f9b88f":"markdown","e335cd07":"markdown","811e134f":"markdown"},"source":{"233cdceb":"import os\n\nimport numpy as np\nimport pandas as pd\nimport cv2\nimport matplotlib.pyplot as plt","67a926b3":"df_train = pd.read_csv(\"..\/input\/sartorius-cell-instance-segmentation\/train.csv\")\ndf_train","bb70bec8":"# ref: https:\/\/www.kaggle.com\/inversion\/run-length-decoding-quick-start\ndef rle_decode(mask_rle, shape, color=1):\n    '''\n    mask_rle: run-length as string formated (start length)\n    shape: (height, width, channels) of array to return \n    color: color for the mask\n    Returns numpy array (mask)\n\n    '''\n    s = mask_rle.split()\n    \n    starts = list(map(lambda x: int(x) - 1, s[0::2]))\n    lengths = list(map(int, s[1::2]))\n    ends = [x + y for x, y in zip(starts, lengths)]\n    \n    img = np.zeros((shape[0] * shape[1], shape[2]), dtype=np.float32)\n            \n    for start, end in zip(starts, ends):\n        img[start : end] = color\n    \n    return img.reshape(shape)","f132f481":"def plot_masks(image_id, colors=True):\n    labels = df_train[df_train[\"id\"] == image_id][\"annotation\"].tolist()\n\n    if colors:\n        mask = np.zeros((520, 704, 3))\n        for label in labels:\n            mask += rle_decode(label, shape=(520, 704, 3), color=np.random.rand(3))\n    else:\n        mask = np.zeros((520, 704, 1))\n        for label in labels:\n            mask += rle_decode(label, shape=(520, 704, 1))\n    mask = mask.clip(0, 1)\n\n    image = cv2.imread(f\"..\/input\/sartorius-cell-instance-segmentation\/train\/{image_id}.png\")\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\n    plt.figure(figsize=(16, 32))\n    plt.subplot(3, 1, 1)\n    plt.imshow(image)\n    plt.axis(\"off\")\n    plt.subplot(3, 1, 2)\n    plt.imshow(image)\n    plt.imshow(mask, alpha=0.5)\n    plt.axis(\"off\")\n    plt.subplot(3, 1, 3)\n    plt.imshow(mask)\n    plt.axis(\"off\")\n    \n    plt.show();","c10478be":"plot_masks(\"ffdb3cc02eef\", colors=False)","8ed48830":"plot_masks(\"ffdb3cc02eef\", colors=True)","60d546f1":"plot_masks(\"73df2962444f\", colors=True)","f9d2826a":"plot_masks(\"13325f865bb0\", colors=True)","ce803d66":"plot_masks(\"08f52aa2add3\", colors=True)","cb8cbd5f":"# \ud83e\udda0Sartorius - Cell Instance Segmentation\ud83e\udda0 - Run Length Decoding\n\n\n#### Run Length Decoding (RLD) algorithm for [Sartorius - Cell Instance Segmentation](https:\/\/www.kaggle.com\/c\/sartorius-cell-instance-segmentation) challenge.","d4f9b88f":"![](https:\/\/storage.googleapis.com\/kaggle-competitions\/kaggle\/30201\/logos\/header.png)","e335cd07":"## How does the RLD algorithm work?\n\nAs you can see from the picture below, we are:\n1. \u0421onverting an empty mask into a long vector. \n2. On this vector, we mark the desired coordinates (in the annotation we are given the beginning of the mask fragment and the length of the fragment). \n3. Convert the vector back to a mask.","811e134f":"![](https:\/\/i.imgur.com\/3FEZqQ0.png)"}}