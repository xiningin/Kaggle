{"cell_type":{"4cfe959a":"code","dbccd267":"code","f9ca6d4c":"code","491c5c7e":"code","b1400e33":"code","ac660129":"code","8e052d4a":"code","aa566240":"code","80f2e1fe":"code","89bbe4ca":"code","dd7c345f":"code","0ab686a6":"code","4f0743c3":"code","ebf7468b":"code","2090c646":"code","fb52d376":"code","a09f3c62":"code","9344031c":"code","2233ec76":"code","6c72c121":"code","81053b2a":"code","852a92b9":"code","674749a4":"code","8cc53541":"code","d7863987":"code","1226eba5":"code","33719bb8":"code","24deed89":"code","ef6391c6":"code","54864686":"code","ef7b7e5b":"markdown","b6f226a7":"markdown","ec7fd3b6":"markdown","d8c6bb2c":"markdown","fbb14ce0":"markdown","f261e419":"markdown","66376f0b":"markdown","d6589733":"markdown","71ef0579":"markdown","88824176":"markdown","8955cd49":"markdown","6c36a004":"markdown","1397d25e":"markdown","36fc5aaa":"markdown","30bde1d5":"markdown","924786c5":"markdown","0432efa4":"markdown","9dd5de3a":"markdown","34e20aed":"markdown","23fdc738":"markdown","0a3d7497":"markdown","cd3a3d02":"markdown","939f1f91":"markdown","884c60b2":"markdown","78097dad":"markdown","b7e3ab18":"markdown"},"source":{"4cfe959a":"import pandas as pd\npd.__version__","dbccd267":"import numpy as np\nimport pandas as pd","f9ca6d4c":"data = pd.Series([0.25, 0.5, 0.75, 1.0])\ndata","491c5c7e":"data.values","b1400e33":"data.index","ac660129":"data[1]","8e052d4a":"data[1:3]","aa566240":"data = pd.Series([0.25, 0.5, 0.75, 1.0],\nindex=['a', 'b', 'c', 'd'])\ndata","80f2e1fe":"#And the item access works as expected:\ndata['b']","89bbe4ca":"# We can even use noncontiguous or nonsequential indices:\ndata = pd.Series([0.25, 0.5, 0.75, 1.0],\nindex=[2, 5, 3, 7])\ndata","dd7c345f":"data[5]","0ab686a6":"population_dict = {'California': 38332521,\n'Texas': 26448193,\n'New York': 19651127,\n'Florida': 19552860,\n'Illinois': 12882135}\npopulation = pd.Series(population_dict)\npopulation","4f0743c3":"population['California']","ebf7468b":"population['California':'Illinois']","2090c646":"pd.Series([2, 4, 6])","fb52d376":"#data can be a scalar, which is repeated to fill the specified index:\npd.Series(5, index=[100, 200, 300])","a09f3c62":"#data can be a dictionary, in which index defaults to the sorted dictionary keys:\npd.Series({2:'a', 1:'b', 3:'c'})","9344031c":"#In each case, the index can be explicitly set if a different result is preferred:\npd.Series({2:'a', 1:'b', 3:'c'}, index=[3, 2])","2233ec76":"area_dict = {'California': 423967, 'Texas': 695662, 'New York': 141297,\n'Florida': 170312, 'Illinois': 149995}\narea = pd.Series(area_dict)\narea","6c72c121":"states = pd.DataFrame({'population': population,\n'area': area})\nstates","81053b2a":"#Like the Series object, the DataFrame has an index attribute that gives access to the index labels:\nstates.index","852a92b9":"#Additionally, the DataFrame has a columns attribute, which is an Index object holding the column labels:\nstates.columns","674749a4":"states['area']","8cc53541":"pd.DataFrame(population, columns=['population'])","d7863987":"data = [{'a': i, 'b': 2 * i}\nfor i in range(3)]\npd.DataFrame(data)","1226eba5":"# Even if some keys in the dictionary are missing, Pandas will fill them in with NaN (i.e.,\u201cnot a number\u201d) values:\npd.DataFrame([{'a': 1, 'b': 2}, {'b': 3, 'c': 4}])","33719bb8":"pd.DataFrame({'population': population,'area': area})","24deed89":"pd.DataFrame(np.random.rand(3, 2),\ncolumns=['foo', 'bar'],\nindex=['a', 'b', 'c'])","ef6391c6":"A = np.zeros(3, dtype=[('A', 'i8'), ('B', 'f8')])\nA","54864686":"pd.DataFrame(A)","ef7b7e5b":"## The Pandas Series Object","b6f226a7":"# 2-The Pandas DataFrame Object\n* The next fundamental structure in Pandas is the DataFrame.\n* If a **Series** is an analog of a one-dimensional array with flexible indices, a **DataFrame** is an analog of a two-dimensional array with both flexible row indices and flexible column names.\n\n* Just as you might think of a two-dimensional array as an ordered sequence of aligned one-dimensional columns, you can think of a DataFrame as a sequence of aligned Series objects. \n* Here, by \u201caligned\u201d we mean that they share the same index.\n\n* To demonstrate this, let\u2019s first construct a new Series listing the area of each of the five states discussed in the previous section:","ec7fd3b6":"# **Data Manipulation with Pandas**","d8c6bb2c":"### From a two-dimensional NumPy array.","fbb14ce0":"* A Pandas Series is a one-dimensional array of indexed data. It can be created from a list or array as follows:","f261e419":"* We\u2019ve already seen a few ways of constructing a Pandas Series from scratch; all of them are some version of the following:\n\n **pd.Series(data, index=index)**","66376f0b":"## Series as specialized dictionary\n* In this way, you can think of a Pandas Series a bit like a specialization of a Pythondictionary. A dictionary is a structure that maps arbitrary keys to a set of arbitrary values,and a Series is a structure that maps typed keys to a set of typed values.\n* We can make the Series-as-dictionary analogy even more clear by constructing a Series object directly from a Python dictionary:","d6589733":"## Constructing Series objects","71ef0579":"* By default, a Series will be created where the index is drawn from the sorted keys. From here, typical dictionary-style item access can be performed:","88824176":"## Constructing DataFrame objects\n* A Pandas DataFrame can be constructed in a variety of ways. Here we\u2019ll give several examples.","8955cd49":"### From a dictionary of Series objects.","6c36a004":"* Now that we have this along with the population Series from before, we can use a dictionary to construct a single two-dimensional object containing this information:","1397d25e":"* Like with a NumPy array, data can be accessed by the associated index via the familiar Python square-bracket notation:","36fc5aaa":"## Series as generalized NumPy array\n* The index need not be an integer, but can consist of values of any desired type. For example, if we wish, we can use strings as an index:","30bde1d5":"# 1-Introducing Pandas Objects","924786c5":"## DataFrame as specialized dictionary\n* For example, asking for the 'area' attribute returns the Series object containing the areas we saw earlier:","0432efa4":"### From a NumPy structured array.","9dd5de3a":"* As we see in the preceding output, the Series wraps both a sequence of values and a sequence of indices, which we can access with the values and index attributes. The values are simply a familiar NumPy array:","34e20aed":"* Once Pandas is installed, you can import it and check the version:","23fdc738":"* Where index is an optional argument, and data can be one of many entities.\n* For example, data can be a list or NumPy array, in which case index defaults to an integer sequence:","0a3d7497":"### From a single Series object.","cd3a3d02":"### From a list of dicts.","939f1f91":"* Unlike a dictionary, though, the Series also supports array-style operations such as slicing:","884c60b2":"# 3-The Pandas Index Object","78097dad":"* We will start our code sessions with the standard NumPy and Pandas imports:","b7e3ab18":"![download.jfif](attachment:5b364a3a-f10f-48fa-b4a0-d9d5789d3cdb.jfif)"}}