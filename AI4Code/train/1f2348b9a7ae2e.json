{"cell_type":{"27c2a8a0":"code","418766e3":"code","45b203e3":"code","7110dce6":"code","70a54cea":"code","bb58abb2":"code","ba4093e2":"markdown","398fe3e2":"markdown"},"source":{"27c2a8a0":"import numpy as np\nimport pandas as pd\nimport sqlite3\nimport os\nfrom sklearn import svm\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","418766e3":"class Data:\n    \"\"\"Class to store connection to soccer database.\n    \n    Contains methods for accessing tables from soccer database.\n    \n    \"\"\"\n    def __init__(self):\n        self._database_connection = sqlite3.connect('\/kaggle\/input\/soccer\/database.sqlite')\n        \n        self.df = {}\n        self.df[\"country_ids\"] = self.table(\"Country\")\n        self.df[\"players\"] = self.table(\"Player\")\n        self.df[\"players_attr\"] = self.table(\"Player_Attributes\")\n        self.df[\"teams\"] = self.table(\"Team\")\n        self.df[\"teams_attr\"] = self.table(\"Team_Attributes\")\n        self.df[\"match\"] = self.table(\"Match\")\n        self.df[\"league\"] = self.table(\"League\")\n            \n    def table(self, table_name):\n        query = f\"SELECT * FROM {table_name};\"\n        return pd.read_sql_query(query, self._database_connection)\n    \n    def player(self, player_id):\n        \"\"\"Returns player's stats.\"\"\"\n        basic = self.df[\"players\"].query(f\"player_api_id == '{player_id}'\")\n        print(basic.player_name)\n        print(basic.height)\n        print(basic.weight)\n        return self.df[\"players_attr\"].query(f\"player_api_id == '{player_id}'\")\n    \nsoccer_data = Data()","45b203e3":"soccer_data.player(\"95327\")","7110dce6":"# Select all matches played during the season 2013\/2014\n# Select all the matches played in England (English Premier League) during the season 2013\/2014\n\nclass Matches:\n    \n    def __init__(self, data, season, league):\n        \"\"\"\n        \n        \"\"\"\n        self._df = data.table(\"Match\")\n        self._league_id = data.table(\"League\").query(f\"name == '{league}'\")[\"country_id\"]\n        self._matches = (self._df.query(f\"season == '{season}' and league_id == '{int(self._league_id)}'\"))\n\n    def get_matches(self, team):\n        team_api_id = int(df[\"teams\"].query(f\"team_long_name == '{team}'\")[\"team_api_id\"])\n        matches = self._matches.query(f\"home_team_api_id == '{team_api_id}' or away_team_api_id == '{team_api_id}'\")\n        return matches\n    \n    def players_from_match(self, match):\n        return \"players from match\"\n\n    \nmatches = Matches(data=soccer_data, season=\"2013\/2014\", league=\"England Premier League\")\n\n# Select the matches played by Manchester United during this season 2013\/2014\nmanchester_matches = matches.get_matches(\"Manchester United\")\n\n# Select the matches played by Liverpool during the season 2013\/2014\nliverpool_matches = matches.get_matches(\"Liverpool\")\n\n# Pick up the all players of the Liverpool and Manchester United during the season\nplayers_liverpool = None\nplayers_manchester = None\n\n# Results of matches:\n# For each match we have a home_team_goal and away_team_goals","70a54cea":"def get_players(match):\n    home_players_list = []\n    away_players_list = []\n    home_players = match.loc[:, \"home_player_1\":\"home_player_11\"]\n    away_players = match.loc[:, \"away_player_1\":\"away_player_11\"]\n    for (home, away) in zip(home_players, away_players):\n        home_players_list.append(soccer_data.player(str(int(home))))\n        away_players_list.append(soccer_data.player(str(int(away))))","bb58abb2":"liverpool_matches.apply(get_players, axis=0)","ba4093e2":"Idea:\nCan we predict the outcome of a game based on the players' statistics?\n\nFor each match, we'll have to figure out who was on each team and based on their statistics we can make a prediction.\n\nTODO:\nMake a derived data set.\n\na. Each row will represent a match between team A and team B where we have the following columns:\n\n i. choice of stats for player 1 from team A, player 2 from team A, ..., \n    player 1 from team B, player 2 from team B...\n\nb. Need to decide which stats are useful, make an educated guess to start, we can perform a more systematic search after.\n\nc. We can make a matrix to represent a team. Each row of the matrix corresponds to the statistics of a player on the team. Then a match would be a matrix multiply A * B = C, followed by a aggregation fuction that reduces C to probability. So we have to learn:\n\n i. weights for multiplying A * B, so really we have A * W * B  = C.\n\n ii. and then we need to find the right function f(C).\n\n iii. maybe W can be the player positions?  Then the formula would be A * W1 * B * W2 = C","398fe3e2":"# X\n\nX will be a matrix, representing a match. Each row will comprise the following data:\n\n```\nX_team1 = pd.DataFrame({\n    player_id: player_stats\n    for (player_id, player_stats) in zip(player_id, team_stats)\n})\n\nX_team2 = pd.DataFrame({\n    player_id: player_stats\n    for (player_id, player_stats) in zip(player_id, team_stats)\n})\n\nX = pd.concat([X_team1, X_team2], axis=0, arrange=False)\n```\n\n# y\n\n"}}