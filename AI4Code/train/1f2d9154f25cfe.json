{"cell_type":{"a81fcab2":"code","e19a9cde":"code","51b8d7db":"code","84c0710a":"code","0f20d81b":"code","5feda197":"code","7d52b2f7":"code","2556ea1a":"code","8533cb05":"code","e9f71d4d":"code","9d56d1e8":"code","5a572757":"code","9d544ef7":"code","ee256807":"code","b2976d9f":"code","4a6df17b":"code","a6f4e195":"code","117efd16":"code","963b4429":"code","2ecfb3cf":"code","d3b08d5b":"code","aa1f6cba":"code","f3c51ef9":"code","6c492f60":"code","c88d5b55":"code","822f13c0":"code","f35ad195":"code","ed228843":"code","f2162b28":"code","6c3c7778":"markdown","a22b6412":"markdown","deb8f0ee":"markdown","a17af800":"markdown","5068df7f":"markdown","631767c6":"markdown"},"source":{"a81fcab2":"import os, random\nimport numpy as np\nimport pandas as pd\nfrom tqdm import tqdm\nfrom PIL import Image\nimport pydicom\nimport glob\nimport h5py","e19a9cde":"# flags\nAT_KAGGLE=True\nQUICK_PROCESS=True\nQUICK_PROCESS_SIZE=16 # used if QUICK_PROCESS is True\nPROCESS=\"All\" #[\"All\", \"Images\", \"Yolov3Labels\",\"MetaData\"]","51b8d7db":"# global variables (stage 2 variables do not have a stage prefix)\nTRAIN_DIR=\"..\/input\/rsna-pneumonia-detection-challenge\/stage_2_train_images\"\nSTAGE1_DETAILED_CLASSES_CSV_FILE=\"..\/input\/rsna-stage1-archived-inputs\/stage_1_detailed_class_info.csv\"\nDETAILED_CLASSES_CSV_FILE=\"..\/input\/rsna-pneumonia-detection-challenge\/stage_2_detailed_class_info.csv\"\nDETAILED_CLASSES_CSV_COLUMN_NAMES=['patientId' , 'class']\n# dictionary to map string classes to numerical\nCLASSES_DICT={'Normal': 0, 'Lung Opacity' : 1, 'No Lung Opacity \/ Not Normal' : 2}\n\nSTAGE1_TRAIN_LABELS_CSV_FILE=\"..\/input\/rsna-stage1-archived-inputs\/stage_1_train_labels.csv\"\nTRAIN_LABELS_CSV_FILE=\"..\/input\/rsna-pneumonia-detection-challenge\/stage_2_train_labels.csv\"\n# pedantic nit: we are changing 'Target' to 'label' on the way in\nTRAIN_LABELS_CSV_COLUMN_NAMES=['patientId', 'x1', 'y1', 'bw', 'bh', 'label']\n\n# saved test ids from stage1\nSTAGE1_TEST_IDS_FILE=\"..\/input\/rsna-stage1-archived-inputs\/stage1_test_ids.npy\"\n\nTEST_DIR=\"..\/input\/rsna-pneumonia-detection-challenge\/stage_2_test_images\"\n# list of test images\nTEST_LIST=sorted(os.listdir(TEST_DIR))\n\nSAVED_KEYS_FILE=\"rsna-stage1-and-stage2-keys.npz\"\nSAVED_PATIENTDICT_FILE=\"rsna-patientdict.h5\"\n\nDICOM_IMAGE_SIZE=1024","84c0710a":"# setup output directories\n# directory where we will put processed inputs\nif not AT_KAGGLE:\n    processedtraininputsdirectory=\"..\/input\/rsna-stage2-processed-train-inputs\"\n    processedtestinputsdirectory=\"..\/input\/rsna-stage2-processed-test-inputs\"\n    processedmetadatadirectory=\"..\/input\/rsna-stage2-processed-metadata-inputs\"\nelse: # we are at Kaggle (have to write to the current directory to keep the Commit engine happy)\n    processedtraininputsdirectory=\".\/rsna-stage2-processed-train-inputs\"\n    processedtestinputsdirectory=\".\/rsna-stage2-processed-test-inputs\"\n    processedmetadatadirectory=\".\/rsna-stage2-processed-metadata-inputs\"\n    \n# create directories (one-time)\nos.makedirs(processedtraininputsdirectory, exist_ok=False)\nos.makedirs(processedtestinputsdirectory, exist_ok=False)\nos.makedirs(processedmetadatadirectory, exist_ok=False)\n\nprint (\"Preprocessing training inputs into directory: {}\".format(processedtraininputsdirectory))\nprint (\"Preprocessing test inputs into directory: {}\".format(processedtestinputsdirectory))\nprint (\"Preprocessing meta data into directory: {}\".format(processedmetadatadirectory))","0f20d81b":"# read STAGE1_DETAILED_CLASSES_CSV_FILE into a pandas dataframe\nclassesdf = pd.read_csv(STAGE1_DETAILED_CLASSES_CSV_FILE,\n                        names=DETAILED_CLASSES_CSV_COLUMN_NAMES,\n                        # skip the header line\n                        header=0,\n                        # index the dataframe on patientId\n                        index_col='patientId')\n#print (classesdf.shape)\n#print (classesdf.head(n=10))\n\n# remove duplicates\nclassesdf=classesdf.groupby(['patientId'])['class'].first()\n# make classes numerical based on CLASSES_DICT\nclassesdf=pd.DataFrame(classesdf.replace(to_replace=CLASSES_DICT), columns=['class'])\nprint (\"Stage 1:: {} lines read from {}\".format(len(classesdf), STAGE1_DETAILED_CLASSES_CSV_FILE))","5feda197":"# read list of stage1 test images\nstage1testkeys=sorted(list(np.load(STAGE1_TEST_IDS_FILE)))","7d52b2f7":"# capture stage1 patientids for different classes\nstage1allkeys=classesdf.index.tolist()\nstage1lungopacitykeys=classesdf.index[classesdf['class']==1].tolist()\nstage1normalkeys=classesdf.index[classesdf['class']==0].tolist()\nstage1otherabnormalkeys=classesdf.index[classesdf['class']==2].tolist()\nprint (\"################STAGE 1 SUMMARY################\")\nprint (\"Total Training Samples: {}\".format(len(stage1allkeys)))\nprint (\">>Lung Opacity Samples: {}\".format(len(stage1lungopacitykeys)))\nprint (\">>Normal Samples: {}\".format(len(stage1normalkeys)))\nprint (\">>Not Normal \/ No Lung Opacity Samples: {}\".format(len(stage1otherabnormalkeys)))\nprint (\"Test Samples: {}\".format(len(stage1testkeys)))\nprint (\"##############################################\")","2556ea1a":"# read stage2 DETAILED_CLASSES_CSV_FILE into a pandas dataframe\nclassesdf = pd.read_csv(DETAILED_CLASSES_CSV_FILE,\n                        names=DETAILED_CLASSES_CSV_COLUMN_NAMES,\n                        # skip the header line\n                        header=0,\n                        # index the dataframe on patientId\n                        index_col='patientId')\n#print (classesdf.shape)\n#print (classesdf.head(n=10))\n\n# remove duplicates\nclassesdf=classesdf.groupby(['patientId'])['class'].first()\n# make classes numerical based on CLASSES_DICT\nclassesdf=pd.DataFrame(classesdf.replace(to_replace=CLASSES_DICT), columns=['class'])\nprint (\"Stage 2:: {} lines read from {}\".format(len(classesdf), DETAILED_CLASSES_CSV_FILE))","8533cb05":"# capture stage2 test keys\ntestkeys=[]\nfor filename in TEST_LIST:\n    key=filename.split(\".\")[0]\n    testkeys.append(key)","e9f71d4d":"# capture stage2 patientids for different classes\nallkeys=classesdf.index.tolist()\nlungopacitykeys=classesdf.index[classesdf['class']==1].tolist()\nnormalkeys=classesdf.index[classesdf['class']==0].tolist()\notherabnormalkeys=classesdf.index[classesdf['class']==2].tolist()\nprint (\"################STAGE 2 SUMMARY################\")\nprint (\"Total Training Samples: {}\".format(len(allkeys)))\nprint (\">>Lung Opacity Samples: {}\".format(len(lungopacitykeys)))\nprint (\">>Normal Samples: {}\".format(len(normalkeys)))\nprint (\">>Not Normal \/ No Lung Opacity Samples: {}\".format(len(otherabnormalkeys)))\nprint (\"Test Samples: {}\".format(len(testkeys)))\nprint (\"##############################################\")","9d56d1e8":"print (\"{} test samples from Stage 1 were distributed into Stage 2 as:\".format(len(stage1testkeys)))\nprint (\">>{} additional Lung Opacity Samples\".format(len(lungopacitykeys)-len(stage1lungopacitykeys)))\nprint (\">>{} additional Normal Samples\".format(len(normalkeys)-len(stage1normalkeys)))\nprint (\">>{} additional Not Normal \/ No Lung Opacity Samples\".format(len(otherabnormalkeys)-len(stage1otherabnormalkeys)))","5a572757":"# check stage2 vs stage1 keys\nassert sorted(allkeys)==sorted(stage1normalkeys+stage1lungopacitykeys+stage1otherabnormalkeys+stage1testkeys), \"Keys Mismatch\"","9d544ef7":"# read TRAIN_LABELS_CSV_FILE into a pandas dataframe\nlabelsbboxdf = pd.read_csv(TRAIN_LABELS_CSV_FILE,\n                           names=TRAIN_LABELS_CSV_COLUMN_NAMES,\n                           # skip the header line\n                           header=0,\n                           # index the dataframe on patientId\n                           index_col='patientId')\n\nlabelsbboxdf.head(10)","ee256807":"# compute and store bounding box centers\nbx=labelsbboxdf['x1']+labelsbboxdf['bw']\/2\nby=labelsbboxdf['y1']+labelsbboxdf['bh']\/2\nlabelsbboxdf=labelsbboxdf.assign(bx=bx, by=by)\nlabelsbboxdf.head(10)","b2976d9f":"# drop labels and rearrange dataframe so we have bounding boxes in rsna format,\n# dropping all rows other than lungopacity ones\nrsnabboxesdf=labelsbboxdf[['x1', 'y1', 'bw', 'bh']].dropna()\nrsnabboxesdf.head(10)","4a6df17b":"# drop labels and top left coordinates and rearrange dataframe in yolov3 format,\n# dropping all rows other than lungopacity ones\nyolov3bboxesdf=labelsbboxdf[['bx', 'by', 'bw', 'bh']].dropna()\nyolov3bboxesdf.head(10)","a6f4e195":"# yolov3 requires bounding box dimensions to be between 0 and 1\n# normalize to DICOM_IMAGE_SIZE\nyolov3bboxesdf=yolov3bboxesdf\/DICOM_IMAGE_SIZE\nyolov3bboxesdf.head(10)","117efd16":"# save a copy of keys we are going to munge up when running quick checks\nif QUICK_PROCESS==True:\n    savedallkeys=allkeys\n    savedtestkeys=testkeys\n    savedlungopacitykeys=lungopacitykeys","963b4429":"# setup a quick test to make sure everything is working before heading off to GCP\nif QUICK_PROCESS == True:\n    allkeys=random.sample(allkeys, QUICK_PROCESS_SIZE)\n    testkeys=random.sample(testkeys, QUICK_PROCESS_SIZE)\n    lungopacitykeys=random.sample(lungopacitykeys, QUICK_PROCESS_SIZE)\n    print (\"Quick check by preprocessing {} samples\".format(QUICK_PROCESS_SIZE))","2ecfb3cf":"def loadDicomImage (directory, patientid, mode=\"metadata\"):\n    imagergb=np.zeros([DICOM_IMAGE_SIZE, DICOM_IMAGE_SIZE, 3])\n    attributes=[]\n    filename=\"{}.dcm\".format(patientid)\n    \n    if mode==\"metadata\":\n        # load patient meta-data only from file\n        patientdata = pydicom.dcmread(os.path.join(directory, filename), stop_before_pixels=True)\n    elif mode==\"image\":\n        # load patient meta-data and image from file\n        patientdata = pydicom.dcmread(os.path.join(directory, filename))\n        imagegray=patientdata.pixel_array\n        # convert grayscale to rgb\n        imagegray=imagegray\/imagegray.max()\n        imagegray = (255*imagegray).clip(0, 255).astype(np.uint8)\n        imagergb=np.stack([imagegray]*3, -1)\n    # make sure there isn't a mismatch\n    assert patientid==patientdata.PatientID, \"PatientId Mismatch\"\n    # grab attributes\n    attributes.append(patientdata.PatientSex)\n    attributes.append(patientdata.PatientAge)\n    attributes.append(patientdata.ViewPosition)\n    \n    #print (imagergb)\n    return attributes, imagergb","d3b08d5b":"# save jpg images for train samples in original size\nif PROCESS == \"All\"  or PROCESS==\"Images\":\n    for patientid in tqdm(allkeys):\n        imagefilename=\"{}.jpg\".format(patientid)\n        imagepathname=os.path.join(processedtraininputsdirectory, imagefilename)\n        #print (imagepathname)\n        _, imagergb = loadDicomImage (TRAIN_DIR, patientid, mode=\"image\")\n        image=Image.fromarray(imagergb)\n        assert image.size==(DICOM_IMAGE_SIZE, DICOM_IMAGE_SIZE), \"Input Image Size Mismatch\"\n        image.save(imagepathname)\n        \n    # make sure all images made it through correctly\n    processedtrainkeys=[]\n    for filename in glob.glob(processedtraininputsdirectory+'\/*.jpg'):\n        key=os.path.split(filename)[1].split(\".\")[0]\n        processedtrainkeys.append(key)\n    assert sorted(processedtrainkeys)==sorted(allkeys), \"Train Samples Missed\"\n    print (\"Preprocessed {} train images\".format(len(processedtrainkeys)))","aa1f6cba":"# save jpg images for test inputs in original size\nif PROCESS == \"All\"  or PROCESS==\"Images\":\n    for patientid in tqdm(testkeys):\n        imagefilename=\"{}.jpg\".format(patientid)\n        imagepathname=os.path.join(processedtestinputsdirectory, imagefilename)\n        #print (imagepathname)\n        _, imagergb = loadDicomImage (TEST_DIR, patientid, mode=\"image\")\n        image=Image.fromarray(imagergb)\n        assert image.size==(DICOM_IMAGE_SIZE, DICOM_IMAGE_SIZE), \"Input Image Size Mismatch\"\n        image.save(imagepathname)\n        \n    # make sure all images made it through correctly\n    processedtestkeys=[]\n    for filename in glob.glob(processedtestinputsdirectory+'\/*.jpg'):\n        key=os.path.split(filename)[1].split(\".\")[0]\n        processedtestkeys.append(key)\n    assert sorted(processedtestkeys)==sorted(testkeys), \"Test Samples Missed\"\n    print (\"Preprocessed {} test images\".format(len(processedtestkeys)))","f3c51ef9":"# get yolov3 bounding boxes by patientid\ndef getyolov3BoundingBoxes (bboxesdf, key):\n    bboxarray=bboxesdf.loc[key][['bx', 'by', 'bw', 'bh']].values\n    # hack to detect and fix single bounding box case which\n    # comes in with shape (4,)\n    #print (bboxarray.shape)\n    bboxarray=np.expand_dims(bboxarray, -1)\n    if bboxarray.shape[1]==1:\n        bboxarray=bboxarray.reshape(1, bboxarray.shape[0])\n    else:\n        bboxarray=np.squeeze(bboxarray, axis=-1)\n    #print (bboxarray.shape)\n    return bboxarray","6c492f60":"# write bounding box information for lungopacity cases in yolov3 format\nif PROCESS == \"All\"  or PROCESS==\"Yolov3labels\":\n    for patientid in tqdm(lungopacitykeys):\n        bboxarray=getyolov3BoundingBoxes(yolov3bboxesdf, patientid)\n        assert len(bboxarray) > 0, \"Missing Bounding Boxes for {}\".format(patientid)\n        bboxfilename=\"{}.txt\".format(patientid)\n        bboxpathname=os.path.join(processedtraininputsdirectory, bboxfilename)\n        #print (bboxpathname)\n        file=open(bboxpathname,'w')\n        for i in range(len(bboxarray)):\n            bx, by, bw, bh = bboxarray[i]\n            #print(bx, by, bw, bh)\n            boxrecord=\"0 {} {} {} {}\\n\".format(bx, by, bw, bh)\n            file.write(boxrecord)\n        file.close()\n        \n    # make sure all boxes made it through correctly\n    processedlungopacitykeys=[]\n    for filename in glob.glob(processedtraininputsdirectory+'\/*.txt'):\n        key=os.path.split(filename)[1].split(\".\")[0]\n        processedlungopacitykeys.append(key)\n    assert sorted(processedlungopacitykeys)==sorted(lungopacitykeys), \"Lung Opacity Samples Missed\"\n    print (\"Saved bounding boxes for {} Lung Opacity cases\".format(len(processedlungopacitykeys)))","c88d5b55":"!ls -al \".\/rsna-stage2-processed-train-inputs\"","822f13c0":"!ls -al \".\/rsna-stage2-processed-test-inputs\"","f35ad195":"# we are going to run the RSNA Metadata for all samples so we don't clutter up the code\n# reset the keys we munged up for quick check\nif QUICK_PROCESS==True:\n    allkeys=savedallkeys\n    testkeys=savedtestkeys\n    lungopacitykeys=savedlungopacitykeys","ed228843":"# get rsna bounding boxes by patientid\ndef getrsnaBoundingBoxes (bboxesdf, key):\n    bboxarray=bboxesdf.loc[key][['x1', 'y1', 'bw', 'bh']].values\n    # hack to detect and fix single bounding box case which\n    # comes in with shape (4,)\n    #print (bboxarray.shape)\n    bboxarray=np.expand_dims(bboxarray, -1)\n    if bboxarray.shape[1]==1:\n        bboxarray=bboxarray.reshape(1, bboxarray.shape[0])\n    else:\n        bboxarray=np.squeeze(bboxarray, axis=-1)\n    #print (bboxarray.shape)\n    return bboxarray","f2162b28":"# save RSNA metadata (will take some time, you can kill the kernel if you have seen enough)\nif PROCESS == \"All\"  or PROCESS==\"MetaData\":\n    rsnapatientdict=pd.DataFrame()\n    oneboundingboxkeys=[]\n    twoboundingboxkeys=[]\n    threeboundingboxkeys=[]\n    fourboundingboxkeys=[]\n    \n    for patientid in tqdm(allkeys):\n        rsnaattributes, _ = loadDicomImage (TRAIN_DIR, patientid, mode=\"metadata\")\n        bboxlist=[]\n        if patientid in lungopacitykeys:\n            bboxarray=getrsnaBoundingBoxes(rsnabboxesdf, patientid)\n            assert len(bboxarray) > 0, \"Missing Bounding Boxes for {}\".format(patientid)\n            bboxlist=list(bboxarray)\n            \n            if len(bboxarray) == 1:\n                oneboundingboxkeys.append(patientid)\n            elif len(bboxarray) == 2:\n                twoboundingboxkeys.append(patientid)\n            elif len(bboxarray) == 3:\n                threeboundingboxkeys.append(patientid)\n            elif len(bboxarray) == 4:\n                fourboundingboxkeys.append(patientid)\n        \n        patientrecord=pd.DataFrame({\n            'patientId': [patientid],\n            'patientSex': [rsnaattributes[0]],\n            'patientAge': [rsnaattributes[1]],\n            'patientViewPosition': [rsnaattributes[2]],\n            'BoundingBoxes': [bboxlist]})\n        rsnapatientdict=rsnapatientdict.append(patientrecord)\n        \n    print (\"################STAGE 2 BOUNDING BOX SUMMARY################\")\n    print (\"Total Lung Opacity Samples: {}\".format(len(lungopacitykeys)))\n    print (\">>Samples with 1 Bounding Box: {}\".format(len(oneboundingboxkeys)))\n    print (\">>Samples with 2 Bounding Boxes: {}\".format(len(twoboundingboxkeys)))\n    print (\">>Samples with 3 Bounding Boxes: {}\".format(len(threeboundingboxkeys)))\n    print (\">>Samples with 4 Bounding Boxes: {}\".format(len(fourboundingboxkeys)))\n    print (\"#############################################################\")\n        \n    # save all stage1 and stage2 keys\n    np.savez(os.path.join(processedmetadatadirectory, SAVED_KEYS_FILE),\n             np.array(allkeys),\n             np.array(normalkeys),\n             np.array(lungopacitykeys),\n             np.array(otherabnormalkeys),\n             np.array(testkeys),\n             np.array(oneboundingboxkeys),\n             np.array(twoboundingboxkeys),\n             np.array(threeboundingboxkeys),\n             np.array(fourboundingboxkeys),\n             np.array(stage1allkeys),\n             np.array(stage1normalkeys),\n             np.array(stage1lungopacitykeys),\n             np.array(stage1otherabnormalkeys),\n             np.array(stage1testkeys))\n    \n    # save RSNA patient dictionary (work in progress, hdf5 is creaky about strings, may not be working )\n    rsnapatientdict.to_hdf(os.path.join(processedmetadatadirectory, SAVED_PATIENTDICT_FILE),\n                           key='rsnapatientdict',\n                           mode='w')\n    print (\">>>Saved RSNA patient dictionary to to {}\".format(os.path.join(processedmetadatadirectory, SAVED_PATIENTDICT_FILE)))\n        \n    # make sure we can get everything back\n    npzfile=np.load(os.path.join(processedmetadatadirectory, SAVED_KEYS_FILE))\n\n    assert allkeys==sorted(list(npzfile['arr_0'])), \"All Keys Mismatch\"\n    assert normalkeys==sorted(list(npzfile['arr_1'])), \"Normal Keys Mismatch\"\n    assert lungopacitykeys==sorted(list(npzfile['arr_2'])), \"Lung Opacity Keys Mismatch\"\n    assert otherabnormalkeys==sorted(list(npzfile['arr_3'])), \"Not Normal \/ No Lung Opacity Keys Mismatch\"\n    assert testkeys==sorted(list(npzfile['arr_4'])), \"Test Keys Mismatch\"\n\n    assert oneboundingboxkeys==sorted(list(npzfile['arr_5'])), \"One Bounding Box Keys Mismatch\"\n    assert twoboundingboxkeys==sorted(list(npzfile['arr_6'])), \"Two Bounding Box Keys Mismatch\"\n    assert threeboundingboxkeys==sorted(list(npzfile['arr_7'])), \"Three Bounding Box Keys Mismatch\"\n    assert fourboundingboxkeys==sorted(list(npzfile['arr_8'])), \"Four Bounding Box Keys Mismatch\"\n\n    assert stage1allkeys==sorted(list(npzfile['arr_9'])), \"Stage1 All Keys Mismatch\"\n    assert stage1normalkeys==sorted(list(npzfile['arr_10'])), \"Stage1 Normal Keys Mismatch\"\n    assert stage1lungopacitykeys==sorted(list(npzfile['arr_11'])), \"Stage1 Lung Opacity Keys Mismatch\"\n    assert stage1otherabnormalkeys==sorted(list(npzfile['arr_12'])), \"Stage1 Not Normal \/ No Lung Opacity Keys Mismatch\"\n    assert stage1testkeys==sorted(list(npzfile['arr_13'])), \"Stage1 Test Keys Mismatch\"\n        \n    ","6c3c7778":"## V.  Preprocess RSNA Metadata","a22b6412":"## IV.  Preprocess YOLOV3 Labels","deb8f0ee":"## **II. Setup**","a17af800":"## VI.  Next Steps\nDownload the [RSNA Stage2 Processed Train Inputs](https:\/\/www.kaggle.com\/kanwalinder\/rsna-stage2-processed-train-inputs), [RSNA Stage2 Processed Test Inputs](https:\/\/www.kaggle.com\/kanwalinder\/rsna-stage2-processed-test-inputs), and [RSNA Stage 2 Processed Metadata Inputs](https:\/\/www.kaggle.com\/kanwalinder\/rsna-stage2-processed-metadata-inputs) datasets and proceed to Step 2 (coming soon), reviewing [RSNA Stage 2 Anchor Box Analysis](https:\/\/www.kaggle.com\/kanwalinder\/rsna-stage-2-anchor-box-analysis) along the way.\n","5068df7f":"## III.  Preprocess Images","631767c6":"##  **I.  Introduction:**\n\nThis kernel preprocesses RSNA Stage 2 inputs as follows:\n\n1.  DICOM images are converted into *.jpg files of shape (1024, 1024, 3)\n2.  Bounding Boxes for individual 'Lung Opacity' cases are saved in individual *.txt files in YOLOV3 format next to the *.jpg files.\n3.  RSNA metadata is saved.  Various collections of keys I could think of as being useful are saved in a *.npz archive.  A RSNA patient dictionary keyed by patientid and containing key DICOM attributes and bounding boxes in lists are saved in a *.h5 file.\n\nI pulled this kernel together and tested it on Kaggle (flags below allow for that), converted the notebook into a *.py file, and did the actual conversion on a CPU on the Google Cloud Platform (GCP).  I used the Kaggle API to download the competition files to GCP and upload the output datasets (releasing in parallel) back to Kaggle.\n\nComments welcome!"}}