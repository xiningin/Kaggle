{"cell_type":{"73191338":"code","7b03d38c":"code","2fe3fa7c":"code","825b4133":"code","529e0558":"code","2c0864d9":"code","2f8dadbf":"code","963ac121":"code","0ea8c61f":"code","af7f44ff":"code","7ede2333":"code","6888e80c":"code","ba61e5c2":"code","5523b9b7":"code","6f6edfea":"code","166e3ce8":"code","a40d1528":"code","756eda45":"code","636b8178":"code","9db625d0":"code","8d719869":"code","e90db23a":"markdown","6547b361":"markdown","120a4204":"markdown","56950cad":"markdown","f15704c7":"markdown","5843223c":"markdown","00832fbe":"markdown","37626143":"markdown","8218b5f9":"markdown","7a07fc70":"markdown","cee2e1dc":"markdown","0476972d":"markdown","180edef0":"markdown"},"source":{"73191338":"! pip install biosppy torchmetrics japanize-matplotlib","7b03d38c":"import sys\nimport os\nimport gc\nimport random\nimport copy\nimport time\nimport functools\n\nimport pandas as pd\nimport numpy as np\nimport biosppy\nimport scipy\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport japanize_matplotlib\nfrom sklearn.model_selection import StratifiedKFold\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\n# from torch_optimizer import Ranger\nfrom torch.utils.data import DataLoader, Dataset\nfrom torchvision import transforms\nimport pytorch_lightning as pl\nfrom pytorch_lightning.callbacks import EarlyStopping, ModelCheckpoint\nimport torchmetrics\nfrom warnings import filterwarnings\n\nfilterwarnings(\"ignore\")\npd.set_option('display.max_columns', 100)\n\n# torch.backends.cudnn.benchmark = True\nprint(torch.cuda.is_available())\nprint(torch.backends.cudnn.is_available())","2fe3fa7c":"def fix_seed(seed):\n    # random\n    random.seed(seed)\n    # Numpy\n    np.random.seed(seed)\n    # Pytorch\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True\n    pl.seed_everything(seed)\n\nfix_seed(42)","825b4133":"df_train = pd.read_csv(\"..\/input\/ai-medical-contest-2021\/train.csv\")\ndf_test = pd.read_csv(\"..\/input\/ai-medical-contest-2021\/test.csv\")\ndf_sub = pd.read_csv(\"..\/input\/ai-medical-contest-2021\/sample_submission.csv\")\n\ndf_train['ecg_path'] = df_train['Id'].apply(lambda x: os.path.abspath(f\"..\/input\/ai-medical-contest-2021\/ecg\/{x}.npy\"))\ndf_test['ecg_path'] = df_test['Id'].apply(lambda x: os.path.abspath(f\"..\/input\/ai-medical-contest-2021\/ecg\/{x}.npy\"))\n\nprint(df_train.shape, df_test.shape, df_sub.shape)\ndisplay(df_train.head(), df_test.head(), df_sub.head())","529e0558":"def plot_single_lead(ax, single_lead, lead_name, min, max, fs=100, t=8):\n    ax.plot(single_lead)\n    ax.set_ylabel(lead_name, rotation=0, fontsize=16)\n    ax.set_xticks(np.arange(0, fs * t + 1, step=fs))\n    ax.minorticks_on()\n    ax.set_ylim(min, max)\n    ax.set_xlim(0, fs * t)\n    ax.grid(which=\"major\", color=\"black\", alpha=0.5)\n    ax.grid(which=\"minor\", color=\"gray\", linestyle=\":\")\n\n\ndef plot_twelve_lead(\n        twelve_lead,\n        lead_list=['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'],\n        fs=100,\n        t=8\n    ):\n    fig, ax = plt.subplots(6, 2, figsize=(20, 16))\n    for i in range(len(lead_list)):\n        ax_ = ax[i % 6, i \/\/ 6]\n        single_lead = twelve_lead[:, i]\n        lead_name = lead_list[i]\n        plot_single_lead(ax_, single_lead, lead_name, twelve_lead.min(), twelve_lead.max())","2c0864d9":"index = 200\ntwelve_lead = np.load(df_train['ecg_path'][index])\ntarget = df_train['target'][index]\nlabel_type = df_train['label_type'][index]\nlead_list = ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6']\n\nprint('target (myocardial infarction):', target)\nprint('label_type:', label_type)\nplot_twelve_lead(twelve_lead, lead_list=lead_list)","2f8dadbf":"single_lead_v2 = twelve_lead[:, lead_list.index('V2')]\n(ts, filtered, rpeaks, templates_ts, templates, heart_rate_ts, heart_rate) = \\\n    biosppy.signals.ecg.ecg(single_lead_v2, sampling_rate=100., show=True)","963ac121":"fig, ax = plt.subplots(1, 2, figsize=(20, 3))\nmin_mv = min(single_lead_v2.min(), filtered.min())\nmax_mv = max(single_lead_v2.max(), filtered.max())\nplot_single_lead(ax[0], single_lead_v2, 'V2', min_mv, max_mv)\nplot_single_lead(ax[1], filtered, 'filtered V2', min_mv, max_mv)","0ea8c61f":"# nperseg\u306e\u9055\u3044\u306b\u3088\u308b\u51fa\u529b\u306e\u9055\u3044\u3092\u78ba\u8a8d\nnperseg_list = [40, 80, 120, 160, 200]\nfig, ax = plt.subplots(1, len(nperseg_list), figsize=(4 * len(nperseg_list), 4))\nfor i, nperseg in enumerate(nperseg_list):\n    f,t,Sxx = scipy.signal.spectrogram(filtered, fs=100, nperseg=nperseg)\n    print(Sxx.shape)\n    ax[i].pcolormesh(t,f,Sxx)\n    ax[i].set_xlabel(u\"\u6642\u9593 [sec]\")\n    ax[i].set_ylabel(u\"\u5468\u6ce2\u6570 [Hz]\")","af7f44ff":"# \u540c\u3058nperseg\u3092\u7528\u3044\u3066\uff0c\u6ce2\u5f62\u3092\u6642\u9593\u65b9\u5411\u306b\u305a\u3089\u305f\u3068\u304d\u306e\u51fa\u529b\u306e\u9055\u3044\u3092\u78ba\u8a8d\nshift_list = [10, 20, 40, 60, 80]\nfig, ax = plt.subplots(1, len(shift_list), figsize=(4 * len(shift_list), 4))\nfor i, shift in enumerate(shift_list):\n    f,t,Sxx = scipy.signal.spectrogram(np.roll(filtered, shift), fs=100, nperseg=80)\n    print(Sxx.shape)\n    ax[i].pcolormesh(t,f,Sxx)\n    ax[i].set_xlabel(u\"\u6642\u9593 [sec]\")\n    ax[i].set_ylabel(u\"\u5468\u6ce2\u6570 [Hz]\")","7ede2333":"# \u30e9\u30f3\u30c0\u30e0\u306b\u6ce2\u5f62\u3092\u6642\u9593\u65b9\u5411\u306b\u305a\u3089\u3057\u3066\u307f\u308b\nshift_arr = np.random.randint(0, 80, (5, 1))\nfig, ax = plt.subplots(1, len(shift_arr), figsize=(4 * len(shift_arr), 4))\nfor i, shift in enumerate(shift_arr):\n    f,t,Sxx = scipy.signal.spectrogram(np.roll(filtered, shift[0]), fs=100, nperseg=80)\n    print(Sxx.shape)\n    ax[i].pcolormesh(t,f,Sxx)\n    ax[i].set_xlabel(u\"\u6642\u9593 [sec]\")\n    ax[i].set_ylabel(u\"\u5468\u6ce2\u6570 [Hz]\")","6888e80c":"def create_recurrence_plot(s, step=4):\n    s = s[::step]\n    d = scipy.spatial.distance.pdist(s[:,None])\n    recurrence_plot = scipy.spatial.distance.squareform(d)\n    return recurrence_plot","ba61e5c2":"recurrence_plot = create_recurrence_plot(single_lead_v2)\nsns.heatmap(recurrence_plot)","5523b9b7":"class ECGFilter():\n    def __init__(self, fs=100):\n        self.fs = fs\n\n    def __call__(self, twelve_lead):\n        \"\"\"\n        Args:\n            twelve_lead (np.ndarray): 12\u8a98\u5c0e\u5fc3\u96fb\u56f3\u3002x.shape[0]\u304c\u6642\u9593\uff0cx.shape[1]\u304c\u5404\u8a98\u5c0e\u3002\n        Returns:\n            twelve_lead (np.ndarray): \u5468\u6ce2\u6570\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u6e08\u307f\u306e12\u8a98\u5c0e\u5fc3\u96fb\u56f3\u3002\n        \"\"\"\n        for i in range(twelve_lead.shape[1]):\n            try:\n                _, filtered, _, _, _, _, _ = biosppy.signals.ecg.ecg(\n                    twelve_lead[:, i],\n                    sampling_rate=self.fs,\n                    show=False\n                )\n                twelve_lead[:, i] = filtered\n            except:\n                pass\n        return twelve_lead\n\n\nclass ECGSpectrogram():\n\n    def __init__(self, shift_max=0, fs=100, nperseg=80):\n        self.shift_max = shift_max\n        self.fs = fs\n        self.nperseg = nperseg\n\n    def __call__(self, twelve_lead):\n        \"\"\"\n        Args:\n            twelve_lead (np.ndarray): 12\u8a98\u5c0e\u5fc3\u96fb\u56f3\u3002x.shape[0]\u304c\u6642\u9593\uff0cx.shape[1]\u304c\u5404\u8a98\u5c0e\u3002\n        Returns:\n            spectrogram (np.ndarray): x.shape[0]\u304c\u5468\u6ce2\u6570\uff0cx.shape[1]\u304c\u6642\u9593\uff0cshape[2]\u304c\u8a98\u5c0e\u3002\n                                      \u305d\u308c\u305e\u308c\u753b\u50cf\u306eH, W, C\u306b\u5bfe\u5fdc\u3002\n        \"\"\"\n        single_spectrogram_list = []\n        for i in range(twelve_lead.shape[1]):\n            shift = np.random.randint(0, self.shift_max+1)\n            single_lead = np.roll(twelve_lead[:, i], shift)\n            f, t, single_spectrogram = \\\n                scipy.signal.spectrogram(\n                    single_lead, fs=self.fs, nperseg=self.nperseg\n                )\n            single_spectrogram_list.append(single_spectrogram)\n        return np.stack(single_spectrogram_list, axis=-1)","6f6edfea":"class DatasetForPrediction(Dataset):\n    def __init__(self, df, target_col_list, path_col='path', mode='train', transform=None):\n        self.df = df\n        self.target_col_list = target_col_list\n        if mode == 'train' or mode == 'val':\n            self.y = df[target_col_list].values\n            self.df_drop_target = df.drop(columns=target_col_list)\n        elif mode == 'test':\n            self.df_drop_target = df\n        else:\n            raise NotImplementedError\n        self.path_col = path_col\n        self.mode = mode\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.df)\n\n    def __getitem__(self, idx):\n        path = self.df[self.path_col].iloc[idx]\n        x = np.load(path)\n        if self.transform is not None:\n            x = self.transform(x)\n\n        if self.mode == 'train' or self.mode == 'val':\n            return torch.tensor(x).float(), torch.tensor(self.y[idx]).float()\n        elif self.mode == 'test':\n            return torch.tensor(x).float()\n        else:\n            raise NotImplementedError","166e3ce8":"class Simple2DCNNClassifier(nn.Module):\n    def __init__(self, num_classes=1):\n        super().__init__()\n        self.feature_extractor = nn.Sequential(\n            nn.Conv2d(12, 32, 3), nn.BatchNorm2d(32), nn.ReLU(), nn.Dropout2d(p=0.3),\n            nn.Conv2d(32, 64, 3), nn.BatchNorm2d(64), nn.ReLU(), nn.Dropout2d(p=0.3),\n            nn.Conv2d(64, 128, 3), nn.BatchNorm2d(128), nn.ReLU(), nn.Dropout2d(p=0.3),\n            nn.Conv2d(128, 256, 3), nn.BatchNorm2d(256), nn.ReLU()\n        )\n        self.pooling = nn.AdaptiveAvgPool2d((1, 1))\n        self.fc = nn.Linear(in_features=256, out_features=num_classes)\n\n    def forward(self, x):\n        return self.fc(self.pooling(self.feature_extractor(x)).view(-1, 256))\n\n\nclass SimpleLightningClassifier(pl.LightningModule):\n    def __init__(self, num_classes=1):\n        super().__init__()\n        self.dnn = Simple2DCNNClassifier(num_classes)\n        self.train_auroc = torchmetrics.AUROC()\n        self.val_auroc = torchmetrics.AUROC()\n\n    def configure_optimizers(self):\n        optimizer = optim.Adam(self.parameters(), lr=0.005)\n        scheduler = optim.lr_scheduler.CosineAnnealingLR(\n                optimizer,\n                T_max=self.trainer.max_epochs,\n                eta_min=1e-4\n            )\n        return [optimizer], [scheduler]\n\n    def forward(self, x):\n        return self.dnn(x)\n\n    def training_step(self, batch, batch_idx):\n        x, y = batch\n        logits = self.dnn(x)\n        loss = F.binary_cross_entropy_with_logits(logits, y)\n        train_auroc = self.train_auroc(logits.sigmoid(), y.long())\n        self.log('loss', loss, prog_bar=True)\n        return loss\n\n    def training_epoch_end(self, outputs):\n        self.log('train_auroc', self.train_auroc.compute(), prog_bar=True)\n\n    def validation_step(self, batch, batch_idx):\n        x, y = batch\n        logits = self.dnn(x)\n        val_auroc = self.val_auroc(logits.sigmoid(), y.long())\n\n    def validation_epoch_end(self, outputs):\n        self.log('val_auroc', self.val_auroc.compute(), prog_bar=True)","a40d1528":"SEED = 42\n\nTARGET_COL_LIST = ['target']\nNUM_FOLDS = 5\nTRAIN_FOLDS = 1  # Train only 1 fold.\n\nTRAIN_BATCH_SIZE = 256\nVAL_BATCH_SIZE = 256\nNUM_WORKERS = 2\n\nNUM_GPUS = 1\nMAX_EPOCHS = 128","756eda45":"df_train = pd.read_csv(\"..\/input\/ai-medical-contest-2021\/train.csv\")\ndf_test = pd.read_csv(\"..\/input\/ai-medical-contest-2021\/test.csv\")\ndf_sub = pd.read_csv(\"..\/input\/ai-medical-contest-2021\/sample_submission.csv\")\n\ndf_train['path'] = df_train['Id'].apply(\n    lambda x: os.path.abspath(f\"..\/input\/public-spectrogram-nperseg80\/spectrogram\/{x}.npy\")\n)\ndf_test['path'] = df_test['Id'].apply(\n    lambda x: os.path.abspath(f\"..\/input\/public-spectrogram-nperseg80\/spectrogram\/{x}.npy\")\n)\n\ntransform = transforms.Compose([\n    transforms.ToTensor(),\n])\n\nskf_split = StratifiedKFold(\n    n_splits=NUM_FOLDS,\n    shuffle=True,\n    random_state=SEED\n).split(np.arange(len(df_train)), y=df_train['target'])\n\nbest_model_path_list = []\n\nfor fold_idx, (train_idx, val_idx) in enumerate(list(skf_split)[:TRAIN_FOLDS]):\n    df_train_fold = df_train.iloc[train_idx]\n    df_val_fold = df_train.iloc[val_idx]\n\n    train_dataset = DatasetForPrediction(\n        df_train_fold,\n        TARGET_COL_LIST,\n        mode='train',\n        transform=transform\n    )\n    val_dataset = DatasetForPrediction(\n        df_val_fold,\n        TARGET_COL_LIST,\n        mode='val',\n        transform=transform\n    )\n    train_dataloader = DataLoader(\n        train_dataset,\n        batch_size=TRAIN_BATCH_SIZE,\n        shuffle=True,\n        num_workers=NUM_WORKERS,\n        pin_memory=True\n    )\n    val_dataloader = DataLoader(\n        val_dataset,\n        batch_size=VAL_BATCH_SIZE,\n        shuffle=False,\n        num_workers=NUM_WORKERS,\n        pin_memory=True\n    )\n\n    model = SimpleLightningClassifier()\n\n    model_checkpoint = ModelCheckpoint(\n            filename=f'fold={fold_idx}_best_auroc',\n            save_top_k=1,\n            monitor='val_auroc',\n            mode='max'\n        )\n    trainer = pl.Trainer(\n        max_epochs=MAX_EPOCHS,\n        gpus=NUM_GPUS,\n        precision=16,\n        default_root_dir=f'..\/output\/fold_{fold_idx}',\n        callbacks=[model_checkpoint]\n    )\n    trainer.fit(model, train_dataloader, val_dataloader)\n    best_model_path_list.append(model_checkpoint.best_model_path)","636b8178":"test_dataset = DatasetForPrediction(\n    df_test,\n    TARGET_COL_LIST,\n    mode='test',\n    transform=transform\n)\ntest_dataloader = DataLoader(\n    test_dataset,\n    batch_size=VAL_BATCH_SIZE,\n    shuffle=False,\n    num_workers=NUM_WORKERS,\n    pin_memory=True\n)\n\ntest_pred = np.zeros((len(test_dataset), len(best_model_path_list)))\nfor i, model_path in enumerate(best_model_path_list):\n    state_dict = torch.load(model_path, map_location=model.device)['state_dict']\n    model.load_state_dict(state_dict, strict=False)\n    test_batch_pred_list = []\n    for batch in test_dataloader:\n        test_batch_pred_list.append(model(batch).sigmoid())\n    test_pred[:, i] = torch.cat(test_batch_pred_list).view(-1).detach().numpy()","9db625d0":"del df_train\ndel train_dataloader\ndel val_dataloader\ndel test_dataloader\ndel state_dict\ndel model\n\ngc.collect()","8d719869":"df_test['target'] = test_pred.mean(axis=1)\ndf_sub = pd.read_csv(\"..\/input\/ai-medical-contest-2021\/sample_submission.csv\").drop(columns=['target'])\ndf_sub = pd.merge(df_sub, df_test, how='left', on='Id')[['Id', 'target']]\ndf_sub.to_csv('submission.csv', index=None)","e90db23a":"\u57fa\u7dda\u306e\u63fa\u308c\u304c\u5927\u304d\u3044V2\u8a98\u5c0e\u306e\u6ce2\u5f62\u3092\u7dba\u9e97\u306b\u3057\u3066\u307f\u308b\u3002","6547b361":"## 3.4. Submission","120a4204":"## 2.1. BioSSPy\u3067\u5468\u6ce2\u6570\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0","56950cad":"## \u6b21\u306b\u3067\u304d\u305d\u3046\u306a\u3053\u3068\n\n- 5-fold CV\u3059\u308b\n    - \u8a13\u7df4\u30c7\u30fc\u30bf\u304c\u5c11\u306a\u304f\u534a\u6570\u306f\u30ce\u30a4\u30ba\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u53ef\u80fd\u6027\u304c\u9ad8\u3044\u30c7\u30fc\u30bf\u3067\u3042\u308b\u305f\u3081\uff0cCV\u3067\u30e2\u30c7\u30eb\u3092\u8a55\u4fa1\u3057\u305f\u307b\u3046\u304c\u5b89\u5168\u3002\n    - validation\u306b\u306flabel_type\u304c'human'\u3060\u3051\u306e\u30c7\u30fc\u30bf\u3092\u7528\u3044\u308b\u3002\n- \u30cf\u30a4\u30d1\u30fc\u30d1\u30e9\u30e1\u30fc\u30bf\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\n    - \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u306e\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\uff0c\u5b66\u7fd2\u7387\u306a\u3069\n- augmentation\n    - \u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u89e3\u6790\u306f\u77ed\u3044\u6642\u9593\u8ef8\u3067\u5fc3\u96fb\u56f3\u3092\u533a\u5207\u3063\u3066\u3044\u308b\u306e\u3067\uff0c\u6ce2\u5f62\u306e\u6642\u9593\u65b9\u5411\u306e\u305a\u308c\u306b\u3088\u3063\u3066\u533a\u5207\u308a\u65b9\u304c\u5909\u308f\u308a\uff0c\u30b9\u30da\u30af\u30c8\u30eb\u5f37\u5ea6\u304c\u7570\u306a\u308b\u3002\n      \u5fc3\u96fb\u56f3\u3092\u6642\u9593\u65b9\u5411\u306b\u305a\u3089\u3057\u3066\u304b\u3089\u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u89e3\u6790\u3059\u308c\u3070\u9811\u5065\u6027\u304c\u4e0a\u304c\u308b\u3002\n- recurrence plot\n    - recurrence plot\u3082\u7d44\u307f\u5408\u308f\u305b\u308b\u3002\n- \u5e74\u9f62\u3084\u6027\u5225\uff0c\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u306e\u969b\u306b\u6c42\u3081\u305f\u5fc3\u62cd\u6570\u306a\u3069\u3092\u5229\u7528\u3059\u308b\n    - heart_rate\u306f\u5fc3\u62cd\u6570\u306e\u7d4c\u6642\u5909\u5316\u3092\u8868\u3057\u3066\u3044\u308b\u3002\n- \u753b\u50cf\u306f\u8ae6\u3081\u308b\n    - 1dcnn\u306e\u30d9\u30fc\u30b9\u30e9\u30a4\u30f3\u3088\u308a\u3082\u30b9\u30b3\u30a2\u304c\u4f4e\u3044\u306e\u3067\uff0c\u305d\u306e\u306e\u6539\u5584\u306b\u96c6\u4e2d\u3057\u305f\u307b\u3046\u304c\u6700\u7d42\u7684\u306a\u30b9\u30b3\u30a2\u306f\u9ad8\u304f\u306a\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u3002\n    - \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u306f1dcnn\u3067\u3082\u5229\u7528\u3067\u304d\u308b(\u304c\uff0c\u7cbe\u5ea6\u5411\u4e0a\u306b\u5bc4\u4e0e\u308b\u3059\u3068\u306f\u9650\u3089\u306a\u3044)\u3002","f15704c7":"\u4ee5\u4e0a\u3092dataset\u306etransform\u3068\u3057\u3066\u7528\u3044\u3066\u3082\u826f\u3044\u3067\u3059\u304c\uff0c1\u6ce2\u5f62\u3054\u3068\u306b\u5468\u6ce2\u6570\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3068\u30d5\u30fc\u30ea\u30a8\u89e3\u6790\u3092\u884c\u3046\u306e\u3067\uff0c\u8a08\u7b97\u5168\u4f53\u306e\u30dc\u30c8\u30eb\u30cd\u30c3\u30af\u306b\u306a\u3063\u3066\u3057\u307e\u3044\u307e\u3059\u3002\n\n\u3088\u3063\u3066\uff0c\u4eca\u56de\u306f\u4ee5\u4e0b\u306e\u30b3\u30fc\u30c9\u3092\u5b9f\u884c(\u6570\u5341\u5206\u304b\u304b\u308a\u307e\u3059)\u3057\u3066\u4e8b\u524d\u306b\u4f5c\u6210\u3057\u305f\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3067\u8a13\u7df4\u3092\u884c\u3044\u307e\u3059\u3002\n\n```\ndef makedirs(path):\n    if not os.path.isdir(path):\n        os.makedirs(path)\n\nmakedirs('..\/input\/spectrogram')\n\ndf_traintest = pd.concat([df_train, df_test]).reset_index(drop=True)\nall_path_list = list(df_traintest['path'].values)\necg2filter = ECGFilter()\necg2spectrogram = ECGSpectrogram()\nfor i, path in enumerate(all_path_list):\n    spectrogram = ecg2spectrogram(ecg2filter(np.load(path)))\n    np.save(\n        f'..\/input\/spectrogram\/{os.path.basename(path)}',\n        spectrogram \/ spectrogram.max()\u3000# \u30b9\u30da\u30af\u30c8\u30eb\u5f37\u5ea6\u304c\u5c0f\u3055\u3044\u306e\u3067[0, 1]\u306b\u30b9\u30b1\u30fc\u30eb\n    )  \n    if i % 1000 == 0:\n        print(i, spectrogram.shape)\n```","5843223c":"## 3.3. PyTroch Lightning","00832fbe":"## 2.3. Scipy\u3067recurrence plot","37626143":"## 3.2. Transform\n\n\u5468\u6ce2\u6570\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\uff0cspectrogram\uff0crecurrence plot\u306etransnform\u3002","8218b5f9":"# 3. 2DCNN with PyTorch Lightning","7a07fc70":"# 1. \u30c7\u30fc\u30bf\u8aad\u307f\u8fbc\u307f\u3068\u53ef\u8996\u5316","cee2e1dc":"## 2.2. Scipy\u3067\u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u89e3\u6790","0476972d":"## 3.2. Dataset","180edef0":"# 2. \u6ce2\u5f62\u306e\u51e6\u7406\n\n- BioSPPy: \u751f\u4f53\u60c5\u5831\u3092\u6271\u3048\u308b\u30e9\u30a4\u30d6\u30e9\u30ea\u3002\u5468\u6ce2\u6570\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3092\u7528\u3044\u3066ECG\u306e\u30ce\u30a4\u30ba\u3092\u9664\u53bb\u3059\u308b\u3002\n- Scipy: \u79d1\u5b66\u8a08\u7b97\u30e9\u30a4\u30d6\u30e9\u30ea\u3002\u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u89e3\u6790\u306b\u3088\u308bspectrogram\u3068recurrence plot\u3092\u7528\u3044\u3066ECG\u3092\u753b\u50cf\u5316\u3059\u308b\u3002"}}