{"cell_type":{"29297a25":"code","28942642":"code","94b815c8":"code","2292f9b9":"code","81d8820a":"code","c0d35179":"code","50a24850":"code","8911c771":"code","164efb8a":"code","d4b45bac":"code","de1f9c4e":"code","d27abd26":"code","4bd8fe28":"code","6480fec3":"code","de23e36d":"code","6ed4d11b":"code","cbcac346":"code","c11f254a":"code","475e2c76":"code","33f9d1e4":"code","f926eaa1":"code","4e324e8b":"code","ab4bfa35":"code","d993707f":"code","757ae215":"code","98407904":"code","9baed504":"code","dbed41e5":"code","d51dcf21":"code","7fffc295":"code","fe7f9ae6":"code","e64f48d4":"code","f4154bc0":"code","d5a223b1":"code","75a8e3f6":"code","b4efd599":"code","f9ca3aaf":"code","fa382642":"code","d131d582":"code","523e2be1":"code","150764bf":"code","7d1f1c6a":"code","af38c02b":"code","03847ec5":"code","877985e6":"code","8c3cd71b":"code","2d032b37":"code","f74090e1":"code","c5196e8c":"code","008dd0be":"code","03314213":"code","9aed6f4f":"code","faec660c":"code","244caf2d":"code","11e2346c":"code","32e8a02a":"code","63b7d58f":"code","59f2a498":"code","605eff87":"code","83f4d540":"markdown","d9ea100d":"markdown","d65838c5":"markdown","0bf95d16":"markdown","a560b2a8":"markdown","574ed2ef":"markdown","82cc9413":"markdown","a38953aa":"markdown","c97ec9a0":"markdown","370e5dca":"markdown","55ba6656":"markdown","a2b34693":"markdown","38c8d6ae":"markdown","429e0274":"markdown","cebeb35f":"markdown","d4640580":"markdown"},"source":{"29297a25":"import random\nimport numpy as np\nfrom datetime import datetime\n\nimport pandas as pd\nfrom pandas.api.types import is_string_dtype\nfrom pandas.api.types import is_numeric_dtype\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom scipy import stats\nfrom sklearn import model_selection\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.tree import DecisionTreeClassifier, plot_tree\nfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier\nfrom sklearn.preprocessing import MinMaxScaler, StandardScaler\nfrom sklearn.impute import SimpleImputer\nfrom sklearn import tree\nfrom sklearn import metrics\n\n\nplt.style.use('ggplot')\npd.set_option('display.max_rows', 100)\n\nRANDOM_STATE = 42\nROWS = 500000\nTARGET = \"HasDetections\"\n\n#PARA TRATAR LOS DATOS EN BLOQUE\nlimit = 300 # Cantidad de valores \u00fanicos (columnas tras OHE)\nstart = 50 # Numero de muestras minimo por valor unico.\nstep = 10 # Step dentro del bucle para ir aumentando la cantidad de muestras.","28942642":"dtypes = {\n        'MachineIdentifier':                                    'category',\n        'ProductName':                                          'category',\n        'EngineVersion':                                        'category',\n        'AppVersion':                                           'category',\n        'AvSigVersion':                                         'category',\n        'IsBeta':                                               'int8',\n        'RtpStateBitfield':                                     'float16',\n        'IsSxsPassiveMode':                                     'int8',\n        'DefaultBrowsersIdentifier':                            'float32',\n        'AVProductStatesIdentifier':                            'float32',\n        'AVProductsInstalled':                                  'float16',\n        'AVProductsEnabled':                                    'float16',\n        'HasTpm':                                               'int8',\n        'CountryIdentifier':                                    'int16',\n        'CityIdentifier':                                       'float32',\n        'OrganizationIdentifier':                               'float16',\n        'GeoNameIdentifier':                                    'float16',\n        'LocaleEnglishNameIdentifier':                          'int16',\n        'Platform':                                             'category',\n        'Processor':                                            'category',\n        'OsVer':                                                'category',\n        'OsBuild':                                              'int16',\n        'OsSuite':                                              'int16',\n        'OsPlatformSubRelease':                                 'category',\n        'OsBuildLab':                                           'category',\n        'SkuEdition':                                           'category',\n        'IsProtected':                                          'float16',\n        'AutoSampleOptIn':                                      'int8',\n        'PuaMode':                                              'category',\n        'SMode':                                                'float16',\n        'IeVerIdentifier':                                      'float16',\n        'SmartScreen':                                          'category',\n        'Firewall':                                             'float16',\n        'UacLuaenable':                                         'float64', # was 'float32'\n        'Census_MDC2FormFactor':                                'category',\n        'Census_DeviceFamily':                                  'category',\n        'Census_OEMNameIdentifier':                             'float32', # was 'float16'\n        'Census_OEMModelIdentifier':                            'float32',\n        'Census_ProcessorCoreCount':                            'float16',\n        'Census_ProcessorManufacturerIdentifier':               'float16',\n        'Census_ProcessorModelIdentifier':                      'float32', # was 'float16'\n        'Census_ProcessorClass':                                'category',\n        'Census_PrimaryDiskTotalCapacity':                      'float64', # was 'float32'\n        'Census_PrimaryDiskTypeName':                           'category',\n        'Census_SystemVolumeTotalCapacity':                     'float64', # was 'float32'\n        'Census_HasOpticalDiskDrive':                           'int8',\n        'Census_TotalPhysicalRAM':                              'float32',\n        'Census_ChassisTypeName':                               'category',\n        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float32', # was 'float16'\n        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float32', # was 'float16'\n        'Census_InternalPrimaryDisplayResolutionVertical':      'float32', # was 'float16'\n        'Census_PowerPlatformRoleName':                         'category',\n        'Census_InternalBatteryType':                           'category',\n        'Census_InternalBatteryNumberOfCharges':                'float64', # was 'float32'\n        'Census_OSVersion':                                     'category',\n        'Census_OSArchitecture':                                'category',\n        'Census_OSBranch':                                      'category',\n        'Census_OSBuildNumber':                                 'int16',\n        'Census_OSBuildRevision':                               'int32',\n        'Census_OSEdition':                                     'category',\n        'Census_OSSkuName':                                     'category',\n        'Census_OSInstallTypeName':                             'category',\n        'Census_OSInstallLanguageIdentifier':                   'float16',\n        'Census_OSUILocaleIdentifier':                          'int16',\n        'Census_OSWUAutoUpdateOptionsName':                     'category',\n        'Census_IsPortableOperatingSystem':                     'int8',\n        'Census_GenuineStateName':                              'category',\n        'Census_ActivationChannel':                             'category',\n        'Census_IsFlightingInternal':                           'float16',\n        'Census_IsFlightsDisabled':                             'float16',\n        'Census_FlightRing':                                    'category',\n        'Census_ThresholdOptIn':                                'float16',\n        'Census_FirmwareManufacturerIdentifier':                'float16',\n        'Census_FirmwareVersionIdentifier':                     'float32',\n        'Census_IsSecureBootEnabled':                           'int8',\n        'Census_IsWIMBootEnabled':                              'float16',\n        'Census_IsVirtualDevice':                               'float16',\n        'Census_IsTouchEnabled':                                'int8',\n        'Census_IsPenCapable':                                  'int8',\n        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',\n        'Wdft_IsGamer':                                         'float16',\n        'Wdft_RegionIdentifier':                                'float16',\n        'HasDetections':                                        'int8'\n        }","94b815c8":"data_cols = [\n    'MachineIdentifier',\n    'ProductName',\n    'EngineVersion',\n    'AppVersion',\n    'AvSigVersion',\n    'RtpStateBitfield',\n    'AVProductStatesIdentifier',\n    'AVProductsInstalled',\n    'AVProductsEnabled',\n    'HasTpm',\n    'Census_OSVersion',\n    'Census_OSArchitecture',\n    'Census_OSBranch',\n    'Census_OSBuildNumber',\n    'Census_OSBuildRevision',\n    'Census_OSEdition',\n    'IsProtected',\n    'IeVerIdentifier',\n    'SmartScreen',\n    \"DefaultBrowsersIdentifier\",\n    \"IeVerIdentifier\",\n    'Firewall',\n    \"OsBuildLab\",\n    \"OsPlatformSubRelease\",\n    'Census_ProcessorCoreCount',\n    'Census_ProcessorManufacturerIdentifier',\n    'Census_ProcessorModelIdentifier',\n    'Census_PrimaryDiskTotalCapacity',\n    'Census_PrimaryDiskTypeName',\n    'Census_TotalPhysicalRAM',\n    'HasDetections',\n    'CountryIdentifier'\n    ]\n","2292f9b9":"dtypes_data = dtypes.copy()\nfor key in dtypes_data.keys():\n    if key not in data_cols:\n        dtypes.pop(key)","81d8820a":"datafile = \"..\/input\/microsoft-malware-prediction\/train.csv\"","c0d35179":"df = pd.read_csv(\n            datafile, \n            nrows=ROWS, \n            skiprows = lambda i: i % 4, \n            low_memory=False, \n            dtype=dtypes,\n            usecols=data_cols\n        )","50a24850":"df.info(verbose=False)","8911c771":"df.head(1).T","164efb8a":"df.set_index(\"MachineIdentifier\", inplace=True)","d4b45bac":"plt.figure(figsize=(6, 5))\np = sns.countplot(\n    data=df,\n    x = TARGET\n)","de1f9c4e":"df[TARGET].value_counts()","d27abd26":"# This one returns the boolean variables\ndef isBool(nodel=False):\n    bool_cols = [col for col in df if np.isin(df[col].dropna().unique(), [0, 1]).all()]\n    if nodel:\n        bool_cols.remove(nodel)\n    return bool_cols\n\n# A OHE generator\ndef generate_dummies(dataframe, column_name):\n    _dummy_dataset = pd.get_dummies(dataframe[column_name], prefix=column_name)\n    dataframe = pd.concat([dataframe, _dummy_dataset], axis=1)\n    dataframe.drop(column_name, axis=1, inplace=True)\n    del _dummy_dataset\n    return dataframe\n\n# Explore return a dataframe with number of rows per uniq value and the mean based on TARGET\ndef explore_cat_values(dataframe, column, target_column):\n    _results_df = dataframe.pivot_table(index=column, values=target_column, aggfunc=[len, np.mean])\n    _results_df.columns = ['n_machines', 'mean_detection']\n    _results_df['pct_rows'] = dataframe[column].value_counts(normalize=True, dropna=False)\n    _results_df = _results_df[['n_machines', 'pct_rows', 'mean_detection']]\n    return _results_df\n\n# Select the top values based on the rows per value\ndef setOthers(dataframe, column, num_values):\n    top_categories = dataframe[column].value_counts().head(num_values)\n    top_categories_list = top_categories.index.to_list()\n    top_categories_list.append('Others')\n    dataframe[column] = pd.Categorical(dataframe[column], categories=top_categories_list)\n    return dataframe[column].fillna('Others')\n\n# Select the top and the bottom values based on mean detection.\ndef setOthersPataNegra(dataframe, column, target_column, num_rows_min, top_n):\n    results_by_category = explore_cat_values(dataframe, column, target_column)\n    last_categories = results_by_category[results_by_category['n_machines'] > num_rows_min].sort_values(by='mean_detection').head(top_n).index.to_list()\n    first_categories = results_by_category[results_by_category['n_machines'] > num_rows_min].sort_values(by='mean_detection').tail(top_n).index.to_list()\n    top_categories_list = first_categories + last_categories\n    top_categories_list.append('Others')\n    dataframe[column] = pd.Categorical(dataframe[column], categories=top_categories_list)\n    return dataframe[column].fillna('Others')\n\n# A null filler\ndef simpleNaN(column, filler):    \n    df[column].fillna(filler, inplace=True)\n    return None\n\n# A (dumb) null filler with strategy\n# strat_value=df[i].mode()[0]  --  MyImputer(df,i,strat_value)\ndef MyImputer(dataframe, column, strategy):\n    dataframe[column] = dataframe[column].fillna(strategy)\n    return None\n\n# Do MinMaxScaler from sklearn.processing\ndef minmaxScal(dataframe, column):\n    minMaxResul = MinMaxScaler()\n    dataframe[column] = minMaxResul.fit_transform(dataframe[column].values.reshape(-1,1))\n    return minMaxResul\n\n# Do StandarScaler from sklearn.processing\ndef stScal(dataframe, column):\n    stResult = StandardScaler()\n    dataframe[column] = stResult.fit_transform(dataframe[column].values.reshape(-1,1))\n    return stResult\n\n# Create a new column with the frecuency of each value\ndef frequency(dataframe, column, new_column):\n    dataframe[new_column] = dataframe.groupby(by=column)[column].transform('count')","4bd8fe28":"df.describe(include=np.number).T","6480fec3":"frequency(df,\"CountryIdentifier\",\"CountryIdentifier_new\")","de23e36d":"df[['CountryIdentifier_new', \"CountryIdentifier\"]].sort_values(by=\"CountryIdentifier_new\", ascending=False).head(5)","6ed4d11b":"df.drop(columns=[\"CountryIdentifier\"], inplace=True)","cbcac346":"num_vars = df.select_dtypes(include=np.number).columns\nnum_vars = num_vars.drop(\"HasDetections\")","c11f254a":"num_vars","475e2c76":"df[\"AvSigVersion\"].head(10)","33f9d1e4":"bools_vars = isBool(TARGET)","f926eaa1":"for i in bools_vars:\n    nnan=df[i].isnull().sum()\n    print(\"{} has {} nulls\".format(i, nnan))\n    if nnan > 0:\n        simpleNaN(i, 0)\n    print(df[i].value_counts(),\"\\n\")","4e324e8b":"df.describe(include=np.number).T","ab4bfa35":"true_num=[\n    \"Census_ProcessorCoreCount\",\n    \"Census_PrimaryDiskTotalCapacity\",\n    \"Census_TotalPhysicalRAM\",\n    \"CountryIdentifier_new\"\n    ]","d993707f":"for i in true_num:\n    nnan=df[i].isnull().sum()\n    if nnan > 0:\n        strat_value=df[i].mode()[0]  \n        MyImputer(df,i,strat_value)","757ae215":"fig, axes = plt.subplots(nrows=3, ncols=2, figsize=(16, 10))\naxes = axes.flat\nfor i, colum in enumerate(true_num):\n    sns.boxenplot(\n        data    = df,\n        x       = colum,\n        ax      = axes[i]\n    )\n    axes[i].set_title(colum, fontsize = 12)\n    axes[i].tick_params(labelsize = 6)\n    axes[i].set_xlabel(\"\")\n    \n    \nfig.tight_layout()\nplt.subplots_adjust(top = 0.9)\nfig.suptitle('Distribuci\u00f3n variables num\u00e9ricas', fontsize = 16, fontweight = \"bold\");","98407904":"#for x in [i for i in num_vars if i not in true_num]:\n#    df[x] = df[x].astype(\"str\")        ","9baed504":"df.describe(include=np.number).T","dbed41e5":"df.describe(exclude=np.number).T","d51dcf21":"cat_vars = list(df.select_dtypes(exclude=np.number).columns.values)","7fffc295":"print(type(cat_vars), type(non_num_vars))","fe7f9ae6":"non_num_vars = [i for i in num_vars if i not in true_num]\nall_cat_vars = non_num_vars + cat_vars\nall_cat_vars","e64f48d4":"for x in all_cat_vars:\n    limiti = limit\n    nnan = df[x].isnull().sum()\n    nuniq = df[x].nunique()\n   \n    if nnan == 0 and nuniq <= limiti:\n        print(\"1 - {} Nulls: {} Uniq: {}\".format(x ,nnan, nuniq))\n        \n        if is_numeric_dtype(df[x]):\n            print(\"{} from {} to STR\".format(x, df[x].dtypes))\n            df[x] = df[x].astype('str')\n        \n    elif nnan > 0 and nuniq <= limiti:\n        \n        _df_x = explore_cat_values(df, x, TARGET)\n        s = _df_x[_df_x[\"n_machines\"] > start].sort_values(by=\"mean_detection\").count()\n        print(\"2 - {} Nulls: {} Uniq: {}\".format(x ,nnan, nuniq))\n        \n        if is_numeric_dtype(df[x]):\n            print(\"{} from {} to STR\".format(x, df[x].dtypes))\n            df[x] = df[x].astype('str')\n        df[x] = setOthers(df, x, start)\n        \n    else:\n        _df_x = explore_cat_values(df, x, TARGET)\n        s = _df_x[_df_x[\"n_machines\"] > start].sort_values(by=\"mean_detection\").count()\n        \n        if s.n_machines > limiti:\n            while s.n_machines > limiti:\n                start = start + step\n                s = _df_x[_df_x[\"n_machines\"] > start].sort_values(by=\"mean_detection\").count()\n            top_n = s.n_machines \/\/ 2 - 2\n            print(\"3 - {} Nulls: {} Uniq: {} TopN: {} Categories: {}\".format(x ,nnan, nuniq, top_n, s.n_machines))\n        else:\n            top_n = s.n_machines \/\/ 2 - 1\n            print(\"3 - {} Nulls: {} Uniq: {} TopN: {} Categories: {}\".format(x ,nnan, nuniq, top_n, s.n_machines))\n            \n        if is_numeric_dtype(df[x]):\n            print(\"{} from {} to STR\".format(x, df[x].dtypes))\n            df[x] = df[x].astype('str')\n            \n        df[x] = setOthersPataNegra(df, x, TARGET, start, top_n)\n        ","f4154bc0":"df.describe(exclude=np.number).T","d5a223b1":"df_final = df.copy(deep=True)","75a8e3f6":"for column in df_final.select_dtypes(exclude=np.number).columns:\n    print(\"Doing {} dtype: {}\".format(column, df_final[column].dtypes))\n    df_final = generate_dummies(df_final, column)","b4efd599":"df_final.shape","f9ca3aaf":"df_dev, df_val = train_test_split(df_final, test_size = 0.20, random_state = RANDOM_STATE)","fa382642":"print(\"Desarrollo df_dev: {}\\nValidaci\u00f3n df_val: {}\".format(df_dev.shape, df_val.shape ))","d131d582":"df_dev_y = df_dev[[TARGET]]\ndf_dev_X = df_dev.drop(TARGET, axis=1)","523e2be1":"df_val_y = df_val[[TARGET]]\ndf_val_X = df_val.drop(TARGET, axis=1)","150764bf":"X_train, X_test, y_train, y_test = model_selection.train_test_split(\n    df_dev_X, \n    df_dev_y,\n    test_size = 0.20,\n    random_state = RANDOM_STATE\n    )","7d1f1c6a":"dt = DecisionTreeClassifier(max_depth=4,\n                            random_state=RANDOM_STATE\n                            )","af38c02b":"dt.fit(\n    X_train, \n    y_train\n)","03847ec5":"plt.figure(figsize=(30,10))\n_ = tree.plot_tree(decision_tree = dt,\n               feature_names = X_train.columns, \n               class_names = ['Safe', 'Unsafe'],\n               filled = True)","877985e6":"y_test_prediction = pd.DataFrame(dt.predict(X_test), index=X_test.index, columns=['Prediction'])","8c3cd71b":"results_df = y_test.join(y_test_prediction)","2d032b37":"results_df['Success'] = (results_df[TARGET] == results_df['Prediction']).astype(int)","f74090e1":"print('Hemos acertado {} registros de {}, con una media de acierto de {}'.format(\n    results_df['Success'].sum(),\n    results_df['Success'].count(),\n    results_df['Success'].mean() * 100\n))","c5196e8c":"confusion_matrix = pd.crosstab(results_df[TARGET],results_df['Prediction'])\nconfusion_matrix","008dd0be":"TP = confusion_matrix.iloc[1,1]\nTN = confusion_matrix.iloc[0,0]\nFP = confusion_matrix.iloc[0,1]\nFN = confusion_matrix.iloc[1,0]","03314213":"accuracy = (TP + TN) \/ (TP + TN + FP + FN)\nprint(\"Accuracy: {}\".format(accuracy))","9aed6f4f":"dt.score(X_test, y_test)","faec660c":"dt.score(df_val_X, df_val_y)","244caf2d":"Precision = TP \/ (TP + FP)\nRecall = TP \/ (TP + FN)","11e2346c":"f1_score = 2 \/ ( 1\/Precision + 1\/Recall )\nf1_score","32e8a02a":"metrics.f1_score(y_test, y_test_prediction)","63b7d58f":"print(metrics.roc_auc_score(results_df['HasDetections'], results_df['Prediction']))\nrocauc_dtree=metrics.roc_auc_score(results_df['HasDetections'], results_df['Prediction'])","59f2a498":"RANDOM_STATE = 42\nn_estimators = 150\nmax_depth = 4\n\nmodels = [ \n    ('DecisionTree', DecisionTreeClassifier(max_depth=max_depth, random_state=RANDOM_STATE)),\n    ('RandomForest', RandomForestClassifier(n_estimators=n_estimators, max_depth=max_depth, random_state=RANDOM_STATE)),\n    ('GradientBoosting', GradientBoostingClassifier(n_estimators=n_estimators, max_depth=max_depth, random_state=RANDOM_STATE))\n]","605eff87":"plt.figure(figsize=(8,8))\nplt.clf()\nfor model in models:\n    model_name = model[0]\n    model_instance = model[1]\n    model_instance.fit(X_train, np.ravel(y_train))\n    predictions = model_instance.predict_proba(X_test)[:,1]\n    auc_score = metrics.roc_auc_score(y_test, predictions)\n    print('ROC AUC Score for {}: {}'.format(model_name, auc_score))\n    fpr, tpr, _ = metrics.roc_curve(y_test, predictions)\n    plt.plot(fpr, tpr, label='ROC Curve for {} - Area: {:2f}'.format(model_name, auc_score))\nplt.plot([0, 1], [0, 1], color='gray', linestyle='--')\nplt.xlabel('FPR')\nplt.ylabel('TPR')\nplt.legend(loc=\"lower right\")\nplt.title('ROC curve')\nplt.show()","83f4d540":"### Now check what to do with false numerical","d9ea100d":"### In this point we have numerical variables without Nulls","d65838c5":"### Let's starts with the Model\n1. Split our data in development and validation\n1. Split our development in train and test\n1. Model instance\n1. Fit (trainining) the model\n1. Evaluate the chosen model (predict)\n1. Check against validation\n","0bf95d16":"We imported just 28 columns.","a560b2a8":"### Numerical columns doesn't have a normal distribution, but for trees it's not so important we will keep it at is","574ed2ef":"### I will fill with 0 because not value means 0.","82cc9413":"#### Change the dtype for those variables that i think aren't truly numerical, we will deal with them later","a38953aa":"### From this point We will deal with Categorical ones + Non True numerical","c97ec9a0":"### Check numerical variables. We need to understand what kind of information is included in each one.","370e5dca":"For me just 5 columns of this limited dataset are truly numerical:","55ba6656":"### EDA Complete. Our DataFrame is ready to OHE!\nWe will create a new DataFrame called **df_final**. May be we will need to return to this point :(","a2b34693":"HasDetections is our Target.","38c8d6ae":" MachineIdentifier as index.","429e0274":"### Some of the variables aren't numerical because cleary are versions or boolean columns, so we will deal with them as categorical ones\nFirst of all we have booleans variables, checking it:","cebeb35f":"# Windows Malware Prediction\n### Second round.","d4640580":"### Some good functions!!!"}}