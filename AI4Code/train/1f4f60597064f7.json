{"cell_type":{"5358912d":"code","32edc784":"code","5e455394":"code","c11e95e5":"code","301106ef":"code","59fbd20b":"markdown"},"source":{"5358912d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","32edc784":"from math import sqrt\nimport matplotlib.pyplot as plt\nimport warnings\nfrom collections import Counter\nplt.style.use(\"fivethirtyeight\")","5e455394":"#Sample Euclidean distance calculation \n\na = np.array([1,2])\nb = np.array([2,4])   \n\nprint(\"euclidean distance between a and b is: \" + str(np.linalg.norm(a-b)))   #using l2 norm   ","c11e95e5":"#creating a dataset\n\n# Two classes are k, r  \n# Dictionary with class name as key and point and respective point coordinates as list of lists\ndataset = {\"k\":[[1,2],[2,3],[3,1]], \"r\":[[6,5],[7,7],[8,6]] }      #dictionary with class name as key and point and respective point coordinates as list of lists\n\nnew_point = [5,7]   #need to classify this point\n\n\n#looping to plot the points\n\nfor i in dataset:\n    for j,k in dataset[i]:\n        plt.scatter(j,k,s=100,color=i)\n        \n#k is the black points class\n#r is the red boints class\n\nplt.scatter(new_point[0],new_point[1],s=100)\n\n","301106ef":"#Need to classify the blue point\n\ndef KNearestNeighbors(data,predict,k=3):                  #data input is of dictionary type\n    if len(data) >=k :\n        warnings.warn(\"K is lower than total voting classes\")\n    \n    dist = []\n    for key in data:                                      # looping to through the dictionary \n        for features in data[key]:\n            euclidean_distance = np.linalg.norm(np.array(features) - np.array(predict))                   #calculating the distance of nw points to all old points\n            dist.append([euclidean_distance,key])\n            \n    votes = [item[1] for item in sorted(dist)[:k]]\n    vote_result = Counter(votes).most_common(1)[0][0]\n    return vote_result\n\nresult = KNearestNeighbors(dataset,new_point,k=3)\n\nprint(\"The new point belongs to the group : \" +str(result))\n\n    ","59fbd20b":"\nKNN is computationally expensive for very large datasets (TB) so its not scalable"}}