{"cell_type":{"dd16226e":"code","1e823ffd":"code","1cbcc512":"code","e3142582":"code","41e015d7":"code","81be4d9f":"code","d57262a3":"code","b661ca59":"code","bddbd7ff":"code","a64387e1":"code","f77c9a12":"code","6e44beaf":"code","e91ec589":"code","7ce7fb8b":"code","73a2c29a":"code","4c730aa3":"code","9762fe32":"markdown","2c3d3e1d":"markdown","cf0c824c":"markdown"},"source":{"dd16226e":"import numpy as np\nimport pickle\nimport torch\n\n# Get the interactive Tools for Matplotlib\n%matplotlib inline\nimport matplotlib.pyplot as plt\nplt.rcParams['figure.figsize'] = [9.5, 6]","1e823ffd":"class Vocabulary(object):\n    def __init__(self, pad_token='<pad>', unk_token='<unk>', eos_token='<eos>'):\n        self.token2idx = {}\n        self.idx2token = []\n        self.pad_token = pad_token\n        self.unk_token = unk_token\n        self.eos_token = eos_token\n        if pad_token is not None:\n            self.pad_index = self.add_token(pad_token)\n        if unk_token is not None:\n            self.unk_index = self.add_token(unk_token)\n        if eos_token is not None:\n            self.eos_index = self.add_token(eos_token)\n\n    def add_token(self, token):\n        if token not in self.token2idx:\n            self.idx2token.append(token)\n            self.token2idx[token] = len(self.idx2token) - 1\n        return self.token2idx[token]\n\n    def get_index(self, token):\n        if isinstance(token, str):\n            return self.token2idx.get(token, self.unk_index)\n        else:\n            return [self.token2idx.get(t, self.unk_index) for t in token]\n\n    def __len__(self):\n        return len(self.idx2token)\n\n    def save(self, filename):\n        with open(filename, 'wb') as f:\n            pickle.dump(self.__dict__, f)\n\n    def load(self, filename):\n        with open(filename, 'rb') as f:\n            self.__dict__.update(pickle.load(f))","1cbcc512":"DATASET_VERSION = 'en-100'\nCBOW_VOCABULARY_ROOT = f'..\/input\/text-preprocessing-english\/data\/{DATASET_VERSION}'\nCBOW_VECTORS_ROOT = f'..\/input\/cbow-training-english\/data\/{DATASET_VERSION}'","e3142582":"dict = f'{CBOW_VOCABULARY_ROOT}\/en.wiki.train.tokens.nopunct.dic'\ncounter = pickle.load(open(dict, 'rb'))\nwords, values = zip(*counter.most_common(5000))\nprint('Most frequent words')\nprint(words[:10])\nprint(values[:10])","41e015d7":"from scipy.stats import entropy\nh = entropy(values)\nprint(f'Word entropy: {h:5.2f}, Perplexity: {np.exp(h):5.0f}')\nprint(f'Probability of the most frequent word: {values[0]\/sum(values):2.3f}')","81be4d9f":"_ = plt.plot(values[:50], 'g', 2*values[0]\/np.arange(2,52), 'r')","d57262a3":"_ = plt.loglog(values)\nplt.show()","b661ca59":"from collections import Counter\nbenford = Counter(int(str(item[1])[0]) for item in counter.most_common(7000))\nprint(benford)\npercentage = np.array(list(benford.values()), dtype=float)\npercentage \/= percentage.sum()\n_ = plt.bar(list(benford.keys()), percentage*100)","bddbd7ff":"modelname = f'{CBOW_VECTORS_ROOT}\/{DATASET_VERSION}.pt'\nstate_dict = torch.load(modelname, map_location=torch.device('cpu'))","a64387e1":"state_dict.keys()","f77c9a12":"input_word_vectors = state_dict['emb.weight'].numpy()\noutput_word_vectors = state_dict['lin.weight'].numpy()","6e44beaf":"token_vocab = Vocabulary()\ntoken_vocab.load(f'{CBOW_VOCABULARY_ROOT}\/en.wiki.vocab')","e91ec589":"class WordVectors:\n    def __init__(self, vectors, vocabulary):\n        # TODO \n        self.vocabulary = vocabulary\n    \n    def most_similar(self, word, topn=10):\n        # TODO\n        return [\n            ('Spanish', 0.6386944),\n            ('Galician', 0.6217334),\n            ('Slovene', 0.615297),\n            ('Portuguese', 0.60148776),\n            ('Sardinian', 0.5932354),\n            ('Asturian', 0.57670474),\n            ('French', 0.5766156),\n            ('Swiss', 0.57484806),\n            ('Belgian', 0.5649847),\n            ('Italian', 0.56316745)\n        ]\n    \n    def analogy(self, x1, x2, y1, topn=5, keep_all=False):\n        # If keep_all is False we remove the input words (x1, x2, y1) from the returned closed words\n        # TODO\n        return [\n            ('Polish', 0.6871295),\n            ('Romanian', 0.6667892),\n            ('German', 0.6514244),\n            ('Finnish', 0.62335044),\n            ('Russian', 0.5811396),\n            ('Hungarian', 0.57879245),\n            ('Swedish', 0.57441497)\n        ]","7ce7fb8b":"model1 = WordVectors(input_word_vectors, token_vocab)\nmodel2 = WordVectors(output_word_vectors, token_vocab)","73a2c29a":"model1.most_similar('Catalan')","4c730aa3":"model1.analogy('France', 'French', 'Poland')","9762fe32":"We will use the vocabulary computed by the Text Preprocessing notebook (text-preprocessing), and the word vectors computed by the CBOW Training notebook (cbow-vectors)","2c3d3e1d":"**Benford's law**, also called the Newcomb\u2013Benford law, the law of anomalous numbers, or the first-digit law, is an observation about the frequency distribution of leading digits in many real-life sets of numerical data.","cf0c824c":"**Zipf's law of words**. Zipf's law was originally formulated in terms of quantitative linguistics, stating that given some corpus of natural language utterances, the frequency of any word is inversely proportional to its rank in the frequency table."}}