{"cell_type":{"429f5323":"code","593d6f53":"code","feea3cf4":"code","69840b35":"code","d8e1301d":"code","1ded80cb":"code","d70db620":"code","cf6c6d93":"code","03143d01":"code","0a7e6d49":"code","598cd8be":"code","1033d007":"code","34e783cb":"code","4c81ca04":"code","c9a01a0a":"code","4a6da09d":"code","674dbef3":"code","b261ff36":"code","e540ac0b":"markdown","e3f09123":"markdown","a72bee02":"markdown","218177c7":"markdown","b5cf5cdf":"markdown"},"source":{"429f5323":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","593d6f53":"# Adding imports that will be used\nfrom collections import namedtuple\nimport networkx as nx\nimport math","feea3cf4":"# Definition of the tuples that will be read from the input files. These tuples of two positions represent the coordinates of the cities\nPoint = namedtuple(\"Point\", ['x', 'y'])\n\ndef distance(point1, point2):\n    \"\"\" Function to compute the euclidean distance between two points (two cities) \"\"\"\n    return math.sqrt((point1.x - point2.x)**2 + (point1.y - point2.y)**2)","69840b35":"def readPoints(input_data):\n    \"\"\" This function takes all lines in a input data (coming from a file) and transforms it into a points array \"\"\"\n    lines = input_data.split('\\n')\n    nodeCount = int(lines[0])\n    points = []\n    for i in range(1, nodeCount+1):\n        line = lines[i]\n        parts = line.split()\n        points.append(Point(float(parts[0]), float(parts[1])))\n    return nodeCount, points","d8e1301d":"def complete_graph(points):\n    \"\"\" Copy here your implementation from P1 \"\"\"\n","1ded80cb":"def calculate_distance_tour(solution, points):\n    \"\"\" Given the solution and the points, here it is computed the cost by summing all distances between the cities considering the order of the solution \"\"\"\n    cost = distance(points[solution[-1]], points[solution[0]])\n    for index in range(0, len(solution) - 1):\n        cost += distance(points[solution[index]], points[solution[index+1]])\n    return cost\n","d70db620":"def check_solution(solution, points):\n    \"\"\" This method checks that the solution is a valid solution. It is checked that a city is not visited twice. If it's correct, it returns the distance of the journey \"\"\"\n    if len(solution) != len(points) or len(set(solution)) != len(points):\n        print('Soluci\u00f3n Incorrecta: No pasa por todos los nodos una \u00fanica vez')\n        return 0\n    \n    return calculate_distance_tour(solution, points)","cf6c6d93":"def checkMST(points, My_MST):\n    def total_distance(edgesWithWeight):\n        def weight(e):\n            return e[2]['weight']\n\n        len = 0\n        for e in edgesWithWeight:\n            len += weight(e)\n        return len\n\n    # MST computed by NetworkX\n    G      = complete_graph(points) \n    NX_MST = nx.minimum_spanning_tree(G, algorithm='prim')\n\n    # Check that our result matches the result computed by NetworkX\n    NX_Edges = NX_MST.edges(data=True)\n    MY_Edges = My_MST.edges(data=True)\n    d1 = total_distance(NX_Edges)\n    d2 = total_distance(MY_Edges)\n    if abs(d1-d2) > 1E-7:\n        print(\"error: your implementation is wrong\")\n        print(\"  Your MST distance =\", d2)\n        print(\"  Networkx distance =\", d1)\n        assert False","03143d01":"def minimum_spanning_tree_prim(points):\n    def edge_distance(node1, node2):\n        return distance(points[node1], points[node2])\n    \n    T = None\n    # 1) Build the graph\n    # 2.a) Fill the nodes\n    # 2.b) Fill the edges\n    # 3) Prim's initialization of auxiliary data\n    #    Use any node (for example, node 0) as the starting node.\n        # 4) find the minimun edge_distance(u,v) with:\n        #       u in Visited and w in not_visited\n        # 5) Update auxiliary data to continue with the next node\n    \n    \n    checkMST(points, T)\n    return T","0a7e6d49":"def solve_2_approx(points, flag_nx_MST= False):\n    \"\"\" Copy here your implementation from P1. This time you will use your PRIM implementation \"\"\"\n    solution = []\n    return solution","598cd8be":"def solve_it(input_data):\n    \"\"\" This function takes input data that describes a specific problem of TSP and solve it. This is how it does:\n        1 - Parse the input and transform the content of each lines into Points\n        2 - If the list of cities is very big (> 1000)\n        2a - It is not solved\n        2b - Otherwise the previous implemented method is called.\n        3 - Prepare the solution in the specified output format\n        \n    \"\"\"\n    nodeCount, points = readPoints(input_data)\n    \n    if nodeCount>1000:\n        solution = range(0, nodeCount)\n    else:\n        solution = solve_2_approx(points, flag_nx_MST= True)\n        \n    cost = calculate_distance_tour(solution, points)\n    output_data = '%.2f' % cost + ' ' + str(0) + '\\n'\n    output_data += ' '.join(map(str, solution))\n\n    return output_data, check_solution(solution, points)","1033d007":"# Let's check the solution of the same example\nwith open('\/kaggle\/input\/ap-algoritmos-y-programacin-2020-v2\/tsp_5_1', 'r') as input_data_file:\n    input_data = input_data_file.read()\n    example_output, example_distance = solve_it(input_data)\n    print(example_distance)\n    \n# Expected distance for this example: 5.03224755112299","34e783cb":"# This code iterates over all files in put directory and send the problem definitions to the solve it function\nimport time\n\ntotal_time = 0\nimport gc\nstr_output_kaggle = [[\"Filename\",\"Value\"]]\nstr_output_moodle = [[\"Filename\",\"Value\", \"Solution\"]]\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        full_name = dirname+'\/'+filename\n        with open(full_name, 'r') as input_data_file:\n            input_data = input_data_file.read()\n            \n            start = time.time()\n                \n            output, value = solve_it(input_data)\n            gc.collect()\n            str_output_kaggle.append([filename,str(value)])\n            str_output_moodle.append([filename,str(value), output.split('\\n')[1]])\n                \n            end = time.time()\n                \n            print(filename, '(', value, ') time:', end - start)\n            total_time += end-start\n                \nprint('total time: ', total_time)","4c81ca04":"# This function generates the submission file that must be upload to the competition\nfrom IPython.display import FileLink\nimport sys\nimport csv\ncsv.field_size_limit(sys.maxsize)\ndef submission_generation(filename, str_output):\n    os.chdir(r'\/kaggle\/working')\n    with open(filename, 'w', newline='') as file:\n        writer = csv.writer(file)\n        for item in str_output:\n            writer.writerow(item)\n    return  FileLink(filename)","c9a01a0a":"submission_generation('NAME_unsorted_kaggle.csv', str_output_kaggle)","4a6da09d":"# The file generated by this method must be uploaded in the task of the \"campus virtual\". The file to upload in the \"campus virtual\" must be the one related to one submitted to Kaggle. That is, both submitted files must be generated in the same run\nsubmission_generation('NAME_unsorted_moodle.csv', str_output_moodle)","674dbef3":"reader = csv.reader(open(\"NAME_unsorted_kaggle.csv\"))\nsortedlist = sorted(reader, key=lambda row: row[0], reverse=False)","b261ff36":"# This file must be submitted in the competition of Kaggle\nsubmission_generation('NAME_kaggle.csv', sortedlist)","e540ac0b":"En la funci\u00f3n a continuaci\u00f3n se **debe** copiar el c\u00f3digo implementado en la P1. Sin embargo, en vez de llamar al minimum spanning tree de networkX, se llamar\u00e1 a la funci\u00f3n implementada en el bloque anterior","e3f09123":"Esta funci\u00f3n **debe** usarse para validar que el \u00e1rbol de expansi\u00f3n m\u00ednima que obtiene la implementaci\u00f3n propia de Prim coincide con la que calcula NetworkX.","a72bee02":"La funci\u00f3n siguiente **debe** ser implementada con el algoritmo de Prim para la obtenci\u00f3n del \u00e1rbol de expansi\u00f3n m\u00ednimo.","218177c7":"En esta funci\u00f3n se **debe** copiar la implementaci\u00f3n realizada en la P1","b5cf5cdf":"El problema del agente viajero (Travel Salesman Problem - TSP) consiste en encontrar la ruta m\u00e1s corta que permita al agente visitar todas las ciudades regresando a la ciudad de origen. Este problema es f\u00e1cilmente resoluble haciendo una comprobaci\u00f3n de todas las posibles rutas que se pueden realizar y tomando la m\u00e1s corta de todas ellas. Sin embargo, estos m\u00e9todos basados en la fuerza bruta son imposibles de aplicar cuando la lista de ciudades que el agente tiene que visitar crece mucho.\n\nEn esta pr\u00e1ctica se trabajar\u00e1 el problema del agente viajero, teniendo como objetivo alcanzar una soluci\u00f3n que permita calcular rutas cortas para un n\u00famero peque\u00f1o de ciudades. Para ello, y siguiendo este notebook, se tendr\u00e1 que hacer uso del lenguaje de programaci\u00f3n Python y de la librer\u00eda NetworkX. La librer\u00eda NetworkX est\u00e1 orientada al tratamiento de grafos, permitiendo realizar operaciones sobre \u00e9stos. El uso de estas operaciones ser\u00e1 necesario para poder alcanzar el objetivo de esta pr\u00e1ctica.\n\nEn este notebook se han incluido distintos datasets que representan diferentes configuraciones del problema del TSP, con distintas distancias y n\u00famero de ciudades. El c\u00f3digo que acompa\u00f1a a este notebook permite realizar la lectura de estos ficheros para su procesamiento. Existen varios c\u00f3digos a lo largo del notebook que deben ser completados para terminar esta practica. **En esta pr\u00e1ctica se pide realizar una implementaci\u00f3n propia del algoritmo de Prim.**\n\nNOTA: se deben documentar las funciones implementadas por el alumno describiendo qu\u00e9 hace y, a grosso modo, c\u00f3mo lo hace. Pueden tomar como ejemplo la documentaci\u00f3n que traen las otras funciones de este notebook o inspirarse en esta web:\nhttp:\/\/edupython.blogspot.com\/2013\/12\/documentando-programas-en-python.html"}}