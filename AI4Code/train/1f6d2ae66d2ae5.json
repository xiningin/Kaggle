{"cell_type":{"1f190d61":"code","3fae8243":"code","78eba34a":"code","7842c4b9":"code","c6ca701a":"code","3d51b0ae":"code","7cc3cd1c":"code","1edf7a78":"markdown","bcdee139":"markdown"},"source":{"1f190d61":"import pandas as pd\nimport numpy as np\nfrom tqdm import tqdm","3fae8243":"INPUT = '..\/input\/unet34-submission-tta-0-699-new-public-lb\/submission.csv'\nOUTPUT = 'submission.csv'","78eba34a":"def get_mask(img_id, df, shape = (768,768)):\n    img = np.zeros(shape[0]*shape[1], dtype=np.uint8)\n    px = df.loc[img_id]['EncodedPixels']\n    if(type(px) == float): return None\n    elif(type(px) == str): px = [px]\n    count = 1\n    for mask in px:\n        if(type(mask) == float):\n            if len(px) == 1: return None\n            else: continue\n        s = mask.split()\n        for i in range(len(s)\/\/2):\n            start = int(s[2*i]) - 1\n            length = int(s[2*i+1])\n            #keep previous prediction for overlapping pixels\n            img[start:start+length] = count*(img[start:start+length] == 0)\n        count+=1\n    return img.reshape(shape).T\n\ndef decode_mask(mask, shape=(768, 768)):\n    pixels = mask.T.flatten()\n    pixels = np.concatenate([[0], pixels, [0]])\n    runs = np.where(pixels[1:] != pixels[:-1])[0] + 1\n    if(len(runs) == 0): return np.nan\n    runs[runs > shape[0]*shape[1]] = shape[0]*shape[1]\n    runs[1::2] -= runs[::2]\n    return ' '.join(str(x) for x in runs)\n\ndef set_masks(mask):\n    n = mask.max()\n    result = []\n    for i in range(1,n+1):\n        result.append(decode_mask(mask == i))\n    return result","7842c4b9":"pred_df = pd.read_csv(INPUT).set_index('ImageId')\npred_df.head()","c6ca701a":"names = list(set(pred_df.index))\nship_list_dict = []\nfor name in tqdm(names):\n    mask = get_mask(name, pred_df)\n    if (not isinstance(mask, np.ndarray) and mask == None) \\\n      or mask.sum() == 0:# or name in test_names_nothing:\n        ship_list_dict.append({'ImageId':name,'EncodedPixels':np.nan})\n    else:\n        encodings = set_masks(mask)\n        if(len(encodings) == 0):\n            ship_list_dict.append({'ImageId':name,'EncodedPixels':np.nan})\n            continue\n        \n        buf =[]\n        for e in encodings:\n            if e == e: buf.append(e)\n        encodings = buf\n        if len(encodings) == 0 : encodings = [np.nan]\n        for encoding in encodings:\n            ship_list_dict.append({'ImageId':name,'EncodedPixels':encoding})","3d51b0ae":"pred_df_cor = pd.DataFrame(ship_list_dict)\npred_df_cor.to_csv(OUTPUT, index=False)","7cc3cd1c":"gr = pred_df_cor.groupby(\"ImageId\")[\"EncodedPixels\"].apply(lambda x: x.isnull().any() and len(x) > 1)  \nprint(gr.value_counts())  # should all be false  \nprint(gr[gr])  # these images have predictions and nan rows ","1edf7a78":"Check that everything is correct (taken from  https:\/\/www.kaggle.com\/c\/airbus-ship-detection\/discussion\/64252)","bcdee139":"### Overview\nSometimes mask processing may result in mask overlap and the corresponding error when the prediction is submitted. This kernel removes overlapping pixels."}}