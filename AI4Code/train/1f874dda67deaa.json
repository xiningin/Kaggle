{"cell_type":{"b19e555a":"code","99e94e11":"code","3d37d2f8":"code","0deba85f":"code","4ffbd59d":"code","7ee1051f":"code","01d0a1e5":"code","4b82da26":"code","a6495314":"code","4001c118":"code","335b3e73":"code","b9305ac3":"code","06e40f9d":"code","b999e85a":"code","7d17edd9":"code","bee29e21":"code","74ed636e":"code","33c86cb1":"code","49fb7b11":"markdown","1b137e47":"markdown","3b30dc1f":"markdown","d54f5caa":"markdown","c6e20022":"markdown","bc46a385":"markdown","adf0b48f":"markdown","52625990":"markdown","e5dc41dd":"markdown","e2a5292a":"markdown","7fb3c70c":"markdown"},"source":{"b19e555a":"import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport tensorflow as tf\n\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score\nfrom sklearn.model_selection import train_test_split\nfrom tensorflow.keras import layers, losses\nfrom tensorflow.keras.datasets import fashion_mnist\nfrom tensorflow.keras.models import Model","99e94e11":"(x_train, _), (x_test, _) = fashion_mnist.load_data()\n\nx_train = x_train.astype('float32') \/ 255.\nx_test = x_test.astype('float32') \/ 255.\n\nprint (x_train.shape)\nprint (x_test.shape)","3d37d2f8":"latent_dim = 64 \n\nclass Autoencoder(Model):\n  def __init__(self, latent_dim):\n    super(Autoencoder, self).__init__()\n    self.latent_dim = latent_dim   \n    self.encoder = tf.keras.Sequential([\n      layers.Flatten(),\n      layers.Dense(latent_dim, activation='relu'),\n    ])\n    self.decoder = tf.keras.Sequential([\n      layers.Dense(784, activation='sigmoid'),\n      layers.Reshape((28, 28))\n    ])\n\n  def call(self, x):\n    encoded = self.encoder(x)\n    decoded = self.decoder(encoded)\n    return decoded\n  \nautoencoder = Autoencoder(latent_dim) ","0deba85f":"autoencoder.compile(optimizer='adam', loss=losses.MeanSquaredError())","4ffbd59d":"autoencoder.fit(x_train, x_train,\n                epochs=10,\n                shuffle=True,\n                validation_data=(x_test, x_test))","7ee1051f":"encoded_imgs = autoencoder.encoder(x_test).numpy()\ndecoded_imgs = autoencoder.decoder(encoded_imgs).numpy()","01d0a1e5":"n = 10\nplt.figure(figsize=(20, 4))\nfor i in range(n):\n  # display original\n  ax = plt.subplot(2, n, i + 1)\n  plt.imshow(x_test[i])\n  plt.title(\"original\")\n  plt.gray()\n  ax.get_xaxis().set_visible(False)\n  ax.get_yaxis().set_visible(False)\n\n  # display reconstruction\n  ax = plt.subplot(2, n, i + 1 + n)\n  plt.imshow(decoded_imgs[i])\n  plt.title(\"reconstructed\")\n  plt.gray()\n  ax.get_xaxis().set_visible(False)\n  ax.get_yaxis().set_visible(False)\nplt.show()","4b82da26":"(x_train, _), (x_test, _) = fashion_mnist.load_data()","a6495314":"x_train = x_train.astype('float32') \/ 255.\nx_test = x_test.astype('float32') \/ 255.\n\nx_train = x_train[..., tf.newaxis]\nx_test = x_test[..., tf.newaxis]\n\nprint(x_train.shape)","4001c118":"noise_factor = 0.2\nx_train_noisy = x_train + noise_factor * tf.random.normal(shape=x_train.shape) \nx_test_noisy = x_test + noise_factor * tf.random.normal(shape=x_test.shape) \n\nx_train_noisy = tf.clip_by_value(x_train_noisy, clip_value_min=0., clip_value_max=1.)\nx_test_noisy = tf.clip_by_value(x_test_noisy, clip_value_min=0., clip_value_max=1.)","335b3e73":"n = 10\nplt.figure(figsize=(20, 2))\nfor i in range(n):\n    ax = plt.subplot(1, n, i + 1)\n    plt.title(\"original + noise\")\n    plt.imshow(tf.squeeze(x_test_noisy[i]))\n    plt.gray()\nplt.show()","b9305ac3":"class Denoise(Model):\n  def __init__(self):\n    super(Denoise, self).__init__()\n    self.encoder = tf.keras.Sequential([\n      layers.Input(shape=(28, 28, 1)),\n      layers.Conv2D(16, (3, 3), activation='relu', padding='same', strides=2),\n      layers.Conv2D(8, (3, 3), activation='relu', padding='same', strides=2)])\n\n    self.decoder = tf.keras.Sequential([\n      layers.Conv2DTranspose(8, kernel_size=3, strides=2, activation='relu', padding='same'),\n      layers.Conv2DTranspose(16, kernel_size=3, strides=2, activation='relu', padding='same'),\n      layers.Conv2D(1, kernel_size=(3, 3), activation='sigmoid', padding='same')])\n\n  def call(self, x):\n    encoded = self.encoder(x)\n    decoded = self.decoder(encoded)\n    return decoded\n\nautoencoder = Denoise()","06e40f9d":"autoencoder.compile(optimizer='adam', loss=losses.MeanSquaredError())","b999e85a":"autoencoder.fit(x_train_noisy, x_train,\n                epochs=10,\n                shuffle=True,\n                validation_data=(x_test_noisy, x_test))","7d17edd9":"autoencoder.encoder.summary()","bee29e21":"autoencoder.decoder.summary()","74ed636e":"encoded_imgs = autoencoder.encoder(x_test).numpy()\ndecoded_imgs = autoencoder.decoder(encoded_imgs).numpy()","33c86cb1":"n = 10\nplt.figure(figsize=(20, 4))\nfor i in range(n):\n\n    # display original + noise\n    ax = plt.subplot(2, n, i + 1)\n    plt.title(\"original + noise\")\n    plt.imshow(tf.squeeze(x_test_noisy[i]))\n    plt.gray()\n    ax.get_xaxis().set_visible(False)\n    ax.get_yaxis().set_visible(False)\n\n    # display reconstruction\n    bx = plt.subplot(2, n, i + n + 1)\n    plt.title(\"reconstructed\")\n    plt.imshow(tf.squeeze(decoded_imgs[i]))\n    plt.gray()\n    bx.get_xaxis().set_visible(False)\n    bx.get_yaxis().set_visible(False)\nplt.show()","49fb7b11":"Let's take a look at a summary of the encoder. Notice how the images are downsampled from 28x28 to 7x7.","1b137e47":"The decoder upsamples the images back from 7x7 to 28x28.","3b30dc1f":"## Import TensorFlow and other libraries","d54f5caa":"Train the model using `x_train` as both the input and the target. The `encoder` will learn to compress the dataset from 784 dimensions to the latent space, and the `decoder` will learn to reconstruct the original images.\n.","c6e20022":"## Load the dataset\nTo start, you will train the basic autoencoder using the Fashon MNIST dataset. Each image in this dataset is 28x28 pixels. ","bc46a385":"# Use MNIST fashion dataset. Construct an auto encoder model that can compress the given images of MNIST dataset.","adf0b48f":"Now that the model is trained, let's test it by encoding and decoding images from the test set.","52625990":"### Define a convolutional autoencoder","e5dc41dd":"Adding random noise to the images","e2a5292a":"Plot the noisy images.\n","7fb3c70c":"Plotting both the noisy images and the denoised images produced by the autoencoder."}}