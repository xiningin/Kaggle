{"cell_type":{"f8c7032a":"code","7f64fc65":"code","a6032b8f":"code","9150e2dd":"code","f283b511":"code","a3dbee8d":"code","594b63dd":"code","77cd890b":"code","2f6bc853":"code","e7e73af0":"code","ac13f37c":"code","3b83d482":"code","e4b0ef2a":"code","a6da22fc":"code","4f5fe1d6":"code","0a29b710":"code","8906f735":"code","e22d942e":"code","aa511bf9":"code","07e9e7ac":"code","47c560ae":"code","482cb1a1":"code","3b3f41c2":"code","d0a05fd2":"markdown","48d2e552":"markdown","ff6495f1":"markdown"},"source":{"f8c7032a":"import numpy as np \nimport pandas as pd \nimport folium\n\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\nfrom sklearn.cluster import SpectralClustering, DBSCAN, KMeans\nfrom sklearn.decomposition import PCA\nfrom sklearn.metrics import silhouette_score\nfrom sklearn.metrics.pairwise import euclidean_distances\n\nimport networkx as nx\nfrom community import best_partition\n\nimport plotly.offline as py\nimport plotly.graph_objs as go\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nimport os\n\npy.init_notebook_mode(connected=True)","7f64fc65":"df = pd.read_csv(r'..\/input\/likud_new.csv' ,  encoding='latin-1')\ndf.drop('Hebrew Location', axis=1, inplace=True)","a6032b8f":"for col in df.columns[3:]:\n    if df[col].sum() < 1000:\n        df = df.drop(col, axis=1)","9150e2dd":"locations = df['Location']\nlat = df.Lat\nlng = df.Lng\nsizes = df.sum(axis=1)","f283b511":"df.drop(['Location', 'Lat', 'Lng'], axis=1).sum().sort_values(ascending=False)","a3dbee8d":"normalized_df = df.drop(['Location', 'Lat', 'Lng'], axis=1)\nnormalized_df = normalized_df[normalized_df.sum().sort_values(ascending=False).index]\nnormalized_df = normalized_df.truediv(normalized_df.sum(axis=1), axis=0)","594b63dd":"normalized_df = normalized_df.fillna(0)\nplt.figure(figsize=(7, 7))\npca_df = pd.DataFrame(PCA(n_components=2).fit_transform(normalized_df))\npca_df['locations'] = locations\npca_df['sizes'] = sizes\n\nplt.scatter(pca_df[0], pca_df[1], s=50, alpha=0.6)\nplt.xlabel('PC 1')\nplt.ylabel('PC 2')\nplt.show()","77cd890b":"for i in np.arange(1,12):\n    kmeans = KMeans(n_clusters=5).fit(normalized_df)\n    print(i, silhouette_score(normalized_df, kmeans.predict(normalized_df)))","2f6bc853":"kmeans = KMeans(n_clusters=5, random_state=42).fit(normalized_df)\n\npca_df = pd.DataFrame(PCA(n_components=2).fit_transform(normalized_df))\npca_df['label'] = kmeans.predict(normalized_df)\npca_df['locations'] = locations\npca_df['sizes'] = sizes","e7e73af0":"trace1 = go.Bar(\n        x=normalized_df.columns,\n        y=kmeans.cluster_centers_[0],\n        name='Cluster 1'\n        )\n\ntrace2 = go.Bar(\n        x=normalized_df.columns,\n        y=kmeans.cluster_centers_[1],\n        name='Cluster 2'\n        )\n\ntrace3 = go.Bar(\n        x=normalized_df.columns,\n        y=kmeans.cluster_centers_[2],\n        name='Cluster 3'\n        )\n\ntrace4 = go.Bar(\n        x=normalized_df.columns,\n        y=kmeans.cluster_centers_[3],\n        name='Cluster 4'\n        )\n\ntrace5 = go.Bar(\n        x=normalized_df.columns,\n        y=kmeans.cluster_centers_[4],\n        name='Cluster 5'\n        )\n\nlayout = go.Layout(\n     title='<b>Cluster Centers<\/b>',\n     titlefont=dict(size = 30, color='#7f7f7f'),\n     hovermode='closest'\n)\n\nfig = go.Figure(data=[trace1, trace2, trace3, trace4, trace5], layout=layout)\npy.iplot(fig)","ac13f37c":"traces = []\n\nfor label in sorted(pca_df.label.unique()):\n    traces.append(go.Scatter(\n            x=pca_df[pca_df.label == label][0],\n            y=pca_df[pca_df.label == label][1],\n            text=pca_df[pca_df.label == label]['locations'],\n            mode='markers',\n            hoverinfo='text',\n            marker=dict(\n                size=[np.sqrt(a)\/5 for a in (pca_df[pca_df.label == label]['sizes'])],\n                opacity=0.3,\n          )\n           )\n                     )\n    \nlayout = go.Layout(\n        title= 'Likud voting clusters',\n        hovermode='closest',\n        xaxis=dict(\n            autorange=True,\n            showgrid=False,\n            zeroline=False,\n            showline=False,\n            ticks='',\n            showticklabels=False\n        ),\n        yaxis=dict(\n            autorange=True,\n            showgrid=False,\n            zeroline=False,\n            showline=False,\n            ticks='',\n            showticklabels=False\n        ))\nfig = go.Figure(data=traces, layout=layout)\npy.iplot(fig)","3b83d482":"ans = []\nfor i in range(len(df)):    \n    ans.append(list(df.loc[i, df.columns[3:]].transpose().sort_values().index))\n    \npca_df['winners'] = ans\npca_df['winners'] = pca_df.winners.apply(lambda x: x[::-1])\n\npca_df['first'] = pca_df.winners.apply(lambda x: x[0])\npca_df['second'] = pca_df.winners.apply(lambda x: x[1])\npca_df['third'] = pca_df.winners.apply(lambda x: x[2])\npca_df['forth'] = pca_df.winners.apply(lambda x: x[3])\npca_df['lat'] = lat\npca_df['lng'] = lng\npca_df['sizes'] = sizes\npca_df['locations'] = locations\npca_df = pca_df.fillna(0)\npca_df['locations'] = pca_df.locations.apply(lambda x: '' if x == 0 else x)","e4b0ef2a":"\n\nm = folium.Map(location=[32.13,34.8],zoom_start=9, tiles=\"CartoDB dark_matter\" )\n\ncolors = ['blue', 'orange', 'green', 'crimson', 'purple']\nfor row in pca_df.iterrows():\n    folium.Circle(\n              location= (row[1].lat, row[1].lng),    \n              radius=0.3*row[1].sizes,\n              popup= '<b>' + row[1].locations + '<\/b><br>' + row[1]['first'] + '<br>' + row[1]['second'],\n              color=colors[row[1].label],\n              fill=True,\n              fill_color=colors[row[1].label]\n        ).add_to(m)\n    \nm","a6da22fc":"m.save('plot_data.html')\n","4f5fe1d6":"candidates = df.drop(['Location', 'Lat', 'Lng'], axis=1).transpose()\ncandidates = candidates[candidates.transpose().sum(axis=1).sort_values(ascending=False)[:32].index]\ncandidates = candidates.truediv(candidates.sum(axis=0), axis=1)\ncandidates = candidates.fillna(0)","0a29b710":"sizes = candidates.sum(axis=1).values","8906f735":"C=np.corrcoef(candidates.transpose(),rowvar=0)\nA=1*(C>0.4)\nG=nx.Graph(A)\nG=nx.relabel_nodes(G,dict(zip(G.nodes(),candidates.transpose().columns.values)))\ncommunities=best_partition(G)","e22d942e":"community_colors=dict(zip(np.unique(sorted(communities.values())), np.linspace(0, 1, len(np.unique(sorted(communities.values()))))))\nnode_coloring=[community_colors[communities[node]] for node in G.nodes()]\n\nnx.pos=nx.fruchterman_reingold_layout(G, dim=2, k=None, pos=None, fixed=None, iterations=5000, weight='weight', scale=1, center=None)\n\nnx.draw_networkx(G, cmap=plt.get_cmap('jet'), with_labels=True, node_color=node_coloring,font_size=10)\nfig = plt.gcf()\nfig.set_size_inches(18.5, 10.5)\nplt.show()","aa511bf9":"nx.draw_networkx(G, cmap=plt.get_cmap('jet'), with_labels=True, node_color=node_coloring,font_size=10)\nfig = plt.gcf()\nfig.set_size_inches(18.5, 10.5)\nplt.xlim([-0.5, 0.5])\nplt.ylim([-0.5, 0.6])","07e9e7ac":"candidates","47c560ae":"for edge in list(G.edges):\n    print('{ target: \"' +edge[0] + '\" ,source: \"' + edge[1] + '\", strength:  ' + str(candidates.transpose().corr()[edge[0]][edge[1]]) + '},')","482cb1a1":"communities","3b3f41c2":"C=np.corrcoef(candidates.transpose(),rowvar=0)\nA=1*(C>0.4)\nG=nx.Graph(A)\npos=nx.spring_layout(G)#, dim=2, k=None, pos=None, fixed=None, iterations=5000, weight='weight', scale=1, center=None)\nlabels = candidates.transpose().columns.values\nN = len(G.nodes)\nE = G.edges\nXv=[pos[k][0] for k in range(N)]\nYv=[pos[k][1] for k in range(N)]\nXed=[]\nYed=[]\nfor edge in E:\n    Xed+=[pos[edge[0]][0],pos[edge[1]][0], None]\n    Yed+=[pos[edge[0]][1],pos[edge[1]][1], None] \n    \ntrace3=go.Scatter(x=Xed,\n               y=Yed,\n               mode='lines',\n               line=dict(color='rgb(210,210,210)', width=1),\n               hoverinfo='none'\n               )\ntrace4=go.Scatter(x=Xv,\n               y=Yv,\n               mode='markers',\n               name='net',\n               marker=dict(symbol='circle-dot',\n                             size=[40*np.sqrt(x) for x in sizes], \n                             color= node_coloring,\n                            colorscale='Viridis',\n                             line=dict(color='rgb(50,50,50)', width=0.5)\n                             ),\n               text=labels,\n               hoverinfo='text'\n               )\n\n\nlayout = go.Layout(\n    title= 'Zoom in for a better view!',\n        hovermode='closest',\n        xaxis=dict(\n            autorange=True,\n            showgrid=False,\n            zeroline=False,\n            showline=False,\n            ticks='',\n            showticklabels=False\n        ),\n        yaxis=dict(\n            autorange=True,\n            showgrid=False,\n            zeroline=False,\n            showline=False,\n            ticks='',\n            showticklabels=False\n    )\n)\ndata1=[trace3, trace4]\nfig1=go.Figure(data=data1, layout=layout)\n# fig1['layout']['annotations'][0]['text']=annot\npy.iplot(fig1,)","d0a05fd2":"This notebook is pretty much a replica of my previous [notebook](http:\/\/https:\/\/www.kaggle.com\/drgilermo\/clustering-meretz-voters-and-candidates), only this time we'll analyze the Likud party results. \n\nThe likud party is an Israeli conservative\\right wing party, which is also the biggest party in Israel and has been dominated its politics for about two decades. Israel's prime minister, Binyamin Netanyahu, is also the chairman and head of the party.","48d2e552":"Let's drop candidates who got less than 1000 votes:","ff6495f1":"First we shall read the data"}}