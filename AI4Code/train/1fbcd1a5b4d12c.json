{"cell_type":{"0028697c":"code","a7336768":"code","122672b9":"code","005eb32f":"code","d860316f":"code","3878a8a2":"code","0b004942":"code","dee6c547":"code","983d0b22":"code","f20fedaa":"code","110ccc50":"code","0a102cba":"code","4fc8fa60":"code","0959ebb2":"code","4d2dbdcb":"code","e0168ece":"code","2e4cd6f0":"code","7e5afcec":"code","acfcc4f2":"markdown","65a8bd97":"markdown"},"source":{"0028697c":"import sys\nsys.path.append('..\/input\/timmmaster')\nsys.path.append(\"..\/input\/tez-lib\")","a7336768":"import tez\nimport albumentations\nimport pandas as pd\nimport cv2\nimport numpy as np\nimport timm\nimport torch.nn as nn\nfrom sklearn import metrics\nimport torch\nfrom tez.callbacks import EarlyStopping\nfrom tqdm import tqdm\nimport math","122672b9":"class args:\n    batch_size = 16\n    image_size = 384","005eb32f":"def sigmoid(x):\n    return 1 \/ (1 + math.exp(-x))","d860316f":"class PawpularDataset:\n    def __init__(self, image_paths, dense_features, targets, augmentations):\n        self.image_paths = image_paths\n        self.dense_features = dense_features\n        self.targets = targets\n        self.augmentations = augmentations\n        \n    def __len__(self):\n        return len(self.image_paths)\n    \n    def __getitem__(self, item):\n        image = cv2.imread(self.image_paths[item])\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        \n        if self.augmentations is not None:\n            augmented = self.augmentations(image=image)\n            image = augmented[\"image\"]\n            \n        image = np.transpose(image, (2, 0, 1)).astype(np.float32)\n        \n        features = self.dense_features[item, :]\n        targets = self.targets[item]\n        return {\n            \"image\": torch.tensor(image, dtype=torch.float),\n            \"features\": torch.tensor(features, dtype=torch.float),\n            \"targets\": torch.tensor(targets, dtype=torch.float),\n        }\n    \n    \n        \n        \n    ","3878a8a2":"class PawpularModel(tez.Model):\n    def __init__(self,model_name):\n        super().__init__()\n        self.model=timm.create_model(model_name,pretrained=False,in_chans=3)\n        self.model.head=nn.Linear(self.model.head.in_features,128)\n        self.dropout=nn.Dropout(0.1)\n        self.dense1=nn.Linear(140,64)\n        self.dense2=nn.Linear(64,1)\n    def forward(self,image,features,targets=None):\n        x=self.model(image)\n        x=self.dropout(x)\n        x=torch.cat([x,features],dim=1)\n        x=self.dense1(x)\n        x=self.dense2(x)\n        return x,0,{}\n    ","0b004942":"test_aug = albumentations.Compose(\n    [\n        albumentations.Resize(args.image_size, args.image_size, p=1),\n        albumentations.Normalize(\n            mean=[0.485, 0.456, 0.406],\n            std=[0.229, 0.224, 0.225],\n            max_pixel_value=255.0,\n            p=1.0,\n        ),\n    ],\n    p=1.0,\n)","dee6c547":"super_final_predictions=[]\nfor fold_ in range(10):\n    #Intialize the model\n    model = PawpularModel(model_name=\"swin_large_patch4_window12_384\")\n    \n    #load model from path\n    model.load(f\"..\/input\/paw-models\/model_f{fold_}.bin\", device=\"cuda\", weights_only=True)\n    \n    #load test.csv file\n    df_test=pd.read_csv(\"..\/input\/petfinder-pawpularity-score\/test.csv\")\n    #create list of path+image ids from the test csv Ids values\n    test_img_paths=[f\"..\/input\/petfinder-pawpularity-score\/test\/{id_}.jpg\" for id_ in df_test['Id'].values]\n    \n    #create list of dense features\n    dense_features = [\n        'Subject Focus', 'Eyes', 'Face', 'Near', 'Action', 'Accessory',\n        'Group', 'Collage', 'Human', 'Occlusion', 'Info', 'Blur'\n    ]\n        \n    #Create dataset\n    test_dataset=PawpularDataset(\n        image_paths=test_img_paths,\n        dense_features=df_test[dense_features].values,\n        targets=np.ones(len(test_img_paths)),\n        augmentations=test_aug)\n    \n    #run data through model\n    test_predictions=model.predict(test_dataset,batch_size=2*args.batch_size,n_jobs=-1)\n        \n        \n    \n    #put predictions in final_test_predictions list\n    final_test_predictions=[]\n    for preds in tqdm(test_predictions):\n        final_test_predictions.extend(preds.ravel().tolist())\n        \n    #apply sigmoid and multiply by 100 to final_test_predsictions list \n    final_test_predictions=[sigmoid(x)*100 for x in final_test_predictions]\n    super_final_predictions.append(final_test_predictions)\n        \n        \n#add the list to super final predictions list\nsuper_final_predictions = np.mean(np.column_stack(super_final_predictions), axis=1)        \n#take average over all the folds\n    \n        \n\n\n\n","983d0b22":"torch.cuda.empty_cache()","f20fedaa":"import sys\nimport pytorch_lightning as pl\nsys.path.append('..\/input\/timmmaster')\nimport os\nimport json\nimport glob\nimport random\nimport collections\nimport albumentations as A\nimport timm\n\nimport numpy as np\nimport pandas as pd\nimport pydicom\nfrom pydicom.pixel_data_handlers.util import apply_voi_lut\nimport cv2\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport sklearn\nimport torch\npackage_path = \"..\/input\/efficientnet-pytorch\/EfficientNet-PyTorch\/EfficientNet-PyTorch-master\/\"\nimport sys \nsys.path.append(package_path)\nimport glob\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom sklearn.model_selection import StratifiedKFold\n\nimport time\nimport os\nimport torch\nfrom torch import nn\nfrom torch.utils import data as torch_data\nfrom sklearn import model_selection as sk_model_selection\nfrom torch.nn import functional as torch_functional\nimport torch.optim.lr_scheduler as lr_scheduler\n\nfrom sklearn.model_selection import StratifiedKFold\nfrom tqdm import tqdm","110ccc50":"def set_seed(seed):\n    random.seed(seed)\n    os.environ[\"PYTHONHASHSEED\"] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    if torch.cuda.is_available():\n        torch.cuda.manual_seed_all(seed)\n        torch.backends.cudnn.deterministic = True\n\n\nset_seed(42)","0a102cba":"df = pd.read_csv(\"..\/input\/petfinder-pawpularity-score\/train.csv\")\ndense_features = [\n        'Subject Focus', 'Eyes', 'Face', 'Near', 'Action', 'Accessory',\n        'Group', 'Collage', 'Human', 'Occlusion', 'Info', 'Blur'\n    ]\n","4fc8fa60":"import albumentations\ntransform = albumentations.Compose(\n    [\n       \n        albumentations.HueSaturationValue(\n            hue_shift_limit=0.2, sat_shift_limit=0.2, val_shift_limit=0.2, p=0.5\n        ),\n        albumentations.RandomBrightnessContrast(\n            brightness_limit=(-0.1, 0.1), contrast_limit=(-0.1, 0.1), p=0.5\n        ),\n        albumentations.Normalize(\n            mean=[0.485, 0.456, 0.406],\n            std=[0.229, 0.224, 0.225],\n            max_pixel_value=255.0,\n            p=1.0,\n        ),\n    ],\n    p=1.0,\n)\n\nvalid_aug = albumentations.Compose(\n    [\n        albumentations.Normalize(\n            mean=[0.485, 0.456, 0.406],\n            std=[0.229, 0.224, 0.225],\n            max_pixel_value=255.0,\n            p=1.0,\n        ),\n    ],)","0959ebb2":"class DataRetriever(torch_data.Dataset):\n    def __init__(self,ids,targets,train=False,valid=False):\n        self.id=ids\n        self.targets=targets\n        self.train=train\n        self.valid=valid\n        self.alpha=0.2\n        \n    def __len__(self):\n        return len(self.id)\n    def __getitem__(self,index):\n        if self.train or self.valid:\n            img_path='..\/input\/petfinder-pawpularity-score\/train\/'+str(self.id[index])+'.jpg'\n        else:\n            img_path='..\/input\/petfinder-pawpularity-score\/test\/'+str(self.id[index])+'.jpg'\n            \n        if self.targets != None:\n            labels=torch.tensor(self.targets[index],dtype=torch.float)\n        img=cv2.imread(img_path)\n        \n        img=cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n        img=cv2.resize(img,(224,224))\n        \n        if self.train:\n            img=transform(image=img)['image']\n            if index%2!=0:\n                lam=np.random.beta(self.alpha,self.alpha)\n                mixup_index=np.random.randint(0,index)\n                labels2=torch.tensor(self.targets[mixup_index],dtype=torch.float)\n                img_path='..\/input\/petfinder-pawpularity-score\/train\/'+str(self.id[mixup_index])+'.jpg'\n                img2=cv2.imread(img_path)\n                img2=cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n                img2=cv2.resize(img,(224,224))\n                img=lam*img+(1-lam)*img2\n                labels=lam*labels+(1-lam)*labels2\n        else:\n            img=valid_aug(image=img)['image']\n      \n        img=np.transpose(img,(2,0,1)).astype(np.float32)\n        if self.train or self.valid:\n            return {\n            'X':torch.tensor(img,dtype=torch.float),   \n            'y':labels\n          }\n        return{'X':torch.tensor(img,dtype=torch.float)} ","4d2dbdcb":"class PawpularityModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.model = timm.create_model('swin_large_patch4_window7_224_in22k', pretrained=False, in_chans=3)\n        #self.model.classifier = nn.Linear(self.model.classifier.in_features, 128)\n        self.dropout = nn.Dropout(0.1)\n        self.dense1 = nn.Linear(128, 1)\n        #self.dense2 = nn.Linear(64, 1)\n        self.model.head=nn.Linear(self.model.head.in_features,128)\n        #self.model.fc = nn.Linear(self.model.fc.in_features, 128)\n        \n    def forward(self,x):\n        output=self.model(x)\n        #print(output.shape)\n        output=self.dropout(output)\n        #print(output.shape)\n        #output=torch.cat([output,dense_features],dim=1)\n        output=self.dense1(output)\n        #print(output.shape)\n        #output=self.dense2(output)\n       # output=torch.sigmoid(output)       \n        return output\n    \n","e0168ece":"submission = pd.read_csv(\"..\/input\/petfinder-pawpularity-score\/sample_submission.csv\")\nmodel=PawpularityModel()\ntest=pd.read_csv(\"..\/input\/petfinder-pawpularity-score\/test.csv\")\nmodel.to('cuda')\ndevice='cuda'\ntest_data_retriever = DataRetriever(\n    submission.Id.values,None,train=False,\n    valid=False\n)\n\ntest_loader = torch_data.DataLoader(\n    test_data_retriever,\n    batch_size=64,\n    shuffle=False,\n    num_workers=8,\n)","2e4cd6f0":"ids = []\npaths=[]\npred=[]\nfor path in os.listdir('..\/input\/pet-paw-data'):\n    paths.append('..\/input\/pet-paw-data\/'+path)\n\nfor path in paths:\n    y_pred = []\n    model.load_state_dict(torch.load(path))\n    for e, batch in enumerate(test_loader):\n        print(f\"{e}\/{len(test_loader)}\", end=\"\\r\")\n        with torch.no_grad():\n            tmp_pred = np.zeros((batch[\"X\"].shape[0], ))\n\n            tmp_pred=model(batch['X'].to(device)).cpu().numpy().squeeze()\n            #print(tmp_pred)\n            tmp_pred=1\/(1+np.exp(-tmp_pred))\n           # print(tmp_pred)\n            \n            y_pred.extend(tmp_pred)\n    y_pred=[x*100 for x in y_pred]\n    pred.append(y_pred)\n    \npred=np.mean(np.column_stack(pred), axis=1)    ","7e5afcec":"df_test['Pawpularity']=(pred+super_final_predictions)\/2\ndf_test=df_test[['Id','Pawpularity']]\ndf_test\ndf_test.to_csv(\"submission.csv\", index=False)   \ndf_test","acfcc4f2":"# Mycode","65a8bd97":"# Dataset"}}