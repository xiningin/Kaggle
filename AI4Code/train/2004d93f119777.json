{"cell_type":{"b5d79961":"code","86da2a7f":"code","daeab36c":"code","71383760":"code","b53c9dc5":"code","3a983002":"code","02f09a85":"code","2d0ba462":"code","7290f32a":"code","2bb77bb8":"code","58d77368":"markdown","e25f84ae":"markdown","7eeb3d34":"markdown","da9316c1":"markdown","3732cd36":"markdown","78a4bab0":"markdown","767e787a":"markdown"},"source":{"b5d79961":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","86da2a7f":"!pip install keras","daeab36c":"import tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Conv2D,MaxPool2D,Flatten,Dense","71383760":"datagen = ImageDataGenerator(rescale=1.\/255)","b53c9dc5":"train_data = datagen.flow_from_directory('..\/input\/chest-xray-pneumoniacovid19tuberculosis\/train', class_mode='categorical', batch_size=32,target_size=(150, 150))\nval_data = datagen.flow_from_directory('..\/input\/chest-xray-pneumoniacovid19tuberculosis\/val', class_mode='categorical', batch_size=32,target_size=(150, 150))\ntest_data = datagen.flow_from_directory('..\/input\/chest-xray-pneumoniacovid19tuberculosis\/test', class_mode='categorical', batch_size=32,target_size=(150, 150))","3a983002":"model= Sequential()\nmodel.add(Conv2D(kernel_size=(3,3), filters=32, activation='relu', input_shape=(150,150,3,)))\nmodel.add(Conv2D(filters=30,kernel_size = (3,3),activation='relu'))\nmodel.add(MaxPool2D(2,2))\nmodel.add(Conv2D(filters=30,kernel_size = (3,3),activation='relu'))\nmodel.add(MaxPool2D(2,2))\nmodel.add(Conv2D(filters=30,kernel_size = (3,3),activation='relu'))\n\nmodel.add(Flatten())\n\nmodel.add(Dense(20,activation='relu'))\nmodel.add(Dense(15,activation='relu'))\nmodel.add(Dense(4,activation = 'softmax'))\n\nmodel.compile(\n              loss='categorical_crossentropy', \n              metrics=['acc'],\n              optimizer='adam'\n             )","02f09a85":"history = model.fit_generator(train_data, steps_per_epoch=20, validation_data=val_data, validation_steps=2,epochs=12)","2d0ba462":"print(history.history.keys())","7290f32a":"acc = history.history['acc']\nval_acc = history.history['val_acc']\nloss = history.history['loss']\nval_loss = history.history['val_loss']\nepochs = range(len(acc))","2bb77bb8":"import matplotlib.pyplot as plt\nplt.plot(epochs,acc,'g',label='D')\nplt.plot(epochs,val_acc,'b',label='D')\nplt.title('ss')\nplt.legend()\nplt.figure()\nplt.plot(epochs,loss,'g',label='D')\nplt.plot(epochs,val_loss,'b',label='D')\nplt.title('ss')\nplt.legend()\nplt.figure()\nplt.show()","58d77368":"# Work in progress...","e25f84ae":"now we will create 3 sets: training, test and validation.\n1. at the beginning we give the path to the folder\n2. class_mode='' - we can choose the following parameters:\n* **categorical** - 2D output (aka. list of numbers of length N), [0, 0, 1, 0], which is a one-hot encoding (only one number is 1\/ \"hot\") representing the donkey. This is for mutually exclusive labels. A dog cannot be a cat, a human is not a dog.\n* **binary** - 1D output (aka. 1 number), which is either 0, 1, 2, 3 ... N. It is called this because it is binary if there are only two classes (IMHO this is a bad reason), source. I suggest using \"binary\" just for single label classification, because it documents-in-code, your intention.\n* **sparse** - After digging in the code, this is the same as \"binary\". The logic is done with elif self.class_mode in {'binary', 'sparse'}:, and the class_mode is not used after that. I suggest using \"sparse\" for multilabel classification though, again because it documents-in-code, your intention.\n* **input** -  The label is literally the image again. So the label for an image of the dog, is the same dog picture array. If I knew more about autoencoders I might have been able to explain further.\n* **None** - No labels, therefore not useful for training, but for inference\/ prediction.\n3. batch_size - it refers to the number of training examples utilized in one iteration\n4. target_size - in this example, it changes the resolution of the image to 150x150","7eeb3d34":"if you want to know more about datagen.flow_from_directory :\n* https:\/\/keras.io\/api\/preprocessing\/image\/","da9316c1":"Line below (rescale = 1.\/255) transforms every pixel value from range [0-225] to [0-1]","3732cd36":"Importing packages","78a4bab0":"![Przechwytywanie.PNG](attachment:c9db96c2-7967-4be9-b743-e0fc5dc7cc8d.PNG)","767e787a":"Creating some visualizations"}}