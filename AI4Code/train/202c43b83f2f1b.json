{"cell_type":{"69c950a3":"code","6dfb4c13":"code","8ed7e472":"code","e24a6b37":"code","58fd9721":"code","5f899fa0":"code","31b74a32":"code","9cefcb86":"markdown","ec561042":"markdown","81206b8f":"markdown","f79874fc":"markdown","95922004":"markdown","7e5e1cb5":"markdown"},"source":{"69c950a3":"import os\nfrom nltk.parse import malt\nos.listdir('\/kaggle\/input')","6dfb4c13":"import pandas as pd\ndf = pd.read_csv('\/kaggle\/input\/gendered-pronoun-resolution\/test_stage_1.tsv', delimiter='\\t')\ndf.head()","8ed7e472":"from nltk.parse import malt\nimport os\nos.listdir('\/kaggle\/input')\nos.environ['MALT_PARSER'] = '\/kaggle\/input\/maltparser19'\nos.environ['MALT_MODEL'] = '\/kaggle\/input\/maltparser19\/engmalt.linear-1.7.mco'\n","e24a6b37":"mp = malt.MaltParser( '\/kaggle\/input', 'engmalt.linear-1.7.mco') \ntree = mp.parse_one(df.iloc[0].Text.split())\ntree","58fd9721":"from nltk.tree import Tree\nmax_depth = 32\ndef findintree(t,d=0):\n    for i in range(len(t)):\n        if d<max_depth:\n            if type(t[i]) is Tree:\n                findintree(t[i],d+1)\n            else:\n                print(d,i,str(t[i]))\nfindintree(tree.tree())","5f899fa0":"max_path_len = 16\ndef search_path_for_leaf(t,kw,path,d=0):\n    for i in range(len(t)):\n        if d<max_depth:\n            if type(t[i]) is Tree:\n                for p in path.keys():\n                    path[p] += 1\n                search_path_for_leaf(t[i],kw,path,d+1)\n            else:\n                for k in kw:\n                    if k in str(t[i]):\n                        if k not in path.keys():\n                            path[k] = 0\n                        for p in list(path.keys()):\n                            path[p+'-'+k] = 0\n                            links = p.split('-')\n                            last = links[-1]\n                            bef_key = last+'-'+k\n                            if bef_key in path.keys():\n                                path[bef_key] = min(path[bef_key], path[p])\n                            else:\n                                path[bef_key] = path[p]\ndef get_score_index( index ):\n    tree = mp.parse_one(df.iloc[index].Text.split())\n    path = {}\n    ap = df.iloc[index].A.split()\n    bp = df.iloc[index].B.split()\n    p = df.iloc[index].Pronoun.split()\n    keywords = ap + bp + p\n    search_path_for_leaf(tree.tree(),keywords,path)\n    score_A = max_depth\n    score_B = max_depth\n    score_N = max_depth\n    for _p in p:\n        for _ap in ap:\n            if _ap+'-'+_p in path.keys():\n                score_A = min(score_A,path[_ap+'-'+_p])\n            elif _p+'-'+_ap in path.keys():\n                score_A = min(score_A,path[_p+'-'+_ap])\n        for _bp in bp:\n            if _bp+'-'+_p in path.keys():\n                score_B = min(score_B,path[_bp+'-'+_p])\n            elif _p+'-'+_bp in path.keys():\n                score_B = min(score_B,path[_p+'-'+_bp])\n    if max_path_len <= score_A and max_path_len <= score_B:\n        score_A = 0.\n        score_B = 0.\n        score_N = 1.\n    elif score_A == score_B:\n        score_A = 0.5\n        score_B = 0.5\n        score_N = 0.\n    elif score_A <= max_path_len:\n        score_A = 0.\n        score_B = 1.\n        score_N = 0.\n    elif score_B <= max_path_len:\n        score_A = 1.\n        score_B = 0.\n        score_N = 0.\n    else:\n        _score_A = max_depth \/ score_A\n        score_B = max_depth \/ score_B\n        score_A = _score_A\n        score_N = 0.\n    return score_A, score_B, score_N\nprint(df.iloc[0].A,'-',df.iloc[0].B,get_score_index(0))\nprint(df.iloc[1].A,'-',df.iloc[1].B,get_score_index(1))\nprint(df.iloc[2].A,'-',df.iloc[2].B,get_score_index(2))\nprint(df.iloc[3].A,'-',df.iloc[3].B,get_score_index(3))\nprint(df.iloc[4].A,'-',df.iloc[4].B,get_score_index(4))","31b74a32":"from multiprocessing import Pool\ndef multi_get_score(index):\n    return index, get_score_index(index)\nwith Pool(4) as p:\n    result = p.map(multi_get_score, list(range(len(df))))\ndst = np.zeros((len(df),3))\nfor index, t in result:\n    dst[index][0] = t[0]\n    dst[index][1] = t[1]\n    dst[index][2] = t[2]\nwith open('submission.csv','w') as f:\n    f.write('ID,A,B,NEITHER\\n')\n    for idx in range(len(df)):\n        f.write('%s,%f,%f,%f\\n'%(df.iloc[idx].ID,dst[idx][0],dst[idx][1],dst[idx][2]))\nprint('done')","9cefcb86":"**Read MaltParser Model**\n\nNote: MaltParser use Java Runtime.\nso we need maltparser-*.jar, lib\/liblinear-1.8,jar, lib\/libsvm.jar, lib\/log4j.jar files.","ec561042":"**Make Submission**","81206b8f":"**Testing Build Tree**","f79874fc":"**Read data**","95922004":"**Testing tree leafs**","7e5e1cb5":"**Make submission score from leaf-to-leaf path length**\n\nIf leaf contains a word from keyword (AorB), we will ask for the leaf's path and the shorter one will be the bigger score."}}