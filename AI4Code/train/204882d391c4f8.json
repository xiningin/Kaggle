{"cell_type":{"1b939003":"code","12517781":"code","9308022e":"markdown"},"source":{"1b939003":"# Install pytorchcv\n!pip install ..\/input\/pytorchcv\/pytorchcv-0.0.55-py2.py3-none-any.whl --quiet","12517781":"import os\nimport sys\nimport numpy as np\nimport pandas as pd\nimport cv2\nfrom tqdm import tqdm\nfrom timeit import default_timer as timer\nimport skimage.io\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.utils.data.dataset import Dataset\nfrom torch.utils.data import DataLoader\nfrom torch.utils.data.sampler import *\n\nif True:\n    DATA_DIR = '\/kaggle\/input\/prostate-cancer-grade-assessment\/'\n    SUBMISSION_CSV_FILE = 'submission.csv'\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\n#### net #########################################################################\n\ndef do_predict(net, inputs):\n    def logit_to_probability(logit):\n        probability=[]\n        for l in logit:\n            p = F.softmax(l)\n            probability.append(p)\n        return probability\n    \n    num_ensemble = len(net)\n    for i in range(num_ensemble):\n        net[i].eval()\n\n    probability=[0,0,0,0]\n    for i in range(num_ensemble):\n        logit = net[i](inputs)\n        prob = logit_to_probability(logit)\n        probability = [p+q for p,q in zip(probability,prob)]\n    \n    #----\n    probability = [p\/num_ensemble for p in probability]\n    predict = [torch.argmax(p,-1) for p in probability]\n    predict = [p.data.cpu().numpy() for p in predict]\n    predict = np.array(predict).T\n    predict = predict.reshape(-1)\n\n    return predict\n\n## load net -----------------------------------\n\nfrom pytorchcv.model_provider import get_model\n\nclass Head(torch.nn.Module):\n  def __init__(self, in_f, out_f, dropout):\n    super(Head, self).__init__()\n    \n    self.f = nn.Flatten()\n    self.d = nn.Dropout(0.25)\n    self.dropout = dropout\n    self.o = nn.Linear(in_f, out_f)\n\n  def forward(self, x):\n    x = self.f(x)\n    if self.dropout:\n      x = self.d(x)\n\n    out = self.o(x)\n    return out\n\nclass FCN(torch.nn.Module):\n  def __init__(self, base, in_f, num_classes, dropout=True):\n    super(FCN, self).__init__()\n    self.base = base\n    self.h1 = Head(in_f, num_classes, dropout)\n  \n  def forward(self, x):\n    x = self.base(x)\n    return self.h1(x)\n\ndef create_model():\n    model = get_model(\"seresnext50_32x4d\", pretrained=False)\n    model.load_state_dict(torch.load('..\/input\/seresnext50-32x4d-pretrained\/seresnext50_32x4d-0521-b0ce2520.pth'))\n    model = nn.Sequential(*list(model.children())[:-1]) # Remove original output layer\n    model[0].final_pool = nn.Sequential(nn.AdaptiveAvgPool2d(1))\n    model = FCN(model, 2048, 6, dropout=True)\n    return model\n\n#----------------------------------------------\nnet = []\n\nmodel = create_model()\nmodel = model.cuda()\nstate = torch.load('..\/input\/panda-5fold-702\/model-fld1.pth') # .\nmodel.load_state_dict(state)\nnet.append(model)\n\nmodel = create_model()\nmodel = model.cuda()\nstate = torch.load('..\/input\/panda-5fold-702\/model-fld2.pth') # .\nmodel.load_state_dict(state)\nnet.append(model)\n\nmodel = create_model()\nmodel = model.cuda()\nstate = torch.load('..\/input\/panda-5fold-702\/model-fld3.pth') # .\nmodel.load_state_dict(state)\nnet.append(model)\n\nmodel = create_model()\nmodel = model.cuda()\nstate = torch.load('..\/input\/panda-5fold-702\/model-fld4.pth') # .\nmodel.load_state_dict(state)\nnet.append(model)\n\nmodel = create_model()\nmodel = model.cuda()\nstate = torch.load('..\/input\/panda-5fold-702\/model-fld5.pth') # .\nmodel.load_state_dict(state)\nnet.append(model)\n\n#------------------------------------------\n\n# Use this to test inference\ntrain = pd.read_csv(f'{DATA_DIR}train.csv')[:1000]\n# submission = train\n\nsubmission = pd.read_csv(f'{DATA_DIR}sample_submission.csv')\n\nWIDTH = 512\nHEIGHT = 512\n\nfrom torch.utils.data import Dataset, DataLoader\nfrom PIL import Image\n\nclass ImageDataset(Dataset):\n    def __init__(self, dataframe, root_dir, transform=None):\n        self.df = dataframe\n        self.root_dir = root_dir\n        self.transform = transform\n\n        self.paths = self.df.image_id.values\n\n    def __len__(self):\n        return len(self.df)\n    \n    def __getitem__(self, idx):\n        img_name = self.paths[idx]\n        file_path = f'{self.root_dir}{img_name}.tiff'\n        \n        image = skimage.io.MultiImage(file_path)\n        image = cv2.resize(image[-1], (WIDTH, HEIGHT), interpolation=cv2.INTER_AREA)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        image = (255 - image).astype(np.float32) \/ 255.\n        \n        if self.transform is not None:\n          image = self.transform(image=image)['image']\n        \n        image = np.rollaxis(image, -1, 0)\n        \n        return image\n#---------------------------------------------\n\ndef run_make_submission_csv():\n    target=[]\n    batch_size= 4\n\n    if os.path.exists('..\/input\/prostate-cancer-grade-assessment\/test_images'):\n    # Use below lines to test inference\n#     if True:\n#         test_dataset = ImageDataset(train, f'{DATA_DIR}train_images\/', None)\n        test_dataset = ImageDataset(submission, f'{DATA_DIR}test_images\/', None)\n        test_loader = DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=False, num_workers=4)\n        \n        t = tqdm(test_loader)\n        with torch.no_grad():\n            for b, image_batch in enumerate(t):\n                image_batch = image_batch.cuda().float()\n                predict = do_predict(net, image_batch)\n                target.append(predict)\n        print('')\n    #---------\n    else:\n        target = [[1],[1],[1]]\n    target = np.concatenate(target)\n\n    submission['isup_grade'] = target\n    submission['isup_grade'] = submission['isup_grade'].astype(int)\n    submission.to_csv(SUBMISSION_CSV_FILE, index=False)\n    print(submission.head())\n\nif __name__ == '__main__':\n    run_make_submission_csv()\n\n    print('\\nsucess!')","9308022e":"# Inference for SeResNeXt-50 baseline classifier\n\n## View this kernal for training: https:\/\/www.kaggle.com\/greatgamedota\/panda-baseline-classifier-5fold-inference"}}