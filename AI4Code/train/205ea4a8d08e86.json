{"cell_type":{"b2a5d5a3":"code","857b0542":"code","8a8944f3":"code","5bfd48ff":"code","24cdd8ab":"code","6f64879f":"code","c5a92564":"code","fffd268c":"code","8a4d3103":"code","1b174e90":"code","8a52591d":"code","64777c54":"code","7ee9bf6d":"code","f90b6147":"code","ed77564c":"code","8ec1c3a5":"code","a04b0980":"code","77184581":"code","683b1aec":"code","39c80042":"code","9e0b62dd":"code","25d7ec20":"code","964d83c8":"code","cc9cf78c":"code","b9a73c5c":"code","407f26ad":"code","1bd130f8":"code","37c3cdf3":"code","bf02e63b":"code","0248c677":"code","122b72f6":"markdown","651313b1":"markdown","2369a76b":"markdown","7ee39c75":"markdown","904033a1":"markdown","4c8333ab":"markdown","1d74f122":"markdown","d8f0180d":"markdown","3ccf5f49":"markdown"},"source":{"b2a5d5a3":"import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom pylab import rcParams\nfrom sklearn.preprocessing import LabelEncoder, StandardScaler\n\n%matplotlib inline\n\nsns.set(style='whitegrid', palette='muted', font_scale=1.5)\n\nrcParams['figure.figsize'] = 14, 8\n\nRANDOM_SEED = 42\nLABELS = [\"Normal\", \"Fraud\"]","857b0542":"df = pd.read_csv(\"..\/input\/creditcardfraud\/creditcard.csv\")","8a8944f3":"df.shape","5bfd48ff":"pd.value_counts(df['Class'], sort = True)","24cdd8ab":"frauds = df[df.Class == 1]\nnormal = df[df.Class == 0]","6f64879f":"frauds.Amount.describe()","c5a92564":"normal.Amount.describe()","fffd268c":"data = df.drop(['Time'], axis=1)","8a4d3103":"data.shape","1b174e90":"from sklearn.preprocessing import StandardScaler\n\ndata['Amount'] = StandardScaler().fit_transform(data['Amount'].values.reshape(-1, 1))","8a52591d":"data.shape","64777c54":"from sklearn.model_selection import train_test_split\nX_train, X_test = train_test_split(data, test_size=0.2, random_state=RANDOM_SEED)","7ee9bf6d":"X_train = X_train[X_train.Class == 0]\nX_train = X_train.drop(['Class'], axis=1)\n\ny_test = X_test['Class']\nX_test = X_test.drop(['Class'], axis=1)\n\nX_train = X_train.values\nX_test = X_test.values","f90b6147":"X_train.shape","ed77564c":"X_train.shape[1]","8ec1c3a5":"input_dim = X_train.shape[1]\nencoding_dim = 14\nbatch_size = 30","a04b0980":"import torch\nimport torchvision as tv\nimport torchvision.transforms as transforms\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.autograd import Variable","77184581":"input_neurons = input_dim\nhidden_neurons = encoding_dim\n# create our network\nclass AutoEncoder(torch.nn.Module):\n    def __init__(self):\n        super(AutoEncoder, self).__init__()\n        self.input = nn.Linear(input_neurons,encoding_dim)\n        self.tanh=nn.Tanh()\n        self.relu=nn.ReLU()\n        self.fc1=nn.Linear(encoding_dim,int(encoding_dim \/ 2))\n        self.fc2=nn.Linear(int(encoding_dim \/ 2),int(encoding_dim \/ 2))\n        self.fc3=nn.Linear(int(encoding_dim \/ 2),encoding_dim)\n        self.fc4=nn.Linear(encoding_dim,input_neurons)\n    def forward(self, x):\n        x = self.input(x)\n        x = self.tanh(self.fc1(x))\n        x = self.relu(self.fc2(x))\n        x = self.tanh(self.fc3(x))\n        x = self.relu(self.fc4(x))\n        return x\n\nencoder = AutoEncoder()\noptimizer = torch.optim.Adam(encoder.parameters(), lr=0.01)\nloss_fn = nn.MSELoss() ","683b1aec":"num_epochs = 300 #you can go for more epochs, I am using a mac","39c80042":"encoder.train()\ntensor_data = torch.from_numpy(X_train).to(torch.float32)\nfor epoch in range(num_epochs):\n    pred_data = encoder(tensor_data)\n    optimizer.zero_grad()\n    loss = loss_fn(pred_data, tensor_data)\n    loss.backward()\n    optimizer.step()\n    print(\"Epoch %s \\t%s\"%(epoch+1, loss.item()))","9e0b62dd":"predictions = encoder(torch.from_numpy(X_test).to(torch.float32))","25d7ec20":"pred=predictions.detach().numpy()","964d83c8":"import numpy as np\nmse = np.mean(np.power(X_test - pred, 2), axis=1)\nerror_df = pd.DataFrame({'reconstruction_error': mse,\n                        'true_class': y_test})","cc9cf78c":"error_df.describe()","b9a73c5c":"fig = plt.figure()\nax = fig.add_subplot(111)\nnormal_error_df = error_df[(error_df['true_class']== 0) & (error_df['reconstruction_error'] < 10)]\n_ = ax.hist(normal_error_df.reconstruction_error.values, bins=10)","407f26ad":"fig = plt.figure()\nax = fig.add_subplot(111)\nfraud_error_df = error_df[error_df['true_class'] == 1]\n_ = ax.hist(fraud_error_df.reconstruction_error.values, bins=10)","1bd130f8":"threshold = 3","37c3cdf3":"from sklearn.metrics import (confusion_matrix, precision_recall_curve, auc,\n                             roc_curve, recall_score, classification_report, f1_score,\n                             precision_recall_fscore_support)","bf02e63b":"groups = error_df.groupby('true_class')\nfig, ax = plt.subplots()\n\nfor name, group in groups:\n    ax.plot(group.index, group.reconstruction_error, marker='o', ms=3.5, linestyle='',\n            label= \"Fraud\" if name == 1 else \"Normal\")\nax.hlines(threshold, ax.get_xlim()[0], ax.get_xlim()[1], colors=\"r\", zorder=100, label='Threshold')\nax.legend()\nplt.title(\"Reconstruction error for different classes\")\nplt.ylabel(\"Reconstruction error\")\nplt.xlabel(\"Data point index\")\nplt.show();","0248c677":"y_pred = [1 if e > threshold else 0 for e in error_df.reconstruction_error.values]\nconf_matrix = confusion_matrix(error_df.true_class, y_pred)\n\nplt.figure(figsize=(12, 12))\nsns.heatmap(conf_matrix, xticklabels=LABELS, yticklabels=LABELS, annot=True, fmt=\"d\");\nplt.title(\"Confusion matrix\")\nplt.ylabel('True class')\nplt.xlabel('Predicted class')\nplt.show()","122b72f6":"### Normalizing","651313b1":"### Reconstruction error for fraud data","2369a76b":"### Reconstruction error for non fraud data","7ee39c75":"### EDA","904033a1":"### Attempting credit card fraud detection using auto-encoders","4c8333ab":"#### We are able to predict a decent no of frauds with this approach","1d74f122":"### Setting a threshold based on the above analysis","d8f0180d":"### Defining the model","3ccf5f49":"### Getting the Reconstruction Error"}}