{"cell_type":{"dd7de0ce":"code","b9fd369c":"code","28d68d1e":"code","4f301a27":"code","9592965c":"code","8f424543":"code","d67495d4":"code","a41b2325":"code","fffcb556":"code","d88f7e81":"code","a58dda91":"code","b9a23313":"code","9c84ec06":"code","d97d244e":"code","7b5f9343":"code","ca0cabd9":"code","0cf96df7":"code","2dffe1ad":"code","e96da184":"code","0b1cfd27":"code","ce3435ad":"code","463a5e04":"code","b1b0d0a0":"code","0182e562":"code","d7031fc4":"code","83bb5830":"code","7215003a":"code","d30d7d20":"code","9cea43cd":"code","28dc03a9":"code","4c1832bf":"code","2c1c9a19":"code","cc57179b":"code","c9277980":"code","d8e3bcf8":"code","bd6dd52b":"code","21acffa5":"code","998d8e70":"code","2bcf8210":"code","95017085":"code","91e3818e":"code","7007415a":"code","be46cc98":"code","2eab802b":"code","12a122ee":"code","7f0796c1":"code","a162f4cb":"code","ed65a226":"code","3dc14f5d":"code","f28ca77f":"code","2ae85c36":"code","06ef6017":"code","8a0a9799":"code","9ee0871e":"code","bb0fbb59":"code","6569c0f3":"code","7402530e":"code","340b4ce5":"code","8a2eb1fa":"code","fa24663d":"code","57c807c9":"code","ea78318c":"code","7dfabfae":"code","d1fddeb2":"code","41417e27":"code","eddc4bc9":"code","df16ecc4":"code","40fadaf1":"code","8d33dc4f":"code","da0685d1":"code","80f92525":"code","06e38409":"code","e729571e":"markdown","79d523e7":"markdown","bc50642d":"markdown","3870f151":"markdown","aeee1b73":"markdown","18007dda":"markdown","9d89e95a":"markdown","fc8edb46":"markdown","47637a17":"markdown","cb582b7a":"markdown","fc23f43e":"markdown","d63728f3":"markdown","5706eecd":"markdown","8efcfc06":"markdown","ba7b9aed":"markdown","32d357e3":"markdown","14149965":"markdown","1cfba1a5":"markdown","a37c0c6a":"markdown","cead5163":"markdown","37e5af5f":"markdown","6d801f82":"markdown","3710dfea":"markdown","0147a961":"markdown","4cae9f66":"markdown","c0d0dfc9":"markdown","81b14e33":"markdown","dd8c90a8":"markdown","710681bc":"markdown","4fd9c4b9":"markdown","ab238d26":"markdown","5c7ff185":"markdown","15acc61a":"markdown","3422d833":"markdown","77de85d1":"markdown","45e0916d":"markdown","6c1c414d":"markdown","f3545a8b":"markdown","d58f201e":"markdown","e56048a0":"markdown","8ab71fd6":"markdown","a7d61e5e":"markdown","55321146":"markdown","65b13d78":"markdown","d82870ca":"markdown","71adabee":"markdown","40c6524a":"markdown","0b998a5d":"markdown","c32b89c7":"markdown","2a295342":"markdown","438793ba":"markdown","c8b8fe82":"markdown","d5bc2a6a":"markdown","3df8d487":"markdown","e836c9ed":"markdown"},"source":{"dd7de0ce":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport seaborn as sns\nfrom scipy.stats.mstats import gmean\nimport math\nfrom scipy.stats.stats import pearsonr\n#from geopandas.tools import sjoin\nfrom sklearn import metrics\nimport folium\nfrom folium.plugins import MarkerCluster\nfrom folium import IFrame\nimport shapely\nfrom shapely.geometry import Point, Polygon\nimport unicodedata\nimport pysal as ps\nimport geopandas as gpd\nfrom mpl_toolkits.basemap import Basemap\nimport geojson\n\n%matplotlib inline\n\nsns.set(rc={\"figure.figsize\": (20,10), \"axes.titlesize\" : 18, \"axes.labelsize\" : 12, \n            \"xtick.labelsize\" : 14, \"ytick.labelsize\" : 14 }, \n        palette=sns.color_palette(\"OrRd_d\", 20))\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\n!cp ..\/input\/images\/kenya_county_mpi_loans.png .","b9fd369c":"def preprocess_dhs_data(country, household_file, househole_member_file, births_file, cluster_file):\n    # Load original DHS data \n    # The following error occurrs if we do not set convert_categoricals=False: ValueError: Categorical categories must be unique\n    household_dhs_df = pd.read_stata('..\/input\/'+country+'-dhs-household\/'+household_file, convert_categoricals=False)\n    household_member_dhs_df = pd.read_stata('..\/input\/'+country+'-dhs-household-member\/'+househole_member_file, convert_categoricals=False)\n    births_dhs_df = pd.read_stata('..\/input\/'+country+'-dhs-births\/'+births_file, convert_categoricals=False)\n    dhs_cluster_df = pd.read_csv('..\/input\/'+country+'-dhs-cluster\/'+cluster_file)\n\n    # Keep only relevant features from each dataset\n    household_dhs_df = household_dhs_df[['hv001', 'hv002', 'hv009', 'hv010',  'hv011',  'hv012',  'hv014',  \n                                         'hv024',  'hv025', 'hv027',\n                                         'hv206','hv201','hv204','hv205','hv225', 'hv226','hv213',\n                                         'hv207', 'hv208', 'hv243a', 'hv221',\n                                        'hv210', 'hv211', 'hv212', 'hv243c', 'hv243d',\n                                         'hv209', 'hv244', 'hv245', 'hv246', \n                                         'hv247']]\n    household_member_dhs_df = household_member_dhs_df[['hv001', 'hv002', 'hc31', 'hc70', 'hc73', 'hc2', 'hc3','ha1', \n                                                       'ha40', 'hv105', 'hv108', 'hv121']]\n    births_dhs_df = births_dhs_df[['v001', 'v002',  'b2', 'b3', 'b5', 'b7']]\n\n    # Save the resulting dataframes\n    household_dhs_df.to_csv(country+'_household_dhs.csv', index = False)\n    household_member_dhs_df.to_csv(country+'_household_member_dhs.csv', index = False)\n    births_dhs_df.to_csv(country+'_births_dhs.csv', index = False)\n\n    # DHS Cluster data preprocessing\n    # drop irrelevant columns\n    dhs_cluster_df.drop(columns=['GPS_Dataset', 'DHSCC', 'DHSYEAR', 'SurveyID'], inplace=True)\n    dhs_cluster_df = dhs_cluster_df[dhs_cluster_df.columns.drop(list(dhs_cluster_df.filter(regex='1985')))]\n    dhs_cluster_df = dhs_cluster_df[dhs_cluster_df.columns.drop(list(dhs_cluster_df.filter(regex='1990')))]\n    dhs_cluster_df = dhs_cluster_df[dhs_cluster_df.columns.drop(list(dhs_cluster_df.filter(regex='1995')))]\n    dhs_cluster_df = dhs_cluster_df[dhs_cluster_df.columns.drop(list(dhs_cluster_df.filter(regex='2000')))]\n    dhs_cluster_df = dhs_cluster_df[dhs_cluster_df.columns.drop(list(dhs_cluster_df.filter(regex='2005')))]\n    dhs_cluster_df = dhs_cluster_df[dhs_cluster_df.columns.drop(list(dhs_cluster_df.filter(regex='UN_Population')))]\n    dhs_cluster_df = dhs_cluster_df[dhs_cluster_df.columns.drop(list(dhs_cluster_df.filter(regex='SMOD')))]\n    dhs_cluster_df = dhs_cluster_df[dhs_cluster_df.columns.drop(list(dhs_cluster_df.filter(regex='Slope')))]\n    dhs_cluster_df = dhs_cluster_df[dhs_cluster_df.columns.drop(list(dhs_cluster_df.filter(regex='Temperature')))]\n    dhs_cluster_df.to_csv(country+'_dhs_cluster.csv', index = False)\n\n# Uncomment the line below to run pre-processing of original DHS files\n#preprocess_dhs_data('kenya', 'KEHR71FL.DTA', 'KEPR71FL.DTA', 'KEBR71FL.DTA', 'KEGC71FL.csv')","28d68d1e":"# States-Provinces shapefile\nstates_provinces_gdf = gpd.read_file('..\/input\/world-geo-data\/ne_10m_admin_1_states_provinces.shp')\n# Kiva subnational MPI dataset\nmpi_subnational_df = pd.read_csv('..\/input\/kiva-mpi-subnational-with-coordinates\/mpi_subnational_coords.csv')\n\n# This step is just to ensure we have matches where possible between the two datasets\n#from string import punctuation\nstates_provinces_gdf['name'] = states_provinces_gdf['name'].str.replace('-',' ')\nmpi_subnational_df['Sub-national region'] = mpi_subnational_df['Sub-national region'].str.replace('-',' ')","4f301a27":"def read_data(country, household_path, household_member_path, births_path, dhs_cluster_path, dhs_geo_path, \n              admin1_geo_path, admin2_geo_path):\n    global household_dhs_df\n    global household_member_dhs_df\n    global births_dhs_df\n    global dhs_cluster_df\n    global dhs_geo_gdf\n    global admin1_geo_gdf\n    global admin2_geo_gdf\n    \n    # Read in preprocessed DHS datasets\n    household_dhs_df = pd.read_csv(household_path)\n    household_member_dhs_df = pd.read_csv(household_member_path)\n    births_dhs_df = pd.read_csv(births_path)\n    dhs_cluster_df = pd.read_csv(dhs_cluster_path)\n    # DHS shapefile\n    dhs_geo_gdf = gpd.read_file(dhs_geo_path)\n\n    # Admin1 boundaries shapefile\n    admin1_geo_gdf = gpd.read_file(admin1_geo_path)\n\n    # Admin2 boundaries shapefile\n    admin2_geo_gdf = gpd.read_file(admin2_geo_path)","9592965c":"# Determine drinking water deprivation\n# hv201 - source of drinking water\n# hv204 - time to water and back (in minutes) \n# *Slightly different logic used compared to ophi calc but should work out the same\nclean_water_source = [10, 11, 12, 13, 20, 21, 30, 31, 41, 51, 71]\ndef determine_water_depriv(row):\n    if row.hv201 in clean_water_source:\n        if (row.hv204 != 996) & (row.hv204 >= 30):\n            return 1\n        else:\n            return 0\n    else:\n        return 1\n\n# Determine asset deprivation given information_asset, mobility_asset and livelihood_asset features\n# A household is not deprived in assets if it has at least one asset from group (1) and at least one asset from groups (2) or (3).\ndef determine_asset_depriv(row):\n    if row.information_asset == 0:\n        return 1\n    if (row.mobility_asset == 0) & (row.livelihood_asset == 0):\n        return 1\n    return 0\n    \ndef process_household_data(df):\n    # hv009 : total members in household, rename col\n    df.rename(columns={'hv009':'total_household_members'}, inplace=True)\n    \n    # hv247 - bank account (used only in MPI2 model)\n    df['financial_depriv'] = np.where(df['hv247'] == 0, 1, 0) \n        \n    # hv206 - electricity, map to electricity_depriv\n    df['electricity_depriv'] = np.where(df['hv206'] == 0, 1, 0)\n    # hv201, hv 204 - map to water_depriv\n    df['water_depriv'] = df.apply(determine_water_depriv, axis=1)\n    # hv05 - type of toilet facility\n    # hv25 - shared sanitation \n    # *Including 14, 15 as improved sanitation, ophi calculation does not.\n    improved_sanitation =  [10, 11, 12, 13, 14, 15, 21, 22, 41]\n    df['sanitation_depriv'] = np.where((df.hv225 == 0) & (df['hv205'].isin(improved_sanitation)), 0, 1)\n    # hv26 - map to cooking_fuel_depriv\n    df['cooking_fuel_depriv'] = np.where(df['hv226'].isin([6, 7, 8, 9, 10, 11, 95, 96]), 1, 0)\n    # hv213 - floor type, map to floor_depriv\n    df['floor_depriv'] = np.where(df['hv213'].isin([11, 12, 13, 96]), 1, 0)\n    \n    # hv207 Radio, HV208 - Television, hv243a - Mobile telephone, hv221 - Telephone (non-mobile)\n    # hv210 Bicycle, HV211 Motorcycle or Scooter, HV212 Car or Truck, HV243C : Animal-drawn cart, HV243D : Boat with a motor\n    # hv209 - Refrigerator, HV244 : Own land usable for agriculture, HV245 : Hectares for agricultural land\n    # hv246 - Livestock, herds or farm animals\n    # hv246a - cattle, hv246c - horses, hv246d - goats, hv246e - sheep, hv246f - chickens\n    # * Note: I have used the simplified hv246 instead of individual livestock, slight deviation from OPHI calculation.\n    df['information_asset'] =  np.where((df.hv207 == 1) | (df.hv208 == 1) | (df.hv243a == 1) | (df.hv221 == 1), 1, 0)\n    df['mobility_asset'] =  np.where((df.hv210 == 1) | (df.hv211 == 1) | (df.hv212 == 1) | (df.hv243c == 1) | (df.hv243d == 1), 1, 0)\n    df['livelihood_asset'] =  np.where((df.hv209 == 1) | (df.hv244 == 1) | (df.hv245 == 1) | (df.hv246 == 1), 1, 0)\n    # determine asset_depriv\n    df['asset_depriv'] = df.apply(determine_asset_depriv, axis=1)\n    return df","8f424543":"# Nutrition:\n# hc73: The measures are presented with two implied decimal places (no decimal points are included in the data file). \nz_cutoff_malnutrition = -200 # Below -2 Std deviations is considered malnourished (UNDP documentation)\nbmi_cutoff_malnutrition = 1850 # Cutoff according is 18.5 (UNDP documentation)\n\ndef process_malnutrition(row):\n    if not math.isnan(row['hc31']):\n        if (row['hv105'] < 5): # < 5 years old\n            if(row['hc70'] <= z_cutoff_malnutrition): # use Ht\/A Std deviations\n                return 1\n            else:\n                return 0\n    elif not math.isnan(row['ha1']):\n        if (row['hv105'] >= 15) & (row['hv105'] <= 49) & (row['ha40'] <= bmi_cutoff_malnutrition): # use BMI for adults\n            return 1\n        else:\n            return 0\n    else:\n        return np.nan\n    \ndef process_household_member_data(df):\n    # determine if household member is malnourished\n    df['malnutrition'] = df.apply(process_malnutrition, axis=1)\n    \n    # Education\n    # Entrance age of primary: 6 years (http:\/\/stats.uis.unesco.org\/unesco\/TableViewer\/tableView.aspx?ReportId=163)\n    # hv121 - Household member attended school during current school year\n    # hv105 - age\n    df['child_not_in_school'] = np.where((df['hv105'] >= 7) & (df['hv105'] <= 14) & (df['hv121'] == 0), 1, 0)\n    \n    # Whether there is a child under 5 in a household or a woman between 15 and 49 are features required later on \n    # to determine whether a household is eligible for inclusion.\n    df['child_under_5'] = np.where(df['hv105'] < 5, 1, 0)\n    df['woman_15_to_49'] = np.where((df['ha1'] >= 15) & (df['ha1'] <=49), 1, 0)\n    \n    # Note: number of years of school is obtained slightly differently to the OPHI method.\n    # Get summary stats per household\n    aggregations = {\n        'hv108':lambda x: x.ge(6).sum(), # count number in houseold with >= 6 years of school\n        'malnutrition': 'sum',\n        'child_under_5': 'max',\n        'woman_15_to_49': 'max',\n        'child_not_in_school': 'max'\n    }\n    summary_df = df.groupby(['hv001', 'hv002']).agg(aggregations).reset_index()\n    summary_df['school_attainment_depriv'] = np.where(summary_df['hv108'] == 0, 1, 0)\n    summary_df['school_attendance_depriv'] = np.where(summary_df['child_not_in_school'] == 0, 0, 1)\n    return summary_df","d67495d4":"# V206 - Total number of sons who have died (children)\n# V207 - Total number of daughters who have died  (children)\n# b7 - Age at death of the child in completed months g (children)\n# B2 Year of birth of child\n# B5 Whether child was alive or dead at the time of interview. \n# Child mortality: a child has died in the household within the five years prior to the survey\nfive_year_threshold = 2009 # Since the survey year was 2014 \n\ndef child_mortailty(row):\n    if (row.b5 == 0) & (row.b2+(row.b7\/12) >= five_year_threshold):\n        return 1\n    else:\n        return 0\n    \ndef process_births_data(df):\n    df['child_mortailty'] = df.apply(child_mortailty, axis=1)\n    \n    # Get summary stats per household\n    aggregations = {\n        'child_mortailty': 'sum'\n    }\n    return df.groupby(['v001', 'v002']).agg(aggregations).reset_index()","a41b2325":"def combine_datasets(household_df, household_member_df, births_df):\n    print(\"Original DHS household dataset: \", household_df.shape)\n    combined_df = household_df.merge(household_member_df)\n    combined_df = combined_df.merge(births_df, how='left', left_on=['hv001', 'hv002'], right_on=['v001', 'v002'])\n    print(\"Merged dataset: \", combined_df.shape)\n    \n    # drop irrelevant columns\n    combined_df = combined_df[combined_df.columns.drop(list(combined_df.filter(regex='^hv2')))]\n    combined_df = combined_df[combined_df.columns.drop(list(combined_df.filter(regex='^v0')))]\n    return combined_df","fffcb556":"edu_ind_weight = 1\/6\nhealth_ind_weight = 1\/6\nliv_ind_weight = 1\/18\n\ndef calculate_total_of_weighted_depriv(row):\n    return (row.school_attainment_depriv*edu_ind_weight) + (row.school_attendance_depriv*edu_ind_weight) + (row.malnutrition*health_ind_weight) + (row.child_mortailty*health_ind_weight) + (row.electricity_depriv*liv_ind_weight) + (row.water_depriv*liv_ind_weight) + (row.sanitation_depriv*liv_ind_weight) + (row.cooking_fuel_depriv*liv_ind_weight) + (row.floor_depriv*liv_ind_weight) + (row.asset_depriv*liv_ind_weight)\n\n#eligible_df['total_of_weighted_deprivations']  = (eligible_df.school_attainment_depriv*edu_ind_weight) + (eligible_df.school_attendance_depriv*edu_ind_weight) + (eligible_df.malnutrition*health_ind_weight) + (eligible_df.child_mortailty*health_ind_weight) + (eligible_df.electricity_depriv*liv_ind_weight) + (eligible_df.water_depriv*liv_ind_weight) + (eligible_df.sanitation_depriv*liv_ind_weight) + (eligible_df.cooking_fuel_depriv*liv_ind_weight) + (eligible_df.floor_depriv*liv_ind_weight) + (eligible_df.asset_depriv*liv_ind_weight)","d88f7e81":"def calculate_deprivations(df, dhs_cluster_df, mp_threshold):\n    # The headcount ratio, H, is the proportion of the multidimensionally poor in the population: H = q \/ n\n    # where q is the number of people who are multidimensionally poor and n is the total population.\n    df['headcount_poor'] =  np.where(df['total_of_weighted_deprivations'] >= mp_threshold, df['total_household_members'], 0)\n\n    # The intensity of poverty, A, reflects the proportion of the weighted component indicators in which, on average,\n    # poor people are deprived. For poor households only (deprivation score c of 33.3 percent or higher), the deprivation \n    # scores are summed and divided by the total number of poor people.\n    df['total_poverty_intensity'] = df['headcount_poor']*df['total_of_weighted_deprivations']\n\n    # Format the DHSID to get just the number part for matching with hv001\n    dhs_cluster_df['DHSID_num'] = dhs_cluster_df['DHSID'].str[6:].str.lstrip('0').astype(int)\n    \n    # Merge dhs_cluster with dhs_geo\n    print(\"Original dhs_cluster_df dataset: \", dhs_cluster_df.shape)\n    dhs_cluster_df = dhs_cluster_df.merge(dhs_geo_gdf[['DHSID', 'ADM1NAME', 'LATNUM', 'LONGNUM']], left_on=['DHSID'], right_on=['DHSID'], suffixes=('', '_y'))\n    dhs_cluster_df = dhs_cluster_df[dhs_cluster_df.columns.drop(list(dhs_cluster_df.filter(regex='_y')))]\n    print(\"Merged dhs_cluster_df dataset: \", dhs_cluster_df.shape)\n\n    # Merge combined_df with dhs_cluster data to get county information (name)\n    df = df.merge(dhs_cluster_df[['DHSID_num', 'ADM1NAME', 'LATNUM', 'LONGNUM']], left_on=['hv001'], right_on=['DHSID_num'])\n    print(\"Merged df dataset: \", df.shape)\n    return df\n\n# Aggregate to specifed level, COUNTY level by default\ndef aggregate_admin_level(df, level='ADM1NAME', col='mpi_county'):\n    aggregations = {\n        'headcount_poor': 'sum',\n        'total_household_members': 'sum',\n        'total_poverty_intensity': 'sum'\n    }\n    df = df.groupby([level]).agg(aggregations).reset_index()\n\n    # Calculate MPI at the required aggregate level\n    df['headcount_ratio'] = df['headcount_poor']\/df['total_household_members']\n    df['poverty_intensity'] = df['total_poverty_intensity']\/df['headcount_poor']\n    df[col] = df['headcount_ratio'] * df['poverty_intensity']\n    return df","a58dda91":"# Function to combine MPI subnational scores with geometry\ndef get_mpi_subnational_gdf(mpi_subnational_df, states_provinces_gdf, country):\n    # Join the mpi_subnational data to states and provinces data in order to plot\n\n    # Keep just country data\n    states_provinces_gdf = states_provinces_gdf[states_provinces_gdf['admin'] == country]\n    mpi_subnational_df = mpi_subnational_df[mpi_subnational_df['Country'] == country]\n\n    # This step is just to ensure we have matches where possible between the two datasets\n    #from string import punctuation\n    #states_provinces_gdf['name'] = states_provinces_gdf['name'].str.replace('-',' ')\n    #mpi_subnational_df['Sub-national region'] = mpi_subnational_df['Sub-national region'].str.replace('-',' ')\n\n    print(\"Country states_provinces_gdf dataset: \", states_provinces_gdf.shape)\n    print(\"Country mpi_subnational_df dataset: \", mpi_subnational_df.shape)\n\n    states_provinces_gdf.drop_duplicates(subset='woe_label', keep=\"last\", inplace=True)\n    print(\"Cleaned states_provinces_gdf dataset: \", states_provinces_gdf.shape)\n\n    mpi_subnational_df = mpi_subnational_df[mpi_subnational_df['Country'] == country]\n    mpi_subnational_df = mpi_subnational_df.merge(states_provinces_gdf, left_on='Sub-national region', right_on='name')\n    print(\"Merged mpi_subnational_gdf dataset (with states_provinces_gdf): \", mpi_subnational_df.shape)\n    \n    return mpi_subnational_df","b9a23313":"# Define some geo conversion functions\n# Spatially join to counties\ndef convert_to_geodataframe_with_lat_long(df, lon, lat):\n    df['geometry'] = df.apply(lambda row: Point(row[lon], row[lat]), axis=1)\n    gdf = gpd.GeoDataFrame( df, geometry='geometry')\n    gdf.crs = {\"init\":'epsg:4326'}\n    return gdf\n\ndef convert_to_geodataframe_with_geometry(df, geometry):\n    gdf = gpd.GeoDataFrame( df, geometry='geometry')\n    gdf.crs = {\"init\":'epsg:4326'}\n    return gdf","9c84ec06":"def get_combined_data_for_eligible_households():\n    global household_dhs_df\n    global household_member_dhs_df\n    global births_dhs_df\n    \n    # Process DHS data to get individual indicators\n    household_dhs_df = process_household_data(household_dhs_df)\n    household_member_dhs_summary_df = process_household_member_data(household_member_dhs_df)\n    births_dhs_summary_df = process_births_data(births_dhs_df)\n    combined_df = combine_datasets(household_dhs_df, household_member_dhs_summary_df, births_dhs_summary_df)\n\n    # remove households with missing indicators\n    print(\"Combined DHS Dataset: \", combined_df.shape)\n    combined_df.dropna(inplace=True)\n    print(\"Dataset after removing households with missing indicators: \", combined_df.shape)\n\n    # remove ineligible households\n    eligible_df = combined_df[(combined_df['woman_15_to_49'] != 0) | (combined_df['child_under_5'] != 0)]\n    print(\"Dataset after removing ineligible households: \", eligible_df.shape)\n    \n    return eligible_df","d97d244e":"# Function to run the whole process\n# This calls all the subfunctions in order to calculate MPI at province level and calcualtes a correlation between \n# the country's calculated MPI and the OPHI MPI.\n# Note: The lines where sjoin is used are commented out in order to run on Kaggle servers. The data has been preprocessed locally,\n# and read in when running on Kaggle. To run full sjoin steps, simple uncomment the lines.\ndef calculate_mpi(country, admin1_geo, admin1_col, admin1_mpi_col, admin2_geo=gpd.GeoDataFrame(), admin2_col='', admin2_mpi_col='', admin3_geo=gpd.GeoDataFrame(), admin3_col='', admin3_mpi_col=''):\n    global household_dhs_df\n    global household_member_dhs_df\n    global births_dhs_df\n    global dhs_mpi_df\n    # Create them in case they are not produced\n    admin2_dhs_mpi_df = pd.DataFrame()\n    admin3_dhs_mpi_df = pd.DataFrame()\n\n    eligible_df = get_combined_data_for_eligible_households()\n\n    # calclate total weighted deprivations\n    eligible_df['total_of_weighted_deprivations'] = eligible_df.apply(calculate_total_of_weighted_depriv, axis=1)\n\n    # calculate MPI. mp_threshold is 0.333 because this is the cutoff for being considered multi-dimensionally poor \n    # (poor in more than one dimension, since there are 3 dimensions, this is 1\/3)\n    dhs_mpi_df = calculate_deprivations(eligible_df, dhs_cluster_df, 0.333)\n\n    # Spatially join to admin1 boundaries\n    #dhs_mpi_gdf = convert_to_geodataframe_with_lat_long(dhs_mpi_df, 'LONGNUM', 'LATNUM')\n    #dhs_mpi_joined_gdf = gpd.sjoin(dhs_mpi_gdf, admin1_geo_gdf, op='within')\n    #print(\"Dataset spatially joined with admin level 1 geodata: \", dhs_mpi_joined_gdf.shape)   \n    #dhs_mpi_joined_gdf.to_csv(country+'_dhs_mpi_admin1_sjoin.csv', index = False)\n    dhs_mpi_joined_gdf = pd.read_csv('..\/input\/'+country.lower()+'-preprocessed\/'+country+'_dhs_mpi_admin1_sjoin.csv')\n    \n    # Aggregate to admin1 (Province) level\n    admin1_dhs_mpi_df = aggregate_admin_level(dhs_mpi_joined_gdf, level=admin1_col, col=admin1_mpi_col)\n    print(\"Dataset aggregated to admin level 1: \", admin1_dhs_mpi_df.shape)\n    \n    # Ensure we are using title case for names (this is inconsistent in some country's datasets)\n    admin1_dhs_mpi_df[admin1_col] = admin1_dhs_mpi_df[admin1_col].str.title()\n    \n    if not admin2_geo.empty:\n        # Spatially join to admin2 boundaries\n        #dhs_mpi_joined_gdf = gpd.sjoin(dhs_mpi_gdf, admin2_geo, op='within')\n        #print(\"Dataset spatially joined with admin level 2 geodata: \", dhs_mpi_joined_gdf.shape)\n        #dhs_mpi_joined_gdf.to_csv(country+'_dhs_mpi_admin2_sjoin.csv', index = False)\n        dhs_mpi_joined_gdf = pd.read_csv('..\/input\/'+country.lower()+'-preprocessed\/'+country+'_dhs_mpi_admin2_sjoin.csv')\n    if admin2_col:\n        # Aggregate to admin2 (County) level\n        admin2_dhs_mpi_df = aggregate_admin_level(dhs_mpi_joined_gdf, level=admin2_col, col=admin2_mpi_col)\n        print(\"Dataset aggregated to admin level 2: \", admin2_dhs_mpi_df.shape)\n    \n    if not admin3_geo.empty:\n        # Spatially join to admin3 boundaries\n        #dhs_mpi_joined_gdf = gpd.sjoin(dhs_mpi_gdf, admin3_geo, op='within')\n        #print(\"Dataset spatially joined with admin level 3 geodata: \", dhs_mpi_joined_gdf.shape)\n        #dhs_mpi_joined_gdf.to_csv(country+'_dhs_mpi_admin3_sjoin.csv', index = False)\n        dhs_mpi_joined_gdf = pd.read_csv('..\/input\/'+country.lower()+'-preprocessed\/'+country+'_dhs_mpi_admin3_sjoin.csv')\n    if admin3_col:\n        # Aggregate to admin3 level\n        admin3_dhs_mpi_df = aggregate_admin_level(dhs_mpi_joined_gdf, level=admin3_col, col=admin3_mpi_col)\n        print(\"Dataset aggregated to admin level 3: \", admin3_dhs_mpi_df.shape)\n    \n    return admin1_dhs_mpi_df, admin2_dhs_mpi_df, admin3_dhs_mpi_df","7b5f9343":"read_data('kenya', \n          '..\/input\/kenya-preprocessed\/kenya_household_dhs.csv',\n          '..\/input\/kenya-preprocessed\/kenya_household_member_dhs.csv',\n          '..\/input\/kenya-preprocessed\/kenya_births_dhs.csv',\n          '..\/input\/kenya-preprocessed\/kenya_dhs_cluster.csv',\n          '..\/input\/kenya-preprocessed\/KEGE71FL.shp', \n          '..\/input\/kenya-humdata-admin-geo\/Kenya_admin_2014_WGS84.shp', \n          '..\/input\/kenya-humdata-admin-geo\/KEN_Adm2.shp')","ca0cabd9":"# Replace polygons with simple ones\n# This step was done because folium maps were not plotting the original polygons for some reason. Maybe they were just too complex.\n\n# This step is only necessary for certain shapefiles, when the geometry has too many points.\ndef replace_geometry(gdf, gdf_simple_path):\n    gdf_simple = gpd.read_file(gdf_simple_path)\n    gdf['geometry'] = gdf_simple['geometry']\n\n# Note: Be careful when simplifying shapefiles, that there are still matches for all admin level entries and \n# no Polygon is simpified down to an empty polygon.\nreplace_geometry(admin1_geo_gdf, '..\/input\/kenya-humdata-admin-geo\/Kenya_admin_2014_WGS84_simple.shp')\nreplace_geometry(admin2_geo_gdf, '..\/input\/kenya-humdata-admin-geo\/KEN_Adm2_simple.shp')","0cf96df7":"admin1_mpi_df, admin2_mpi_df, admin3_mpi_df = calculate_mpi('Kenya', admin1_geo_gdf, 'Province', 'mpi_admin1', \n        admin2_geo=admin2_geo_gdf, admin2_col='ADM1NAME', admin2_mpi_col='mpi_admin2', \n        admin3_col='Adm2Name', admin3_mpi_col='mpi_admin3')","2dffe1ad":"# Merge \ncountry_mpi_subnational_gdf = get_mpi_subnational_gdf(mpi_subnational_df, states_provinces_gdf, 'Kenya')\nadmin1_mpi_merged_df = admin1_mpi_df.merge(country_mpi_subnational_gdf[['Sub-national region', 'MPI Regional']],\n                                                left_on=['Province'], right_on=['Sub-national region'])\nprint(\"Dataset after merge with OPHI MPI data: \", admin1_mpi_merged_df.shape)\n\n# Check Correlation at admin1 level\nprint(\"Correlation, p-value: \", pearsonr(admin1_mpi_merged_df.loc[:, 'mpi_admin1'], admin1_mpi_merged_df.loc[:, 'MPI Regional']))\nsns.regplot(x=\"MPI Regional\", y='mpi_admin1', data=admin1_mpi_merged_df)","e96da184":"# RMSE\nprint(\"RMSE: \", np.sqrt(metrics.mean_squared_error(admin1_mpi_merged_df.loc[:, 'MPI Regional'], admin1_mpi_merged_df.loc[:, 'mpi_admin1'])))","0b1cfd27":"# Define some helper functions\ndef get_geo_gdf(country):\n    return states_provinces_gdf[states_provinces_gdf['geonunit'] == country]\n\ndef create_map(geo_gdf, data, key_on, key_col, feature, fill_color, lat, long, zoom, threshold_scale):\n    geojson = geo_gdf.to_json()\n    country_map = folium.Map([lat, long], zoom_start = zoom)\n    country_map.choropleth(\n        geo_data=geojson,\n        name=feature+' choropleth',\n        key_on=key_on,\n        fill_color=fill_color,\n        data=data,\n        columns=[key_col, feature],\n        threshold_scale=threshold_scale,\n        legend_name= feature+' per Province'\n    )\n    return country_map","ce3435ad":"kenya_mpi_threshold_scale = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6] # Define MPI scale for Kenya\nkenya_geo_gdf = get_geo_gdf('Kenya')\ncreate_map(kenya_geo_gdf, country_mpi_subnational_gdf, 'feature.properties.name', 'Sub-national region', 'MPI Regional', 'YlOrRd', 0.0236, 37.9062, 6, kenya_mpi_threshold_scale)","463a5e04":"create_map(kenya_geo_gdf, admin1_mpi_df, 'feature.properties.name', 'Province', 'mpi_admin1', 'YlOrRd', 0.0236, 37.9062, 6, kenya_mpi_threshold_scale)","b1b0d0a0":"create_map(admin1_geo_gdf, admin2_mpi_df, 'feature.properties.COUNTY', 'ADM1NAME', 'mpi_admin2', 'YlOrRd', 0.0236, 37.9062, 6, kenya_mpi_threshold_scale)","0182e562":"create_map(admin2_geo_gdf, admin3_mpi_df, 'feature.properties.Adm2Name', 'Adm2Name', 'mpi_admin3', 'YlOrRd', 0.0236, 37.9062, 6, kenya_mpi_threshold_scale)","d7031fc4":"admin2_mpi_df.min()","83bb5830":"admin3_mpi_df.min()","7215003a":"# Original Kiva datasets\nkiva_loans_df = pd.read_csv(\"..\/input\/data-science-for-good-kiva-crowdfunding\/kiva_loans.csv\")\n#kiva_mpi_locations_df = pd.read_csv(\"..\/input\/data-science-for-good-kiva-crowdfunding\/kiva_mpi_region_locations.csv\")\nloan_theme_ids_df = pd.read_csv(\"..\/input\/data-science-for-good-kiva-crowdfunding\/loan_theme_ids.csv\")\nloan_themes_by_region_df = pd.read_csv(\"..\/input\/data-science-for-good-kiva-crowdfunding\/loan_themes_by_region.csv\")","d30d7d20":"# Merge Kiva loans to locations data via loan_themes\nprint(\"Original Kiva Loans dataset: \", kiva_loans_df.shape)\nkiva_loans_region_df = pd.merge(kiva_loans_df, loan_theme_ids_df, how='left', on='id', suffixes=('', '_y'))\nkiva_loans_region_df = kiva_loans_region_df[kiva_loans_region_df.columns.drop(list(kiva_loans_region_df.filter(regex='_y')))]\n\nkiva_loans_region_df = kiva_loans_region_df.merge(loan_themes_by_region_df, how='left', on=['Partner ID', 'Loan Theme ID', 'country', 'region'], suffixes=('', '_y'))\nkiva_loans_region_df = kiva_loans_region_df[kiva_loans_region_df.columns.drop(list(kiva_loans_region_df.filter(regex='_y')))]\n\n#kiva_loans_region_df = kiva_loans_region_df.merge(kiva_loans_region_df, how='left', left_on=['country', 'mpi_region'], right_on=['country', 'LocationName'], suffixes=('', '_y'))\n#kiva_loans_region_df = kiva_loans_region_df[kiva_loans_region_df.columns.drop(list(kiva_loans_region_df.filter(regex='_y')))]\nprint(\"Merged Kiva Loans dataset: \", kiva_loans_region_df.shape)","9cea43cd":"# Keep only Kenya loans\nkiva_loans_kenya_df = kiva_loans_region_df[kiva_loans_region_df['country']=='Kenya']\nprint(\"Kenya Kiva Loans dataset: \", kiva_loans_kenya_df.shape)\n\n# Drop those with null lat\/long. If lat\/long is not known, the borrower cannot be more accurately classified using this method.\nkiva_loans_kenya_df = kiva_loans_kenya_df[np.isfinite(kiva_loans_kenya_df['lat'])]\nprint(\"Kenya cleaned Kiva Loans dataset: \", kiva_loans_kenya_df.shape)","28dc03a9":"# Get county geomentry\n\n# Doing some manual recoding to get matches \nadmin1_geo_gdf.COUNTY.replace('Keiyo-Marakwet', 'Elgeyo Marakwet', inplace=True)\nadmin1_geo_gdf.COUNTY.replace('Tharaka', 'Tharaka-Nithi', inplace=True)\nadmin1_geo_gdf.COUNTY.replace('Trans Nzoia', 'Trans-Nzoia', inplace=True)\n\nprint(\"Original dhs_mpi_county_df dataset: \", admin2_mpi_df.shape)\nadmin2_mpi_df = admin2_mpi_df.merge(admin1_geo_gdf[['COUNTY', 'Province', 'geometry']], left_on='ADM1NAME', right_on=['COUNTY'])\nprint(\"Merged dhs_mpi_county_df dataset: \", admin2_mpi_df.shape)","4c1832bf":"# function to add markers to folium map\ndef add_markers(df, m, radius='count', color='blue', popup=None):\n    for i in range(0, df.shape[0]):\n        folium.CircleMarker(\n            [df.iloc[i]['lat'], df.iloc[i]['lon']], \n            radius=df.iloc[i][radius]**(4**-1), # x**(n**-1) is used because there are clusters of loans with the same lot\/long\n                                                 # and also single loans with unique lat\/long\n            color=color, \n            fill=True, \n            fill_color=color\n        ).add_to(m)","2c1c9a19":"# Convert to geo dataframe\nkiva_loans_kenya_gdf = convert_to_geodataframe_with_lat_long(kiva_loans_kenya_df, 'lon', 'lat')\n\n# Group by lat\/long, count because there are many loans recorded with the same lat\/long and it takes too long to plot otherwise.\nprint(\"Original kiva_loans_kenya_gdf dataset: \", kiva_loans_kenya_gdf.shape)\nkiva_loans_kenya_grouped_gdf = kiva_loans_kenya_gdf.groupby(['lat','lon']).size().reset_index(name='count')\nprint(\"Grouped kiva_loans_kenya_gdf dataset: \", kiva_loans_kenya_grouped_gdf.shape)\n\n# plot at county level\nkenya_map = create_map(admin1_geo_gdf, admin2_mpi_df, 'feature.properties.COUNTY', 'ADM1NAME', 'mpi_admin2', 'YlOrRd', 0.0236, 37.9062, 6, kenya_mpi_threshold_scale)\nadd_markers(kiva_loans_kenya_grouped_gdf, kenya_map)\nkenya_map","cc57179b":"# Uncomment the line below to run pre-processing of original DHS files\n#preprocess_dhs_data('zimbabwe', 'ZWHR71FL.DTA', 'ZWPR71FL.DTA', 'ZWBR71FL.DTA', 'ZWGC71FL.csv')","c9277980":"# Read in DHS and Geo Data\nread_data('zimbabwe', \n          '..\/input\/zimbabwe-preprocessed\/zimbabwe_household_dhs.csv',\n          '..\/input\/zimbabwe-preprocessed\/zimbabwe_household_member_dhs.csv',\n          '..\/input\/zimbabwe-preprocessed\/zimbabwe_births_dhs.csv',\n          '..\/input\/zimbabwe-preprocessed\/zimbabwe_dhs_cluster.csv',\n          '..\/input\/zimbabwe-preprocessed\/ZWGE72FL.shp', \n          '..\/input\/zimbabwe-humdata-admin-geo\/zwe_polbnda_adm1_250k_cso.shp', \n          '..\/input\/zimbabwe-humdata-admin-geo\/zwe_polbnda_adm2_250k_cso.shp'\n         )\n\n# Simplify geometry. Seems to be necessary only for admin level 2 for Zimbabwe.\nreplace_geometry(admin2_geo_gdf, '..\/input\/zimbabwe-humdata-admin-geo\/zwe_polbnda_adm2_250k_cso_simple.shp')","d8e3bcf8":"admin1_mpi_df, admin2_mpi_df, admin3_mpi_df = calculate_mpi('Zimbabwe', admin1_geo_gdf, 'ADM1NAME', 'mpi_admin1', admin2_geo=admin2_geo_gdf, admin2_col='DIST_NM_LA', admin2_mpi_col='mpi_admin2', )","bd6dd52b":"# Merge \ncountry_mpi_subnational_gdf = get_mpi_subnational_gdf(mpi_subnational_df, states_provinces_gdf, 'Zimbabwe')\nadmin1_mpi_merged_df = admin1_mpi_df.merge(country_mpi_subnational_gdf[['Sub-national region', 'MPI Regional']],\n                                                left_on=['ADM1NAME'], right_on=['Sub-national region'])\nprint(\"Dataset after merge with OPHI MPI data: \", admin1_mpi_merged_df.shape)\n\n# Check Correlation at admin1 level\nprint(\"Correlation, p-value: \", pearsonr(admin1_mpi_merged_df.loc[:, 'mpi_admin1'], admin1_mpi_merged_df.loc[:, 'MPI Regional']))\nsns.regplot(x=\"MPI Regional\", y='mpi_admin1', data=admin1_mpi_merged_df)","21acffa5":"# RMSE\nprint(\"RMSE: \", np.sqrt(metrics.mean_squared_error(admin1_mpi_merged_df.loc[:, 'MPI Regional'], admin1_mpi_merged_df.loc[:, 'mpi_admin1'])))","998d8e70":"zmbabwe_mpi_threshold_scale = [0.05, 0.1, 0.15, 0.2, 0.25, 0.3] # Define MPI scale for Zimbabwe\nzimbabwe_geo_gdf = get_geo_gdf('Zimbabwe')\ncreate_map(zimbabwe_geo_gdf, country_mpi_subnational_gdf, 'feature.properties.name', 'Sub-national region', \n           'MPI Regional', 'YlOrRd', -19.0154, 29.1549, 6, zmbabwe_mpi_threshold_scale)","2bcf8210":"create_map(zimbabwe_geo_gdf, admin1_mpi_df, 'feature.properties.name', 'ADM1NAME', 'mpi_admin1', 'YlOrRd', -19.0154, 29.1549, 6, zmbabwe_mpi_threshold_scale)","95017085":"create_map(admin2_geo_gdf, admin2_mpi_df, 'feature.properties.DIST_NM_LA', 'DIST_NM_LA', 'mpi_admin2', 'YlOrRd', -19.0154, 29.1549, 6, zmbabwe_mpi_threshold_scale)","91e3818e":"# Uncomment the line below to run pre-processing of original DHS files\n#preprocess_dhs_data('cambodia', 'KHHR73FL.DTA', 'KHPR73FL.DTA', 'KHBR73FL.DTA', 'KHGC71FL.csv')","7007415a":"# Read in DHS and Geo Data\nread_data('cambodia', \n          '..\/input\/cambodia-preprocessed\/cambodia_household_dhs.csv',\n          '..\/input\/cambodia-preprocessed\/cambodia_household_member_dhs.csv',\n          '..\/input\/cambodia-preprocessed\/cambodia_births_dhs.csv',\n          '..\/input\/cambodia-preprocessed\/cambodia_dhs_cluster.csv',\n          '..\/input\/cambodia-preprocessed\/KHGE71FL.shp', \n          '..\/input\/cambodia-humdata-admin-geo\/khm_admbnda_adm1_gov.shp', \n          '..\/input\/cambodia-humdata-admin-geo\/khm_admbnda_adm2_gov.shp'\n         )\n\n# Simplify geometry.\nreplace_geometry(admin1_geo_gdf, '..\/input\/cambodia-humdata-admin-geo\/khm_admbnda_adm1_gov_simple.shp')\nreplace_geometry(admin2_geo_gdf, '..\/input\/cambodia-humdata-admin-geo\/khm_admbnda_adm2_gov_simple.shp')","be46cc98":"# Doing some manual recoding to get matches - no match for Banteay Mean Chey, Kampong Speu,  Kampong Thom, Kandal, Kratie, Pursat\nstates_provinces_gdf.name.replace('B\u00e2nt\u00e9ay M\u00e9anchey', 'Banteay Mean Chey', inplace=True)\n#states_provinces_gdf.name.replace('Battambang & Pailin', 'Pailin', inplace=True)\nstates_provinces_gdf.name.replace('Batd\u00e2mb\u00e2ng', 'Battambang & Pailin', inplace=True)\nstates_provinces_gdf.name.replace('K\u00e2mp\u00f3ng Cham', 'Kampong Cham', inplace=True)\nstates_provinces_gdf.name.replace('K\u00e2mp\u00f3ng Chhnang', 'Kampong Chhnang', inplace=True)\nstates_provinces_gdf.name.replace('K\u00e2mp\u00f3ng Sp\u0153', 'Kampong Speu', inplace=True)\nstates_provinces_gdf.name.replace('K\u00e2mp\u00f3ng Thum', 'Kampong Thom', inplace=True)\nstates_provinces_gdf.name.replace('Kep', 'Kampot & Kep', inplace=True)\nstates_provinces_gdf.name.replace('K\u00e2ndal', 'Kandal', inplace=True)\nstates_provinces_gdf.name.replace('Kr\u00e2ch\u00e9h', 'Kratie', inplace=True)\nstates_provinces_gdf.name.replace('M\u00f4nd\u00f3l Kiri', 'Mondol Kiri & Rattanak Kiri', inplace=True)\nstates_provinces_gdf.name.replace('Krong Preah Sihanouk', 'Preah Sihanouk & Kaoh Kong', inplace=True)\nstates_provinces_gdf.name.replace('Preah Vih\u00e9ar', 'Preah Vihear & Steung Treng', inplace=True)\nstates_provinces_gdf.name.replace('St\u0153ng Tr\u00eang', 'Preah Vihear & Steung Treng', inplace=True)\nstates_provinces_gdf.name.replace('Prey V\u00eang', 'Prey Veng', inplace=True)\nstates_provinces_gdf.name.replace('Pouthisat', 'Pursat', inplace=True)\nstates_provinces_gdf.name.replace('Siemr\u00e9ab', 'Siem Reap', inplace=True)\nstates_provinces_gdf.name.replace('Tak\u00eav', 'Takeo', inplace=True)\n\n#cambodia_geo_gdf.name.replace('B\u00e2nt\u00e9ay M\u00e9anchey', 'Banteay Mean Chey', inplace=True)\n#cambodia_geo_gdf.name.replace('Krong Pailin', 'Pailin', inplace=True)\n#cambodia_geo_gdf.name.replace('Ka\u00f4h Kong', 'Preah Sihanouk & Kaoh Kon', inplace=True)\n#cambodia_geo_gdf.name.replace('St\u0153ng Tr\u00eang', 'Preah Vihear & Steung Treng', inplace=True)","2eab802b":"admin1_mpi_df, admin2_mpi_df, admin3_mpi_df = calculate_mpi('Cambodia', admin1_geo_gdf, 'ADM1NAME', 'mpi_admin1', admin2_geo=admin2_geo_gdf, admin2_col='DIS_NAME', admin2_mpi_col='mpi_admin2')","12a122ee":"# Merge \ncountry_mpi_subnational_gdf = get_mpi_subnational_gdf(mpi_subnational_df, states_provinces_gdf, 'Cambodia')\nadmin1_mpi_merged_df = admin1_mpi_df.merge(country_mpi_subnational_gdf[['Sub-national region', 'MPI Regional']],\n                                                left_on=['ADM1NAME'], right_on=['Sub-national region'])\nprint(\"Dataset after merge with OPHI MPI data: \", admin1_mpi_merged_df.shape)\n\n# Check Correlation at admin1 level\nprint(\"Correlation, p-value: \", pearsonr(admin1_mpi_merged_df.loc[:, 'mpi_admin1'], admin1_mpi_merged_df.loc[:, 'MPI Regional']))\nsns.regplot(x=\"MPI Regional\", y='mpi_admin1', data=admin1_mpi_merged_df)","7f0796c1":"# RMSE\nprint(\"RMSE: \", np.sqrt(metrics.mean_squared_error(admin1_mpi_merged_df.loc[:, 'MPI Regional'], admin1_mpi_merged_df.loc[:, 'mpi_admin1'])))","a162f4cb":"cambodia_mpi_threshold_scale = [0.05, 0.1, 0.15, 0.2, 0.25, 0.3] # Define MPI scale\ncambodia_geo_gdf = get_geo_gdf('Cambodia')\ncreate_map(cambodia_geo_gdf, country_mpi_subnational_gdf, 'feature.properties.name', 'Sub-national region', \n           'MPI Regional', 'YlOrRd', 12.5657, 104.9910, 7, cambodia_mpi_threshold_scale)","ed65a226":"create_map(cambodia_geo_gdf, admin1_mpi_df, 'feature.properties.name', 'ADM1NAME', 'mpi_admin1', 'YlOrRd',  12.5657, 104.9910, 7, cambodia_mpi_threshold_scale)","3dc14f5d":"create_map(admin2_geo_gdf, admin2_mpi_df, 'feature.properties.DIS_NAME', 'DIS_NAME', 'mpi_admin2', 'YlOrRd',  12.5657, 104.9910, 7, cambodia_mpi_threshold_scale)","f28ca77f":"# Uncomment the line below to run pre-processing of original DHS files\n#preprocess_dhs_data('rwanda', 'RWHR70FL.DTA', 'RWPR70FL.DTA', 'RWBR70FL.DTA', 'RWGC71FL.csv')","2ae85c36":"# Read in DHS and Geo Data\nread_data('rwanda', \n          '..\/input\/rwanda-preprocessed\/rwanda_household_dhs.csv',\n          '..\/input\/rwanda-preprocessed\/rwanda_household_member_dhs.csv',\n          '..\/input\/rwanda-preprocessed\/rwanda_births_dhs.csv',\n          '..\/input\/rwanda-preprocessed\/rwanda_dhs_cluster.csv',\n          '..\/input\/rwanda-preprocessed\/RWGE72FL.shp', \n          '..\/input\/rwanda-humdata-admin-geo\/RWA_Admin2_2006_NISR.shp', \n          '..\/input\/rwanda-humdata-admin-geo\/RWA_Admin3_2006_NISR.shp')\n\n# Simplify geometry. Seems to be necessary only for admin level 2 for Zimbabwe.\nreplace_geometry(admin2_geo_gdf, '..\/input\/rwanda-humdata-admin-geo\/RWA_Admin3_2006_NISR_simple.shp')","06ef6017":"# Doing some manual recoding to get matches \nstates_provinces_gdf.name.replace('Southern', 'South', inplace=True)\nstates_provinces_gdf.name.replace('Northern', 'North', inplace=True)\nstates_provinces_gdf.name.replace('Eastern', 'East', inplace=True)\nstates_provinces_gdf.name.replace('Western', 'West', inplace=True)\n\nadmin1_geo_gdf.PROVINCE.replace('SOUTHERN PROVINCE', 'South', inplace=True)\nadmin1_geo_gdf.PROVINCE.replace('NORTHERN PROVINCE', 'North', inplace=True)\nadmin1_geo_gdf.PROVINCE.replace('EASTERN PROVINCE', 'East', inplace=True)\nadmin1_geo_gdf.PROVINCE.replace('WESTERN PROVINCE', 'West', inplace=True)\nadmin1_geo_gdf.PROVINCE.replace('TOWN OF KIGALI', 'Kigali City', inplace=True)","8a0a9799":"admin1_mpi_df, admin2_mpi_df, admin3_mpi_df = calculate_mpi('Rwanda', admin1_geo_gdf, 'ADM1NAME', 'mpi_admin1', admin2_geo=admin2_geo_gdf, admin2_col='NOMDISTR', admin2_mpi_col='mpi_admin2')","9ee0871e":"# Merge \ncountry_mpi_subnational_gdf = get_mpi_subnational_gdf(mpi_subnational_df, states_provinces_gdf, 'Rwanda')\nadmin1_mpi_merged_df = admin1_mpi_df.merge(country_mpi_subnational_gdf[['Sub-national region', 'MPI Regional']],\n                                                left_on=['ADM1NAME'], right_on=['Sub-national region'])\nprint(\"Dataset after merge with OPHI MPI data: \", admin1_mpi_merged_df.shape)\n\n# Check Correlation at admin1 level\nprint(\"Correlation, p-value: \", pearsonr(admin1_mpi_merged_df.loc[:, 'mpi_admin1'], admin1_mpi_merged_df.loc[:, 'MPI Regional']))\nsns.regplot(x=\"MPI Regional\", y='mpi_admin1', data=admin1_mpi_merged_df)","bb0fbb59":"# RMSE\nprint(\"RMSE: \", np.sqrt(metrics.mean_squared_error(admin1_mpi_merged_df.loc[:, 'MPI Regional'], admin1_mpi_merged_df.loc[:, 'mpi_admin1'])))","6569c0f3":"rwanda_mpi_threshold_scale = [0.05, 0.1, 0.15, 0.2, 0.25, 0.3] # Define MPI scale\nrwanda_geo_gdf = get_geo_gdf('Rwanda')\ncreate_map(rwanda_geo_gdf, country_mpi_subnational_gdf, 'feature.properties.name', 'Sub-national region', \n           'MPI Regional', 'YlOrRd', -1.9403, 29.8739, 8, rwanda_mpi_threshold_scale)","7402530e":"create_map(rwanda_geo_gdf, admin1_mpi_df, 'feature.properties.name', 'ADM1NAME', 'mpi_admin1', 'YlOrRd', -1.9403, 29.8739, 8, rwanda_mpi_threshold_scale)","340b4ce5":"# Ensure we are using title case for names (this is inconsistent in some country's datasets)\nadmin2_geo_gdf['NOMDISTR'] = admin2_geo_gdf['NOMDISTR'].str.title()\ncreate_map(admin2_geo_gdf, admin2_mpi_df, 'feature.properties.NOMDISTR', 'NOMDISTR', 'mpi_admin2', 'YlOrRd',  -1.9403, 29.8739, 8, rwanda_mpi_threshold_scale)","8a2eb1fa":"# Uncomment the line below to run pre-processing of original DHS files\n#preprocess_dhs_data('tanzania', 'TZHR7HFL.DTA', 'TZPR7HFL.DTA', 'TZBR7HFL.DTA', 'TZGC7AFL.csv')","fa24663d":"# Read in DHS and Geo Data\nread_data('tanzania', \n          '..\/input\/tanzania-preprocessed\/tanzania_household_dhs.csv',\n          '..\/input\/tanzania-preprocessed\/tanzania_household_member_dhs.csv',\n          '..\/input\/tanzania-preprocessed\/tanzania_births_dhs.csv',\n          '..\/input\/tanzania-preprocessed\/tanzania_dhs_cluster.csv',\n          '..\/input\/tanzania-preprocessed\/TZGE7AFL.shp', \n          '..\/input\/tanzania-humdata-admin-geo\/tza_popa_adm1_regions_TNBS2012_OCHA.shp', \n          '..\/input\/tanzania-humdata-admin-geo\/tza_popa_adm2_districts_TNBS2012_OCHA.shp')\n\n# Simplify geometry. \nreplace_geometry(admin2_geo_gdf, '..\/input\/tanzania-humdata-admin-geo\/tza_popa_adm2_districts_TNBS2012_OCHA_simple.shp')","57c807c9":"admin1_mpi_df, admin2_mpi_df, admin3_mpi_df = calculate_mpi('Tanzania', admin1_geo_gdf, 'REGION', 'mpi_admin1', admin2_geo=admin2_geo_gdf, admin2_col='DISTRICT', admin2_mpi_col='mpi_admin2')","ea78318c":"tanzania_mpi_threshold_scale = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]# Define MPI scale\ntanzania_geo_gdf = get_geo_gdf('Tanzania')","7dfabfae":"create_map(tanzania_geo_gdf, admin1_mpi_df, 'feature.properties.name', 'REGION', 'mpi_admin1', 'YlOrRd', -6.3690, 34.8888, 6, tanzania_mpi_threshold_scale)","d1fddeb2":"create_map(admin2_geo_gdf, admin2_mpi_df, 'feature.properties.DISTRICT', 'DISTRICT', 'mpi_admin2', 'YlOrRd', -6.3690, 34.8888, 6, tanzania_mpi_threshold_scale)","41417e27":"# Uncomment the line below to run pre-processing of original DHS files\n#preprocess_dhs_data('ghana', 'GHHR72FL.DTA', 'GHPR72FL.DTA', 'GHBR72FL.DTA', 'GHGC71FL.csv')","eddc4bc9":"# Read in DHS and Geo Data\nread_data('ghana', \n          '..\/input\/ghana-preprocessed\/ghana_household_dhs.csv',\n          '..\/input\/ghana-preprocessed\/ghana_household_member_dhs.csv',\n          '..\/input\/ghana-preprocessed\/ghana_births_dhs.csv',\n          '..\/input\/ghana-preprocessed\/ghana_dhs_cluster.csv',\n          '..\/input\/ghana-preprocessed\/GHGE71FL.shp', \n          '..\/input\/ghana-humdata-admin-geo\/GHA_admbndp1_1m_GAUL.shp', \n          '..\/input\/ghana-humdata-admin-geo\/GHA_admbndp2_1m_GAUL.shp')\n\n# Simplify geometry.     \nreplace_geometry(admin2_geo_gdf, '..\/input\/ghana-humdata-admin-geo\/GHA_admbndp2_1m_GAUL_simple.shp')","df16ecc4":"admin1_mpi_df, admin2_mpi_df, admin3_mpi_df = calculate_mpi('Ghana', admin1_geo_gdf, 'ADM1_NAME', 'mpi_admin1', admin2_geo=admin2_geo_gdf, admin2_col='ADM2_NAME', admin2_mpi_col='mpi_admin2')","40fadaf1":"# Merge \ncountry_mpi_subnational_gdf = get_mpi_subnational_gdf(mpi_subnational_df, states_provinces_gdf, 'Ghana')\nadmin1_mpi_merged_df = admin1_mpi_df.merge(country_mpi_subnational_gdf[['Sub-national region', 'MPI Regional']],\n                                                left_on=['ADM1_NAME'], right_on=['Sub-national region'])\nprint(\"Dataset after merge with OPHI MPI data: \", admin1_mpi_merged_df.shape)\n\n# Check Correlation at admin1 level\nprint(\"Correlation, p-value: \", pearsonr(admin1_mpi_merged_df.loc[:, 'mpi_admin1'], admin1_mpi_merged_df.loc[:, 'MPI Regional']))\nsns.regplot(x=\"MPI Regional\", y='mpi_admin1', data=admin1_mpi_merged_df)","8d33dc4f":"# RMSE\nprint(\"RMSE: \", np.sqrt(metrics.mean_squared_error(admin1_mpi_merged_df.loc[:, 'MPI Regional'], admin1_mpi_merged_df.loc[:, 'mpi_admin1'])))","da0685d1":"ghana_mpi_threshold_scale = [0.05, 0.1, 0.15, 0.2, 0.25, 0.3]\nghana_geo_gdf = get_geo_gdf('Ghana')\ncreate_map(ghana_geo_gdf, country_mpi_subnational_gdf, 'feature.properties.name', 'Sub-national region', \n           'MPI Regional', 'YlOrRd', 7.9465, -1.0232, 6, ghana_mpi_threshold_scale)","80f92525":"create_map(ghana_geo_gdf, admin1_mpi_df, 'feature.properties.name', 'ADM1_NAME', 'mpi_admin1', 'YlOrRd', 7.9465, -1.0232, 6, ghana_mpi_threshold_scale)","06e38409":"create_map(admin2_geo_gdf, admin2_mpi_df, 'feature.properties.ADM2_NAME', 'ADM2_NAME', 'mpi_admin2', 'YlOrRd', 7.9465, -1.0232, 6, ghana_mpi_threshold_scale)","e729571e":"## 7. Conclusion <a class=\"anchor\" id=\"conclusion\"\/>\n***\nThis notebook has provided Kiva with a way to calculate MPI scores at a  more granular level than is currently available. The calculation has been tested by comparing outputs at a level of granularity for which MPI scores are available from OPHI, and found to be relatively accurate (with RMSEs between 0.022 and 0.043). It has also been shown that assigning scores at higher levels of granularity results in significantly varying MPI scores across areas which have in the past been treated by Kiva as one region, bringing the advantage of more accurate targeting. \n\nAlthough this notebook only covers a small number of countries, the methods provided in this notebook should work for any country which has DHS v7 survey data available. Additionally, for countries that only have older versions of DHS survey data available, the methods should only require small tweaks so that the features can be correctly extracted from these datasets. Once the calculations are run at the required level of granulartiy, Kiva loans are easily associated with the appropriate region, and thus MPI, by using either a spatial join function if the latitude and longitude of the loan is known, or a simple name match if the name of the region where the loan comes from is known.","79d523e7":"### Rwanda (National MPI 0.259) <a class=\"anchor\" id=\"rwanda\"\/>\n***","bc50642d":"#### Figure: OPHI Province (Sub-national) MPI - Kenya <a class=\"anchor\" id=\"fig_ophi_admin1_mpi_kenya\"\/>","3870f151":"The plot of calculated MPI at administration level 1 (county level) shows that the counties within a provice actually have very different MPIs. For example, the large Rift Valley province running from north to south Kenya in the West contains high MPI regions, such as Turkana, in the north, some low MPI regions, such as Kitale, and also a number of regions with mid-level poverty. Therefore, it is an obvious advantage to be able to consider MPI at this level.","aeee1b73":"#### Figure: Calculated Administration Level 2 MPI - Ghana <a class=\"anchor\" id=\"fig_calc_admin2_mpi_ghana\"\/>","18007dda":"#### Figure: Calculated Province (Sub-national) MPI - Cambodia <a class=\"anchor\" id=\"fig_calc_admin1_mpi_cambodia\"\/>","9d89e95a":"### Mapping DHS Features to MPI Indicators <a class=\"anchor\" id=\"mapping_dhs_features\"\/>\n***\nThe following features from the DHS dataset have been identified as corresponding to the MPI features defined above.\n\n**Identifiers**\n\nhousehold, household member\n-  HV001 - Cluster number\n-  HV002 Household number \nbirths\n-  V001 Cluster number \n-  V002 Household number \n\n\n***Features***\n\nThere are a huge number of features available in the DHS datasets, too many to explore all of them here. So I have selected the features that match the most closely to the features used to caluclate MPI, as well as a number which I intuitively believe could be relevant to estimating poverty. \nThe relevant features in this case are:\n\n**Health**\n    -  V206 - Total number of sons who have died (children)\n    -  V207 - Total number of daughters who have died  (children)\n    -  b7 - Age at death of the child in completed months g (children)\n    -  HA1 Women's age in years. \n    -  HC31 : Child's year of birth \n    -  HC70 Ht\/A Standard deviations (according to WHO) \n    -  HC73 BMI standard deviations (according to WHO) (household_member)\n    -  HA40 Body mass index for respondent.  (household_member)\n\n**Education**\n    -  HV108 - Education in single years (household_member)\n    -  HV110 Whether the household member is still in school \n        ** Note: This question is no longer part of the DHS VI core questionnaire so there is unfortunately no data available for the dataset year chosen. Instead we can use HV121\n    -  HV121 - Household member attended school during current school year.\n\n**Standard of Living**\n    -  HV206 - Electricity\n    -  HV201, HV204 - Drinking water\n    -  HV205, HV225 - Sanitation\n    -  HV226 - Cooking fuel\n    -  HV213 - Floor\n    \n    **Assets**\n        **Information**\n         -  HV207 Radio\n         -  HV208 - Television\n         -  HV243A - Mobile telephone\n         -  HV221 - Telephone (non-mobile)\n         **Mobility**\n         -  HV210 Bicycle\n         -  HV211 Motorcycle or Scooter\n         -  HV212 Car or Truck\n         -  HV243C : Animal-drawn cart\n         -  HV243D : Boat with a motor\n         **Livelihood**\n         -  HV209 - Refrigerator\n         -  HV244 : Own land usable for agriculture\n         -  HV245 : Hectares for agricultural land\n         -  HV246 : Livestock, herds or farm animals\n\n**Other**\n    -  HV009 : Total members in household\n    -  HV247 : Any member of the household has a bank account","fc8edb46":"It is interesting to note that there are no\/not many loans in the poorest regions. This becomes even more obvious when examining the map at this administrative level.","47637a17":"#### Figure: Calculated Province (Sub-national) MPI - Rwanda <a class=\"anchor\" id=\"fig_calc_admin1_mpi_rwanda\"\/>","cb582b7a":"### Tanzania (National MPI 0.284)  <a class=\"anchor\" id=\"tanzania\"\/>\n***\nTanzania is one of a number of countries for which Kiva does not appear have subnational MPI scores so it is not possible to calculate a correlation as was done for other countries. Nonetheless, using the developed calulation method, we can still calculate the scores for Tanzania.","fc23f43e":"# Kiva Crowdfunding - Targeting Poverty at a Sub-national Level\n***\n\nKiva is an online crowdfunding platform to extend financial services to poor and financially excluded people around the world.\n\nThis notebook series is my contribution to the Data Science for Good: Kiva Crowdfunding challenge. The objective is to help Kiva to better understand their borrowers and build more localized models to estimate the poverty levels in the regions where Kiva has active loans.\n\nKiva Crowdfunding notebook series:\n  - [Part I - Understanding Poverty]\n  - [Part II - Targeting Poverty at a National Level]\n  - [Part III - Targeting Poverty at a Subnational Level]\n  - [Part IV - Adding a Financial Dimension to the MPI]\n  - [Part V - Investigating Nightlight as a Poverty Indicator]\n\n[Part I - Understanding Poverty]: https:\/\/www.kaggle.com\/taniaj\/kiva-crowdfunding-understanding-poverty\n[Part II - Targeting Poverty at a National Level]: https:\/\/www.kaggle.com\/taniaj\/kiva-crowdfunding-targeting-poverty-national\n[Part III - Targeting Poverty at a Subnational Level]: https:\/\/www.kaggle.com\/taniaj\/kiva-crowdfunding-targeting-poverty-sub-nat\n[Part IV - Adding a Financial Dimension to the MPI]: https:\/\/www.kaggle.com\/taniaj\/kiva-crowdfunding-adding-a-financial-dimension\n[Part V - Investigating Nightlight as a Poverty Indicator]: https:\/\/www.kaggle.com\/taniaj\/kiva-crowdfunding-investigating-nightlight\n\nThe series in broken down into five notebooks. The first notebook is an exploratory analysis of the data to get a feeling for what we are working with. The second notebook examines external datasets and looks at how MPI and other indicators can be used to get a better understanding of poverty levels of Kiva borrowers at a national level. The third notebook examines external data at a subnational level to see how Kiva can get MPI scores based on location at a more granular level than is currently available. The fourth notebook attepts to build a better poverty index at a subnational level by adding a financial dimension. The fifth notebook examines nightlight data as a poverty indicator.\n\nThis is the third notebook of the series and together with Part IV, the most relevant to directly addressing the Kiva challenge.\nThe notebook focuses on the Demographic and Health Surveys (DHS) dataset, which is the result of the DHS Program funded by the U.S. Agency for International Development (USAID). This is the only dataset that the author has found, that has extensive data at a very granular level across many countries. The dataset is used to reproduce the MPI at a more granular level than is currently available to Kiva (ie: more granualar than the Kiva sub_national data).\n\nThe problem of finding a better poverty estimate is approached in two ways. \nThe first is an attempt to reproduce the index by following the methodology used by the Oxford Poverty & Human Development Initiative (OPHI) to build the MPI. Because we have raw data available at a very granular level, we can thus calculate MPI scores at, for example a county level, or any other even more granular groupings as required.\nThe second approach (Part IV) combines features which are not currently used as part of the OPHI MPI method to add other dimensions to the MPI and build an index which could be more useful to Kiva.\n\nKenya was chosen as a country to focus on initially due to its high number of Kiva loans and also as  one of the few high MPI countries the author has visited. Additionally, there is simply too much dirty data to consider all countries at once. After the initial model was built, several other countries where Kiva has loans were chosen for testing.\n\nNote: The code has been written with a focus on understandability rather than optimization, although optimization is also a secondary aim.\n\n### Contents\n***\n   1. [Data Gathering](#data_gathering)\n   2. [Preprocessing](#preprocessing)\n   3. [Extrating MPI Features from DHS Data](#extracting_mpi_features)\n       * [Definition of MPI (OPHI)](#mpi_def)\n       * [Mapping DHS Features to MPI Indicators)](#mapping_dhs_features)\n       * [Household Data](#household_data)\n       * [Household Member Data](#household_member_data)\n       * [Child Data](#child_data)\n   4. [Calculating MPI with DHS Data](#calculating_mpi)\n       * [Treatment of households with missing observations in at least one indicator](#missing_observations)\n       * [Treatment of households with non-eligible population](#non_eligible_popluation)\n       * [Kenya (National MPI 0.187)](#kenya)\n           * [Figure: OPHI Province (Sub-national) MPI - Kenya](#fig_ophi_admin1_mpi_kenya)\n           * [Figure: Calculated Province (Sub-national) MPI - Kenya](#fig_calc_admin1_mpi_kenya)\n           * [Figure: Calculated Administration Level 1 (County) MPI - Kenya](#fig_calc_admin2_mpi_kenya)\n           * [Figure: Calculated Administration Level 2 MPI - Kenya](#fig_calc_admin3_mpi_kenya)\n   5. [Comparing Calculated MPI to OPHI MPI](#compare_dhs_ophi_mpi)\n       * [Figure: Kiva Loans + Calculated County MPI - Kenya](#fig_loans_vs_calc_admin2_mpi_kenya)\n   6. [Scalability Testing](#scalability_testing)\n       * [Zimbabwe (National MPI 0.152)](#zimbabwe)\n           * [Figure: OPHI Province (Sub-national) MPI - Zimbabwe](#fig_ophi_admin1_mpi_zimbabwe)\n           * [Figure: Calculated Province (Sub-national) MPI - Zimbabwe](#fig_calc_admin1_mpi_zimbabwe)\n           * [Figure: Calculated Administration Level 2 MPI - Zimbabwe](#fig_calc_admin2_mpi_zimbabwe)\n       * [Cambodia  (National MPI 0.146)](#cambodia)\n           * [Figure: OPHI Province (Sub-national) MPI - Cambodia](#fig_ophi_admin1_mpi_cambodia)\n           * [Figure: Calculated Province (Sub-national) MPI - Cambodia](#fig_calc_admin1_mpi_cambodia)\n           * [Figure: Calculated Administration Level 2 MPI - Cambodia](#fig_calc_admin2_mpi_cambodia)\n       * [Rwanda (National MPI 0.259)](#rwanda)\n           * [Figure: OPHI Province (Sub-national) MPI - Rwanda](#fig_ophi_admin1_mpi_rwanda)\n           * [Figure: Calculated Province (Sub-national) MPI - Rwanda](#fig_calc_admin1_mpi_rwanda)\n           * [Figure: Calculated Administration Level 2 MPI - Rwanda](#fig_calc_admin2_mpi_rwanda)\n       * [Tanzania (National MPI 0.284)](#tanzania)\n           * [Figure: Calculated Province (Sub-national) MPI - Tanzania](#fig_calc_admin1_mpi_tanzania)\n           * [Figure: Calculated Administration Level 2 MPI - Tanzania](#fig_calc_admin2_mpi_tanzania)\n       * [Ghana (National MPI 0.156)](#ghana)\n           * [Figure: Calculated Province (Sub-national) MPI - Ghana](#fig_calc_admin1_mpi_ghana)\n           * [Figure: Calculated Administration Level 2 MPI - Ghana](#fig_calc_admin2_mpi_ghana)\n       * [Summary](#summary)\n   7. [Conclusion](#conclusion)\n   8. [References](#references)","d63728f3":"## 2. Preprocessing <a class=\"anchor\" id=\"preprocessing\"\/>\n***\nEven the Kenya datasets alone were very large so it was necessary to trim them down to the necessary data before uploading. This section defines the preprocess_dhs_data function that does this trimming and writes the result to csv files which are later simply read in. To run the full processing from original datasets, uncomment the last line to call the function. ","5706eecd":"## Joining Kiva Loan Data\n***\nSince the whole purpose of this work is to enable Kiva to estimate the level of poverty of their borrows more accurately, what is needed is a join between the Kiva loan data and the MPI at a county level. (This notebook will work at a county level when joning Kiva data even though, as shown in the previous section, it is possible to get more granular. Reason being that the next level down - county - will be an improvenment for Kiva and 1. is more likely to be applicable across countries as data should be more readily available and 2. the complexity of this notebook is reduced.)\n\nSince a direct mapping of Kiva loan data to counties is not available, the join will be done spatially by checking in which county polygon the latitude and longitude of the Kiva borrower lies.","8efcfc06":"## 1. Data Gathering <a class=\"anchor\" id=\"data_gathering\"\/>\n***\nThe original DHS datasetes used in this kernel are not made public because they are very large and were obtained privately from DHS after going through thier data request procedure. This, however, should not be a problem if Kiva want to obtain and use the original data for modelling purposes, as it was a relatively quick and simple process to register a project and gain access.","ba7b9aed":"#### Figure: Calculated Province (Sub-national) MPI - Zimbabwe <a class=\"anchor\" id=\"fig_calc_admin1_mpi_zimbabwe\"\/>","32d357e3":"#### Figure: Calculated Administration Level 2 MPI - Tanzania  <a class=\"anchor\" id=\"fig_calc_admin2_mpi_tanzania\"\/>","14149965":"### Ghana (National MPI 0.156)  <a class=\"anchor\" id=\"ghana\"\/>","1cfba1a5":"At the county level, the county with the least data has 1270 household members and 165 of those classified as poor. At the next level of granularity there is an administrative region with data for only 24 household members and 0 of those classified as poor. Therefore, in this notebook the next administrative level down from the county level (which is sometimes known as admin level 2 and sometimes as level 3, depending on the country) will not be given further consideration. Although it has been shown that it is possible using this method to go down to this level, there is probably crrently not enough data for it to be effective.","a37c0c6a":"Looking at the plot of calculated MPI at administrative level 2 also reveals varying MPI scores in level 2 regions belonging to the same county. Therefore, looking at MPI at this level of granularity also brings advantages. The question, is there enough data to reliably calculate MPI at these sort of levels for Kenya and other countries?","cead5163":"The correlation and p-value confirm that the index that has been built seems to match up well with the OPHI index and the two Folium map plots below also confirm this. The RMSE is also very low.","37e5af5f":"#### Figure: Calculated Administration Level 2 MPI - Zimbabwe <a class=\"anchor\" id=\"fig_calc_admin2_mpi_zimbabwe\"\/>","6d801f82":"## Kenya (National MPI 0.187)\n***\nKenya is the country on which this model was initially developed, so lets have a look at the results for Kenya.","3710dfea":"### Household Member Data <a class=\"anchor\" id=\"household_member_data\"\/>\n***\nThis section defines functions to process the household member dataset in order to extract the relevant indicator information. The indicators extracted here are: \n\n    -  malnourishment, \n    -  school attainment deprivation and\n    -  school attendance deprivation\n    \nThe data is then aggregated to get the indicators at a household level so that the entries can later be joined to the household dataset.","0147a961":"The correlation and RMSE show an even better match between the calculated MPI and OPHI MPI than was observed with the Kenya data, meaning the model also holds for Rwanda.","4cae9f66":"The correlation and RMSE show an even better match between the calculated MPI and OPHI MPI than was observed with the Kenya data, meaning the model also holds for Cambodia.","c0d0dfc9":"## Scalability Testing <a class=\"anchor\" id=\"scalability_testing\"\/>\n***\nNow that we have a, hopefully, generic model developed on Kenya datasets, lets see how well it copes with data from other countries.\n\n### Zimbabwe (National MPI 0.152) <a class=\"anchor\" id=\"zimbabwe\"\/>\n***","81b14e33":"#### Figure: Calculated Administraton Level 1 MPI - Kenya <a class=\"anchor\" id=\"fig_calc_admin2_mpi_kenya\"\/>","dd8c90a8":"Note: In the next step the datasetes are spatially joined using geopandas sjoin. This does not seem to work on Kaggle servers (due to a problem with the rtree dependency. Ref: https:\/\/www.kaggle.com\/product-feedback\/53008) but works on any system where the dependencies are set up correctly. To overcome this, the author has run sjoin locally, saved the result and read it back in when running this kernel on Kaggle servers. To run sjoin, simply uncomment below.","710681bc":"The correlation and RMSE show an even better match between the calculated MPI and OPHI MPI than was observed with the Kenya data, meaning the model also holds for Zimbabwe.","4fd9c4b9":"## 8. References <a class=\"anchor\" id=\"references\"\/>\n***\n- [Demographic and Health Surveys Program Website](https:\/\/dhsprogram.com\/Data\/)\n- [Demographic and Health Surveys Program Recode (PDF)](https:\/\/dhsprogram.com\/pubs\/pdf\/DHSG4\/Recode6_DHS_22March2013_DHSG4.pdf)\n- [HDR Technical Notes (PDF)](http:\/\/dev-hdr.pantheonsite.io\/sites\/default\/files\/hdr2016_technical_notes_0.pdf)\n- [Kiva Website](https:\/\/www.kiva.org\/)\n- [Mapshaper](http:\/\/mapshaper.org\/)\n- [The Humanitarian Data Exchange](https:\/\/data.humdata.org\/)\n- [UNDP Specifications for Computation of the MPI (PDF)](http:\/\/hdr.undp.org\/sites\/default\/files\/specifications_for_computation_of_the_mpi_0.pdf)","ab238d26":"#### Figure: Calculated Province (Sub-national) MPI - Ghana <a class=\"anchor\" id=\"fig_calc_admin1_mpi_ghana\"\/>","5c7ff185":"## 3. Extrating MPI Features from DHS Data <a class=\"anchor\" id=\"extracting_mpi_features\"\/>\n***\nIn this section the DHS datasets are preprocessed in order to extract the features relevant to calculation a MPI according to the OPHI method, as well as other features which are deemed to be interesting for our problem.","15acc61a":"### Definition of MPI (OPHI) <a class=\"anchor\" id=\"mpi_def\"\/>\n***\n\nThe following are features included in the MPI as defined by the Human Development Report. http:\/\/dev-hdr.pantheonsite.io\/sites\/default\/files\/hdr2016_technical_notes_0.pdf\n\n\n**Definitions of poverty states**\n1. A household is considered **multidimensionally poor** (or MPI poor) if the total of weighted\ndeprivations (deprivation score) is equal to 1\/3 or more.\n2. A household is considered **severely multidimensionally poor** if the deprivation score is 1\/2 or\nmore.\n3. A household is considered **near-MPI poor** if the deprivation score is 1\/5 or more but less than\n1\/3.\n4. A household is considered **deprived but not near-MPI poor** if the deprivation score is positive\nbut less than 1\/5.\n5. If a household is deprived, then all its members are deprived.\n6. Dimensions included in the MPI are education, health, and living standards; all are equally\nweighted by 1\/3 each.\n\n**Education:**\n    - School attainment: no household member has completed at least six years of schooling.\n    - School attendance: a school-age child (up to grade 8) is not attending school.\n\n\n**Health:**\n    - Nutrition: a household member (for whom there is nutrition information) is malnourished, as measured by the body mass index for adults (women ages 15\u201349 in most of the surveys) and by the height-for-age z-score calculated based on World Health Organization standards for children under age 5.\n    - Child mortality: a child has died in the household within the five years prior to the survey.\n\n\n**Standard of living:**\n    - Electricity: not having access to electricity.\n    - Drinking water: not having access to clean drinking water or having access to clean drinking water through a source that is located 30 minutes away or more by walking.\n    - Sanitation: not having access to improved sanitation facilities or having access only to shared improved sanitation facilities.\n    - Cooking fuel: using \u201cdirty\u201d cooking fuel (dung, wood or charcoal).\n    - Having a home with dirt, sand or dung floor.\n    - Assets:\n        - not having at least one asset related to access to information (radio, television or telephone) or \n        - having at least one asset related to information but not having at least one asset related to mobility (bike, motorbike, car, truck, animal cart or motorboat) or\n        - at least one asset related to livelihood (refrigerator, arable land or livestock).\n        ","3422d833":"#### Figure: Calculated Province (Sub-national) MPI - Kenya <a class=\"anchor\" id=\"fig_calc_admin1_mpi_kenya\"\/>","77de85d1":"### Household Data <a class=\"anchor\" id=\"household_data\"\/>\n***\nThis section defines functions to process the household dataset in order to extract the relevant indicator information. The indicators extracted here are: \n\n    -  electricity deprevation, \n    -  clean water deprivation, \n    -  sanitation deprivation,\n    -  cooking fuel deprivation,\n    -  imrpoved flooring deprivation and\n    -  asset deprivation.\n    \n This dataset also provides the total number of household members, which is later used to calculate the MPI.","45e0916d":"#### Figure: OPHI Province (Sub-national) MPI - Cambodia <a class=\"anchor\" id=\"fig_ophi_admin1_mpi_cambodia\"\/>","6c1c414d":"Note that the MPI threshold scale for plotting has been set differently for each country in order to get the best visualisations possible. The MPI scores from Zimbabwe are actually a lot lower in comparison to those from Kenya even though the colours displayed on the maps are similar.","f3545a8b":"### Births Data<a class=\"anchor\" id=\"births_data\"\/>\n***\nThis section defines functions to process the births dataset in order to extract the relevant indicator information. The only information extracted out of this dataset is the number of children per household who have died within five years of the survey.    ","d58f201e":"### Combined Dataset\n***\nThe data sets are now be combined into a single dataset at the household level.","e56048a0":"Note: Kiva currently doesn't have an MPI available at a more granular level than national for Tanzania. Therefore the OPHI MPI correlation comparison and plot are skipped for Tanzania. ","8ab71fd6":"#### Figure: Calculated Province (Sub-national) MPI - Tanzania <a class=\"anchor\" id=\"fig_calc_admin1_mpi_tanzania\"\/>","a7d61e5e":"#### Figure: Calculated Administration Level 2 MPI - Rwanda <a class=\"anchor\" id=\"fig_calc_admin2_mpi_rwanda\"\/>","55321146":"#### Figure: OPHI Province (Sub-national) MPI - Ghana <a class=\"anchor\" id=\"fig_ophi_admin1_mpi_ghana\"\/>","65b13d78":"The correlation and RMSE show a good match between the calculated MPI and OPHI MPI, similar to the Kenya data, meaning the model also holds for Ghana.","d82870ca":"### Cambodia (National MPI 0.146)  <a class=\"anchor\" id=\"cambodia\"\/> \n***","71adabee":"#### Figure: Calculated Administration Level 2 MPI - Cambodia <a class=\"anchor\" id=\"fig_calc_admin2_mpi_cambodia\"\/>","40c6524a":"#### Figure: OPHI Province (Sub-national) MPI - Zimbabwe <a class=\"anchor\" id=\"fig_ophi_admin1_mpi_zimbabwe\"\/>","0b998a5d":"It was necessary to manually map many of the names of regions provided in Cambodia datasets to get matches due to use of native language vs English, including special characters, and also different region aggregation across datasets. This mapping is done in the next step.","c32b89c7":"#### Figure: OPHI Province (Sub-national) MPI - Rwanda <a class=\"anchor\" id=\"fig_ophi_admin1_mpi_rwanda\"\/>","2a295342":"Note: It was quite fiddly to match the province names of Cambodia due to special characters in the language, different translations and also changes in provinces over time. Most were matched in the end but not all (some had a single mpi entry between what are now two different provinces) so keep in mind when looking at the map, some of the light regions may actually be missing MPI values.\nTODO: Clean this up \/ plot missing values as black instead of 0.","438793ba":"\nNotice there is a much better level of matching between names at the administrative level two, as shown by the above plot.","c8b8fe82":"## 6. Calculating MPI with DHS Data <a class=\"anchor\" id=\"calculating_mpi\"\/>\n***\nThe data can now be matched to MPI data spatially (at various administrative levels) to \n    1.  look at how closely the MPI calculated here reflects the given MPI scores and\n    2.  assign MPI scores at a more granual level that was previously available.\n\n### Treatment of households with missing observations in at least one indicator <a class=\"anchor\" id=\"missing_observations\"\/>\nA household is excluded from the MPI calculation if there is missing information for one or more indicators. MPI estimates can be based only on the sample of households with available information in all 10 indicators.\n\n### Treatment of households with non-eligible population <a class=\"anchor\" id=\"non_eligible_popluation\"\/>\nA household is considered non-eligible for the MPI estimation if estimation of its deprivation in the health dimension is not possible. This happens when the household does not have women of age between 15 and 49 and it does not have children of age under 60 months (under-5), and the BMI measurements were not taken for men. In this situation, it is not possible to observe any deprivation in the health dimension.","d5bc2a6a":"The same goes for the calculated MPI plot - it was not possible to match all provinces up between both datasets (DHS and cambodia geo data). A suggestion would be to search for a more up-to-date source of geo data for Cambodia, however this will be left for now. The MPIs have been calculated for every province, just not all have been plotted above.","3df8d487":"#### Figure: Calculated Administration Level 2 MPI - Kenya <a class=\"anchor\" id=\"fig_calc_admin3_mpi_kenya\"\/>","e836c9ed":"#### Figure: Kiva Loans + Calculated County MPI - Kenya <a class=\"anchor\" id=\"fig_loans_vs_calc_admin2_mpi_kenya\"\/>"}}