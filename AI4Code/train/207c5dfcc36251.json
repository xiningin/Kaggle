{"cell_type":{"ef1167ca":"code","3b7582c9":"code","08494700":"code","8ea7761b":"code","6248b1fb":"code","9e4d65f2":"code","8ceffd9f":"code","9a6848b3":"code","2f5b284f":"code","4839656a":"code","51ec5a04":"code","173673a0":"code","6c97c621":"code","ffccab70":"code","9ff78fb5":"markdown","030651d1":"markdown","cd9cafd3":"markdown","1b5704c5":"markdown","c47e53e9":"markdown","2622e9a9":"markdown","a1f8d52a":"markdown","dc9b44bb":"markdown"},"source":{"ef1167ca":"import numpy as np\nimport pandas as pd\n\n# import sklearn\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.metrics import mean_squared_error\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","3b7582c9":"train_data_no_name = pd.read_csv(\"..\/input\/nasa-cmaps\/CMaps\/train_FD001.txt\", sep = \"\\s+\", header = None)\ntest_data_no_name = pd.read_csv(\"..\/input\/nasa-cmaps\/CMaps\/test_FD001.txt\", sep = \"\\s+\", header = None)\ntrue_rul_no_name = pd.read_csv('..\/input\/nasa-cmaps\/CMaps\/RUL_FD001.txt', sep = '\\s+', header = None)","08494700":"# Let's add columns' names for better identification\ncolumns = {0:'engineNumber',1:'cycleNumber',2:'opSetting1',3:'opSetting2',4:'opSetting3',5:'sensor1',6:'sensor2',\n           7:'sensor3',8:'sensor4',9:'sensor5',10:'sensor6',11:'sensor7',12:'sensor8',13:'sensor9',14:'sensor10',\n           15:'sensor11',16:'sensor12',17:'sensor13',18:'sensor14',19:'sensor15',20:'sensor16',\n           21:'sensor17',22:'sensor18',23:'sensor19',24:'sensor20',25:'sensor21'}","8ea7761b":"train_data = train_data_no_name.rename(columns=columns)\ntest_data = test_data_no_name.rename(columns=columns)\ntrue_rul = true_rul_no_name.rename(columns={0: 'RUL'})\n#train_data.describe()\ntest_data.describe()","6248b1fb":"true_rul.describe()","9e4d65f2":"# How many engines are there?\nnum_machines = np.unique(train_data['engineNumber']).shape[0]\nnum_machines","8ceffd9f":"# After how many cycles does each engine fail?\nnum_cycles_to_failure = train_data.groupby('engineNumber')['cycleNumber'].count()\nnum_cycles_to_failure[:10]","9a6848b3":"num_cycles_to_failure[-1:]","2f5b284f":"plt.figure(figsize = (16, 21))\n\nfor i in range(21):\n    temp_data = train_data.iloc[:,i+5]\n    plt.subplot(7,3,i+1)\n    plt.boxplot(temp_data)\n    plt.title(\"Sensor \" + str(i+1) + \", column \"+ str(i+6))\nplt.show()","4839656a":"plt.figure(figsize = (15, 21))\nfor i,j in enumerate([6, 7, 8, 11, 12, 13, 15, 16, 17, 18, 19, 21, 24, 25]):\n    temp = train_data.iloc[:, j]\n    plt.subplot(7,3, i+1)\n    sns.kdeplot(temp, legend = False)\n    plt.title(\"Sensor \" + str(j-4) + \", column \"+ str(j))\nplt.show()","51ec5a04":"plt.figure(figsize = (15, 21))\nfor i,j in enumerate([6, 7, 8, 11, 12, 13, 15, 16, 17, 18, 19, 21, 24, 25]):\n    temp_train = train_data.iloc[:, j]\n    temp_test = test_data.iloc[:, j]\n    plt.subplot(7,3, i+1)\n    sns.kdeplot(temp_train, legend = False, color = \"blue\", label = \"Train\")\n    sns.kdeplot(temp_test, legend = False, color = \"red\", label = \"Test\")\n    plt.title(\"Sensor \" + str(j-4) + \", column \"+ str(j+1))\n    plt.legend()\nplt.show()","173673a0":"# columns_to_keep = ['sensor2', 'sensor3', 'sensor4', 'sensor7', 'sensor8', 'sensor9',\ncolumns_to_keep = ['cycleNumber', 'sensor2', 'sensor3', 'sensor4', 'sensor7', 'sensor8', 'sensor9',\n                   'sensor11', 'sensor12', 'sensor13', 'sensor14', 'sensor15',\n                   'sensor17', 'sensor20', 'sensor21']\n\n# columns_to_drop=['cycleNumber', 'opSetting1', 'opSetting2', 'opSetting3',\ncolumns_to_drop=['opSetting1', 'opSetting2', 'opSetting3',\n                 'sensor1','sensor5','sensor6','sensor10','sensor16','sensor18', 'sensor19']","6c97c621":"train_data_ = train_data.drop(columns=columns_to_drop) #.values\ntest_data_  = test_data.drop(columns=columns_to_drop)","ffccab70":"train_data_.describe()","9ff78fb5":"This dataset has 26 columns (as well as the datasets for the other 3 scenarios). Because of Python's numbering convention, the columns are numbered from 0 to 25. Description of each column is as follows:\n\n* `Column 1`: Corresponds to engine number (This column is indexed 0 because of Python's numbering convention)\n* `Column 2`: Corresponds to cycle number. If engine 1 fails after 192 cycles, the entries of second column for engine 1 will go from 1 to 192. Similarly for other engines. \n* `Columns 3,4,5`: 3 operational settings\n* `Columns 6-26`: 21 sensor measurements\n\n**Note**: Hence, we will always refer to the first column as column 1 even though it is indexed as 0 in Python. Similarly for other columns.","030651d1":"An algorithm generalizes well (i.e., its performance on unseen data is good) if unseen data is similar in distribution to training data. Unseen data need not be exactly of same distribution as of training data but it should not be very different from training data.\n\nSo let's compare the distribution of training and test data:\n","cd9cafd3":"### Comparison with test dataset","1b5704c5":"## Probability density distributions\nFor the relevant sensors","c47e53e9":"# Dataset simplification","2622e9a9":"From the above plot we see that **columns 6, 10, 11, 15, 21, 23 and 24** contain constant values\n\n - These columns corresponds to **sensors 1,  5,  6, 10, 16, 18 and 19**\n - Useful sensors are therefore 2, 3, 4, 7, 8, 9, 11, 12 ,13 ,14 ,15 ,17, 20, 21","a1f8d52a":"## Boxplots of sensor data","dc9b44bb":"# Data description"}}