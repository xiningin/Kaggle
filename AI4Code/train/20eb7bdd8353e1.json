{"cell_type":{"483ede72":"code","5588370f":"code","69abb774":"code","d430f6f2":"code","f9124bd8":"code","06551190":"code","19e6245c":"code","4dababeb":"code","6715b1c0":"code","17bbf3d9":"code","531aab75":"code","76ff1a48":"code","f80c4563":"code","360d5643":"code","4d6bd763":"code","351d86f2":"code","33b03c48":"code","7d75c498":"code","d5f72e74":"code","f8e721c6":"code","79dbdf37":"code","5f8641c9":"code","b2fbddc2":"code","72b59006":"code","1517f02e":"code","b0e0e05f":"code","533565f9":"code","6f59b050":"code","8590877a":"code","0ef9c00a":"code","9413bbab":"code","5bb96956":"code","68fbd85c":"code","72e67d95":"code","b3d36f90":"code","a8af3277":"code","68298234":"code","113b3d73":"code","0f291550":"code","27245b6a":"code","772e703d":"markdown","792f9479":"markdown","737d9062":"markdown","3ad13fef":"markdown","1bc89bc7":"markdown","b4b4d71a":"markdown","b767d6fd":"markdown","96e0c921":"markdown","acc5e503":"markdown","4b9d39b2":"markdown","ce9791a2":"markdown","99434dc8":"markdown","7f527893":"markdown","7bf2916b":"markdown","48cb45f5":"markdown","2232f635":"markdown","3ed3c47c":"markdown","5dc1975e":"markdown","3be3b303":"markdown","bf64c97a":"markdown","d76e0487":"markdown","24de3341":"markdown","38f1667f":"markdown"},"source":{"483ede72":"import pandas as pd\nfrom pandas_datareader import data as pd_data","5588370f":"start_date = '2014-01-01'\nend_date = '2018-01-01'\nSRC_DATA_FILENAME = 'goog_data.pkl'\n\ntry:\n    goog_data2 = pd.read_pickle(SRC_DATA_FILENAME)\n    print('File found...')\nexcept FileNotFoundError:\n    print('File Not Found! Downloading the data and creating the pickle file...')\n    goog_data2 = pd_data.DataReader('GOOG', 'yahoo', start_date, end_date)\n    goog_data2.to_pickle(SRC_DATA_FILENAME)","69abb774":"goog_data = goog_data2.tail(620) # pick the 620 most recent observations\nlows = goog_data[\"Low\"]\nhighs = goog_data[\"High\"]\n\n#print(lows.head(),\"\\n\\n\")\n#print(highs.head())\ngoog_data.head(3)","d430f6f2":"import matplotlib.pyplot as plt","f9124bd8":"fig = plt.figure()\nax1 = fig.add_subplot(111, ylabel='Google price in $')\n\nhighs.plot(ax=ax1, color='c', lw=2.)\nlows.plot(ax=ax1, color='y', lw=2.)\n\nplt.hlines(highs.head(200).max(), highs.index.values[0], highs.index.values[-1], linewidth=2, color='g')\nplt.hlines(lows.head(200).min(), lows.index.values[0], lows.index.values[-1], linewidth=2, color='r')\n\nplt.axvline(linewidth=2, color='b', x=lows.index.values[200], linestyle=':')\n\nzoom = 2.0\nw, h = fig.get_size_inches()\nfig.set_size_inches(w * zoom, h * zoom)\n\nplt.show()","06551190":"import numpy as np","19e6245c":"goog_data_signal = pd.DataFrame(index=goog_data.index)\ngoog_data_signal.tail(3)","4dababeb":"goog_data_signal['price'] = goog_data['Adj Close']\ngoog_data_signal.tail(3)","6715b1c0":"def trading_support_resistance(df, bin_width=20): # 20 is the rolling window, the memory of the support and resistance...\n    df['sup_tolerance'] = pd.Series(np.zeros(len(df)))\n    df['res_tolerance'] = pd.Series(np.zeros(len(df)))\n    df['sup_count'] = pd.Series(np.zeros(len(df)))\n    df['res_count'] = pd.Series(np.zeros(len(df)))\n    df['sup'] = pd.Series(np.zeros(len(df)))\n    df['res'] = pd.Series(np.zeros(len(df)))\n    df['positions'] = pd.Series(np.zeros(len(df)))\n    df['signal'] = pd.Series(np.zeros(len(df)))\n    in_support = 0\n    in_resistance = 0\n    \n    TOLERANCE = 0.2\n    \n    for x in range((bin_width-1) + bin_width, len(df)):\n        df_section = df[x - bin_width:x + 1]\n        support_level = min(df_section['price'])\n        resistance_level = max(df_section['price'])\n        range_level = resistance_level - support_level\n        df['res'][x] = resistance_level\n        df['sup'][x] = support_level\n        df['sup_tolerance'][x] = support_level + TOLERANCE*range_level\n        df['res_tolerance'][x] = resistance_level - TOLERANCE*range_level\n        \n        if df['price'][x] >= df['res_tolerance'][x] and df['price'][x] <= df['res'][x]:\n            in_resistance += 1\n            df['res_count'][x] = in_resistance\n        elif df['price'][x] <= df['sup_tolerance'][x] and df['price'][x] >= df['sup'][x]:\n            in_support += 1\n            df['sup_count'][x] = in_support\n        else:\n            in_support = 0\n            in_resistance = 0\n        \n        if in_resistance > 2:\n            df['signal'][x] = 1\n        elif in_support > 2:\n            df['signal'][x] = 0\n        else:\n            df['signal'][x] = df['signal'][x-1]\n    \n    df['positions'] = df['signal'].diff()\n\ntrading_support_resistance(goog_data_signal)\ngoog_data_signal","17bbf3d9":"goog_data_signal.tail()","531aab75":"import matplotlib.pyplot as plt","76ff1a48":"fig = plt.figure()\nax1 = fig.add_subplot(111, ylabel='Google Price in $')\ngoog_data_signal['sup'].plot(ax=ax1, color='g', lw=2.)\ngoog_data_signal['res'].plot(ax=ax1, color='b', lw=2.)\ngoog_data_signal['price'].plot(ax=ax1, color='r', lw=2.)\nax1.plot(goog_data_signal.loc[goog_data_signal.positions == 1.0].index, \n         goog_data_signal.price[goog_data_signal.positions == 1.0], \n         '^', markersize=7, color='k', label='buy')\nax1.plot(goog_data_signal.loc[goog_data_signal.positions == -1.0].index, \n         goog_data_signal.price[goog_data_signal.positions == -1.0], \n         'v', markersize=7, color='k', label='sell')\n\nzoom = 2.0\nw, h = fig.get_size_inches()\nfig.set_size_inches(w * zoom, h * zoom)\n\nplt.legend()\nplt.show()","f80c4563":"import statistics as stats","360d5643":"close = goog_data['Close']\n\ntime_period = 20 # number of days over which to average\nhistory = [] # will store the last 20 prices, when\nsma_values = [] # to track simple moving average values\nfor close_price in close:\n    history.append(close_price)\n    if len(history) > time_period: # we remove oldest price because we only average over last 'time_period' prices\n        del (history[0]) # it will start deleting when the number of observations is greater than 'time_period'\n    sma_values.append(stats.mean(history))\n\n# creating new columns in the 'goog_data' DataFrame\ngoog_data = goog_data.assign(ClosePrice=pd.Series(close, index=goog_data.index))\ngoog_data = goog_data.assign(Simple20DayMovingAverage=pd.Series(sma_values, index=goog_data.index))\n\nclose_price = goog_data['ClosePrice']\nsma = goog_data['Simple20DayMovingAverage']","4d6bd763":"fig = plt.figure()\nax1 = fig.add_subplot(111, ylabel='Google price in $')\n\nclose_price.plot(ax=ax1, color='g', lw=2., legend=True)\nsma.plot(ax=ax1, color='r', lw=2., legend=True)\n\nzoom = 2.0\nw, h = fig.get_size_inches()\nfig.set_size_inches(w * zoom, h * zoom)\n\nplt.show()","351d86f2":"num_periods = 20 # number of days over which to average\nK = 2 \/ (num_periods + 1) # smoothing constant\nema_p = 0\n\nema_values = [] # to hold computed EMA values\nfor close_price in close:\n    if (ema_p == 0): # first observation, EMA = current-price\n        ema_p = close_price\n    else:\n        ema_p = (close_price - ema_p) * K + ema_p\n\n    ema_values.append(ema_p)","33b03c48":"goog_data = goog_data.assign(ClosePrice=pd.Series(close, index=goog_data.index))\ngoog_data = goog_data.assign(Exponential20DayMovingAverage=pd.Series(ema_values, index=goog_data.index))\n\nclose_price = goog_data['ClosePrice']\nema = goog_data['Exponential20DayMovingAverage']","7d75c498":"fig = plt.figure()\nax1 = fig.add_subplot(111, ylabel='Google price in $')\n\nclose_price.plot(ax=ax1, color='g', lw=2., legend=True)\nema.plot(ax=ax1, color='b', lw=2., legend=True)\n\nzoom = 2.0\nw, h = fig.get_size_inches()\nfig.set_size_inches(w * zoom, h * zoom)\n\nplt.show()","d5f72e74":"num_periods_fast = 10 # time period for the fast EMA\nK_fast = 2 \/ (num_periods_fast + 1) # smoothing factor for fast EMA\nema_fast = 0\n\nnum_periods_slow = 40 # time period for slow EMA\nK_slow = 2 \/ (num_periods_slow + 1) # smoothing factor for slow EMA\nema_slow = 0\n\nema_fast_values = [] # we will hold fast EMA values for visualization purposes\nema_slow_values = [] # we will hold slow EMA values for visualization purposes\napo_values = [] # track computed absolute price oscillator values\n\nfor close_price in close:\n    if (ema_fast == 0): # first observation\n        ema_fast = close_price\n        ema_slow = close_price\n    else:\n        ema_fast = (close_price - ema_fast) * K_fast + ema_fast\n        ema_slow = (close_price - ema_slow) * K_slow + ema_slow\n\n    ema_fast_values.append(ema_fast)\n    ema_slow_values.append(ema_slow)\n    apo_values.append(ema_fast - ema_slow)","f8e721c6":"goog_data = goog_data.assign(ClosePrice=pd.Series(close, index=goog_data.index))\ngoog_data = goog_data.assign(FastExponential10DayMovingAverage=pd.Series(ema_fast_values, index=goog_data.index))\ngoog_data = goog_data.assign(SlowExponential40DayMovingAverage=pd.Series(ema_slow_values, index=goog_data.index))\ngoog_data = goog_data.assign(AbsolutePriceOscillator=pd.Series(apo_values, index=goog_data.index))\n\nclose_price = goog_data['ClosePrice']\nema_f = goog_data['FastExponential10DayMovingAverage']\nema_s = goog_data['SlowExponential40DayMovingAverage']\napo = goog_data['AbsolutePriceOscillator']","79dbdf37":"fig = plt.figure()\nax1 = fig.add_subplot(211, ylabel='Google price in $')\n\nclose_price.plot(ax=ax1, color='g', lw=2., legend=True)\nema_f.plot(ax=ax1, color='b', lw=2., legend=True)\nema_s.plot(ax=ax1, color='r', lw=2., legend=True)\n\nax2 = fig.add_subplot(212, ylabel='APO')\napo.plot(ax=ax2, color='black', lw=2., legend=True)\n\nzoom = 2.0\nw, h = fig.get_size_inches()\nfig.set_size_inches(w * zoom, h * zoom)\n\nplt.show()","5f8641c9":"num_periods_fast = 10 # fast EMA time period\nK_fast = 2 \/ (num_periods_fast + 1) # fast EMA smoothing factor\nema_fast = 0\nnum_periods_slow = 40 # slow EMA time period\nK_slow = 2 \/ (num_periods_slow + 1) # slow EMA smoothing factor\nema_slow = 0\nnum_periods_macd = 20 # MACD EMA time period\nK_macd = 2 \/ (num_periods_macd + 1) # MACD EMA smoothing factor\nema_macd = 0\n\nema_fast_values = [] # track fast EMA values for visualization purposes\nema_slow_values = [] # track slow EMA values for visualization purposes\nmacd_values = [] # track MACD values for visualization purposes\nmacd_signal_values = [] # MACD EMA values tracker\nmacd_historgram_values = [] # MACD - MACD-EMA\nfor close_price in close:\n    if (ema_fast == 0): # first observation\n        ema_fast = close_price\n        ema_slow = close_price\n    else:\n        ema_fast = (close_price - ema_fast) * K_fast + ema_fast\n        ema_slow = (close_price - ema_slow) * K_slow + ema_slow\n\n    ema_fast_values.append(ema_fast)\n    ema_slow_values.append(ema_slow)\n\n    macd = ema_fast - ema_slow # MACD is fast_MA - slow_EMA\n    if ema_macd == 0:\n        ema_macd = macd\n    else:\n        ema_macd = (macd - ema_macd) * K_slow + ema_macd # signal is EMA of MACD values\n\n    macd_values.append(macd)\n    macd_signal_values.append(ema_macd)\n    macd_historgram_values.append(macd - ema_macd)","b2fbddc2":"goog_data = goog_data.assign(ClosePrice=pd.Series(close, index=goog_data.index))\ngoog_data = goog_data.assign(FastExponential10DayMovingAverage=pd.Series(ema_fast_values, index=goog_data.index))\ngoog_data = goog_data.assign(SlowExponential40DayMovingAverage=pd.Series(ema_slow_values, index=goog_data.index))\ngoog_data = goog_data.assign(MovingAverageConvergenceDivergence=pd.Series(macd_values, index=goog_data.index))\ngoog_data = goog_data.assign(Exponential20DayMovingAverageOfMACD=pd.Series(macd_signal_values, index=goog_data.index))\ngoog_data = goog_data.assign(MACDHistorgram=pd.Series(macd_historgram_values, index=goog_data.index))\n\nclose_price = goog_data['ClosePrice']\nema_f = goog_data['FastExponential10DayMovingAverage']\nema_s = goog_data['SlowExponential40DayMovingAverage']\nmacd = goog_data['MovingAverageConvergenceDivergence']\nema_macd = goog_data['Exponential20DayMovingAverageOfMACD']\nmacd_histogram = goog_data['MACDHistorgram']","72b59006":"fig = plt.figure()\nax1 = fig.add_subplot(311, ylabel='Google price in $')\nclose_price.plot(ax=ax1, color='g', lw=2., legend=True)\nema_f.plot(ax=ax1, color='b', lw=2., legend=True)\nema_s.plot(ax=ax1, color='r', lw=2., legend=True)\nax2 = fig.add_subplot(312, ylabel='MACD')\nmacd.plot(ax=ax2, color='black', lw=2., legend=True)\nema_macd.plot(ax=ax2, color='g', lw=2., legend=True)\nax3 = fig.add_subplot(313, ylabel='MACD')\nmacd_histogram.plot(ax=ax3, color='r', kind='bar', legend=True, use_index=False)\n\nzoom = 2.5\nw, h = fig.get_size_inches()\nfig.set_size_inches(w * zoom, h * zoom)\n\nplt.show()","1517f02e":"import math as math","b0e0e05f":"time_period = 20 # history length for Simple Moving Average for middle band\nstdev_factor = 2 # Standard Deviation Scaling factor for the upper and lower bands\nhistory = [] # price history for computing simple moving average\nsma_values = [] # moving average of prices for visualization purposes\nupper_band = [] # upper band values\nlower_band = [] # lower band values\n\nfor close_price in close:\n    history.append(close_price)\n    if len(history) > time_period: # we only want to maintain at most 'time_period' number of price observations\n        del (history[0])\n\n    sma = stats.mean(history)\n    sma_values.append(sma) # simple moving average or middle band\n    variance = 0 # variance is the square of standard deviation\n    for hist_price in history:\n        variance = variance + ((hist_price - sma) ** 2)\n\n    stdev = math.sqrt(variance \/ len(history)) # use square root to get standard deviation\n\n    upper_band.append(sma + stdev_factor * stdev)\n    lower_band.append(sma - stdev_factor * stdev)","533565f9":"goog_data = goog_data.assign(ClosePrice=pd.Series(close, index=goog_data.index))\ngoog_data = goog_data.assign(MiddleBollingerBand20DaySMA=pd.Series(sma_values, index=goog_data.index))\ngoog_data = goog_data.assign(UpperBollingerBand20DaySMA2StdevFactor=pd.Series(upper_band, index=goog_data.index))\ngoog_data = goog_data.assign(LowerBollingerBand20DaySMA2StdevFactor=pd.Series(lower_band, index=goog_data.index))\n\nclose_price = goog_data['ClosePrice']\nmband = goog_data['MiddleBollingerBand20DaySMA']\nuband = goog_data['UpperBollingerBand20DaySMA2StdevFactor']\nlband = goog_data['LowerBollingerBand20DaySMA2StdevFactor']","6f59b050":"fig = plt.figure()\nax1 = fig.add_subplot(111, ylabel='Google price in $')\nclose_price.plot(ax=ax1, color='black', lw=2., legend=True)\nmband.plot(ax=ax1, color='b', lw=2., legend=True)\nuband.plot(ax=ax1, color='g', lw=2., legend=True)\nlband.plot(ax=ax1, color='r', lw=2., legend=True)\n\nzoom = 2.5\nw, h = fig.get_size_inches()\nfig.set_size_inches(w * zoom, h * zoom)\n\nplt.show()","8590877a":"time_period = 20 # look back period to compute gains & losses\ngain_history = [] # history of gains over look back period (0 if no gain, magnitude of gain if gain)\nloss_history = [] # history of losses over look back period (0 if no loss, magnitude of loss if loss)\navg_gain_values = [] # track avg gains for visualization purposes\navg_loss_values = [] # track avg losses for visualization purposes\nrsi_values = [] # track computed RSI values\nlast_price = 0 # current_price - last_price > 0 => gain. current_price - last_price < 0 => loss.\n\nfor close_price in close:\n    if last_price == 0:\n        last_price = close_price\n\n    gain_history.append(max(0, close_price - last_price))\n    loss_history.append(max(0, last_price - close_price))\n    last_price = close_price\n\n    if len(gain_history) > time_period: # maximum observations is equal to lookback period\n        del (gain_history[0])\n        del (loss_history[0])\n\n    avg_gain = stats.mean(gain_history) # average gain over lookback period\n    avg_loss = stats.mean(loss_history) # average loss over lookback period\n\n    avg_gain_values.append(avg_gain)\n    avg_loss_values.append(avg_loss)\n\n    rs = 0\n    if avg_loss > 0: # to avoid division by 0, which is undefined\n        rs = avg_gain \/ avg_loss\n\n    rsi = 100 - (100 \/ (1 + rs))\n    rsi_values.append(rsi)","0ef9c00a":"goog_data = goog_data.assign(ClosePrice=pd.Series(close, index=goog_data.index))\ngoog_data = goog_data.assign(RelativeStrengthAvgGainOver20Days=pd.Series(avg_gain_values, index=goog_data.index))\ngoog_data = goog_data.assign(RelativeStrengthAvgLossOver20Days=pd.Series(avg_loss_values, index=goog_data.index))\ngoog_data = goog_data.assign(RelativeStrengthIndicatorOver20Days=pd.Series(rsi_values, index=goog_data.index))\n\nclose_price = goog_data['ClosePrice']\nrs_gain = goog_data['RelativeStrengthAvgGainOver20Days']\nrs_loss = goog_data['RelativeStrengthAvgLossOver20Days']\nrsi = goog_data['RelativeStrengthIndicatorOver20Days']","9413bbab":"fig = plt.figure()\nax1 = fig.add_subplot(311, ylabel='Google price in $')\nclose_price.plot(ax=ax1, color='black', lw=2., legend=True)\nax2 = fig.add_subplot(312, ylabel='RS')\nrs_gain.plot(ax=ax2, color='g', lw=2., legend=True)\nrs_loss.plot(ax=ax2, color='r', lw=2., legend=True)\nax3 = fig.add_subplot(313, ylabel='RSI')\nrsi.plot(ax=ax3, color='b', lw=2., legend=True)\n\nzoom = 2.5\nw, h = fig.get_size_inches()\nfig.set_size_inches(w * zoom, h * zoom)\n\nplt.show()","5bb96956":"time_period = 20 # look back period\nhistory = [] # history of prices\nsma_values = [] # to track moving average values for visualization purposes\nstddev_values = [] # history of computed stdev values\n\nfor close_price in close:\n  history.append(close_price)\n  if len(history) > time_period: # we track at most 'time_period' number of prices\n    del (history[0])\n\n  sma = stats.mean(history)\n  sma_values.append(sma)\n  variance = 0 # variance is square of standard deviation\n  for hist_price in history:\n    variance = variance + ((hist_price - sma) ** 2)\n\n  stdev = math.sqrt(variance \/ len(history))\n\n  stddev_values.append(stdev)","68fbd85c":"goog_data = goog_data.assign(ClosePrice=pd.Series(close, index=goog_data.index))\ngoog_data = goog_data.assign(StandardDeviationOver20Days=pd.Series(stddev_values, index=goog_data.index))\n\nclose_price = goog_data['ClosePrice']\nstddev = goog_data['StandardDeviationOver20Days']","72e67d95":"fig = plt.figure()\nax1 = fig.add_subplot(211, ylabel='Google price in $')\nclose_price.plot(ax=ax1, color='g', lw=2., legend=True)\nax2 = fig.add_subplot(212, ylabel='Stddev in $')\nstddev.plot(ax=ax2, color='b', lw=2., legend=True)\nax2.axhline(y=stats.mean(stddev_values), color='k')\n\nzoom = 2.5\nw, h = fig.get_size_inches()\nfig.set_size_inches(w * zoom, h * zoom)\n\nplt.show()","b3d36f90":"time_period = 20 # how far to look back to find reference price to compute momentum\nhistory = [] # history of observed prices to use in momentum calculation\nmom_values = [] # track momentum values for visualization purposes\n\nfor close_price in close:\n    history.append(close_price)\n    if len(history) > time_period: # history is at most 'time_period' number of observations\n        del (history[0])\n\n    mom = close_price - history[0]\n    mom_values.append(mom)","a8af3277":"goog_data = goog_data.assign(ClosePrice=pd.Series(close, index=goog_data.index))\ngoog_data = goog_data.assign(MomentumFromPrice20DaysAgo=pd.Series(mom_values, index=goog_data.index))\n\nclose_price = goog_data['ClosePrice']\nmom = goog_data['MomentumFromPrice20DaysAgo']","68298234":"fig = plt.figure()\nax1 = fig.add_subplot(211, ylabel='Google price in $')\nclose_price.plot(ax=ax1, color='g', lw=2., legend=True)\nax2 = fig.add_subplot(212, ylabel='Momentum in $')\nmom.plot(ax=ax2, color='b', lw=2., legend=True)\n\nzoom = 2.5\nw, h = fig.get_size_inches()\nfig.set_size_inches(w * zoom, h * zoom)\n\nplt.show()","113b3d73":"goog_data.tail(3)","0f291550":"start_date = '2001-01-01'\nend_date = '2018-01-01'\nSRC_DATA_LARGE_FILENAME = 'goog_data_large.pkl'\n\ntry:\n    goog_data = pd.read_pickle(SRC_DATA_LARGE_FILENAME)\n    print('File data found...')\nexcept FileNotFoundError:\n    print(\"File not found! downloading and saving the GOOG data in a pickle file...\")\n    goog_data = pd_data.DataReader('GOOG', 'yahoo', start_date, end_date)\n    goog_data.to_pickle(SRC_DATA_LARGE_FILENAME)\n    \ngoog_monthly_return = goog_data['Adj Close'].pct_change().groupby(\n    [goog_data['Adj Close'].index.year, goog_data['Adj Close'].index.month]).mean()\ngoog_monthly_return_list = []\n\nfor i in range(len(goog_monthly_return)):\n    goog_monthly_return_list.append({\n        'month': goog_monthly_return.index[i][1], # the first item of `index` is the (year,month) tupple, the second is the month\n        'monthly_return': goog_monthly_return[i]\n    })\n\ngoog_monthly_return_list = pd.DataFrame(goog_monthly_return_list, columns=('month', 'monthly_return'))\ngoog_monthly_return_list.boxplot(column=\"monthly_return\", by=\"month\")\n\nax = plt.gca()\nlabels = [item.get_text() for item in ax.get_xticklabels()]\nlabels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\nax.set_xticklabels(labels)\nax.set_ylabel('GOOG return')\n\nplt.tick_params(axis='both', which='major', labelsize=7)\nplt.title('GOOG Monthly return 2001-2018')\nplt.suptitle(\"\")\nfig.set_size_inches(w * zoom, h * zoom)\n\nplt.show()","27245b6a":"def plot_rolling_statistics_ts(ts, titletext, ytext, window_size=12):\n    ts.plot(color='red', label='Original', lw=0.5)\n    ts.rolling(window_size).mean().plot(color='blue', label='Rolling mean')\n    ts.rolling(window_size).std().plot(color='black', label='Rolling std')\n    \n    plt.legend(loc='best')\n    plt.ylabel(ytext)\n    plt.title(titletext)\n    \n    plt.show(block=False)\n\nplot_rolling_statistics_ts(goog_monthly_return[1:], 'GOOG prices rolling mean and standard deviation', 'Monthly return')\nplot_rolling_statistics_ts(goog_data['Adj Close'], 'GOOG prices rolling mean and standard deviation', 'Daily prices', 365)","772e703d":"#### The book talks about removing the trend and seazonality, but it doesn't provide the code for how to do it.\nBut it says \"For the data using the GOOG daily prices, we can just remove the trend by\nsubtracting the moving average from the daily prices:\n* We can now observe the trend disappeared.\n* Additionally, we also want to remove seasonality; for that, we can apply differentiation.\n* For the differentiation, we will calculate the difference between two consecutive days; we will then use the difference as data points.\"","792f9479":"### Implementation of the Exponential Moving Average (EMA):\nBy definition, $EMA$ is:\n### $ EMA = (P - EMA_{old})*\\mu + EMA_{old} $\nOr, alternatively:\n### $ EMA = P*\\mu + (1-\\mu)*EMA_{old} $\nWhere $\\mu$ is a weight factor.","737d9062":"All the APO logic is in the cell bellow:","3ad13fef":"Plotting the chart with the time the orders go out:","1bc89bc7":"... Now Plotting ...","b4b4d71a":"## Suport and Resistence Indicators:","b767d6fd":"### Summary and My work over the 2nd chapter of the book \"Learn Algorithmic Trading\" by Donadio & Ghosh.","96e0c921":"### Implementation of the Moving Average Convergence Divergence (MACD):\nMACD also relies on EMA:\n\n$ MACD = EMA_{fast} - EMA_{slow} $\n\n$ MACD_{Signal} = EMA_{MACD} $\n\n$ MACD_{Histogram} = MACD - MACD_{Signal} $","acc5e503":"### Implementing Standard Derivatives (STDEV):","4b9d39b2":"### Implementation of the Relative Strength Indicator (RSI):\n# $ RSI = 100 - \\frac{100}{1+\\frac{GainsOverTheLastNPeriods}{LossesOverTheLastNPerios}} $","ce9791a2":"### Implementation of the Simple Moving Average (SMA):","99434dc8":"In our example, we can introduce two further parameters:\n* The minimum number of times that a price needs to reach the support\/resistance level.\n* We will define the tolerance margin of what we consider being close to the support\/resistance level.","7f527893":"All the EMA logic is in the following cell:","7bf2916b":"After all that, this is what the `goog_data` DataFrame looks like:","48cb45f5":"Implementing the trading strategy:","2232f635":"### Implementation of Momentum (MOM):\nIn its simplest form, momentum is simply the difference between the current price and price of some fixed time-periods in the past:\n### $ MOM = Price_{t} - Price_{t-n} $","3ed3c47c":"# Designing a Trading Strategy based on trend and momentum-based indicators:","5dc1975e":"Displaying Rolling Statistics:","3be3b303":"### Implementation of Bollinger Bands (BBANDS):\nBBANDS is also built on top of moving averages:\n\n$ BBAND_{Middle} = SMA_{nperiods} $\n\n$ BBAND_{Upper} = BBAND_{Middle} + (\\beta*\\sigma) $\n\n$ BBAND_{Lower} = BBAND_{Middle} - (\\beta*\\sigma) $\n\n$ \\beta $: is a control paramenter, controls the width of our trading signal.\n\n$ \\sigma $: is the standard deviation.","bf64c97a":"# Implementing Advanced Concepts, such as Seasonality, in Trading Instruments:\nLike any other retail products, financial products follow trends and seasonality during different seasos.\n\nIn this sections we will use the GOOG data from 2001 to 2018 to study price variations based on the months:","d76e0487":"### Implementation of the Absolute Price Oscillator (APO):\nAPO is built on top of the EMA: $ APO = EMA_{fast} - EMA_{slow} $. That is, APO is the difference between a short-time-period EMA and a long-time-period EMA.","24de3341":"# Creating trading signals based on Fundamental Technical Analysis:\n* Simple Moving Average (SMA);\n* Exponantial Moving Average (EMA);\n* Absolute Price Oscilator (APO);\n* Moving Average Convergence Divergence (MACD);\n* Bollinger Bands (BBANDS);\n* Relative Strngth Indicator (RSI);\n* Standard Deviation (STDEV);\n* Momentum (MOM).","38f1667f":"Ploting the EMA:"}}