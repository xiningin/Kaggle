{"cell_type":{"f4597532":"code","a674ba32":"code","bae088f6":"code","e4e811d7":"code","dc5a385f":"code","803c1962":"code","5d80c709":"code","27e3c208":"code","ba282d7a":"code","37f808f0":"code","20d34dc5":"code","d4ea329e":"code","2f6c89f7":"code","a57c99a7":"code","a47a2c13":"code","8e79edf6":"code","650991e9":"code","2672d0f5":"code","56279043":"code","a08621c2":"code","6d2c19bf":"code","62803e40":"code","39b043f9":"code","06907bcf":"code","d8f7c105":"code","1302b7af":"code","2e8adf28":"code","c758b759":"code","f14b42d0":"code","2e95ec0c":"code","1cd5315e":"code","6fb90753":"markdown","d958b142":"markdown","2a34c9b8":"markdown","3ad83f3a":"markdown","732df9af":"markdown","b3a78e50":"markdown","cf4edb95":"markdown","448d6b12":"markdown","46ed71d1":"markdown","b72677b9":"markdown","0203f4db":"markdown","277ab68b":"markdown"},"source":{"f4597532":"fn = '..\/input\/lyft3d-mask-test-data\/model_preds.gif'\nfrom IPython.display import Image\nImage(filename=fn)","a674ba32":"!pip install lyft-dataset-sdk -q\n!pip install moviepy","bae088f6":"! python ..\/input\/mlcomp\/mlcomp\/mlcomp\/setup.py","e4e811d7":"from datetime import datetime\nfrom functools import partial\nimport glob\nfrom multiprocessing import Pool\n\n# Disable multiprocesing for numpy\/opencv. We already multiprocess ourselves, this would mean every subprocess produces\n# even more threads which would lead to a lot of context switching, slowing things down a lot.\nimport os\nos.environ[\"OMP_NUM_THREADS\"] = \"1\"\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport pandas as pd\nimport cv2\nfrom PIL import Image\nimport numpy as np\nfrom tqdm import tqdm, tqdm_notebook\nimport scipy\nimport scipy.ndimage\nimport scipy.special\nfrom scipy.spatial.transform import Rotation as R\n\nfrom lyft_dataset_sdk.lyftdataset import LyftDataset\nfrom lyft_dataset_sdk.utils.data_classes import LidarPointCloud, Box, Quaternion\nfrom lyft_dataset_sdk.utils.geometry_utils import view_points, transform_matrix\n\nimport time\nfrom lyft_dataset_sdk.utils.map_mask import MapMask\nfrom pathlib import Path\nfrom lyft_dataset_sdk.lyftdataset import LyftDataset,LyftDatasetExplorer","dc5a385f":"!ln -s \/kaggle\/input\/3d-object-detection-for-autonomous-vehicles\/test_images images\n!ln -s \/kaggle\/input\/3d-object-detection-for-autonomous-vehicles\/test_maps maps\n!ln -s \/kaggle\/input\/3d-object-detection-for-autonomous-vehicles\/test_lidar lidar","803c1962":"classes = [\"car\", \"motorcycle\", \"bus\", \"bicycle\", \"truck\", \"pedestrian\", \"other_vehicle\", \"animal\", \"emergency_vehicle\"]\ntrain_dataset = LyftDataset(data_path='.', json_path='..\/input\/3d-object-detection-for-autonomous-vehicles\/train_data', verbose=True)","5d80c709":"train_dataset.list_categories()\ndel train_dataset;","27e3c208":"class_heights = {'animal':0.51,'bicycle':1.44,'bus':3.44,'car':1.72,'emergency_vehicle':2.39,'motorcycle':1.59,\n                'other_vehicle':3.23,'pedestrian':1.78,'truck':3.44}\nlevel5data = LyftDataset(data_path='.', json_path='..\/input\/3d-object-detection-for-autonomous-vehicles\/test_data', verbose=True)","ba282d7a":"def move_boxes_to_car_space(boxes, ego_pose):\n    \"\"\"\n    Move boxes from world space to car space.\n    Note: mutates input boxes.\n    \"\"\"\n    translation = -np.array(ego_pose['translation'])\n    rotation = Quaternion(ego_pose['rotation']).inverse\n    \n    for box in boxes:\n        # Bring box to car space\n        box.translate(translation)\n        box.rotate(rotation)\n        \ndef scale_boxes(boxes, factor):\n    \"\"\"\n    Note: mutates input boxes\n    \"\"\"\n    for box in boxes:\n        box.wlh = box.wlh * factor\n\ndef draw_boxes(im, voxel_size, boxes, classes, z_offset=0.0):\n    for box in boxes:\n        # We only care about the bottom corners\n        corners = box.bottom_corners()\n        corners_voxel = car_to_voxel_coords(corners, im.shape, voxel_size, z_offset).transpose(1,0)\n        corners_voxel = corners_voxel[:,:2] # Drop z coord\n\n        class_color = classes.index(box.name) + 1\n        \n        if class_color == 0:\n            raise Exception(\"Unknown class: {}\".format(box.name))\n\n        cv2.drawContours(im, np.int0([corners_voxel]), 0, (class_color, class_color, class_color), -1)","37f808f0":"# Some hyperparameters we'll need to define for the system\nvoxel_size = (0.4, 0.4, 1.5)\nz_offset = -2.0\nbev_shape = (336, 336, 3)\n\n# We scale down each box so they are more separated when projected into our coarse voxel space.\nbox_scale = 0.8","20d34dc5":"records = [(level5data.get('sample', record['first_sample_token'])['timestamp'], record) for record in level5data.scene]\n\nentries = []\n\nfor start_time, record in sorted(records):\n    start_time = level5data.get('sample', record['first_sample_token'])['timestamp'] \/ 1000000\n\n    token = record['token']\n    name = record['name']\n    date = datetime.utcfromtimestamp(start_time)\n    host = \"-\".join(record['name'].split(\"-\")[:2])\n    first_sample_token = record[\"first_sample_token\"]\n\n    entries.append((host, name, date, token, first_sample_token))\n            \ndf = pd.DataFrame(entries, columns=[\"host\", \"scene_name\", \"date\", \"scene_token\", \"first_sample_token\"])","d4ea329e":"df.head()","2f6c89f7":"# sample_sub = pd.read_csv('..\/input\/3d-object-detection-for-autonomous-vehicles\/sample_submission.csv')\nall_sample_tokens,scene_len = [],[]\nfor sample_token in tqdm_notebook(df.first_sample_token.values):\n    i = 0\n    while sample_token:\n        all_sample_tokens.append(sample_token)\n        sample = level5data.get(\"sample\", sample_token)\n        sample_token = sample[\"next\"]\n        i += 1\n    scene_len.append(i)\n#     print(len(all_sample_tokens[-1]))\n    \nprint('Total number of tokens=',len(all_sample_tokens))","a57c99a7":"import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.utils.data\n\ntest_data_folder = '..\/input\/lyft3d-mask-test-data\/test_data\/test_data'\n\nclass BEVImageDataset(torch.utils.data.Dataset):\n    def __init__(self, sample_token,test_data_folder):\n\n        self.sample_token = sample_token\n        self.test_data_folder = test_data_folder\n\n    def __len__(self):\n        return len(self.sample_token)\n\n    def __getitem__(self, idx):\n        sample_token = self.sample_token[idx]\n        \n#         sample_token = input_filepath.split(\"\/\")[-1].replace(\"_input.png\",\"\")\n        \n        input_filepath = os.path.join(test_data_folder,f\"{sample_token}_input.png\")\n\n        map_filepath = os.path.join(test_data_folder,f\"{sample_token}_map.png\")\n        \n        \n        im = cv2.imread(input_filepath, cv2.IMREAD_UNCHANGED)\n        \n        map_im = cv2.imread(map_filepath, cv2.IMREAD_UNCHANGED)\n#         print(im.shape,map_im.shape)\n        im = np.concatenate((im, map_im), axis=2)\n        \n        im = im.astype(np.float32)\/255\n        \n        im = torch.from_numpy(im.transpose(2,0,1))\n        \n        return im, sample_token\n\n    \n# input_filepaths = sorted(glob.glob(os.path.join(test_data_folder, \"*_input.png\")))\n# map_filepaths = sorted(glob.glob(os.path.join(test_data_folder, \"*_map.png\")))\n\ntest_dataset = BEVImageDataset(all_sample_tokens,test_data_folder)","a47a2c13":"# This implementation was copied from https:\/\/github.com\/jvanvugt\/pytorch-unet, it is MIT licensed.\n\nclass UNet(nn.Module):\n    def __init__(\n        self,\n        in_channels=1,\n        n_classes=2,\n        depth=5,\n        wf=6,\n        padding=False,\n        batch_norm=False,\n        up_mode='upconv',\n    ):\n        \"\"\"\n        Implementation of\n        U-Net: Convolutional Networks for Biomedical Image Segmentation\n        (Ronneberger et al., 2015)\n        https:\/\/arxiv.org\/abs\/1505.04597\n        Using the default arguments will yield the exact version used\n        in the original paper\n        Args:\n            in_channels (int): number of input channels\n            n_classes (int): number of output channels\n            depth (int): depth of the network\n            wf (int): number of filters in the first layer is 2**wf\n            padding (bool): if True, apply padding such that the input shape\n                            is the same as the output.\n                            This may introduce artifacts\n            batch_norm (bool): Use BatchNorm after layers with an\n                               activation function\n            up_mode (str): one of 'upconv' or 'upsample'.\n                           'upconv' will use transposed convolutions for\n                           learned upsampling.\n                           'upsample' will use bilinear upsampling.\n        \"\"\"\n        super(UNet, self).__init__()\n        assert up_mode in ('upconv', 'upsample')\n        self.padding = padding\n        self.depth = depth\n        prev_channels = in_channels\n        self.down_path = nn.ModuleList()\n        for i in range(depth):\n            self.down_path.append(\n                UNetConvBlock(prev_channels, 2 ** (wf + i), padding, batch_norm)\n            )\n            prev_channels = 2 ** (wf + i)\n\n        self.up_path = nn.ModuleList()\n        for i in reversed(range(depth - 1)):\n            self.up_path.append(\n                UNetUpBlock(prev_channels, 2 ** (wf + i), up_mode, padding, batch_norm)\n            )\n            prev_channels = 2 ** (wf + i)\n\n        self.last = nn.Conv2d(prev_channels, n_classes, kernel_size=1)\n\n    def forward(self, x):\n        blocks = []\n        for i, down in enumerate(self.down_path):\n            x = down(x)\n            if i != len(self.down_path) - 1:\n                blocks.append(x)\n                x = F.max_pool2d(x, 2)\n\n        for i, up in enumerate(self.up_path):\n            x = up(x, blocks[-i - 1])\n\n        return self.last(x)\n\n\nclass UNetConvBlock(nn.Module):\n    def __init__(self, in_size, out_size, padding, batch_norm):\n        super(UNetConvBlock, self).__init__()\n        block = []\n\n        block.append(nn.Conv2d(in_size, out_size, kernel_size=3, padding=int(padding)))\n        block.append(nn.ReLU())\n        if batch_norm:\n            block.append(nn.BatchNorm2d(out_size))\n\n        block.append(nn.Conv2d(out_size, out_size, kernel_size=3, padding=int(padding)))\n        block.append(nn.ReLU())\n        if batch_norm:\n            block.append(nn.BatchNorm2d(out_size))\n\n        self.block = nn.Sequential(*block)\n\n    def forward(self, x):\n        out = self.block(x)\n        return out\n\n\nclass UNetUpBlock(nn.Module):\n    def __init__(self, in_size, out_size, up_mode, padding, batch_norm):\n        super(UNetUpBlock, self).__init__()\n        if up_mode == 'upconv':\n            self.up = nn.ConvTranspose2d(in_size, out_size, kernel_size=2, stride=2)\n        elif up_mode == 'upsample':\n            self.up = nn.Sequential(\n                nn.Upsample(mode='bilinear', scale_factor=2),\n                nn.Conv2d(in_size, out_size, kernel_size=1),\n            )\n\n        self.conv_block = UNetConvBlock(in_size, out_size, padding, batch_norm)\n\n    def center_crop(self, layer, target_size):\n        _, _, layer_height, layer_width = layer.size()\n        diff_y = (layer_height - target_size[0]) \/\/ 2\n        diff_x = (layer_width - target_size[1]) \/\/ 2\n        return layer[\n            :, :, diff_y : (diff_y + target_size[0]), diff_x : (diff_x + target_size[1])\n        ]\n\n    def forward(self, x, bridge):\n        up = self.up(x)\n        crop1 = self.center_crop(bridge, up.shape[2:])\n        out = torch.cat([up, crop1], 1)\n        out = self.conv_block(out)\n\n        return out","8e79edf6":"def get_unet_model(in_channels=6, num_output_classes=2):\n    model = UNet(in_channels=in_channels, n_classes=num_output_classes, wf=5, depth=4, padding=True, up_mode='upsample')\n    \n    # Optional, for multi GPU training and inference\n    model = nn.DataParallel(model)\n    return model\n","650991e9":"def box_in_image(box, intrinsic, image_size) -> bool:\n    \"\"\"Check if a box is visible inside an image without accounting for occlusions.\n    Args:\n        box: The box to be checked.\n        intrinsic: <float: 3, 3>. Intrinsic camera matrix.\n        image_size: (width, height)\n        vis_level: One of the enumerations of <BoxVisibility>.\n    Returns: True if visibility condition is satisfied.\n    \"\"\"\n\n    corners_3d = box.corners()\n    corners_img = view_points(corners_3d, intrinsic, normalize=True)[:2, :]\n\n    visible = np.logical_and(corners_img[0, :] > 0, corners_img[0, :] < image_size[0])\n    visible = np.logical_and(visible, corners_img[1, :] < image_size[1])\n    visible = np.logical_and(visible, corners_img[1, :] > 0)\n    visible = np.logical_and(visible, corners_3d[2, :] > 1)\n\n    in_front = corners_3d[2, :] > 0.1  # True if a corner is at least 0.1 meter in front of the camera.\n\n    return any(visible) and all(in_front)\n\nall_pred_fn = []\ndef viz_unet(sample_token,boxes): \n\n    sample = level5data.get(\"sample\", sample_token)\n\n    sample_camera_token = sample[\"data\"][\"CAM_FRONT\"]\n    camera_data = level5data.get(\"sample_data\", sample_camera_token)\n    # camera_filepath = level5data.get_sample_data_path(sample_camera_token)\n\n    ego_pose = level5data.get(\"ego_pose\", camera_data[\"ego_pose_token\"])\n    calibrated_sensor = level5data.get(\"calibrated_sensor\", camera_data[\"calibrated_sensor_token\"])\n    data_path, _, camera_intrinsic = level5data.get_sample_data(sample_camera_token)\n\n\n    data = Image.open(data_path)\n    _, axis = plt.subplots(1, 1, figsize=(9, 9))\n    \n    for i,box in enumerate(boxes):\n\n        # Move box to ego vehicle coord system\n        box.translate(-np.array(ego_pose[\"translation\"]))\n        box.rotate(Quaternion(ego_pose[\"rotation\"]).inverse)\n\n        # Move box to sensor coord system\n        box.translate(-np.array(calibrated_sensor[\"translation\"]))\n        box.rotate(Quaternion(calibrated_sensor[\"rotation\"]).inverse)\n\n        if box_in_image(box,camera_intrinsic,np.array(data).shape):            \n            box.render(axis,camera_intrinsic,normalize=True)\n\n    axis.imshow(data)\n    all_pred_fn.append(f'.\/cam_viz\/cam_preds_{sample_token}.jpg')\n    plt.savefig(all_pred_fn[-1])\n    plt.close()","2672d0f5":"# We weigh the loss for the 0 class lower to account for (some of) the big class imbalance.\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\nclass_weights = torch.from_numpy(np.array([0.2] + [1.0]*len(classes), dtype=np.float32))\nclass_weights = class_weights.to(device)","56279043":"batch_size = 16\nmodel10 = get_unet_model(num_output_classes=len(classes)+1)\n\nstate = torch.load('..\/input\/lyft3d-mask-test-data\/unet_checkpoint_epoch_10.pth')\nmodel10.load_state_dict(state)\nmodel10 = model10.to(device)\nmodel10.eval();\n\n\nmodel9 = get_unet_model(num_output_classes=len(classes)+1)\n\nstate = torch.load('..\/input\/lyft3d-mask-test-data\/unet_checkpoint_epoch_9.pth')\nmodel9.load_state_dict(state)\nmodel9 = model9.to(device)\nmodel9.eval();\n\nmodel8 = get_unet_model(num_output_classes=len(classes)+1)\n\nstate = torch.load('..\/input\/lyft3d-mask-test-data\/unet_checkpoint_epoch_8.pth')\nmodel8.load_state_dict(state)\nmodel8 = model8.to(device)\nmodel8.eval();","a08621c2":"class Model:\n    def __init__(self, models):\n        self.models = models\n    \n    def __call__(self, x):\n        res = []\n        x = x.cuda()\n        with torch.no_grad():\n            for m in self.models:\n                res.append(m(x))\n        res = torch.stack(res)\n        return torch.mean(res, dim=0)\n\nmodel = Model([model8,model9,model10])","6d2c19bf":"def calc_detection_box(prediction_opened,class_probability):\n\n    sample_boxes = []\n    sample_detection_scores = []\n    sample_detection_classes = []\n    \n    contours, hierarchy = cv2.findContours(prediction_opened, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) \n    \n    for cnt in contours:\n        rect = cv2.minAreaRect(cnt)\n        box = cv2.boxPoints(rect)\n        \n        # Let's take the center pixel value as the confidence value\n        box_center_index = np.int0(np.mean(box, axis=0))\n        \n        for class_index in range(len(classes)):\n            box_center_value = class_probability[class_index+1, box_center_index[1], box_center_index[0]]\n            \n            # Let's remove candidates with very low probability\n            if box_center_value < 0.01:\n                continue\n            \n            box_center_class = classes[class_index]\n\n            box_detection_score = box_center_value\n            sample_detection_classes.append(box_center_class)\n            sample_detection_scores.append(box_detection_score)\n            sample_boxes.append(box)\n            \n    return np.array(sample_boxes),sample_detection_scores,sample_detection_classes","62803e40":"# We perform an opening morphological operation to filter tiny detections\n# Note that this may be problematic for classes that are inherently small (e.g. pedestrians)..\nkernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(3,3))","39b043f9":"import gc\ngc.collect()\ntest_loader = torch.utils.data.DataLoader(test_dataset, batch_size, shuffle=False, num_workers=os.cpu_count()*2)\nprogress_bar = tqdm_notebook(test_loader)\n\n# We quantize to uint8 here to conserve memory. We're allocating >20GB of memory otherwise.\n# predictions = np.zeros((len(test_loader), 1+len(classes), 336, 336), dtype=np.uint8)\n\nsample_tokens = []\nall_losses = []\n\ndetection_boxes = []\ndetection_scores = []\ndetection_classes = []\n\n# Arbitrary threshold in our system to create a binary image to fit boxes around.\nbackground_threshold = 200\n\nwith torch.no_grad():\n    for ii, (X, batch_sample_tokens) in enumerate(progress_bar):\n\n        sample_tokens.extend(batch_sample_tokens)\n        \n        X = X.to(device)  # [N, 1, H, W]\n        prediction = model(X)  # [N, 2, H, W]\n        \n        prediction = F.softmax(prediction, dim=1)\n        \n        prediction_cpu = prediction.cpu().numpy()\n        predictions = np.round(prediction_cpu*255).astype(np.uint8)\n        \n        # Get probabilities for non-background\n        predictions_non_class0 = 255 - predictions[:,0]\n        \n        predictions_opened = np.zeros((predictions_non_class0.shape), dtype=np.uint8)\n\n        for i, p in enumerate(predictions_non_class0):\n            thresholded_p = (p > background_threshold).astype(np.uint8)\n            predictions_opened[i] = cv2.morphologyEx(thresholded_p, cv2.MORPH_OPEN, kernel)\n    \n            sample_boxes,sample_detection_scores,sample_detection_classes = calc_detection_box(predictions_opened[i],\n                                                                                              predictions[i])\n        \n            detection_boxes.append(np.array(sample_boxes))\n            detection_scores.append(sample_detection_scores)\n            detection_classes.append(sample_detection_classes)\n        \n#         # Visualize the first prediction\n#         if ii == 0:\n#             visualize_predictions(X, prediction, apply_softmaxiii=False)\n            ","06907bcf":"print(\"Total amount of boxes:\", np.sum([len(x) for x in detection_boxes]))\n    \n\n# Visualize the boxes in the first sample\nt = np.zeros_like(predictions_opened[0])\nfor sample_boxes in detection_boxes[0]:\n    box_pix = np.int0(sample_boxes)\n    cv2.drawContours(t,[box_pix],0,(255),2)\nplt.imshow(t)\nplt.show()\n\n# Visualize their probabilities\nplt.hist(detection_scores[0], bins=20)\nplt.xlabel(\"Detection Score\")\nplt.ylabel(\"Count\")\nplt.show()","d8f7c105":"def create_transformation_matrix_to_voxel_space(shape, voxel_size, offset):\n    \"\"\"\n    Constructs a transformation matrix given an output voxel shape such that (0,0,0) ends up in the center.\n    Voxel_size defines how large every voxel is in world coordinate, (1,1,1) would be the same as Minecraft voxels.\n    \n    An offset per axis in world coordinates (metric) can be provided, this is useful for Z (up-down) in lidar points.\n    \"\"\"\n    \n    shape, voxel_size, offset = np.array(shape), np.array(voxel_size), np.array(offset)\n    \n    tm = np.eye(4, dtype=np.float32)\n    translation = shape\/2 + offset\/voxel_size\n    \n    tm = tm * np.array(np.hstack((1\/voxel_size, [1])))\n    tm[:3, 3] = np.transpose(translation)\n    return tm\n\ndef transform_points(points, transf_matrix):\n    \"\"\"\n    Transform (3,N) or (4,N) points using transformation matrix.\n    \"\"\"\n    if points.shape[0] not in [3,4]:\n        raise Exception(\"Points input should be (3,N) or (4,N) shape, received {}\".format(points.shape))\n    return transf_matrix.dot(np.vstack((points[:3, :], np.ones(points.shape[1]))))[:3, :]\n\n\ndef car_to_voxel_coords(points, shape, voxel_size, z_offset=0):\n    if len(shape) != 3:\n        raise Exception(\"Voxel volume shape should be 3 dimensions (x,y,z)\")\n        \n    if len(points.shape) != 2 or points.shape[0] not in [3, 4]:\n        raise Exception(\"Input points should be (3,N) or (4,N) in shape, found {}\".format(points.shape))\n\n    tm = create_transformation_matrix_to_voxel_space(shape, voxel_size, (0, 0, z_offset))\n    p = transform_points(points, tm)\n    return p\n\ndef create_voxel_pointcloud(points, shape, voxel_size=(0.5,0.5,1), z_offset=0):\n\n    points_voxel_coords = car_to_voxel_coords(points.copy(), shape, voxel_size, z_offset)\n    points_voxel_coords = points_voxel_coords[:3].transpose(1,0)\n    points_voxel_coords = np.int0(points_voxel_coords)\n    \n    bev = np.zeros(shape, dtype=np.float32)\n    bev_shape = np.array(shape)\n\n    within_bounds = (np.all(points_voxel_coords >= 0, axis=1) * np.all(points_voxel_coords < bev_shape, axis=1))\n    \n    points_voxel_coords = points_voxel_coords[within_bounds]\n    coord, count = np.unique(points_voxel_coords, axis=0, return_counts=True)\n        \n    # Note X and Y are flipped:\n    bev[coord[:,1], coord[:,0], coord[:,2]] = count\n    \n    return bev\n\ndef normalize_voxel_intensities(bev, max_intensity=16):\n    return (bev\/max_intensity).clip(0,1)\n","1302b7af":"os.makedirs('.\/cam_viz',exist_ok=True)\n\nfrom moviepy.editor import ImageSequenceClip \nfrom lyft_dataset_sdk.eval.detection.mAP_evaluation import Box3D, recall_precision\nimport shutil\n\npred_box3ds = []\n\nmax_frames = 128\nvid_count = 0\nprocessed_samples = 0\nfor (sample_token, sample_boxes, sample_detection_scores, sample_detection_class) in tqdm_notebook(zip(sample_tokens, detection_boxes, detection_scores, detection_classes), total=len(sample_tokens)):\n    processed_samples += 1\n    sample_boxes = sample_boxes.reshape(-1, 2) # (N, 4, 2) -> (N*4, 2)\n    sample_boxes = sample_boxes.transpose(1,0) # (N*4, 2) -> (2, N*4)\n\n    # Add Z dimension\n    sample_boxes = np.vstack((sample_boxes, np.zeros(sample_boxes.shape[1]),)) # (2, N*4) -> (3, N*4)\n\n    sample = level5data.get(\"sample\", sample_token)\n    sample_lidar_token = sample[\"data\"][\"LIDAR_TOP\"]\n    lidar_data = level5data.get(\"sample_data\", sample_lidar_token)\n    lidar_filepath = level5data.get_sample_data_path(sample_lidar_token)\n    ego_pose = level5data.get(\"ego_pose\", lidar_data[\"ego_pose_token\"])\n    ego_translation = np.array(ego_pose['translation'])\n\n    global_from_car = transform_matrix(ego_pose['translation'],\n                                       Quaternion(ego_pose['rotation']), inverse=False)\n\n    car_from_voxel = np.linalg.inv(create_transformation_matrix_to_voxel_space(bev_shape, voxel_size, (0, 0, z_offset)))\n\n\n    global_from_voxel = np.dot(global_from_car, car_from_voxel)\n    sample_boxes = transform_points(sample_boxes, global_from_voxel)\n\n    # We don't know at where the boxes are in the scene on the z-axis (up-down), let's assume all of them are at\n    # the same height as the ego vehicle.\n    sample_boxes[2,:] = ego_pose[\"translation\"][2]\n\n\n    # (3, N*4) -> (N, 4, 3)\n    sample_boxes = sample_boxes.transpose(1,0).reshape(-1, 4, 3)\n\n#     box_height = 1.75\n    box_height = np.array([class_heights[cls] for cls in sample_detection_class])\n\n    # Note: Each of these boxes describes the ground corners of a 3D box.\n    # To get the center of the box in 3D, we'll have to add half the height to it.\n    sample_boxes_centers = sample_boxes.mean(axis=1)\n    sample_boxes_centers[:,2] += box_height\/2\n\n    # Width and height is arbitrary - we don't know what way the vehicles are pointing from our prediction segmentation\n    # It doesn't matter for evaluation, so no need to worry about that here.\n    # Note: We scaled our targets to be 0.8 the actual size, we need to adjust for that\n    sample_lengths = np.linalg.norm(sample_boxes[:,0,:] - sample_boxes[:,1,:], axis=1) * 1\/box_scale\n    sample_widths = np.linalg.norm(sample_boxes[:,1,:] - sample_boxes[:,2,:], axis=1) * 1\/box_scale\n    \n    sample_boxes_dimensions = np.zeros_like(sample_boxes_centers) \n    sample_boxes_dimensions[:,0] = sample_widths\n    sample_boxes_dimensions[:,1] = sample_lengths\n    sample_boxes_dimensions[:,2] = box_height\n    \n    temp = []\n    for i in range(len(sample_boxes)):\n        translation = sample_boxes_centers[i]\n        size = sample_boxes_dimensions[i]\n        class_name = sample_detection_class[i]\n        ego_distance = float(np.linalg.norm(ego_translation - translation))\n    \n        \n        # Determine the rotation of the box\n        v = (sample_boxes[i,0] - sample_boxes[i,1])\n        v \/= np.linalg.norm(v)\n        r = R.from_dcm([\n            [v[0], -v[1], 0],\n            [v[1],  v[0], 0],\n            [   0,     0, 1],\n        ])\n        quat = r.as_quat()\n        # XYZW -> WXYZ order of elements\n        quat = quat[[3,0,1,2]]\n        \n        detection_score = float(sample_detection_scores[i])\n\n        \n        box3d = Box(\n            token=sample_token,\n            center=list(translation),\n            size=list(size),\n            orientation=Quaternion(quat),\n            name=class_name,\n            score=detection_score\n        )\n        \n        temp.append(box3d)\n        box3d = Box3D(\n            sample_token=sample_token,\n            translation=list(translation),\n            size=list(size),\n            rotation=list(quat),\n            name=class_name,\n            score=detection_score\n        )\n        pred_box3ds.append(box3d)\n        \n#     https:\/\/github.com\/Zulko\/moviepy\/issues\/903\n    if vid_count < 1:\n        viz_unet(sample_token,temp)\n        if processed_samples==max_frames:\n            os.makedirs('.\/cam_viz',exist_ok=True)\n            processed_samples = 0\n            vid_count += 1        \n            new_clip = ImageSequenceClip(all_pred_fn,fps=5)\n            all_pred_fn = []\n            new_clip.write_videofile(f\"model_preds_{vid_count}.mp4\") \n            shutil.rmtree('.\/cam_viz')\n            del new_clip\n            gc.collect()\n            os.makedirs('.\/cam_viz',exist_ok=True)\n#         os.system('rm -rf .\/cam_viz')\n","2e8adf28":"!rm -r .\/cam_viz\/","c758b759":"sub = {}\nfor i in tqdm_notebook(range(len(pred_box3ds))):\n#     yaw = -np.arctan2(pred_box3ds[i].rotation[2], pred_box3ds[i].rotation[0])\n    yaw = 2*np.arccos(pred_box3ds[i].rotation[0]);\n    pred =  str(pred_box3ds[i].score\/255) + ' ' + str(pred_box3ds[i].center_x)  + ' '  + \\\n    str(pred_box3ds[i].center_y) + ' '  + str(pred_box3ds[i].center_z) + ' '  + \\\n    str(pred_box3ds[i].width) + ' ' \\\n    + str(pred_box3ds[i].length) + ' '  + str(pred_box3ds[i].height) + ' ' + str(yaw) + ' ' \\\n    + str(pred_box3ds[i].name) + ' ' \n        \n    if pred_box3ds[i].sample_token in sub.keys():     \n        sub[pred_box3ds[i].sample_token] += pred\n    else:\n        sub[pred_box3ds[i].sample_token] = pred        \n    \nsample_sub = pd.read_csv('..\/input\/3d-object-detection-for-autonomous-vehicles\/sample_submission.csv')\nfor token in set(sample_sub.Id.values).difference(sub.keys()):\n#     print(token)\n    sub[token] = ''","f14b42d0":"sub = pd.DataFrame(list(sub.items()))\nsub.columns = sample_sub.columns\nsub.head()","2e95ec0c":"sub.tail()","1cd5315e":"sub.to_csv('lyft3d_pred.csv',index=False)","6fb90753":"# Unet Model","d958b142":"# Visualizing some model predictions\n","2a34c9b8":"# Find the mean height of all categories\nWe can use the mean height instead of blindly using 1.75m for all categories","3ad83f3a":"# Lyft SDK requires creating a link to input folders","732df9af":"# Creating Submission File","b3a78e50":"We train a U-net fully convolutional neural network, we create a network that is less deep and with only half the amount of filters compared to the original U-net paper implementation. We do this to keep training and inference time low.","cf4edb95":"## Updates 1\n\n- I have added code that does model prediction visualization by putting it in camera frame. I found this to be more intuitive than visualizing it in lidar frame.\nI hope you find it useful.\n\nIf you check out the reference model in [lyft devkit](https:\/\/github.com\/lyft\/nuscenes-devkit\/tree\/master\/notebooks), you will find that they are using map masks for training UNET. The map masks are first extracted around the corresponding ego region and used as 3 additional channels. This seems to be give some improvement in lb score.\n\nIn this notebook i do inference using such a trained trained model.\nI have extracted the ego centered maps and made a train and test dataset. You can find it [here](https:\/\/www.kaggle.com\/meaninglesslives\/lyft3d-mask-test-data). It takes a long time to compute on test set, so i am sharing it here :-D\n\n## Updates 2\nI have added code that shows how you can easily ensemble your models. Here, I use same models at different epochs of training. Even such a simple approach gives a slight boost. To get a bigger boost, you can try training models with different architectures. Good Luck !\n","448d6b12":"# Test Set Predictions","46ed71d1":"## We can use MLComp to ensemble multiple models easily.\nIt can also be used to TTA. Reduces boiler plate code.\n","b72677b9":"# Install the Lyft SDK","0203f4db":"# Loading trained Unet models","277ab68b":"# Transform predicted boxes back into world space"}}