{"cell_type":{"42523c4f":"code","c7b66c0e":"code","f566adca":"code","2db59f7e":"code","4b4177f5":"code","899781b6":"code","0448352c":"code","daf7226c":"code","03a35353":"markdown","926eb919":"markdown"},"source":{"42523c4f":"import torch\nfrom torch import nn\nfrom torch import optim\nfrom torchvision import datasets, transforms\nfrom torch.utils.data import random_split, DataLoader","c7b66c0e":"!pip install pytorch-lightning","f566adca":"import pytorch_lightning as pl\nfrom pytorch_lightning.metrics.functional import accuracy","2db59f7e":"train_accuracy = pl.metrics.Accuracy()\nvalid_accuracy = pl.metrics.Accuracy(compute_on_step=False)","4b4177f5":"class MNISTDataModule(pl.LightningDataModule):\n    def __init__(self, batch_size=64):\n        super().__init__()\n        self.batch_size = batch_size\n\n    def prepare_data(self):\n        datasets.MNIST('data', train=True, download=True, transform=transforms.ToTensor())\n        datasets.MNIST('data', train=False, download=True, transform=transforms.ToTensor())\n\n    def setup(self, stage):\n        transform=transforms.Compose([transforms.ToTensor()])\n        training_dataset = datasets.MNIST('data', train=True, download=False, transform=transform)\n        test_dataset = datasets.MNIST('data', train=False, download=False, transform=transform)\n        mnist_train, mnist_val = random_split(training_dataset, [55000, 5000])\n        \n        self.train_dataset = mnist_train\n        self.val_dataset = mnist_val\n        self.test_dataset = test_dataset\n\n    def train_dataloader(self):\n        return DataLoader(self.train_dataset, batch_size=self.batch_size)\n\n    def val_dataloader(self):\n        return DataLoader(self.val_dataset, batch_size=self.batch_size)\n\n    def test_dataloader(self):\n        return DataLoader(self.test_dataset, batch_size=self.batch_size)","899781b6":"class ImageClassifier(pl.LightningModule):\n    def __init__(self):\n        super().__init__()\n        self.l1 = nn.Linear(28 * 28, 64)\n        self.l2 = nn.Linear(64, 64)\n        self.l3 = nn.Linear(64, 10)\n        self.do = nn.Dropout(0.1)\n        self.loss = nn.CrossEntropyLoss()\n  \n    def forward(self, x):\n        h1 = nn.functional.relu(self.l1(x))\n        h2 = nn.functional.relu(self.l2(h1))\n        do = self.do(h2 + h1)\n        logits = self.l3(do)\n        return logits\n\n    def configure_optimizers(self):\n        optimizer = optim.SGD(self.parameters(), lr=1e-2)\n        return optimizer\n    \n    def training_step(self, batch, batch_idx):\n        x, y = batch\n        b = x.size(0)\n        x = x.view(b, -1)\n        l = self(x) # l: logits\n        J = self.loss(l, y)\n        acc = train_accuracy(l, y)\n        pbar = {'train_acc': acc}\n        return {'loss': J, 'progress_bar': pbar}\n\n    def validation_step(self, batch, batch_idx):\n        results = self.training_step(batch, batch_idx)\n        results['progress_bar']['val_acc'] = results['progress_bar']['train_acc']\n        del results['progress_bar']['train_acc']\n        return results\n\n    def validation_epoch_end(self, val_step_outputs):\n        avg_val_loss = torch.tensor([x['loss'] for x in val_step_outputs]).mean()\n        avg_val_acc = torch.tensor([x['progress_bar']['val_acc'] for x in val_step_outputs]).mean()\n        pbar = {'avg_val_acc': avg_val_acc}\n        return {'val_loss': avg_val_loss, 'progress_bar': pbar}","0448352c":"model = ImageClassifier()\nmnist_dm = MNISTDataModule()\ntrainer = pl.Trainer(progress_bar_refresh_rate=20, max_epochs=5)\ntrainer.fit(model, mnist_dm)","daf7226c":"model","03a35353":"# MNIST from Pytorch to Pytorch Lightning\nfrom 'Pytorch Lightning' YouTube Channel, 'Episode 3: From PyTorch to PyTorch Lightning'<br\/>\nhttps:\/\/youtu.be\/DbESHcCoWbM<br\/>\n<br\/>\npytorch code<br\/>\nhttps:\/\/www.kaggle.com\/stpeteishii\/mnist-pytorch-linear-sample\n","926eb919":"This notebook referred to Niko Gamulin's scripts.<br\/>\nhttps:\/\/colab.research.google.com\/drive\/1_YYYHRA-blncinGFz3dJeZExAoWxIkGh?usp=sharing"}}