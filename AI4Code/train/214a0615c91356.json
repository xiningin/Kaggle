{"cell_type":{"e7ea1c17":"code","c48bca79":"code","ed153018":"code","93bae2da":"code","c7ebe05d":"code","47ef35ca":"code","59252451":"code","cd34284c":"code","1c4cb4e6":"code","46162b3e":"code","63c148c1":"code","d49112c5":"code","30b38f8c":"code","bdaef6f2":"code","f2567d59":"code","50700c59":"code","e08f0fed":"code","57c3e399":"code","af0636f6":"code","273f248f":"code","818416d0":"code","32186019":"code","7e4c6344":"code","bb2fcc34":"code","41f0460c":"code","e9d42822":"code","55140292":"code","30c5270b":"code","2686dae5":"code","6051e7c5":"code","08d1c33c":"code","5a6fd996":"code","612add02":"code","0e53c65a":"code","70362a1e":"markdown","2c2489e2":"markdown","c969979c":"markdown","366d5524":"markdown","4aeb5db2":"markdown","ccae6953":"markdown","63e9f715":"markdown","769fb60c":"markdown","13305246":"markdown","d79d059b":"markdown","41d0ff17":"markdown","8052ad7d":"markdown","857990d1":"markdown","d437298c":"markdown","944c8de2":"markdown","09231e09":"markdown","22f55d33":"markdown","d92d97b2":"markdown","59c55cb1":"markdown","2657c7f0":"markdown","d5c85224":"markdown","589a86e9":"markdown","8db27e84":"markdown","868a8721":"markdown","227f5606":"markdown","803ab28c":"markdown","aa9ca094":"markdown","8e988c32":"markdown","c53c59dd":"markdown","b7e82ecf":"markdown","ff4198ad":"markdown","116e1526":"markdown","2fdda15d":"markdown","08099ab6":"markdown","8a6a29e5":"markdown","a9be53f9":"markdown","2b7b4ce5":"markdown","b6199637":"markdown","b62a9988":"markdown"},"source":{"e7ea1c17":"!pip install -qU wandb\n!pip install -qU bbox-utility # check https:\/\/github.com\/awsaf49\/bbox for source code","c48bca79":"import numpy as np\nfrom tqdm.notebook import tqdm\ntqdm.pandas()\nimport pandas as pd\nimport os\nimport cv2\nimport matplotlib.pyplot as plt\nimport glob\n\nimport shutil\nimport sys\nsys.path.append('..\/input\/tensorflow-great-barrier-reef')\n\nfrom joblib import Parallel, delayed\n\nfrom IPython.display import display","ed153018":"import wandb\n\ntry:\n    from kaggle_secrets import UserSecretsClient\n    user_secrets = UserSecretsClient()\n    api_key = user_secrets.get_secret(\"WANDB\")\n    wandb.login(key=api_key)\n    anonymous = None\nexcept:\n    wandb.login(anonymous='must')\n    print('To use your W&B account,\\nGo to Add-ons -> Secrets and provide your W&B access token. Use the Label name as WANDB. \\nGet your W&B access token from here: https:\/\/wandb.ai\/authorize')","93bae2da":"FOLD      = 1 # which fold to train\nDIM       = 3000 \nMODEL     = 'yolov5s6'\nBATCH     = 4\nEPOCHS    = 7\nOPTMIZER  = 'Adam'\n\nPROJECT   = 'great-barrier-reef-public' # w&b in yolov5\nNAME      = f'{MODEL}-dim{DIM}-fold{FOLD}' # w&b for yolov5\n\nREMOVE_NOBBOX = True # remove images with no bbox\nROOT_DIR  = '\/kaggle\/input\/tensorflow-great-barrier-reef\/'\nIMAGE_DIR = '\/kaggle\/images' # directory to save images\nLABEL_DIR = '\/kaggle\/labels' # directory to save labels","c7ebe05d":"!mkdir -p {IMAGE_DIR}\n!mkdir -p {LABEL_DIR}","47ef35ca":"# Train Data\ndf = pd.read_csv(f'{ROOT_DIR}\/train.csv')\ndf['old_image_path'] = f'{ROOT_DIR}\/train_images\/video_'+df.video_id.astype(str)+'\/'+df.video_frame.astype(str)+'.jpg'\ndf['image_path']  = f'{IMAGE_DIR}\/'+df.image_id+'.jpg'\ndf['label_path']  = f'{LABEL_DIR}\/'+df.image_id+'.txt'\ndf['annotations'] = df['annotations'].progress_apply(eval)\ndisplay(df.head(2))","59252451":"df['num_bbox'] = df['annotations'].progress_apply(lambda x: len(x))\ndata = (df.num_bbox>0).value_counts(normalize=True)*100\nprint(f\"No BBox: {data[0]:0.2f}% | With BBox: {data[1]:0.2f}%\")","cd34284c":"if REMOVE_NOBBOX:\n    df = df.query(\"num_bbox>0\")","1c4cb4e6":"def make_copy(row):\n    shutil.copyfile(row.old_image_path, row.image_path)\n    return","46162b3e":"image_paths = df.old_image_path.tolist()\n_ = Parallel(n_jobs=-1, backend='threading')(delayed(make_copy)(row) for _, row in tqdm(df.iterrows(), total=len(df)))","63c148c1":"# check https:\/\/github.com\/awsaf49\/bbox for source code of following utility functions\nfrom bbox.utils import coco2yolo, coco2voc, voc2yolo\nfrom bbox.utils import draw_bboxes, load_image\nfrom bbox.utils import clip_bbox, str2annot, annot2str\n\ndef get_bbox(annots):\n    bboxes = [list(annot.values()) for annot in annots]\n    return bboxes\n\ndef get_imgsize(row):\n    row['width'], row['height'] = imagesize.get(row['image_path'])\n    return row\n\nnp.random.seed(32)\ncolors = [(np.random.randint(255), np.random.randint(255), np.random.randint(255))\\\n          for idx in range(1)]","d49112c5":"df['bboxes'] = df.annotations.progress_apply(get_bbox)\ndf.head(2)","30b38f8c":"df['width']  = 1280\ndf['height'] = 720\ndisplay(df.head(2))","bdaef6f2":"cnt = 0\nall_bboxes = []\nbboxes_info = []\nfor row_idx in tqdm(range(df.shape[0])):\n    row = df.iloc[row_idx]\n    image_height = row.height\n    image_width  = row.width\n    bboxes_coco  = np.array(row.bboxes).astype(np.float32).copy()\n    num_bbox     = len(bboxes_coco)\n    names        = ['cots']*num_bbox\n    labels       = np.array([0]*num_bbox)[..., None].astype(str)\n    ## Create Annotation(YOLO)\n    with open(row.label_path, 'w') as f:\n        if num_bbox<1:\n            annot = ''\n            f.write(annot)\n            cnt+=1\n            continue\n        bboxes_voc  = coco2voc(bboxes_coco, image_height, image_width)\n        bboxes_voc  = clip_bbox(bboxes_voc, image_height, image_width)\n        bboxes_yolo = voc2yolo(bboxes_voc, image_height, image_width).astype(str)\n        all_bboxes.extend(bboxes_yolo.astype(float))\n        bboxes_info.extend([[row.image_id, row.video_id, row.sequence]]*len(bboxes_yolo))\n        annots = np.concatenate([labels, bboxes_yolo], axis=1)\n        string = annot2str(annots)\n        f.write(string)\nprint('Missing:',cnt)","f2567d59":"from sklearn.model_selection import GroupKFold\nkf = GroupKFold(n_splits = 3)\ndf = df.reset_index(drop=True)\ndf['fold'] = -1\nfor fold, (train_idx, val_idx) in enumerate(kf.split(df, groups=df.video_id.tolist())):\n    df.loc[val_idx, 'fold'] = fold\ndisplay(df.fold.value_counts())","50700c59":"bbox_df = pd.DataFrame(np.concatenate([bboxes_info, all_bboxes], axis=1),\n             columns=['image_id','video_id','sequence',\n                     'xmid','ymid','w','h'])\nbbox_df[['xmid','ymid','w','h']] = bbox_df[['xmid','ymid','w','h']].astype(float)\nbbox_df['area'] = bbox_df.w * bbox_df.h * 1280 * 720\nbbox_df = bbox_df.merge(df[['image_id','fold']], on='image_id', how='left')\nbbox_df.head(2)","e08f0fed":"from scipy.stats import gaussian_kde\n\nall_bboxes = np.array(all_bboxes)\n\nx_val = all_bboxes[...,0]\ny_val = all_bboxes[...,1]\n\n# Calculate the point density\nxy = np.vstack([x_val,y_val])\nz = gaussian_kde(xy)(xy)\n\nfig, ax = plt.subplots(figsize = (10, 10))\n# ax.axis('off')\nax.scatter(x_val, y_val, c=z, s=100, cmap='viridis')\n# ax.set_xlabel('x_mid')\n# ax.set_ylabel('y_mid')\nplt.show()","57c3e399":"x_val = all_bboxes[...,2]\ny_val = all_bboxes[...,3]\n\n# Calculate the point density\nxy = np.vstack([x_val,y_val])\nz = gaussian_kde(xy)(xy)\n\nfig, ax = plt.subplots(figsize = (10, 10))\n# ax.axis('off')\nax.scatter(x_val, y_val, c=z, s=100, cmap='viridis')\n# ax.set_xlabel('bbox_width')\n# ax.set_ylabel('bbox_height')\nplt.show()","af0636f6":"import matplotlib as mpl\nimport seaborn as sns\n\nf, ax = plt.subplots(figsize=(12, 6))\nsns.despine(f)\n\nsns.histplot(\n    bbox_df,\n    x=\"area\", hue=\"fold\",\n    multiple=\"stack\",\n    palette=\"viridis\",\n    edgecolor=\".3\",\n    linewidth=.5,\n    log_scale=True,\n)\nax.xaxis.set_major_formatter(mpl.ticker.ScalarFormatter())\nax.set_xticks([500, 1000, 2000, 5000, 10000]);","273f248f":"df2 = df[(df.num_bbox>0)].sample(100) # takes samples with bbox\ny = 3; x = 2\nplt.figure(figsize=(12.8*x, 7.2*y))\nfor idx in range(x*y):\n    row = df2.iloc[idx]\n    img           = load_image(row.image_path)\n    image_height  = row.height\n    image_width   = row.width\n    with open(row.label_path) as f:\n        annot = str2annot(f.read())\n    bboxes_yolo = annot[...,1:]\n    labels      = annot[..., 0].astype(int).tolist()\n    names         = ['cots']*len(bboxes_yolo)\n    plt.subplot(y, x, idx+1)\n    plt.imshow(draw_bboxes(img = img,\n                           bboxes = bboxes_yolo, \n                           classes = names,\n                           class_ids = labels,\n                           class_name = True, \n                           colors = colors, \n                           bbox_format = 'yolo',\n                           line_thickness = 2))\n    plt.axis('OFF')\nplt.tight_layout()\nplt.show()","818416d0":"train_files = []\nval_files   = []\ntrain_df = df.query(\"fold!=@FOLD\")\nvalid_df = df.query(\"fold==@FOLD\")\ntrain_files += list(train_df.image_path.unique())\nval_files += list(valid_df.image_path.unique())\nlen(train_files), len(val_files)","32186019":"import yaml\n\ncwd = '\/kaggle\/working\/'\n\nwith open(os.path.join( cwd , 'train.txt'), 'w') as f:\n    for path in train_df.image_path.tolist():\n        f.write(path+'\\n')\n            \nwith open(os.path.join(cwd , 'val.txt'), 'w') as f:\n    for path in valid_df.image_path.tolist():\n        f.write(path+'\\n')\n\ndata = dict(\n    path  = '\/kaggle\/working',\n    train =  os.path.join( cwd , 'train.txt') ,\n    val   =  os.path.join( cwd , 'val.txt' ),\n    nc    = 1,\n    names = ['cots'],\n    )\n\nwith open(os.path.join( cwd , 'gbr.yaml'), 'w') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False)\n\nf = open(os.path.join( cwd , 'gbr.yaml'), 'r')\nprint('\\nyaml:')\nprint(f.read())","7e4c6344":"%%writefile \/kaggle\/working\/hyp.yaml\nlr0: 0.01  # initial learning rate (SGD=1E-2, Adam=1E-3)\nlrf: 0.1  # final OneCycleLR learning rate (lr0 * lrf)\nmomentum: 0.937  # SGD momentum\/Adam beta1\nweight_decay: 0.0005  # optimizer weight decay 5e-4\nwarmup_epochs: 3.0  # warmup epochs (fractions ok)\nwarmup_momentum: 0.8  # warmup initial momentum\nwarmup_bias_lr: 0.1  # warmup initial bias lr\nbox: 0.05  # box loss gain\ncls: 0.5  # cls loss gain\ncls_pw: 1.0  # cls BCELoss positive_weight\nobj: 1.0  # obj loss gain (scale with pixels)\nobj_pw: 1.0  # obj BCELoss positive_weight\niou_t: 0.20  # IoU training threshold\nanchor_t: 4.0  # anchor-multiple threshold\n# anchors: 3  # anchors per output layer (0 to ignore)\nfl_gamma: 0.0  # focal loss gamma (efficientDet default gamma=1.5)\nhsv_h: 0.015  # image HSV-Hue augmentation (fraction)\nhsv_s: 0.7  # image HSV-Saturation augmentation (fraction)\nhsv_v: 0.4  # image HSV-Value augmentation (fraction)\ndegrees: 0.0  # image rotation (+\/- deg)\ntranslate: 0.10  # image translation (+\/- fraction)\nscale: 0.5  # image scale (+\/- gain)\nshear: 0.0  # image shear (+\/- deg)\nperspective: 0.0  # image perspective (+\/- fraction), range 0-0.001\nflipud: 0.5  # image flip up-down (probability)\nfliplr: 0.5  # image flip left-right (probability)\nmosaic: 0.5  # image mosaic (probability)\nmixup: 0.5 # image mixup (probability)\ncopy_paste: 0.0  # segment copy-paste (probability)","bb2fcc34":"%cd \/kaggle\/working\n!rm -r \/kaggle\/working\/yolov5\n# !git clone https:\/\/github.com\/ultralytics\/yolov5 # clone\n!cp -r \/kaggle\/input\/yolov5-lib-ds \/kaggle\/working\/yolov5\n%cd yolov5\n%pip install -qr requirements.txt  # install\n\nfrom yolov5 import utils\ndisplay = utils.notebook_init()  # check","41f0460c":"!python train.py --img {DIM}\\\n--batch {BATCH}\\\n--epochs {EPOCHS}\\\n--optimizer {OPTMIZER}\\\n--data \/kaggle\/working\/gbr.yaml\\\n--hyp \/kaggle\/working\/hyp.yaml\\\n--weights {MODEL}.pt\\\n--project {PROJECT} --name {NAME}\\\n--exist-ok","e9d42822":"OUTPUT_DIR = '{}\/{}'.format(PROJECT, NAME)\n!ls {OUTPUT_DIR}","55140292":"plt.figure(figsize = (10,10))\nplt.axis('off')\nplt.imshow(plt.imread(f'{OUTPUT_DIR}\/labels_correlogram.jpg'));","30c5270b":"plt.figure(figsize = (10,10))\nplt.axis('off')\nplt.imshow(plt.imread(f'{OUTPUT_DIR}\/labels.jpg'));","2686dae5":"import matplotlib.pyplot as plt\nplt.figure(figsize = (10, 10))\nplt.imshow(plt.imread(f'{OUTPUT_DIR}\/train_batch0.jpg'))\n\nplt.figure(figsize = (10, 10))\nplt.imshow(plt.imread(f'{OUTPUT_DIR}\/train_batch1.jpg'))\n\nplt.figure(figsize = (10, 10))\nplt.imshow(plt.imread(f'{OUTPUT_DIR}\/train_batch2.jpg'))","6051e7c5":"fig, ax = plt.subplots(3, 2, figsize = (2*9,3*5), constrained_layout = True)\nfor row in range(3):\n    ax[row][0].imshow(plt.imread(f'{OUTPUT_DIR}\/val_batch{row}_labels.jpg'))\n    ax[row][0].set_xticks([])\n    ax[row][0].set_yticks([])\n    ax[row][0].set_title(f'{OUTPUT_DIR}\/val_batch{row}_labels.jpg', fontsize = 12)\n    \n    ax[row][1].imshow(plt.imread(f'{OUTPUT_DIR}\/val_batch{row}_pred.jpg'))\n    ax[row][1].set_xticks([])\n    ax[row][1].set_yticks([])\n    ax[row][1].set_title(f'{OUTPUT_DIR}\/val_batch{row}_pred.jpg', fontsize = 12)\nplt.show()","08d1c33c":"plt.figure(figsize=(30,15))\nplt.axis('off')\nplt.imshow(plt.imread(f'{OUTPUT_DIR}\/results.png'));","5a6fd996":"plt.figure(figsize=(12,10))\nplt.axis('off')\nplt.imshow(plt.imread(f'{OUTPUT_DIR}\/confusion_matrix.png'));","612add02":"for metric in ['F1', 'PR', 'P', 'R']:\n    print(f'Metric: {metric}')\n    plt.figure(figsize=(12,10))\n    plt.axis('off')\n    plt.imshow(plt.imread(f'{OUTPUT_DIR}\/{metric}_curve.png'));\n    plt.show()","0e53c65a":"!rm -r {IMAGE_DIR}\n!rm -r {LABEL_DIR}","70362a1e":"# \ud83c\udf08 Visualization","2c2489e2":"## `x_center` Vs `y_center`","c969979c":"# \ud83c\udf5a Dataset","366d5524":"## Create BBox","4aeb5db2":"# [Tensorflow - Help Protect the Great Barrier Reef](https:\/\/www.kaggle.com\/c\/tensorflow-great-barrier-reef)\n> Detect crown-of-thorns starfish in underwater image data\n\n<img src=\"https:\/\/storage.googleapis.com\/kaggle-competitions\/kaggle\/31703\/logos\/header.png?t=2021-10-29-00-30-04\">","ccae6953":"## Get Image-Size\n> All Images have same dimension, [Width, Height] =  `[1280, 720]`","63e9f715":"# \ud83d\udee0 Install Libraries","769fb60c":"## Output Files","13305246":"# \ud83d\udccc Key-Points\n* One have to submit prediction using the provided **python time-series API**, which makes this competition different from previous Object Detection Competitions.\n* Each prediction row needs to include all bounding boxes for the image. Submission is format seems also **COCO** which means `[x_min, y_min, width, height]`\n* Copmetition metric `F2` tolerates some false positives(FP) in order to ensure very few starfish are missed. Which means tackling **false negatives(FN)** is more important than false positives(FP). \n$$F2 = 5 \\cdot \\frac{precision \\cdot recall}{4\\cdot precision + recall}$$","d79d059b":"# \ud83d\udcc1 Create Folds\n> Number of samples aren't same in each fold which can create large variance in **Cross-Validation**.","41d0ff17":"# \u2b55 BBox Distribution","8052ad7d":"## Area","857990d1":"# \u2702\ufe0f Remove Files","d437298c":"## Number of BBoxes\n> Nearly 80% images are without any bbox.","944c8de2":"<div align=\"center\"><img src=\"https:\/\/www.pngall.com\/wp-content\/uploads\/2018\/04\/Under-Construction-PNG-File.png\" width=600>","09231e09":"## Confusion Matrix","22f55d33":"# \ud83d\ude85 Training","d92d97b2":"## `width` Vs `height`","59c55cb1":"# \ud83d\udd28 Helper","2657c7f0":"## Score Vs Epoch","d5c85224":"# \u2699\ufe0f Configuration\nThe dataset config file requires\n1. The dataset root directory path and relative paths to `train \/ val \/ test` image directories (or *.txt files with image paths)\n2. The number of classes `nc` and \n3. A list of class `names`:`['cots']`","589a86e9":"## Create Directories","8db27e84":"# \u2728 Overview\n<span style=\"color: #000508; font-family: Segoe UI; font-size: 1.5em; font-weight: 300;\"><a href=\"https:\/\/wandb.ai\/awsaf49\/great-barrier-reef-public\">View the Complete Dashboard Here \u2b95<\/a><\/span>\n![image.png](attachment:14c7fea9-9a96-45de-a620-675270d74c8d.png)","868a8721":"# \ud83d\udd0d Result","227f5606":"# \ud83d\udcc8 Class Distribution","803ab28c":"# \ud83d\udce6 [YOLOv5](https:\/\/github.com\/ultralytics\/yolov5\/)\n<div align=center><img src=\"https:\/\/github.com\/ultralytics\/yolov5\/releases\/download\/v1.0\/splash.jpg\" width=800>","aa9ca094":"# \ud83d\udd2d Batch Image","8e988c32":"## Get Paths","c53c59dd":"# \ud83c\udff7\ufe0f Create Labels\nWe need to export our labels to **YOLO** format, with one `*.txt` file per image (if no objects in image, no `*.txt` file is required). The *.txt file specifications are:\n\n* One row per object\n* Each row is class `[x_center, y_center, width, height]` format.\n* Box coordinates must be in **normalized** `xywh` format (from `0 - 1`). If your boxes are in pixels, divide `x_center` and `width` by `image width`, and `y_center` and `height` by `image height`.\n* Class numbers are **zero-indexed** (start from `0`).\n\n> Competition bbox format is **COCO** hence `[x_min, y_min, width, height]`. So, we need to convert form **COCO** to **YOLO** format.\n","b7e82ecf":"# \ud83e\uddf9 Clean Data\n* In this notebook, we use only **bboxed-images** (`~5k`). We can use all `~23K` images for train but most of them don't have any labels. So it would be easier to carry out experiments using only **bboxed images**.","ff4198ad":"## Please Upvote if you find this Helpful","116e1526":"# \u270f\ufe0f Write Images\n* We need to copy the Images to Current Directory(`\/kaggle\/working`) as `\/kaggle\/input` doesn't have **write access** which is needed for **YOLOv5**.\n* We can make this process faster using **Joblib** which uses **Parallel** computing.","2fdda15d":"# \ud83d\udcda Import Libraries","08099ab6":"## GT Vs Pred","8a6a29e5":"## \ud83d\udcd2 Notebooks:\n* Train: [Great-Barrier-Reef: YOLOv5 [train] \ud83c\udf0a](https:\/\/www.kaggle.com\/awsaf49\/great-barrier-reef-yolov5-train)\n* Infer: [Great-Barrier-Reef: YOLOv5 [infer] \ud83c\udf0a](https:\/\/www.kaggle.com\/awsaf49\/great-barrier-reef-yolov5-infer)","a9be53f9":"# \ud83d\udcd6 Meta Data\n* `train_images\/` - Folder containing training set photos of the form `video_{video_id}\/{video_frame}.jpg`.\n\n* `[train\/test].csv` - Metadata for the images. As with other test files, most of the test metadata data is only available to your notebook upon submission. Just the first few rows available for download.\n\n* `video_id` - ID number of the video the image was part of. The video ids are not meaningfully ordered.\n* `video_frame` - The frame number of the image within the video. Expect to see occasional gaps in the frame number from when the diver surfaced.\n* `sequence` - ID of a gap-free subset of a given video. The sequence ids are not meaningfully ordered.\n* `sequence_frame` - The frame number within a given sequence.\n* `image_id` - ID code for the image, in the format `{video_id}-{video_frame}`\n* `annotations` - The bounding boxes of any starfish detections in a string format that can be evaluated directly with Python. Does not use the same format as the predictions you will submit. Not available in test.csv. A bounding box is described by the pixel coordinate `(x_min, y_min)` of its lower left corner within the image together with its `width` and `height` in pixels --> (COCO format).","2b7b4ce5":"# \u2b50 WandB\n<img src=\"https:\/\/camo.githubusercontent.com\/dd842f7b0be57140e68b2ab9cb007992acd131c48284eaf6b1aca758bfea358b\/68747470733a2f2f692e696d6775722e636f6d2f52557469567a482e706e67\" width=600>\n\nWeights & Biases (W&B) is MLOps platform for tracking our experiemnts. We can use it to Build better models faster with experiment tracking, dataset versioning, and model management. Some of the cool features of W&B:\n\n* Track, compare, and visualize ML experiments\n* Get live metrics, terminal logs, and system stats streamed to the centralized dashboard.\n* Explain how your model works, show graphs of how model versions improved, discuss bugs, and demonstrate progress towards milestones.\n","b6199637":"## Please Upvote if you find this Helpful","b62a9988":"## Metrics"}}