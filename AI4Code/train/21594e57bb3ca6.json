{"cell_type":{"12fea19a":"code","505741f7":"code","45a9be6d":"code","ffd38bf1":"code","ae379425":"code","7d5a3a68":"code","28fb42d5":"code","b9d196ea":"code","d0d6ff4b":"code","abea6e00":"code","04d791b3":"code","0f802e32":"code","be462ea7":"code","a34ceed3":"code","5c8c33f4":"code","477fdd9a":"code","4476c148":"code","de642141":"code","7a9c3b2f":"code","46c08a4c":"code","3809f19b":"code","2789a351":"code","4e527518":"code","48f96eaa":"markdown","6131ed48":"markdown","31ea6026":"markdown","aa0688e0":"markdown","e787373a":"markdown","7b098690":"markdown","2c472979":"markdown"},"source":{"12fea19a":"pip install tensorflow-io","505741f7":"pip install python-gdcm","45a9be6d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\nt_image_fnames = []\npath = \"\/kaggle\/input\/siim-covid19-detection\/train\/\"\nimport os\nlen(os.listdir(path))\nfor root, dirs, filenames in os.walk(path):\n    for fname in filenames:\n        t_image_fnames.append(os.path.join(root,fname))\n\ntrain_image_level = pd.read_csv(\"\/kaggle\/input\/siim-covid19-detection\/train_image_level.csv\")\ntrain_study_level = pd.read_csv(\"\/kaggle\/input\/siim-covid19-detection\/train_study_level.csv\")    \nlen(t_image_fnames)\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","ffd38bf1":"if len(train_image_level.id) == len(t_image_fnames):\n    print(\"length is almost the same\")\n    \nelse:\n    print(\"you fucked up\")\n    \ntrain_image_level.head()","ae379425":"train_image_level.isnull().sum()","7d5a3a68":"# verifying the directory stucture.\nfor i in train_image_level[\"StudyInstanceUID\"]:\n    if i == \"0135d267f462\":\n        print(\"its here\")\n        break\ntrain_image_level.id = train_image_level.id.str.split(\"_\",expand = True,n=0)\n\n# The number of cases with more than one images\n\ntrain_image_level.StudyInstanceUID.duplicated().sum()        ","28fb42d5":"NUM_IMAGES = 200 #@param {type:\"slider\", min:100, max:6334, step: 10 }","b9d196ea":"train_image_level.head()","d0d6ff4b":"### Setup X & y variables\n\nX = t_image_fnames\ny = train_image_level.label\nbboxes = train_image_level.boxes","abea6e00":"y[1]","04d791b3":"import matplotlib.pyplot as plt\n\nimport pydicom\n%matplotlib inline\nplt.figure(figsize = (10,8))\nimage = pydicom.dcmread(X[21])\nplt.imshow(image.pixel_array,cmap=plt.cm.bone)\n","0f802e32":"import matplotlib.pyplot as plt\nimport pydicom\n\ndef show_25_images(images):\n    \"\"\"\n    Displays a plot of 25 images and their labes for training images\n    \"\"\"\n    \n    # setup the figure\n    plt.figure(figsize = (10,10))\n    \n    # loop through 25 files to display 25 images\n    for i in range(25):\n        # Create subplots ( 5 rows , 5 columns)\n        ax = plt.subplot(5,5,i+1)\n        # display an image\n        image = pydicom.dcmread(images[i])\n        plt.imshow(image.pixel_array,cmap = plt.cm.bone)\n        plt.axis(\"off\")\n        \n        ","be462ea7":"show_25_images(X)","a34ceed3":"len(X), len(y), len(bboxes)","5c8c33f4":"import matplotlib.pyplot as plt\nimport pydicom \n%matplotlib inline\nplt.figure(figsize = (10,8))\nimage = pydicom.dcmread(X[2])\nplt.imshow(image.pixel_array,cmap=plt.cm.bone)","477fdd9a":"import ast\nboxes = ast.literal_eval(train_image_level.loc[3,'boxes'])\nboxes","4476c148":"img = pydicom.dcmread(X[3])\nimg = img.pixel_array\nimg","de642141":"import matplotlib\nfig,ax = plt.subplots(figsize=(10,8))\n\nfor box in boxes:\n    p = matplotlib.patches.Rectangle((box['x'], box['y']),box['width'], box['height'],\n                                     ec='r' , fc = 'none',lw = 2.)\n    ax.add_patch(p)\n    \nax.imshow(img, cmap= plt.cm.bone)\nplt.show()\n                                     ","7a9c3b2f":"fig, axs = plt.subplots(3,3,figsize = (20,16))\nfig.subplots_adjust(hspace = .1 , wspace = .1)\naxs = axs.ravel()\n\nfor row in range(9):\n    study = train_image_level.loc[row, 'StudyInstanceUID']\n    dt_file =pydicom.dcmread( X[row])\n    img = dt_file.pixel_array\n    if(train_image_level.loc[row,'boxes']!= train_image_level.loc[row,'boxes']) == False:\n        boxes = ast.literal_eval(train_image_level.loc[row,'boxes'])\n        \n        for box in boxes:\n            p = matplotlib.patches.Rectangle((box['x'],box['y']), box['width'], box['height'],\n                                           ec = 'r',fc = 'none', lw = 2.)\n            axs[row].add_patch(p)\n    axs[row].imshow(img,cmap = plt.cm.bone)\n    axs[row].set_title(train_image_level.loc[row,'label'].split(' ')[0])\n    axs[row].set_xticklabels([])\n    axs[row].set_yticklabels([])\n    ","46c08a4c":"import PIL\nfrom PIL import Image, ImageDraw, ImageFont\nimport tensorflow as tf\nimport tensorflow_io as tfio\nimg1 = pydicom.dcmread(X[0])\nb = tf.constant(img1.pixel_array)\n","3809f19b":"# Define image size\nIMAGE_SIZE = 416\n\n# create a function for preprocessing the images\n\ndef process_image(path):\n    \"\"\"\n    takes an image file and turn image into a tensor\n    \"\"\"\n    img=pydicom.dcmread(path)\n    img = img.pixel_array\n    img = np.array(img)\n    \n    if len(img.shape)<3 :\n        w, h = img.shape\n        ret = np.empty((w, h, 3), dtype=np.uint8)\n        ret[:, :, 2] =  ret[:, :, 1] =  ret[:, :, 0] =  img\n        img=ret \n    # read in image file path and turn image into a tensor\n    image = img\n    image = tf.convert_to_tensor(image, np.float32)\n     #convert the colour channel values from 0-255 to 0-1\n    image = tf.image.convert_image_dtype(image,tf.float32)\n     # Resize the image to our desired value (224,224)\n    image = tf.image.resize(image, size=[IMAGE_SIZE, IMAGE_SIZE])\n    \n    \n    return image","2789a351":"a = process_image(X[0])","4e527518":"# Create a simple function to return a tuple( image , label)","48f96eaa":"## Turning our data into batches\n\nwe do about 32 (This is the batch size) images at a time (you can manually adjust the batchsize if need to)\n\nIn order to use TensorFLow effectively, we need our data in the form of Tensor Tuples which look like this: (image , label)","6131ed48":"## Creating our own validation set\n\nNow gotta create the datasets and create our own validation set\n","31ea6026":"## Function to show 25 Images\n","aa0688e0":"## Lets see what improting an image looks like:\n\n","e787373a":"## Go to the colab notebook for details\n","7b098690":"## Create a function to preprocess the images\n1. It should Take an image filepath as input i.e. X[0]\n2. Using pydicom it should convert the read file into `TENSORS`\n3. Normalise the image ( convert colour channel from 0-225 to 0-1 ).\n4. Resize the image to be of the shape of (416,416)\n5. Return the modified image.\n\n* Had to convert the images in to RGB to convert them into acceptable Tensor\n","2c472979":"## Preprocessing Images (Turning images into tensors)\n\nWrite a function to preprocess images\n* 1. Take an image filepath as input\n* 2. Use Tensorflow to read the file and save it to a variable, `image`\n* 3. Turn our image (dicom) into Tensors\n* 4. Resize the image to a shape of (416,416) # Hyper parameter to experiment with\n* 5. Return the modified image"}}