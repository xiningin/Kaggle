{"cell_type":{"9afc4a59":"code","7a1d9486":"code","d138a396":"code","8cf02dcb":"code","c751fa90":"code","b68e5f77":"code","91762d23":"code","03ecb62d":"code","d62ef867":"code","fa1186b8":"code","6439f969":"code","c434b2f8":"code","846575a7":"code","17b92978":"code","d0f25f4d":"code","a4ad9fab":"code","f3c59ba0":"code","f621f3c0":"code","dd39bde6":"code","54bfb666":"code","4129e0e2":"code","0e5ad32f":"markdown"},"source":{"9afc4a59":"from IPython.display import display,HTML\ndef dhtml(str):\n    display(HTML(\"\"\"<style>\n    @import 'https:\/\/fonts.googleapis.com\/css?family=Orbitron&effect=3d';      \n    <\/style><h1 class='font-effect-3d' \n    style='font-family:Orbitron; color:#ff1155;'>\n    %s<\/h1>\"\"\"%str))","7a1d9486":"dhtml('Code Modules, Functions, & Classes')","d138a396":"import numpy as np,pandas as pd,pylab as pl\nimport h5py,torch,time,copy,urllib,zipfile\nfrom torchvision.datasets import CIFAR10 as tcifar10\nfrom torchvision import transforms,utils,models\nfrom torch.utils.data import DataLoader as tdl\nfrom torch.utils.data import Dataset as tds\nfrom torch.utils.data.dataset import Subset\nimport torch.nn.functional as tnnf\nimport torch.nn as tnn\nimport tensorflow.image as timage\nfrom IPython.core.magic import register_line_magic\ndev=torch.device(\"cuda:0\" \\\nif torch.cuda.is_available() else \"cpu\")\npl.ion() ","8cf02dcb":"class TData(tds):\n    def __init__(self,x,y):   \n        self.x=torch.tensor(x,dtype=torch.float32)\n        self.y=torch.tensor(y,dtype=torch.int32)\n    def __getitem__(self,index):\n        img,lbl=self.x[index],self.y[index]\n        return img,lbl\n    def __len__(self):\n        return self.y.shape[0]","c751fa90":"@register_line_magic\ndef display_examples(data):\n    for images,labels in dataloaders2[data]:  \n        print('Image dimensions: %s'%str(images.shape))\n        print('Label dimensions: %s'%str(labels.shape))\n        n=np.random.randint(1,50)\n        fig=pl.figure(figsize=(10,4))\n        for i in range(n,n+5):\n            ax=fig.add_subplot(1,5,i-n+1,\\\n            xticks=[],yticks=[],title=labels[i].item())\n            ax.imshow((images[i]).reshape(img_size,img_size,3))\n        break\ndef show_image(img):\n    npimg=img.numpy()\/2.+.5; tr=(1,2,0)\n    pl.figure(figsize=(10,2))\n    pl.imshow(np.transpose(npimg,tr))\n    pl.xticks([]); pl.show()\n@register_line_magic\ndef show_examples(data):\n    dataiter=iter(dataloaders[data])\n    images,labels=dataiter.next()\n    show_image(utils.make_grid(images[0:5]))\n    print('^'.join('%11s'%classes[labels[j]] \n                   for j in range(5)),end='^')","b68e5f77":"dhtml('Data')","91762d23":"img_size=32\nclasses=('plane','car','bird','cat','deer',\n          'dog','frog','horse','ship','truck')\nrandom_seed=12; batch_size=256\ntrain_ids=torch.arange(0,44000)\nvalid_ids=torch.arange(44000,50000)\ntr0=(.5,.5,.5)\ntrain_transform=transforms\\\n.Compose([transforms.ToTensor(),\n          transforms.Normalize(tr0,tr0)])\ntest_transform=transforms\\\n.Compose([transforms.ToTensor(),\n          transforms.Normalize(tr0,tr0)])\ntrain_valid=tcifar10(root='data',train=True,\n                     download=True,\n                     transform=train_transform)\ntrain=Subset(train_valid,train_ids)\nvalid=Subset(train_valid,valid_ids)\ntest=tcifar10(root='data',train=False, \n              transform=test_transform)\ndataloaders={'train':tdl(dataset=train,shuffle=True, \n                         batch_size=batch_size), \n             'valid':tdl(dataset=valid,shuffle=True, \n                         batch_size=batch_size),\n             'test':tdl(dataset=test,shuffle=True, \n                        batch_size=batch_size)}","03ecb62d":"%show_examples test","d62ef867":"fpath='..\/input\/classification-of-handwritten-letters\/'\nf='LetterColorImages_123.h5'\nf=h5py.File(fpath+f,'r')\nkeys=list(f.keys()); print(keys)\nx=np.array(f[keys[1]],dtype='float32')\nx=x.reshape(-1,3,img_size,img_size)\/255\nprint(x.mean(),x.std())\ny=np.array(f[keys[2]],dtype='int32')-1\nN=len(y); n=int(.1*N)\nshuffle_ids=np.arange(N)\nnp.random.RandomState(23).shuffle(shuffle_ids)\nx,y=x[shuffle_ids],y[shuffle_ids]\nx_test,x_valid,x_train=x[:n],x[n:2*n],x[2*n:]\ny_test,y_valid,y_train=y[:n],y[n:2*n],y[2*n:]\nrandom_seed=23; batch_size2=128\ntrain2=TData(x_train,y_train)\nvalid2=TData(x_valid,y_valid)\ntest2=TData(x_test,y_test)\ndataloaders2={'train':tdl(dataset=train2,shuffle=True, \n                          batch_size=batch_size), \n              'valid':tdl(dataset=valid2,shuffle=True, \n                          batch_size=batch_size),\n              'test':tdl(dataset=test2,shuffle=True, \n                         batch_size=batch_size)}","fa1186b8":"%display_examples valid","6439f969":"dhtml('Model Loading and Training')","c434b2f8":"def train_model(model,dataloaders,criterion,optimizer,\n                scheduler,num_epochs):\n    start=time.time(); best_acc=0.\n    best_model_wts=copy.deepcopy(model.state_dict())\n    for epoch in range(num_epochs):\n        print('Epoch {}\/{}'.format(epoch+1,num_epochs))\n        print('-'*10)\n        for phase in ['train','valid']:\n            if phase=='train': model.train()\n            else: model.eval()\n            running_loss=0.; running_corrects=0\n            for images,labels in dataloaders[phase]:\n                images=images.to(dev)\n                labels=labels.to(dev).long()\n                optimizer.zero_grad()\n                with torch.set_grad_enabled(phase=='train'):\n                    outputs=model(images)\n                    _, preds=torch.max(outputs,1)\n                    loss=criterion(outputs,labels)\n                    if phase=='train':\n                        loss.backward(); optimizer.step()\n                running_loss+=loss.item()*images.size(0)\n                running_corrects+=torch.sum(preds==labels.data)\n            if phase=='train': scheduler.step()\n            epoch_loss=running_loss\/dataset_sizes[phase]\n            epoch_acc=running_corrects.double()\/dataset_sizes[phase]\n            print('phase: {} loss: {:.4f} acc: {:.4f}'\\\n                  .format(phase,epoch_loss,epoch_acc))\n            if phase=='valid' and epoch_acc>best_acc:\n                best_acc=epoch_acc\n                best_model_wts=copy.deepcopy(model.state_dict())\n    time_elapsed=time.time()-start\n    print('training time: {:.0f}m {:.0f}s'\\\n          .format(time_elapsed\/\/60,time_elapsed%60))\n    print('best valid acc: {:4f}'.format(best_acc))\n    model.load_state_dict(best_model_wts)\n    return model","846575a7":"num_classes=10; learning_rate=.0001\ndataset_sizes={'train':44000,'valid':6000}\nmodel_ft=models.resnet18(pretrained=True)\nnum_ftrs=model_ft.fc.in_features\nmodel_ft.fc=tnn.Linear(num_ftrs,num_classes)\nmodel_ft=model_ft.to(dev)\ncriterion=tnn.CrossEntropyLoss()\noptimizer_ft=torch.optim.Adam(model_ft.parameters(),\n                              lr=learning_rate)\nexp_lr_scheduler=torch.optim.lr_scheduler\\\n.StepLR(optimizer_ft,step_size=5,gamma=.5)","17b92978":"model_ft=train_model(model_ft,dataloaders,criterion,\n                     optimizer_ft,exp_lr_scheduler,\n                     num_epochs=25)","d0f25f4d":"dhtml('Model Evaluation')","a4ad9fab":"with torch.no_grad():\n    for i,(images,labels) in enumerate(dataloaders['test']):\n        show_image(utils.make_grid(images[:5]))\n        print('\\ntrue labels: ',\n              ''.join('%9s'%classes[labels[j]] \n                       for j in range(5)))\n        images=images.to(dev)\n        labels=labels.to(dev)\n        outputs=model_ft(images)\n        _,preds=torch.max(outputs,1)\n        print('\\npredictions: ',\n             ''.join('%9s'%classes[preds[j]]\n                      for j in range(5)))\n        if i==3: break","f3c59ba0":"dhtml('Model Training')","f621f3c0":"num_classes=33; learning_rate=.0007\ndataset_sizes={'train':x_train.shape[0],\n               'valid':x_valid.shape[0]}\nmodel_ft=models.resnet18(pretrained=True)\nnum_ftrs=model_ft.fc.in_features\nmodel_ft.fc=tnn.Linear(num_ftrs,num_classes)\nmodel_ft=model_ft.to(dev)\ncriterion=tnn.CrossEntropyLoss()\noptimizer_ft=torch.optim.Adam(model_ft.parameters(),\n                              lr=learning_rate)\nexp_lr_scheduler=torch.optim.lr_scheduler\\\n.StepLR(optimizer_ft,step_size=5,gamma=.5)","dd39bde6":"model_ft=train_model(model_ft,dataloaders2,criterion,\n                     optimizer_ft,exp_lr_scheduler,\n                     num_epochs=25)","54bfb666":"dhtml('Model Evaluation')","4129e0e2":"letters=u'\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f'\nwith torch.no_grad():\n    for i,(images,labels) in enumerate(dataloaders2['test']):\n        fig=pl.figure(figsize=(10,4))\n        for k in range(5):\n            ax=fig.add_subplot(1,5,k+1,\\\n            xticks=[],yticks=[],title=labels[k].item())\n            ax.imshow((images[k])\\\n                      .reshape(img_size,img_size,3))\n        pl.show()\n        print('\\ntrue labels: ',\n             ''.join('%9s'%letters[labels[j]]\n                      for j in range(5)))\n        images=images.to(dev)\n        labels=labels.to(dev).long()\n        outputs=model_ft(images)\n        _,preds=torch.max(outputs,1)\n        print('\\npredictions: ',\n             ''.join('%9s'%letters[preds[j]]\n                      for j in range(5)))\n        if i==2: break","0e5ad32f":"[Google Colaboratory Variant](https:\/\/colab.research.google.com\/drive\/1sDO3S-oPGgdgxwzkBFFousJa6dYexd7z?)"}}