{"cell_type":{"c042e9d0":"code","e5e94b15":"code","715816b6":"code","5ac90cff":"code","1391025f":"code","ac1f4e49":"code","bbf470b4":"code","c15ede30":"code","76ff14a5":"code","136d76d7":"code","fa3f8ba6":"markdown"},"source":{"c042e9d0":"from numpy import hstack\nfrom numpy import zeros\nfrom numpy import ones\nfrom numpy.random import rand\nfrom numpy.random import randn\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom matplotlib import pyplot","e5e94b15":"def define_discriminator(n_inputs=2):\n\tmodel = Sequential()\n\tmodel.add(Dense(25, activation='relu', kernel_initializer='he_uniform', input_dim=n_inputs))\n\tmodel.add(Dense(1, activation='sigmoid'))\n\t# compile model\n\tmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\n\treturn model","715816b6":"def define_generator(latent_dim, n_outputs=2):\n\tmodel = Sequential()\n\tmodel.add(Dense(15, activation='relu', kernel_initializer='he_uniform', input_dim=latent_dim))\n\tmodel.add(Dense(n_outputs, activation='linear'))\n\treturn model","5ac90cff":"def define_gan(generator, discriminator):\n\t# make weights in the discriminator not trainable\n\tdiscriminator.trainable = False\n\t# connect them\n\tmodel = Sequential()\n\t# add generator\n\tmodel.add(generator)\n\t# add the discriminator\n\tmodel.add(discriminator)\n\t# compile model\n\tmodel.compile(loss='binary_crossentropy', optimizer='adam')\n\treturn model","1391025f":"def generate_real_samples(n):\n\t# generate inputs in [-0.5, 0.5]\n\tX1 = rand(n) - 0.5\n\t# generate outputs X^2\n\tX2 = X1 * X1\n\t# stack arrays\n\tX1 = X1.reshape(n, 1)\n\tX2 = X2.reshape(n, 1)\n\tX = hstack((X1, X2))\n\t# generate class labels\n\ty = ones((n, 1))\n\treturn X, y","ac1f4e49":"def generate_latent_points(latent_dim, n):\n\t# generate points in the latent space\n\tx_input = randn(latent_dim * n)\n\t# reshape into a batch of inputs for the network\n\tx_input = x_input.reshape(n, latent_dim)\n\treturn x_input","bbf470b4":"def generate_fake_samples(generator, latent_dim, n):\n\t# generate points in latent space\n\tx_input = generate_latent_points(latent_dim, n)\n\t# predict outputs\n\tX = generator.predict(x_input)\n\t# create class labels\n\ty = zeros((n, 1))\n\treturn X, y","c15ede30":"def summarize_performance(epoch, generator, discriminator, latent_dim, n=100):\n\t# prepare real samples\n\tx_real, y_real = generate_real_samples(n)\n\t# evaluate discriminator on real examples\n\t_, acc_real = discriminator.evaluate(x_real, y_real, verbose=0)\n\t# prepare fake examples\n\tx_fake, y_fake = generate_fake_samples(generator, latent_dim, n)\n\t# evaluate discriminator on fake examples\n\t_, acc_fake = discriminator.evaluate(x_fake, y_fake, verbose=0)\n\t# summarize discriminator performance\n\tprint(epoch, acc_real, acc_fake)\n\t# scatter plot real and fake data points\n\tpyplot.scatter(x_real[:, 0], x_real[:, 1], color='red')\n\tpyplot.scatter(x_fake[:, 0], x_fake[:, 1], color='blue')\n\tpyplot.show()","76ff14a5":"def train(g_model, d_model, gan_model, latent_dim, n_epochs=10000, n_batch=128, n_eval=2000):\n\t# determine half the size of one batch, for updating the discriminator\n\thalf_batch = int(n_batch \/ 2)\n\t# manually enumerate epochs\n\tfor i in range(n_epochs):\n\t\t# prepare real samples\n\t\tx_real, y_real = generate_real_samples(half_batch)\n\t\t# prepare fake examples\n\t\tx_fake, y_fake = generate_fake_samples(g_model, latent_dim, half_batch)\n\t\t# update discriminator\n\t\td_model.train_on_batch(x_real, y_real)\n\t\td_model.train_on_batch(x_fake, y_fake)\n\t\t# prepare points in latent space as input for the generator\n\t\tx_gan = generate_latent_points(latent_dim, n_batch)\n\t\t# create inverted labels for the fake samples\n\t\ty_gan = ones((n_batch, 1))\n\t\t# update the generator via the discriminator's error\n\t\tgan_model.train_on_batch(x_gan, y_gan)\n\t\t# evaluate the model every n_eval epochs\n\t\tif (i+1) % n_eval == 0:\n\t\t\tsummarize_performance(i, g_model, d_model, latent_dim)","136d76d7":"# size of the latent space\nlatent_dim = 5\n# create the discriminator\ndiscriminator = define_discriminator()\n# create the generator\ngenerator = define_generator(latent_dim)\n# create the gan\ngan_model = define_gan(generator, discriminator)\n# train model\ntrain(generator, discriminator, gan_model, latent_dim)","fa3f8ba6":"# Generative Adversial Network"}}