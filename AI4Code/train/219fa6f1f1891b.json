{"cell_type":{"a263b3c0":"code","0b624c6a":"code","dc19f034":"code","3a1580da":"code","25ac903b":"code","59dfe69d":"code","76353443":"code","33535441":"code","30e25d76":"code","a05dc772":"code","77a21ab2":"markdown","f3476d08":"markdown","cd077d83":"markdown","3b57d09e":"markdown","a1bc136e":"markdown","4031a6ce":"markdown","67980164":"markdown"},"source":{"a263b3c0":"# Basic import statements\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom collections import Counter\n\n%matplotlib inline\nimport matplotlib.pyplot as plt","0b624c6a":"# load text and ciphertexts in pandas dataframe\ntrain = pd.read_csv('..\/input\/training.csv', index_col='index')\ntrain['length'] = train['text'].apply(lambda x: len(x))\n# ceil the length of the plain texts and save locally (for matching plain and cipher texts)\ntrain['length_100'] = (np.ceil(train['length'] \/ 100) * 100).astype(int)\ntest = pd.read_csv('..\/input\/test.csv')\ntest['length'] = test['ciphertext'].apply(lambda x: len(x))","dc19f034":"# select difficulty 1 ciphertexts\ndiff1 = test[test['difficulty'] == 1]\n# group the ciphertexts by length & sort the values \nlengths = diff1.groupby('length')['ciphertext'].count().sort_values()\n# search for those cipher lengths which only once in our ciphertexts set\nrare_lengths =  lengths[lengths == 1].index\n# match them with the train (plaintext) set and count how many times we found a plaintext matching the length of the ciphertexts\ntrain[train['length_100'].isin(rare_lengths)].groupby('length_100')['text'].count()","3a1580da":"matches = [7300, 7700, 8500, 14200]\ntrain[train['length_100'].isin(matches)].sort_values('length_100')","25ac903b":"diff1[diff1['length'].isin(matches)].sort_values('length')","59dfe69d":"# Count occurences of charcters in the train plaintext (we used the ID_4929f84c6 plain text from the previous analysis)\nplain_char_cntr = Counter(''.join(train[train.plaintext_id=='ID_4929f84c6']['text'].values))\n# new dataframe with frequency and letter\nplain_stats = pd.DataFrame([[x[0], x[1]] for x in plain_char_cntr.items()], columns=['Letter', 'Frequency'])\n# sort dataframe on occurence of frequency\nplain_stats = plain_stats.sort_values(by='Frequency', ascending=True)\n\n# plot\nf, ax = plt.subplots(figsize=(5, 15))\nplt.barh(np.array(range(len(plain_stats))) + 0.5, plain_stats['Frequency'].values)\nplt.yticks(np.array(range(len(plain_stats))) + 0.5, plain_stats['Letter'].values)\nplt.show()\n\n# Space is the most occurring character, folowed by e, t, a, ...","76353443":"# same approach for ciphertext with id 'ID_a6ecf7480'\ncipher_char_cntr = Counter(''.join(test[test['ciphertext_id'] == 'ID_a6ecf7480']['ciphertext'].values))\ncipher_stats = pd.DataFrame([[x[0], x[1]] for x in cipher_char_cntr.items()], columns=['Letter', 'Frequency'])\ncipher_stats = cipher_stats.sort_values(by='Frequency', ascending=True)\n\nf, ax = plt.subplots(figsize=(5, 15))\nplt.barh(np.array(range(len(cipher_stats))) + 0.5, cipher_stats['Frequency'].values)\nplt.yticks(np.array(range(len(cipher_stats))) + 0.5, cipher_stats['Letter'].values)\nplt.show()\n\n# The bars match the training distribution very well! Most occurring character here is 7, followed by l, x, 4, ...","33535441":"# merge plaintext frequency stats together with the cipher text stats based on the Frequency scores\nfreq_alphabet = pd.merge(plain_stats, cipher_stats, on=['Frequency'])\n# sort dataframe on frequency score\nfreq_alphabet = freq_alphabet.sort_values(by='Frequency', ascending=False)\n# print first 20 rows of this dataframe\nfreq_alphabet.head(20)","30e25d76":"# Manually fix the mapping for the remainining characters\nalphabet = \"\"\"7lx4v!2oQ[O=,yCzV:}dFX#(Wak\/bqne*JApK{cmf6 GZDj9gT\\'\"YSHiE]5)81hMNwI@P?Us%;30uBrLR-.$t\"\"\"\nkey =      \"\"\" etaoinsrhldcumfygwpb.v,kI\\'T\"A-SBMxDHj)CW(ELORN!FGPJz0qK?1VY:U92\/3*5;478QZ6X%$}#@={[]\"\"\"\n\ndecrypt_mapping = {}\nencrypt_mapping = {}\nfor i, j in zip(alphabet, key):\n    decrypt_mapping[ord(i)] = ord(j)\n    encrypt_mapping[ord(j)] = ord(i)\n\ndef encrypt_step1(x):\n    return x.translate(encrypt_mapping)\n\ndef decrypt_step1(x):\n    return x.translate(decrypt_mapping)","a05dc772":"cipher = test[(test['difficulty'] == 1)].sample(1).iloc[0, :]['ciphertext']\nprint(decrypt_step1(cipher))","77a21ab2":"We see the occurence of characters are identical, which gives us an indication a substitution cipher was used between the plaintext and ciphertext of difficulty one. Creating a both alphabets is rather easy by matching them both based on the frequency.","f3476d08":"# 1. Length analysis plain vs difficulty 1\nBy exploiting the padding properties (each plaintext is padded with a certain number of characters), we can try to match different plain- to ciphertexts with rare lengths to construct so-called known attacks.\n\nTo show the advantage of length analysis, we will try to search for one difficulty 1 ciphertext and its corresponding plain text.\nThis (plain, ciphertext) pair can further be used to map character or perform further crypto-analyses.","cd077d83":"**These 4 texts can be used to investigate the underlying cipher algorithm  further**","3b57d09e":"**Seems like we found 4 (padded) lengths that only have 1 plain- and ciphertext of difficulty 1: 7300, 7700, 8500, 14200** \n\nWe can now print these out. Take into account that padding has been added to all these texts.","a1bc136e":"# 2. Frequency analysis plain vs difficulty 1\nOften, by inspecting the frequency of each symbol in the cipher's alphabet, the type of cipher which was applied can be easily determined.\n\nIn frequency analysis, the occurrence of each character in both the plain text and ciphertext is analysed. When for instance in the plaintext the space character occurs most of the time, and in the ciphertext, the '7' occurs very often,  there is a high probability that the space in the plaintext is mapped on the 7 in the ciphertext.\n\nBy repeating this procedure for all character occurrences, a mapping can be made.","4031a6ce":"We see these Letter_x (plaintext) characters are mapped exactly on Letter_y (ciphertext) characters.\n\n**Of course, one pair of (plaintext, ciphertext) will not be sufficient to get the full substitution alphabet (the same frequencies occur for less occurring characters). But using this technique, we can find more and more pairs of (ciphertext, plaintexts), providing us with more information about the used substitutions. **\n\nWe manually corrected the small number of mistakes in our mapping, since it is important to have this mapping as correct as possible, since it will help further analysis of more difficult ciphertexts. **The manual correction step is rather tedious. If you have any neat tools or other heuristics for that, please comment!**","67980164":"# Cracking the code for difficulty 1\n\n## Crypto-analysis: length & frequency analysis\n\nIn this notebook, we discuss two types of crypto-analysis, which could help in cracking multiple cipher algorithms.\nThe first approach tries to find a matching cipher and plain text, to perform a so-called known-plain-text attack.\nThe second approach analysis the occurrence of the most common characters in both the cipher and plaintext documents.\nBoth techniques are visualised on the difficulty 1 ciphertexts, but can be used for other challenges as well (gathering more insights)"}}