{"cell_type":{"5d1964ff":"code","bfbe0005":"code","dc026011":"code","b876f9fb":"code","4dbb8a50":"code","a3177ad4":"code","830a5c67":"code","c1aaf5ec":"code","d3d8e066":"code","58c4e6be":"code","082fe2a0":"code","bfc23b7f":"code","f097a74a":"code","c40ca2cc":"code","2e4cf548":"code","a973b84e":"code","393178bc":"code","438a908a":"code","01eb8a69":"code","965235f4":"code","5fc44ca2":"code","e44b4332":"code","7ec2e876":"code","f966d66c":"code","faacfdf5":"code","c3a66470":"code","27b9e94e":"code","58965665":"code","5eef87cb":"code","d24b57b9":"code","31f3a42c":"code","34212b3f":"code","fb03bb2f":"code","a059d882":"code","4b68be23":"code","22bc3a1c":"code","3b9110f1":"code","05a4a2c0":"code","57d25d2a":"code","36d83d95":"code","3d25838a":"code","cb5794ea":"code","fa614717":"code","c480bd1a":"code","7bed25d5":"code","1365738c":"code","726bf931":"code","461e9e35":"code","6ad15c9c":"code","eb950d0f":"code","92b818ac":"code","5777ad12":"code","48e8a001":"code","d13173cf":"code","68e6f1c1":"code","10e15bd9":"code","13aada7b":"code","8dbaf962":"markdown"},"source":{"5d1964ff":"import Bio\nprint (Bio.__version__)","bfbe0005":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","dc026011":"# How to load data files in kaggle while working with BioPython\n# This is how it's done\n# _________________________________________________________________________\n# Loading Complementary DNA Sequence into an alignable file\n#\nfrom Bio import SeqIO\nfor seq_record in SeqIO.parse('\/kaggle\/input\/nc-005816gb\/NC_005816.gb', \"genbank\"):\n    print(seq_record.id)\n    print(repr(seq_record.seq))\n    print(len(seq_record))","b876f9fb":"from Bio.Seq import Seq\nmy_seq = Seq(\"AGTACACTGGT\")\nprint (my_seq)\nmy_seq.alphabet","4dbb8a50":"print (\"My original sequence \" + my_seq)\nprint (\"It's reverse complement is \" + my_seq.complement())","a3177ad4":"from Bio.Seq import Seq\nfrom Bio.Alphabet import IUPAC\nmy_seq = Seq(\"TATAAGGCGAT\", IUPAC.unambiguous_dna)\nprint (my_seq[2:5]) # This actually splices the sequence from 3rd base to 5th base\nlen(my_seq)\nmy_seq.count(\"G\")","830a5c67":"from Bio.Seq import Seq\nfrom Bio.Alphabet import IUPAC\nfrom Bio.SeqUtils import GC\nmy_seq = Seq(\"TATAAGGCGAT\", IUPAC.unambiguous_dna)\nGC(my_seq)","c1aaf5ec":"from Bio.Seq import Seq\nfrom Bio.Alphabet import IUPAC\nmy_seq = Seq(\"GATCGATGGGCCTATATAGGATCGAAAATCGC\", IUPAC.unambiguous_dna)\nmy_seq[::-1]","d3d8e066":"print(my_seq)","58c4e6be":"from Bio.Seq import Seq\nfrom Bio.Alphabet import generic_alphabet\nfrom Bio.Alphabet import generic_nucleotide\nfrom Bio.Alphabet import IUPAC\nprotein_seq = Seq(\"EVERNK\", IUPAC.protein)\ndna_seq = Seq(\"ACGT\", IUPAC.unambiguous_dna)\nprotein_seq.alphabet = generic_alphabet\ndna_seq.alphabet = generic_alphabet\nprotein_seq + dna_seq","082fe2a0":"from Bio.Seq import Seq\nfrom Bio.Alphabet import generic_alphabet\nfrom Bio.Alphabet import generic_nucleotide\nfrom Bio.Alphabet import IUPAC\ndna_seq = Seq(\"ACGT\", IUPAC.unambiguous_dna)\nnuc_seq = Seq(\"GATCGATGC\", generic_nucleotide)\ndna_seq + nuc_seq","bfc23b7f":"from Bio.Seq import Seq\nfrom Bio.Alphabet import IUPAC\nmy_seq = Seq(\"GATCGATGGGCCTATATAGGATCGAAAATCGC\", IUPAC.unambiguous_dna)\nprint (\"Reverse complement \" + my_seq.reverse_complement() + \"\\nComplement \" + my_seq.complement())","f097a74a":"from Bio.Seq import Seq\nfrom Bio.Alphabet import IUPAC\ncoding_dna = Seq(\"ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG\", IUPAC.unambiguous_dna)\ntemplate_dna = coding_dna.reverse_complement()\nmessenger_rna = coding_dna.transcribe()\nback_messenger = messenger_rna.back_transcribe()\ntranslate = coding_dna.translate()","c40ca2cc":"print (\"coding dna \" + coding_dna)\nprint (\"\\nReverse complement of the coding dna \" + template_dna)\nprint (\"\\ntranscribed form of the coding dna \" + messenger_rna)\nprint (\"\\nBack transcription of messenger RNA \" + back_messenger)\nprint (\"\\nTranslated form of the given dna sequence \" + translate)","2e4cf548":"coding_dna.translate(table=2)","a973b84e":"#from Bio.Seq import Seq\n#from Bio.Alphabet import generic_dna, generic_rna, generic_protein\n#print(\"%0.2f\" % molecular_weight(Seq(\"AGC\", generic_dna)))\n#Apparently this doesnt seem to be working whatsoever\n","393178bc":"# Now, suppose you have a complete coding sequence CDS, which is to say a nucleotide sequence (e.g.\n# mRNA \u2013 after any splicing) which is a whole number of codons (i.e. the length is a multiple of three),\n# commences with a start codon, ends with a stop codon, and has no internal in-frame stop codons. In\n# general, given a complete CDS, the default translate method will do what you want (perhaps with the\n# to_stop option). However, what if your sequence uses a non-standard start codon? This happens a lot in\n# bacteria \u2013 for example the gene yaaX in E. coli K12:\nfrom Bio.Seq import Seq\nfrom Bio.Alphabet import generic_dna\ngene = Seq(\"GTGAAAAAGATGCAATCTATCGTACTCGCACTTTCCCTGGTTCTGGTCGCTCCCATGGCAGCACAGGCTGCGGAAATTACGTTAGTCCCGTCAGTAAAATTACAGATAGGCGATCGTGATAATCGTGGCTATTACTGGGATGGAGGTCACTGGCGCGACCACGGCTGGTGGAAACAACATTATGAATGGCGAGGCAATCGCTGGCACCTACACGGACCGCCGCCACCGCCGCGCCACCATAAGAAAGCTCCTCATGATCATCACGGCGGTCATGGTCCAGGCAAACATCACCGCTAA\", generic_dna)\ngene.translate(table=\"Bacterial\")","438a908a":"# In the bacterial genetic code GTG is a valid start codon, and while it does normally encode Valine, if used as\n# a start codon it should be translated as methionine. This happens if you tell Biopython your sequence is a\n# complete CDS:\n gene.translate(table=\"Bacterial\", cds=True)","01eb8a69":"from Bio.Data import CodonTable\nstandard_table = CodonTable.unambiguous_dna_by_name[\"Standard\"]\nmito_table = CodonTable.unambiguous_dna_by_name[\"Vertebrate Mitochondrial\"]\nprint(standard_table)\nprint (mito_table)","965235f4":"mito_table.stop_codons","5fc44ca2":"mito_table.start_codons","e44b4332":"# Comparing sequence object\nfrom Bio.Seq import Seq\nfrom Bio.Alphabet import IUPAC\nseq1 = Seq(\"ACGT\", IUPAC.unambiguous_dna)\nseq2 = Seq(\"ACGT\", IUPAC.ambiguous_dna)\nstr(seq1) == str(seq2)","7ec2e876":"str(seq1) == str(seq1)","f966d66c":"# MutableSeq object\nfrom Bio.Seq import MutableSeq\nfrom Bio.Alphabet import IUPAC\nmutable_seq = MutableSeq(\"GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA\", IUPAC.unambiguous_dna)\nmutable_seq","faacfdf5":"# Sequence manipulation at position 6\nmutable_seq[5]=\"C\"\nmutable_seq","c3a66470":"mutable_seq.reverse()\nmutable_seq","27b9e94e":"# UnknownSequence Object\nfrom Bio.Seq import UnknownSeq\nunk = UnknownSeq(20)\nunk","58965665":"print(unk)","5eef87cb":"from Bio.Seq import UnknownSeq\nfrom Bio.Alphabet import IUPAC\nunk_dna = UnknownSeq(20, alphabet=IUPAC.ambiguous_dna)\nunk_dna","d24b57b9":"print(unk_dna)","31f3a42c":"unk_protein = unk_dna.translate()\nunk_protein","34212b3f":"print(unk_protein)\nlen(unk_protein)","fb03bb2f":"# Performing a reverse complement, transcription, back transcription and translation of a given gene sequence\nfrom Bio.Seq import reverse_complement, transcribe, back_transcribe, translate\nmy_string = \"GCTGTTATGGGTCGTTGGAAGGGTGGTCGTGCTGCTGGTTAG\"\nprint (\"The original string \" + my_string)\nprint (\"Reverse complement >> \" + reverse_complement(my_string))\nprint (\"Transcription >> \" + transcribe(my_string))\nprint (\"Back transcription >> \" + back_transcribe(my_string))\nprint (\"Translation >> \" + translate(my_string))","a059d882":"# Sequence Annotation Object\nfrom Bio.Seq import Seq\nsimple_seq = Seq(\"GATC\")\nfrom Bio.SeqRecord import SeqRecord\nsimple_seq_rec = SeqRecord(simple_seq)\nsimple_seq_rec.id = \"AC12345\"\nsimple_seq_rec.description = \"This is a record sequence\"\nprint (simple_seq_rec.description)","4b68be23":"print (simple_seq_rec.seq)","22bc3a1c":"# Sequence described by a feature or location\nfrom Bio.Seq import Seq\nfrom Bio.SeqFeature import SeqFeature, FeatureLocation\nexample_parent = Seq(\"ACCGAGACGGCAAAGGCTAGCATAGGTATGAGACTTCCTTCCTGCCAGTGCTGAGGAACTGGGAGCCTAC\")\nexample_feature = SeqFeature(FeatureLocation(5, 18), type=\"gene\", strand=-1)\nprint (example_feature)","3b9110f1":"# splicing region of example_parent sequence from 6th base to 18th base and performing a reverse complement of the sequence\nfeature_seq = example_parent[example_feature.location.start:example_feature.location.end].reverse_complement\nprint(feature_seq)","05a4a2c0":"# notice that the printed sequence is a complete reverse seq from the above reverse-complemented sequence\nprint(example_feature.extract(example_parent))","57d25d2a":"print(len(example_feature.extract(example_parent)))","36d83d95":"# The format method\nfrom Bio.Seq import Seq\nfrom Bio.SeqRecord import SeqRecord\nfrom Bio.Alphabet import generic_protein\nrecord = SeqRecord(Seq(\"MMYQQGCFAGGTVLRLAKDLAENNRGARVLVVCSEITAVTFRGPSETHLDSMVGQALFGDGAGAVIVGSDPDLSVERPLYELVWTGATLLPDSEGAIDGHLREVGLTFHLLKDVPGLISKNIEKSLKEAFTPLGISDWNSTFWIAHPGGPAILDQVEAKLGLKEEKMRATREVLSEYGNMSSAC\", generic_protein), id=\"gi|14150838|gb|AAK54648.1|AF376133_1\", description=\"chalcone synthase [Cucumis sativus]\",)\nprint(record.format(\"fasta\")) # Prints the seq in a fasta format","3d25838a":"# Slicing a sequence record\nfrom Bio import SeqIO\nrecord = SeqIO.read(\"\/kaggle\/input\/nc-005816gb\/NC_005816.gb\", \"genbank\")\nrecord","cb5794ea":"len(record)","fa614717":"len(record.features)","c480bd1a":"print(record.features[20])","7bed25d5":"print(record.features[21])","1365738c":"sub_record = record[4300:4800]\nsub_record","726bf931":"sr_length = len(sub_record)\nsr_features = len(sub_record.features)\nprint(\"Length of the sub_record \", sr_length)\nprint(\"Length of sub_record features \", sr_features)","461e9e35":"# As our sub_record has 2 features, we're going to run 0 for feature 1 and 1 for the second feature\nprint(sub_record.features[0])","6ad15c9c":"print(sub_record.features[1])","eb950d0f":"print(\"ID of sub_record:\\n\", sub_record.id, \"\\nName of sub_record:\\n\", sub_record.name, \"\\nSub_record description:\\n\", sub_record.description)","92b818ac":"# Page 47\n","5777ad12":"# All the reading files seem to be causing problems whatsoever, thus I'm commenting them out\n# Reading sequence file\n#from Bio import SeqIO\n#for seq_record in SeqIO.parse(\"..input\/orchidfasta\/orchid.fasta\", \"fasta\"):\n #   print(seq_record.id)\n  #  print(repr(seq_record.seq))\n   # print(len(seq_record))\n# page 51 from the biopython book pdf","48e8a001":"# Parsing gene bank sequence from the net\nfrom Bio import Entrez\nfrom Bio import SeqIO\nEntrez.email = \"A.N.Other@example.com\"\nwith Entrez.efetch(\n    db=\"nucleotide\", rettype=\"fasta\", retmode=\"text\", id=\"6273291\"\n) as handle:\n    seq_record = SeqIO.read(handle, \"fasta\")\nprint(\"%s with %i features\" % (seq_record.id, len(seq_record.features)))","d13173cf":"#The NCBI will also let you ask for the file in other formats, in particular as a GenBank file. Until Easter\n#2009, the Entrez EFetch API let you use \u201cgenbank\u201d as the return type, however the NCBI now insist on\n#using the official return types of \u201cgb\u201d (or \u201cgp\u201d for proteins) as described on EFetch for Sequence and other\n#Molecular Biology Databases. As a result, in Biopython 1.50 onwards, we support \u201cgb\u201d as an alias for\n#\u201cgenbank\u201d in Bio.SeqIO.\nfrom Bio import Entrez\nfrom Bio import SeqIO\nEntrez.email = \"A.N.Other@example.com\"\nwith Entrez.efetch(\n    db=\"nucleotide\", rettype=\"gb\", retmode=\"text\", id=\"6273291\"\n) as handle:\n    seq_record = SeqIO.read(handle, \"gb\") # using \"gb\" as an alias for \"genbank\"\nprint(\"%s with %i features\" % (seq_record.id, len(seq_record.features)))","68e6f1c1":"# Fetching several records\nfrom Bio import Entrez\nfrom Bio import SeqIO\nEntrez.email = \"A.N.Other@example.com\"\nwith Entrez.efetch(\n    db=\"nucleotide\", rettype=\"gb\", retmode=\"text\", id=\"6273291,6273290,6273289\"\n) as handle:\n    for seq_record in SeqIO.parse(handle, \"gb\"):\n        print(\"%s %s...\" % (seq_record.id, seq_record.description[:50]))\n        print(\n            \"Sequence length %i, %i features, from: %s\"\n            % (\n                len(seq_record),\n                len(seq_record.features),\n                seq_record.annotations[\"source\"],\n            )\n        )","10e15bd9":"# Parsing SwissProt sequences from the net\nfrom Bio import ExPASy\nfrom Bio import SeqIO\nwith ExPASy.get_sprot_raw(\"O23729\") as handle:\n    seq_record = SeqIO.read(handle, \"swiss\")\nprint(seq_record.id)\nprint(seq_record.name)\nprint(seq_record.description)\nprint(repr(seq_record.seq))\nprint(\"Length %i\" % len(seq_record))\nprint(seq_record.annotations[\"keywords\"])","13aada7b":"from Bio import ExPASy\nfrom Bio import SeqIO\nwith ExPASy.get_sprot_raw(\"O23730\") as handle:\n    seq_record = SeqIO.read(handle, \"swiss\")\nprint(seq_record.id)\nprint(seq_record.name)\nprint(seq_record.description)\nprint(repr(seq_record.seq))\nprint(\"Length %i\" % len(seq_record))\nprint(seq_record.annotations[\"keywords\"])","8dbaf962":"# **Welcome**<br>\n## **This here are some codes taken from the BioPython tutorial book**<br>\n## **BioPython is as fascinating as it sounds. It is specially codded for those working in fields like Genetic Engineering, and fields related to life science and such. Hope this notebook helps you in any way**\n"}}