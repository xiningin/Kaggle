{"cell_type":{"97696e10":"code","384bc006":"code","7d219f68":"code","02e13b88":"code","eacd9ab5":"code","8ede3f8e":"code","a0798a0a":"code","6546ac00":"code","17a41fdf":"code","47017637":"code","67148b2f":"code","4400499b":"code","29dffed6":"code","30fec990":"markdown","8e007814":"markdown","fa246868":"markdown"},"source":{"97696e10":"import numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error, explained_variance_score, r2_score, max_error,median_absolute_error, mean_squared_log_error","384bc006":"df_power = pd.read_csv('..\/input\/residential-power-usage-3years-data-timeseries\/power_usage_2016_to_2020.csv')\ndf_weather = pd.read_csv('..\/input\/residential-power-usage-3years-data-timeseries\/weather_2016_2020_daily.csv')\n\n# Sum hourly power in each day\np1 = pd.Series(range(df_power.shape[0]), pd.period_range('2016-06-01 00:00:00', freq = '1H', periods = df_power.shape[0]))\ndf_power['StartDate'] = p1.to_frame().index.to_timestamp()\ndf_power['StartDate'] = pd.DatetimeIndex(df_power['StartDate']).date\ndf_power = df_power.groupby(['StartDate']).sum().reset_index().drop([\"StartDate\", \"day_of_week\"], axis=1)","7d219f68":"df_weather.head()","02e13b88":"df_power.head()","eacd9ab5":"# Feature Selection (use temperature average and wind speed average)\ndf_weather_filtered = df_weather.filter([\"Temp_avg\", \"Wind_avg\"])\ndf_weather_filtered","8ede3f8e":"# Train-Test Split\ntrain_ratio = 0.75;\nsplitIdx = int(len(df_power)*train_ratio)\n\ntrain_feature = df_weather_filtered.iloc[0:splitIdx+1,:];\ntrain_label = df_power.iloc[0:splitIdx+1,:];\ntest_feature = df_weather_filtered.iloc[splitIdx+1:len(df_power),:];\ntest_label = df_power.iloc[splitIdx+1:len(df_power),:];","a0798a0a":"train_feature","6546ac00":"# Least Square fitting on NARX model (Polynomial degree 2 on input only, i.e. y(t) = a1y(t-1) + a2y(t-2) + ... + b0u^2(t) + b1u^2(t-1) + ... + c0u(t) + c1u(t-1) + ... + bias)\n\n# use current input (has u(t) term if 1, no u(t) term if 0)\ncurInput = 1;\n\n# Memory n timestep for y (label) and u (input)\nNy = 6;\nNu = 3;\n\nytrue_train = train_label.iloc[Ny:len(train_label),:];\nytrue_test = test_label.iloc[Ny:len(test_label),:];\n\n# Matrix Formulation for equation A*theta = ytrue_train, and we solve for theta\nA = train_label.iloc[Ny-1:len(train_label)-1, :];\nB = train_feature.iloc[Ny+curInput-1:len(train_label)+curInput-1, :];\n\nfor i in range(1,Ny):\n    A = pd.concat([A.reset_index(drop=True), train_label.iloc[Ny-i-1:len(train_label)-i-1, :].reset_index(drop=True)], axis=1, ignore_index=True);\n    \nfor i in range(1,Nu+curInput):\n    B = pd.concat([B.reset_index(drop=True), train_feature.iloc[Ny+curInput-i-1:len(train_label)-i+curInput-1, :].reset_index(drop=True)], axis=1, ignore_index=True);\n    \nA = pd.concat([A.reset_index(drop=True), pow(B,2).reset_index(drop=True), B.reset_index(drop=True), pd.DataFrame(np.ones(len(train_label)-Ny)).reset_index(drop=True)], axis=1, ignore_index=True)","17a41fdf":"# Matrix A contains [poly_1(previous output) poly_2(previous_current input) poly_1(previous_current input) bias]\nA","47017637":"# Solve for equation => theta = A\\ytrue_train\ntheta = np.linalg.lstsq(A.values,ytrue_train.values)\n\n# Parameter for NARX polynomial mathematical modelling\ntheta[0]","67148b2f":"def performance_report(ytrue, ypred):\n    print(\"R2 =\", r2_score(ytrue, ypred))\n    print(\"MSE =\", mean_squared_error(ytrue, ypred))\n    print(\"MAE =\", mean_absolute_error(ytrue, ypred))\n    print(\"MSLE =\", mean_squared_log_error(ytrue, ypred))\n    print(\"Exp. Var. =\", explained_variance_score(ytrue, ypred))\n    print(\"Max Error =\", max_error(ytrue, ypred))","4400499b":"# Evaluate Result on Train set\nx_train = A\nypred_train = np.matmul(x_train, theta[0])\n\n# Plot last 100 timesteps\nplt.plot(ypred_train[len(ypred_train)-100:].values)\nplt.plot(ytrue_train[len(ytrue_train)-100:].values)\nperformance_report(ytrue_train, ypred_train)","29dffed6":"# Evaluate Result on Train set\n\n# Matrix Formulation for equation C*theta = ypred_test, and we solve for theta\nC = test_label.iloc[Ny-1:len(test_label)-1, :];\nD = test_feature.iloc[Ny+curInput-1:len(test_label)+curInput-1, :];\n\nfor i in range(1,Ny):\n    C = pd.concat([C.reset_index(drop=True), test_label.iloc[Ny-i-1:len(test_label)-i-1, :].reset_index(drop=True)], axis=1, ignore_index=True);\n    \nfor i in range(1,Nu+curInput):\n    D = pd.concat([D.reset_index(drop=True), test_feature.iloc[Ny+curInput-i-1:len(test_label)-i+curInput-1, :].reset_index(drop=True)], axis=1, ignore_index=True);\n    \nC = pd.concat([C.reset_index(drop=True), pow(D,2).reset_index(drop=True), D.reset_index(drop=True), pd.DataFrame(np.ones(len(test_label)-Ny)).reset_index(drop=True)], axis=1, ignore_index=True)\n\nx_test = C\nypred_test = np.matmul(x_test, theta[0])\n\n# Plot last 100 timesteps\nplt.plot(ypred_test[len(ypred_test)-100:].values)\nplt.plot(ytrue_test[len(ytrue_test)-100:].values)\nperformance_report(ytrue_test, ypred_test)","30fec990":"![image.png](attachment:6818bc07-d83c-4014-b42d-355607e69438.png)","8e007814":"# **This is the code for creating NARX Polynomial model for power consumption prediction**","fa246868":"**Note:** This code is involving with matrix operation"}}