{"cell_type":{"3ada18e9":"code","86f478a8":"code","d0d49eaa":"code","bc39551e":"code","26fcaa68":"code","f93a183e":"code","fd4b0982":"code","2220695b":"code","1067c50b":"code","f409cdec":"code","f03aba09":"code","83744d96":"code","edf4a27e":"code","e97257fb":"code","61daf38a":"code","bba7ce42":"code","52bd6583":"code","c9519b96":"code","4facec29":"code","e364bd82":"code","c0d47fab":"code","b5561056":"code","0c79c095":"code","0be4e53b":"code","c36f1f14":"code","b7db1be4":"code","155cba37":"code","3b50d4e0":"code","91c4f89b":"code","0b20442a":"code","740590d4":"code","f396ab70":"code","b4020521":"code","b816c2d6":"code","15a782b6":"code","75a4574e":"code","7b2dc7f4":"code","71639922":"code","80a59112":"code","2732cb97":"code","d4bcef5e":"code","ff0c70b5":"code","312bfd09":"code","1f7a6510":"code","20b639f5":"markdown","1fc3b407":"markdown","e79c34b0":"markdown","1bf3f5f0":"markdown","414cbfe7":"markdown","44a1875f":"markdown","f4df98b6":"markdown","802cd38a":"markdown","2994b3f7":"markdown","71a23804":"markdown","a94f260e":"markdown","e5cc66ef":"markdown","28481b5a":"markdown","890f186c":"markdown","4cf740aa":"markdown","77619a07":"markdown","ef83968f":"markdown","1f50ab20":"markdown","efde22c0":"markdown","b711f78d":"markdown","18ba4c67":"markdown","429b156d":"markdown","a3c828c4":"markdown","e20173bb":"markdown","0007ee1a":"markdown","beaf730d":"markdown","7ea51336":"markdown"},"source":{"3ada18e9":"import numpy as np\nimport os\nfrom sklearn.metrics import confusion_matrix\nimport seaborn as sn; sn.set(font_scale=1.4)\nfrom sklearn.utils import shuffle           \nimport matplotlib.pyplot as plt             \nimport cv2                                 \nimport tensorflow as tf                \nfrom tqdm import tqdm","86f478a8":"class_names = ['mountain', 'street', 'glacier', 'buildings', 'sea', 'forest']\nclass_names_label = {class_name:i for i, class_name in enumerate(class_names)}\n\nnb_classes = len(class_names)\n\nIMAGE_SIZE = (150, 150)","d0d49eaa":"def load_data():\n    \"\"\"\n        Load the data:\n            - 14,034 images to train the network.\n            - 3,000 images to evaluate how accurately the network learned to classify images.\n    \"\"\"\n    \n    datasets = ['..\/input\/seg_train\/seg_train', '..\/input\/seg_test\/seg_test']\n    output = []\n    \n    # Iterate through training and test sets\n    for dataset in datasets:\n        \n        images = []\n        labels = []\n        \n        print(\"Loading {}\".format(dataset))\n        \n        # Iterate through each folder corresponding to a category\n        for folder in os.listdir(dataset):\n            label = class_names_label[folder]\n            \n            # Iterate through each image in our folder\n            for file in tqdm(os.listdir(os.path.join(dataset, folder))):\n                \n                # Get the path name of the image\n                img_path = os.path.join(os.path.join(dataset, folder), file)\n                \n                # Open and resize the img\n                image = cv2.imread(img_path)\n                image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n                image = cv2.resize(image, IMAGE_SIZE) \n                \n                # Append the image and its corresponding label to the output\n                images.append(image)\n                labels.append(label)\n                \n        images = np.array(images, dtype = 'float32')\n        labels = np.array(labels, dtype = 'int32')   \n        \n        output.append((images, labels))\n\n    return output","bc39551e":"(train_images, train_labels), (test_images, test_labels) = load_data()","26fcaa68":"train_images, train_labels = shuffle(train_images, train_labels, random_state=25)","f93a183e":"n_train = train_labels.shape[0]\nn_test = test_labels.shape[0]\n\nprint (\"Number of training examples: {}\".format(n_train))\nprint (\"Number of testing examples: {}\".format(n_test))\nprint (\"Each image is of size: {}\".format(IMAGE_SIZE))","fd4b0982":"import pandas as pd\n\n_, train_counts = np.unique(train_labels, return_counts=True)\n_, test_counts = np.unique(test_labels, return_counts=True)\npd.DataFrame({'train': train_counts,\n                    'test': test_counts}, \n             index=class_names\n            ).plot.bar()\nplt.show()","2220695b":"plt.pie(train_counts,\n        explode=(0, 0, 0, 0, 0, 0) , \n        labels=class_names,\n        autopct='%1.1f%%')\nplt.axis('equal')\nplt.title('Proportion of each observed category')\nplt.show()","1067c50b":"train_images = train_images \/ 255.0 \ntest_images = test_images \/ 255.0","f409cdec":"def display_random_image(class_names, images, labels):\n    \"\"\"\n        Display a random image from the images array and its correspond label from the labels array.\n    \"\"\"\n    \n    index = np.random.randint(images.shape[0])\n    plt.figure()\n    plt.imshow(images[index])\n    plt.xticks([])\n    plt.yticks([])\n    plt.grid(False)\n    plt.title('Image #{} : '.format(index) + class_names[labels[index]])\n    plt.show()","f03aba09":"display_random_image(class_names, train_images, train_labels)","83744d96":"def display_examples(class_names, images, labels):\n    \"\"\"\n        Display 25 images from the images array with its corresponding labels\n    \"\"\"\n    \n    fig = plt.figure(figsize=(10,10))\n    fig.suptitle(\"Some examples of images of the dataset\", fontsize=16)\n    for i in range(25):\n        plt.subplot(5,5,i+1)\n        plt.xticks([])\n        plt.yticks([])\n        plt.grid(False)\n        plt.imshow(images[i], cmap=plt.cm.binary)\n        plt.xlabel(class_names[labels[i]])\n    plt.show()","edf4a27e":"display_examples(class_names, train_images, train_labels)","e97257fb":"model = tf.keras.Sequential([\n    tf.keras.layers.Conv2D(32, (3, 3), activation = 'relu', input_shape = (150, 150, 3)), \n    tf.keras.layers.MaxPooling2D(2,2),\n    tf.keras.layers.Conv2D(32, (3, 3), activation = 'relu'),\n    tf.keras.layers.MaxPooling2D(2,2),\n    tf.keras.layers.Flatten(),\n    tf.keras.layers.Dense(128, activation=tf.nn.relu),\n    tf.keras.layers.Dense(6, activation=tf.nn.softmax)\n])","61daf38a":"model.compile(optimizer = 'adam', loss = 'sparse_categorical_crossentropy', metrics=['accuracy'])","bba7ce42":"history = model.fit(train_images, train_labels, batch_size=128, epochs=20, validation_split = 0.2)","52bd6583":"def plot_accuracy_loss(history):\n    \"\"\"\n        Plot the accuracy and the loss during the training of the nn.\n    \"\"\"\n    fig = plt.figure(figsize=(10,5))\n\n    # Plot accuracy\n    plt.subplot(221)\n    plt.plot(history.history['acc'],'bo--', label = \"acc\")\n    plt.plot(history.history['val_acc'], 'ro--', label = \"val_acc\")\n    plt.title(\"train_acc vs val_acc\")\n    plt.ylabel(\"accuracy\")\n    plt.xlabel(\"epochs\")\n    plt.legend()\n\n    # Plot loss function\n    plt.subplot(222)\n    plt.plot(history.history['loss'],'bo--', label = \"loss\")\n    plt.plot(history.history['val_loss'], 'ro--', label = \"val_loss\")\n    plt.title(\"train_loss vs val_loss\")\n    plt.ylabel(\"loss\")\n    plt.xlabel(\"epochs\")\n\n    plt.legend()\n    plt.show()","c9519b96":"plot_accuracy_loss(history)","4facec29":"test_loss = model.evaluate(test_images, test_labels)","e364bd82":"predictions = model.predict(test_images)     # Vector of probabilities\npred_labels = np.argmax(predictions, axis = 1) # We take the highest probability\n\ndisplay_random_image(class_names, test_images, pred_labels)","c0d47fab":"def print_mislabeled_images(class_names, test_images, test_labels, pred_labels):\n    \"\"\"\n        Print 25 examples of mislabeled images by the classifier, e.g when test_labels != pred_labels\n    \"\"\"\n    BOO = (test_labels == pred_labels)\n    mislabeled_indices = np.where(BOO == 0)\n    mislabeled_images = test_images[mislabeled_indices]\n    mislabeled_labels = pred_labels[mislabeled_indices]\n\n    title = \"Some examples of mislabeled images by the classifier:\"\n    display_examples(class_names,  mislabeled_images, mislabeled_labels)\n","b5561056":"print_mislabeled_images(class_names, test_images, test_labels, pred_labels)","0c79c095":"CM = confusion_matrix(test_labels, pred_labels)\nax = plt.axes()\nsn.heatmap(CM, annot=True, \n           annot_kws={\"size\": 10}, \n           xticklabels=class_names, \n           yticklabels=class_names, ax = ax)\nax.set_title('Confusion matrix')\nplt.show()","0be4e53b":"from keras.applications.vgg16 import VGG16\nfrom keras.preprocessing import image\nfrom keras.applications.vgg16 import preprocess_input\n\nmodel = VGG16(weights='imagenet', include_top=False)","c36f1f14":"train_features = model.predict(train_images)\ntest_features = model.predict(test_images)","b7db1be4":"n_train, x, y, z = train_features.shape\nn_test, x, y, z = test_features.shape\nnumFeatures = x * y * z","155cba37":"from sklearn import decomposition\n\npca = decomposition.PCA(n_components = 2)\n\nX = train_features.reshape((n_train, x*y*z))\npca.fit(X)\n\nC = pca.transform(X) # Repr\u00e9sentation des individus dans les nouveaux axe\nC1 = C[:,0]\nC2 = C[:,1]","3b50d4e0":"### Figures\n\nplt.subplots(figsize=(10,10))\n\nfor i, class_name in enumerate(class_names):\n    plt.scatter(C1[train_labels == i][:1000], C2[train_labels == i][:1000], label = class_name, alpha=0.4)\nplt.legend()\nplt.title(\"PCA Projection\")\nplt.show()","91c4f89b":"model2 = tf.keras.Sequential([\n    tf.keras.layers.Flatten(input_shape = (x, y, z)),\n    tf.keras.layers.Dense(50, activation=tf.nn.relu),\n    tf.keras.layers.Dense(6, activation=tf.nn.softmax)\n])\n\nmodel2.compile(optimizer = 'adam', loss = 'sparse_categorical_crossentropy', metrics=['accuracy'])\n\nhistory2 = model2.fit(train_features, train_labels, batch_size=128, epochs=15, validation_split = 0.2)","0b20442a":"plot_accuracy_loss(history)","740590d4":"test_loss = model2.evaluate(test_features, test_labels)","f396ab70":"np.random.seed(seed=1997)\n# Number of estimators\nn_estimators = 10\n# Proporition of samples to use to train each training\nmax_samples = 0.8\n\nmax_samples *= n_train\nmax_samples = int(max_samples)","b4020521":"models = list()\nrandom = np.random.randint(50, 100, size = n_estimators)\n\nfor i in range(n_estimators):\n    \n    # Model\n    model = tf.keras.Sequential([ tf.keras.layers.Flatten(input_shape = (x, y, z)),\n                                # One layer with random size\n                                    tf.keras.layers.Dense(random[i], activation=tf.nn.relu),\n                                    tf.keras.layers.Dense(6, activation=tf.nn.softmax)\n                                ])\n    \n    model.compile(optimizer = 'adam', loss = 'sparse_categorical_crossentropy', metrics=['accuracy'])\n    \n    # Store model\n    models.append(model)","b816c2d6":"histories = []\n\nfor i in range(n_estimators):\n    # Train each model on a bag of the training data\n    train_idx = np.random.choice(len(train_features), size = max_samples)\n    histories.append(models[i].fit(train_features[train_idx], train_labels[train_idx], batch_size=128, epochs=10, validation_split = 0.1))","15a782b6":"predictions = []\nfor i in range(n_estimators):\n    predictions.append(models[i].predict(test_features))\n    \npredictions = np.array(predictions)\npredictions = predictions.sum(axis = 0)\npred_labels = predictions.argmax(axis=1)","75a4574e":"from sklearn.metrics import accuracy_score\nprint(\"Accuracy : {}\".format(accuracy_score(test_labels, pred_labels)))","7b2dc7f4":"from keras.models import Model\n\nmodel = VGG16(weights='imagenet', include_top=False)\nmodel = Model(inputs=model.inputs, outputs=model.layers[-5].output)","71639922":"train_features = model.predict(train_images)\ntest_features = model.predict(test_images)","80a59112":"from keras.layers import Input, Dense, Conv2D, Activation , MaxPooling2D, Flatten\n\nmodel2 = VGG16(weights='imagenet', include_top=False)\n\ninput_shape = model2.layers[-4].get_input_shape_at(0) # get the input shape of desired layer\nlayer_input = Input(shape = (9, 9, 512)) # a new input tensor to be able to feed the desired layer\n# https:\/\/stackoverflow.com\/questions\/52800025\/keras-give-input-to-intermediate-layer-and-get-final-output\n\nx = layer_input\nfor layer in model2.layers[-4::1]:\n    x = layer(x)\n    \nx = Conv2D(64, (3, 3), activation='relu')(x)\nx = MaxPooling2D(pool_size=(2, 2))(x)\nx = Flatten()(x)\nx = Dense(100,activation='relu')(x)\nx = Dense(6,activation='softmax')(x)\n\n# create the model\nnew_model = Model(layer_input, x)","2732cb97":"new_model.compile(optimizer = 'adam', loss = 'sparse_categorical_crossentropy', metrics=['accuracy'])","d4bcef5e":"new_model.summary()","ff0c70b5":"history = new_model.fit(train_features, train_labels, batch_size=128, epochs=10, validation_split = 0.2)","312bfd09":"plot_accuracy_loss(history)","1f7a6510":"from sklearn.metrics import accuracy_score\n\npredictions = new_model.predict(test_features)    \npred_labels = np.argmax(predictions, axis = 1)\nprint(\"Accuracy : {}\".format(accuracy_score(test_labels, pred_labels)))","20b639f5":"# Intel Image Classification (CNN - Keras)\n\nHello, I hope you are having a great day.\n\nIn this notebook, I will try the process of implementing CNN with Keras in order to classify images.\n1. Firstly, we'll import usefull packages.\n1. Then, we'll load the data, before visualize and preprocess it.\n1. We'll try a simple CNN model and then we will evaluate its performances.\n1. We will then use pre trained model to address this challenge aswell.","1fc3b407":"Get the features directly from VGG16","e79c34b0":"# Loading the Data\nWe have to write a load_data function that load the images and the labels from the folder.","1bf3f5f0":"## Training on top of VGG\n\nLet's train a simple one-layer Neural Network on the features extracted from VGG.","414cbfe7":"## Error analysis\n\nWe can try to understand on which kind of images the classifier has trouble.","44a1875f":"We see that we achieve 0.76 accuracy on the testing test. We got a slight underfitting :(\n\nLet's see how the classifier is doing on random images.","f4df98b6":"**Intermediate Update January 2020**\n\n* Feature extraction with VGG16 trained on ImageNet\n\n\n* Ensemble models of Neural Networks with the features extracted from VGG\n\nInspired from: https:\/\/machinelearningmastery.com\/model-averaging-ensemble-for-deep-learning-neural-networks\/\n\n* Fine Tuning with VGG16 trained on ImageNet","802cd38a":"## Visualize the features through PCA","2994b3f7":"We should improve our result as we have a lower variance.","71a23804":"# Feature extraction with VGG ImageNet","a94f260e":"# Fine Tuning VGG ImageNet","e5cc66ef":"We fit the model to the data from the training set. The neural network will learn by itself the pattern in order to distinguish each category.","28481b5a":"We should get approximately 0.844 accuracy (+0.1 accuracy) over the simple ConvNet.","890f186c":"We aggregate each model individual predictions to form a final prediction.","4cf740aa":"## Conclusion: The classifier has trouble with 2 kinds of images.\nIt has trouble with street and buildings. Well, it can be understandable as as there are buildings in the street. \nIt has also trouble with sea, glacier and moutain as well. It is hard for me to fully distinguish them.\nHowever, it can detects forest very accurately!","77619a07":"## Visualize the data\nWe can display a random image from the training set.","ef83968f":"We define n_estimators Neural Networks. \n\nEach Neural Network will be trained on random subsets of the training dataset. Each subset contains max_samples samples.","1f50ab20":"We can extract features from VGG16.","efde22c0":"# Import Packages","b711f78d":"We can also display the first 25 images from the training set directly with a loop to get a better view","18ba4c67":"Then, we can compile it with some parameters such as:\n* **Optimizer**: adam = RMSProp + Momentum.\nWhat is Momentum and RMSProp ?\n* Momentum = takes into account past gradient to have a better update.\n* RMSProp = exponentially weighted average of the squares of past gradients.\n* **Loss function**: we use sparse categorical crossentropy for classification, each images belongs to one class only","429b156d":"# Beginner: Simple Model Creation\n\nSteps are:\n1. Build the model,\n1. Compile the model,\n1. Train \/ fit the data to the model,\n1. Evaluate the model on the testing set,\n1. Carry out an error analysis of our model.\n\nWe can build an easy model composed of different layers such as:\n* Conv2D: (32 filters of size 3 by 3) The features will be \"extracted\" from the image.\n* MaxPooling2D: The images get half sized.\n* Flatten: Transforms the format of the images from a 2d-array to a 1d-array of 150 150 3 pixel values.\n* Relu  : given a value x, returns max(x, 0).\n* Softmax: 6 neurons, probability that the image belongs to one of the classes.","a3c828c4":"# Let's explore the dataset\nWe can ask ourselves:\n* How many training and testing examples do we have ?\n* What is the size of the images ?\n* What is the proportion of each observed category ?","e20173bb":"We can identifying clusters thanks to this PCA. The clusters correspond more or less to the labels.\n\nWe see that glacier and mountain points are very close to each other, as VGG sees them as very similar.\n\nWe see that there is no distinction between building and street.\n ","0007ee1a":"## Good practice: scale the data","beaf730d":"# Ensemble Neural Networks","7ea51336":"We should evaluate the model performance on test set"}}