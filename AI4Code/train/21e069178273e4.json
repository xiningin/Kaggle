{"cell_type":{"0068bce2":"code","c64aa7a3":"code","cee5dfdf":"code","c10ebde9":"code","88df1551":"code","c9d2ea76":"code","b0773218":"code","0d33239d":"code","dfe69eb4":"code","1c5b113f":"code","47cbad2a":"code","24f9308f":"code","bc21c48c":"code","0e8575c8":"code","eaf7a531":"code","5232ead2":"code","22c961e2":"code","d6e2adef":"code","52a3518b":"code","3ac1aa52":"code","fd1003cf":"code","b6a7c18a":"code","51e4c233":"code","5c7b1b87":"code","5c27962e":"code","06a75a9c":"code","2cf90639":"code","757d82dd":"code","bafcfc98":"code","d6e7ca7d":"code","43f20174":"code","2cdf4191":"code","7afb64dd":"code","d74055c7":"code","38531cbd":"code","cd027383":"code","79d5e34d":"code","d8844c55":"code","7005da8e":"code","d0bf835f":"code","784b3f99":"code","d095fda1":"code","976f71ef":"code","2f1f025c":"code","5c3c0e1d":"code","55fb3470":"code","05abc2f6":"code","7e04ce5c":"code","dbf6f242":"code","ad330fcd":"code","c491283a":"code","260abc66":"code","05421516":"code","16daa25b":"code","351db2d5":"code","0afcf69c":"code","f5f13b71":"code","16689ee6":"code","256fe2ab":"code","6378025a":"code","00b8c3eb":"code","6957efd0":"code","48e5cae3":"code","1d5154e3":"code","2afde882":"code","b1e0f844":"code","fd0369d6":"code","ef101389":"code","c28ae58e":"code","0fa74e13":"code","5d018a88":"code","265683bc":"code","5f54ec30":"code","ec1b17a6":"code","37ead25e":"code","ea666373":"code","11773076":"code","b6335bfa":"code","a1404393":"code","5de8c858":"code","c4a572c3":"code","59b10388":"code","583ad70e":"code","28ab587d":"code","ee57bc04":"code","3984b724":"code","8fc76be2":"code","e7c70f61":"markdown","3661f473":"markdown","53a280cd":"markdown","de003b54":"markdown","2acf9897":"markdown","7212e6b7":"markdown","61d40970":"markdown","29861972":"markdown","9527c47b":"markdown","528cbb5a":"markdown","b3245ce1":"markdown","84d4ffe1":"markdown","e9aada2a":"markdown","53161be2":"markdown","abcd1b6d":"markdown","3b7b3ea9":"markdown","d8730287":"markdown","0363fe01":"markdown","935cddc5":"markdown","875298f5":"markdown","a5e276aa":"markdown","9ea4084d":"markdown","8b7dc597":"markdown","44a4430c":"markdown","06bccf06":"markdown","d2defffc":"markdown","1bbf038a":"markdown","298d6e48":"markdown","6eb71122":"markdown","8afe46be":"markdown","23e1424b":"markdown","a50a7fa4":"markdown","af7535d4":"markdown","e6f98dfd":"markdown","94631250":"markdown","25745484":"markdown","5a555bb2":"markdown","472fd358":"markdown","263d3494":"markdown","3f0eaa5d":"markdown","69d2212b":"markdown","5ea48359":"markdown","78a4dca4":"markdown","bdd3810d":"markdown","7394783d":"markdown","73cb7550":"markdown","69a4f745":"markdown","a7b765ad":"markdown","dd821ff6":"markdown","f26906d8":"markdown","fcbe11d0":"markdown","c086bd09":"markdown","d1216e22":"markdown","99802a74":"markdown","4d21ccb0":"markdown","63d07f45":"markdown","48b501c8":"markdown","37f709eb":"markdown","efb2eb11":"markdown","729792f8":"markdown","a9a59b97":"markdown","0791c50f":"markdown","6594eb87":"markdown","7b05cb84":"markdown","f9280b28":"markdown","072b06b7":"markdown","79ed09ae":"markdown","25c8c781":"markdown","9c75545f":"markdown","b79b283b":"markdown","c081d020":"markdown","a6015c39":"markdown","0f356a35":"markdown","59aaca70":"markdown","0cd76e74":"markdown","a7b6598b":"markdown","099bd794":"markdown","33daa412":"markdown","d8797692":"markdown","d68db46c":"markdown","0ca0f361":"markdown","0804a266":"markdown","3a974830":"markdown","686ea1e1":"markdown","c6ae6698":"markdown","73f14ba7":"markdown","fa9b380d":"markdown","d6fdcd42":"markdown"},"source":{"0068bce2":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","c64aa7a3":"df = pd.read_sas('\/kaggle\/input\/apurao-final-eleio-2018\/eleicao_2018_apuracao_final.sas7bdat', format = 'sas7bdat', encoding='iso-8859-1')","cee5dfdf":"import seaborn as sns","c10ebde9":"import matplotlib.pyplot as plt","88df1551":"df.T","c9d2ea76":"df_drop=df.drop(columns=['ANO_ELEICAO', 'NM_TIPO_ELEICAO','DS_ELEICAO','DT_ELEICAO','TP_ABRANGENCIA','SG_UE','NM_PARTIDO',\n                 'NM_URNA_CANDIDATO','TP_AGREMIACAO','DS_NACIONALIDADE','ST_DECLARAR_BENS','NM_COLIGACAO',\n                         'DS_COMPOSICAO_COLIGACAO','ST_REELEICAO','SQ_CANDIDATO','NM_MUNICIPIO_NASCIMENTO','DT_NASCIMENTO',\n                        'NR_CANDIDATO','NM_UE','NM_CANDIDATO'])","b0773218":"df_drop.T","0d33239d":"pd.options.display.float_format = '{:.0f}'.format","dfe69eb4":"df_drop.describe()","1c5b113f":"df_drop.shape","47cbad2a":"df[df['NR_IDADE_DATA_POSSE'] == 825][['DT_NASCIMENTO']]","24f9308f":"plt.figure(figsize=(20,10))","bc21c48c":"\ndf_drop[['Despesa_Total','Receita_Total','Votos','NR_IDADE_DATA_POSSE']].hist(figsize=[20,10])","0e8575c8":"df_drop[df_drop['Votos'] < 1000][['Despesa_Total','Receita_Total','Votos','NR_IDADE_DATA_POSSE']].hist(figsize=[20,10])","eaf7a531":"df_drop.isnull().sum().reset_index()","5232ead2":"df_drop.T","22c961e2":"df_drop_rs = df_drop[\n    (df_drop['SG_UF'] == 'RS')\n  & (df_drop['NR_TURNO'] == 1)\n  & (df_drop['DS_SITUACAO_CANDIDATURA'] == 'APTO')\n  & (df_drop['DS_DETALHE_SITUACAO_CAND'].isin(['DEFERIDO','DEFERIDO COM RECURSO'])) \n  & (df_drop['DS_CARGO'].isin(['SENADOR','DEPUTADO ESTADUAL','DEPUTADO FEDERAL']))\n  & (df_drop['DS_SIT_TOT_TURNO'].isin(['ELEITO','N\u00c3O ELEITO','ELEITO POR QP','ELEITO POR M\u00c9DIA']))\n].reset_index()","d6e2adef":"df_rs = df_drop_rs.drop(columns=['NR_TURNO','DS_SITUACAO_CANDIDATURA']).reset_index()","52a3518b":"df_rs[['index','DS_SIT_TOT_TURNO']].groupby('DS_SIT_TOT_TURNO').count()","3ac1aa52":"def resulta(df):\n    if df['DS_SIT_TOT_TURNO'] == 'N\u00c3O ELEITO':\n        return 0\n    else:\n        return 1","fd1003cf":"df_rs['Resultado']=df_rs.apply(resulta,axis=1)","b6a7c18a":"df_rs[['index','Resultado']].groupby('Resultado').count()","51e4c233":"df_rs.isnull().sum().reset_index()","5c7b1b87":"from sklearn.experimental import enable_iterative_imputer\nfrom sklearn.impute import IterativeImputer","5c27962e":"imp = IterativeImputer(max_iter=10, random_state=0)","06a75a9c":"df_rs.describe()","2cf90639":"imp = IterativeImputer(max_iter=10, random_state=0)","757d82dd":"imp.fit(df_rs[['NR_IDADE_DATA_POSSE','Votos','Receita_Total','Despesa_Total','Resultado']])  ","bafcfc98":"IterativeImputer(add_indicator=False, estimator=None,\n                 imputation_order='ascending', initial_strategy='mean',\n                 max_iter=10, max_value=None, min_value=None,\n                 missing_values=np.nan, n_nearest_features=None,\n                 random_state=0, sample_posterior=False, tol=0.001,\n                 verbose=0)","d6e7ca7d":"array_imputado = imp.transform(df_rs[['NR_IDADE_DATA_POSSE','Votos','Receita_Total','Despesa_Total','Resultado']])","43f20174":"df_imputado=pd.DataFrame(data=array_imputado[:,:],columns=['NR_IDADE_DATA_POSSE','Votos','Receita_Total','Despesa_Total','Resultado'])","2cdf4191":"df_imputado.T","7afb64dd":"df_imputado.describe()","d74055c7":"df_imputado.isnull().sum().reset_index()","38531cbd":"# import statements\n#from sklearn.datasets import make_blobs\n#import numpy as np\n#import matplotlib.pyplot as plt\n# create blobs\n#data = make_blobs(n_samples=200, n_features=2, centers=4, cluster_std=1.6, random_state=50)\n# create np array for data points\n#points = data[0]\n# create scatter plot\n#plt.scatter(data[0][:,0], data[0][:,1], c=data[1], cmap='viridis')\n#plt.xlim(-15,15)\n#plt.ylim(-15,15)","cd027383":"#plt.scatter(df_rs['Votos'], df_rs['Receita_Total'], cmap='viridis')\n#plt.xlim(-15,15)\n#plt.ylim(-15,15)\n","79d5e34d":"df_imputado.plot(kind='scatter', x='Votos', y='Receita_Total',figsize=[9,6])","d8844c55":"df_imputado.plot(kind='scatter', x='Votos', y='Despesa_Total',figsize=[9,6])","7005da8e":"df_imputado.plot(kind='scatter', y='Despesa_Total', x='Receita_Total',figsize=[9,6])","d0bf835f":"df_imputado.plot(kind='scatter', y='Votos', x='NR_IDADE_DATA_POSSE',figsize=[9,6])","784b3f99":"# import KMeans\nfrom sklearn.cluster import KMeans","d095fda1":"#vetor = df_imputado[['Votos','Despesa_Total']].values\n#vetor","976f71ef":"kmeans = KMeans(n_clusters=4)","2f1f025c":"kmeans.fit(array_imputado)","5c3c0e1d":"# print location of clusters learned by kmeans object\nprint(kmeans.cluster_centers_)","55fb3470":"y_km = kmeans.fit_predict(array_imputado)","05abc2f6":"plt.scatter(array_imputado[y_km ==0,0], array_imputado[y_km == 0,1], s=10, c='red')\nplt.scatter(array_imputado[y_km ==1,0], array_imputado[y_km == 1,1], s=10, c='black')\nplt.scatter(array_imputado[y_km ==2,0], array_imputado[y_km == 2,1], s=10, c='blue')\nplt.scatter(array_imputado[y_km ==3,0], array_imputado[y_km == 3,1], s=10, c='cyan')","7e04ce5c":"plt.scatter(array_imputado[y_km ==0,2], array_imputado[y_km == 0,1], s=10, c='red')\nplt.scatter(array_imputado[y_km ==1,2], array_imputado[y_km == 1,1], s=10, c='black')\nplt.scatter(array_imputado[y_km ==2,2], array_imputado[y_km == 2,1], s=10, c='blue')\nplt.scatter(array_imputado[y_km ==3,2], array_imputado[y_km == 3,1], s=10, c='cyan')","dbf6f242":"plt.scatter(array_imputado[y_km ==0,3], array_imputado[y_km == 0,1], s=10, c='red')\nplt.scatter(array_imputado[y_km ==1,3], array_imputado[y_km == 1,1], s=10, c='black')\nplt.scatter(array_imputado[y_km ==2,3], array_imputado[y_km == 2,1], s=10, c='blue')\nplt.scatter(array_imputado[y_km ==3,3], array_imputado[y_km == 3,1], s=10, c='cyan')","ad330fcd":"plt.scatter(array_imputado[y_km ==0,2], array_imputado[y_km == 0,3], s=10, c='red')\nplt.scatter(array_imputado[y_km ==1,2], array_imputado[y_km == 1,3], s=10, c='black')\nplt.scatter(array_imputado[y_km ==2,2], array_imputado[y_km == 2,3], s=10, c='blue')\nplt.scatter(array_imputado[y_km ==3,2], array_imputado[y_km == 3,3], s=10, c='cyan')","c491283a":"# import hierarchical clustering libraries\nimport scipy.cluster.hierarchy as sch\nfrom sklearn.cluster import AgglomerativeClustering","260abc66":"plt.figure(figsize=(20,10))\n# create dendrogram\ndendrogram = sch.dendrogram(sch.linkage(array_imputado, method='ward'))\n# create clusters\nhc = AgglomerativeClustering(n_clusters=4, affinity = 'euclidean', linkage = 'ward')\n# save clusters for chart\ny_hc = hc.fit_predict(array_imputado)","05421516":"plt.scatter(array_imputado[y_hc ==0,0], array_imputado[y_hc == 0,1], s=10, c='red')\nplt.scatter(array_imputado[y_hc ==1,0], array_imputado[y_hc == 1,1], s=10, c='black')\nplt.scatter(array_imputado[y_hc ==2,0], array_imputado[y_hc == 2,1], s=10, c='blue')\nplt.scatter(array_imputado[y_hc ==3,0], array_imputado[y_hc == 3,1], s=10, c='cyan')","16daa25b":"plt.scatter(array_imputado[y_hc ==0,2], array_imputado[y_hc == 0,1], s=10, c='red')\nplt.scatter(array_imputado[y_hc ==1,2], array_imputado[y_hc == 1,1], s=10, c='black')\nplt.scatter(array_imputado[y_hc ==2,2], array_imputado[y_hc == 2,1], s=10, c='blue')\nplt.scatter(array_imputado[y_hc ==3,2], array_imputado[y_hc == 3,1], s=10, c='cyan')","351db2d5":"plt.scatter(array_imputado[y_hc ==0,3], array_imputado[y_hc == 0,1], s=10, c='red')\nplt.scatter(array_imputado[y_hc ==1,3], array_imputado[y_hc == 1,1], s=10, c='black')\nplt.scatter(array_imputado[y_hc ==2,3], array_imputado[y_hc == 2,1], s=10, c='blue')\nplt.scatter(array_imputado[y_hc ==3,3], array_imputado[y_hc == 3,1], s=10, c='cyan')","0afcf69c":"plt.scatter(array_imputado[y_hc ==0,2], array_imputado[y_hc == 0,3], s=10, c='red')\nplt.scatter(array_imputado[y_hc ==1,2], array_imputado[y_hc == 1,3], s=10, c='black')\nplt.scatter(array_imputado[y_hc ==2,2], array_imputado[y_hc == 2,3], s=10, c='blue')\nplt.scatter(array_imputado[y_hc ==3,2], array_imputado[y_hc == 3,3], s=10, c='cyan')","f5f13b71":"from sklearn.tree import DecisionTreeClassifier # Import Decision Tree Classifier\nfrom sklearn.model_selection import train_test_split # Import train_test_split function\nfrom sklearn import metrics #Import scikit-learn metrics module for accuracy calculation","16689ee6":"feature_cols = ['NR_IDADE_DATA_POSSE','Votos','Receita_Total','Despesa_Total']\nX = df_imputado[feature_cols] # Vari\u00e1veis de entrada\ny = df_imputado.Resultado # Vari\u00e1vel a ser predita","256fe2ab":"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1) # 70% training and 30% test","6378025a":"\nclf = DecisionTreeClassifier()\n\n\nclf = clf.fit(X_train,y_train)\n\n\n","00b8c3eb":"y_pred = clf.predict(X_test)","6957efd0":"print(\"Accuracia:\",metrics.accuracy_score(y_test, y_pred))","48e5cae3":"df_sem_definicao = pd.read_sas('\/kaggle\/input\/apuracao-resultado\/eleicao_2018_sem_definicao.sas7bdat', format = 'sas7bdat', encoding='iso-8859-1')","1d5154e3":"df_sem_definicao.T","2afde882":"df_drop_sem=df_sem_definicao.drop(columns=['ANO_ELEICAO', 'NM_TIPO_ELEICAO','DS_ELEICAO','DT_ELEICAO','TP_ABRANGENCIA','SG_UE','NM_PARTIDO',\n                 'NM_URNA_CANDIDATO','TP_AGREMIACAO','DS_NACIONALIDADE','ST_DECLARAR_BENS','NM_COLIGACAO',\n                         'DS_COMPOSICAO_COLIGACAO','ST_REELEICAO','SQ_CANDIDATO','NM_MUNICIPIO_NASCIMENTO','DT_NASCIMENTO',\n                        'NR_CANDIDATO','NM_UE'])","b1e0f844":"df_drop_sem.T","fd0369d6":"df_drop_sem_rs = df_drop_sem[\n    (df_drop_sem['SG_UF'] == 'RS')\n  & (df_drop_sem['NR_TURNO'] == 1)\n  & (df_drop_sem['DS_SITUACAO_CANDIDATURA'] == 'APTO')\n  & (df_drop_sem['DS_DETALHE_SITUACAO_CAND'].isin(['DEFERIDO','DEFERIDO COM RECURSO'])) \n  & (df_drop_sem['DS_CARGO'].isin(['SENADOR','DEPUTADO ESTADUAL','DEPUTADO FEDERAL']))\n].reset_index()","ef101389":"df_drop_sem_rs2 = df_drop_sem_rs.drop(columns=['NR_TURNO','DS_SITUACAO_CANDIDATURA']).reset_index()","c28ae58e":"df_drop_sem_rs2.describe()","0fa74e13":"df_drop_sem_rs2.isnull().sum().reset_index()","5d018a88":"imp_sem = IterativeImputer(max_iter=10, random_state=0)","265683bc":"imp_sem.fit(df_drop_sem_rs2[['NR_IDADE_DATA_POSSE','Votos','Receita_Total','Despesa_Total']])  ","5f54ec30":"array_imputado_sem = imp_sem.transform(df_drop_sem_rs2[['NR_IDADE_DATA_POSSE','Votos','Receita_Total','Despesa_Total']])","ec1b17a6":"df_imputado_sem=pd.DataFrame(data=array_imputado_sem[:,:],columns=['NR_IDADE_DATA_POSSE','Votos','Receita_Total','Despesa_Total'])","37ead25e":"df_imputado_sem.describe()","ea666373":"df_imputado_sem.isnull().sum().reset_index()","11773076":"df_imputado_sem","b6335bfa":"y_pred_sem = clf.predict(df_imputado_sem)","a1404393":"y_pred_sem","5de8c858":"df_pred_sem=pd.DataFrame(data=y_pred_sem[:],columns=['Resultado'])","c4a572c3":"df_pred_sem_join = pd.concat([df_imputado_sem,df_pred_sem], axis=1)","59b10388":"df_pred_sem_join","583ad70e":"resultado_rs_previsto = pd.concat([df_drop_sem_rs2,df_pred_sem], axis=1)","28ab587d":"resultado_rs_previsto.T","ee57bc04":"def final(df):\n    if df['Resultado'] == 1:\n        return 'ELEITO'\n    else:\n        return 'N\u00c3O ELEITO'","3984b724":"resultado_rs_previsto['Resultado_Final']=resultado_rs_previsto.apply(final,axis=1)","8fc76be2":"resultado_rs_previsto[['DS_CARGO','NM_CANDIDATO','Resultado_Final']]","e7c70f61":"Os valores est\u00e3o muito concentrados \u00e0 esquerda. Para melhor visualiza\u00e7\u00e3o vamos filtrar.","3661f473":"Este sum\u00e1rio de estat\u00edsticas b\u00e1sicas j\u00e1 nos apresenta algumas inconsistencias, uma idade m\u00e1xima de 825 anos, diferencas na contagem dos dados de diferentes vari\u00e1veis, indicando que faltam dados. As colunas \"Votos\", \"Receita_Total\" e \"Despesa_Total\" tem valores menores na contagem. As colunas \"NR_IDADE_DATA_POSSE\" e \"NR_TURNO\" tem contagem maior: 29145 registros. Vamos verificar se coincide com o n\u00famero de registros total da tabela.","53a280cd":"Despesas x votos","de003b54":"Vamos ver agora como foi preenchida a coluna Resultado.","2acf9897":"H\u00e1 cinco registros sem informa\u00e7\u00e3o de receita e 94 registros de despesa de candidatos tamb\u00e9m vazios. Vamos imputar valores utilizando a biblioteca sklearn. A rotina IterativeImputer efetua uma imputa\u00e7\u00e3o nos dados de forma iterativa considerando a cada vez uma das vari\u00e1veis como dependente. Ela utiliza as outras vari\u00e1veis para efetuar a estimativa. A forma como a rotina efetua as itera\u00e7\u00f5es \u00e9 denominada round-robin. a cada itera\u00e7\u00e3o, uma vari\u00e1vel\/coluna \u00e9 designada como vari\u00e1vel de sa\u00edda y e as outras s\u00e3o tratadas como vari\u00e1veis de entrada  X. Uma regress\u00e3o \u00e9 efetuada em (X, y) cada vez. Esta regress\u00e3o \u00e9 utilizada para predizer os valores faltantes de y. Isto \u00e9 feito para cada vari\u00e1vel de forma iterativa, e \u00e9 repetida at\u00e9 alcan\u00e7ar o valor m\u00e1ximo de itera\u00e7\u00f5es (max_iter). Os resultados da itera\u00e7\u00e3o final s\u00e3o ent\u00e3o imputados aos campos vazios.\n \n\nPrimeiro vamos importar a biblioteca sklearn.","7212e6b7":"Para a idade x votos","61d40970":"Para ficar mais claro, vamos criar mais uma coluna  que decodificar\u00e1 os valores do resultado de 0 para 'N\u00c3O ELEITO' e de 1 para 'ELEITO'.","29861972":"Receitas x votos","9527c47b":"Vamos definir a fun\u00e7\u00e3o que seta os valores de Resultado para 1 ou 0 caso o candidato seja eleito ou n\u00e3o.","528cbb5a":"Utilizaremos agora um m\u00e9todo hier\u00e1rquico. O m\u00e9todo AgglomerativeClustering inialmente considera todos os pontos como clusters individuais. Depois eles s\u00e3o aglutinados em fun\u00e7\u00e3o da distancia. Os mais pr\u00f3ximos se aglutinam. Formado o cluster maior, \u00e9 ent\u00e3o gerado um dendograma (diagrama em forma de \u00e1rvore) que formar\u00e1 a \u00e1rvore de decis\u00e3o.\nUtilizaremos agora um m\u00e9todo hier\u00e1rquico.","b3245ce1":"Abaixo a estrutura da tabela que \u00e9 identica \u00e0 que utilizamos inicialmente para constru\u00e7\u00e3o do modelo.","84d4ffe1":"Abaixo podemos ver que os valores faltantes foram preenchidos.","e9aada2a":"Abaixo temos a visualiza\u00e7\u00e3o de parte da tabela com a posi\u00e7\u00e3o das linhas e colunas invertida para que possamos visualizar melhor todas as colunas dispon\u00edveis.","53161be2":"Efetuaremos agora uma contagem dos valores nulos usando outro m\u00e9todo.","abcd1b6d":"Definimos em seguida as vari\u00e1veis que vamos utilizar na imputa\u00e7\u00e3o.","3b7b3ea9":"O resultado vem na forma de 0 e 1, indicando se o candidato foi eleito ou n\u00e3o.","d8730287":"Definimos a fun\u00e7\u00e3o de transforma\u00e7\u00e3o.","0363fe01":"Abaixo temos as estat\u00edsiticas da tabela resultante","935cddc5":"Observamos que as colunas Votos, Receita_Total e Despesa_Total est\u00e3o vazias em muitos registros.","875298f5":"Acur\u00e1cia do modelo, Qual a taxa de acerto?","a5e276aa":"Vamos filtrar a base selecionando apenas os candidatos do Rio Grande do Sul (SG_UF = 'RS'), no primeiro turno (NR_TURNO=1), para os cargos de senador, deputado federal e estadual (DS_CARGO ='SENADOR' ou DS_CARGO ='DEPUTADO ESTADUAL' ou DS_CARGO ='DEPUTADO FEDERAL') que foram eleitos, n\u00e3o eleitos, eleitos por qp ou por m\u00e9dia (S_SIT_TOT_TURNO='ELEITO','ELEITO POR QP','ELEITO POR M\u00c9DIA','N\u00c3O ELEITO'), que est\u00e3o aptos (DS_SITUACAO_CANDIDATURA='APTO') e que tiveram a candidatura deferida (DS_DETALHE_SITUACAO_CAND='DEFERIDO' ou DS_DETALHE_SITUACAO_CAND='DEFERIDO COM RECURSO').","9ea4084d":"Tal qual efetuado anteriormente, vamos proceder \u00e0 imputa\u00e7\u00e3o dos dados de despesa j\u00e1 que h\u00e1 registros vazios.","8b7dc597":"Abaixo o grafico das despesas versus receitas mostra esta rela\u00e7\u00e3o que \u00e9 bastante linear.","44a4430c":"Atribuimos a fun\u00e7\u00e3o \u00e0 coluna 'Resultado_Final'","06bccf06":"Agora o gr\u00e1fico das despesas versus quantidade de votos. Este \u00e9 bem similar ao das receitas versus votos. Podemos ver tamb\u00e9m que a efici\u00eancia do dinheiro gasto, quando se considera o n\u00famero de votos obtidos em fun\u00e7\u00e3o das despesas, varia bastante. H\u00e1 muitos candidatos que gastam muito e recebem poucos votos.\nAgora o gr\u00e1fico das despesas vesus quantidade de votos. Este \u00e9 bem similar ao das receitas versus votos.","d2defffc":"Visualmente podemos perceber que h\u00e1 uma correspond\u00eancia entre as vari\u00e1veis receita e despesa com o n\u00famero de votos. O algoritmo entendeu que \u00e9 necess\u00e1rio dinheiro para se ganhar uma elei\u00e7\u00e3o.\n\nAgora vamos concatenar o resultado com a tabela com todos os dados de entrada para permitir a identifica\u00e7\u00e3o do candidato.","1bbf038a":"Al\u00e9m da bibbiloteca Pandas e Numpy, precisamos de mais algumas, como Seaborn e Matplotlib para gerar gr\u00e1ficos.","298d6e48":"### Iremos agora efetuar previs\u00f5es  utilizando o modelo gerado com o classificador.","6eb71122":"Podemos perceber que h\u00e1 muitas colunas que s\u00e3o relevantes para a nossa an\u00e1lise, como por exemplo o nome do munic\u00edpio de nascimento, o nome do estado (utilizaremos a sigla somente), data da elei\u00e7\u00e3o e outras.\nVamos remover as colunas desnecess\u00e1rias ou redundantes e denominar a nova tabela de df_drop.","8afe46be":"\nDefinimos em seguida os par\u00e2metros para a imputa\u00e7\u00e3o.","23e1424b":"Abaixo a tabela ap\u00f3s limpeza.","a50a7fa4":"Contamos agora a qauntidade de leitos e n\u00e3o eleitos.","af7535d4":"Procederemos novamente \u00e0 limpeza dos campos desnecess\u00e1rios.","e6f98dfd":"Primeiro importamos a bibiloteca necess\u00e1ria","94631250":"Abaixo temos o resultado das elei\u00e7\u00f5es para os candidatos da tabela 'eleicao_2018_sem_definicao' para o estado do Rio Grande do Sul.","25745484":"Utilizamos agora o classificador obtido anteriormente com os dados dos candidatos cujo resultado sera previsto.","5a555bb2":"Mesmo para quem recebeu menos de 1000 votos, h\u00e1 totais de receita e despesa bastante elevados com podemos ver pelo gr\u00e1fico.","472fd358":"Verificamos novamente se falta algum dado","263d3494":"Abaixo o resultado da concatena\u00e7\u00e3o.","3f0eaa5d":"Primeiro vamos  importar a tabela com dados do candidatos cujo resultado da elei\u00e7\u00e3o est\u00e1 indefinido.","69d2212b":"Vamos criar uma coluna \"RESULTADO\" com os valores \"ELEITO\" ou 'N\u00c3O ELEITO' trnsformando os dados 'ELEITO POR QP' e 'ELEITO POR M\u00c9DIA' em 'ELEITO'. Assim tentaremos efetuar uma previs\u00e3o de quem se elegeu ou n\u00e3o.","5ea48359":"Despesa x votos","78a4dca4":"Filtramos as colunas para total de votso menor que 1000 e plotamos o gr\u00e1fico do histograma com a biblioteca seaborn.","bdd3810d":"Infelizmente o campo est\u00e1 vazio para a data de nascimento.","7394783d":"Dividimos o dataset entre as vari\u00e1veis de entrada e a que iremos prever","73cb7550":"Inicialmente vamos obter as estat\u00edsiticas b\u00e1sicas da tabela, corrigindo o formato de apresenta\u00e7\u00e3o dos n\u00fameros pois, como vimos acima, colunas como receita e despesa foram apresentadas com nota\u00e7\u00e3o cient\u00edfica.","69a4f745":"removeremos tamb\u00e9m as linhas indesejadas, tal qual efetuamos anteriormente com os dados que utilizamos para an\u00e1lise.","a7b765ad":"Mas antes vamos setar o tamanho do gr\u00e1fico.","dd821ff6":"A contagem de campos vazios informa tamb\u00e9m que a tablea esta totalmente preenchida.","f26906d8":"Em seguida procedemos \u00e0 clusteriza\u00e7\u00e3o. O m\u00e9todo d\u00e1 como sa\u00edda um gr\u00e1fico.","fcbe11d0":"Retiramos mais algumas colunas desnecess\u00e1rias.","c086bd09":"Primeiramente vamos importar a tabela Apura\u00e7\u00e3o Final da elei\u00e7\u00e3o de 2018.","d1216e22":"Criamos o objeto de classifica\u00e7\u00e3o","99802a74":"Divis\u00e3o do dataset em treinamento e teste","4d21ccb0":"A massa de dados \u00e9 pequena, mas obtivemos uma acur\u00e1cia de 94%.","63d07f45":"\nPrimeiro definimos os atributos de IterativeImputer.","48b501c8":"Temos agora a tabela mais compacta, com vari\u00e1veis mais interessanes para nossa pesquisa.","37f709eb":"https:\/\/towardsdatascience.com\/an-introduction-to-clustering-algorithms-in-python-123438574097","efb2eb11":"\nEm seguida convertemos o array em um dataframe.","729792f8":"A tabela tem 29.145 linhas e 17 colunas. Assim a coluna com a idade do candidato est\u00e1 completa, entretanto, como j\u00e1 vimos, h\u00e1 incosistencias pois h\u00e1 um valor m\u00e1ximo encontrado de 825 anos.\nPor meio do dataframe df podemos descobrir se a data de nasciemnto foi preenchida.","a9a59b97":"Atribuimos a fun\u00e7\u00e3o \u00e0 coluna.","0791c50f":"Ap\u00f3s remo\u00e7\u00e3o das linhas, podemos retirar tamb\u00e9m mais algumas colunas que foram utilizadas como filtro.","6594eb87":"Receita x votos","7b05cb84":"Abaixo uma amostra da base com valores imputados.","f9280b28":"Utilizamos o array com os valores imputados para carregar os dados na fun\u00e7\u00e3o de an\u00e1lise de cluster.","072b06b7":"Vejamos de novo as estat\u00edsiticas b\u00e1sicas ap\u00f3s a imputa\u00e7\u00e3o.","79ed09ae":"Receita x despesas","25c8c781":"Abaixo a tabela completa","9c75545f":"Predizemos a sa\u00edda","b79b283b":"Abaixo o gr\u00e1fico que mostra a rela\u00e7\u00e3o entre idade e quantidade de votos. Interessante notar que as quantidades maiores de votos est\u00e3o em uma faixa de idade entre 55 e 75 anod de idade. S\u00e3o os pol\u00edticos mais conhecidos e de longo tempo de carreira.","c081d020":"Vamos verificar se h\u00e1 campos vazios.","a6015c39":"Concatenamos o resultado com os dados de entrada para analisar a corrspondencia entre os dados de entrada e o resultado.","0f356a35":"Vamos agora implementar uma \u00e1rvore de decis\u00e3o.","59aaca70":"O c\u00f3digo abaixo lista os arquivos dispon\u00edveis no Kaggle. Ap\u00f3s efetuado no upload do arquivo, a tabela no formato do SAS (sas7bdat) aparece na listagem.","0cd76e74":"## Efetuaremos agora a implementa\u00e7\u00e3o e visualiza\u00e7\u00e3o de resultados de uma funcionalidade completa em Python com a leitura dos dados, tratamento de missing values, an\u00e1lise de cluster e implementa\u00e7\u00e3o de uma \u00e1rvore de decis\u00e3o.\n","a7b6598b":"Convertemos a sa\u00edda para um dataframe.","099bd794":"\nObtemos em seguida o array com os valores imputados.","33daa412":"Abaixo temos o gr\u00e1fico da receita dos candidatos em fun\u00e7\u00e3o da quantidade de votos","d8797692":"Abaixo o resultado obtido.","d68db46c":"Idade x votos","0ca0f361":"Primeiro importamos as bibliotecas necess\u00e1rias","0804a266":"Vamos verificar se h\u00e1 valores nulos na base.","3a974830":"Observamos que embora haja uma rela\u00e7\u00e3o entre o n\u00famero de votos e a receita total de cada candidato, podemos notar que h\u00e1 uma faixa \u00e0 esquerda do gr\u00e1fico indicando que muitos candidatos tem receitas maiores que n\u00e3o correspondem a um n\u00famero maior de votos.\n","686ea1e1":"\nPodemos ver como algumas vari\u00e1veis se distribuem por meio de um histograma. Vamos analisar as colunas \"Despesa_Total\", \"Receita_Total\", \"Votos\" e \"NR_IDADE_DATA_POSSE\".\n","c6ae6698":"Vamos verificar novamente os dados que faltam.","73f14ba7":"Obtemos os dados preditos para an\u00e1lise gr\u00e1fica","fa9b380d":"Efetuaremos agora uma an\u00e1lise de cluster. Para isso utilizaremos a rotina KMeans da biblioteca SKLearn. O K-means \u00e9 um algoritmo do tipo n\u00e3o supervisionado. O algoritmo de forma iterativa atribui os pontos de dados ao grupo que representa a menor dist\u00e2ncia, ou seja, ao grupo de dados que seja mais similar. Os centr\u00f3ides s\u00e3o estipulados aleatoriamente. Os dados s\u00e3o agrupados a cada centr\u00f3ide em fun\u00e7\u00e3o da menor dist\u00e2ncia. Finalizados os agrupamentos os centr\u00f3ides s\u00e3o recalculados em fun\u00e7\u00e3o da posi\u00e7\u00e3o dos pontos do grupo.\n","d6fdcd42":"Receitas x Despesas"}}