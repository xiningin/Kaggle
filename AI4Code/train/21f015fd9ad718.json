{"cell_type":{"b95fc216":"code","1a047a5b":"code","5887bbc8":"code","98d391fb":"code","0a08f860":"code","1066375e":"code","5ee6a393":"code","37389076":"code","a2911a18":"code","3886f947":"code","733ea76c":"code","75d31608":"code","6200ffb2":"code","2449cf83":"code","cc5f2cc4":"code","018d91b9":"code","66bac33a":"code","e16da4bc":"code","69af2a0f":"code","8f46a799":"code","d2259cb3":"code","1024cf96":"code","9de5d2ac":"code","b21af709":"code","7d6c7f94":"code","29a1cccd":"code","35ba712e":"code","66f64902":"code","5a0089a5":"code","08f41dcd":"code","3108458c":"code","b7378d7d":"code","edb62ff4":"code","911d7f73":"code","0ab92865":"code","8190c75c":"code","4c7c8aa0":"code","9c35d353":"markdown","dd2a07f7":"markdown","edf8ccef":"markdown","ea503c1e":"markdown","0a21ea81":"markdown","998f6d2c":"markdown","8d7dc0f8":"markdown","19d117d1":"markdown","c8b76f3b":"markdown","86f50e5d":"markdown","3c90277a":"markdown","0ba3249c":"markdown"},"source":{"b95fc216":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport datetime\nimport time\n\n%matplotlib inline\nsns.set(rc = {\"figure.figsize\" : (8, 6)})","1a047a5b":"data = pd.read_csv(\"..\/input\/wind-turbine-scada-dataset\/T1.csv\")\ndata.head()","5887bbc8":"data.info()","98d391fb":"data.describe()","0a08f860":"data.isnull().sum()","1066375e":"# Pair Plot correlation between all attributes\nsns.pairplot(data)","5ee6a393":"#correlation between the values\ncorr = data.corr()\nplt.figure(figsize=(10, 8))\n\nax = sns.heatmap(corr, vmin = -1, vmax = 1, annot = True)\nbottom, top = ax.get_ylim()\nax.set_ylim(bottom + 0.5, top - 0.5)\nplt.show()\ncorr","37389076":"# Importing a visualization library\n! pip install windrose","a2911a18":"from windrose import WindroseAxes\n\nax = WindroseAxes.from_ax()\nax.bar(data['Wind Direction (\u00b0)'], data['Wind Speed (m\/s)'], normed=True, opening=0.8, edgecolor='white')\nax.set_legend()\nplt.title(\"Wind Direction (\u00b0) VS Wind Speed (m\/s)\")\nplt.show()","3886f947":"# Spliting the date time in year, month, days, hours and minutes\ndata['Year']=data['Date\/Time'].apply(lambda x: time.strptime(x,\"%d %m %Y %H:%M\")[0])\ndata['Month']=data['Date\/Time'].apply(lambda x: time.strptime(x,\"%d %m %Y %H:%M\")[1])\ndata['Day']=data['Date\/Time'].apply(lambda x: time.strptime(x,\"%d %m %Y %H:%M\")[2])\ndata['Time_Hours']=data['Date\/Time'].apply(lambda x: time.strptime(x,\"%d %m %Y %H:%M\")[3])\ndata['Time_Minutes']=data['Date\/Time'].apply(lambda x: time.strptime(x,\"%d %m %Y %H:%M\")[4])\ndata.head(10)","733ea76c":"#plotting the data distribution\nplt.figure(figsize=(10, 8))\nfor i in range(4):\n    plt.subplot(2, 2, i+1)\n    sns.kdeplot(data.iloc[:,i+1], shade=True)\n    plt.title(data.columns[i+1])\nplt.tight_layout()\nplt.show()","75d31608":"# droping all the null values from the data\ndata = data.dropna()","6200ffb2":"data[\"Date\/Time\"] = pd.to_datetime(data[\"Date\/Time\"], format = \"%d %m %Y %H:%M\", errors = \"coerce\")\ndata","2449cf83":"# Create figure and plot space\nfig, ax = plt.subplots(figsize=(20,10))\n\n# Add x-axis and y-axis\nax.plot(data['Date\/Time'][0:1000],\n        data['Theoretical_Power_Curve (KWh)'][0:1000],\n        color='purple')\n\n# Set title and labels for axes\nax.set(xlabel=\"Theoretical_Power_Curve\",\n       ylabel=\"Date\/Time\",\n       title=\"Date\/Time vs Theoretical_Power_Curve\")\n\nplt.show()","cc5f2cc4":"# Droping all the irrelavent features that dosent affect the target variable.\ncols = [\"Wind Direction (\u00b0)\", 'Year', 'Month', \"Day\", \"Time_Hours\", \"Time_Minutes\" ]\ndata = data.drop(cols, axis=1)\ndata.head()","018d91b9":"df = data.copy()","66bac33a":"from pandas import DataFrame\nfrom pandas import Series\nfrom pandas import concat\nfrom pandas import read_csv\nfrom pandas import datetime\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import MinMaxScaler\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import LSTM\nfrom math import sqrt\nfrom matplotlib import pyplot\nimport numpy as np\nimport pandas as pd","e16da4bc":"# converting the Data\/Time as the index for proper shape of the input.\ndf = df.set_index('Date\/Time')","69af2a0f":"# Hardcode all variables\nbatch_size_exp = 1\nepoch_exp = 15\nneurons_exp = 10\npredict_values_exp = 1000\nlag_exp=24","8f46a799":"# frame a sequence as a supervised learning problem\ndef timeseries_to_supervised(data, lag=1):\n    df = DataFrame(data)\n    columns = [df.shift(i) for i in range(1, lag+1)]\n    columns.append(df)\n    df = concat(columns, axis=1)\n    df.fillna(0, inplace=True)\n    return df","d2259cb3":"# create a differenced series\ndef difference(dataset, interval=1):\n    diff = list()\n    for i in range(interval, len(dataset)):\n        value = dataset[i] - dataset[i - interval]\n        diff.append(value)\n    return Series(diff)","1024cf96":"# invert differenced value\ndef inverse_difference(history, yhat, interval=1):\n    return yhat + history[-interval]","9de5d2ac":"# scale train and test data to [-1, 1]\ndef scale(train, test):\n    # fit scaler\n    scaler = MinMaxScaler(feature_range=(-1, 1))\n    scaler = scaler.fit(train)\n    # transform train\n    train = train.reshape(train.shape[0], train.shape[1])\n    train_scaled = scaler.transform(train)\n    # transform test\n    test = test.reshape(test.shape[0], test.shape[1])\n    test_scaled = scaler.transform(test)\n    return scaler, train_scaled, test_scaled","b21af709":"# inverse scaling for a forecasted value\ndef invert_scale(scaler, X, value):\n    new_row = [x for x in X] + [value]\n    array = np.array(new_row)\n    array = array.reshape(1, len(array))\n    inverted = scaler.inverse_transform(array)\n    return inverted[0, -1]","7d6c7f94":"# fit an LSTM network to training data\ndef fit_lstm(train, batch_size, nb_epoch, neurons):\n    X, y = train[:, 0:-1], train[:, -1]\n    X = X.reshape(X.shape[0], 1, X.shape[1])\n    model = Sequential()\n    model.add(LSTM(neurons, batch_input_shape=(batch_size, X.shape[1], X.shape[2]), stateful=True))\n    model.add(Dense(1))\n    model.compile(loss='mean_squared_error', optimizer='adam')\n    for i in range(nb_epoch):\n        model.fit(X, y, epochs=1, batch_size=batch_size, verbose=1, shuffle=False)\n        model.reset_states()\n    return model\n    print(model.summary)","29a1cccd":"# make a one-step forecast\ndef forecast_lstm(model, batch_size, X):\n    X = X.reshape(1, 1, len(X))\n    #print(X)\n    yhat = model.predict(X, batch_size=1)\n    return yhat[0,0]","35ba712e":"'''Drop all the features as we will not be having any in production'''\ndel df['LV ActivePower (kW)']\ndel df['Wind Speed (m\/s)']\ndf.head()","66f64902":"for i in range(0,10):\n  df = df[:-1]\ndf.tail()","5a0089a5":"# transform data to be stationary\nraw_values = df.values\ndiff_values = difference(raw_values, 1)","08f41dcd":"# transform data to be supervised learning\nsupervised = timeseries_to_supervised(diff_values, lag_exp)\nsupervised_values = supervised.values","3108458c":"# split data into train and test-sets\ntrain, test = supervised_values[0:-predict_values_exp], supervised_values[-predict_values_exp:]","b7378d7d":"# transform the scale of the data\nscaler, train_scaled, test_scaled = scale(train, test)","edb62ff4":"# fit the model\nlstm_model = fit_lstm(train_scaled, batch_size_exp, epoch_exp, neurons_exp)","911d7f73":"# walk-forward validation on the test data\npredictions = list()\nexpectations = list()\npredictions_plot = list()\nexpectations_plot = list()\ntest_pred = list()\nfor i in range(len(test_scaled)):\n    # make one-step forecast\n    X, y = test_scaled[i, 0:-1], test_scaled[i, -1]\n    yhat = forecast_lstm(lstm_model, 1, X)#batch_size_exp to 1\n    '''# Start Debug prints\n    print(\"X: %\", X)\n    print(\"yhat: %\", yhat)\n    # End Debug prints'''\n    # Replacing value in test scaled with the predicted value.\n    test_pred = [yhat] + test_pred \n    if len(test_pred) > lag_exp+1:\n        test_pred = test_pred[:-1]\n    if i+1<len(test_scaled):\n        if i+1 > lag_exp+1:\n            test_scaled[i+1] = test_pred\n        else:\n            test_scaled[i+1] = np.concatenate((test_pred, test_scaled[i+1, i+1:]),axis=0)\n\n    # invert scaling\n    yhat = invert_scale(scaler, X, yhat)\n    # invert differencing\n    yhat = inverse_difference(raw_values, yhat, len(test_scaled)+1-i)\n    # store forecast\n    expected = raw_values[len(train) + i + 1]\n    predictions_plot.append(yhat)\n    expectations_plot.append(expected)\n    if expected != 0:\n        predictions.append(yhat)\n        expectations.append(expected)\n    print('Hour=%d, Predicted=%f, Expected=%f' % (i+1, yhat, expected))","0ab92865":"lstm_model.summary()","8190c75c":"expectations = np.array(expectations)\npredictions = np.array(predictions)\nprint(\"Mean Absolute Percent Error: \", (np.mean(np.abs((expectations - predictions) \/ expectations))))","4c7c8aa0":"# line plot of observed vs predicted\nsns.set_style(\"whitegrid\")\npyplot.figure(figsize=(20,10))\npyplot.plot(expectations_plot[0:100], label=\"True\")\npyplot.plot(predictions_plot[0:100], label=\"Predicted\")\npyplot.legend(loc='upper right')\npyplot.xlabel(\"Number of hours\")\npyplot.ylabel(\"Power generated by system (kW)\")\npyplot.show()","9c35d353":"### Reading the dataset","dd2a07f7":"## Importing Basic Libraries","edf8ccef":"## Calculating Mean Absolute Error","ea503c1e":"# Wind Energy Prediction and Analysis","0a21ea81":"## Converting the Data\/Time feature in proper DateTime format","998f6d2c":"# Final Prediction Plot","8d7dc0f8":"### KDE Plot","19d117d1":"### Pie Bar Chart (Wind Direction VS Wind Speed)","c8b76f3b":"# Building the LSTM model","86f50e5d":"## Data Wrangling","3c90277a":"## Visualization","0ba3249c":"### Line Graph of DateTime VS Target variable"}}