{"cell_type":{"7c3c22a4":"code","207ec520":"code","ae0435e3":"code","26fa1618":"code","8f86ad10":"code","5d65e094":"code","3c8bd2dc":"code","7d5aa870":"code","965e222f":"code","b5d3d080":"code","17caa38d":"code","a0e62a0c":"markdown"},"source":{"7c3c22a4":"import osmnx as ox\nimport pandas as pd\nimport geopandas as gpd\nimport networkx as nx\n%matplotlib inline\nox.config(log_console=True, use_cache=True)","207ec520":"# This function takes the road name and a 3-letter code for the language and it returns the colour\ndef colourcode(x, language):\n    if (language=='GER'):\n        if ('stra\u00dfe' in x) or ('strasse' in x): \n            return '#f6cf71'\n        elif ('weg' in x):\n            return '#019868'\n        elif ('allee' in x) or ('gasse' in x):\n            return '#ec0b88'\n        elif ('damm' in x):\n            return '#651eac'\n        elif ('platz' in x):\n            return '#e18a1e'\n        elif ('chaussee' in x):\n            return '#9dd292'\n        elif ('see' in x):\n            return '#2b7de5'\n        elif ('ufer' in x):\n            return '#2b7de5'\n        elif ('steg' in x):\n            return '#2b7de5'\n        else:\n            return '#c6c6c6'\n    elif (language=='ENG'):\n        if ('road' in x): \n            return '#019868'\n        elif ('street' in x):\n            return '#f6cf71'\n        elif ('way' in x):\n            return '#ec0b88'\n        elif ('avenue' in x):\n            return '#651eac'\n        elif ('drive' in x):\n            return '#e18a1e'\n        elif ('lane' in x):\n            return '#9dd292'\n        else:\n            return '#c6c6c6'\n    elif (language=='FRA'):\n        if ('rue' in x): \n            return '#019868'\n        elif ('place' in x):\n            return '#f6cf71'\n        elif ('avenue' in x):\n            return '#ec0b88'\n        elif ('boulevard' in x):\n            return '#651eac'\n        elif ('passage' in x):\n            return '#e18a1e'\n        elif ('pont' in x):\n            return '#9dd292'\n        elif ('quai' in x):\n            return '#2b7de5'\n        else:\n            return '#c6c6c6'\n    else:\n        return 'black'","ae0435e3":"# Set place and language; the place is basically a Nominatim query. It must return a POLYGON\/POLYLINE, not a POINT, so you might have to play with it a little, or set which_result below accordingly    \nplace='Zurich, Switzerland'\nlanguage='GER'\n\n# note the which_result parameter, as per comment above\nG = ox.graph_from_place(place, network_type='all', which_result=1) ","26fa1618":"# For the colouring, we take the attributes from each edge found extract the road name, and use the function above to create the colour array\nedge_attributes = ox.graph_to_gdfs(G, nodes=False)\nedge_attributes['ec'] = edge_attributes['name'].str.lower().map(lambda x: colourcode(str(x), language))\n# We can finally draw the plot\nfig, ax = ox.plot_graph(G, \n                        bgcolor='white', \n                        axis_off=True, \n                        node_size=0, \n                        node_color='w', \n                        node_edgecolor='gray', \n                        node_zorder=2,\n                        edge_color=edge_attributes['ec'], \n                        edge_linewidth=0.5, \n                        edge_alpha=1, \n                        fig_height=20, \n                        dpi=300)","8f86ad10":"# Appendix \n# Are you curious about other feature of the streets? With this piece of code, you can see what other elements you could colour..\n\nedge_attributes = ox.graph_to_gdfs(G, nodes=False)\nedge_attributes.head()","5d65e094":"edge_attributes.sample()","3c8bd2dc":"# calculate basic and extended network stats, merge them together, and display\narea = ox.project_gdf(edge_attributes).unary_union.area\nstats = ox.basic_stats(G, area=area)\nextended_stats = ox.extended_stats(G, ecc=True, bc=True, cc=True)\nfor key, value in extended_stats.items():\n    stats[key] = value\npd.Series(stats)","7d5aa870":"# unpack dicts into individiual keys:values\nstats = ox.basic_stats(G, area=area)\nfor k, count in stats['streets_per_node_counts'].items():\n    stats['int_{}_count'.format(k)] = count\nfor k, proportion in stats['streets_per_node_proportion'].items():\n    stats['int_{}_prop'.format(k)] = proportion\n\n# delete the no longer needed dict elements\ndel stats['streets_per_node_counts']\ndel stats['streets_per_node_proportion']\n\n# load as a pandas dataframe\npd.DataFrame(pd.Series(stats)).T\n","965e222f":"G_projected = ox.project_graph(G)\nmax_node, max_bc = max(extended_stats['betweenness_centrality'].items(), key=lambda x: x[1])\nmax_node, max_bc","b5d3d080":"nc = ['r' if node==max_node else '#336699' for node in G_projected.nodes()]\nns = [50 if node==max_node else 8 for node in G_projected.nodes()]\nfig, ax = ox.plot_graph(G_projected, node_size=ns, node_color=nc, node_zorder=2)","17caa38d":"# get a color for each node\ndef get_color_list(n, color_map='plasma', start=0, end=1):\n    return [cm.get_cmap(color_map)(x) for x in np.linspace(start, end, n)]\n\ndef get_node_colors_by_stat(G, data, start=0, end=1):\n    df = pd.DataFrame(data=pd.Series(data).sort_values(), columns=['value'])\n    df['colors'] = get_color_list(len(df), start=start, end=end)\n    df = df.reindex(G.nodes())\n    return df['colors'].tolist()\n\nnc = get_node_colors_by_stat(G_projected, data=extended_stats['betweenness_centrality'])\nfig, ax = ox.plot_graph(G_projected, node_color=nc, node_edgecolor='gray', node_size=20, node_zorder=2)","a0e62a0c":"Code blatantly stolen from:\nhttps:\/\/github.com\/puntofisso\/OSMnxNotebooks\/blob\/master\/Street%20colouring.ipynb\n\nTry making maps with different color roads"}}