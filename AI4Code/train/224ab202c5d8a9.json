{"cell_type":{"2dd8ee13":"code","93877dac":"code","c7c631a4":"code","0cd4442a":"code","8ec17092":"code","26c81456":"code","06c433d1":"code","5c941664":"code","4d4a11e5":"code","031cbe2e":"code","ed86593a":"code","2382cbef":"code","de8a6603":"code","3a3ff9bd":"code","2dcc833a":"code","248c25b9":"code","06d4e27f":"code","84dd3974":"code","15cf435c":"code","f23cc862":"code","f97b21d5":"code","677f24c1":"code","6e7214aa":"code","75ecb94e":"code","63c108e9":"code","769d1ec0":"code","64f1fb34":"code","b1530ac3":"code","95f1d7ef":"code","d9da33fe":"code","0fc59c78":"code","30564edd":"code","48e5cfb7":"markdown","30b2e7db":"markdown","630e6b65":"markdown","fda9a1d5":"markdown","57804934":"markdown","51fd529d":"markdown","db58af61":"markdown","d7a27b8d":"markdown","39bd8099":"markdown","bbfd4245":"markdown","9a6c5d77":"markdown","2e7b6fa5":"markdown","7ec8c383":"markdown","8b19f76d":"markdown","b677b25e":"markdown","fb582ca4":"markdown","439ffb86":"markdown","9ba03c6a":"markdown","882c8477":"markdown","16df73d4":"markdown","787665ef":"markdown"},"source":{"2dd8ee13":"import numpy as np \n\n# data in\/out & eda\nimport pandas as pd \nimport pandas_profiling\n\n# visualisations\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go","93877dac":"# let's only read one of the region's power consumptions, to keep this notebook concise\ndf = pd.read_csv('..\/input\/hourly-energy-consumption\/PJME_hourly.csv')\n\n# sort by date & time\ndf['Datetime'] = pd.to_datetime(df['Datetime'])\ndf.sort_values(by=['Datetime'], axis=0, ascending=True, inplace=True)\ndf.reset_index(inplace=True, drop=True)\n\n# renaming the target variable columns\ndf.rename(columns={'PJME_MW':'demand_in_MW'}, inplace=True)\n\n# display the first couple of rows\ndf.head()","c7c631a4":"# deduplicate, only keeping the last measurement per datetime\ndf.drop_duplicates(subset='Datetime', keep='last', inplace=True)","0cd4442a":"df.head()","8ec17092":"# let's see if we have a continuous dataset\ndf = df.set_index('Datetime')\nprint(f'df.index.freq is set to: {df.index.freq}')","26c81456":"# custom range\ndate_range = pd.date_range(start=min(df.index), \n                           end=max(df.index), \n                           freq='H')","06c433d1":"print(f'The difference in length between the custom date range and our dataset is {(len(date_range)-len(df))}:')\nprint(date_range.difference(df.index))","5c941664":"# this will append the previously missing datetimes, and create null values in our target variable\ndf = df.reindex(date_range)\n\n# we fill in the blanks with values that lie on a linear curve between existing data points\ndf['demand_in_MW'].interpolate(method='linear', inplace=True)\n\n# now we have a neatly continuous datetime index\nprint(f'The df.index.freq is now: {df.index.freq}, indicating that we no longer have missing instances')","4d4a11e5":"# see: https:\/\/www.kaggle.com\/robikscube\/starter-hourly-energy-consumption\ndf['dow'] = df.index.dayofweek\ndf['doy'] = df.index.dayofyear\ndf['year'] = df.index.year\ndf['month'] = df.index.month\ndf['quarter'] = df.index.quarter\ndf['hour'] = df.index.hour\ndf['weekday'] = df.index.weekday_name\ndf['woy'] = df.index.weekofyear\ndf['dom'] = df.index.day # Day of Month\ndf['date'] = df.index.date \n\n# let's add the season number\ndf['season'] = df['month'].apply(lambda month_number: (month_number%12 + 3)\/\/3)","031cbe2e":"df.head()","ed86593a":"pandas_profiling.ProfileReport(df)","2382cbef":"# plotly doesn't allow us to access the index, so let's copy it into a column \ndf['date_and_time'] = df.index\n\n# plotting\nfig = px.line(df,\n              x='date_and_time',\n              y='demand_in_MW',\n              title=f'Power Demand (MW) over time [{min(df.year)} - {max(df.year)}]')\nfig.update_traces(line=dict(width=0.05))\nfig.update_layout(xaxis_title='Date & Time (yyyy\/mm\/dd hh:MM)',\n                  yaxis_title='Energy Demand [MW]')\nfig.show()","de8a6603":"# aggregated data\n_ = df\\\n    .groupby(['hour', 'weekday'], as_index=False)\\\n    .agg({'demand_in_MW':'median'})\n\n# plotting\nfig = px.line(_, \n              x='hour', \n              y='demand_in_MW', \n              color='weekday', \n              title='Median Hourly Power Demand per Weekday')\nfig.update_layout(xaxis_title='Hour',\n                  yaxis_title='Energy Demand [MW]')\nfig.show()","3a3ff9bd":"df","2dcc833a":"# aggregated data\n_ = df\\\n    .groupby(['hour', 'season'], as_index=False)\\\n    .agg({'demand_in_MW':'median'})\n\n# plotting\nfig = px.line(_,\n              x='hour', \n              y='demand_in_MW', \n              color='season', \n              title='Median Hourly Power Demand per Season')\nfig.update_layout(xaxis_title='Hour',\n                  yaxis_title='Energy Demand [MW]')\nfig.show()","248c25b9":"from statsmodels.tsa.seasonal import seasonal_decompose\n\n# seasonal_decompose needs a dataframe with a datetime index\nseries = df[['demand_in_MW']]\nfrequency = 24*365\n\n# decomposing the time-series, with the frequency being 24 hours per 365 days\ndecomposed = seasonal_decompose(series, model='additive', freq=frequency)","06d4e27f":"series","84dd3974":"# plotting the different elements constituting our time-series\ndef plot_decompositions(decompositions, titles, line_widths):\n    for d, t, lw in zip(decompositions, titles, line_widths):\n        \n        # draw a line plot of the data\n        fig = px.line(d,\n              y='demand_in_MW',\n              title=t,\n              height=300)\n        \n        # adjust line width\n        fig.update_traces(line=dict(width=lw))\n        \n        # change layout of axes and the figure's margins \n        # to emulate tight_layout\n        fig.update_layout(\n            xaxis=dict(\n                showticklabels=False,\n                linewidth=1\n            ),\n            yaxis=dict(title=''),\n            margin=go.layout.Margin(\n                l=40, r=40, b=0, t=40, pad=0\n            ),\n        )\n        \n        # display\n        fig.show()\n\n# calling the function \nplot_decompositions(decompositions=[decomposed.trend, \n                                    decomposed.seasonal, \n                                    decomposed.resid],\n                    titles=['Trend', \n                            'Seasonality',\n                            'Residuals'],\n                    line_widths=[2, 0.025, 0.05])","15cf435c":"f'The last date time point in our dataframe is: {max(df.index)}'","f23cc862":"# set manually\nCUTOFF_DATE = pd.to_datetime('2017-08-01')\nTIME_DELTA = pd.DateOffset(years=8)\n\n# splitting\ntrain = df.loc[(df.index < CUTOFF_DATE) & (df.index >= CUTOFF_DATE-TIME_DELTA) ].copy()\ntest = df.loc[df.index >= CUTOFF_DATE].copy()","f97b21d5":"TIME_DELTA","677f24c1":"print(f'Training shape: {train.shape} \\nTesting shape: {test.shape}\\n')\nprint(f'The training set lies between the dates: {min(train.index)} and {max(train.index)}')\nprint(f'For the testing set, the dates are: {min(test.index)} and {max(test.index)}')","6e7214aa":"import statsmodels.api as sm\n\n# exponential smoothing only takes into consideration patterns in the target variable\n# so we discard the other features\nexp_smooth_train, exp_smooth_test = train['demand_in_MW'], test['demand_in_MW']\n\n# fit & predict\nholt_winter = sm.tsa.ExponentialSmoothing(exp_smooth_train,\n                                          seasonal_periods=24*365,\n                                          seasonal='add').fit()\ny_hat_holt_winter = holt_winter.forecast(len(exp_smooth_test))","75ecb94e":"def mape(y_true, y_pred):\n    \"\"\" Mean Absolute Percentage Error \"\"\"\n    \n    # convert to numpy arrays\n    y_true, y_pred = np.array(y_true), np.array(y_pred)\n    \n    # take the percentage error\n    pe = (y_true - y_pred) \/ y_true\n    \n    # take the absolute values\n    ape = np.abs(pe)\n    \n    # quantify the performance in a single number\n    mape = np.mean(ape)\n    \n    return f'{mape*100:.2f}%'","63c108e9":"# https:\/\/facebook.github.io\/prophet\/docs\/quick_start.html#python-api\nfrom fbprophet import Prophet\nfrom fbprophet.diagnostics import cross_validation","769d1ec0":"# format data for prophet model using 'ds' and 'y'\ntrain_prophet = train[['demand_in_MW']]\\\n                    .reset_index()\\\n                    .rename(columns={\n                        'index':'ds', \n                        'demand_in_MW':'y'\n                    })\n\ntest_prophet = test[['demand_in_MW']]\\\n                    .reset_index()\\\n                    .rename(columns={\n                        'index':'ds',\n                        'demand_in_MW':'y'\n                    })","64f1fb34":"# conditions\ndef is_spring(ds):\n    date = pd.to_datetime(ds)\n    return (date.month >= 3) & (date.month <= 5)\n\ndef is_summer(ds):\n    date = pd.to_datetime(ds)\n    return (date.month >= 6) & (date.month <= 8)\n\ndef is_autumn(ds):\n    date = pd.to_datetime(ds)\n    return (date.month >= 9) & (date.month <= 11)\n\ndef is_winter(ds):\n    date = pd.to_datetime(ds)\n    return (date.month >= 12) | (date.month <= 2)\n\ndef is_weekend(ds):\n    date = pd.to_datetime(ds)\n    return date.weekday_name in ('Saturday', 'Sunday')\n\n# adding to train set\ntrain_prophet['is_spring'] = train_prophet['ds'].apply(is_spring)\ntrain_prophet['is_summer'] = train_prophet['ds'].apply(is_summer)\ntrain_prophet['is_autumn'] = train_prophet['ds'].apply(is_autumn)\ntrain_prophet['is_winter'] = train_prophet['ds'].apply(is_winter)\ntrain_prophet['is_weekend'] = train_prophet['ds'].apply(is_weekend)\ntrain_prophet['is_weekday'] = ~train_prophet['ds'].apply(is_weekend)\n\n# adding to test set\ntest_prophet['is_spring'] = test_prophet['ds'].apply(is_spring)\ntest_prophet['is_summer'] = test_prophet['ds'].apply(is_summer)\ntest_prophet['is_autumn'] = test_prophet['ds'].apply(is_autumn)\ntest_prophet['is_winter'] = test_prophet['ds'].apply(is_winter)\ntest_prophet['is_weekend'] = test_prophet['ds'].apply(is_weekend)\ntest_prophet['is_weekday'] = ~test_prophet['ds'].apply(is_weekend)","b1530ac3":"# instantiating the class with custom settings, for the sake of illustration\nprophet = Prophet(\n     daily_seasonality=False,\n    weekly_seasonality=False,\n    yearly_seasonality=False\n)\n\n# custom seasonalities to account for conditional variance \n# (more extreme trends in extreme seasons)\nprophet.add_seasonality(name='yearly', period=365.25, fourier_order=10)\nprophet.add_seasonality(name='weekly_spring', \n                        period=7,\n                        fourier_order=5, \n                        condition_name='is_spring')\nprophet.add_seasonality(name='weekly_summer', \n                        period=7,\n                        fourier_order=5, \n                        condition_name='is_summer')\nprophet.add_seasonality(name='weekly_autumn', \n                        period=7,\n                        fourier_order=5, \n                        condition_name='is_autumn')\nprophet.add_seasonality(name='weekly_winter', \n                        period=7,\n                        fourier_order=5, \n                        condition_name='is_winter')\nprophet.add_seasonality(name='daily_spring',  \n                        period=1,\n                        fourier_order=5, \n                        condition_name='is_spring')\nprophet.add_seasonality(name='daily_summer',  \n                        period=1,\n                        fourier_order=5, \n                        condition_name='is_summer')\nprophet.add_seasonality(name='daily_autumn',  \n                        period=1,\n                        fourier_order=5, \n                        condition_name='is_autumn')\nprophet.add_seasonality(name='daily_winter',  \n                        period=1,\n                        fourier_order=5, \n                        condition_name='is_winter')\nprophet.add_seasonality(name='daily_weekend',  \n                        period=1,\n                        fourier_order=5, \n                        condition_name='is_weekend')\nprophet.add_seasonality(name='daily_weekday',  \n                        period=1,\n                        fourier_order=5, \n                        condition_name='is_weekday')\n\n# account for holidays\n#prophet.add_country_holidays(country_name='US')\n\n# fitting the model\nprophet.fit(train_prophet);\n\n# part of the dataframe on which we want to make predictions\nfuture = test_prophet.drop(['y'], axis=1)\n\n# predicting values\nforecast = prophet.predict(future)\n\n# see https:\/\/github.com\/facebook\/prophet\/issues\/999 for the matplotlib_converts()\npd.plotting.register_matplotlib_converters()\n\n# plotting the seasonality components found\n_ = prophet.plot_components(forecast)","95f1d7ef":"forecast","d9da33fe":"# create figure\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=test_prophet.ds, y=test_prophet.y,\n                         mode='lines',\n                         name='Test - Ground Truth'))\nfig.add_trace(go.Scatter(x=forecast.ds, y=forecast.yhat,\n                         mode='lines', \n                         name='Test - Prediction'))\n\n# adjust layout\nfig.update_traces(line=dict(width=0.5))\nfig.update_layout(title='Prophet Forecast of Hourly Energy Demand',\n                  xaxis_title='Date & Time (yyyy\/mm\/dd hh:MM)',\n                  yaxis_title='Energy Demand [MW]')\nfig.show()\n\n# quantify accuracy\nprint(f'MAPE for Prophet\\'s predictions: {mape(test_prophet.y, forecast.yhat)}')","0fc59c78":"# interval length\ninterval = 24 * 7\n\n# intermediary variables for readability\nx_true, y_true = test_prophet.iloc[:interval].ds, test_prophet.iloc[:interval].y\nx_pred, y_pred = forecast.iloc[:interval].ds, forecast.iloc[:interval].yhat\n\n# create figure\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=x_true, y=y_true,\n                         mode='lines',\n                         name='Test - Ground Truth'))\nfig.add_trace(go.Scatter(x=x_pred, y=y_pred,\n                         mode='lines', \n                         name='Test - Prediction'))\n\n# adjust layout\nfig.update_traces(line=dict(width=0.9))\nfig.update_layout(title=f'Prophet Intra-Day Forecast of First {interval} Hours of Energy Demand',\n                  xaxis_title='Date & Time (yyyy\/mm\/dd hh:MM)',\n                  yaxis_title='Energy Demand [MW]')\nfig.show()\n\n# quantify accuracy\nprint(f'MAPE for interval of the first {interval} hours: {mape(y_true, y_pred)}')","30564edd":"# interval length\ninterval = -24 * 7\n\n# intermediary variables for readability\nx_true, y_true = test_prophet.iloc[interval:].ds, test_prophet.iloc[interval:].y\nx_pred, y_pred = forecast.iloc[interval:].ds, forecast.iloc[interval:].yhat\n\n# create figure\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=x_true, y=y_true,\n                         mode='lines',\n                         name='Test - Ground Truth'))\nfig.add_trace(go.Scatter(x=x_pred, y=y_pred,\n                         mode='lines', \n                         name='Test - Prediction'))\n\n# adjust layout\nfig.update_traces(line=dict(width=0.9))\nfig.update_layout(title=f'Prophet Intra-Day Forecast of Last {abs(interval)} Hours of Energy Demand',\n                  xaxis_title='Date & Time (yyyy\/mm\/dd hh:MM)',\n                  yaxis_title='Energy Demand [MW]')\nfig.show()\n\n# quantify accuracy\nprint(f'MAPE for interval of the last {abs(interval)} hours: {mape(y_true, y_pred)}')","48e5cfb7":"<a id=\"6\"><\/a> <br>\n# Decomposing the Time-Series\nData points over time can be interesting in the sense that their patterns are complemented by a trend (upward or downward) and\/or seasonality.\nAs we have established in our EDA, these aspects seem to play a role in this dataset.\n\nBecause the seasonal variation in our dataset looks constant over time, we will use the additive model for decomposition (as opposed to the multiplicative model, which is useful for cases where seasonal variation increases over time).","30b2e7db":"## Date & Time Patterns\nWe can use our previously extracted date and time features to see if recurring patterns emerge from aggregated data.\nTake, for instance, the power demand throughout the day for each weekday:","630e6b65":"## Find and Fill Missing DateTime Instances","fda9a1d5":"Looks like those air conditioners are cranked up during summer!","57804934":"<a id=\"2\"><\/a> <br>\n# Cleaning the dataset \n\n## Deduplicating","51fd529d":"<a id=\"10\"><\/a> <br>\n# Conclusion \n* Holt-Winter seems to capture more of the erraticness, but mistakes it for being a trend. It is not immediately obvious how to fine tune it.\n* Prophet, on the other hand, seems more consistent. It gives us much more insight and flexibility, offering a great baseline on which to improve.\n\nIncorporating weather forecast data is the obvious next step towards improving our predictive performance.","db58af61":"As before, let's zoom in on some intra-day predictions at the beginning and at the end of the forecasting period.","d7a27b8d":"We can definitely identify a seasonal pattern here. Counter-intuitively, though, no immediately apparent trend.","39bd8099":"The correlation matrix indicates the variables \"dow\" (day of week) and \"hour\" will be interesting to look at in the context of predicting our target variable.","bbfd4245":"<a id=\"3\"><\/a> <br>\n# Extracting Time Features\nWe can split up the date-timestamp column into its different components.\nThis will allow us to find patterns for different groups.","9a6c5d77":"The fact our datetime index's frequency is set to None is an indication there are some missing data points somewhere (otherwise Python could deduce it). Let's compare it to an uninterruped custom date range.","2e7b6fa5":"<a id=\"9\"><\/a> <br>\n# Prophet\n\n\\begin{eqnarray}\n\\mbox{Forecasting Equation}: \\\\\ny(t) & = & g(t) + s(t) + h(t) + \u03b5t \\\\\n&& \\\\\n\\mbox{Where}: \\\\\ng(t) & : & \\mbox{piecewise linear or logistic growth curve for modelling non-periodic changes in time series} \\\\\ns(t) & : & \\mbox{periodic changes (e.g. weekly\/yearly seasonality)} \\\\\nh(t) & : & \\mbox{effects of holidays (user provided) with irregular schedules} \\\\\n\u03b5t & : & \\mbox{error term accounts for any unusual changes not accommodated by the model} \\\\\n\\end{eqnarray}\n\nDelve deeper into the math with [this article](https:\/\/medium.com\/future-vision\/the-math-of-prophet-46864fa9c55a).\n<br>\n\nAn adept name for a model designed to predict time-series. It was developed by Facebook and [released as open source](https:\/\/github.com\/facebook\/prophet) in 2017.\nIt is distinct in the fact that it explicitly lets the user account for and configure seasonalities at multiple frequencies.\n\nAs the mathheads (not to be confused with methheads) amongst us surely know, we can do this by exploiting the nature of Fourier series: Breaking down a function of real numbers into a sum of sine waves. \nThe Prophet documentation has [a section](https:\/\/facebook.github.io\/prophet\/docs\/seasonality,_holiday_effects,_and_regressors.html#fourier-order-for-seasonalities) dedicated to fine-tuning the order of the fourier series for seasonalities. In summary:\n* A **higher order** fits the sine wave more closely to the seasonality in the data, at the risk of capturing too much of the noise (overfitting).\n* A **lower order** smoothes out the noise, at the risk of not capturing enough of the seasonality (underfitting).\n\nA good, general fit lies in between. We will try to find this by employing Prophet's built-in cross-validation method.\n\nIf you want to learn more about Fourier series, do check out the amazing Grant Sanderson's \"[But what is a Fourier series? From heat flow to circle drawings](https:\/\/www.youtube.com\/watch?v=r6sGWTCMz2k)\" on YouTube. Below is one of his many gorgeous visualisations, illustrating the additive concept of sine waves in the context of heat equations:\n![3Brown1Blue](https:\/\/i.imgur.com\/hu8hEpl.png)","7ec8c383":"<a id=\"top\"><\/a> <br>\n## Goal Setting\n\nThe objective of this kernel is primarily to illustrate concepts that are relevant to the forecasting of time-series data.\nIn particular, we touch on the topics of trends, (conditional and multiple) seasonalities, and - briefly - fourier series. \n\nWe compare two forecasting models: Holt-Winter and Facebook's Prophet algorithms. We demonstrate how the latter allows the user to taylor the algorithm to the dataset's particular needs.\n\n# Table of Contents\n1. [Load Dataset](#1)\n1. [Cleaning The Dataset](#2)\n<br><span style=\"font-size: 10px\">Deduplicating, filling missing values<\/span>\n1. [Extracting Time Features](#3)\n<br><span style=\"font-size: 10px\"> Use as much as we can from the datetime stamp<\/span>\n1. [EDA](#4)\n<br><span style=\"font-size: 10px\"> Analyse the distribution and correlation of variables, amongst others<\/span>\n1. [Quick Visuals](#5)\n<br><span style=\"font-size: 10px\"> Following the light shed by the EDA, illustrate some of the data's patterns <\/span>\n1. [Decomposing The Time-Series](#6)\n<br><span style=\"font-size: 10px\"> Gradually working our way towards forecasting models, we illustrate how time-series function can be seen as a sum of trend, seasonality, and noise<\/span>\n1. [Forecasting Models](#7)\n<br><span style=\"font-size: 10px\"> Predicting future energy demand, presenting two models<\/span>\n1. [Holt-Winter](#8)\n<br><span style=\"font-size: 10px\"> A somewhat naive, but remarkably powerful method<\/span>\n1. [Prophet](#9)\n<br><span style=\"font-size: 10px\"> Our model of choice to illustrate the concept of multi- as well as conditional seasonality<\/span>\n1. [Conclusion](#10)\n<br><span style=\"font-size: 10px\"> Summarizing insights gathered from the forecasting models, touching on avenues that could lead to further improvements<\/span>\n","8b19f76d":"Let's reindex our dataset and then perform imputation.","b677b25e":"## Conditional Seasonalities\nAs stated in the [documentation](https:\/\/facebook.github.io\/prophet\/docs\/seasonality,_holiday_effects,_and_regressors.html#seasonalities-that-depend-on-other-factors):\n> In some instances the seasonality may depend on other factors, such as a weekly seasonal pattern that is different during the summer than it is during the rest of the year, or a daily seasonal pattern that is different on weekends vs. on weekdays. These types of seasonalities can be modeled using conditional seasonalities.\n\nFrom our EDA, we could tell that the variance in the daily seasonality is higher in Winter and Summer. Not coincidentally, these are the seasons where the absolute difference in ambient temperature vs. desired temperature is greatest. Let's try to break down the patterns in our data to account for such interdependent variability.","fb582ca4":"<a id=\"1\"><\/a> <br>\n# Load Dataset","439ffb86":"<a id=\"4\"><\/a> <br>\n# EDA\nA quick one-liner with pandas_profiling to get an overview of our dataset","9ba03c6a":"<a id=\"5\"><\/a> <br>\n# Quick Visuals\n\n### Plotting the energy consumption over time","882c8477":"<a id=\"7\"><\/a> <br>\n# Forecasting Models\nWe will look at the following methods:\n* Triple Exponential Smoothing: Holt-Winter's \n* Explicit Multi-Seasonality: Prophet\n\n## Train\/Test\nLet's make it our goal to accurately predict up to 12 month's worth of energy demand.\nWe will also restrict our training data to a couple of years leading up to that, to make sure we don't capture any outdated trends (industry shifts).\nThis doesn't seem to be the case, judging from our prior visualisations, but it will keep our computational load low and allow us to iterate over models more quickly.","16df73d4":"### Library Imports","787665ef":"We can quickly tell demand for electricity is lower during the weekends, and dips a little sooner on friday afternoons."}}