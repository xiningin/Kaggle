{"cell_type":{"4d92688f":"code","32c5d72e":"code","50557c2e":"code","c78c6b54":"code","8c35009f":"code","144c64f9":"code","66575f8d":"code","018025b0":"code","09784411":"code","3e8ce729":"code","30c6fdfb":"code","31282350":"code","9820a9b8":"code","a36966a7":"code","b0bec066":"code","6fad06ed":"markdown","336aa610":"markdown","3cc41839":"markdown","b509832d":"markdown","60b5f66e":"markdown","c2e056b6":"markdown"},"source":{"4d92688f":"# General imports\nimport numpy as np\nimport pandas as pd\nimport os, sys, gc, warnings, random, datetime\n\nfrom sklearn import metrics\nfrom sklearn.preprocessing import LabelEncoder\n\nfrom tqdm import tqdm\nimport lightgbm as lgb\n\nimport math\nwarnings.filterwarnings('ignore')","32c5d72e":"########################### Helpers\n#################################################################################\n## Seeder\n# :seed to make all processes deterministic     # type: int\ndef seed_everything(seed=0):\n    random.seed(seed)\n    np.random.seed(seed)","50557c2e":"########################### Vars\n#################################################################################\nSEED = 42\nseed_everything(SEED)\nTARGET = 'isFraud'\nSTART_DATE = datetime.datetime.strptime('2017-11-30', '%Y-%m-%d')","c78c6b54":"########################### Model params\n# These parameters we will keep untouched\n# for each lgbm model\n# the unique param that we will look at\n# is n_estimators\nlgb_params = {\n                    'objective':'binary',\n                    'boosting_type':'gbdt',\n                    'metric':'auc',\n                    'n_jobs':-1,\n                    'learning_rate':0.01,\n                    'num_leaves': 2**8,\n                    'max_depth':-1,\n                    'tree_learner':'serial',\n                    'colsample_bytree': 0.7,\n                    'subsample_freq':1,\n                    'subsample':0.7,\n                    'n_estimators':20000,\n                    'max_bin':255,\n                    'verbose':-1,\n                    'seed': SEED,\n                    'early_stopping_rounds':100, \n                } ","8c35009f":"########################### DATA LOAD\n#################################################################################\nprint('Load Data')\ntrain_df = pd.read_pickle('..\/input\/ieee-data-minification\/train_transaction.pkl')\n\n# We will prepare simulation here\n# Last month will be our test test \ntrain_df['DT_M'] = train_df['TransactionDT'].apply(lambda x: (START_DATE + datetime.timedelta(seconds = x)))\ntrain_df['DT_M'] = (train_df['DT_M'].dt.year-2017)*12 + train_df['DT_M'].dt.month \n\ntest_df = train_df[train_df['DT_M']==train_df['DT_M'].max()].reset_index(drop=True)\ntrain_df = train_df[train_df['DT_M']<(train_df['DT_M'].max()-1)].reset_index(drop=True)\n    \nprint('Shape control:', train_df.shape, test_df.shape)","144c64f9":"########################### Encode Str columns\n# For all such columns (probably not)\n# we already did frequency encoding (numeric feature)\n# so we will use astype('category') here\nfor col in list(train_df):\n    if train_df[col].dtype=='O':\n        print(col)\n        train_df[col] = train_df[col].fillna('unseen_before_label')\n        test_df[col]  = test_df[col].fillna('unseen_before_label')\n        \n        train_df[col] = train_df[col].astype(str)\n        test_df[col] = test_df[col].astype(str)\n        \n        le = LabelEncoder()\n        le.fit(list(train_df[col])+list(test_df[col]))\n        train_df[col] = le.transform(train_df[col])\n        test_df[col]  = le.transform(test_df[col])\n        \n        train_df[col] = train_df[col].astype('category')\n        test_df[col] = test_df[col].astype('category')","66575f8d":"########################### Model Features \n# Remove Some Features\nrm_cols = [\n    'TransactionID','TransactionDT', # These columns are pure noise right now\n    TARGET,                          # Not target in features))\n    'DT_M'                           # Column that we used to simulate test set\n]\n\n# Remove V columns (for faster training)\nrm_cols += ['V'+str(i) for i in range(1,340)]\n\n# Final features\nfeatures_columns = [col for col in list(train_df) if col not in rm_cols]\n\n## Baseline LB score is 0.9360","018025b0":"## Let's creat dataframe to compare results\n## We will join prepdictions\nRESULTS = test_df[['TransactionID',TARGET]]\n\n# We will always use same number of splits\n# for training model\n# Number of splits depends on data structure\n# and in our case it is better to use \n# something in range 5-10\n# 5 - is a common number of splits\n# 10+ is too much (we will not have enough diversity in data)\n# Here we will use 3 for faster training\n# but you can change it by yourself\nN_SPLITS = 3","09784411":"# Main Data\n# We will take whole train data set\n# and will NOT use any early stopping \nX,y = train_df[features_columns], train_df[TARGET]\n\n# Test Data (what we need to predict)\nP = test_df[features_columns]\n\n# We don't know where to stop\n# so we will try to guess \n# number of boosting rounds\nfor n_rounds in [500,1000,2500,5000]:\n    print('#'*20)\n    print('No Validation training...', n_rounds, 'boosting rounds')\n    corrected_lgb_params = lgb_params.copy()\n    corrected_lgb_params['n_estimators'] = n_rounds\n    corrected_lgb_params['early_stopping_rounds'] = None\n\n    train_data = lgb.Dataset(X, label=y)\n    \n    estimator = lgb.train(\n                corrected_lgb_params,\n                train_data\n            )\n\n    RESULTS['no_validation_'+str(n_rounds)] = estimator.predict(P)\n    print('AUC score', metrics.roc_auc_score(RESULTS[TARGET], RESULTS['no_validation_'+str(n_rounds)]))\n    print('#'*20)\n\n# Be careful. We are printing auc results\n# for our simulated test set\n# but in real Data set we do not have True labels (obviously)\n# and can't be sure that we stopped in right round\n# lb probing can give you some idea how good our training is\n# but this leads to nowhere -> overfits or completely bad results\n# bad practice for real life problems!","3e8ce729":"print('#'*20)\nprint('KFold training...')\n\n# You can find oof name for this strategy\n# oof - Out Of Fold\n# as we will use one fold as validation\n# and stop training when validation metric\n# stops improve\nfrom sklearn.model_selection import KFold\nfolds = KFold(n_splits=N_SPLITS, shuffle=True, random_state=SEED)\n\n# Main Data\nX,y = train_df[features_columns], train_df[TARGET]\n\n# Test Data\nP = test_df[features_columns]\nRESULTS['kfold'] = 0\n\nfor fold_, (trn_idx, val_idx) in enumerate(folds.split(X, y)):\n    print('Fold:',fold_+1)\n    tr_x, tr_y = X.iloc[trn_idx,:], y[trn_idx]    \n    vl_x, v_y = X.iloc[val_idx,:], y[val_idx]    \n    train_data = lgb.Dataset(tr_x, label=tr_y)\n    valid_data = lgb.Dataset(vl_x, label=v_y)  \n\n    estimator = lgb.train(\n            lgb_params,\n            train_data,\n            valid_sets = [train_data, valid_data],\n            verbose_eval = 1000,\n        )\n\n    RESULTS['kfold'] = estimator.predict(P)\n\nprint('AUC score', metrics.roc_auc_score(RESULTS[TARGET], RESULTS['kfold']))\nprint('#'*20)\n    \n## We have two \"problems\" here\n## 1st: Training score goes upto 1 and it's not normal situation\n## It's nomally means that model did perfect or\n## almost perfect match between \"data fingerprint\" and target\n## we definitely should stop before to generalize better\n## 2nd: Our LB probing gave 0.936 and it is too far away from validation score\n## some difference is normal, but such gap is too big","30c6fdfb":"print('#'*20)\nprint('StratifiedKFold training...')\n\n# Same as normal kfold but we can be sure\n# that our target is perfectly distribuited\n# over folds\nfrom sklearn.model_selection import StratifiedKFold\nfolds = StratifiedKFold(n_splits=N_SPLITS, shuffle=True, random_state=SEED)\n\n# Main Data\nX,y = train_df[features_columns], train_df[TARGET]\n\n# Test Data and expport DF\nP = test_df[features_columns]\nRESULTS['stratifiedkfold'] = 0\n\nfor fold_, (trn_idx, val_idx) in enumerate(folds.split(X, y, groups=y)):\n    print('Fold:',fold_+1)\n    tr_x, tr_y = X.iloc[trn_idx,:], y[trn_idx]    \n    vl_x, v_y = X.iloc[val_idx,:], y[val_idx]    \n    train_data = lgb.Dataset(tr_x, label=tr_y)\n    valid_data = lgb.Dataset(vl_x, label=v_y)  \n\n    estimator = lgb.train(\n            lgb_params,\n            train_data,\n            valid_sets = [train_data, valid_data],\n            verbose_eval = 1000,\n        )\n\n    # we are not sure what fold is best for us\n    # so we will average prediction results \n    # over folds\n    RESULTS['stratifiedkfold'] += estimator.predict(P)\/N_SPLITS\n\nprint('AUC score', metrics.roc_auc_score(RESULTS[TARGET], RESULTS['stratifiedkfold']))\nprint('#'*20)\n\n## We have same \"problems\" here as in normal kfold\n## 1st: Training score goes upto 1 and it's not normal situation\n## we definitely should stop before \n## 2nd: Our LB probing gave 0.936 and it is too far away from validation score\n## some difference is normal, but such gap is too big","31282350":"print('#'*20)\nprint('LBO training...') \n\n## We need Divide Train Set by Time blocks\n## Convert TransactionDT to Months\n## And use last month as Validation\ntrain_df['DT_M'] = train_df['TransactionDT'].apply(lambda x: (START_DATE + datetime.timedelta(seconds = x)))\ntrain_df['DT_M'] = (train_df['DT_M'].dt.year-2017)*12 + train_df['DT_M'].dt.month \n\nmain_train_set = train_df[train_df['DT_M']<(train_df['DT_M'].max())].reset_index(drop=True)\nvalidation_set = train_df[train_df['DT_M']==train_df['DT_M'].max()].reset_index(drop=True)\n\n## We will use oof kfold to find \"best round\"\nfolds = KFold(n_splits=N_SPLITS, shuffle=True, random_state=SEED)\n\n# Main Data\nX,y = main_train_set[features_columns], main_train_set[TARGET]\n\n# Validation Data\nv_X, v_y = validation_set[features_columns], validation_set[TARGET]\n\nestimators_bestround = []\nfor fold_, (trn_idx, val_idx) in enumerate(folds.split(X, y)):\n    print('Fold:',fold_+1)\n    tr_x, tr_y = X.iloc[trn_idx,:], y[trn_idx]    \n    train_data = lgb.Dataset(tr_x, label=tr_y)\n    valid_data = lgb.Dataset(v_X, label=v_y)  \n\n    seed_everything(SEED)\n    estimator = lgb.train(\n            lgb_params,\n            train_data,\n            valid_sets = [train_data, valid_data],\n            verbose_eval = 1000,\n        )\n    estimators_bestround.append(estimator.current_iteration())\n\n## Now we have \"mean Best round\" and we can train model on full set\ncorrected_lgb_params = lgb_params.copy()\ncorrected_lgb_params['n_estimators'] = int(np.mean(estimators_bestround))\ncorrected_lgb_params['early_stopping_rounds'] = None\nprint('#'*10)\nprint('Mean Best round:', corrected_lgb_params['n_estimators'])\n\n# Main Data\nX,y = train_df[features_columns], train_df[TARGET]\n\n# Test Data\nP = test_df[features_columns]\nRESULTS['lbo'] = 0\n\nfor fold_, (trn_idx, val_idx) in enumerate(folds.split(X, y)):\n    print('Fold:',fold_+1)\n    tr_x, tr_y = X.iloc[trn_idx,:], y[trn_idx]\n    train_data = lgb.Dataset(tr_x, label=tr_y)\n\n    estimator = lgb.train(\n            corrected_lgb_params,\n            train_data\n        )\n    \n    RESULTS['lbo'] += estimator.predict(P)\/N_SPLITS\n\nprint('AUC score', metrics.roc_auc_score(RESULTS[TARGET], RESULTS['lbo']))\nprint('#'*20)   ","9820a9b8":"print('#'*20)\nprint('GroupKFold timeblocks split training...') \n\nfrom sklearn.model_selection import GroupKFold\nfolds = GroupKFold(n_splits=N_SPLITS)\n\n## We need Divide Train Set by Time blocks\n## Convert TransactionDT to Months\ntrain_df['groups'] = train_df['TransactionDT'].apply(lambda x: (START_DATE + datetime.timedelta(seconds = x)))\ntrain_df['groups'] = (train_df['groups'].dt.year-2017)*12 + train_df['groups'].dt.month \n\n# Main Data\nX,y = train_df[features_columns], train_df[TARGET]\nsplit_groups = train_df['groups']\n\n# Test Data and expport DF\nP = test_df[features_columns]\nRESULTS['groupkfold_timeblocks'] = 0\n\nfor fold_, (trn_idx, val_idx) in enumerate(folds.split(X, y, groups=split_groups)):\n    print('Fold:',fold_+1)\n    tr_x, tr_y = X.iloc[trn_idx,:], y[trn_idx]    \n    vl_x, v_y = X.iloc[val_idx,:], y[val_idx]    \n    train_data = lgb.Dataset(tr_x, label=tr_y)\n    valid_data = lgb.Dataset(vl_x, label=v_y)  \n\n    estimator = lgb.train(\n            lgb_params,\n            train_data,\n            valid_sets = [train_data, valid_data],\n            verbose_eval = 1000,\n        )\n\n    RESULTS['groupkfold_timeblocks'] += estimator.predict(P)\/N_SPLITS\n\nprint('AUC score', metrics.roc_auc_score(RESULTS[TARGET], RESULTS['groupkfold_timeblocks']))\nprint('#'*20)","a36966a7":"print('#'*20)\nprint('GroupKFold uID split training...') \n\nfrom sklearn.model_selection import GroupKFold\nfolds = GroupKFold(n_splits=N_SPLITS)\n\n## We need Divide Train Set by virtual client ID\n## If we do everuthing well\n## (I'm not sure that this columns are good ones\n## 'card1','card2','card3','card5','addr1','addr2')\n## our model will not have \"personal client information\"\n## shared by folds\n\ntrain_df['groups'] = ''\nfor col in ['card1','card2','card3','card5','addr1','addr2',]:\n    train_df['groups'] = '_' + train_df[col].astype(str)\n    \n# Main Data\nX,y = train_df[features_columns], train_df[TARGET]\nsplit_groups = train_df['groups']\n\n# Test Data and expport DF\nP = test_df[features_columns]\nRESULTS['groupkfold_uid'] = 0\n\nfor fold_, (trn_idx, val_idx) in enumerate(folds.split(X, y, groups=split_groups)):\n    print('Fold:',fold_+1)\n    tr_x, tr_y = X.iloc[trn_idx,:], y[trn_idx]    \n    vl_x, v_y = X.iloc[val_idx,:], y[val_idx]    \n    train_data = lgb.Dataset(tr_x, label=tr_y)\n    valid_data = lgb.Dataset(vl_x, label=v_y)  \n\n    estimator = lgb.train(\n            lgb_params,\n            train_data,\n            valid_sets = [train_data, valid_data],\n            verbose_eval = 1000,\n        )\n\n    RESULTS['groupkfold_uid'] += estimator.predict(P)\/N_SPLITS\n\nprint('AUC score', metrics.roc_auc_score(RESULTS[TARGET], RESULTS['groupkfold_uid']))\nprint('#'*20)","b0bec066":"print('#'*30)\nprint('Final results...')\nfinal_df = []\nfor current_strategy in list(RESULTS.iloc[:,2:]):\n    auc_score = metrics.roc_auc_score(RESULTS[TARGET], RESULTS[current_strategy])\n    final_df.append([current_strategy, auc_score])\n    \nfinal_df = pd.DataFrame(final_df, columns=['Stategy', 'Result'])\nfinal_df.sort_values(by=['Result'], ascending=False, inplace=True)\nprint(final_df)","6fad06ed":"----\n## No Validation","336aa610":"----\n## Kfold","3cc41839":"----\n## GroupKFold\n> The folds are approximately balanced in the sense that the number of distinct groups is approximately the same in each fold.\n\nWhy we may use it?\nLet's imagine that we want to separate train data by time blocks groups or client IDs or something else.\nWith GroupKFold we can be sure that our validation fold will contain groupIDs that are not in main train set.\nSometimes it helps to deal with \"dataleakage\" and overfit.","b509832d":"----\n## StratifiedKFold\nThere are situations when normal kfold split doesn't perform well because of train set imbalance.\nWe can use StratifiedKFold to garant that each split will have same number of positives and negatives samples.","60b5f66e":"----\n## LBO (last block out)\nFor Time series data (what we have here) we can use (sometimes) last Time block as validation subset and track mean early stopping round.\n\nLet's code it.","c2e056b6":"## CV concept\n\n### Basics\n\n> Cross-validation is a technique for evaluating ML models \n> by training several ML models on subsets of the available \n> input data and evaluating them on the complementary \n> subset of the data. \n\n> In k-fold cross-validation, you split the input data \n> into k subsets of data (also known as folds).\n\n\n### Main strategy\n1. Divide Train set in subsets (Training set itself + Validation set)\n2. Define Validation Metric (in our case it is ROC-AUC)\n3. Stop training when Validation metric stops improving\n4. Make predictions for Test set\n\nSeems simple but he devil's always in the details."}}