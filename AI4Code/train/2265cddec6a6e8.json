{"cell_type":{"af6f16cc":"code","1d9716d7":"code","52dcbcd2":"code","f5e24b8e":"code","39d950eb":"code","2502dceb":"code","dde1986f":"code","842e2cce":"code","df998614":"code","c7729982":"code","4b38fcab":"code","dec6a574":"code","03a14043":"code","b4cb66cd":"markdown","d4ca0999":"markdown","e67385d8":"markdown","54312759":"markdown","57216e2c":"markdown"},"source":{"af6f16cc":"import numpy as np\nimport pandas as pd","1d9716d7":"import time\nimport warnings\nwarnings.simplefilter(action = 'ignore')","52dcbcd2":"import csv","f5e24b8e":"general_columns = ['object_id', 'count']\nmean_columns = ['mjd', 'flux', 'flux_err', 'detected']\nvar_columns = ['mjd', 'flux', 'flux_err']","39d950eb":"all_columns = general_columns + \\\n              [c + '_all_mean' for c in mean_columns] + \\\n              [c + '_pb' + str(pb) + '_mean' for pb in range(6) for c in mean_columns] + \\\n              [c + '_all_var' for c in var_columns] + \\\n              [c + '_pb' + str(pb) + '_var' for pb in range(6) for c in var_columns]\nall_columns","2502dceb":"# auxiliary function for accumulating sum of values and sum of values squares by passbands\n# indexes correspond to positions of fields in source datasets\ndef convert_row(row):\n    current_id = int(row[0])\n    current_pb = int(row[2])\n    return current_id, current_pb, [1,                                 # count\n                                    float(row[1]), float(row[1]) ** 2, # mjd\n                                    float(row[3]), float(row[3]) ** 2, # flux\n                                    float(row[4]), float(row[4]) ** 2, # flux_err\n                                    int(row[5])]                       # detected","dde1986f":"# auxiliary function for calculating means and vars for one object including by passbands\n# rows_dict - dictionary for one object with passbands as keys and sum of convert_row's result as values\n# indexes correspond to positions of fields in convert_row's output\ndef estimate_means_vars(rows_dict):\n    values = np.array(list(rows_dict.values()))\n    all_count = sum(values[:, 0])\n    all_means = [\n                sum(values[:, 1]) \/ all_count, # mjd\n                sum(values[:, 3]) \/ all_count, # flux\n                sum(values[:, 5]) \/ all_count, # flux_err\n                sum(values[:, 7]) \/ all_count  # detected\n    ]\n    # Var(X) = E(X^2) - (E(X))^2\n    all_vars = [\n                sum(values[:, 2]) \/ all_count - all_means[0] ** 2, # mjd\n                sum(values[:, 4]) \/ all_count - all_means[1] ** 2, # flux\n                sum(values[:, 6]) \/ all_count - all_means[2] ** 2  # flux_err\n    ]\n    for pb in range(6):\n        values = rows_dict[pb]\n        count = values[0]\n        pb_means = [\n                values[1] \/ count,\n                values[3] \/ count,\n                values[5] \/ count,\n                values[7] \/ count\n        ]\n        all_means += pb_means\n        pb_vars = [\n                values[2] \/ count - pb_means[0] ** 2, \n                values[4] \/ count - pb_means[1] ** 2, \n                values[6] \/ count - pb_means[2] ** 2 \n        ]\n        all_vars += pb_vars\n        \n    return [all_count] + all_means + all_vars","842e2cce":"# main function for aggregating dataset from file to file\ndef aggregate_file(in_file_name, out_file_name, out_columns, verbose = -1):\n    with open(in_file_name, mode = 'r') as in_file, \\\n         open(out_file_name, mode = 'a') as out_file:\n\n        # open reader and skip header\n        reader = csv.reader(in_file)\n        next(reader, None)\n    \n        # open writer and write new header\n        csv.register_dialect('lineterminator', lineterminator = '\\n')\n        writer = csv.writer(out_file, 'lineterminator')\n        writer.writerow(out_columns)\n    \n        current_id = None\n        \n        # loop through rows in reader\n        for i, row in enumerate(reader):\n            curr_id, curr_pb, agg_row = convert_row(row)\n        \n            # the same object\n            if current_id == curr_id:\n                # passband found\n                if curr_pb in current_agg_rows.keys():\n                    current_agg_rows[curr_pb] = [i + j for i, j in zip(current_agg_rows[curr_pb], agg_row)]\n                # new passband\n                else:\n                    current_agg_rows[curr_pb] = agg_row\n                \n            # the new object\n            else:\n                # save previous object if exist\n                if not current_id is None:\n                    # calculate estimates of mean and var for previous object\n                    final_row = estimate_means_vars(current_agg_rows)\n                    writer.writerow([current_id] + final_row)\n                # start new object\n                current_id, current_pb = curr_id, curr_pb\n                current_agg_rows = {}\n                current_agg_rows[current_pb] = agg_row\n                \n            # verbose\n            if (verbose > 0) and (i % verbose == 0):\n                print('Row:', i, time.ctime())\n            \n        # save the last object if exist\n        if not current_id is None:\n            # calculate estimates of mean and var for the last object\n            final_row = estimate_means_vars(current_agg_rows)\n            writer.writerow([current_id] + final_row)","df998614":"%%time\naggregate_file('..\/input\/training_set.csv', 'agg_training_set.csv', all_columns)","c7729982":"%%time\naggregate_file('..\/input\/test_set.csv', 'agg_test_set.csv', all_columns, verbose = 100000000)","4b38fcab":"train_set = pd.read_csv('agg_training_set.csv')\ntrain_set.head()","dec6a574":"train_set.shape","03a14043":"train_set.info(null_counts = True)","b4cb66cd":"# PLAsTiCC 2018 - Aggregate datasets by means and vars","d4ca0999":"## Check aggregated training set","e67385d8":"## New columns","54312759":"## Functions for aggregating","57216e2c":"## Aggregate train and test sets"}}