{"cell_type":{"d2e5ebe4":"code","974befd0":"code","3c1dbd4a":"code","fb1ecbca":"code","e25154d9":"code","fc385987":"code","045c6cc4":"code","f3fef8ef":"code","b57eee37":"code","f8894fe3":"code","b6dcc34e":"code","663ad22b":"code","47340031":"code","63c5d65d":"code","a798431a":"code","c94eb2e2":"code","15a56321":"code","c6150be0":"code","f97eddb5":"code","716837e5":"code","d1f1d001":"code","df4c53da":"markdown","e9110604":"markdown","1ea2ca08":"markdown","ff45729e":"markdown","69cfc2e3":"markdown","cead4b7a":"markdown","de7cad32":"markdown","bde2784d":"markdown","ba1918a5":"markdown","f5678ac5":"markdown","ba78c328":"markdown","6537363e":"markdown","9e4c6e30":"markdown","02cf1504":"markdown","4a7498a1":"markdown"},"source":{"d2e5ebe4":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport datetime as dt\nfrom matplotlib.ticker import PercentFormatter\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import KMeans\nfrom yellowbrick.cluster import KElbowVisualizer\nfrom itertools import combinations\n\npd.options.mode.chained_assignment = None","974befd0":"df = pd.read_csv(\"..\/input\/online-retail-final\/online_retail_final.csv\")\n\ndf.head()","3c1dbd4a":"df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])\n\nprint(\"Min date: {} \\nMax date: {}\".format(df.InvoiceDate.min(), df.InvoiceDate.max()))","fb1ecbca":"last_day = df.InvoiceDate.max() + dt.timedelta(days = 1)","e25154d9":"rfm_table = df.groupby(\"CustomerID\").agg({\"InvoiceDate\": lambda x: (last_day - x.max()).days,\n                                          \"InvoiceNo\": \"nunique\",\n                                          \"TotalPrice\": \"sum\"})\n\nrfm_table.rename(columns = {\"InvoiceDate\": \"Recency\",\n                            \"InvoiceNo\": \"Frequency\",\n                            \"TotalPrice\": \"Monetary\"}, inplace = True)\n\nrfm_table.head()","fc385987":"r_labels = range(5, 0, -1)\nfm_labels = range(1, 6)\n\nrfm_table[\"R\"] = pd.qcut(rfm_table[\"Recency\"], 5, labels = r_labels)\nrfm_table[\"F\"] = pd.qcut(rfm_table[\"Frequency\"].rank(method = 'first'), 5, labels = fm_labels)\nrfm_table[\"M\"] = pd.qcut(rfm_table[\"Monetary\"], 5, labels = fm_labels)\n\nrfm_table.head()","045c6cc4":"rfm_table[\"RFM_Segment\"] = rfm_table[\"R\"].astype(str) + rfm_table[\"F\"].astype(str) + rfm_table[\"M\"].astype(str)\nrfm_table[\"RFM_Score\"] = rfm_table[[\"R\", \"F\", \"M\"]].sum(axis = 1)\n\nrfm_table.head()","f3fef8ef":"segt_map = {\n    r'[1-2][1-2]': 'Hibernating',\n    r'[1-2][3-4]': 'At-Risk',\n    r'[1-2]5': 'Cannot lose them',\n    r'3[1-2]': 'About To Sleep',\n    r'33': 'Need Attention',\n    r'[3-4][4-5]': 'Loyal Customers',\n    r'41': 'Promising',\n    r'51': 'New Customers',\n    r'[4-5][2-3]': 'Potential Loyalists',\n    r'5[4-5]': 'Champions'\n}\nrfm_table['Segment'] = rfm_table['R'].astype(str) + rfm_table['F'].astype(str)\nrfm_table['Segment'] = rfm_table['Segment'].replace(segt_map, regex=True)\nrfm_table.head()","b57eee37":"rfm_coordinates = {\"Champions\": [3, 5, 0.8, 1],\n                   \"Loyal Customers\": [3, 5, 0.4, 0.8],\n                   \"Cannot lose them\": [4, 5, 0, 0.4],\n                   \"At-Risk\": [2, 4, 0, 0.4],\n                   \"Hibernating\": [0, 2, 0, 0.4],\n                   \"About To Sleep\": [0, 2, 0.4, 0.6],\n                   \"Promising\": [0, 1, 0.6, 0.8],\n                   \"New Customers\": [0, 1, 0.8, 1],\n                   \"Potential Loyalists\": [1, 3, 0.6, 1],\n                   \"Need Attention\": [2, 3, 0.4, 0.6]}","f8894fe3":"fig, ax = plt.subplots(figsize = (20, 10))\n\nax.set_xlim([0, 5])\nax.set_ylim([0, 5])\n\nplt.rcParams[\"axes.facecolor\"] = \"white\"\npalette = [\"#282828\", \"#04621B\", \"#971194\", \"#F1480F\",  \"#4C00FF\", \n           \"#FF007B\", \"#9736FF\", \"#8992F3\", \"#B29800\", \"#80004C\"]\n\nfor key, color in zip(rfm_coordinates.keys(), palette[:10]):\n    \n    coordinates = rfm_coordinates[key]\n    ymin, ymax, xmin, xmax = coordinates[0], coordinates[1], coordinates[2], coordinates[3]\n    \n    ax.axhspan(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax, facecolor = color)\n    \n    users = rfm_table[rfm_table.Segment == key].shape[0]\n    users_percentage = (rfm_table[rfm_table.Segment == key].shape[0] \/ rfm_table.shape[0]) * 100\n    avg_monetary = rfm_table[rfm_table.Segment == key][\"Monetary\"].mean()\n    \n    user_txt = \"\\n\\nTotal Users: \" + str(users) + \"(\" +  str(round(users_percentage, 2)) + \"%)\"\n    monetary_txt = \"\\n\\n\\n\\nAverage Monetary: \" + str(round(avg_monetary, 2))\n    \n    x = 5 * (xmin + xmax) \/ 2\n    y = (ymin + ymax) \/ 2\n    \n    plt.text(x = x, y = y, s = key, ha = \"center\", va = \"center\", fontsize = 18, color = \"white\", fontweight = \"bold\")\n    plt.text(x = x, y = y, s = user_txt, ha = \"center\", va = \"center\", fontsize = 14, color = \"white\")    \n    plt.text(x = x, y = y, s = monetary_txt, ha = \"center\", va = \"center\", fontsize = 14, color = \"white\")    \n    \n    ax.set_xlabel(\"Recency Score\")\n    ax.set_ylabel(\"Frequency Score\")\n    \nsns.despine(left = True, bottom = True)\nplt.show()","b6dcc34e":"rfm_table2 = rfm_table.reset_index()\n\nrfm_monetary_size = rfm_table2.groupby(\"Segment\").agg({\"Monetary\": \"mean\",\n                                                       \"CustomerID\": \"nunique\"})\n\nrfm_monetary_size.rename(columns = {\"Monetary\": \"MeanMonetary\", \"CustomerID\": \"CustomerCount\"}, inplace = True)\nrfm_monetary_size = rfm_monetary_size.sort_values(\"MeanMonetary\", ascending = False)","663ad22b":"plt.rcParams[\"axes.facecolor\"] = \"#A2A2A2\"\nplt.rcParams[\"axes.grid\"] = False\n\nfig, ax = plt.subplots(figsize = (16, 10), facecolor = \"#A2A2A2\")\n\nsns.barplot(x = rfm_monetary_size.MeanMonetary, y = rfm_monetary_size.index, ax = ax, color = \"#101820\")\nax2 = ax.twiny()\nsns.lineplot(x = rfm_monetary_size.CustomerCount, y = rfm_monetary_size.index, ax = ax2, marker = \"o\", linewidth = 0,\n             color = \"#F1480F\", markeredgecolor = \"#F1480F\")\n\nax2.axis(\"off\")\n\nfor y, x in list(enumerate(rfm_monetary_size.CustomerCount)):\n    ax2.text(x + 10, y + 0.05, str(x) + \" Customer\", color = \"white\", fontweight = \"normal\")\n\nplt.title(\"RFM Segments Details\")\nsns.despine(left = True, right = True, bottom = True, top = True)\nplt.show()","47340031":"rfm = rfm_table2.groupby(\"Segment\").agg({\"CustomerID\": \"nunique\", \n                                        \"Recency\": \"mean\",\n                                        \"Frequency\": \"mean\",\n                                        \"Monetary\": \"mean\"})\nrfm.rename(columns = {\"CustomerID\": \"Segment Size\"}, inplace = True)\n\ncm = sns.light_palette(\"#A2A2A2\", as_cmap = True)\n\nrfm.T.style.background_gradient(cmap = cm, axis = 1)\\\n.set_precision(2)\\\n.highlight_min(axis = 1, color = \"#195190\")\\\n.highlight_max(axis = 1, color = \"#D60000\")","63c5d65d":"plt.rcParams[\"axes.facecolor\"] = \"#A2A2A2\"\nplt.rcParams[\"axes.grid\"] = False\n\nsns.relplot(x = \"Recency\", y = \"Frequency\", hue = \"Segment\", size = \"Monetary\", data = rfm_table2, palette = palette,\n            height = 10, aspect = 2, sizes = (50, 1000))\n\nplt.show()","a798431a":"monetary_per_segment = (rfm_table2.groupby(\"Segment\")[\"Monetary\"].sum() \/\\\n                        rfm_table2.groupby(\"Segment\")[\"Monetary\"].sum().sum()).sort_values(ascending = False)","c94eb2e2":"fig, ax = plt.subplots(figsize = (10, 10), facecolor = \"#A2A2A2\")\n\nwedges, texts = ax.pie(monetary_per_segment.values, wedgeprops=dict(width=0.5), startangle=-40, normalize=False, colors = palette)\n\nbbox_props = dict(boxstyle=\"square,pad=0.3\", fc=\"w\", ec=\"k\", lw=0.72)\nkw = dict(arrowprops=dict(arrowstyle=\"-\"),\n          bbox=bbox_props, zorder=0, va=\"center\")\n\nfor i, p in enumerate(wedges):\n    ang = (p.theta2 - p.theta1)\/2. + p.theta1\n    y = np.sin(np.deg2rad(ang))\n    x = np.cos(np.deg2rad(ang))\n    horizontalalignment = {-1: \"right\", 1: \"left\"}[int(np.sign(x))]\n    connectionstyle = \"angle,angleA=0,angleB={}\".format(ang)\n    kw[\"arrowprops\"].update({\"connectionstyle\": connectionstyle})\n    ax.annotate(monetary_per_segment.index[i] + \" \" + str(round(monetary_per_segment[i] * 100, 2)) + \"%\", xy=(x, y), \n                xytext=(1.35*np.sign(x), 1.4*y),horizontalalignment=horizontalalignment, **kw)\nplt.show()","15a56321":"rfm_clustering = rfm_table2[[\"Recency\", \"Frequency\", \"Monetary\", \"Segment\"]]\n\nfor col in [\"Recency\", \"Frequency\", \"Monetary\"]:\n    \n    scaler = StandardScaler()\n    rfm_clustering[col] = np.log(rfm_clustering[col])\n    rfm_clustering[col] = scaler.fit_transform(rfm_clustering[col].values.reshape(-1, 1))\n    \nrfm_melted = pd.melt(rfm_clustering, id_vars = \"Segment\", value_vars = [\"Recency\", \"Frequency\", \"Monetary\"], var_name = \"RFM\", value_name = \"Value\")","c6150be0":"fig, ax = plt.subplots(figsize = (15, 12), facecolor = \"#A2A2A2\")\nax.set_facecolor(\"#A2A2A2\")\n\nsns.lineplot(x = \"RFM\", y = \"Value\", hue = \"Segment\", data = rfm_melted, palette = palette)\nax.legend(bbox_to_anchor = (1.05, 1), loc = 2, borderaxespad = 0.)\nax.set_yticks([])\nax.set_title(\"Snake Plot for RFM Segments\")\nplt.show()","f97eddb5":"features = [\"Recency\", \"Frequency\", \"Monetary\"]\n\nkmeans_ = KMeans(init = \"k-means++\", random_state = 42)\n\nfig, ax = plt.subplots(figsize = (9, 6), facecolor = \"#A2A2A2\")\nax.set_facecolor(\"#A2A2A2\")\nax.grid(False)\n\nvisualizer = KElbowVisualizer(kmeans_, k = (2, 21), timings = False)\n\nvisualizer.fit(rfm_clustering[features]) \nvisualizer.show()","716837e5":"kmeans = KMeans(n_clusters = 6, random_state = 42) \nkmeans.fit(rfm_clustering[features])\ncluster = kmeans.labels_\n\nfig, axes = plt.subplots(1, 3, figsize = (24, 8))\n\nfor i, feature in list(enumerate(combinations([\"Recency\", \"Frequency\", \"Monetary\"], 2))):\n\n    sns.scatterplot(x = rfm_clustering[feature[0]], y = rfm_clustering[feature[1]], hue = cluster, \n                    palette = palette[: len(set(cluster))], ax = axes[i]).set_title(feature[0] + \" - \" + feature[1])\n\n    sns.scatterplot(x = kmeans.cluster_centers_[:, 0], y = kmeans.cluster_centers_[:, 1],\n                    s = 250, color = '#C0EB00', label = 'Centroids', marker = \"X\", ax = axes[i], edgecolor = \"black\")\n\nplt.suptitle(\"Segmentation with KMeans - 6 Clusters\")\nfor ax in axes:\n    ax.set_facecolor(\"#A2A2A2\")\n    ax.grid(False)\n    \nplt.show()","d1f1d001":"fig, axes = plt.subplots(1, 3, figsize = (18, 6))\n\nfor ax in axes:\n    ax.set_facecolor(\"#A2A2A2\")\n    ax.set_xlabel(\"Clusters\")\n    \nsns.boxplot(x = cluster, y = \"Recency\", data = rfm_clustering, ax = axes[0]).set_title(\"Boxplot for Recency\")\nsns.boxplot(x = cluster, y = \"Frequency\", data = rfm_clustering, ax = axes[1]).set_title(\"Boxplot for Frequency\")\nsns.boxplot(x = cluster, y = \"Monetary\", data = rfm_clustering, ax = axes[2]).set_title(\"Boxplot for Monetary\")\n\nplt.show()","df4c53da":"# Customer Segmentation with using RFM Metrics","e9110604":"# Visualizing RFM Segments","1ea2ca08":"**Champions**: Bought recently, buy often and spend the most\n\n**Loyal customers**: Buy on a regular basis. Responsive to promotions.\n\n**Potential loyalist**: Recent customers with average frequency.\n\n**Recent customers**: Bought most recently, but not often.\n\n**Promising**: Recent shoppers, but haven\u2019t spent much.\n\n**Needs attention**: Above average recency, frequency and monetary values. May not have bought very recently though.\n\n**About to sleep**: Below average recency and frequency. Will lose them if not reactivated.\n\n**At risk**: Some time since they\u2019ve purchased. Need to bring them back!\n\n**Can\u2019t lose them**: Used to purchase frequently but haven\u2019t returned for a long time.\n\n**Hibernating**: Last purchase was long back and low number of orders. May be lost.\n\n*https:\/\/futurice.com\/blog\/know-your-customers-with-rfm","ff45729e":"I don't know is it original source of below segmentation map dict, but I take that code here.\nhttps:\/\/guillaume-martin.github.io\/rfm-segmentation-with-python.html","69cfc2e3":"# Preparing RFM Table","cead4b7a":"# Visualizing RFM Grid\n\n![](https:\/\/www.wigzo.com\/blog\/wp-content\/uploads\/2021\/06\/RFM-Analysis.jpg)\n\n*https:\/\/www.wigzo.com\/blog\/wp-content\/uploads\/2021\/06\/RFM-Analysis.jpg","de7cad32":"**Nice!**","bde2784d":"# Next\n\nNext chapter:\n\nhttps:\/\/www.kaggle.com\/mustafacicek\/marketing-analytics-forecasting\n\nFull work: https:\/\/www.kaggle.com\/mustafacicek\/detailed-marketing-analytics-cohort-pareto-rfm","ba1918a5":"**Let's perform RFM Analysis to our data.**","f5678ac5":"47.5% of total revenue comes from \"Champions\" segment, and 28% of total revenue comes from \"Loyal Customers\" segment. These two segments have 75% of company's total revenue.","ba78c328":"This is fourth part of https:\/\/www.kaggle.com\/mustafacicek\/detailed-marketing-analytics-cohort-pareto-rfm\n\nYou can reach this data from here. https:\/\/www.kaggle.com\/mustafacicek\/online-retail-final","6537363e":"# RFM Analysis","9e4c6e30":"Recency, frequency, monetary value is a marketing analysis tool used to identify a company's or an organization's best customers by using certain measures. The RFM model is based on three quantitative factors:\n\n**Recency**: How recently a customer has made a purchase\n\n**Frequency**: How often a customer makes a purchase\n\n**Monetary** Value: How much money a customer spends on purchases\n\nRFM analysis numerically ranks a customer in each of these three categories, generally on a scale of 1 to 5 (the higher the number, the better the result). The \"best\" customer would receive a top score in every category.\n\n*https:\/\/www.investopedia.com\/terms\/r\/rfm-recency-frequency-monetary-value.asp\n\n![](https:\/\/d35fo82fjcw0y8.cloudfront.net\/2018\/03\/01013508\/Incontent_image.png)\n\n*https:\/\/clevertap.com\/blog\/rfm-analysis\/","02cf1504":"Well, I'm surprised noone plot the above graph.\n\nI wrote these codes for visualizing above RFM grid.","4a7498a1":"# RFM Segments"}}