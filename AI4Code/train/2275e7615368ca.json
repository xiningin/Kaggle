{"cell_type":{"ff7ceac4":"code","f567348b":"code","b9cc86b3":"code","f1cdba1b":"code","43f3cb95":"code","5fa97bbc":"code","682aefbf":"code","c45eca8d":"code","ece9f535":"code","b1677802":"markdown","584dbaea":"markdown","e81edea3":"markdown","9ca65a8d":"markdown","202ec7fb":"markdown","f8bfc882":"markdown","28057146":"markdown","d50d1b81":"markdown","872a3c37":"markdown","14230557":"markdown","f171d84a":"markdown","6f713ce8":"markdown"},"source":{"ff7ceac4":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom matplotlib import pyplot as plt\n\nrankings = pd.read_csv('..\/input\/fifa-international-soccer-mens-ranking-1993now\/fifa_ranking.csv')\nrankings = rankings.loc[:,['rank', 'country_full', 'country_abrv', 'cur_year_avg_weighted', 'rank_date', \n                           'two_year_ago_weighted', 'three_year_ago_weighted']]\nrankings = rankings.replace({\"IR Iran\": \"Iran\"})\nrankings['weighted_points'] =  rankings['cur_year_avg_weighted'] + rankings['two_year_ago_weighted'] + rankings['three_year_ago_weighted']\nrankings['rank_date'] = pd.to_datetime(rankings['rank_date'])\n\nmatches = pd.read_csv('..\/input\/international-football-results-from-1872-to-2017\/results.csv')\nmatches =  matches.replace({'Germany DR': 'Germany', 'China': 'China PR'})\nmatches['date'] = pd.to_datetime(matches['date'])\n\nworld_cup = pd.read_csv('..\/input\/fifa-worldcup-2018-dataset\/World Cup 2018 Dataset.csv')\nworld_cup = world_cup.loc[:, ['Team', 'Group', 'First match \\nagainst', 'Second match\\n against', 'Third match\\n against']]\nworld_cup = world_cup.dropna(how='all')\nworld_cup = world_cup.replace({\"IRAN\": \"Iran\", \n                               \"Costarica\": \"Costa Rica\", \n                               \"Porugal\": \"Portugal\", \n                               \"Columbia\": \"Colombia\", \n                               \"Korea\" : \"Korea Republic\"})\nworld_cup = world_cup.set_index('Team')","f567348b":"# I want to have the ranks for every day \nrankings = rankings.set_index(['rank_date'])\\\n            .groupby(['country_full'], group_keys=False)\\\n            .resample('D').first()\\\n            .fillna(method='ffill')\\\n            .reset_index()\n\n# join the ranks\nmatches = matches.merge(rankings, \n                        left_on=['date', 'home_team'], \n                        right_on=['rank_date', 'country_full'])\nmatches = matches.merge(rankings, \n                        left_on=['date', 'away_team'], \n                        right_on=['rank_date', 'country_full'], \n                        suffixes=('_home', '_away'))","b9cc86b3":"# feature generation\nmatches['rank_difference'] = matches['rank_home'] - matches['rank_away']\nmatches['average_rank'] = (matches['rank_home'] + matches['rank_away'])\/2\nmatches['point_difference'] = matches['weighted_points_home'] - matches['weighted_points_away']\nmatches['score_difference'] = matches['home_score'] - matches['away_score']\nmatches['is_won'] = matches['score_difference'] > 0 # take draw as lost\nmatches['is_stake'] = matches['tournament'] != 'Friendly'\n\n# I tried earlier rest days but it did not turn to be useful\nmax_rest = 30\nmatches['rest_days'] = matches.groupby('home_team').diff()['date'].dt.days.clip(0,max_rest).fillna(max_rest)\n\n# I tried earlier the team as well but that did not make a difference either\nmatches['wc_participant'] = matches['home_team'] * matches['home_team'].isin(world_cup.index.tolist())\nmatches['wc_participant'] = matches['wc_participant'].replace({'':'Other'})\nmatches = matches.join(pd.get_dummies(matches['wc_participant']))","f1cdba1b":"from sklearn import linear_model\nfrom sklearn import ensemble\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix, roc_curve, roc_auc_score\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX, y = matches.loc[:,['average_rank', 'rank_difference', 'point_difference', 'is_stake']], matches['is_won']\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42)\n\nlogreg = linear_model.LogisticRegression(C=1e-5)\nfeatures = PolynomialFeatures(degree=2)\nmodel = Pipeline([\n    ('polynomial_features', features),\n    ('logistic_regression', logreg)\n])\nmodel = model.fit(X_train, y_train)\n\n# figures \nfpr, tpr, _ = roc_curve(y_test, model.predict_proba(X_test)[:,1])\nplt.figure(figsize=(15,5))\nax = plt.subplot(1,3,1)\nax.plot([0, 1], [0, 1], 'k--')\nax.plot(fpr, tpr)\nax.set_title('AUC score is {0:0.2}'.format(roc_auc_score(y_test, model.predict_proba(X_test)[:,1])))\nax.set_aspect(1)\n\nax = plt.subplot(1,3,2)\ncm = confusion_matrix(y_test, model.predict(X_test))\nax.imshow(cm, cmap='Blues', clim = (0, cm.max())) \n\nax.set_xlabel('Predicted label')\nax.set_title('Performance on the Test set')\n\nax = plt.subplot(1,3,3)\ncm = confusion_matrix(y_train, model.predict(X_train))\nax.imshow(cm, cmap='Blues', clim = (0, cm.max())) \nax.set_xlabel('Predicted label')\nax.set_title('Performance on the Training set')\npass","43f3cb95":"features = ['average_rank', 'rank_difference', 'point_difference']\nwrongs = y_test != model.predict(X_test)\n\nfor feature in features:\n    plt.figure()\n    plt.title(feature)\n    X_test.loc[wrongs, feature].plot.kde()\n    X.loc[:, feature].plot.kde()\n    plt.legend(['wrongs', 'all'])\n    \nprint(\"Stakes distribution in the wrong predictions\")\nprint(X_test.loc[wrongs, 'is_stake'].value_counts() \/ wrongs.sum())\nprint(\"Stakes distribution overall\")\nprint(X['is_stake'].value_counts() \/ X.shape[0])","5fa97bbc":"# let's define a small margin when we safer to predict draw then win\nmargin = 0.05\n\n# let's define the rankings at the time of the World Cup\nworld_cup_rankings = rankings.loc[(rankings['rank_date'] == rankings['rank_date'].max()) & \n                                    rankings['country_full'].isin(world_cup.index.unique())]\nworld_cup_rankings = world_cup_rankings.set_index(['country_full'])","682aefbf":"from itertools import combinations\n\nopponents = ['First match \\nagainst', 'Second match\\n against', 'Third match\\n against']\n\nworld_cup['points'] = 0\nworld_cup['total_prob'] = 0\n\nfor group in set(world_cup['Group']):\n    print('___Starting group {}:___'.format(group))\n    for home, away in combinations(world_cup.query('Group == \"{}\"'.format(group)).index, 2):\n        print(\"{} vs. {}: \".format(home, away), end='')\n        row = pd.DataFrame(np.array([[np.nan, np.nan, np.nan, True]]), columns=X_test.columns)\n        home_rank = world_cup_rankings.loc[home, 'rank']\n        home_points = world_cup_rankings.loc[home, 'weighted_points']\n        opp_rank = world_cup_rankings.loc[away, 'rank']\n        opp_points = world_cup_rankings.loc[away, 'weighted_points']\n        row['average_rank'] = (home_rank + opp_rank) \/ 2\n        row['rank_difference'] = home_rank - opp_rank\n        row['point_difference'] = home_points - opp_points\n        \n        home_win_prob = model.predict_proba(row)[:,1][0]\n        world_cup.loc[home, 'total_prob'] += home_win_prob\n        world_cup.loc[away, 'total_prob'] += 1-home_win_prob\n        \n        points = 0\n        if home_win_prob <= 0.5 - margin:\n            print(\"{} wins with {:.2f}\".format(away, 1-home_win_prob))\n            world_cup.loc[away, 'points'] += 3\n        if home_win_prob > 0.5 - margin:\n            points = 1\n        if home_win_prob >= 0.5 + margin:\n            points = 3\n            world_cup.loc[home, 'points'] += 3\n            print(\"{} wins with {:.2f}\".format(home, home_win_prob))\n        if points == 1:\n            print(\"Draw\")\n            world_cup.loc[home, 'points'] += 1\n            world_cup.loc[away, 'points'] += 1","c45eca8d":"pairing = [0,3,4,7,8,11,12,15,1,2,5,6,9,10,13,14]\n\nworld_cup = world_cup.sort_values(by=['Group', 'points', 'total_prob'], ascending=False).reset_index()\nnext_round_wc = world_cup.groupby('Group').nth([0, 1]) # select the top 2\nnext_round_wc = next_round_wc.reset_index()\nnext_round_wc = next_round_wc.loc[pairing]\nnext_round_wc = next_round_wc.set_index('Team')\n\nfinals = ['round_of_16', 'quarterfinal', 'semifinal', 'final']\n\nlabels = list()\nodds = list()\n\nfor f in finals:\n    print(\"___Starting of the {}___\".format(f))\n    iterations = int(len(next_round_wc) \/ 2)\n    winners = []\n\n    for i in range(iterations):\n        home = next_round_wc.index[i*2]\n        away = next_round_wc.index[i*2+1]\n        print(\"{} vs. {}: \".format(home,\n                                   away), \n                                   end='')\n        row = pd.DataFrame(np.array([[np.nan, np.nan, np.nan, True]]), columns=X_test.columns)\n        home_rank = world_cup_rankings.loc[home, 'rank']\n        home_points = world_cup_rankings.loc[home, 'weighted_points']\n        opp_rank = world_cup_rankings.loc[away, 'rank']\n        opp_points = world_cup_rankings.loc[away, 'weighted_points']\n        row['average_rank'] = (home_rank + opp_rank) \/ 2\n        row['rank_difference'] = home_rank - opp_rank\n        row['point_difference'] = home_points - opp_points\n\n        home_win_prob = model.predict_proba(row)[:,1][0]\n        if model.predict_proba(row)[:,1] <= 0.5:\n            print(\"{0} wins with probability {1:.2f}\".format(away, 1-home_win_prob))\n            winners.append(away)\n        else:\n            print(\"{0} wins with probability {1:.2f}\".format(home, home_win_prob))\n            winners.append(home)\n\n        labels.append(\"{}({:.2f}) vs. {}({:.2f})\".format(world_cup_rankings.loc[home, 'country_abrv'], \n                                                        1\/home_win_prob, \n                                                        world_cup_rankings.loc[away, 'country_abrv'], \n                                                        1\/(1-home_win_prob)))\n        odds.append([home_win_prob, 1-home_win_prob])\n                \n    next_round_wc = next_round_wc.loc[winners]\n    print(\"\\n\")","ece9f535":"import networkx as nx\nimport pydot\nfrom networkx.drawing.nx_pydot import graphviz_layout\n\nnode_sizes = pd.DataFrame(list(reversed(odds)))\nscale_factor = 0.3 # for visualization\nG = nx.balanced_tree(2, 3)\npos = graphviz_layout(G, prog='twopi', args='')\ncentre = pd.DataFrame(pos).mean(axis=1).mean()\n\nplt.figure(figsize=(10, 10))\nax = plt.subplot(1,1,1)\n# add circles \ncircle_positions = [(235, 'black'), (180, 'blue'), (120, 'red'), (60, 'yellow')]\n[ax.add_artist(plt.Circle((centre, centre), \n                          cp, color='grey', \n                          alpha=0.2)) for cp, c in circle_positions]\n\n# draw first the graph\nnx.draw(G, pos, \n        node_color=node_sizes.diff(axis=1)[1].abs().pow(scale_factor), \n        node_size=node_sizes.diff(axis=1)[1].abs().pow(scale_factor)*2000, \n        alpha=1, \n        cmap='Reds',\n        edge_color='black',\n        width=10,\n        with_labels=False)\n\n# draw the custom node labels\nshifted_pos = {k:[(v[0]-centre)*0.9+centre,(v[1]-centre)*0.9+centre] for k,v in pos.items()}\nnx.draw_networkx_labels(G, \n                        pos=shifted_pos, \n                        bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"black\", lw=.5, alpha=1),\n                        labels=dict(zip(reversed(range(len(labels))), labels)))\n\ntexts = ((10, 'Best 16', 'black'), (70, 'Quarter-\\nfinal', 'blue'), (130, 'Semifinal', 'red'), (190, 'Final', 'yellow'))\n[plt.text(p, centre+20, t, \n          fontsize=12, color='grey', \n          va='center', ha='center') for p,t,c in texts]\nplt.axis('equal')\nplt.title('Single-elimination phase\\npredictions with fair odds', fontsize=20)\nplt.show()","b1677802":"## Group rounds","584dbaea":"> # Data\n\nI use three datasets\n- FIFA rankings from 1993 to 2018 (courtesy of [Tadhg Fitzgerald](https:\/\/www.kaggle.com\/tadhgfitzgerald) \n> This one I used to get the FIFA ranking and points for the teams, which is a monthly changing rank previously shown as a [decent predictor](http:\/\/www.sportingintelligence.com\/2014\/06\/20\/upsets-giant-killings-adios-bye-bye-fifa-rankings-still-ahead-in-predicting-results-200601\/) of team performance\n- International Soccer matches from 1872 to 2018 (courtesy of [Mart J\u00fcrisoo](https:\/\/www.kaggle.com\/martj42))\n> This I will use to find out how much the difference in point, ranks and the current rank of the team affects the outocme of a match\n- FIFA World Cup 2018 data set (courtesy of [Nuggs](https:\/\/www.kaggle.com\/ahmedelnaggar))\n> This I will use to get the upcoming matches \n\nComment: Right when reading the datafiles I take care of the renaming of the Countries because there is some mismatch in the sources","e81edea3":"From these figures, we read \n- we predict worse for closer ranks\n- lower ranks in general\n- and somewhat for matches with no stakes (Friendly here)\n","9ca65a8d":"## Single-elimination rounds","202ec7fb":"I consider this pretty good performance, minding that soccer matches have typically only few goals scored and therefore making their outcome even more unpredictable. Nevertheless, let's look at the bad predictions and see where we are making mistakes more often.","f8bfc882":"# World Cup simulation","28057146":"# Visualization ","d50d1b81":"Fin","872a3c37":"# Feature extraction\n\nI join the matches with the ranks of the different teams. \n\nThen extract some features:\n- point and rank differences\n- if the game was for some stakes, because my naive view was that typically friendly matches are harder to predict (TODO differentiate the WC matches from the rest)\n- how many days the different teams were able to rest but this turned out to be not important enough to be worth the hassle\n- include the participant countries as a one hot vector but that did not appear to be a strong predictor either","14230557":"Thanks to Dr. James Bond and his kernel \n* [Soccer world cup winner](https:\/\/www.kaggle.com\/agostontorok\/soccer-world-cup-2018-winner)","f171d84a":"# Predicting the winner of the 2018 FIFA World Cup\n**Aim**: \nto predict the outcome of the FIFA World Cup 2018\n\n\n **Method**:\n- Use data from Kaggle to model the outcome of certain pairings between teams, given their rank, points, and the weighted point difference with the opponent.\n- Use this model to predict the outcome of the group rounds and then the single-elimination phase\n\n","6f713ce8":"# Modeling\n\nI used a simple Logistic regression, which yielded already rather good performance"}}