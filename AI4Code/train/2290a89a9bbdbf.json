{"cell_type":{"ccd1983e":"code","4cc1f16f":"code","bccd717e":"code","fce4d1ce":"code","60f103be":"code","d324c51e":"code","0ffdbe8b":"code","b92f6798":"code","1b7d43e6":"code","524a1a9a":"code","865b16c9":"code","763ba643":"code","9f8dff9f":"code","f0f116d5":"code","e7a5cbb9":"code","61241dfa":"code","908046e5":"code","73a9b4cd":"markdown","7ff879aa":"markdown","d52018da":"markdown","953230a6":"markdown","f3d195a4":"markdown","305cf2ad":"markdown","d4ac071c":"markdown","45d5786c":"markdown","1ddfca15":"markdown","4f33d1b5":"markdown","53ec1fbb":"markdown","754e4c30":"markdown","dda83805":"markdown","42eea174":"markdown","4077731c":"markdown","cc0814de":"markdown","8cf3623c":"markdown"},"source":{"ccd1983e":"import pandas as pd\nimport numpy as np\nimport sqlite3 as sql\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nfrom datetime import datetime, timedelta\n!pip install lmfit\nimport lmfit","4cc1f16f":"# Functions of equations\n\ndef getlambda(tspan, Q, R, initial_guess):\n    \"\"\"\n    Parameters\n    ----------\n    tspan : numpy.ndarray\n        time vector [days,].\n    Q : numpy.ndarray\n        time series of quarantiened cases [days,].\n    R : numpy.ndarray\n        time series of recovered cases [days,].\n    initial_guess: list\n        list of initial guess for the parameters lambda0, lambda1, lambda2\n        \n    Returns\n    -------\n    lambda0 : float\n        estimated value of lambda0.\n    lambda1 : float\n        estimated value of lambda1.\n    lambda2 : float\n        estimated value of lambda2.\n    lambdafun : function\n        estimation function for lambdafun(lambda0, lambda1, lambda2, time_span)\n\n    \"\"\"\n    if np.max(R)<20:                    # Assumption: Recovered cases less than 20 can either increase or decrease\n        lambdafun = lambda l0,l1,l2,t: l0 *np.exp(-(l1 *(t - l2)) **2)       # Hill-shaped sigmoide fuction\n        rate = (np.diff(R)\/np.median(np.diff(tspan[:])))\/Q[1:]\n        x = tspan[1:]\n        if initial_guess == []:  \n            lambda0 = np.max(rate)\n            lambda1 = 0.5\n            lambda2 = len(tspan)\/2\n        else:\n            lambda0, lambda1, lambda2 = initial_guess\n        params = lmfit.Parameters()\n        if np.max(rate)< 1e-10:   # To prevent dividing by zero\n            params.add('lambda0',lambda0,min=0,max=1)\n            print('\\nWarning! Recovery rate is too low for Lambda estimation. Poor estimation is expected!\\n')\n        else:\n            params.add('lambda0',lambda0,min=0,max=np.max(rate))\n        params.add('lambda1',lambda1,min=0,max=1)\n        params.add('lambda2',lambda2,min=0,max=100)\n        res1 = lambda params, rate, x: lambdafun(params['lambda0'].value,params['lambda1'].value,params['lambda2'].value,x) - rate\n        \n        fit1 = lmfit.minimize(res1,params,args=(rate,x),method='least_squares')\n        lambda0 = fit1.params['lambda0'].value\n        lambda1 = fit1.params['lambda1'].value\n        lambda2 = fit1.params['lambda2'].value\n        # lmfit.report_fit(fit1)\n\n    else: \n        myfun1 = lambda l0,l1,l2,t: l0\/(1+np.exp(-l1*(t-l2)))            # Ascending sigmoide function\n        myfun2 = lambda l0,l1,l2,t: l0 + np.exp(-l1 *(t + l2))           # Descending sigmoide function\n        myfun3 = lambda l0,l1,l2,t: l0 *np.exp(-(l1 *(t - l2)) **2)      # Hill-shaped sigmoide function\n    \n        rate = (np.diff(R)\/np.median(np.diff(tspan[:])))\/Q[1:]\n        x = tspan[1:]\n          \n        if initial_guess == []:  \n            lambda0 = np.max(rate)\n            lambda1 = 0.5\n            lambda2 = len(tspan)\/2\n        else:\n            lambda0, lambda1, lambda2 = initial_guess\n            \n        params = lmfit.Parameters()\n        if np.max(rate)< 1e-10:   # To prevent dividing by zero\n            params.add('lambda0',lambda0,min=0,max=1)\n            print('\\nWarning! Recovery rate is too low for Lambda estimation. Poor estimation is expected!\\n')\n        else:\n            params.add('lambda0',lambda0,min=0,max=np.max(rate))\n  \n        params.add('lambda1',lambda1,min=0,max=1)\n        params.add('lambda2',lambda2,min=0,max=100)\n        res1 = lambda params, rate, x: myfun1(params['lambda0'].value,params['lambda1'].value,params['lambda2'].value,x) - rate\n        res2 = lambda params, rate, x: myfun2(params['lambda0'].value,params['lambda1'].value,params['lambda2'].value,x) - rate\n        res3 = lambda params, rate, x: myfun3(params['lambda0'].value,params['lambda1'].value,params['lambda2'].value,x) - rate\n        \n        fit1 = lmfit.minimize(res1,params,args=(rate,x),method='least_squares')\n        lf10 = fit1.params['lambda0'].value\n        lf11 = fit1.params['lambda1'].value\n        lf12 = fit1.params['lambda2'].value\n        lamda1 = myfun1(lf10,lf11,lf12,x)\n        dlambda1 = abs(lamda1[0]-lamda1[-1])\n        # lmfit.report_fit(fit1)\n        \n        fit2 = lmfit.minimize(res2,params,args=(rate,x),method='least_squares')\n        lf20 = fit2.params['lambda0'].value\n        lf21 = fit2.params['lambda1'].value\n        lf22 = fit2.params['lambda2'].value\n        lamda2 = myfun2(lf20,lf21,lf22,x)\n        dlambda2 = abs(lamda2[0]-lamda2[-1])\n        # lmfit.report_fit(fit2)\n        \n        fit3 = lmfit.minimize(res3,params,args=(rate,x),method='least_squares')\n        lf30 = fit3.params['lambda0'].value\n        lf31 = fit3.params['lambda1'].value\n        lf32 = fit3.params['lambda2'].value\n        lamda3 = myfun3(lf30,lf31,lf32,x)\n        dlambda3 = abs(lamda3[0]-lamda3[-1])\n        # lmfit.report_fit(fit2)\n        \n        if  (dlambda1>dlambda2) and (dlambda1>dlambda2):\n            lambdaGuess = [lf10,lf11,lf12]\n            lambdafun = myfun1\n\n        elif (dlambda2>dlambda1) and (dlambda2>dlambda3): \n            lambdaGuess = [lf20,lf21,lf22]\n            lambdafun = myfun2\n\n        else:\n            lambdaGuess = [lf30,lf31,lf32]\n            lambdafun = myfun3\n\n        lambda0, lambda1, lambda2 = lambdaGuess\n    return lambda0, lambda1, lambda2, lambdafun\n\n\ndef getkappa(tspan, Q, D, initial_guess):\n    \"\"\"\n    Parameters\n    ----------\n    tspan : numpy.ndarray\n        time vector [days,].\n    D : numpy.ndarray\n        time series of death cases [days,].\n    R : numpy.ndarray\n        time series of recovered cases [days,].\n    initial_guess: list\n        list of initial guess for the parameters kappa0, kappa1, kappa2\n    Returns\n    -------\n    lambda0 : float\n        estimated value of lambda0.\n    lambda1 : float\n        estimated value of lambda1.\n    lambda2 : float\n        estimated value of lambda2.\n    lambdafun : function\n        estimation function for lambdafun(lambda0, lambda1, lambda2, time_span)\n\n    \"\"\"\n    if np.max(D)<10:      # Assumption: Deceased cases less than 10 can either increase or decrease\n        kappafun = lambda k0,k1,k2,t: k0 *np.exp(-(k1 *(t - k2)) **2)   # Hill-shaped sigmoide function\n        rate = (np.diff(D)\/np.median(np.diff(tspan[:])))\/Q[1:]\n        x = tspan[1:]\n        if initial_guess == []:\n            kappa0 = np.max(rate)\n            kappa1 = 0.5\n            kappa2 = len(tspan)\/2 \n        else:\n            kappa0, kappa1, kappa2 = initial_guess\n        params = lmfit.Parameters()\n        if np.max(rate)< 1e-10:   # To prevent dividing by zero\n            params.add('kappa0',kappa0,min=0,max=1)\n            print('\\nWarning! Mortality rate is too low for Kappa estimation. Poor estimation is expected!\\n')\n        else:\n            params.add('kappa0',kappa0,min=0,max=np.max(rate))\n  \n        params.add('kappa0',kappa0,min=0,max=np.max(rate))\n        params.add('kappa1',kappa1,min=0,max=1)\n        params.add('kappa2',kappa2,min=0,max=len(tspan))\n\n        res1 = lambda params, rate, x: kappafun(params['kappa0'].value,params['kappa1'].value,params['kappa2'].value,x) - rate\n        \n        fit1 = lmfit.minimize(res1,params,args=(rate,x),method='least_squares')\n        kappa0 = fit1.params['kappa0'].value\n        kappa1 = fit1.params['kappa1'].value\n        kappa2 = fit1.params['kappa2'].value\n        # lmfit.report_fit(fit1)\n\n\n    else:\n        myfun1 = lambda k0,k1,k2,t: k0 \/(1 + np.exp(-k1 *(t - k2)))            # Ascending sigmoide function\n        myfun2 = lambda k0,k1,k2,t: k0 + np.exp(-k1 *(t + k2))                 # Descending sigmoide function\n        myfun3 = lambda k0,k1,k2,t: k0 *np.exp(-(k1 *(t - k2)) **2)            # Hill-shaped sigmoide function\n        rate = (np.diff(D)\/np.median(np.diff(tspan[:])))\/Q[1:]\n        x = tspan[1:]\n        if initial_guess == []:\n            kappa0 = np.max(rate)\n            kappa1 = 0.5\n            kappa2 = 2 \n        else:\n            kappa0, kappa1, kappa2 = initial_guess        \n        params = lmfit.Parameters()\n        if np.max(rate)< 1e-10:   # To prevent dividing by zero\n            params.add('kappa0',kappa0,min=0,max=1)\n            print('\\nWarning! Mortality rate is too low for Kappa estimation. Poor estimation is expected!\\n')\n        else:\n            params.add('kappa0',kappa0,min=0,max=np.max(rate))\n        params.add('kappa1',kappa1,min=0,max=1)\n        params.add('kappa2',kappa2,min=0,max=len(tspan))\n        res1 = lambda params, rate, x: myfun1(params['kappa0'].value,params['kappa1'].value,params['kappa2'].value,x) - rate\n        res2 = lambda params, rate, x: myfun2(params['kappa0'].value,params['kappa1'].value,params['kappa2'].value,x) - rate\n        res3 = lambda params, rate, x: myfun3(params['kappa0'].value,params['kappa1'].value,params['kappa2'].value,x) - rate\n\n        fit1 = lmfit.minimize(res1,params,args=(rate,x),method='least_squares')\n        kf10 = fit1.params['kappa0'].value\n        kf11 = fit1.params['kappa1'].value\n        kf12 = fit1.params['kappa2'].value\n        kappa1 = myfun1(kf10,kf11,kf12,x)\n        dkappa1 = abs(kappa1[0]-kappa1[-1])\n        # lmfit.report_fit(fit1)\n        \n        fit2 = lmfit.minimize(res2,params,args=(rate,x),method='least_squares')\n        kf20 = fit2.params['kappa0'].value\n        kf21 = fit2.params['kappa1'].value\n        kf22 = fit2.params['kappa2'].value\n        kappa2 = myfun2(kf20,kf21,kf22,x)\n        dkappa2 = abs(kappa2[0]-kappa2[-1])\n        # lmfit.report_fit(fit2)\n        \n        fit3 = lmfit.minimize(res3,params,args=(rate,x),method='least_squares')\n        kf30 = fit3.params['kappa0'].value\n        kf31 = fit3.params['kappa1'].value\n        kf32 = fit3.params['kappa2'].value\n        kappa3 = myfun2(kf30,kf31,kf32,x)\n        dkappa3 = abs(kappa3[0]-kappa3[-1])\n        # lmfit.report_fit(fit2)\n\n        if  dkappa1>dkappa2 and (dkappa1>dkappa3):\n            kappaGuess = [kf10,kf11,kf12]\n            kappafun = myfun1\n            # lmfit.report_fit(fit1)\n\n        elif (dkappa2>dkappa1) and (dkappa2>dkappa3): \n            kappaGuess = [kf20,kf21,kf22]\n            kappafun = myfun2\n            # report = lmfit.report_fit(fit2)\n\n        else:\n            kappaGuess = [kf30,kf31,kf32]\n            kappafun = myfun3\n            # report = lmfit.report_fit(fit3)\n            \n        kappa0, kappa1, kappa2 = kappaGuess\n    return kappa0, kappa1, kappa2, kappafun \n\ndef ode_model(conditions, time_span, alpha, beta, gamma, delta, lamda, kappa):\n    # For the range of Lambda\n    S, E, I, Q , R, D, P = conditions\n    N = S + E + I + Q + R + D + P\n    dSdt = -alpha*S - beta*S*I\/N\n    dEdt = beta*S*I\/N - gamma*E\n    dIdt = gamma*E - delta*I\n    dQdt = delta*I - lamda*Q - kappa*Q\n    dRdt = lamda*Q\n    dDdt = kappa*Q\n    dPdt = alpha*S\n    \n    dSdt = np.clip(dSdt, -N, N)\n    dEdt = np.clip(dEdt, -N, N)\n    dIdt = np.clip(dIdt, -N, N)\n    dQdt = np.clip(dQdt, -N, N)\n    dRdt = np.clip(dRdt, -N, N)\n    dDdt = np.clip(dDdt, -N, N)\n    dPdt = np.clip(dPdt, -N, N)\n    return [dSdt, dEdt, dIdt, dQdt, dRdt, dDdt, dPdt]\n\n\ndef SEIQRDP(initial_conditions, parameter_guess, lambdafun, kappafun, tspan):\n    \"\"\"\n    Parameters\n    ----------\n    initial_conditions : list\n        list of initial conditions and population [6,]\n        initial_conditions = [initE, initI, initQ, initR, initD, initN]\n    parameters_guess: lmfit.parameter.Parameters\n        initial guess of transition parameters\n    lambdafun: function\n        estimation function for lambdafun(lambda0, lambda1, lambda2, time_span)\n    kappafun: function\n        estimation function for lambdafun(kappa0, kappa1, kappa2, time_span)\n    tspan : numpy.ndarray\n        time vector [days,].\n\n    Returns\n    -------\n    ode results\n    \"\"\"\n    alpha = parameter_guess['alpha'].value\n    beta = parameter_guess['beta'].value\n    gamma = parameter_guess['gamma'].value\n    delta = parameter_guess['delta'].value\n    \n    lambda0 = parameter_guess['lambda0'].value\n    lambda1 = parameter_guess['lambda1'].value\n    lambda2 = parameter_guess['lambda2'].value\n    \n    kappa0 = parameter_guess['kappa0'].value\n    kappa1 = parameter_guess['kappa1'].value\n    kappa2 = parameter_guess['kappa2'].value\n\n    lamda = lambdafun(lambda0, lambda1, lambda2, tspan)\n    kappa = kappafun(kappa0, kappa1, kappa2, tspan)\n\n    model = initial_conditions\n    # ODE is solved using time-varying Lambda and Kappa parameters\n    for ii in range(1,len(lamda)):\n        t = [tspan[ii-1],tspan[ii]]\n        sol = odeint(ode_model, initial_conditions,\n                   t,\n                   args=(alpha, beta, gamma, delta, lamda[ii-1], kappa[ii-1])) \n        initial_conditions = [sol[1][0],sol[1][1],sol[1][2],sol[1][3],sol[1][4],sol[1][5],sol[1][6]]\n        model = np.vstack((model,sol[1]))\n    return model\n\ndef residual(parameter_guess, initial_conditions, QRD, lambdafun, kappafun, tspan):\n    sol = SEIQRDP(initial_conditions, parameter_guess, lambdafun, kappafun, tspan)\n    QRD_sim = np.vstack((sol[:,3],sol[:,4], sol[:,5]))\n    error = (QRD_sim-QRD).ravel()\n    return error\n\n\ndef model_fitting(alpha, beta, gamma, delta, lambdaGuess, kappaGuess, Q, R, D, initS, initE, initI, initP, tspan):\n    \n    initial_conditions = [initS,initE, initI, Q[0], R[0], D[0], initP]\n    QRD = np.vstack((Q,R,D))\n\n    recovery_rate = (np.diff(R)\/np.median(np.diff(tspan[:])))\/Q[1:]\n    death_rate = (np.diff(D)\/np.median(np.diff(tspan[:])))\/Q[1:]\n\n    lambda0, lambda1, lambda2, lambdafun = getlambda(tspan, Q, R, lambdaGuess) \n    kappa0, kappa1, kappa2, kappafun = getkappa(tspan, Q, D, kappaGuess)\n    \n    params = lmfit.Parameters()\n    params.add('alpha', value=alpha, vary=False, min=0, max=1)\n    params.add('beta', value=beta, vary=True, min=0, max=1)\n    params.add('gamma', value=gamma,  vary=False, min=0, max=1)\n    params.add('delta', value=delta, vary=True, min=0, max=1)\n    if max(recovery_rate)<1e-10:\n        params.add('lambda0', value=lambda0, vary=True, min=0, max=1)    \n    else:\n        params.add('lambda0', value=lambda0, vary=True, min=0, max=np.max(recovery_rate))\n    params.add('lambda1', value=lambda1, vary=True, min=0, max=1)\n    params.add('lambda2', value=lambda2,vary=True, min=0, max=len(tspan))\n    \n    if np.max(death_rate) == np.min(death_rate):\n        params.add('kappa0', value=kappa0, vary=True, min=0, max=1)\n    else:\n        params.add('kappa0', value=kappa0, vary=True, min=0, max=np.max(death_rate))\n    params.add('kappa1', value=kappa1, vary=True, min=0, max=1)\n    params.add('kappa2', value=kappa2,vary=True, min=0, max=len(tspan))\n    \n    fit = lmfit.minimize(residual,params,args=(initial_conditions, QRD, lambdafun, kappafun, tspan),\n                          method='least_squares')\n\n    \n    return fit, lambdafun, kappafun","bccd717e":"# Databank related functions:\n\ndef read_dataset(connection,min_date,max_date,country,region): \n    df = pd.DataFrame()\n    if (country == \"all\" or region == \"all\"):\n        cq = \"SELECT ROWID FROM DimCountry\"\n    else:              \n        cq = \"SELECT ROWID FROM DimCountry WHERE convert_name IN %s OR continent IN %s \"%(country,region) \n    cid = pd.read_sql_query(cq,connection)\n    sq = \"SELECT DISTINCT source_id FROM data\"\n    sid = pd.read_sql_query(sq,connection)\n    for n in range(cid.size):\n        for m in range(sid.size):\n            sql = \"SELECT \"\\\n                \"dc.country_code \"\\\n            \t\",dc.convert_name \"\\\n                \",dc.continent \"\\\n                \",dt.id \"\\\n            \t\",dt.date \"\\\n            \t\",CASE dt.day_of_week WHEN 1 THEN 'monday' \"\\\n            \t\"\t\t\t\t\t WHEN 2 THEN 'tuesday' \"\\\n            \t\"\t\t\t\t\t WHEN 3 THEN 'wednesday' \"\\\n            \t\"\t\t\t\t\t WHEN 4 THEN 'thursday' \"\\\n            \t\"\t\t\t\t\t WHEN 5 THEN 'friday' \"\\\n            \t\"\t\t\t\t\t WHEN 6 THEN 'saturday' \"\\\n            \t\"\t\t\t\t\t WHEN 7 THEN 'sunday' \"\\\n            \t\"\t\t\t\t\t ELSE 'n\/a' END day_of_week \"\\\n            \t\",dt.cw calender_week \"\\\n            \t\",d.cases \"\\\n                \",d.deaths \"\\\n                \",d.recovered \"\\\n                \",d.cumulate_cases \"\\\n                \",d.cumulate_deaths \"\\\n                \",d.cumulate_recovered \"\\\n                \",ds.name source \"\\\n                \"FROM DimTime dt \"\\\n                \"LEFT JOIN data d ON d.time_id = dt.id AND country_id = %i AND d.source_id = %i \"\\\n                \"LEFT JOIN DimCountry dc ON dc.ROWID = %i \"\\\n                \"LEFT JOIN DimSource ds ON ds.id = %i \"\\\n                \"WHERE dt.date BETWEEN '%s' AND '%s' \"\\\n                \"ORDER by dt.date\"%(cid[\"rowid\"][n],sid[\"source_id\"][m],cid[\"rowid\"][n],sid[\"source_id\"][m],min_date,max_date)            \n            tmp = pd.read_sql_query(sql,connection)\n            df = pd.concat([tmp,df])    \n            \n    obj_columns = list(df.select_dtypes(include=['object']).columns.values)\n    df[obj_columns] = df[obj_columns].replace([None], np.nan)\n    return df","fce4d1ce":"# Database connection\npath = \"..\/input\/covid19-database\"    # Path to the database\ndb = path + '\/database.db'\nconn = sql.connect(db)                # SQL connection to the database\nmin_date = \"2020-03-20\"\nmax_date = \"2020-06-30\" \ndata = read_dataset(conn,min_date,max_date,('all'),()) \ndata","60f103be":"def data_fit_prediction(min_date,max_date, country, region, N,  conn):\n    # Use query to get dataframe - Measure    \n    # Database query \n    if np.size(country) == 1:\n        countries = (country,'')\n    else:\n        countries = country\n    \n    if region == '':\n        region = ()\n    data = read_dataset(conn,min_date,max_date,countries,region)   \n    # cw_data = data.groupby(['calender_week']).mean()\n    day_data =data.groupby(data.index).mean()\n    \n    days = 10    # Data is analyzed in 10 days periods\n    rest = np.mod(len(day_data), days)\n    train_data = day_data[:-(10+rest)]\n    tspan_fit = len(train_data.index) - np.mod(len(train_data),days)\n    pred_data = day_data[-(10+rest):]\n    \n    # Assumption: Any person with a positive test result is in quarantine until their state changes.\n    Q = day_data['cumulate_cases'].values - day_data['cumulate_recovered'].values - day_data['cumulate_deaths'].values\n    R = day_data['cumulate_recovered'].values\n    D = day_data['cumulate_deaths'].values\n    I = day_data['cumulate_cases'].values\n    \n    # Memory reserve \/ Parameter initialization\n    beta = np.zeros(int(tspan_fit\/days)+1)\n    beta[0] = 0.4\n    delta = np.zeros(int(tspan_fit\/days)+1)\n    alpha = 0.05\n    gamma = 0.4\n    delta[0] = 0.04\n    lamda = []\n    kappa = []\n    \n    S_f = []\n    I_f = []\n    Q_f = []\n    D_f = []\n    R_f = []\n\n    jj = 1\n    \n    # Initial states in the corresponding country\n    Q_begin = Q[:days]\n    R_begin = R[:days]\n    D_begin = D[:days]\n    initI = gamma*I[0] \n    initE = (1-gamma)*I[0]\n    initP = alpha*N\n    initS = N - (initE + initI + Q_begin[0] + R_begin[0] + D_begin[0] + initP)\n    \n    # Initial values of parameters may vary in different countries. \n    # The aim of following fitting is to prevent wrong initialization of infection rate, infected to quarantined rate, recovery rate and mortality rate\n    tspan = np.linspace(0,days,days)\n    fit, lambdafun, kappafun = model_fitting(alpha, beta[0], gamma, delta[0],[],[], Q_begin, R_begin, D_begin, initS, initE, initI, initP, tspan)\n    beta[0] = fit.params['beta'].value\n    delta[0] = fit.params['delta'].value\n    lambdaGuess = [fit.params['lambda0'].value,fit.params['lambda1'].value,fit.params['lambda2'].value]\n    kappaGuess = [fit.params['kappa0'].value,fit.params['kappa1'].value,fit.params['kappa2'].value]\n\n    # Fitting in ten-day periods\n    for ii in range(0,tspan_fit,days):\n        tspan = np.linspace(0,days-1,days)\n        Q_fit = Q[ii:days+ii]\n        R_fit = R[ii:days+ii]\n        D_fit = D[ii:days+ii]\n        \n        fit, lambdafun, kappafun = model_fitting(alpha, beta[jj-1], gamma, delta[jj-1],lambdaGuess, kappaGuess, Q_fit, R_fit, D_fit, initS, initE, initI, initP, tspan)\n        #lmfit.report_fit(fit)\n        \n        # To prevent underfitting and adjust to sudden changes\n        if fit.params['beta'].value < 1e-7:\n            beta[jj] = beta[jj-1]\n        else:\n            beta[jj] = fit.params['beta'].value\n        \n        delta[jj] = fit.params['delta'].value\n        lambdaGuess = fit.params['lambda0'].value,fit.params['lambda1'].value,fit.params['lambda2'].value\n        lambda_tmp = days * [np.mean(lambdafun(lambdaGuess[0],lambdaGuess[1],lambdaGuess[2],tspan))]\n        lamda= np.hstack((lamda,lambda_tmp))\n        kappaGuess = fit.params['kappa0'].value,fit.params['kappa1'].value,fit.params['kappa2'].value\n        kappa_tmp = days * [np.mean(kappafun(kappaGuess[0],kappaGuess[1],kappaGuess[2],tspan))]\n        kappa = np.hstack((kappa, kappa_tmp))\n        \n        # Updating the initial conditions\n        initial_conditions = [initS,initE, initI, Q_fit[0], R_fit[0], D_fit[0], initP]\n        model = SEIQRDP(initial_conditions, fit.params, lambdafun, kappafun, tspan)\n        S_f = np.hstack((S_f, model[:,0]))\n        I_f = np.hstack((I_f, model[:,2]))\n        Q_f = np.hstack((Q_f, model[:,3]))\n        R_f = np.hstack((R_f,model[:,4]))\n        D_f = np.hstack((D_f,model[:,5]))\n        jj +=1\n        initS = model[:,0][-1]\n        initE = model[:,1][-1]\n        initI = model[:,2][-1]\n        initP = model[:,6][-1]\n        \n    del jj   \n    \n\n    \n    \n    # Time dimension\n    num_days = len(day_data.index)\n    tspan_pred = np.linspace(0,len(pred_data), len(pred_data)+1)\n    # Prediction of rest + 10 days with the fitted parameters\n    initial_conditions = [initS,initE, initI, Q_f[-1], R_f[-1], D_f[-1], initP]\n    model_rest = SEIQRDP(initial_conditions,fit.params,lambdafun,kappafun,tspan_pred)\n    S_f = np.hstack((S_f,model_rest[:,0][:-1]))    \n    I_f = np.hstack((I_f,model_rest[:,2][:-1]))\n    \n    return S_f, I_f, Q, Q_f, R, R_f, D, D_f, model_rest, beta, gamma, delta, lamda, kappa, tspan_fit, tspan_pred, num_days, rest","d324c51e":"country = 'Germany'\nregion = ''\nN = 83.02e06           # Population of Germany\nmin_date = \"2020-03-20\"\nmax_date = \"2020-06-30\" \n\nS_f, I_f, Q, Q_f, R, R_f, D, D_f, model_rest, beta, gamma,  delta, lamda, kappa, tspan_fit, tspan_pred, num_days, rest = data_fit_prediction(min_date,max_date, country, region, N,  conn)\n\nfirst_day = datetime.strptime(min_date, '%Y-%m-%d')\ndate_list = [first_day + timedelta(days=x) for x in range(0, num_days)]\nd_locator = mdates.DayLocator() \nfmt = mdates.DateFormatter('%b-%d')\nplt.style.use('fivethirtyeight') ","0ffdbe8b":"# Plotting\nQ_f_rest = model_rest[:,3]\nR_f_rest = model_rest[:,4]\nD_f_rest = model_rest[:,5]\n\nfig,ax = plt.subplots(1,1,figsize=(12,8)) \n\nax.plot(date_list,Q,'d',color='dimgrey',label='Data')\nax.plot(date_list[:tspan_fit],Q_f,color='darkorange', lw=3,label='Quarantined cases')\nax.plot(date_list[tspan_fit-1:],Q_f_rest,'--',color='darkorange',lw=3) \nax.fill_between(date_list[:tspan_fit],0.875*Q_f,1.125*Q_f,alpha=0.3,color='orange') \nax.fill_between(date_list[tspan_fit-1:],0.875*Q_f_rest,1.125*Q_f_rest,alpha=0.3,color='orange') \nax.fill_between(date_list[tspan_fit-1:],0.93*Q_f_rest,1.07*Q_f_rest,alpha=0.4,color='orange') \n\nax.plot(date_list,I_f,color='darkmagenta', lw=3,label='Infected cases')\n\nax.plot(date_list,R,'d',color='dimgrey')\nax.plot(date_list[:tspan_fit],R_f,color='green', lw=3,label='Recovered cases')\nax.plot(date_list[tspan_fit-1:],R_f_rest,'--',color='green',lw=3) \nax.fill_between(date_list[:tspan_fit],0.875*R_f,1.125*R_f,alpha=0.3,color='limegreen') \nax.fill_between(date_list[tspan_fit-1:],0.875*R_f_rest,1.125*R_f_rest,alpha=0.3,color='limegreen') \nax.fill_between(date_list[tspan_fit-1:],0.93*R_f_rest,1.07*R_f_rest,alpha=0.4,color='limegreen') \n\nax.plot(date_list,D,'d',color='dimgrey')\nax.plot(date_list[:tspan_fit],D_f,color='red', lw=3,label='Fetalities')\nax.plot(date_list[tspan_fit-1:],D_f_rest,'--',color='red',lw=3) \nax.fill_between(date_list[:tspan_fit],0.875*D_f,1.125*D_f,alpha=0.3,color='salmon') \nax.fill_between(date_list[tspan_fit-1:],0.875*D_f_rest,1.125*D_f_rest,alpha=0.3,color='salmon') \nax.fill_between(date_list[tspan_fit-1:],0.93*D_f_rest,1.07*D_f_rest,alpha=0.4,color='salmon') \n\nax.set_title('Cases in '+country, fontsize=16)\nax.set_xlabel('Date', fontsize=14)\nax.autoscale(enable=True, axis='x', tight=True)\nax.legend()\nax.xaxis.set_minor_locator(d_locator)\nax.xaxis.set_major_formatter(fmt)\nfig.autofmt_xdate()","b92f6798":"s_fit = np.zeros((int(num_days\/10)+1,))\njj = 0\nfor ii in range(0,len(S_f),10):\n    s_fit[jj] = np.mean(S_f[ii:ii+10])   \n    jj += 1\ndel jj\n# Calculating the reproduction number\nRt = beta*s_fit[:-1]\/(delta*N)","1b7d43e6":"# I&Q vs R(t)\nfig, axes = plt.subplots(2, 1, figsize=(12, 8), gridspec_kw={'height_ratios': [3,7]})\n\nax = axes[1]\nax.plot(date_list[:num_days],Q,'d',color='dimgrey',label='Data')\nax.plot(date_list[:tspan_fit],Q_f,color='darkorange', lw=3,label='Quarantined cases')\nax.plot(date_list[tspan_fit-1:],Q_f_rest,'--',color='darkorange',lw=3) \nax.fill_between(date_list[:tspan_fit],0.875*Q_f,1.125*Q_f,alpha=0.3,color='orange') \nax.fill_between(date_list[tspan_fit-1:],0.875*Q_f_rest,1.125*Q_f_rest,alpha=0.3,color='orange') \nax.fill_between(date_list[tspan_fit-1:],0.93*Q_f_rest,1.07*Q_f_rest,alpha=0.4,color='orange') \nax.set_title('Quarantined cases vs. Infected cases in '+country, fontsize=16)\nax.set_xlabel('Date', fontsize=14)\nax.plot(date_list,I_f,color='darkmagenta', lw=3,label='Infected cases')\nax.autoscale(enable=True, axis='x', tight=True)\nax.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)\nax.xaxis.set_minor_locator(d_locator)\nax.xaxis.set_major_formatter(fmt)\n\nax = axes[0]\nax.plot(date_list[0:tspan_fit:9], Rt)\nax.fill_between(date_list[0:tspan_fit:9],0.93*Rt,1.07*Rt,alpha=0.4,color='skyblue') \nax.plot(date_list[0:tspan_fit:9], len(date_list[0:tspan_fit:9])*[1],'--', color='royalblue', lw=1)\nax.set_title(r'Effective reproduction number in '+country+' - $R(t)$', fontsize=16)\nax.autoscale(enable=True, axis='x', tight=True)\nax.xaxis.set_minor_locator(d_locator)\nax.xaxis.set_major_formatter(fmt)\n\nfig.autofmt_xdate()","524a1a9a":"country = 'Italy'\nregion = ''\nN = 60.36e06            # Population of Italy\nmin_date = \"2020-03-20\"\nmax_date = \"2020-06-30\" \n\nS_f, I_f, Q, Q_f, R, R_f, D, D_f, model_rest, beta, gamma,  delta, lamda, kappa, tspan_fit, tspan_pred, num_days, rest = data_fit_prediction(min_date,max_date, country, region, N,  conn)\n\nfirst_day = datetime.strptime(min_date, '%Y-%m-%d')\ndate_list = [first_day + timedelta(days=x) for x in range(0, num_days)]\nd_locator = mdates.DayLocator() \nfmt = mdates.DateFormatter('%b-%d')\nplt.style.use('fivethirtyeight') ","865b16c9":"# Plotting\nQ_f_rest = model_rest[:,3]\nR_f_rest = model_rest[:,4]\nD_f_rest = model_rest[:,5]\n\nfig,ax = plt.subplots(1,1,figsize=(12,8)) \n\nax.plot(date_list,Q,'d',color='dimgrey',label='Data')\nax.plot(date_list[:tspan_fit],Q_f,color='darkorange', lw=3,label='Quarantined cases')\nax.plot(date_list[tspan_fit-1:],Q_f_rest,'--',color='darkorange',lw=3) \nax.fill_between(date_list[:tspan_fit],0.875*Q_f,1.125*Q_f,alpha=0.3,color='orange') \nax.fill_between(date_list[tspan_fit-1:],0.875*Q_f_rest,1.125*Q_f_rest,alpha=0.3,color='orange') \nax.fill_between(date_list[tspan_fit-1:],0.93*Q_f_rest,1.07*Q_f_rest,alpha=0.4,color='orange') \n\nax.plot(date_list,I_f,color='darkmagenta', lw=3,label='Infected cases')\n\nax.plot(date_list,R,'d',color='dimgrey')\nax.plot(date_list[:tspan_fit],R_f,color='green', lw=3,label='Recovered cases')\nax.plot(date_list[tspan_fit-1:],R_f_rest,'--',color='green',lw=3) \nax.fill_between(date_list[:tspan_fit],0.875*R_f,1.125*R_f,alpha=0.3,color='limegreen') \nax.fill_between(date_list[tspan_fit-1:],0.875*R_f_rest,1.125*R_f_rest,alpha=0.3,color='limegreen') \nax.fill_between(date_list[tspan_fit-1:],0.93*R_f_rest,1.07*R_f_rest,alpha=0.4,color='limegreen') \n\nax.plot(date_list,D,'d',color='dimgrey')\nax.plot(date_list[:tspan_fit],D_f,color='red', lw=3,label='Fetalities')\nax.plot(date_list[tspan_fit-1:],D_f_rest,'--',color='red',lw=3) \nax.fill_between(date_list[:tspan_fit],0.875*D_f,1.125*D_f,alpha=0.3,color='salmon') \nax.fill_between(date_list[tspan_fit-1:],0.875*D_f_rest,1.125*D_f_rest,alpha=0.3,color='salmon') \nax.fill_between(date_list[tspan_fit-1:],0.93*D_f_rest,1.07*D_f_rest,alpha=0.4,color='salmon') \n\nax.set_title('Cases in '+country, fontsize=16)\nax.set_xlabel('Date', fontsize=14)\nax.autoscale(enable=True, axis='x', tight=True)\nax.legend()\nax.xaxis.set_minor_locator(d_locator)\nax.xaxis.set_major_formatter(fmt)\nfig.autofmt_xdate()","763ba643":"s_fit = np.zeros((int(num_days\/10)+1,))\njj = 0\nfor ii in range(0,len(S_f),10):\n    s_fit[jj] = np.mean(S_f[ii:ii+10])   \n    jj += 1\ndel jj\n# Calculating the reproduction number\nRt = beta*s_fit[:-1]\/(delta*N)","9f8dff9f":"# I&Q vs R(t)\nfig, axes = plt.subplots(2, 1, figsize=(12, 8), gridspec_kw={'height_ratios': [3,7]})\n\nax = axes[1]\nax.plot(date_list[:num_days],Q,'d',color='dimgrey',label='Data')\nax.plot(date_list[:tspan_fit],Q_f,color='darkorange', lw=3,label='Quarantined cases')\nax.plot(date_list[tspan_fit-1:],Q_f_rest,'--',color='darkorange',lw=3) \nax.fill_between(date_list[:tspan_fit],0.875*Q_f,1.125*Q_f,alpha=0.3,color='orange') \nax.fill_between(date_list[tspan_fit-1:],0.875*Q_f_rest,1.125*Q_f_rest,alpha=0.3,color='orange') \nax.fill_between(date_list[tspan_fit-1:],0.93*Q_f_rest,1.07*Q_f_rest,alpha=0.4,color='orange') \nax.set_title('Quarantined cases vs. Infected cases in '+country, fontsize=16)\nax.set_xlabel('Date', fontsize=14)\nax.plot(date_list,I_f,color='darkmagenta', lw=3,label='Infected cases')\nax.autoscale(enable=True, axis='x', tight=True)\nax.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)\nax.xaxis.set_minor_locator(d_locator)\nax.xaxis.set_major_formatter(fmt)\n\nax = axes[0]\nax.plot(date_list[0:tspan_fit:9], Rt)\nax.fill_between(date_list[0:tspan_fit:9],0.93*Rt,1.07*Rt,alpha=0.4,color='skyblue') \nax.plot(date_list[0:tspan_fit:9], len(date_list[0:tspan_fit:9])*[1],'--', color='royalblue', lw=1)\nax.set_title(r'Effective reproduction number in '+country+' - $R(t)$', fontsize=16)\nax.autoscale(enable=True, axis='x', tight=True)\nax.xaxis.set_minor_locator(d_locator)\nax.xaxis.set_major_formatter(fmt)\n\nfig.autofmt_xdate()","f0f116d5":"country = 'Spain'\nregion = ''\nN = 46.94e06            # Population of Spain\nmin_date = \"2020-03-20\"\nmax_date = \"2020-06-30\" \n\nS_f, I_f, Q, Q_f, R, R_f, D, D_f, model_rest, beta, gamma,  delta, lamda, kappa, tspan_fit, tspan_pred, num_days, rest = data_fit_prediction(min_date,max_date, country, region, N,  conn)\n\nfirst_day = datetime.strptime(min_date, '%Y-%m-%d')\ndate_list = [first_day + timedelta(days=x) for x in range(0, num_days)]\nd_locator = mdates.DayLocator() \nfmt = mdates.DateFormatter('%b-%d')\nplt.style.use('fivethirtyeight') ","e7a5cbb9":"# Plotting\nQ_f_rest = model_rest[:,3]\nR_f_rest = model_rest[:,4]\nD_f_rest = model_rest[:,5]\n\nfig,ax = plt.subplots(1,1,figsize=(12,8)) \n\nax.plot(date_list,Q,'d',color='dimgrey',label='Data')\nax.plot(date_list[:tspan_fit],Q_f,color='darkorange', lw=3,label='Quarantined cases')\nax.plot(date_list[tspan_fit-1:],Q_f_rest,'--',color='darkorange',lw=3) \nax.fill_between(date_list[:tspan_fit],0.875*Q_f,1.125*Q_f,alpha=0.3,color='orange') \nax.fill_between(date_list[tspan_fit-1:],0.875*Q_f_rest,1.125*Q_f_rest,alpha=0.3,color='orange') \nax.fill_between(date_list[tspan_fit-1:],0.93*Q_f_rest,1.07*Q_f_rest,alpha=0.4,color='orange') \n\nax.plot(date_list,I_f,color='darkmagenta', lw=3,label='Infected cases')\n\nax.plot(date_list,R,'d',color='dimgrey')\nax.plot(date_list[:tspan_fit],R_f,color='green', lw=3,label='Recovered cases')\nax.plot(date_list[tspan_fit-1:],R_f_rest,'--',color='green',lw=3) \nax.fill_between(date_list[:tspan_fit],0.875*R_f,1.125*R_f,alpha=0.3,color='limegreen') \nax.fill_between(date_list[tspan_fit-1:],0.875*R_f_rest,1.125*R_f_rest,alpha=0.3,color='limegreen') \nax.fill_between(date_list[tspan_fit-1:],0.93*R_f_rest,1.07*R_f_rest,alpha=0.4,color='limegreen') \n\nax.plot(date_list,D,'d',color='dimgrey')\nax.plot(date_list[:tspan_fit],D_f,color='red', lw=3,label='Fetalities')\nax.plot(date_list[tspan_fit-1:],D_f_rest,'--',color='red',lw=3) \nax.fill_between(date_list[:tspan_fit],0.875*D_f,1.125*D_f,alpha=0.3,color='salmon') \nax.fill_between(date_list[tspan_fit-1:],0.875*D_f_rest,1.125*D_f_rest,alpha=0.3,color='salmon') \nax.fill_between(date_list[tspan_fit-1:],0.93*D_f_rest,1.07*D_f_rest,alpha=0.4,color='salmon') \n\nax.set_title('Cases in '+country, fontsize=16)\nax.set_xlabel('Date', fontsize=14)\nax.autoscale(enable=True, axis='x', tight=True)\nax.legend()\nax.xaxis.set_minor_locator(d_locator)\nax.xaxis.set_major_formatter(fmt)\nfig.autofmt_xdate()","61241dfa":"s_fit = np.zeros((int(num_days\/10)+1,))\njj = 0\nfor ii in range(0,len(S_f),10):\n    s_fit[jj] = np.mean(S_f[ii:ii+10])   \n    jj += 1\ndel jj\n# Calculating the reproduction number\nRt = beta*s_fit[:-1]\/(delta*N)","908046e5":"# I&Q vs R(t)\nfig, axes = plt.subplots(2, 1, figsize=(12, 8), gridspec_kw={'height_ratios': [3,7]})\n\nax = axes[1]\nax.plot(date_list[:num_days],Q,'d',color='dimgrey',label='Data')\nax.plot(date_list[:tspan_fit],Q_f,color='darkorange', lw=3,label='Quarantined cases')\nax.plot(date_list[tspan_fit-1:],Q_f_rest,'--',color='darkorange',lw=3) \nax.fill_between(date_list[:tspan_fit],0.875*Q_f,1.125*Q_f,alpha=0.3,color='orange') \nax.fill_between(date_list[tspan_fit-1:],0.875*Q_f_rest,1.125*Q_f_rest,alpha=0.3,color='orange') \nax.fill_between(date_list[tspan_fit-1:],0.93*Q_f_rest,1.07*Q_f_rest,alpha=0.4,color='orange') \nax.set_title('Quarantined cases vs. Infected cases in '+country, fontsize=16)\nax.set_xlabel('Date', fontsize=14)\nax.plot(date_list,I_f,color='darkmagenta', lw=3,label='Infected cases')\nax.autoscale(enable=True, axis='x', tight=True)\nax.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)\nax.xaxis.set_minor_locator(d_locator)\nax.xaxis.set_major_formatter(fmt)\n\nax = axes[0]\nax.plot(date_list[0:tspan_fit:9], Rt)\nax.fill_between(date_list[0:tspan_fit:9],0.93*Rt,1.07*Rt,alpha=0.4,color='skyblue') \nax.plot(date_list[0:tspan_fit:9], len(date_list[0:tspan_fit:9])*[1],'--', color='royalblue', lw=1)\nax.set_title(r'Effective reproduction number in '+country+' - $R(t)$', fontsize=16)\nax.autoscale(enable=True, axis='x', tight=True)\nax.xaxis.set_minor_locator(d_locator)\nax.xaxis.set_major_formatter(fmt)\n\nfig.autofmt_xdate()","73a9b4cd":"# Future Works\nWe analyzed the data from reported cumulative infected, recovered, and deceased cases and evaluated the impact of taken social interventions in Germany, Italy and Spain, using the effective reproduction number. \n\nThe proposed model could also be used to evaluate the role of the health care system across countries, using the recovery and mortality rate and comparing them with the effective reproduction number and also the health index of any specific country. \n\nFurthurmore, many other fitting methods, using the Markov property of the system, can be used to prevent overfitting and to adjust the model to sudden changes in the trends.","7ff879aa":"## Germany","d52018da":"## Priors for the transition parameters \nAccording to the [Robert Koch Institute](https:\/\/edoc.rki.de\/handle\/176904\/6547.2), we initialize the transition parameters $\\alpha$, $\\beta$ and $\\gamma$ with the values 0.05, 0.4, and 0.4. To initialize the coefficients $\\lambda_{0}$, $\\lambda_{1}$ and $\\lambda_{2}$ such as $\\kappa_{0}$, $\\kappa_{1}$ and $\\kappa_{2}$ we first fitted the model with data from the first ten days and then we perform the fitting for the whole dataset in ten days periods.","953230a6":"# Introduction\n* Through the COVID-19 outbreak, many countries have adopted different strategies to control the infection rate of the virus. Many health organizations released datasets, which contain information about infected, recovered and deceased cases in several countries, and the corresponding measures, which have been taken in each country.\t\n* Can the effect of measures taken in each country be quantified? How to predict the course of the pandemic? And is it possible to estimate the rates of COVID-19 using the implemented model? \n* With this approach in mind we implemented an epidemiological compartmental model, to estimate the rates of COVID-19 using the data of reported infected, recovered and deceased cases in each country. Additionally, we used the effective reproduction number to quantify the effectiveness of taken measures and the impact of social interventions such as social lockdown or closure of schools on the number of reported infected cases in Germany, Italy and Spain. ","f3d195a4":"# Results\nWe analyzed the data from Germany, Italy and Spain, and compared the dynamics of the parameters with the public interventions which have been taken in a timespan between March 20 and June 30. ","305cf2ad":"The low value of the effective reproduction number in Spain during April 1 until around May 1 shows the effectiveness of the full lockdown on April 4 and April 13.\n\nHowever, with the significant rise of $R(t)$ and the number of infected cases in the first half of May, partial lockdowns, movement restrictions and other social interventions were only able to impact the course of the pandemic after a relatively long delay, so the effective reproduction number only dropped below one again in the last days of June.","d4ac071c":"If we look more closely at the changes of infected and quarantined cases between March 20 and June 30, and compare them with the trend of changes in the effective reproduction number, we can draw two conclusions:\n* The increasing number of the infected cases in the beginning of April is controlled and begins to fall due to the social lockdown, and the reproduction number reaches $R(t)<1$\n* As in the beginning of May the number of infected cases begins to gradually increase, the obligatory social distancing and partial lockdown in Germany, which has been taken until 15. May, controls this rising trend. The latter can also be seen in the changes of effective reproduction number as its value decreases and remains below one.","45d5786c":"## Spain","1ddfca15":"# Refrences\n* [A time-dependent SEIR model to analyse the evolution of the SARS-covid-2 epidemic outbreak in Portugal](http:\/\/dx.doi.org\/10.2471\/BLT.20.258392)\n* [Modellierung von Beispielszenarien der SARS-CoV-2-Epidemie 2020 in Deutschland](http:\/\/dx.doi.org\/10.25646\/6571.2)\n* [Generalized SEIR Epidemic Model (fitting and computation in MATLAB)](https:\/\/de.mathworks.com\/matlabcentral\/fileexchange\/74545-generalized-seir-epidemic-model-fitting-and-computation)\n","4f33d1b5":"Considering the changes of infected and quarantined cases in Italy and comparing them with the trend of changes of effective reproduction number in the corresponding timespan, we can see that the spreading of the virus is well controlled until about May 1, and the effective reproduction number had reached values less than one.\n\n\nHowever, as the number of quarantined cases decrease, the effective reproduction number increases rapidly and reaches values near to one, which may indicate the instant need for further social interventions such as social distancing.","53ec1fbb":"# Model\n\n## SEIQRDP Model\nWe implemented an epidemiological compartmental model andused the Least Squares Error (LSE) method to fit the model to data. \n\n![SEIQRDP.png](attachment:SEIQRDP.png)\n\nThis model consists of seven compartments of the population of a country <br>\n{$S(t), E(t), I(t), Q(t), R(t), D(t), P(t)$} denoting time by $t$, with the following states:\n*     $S\\rightarrow Susceptible$\n*     $E\\rightarrow Exposed$\n*     $I\\rightarrow Infected$\n*     $Q\\rightarrow Quarantined$\n*     $R\\rightarrow Recovered$\n*     $D\\rightarrow Deceased$\n*     $P\\rightarrow Insusceptible$    \n\nUsing this model, we assumed that a secondary infection in the investigated timespan is so unlikely that it does not warrant consideration here. Moreover the model is implemented under the assumption that every person with a positive test result goes to quarantine.\n\nThese states are connected via six transition parameters, each representing the rate of passing over from a state to the next one.\n\n* $\\alpha\\rightarrow$ Protection rate\n* $\\beta\\rightarrow$ Infection rate\n* $\\gamma\\rightarrow$ Inverse of the average latent time \n* $\\delta\\rightarrow$ The rate at which infectious people enter in quarantine\n* $\\lambda(t)\\rightarrow$ Time-dependent coefficient for recovery rate\n* $\\kappa(t)\\rightarrow$ Time-dependent coefficient for mortality rate\n\nDepending on whether the recovery or mortality rate in the corresponding timespan is ascending or descending, one of the three following functions is selected to fit the changes in the parameters:\n\n\\begin{equation*}\n \\lambda (t)=\\qquad\t\n \\left\\{\n \\begin{array}{c1}\n\t\\dfrac{\\lambda_{0}}{1 + e^{-\\lambda_{1} (t + \\lambda_{2})}}  \\\\ \\\\\n\t\\lambda_{0} + e^{-\\lambda_{1} (t + \\lambda_{2})} \\\\ \\\\\n    \\lambda_{0} e^{-\\lambda_{1} (t - \\lambda_{2})^{2}}\n \\end{array}\n\t\\right.\n\\end{equation*}\nwhere $\\lambda_{0}$, $\\lambda_{1}$ and $\\lambda_{2}$ are empirical coefficients. \n\n\\begin{equation*}\n \\kappa (t)=\\qquad\t\n \\left\\{\n \\begin{array}{c1}\n\t\\dfrac{\\kappa_{0}}{1 + e^{-\\kappa_{1} (t + \\kappa_{2})}}  \\\\ \\\\\n\t\\kappa_{0} + e^{-\\kappa_{1} (t + \\kappa_{2})} \\\\ \\\\\n    \\kappa_{0} e^{-\\kappa_{1} (t - \\kappa_{2})^{2}}\n \\end{array}\n\t\\right.\n\\end{equation*}\nwhere $\\kappa_{0}$, $\\kappa_{1}$ and $\\kappa_{2}$ are empirical coefficients. ","754e4c30":"## Importing essential libraries","dda83805":"## Fitting and Prediction\nFor this task, we used data from cumulative cases. Under assumption that every person with a positive test result goes to quarantine, we fitted our model to data in ten-day periods. The data from the last ten days is used to evaluate the fitting results and to predict the trend of changes in states and parameters in the subsequent days.\n\nTo this aim, we implemented the function `data_fit_prediction(min_date, max_date, country, region, N, conn)` with the follwing in- and outputs:\n-    In:\n    - min_date; Begin date of the timespan (string, format: yyyy-mm-dd)\n    - max_date; End date of the timespan (string, format: yyyy-mm-dd)\n    - country; Name of selected countries (tuple of strings)\n    - region; Name of selected region(s) (tuple of strings)\n    - N; population of selected countries (intiger)\n    - conn; SQL connection\n-    Out:\n    - S_f; Trend of changes in susceptible cases using fitted parameters\n    - I_f; Trend of changes in infected cases using fitted parameters\n    - Q; Quarantined cases from reported data\n    - Q_f; Trend of changes in quarantined cases using fitted parameters\n    - R; Recovered cases from reported data\n    - R_f; Trend of changes in recovered cases using fitted parameters\n    - D; Deceased cases from reported data\n    - D_f; Trend of changes in deceased cases using fitted parameters\n    - model_rest; List of predicted changes in model conditions\n    - beta; Changes in infection rate\n    - gamma; Inverse of latent time (fixed parameter)\n    - delta; Changes in infected to quarantined rate\n    - lambda; Recovery rate\n    - kappa; Mortality rate\n    - tspan_fit; Timespan of fitting\n    - tspan_pred; Timespan of prediction\n    - num_days; Total number of investigated timespan\n    - rest; mod(num_days,10)\n\nKnowing that the initial values of transition parameters may vary in different countries, we initialized the varying parameters such as, infection rate $\\beta$, infected to quarantined rate $\\delta$, recovery rate $\\lambda$, and mortality rate $\\kappa$, with a preliminary fitting with the data of the first ten days. ","42eea174":"# Materials and Methods\n\n## Database\nFor this study, we gathered data from these three sources:\n* Johns Hopkins University\n* World Health Organisation (WHO)\n* European Centre for Disease Prevention and Control (ECDC)\n\nOur database contains 3 main tables which give us data about cumulative cases, taken measures and the health index in each country in a specific timespan.\n![Database%20structure.gif](attachment:Database%20structure.gif)","4077731c":"## Effective reproduction number\nThe effective reproduction number $R(t) = \\beta\\delta^{-1}S(t)\/N$ is a strong tool to evaluate the intensity of interventions required to control the spread of the virus. Generally, $R(t)>1$ corresponds to $\\dfrac{dI(t)}{dt} + \\dfrac{dE(t)}{dt} >1$, which can be interpreted as the epidemical spread of disease. Similarly, $R(t)<1$ corresponds to controlling the spread of the disease.","cc0814de":"## Mathematical model\nThe dynamics of the above states and transition parameters are mathematically characterized by ordinary differential equations (ODE) as follows:\n\\begin{equation*}\n \\qquad\t\n \\left\\{\n \\begin{array}{l0.5}\n\t\\dfrac{dS(t)}{dt} = -\\alpha S(t) - \\beta \\dfrac{S(t)I(t)}{N} \\\\ \n    \\dfrac{dE(t)}{dt} = -\\gamma E(t) + \\beta \\dfrac{S(t)I(t)}{N} \\\\ \n    \\dfrac{dI(t)}{dt} = \\gamma E(t) - \\delta I(t) \\\\ \n    \\dfrac{dQ(t)}{dt} = \\delta I(t) - \\lambda (t) Q(t) - \\kappa (t) Q(t) \\\\ \n    \\dfrac{dR(t)}{dt} = \\lambda (t) Q(t) \\\\ \n    \\dfrac{dD(t)}{dt} = \\kappa (t) Q(t) \\\\ \n    \\dfrac{dP(t)}{dt} = \\alpha S(t) \\\\ \n \\end{array}\n       \\right.\n\\end{equation*}\nwhere $N$ corresponds to the population of the considered country and it can be expressed as $S + E + I + Q + R + D + P = N$","8cf3623c":"## Italy"}}