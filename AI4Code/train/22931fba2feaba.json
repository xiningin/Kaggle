{"cell_type":{"67b0c70b":"code","b52711b4":"code","02ca01b1":"code","4977b836":"code","d513ae0f":"code","e1a92f61":"code","89edc9ba":"code","ff511168":"code","9778a1f7":"code","fc9f4886":"code","1b6febb7":"code","3b94c23a":"code","b0aa8015":"code","0fff1b74":"code","3a2d22eb":"code","3cfc5607":"code","6ad6d2a3":"code","418684b6":"code","08d8545b":"code","470cd6fe":"code","9bf4201c":"code","497a0784":"code","4217def0":"code","60b84dfb":"code","ec5b675b":"code","b9114a23":"code","4027ab6f":"code","7e725a51":"code","b6b4b8f9":"code","411a9cbe":"code","ada3efeb":"code","c2a50f33":"code","cac09c38":"code","09fe7345":"code","7db631cf":"code","d7af35b6":"code","3586ecc9":"code","1747fabe":"code","8eca6d7f":"code","fae39730":"code","21d97ed3":"code","aca64975":"code","74a7251b":"code","1f5d6075":"code","ff6c750b":"code","86eab052":"code","300f79e4":"code","544fa08f":"code","899aacfc":"code","d2981fcb":"code","4c1452f6":"code","df15575f":"code","f0c90c2b":"code","fa971ae7":"code","004b9c9c":"code","c5140bdf":"code","61219e05":"code","ebe456af":"code","c7859bca":"code","77d3b67f":"markdown","e9cbbff8":"markdown","d637683c":"markdown","04774c15":"markdown","d8acc50f":"markdown","68853e71":"markdown","11a2239b":"markdown","07c3c40f":"markdown","893cdfdd":"markdown","156a9804":"markdown","3a95a022":"markdown","7ad9c111":"markdown","40f05f06":"markdown","bf49c0ae":"markdown","f6770f73":"markdown","768eaf5c":"markdown","9eeb2c4e":"markdown","acff5913":"markdown","f51fbcee":"markdown","d118ce11":"markdown","a3dac728":"markdown","b378d2d9":"markdown","7b2ab01a":"markdown","ce3faca3":"markdown","f0062df3":"markdown","2fb951db":"markdown","03071549":"markdown","ee6f8876":"markdown","c8af8798":"markdown","9680c497":"markdown","87c3b4e1":"markdown","1628af7b":"markdown","5d83f038":"markdown","b11ee233":"markdown","96bd4a68":"markdown","a846f4dc":"markdown","af633254":"markdown","69ed1774":"markdown","8ce39243":"markdown","f1f9e128":"markdown","2d711a6e":"markdown","f7ccdb17":"markdown","a59d6910":"markdown","444ff9b6":"markdown","a1967b00":"markdown","d1338938":"markdown"},"source":{"67b0c70b":"! wget https:\/\/repo.anaconda.com\/miniconda\/Miniconda3-py37_4.8.2-Linux-x86_64.sh\n! chmod +x Miniconda3-py37_4.8.2-Linux-x86_64.sh\n! bash .\/Miniconda3-py37_4.8.2-Linux-x86_64.sh -b -f -p \/usr\/local\n! conda install -c rdkit rdkit -y\nimport sys\nsys.path.append('\/usr\/local\/lib\/python3.7\/site-packages\/')","b52711b4":"! wget https:\/\/pubs.acs.org\/doi\/suppl\/10.1021\/ci034243x\/suppl_file\/ci034243xsi20040112_053635.txt","02ca01b1":"! wget https:\/\/raw.githubusercontent.com\/dataprofessor\/data\/master\/delaney.csv","4977b836":"import pandas as pd","d513ae0f":"sol = pd.read_csv('delaney.csv')\nsol","e1a92f61":"sol.SMILES","89edc9ba":"sol.SMILES[0]","ff511168":"from rdkit import Chem","9778a1f7":"Chem.MolFromSmiles(sol.SMILES[0])","fc9f4886":"Chem.MolFromSmiles('ClCC(Cl)(Cl)Cl')","1b6febb7":"m = Chem.MolFromSmiles('ClCC(Cl)(Cl)Cl')","3b94c23a":"m.GetNumAtoms()","b0aa8015":"from rdkit import Chem","0fff1b74":"mol_list= []\nfor element in sol.SMILES:\n  mol = Chem.MolFromSmiles(element)\n  mol_list.append(mol)","3a2d22eb":"len(mol_list)","3cfc5607":"mol_list[:5]","6ad6d2a3":"mol_list2 = [Chem.MolFromSmiles(element) for element in sol.SMILES]","418684b6":"len(mol_list2)","08d8545b":"mol_list2[:5]","470cd6fe":"import numpy as np\nfrom rdkit.Chem import Descriptors","9bf4201c":"# Inspired by: https:\/\/codeocean.com\/explore\/capsules?query=tag:data-curation\n\ndef generate(smiles, verbose=False):\n\n    moldata= []\n    for elem in smiles:\n        mol=Chem.MolFromSmiles(elem) \n        moldata.append(mol)\n       \n    baseData= np.arange(1,1)\n    i=0  \n    for mol in moldata:        \n       \n        desc_MolLogP = Descriptors.MolLogP(mol)\n        desc_MolWt = Descriptors.MolWt(mol)\n        desc_NumRotatableBonds = Descriptors.NumRotatableBonds(mol)\n           \n        row = np.array([desc_MolLogP,\n                        desc_MolWt,\n                        desc_NumRotatableBonds])   \n    \n        if(i==0):\n            baseData=row\n        else:\n            baseData=np.vstack([baseData, row])\n        i=i+1      \n    \n    columnNames=[\"MolLogP\",\"MolWt\",\"NumRotatableBonds\"]   \n    descriptors = pd.DataFrame(data=baseData,columns=columnNames)\n    \n    return descriptors","497a0784":"df = generate(sol.SMILES)\ndf","4217def0":"m = Chem.MolFromSmiles('COc1cccc2cc(C(=O)NCCCCN3CCN(c4cccc5nccnc54)CC3)oc21')","60b84dfb":"aromatic_atoms = [m.GetAtomWithIdx(i).GetIsAromatic() for i in range(m.GetNumAtoms())]\naromatic_atoms","ec5b675b":"def AromaticAtoms(m):\n  aromatic_atoms = [m.GetAtomWithIdx(i).GetIsAromatic() for i in range(m.GetNumAtoms())]\n  aa_count = []\n  for i in aromatic_atoms:\n    if i==True:\n      aa_count.append(1)\n  sum_aa_count = sum(aa_count)\n  return sum_aa_count","b9114a23":"AromaticAtoms(m)","4027ab6f":"desc_AromaticAtoms = [AromaticAtoms(element) for element in mol_list]\ndesc_AromaticAtoms","7e725a51":"m = Chem.MolFromSmiles('COc1cccc2cc(C(=O)NCCCCN3CCN(c4cccc5nccnc54)CC3)oc21')\nDescriptors.HeavyAtomCount(m)","b6b4b8f9":"desc_HeavyAtomCount = [Descriptors.HeavyAtomCount(element) for element in mol_list]\ndesc_HeavyAtomCount","411a9cbe":"m = Chem.MolFromSmiles('COc1cccc2cc(C(=O)NCCCCN3CCN(c4cccc5nccnc54)CC3)oc21')\nAromaticAtoms(m)\/Descriptors.HeavyAtomCount(m)","ada3efeb":"desc_AromaticProportion = [AromaticAtoms(element)\/Descriptors.HeavyAtomCount(element) for element in mol_list]\ndesc_AromaticProportion","c2a50f33":"df_desc_AromaticProportion = pd.DataFrame(desc_AromaticProportion, columns=['AromaticProportion'])\ndf_desc_AromaticProportion","cac09c38":"df","09fe7345":"df_desc_AromaticProportion","7db631cf":"X = pd.concat([df,df_desc_AromaticProportion], axis=1)\nX","d7af35b6":"sol.head()","3586ecc9":"Y = sol.iloc[:,1]\nY","1747fabe":"from sklearn.model_selection import train_test_split","8eca6d7f":"X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2)","fae39730":"from sklearn import linear_model\nfrom sklearn.metrics import mean_squared_error, r2_score","21d97ed3":"model = linear_model.LinearRegression()\nmodel.fit(X_train, Y_train)","aca64975":"Y_pred_train = model.predict(X_train)","74a7251b":"print('Coefficients:', model.coef_)\nprint('Intercept:', model.intercept_)\nprint('Mean squared error (MSE): %.2f'\n      % mean_squared_error(Y_train, Y_pred_train))\nprint('Coefficient of determination (R^2): %.2f'\n      % r2_score(Y_train, Y_pred_train))","1f5d6075":"Y_pred_test = model.predict(X_test)","ff6c750b":"print('Coefficients:', model.coef_)\nprint('Intercept:', model.intercept_)\nprint('Mean squared error (MSE): %.2f'\n      % mean_squared_error(Y_test, Y_pred_test))\nprint('Coefficient of determination (R^2): %.2f'\n      % r2_score(Y_test, Y_pred_test))","86eab052":"print('LogS = %.2f %.2f LogP %.4f MW %.4f RB %.2f AP' % (model.intercept_, model.coef_[0], model.coef_[1], model.coef_[2], model.coef_[3] ) )","300f79e4":"yintercept = '%.2f' % model.intercept_\nLogP = '%.2f LogP' % model.coef_[0]\nMW = '%.4f MW' % model.coef_[1]\nRB = '%.4f RB' % model.coef_[2]\nAP = '%.2f AP' % model.coef_[3]","544fa08f":"print('LogS = ' + \n      ' ' + \n      yintercept + \n      ' ' + \n      LogP + \n      ' ' + \n      MW + \n      ' ' + \n      RB + \n      ' ' + \n      AP)","899aacfc":"full = linear_model.LinearRegression()\nfull.fit(X, Y)","d2981fcb":"full_pred = model.predict(X)","4c1452f6":"print('Coefficients:', full.coef_)\nprint('Intercept:', full.intercept_)\nprint('Mean squared error (MSE): %.2f'\n      % mean_squared_error(Y, full_pred))\nprint('Coefficient of determination (R^2): %.2f'\n      % r2_score(Y, full_pred))","df15575f":"full_yintercept = '%.2f' % full.intercept_\nfull_LogP = '%.2f LogP' % full.coef_[0]\nfull_MW = '%.4f MW' % full.coef_[1]\nfull_RB = '+ %.4f RB' % full.coef_[2]\nfull_AP = '%.2f AP' % full.coef_[3]","f0c90c2b":"print('LogS = ' + \n      ' ' + \n      full_yintercept + \n      ' ' + \n      full_LogP + \n      ' ' + \n      full_MW + \n      ' ' + \n      full_RB + \n      ' ' + \n      full_AP)","fa971ae7":"import matplotlib.pyplot as plt","004b9c9c":"Y_train.shape, Y_pred_train.shape","c5140bdf":"Y_test.shape, Y_pred_test.shape","61219e05":"plt.figure(figsize=(5,11))\n\n# 2 row, 1 column, plot 1\nplt.subplot(2, 1, 1)\nplt.scatter(x=Y_train, y=Y_pred_train, c=\"#7CAE00\", alpha=0.3)\n\n# Add trendline\n# https:\/\/stackoverflow.com\/questions\/26447191\/how-to-add-trendline-in-python-matplotlib-dot-scatter-graphs\nz = np.polyfit(Y_train, Y_pred_train, 1)\np = np.poly1d(z)\nplt.plot(Y_test,p(Y_test),\"#F8766D\")\n\nplt.ylabel('Predicted LogS')\n\n\n# 2 row, 1 column, plot 2\nplt.subplot(2, 1, 2)\nplt.scatter(x=Y_test, y=Y_pred_test, c=\"#619CFF\", alpha=0.3)\n\nz = np.polyfit(Y_test, Y_pred_test, 1)\np = np.poly1d(z)\nplt.plot(Y_test,p(Y_test),\"#F8766D\")\n\nplt.ylabel('Predicted LogS')\nplt.xlabel('Experimental LogS')\n\nplt.savefig('plot_vertical_logS.png')\nplt.savefig('plot_vertical_logS.pdf')\nplt.show()","ebe456af":"plt.figure(figsize=(11,5))\n\n# 1 row, 2 column, plot 1\nplt.subplot(1, 2, 1)\nplt.scatter(x=Y_train, y=Y_pred_train, c=\"#7CAE00\", alpha=0.3)\n\nz = np.polyfit(Y_train, Y_pred_train, 1)\np = np.poly1d(z)\nplt.plot(Y_test,p(Y_test),\"#F8766D\")\n\nplt.ylabel('Predicted LogS')\nplt.xlabel('Experimental LogS')\n\n# 1 row, 2 column, plot 2\nplt.subplot(1, 2, 2)\nplt.scatter(x=Y_test, y=Y_pred_test, c=\"#619CFF\", alpha=0.3)\n\nz = np.polyfit(Y_test, Y_pred_test, 1)\np = np.poly1d(z)\nplt.plot(Y_test,p(Y_test),\"#F8766D\")\n\nplt.xlabel('Experimental LogS')\n\nplt.savefig('plot_horizontal_logS.png')\nplt.savefig('plot_horizontal_logS.pdf')\nplt.show()","c7859bca":"! ls -l","77d3b67f":"#### **Use entire dataset for model training (For Comparison)**","e9cbbff8":"The first element from the **SMILES** column of the **sol** dataframe.","d637683c":"Let's combine the 2 dataframes to produce the **X** matrix","04774c15":"---","d8acc50f":"##### 3.2.1.1. Number of aromatic atoms\n\nHere, we will create a custom function to calculate the **Number of aromatic atoms**. With this descriptor we can use it to subsequently calculate the AP descriptor.","68853e71":"### **2.4. Convert a molecule from the SMILES string to an rdkit object**","11a2239b":"#### **3.1.2. Method 2**","07c3c40f":"Computing for a single molecule.","893cdfdd":"## **3. Calculate molecular descriptors in rdkit**","156a9804":"The same equation can also be produced with the following code (which breaks up the previous one-line code into several comprehensible lines.","3a95a022":"The work of Delaney$^1$ provided the following linear regression equation:\n\n> LogS = 0.16 -  0.63 cLogP - 0.0062 MW + 0.066 RB - 0.74 AP\n\nThe reproduction by Pat Walters$^2$ provided the following:\n\n> LogS = 0.26 -  0.74 LogP - 0.0066 MW + 0.0034 RB - 0.42 AP\n\nThis notebook's reproduction gave the following equation:\n\n* Based on the Train set\n> LogS = 0.30 -0.75 LogP - .0066 MW -0.0041 RB - 0.36 AP\n\n* Based on the Full dataset\n> LogS =  0.26 -0.74 LogP - 0.0066 + MW 0.0032 RB - 0.42 AP","7ad9c111":"#### **3.1.1. Method 1**","40f05f06":"### **Predicts the X_train**","bf49c0ae":"### **3.3. X matrix (Combining all computed descriptors into 1 dataframe)**","f6770f73":"### **3.4. Y matrix**","768eaf5c":"### **Linear Regression Equation**","9eeb2c4e":"### **2.3. Examining the SMILES data**","acff5913":"## **Reference**\n\n1. John S. Delaney. [ESOL:? Estimating Aqueous Solubility Directly from Molecular Structure](https:\/\/pubs.acs.org\/doi\/10.1021\/ci034243x). ***J. Chem. Inf. Comput. Sci.*** 2004, 44, 3, 1000-1005.\n\n2. Pat Walters. [Predicting Aqueous Solubility - It's Harder Than It Looks](http:\/\/practicalcheminformatics.blogspot.com\/2018\/09\/predicting-aqueous-solubility-its.html). ***Practical Cheminformatics Blog***\n\n3. Bharath Ramsundar, Peter Eastman, Patrick Walters, and Vijay Pande. [Deep Learning for the Life Sciences: Applying Deep Learning to Genomics, Microscopy, Drug Discovery, and More](https:\/\/learning.oreilly.com\/library\/view\/deep-learning-for\/9781492039822\/), O'Reilly, 2019.\n\n4. [Supplementary file](https:\/\/pubs.acs.org\/doi\/10.1021\/ci034243x) from Delaney's ESOL:? Estimating Aqueous Solubility Directly from Molecular Structure.","f51fbcee":"### **3.2. Calculate molecular descriptors**\n\nTo predict **LogS** (log of the aqueous solubility), the study by Delaney makes use of 4 molecular descriptors:\n1. **cLogP** *(Octanol-water partition coefficient)*\n2. **MW** *(Molecular weight)*\n3. **RB** *(Number of rotatable bonds)*\n4. **AP** *(Aromatic proportion = number of aromatic atoms \/ total number of heavy atoms)*\n\nUnfortunately, rdkit readily computes the first 3. As for the AP descriptor, we will calculate this by manually computing the ratio of the *number of aromatic atoms* to the *total number of heavy atoms* which rdkit can compute.","d118ce11":"#### **3.2.2. Aromatic proportion**","a3dac728":"Computing for molecules in the entire dataset.","b378d2d9":"#### **3.2.1. LogP, MW and RB**","7b2ab01a":"## **Linear Regression Model**","ce3faca3":"---","f0062df3":"### **3.1. Convert list of molecules to rdkit object**","2fb951db":"### **2.2. Read in the dataset**","03071549":"## **1. Install rdkit**","ee6f8876":"Computing for molecules in the entire dataset.","c8af8798":"Assigning the second column (index 1) to the Y matrix","9680c497":"Chemical structures are encoded by a string of text known as **SMILES** which is an acronym for **Simplified Molecular-Input Line-Entry System**.","87c3b4e1":"### **Horizontal plot**","1628af7b":"### **Predicts the X_test**","5d83f038":"### **Quick check of the variable dimensions of Train and Test sets**","b11ee233":"## **2. Delaney's solubility dataset**\n\nThe original [Delaney's dataset](https:\/\/pubs.acs.org\/doi\/10.1021\/ci034243x) available as a [Supplementary file](https:\/\/pubs.acs.org\/doi\/10.1021\/ci034243x)$^4$. The full paper is entitled [ESOL:? Estimating Aqueous Solubility Directly from Molecular Structure](https:\/\/pubs.acs.org\/doi\/10.1021\/ci034243x).$^1$","96bd4a68":"### **2.5. Working with rdkit object**","a846f4dc":"## **Scatter plot of experimental vs. predicted LogS**","af633254":"##### 3.2.1.2. **Number of heavy atoms**\n\nHere, we will use an existing function for calculating the Number of heavy atoms.","69ed1774":"### **2.1. Download the dataset**","8ce39243":"Computing for a single molecule.","f1f9e128":"### **Vertical plot**","2d711a6e":"Computing for a single molecule.","f7ccdb17":"Computing for molecules in the entire dataset.","a59d6910":"## **Data split**","444ff9b6":"##### **3.2.1.3. Computing the Aromatic Proportion (AP) descriptor**","a1967b00":"# **Cheminformatics in Python: Predicting Solubility of Molecules | End-to-End Data Science Project** \n\n\nIn this Jupyter notebook, we will dive into the world of Cheminformatics which lies at the interface of Informatics and Chemistry. We will be reproducing a research article (by John S. Delaney$^1$) by applying Linear Regression to predict the solubility of molecules (i.e. solubility of drugs is an important physicochemical property in Drug discovery, design and development).\n\nThis idea for this notebook was inspired by the excellent blog post by Pat Walters$^2$ where he reproduced the linear regression model with similar degree of performance as that of Delaney. This example is also briefly described in the book ***Deep Learning for the Life Sciences: Applying Deep Learning to Genomics, Microscopy, Drug Discovery, and More***.$^3$","d1338938":"#### **Our linear regression equation**"}}