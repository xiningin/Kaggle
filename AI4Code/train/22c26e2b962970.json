{"cell_type":{"4cc7a5b9":"code","1b957bdf":"code","80508d6f":"code","e2d7a221":"code","1a220d5b":"code","d2e914e8":"code","e28a4ef6":"code","fd94bb10":"code","57073804":"code","08856d2d":"code","59e5a331":"code","80bde5de":"code","3c6363b1":"code","bba8ba3e":"code","c70b21c1":"code","581e6e28":"code","c3a0cefb":"code","f60c7f4f":"code","4bd6550b":"code","59d67ced":"code","4d918235":"code","61b0d0b5":"code","c45116ad":"code","cd0a9441":"code","5dc6d567":"code","dcab30d6":"code","46e8ccc4":"code","1c94b61b":"code","7c325bc5":"code","034e8016":"code","dd68e8db":"code","1b6abf24":"code","dc4201d7":"code","11988204":"code","392523b6":"code","c34e3cef":"code","e315ac30":"code","c077c038":"code","1eedf4f3":"code","77246b20":"code","54a0d42f":"code","59d55986":"code","735bb36d":"code","e46d9a99":"code","1dc3bcdb":"code","e73ec509":"code","ccb595fe":"code","3b118063":"code","837a7019":"code","a77e8423":"markdown","3547a84d":"markdown","734dc473":"markdown","8af3f95a":"markdown","962cf966":"markdown","f5135207":"markdown","48c9ce94":"markdown","6548b2d1":"markdown","9cd6d41f":"markdown","8eec9e39":"markdown","a7916f86":"markdown","12e29ff8":"markdown","6af4b12a":"markdown","0a7309da":"markdown","8e2f32f4":"markdown","1d1d987f":"markdown","55037663":"markdown","bc2f7b58":"markdown","f1602ae2":"markdown","4f65e9fe":"markdown","691a0c9a":"markdown","d8bfcef6":"markdown","f9019cd3":"markdown","ca5da721":"markdown","4a94cae7":"markdown","c51dd847":"markdown","4f289480":"markdown","8a5ce3de":"markdown","20898ca9":"markdown","bcdbd5e8":"markdown","5a8844f0":"markdown","389f602b":"markdown","c0e61af4":"markdown","2b0097e9":"markdown","f01e1e90":"markdown","b53ddea6":"markdown","dd50d651":"markdown","4ea27424":"markdown","70a5a095":"markdown","f8fd6a9c":"markdown","5612225d":"markdown","c8069937":"markdown","6e110b0c":"markdown","7f40cb66":"markdown","a34f148d":"markdown","2bd9123a":"markdown"},"source":{"4cc7a5b9":"#Imports\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns # import seaborn\nimport matplotlib.pyplot as plt\n\nfrom subprocess import check_output\nprint(check_output([\"ls\", \"..\/input\"]).decode(\"utf8\"))\n\nimport warnings\nwarnings.filterwarnings('ignore')","1b957bdf":"titanic_train = pd.read_csv('..\/input\/train.csv')\ntitanic_test = pd.read_csv('..\/input\/test.csv')","80508d6f":"titanic_train.head(5)","e2d7a221":"titanic_train.info()","1a220d5b":"titanic_test.info()","d2e914e8":"titanic_train.describe()","e28a4ef6":"titanic_train.describe(include=['O'])","fd94bb10":"print(\"Age broken down by P-class\")\ntitanic_train.groupby('Pclass').mean()[['Age']]","57073804":"titanic_train.loc[titanic_train.Age.isnull(), 'Age'] = titanic_train.groupby('Pclass')['Age'].transform('mean')\ntitanic_test.loc[titanic_test.Age.isnull(), 'Age'] = titanic_test.groupby('Pclass')['Age'].transform('mean')","08856d2d":"titanic_train.iloc[[5, 17]]","59e5a331":"titanic_train = titanic_train.drop('Cabin', axis=1)\ntitanic_test = titanic_test.drop('Cabin', axis=1)","80bde5de":"titanic_train['Embarked'].fillna(titanic_train['Embarked'].mode()[0], inplace=True)\ntitanic_test['Fare'].fillna(titanic_test['Fare'].median(), inplace = True)","3c6363b1":"print('Training Data Null Values')\nprint(titanic_train.isnull().sum())\nprint(\"-\" * 30)\nprint('Test Data Null Values')\nprint(titanic_test.isnull().sum())","bba8ba3e":"titanic_train.head()","c70b21c1":"sns.countplot(x='Survived', data=titanic_train)","581e6e28":"sns.boxplot(x = 'Survived', y = 'Fare', data = titanic_train)","c3a0cefb":"titanic_train.groupby('Survived').mean()[['Fare']]","f60c7f4f":"titanic_train.loc[titanic_train['Fare'] > 500, :]","4bd6550b":"titanic_no_500s = titanic_train.loc[titanic_train['Fare'] < 500, :]\nsns.boxplot(x = 'Survived', y = 'Fare', data = titanic_no_500s, palette = 'RdBu_r')\ntitanic_no_500s.groupby('Survived').mean()[['Fare']]","59d67ced":"sns.countplot(x = 'Sex', data = titanic_train, hue = 'Survived')","4d918235":"hist = sns.distplot(titanic_train['Age'], color='b', bins=30, kde=False)\nhist.set(xlim=(0, 100), title = \"Distribution of Passenger Age's\")","61b0d0b5":"titanic_train.Age.describe()","c45116ad":"age_box = sns.boxplot(y = 'Age', x = 'Survived',data = titanic_train, palette='coolwarm')\nage_box.set(title='Boxplot of Age')","cd0a9441":"titanic_train.groupby(['Embarked']).count()","5dc6d567":"sns.countplot(x = 'Embarked', hue = 'Survived', data=titanic_train)","dcab30d6":"sns.set_style('whitegrid')\nsns.countplot(x='Survived',hue='Pclass', data=titanic_train, palette = 'rainbow')","46e8ccc4":"#Make copies of both dataframes.\ntraindf = titanic_train.copy()\ntestdf = titanic_test.copy()","1c94b61b":"#Create list of both data frames to apply similar functions to.\nall_data = [traindf, testdf]\n","7c325bc5":"#Drop name and ticket columns\nfor dat in all_data:\n    dat.drop(['Name', 'Ticket'], axis=1, inplace=True)","034e8016":"traindf.describe()['Fare']","dd68e8db":"#Perform operation on both frames\nfor dat in all_data:\n    \n    #Create bins to separate fares\n    bins = (0, 8, 15, 31, 515)\n\n    #Assign group names to bins\n    group_names = ['Fare_Group_1', 'Fare_Group_2', 'Fare_Group_3', 'Fare_Group_4']\n\n    #Bin the Fare column based on bins\n    categories = pd.cut(dat.Fare, bins, labels=group_names)\n    \n    #Assign bins to column\n    dat['Fare'] = categories\n","1b6abf24":"traindf.describe()['Age']","dc4201d7":"#Perform operation on both frames\nfor dat in all_data:\n    \n    #Create bins to separate fares\n    bins = (0, 15, 30, 45, 60, 75, 90)\n\n    #Assign group names to bins\n    group_names = ['Child', 'Young Adult', 'Adult', 'Experienced', 'Senior', 'Elderly']\n\n    #Bin the Fare column based on bins\n    categories = pd.cut(dat.Age, bins, labels=group_names)\n    \n    #Assign bins to column\n    dat['Age'] = categories","11988204":"traindf.head()","392523b6":"for dat in all_data:\n    dat['Fam_Size'] = dat['SibSp'] + dat['Parch']","c34e3cef":"traindf = pd.get_dummies(traindf)\ntraindf.head()","e315ac30":"testdf = pd.get_dummies(testdf)\ntestdf.head()","c077c038":"#Import libraries\nfrom sklearn.metrics import confusion_matrix #confusion matrix\nfrom sklearn.linear_model import LogisticRegression #Logistic Regression\nfrom sklearn.ensemble import RandomForestClassifier #Random Forest Classifier\nfrom sklearn.svm import SVC #Support Vector Machine\nfrom sklearn.preprocessing import StandardScaler #For scaling data\nfrom sklearn.neighbors import KNeighborsClassifier #KNN\nfrom sklearn.model_selection import train_test_split #Split data into training and validation sets.\nfrom sklearn.metrics import accuracy_score  #Accuracy Score","1eedf4f3":"#Split data into training and validation set\nX = traindf.drop(columns=['PassengerId', 'Survived'], axis=1)\ny = traindf['Survived']\n\n#Note they are labeled as test sets but I'm treating them as validation data sets.\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30)","77246b20":"results = pd.DataFrame(columns=['Validation'], index=['Logistic Regression', 'Support Vector Machine', 'KNN', 'Random Forest'])","54a0d42f":"def log_reg(X_train, X_test, y_train, y_test):\n    #Create logmodel object\n    logmodel = LogisticRegression(C=.01)\n\n    #fit logistic regression model\n    logmodel.fit(X_train, y_train)\n\n    #Make predictions on validation data\n    predictions = logmodel.predict(X_test)\n    \n    #Print Statistics\n    print(accuracy_score(y_test, predictions))\n    \n    #Return predictions\n    return accuracy_score(y_test, predictions)","59d55986":"#Get prediction accuracy for model.\nLR_preds = log_reg(X_train, X_test, y_train, y_test)\n\n#Add to dataframe.\nresults.loc['Logistic Regression', 'Validation'] = LR_preds","735bb36d":"def svm(X_train, X_test, y_train, y_test):\n    \n    #Scale data\n    #scaler = StandardScaler()\n    #scaler.fit(X_train)\n    #X_train = scaler.transform(X_train)\n    #X_test = scaler.transform(X_test)\n    \n    #Create list of c values to try\n    c_vals = list(range(1, 100))\n    \n    #Accuracy list\n    accuracy = [0 for i in range(99)]\n    \n    #Loop through c_values\n    for i, c in enumerate(c_vals):\n        #Create support vector machine object\n        svc_model = SVC(C=c)\n        \n        #fit support vector machine model\n        svc_model.fit(X_train, y_train)\n        \n        #Make predictions\n        predictions = svc_model.predict(X_test)\n        \n        #add accuracy score to accuracy list\n        accuracy[i] = accuracy_score(y_test, predictions)\n    \n    print(\"Best C Value:\", c_vals[accuracy.index(max(accuracy))])\n    print(accuracy)\n    print(\"Prediction Accuracy: \", max(accuracy))\n    \n    return max(accuracy)\n        \n        ","e46d9a99":"#Get support vector machine results\nsvm_preds = svm(X_train, X_test, y_train, y_test)\n\n#Add to dataframe.\nresults.loc['Support Vector Machine', 'Validation'] = svm_preds\nresults.head()\n","1dc3bcdb":"def knn(X_train, X_test, y_train, y_test):\n    \n    #Scale data\n    scaler = StandardScaler()\n    scaler.fit(X_train)\n    X_train = scaler.transform(X_train)\n    X_test = scaler.transform(X_test)\n    \n    #Create list of c values to try\n    ks = [i + 1 for i in range(20)]\n    \n    #Accuracy list\n    accuracy = [0 for i in range(20)]\n    \n    #Loop through c_values\n    for i, k in enumerate(ks):\n        #Create support vector machine object\n        knn = KNeighborsClassifier(n_neighbors = k)\n        \n        #fit support vector machine model\n        knn.fit(X_train, y_train)\n        \n        #Make predictions\n        predictions = knn.predict(X_test)\n        \n        #add accuracy score to accuracy list\n        accuracy[i] = accuracy_score(y_test, predictions)\n    \n    print(ks)\n    print(accuracy)\n    print(\"Best k Value:\", ks[accuracy.index(max(accuracy))])\n    \n    print(\"Prediction Accuracy: \", max(accuracy))\n    \n    return max(accuracy)","e73ec509":"knn_preds = knn(X_train, X_test, y_train, y_test)\nresults.loc['KNN', 'Validation'] = knn_preds\nresults.head()","ccb595fe":"from sklearn.decomposition import PCA","3b118063":"scaler = StandardScaler()\nscaler.fit(X)\ntest_feats = testdf.drop('PassengerId', axis=1)\nX = scaler.transform(X)\ntest_feats = scaler.transform(test_feats)\npca = PCA(n_components = 4)\npca.fit(X)\nx_train_pca = pca.transform(X)\nx_test_pca = pca.transform(test_feats)\nsvc_model = SVC(C = 1)\nsvc_model.fit(x_train_pca, y)\nsvm_predictions = svc_model.predict(x_test_pca)\noutput = pd.DataFrame({ 'PassengerId' : testdf['PassengerId'], 'Survived': svm_predictions })\noutput.to_csv('titanic-predictions-svm-pca.csv', index=False)\noutput\n","837a7019":"#svc_model = SVC(C = 1)\n#svc_model.fit(X, y)\n#svm_predictions = svc_model.predict(test_feats)\n#output = pd.DataFrame({ 'PassengerId' : testdf['PassengerId'], 'Survived': svm_predictions })\n#output.to_csv('titanic-predictions-svm.csv', index=False)\n","a77e8423":"Due to the large number of missing entires for the cabin column in both the training and testing dataset, I'm going to drop it from both.","3547a84d":"### Use one hot encoding to code categorical variables.","734dc473":"### Drop Name and Ticket Columns","8af3f95a":"Check out rows 5 and 17 to ensure age of ~25 got inputed for age in row 5 and ~29 was inputted for age in row 17. Looks good, and checking .info() method there are no missing values for age column.","962cf966":"Also because Embarked is only missing two entries from the training dataset and fare is only missing one entry from the test dataset I'm just going to impute these values with the mode and median value for each column respectively.","f5135207":"Looks like a majority of those who didn't survive were in the 3rd P-class. Would definitely be worth including as a feature in the model.","48c9ce94":"With the fare's of 500+ removed, the boxplots are more readable. The mean and median are definitely higher for those who survived and will include as a feaure for model training.","6548b2d1":"## Exploratory Data Analysis","9cd6d41f":"First step is to make copies of each dataframe","8eec9e39":"Let's take a look at the Age column","a7916f86":"## Some observations about the head of the data frame\n* Looks like there are 11 features and one response variable \"survived\".\n* PassengerID could represent the index of the data frame\n* Pclass looks like it could be a categorical variable\n* Cabin appears to have some missing data.","12e29ff8":"Conclusion: This model resulted in 78.947% accuracy which ranks in the top 1\/2 of submissions on the kaggle leaderboard. As this was intended to be a \nsimple notebook to reinforce learning concepts I'm pretty happy with this result. As I continue to improve my feature engineering skills and understand the workings of more advanced machine learning models I will update this kernel to try and improve upon the body of work that is here.\n\nIf you  made it this far, thanks for reading! Any feedback is appreciated :)","6af4b12a":"There is a class imbalance meaning that more people did not survive the titanic than did survive it in our training dataset.","0a7309da":"Embarked Column","8e2f32f4":"Because the goal is to predict the Survived column I want to take a look at the class balance in that column","1d1d987f":"# 1. Data Cleaning","55037663":"Want to look at how the price of tickets bought varied by the age of the people on board.","bc2f7b58":"Based on the description and histogram our passengers are roughly normally distributed with a mean of 29 and median of 26 years of age respectively. Looking at the boxplots of ages of passengers who did and didn't survive the distributions look relatively similar. Based on this I'm debating including the age column in model training.","f1602ae2":"![](http:\/\/)Use SVM with C = 1 to make predictions on testing data.","4f65e9fe":"Now I want to take a look at the effect of male vs female passengers","691a0c9a":"# Machine Learning\nIn order to predict whether a passenger survived the titainc or not, a classification machine learning algorithm will be needed. I've decided for this kernel to try the following methods:\n* Logistic Regression\n* Support Vector Machine\n* K Nearest Neighbors\n\nThe steps I'm going to take to find the best model are outlined below\n1. Split data into training, validation, and test sets\n2. Train and fit each model to training data\n3. Test each model on validation data\n4. Pick model with highest prediction accuracy on validation set.\n5. Use model from step 4 on test dataset.","d8bfcef6":"Am going to try binning by every 15 years.","f9019cd3":"# Data Cleaning\nIn order to clean this dataset, I'd like to make sure that each column is free from NaN values and is of the correct type. As noted previously, the age, embarked, and cabin columns are all missing values.","ca5da721":"PClass column","4a94cae7":"A couple things here:\n* No repeated names\n* 3 different values for embarked","c51dd847":"### Create Family Size Feature. SibSp + Parch","4f289480":"### K Nearest Neighbors\nFirst create function to train, fit, and test K Nearest Neighbors model on. For KNN we will need to scale the input features.","8a5ce3de":"### Bin Fare Column\nNext I'm going to bin the fare column based on the summary statistics for that column","20898ca9":"Looks like the following columns have some missing values:\n\n* Age\n* Cabin - which aligns with the previous observation\n* Embarked","bcdbd5e8":"### 1. Split data into training and validation sets\nBecause we already have the test dataset provided to us, all we need to do is split the training dataset into a training and validation set.","5a8844f0":"The purpose of this kernel is to reinforce my understanding of using the logistic regression, k nearest neighbors and support vector machine to make predictions on a binary response. In addition to that, I'd like to get practice of completing an end to end machine learning project. This kernel contains the following sections:\n1. Data Cleaning\n2. Exploratory Data Analysis\n3. Feature Engineering\n4. Model training and selection using a training and validation data set.\n5. Submitting predictions.","389f602b":"### Logistic Regression\nFirst create function to train, fit, and test logistic regression model on validation data","c0e61af4":"### Bin Age Column","2b0097e9":"### 2. Train and fit each model to train, test on validaiton data.\nI will do this for each model listed above. The dataframe below will hold the validation results.","f01e1e90":"Looks like people who boarded from S were more likely to not survive than those who didn't board at S","b53ddea6":"## Feature Engineering","dd50d651":"Next I'm going to put the copied dataframes into a list so I can perform the same actions to both dataframes.","4ea27424":"I'm going to impute the age column based on the average age per passenger determined by the Pclass column for both the training and testing data sets because both of these columns contain missing data and less than 25% of the column is missing data. ","70a5a095":"Looking at this chart more male a larger proportion of male passengers didn't survive when compared to female. Will consider this as an important feature for model training and building.","f8fd6a9c":"Looks like the median ticket price is larger for those who survived. Average ticket price is much higher but is likely due to the outlier. Want to investigate this outlier. Look below and see that three individuals purchased tickets at a fare of $512. Money must have not been a problem for these folks!","5612225d":"### Support Vector Machine\nFirst create function to train, fit, and test support vector machine model on. For SVM we will need to scale the input features.\n","c8069937":"Let's take a look at the age column","6e110b0c":"Looks like some good cutoff points will be 0, 8, 15, 31, and 515 to include the max fare value of 512.","7f40cb66":"The test data set had missing values for the following columns\n* Age\n* Cabin - which aligns with the previous observation\n* Fare","a34f148d":"Looks like all columns are cleaned","2bd9123a":"Ensure all columns have no null values"}}