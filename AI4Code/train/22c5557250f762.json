{"cell_type":{"8a55570f":"code","ef097723":"code","726f8f1b":"code","24cd61c6":"code","763f8a10":"code","f8d31a08":"code","e0353510":"code","5cdb6332":"code","954f905b":"markdown","b204196e":"markdown","302534e0":"markdown","e3cce424":"markdown","3559a043":"markdown","28f42003":"markdown","4b6cf17c":"markdown"},"source":{"8a55570f":"class node:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None","ef097723":"root = node(1)\nroot.left = node(2)\nroot.right = node(3)","726f8f1b":"root","24cd61c6":"def inorder(node):\n    if node:\n        inorder(node.left)\n        print(node.val)\n        inorder(node.right)","763f8a10":"inorder(root)","f8d31a08":"def create_bst(array,min_index,max_index):\n    if max_index<min_index:\n        return None\n    mid = int((min_index+max_index)\/2)\n    root = node(array[mid])\n    leftbst = create_bst(array,min_index,mid-1)\n    rightbst = create_bst(array,mid+1,max_index)\n    root.left = leftbst\n    root.right = rightbst\n    return root\na = [2,4,5,6,7]\nroot = create_bst(a,0,len(a)-1)","e0353510":"inorder(root)","5cdb6332":"def isValidBST(node, minval, maxval):\n    if node:\n        # Base case\n        if node.val<=minval or node.val>=maxval:\n            return False\n        # Check the subtrees changing the min and max values\n        return isValidBST(node.left,minval,node.val) &    isValidBST(node.right,node.val,maxval)\n    return True\nisValidBST(root,-float('inf'),float('inf'))","954f905b":"# Creating a Binary Search Tree from a sorted\u00a0array\nWhat kind of coders will we be if we need to create a tree piece by piece manually as we did above?\u00a0\nSo can we create a  BST from a sorted array of unique elements?","b204196e":"We check the subtrees recursively if they satisfy the Binary Search tree property or not. At each recursive call, we change the minval or maxval for the call to provide the function with the range of allowed values for the subtree.","302534e0":"# Handling Trees in Data Science Algorithmic Interview","e3cce424":"# Inorder Tree Traversal:\nThere are a variety of ways to traverse a tree, but I find the inorder traversal to be most intuitive. When we do an inorder traversal on the root node on a Binary Search tree, it visits\/prints the node in ascending order.","3559a043":"Trees are inherently recursive in nature and so we use recursion here. We take the mid element of the array and assign it as the node. We then apply the create_bst function to the left part of the array and assign it to node.left and do the same with the right part of the array.\nAnd we get our BST. Have we done it right? We can check it by creating the BST and then doing an inorder traversal.","28f42003":"# Let's check if our tree is\u00a0BST\nBut again what sort of coders are we if we need to print all the elements and check manually for the BST property being satisfied?\nAnd here is a simple code to check if our BST is valid or not.","4b6cf17c":"By definition, a tree is made up of nodes. So we start by defining the node class which we will use to create nodes. Our node class is pretty simple as it holds value for a node, the location of the left child and the location of the right child.\n"}}