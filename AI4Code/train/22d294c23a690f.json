{"cell_type":{"c2cdf89e":"code","16ace9c8":"code","428a5a99":"code","d9302242":"code","0c60f594":"code","64257c2a":"code","7b5cdb8f":"code","566b0b50":"code","f2ce9f33":"code","564a9617":"code","ba0f56a9":"code","6799dadc":"code","700eb3fc":"markdown","e38913b8":"markdown"},"source":{"c2cdf89e":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import Pipeline\nfrom xgboost import XGBClassifier\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder, FunctionTransformer\nfrom sklearn import metrics","16ace9c8":"df = pd.read_csv('\/kaggle\/input\/ethereum-frauddetection-dataset\/transaction_dataset.csv')\ndf.columns = [x.lower() for x in df.columns]","428a5a99":"cols_to_drop = [\n    ' erc20 most sent token type',\n    ' erc20_most_rec_token_type',\n    'address',\n    'index',\n    'unnamed: 0'\n]\n\nfeatures = [x for x in df.columns if (x != 'flag' and x not in cols_to_drop)]\n\nunique_values = df.nunique()\n\nfeatures = [x for x in features if x in unique_values.loc[(unique_values>1)]]\n","d9302242":"df[features].info()","0c60f594":"from sklearn.base import BaseEstimator, TransformerMixin\n\n\nclass BasePipeStep(BaseEstimator, TransformerMixin):\n    \n    def __init__(self, columns=[]):\n        self.columns = columns\n        \n    def fit(self, X, y=None):\n        return self\n    \n    def transform(self, X):\n        X = X.copy()\n        return X\n    \nclass SelectColumns(BasePipeStep):\n    \n    def transform(self, X):\n        X = X.copy()\n        return X[self.columns]\n    \nclass FillNumericData(BasePipeStep):\n    \n    def fit(self, X, y=None):\n        self.means = { col: X[col].mean() for col in self.columns}\n        return self\n        \n    def transform(self, X):\n        X = X.copy()\n        for col in self.columns:\n            X[col] = X[col].fillna(self.means[col])\n        return X\n\n\nclass ScaleNumeric(BasePipeStep):\n    \n    def fit(self, X, y=None):\n        self.scaler = StandardScaler()\n        self.scaler.fit(X[self.columns])\n        return self\n        \n    def transform(self, X):\n        X = X.copy()\n        X[self.columns] = self.scaler.transform(X[self.columns])\n        return X\n\nclass GetValues(BasePipeStep):\n    \n    def transform(self, X):\n        X = X.copy()\n        return X.values","64257c2a":"from sklearn.pipeline import Pipeline\npreprocessing = Pipeline([\n    ('feature_selection', SelectColumns(features)),\n    ('fill_missing', FillNumericData(features)),\n    ('standard_scaling', ScaleNumeric(features)),\n    ('returnValues', GetValues())\n])","7b5cdb8f":"from keras.utils import to_categorical\n\nX = df[features]\ny = df['flag']\ny = to_categorical(y)\n\n\nX_train, X_test, y_train, y_test = train_test_split(\n     X, y, test_size=0.33, random_state=42)","566b0b50":"X_train = preprocessing.fit_transform(X_train)\nX_test = preprocessing.transform(X_test)","f2ce9f33":"from keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras import Input\n#create model\nmodel = Sequential()\n#add model layers\nmodel.add(Input(shape=(len(features),)))\n\nmodel.add(Dense(len(features), activation='relu'))\nmodel.add(Dense(20, activation='relu'))\nmodel.add(Dense(5, activation='relu'))\nmodel.add(Dense(2, activation='softmax'))\nmodel.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])\nmodel.summary()","564a9617":"model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=10)","ba0f56a9":"from sklearn import metrics\ntest_prediction = [np.argmax(x) for x in model.predict(X_test)]\n\nacc = metrics.accuracy_score(test_prediction, [np.argmax(y) for y in y_test])\n\nprint(f'Accuracy: {acc:,.2%}')","6799dadc":"\nscore = metrics.roc_auc_score([np.argmax(y) for y in y_test], model.predict(X_test)[:,1])\n\nprint(f'Area under ROC of Model On Test Set - {score:,.2%}')","700eb3fc":"# Load data","e38913b8":"# Ethereum Fraud Detection\n\nBuilding a DNN using Keras and a preprocessing pipeline. Note that we got worse accuracy using this than a XGboost model [here](https:\/\/www.kaggle.com\/stuartday274\/basic-xgb-model) but was a fun learning experience. If anyone has any pointers to improve the accuracy I'd love to hear them :) \n\nHere is a description of the rows of the dataset:\n- Index: the index number of a row\n- Address: the address of the ethereum account\n- FLAG: whether the transaction is fraud or not\n- Avg min between sent tnx: Average time between sent transactions for account in minutes\n- Avgminbetweenreceivedtnx: Average time between received transactions for account in minutes\n- TimeDiffbetweenfirstand_last(Mins): Time difference between the first and last transaction\n- Sent_tnx: Total number of sent normal transactions\n- Received_tnx: Total number of received normal transactions\n- NumberofCreated_Contracts: Total Number of created contract transactions\n- UniqueReceivedFrom_Addresses: Total Unique addresses from which account received transactions\n- UniqueSentTo_Addresses20: Total Unique addresses from which account sent transactions\n- MinValueReceived: Minimum value in Ether ever received\n- MaxValueReceived: Maximum value in Ether ever received\n- AvgValueReceived5Average value in Ether ever received\n- MinValSent: Minimum value of Ether ever sent\n- MaxValSent: Maximum value of Ether ever sent\n- AvgValSent: Average value of Ether ever sent\n- MinValueSentToContract: Minimum value of Ether sent to a contract\n- MaxValueSentToContract: Maximum value of Ether sent to a contract\n- AvgValueSentToContract: Average value of Ether sent to contracts\n- TotalTransactions(IncludingTnxtoCreate_Contract): Total number of transactions\n- TotalEtherSent:Total Ether sent for account address\n- TotalEtherReceived: Total Ether received for account address\n- TotalEtherSent_Contracts: Total Ether sent to Contract addresses\n- TotalEtherBalance: Total Ether Balance following enacted transactions\n- TotalERC20Tnxs: Total number of ERC20 token transfer transactions\n- ERC20TotalEther_Received: Total ERC20 token received transactions in Ether\n- ERC20TotalEther_Sent: Total ERC20token sent transactions in Ether\n- ERC20TotalEtherSentContract: Total ERC20 token transfer to other contracts in Ether\n- ERC20UniqSent_Addr: Number of ERC20 token transactions sent to Unique account addresses\n- ERC20UniqRec_Addr: Number of ERC20 token transactions received from Unique addresses\n- ERC20UniqRecContractAddr: Number of ERC20token transactions received from Unique contract addresses\n- ERC20AvgTimeBetweenSent_Tnx: Average time between ERC20 token sent transactions in minutes\n- ERC20AvgTimeBetweenRec_Tnx: Average time between ERC20 token received transactions in minutes\n- ERC20AvgTimeBetweenContract_Tnx: Average time ERC20 token between sent token transactions\n- ERC20MinVal_Rec: Minimum value in Ether received from ERC20 token transactions for account\n- ERC20MaxVal_Rec: Maximum value in Ether received from ERC20 token transactions for account\n- ERC20AvgVal_Rec: Average value in Ether received from ERC20 token transactions for account\n- ERC20MinVal_Sent: Minimum value in Ether sent from ERC20 token transactions for account\n- ERC20MaxVal_Sent: Maximum value in Ether sent from ERC20 token transactions for account\n- ERC20AvgVal_Sent: Average value in Ether sent from ERC20 token transactions for account\n- ERC20UniqSentTokenName: Number of Unique ERC20 tokens transferred\n- ERC20UniqRecTokenName: Number of Unique ERC20 tokens received\n- ERC20MostSentTokenType: Most sent token for account via ERC20 transaction\n- ERC20MostRecTokenType: Most received token for account via ERC20 transactions"}}