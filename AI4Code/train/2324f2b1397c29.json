{"cell_type":{"6e35f6ca":"code","c95e6ec9":"code","0ce304e7":"code","2a69c566":"markdown","a815a78c":"markdown","a55c5606":"markdown","3fa3217b":"markdown","42662a49":"markdown","5a4e75a8":"markdown"},"source":{"6e35f6ca":"# 1a - Knapsack 0-1 dengan pendekatan Dynamic Programming (DP) dalam waktu \ud835\udc42(\ud835\udc5b\ud835\udc4a)\n\n# Input:\n# W - kapasitas kantong (snapsack)\n# weight - array yang masing-masing elemennya mewakili berat terkait dengan n item\n# value - array yang masing-masing elemennya mewakili harga terkait dengan n item\n# Output: Total harga barang maksimal yang bisa didapatkan\n\ndef knapSack(W, weight, value):\n    n = len(value)\n    K = [[0 for x in range(W+1)] for x in range(n+1)] \n    \n    for i in range(n+1): \n        for w in range(W+1): \n            if i==0 or w==0: \n                K[i][w] = 0\n            elif weight[i-1] <= w: \n                K[i][w] = max(value[i-1] + K[i-1][w-weight[i-1]],  K[i-1][w]) \n            else: \n                K[i][w] = K[i-1][w] \n  \n    return K[n][W]\n\n# Contoh input:\nW = 50\nweight = [10, 20, 30]\nvalue = [60, 100, 120]\n\n# Hasil yang diharapkan:\n# 220, hasil penjumlahan value 100 + 120\nprint(\"Total harga barang maksimal yang bisa didapatkan adalah\", knapSack(W, weight, value)) ","c95e6ec9":"# Nomor 2 - Longest Common Increasing Subsequence (LCIS)\n\n# Input: Dua buah array arr1 dan arr2 yang berisi bilangan bulat\n# Output: Panjang dari LCIS\n\ndef LCIS(arr1, arr2):\n    n = len(arr1) \n    m = len(arr2)  \n    table = [0] * m\n    result = 0\n    \n    for j in range(m): \n        table[j] = 0\n\n    for i in range(n):\n        current = 0\n        for j in range(m): \n            if (arr1[i] == arr2[j]): \n                if (current + 1 > table[j]): \n                    table[j] = current + 1\n            if (arr1[i] > arr2[j]): \n                if (table[j] > current): \n                    current = table[j]\n  \n    for i in range(m): \n        if (table[i] > result): \n            result = table[i] \n  \n    return result\n\n# Contoh input:\narr1 =  [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3]\narr2 = [1, 4, 1, 4, 2, 1, 3, 5, 6, 2, 3, 7, 3, 0, 9, 5]\n\n# Hasil yang diharapkan:\n# 6, yang merupakan panjang dari [1, 4, 5, 6, 7, 9]\nprint(\"Panjang dari LCIS adalah\", LCIS(arr1, arr2))","0ce304e7":"# Nomor 3 - Longest Non-Overlapping Reverse Substring\n\n# Input: Sebuah string str\n# Output: Panjang substring terpanjang yang susunan asli dan susunan kebalikannya\n# muncul pada string str tanpa ada karakter yang overlap\n\ndef longestNonOverlappingReverse(str):\n    longest = 0\n\n    for i in range(len(str)):\n        for j in range(i + 1, len(str) + 1):\n            subString = str[i:j] \n            reversedSubstring = subString[::-1]\n            length = len(subString)\n            \n            if reversedSubstring in str:\n                if str.find(reversedSubstring, j) != -1:\n                    if length > longest:\n                        longest = length\n\n    return longest\n\n# Contoh input:\ns = \"RECURSE\"\n\n# Hasil yang diharapkan:\n# 2, untuk \"RE\" dan \"ER\"\nprint(\"Panjang substring adalah\", longestNonOverlappingReverse(s))","2a69c566":"# PR 4 Desain & Analisis Algoritma\n### Aviliani Pramestya (1606829402)\n### Hema Mitta Kalyani (1606827706)\n### DAA-A","a815a78c":"## 1b - Knapsack 0-1 dengan berat barang dapat berupa bilangan riil\nPendekatan DP yang telah dibuat sebelumnya **tidak dapat berjalan** jika berat barang (weight) merupakan bilangan riil. Hal ini disebabkan karena jika weight berupa bilangan riil, maka struktur data akan berat untuk menampung bilangan-bilangan yang infinit.\n\n\n**Penyelesaian** dari kasus tersebut dapat dilakukan dengan mengalikan bilangan riil dengan big number untuk mengubahnya menjadi integers. Selain itu, dapat dilakukan pembulatan dan memberikan batasan pada bilangan desimal yang digunakan. Adapun pendekatan lain yang dapat digunakan adalah linear programming.","a55c5606":"## 2 - Longest Common Increasing Subsequence (LCIS)\nPada algoritma di bawah ini, terdapat tiga loop yang sejajar. Loop tersebut masing-masing mengiterasi sebanyak m, n, dan m. Pada loop kedua, terdapat inner loop sebanyak m. Maka, kompleksitas dari algoritma di bawah ini dapat dituliskan sebagai O(mn+m) = O(mn).","3fa3217b":"## 3 - Longest Non-Overlapping Reverse Substring\nPada algoritma di bawah ini, pertama-tama dilakukan pengecekan terhadap semua substring. Setelah itu, dilakukan pengecekan terhadap kebalikan dari substring tersebut. Untuk mencari semua substring, dilakukan dua kali looping sebanyak n. Sedangkan untuk melakukan pengecekan kebalikan substring cukup menggunakan pengecekan konstan. Maka,kompleksitas dari algoritma di bawah ini adalah O(n^2).","42662a49":"## 1c - Knapsack 0-1 dengan berat increasing dan harga decreasing\n**Permasalahan** jika urutan dari \ud835\udc5b buah barang secara increasing berdasarkan berat sama dengan urutannya secara decreasing berdasarkan harga.\n\n**Pendekatan yang efisien** untuk permasalahan tersebut adalah dengan greedy algorithm. Greedy algorithm akan selalu memilih barang yang harganya paling tinggi sampai kapasitas knapsack terpenuhi.\nMisal i[1,...,n] adalah item dengan value v[1,...,n] dan weight w[1,...,n]. Misal W adalah kapasitas maksimum knapsack. Maka permasalahan dapat disimpulkan dalam dua poin, yaitu:\n* w1\u2264 w2\u2264 \u00b7 \u00b7 \u00b7 \u2264 wn\n* v1\u2265 v2\u2265 \u00b7 \u00b7 \u00b7 \u2265 vn\n\nMaka salah satu solusi yang bisa digunakan adalah sebagai berikut:\n\n    w=0 \/\/weight dari knapsack\n    S=\u2205 \/\/isi dari knapsack\n    for(i=1; i<=n; i++):\n        if(w + w[i] <= W):\n            w += w[i]\n            S = S U {i}\n\nAlgoritma tersebut berjalan dalam waktu linear, jadi kompleksitasnya adalah \ud835\udc42(\ud835\udc5b) dengan \ud835\udc5b adalah jumlah semua item.\n\nMisal S adalah subset optimal. Dalam S terkandung barang x dan barang y dimana berat y < berat x, dan harga y > harga x. Subset optimal akan menjadi S-x+y dengan total harga yang lebih tinggi dan berat yang lebih ringan. Pendekatan greedy akan selalu memilih harga yang paling tinggi.","5a4e75a8":"## 1a - Knapsack 0-1 dengan pendekatan Dynamic Programming (DP) dalam waktu \ud835\udc42(\ud835\udc5b\ud835\udc4a)\n**Permasalahan** tentang pengambilan \ud835\udc5a buah barang dari \ud835\udc5b buah barang untuk dimasukkan ke dalam sebuah kantong dengan kapasitas \ud835\udc4a sedemikian hingga total berat \ud835\udc5a buah barang tidak melebihi \ud835\udc4a dan diperoleh total harga barang yang maksimal.\n\n**Strategi** dilakukan dengan menghitung total weight dan value dari semua subset. Kemudian, gunakan subset yang memiliki total weight kurang dari sama dengan W. Dari semua subset tersebut, kemudian pilih yang memiliki value paling maksimal.\n\nUntuk mencari semua subset, ada 2 kemungkinan kasus untuk setiap item:\n1. Item tersebut termasuk ke dalam subset optimal\n2. Item tersebut tidak termasuk ke dalam subset optimal\n\nOleh karena itu, value maksimum yang bisa diperoleh dari n buah item adalah nilai maksimum dari 2 value berikut:\n1. Value maksimum yang diperoleh dari n-1 items dan W weight (jika weight dari item ke-n lebih besar dari W, maka item ke-n tidak dapat dimasukkan)\n2. Value dari item ke-n ditambah value maksimum dari n-1 items dan W dikurang weight dari item ke-n\n\nNamun, untuk menghindari overlapping subproblems, digunakan pendekatan DP, di mana komputasi dari subproblem yang sama dapat dihindari dengan membuat sebuah array sementara K[][] dalam bottom up manner. Implementasi dapat dilihat pada code di bawah.\n\n**Kompleksitas** dari code di bawah ini adalah \ud835\udc42(\ud835\udc5b\ud835\udc4a). Hal ini disebabkan karena algoritma melakukan looping untuk setiap elemen \ud835\udc5b dan kemudian di dalamnya terdapat loopig untuk setiap elemen \ud835\udc4a."}}