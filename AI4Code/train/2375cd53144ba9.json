{"cell_type":{"98f84335":"code","2d91d3e8":"code","f513ff4e":"code","97cbfbfc":"code","41c63a56":"code","aeee3567":"code","35375d30":"code","714f1ec2":"code","f134380a":"code","81abf1fe":"code","35f70cb1":"code","dab1af8f":"code","86f9daa1":"markdown","c0f490e0":"markdown","80c11afe":"markdown","19ed4cf8":"markdown","798450f4":"markdown","b97502cb":"markdown","862072ef":"markdown","02e15f0e":"markdown","a48481b0":"markdown","a826e450":"markdown","87548657":"markdown","7302b69f":"markdown","682eacd6":"markdown","89e75e36":"markdown"},"source":{"98f84335":"#loading required package\nimport numpy as np\nimport matplotlib.pyplot as plt","2d91d3e8":"#INPUT\nx_train=[[0,0,0],\n         [0,0,1],\n         [0,1,0],\n         [0,1,1],\n         [1,0,0],\n         [1,0,1],\n         [1,1,0],\n         [1,1,1]]\n\n#OUTPUT\ny_train_and  = np.array([0,0,0,0,0,0,0,1])  #AND\ny_train_or   = np.array([0,1,1,1,1,1,1,1])  #OR\ny_train_nand = np.array([1,1,1,1,1,1,1,0])  #NAND\ny_train_nor  = np.array([1,0,0,0,0,0,0,0])  #NAND\nx_train = np.array(x_train)\nprint(x_train.shape,y_train_and.shape)","f513ff4e":"a=np.linspace(-0.1,0.1,5)        #points nearer to zero -0.1 to 0.1\nb=np.linspace(0.9,1.1,5)        #points nearer to one  0.9 to 1.1\nc = np.hstack((a,b)) \nx_test = []\ny_test_and = []\ny_test_or = []\ny_test_nor = []\ny_test_nand = []\n\nfor i in c:                   #creating combination of points with three input\n    for j in c:\n        for k in c:\n            x_test.append([i,j,k])\n            tmp = np.round(x_test[-1])\n            and_x = tmp[0] and tmp[1] and tmp[2]\n            or_x = tmp[0] and tmp[1] and tmp[2]\n            y_test_and.append(and_x)\n            y_test_or.append(or_x)\n            \n            if and_x==0:\n                y_test_nand.append(1)\n            else:\n                y_test_nand.append(0)\n            \n            if or_x==0:\n                y_test_nor.append(1)\n                y_test_nor.append(0)\n                \n            \nx_test = np.array(x_test)\ny_test_and = np.array(y_test_and)\ny_test_or = np.array(y_test_or)\ny_test_nand = np.array(y_test_nand)\ny_test_nor = np.array(y_test_nor)\nprint(x_test.shape,y_test_and.shape)\nprint(\"Display top 10 testing inputs \",x_test[:10,:])   ","97cbfbfc":"#using above equation to create single unit of perceptron.\ndef perceptron(x,w,threshold):\n    sum = 0 \n    for xi,wi in zip(x,w):         #x1w1+x2w2+x3w3+.....+xnwn\n        sum += xi*wi\n    if sum>= threshold:                #  wx - theta >=0 \n        return 1\n    else:\n        return 0\n    \n   ","41c63a56":"#Delta Learning Algorithm using above two equations\ndef deltaLearningAlgorithm(x_train,y_train,alpha=1e-2,max_epoch=100):\n    w = np.zeros(x_train.shape[1])\n    theta = np.random.random()\n    #theat = 0\n    print(\"Initial Weight --> \",w)\n    print(\"Initial Thresold -->\",theta)\n    \n    for c in range(max_epoch):\n        for i in range(x_train.shape[0]):\n            y_predicted = perceptron(x_train[i],w,threshold=theta)\n            error = y_train[i] - y_predicted\n            if y_train[i]==y_predicted:\n                error= 0\n            elif y_train[i] < y_predicted:\n                error= -1\n            else:\n                error= +1\n    \n        \n            dw = alpha*x_train[i]*error\n            dtheta = alpha*1*error\n            w = w +dw                        #updating weight\n            theta = theta - dtheta           #updating thresold i.e, theta\n            \n            \n            \n    return w,theta","aeee3567":"def accuracy(x_test,y_test,w,thresold):\n    count =0\n    m,n = x_test.shape\n    for i in range(m):\n        predict = perceptron(x_test[i],w,thresold)\n        if predict==y_test[i]:\n            count +=1\n    \n    return (count*100)\/m","35375d30":"def plot3d(w_final,theta_final):\n    p = np.linspace(-2,2,20)\n    px,py,pz=[],[],[]\n    nx,ny,nz=[],[],[]\n    for i in p:\n        for j in p:\n            for k in p:\n                if perceptron(np.array([i,j,k]),w_final,theta_final)>=1:\n                    px.append(i)\n                    py.append(j)\n                    pz.append(k)\n                else:\n                    nx.append(i)\n                    ny.append(j)\n                    nz.append(k)\n\n\n\n    fig = plt.figure(figsize=(10,10))\n    ax = plt.axes(projection='3d')\n    ax.scatter3D(px,py,pz,color='blue')\n    ax.scatter3D(nx,ny,nz,color='red')\n    ax.set_title('Plot (blue=1 as output),(red=0 as output)')\n    plt.show()","714f1ec2":"#Applying delta learning algorithm for and.\nw_final,theta_final = deltaLearningAlgorithm(x_train,y_train_and,alpha=1e-2,max_epoch=300)\nprint(\"Final Weight   ->\",w_final)\nprint(\"Final Thresold ->\",theta_final)\nprint(\"For training data(prediction) --->\",end=\"  \")\nfor i in range(8):\n    print(perceptron(x_train[i],w_final,threshold=theta_final),end=\",\")\n\n\nprint(\"\\n\\nAccuracy  ------>\",accuracy(x_test,y_test_and,w_final,theta_final))\nplot3d(w_final,theta_final)","f134380a":"w_final,theta_final = deltaLearningAlgorithm(x_train,y_train_or,alpha=1e-2,max_epoch=100)\nprint(\"Final Weight   ->\",w_final)\nprint(\"Final Thresold ->\",theta_final)\nprint(\"For training data(prediction) --->\",end=\"  \")\nfor i in range(8):\n    print(perceptron(x_train[i],w_final,threshold=theta_final),end=\",\")\n\n\nprint(\"\\n\\nAccuracy  ------>\",accuracy(x_test,y_test_or,w_final,theta_final))\nplot3d(w_final,theta_final)","81abf1fe":"w_final,theta_final = deltaLearningAlgorithm(x_train,y_train_nand,alpha=1e-2,max_epoch=100)\nprint(\"Final Weight   ->\",w_final)\nprint(\"Final Thresold ->\",theta_final)\nprint(\"For training data(prediction) --->\",end=\"  \")\nfor i in range(8):\n    print(perceptron(x_train[i],w_final,threshold=theta_final),end=\",\")\n\n\nprint(\"\\n\\nAccuracy  ------>\",accuracy(x_test,y_test_nand,w_final,theta_final))\nplot3d(w_final,theta_final)","35f70cb1":"w_final,theta_final = deltaLearningAlgorithm(x_train,y_train_nor,alpha=1e-2,max_epoch=300)\nprint(\"Final Weight   ->\",w_final)\nprint(\"Final Thresold ->\",theta_final)\nprint(\"For training data(prediction) --->\",end=\"  \")\nfor i in range(8):\n    print(perceptron(x_train[i],w_final,threshold=theta_final),end=\",\")\n\n\nprint(\"\\n\\nAccuracy  ------>\",accuracy(x_test,y_test_nor,w_final,theta_final))\nplot3d(w_final,theta_final)","dab1af8f":"x = np.array([[0,0],\n              [0,1],\n              [1,0],\n              [1,1]])\ny_and = np.array([0,0,0,1])\ny_or = np.array([0,1,1,1])\ny_nand = np.array([1,1,1,0])\ny_nor = np.array([1,0,0,0])\nw_final,theta_final = deltaLearningAlgorithm(x,y_and,alpha=1e-1,max_epoch=100)\nfor i in range(4):\n    print(perceptron(x[i],w_final,threshold=theta_final))\np = np.linspace(-2,2,200)\npx,py=[],[]\nnx,ny=[],[]\n\nfor i in p:\n    for j in p:\n        if perceptron(np.array([i,j]),w_final,theta_final)>=1:\n            px.append(i)\n            py.append(j)\n        else:\n            nx.append(i)\n            ny.append(j)\n\nplt.scatter(px,py)\nplt.scatter(nx,ny)\nplt.scatter(x[:,0],x[:,1])\nplt.show()\n\n#plot is for and gate(to get plot for or,nand,nor replace y_and to y_or,y_nand,y_nor in line 9 of this cell)\n#blue region is where output = 1\n#orange region in where output = 0","86f9daa1":"### Generating Testing Dataset (Point nearer to training dataset).\nSteps:\n1. generate values near 0,1 \n2. create 3 input points from step 1 by using loop(3 times).\n3. append to x_test point generated in step2.\n4. create corresponding y_test for and,or,nand,nor.","c0f490e0":"### OR (3-INPUT)","80c11afe":"## Delta Learning Algorithm :\n\\begin{equation}\n                error(p) = y_{train(p)} - y_{predicted(p)} \\\\\n                w_i(p+1) = w_i + \\alpha * x * error(p)\n\\end{equation}","19ed4cf8":"### Training Dataset(Truth table for AND,OR,NAND,NOR).","798450f4":"## AND (3-INPUT)","b97502cb":"## Analysis :\n<ul>\n    <li>chaning value of alplha,max_epoch doesn't have significant impact on accuracy.<\/li>\n    <li>using delta algorithm gives different value of weight for different execution.<\/li>\n    <li>Single Unit Perceptron is able to Perform AND,OR,NAND and NOR.<\/li>\n    <li><b>Conclusion :<\/b>Using Delta Learning Rule on single perceptron create a linealy separable boundary.<\/li>\n<\/ul>","862072ef":"### plot3d to visualize in 3d (blue=1 , red = 0 ) 1,0 are output ","02e15f0e":"### NAND (3-INPUT)","a48481b0":"### Visualization by plotting for 2-input AND (For simplification)","a826e450":"### NOR (3-INPUT)","87548657":"# Design perceptron learning rule for 3-input AND, OR, NAND & NOR.\n","7302b69f":"### Defining function to find Accuracy :","682eacd6":"## Perceptron unit :\n\\begin{equation}\n    \\sum_{i=1}^{n} w_ix_i >= \\theta , y=1\\ else\\ y=0\n\\end{equation}","89e75e36":"# Results :\n<ul>\n    <li>Accuracy of Perceptron for AND(3-INPUT) -:99.7%<\/li>\n    <li>Accuracy of Perceptron for OR(3-INPUT)  -:31.1%<\/li>\n    <li>Accuracy of Perceptron for NAND(3-INPUT) -:99.4%<\/li>\n    <li>Accuracy of Perceptron for NOR(3-INPUT) -:52.9%<\/li>\n    <\/ul>"}}