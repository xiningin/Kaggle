{"cell_type":{"34279d52":"code","aaebf84b":"code","4ca7d5c9":"code","f4fd5d58":"code","147f50fa":"code","37cf8c28":"code","fc12b945":"code","114fa5a4":"code","3bdae729":"code","0948c4fd":"code","385bc5db":"code","1db12b93":"code","d0c46e49":"code","42162b53":"code","9c9c141c":"code","835ebe18":"code","aea5fd97":"code","5a5bbea5":"code","8be9b993":"code","d9aef613":"code","ab6eb9c8":"code","296d93f6":"markdown","cba9b9bf":"markdown","051b4f99":"markdown","10964bc6":"markdown","a06b5b47":"markdown"},"source":{"34279d52":"package_paths = [\n    '..\/input\/pytorch-image-models\/pytorch-image-models-master', #'..\/input\/efficientnet-pytorch-07\/efficientnet_pytorch-0.7.0'\n    '..\/input\/image-fmix\/FMix-master'\n]\nimport sys; \n\nfor pth in package_paths:\n    sys.path.append(pth)\n    \nfrom fmix import sample_mask, make_low_freq_image, binarise_mask","aaebf84b":"from glob import glob\nfrom sklearn.model_selection import GroupKFold, StratifiedKFold\nimport cv2\nfrom skimage import io\nfrom skimage import exposure\nimport torch\nfrom torch import nn\nimport os\nfrom datetime import datetime\nimport time\nimport random\nimport cv2\nimport torchvision\nfrom torchvision import transforms\nimport pandas as pd\nimport numpy as np\nfrom tqdm import tqdm\n\nimport matplotlib.pyplot as plt\nfrom torch.utils.data import Dataset,DataLoader\nfrom torch.utils.data.sampler import SequentialSampler, RandomSampler\nfrom torch.cuda.amp import autocast, GradScaler\nfrom torch.nn.modules.loss import _WeightedLoss\nimport torch.nn.functional as F\n\nimport timm\n\nimport sklearn\nimport warnings\nimport joblib\nfrom sklearn.metrics import roc_auc_score, log_loss\nfrom sklearn import metrics\nimport warnings\nimport cv2\nimport pydicom\n#from efficientnet_pytorch import EfficientNet\nfrom scipy.ndimage.interpolation import zoom","4ca7d5c9":"import warnings\nwarnings.filterwarnings(\"ignore\")","f4fd5d58":"# \u5c06\u8bad\u7ec3csv\u8bfb\u5165\nCOMPETITION_NAME = \"siimcovid19-512-img-png-600-study-png\"\nload_dir = f\"\/kaggle\/input\/{COMPETITION_NAME}\/\"\ndf = pd.read_csv('..\/input\/siim-covid19-detection\/train_study_level.csv')\ndf.head()","147f50fa":"# \u4e3a\u64cd\u4f5c\u65b9\u4fbf\u4fee\u6539\u8868\u5934 inplace\u53c2\u6570\u51b3\u5b9a\u662f\u5426\u4fee\u6539\u539fdf\ndf.rename(columns={'Negative for Pneumonia':'0','Typical Appearance':'1',\"Indeterminate Appearance\":'2',\n                   \"Atypical Appearance\":\"3\"}, inplace=True)\ndf.head()","37cf8c28":"# \u89e3\u7801one-hot\nlabels = []\ndef get_label(row):\n    for c in df.columns:\n        if row[c]==1:\n            labels.append(int(c))\ndf.apply(get_label, axis=1)\nprint(\"label modified\")","fc12b945":"# \u5408\u5e76\u4e24\u4efdDataFrame,\u6ce8\u610faxis = 1\u53c2\u6570\nlabels = {'label':labels}\nstudy_label = pd.DataFrame(labels)\ntrain_study = pd.concat([df, study_label], axis = 1)\n#print(train_study)","114fa5a4":"del train_study ['0'];del train_study ['1'];del train_study ['2'];del train_study ['3']\ntrain_study","3bdae729":"train_study.label.value_counts()","0948c4fd":"# \u968f\u673aseed\u79cd\u5b50\u5f88\u91cd\u8981\ndef seed_everything(seed):\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = True","385bc5db":"# \u4ece\u516c\u5f00\u5206\u4eab\u7684notebook\u4e2d\u5b66\u4e60\u5230\uff1a\u7070\u5ea6\u503c\u5747\u8861\u5316\u53ef\u80fd\u4f1a\u589e\u52a0\u51c6\u786e\u7387\uff0c\u6240\u4ee5\u8fd9\u91cc\u5c1d\u8bd5\u4e00\u4e0b\ndef preprocess_image(img):\n    #img[:,:,0] = exposure.equalize_hist(img[:,:,0])\n    #img[:,:,1] = exposure.equalize_hist(img[:,:,1])\n    #img[:,:,2] = exposure.equalize_hist(img[:,:,2])\n    eimg = exposure.equalize_hist(img)\n    return eimg\n# \u76ee\u524d\u5b9e\u73b0\u7684\u6548\u679c\u5e76\u6ca1\u6709\u592a\u5927\u63d0\u5347\uff0c\u4f46\u611f\u89c9\u8bad\u7ec3\u8fc7\u7a0b\u66f4\u7a33\u5b9a\u4e86\u4e00\u4e9b","1db12b93":"# \u6253\u5f00\u4e00\u5f20\u56fe\u770b\u770b\u957f\u4ec0\u4e48\u6837\ndef get_img(path):\n    im_bgr = cv2.imread(path)\n    im_rgb = im_bgr[:, :, ::-1]\n    return im_rgb\n    \n    '''\n    #\u6253\u5f00\u8fd9\u4e24\u6761\u7a0b\u5e8f\u53ef\u4ee5\u770b\u5230\u5904\u7406\u524d\u540e\u4e24\u8005\u7684\u5bf9\u6bd4\n    #processimg = np.concatenate((im_rgb\/255, equ_img), axis=1)\n    #return processimg\n    '''\n    #equ_img = preprocess_image(im_rgb)  #\u6253\u5f00\u6216\u5173\u95ed\u901a\u9053\u7070\u5ea6\u5747\u503c\u5316\n    #return equ_img.astype(np.float32)\n\nyuan = get_img('..\/input\/siimcovid19-512-img-png-600-study-png\/study\/00086460a852_study.png')\nplt.imshow(yuan)\nplt.show()","d0c46e49":"# \u8c03\u8bd5\n'''\npath = '..\/input\/siimcovid19-512-img-png-600-study-png\/study\/00086460a852_study.png'\nimg = cv2.imread(path)\nprint(img)\n'''","42162b53":"# \u57fa\u672c\u8d85\u53c2\u6570\u8bbe\u7f6e\nCFG = {\n    'fold_num': 5,\n    'seed': 2021,\n    #'model_arch': 'tf_efficientnet_b7',\n    'model_arch': 'tf_efficientnet_b4_ns',\n    'img_size': 512,\n    'epochs': 60,\n    'train_bs': 16,\n    'valid_bs': 32,\n    'T_0': 10,\n    'lr': 1e-6,\n    'min_lr': 1e-6,\n    'weight_decay':1e-6,\n    'num_workers': 4,\n    'accum_iter': 2, # suppoprt to do batch accumulation for backprop with effectively larger batch size\n    'verbose_step': 1,\n    'device': 'cuda:0'\n}","9c9c141c":"def rand_bbox(size, lam):\n    W = size[0]\n    H = size[1]\n    cut_rat = np.sqrt(1. - lam)\n    cut_w = np.int(W * cut_rat)\n    cut_h = np.int(H * cut_rat)\n\n    # uniform\n    cx = np.random.randint(W)\n    cy = np.random.randint(H)\n\n    bbx1 = np.clip(cx - cut_w \/\/ 2, 0, W)\n    bby1 = np.clip(cy - cut_h \/\/ 2, 0, H)\n    bbx2 = np.clip(cx + cut_w \/\/ 2, 0, W)\n    bby2 = np.clip(cy + cut_h \/\/ 2, 0, H)\n    return bbx1, bby1, bbx2, bby2\n\n\nclass CassavaDataset(Dataset):\n    def __init__(self, train_study, data_root, \n                 transforms=None, \n                 output_label=True, \n                 one_hot_label=False,\n                 do_fmix=False, \n                 fmix_params={\n                     'alpha': 1., \n                     'decay_power': 3., \n                     'shape': (CFG['img_size'], CFG['img_size']),\n                     'max_soft': True, \n                     'reformulate': False\n                 },\n                 do_cutmix=False,\n                 cutmix_params={\n                     'alpha': 1,\n                 }\n                ):\n        \n        super().__init__()\n        self.df = train_study.reset_index(drop=True).copy()\n        self.transforms = transforms\n        self.data_root = data_root\n        self.do_fmix = do_fmix\n        self.fmix_params = fmix_params\n        self.do_cutmix = do_cutmix\n        self.cutmix_params = cutmix_params\n        \n        self.output_label = output_label\n        self.one_hot_label = one_hot_label\n        \n        if output_label == True:\n            self.labels = self.df['label'].values\n            #print(self.labels)\n            \n            if one_hot_label is True:\n                self.labels = np.eye(self.df['label'].max()+1)[self.labels]\n                #print(self.labels)\n            \n    def __len__(self):\n        return self.df.shape[0]\n    \n    def __getitem__(self, index: int):\n        \n        # get labels\n        if self.output_label:\n            target = self.labels[index]\n        #print('\u67e5\u67e5\u8def\u5f84\u6b63\u786e\u5417',\"{}\/{}\".format(self.data_root, self.df.loc[index]['id']))\n        img  = get_img(\"{}\/{}\".format(self.data_root, self.df.loc[index]['id'])+'.png')\n        #print(img)\n\n        if self.transforms:\n            img = self.transforms(image=img)['image']\n        \n        if self.do_fmix and np.random.uniform(0., 1., size=1)[0] > 0.5:\n            with torch.no_grad():\n                #lam, mask = sample_mask(**self.fmix_params)\n                \n                lam = np.clip(np.random.beta(self.fmix_params['alpha'], self.fmix_params['alpha']),0.6,0.7)\n                \n                # Make mask, get mean \/ std\n                mask = make_low_freq_image(self.fmix_params['decay_power'], self.fmix_params['shape'])\n                mask = binarise_mask(mask, lam, self.fmix_params['shape'], self.fmix_params['max_soft'])\n    \n                fmix_ix = np.random.choice(self.df.index, size=1)[0]\n                fmix_img  = get_img(\"{}\/{}\".format(self.data_root, self.df.iloc[fmix_ix]['id'])+'.png')\n\n                if self.transforms:\n                    fmix_img = self.transforms(image=fmix_img)['image']\n\n                mask_torch = torch.from_numpy(mask)\n                \n                # mix image\n                img = mask_torch*img+(1.-mask_torch)*fmix_img\n\n                #print(mask.shape)\n\n                #assert self.output_label==True and self.one_hot_label==True\n\n                # mix target\n                rate = mask.sum()\/CFG['img_size']\/CFG['img_size']\n                target = rate*target + (1.-rate)*self.labels[fmix_ix]\n                #print(target, mask, img)\n                #assert False\n        \n        if self.do_cutmix and np.random.uniform(0., 1., size=1)[0] > 0.5:\n            #print(img.sum(), img.shape)\n            with torch.no_grad():\n                cmix_ix = np.random.choice(self.df.index, size=1)[0]\n                cmix_img  = get_img(\"{}\/{}\".format(self.data_root, self.df.iloc[cmix_ix]['id'])+'.png')\n                if self.transforms:\n                    cmix_img = self.transforms(image=cmix_img)['image']\n                    \n                lam = np.clip(np.random.beta(self.cutmix_params['alpha'], self.cutmix_params['alpha']),0.3,0.4)\n                bbx1, bby1, bbx2, bby2 = rand_bbox((CFG['img_size'], CFG['img_size']), lam)\n\n                img[:, bbx1:bbx2, bby1:bby2] = cmix_img[:, bbx1:bbx2, bby1:bby2]\n\n                rate = 1 - ((bbx2 - bbx1) * (bby2 - bby1) \/ (CFG['img_size'] * CFG['img_size']))\n                target = rate*target + (1.-rate)*self.labels[cmix_ix]\n                \n            #print('-', img.sum())\n            #print(target)\n            #assert False\n                            \n        # do label smoothing\n        #print(type(img), type(target))\n        if self.output_label == True:\n            return img, target\n        else:\n            return img","835ebe18":"from albumentations import (\n    HorizontalFlip, VerticalFlip, IAAPerspective, ShiftScaleRotate, CLAHE, RandomRotate90,\n    Transpose, ShiftScaleRotate, Blur, OpticalDistortion, GridDistortion, HueSaturationValue,\n    IAAAdditiveGaussianNoise, GaussNoise, MotionBlur, MedianBlur, IAAPiecewiseAffine, RandomResizedCrop,\n    IAASharpen, IAAEmboss, RandomBrightnessContrast, Flip, OneOf, Compose, Normalize, Cutout, CoarseDropout, ShiftScaleRotate, CenterCrop, Resize\n)\n\nfrom albumentations.pytorch import ToTensorV2\n\ndef get_train_transforms():\n    return Compose([\n            RandomResizedCrop(CFG['img_size'], CFG['img_size']),\n            Transpose(p=0.5),\n            HorizontalFlip(p=0.5),\n            VerticalFlip(p=0.5),\n            ShiftScaleRotate(p=0.5),\n            HueSaturationValue(hue_shift_limit=0.2, sat_shift_limit=0.2, val_shift_limit=0.2, p=0.5),\n            RandomBrightnessContrast(brightness_limit=(-0.1,0.1), contrast_limit=(-0.1, 0.1), p=0.5),\n            Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225], max_pixel_value=255.0, p=1.0),\n            CoarseDropout(p=0.5),\n            Cutout(p=0.5),\n            ToTensorV2(p=1.0),\n        ], p=1.)\n  \n        \ndef get_valid_transforms():\n    return Compose([\n            CenterCrop(CFG['img_size'], CFG['img_size'], p=1.),\n            Resize(CFG['img_size'], CFG['img_size']),\n            Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225], max_pixel_value=255.0, p=1.0),\n            ToTensorV2(p=1.0),\n        ], p=1.)","aea5fd97":"class CassvaImgClassifier(nn.Module):\n    def __init__(self, model_arch, n_class, pretrained=False):\n        super().__init__()\n        self.model = timm.create_model(model_arch, pretrained=pretrained)\n        n_features = self.model.classifier.in_features\n        self.model.classifier = nn.Linear(n_features, n_class)\n        '''\n        self.model.classifier = nn.Sequential(\n            nn.Dropout(0.3),\n            #nn.Linear(n_features, hidden_size,bias=True), nn.ELU(),\n            nn.Linear(n_features, n_class, bias=True)\n        )\n        '''\n    def forward(self, x):\n        x = self.model(x)\n        return x","5a5bbea5":"#\u7ed8\u5236loss\uff0c\u65b9\u4fbf\u67e5\u770b\ndef PlotLossFun(epoch, Cur_List, IFTRAIN='TRAIN'):\n    x = range(len(Cur_List))\n    y = Cur_List\n    \n    IFTRAIN = IFTRAIN\n    EPOCHNUM = str(epoch)\n    \n    plt.plot(x,y)\n    plt.xlabel(f'EpochNum:{EPOCHNUM}')\n    plt.ylabel(f'{IFTRAIN}cur')\n    \n    #if epoch == CFG['epochs']-1:\n    plt.show()\n    plt.savefig(f\"{IFTRAIN}_epoch{EPOCHNUM}_cur.jpg\")","8be9b993":"def prepare_dataloader(df, trn_idx, val_idx, data_root='..\/input\/siimcovid19-512-img-png-600-study-png\/study'):\n    \n    from catalyst.data.sampler import BalanceClassSampler\n    \n    train_ = df.loc[trn_idx,:].reset_index(drop=True)\n    valid_ = df.loc[val_idx,:].reset_index(drop=True)\n    #print(train_, valid_)\n        \n    train_ds = CassavaDataset(train_, data_root, transforms=get_train_transforms(), output_label=True, one_hot_label=False, do_fmix=False, do_cutmix=False)\n    valid_ds = CassavaDataset(valid_, data_root, transforms=get_valid_transforms(), output_label=True)\n    \n    train_loader = torch.utils.data.DataLoader(\n        train_ds,\n        batch_size=CFG['train_bs'],\n        pin_memory=False,\n        drop_last=False,\n        shuffle=True,        \n        num_workers=CFG['num_workers'],\n        #sampler=BalanceClassSampler(labels=train_['label'].values, mode=\"downsampling\")\n    )\n    val_loader = torch.utils.data.DataLoader(\n        valid_ds, \n        batch_size=CFG['valid_bs'],\n        num_workers=CFG['num_workers'],\n        shuffle=False,\n        pin_memory=False,\n    )\n    return train_loader, val_loader\n\ndef train_one_epoch(epoch, model, loss_fn, optimizer, train_loader, device, scheduler=None, schd_batch_update=False):   \n       \n    model.train()\n    Temp_Loss_List = []\n\n    t = time.time()\n    running_loss = None\n\n    pbar = tqdm(enumerate(train_loader), total=len(train_loader))\n    #print(enumerate(train_loader),'len(train_loader)',train_loader)\n    \n    for step, (imgs, image_labels) in pbar:\n        \n        imgs = imgs.to(device).float()\n        image_labels = image_labels.to(device).long()\n\n        #print(image_labels.shape, exam_label.shape)\n        with autocast():\n            image_preds = model(imgs)   #output = model(input)\n\n            loss = loss_fn(image_preds, image_labels)\n            \n            scaler.scale(loss).backward()\n\n            if running_loss is None:\n                running_loss = loss.item()\n            else:\n                running_loss = running_loss * .99 + loss.item() * .01\n\n            if ((step + 1) %  CFG['accum_iter'] == 0) or ((step + 1) == len(train_loader)):\n                # may unscale_ here if desired (e.g., to allow clipping unscaled gradients)\n\n                scaler.step(optimizer)\n                scaler.update()\n                optimizer.zero_grad() \n                \n                if scheduler is not None and schd_batch_update:\n                    scheduler.step()\n\n            if ((step + 1) % CFG['verbose_step'] == 0) or ((step + 1) == len(train_loader)):\n                description = f'epoch {epoch} loss: {running_loss:.4f}'\n                Temp_Loss_List.append(running_loss)\n                \n                pbar.set_description(description)\n    \n    # \u7ed8\u5236loss\u66f2\u7ebf\n    Train_Loss_List.append(np.sum(Temp_Loss_List) \/ len(Temp_Loss_List))\n    if epoch == CFG['epochs']-1:\n        PlotLossFun(epoch, Train_Loss_List,IFTRAIN='TRAIN')            \n    if scheduler is not None and not schd_batch_update:\n        scheduler.step()\n    return Train_Loss_List\n        \ndef valid_one_epoch(epoch, model, loss_fn, val_loader, device, scheduler=None, schd_loss_update=False):\n    model.eval()\n\n    t = time.time()\n    loss_sum = 0\n    sample_num = 0\n    image_preds_all = []\n    image_targets_all = []\n    \n    pbar = tqdm(enumerate(val_loader), total=len(val_loader))\n    for step, (imgs, image_labels) in pbar:\n        imgs = imgs.to(device).float()\n        image_labels = image_labels.to(device).long()\n        \n        image_preds = model(imgs)   #output = model(input)\n        #print(image_preds.shape, exam_pred.shape)\n        image_preds_all += [torch.argmax(image_preds, 1).detach().cpu().numpy()]\n        image_targets_all += [image_labels.detach().cpu().numpy()]\n        \n        loss = loss_fn(image_preds, image_labels)\n        \n        loss_sum += loss.item()*image_labels.shape[0]\n        sample_num += image_labels.shape[0]  \n\n        if ((step + 1) % CFG['verbose_step'] == 0) or ((step + 1) == len(val_loader)):\n            description = f'epoch {epoch} loss: {loss_sum\/sample_num:.4f}'\n            pbar.set_description(description)\n    \n    image_preds_all = np.concatenate(image_preds_all)\n    image_targets_all = np.concatenate(image_targets_all)\n    print('validation multi-class accuracy = {:.4f}'.format((image_preds_all==image_targets_all).mean()))\n    \n    Val_Acc_List.append((image_preds_all==image_targets_all).mean())\n    if epoch == CFG['epochs']-1:\n        PlotLossFun(epoch, Val_Acc_List, IFTRAIN='VAL') \n    \n    if scheduler is not None:\n        if schd_loss_update:\n            scheduler.step(loss_sum\/sample_num)\n        else:\n            scheduler.step()","d9aef613":"# reference: https:\/\/www.kaggle.com\/c\/siim-isic-melanoma-classification\/discussion\/173733\nclass MyCrossEntropyLoss(_WeightedLoss):\n    def __init__(self, weight=None, reduction='mean'):\n        super().__init__(weight=weight, reduction=reduction)\n        self.weight = weight\n        self.reduction = reduction\n\n    def forward(self, inputs, targets):\n        lsm = F.log_softmax(inputs, -1)\n\n        if self.weight is not None:\n            lsm = lsm * self.weight.unsqueeze(0)\n\n        loss = -(targets * lsm).sum(-1)\n\n        if  self.reduction == 'sum':\n            loss = loss.sum()\n        elif  self.reduction == 'mean':\n            loss = loss.mean()\n\n        return loss","ab6eb9c8":"if __name__ == '__main__':\n    \n    # for training only, need nightly build pytorch\n    seed_everything(CFG['seed'])\n    \n    folds = StratifiedKFold(n_splits=CFG['fold_num'], shuffle=True, random_state=CFG['seed']).split(np.arange(train_study.shape[0]), train_study.label.values)\n    \n    for fold, (trn_idx, val_idx) in enumerate(folds):\n        \n        # we'll train fold 0 first\n        if fold > 0:\n            break \n\n        print('Training with {} started'.format(fold))\n\n        print(len(trn_idx), len(val_idx))\n        train_loader, val_loader = prepare_dataloader(train_study, trn_idx, val_idx, \n                                                      data_root='..\/input\/siimcovid19-512-img-png-600-study-png\/study')\n        device = torch.device(CFG['device'])\n        model = CassvaImgClassifier(CFG['model_arch'], train_study.label.nunique(), pretrained=True).to(device)\n        scaler = GradScaler()   \n        optimizer = torch.optim.Adam(model.parameters(), lr=CFG['lr'], weight_decay=CFG['weight_decay'])\n        #scheduler = torch.optim.lr_scheduler.StepLR(optimizer, gamma=0.1, step_size=CFG['epochs']-1)\n        scheduler = torch.optim.lr_scheduler.CosineAnnealingWarmRestarts(optimizer, T_0=CFG['T_0'], T_mult=1, eta_min=CFG['min_lr'], last_epoch=-1)\n        #scheduler = torch.optim.lr_scheduler.OneCycleLR(optimizer=optimizer, pct_start=0.1, div_factor=25, \n        #                                                max_lr=CFG['lr'], epochs=CFG['epochs'], steps_per_epoch=len(train_loader))\n        \n        loss_tr = nn.CrossEntropyLoss().to(device) #MyCrossEntropyLoss().to(device)\n        loss_fn = nn.CrossEntropyLoss().to(device)\n        \n        #\u5efa\u7acb\u7a7a\u6570\u7ec4\uff0c\u7528\u6765\u7ed8\u5236\u66f2\u7ebf\n        global Train_Loss_List, Val_Acc_List\n        Train_Loss_List = []\n        Val_Acc_List = []\n            \n        for epoch in range(CFG['epochs']):\n\n            train_one_epoch(epoch, model, loss_tr, optimizer, train_loader, device, scheduler=scheduler, schd_batch_update=False)\n            \n            with torch.no_grad():\n                valid_one_epoch(epoch, model, loss_fn, val_loader, device, scheduler=None, schd_loss_update=False)\n            \n            # \u4fdd\u5b58\u6a21\u578b\n            if epoch > CFG['epochs']-10:\n                torch.save(model.state_dict(),'{}_fold_{}_{}'.format(CFG['model_arch'], fold, epoch))\n            \n        #torch.save(model.cnn_model.state_dict(),'{}\/cnn_model_fold_{}_{}'.format(CFG['model_path'], fold, CFG['tag']))\n        del model, optimizer, train_loader, val_loader, scaler, scheduler\n        torch.cuda.empty_cache()","296d93f6":"# 3 \u4e3b\u5faa\u73af\uff0c\u5f00\u59cb\u8bad\u7ec3\u7f51\u7edc","cba9b9bf":"# pytorch-baseline for classify data(study -label)","051b4f99":"# 1 \u6570\u636e\u9884\u5904\u7406","10964bc6":"# 0 \u5bfc\u5165\u7a0b\u5e8f\u5305","a06b5b47":"# 2 \u6784\u5efa\u7f51\u7edc\u53ca\u5176\u57fa\u672c\u53c2\u6570\u8bbe\u7f6e"}}