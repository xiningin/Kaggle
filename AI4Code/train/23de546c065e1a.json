{"cell_type":{"dafce3ff":"code","8d7bb1b7":"code","2dabe004":"code","0ed4bd8b":"code","525156a0":"code","8177f72b":"code","6c4ea67e":"markdown","e6d211be":"markdown","d21cc64c":"markdown","a88c95d6":"markdown"},"source":{"dafce3ff":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","8d7bb1b7":"import pandas as pd\n\ndata = pd.read_csv('\/kaggle\/input\/metro\/train.csv', encoding='utf-8')\ndata = data.drop(['\uc5ed\ubc88\ud638', '\uc5ed\uc774\ub984', '\ud638\uc120', '\uacc4', '\uc77c\ud3c9\uade0'], axis = 1)","2dabe004":"import numpy as np\nimport torch\nimport torch.optim as optim\nfrom sklearn.preprocessing import MinMaxScaler\nimport random\n\nif torch.cuda.is_available():\n    device = torch.device('cuda')\nelse:\n    device = torch.device('cpu')\n\nrandom.seed(1)\ntorch.manual_seed(1)\ntorch.cuda.manual_seed_all(1)\n\nnum_data = data.to_numpy()\nx_data = num_data[:,:-1];\ny_data = num_data[:,[-1]]\n\nx_data = torch.FloatTensor(x_data).to(device)\ny_data = torch.FloatTensor(y_data).to(device)\n\nlinear1 = torch.nn.Linear(7, 32, bias=True)\nlinear2 = torch.nn.Linear(32, 32, bias=True)\nlinear3 = torch.nn.Linear(32, 32, bias=True)\noutput = torch.nn.Linear(32, 1, bias=True)\n\ntorch.nn.init.xavier_uniform_(linear1.weight)\ntorch.nn.init.xavier_uniform_(linear2.weight)\ntorch.nn.init.xavier_uniform_(linear3.weight)\ntorch.nn.init.xavier_uniform_(output.weight)\n\n","0ed4bd8b":"relu = torch.nn.ReLU()\n\nmodel = torch.nn.Sequential(linear1, relu,\n                            linear2, relu,\n                            linear3, relu,\n                            output).to(device)\n\nloss = torch.nn.MSELoss().to(device)\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-3)\n\nepochs = 15001;\nfor epoch in range(epochs):\n  optimizer.zero_grad();\n  hypothesis = model(x_data);\n  cost = loss(hypothesis, y_data)\n  cost.backward();\n  optimizer.step()\n\n  if(epoch%1000 == 0):\n    print('Epoch: {}, Cost: {}'.format(epoch, cost.item()))","525156a0":"test = pd.read_csv('\/kaggle\/input\/metro\/test.csv', encoding='utf-8')\ntest = test.drop(['\uc5ed\uc774\ub984', '\uc5ed\ubc88\ud638', '\uacc4', '\uc77c\ud3c9\uade0', '\ud638\uc120'], axis=1)\n\ntest = test.to_numpy()\ntest = torch.FloatTensor(test).to(device)\n\nprediction = model(test)","8177f72b":"submit = pd.read_csv('\/kaggle\/input\/metro\/submit.csv')\n\nfor i in range(len(submit)):\n    submit['Expected'][i] = prediction[i];\n\nsubmit","6c4ea67e":"## submit \ud615\uc2dd\uc73c\ub85c \uc81c\ucd9c\ud558\uae30","e6d211be":"## \ud559\uc2b5\uc2dc\ud0a4\uae30\n - \ud559\uc2b5\uc740 \ub525\ub7ec\ub2dd\uc744 \uc774\uc6a9\ud588\uc2b5\ub2c8\ub2e4.\n - Loss\ub294 \ud68c\uadc0 \ubb38\uc81c\uc774\ubbc0\ub85c MSELoss\ub97c \uc0ac\uc6a9\ud588\uc2b5\ub2c8\ub2e4.","d21cc64c":"## \ud14c\uc2a4\ud2b8 \ub370\uc774\ud130\ub85c \uc608\uce21\ud558\uae30","a88c95d6":"## Train \ub370\uc774\ud130 \uc900\ube44\n - encoding\uc740 'utf-8'\ub85c \uc124\uc815\ud558\uc5ec train \ub370\uc774\ud130\ub97c \ubd88\ub7ec\uc635\ub2c8\ub2e4\n - \ud559\uc2b5\uc5d0 \uc5f0\uad00\uc774 \uc5c6\ub2e4\uace0 \uc0dd\uac01\ub418\ub294 \ub370\uc774\ud130\ub97c \uc9c0\uc6c1\ub2c8\ub2e4"}}