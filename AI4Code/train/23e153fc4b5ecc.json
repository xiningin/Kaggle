{"cell_type":{"69b98328":"code","42fb925f":"code","ad34193c":"code","db8ac786":"code","4b0c674d":"code","2dcd0486":"code","4ea3f3dd":"code","8141f892":"code","dfa4e350":"code","7debbc5b":"code","0e936a6d":"code","901d1d9a":"code","c347e07a":"code","ffa0f88d":"code","5c71e1fa":"code","43ceae8c":"code","bf06878a":"code","aec55924":"code","bdae7a9b":"code","fe072f21":"code","dc538df7":"code","f1c37a4f":"code","7cff1feb":"code","ecc71868":"code","a2e88bf2":"code","976421b7":"code","3a4f8f46":"code","b2fbc868":"code","76b39e1f":"code","7acdb7fd":"code","82292489":"code","2fa62b61":"code","73a6cd7b":"code","98077239":"code","c6560a92":"code","47be5336":"code","19f7eedc":"code","ba43bbd1":"code","e6b71009":"code","851aafdc":"code","dc8c0db1":"code","04e70b4d":"code","a19a769b":"code","23ad0da9":"code","c04c371c":"code","2259460d":"code","c3f72192":"code","c1f3fa3e":"code","fce8610d":"code","bfbbe92e":"code","6440152e":"code","95e3df98":"code","a1690c1b":"code","7b37d9ce":"code","3affe9fa":"code","eb9ef7b7":"code","dabbfde3":"code","b32726c1":"code","630070de":"code","1ca53d58":"code","be7dc113":"code","d079f031":"code","a6602632":"code","42a58fb0":"markdown","10127619":"markdown","9079ddec":"markdown","87f1c697":"markdown","f30b6045":"markdown","8f9c85d6":"markdown","e0755f82":"markdown","7a021714":"markdown","f3494ecc":"markdown","e6f12cd4":"markdown","d3816515":"markdown","09c62fea":"markdown","6534a542":"markdown","75d93bab":"markdown","b6d88cdf":"markdown","e404f18a":"markdown","7b8c23e7":"markdown","fc403d5b":"markdown","5451209c":"markdown","5bf7b09d":"markdown","cdb01dc0":"markdown","ee897104":"markdown","51c66c44":"markdown","5539220a":"markdown","c4c09fd1":"markdown","97a55510":"markdown","aafd04cd":"markdown","a52e512f":"markdown","0607af61":"markdown","79429557":"markdown","55249b8f":"markdown","ed7fce98":"markdown","c019edb1":"markdown","4d0115e0":"markdown","379bc58c":"markdown","ffcf0d01":"markdown","c6ce80ea":"markdown","4cd02c4e":"markdown","a47fb50b":"markdown","7b51b2b2":"markdown","b7ac3dbf":"markdown","c0df1f4d":"markdown","05b048fb":"markdown","fbb79381":"markdown","f56867e1":"markdown","cf2f819f":"markdown","c48cb007":"markdown","acce0409":"markdown","5a066bf9":"markdown","da14c8ea":"markdown","0d5d43c5":"markdown","60ad9348":"markdown","68e3c309":"markdown","135533a3":"markdown","6449f187":"markdown","59f65da4":"markdown","1111a07d":"markdown"},"source":{"69b98328":"import numpy as np","42fb925f":"x = np.array([1, 2, 3])\ny = np.array([3, 2, 1])\nnp.concatenate([x, y])","ad34193c":"z = [99, 99, 99]\nprint(np.concatenate([x, y, z]))","db8ac786":"grid = np.array([[1, 2, 3],\n                 [4, 5, 6]])","4b0c674d":"# concatenate along the first axis\nnp.concatenate([grid, grid])","2dcd0486":"# concatenate along the second axis (zero-indexed)\nnp.concatenate([grid, grid], axis=1)","4ea3f3dd":"x = np.array([1, 2, 3])\ngrid = np.array([[9, 8, 7],\n                 [6, 5, 4]])\n\n# vertically stack the arrays\nnp.vstack([x, grid])","8141f892":"# horizontally stack the arrays\ny = np.array([[99],\n              [99]])\nnp.hstack([grid, y])","dfa4e350":"x = [1, 2, 3, 99, 99, 3, 2, 1]\nx1, x2, x3 = np.split(x, [3, 5])\nprint(x1, x2, x3)","7debbc5b":"grid = np.arange(16).reshape((4, 4))\ngrid","0e936a6d":"upper, lower = np.vsplit(grid, [2])\nprint(upper)\nprint(lower)","901d1d9a":"left, right = np.hsplit(grid, [2])\nprint(left)\nprint(right)","c347e07a":"np.random.seed(0)\n\ndef compute_reciprocals(values):\n    output = np.empty(len(values))\n    for i in range(len(values)):\n        output[i] = 1.0 \/ values[i]\n    return output\n        \nvalues = np.random.randint(1, 10, size=5)\ncompute_reciprocals(values)","ffa0f88d":"big_array = np.random.randint(1, 100, size=1000000)\n%timeit compute_reciprocals(big_array)","5c71e1fa":"%timeit compute_reciprocals(values)\n%timeit 1.0 \/ values","43ceae8c":"print(compute_reciprocals(values))\nprint(1.0 \/ values)","bf06878a":"%timeit (1.0 \/ big_array)","aec55924":"np.arange(5) \/ np.arange(1, 6)","bdae7a9b":"x = np.arange(9).reshape((3, 3))\n2 ** x","fe072f21":"x = np.arange(4)\nprint(\"x     =\", x)\nprint(\"x + 5 =\", x + 5)\nprint(\"x - 5 =\", x - 5)\nprint(\"x * 2 =\", x * 2)\nprint(\"x \/ 2 =\", x \/ 2)\nprint(\"x \/\/ 2 =\", x \/\/ 2)  # floor division","dc538df7":"print(\"-x     = \", -x)\nprint(\"x ** 2 = \", x ** 2)\nprint(\"x % 2  = \", x % 2)","f1c37a4f":"-(0.5*x + 1) ** 2","7cff1feb":"np.add(x, 2)","ecc71868":"x = np.array([-2, -1, 0, 1, 2])\nabs(x)","a2e88bf2":"np.absolute(x)","976421b7":"x = np.array([3 - 4j, 4 - 3j, 2 + 0j, 0 + 1j])\nnp.abs(x)","3a4f8f46":"theta = np.linspace(0, np.pi, 3)","b2fbc868":"print(\"theta      = \", theta)\nprint(\"sin(theta) = \", np.sin(theta))\nprint(\"cos(theta) = \", np.cos(theta))\nprint(\"tan(theta) = \", np.tan(theta))","76b39e1f":"x = [-1, 0, 1]\nprint(\"x         = \", x)\nprint(\"arcsin(x) = \", np.arcsin(x))\nprint(\"arccos(x) = \", np.arccos(x))\nprint(\"arctan(x) = \", np.arctan(x))","7acdb7fd":"x = [1, 2, 3]\nprint(\"x     =\", x)\nprint(\"e^x   =\", np.exp(x))\nprint(\"2^x   =\", np.exp2(x))\nprint(\"3^x   =\", np.power(3, x))","82292489":"x = [1, 2, 4, 10]\nprint(\"x        =\", x)\nprint(\"ln(x)    =\", np.log(x))\nprint(\"log2(x)  =\", np.log2(x))\nprint(\"log10(x) =\", np.log10(x))","2fa62b61":"x = [0, 0.001, 0.01, 0.1]\nprint(\"exp(x) - 1 =\", np.expm1(x))\nprint(\"log(1 + x) =\", np.log1p(x))","73a6cd7b":"from scipy import special","98077239":"# Gamma functions (generalized factorials) and related functions\nx = [1, 5, 10]\nprint(\"gamma(x)     =\", special.gamma(x))\nprint(\"ln|gamma(x)| =\", special.gammaln(x))\nprint(\"beta(x, 2)   =\", special.beta(x, 2))","c6560a92":"# Error function (integral of Gaussian)\n# its complement, and its inverse\nx = np.array([0, 0.3, 0.7, 1.0])\nprint(\"erf(x)  =\", special.erf(x))\nprint(\"erfc(x) =\", special.erfc(x))\nprint(\"erfinv(x) =\", special.erfinv(x))","47be5336":"x = np.arange(5)\ny = np.empty(5)\nnp.multiply(x, 10, out=y)\nprint(y)","19f7eedc":"y = np.zeros(10)\nnp.power(2, x, out=y[::2])\nprint(y)","ba43bbd1":"x = np.arange(1, 6)\nnp.add.reduce(x)","e6b71009":"np.multiply.reduce(x)","851aafdc":"np.add.accumulate(x)","dc8c0db1":"np.multiply.accumulate(x)","04e70b4d":"x = np.arange(1, 6)\nnp.multiply.outer(x, x)","a19a769b":"a = np.array([0, 1, 2])\nb = np.array([5, 5, 5])\na + b","23ad0da9":"a + 5","c04c371c":"M = np.ones((3, 3))\nM","2259460d":"M + a","c3f72192":"a = np.arange(3)\nb = np.arange(3)[:, np.newaxis]\n\nprint(a)\nprint(b)","c1f3fa3e":"a + b","fce8610d":"M = np.ones((2, 3))\na = np.arange(3)","bfbbe92e":"M + a","6440152e":"a = np.arange(3).reshape((3, 1))\nb = np.arange(3)","95e3df98":"a + b","a1690c1b":"M = np.ones((3, 2))\na = np.arange(3)","7b37d9ce":"a[:, np.newaxis].shape","3affe9fa":"M + a[:, np.newaxis]","eb9ef7b7":"np.logaddexp(M, a[:, np.newaxis])","dabbfde3":"X = np.random.random((10, 3))","b32726c1":"Xmean = X.mean(0)\nXmean","630070de":"X_centered = X - Xmean","1ca53d58":"X_centered.mean(0)","be7dc113":"# x and y have 50 steps from 0 to 5\nx = np.linspace(0, 5, 50)\ny = np.linspace(0, 5, 50)[:, np.newaxis]\n\nz = np.sin(x) ** 10 + np.cos(10 + y * x) * np.cos(x)","d079f031":"%matplotlib inline\nimport matplotlib.pyplot as plt","a6602632":"plt.imshow(z, origin='lower', extent=[0, 5, 0, 5],\n           cmap='viridis')\nplt.colorbar();","42a58fb0":"The following table lists the arithmetic operators implemented in NumPy:\n\n| Operator | Equivalent | ufunc | Description | \n|----------|------------|-------|-------------|\n| + | np.add | Addition | (e.g., 1 + 1 = 2) |\n| - | np.subtract | Subtraction | (e.g., 3 - 2 = 1) |\n| - | np.negative | Unary negation | (e.g., -2) |\n| * | np.multiply | Multiplication | (e.g., 2 * 3 = 6) |\n| \/ | np.divide | Division | (e.g., 3 \/ 2 = 1.5) |\n| \/\/ | np.floor_divide | Floor division | (e.g., 3 \/\/ 2 = 1) |\n| ** | np.power | Exponentiation | (e.g., 2 ** 3 = 8) |\n| % | np.mod | Modulus\/remainder | (e.g., 9 % 4 = 1) |\n\nAdditionally there are Boolean\/bitwise operators; we will explore these in Comparisons, Masks, and Boolean Logic.","10127619":"To double-check that we've done this correctly, we can check that the centered array has near zero mean:","9079ddec":"### Broadcasting example 2\n\nLet's take a look at an example where both arrays need to be broadcast:","87f1c697":"## Trigonometric functions\n\nNumPy provides a large number of useful ufuncs, and some of the most useful for the data scientist are the trigonometric functions. We'll start by defining an array of angles:","f30b6045":"Broadcasting allows these types of binary operations to be performed on arrays of different sizes\u2013for example, we can just as easily add a scalar (think of it as a zero-dimensional array) to an array:","8f9c85d6":"This implementation probably feels fairly natural to someone from, say, a C or Java background. But if we measure the execution time of this code for a large input, we see that this operation is very slow, perhaps surprisingly so! We'll benchmark this with IPython's `%timeit` magic (discussed in Profiling and Timing Code):","e0755f82":"## Rules of Broadcasting\nBroadcasting in NumPy follows a strict set of rules to determine the interaction between the two arrays:\n\n- Rule 1: If the two arrays differ in their number of dimensions, the shape of the one with fewer dimensions is padded with ones on its leading (left) side.\n- Rule 2: If the shape of the two arrays does not match in any dimension, the array with shape equal to 1 in that dimension is stretched to match the other shape.\n- Rule 3: If in any dimension the sizes disagree and neither is equal to 1, an error is raised.\n\nTo make these rules clear, let's consider a few examples in detail.\n\n### Broadcasting example 1\n\nLet's look at adding a two-dimensional array to a one-dimensional array:","7a021714":"## Introducing UFuncs\nFor many types of operations, NumPy provides a convenient interface into just this kind of statically typed, compiled routine. This is known as a vectorized operation. This can be accomplished by simply performing an operation on the array, which will then be applied to each element. This vectorized approach is designed to push the loop into the compiled layer that underlies NumPy, leading to much faster execution.\n\nCompare the results of the following two:","f3494ecc":"In addition, these can be strung together however you wish, and the standard order of operations is respected:","e6f12cd4":"## Advanced Ufunc Features\n\nMany NumPy users make use of ufuncs without ever learning their full set of features. We'll outline a few specialized features of ufuncs here.","d3816515":"### Splitting of arrays\n\nThe opposite of concatenation is splitting, which is implemented by the functions np.split, np.hsplit, and np.vsplit. For each of these, we can pass a list of indices giving the split points:","09c62fea":"# Introduction to Numpy - II\n\n![numpy_banner](https:\/\/camo.githubusercontent.com\/aa8934e90d93fccd8f6fbaf3be1b3ff1af7deac95c32a612d8b4dbe627d73269\/68747470733a2f2f6d69726f2e6d656469756d2e636f6d2f6d61782f313430302f312a63795843452d4a6342656c5479724b2d353877365f512e706e67)\n\n> ### Reference \n> https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/\n\n---\nThis notebook is in continuation to the previous notebook [Introduction to Numpy I](https:\/\/www.kaggle.com\/thanatoz\/introduction-to-numpy-i\/). Thi\n## Array Concatenation and Splitting\n\nAll of the preceding routines worked on single arrays. It's also possible to combine multiple arrays into one, and to conversely split a single array into multiple arrays. We'll take a look at those operations here.\n\n### Concatenation of arrays\n\nConcatenation, or joining of two arrays in NumPy, is primarily accomplished using the routines `np.concatenate`, `np.vstack`, and `np.hstack`. `np.concatenate` takes a tuple or list of arrays as its first argument, as we can see here:","6534a542":"This is just a slightly different situation than in the first example: the matrix M is transposed. How does this affect the calculation? The shape of the arrays are\n\n- `M.shape = (3, 2)`\n- `a.shape = (3,)`\n\nAgain, rule 1 tells us that we must pad the shape of a with ones:\n\n- `M.shape -> (3, 2)`\n- `a.shape -> (1, 3)`\n\nBy rule 2, the first dimension of a is stretched to match that of M:\n\n- `M.shape -> (3, 2)`\n- `a.shape -> (3, 3)`\n\nNow we hit rule 3\u2013the final shapes do not match, so these two arrays are incompatible, as we can observe by attempting this operation:\n\n```python\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-14-8cac1d547906> in <module>\n----> 1 M + a\n\nValueError: operands could not be broadcast together with shapes (3,2) (3,) \n```\n\nNote the potential confusion here: you could imagine making a and M compatible by, say, padding a's shape with ones on the right rather than the left. But this is not how the broadcasting rules work! That sort of flexibility might be useful in some cases, but it would lead to potential areas of ambiguity. If right-side padding is what you'd like, you can do this explicitly by reshaping the array (we'll use the np.newaxis keyword introduced in The Basics of NumPy Arrays):","75d93bab":"### Introducing Broadcasting\n\nRecall that for arrays of the same size, binary operations are performed on an element-by-element basis:","b6d88cdf":"Let's consider an operation on these two arrays. The shape of the arrays are\n\n- `M.shape = (2, 3)`\n- `a.shape = (3,)`\n\nWe see by rule 1 that the array a has fewer dimensions, so we pad it on the left with ones:\n\n- `M.shape -> (2, 3)`\n- `a.shape -> (1, 3)`\n\nBy rule 2, we now see that the first dimension disagrees, so we stretch this dimension to match:\n\n- `M.shape -> (2, 3)`\n- `a.shape -> (2, 3)`\n\nThe shapes match, and we see that the final shape will be (2, 3):","e404f18a":"### Array arithmetic\n\nNumPy's ufuncs feel very natural to use because they make use of Python's native arithmetic operators. The standard addition, subtraction, multiplication, and division can all be used:","7b8c23e7":"## The Slowness of Loops\n\nWe have already covered this in the previous notebook, but lets talk about this here once more.\n\nPython's default implementation (known as [CPython](https:\/\/cython.org\/)) does some operations very slowly. This is in part due to the dynamic, interpreted nature of the language: the fact that types are flexible, so that sequences of operations cannot be compiled down to efficient machine code as in languages like C and Fortran. Recently there have been various attempts to address this weakness: well-known examples are the PyPy project, a just-in-time compiled implementation of Python; the Cython project, which converts Python code to compilable C code; and the Numba project, which converts snippets of Python code to fast LLVM bytecode. Each of these has its strengths and weaknesses, but it is safe to say that none of the three approaches has yet surpassed the reach and popularity of the standard CPython engine.\n\nThe relative sluggishness of Python generally manifests itself in situations where many small operations are being repeated \u2013 for instance looping over arrays to operate on each element. For example, imagine we have an array of values and we'd like to compute the reciprocal of each. A straightforward approach might look like this:","fc403d5b":"You can also concatenate more than two arrays at once:","5451209c":"This can even be used with array views. For example, we can write the results of a computation to every other element of a specified array:","5bf7b09d":"The values are computed to within machine precision, which is why values that should be zero do not always hit exactly zero. Inverse trigonometric functions are also available:","cdb01dc0":"There are also some specialized versions that are useful for maintaining precision with very small input:\n\n","ee897104":"There are many, many more ufuncs available in both NumPy and `scipy.special`. Because the documentation of these packages is available online, a web search along the lines of \"gamma function python\" will generally find the relevant information.","51c66c44":"Note that for these particular cases, there are dedicated NumPy functions to compute the results (np.sum, np.prod, np.cumsum, np.cumprod), which we'll explore in other notebook.\n\n","5539220a":"The inverse of the exponentials, the logarithms, are also available. The basic np.log gives the natural logarithm; if you prefer to compute the base-2 logarithm or the base-10 logarithm, these are available as well:","c4c09fd1":"### Specifying output\n\nFor large calculations, it is sometimes useful to be able to specify the array where the result of the calculation will be stored. Rather than creating a temporary array, this can be used to write computation results directly to the memory location where you'd like them to be. For all ufuncs, this can be done using the out argument of the function:","97a55510":"The result is a compelling visualization of the two-dimensional function.","aafd04cd":"### Outer products\n\nFinally, any ufunc can compute the output of all pairs of two different inputs using the outer method. This allows you, in one line, to do things like create a multiplication table:","a52e512f":"If we'd like to store all the intermediate results of the computation, we can instead use `accumulate`:\n","0607af61":"We can think of this as an operation that stretches or duplicates the value $5$ into the array $[5, 5, 5]$ , and adds the results. The advantage of NumPy's broadcasting is that this duplication of values does not actually take place, but it is a useful mental model as we think about broadcasting.\n\nWe can similarly extend this to arrays of higher dimension. Observe the result when we add a one-dimensional array to a two-dimensional array:","79429557":"## Computation on Arrays: Broadcasting\n\nWe saw in the previous section how NumPy's universal functions can be used to vectorize operations and thereby remove slow Python loops. Another means of vectorizing operations is to use NumPy's broadcasting functionality. Broadcasting is simply a set of rules for applying binary ufuncs (e.g., addition, subtraction, multiplication, etc.) on arrays of different sizes.","55249b8f":"## Specialized ufuncs\n\nNumPy has many more ufuncs available, including hyperbolic trig functions, bitwise arithmetic, comparison operators, conversions from radians to degrees, rounding and remainders, and much more. A look through the NumPy documentation reveals a lot of interesting functionality.\n\nAnother excellent source for more specialized and obscure ufuncs is the submodule scipy.special. If you want to compute some obscure mathematical function on your data, chances are it is implemented in scipy.special. There are far too many functions to list them all, but the following snippet shows a couple that might come up in a statistics context:","ed7fce98":"We can compute the mean of each feature using the mean aggregate across the first dimension:","c019edb1":"## Numpy Universal Functions\nUp until now, we have been discussing some of the basic nuts and bolts of NumPy; in the next few sections, we will dive into the reasons that NumPy is so important in the Python data science world. Namely, it provides an easy and flexible interface to optimized computation with arrays of data.\n\nComputation on NumPy arrays can be very fast, or it can be very slow. The key to making it fast is to use vectorized operations, generally implemented through NumPy's universal functions (ufuncs). This section motivates the need for NumPy's ufuncs, which can be used to make repeated calculations on array elements much more efficient. It then introduces many of the most common and useful arithmetic ufuncs available in the NumPy package.","4d0115e0":"The `ufunc.at` and `ufunc.reduceat` methods, which we'll explore in Fancy Indexing, are very helpful as well.\n\nAnother extremely useful feature of ufuncs is the ability to operate between arrays of different sizes and shapes, a set of operations known as broadcasting. This subject is important enough that we will devote a whole section to it (see Computation on Arrays: Broadcasting).","379bc58c":"Vectorized operations in NumPy are implemented via ufuncs, whose main purpose is to quickly execute repeated operations on values in NumPy arrays. Ufuncs are extremely flexible \u2013 before we saw an operation between a scalar and an array, but we can also operate between two arrays:","ffcf0d01":"When `x` is very small, these functions give more precise values than if the raw `np.log` or `np.exp` were to be used.","c6ce80ea":"Each of these arithmetic operations are simply convenient wrappers around specific functions built into NumPy; for example, the $+$ operator is a wrapper for the `add` function:","4cd02c4e":"For working with arrays of mixed dimensions, it can be clearer to use the np.vstack (vertical stack) and np.hstack (horizontal stack) functions:","a47fb50b":"To within machine precision, the mean is now zero.","7b51b2b2":"### Aggregates\n\nFor binary ufuncs, there are some interesting aggregates that can be computed directly from the object. For example, if we'd like to reduce an array with a particular operation, we can use the reduce method of any ufunc. A reduce repeatedly applies a given operation to the elements of an array until only a single result remains.\n\nFor example, calling reduce on the add ufunc returns the sum of all elements in the array:","b7ac3dbf":"### Broadcasting example 3\n\nNow let's take a look at an example in which the two arrays are not compatible:","c0df1f4d":"Computations using vectorization through ufuncs are nearly always more efficient than their counterpart implemented using Python loops, especially as the arrays grow in size. Any time you see such a loop in a Python script, you should consider whether it can be replaced with a vectorized expression.","05b048fb":"There is also a unary ufunc for negation, and a ** operator for exponentiation, and a % operator for modulus:\n\n","fbb79381":"This ufunc can also handle complex data, in which the absolute value returns the magnitude:","f56867e1":"### Absolute value\n\nJust as NumPy understands Python's built-in arithmetic operators, it also understands Python's built-in absolute value function:","cf2f819f":"Notice that N split-points, leads to N + 1 subarrays. The related functions np.hsplit and np.vsplit are similar:","c48cb007":"It takes several seconds to compute these million operations and to store the result! When even cell phones have processing speeds measured in Giga-FLOPS (i.e., billions of numerical operations per second), this seems almost absurdly slow. It turns out that the bottleneck here is not the operations themselves, but the type-checking and function dispatches that CPython must do at each cycle of the loop. Each time the reciprocal is computed, Python first examines the object's type and does a dynamic lookup of the correct function to use for that type. If we were working in compiled code instead, this type specification would be known before the code executes and the result could be computed much more efficiently.","acce0409":"## Plotting a two-dimensional function\n\nOne place that broadcasting is very useful is in displaying images based on two-dimensional functions. If we want to define a function z=f(x,y), broadcasting can be used to compute the function across the grid:","5a066bf9":"Again, we'll start by writing out the shape of the arrays:\n\n- `a.shape = (3, 1)`\n- `b.shape = (3,)`\nRule 1 says we must pad the shape of b with ones:\n\n- `a.shape -> (3, 1)`\n- `b.shape -> (1, 3)`\n\nAnd rule 2 tells us that we upgrade each of these ones to match the corresponding size of the other array:\n\n- `a.shape -> (3, 3)`\n- `b.shape -> (3, 3)`\n\nBecause the result matches, these shapes are compatible. We can see this here:","da14c8ea":"Also note that while we've been focusing on the `+` operator here, these broadcasting rules apply to any binary ufunc. For example, here is the `logaddexp(a, b)` function, which computes `log(exp(a) + exp(b))` with more precision than the naive approach:","0d5d43c5":"### Ufuncs: Learning More\nMore information on universal functions (including the full list of available functions) can be found on the NumPy and SciPy documentation websites.\n\nRecall that you can also access information directly from within IPython by importing the packages and using IPython's tab-completion and help (?) functionality, as described in Help and Documentation in IPython.","60ad9348":"### Exponents and logarithms\n\nAnother common type of operation available in a NumPy ufunc are the exponentials:","68e3c309":"If we had instead written `y[::2] = 2 ** x`, this would have resulted in the creation of a temporary array to hold the results of `2 ** x`, followed by a second operation copying those values into the y array. This doesn't make much of a difference for such a small computation, but for very large arrays the memory savings from careful use of the out argument can be significant.","135533a3":"Similarly, calling reduce on the multiply ufunc results in the product of all array elements:","6449f187":"## Broadcasting in Practice\n\nBroadcasting operations form the core of many examples we'll see throughout this book. We'll now take a look at a couple simple examples of where they can be useful.\n\n## Centering an array\n\nIn the previous section, we saw that ufuncs allow a NumPy user to remove the need to explicitly write slow Python loops. Broadcasting extends this ability. One commonly seen example is when centering an array of data. Imagine you have an array of 10 observations, each of which consists of $3$ values. Using the standard convention (see Data Representation in Scikit-Learn), we'll store this in a $10 * 3$ array:","59f65da4":"Similary, np.hstack will stack arrays along the third axis.","1111a07d":"## Exploring NumPy's UFuncs\nUfuncs exist in two flavors: unary ufuncs, which operate on a single input, and binary ufuncs, which operate on two inputs. We'll see examples of both these types of functions here."}}