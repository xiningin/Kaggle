{"cell_type":{"5950bac5":"code","c01e341a":"code","9736be38":"code","b5b1c562":"code","29d4332a":"code","35e8d0e7":"code","07ba7963":"code","bb9ea387":"code","008343c4":"code","78ba5771":"code","06d9209a":"code","20b6b70c":"code","dc68fdea":"code","05e4272d":"code","4738cfaf":"code","af84ef37":"code","bdf9d40d":"code","55e689f3":"code","7b3dbbf5":"code","150444a6":"code","a67761ee":"code","2f978959":"code","1bfcedcf":"code","7b50def6":"code","4636c899":"code","c9553a72":"code","20276b7d":"code","c3379849":"code","71d6f364":"code","b87edd4a":"code","2cbfccef":"code","e30dedbf":"code","13f05777":"code","31fd1e73":"code","9792b35e":"markdown","8f3fa625":"markdown","d656f2b7":"markdown","12a15bc1":"markdown","3169fe15":"markdown","57133c04":"markdown","bab320b0":"markdown","ff0c9449":"markdown","6ae734b4":"markdown","e783d375":"markdown","6343406b":"markdown","32c855c9":"markdown","03622bc2":"markdown","6533380f":"markdown","cd813789":"markdown"},"source":{"5950bac5":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\nfrom itertools import groupby\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom sklearn.linear_model import LinearRegression\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","c01e341a":"dtypes = {\n     'sessionTime' : \"float32\",\n     'frameIdentifier' : \"uint32\",\n     'pilot_index' : \"uint8\",\n     'worldPositionX' : \"float32\",\n     'worldPositionY' : \"float32\",\n     'worldPositionZ' : \"float32\",\n     'worldVelocityX' : \"float32\",\n     'worldVelocityY' : \"float32\",\n     'worldVelocityZ' : \"float32\",\n     'worldForwardDirX' : \"int32\",\n     'worldForwardDirY' : \"int32\",\n     'worldForwardDirZ' : \"int32\",\n     'worldRightDirX' : \"int32\",\n     'worldRightDirY' : \"int32\",\n     'worldRightDirZ' : \"int32\",\n     'gForceLateral' : \"float32\",\n     'gForceLongitudinal' : \"float32\",\n     'gForceVertical' : \"float32\",\n     'yaw' : \"float32\",\n     'pitch' : \"float32\",\n     'roll' : \"float32\",\n     'speed' : \"float32\",\n     'throttle' : \"float32\",\n     'steer' : \"float32\",\n     'brake' : \"float32\",\n     'clutch': \"uint8\",\n     'gear': \"uint8\",\n     'engineRPM' : \"uint32\",\n     'drs' : \"bool\",\n     'engineTemperature': \"uint8\",\n     'fuelMix': \"uint8\",\n     'pitLimiterStatus': \"bool\",\n     'fuelInTank' : \"float32\",\n     'fuelRemainingLaps' : \"float32\",\n     'ersStoreEnergy' : \"uint32\",\n     'ersDeployMode' : \"uint32\",\n     'ersHarvestedThisLapMGUK' : \"uint32\",\n     'ersHarvestedThisLapMGUH' : \"uint32\",\n     'ersDeployedThisLap' : \"uint32\",\n     'carPosition' : \"uint8\",\n     'currentLapTime' : \"float32\",\n     'currentLapNum' : \"uint8\",\n     'sector': \"uint8\",\n     'lapDistance' : \"float32\",\n     'totalDistance' : \"float32\",\n}\n\nfillnas = {\n    'clutch' : 0,\n    'gear' : 0,\n    'engineRPM': 0,\n    \"engineTemperature\" : 0,\n    \"fuelMix\": 1,\n    \"pitLimiterStatus\" : False,\n    \"ersStoreEnergy\" : 4e7,\n    \"ersDeployMode\" : 1,\n    \"ersHarvestedThisLapMGUK\" : 0,\n    \"ersHarvestedThisLapMGUH\" : 0,\n    \"ersDeployedThisLap\" : 0,\n    \"sector\" : 0\n}","9736be38":"df = pd.read_csv(\"\/kaggle\/input\/f1-2020-race-data\/TelemetryData_3335673977098133433.csv\")\nteam = pd.read_csv(\"\/kaggle\/input\/f1-2020-race-data\/ParticipantData_3335673977098133433.csv\")\nsession = pd.read_csv(\"\/kaggle\/input\/f1-2020-race-data\/SessionData_3335673977098133433.csv\").iloc[0].to_dict()\nprint(session)","b5b1c562":"for col, dtype in dtypes.items():\n    if col in fillnas:\n        df[col] = df[col].fillna(fillnas[col])\n    df[col] = df[col].astype(dtype)","29d4332a":"def remove_flashbacks(df, pilot=19):\n    df2 = df[df[\"pilot_index\"] == pilot]\n    frame, X = df2[\"frameIdentifier\"].values, df2[[\"worldPositionX\", \"worldPositionY\", \"worldPositionZ\"]].values\n    dist_sq = ((X[1:, :] - X[:-1, :])**2).sum(axis=1)\n    idx_frame_after_flashback = np.argwhere(dist_sq > 1000).flatten() + 1 # to add the frame 0 shifted for the distance computation\n    \n    number_flashback = idx_frame_after_flashback.shape[0]\n    pos_before_flashback = X[idx_frame_after_flashback-1]\n    pos_after_flashback = X[idx_frame_after_flashback]  # position after validateing the flashback\n    frames_before_flashback = frame[idx_frame_after_flashback-1]\n    frames_after_flashback = frame[idx_frame_after_flashback] # first frame after validating the flashback\n    \n    for i in range(number_flashback):\n        X_start = pos_after_flashback[i, :]\n        frame_start = frames_after_flashback[i]\n        idx_pos = idx_frame_after_flashback[i]\n        d = ((X[idx_pos-500:idx_pos] - X_start)**2).sum(axis=1)\n        start, stop = frame[idx_pos - 500 + np.argmin(d)], frame_start\n        df = df[(df[\"frameIdentifier\"] > stop) | (df[\"frameIdentifier\"] <= start)]\n        \n    return df\n\ndf = remove_flashbacks(df, pilot=19)","35e8d0e7":"pilot_id = 1\nlap = 15\n\ntemp = df[(df[\"pilot_index\"] == pilot_id) & (df[\"currentLapNum\"] == lap)]\n\nc = [[\"b\", \"g\", \"r\"][x] for x in temp[\"fuelMix\"]]\n\nplt.figure(figsize=(20, 12))\nplt.scatter(temp[\"worldPositionZ\"], temp[\"worldPositionX\"], marker=\"o\", s=1, c=c)\nplt.axis('equal')\n# plt.xlim(-500, -300)\n# plt.ylim(-200, 0)\nplt.show()","07ba7963":"mixes = df.groupby([\"pilot_index\", \"currentLapNum\"]).apply(lambda x: x[\"fuelMix\"].value_counts() \/ len(x)).reset_index()\nmixes = mixes.pivot_table(index=[\"pilot_index\", \"currentLapNum\"], values='fuelMix', columns='level_2')\nmixes = mixes.fillna(0)\nmixes.columns = [\"Lean\", \"Normal\", \"Rich\"]","bb9ea387":"mixes.head()","008343c4":"fig, axes = plt.subplots(5, 4, figsize=(30, 30))\nfor i in range(20):\n    mixes[mixes.index.get_level_values(0) == i].reset_index().set_index(\"currentLapNum\").drop(\"pilot_index\", axis=1).plot(kind='bar', stacked=True, ax=axes[i\/\/4][i%4])\n    axes[i\/\/4][i%4].set_title(team[team[\"pilot_index\"] == i][\"driverId\"].values[0])\nplt.show()","78ba5771":"fuel = df.groupby([\"pilot_index\", \"currentLapNum\"]).agg({\n    \"fuelRemainingLaps\" : [\"min\", \"max\", \"mean\"]\n}).reset_index()","06d9209a":"fuel.head()","20b6b70c":"fig, axes = plt.subplots(5, 4, figsize=(30, 30))\nfor i in range(20):\n    temp = fuel[fuel[\"pilot_index\"] == i]\n    axes[i\/\/4][i%4].plot(temp[\"currentLapNum\"], temp[(\"fuelRemainingLaps\", \"max\")], c=\"r\")\n    axes[i\/\/4][i%4].plot(temp[\"currentLapNum\"], temp[(\"fuelRemainingLaps\", \"mean\")], c=\"b\")\n    axes[i\/\/4][i%4].plot(temp[\"currentLapNum\"], temp[(\"fuelRemainingLaps\", \"min\")], c=\"g\")\n    axes[i\/\/4][i%4].fill_between( temp[\"currentLapNum\"], temp[(\"fuelRemainingLaps\", \"min\")], temp[(\"fuelRemainingLaps\", \"max\")], alpha = 0.3, color=\"y\")\n    axes[i\/\/4][i%4].set_title(team[team[\"pilot_index\"] == i][\"driverId\"].values[0])\nplt.show()","dc68fdea":"def get_ratio_fuel(df):\n    dist = df[\"lapDistance\"].values\n\n    ans = [0, 0, 0]\n    for key, seq in groupby( df[\"fuelMix\"].values):\n        n = len(list(seq))\n        ans[key] += (dist[n-1] - dist[0]) \/ session[\"trackLength\"]\n        dist = dist[n:]\n\n    return ans\n\ndef get_fuel_diff(df):\n    return df[\"fuelInTank\"].max() - df[\"fuelInTank\"].min()\n\ndef engine_provider(team):\n    a = {\n        \"Ferrari\": \"Ferrari\",\n        \"Mercedes\": \"Mercedes\",\n        \"Renault\": \"Renault\",\n        \"McLaren\": \"Renault\",\n        \"Red Bull Racing\": \"Honda\",\n        \"Toro Rosso\": \"Honda\",\n        \"Racing Point\": \"Mercedes\",\n        \"Williams\": \"Mercedes\",\n        \"Alfa Romeo\": \"Ferrari\",\n        \"Haas\": \"Ferrari\"\n    }\n    return a[team]\n\nmix = df.groupby([\"pilot_index\", \"currentLapNum\"]).apply(get_ratio_fuel).rename(\"percent_mix\").reset_index()\nmix[\"lean\"] = mix[\"percent_mix\"].apply(lambda x:x[0])\nmix[\"normal\"] = mix[\"percent_mix\"].apply(lambda x:x[1])\nmix[\"rich\"] = mix[\"percent_mix\"].apply(lambda x:x[2])\n\nconsumed_fuel = df.groupby([\"pilot_index\", \"currentLapNum\"]).apply(get_fuel_diff).rename(\"fuel_burned\").reset_index()\n\nfuel = pd.merge(mix, consumed_fuel, how=\"left\", left_on=[\"pilot_index\", \"currentLapNum\"], right_on = [\"pilot_index\", \"currentLapNum\"])\nfuel = pd.merge(fuel, team, how=\"left\", left_on=[\"pilot_index\"], right_on = [\"pilot_index\"])\nfuel[\"motor\"] = fuel[\"teamId\"].apply(engine_provider)\nfuel.head()","05e4272d":"def get_model(df):\n    X = df[[\"lean\", \"normal\", \"rich\"]].values\n    y = df[\"fuel_burned\"].values\n    \n    mdl = LinearRegression(fit_intercept=False)\n    mdl.fit(X, y)\n    \n#     print(mdl.score(X, y))\n    \n    return mdl.coef_\n\nans = fuel.groupby(\"motor\").apply(get_model)\nprint(ans)","4738cfaf":"a, b, c = get_model(fuel)\nprint(f\"In Lean mix, the consumption is {a:.3f} kg\/lap\")\nprint(f\"In Normal mix, the consumption is {b:.3f} kg\/lap\")\nprint(f\"In Rich mix, the consumption is {c:.3f} kg\/lap\")","af84ef37":"ans","bdf9d40d":"filterered_fuel = fuel[fuel[\"lean\"] == 0]\nplt.scatter(filterered_fuel[\"normal\"], filterered_fuel[\"fuel_burned\"], alpha = 0.3)\nplt.plot([0, 1], [c, b])\nplt.show()","55e689f3":"pilot_id = 19\nlap = 2\n\ntemp = df[(df[\"pilot_index\"] == pilot_id) & (df[\"currentLapNum\"] == lap)]\n\nc = [[\"b\", \"g\", \"r\"][x] for x in temp[\"ersDeployMode\"]]\n\nplt.figure(figsize=(20, 12))\nplt.scatter(temp[\"worldPositionZ\"], temp[\"worldPositionX\"], marker=\"o\", s=1, c=c)\nplt.axis('equal')\n# plt.xlim(-500, -300)\n# plt.ylim(-200, 0)\nplt.show()","7b3dbbf5":"ers = df.groupby([\"pilot_index\", \"currentLapNum\"]).apply(lambda x: x[\"ersDeployMode\"].value_counts() \/ len(x)).reset_index()\ners = ers.pivot_table(index=[\"pilot_index\", \"currentLapNum\"], values='ersDeployMode', columns='level_2')\ners = ers.fillna(0)\ners.columns = [\"Disable\", \"Normal\", \"OT mode\"]","150444a6":"fig, axes = plt.subplots(5, 4, figsize=(30, 30))\nfor i in range(20):\n    ers[ers.index.get_level_values(0) == i].reset_index().set_index(\"currentLapNum\").drop(\"pilot_index\", axis=1).plot(kind='bar', stacked=True, ax=axes[i\/\/4][i%4])\n    axes[i\/\/4][i%4].set_title(team[team[\"pilot_index\"] == i][\"driverId\"].values[0])\nplt.show()","a67761ee":"energy = df[df[\"ersStoreEnergy\"] <= 4e6].groupby([\"pilot_index\", \"currentLapNum\"]).agg({\n    \"ersStoreEnergy\" : [\"min\", \"max\", \"mean\"]\n}).reset_index()\n\n# some point have invalid values with 4e7 to be filtered","2f978959":"fig, axes = plt.subplots(5, 4, figsize=(30, 30))\nfor i in range(20):\n    temp = energy[energy[\"pilot_index\"] == i]\n    axes[i\/\/4][i%4].plot(temp[\"currentLapNum\"], temp[(\"ersStoreEnergy\", \"max\")], c=\"r\")\n    axes[i\/\/4][i%4].plot(temp[\"currentLapNum\"], temp[(\"ersStoreEnergy\", \"mean\")], c=\"b\")\n    axes[i\/\/4][i%4].plot(temp[\"currentLapNum\"], temp[(\"ersStoreEnergy\", \"min\")], c=\"g\")\n    axes[i\/\/4][i%4].fill_between( temp[\"currentLapNum\"], temp[(\"ersStoreEnergy\", \"min\")], temp[(\"ersStoreEnergy\", \"max\")], alpha = 0.3, color=\"y\")\n    axes[i\/\/4][i%4].set_title(team[team[\"pilot_index\"] == i][\"driverId\"].values[0])\nplt.show()","1bfcedcf":"def get_ratio_ers(df):\n    dist = df[\"lapDistance\"].values\n\n    ans = [0, 0, 0]\n    for key, seq in groupby( df[\"ersDeployMode\"].values):\n        n = len(list(seq))\n        ans[key] += (dist[n-1] - dist[0]) \/ session[\"trackLength\"]\n        dist = dist[n:]\n\n    return ans","7b50def6":"ers_used = df.groupby([\"pilot_index\", \"currentLapNum\"]).agg({\n    \"ersDeployedThisLap\" : \"max\"\n}).reset_index()","4636c899":"ers = df.groupby([\"pilot_index\", \"currentLapNum\"]).apply(get_ratio_ers).rename(\"ers_mix\").reset_index()\ners[\"Disable\"] = ers[\"ers_mix\"].apply(lambda x:x[0])\ners[\"Normal\"] = ers[\"ers_mix\"].apply(lambda x:x[1])\ners[\"Overtake\"] = ers[\"ers_mix\"].apply(lambda x:x[2])\n\ners = pd.merge(ers, ers_used, how=\"left\", left_on=[\"pilot_index\", \"currentLapNum\"], right_on = [\"pilot_index\", \"currentLapNum\"])\ners = pd.merge(ers, team, how=\"left\", left_on=[\"pilot_index\"], right_on = [\"pilot_index\"])\ners.head()","c9553a72":"def get_model(df):\n    X = df[[\"Disable\", \"Normal\", \"Overtake\"]].values\n    y = df[\"ersDeployedThisLap\"].values\n    \n    mdl = LinearRegression(fit_intercept=False)\n    mdl.fit(X, y)\n    \n    return mdl.coef_\n\ners.groupby([\"pilot_index\"]).apply(get_model)","20276b7d":"a, b, c = get_model(ers)\nprint(f\"In Disable mode, the consumption is {a:.3f} J\/lap\")\nprint(f\"In Normal mode, the consumption is {b:.3f} J\/lap\")\nprint(f\"In Overtake mode, the consumption is {c:.3f} J\/lap\")","c3379849":"filterered_ers = ers[ers[\"Disable\"] == 0]  # normally nothing is removed\nplt.scatter(filterered_ers[\"Normal\"], filterered_ers[\"ersDeployedThisLap\"], alpha = 0.3)\nplt.plot([0, 1], [c, b])\nplt.show()","71d6f364":"ers_harvested = df[[\"pilot_index\", \"currentLapNum\", 'ersHarvestedThisLapMGUK', 'ersHarvestedThisLapMGUH']].groupby([\"pilot_index\", \"currentLapNum\"]).max().reset_index()\n\n# remove last lap as they are not always completed\ners_harvested = ers_harvested[ers_harvested[\"currentLapNum\"] < 28]","b87edd4a":"fig, (ax, ax2) = plt.subplots(1, 2, figsize=(30, 12))\nsns.boxplot(x=\"currentLapNum\", y='ersHarvestedThisLapMGUK', data=ers_harvested, ax=ax)\nsns.boxplot(x=\"currentLapNum\", y='ersHarvestedThisLapMGUH', data=ers_harvested, ax=ax2)\nplt.show()","2cbfccef":"ers_harvested[['ersHarvestedThisLapMGUK', 'ersHarvestedThisLapMGUH']].mean()","e30dedbf":"ers_harvested = pd.merge(ers_harvested, team[[\"pilot_index\", \"driverId\", \"teamId\"]], how=\"left\", left_on=[\"pilot_index\"], right_on = [\"pilot_index\"])","13f05777":"fig, (ax, ax2) = plt.subplots(1, 2, figsize=(30, 12))\nsns.boxplot(x=\"teamId\", y='ersHarvestedThisLapMGUK', data=ers_harvested, ax=ax)\nsns.boxplot(x=\"teamId\", y='ersHarvestedThisLapMGUH', data=ers_harvested, ax=ax2)\nplt.show()","31fd1e73":"print(f\"The average energy harvested by the MGUK is {ers_harvested.median()['ersHarvestedThisLapMGUK']:.0f} J\")\nprint(f\"The average energy harvested by the MGUH is {ers_harvested.median()['ersHarvestedThisLapMGUH']:.0f} J\")","9792b35e":"Similarly to the fuel, we can assume that the energy consumed can be evaluated as:\n\n$ Fuel = ERS_{OT} * Percent_{OT} + ERS_{Normal} * Percent_{Normal} + ERS_{Disable} * Percent_{Disable} + 0 $\n\nIn principle, the disable should be 0 as it mean no energy is used and it is not used in race","8f3fa625":"The model used can be a linear one as it is simple to understand that:\n\n$ Fuel = Fuel_{Rich} * Percent_{Rich} + Fuel_{Normal} * Percent_{Normal} + Fuel_{Lean} * Percent_{Lean} + 0 $\n\nso we can train a linear model with an intercept at 0","d656f2b7":"Are harvesting systems identical between teams ?","12a15bc1":"# Fuel Mix\n\nDuring the race, there is mainly 2 option we can play with:\n\n- The fuel Mix to have more or less engine power form the Internal Combustion Engine\n- The ERS (Energy Recovery System) which is storing energy during braking and can be use to have an extra boost of power. It has 2 states\n    - Normal Mode where the energy is released automatically\n    - Overtake Mode where the full power is provided (but consume a lot more). In addition, there is restriction of energy used\/stored per lap.\n    \nLet's look on a lap where the fuel mix is used","3169fe15":"## ERS recuperation\n\nFinally, let's look at the energy recuperation","57133c04":"On lap 13\/14, the value is a lot higher due to pit stop, there is 1 more break and the MGUH is working for free in the pit lane. We can also remark that :\n\n- The production of the MGUK decrease over lap, this is because it harvest energy during break. The car having more fuel, it has more kinetic energy so it harvests more.\n- The production of the MGUK is stable over lap, this is because it harvest energy from the engine during break. This is more stable because the engine still rotate at same speed. The only small decrease is due to the breaking distance which is slightly shorter.","bab320b0":"In term of strategy I am used to save a bit of fuel all along the race to be able to have a good amount on lasts lap to try to get the fastest lap as the car il lighter. I'm also trying to keep soft tyre for the end as there is less wear with a lighter car. Let's see if I.A. are all using the same strategy and which one it is (use a lot in first laps and them regularly every lap for example) ?","ff0c9449":"During each race, in case of accident, a flashback can be used to return to a previous position. This comes from the Notebook [Estimation of the time lost in pit](https:\/\/www.kaggle.com\/coni57\/estimation-of-time-lost-in-pit) so I'll just reuse it as is","6ae734b4":"Except the value for the Lean mix with Honda (due to nearly no values so a big value is used to correct slightly the model - overfitting), values look very similar. We can train the model without taking care of the provider","e783d375":"That's good, they don't use it the same way. It would be fun to check but a bit complicated if they are only using it as defense when they are attacked by another car. Now it would be good to estimate how much feul each lap is consuming based on the engine provider and the mix used. So let's compute the percentage of *distance* per pilot and per lap with each mix","6343406b":"The energy harvested is quite stable by team except the MGUK which has some laps with more MGUK recuperation. ","32c855c9":"In term of strategy I am used to save a bit of energy at the middle of the race to be able to have a good amount on lasts lap to try to get the fastest lap as the fuel tank is nearly empty. I'm also trying to keep soft tyre for the end as there is less wear with a lighter car. Let's see if I.A. are all using the same strategy and which one it is (use a lot in first laps and them regularly every lap for example) ?","03622bc2":"## Model to estimate the energy consumption","6533380f":"# ERS Mode\n\nWe can do the same analysis for the ERS Strategy. However, it is however less obvious to determine the consumption of the ERS. What can be done is to determine how many Joule we can harvest in a lap.","cd813789":"# Loading data\n\nFirst let's load an convert data to reduce the dataframe size"}}