{"cell_type":{"53d210fe":"code","38e3f5c3":"code","c85c2c51":"code","9378e3a7":"code","e7ac5a3e":"code","abbf1080":"code","6f3b6ade":"code","d22f7c4a":"code","a09e9d20":"code","4e34a63e":"code","26135c92":"code","98679c61":"code","ccddf9d7":"code","4be182b9":"code","00840481":"code","79acb0ae":"code","7ecdb1d8":"code","6b06345e":"code","5c3110ee":"code","3238edf6":"code","566f2a47":"code","1b97df1a":"code","f7afa18d":"code","75e74c10":"code","c56f655a":"code","cb16a382":"code","4e474d4e":"code","f8155c5b":"code","264223c5":"code","dab12e5e":"code","d0d87a3d":"code","0eec7b3d":"code","a0008753":"code","f5992fb7":"code","3cf2b6b2":"code","2f6881b5":"markdown","ebbbdb72":"markdown","f129d4f2":"markdown","96043265":"markdown","77da8366":"markdown","2c966adc":"markdown","615ad2e4":"markdown","a84a952a":"markdown","efee8500":"markdown","93895731":"markdown","0453c721":"markdown"},"source":{"53d210fe":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport nltk\nimport re\nfrom nltk.corpus import stopwords\nfrom nltk.tokenize import word_tokenize, sent_tokenize\nfrom sklearn.model_selection import StratifiedShuffleSplit, StratifiedKFold\nfrom scipy.sparse import hstack, vstack, csr_matrix\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.preprocessing import MinMaxScaler\nfrom lightgbm import LGBMRegressor\nfrom sklearn.metrics import mean_squared_error\nimport optuna\nfrom transformers import RobertaTokenizer, TFRobertaModel\n\nimport tensorflow as tf\nfrom tensorflow import keras\nimport tensorflow_hub as hub\nfrom tensorflow.keras.optimizers.schedules import PolynomialDecay\nfrom tensorflow.keras.optimizers import Adam\n\nnp.random.seed(42)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","38e3f5c3":"train = pd.read_csv(\"\/kaggle\/input\/commonlitreadabilityprize\/train.csv\", low_memory=False)\ntest = pd.read_csv(\"\/kaggle\/input\/commonlitreadabilityprize\/test.csv\", low_memory=False)\ntrain.info(memory_usage=\"deep\")","c85c2c51":"test.info(memory_usage=\"deep\")","9378e3a7":"train.head()","e7ac5a3e":"train[\"target\"].describe()","abbf1080":"fig, ax = plt.subplots(figsize=(7, 4))\nax.hist(train[\"target\"], bins=20, edgecolor=\"black\", color=\"steelblue\")\nax.set_title(\"Target distribution\", fontsize=15)\nax.set_xlabel(\"Target\", fontsize=12)\nax.set_ylabel(\"Amount of observations\", fontsize=12)\nplt.show();","6f3b6ade":"train[\"standard_error\"].describe()","d22f7c4a":"fig, ax = plt.subplots(figsize=(7, 4))\nax.hist(train[\"standard_error\"], bins=20, edgecolor=\"black\", color=\"palevioletred\")\nax.set_title(\"Standard error distribution\", fontsize=15)\nax.set_xlabel(\"Standard error\", fontsize=12)\nax.set_ylabel(\"Amount of observations\", fontsize=12)\nplt.show();","a09e9d20":"def get_text_data_parameters(data, stop_words):\n    \"\"\"\n    Calculates some numeric parameters of paragraphs of the given series object.\n    \"\"\"\n    \n    text_shortage = []\n    quotes = []\n    sentences = []\n    sent_length = []\n    word_length = []\n    lemma_length = []\n    \n#     new_data = []\n    for row in data:\n        # Amount of quotes devided by 2 to determine if there is any dialogue\n        quotes.append(row.count('\"')\/2)\n        # The original, raw text paragraph lenght\n        initial_length = len(row)\n        # Using nltk tokenizer to split a text into sentences to determine their amount\n        num_sent = len(sent_tokenize(row))\n        sentences.append(num_sent)\n        # Getting rid of all noncharacter symbols and splitting a text into \n        # words using nltk tokenizer and getting amount of words\n        row = re.sub(\"[^a-zA-Z]\", \" \", row)\n        row = row.lower()\n        row = word_tokenize(row)\n        num_words = len(row)\n        \n        # Calculating mean amount of words per sentence and mean word length \n        sent_length.append(num_words\/num_sent)\n        word_length.append(initial_length\/num_words)\n        # Splitting text data into words and dropping stop words\n        row = [word for word in row if not word in stop_words]\n        # Words lemmatisation\n        lemma = nltk.WordNetLemmatizer()\n        row = [lemma.lemmatize(word) for word in row]\n        num_lemmas = len(row)\n        row = \" \".join(row)\n        # Text length after cleaning and lemmatisation\n        processed_length = len(row)\n        # Calculating mean lemma length and amount of text shrinkage after the processing\n        lemma_length.append(processed_length\/num_lemmas)\n        text_shortage.append(processed_length\/initial_length)\n    \n    # Creating a dataframe containing all calculated parameters\n    result_df = pd.concat([pd.Series(text_shortage), pd.Series(quotes),\n                          pd.Series(sentences), pd.Series(sent_length),\n                          pd.Series(word_length), pd.Series(lemma_length)], axis=1)\n    result_df.columns = [\"text_shortage\", \"num_quotes\",\n                        \"num_sentences\", \"sent_length\",\n                        \"mean_word_length\", \"mean_lemma_length\"]\n    \n    return result_df","4e34a63e":"# Stopwords import from nltk \nstop_words = set(stopwords.words(\"english\"))","26135c92":"text_params = get_text_data_parameters(train[\"excerpt\"].copy(), stop_words)\ntext_params.head()","98679c61":"df = pd.concat([text_params, train[\"target\"]], axis=1)\n\nax = sns.pairplot(data=df,\n                  diag_kws=dict(bins=15, color=\"lightcoral\"),\n                  plot_kws=dict(color=\"seagreen\"))\nax.fig.suptitle(\"Target and text parameters pairplots\", fontsize=15, y=1.03)\nplt.show();","ccddf9d7":"# Plot dataframe\ncorr = df.corr().round(2)\n\n# Mask to hide upper-right part of plot as it is a duplicate\nmask = np.zeros_like(corr)\nmask[np.triu_indices_from(mask)] = True\n\n# Making a plot\nplt.figure(figsize=(8,8))\nax = sns.heatmap(corr, annot=True, mask=mask, cmap=\"RdBu\", linewidths=1,\n                 annot_kws={\"weight\": \"bold\", \"fontsize\": 13})\n\nax.set_title(\"Target and text parameters heatmap\", fontsize=15, y=1.03)\nplt.show();","4be182b9":"# Loading RoBERTa tokenizer and model\nroberta_tokenizer = RobertaTokenizer.from_pretrained(\"\/kaggle\/input\/roberta-large-model-tensorflow\/\")\nroberta_model = TFRobertaModel.from_pretrained(\"\/kaggle\/input\/roberta-large-model-tensorflow\/\")","00840481":"roberta_model.summary()","79acb0ae":"# Calculating edges of target bins to be used for stratified split\ntarget_bin_edges = np.histogram_bin_edges(train[\"target\"], bins=10)\ntarget_bin_edges[0] = -np.inf\ntarget_bin_edges[-1] = np.inf\ntarget_bins = pd.cut(train[\"target\"], target_bin_edges, labels=np.arange(10))\ntarget_bins","7ecdb1d8":"X = train[\"excerpt\"].copy()\ny = train[\"target\"].copy()\n# Splitting data into train and valid folds using target bins for stratification\nsplit = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)\nfor train_idx, valid_idx in split.split(X, target_bins):\n    X_train, X_valid = X.loc[train_idx], X.loc[valid_idx]\n    y_train, y_valid = y.loc[train_idx], y.loc[valid_idx]","6b06345e":"def tokenize_text(text, tokenizer):\n    input_ids = []\n    attention_mask = []\n    for row in text:\n        tokenized_text = (tokenizer.encode_plus(row, truncation=True, max_length=340, padding=\"max_length\", return_tensors='tf', return_attention_mask=True).data)\n        input_ids.append(tokenized_text[\"input_ids\"][0])\n        attention_mask.append(tokenized_text[\"attention_mask\"][0])\n    return np.array(input_ids), np.array(attention_mask)","5c3110ee":"# tokenized_text = (roberta_tokenizer.encode_plus(X_train.iloc[0], truncation=True, max_length=340, padding=\"max_length\", return_tensors='tf', return_attention_mask=True).data)\n# tokenized_text[\"attention_mask\"][0]","3238edf6":"train_input_ids, train_attention_mask = tokenize_text(X_train, roberta_tokenizer)\nvalid_input_ids, valid_attention_mask = tokenize_text(X_valid, roberta_tokenizer)","566f2a47":"# Forbidding training of model's layers\nfor layer in roberta_model.layers:\n    layer.trainable = True\n\n# Fixing random state of initialized weights to ensure results repeatability\nweight_initializer = tf.keras.initializers.GlorotNormal(seed=42)\n\ninput_ids_layer = tf.keras.layers.Input(shape=(340,), \n                                        name='input_ids', \n                                        dtype='int32')\ninput_attention_layer = tf.keras.layers.Input(shape=(340,), \n                                              name='input_attention', \n                                              dtype='int32')\n\nlast_hidden_state = roberta_model([input_ids_layer, input_attention_layer])[0]\ncls_token = last_hidden_state[:, 0, :]\n\noutput = tf.keras.layers.Dense(1, \n                               activation='linear',\n                               kernel_initializer=weight_initializer,  \n                               )(cls_token)\n\nmodel = tf.keras.Model([input_ids_layer, input_attention_layer], output)\n\nloss = tf.keras.losses.MeanSquaredError()\n\nbatch_size = 32\nnum_epochs = 4\nnum_train_steps = (len(X_train) \/\/ batch_size) * num_epochs\nlr_scheduler = PolynomialDecay(\n    initial_learning_rate=5e-5,\n    end_learning_rate=0.,\n    decay_steps=num_train_steps\n)\n\nopt = Adam(learning_rate=lr_scheduler)\n\nmodel.compile(optimizer=opt, \n              loss=loss)","1b97df1a":"tf.keras.utils.plot_model(model, show_shapes=True, dpi=48)","f7afa18d":"%%time\nmodel.fit(\n        x=[train_input_ids, train_attention_mask],\n        y=y_train.to_numpy(), \n        validation_data=([valid_input_ids, valid_attention_mask], y_valid.to_numpy()),\n        batch_size=2,\n        epochs=4\n)","75e74c10":"def scale_train_text_params(df):\n    scalers = []\n#     scaled_columns = []\n    \n    for column in df.columns:\n        scaler = MinMaxScaler()\n        df[column] = scaler.fit_transform(np.array(df[column]).reshape(-1, 1))\n        scalers.append(scaler)\n#         scaled_columns.append(scaled_column)\n\n    return df, scalers\n\ndef scale_test_text_params(df, scalers):\n#     scaled_columns = []\n    \n    for i, column in enumerate(df.columns):\n        scaler = scalers[i]\n        df[column] = scaler.transform(np.array(df[column]).reshape(-1, 1))\n#         scaled_columns.append(scaled_column)\n\n    return df\n\ndef vectorize_text_data(X_train, text_params, roberta_tokenizer, roberta_model):\n    vectors = []\n    \n    for i, text in enumerate(X_train):\n        encoded_input = roberta_tokenizer.encode_plus(text, truncation=True, max_length=340, padding=\"max_length\", return_tensors='tf', return_attention_mask=True)\n        output = roberta_model(encoded_input)\n        vectors.append(np.array(output[1])[0])\n        if ((i+1) % 100) == 0:\n            print(f\"Vectorized {i+1} of {len(X_train)}\")\n    print(f\"Vectorized {i+1} of {len(X_train)}\")\n    vectorized_text = pd.DataFrame(vectors)\n    print(f\"Vectorized text shape: {vectorized_text.shape}\")\n    \n#     vectorized_text.to_csv('vectorized_text.csv', index=False)\n    \n    X_train = pd.concat((text_params, vectorized_text), axis=1)\n    print(f\"Concatenated data shape: {X_train.shape}\")\n    \n    return X_train","c56f655a":"%%time\n# Scaling text parameters\ntext_params, scalers = scale_train_text_params(text_params)\n# Vectorizing text data and concatenating it with text parameters\nX = vectorize_text_data(train[\"excerpt\"].copy(), text_params, roberta_tokenizer, roberta_model)\ny = train[\"target\"].copy()","cb16a382":"X.head()","4e474d4e":"def train_model_optuna(trial, X_train, X_valid, y_train, y_valid):\n    \"\"\"\n    A function to train a model using different hyperparamerters combinations provided by Optuna. \n    RMSE of validation data predictions is returned to estimate hyperparameters effectiveness.\n    \"\"\"\n    preds = 0\n    \n       \n    #A set of hyperparameters to optimize by optuna\n    lgbm_params = {\n        'objective': trial.suggest_categorical('objective', ['regression']),\n        'boosting_type': trial.suggest_categorical('boosting_type', ['gbdt']),\n        'num_leaves': trial.suggest_int('num_leaves', 2, 31),\n        'max_depth': trial.suggest_int('max_depth', 1, 30),\n        'learning_rate': trial.suggest_float('learning_rate', 0.01, 1),\n        'n_estimators': trial.suggest_categorical('n_estimators', [1000]),        \n        'reg_alpha': trial.suggest_float('reg_alpha', 1.0, 20.0),\n        'reg_lambda': trial.suggest_float('reg_lambda', 0.00001, 0.1),\n        'random_state': trial.suggest_categorical('random_state', [42]), \n        'n_jobs': trial.suggest_categorical('n_jobs', [4]), \n\n    }\n\n    # Model loading and training\n    model = LGBMRegressor(**lgbm_params)\n    model.fit(X_train, y_train,\n              eval_set=[(X_valid, y_valid)],\n              eval_metric=\"rmse\",\n              early_stopping_rounds=100,\n              verbose=False)\n    \n    # Out of fold predictions\n    oof = model.predict(X_valid)\n    # Number of actually grown trees before overfitting is detected \n    print(f\"Number of boosting rounds: {model.best_iteration}\")\n    \n    return np.sqrt(mean_squared_error(y_valid, oof))","f8155c5b":"# %%time\n# # Splitting data into train and valid folds using target bins for stratification\n# split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)\n# for train_idx, valid_idx in split.split(X, target_bins):\n#     X_train, X_valid = X.loc[train_idx], X.loc[valid_idx]\n#     y_train, y_valid = y.loc[train_idx], y.loc[valid_idx]\n# # Setting optuna verbosity to show only warning messages\n# # If the line is uncommeted each iteration results will be shown\n# # optuna.logging.set_verbosity(optuna.logging.WARNING)\n\n# study = optuna.create_study(direction='minimize')\n# study.optimize(lambda trial: train_model_optuna(trial, X_train, X_valid,\n#                                                     y_train, y_valid),\n#                n_trials = 5)\n\n# # Showing optimization results\n# print('Number of finished trials:', len(study.trials))\n# print('Best trial parameters:', study.best_trial.params)\n# print('Best score:', study.best_value)","264223c5":"# The function splits given train data into 10 folds and trains each model on each fold.\n# Each model makes test predictions. Mean predictions are returned. \ndef train_with_folds(X, y, X_test, target_bins, params):\n    splits = 10\n    skf = StratifiedKFold(n_splits=splits, shuffle=True, random_state=42)\n    oof_preds = np.zeros((X.shape[0],))\n    model_preds = 0\n    model_fi = 0\n    for num, (train_idx, valid_idx) in enumerate(skf.split(X, target_bins)):\n        X_train, X_valid = X.loc[train_idx], X.loc[valid_idx]\n        y_train, y_valid = y.loc[train_idx], y.loc[valid_idx]\n        model = LGBMRegressor(**params)\n        model.fit(X_train, y_train,\n                  eval_set=[(X_valid, y_valid)],\n                  eval_metric=\"rmse\",\n                  early_stopping_rounds=100,\n                  verbose=False)\n        model_preds += model.predict(X_test) \/ splits\n        model_fi += model.feature_importances_\n        oof_preds[valid_idx] = model.predict(X_valid)\n        print(f\"Fold {num} RMSE: {np.sqrt(mean_squared_error(y_valid, oof_preds[valid_idx]))}\")\n    model_rmsle = np.sqrt(mean_squared_error(y, oof_preds))\n    print(f\"Overall RMSE: {model_rmsle}\")\n    \n    return model_preds, model_fi","dab12e5e":"# Hyperparameters values optimized by Optuna\nlgbm_params = {'objective': 'regression',\n               'boosting_type': 'gbdt',\n               'num_leaves': 13,\n               'max_depth': 6,\n               'learning_rate': 0.11136686062332299,\n               'n_estimators': 3000,\n               'reg_alpha': 2.129407050814302,\n               'reg_lambda': 0.05088230910987312,\n               'random_state': 42,\n               'n_jobs': 4}","d0d87a3d":"# Preprocessing test data\ntext_params = get_text_data_parameters(test[\"excerpt\"], stop_words)\ntext_params = scale_test_text_params(text_params, scalers)\nX_test = vectorize_text_data(test[\"excerpt\"], text_params, roberta_tokenizer, roberta_model)","0eec7b3d":"%%time\npreds, feature_importances = train_with_folds(X, y, X_test, target_bins, lgbm_params)","a0008753":"fig, ax = plt.subplots(figsize=(16, 5))\nax = sns.lineplot(data=pd.Series(feature_importances))\nax.set_title(\"Feature importance\")\nax.set_xlabel(\"Feature number\")\nax.set_ylabel(\"Importance\")\nplt.show();","f5992fb7":"fig, ax = plt.subplots(figsize=(5, 5))\nax = sns.lineplot(x=text_params.columns, y=pd.Series(feature_importances[:6]))\nax.set_title(\"Feature importance\")\nax.set_xlabel(\"Feature\")\nax.set_ylabel(\"Importance\")\nplt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\", rotation_mode=\"anchor\")\nplt.show();","3cf2b6b2":"submission = pd.read_csv(\"\/kaggle\/input\/commonlitreadabilityprize\/sample_submission.csv\", low_memory=False)\nsubmission[\"target\"] = preds\nsubmission.to_csv('submission.csv', index=False)\nsubmission","2f6881b5":"# **Data preparation**","ebbbdb72":"# **RoBERTa fine-tuning**","f129d4f2":"# **Optuna**","96043265":"To make further analysis we need to exctract more data from text exceprts. So the function below calculates some numeric parameters I think may be important for target predicting like text length decrease after deleting stop words, mean sentence length, amount of quotes (i.e. dialogs), word and lemma mean length etc. The function returns only these parameters. The transformed and preprocessed text object is not returned.","77da8366":"# **Submission**","2c966adc":"# **LGBMRegressor model training**","615ad2e4":"Let's check feature importances of all features and then engineered feature only.","a84a952a":"The code below runs hyperparameters optimization. It is commeted to save runtime.","efee8500":"# **Data analysis**","93895731":"This notebook demonstrates usage examples the following modules\/packages:\n* Matplotlib and seaborn for plots\n* Some NLTK module functions for text cleaning, splitting and lemmatisation\n* Out-of-the-box (not fine-tuned) RoBERTa model for text vectorization\n* LGBMRegressor model training on data folds\n* Optuna for LGBMRegressor hyperparameters optimization","0453c721":"Let's take a look at these parameters."}}