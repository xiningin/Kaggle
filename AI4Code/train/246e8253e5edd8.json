{"cell_type":{"2564172d":"code","4e2f5743":"code","bbea4feb":"code","09015334":"code","0c6f0604":"code","a69604f2":"code","4b161d8d":"code","6fead56c":"code","505ce8e1":"code","fff0541d":"code","cafbcce1":"code","cfae72a4":"code","54873a94":"code","3d2c0f35":"code","5752b88c":"code","2adf442e":"code","871dbffc":"code","669dfffb":"code","9f882afe":"code","1a0d2017":"code","b94e9d62":"code","f04164e3":"code","ecb295e2":"code","5ecd9d18":"code","33d02e4c":"code","348e3838":"code","8cb096fd":"code","470d50fb":"code","498d3daf":"code","28144413":"code","ec4680e8":"code","3f28888b":"code","144693ba":"code","bd38563c":"code","a87257d9":"code","40fec90c":"code","df0f2180":"code","56996589":"code","c0169d52":"code","a69b9f27":"code","25e90d97":"code","c0ea1c24":"code","bda1ce76":"code","3300e02e":"code","8537ce77":"code","22bb401c":"code","4b8cc8f9":"code","40cedcb1":"code","59d91adb":"code","326015cc":"code","549b8134":"code","591c3fdd":"code","b915db7b":"code","b74e6768":"code","1d332af9":"markdown","a943b353":"markdown","c694a0af":"markdown","b81ed011":"markdown","c442e3e8":"markdown","0ecc8046":"markdown","cf16c87e":"markdown","3be3d47a":"markdown","16427bed":"markdown","13d54ea2":"markdown","7ca18cc0":"markdown","a85f66aa":"markdown","3c3d805f":"markdown","49787f40":"markdown","f7dc0300":"markdown","d28f2e93":"markdown","c5cacab8":"markdown","efb0ead5":"markdown","f3057bbe":"markdown","b5bae89a":"markdown","6eeabd16":"markdown","42830133":"markdown","e224f66a":"markdown"},"source":{"2564172d":"import warnings\nwarnings.filterwarnings('ignore')\n\nimport numpy as np\nimport pandas as pd \n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.model_selection import KFold, cross_val_score, GridSearchCV, train_test_split\n\nfrom sklearn.preprocessing import LabelEncoder, RobustScaler\n\nfrom sklearn.linear_model import Lasso, Ridge\nfrom xgboost import XGBRegressor\nfrom lightgbm import LGBMRegressor\nfrom catboost import CatBoostRegressor\n\n\nfrom sklearn.preprocessing import RobustScaler\nfrom sklearn.model_selection import KFold, cross_val_score","4e2f5743":"# read data\nred = pd.read_csv('..\/input\/wine-rating-and-price\/Red.csv')\nwhite = pd.read_csv('..\/input\/wine-rating-and-price\/White.csv')\nsparkling = pd.read_csv('..\/input\/wine-rating-and-price\/Sparkling.csv')\nrose = pd.read_csv('..\/input\/wine-rating-and-price\/Rose.csv')","bbea4feb":"red.head()","09015334":"red['WineStyle'] = 'red'\nwhite['WineStyle'] = 'white'\nsparkling['WineStyle'] = 'sparkling'\nrose['WineStyle'] = 'rose'\nwines =  pd.concat([red, white, sparkling, rose], ignore_index=True)","0c6f0604":"wines.info()","a69604f2":"# N.V. wines is a nonvintage wine, which is usually a blend from the produce of two or more years\n# we can choose any free number to encode it\n\nwines['Year'] = wines['Year'].replace('N.V.', 2030) # it's important, that there were no 2030 year wines in list before\nwines['Year'] = wines['Year'].astype('int')","4b161d8d":"wines.sample(frac=1).head()","6fead56c":"wines.shape","505ce8e1":"wines.info()","fff0541d":"wines.describe()","cafbcce1":"wines.Country.nunique()","cfae72a4":"wines.Country.value_counts()","54873a94":"LEV_countries = wines.Country.value_counts()[:12] #Countries with the largest export volume","3d2c0f35":"plt.figure(figsize=(10,4))\n\ncountry = wines.Country.value_counts()[:12]\n\ngraph = sns.countplot(x='Country', \n                  data=wines[wines.Country.isin(LEV_countries.index.values)],\n                 color='olive')\ngraph.set_title(\"Countries with the largest export volume\", fontsize=20)\ngraph.set_xlabel(\"Country\", fontsize=15)\ngraph.set_ylabel(\"Volume\", fontsize=15)\ngraph.set_xticklabels(graph.get_xticklabels(),rotation=45)\n\nplt.show()\n","5752b88c":"plt.figure(figsize=(10, 4))\ngraph = sns.countplot(x='Rating', data=wines, color='mediumpurple')\ngraph.set_title(\"Rating Count distribuition \", fontsize=20)\ngraph.set_xlabel(\"Rating\", fontsize=15) \ngraph.set_ylabel(\"Count\", fontsize=15)\nplt.show()","2adf442e":"plt.figure(figsize=(16,6))\n\ngraph = sns.boxplot(x='Country', y='Rating',\n                 data=wines[wines.Country.isin(LEV_countries.index.values)],\n                 color='mediumpurple')\ngraph.set_title(\"Rating by Country\", fontsize=20)\ngraph.set_xlabel(\"Country\", fontsize=15)\ngraph.set_ylabel(\"Rating\", fontsize=15)\ngraph.set_xticklabels(graph.get_xticklabels())\n\nplt.show()","871dbffc":"MP_regions = wines['Region'].value_counts()[:100].index #most productive regions\nprint(wines[wines['Region'].isin(MP_regions)].groupby('Region').Rating.mean().sort_values(ascending=False)[:20])\n#Regions with the best rating from most productive onece","669dfffb":"MP_wineries = wines['Winery'].value_counts()[:100].index #most productive wineries\nprint(wines[wines['Winery'].isin(MP_wineries)].groupby('Winery').Rating.mean().sort_values(ascending=False)[:20])\n#wineries with the best rating from most productive onece","9f882afe":"plt.figure(figsize=(10,10))\nplt.subplot(2,1,1)\ngraph = sns.distplot(wines['Price'], color='coral')\ngraph.set_title(\"Price distribuition\", fontsize=20) # seting title and size of font\ngraph.set_xlabel(\"Price (EUR)\", fontsize=15) # seting xlabel and size of font\ngraph.set_ylabel(\"Frequency\", fontsize=15) # seting ylabel and size of font\n\nplt.subplot(2,1,2)\ngraph1 = sns.distplot(np.log(wines['Price']) , color='coral')\ngraph1.set_title(\"Price Log distribuition\", fontsize=20) # seting title and size of font\ngraph1.set_xlabel(\"Price(EUR)\", fontsize=15) # seting xlabel and size of font\ngraph1.set_ylabel(\"Frequency\", fontsize=15) # seting ylabel and size of font\ngraph1.set_xticklabels(np.exp(graph1.get_xticks()).astype(int))\n\nplt.subplots_adjust(hspace = 0.3,top = 0.9)\nplt.show()","1a0d2017":"plt.figure(figsize=(16,18))\n\nplt.subplot(3,1,1)\ngraph = sns.boxplot(x='Year', y=np.log(wines['Price']),\n                    data=wines,\n                    color='coral')\ngraph.set_title(\"Price by Year\", fontsize=20)\ngraph.set_xlabel(\"Year\", fontsize=15)\ngraph.set_ylabel(\"Price(EUR)\", fontsize=15)\ngraph.set_xticklabels(graph.get_xticklabels(),rotation=45)\ngraph.set_yticklabels(np.exp(graph.get_yticks()).astype(int))\n\nplt.subplot(3,1,2)\ngraph1 = sns.boxplot(x='WineStyle', y=np.log(wines['Price']),\n                 data=wines,\n                 color='coral')\ngraph1.set_title(\"Price by WineStyle\", fontsize=20)\ngraph1.set_xlabel(\"WineStyle\", fontsize=15)\ngraph1.set_ylabel(\"Price(EUR)\", fontsize=15)\ngraph1.set_xticklabels(graph1.get_xticklabels())\ngraph1.set_yticklabels(np.exp(graph1.get_yticks()).astype(int))\n\nplt.subplot(3,1,3)\ngraph2 = sns.boxplot(x='Country', y=np.log(wines['Price']),\n                 data=wines[wines.Country.isin(LEV_countries.index.values)],\n                 color='coral')\ngraph2.set_title(\"Price by Country\", fontsize=20)\ngraph2.set_xlabel(\"Country\", fontsize=15)\ngraph2.set_ylabel(\"Price(EUR)\", fontsize=15)\ngraph2.set_yticklabels(np.exp(graph2.get_yticks()).astype(int))\n\nplt.subplots_adjust(hspace = 0.3, top = 0.9)\n\nplt.show()","b94e9d62":"plt.figure(figsize=(16,6))\ngraph = sns.boxplot(x='Country', y=wines['Rating']\/wines['Price'],\n                 data=wines[wines.Country.isin(LEV_countries.index.values)],\n                 color='olive')\ngraph.set_title(\"Rating\/Price by Countries\", fontsize=20)\ngraph.set_xlabel(\"Country\", fontsize=15)\ngraph.set_ylabel(\"Rating\/Price\", fontsize=15)\ngraph.set_xticklabels(graph.get_xticklabels())\n\nplt.show()","f04164e3":"plt.figure(figsize=(13,5))\n\ngraph = sns.regplot(x=np.log(wines['Price']), y='Rating', \n                    data=wines, fit_reg=False, color='olive')\ngraph.set_title(\"Rating x Price Distribuition\", fontsize=20)\ngraph.set_xlabel(\"Price(EUR)\", fontsize= 15)\ngraph.set_ylabel(\"Rating\", fontsize= 15)\ngraph.set_xticklabels(np.exp(graph.get_xticks()).astype(int))\n\nplt.show()","ecb295e2":"corrs = wines[['Rating','NumberOfRatings','Price','Year']].corr() #Heatmap for numetrical columns\nfig, ax = plt.subplots(figsize=(7,5))        \n\nsns.heatmap(corrs,annot = True,ax=ax,linewidths=.6, cmap = 'YlGnBu');","5ecd9d18":"plt.figure(figsize=(10,15))\n\nplt.subplot(3,1,1)\ngraph = sns.distplot(wines['NumberOfRatings'], color='olive')\ngraph.set_title(\"Number Of Ratings distribuition\", fontsize=20) \ngraph.set_xlabel(\"Number Of Ratings\", fontsize=15)\ngraph.set_ylabel(\"Frequency\", fontsize=15) \n\nplt.subplot(3,1,2)\ngraph1 = sns.distplot(np.log(wines['NumberOfRatings']), color='olive')\ngraph1.set_title(\"Number Of Ratings Log distribuition\", fontsize=20) \ngraph1.set_xlabel(\"Number Of Ratings\", fontsize=15) \ngraph1.set_ylabel(\"Frequency\", fontsize=15)\ngraph1.set_xticklabels(np.exp(graph1.get_xticks()).astype(int))\n\nplt.subplot(3,1,3)\ngraph = sns.distplot(wines[wines['NumberOfRatings']<1000]['NumberOfRatings'], color='olive')\ngraph.set_title(\"Number Of Ratings <1000 distribuition\", fontsize=20)\ngraph.set_xlabel(\"Number Of Ratings\", fontsize=15) \ngraph.set_ylabel(\"Frequency\", fontsize=15) \n\nplt.subplots_adjust(hspace = 0.3,top = 0.9)\nplt.show()","33d02e4c":"varieties = pd.read_csv('..\/input\/wine-rating-and-price\/Varieties.csv')","348e3838":"wines['Variety'] = np.nan\nfor index in wines.index:\n    for variety in varieties['Variety']:    \n        if variety in wines.loc[index, 'Name']:\n            wines.loc[index, 'Variety'] = variety\n            break","8cb096fd":"print('Now we have variety for', wines.Variety.notna().sum(),'wines,',\n      '%s%%' % int(wines.Variety.notna().sum()\/len(wines)*100), 'of all')","470d50fb":"# replace NaN's\nwines.Variety = wines.Variety.fillna('unknown')","498d3daf":"wines.Variety.value_counts().head(20)","28144413":"wines_enc = wines.copy().drop(columns = ['Name'])","ec4680e8":"#One-hot encoder for winestyle\nwines_enc = pd.get_dummies(wines_enc, columns = ['WineStyle'])","3f28888b":"wines_enc.head()","144693ba":"categorical_cols = [col for col in wines_enc.columns if wines_enc[col].dtype == \"object\"]","bd38563c":"# Apply label encoder\nlabel_encoder = LabelEncoder()\nfor col in categorical_cols:\n    wines_enc[col] = label_encoder.fit_transform(wines_enc[col])","a87257d9":"wines_enc.head()","40fec90c":"y = wines_enc['Rating']\nX = wines_enc.drop(['Rating'], axis = 1)","df0f2180":"kfolds = KFold(n_splits=6, shuffle=True,\n               random_state=0)","56996589":"def cv_mae(model, X=X, y=y):\n    mae = -cross_val_score(model, X, y,\n                          scoring=\"neg_mean_absolute_error\",\n                          cv=kfolds)\n    return mae","c0169d52":"lightgbm = LGBMRegressor(objective='regression',\n                         metric='mean_absolute_error',\n                         num_leaves=10,\n                         learning_rate=0.05,\n                         n_estimators=3000,\n                         max_depth=5,\n                         max_bin=400,\n                         bagging_fraction=0.75,                         \n                         bagging_freq=5,\n                         bagging_seed=7,\n                         reg_alpha=0.7,\n                         reg_lambda=1.2,\n                         feature_fraction=0.6,\n                         feature_fraction_seed=7,\n                         verbose=-1,\n                         min_data_in_leaf=3,\n                         min_sum_hessian_in_leaf=11\n                         )\nxgboost = XGBRegressor(n_estimators=3000,\n                       learning_rate=0.02,\n                       max_depth=5, \n                       min_child_weight=2,\n                       subsample=0.8,\n                       colsample_bytree=0.7,\n                       nthread=-1,\n                       gamma=0,\n                       reg_alpha=0.1,\n                       reg_lambda=1.8\n                       )\ncatboost = CatBoostRegressor(iterations=3000,\n                             learning_rate=0.03,\n                             depth=6,\n                             l2_leaf_reg = 2,\n                             verbose=0\n                            )","a69b9f27":"maes_lgbm = cv_mae(lightgbm)","25e90d97":"print('Average lightgbm mae:', np.average(maes_lgbm), ' Standard deviation: ', np.std(maes_lgbm))","c0ea1c24":"maes_xgb = cv_mae(xgboost)","bda1ce76":"print('Average xgboost mae:', np.average(maes_xgb), ' Standard deviation: ', np.std(maes_xgb))","3300e02e":"maes_catboost = cv_mae(catboost)","8537ce77":"print('Average catboost mae:', np.average(maes_catboost), ' Standard deviation: ', np.std(maes_catboost))","22bb401c":"lasso=Lasso()\nparameters={'alpha':[1e-15,1e-10,1e-8,1e-3,1e-2,1,5,10,20,30,35,40,45,50,55,100,150,200,250,300]}\nlasso_regressor = GridSearchCV(lasso,parameters,scoring='neg_mean_absolute_error',cv=kfolds)\nlasso_regressor.fit(X,y)\nprint('Best lasso mae:', -lasso_regressor.best_score_,'with',lasso_regressor.best_params_)","4b8cc8f9":"ridge=Ridge()\nparameters={'alpha':[1e-15,1e-10,1e-8,1e-3,1e-2,1,5,10,20,30,35,40,45,50,55,100,150,200,250,300]}\nridge_regressor=GridSearchCV(ridge,parameters,scoring='neg_mean_absolute_error',cv=kfolds)\nridge_regressor.fit(X,y)\nprint('Best ridge mae:', -ridge_regressor.best_score_,'with',ridge_regressor.best_params_)","40cedcb1":"wines_enc['NumberOfRatings'].sort_values()[int(0.1*(len(wines_enc))):int(0.9*(len(wines_enc)))]","59d91adb":"wines_low_NumberOfRatings = wines_enc[wines_enc['NumberOfRatings']<35]\nwines_high_NumberOfRatings = wines_enc[wines_enc['NumberOfRatings']>838]\nwines_mid_NumberOfRatings = wines_enc[wines_enc['NumberOfRatings']>35][wines_enc['NumberOfRatings']<838]","326015cc":"X_low_NumberOfRatings_test = wines_low_NumberOfRatings.drop(['NumberOfRatings','Rating'], axis = 1)\ny_low_NumberOfRatings_test = wines_low_NumberOfRatings['Rating']\n\nX_high_NumberOfRatings_test = wines_high_NumberOfRatings.drop(['NumberOfRatings','Rating'], axis = 1)\ny_high_NumberOfRatings_test = wines_high_NumberOfRatings['Rating']\n\nX_mid = wines_mid_NumberOfRatings.drop(['NumberOfRatings','Rating'], axis = 1)\ny_mid = wines_mid_NumberOfRatings['Rating']\nX_train, X_random_test, y_train, y_random_test = train_test_split(X_mid, y_mid, test_size=len(X_low_NumberOfRatings_test))","549b8134":"print('Train data size:', len(X_train))\nprint('Test data sizes:', len(X_low_NumberOfRatings_test), len(X_high_NumberOfRatings_test), len(X_random_test))","591c3fdd":"lgbm = lightgbm.fit(X_train, y_train)","b915db7b":"res_low_NumberOfRatings = lgbm.predict(X_low_NumberOfRatings_test)\nres_high_NumberOfRatings = lgbm.predict(X_high_NumberOfRatings_test)\nres_random_NumberOfRatings = lgbm.predict(X_random_test)","b74e6768":"print('MAE of predictions with low NumberOfRatings:   ', mean_absolute_error(y_low_NumberOfRatings_test, res_low_NumberOfRatings))\nprint('MAE of predictions with high NumberOfRatings:  ', mean_absolute_error(y_high_NumberOfRatings_test, res_high_NumberOfRatings))\nprint('MAE of predictions with middle NumberOfRatings:', mean_absolute_error(y_random_test, res_random_NumberOfRatings))","1d332af9":"Now let's check our model predictions on wines with low, high and random Number of Ratings.","a943b353":"### Feature Generation","c694a0af":"# 3) Feature Engineering","b81ed011":"Data is quite clear, I only want to convert year feature from object to integer for plotting and modeling","c442e3e8":"# 2) EDA","0ecc8046":"# 1) Data preparation","cf16c87e":"Let's find regions and wineries which produce quite a lot of bottles and have the highest average rating<br>\nIf you find wine from there in the store it's probably worth a try","3be3d47a":"First glance, there is no information about variety in dataset.<br>\nUsually, wine's names also contains variety<br>\nI have scraped about 1500 wine varieties from wine-searcher.com and wiki.<br>\nWill look for entries of variety from lists in Name column.<br>","16427bed":"Often we would like to know main info not about all countries(there are wines from 33 countries, as we can see)<br>\nFor example, we can analyze countries with the largest export volume","13d54ea2":"Gradient boosting shows significantly higher result than regresson models. Further, I will use lightgbm, because results are very close, but lightgbm is faster than xgboost and catboost. ","7ca18cc0":"Firstly, will look for general info","a85f66aa":"### Rating","3c3d805f":"### Price","49787f40":"As we expected, rating of wines with low Number of Ratings is less representative, and accuracy of model is lower","f7dc0300":"### Standart imports","d28f2e93":"At modeling step, i would like to work with data as single data frame.<br>\nLet's join our data and make feature for wine styles.","c5cacab8":"### If you have any questions or recommendations, please let me know. <br>\n## Now I'm looking for a DS job, so if you liked this kernel, please votes up!","efb0ead5":"### Encode categorical features","f3057bbe":"From the last graphics we can see, that Number of Ratings has the exponential distribution and there a lot of wines,<br> which has low Number of Ratings(at Vivino and in this dataset you can see rating of wines which has more than 25 ratings).<br>\nThere is a real problem for business, because the main reason of Vivino app is to give info about quality of wine to customers,<br> but for huge number of wines there are no rating at all. <br>\nMy idea is to apply ML methods to predict rating of wines wich has less than 25 ratings.","b5bae89a":"Many people think, that good wine must be expensive. Of course, there is a tendency of average rating increasing when the price increases, but there are a lot of wines with 4+ rating just for 7 euros and 4.4+ rating for 20 euro. So, you can find a good wine for any wallet.","6eeabd16":"We has accuracy = 0.13 with boosting models, and of course it can be improved by bigger dataset size and more features which has Vivino company.","42830133":"# 4) Modeling","e224f66a":"### Other plots"}}