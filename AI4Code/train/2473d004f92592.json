{"cell_type":{"a0a13abb":"code","03bb220d":"code","a509121d":"code","7482ac36":"code","d27ae068":"code","d1f910d3":"code","e05d0281":"code","38ba368c":"code","85bea8bc":"code","80f2fdb9":"code","c023f935":"code","b9970848":"code","8a6a5fc6":"markdown","e389a993":"markdown","cfb7c343":"markdown","f1c83923":"markdown","9d205402":"markdown","7253b47b":"markdown","b4b256d2":"markdown","6d2b6704":"markdown","7bb4484a":"markdown"},"source":{"a0a13abb":"import numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.metrics import classification_report,confusion_matrix\nfrom sklearn.naive_bayes import MultinomialNB","03bb220d":"df = pd.read_csv('..\/input\/spamraw.csv')\ndf.head()","a509121d":"#Find count and unique messages count of all the messages\ndf.describe()","7482ac36":"#Extract SPAM messages\nspam_messages = df[df[\"type\"]==\"spam\"]\nspam_messages.head() #Display first 5 rows of SPAM messages","d27ae068":"#Find count and unique messages count of SPAM messages.\nspam_messages.describe()","d1f910d3":"#Plot the counts of HAM (non SPAM) vs SPAM\nsns.countplot(data = df, x= df[\"type\"]).set_title(\"Amount of spam and no-spam messages\")\nplt.show()","e05d0281":"data_train, data_test, labels_train, labels_test = train_test_split(df.text,df.type,test_size=0.2,random_state=0) \nprint(\"data_train, labels_train : \",data_train.shape, labels_train.shape)\nprint(\"data_test, labels_test: \",data_test.shape, labels_test.shape)","38ba368c":"vectorizer = CountVectorizer()\n#fit & transform\n# fit: build dict (i.e. word->wordID)  \n# transform: convert document (i.e. each line in the file) to word vector \ndata_train_count = vectorizer.fit_transform(data_train)\ndata_test_count  = vectorizer.transform(data_test)","85bea8bc":"clf = MultinomialNB()\nclf.fit(data_train_count, labels_train)\npredictions = clf.predict(data_test_count)\npredictions","80f2fdb9":"print (\"accuracy_score : \", accuracy_score(labels_test, predictions))","c023f935":"print (\"confusion_matrix : \\n\", confusion_matrix(labels_test, predictions))","b9970848":"print (classification_report(labels_test, predictions))","8a6a5fc6":"**Exploratory Data Analysis (EDA)**","e389a993":"**Confusion Matrix**\n\n\n*A confusion matrix is a table that is often used to describe the performance of a classification model (or \u201cclassifier\u201d) on a set of test data for which the true values are known. It allows the visualization of the performance of an algorithm.*","cfb7c343":"**Import Python libraries**","f1c83923":"**Extraction & CountVectorize**\n\n\n*The CountVectorizer provides a simple way to both tokenize a collection of text documents and build a vocabulary of known words, but also to encode new documents using that vocabulary.*","9d205402":"Multinomial Naive Bayes is a specialized version of Naive Bayes that is designed more for text documents. Whereas simple naive Bayes would model a document as the presence and absence of particular words, multinomial naive bayes explicitly models the word counts and adjusts the underlying calculations to deal with in.\n\nIt is a classification technique based on Bayes' Theorem with an assumption of independence among predictors. In simple terms, a Naive Bayes classifier assumes that the presence of a particular feature in a class is unrelated to the presence of any other feature.","7253b47b":"**Import SMS Data**","b4b256d2":"**Splitting the SMS data into Test and Train data**","6d2b6704":"**Results and Accuracy**","7bb4484a":"**Modelling & training**"}}