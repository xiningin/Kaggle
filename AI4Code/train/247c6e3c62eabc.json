{"cell_type":{"9ad34856":"code","3e080443":"code","8f34a643":"code","de98e316":"markdown","62869cbb":"markdown"},"source":{"9ad34856":"%%writefile submission.py\n\nfrom kaggle_environments.envs.hungry_geese.hungry_geese import Observation, Configuration, Action, row_col\nimport numpy as np\nimport random\n\ndef get_nearest_cells(x,y):\n    # returns all cells reachable from the current one\n    result = []\n    for i in (-1,+1):\n        result.append(((x+i+7)%7, y))\n        result.append((x, (y+i+11)%11))\n    return result\n\ndef find_closest_food(table):\n    # returns the first step toward the closest food item\n    new_table = table.copy()\n    \n    \n    # (direction of the step, axis, code)\n    possible_moves = [\n        (1, 0, 1),\n        (-1, 0, 2),\n        (1, 1, 3),\n        (-1, 1, 4)\n    ]\n    \n    # shuffle possible options to add variability\n    random.shuffle(possible_moves)\n    \n    \n    updated = False\n    for roll, axis, code in possible_moves:\n\n        shifted_table = np.roll(table, roll, axis)\n        \n        if (table == -2).any() and (shifted_table[table == -2] == -3).any(): # we have found some food at the first step\n            return code\n        else:\n            mask = np.logical_and(new_table == 0,shifted_table == -3)\n            if mask.sum() > 0:\n                updated = True\n            new_table += code * mask\n        if (table == -2).any() and shifted_table[table == -2][0] > 0: # we have found some food\n            return shifted_table[table == -2][0]\n        \n        # else - update new reachible cells\n        mask = np.logical_and(new_table == 0,shifted_table > 0)\n        if mask.sum() > 0:\n            updated = True\n        new_table += shifted_table * mask\n\n    # if we updated anything - continue reccurison\n    if updated:\n        return find_closest_food(new_table)\n    # if not - return some step\n    else:\n        return table.max()\n\nlast_step = None\n\ndef agent(obs_dict, config_dict):\n    global last_step\n    \n    observation = Observation(obs_dict)\n    configuration = Configuration(config_dict)\n    player_index = observation.index\n    player_goose = observation.geese[player_index]\n    player_head = player_goose[0]\n    player_row, player_column = row_col(player_head, configuration.columns)\n\n\n    table = np.zeros((7,11))\n    # 0 - emply cells\n    # -1 - obstacles\n    # -4 - possible obstacles\n    # -2 - food\n    # -3 - head\n    # 1,2,3,4 - reachable on the current step cell, number is the id of the first step direction\n    \n    legend = {\n        1: 'SOUTH',\n        2: 'NORTH',\n        3: 'EAST',\n        4: 'WEST'\n    }\n    \n    # let's add food to the map\n    for food in observation.food:\n        x,y = row_col(food, configuration.columns)\n        table[x,y] = -2 # food\n        \n    # let's add all cells that are forbidden\n    for i in range(4):\n        opp_goose = observation.geese[i]\n        if len(opp_goose) == 0:\n            continue\n            \n        is_close_to_food = False\n            \n        if i != player_index:\n            x,y = row_col(opp_goose[0], configuration.columns)\n            possible_moves = get_nearest_cells(x,y) # head can move anywhere\n            \n            for x,y in possible_moves:\n                if table[x,y] == -2:\n                    is_close_to_food = True\n            \n                table[x,y] = -4 # possibly forbidden cells\n        \n        # usually we ignore the last tail cell but there are exceptions\n        tail_change = -1\n        if obs_dict['step'] % 40 == 39:\n            tail_change -= 1\n        \n        # we assume that the goose will eat the food\n        if is_close_to_food:\n            tail_change += 1\n        if tail_change >= 0:\n            tail_change = None\n            \n\n        for n in opp_goose[:tail_change]:\n            x,y = row_col(n, configuration.columns)\n            table[x,y] = -1 # forbidden cells\n    \n    # going back is forbidden according to the new rules\n    x,y = row_col(player_head, configuration.columns)\n    if last_step is not None:\n        if last_step == 1:\n            table[(x + 6) % 7,y] = -1\n        elif last_step == 2:\n            table[(x + 8) % 7,y] = -1\n        elif last_step == 3:\n            table[x,(y + 10)%11] = -1\n        elif last_step == 4:\n            table[x,(y + 12)%11] = -1\n        \n    # add head position\n    table[x,y] = -3\n    \n    # the first step toward the nearest food\n    step = int(find_closest_food(table))\n    \n    # if there is not available steps try to go to possibly dangerous cell\n    if step not in [1,2,3,4]:\n        x,y = row_col(player_head, configuration.columns)\n        if table[(x + 8) % 7,y] == -4:\n            step = 1\n        elif table[(x + 6) % 7,y] == -4:\n            step = 2\n        elif table[x,(y + 12)%11] == -4:\n            step = 3\n        elif table[x,(y + 10)%11] == -4:\n            step = 4\n                \n    # else - do a random step and lose\n        else:\n            step = np.random.randint(4) + 1\n    \n    last_step = step\n    return legend[step]","3e080443":"from kaggle_environments import evaluate, make\nenv = make(\"hungry_geese\")","8f34a643":"env.reset()\nenv.run(['submission.py', 'submission.py', 'submission.py', 'submission.py'])\nenv.render(mode=\"ipython\", width=800, height=700)","de98e316":"In another notebook, [Goose on a healthy diet](https:\/\/www.kaggle.com\/ilialar\/goose-on-a-healthy-diet), I use an opposite idea and avoid eating a lot of food to keep goose small and easy to control.","62869cbb":"This notebook proposes a simple greedy straightforward solution. At each step:\n- Mark all cells that can be dangerous on the next step as obstacles\n- Find the shortest route to the nearest food item\n- Make one step toward this food\n- Repeat"}}