{"cell_type":{"669b1163":"code","f55b2818":"code","bfdb196a":"code","055b79af":"code","645d16e0":"code","8ca06f1b":"code","17808b25":"code","175534e5":"code","6b409e38":"code","c1519041":"code","0bf92223":"code","73af95a1":"code","d5004d6d":"code","4c88a7af":"code","4783c7cf":"code","e2551aa0":"code","3052b3cb":"code","612c1e40":"code","a95695a8":"code","50178e15":"code","f7ddf1b8":"code","f4df9fa2":"code","bc4fd79e":"markdown"},"source":{"669b1163":"# %config IPCompleter.greedy=True\nimport pandas as pd\nimport seaborn as sns\nimport numpy as np\n\nimport matplotlib as matplot\nimport matplotlib.pyplot as plt\n# %matplotlib inline\n\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\n\nimport warnings, os \n# warnings.filterwarnings(\"ignore\")\n\n# from keras import Sequential\n# from keras.models import Model, load_model\n# from keras.layers import *\n# from keras.callbacks import ModelCheckpoint\n# from keras import regularizers\n\nfrom sklearn.metrics import *\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier, ExtraTreesClassifier, VotingClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder\n\nfrom sklearn.feature_selection import RFE\nfrom sklearn.decomposition import PCA, TruncatedSVD, PCA\nfrom sklearn.svm import LinearSVC\n\nimport xgboost, lightgbm\nfrom mlxtend.classifier import EnsembleVoteClassifier ","f55b2818":"ls = [] \nfor filename in os.listdir(r'.\/'):\n  if '.csv' in  filename:\n    print(filename)\n    df = pd.read_csv(filename)\n    ls.append(df)\n    print(f'Shape: {df.shape}. Attack Type {df[\" Label\"].unique()}')","bfdb196a":"for df in ls:\n  cols = df.columns.to_list()\n  for i in range(len(cols)):\n    cols[i] = cols[i].strip()\n  df.columns = cols","055b79af":"df = pd.concat(ls)\ndf.head(3)\nassert df.shape[1] == 79","645d16e0":"# mix of ints and floats. Label is a object (words)\n# with pd.option_context('display.max_rows', None, 'display.max_columns', None):  # more options can be specified also\n    # df.dtypes\n","8ca06f1b":"from collections import Counter\n\nCounter(df[\"Label\"])","17808b25":"print(f'df.shape {df.shape} before sampling out most of benign data')\ndf = pd.concat([df[df['Label'] != 'BENIGN'], df[df['Label'] == 'BENIGN'].sample(frac=.1, random_state=42)]) # 20% of total is Malicious; Use only a sample of the BENIGN data\nprint(f'df.shape {df.shape} after sampling out most of benign data')","175534e5":"le = LabelEncoder()\ndf['Label'] = le.fit_transform(df['Label'])\ndf.head(3)\nle.classes_","6b409e38":"lowSTD = list(df.std().to_frame().nsmallest(20, columns=0).index)\ndf[lowSTD].head(3)","c1519041":"lowCORR = list(df.corr().abs().sort_values('Label')['Label'].nsmallest(20).index) # .where(lambda x: x < 0.005).dropna()\ndf[lowCORR].head(3)","0bf92223":"print(f'Intersection: {set(lowSTD).intersection(set(lowCORR))}')\nprint(f'Union:        {len(set(lowSTD).union(set(lowCORR)))}')","73af95a1":"import gc \ngc.collect()","d5004d6d":"df.dropna(inplace=True)\nindices_to_keep = ~df.isin([np.nan, np.inf, -np.inf]).any(1)\ndf = df[indices_to_keep]\n\n\nfor i in df.columns:\n    df = df[df[i] != \"Infinity\"]\n    df = df[df[i] != np.nan]\n    df = df[df[i] != np.inf]\n    df = df[df[i] != -np.inf]\n    df = df[df[i] != \",,\"]\n    df = df[df[i] != \", ,\"]\n    \nprint(np.any(np.isnan(df)))\nprint(np.any(np.isfinite(df)))\n\nX_train, X_test, y_train, y_test = train_test_split(df.drop(['Label'],axis=1), df['Label'], test_size=.20, random_state=42)\nX_train.head(2)\ny_train.head(2)","4c88a7af":"def benchmark(X_train=X_train, X_test=X_test, y_train=y_train, y_test=y_test):\n  GBM = lightgbm.LGBMClassifier(objective='binary', n_estimators= 50)\n  clfs = [GBM]\n  for clf in clfs:\n      _ = clf.fit(X_train, y_train)\n      pred = clf.score(X_test, y_test)\n      name = str(type(clf)).split(\".\")[-1][:-2]\n      print(\"Acc: %0.5f for the %s\" % (pred, name))\n  return clfs","4783c7cf":"print('Baseline with all features')\nclfs = benchmark()","e2551aa0":"print('Solely with features identified as useless')\n\nGBM = clfs[0]\nremove = X_train.columns.to_numpy()[GBM.feature_importances_ == 0] \nclfs = benchmark(X_train[remove], X_test[remove])\nprint(remove)","3052b3cb":"print('Solely with features identified as useful')\nclfs = benchmark(X_train.drop(remove,1), X_test.drop(remove,1))","612c1e40":"X_train.reset_index(drop=True, inplace=True)\nX_test.reset_index(drop=True, inplace=True)\n\nprint('PCA 5')\npca = PCA(5)\n_ = benchmark(pca.fit_transform(X_train), pca.transform(X_test))","a95695a8":"print('PCA 15')\npca = PCA(15)\n_ = benchmark(pca.fit_transform(X_train), pca.transform(X_test))","50178e15":"print('PCA 25')\npca = PCA(25)\n_ = benchmark(pca.fit_transform(X_train), pca.transform(X_test))","f7ddf1b8":"tmp = np.argsort(GBM.feature_importances_)\ntmp = tmp[::-1] # large to small \ntop = tmp[:20] # index of the top N\nrest = tmp[20:]\nprint(GBM.feature_importances_[top]) # check ","f4df9fa2":"print('Top 20 features (per `LGBMClassifier`) + PCA(15) of remaining') # 2nd highest \npca = PCA(15)\n\na = pd.concat([X_train.iloc[:, top], pd.DataFrame(pca.fit_transform(X_train.iloc[:, rest]))], axis=1, ignore_index=True) \nb = pd.concat([X_test.iloc[:, top] , pd.DataFrame(pca.transform    (X_test.iloc[:, rest])) ], axis=1, ignore_index=True) \n\n_ = benchmark(a, b)","bc4fd79e":"# Intrusion Detection Evaluation Dataset (CIC-IDS2017)\nBy AliK604 \n\nIntrusion Detection Systems (IDSs) and Intrusion Prevention Systems (IPSs) are the most important defense tools against the sophisticated and ever-growing network attacks. Due to the lack of reliable test and validation datasets, anomaly-based intrusion detection approaches are suffering from consistent and accurate performance evolutions."}}