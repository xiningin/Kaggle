{"cell_type":{"1e4bc6f4":"code","4477d58d":"code","303e7797":"code","a3f9d57f":"code","dc92687b":"code","b69de68b":"code","ea03ea1e":"code","a436924b":"code","8c961b60":"code","8bcdcf4d":"code","04d66e2e":"code","ec566290":"code","ea362c80":"code","ca953fe2":"code","76f874c1":"code","facec12d":"code","07db1774":"markdown","b383c8f8":"markdown","8771b67b":"markdown","b957dbda":"markdown","49d0800c":"markdown"},"source":{"1e4bc6f4":"\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","4477d58d":"import pandas as pd\nimport numpy as np \nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndfTrain = pd.read_csv(\"..\/input\/CylinderVolumeData.csv\")\ndfTrain.head()","303e7797":"dfTrain.plot(x='radius',y='volume',kind='scatter')\nplt.show()","a3f9d57f":"dfTrain.plot(x='height',y='volume',kind='scatter')\nplt.show()","dc92687b":"#%matplotlib notebook\nplt3D = plt.figure().gca(projection='3d')\nplt3D.scatter(dfTrain['radius'], dfTrain['height'], dfTrain['volume'])\nplt3D.set_xlabel('radius')\nplt3D.set_ylabel('height')\nplt3D.set_zlabel('volume')\nplt.show()","b69de68b":"#MapFeature - This function is used to provide 2 level degree to the independent variables\ndef mapFeature(X,degree):\n    \n    sz=X.shape[1]\n    if (sz==2):\n        sz=(degree+1)*(degree+2)\/2\n        sz=int(sz)\n    else:\n         sz=degree+1\n    out=np.ones((X.shape[0],sz))     #Adding Bias W0\n\n    sz=X.shape[1]\n    if (sz==2):\n        X1=X[:, 0:1]\n        X2=X[:, 1:2]\n        col=1\n        for i in range(1,degree+1):        \n            for j in range(0,i+1):\n                out[:,col:col+1]= np.multiply(np.power(X1,i-j),np.power(X2,j))    \n                col+=1\n        return out\n    else:\n        for i in range(1,degree+1):        \n            out[:,i:i+1]= np.power(X,i)\n    \n    return out","ea03ea1e":"import sklearn.linear_model  as LR\n\ndf_Features=dfTrain.iloc[:,0:2]\ndf_Label=dfTrain.iloc[:,2:3]\n\nX = df_Features.values\nY = df_Label.values.ravel()","a436924b":"#Standard Scaling - Data Preprocessing\n\n#Data Preprocessing\nfrom sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit(X)\nXS = scaler.transform(X)\ninputX = mapFeature(XS,3) ","8c961b60":"RegObj = LR.SGDRegressor(learning_rate='adaptive',eta0=0.1,alpha=0,max_iter=1000).fit(inputX,Y)\npred = RegObj.predict(mapFeature(scaler.transform([[189,177]]),3) )\nprint(pred)","8bcdcf4d":"#You can obtain the coefficient of determination (\ud835\udc45\u00b2) with .score() called on model:\n#When you\u2019re applying .score(), the arguments are also the predictor x and regressor y, and the return value is \ud835\udc45\u00b2.\nprint('coefficient of determination:', RegObj.score(inputX,Y))\n#The attributes of model are .intercept_, which represents the coefficient, \ud835\udc4f\u2080 and .coef_, which represents \ud835\udc4f\u2081:\nprint('intercept:', RegObj.intercept_)\nprint('slope:', RegObj.coef_)","04d66e2e":"x_min, x_max = X[:, 0].min() , X[:, 0].max() \ny_min, y_max = X[:, 1].min() , X[:, 1].max() \nu = np.linspace(x_min, x_max,10) \nv = np.linspace(y_min, y_max, 10) \nz = np.zeros(( len(u), len(v) )) \nU,V=np.meshgrid(u,v)\nfor i in range(len(u)): \n    for j in range(len(v)): \n        uv= np.column_stack((np.array([[u[i]]]),np.array([[v[j]]])))\n        pred = RegObj.predict(mapFeature(scaler.transform(uv),3) )\n     \n        z[i,j] =pred[0]\nz = np.transpose(z) ","ec566290":"#%matplotlib notebook\nplt3D = plt.figure().gca(projection='3d')\nplt3D.scatter(dfTrain['radius'], dfTrain['height'], dfTrain['volume'])\nplt3D.scatter(U,V,z)\nplt3D.set_xlabel('radius')\nplt3D.set_ylabel('height')\nplt3D.set_zlabel('volume')\nplt.show()","ea362c80":"#Contour Graph \nplt3D = plt.figure().gca(projection='3d')\nplt3D.scatter(dfTrain['radius'], dfTrain['height'], dfTrain['volume'],alpha=0.01,color='r')\nplt3D.contourf(U,V,z,color='b',alpha=0.6)\nplt3D.set_xlabel('radius')\nplt3D.set_ylabel('height')\nplt3D.set_zlabel('volume')\nplt.show()","ca953fe2":"import pickle\nwith open('SGDLearning.pkl', 'wb') as f:\n  pickle.dump(RegObj,f,pickle.HIGHEST_PROTOCOL)","76f874c1":"with open('SGDLearning.pkl', 'rb') as f:\n  RegObj = pickle.load(f)","facec12d":"PredictionFromFile = RegObj.predict(mapFeature(scaler.transform([[189,177]]),3) )\nprint(PredictionFromFile)","07db1774":"#Pickel","b383c8f8":"### Prediction - Volume of Cylinder- V=\u03c0r2h\n### SGD Regressor - Stochastic gradient descent\n\nIntroduction\n\nSGD stands for Stochastic Gradient Descent: the gradient of the loss is estimated each sample at a time and the model is updated along the way with a decreasing strength schedule (aka learning rate).","8771b67b":"**PLOTTING**","b957dbda":"#### Using SGD Regressor predict volume for following values\n     radius=189\n     height=177\n     \n     Volume should be approx 19863087.12","49d0800c":"You can obtain the coefficient of determination (\ud835\udc45\u00b2) with .score() called on model:\nWhen you\u2019re applying .score(), the arguments are also the predictor x and regressor y, and the return value is \ud835\udc45\u00b2.**"}}