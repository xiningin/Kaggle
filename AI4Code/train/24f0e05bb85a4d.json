{"cell_type":{"91714b60":"code","f520ec76":"code","3a46a10a":"code","0ddc1372":"code","780c3c3b":"code","33f7f9d1":"code","41f3b77e":"code","15ad2688":"code","9679af31":"code","2750cf16":"code","1830a2dd":"code","5d05750a":"code","7d470d4e":"code","d2d82af7":"code","1065a276":"markdown","d8a3db1c":"markdown","4ffde2a9":"markdown","0e5bbab3":"markdown","9135e828":"markdown","9c8293b5":"markdown","da0e6276":"markdown","b94f5322":"markdown","59fb5f09":"markdown","e8ddfa29":"markdown","4e8a59d6":"markdown","d516b3c3":"markdown","f9ab4915":"markdown"},"source":{"91714b60":"import tensorflow as tf\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport random","f520ec76":"# load the dataset\n(train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.fashion_mnist.load_data()","3a46a10a":"train_images = np.array((train_images \/ 255.0), dtype=\"float32\")\ntest_images = np.array((test_images \/ 255.0), dtype=\"float32\")","0ddc1372":"def create_pairs(x, digit_indices):\n    pairs = []\n    labels = []\n    n = min([len(digit_indices[d]) for d in range(10)]) - 1 #What is the minimum amount of images that we have on a specific class\n    for d in range(10): #For all the classes\n        for i in range(n): #For the minimum amount in one class\n            z1, z2 = digit_indices[d][i], digit_indices[d][i + 1] #Take 2 indices in the same class\n            pairs += [[x[z1], x[z2]]]\n            inc = random.randrange(1, 10)\n            dn = (d + inc) % 10\n            z1, z2 = digit_indices[d][i], digit_indices[dn][i] #Take 2 indices from different classes\n            pairs += [[x[z1], x[z2]]]\n            labels += [1, 0] #The first couple of images are similar, the second are different \n            \n    return np.array(pairs), np.array(labels)\n\ndef create_pairs_on_set(images, labels):\n    # Function to get indices of the same class and create couples of images \n    # Parameters\n    # images (np.ndarray): mnist images\n    # labels(np.ndarray): mnist tags \n    \n    digit_indices = [np.where(labels == i)[0] for i in range(10)] #Get a list of arrays with the indices\n    pairs, y = create_pairs(images, digit_indices)\n    y = y.astype('float32')\n    \n    return pairs, y\n\ntrain_pairs, train_labels = create_pairs_on_set(train_images, train_labels)\ntest_pairs, test_labels = create_pairs_on_set(test_images, test_labels)","780c3c3b":"def plot_images(train_pairs, train_labels):\n    n = np.random.randint(train_pairs.shape[0])\n    plt.subplot(1,2,1)\n    plt.imshow(train_pairs[n,0,:,:])\n    plt.subplot(1,2,2)\n    plt.imshow(train_pairs[n,1,:,:])\n    if train_labels[n] == 1:\n        print(\"Images are similar\")\n    else:\n        print(\"Images are not similar\")\nplot_images(train_pairs, train_labels)","33f7f9d1":"plot_images(train_pairs, train_labels)","41f3b77e":"def base_network():\n    Input = tf.keras.layers.Input(shape=(28,28,), name=\"Input\")\n    L1 = tf.keras.layers.Flatten(name=\"flatten_input\")(Input)\n    L2 = tf.keras.layers.Dense(128, activation='relu', name=\"Dense_1\")(L1)\n    L3 = tf.keras.layers.Dropout(0.1, name=\"Dropout_1\")(L2)\n    L4 = tf.keras.layers.Dense(128, activation='relu', name=\"Dense_2\")(L3)\n    L5 = tf.keras.layers.Dropout(0.1, name=\"Dropout_2\")(L4)\n    Out = tf.keras.layers.Dense(128, activation='relu', name=\"Dense_3\")(L5)\n    model = tf.keras.models.Model(inputs=Input, outputs=Out)\n    return model\nbase = base_network()\ntf.keras.utils.plot_model(base, show_shapes=True, show_layer_names=True, to_file=\"base.png\")","15ad2688":"#Calculate euclidean distance\ndef euclidean_distance(vects):\n    x, y = vects\n    sum_square = tf.keras.backend.sum(tf.keras.backend.square(x - y), axis=1, keepdims=True)\n    return tf.keras.backend.sqrt(tf.keras.backend.maximum(sum_square, tf.keras.backend.epsilon()))","9679af31":"# create the left input and point to the base network\ninput1 = tf.keras.layers.Input(shape=(28,28,), name=\"Input_layer1\")\noutput1 = base(input1)\n\n# create the right input and point to the base network\ninput2 = tf.keras.layers.Input(shape=(28,28,), name=\"Input_layer2\")\noutput2 = base(input2)\n\n# Custom Lambda layer; measure the similarity of the two vector outputs\noutput = tf.keras.layers.Lambda(euclidean_distance, name=\"output_layer\", output_shape=(1,))([output1, output2])\n\n# Wrap the base network, inputs and lambda layer in a model\nmodel = tf.keras.models.Model(inputs=[input1, input2], outputs=output)\n\n# plot model graph\ntf.keras.utils.plot_model(model, show_shapes=True, show_layer_names=True, to_file='outer-model.png')","2750cf16":"def contrastive_loss_with_margin(margin):\n    def contrastive_loss(y_true, y_pred):\n        '''Contrastive loss from Hadsell-et-al.'06\n        http:\/\/yann.lecun.com\/exdb\/publis\/pdf\/hadsell-chopra-lecun-06.pdf\n        '''\n        square_pred = tf.keras.backend.square(y_pred)\n        margin_square = tf.keras.backend.square(tf.keras.backend.maximum(margin - y_pred, 0))\n        return tf.keras.backend.mean(y_true * square_pred + (1 - y_true) * margin_square)\n    return contrastive_loss\n\nrms = tf.keras.optimizers.RMSprop()\nmodel.compile(loss=contrastive_loss_with_margin(margin=1), optimizer=rms)","1830a2dd":"history = model.fit([train_pairs[:,0], train_pairs[:,1]], train_labels, epochs=25, batch_size=128, validation_data=([test_pairs[:,0], test_pairs[:,1]], test_labels))","5d05750a":"predictions = model.predict([test_pairs[:,0], test_pairs[:,1]])","7d470d4e":"# utility to display a row of digits with their predictions\ndef display_images(left, right, predictions, labels, title, n):\n    plt.figure(figsize=(17,3))\n    plt.title(title)\n    plt.yticks([])\n    plt.xticks([])\n    plt.grid(None)\n    left = np.reshape(left, [n, 28, 28])\n    left = np.swapaxes(left, 0, 1)\n    left = np.reshape(left, [28, 28*n])\n    plt.imshow(left)\n    plt.figure(figsize=(17,3))\n    plt.yticks([])\n    plt.xticks([28*x+14 for x in range(n)], predictions)\n    for i,t in enumerate(plt.gca().xaxis.get_ticklabels()):\n        if predictions[i] > 0.5: t.set_color('red') # bad predictions in red\n    plt.grid(None)\n    right = np.reshape(right, [n, 28, 28])\n    right = np.swapaxes(right, 0, 1)\n    right = np.reshape(right, [28, 28*n])\n    plt.imshow(right)","d2d82af7":"predictions = np.squeeze(predictions)\nindexes = np.random.choice(len(predictions), size=10)\ndisplay_images(test_pairs[:, 0][indexes], test_pairs[:, 1][indexes], predictions[indexes], test_labels[indexes], \"clothes and their dissimilarity\", 10)","1065a276":"Let's see some examples","d8a3db1c":"We will use the euclidean distance to measure the similarity of the two vectors. The euclidean distance is definded by:\n![euc](https:\/\/chrisjmccormick.files.wordpress.com\/2014\/08\/euclideandistanceexpansion_eq.png)","4ffde2a9":"Normalize and prepare the images to be used","0e5bbab3":"We are going to need pairs of images and their tag saying if they are similar or not. We are going to use the value of 1 if they are similar and 0 if they are not.","9135e828":"Take a random pairs of images and predict the similarity between a couple of images. When there is a high value it shows dissimilarity between the images and a low value shows a high similarity. This is because we are using euclidean distance, so a small distance would represent a high similarity and a high distance would represent dissimilarity.","9c8293b5":"Now it is time to train our model. Remember that our train_pairs variable has a shape of (119980, 2, 28, 28), so we get the first image using the slice tr_pairs[:,0] and the second image using the slice tf_pairs[:,1]","da0e6276":"Download the library and store it","b94f5322":"Let's build our custom loss function [Hadsell](http:\/\/yann.lecun.com\/exdb\/publis\/pdf\/hadsell-chopra-lecun-06.pdf) for our network and compile it with the [RMSprop](https:\/\/www.tensorflow.org\/api_docs\/python\/tf\/keras\/optimizers\/RMSprop) optimizer.","59fb5f09":"Now, we will build our model and define our custom layer to measure the difference between the couple of images","e8ddfa29":"Let's now build the Siamese network. The plot will show two inputs going to the base network.","4e8a59d6":"Import libraries","d516b3c3":"# Siamese Networks\nA siamese neural network is a class of neural network architecture that contains two identical structures that share weights and parameters. Siamese networks are popular because they don't need a lot of data to learn to reproduce the probability distribution of the dataset.\n\nSiamese networks are used to find similarity of multiple inputs by comparing its feature vectors. A simple application would be the comparison between two or more images to see if they are the similar or how much they differ. Here we are going to use the MNIST fashion Dataset and compare pairs of images to learn if we are watching the same class or not.","f9ab4915":"Let's see some images"}}