{"cell_type":{"19f44d06":"code","a2776b65":"code","974bd99e":"code","b00f50b4":"code","19a77b55":"code","11e1aec4":"code","11601d3c":"code","0960079e":"code","aa6ad269":"code","69f01885":"code","68016392":"code","e6795a26":"code","c8575731":"code","268db09e":"code","737abb3e":"code","3e08b937":"code","874cc338":"code","3d854a36":"markdown","870da4d1":"markdown","2f539d56":"markdown","36962431":"markdown","288a7d5e":"markdown","fd5a616c":"markdown","3c6a5b63":"markdown","e0478ff4":"markdown","49694fcd":"markdown","d586e682":"markdown","c852dbad":"markdown","f36d08da":"markdown","25d7d8b8":"markdown","e2bc3e65":"markdown","151f3531":"markdown","f7ed3c89":"markdown","2f2da659":"markdown","59db0249":"markdown","d7f6db93":"markdown","908adcc9":"markdown","359a7694":"markdown"},"source":{"19f44d06":"from copy import deepcopy\nimport numpy as np\nimport pandas as pd\nimport os\nfrom matplotlib import pyplot as plt\nplt.style.use('ggplot')\nprint(os.listdir(\"..\/input\"))\n","a2776b65":"data = pd.read_csv('..\/input\/120-years-of-olympic-history-athletes-and-results\/athlete_events.csv')\nprint(data.shape)","974bd99e":"## The data has 9474 null values in Age , hence will be substituting with the mean\n\nAgeMean = int(data['Age'].mean())\nprint('Age Mean', AgeMean)\ndata['Age'] = data['Age'].fillna(AgeMean)\ndata['Age'].isna().sum()\n\n## 22% of the Height and 23% of the Weight column is having NaN values\n## The NaN values are substitued with mode\n\n\nHeightMode = data['Height'].mode()[0] ## 0 -> the column wise mode \nprint('Height Mode',HeightMode)\ndata['Height'] = data['Height'].fillna(HeightMode)\ndata['Height'].isna().sum()\n\n\nWeightMode = data['Weight'].mode()[0]\nprint('Weight Mode',WeightMode)\ndata['Weight'] = data['Weight'].fillna(WeightMode)\ndata['Weight'].isna().sum()\n\n##The Medal column has NaN values if no medal is won , we Substitute the NaN values with a string 'None'\n\ndata['Medal'] = data['Medal'].fillna('None')\ndata['Medal'].isna().sum()\n\n","b00f50b4":"noc_country = pd.read_csv(\"..\/input\/120-years-of-olympic-history-athletes-and-results\/noc_regions.csv\")\nnoc_country.drop('notes', axis = 1 , inplace = True)\nnoc_country.rename(columns = {'region':'Country'}, inplace = True)\n\nnoc_country.head()\n\n\n#Merging the datasets\n\nolympics_merge = data.merge(noc_country,\n                                left_on = 'NOC',\n                                right_on = 'NOC',\n                                how = 'left')\n\n# Do we have NOCs that didnt have a matching country in the master?\nolympics_merge.loc[olympics_merge['Country'].isnull(),['NOC', 'Team']].drop_duplicates()\nolympics_merge.shape\n\n## Merge gdp\n\nw_gdp = pd.read_csv('..\/input\/country-wise-gdp-data\/world_gdp.csv', skiprows = 3)\n\n# Remove unnecessary columns\nw_gdp.drop(['Indicator Name', 'Indicator Code'], axis = 1, inplace = True)\n\n# The columns are the years for which the GDP has been recorded. This needs to brought into a single column for efficient\n# merging.\nw_gdp = pd.melt(w_gdp, id_vars = ['Country Name', 'Country Code'], var_name = 'Year', value_name = 'GDP')\n\n# convert the year column to numeric\nw_gdp['Year'] = pd.to_numeric(w_gdp['Year'])\n\nw_gdp.head()\n\n\n# Replace missing Teams by the values above.\nolympics_merge.loc[olympics_merge['Country'].isnull(), ['Country']] = olympics_merge['Team']\n\nolympics_merge['Country'] = np.where(olympics_merge['NOC']=='SGP', 'Singapore', olympics_merge['Country'])\nolympics_merge['Country'] = np.where(olympics_merge['NOC']=='ROT', 'Refugee Olympic Athletes', olympics_merge['Country'])\nolympics_merge['Country'] = np.where(olympics_merge['NOC']=='UNK', 'Unknown', olympics_merge['Country'])\nolympics_merge['Country'] = np.where(olympics_merge['NOC']=='TUV', 'Tuvalu', olympics_merge['Country'])\n\n\n# Put these values from Country into Team\nolympics_merge.drop('Team', axis = 1, inplace = True)\nolympics_merge.rename(columns = {'Country': 'Team'}, inplace = True)\n\n# Merge to get country code\nolympics_merge_ccode = olympics_merge.merge(w_gdp[['Country Name', 'Country Code']].drop_duplicates(),\n                                            left_on = 'Team',\n                                            right_on = 'Country Name',\n                                            how = 'left')\n\nolympics_merge_ccode.drop('Country Name', axis = 1, inplace = True)\n\n# Merge to get gdp too\nolympics_merge_gdp = olympics_merge_ccode.merge(w_gdp,\n                                                left_on = ['Country Code', 'Year'],\n                                                right_on = ['Country Code', 'Year'],\n                                                how = 'left')\n\nolympics_merge_gdp.drop('Country Name', axis = 1, inplace = True)\n\n### Merge Population Data\n\n# Read in the population data\nw_pop = pd.read_csv('..\/input\/country-wise-population-data\/world_pop.csv')\n\nw_pop.drop(['Indicator Name', 'Indicator Code'], axis = 1, inplace = True)\n\nw_pop = pd.melt(w_pop, id_vars = ['Country', 'Country Code'], var_name = 'Year', value_name = 'Population')\n\n# Change the Year to integer type\nw_pop['Year'] = pd.to_numeric(w_pop['Year'])\n\nw_pop.head()\n\nolympics_complete = olympics_merge_gdp.merge(w_pop,\n                                            left_on = ['Country Code', 'Year'],\n                                            right_on= ['Country Code', 'Year'],\n                                            how = 'left')\n\nolympics_complete.drop('Country', axis = 1, inplace = True)\n\nolympics_complete.head()","19a77b55":"\nolympics_complete['Medal_Won'] = np.where(olympics_complete.loc[:,'Medal'] == 'None', 0, 1)\nmedalC = olympics_complete.groupby(['Team'])['Medal_Won'].agg('sum').reset_index()\nmedal_count_per_country = medalC.sort_values('Medal_Won',ascending = False)\n#medal_count_per_country = medal_count_per_country.iloc[:136,:]\nmedal_count_per_country","11e1aec4":"### GDP\n###### TYG = 'Team,Year,GDP'\nTYG = olympics_complete[olympics_complete['Year'] == 2016 ][['Team','Year','GDP']]\n\ngdp = {}\n\nfor index,row in TYG.iterrows():\n    if TYG.loc[index,'Team'] not in gdp:\n        gdp[TYG.loc[index,'Team']] = TYG.loc[index,'GDP']\n\nmedal_count_per_country['GDP'] = medal_count_per_country['Team'].map(gdp)\nmedal_count_per_country['GDP'] = medal_count_per_country['GDP'].fillna(1)\n\n### Population\n###### TYP = 'Team,Year,Population'\nTYP = olympics_complete[olympics_complete['Year'] == 2016][['Team','Year','Population']]\n\npopu = {}\n\nfor index,row in TYP.iterrows():\n    if TYP.loc[index,'Team'] not in popu:\n        popu[TYP.loc[index,'Team']] = TYP.loc[index,'Population']\n\n\nmedal_count_per_country['Population'] = medal_count_per_country['Team'].map(popu)\nmedal_count_per_country['Population'] = medal_count_per_country['Population'].fillna(1)\n\n\n## This is done to remove all the instances with missing or negligible population or GDP inorder to futher normalise the data \nmedal_count_per_country = medal_count_per_country[medal_count_per_country['Population']>10000]","11601d3c":"medal_count_per_country['Medal_WonNorm'] = (medal_count_per_country['Medal_Won']-medal_count_per_country['Medal_Won'].mean())\/np.std(medal_count_per_country['Medal_Won'],axis = 0)\nmedal_count_per_country['GDPNorm'] = (medal_count_per_country['GDP']-medal_count_per_country['GDP'].mean())\/np.std(medal_count_per_country['GDP'],axis = 0)\nmedal_count_per_country['PopulationNorm'] = (medal_count_per_country['Population']-medal_count_per_country['Population'].mean())\/np.std(medal_count_per_country['Population'],axis = 0)\n\ntopMedalHolders = medal_count_per_country\ntopMedalHolders","0960079e":"topMedalHolders.columns\n\n","aa6ad269":"# find the appropriate cluster number\nplt.figure(figsize=(10, 8))\nfrom sklearn.cluster import KMeans\nwcss = []\nfor i in range(1, 11):\n    kmeans = KMeans(n_clusters = i, init = 'k-means++', random_state = 42)\n    kmeans.fit(topMedalHolders.iloc[:, [4, 5]].values)\n    wcss.append(kmeans.inertia_)\nplt.plot(range(1, 11), wcss)\nplt.title('The Elbow Method')\nplt.xlabel('Number of clusters')\nplt.ylabel('WCSS')\nplt.show()\n\nplt.figure(figsize=(10, 8))\n\n# Fitting K-Means to the dataset\nfrom mpl_toolkits.mplot3d import Axes3D\n\nkmeans = KMeans(n_clusters = 3, init = 'k-means++', random_state = 42)\ny_kmeans = kmeans.fit_predict(topMedalHolders[['Medal_WonNorm','GDPNorm']])\n\ncentroids = kmeans.cluster_centers_\n\n#beginning of  the cluster numbering with 1 instead of 0\ny_kmeans1=y_kmeans\ny_kmeans1=y_kmeans+1\n# New Dataframe called cluster\ncluster = pd.DataFrame(y_kmeans1)\n# Adding cluster to the Dataset1\ntopMedalHolders['cluster'] = cluster\n#Mean of clusters\nkmeans_mean_cluster = pd.DataFrame(round(topMedalHolders.groupby('cluster').mean(),1))\nkmeans_mean_cluster\n\nplt.title('Clusters of Countries')\nplt.xlabel('Medal Count')\nplt.ylabel('GDP')\nplt.scatter( topMedalHolders['Medal_WonNorm'],topMedalHolders['GDPNorm'],s = 100,c= kmeans.labels_.astype(float), alpha=0.5)\nplt.scatter(centroids[:, 0], centroids[:, 1],s= 50, c=['red','white','blue'])\nplt.show()\n\n","69f01885":"# Importing the libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Importing the dataset\nX = topMedalHolders.iloc[:, [4, 5]].values\n#print(X)\n# y = dataset.iloc[:, 3].values\nplt.figure(figsize=(10,18))\n\n# Using the dendrogram to find the optimal number of clusters\nimport scipy.cluster.hierarchy as sch\ndendrogram = sch.dendrogram(sch.linkage(X, method = 'ward'))\nplt.title('Dendrogram')\nplt.xlabel('Medal Count')\nplt.ylabel('Euclidean distances')\nplt.show()\n\n# Fitting Hierarchical Clustering to the dataset\nfrom sklearn.cluster import AgglomerativeClustering\nhc = AgglomerativeClustering(n_clusters = 3, affinity = 'euclidean', linkage = 'ward')\ny_hc = hc.fit_predict(X)\n\n\n# Visualising the clusters\nplt.figure(figsize=(10,18))\nplt.xticks(np.arange(min(topMedalHolders['Medal_WonNorm']), max(topMedalHolders['Medal_WonNorm']), 800)) \n#plt.xticks(np.arange(min(topMedalHolders['GDP']), max(topMedalHolders['GDP']),1.084733e+05)) \nplt.scatter(X[y_hc == 0, 0], X[y_hc == 0, 1], s = 100, c = 'red', label = 'Cluster 1')\nplt.scatter(X[y_hc == 1, 0], X[y_hc == 1, 1], s = 100, c = 'blue', label = 'Cluster 2')\nplt.scatter(X[y_hc == 2, 0], X[y_hc == 2, 1], s = 100, c = 'green', label = 'Cluster 3')\n#plt.scatter(X[y_hc == 3, 0], X[y_hc == 3, 1], s = 100, c = 'Black', label = 'USA')\n#plt.scatter(X[y_hc == 4, 0], X[y_hc == 4, 1], s = 100, c = 'magenta', label = 'Cluster 5')\nplt.title('Clusters of Countries')\nplt.xlabel('Medal Count')\nplt.ylabel('GDP')\nplt.legend()\nplt.show()","68016392":"# find the appropriate cluster number\nplt.figure(figsize=(10, 8))\nfrom sklearn.cluster import KMeans\nwcss = []\nfor i in range(1, 11):\n    kmeans = KMeans(n_clusters = i, init = 'k-means++', random_state = 42)\n    kmeans.fit(topMedalHolders.iloc[:, [4, 6]].values)\n    wcss.append(kmeans.inertia_)\nplt.plot(range(1, 11), wcss)\nplt.title('The Elbow Method')\nplt.xlabel('Number of clusters')\nplt.ylabel('WCSS')\nplt.show()\n\nplt.figure(figsize=(10, 8))\n\n# Fitting K-Means to the dataset\nfrom mpl_toolkits.mplot3d import Axes3D\n\nkmeans = KMeans(n_clusters = 4, init = 'k-means++', random_state = 42)\ny_kmeans = kmeans.fit_predict(topMedalHolders[['Medal_WonNorm','PopulationNorm']])\n\ncentroids = kmeans.cluster_centers_\n\n#beginning of  the cluster numbering with 1 instead of 0\ny_kmeans1=y_kmeans\ny_kmeans1=y_kmeans+1\n# New Dataframe called cluster\ncluster = pd.DataFrame(y_kmeans1)\n# Adding cluster to the Dataset1\ntopMedalHolders['cluster'] = cluster\n#Mean of clusters\nkmeans_mean_cluster = pd.DataFrame(round(topMedalHolders.groupby('cluster').mean(),1))\nkmeans_mean_cluster\n\nplt.title('Clusters of Countries')\nplt.xlabel('Medal Count')\nplt.ylabel('Population')\nplt.scatter( topMedalHolders['Medal_WonNorm'],topMedalHolders['PopulationNorm'],s = 100,c= kmeans.labels_.astype(float), alpha=0.5)\nplt.scatter(centroids[:, 0], centroids[:, 1],s = 50, c=['red','white','blue','cyan'])\nplt.show()\n\n\n\n","e6795a26":"# Importing the libraries\n'''import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n'''\n# Importing the dataset\nX = topMedalHolders.iloc[:, [4, 6]].values\n# y = dataset.iloc[:, 3].values\nplt.figure(figsize=(10, 8))\n\n# Using the dendrogram to find the optimal number of clusters\nimport scipy.cluster.hierarchy as sch\ndendrogram = sch.dendrogram(sch.linkage(X, method = 'ward'))\nplt.title('Dendrogram')\nplt.xlabel('Medal Count')\nplt.ylabel('Euclidean distances')\nplt.show()\n\n# Fitting Hierarchical Clustering to the dataset\nfrom sklearn.cluster import AgglomerativeClustering\nhc = AgglomerativeClustering(n_clusters = 4, affinity = 'euclidean', linkage = 'ward')\ny_hc = hc.fit_predict(X)\n\n\n# Visualising the clusters\nplt.figure(figsize=(10, 8))\nplt.scatter(X[y_hc == 0, 0], X[y_hc == 0, 1], s = 100, c = 'red', label = 'Cluster 1')\nplt.scatter(X[y_hc == 1, 0], X[y_hc == 1, 1], s = 100, c = 'blue', label = 'Cluster 2')\nplt.scatter(X[y_hc == 2, 0], X[y_hc == 2, 1], s = 100, c = 'green', label = 'Cluster 3')\nplt.scatter(X[y_hc == 3, 0], X[y_hc == 3, 1], s = 100, c = 'cyan', label = 'Cluster 4')\n#plt.scatter(X[y_hc == 4, 0], X[y_hc == 4, 1], s = 100, c = 'magenta', label = 'Cluster 5')\nplt.title('Clusters of Countries')\nplt.xlabel('Medal Count')\nplt.ylabel('Population')\nplt.legend()\nplt.show()","c8575731":"data['HeightNorm'] = (data['Height']-data['Height'].mean())\/np.std(data['Height'],axis = 0)\ndata['WeightNorm'] = (data['Weight']-data['Weight'].mean())\/np.std(data['Weight'],axis = 0)\n","268db09e":"## Input for K Means Algo\n### Creating dataset for the winners alone\nmed = ['Gold','Silver','Bronze']\nHeight_Weight_Win = data[data.Medal.isin(med)]\nHeight_Weight_Win = Height_Weight_Win[['HeightNorm','WeightNorm']]\n\n### Creating dataset for all the players  \nHeight_Weight= data[['HeightNorm','WeightNorm']]\n\nHeight_Weight.head()","737abb3e":"# find the appropriate cluster number\nplt.figure(figsize=(10, 8))\nfrom sklearn.cluster import KMeans\nwcss = []\nfor i in range(1, 11):\n    kmeans = KMeans(n_clusters = i, init = 'k-means++', random_state = 42)\n    kmeans.fit(Height_Weight)\n    wcss.append(kmeans.inertia_)\nplt.plot(range(1, 11), wcss)\nplt.title('The Elbow Method')\nplt.xlabel('Number of clusters')\nplt.ylabel('WCSS')\nplt.show()\n\nplt.figure(figsize=(10, 8))\n\n# Fitting K-Means to the dataset\nfrom mpl_toolkits.mplot3d import Axes3D\n\nkmeans = KMeans(n_clusters = 3, init = 'k-means++', random_state = 42)\ny_kmeans = kmeans.fit_predict(Height_Weight)\n\ncentroids = kmeans.cluster_centers_\n\n#beginning of  the cluster numbering with 1 instead of 0\ny_kmeans1=y_kmeans\ny_kmeans1=y_kmeans+1\n# New Dataframe called cluster\ncluster = pd.DataFrame(y_kmeans1)\n# Adding cluster to the Dataset1\nHeight_Weight['cluster'] = cluster\n#Mean of clusters\nkmeans_mean_cluster = pd.DataFrame(round(Height_Weight.groupby('cluster').mean(),1))\nkmeans_mean_cluster\n\nplt.title('Height-Weight Distribution all Players')\nplt.xlabel('Height')\nplt.ylabel('Weight')\nplt.scatter(Height_Weight['HeightNorm'], Height_Weight['WeightNorm'], c= kmeans.labels_.astype(float), alpha=0.5)\nplt.scatter(centroids[:, 0], centroids[:, 1], c=['red','white','blue'])\n\n\nplt.show()\n","3e08b937":"Height_Weight_Win = Height_Weight_Win[['HeightNorm','WeightNorm']]","874cc338":"# find the appropriate cluster number\nplt.figure(figsize=(10, 8))\nwcss = []\nfor i in range(1, 11):\n    kmeans = KMeans(n_clusters = i, init = 'k-means++', random_state = 42)\n    kmeans.fit(Height_Weight_Win)\n    wcss.append(kmeans.inertia_)\nplt.plot(range(1, 11), wcss)\nplt.title('The Elbow Method')\nplt.xlabel('Number of clusters')\nplt.ylabel('WCSS')\nplt.show()\n\n# Fitting K-Means to the dataset\nfrom mpl_toolkits.mplot3d import Axes3D\nplt.figure(figsize=(10, 8))\n\nkmeans = KMeans(n_clusters = 3, init = 'k-means++', random_state = 42)\ny_kmeans = kmeans.fit_predict(Height_Weight_Win)\n\ncentroids = kmeans.cluster_centers_\n\n#beginning of  the cluster numbering with 1 instead of 0\ny_kmeans1=y_kmeans\ny_kmeans1=y_kmeans+1\n# New Dataframe called cluster\ncluster = pd.DataFrame(y_kmeans1)\n# Adding cluster to the Dataset1\nHeight_Weight_Win['cluster'] = cluster\n#Mean of clusters\nkmeans_mean_cluster = pd.DataFrame(round(Height_Weight_Win.groupby('cluster').mean(),1))\nkmeans_mean_cluster\n\nplt.title('Height-Weight Distribution all Medal Winners')\nplt.xlabel('Height')\nplt.ylabel('Weight')\nplt.scatter(Height_Weight_Win['HeightNorm'], Height_Weight_Win['WeightNorm'], c= kmeans.labels_.astype(float), alpha=0.5)\nplt.scatter(centroids[:, 0], centroids[:, 1], c=['red','white','blue'])\nplt.show()\n\n","3d854a36":"# on Medal_Won vs Population","870da4d1":"# Merging Multiple DataSets","2f539d56":"# $$ $$\n\n\n","36962431":"## Winning Medals","288a7d5e":"# Hierarchical Clustering","fd5a616c":"finalCount = pd.DataFrame(data['Team'].unique(),columns = ['Country'])\n\n\n'''\nTYG = data[data['Year'] == 2016][['Team','Year','GDP']]\n\ngdp = {}\n\nfor index,row in TYG.iterrows():\n    if TYG.loc[index,'Team'] not in gdp:\n        gdp[TYG.loc[index,'Team']] = TYG.loc[index,'GDP']\n   for team in finalCount['Country']:\n    if team not in gdp:\n        gdp[team] = 1\n   \n\n\ngdpM = 0\nfor i in finalCount['GDP']:\n    \n    gdpM += float(i)\ngdpM = gdpM\/len(finalCount['GDP'])\nprint(gdpM)'''\n\n#gdpS = float(np.std(finalCount['GDP']))\ngdpM = 353802711528.3493\ngdpS = 1665152657347.2659\n\nfinalCount['GDP'] = finalCount['Country'].map(gdp)\n#countryWiseMedalCount = finalCount\n\n\nfinalCount['GDPNorm'] = float(finalCount['GDP']-gdpM)\/gdpS\nfinalCount['MedalCNorm'] = (finalCount['MedalC']-finalCount['MedalC'].mean())\/np.std(finalCount['MedalC'],axis = 0)\n\n\n","3c6a5b63":"#  $$ $$ \n# Conclusion\n\n## The results of the K Means clustering i.e. the height weight distribution:\n    a) For all the Players\n    b) For all Medalists\n\n### Both of them follow a similar distribution, and hence the winners and non-winners do not show a huge  difference in their height and weight. This shows that, taking the height and weight into considerence, all the players have almost equally likely chances to win a medal.","e0478ff4":"## Data Preprocessing - Missing Value Treatment by the imputation method\n","49694fcd":"# K Means Clustering","d586e682":"# Results on no_of_medals_won vs GDP:\n### On comparing the results of the K-Means clustering and Hierachial clustering to divide of the instances into clusters, both the results seem to follow almost similar distribution.\n### Using the result of the elbow method of k-means clustering, 3 was found to be the appropriate no of clusters. Hence, for both the k-means and hierarchial clustering I chose 3 as the ideal no of clusters for better analysis.\n### The clusters formed are as follows:\n     1. Green Cluster: with very few medals and less GDP.\n     2. Red Cluster: with average range  of no of medals and average distributed GDP\n     3. Blue Cluster: the highest no of medals and highest GDP     ","c852dbad":"## GDP for the Year 2016","f36d08da":"'''\ndata = olympics_merge_gdp\ndf = pd.DataFrame(data[['Team','Year','GDP','Medal']],columns = ['Team','Year','GDP','Medal'])\ndf.head()\ndata['Medal'] = data['Medal'].fillna('None')\n\nfor year in data['Year'].unique():\n    for index,rows in data.iterrows():\n        if (df.loc[index,'Year'] == year):\n\n            if (df.loc[index,'Team'] not in count):\n                if (df.loc[index,'Medal']== 'Silver'):\n                    count[df.loc[index,'Team']]= 1\n\n            else:\n                if (df.loc[index,'Medal'] == 'Silver'):\n                    count[df.loc[index,'Team']] += 1\n\n\ncount1 = {}\nfor index,rows in data.iterrows():\n    if df.loc[index,'Team'] not in count:\n        count1[df.loc[index,'Team']] = 0\ncount.update(count1)      \n'''","25d7d8b8":"# Hierarchial Clustering ","e2bc3e65":"# Results on no_of_medals_won vs Population:\n### On comparing the results of the K-Means clustering and Hierachial clustering to divide of the instances into clusters, both the results seem to follow almost similar distribution.\n### Using the result of the elbow method of k-means clustering,  4 was found to be the appropriate no of clusters. Hence, for both the k-means and hierarchial clustering I chose 4 as the ideal no of clusters for better analysis.\n### The clusters formed are as follows:\n     1. Blue Cluster: with very few medals and very less Population.\n     2. Red Cluster: with relatively higher no of medals when compared to 'Blue' Cluster,(average no of medals) but less Population\n     3. Cyan Cluster: with many medals and relatively less population.\n     4. Green Cluster: with relatively fewer medal but very large popuation\n     ","151f3531":"# Medals Won by Each Country","f7ed3c89":"# Find the appropriate cluster number\n","2f2da659":"# Using  Hierarchical  and K means Clustering to analyse the olympics history\n","59db0249":"# on Medal_Won vs GDP","d7f6db93":"# KMeans Clustering to see the distribution of Height and Weight of players","908adcc9":"# Standardize the data to normal distribution\n","359a7694":"# K Means Clustering"}}