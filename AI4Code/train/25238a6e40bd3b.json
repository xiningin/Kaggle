{"cell_type":{"db4b7a07":"code","4bfbf4c6":"code","152c9c9e":"code","34883126":"code","b0a3c119":"code","2c0c95c5":"code","df2247b1":"code","17630652":"code","dcdabe1e":"code","800fae90":"code","feb67beb":"code","8cb99a6b":"code","2d243537":"code","0e7894e5":"code","2fa2cb33":"code","7ef92496":"code","704f8f0c":"code","532d2c69":"code","4ad49aeb":"markdown","19889c91":"markdown","4c337bd3":"markdown","9b7d9e00":"markdown","4bf96d1e":"markdown","ccffd6ba":"markdown","bef9d1d8":"markdown","da2d0e6f":"markdown","b46e594e":"markdown","3c9e0c8a":"markdown","50c45118":"markdown","192ef5af":"markdown","b292556c":"markdown","78324c7d":"markdown"},"source":{"db4b7a07":"# Instalamos TensorFlow en nuestro entorno de ejecuci\u00f3n\nimport tensorflow as tf\n\n# Keras es una serie de APIs de TensorFlow que permiten simplificar el desarrollo de modelos\nfrom tensorflow import keras\n\n# NumPy nos permite realizar operaciones de \u00e1lgebra lineal, matrices y es muy flexible para ser utilizada con TensorFlow\nimport numpy as np\n\n# Matplotlib simplifica la creaci\u00f3n de gr\u00e1ficos y ser\u00e1 muy importante para presentar los resultados obtenidos\nimport matplotlib.pyplot as plt\n\n# Cada celda se corre dando clic en \u2018run\u2019 del lado izquierdo o presionando Shift + Enter.","4bfbf4c6":"datos = np.loadtxt('..\/input\/graficaejemplo\/Datos-RedNeuronal.csv', delimiter=',', skiprows=1)\nx = datos[:, 0:2]\ny = datos[:, 2]\nplt.scatter(x[:, 0], x[:, 1], c=y, cmap='Accent')\nprint(y)","152c9c9e":"from keras.models import Sequential\nfrom keras.layers import Dense","34883126":"\n# Generamos el modelo de tipo secuencial, con la funci\u00f3n de activaci\u00f3n deseada y una capa.\n# La funci\u00f3n de activaci\u00f3n es sigmoide. Tambi\u00e9n puedes usar otros tipos, como ReLU\nmodelo = Sequential()\nmodelo.add(Dense(1, input_dim=2, activation='sigmoid'))\nmodelo.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n\n# Ya que est\u00e1 listo el modelo, procedemos a entrenar con 1000 epochs, es decir, 1000 ciclos de entrenamiento\nhist = modelo.fit(x, y, epochs=10, verbose=1) # El par\u00e1metro verbose nos permite ir imprimiendo los resultados por capa.\nplt.plot(hist.history['accuracy'])","b0a3c119":"pruebas = 15 * np.random.rand(100, 2) - 5\nresultado_pruebas = modelo.predict(pruebas).round()\nplt.scatter(pruebas[:, 0], pruebas[:, 1], c=resultado_pruebas, cmap='Accent')","2c0c95c5":"# A\u00f1adimos una capa m\u00e1s y volvemos a entrenar con los mismos datos\nmodelo_2 = Sequential([\n    Dense(2, input_dim=2, activation='sigmoid'),\n    Dense(1, activation='sigmoid')\n])\nmodelo_2.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\nmodelo_2.fit(x, y, epochs=100)\n# Probamos con los datos de prueba que ya ten\u00edamos\nresultado_pruebas_2 = modelo_2.predict(pruebas).round()\nplt.scatter(pruebas[:, 0], pruebas[:, 1], c=resultado_pruebas_2, cmap='Accent')","df2247b1":"# Inicializamos un nuevo objeto para el modelo 3 y a\u00f1adimos una capa m\u00e1s y volvemos a entrenar con los mismos datos\nprint(x.shape)\nmodelo_3 = Sequential([\n    Dense(2, input_dim=2),\n    Dense(2, activation='sigmoid'),\n    Dense(1,activation='sigmoid')\n])\nmodelo_3.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\nmodelo_3.fit(x, y, epochs=100, verbose=1)\n# Probamos con los datos de prueba que ya ten\u00edamos\nresultado_pruebas_3 = modelo_3.predict(pruebas).round()\nplt.scatter(pruebas[:, 0], pruebas[:, 1], c=resultado_pruebas_3, cmap='Accent')","17630652":"datos = keras.datasets.fashion_mnist","dcdabe1e":"# Almacenamos la informaci\u00f3n de la base de datos y la dividimos en conjuntos de prueba y entrenamiento.\n(imagenes_entrenamiento, labels_entrenamiento), (imagenes_prueba, labels_prueba) = datos.load_data()\n# Dado que las im\u00e1genes tienen una descripci\u00f3n num\u00e9rica, es mucho m\u00e1s sencillo revisarlas por su nombre\nclase_imagenes = ['Playera', 'Pantal\u00f3n', 'Su\u00e9ter', 'Vestido', 'Abrigo', 'Sandalia', 'Camisa', 'Tenis', 'Bolso', 'Botas']\n# Lo anterior significa que las im\u00e1genes cuya clase est\u00e9 identificada como \u20180\u2019 ser\u00e1n de playeras; las identificadas con \u20181\u2019, pantalones; y as\u00ed sucesivamente.","800fae90":"imagenes_entrenamiento[4]","feb67beb":"# Despu\u00e9s de normalizar, obtenemos valores m\u00e1s sencillos de manejar dentro del modelo.\nimagenes_entrenamiento = imagenes_entrenamiento \/ 255\nimagenes_prueba = imagenes_prueba \/ 255\nimagenes_entrenamiento[4]","8cb99a6b":"print(imagenes_entrenamiento.shape)\nprint(labels_entrenamiento.shape)","2d243537":"from keras.models import Sequential\nfrom keras import layers\n\nmodelo = Sequential([\n    layers.Flatten(input_shape=(28, 28)),\n    layers.Dense(128, activation='relu'),\n    layers.Dense(10, activation='softmax')\n])\nmodelo.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])\n\nmodelo.fit(imagenes_entrenamiento, labels_entrenamiento, epochs=10)","0e7894e5":"errores_prueba, precision_prueba = modelo.evaluate(imagenes_prueba, labels_prueba)","2fa2cb33":"prediccion = modelo.predict(imagenes_prueba)\n","7ef92496":"# La siguiente l\u00ednea, nos imprime la probabilidad obtenida de que la imagen \u20180\u2019 del set de im\u00e1genes de prueba corresponda con una de las categor\u00edas de im\u00e1genes\nprint(prediccion[0])","704f8f0c":"# Podemos obtener el valor m\u00e1ximo del vector anterior para mostrar la clase a la que pertenece la imagen\nprint(clase_imagenes[np.argmax(prediccion[0])])\n# Verificamos revisando la imagen\nplt.imshow(imagenes_prueba[0], cmap=plt.cm.binary)","532d2c69":"# Para visualizar todas las im\u00e1genes de prueba\nfor i in range(50):\n    plt.imshow(imagenes_prueba[i], cmap=plt.cm.binary)\n    plt.xlabel('Predicci\u00f3n: ' + clase_imagenes[np.argmax(prediccion[i])])\n    plt.title(clase_imagenes[labels_prueba[i]])\n    plt.show()","4ad49aeb":"Revisando las im\u00e1genes, podemos comprobar si el modelo result\u00f3 exitoso. Se puede ver que la gran mayor\u00eda de im\u00e1genes est\u00e1n plenamente identificadas, sin embargo, de vez en cuando aparece alg\u00fan error. Esto parte de que la precisi\u00f3n del modelo no es del 100%, como revisamos en celdas anteriores.\n\n# Referencias\n\n> Aur\u00e9lien G\u00e9ron. (2019). Hands-On Machine Learning with Scikit-Learn, Keras, and TensorFlow, 2nd Edition. Nueva York: O'Reilly.","19889c91":"### Modelo 1 capa","4c337bd3":"**\u00bfC\u00f3mo est\u00e1 almacenada la informaci\u00f3n de cada una de las im\u00e1genes de la base de datos?**\n\n![Captura%20de%20Pantalla%202020-11-03%20a%20la%28s%29%200.33.06.png](attachment:Captura%20de%20Pantalla%202020-11-03%20a%20la%28s%29%200.33.06.png)\n\nPor cada pixel, se guarda un valor num\u00e9rico del 0 al 255 que corresponde al color de dicho pixel. Por lo tanto, ser\u00e1 mucho m\u00e1s sencillo normalizar dichos valores a que est\u00e9n dentro del rango [0\u20131]. A continuaci\u00f3n, se muestra el vector de una de las im\u00e1genes.","9b7d9e00":"#### Predicci\u00f3n\n\n\nEs el paso final de nuestro dise\u00f1o de una red neuronal. Lo que nos permite hacer es evaluar el modelo generado con los elementos de prueba de la base de datos. Por cada elemento que probamos, el modelo nos regresa un valor que equivale a la probabilidad de que dicha imagen sea cada uno de los objetos que entrenamos. Idealmente, cuando el modelo asegura que la imagen proporcionada equivale a un pantal\u00f3n, por ejemplo, nos va a dar un valor muy cercano a 1 para el valor correspnondiente a un pantal\u00f3n y cercano a 0 para los dem\u00e1s.","4bf96d1e":"# TensorFlow\n\nEs una plataforma de c\u00f3digo abierto desarrollada por un equipo de Google creada espec\u00edficamente para el aprendizaje autom\u00e1tico. Es muy utilizada ya que permite a los investigadores de este campo seguir profundizando el conocimiento de las redes neuronales artificiales y a los desarrolladores aplicar r\u00e1pidamente todo este conocimiento en diversos tipos de sistemas. La plataforma fue desarrollada en Python, C++ y CUDA, por lo que es muy \u00fatil utilizar el primero para ir aprendiendo sobre c\u00f3mo desarrollar redes neuronales artificiales utilizando esta herramienta.\n\n## Kaggle\n\nEn este momento, estamos utilizando un notebook de [Kaggle](kaggle.com), pero tambi\u00e9n puedes probar trabajando en [Google Colaboratory](https:\/\/colab.research.google.com\/notebooks\/welcome.ipynb) o en una instalaci\u00f3n local de [Jupyter](https:\/\/jupyter.org\/). Kaggle es muy conocido dentro del mundo del aprendizaje autom\u00e1tico y la ciencia de datos. Te permite utilizar conjuntos de datos pre-existentes f\u00e1cilmente, utilizar distintas bibliotecas de Python y TensorFlow directamente, usar aceleradores de gr\u00e1ficos, compartir tu trabajo y hasta participar en concursos.\n\n## Modelado\n\nPara producir modelos adecuados, se necesitar\u00e1 tener experiencia y adecuar correctamente las t\u00e9cnicas de *machine learning*, es decir, no hay una \u2018receta\u2019 ya establecida que funcione a la perfecci\u00f3n todo el tiempo. Con el siguiente [modelo](playground.tensorflow.org) interactivo podr\u00e1s jugar y probar un poco todos los conceptos que hemos revisado hasta el momento.\n\n## Primeros pasos\n","ccffd6ba":"\u00bfQu\u00e9 podemos deducir de este resultado? Se puede observar una l\u00ednea de tendencia en la clasificaci\u00f3n. Sin embargo, todav\u00eda podemos mejorar nuestro modelo. \u00bfSi a\u00f1adimos una capa adicional tendremos m\u00e1s suerte?\n\n## 2 capas","bef9d1d8":"Se puede ver que los puntos est\u00e1n divididos en dos conjuntos. Uno de color claro y el otro de color oscuro. \u00bfC\u00f3mo podemos ense\u00f1arle a la computadora que queremos que aprenda que se dividan los puntos de esa manera?\n\nEn esta ocasi\u00f3n, usaremos la clase Sequential de la biblioteca Keras, ya que es uno de los modelos m\u00e1s sencillos que pueden encontrarse y que sirve perfectamente para nuestro conjunto de datos. Tambi\u00e9n, dado que necesitamos que nuestro modelo tenga capas entre cada neurona artificial, usaremos Dense de la misma biblioteca.","da2d0e6f":"### Pruebas del modelo\n\nAhora que hemos creado el modelo, debemos probar que los resultados sean correctos. Tomamos la informaci\u00f3n del set de pruebas y lo comparamos con los resultados obtenidos.\n\n#### Evaluaci\u00f3n\n\nEste comando nos permite conocer si nuestro modelo propuesto es adecuado. Por los resultados que arroja, podemos decir que lo es. Sin embargo, puede haber ocasiones en que necesitemos resultados con mayor precisi\u00f3n o mayor rapidez al momento de realizar el entrenamiento. Todo depende de las circunstancias.","b46e594e":"Para revisar un primer ejemplo, deseamos entrenar un modelo que nos permita clasificar los puntos de una gr\u00e1fica. Ya tenemos los datos cargados directamente en Kaggle por medio de un archivo csv que contiene todo lo que necesitamos para trabajar.\n\nPrimero, revisamos sobre qu\u00e9 datos estamos trabajando.","3c9e0c8a":"### Creaci\u00f3n del modelo\n\n#### Objetivo\n\nNosotros deseamos generar un modelo de aprendizaje autom\u00e1tico que nos genere un modelo que, al enviarle una imagen de ropa, nos diga de qu\u00e9 tipo es. Es decir, que nos permita clasificarla.","50c45118":"# Introducci\u00f3n a redes neuronales con TensorFlow\n\nPrimero, antes de comenzar a hablar propiamente de redes neuronales, es importante ver algunas definiciones para aclarar conceptos.\n\n## Machine Learning \u2014 Aprendizaje autom\u00e1tico\n\nAl escuchar las palabras \u2018Machine Learning\u2019, muchas personas se imaginan un robot aprendiendo a hablar o interactuar con personas. Pareciera un concepto del futuro, pero es algo que ya est\u00e1 muy presente en nuestra vida diaria; m\u00e1s de lo que imaginamos.\n\n### \u00bfQu\u00e9 significa que una computadora aprenda algo?\n\nEs importante establecer un l\u00edmite. Si yo descargo un documento, \u00bfmi computadora ya conoce el contenido de dicho archivo? Si descargo una pel\u00edcula, \u00bfmi computadora ya se habr\u00e1 aprendido los di\u00e1logos? No realmente, ya que existen distintas t\u00e9cnicas que nos permiten programar las computadoras para que aprendan y respondan a distintos est\u00edmulos que deseamos que reconozcan.\n\nAhora, \u00bfcu\u00e1l es el primer ejemplo que se volvi\u00f3 dominante y muy presente en la vida de cualquier persona que utiliza una computadora? En los noventa, el uso de filtros spam se volvi\u00f3 muy importante en el correo electr\u00f3nico. Cada vez que marcas un mensaje como \u2018no deseado\u2019, el cliente de correo electr\u00f3nico aprende de esta selecci\u00f3n y la pr\u00f3xima vez que te llegue un correo del mismo destinatario o con contenido similar, lo marcar\u00e1 nuevamente como spam.\n\n**El aprendizaje autom\u00e1tico es la ciencia y arte de programar computadoras para que aprenda de datos que est\u00e9n a su alcance.** Es decir, permite que las computadoras aprendan a actuar y producir resultados sin necesidad de que se les programe en dicha tarea de manera expl\u00edcita.\n\n### \u00bfC\u00f3mo aprende una computadora?\n\nB\u00e1sicamente, se necesita un conjunto de datos que sirvan como ejemplo. De esta manera, le estamos ense\u00f1ando a la computadora a responder a los distintos casos a los que se enfrentar\u00e1 en el futuro. A esto se le llama un conjunto de entrenamiento\u2014*training set* en ingl\u00e9s. Cada ejemplo que se encuentra en los datos de entrenamiento, se le conoce como instancia o muestra de entrenamiento; en ingl\u00e9s, *training instance* o *sample*.\n\n### Tipos de aprendizaje\n\nLas siguientes clasificaciones pueden usarse para describir un sistema que utilice aprendizaje autom\u00e1tico, ya que no son excluyentes y algunas aplicaciones pueden cumplir con m\u00e1s de una caracter\u00edstica a la vez. Finalmente, lo m\u00e1s importante es que la computadora entregue los resultados esperados de la manera m\u00e1s eficiente y precisa posible.\n\n- Si aprenden bajo supervisi\u00f3n\n    - Supervisados\u2014*supervised*\n    - No supervisados\u2014*unsupervised*\n    - Semi-supervisados\u2014*semisupervised*\n    - Por refuerzo\u2014*Reinforcemente Learning*\n- Si aprenden por incrementos y de manera constante\n    - En l\u00ednea\u2014*online*\n    - Por lotes\u2014*batch learning*\n- Por modelos de patrones o datos conocidos\n    - Por instancia\u2014*instance-based*\n    - Por modelado\u2014*model-based*\n\n## Redes neuronales\n\nEn 1943, Warren McCulloch y Walter Pitts propusieron un modelo basado en la biolog\u00eda de las neuronas. Su modelo generaba un concepto abstracto de lo que ocurre en nuestro sistema nervioso y llegaron a que se pod\u00eda tener una neurona artificial que recibiera uno o m\u00e1s entradas binarias y produjera una salida del mismo tipo. As\u00ed, demostraron que era posible proponer una simple red de neuronas para resolver cualquier proposici\u00f3n l\u00f3gica que se deseara. En la siguiente imagen, del libro de Aur\u00e9lien G\u00e9rone, se puede observar una serie de ejemplos de c\u00f3mo se puede utilizar esta idea para resolver simples problemas l\u00f3gicos:\n\n![Ejemplos%20ANN%20Ge%CC%81ron.png](attachment:Ejemplos%20ANN%20Ge%CC%81ron.png)\n\n- En el primer ejemplo, la neurona C es activada solamente cuando A est\u00e1 activada, a pesar de que C reciba dos veces el valor de A.\n- C se activa cuando A y B est\u00e1n activas. Por lo tanto, estamos mostrando la operaci\u00f3n `AND`.\n- C se enciende cuando A o B est\u00e9n activas\u2014`OR`.\n- C se activa cuando A lo est\u00e9 y B no lo est\u00e9. Este ejemplo es un poco m\u00e1s complejo, ya que la neurona B est\u00e1 realizando m\u00e1s de una operaci\u00f3n.\n\nLas redes neuronales son un tipo de aprendizaje autom\u00e1tico, generalmente de tipo supervisado. Algunas veces se puede contar con implementaciones no supervisadas\u2014*autoencoder* o m\u00e1quinas de Boltzmann\u2014y semisupervisadas\u2014redes de creencia profunda.\n\n### Perceptr\u00f3n\n\nEn 1957, Frank Rosenblatt introdujo un concepto nuevo que volv\u00eda mucho m\u00e1s poderosas a las redes neuronales artificiales. Su idea ahora permit\u00eda introducir valores distintos de 0 y 1; por supuesto, tambi\u00e9n las salidas ya pod\u00edan ser de cualquier valor num\u00e9rico. Es decir, con el perceptr\u00f3n, una red neuronal artificial no va a estar limitada a trabajar con valores \u00fanicamente binarios.\n\nLa idea general es que la entrada va a ser un vector conformado por la suma ponderada, seg\u00fan el peso que se le haya asignado, de todas las entradas de la neurona artificial en cuesti\u00f3n. Despu\u00e9s, a estas entradas se les aplica una funci\u00f3n y producimos una salida num\u00e9rica. Una de las funciones m\u00e1s utilizadas y comunes en este tipo de redes neuronales artificiales, es la funci\u00f3n escal\u00f3n. Esto se muestra en la siguiente imagen:\n\n![Perceptro%CC%81n.png](attachment:Perceptro%CC%81n.png)\n\nSiguiendo la idea de las redes neuronales en la biolog\u00eda, es posible tambi\u00e9n conectar m\u00faltiples perceptrones para formar redes m\u00e1s poderosas y que tengan una mayor profundidad.\n\n**\u00bfPara qu\u00e9 nos sirve todo esto?** En un principio, nos permite clasificar conjuntos de datos y esto, a su vez, nos abre la posibilidad de que desarrollemos herramientas mucho m\u00e1s poderosas que le permitan a las computadoras \u2018aprender\u2019. Esto se puede ver en el primer ejemplo del correo no deseado, reconocimiento de OCR (*Optical Character Recognition*)\u2014el que se usa en las aplicaciones de escaneo de documentos en los tel\u00e9fonos\u2014, lenguaje, asistentes virtuales como Alexa, Cortana o Siri y muchos otros campos m\u00e1s.","192ef5af":"### Introducci\u00f3n a la base de datos MNIST\n\n[MNIST](http:\/\/yann.lecun.com\/exdb\/mnist\/) es una base de datos de d\u00edgitos manuscritos ya preprocesados y preparados para utilizarse en aplicaciones de aprendizaje autom\u00e1tico. Contiene 60,000 ejemplos y 10,000 elementos de entrenamiento. Es muy utilizada para el estudio de redes neuronales y permite practicar sin tener que preprocesar los datos de entrada a utilizar.\n\n> Lo m\u00e1s complicado de trabajar con aprendizaje autom\u00e1tico e inteligencia artificial es preparar los datos para introducirlos a nuestro modelo. En aplicaciones reales, los datos no estar\u00e1n completamente preparados.\n\nTambi\u00e9n, existe una variante conocida como Fashion MNIST que contiene im\u00e1genes de diversos art\u00edculo de ropa. Es \u00fatil utilizarla ya que puede ayudar a entender mejor lo que estamos clasificando en nuestros ejemplos.\n\nA continuaci\u00f3n, nuestro primer paso es importar los datos y convertirlos a un formato f\u00e1cil de utilizar con TensorFlow:","b292556c":"### 3 capas\n\nFinalmente, terminaremos a\u00f1adiendo una \u00faltima capa para ver si podemos mejorar nuestros resultados. A\u00f1adir capas llega a funcionar para clasificar mejor los datos pero llega un momento que ya no genera ning\u00fan cambio o puede ser contraproducente. En este caso, observamos que ya se aprecia un sobreajuste de los datos. El rendimiento en algunas sesiones de entrenamiento puede llegar a ser peor que con la red neuronal de 2 capas.","78324c7d":"\u00bfC\u00f3mo sabemos si el modelo est\u00e1 bien? Dado que no tenemos un set de datos de prueba en este momento, podemos generar puntos aleatorios en una gr\u00e1fica y ver c\u00f3mo los clasifica. Si us\u00e1ramos los mismos puntos del entrenamiento, la prueba no tendr\u00eda sentido ya que estar\u00edamos usando la misma informaci\u00f3n que la red neuronal ya conoce."}}