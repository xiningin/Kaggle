{"cell_type":{"2bbb5678":"code","6e7cd300":"code","54a43b5a":"code","74d41da8":"code","a727bc4e":"code","c719e15e":"code","cee4315e":"code","70b6f54c":"code","e4a55a67":"code","e567b569":"code","577d5f3a":"code","d7372d1f":"code","64880636":"code","35c2414b":"code","f0033add":"code","4dcbd9c7":"markdown","8a988925":"markdown","efc648ac":"markdown","49561bdf":"markdown","8d0426b5":"markdown","fa362e2f":"markdown","8bd16170":"markdown"},"source":{"2bbb5678":"import os\nimport sys\nimport random\nimport warnings\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom tqdm import tqdm_notebook, tnrange\n\nfrom scipy import signal\n\nimport cv2\nfrom PIL import Image\nimport pdb\nfrom tqdm import tqdm\nimport seaborn as sns\nimport os \nfrom glob import glob\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","6e7cd300":"INPUT_PATH = '..\/input'\nDATA_PATH = INPUT_PATH\nTRAIN_DATA = os.path.join(DATA_PATH, \"train\")\nTRAIN_MASKS_DATA = os.path.join(DATA_PATH, \"train\/masks\")\nTEST_DATA = os.path.join(DATA_PATH, \"test\")\ndf = pd.read_csv(DATA_PATH+'\/train_ship_segmentations.csv')\npath_train = '..\/input\/train\/'\npath_test = '..\/input\/test\/'\ntrain_ids = df.ImageId.values\ndf = df.set_index('ImageId')","54a43b5a":"images_with_no_ship = df.index[df.EncodedPixels.isnull()==True]\nprint ('Found ' + str(len(images_with_no_ship)) + ' no-ship images') ","74d41da8":"# \n# Number of distinct classes \nNUM_CLASSES = 50\n#\n# In order to reduce computation time, downsample train images. \n# Sure we loose some pixel information this way.....\nIMG_SIZE = 32","a727bc4e":"from sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import KMeans\n\ndef get_filename(image_id, image_type):\n    check_dir = False\n    if \"Train\" == image_type:\n        data_path = TRAIN_DATA\n    elif \"mask\" in image_type:\n        data_path = TRAIN_MASKS_DATA\n    elif \"Test\" in image_type:\n        data_path = TEST_DATA\n    else:\n        raise Exception(\"Image type '%s' is not recognized\" % image_type)\n\n    if check_dir and not os.path.exists(data_path):\n        os.makedirs(data_path)\n\n    return os.path.join(data_path, \"{}\".format(image_id))\n\n\ndef get_image_data_opencv(image_id, image_type, **kwargs):\n    fname = get_filename(image_id, image_type)\n    img = cv2.imread(fname)\n    assert img is not None, \"Failed to read image : %s, %s\" % (image_id, image_type)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))\n    return img\n\ndef get_domimant_colors(img, top_colors=2):\n    img_l = img.reshape((img.shape[0] * img.shape[1], img.shape[2]))\n    clt = KMeans(n_clusters = top_colors)\n    clt.fit(img_l)\n    # grab the number of different clusters and create a histogram\n    # based on the number of pixels assigned to each cluster\n    numLabels = np.arange(0, len(np.unique(clt.labels_)) + 1)\n    (hist, _) = np.histogram(clt.labels_, bins = numLabels)\n    # normalize the histogram, such that it sums to one\n    hist = hist.astype(\"float\")\n    hist \/= hist.sum()\n    return clt.cluster_centers_, hist","c719e15e":"details = []\nfor imfile in tqdm(images_with_no_ship):\n    image_hsv = get_image_data_opencv(imfile, \"Train\")\n    height, width, l = image_hsv.shape\n    dominant_colors_hsv, dominant_rates_hsv = get_domimant_colors(image_hsv, top_colors=1)\n    dominant_colors_hsv = dominant_colors_hsv.reshape(1, dominant_colors_hsv.shape[0] * dominant_colors_hsv.shape[1])\n    info = (imfile, width, height, dominant_colors_hsv.squeeze())\n    details.append(info)","cee4315e":"cols  = ['image_id', 'image_width', 'image_height', 'hsv_dominant']\ntrainPD = pd.DataFrame(details, columns=cols)\nX = (pd.DataFrame(trainPD['hsv_dominant'].values.tolist())).as_matrix()\nkmeans = KMeans(n_clusters=50).fit(X)\nclusters = kmeans.predict(X)\ntrainPD['hsv_cluster'] = clusters\ntrainPD.head()\n","70b6f54c":"## View partitioning counts","e4a55a67":"hist = trainPD.groupby('hsv_cluster')['image_id'].count()\nhist","e567b569":"plt.figure(figsize=(12, 6))\nplt.title('#images per partition')\nplt.bar(np.arange(50), hist.values)\nplt.show()","577d5f3a":"def plot_images(images, images_rows, images_cols):\n    f, axarr = plt.subplots(images_rows,images_cols,figsize=(16,images_rows*2))\n    for row in range(images_rows):\n        for col in range(images_cols):\n            image_id = images[row*images_cols + col]\n            image = cv2.imread(get_filename(image_id, 'Train'))\n            height, width, l = image.shape\n            ax = axarr[row,col]\n            ax.axis('off')\n            ax.set_title(\"%dx%d\"%(width, height))\n            ax.imshow(image)","d7372d1f":"plot_images(trainPD[trainPD['hsv_cluster'] == 0]['image_id'].values, 4, 4)\n","64880636":"plot_images(trainPD[trainPD['hsv_cluster'] == 1]['image_id'].values, 4, 4)\n","35c2414b":"plot_images(trainPD[trainPD['hsv_cluster'] == 30]['image_id'].values, 4, 4)\n","f0033add":"trainPD.to_csv('noship_clusters.csv', index = False)\n","4dcbd9c7":" ## Apply kmeans on HSV dominant color","8a988925":"## Save cluster information ","efc648ac":"## Some utility definitions and functions","49561bdf":"As already noted in this competition  we are going to give a struggle *in  the open sea*. About `75000` images contain no ship at all and succesfully sampling from those may benefit any model. However, stratification using no-ship images would be difficult. In the case of images with ships we can either stratify using\n* the number of ships in the image\n* the area of ship pixels in the mask\n\nIn this notebook, I attempt to group no ship images, based on *color information* using bits and pieces from the following two kernels.\n* [https:\/\/www.kaggle.com\/mpware\/stage1-eda-microscope-image-types-clustering](http:\/\/)  \n* [https:\/\/www.kaggle.com\/meaninglesslives\/airbus-ship-detection-data-visualization](http:\/\/)\n\nFor  every image the dominant color is extracted by applying kmeans on pixel intesities. Then all `75000` are partitioned using this dominant HSV color information into `NUM_CLASSES` classes.  As a result of this analysis we could group no-ship images in a arbitrary number of classes, and sample from those  at random. ","8d0426b5":"## Some arbitrary plots for clusters, 0, 1 and 30....","fa362e2f":"## Find images containing no ships ","8bd16170":"<h2> Setting paths"}}