{"cell_type":{"0378cbfa":"code","7ec87e6b":"code","db6f0bf1":"code","1f75b8b5":"code","50ebbc31":"code","e6295091":"code","4b5f8fca":"code","a3d3e7b2":"code","0bee71d4":"code","44f9ba48":"code","241311d0":"code","8c56b46b":"markdown","41f0d10b":"markdown","a07634f2":"markdown"},"source":{"0378cbfa":"#HM Attaullah\n","7ec87e6b":"import os\nfrom collections import deque, namedtuple\n\nINPUT_FILE_PATH = '..\/input\/hashcode-2021-oqr-extension\/hashcode.in'\nOUTPUT_FILE_PATH = '\/kaggle\/input\/sample-submission-with-traffic-signal-control\/' \\\n                   'submission.csv'","db6f0bf1":"class MutableValue:\n    def __init__(self, val=None):\n        self.val = val","1f75b8b5":"# working on model","50ebbc31":"Street = namedtuple('Street', [\n    'id',  # The index of the street\n    'start',  # The Intersection object at the start of the street\n    'end',  # The Intersection object at the end of the street\n    'name',  # A str\n    'duration',  # The length of the street in seconds\n    'driving_cars',  # A dict mapping car ids (int) to remaining seconds\n    'waiting_cars',  # A deque of car ids (int)\n    'arrival_times',  # A dict mapping car ids (int) to their arrival times\n    'departure_times'  # A dict mapping car ids (int) to their departure times\n    # You can compute the seconds that a car was waiting at the end of the street\n    # by subtracting the arrival time from the departure time.\n])\n\nIntersection = namedtuple('Intersection', [\n    'id',  # The index of the intersection\n    'incomings',  # A deque of incoming Street objects\n    'outgoings',  # A deque of outgoing Street objects\n\n    'green_street',\n\n    'num_waiting_cars',\n\n    'schedule_duration',\n\n    'green_street_per_t_mod',\n\n    'needs_updates'\n])\n\n# We only use street indices and intersection indices here to allow\n# fast deep-copies of a schedule for testing out and reverting modifications.\nSchedule = namedtuple('Schedule', [\n    'i_intersection',  # The index of the intersection\n    'order',  # A list of street ids\n    'green_times'  # A dict mapping street ids to green times (seconds)\n])","e6295091":"def read_input(input_file_path):\n    with open(input_file_path) as f:\n        lines = deque(f.readlines())\n        \n    # Parse the first line\n    total_duration, num_intersections, num_streets, \\\n    num_cars, bonus_points = map(int, lines.popleft().split())\n\n    # Create empty intersections\n    intersections = tuple(Intersection(id=i,\n                                       incomings=deque(),\n                                       outgoings=deque(),\n                                       green_street=MutableValue(),\n                                       num_waiting_cars=MutableValue(0),\n                                       green_street_per_t_mod=[],\n                                       schedule_duration=MutableValue(),\n                                       needs_updates=MutableValue(False))\n                          for i in range(num_intersections))\n\n    # Parse the streets\n    streets = []\n    name_to_street = {}\n    for i_street in range(num_streets):\n        line = lines.popleft().split()\n        start, end = map(int, line[:2])\n        name = line[2]\n        duration = int(line[3])\n        street = Street(id=i_street,\n                        start=intersections[start],\n                        end=intersections[end],\n                        name=name,\n                        duration=duration,\n                        driving_cars={},\n                        waiting_cars=deque(),\n                        arrival_times={},\n                        departure_times={})\n        name_to_street[name] = street\n        intersections[start].outgoings.append(street)\n        intersections[end].incomings.append(street)\n        streets.append(street)\n\n    # Parse the paths\n    paths = []\n    for i_car in range(num_cars):\n        line = lines.popleft().split()\n        path_length = int(line[0])\n        path = line[1:]\n        assert len(path) == path_length\n        path = deque(name_to_street[name] for name in path)\n        paths.append(path)\n\n    return total_duration, bonus_points, intersections, \\\n           streets, name_to_street, paths","4b5f8fca":"total_duration, bonus_points, intersections, \\\nstreets, name_to_i_street, paths = read_input(INPUT_FILE_PATH)","a3d3e7b2":"def read_answer(output_file_path, name_to_street):\n    with open(output_file_path) as f:\n        lines = deque(f.readlines())\n    num_schedules = int(lines.popleft())\n    schedules = []\n    for i_schedule in range(num_schedules):\n        i_intersection = int(lines.popleft())\n        num_incomings = int(lines.popleft())\n        order = []\n        green_times = {}\n        for i_incoming in range(num_incomings):\n            street_name, green_time = lines.popleft().split()\n            green_time = int(green_time)\n            street = name_to_street[street_name]\n            order.append(street.id)\n            green_times[street.id] = green_time\n\n        schedule = Schedule(i_intersection=i_intersection,\n                            order=order,\n                            green_times=green_times)\n        schedules.append(schedule)\n    return schedules","0bee71d4":"# schedules = read_answer(OUTPUT_FILE_PATH, name_to_i_street)\n#https:\/\/www.kaggle.com\/batzner\/simulation-and-grading-in-python","44f9ba48":"def reinit(streets, intersections):\n    # Reinitialize mutable data structures\n    for street in streets:\n        street.driving_cars.clear()\n        street.waiting_cars.clear()\n        street.arrival_times.clear()\n        street.departure_times.clear()\n\n    for intersection in intersections:\n        intersection.green_street.val = None\n        intersection.num_waiting_cars.val = 0\n        intersection.green_street_per_t_mod.clear()\n        intersection.schedule_duration.val = None\n        intersection.needs_updates.val = False\n\ndef grade(schedules, streets, intersections, paths, total_duration, bonus_points):\n    reinit(streets, intersections)\n    \n    # We will consume the deques in the paths list. Save a copy of them\n    # for later to reset the paths after the simulation.\n    paths_copy = [path.copy() for path in paths]\n\n    # Iterate through the schedules and initialize the intersections.\n    intersection_ids_with_schedules = set()\n    for schedule in schedules:\n        intersection = intersections[schedule.i_intersection]\n        intersection_ids_with_schedules.add(intersection.id)\n        first_street = streets[schedule.order[0]]\n        intersection.green_street.val = first_street\n        intersection.needs_updates.val = len(schedule.order) > 1\n        schedule_duration = 0\n        green_street_per_t_mod = intersection.green_street_per_t_mod\n        for street_id in schedule.order:\n            green_time = schedule.green_times[street_id]\n            for _ in range(green_time):\n                green_street_per_t_mod.append(streets[street_id])\n            schedule_duration += green_time\n        intersection.schedule_duration.val = schedule_duration\n\n    # intersection_ids_with_waiting_cars is restricted to intersections \n    # with schedules\n    intersection_ids_with_waiting_cars = set()\n    for i_car, path in enumerate(paths):\n        street = path.popleft()\n        street.waiting_cars.append(i_car)\n        if street.end.id in intersection_ids_with_schedules:\n            intersection_ids_with_waiting_cars.add(street.end.id)\n        street.end.num_waiting_cars.val += 1\n\n    street_ids_with_driving_cars = set()\n    score = 0\n    \n    # Main simulation loop\n    for t in range(total_duration):\n        \n        # Drive across intersections\n        # Store the ids of intersections that don't have waiting cars after this.\n        intersection_ids_to_remove = set()\n        for i_intersection in intersection_ids_with_waiting_cars:\n            intersection = intersections[i_intersection]\n\n            if intersection.needs_updates.val:\n                # Update the green street\n                t_mod = t % intersection.schedule_duration.val\n                intersection.green_street.val = intersection.green_street_per_t_mod[t_mod]\n\n            green_street = intersection.green_street.val\n            waiting_cars = green_street.waiting_cars\n            if len(waiting_cars) > 0:\n                # Drive across the intersection\n                waiting_car = waiting_cars.popleft()\n                green_street.departure_times[waiting_car] = t\n                next_street = paths[waiting_car].popleft()\n                next_street.driving_cars[waiting_car] = next_street.duration\n                street_ids_with_driving_cars.add(next_street.id)\n\n                intersection.num_waiting_cars.val -= 1\n                if intersection.num_waiting_cars.val == 0:\n                    intersection_ids_to_remove.add(i_intersection)\n\n        intersection_ids_with_waiting_cars.difference_update(intersection_ids_to_remove)\n\n        # Drive across roads\n        # Store the ids of streets that don't have driving cars after this.\n        street_ids_to_remove = set()\n        for i_street in street_ids_with_driving_cars:\n            street = streets[i_street]\n            driving_cars = street.driving_cars\n            for car in list(driving_cars):\n                # Update the \"time to live\" of this car, i.e. the remaining\n                # driving seconds.\n                ttl = driving_cars[car]\n                ttl -= 1\n                if ttl < 0:\n                    raise ValueError\n                elif ttl == 0:\n                    # Reached the end of the street\n                    del driving_cars[car]\n                    if len(paths[car]) == 0:\n                        # FINISH\n                        score += bonus_points\n                        score += total_duration - t - 1\n                    else:\n                        street.waiting_cars.append(car)\n                        street.end.num_waiting_cars.val += 1\n                        street.arrival_times[car] = t + 1\n                        intersection_id = street.end.id\n                        if intersection_id in intersection_ids_with_schedules:\n                            intersection_ids_with_waiting_cars.add(intersection_id)\n                else:\n                    # The car is still driving on the street\n                    driving_cars[car] = ttl\n            if len(driving_cars) == 0:\n                street_ids_to_remove.add(i_street)\n        street_ids_with_driving_cars.difference_update(street_ids_to_remove)\n\n    # We are done with the simulation. Restore the paths.\n    for i_path in range(len(paths)):\n        paths[i_path] = paths_copy[i_path]\n    return score","241311d0":"score = grade(schedules, streets, intersections, paths, total_duration, bonus_points)","8c56b46b":"train_vis.py","41f0d10b":"pg_control.py","a07634f2":"vis_env.py"}}