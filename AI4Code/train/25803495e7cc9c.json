{"cell_type":{"eddc4764":"code","e6c76807":"code","f627cf37":"code","0f808ac9":"code","0f0704a7":"code","e310babf":"code","caf09c8c":"code","acf44ffa":"code","348fc7d7":"code","fb7b77a7":"code","f2bb1c9c":"code","75f229a9":"code","393261fd":"code","332f97de":"code","ee749b1d":"code","8336d6b2":"code","6ccdcde0":"code","34a581ce":"code","04278094":"code","e90d3109":"code","959fe5d3":"code","6466d9fe":"code","35e9331e":"code","760a588f":"code","453f4851":"code","55545caf":"code","fe94ce84":"code","cdddf84f":"code","aa1d0439":"code","c9020e89":"code","d9c3d731":"code","03d08d3f":"code","dfadfc94":"code","b5fe1cc4":"code","217cea45":"code","95bd6573":"code","9840a799":"code","740886d3":"code","5621aa9c":"code","04e3fb8a":"code","85578e32":"code","92a286e3":"code","21f5a9b4":"code","e31b8bb4":"code","9a516f38":"code","56a68162":"code","6ce53534":"code","62b90433":"code","9319dd13":"code","2ae02b37":"code","729eafa1":"code","caee7718":"code","83d46ffe":"code","27316d0c":"code","4b5f93f5":"code","e48d66a8":"markdown","fb9e7f94":"markdown","6e767706":"markdown","23838021":"markdown","503834e7":"markdown","17ae1e65":"markdown","6c20875d":"markdown","5533073b":"markdown","ed3df038":"markdown","2f7d81ef":"markdown","cb618765":"markdown","cc5a44a1":"markdown","41900c09":"markdown","9ef3b086":"markdown","02aedee0":"markdown","1af9bee8":"markdown","c00b18a0":"markdown","bf8f5ebe":"markdown","a3f0cf3d":"markdown","c63d72a8":"markdown","b7e6bf58":"markdown","aeee3d9e":"markdown","197f65e1":"markdown","2c642bf5":"markdown","215010a0":"markdown","af79af15":"markdown","bae2a691":"markdown","74be34a2":"markdown","4cca98fe":"markdown","0c0befe4":"markdown","b3c8a76e":"markdown","9bc46c73":"markdown","b4d7c4ae":"markdown","da9b3154":"markdown","f32b1fa7":"markdown","b9aece73":"markdown","13494a27":"markdown","85bb2f10":"markdown","dbc533d0":"markdown","55fca09d":"markdown"},"source":{"eddc4764":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Model libraries\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.ensemble import AdaBoostClassifier\nfrom sklearn.svm import SVC\nimport xgboost as xgb\nfrom imblearn.ensemble import BalancedBaggingClassifier\nfrom sklearn.tree import DecisionTreeClassifier\n\n\n#Other Libraries\nfrom sklearn.model_selection import cross_val_score, StratifiedKFold, train_test_split,RandomizedSearchCV\nfrom sklearn.metrics import recall_score,precision_score,confusion_matrix\nimport scipy.stats as stats","e6c76807":"data = pd.read_csv('\/kaggle\/input\/novartis-data\/Train.csv')\ndata_test = pd.read_csv('\/kaggle\/input\/novartis-data\/Test.csv')\n\n\nprint('Shape of the data:',data.shape)\ndata.head()","f627cf37":"data.info() #getting more information on the dtype","0f808ac9":"data.describe()  # To check on the statistics","0f0704a7":"data.isnull().sum() #checking for missing values in data","e310babf":"data.columns #columns of the data","caf09c8c":"print(data['MULTIPLE_OFFENSE'].value_counts())\nplt.figure(figsize=(5,3))\nsns.countplot(data['MULTIPLE_OFFENSE'])\nplt.show()","acf44ffa":"X = data.drop('MULTIPLE_OFFENSE', axis=1)\ny = data['MULTIPLE_OFFENSE']","348fc7d7":"X_train,X_test,y_train,y_test = train_test_split(X,y,test_size =0.25, random_state = 42, stratify=y)","fb7b77a7":"print('y_train:\\n',y_train.value_counts(normalize = True))\nprint('y_test:\\n',y_test.value_counts(normalize = True))","f2bb1c9c":"#function to create histogram, Q-Q Plot and boxplot\n\ndef diagnostic_plots(df,variable):\n    \n    #define figure size\n    plt.figure(figsize =(16,4))\n    \n    #histogram\n    plt.subplot(1,3,1)\n    sns.distplot(df[variable], bins = 30, kde = False)\n    plt.title('Histogram')\n    \n    #Q-Q plot\n    plt.subplot(1,3,2)\n    stats.probplot(df[variable], dist = \"norm\", plot = plt)\n    plt.ylabel('RM quantiles')\n    \n    # box plot\n    plt.subplot(1,3,3)\n    sns.boxplot(y=df[variable])\n    plt.title('Boxplot')\n    \n    plt.show()","75f229a9":"diagnostic_plots(data,'X_2')","393261fd":"diagnostic_plots(data,'X_3')","332f97de":"diagnostic_plots(data,'X_6')","ee749b1d":"diagnostic_plots(data,'X_7')","8336d6b2":"diagnostic_plots(data,'X_8')","6ccdcde0":"diagnostic_plots(data,'X_10')","34a581ce":"diagnostic_plots(data,'X_11')","04278094":"diagnostic_plots(data.dropna(),'X_12')","e90d3109":"diagnostic_plots(data,'X_13')","959fe5d3":"diagnostic_plots(data,'X_14')","6466d9fe":"diagnostic_plots(data,'X_15')","35e9331e":"f, axes = plt.subplots(ncols=4, figsize=(20,4))\nsns.countplot(data['X_1'],ax=axes[0])\nsns.countplot(data['X_4'],ax=axes[1])\nsns.countplot(data['X_5'],ax=axes[2])\nsns.countplot(data['X_9'],ax=axes[3])\nplt.show()","760a588f":"### We need to install the libraries required for the preprocesing steps\n!pip install -U imbalanced-learn\n!pip install feature_engine","453f4851":"# Pipelines\nfrom sklearn.pipeline import Pipeline\nfrom imblearn.pipeline import make_pipeline as imbalanced_make_pipeline\nfrom imblearn.over_sampling import SMOTE\nfrom imblearn.pipeline import Pipeline as pl1\n\n#preprocessing methods\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder, RobustScaler\n\n#preprocessing methods using feature engine\nfrom feature_engine import categorical_encoders as ce\nfrom feature_engine.outlier_removers import Winsorizer","55545caf":"# Segregating the data into numerical, categorical and features with outliers\nnumerical_features = ['X_2', 'X_3', 'X_6','X_7', 'X_8', 'X_10', 'X_11','X_12', 'X_13', 'X_14','X_15']\ncategorical_features = ['X_1', 'X_4', 'X_5','X_9']\noutliers_data = ['X_6', 'X_7','X_8','X_10','X_11','X_12','X_13','X_15']","fe94ce84":"X_train['X_12'] = X_train['X_12'].fillna(X_train['X_12'].median())\nX_test['X_12'] = X_test['X_12'].fillna(X_test['X_12'].median())","cdddf84f":"categorical_features = ['X_1', 'X_4', 'X_5','X_9']\nX_train[categorical_features] = X_train[categorical_features].astype('object')\nX_test[categorical_features] = X_test[categorical_features].astype('object')","aa1d0439":"outlier_treat =Pipeline(steps = [\n              ('outlier1', Winsorizer(distribution = 'gaussian', tail = 'right',fold = 3, variables = ['X_6', 'X_7','X_8','X_10','X_12'])),\n              ('outlier2', Winsorizer(distribution = 'gaussian', tail = 'left',fold = 3, variables = ['X_11', 'X_13'])),\n              ('outlier3', Winsorizer(distribution = 'gaussian', tail = 'both',fold = 3, variables = ['X_15']))\n                                      ])","c9020e89":"outlier_treat.fit(X_train)","d9c3d731":"X_train = outlier_treat.transform(X_train)","03d08d3f":"# Converting the categorical variables to 'object' for doing the one hot encoding operation\nX_train[categorical_features] = X_train[categorical_features].astype('object')\nX_test[categorical_features] = X_test[categorical_features].astype('object')","dfadfc94":"numeric_transformer = Pipeline(steps = [\n              ('scaler', StandardScaler())\n                     ])\ncategorical_transformer = Pipeline(steps=[\n    ('onehot3',ce.OneHotCategoricalEncoder(top_categories = 3, variables = ['X_9','X_1'] )),\n    ('onehot4',ce.OneHotCategoricalEncoder(top_categories = 4, variables = ['X_5'] )),\n    ('onehot10',ce.OneHotCategoricalEncoder(top_categories = 9, variables = ['X_4'] ))\n])","b5fe1cc4":"from sklearn.compose import ColumnTransformer\npreprocessor = ColumnTransformer(\n    transformers=[\n                 ('drop_columns', 'drop', ['INCIDENT_ID','DATE']), #dropping the columns \n                 ('num', numeric_transformer, numerical_features),\n                 ('cat', categorical_transformer,categorical_features)\n    ])","217cea45":"preprocessor.fit(X_train)","95bd6573":"X_train = preprocessor.transform(X_train)\nX_test = preprocessor.transform(X_test)","9840a799":"# from sklearn.model_selection import RandomizedSearchCV\n# rs = RandomizedSearchCV(xgb_model, {\n#         'scale_pos_weight': [1,2],\n#         'learning_rate'   : [0.05,0.10,0.15,0.20,0.25,0.30],\n#         'min_child_weight': [1,3,5,7],\n#         'gamma'           : [0.0,0.1,0.2,0.3,0.4],\n#         'colsample_bytree': [0.3,0.4,0.5,0.7]\n#     }, \n#     cv=5, \n#     scoring = 'f1',\n#     return_train_score=False, \n#     n_iter=50\n# )\n# rs.fit(X_train, y_train)\n# pd.DataFrame(rs.cv_results_)[['param_scale_pos_weight','param_learning_rate','param_min_child_weight','param_gamma','param_colsample_bytree','mean_test_score']]","740886d3":"xgb_model = xgb.XGBClassifier(scale_pos_weight= 1,min_child_weight=1,learning_rate= 0.35,gamma= 0.3,colsample_bytree= 0.3 )\nxgb_model.fit(X_train, y_train)\ny_pred_xgb = xgb_model.predict(X_test)\n\nscore = recall_score(y_test,y_pred_xgb)\nprint('Recall score :',score)\nconfusion_matrix(y_test,y_pred_xgb, labels = [1,0])","5621aa9c":"#Create an object of the classifier.\nbbc = BalancedBaggingClassifier(base_estimator=DecisionTreeClassifier(),sampling_strategy='auto',\nreplacement=False,random_state=0)\n","04e3fb8a":"from sklearn.metrics import precision_score\nbbc.fit(X_train, y_train)\ny_pred_bbc = bbc.predict(X_test)\n\nscore = recall_score(y_test,y_pred_bbc)\nprecision = precision_score(y_test,y_pred_bbc)\nprint('recall score :',score)\nconfusion_matrix(y_test,y_pred_bbc, labels = [1,0])\n","85578e32":"# from sklearn.model_selection import RandomizedSearchCV\n# fold = StratifiedKFold(n_splits=5, random_state=None, shuffle=False)\n# svm = SVC()\n\n# rs = RandomizedSearchCV(SVC(class_weight = 'balanced'), {\n#         'C': [0.1, 1, 10],\n#         'kernel': ['linear', 'poly', 'rbf'],\n#         'tol' :[0.1,0.001,0.001]\n#     }, \n#     cv=fold, \n#     scoring=\"recall\", \n#     n_iter=5\n# )\n# rs.fit(X_train, y_train)\n# pd.DataFrame(rs.cv_results_)[['param_C','param_kernel','param_tol','mean_test_score']]","92a286e3":"model = SVC(class_weight = 'balanced', C = 0.1 , kernel = 'poly', tol = 0.001)\nmodel.fit(X_train, y_train)\ny_pred_svm = model.predict(X_test)\n\nscore = recall_score(y_pred_svm,y_test)\nprint('recall score',score)\nconfusion_matrix(y_pred_svm,y_test, labels = [1,0])\n","21f5a9b4":"model_rf = RandomForestClassifier(class_weight='balanced_subsample')\nmodel_rf.fit(X_train, y_train)\ny_pred_rf = model_rf.predict(X_test)\n\nscore = recall_score(y_pred_rf,y_test)\nprint(score)\nconfusion_matrix(y_pred_rf,y_test, labels = [1,0])\n","e31b8bb4":"ada_model = AdaBoostClassifier()\nada_model.fit(X_train, y_train)\ny_pred_ada = ada_model.predict(X_test)\n\nscore = recall_score(y_test,y_pred_ada)\nprint('Recall score :', score)\nconfusion_matrix(y_test,y_pred_ada, labels = [1,0])","9a516f38":"data_test.head()","56a68162":"data_test.isnull().sum()","6ce53534":"# Replacing the missing values with the median values\ndata_test['X_12'] = data_test['X_12'].fillna(data_test['X_12'].median())","62b90433":"#Converting the datatype to 'object' for all the categorical features for transformations\ndata_test[categorical_features] = data_test[categorical_features].astype('object')","9319dd13":"# Performing scaling , one hot encoding on the data using sklearn pipelines\ndata_test1 = preprocessor.transform(data_test)","2ae02b37":"#Missing value imputation\nX['X_12'] = X['X_12'].fillna(X['X_12'].median())","729eafa1":"# Outlier treatment\nX = outlier_treat.transform(X)","caee7718":"# Preprocessing \nX = preprocessor.transform(X)","83d46ffe":"xgb_model.fit(X, y)\nprediction_xgb = xgb_model.predict(data_test1)","27316d0c":"output_xgb=pd.DataFrame({\"INCIDENT_ID\":data_test[\"INCIDENT_ID\"],\"MULTIPLE_OFFENSE\":prediction_xgb}) \noutput_xgb.head()","4b5f93f5":"print(output_xgb['MULTIPLE_OFFENSE'].value_counts())\nsns.countplot(output_xgb['MULTIPLE_OFFENSE'])","e48d66a8":"### Creating a column transformer","fb9e7f94":"Best parameters from the randomizedsearchcv\n{'scale_pos_weight': 1,\n 'min_child_weight': 1,\n 'learning_rate': 0.3,\n 'gamma': 0.3,\n 'colsample_bytree': 0.3}\n \n Applying the parameters in the xgb model","6e767706":"### Preprocessing steps that need to be done before fitting the model\n\n- Missing values to be imputed for feature 'X_12'\n- Oulier treatment using capping technique.\n- Creating a pipleine with Standardization using standard scale on continous data & one hot encoding on Cagtegorical data\n- Drop the columns 'INCIDENT_ID' & 'DATE' as not much information is available\n- Fit the data and transform on both X_train & test\nThe data will be ready for using to the model after the above steps","23838021":"### 4. Random Forest With Bootstrap Class Weighting\n\nGiven that each decision tree is constructed from a bootstrap sample (e.g. random selection with replacement), the class distribution in the data sample will be different for each tree.\n\nAs such, it might be interesting to change the class weighting based on the class distribution in each bootstrap sample, instead of the entire training dataset.\n\nThis can be achieved by setting the class_weight argument to the value \u2018balanced_subsample\u2018.","503834e7":"<a id=section2><\/a>\n## Exploring the data ","17ae1e65":"Using the above approaces , I was able to achieve 99.5% on the unseen test data using XGB model with hyperparameter tuning.\n\n### I hope this notebook was useful\n\n## Thank you, kindly Upvote and Happy learning :)","6c20875d":"### Creating pipelines with Standardization on Continous values & One Hot encoding for frequent categories using Feature engine","5533073b":"### Outlier Treatment\nWe are gonna treat the outliers for each individual variable in different ways of which tail to be considered for the capping method.\nSo in the below code we have created a pipeline","ed3df038":"### Testing the unseen data for XGB Classifier","2f7d81ef":"<a id=section6><\/a>\n## Test for unseen data & output file \n\n#### Now applying the model on the hackathon test data","cb618765":"- [Import Packages](#section1)<br>\n- [Exploring the data ](#section2)<br>\n- [Visualizing the data](#section3)<br>\n- [Preprocessing](#section4)<br>\n- [Model Selection](#section5)<br>\n- [Test for unseen data & output file ](#section6)<br>","cc5a44a1":"Now our data is ready for final prediction & the model we will be using is XBoost Classifier & ADA boost classifier","41900c09":"### Conclusion :\nConsidering the recall score , XGB Classifier is having the best recall score after hyper tuning the parameters. So we will use this model for our prediction.","9ef3b086":"### Splitting the data into test & train before we do any preprocessing or implementing sampling techniques","02aedee0":"### Transforming the data on the Train & test","1af9bee8":"### Missing data imputation\nAs the X_12 feature data is skewed, the missing data can be replaced using median.","c00b18a0":"### What Is Data Imbalance?\n\nData imbalance usually reflects an unequal distribution of classes within a dataset.\n\nAs you can see from the above figure most of the mails are suspicious, if we dont fix the probelm the model will be biased. \n\nDealing with Imbalanced Datsets:\nThere are many ways of dealing with imbalanced datasets:\n- __Undersampling :__\nUndersampling is the process where you randomly\ndelete some of the observations from the majority class in order to match the numbers\nwith the minority class.\n- __Oversampling :__ \nIt is the process of generating synthetic data that tries to randomly generate a sample of the attributes from observations in the minority class.\n\nThe best kaggle kernal which I refer on the above topics :\nhttps:\/\/www.kaggle.com\/janiobachmann\/credit-fraud-dealing-with-imbalanced-datasets\n\nBut in this problem(kernal) I didnot use undersampling or oversampling techniques.\nI have applied on the Machine learning algorithms like XGBOOST, Ensembling methods , Balanced Bagging classifier with the required hyperparmaters which deals with imbalance data and helped achieved me a great score of __99.5 %__ on test score. We are gonna look into more detail while doing the model Building","bf8f5ebe":"After the randomized searchcv the best params are :\n__C = 0.1 , kernel = 'poly', tol = 0.001__","a3f0cf3d":"From the above histogram ,Probability plot and Boxplots for continous variables in the data, we can see that there are many outliers present in the features __X_6,X_7,X_8,X_10,X_11,X_12,X_13,X_15__.\n\nOne way of dealing with outliers is to remove them from the data but this will cause information loss so we will use a technique called __Capping or Censoring capping__ in this kernal. \n\n__Capping or Censoring capping__ : means capping the maximum and \/or minimum of a distribution at an arbitrary value. In other words, values bigger or smaller than the arbitrarily determined ones are __censored__.\n\nThis can be done using by a simple code and on each of the feature but in this notebook we gonna use __Winsorizer__ method from the __feature engine__ which deals with outliers using Capping method","c63d72a8":"## Visualizing the target variable","b7e6bf58":"#### Transforming the test data same as the operations done on the train data","aeee3d9e":"This kernal(notebook) is an attempt to showcase the work done for Novartis hackathon by Hackerearth and on the topic of Imbalanced dataset, if you like my work please upvote and also provide your valuable comments on this kernal which will help me in improving further.\n\nAlthough its been 3 months for the competetion it took time for me to post the code here. \n\n**Better late than never :):)**","197f65e1":"### Fitting the data to the created column transformer","2c642bf5":"### Distribution of categorical variables ","215010a0":"<a id=section4><\/a>\n\n## Preprocessing\n\n- We gonna use Pipelines for dropping the columns, doing standardization of Numerical data & for Frequent one hot encoding for categorical data\n\n\n### Why Pipelines?\n\nIn a typical machine learning workflow you will need to apply all transformations at least twice. Once when training the model and again on any new data when we want to predict. Using Scikit-learn pipelines as a tool will simplify this process.\n\nThey have several key benefits:\n- They make your workflow much easier to read and understand.\n- They enforce the implementation and order of steps in your project.\n- These in turn make your work much more reproducible.","af79af15":"### 1. XGB Classifier with Hyper parameter(scale_pos_weight) \n\nscale_pos_weight hyperparamter controls the balance of positive and negative weights, useful for unbalanced classes.","bae2a691":"#### Transforming the train data with all the data , previously we divide the train data again into test & train for internal evaluation and selection of algorithm","74be34a2":"<a id=section5><\/a>\n# Model Selection\n\nWe can try to fit the imbalanced data on below models\n\n- XGBOOST \n- Balanced Bagging classifier\n- Support vector machine\n- Random Forest\n- ADA Boost\n\n**Evaluation Metric : Recall score : TP\/(TP+FN)**","4cca98fe":"### 3. SVM with Weighted class\n\nClass-weighted SVM is designed to deal with unbalanced data by assigning higher misclassification penalties to training instances of the minority class.\nThe paramter used : __class_weight = 'balanced'__","0c0befe4":"We can see that the data is imbalanaced & most of the mails are from hackers(suspicious).","b3c8a76e":"### 5. ADA boost","9bc46c73":"**NOTE** :The outlier treatment will be done only on the train data but not the test data.","b4d7c4ae":"We can see that the distribution of data is identical for both the varaibles __0 & 1__ in test & train data. ","da9b3154":"### Data:\n- __X_1 - X_15__ : Anonymized logging parameters\n- __Date__ : Date wof Incident occurance\n- __Incident ID__ : ID of the occurance of event\n- __Multiple Offense__ : Indicates that if the incident was hack","f32b1fa7":"# Prediction if Server is Hack or not ","b9aece73":"## Problem Statement\n\nAll the countries across the globe have adapted to means of digital payments. And with the increased volume of digital payments, hacking has become common event\nwherein the hacker can try to hack your details just with your phone number linked to your bank account.\nHowever, there is data with some anonymized variables based on which one can predict that the hack is going to happen.\n\nThe problem is to build a __predictive model which can identify a pattern in these variables and suggest that a hack is going to happen So that the cyber security can somehow stop it before it happens__.\n\n![](https:\/\/raw.githubusercontent.com\/VijayMukkala\/Mini-Projects\/master\/Predict_incident-is-hack\/hacker-1944688_640.jpg)","13494a27":"<a id=section3><\/a>\n## Visualizing the data\n### Checking the distribution of Continous variables","85bb2f10":"The observation here is for variables X_1 and X_9 only 3 variables are giving more information and the rest of the values are very less. so instead of __onehot encoding__ technique I will use __onehot encoding of frequent categories__ .\n\nIn __One hot encoding of frequent categories__, we create dummy variables only for most frequent categories. It is equivalent to grouping all the remaining categories under a new category.We can choose if we want top 10 frequent variables or more as per the use case or data provide to us\n\nIn this kernal, we use selecting the top frequent values using __OneHotCategoricalEncoder API__. This encoder can also create binary variables for the n most popular categories","dbc533d0":"<a id=section1><\/a>\n## Import Packages","55fca09d":"### 2. Balanced Bagging Classifier\nBalancedBaggingClassifier uses a random undersampling strategy on the majority class within a bootstrap sample in order to balance the two classes"}}