{"cell_type":{"f4776ff5":"code","bcadfa09":"code","98b03a92":"code","fe30ce81":"code","102057d9":"code","d20c1853":"code","2853978b":"code","c324a56f":"code","c6fe3c51":"code","0dd008a1":"code","28251abf":"code","d56365f8":"code","1907df42":"code","23c0818b":"code","6add3088":"code","454a7e0e":"code","a0d7b924":"code","eb4c6688":"code","cfc5828e":"code","d265b76e":"code","afa64c82":"code","b994178c":"code","bb0a06f8":"code","ef2f558e":"code","ab1ca4d9":"code","3d01b932":"code","59830364":"code","1375603e":"code","745556bf":"code","efc3117b":"markdown","22baaead":"markdown","4f91ca67":"markdown","c7893116":"markdown","620d6467":"markdown","8bc1dc14":"markdown","7757ac6e":"markdown","7ee597dc":"markdown","909d1741":"markdown","951f2851":"markdown","64fc3fa0":"markdown","f076b84d":"markdown","06d15841":"markdown","d46fd33c":"markdown","6a5e5fec":"markdown","6bad89f5":"markdown","c08c0ac1":"markdown","3e9fb61e":"markdown","d47156a7":"markdown","10943cef":"markdown","b0f5c62a":"markdown","66dc3d21":"markdown","dd70cff3":"markdown","c6f20d56":"markdown","e68ee101":"markdown","948c7af7":"markdown","2dd47645":"markdown","17705c1c":"markdown","98687918":"markdown","096caa89":"markdown"},"source":{"f4776ff5":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nimport inspect","bcadfa09":"!pip install python-chess  # Python-Chess is the Python Chess Package that handles the chess environment\n!pip install --upgrade git+https:\/\/github.com\/arjangroen\/RLC.git  # RLC is the Reinforcement Learning package","98b03a92":"%load_ext autoreload\n%autoreload 2","fe30ce81":"from RLC.move_chess.environment import Board\nfrom RLC.move_chess.agent import Piece\nfrom RLC.move_chess.learn import Reinforce","102057d9":"env = Board()\nenv.render()\nenv.visual_board","d20c1853":"p = Piece(piece='king')","2853978b":"r = Reinforce(p,env)","c324a56f":"# print(inspect.getsource(r.evaluate_state))\n\ndef evaluate_state(self, state, gamma=0.9, synchronous=True):\n        \"\"\"\n        Calculates the value of a state based on the successor states and the immediate rewards.\n        Args:\n            state: tuple of 2 integers 0-7 representing the state\n            gamma: float, discount factor\n            synchronous: Boolean\n\n        Returns: The expected value of the state under the current policy.\n\n        \"\"\"\n        greedy_action_value = np.max(self.agent.policy[state[0], state[1], :])\n        #print(greedy_action_value)\n        greedy_indices = [i for i, a in enumerate(self.agent.policy[state[0], state[1], :]) if\n                          a == greedy_action_value]  # List of all greedy actions\n        prob = 1 \/ len(greedy_indices)  # probability of an action occuring\n        state_value = 0\n        for i in greedy_indices:\n            self.env.state = state  # reset state to the one being evaluated\n            reward, episode_end = self.env.step(self.agent.action_space[i])\n            #print(reward)\n            if synchronous:\n                successor_state_value = self.agent.value_function_prev[self.env.state]\n            else:\n                successor_state_value = self.agent.value_function[self.env.state]\n            state_value += (prob * (\n                    reward + gamma * successor_state_value))  # sum up rewards and discounted successor state value\n        return state_value\n    \nr.evaluate_state = evaluate_state","c6fe3c51":"r.agent.value_function.astype(int)","0dd008a1":"state = (0,0)\nr.agent.value_function[0,0] = r.evaluate_state(r,state,gamma=1)","28251abf":"r.agent.value_function.astype(int)","d56365f8":"# print(inspect.getsource(r.evaluate_policy))\n\ndef evaluate_policy(self, gamma=0.9, synchronous=True):\n        self.agent.value_function_prev = self.agent.value_function.copy()  # For synchronous updates\n        for row in range(self.agent.value_function.shape[0]):\n            for col in range(self.agent.value_function.shape[1]):\n                self.agent.value_function[row, col] = self.evaluate_state(self, (row, col), gamma=gamma,\n                                                                          synchronous=synchronous)\n                \nr.evaluate_policy = evaluate_policy","1907df42":"r.evaluate_policy(r,gamma=1)","23c0818b":"r.agent.value_function.astype(int)","6add3088":"eps=0.1\nk_max = 1000\nvalue_delta_max = 0\ngamma = 1\nsynchronous=True\nvalue_delta_max = 0\nfor k in range(k_max):\n    r.evaluate_policy(r, gamma=gamma,synchronous=synchronous)\n    value_delta = np.max(np.abs(r.agent.value_function_prev - r.agent.value_function))\n    value_delta_max = value_delta\n    if value_delta_max < eps:\n        print('converged at iter',k)\n        break","454a7e0e":"r.visualize_policy()","a0d7b924":"r.agent.value_function.astype(int)","eb4c6688":"#print(inspect.getsource(r.improve_policy))\ndef improve_policy(self):\n    \"\"\"\n    Finds the greedy policy w.r.t. the current value function\n    \"\"\"\n\n    self.agent.policy_prev = self.agent.policy.copy()\n    for row in range(self.agent.action_function.shape[0]):\n        for col in range(self.agent.action_function.shape[1]):\n            for action in range(self.agent.action_function.shape[2]):\n                self.env.state = (row, col)  # reset state to the one being evaluated\n                reward, episode_end = self.env.step(self.agent.action_space[action])\n                successor_state_value = 0 if episode_end else self.agent.value_function[self.env.state]\n                self.agent.policy[row, col, action] = reward + successor_state_value\n\n            max_policy_value = np.max(self.agent.policy[row, col, :])\n            max_indices = [i for i, a in enumerate(self.agent.policy[row, col, :]) if a == max_policy_value]\n            for idx in max_indices:\n                self.agent.policy[row, col, idx] = 1\n\nfuncType = type(r.improve_policy)\nr.improve_policy = funcType(improve_policy, r)","cfc5828e":"r.evaluate_policy(r,gamma=1)","d265b76e":"r.agent.value_function.astype(int)","afa64c82":"r.improve_policy()\nr.visualize_policy()","b994178c":"r.evaluate_policy(r,gamma=1)\nr.agent.value_function.astype(int)","bb0a06f8":"# print(inspect.getsource(r.policy_iteration))\ndef policy_iteration(self, eps=0.1, gamma=0.9, iteration=1, k=32, synchronous=True):\n        \"\"\"\n        Finds the optimal policy\n        Args:\n            eps: float, exploration rate\n            gamma: float, discount factor\n            iteration: the iteration number\n            k: (int) maximum amount of policy evaluation iterations\n            synchronous: (Boolean) whether to use synchronous are asynchronous back-ups \n\n        Returns:\n\n        \"\"\"\n        policy_stable = True\n        print(\"\\n\\n______iteration:\", iteration, \"______\")\n        print(\"\\n policy:\")\n        self.visualize_policy()\n\n        print(\"\")\n        value_delta_max = 0\n        for _ in range(k):\n            self.evaluate_policy(self, gamma=gamma, synchronous=synchronous)\n            value_delta = np.max(np.abs(self.agent.value_function_prev - self.agent.value_function))\n            value_delta_max = value_delta\n            if value_delta_max < eps:\n                break\n        print(\"Value function for this policy:\")\n        print(self.agent.value_function.round().astype(int))\n        action_function_prev = self.agent.action_function.copy()\n        print(\"\\n Improving policy:\")\n        self.improve_policy()\n        policy_stable = self.agent.compare_policies() < 1\n        print(\"policy diff:\", policy_stable)\n\n        if not policy_stable and iteration < 1000:\n            iteration += 1\n            self.policy_iteration(iteration=iteration)\n        elif policy_stable:\n            print(\"Optimal policy found in\", iteration, \"steps of policy evaluation\")\n        else:\n            print(\"failed to converge.\")\n            \nfuncType = type(r.policy_iteration)\nr.policy_iteration = funcType(policy_iteration, r)","ef2f558e":"r.policy_iteration()","ab1ca4d9":"agent = Piece(piece='king')\nr = Reinforce(agent,env)","3d01b932":"r.policy_iteration(gamma=1,synchronous=False)","59830364":"r.visualize_policy()","1375603e":"r.agent.value_function.astype(int)","745556bf":"agent = Piece(piece='rook')  # Let's pick a rook for a change.\nr = Reinforce(agent,env)\nr.policy_iteration(k=1,gamma=1)  # The only difference here is that we set k_max to 1.","efc3117b":"**Demonstration**","22baaead":"1. Reinforcement Learning: An Introduction  \n   Richard S. Sutton and Andrew G. Barto  \n   1st Edition  \n   MIT Press, march 1998\n2. RL Course by David Silver: Lecture playlist  \n   https:\/\/www.youtube.com\/watch?v=2pWv7GOvuf0&list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ","4f91ca67":"** Theory **  \nValue iteration is nothing more than a simple parameter modification to policy iteration. Remember that policy iteration consists of policy evaluation and policy improvement. The policy evaluation step does not necessarily have to be repeated until convergence before we improve our policy. Recall that the policy iteration above took over 400 iterations to converge. If we use ony 1 iteration instead we call it value iteration.","c7893116":"# Notebook I: Solving Move Chess","620d6467":"# 1.1 State Evaluation","8bc1dc14":"### Reinforce\n- The reinforce object contains the algorithms for solving move chess\n- The agent and the environment are attributes of the Reinforce object","7757ac6e":"### The agent\n- The agent is a chess Piece (king, queen, rook, knight or bishop)\n- The agent has a behavior policy determining what the agent does in what state","7ee597dc":"**Demonstration**","909d1741":"# Policy Improvement","951f2851":"**Theory**  \nWith policy evaluation, we bootstrap: we make an estimate based on another estimate. So which estimate do we take? We have to options:\n1. We bootstrap from the previous policy evaluation. This means each state value estimate update is based on the same iteration of policy evaluation. This is called synchronous policy iteration\n2. We bootstrap from the freshest estimate. This means a estimate update can be based on the previous or the current value funtion, or a combination of the two. This is called asynchrronous policy iteration\n\nThe **Implementation** is the same as policy iteration, only we pass the argument sychronous=False","64fc3fa0":"**Demonstration**","f076b84d":"# 1.2 Policy Evaluation\n* Policy evaluation is the act of doe state evaluation for each state in the statespace\n* As you can see in my implementatin I simply iterate over all state and update the value function\n* This is the algorithm provided by Sutton and Barto:  \n![](http:\/\/incompleteideas.net\/book\/ebook\/pseudotmp0.png)\n","06d15841":"### The environment","d46fd33c":"**Python implementation**","6a5e5fec":"**Demonstration**","6bad89f5":"This value function below shows the expected discounted future reward from state (0,0) = -185","c08c0ac1":"# That's all!\nIn the next notebook I'll cover model-free methods such as Monte Carlo and Temporal Difference based methods. These methods help us when we don't know the transition probalities of a Markov Decision Process. \n\nI expect to have my second RLC notebook up and running around mid-june!\nHope you enjoyed!","3e9fb61e":"# References","d47156a7":"- The state space is a 8 by 8 grid\n- The starting state S is the top-left square (0,0)\n- The terminal state F is square (5,7). \n- Every move from state to state gives a reward of minus 1\n- Naturally the best policy for this evironment is to move from S to F in the lowest amount of moves possible.","10943cef":"# 1.3 Policy Iteration  \n**Theory**  \nWe can now find the optimal policy by doing policy evaluation and policy improvement untill the policy is stable:\n![](http:\/\/www.incompleteideas.net\/book\/first\/ebook\/pseudotmp1.png)","b0f5c62a":"**Theory**\n\nIf we want our agent to optimize its rewards, we want its policy to guide behavior towards the states with the highest value. This value can be estimated using bootstrapping:\n* A state (s) is as valuable (V) as the successor state (s') plus the reward (R) for going from s to s'. \n* Since there can be mulitple actions (a) and multiple successor states they are summed and weighted by their probability (pi). \n* In a non-deterministic environment, a given action could result in multiple successor states. We don't have to take this into account for this problem because move chess is a deterministic game.\n* Successor state values are discounted with discount factor (gamma) that varies between 0 and 1.  \n* This gives us the following formula:  \n![](http:\/\/incompleteideas.net\/book\/ebook\/numeqnarraytmp7-2-2.png)  \n\nNote that:\n* The successor state value is also en estimate. \n* Evaluating a state is bootstrapping because you are making an estimate based on another estimate\n* In the code you'll see a synchronous parameter that will be explained later in the policy evaluation section\n\n","66dc3d21":"Now that we know what the values of the states are, we want to improve our Policy so that we the behavior is guided towards the state with the highest value. Policy Improvement is simply the act of making the policy greedy with respect to the value function.\n* In my implementation, we do this by setting the value of the action that leads to the most valuable state to 1 (while the rest remains 0)","dd70cff3":"**Python Implementation**","c6f20d56":"# Reinforcement Learning Chess\nHi there! If you're interested in learning about reinforcement learning, you are in the right place. As we all know the best way to learn about a topic is to build something and make a kernel about it. My plan is to make a series of notebooks where I work may way towards a full-fledged chess AI named RLC (Reinforcement Learning Chess). \n\nTackling chess is a big challenge, mainly because of its huge state-space. Therefore I start with simpler forms of chess and solve these problems with elementary RL-techniques. Gradually I will expand this untill we end up in a chess AI that can play actual games of chess somewhat intelligibly. The forms of chess I want to cover in my notebooks are:  \n\n#### 1. Move Chess \n- Goal: Learn to find the shortest path between 2 squares on a chess board  \n- Motivation: Move Chess has a small statespace, which allows us to tackle this with simple RL algorithms.\n- Concepts: Dynamic Programming, Policy Evaluation, Policy Improvement, Policy Iteration, Value Iteration, Synchronous & Asynchronous back-ups, Monte Carlo (MC) Prediction, MC Control, Temporal Difference (TD) Learning, TD control, TD-lambda, SARSA(-max)\n\n#### 2. Capture Chess\n- Goal: Capture as many pieces from the opponent within n fullmoves\n- Motivation: Piece captures happen more frequently than win-lose-draw events. This give the algorithm more information to learn from.\n- Concepts: Q-learning, value function approximation, experience replay, fixed-q-targets, policy gradients, REINFORCE, actor-critic\n\n\n#### 3. Real Chess (a.k.a. chess)\n- Goal: Play chess competitively against a human beginner\n- Motivation: A RL chess AI\n- Concepts: Monte Carlo Tree Search\n\n#### Other notebooks\n[**Notebook 2: Model free learning**](https:\/\/www.kaggle.com\/arjanso\/reinforcement-learning-chess-2-model-free-methods)  \n[**Notebook 3: Q-networks**](https:\/\/www.kaggle.com\/arjanso\/reinforcement-learning-chess-3-q-networks)  \n[**Notebook 4: Policy Gradients**](https:\/\/www.kaggle.com\/arjanso\/reinforcement-learning-chess-4-policy-gradients)  \n[**Notebook 5: Monte Carlo Tree Search**](https:\/\/www.kaggle.com\/arjanso\/reinforcement-learning-chess-5-tree-search)\n\n\nIn my notebooks, I will describe and reference the Reinforcement Learning theory but I will not fully explain it. For that there are resources available that do a match better job at explaining RL than I could. For that my advice would be to check out David Silver's (Deepmind) lectures that are available on Youtube and the book Introduction to Reinforcement Learning by Sutton and Barto referenced below.","e68ee101":"We can iterate this until the value function is stable:","948c7af7":"# 1.4 Asynchronous Policy Iteration\n","2dd47645":"* Please note that my visual can print only 1 arrow per square, but there may be multiple optimal actions.","17705c1c":"**Demonstration**\n* The initial value function assigns value 0 to each state\n* The initial policy gives an equal probability to each action\n* We evaluate state (0,0)","98687918":"# 1.5 Value Iteration","096caa89":"We end up with the following value of -1 for all states except the terminal state. "}}