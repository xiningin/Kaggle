{"cell_type":{"cf1fa5f9":"code","0f73ef2e":"code","3956b83a":"code","89db8dae":"code","a0476ad7":"code","cc171227":"code","5161f388":"code","42cf461d":"code","bdb70c78":"code","160cafd0":"code","2a46f0aa":"code","f3c8159c":"code","2802f08e":"code","95cd4eb5":"code","154ab39b":"code","0763b42b":"markdown","ddfcbda3":"markdown","41ff33a3":"markdown","de2925f1":"markdown"},"source":{"cf1fa5f9":"! pip install -qq ..\/input\/timm-pytorch-image-models\/pytorch-image-models-master","0f73ef2e":"import os\nimport gc\nimport random\nimport time\nimport math\n\nimport numpy as np\nimport pandas as pd\nimport cv2\nimport matplotlib.pyplot as plt\n\nfrom tqdm.auto import tqdm\nimport albumentations as A\nfrom albumentations.pytorch import ToTensorV2\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nimport pytorch_lightning as pl\nimport torchmetrics as metrics\nimport timm\n\nfrom kaggle_datasets import KaggleDatasets\n\nimport warnings\nwarnings.filterwarnings('ignore')","3956b83a":"class Config:\n    '''general'''\n    num_workers = 4\n    \n    '''data'''\n    batch_size = 64\n    target_col = \"Pawpularity\"\n    \n    '''model'''\n    # 'regnety_002', 'efficientnet_b3', 'efficientnet_b0', \n    # 'vit_base_patch16_224', 'tf_efficientnet_b4_ns'\n    model_name = 'tf_efficientnet_b3'\n    # number of predictors\n    targets = 1\n    # regressor features, number of useful features in meta data\n    # 12 means using all columns except id and target column\n    num_features = 12\n    # input image size send to network can be like 256, 512, 768, 1028\n    input_size = 260\n    # freeze backbone network\n    freeze_backbone = True\n    \n    '''test'''\n    n_fold = 5\n    trn_folds = [0, 1, 2, 3, 4]\n    tta_steps = 10","89db8dae":"test_csv = pd.read_csv(\"..\/input\/petfinder-pawpularity-score\/test.csv\")\ntest_data_path = \"..\/input\/petfinder-pawpularity-score\/test\"\ntest_csv[\"path\"] = test_csv[\"Id\"].apply(lambda x: os.path.join(test_data_path, x+\".jpg\"))\ntest_csv.head()","a0476ad7":"max_paws = 100","cc171227":"class PawpularityDataset(torch.utils.data.Dataset):\n    def __init__(self, csv_file, augmentations=None, test=False):\n        super(PawpularityDataset, self).__init__()\n        self.csv = csv_file\n        self.test = test\n        self.augs = augmentations\n        self.length = len(self.csv)\n    \n    def __len__(self):\n        return self.length\n    \n    def __getitem__(self, idx):\n        path = self.csv.iloc[idx][\"path\"]\n        img = cv2.imread(path)\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n        if self.augs is not None:\n            img = self.augs(image=img)['image']\n        else:\n            img = torch.from_numpy(img).float()\n            img = img.permute(2, 0, 1)\n        meta = torch.from_numpy(self.csv.iloc[idx, 1:13].values.astype(np.float32))\n        if self.test:\n            return img, meta\n        label = torch.tensor(self.csv.iloc[idx][Config.target_col], dtype=torch.float)\/max_paws\n        return img, meta, label","5161f388":"class ImageAugmentations:\n    '''\n        image_size: resize image to -> (width, height)\n        train_augs: include augmentations like random crop, rotation etc training if false then return\n                    only resize image as pytorch tensor\n    '''\n    def __init__(self, image_size, apply_augs=False):\n        self.image_size = image_size\n        self.apply_augs = apply_augs\n        \n    def train_augs(self):\n        if self.apply_augs:\n            return A.Compose([A.Resize(self.image_size, self.image_size),\n                              A.HorizontalFlip(p=.5),\n                              A.ChannelShuffle(p=.1),\n                              A.ColorJitter(brightness=0.1,\n                                            hue=0.1,\n                                            saturation=0.1,\n                                            contrast=0.1,\n                                            p=.2),\n                              A.RandomGamma(p=.1),\n                              A.Sharpen(p=.1),\n                              A.Cutout(p=.2),\n                              # imagenet normalization\n                              A.Normalize(mean=[0.485, 0.456, 0.406],\n                                          std=[0.229, 0.224, 0.225],\n                                          max_pixel_value=255.0,\n                                          p=1.0),\n                              ToTensorV2()])\n        return A.Compose([A.Resize(self.image_size, self.image_size),\n                          A.Normalize(mean=[0.485, 0.456, 0.406],\n                                      std=[0.229, 0.224, 0.225],\n                                      max_pixel_value=255.0,\n                                      p=1.0),\n                          ToTensorV2()])\n    \n    def valid_augs(self):\n        return A.Compose([A.Resize(self.image_size, self.image_size),\n                          A.Normalize(mean=[0.485, 0.456, 0.406],\n                                      std=[0.229, 0.224, 0.225],\n                                      max_pixel_value=255.0,\n                                      p=1.0),\n                          ToTensorV2()])\n        ","42cf461d":"augs = ImageAugmentations(Config.input_size, apply_augs=True)\nds = PawpularityDataset(test_csv, augmentations=augs.train_augs(), test=True)\nloader = torch.utils.data.DataLoader(ds,\n                                     shuffle=True,\n                                     batch_size=4)\nimages, meta = next(iter(loader))\nplt.figure(figsize=(15, 15))\nfor step, image in enumerate(images):\n    plt.subplot(1, 4, step+1)\n    plt.imshow(image.permute(1, 2, 0).numpy())\n    plt.axis('off')","bdb70c78":"class PawpularityModel(nn.Module):\n    def __init__(self, cfg, pretrained=False):\n        super(PawpularityModel, self).__init__()\n        self.cfg = cfg\n        timm_model = timm.create_model(self.cfg.model_name, \n                                       pretrained=pretrained, \n                                       in_chans=3)\n        \n        if self.cfg.freeze_backbone:\n            modules = []\n            for module in timm_model.children():\n                for param in module.parameters():\n                    param.requires_grad = False\n                modules.append(module)\n        else:\n            modules = list(timm_model.children())\n        \n        self.classifier = modules[-1]\n        cnn_out_features = self.classifier.in_features\n        classifier_out_features = self.classifier.out_features\n        \n        self.cnn = nn.Sequential(*modules[:-1])\n        self.dropout = nn.Dropout(0.2)\n        \n        self.meta_reg = nn.Linear(cfg.num_features, cfg.num_features)\n        num_features = classifier_out_features + cfg.num_features + cnn_out_features\n        self.regressor_1 = nn.Sequential(nn.Linear(num_features, 128),\n                                         nn.SiLU(),\n                                         nn.Dropout(0.2),\n                                         nn.Linear(128, 64),\n                                         nn.SiLU(),\n                                         nn.Dropout(0.2),\n                                         nn.Linear(64, 32),\n                                         nn.SiLU(),\n                                         nn.Dropout(0.2),\n                                         nn.Linear(32, 16),\n                                         nn.SiLU(),\n                                         nn.Dropout(0.2),\n                                         nn.Linear(16, cfg.targets))\n        num_features = cnn_out_features + cfg.num_features\n        self.regressor_2 = nn.Sequential(nn.Linear(num_features, 64),\n                                         nn.SiLU(),\n                                         nn.Dropout(0.2),\n                                         nn.Linear(64, cfg.targets))\n        \n    def forward(self, img, meta):\n        meta = self.meta_reg(meta)\n        cnn_features = self.cnn(img)\n        if self.cfg.freeze_backbone:\n            classes = self.classifier(cnn_features)\n            cnn_features = self.dropout(cnn_features)\n            x = torch.cat((cnn_features, meta, classes), dim=1)\n            x = self.dropout(x)\n            return self.regressor_1(x)\n        cnn_features = self.dropout(cnn_features)\n        x = torch.cat((cnn_features, meta), dim=1)\n        x = self.dropout(x)\n        return self.regressor_2(x)","160cafd0":"class LitPawpularity(pl.LightningModule):\n    def __init__(self, cfg, model):\n        super(LitPawpularity, self).__init__()\n        self.cfg = cfg\n        self.model = model\n        \n    def forward(self, img, meta):\n        return self.model(img, meta)\n        \n    def predict_step(self, batch, batch_idx, dataloader_idx=None):\n        img, meta = batch\n        out = self(img, meta).flatten()\n        return F.sigmoid(out) * max_paws","2a46f0aa":"def get_weights_path(fold, mode):\n    path = \"..\/input\/find-a-pet-with-lightning-speed-effnets\"\n    return os.path.join(path, \"best\", f\"{Config.model_name}_best_{mode}_fold{fold}.ckpt\")","f3c8159c":"def get_fold_predictions(fold):\n    print(\"=\"*10)\n    print(\"Predictions using fold\", fold)\n    print(\"=\"*10)\n    augs = ImageAugmentations(Config.input_size, apply_augs=True)\n    weights = [get_weights_path(fold, \"loss\"),\n               get_weights_path(fold, \"rmse\")]\n    preds = []\n    for weight in weights:\n        print(\"Using weights: \", weight)\n        model = PawpularityModel(Config, pretrained=False)\n        lit = LitPawpularity.load_from_checkpoint(weight, cfg=Config, model=model, fold=fold)\n        trainer_params = {\"gpus\": -1}\n        trainer = pl.Trainer(**trainer_params)\n        tta_preds = []\n        for tta in range(Config.tta_steps):\n            if tta == 0:\n                ds = PawpularityDataset(test_csv,\n                                        augmentations=augs.valid_augs(),\n                                        test=True)\n            else:\n                ds = PawpularityDataset(test_csv,\n                                        augmentations=augs.train_augs(),\n                                        test=True)\n            loader = torch.utils.data.DataLoader(ds,\n                                                 shuffle=False,\n                                                 num_workers=Config.num_workers, \n                                                 pin_memory=True,\n                                                 drop_last=False,\n                                                 batch_size=Config.batch_size*2)\n            predictions = trainer.predict(lit, loader)\n            tta_preds.append(torch.cat([x for x in predictions]).detach().cpu().numpy())\n        predictions = np.mean(np.column_stack(tta_preds), axis=1)\n        preds.append(predictions)\n    preds = np.mean(np.column_stack(preds), axis=1)\n    return preds","2802f08e":"fold_predictions = []\nfor fold in Config.trn_folds:\n    preds = get_fold_predictions(fold)\n    fold_predictions.append(preds)\n    \nfold_predictions = np.column_stack(fold_predictions)","95cd4eb5":"mean_predictions = np.mean(fold_predictions, axis=1)","154ab39b":"test_csv[\"Pawpularity\"] = mean_predictions\nsub_csv = test_csv[[\"Id\", \"Pawpularity\"]]\nsub_csv.to_csv(\"submission.csv\", index=False)\nsub_csv.head()","0763b42b":"### Internet Disabled\nMake sure to disable internet for submitting predictions","ddfcbda3":"# PAWPULARITY PETFINDER INFERENCE","41ff33a3":"### [Training Notebook](https:\/\/www.kaggle.com\/tarunbisht11\/find-a-pet-with-lightning-speed-effnets)","de2925f1":"### What's New\n- tta added\n- models and augmentations updated"}}