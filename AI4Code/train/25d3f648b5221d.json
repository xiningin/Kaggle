{"cell_type":{"5c932a32":"code","fbe0aa39":"code","71808a3b":"code","35f5d2da":"code","710e6eab":"code","7e6f226c":"code","70337721":"code","ba16ef06":"code","9482b57f":"code","61d6e437":"code","b1abd6e4":"code","4fd5fd9f":"code","159a581c":"code","8e22335b":"code","10eb2a42":"code","1176ff8e":"code","a4105f1a":"code","0e87ca24":"code","6bac3504":"code","fc2cf130":"code","2dff0ead":"code","798afa2a":"code","03222417":"code","10b37f8b":"code","77206bd3":"code","14962ada":"code","2117cc50":"code","59eb77ee":"markdown","1942e66c":"markdown","775423d6":"markdown","ba5920d8":"markdown","8d74c613":"markdown","5914ebcc":"markdown","1453338a":"markdown","0e0fe662":"markdown","d53fd77b":"markdown","ae8fc490":"markdown","3017c80b":"markdown","f303e7ee":"markdown","4f4060c1":"markdown","ec7176a8":"markdown"},"source":{"5c932a32":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\nimport sqlite3\nimport matplotlib.pyplot as plt\nimport xml.etree.ElementTree as ET\nfrom datetime import datetime\nimport plotly.graph_objs as go\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nimport plotly\nimport plotly.figure_factory as ff\nimport ipywidgets as widgets\nimport math\nplotly.offline.init_notebook_mode()\n#THIS LINE IS MOST IMPORTANT AS THIS WILL DISPLAY PLOT ON \n#NOTEBOOK WHILE KERNEL IS RUNNING\n\n# Any results you write to the current directory are saved as output.","fbe0aa39":"#Lets set up the connection to database\ndatabase = \"..\/input\/database.sqlite\"\nconn = sqlite3.connect(database)","71808a3b":"#Lets print out the name of the tables in the database\npd.read_sql(\"SELECT * FROM sqlite_master WHERE type='table';\", conn)","35f5d2da":"pd.read_sql(\"SELECT * FROM League;\", conn)","710e6eab":"#Given that we want to find out infomration of the English Premier Leage, lets get the data using SQL query\nepl = pd.read_sql(\"\"\"SELECT id, league_id, stage, season,date, match_api_id,\n                     home_team_api_id, (SELECT team_long_name FROM Team WHERE team_api_id = home_team_api_id) home_team, \n                     away_team_api_id, (SELECT team_long_name FROM Team WHERE team_api_id = away_team_api_id) away_team,\n                     home_team_goal, away_team_goal, goal, shoton, shotoff, foulcommit,\n                     card, cross, corner, possession, B365H, B365D, B365A\n                     FROM Match m\n                     WHERE league_id = (SELECT id FROM league WHERE name = 'England Premier League')\n                     ORDER BY date;\n                \"\"\", conn)","7e6f226c":"match_count = epl['id'].size\nno_seasons = epl['season'].nunique()\nprint(\"The dataframe consists of %d rows spanning %d years of data\" % (match_count, no_seasons))\nepl['season'].value_counts()","70337721":"epl.head()","ba16ef06":"epl['shoton'].iloc[0]","9482b57f":"def calculate_stats_both_teams(xml_document, home_team, away_team, card_type='y'):\n    assert card_type == 'y' or card_type == 'r', \"Please enter either y or r\"\n    tree = ET.fromstring(xml_document)\n    stat_home_team = 0\n    stat_away_team = 0\n    \n    #Dealing with card type using the root element & the card type argument\n    if tree.tag == 'card':\n        for child in tree.iter('value'):\n            #Some xml docs have no card_type element in the tree. comment section seems to have that information\n            try:\n                if child.find('comment').text == card_type:\n                    if int(child.find('team').text) == home_team:\n                        stat_home_team += 1\n                    else:\n                        stat_away_team += 1\n            except AttributeError:\n                #Some values in the xml doc don't have team values, so there isn't much we can do at this stage\n                pass\n                \n        return stat_home_team, stat_away_team\n    \n    #Lets take the last possession stat which is available from the xml doc\n    if tree.tag == 'possession':\n        try:\n            last_value = [child for child in tree.iter('value')][-1]\n            return int(last_value.find('homepos').text), int(last_value.find('awaypos').text)\n        except:\n            return None, None\n    \n    #Taking care of all other stats by extracting based on the home team & away team api id's\n    for team in [int(stat.text) for stat in tree.findall('value\/team')]:\n        if team == home_team: \n            stat_home_team += 1\n        else:\n            stat_away_team += 1\n    return stat_home_team, stat_away_team","61d6e437":"epl[['on_target_shot_home_team','on_target_shot_away_team']] = epl[['shoton','home_team_api_id','away_team_api_id']].apply(lambda x: calculate_stats_both_teams(x['shoton'],x['home_team_api_id'],x['away_team_api_id']), axis = 1,result_type=\"expand\")  \nepl[['off_target_shot_home_team','off_target_shot_away_team']] = epl[['shotoff','home_team_api_id','away_team_api_id']].apply(lambda x: calculate_stats_both_teams(x['shotoff'],x['home_team_api_id'],x['away_team_api_id']), axis = 1,result_type=\"expand\") \nepl[['foul_home_team','foul_away_team']] = epl[['foulcommit','home_team_api_id','away_team_api_id']].apply(lambda x: calculate_stats_both_teams(x['foulcommit'],x['home_team_api_id'],x['away_team_api_id']), axis = 1,result_type=\"expand\")  \nepl[['yellow_card_home_team','yellow_card_away_team']] = epl[['card','home_team_api_id','away_team_api_id']].apply(lambda x: calculate_stats_both_teams(x['card'],x['home_team_api_id'],x['away_team_api_id']), axis = 1,result_type=\"expand\")\nepl[['red_card_home_team','red_card_away_team']] = epl[['card','home_team_api_id','away_team_api_id']].apply(lambda x: calculate_stats_both_teams(x['card'],x['home_team_api_id'],x['away_team_api_id'], card_type='r'), axis = 1,result_type=\"expand\")  \nepl[['crosses_home_team','crosses_away_team']] = epl[['cross','home_team_api_id','away_team_api_id']].apply(lambda x: calculate_stats_both_teams(x['cross'],x['home_team_api_id'],x['away_team_api_id']), axis = 1,result_type=\"expand\")  \nepl[['corner_home_team','corner_away_team']] = epl[['corner','home_team_api_id','away_team_api_id']].apply(lambda x: calculate_stats_both_teams(x['corner'],x['home_team_api_id'],x['away_team_api_id']), axis = 1,result_type=\"expand\")  \nepl[['possession_home_team','possession_away_team']] = epl[['possession','home_team_api_id','away_team_api_id']].apply(lambda x: calculate_stats_both_teams(x['possession'],x['home_team_api_id'],x['away_team_api_id']), axis = 1,result_type=\"expand\")","b1abd6e4":"epl.describe()","4fd5fd9f":"epl.loc[epl['possession_home_team'].isnull()]","159a581c":"#Function to calculate the outcome of the match with respect to the target team\ndef get_result(home,away, home_goal, away_goal, target):\n    if home_goal == away_goal:\n        return 'D'\n    elif(home_goal > away_goal and target == home) or (home_goal<away_goal and target==away):\n        return 'W'\n    elif(home_goal > away_goal and target == away) or (home_goal<away_goal and target==home):\n        return 'L'","8e22335b":"#drop the XML columns from the datsaet\nepl = epl.drop(['goal','shoton','shotoff','foulcommit','card','cross','corner','possession'], axis=1)","10eb2a42":"#remove the time from the date in the datset\nepl['date'] = epl['date'].apply(lambda x: x.split()[0])\n#Subset the columns concerning the stats of the home and away team & rename the column names\naway_teams = epl[['id','league_id','stage','season','date','match_api_id','home_team_api_id','home_team','away_team_api_id','away_team',\n                  'home_team_goal','away_team_goal','B365H','B365D','B365A','on_target_shot_away_team','off_target_shot_away_team',\n                 'foul_away_team','yellow_card_away_team','red_card_away_team','crosses_away_team','corner_away_team','possession_away_team'\n                 ]].copy(deep=True)\naway_teams['team_name_stats'] = away_teams['away_team']\nhome_teams = epl[['id','league_id','stage','season','date','match_api_id','home_team_api_id','home_team','away_team_api_id','away_team',\n                  'home_team_goal','away_team_goal','B365H','B365D','B365A','on_target_shot_home_team','off_target_shot_home_team',\n                 'foul_home_team','yellow_card_home_team','red_card_home_team','crosses_home_team','corner_home_team','possession_home_team'\n                 ]].copy(deep=True)\nhome_teams['team_name_stats'] = home_teams['home_team']\nhome_teams.columns = ['id', 'league_id', 'stage', 'season', 'date', 'match_api_id','home_team_api_id', 'home_team', 'away_team_api_id', 'away_team',\n       'home_team_goal', 'away_team_goal', 'B365H', 'B365D', 'B365A','on_target_shots', 'off_target_shots', 'foul_home', 'yellow_card', 'red_card',\n       'crosses', 'corners', 'possession','team_name_stats']\naway_teams.columns = ['id', 'league_id', 'stage', 'season', 'date', 'match_api_id', 'home_team_api_id', 'home_team', 'away_team_api_id', 'away_team',\n       'home_team_goal', 'away_team_goal', 'B365H', 'B365D', 'B365A', 'on_target_shots', 'off_target_shots', 'foul_home', 'yellow_card', 'red_card',\n       'crosses', 'corners', 'possession', 'team_name_stats']\n\n#Merge both the home & away datasets, order them by the date & the home team in order to get team stats consecutively\nepl_team_stats = pd.concat([home_teams,away_teams]).sort_values(by=['date','home_team']).copy(deep=True)\nepl_team_stats['outcome'] = epl_team_stats.apply(\n    lambda x: get_result(x['home_team'],x['away_team'],x['home_team_goal'],x['away_team_goal'],x['team_name_stats']),\n    axis = 1\n)\nepl_team_stats['points_earned'] = epl_team_stats['outcome'].apply(lambda x: 3 if x=='W' else 0 if x=='L' else 1)\nepl_team_stats['date'] = epl_team_stats.date.map(lambda x: datetime.strptime(x,\"%Y-%m-%d\"))\nepl_team_stats = epl_team_stats.reset_index()","1176ff8e":"epl_team_stats.head()","a4105f1a":"#Calculate cumulative points, Goals for, Goal against & Goal difference for each team and at each stage of the season \nepl_team_stats['cum_points']=epl_team_stats.groupby(['season','team_name_stats']).points_earned.cumsum()\nepl_team_stats['goal_scored'] = epl_team_stats.apply(\n    lambda x: x['home_team_goal'] if x['team_name_stats']==x['home_team'] else x['away_team_goal'], axis=1)\nepl_team_stats['goal_conceded'] = epl_team_stats.apply(\n    lambda x: x['away_team_goal'] if x['team_name_stats']==x['home_team'] else x['home_team_goal'], axis=1)\nepl_team_stats['won'] = epl_team_stats.apply(lambda x:1 if x['outcome']=='W' else 0,axis=1)\nepl_team_stats['draw'] = epl_team_stats.apply(lambda x:1 if x['outcome']=='D' else 0,axis=1)\nepl_team_stats['loss'] = epl_team_stats.apply(lambda x:1 if x['outcome']=='L' else 0,axis=1)\nepl_team_stats['W'] = epl_team_stats.groupby(['season','team_name_stats']).won.cumsum()\nepl_team_stats['D'] = epl_team_stats.groupby(['season','team_name_stats']).draw.cumsum()\nepl_team_stats['L'] = epl_team_stats.groupby(['season','team_name_stats']).loss.cumsum()\nepl_team_stats['GF'] = epl_team_stats.groupby(['season','team_name_stats']).goal_scored.cumsum()\nepl_team_stats['GA'] = epl_team_stats.groupby(['season','team_name_stats']).goal_conceded.cumsum()\nepl_team_stats['GF'] = epl_team_stats.groupby(['season','team_name_stats']).goal_scored.cumsum()\nepl_team_stats['GA'] = epl_team_stats.groupby(['season','team_name_stats']).goal_conceded.cumsum()\nepl_team_stats['GD'] = epl_team_stats.apply( \n    lambda x: x['GF']-x['GA'], axis=1\n)\nepl_team_stats = epl_team_stats.drop([\"won\",\"draw\",\"loss\"],axis=1)","0e87ca24":"epl_team_stats.head(5)","6bac3504":"#Lets calculate the table position of each team at each stage of the tournament. \n#The premier league ranks according to points followed by goal difference and then goals for. \n#So at the start of the season there is are multiple ties, & the minimum rank is given for the teams in the same position\nepl_team_stats['rank_calc'] = epl_team_stats.apply(lambda x: x['cum_points']*10000 +x['GD']*50 +x['GF'],axis=1)\nepl_team_stats['table_position'] = epl_team_stats.groupby(['stage','season'])['rank_calc'].rank(ascending=False, method='min').astype(int)\nepl_team_stats = epl_team_stats.drop('rank_calc',axis=1)\nepl_team_stats.head(20).sort_values(['table_position','team_name_stats'])[['table_position','team_name_stats','W','D','L','GF','GA','GD','cum_points']]","fc2cf130":"epl_team_stats.tail(20).sort_values(['table_position','team_name_stats'])[['table_position','team_name_stats','W','D','L','GF','GA','GD','cum_points']]","2dff0ead":"team_attributes = pd.read_sql(\"\"\"WITH epl_team AS(\n                SELECT DISTINCT(m.home_team_api_id) \n                FROM  match m\n                WHERE league_id = (SELECT id FROM league l WHERE l.name='England Premier League')\n               )\n               SELECT (SELECT t.team_long_name FROM team t where t.team_api_id = ta.team_api_id) AS team_name, ta.* \n               FROM Team_Attributes ta WHERE ta.team_api_id IN (SELECT * FROM epl_team);\"\"\",\n            conn)","798afa2a":"team_attributes.head(10)","03222417":"print(\"There are %d unique teams in the attributes dataset which is also present in the EPL dataset we have extracted\"%sum(team_attributes.team_name.unique() == epl_team_stats.sort_values('home_team').home_team.unique()))","10b37f8b":"team_attributes.pivot_table( columns='team_name', values='team_api_id', aggfunc=len)","77206bd3":"#Lets create the season attribute to match the team attributes\nteam_attributes['date'] = team_attributes.date.map(lambda x: datetime.strptime(x.split()[0],'%Y-%m-%d'))\nbins = [datetime(2008,8,1),datetime(2009,6,15),\n       datetime(2009,8,1),datetime(2010,6,15),\n       datetime(2010,8,1),datetime(2011,6,15),\n       datetime(2011,8,1),datetime(2012,6,15),\n       datetime(2012,8,1),datetime(2013,6,15),\n       datetime(2013,8,1),datetime(2014,6,15),\n       datetime(2014,8,1),datetime(2015,6,15),\n       datetime(2015,8,1),datetime(2016,6,15)]\nteam_attributes['season_bin'] = pd.cut(team_attributes['date'], bins)\nteam_attributes['season'] = team_attributes.season_bin.map(lambda x: \"\".join([x.left.strftime('%Y-%m-%d').split('-')[0], \"\/\", x.right.strftime('%Y-%m-%d').split('-')[0]]))\nteam_attributes = team_attributes.drop(\"season_bin\", axis=1)","14962ada":"def graph_update_team_and_season_selection(season, team):\n    data_viz_season_performance = epl_team_stats[epl_team_stats.team_name_stats.eq(team) & \n                                  epl_team_stats.season.eq(season)]\n\n    #Trace for points gained during the selected season\n    trace_point_progression = go.Scatter(\n        x=data_viz_season_performance.date, \n        y=data_viz_season_performance.cum_points,\n        mode = \"markers+lines\",\n        marker={'color': 'green'},\n        name = \"Point Progression\"\n    )\n    #Trace for the Goal for during the selected team and season\n    trace_GF_progression = go.Scatter(\n        x=data_viz_season_performance.date,\n        y=data_viz_season_performance.GF,\n        mode = \"markers+lines\",\n        marker={'color':'blue'},\n        name=\"Goal For\",\n        yaxis=\"y2\"\n    )\n    #Trace for the Goal Allowed during the selected team and season\n    trace_GA_progression = go.Scatter(\n        x=data_viz_season_performance.date,\n        y=data_viz_season_performance.GA,\n        mode = \"markers+lines\",\n        marker={'color':'red'},\n        name=\"Goal Against\",\n        yaxis=\"y2\"\n    )\n\n    data1 = [trace_point_progression, trace_GF_progression, trace_GA_progression]\n    layout1= go.Layout(\n        title=\"\".join([team,' - ',season]), \n        xaxis={'title':'Date'}, \n        yaxis={'title':'Points','side':'left'},\n        yaxis2={'title':'Goals','overlaying':'y','side':'right'},\n    )\n    figure1 = go.FigureWidget(data = data1, layout=layout1)\n\n    data_viz_team_attributes = team_attributes.loc[team_attributes.team_name.eq(team) & team_attributes.season.eq(season),\n                                            ['team_name', 'buildUpPlaySpeed', 'buildUpPlayDribbling','buildUpPlayPassing',\n                                             'chanceCreationPassing', 'chanceCreationCrossing', 'chanceCreationShooting', \n                                             'defencePressure', 'defenceAggression', 'defenceTeamWidth', 'season']]\n    try:\n        trace_team_attributes = go.Scatterpolar(r=data_viz_team_attributes.values.tolist()[0][1:-1],\n                                            theta=data_viz_team_attributes.columns.tolist()[1:-1],\n                                            fill='toself'\n                                            )\n    except IndexError:\n        trace_team_attributes = go.Scatterpolar(r=[0*9],\n                                            theta=data_viz_team_attributes.columns.tolist()[1:-1],\n                                            fill='toself'\n                                            )\n    data2 = [trace_team_attributes]\n    layout2= go.Layout( polar = dict(\n                                 radialaxis = dict(\n                                 visible = True,\n                                 range = [25, 80]\n                                                  )\n                                ),showlegend = False\n                 )\n    figure2 = go.FigureWidget(data = data2, layout=layout2)\n    display(widgets.VBox([widgets.VBox([figure1, figure2])]))\n    \n\nseason = widgets.Dropdown(\n    options=list(epl_team_stats.season.unique()),\n    value='2015\/2016',\n    description='Season',\n    disabled=False,\n)\n\nteam = widgets.Dropdown(\n    options=epl_team_stats.sort_values('team_name_stats').team_name_stats.unique(),\n    value='Leicester City',\n    description='Team',\n    disabled=False,\n)\nwidgets.interactive(graph_update_team_and_season_selection, season=season, team=team)","2117cc50":"#Create pivot table for calculating mean points gained during season\nepl_mean_point = epl_team_stats.pivot_table(index=\"team_name_stats\", \n                                            columns=\"season\", \n                                            values=\"points_earned\", \n                                            aggfunc=np.mean)\n#Calculate the mean across th entire dataset\nepl_mean_point[\"All\"] = epl_mean_point.mean(axis=1)\n\n#Array of team points average as a list for the heatmap\nz= epl_mean_point.fillna(0).values\n# Seasons as columns \nx= epl_mean_point.columns.tolist()\n#team name on y-axis\ny= epl_mean_point.index.tolist()\n\n#List to store the hover-info\nepl_mean_text = []\n#list to store the annotated text\nepl_mean_annotated_text = []\n#loop to extract the details form the epl_mean_stats table to give end of the season information \nfor team in range(len(y)):\n    team_season_list = []\n    team_season_annotated = []\n    for year in range(len(x)-1):\n        if z[team][year] == 0:\n            #team was not present in the epl for that season\n            team_season_list.append('')\n            team_season_annotated.append('')\n        else:\n            #subset the row with the selected row and season\n            selected_row = epl_team_stats[epl_team_stats.stage.eq(38)&\n                                          epl_team_stats.team_name_stats.eq(y[team])&\n                                          epl_team_stats.season.eq(x[year])]\n            team_season_list.append(\"\".join(\n                [\"Team: \",y[team],\"<br>\",\n                 \"Season: \",x[year],\",<br>\",\n                 \"Total Points: \", str(selected_row.cum_points.values[0]),\"<br>\",\n                 \"Average Pts per game\", str(round(z[team][year], 3))\n                ]\n            ))\n            team_season_annotated.append(str(int(selected_row.table_position)))\n    team_season_list.append(\"\".join([\"Avg over all seasons: \", str(round(z[team][year+1],4))]))\n    team_season_annotated.append('')\n    epl_mean_text.append(team_season_list)\n    epl_mean_annotated_text.append(team_season_annotated)\n    \nann_heatmap = ff.create_annotated_heatmap(x=x, y=y, z=z, annotation_text=epl_mean_annotated_text, text=epl_mean_text,\n                                          colorscale='Jet', font_colors =['Black'], hoverinfo='text', showscale= True\n                                         )\nann_heatmap.layout.height = 1250\nann_heatmap.layout.yaxis.automargin = True\niplot(ann_heatmap)","59eb77ee":"Looks the columns from goal - posession consist of xml data, it would be a good idea to inspect this xml file closely, to figure out if we can get more information.","1942e66c":"Aha! Everything is working out fine. Even the 4th & 5th position tie was properly resolved. The extreme ends of the dataset are verified. I am glad that this dataset is pretty clean.","775423d6":"Lets retrive the team attributes from the database and join them with the team in each row","ba5920d8":"<p>Based on the output of the above two outputs, it seems that there are team attribute data of 6 seasons each.<\/p>","8d74c613":"So based on the above results we can conclude that each season has 380 matches in the premier league. Which serves properly because, there are 20 teams. Each team will play in each round against another team and thus each team plays 38 matches in a seaon per round.\nTotal Matches = 38 rounds * 10 matches per round. \nThus 380 seems a right number.\n\nLets have a look at the data contained in the epl dataset and try to figure out if there is any additional details we can extract from the columns.","5914ebcc":"Looking at the heatmap, there are some observations we can put forth.\n- Teams having point avergae of less than 1 have very high chance of relagation, having less than 0.9(i.e <34) they are always relagated. Interestingly, in the 2010-11 season, teams having 39 points were also relegated.\n- There are 9 teams which have maintained their status in the Premier League over the course of 8+ years.\n- Arsenal have been the most consistent performers during this periods, though never winning the league in the same period.\n- Manchester united have been the most successful during the 8 seasons, having won 3 league titles. After the 2012-13 season, there has been a drop off in their league consistency, which we can say might be due to the departure of their coach.\n- Following United, Chelsea and Manchester City have been the most sucessfull, each winning the league title twice.\n- At the other end of the spectrum, Sunderland has been able to maintain their place in premier league even after flirting with relagation during the 8 year period.","1453338a":"The xml statements have loads of infomration. Having a look at the above result, we can see that it contains detailed information about the goal scored, the time the goal was scored, the team and the player who scored, the shot which he took. Similarly, I had closer look at all the other columns containing the XML data type & they also had very detailed information regarding each incident\/event that took place. Let's try and extract at least a high level overview of all these data, so we can get the match statistics. We might have to use an XML parser.","0e0fe662":"So there are 5 matches which have no data at all. There is one match which we can still extract the data. I'll have a look at it later and try to improve my function.","d53fd77b":"Soccer is one of the most exciting sport in the world. I know it might be insulting slightly, hearing the word Soccer, but hence forth I will refer it to as football because as a fan and follower of the sport, I .Based on the popularity, it is the most followed sport. In comparison to other sports, Football is played globally with differents leagues in different countries and there are a lot of people which are involved in this sports. From people working as scouts and coaches from the local clubs upto top players and management who earn million of euro's by being in this profession.\n\nThe data presented here is very exciting, there are so many things which this database contains like Match , Player & League Stats, with so much numbers present and the fact that I have been following football for almost 10 years, I think I should try my hand on this dataset, to excersie my quant skills and see if I can find answers to some things which has always comes up when watching the matches especially in terms of strategy and given the fact that this dataset contains information about those attributes, I think I will have good time going over the data and learn a lot along the way.\n\n**League Chosen**\n\nEven though the dataset contains so many League data, I feel going with the English Premier League would be a good idea. It has a large number of followers and the past years has created a lot of excitment with Leicester City winning the 2015-2016 premier league, Manchester City winning the league on the last day in 2011-12, 2013-14 & 2018-19. A lot keeps on happening, lets try and see what the reason behind this phenomenon.\n\nSome of the question which I will try to answer:\nWhich teams have been consistently performing well?\nWhat are the team attributes which contributes to the result?\nWhich kind of players are the most valuable in such a winning team setup?\nWhether the transfer amount which a club pays is worth it or not?\nWhat kind of stratgies work against each other?\n\nIn the process, I hope to gain valuable analytics skills and even work with tools like SQL, Pandas & Numpy. Exploring this data will be a lot of fun and I will try to update it if and when possible.","ae8fc490":"<img src=\"https:\/\/i.imgur.com\/BFatIV5.png\" width=500px><\/img>","3017c80b":"<img src=\"https:\/\/i.imgur.com\/A5oJI6J.png\" width=500px><\/img>","f303e7ee":"Looking at the last two columns we can see that there are about 6 games whose possession stats were not available. Thats not too bad.","4f4060c1":"Based on the initial glance of team & date, there might be only 6 seasons data for team attributes in contrast to 8 seasons of match data. The data must have been collected at a random match day in each season.","ec7176a8":"Seems like a proper match for the first round of 2008\/2009 season\nLets have a look at the final round of the 2015\/2016 season. Just to be sure whether everything is working right"}}