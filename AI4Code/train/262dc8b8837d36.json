{"cell_type":{"9d3a6ca9":"code","d3b251d7":"code","9d367331":"code","14011250":"code","fddc5614":"code","a1025c4f":"code","01b0926b":"code","5df7c2e0":"code","41c0a1f6":"code","255007cc":"code","f42cd442":"code","86c3c416":"code","26356e24":"code","53e2d020":"code","e2f6aca2":"code","d75848e6":"code","8212b4bb":"code","a758e0c5":"code","6e6a912d":"code","2ba3205b":"code","ed5a04c4":"code","1edd5393":"code","4b3ee3db":"code","0e300f89":"code","eb866a63":"code","1b907d27":"code","6e3134df":"code","9155558d":"code","abd588d0":"code","98d3629c":"code","f4a12cc4":"code","f3fdeab1":"code","aa82956e":"code","b6ee7c73":"code","62e7574a":"code","5b815bf0":"code","e4c92c1f":"code","b318c8ef":"code","ed77c592":"code","db330751":"code","7d767acf":"code","c2b2f3c1":"code","cc1620a6":"code","0a382a58":"code","53f69f86":"code","8d997846":"code","41ea29f5":"code","44894ee1":"code","b50ec1ee":"code","4022c806":"code","b2ff8f88":"code","fa134c74":"code","89af82df":"code","af3ab1d7":"code","9b77e1ad":"code","73ace90e":"code","18b11a91":"code","0313cf5b":"code","ada7da2a":"code","bb05a31a":"code","8b001fdf":"code","e7b0d580":"code","ecf8a54a":"code","77445270":"code","eb0e0a7e":"markdown","193e8a9b":"markdown","2c36a363":"markdown","988e6d35":"markdown","31432366":"markdown","e62cdfdf":"markdown","8edf8926":"markdown","f3330d62":"markdown","cdc2e1c4":"markdown"},"source":{"9d3a6ca9":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport zipfile\nimport cv2\nfrom skimage import io\nimport tensorflow as tf\nfrom tensorflow.python.keras import Sequential\nfrom tensorflow.keras import layers, optimizers\nfrom tensorflow.keras.applications import EfficientNetB4\nfrom tensorflow.keras.layers import *\nfrom tensorflow.keras.models import Model, load_model\nfrom tensorflow.keras.initializers import glorot_uniform\nfrom tensorflow.keras.utils import plot_model\nfrom tensorflow.keras.callbacks import ReduceLROnPlateau, EarlyStopping, ModelCheckpoint, LearningRateScheduler\nfrom IPython.display import display\nfrom tensorflow.keras import backend as K\nfrom sklearn.preprocessing import StandardScaler, normalize\nimport os\nimport glob\nimport random\n%matplotlib inline","d3b251d7":"# Navigate to My Drive directory to store the dataset\n%cd \/kaggle\/input\/healthcare-mri-for-brain-tumor\/Healthcare AI Datasets\/Brain_MRI\n","9d367331":"# data containing path to Brain MRI and their corresponding mask\nbrain_df = pd.read_csv('data_mask.csv')","14011250":"brain_df.info()","fddc5614":"brain_df.head()","a1025c4f":"brain_df.mask_path[1] # Path to the brain MRI image","01b0926b":"brain_df.image_path[1] # Path to the segmentation mask","5df7c2e0":"brain_df[:5]","41c0a1f6":"brain_df['mask'].value_counts().index","255007cc":"# Use plotly to plot interactive bar chart\nimport plotly.graph_objects as go\n\nfig = go.Figure([go.Bar(x = brain_df['mask'].value_counts().index, y = brain_df['mask'].value_counts())])\nfig.update_traces(marker_color = 'rgb(0,200,0)', marker_line_color = 'rgb(0,0,0)',\n                  marker_line_width = 2, opacity = 0.6)\nfig.show()","f42cd442":"# Obtain the percentage of images with mask\nround((brain_df['mask'].value_counts()* 100 \/ len(brain_df['mask'])),2)","86c3c416":"brain_df.mask_path[:5]","26356e24":"brain_df.image_path[:5]","53e2d020":"plt.figure(figsize=(10,10))\nplt.imshow(cv2.imread(brain_df.mask_path[2490]))\nplt.show()","e2f6aca2":"plt.figure(figsize=(10,10))\nplt.imshow(cv2.imread(brain_df.image_path[2490]))\nplt.show()","d75848e6":"cv2.imread(brain_df.mask_path[2490]).max()","8212b4bb":"cv2.imread(brain_df.mask_path[2490]).min()","a758e0c5":"# Basic visualizations: Visualize the images (MRI and Mask) in the dataset separately \nimport random\nfig, axs = plt.subplots(5,2, figsize=(20,40))\ncount = 0\nfor x in range(5):\n  i = random.randint(0, len(brain_df)) # select a random index \n  axs[count][0].title.set_text(\"Brain MRI\") # set title\n  axs[count][0].imshow(cv2.imread(brain_df.image_path[i])) # show MRI \n  axs[count][1].title.set_text(\"Mask : \" + str(brain_df['mask'][i])) # plot title on the mask (0 or 1)\n  axs[count][1].imshow(cv2.imread(brain_df.mask_path[i])) # Show corresponding mask\n  count += 1\n\nfig.tight_layout()","6e6a912d":"# Advanced Visualization: visualize the MRI scans along with their mask on one image \ncount = 0\nfig, axs = plt.subplots(10, 3, figsize = (20, 40))\nfor i in range(len(brain_df)):\n  if brain_df['mask'][i] ==1 and count <10:\n    img = io.imread(brain_df.image_path[i])\n    axs[count][0].title.set_text('Brain MRI')\n    axs[count][0].imshow(img)\n\n    mask = io.imread(brain_df.mask_path[i])\n    axs[count][1].title.set_text('Mask')\n    axs[count][1].imshow(mask, cmap = 'gray')\n\n    \n    img[mask == 255] = (255, 0, 0)\n    axs[count][2].title.set_text('MRI with Mask')\n    axs[count][2].imshow(img)\n    count+=1\n\nfig.tight_layout()\n","2ba3205b":"# Drop the patient id column\nbrain_df_train = brain_df.drop(columns = ['patient_id'])\nbrain_df_train.shape","ed5a04c4":"# Convert the data in mask column to string format, to use categorical mode in flow_from_dataframe\nbrain_df_train['mask'] = brain_df_train['mask'].apply(lambda x: str(x))","1edd5393":"brain_df_train.info()","4b3ee3db":"# split the data into train and test data\n\nfrom sklearn.model_selection import train_test_split\n\ntrain, test = train_test_split(brain_df_train, test_size = 0.2,random_state=42)","0e300f89":"# create a image generator\nfrom keras_preprocessing.image import ImageDataGenerator\n\n# Create a data generator which scales the data from 0 to 1 and makes validation split of 0.1\ndatagen = ImageDataGenerator(rescale=1.\/255., validation_split = 0.1)\n","eb866a63":"train_generator=datagen.flow_from_dataframe(\ndataframe=train,\ndirectory= '.\/',\nx_col='image_path',\ny_col='mask',\nsubset=\"training\",\nbatch_size=16,\nshuffle=True,\nclass_mode=\"categorical\",\ntarget_size=(256,256))\n\n\nvalid_generator=datagen.flow_from_dataframe(\ndataframe=train,\ndirectory= '.\/',\nx_col='image_path',\ny_col='mask',\nsubset=\"validation\",\nbatch_size=16,\nshuffle=True,\nclass_mode=\"categorical\",\ntarget_size=(256,256))\n\n# Create a data generator for test images\ntest_datagen=ImageDataGenerator(rescale=1.\/255.)\n\ntest_generator=test_datagen.flow_from_dataframe(\ndataframe=test,\ndirectory= '.\/',\nx_col='image_path',\ny_col='mask',\nbatch_size=16,\nshuffle=False,\nclass_mode='categorical',\ntarget_size=(256,256))\n\n","1b907d27":"# Get the EfficientNetB4 base model\nbasemodel =EfficientNetB4(weights = 'imagenet', include_top = False, input_tensor = Input(shape=(256, 256, 3)))","6e3134df":"basemodel.summary()","9155558d":"# freeze the model weights\n\nfor layer in basemodel.layers:\n  layers.trainable = False","abd588d0":"# Add classification head to the base model\n\nheadmodel = basemodel.output\nheadmodel = AveragePooling2D(pool_size = (4,4))(headmodel)\nheadmodel = Flatten(name= 'flatten')(headmodel)\nheadmodel = Dense(256, activation = \"relu\")(headmodel)\nheadmodel = Dropout(0.25)(headmodel)#\nheadmodel = Dense(256, activation = \"relu\")(headmodel)\nheadmodel = Dropout(0.25)(headmodel)\nheadmodel = Dense(256, activation = \"relu\")(headmodel)\nheadmodel = Dropout(0.25)(headmodel)\nheadmodel = Dense(2, activation = 'softmax')(headmodel)\n\nmodel = Model(inputs = basemodel.input, outputs = headmodel)","98d3629c":"model.summary()","f4a12cc4":"earlystopping = EarlyStopping(monitor='val_loss', \n                              mode='min', \n                              verbose=1, \n                              patience=25\n                             )\ncheckpointer = ModelCheckpoint(filepath=\"\/kaggle\/working\/classifier-resnet-weights.hdf5\", \n                               verbose=1, \n                               save_best_only=True\n                              )\nreduce_lr = ReduceLROnPlateau(monitor='val_loss',\n                              mode='min',\n                              verbose=1,\n                              patience=10,\n                              min_delta=0.0001,\n                              factor=0.2\n                             )\ncallbacks = [checkpointer, earlystopping, reduce_lr]","f3fdeab1":"# compile the model\n\nmodel.compile(loss = 'categorical_crossentropy', optimizer='adam', metrics= [\"accuracy\"])","aa82956e":"history = model.fit(train_generator, \n              steps_per_epoch= train_generator.n \/\/ train_generator.batch_size, \n              epochs = 100, \n              validation_data= valid_generator, \n              validation_steps= valid_generator.n \/\/ valid_generator.batch_size, \n              callbacks = [checkpointer, earlystopping, reduce_lr])","b6ee7c73":"model_json = model.to_json()\nwith open(\"\/kaggle\/working\/classifierresnetmodel.json\", \"w\") as json_file:\n    json_file.write(model_json)","62e7574a":"with open('\/kaggle\/working\/classifierresnetmodel.json', 'r') as json_file:\n    json_savedModel= json_file.read()\n# load the model  \nmodel = tf.keras.models.model_from_json(json_savedModel)\nmodel.load_weights('\/kaggle\/working\/classifier-resnet-weights.hdf5')\nmodel.compile(loss = 'categorical_crossentropy', optimizer='adam', metrics= [\"accuracy\"])","5b815bf0":"# make prediction\n\ntest_predict = model.predict(test_generator, steps = test_generator.n \/\/ 16, verbose =1)","e4c92c1f":"test_predict.shape","b318c8ef":"test_predict[:5]","ed77c592":"# Obtain the predicted class from the model prediction\npredict = []\n\nfor i in test_predict:\n  predict.append(str(np.argmax(i)))\n\npredict = np.asarray(predict)","db330751":"predict","7d767acf":"# since we have used test generator, it limited the images to len(predict), due to batch size\noriginal = np.asarray(test['mask'])[:len(predict)]\nlen(original)","c2b2f3c1":"# Obtain the accuracy of the model\nfrom sklearn.metrics import accuracy_score\n\naccuracy = round(accuracy_score(original, predict),2)\naccuracy","cc1620a6":"# plot the confusion matrix\nfrom sklearn.metrics import confusion_matrix\n\ncm = confusion_matrix(original, predict)\nplt.figure(figsize = (7,7))\nsns.heatmap(cm, annot=True,fmt='d')\nplt.show()","0a382a58":"from sklearn.metrics import classification_report\n\nreport = classification_report(original, predict, labels = [0,1])\nprint(report)","53f69f86":"# Get the dataframe containing MRIs which have masks associated with them.\nbrain_df_mask = brain_df[brain_df['mask'] == 1]\nbrain_df_mask.shape","8d997846":"# split the data into train and test data\n\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_val = train_test_split(brain_df_mask, test_size=0.2,random_state=42)\nX_test, X_val = train_test_split(X_val, test_size=0.5,random_state=42)","41ea29f5":"X_train.shape,X_test.shape, X_val.shape","44894ee1":"# create separate list for imageId, classId to pass into the generator\n\ntrain_ids = list(X_train.image_path)\ntrain_mask = list(X_train.mask_path)\n\nval_ids = list(X_val.image_path)\nval_mask= list(X_val.mask_path)","b50ec1ee":"# Utilities file contains the code for custom loss function and custom data generator\nfrom utilities import DataGenerator\n\n# create image generators\n\ntraining_generator = DataGenerator(train_ids,train_mask)\nvalidation_generator = DataGenerator(val_ids,val_mask)","4022c806":"def resblock(X, f):\n  \n\n  # make a copy of input\n  X_copy = X\n\n  # main path\n  # Read more about he_normal: https:\/\/medium.com\/@prateekvishnu\/xavier-and-he-normal-he-et-al-initialization-8e3d7a087528\n\n  X = Conv2D(f, kernel_size = (1,1) ,strides = (1,1),kernel_initializer ='he_normal')(X)\n  X = BatchNormalization()(X)\n  X = Activation('relu')(X) \n\n  X = Conv2D(f, kernel_size = (3,3), strides =(1,1), padding = 'same', kernel_initializer ='he_normal')(X)\n  X = BatchNormalization()(X)\n\n  # Short path\n  # Read more here: https:\/\/towardsdatascience.com\/understanding-and-coding-a-resnet-in-keras-446d7ff84d33\n\n  X_copy = Conv2D(f, kernel_size = (1,1), strides =(1,1), kernel_initializer ='he_normal')(X_copy)\n  X_copy = BatchNormalization()(X_copy)\n\n  # Adding the output from main path and short path together\n\n  X = Add()([X,X_copy])\n  X = Activation('relu')(X)\n\n  return X","b2ff8f88":"# function to upscale and concatenate the values passsed\ndef upsample_concat(x, skip):\n  x = UpSampling2D((2,2))(x)\n  merge = Concatenate()([x, skip])\n\n  return merge","fa134c74":"input_shape = (256,256,3)\n\n# Input tensor shape\nX_input = Input(input_shape)\n\n# Stage 1\nconv1_in = Conv2D(16,3,activation= 'relu', padding = 'same', kernel_initializer ='he_normal')(X_input)\nconv1_in = BatchNormalization()(conv1_in)\nconv1_in = Conv2D(16,3,activation= 'relu', padding = 'same', kernel_initializer ='he_normal')(conv1_in)\nconv1_in = BatchNormalization()(conv1_in)\npool_1 = MaxPool2D(pool_size = (2,2))(conv1_in)\n\n# Stage 2\nconv2_in = resblock(pool_1, 32)\npool_2 = MaxPool2D(pool_size = (2,2))(conv2_in)\n\n# Stage 3\nconv3_in = resblock(pool_2, 64)\npool_3 = MaxPool2D(pool_size = (2,2))(conv3_in)\n\n# Stage 4\nconv4_in = resblock(pool_3, 128)\npool_4 = MaxPool2D(pool_size = (2,2))(conv4_in)\n\n# Stage 5 (Bottle Neck)\nconv5_in = resblock(pool_4, 256)\n\n# Upscale stage 1\nup_1 = upsample_concat(conv5_in, conv4_in)\nup_1 = resblock(up_1, 128)\n\n# Upscale stage 2\nup_2 = upsample_concat(up_1, conv3_in)\nup_2 = resblock(up_2, 64)\n\n# Upscale stage 3\nup_3 = upsample_concat(up_2, conv2_in)\nup_3 = resblock(up_3, 32)\n\n# Upscale stage 4\nup_4 = upsample_concat(up_3, conv1_in)\nup_4 = resblock(up_4, 16)\n\n# Final Output\noutput = Conv2D(1, (1,1), padding = \"same\", activation = \"sigmoid\")(up_4)\n\nmodel_seg = Model(inputs = X_input, outputs = output )\n","89af82df":"model_seg.summary()","af3ab1d7":"\"\"\"@article{focal-unet,\n  title={A novel Focal Tversky loss function with improved Attention U-Net for lesion segmentation},\n  author={Abraham, Nabila and Khan, Naimul Mefraz},\n  journal={arXiv preprint arXiv:1810.07842},\n  year={2018}\n}\"\"\"","9b77e1ad":"# Utilities file contains the code for custom loss function and custom data generator\n\nfrom utilities import tversky_loss, tversky","73ace90e":"def focal_tversky(y_true,y_pred):\n    ## IMPORTANT NOTE:\n    ## It seems that the type of y_true and y_pred are not the same. One is of type\n    ## float32 and other int64. They need to be cast as the same type for the training\n    ## to actually work.\n    y_true = tf.cast(y_true, tf.float32)\n    y_pred = tf.cast(y_pred, tf.float32)\n    #print(type(y_pred))\n    pt_1 = tversky(y_true, y_pred)\n    gamma = 0.75\n    return K.pow((1-pt_1), gamma)","18b11a91":"# compling model and callbacks functions\nadam = tf.keras.optimizers.Adam(lr = 0.05, epsilon = 0.1)\nmodel_seg.compile(optimizer = adam, \n                  loss = focal_tversky, \n                  metrics = [tversky]\n                 )\n#callbacks\nearlystopping = EarlyStopping(monitor='val_loss',\n                              mode='min', \n                              verbose=1, \n                              patience=25\n                             )\n# save the best model with lower validation loss\ncheckpointer = ModelCheckpoint(filepath=\"\/kaggle\/workingResUNet-weights.hdf5\", \n                               verbose=1, \n                               save_best_only=True\n                              )\nreduce_lr = ReduceLROnPlateau(monitor='val_loss',\n                              mode='min',\n                              verbose=1,\n                              patience=10,\n                              min_delta=0.0001,\n                              factor=0.2\n                             )","0313cf5b":"history = model_seg.fit(training_generator, epochs = 1000, validation_data = validation_generator,\n                        callbacks = [checkpointer, earlystopping,reduce_lr])","ada7da2a":"# save the model architecture to json file for future use\n\nmodel_json = model_seg.to_json()\nwith open(\"\/kaggle\/working\/ResUNet-model.json\",\"w\") as json_file:\n  json_file.write(model_json)","bb05a31a":"from utilities import focal_tversky, tversky_loss, tversky\n\nwith open('\/kaggle\/input\/healthcare-mri-for-brain-tumor\/Healthcare AI Datasets\/Brain_MRI\/ResUNet-MRI.json', 'r') as json_file:\n    json_savedModel= json_file.read()\n\n# load the model architecture \nmodel_seg = tf.keras.models.model_from_json(json_savedModel)\nmodel_seg.load_weights('\/kaggle\/input\/healthcare-mri-for-brain-tumor\/Healthcare AI Datasets\/Brain_MRI\/weights_seg.hdf5')\nadam = tf.keras.optimizers.Adam(lr = 0.05, epsilon = 0.1)\nmodel_seg.compile(optimizer = adam, loss = focal_tversky, metrics = [tversky])","8b001fdf":"# Utilities file contains the code for custom loss function and custom data generator\nfrom utilities import prediction\n\n# making prediction\nimage_id, mask, has_mask = prediction(test, model, model_seg)","e7b0d580":"# creating a dataframe for the result\ndf_pred = pd.DataFrame({'image_path': image_id,'predicted_mask': mask,'has_mask': has_mask})\ndf_pred.head()","ecf8a54a":"# Merge the dataframe containing predicted results with the original test data.\ndf_pred = test.merge(df_pred, on = 'image_path')\ndf_pred.head()","77445270":"count = 0 \nfig, axs = plt.subplots(12, 5, figsize=(30,90))\nfor i in range(len(df_pred)):\n  if df_pred['has_mask'][i] == 1 and count < 12:\n    # read the images and convert them to RGB format\n    img = io.imread(df_pred.image_path[i])\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    axs[count][0].title.set_text(\"Brain MRI\")\n    axs[count][0].imshow(img)\n\n    # Obtain the mask for the image \n    mask = io.imread(df_pred.mask_path[i])\n    axs[count][1].title.set_text(\"Original Mask\")\n    axs[count][1].imshow(mask)\n\n    # Obtain the predicted mask for the image \n    predicted_mask = np.asarray(df_pred.predicted_mask[i])[0].squeeze().round()\n    axs[count][2].title.set_text(\"AI Predicted Mask\")\n    axs[count][2].imshow(predicted_mask)\n    \n    # Apply the mask to the image 'mask==255'\n    img[mask == 255] = (255, 0, 0)\n    axs[count][3].title.set_text(\"MRI with Original Mask (Ground Truth)\")\n    axs[count][3].imshow(img)\n\n    img_ = io.imread(df_pred.image_path[i])\n    img_ = cv2.cvtColor(img_, cv2.COLOR_BGR2RGB)\n    img_[predicted_mask == 1] = (0, 255, 0)\n    axs[count][4].title.set_text(\"MRI with AI Predicted Mask\")\n    axs[count][4].imshow(img_)\n    count += 1\n\nfig.tight_layout()","eb0e0a7e":"# ASSESS TRAINED MODEL PERFORMANCE","193e8a9b":"# PERFORM DATA VISUALIZATION","2c36a363":"#  IMPORT LIBRARIES AND DATASETS","988e6d35":"# BUILD A SEGMENTATION MODEL TO LOCALIZE TUMOR","31432366":"#  ASSESS TRAINED SEGMENTATION RESUNET MODEL PERFORMANCE","e62cdfdf":"## Loss function:\n \nWe need a custom loss function to train this ResUNet.So,  we have used the loss function as it is from https:\/\/github.com\/nabsabraham\/focal-tversky-unet\/blob\/master\/losses.py\n\n\n","8edf8926":"# TRAIN A CLASSIFIER MODEL TO DETECT IF TUMOR EXISTS OR NOT","f3330d62":"# Save the model architecture to json file for future use\n","cdc2e1c4":"# TRAIN A SEGMENTATION RESUNET MODEL TO LOCALIZE TUMOR"}}