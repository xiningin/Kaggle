{"cell_type":{"dab754df":"code","048f5d8d":"code","19bbd0b7":"code","7282e413":"code","0ff219c9":"code","033c1e86":"code","003e752b":"code","54b0b5ff":"code","e937f58f":"code","7e389e4d":"code","79193b85":"code","a763b720":"code","cdf8e937":"code","a4f828e8":"code","bf98f45a":"code","5e974f91":"code","6c10e0b6":"code","8c7ac803":"code","94243290":"code","de70c73a":"code","14b60ab4":"code","5564d983":"code","dfd46f8f":"code","03f7c132":"code","1233ba08":"code","6a004ee5":"code","36330691":"code","30930961":"code","935b0a95":"code","55bc3315":"markdown","6da83692":"markdown","301e4ad2":"markdown","bb2a784c":"markdown","cfa39362":"markdown","6a9bcc69":"markdown","b76611dc":"markdown","d1c2495f":"markdown","893de4e0":"markdown","fad6747c":"markdown","41bf50a9":"markdown","4ea5d8f5":"markdown","e861e056":"markdown","666cf72b":"markdown","8440c266":"markdown","8f0e55e8":"markdown","3645d736":"markdown","c39f2989":"markdown","d667da83":"markdown","615b018b":"markdown","fe3809f1":"markdown","bc7561aa":"markdown","d4a08f38":"markdown","d29eda43":"markdown","6cdfe59e":"markdown"},"source":{"dab754df":"import os \nimport pandas as pd\nimport seaborn as sns\nimport numpy as np\n\nfrom sklearn.cluster import KMeans\nfrom sklearn.metrics import silhouette_score\nfrom sklearn.preprocessing import LabelBinarizer, MultiLabelBinarizer, MinMaxScaler\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.neighbors import NearestNeighbors\nfrom scipy.sparse import csr_matrix\nfrom sklearn.decomposition import PCA\n\n\n","048f5d8d":"usecols = [\"MAL_ID\", \"Name\", \"Score\", \"Genres\", \"Type\", \"Episodes\", \"Premiered\",\n           \"Studios\", \"Source\", \"Rating\", \"Members\"]\nanime_recom =pd.read_csv('..\/input\/anime-recommendation-database-2020\/anime.csv',usecols=usecols)\nrating_data = pd.read_csv('..\/input\/anime-recommendation-database-2020\/rating_complete.csv')\nanime = pd.read_csv('..\/input\/anime-recommendation-database-2020\/anime.csv',low_memory=True)","19bbd0b7":"anime.rename(columns = {'MAL_ID':'anime_id'},inplace=True)\nrating_data.rename(columns = {'MAL_ID':'anime_id'},inplace=True)","7282e413":"def process_multilabel(series):\n    series = series.split(\",\")\n    if \"Unknown\" in series:\n        series.remove(\"Unknown\")\n    return series\n\nanime_recom[\"Genres\"] = anime_recom[\"Genres\"].map(process_multilabel)\nanime_recom[\"Studios\"] = anime_recom[\"Studios\"].map(process_multilabel)\nanime_recom[\"Score\"] = anime_recom[\"Score\"].replace(\"Unknown\", 0).astype(float)\nanime_recom[\"Episodes\"] = anime_recom[\"Episodes\"].replace(\"Unknown\", 0).astype(int)\nanime_recom.head()","0ff219c9":"def preprocessing_category(df, column, is_multilabel=False):\n    \n    # Binarise labels\n    lb = LabelBinarizer()\n    if is_multilabel:\n        lb = MultiLabelBinarizer()\n\n    expandedLabelData = lb.fit_transform(df[column])\n    labelClasses = lb.classes_\n\n    # Create a pandas.DataFrame from our output\n    category_df = pd.DataFrame(expandedLabelData, columns=labelClasses)\n    del df[column]\n    return pd.concat([df, category_df], axis=1)\n\nanime_metadata = anime_recom.copy()\nanime_metadata = preprocessing_category(anime_metadata, \"Type\")\nanime_metadata = preprocessing_category(anime_metadata, \"Premiered\")\nanime_metadata = preprocessing_category(anime_metadata, \"Studios\", is_multilabel=True)\nanime_metadata = preprocessing_category(anime_metadata, \"Source\")\nanime_metadata = preprocessing_category(anime_metadata, \"Rating\")\n\nGenres = anime_metadata[\"Genres\"]\nID_NAME = anime_metadata[[\"MAL_ID\", \"Name\"]]\n\n#Deleting Repeated Columns from the Dataframe\ndel anime_metadata[\"Genres\"]\ndel anime_metadata[\"MAL_ID\"]\ndel anime_metadata[\"Name\"]\ndel anime_metadata[\"Unknown\"]","033c1e86":"anime_metadata[[\"Score\", \"Episodes\", \"Members\"]] = MinMaxScaler().fit_transform(anime_metadata[[\"Score\", \"Episodes\", \"Members\"]])\nanime_metadata = anime_metadata.values","003e752b":"from sklearn.feature_extraction.text import TfidfVectorizer\n\ntfv = TfidfVectorizer(min_df=3,  max_features=None, \n            strip_accents='unicode', analyzer='word',token_pattern=r'\\w{1,}',\n            ngram_range=(1, 3),\n            stop_words = 'english')\n\n# Filling NaNs with empty string\ngenres_original = anime_recom['Genres'].fillna('').astype(str)\ngenres_vector_tf_idf = tfv.fit_transform(genres_original)\n\ngenres_vector_one_hot = preprocessing_category(pd.DataFrame(Genres), \"Genres\", True).values","54b0b5ff":"print(\"anime_metadata.shape:\", anime_metadata.shape)\nprint(\"genres_vector_tf_idf.shape:\", genres_vector_tf_idf.shape)\nprint(\"genres_vector_one_hot.shape:\", genres_vector_one_hot.shape)","e937f58f":"def get_recommended(vector, query_index, n_neighbors=10):\n    model_knn = NearestNeighbors(metric='cosine', n_neighbors=n_neighbors)\n    model_knn.fit(csr_matrix(vector))\n\n    distances, indices = model_knn.kneighbors(vector[query_index,:].reshape(1, -1), n_neighbors = n_neighbors)\n    result = []\n    for i in range(0, len(distances.flatten())):\n        index = indices.flatten()[i]\n        if index == query_index:\n            continue\n        result.append(anime_recom.iloc[index])\n        \n    return pd.DataFrame(result)","7e389e4d":"query_index = ID_NAME[ID_NAME.MAL_ID == 5231].index[0]\nanime_recom.iloc[[query_index]]","79193b85":"get_recommended(anime_metadata, query_index, 10)","a763b720":"get_recommended(genres_vector_tf_idf, query_index, 10)","cdf8e937":"get_recommended(genres_vector_one_hot, query_index, 10)","a4f828e8":"all_data = np.concatenate((anime_metadata, genres_vector_tf_idf.todense(), genres_vector_one_hot), axis=1)\nall_data.shape","bf98f45a":"get_recommended(all_data, query_index, 10)","5e974f91":"reduced_all_data = PCA(n_components=250).fit_transform(all_data)\nget_recommended(reduced_all_data, query_index, 10)","6c10e0b6":"users_count = rating_data.groupby(\"user_id\").size().reset_index()\nusers_count.columns = [\"user_id\", \"anime_count\"]\n\nprint(users_count.shape)\n\nfiltered_users = users_count[users_count.anime_count >= 300]\nusers = set(filtered_users.user_id)\n\nprint(len(users))","8c7ac803":"rating_data = rating_data[rating_data.user_id.isin(users)]\nprint (\"rating_data.shape:\", rating_data.shape)\nprint (rating_data.info())","94243290":"unique_users = {int(x): i for i,x in enumerate(rating_data.user_id.unique())}\nunique_items = {int(x): i for i,x in enumerate(anime_recom.MAL_ID.unique())}\nprint(len(unique_items), len(unique_users))\n\nanime_collabolative_filter = np.zeros((len(unique_items), len(unique_users)))\n\nfor user_id, anime_id, rating in rating_data.values:\n    anime_collabolative_filter[unique_items[anime_id], unique_users[user_id]] = rating","de70c73a":"get_recommended(anime_collabolative_filter, query_index, 10)","14b60ab4":"df = pd.merge(rating_data,anime[[\"anime_id\",\"Name\"]], left_on = \"anime_id\", right_on = \"anime_id\").drop(\"anime_id\", axis = 1)\ndf.head()","5564d983":"count_rating = df.groupby(\"Name\")[\"rating\"].count().sort_values(ascending = False)\ncount_rating","dfd46f8f":"r = 10000\nmore_than_r_ratings = count_rating[count_rating.apply(lambda x: x >= r)].index\n\ndf_r = df[df['Name'].apply(lambda x: x in more_than_r_ratings)]","03f7c132":"df_r.info()","1233ba08":"df_recom = df_r.pivot_table(index='user_id',columns='Name',values='rating')\ndf_recom.iloc[:5,:5]","6a004ee5":"df_r.Name.value_counts().head(10)","36330691":"def find_corr(df, name):\n\n    similar_to_movie = df.corrwith(df[name])\n    similar_to_movie = pd.DataFrame(similar_to_movie,columns=['Correlation'])\n    similar_to_movie = similar_to_movie.sort_values(by = 'Correlation', ascending = False)\n    return similar_to_movie","30930961":"# Let's choose an anime\nanime1 = 'Naruto'\n\n# Let's try with \"Death Note\"\n\n# Recommendations\nfind_corr(df_recom, anime1).head(20)","935b0a95":"find_corr(df_recom, anime1).tail(10)","55bc3315":"#### 2.2 Normalization\n","6da83692":"* #### Recommendation based on Colaborative Filtering","301e4ad2":"# 1. Importing Libraries","bb2a784c":"* #### Preparing Data for Collaborating Filtering","cfa39362":"### 2.1 Feature Extraction and Feature Engineering","6a9bcc69":" ## Choose an Anime ","b76611dc":"* #### Arguments to the function are :\n    1.   ####   df (DataFrame):  with user_id as rows and movie titles as column and ratings as values\n    1.   ####   name (str): Name of the anime\n    \n* #### And it Returns a DataFrame with the correlation of the anime with all others\n        ","d1c2495f":"# 2. Recommendation","893de4e0":"# 3.2. Recommendations using Collaborative Filtering","fad6747c":"* ####  **Based on all Aspects**","41bf50a9":"* #### Function to remove Unknown values from Columns","4ea5d8f5":"* ####  **Based on Keywords of the anime**","e861e056":"* ####  **Based on Type and Studios**","666cf72b":"* #### Creating a pivot table for recommendation","8440c266":"* #### Select Anime Id on the basis of which recommendations will be done","8f0e55e8":"* #### Keeping only the animes with at least r ratings in the DataFrame","3645d736":"* #### Creating a Recommendation function using KNN Model","c39f2989":"* ####  **Based on Genres**","d667da83":"\n* #### Creating a function to get the correlation of one anime with others.\n    \n","615b018b":"# 3.3. Recommendation based on Similarity","fe3809f1":"# 3.1.  Content Based Recommendation using KNN","bc7561aa":"* #### Extracting  Keywords from the Dataframe","d4a08f38":"* ### Not Recommended","d29eda43":"* ####  **Based on Top Features**","6cdfe59e":"* #### Loading Datasets"}}