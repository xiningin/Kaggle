{"cell_type":{"9aff7411":"code","3c8718a9":"code","f886df43":"code","2f4c769a":"code","c1929677":"code","3bce96de":"code","2d5fc6c9":"code","7cffd5c2":"code","2b3da169":"code","82d2daa3":"code","7656bd0f":"code","0bdca3de":"code","99f243b4":"code","d3b57f9e":"code","5d4f7660":"code","2848fa92":"code","824730c1":"code","87c1a01c":"code","b4c8b554":"code","58109287":"code","cb9b2c54":"code","bef91364":"code","f6987e06":"code","40cb77d0":"code","951c0b29":"code","3226c108":"code","18e675cf":"code","48f7d467":"code","3323ed12":"code","f369d14b":"code","994bdcca":"code","a8ed9804":"code","052a7c2f":"code","918a7033":"markdown","f605e60b":"markdown","a56d3b78":"markdown","1d387ee7":"markdown","26a37d59":"markdown","fc00d788":"markdown"},"source":{"9aff7411":"!pip install git+git:\/\/github.com\/kvoyager\/GmdhPy.git","3c8718a9":"from gmdhpy.gmdh import Regressor\n# Importing the libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('fivethirtyeight')\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\nfrom keras.models import Sequential\nfrom keras.layers import Dense, LSTM, Dropout, GRU, Bidirectional\nfrom keras.optimizers import SGD\nimport math\nfrom sklearn.metrics import mean_squared_error","f886df43":"from sklearn.metrics import mean_absolute_error, r2_score","2f4c769a":"# Some functions to help out with\ndef plot_predictions(test,predicted):\n    plt.plot(test, color='red',label='Real Stock Price')\n    plt.plot(predicted, color='blue',label='Predicted Stock Price')\n    plt.title('Stock Price Prediction')\n    plt.xlabel('Time')\n    plt.ylabel('Stock Price')\n    plt.legend()\n    plt.figure(figsize=(16,4))\n    plt.show()\n\ndef return_rmse(test,predicted):\n    rmse = math.sqrt(mean_squared_error(test, predicted))\n    print(\"The root mean squared error is {}.\".format(rmse))\n    print(\"The MSE is {}\".format(mean_squared_error(test, predicted)))\n    print(\"The MAE is {}\".format(mean_absolute_error(test, predicted)))\n    print(\"The R2_Score is {}\".format(r2_score(test, predicted)))","c1929677":"# First, we get the data\ndataset = pd.read_csv('..\/input\/stock-time-series-20050101-to-20171231\/CSCO_2006-01-01_to_2018-01-01.csv', index_col='Date', parse_dates=['Date'])\ndataset.head()","3bce96de":"# Checking for missing values\ntraining_set = dataset[:'2016'].iloc[:,1:2].values\ntest_set = dataset['2017':].iloc[:,1:2].values","2d5fc6c9":"# We have chosen 'High' attribute for prices. Let's see what it looks like\ndataset[\"High\"][:'2016'].plot(figsize=(16,4),legend=True)\ndataset[\"High\"]['2017':].plot(figsize=(16,4),legend=True)\nplt.legend(['Training set (Before 2017)','Test set (2017 and beyond)'])\nplt.title('CSCO stock price')\nplt.show()","7cffd5c2":"# Scaling the training set\nsc = MinMaxScaler(feature_range=(0,1))\ntraining_set_scaled = sc.fit_transform(training_set)\n# print(training_set_scaled.shape)\nprint(training_set.shape)\nprint(test_set.shape)","2b3da169":"X_train = []\ny_train = []\nfor i in range(60,training_set.shape[0]):\n    X_train.append(training_set[i-60:i,0])\n    y_train.append(training_set[i,0])\nX_train, y_train = np.array(X_train), np.array(y_train)\nprint(X_train.shape)\nprint(y_train.shape)","82d2daa3":"gmdh = Regressor(ref_functions=('cubic','quadratic','linear','linear_cov'),\n                      criterion_type='validate',\n                      criterion_minimum_width=5,\n                      stop_train_epsilon_condition=0.0001,\n                      layer_err_criterion='top',\n                      l2=0.5,\n                      verbose=1,\n                      n_jobs='max')","7656bd0f":"# Now to get the test set ready in a similar way as the training set.\n# The following has been done so first 60 entires of test set have 60 previous values which is impossible to get unless we take the whole \n# 'High' attribute data for processing\ndataset_total = pd.concat((dataset[\"High\"][:'2016'],dataset[\"High\"]['2017':]),axis=0)\ninputs = dataset_total[len(dataset_total)-len(test_set) - 60:].values\n# print(inputs.shape)\ninputs = inputs.reshape(-1,1)\nprint(inputs.shape)\n\n# print(inputs.shape)\n# inputs  = sc.transform(inputs)\n# print(inputs.shape)\nprint(test_set.shape)","0bdca3de":"# Preparing X_test and predicting the prices\nX_test = []\ny_test = []\nfor i in range(60,inputs.shape[0]):\n    X_test.append(inputs[i-60:i,0])\n    y_test.append(inputs[i,0])\nX_test, y_test = np.array(X_test), np.array(y_test)\nprint(X_test.shape)\nprint(y_test.shape)\n# X_test = np.reshape(X_test, (X_test.shape[0],X_test.shape[1],1))\n","99f243b4":"gmdh.fit(X_train,y_train)","d3b57f9e":"predicted_stock_price = gmdh.predict(X_test)\nprint(predicted_stock_price.shape)\n# predicted_stock_price = regressor.predict(X_test)\n# predicted_stock_price.reshape(-1,1)\n# predicted_stock_price = sc.inverse_transform(predicted_stock_price)","5d4f7660":"plot_predictions(test_set,predicted_stock_price)","2848fa92":"return_rmse(y_test,predicted_stock_price)","824730c1":"from sklearn.metrics import r2_score\ny_test, predicted_stock_price = list(y_test),list(predicted_stock_price)\n# gmdh.score(y_test, predicted_stock_price)\nr2_score(y_test, predicted_stock_price)","87c1a01c":"k=144\nprint(y_test[k],predicted_stock_price[k])\n","b4c8b554":"# Since LSTMs store long term memory state, we create a data structure with 60 timesteps and 1 output\n# So for each element of training set, we have 60 previous training set elements \nX_train = []\ny_train = []\nfor i in range(60,2769):\n    X_train.append(training_set_scaled[i-60:i,0])\n    y_train.append(training_set_scaled[i,0])\nX_train, y_train = np.array(X_train), np.array(y_train)","58109287":"# Reshaping X_train for efficient modelling\nX_train = np.reshape(X_train, (X_train.shape[0],X_train.shape[1],1))","cb9b2c54":"# The LSTM architecture\nregressor = Sequential()\n# First LSTM layer with Dropout regularisation\nregressor.add(LSTM(units=50, return_sequences=True, input_shape=(X_train.shape[1],1)))\nregressor.add(Dropout(0.2))\n# Second LSTM layer\nregressor.add(LSTM(units=50, return_sequences=True))\nregressor.add(Dropout(0.2))\n# Third LSTM layer\nregressor.add(LSTM(units=50, return_sequences=True))\nregressor.add(Dropout(0.2))\n# Fourth LSTM layer\nregressor.add(LSTM(units=50))\nregressor.add(Dropout(0.2))\n# The output layer\nregressor.add(Dense(units=1))\n\n# Compiling the RNN\nregressor.compile(optimizer='rmsprop',loss='mean_squared_error')\n# Fitting to the training set\nregressor.fit(X_train,y_train,epochs=50,batch_size=32)","bef91364":"# Now to get the test set ready in a similar way as the training set.\n# The following has been done so forst 60 entires of test set have 60 previous values which is impossible to get unless we take the whole \n# 'High' attribute data for processing\ndataset_total = pd.concat((dataset[\"High\"][:'2016'],dataset[\"High\"]['2017':]),axis=0)\ninputs = dataset_total[len(dataset_total)-len(test_set) - 60:].values\ninputs = inputs.reshape(-1,1)\ninputs  = sc.transform(inputs)","f6987e06":"# Preparing X_test and predicting the prices\nX_test = []\nfor i in range(60,311):\n    X_test.append(inputs[i-60:i,0])\nX_test = np.array(X_test)\nX_test = np.reshape(X_test, (X_test.shape[0],X_test.shape[1],1))\n","40cb77d0":"predicted_stock_price = regressor.predict(X_test)\npredicted_stock_price = sc.inverse_transform(predicted_stock_price)","951c0b29":"# Visualizing the results for LSTM\nplot_predictions(test_set,predicted_stock_price)","3226c108":"# Evaluating our model\nreturn_rmse(test_set,predicted_stock_price)","18e675cf":"# The GRU architecture\nregressorGRU = Sequential()\n# First GRU layer with Dropout regularisation\nregressorGRU.add(GRU(units=50, return_sequences=True, input_shape=(X_train.shape[1],1), activation='tanh'))\nregressorGRU.add(Dropout(0.2))\n# Second GRU layer\nregressorGRU.add(GRU(units=50, return_sequences=True, input_shape=(X_train.shape[1],1), activation='tanh'))\nregressorGRU.add(Dropout(0.2))\n# Third GRU layer\nregressorGRU.add(GRU(units=50, return_sequences=True, input_shape=(X_train.shape[1],1), activation='tanh'))\nregressorGRU.add(Dropout(0.2))\n# Fourth GRU layer\nregressorGRU.add(GRU(units=50, activation='tanh'))\nregressorGRU.add(Dropout(0.2))\n# The output layer\nregressorGRU.add(Dense(units=1))\n# Compiling the RNN\nregressorGRU.compile(optimizer=SGD(lr=0.01, decay=1e-7, momentum=0.9, nesterov=False),loss='mean_squared_error')\n# Fitting to the training set\nregressorGRU.fit(X_train,y_train,epochs=50,batch_size=150)","48f7d467":"# Preparing X_test and predicting the prices\nX_test = []\nfor i in range(60,311):\n    X_test.append(inputs[i-60:i,0])\nX_test = np.array(X_test)\nX_test = np.reshape(X_test, (X_test.shape[0],X_test.shape[1],1))\nGRU_predicted_stock_price = regressorGRU.predict(X_test)\nGRU_predicted_stock_price = sc.inverse_transform(GRU_predicted_stock_price)","3323ed12":"# Visualizing the results for GRU\nplot_predictions(test_set,GRU_predicted_stock_price)","f369d14b":"# Evaluating GRU\nreturn_rmse(test_set,GRU_predicted_stock_price)","994bdcca":"# Preparing sequence data\ninitial_sequence = X_train[2708,:]\nsequence = []\nfor i in range(251):\n    new_prediction = regressorGRU.predict(initial_sequence.reshape(initial_sequence.shape[1],initial_sequence.shape[0],1))\n    initial_sequence = initial_sequence[1:]\n    initial_sequence = np.append(initial_sequence,new_prediction,axis=0)\n    sequence.append(new_prediction)\nsequence = sc.inverse_transform(np.array(sequence).reshape(251,1))","a8ed9804":"# Visualizing the sequence\nplot_predictions(test_set,sequence)","052a7c2f":"# Evaluating the sequence\nreturn_rmse(test_set,sequence)","918a7033":"Truth be told. That's one awesome score. \n\nLSTM is not the only kind of unit that has taken the world of Deep Learning by a storm. We have **Gated Recurrent Units(GRU)**. It's not known, which is better: GRU or LSTM becuase they have comparable performances. GRUs are easier to train than LSTMs.\n\n## Gated Recurrent Units\nIn simple words, the GRU unit does not have to use a memory unit to control the flow of information like the LSTM unit. It can directly makes use of the all hidden states without any control. GRUs have fewer parameters and thus may train a bit faster or need less data to generalize. But, with large data, the LSTMs with higher expressiveness may lead to better results.\n\nThey are almost similar to LSTMs except that they have two gates: reset gate and update gate. Reset gate determines how to combine new input to previous memory and update gate determines how much of the previous state to keep. Update gate in GRU is what input gate and forget gate were in LSTM. We don't have the second non linearity in GRU before calculating the outpu, .neither they have the output gate.\n\nSource: [Quora](https:\/\/www.quora.com\/Whats-the-difference-between-LSTM-and-GRU-Why-are-GRU-efficient-to-train)\n\n<img src=\"https:\/\/cdnpythonmachinelearning.azureedge.net\/wp-content\/uploads\/2017\/11\/GRU.png?x31195\">","f605e60b":"So, GRU works better than LSTM in this case. Bidirectional LSTM is also a good way so make the model stronger. But this may vary for different data sets. **Applying both LSTM and GRU together gave even better results.** ","a56d3b78":"## Sequence Generation\nHere, I will generate a sequence using just initial 60 values instead of using last 60 values for every new prediction. **Due to doubts in various comments about predictions making use of test set values, I have decided to include sequence generation.** The above models make use of test set so it is using last 60 true values for predicting the new value(I will call it a benchmark). This is why the error is so low. Strong models can bring similar results like above models for sequences too but they require more than just data which has previous values. In case of stocks, we need to know the sentiments of the market, the movement of other stocks and a lot more. So, don't expect a remotely accurate plot. The error will be great and the best I can do is generate the trend similar to the test set.\n\nI will use GRU model for predictions. You can try this using LSTMs also. I have modified GRU model above to get the best sequence possible. I have run the model four times and two times I got error of around 8 to 9. The worst case had an error of around 11. Let's see what this iterations.\n\nThe GRU model in the previous versions is fine too. Just a little tweaking was required to get good sequences. **The main goal of this kernel is to show how to build RNN models. How you predict data and what kind of data you predict is up to you. I can't give you some 100 lines of code where you put the destination of training and test set and get world-class results. That's something you have to do yourself.**","1d387ee7":"#### I was going to cover text generation using LSTM but already an excellent kernel by [Shivam Bansal](https:\/\/www.kaggle.com\/shivamb) on the mentioned topic exists. Link for that kernel here: https:\/\/www.kaggle.com\/shivamb\/beginners-guide-to-text-generation-using-lstms","26a37d59":"The current version version uses a dense GRU network with 100 units as opposed to the GRU network with 50 units in previous version","fc00d788":"#### This is certainly not the end. Stay tuned for more stuff!"}}