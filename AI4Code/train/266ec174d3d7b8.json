{"cell_type":{"50d3b13b":"code","72d1bf54":"code","52bb8d39":"code","aa325b81":"code","0e3ccea9":"code","c7739a27":"code","09442c9b":"code","ade65770":"code","e3d551ce":"code","7064e16e":"code","8ee3dcf7":"code","7bb9359b":"code","52f9cefc":"code","eba63ee2":"code","d6675b9a":"code","07beeb43":"code","1b90b0e8":"code","2e46c637":"code","96eedf8e":"markdown","6190fae4":"markdown","f17f6420":"markdown","5ede4cb2":"markdown","e4336ba7":"markdown","1e9d0972":"markdown","faf20335":"markdown","b6521fcf":"markdown","48fb8897":"markdown","ed1be601":"markdown","74e5a09f":"markdown","67cf2198":"markdown","11217ed2":"markdown","8667c163":"markdown","701d30fa":"markdown","fdc8006b":"markdown","61a198c0":"markdown","a36fc19b":"markdown","69ea29df":"markdown"},"source":{"50d3b13b":"import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport tensorflow as tf\n\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score\nfrom sklearn.model_selection import train_test_split\nfrom tensorflow.keras import layers, losses\nfrom tensorflow.keras.datasets import fashion_mnist\nfrom tensorflow.keras.models import Model","72d1bf54":"# Download the dataset\ndataframe = pd.read_csv('http:\/\/storage.googleapis.com\/download.tensorflow.org\/data\/ecg.csv', header=None)\nraw_data = dataframe.values\ndataframe.head()","52bb8d39":"# The last element contains the labels\nlabels = raw_data[:, -1]\n\n# The other data points are the electrocadriogram data\ndata = raw_data[:, 0:-1]\n\ntrain_data, test_data, train_labels, test_labels = train_test_split(\n    data, labels, test_size=0.2, random_state=21\n)","aa325b81":"min_val = tf.reduce_min(train_data)\nmax_val = tf.reduce_max(train_data)\n\ntrain_data = (train_data - min_val) \/ (max_val - min_val)\ntest_data = (test_data - min_val) \/ (max_val - min_val)\n\ntrain_data = tf.cast(train_data, tf.float32)\ntest_data = tf.cast(test_data, tf.float32)","0e3ccea9":"train_labels = train_labels.astype(bool)\ntest_labels = test_labels.astype(bool)\n\nnormal_train_data = train_data[train_labels]\nnormal_test_data = test_data[test_labels]\n\nanomalous_train_data = train_data[~train_labels]\nanomalous_test_data = test_data[~test_labels]","c7739a27":"plt.grid()\nplt.plot(np.arange(140), normal_train_data[0])\nplt.title(\"A Normal ECG\")\nplt.show()","09442c9b":"plt.grid()\nplt.plot(np.arange(140), anomalous_train_data[0])\nplt.title(\"An Anomalous ECG\")\nplt.show()","ade65770":"class AnomalyDetector(Model):\n  def __init__(self):\n    super(AnomalyDetector, self).__init__()\n    self.encoder = tf.keras.Sequential([\n      layers.Dense(32, activation=\"relu\"),\n      layers.Dense(16, activation=\"relu\"),\n      layers.Dense(8, activation=\"relu\")])\n    \n    self.decoder = tf.keras.Sequential([\n      layers.Dense(16, activation=\"relu\"),\n      layers.Dense(32, activation=\"relu\"),\n      layers.Dense(140, activation=\"sigmoid\")])\n    \n  def call(self, x):\n    encoded = self.encoder(x)\n    decoded = self.decoder(encoded)\n    return decoded\n\nautoencoder = AnomalyDetector()","e3d551ce":"autoencoder.compile(optimizer='adam', loss='mae')","7064e16e":"history = autoencoder.fit(normal_train_data, normal_train_data, \n          epochs=20, \n          batch_size=512,\n          validation_data=(test_data, test_data),\n          shuffle=True)","8ee3dcf7":"plt.plot(history.history[\"loss\"], label=\"Training Loss\")\nplt.plot(history.history[\"val_loss\"], label=\"Validation Loss\")\nplt.legend()","7bb9359b":"encoded_imgs = autoencoder.encoder(normal_test_data).numpy()\ndecoded_imgs = autoencoder.decoder(encoded_imgs).numpy()\n\nplt.plot(normal_test_data[0],'b')\nplt.plot(decoded_imgs[0],'r')\nplt.fill_between(np.arange(140), decoded_imgs[0], normal_test_data[0], color='lightcoral' )\nplt.legend(labels=[\"Input\", \"Reconstruction\", \"Error\"])\nplt.show()","52f9cefc":"encoded_imgs = autoencoder.encoder(anomalous_test_data).numpy()\ndecoded_imgs = autoencoder.decoder(encoded_imgs).numpy()\n\nplt.plot(anomalous_test_data[0],'b')\nplt.plot(decoded_imgs[0],'r')\nplt.fill_between(np.arange(140), decoded_imgs[0], anomalous_test_data[0], color='lightcoral' )\nplt.legend(labels=[\"Input\", \"Reconstruction\", \"Error\"])\nplt.show()","eba63ee2":"reconstructions = autoencoder.predict(normal_train_data)\ntrain_loss = tf.keras.losses.mae(reconstructions, normal_train_data)\n\nplt.hist(train_loss, bins=50)\nplt.xlabel(\"Train loss\")\nplt.ylabel(\"No of examples\")\nplt.show()","d6675b9a":"threshold = np.mean(train_loss) + np.std(train_loss)\nprint(\"Threshold: \", threshold)","07beeb43":"reconstructions = autoencoder.predict(anomalous_test_data)\ntest_loss = tf.keras.losses.mae(reconstructions, anomalous_test_data)\n\nplt.hist(test_loss, bins=50)\nplt.xlabel(\"Test loss\")\nplt.ylabel(\"No of examples\")\nplt.show()","1b90b0e8":"def predict(model, data, threshold):\n  reconstructions = model(data)\n  loss = tf.keras.losses.mae(reconstructions, data)\n  return tf.math.less(loss, threshold)\n\ndef print_stats(predictions, labels):\n  print(\"Accuracy = {}\".format(accuracy_score(labels, preds)))\n  print(\"Precision = {}\".format(precision_score(labels, preds)))\n  print(\"Recall = {}\".format(recall_score(labels, preds)))","2e46c637":"preds = predict(autoencoder, test_data, threshold)\nprint_stats(preds, test_labels)","96eedf8e":"Detect anomalies by calculating whether the reconstruction loss is greater than a fixed threshold. In this tutorial, you will calculate the mean average error for normal examples from the training set, then classify future examples as anomalous if the reconstruction error is higher than one standard deviation from the training set.\n","6190fae4":"## Import TensorFlow and other libraries","f17f6420":"Plot an anomalous ECG.","5ede4cb2":"Classify an ECG as an anomaly if the reconstruction error is greater than the threshold.","e4336ba7":"Plot the reconstruction error on normal ECGs from the training set","1e9d0972":"Note: There are other strategies you could use to select a threshold value above which test examples should be classified as anomalous, the correct approach will depend on your dataset. You can learn more with the links at the end of this tutorial. ","faf20335":"The dataset you will use is based on one from [timeseriesclassification.com](http:\/\/www.timeseriesclassification.com\/description.php?Dataset=ECG5000).\n","b6521fcf":"Choose a threshold value that is one standard deviations above the mean.","48fb8897":"Create a similar plot, this time for an anomalous test example.","ed1be601":"If you examine the recontruction error for the anomalous examples in the test set, you'll notice most have greater reconstruction error than the threshold. By varing the threshold, you can adjust the [precision](https:\/\/developers.google.com\/machine-learning\/glossary#precision) and [recall](https:\/\/developers.google.com\/machine-learning\/glossary#recall) of your classifier. ","74e5a09f":"You will train the autoencoder using only the normal rhythms, which are labeled in this dataset as `1`. Separate the normal rhythms from the abnormal rhythms.","67cf2198":"Plot a normal ECG. ","11217ed2":"### Detect anomalies","8667c163":"Normalize the data to `[0,1]`.\n","701d30fa":"### Build the model","fdc8006b":"### Load ECG data","61a198c0":"## example: Anomaly detection\n\n## Overview\n\n\nIn this example, you will train an autoencoder to detect anomalies on the [ECG5000 dataset](http:\/\/www.timeseriesclassification.com\/description.php?Dataset=ECG5000). This dataset contains 5,000 [Electrocardiograms](https:\/\/en.wikipedia.org\/wiki\/Electrocardiography), each with 140 data points. You will use a simplified version of the dataset, where each example has been labeled either `0` (corresponding to an abnormal rhythm), or `1` (corresponding to a normal rhythm). You are interested in identifying the abnormal rhythms.\n\nNote: This is a labeled dataset, so you could phrase this as a supervised learning problem. The goal of this example is to illustrate anomaly detection concepts you can apply to larger datasets, where you do not have labels available (for example, if you had many thousands of normal rhythms, and only a small number of abnormal rhythms).\n\nHow will you detect anomalies using an autoencoder? Recall that an autoencoder is trained to minimize reconstruction error. You will train an autoencoder on the normal rhythms only, then use it to reconstruct all the data. Our hypothesis is that the abnormal rhythms will have higher reconstruction error. You will then classify a rhythm as an anomaly if the reconstruction error surpasses a fixed threshold.","a36fc19b":"You will soon classify an ECG as anomalous if the reconstruction error is greater than one standard deviation from the normal training examples. First, let's plot a normal ECG from the training set, the reconstruction after it's encoded and decoded by the autoencoder, and the reconstruction error.","69ea29df":"Notice that the autoencoder is trained using only the normal ECGs, but is evaluated using the full test set."}}