{"cell_type":{"55be3bdd":"code","c1d0936d":"code","2a811beb":"code","e34b9bfa":"code","b047dc08":"code","b1a7da2f":"code","f4768478":"code","778fed66":"code","c20430cb":"code","fa382c02":"code","7d6bfe8e":"code","733605d0":"code","5fee61cd":"code","b250c812":"code","7dbcd268":"code","b2f6ec02":"code","bb965558":"code","6c144fb5":"code","3800af55":"code","4912c54b":"code","53ee3307":"code","a078e5c0":"code","bb715f89":"code","577f6b05":"code","3320c99d":"code","c8e6b194":"code","a08e0c00":"code","d7f801e0":"code","3b20fc19":"code","00f6b786":"code","f406aad9":"code","14f221a9":"code","1a0ba02d":"code","6def4376":"code","b4a76411":"code","ee069624":"code","686532be":"code","44a80a1c":"code","b67d7fb6":"code","ed6d1f04":"code","b684bdae":"code","92b7a7bc":"code","4acea68a":"code","f8548f58":"code","a61bda8f":"code","c5ff9032":"code","abcd9bf2":"code","010c139f":"code","4ea7b2e5":"code","e24d7343":"code","e1d697f5":"code","44d2cd44":"markdown","0c4bba86":"markdown","b5800ede":"markdown","cb92ad32":"markdown","e921030f":"markdown","1ee38c23":"markdown","3a092699":"markdown","4e52a28f":"markdown","6fb76894":"markdown","1e5cf853":"markdown","5059454c":"markdown","c91b1118":"markdown","02d5fdeb":"markdown","28c967fc":"markdown","49433877":"markdown","2aa886e6":"markdown","27247237":"markdown","bcf87c20":"markdown","19533ea8":"markdown","e6de0113":"markdown","bd2bb455":"markdown","83cd199b":"markdown","3dfdf0f5":"markdown","d3d6d2fc":"markdown","4d1dbb97":"markdown","69ed4c3a":"markdown","8caf442d":"markdown","8a9fe5d9":"markdown","f7893d2b":"markdown","65f123ed":"markdown","6cab8a29":"markdown","e18d9706":"markdown","51f6592d":"markdown","f03e113e":"markdown","a2b491d2":"markdown","6b261897":"markdown","b0b0c666":"markdown","c1c784e8":"markdown","734ddc2f":"markdown","e7b679dd":"markdown","b15af4d8":"markdown","f5aeb2d2":"markdown","bfd903cb":"markdown","0c20eac4":"markdown","374c56dd":"markdown","e8c3c155":"markdown","034e979b":"markdown","81d6a8ca":"markdown","aff2326c":"markdown","473e86a0":"markdown","eb1baba9":"markdown","b16706d9":"markdown","e9154d05":"markdown","76e86c69":"markdown","2a842da3":"markdown","4c6a7f03":"markdown","85fc5f54":"markdown","eb376c79":"markdown","18ad1e02":"markdown","382f8345":"markdown","93be7746":"markdown","e6912a43":"markdown","57503359":"markdown","e8b2f3b5":"markdown","847f38c8":"markdown","fb27b273":"markdown","cec1f46b":"markdown","fcd0281f":"markdown"},"source":{"55be3bdd":"import os\nimport numpy as np\nimport pandas as pd\nfrom PIL import Image\nimport cv2\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nfrom datetime import datetime","c1d0936d":"!cp ..\/input\/talibinstall\/ta-lib-0.4.0-src.tar.gzh  .\/ta-lib-0.4.0-src.tar.gz\n!tar -xzvf ta-lib-0.4.0-src.tar.gz > null\n!cd ta-lib && .\/configure --prefix=\/usr > null && make  > null && make install > null","2a811beb":"!cp ..\/input\/talibinstall\/TA-Lib-0.4.21.tar.gzh TA-Lib-0.4.21.tar.gz\n!pip install TA-Lib-0.4.21.tar.gz\n!pip install ..\/input\/talibinstall\/numpy-1.21.4-cp37-cp37m-manylinux_2_12_x86_64.manylinux2010_x86_64.whl\nimport talib as ta","e34b9bfa":"asset_details = pd.read_csv('..\/input\/g-research-crypto-forecasting\/asset_details.csv')\nasset_details","b047dc08":"asset_details.Weight.sum()","b1a7da2f":"crypto_df = pd.read_csv('..\/input\/g-research-crypto-forecasting\/train.csv')\ncrypto_df","f4768478":"supplemental_train = pd.read_csv('..\/input\/g-research-crypto-forecasting\/supplemental_train.csv')\nsupplemental_train","778fed66":"example_test = pd.read_csv('..\/input\/g-research-crypto-forecasting\/example_test.csv')\nexample_test.head()","c20430cb":"sample_submission = pd.read_csv('..\/input\/g-research-crypto-forecasting\/example_sample_submission.csv')\nsample_submission.head()","fa382c02":"btc =crypto_df[crypto_df.Asset_ID==1].reset_index(drop=True) \nbtc","7d6bfe8e":"btc['date'] = btc.timestamp.astype('datetime64[s]')\nbtc['date'] = btc['date'].astype(str)\nbtc['time'] = btc['date'].apply(lambda x: x[11:])\nbtc","733605d0":"import seaborn as sns\nplt.figure(figsize=(10,8))\nsns.heatmap(btc[['Count','Open','High','Low','Close','Volume','VWAP','Target']].corr(), vmin=-1.0, vmax=1.0, annot=True, cmap='coolwarm', linewidths=0.1)\nplt.show()\n","5fee61cd":"btc['np_count'] = np.log1p(btc['Count'])\nbtc['np_open'] = np.log1p(btc['Open'])\nbtc['np_high'] = np.log1p(btc['High'])\nbtc['np_low'] = np.log1p(btc['Low'])\nbtc['np_close'] = np.log1p(btc['Close'])\nbtc['np_volume'] = np.log1p(btc['Volume'])\nbtc['np_vwap'] = np.log1p(btc['VWAP'])\n\nplt.figure(figsize=(10,8))\nsns.heatmap(btc[['np_count','np_open','np_high','np_low','np_close','np_volume','np_vwap','Target']].corr(), vmin=-1.0, vmax=1.0, annot=True, cmap='coolwarm', linewidths=0.1)\nplt.show()","b250c812":"btc['np_count'] =  (btc['Count'])**2\nbtc['np_open'] = (btc['Open'])**2\nbtc['np_high'] = (btc['High'])**2\nbtc['np_low'] = (btc['Low'])**2\nbtc['np_close'] = (btc['Close'])**2\nbtc['np_volume'] = (btc['Volume'])**2\nbtc['np_vwap'] = (btc['VWAP'])**2\n\nplt.figure(figsize=(10,8))\nsns.heatmap(btc[['np_count','np_open','np_high','np_low','np_close','np_volume','np_vwap','Target']].corr(), vmin=-1.0, vmax=1.0, annot=True, cmap='coolwarm', linewidths=0.1)\nplt.show()","7dbcd268":"btc['np_count'] =  np.sqrt(btc['Count'])\nbtc['np_open'] = np.sqrt(btc['Open'])\nbtc['np_high'] = np.sqrt(btc['High'])\nbtc['np_low'] = np.sqrt(btc['Low'])\nbtc['np_close'] = np.sqrt(btc['Close'])\nbtc['np_volume'] = np.sqrt(btc['Volume'])\nbtc['np_vwap'] = np.sqrt(btc['VWAP'])\n\nplt.figure(figsize=(10,8))\nsns.heatmap(btc[['np_count','np_open','np_high','np_low','np_close','np_volume','np_vwap','Target']].corr(), vmin=-1.0, vmax=1.0, annot=True, cmap='coolwarm', linewidths=0.1)\nplt.show()","b2f6ec02":"btc['np_count'] = btc['Count'] -btc['Volume']\nbtc['np_open'] = btc['Open'] -  btc['Close'] \nbtc['np_high'] = btc['High'] - btc['Low']\nbtc['np\/count'] = btc['Count'] \/btc['Volume']\nbtc['np\/open'] = btc['Open'] \/  btc['Close'] \nbtc['np\/high'] = btc['High'] \/ btc['Low']\n\nplt.figure(figsize=(10,8))\nsns.heatmap(btc[['np_count','np_open','np_high','np\/count','np\/open','np\/high','Target']].corr(), vmin=-1.0, vmax=1.0, annot=True, cmap='coolwarm', linewidths=0.1)\nplt.show()","bb965558":"btc['np_count'] = btc['Count'] +btc['Volume']\nbtc['np_open'] = btc['Open'] +  btc['Close'] \nbtc['np_high'] = btc['High'] + btc['Low']\nbtc['np\/count'] = btc['Count'] *btc['Volume']\nbtc['np\/open'] = btc['Open'] *  btc['Close'] \nbtc['np\/high'] = btc['High'] * btc['Low']\n\nplt.figure(figsize=(10,8))\nsns.heatmap(btc[['np_count','np_open','np_high','np\/count','np\/open','np\/high','Target']].corr(), vmin=-1.0, vmax=1.0, annot=True, cmap='coolwarm', linewidths=0.1)\nplt.show()","6c144fb5":"btc['np_open'] =btc[f'Open'] \/ ((np.log(np.abs(btc[f'Open'])) **10)+(np.log(np.abs(btc[f'Close']))**10))\nbtc['np_close']=   btc[f'Close'] \/((np.log(np.abs(btc[f'Open'])) **10)+(np.log(np.abs(btc[f'Close']))**10))\nbtc['np_high']= btc[f'High'] \/ ((np.log(np.abs(btc[f'High']))**10)+(np.log(np.abs(btc[f'Low']))**10))\nbtc['np_low'] = btc[f'Low'] \/ ((np.log(np.abs(btc[f'High']))**10)+(np.log(np.abs(btc[f'Low']))**10))\nplt.figure(figsize=(10,8))\nsns.heatmap(btc[['np_open','np_close','np_high','np_low','Target']].corr(), vmin=-1.0, vmax=1.0, annot=True, cmap='coolwarm', linewidths=0.1)\nplt.show()","3800af55":"fig = plt.figure(figsize=(30,20))\nx=1\nfor i in crypto_df.Asset_ID.unique():\n    money = crypto_df[crypto_df.Asset_ID==i].reset_index(drop=True) \n    fig.add_subplot(4, 4, x)\n    a = str(x-1) +' ' + asset_details[asset_details.Asset_ID==i].Asset_Name.values \n    plt.title(a,fontsize=18)\n    plt.plot(money.index,money.Target)\n    x +=1\ndel money","4912c54b":"fig = plt.figure(figsize=(30,20))\ndata =crypto_df #[-10000:]\nfor i in data.Asset_ID.unique():\n    money = data[data.Asset_ID==i].reset_index(drop=True) \n    plt.plot(money.index,money.Target)\ndel data","53ee3307":"fig = plt.figure(figsize=(30,20))\ndata =crypto_df[-10000:]\nfor i in data.Asset_ID.unique():\n    money = data[data.Asset_ID==i].reset_index(drop=True) \n    plt.plot(money.index,money.Target)\ndel data","a078e5c0":"fig = plt.figure(figsize=(30,20))\ndata =crypto_df[-1000:]\nfor i in data.Asset_ID.unique():\n    money = data[data.Asset_ID==i].reset_index(drop=True) \n    plt.plot(money.index,money.Target)\n","bb715f89":"check = pd.DataFrame()\nfor i in data.Asset_ID.unique():\n    check[i] = data[data.Asset_ID==i]['Target'].reset_index(drop=True) ","577f6b05":"import seaborn as sns\nplt.figure(figsize=(10,8))\nsns.heatmap(check.dropna().corr(), vmin=-1.0, vmax=1.0, annot=True, cmap='coolwarm', linewidths=0.1)\nplt.show()\ndel check","3320c99d":"for i in  crypto_df.Asset_ID.unique():\n    check = crypto_df[crypto_df.Asset_ID==i].reset_index(drop=True) \n    print('Asset_ID=', pd.to_datetime(check.loc[0,'timestamp'],unit=\"s\",infer_datetime_format=True))\n   ","c8e6b194":"check","a08e0c00":"from lightgbm import LGBMRegressor\ndf = crypto_df.copy()\ndf['macd'], df['macdsignal'], df['MACD_HIST'] = ta.MACD(df['Close'], fastperiod=12, slowperiod=26, signalperiod=9)\ndf[\"RSI\"]=ta.RSI(df['Close'], timeperiod=14)\ndf['ema']   =ta.EMA(df['Open'], timeperiod=20)\ndf['willr'] = ta.WILLR(df['High'], df['Low'],np.array(df.loc[:, 'Close']), timeperiod=14)\ndf['ROCP'] =ta.ROCP(df['Open'])\ndf['momentam'] =ta.MOM(df['Open'])\ndf['APO'] =ta.APO(df['Open'])\ndf['PPO'] =ta.PPO(df['Open'])\ndf['CMO'] =ta.CMO(df['Open'])\ndf['MIDPOINT'] =ta.MIDPOINT(df['Open'])\ndf['TRENDLINE'] =ta.HT_TRENDLINE(df['Open'])\n\ndf = df[df[\"Asset_ID\"] == 0]\n\ndf = df.dropna(subset=['Target'])\ny = df['Target']\ndf = df.fillna(-1)\n    \ndf = df.drop(['Asset_ID','Target'],axis=1)\nX  = df \n\nmodel = LGBMRegressor(n_estimators=1500,num_leaves=700,learning_rate=0.09,silent=True)\nmodel.fit(X, y)\n\nfi =model.feature_importances_\nfi_df = pd.DataFrame({'feature': list(X.columns),\n         'feature importance': fi[:]}).sort_values('feature importance', ascending = False)\ndisplay(fi_df)\ndel df\ndel X\ndel y","d7f801e0":"fig = plt.figure(figsize=(30,20))\nx=1\nfor i in crypto_df.Asset_ID.unique():\n    money = crypto_df[crypto_df.Asset_ID==i].reset_index(drop=True) \n    fig.add_subplot(4, 4, x)\n    plt.title(asset_details[asset_details.Asset_ID==i].Asset_Name.values,fontsize=18)\n    plt.plot(money.index,money.Open,color=\"red\")\n    plt.plot(money.index,money.Close,color=\"blue\")\n    x +=1","3b20fc19":"fig = plt.figure(figsize=(30,20))\nx=1\nfor i in crypto_df.Asset_ID.unique():\n    money = crypto_df[crypto_df.Asset_ID==i].reset_index(drop=True) \n    fig.add_subplot(4, 4, x)\n    plt.title(asset_details[asset_details.Asset_ID==i].Asset_Name.values,fontsize=18)\n    plt.plot(money.index,money.High,color=\"red\")\n    plt.plot(money.index,money.Low,color=\"blue\")\n    x +=1\ndel money","00f6b786":"fig = plt.figure(figsize=(30,20))\nx=1\nfor i in crypto_df.Asset_ID.unique():\n    money = crypto_df[crypto_df.Asset_ID==i].reset_index(drop=True) \n    fig.add_subplot(4, 4, x)\n    plt.title(asset_details[asset_details.Asset_ID==i].Asset_Name.values,fontsize=18)\n    plt.plot(money.index,money.Volume)\n    x +=1\ndel money","f406aad9":"fig = plt.figure(figsize=(30,20))\nx=1\nfor i in crypto_df.Asset_ID.unique():\n    money = crypto_df[crypto_df.Asset_ID==i].reset_index(drop=True) \n    fig.add_subplot(4, 4, x)\n    plt.title(asset_details[asset_details.Asset_ID==i].Asset_Name.values,fontsize=18)\n    plt.plot(money.index,money.VWAP)\n    x +=1\n    \ndel money","14f221a9":"fig = plt.figure(figsize=(30,20))\nx=1\nfor i in crypto_df.Asset_ID.unique():\n    money = crypto_df[crypto_df.Asset_ID==i].reset_index(drop=True) \n    fig.add_subplot(4, 4, x)\n    plt.title(asset_details[asset_details.Asset_ID==i].Asset_Name.values,fontsize=18)\n    plt.plot(money.index,money.Count)\n    x +=1\ndel money","1a0ba02d":"btc['high_low'] = btc['High'] - btc['Low']\nbtc['open_close'] = btc['Open'] - btc['Close']","6def4376":"plt.figure(figsize=(10,8))\nsns.heatmap(btc[['Count','Open','High','Low','Close','Volume','high_low','open_close','VWAP','Target']].corr(), vmin=-1.0, vmax=1.0, annot=True, cmap='coolwarm', linewidths=0.1)\nplt.show()","b4a76411":"    \nfig = plt.figure(figsize=(30,20))\nx=1\nfor i in crypto_df.Asset_ID.unique():\n    money = crypto_df[crypto_df.Asset_ID==i].reset_index(drop=True) \n    fig.add_subplot(4, 4, x)\n    plt.title(asset_details[asset_details.Asset_ID==i].Asset_Name.values,fontsize=18)\n    money['MACD'] ,_,_ = ta.MACD(money['Close'], fastperiod=12, slowperiod=26, signalperiod=9)\n    plt.plot(money.index,money.MACD)\n    x +=1","ee069624":"   \nfig = plt.figure(figsize=(30,20))\nx=1\nfor i in crypto_df.Asset_ID.unique():\n    money = crypto_df[crypto_df.Asset_ID==i].reset_index(drop=True) \n    fig.add_subplot(4, 4, x)\n    plt.title(asset_details[asset_details.Asset_ID==i].Asset_Name.values,fontsize=18)\n    money[\"RSI\"]=ta.RSI(money['Close'], timeperiod=14)\n    plt.plot(money.index,money.RSI)\n    x +=1","686532be":"fig = plt.figure(figsize=(30,20))\nx=1\nfor i in crypto_df.Asset_ID.unique():\n    money = crypto_df[crypto_df.Asset_ID==i].reset_index(drop=True) \n    fig.add_subplot(4, 4, x)\n    plt.title(asset_details[asset_details.Asset_ID==i].Asset_Name.values,fontsize=18)\n    money[\"TRENDLINE\"]=ta.HT_TRENDLINE(money['Close'])\n    plt.plot(money.index,money.TRENDLINE)\n    x +=1","44a80a1c":"fig = plt.figure(figsize=(30,20))\nx=1\nfor i in crypto_df.Asset_ID.unique():\n    money = crypto_df[crypto_df.Asset_ID==i].reset_index(drop=True) \n    fig.add_subplot(4, 4, x)\n    plt.title(asset_details[asset_details.Asset_ID==i].Asset_Name.values,fontsize=18)\n    money[\"ROCP\"]=ta.ROCP(money['Close'])\n    plt.plot(money.index,money.ROCP)\n    x +=1","b67d7fb6":"# create dataframe with returns for all assets\nimport time\nfrom datetime import datetime\n# define function to compute log returns\ndef log_return(series, periods=1):\n    return np.log(series).diff(periods=periods)\ntotimestamp = lambda s: np.int32(time.mktime(datetime.strptime(s, \"%d\/%m\/%Y\").timetuple()))\n\nall_assets_2021 = pd.DataFrame([])\nfor asset_id, asset_name in zip(asset_details.Asset_ID, asset_details.Asset_Name):\n  asset = crypto_df[crypto_df[\"Asset_ID\"]==asset_id].set_index(\"timestamp\")\n  asset = asset.loc[totimestamp('01\/01\/2021'):totimestamp('01\/05\/2021')]\n  asset = asset.reindex(range(asset.index[0],asset.index[-1]+60,60),method='pad')\n  lret = log_return(asset.Close.fillna(0))[1:]\n  all_assets_2021 = all_assets_2021.join(lret, rsuffix=asset_name, how=\"outer\")","ed6d1f04":"train_window = [totimestamp(\"01\/05\/2021\"), totimestamp(\"30\/05\/2021\")]\ntest_window = [totimestamp(\"01\/06\/2021\"), totimestamp(\"30\/06\/2021\")]\n\nupper_shadow = lambda asset: asset.High - np.maximum(asset.Close,asset.Open)\nlower_shadow = lambda asset: np.minimum(asset.Close,asset.Open)- asset.Low","b684bdae":" coins = pd.DataFrame()\n coins['coin'] =0\n from datetime import datetime\n from tqdm.notebook import tqdm\n from sklearn.linear_model import LinearRegression\n cols =['Count','Open','High','Low','Close','Volume','VWAP']\n kts, kps = set(), set()\n for coin_id in tqdm(crypto_df['Asset_ID'].unique()):\n     coin = crypto_df[crypto_df['Asset_ID'] == coin_id]\n     coins.loc[coin_id,'coin'] = asset_details[asset_details.Asset_ID==coin_id].Asset_Name.values\n     coin = coin.dropna()\n        \n     coin = coin[(coin.timestamp >train_window[0]) & (coin.timestamp <train_window[1])]   \n    \n     for col in cols: \n       coin= coin.replace(np.inf,100)\n       coin= coin.replace(-np.inf,0)\n       X = coin[col].values.reshape((-1, 1))\n       y = coin['Target'].values\n\n       lr = LinearRegression()\n       lr.fit(X, y)\n       coins.loc[coin_id,col+'_score'] = lr.score(X, y)\n       coins.loc[coin_id,col+'_intercept_'] = lr.intercept_\n       coins.loc[coin_id,col+'_coef_'] = lr.coef_[0]\n    \n coins.iloc[:,:13]","92b7a7bc":"coins.iloc[:,13:]","4acea68a":"btc","f8548f58":"def log_return(series, periods=5):\n    return np.log(series).diff(periods=periods)","a61bda8f":"fig = plt.figure(figsize=(30,10))\n\ni=4\nfig.add_subplot(1, i, 1)\nplt.title('Target',fontsize=18)\nplt.plot(btc.Target,color=\"orange\")\n\nfig.add_subplot(1, i, 2)\nplt.title('Close return 1',fontsize=18)\nplt.plot(log_return(btc.Close,periods=1))\n\nfig.add_subplot(1, i, 3)\nplt.title('Close return 5',fontsize=18)\nplt.plot(log_return(btc.Close,periods=5))\n\nfig.add_subplot(1, i, 4)\nplt.title('Close return 10',fontsize=18)\nplt.plot(log_return(btc.Close,periods=10))","c5ff9032":"fig = plt.figure(figsize=(30,10))\n\ni=4\nfig.add_subplot(1, i, 1)\nplt.title('Target',fontsize=18)\nplt.plot(btc.Target,color=\"orange\")\n\nfig.add_subplot(1, i, 2)\nplt.title('Open return 1',fontsize=18)\nplt.plot(log_return(btc.Open,periods=1))\n\nfig.add_subplot(1, i, 3)\nplt.title('Open return 5',fontsize=18)\nplt.plot(log_return(btc.Open,periods=5))\n\nfig.add_subplot(1, i, 4)\nplt.title('Open return 10',fontsize=18)\nplt.plot(log_return(btc.Open,periods=10))","abcd9bf2":"fig = plt.figure(figsize=(30,10))\n\ni=4\nfig.add_subplot(1, i, 1)\nplt.title('Target',fontsize=18)\nplt.plot(btc.Target,color=\"orange\")\n\nfig.add_subplot(1, i, 2)\nplt.title('Open pct_change 1',fontsize=18)\nplt.plot(btc.Open.pct_change(1))\n\nfig.add_subplot(1, i, 3)\nplt.title('Open pct_change 5',fontsize=18)\nplt.plot(btc.Open.pct_change(5))\n\nfig.add_subplot(1, i, 4)\nplt.title('Open pct_change 10',fontsize=18)\nplt.plot(btc.Open.pct_change(10))","010c139f":"fig = plt.figure(figsize=(30,10))\n\ni=4\nfig.add_subplot(1, i, 1)\nplt.title('Target',fontsize=18)\nplt.plot(btc.Target,color=\"orange\")\n\nfig.add_subplot(1, i, 2)\nplt.title('Open rolling( 1',fontsize=18)\nplt.plot(btc.Open.diff().rolling(1).mean())\n\nfig.add_subplot(1, i, 3)\nplt.title('Open rolling( 5',fontsize=18)\nplt.plot(btc.Open.diff().rolling(5).mean())\n\nfig.add_subplot(1, i, 4)\nplt.title('Open rolling( 10',fontsize=18)\nplt.plot(btc.Open.diff().rolling(10).mean())","4ea7b2e5":"import scipy.stats as stats\nfig = plt.figure(figsize=(30,10))\n\nlret_btc = log_return(btc.Close)[1:]\nlret_btc.rename('lret_btc', inplace=True)\ni=4\nfig.add_subplot(1, i, 1)\nplt.title('Target',fontsize=18)\nplt.plot(btc.Target,color=\"orange\");\n\nfig.add_subplot(1, i, 2)\nplt.title('high_low return 1',fontsize=18)\nplt.plot(log_return(btc.high_low,periods=1))\n\nfig.add_subplot(1, i, 3)\nplt.title('high_low return 5',fontsize=18)\nplt.plot(log_return(btc.high_low,periods=5));\n\nfig.add_subplot(1, i, 4)\nplt.title('high_low return 10',fontsize=18)\nplt.plot(log_return(btc.high_low,periods=10));","e24d7343":"fig = plt.figure(figsize=(30,10))\n\nlret_btc = log_return(btc.Close)[1:]\nlret_btc.rename('lret_btc', inplace=True)\ni=4\nfig.add_subplot(1, i, 1)\nplt.title('Target',fontsize=18)\nplt.plot(btc.Target,color=\"orange\");\n\nfig.add_subplot(1, i, 2)\nplt.title('high_low return 1',fontsize=18)\nplt.plot(log_return(btc.open_close,periods=1))\n\nfig.add_subplot(1, i, 3)\nplt.title('high_low return 5',fontsize=18)\nplt.plot(log_return(btc.open_close,periods=5));\n\nfig.add_subplot(1, i, 4)\nplt.title('high_low return 10',fontsize=18)\nplt.plot(log_return(btc.open_close,periods=10));","e1d697f5":"fig = plt.figure(figsize=(30,10))\n\nlret_btc = log_return(btc.Close)[1:]\nlret_btc.rename('lret_btc', inplace=True)\ni=4\nfig.add_subplot(1, i, 1)\nplt.title('Target',fontsize=18)\nplt.plot(btc.Target,color=\"orange\");\n\nfig.add_subplot(1, i, 2)\nplt.title('high_low return 1',fontsize=18)\nplt.plot(log_return(btc.Volume,periods=1))\n\nfig.add_subplot(1, i, 3)\nplt.title('high_low return 5',fontsize=18)\nplt.plot(log_return(btc.Volume,periods=5));\n\nfig.add_subplot(1, i, 4)\nplt.title('high_low return 10',fontsize=18)\nplt.plot(log_return(btc.Volume,periods=10));","44d2cd44":"### Open_Close","0c4bba86":"Looking at the public code, there is score = 0.999. Since leak data is used, the code doesn't mean anything at all.\n \n  Well, it's a future prediction competition, so I don't think the score is meaningful.\n \n  Anyway, it's hard to finish within 9 hours after submitting.\n ","b5800ede":"Depending on the coin, there are great ups and downs.","cb92ad32":"# Count","e921030f":"\n\u30fb Waveforms of 0 and 5 are very similar <br>\n\u30fb Waveforms of 1 and 7 are similar <br>\n\u30fb Waveforms of 3,8,12,13 are a little similar <br>\n\u30fb Waveforms of 2, 9 and 10 are a little similar <br>\n\u30fb There are not many similarities between 6 and 11 <br>\n\nReally?","1ee38c23":"# [-1000]","3a092699":"## <span style=\"color: orange; font-family: Segoe UI; font-size: 1.0em; font-weight: 100;\">HeatMap Coins<\/span>","4e52a28f":"\ud83d\ude3a\ud83d\ude05\u3299\ud83d\udd30\ud83d\uddd1\u2b1b\ud83d\udfe5\ud83d\udfe8\ud83d\udfe9","6fb76894":"# Volume","1e5cf853":"## <span style=\"color: orange; font-family: Segoe UI; font-size: 1.0em; font-weight: 100;\">Serch Feature columns<\/span>","5059454c":"# Disscution","c91b1118":"# High\/Low","02d5fdeb":"# Open\/Close","28c967fc":"Use this as test data","49433877":"## <span style=\"color: orange; font-family: Segoe UI; font-size: 1.0em; font-weight: 100;\">Check feature importance<\/span>","2aa886e6":"## <span style=\"color: orange; font-family: Segoe UI; font-size: 1.0em; font-weight: 100;\">example_test.csv<\/span>","27247237":"## <span style=\"color: orange; font-family: Segoe UI; font-size: 1.0em; font-weight: 100;\">Asset_details.csv<\/span>","bcf87c20":"It returns independently of the benchmark. Residual returns are the relative returns multiplied by the beta and benchmark returns. To be precise, the residual return on an asset is equal to the excess return minus the beta multiplied by the benchmark excess return.\n\nhttps:\/\/www.nasdaq.com\/glossary\/r\/residual-return","19533ea8":"### Forecasting Competitions<br>\nhttps:\/\/www.kaggle.com\/c\/g-research-crypto-forecasting\/discussion\/284856<br>\nhttps:\/\/www.kaggle.com\/c\/g-research-crypto-forecasting\/discussion\/284883","e6de0113":"## <span style=\"color: orange; font-family: Segoe UI; font-size: 1.0em; font-weight: 100;\">example_sample_submission<\/span>","bd2bb455":"### log_return","83cd199b":"\n\nI don't think any additional data will help in this forecast competition. I'm usually against external data, but finding the signal somewhere is worth it, so it makes perfect sense here. Also, it doesn't make much sense to have no latest version of the data itself <by Psi>\n\nhttps:\/\/www.kaggle.com\/c\/g-research-crypto-forecasting\/discussion\/284942<br>\nhttps:\/\/www.kaggle.com\/c\/g-research-crypto-forecasting\/discussion\/285726<br>","3dfdf0f5":"# ROCP","d3d6d2fc":"## <span style=\"color: orange; font-family: Segoe UI; font-size: 1.0em; font-weight: 100;\">Check BTC<\/span>","4d1dbb97":"'Volume","69ed4c3a":"There was a technical analysis tool called Tab-lib. I will install it.","8caf442d":"# MACD","8a9fe5d9":"### Some coins have a strong correlation.","f7893d2b":"# VWAP","65f123ed":"\nThe transaction volume is increasing. Are you all doing it?\n\nThere is a gap between Count and Volume.\n\nThe number of transactions is increasing unilaterally, but the transaction volume peaks around the center of the graph.","6cab8a29":"# All","e18d9706":"# Target","51f6592d":"\nhttps:\/\/www.kaggle.com\/cstein06\/tutorial-to-the-g-research-crypto-competition<br>\n\nA model of linear regression is described.\n\nI have to read this notebook well.","f03e113e":"\n\nThere are also maniac coins.","a2b491d2":"### **2","6b261897":"# [-10000]","b0b0c666":"lets check BTC.","c1c784e8":"\n\n### It may be good to create a model that summarizes the ones with strong correlation.","734ddc2f":"![image.png](attachment:0c9e65b1-4f95-4c40-8b5b-6853b600e58b.png)","e7b679dd":"The tendency is different for each coin. It seems that the result will be better if the model is divided for each coin.","b15af4d8":"February 1, 2022 - Final submission deadline.\n\nMay 3, 2022 - Competition End Date - Winner's announcement\n\n\nIt's a future prediction competition where you can see the results in May by submitting in February.<br>\n\n\nOptiver Realized Volatility Prediction is the same in terms of future prediction competition. Although it was provisionally 90th, it is now 1415th.\n\n### <u> <font color = \"red\"> Note: Public data is very big. <\/font> <\/u> <br>\nIf you don't keep it simple, it will take more than 9 hours even if you use GPU. <br>\nEven with a model that uses local data and finishes in about 30 minutes, submitting it often exceeds 9 hours, which is a pain. <br>\nI tried a simple neural network, but it didn't finish in 9 hours. Gradient boosting is finally over. <br>\n\n2021\/11\/16 I found some things when I looked it up.<br>\n-It takes 8 minutes to output by simply setting Target = 0.<br>\n-The data length is not always 14.<br>\n-It took more than 9 hours when I put an interval of 1 second in the loop.<br>\n\u2192 3600 seconds x 9 hours -8 minutes x 60 seconds =There are more than 28320 loops.<br>\n\ntest notebook<br>\nhttps:\/\/www.kaggle.com\/tensorchoko\/g-research-test","f5aeb2d2":"Since the timestamp is difficult to understand, I added date and time columns","bfd903cb":"## <span style=\"color: orange; font-family: Segoe UI; font-size: 1.0em; font-weight: 100;\">supplemental_train.csv<\/span>","0c20eac4":"### np.log1p","374c56dd":"## <span style=\"color: orange; font-family: Segoe UI; font-size: 1.0em; font-weight: 100;\">Train.csv<\/span>","e8c3c155":" np.log1p(btc['Volume'])","034e979b":"\n\nFind out if it is related to linear regression => I think it is irrelevant.","81d6a8ca":"### np.sqrt","aff2326c":"# Liner Regression\n","473e86a0":"Provides the actual name of each Asset_ID and the name of the crypto asset, and the weight that each crypto asset receives in the metric","eb1baba9":"### Added MACD and RSI,Trendline,ROCP. I think it's important.","b16706d9":"### Close","e9154d05":"## <span style=\"color: orange; font-family: Segoe UI; font-size: 1.0em; font-weight: 100;\">Tab-lib install<\/span>","76e86c69":"The weight of each asset used to weigh their relative importance in the evaluation metric.Well, how should we use this?","2a842da3":"# TRENDLINE","4c6a7f03":"It has a total of 14 assets and 7 basic functions (close, open, etc.). A simple idea in \"brute force\" is to first pivot the data for each timestamp to create 14 * 7 = 98 features and 14 targets, then a sliding window with a multitasking RNN \/ Transformers \/ TCN. Applying training. Look at such a method.\n\nhttps:\/\/www.kaggle.com\/c\/g-research-crypto-forecasting\/discussion\/285176\n\n\nI noticed that different exchanges have different OHLC (Open High Low Close) data. This is because the transaction fees are different. Are you wondering if competition organizers can share insights into the process of creating datasets?\n\nhttps:\/\/www.kaggle.com\/c\/g-research-crypto-forecasting\/discussion\/285713\n\n\u3002<br>\nThis is a time-series competition.\nmoreover - this can be modeled with hierarchical time series (HTS) model.\n\nhttps:\/\/www.kaggle.com\/c\/g-research-crypto-forecasting\/discussion\/284903","85fc5f54":"### Open","eb376c79":"# RSI","18ad1e02":"\nThe world is not so sweet","382f8345":"\nThen, what is the relationship between OPEN-CLOSE, HIGH-LOW and target?","93be7746":"np.sqrt(btc['Volume'])","e6912a43":"### test","57503359":"### - \/","e8b2f3b5":"# HEATMAP","847f38c8":"15 minute residualized returns\n\nI would expect this. Looking at the HEATMAP, there seems to be no item that has an important relationship.\n\nAlso, it seems necessary to create an objective function.\n\nI'm sure there will be an important paper somewhere again.","fb27b273":"## <span style=\"color: orange; font-family: Segoe UI; font-size: 1.0em; font-weight: 100;\">Check All Coins<\/span>","cec1f46b":"### + *","fcd0281f":"### high_low"}}