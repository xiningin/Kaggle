{"cell_type":{"09adef3e":"code","db38fe32":"code","4451f116":"code","eaaaa1f2":"code","52d95a11":"code","b9635782":"code","349cf2c5":"code","a26414c3":"code","68b2fd98":"code","93b36773":"code","ec35d4c5":"code","3a146a7d":"code","ce119be7":"code","ac8c19fb":"code","5ef93649":"code","835a4bb6":"code","05ad7f86":"code","c337a337":"code","49bd68d1":"code","85886496":"code","9628da7e":"code","7b951ce2":"code","4401ea5b":"code","c3a8dacb":"code","47d23561":"code","a2954a10":"code","a6e9ea13":"code","afdef6e6":"code","ce6938e7":"code","b7dd0b7f":"code","1547f1d8":"code","8cadae06":"code","4c66b713":"code","a568abfb":"code","be1804a0":"code","726a19e0":"markdown","a8ed3872":"markdown","a6610aaf":"markdown","b0abd548":"markdown","8389e95c":"markdown","2248f17b":"markdown","ae17dcb6":"markdown","27b0a1af":"markdown","fd5666b7":"markdown","35822d20":"markdown","37df5bfa":"markdown","ab900a8b":"markdown","4cc9ef09":"markdown"},"source":{"09adef3e":"import pandas as pd\nimport numpy as np\nimport os\n\nos.listdir('..\/input')","db38fe32":"# List of Lists (Row Wise)\ndata = [[30, 21]]\nfruits = pd.DataFrame(data, columns=['Apples', 'Bananas'])\n\n# Make individual column wise lists, then zip and add\n# apples = [30]\n# bananas = [21]\n# fruits = pd.DataFrame(list(zip(apples, bananas)), columns = ['Apples', 'Bananas'])\n\n# From A Dictionary\n# fruits = pd.DataFrame({'Apples': [30], 'Bananas': [21]})\nfruits","4451f116":"# My chosen approach (With index)\n\n# Your code goes here. Create a dataframe matching the above diagram and assign it to the variable fruit_sales.\nindex = ['2017 Sales', '2018 Sales']\ncolumns = ['Apples', 'Bananas']\napples = [35, 41]\nbananas = [21, 34]\nfruit_sales = pd.DataFrame(list(zip(apples, bananas)), columns=columns, index=index)\n\nfruit_sales","eaaaa1f2":"# Each column of a dataframe is basically a series.\n\napplesSeries = pd.Series(fruit_sales['Apples'])\napplesSeries","52d95a11":"# Creating a Series\n\nindex = ['Flour', 'Milk', 'Eggs', 'Spam']\ndata = ['4 cups', '1 cup', '2 large', '1 can']\ningredients = pd.Series(data, index = index, name = 'Dinner')\n\ningredients","b9635782":"housing = pd.read_csv('..\/input\/california-housing-prices\/housing.csv', index_col = None, skiprows = 0)\nhousing.head()","349cf2c5":"animals = pd.DataFrame({'Cows': [12, 20], 'Goats': [22, 19]}, index=['Year 1', 'Year 2'])\nanimals\nanimals.to_csv('cows_and_goats.csv')","a26414c3":"wineReviews = pd.read_csv('..\/input\/wine-reviews\/winemag-data-130k-v2.csv', index_col = 0)\nwineReviews.head()\n\n# Selecting a column\ndesc = wineReviews['description']\ndesc\nprint(type(desc))","68b2fd98":"# Accessing a specific entry\n\n# wineReviews.description.iloc[0]\n\n# wineReviews['description'][0]\n\n# My chosen way\n\nwineReviews.description[0]","93b36773":"# return first row of data\n\n# iloc return data based on postions so it doesn't \n# take anything apart from integers as input. It can take ranges though.\n\n# iloc basically returns both columns as well as rows as function of no. of\n# positions.\n\nwineReviews.iloc[:4, :4]\n\n# loc on the other hands returns rows and columns based on their labels.\n# please note that loc includes the label at right side of range. iloc doesnt.\n\nwineReviews.loc[:4, :'points']\n\n\n","ec35d4c5":"# Return first few rows\n\n# wineReviews.description.head(10)\n\n# iloc also takes in range of data\nwineReviews.description.iloc[:10]\n\n# interesting things can be done with loc to select specific rows\/columns\n# Note that loc can take a boolean mask unlike iloc.\nwineReviews.loc[wineReviews['country']=='USA', 'country'] = 'US'\n\n# loc can take list of values as well\nsample_reviews = wineReviews.loc[[1,2,3,5,8]]\nsample_reviews\n","3a146a7d":"# loc since it takes a boolean mask as input, can be used for multiple things\n\n# eg. Select all the wines made in italy\n\nwineReviews.loc[wineReviews.country == 'Italy']","ce119be7":"top_oceania_wines = wineReviews.loc[(wineReviews.points >=95) & (wineReviews.country.isin(['Australia', 'New Zealand']))]\ntop_oceania_wines","ac8c19fb":"# Finding Median\n\n#Dataframe.Median takes (axis={0:index, 1: columns})\n# if used with a series object, it returns a single scalar value\n\n#median over index and columns\n\nhousing.median(axis = 0)","5ef93649":"# median over columns\nhousing.median(axis=1).head()","835a4bb6":"# Finding for a particular column\nhousing['total_rooms'].median()","05ad7f86":"# Finding unique values\n#df.unqiue returns a numpy array with unique values.\n\nhousing['housing_median_age'].unique()","c337a337":"# Value Counts method to see how many times each value appears\n\nhousing['housing_median_age'].value_counts().head()","49bd68d1":"# Center the data\n\n(housing.total_bedrooms - housing.total_bedrooms.mean()).head()","85886496":"# Find median income of the household with maximum total bedrooms\n# use of idxmax\n\nhousing.loc[housing.total_bedrooms.idxmax(), 'median_income']","9628da7e":"import math\nhousing.median_income.map(lambda x: math.floor(x)).head()\n\n# apply works similarly, it does not take dictionary or series as an argument \n# and works for dataframe as well. \n# Apply can take more complex functions as input\n\n# df.apply takes function and axis as arguments. axis = 0 is across rows ( in index direction)","7b951ce2":"# Just groupby returns a groupby object, whose columns can be accessed and any\n# aggregation functions can be used\nhousing.groupby('housing_median_age')","4401ea5b":"housing.groupby('housing_median_age').households.sum().head()","c3a8dacb":"# apply can be directly used on groupby object to manipulate individual dataframes\n\n# Know first total_rooms value in each group\n\nhousing.groupby('housing_median_age').apply(lambda df: df.total_rooms.iloc[0]).head()\n\n# Groupby can also be used on multiple columns. This results in creation of a \n# multi-index\n\n","47d23561":"# agg function lets you apply multiple aggregation functions at the same time\n# along with the groupby\n\nhousing.groupby('housing_median_age').households.agg(['count','sum','min','max']).head()","a2954a10":"# sort_values function let's us sort the values of dataframe. by default\n# the values returned are sorted by index when you do in operation on pandas\n\nhousing.sort_values(by = 'housing_median_age').head()\n\n# This defaults to ascending sort. In case we want descending, put \n\nhousing.sort_values(by = 'housing_median_age', ascending = False).head()","a6e9ea13":"# to sort by index, sort_index is used\n\nhousing.sort_index().head()\n\n# We can also sort by multiple columns, it first sorts by first columns, \n# then sorts by second column when encountered same values for first column.\n\nhousing.sort_values(by=['housing_median_age', 'total_rooms']).head()","afdef6e6":"# To simple return a size of each group , we do not need\n\n# housing.groupby('housing_median_age').some_column.count()\n\n# we can just do\n\nhousing.groupby('housing_median_age').size().head()","ce6938e7":"# Find dtype of every column\n\nhousing.dtypes\n\n# Find for some column\n\nhousing.longitude.dtype\n\n# Convert dtype\n\nhousing.longitude.astype('int32').head()","b7dd0b7f":"# Missing values in pandas are represented as NaNs, all their dtype is always \n# float64\n\n# Find out mssing values\n\n# housing.loc[housing.households.isnull()]\n\n# fill Nan Values\n\nhousing.total_rooms.fillna(0).head()\n\n# replace values ( useful for mssing values where value is not NaN)\n\nhousing.longitude.replace('unknown', 'someValue').head()","1547f1d8":"# rename columns\n\nhousing.head()\n\nhousing.rename(columns = {'longitude': 'long', 'latitude': 'lat'}).head()\n\n# we can similarly use dictionary to rename index as well\n\nhousing.rename(index = {0: 'first'}).head()","8cadae06":"# both row index and column index have their names apparently\n# these names can be renamed\n\nhousing.rename_axis('fields', axis = 'columns').rename_axis('rows', axis = 'rows').head()","4c66b713":"# Combining the dataframes\n\n# Concat method joins two dataframes having same columns. It basically adds the \n# rows of both the dataframes\n\n\nprint(len(housing))\n\nprint(len(pd.concat([housing, housing])))\n\n","a568abfb":"# Join method joins two dataframes with same indices. In case their column \n# names are same, we need to add lsuffix and rsuffix\n\nhousing.join(housing, lsuffix = '_left', rsuffix = '_right').head()","be1804a0":"# Merge is the third command which works exactly like sql join\n\n# result = pd.merge(user_usage,\n#                  user_device[['use_id', 'platform', 'device']],\n#                  on='use_id', \n#                  how='left')\n\n# Pandas default join is inner join\n\n# Note that Join and merge both behave in similar way. Join can also take an \n# attribute 'on' and behave similarly. But without this attribute, join functions \n# joins columns based on index. This is not the case with merge.","726a19e0":"## Creating structure and importing Data","a8ed3872":"## Renaming and Combining Data\n\n[Essential Basic Functionality](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/getting_started\/basics.html)\n\n[Merge Join and Concat](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/merging.html)\n\n[Kaggle Reference](https:\/\/www.kaggle.com\/residentmario\/renaming-and-combining-reference)","a6610aaf":"## Grouping and Sorting\n\n[Grouping and Sorting Reference](https:\/\/www.kaggle.com\/residentmario\/grouping-and-sorting-reference)\n\nGroupby as I already know divides the data in groups. A point worth noting in pandas is that each of these groups is a dataframe and can be accessed\/manipulated by using apply.\n","b0abd548":"## Saving Data","8389e95c":"## Indexing Selecting and Assigning Data\n","2248f17b":"#### IMQAV\n\n* Ingest\n    \n    * Import large volume of data rapidly\n    * eg. Tools like Kafka \n* Model\n    \n    * Data Storage Techniques\n    * Eg. Mysql, MongoDb\n* Query\n    \n    * Query and Manipulate Data\n* Analyze\n\n    * All ML data science Stat techniques go under here\n* Visualize\n\n  * Transform data in insightful format and generate reports\n  \n  \n  [Pandas Cheetsheet](https:\/\/github.com\/pandas-dev\/pandas\/blob\/master\/doc\/cheatsheet\/Pandas_Cheat_Sheet.pdf)\n","ae17dcb6":"Pandas Data frames are basically tables, with following three components\n* Index\n* Columns\n* Data\n\nThis is a two dimensional Structure.\n\nEach Dataframe column can also be represented as a pandas series.\nPandas Series is a 1D structure which includes\n* Index\n* Data\n","27b0a1af":"## Maps \n\n Map function is used on a series to do something on each value and replace it with new value\n\n Series.map takes either a dict, series ( with index same as column of caller series), function\nPython lambda function is especially helpful here.\n\n[Python lambda](https:\/\/www.w3schools.com\/python\/python_lambda.asp)\n\n[Pandas Series Map](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/reference\/api\/pandas.Series.map.html)\n\n","fd5666b7":"## Imorting Data in Pandas\n\n[Pandas Read CSV Datacamp](https:\/\/www.datacamp.com\/community\/tutorials\/pandas-read-csv)\n\n","35822d20":"## Data Types and Missing Data\n\n[Kaggle Reference](https:\/\/www.kaggle.com\/residentmario\/data-types-and-missing-data-reference)","37df5bfa":"## Summary Functions\n\n[Aggregation and Grouping in Pandas](https:\/\/data36.com\/pandas-tutorial-2-aggregation-and-grouping\/)","ab900a8b":"## Pandas Refresher","4cc9ef09":"iloc stands for index location. It can be directly used for returning a row from the dataframe. Consider that columns exist as a property of dataframe so we can access them like df.columnName but same doesn't hold true for index values."}}