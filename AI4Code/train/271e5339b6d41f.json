{"cell_type":{"990344c2":"code","1dec9dc6":"code","10245221":"code","e84c0b5c":"code","5c2ea7bf":"code","4f427e29":"code","592dc63a":"code","f0e1f9db":"code","dde3bb44":"code","0b4e1e38":"markdown","6f1de571":"markdown","1a279d1c":"markdown","737a9e3f":"markdown"},"source":{"990344c2":"import pandas as pd    \nimport numpy as np\nimport seaborn as sns\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nimport warnings\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning) \nwarnings.filterwarnings(\"ignore\", category=FutureWarning)\n\npd.set_option('display.max_columns', None); pd.set_option('display.max_rows', None);\npd.set_option('display.float_format', lambda x: '%.0f' % x)\nimport matplotlib.pyplot as plt\n\n#Data set reading process was performed.\ndf_2010_2011 = pd.read_excel(\"..\/input\/uci-online-retail-ii-data-set\/online_retail_II.xlsx\", sheet_name = \"Year 2010-2011\")\ndf = df_2010_2011.copy()\n\n# DATA PREPROCESSING\n# We extract the returned transactions from the data.\nreturned = df[df[\"Invoice\"].str.contains(\"C\",na=False)].index\ndf = df.drop(returned, axis = 0)\n\n#How much money has been earned per invoice? (It is necessary to create a new variable by multiplying two variables)\ndf[\"TotalPrice\"] = df[\"Quantity\"]*df[\"Price\"]\n# Missing observations were deleted.\ndf.dropna(inplace = True)\n\n\n#RFM METRIC ACCOUNT\n\n#RECENCY METRIC\nimport datetime as dt\ntoday_date = dt.datetime(2011,12,9)\ndf[\"Customer ID\"] = df[\"Customer ID\"].astype(int)\ntemp_df = (today_date - df.groupby(\"Customer ID\").agg({\"InvoiceDate\":\"max\"}))\ntemp_df.rename(columns={\"InvoiceDate\": \"Recency\"}, inplace = True)\nrecency_df = temp_df[\"Recency\"].apply(lambda x: x.days)\n\n# FREQUENCY METRIC\ntemp_df = df.groupby([\"Customer ID\",\"Invoice\"]).agg({\"Invoice\":\"count\"})\nfreq_df = temp_df.groupby(\"Customer ID\").agg({\"Invoice\":\"count\"})\nfreq_df.rename(columns={\"Invoice\": \"Frequency\"}, inplace = True)\n\n# MONETARY METRIC\nmonetary_df = df.groupby(\"Customer ID\").agg({\"TotalPrice\":\"sum\"})\nmonetary_df.rename(columns = {\"TotalPrice\": \"Monetary\"}, inplace = True)\nrfm = pd.concat([recency_df, freq_df, monetary_df],  axis=1)\ndf = rfm\ndf[\"RecencyScore\"] = pd.qcut(df['Recency'], 5, labels = [5, 4, 3, 2, 1])\ndf[\"FrequencyScore\"] = pd.qcut(df['Frequency'].rank(method = \"first\"), 5, labels = [1,2,3,4,5])\ndf[\"MonetaryScore\"] = pd.qcut(df['Monetary'], 5, labels = [1,2,3,4,5])\ndf[\"RFM_SCORE\"] = df['RecencyScore'].astype(str) + df['FrequencyScore'].astype(str) + df['MonetaryScore'].astype(str)\nseg_map = {\n        r'[1-2][1-2]': 'Hibernating',\n        r'[1-2][3-4]': 'At Risk',\n        r'[1-2]5': 'Can\\'t Loose',\n        r'3[1-2]': 'About to Sleep',\n        r'33': 'Need Attention',\n        r'[3-4][4-5]': 'Loyal Customers',\n        r'41': 'Promising',\n        r'51': 'New Customers',\n        r'[4-5][2-3]': 'Potential Loyalists',\n        r'5[4-5]': 'Champions'\n}\n\ndf['Segment'] = df['RecencyScore'].astype(str) + rfm['FrequencyScore'].astype(str)\ndf['Segment'] = df['Segment'].replace(seg_map, regex=True)\ndf.head()","1dec9dc6":"rfm = df.loc[:,\"Recency\":\"Monetary\"]","10245221":"df.groupby(\"Customer ID\").agg({\"Segment\": \"sum\"}).head()","e84c0b5c":"from sklearn.preprocessing import MinMaxScaler\nsc = MinMaxScaler((0,1))\ndf = sc.fit_transform(rfm)\nkmeans = KMeans(n_clusters = 10)\nk_fit = kmeans.fit(df)\nk_fit.labels_","5c2ea7bf":"kmeans = KMeans(n_clusters = 10)\nk_fit = kmeans.fit(df)\nssd = []\n\nK = range(1,30)\n\nfor k in K:\n    kmeans = KMeans(n_clusters = k).fit(df)\n    ssd.append(kmeans.inertia_)\n\nplt.plot(K, ssd, \"bx-\")\nplt.xlabel(\"Distance Residual Sums Versus Different k Values\")\nplt.title(\"Elbow method for Optimum number of clusters\")","4f427e29":"from yellowbrick.cluster import KElbowVisualizer\nkmeans = KMeans()\nvisu = KElbowVisualizer(kmeans, k = (2,20))\nvisu.fit(df)\nvisu.poof();","592dc63a":"kmeans = KMeans(n_clusters = 6).fit(df)\nkumeler = kmeans.labels_\npd.DataFrame({\"Customer ID\": rfm.index, \"Kumeler\": kumeler})\nrfm[\"cluster_no\"] = kumeler\nrfm[\"cluster_no\"] = rfm[\"cluster_no\"] + 1","f0e1f9db":"rfm.groupby(\"cluster_no\").agg({\"cluster_no\":\"count\"})","dde3bb44":"rfm.head()","0b4e1e38":"# 1) Data Understanding","6f1de571":"# 3) Determining the Optimum Number of Clusters","1a279d1c":"# RFM Clustering of Customers using K-Means\n## Description of data set\n\n- **InvoiceNo**: Invoice number. Nominal. A 6-digit integral number uniquely assigned to each transaction. If this code starts with the letter 'c', it indicates a cancellation.\n- **StockCode**: Product (item) code. Nominal. A 5-digit integral number uniquely assigned to each distinct product.\n- **Description**: Product (item) name. Nominal.\n- **Quantity**: The quantities of each product (item) per transaction. Numeric.\n- **InvoiceDate**: Invice date and time. Numeric. The day and time when a transaction was generated.\n- **UnitPrice**: Unit price. Numeric. Product price per unit in sterling (\u00c2\u00a3).\n- **CustomerID**: Customer number. Nominal. A 5-digit integral number uniquely assigned to each customer.\n- **Country**: Country name. Nominal. The name of the country where a customer resides.","737a9e3f":"# 2) Clustering with the K-Means Algorithm"}}