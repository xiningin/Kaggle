{"cell_type":{"288e27d8":"code","74573dfe":"code","d589c9d6":"code","90adf94d":"code","7ebe1d82":"code","76806d78":"code","1e88fec3":"code","276d891d":"code","f693462e":"code","e1114999":"code","933a1d37":"code","7c7da04e":"code","d6b6509b":"code","8fa80e9b":"code","3c47b9b2":"code","93183935":"code","e6a2f852":"code","16575e0a":"code","83079084":"code","0c26d578":"code","7c1658b8":"code","f7c54a61":"code","9825c959":"code","9b72889c":"code","b3d20321":"code","3c6e9d0a":"code","8b5c4365":"code","ac8d7799":"code","d1d11367":"code","15267c3a":"code","a3005bc1":"code","e412fd9e":"code","9fb676f8":"code","d1bf8b43":"code","6b50734a":"code","5d720cb6":"code","b0867bb3":"code","1b44d548":"code","c14654d6":"code","ddfdfb6c":"markdown","c192149e":"markdown","64a1572c":"markdown","28619e27":"markdown","953ac4dc":"markdown","20acf327":"markdown","8585bddf":"markdown","9c8ae4a1":"markdown","abaf64dc":"markdown","ceb57e85":"markdown","b364caf8":"markdown","449b2429":"markdown","b46d145b":"markdown","ccfbc813":"markdown","d3735934":"markdown","21e45bf2":"markdown","602c9962":"markdown","7647889d":"markdown","bef29fd6":"markdown","72fcb840":"markdown","a591d5c3":"markdown","3588b4ef":"markdown","3bd230dc":"markdown","a2ada195":"markdown","ecfd8f44":"markdown","ae161b86":"markdown","6fec1443":"markdown","df48186d":"markdown","c3cad327":"markdown","2c43c223":"markdown","2ad27e80":"markdown","7c86212b":"markdown","0ab894ec":"markdown","7b08ac20":"markdown"},"source":{"288e27d8":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n%matplotlib inline\n\n# Load the diamond's dataset\ndiamonds = pd.read_csv(\"..\/input\/diamonds.csv\")","74573dfe":"# Preview the top (five) rows of the dataset\ndiamonds.head()","d589c9d6":"# Preview the little information about dataset\ndiamonds.info()","90adf94d":"# Drop the \"Unnamed: 0\" column\ndiamonds = diamonds.drop(\"Unnamed: 0\", axis = 1)\n\n# Price is int64, best if all numeric attributes have the same datatype, especially as float64\ndiamonds[\"price\"] = diamonds[\"price\"].astype(float)\n\n# Preview dataset again\ndiamonds.head()","7ebe1d82":"# The diamond cut categories\ndiamonds[\"cut\"].value_counts()","76806d78":"# The diamond color categories\ndiamonds[\"color\"].value_counts()","1e88fec3":"# The diamond clarity categories\ndiamonds[\"clarity\"].value_counts()","276d891d":"# Summary of each numerical attribute\ndiamonds.describe()","f693462e":"diamonds.hist(bins = 50, figsize = (20, 15))\nplt.show()","e1114999":"# Create a correlation matrix between every pair of attributes\ncorr_matrix = diamonds.corr()\n\n# Plot the correlation with seaborn\nplt.subplots(figsize = (10, 8))\nsns.heatmap(corr_matrix, annot = True)\nplt.show()","933a1d37":"diamonds[\"carat\"].hist(bins = 50)\nplt.show()","7c7da04e":"# Divide the diamond carats by 0.4 to limit the number of carat categories\n# Round up to have discrete categories\ndiamonds[\"carat_cat\"] = np.ceil(diamonds[\"carat\"] \/ 0.35)\n\n# Merge categories > 5 in 5\ndiamonds[\"carat_cat\"].where(diamonds[\"carat_cat\"] < 5, 5.0, inplace = True)","d6b6509b":"# Check the distribution of the diamonds in the categories\ndiamonds[\"carat_cat\"].value_counts()","8fa80e9b":"diamonds[\"carat_cat\"].hist()\nplt.show()","3c47b9b2":"# Import the sklearn module\nfrom sklearn.model_selection import StratifiedShuffleSplit\n\n# Run the split. Creates on split and shares 20% of the dataset for the test set\nsplit = StratifiedShuffleSplit(n_splits = 1, test_size = 0.2, random_state = 42)\n\n# Separate the stratified train set and the test set\nfor train_index, test_index in split.split(diamonds, diamonds[\"carat_cat\"]):\n    strat_train_set = diamonds.loc[train_index]\n    strat_test_set = diamonds.loc[test_index]","93183935":"for set in (strat_train_set, strat_test_set):\n    set.drop([\"carat_cat\"], axis = 1, inplace = True)","e6a2f852":"# Redefined diamonds dataset\ndiamonds = strat_train_set.copy()\ndiamonds.head()","16575e0a":"sns.pairplot(diamonds[[\"price\", \"carat\", \"cut\"]], hue = \"cut\", height = 5)\nplt.show()\nsns.barplot(x = \"carat\", y = \"cut\", data = diamonds)\nplt.show()\nsns.barplot(x = \"price\", y = \"cut\", data = diamonds)\nplt.show()","83079084":"sns.pairplot(diamonds[[\"price\", \"carat\", \"color\"]], hue = \"color\", height = 5)\nplt.show()\nsns.barplot(x = \"carat\", y = \"color\", data = diamonds)\nplt.show()\nsns.barplot(x = \"price\", y = \"color\", data = diamonds)\nplt.show()","0c26d578":"sns.pairplot(diamonds[[\"price\", \"carat\", \"clarity\"]], hue = \"clarity\", height = 5)\nplt.show()\nsns.barplot(x = \"carat\", y = \"clarity\", data = diamonds)\nplt.show()\nsns.barplot(x = \"price\", y = \"clarity\", data = diamonds)\nplt.show()","7c1658b8":"from pandas.plotting import scatter_matrix\n\nattributes = [\"x\", \"y\", \"z\", \"table\", \"depth\", \"price\"]\nscatter_matrix(diamonds[attributes], figsize=(25, 20))\nplt.show()","f7c54a61":"# Do not stratify the label\ndiamonds = strat_train_set.drop(\"price\", axis = 1)\n\n# Set a new dataset label variable\ndiamond_labels = strat_train_set[\"price\"].copy()\n\n# Drop all the category, so we could have only numeric\ndiamonds_num = diamonds.drop([\"cut\", \"color\", \"clarity\"], axis = 1)\ndiamonds_num.head()","9825c959":"from sklearn.preprocessing import StandardScaler\n\n# Perform the feature scaling on the numeric attributes of the dataset\nnum_scaler = StandardScaler()\ndiamonds_num_scaled = num_scaler.fit_transform(diamonds_num)\n\n# Preview \npd.DataFrame(diamonds_num_scaled).head()","9b72889c":"# We need only the category attributes to work with here\ndiamonds_cat = diamonds[[\"cut\", \"color\", \"clarity\"]]\ndiamonds_cat.head()","b3d20321":"from sklearn.preprocessing import OneHotEncoder\n\n# Perform the one-hot encoding on the category attributes of the dataset\ncat_encoder = OneHotEncoder()\ndiamonds_cat_encoded = cat_encoder.fit_transform(diamonds_cat)\n\n# Convert the encoded categories to arrays and Preview\npd.DataFrame(diamonds_cat_encoded.toarray()).head()","3c6e9d0a":"from sklearn.compose import ColumnTransformer\n\nnum_attribs = list(diamonds_num)\ncat_attribs = [\"cut\", \"color\", \"clarity\"]\n\n# Pipeline to transform our dataset\npipeline = ColumnTransformer([\n    (\"num\", StandardScaler(), num_attribs), # Perform feaured scaling on numeric attributes\n    (\"cat\", OneHotEncoder(), cat_attribs) # Perform One-Hot encoding on the category attributes\n])","8b5c4365":"# Transformed dataset to feed the ML Algorithm\ndiamonds_ready = pipeline.fit_transform(diamonds)\n\n# Preview\npd.DataFrame(diamonds_ready).head()","ac8d7799":"from sklearn.metrics import mean_squared_error\nfrom sklearn.model_selection import cross_val_score\nfrom random import randint\n\n# Our test set\n\n# Remove label from test set\nX_test = strat_test_set.drop(\"price\", axis = 1)\n# Have label stand alone\ny_test = strat_test_set[\"price\"].copy()\n\n# Our models performance holder\nmodels_rmse = [] # Holds Models original RMSE\ncvs_rmse_mean = [] # Holds the Cross Validation RMSE Mean\ntests_rmse = [] # Holds the tests RMSE\ntests_accuracy = [] # Holds the tests accuracy\nmodels = [] # Holds the models name\n\ndef display_model_performance(model_name, model, diamonds = diamonds_ready, labels = diamond_labels,\n                              models_rmse = models_rmse, cvs_rmse_mean = cvs_rmse_mean, tests_rmse = tests_rmse,\n                              tests_accuracy = tests_accuracy, pipeline = pipeline, X_test = X_test,\n                              y_test = y_test, cv = True):\n    # Fit dataset in model\n    model.fit(diamonds, labels)\n    \n    # Setup predictions\n    predictions = model.predict(diamonds)\n    \n    # Get models performance\n    model_mse = mean_squared_error(labels, predictions)\n    model_rmse = np.sqrt(model_mse)\n    \n    # Cross validation\n    cv_score = cross_val_score(model, diamonds, labels, scoring = \"neg_mean_squared_error\", cv = 10)\n    cv_rmse = np.sqrt(-cv_score)\n    cv_rmse_mean = cv_rmse.mean()\n    \n    print(\"RMSE: %.4f\" %model_rmse)\n    models_rmse.append(model_rmse)\n    \n    print(\"CV-RMSE: %.4f\" %cv_rmse_mean)\n    cvs_rmse_mean.append(cv_rmse_mean)\n    \n    print(\"--- Test Performance ---\")\n    \n    X_test_prepared = pipeline.transform(X_test)\n    \n    # Fit test dataset in model\n    model.fit(X_test_prepared, y_test)\n    \n    # Setup test predictions\n    test_predictions = model.predict(X_test_prepared)\n    \n    # Get models performance on test\n    test_model_mse = mean_squared_error(y_test, test_predictions)\n    test_model_rmse = np.sqrt(test_model_mse)\n    print(\"RMSE: %.4f\" %test_model_rmse)\n    tests_rmse.append(test_model_rmse)\n    \n    # Tests accuracy\n    test_accuracy = round(model.score(X_test_prepared, y_test) * 100, 2)\n    print(\"Accuracy:\", str(test_accuracy)+\"%\")\n    tests_accuracy.append(test_accuracy)\n    \n    # Check how well model works on Test set by comparing prices\n    start = randint(1, len(y_test))\n    some_data = X_test.iloc[start:start + 7]\n    some_labels = y_test.iloc[start:start + 7]\n    some_data_prepared = pipeline.transform(some_data)\n    print(\"Predictions:\\t\", model.predict(some_data_prepared))\n    print(\"Labels:\\t\\t\", list(some_labels))\n    \n    models.append(model_name)\n    \n    # Preview plot\n    plt.scatter(diamond_labels, model.predict(diamonds_ready))\n    plt.xlabel(\"Actual\")\n    plt.ylabel(\"Predicted\")\n    x_lim = plt.xlim()\n    y_lim = plt.ylim()\n    plt.plot(x_lim, y_lim, \"k--\")\n    plt.show()\n    \n    print(\"------- Test -------\")\n    plt.scatter(y_test, model.predict(X_test_prepared))\n    plt.xlabel(\"Actual\")\n    plt.ylabel(\"Predicted\")\n    plt.plot(x_lim, y_lim, \"k--\")\n    plt.show()","d1d11367":"from sklearn.linear_model import LinearRegression\n\nlin_reg = LinearRegression(normalize = True)\ndisplay_model_performance(\"Linear Regression\", lin_reg)","15267c3a":"from sklearn.tree import DecisionTreeRegressor\n\ntree_reg = DecisionTreeRegressor(random_state = 42)\ndisplay_model_performance(\"Decision Tree Regression\", tree_reg)","a3005bc1":"from sklearn.ensemble import RandomForestRegressor\n\nforest_reg = RandomForestRegressor(n_estimators = 10, random_state = 42)\ndisplay_model_performance(\"Random Forest Regression\", forest_reg)","e412fd9e":"from sklearn.linear_model import Ridge\n\nridge_reg = Ridge(normalize = True)\ndisplay_model_performance(\"Ridge Regression\", ridge_reg)","9fb676f8":"from sklearn.linear_model import Lasso\n\nlasso_reg = Lasso(normalize = True)\ndisplay_model_performance(\"Lasso Regression\", lasso_reg)","d1bf8b43":"from sklearn.linear_model import ElasticNet\n\nnet_reg = ElasticNet()\ndisplay_model_performance(\"Elastic Net Regression\", net_reg)","6b50734a":"from sklearn.ensemble import AdaBoostRegressor\n\nada_reg = AdaBoostRegressor(n_estimators = 100)\ndisplay_model_performance(\"AdaBoost Regression\", ada_reg)","5d720cb6":"from sklearn.ensemble import GradientBoostingRegressor\n\ngrad_reg = GradientBoostingRegressor(n_estimators = 100, learning_rate = 0.1,\n                                     max_depth = 1, random_state = 42, loss = 'ls')\ndisplay_model_performance(\"GradientBoosting Regression\", grad_reg)","b0867bb3":"compare_models = pd.DataFrame({ \"Algorithms\": models, \"Models RMSE\": models_rmse, \"CV RMSE Mean\": cvs_rmse_mean,\n                              \"Tests RMSE\": tests_rmse, \"Tests Accuracy\": tests_accuracy })\ncompare_models.sort_values(by = \"Tests Accuracy\", ascending = False)","1b44d548":"sns.barplot(x = \"Tests Accuracy\", y = \"Algorithms\", data = compare_models)\nplt.show()","c14654d6":"import pickle\n\nwith open('final_model.pkl', 'wb') as f:\n    pickle.dump(tree_reg, f)","ddfdfb6c":"### Lasso Regression","c192149e":"### Ridge Regression","64a1572c":"### Decision Tree Regression","28619e27":"These visualizations have been met by our theories during correlation. And it's very obvious here that depth and table have very weak correlation with price.\n\n## Feature Scaling\n\nWith few exceptions, Machine Learning algrorithms don't perform well when the input numerical attributes have very different scales. We sure want our models to work well, so how can we go about it?\n\nFeature scaling can be done in 2 ways: **Min-max scaling** and **Standardization**. I would preferably use Standardization, because it is much less affected by outliers. Scikit-Learn provides a transformer called `StandardScaler` for this transformation.\n\n**PS:** You don't stratify your label, which is in our case `price`.","953ac4dc":"We can now start fitting models and get their performance error. Remember we are using **Root Mean Squared Error** for our performance measure.\n\nLet's start with the easiest model - `Linear Regression`","20acf327":"From the plot above, we could deduce that:\n- `x`, `y`, `z` have strong correlations with `price`\n- `carat` has the strongest correlation with `price` (0.92)\n- `table` and `depth` have the weakest correlations\n\nIt is amazing so see that `carat` correlates best with price. Its score is pretty high! Now we use this for our *Stratified Sampling*.\n\nLet's take a closer look at the `carat`'s histogram.","8585bddf":"# Diamond Price Modelling\n\nThis is my first ever machine learning project. I will be applying what I've learnt so far (since 2 weeks) on this data set.\n\nIn this notebook, we will explore the factors that affect the price of a diamond with a goal of finding a model to help predict the price of diamonds.\n\n### Notice\n- The problem is requires **Supervised Learning**. The instances come with an expected output (*i.e* **the diamond's price**).\n- Predicting the price of a diamond from dataset is a **Regression Task**. More specifically, a **Multivariate Regression Task**.\n- We will be using the **Batch Learning** technique since the data is not live-fed from a source.\n- We will also be the **Root Mean Square Error (RMSE)** for our performance measure (typical for Regression tasks).\n\n**If you like this notebook, please up-vote! It keeps me motivated. Thank you! :)**","9c8ae4a1":"That is what our data *will* look like during its processing. That's for the Machine Learning algorithm.\n\n## Handling Categorical Attributes\n\nFrom above, we split the columns of our dataset, putting aside the category attributes. Remember we still wanted to convert these attributes to numericaal attributes. How to we go about this?\n\nWe create one binary attribute per category: one attribute will be one while the rest will be 0. This is called **One-Hot Encoding**. Scikit-Learn provides a `OneHotEncoder` encoder to convert our category attributes to One-Hot vectors.","abaf64dc":"Now let's see how much the diamonds are distributed in relation to the carat categories.","ceb57e85":"## Save model","b364caf8":"### Linear Regression","449b2429":"Okay. I was really surprised seeing some **100% accuracy** from the `Decision Tree Regression `Model. That is just too perfect. Noticed that some dataset from the test set were selected and compared and that was just right!\n\nAnother model that we could depend on is the `Random Forest Regression`. It works relatively fine in my opinion.","b46d145b":"They each don't have so many categories, but still, we will be having a much longer table (*more columns*). That aside for now.\n\nLet's take a preview of the summary of the numerical attributes and then an histogram on the dataset.","ccfbc813":"`Fair` cuts are most weighed, but they aren't the most expensive diamonds. `Premium` cuts weigh less than the fair and then cost more. `Ideal` cuts weigh way less and they are least expensive. The cut therefore is relatively considered while determining the price of the diamond.","d3735934":"We now have our Train set and Test set, both stratified. From here, we don't need the `carat_cat` anylonger, hence we can drop it.","21e45bf2":"### GradientBoosting Regression","602c9962":"Now that's what I meant by a longer table. What do we do next?\n\n## Transformation Pipeline\nWe have our tables reformed, what we do now to to merge the numeric feature scaled attributes and the encoded category attributes. An easy way to do this without writing so much like above is to Scikit-Learn's `ColumnTransformer` class. This merging provides a single pipeline for the whole dataset.","7647889d":"### AdaBoost Regression","bef29fd6":"Most diamonds are roughly between 0.3 and 1.5 Carats. Let's divide them into 5 categories, with those more than the 5th category merging into the 5th category.","72fcb840":"Noticed an unnecessary column `Unnamed: 0`. It just acts as index, it is not needed, thus that needs to be dropped.","a591d5c3":"### Elastic Net Regression","3588b4ef":"Here, we could see that the color `J` which is the most weighed is also the most priced. The last 2 plots are very similar. We could see here that the color of the diamond is also very dependent on its price.","3bd230dc":"There are **53490** instances in the dataset. There are also no missing instances in the dataset. *That looks clean!*\n\nIt's easier to work a dataset when all its attributes are numerical. The **cut**, **color** and **clarity** attributes are non-numeric (They are *objects*). We still have to convert them to be numerical.\n\nLet's find out what categories exist for each of them.","a2ada195":"## Take a quick look at the Data Structure\n\nLet's take a quick look at our diamonds dataset.","ecfd8f44":"Our new `diamonds` dataset will now be the *Stratified Train set*.","ae161b86":"We now have our newly transformed dataset that can easily be fed to our Machine Learning Algorithms.\n\n## Select and Train Model\n\nWe will create one function that will run through each algorithm. We'll also have variables that hold results of the algorithms for future comparisons. What does our fat function do?\n\n- Fits the dataset into the model and create series of predictions to compare with labels. We check its performance with the **RMSE**.\n\n- Performs some evaluation using Cross validation, which splits the training set into a number of CVs and train the model on the smaller sets. We then compare its mean with our intial RMSE.\n\n- We view how well the model performs on our test set and compare its RMSE with that of the train set. Hopefully we don't have much difference.\n\n- Some accuracy test of the model on the dataset is being evaluated\n\n- We could also have a preview of what's going on. Some parts of the test set will be selected and then the model will run on them and we can then compare its result with the expected prices.\n\n- We also get a preview this model's plot results and see how well it fits","6fec1443":"Okay good! But what about the categorical attributes? What happens to them now? We are still going to make out a solution for them. But there's also something important we have to do and that is **\"Creating a Test Set\"**.\n\n## Create a Test Set\n\nI've learnt it is a good practice to separate your **Train Set** and **Test Set** (80% and 20% from your dataset respectively). The Test set will make us see our model's performance on the new instances.\n\nThat's clear! **But**, even though we want to do this, it doesn't feel right taking purely random samples of the dataset, else we could introduce a significant **Sampling Bias**. A good solution is by performing **Stratified Sampling**. The dataset will be divided into homogeneous subgroups called strata, and the right number of instances is sampled from each stratum to guarantee that the test set is representative of the overall dataset. (*Hopefully, that's clear enough*)\n\nTo use this, we will need a very important attribute of the dataset to predict the of the diamond. How can we try select the attribute even though the team of those who gave you data didn't give you a clue? This is where we need to know the attributes that are most correlated to the price of the diamond. We use the **Standard Correlation Coefficient** (Pearson's r) to determine.","df48186d":"### Random Forest Regression","c3cad327":"The distribution looks nice enough.\n\n**PS:** I adjusted the divisor of `carat` until the distribution of the diamonds looked nice. *You could comment if you have any other ideas to doing this* :)\n\nAnd yup! We can now perform a Stratified Sampling based on the carat categories :) I will use Scikit-Learn's `StratifiedShuffleSplit` class.","2c43c223":"## Data Visualization\n\nLet's play around with some visualization of our dataset and make some observations out of it.","2ad27e80":"A little more information about our dataset.","7c86212b":"Here, we could see that `I1` doesn't hold the highest clarity, even though it is the most priced. But there's something else: Apart from `I1`, if the rest stays, the price of a diamond could **fairly** be relative to its clarity, to some extent.","0ab894ec":"## Conclusion\n\nThe **Decision Tree Algorithm** wins it all here!\n\nWhat do you think about the deduced model? Could it really be? Please comment your opinions.\n\nThat's all for now. I'm still learning, so I would love some feedback!\n\n**If you find this notebook useful, Please upvote this notebook it keeps me motivated.** Also I do look forward to suggestions, so please comment if any. Thank you!","7b08ac20":"## Compare Models Performance"}}