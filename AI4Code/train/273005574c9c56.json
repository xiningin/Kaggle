{"cell_type":{"6d1e4c00":"code","7a34bbbf":"code","c112acbe":"code","3d220392":"code","120ca1ce":"code","5e967d87":"code","60c29dc6":"code","ea4aab72":"code","2f000c6d":"code","1c818323":"code","63c760d5":"code","d1c84de6":"code","27844497":"code","28c4c2b2":"code","59dd0d86":"code","e4dbc9e0":"code","2655297d":"code","39089ac0":"markdown","37d51301":"markdown","9fe537f8":"markdown","d1b677ea":"markdown","7c5dfda6":"markdown","6fad4aa4":"markdown","d5946e2d":"markdown","296e60b1":"markdown","f98f1f26":"markdown","891af599":"markdown","f0864951":"markdown"},"source":{"6d1e4c00":"# Bibliotecas necess\u00e1rias\n# Manipula\u00e7\u00e3o de dados\nimport pandas as pd\n# Redes Neurais\nfrom tensorflow import keras\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, Conv2D, MaxPooling2D, Flatten\nfrom tensorflow.keras.optimizers import RMSprop\n# Plot\nimport matplotlib.pyplot as plt\n%matplotlib inline\n# Avalia\u00e7\u00e3o\nfrom sklearn.metrics import classification_report, confusion_matrix\n","7a34bbbf":"# Lendo o dataset do Kaggle\ntrain = pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")","c112acbe":"print(\"Quantidade de elementos de treino: {}\". format(len(train)))\nprint(train.head())","3d220392":"# Separando x_train e y_train\nY = train[\"label\"]\nX = train.drop(labels = [\"label\"],axis = 1)\n# Em formato numpy array de imagens 28 x 28\n#x = X.values.reshape(-1,28,28,1)\n#print(x[0])","120ca1ce":"# Transformando a imagem 2d em um numpy array (imagem 28*28)\nx = X.values.reshape(42000, 28, 28, 1)\n\n# Normalizando para valores entre 0 e 1\nx = x.astype('float32')\nx \/= 1023","5e967d87":"# Vamos ajustar o formato da saida\nnum_classes = 10\n\n# Convertendo para um vetor de saida com 10 dimensoes\ny = keras.utils.to_categorical(Y, num_classes)","60c29dc6":"# Separando uma parte para treino (90%) e outra para valida\u00e7\u00e3o (10%)\nfrom sklearn.model_selection import train_test_split\nx_train, x_val, y_train, y_val = train_test_split(x, y, test_size = 0.1, random_state=5)\nprint('Qtde de treino: {}'.format(len(x_train)))\nprint('Qtde de valida\u00e7\u00e3o: {}'.format(len(x_val)))","ea4aab72":"# Criando o modelo Sequential\n# Sequential: Modelo Keras de ir adicionando camadas (como um lego)\n# Conv2D: Camada com kernels (filtros) que percorrem a imagem extraindo caracter\u00edsitcas (mapas de caracte\u00edsticas)\n# MaxPooling2D: Camada que reduz a dimensionalidade dos mapas de caracter\u00edsticas 2D\n# Flatten: Camada que transforma um mapa de caracter\u00edsticas 2D num vetor para classficador final\n# Dense: Camada onde todas as entradas est\u00e3o conectadas em cada neur\u00f4nio (totalmente conectada)\n# Dropout: Camada usa durante treino que descarta aleatoriamente um percentual de conex\u00f5es (reduz overfitting)\n\nmodel = Sequential()\n# Convolu\u00e7\u00e3o\nmodel.add(Conv2D(40, kernel_size=(3, 3),activation='relu',input_shape=(28,28,1)))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Conv2D(20, kernel_size=(3,3), activation='relu'))\nmodel.add(Dropout(0.05))\nmodel.add(Conv2D(30, kernel_size=(4,4), activation='relu'))\nmodel.add(Dropout(0.05))\nmodel.add(Conv2D(20, kernel_size=(3,3), activation='relu'))\nmodel.add(Conv2D(20, kernel_size=(2,2), activation='relu'))\n# Ep\u00edlogo\nmodel.add(Flatten())\nmodel.add(Dense(50, activation='relu'))\nmodel.add(Dropout(0.1))\nmodel.add(Dense(num_classes, activation='softmax'))","2f000c6d":"# Compila o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer=RMSprop(),\n              metrics=['accuracy'])","1c818323":"# Treina com os parte dos dados\nbatch_size = 32\nepochs = 25\n\n#Salvar o melhor modelo\ncallbacks_list = [\n    keras.callbacks.ModelCheckpoint(\n        filepath='model.h5',\n        monitor='val_loss', save_best_only=True, verbose=1),\n    keras.callbacks.EarlyStopping(monitor='val_loss', patience=25,verbose=1)\n]\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=batch_size,\n                    epochs=epochs,\n                    callbacks = callbacks_list,\n                    verbose=1,\n                    validation_data=(x_val, y_val))","63c760d5":"fig, ax = plt.subplots(1,2, figsize=(16,8))\nax[0].plot(history.history['loss'], color='b', label=\"Training loss\")\nax[0].plot(history.history['val_loss'], color='r', label=\"validation loss\",axes =ax[0])\nlegend = ax[0].legend(loc='best', shadow=True)\n\nax[1].plot(history.history['accuracy'], color='b', label=\"Training accuracy\")\nax[1].plot(history.history['val_accuracy'], color='r',label=\"Validation accuracy\")\nlegend = ax[1].legend(loc='best', shadow=True)","d1c84de6":"from tensorflow.keras.models import load_model\nmodel = load_model('model.h5')","27844497":"# Testando\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","28c4c2b2":"import itertools\n\n# Gerando matriz de confus\u00e3o\ndef plot_confusion_matrix(cm, classes, normalize=True, title='Confusion matrix', cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.figure(figsize=(10,10))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        cm = np.around(cm, decimals=2)\n        cm[np.isnan(cm)] = 0.0\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","59dd0d86":"# Vendo alguns reports\n# Usando sklearn\nimport numpy as np\n\n# Classificando toda base de teste\ny_pred = model.predict_classes(x_val)\n# voltando pro formato de classes\ny_test_c = np.argmax(y_val, axis=1)\ntarget_names = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n#Confution Matrix\ncm = confusion_matrix(y_test_c, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\n\nprint('Classification Report')\nprint(classification_report(y_test_c, y_pred, target_names=target_names))","e4dbc9e0":"# Gerando sa\u00edda para dataset de teste\n\n#Carrega dataset de teste\ntest = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\nprint(\"Qtde de testes: {}\".format(len(test)))\n# Bota no formato numpy e normaliza\nx_test = test.values.reshape(len(test),28,28,1)\nx_test = x_test.astype('float32')\nx_test \/= 255\n\n# Faz classifica\u00e7\u00e3o para dataset de teste\ny_pred = model.predict_classes(x_test)\n\n# Verficando algum exemplo\ni = 0\nplt.imshow(test.values[i].reshape(28,28), cmap=plt.cm.binary)\nplt.show()\nprint('Previsto: {}'.format(y_pred[i]))\n\n# Botando no formato de sa\u00edda (competi\u00e7\u00e3o Kaggle)\nresults = pd.Series(y_pred,name=\"Label\")\nsubmission = pd.concat([pd.Series(range(1,len(y_pred)+1),name = \"ImageId\"),results],axis = 1)\nprint(submission.head(10))\n#Salvando Arquivo\nsubmission.to_csv(\"mlp_mnist_v1.csv\",index=False)","2655297d":"# Introduzindo ruido nas entradas\nimport numpy as np\nmean = 0.\nstddev = 0.2\nnoise = np.random.normal(mean, stddev, (4200, 28, 28,1))\nx_te = x_val + noise\nx_te = np.clip(x_te, 0., 1.)\n\nplt.imshow(x_te.reshape(4200, 28,28)[0], cmap=plt.cm.binary)\nplt.show()\n\n# Testando\nscore = model.evaluate(x_te, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","39089ac0":"# Mudan\u00e7a no batch size e nas \u00e9pocas\nO valor do batch_size tamb\u00e9m foi alterado tanto aumentando (64, 128) quanto reduzindo (16). O mesmo procedimento para as \u00e9pocas foi feito. Um treino de at\u00e9 50 \u00e9pocas foi executado. Optou-se por 25 \u00e9pocas.","37d51301":"# Teste Adicional: Com ru\u00eddo","9fe537f8":"# Altera\u00e7\u00e3o da normaliza\u00e7\u00e3o\n\nAqui foi feita uma altera\u00e7\u00e3o para tentar diminuir a precis\u00e3o dos p\u00edxeis.\nNo in\u00edcio, o tipo dos valores foi dobrado para float64 mas depois retornado para float32 (n\u00e3o surtiu efeito).\nE a divis\u00e3o logo em seguida foi aumentada em 4 vezes para diminuir a precis\u00e3o tamb\u00e9m (antes era 255).\n","d1b677ea":"Com ru\u00eddo, percebemos que a acur\u00e1cia dos exemplos de valida\u00e7\u00e3o caiu, mas muito menos que o modelo MLP cl\u00e1ssico (ver exemplo de MLP).\nUm modelo Convolucional (CNN) captura melhor regi\u00f5es, ou padr\u00f5es espaciais de pixels, tornando o modelo mais robusto.","7c5dfda6":"# Criando e treinando o Modelo\n**Modifica\u00e7\u00e3o do dropout:**\n\nO dropout de 20% a princ\u00edpio foi divido para ser 2 de 10% pelas camadas. Depois s\u00f3 foi acrescentado um dropout de 10% no meio das camadas pois a acur\u00e1cia do teste mesmo estando muito alta (pr\u00f3xima de 0,999), a acur\u00e1cia dos testes reais ainda era de 0,98. Agora, os 20% iniciais foi dividido em 3 partes, 5% para as camadas de convolu\u00e7\u00e3o e 10% para o fim.\n\n**Modifica\u00e7\u00e3o do Max Pooling:**\n\nV\u00e1rios testes de Max Pooling (MP) tamb\u00e9m foram realizados: foram acrescentados MP de (2,2), (3,3), (4,4) e at\u00e9 um treino sem MP. No fim, optou-se pelo MP inicial.\n\n**Modifica\u00e7\u00e3o das camadas de convolu\u00e7\u00e3o**\n\nEssa foi a etapa com mais testes. Foram treinados modelos com at\u00e9 10 camadas de convolu\u00e7\u00e3o de (3,3); modelos com camadas de matrizes grandes: (4,4) (5,5) e (7,7); modelos com camadas pequenas: (2,2) e (1,1). A maioria n\u00e3o surtou muito efeito em quest\u00e3o de melhoria da acur\u00e1ria. Depois desses testes, o melhor modelo para as camadas de convolu\u00e7\u00e3o foi esse: na primeira camada, foram acrescentados mais 10 neur\u00f4nios. Al\u00e9m disso, mais 3 camadas de convolu\u00e7\u00e3o foram acrescentadas com 20, 30 e 20 neur\u00f4nios. As matrizes foram (4,4) para buscar par\u00e2metros maiores na figura, (3,3) padr\u00e3o e (2,2) para detalhes menores.\n","6fad4aa4":"# Problemas no modelo\nPela matriz de confus\u00e3o, os problemas de reconhecer os d\u00edgitos est\u00e3o relacionados \u00e0queles com formas parecidas. Por exemplo 8 e 9, 6 e 5, 7 e 2.","d5946e2d":"**Resumo:**\n\nTodo o c\u00f3digo abaixo \u00e9 uma deriva\u00e7\u00e3o daquele mostrado em sala de aula. Os ajustes foram feitos na configura\u00e7\u00e3o da CNN para se obter a acur\u00e1cia m\u00e1xima para o desafio Digit Recognizer do Kaggle. ","296e60b1":"# Introdu\u00e7\u00e3o","f98f1f26":"# Bibliotecas e Dados","891af599":"# Gerando Sa\u00edda","f0864951":"# Avaliando o Modelo"}}