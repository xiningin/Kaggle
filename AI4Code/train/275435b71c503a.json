{"cell_type":{"3b44aefb":"code","d3b3835f":"code","4f533fb2":"code","b7d6b424":"code","26eb9e3c":"code","73332a60":"code","43c5ad8b":"code","87856db6":"code","3973ec31":"code","afd8b065":"code","d8552dd9":"code","aec369d3":"code","5b504297":"markdown","615bdd2d":"markdown","9738c4ed":"markdown","ca73d08d":"markdown"},"source":{"3b44aefb":"import numpy as np \nimport pandas as pd\n\nfrom PIL import Image\n\nimport torch\nimport torch.nn as nn\nimport torch.utils.data as D\nimport torch.nn.functional as F\n\nimport torchvision\nfrom torchvision import transforms as T\n\nimport tqdm\n\nimport warnings\nwarnings.filterwarnings('ignore')","d3b3835f":"path_data = '..\/input\/'\ndevice = 'cuda'\nbatch_size = 16","4f533fb2":"class ImagesDS(D.Dataset):\n    def __init__(self, csv_file, img_dir, mode='train', site=1, channels=[1,2,3,4,5,6]):\n        \n        df = pd.read_csv(csv_file)\n        self.records = df.to_records(index=False)\n        self.channels = channels\n        self.site = site\n        self.mode = mode\n        self.img_dir = img_dir\n        self.len = df.shape[0]\n        \n    @staticmethod\n    def _load_img_as_tensor(file_name):\n        with Image.open(file_name) as img:\n            return T.ToTensor()(img)\n\n    def _get_img_path(self, index, channel):\n        experiment, well, plate = self.records[index].experiment, self.records[index].well, self.records[index].plate\n        return '\/'.join([self.img_dir,self.mode,experiment,f'Plate{plate}',f'{well}_s{self.site}_w{channel}.png'])\n        \n    def __getitem__(self, index):\n        paths = [self._get_img_path(index, ch) for ch in self.channels]\n        img = torch.cat([self._load_img_as_tensor(img_path) for img_path in paths])\n        \n        if self.mode == 'train':\n            return img, self.records[index].sirna\n        else:\n            return img, self.records[index].id_code\n\n    def __len__(self):\n        \"\"\"\n        Total number of samples in the dataset\n        \"\"\"\n        return self.len","b7d6b424":"ds = ImagesDS(path_data+'\/train.csv', path_data)\nds_test = ImagesDS(path_data+'\/test.csv', path_data, mode='test')","26eb9e3c":"class DensNet(nn.Module):\n    def __init__(self, num_classes=1000, num_channels=6):\n        super().__init__()\n        preloaded = torchvision.models.densenet121(pretrained=True)\n        self.features = preloaded.features\n        self.features.conv0 = nn.Conv2d(num_channels, 64, 7, 2, 3)\n        self.classifier = nn.Linear(1024, num_classes, bias=True)\n        del preloaded\n        \n    def forward(self, x):\n        features = self.features(x)\n        out = F.relu(features, inplace=True)\n        out = F.adaptive_avg_pool2d(out, (1, 1)).view(features.size(0), -1)\n        out = self.classifier(out)\n        return out","73332a60":"classes = 1108\nmodel = DensNet(num_classes=classes)\nmodel.to(device);","43c5ad8b":"loader = D.DataLoader(ds, batch_size=batch_size, shuffle=True, num_workers=2)\ntloader = D.DataLoader(ds_test, batch_size=batch_size, shuffle=False, num_workers=2)","87856db6":"criterion = nn.BCEWithLogitsLoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.001)","3973ec31":"def accuracy(output, target, topk=(1,)):\n    \"\"\"Computes the accuracy over the k top predictions for the specified values of k\"\"\"\n    with torch.no_grad():\n        maxk = max(topk)\n        batch_size = target.size(0)\n\n        _, pred = output.topk(maxk, 1, True, True)\n        pred = pred.t()\n        correct = pred.eq(target.view(1, -1).expand_as(pred))\n\n        res = []\n        for k in topk:\n            correct_k = correct[:k].view(-1).float().sum(0, keepdim=True)\n            res.append(correct_k.mul_(100.0 \/ batch_size).item())\n        return np.array(res)","afd8b065":"epochs = 10\ntlen = len(loader)\nfor epoch in range(epochs):\n    tloss = 0\n    acc = np.zeros(1)\n    for x, y in loader: \n        x = x.to(device)\n        optimizer.zero_grad()\n        output = model(x)\n        target = torch.zeros_like(output, device=device)\n        target[np.arange(x.size(0)), y] = 1\n        loss = criterion(output, target)\n        loss.backward()\n        optimizer.step()\n        tloss += loss.item() \n        acc += accuracy(output.cpu(), y)\n        del loss, output, y, x, target\n    print('Epoch {} -> Train Loss: {:.4f}, ACC: {:.2f}%'.format(epoch+1, tloss\/tlen, acc[0]\/tlen))","d8552dd9":"@torch.no_grad()\ndef prediction(model, loader):\n    preds = np.empty(0)\n    for x, _ in loader: \n        x = x.to(device)\n        output = model(x)\n        idx = output.max(dim=-1)[1].cpu().numpy()\n        preds = np.append(preds, idx, axis=0)\n    return preds\n\npreds = prediction(model, tloader)","aec369d3":"submission = pd.read_csv(path_data + '\/test.csv')\nsubmission['sirna'] = preds.astype(int)\nsubmission.to_csv('submission.csv', index=False, columns=['id_code','sirna'])","5b504297":"## Prediction for test","615bdd2d":"## Train model","9738c4ed":"## Define dataset and model","ca73d08d":"## Load libs"}}