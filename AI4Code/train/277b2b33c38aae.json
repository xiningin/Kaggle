{"cell_type":{"94557780":"code","e3cd6099":"code","ca4698dc":"code","1567437b":"code","50a5742d":"code","c6f17fe3":"code","357cbcf7":"code","8e0a503d":"code","91e1508a":"code","434fa82b":"code","97073f72":"code","011c3755":"code","dfe23367":"code","7367e796":"code","64e48dd2":"code","3200e499":"code","e068a537":"markdown","edd3507a":"markdown","5c9b50b4":"markdown","998a8f8f":"markdown","d7160be0":"markdown","bd251134":"markdown","20563959":"markdown","129aa47a":"markdown","60ff96e7":"markdown","8bd61fc2":"markdown","7bfdfa96":"markdown","86693314":"markdown","c07793c5":"markdown","a66ef162":"markdown","9995ae80":"markdown","18aa0436":"markdown","f4acd42e":"markdown"},"source":{"94557780":"# Basic Libraries for Data Manipulations\nimport numpy as np\nimport pandas as pd\n\n# Libraries for Visualization\nimport matplotlib.pyplot as plt\n\n# Machine Learning Libraries. \nimport tensorflow as tf\nfrom tensorflow.keras import Sequential\nfrom tensorflow.keras.layers import Conv2D,MaxPool2D,Dropout,Flatten,Dense,BatchNormalization\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.callbacks import EarlyStopping","e3cd6099":"IMAGE_DIR = '..\/input\/cell-images-for-detecting-malaria\/cell_images\/cell_images\/'\nIMG_SIZE = (128, 128)\nBATCH_SIZE = 64","ca4698dc":"\n\ndatagen = ImageDataGenerator(rescale=1\/255.0, \n                             validation_split=0.2, \n                             rotation_range=5.0,    \n                             width_shift_range=5.0,\n                             height_shift_range=5.0,\n                             horizontal_flip=True,\n                             vertical_flip=True)\n\ntrain_datagen = datagen.flow_from_directory(directory=IMAGE_DIR,\n                                            target_size= IMG_SIZE,\n                                            class_mode = 'binary',\n                                            batch_size = 16,\n                                            subset='training')\n\nvalid_datagen = datagen.flow_from_directory(directory = IMAGE_DIR,\n                                           target_size = IMG_SIZE,\n                                           class_mode = 'binary',\n                                           batch_size = 16,\n                                           subset='validation')","1567437b":"X, Y = train_datagen.next()\nprint('Train Input  batch Shape: ', X.shape)\nprint('Train Output batch Shape: ', Y.shape)\n\nrows = int(np.sqrt(X.shape[0]))\ncols = int(np.sqrt(X.shape[0]))\n\nfig = plt.figure(figsize=(15,15))\nfor i in range(1, rows*cols+1):\n    fig.add_subplot(rows, cols, i)\n    plt.imshow(np.squeeze(X[i-1]))\n    plt.title(str(Y[i-1]), fontsize=16)\n    plt.axis(False)\n    fig.add_subplot","50a5742d":"!pip install -q efficientnet\n!pip install -q pyyaml h5py\n\nimport efficientnet.tfkeras as efn\nimport tensorflow.keras.layers as Layers","c6f17fe3":"try:\n    # TPU detection. No parameters necessary if TPU_NAME environment variable is\n    # set: this is always the case on Kaggle.\n    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n    print('Running on TPU ', tpu.master())\nexcept ValueError:\n    tpu = None\n\nif tpu:\n    tf.config.experimental_connect_to_cluster(tpu)\n    tf.tpu.experimental.initialize_tpu_system(tpu)\n    strategy = tf.distribute.experimental.TPUStrategy(tpu)\nelse:\n    # Default distribution strategy in Tensorflow. Works on CPU and single GPU.\n    strategy = tf.distribute.get_strategy()\n\nprint(\"REPLICAS: \", strategy.num_replicas_in_sync)","357cbcf7":"with strategy.scope():\n    model_efn_b0 = tf.keras.Sequential([\n        efn.EfficientNetB0(\n            input_shape=(*IMG_SIZE, 3),\n            weights='imagenet',\n            include_top=False\n        ),\n        Layers.GlobalAveragePooling2D(),\n        Layers.Dense(1, activation='sigmoid')\n    ])\n    \n    model_efn_b0.compile(\n        optimizer='adam',\n        loss = 'binary_crossentropy',\n        metrics=['accuracy']\n    )\n    model_efn_b0.summary()","8e0a503d":"def build_lrfn(lr_start=1e-5, lr_max=1e-4, \n               lr_min=0, lr_rampup_epochs=8, \n               lr_sustain_epochs=1, lr_exp_decay=.8):\n\n    def lrfn(epoch):\n        if epoch < lr_rampup_epochs:\n            lr = (lr_max - lr_start) \/ lr_rampup_epochs * epoch + lr_start\n        elif epoch < lr_rampup_epochs + lr_sustain_epochs:\n            lr = lr_max\n        else:\n            lr = (lr_max - lr_min) *\\\n                 lr_exp_decay**(epoch - lr_rampup_epochs\\\n                                - lr_sustain_epochs) + lr_min\n        return lr\n    return lrfn\n\nlrfn = build_lrfn()\nlr_schedule = tf.keras.callbacks.LearningRateScheduler(lrfn, verbose=True)","91e1508a":"model_checkpoint = tf.keras.callbacks.ModelCheckpoint(filepath='model_efnB0_best_val_acc.hdf5',\n                                                      save_weights_only=True,\n                                                      monitor='val_accuracy',\n                                                      mode='max',\n                                                      save_best_only=True)","434fa82b":"history = model_efn_b0.fit(train_datagen, \n                           epochs=20,\n                           steps_per_epoch=len(train_datagen),\n                           validation_data = valid_datagen,\n                           validation_steps=len(valid_datagen),\n                           callbacks=[lr_schedule, model_checkpoint],\n                           verbose = 0)\n","97073f72":"def visualize_training(history, lw = 3):\n    plt.figure(figsize=(10,10))\n    plt.subplot(2,1,1)\n    plt.plot(history.history['accuracy'], label = 'training', marker = '*', linewidth = lw)\n    plt.plot(history.history['val_accuracy'], label = 'validation', marker = 'o', linewidth = lw)\n    plt.title('Accuracy Comparison')\n    plt.xlabel('Epochs')\n    plt.ylabel('Accuracy')\n    plt.grid(True)\n    plt.legend(fontsize = 'x-large')\n    \n\n    plt.subplot(2,1,2)\n    plt.plot(history.history['loss'], label = 'training', marker = '*', linewidth = lw)\n    plt.plot(history.history['val_loss'], label = 'validation', marker = 'o', linewidth = lw)\n    plt.title('Loss Comparison')\n    plt.xlabel('Epochs')\n    plt.ylabel('Loss')\n    plt.legend(fontsize = 'x-large')\n    plt.grid(True)\n    plt.show()\n\n    plt.figure(figsize=(10,5))\n    plt.plot(history.history['lr'], label = 'lr', marker = '*',linewidth = lw)\n    plt.title('Learning Rate')\n    plt.xlabel('Epochs')\n    plt.ylabel('Learning Rate')\n    plt.grid(True)\n    plt.show()","011c3755":"visualize_training(history)","dfe23367":"labels_test = []\nfor i in range(0, len(valid_datagen)):\n    labels_test.extend(np.array(valid_datagen[i][1]))\n    \nlabels_test = np.array(labels_test, dtype = 'int64')\n\n\nlabels_predict = model_efn_b0.predict(valid_datagen)\n\n","7367e796":"from sklearn.metrics import classification_report, confusion_matrix, accuracy_score, roc_auc_score\n\nlabels_predict =  ((labels_predict > 0.5)*1).squeeze()\n\nprint(classification_report(labels_test, labels_predict,\n                            labels = [1,0], \n                            target_names = ['Parasitized', 'Uninfected']) )","64e48dd2":"import seaborn as sns\nprint(confusion_matrix(labels_test, labels_predict))\nsns.heatmap(confusion_matrix(labels_test, labels_predict), annot=True)","3200e499":"print('Area Under ROC-Curve: ', roc_auc_score(labels_test, labels_predict))\n\nfrom sklearn.metrics import roc_curve\nfpr, tpr, thresholds = roc_curve(labels_test, labels_predict , drop_intermediate = False)\nplt.plot(fpr,tpr)\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.0])\nplt.title('ROC curve for Malaria Cell Classification')\nplt.xlabel('False positive rate (1-Specificity)')\nplt.ylabel('True positive rate (Sensitivity)')\nplt.grid(True)","e068a537":"### 2. Loading and SPlitting Train Validation\n","edd3507a":"Malaria remains a major burden on global health, with roughly 200 million cases worldwide and more than 400,000 deaths per year. Besides biomedical research and political efforts, modern information technology is playing a key role in many attempts at fighting the disease. One of the barriers toward a successful mortality reduction has been inadequate malaria diagnosis in particular. To improve diagnosis, image analysis software and machine learning methods have been used to quantify parasitemia in microscopic blood slides. This notebook gives a first hand application of machine learning techniques to diagnose and predict malaria infected blood cells. \n\nIf you like this work, please do <font color='red'> UPVOTE <\/font>","5c9b50b4":"# 4. Model Cration and training\n## 4.1 Model From Scratch:\nWith the following model in the markdown box, I was able to achieve upto 95% accuracy on validation set. Feel free to play with this by converting this cell into a code cell. ","998a8f8f":"### 4.2.2 Creating Model, Compiling","d7160be0":"```\n# Model Creation: \nmodel = Sequential()\nmodel.add(Conv2D(16,(3,3),activation='relu',input_shape=(128,128,3)))\nmodel.add(MaxPool2D(2,2))\nmodel.add(Dropout(0.2))\n\nmodel.add(Conv2D(32,(3,3),activation='relu'))\nmodel.add(MaxPool2D(2,2))\nmodel.add(Dropout(0.3))\n\nmodel.add(Conv2D(64,(3,3),activation='relu'))\nmodel.add(MaxPool2D(2,2))\nmodel.add(Dropout(0.3))\n\nmodel.add(Flatten())\nmodel.add(Dense(64,activation='relu'))\nmodel.add(Dropout(0.5))\n\nmodel.add(Dense(1,activation='sigmoid'))\n\n\n# Model Summary\nmodel.summary()\n\n# Model Compilation\nmodel.compile(optimizer='adam',loss='binary_crossentropy',metrics=['accuracy'])\n\n# Model Training\nhistory = model.fit_generator(generator = train_datagen,\n                             steps_per_epoch = len(train_datagen),\n                              epochs =20,\n                              validation_data = valid_datagen,\n                              validation_steps=len(valid_datagen))\n                              \n```","bd251134":"#### Confusion matrix","20563959":"## 4.2 EfficentNet-B0 Model: ","129aa47a":"### 4.2.1 Installation and Setup","60ff96e7":"### 4.2.4 Model Checkpoints Callback","8bd61fc2":"### 4.2.7 Inference\nNow let's find out the prediction of the model on the vaidation dataset. We are also making an array of the labels of the validation set from the DataGenerator for our further evaluation of model. ","7bfdfa96":"### 1. Importng Necesary Libraries","86693314":"#### Area Under ROC Curve","c07793c5":"### 4.2.5 Training\nNow let us train the model. ","a66ef162":"### 4.2.6 Training Summary Visualization","9995ae80":"### 4.2.3 Learning Rate Scheduler","18aa0436":"### 3. Data Visualization\nLet's have a look at the data itself. We will have a good idea about what we are dealing with. ","f4acd42e":"### 4.2.8 Result Analysis\n#### Classification Report"}}