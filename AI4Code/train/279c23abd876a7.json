{"cell_type":{"e917a1b0":"code","07a3c17e":"code","5584776e":"code","5adfbac6":"code","626a436a":"code","8f47be98":"code","9eb7f1ef":"code","d093100e":"code","34d41031":"code","e64be569":"code","9434daa9":"code","9b5a033c":"code","8c14bf0c":"markdown","3ab30d9a":"markdown","772d1442":"markdown"},"source":{"e917a1b0":"import numpy as np\nimport pandas as pd\nimport time\n","07a3c17e":"import itertools\n\nimport numpy as np\nimport pandas as pd\nimport time\n\nimport torch\nif torch.cuda.is_available():\n    device = torch.device(\"cuda\")\n    dtype = torch.float\nelse:\n    device = torch.device(\"cpu\")\n    dtype = torch.float#int16  \n    \ndef get_matrix_array(p,matrix_size): # generation_mode = 'Full',\n    '''\n    Generates array of ALL possible matrices over F_p and of given size, p and matrix_size are params.\n    '''\n    n = p**(matrix_size*matrix_size)\n    l = range(p)\n    c = 0\n    matrix_array = torch.zeros( n,matrix_size, matrix_size,  device=device, dtype = dtype )\n    for tpl in itertools.product(l, repeat= matrix_size*matrix_size):\n        matrix_array[c,:,:] = torch.tensor(np.array(tpl).reshape(matrix_size,matrix_size) )\n        c += 1\n            \n    return matrix_array","5584776e":"\nimport time\nt0start =time.time()\n\ntype_of_Jordan_cell = '2+1+1'#  '2+1+1+1' # '2+2+1' # '3+2' # '4+1'# '3+1'\n# Generate Jordan cell matrix\nif type_of_Jordan_cell == '2':\n    J = torch.tensor([[0,1],[0,0]],dtype = dtype, device = device)\n    matrix_size = 2\nelif type_of_Jordan_cell == '2+1':\n    J = torch.tensor([[0,1,0],[0,0,0],[0,0,0]],dtype = dtype, device = device)\n    matrix_size = 3\nelif type_of_Jordan_cell == '3+1':\n    J = torch.tensor([[0,1,0,0],[0,0,1,0],[0,0,0,0],[0,0,0,0]],dtype = dtype, device = device)\n    matrix_size = 4\nelif type_of_Jordan_cell == '2+1+1':\n    J = torch.tensor([[0,1,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]],dtype = dtype, device = device)\n    matrix_size = 4\nelif type_of_Jordan_cell == '2+2':\n    J = torch.tensor([[0,1,0,0],[0,0,0,0],[0,0,0,1],[0,0,0,0]],dtype = dtype, device = device)\n########## Size 5 \nelif type_of_Jordan_cell == '4+1':\n    J = torch.tensor([[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,0],[0,0,0,0,0]],dtype = dtype, device = device)\n    matrix_size = 5\nelif type_of_Jordan_cell == '2+1+1+1':\n    J = torch.tensor([[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],dtype = dtype, device = device)\n    matrix_size = 5\nelif type_of_Jordan_cell == '2+2+1':\n    J = torch.tensor([[0,1,0,0,0],[0,0,0,0,0],[0,0,0,1,0],[0,0,0,0,0],[0,0,0,0,0]],dtype = dtype, device = device)\n    matrix_size = 5\nelif type_of_Jordan_cell == '3+2':\n    J = torch.tensor([[0,1,0,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,1],[0,0,0,0,0]],dtype = dtype, device = device)\n    matrix_size = 5\n\nprint()\nprint('type_of_Jordan_cell', type_of_Jordan_cell )\nprint('Matrix J = ')\nprint( J)\n    \nfor p in [2,3]:\n    print('p=',p)\n    t0 = time.time()\n\n\n    # Generate all matrices\n    matrix_array = get_matrix_array(p=p,matrix_size=matrix_size)\n    s1 = np.round(time.time()-t0,1)\n    t0 = time.time()\n    mlen = matrix_array.shape[0]\n\n    mask = torch.sum(torch.remainder(torch.matmul(J,matrix_array) - torch.matmul(matrix_array,J) , p),dim = (1,2) )  == 0\n    print('For p =',p,'matrix_size',matrix_size, 'number of commuting with J matrices from Mat(n,F_p) equals to', mask.sum().item() )\n\n    # Select with non-zero determinant \n    v = torch.remainder(torch.round(torch.linalg.det(matrix_array)), p )\n    matrix_array = matrix_array[v!=0,:,:]\n\n\n    # Find those which are commuting with J : \n    mask = torch.sum(torch.remainder(torch.matmul(J,matrix_array) - torch.matmul(matrix_array,J) , p),dim = (1,2) )  == 0\n    print('For p =',p,'matrix_size',matrix_size, 'number of commuting with J matrices from GL(n,F_p) equals to', mask.sum().item() )\n    print(s1, 'Seconds passed on matrix array generation, size: ',mlen , np.round(time.time()-t0,1), 'Seconds passed on calculations' )\n    \nprint(np.round(time.time()-t0start,1), 'Seconds passed total.' )\n# matrix_array[mask,:,:]","5adfbac6":"if type_of_Jordan_cell == '2+1+1+1' :\n    # Search for basic  1-non-trivial unit matrices - part of the basis \n    \n    c = 0\n    for k in range(mask.shape[0]):\n        if not mask[k]: continue\n        sum1 = 0\n        for i in range(2,5):\n            for j in range(2,5):\n                if i == j: continue \n                sum1 += matrix_array[k,i,j]#  + matrix_array[k,2,3]\n        sum1 += matrix_array[k,0,1]\n        #for i in range(1,3):\n        #    for j in range(i+1,3):\n        #for i in range(1, matrix_array.shape[1]):\n        #    sum += matrix_array[k,0,i]\n        #sum += (matrix_array[k,0,3] )\n        sum2 = 0\n        for i in range(0,5):\n            for j in range(0,5):\n                if i == j: continue \n                sum2 += matrix_array[k,i,j]#  + matrix_array[k,2,3]\n        if (sum1 == 0) and (sum2==1):\n            c+=1\n            print(c)\n            print(matrix_array[k,:,:] )\n            print()    ","626a436a":"if type_of_Jordan_cell == '2+1+1+1' :\n    # Search for basic  1-non-trivial unit matrices - part of the basis \n    \n    c = 0\n    for k in range(mask.shape[0]):\n        if not mask[k]: continue\n        sum1 = 0\n        for i in range(2,5):\n            for j in range(2,5):\n                if i == j: continue \n                sum1 += matrix_array[k,i,j]#  + matrix_array[k,2,3]\n        sum1 += matrix_array[k,0,1]\n        #for i in range(1,3):\n        #    for j in range(i+1,3):\n        #for i in range(1, matrix_array.shape[1]):\n        #    sum += matrix_array[k,0,i]\n        #sum += (matrix_array[k,0,3] )\n        sum2 = 0\n        for i in range(0,5):\n            for j in range(0,5):\n                if i == j: continue \n                sum2 += matrix_array[k,i,j]#  + matrix_array[k,2,3]\n        if (sum1 == 0) and (sum2==2):\n            c+=1\n            print(c)\n            print(matrix_array[k,:,:] )\n            print()    ","8f47be98":"if type_of_Jordan_cell == '2+1+1+1' :\n    # Search for basic  1-non-trivial unit matrices - part of the basis \n    \n    c = 0\n    for k in range(mask.shape[0]):\n        if not mask[k]: continue\n        sum1 = 0\n        for i in range(2,5):\n            for j in range(2,5):\n                if i == j: continue \n                sum1 += matrix_array[k,i,j]#  + matrix_array[k,2,3]\n        sum1 += matrix_array[k,0,1]\n        #for i in range(1,3):\n        #    for j in range(i+1,3):\n        #for i in range(1, matrix_array.shape[1]):\n        #    sum += matrix_array[k,0,i]\n        #sum += (matrix_array[k,0,3] )\n        sum2 = 0\n        for i in range(0,5):\n            for j in range(0,5):\n                if i == j: continue \n                sum2 += matrix_array[k,i,j]#  + matrix_array[k,2,3]\n        if (sum1 == 0) and (sum2==2):\n            c+=1\n            print(c)\n            print(matrix_array[k,:,:] )\n            print()    ","9eb7f1ef":"if type_of_Jordan_cell == '2+2+1' :\n    # fix known part of centralizer to be zero \n    c = 0\n    for k in range(mask.shape[0]):\n        if not mask[k]: continue\n        sum = 0\n        for i in range(0,4):\n            for j in range(0,4):\n                if i == j: continue \n                sum += matrix_array[k,i,j]#  + matrix_array[k,2,3]\n        #sum += matrix_array[k,0,1]\n        #for i in range(1,3):\n        #    for j in range(i+1,3):\n        #for i in range(1, matrix_array.shape[1]):\n        #    sum += matrix_array[k,0,i]\n        #sum += (matrix_array[k,0,3] )\n        if sum == 0:\n            c+=1\n            print(c)\n            print(matrix_array[k,:,:] )\n            print()    ","d093100e":"if type_of_Jordan_cell == '2+2+1' :\n    # fix known part of centralizer to be zero \n    c = 0\n    for k in range(mask.shape[0]):\n        if not mask[k]: continue\n        sum = 0\n        for i in range(0,4):\n            for j in range(0,4):\n                if i == j: continue \n                sum += matrix_array[k,i,j]#  + matrix_array[k,2,3]\n        sum += matrix_array[k,0,4]#\n        #sum += matrix_array[k,0,1]\n        #for i in range(1,3):\n        #    for j in range(i+1,3):\n        #for i in range(1, matrix_array.shape[1]):\n        #    sum += matrix_array[k,0,i]\n        #sum += (matrix_array[k,0,3] )\n        if sum == 0:\n            c+=1\n            print(c)\n            print(matrix_array[k,:,:] )\n            print()   ","34d41031":"if type_of_Jordan_cell == '2+1+1+1' :\n    # fix obvious part of centralizer to be zero \n    c = 0\n    for k in range(mask.shape[0]):\n        if not mask[k]: continue\n        sum = 0\n        for i in range(2,5):\n            for j in range(2,5):\n                if i == j: continue \n                sum += matrix_array[k,i,j]#  + matrix_array[k,2,3]\n        sum += matrix_array[k,0,1]\n        #for i in range(1,3):\n        #    for j in range(i+1,3):\n        #for i in range(1, matrix_array.shape[1]):\n        #    sum += matrix_array[k,0,i]\n        #sum += (matrix_array[k,0,3] )\n        if sum == 0:\n            c+=1\n            print(c)\n            print(matrix_array[k,:,:] )\n            print()    ","e64be569":"if type_of_Jordan_cell == '2+1+1+1' :\n    # fix obvious part of centralizer to be zero and E_{0,n}\n    c = 0\n    for k in range(mask.shape[0]):\n        if not mask[k]: continue\n        sum = 0\n        for i in range(2,5):\n            for j in range(2,5):\n                if i == j: continue \n                sum += matrix_array[k,i,j]#  + matrix_array[k,2,3]\n        sum += matrix_array[k,0,1]\n        sum += matrix_array[k,0,4]\n        if sum == 0:\n            c+=1\n            print(c)\n            print(matrix_array[k,:,:] )\n            print()    ","9434daa9":"if 0:\n    if matrix_size == 5:\n        # For type_of_Jordan_cell = '2+2+1' fix obvious part of centralizer to be zero \n        c = 0\n        for k in range(mask.shape[0]):\n            if not mask[k]: continue\n            sum = 0\n            sum += matrix_array[k,0,1] + matrix_array[k,2,3]\n            #sum += matrix_array[k,3,4]\n            #for i in range(1,3):\n            #    for j in range(i+1,3):\n            #for i in range(1, matrix_array.shape[1]):\n            #    sum += matrix_array[k,0,i]\n            #sum += (matrix_array[k,0,3] )\n            if sum == 0:\n                c+=1\n                print(c)\n                print(matrix_array[k,:,:] )\n                print()","9b5a033c":"if 0:\n    if matrix_size == 5:\n        # For type_of_Jordan_cell = '2+2+1' fix obvious part of centralizer to be zero  and also E_{0,n}\n\n        c = 0\n        for k in range(mask.shape[0]):\n            if not mask[k]: continue\n            sum = 0\n            #sum += matrix_array[k,0,1] + matrix_array[k,0,2] +  matrix_array[k,0,4]\n            sum += matrix_array[k,0,1] + matrix_array[k,2,3]\n            sum += matrix_array[k,3,4]\n            #for i in range(1,3):\n            #    for j in range(i+1,3):\n            #for i in range(1, matrix_array.shape[1]):\n            #    sum += matrix_array[k,0,i]\n            #sum += (matrix_array[k,0,3] )\n            if sum == 0:\n                c+=1\n                print(c)\n                print(matrix_array[k,:,:] )\n                print()","8c14bf0c":"# What is about ?\n\nUnderstanding centralizers of nilpotent elements in GL(n,F_p), Mat(n,F_p)\n\nElements like: \n\n##### [[0., 1., 0.],\n#####  [0., 0., 0.],\n#####  [0., 0., 0.]]\n\nor\n##### [[0., 1., 0., 0],\n#####  [0., 0., 0., 0],\n#####  [0., 0., 0., 1]]\n#####  [0., 0., 0., 0]]\n\nor similar\n\n","3ab30d9a":"# Versions:\n\n#### 22 ## Subtype J = '2+1+1'\n    # p=2: 192 = 2^6*3 , 1024=2^10 - for Mat(3), so guess: (q-1)^3q^6(q+1) \n    # p=3: 59049 = 3^10 , 23328 = 2^5 \u00d7 3^6 = 2^3 \u00d7 3^6 \u00d7 4 - so guess is correct\n    # For p = 3 matrix_size 4 number of commuting with J matrices from Mat(n,F_p) equals to 59049\n    # For p = 3 matrix_size 4 number of commuting with J matrices from GL(n,F_p) equals to 23328\n    # 1170.0 Seconds passed on matrix array generation, size:  43046721 38.4 Seconds passed on calculations\n    # 1210.2 Seconds passed total.\n \n    \n#### 21 ## Subtype J = '2+1'\n    # Matrix_size = 3: J = '2+1'  : (q-1)^2* q^3, checked for p=2,3,5\n\n\n#### 20 n=5,p=2 J of type '2+2+1'  \n    # Added output with fixing to zero of the known part of centralizer\n    # Added ouput with 1-non-trivial unit \n    \n#### 19 n=5,p=2 J of type '2+2+1'  \n    # Added output with fixing to zero of the known part of centralizer\n\n#### 18 n=5,p=2 J of type '2+1+1+1' \n    # Added output with fixing to zero of the known part of centralizer # 18 \n    # 21504 = 2^10 x 3 x 7 in GL\n    # 131072 = 2^17 in Mat\n    \n#### 17 n=5,p=2 J of type '2+1+1+1' \n    # Ran in 14 minutes and 6 seconds\n    # 21504 = 2^10 x 3 x 7; Lie alg level: 131_072 = 2^17\n    # GL(3,F_q) comes from 3 copies of 1 and gives (q^3-1)(q^3-q)(q^3-q^2)= q^3[3_q]! ; on Lie alg level it is q^9\n    # (q-1)q - comes from [[0,1][0,0]]; on Lie alg level it is q^2 \n    # so we a missing a lot: q^6 \n    \n#### 16 n=5,p=2 J of type '2+2+1' \n    # Ran in 14 minutes and 36 seconds  1536 = 3*2^9 matrices - because it should contain GL(2,F_2)= (3)(2) , also 2 and 2 comes from each copy of [[0,1],[0,0]]  \n    # Need to undestand further the general structure \n\n#### 15 n=5,p=2 J of type '3+2' \n    # Ran in 18 minutes and 33 seconds\n    # In total we have 512 in Mat 128 in GL, Fixing obvious part and $E_{0,n}$ we get 8 \n    # But there are MORE than 3 positions which are non-zero - that means structure is not that much simple, but may be there are some equalities between coordinates.\n    \n    \n#### 14 n=5,p=2 J of type '4+1' \n    # Confirms case n=4 '3+1' - we only seems to have $E_{0,n}$ and $E_{n,n-1}$ \n    # Ran in 18 minutes and 25 seconds\n    \n#### 13 - skip it\n\n#### 12 n=4 J of type '3+1' - understanding structure:  \n    # seems to formula: p^4(p-1)^2, linear part p^6 \n    # There is clearly the-same-block (polynoms in J) commuting: (p-1)p^2 , also subgroup:  (p-1)* element E_{44}, \n    # also seems to be elements $E_{0,3}$ and $E_{3,2}$ give free coorditanes. \n\n#### 11 p=2,3 n=4 J of type '3+1' seems to formula: p^4(p-1)^2, linear part p^6 \n\n\n#### 10\nCalculations for n=5, p=2, another J matrix - with 2 cells: one 3x3, another is  2x2 \n\n#### 8,9 (repeated by mistake)\n\nCalculations for n=5, p=2, another J matrix - with 2 cells 2x2 \n\nJ = torch.tensor([[0,1,0,0,0],[0,0,0,0,0],[0,0,0,1,0],[0,0,0,0,0],[0,0,0,0,0]],dtype = dtype)\n\nRan in 17 minutes and 8 seconds\n\n2^13 = 8192  - matrices from Mat(n,F_p) commuting with J\n\n1536 = 2^3 x 3 - matrices from GL(n,F_p) commuting with J\n\n\n#### 6,7 - crashed due to misprints (should NOT run p=3 for n=5)\n\nCalculations for n=5, p=2, another J matrix - with 2 cells, one is 3x3, another is 2x2 \n\n\n\n#### 5 \nCalculations for n=4, p=2,3, another J matrix - with 2 cells 2x2,  we need to process 43_046_721 (p=3) matrices, expected time seems to be about 17 minutes (same as v3)\n\nRan in 19 minutes and 48 seconds\n\nResults: p^8 - matrices from Mat(n,F_p) commuting with J\n\n\n##### Fitted; p^5 (p - 1)^2 (p + 1)  = p^8-p^7-p^6+p^5\n\n\n\n#### 4\n\nCalculations for n=5, p=2 we need to process 33_554_432 matrices, expected time seems to be about 1 hour\n\nRan in 17 minutes\n\nResults: 2^17 =  131072 matrices from Mat(n,F_p) commuting with J\n\n21504 = 2^10 x 3 x 7 matrices from Mat(n,F_p) commuting with J\n\n\n\n#### 3 \n\nCalculations for n=4, p=2,3 we need to process 43_046_721 (p=3) matrices, expected time seems to be about 1 hour\n\nRan in 16 minutes and 59 seconds\n\nResults: p^10: 1024, 59049 matrices from Mat(3,F_q) commuting with J \n\nFor GL(3,F_p), for p=2:  192 = 2^6 \u00d7 3,  p=3: 23,328 = 2^5 \u00d7 3^6.\n\n#####  p^6 (p - 1)^3 (p + 1) = +p^10-2p^9+2p^7-p^6 fits - the only with coefs <=4 of degree 10\n\n\n\n#### 2 \nCalculations n=3, p=2,3,5 so we walk over all matrices which i.e. number of matrices:  512,   19_683, 1_953_125 it took about 49 seconds - most time is on generation of list of p=5, calculations are immediate \n\nwe get p^5 matrices from Mat(n,F_p) commuting with J and 8, 108, 2000 matrices from GL(n,F_p)\nwhich corresponds to p^3(p-1)^2 \n\n#### 1 \nSimple calculation for p=2, n=3 show 8 matrices commuting J ","772d1442":"# Results\n\n## Subtype J = '2+1+1+...+1', ComMat: q^{(n-1)^2+1} - from transpose Young diagram rule \n#### J = '2+1'  : (q-1)^2q^3, ComMat:  q^5 checked for p=2,3,5 (V21)\n\n#### J = '2+1+1' : (q-1)^3q^6(q+1) , ComMat: q^10 checked for p=2,3\n    # Version 22: \n    # p=2: 192 = 2^6*3 , 1024=2^10 - for Mat(3), so guess: (q-1)^3q^6(q+1) \n    # p=3: 59049 = 3^10 , 23328 = 2^5 \u00d7 3^6 = 2^3 \u00d7 3^6 \u00d7 4 - so guess is correct\n    # For p = 3 matrix_size 4 number of commuting with J matrices from Mat(n,F_p) equals to 59049\n    # For p = 3 matrix_size 4 number of commuting with J matrices from GL(n,F_p) equals to 23328\n    # 1170.0 Seconds passed on matrix array generation, size:  43046721 38.4 Seconds passed on calculations\n    # 1210.2 Seconds passed total.\n\n#### J = '2+1+1+1' (q-1)^4 q^10 (q+1)(q^2+q+1), ComMat q^17 checked for p=2 \n    # Version 18  n=5,p=2\n    # Added output with fixing to zero of the known part of centralizer # Ran in 14 minutes and 57 seconds\n    # 21504 = 2^10 x 3 x 7 in GL\n    # 131072 = 2^17 in Mat\n\n\n## Some first results:\n\n##### p(p-1) for n=2\nThat is clear \n\n##### p^3(p-1)^2 for n=3\nFor n=3 , J= [[0,1,0],[0,0,0],[0,0,0]] the size of centralizer in GL(n,F_q) is p^3(p-1)^2 , checked for p=2,3,5 in 49 seconds\n\n##### p^6 (p - 1)^3 (p + 1) = +p^10-2p^9+2p^7-p^6, for n=4 , J =  [[0,1,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]\nFor n=4 J with one non-trivial 2x2 cell and other elements are zero ,  the only with coefs <=4 of degree 10\n, results from version 3\n\n#####  p^5 (p - 1)^2 (p + 1)  = p^8-p^7-p^6+p^5, for n=4 , J =  [[0,1,0,0],[0,0,0,0],[0,0,0,1],[0,0,0,0]]\nFor n=4 J with two 2x2 cells , results from version 5\n\n"}}