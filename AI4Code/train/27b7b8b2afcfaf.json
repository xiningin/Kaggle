{"cell_type":{"606a6f35":"code","b7dcdc6b":"code","96320e70":"code","90bfb9d9":"code","062be0b2":"code","535a7dd3":"code","84af7d02":"code","39be0699":"code","14730db8":"code","e5ca4bdb":"code","db5d0049":"code","bca07678":"code","4ef6b9a9":"code","d2e05341":"code","f50563b9":"code","94368797":"code","49cce764":"code","d4f865f8":"code","29d8e2b9":"code","ce0bb250":"code","9794e132":"code","bd4e776d":"code","8524897d":"code","b1e98a05":"code","64f9ab40":"code","f50bc8f2":"code","6960a7c4":"code","99a927e8":"code","2fe24b65":"markdown"},"source":{"606a6f35":"!pip install '..\/input\/timm-whl\/timm-0.4.12-py3-none-any.whl'","b7dcdc6b":"import os","96320e70":"if not os.path.exists('\/root\/.cache\/torch\/hub\/checkpoints\/'):\n    os.makedirs('\/root\/.cache\/torch\/hub\/checkpoints\/')","90bfb9d9":"!cp '..\/input\/timm-whl\/efficientnet_b0_ra-3dd342df.pth' '\/root\/.cache\/torch\/hub\/checkpoints\/efficientnet_b0_ra-3dd342df.pth'","062be0b2":"import numpy as np\nimport pandas as pd\n\nimport gc\n\nimport cv2\n\n# plotting\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn')\n\nfrom tqdm.notebook import tqdm_notebook\n\nfrom plotly.offline import init_notebook_mode, iplot\nimport plotly.express as px\nimport plotly.graph_objs as go\nfrom plotly.subplots import make_subplots\n\nfrom sklearn.model_selection import StratifiedKFold\n\ninit_notebook_mode(connected=True)\n\n# torch\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.utils.data import Dataset, DataLoader\nfrom torchvision import models, transforms\nimport torch.optim as optim\n\nimport timm","535a7dd3":"train_df = pd.read_csv('..\/input\/petfinder-pawpularity-score\/train.csv')","84af7d02":"train_df.shape","39be0699":"train_df.head()","14730db8":"train_df.describe()","e5ca4bdb":"fig = px.histogram(train_df, x='Pawpularity')\nfig.update_layout(autosize=False, width=700)\nfig.show()","db5d0049":"metadata = [\"Subject Focus\", \"Eyes\", \"Face\", \"Near\", \"Action\", \"Accessory\", \\\n            \"Group\", \"Collage\", \"Human\", \"Occlusion\", \"Info\", \"Blur\"]\n\nfig = make_subplots(rows=2, cols=6)\n\nfor i, name in enumerate(metadata):\n    row, col = i \/\/ 6, i % 6\n    trace1 = go.Box(x=train_df['Near'], y=train_df['Pawpularity'], name=name)\n    fig.append_trace(trace1, row = row + 1, col = col + 1)\n    \nfig.show()","bca07678":"# image related utility functions\n\ndef image_read(path):\n    img = cv2.imread(path)\n    if img is None:\n        raise Exception(\"Unable to read an image\")\n    return img\n\ndef read_image_rgb(path):\n    img = image_read(path)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    return img\n\ndef image_h_w(path):\n    img = image_read(path)\n    shape = img.shape\n    return shape[0], shape[1]","4ef6b9a9":"train_df['path'] = train_df.apply(lambda x : '..\/input\/petfinder-pawpularity-score\/train\/' + x['Id'] + \".jpg\", axis=1)\ntrain_df['image_h_w'] = train_df.apply(lambda x : image_h_w(x.path), axis=1)\ntrain_df['height'] = train_df.apply(lambda x : x['image_h_w'][0], axis=1)\ntrain_df['width'] = train_df.apply(lambda x : x['image_h_w'][1], axis=1)","d2e05341":"fig = px.scatter(x=train_df['width'], y=train_df['height'])\nfig.update_layout(autosize=False, width=700)\nfig.show()","f50563b9":"# Plot first 50 images\nfig, ax = plt.subplots(5,10,figsize=(16, 10))\nfor i, (path, score) in enumerate(train_df[['path', 'Pawpularity']][:50].values.tolist()):\n    row, col = i \/\/ 10, i % 10\n    axis = ax[row][col]\n    axis.imshow(image_read(path))\n    axis.set_xticks([])\n    axis.set_yticks([])\n    axis.set_xlabel(score)\nplt.show()","94368797":"class PetDataset(Dataset):\n    \n    def __init__(self, paths, labels=None, transforms=None):\n        self.paths = paths\n        self.labels = labels\n        self.transforms = transforms\n    \n    def __len__(self):\n        return len(self.paths)\n    \n    def __getitem__(self, idx : int):\n        \n        img = read_image_rgb(self.paths[idx])\n        \n        if self.transforms:\n            img = self.transforms(img)\n    \n        # if we use for model inference  \n        if self.labels is None:\n            return img\n        \n        return img, self.labels[idx]\n    ","49cce764":"device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nprint(device)","d4f865f8":"def sigmoid_fn(x):\n    return 1\/(1 + np.exp(-x))\n\n\ndef rmse_fn(predictions, targets):\n    return np.sqrt(\n        np.mean((predictions-targets)**2)\n    )\n\n\nclass PetNet(nn.Module):\n\n    def __init__(self):\n        super().__init__()\n        self.model = timm.create_model('efficientnet_b0', pretrained=True)\n        self.model.classifier = nn.Linear(in_features=1280, out_features=1)\n\n    def forward(self, x):\n        return self.model(x)\n\n\nclass PetTrainer:\n\n    def __init__(self, net) -> None:\n        self.net = net.to(device)\n        self.loss_fn = nn.BCEWithLogitsLoss()\n        self.optimizer_fn = optim.AdamW(params=self.net.parameters())\n\n    def train(self, data_loader):\n\n        # model set to train mode\n        self.net.train()\n\n        total_loss = 0\n\n        for img_batch, label_batch in tqdm_notebook(data_loader):\n\n            img_batch, label_batch = \\\n                img_batch.to(device), label_batch.to(device)\n\n            # reset params\n            self.optimizer_fn.zero_grad()\n\n            # forward\n            output = self.net(img_batch)\n\n            # compute loss and take backward\n            loss_op = self.loss_fn(output, label_batch)\n            loss_op.backward()\n\n            # take optimizer step\n            self.optimizer_fn.step()\n\n            total_loss += loss_op.item()\n\n        print(f\"BCELoss: {total_loss \/ len(data_loader)}\")\n\n    def test(self, data_loader):\n\n        self.net.eval()\n\n        predict_ls, true_ls = [], []\n\n        with torch.no_grad():\n            for img_batch, label_batch in tqdm_notebook(data_loader):\n                img_batch = img_batch.to(device)\n                prediction = self.net(img_batch).cpu()\n                predict_ls.extend(prediction.numpy())\n                true_ls.extend(label_batch.numpy())\n\n        predict_ls = np.array(predict_ls).ravel()\n        predict_ls = sigmoid_fn(predict_ls) * 100\n\n        true_ls = np.array(true_ls).ravel() * 100\n\n        rmse = rmse_fn(predict_ls, true_ls)\n\n        print(predict_ls[:50])\n        print(true_ls[:50])\n        print(\"RMSE:\", rmse)\n\n        return rmse\n\n    def infer(self, data_loader):\n        \n        self.net.eval()\n        \n        predict_ls = []\n        with torch.no_grad():\n            for img_batch in tqdm_notebook(data_loader):\n                img_batch = img_batch.to(device)\n                prediction = self.net(img_batch).cpu()\n                predict_ls.extend(prediction.numpy())\n                \n        predict_ls = np.array(predict_ls).ravel()\n        predict_ls = sigmoid_fn(predict_ls) * 100\n        \n        return predict_ls\n","29d8e2b9":"# Note:\n# ToTensor() -> change channel order from (H x W x C) to (C x H x W), and scale from [0,255] -> [0,1]\n# Normalize() -> mean, std, will convert to z-score, y = (x-mean)\/std\n\ndata_transforms = {\n    'train': transforms.Compose([\n        transforms.ToPILImage(),\n#         transforms.RandomResizedCrop(224),\n        transforms.Resize(256),\n        transforms.CenterCrop(224),\n        transforms.RandomHorizontalFlip(),\n        transforms.ToTensor(),\n        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])\n    ]),\n    'test': transforms.Compose([\n        transforms.ToPILImage(),\n        transforms.Resize(256),\n        transforms.CenterCrop(224),\n        transforms.ToTensor(),\n        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])\n    ]),\n}\n\ntrain_df['stratify_label'] = pd.qcut(train_df['Pawpularity'], q = 30, labels = range(30))\n\nX_data = np.array(train_df.path)\ny_data = np.array(train_df.Pawpularity)\ny_data = y_data \/ 100.0\ny_data = np.expand_dims(y_data, axis=1)\ny_skflabel = np.array(train_df.stratify_label)\n\n\ndebug = False\nepochs = 20\ntrain_batch_size = 128\ntest_batch_size = 32\nn_splits = 5\n\nif debug: epochs = 5","ce0bb250":"!mkdir models","9794e132":"skf = StratifiedKFold(n_splits=n_splits, random_state=2022, shuffle=True)\n\ncheckpoints = []\n\nfor fold_i, (train_index, test_index) in enumerate(skf.split(X_data, y_skflabel)):\n    \n    print(\"FOLD:\", fold_i + 1)\n\n    X_train, y_train = X_data[train_index], y_data[train_index]\n    X_test, y_test = X_data[test_index], y_data[test_index]\n    \n    train_dataloader = DataLoader(PetDataset(X_train, y_train, data_transforms['train']), batch_size=train_batch_size)\n    test_dataloader = DataLoader(PetDataset(X_test, y_test, data_transforms['test']), batch_size=test_batch_size)\n\n    print(len(train_dataloader.dataset), len(test_dataloader.dataset))\n    \n    # clean cache and model\n    try: del net\n    except Exception: pass\n    gc.collect()\n    torch.cuda.empty_cache()\n\n    net = PetNet()\n\n    trainer = PetTrainer(net)\n    for i in range(epochs):\n        trainer.train(train_dataloader)\n        \n    score = trainer.test(test_dataloader)\n    \n    out_path = f\"models\/model{fold_i}.pt\"\n    print(\"Model saving at:\", out_path)\n    torch.save(net.state_dict(), out_path)\n    \n    checkpoints.append((score, out_path))\n    \n    if debug:\n        break","bd4e776d":"checkpoints","8524897d":"best_scored = sorted(checkpoints)[0]\nbest_scored, best_scored[1]","b1e98a05":"net = PetNet()\npath = best_scored[1]\nprint(\"Model Loading:\", path)\nnet.load_state_dict(torch.load(path))\n\ntrainer = PetTrainer(net)","64f9ab40":"test_df = pd.read_csv('..\/input\/petfinder-pawpularity-score\/test.csv')\ntest_df['path'] = test_df.apply(lambda x : '..\/input\/petfinder-pawpularity-score\/test\/' + x['Id'] + \".jpg\", axis=1)\nX_pred_data = np.array(test_df.path)\npred_dataloader = DataLoader(PetDataset(X_pred_data, None, data_transforms['test']), batch_size=test_batch_size)","f50bc8f2":"pred = trainer.infer(pred_dataloader)","6960a7c4":"pred[:10]","99a927e8":"submit_df = pd.read_csv(\"..\/input\/petfinder-pawpularity-score\/sample_submission.csv\")\nsubmit_df.Pawpularity = pred\nsubmit_df.to_csv(\"submission.csv\", index=False)","2fe24b65":"## PetFinder.my - Pawpularity Contest\n---"}}