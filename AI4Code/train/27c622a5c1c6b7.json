{"cell_type":{"177eb320":"code","8cf055dc":"code","2d99c5d6":"code","803b0782":"code","230385ed":"code","d2649c4d":"code","1f2d27eb":"code","b3017a86":"code","08849b01":"code","1d81f05c":"code","eefd7cd7":"code","0e5cce5a":"code","848203ce":"code","da396f95":"code","1dcc9a17":"code","fb3576a3":"markdown","a3966ffb":"markdown","30386136":"markdown","0ed4ca23":"markdown","58d14836":"markdown","a766a1ee":"markdown","e822f3e4":"markdown","c9dc3720":"markdown","33a2fe85":"markdown","24e40f1e":"markdown"},"source":{"177eb320":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nfrom collections import Counter\nimport os\nimport seaborn as sns\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","8cf055dc":"train = pd.read_csv(\"..\/input\/train.csv\")\ntrain.head()\n# train_df.Target.value_counts()","2d99c5d6":"label_names={\n0:  \"Nucleoplasm\", \n1:  \"Nuclear membrane\",   \n2:  \"Nucleoli\",   \n3:  \"Nucleoli fibrillar center\" ,  \n4:  \"Nuclear speckles\"   ,\n5:  \"Nuclear bodies\"   ,\n6:  \"Endoplasmic reticulum\",   \n7:  \"Golgi apparatus\"   ,\n8:  \"Peroxisomes\"   ,\n9:  \"Endosomes\"   ,\n10:  \"Lysosomes\"   ,\n11:  \"Intermediate filaments\",   \n12:  \"Actin filaments\"   ,\n13:  \"Focal adhesion sites\",   \n14:  \"Microtubules\"   ,\n15:  \"Microtubule ends\",   \n16:  \"Cytokinetic bridge\",   \n17:  \"Mitotic spindle\"   ,\n18:  \"Microtubule organizing center\" ,  \n19:  \"Centrosome\"   ,\n20:  \"Lipid droplets\",   \n21:  \"Plasma membrane\",   \n22:  \"Cell junctions\"  , \n23:  \"Mitochondria\"   ,\n24:  \"Aggresome\"   ,\n25:  \"Cytosol\",\n26:  \"Cytoplasmic bodies\",   \n27:  \"Rods & rings\" \n}\n\nreverse_train_labels = dict((v,k) for k,v in label_names.items())\n\ndef fill_targets(row):\n    row.Target = np.array(row.Target.split(\" \")).astype(np.int)\n    for num in row.Target:\n        name = label_names[int(num)]\n        row.loc[name] = 1\n    return row","803b0782":"for key in label_names.keys():\n    train[label_names[key]] = 0\n\ntrain = train.apply(fill_targets, axis=1)\ntrain.head()","230385ed":"print(\"Total number of samples in the training data:\", train.shape[0])\nprint(\"Total number of unique IDs in the training data: \",len(train.Id.unique()))\ntrain[\"number_of_targets\"] = train.drop([\"Id\", \"Target\"],axis=1).sum(axis=1)","d2649c4d":"count_perc = np.round(100 * train[\"number_of_targets\"].value_counts() \/ train.shape[0], 2)\nplt.figure(figsize=(20,5))\nsns.barplot(x=count_perc.index.values, y=count_perc.values, palette=\"Oranges\")\nplt.xlabel(\"Number of targets per image\")\nplt.ylabel(\"% of data\")\n","1f2d27eb":"import gc\nimport matplotlib.pyplot as plt\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.tools as tls\n\ntarget_array = list(train.Target)\ntarget_array = [label_names[int(n)] for a in target_array for n in a]\nfig, ax = plt.subplots(figsize=(15, 5))\npd.Series(target_array).value_counts().plot('bar', fontsize=14 )","b3017a86":"# train[\"nb_labels\"] = train[\"Target\"].apply(lambda x: len(x.split(\" \")))\nsingle_labels_count = train[train['number_of_targets']==1]['number_of_targets'].count()\nmulti_labels_count = train[train['number_of_targets']>1]['number_of_targets'].count()\n\nimport gc\nimport matplotlib.pyplot as plt\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.tools as tls\n\ndata=[go.Bar(x=['Single label', 'Multi-label'], y=[single_labels_count, multi_labels_count],marker=dict(color='rgb(58,200,225)'))]\nlayout=dict(height=10, width=10, title='Single vs Multi label distribution')\nfig=dict(data=data, layout=layout)\npy.iplot(data, filename='Label type vs Count')\n","08849b01":"import seaborn as sns\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(15,15))\nsns.heatmap(train[train.number_of_targets>1].drop(\n    [\"Id\", \"Target\", \"number_of_targets\"],axis=1\n).corr(), cmap=\"YlGnBu\", vmin=-1, vmax=1)","1d81f05c":"# def heatMap(self, df):\ndf = train[train.number_of_targets>1].drop( [\"Id\", \"Target\", \"number_of_targets\"],axis=1).corr()\n\nmirror = False\n# Create Correlation df\ncorr = df.corr()\n# Plot figsize\nfig, ax = plt.subplots(figsize=(20, 15))\n# Generate Color Map\ncolormap = sns.diverging_palette(220, 10, as_cmap=True)\n\nif mirror == True:\n   #Generate Heat Map, allow annotations and place floats in map\n   sns.heatmap(train[train.number_of_targets>1].drop( [\"Id\", \"Target\", \"number_of_targets\"],axis=1).corr(), cmap=colormap, annot=True, fmt=\".2f\")\n   #Apply xticks\n   plt.xticks(range(len(corr.columns)), corr.columns);\n   #Apply yticks\n   plt.yticks(range(len(corr.columns)), corr.columns)\n   #show plot\n\nelse:\n   # Drop self-correlations\n   dropSelf = np.zeros_like(corr)\n   dropSelf[np.triu_indices_from(dropSelf)] = True# Generate Color Map\n   colormap = sns.diverging_palette(220, 10, as_cmap=True)\n   # Generate Heat Map, allow annotations and place floats in map\n   sns.heatmap(train[train.number_of_targets>1].drop( [\"Id\", \"Target\", \"number_of_targets\"],axis=1).corr(), cmap='YlGnBu', annot=True, fmt=\".2f\", mask=dropSelf)\n   # Apply xticks\n   plt.xticks(range(len(corr.columns)), corr.columns);\n   # Apply yticks\n   plt.yticks(range(len(corr.columns)), corr.columns)\n# show plot\nplt.show()\n    ","eefd7cd7":"# coreation values of protein\ncorr_matrix = train[train.number_of_targets>1].drop( [\"Id\", \"Target\", \"number_of_targets\"],axis=1).corr()\ncorr_matrix","0e5cce5a":"# High corelation between proteins\n\nhigh_corr_var_=np.where(corr_matrix>0.02)\nhigh_corr_var=[(corr_matrix.columns[x],corr_matrix.columns[y], corr_matrix[corr_matrix.columns[x]][corr_matrix.columns[y]]) for x,y in zip(*high_corr_var_) if x!=y and x<y]\n\nhigh_corr_var","848203ce":"\nlow_corr_var_=np.where(corr_matrix<=-.1)\nlow_corr_var=[(corr_matrix.columns[x],corr_matrix.columns[y], corr_matrix[corr_matrix.columns[x]][corr_matrix.columns[y]]) for x,y in zip(*low_corr_var_) if x!=y and x<y]\n\nlow_corr_var","da396f95":" sns.pairplot(corr_matrix, diag_kind=\"kde\", palette=\"husl\")","1dcc9a17":"import cv2\nfrom PIL import Image\nimport imageio\nfrom scipy.misc import imread\ntrain_path = \"..\/input\/train\/\"","fb3576a3":"1. **Single vs Multi label distribution of train data**","a3966ffb":"**Matrix for coreation values of labels**","30386136":"**correlations between training labes**","0ed4ca23":"**Load dataset info\n**","58d14836":"**Distribution of training labels**","a766a1ee":"Count of proteins occur in each images ","e822f3e4":"**Low corelation between labels**","c9dc3720":"Count of Images for number of labes present in images\n\nAll counts:\n\n**        label count     and       Images count**\n        \n        1                 15126\n        \n        2                 12485\n        \n        3                  3160\n        \n        4                  299\n        \n        5                  2\n        ","33a2fe85":"**High corelation between labels**","24e40f1e":"There are 28 different target proteins\ncreating label dict"}}