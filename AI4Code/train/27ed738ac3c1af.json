{"cell_type":{"c1ee9e45":"code","df1f0520":"code","3595184d":"code","3181e372":"code","0c9e8431":"code","28aaf9bd":"code","c11adefd":"code","19b2050e":"code","c783332c":"code","adc881fd":"code","a2fe14c6":"code","42ec95ee":"code","d18b2468":"code","c3983426":"code","e4309ee0":"code","3971b4d2":"code","cf6cf2eb":"code","ebb4beb7":"code","e45ed16c":"code","e1e1d67f":"code","f39b17ff":"code","90045647":"code","936b4047":"code","b8f94600":"code","04514326":"code","9d5a5fce":"code","f94c7124":"code","bb966896":"markdown"},"source":{"c1ee9e45":"import numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import StratifiedKFold\nimport gc\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport lightgbm as lgb\nimport logging\nfrom astropy.stats import LombScargle\nfrom astropy.time import Time","df1f0520":"train = pd.read_csv('..\/input\/training_set.csv')\nprint(train.shape)\nmeta_train = pd.read_csv('..\/input\/training_set_metadata.csv')\nprint(meta_train.shape)","3595184d":"train['mjd'] = Time(train.mjd.values, format='mjd').iso\ntrain['mjd'] = pd.to_datetime(train['mjd'])","3181e372":"x = train.copy()\nx.head()\nx = x.sort_values(by=['object_id','passband','mjd'])","0c9e8431":"x['cc'] = x.groupby(['object_id','passband'])['mjd'].cumcount()\n","28aaf9bd":"x.mjd = x.groupby(['object_id','passband'])['mjd'].diff()\nx.loc[~x.mjd.isnull(),'mjd'] = x.loc[~x.mjd.isnull(),'mjd'].apply(lambda a: a.total_seconds())\nx.loc[x.mjd.isnull(),'mjd'] = 0\nx.mjd = x.mjd.astype('float32')","c11adefd":"x.head()","19b2050e":"x = x.set_index(['object_id','passband','cc'])","c783332c":"x = x.unstack()","adc881fd":"x.head()","a2fe14c6":"cols = ['_'.join(str(s).strip() for s in col if s) if len(col)==2 else col for col in x.columns ]\ncols\nx.columns = cols","42ec95ee":"x.head()","d18b2468":"mjdcolumns = [a  for a in x.columns if a.startswith('mjd')]","c3983426":"fluxcolumns = [a  for a in x.columns if a.startswith('flux') and not a.startswith('flux_err')]","e4309ee0":"def GenerateLS(r):\n    t = r[mjdcolumns].dropna().apply(lambda a: a\/(3600)).cumsum().astype('float32')\n    p = r[fluxcolumns].dropna().astype('float32')\n    frequency, power = LombScargle(t.values,p.values).autopower(nyquist_factor=1)\n    w = pd.DataFrame()\n    w['f'] = (frequency*100000).astype(int)\n    w['p'] = power\n    w = w.groupby('f').sum().reset_index(drop=False)\n    return  {'f'+str(int(i)):j for i,j in zip(w.f,w.p)}\n    ","3971b4d2":"d = x.apply(lambda r: GenerateLS(r),axis=1)","cf6cf2eb":"trn_all_predictions = pd.DataFrame(list(d))","ebb4beb7":"trn_all_predictions.head()","e45ed16c":"meta_train = meta_train.set_index('object_id')","e1e1d67f":"x = x.join(meta_train,on='object_id',how='left')","f39b17ff":"x = x.reset_index(drop=False)\n","90045647":"x.head()","936b4047":"trn_all_predictions.insert(0,'passband',x.passband.ravel())\ntrn_all_predictions.insert(0,'object_id',x.object_id.ravel())\ntrn_all_predictions = trn_all_predictions.join(meta_train,on='object_id',how='left')","b8f94600":"trn_all_predictions.head()","04514326":"cols = []\nfor i in range(186):\n    cols.append('f'+str(i))\n","9d5a5fce":"f, ax = plt.subplots(6)\nf.set_figheight(15)\nf.set_figwidth(15)\nfor i in range(6):\n    ax[i].xaxis.set_ticks(np.arange(0, 186, 20))   \nax[0].plot(trn_all_predictions[(trn_all_predictions.passband==0)][cols].mean())\nax[1].plot(trn_all_predictions[(trn_all_predictions.passband==1)][cols].mean())\nax[2].plot(trn_all_predictions[(trn_all_predictions.passband==2)][cols].mean())\nax[3].plot(trn_all_predictions[(trn_all_predictions.passband==3)][cols].mean())\nax[4].plot(trn_all_predictions[(trn_all_predictions.passband==4)][cols].mean())\nax[5].plot(trn_all_predictions[(trn_all_predictions.passband==5)][cols].mean())","f94c7124":"uniques = sorted(trn_all_predictions.target.unique())\nf, ax = plt.subplots(len(uniques),6)\nf.set_figheight(30)\nf.set_figwidth(15)\nfor a in range(len(uniques)):\n    for b in range(6):\n        ax[a,b].xaxis.set_ticks(np.arange(0, 186, 50))   \n   \nfor i in range(len(uniques)):\n    ax[i][0].plot(trn_all_predictions[(trn_all_predictions.target==uniques[i])&(trn_all_predictions.passband==0)][cols].mean()-trn_all_predictions[(trn_all_predictions.passband==0)][cols].mean())\n    ax[i][1].plot(trn_all_predictions[(trn_all_predictions.target==uniques[i])&(trn_all_predictions.passband==1)][cols].mean()-trn_all_predictions[(trn_all_predictions.passband==1)][cols].mean())\n    ax[i][2].plot(trn_all_predictions[(trn_all_predictions.target==uniques[i])&(trn_all_predictions.passband==2)][cols].mean()-trn_all_predictions[(trn_all_predictions.passband==2)][cols].mean())\n    ax[i][3].plot(trn_all_predictions[(trn_all_predictions.target==uniques[i])&(trn_all_predictions.passband==3)][cols].mean()-trn_all_predictions[(trn_all_predictions.passband==3)][cols].mean())\n    ax[i][4].plot(trn_all_predictions[(trn_all_predictions.target==uniques[i])&(trn_all_predictions.passband==4)][cols].mean()-trn_all_predictions[(trn_all_predictions.passband==4)][cols].mean())\n    ax[i][5].plot(trn_all_predictions[(trn_all_predictions.target==uniques[i])&(trn_all_predictions.passband==5)][cols].mean()-trn_all_predictions[(trn_all_predictions.passband==5)][cols].mean())","bb966896":"The Lomb-Scargle Periodogram is a commonly-used statistical tool designed to detect periodic signals in unevenly-spaced observations. The AstropyLombScargle class is a unified interface to several implementations of the Lomb-Scargle periodogram, including a fast O[NlogN] implementation following the algorithm presented by Press & Rybicki]."}}