{"cell_type":{"ba73520d":"code","47f4c89d":"code","722d1b91":"code","be2ffc03":"code","cb7c836f":"code","d280ee89":"code","2e3339db":"code","f7989a28":"code","8b525b89":"code","f1fc0a47":"code","63b52943":"code","bee51dcc":"code","274d0ddf":"code","473ed6c2":"code","7e111314":"code","33f045a6":"code","20b36966":"code","3fac56c6":"code","9339f88b":"code","e9d234df":"code","03985056":"code","c0d2fea1":"code","1bef8055":"code","b1ce5712":"code","55027970":"code","675e0720":"code","aa00d128":"code","a7dd7f20":"code","e6db66f7":"code","415642fa":"code","617ec903":"code","897b1409":"code","e22b81b3":"code","bf27072d":"code","aabbeb21":"code","3c1705f0":"code","ca249b9c":"code","a8514024":"code","9c64ba22":"code","15c3d33b":"code","61c69bfb":"markdown","2dc2110c":"markdown","3c6a29ac":"markdown","3ebb4735":"markdown","5220c3aa":"markdown","0b362abb":"markdown","f5694b01":"markdown","f113261b":"markdown","794c9b6f":"markdown","948d73a5":"markdown","45c8b1a4":"markdown","594fbd9b":"markdown"},"source":{"ba73520d":"\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n#Visiulazation\nimport matplotlib.pyplot as plt\n#image processing\nimport cv2\n#extracting zippped file\nimport tarfile\n#systems\nimport os\nprint(os.listdir(\"..\/input\"))","47f4c89d":"#example\nimgg=\"\/kaggle\/input\/photos\/ben.jpg\"\nceleb=cv2.imread(imgg)","722d1b91":"def show_image(image):\n    plt.figure(figsize=(8,5))\n    #Before showing image, bgr color order transformed to rgb order\n    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\n    plt.xticks([])\n    plt.yticks([])\n    plt.show()\n    ","be2ffc03":"show_image(celeb)","cb7c836f":"# Our face detection function that uses haarcascade from OpenCV\ndef face_detection(img):\n    face_cascade = cv2.CascadeClassifier('\/kaggle\/input\/haarcascades\/haarcascade_frontalface_alt.xml')\n    \n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    faces = face_cascade.detectMultiScale(gray)\n    print('Number of faces detected:', len(faces))\n        \n    for (x,y,w,h) in faces:\n        cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)\n        #img = img[y:y+h, x:x+w] # for cropping\n    cv_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    return cv_rgb","d280ee89":"#imgg2=cv2.imread(\"\/kaggle\/input\/photos\/ben.jpg\")\na=face_detection(celeb)\nplt.imshow(a)\nplt.show() \n\n# as shown below, the library is not detecting this particular face angle of Ben Afflek","2e3339db":"plt.figure(figsize=(15,18))\nimg=cv2.imread(\"..\/input\/photos\/people.jpg\")\nc=face_detection(img)\nplt.imshow(c)\nplt.show()","f7989a28":"# using openCV DNN\n# load the model\n#modelFile = \"..\/input\/opencv-dnn\/opencv_face_detector_uint8.pb\" \n#configFile = \"..\/input\/opencv-dnn\/opencv_face_detector.pbtxt\"\n#net = cv2.dnn.readNetFromTensorflow(modelFile, configFile)\n\nmodelFile =\"..\/input\/opencvdnnfp16\/res10_300x300_ssd_iter_140000_fp16.caffemodel\"\nconfigFile = \"..\/input\/opencvdnnfp16\/deploy.prototxt\"\nnet = cv2.dnn.readNetFromCaffe(configFile, modelFile)","8b525b89":"#function to extract box dimensions\ndef face_dnn(img, coord=False):\n    blob = cv2.dnn.blobFromImage(img, 1, (224,224), [104, 117, 123], False, False) #\n    # params: source, scale=1, size=300,300, mean RGB values (r,g,b), rgb swapping=false, crop = false\n    conf_threshold=0.8 # confidence at least 60%\n    frameWidth=img.shape[1] # get image width\n    frameHeight=img.shape[0] # get image height\n    max_confidence=0\n    net.setInput(blob)\n    detections = net.forward()\n    detection_index=0\n    bboxes = []\n    \n    for i in range(detections.shape[2]):\n        confidence = detections[0, 0, i, 2]\n        if confidence > conf_threshold:\n            \n            if max_confidence < confidence: # only show maximum confidence face\n                max_confidence = confidence\n                detection_index = i\n    i=detection_index        \n    x1 = int(detections[0, 0, i, 3] * frameWidth)\n    y1 = int(detections[0, 0, i, 4] * frameHeight)\n    x2 = int(detections[0, 0, i, 5] * frameWidth)\n    y2 = int(detections[0, 0, i, 6] * frameHeight)\n    cv2.rectangle(img,(x1,y1),(x2,y2),(255,255,0),2)\n    cv_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    if coord==True:\n        return x1, y1, x2, y2\n    return cv_rgb","f1fc0a47":"#gray=cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)\n# multiple faces needs increasing the size of image as well as multiple detections\ndef nfaces_dnn(img):\n    blob = cv2.dnn.blobFromImage(img, 1.2, (1200,1200), [104, 117, 123], False, False) #\n    # params: source, scale=1, size=300,300, mean RGB values (r,g,b), rgb swapping=false, crop = false\n    conf_threshold=0.6 # confidence at least 60%\n    frameWidth=img.shape[1] # get image width\n    frameHeight=img.shape[0] # get image height\n    net.setInput(blob)\n    detections = net.forward()\n  \n    bboxes = []\n    \n    for i in range(detections.shape[2]):\n        confidence = detections[0, 0, i, 2]\n        if confidence > conf_threshold:\n                  \n            x1 = int(detections[0, 0, i, 3] * frameWidth)\n            y1 = int(detections[0, 0, i, 4] * frameHeight)\n            x2 = int(detections[0, 0, i, 5] * frameWidth)\n            y2 = int(detections[0, 0, i, 6] * frameHeight)\n            cv2.rectangle(img,(x1,y1),(x2,y2),(255,255,0),2)\n    cv_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    return cv_rgb","63b52943":"a=face_dnn(celeb)\nplt.imshow(a)\nplt.show() ","bee51dcc":"img=cv2.imread(\"..\/input\/photos\/people.jpg\")\nc=nfaces_dnn(img)\nplt.figure(figsize=(15,18))\nplt.imshow(c)\nplt.show()","274d0ddf":"#os.listdir('..\/input\/lfwpeople\/')\nfname='..\/input\/lfwpeople\/lfwfunneled.tgz'","473ed6c2":"def jpg_files(members): #only extract jpg files\n    for tarinfo in members:\n        if os.path.splitext(tarinfo.name)[1] == \".jpg\":\n            yield tarinfo\ndef untar(fname,path=\"LFW\"): #untarring the archive\n    tar = tarfile.open(fname)\n    tar.extractall(path,members=jpg_files(tar))\n    tar.close()\n    if path is \"\":\n        print(\"File Extracted in Current Directory\")\n    else:\n        print(\"File Extracted in to\",  path)","7e111314":"untar(fname,\"LFW\")","33f045a6":"len(os.listdir('..\/working\/LFW\/lfw_funneled\/')) # total number of folders (people)","20b36966":"# total number of images\ntotal = sum([len(files) for r, d, files in os.walk('..\/working\/LFW\/lfw_funneled\/')])\nprint(total)","3fac56c6":"count=0 \nimglist=[]\n# \nfor r, d, files in os.walk('..\/working\/LFW\/lfw_funneled\/'):   \n    if len(files)>=20: \n        imglist.append(r)\n        #print(count, r)\n        count+=1 # counts how many folders have with at least 20 images\nprint(count)","9339f88b":"#os.listdir(imglist[0])\n# pick one random photo\na=np.random.randint(0,20)\nb=np.random.randint(0,62)\nimglist[b]","e9d234df":"# show the random photo with face detected\nimg=imglist[b]+'\/'+os.listdir(imglist[b])[a]\nimg=cv2.imread(img)\nc=face_dnn(img)\nplt.imshow(c)\nplt.show()","03985056":"#remove unused folders\nimport shutil\npathd='..\/working\/LFW\/lfw_funneled\/'\n#shutil.rmtree(os.path.realpath('LFW'))\nfor dirs in os.listdir(pathd):\n    if not (pathd+dirs) in imglist:\n        shutil.rmtree(os.path.realpath(pathd+dirs))","c0d2fea1":"dirs=os.listdir(pathd)\ndirs.sort()","1bef8055":"#example of box coordinates\n#a=np.random.randint(0,20)\nb=np.random.randint(0,62)\nfor img in os.listdir(pathd+dirs[b])[:5]:\n    #print(pathd+dirs[0]+'\/'+img)\n    print(dirs[b])\n    img=cv2.imread(pathd+dirs[b]+'\/'+img)\n    x1, y1, x2, y2=face_dnn(img, True)\n    #print coordinates of the detected face\n    print(x1, y1, x2, y2)\n    plt.imshow(img)\n    plt.show()","b1ce5712":"os.listdir('..\/working\/LFW\/')\npathd\n#(os.listdir(pathd))","55027970":"# # creating test and train set\nfrom numpy import random\ndatadir='..\/working\/LFW\/'\ntrain=datadir+'train\/'\ntest=datadir+'test\/'\n\nif not os.path.exists(train):\n    os.mkdir(train)\nif not os.path.exists(test):\n    os.mkdir(test)\n    \nfor dirs in os.listdir(pathd):\n    filenames = os.listdir(pathd+dirs)\n    filenames.sort()  # make sure that the filenames have a fixed order before shuffling\n    random.seed(402)\n    random.shuffle(filenames) # shuffles the ordering of filenames (deterministic given the chosen seed)\n    split = int(0.85 * len(filenames))\n    train_filenames = filenames[:split] # splitting filenames into two parts\n    test_filenames = filenames[split:]\n    for img in train_filenames:\n        full_file_name = os.path.join(pathd+dirs, img)\n        cur_dir=os.path.join(train+dirs)\n        #print(cur_dir)\n        if not os.path.exists(cur_dir): # create this current person's folder for training\n            os.mkdir(cur_dir)\n        shutil.copy(full_file_name, cur_dir)\n    for img in test_filenames:\n        full_file_name = os.path.join(pathd+dirs, img)\n        cur_dir=os.path.join(test+dirs)\n        if not os.path.exists(cur_dir): # create this current person's folder for testing\n            os.mkdir(cur_dir)\n        shutil.copy(full_file_name, cur_dir)\n        #a=full_file_name+' '+test+dirs\nshutil.rmtree('..\/working\/LFW\/lfw_funneled\/')","675e0720":"# total number of images left\ntotal = sum([len(files) for r, d, files in os.walk(datadir)])\nprint(total)","aa00d128":"labeldir=\"Labels\/\" # labels dir\nwdir=\"..\/working\/LFW\/\"\nlab=wdir+labeldir\nif not os.path.exists(lab):\n    os.mkdir(lab)","a7dd7f20":"# function for creating box labels as txt file\ndef label_txt(pathdr, lab_dir):\n    for fol in os.listdir(pathdr):\n        tfile = open(lab_dir+fol+\".txt\",\"w+\")\n        for img in os.listdir(pathdr+fol):\n            pathimg=os.path.join(pathdr+fol, img)\n            #print(pathimg)\n            pic=cv2.imread(pathimg)\n            x1, y1, x2, y2=face_dnn(pic, True) # face detection and then saving into txt file       \n            tfile.write(img+' '+str(x1)+' '+str(x2)+' '+str(y1)+' '+str(y2)+'\\n')          \n        tfile.close()\n    print('Saved')","e6db66f7":"lab_dir=lab+'train\/'\nos.mkdir(lab_dir)\nlabel_txt(train, lab_dir)\n\nlab_dir=lab+'test\/'\nos.mkdir(lab_dir)\nlabel_txt(test, lab_dir)","415642fa":"#let's check if txt files are correct:\nf2 = open(\"..\/working\/LFW\/Labels\/test\/Arnold_Schwarzenegger.txt\",\"r\")\nprint(f2.read())\nf2.close()","617ec903":"# checking Arnold_Schwarzenegger_0041.jpg\npic=cv2.imread(test+'Arnold_Schwarzenegger\/Arnold_Schwarzenegger_0041.jpg')\ncv2.rectangle(pic,(77 ,62),(176,194),(255,255,0),2)\nplt.imshow(pic)\nplt.show()","897b1409":"def read_txt(person, photo):  \n    txtfile = labels+person+\".txt\"\n    txtfile_contents = open(txtfile, \"r\")\n    txtlines = txtfile_contents.readlines()\n    txtfile_contents.close()\n    for line in txtlines:\n        if photo in line:\n            txtlines=line\n    return txtlines","e22b81b3":"!pip install object_detection >obj_dtc.txt # installing object detection","bf27072d":"from PIL import Image\nfrom object_detection.utils import dataset_util\n\n# flags = tf.app.flags\n# flags.DEFINE_string('output_path', '', 'Path to output TFRecord')\n# FLAGS = flags.FLAGS\n# modified from source: https:\/\/github.com\/tensorflow\/models\/blob\/master\/research\/object_detection\/g3doc\/using_your_own_dataset.md\ndef create_tf_example(photo, person, iclass, foldr):\n    # one image at a time\n    img_f=os.path.join(foldr+person,photo+\".jpg\")\n    pic = Image.open(img_f)\n    height = pic.height # Image height\n    width = pic.width # Image width\n    filename = str.encode(photo) # Filename of the image. Empty if image is not from file\n    #encoded_image_data = None # Encoded image bytes\n    image_data = tf.gfile.GFile(img_f,'rb').read()\n    \n    image_format = b'jpeg' #None #  or b'png'\n    #declare coordinates\n    xmins = [] # List of normalized left x coordinates in bounding box (1 per box)\n    xmaxs = [] # List of normalized right x coordinates in bounding box\n             # (1 per box)\n    ymins = [] # List of normalized top y coordinates in bounding box (1 per box)\n    ymaxs = [] # List of normalized bottom y coordinates in bounding box\n             # (1 per box)\n    classes_text = [] # List of string class name of bounding box (1 per box)\n    classes = [] # List of integer class id of bounding box (1 per box)\n    \n    txtlines = read_txt(person, photo)\n\n    labels = txtlines.split()\n\n    xmins.append(float(labels[1])\/width)\n    xmaxs.append(float(labels[2])\/width)\n    ymins.append(float(labels[3])\/height)\n    ymaxs.append(float(labels[4])\/height)\n\n    classes_text.append(str.encode(person))\n    classes.append(iclass) #### iterator is needed\n    #print(xmins, xmaxs, ymins, ymaxs, classes_text, photo, img_f) # for test purposes\n    tf_example = tf.train.Example(features=tf.train.Features(feature={\n      'image\/height': dataset_util.int64_feature(height),\n      'image\/width': dataset_util.int64_feature(width),\n      'image\/filename': dataset_util.bytes_feature(filename),\n      'image\/source_id': dataset_util.bytes_feature(filename),\n      'image\/encoded': dataset_util.bytes_feature(image_data),\n      'image\/format': dataset_util.bytes_feature(image_format),\n      'image\/object\/bbox\/xmin': dataset_util.float_list_feature(xmins),\n      'image\/object\/bbox\/xmax': dataset_util.float_list_feature(xmaxs),\n      'image\/object\/bbox\/ymin': dataset_util.float_list_feature(ymins),\n      'image\/object\/bbox\/ymax': dataset_util.float_list_feature(ymaxs),\n      'image\/object\/class\/text': dataset_util.bytes_list_feature(classes_text),\n      'image\/object\/class\/label': dataset_util.int64_list_feature(classes),\n    }))\n    return tf_example\n\n","aabbeb21":"import tensorflow as tf\n#saving tfrecords\ndef save_tf(folder):\n    tf_file=folder.split('\/')[-2] +'.tfrecord'\n    writer = tf.python_io.TFRecordWriter('..\/working\/'+tf_file)\n    \n    labelmap = '..\/working\/'+'object_label.pbtxt' # for model training\n    txtf = open(labelmap, \"w\")\n    \n    labels = '..\/working\/'+'labels.txt' # for android deployment\n    txtl = open(labels, \"w\")\n    \n    for ind, person in enumerate(os.listdir(folder)):\n        iclass=ind+1\n        txtf.write(\"item\\n{\\n  id: %s\\n  name: '%s'\\n}\\n\"%(iclass,person))\n        txtl.write(\"%s\\n\"%person)\n        #print(iclass, person)\n        for photo in os.listdir(folder+person):\n            tf_example = create_tf_example(photo.split('.')[0], person, iclass, folder) #004.jpg, arnold, 1\n            #print('Folder:', pathd+fol, iclass)\n            writer.write(tf_example.SerializeToString())\n    txtf.close()\n    writer.close()","3c1705f0":"labels='..\/working\/LFW\/Labels\/train\/'\nsave_tf(train)\n\nlabels='..\/working\/LFW\/Labels\/test\/'\nsave_tf(test)","ca249b9c":"os.stat('..\/working\/train.tfrecord').st_size\/1024\/1024","a8514024":"def make_tarfile(output_filename, source_dir):\n    with tarfile.open(output_filename, \"w:gz\") as tar:\n        tar.add(source_dir, arcname=os.path.basename(source_dir))\nmake_tarfile('test_images.tar.gz','\/kaggle\/working\/LFW\/test')        \nshutil.rmtree('\/kaggle\/working\/LFW\/')\n#os.listdir('\/kaggle\/working\/LFW\/test')","9c64ba22":"os.listdir('\/kaggle\/working\/')","15c3d33b":"# for test purposes\n# pic = Image.open('..\/working\/LFW\/test\/Jennifer_Capriati\/Jennifer_Capriati_0007.jpg')\n# height = pic.height # Image height\n# width = pic.width # Image width\n# pic=cv2.imread('..\/working\/LFW\/test\/Jennifer_Capriati\/Jennifer_Capriati_0007.jpg')\n# cv2.rectangle(pic,(int(0.304*width),int(0.236*height)),(int(0.692*width),int(0.768*height)),(255,255,0),2)\n# plt.imshow(pic)\n# plt.show()","61c69bfb":"# Creating tfrecords with annotated images","2dc2110c":"## Now we extract LFW for face detection","3c6a29ac":"As output shows, although 'multiple faces' function does not register some faces from a group of people, DNN is able to detect non-frontal faces without clipping chin.","3ebb4735":"This is the complete code for part 1 of [my Medium article](https:\/\/medium.com\/@saidakbarp\/real-time-face-recognition-tflite-3fb818ac039a). The complete notebook for the part 2 of my Medium article is [here](https:\/\/www.kaggle.com\/saidakbarp\/face-recognition-part-2\/notebook).\n\nFace recognition relies on the dataset that has been annotated with boxes. Manually annotating faces in each images can be time consuming and for large scale training, manual annotation is impractical. For this reason we will use available face annotation tools to annotate each image with boxes. Afterwards, we can move to Object detection training part.","5220c3aa":"Our tfrecords and labels are ready for model training. [Part 2](https:\/\/www.kaggle.com\/saidakbarp\/face-recognition-part-2\/notebook) shows how to train an existing model and convert it to tflite directly in jupyter notebook.","0b362abb":"As we can see box annotation is correct! Now, we have to save annotations as tfrecord:","f5694b01":"## Creating training and test sets","f113261b":"Haarcascade has a con: it can not detect non-frontal face images and also boxes sometimes do not include full face, clipping chins or forehead. Let us try a better model: openCV DNN","794c9b6f":"# Face recognition with Tensorflow Object Detection API (LFW dataset)","948d73a5":"We have a list of people (62) with at least 20 images. Now, we will use this annotation of faces, and train MobileNet NN model to recognize those people.","45c8b1a4":"Our main purpose is to use LFW people images that have at least 20 examples ( later, obtain 100 images of top 100 celebrities from Google image search), then crop their faces (single face photos). Afterwards, we train our mobilenetV2 coco model to recognize those celebrities. Final goal is to identify celebrities from their photos.","594fbd9b":"Each picture is centered on a single face. The typical task is called Face Verification: given a pair of two pictures, a binary classifier must predict whether the two images are from the same person.\n\nAn alternative task, Face Recognition or Face Identification is: given the picture of the face of an unknown person, identify the name of the person by referring to a gallery of previously seen pictures of identified persons.\n\nBoth Face Verification and Face Recognition are tasks that are typically performed on the output of a model trained to perform Face Detection. The most popular model for Face Detection is called Viola-Jones and is implemented in the OpenCV library. The LFW faces were extracted by this face detector from various online websites."}}