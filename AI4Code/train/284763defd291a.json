{"cell_type":{"afa0b647":"code","7f6841ce":"code","fb0277b4":"code","4547c0a1":"code","f3febd9c":"code","d5e0a0f3":"code","068b3f5a":"code","7220952a":"code","3d934efa":"code","54607080":"code","8709f124":"code","616be5b9":"code","44dcb39d":"code","d1fc7071":"code","fa90e5e3":"code","ffaf831d":"code","4a7a8b27":"code","115a5b9d":"code","cf552d82":"code","15bc9b47":"code","a0ee6791":"code","580be68e":"code","4471d01d":"markdown","1f7f56bd":"markdown","4d84786c":"markdown","a643c54f":"markdown","a143aa07":"markdown","6e69d2cd":"markdown","bd1dd627":"markdown","a30e753c":"markdown","e8aa4b5e":"markdown","b55604a6":"markdown","ff8e8e43":"markdown","ff55e420":"markdown","0058a461":"markdown","bf4118af":"markdown","f397e91f":"markdown","f70e403e":"markdown","35d3aa08":"markdown","6b35550c":"markdown","88c09de7":"markdown","f8048a3a":"markdown","e1591390":"markdown","1ae013a4":"markdown","6bb979e9":"markdown","bdc6b6ff":"markdown","188fac20":"markdown","58c59df5":"markdown","70b8a163":"markdown","26e28962":"markdown"},"source":{"afa0b647":"from tensorflow.keras.preprocessing.image import ImageDataGenerator, load_img\nfrom tensorflow.keras.preprocessing import image \nimport matplotlib.image as image \nimport matplotlib.pyplot as plt\nimport tensorflow as tf\nimport numpy as np\nimport cv2\nimport PIL\nimport os\n\nprint(tf.__version__)","7f6841ce":"image_generator = ImageDataGenerator(rescale=1\/255, validation_split=0.2)\n\ntrain_data = image_generator.flow_from_directory(\"..\/input\/cell-images-for-detecting-malaria\/cell_images\/cell_images\",\n                                                target_size=(163,142),\n                                                class_mode=\"binary\",\n                                                batch_size=32,\n                                                subset=\"training\")\n\nval_data = image_generator.flow_from_directory(\"..\/input\/cell-images-for-detecting-malaria\/cell_images\/cell_images\",\n                                                target_size=(163,142),\n                                                class_mode=\"binary\",\n                                                batch_size=32,\n                                                subset=\"validation\",\n                                                shuffle = False)","fb0277b4":"train_data.class_indices","4547c0a1":"infect=[]\nfor i in range(20):\n    if train_data[i][1][0]==0:\n        infect.append(i)\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,10))\nax = plt.subplot(1,2, 1)\nplt.imshow(train_data[infect[0]][0][0])\nax.axes.get_yaxis().set_visible(False)\nax.axes.get_xaxis().set_visible(False)\nax = plt.subplot(1,2, 2)\nplt.imshow(train_data[infect[1]][0][0])\nax.axes.get_yaxis().set_visible(False)\nax.axes.get_xaxis().set_visible(False)\nprint(\"Left is Parasitized:\",train_data[infect[0]][1][0]==0)\nprint(\"Right is Parasitized:\",train_data[infect[1]][1][0]==0)","f3febd9c":"non=[]\nfor i in range(20):\n    if train_data[i][1][0]==1:\n        non.append(i)\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,10))\nax = plt.subplot(1,2, 1)\nplt.imshow(train_data[non[0]][0][0])\nax.axes.get_yaxis().set_visible(False)\nax.axes.get_xaxis().set_visible(False)\nax = plt.subplot(1,2, 2)\nplt.imshow(train_data[non[1]][0][0])\nax.axes.get_yaxis().set_visible(False)\nax.axes.get_xaxis().set_visible(False)\nprint(\"Left is Uninfected:\",train_data[non[0]][1][0]==1)\nprint(\"Right is Uninfected:\",train_data[non[1]][1][0]==1)","d5e0a0f3":"import pandas as pd \n\ntest = pd.DataFrame(train_data.classes, columns=[\"classes\"])\ntest[\"c\"] = 1\ntest = test.groupby([\"classes\"]).count()","068b3f5a":"plt.figure(figsize=(8,8))\nplt.bar([\"Uninfected\",\"Parasitized\"],test.c)\nplt.rcParams.update({'font.size': 15})\nplt.title(\"Training Data Distribution\")\nplt.ylim((10000,11500));","7220952a":"import shutil\nshutil.rmtree(\".\/logs\/\") ","3d934efa":"def create_model():\n    model = tf.keras.models.Sequential([tf.keras.layers.Conv2D(16,(3,3), activation = \"relu\", input_shape=(163,142,3)),\n                                     tf.keras.layers.MaxPool2D((2,2)),\n                                     tf.keras.layers.Conv2D(32,(3,3), activation = \"relu\"),\n                                     tf.keras.layers.MaxPool2D((2,2)),\n                                     tf.keras.layers.Dropout(0.25),\n                                     tf.keras.layers.Conv2D(64,(3,3), activation = \"relu\"),\n                                     tf.keras.layers.MaxPool2D((2,2)),\n                                     tf.keras.layers.Dropout(0.25),\n                                     tf.keras.layers.Conv2D(128,(3,3), activation = \"relu\"),\n                                     tf.keras.layers.Dropout(0.25),\n                                     tf.keras.layers.Flatten(),\n                                     tf.keras.layers.Dense(256, activation = \"relu\"),\n                                     tf.keras.layers.Dense(128, activation = \"relu\"),\n                                     tf.keras.layers.Dense(1, activation = \"sigmoid\")\n                                     ])\n    model.compile(loss=\"binary_crossentropy\",\n            optimizer =\"adam\",\n            metrics =['accuracy'])\n    return model","54607080":"model = create_model()\n\nmodel.summary()","8709f124":"# When changing something in the logs cell you need to reload the\n# the tensorboard extenstion\n\n%reload_ext tensorboard","616be5b9":"%load_ext tensorboard\nimport datetime\n\n#Saving weights callback\ncp_path = \"training_1\/cp.ckpt\"\ncp_dir = os.path.dirname(cp_path)\ncp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=cp_path,\n                                                save_weights_only=True,\n                                                verbose=1)\n\n#Tensorboard callback \nlog_path = os.path.join('logs','fit')\nos.makedirs(log_path,exist_ok=True)\ntensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_path, histogram_freq=1,profile_batch = 100000000)","44dcb39d":"model.fit(train_data, \n          epochs=2, \n          validation_data=val_data,\n          callbacks=[cp_callback, tensorboard_callback]);","d1fc7071":"latest = tf.train.latest_checkpoint(cp_dir)\n\nmodel.load_weights(latest)","fa90e5e3":"loss, acc = model.evaluate(val_data, verbose=2)\nprint(\"Restored model, accuracy: {:5.2f}%\".format(100*acc))","ffaf831d":"%tensorboard --logdir logs\/fit\/ --host localhost","4a7a8b27":"%matplotlib inline\nfrom sklearn.metrics import confusion_matrix \nimport itertools \n\npred = model.predict_classes(val_data, batch_size=None)\n\ntrue = val_data.classes\n\ncm = confusion_matrix(y_true=true, y_pred=pred)","115a5b9d":"def plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label');","cf552d82":"cm_plot_labels= [\"Uninfected\",\"Parasitized\"]\nplot_confusion_matrix(cm=cm, classes=cm_plot_labels, title=\"Confusion Matrix\");","15bc9b47":"false_n = []\nfalse_p =[]\nfor i in range(len(pred)):\n    if pred[i] == 0 and true[i] == 1:\n        false_p.append(i)\n    if pred[i] == 1 and true[i] == 0:\n        false_n.append(i)\n\nbatch_false_n = []\nfor i in false_n:\n    batch_false_n.append(int(i \/ 32))\n\nbatch_false_p = []\nfor i in false_p:\n    batch_false_p.append(int(i \/ 32))\n\nind_in_batch_false_n = []\nfor i, val in enumerate(false_n):\n    ind_in_batch_false_n.append(false_n[i] - (batch_false_n[i] * 32))\n\nind_in_batch_false_p = []\nfor i, val in enumerate(false_p):\n    ind_in_batch_false_p.append(false_p[i] - (batch_false_p[i] * 32))","a0ee6791":"fig, ([ax1, ax2], [ax3, ax4]) = plt.subplots(2,2, figsize=(10,10))\nax = plt.subplot(2,2,1)\n\nax = plt.imshow(val_data[batch_false_n[0]][0][ind_in_batch_false_n[0]])\nax.axes.get_yaxis().set_visible(False)\nax.axes.get_xaxis().set_visible(False)\n\nax = plt.subplot (2,2,2)\nax = plt.imshow(val_data[batch_false_n[1]][0][ind_in_batch_false_n[1]])\nax.axes.get_yaxis().set_visible(False)\nax.axes.get_xaxis().set_visible(False)\n\nax = plt.subplot (2,2,3)\nax = plt.imshow(val_data[batch_false_n[2]][0][ind_in_batch_false_n[2]])\nax.axes.get_yaxis().set_visible(False)\nax.axes.get_xaxis().set_visible(False)\n\nax = plt.subplot (2,2,4)\nax = plt.imshow(val_data[batch_false_n[3]][0][ind_in_batch_false_n[3]])\nax.axes.get_yaxis().set_visible(False)\nax.axes.get_xaxis().set_visible(False)\n\nprint(\"Amount of False Negatives: {}\".format(len(false_n)))\nprint(\"Top Left is Labeled as Parasitized:\",val_data[batch_false_n[0]][1][ind_in_batch_false_n[0]]==0)\nprint(\"Top Right is Labeled as Parasitized:\",val_data[batch_false_n[1]][1][ind_in_batch_false_n[1]]==0)\nprint(\"Bottom Left is Labeled as Parasitized:\",val_data[batch_false_n[2]][1][ind_in_batch_false_n[2]]==0)\nprint(\"Bottom Right is Labeled as Parasitized:\",val_data[batch_false_n[3]][1][ind_in_batch_false_n[3]]==0)","580be68e":"fig, ([ax1, ax2], [ax3, ax4]) = plt.subplots(2,2, figsize=(10,10))\n\nax = plt.subplot(2,2,1)\nax = plt.imshow(val_data[batch_false_p[0]][0][ind_in_batch_false_p[0]])\nax.axes.get_yaxis().set_visible(False)\nax.axes.get_xaxis().set_visible(False)\n\nax = plt.subplot (2,2,2)\nax = plt.imshow(val_data[batch_false_p[1]][0][ind_in_batch_false_p[1]])\nax.axes.get_yaxis().set_visible(False)\nax.axes.get_xaxis().set_visible(False)\n\nax = plt.subplot (2,2,3)\nax = plt.imshow(val_data[batch_false_p[2]][0][ind_in_batch_false_p[2]])\nax.axes.get_yaxis().set_visible(False)\nax.axes.get_xaxis().set_visible(False)\n\nax = plt.subplot (2,2,4)\nax = plt.imshow(val_data[batch_false_p[3]][0][ind_in_batch_false_p[3]])\nax.axes.get_yaxis().set_visible(False)\nax.axes.get_xaxis().set_visible(False)\n\nprint(\"Amount of False Positives: {}\".format(len(false_p)))\nprint(\"Top Left is Labeled as Uninfected:\",val_data[batch_false_p[0]][1][ind_in_batch_false_p[0]]==1)\nprint(\"Top Right is Labeled as Uninfected:\",val_data[batch_false_p[1]][1][ind_in_batch_false_p[1]]==1)\nprint(\"Bottom Left is Labeled as Uninfected:\",val_data[batch_false_p[2]][1][ind_in_batch_false_p[2]]==1)\nprint(\"Bottom Right is Labeled as Uninfected:\",val_data[batch_false_p[3]][1][ind_in_batch_false_p[3]]==1)","4471d01d":"# Malaria Blood Smear Classifier\n\n----------","1f7f56bd":"Setting up the callbacks, one for saving weights and one for the tensorboard analysis. ","4d84786c":"Seems to have more false negatives compared to false positives with this validation set. This is a good thing as it allows more false negatives to reduce the amount of false positives. ","a643c54f":"Loading most recent model: ","a143aa07":"Calling the plot function in the confusion matrix data","6e69d2cd":"## Uninfected\n\nUninfected blood smears look clear and do not show dark pink areas. ","bd1dd627":"Function to plot the confusion matrix taken from the sklearn website","a30e753c":"### False Positives\n\nThis is when the model classified an uninfected labeled image as parasitized. Here we can see a few example of uninfected labeled images that the model predicted to be parasitized:","e8aa4b5e":"### Image Classification\n\n> [By: Graham Pinsent](https:\/\/twitter.com\/GrahamPinsent)  \n> [Linkedin](https:\/\/www.linkedin.com\/in\/graham-pinsent\/)  \n> [GitHub](https:\/\/github.com\/PerryGraham)   \n> Actively looking for new opportunities in Data Science and ML\n\n**Tools Used**: tensorflow-gpu, matplotlib, numpy, cv2, PIL, Sklearn. ","b55604a6":"# Results \n\n-----------\n\nUsed TensorBoard to evaluate the performance of my training. (doesn't show in kaggle notebook)","ff8e8e43":"Training data is ballenced between both classes","ff55e420":"I am not an expert but to me some of these images seem to not have any pink\/purple area indicating presence of parasites, even though they are labeled as parasitized. I believe that some of these images are labeled incorrectly. ","0058a461":"Setting up the data for the confusion matrix","bf4118af":"### Parasitized\n\nParasites are transmitted through female mosquito bites and can be seen in the blood smear image as a small purple area. There are different kinds of parasites, some of which can be lethal. These parasites can multiply in the blood and cause malaria. Early detection and treatment can be very beneficial for prevention of serious illness. ","f397e91f":"Getting the batch number and index within the batch of each false positive and false negative from the model predictions so they can be plotted: ","f70e403e":"Calling the model creation function and printing summary","35d3aa08":"Checking the accuracy of the loaded model:","6b35550c":"Function to create and compile the 7 layer network (4 conv: relu activation, & 3 maxpool) with 3 dropout layers. Using adam optimizer and sigmoid activation in the last layer because this is a binary classification. ","88c09de7":"Training the model. Trained for 3 epochs and saw that accuracy was still increasing, then ran for another 2 to match my best accuracy when running locally(~95%). ","f8048a3a":"Thank you ","e1591390":"## Visualizing The Data","1ae013a4":"### False Negatives\n\nThis is when the model classified a parasitized labeled image as uninfected. Here we can see a few example of parasitized labeled images that the model predicted to be uninfected:","6bb979e9":"Checking to see how balanced the training data is between the two classes. ","bdc6b6ff":"Used to delete logs when changing model params","188fac20":"Similar to the false negatives, there seem to be some incorrectly labeled images within the false positives. Having a model in which has higher accuracy than the current might be a bad thing considering the amount of incorrectly labeled images. ","58c59df5":"-------------\n\n## Model Building\n\n\n","70b8a163":"The purpose if this notebook is to try using a CNN model with TensorFlow to classify thin blood smears. More specifically, detecting the presence of parasites. With the use of smartphones with a small microscopic attachment, large scale blood smear tests can be done in developing countries. However, there is a limitation with the amount of expects that are able to determine the results of the tests. Computer vision can help solve this problem. Here is some code with an  explanation to implement a convolutional neural network to handle this classification. \n\nData from [Malaria Cell Images Dataset](https:\/\/www.kaggle.com\/iarunava\/cell-images-for-detecting-malaria) uploaded by: [Arunava](https:\/\/www.kaggle.com\/iarunava)\n\nThe final accuracy of this model was around 95%. After investigating the incorrect predictions, there seems to be some labels that are incorrect within the dataset. \n\n### Table of Contents:\n* [Preprocessing](#Preprocessing)\n* [Visualizing The Data](#Visualizing-The-Data)\n* [Model Building](#Model-Building)\n* [Results](#Result)\n\n---------------","26e28962":"### Preprocessing \n\nstart by reading the data from the directory with a 80:20 split for training and validation. "}}