{"cell_type":{"77340c21":"code","2b04327c":"code","7e77cb6f":"code","9ac85f2e":"code","3a2d2d5c":"code","93f2960d":"code","1089f036":"markdown","c46b971d":"markdown","0350c34e":"markdown","3acaba4d":"markdown","c3b692dd":"markdown"},"source":{"77340c21":"!pip install kaggle_environments==0.1.6","2b04327c":"from kaggle_environments import evaluate, make, utils\n\nenv = make(\"connectx\", debug=True)\nenv.render()","7e77cb6f":"def negamax_agent(obs, config):\n    import random\n    columns = config.columns\n    rows = config.rows\n    size = rows * columns\n    EMPTY = 0\n    # Due to compute\/time constraints the tree depth must be limited.\n    max_depth = 4\n    \n    def choice(seq):\n        return random.choice(seq)\n    def play(board, column, mark, config):\n        columns = config.columns\n        rows = config.rows\n        row = max([r for r in range(rows) if board[column + (r * columns)] == EMPTY])\n        board[column + (row * columns)] = mark\n    def is_win(board, column, mark, config, has_played=True):\n        inarow = config.inarow - 1\n        row = (\n            min([r for r in range(rows) if board[column + (r * columns)] == mark])\n            if has_played\n            else max([r for r in range(rows) if board[column + (r * columns)] == EMPTY])\n        )\n\n        def count(offset_row, offset_column):\n            for i in range(1, inarow + 1):\n                r = row + offset_row * i\n                c = column + offset_column * i\n                if (\n                    r < 0\n                    or r >= rows\n                    or c < 0\n                    or c >= columns\n                    or board[c + (r * columns)] != mark\n                ):\n                    return i - 1\n            return inarow\n\n        return (\n            count(1, 0) >= inarow  # vertical.\n            or (count(0, 1) + count(0, -1)) >= inarow  # horizontal.\n            or (count(-1, -1) + count(1, 1)) >= inarow  # top left diagonal.\n            or (count(-1, 1) + count(1, -1)) >= inarow  # top right diagonal.\n        )\n\n    def negamax(board, mark, depth):\n        moves = sum(1 if cell != EMPTY else 0 for cell in board)\n\n        # Tie Game\n        if moves == size:\n            return (0, None)\n\n        # Can win next.\n        for column in range(columns):\n            if board[column] == EMPTY and is_win(board, column, mark, config, False):\n                return ((size + 1 - moves) \/ 2, column)\n\n        # Recursively check all columns.\n        best_score = -size\n        best_column = None\n        for column in range(columns):\n            if board[column] == EMPTY:\n                # Max depth reached. Score based on cell proximity for a clustering effect.\n                if depth <= 0:\n                    row = max(\n                        [\n                            r\n                            for r in range(rows)\n                            if board[column + (r * columns)] == EMPTY\n                        ]\n                    )\n                    score = (size + 1 - moves) \/ 2\n                    if column > 0 and board[row * columns + column - 1] == mark:\n                        score += 1\n                    if (\n                        column < columns - 1\n                        and board[row * columns + column + 1] == mark\n                    ):\n                        score += 1\n                    if row > 0 and board[(row - 1) * columns + column] == mark:\n                        score += 1\n                    if row < rows - 2 and board[(row + 1) * columns + column] == mark:\n                        score += 1\n                else:\n                    next_board = board[:]\n                    play(next_board, column, mark, config)\n                    (score, _) = negamax(next_board,\n                                         1 if mark == 2 else 2, depth - 1)\n                    score = score * -1\n                if score > best_score or (score == best_score and choice([True, False])):\n                    best_score = score\n                    best_column = column\n\n        return (best_score, best_column)\n\n    _, column = negamax(obs.board[:], obs.mark, max_depth)\n    if column == None:\n        column = choice([c for c in range(columns) if obs.board[c] == EMPTY])\n    return column\n","9ac85f2e":"env.reset()\n# Play as the first agent against default \"random\" agent.\nenv.run([negamax_agent, \"random\"])\nenv.render(mode=\"ipython\", width=500, height=450)","3a2d2d5c":"import os\nimport inspect\ndef write_agent_to_file(function, file):\n    with open(file, \"a\" if os.path.exists(file) else \"w\") as f:\n        f.write(inspect.getsource(function))\n        print(function, \"written to\", file)\n\nwrite_agent_to_file(negamax_agent, \"submission.py\")","93f2960d":"# Note: Stdout replacement is a temporary workaround.\nimport sys\nout = sys.stdout\nsubmission = utils.read_file(\"\/kaggle\/working\/submission.py\")\nagent = utils.get_last_callable(submission)\nsys.stdout = out\n\nenv = make(\"connectx\", debug=True)\nenv.run([agent, agent])\nprint(\"Success!\" if env.state[0].status == env.state[1].status == \"DONE\" else \"Failed...\")","1089f036":"# Test","c46b971d":"# Test with random agent","0350c34e":"# Write submission","3acaba4d":"# Create Agent Use negamax code of kaggle","c3b692dd":"# Install kaggle enviroment"}}