{"cell_type":{"e5c74394":"code","4e169a45":"code","85c4bc29":"code","32f9886d":"code","41a65cc2":"code","ca4d4d52":"code","42a56826":"code","80a39919":"code","91681164":"code","fd82d52a":"code","8a647fa4":"code","2c6c022b":"code","be8b9c91":"code","72a1931b":"code","ecea5e7c":"code","3a496d3b":"code","0182f384":"code","f71f9b07":"code","21e08aa1":"code","1903fb98":"code","fba3190d":"code","c93ba0b0":"code","2a3f865e":"code","696abc28":"code","1e365603":"code","97d70340":"code","3ed7eaa5":"code","055ae9eb":"code","8a7c2050":"code","d84edb7c":"code","46581051":"code","707f09a3":"code","4c04887a":"code","64e7f0c3":"code","d4f43b55":"code","87200aaf":"code","3a5c96c6":"code","45668946":"code","47342cc9":"code","c7f4ce9b":"code","c93a25c9":"code","6c5d9774":"code","9561409e":"code","ab667afb":"code","5ce6adbd":"code","31b46364":"code","a9009b5a":"code","6f23f055":"code","ebdc3954":"code","57b774d4":"code","d6a583cf":"code","e898dc55":"code","a94c4545":"code","499e56c1":"markdown","f08ff400":"markdown","a3f959cd":"markdown","fdac3ad0":"markdown","f5271f72":"markdown","d7b8ea43":"markdown","e9db58dd":"markdown","8c1e98e8":"markdown","8574bc49":"markdown","ed797dd1":"markdown","cc52dc7d":"markdown","da47ce98":"markdown","d8c75411":"markdown","2fc57705":"markdown","01c6065e":"markdown","18355612":"markdown","b2899d3d":"markdown","3ce63dc7":"markdown","31863f5e":"markdown","9ae6388d":"markdown","118608ae":"markdown","1c04e453":"markdown","6e57a626":"markdown","980634d0":"markdown","d9256f29":"markdown","713c2dd4":"markdown","3fce8295":"markdown","8b5342d1":"markdown","a9d17e39":"markdown","a2e12d20":"markdown","95169e9d":"markdown","f1dceafe":"markdown","6b95c5dd":"markdown","ef060f29":"markdown","1237e61f":"markdown","5a5aa6ca":"markdown","d5434fed":"markdown","6620c0c7":"markdown","e020fe9d":"markdown","77e75bb0":"markdown","881d6501":"markdown","efa2b4a5":"markdown","3e9ff529":"markdown","1156c46c":"markdown","1c7473b2":"markdown","c8d308d3":"markdown","986f15a0":"markdown","992a9a1c":"markdown","f2d19f3d":"markdown","9dbeca35":"markdown","a39e6e8a":"markdown","e74c0ebf":"markdown","0645e25b":"markdown","3d25bf88":"markdown"},"source":{"e5c74394":"# %load_ext autoreload\n# %autoreload 2\n\n# Import libraries\nimport pandas as pd\nimport re\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom sklearn.tree import DecisionTreeClassifier, plot_tree\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.model_selection import train_test_split, cross_val_score\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, confusion_matrix\nimport seaborn as sns\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\nfrom sklearn.feature_selection import SelectKBest\nfrom sklearn.feature_selection import f_classif, chi2\nfrom sklearn.metrics import roc_curve, auc\nfrom sklearn.linear_model import LogisticRegression\nimport statsmodels.api as sm\nfrom mlxtend.feature_selection import ExhaustiveFeatureSelector as EFS\nfrom sklearn.tree import export_graphviz\nfrom IPython.display import Image\nfrom subprocess import call\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nimport os\nimport sys\nsys.path.insert(0, os.path.abspath('..\/'))\nfrom visualize_py import plot_confusion_matrix, plot_roc_curve, plot_feature_importance, \\\n    plot_feature_importance_log, plot_feature_importance_dec, plotVar, plotAge, plotContinuous, plotCategorical\nfrom IPython.core.display import HTML as Center\n\nCenter(\"\"\" <style>\n.output_png {\n    display: table-cell;\n    text-align: center;\n    vertical-align: middle;\n}\n<\/style> \"\"\")","4e169a45":"# Import data\ndf = pd.read_csv('..\/input\/uci-heart-disease-data-set\/processed.cleveland.data', header = None, \n                 names = ['age', 'sex', 'chest_pain_type', 'rest_blood_press', 'cholesterol',\n                          'fasting_blood_sugar', 'rest_ecg', 'max_heart_rate', \n                          'exer_ind_angina', 'st_depression', 'st_slope',                                                                                                         'num_major_vessels', 'thallium_scint', 'ca_disease'], \n                 index_col=None, usecols = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \n                 sep=',', skipinitialspace=True)\ndf.head(20)\nprint(df.shape)","85c4bc29":"# Type of data\nprint(df.info())","32f9886d":"# Find out what types of data is stored in object column. Use simple regex. Leading number omitted not catered for.\n# Future improvement.\nr = re.compile(r'\\d+[.,]\\d*')\ndf.num_major_vessels.apply(lambda x: bool(r.match(x))).value_counts()\ndf.thallium_scint.apply(lambda x: bool(r.match(x))).value_counts()\n\ndf.loc[df.num_major_vessels.apply(lambda x: bool(r.match(x))) == False]\ndf.loc[df.thallium_scint.apply(lambda x: bool(r.match(x))) == False]","41a65cc2":"# Replace all non numeric data with NaN, convert strings to numbers.\ndf_clean = df.apply(pd.to_numeric, errors='coerce')","ca4d4d52":"# Number of null values\nprint(df_clean.isnull().sum())\n\n# Actual null values\ndf_clean[df_clean.isnull().any(axis=1)]","42a56826":"df_fin = df_clean.copy()\nmedian = df_fin['num_major_vessels'].median()\ndf_fin['num_major_vessels'].fillna(median, inplace=True)\nprint(\"Number of null values in num_major_vessels column: {}\".format(df_fin['num_major_vessels'].isnull().sum()))\n\nmedian = df_fin['thallium_scint'].median()\ndf_fin['thallium_scint'].fillna(median, inplace=True)\nprint(\"Number of null values in thallium_scint column: {}\".format(df_fin['thallium_scint'].isnull().sum()))\nprint(\"Dataframe dimension: {}\".format(df_fin.shape))","80a39919":"print(df_fin.nunique())","91681164":"# Extract categorical variables for analysis.\ndf_fin_cat = df_fin.copy()\nnames_cat = ('sex', 'chest_pain_type', 'fasting_blood_sugar', 'rest_ecg', 'exer_ind_angina', 'st_slope',\n             'num_major_vessels', 'thallium_scint', 'ca_disease')\ndf_fin_cat = df_fin_cat.loc[:, names_cat]\n\n# Extract continuous variables for analysis.\n#df_fin.reset_index(drop=True, inplace=True)\ndf_fin_con = df_fin.copy()\nnames_con = ('age', 'rest_blood_press', 'cholesterol', 'max_heart_rate', 'st_depression')\ndf_fin_con = df_fin_con.loc[:, names_con]\n\n# Plotting label dictionary\nplot_cat = [('sex', ['female', 'male']),\n              ('chest_pain_type', ['typical angina', 'atypical angina', 'non-anginal pain', 'asymptomatic']),\n              ('fasting_blood_sugar', ['fbs > 120mg', 'fbs < 120mg']),\n              ('rest_ecg', ['normal', 'ST T-wave', 'left ventricular']),\n              ('exer_ind_angina', ['yes', 'no']),\n              ('st_slope', ['upsloping', 'flat', 'downsloping']),\n              ('num_major_vessels', ['0', '1', '2', '3']),\n              ('thallium_scint', ['normal', 'fixed defect', 'reversible defect']),\n              ('ca_disease', ['No CA disease', 'CA disease'])]\nplot_con = [('age', 'age in years'),\n            ('rest_blood_press', 'blood pressure in mm Hg'),\n              ('cholesterol', 'serum cholesterol in mg\/d'),\n              ('max_heart_rate', 'maximum heart rate achieved'),\n              ('st_depression', 'ST depression by exercise relative to rest'),\n              ('ca_disease', 'Coronary Artery disease')]\n\n# Extract numeric variables for analysis.\ndf_fin.reset_index(drop=True, inplace=True)\ndf_fin_num = df_fin.copy()\nnames_num = ('age', 'sex', 'chest_pain_type', 'rest_blood_press', 'cholesterol', 'fasting_blood_sugar', 'rest_ecg',\n             'max_heart_rate', 'exer_ind_angina', 'st_depression', 'st_slope', 'num_major_vessels', 'thallium_scint',\n             'ca_disease')\ndf_fin_num = df_fin_num.loc[:, names_num]","fd82d52a":"#outcome_counts = df_fin_cat.groupby('ca_disease').size()\noutcome_counts = df_fin_cat['ca_disease'].value_counts()\nprint(outcome_counts)\n\n# Plot outcome counts.\nax = sns.barplot(x=outcome_counts.index, y=outcome_counts.values, alpha=0.9)\nax.xaxis.label.set_size(20)\nax.yaxis.label.set_size(20)\n#ax.title.set_size(45)\nax.tick_params('y', labelsize = 20);\nax.tick_params('x', labelsize = 20);\nplt.title('Frequency Distribution of Outcomes', fontsize=20)\nplt.ylabel('Number of Occurrences')\nplt.xlabel('Outcome')\nplt.show();","8a647fa4":"# Transform y variable\ndf_fin_cat['num_bin'] = df_fin['ca_disease'].apply(lambda x: 1 if x > 0 else 0)\n\noutcome_counts_bin = df_fin_cat['num_bin'].value_counts()\nprint(outcome_counts_bin)\nax = sns.barplot(x=outcome_counts_bin.index, y=outcome_counts_bin.values)\nax.xaxis.label.set_size(20)\nax.yaxis.label.set_size(20)\n#ax.title.set_size(45)\nax.tick_params('y', labelsize = 20);\nax.tick_params('x', labelsize = 20);\nplt.title('Frequency Distribution of Outcomes', fontsize = 20)\nplt.ylabel('Number of Occurrences')\nplt.xlabel('Outcome')\nplt.show();","2c6c022b":"# Class level counts for categorical variables.\nfor variable in names_cat:\n    print(df_fin_cat[variable].value_counts())","be8b9c91":"# Bar chart plot of categorical variables.\nfig, ax = plt.subplots(3, 3, figsize=(25, 20));\nfor variable, subplot in zip(names_cat, ax.flatten()):\n    subplot.xaxis.label.set_size(34)\n    subplot.yaxis.label.set_size(34)\n    subplot.tick_params('y', labelsize = 30);\n    subplot.tick_params('x', labelsize = 30);\n    cp = sns.countplot(x=df_fin_cat[variable], ax=subplot);\nplt.tight_layout()","72a1931b":"# Continuous density plot\ndf_fin_num['ca_disease'] = df_fin_num['ca_disease'].apply(lambda x: 1 if x > 0 else 0)\n\nfig_age, axes = plt.subplots(nrows=1, ncols=1, figsize=(10, 6), squeeze=False)\n_ = plotAge(df=df_fin_num, axes=axes, single_plot=True);","ecea5e7c":"# 5 number summary.\ndf_fin_con.describe()","3a496d3b":"# Continuous density plot\n#df_fin_num['ca_disease'] = df_fin_num['ca_disease'].apply(lambda x: 1 if x > 0 else 0)\n\nfig_continuous, axes = plt.subplots(nrows=len(plot_con)-1, ncols=2, figsize=(15, 22))\n_ = plotVar(isCategorical=False, categorical = plot_cat, continuous = plot_con, df=df_fin_num, axes=axes);","0182f384":"for variable in names_con:\n    skew = df_fin_con[variable].skew()\n    print(\"Skewness value for {}: {}\".format(variable, skew))","f71f9b07":"# Boxplot of continuous variables\nmedianprops = {'color': 'magenta', 'linewidth': 2}\nboxprops = {'color': 'black', 'linestyle': '-', 'linewidth': 4}\nwhiskerprops = {'color': 'black', 'linestyle': '-', 'linewidth': 4}\ncapprops = {'color': 'black', 'linestyle': '-', 'linewidth': 4}\nflierprops = {'color': 'black', 'marker': 'x', 'markersize': 25}\n\n_ = df_fin_con.plot(kind='box', subplots=True, figsize=(35, 25), layout=(2,3), fontsize = 50, medianprops=medianprops,\n                    boxprops=boxprops, whiskerprops=whiskerprops, capprops=capprops, flierprops=flierprops);\n\n_ = plt.tight_layout();\n_ = plt.show();","21e08aa1":"# Transform y variable\ndf_fin['ca_disease'] = df_fin['ca_disease'].apply(lambda x: 1 if x > 0 else 0)\n\n# Copy original dataset\ndf_fin_nn = df_fin.copy()\n\n# Group response values to form binary response\ny = df_fin_nn.loc[:, 'ca_disease']\n\n# Split data into features (X) and response (y)\nX = df_fin_nn.loc[:, ('age', 'sex', 'chest_pain_type', 'rest_blood_press', 'cholesterol', 'fasting_blood_sugar', 'rest_ecg', 'max_heart_rate', 'exer_ind_angina', 'st_depression', 'st_slope',\n                   'num_major_vessels', 'thallium_scint')]\n\nX.head()\n\n# Put the response y into an array\ny = np.ravel(y)","1903fb98":"X_train_init, X_test_init, y_train_init, y_test_init = train_test_split(X, y, random_state=0)","fba3190d":"print('Percentage holdout data: {}%'.format(round(100*(len(X_test_init)\/len(X)),0)))","c93ba0b0":"# Initial model\nlogreg = LogisticRegression(max_iter=2000000, fit_intercept = False)\n\n# Probability scores for test set\ny_score_init = logreg.fit(X_train_init, y_train_init).decision_function(X_test_init)\n\n# False positive Rate and true positive rate\nfpr_roc, tpr_roc, thresholds = roc_curve(y_test_init, y_score_init)\n\nplot_roc_curve(fpr = fpr_roc, tpr = tpr_roc)","2a3f865e":"y_pred = logreg.predict(X_test_init)\n# Accuracy before model parameter optimisation\ncnf_matrix = confusion_matrix(y_pred, y_test_init)\nplot_confusion_matrix(cnf_matrix, classes=[0,1], normalize=True)","696abc28":"# Transform thallium_scint variable\ntrans_thal = {3:0, 7:1, 6:2}\ndf_fin_nn = df_fin.replace({\"thallium_scint\": trans_thal})\nfeature_names = ('age', 'sex', 'chest_pain_type', 'rest_blood_press', 'cholesterol', 'fasting_blood_sugar', 'rest_ecg',\n                 'max_heart_rate', 'exer_ind_angina', 'st_depression', 'st_slope', 'num_major_vessels', 'thallium_scint')\n\n# Re-extract transformed X features\nX = df_fin_nn.loc[:, feature_names]\n\n\n# Rebuild training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)\n\n# Create variables for Random Forest model\nX_train_rf = X_train.copy()\nX_test_rf = X_test.copy()\ny_train_rf = y_train.copy()\ny_test_rf = y_test.copy()\n\n# Scale data\nscaler = StandardScaler()\n\n# Fit on training data set\nscaler.fit(X_train)\nX_train = scaler.transform(X_train)\n\n# Apply to test data\nX_test = scaler.transform(X_test)","1e365603":"# Initial model\nlogreg = LogisticRegression(fit_intercept = False)\n\n# Probability scores for test set\ny_score = logreg.fit(X_train, y_train).decision_function(X_test)\n\n# False positive Rate and true positive rate\nfpr_roc, tpr_roc, thresholds = roc_curve(y_test, y_score)\n\nplot_roc_curve(fpr = fpr_roc, tpr = tpr_roc)","97d70340":"y_pred = logreg.predict(X_test)\n# Accuracy before model parameter optimisation\ncnf_matrix = confusion_matrix(y_pred, y_test)\nplot_confusion_matrix(cnf_matrix, classes=[0,1], normalize=True)","3ed7eaa5":"# Pearson correlation plot.\ncorrelations = df_fin_con.corr()\n# Plot correlation matrix\n#sns.set(font_scale=1);\nfig = plt.figure(figsize=(15, 15))\nax = sns.heatmap(correlations, annot=True, linewidths = 0, vmin=-.5, cmap='pink_r')\nax.xaxis.label.set_size(15)\nax.yaxis.label.set_size(15)\n#ax.title.set_size(45)\nax.tick_params('y', labelsize = 15, labelrotation=0);\nax.tick_params('x', labelsize = 15);","055ae9eb":"# Extract continuous and categorical variables for analysis.\nX_con = df_fin_con.copy()\nX_cat = df_fin_cat.loc[:,('sex', 'chest_pain_type', 'fasting_blood_sugar', 'rest_ecg', 'exer_ind_angina', 'st_slope', 'num_major_vessels', 'thallium_scint')]\n\nX_train_con, X_test_con, y_train_con, y_test_con = train_test_split(X_con, y, random_state=0)\nX_train_cat, X_test_cat, y_train_cat, y_test_cat = train_test_split(X_cat, y, random_state=0)\n\nlog_reg = sm.Logit(y_train_con, X_train_con)\nlog_result = log_reg.fit()\n\nprint(log_result.summary2())\nfeatures_con = np.array(names_con)\nplot_feature_importance_log(fit = log_result, features = features_con)","8a7c2050":"logval = LogisticRegression(fit_intercept = False)\n\nefs1 = EFS(logval,\n           min_features=1,\n           max_features=1,\n           scoring='accuracy',\n           print_progress=True,\n           cv=5)\n\nefs1 = efs1.fit(X_train, y_train, custom_feature_names=feature_names)\n\nprint('Best accuracy score: %.2f' % efs1.best_score_)\nprint('Best subset (indices):', efs1.best_idx_)\nprint('Best subset (corresponding names):', efs1.best_feature_names_)\n\n#efs1 = efs1.fit(X, y, custom_feature_names=feature_names)\n\ndf_efs = pd.DataFrame.from_dict(efs1.get_metric_dict()).T\ndf_efs.sort_values('avg_score', inplace=True, ascending=False)\n\nmetric_dict = efs1.get_metric_dict()\n\nfig = plt.figure()\nk_feat = sorted(metric_dict.keys())\navg = [metric_dict[k]['avg_score'] for k in k_feat]\n\nupper, lower = [], []\nfor k in k_feat:\n    upper.append(metric_dict[k]['avg_score'] +\n                 metric_dict[k]['std_dev'])\n    lower.append(metric_dict[k]['avg_score'] -\n                 metric_dict[k]['std_dev'])\n\nplt.fill_between(k_feat,\n                 upper,\n                 lower,\n                 alpha=0.2,\n                 color='blue',\n                 lw=1)\n\n_ = plt.plot(k_feat, avg, color='blue', marker='o');\n_ = plt.ylabel('Accuracy +\/- Standard Deviation', size = 15)\n_ = plt.xlabel('Feature', size = 15)\nfeature_min = len(metric_dict[k_feat[0]]['feature_idx'])\nfeature_max = len(metric_dict[k_feat[-1]]['feature_idx'])\n_ = plt.xticks(k_feat,\n           [str(metric_dict[k]['feature_names']) for k in k_feat],\n           rotation=90, size = 15)\n_ = plt.yticks(size = 15)\nplt.show();\n\ndf_efs","d84edb7c":"# Feature extraction set to retain all - we want to see scores for all variables.\ntest = SelectKBest(score_func=f_classif, k=5)\nfit_kbest = test.fit(X_train_con, y_train_con)\nfeatures_kbest = np.array(X_con.columns)\nplot_feature_importance(fit = fit_kbest, features = features_kbest)","46581051":"test_cat = SelectKBest(score_func=chi2, k='all')\nfit_kbest_cat = test_cat.fit(X_train_cat, y_train_cat)\nfeatures_kbest_cat = np.array(X_cat.columns)\nplot_feature_importance(fit = fit_kbest_cat, features = features_kbest_cat)","707f09a3":"# Fit a Decision Tree to data - perform cross validation to obtain optimum value for hyperparameter used for pruning.\nsamples = [sample for sample in range(1,30)]\nvalidation_scores = []\nfor sample in samples:\n    classifier1 = DecisionTreeClassifier(random_state=1, min_samples_leaf=sample)\n    score = cross_val_score(estimator=classifier1, X=X_train_rf, y=y_train_rf, cv=5)\n    validation_scores.append(score.mean())\n\n# Obtain the minimum leaf samples with the highest validation score\nsamples_optimum = samples[validation_scores.index(max(validation_scores))]\n\n# Create final classifier\nclassifier2 = DecisionTreeClassifier(random_state=0, min_samples_leaf=samples_optimum)\nclassifier2 = classifier2.fit(X_train_rf, y_train_rf)\n\n# Probability scores for test set\ny_pred_rf = classifier2.predict(X_test_rf)\n\n# False positive Rate and true positive rate\nfpr_roc, tpr_roc, thresholds = roc_curve(y_test_rf, y_pred_rf)\nplot_roc_curve(fpr = fpr_roc, tpr = tpr_roc)","4c04887a":"cnf_matrix = confusion_matrix(y_pred_rf, y_test_rf)\nplot_confusion_matrix(cnf_matrix, classes=[0,1], normalize=True)","64e7f0c3":"importances = np.array(classifier2.feature_importances_)\nfeature_list = np.array(X.columns)\nplot_feature_importance_dec(fit = importances, features = feature_list)","d4f43b55":"# Show the first few levels of the tree\n_ = export_graphviz(classifier2, out_file='tree.dot',\n                feature_names = X.columns,\n                class_names = ['No CAD', 'CAD'],\n                rounded = True, proportion = True,\n                label='root',\n                precision = 2, filled = True);","87200aaf":"_ = call(['dot', '-Tpng', 'tree.dot', '-o', 'tree.png', '-Gdpi=600'])\nImage(filename = 'tree.png')","3a5c96c6":"rand_forest = RandomForestClassifier(max_features=0.25, n_estimators=1000, criterion= 'gini',\n                                     random_state=0)\nrand_forest.fit(X_train_rf, y_train_rf)\n\n# Probability scores for test set\ny_pred_rf = rand_forest.predict(X_test_rf)\n\n# False positive Rate and true positive rate\nfpr_roc, tpr_roc, thresholds = roc_curve(y_test_rf, y_pred_rf)\nplot_roc_curve(fpr = fpr_roc, tpr = tpr_roc)","45668946":"cnf_matrix = confusion_matrix(y_pred_rf, y_test_rf)\nplot_confusion_matrix(cnf_matrix, classes=[0,1], normalize=True)","47342cc9":"importances = np.array(rand_forest.feature_importances_)\nfeature_list = np.array(X.columns)\nplot_feature_importance_dec(fit = importances, features = feature_list)","c7f4ce9b":"estimator = rand_forest.estimators_[1]\n\n# Show the first few levels of the tree\n_ = export_graphviz(estimator, out_file='tree.dot',\n                feature_names = X.columns,\n                class_names = ['No CAD', 'CAD'],\n                rounded = True, proportion = True,\n                label='root',\n                precision = 2, filled = True);","c93a25c9":"_ = call(['dot', '-Tpng', 'tree.dot', '-o', 'tree.png', '-Gdpi=600'])\nImage(filename = 'tree.png')","6c5d9774":"# Extract continuous and categorical variables for analysis.\nX_fin_cat = df_fin_cat.loc[:,('sex', 'chest_pain_type', 'exer_ind_angina', 'st_slope', 'num_major_vessels', 'thallium_scint')]\nX_fin_con = df_fin_con.loc[:,('max_heart_rate', 'st_depression')]\nX_final = pd.concat([X_fin_cat, X_fin_con], axis=1)\n\nX_train_fin, X_test_fin, y_train_fin, y_test_fin = train_test_split(X_final, y, random_state=0)\n\n# Scale data\nscaler = StandardScaler()\n\n# Fit on training data set\nscaler.fit(X_train_fin)\nX_train_fin = scaler.transform(X_train_fin)\n\n# Apply to test data\nX_test_fin = scaler.transform(X_test_fin)\n\n# Final model\nlogfin = LogisticRegression(fit_intercept = False)\n\n# Probability scores for test set\ny_score_fin = logfin.fit(X_train_fin, y_train_fin).decision_function(X_test_fin)\n\n# False positive Rate and true positive rate\nfpr_roc, tpr_roc, thresholds = roc_curve(y_test_fin, y_score_fin)\n\nplot_roc_curve(fpr = fpr_roc, tpr = tpr_roc)","9561409e":"y_pred_fin = logfin.predict(X_test_fin)\n# Accuracy before model parameter optimisation\ncnf_matrix = confusion_matrix(y_pred_fin, y_test_fin)\nplot_confusion_matrix(cnf_matrix, classes=[0,1], normalize=True)","ab667afb":"# Fit and check MSE before regularisation\nreg = MLPClassifier(max_iter=50000, solver=\"adam\", activation=\"tanh\", hidden_layer_sizes=(5, 5), random_state=1)\nreg.fit(X_train_fin, y_train_fin)\n\n# Predict\ny_pred_fin = reg.predict(X_test_fin)\n\n# Accuracy before model parameter optimisation\naccuracy_score(y_pred_fin, y_test_fin)","5ce6adbd":"# Optimise numbers of nodes on both layers\nvalidation_scores = {}\nprint(\"Nodes |Validation\")\nprint(\"      | score\")\n\nfor hidden_layer_size in [(i,j) for i in range(3,6) for j in range(3,6)]:\n\n    reg = MLPClassifier(max_iter=1000000, hidden_layer_sizes=hidden_layer_size, random_state=1)\n\n    score = cross_val_score(estimator=reg, X=X_train_fin, y=y_train_fin, cv=2)\n    validation_scores[hidden_layer_size] = score.mean()\n    print(hidden_layer_size, \": %0.5f\" % validation_scores[hidden_layer_size])","31b46364":"# Check scores\nprint(\"The highest validation score is: %0.4f\" % max(validation_scores.values()))\noptimal_hidden_layer_size = [name for name, score in validation_scores.items()\n                              if score==max(validation_scores.values())][0]\nprint(\"This corresponds to nodes\", optimal_hidden_layer_size )","a9009b5a":"# Select range over which to find regularisation parameter - exponential used for even distribution of values\nreg_par = [np.e**n for n in np.arange(-2,4,0.5)]\n\nvalidation_scores = {}\nprint(\" alpha  |  Accuracy\")\nfor param in reg_par:\n    reg = MLPClassifier(max_iter=1000000, solver=\"adam\", activation=\"tanh\", hidden_layer_sizes=optimal_hidden_layer_size, alpha=param,\n                        random_state=1)\n    score = cross_val_score(estimator=reg, X=X_train_fin, y=y_train_fin, cv=2, scoring=\"accuracy\")\n    validation_scores[param] = score.mean()\n    print(\"%0.5f |  %s\" % (param, score.mean()))\n\n# Plot the accuracy function against regularisation parameter\nplt.plot([np.log(i) for i in validation_scores.keys()], list(validation_scores.values()));\nplt.xlabel(\"Ln of alpha\");\nplt.ylabel(\"Accuracy\");","6f23f055":"max_score = ([np.log(name) for name, score in validation_scores.items() if score==max(validation_scores.values())][0])\n\n# Find lowest value.\nprint(\"The highest accuracy score is: %s\" % (max(validation_scores.values())))\nprint(\"This corresponds to regularisation parameter e**%s\" % max_score)","ebdc3954":"# Fit data with the best parameter\nreg = MLPClassifier(max_iter=1000000, solver=\"adam\", activation=\"tanh\", hidden_layer_sizes=optimal_hidden_layer_size,\n                    alpha=np.e**(2), random_state=1)\n\nreg.fit(X_train_fin, y_train_fin)\n\n# Predict\ny_pred = reg.predict(X_test_fin)\n\n# Accuracy after model parameter optimisation\naccuracy_score(y_pred_fin, y_test_fin)","57b774d4":"# Create X_design_vec, which contains the median of each respective column\nX_design = X_final.copy()\nX_design_vec = pd.DataFrame(X_design.median()).transpose()\nX_design_vec.head()","d6a583cf":"names_num = ('sex', 'chest_pain_type', 'max_heart_rate', 'exer_ind_angina', 'st_depression', 'st_slope', 'num_major_vessels', 'thallium_scint')\n\nfor variable in names_num:\n    # Set up a sequence for response variable to plot\n    min_res = min(X.loc[:,variable])\n    max_res = max(X.loc[:,variable])\n    seq = np.linspace(start=min_res,stop=max_res,num=50)\n\n    # Set up a list of moving resultants to plot\n    to_predict = []\n    for result in seq:\n        X_design_vec.loc[0,variable] = result\n        to_predict.append(X_design_vec.copy())\n\n    # Convert back to dataframe\n    to_predict = pd.concat(to_predict)\n\n    # Scale and predict\n    to_predict = scaler.transform(to_predict)\n    predictions = reg.predict_proba(to_predict)\n\n    # Plot\n    _ = plt.plot(seq,predictions[:,1])\n    _ = plt.xlabel(variable)\n    _ = plt.ylabel(\"ca_disease\")\n    _ = plt.title(\"ca_disease vs \" + variable)\n    plt.show();","e898dc55":"# False positive Rate and true positive rate\nfpr_roc, tpr_roc, thresholds = roc_curve(y_test, y_pred)\nplot_roc_curve(fpr = fpr_roc, tpr = tpr_roc)","a94c4545":"cnf_matrix = confusion_matrix(y_pred, y_test)\nplot_confusion_matrix(cnf_matrix, classes=[0,1], normalize=True)","499e56c1":"The Random Forest plot is interesting to analyse. Visually one can observe that ca disease (blue nodes) is evenly\nspread throughout the leave nodes of the entire tree. A large proportion of the early ca disease nodes occur for\nindividuals with maximum heart rate < 150 and cholesterol >210. From here if ST depression >0.8 and one is male around\n20% of the overall population is classified as having ca disease.\nLikewise, a large proportion of the population with max heart rate >150 and chest pain < 3.5 is classified as not\nhaving ca disease (orange nodes).\nAnother interesting factor is that Thallium Scintography is reported as the second most important feature. It does \nhowever not feature strongly in the Decision Tree. It is likely that strong cross-correlation with other strong \nfeatures such as maximum heart rate causes the Thallium feature to only surface as a confirmatory feature at lower \nlevels in the tree.","f08ff400":"The accuracy results indicate that even though 5 variables were dropped, the model accuracy did not reduce by\na significant amount. We can therefore confidently deploy this model with the knowledge that it is both robust and\naccurate.","a3f959cd":"<div class=\"alert alert-block alert-info\">\n<b>Build Naive Model - Baseline<\/b>\n<\/div>","fdac3ad0":"# Feature selection \n### Exploratory analysis - determining most important features for prediction of CAD\n","f5271f72":"Our model is accurate enough to capture the directly proportionate relationship between several response variables\n(in order of strength of association, based on response curve output):\n\n- thallium_scint\n- num_major_vessels\n- st_slope\n- st_depression\n- exer_ind_angina\n- chest_pain_type\n- sex\n\nand the inversely proportional relationship between:\n\n- max_heart_rate\n\nand the outcome of confirmed Coronary Artery Disease. This is a positive outcome, as it means the model as applied\nto the validation dataset managed to capture the underlying signals in the data. We can therefore conclude that the\nmodel generalises well and that its accuracy is sufficiently high for this model to be used based on the features\ncaptured.\n\nThis makes sense if one takes into account that the first two variables:\n\n- thallium_scint: Arteries found to be: 1. Normal 2. Reversible defect and 3. Fixed defect\n- num_major_vessels: Number of major vessels (0-3) coloured by fluoroscopy\n\nare by nature close to the definition of Coronary Artery Disease itself.","d7b8ea43":"Scale and transform variables","e9db58dd":"All looks good here. No obvious issues with the data. The spread of the data is good for classification, as there are\na large number of positive cases. If one combines classes 1, 2, 3 and 4 as suggested there will be a fairly even split\nbetween positive and negative outcomes.\nLet us look at that.","8c1e98e8":"We now optimise the NN architecture.","8574bc49":"We start by looking at the number of unique records per variable.","ed797dd1":"Now let us consider the response variable.","cc52dc7d":"Split the data into training and test sets","da47ce98":"Let us see if that worked! We should now have only decimal and null values.","d8c75411":"The model has accuracy below 70% (ROC curve slope flatter than models thus far) and the feature importance results\nare not very convincing seeing as many values are missing. This model needs a bit more work. Interesting to note\nthat Thallium Scintograpy comes out very strongly even in this sub-optimal model.\nWe will next look at random forests to see if we can improve on the single tree's accuracy.","2fc57705":"For this analysis we use the Cleveland \"Coronary Artery Disease\" dataset found on the UCI Machine Learning Repository\nat the following location:\n\n<a href=https:\/\/archive.ics.uci.edu\/ml\/datasets\/Heart+Disease>Heart Disease Dataset<\/a>\n\nThe objective of the analysis is to use statistical learning to identify factors associated with Coronary Artery\nDisease as indicated by a coronary angiography interpreted by a Cardiologist.\n\nAccording to the paper: \n\n<a href=\"https:\/\/d1wqtxts1xzle7.cloudfront.net\/49612602\/0002-9149_2889_2990524-920161014-6139-keu7l8.pdf?1476513760=&response-content-disposition=inline%3B+filename%3DInternational_application_of_a_new_proba.pdf&Expires=1610647064&Signature=daWTqdYl7zeTBQ4brLNw51BESvOL0p9NBXtZ9uoIaK3uI~AmI6k8RhHVOSE~skIR~Dls~2ZU5Tbz3GHv9xYDXrAitpjjcfjeww71nioKHbneQDfCffuVBGsoQnKw8E6oltbJarfoNsUbmkU3nwYlNl1CUqqSHOAdrs9JACP6aXhFAuIEVME3LNlESARfF-ugEuB-W69geObdjPIaFt9VJKrf2~6wIi0hsX~f5jtnWgxIjXQ0AGTCQFJRVgKltN1eaMiY~S79hca8WZiSBbbFGKymvKYuQffBcMX3SaRh0b1f5kuusUEn3A0PL316Li1mcCS6nA1Z5bVwzwScz4TIrQ__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA\">International application of a new probability algorithm for the diagnosis of \ncoronary artery disease<\/a> \n\nby Detrano et al. (1989) the data represents data collected for 303 patients referred for\ncoronary angiography at the Cleveland Clinic between May 1981 and September 1984. The 13 independent\/ features\nvariables can be divided into 3 groups as follows:\n\nRoutine evaluation (based on historical data):\n* ECG at rest\n* Serum Cholesterol\n* Fasting blood sugar\n\nNon-invasive test data (informed consent obtained for data as part of research protocol):\n* Exercise ECG\n    * ST-segment peak slope (upsloping, flat or downsloping)\n    * ST-segment depression\n* Excercise Thallium scintigraphy (fixed, reversible or none)\n* Cardiac fluoroscopy (number of vessels appeared to contain calcium)\n\nOther demographic and clinical variables (based on routine data):\n* Age\n* Sex\n* Chest pain type\n* Systolic blood pressure\n* ST-T-wave abnormality (T-wave abnormality)\n* Probably or definite ventricular hypertrophy (Este's criteria)\n\nThe dependent\/ response variable was the angiographic test result indicating a >50% diameter narrowing.\n\nDetrano et al created 352 logistic regression models based on different combinations of the previously discussed\n13 variables. Depending on information available in the test dataset one of these models was applied during model\nvalidation.\n\nUnfortunately the the paper by (Detrano et al., 1989) does not publish extensive model accuracy results such as:\noverall accuracy, C-Statistic, precision (positive predictive value), recall (sensitivity) or specificity. The\nmodel was however validated on various external datasets which is very important. The positive predictive value\n(precision) is reported for a range of probability cut-off points for the various test sets. The various data sets\nhave widely varying prevalence (38% - 81%), and hence te positive predictive value likewise varies widely between the\nreported tests.\n\nFrom these results one can see that the model was capable of a Precision of approximately 75% for datasets closely\nmatching the Cleveland dataset in terms of disease prevalence within the test set.\n\nWe are going to replicate the analysis by performing a logistic regression and will perform a validation study to\nconfirm results obtained by (Detrano et al., 1989) in terms of model accuracy. Furthermore we will do an analysis of\nsignificance of the various logistic regression features as means of classifying feature importance.\n\nSubsequent to this analysis we will use an ensemble model (Random Forest) to create feature importance classifications\nto validate the regression findings. We will also apply our learnings to a Neural Network, to assess performance on\nthe smaller dataset i.e. after features selection has been applied.\n\nWe aim to achieve this by following the Machine Learning pipeline approach of deploying a variety of ML techniques to\nbuild a predictive model and analyse its results. In the process we hope to gain valuable insights. The various steps\nin the process are as follows (not necessarily in this order):\n\n- Load data\n- Prepare data\n    - Clean data\n        - Missing values\n        - Outliers\n        - Erroneous values\n    - Explore data\n        - Exploratory descriptive analysis (EDA)\n        - Correlation analysis\n        - Variable cluster analysis\n    - Transform Data\n        - Engineer features\n        - Encode data\n        - Scale & normalise data\n        - Impute data\n        - Feature selection\/ importance analysis\n- Build model\n    - Model selection\n    - Data sampling (validation strategy, imbalanced classification)\n    - Hyperparameter optimisation\n- Validate model\n    - Accuracy testing\n- Analysis of results\n    - Response curves\n    - Accuracy analysis\n    - Commentary\n\nLet us start the analysis!","01c6065e":"<div class=\"alert alert-block alert-info\">\n<b>Load data<\/b>\n<\/div>","18355612":"We now build and test a naive logistic regression model - without any transformations or optimisations.","b2899d3d":"As expected, we don't need to be concerned about imbalanced classes for this analysis.\n\nLet us now consider the categorical variables.","3ce63dc7":"We now build a logistic regression model with data scaled and transformed according to Exploratory Data Analysis\nresults num_major_vessels and exer_ind_angina also have very small confidence intervals and high accuracy scores.","31863f5e":"Plot response curves","9ae6388d":"What is notable in this analysis is the fact that age shows a higher significance here than for the previous test.\nThis is due to the fact that age and max_heart_rate are cross-correlated as seen from Pearson's cross correlation test -\nreported a bit later in this document. The strong correlation between max_heart_rate and ca_disease diminishes the\nimpact of age in multivariate tests. Univariate tests are better suited to this analysis for this reason.\n\nAlthough age does clearly have some value as a variable, and in general it is good to include in any regression\nanalysis due to the insights it brings, we will exclude it based on test results and levels of significance of other\nvariables being much greater and capturing the effect of age sufficiently. We later discuss a strategy for the inclusion\nof age at a later stage.\n\nWe will now consider the categorical variables. Again the SelectKBest method will be used again, but this time the\nChi-Squared function 'chi2' for categorical variables will be used. Let's see what the results are.","118608ae":"Given the similar levels of accuracy that both the Logistic and MLP models attained it will be up to clinical decision\nmakers to decide on the utility of these approaches. Given the confidence in the Gold Standard i.e. Angiography and the\nconsequences of incorrect diagnosis, in my mind it is unlikely that a test resulting in a sensitivity of approximately 90% or less will be considered as a replacement.\nAn understanding of the factors contributing to a positive Angiogram test would however assist clinicians in deciding\nwhen an Angiogram might be indicated and what the likely outcome would be. This could assist in early intervention,\nworkup and planning. As I understand it there are problems in some settings with too many Angiograms being performed which could result in poorer patient care and outcomes. \nThis analysis identified the 8 most important features to consider which are: thallium_scint, num_major_vessels,\nst_slope, st_depression, max_heart_rate, exer_ind_angina, chest_pain_type and sex.","1c04e453":"<div class=\"alert alert-block alert-info\">\n<b>Clean data<\/b>\n<\/div>","6e57a626":"<div class=\"alert alert-block alert-info\">\n<b>Build Model 2 - Multi-Layer Perceptron<\/b>\n<\/div>","980634d0":"No surprises here with regards to the continuous feature variables, similar observations to those made for the density\nand violin plots. We are dealing with an older population here with average age of 54 years old. There are a few\noutliers for high resting blood pressure with the distribution showing a slight skew to the right. Likewise for\ncholesterol and st_depression, with these two showing even higher skewness. Conversely max_heart_rate has outliers\nto left and slight skewness to left too. This makes sense, as higher values for the prior could indicate poorer\nhealth, whereas lower values for max_heart_rate could indicate poorer health, as observed in the violin plots.\n\nThe distributions of the feature variables have varying scales, so standardisation would be required for ML purposes.\nFor regression, normalisation might improve outcomes (for this investigation we will however not perform normalisatoin).\nInvestigation into outliers is recommended as it might reveal interesting facts and would improve the model performance\nif outliers were addressed.","d9256f29":"We now perform feature selection in order to ascertain whether a smaller parsimonious model could be built with fewer\nvariables. As per the article by (Detrano et al., 1989) this could be useful from a practical perspective as not all\nhealthcare settings have all the variables to their disposal which necessitates the deployment of several complex\npredictive models which is not practical from an operational perspective.\n\nWe will first perform correlation and regression tests on the data. These tests are best performed by considering\ncontinuous and categoric variables separately due to the intrinsic difference in regression coefficient values\nfor these variables. We will then perform a few numeric methods on the full dataset and compare results.\n\nWe start by considering the continuous variables.","713c2dd4":"We observe a modest improvement in accuracy for the model with the data minimally transformed and scaled.\nAlthough accuracy in itself probably does not warrant the transformation and scaling, model performance in terms of\nconvergence has improved by an order of magnitude as number of iterations required before convergence was previously\nlarger than 1000,000 and after the data has been scaled number of iterations reduced to less than 100 0000.","3fce8295":"We see that there is a very strong inverse correlation between maximum heart rate and age. This makes sense as one's\nmaximum heart typically decreases with age. We also see that there is a strong positive correlation between maximum\nheart rate and both cholesterol and resting blood pressure. This too makes sense as high blood pressure and cholesterol\nare typically indications poor health which would result in lower maximum heart rate.\nAnother observation of interest is the strong correlation between cholesterol and the depression induced by exercise in\nthe ECG during exercise. These variables could make strong combined predictors for a next iteration of the model.\nFor now we will continue with the variables as is and focus on feature selection.","8b5342d1":"There are no columns with only one value. We therefore retain all columns for ML purposes as there is enough\nvariability to warrant using the data. Interesting to observe that there is also a fair amount of similarity in\nthe cholesterol measurements which is surprising. There are many variables with fewer than 10 levels which\ncould be considered as categorical. Based on our initial assessment of the data we will work with levels of measurement\nfor the data as follows:\n\n- age (continuous)\n- sex (binary)\n- chest_pain_type (ordinal)\n- rest_blood_press (continuous)\n- cholesterol (continuous)\n- fasting_blood_sugar (binary)\n- rest_ecg (ordinal)\n- max_heart_rate (continuous)\n- exer_ind_angina (binary)\n- st_depression (continuous)\n- st_slope (ordinal)\n- num_major_vessels (ordinal)\n- thallium_scint (ordinal - needs reordering)\n- ca_disease (binary - we will need to transform as there are actually 5 levels in the data)\n\nAt this point it seems as if the only nominal data is binary, which means we might not need any One Hot Encoding\ninitially. We will leave the ordinal data as is for the initial analysis.\nNext we look at the distribution of the data.","a9d17e39":"Now we optimise neural network regularisation parameter","a2e12d20":"Looks great we have 6 null values, 4 in num_major_vessels and 2 in thallium_scint as expected. We can also observe\nthat none of the other fields contain any null values. Seeing as there are only a handful of these values and none\nin the response variable, it is not necessary to remove these records from the dataset at this stage.\n\nWe now have a dataset with 303 records and 14 numeric fields, as per the data dictionary, there are still 6 missing\nvalues in the 'num_major_vessels' and 'thallium_scint' fields though. Due to the low number of missing values and even\ndistribution of values in these fields (see explore analysis below) we will now substitute these with median values.","95169e9d":"From the output we observe that we have twelve numeric columns and two \"object\" columns. The data dictionary\nhowever specifies that all fields are numeric. This means that Python could not convert two numeric variables\n(num_major_vessels and thallium_scint) to numeric columns due to their contents being non-numeric. Let us investigate.","f1dceafe":"The data looks fine from a modelling perspective, apart from the fact that the 'thallium_scint' variable needs to be recoded.\nThe values are not coded in the correct order.\n\nNext, let us consider the continuous variables.\n\nWe start by looking at age patterns.","6b95c5dd":"MSE before model optimisation","ef060f29":"<div class=\"alert alert-block alert-info\">\n<b>Analysis of results<\/b>\n<\/div>","1237e61f":"The dataset read from csv file has 303 rows and 14 columns.\nThe data dictionary specified that 303 rows and 75 columns existed.\nWe therefore have the same number of rows as the data dictionary, but 61 fewer columns...\n\nWe were lucky that the data was already pre-processed, and this can be observed from the subset of data displayed\nappearing very clean. Hopefully not much further cleaning would be required.\n\nThe original field names were not very informative. We therefore renamed the fields based on information gathered\nfrom the article by Detrano et al.\n\nLet us explore the data!","5a5aa6ca":"We now build our final Logistic Regression model with the variables selected.","d5434fed":"The violin plots demonstrate that the distributions for age, maximum HR and ST depression differ between individuals\nwith and those without ca disease, whereas there is little difference in the distributions for resting BP and\ncholesterol.\n\nThe violin plot for age against coronary artery disease demonstrates that the age of individuals without ca disease is\nevenly spread between the ages of 40 and 65, with some younger patients below the age of 30, whereas individuals with\nca disease are mostly older, with a median age of approx 60 and few, if any, below 30 years of age.\n\nThe median maximum HR for individuals without ca disease is higher (\\~160) than for individuals with ca disease (\\~150),\nwith a narrower distribution around the mean, whereas individuals with ca disease have a skewed distribution towards\nlower maximum HR, with a larger proportion having max HR below 100 than healthy individuals.\n\nThe distribution for ST depression is starkly different, with individuals without ca disease having a median ST\ndepression of 0, with a narrow distribution around the mean, and a small proportion having ST depression between 1 and 2.\n\nIn contrast, individuals with ca disease follow a broader distribution around a median of ~1.5, with a substantial\nproportion of individuals with ST depression >2. Resting blood pressure and cholesterol do not appear to be\nsignificantly different between patients with and without ca disease, with both groups having similar median resting\nBP (around 125mmHg) and cholesterol (200-250) and roughly even spread around the point estimates. A small number of\nindividuals with ca disease have much higher resting BP of >200, whereas none of those without ca disease have a\nresting BP >200. However, this may not be statistically significant. Interestingly, some individuals without ca disease\nhave very high cholesterol (500-600).","6620c0c7":"It is clear that individuals suffering from coronary artery disease have a higher average age.","e020fe9d":"<div class=\"alert alert-block alert-info\">\n<b>Explore data<\/b>\n<\/div>","77e75bb0":"The first method we use is to compare the relative importance of logistic regression coefficient values for all our\ncontinuous variables. Scikit-learn does not implement feature importance measures for logistic regression. We\ntherefore make use of the statsmodel libraries' implementation.","881d6501":"<div class=\"alert alert-block alert-info\">\n<b>Build Logistic Regression - Release 2<\/b>\n<\/div>","efa2b4a5":"MSE after regularisation","3e9ff529":"<div class=\"alert alert-block alert-info\">\n<b>Build Logistic Regression - Release 1<\/b>\n<\/div>","1156c46c":"From this analysis it can be seen that the only variables of significance are max_heart_rate and st_depression.\nThe remainder of the variables will be rejected based on their coefficient sizes.\n\nNow we perform a univariate comparison between all the features. We use the mlxtend library for this. We fit a\nLogistic regression model to each variable in turn and study the accuracy obtained.","1c7473b2":"We can see that there are 4 non-numeric fields in num_major_vessels and 2 in thallium_scint. These values are all '?'.\nIt is a reasonable assumption that these are missing values from data entry due to the placeholder. We will therefore\nclean the data by replacing these values with NaN and converting all character values to decimal.","c8d308d3":"The highest cross-validation accuracy score and hence the value to use for the `alpha` parameter is as follows.","986f15a0":"We now extract data according levels of measurement first to ease analysis. We also rename the variables to enable\nease of interpretion.","992a9a1c":"Accuracy analysis","f2d19f3d":"<div class=\"alert alert-block alert-info\">\n<b>Conclusion<\/b>\n<\/div>","9dbeca35":"We can now build a Multi Layer Perceptron to compare with the Logistic Regression.","a39e6e8a":"num_major_vessels, thal_scint and exer_ind_angina are all extremely strong predictors. chest_pain_type, st_slope and\nsex also contribute to the overall classification. From this analysis the only non-significant variables are\nrest_ecg and fasting_blood_sugar.\n\nWe have now analysed continuous at categorical data separately from a statistical perspective.\nBefore we make the final decision on what variables to drop, we will now consider an ML technique for deriving feature\nimportance i.e. Decision Trees and Random Forests. Unlike the case of regression, we can analyse and draw conclusions\non continuous and categorical data together when using these algorithms as they are impervious to differences in\nvariable type. Another nice feature about Trees is that we don't have to standardise and normalise features which\nmakes visual analysis a lot more intuitive. We therefore use our initial untransformed dataset for this analysis.","e74c0ebf":"From this analysis we can see that there are a large number of very strong predictors in this set of variables.\nthallium_scint scores 77% for accuracy and has the smallest confidence interval. exer_ind_angina and num_major_vessels\nsimilarly have high accuracy and small confidence intervals. chest_pain_type and max_heart_rate also have very high\naccuracy scores.\n\nNext we will however make use of scikit-learn's native feature extraction methods - which also allow for Univariate\ntests. The Uni-variate Anova test on continuous variables as implemented in SelectKBest function 'f_classif' will\nbe used. Let's see what the results are.","0645e25b":"Now our set is finally ready for further analysis. We will now look at the distribution of variables and any possible\noutliers or heavy tailed distributions.","3d25bf88":"We start by splitting the response and the features."}}