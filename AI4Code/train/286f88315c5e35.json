{"cell_type":{"959fbaa5":"code","6271eece":"code","a7a08ce2":"code","b0e0de74":"code","468ee631":"code","b2a6bb28":"code","6a1d7497":"markdown","0c0db3bb":"markdown","df9ca74b":"markdown","2140619c":"markdown","a7493433":"markdown"},"source":{"959fbaa5":"# kaggle \uc7ac\uc124\uce58\n! pip uninstall kaggle -y\n! pip install kaggle==1.5.6\n\n# kaggle\uc5d0\uc11c \ub370\uc774\ud130 \ub2e4\uc6b4\ub85c\ub4dc\n! mkdir ~\/.kaggle\n! cp drive\/My\\ Drive\/Colab\\ Notebooks\/kaggle.json ~\/.kaggle\n\n! kaggle competitions download -c 2020-ai-air-pollution\n! unzip 2020-ai-air-pollution","6271eece":"# \ud30c\uc77c \uc5f4\uae30\ndata = pd.read_csv('air_pollution_train.csv', header=None, skiprows=1)\n\n# \ubd80\uc801\ud569 \ub370\uc774\ud130 drop\ndata = data.dropna()\ndata = np.array(data)\ndata = pd.DataFrame(data)\ndata[0] = data[0].astype(int)\ndata[1] = data[1].astype(int)\n\n# \ud559\uc2b5 \ub370\uc774\ud130 \uad6c\uc131\n# \ucd1d 6\uac00\uc9c0\uc758 y\ub97c \uad6c\ud574\uc57c \ud558\ubbc0\ub85c y_train\uc744 \ub9ac\uc2a4\ud2b8\ub85c \uad6c\ud604\ud558\uc5ec \uac01\uac01 \uc800\uc7a5\nx_train = data.loc[:, 0:1]\ny_train = [] # so2, co, o3, no2, pm10, pm2.5\nfor i in range(2, 8):\n  y_temp = data.loc[:, i]\n  y_temp = np.array(y_temp)\n  y_temp = torch.FloatTensor(y_temp)\n  y_train.append(y_temp)\n\nx_train = np.array(x_train)\nx_train = torch.FloatTensor(x_train)","a7a08ce2":"import pandas as pd\nimport numpy as np\n\nimport torch\nimport torch.optim as optim\n\ntorch.manual_seed(777)","b0e0de74":"minw = [0, 0, 0, 0, 0, 0] # \ucd5c\uc18c\uc758 cost\ub97c \uac00\uc9c8 \ub54c\uc758 W\nminb = [0, 0, 0, 0, 0, 0] # \ucd5c\uc18c\uc758 cost\ub97c \uac00\uc9c8 \ub54c\uc758 b\nlr = [1e-7, 1e-7, 1e-7, 1e-7, 1e-5, 1e-5] # \uac01 \uc218\uce58\uc758 learning rate\ntotal_epochs = [1500, 1500, 1500, 1500, 1000, 1000] # \uac01 \uc218\uce58\uc758 epoch\nprint_per_epoch = [i \/ 10 for i in total_epochs] # \uac01 \uc218\uce58\uc758 \ud559\uc2b5 \uc9c4\ud589\ub3c4\ub97c \ub098\ud0c0\ub0b4\ub824 \ub530\ub85c \ub9cc\ub4e0 \ubcc0\uc218","468ee631":"# \uac74\ub108 \ub6f0\uc5b4\ub3c4 \ub418\ub294 \uc218\uce58\uc758 \uc778\ub371\uc2a4 \uc800\uc7a5\nskiptype = []\n\nfor pollution_type in range(6):\n  # 0 ~ 5 : SO2, CO, O3, NO2, PM10, PM2.5\n\n  if pollution_type in skiptype:\n    continue\n\n  minw[pollution_type] = 0\n  minb[pollution_type] = 0\n\n\n  W = torch.zeros((2, 1), requires_grad=True)\n  b = torch.zeros(1, requires_grad=True)\n  optimizer = optim.SGD([W, b], lr=lr[pollution_type])\n\n  mincost = 1e10 # cost \ucd5c\uc19f\uac12\n\n    # \uc2dc\uc791 \ub85c\uadf8 \ucd9c\ub825\n  if pollution_type == 0:   print('Start training SO2')\n  elif pollution_type == 1: print('Start training CO')\n  elif pollution_type == 2: print('Start training O3')\n  elif pollution_type == 3: print('Start training NO2')\n  elif pollution_type == 4: print('Start training PM10')\n  elif pollution_type == 5: print('Start training PM2.5')\n\n  for epoch in range(total_epochs[pollution_type] + 1):\n\n    hypothesis = x_train.matmul(W) + b\n    cost = torch.mean((hypothesis - y_train[pollution_type]) ** 2)\n\n    # cost\uac00 \uc815\uc0c1\uc801\uc778 \uac12\uc774\uace0, \ud604\uc7ac cost\uac00 \uae30\uc874 cost\ubcf4\ub2e4 \uc791\uc544\uc9c0\uba74\n    # mincost, minw, minb\ub97c \uac31\uc2e0\n    if cost != np.nan and cost < mincost:\n      mincost = cost\n      minw[pollution_type] = W\n      minb[pollution_type] = b\n\n    optimizer.zero_grad()\n    cost.backward()\n    optimizer.step()\n\n    if epoch % print_per_epoch[pollution_type] == 0:\n      print('Epoch {:6d}\/{} , cost = {}'.format(epoch, total_epochs[pollution_type], cost.item()))","b2a6bb28":"x_test = pd.read_csv('air_pollution_test.csv', header=None, skiprows=1)\nx_test = np.array(x_test)\nx_test = torch.FloatTensor(x_test)\n\npredict = []\nfor i in range(6):\n  predict.append(x_test.matmul(minw[i]) + minb[i])\n\nsub = pd.read_csv('air_pollution_submission.csv', header=None, skiprows=1)\n\nsub[1] = sub[1].astype(float)\nsub[2] = sub[2].astype(float)\nsub[3] = sub[3].astype(float)\nsub[4] = sub[4].astype(float)\nsub[5] = sub[5].astype(float)\nsub[6] = sub[6].astype(float)\n\nsub = np.array(sub)\n\nfor i in range(len(sub)):\n  sub[i][1] = predict[0][i]\n  sub[i][2] = predict[1][i]\n  sub[i][3] = predict[2][i]\n  sub[i][4] = predict[3][i]\n  sub[i][5] = predict[4][i]\n  sub[i][6] = predict[5][i]\n\nfor i in range(6):\n  predict[i] = predict[i].detach().numpy().reshape(-1, 1)\n\nid = np.array([i for i in range(len(x_test))]).reshape(-1, 1)\nresult = np.hstack([id, predict[0], predict[1], predict[2], predict[3], predict[4], predict[5]])\n\nsub = pd.DataFrame(result, columns=[\"Id\", \"SO2\", \"CO\", \"O3\", \"NO2\", \"PM10\", \"PM2.5\"])\nsub['Id'] = sub['Id'].astype(int)\n\nsub\nsub.to_csv('baseline.csv', index=False)","6a1d7497":"\ud559\uc2b5","0c0db3bb":"import","df9ca74b":"\uc0ac\uc6a9\ud560 \ub370\uc774\ud130 \uc120\uc5b8 & \ucd08\uae30\ud654","2140619c":"\uc81c\ucd9c \uc591\uc2dd\uc5d0 \ub530\ub77c \uc608\uce21\uac12 \uc0bd\uc785 \ud6c4 \ubca0\uc774\uc2a4\ub77c\uc778 \ud30c\uc77c \uad6c\uc131","a7493433":"kaggle \uc7ac\uc124\uce58 & \ub370\uc774\ud130 \ub2e4\uc6b4\ub85c\ub4dc"}}