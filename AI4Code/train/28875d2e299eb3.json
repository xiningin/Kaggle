{"cell_type":{"e3b7877f":"code","e0985a42":"code","ab937215":"code","66a8c496":"code","0df82baa":"code","12cbab23":"code","18ae86cf":"code","c52da606":"code","26f4eb37":"code","d3029ba3":"code","e77d046c":"code","d9631266":"code","7f9ad0fd":"code","eae709fa":"code","7be5a9fe":"code","1ae51a48":"code","8dc0e706":"code","cab5dd1b":"code","da856912":"code","dc4cd7e8":"code","50822d73":"code","9c95e3d0":"code","ee5d0502":"code","658bd54e":"code","82acd064":"code","31b290e6":"code","bc88ba21":"code","8e341249":"code","eaf4c1f4":"code","c070888a":"code","fb6be713":"code","15d71506":"code","506602ff":"code","e9e72644":"code","3510b3e7":"code","2c608fc8":"code","8bd461f6":"code","32979a73":"code","b3b226b4":"code","db6b90ac":"code","e0ee069f":"code","3471e069":"code","0293083e":"code","b33c8c0c":"code","fc992bae":"code","afb52215":"code","0a6da1e4":"code","2078e51b":"code","e9c10675":"markdown","10c6aa2f":"markdown","a7bcdeca":"markdown","3cadb614":"markdown","9fa777b2":"markdown","93718ad1":"markdown","5068a1fd":"markdown","da0cb244":"markdown"},"source":{"e3b7877f":"import os\nimport pandas as pd\nimport numpy as np\nimport plotly_express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings('ignore')","e0985a42":"sales = pd.read_csv('\/kaggle\/input\/m5-forecasting-accuracy\/sales_train_validation.csv')\ncalendar = pd.read_csv('\/kaggle\/input\/m5-forecasting-accuracy\/calendar.csv')\nprices = pd.read_csv('\/kaggle\/input\/m5-forecasting-accuracy\/sell_prices.csv')","ab937215":"sales_bmr = np.round(sales.memory_usage().sum()\/(1024*1024),1)\ncalendar_bmr = np.round(calendar.memory_usage().sum()\/(1024*1024),1)\nprices_bmr = np.round(prices.memory_usage().sum()\/(1024*1024),1)","66a8c496":"def reduceMemory(df):\n    columns = df.dtypes.index.tolist()\n    datypes = df.dtypes.values.tolist()\n    for i,j in enumerate(datypes):\n        if 'int' in str(j):\n            if df[columns[i]].min() > np.iinfo(np.int8).min and df[columns[i]].max() < np.iinfo(np.int8).max:\n                df[columns[i]] = df[columns[i]].astype(np.int8)\n            elif df[columns[i]].min() > np.iinfo(np.int16).min and df[columns[i]].max() < np.iinfo(np.int16).max:\n                df[columns[i]] = df[columns[i]].astype(np.int16)\n            elif df[columns[i]].min() > np.iinfo(np.int32).min and df[columns[i]].max() < np.iinfo(np.int32).max:\n                df[columns[i]] = df[columns[i]].astype(np.int32)\n            else:\n                df[columns[i]] = df[columns[i]].astype(np.int64)\n        elif 'float' in str(j):\n            if df[columns[i]].min() > np.finfo(np.float16).min and df[columns[i]].max() < np.finfo(np.float16).max:\n                df[columns[i]] = df[columns[i]].astype(np.float16)\n            elif df[columns[i]].min() > np.finfo(np.float32).min and df[columns[i]].max() < np.finfo(np.float32).max:\n                df[columns[i]] = df[columns[i]].astype(np.float32)\n            else:\n                df[columns[i]] = df[columns[i]].astype(np.float64)\n        elif j == np.object:\n            if columns[i] == 'date':\n                df[columns[i]] = pd.to_datetime(df[columns[i]], format='%Y-%m-%d')\n            else:\n                df[columns[i]] = df[columns[i]].astype('category')\n    return df  \n\nsales = reduceMemory(sales)\nprices = reduceMemory(prices)\ncalendar = reduceMemory(calendar)","0df82baa":"sales_amr = np.round(sales.memory_usage().sum()\/(1024*1024),1)\ncalendar_amr = np.round(calendar.memory_usage().sum()\/(1024*1024),1)\nprices_amr = np.round(prices.memory_usage().sum()\/(1024*1024),1)","12cbab23":"d = {'DataFrame':['sales','calendar','prices'],\n       'Before Memory Reduction':[sales_bmr,calendar_bmr,prices_bmr],\n       'After Memory Reduction':[sales_amr,calendar_amr,prices_amr]}\n\nmemory = pd.DataFrame(d)\nmemory = pd.melt(memory, id_vars='DataFrame', var_name='Status', value_name='Memory (MB)')\nmemory.sort_values('Memory (MB)',inplace=True)\nfig = px.bar(memory, x='DataFrame', y='Memory (MB)', color='Status', barmode='group', text='Memory (MB)')\nfig.update_traces(texttemplate='%{text} MB', textposition='outside')\nfig.update_layout(template='seaborn', title='Memory Saving')\nfig.show()","18ae86cf":"df = pd.melt(sales, id_vars=['id', 'item_id', 'dept_id', 'cat_id', 'store_id', 'state_id'], var_name='d', value_name='sold').dropna()","c52da606":"df = pd.merge(df, calendar, on='d', how='left')\ndf = pd.merge(df, prices, on=['store_id','item_id','wm_yr_wk'], how='left') ","26f4eb37":"sales.head()","d3029ba3":"group = sales.groupby(['state_id','store_id','cat_id','dept_id'],as_index=False)['item_id'].count().dropna()\ngroup['USA'] = 'United States of America'\ngroup.rename(columns={'state_id':'State','store_id':'Store','cat_id':'Category','dept_id':'Department','item_id':'Count'},inplace=True)\nfig = px.treemap(group, path=['USA', 'State', 'Store', 'Category', 'Department'], values='Count',\n                  color='Count',\n                  color_continuous_scale= px.colors.sequential.Sunset,\n                  title='Walmart: Distribution of items')\nfig.update_layout(template='seaborn')\nfig.show()","e77d046c":"group_price_store = df.groupby(['state_id','store_id','item_id'],as_index=False)['sell_price'].mean().dropna()\nfig = px.violin(group_price_store, x='store_id', color='state_id', y='sell_price',box=True, hover_name='item_id')\nfig.update_xaxes(title_text='Store')\nfig.update_yaxes(title_text='Selling Price($)')\nfig.update_layout(template='seaborn',title='Distribution of Items prices wrt Stores',legend_title_text='State')\nfig.show()","d9631266":"group_price_cat = df.groupby(['store_id','cat_id','item_id'],as_index=False)['sell_price'].mean().dropna()\nfig = px.violin(group_price_cat, x='store_id', color='cat_id', y='sell_price',box=True, hover_name='item_id')\nfig.update_xaxes(title_text='Store')\nfig.update_yaxes(title_text='Selling Price($)')\nfig.update_layout(template='seaborn',title='Distribution of Items prices wrt Stores across Categories',\n                 legend_title_text='Category')\nfig.show()","7f9ad0fd":"group = df.groupby(['year','date','state_id','store_id'], as_index=False)['sold'].sum().dropna()\nfig = px.violin(group, x='store_id', color='state_id', y='sold',box=True)\nfig.update_xaxes(title_text='Store')\nfig.update_yaxes(title_text='Total items sold')\nfig.update_layout(template='seaborn',title='Distribution of Items sold wrt Stores',legend_title_text='State')\nfig.show()","eae709fa":"fig = go.Figure()\ntitle = 'Items sold over time'\nyears = group.year.unique().tolist()\nbuttons = []\ny=3\nfor state in group.state_id.unique().tolist():\n    group_state = group[group['state_id']==state]\n    for store in group_state.store_id.unique().tolist():\n        group_state_store = group_state[group_state['store_id']==store]\n        fig.add_trace(go.Scatter(name=store, x=group_state_store['date'], y=group_state_store['sold'], showlegend=True, \n                                   yaxis='y'+str(y) if y!=1 else 'y'))\n    y-=1\n\nfig.update_layout(\n        xaxis=dict(\n        #autorange=True,\n        range = ['2011-01-29','2016-05-22'],\n        rangeselector=dict(\n            buttons=list([\n                dict(count=1,\n                     label=\"1m\",\n                     step=\"month\",\n                     stepmode=\"backward\"),\n                dict(count=6,\n                     label=\"6m\",\n                     step=\"month\",\n                     stepmode=\"backward\"),\n                dict(count=1,\n                     label=\"YTD\",\n                     step=\"year\",\n                     stepmode=\"todate\"),\n                dict(count=1,\n                     label=\"1y\",\n                     step=\"year\",\n                     stepmode=\"backward\"),\n                dict(count=2,\n                     label=\"2y\",\n                     step=\"year\",\n                     stepmode=\"backward\"),\n                dict(count=3,\n                     label=\"3y\",\n                     step=\"year\",\n                     stepmode=\"backward\"),\n                dict(count=4,\n                     label=\"4y\",\n                     step=\"year\",\n                     stepmode=\"backward\"),\n                dict(step=\"all\")\n            ])\n        ),\n        rangeslider=dict(\n            autorange=True,\n        ),\n        type=\"date\"\n    ),\n    yaxis=dict(\n        anchor=\"x\",\n        autorange=True,\n        domain=[0, 0.33],\n        mirror=True,\n        showline=True,\n        side=\"left\",\n        tickfont={\"size\":10},\n        tickmode=\"auto\",\n        ticks=\"\",\n        title='WI',\n        titlefont={\"size\":20},\n        type=\"linear\",\n        zeroline=False\n    ),\n    yaxis2=dict(\n        anchor=\"x\",\n        autorange=True,\n        domain=[0.33, 0.66],\n        mirror=True,\n        showline=True,\n        side=\"left\",\n        tickfont={\"size\":10},\n        tickmode=\"auto\",\n        ticks=\"\",\n        title = 'TX',\n        titlefont={\"size\":20},\n        type=\"linear\",\n        zeroline=False\n    ),\n    yaxis3=dict(\n        anchor=\"x\",\n        autorange=True,\n        domain=[0.66, 1],\n        mirror=True,\n        showline=True,\n        side=\"left\",\n        tickfont={\"size\":10},\n        tickmode=\"auto\",\n        ticks='',\n        title=\"CA\",\n        titlefont={\"size\":20},\n        type=\"linear\",\n        zeroline=False\n    )\n    )\nfig.update_layout(template='seaborn', title=title)\nfig.show()","7be5a9fe":"df['revenue'] = df['sold']*df['sell_price'].astype(np.float32)","1ae51a48":"def introduce_nulls(df):\n    idx = pd.date_range(df.date.dt.date.min(), df.date.dt.date.max())\n    df = df.set_index('date')\n    df = df.reindex(idx)\n    df.reset_index(inplace=True)\n    df.rename(columns={'index':'date'},inplace=True)\n    return df\n\ndef plot_metric(df,state,store,metric):\n    store_sales = df[(df['state_id']==state)&(df['store_id']==store)&(df['date']<='2016-05-22')]\n    food_sales = store_sales[store_sales['cat_id']=='FOODS']\n    store_sales = store_sales.groupby(['date','snap_'+state],as_index=False)['sold','revenue'].sum()\n    snap_sales = store_sales[store_sales['snap_'+state]==1]\n    non_snap_sales = store_sales[store_sales['snap_'+state]==0]\n    food_sales = food_sales.groupby(['date','snap_'+state],as_index=False)['sold','revenue'].sum()\n    snap_foods = food_sales[food_sales['snap_'+state]==1]\n    non_snap_foods = food_sales[food_sales['snap_'+state]==0]\n    non_snap_sales = introduce_nulls(non_snap_sales)\n    snap_sales = introduce_nulls(snap_sales)\n    non_snap_foods = introduce_nulls(non_snap_foods)\n    snap_foods = introduce_nulls(snap_foods)\n    fig = go.Figure()\n    fig.add_trace(go.Scatter(x=non_snap_sales['date'],y=non_snap_sales[metric],\n                           name='Total '+metric+'(Non-SNAP)'))\n    fig.add_trace(go.Scatter(x=snap_sales['date'],y=snap_sales[metric],\n                           name='Total '+metric+'(SNAP)'))\n    fig.add_trace(go.Scatter(x=non_snap_foods['date'],y=non_snap_foods[metric],\n                           name='Food '+metric+'(Non-SNAP)'))\n    fig.add_trace(go.Scatter(x=snap_foods['date'],y=snap_foods[metric],\n                           name='Food '+metric+'(SNAP)'))\n    fig.update_yaxes(title_text='Total items sold' if metric=='sold' else 'Total revenue($)')\n    fig.update_layout(template='seaborn',title=store)\n    fig.update_layout(\n        xaxis=dict(\n        #autorange=True,\n        range = ['2011-01-29','2016-05-22'],\n        rangeselector=dict(\n            buttons=list([\n                dict(count=1,\n                     label=\"1m\",\n                     step=\"month\",\n                     stepmode=\"backward\"),\n                dict(count=6,\n                     label=\"6m\",\n                     step=\"month\",\n                     stepmode=\"backward\"),\n                dict(count=1,\n                     label=\"YTD\",\n                     step=\"year\",\n                     stepmode=\"todate\"),\n                dict(count=1,\n                     label=\"1y\",\n                     step=\"year\",\n                     stepmode=\"backward\"),\n                dict(count=2,\n                     label=\"2y\",\n                     step=\"year\",\n                     stepmode=\"backward\"),\n                dict(count=3,\n                     label=\"3y\",\n                     step=\"year\",\n                     stepmode=\"backward\"),\n                dict(count=4,\n                     label=\"4y\",\n                     step=\"year\",\n                     stepmode=\"backward\"),\n                dict(step=\"all\")\n            ])\n        ),\n        rangeslider=dict(\n            autorange=True,\n        ),\n        type=\"date\"\n    ))\n    return fig","8dc0e706":"cal_data = group.copy()\ncal_data = cal_data[cal_data.date <= '22-05-2016']\ncal_data['week'] = cal_data.date.dt.weekofyear\ncal_data['day_name'] = cal_data.date.dt.day_name()","cab5dd1b":"def calmap(cal_data, state, store, scale):\n    cal_data = cal_data[(cal_data['state_id']==state)&(cal_data['store_id']==store)]\n    years = cal_data.year.unique().tolist()\n    fig = make_subplots(rows=len(years),cols=1,shared_xaxes=True,vertical_spacing=0.005)\n    r=1\n    for year in years:\n        data = cal_data[cal_data['year']==year]\n        data = introduce_nulls(data)\n        fig.add_trace(go.Heatmap(\n            z=data.sold,\n            x=data.week,\n            y=data.day_name,\n            hovertext=data.date.dt.date,\n            coloraxis = \"coloraxis\",name=year,\n        ),r,1)\n        fig.update_yaxes(title_text=year,tickfont=dict(size=5),row = r,col = 1)\n        r+=1\n    fig.update_xaxes(range=[1,53],tickfont=dict(size=10), nticks=53)\n    fig.update_layout(coloraxis = {'colorscale':scale})\n    fig.update_layout(template='seaborn', title=store)\n    return fig","da856912":"fig = plot_metric(df,'CA','CA_1','sold')\nfig.show()","dc4cd7e8":"fig = plot_metric(df,'CA','CA_1','revenue')\nfig.show()","50822d73":"fig = calmap(cal_data, 'CA', 'CA_1', 'magma')\nfig.show()","9c95e3d0":"fig = plot_metric(df,'CA','CA_2','sold')\nfig.show()","ee5d0502":"fig = plot_metric(df,'CA','CA_2','revenue')\nfig.show()","658bd54e":"fig = calmap(cal_data, 'CA', 'CA_2', 'magma')\nfig.show()","82acd064":"fig = plot_metric(df,'CA','CA_3','sold')\nfig.show()","31b290e6":"fig = plot_metric(df,'CA','CA_3','revenue')\nfig.show()","bc88ba21":"fig = calmap(cal_data, 'CA', 'CA_3', 'magma')\nfig.show()","8e341249":"fig = plot_metric(df,'CA','CA_4','sold')\nfig.show()","eaf4c1f4":"fig = plot_metric(df,'CA','CA_4','revenue')\nfig.show()","c070888a":"fig = calmap(cal_data, 'CA', 'CA_4', 'magma')\nfig.show()","fb6be713":"fig = plot_metric(df,'TX','TX_1','sold')\nfig.show()","15d71506":"fig = plot_metric(df,'TX','TX_1','revenue')\nfig.show()","506602ff":"fig = calmap(cal_data, 'TX', 'TX_1', 'viridis')\nfig.show()","e9e72644":"fig = plot_metric(df,'TX','TX_2','sold')\nfig.show()","3510b3e7":"fig = plot_metric(df,'TX','TX_2','revenue')\nfig.show()","2c608fc8":"fig = calmap(cal_data, 'TX', 'TX_2', 'viridis')\nfig.show()","8bd461f6":"fig = plot_metric(df,'TX','TX_3','sold')\nfig.show()","32979a73":"fig = plot_metric(df,'TX','TX_3','revenue')\nfig.show()","b3b226b4":"fig = calmap(cal_data, 'TX', 'TX_3', 'viridis')\nfig.show()","db6b90ac":"fig = plot_metric(df,'WI','WI_1','sold')\nfig.show()","e0ee069f":"fig = plot_metric(df,'WI','WI_1','revenue')\nfig.show()","3471e069":"fig = calmap(cal_data, 'WI', 'WI_1', 'twilight')\nfig.show()","0293083e":"fig = plot_metric(df,'WI','WI_2','sold')\nfig.show()","b33c8c0c":"fig = plot_metric(df,'WI','WI_2','revenue')\nfig.show()","fc992bae":"fig = calmap(cal_data, 'WI', 'WI_2', 'twilight')\nfig.show()","afb52215":"fig = plot_metric(df, 'WI', 'WI_3', 'sold')\nfig.show()","0a6da1e4":"fig = plot_metric(df, 'WI', 'WI_3', 'revenue')\nfig.show()","2078e51b":"fig = calmap(cal_data, 'WI', 'WI_3', 'twilight')\nfig.show()","e9c10675":"### Calculating Memory Usage After Reduction","10c6aa2f":"#### Numerical Columns:\n\nint8 \/ uint8 : consumes 1 byte of memory, range between -128\/127 or 0\/255\n\nbool : consumes 1 byte, true or false\n\nfloat16 \/ int16 \/ uint16: consumes 2 bytes of memory, range between -32768 and 32767 or 0\/65535\n\nfloat32 \/ int32 \/ uint32 : consumes 4 bytes of memory, range between -2147483648 and 2147483647\n\nfloat64 \/ int64 \/ uint64: consumes 8 bytes of memory\n\nIf one of your column has values between 1 to 126 for example, you will reduce the size of that column from 8 bytes per row to 1 byte, which is more than 90% memory saving on that column!\n\n#### Categorical Columns:\n\nPandas stores categorical columns as objects. One of the reason this storage is not optimal is that it creates a list of pointers to the memory address of each value of your column. For columns with low cardinality (the amount of unique values is lower than 50% of the count of these values), this can be optimized by forcing pandas to use a virtual mapping table where all unique values are mapped via an integer instead of a pointer. This is done using the category datatype.","a7bcdeca":"### Fetch Data","3cadb614":"### Function To Reduce Memory Usage","9fa777b2":"### Importing Required Libraries","93718ad1":"### Downcast using pandas datatypes to save memory usage","5068a1fd":"### Visualizing the Storage Consumed By The Dataset","da0cb244":"### Calculating Memory Usage Before Visualization"}}