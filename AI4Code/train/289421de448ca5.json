{"cell_type":{"4b816fdf":"code","481acd90":"code","59c10377":"code","e35089ea":"code","6ccff985":"code","9e549bf4":"code","d94c793e":"code","32861107":"code","979d3f60":"code","7206ad80":"code","3b2a216e":"code","fbdc5558":"code","4bab8825":"code","200e1ab7":"code","eabe2a7a":"code","e655b0cb":"code","70cc6122":"code","054dd1a7":"code","d42b60aa":"code","cce3bd54":"code","5a2fbd17":"code","a66cc8df":"code","545ce310":"code","8bf92b1a":"code","79ed7b69":"code","9f6bb712":"code","3f9bd7c4":"code","c893d7e9":"code","9de4eefd":"code","b26ce017":"markdown","a38d7700":"markdown","49024f12":"markdown","82c85a08":"markdown","359aa9cc":"markdown","43ca4e87":"markdown","d84dd752":"markdown","1c012c7a":"markdown","7b4ca713":"markdown","9289fadf":"markdown","269b2438":"markdown","d53bb572":"markdown","ddb4e7d8":"markdown"},"source":{"4b816fdf":"import torch\nimport torchvision\nfrom torchvision.transforms import ToTensor,Normalize,Compose\nfrom torchvision.datasets import MNIST","481acd90":"mnist = MNIST(root = 'data',train=True,download=True,transform=Compose([\n    ToTensor(),Normalize(mean=(0.5,),std=(0.5,))\n]))","59c10377":"img,label = mnist[0]\nprint('Label:', label)\nprint(img)\ntorch.min(img),torch.max(img)","e35089ea":"def denorm(x):\n    out = (x+1)\/2\n    return out.clamp(0,1)","6ccff985":"import matplotlib.pyplot as plt\n%matplotlib inline\n\nimg_norm = denorm(img)\nplt.imshow(img_norm[0], cmap='gray')\nprint('Label:', label)","9e549bf4":"from torch.utils.data import DataLoader\n\nbatch_size = 100\ndata_loader = DataLoader(mnist,batch_size,shuffle=True)","d94c793e":"for img_batch,label_batch in data_loader:\n    print(\"First Batch\")\n    print(img_batch.shape)\n    plt.imshow(img_batch[0][0],cmap='gray')\n    print(label_batch)\n    break","32861107":"device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')","979d3f60":"device","7206ad80":"image_size = 784\nhidden_size = 256","3b2a216e":"import torch.nn as nn\nimport torch.nn.functional as F","fbdc5558":"D = nn.Sequential(\n    nn.Linear(image_size, hidden_size),\n    nn.LeakyReLU(0.2),\n    nn.Linear(hidden_size, hidden_size),\n    nn.LeakyReLU(0.2),\n    nn.Linear(hidden_size, 1),\n    nn.Sigmoid())","4bab8825":"D.to(device);","200e1ab7":"latent_size = 64","eabe2a7a":"G = nn.Sequential(\n    nn.Linear(latent_size, hidden_size),\n    nn.ReLU(),\n    nn.Linear(hidden_size, hidden_size),\n    nn.ReLU(),\n    nn.Linear(hidden_size, image_size),\n    nn.Tanh())","e655b0cb":"y = G(torch.randn(2,latent_size))\ngen_imgs = denorm(y.reshape((-1,28,28)).detach())","70cc6122":"plt.imshow(gen_imgs[0],cmap='gray')","054dd1a7":"plt.imshow(gen_imgs[1], cmap='gray');","d42b60aa":"G.to(device);","cce3bd54":"criterion = nn.BCELoss()\nd_optimizer = torch.optim.Adam(D.parameters(),lr=0.0002)\ng_optimizer = torch.optim.Adam(G.parameters(),lr=0.0002)","5a2fbd17":"def reset_grad():\n    d_optimizer.zero_grad()\n    g_optimizer.zero_grad()\n\ndef train_discriminator(images):\n    # Create the labels which are later used as input for the BCE loss\n    real_labels = torch.ones(batch_size, 1).to(device)\n    fake_labels = torch.zeros(batch_size, 1).to(device)\n        \n    # Loss for real images\n    outputs = D(images)\n    d_loss_real = criterion(outputs, real_labels)\n    real_score = outputs\n\n    # Loss for fake images\n    z = torch.randn(batch_size, latent_size).to(device)\n    fake_images = G(z)\n    outputs = D(fake_images)\n    d_loss_fake = criterion(outputs, fake_labels)\n    fake_score = outputs\n\n    # Combine losses\n    d_loss = d_loss_real + d_loss_fake\n    # Reset gradients\n    reset_grad()\n    # Compute gradients\n    d_loss.backward()\n    # Adjust the parameters using backprop\n    d_optimizer.step()\n    \n    return d_loss, real_score, fake_score","a66cc8df":"def train_generator():\n    # Generate fake images and calculate loss\n    z = torch.randn(batch_size, latent_size).to(device) #creating fake images\n    fake_images = G(z)\n    labels = torch.ones(batch_size, 1).to(device) # foolig the generator\n    g_loss = criterion(D(fake_images), labels)\n    \n    reset_grad()\n    g_loss.backward()\n    g_optimizer.step()\n    return g_loss,fake_images","545ce310":"import os\n\nsample_dir = 'samples'\nif not os.path.exists(sample_dir):\n    os.makedirs(sample_dir)","8bf92b1a":"from IPython.display import Image\nfrom torchvision.utils import save_image\n\n# Save some real images\nfor images, _ in data_loader:\n    images = images.reshape(images.size(0), 1, 28, 28)\n    save_image(denorm(images), os.path.join(sample_dir, 'real_images.png'), nrow=10)\n    break\n   \nImage(os.path.join(sample_dir, 'real_images.png'))","79ed7b69":"sample_vectors = torch.randn(batch_size, latent_size).to(device)\ndef save_fake_images(index):\n    fake_images = G(sample_vectors)\n    fake_images = fake_images.reshape(fake_images.size(0),1,28,28)\n    fake_fname = 'fake_images-{0:0=4d}.png'.format(index)\n    print('Saving', fake_fname)\n    save_image(denorm(fake_images), os.path.join(sample_dir, fake_fname), nrow=10)\n    \n# Before training\nsave_fake_images(0)\nImage(os.path.join(sample_dir, 'fake_images-0000.png'))","9f6bb712":"num_epochs = 50\ntotal_step = len(data_loader)\nd_losses, g_losses, real_scores, fake_scores = [], [], [], []\n\nfor epoch in range(num_epochs):\n    for i, (images, _) in enumerate(data_loader):\n        # Load a batch & transform to vectors\n        images = images.reshape(batch_size, -1).to(device)\n        \n        # Train the discriminator and generator\n        d_loss, real_score, fake_score = train_discriminator(images)\n        g_loss, fake_images = train_generator()\n        \n        # Inspect the losses\n        if (i+1) % 200 == 0:\n            d_losses.append(d_loss.item())\n            g_losses.append(g_loss.item())\n            real_scores.append(real_score.mean().item())\n            fake_scores.append(fake_score.mean().item())\n            print('Epoch [{}\/{}], Step [{}\/{}], d_loss: {:.4f}, g_loss: {:.4f}, D(x): {:.2f}, D(G(z)): {:.2f}' \n                  .format(epoch, num_epochs, i+1, total_step, d_loss.item(), g_loss.item(), \n                          real_score.mean().item(), fake_score.mean().item()))\n        \n    # Sample and save images\n    save_fake_images(epoch+1)","3f9bd7c4":"# Save the model checkpoints \ntorch.save(G.state_dict(), 'G.ckpt')\ntorch.save(D.state_dict(), 'D.ckpt')","c893d7e9":"Image('.\/samples\/fake_images-0010.png')","9de4eefd":"import cv2\nimport os\nfrom IPython.display import FileLink\n\nvid_fname = 'gans_training.avi'\n\nfiles = [os.path.join(sample_dir, f) for f in os.listdir(sample_dir) if 'fake_images' in f]\nfiles.sort()\n\nout = cv2.VideoWriter(vid_fname,cv2.VideoWriter_fourcc(*'MP4V'), 8, (302,302))\n[out.write(cv2.imread(fname)) for fname in files]\nout.release()\nFileLink('gans_training.avi')","b26ce017":"## Training the Model","a38d7700":"Note that we are are transforming the pixel values from the range ```[0, 1]``` to the range ```[-1, 1]```. The reason for doing this will become clear when define the generator network. Let's look at a sample tensor from the data.\n\n","49024f12":"**Discriminator Training**\n\nSince the discriminator is a binary classification model, we can use the binary cross entropy loss function to quantify how well it is able to differentiate between real and generated images.\n\n![binary](https:\/\/image.slidesharecdn.com\/chrishokamp-dublinnlp3-160805110319\/95\/task-based-learning-for-nlp-going-beyond-cross-entropy-chris-hokamp-10-638.jpg?cb=1470395213)","82c85a08":"## Discriminator Network\n\nThe discriminator takes an image as input, and tries to classify it as \"real\" or \"generated\". In this sense, it's like any other neural network. While we can use a CNN for the discriminator, we'll use a simple feedforward network with 3 linear layers to keep things since. We'll treat each 28x28 image as a vector of size 784.","359aa9cc":"We use the Leaky ReLU activation for the discriminator.\n\n![leakyrelu](https:\/\/cdn-images-1.medium.com\/max\/1600\/1*ypsvQH7kvtI2BhzR2eT_Sw.png)\n\nDifferent from the regular ReLU function, Leaky ReLU allows the pass of a small gradient signal for negative values. As a result, it makes the gradients from the discriminator flows stronger into the generator. Instead of passing a gradient (slope) of 0 in the back-prop pass, it passes a small negative gradient.","43ca4e87":"**Generator Training**\n\nSince the outputs of the generator are images, it's not obvious how we can train the generator. This is where we employ a rather elegant trick, which is to use the discriminator as a part of the loss function. Here's how it works:\n\n* We generate a batch of images using the generator, pass the into the discriminator.\n\n* We calculate the loss by setting the target labels to 1 i.e. real. We do this because the generator's objective is to \"fool\" the discriminator.\n\n* We use the loss to perform gradient descent i.e. change the weights of the generator, so it gets better at generating real-like images.","d84dd752":"Here are the steps involved in training the discriminator.\n\n* We expect the discriminator to output 1 if the image was picked from the real MNIST dataset, and 0 if it was generated.\n\n* We first pass a batch of real images, and compute the loss, setting the target labels to 1.\n\n* Then, we generate a batch of fake images using the generator, pass them into the discriminator, and compute the loss, setting the target labels to 0.\n\n* Finally we add the two losses and use the overall loss to perform gradient descent to adjust the weights of the discriminator.\n\nIt's important to note that we don't change the weights of the generator model while training the discriminator ```(d_optimizer only affects the D.parameters())```","1c012c7a":"As expected, the pixel values range from -1 to 1. Let's define a helper to denormalize and view the images. This function will also be useful for viewing the generated images.","7b4ca713":"**Loading The Data**","9289fadf":"## Generator Network\n\nThe input to the generator is typically a vector or a matrix which is used as a seed for generating an image. Once again, to keep things simple, we'll use a feedfoward neural network with 3 layers, and the output will be a vector of size 784, which can be transformed to a 28x28 px image.","269b2438":"Let's save a batch of real images that we can use for visual comparision while looking at the generated images.","d53bb572":"# Generative Adverserial Networks in PyTorch\n\nDeep neural networks are used mainly for supervised learning: classification or regression. Generative Adverserial Networks or GANs, however, use neural networks for a very different purpose: Generative modeling\n\nGenerative modeling is an unsupervised learning task in machine learning that involves automatically discovering and learning the regularities or patterns in input data in such a way that the model can be used to generate or output new examples that plausibly could have been drawn from the original dataset.\n\nWhile there are many approaches used for generative modeling, a Generative Adverserial Network takes the following approach:\n\n![image](https:\/\/i.imgur.com\/6NMdO9u.png)\n\n\nThere are two neural networks: a Generator and a Discriminator. The generator generates a \"fake\" sample given a random vector\/matrix, and the discriminator attempts to detect whether a given sample is \"real\" (picked from the training data) or \"fake\" (generated by the generator). Training happens in tandem: we train the discriminator for a few epochs, then train the generator for a few epochs, and repeat. This way both the generator and the discriminator get better at doing their jobs. This rather simple approach can lead to some astounding results. The following images (source), for instances, were all generated using GANs:\n\n![face](https:\/\/3qeqpr26caki16dnhd19sv6by6v-wpengine.netdna-ssl.com\/wp-content\/uploads\/2019\/04\/Example-of-Photorealistic-Human-Faces-Generated-by-a-GAN.png)\n","ddb4e7d8":"We use the TanH activation function for the output layer of the generator.\n\n![tanh](https:\/\/nic.schraudolph.org\/teach\/NNcourse\/figs\/tanh.gif)\n\nThe ReLU activation is used in the generator with the exception of the output layer which uses the Tanh function. We observed that using a bounded activation allowed the model to learn more quickly to saturate and cover the color space of the training distribution. Within the discriminator we found the leaky rectified activation to work well, especially for higher resolution modeling.\n\n* Note that since the outputs of the TanH activation lie in the range [-1,1], we have applied the same transformation to the images in the training dataset. Let's generate an output vector using the generator and view it as an image by transforming and denormalizing the output."}}