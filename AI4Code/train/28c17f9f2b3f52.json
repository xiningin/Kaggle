{"cell_type":{"675c8ac6":"code","16d3c83b":"code","d4bce875":"code","ec1a1143":"code","06943f47":"code","e97c3416":"code","c979ea44":"code","6701f624":"code","05205032":"code","b760907e":"code","93dc45b4":"code","101319ce":"code","564ca774":"code","a3c175a8":"code","e57ce169":"code","85cfa95d":"code","6acaefc6":"code","66c0ee4a":"code","ae29682a":"code","25afe9a7":"code","d450559d":"code","65798df1":"code","acbb34b0":"code","0c514195":"code","f930b35d":"code","6988256b":"code","c987155c":"code","08c5de67":"code","eefecdd6":"code","c8508edf":"code","ef089a25":"code","f8977820":"code","74202e61":"code","2bb72413":"code","fc06d168":"code","6ffa4eaa":"code","1dcb736e":"code","2e002109":"code","1a216f7b":"code","c571d888":"code","42e7833f":"code","a847aceb":"code","c5150450":"code","7ccda509":"code","e9b2fafa":"markdown","d63579db":"markdown","0e9ae299":"markdown","16063ecd":"markdown","caee4194":"markdown","6c813b5d":"markdown","070c04b9":"markdown","749e47b7":"markdown","76c7bcfc":"markdown","ac1338ae":"markdown","446f5213":"markdown","d7ea8ec9":"markdown","734fb52f":"markdown","fd013f6d":"markdown","df00f7e2":"markdown","8aee7026":"markdown","a00c538a":"markdown","787dc663":"markdown","22ed54a4":"markdown","a0c63e6b":"markdown","6bca7d88":"markdown","6775a469":"markdown","60647f7c":"markdown","0d1fec75":"markdown","fbb9fe59":"markdown","653c3224":"markdown","07ff2f1a":"markdown"},"source":{"675c8ac6":"# importing libraries\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os, time, tqdm\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.metrics import *\nimport tensorflow as tf \nfrom functools import partial\n# import keras\nfrom tensorflow.keras import layers\nimport albumentations as A\nimport tensorflow_hub as hub\nfrom tensorflow.keras.layers import Input, Dense, Flatten, Dropout\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.applications.resnet50 import ResNet50\nfrom tensorflow.keras.callbacks import CSVLogger\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.losses import BinaryCrossentropy\nfrom tensorflow.keras.metrics import Precision, Recall\nfrom sklearn.metrics import classification_report, f1_score\nfrom sklearn.model_selection import KFold","16d3c83b":"!nvidia-smi","d4bce875":"image_dir = '..\/input\/breakhis\/BreaKHis_v1\/'\ndata_path = '..\/input\/breakhis\/Folds.csv'\n\n# experimental API for making data pipelines\ntf.data.experimental.AUTOTUNE\n\n# defining the class names\nclass_names = ['malignant', 'benign']\nprint(class_names)","ec1a1143":"# loading the data\ndata = pd.read_csv(data_path)\ndata.head(5)","06943f47":"data['fold'].value_counts()","e97c3416":"# renaming and structuring the columns for better data understanding\ndata = data.rename(columns={'filename': 'path'})\ndata['label'] = data.path.apply(lambda x: x.split('\/')[3])\ndata['label_int'] = data.label.apply(lambda x: class_names.index(x))\ndata['filename'] = data.path.apply(lambda x: x.split('\/')[-1])","c979ea44":"# view first n rows of strucrured data\ndata.head(6)","6701f624":"data.shape","05205032":"# making a plot to see data distribution\n# sns.figure()\nsns.set_theme()\nsns.displot(x='label', data=data)","b760907e":"sns.countplot(x=data['label'], data=data)","93dc45b4":"# sorting out training, validation and testing images\ntest_images = data.groupby(by='label').sample(3000)\ntrain_images = data.drop(test_images.index).reset_index(drop=True)\ntest_images = test_images.reset_index(drop=True)","101319ce":"# making splits of training & validation datasets\nvalidation_images = train_images.sample(frac = 0.3)\ntrain_images = train_images.drop(validation_images.index).reset_index(drop=True)\nvalidation_images = validation_images.reset_index(drop=True)","564ca774":"print('Total training images: % s' % str(train_images.shape[0]))\nprint('Total validation images: % s' % str(validation_images.shape[0]))\nprint('Total testing images: % s' % str(test_images.shape[0]))","a3c175a8":"train_images['set'] = 'train'\nvalidation_images['set'] = 'validation'\ntest_images['set'] = 'test'","e57ce169":"new_data = pd.concat([train_images, validation_images, test_images])\nnew_data.head(5)","85cfa95d":"sns.set(rc={'figure.figsize':(10.4, 5.4)})\nsns.countplot(x=new_data['label'], hue=new_data['set'])","6acaefc6":"max_count = np.max(train_images.label.value_counts())\nmin_count = np.min(train_images.label.value_counts())\ntrain_images = train_images.groupby('label').sample(n=max_count, replace=True)\ntrain_images = train_images.reset_index(drop=True)","66c0ee4a":"train_images.head(5)","ae29682a":"model_handle_map = {\"efficientnetv2-b0\": \"https:\/\/tfhub.dev\/google\/imagenet\/efficientnet_v2_imagenet1k_b0\/feature_vector\/2\", \n                   \"inception_v3\": \"https:\/\/tfhub.dev\/google\/imagenet\/inception_v3\/feature_vector\/4\", \n                   \"inception_resnet_v2\": \"https:\/\/tfhub.dev\/google\/imagenet\/inception_resnet_v2\/feature-vector\/4\"}\nmodel_image_size = {\"efficientnetv2-b0\": 224, \n                   \"inception_v3\": 299, \n                   \"inception_resnet_v2\": 299}","25afe9a7":"# function to decode a PNG image into a tf tensor\ndef load_image(path, label):\n    image = tf.io.read_file(path)\n    image = tf.io.decode_png(image, channels=3)\n    return image, label\n\n# reshaping the image between 0 and 1\ndef image_reshape(image, label):\n    image = tf.cast(image, tf.float32)\n    image = tf.image.resize(image, [224, 224] \/ 255)\n    return image, label\n\n# image argumentation for faster model training\ndef argument_image(image):\n    transform = A.Compose([A.HorizontalFlip(p = 0.5), \n                          A.Rotate(p = 0.5, limit = 15), \n                          A.RandomBrightnessContrast(p=0.5, brightness_limit=(-0.2, 0.2), contrast_limit=(-0.1, 0.1), \n                                                    brightness_by_max=True),\n                           A.RandomResizedCrop(p=0.8, height=IMG_SIZE, width=IMG_SIZE, \n                                              scale=(0.9, 1.1), ratio=(0.05, 1.1), interpolation=0),\n                           A.Blur(blur_limit = (1, 1))\n                           \n                          ])\n    \n    data = {\"image\": image}\n    argumented_data = transform(**data)\n    argumented_image = argumented_data[\"image\"]\n    argumented_image = tf.cast(argumented_image, tf.float32)\n    argumented_image = tf.image.resize(argumented_image, [IMG_SIZE, IMG_SIZE]) \/ 255\n    \n    return argumented_image\n\ndef argumentor_function(image, label):\n    argumented_image = tf.numpy_function(func = argument_image, inp=[image], Tout = tf.float32)\n    return argumented_image, label\n\n\n# function to view sample of images\ndef view_image(ds, col = 5, row = 5, size=(30, 10)):\n    plt.figure(figsize=(10, 5))\n    plt.subplots_adjust(wspace = 0.05, hspace = 0.15)\n    for images, labels in ds.take(1):\n        for i in range(col * row):\n            ax = plt.subplot(row, col, i + 1)\n            shape = str(images[i].numpy().shape)\n            plt.imshow(images[i].numpy())\n            plt.title(class_names[labels[i].numpy()])\n            plt.axis(\"off\") \n    plt.tight_layout\n    return None\n\ndef view_model_predictions():\n    plt.figure(figsize = (30, 8))\n    plt.rcParams.update({'font.size': 10})\n    plt.subplots_adjust(wspace = 0.05, hspace = 0.15)\n    for i in range(30):\n        ax = plt.subplot(3, 10, i + 1)\n        shape = str(test_image[i].numpy().shape)\n        plt.imshow(test_image[i].numpy())\n        plt.title(predicted_label[i][0])\n        plt.axis(\"off\") \n        plt.tight_layout\n    return None\n\n# making a function to calculate & show model history\ndef model_hist(history):\n    accuracy = history['accuracy']\n    loss = history['loss']\n    val_accuracy = history['val_accuracy']\n    val_loss = history['val_loss']\n    \n    # setting the epochs\n    n_epochs = range(len(history['loss']))\n    \n    # saving models logs\n    # csv_logger = CSVLogger('cnn_model_logs.csv', append=True)\n    \n    # making plots for accuracy \n    plt.figure(figsize=(16, 5))\n    plt.subplot(1, 2, 1)\n    plt.plot(n_epochs, accuracy, label='training accuracy')\n    plt.plot(n_epochs, val_accuracy, label='validation accuracy')\n    plt.legend()\n    \n    # making plots for loss\n    plt.figure(figsize=(16, 5))\n    plt.subplot(1, 2, 2)\n    plt.plot(n_epochs, loss, label='training loss (binary crossentropy)')\n    plt.plot(n_epochs, val_loss, label='validation loss (binary crossentropy)')\n    plt.legend()\n    \n    return None\n\n# function for decoding a test image\ndef decode_test_img(path):\n    image = tf.io.read_file(path)\n    image = tf.image.decode_png(image, channels=3)\n    image = tf.cast(image, tf.float32)\n    image = tf.image.resize(image, [224, 224])\n    return image\n\n# function for building a NN\ndef make_nn_model(image_size):\n    print('Making our deep cnn model.....')\n    cnn_model = tf.keras.Sequential([\n        layers.InputLayer(input_shape=(image_size, image_size, 3)),\n        hub.KerasLayer(model_handle, trainable=True, name='base'),\n        layers.Dense(512, activation='relu', name='fc1'),\n        layers.BatchNormalization(),\n        layers.Dropout(0.4, name='dropout'),\n        layers.Dense(128, activation='relu', name='fc2'),\n        layers.BatchNormalization(),\n        # layers.Dropout(0.4, name='dropout2'),\n        layers.Dense(1, activation='sigmoid', name='output')\n    ], name=model_name)\n    \n    cnn_model.build((None, image_size, image_size, 3))\n    cnn_model.summary()\n    print('model built!')\n    return cnn_model","d450559d":"# defining model configuration parameters\nmodel_name = \"efficientnetv2-b0\"\n# model_name = \"inception_v3\"\n# model_name = \"inception_resnet_v2\"\nmodel_handle = model_handle_map.get(model_name)\nIMG_SIZE = model_image_size.get(model_name, 224)\nBATCH_SIZE = 32\nEPOCHS = 10\nsample_size = len(train_images)\n\nprint(f\"Selected model: {model_name} : {model_handle}\")\nprint(f\"Input size of model: {IMG_SIZE}\")","65798df1":"IMG_SIZE","acbb34b0":"(image_dir + train_images.path)[0]","0c514195":"# loading the train & validation dataets\nload_train = tf.data.Dataset.from_tensor_slices((image_dir + train_images.path, \n                                                train_images.label_int))\n\nload_valid = tf.data.Dataset.from_tensor_slices((image_dir + validation_images.path, \n                                                validation_images.label_int))","f930b35d":"load_train","6988256b":"train_dataset = (\n                load_train.shuffle(len(train_images))\n                .map(load_image, num_parallel_calls=tf.data.experimental.AUTOTUNE)\n                .map(partial(argumentor_function), num_parallel_calls=tf.data.experimental.AUTOTUNE)\n                .batch(BATCH_SIZE)\n                .prefetch(tf.data.experimental.AUTOTUNE)\n                )\nval_dataset = (\n                load_valid.shuffle(len(validation_images))\n                .map(load_image, num_parallel_calls=tf.data.experimental.AUTOTUNE)\n                .map(partial(argumentor_function), num_parallel_calls=tf.data.experimental.AUTOTUNE)\n                .batch(BATCH_SIZE)\n                .prefetch(tf.data.experimental.AUTOTUNE)\n                )\n\ntrain_dataset","c987155c":"# checking the path of images\ntrain_images.path[5]","08c5de67":"start = time.time()\nview_image(train_dataset)\nend = time.time()\nprint('Time Taken: %.3f seconds' % (end-start))","eefecdd6":"start = time.time()\nview_image(val_dataset)\nend = time.time()\nprint('Time Taken: %.3f seconds' % (end-start))","c8508edf":"def get_labels_from_tfdataset(tfdataset, batched=False):\n\n    labels = list(map(lambda x: x[1], tfdataset)) # Get labels \n\n    if not batched:\n        return tf.concat(labels, axis=0) # concat the list of batched labels\n\n    return labels\nget_labels_from_tfdataset(train_dataset)","ef089a25":"print('Size of Image being used: %d' % (IMG_SIZE))","f8977820":"# starting a new sesion for TF\nimage_size = 224\ntf.keras.backend.clear_session()\nmodel_nn = make_nn_model(IMG_SIZE)\n\n# making model checkpoints\nmodel_checkpoint = tf.keras.callbacks.ModelCheckpoint('model.h5', save_best_only=True)\n\n# model logs\ncsv_logger = CSVLogger('cnn_model_logs.csv', append=True)\n\nmetrics = ['accuracy', Precision(name='Precision'), Recall(name='Recall')]\n\n# compiling the model\nmodel_nn.compile(loss='binary_crossentropy', optimizer='adam', metrics=metrics)\n\n# fit the model\ntrain_history = model_nn.fit(train_dataset, epochs=10, batch_size=BATCH_SIZE, verbose=1, \n                             callbacks=[model_checkpoint, csv_logger], validation_data=val_dataset)","74202e61":"# visualize model performance\nhistory = train_history.history\nmodel_hist(history)","2bb72413":"model_performance = model_nn.evaluate(val_dataset)","fc06d168":"print('Net loss on validation data: %.3f' % model_performance[0])\nprint('Net accuracy on validation data: %.3f' % model_performance[1])\nprint('Net precision on validation data: %.3f' % model_performance[2])\nprint('Net recall on validation data: %.3f' % model_performance[3])","6ffa4eaa":"# making samples of test data\ntest_images = test_images.sample(frac=1).reset_index(drop=True)\ntest_data = tf.data.Dataset.from_tensor_slices(image_dir + test_images.path)\ntest_data = test_data.map(decode_test_img, \n                          num_parallel_calls=tf.data.experimental.AUTOTUNE).batch(64)\ntest_data","1dcb736e":"print('Total Test Images: %d' % len(test_images))","2e002109":"test_index = test_images.label_int.values\ntest_labels = test_images.label.values\ntest_index, test_labels","1a216f7b":"test_image = next(iter(test_data))","c571d888":"# making predictions\ntest_predictions = model_nn.predict(test_data)\npredicted_index = np.round(test_predictions)","42e7833f":"# checking predictions made by neural network\npredicted_index[:6]","a847aceb":"predicted_index = np.round(test_predictions).astype(int)\npredicted_label = np.array(class_names)[predicted_index]\npredicted_label[:8]","c5150450":"prediction_data = pd.DataFrame({'filename':test_images.filename.values,'actual':test_images.label.values, \n                              'prediction': np.squeeze(predicted_label),'path':test_images.path.values,})","7ccda509":"# see model predictions\nprediction_data[['actual', 'prediction']].head(15)","e9b2fafa":"![](https:\/\/upload.wikimedia.org\/wikipedia\/commons\/5\/50\/Histopathology_of_basal-like_breast_cancer.jpg)","d63579db":"## Dataset Modelling for Deep Learning","0e9ae299":"## Import Python Libraries\nFirst, we will import the necessary libraries for our notebook.","16063ecd":"### Visualizing Train, Validation & Test Splits","caee4194":"Test Data Samples have been successfully created!","6c813b5d":"## Dataset Information \nThe breast cancer histopathological image dataset (BreakHis) contains **9109** microscopic images of breast tumor tissues collected from **82** patients, regarded as malignant or benign. The tissues are magnigfied at different scaling factors (**40X**, **100X**, **200X**, **400X**). In this dataset, it contains **2480** malignant and **5429** benign tumors. The images of tissues are taken to be **700X460 pixels**, **3-channel RGB**, **8** bit depth in each format, and in PNG. It is believed that this dataset can become a benchmark for future classifications of breast cancer classification.        ","070c04b9":"Let's make sure that we have a GPU installed. ","749e47b7":"We will model the data for our training, vaidation and testing sets. ","76c7bcfc":"We have successfully loaded the images, preprocessed them, made image argumentations and visualized the images of what they look like. ","ac1338ae":"## Loading the Dataset","446f5213":"### Data Structuring\nWe will strcuture the data in csv filefor our ease and for better understanding. ","d7ea8ec9":"We have defined the model parameters + configuration in above sections. Now we define and load the dataset in our memory. We will define 2 datasets, train & valid. ","734fb52f":"## Evaluation on Test Data","fd013f6d":"## Making the Deep Learning Model","df00f7e2":"## Deep Learning Model Training Using K Fold Cross Validation\nThis is the step whwre we train our deep learning model. We have defined the model configuration, dataset modelling, data loading and preparation. We will use the **K-Fold Cross Validation Technique** to train our model, by making sure that what is the best fit for our model","8aee7026":"### Model Configuration Parameters ","a00c538a":"## Visualize Model Performance (Loss\/Accuracy)","787dc663":"Our dataset has been restructured the way we wanted it to be. Let's perform some analysis on it tnd then we will move towards the images to perform computations on them. ","22ed54a4":"## GPU Confirmation","a0c63e6b":"## Unsampling Data","6bca7d88":"## ","6775a469":"## Problem Introduction:\nThis notebook is concerned with classifying images using the **BreakHis** (Breast Cancer Histopathological Image Dataset). Breast cancer is a disease seen mainly in women and is seen as a major cause of death among women. In the year **2018**, the total deaths due to breast cancer in women was seen to be **627,000** out of **2.1 million** cases which were diagnosed. **Invasive Ductual Carcinoma (IDC)** in diagnosing breast cancer, since its subsequent digitalization is more feasible due to advancements in slide scanning technology, as well as the reduction of storage load cost in recent years. The digitialized approcches in deep learning has aided a lot in diagnosing and controlling breast cancer, with power to pre-identify the disease via deep learning methods. ","60647f7c":"First, we load the dara that contains multiple files, one file contains the information anout all images in a csv format, and there is another directory that contains the information about the images of breast cancer tissues.   ","0d1fec75":"## Analysis on Data","fbb9fe59":"The graph sows that most of the samples in our data have malignant tumors, and less have benign tumors","653c3224":"## Loading the Dataset","07ff2f1a":"# BreakHis Cancer Images Classification"}}