{"cell_type":{"fa83740b":"code","f8616414":"code","0b2af35a":"code","8f07469d":"code","c021c31c":"code","40a7a325":"code","f3e8f6c0":"code","02f74386":"code","ffd51ae7":"code","ddf9398f":"code","602e5331":"code","ee3f584c":"code","d3bf918c":"code","960ce917":"code","a7492ff9":"code","19f7c718":"code","8797d535":"code","2a6d71c8":"code","27198667":"code","7e0c43fe":"code","b7cf2c37":"code","f9a9d172":"code","07d3b684":"code","e42425c5":"code","a29f97cb":"code","79a86d0a":"code","59af3745":"code","aea59d3a":"code","e944ea2c":"code","58d8953a":"code","a0ad7867":"code","c90dd583":"code","7ca4cb9a":"code","139650c1":"code","0e3f9b36":"code","01c6d6e0":"code","431a38dc":"code","89982170":"code","2bd327ca":"code","36865bdf":"code","e5457221":"code","116982d7":"code","39d90108":"code","562887f7":"code","52b51061":"code","816d2d3d":"code","dcf1b629":"code","5a329572":"code","ea3c7933":"code","67f6d47c":"code","cbd08816":"code","a7f5c325":"code","a361b8a9":"code","b3b893fc":"code","d0b42da7":"code","428f2ad8":"code","dabcd49b":"code","cd79cc02":"code","e04ec155":"code","1ffcdc01":"code","583997cd":"code","2d5201c4":"code","49bf6a83":"code","87556bfd":"code","56071ac9":"code","d928be63":"code","a7efd26c":"code","cb7564e4":"code","5ddc3d7d":"markdown","5ab40560":"markdown","0c792c7f":"markdown","4152791e":"markdown","02a89015":"markdown","9e7172a5":"markdown","b87784ce":"markdown","ff1b8fc3":"markdown","207fbce3":"markdown","b40528ef":"markdown","222c1b68":"markdown","9709abd8":"markdown","2bdc3cf6":"markdown","14968019":"markdown","656523f6":"markdown","83d9fee2":"markdown","2b65dbc5":"markdown","86712b48":"markdown","7a1509cc":"markdown","9439e320":"markdown","65c9b404":"markdown","c9fb1f2f":"markdown","8944188b":"markdown","ab923d63":"markdown","f2b567f0":"markdown","942c5647":"markdown","ff1207bf":"markdown","e0b61c8e":"markdown","8ed270ca":"markdown","d7a26357":"markdown","c3d17bf7":"markdown","f6563fda":"markdown","87bcd206":"markdown","f527cd09":"markdown","801e07f3":"markdown"},"source":{"fa83740b":"import numpy as np \nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport random\n\npd.set_option('mode.chained_assignment', None)\n\n# Note that there are no NANs in these data; '?' is\n# used when there is missing information\naccepts = pd.read_csv('..\/input\/chefmozaccepts.csv')\ncuisine = pd.read_csv('..\/input\/chefmozcuisine.csv')\nhours = pd.read_csv('..\/input\/chefmozhours4.csv')\nparking = pd.read_csv('..\/input\/chefmozparking.csv')\ngeo = pd.read_csv('..\/input\/geoplaces2.csv') \nusercuisine = pd.read_csv('..\/input\/usercuisine.csv')\npayment = pd.read_csv('..\/input\/userpayment.csv')\nprofile = pd.read_csv('..\/input\/userprofile.csv')\nrating = pd.read_csv('..\/input\/rating_final.csv')","f8616414":"res_all = np.concatenate((accepts.placeID, cuisine.placeID, \n                          hours.placeID, parking.placeID, geo.placeID))\nres_all = np.sort( np.unique(res_all) ) # All the placeID's\n\nprint(\"There are {} restaurants.\".format(len(res_all)))","0b2af35a":"user_all = np.concatenate((usercuisine.userID, payment.userID, profile.userID))\nuser_all = np.sort( np.unique(user_all) ) # All the userID's\n\nprint(\"There are {} users.\".format(len(user_all)))","8f07469d":"rating.head(10) # There are three types of ratings","c021c31c":"print(\"There are {} restaurants with ratings.\".format(len(rating.placeID.unique())))\nprint(\"There are {} users who gave ratings.\".format(len(rating.userID.unique())))","40a7a325":"overall_rating = pd.DataFrame( np.zeros((len(res_all),len(user_all)))-1.0, \n                              columns=user_all, index=res_all )\nfood_rating = overall_rating.copy()\nservice_rating = overall_rating.copy() \n\nfor r, u, o, f, s in zip(rating.placeID, rating.userID, rating.rating, rating.food_rating, \n                         rating.service_rating):\n    overall_rating.loc[r,u] = o\n    food_rating.loc[r,u] = f\n    service_rating.loc[r,u] = s\n\n# This tells us whether a restaurant-user pair has a rating. 0 means No and 1 means Yes.\nreview = pd.DataFrame( np.zeros(overall_rating.shape), columns=user_all, index=res_all)\nreview[overall_rating >= 0] = 1","f3e8f6c0":"cuisine.head(10)","02f74386":"# use dummy variables for different cuisine categories of the restaurants\nres_cuisine = pd.get_dummies(cuisine,columns=['Rcuisine'])\n\n# remove duplicate restaurant ID's. \n# A restaurant with multiple cuisine categories would have multiple columns equal 1\nres_cuisine = res_cuisine.groupby('placeID',as_index=False).sum()","ffd51ae7":"parking.head(10)","ddf9398f":"# use dummy variables for different cuisine categories of the restaurants\nres_parking = pd.get_dummies(parking,columns=['parking_lot'])\n\n# remove duplicate restaurant ID's. \n# A restaurant with multiple parking options would have multiple columns equal 1\nres_parking = res_parking.groupby('placeID',as_index=False).sum()","602e5331":"geo.columns.values","ee3f584c":"geo.head()","d3bf918c":"# These are the ones that I think might be relevant\nres_features = geo[['placeID','alcohol','smoking_area','other_services','price','dress_code',\n                         'accessibility','area']]\n\ndf_res = pd.DataFrame({'placeID': res_all})\ndf_res = pd.merge(left=df_res, right=res_cuisine, how=\"left\", on=\"placeID\")\ndf_res = pd.merge(left=df_res, right=res_parking, how=\"left\", on=\"placeID\")\ndf_res = pd.merge(left=df_res, right=res_features, how=\"left\", on=\"placeID\")","960ce917":"# The placeID's for the 130 restaurants with ratings\nres_rated = res_all[np.sum(review,axis=1) > 0] \n\n# tells us whether a restaurant-user pair has a rating. 0 means No and 1 means Yes.\nR = review.loc[res_rated].values  # shape = (130,138)\n\n# Now these have a shape of (130, 138) too\nY_overall = overall_rating.loc[res_rated].values\nY_food  = food_rating.loc[res_rated].values\nY_service = service_rating.loc[res_rated].values\n\n# select the indices of \"df_res\" where a restaurant has ratings\nindex = [x in res_rated for x in df_res['placeID'].values] #np.array()\n\n# restaurant features for the 130 restaurants with ratings\nX = df_res.loc[index, :].reset_index(drop=True)\n\nX.isnull().sum() # all the NANs are from cuisine ","a7492ff9":"# fill all NANs with 0\nX = X.fillna(0) \n\n# drop a feature if the entire column are 0\nfeatures_to_drop = X.columns.values[np.sum(X,axis=0) == 0] \nX = X.drop(features_to_drop, axis=1)\n\n# drop placeID\nX = X.drop(['placeID'], axis=1)\n\n# There are the restaurant features we'll explore\nX.columns.values ","19f7c718":"profile.columns.values","8797d535":"user_info = profile[['smoker','drink_level','transport','budget','dress_preference']] \n\nprint(user_info.smoker.value_counts())\nprint('\\n')\nprint(user_info.drink_level.value_counts())\nprint('\\n')\nprint(user_info.transport.value_counts())\nprint('\\n')\nprint(user_info.budget.value_counts())\nprint('\\n')\nprint(user_info.dress_preference.value_counts())","2a6d71c8":"user_info.transport = user_info.transport.replace({'public':'no car', 'on foot':'no car'})\nuser_info.dress_preference = user_info.dress_preference.replace({'elegant':'formal'})","27198667":"# Calculate the mean rating for each restaurant\ndef GetMean(Y,R):\n\n    Y = Y*R\n    mean =  (np.sum(Y, axis=1)\/np.sum((R == 1.0), axis=1)).reshape(Y.shape[0],1)\n    return mean\n\nY_overall_mean = GetMean(Y_overall,R)\nY_food_mean = GetMean(Y_food,R)\nY_service_mean = GetMean(Y_service,R)","7e0c43fe":"# This is the function I'll use to plot and print the mean ratings of different \n# groups of restaurants based on different values of a given feature\ndef plot_mean_rating(df,rotate=False):\n    \n    n = df.shape[1]\n    columns = df.columns.values\n    \n    if n > 1:\n        y_overall = [ Y_overall_mean[df[i] == 1].mean() for i in columns ]\n        y_food = [ Y_food_mean[df[i] == 1].mean() for i in columns ]\n        y_service = [ Y_service_mean[df[i] == 1].mean() for i in columns ] \n        y = pd.DataFrame({'overall':y_overall, 'food':y_food, 'service':y_service},\n                         columns=['overall','food','service'],index=columns) \n        ticks = columns\n        \n    else:\n        values = df[columns[0]].unique()\n        values = values[values != '?']\n        y_overall = [ Y_overall_mean[df[columns[0]] == i].mean() for i in values ]\n        y_food = [ Y_food_mean[df[columns[0]] == i].mean() for i in values ]\n        y_service = [ Y_service_mean[df[columns[0]] == i].mean() for i in values ] \n        y = pd.DataFrame({'overall':y_overall, 'food':y_food, 'service':y_service},\n                         columns=['overall','food','service'],index=values) \n        ticks = values\n   \n    fig = plt.figure()\n    plt.plot(range(y.shape[0]),y['overall'],'-o',c='k',label='overall')\n    plt.plot(range(y.shape[0]),y['food'],'-o',c='r',label='food')   \n    plt.plot(range(y.shape[0]),y['service'],'-o',c='b',label='service')\n    plt.xticks(range(y.shape[0]),ticks,fontsize=13)\n    if rotate: plt.xticks(rotation=40)\n    plt.yticks(fontsize=13) \n    if n == 1: plt.xlabel(columns[0],fontsize=15)\n    plt.ylabel('mean rating',fontsize=15)\n    plt.legend(fontsize=15,frameon=False)\n    plt.show()\n    \n    print(y)","b7cf2c37":"# This function is similar to the one above, but this time the result is split\n# into different groups of users as well\ndef plot_mean_rating_split(df,userinfo,rotate=False):\n    \n    n = df.shape[1]\n    columns = df.columns.values\n    \n    cases = userinfo.unique()\n    cases = cases[cases != '?']\n    \n    num = len(cases)\n    y = {}\n    \n    if n > 1:\n        \n        for i in range(num):\n            \n            index = (userinfo == cases[i])\n            R_case = np.zeros(R.shape)\n            R_case[:,index] = R[:,index]\n\n            Y_overall_case = GetMean(Y_overall,R_case)\n            Y_food_case = GetMean(Y_food,R_case)\n            Y_service_case = GetMean(Y_service,R_case)\n        \n            isnan = np.isnan(Y_overall_case).reshape(-1)\n            y_overall = [Y_overall_case[(df[j] == 1) & \n                        (isnan == False)].mean() for j in columns]\n            y_food = [Y_food_case[(df[j] == 1) & \n                     (isnan == False)].mean() for j in columns]\n            y_service = [Y_service_case[(df[j] == 1) & \n                        (isnan == False)].mean() for j in columns]\n            \n            y[cases[i]] = pd.DataFrame({'overall':y_overall, 'food':y_food, 'service':\n                          y_service}, columns=['overall','food','service'],index=columns)\n            \n        ticks = columns\n\n     \n    else:\n        \n        for i in range(num):\n            \n            values = df[columns[0]].unique()\n            values = values[values != '?']\n            \n            index = (userinfo == cases[i])\n            R_case = np.zeros(R.shape)\n            R_case[:,index] = R[:,index]\n\n            Y_overall_case = GetMean(Y_overall,R_case)\n            Y_food_case = GetMean(Y_food,R_case)\n            Y_service_case = GetMean(Y_service,R_case)\n        \n            isnan = np.isnan(Y_overall_case).reshape(-1)\n            y_overall = [Y_overall_case[(df[columns[0]] == j) & \n                        (isnan == False)].mean() for j in values]\n            y_food = [Y_food_case[(df[columns[0]] == j) & \n                     (isnan == False)].mean() for j in values]\n            y_service = [Y_service_case[(df[columns[0]] == j) & \n                        (isnan == False)].mean() for j in values]\n                        \n            y[cases[i]] = pd.DataFrame({'overall':y_overall, 'food':y_food, 'service':\n                          y_service}, columns=['overall','food','service'],index=values)\n\n        ticks = values\n   \n\n    f, (ax1, ax2, ax3) = plt.subplots(1,3, sharex=True, sharey=True, figsize=(24,6))\n \n    color = ['k','r','b'] \n\n    for i in range(num):\n        ax1.plot(range(len(ticks)),y[cases[i]]['overall'],'-o',c=color[i],label=cases[i])\n        ax2.plot(range(len(ticks)),y[cases[i]]['food'],'-o',c=color[i],label=cases[i])\n        ax3.plot(range(len(ticks)),y[cases[i]]['service'],'-o',c=color[i],label=cases[i])\n    \n    ax1.set_title('overall',fontsize=20)\n    ax2.set_title('food',fontsize=20)\n    ax3.set_title('service',fontsize=20)\n\n    ax1.tick_params(labelsize=16)\n    ax2.tick_params(labelsize=16)\n    ax3.tick_params(labelsize=16)\n    \n    if rotate:\n        ax1.set_xticks(range(len(ticks)))\n        ax1.set_xticklabels(ticks, rotation=40)\n        ax2.set_xticks(range(len(ticks)))\n        ax2.set_xticklabels(ticks, rotation=40)\n        ax3.set_xticks(range(len(ticks)))\n        ax3.set_xticklabels(ticks, rotation=40)\n    else:\n        plt.xticks(range(len(ticks)),ticks)\n                           \n    if n == 1: \n        ax2.set_xlabel(columns[0],fontsize=20)\n    \n    ax1.set_ylabel('mean rating',fontsize=20)\n    \n    plt.legend(fontsize=20,frameon=False)\n    plt.show()\n    \n    return y","f9a9d172":"X.price.value_counts()","07d3b684":"user_info.budget.value_counts()","e42425c5":"# mean rating as a function of price\nplot_mean_rating(X[['price']])","a29f97cb":"# mean rating as a function of price, split into three groups of consumers\n# with low, medium, and high budget\ny = plot_mean_rating_split(X[['price']],user_info.budget)\n\nprint('low budget:')\nprint(y['low'])\nprint('\\nmedium budget:')\nprint(y['medium'])\nprint('\\nhigh budget:')\nprint(y['high'])","79a86d0a":"columns = ['parking_lot_none','parking_lot_public', 'parking_lot_valet parking','parking_lot_yes']\nX[columns].sum()","59af3745":"X[columns].sum().sum()","aea59d3a":"user_info.transport.value_counts()","e944ea2c":"# mean rating as a function of parking option\nplot_mean_rating(X[columns], rotate=True)","58d8953a":"# mean rating as a function of parking option, split into car owners and\n# non car owners\ny = plot_mean_rating_split(X[columns],user_info.transport,rotate=True)\n\nprint('no car:')\nprint(y['no car'])\nprint('\\ncar owner:')\nprint(y['car owner'])","a0ad7867":"X.price[X['parking_lot_valet parking']==1].value_counts()","c90dd583":"X.price[X['parking_lot_public']==1].value_counts()","7ca4cb9a":"X.price[X['parking_lot_none']==1].value_counts()","139650c1":"X.smoking_area.value_counts()","0e3f9b36":"user_info.smoker.value_counts()","01c6d6e0":"# mean rating as a function of smoking area\nplot_mean_rating(X[['smoking_area']])","431a38dc":"# mean rating as a function of smoking area, split into smokers and\n# non smokers\ny = plot_mean_rating_split(X[['smoking_area']],user_info.smoker)\n\nprint('false:')\nprint(y['false'])\nprint('\\ntrue:')\nprint(y['true'])","89982170":"X.alcohol.value_counts()","2bd327ca":"user_info.drink_level.value_counts()","36865bdf":"# mean rating as a function of alcohol\nplot_mean_rating(X[['alcohol']])","e5457221":"# mean rating as a function of smoking alcohol, split into abstemious, \n# casual and social drinkers\ny = plot_mean_rating_split(X[['alcohol']],user_info.drink_level)\n\nprint('abstemious:')\nprint(y['abstemious'])\nprint('\\ncasual drinker:')\nprint(y['casual drinker'])\nprint('\\nsocial drinker:')\nprint(y['social drinker'])","116982d7":"X.price[X.alcohol == 'No_Alcohol_Served'].value_counts()","39d90108":"X.price[X.alcohol == 'Wine-Beer'].value_counts()","562887f7":"X.price[X.alcohol == 'Full_Bar'].value_counts()","52b51061":"X.other_services.value_counts()","816d2d3d":"# mean rating as a function of other_services\nplot_mean_rating(X[['other_services']])","dcf1b629":"X.price[X.other_services == 'variety'].value_counts()","5a329572":"X.price[X.other_services == 'Internet'].value_counts()","ea3c7933":"X.price[X.other_services == 'none'].value_counts()","67f6d47c":"X.dress_code.value_counts()","cbd08816":"# mean rating as a function of dress code\nplot_mean_rating(X[['dress_code']])","a7f5c325":"# mean rating as a function of smoking alcohol, split into different \n# groups of consumers with different dress preferences\ny = plot_mean_rating_split(X[['dress_code']],user_info.dress_preference)\n\nprint('no preference:')\nprint(y['no preference'])\nprint('\\ninformal:')\nprint(y['informal'])\nprint('\\nformal:')\nprint(y['formal'])","a361b8a9":"X.price[X.dress_code == 'formal'].value_counts()","b3b893fc":"X.price[X.dress_code == 'informal'].value_counts()","d0b42da7":"X.price[X.dress_code == 'casual'].value_counts()","428f2ad8":"X.accessibility.value_counts()","dabcd49b":"# mean rating as a function of dress accessibility\nplot_mean_rating(X[['accessibility']])","cd79cc02":"X.price[X.accessibility == 'partially'].value_counts()","e04ec155":"X.price[X.accessibility == 'no_accessibility'].value_counts()","1ffcdc01":"X.price[X.accessibility == 'completely'].value_counts()","583997cd":"X.area.value_counts()","2d5201c4":"# mean rating as a function of area\nplot_mean_rating(X[['area']])","49bf6a83":"# the number of restaurants for each cuisine type \nX.iloc[:,:23].sum()","87556bfd":"# Besides Mexican, Cafeteria and Fast_Food, group the other types into \n# the following 5 types\n\nX['Rcuisine_Bar_Pub'] = np.zeros(X.shape[0])\nindex = ((X.Rcuisine_Bar == 1) | (X.Rcuisine_Bar_Pub_Brewery == 1))\nX.loc[index,'Rcuisine_Bar_Pub'] = 1\n\nX['Rcuisine_Asian'] = np.zeros(X.shape[0])\nindex = ((X.Rcuisine_Chinese == 1) | (X.Rcuisine_Japanese == 1) | (X.Rcuisine_Vietnamese == 1))\nX.loc[index,'Rcuisine_Asian'] = 1\n\nX['Rcuisine_Western'] = np.zeros(X.shape[0])\nindex = ((X.Rcuisine_Armenian == 1) | (X.Rcuisine_Italian == 1) | (X.Rcuisine_Mediterranean == 1) \n         | (X.Rcuisine_Pizzeria == 1) | (X.Rcuisine_Seafood == 1))\nX.loc[index,'Rcuisine_Western'] = 1\n\nX['Rcuisine_American_Burgers'] = np.zeros(X.shape[0])\nindex = ((X.Rcuisine_American == 1) | (X.Rcuisine_Burgers == 1))\nX.loc[index,'Rcuisine_American_Burgers'] = 1\n\nX['Rcuisine_Others'] = np.zeros(X.shape[0])\nindex = (((X.Rcuisine_Bakery == 1) | (X[\"Rcuisine_Breakfast-Brunch\"] == 1) | (X[\"Rcuisine_Cafe-Coffee_Shop\"] == 1) \n        | (X.Rcuisine_Contemporary == 1) | (X.Rcuisine_Family == 1) | (X.Rcuisine_Game == 1) \n        | (X.Rcuisine_International == 1) | (X.Rcuisine_Regional == 1)))\nX.loc[index,'Rcuisine_Others'] = 1","56071ac9":"print(\"Number of restaurants for each type\")\nprint(\"Mexican: {}\".format(int(X.Rcuisine_Mexican.sum())))\nprint(\"American\/Burgers: {}\".format(int(X.Rcuisine_American_Burgers.sum())))\nprint(\"Asian: {}\".format(int(X.Rcuisine_Asian.sum()))) \nprint(\"Bar\/Pub: {}\".format(int(X.Rcuisine_Bar_Pub.sum()))) \nprint(\"Cafeteria: {}\".format(int(X.Rcuisine_Cafeteria.sum()))) \nprint(\"Fast Food: {}\".format(int(X.Rcuisine_Fast_Food.sum()))) \nprint(\"Others: {}\".format(int(X.Rcuisine_Others.sum())))\nprint(\"Western: {}\".format(int(X.Rcuisine_Western.sum())))","d928be63":"columns = ['Rcuisine_Mexican','Rcuisine_American_Burgers', 'Rcuisine_Asian','Rcuisine_Bar_Pub', 'Rcuisine_Cafeteria',\n           'Rcuisine_Fast_Food','Rcuisine_Others','Rcuisine_Western']\nplot_mean_rating(X[columns],rotate=True)","a7efd26c":"X_cuisine = X[['Rcuisine_Mexican','Rcuisine_American_Burgers','Rcuisine_Asian','Rcuisine_Bar_Pub','Rcuisine_Cafeteria',\n           'Rcuisine_Fast_Food','Rcuisine_Western','Rcuisine_Others']]\n\nX_cuisine['Y_food'] = Y_food_mean\nX_cuisine['Y_overall'] = Y_overall_mean\nX_cuisine['Y_service'] = Y_service_mean","cb7564e4":"print(X_cuisine.corr()['Y_overall'][:-3])\nprint('\\n')\nprint(X_cuisine.corr()['Y_food'][:-3])\nprint('\\n')\nprint(X_cuisine.corr()['Y_service'][:-3])\nprint('\\n')","5ddc3d7d":"I will now create three data frames for the three types of rating, each of which will have a shape of (938, 138). A restaurant-user pair without a rating will be recorded as -1 (to be different from 0, the lowest rating).","5ab40560":"The sum is 130, which means each of these 130 restaurants actually only has one parking option (there were restaurants without ratings that have multiple parking options).","0c792c7f":"## Conclusion","4152791e":"Now let's select some of the user features that are related to the restaurant features","02a89015":"Let's select some columns from **geo** that might affect the ratings.","9e7172a5":"**Observations: ** On average, the order of price is **Full_Bar** > **Wine-Beer** > **No_Alcohol_Served**, which does not explain the ratings drinkers of abstemious and social drinkers.","b87784ce":"**Observations: ** Although the correlations are slightly different between different ratings, **Rcuisine_Others** generally gets higher ratings and **Rcuisine_Fast_Food** generally gets lower ratings. Asian restaurants perform really well at food rating. Interestingly, Mexican restaurants have above than average food rating but just roughly average overall and service ratings.  ","ff1b8fc3":"Now I'll go over all the restaurant features that are stored in **X**\n\n### Price","207fbce3":"**Observations: ** You get what you pay for? In general, restaurants with medium or high price have higher ratings (high ~ medium > low). However, the consumers with high budget actually prefer medium-price restaurants over high-price ones.","b40528ef":"# What Affects the Ratings?\n\n**By Li-Yen Hsu (11\/08\/2017)**\n<br><br>\n  In another [kernel](https:\/\/www.kaggle.com\/liyenhsu\/simple-content-based-recommenders), I implemented two content-based recommender systems and tried the [SVD algorithm](http:\/\/sifter.org\/simon\/journal\/20061211.html) using [Surprise](http:\/\/surpriselib.com\/). In this kernel, I will focus on data exploration, looking for correlations within the data.\n<br><br>\n  It's obvious that the main factors that affect the ratings are (1) how delicious the food is, and (2) how well a customer is served. These two are definitely not something that are in the data. But some of the features of a restaurant still have some influence on the ratings. For a content-based approach, selecting the relevant features is important for the rating prediction.","222c1b68":"### Cuisine","9709abd8":"Let's also check the correlation coefficients between these cuisine types and the ratings","2bdc3cf6":"**Observations: ** (1) Surprisingly, public parking is the least popular one, and it's worse than no parking. (2) Valet parking is the most popular one, although there are only three restaurants with this option. (3) Food rating changes the least among all three types of ratings, which makes sense since it shouldn't be affected by parking options at all. (4) The trend of ratings from car owners is actually not very different from non car owners.\n<br><br>\nIs it possible that parking options don't matter? Let's see if the trend we see above can be explained by **price**, as we found previously that restaurants with medium or high price generally get higher ratings.\n","14968019":"**Observations: ** If accessibility could affect the rating, we would expect **completely > partially > no_accessibility**. However, this is not we see here. In the following, we can see that the trend is simply due to price again.","656523f6":"### Other Services","83d9fee2":"I'll be looking at the restaurant features from **cuisine, parking** and **geo**. The payment options and business hours should have very little effects on the rating, so I won't look into **accepts** and **hours** here.","2b65dbc5":"**Observations: ** Restaurants that require the customers to dress formally have the highest ratings. This is not a surprise because they should be expensive\/high-class restaurants. Again, we can check the corresponding price in the following.","86712b48":"So **smoker**, **drink_level**, **transport**, **budget** and **dress_preference** are related to **smoking_area**, **alcohol**, **parking options** (**parking_lot_none**, **parking_lot_public**, **parking_lot_valet parking** and **parking_lot_yes**), **price**, and **dress_code**","7a1509cc":"### Smoking Area","9439e320":"### Alcohol","65c9b404":"### Parking Options","c9fb1f2f":"**Observations: ** The order of rating is **Variety** > **Internet** > **None**, consistent with the amount of other service provided.\n<br><br>\nAgain, is it just caused by **price**?","8944188b":"### Area","ab923d63":"So what features affect the ratings? \n- **Price** is definitely one. Generally medium and high-price restaurants have better rating. However, it may be better to transform the original categories (low, medium, high) using dummy variables (one-hot encoding) instead of directly mapping them to numbers (such as 1,2,3). This is because we saw that people with different budget actually react differently on the price change.\n<br><br>\n- **Parking options** can affect the ratings too, but not the food rating. Also, it only matters to car owners. It's probably only necessary to distinguish between public parking and the other options (including no parking) because we saw that restaurants with public parking have significantly lower overall and service ratings.\n<br><br>\n- **Smoking Area** is only important for smokers. Especially, restaurants that do not allow smoking are low rated, and restaurants with their smoking area located at bar are highly rated.\n<br><br>\n- **Alcohol** is also relevant but different types of drinkers react differently on the change of alcohol service (No_Alcohol_Served, Wine-Beer, Full_Bar). Similar to **Price**, it may be better to transform the original three categories using dummy variables.\n<br><br>\n- **Other Services** has influence on the ratings. We saw that restaurants with a variety of other service perform better than those with only Internet. And those with Internet are better than those without other services. \n<br><br>\n- The effect of **Dress Code** on the ratings is probably due to **Price**. However, there are only two restaurants that require the customers to dress formally and their ratings are close to 2. I would keep a feature (0 or 1) to show whether a restaurant has formal dress code because when this condition is true, the ratings are essentially guaranteed to be very good.\n<br><br>\n- **Accessibility** does not affect the ratings. For **Area**, people prefer closed space over open space. For **Cuisine**, what restaurant\/food types are relevant depend on which rating we are trying to predict. But in general, some types have significant influence. For example, fast food restaurants generally have low ratings. ","f2b567f0":"**Observations: ** Abstemious drinkers prefer **Wine-Beer**; casual drinkers prefer **Full_Bar**; but it's not so clear for social drinkers.\n<br><br>\nLet's check again if the trend we see above can be explained by **price**.","942c5647":"From now on I will use four (130,138) arrays, **R, Y_overall, Y_food** and **Y_service**, for their ratings, where the axis=0 dimension is for the restaurants and the axis=1 dimension is for the consumers. The elements of **R** are either 0 or 1, showing whether a restaurant-user pair has a rating. The information of the restaurants will be recorded in a (130,n_feature) array, **X**.","ff1207bf":"**Observations: ** Food rating does not depend on **area**, but from overall and service ratings, we can tell that consumers still prefer closed area over open area.","e0b61c8e":"## Data Preprocessing ##\nThis part is pretty much the same as another [kernel](https:\/\/www.kaggle.com\/liyenhsu\/simple-content-based-recommenders) I posted. Please go there for a more complete description.","8ed270ca":"### Accessibility","d7a26357":"**Observations: ** (1) Non smokers do not care much about smoking area. (2) For smokers, **only at bar** is very popular, while **not permitted** leads to very low ratings. (3) Surprisingly, **none** and **not permitted** have very different mean ratings. Originally I thought these two mean the same thing. It's probably because smokers can still find a place to smoke at those restaurants without a smoking area but are completely not allowed to do so at those **not permitted** ones.","c3d17bf7":"## Exploratory Visualization\nIn order to see how the restaurant features affect the ratings, I will first get the mean rating for each restaurant. And then for each feature, I will show how the rating changes with different feature values. To do this, I will group the restaurants based on the different feature values and then average the mean ratings mentioned above for each group. Notice that what I do is **NOT** averaging all the ratings with the feature equals to a certain value. Instead, it is first getting the mean rating for each restaurant and then grouping. If I used the former approach, the mean rating of a group would be biased towards the restaurants with more ratings. This should be avoided because we want to treat every restaurant equally.","f6563fda":"Before exploring these data, I will combine 'public' and 'on foot' of **transport** into just one category, 'no car', because these two types of people would feel the same about whether there is a parking lot. Similarly, 'elegant' and 'formal' of **dress_preference** will be merged to just one category, 'formal'.","87bcd206":"**Observations: ** Apparently the restaurants with valet parking are the expensive\/high-class ones, which is why they are highly rated. The compositions of the restaurants with public parking and no parking are similar; about half of either group are low-price restaurants. So the different ratings between these two groups given by car owners might be real. Maybe it's because public parking is expensive? ","f527cd09":"**Observations: ** Restaurants with **Internet** actually have a higher mean price than those with **Variety**. So the ratings are indeed affected by the amount of other service provided.","801e07f3":"### Dress Code"}}