{"cell_type":{"923ce682":"code","64975e53":"code","4dc163c8":"code","8e911c20":"code","5d5c2840":"code","60371b0f":"code","942b2272":"code","354dda84":"code","34b48e5a":"code","010300cb":"markdown","b7420caf":"markdown","a8970812":"markdown","9edefd19":"markdown","9b845d1a":"markdown"},"source":{"923ce682":"import matplotlib as mat\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport pandas as pd\n\nimport seaborn as sns\n\npd.options.display.max_colwidth = 100\n\nimport os\nimport random\n\nimport numpy as np\nfrom numpy.random import seed\nseed(42)\nrandom.seed(42)\nos.environ['PYTHONHASHSEED'] = str(42)\nos.environ['TF_DETERMINISTIC_OPS'] = '1'\n\n\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\nfrom tensorflow.keras import callbacks\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.random import set_seed\nset_seed(42)\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import metrics\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.metrics import precision_score\nfrom sklearn.metrics import recall_score\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.datasets import make_classification\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import roc_curve\n\n\nfrom tensorflow.keras import Sequential\n\nfrom sklearn.metrics import classification_report, confusion_matrix, auc\n\nimport cv2\nimport glob\n\nimport warnings\nwarnings.filterwarnings('ignore')","64975e53":"IMG_SIZE = 150\nBATCH = 64\nSEED = 42","4dc163c8":"main_path = \"..\/input\/labeled-chest-xray-images\/chest_xray\"\n\ntrain_path = os.path.join(main_path,\"train\")\ntest_path=os.path.join(main_path,\"test\")\n\ntrain_normal = glob.glob(train_path+\"\/NORMAL\/*.jpeg\")\ntrain_pneumonia = glob.glob(train_path+\"\/PNEUMONIA\/*.jpeg\")\n\ntest_normal = glob.glob(test_path+\"\/NORMAL\/*.jpeg\")\ntest_pneumonia = glob.glob(test_path+\"\/PNEUMONIA\/*.jpeg\")\n\ntrain_list = [x for x in train_normal]\ntrain_list.extend([x for x in train_pneumonia])\n\ndf_train = pd.DataFrame(np.concatenate([['Normal']*len(train_normal) , ['Pneumonia']*len(train_pneumonia)]), columns = ['class'])\ndf_train['image'] = [x for x in train_list]\n\ntest_list = [x for x in test_normal]\ntest_list.extend([x for x in test_pneumonia])\n\ndf_test = pd.DataFrame(np.concatenate([['Normal']*len(test_normal) , ['Pneumonia']*len(test_pneumonia)]), columns = ['class'])\ndf_test['image'] = [x for x in test_list]","8e911c20":"train_df, val_df = train_test_split(df_train, test_size = 0.20, random_state = SEED, stratify = df_train['class'])","5d5c2840":"train_datagen = ImageDataGenerator(rescale=1\/255.,\n                                  zoom_range = 0.1,\n                                  #rotation_range = 0.1,\n                                  width_shift_range = 0.1,\n                                  height_shift_range = 0.1)\n\nval_datagen = ImageDataGenerator(rescale=1\/255.)\n\nds_train = train_datagen.flow_from_dataframe(train_df,\n                                             #directory=train_path, #dataframe contains the full paths\n                                             x_col = 'image',\n                                             y_col = 'class',\n                                             target_size = (IMG_SIZE, IMG_SIZE),\n                                             class_mode = 'binary',\n                                             batch_size = BATCH,\n                                             seed = SEED)\n\nds_val = val_datagen.flow_from_dataframe(val_df,\n                                            #directory=train_path,\n                                            x_col = 'image',\n                                            y_col = 'class',\n                                            target_size = (IMG_SIZE, IMG_SIZE),\n                                            class_mode = 'binary',\n                                            batch_size = BATCH,\n                                            seed = SEED)\n\nds_test = val_datagen.flow_from_dataframe(df_test,\n                                            #directory=test_path,\n                                            x_col = 'image',\n                                            y_col = 'class',\n                                            target_size = (IMG_SIZE, IMG_SIZE),\n                                            class_mode = 'binary',\n                                            batch_size = 1,\n                                            shuffle = False)","60371b0f":"def get_model():\n    inputs = layers.Input(shape=(IMG_SIZE, IMG_SIZE, 3))\n    \n    # Block One\n    x = layers.Conv2D(filters=1, kernel_size=3, padding='valid')(inputs)\n    x = layers.BatchNormalization()(x)\n    x = layers.Activation('relu')(x)\n    x = layers.MaxPool2D()(x)\n  \n    # Block Two\n    x = layers.Conv2D(filters=3, kernel_size=5, padding='valid')(x)\n    x = layers.BatchNormalization()(x)\n    x = layers.Activation('relu')(x)\n    x = layers.MaxPool2D()(x)\n\n    # Block\n    x = layers.BatchNormalization()(x)\n    x = layers.Activation('relu')(x)\n    x = layers.Dropout(0.5)(x)\n    x = layers.GlobalAveragePooling2D()(x)\n    \n    x = layers.Flatten()(x)\n    x = layers.Dense(128, activation='relu')(x)\n    x = layers.Dropout(0.5)(x)\n    \n    output = layers.Dense(1, activation='sigmoid')(x)\n    model = keras.Model(inputs=[inputs], outputs=output)\n    \n    return model","942b2272":"keras.backend.clear_session()\n\nmodel = get_model()\nmodel.compile(loss='binary_crossentropy', optimizer = keras.optimizers.Adam(learning_rate=0.00003), metrics='binary_accuracy')\n\nmodel.summary()","354dda84":"history = model.fit(ds_train,\n          batch_size = BATCH, epochs = 50,\n          validation_data=ds_val,\n          steps_per_epoch=(len(train_df)\/BATCH),\n          validation_steps=(len(val_df)\/BATCH));","34b48e5a":"X_test, y_test = next(ds_train)\nds_train.reset()\n\ny_pred = model.predict(X_test, batch_size=BATCH, verbose=1)\ny_pred_bool = np.argmax(y_pred, axis=1)\n\nprint(classification_report(y_test, y_pred_bool))","010300cb":"# Fontes:\n\nhttps:\/\/www.kaggle.com\/jonaspalucibarbosa\/chest-x-ray-pneumonia-cnn-transfer-learning\/notebook\n\nhttps:\/\/www.kaggle.com\/tolgadincer\/labeled-chest-xray-images","b7420caf":"# Conclus\u00e3o\n\n```\nO modelo CNN proposto por Liang e Zheng obtem bons resultados assim como a implementa\u00e7\u00e3o aqui abordada. Gostaria apenas de ter tido mais tempo para analisar o mesmo uma vez que \u00e9 um tema muito rico e com infinitas aplica\u00e7\u00f5es. No geral acredito que este trabalho conseguiu obter bons resultados.\n```","a8970812":"# Modelo CNN de Liang e Zheng: ","9edefd19":"# m\u00e9tricas de desempenho:","9b845d1a":"\n# Projeto 3 da disciplina Introdu\u00e7\u00e3o a inteligencia artificial - UnB\n```\nAluno: Daniel Rodrigues Cardoso - 190064064\nProfessor: Dibio\nSemestre: 2020\/1\n```"}}