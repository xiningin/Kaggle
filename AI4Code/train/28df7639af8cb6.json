{"cell_type":{"4363fdf5":"code","f3344043":"code","b3676afe":"code","ef6c79d1":"code","5f783939":"code","1a1d8a87":"code","11d60765":"code","97b0df5e":"code","930f9681":"code","817fdc95":"code","570df461":"code","699ce0c0":"code","a693156d":"markdown","0f3886d1":"markdown","78feb78e":"markdown","8889804f":"markdown","d43581af":"markdown","3f185f5e":"markdown","b65119f4":"markdown","9831ca27":"markdown"},"source":{"4363fdf5":"import numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\nfrom scipy.signal import convolve2d","f3344043":"imsize=256","b3676afe":"im=cv2.imread('..\/input\/lena-pic\/lena.jpg')\n\nim=cv2.cvtColor(im,cv2.COLOR_RGB2GRAY)\nim=cv2.resize(im,(imsize,imsize))\n\nx=im\/255.","ef6c79d1":"noise_img=np.clip(x+np.random.normal(scale=0.1,size=x.shape),0,1)\n\nfig,ax=plt.subplots(ncols=2,figsize=(20,20))\n\nax[0].imshow(x,cmap='gray')\nax[0].set_title('Origin Image',fontsize=20)\nax[1].imshow(noise_img,cmap='gray')\nax[1].set_title('Noised Image',fontsize=20)\nplt.show()","5f783939":"#hyperparameter for admm, see rof \n\nBETA=1  # if beta is larger, the reconstruction image will be more blur --> better total variation minimization\nMU=10  #if mu is larger, the reconstruction image will be more close to observation ","1a1d8a87":"#Div: compute laplacian of signal (this can replace by laplacian filter + conv)\n#in partial differential equation, we usually use u notation for signal\ndef Div(u): \n    m,n=u.shape\n    div=np.zeros((n,m,2))\n    \n    #preorder difference \n    div[:-1,:,0]=u[1:,:]-u[:-1,:] #(i+1,j)-(i,j)\n    div[:,:-1,1]=u[:,1:]-u[:,:-1] #(i,j+1)-(i,j)\n    \n    #postorder difference \n    div[1:,:,0]=-(div[1:,:,0]-div[:-1,:,0]) #(i,j)-(i-1,j)\n    div[:,1:,1]=-(div[:,1:,1]-div[:,:-1,1]) #(i,j)-(i,j-1)\n    \n    div=np.sum(div,axis=-1)  #[dx dy].T @ [dx dy] \n    return div","11d60765":"def ConjGrad(u,b,N):\n    Cu=BETA*Div(u)+MU*u\n    Qu=BETA*Div(Cu)+MU*Cu\n    \n    b=BETA*Div(b)+MU*b\n    d=b-Qu\n    g=-d\n    \n    \n    for i in range(N):\n        #update u\n        \n        Cd=BETA*Div(d)+MU*d\n        Qd=BETA*Div(Cd)+MU*Cd\n        \n        alpha=-g.ravel()@d.ravel()\/(d.ravel()@Qd.ravel())\n        u=u+alpha*d\n        \n        #update gradient\n        Cu=BETA*Div(u)+MU*u\n        Qu=BETA*Div(Cu)+MU*Cu\n        g=Qu-b\n        \n        #update beta\n        beta=g.ravel()@Qd.ravel()\/(d.ravel()@Qd.ravel())\n        d=-g+BETA*d\n        \n        if np.linalg.norm(g)<1e-10:\n            break\n    return u","97b0df5e":"def ROF(f,niters=200,cgiters=100):\n    m,n=f.shape\n    \n    u=f\n    v=np.zeros((m,n,2))\n    lamb=np.zeros((n,m,2))\n    \n    loop=tqdm(range(niters))\n    for i in loop:\n        gradu=np.zeros((m,n,2))\n        #preorder difference\n        gradu[:-1,:,0]=u[1:,:]-u[:-1,:]\n        gradu[:,:-1,1]=u[:,1:]-u[:,:-1]\n        lamb=lamb-BETA*(gradu-v)\n        \n        #total variation\n        tv=np.sum(np.sqrt(np.sum(np.square(gradu),axis=-1)))\n        loop.set_postfix(total_variation=tv)\n        if i!=0:\n            if np.abs(tv-temp)<=1:\n                break\n        temp=tv\n        \n        #update v\n        w=gradu-lamb\/BETA\n        v=np.maximum(np.abs(w)-1\/BETA,0)*w\/(np.abs(w)+1e-10) #shrinkage for l1 regression\n        \n        \n        #update u\n        #tgrad=transpose gradient \n        \n        tgradv=np.zeros((m,n,2))\n        tgradv[1:,:,0]=-(v[1:,:,0]-v[:-1,:,0])\n        tgradv[:,1:,1]=-(v[:,1:,1]-v[:,:-1,1])\n        tgradv=np.sum(tgradv,axis=-1)\n        \n        \n        tgradlamb=np.zeros((m,n,2))\n        tgradlamb[1:,:,0]=-(lamb[1:,:,0]-lamb[:-1,:,0])\n        tgradlamb[:,1:,1]=-(lamb[:,1:,1]-lamb[:,:-1,1])\n        tgradlamb=np.sum(tgradlamb,axis=-1)\n        \n        b=BETA*tgradv+tgradlamb+MU*f\n        u=ConjGrad(u,b,cgiters)\n    \n    return u","930f9681":"u=ROF(noise_img)","817fdc95":"def compute_psnr(img1, img2):\n    #input 0~1\n    mse = np.mean( (img1 - img2) ** 2 )\n    if mse < 1.0e-10:\n        return 100\n    PIXEL_MAX = 1\n    return 20 * np.math.log10(PIXEL_MAX \/ np.math.sqrt(mse))\n","570df461":"def matlab_style_gauss2D(shape=(3,3),sigma=0.5):\n    m,n = [(ss-1.)\/2. for ss in shape]\n    y,x = np.ogrid[-m:m+1,-n:n+1]\n    h = np.exp( -(x*x + y*y) \/ (2.*sigma*sigma) )\n    h[ h < np.finfo(h.dtype).eps*h.max() ] = 0\n    sumh = h.sum()\n    if sumh != 0:\n        h \/= sumh\n    return h\n \ndef filter2(x, kernel, mode='same'):\n    return convolve2d(x, np.rot90(kernel, 2), mode=mode)\n \ndef compute_ssim(im1, im2, k1=0.01, k2=0.03, win_size=11, L=255):\n \n    if not im1.shape == im2.shape:\n        raise ValueError(\"Input Imagees must have the same dimensions\")\n    if len(im1.shape) > 2:\n        raise ValueError(\"Please input the images with 1 channel\")\n \n    M, N = im1.shape\n    C1 = (k1*L)**2\n    C2 = (k2*L)**2\n    window = matlab_style_gauss2D(shape=(win_size,win_size), sigma=1.5)\n    window = window\/np.sum(np.sum(window))\n \n    if im1.dtype == np.uint8:\n        im1 = np.double(im1)\n    if im2.dtype == np.uint8:\n        im2 = np.double(im2)\n \n    mu1 = filter2(im1, window, 'valid')\n    mu2 = filter2(im2, window, 'valid')\n    mu1_sq = mu1 * mu1\n    mu2_sq = mu2 * mu2\n    mu1_mu2 = mu1 * mu2\n    sigma1_sq = filter2(im1*im1, window, 'valid') - mu1_sq\n    sigma2_sq = filter2(im2*im2, window, 'valid') - mu2_sq\n    sigmal2 = filter2(im1*im2, window, 'valid') - mu1_mu2\n \n    ssim_map = ((2*mu1_mu2+C1) * (2*sigmal2+C2)) \/ ((mu1_sq+mu2_sq+C1) * (sigma1_sq+sigma2_sq+C2))\n \n    return np.mean(np.mean(ssim_map))\n","699ce0c0":"fig,ax=plt.subplots(ncols=3,figsize=(20,20))\n\n\npsnr=[np.float16(compute_psnr(x,im)) for im in [x,noise_img,u]]\nssim=[np.float16(compute_ssim(x,im,L=1.)) for im in [x,noise_img,u]]\n\nax[0].imshow(x,cmap='gray')\nax[0].set_title('Origin Image',fontsize=20)\nax[0].set_xlabel(f'psnr:{psnr[0]}  ssim:{ssim[0]}')\n\nax[1].imshow(noise_img,cmap='gray')\nax[1].set_title('Noised Image',fontsize=20)\nax[1].set_xlabel(f'psnr:{psnr[1]}  ssim:{ssim[1]}')\n\nax[2].imshow(u,cmap='gray')\nax[2].set_title('Denoised Image',fontsize=20)\nax[2].set_xlabel(f'psnr:{psnr[2]}  ssim:{ssim[2]}')\nplt.savefig('.\/result.png')\nplt.show()","a693156d":"#### Show Result","0f3886d1":"#### The conjugate gradient method is to solve linear system Ax=b in A non-invertible case which is usually happened in real world application, this part also can be replaced by fourier transform which is used to solve partial differential equation $u_{xx}+u=b$ and can consider as Au=b because linearity of differetial operator\n","78feb78e":"### ROF Model\n\n\n#### Suppose we observe a noised image f, we want to find a true image u which has low total variation and not far from observation f, so the problem can be written as following : \n$$\\mathop{min}\\limits_{u} ||\\nabla{u}||+\\frac{\\mu}{2}||u-f||^2$$\n\n#### Then trasnfroming the problem by ADMM method\n\n$$\\mathop{min}\\limits_{u,v} ||v||_1+\\frac{\\mu}{2}||u-f||^2-\\lambda(\\nabla{u}-v)+\\frac{\\beta}{2}||\\nabla{u}-v||^2\\ \\ \\ \\ s.t\\ \\ \\ \\ \\ v=\\nabla{u} $$\n\n\n","8889804f":"Best : $50 \\leq psnr <100$\n\nSecond : $30 \\leq psnr<50$\n\nThird : $20 \\leq psnr <30$\n\nForth : $10 \\leq psnr <20$\n\nWorst : $0< \\leq psnr <10$","d43581af":"#### Here we use PSNR metric to measure the denoise quality, expect the reconstruction not far from ground truth","3f185f5e":"#### In practice, we don't construct laplacian matrix because image is too big, so we compute laplacian of signal directly or using laplacian filter and do convolution on signal ","b65119f4":"#### Structure Similarity","9831ca27":"#### I want to share my work in my College Optimization Course, this work is for denoising image by two method called ROF & conjugate gradient\n\nMathematical detail of the model :\n\n   * [Conjugate Gradient ](https:\/\/drive.google.com\/file\/d\/1vddKOgSYlqO6bz529J3-bNYvo5w8MxA6\/view?usp=sharing)\n   \n   * [ROF](https:\/\/drive.google.com\/file\/d\/1Yisb8UwWNkAZTtITjOzDE_TNcAfuXmTt\/view?usp=sharing)"}}