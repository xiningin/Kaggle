{"cell_type":{"5f1e19e9":"code","e794a44a":"code","d3a32e2d":"code","4eac6978":"code","54dc1f3c":"code","ea37448d":"code","4a10f268":"code","0bba0adc":"code","61c2ce1b":"code","6e55b4ea":"code","1f75d67b":"code","a92e9fef":"code","c4ba217c":"code","ad1f02d4":"code","4b929632":"code","b1d1da6d":"code","4f932c55":"code","9f121b49":"code","631a8ef5":"code","3c31363d":"code","294e151c":"code","85f820d7":"code","799dd3a5":"code","a10d83f8":"code","40b7ef09":"code","237d9c39":"code","bf22a276":"code","eb32caa8":"code","91ffb6f4":"code","ae2e619c":"code","87a4d725":"code","70d35dbb":"code","7cdbfbe6":"markdown","648dd5bb":"markdown","bb0ef780":"markdown","89093d03":"markdown","324462d6":"markdown","c48c4593":"markdown","a001bfa3":"markdown","1a77d4f4":"markdown","eb37ce3d":"markdown","7025ff83":"markdown","dc349408":"markdown","4b3bcdd5":"markdown","446499e3":"markdown","a4e650cf":"markdown","0977a043":"markdown","3f94b915":"markdown","899754d1":"markdown","7fddeac2":"markdown","4a31069d":"markdown","c865f053":"markdown","be4b0427":"markdown","c72ded9c":"markdown","4b05b97a":"markdown","eee09272":"markdown","d996f7a8":"markdown","50c2edb9":"markdown","1ae5e4a6":"markdown","8e580f5b":"markdown","88035526":"markdown","3a245ebb":"markdown","85cddfe3":"markdown","fe0e434b":"markdown","617f0347":"markdown","7d010828":"markdown","35c7a789":"markdown","eb6cee0a":"markdown","b6fb5ac6":"markdown","8c7ae4d2":"markdown","a0294c93":"markdown","b86f9ee9":"markdown","b2d5c08c":"markdown","68dc1519":"markdown","1920121a":"markdown","9b8af3b2":"markdown","d64fd7e6":"markdown","e97a71d2":"markdown","38f4147b":"markdown","b3fbddf2":"markdown","98599880":"markdown","d3979de0":"markdown","22ea1b0b":"markdown","e117a8d1":"markdown","bc406018":"markdown","6db3443b":"markdown","25f4ec9a":"markdown","6d93b3a2":"markdown","31543559":"markdown","1b2af2f1":"markdown","7a0c4558":"markdown"},"source":{"5f1e19e9":"import numpy as np\nprint(np.array([1,2,3,4]))\n\nprint('\\n', 'array of 16 bit integers')\nprint(np.array([1,2,3,4], dtype=np.int16))\n\nprint('\\n', '2 dimensional array')\nprint(np.array([[1,2,3], [4,5,6]]))","e794a44a":"print('Numpy array from range')\nprint(np.arange(3,8))\n\nprint('\\n', '2D 3X3 array of zeros')\nprint(np.zeros((3,3)))\n\nprint('\\n', '2D 2X3 array of ones')\nprint(np.ones((2,3)))\n\nprint('\\n', 'Triangular array with ones at and below diagonal')\nprint(np.tri(3, 4))\n\nprint('\\n', 'Index matrix with ones at diagonal')\nprint(np.eye(3))\n\nprint('\\n', '20 equally spaced values between 1 and 5')\nprint(np.linspace(1, 5, 20))","d3a32e2d":"print('3X2 array of uniformly distributed number between 0 and 1')\nprint(np.random.rand(3,2))\n\nprint('\\n', 'Normally distributed random numbers with mean=0 and std=1')\nprint(np.random.randn(3,3))\n\nprint('\\n', 'Randomly choose integers from a range (>=5, <11)')\nprint(np.random.randint(5, 11, size=(2,2)))\n\nprint('\\n', \"Randomly selects a permutation from array\")\nprint(np.random.permutation([2,3,4,5,6]))\n\nprint('\\n', \"This is equivalent to rolling dice 10 times and counting \\\noccurance of getting each side\")\nprint(np.random.multinomial(10, [1\/6]*6))","4eac6978":"import numpy as np\narr = np.array([[1,2,3], [2,3,1], [3,3,3]])\n\nprint('Number of array dimensions')\nprint(arr.ndim)\n\nprint('\\nShape of array is tuple giving size of each dimension')\nprint(arr.shape)\n\nprint('\\nstrides gives byte steps to be moved in memory to get to next \\\nindex in each dimension')\nprint(arr.strides)\n\nprint('\\nByte size of each item')\nprint(arr.itemsize)","54dc1f3c":"print('Slice indexing is done by changing strides, as in examples below')\n\nprint('Strides of original array')\nprint(arr.strides)\n\nprint('\\n', 'Slice with step of 2 is done by multiplying stride(byte step size) by 2 in that dimension')\nprint(arr[::2].strides)\n\nprint('\\n', 'Reverse index will negate the stride')\nprint(arr[::-1].strides)\n\nprint('\\n', 'Transpose will swap the stride of the dimensions')\nprint(arr.T.strides)","ea37448d":"from numpy.lib.stride_tricks import as_strided\n\narr1 = np.arange(5)\nprint('arr1: ', arr1)\n\narr2 = np.arange(3)\nprint('arr2: ', arr2)\n\nprint('\\n', 'Adding a dimension with stride 0 allows us to repeat array in that dimension without making copy')\n\nprint('\\n', 'Making stride 0 for rows repeats rows.')\nprint('As step size is zero to move to next row it will give same row repeatedly')\nr_arr1 = as_strided(arr1, strides=(0,arr1.itemsize), shape=(len(arr2),len(arr1)))\nprint(r_arr1)\n\nprint('\\n', 'Making stride 0 for columns repeats columns.')\nr_arr2 = as_strided(arr1, strides=(arr2.itemsize, 0), shape=(len(arr2),len(arr1)))\nprint(r_arr2, '\\n')\n\nprint('Inner product: product of every value of arr1 to every value of arr2')\nprint(r_arr1 * r_arr2)\n","4a10f268":"print('Above example is equivalent to using broadcast to do inner product')\nprint(arr1[np.newaxis, :] * arr2[:, np.newaxis])\n\nprint('arr1[np.newaxis, :].strides => ', arr1[np.newaxis, :].strides)\nprint('arr2[:, np.newaxis].strides => ', arr2[:, np.newaxis].strides)","0bba0adc":"import numpy as np\narr = np.arange(5, dtype='<f4')\nprint('arr: ', arr)\n\nprint('\\n', 'Cast to integer using astype function which will make copy of the array')\ndisplay(arr.astype(np.int8))\n\nprint('\\n', 'By default casting is unsafe which will ignore the overflow. e.g. `2e10` is converted to 0')\narr[3] = 2e10\nprint(arr.astype('<i1'))\n\nprint('\\n', 'Casting from string to float')\nsarr = np.array(\"1 2 3 4 5.0\".split())\nprint(sarr)\nprint(sarr.astype('<f4'))\n\nprint('\\n', 'Use casting=\"safe\" for doing safe casting, which will raise error if overflow')\n# print(arr.astype('<i1', casting='safe'))\n","61c2ce1b":"arr = np.arange(20)\nprint('arr: ', arr)\n\nprint('\\n', 'reshape 1D arr of length 20 to shape (4,5)')\nprint(arr.reshape(4,5))\n\nprint('\\n', 'One item of shape tuple can be -1 in which case the item will be calculated by numpy')\nprint('For total size to be 20 missing value must be 5')\nprint(arr.reshape(2,2,-1))\n\n","6e55b4ea":"arr = np.arange(5, dtype='<i2')\nprint('arr: ', arr)\n\nprint('\\n', 'View with dtype \"<i1\" for array of dtype \"<i2\" will breakdown items to bytes')\nprint(arr.view('<i1'))\n\nprint('\\n', 'Changing little-endian to big-endian will change value as they use different byte order')\nprint(arr.view('>i2'))\n\nprint('\\n', 'Following will give individual bytes in memory of each items')\narr = np.arange(5, dtype='<f2')\nprint(arr)\nprint(arr.view('<i1'))","1f75d67b":"import numpy as np\narr = np.arange(20)\nprint(\"arr: \", arr)\n\nprint('\\n', 'Get item at index 4(5th item) of the array')\nprint(arr[4])\n\nprint('\\n', 'Assign 0 to index 4 of array')\narr[4] = 0\nprint(arr)\n\nprint('\\n', 'Get items in the index range 4 to 10 not including 10')\nprint(arr[4:10])\n\nprint('\\n', 'Set 1 to alternate items starting at index 4 to 10 ')\narr[4:10:2] = 1\nprint(arr)\n\n","a92e9fef":"arr = np.arange(20).reshape(4,5)\n\nprint('arr:\\n', arr)\n\nprint('\\n', 'Set 0 to first 3 rows and and last 2 columns')\narr[:3, -2:] = 1\nprint(arr)","c4ba217c":"arr = np.arange(6).reshape(2,3)\nprint('arr:\\n', arr)\n\nprint('\\n', 'Following index will gives last two items of 1st row and 1st element of 2nd row')\nindx = np.array([[False, True, True], [True, False,False]])\narr[indx]\n\nprint('\\n', 'Boolean index to filter values greater than 3 from arr')\nfilter_indx = arr>3\nprint('Filter Index:\\n', filter_indx)\n\nprint('\\n', 'Set 3 to values greater than 3 in arr')\narr[filter_indx] = 3\nprint(arr)\n","ad1f02d4":"import numpy as np\n\narr = np.arange(10)\nprint('arr:\\n', arr)\n\nprint('\\n', 'Get items at indexes 3,5 and 7 at once')\nprint(arr[[3,5,7]])\n\nprint('\\n', 'Sorting arr based on another array \"values\"')\nnp.random.seed(5)\nvalues = np.random.rand(10)\nprint('values:\\n', values)\nprint('\\n', 'np.argsort instead of returning sorted values will return array of indexes which will sort the array')\nindexes = np.argsort(values) \nprint('indexes:\\n', indexes)\nprint('Sorted array:\\n', arr[indxes])\n\nprint('\\n', 'You can also use fancy indexing to get same item multiple times')\nprint(arr[[0,1,1,2,2,2,3,3,3,3]])\n","4b929632":"arr2 = np.arange(15).reshape(5,3)\nprint('arr2:\\n', arr2)\n\nprint('\\n', 'Will give items at index (4,0) and (1,2)')\nindx = ([4,1],[0,2])\nprint(arr2[indx])\n\nprint('\\n', 'Tuple of length one will return rows')\nindx = ([4,1],)\nprint(arr2[indx])\n","b1d1da6d":"import numpy as np\n\narr = np.arange(10)\nprint('arr: ', arr)\n\nprint('\\n', 'Direct assignment will change the original array')\narr[[3,5,7]] = -1\nprint(arr)\n\nprint('\\n', 'When we chain the indexing it will not work')\narr[[3,5,7]][0] = -2\nprint(arr)\n\nprint('\\n', 'But chaining index will work with slicing indexing')\narr[3:8:2][0] = -2\nprint(arr)","4f932c55":"arr = np.arange(64).reshape(4,4,4)\nprint('arr: ', arr)\nprint('\\n', 'Following mixed indexing will select 1st and 3rd item in 0th dimension')\nprint('and item at index 0 and 2 at 1st dimension and item at index >=2')\nprint(arr[[True, False, True, False], [0,2], 2:])","9f121b49":"import numpy as np\n\nprint('Evaluate expression (x1*x2 - 3*x1 + 30) for x1 and x2 in range 0 to 10')\nx1 = np.linspace(0,10,20)\nx2 = np.linspace(0, 10, 20)\nz = x1*x2 - 3*x1 + 30\nprint(z)\n\nprint('\\n', 'Spatial distance between corresponding points in two array')\np1 = np.random.rand(20,2)\np2 = np.random.rand(20,2)\n\n'''np.sum will add values along given axis (dimension). If shape of array is (3,4,5)')\nthen axis 0,1 and 2 corresponds to dimension with length 3, 4 and 5 respectively'''\nd = np.sum((p1-p2)**2, axis=1)\nprint(d)\n\nprint('\\n', 'Element wise comparison, \">=\" will give boolean array with True where element')\nprint('of p2 is greater than or equal to p1')\nr = p2>=p1\nprint(r)\n\nprint('\\n', 'Element wise logical operation, \"&\" will give True where point of p2 is ahead')\nprint('in both x and y direction from corresponding point in p1')\nprint(r[:,0] & r[:,1])\n\n","631a8ef5":"import numpy as np\n\nprint('Evaluate expression (x1*x2 - 3*x1 + 30) using functions')\nx1 = np.linspace(0,10,20)\nx2 = np.linspace(0, 10, 20)\n\n'''Create empty output array with expected shape'''\nz = np.empty_like(x1)\n\n'''Code is not very clean as using operator but it will perform very well memory wise'''\nnp.multiply(x1, x2, out=z)\nnp.subtract(z, 3*x1, out=z)\nnp.add(z, 30, out=z)\nprint(z)\n\n\n","3c31363d":"import numpy as np\n\narr1 = np.arange(20).reshape(10,2)\narr2 = np.random.rand(2)\narr3 = arr2.copy()\n\nprint('arr1.shape: ', arr1.shape)\nprint('arr2.shape: ', arr2.shape)\n\n# Step 1: Check Array Dimensions\nprint('\\n', 'arr1 has dimension 2 and arr2 has dimension 1, so add 1 dimension to\\\nleft side of arr2')\n# np.newaxis is convenient way of adding new dimension\narr2 = arr2[np.newaxis, :]\nprint('arr1.shape: ', arr1.shape)\nprint('arr2.shape: ', arr2.shape)\n\n# Step 2: Match Shape On Each Dimension\nprint('\\n', 'Now in axis=0 arr1 has 10 items and arr2 has one item, so repeat it 10\\\ntimes to match arr2')\narr2 = np.repeat(arr2, 10, axis=0)\nprint('arr1.shape: ', arr1.shape)\nprint('arr2.shape: ', arr2.shape)\n\nprint('\\n', 'Now both array has same dimension and shape, we can multiply them')\nprint('arr1*arr2:\\n', arr1*arr2)\n\nprint('\\n', 'Lets see if broadcasting also produce same result')\nprint('arr1*arr3:\\n', arr1*arr3)\n","294e151c":"print(\"Let's evaluate equation c1*x1 + c2*x2 + c3*x3 for 100 points at once\")\npoints = np.random.rand(100,3)\ncoefficients = np.array([5, -2, 11])\nresults = np.sum(points*coefficients, axis=1)\nprint('results first 10:\\n', results[:10])\nprint('results.shape: ', results.shape)","85f820d7":"np.random.seed(5)\n## Get 20 random value from 0 to 99\narr1 = np.random.choice(50, 20, replace=False)\narr2 = np.random.choice(50, 15, replace=False)\nprint(\"arr1: \", arr1)\nprint(\"arr2: \", arr2)\nprint('\\n', 'arr1 and arr2 are 1D arrays of length 20, 15 respectively.')\nprint('To make them broadcastable Change shape of arr2 to (15, 1)')\narr2 = arr2.reshape(15, 1)\nprint('\\n', 'Then both arrays will be broadcasted to (15, 20) matrix with all possible pairs')\ncomparison = (arr1 == arr2)\nprint('\\n', 'comparison.shape: ', comparison.shape)\nprint('\\n', 'Elements of arr1 also in arr2: ', arr1[comparison.any(axis=0)])\n","799dd3a5":"import numpy as np\n\nnp.random.seed(5)\n\npoints = np.random.rand(20, 2)\nprint('To calculate distance between every pair of points make copy of points ')\nprint('with shape (20, 1, 2) which will broadcast both array to shape (20, 20, 2)', '\\n')\ncp_points = points.reshape(20, 1, 2)\n\n## calculate x2-x1, y2-y1\ndiff = (cp_points - points)\nprint('diff.shape: ', diff.shape)\n\n## calculate (x2-x1)**2 + (y2-y1)**\ndistance_matrix = np.sum(diff**2, axis=2)\nprint('distance_matrix.shape: ', distance_matrix.shape, '\\n')\n\n## sort by distance along axis 1 and take top 4, one of which is the point itself\ntop_3 = np.argsort(distance_matrix, axis=1)[:,:4]\nprint(\"Get the points with it's 3 nearest neighbors\")\npoints[top_3]","a10d83f8":"import numpy as np\nnp.random.seed(32)\nX = np.random.rand(10000)\ncoefficients = np.random.randn(10)*20 + 50\n","40b7ef09":"def evaluate_polynomial_loop():\n  result_loop = np.empty_like(X)\n  for i in range(X.shape[0]):\n    exp_part = 1\n    total = 0\n    for j in range(coefficients.shape[0]):\n      exp_part *= X[i]\n      total+=coefficients[j]*exp_part\n    result_loop[i] = total\n  return result_loop\n\n\ndef evaluate_polynomial_vect():\n  ## repeates x's in 10 columns\n  exponents = X[:, np.newaxis] + np.zeros((1, coefficients.shape[0]))\n  exponents.cumprod(axis=1, out=exponents)\n  result_vect = np.sum(exponents * coefficients, axis=1)\n  return result_vect\n  \nprint('Verify that both gives same result')\nprint('Loop:\\n', evaluate_polynomial_loop()[:10])\nprint('Vectorization:\\n', evaluate_polynomial_vect()[:10])","237d9c39":"%timeit evaluate_polynomial_loop()","bf22a276":"%timeit evaluate_polynomial_vect()","eb32caa8":"arr1 = np.arange(1000000, dtype='int64')\narr2 = np.arange(1000000, dtype='int64')","91ffb6f4":"def add_arr(arr1, arr2):\n  assert len(arr1)==len(arr2), \"array must have same length\"\n  result = np.empty_like(arr1)\n  for i in range(len(arr1)):\n    result[i] = arr1[i] + arr2[i]\n  return result\n\n%timeit _ = add_arr(arr1, arr2)","ae2e619c":"def add(a, b):\n  return a+b\n\nvect_add =  np.frompyfunc(add,2,1)\n\n%timeit _ = vect_add(arr1, arr2)","87a4d725":"import numba\n@numba.jit(nopython=True)\ndef add_arr_jit(arr1, arr2):\n  assert len(arr1)==len(arr2), \"array must have same length\"\n  result = np.empty_like(arr1)\n  for i in range(len(arr1)):\n    result[i] = arr1[i] + arr2[i]\n  return result\n\n_ = add_arr_jit(arr1, arr2)\n%timeit _ = add_arr_jit(arr1, arr2)","70d35dbb":"import numba\n\n@numba.vectorize(['int64(int64,int64)'], nopython=True)\ndef vect_add(a, b):\n  return a+b\n\n%timeit _ = vect_add(arr1, arr2)","7cdbfbe6":"### What is Numpy?\nNumpy is fundamental computing library for python. It supports N-Dimensional array and provides simple and efficient array operations. \n\nNumPy is library of algorithms written in the C language which stores data in a contiguous block of memory, independent of other built-in Python objects and can operate on this memory without any type checking or other python overheads. NumPy arrays also use much less memory than built-in Python sequences.","648dd5bb":"# Indexing Methods","bb0ef780":"### Creating Ufunc Using `numba.vectorize`\n- 'numba.vectorize' takes signature of function being converted as parameter. 'int64(int64,int64)' means takes 2 'int64' parameters and returns 'int64'","89093d03":"**Conclusion** solution using `numba.jit and numba.vectorize` are performing much better. You can also check how numpy vectorization compares with these","324462d6":"### What Will We Cover\nBasics\n - [Creating Array](#Creating-Array)\n - [Understanding Structure of Numpy Array - dimension, shape and strides](#Understanding-Structure-of-Numpy-Array---dimension,-shape-and-strides)\n - [Data Types and Casting](#Data-Types-and-Casting)\n - [Indexing Methods](#Indexing-Methods)\n - [Array Operations](#Array-Operations)\n\nAdvance\n - [Broadcasting](#Broadcasting)\n - [Vectorization](#Vectorization)\n - [Ufunc and Numba](#Ufunc-and-Numba)\n \n[More for Exploration](#More-for-Exploration)","c48c4593":"## Some Usage of Broadcast","a001bfa3":"## Fancy Indexing\n- Fancy Indexing means using array of index(integer) as index to get all items at once\n- Fancy Indexing **will also return copy** instead of view to the array","1a77d4f4":"### Some Tips On Jupyter Notebook\n - To see auto completion suggestions **press `tab`**\n - To see parameters of a function **press `shift + tab`** after typing function name and '('. eg. type `np.asarray(` then press `shift + tab`\n - To view doc string use '?' like **`np.asarray?`** then press **`shift + enter`**","eb37ce3d":"## Casting ","7025ff83":"### Memory Mapping\nTo work with large numpy array that doesn't fit in RAM you can use numpy.memmap function to map the array to file in disk. It will transparently loads only segments of array needed for current operations.\n\n- **`np.memmap(filename, dtype, mode, shape)`: ** create a memory mapped array to a given file\n- **`mmap.flush()`: ** flush all in memory changes to disk\n","dc349408":"### Save and Load ndarray From Disk\n- **`np.save(\"filename.npy\", x)`: ** save single numpy array to disk\n- **`np.load(\"filename.npy\")`: ** load single numpy array from disk\n- **`np.savez(\"filename.npz\", key1=arr1, key2=arr2)`: ** saves multiple arrays with given key\n- **`np.savetxt(\"filename.npy\", x)`: ** save single numpy array to disk as delimited text file\n- **`np.loadtxt(\"filename.npy\")`: ** load single numpy array from text file","4b3bcdd5":"## From python list","446499e3":"### Creating Ufunc Using `np.frompyfunc`","a4e650cf":"## Functions for Array Operations\n - Numpy also has function version of above operations like `np.add, np.substract, np.divide, np.greater_equal, np.logical_and` and more\n - Array operations we see in section above using operators like +, * are operator overloaded version of function operation\n - Function version of the operation will give us extra parameters to customize, one of commonly used parameter is `out`. It is `None` by default, which will create a new array for result. \n - If We pass an array with shape and dtype matching to expected result to `out` parameter result will be filled to the passed array. It will be efficient memory wise if we are doing multiple operations  ","0977a043":"### Some Useful Functions","3f94b915":"### Implementation Using Python Loop","899754d1":"### Compare\nFor fair comparison I used numpy array in both whose indexing is much faster than python list. By comparison we see the vectorization is **about 80 times faster**","7fddeac2":"## Reshaping\n- ndarray can be reshaped to any shape as long as total number of element are same","4a31069d":"When doing array operations between two array's whose shape doesn't match exactly then few simple steps are taken which changes shapes to match each other if they are compatible.\n\n 1. **Check Array Dimensions**: If dimensions doesn't match added to left of array with smaller dimension\n 2. **Match Shape On Each Dimension**: If shape in any dimension doesn't match and shape is 1 for one of the array then repeat it to match shape of other array in that dimension\n 3. **Raise Error if Dimension and Shape Not Matched**: If dimension and shape don't match till this step then raise error","c865f053":"#### Using Broadcast","be4b0427":"# Understanding Structure of Numpy Array - dimension, shape and strides","c72ded9c":"### Let's Try Few Examples With Shapes\nyou can try it by creating arrays of given shape and doing some operation between them\n\n```\nBefore Broadcast        |Step 1                      | Step 2 and 3  \nShapes of arr1 and arr2 |                            | Shapes of result \n-------------------------------------------------------------------------\n(3, 1, 5); (4, 1)       | (3, 1, 5); (1, 4, 1)       | (3, 4, 5)        \n(10,); (1, 10)          | (10, 1); (1, 10)           | (10, 10)         \n(2, 2, 2); (2, 3)       | (2, 2, 2); (1, 2, 3)       | Not Broadcastable\n(2, 2, 2, 1); (2, 3)    | (2, 2, 2, 1); (1, 1, 2, 3) | (2, 2, 2, 2, 3)\n\n```","4b05b97a":"### Set Operations\n- **`np.unique(x)`: ** gives array of unique elements on the array\n- **`Intersect1d(x, y)`: ** gives 1D array of elements common to both arrays\n- **`Union1d(x, y)`: ** gives 1D array of unique elements from both arrays\n- **`In1d(x, y)`: ** check if each element of x is also present on y and returns array of length equal to x with boolean values\n- **`Setdiff1d(x, y)`: ** gives elements of x not in y\n- **`Setxor1d(x, y)`: ** give elements that is either in x or y but not in both\n","eee09272":"### Vectorization Vs Loop\nLet's say we have a polynomial equation of degree 10 of single variable like `a1*x + a2*x^2 + a3*x^3 ... + a10*x^10`. Let's try evaluating the equation for large number of x using python only and numpy vectorization see how they compare","d996f7a8":"## More on Strides","50c2edb9":"## Boolean Indexing\n- Boolean array of same shape as original array (or broadcastable to the shape) can be used as index. Which will select the items where index value is true\n- Boolean array can also be used to filter array with certain conditions\n- Boolean indexing **will return copy** instead of view to the array","1ae5e4a6":"**Notes**\n- Numpy array can store items of only one data type\n- ```np_array.dtype``` attribute will give dtype of the array\n- following table shows some common datatypes with their string names\n\n```\n\nNumpy Attribute                                 | String Name                | Description\n------------------------------------------------------------------------------------------------------\nnp.int8, np.int16, np.int32, np.int64           | '<i1', '<i2', '<i4', '<i8' | signed int\nnp.uint8, np.uint16, np.uint32, np.uint64       | '<u1', '<u2', '<u4', '<u8' | unsigned int\nnp.float16, np.float32, np.float64, np.float128 | '<f2', '<f4', '<f8', '<f16'| floats\nnp.string_                                      |'S1', 'S10', 'S255'         | string of bytes (ascii)\nnp.str                                          |'U1', 'U255'                | string of unicode characters\nnp.datetime64                                   |'M8'                        | date time\nnp.Object                                       |'O'                         | python object\nnp.bool                                         |'?'                         | boolean\n\n```\n\n- **Break down of string name '<u8':** here '<' means little-endian byte order, 'u' means unsigned int and '8' means 8 bytes. Other options for byte order are '>' big endian and '=' system default\n- All of the array initialization functions discussed above takes 'dtype' parameter to set datatype of the array eg: ```np.random.randint(5, 11, size=(2,2), dtype=np.int8)```","8e580f5b":"## Simple Array Operations\n- Numpy provides simple syntax to perform mathematical and logical operations between array of compatible shapes. Here compatible shape means, shape of one of the array can be expanded to match shape of other using broadcast rule, which we'll discuss below\n- For this section we'll only see two cases\n  - Arrays has same shape in which case operation will be element wise\n  - One of operand is scalar in which case operation will be done between scalar and each element of array\n- These operations between arrays are called vectorization and are way faster than same operation using loop. \n- Vectorization are faster because it is implemented in C and don't have overheads like type checking etc.","88035526":"## Numpy's Methods","3a245ebb":"# Vectorization\n - In numpy vectorization means performing optimized operations on sequence of same type of data.\n - In addition to having clean structure of code vectorized operations are also very performant because codes are compiled an avoids overhead of python, like type checking, memory management etc.\n - The examples we see on **Broadcast section above are also good example of vectorization**","85cddfe3":"### Some Stride Tricks: Inner product by changing strides\nIt is very rare that you may want to use these tricks but it helps us understand how indexing in numpy works\n\n`as_strided` function returns a view to an array with different strides and shape","fe0e434b":"## Mixed Indexing\n- In multi dimensional array we can use different indexing method (slicing, boolean and fancy) for each dimension at same time\n- For mixture of boolean and fancy index to work, number of True's in boolean index must be equal to length of fancy index","617f0347":"# Introduction","7d010828":"### Tuple Indexing\n- Multi-dimensional array can be indexed using tuple of integer array of equal length, where each array in tuple will index corresponding dimension\n- If number of index-array in tuple is less than the dimension of array being indexed they will be used to index lower dimension (i.e. dimension starting from 0 to length of tuple)","35c7a789":"## Ufunc and Numba\n**Ufunc:** Also called Universal Functions are vectorized wrapper for a function. Ufunc can operate on ndarray and support broadcasting and type casting. `np.add, np.multiply` etc are examples of Ufunc which are implemented in C. We can create custom Ufunc using `np.frompyfunc` or using numba.\n\n**Numba**: Numba is just in time compiler which generate optimized machine code from pure python array and numerical functions. You can use `numba.jit` decorator on a function which makes the function to be compiled on its 1st run. You can use `numba.vectorize` decorator to convert python function to Ufunc.","eb6cee0a":"### Assignment With Advance Indexing\n- Advance Indexing(i.e. Boolean, Fancy and Tuple) returns copy instead of view to the indexed array. But direct assignment using those index will change the original array, this feature is for convenience. But if we chain the indexing it may behaves in a way which seems to be somewhat unexpected","b6fb5ac6":"# Array Operations","8c7ae4d2":"### Evaluate Linear Equation Using Broadcast","a0294c93":"## Array View With Different dtype\n- ```arr.view()``` method gives new view for same data with new dtype. Creating view with different dtype is not same as casting. eg. if we have ndarray of np.float32 ('<f4') creating view with dtype byte ('<i8') will read 4 bytes float data as individual bytes","b86f9ee9":"# Broadcasting","b2d5c08c":"### Create Big Arrays","68dc1519":"## Rules for broadcasting","1920121a":"### Why Use Numpy?\nPython was not initially designed for numerical computation. As python is interpreted language it is inherently slower than compiled languages like C. So numpy fills that gap here, following are few advantages of using numpy \n\n - It provides efficient multidimensional array operations, both memory and computation wise\n - It provides fast mathematical operations on entire array without need to use loop\n - It also provides scientific operations related to linear algebra,  statistics, Fourier transform and more \n - It provides tool for interoperability with c and c++ \n \n\n\n\n","9b8af3b2":"### Find k-nearest Neighbors","d64fd7e6":"- **`np.where`:** element wise `if .. then .. Else`  \n- **`np.select`:** select values from multiple arrays based on multiple conditions  \n- **`np.concatenate, np.vstack, np.r_, np.hstack, np.c_`:** join multiple ndarray row wise, column wise or in a given axis\n- **`np.ravel, np.flatten`:** converts multidimensional array to 1D array\n- **`np.roll`:** do circular shift of the array along given axis\n\n","e97a71d2":"This blog is meant to be **playground** for beginners to learn about numpy by trying real codes. I have kept texts content as little as possible and code examples as much as possible.\n\nThis is also meant to be **quick future reference guide** of numpy features you already learned. The output of each cell has details describing results.","38f4147b":"## Using ```np.random```","b3fbddf2":"### Slice Indexing in 2D\u00a0Array\n- For multidimensional array slice index can be separated using comma","98599880":"# Creating Array","d3979de0":"### Using Numba JIT\n- 'nopython=True' means convert all to machine level code, if can't convert raise error","22ea1b0b":"# Data Types and Casting","e117a8d1":"**Enough of reading!!**\n***Lets get our hand dirty***","bc406018":"## Integer and Slice Indexing\n- This method of indexing is similar to indexing used in python list\n- Slicing always create view to the array ie. does not copy the array","6db3443b":"### Let's Visualize the Broadcasting Rule With Custom Implementation\nlets do our custom implementation to visualize in code how the broadcast rule works","25f4ec9a":"Let's compare different implementations of adding two big arrays as follow","6d93b3a2":"### Find Common Elements Between Arrays","31543559":"### Prerequisite\n - Basic programming knowledge \n - Some familiarity with python (loops, arrays etc.)\n","1b2af2f1":"# More for Exploration","7a0c4558":"### How to Play With Numpy?\nI would recommend two ways to play around with Numpy\n - [kaggle](https:\/\/www.kaggle.com\/notebooks) or [Google Colab](https:\/\/colab.research.google.com\/notebooks\/intro.ipynb#): you can jump right into coding without needing any setup\n - [Jupyter Notebook](https:\/\/jupyter.org\/install): you need to install jupyter notebook and then [install numpy](https:\/\/pypi.org\/project\/numpy\/) library using pip (numpy may be already installed if you have anaconda or miniconda)"}}