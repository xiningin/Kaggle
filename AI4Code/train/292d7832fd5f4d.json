{"cell_type":{"f0c85052":"code","8dff2f3a":"code","6747675f":"code","a34c6010":"code","f96c99f4":"code","e86ab79b":"code","d6fdf634":"code","7d49fdc3":"code","afaf7c58":"code","d55d3cab":"code","c18b1212":"code","869e0243":"code","deb325c5":"code","d0223c10":"code","8a2c0192":"code","bf8135ab":"code","046bace8":"code","6b72ab3b":"code","39d5e3d7":"code","39cc9923":"code","bed2ff35":"code","92e851b7":"code","577b38c5":"code","2cbf13fd":"code","c300dcc8":"code","e52eff8c":"code","c44437f9":"code","8bc2a889":"code","9f0b8656":"code","19cba134":"code","1213d94d":"code","de4ec368":"code","4b6b2556":"markdown","d22fc1ca":"markdown","ad3e82fa":"markdown","593da254":"markdown","9dc237b0":"markdown","f3ceac6d":"markdown","e22e8d8e":"markdown","f70192d1":"markdown","55181900":"markdown","1ed79ccc":"markdown"},"source":{"f0c85052":"import numpy as np\nimport pandas as pd\nimport xml.etree.ElementTree as ET\nfrom sklearn.model_selection import train_test_split\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\nimport random\nimport os\nimport cv2","8dff2f3a":"import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport torch.optim as optim\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torchvision import models","6747675f":"base_path = '..\/input\/road-sign-detection\/'\nann_path = base_path + 'annotations\/'\nimg_path = base_path + 'images\/'","a34c6010":"def get_file_list(root, file_type):\n    return [os.path.join(directory_path, f) for directory_path, directory_name, \n            files in os.walk(root) for f in files if f.endswith(file_type)]","f96c99f4":"def get_train_df(ann_path, img_path):\n    ann_path_list = get_file_list(ann_path, '.xml')\n    ann_list = []\n    for a_path in ann_path_list:\n        root = ET.parse(a_path).getroot()\n        ann = {}\n        ann['filename'] = Path(str(img_path) + '\/'+ root.find(\".\/filename\").text)\n        ann['width'] = root.find(\".\/size\/width\").text\n        ann['height'] = root.find(\".\/size\/height\").text\n        ann['class'] = root.find(\".\/object\/name\").text\n        ann['xmin'] = int(root.find(\".\/object\/bndbox\/xmin\").text)\n        ann['ymin'] = int(root.find(\".\/object\/bndbox\/ymin\").text)\n        ann['xmax'] = int(root.find(\".\/object\/bndbox\/xmax\").text)\n        ann['ymax'] = int(root.find(\".\/object\/bndbox\/ymax\").text)\n        ann_list.append(ann)\n    return pd.DataFrame(ann_list)","e86ab79b":"df_train = get_train_df(ann_path, img_path)","d6fdf634":"class_dict = {'speedlimit': 0, 'stop': 1, 'crosswalk': 2, 'trafficlight': 3}\nidx_to_class = {k:v for k,v in enumerate(list(class_dict.keys()))}\ndf_train['class'] = df_train['class'].apply(lambda x:  class_dict[x])\ndf_train.head()","7d49fdc3":"# additional functions\n\ndef read_image(path):\n    return cv2.cvtColor(cv2.imread(str(path)), cv2.COLOR_BGR2RGB)\n\ndef create_bb_array(x):\n    return np.array([x[5],x[4],x[7],x[6]])","afaf7c58":"# masks functions\n\ndef create_mask(bb, x):\n    rows,cols,*_ = x.shape\n    Y = np.zeros((rows, cols))\n    bb = bb.astype(np.int)\n    Y[bb[0]:bb[2], bb[1]:bb[3]] = 1.\n    return Y\n\ndef mask_to_bb(Y):\n    cols, rows = np.nonzero(Y)\n    if len(cols)==0: \n        return np.zeros(4, dtype=np.float32)\n    top_row = np.min(rows)\n    left_col = np.min(cols)\n    bottom_row = np.max(rows)\n    right_col = np.max(cols)\n    return np.array([left_col, top_row, right_col, bottom_row], dtype=np.float32)","d55d3cab":"def resize_image_bb(read_path, write_path, bb, sz):\n    im = read_image(read_path)\n    im_resized = cv2.resize(im, (int(1.49*sz), sz))\n    Y_resized = cv2.resize(create_mask(bb, im), (int(1.49*sz), sz))\n    new_path = str(write_path\/read_path.parts[-1])\n    cv2.imwrite(new_path, cv2.cvtColor(im_resized, cv2.COLOR_RGB2BGR))\n    return new_path, mask_to_bb(Y_resized)","c18b1212":"!rm -rf images_resized\n!mkdir images_resized","869e0243":"new_paths = []\nnew_bbs = []\ntrain_path_resized = Path('images_resized')\n\nfor index, row in df_train.iterrows():\n    new_path,new_bb = resize_image_bb(row['filename'], train_path_resized, create_bb_array(row.values),300)\n    new_paths.append(new_path)\n    new_bbs.append(new_bb)\n    \ndf_train['new_path'] = new_paths\ndf_train['new_bb'] = new_bbs","deb325c5":"# crop functions\n\ndef crop(im, r, c, target_r, target_c): \n    return im[r:r+target_r, c:c+target_c]\n\ndef random_crop(x, r_pix=8):\n    r, c,*_ = x.shape\n    c_pix = round(r_pix*c\/r)\n    rand_r = random.uniform(0, 1)\n    rand_c = random.uniform(0, 1)\n    start_r = np.floor(2*rand_r*r_pix).astype(int)\n    start_c = np.floor(2*rand_c*c_pix).astype(int)\n    return crop(x, start_r, start_c, r-2*r_pix, c-2*c_pix)\n\ndef center_crop(x, r_pix=8):\n    r, c,*_ = x.shape\n    c_pix = round(r_pix*c\/r)\n    return crop(x, r_pix, c_pix, r-2*r_pix, c-2*c_pix)\n\ndef random_cropXY(x, Y, r_pix=8):\n    r, c,*_ = x.shape\n    c_pix = round(r_pix*c\/r)\n    rand_r = random.uniform(0, 1)\n    rand_c = random.uniform(0, 1)\n    start_r = np.floor(2*rand_r*r_pix).astype(int)\n    start_c = np.floor(2*rand_c*c_pix).astype(int)\n    xx = crop(x, start_r, start_c, r-2*r_pix, c-2*c_pix)\n    YY = crop(Y, start_r, start_c, r-2*r_pix, c-2*c_pix)\n    return xx, YY","d0223c10":"def rotate_cv(im, deg, y=False, mode=cv2.BORDER_REFLECT, interpolation=cv2.INTER_AREA):\n    \"\"\" Rotates an image by deg degrees\"\"\"\n    r,c,*_ = im.shape\n    M = cv2.getRotationMatrix2D((c\/2,r\/2),deg,1)\n    if y:\n        return cv2.warpAffine(im, M,(c,r), borderMode=cv2.BORDER_CONSTANT)\n    return cv2.warpAffine(im,M,(c,r), borderMode=mode, flags=cv2.WARP_FILL_OUTLIERS+interpolation)","8a2c0192":"# main function for augmentation\n\ndef transformsXY(path, bb, transforms):\n    x = cv2.imread(str(path)).astype(np.float32)\n    x = cv2.cvtColor(x, cv2.COLOR_BGR2RGB)\/255\n    Y = create_mask(bb, x)\n    if transforms:\n        rdeg = (np.random.random()-.50)*20\n        x = rotate_cv(x, rdeg)\n        Y = rotate_cv(Y, rdeg, y=True)\n        if np.random.random() > 0.5: \n            x = np.fliplr(x).copy()\n            Y = np.fliplr(Y).copy()\n        x, Y = random_cropXY(x, Y)\n    else:\n        x, Y = center_crop(x), center_crop(Y)\n    return x, mask_to_bb(Y)","bf8135ab":"# functions to create and show the boxes\n\ndef create_corner_rect(bb, color='red'):\n    bb = np.array(bb, dtype=np.float32)\n    return plt.Rectangle((bb[1], bb[0]), bb[3]-bb[1], bb[2]-bb[0], color=color,\n                         fill=False, lw=3)\n\ndef show_corner_bb(im, bb):\n    plt.imshow(im)\n    plt.gca().add_patch(create_corner_rect(bb))","046bace8":"# before transformation\n\nim = cv2.imread(str(df_train.values[100][8]))\nim = cv2.cvtColor(im, cv2.COLOR_BGR2RGB)\nshow_corner_bb(im, df_train.values[100][9])","6b72ab3b":"# after transformation\n\nim, bb = transformsXY(str(df_train.values[100][8]),df_train.values[100][9],True )\nshow_corner_bb(im, bb)","39d5e3d7":"df_train = df_train.reset_index()\n\nX = df_train[['new_path', 'new_bb']]\ny = df_train['class']","39cc9923":"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=34)","bed2ff35":"class RoadDataset(Dataset):\n    def __init__(self, paths, bb, y, transforms=False):\n        self.transforms = transforms\n        self.paths = paths.values\n        self.bb = bb.values\n        self.y = y.values\n        \n    def normalize(self, im):\n        imagenet_stats = np.array([[0.485, 0.456, 0.406], [0.229, 0.224, 0.225]])\n        return (im - imagenet_stats[0])\/imagenet_stats[1]\n    \n    def __len__(self):\n        return len(self.paths)\n    \n    def __getitem__(self, idx):\n        path = self.paths[idx]\n        y_class = self.y[idx]\n        x, y_bb = transformsXY(path, self.bb[idx], self.transforms)\n        x = self.normalize(x)\n        x = np.rollaxis(x, 2)\n        return x, y_class, y_bb","92e851b7":"batch_size = 64\n\ntrain_ds = RoadDataset(X_train['new_path'],X_train['new_bb'] ,y_train, transforms=True)\nvalid_ds = RoadDataset(X_test['new_path'],X_test['new_bb'],y_test)\n\ntrain_dl = DataLoader(train_ds, batch_size=batch_size, shuffle=True)\nvalid_dl = DataLoader(valid_ds, batch_size=batch_size)","577b38c5":"class BB(nn.Module):\n    def __init__(self):\n        super(BB, self).__init__()\n        resnet = models.resnet34(pretrained=True)\n        layers = list(resnet.children())[:8]\n        self.features1 = nn.Sequential(*layers[:6])\n        self.features2 = nn.Sequential(*layers[6:])\n        self.classifier = nn.Sequential(nn.BatchNorm1d(512), nn.Linear(512, 4))\n        self.bb = nn.Sequential(nn.BatchNorm1d(512), nn.Linear(512, 4))\n        \n    def forward(self, x):\n        x = self.features1(x)\n        x = self.features2(x)\n        x = F.relu(x)\n        x = nn.AdaptiveAvgPool2d((1,1))(x)\n        x = x.view(x.shape[0], -1)\n        return self.classifier(x), self.bb(x)","2cbf13fd":"def update_optimizer(optimizer, lr):\n    for i, param_group in enumerate(optimizer.param_groups):\n        param_group[\"lr\"] = lr","c300dcc8":"def train_epocs(model, optimizer, train_dl, val_dl, epochs=10,C=1000):\n    idx = 0\n    for i in range(epochs):\n        model.train()\n        total = 0\n        sum_loss = 0\n        for x, y_class, y_bb in train_dl:\n            batch = y_class.shape[0]\n            x = x.cuda().float()\n            y_class = y_class.cuda()\n            y_bb = y_bb.cuda().float()\n            out_class, out_bb = model(x)\n            loss_class = F.cross_entropy(out_class, y_class, reduction=\"sum\")\n            loss_bb = F.l1_loss(out_bb, y_bb, reduction=\"none\").sum(1)\n            loss_bb = loss_bb.sum()\n            loss = loss_class + loss_bb\/C\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n            idx += 1\n            total += batch\n            sum_loss += loss.item()\n        train_loss = sum_loss\/total\n        val_loss, val_acc = val_metrics(model, valid_dl, C)\n        if (i+1) % 10 == 0:\n            print(\"i:%4d train_loss:%5.3f val_loss:%5.3f val_acc:%5.3f\" % ((i+1), train_loss, val_loss, val_acc))\n    return sum_loss\/total","e52eff8c":"def val_metrics(model, valid_dl, C=1000):\n    model.eval()\n    total = 0\n    sum_loss = 0\n    correct = 0 \n    for x, y_class, y_bb in valid_dl:\n        batch = y_class.shape[0]\n        x = x.cuda().float()\n        y_class = y_class.cuda()\n        y_bb = y_bb.cuda().float()\n        out_class, out_bb = model(x)\n        loss_class = F.cross_entropy(out_class, y_class, reduction=\"sum\")\n        loss_bb = F.l1_loss(out_bb, y_bb, reduction=\"none\").sum(1)\n        loss_bb = loss_bb.sum()\n        loss = loss_class + loss_bb\/C\n        _, pred = torch.max(out_class, 1)\n        correct += pred.eq(y_class).sum().item()\n        sum_loss += loss.item()\n        total += batch\n    return sum_loss\/total, correct\/total","c44437f9":"model = BB().cuda()\nparameters = filter(lambda p: p.requires_grad, model.parameters())\noptimizer = torch.optim.Adam(parameters, lr=0.002)","8bc2a889":"train_epocs(model, optimizer, train_dl, valid_dl, epochs=101)","9f0b8656":"# Predict the first image of the validation set\ntest_batch = next(iter(valid_dl))\ntest_batch[0] = test_batch[0].type(torch.cuda.FloatTensor).cuda()","19cba134":"out, bb = model(test_batch[0])","1213d94d":"print('Class :', idx_to_class[torch.argmax(out[0]).item()])","de4ec368":"show_corner_bb(np.moveaxis(test_batch[0][0].cpu().numpy(), 0, 2), bb.detach().cpu().numpy().astype(int)[0])","4b6b2556":"# Split DataSet","d22fc1ca":"# Road Traffic Signs Dataset","ad3e82fa":"# Data Augmentation","593da254":"# Prepare the Training Dataframe","9dc237b0":"# Bounding Box Model","f3ceac6d":"# Training","e22e8d8e":"# Prepare Images size and bounding boxes","f70192d1":"# Road Traffic Signs - Bounding Box Predictions","55181900":"# Prediction","1ed79ccc":"# Demo Image with Bounding Box"}}