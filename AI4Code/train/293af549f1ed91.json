{"cell_type":{"69caf869":"code","3c398a55":"code","cec0b1a0":"code","87730d75":"code","9512b200":"code","cc731235":"code","1df4103a":"code","9c5419c2":"code","a1901853":"code","d76c0366":"code","6511e2e3":"code","204d8b51":"code","eea36298":"code","2ca07ff5":"code","a7b066a2":"code","93aedd60":"code","25694df3":"code","07507b6e":"code","c512e489":"code","bfeca2a4":"code","97a4cc6c":"markdown","353f4746":"markdown","f9e0085b":"markdown","4ecc29bb":"markdown","07b0d23e":"markdown","8e0a521e":"markdown","863d8fb1":"markdown","a26d0f1d":"markdown","a8f830e1":"markdown","02cdd63f":"markdown","35580ae2":"markdown","40258944":"markdown"},"source":{"69caf869":"import random\n\nclass TicTacToe:\n    X_MARK = 'X'\n    O_MARK = 'O'\n\n    def __init__(self, callback):\n        if not callable(callback):\n            raise Exception('TicTacToe need a function to retrieve the next move')\n        self.callback = callback\n\n    def _resetBoard(self):\n        self.board = [\n            [None, None, None],\n            [None, None, None],\n            [None, None, None]\n        ]\n\n    def _getMark(self, mark):\n        if mark == TicTacToe.X_MARK:\n            return TicTacToe.O_MARK\n        else:\n            return TicTacToe.X_MARK\n\n    def _getEmpty(self):\n        empty = []\n        for ri, row in enumerate(self.board):\n            for ci, cell in enumerate(row):\n                if cell is None:\n                    empty.append((ri, ci))\n        return empty\n\n    def _getRandomMove(self):\n        empty = self._getEmpty()\n        return random.choice(empty)\n\n    def _playMove(self, move, mark=None):\n        if not mark:\n            mark = self._getMark(self.mark)\n        row, col = move\n        if self.board[row][col] != None:\n            return -1\n        self.board[row][col] = mark\n        return 1 if not self._getEmpty() else 0\n\n    def _checkBoard(self):\n        b = self.board\n        for i in range(3):\n            if (b[i][0] and b[i][0] == b[i][1] and b[i][1] == b[i][2]): # row\n                return b[i][0]\n            if (b[0][i] and b[0][i] == b[1][i] and b[1][i] == b[2][i]): # column\n                return b[0][i]\n        if (b[0][0] and b[0][0] == b[1][1] and b[1][1] == b[2][2]): # diagonal\n            return b[0][0]\n        if (b[0][2] and b[0][2] == b[1][1] and b[1][1] == b[2][0]): # diagonal\n            return b[0][2]\n        return None\n\n    def _printBoard(self):\n        p = lambda row, col: self.board[row][col] or ' '\n        print( '\\n -----')\n        print( '|' + p(0,0) + '|' + p(0,1) + '|' + p(0,2) + '|')\n        print( ' -----')\n        print( '|' + p(1,0) + '|' + p(1,1) + '|' + p(1,2) + '|')\n        print( ' -----')\n        print( '|' + p(2,0) + '|' + p(2,1) + '|' + p(2,2) + '|')\n        print( ' -----\\n')       \n\n    def simulateGame(self, mark='X', play_first=False, verbose=False):\n        self.mark = mark\n        self._resetBoard()\n        printBoard = lambda: self._printBoard() if verbose else None\n        if not play_first:\n            move = self._getRandomMove()\n            self._playMove(move)\n        empty = self._getEmpty()\n        win = None\n        while empty and not win:\n            printBoard()\n            move = self.callback(self.board, empty, mark)\n            self._playMove(move, mark)\n            win = self._checkBoard()\n            if not self._getEmpty() or win:\n                break\n            printBoard()\n            move = self._getRandomMove()\n            self._playMove(move)\n            empty = self._getEmpty()\n            win = self._checkBoard()\n        printBoard()\n\n        if win == mark:\n            return 1    # win\n        elif win == self._getMark(mark):\n            return -1   # lose\n        else:\n            return 0    # draw\n\n    def simulate(self, n_games):\n        win = 0\n        for _ in range(n_games):\n            mark = random.choice([TicTacToe.X_MARK, TicTacToe.O_MARK])\n            play_first = random.choice([True, False])\n            res = self.simulateGame(mark=mark, play_first=play_first)\n            if res == 1:\n                win += 1\n        return win\n\n\ndef placeMark(board_state, empty_cells, mark):\n    return random.choice(empty_cells)\n\nif __name__ == '__main__':\n    from datetime import datetime\n    random.seed(datetime.now())\n\n    n_games = 5000\n    win = TicTacToe(placeMark).simulate(n_games)\n    print(f'Player won {win} out of {n_games} games (win rate = {round((win\/n_games) * 100, 2)}%)')","3c398a55":"import random\nfrom datetime import datetime\n\nrandom.seed(datetime.now())\n\ndef placeMark(board_state, empty_cells, mark):\n    \"\"\" Return the position to place the mark.\n    Ex:\n        board_state: [[X, O, X], [X, None, O], [O, None, X]]\n        empty_cells: [(1, 1), (2, 1)]\n        mark: 'X'\n    \"\"\"\n    return random.choice(empty_cells)","cec0b1a0":"win = TicTacToe(placeMark).simulateGame(verbose=True)\nif win == 1:\n    print('Won')\nelif win == -1:\n    print('Lost')\nelse:\n    print('Draw') ","87730d75":"n_games = 5000\nwin = TicTacToe(placeMark).simulate(n_games)\nprint(f'Player won {win} out of {n_games} games (win rate = {round((win\/n_games) * 100, 2)}%)')","9512b200":"import pandas as pd\nimport copy\n\ndef toStr(o):\n    \"\"\" Makes list\/tuple readable and clean\n    \"\"\"\n    if isinstance(o, list):\n        return str(o).translate(str.maketrans('','', '\\'[]'))\n    elif isinstance(o, tuple):\n        return str(o).strip('()').replace(', ', '-')\n\ndef playGame(n_games):\n    games = []\n    logs = []\n    def placeMark(board_state, empty_cells, mark):\n        move = random.choice(empty_cells) # randomly choose next move from empty cells\n        logs.append((copy.deepcopy(board_state), move)) # deepcopy for list of lists\n        return move\n    \n    tic = TicTacToe(placeMark)\n    for _ in range(n_games):\n        logs = []\n        mark = random.choice([TicTacToe.X_MARK, TicTacToe.O_MARK])\n        play_first = random.choice([True, False])\n        win = tic.simulateGame(mark=mark, play_first=play_first)\n        for i, (board_state, move) in enumerate(reversed(logs)):\n            winner = win == 1\n            result = 1.0 * winner if i == 0 else .4 + .2 * winner\n            games.append({\n                'mark': mark,\n#                 'play_first': play_first,\n                'board_state': toStr(board_state),\n                'move': toStr(move),\n                'result': result,\n            })\n    return games\n\nN_GAMES = 100000\ngames = playGame(N_GAMES)\ndf = pd.DataFrame(games)","cc731235":"df.head()","1df4103a":"from sklearn.preprocessing import LabelEncoder\n\ntrain = pd.DataFrame() # dataset for train the model\nbs_encoder = LabelEncoder()\ntrain['board_state'] = bs_encoder.fit_transform(df['board_state'])\nmark_encoder = LabelEncoder()\ntrain['mark'] = mark_encoder.fit_transform(df['mark'])\nmove_encoder = LabelEncoder()\ntrain['move'] = move_encoder.fit_transform(df['move'])\ntrain['result'] = df['result']","9c5419c2":"train.head()","a1901853":"y = train['result']\nX = train.drop('result', axis=1)","d76c0366":"from sklearn.tree import DecisionTreeRegressor\n\nmodel = DecisionTreeRegressor()\nmodel.fit(X, y)","6511e2e3":"import numpy as np\n\ndef getMoveFromPred(preds, empty):\n    \"\"\" Decode and format the predicted move\n    \"\"\"\n    p = max(preds, key=lambda x: x[0]) # get the max value for predicted result\n    move_dec = move_encoder.inverse_transform([p[1]])[0] # decode from int to categorical value\n    row, col = move_dec.split('-')\n    return (int(row), int(col))\n\ndef placeMark(board_state, empty_cells, mark):\n    \"\"\" Predict the result for each possible move\n    \"\"\"\n    preds = []\n    empty_index = move_encoder.transform([toStr(e) for e in empty_cells]) # transform empty cells to index using encoder\n    for i in empty_index:\n        p = np.reshape([\n            bs_encoder.transform([toStr(board_state)])[0],\n            mark_encoder.transform([mark])[0],\n            i\n        ],  (1, -1))\n        preds.append((model.predict(p), i)) # predict result for each possible move and store in a list\n    move = getMoveFromPred(preds, empty_cells)\n    \n    return move","204d8b51":"win = TicTacToe(placeMark).simulateGame()\nif win == 1:\n    print('Won')\nelif win == -1:\n    print('Lost')\nelse:\n    print('Draw') ","eea36298":"n_games = 500\nwin = TicTacToe(placeMark).simulate(n_games)\nprint(f'Player won {win} out of {n_games} games (win rate = {round((win\/n_games) * 100, 2)}%)')","2ca07ff5":"class TicTacToeAI:\n    X_MARK = 'X'\n    O_MARK = 'O'\n\n    def __init__(self, callback_X, callback_O):\n        if not callable(callback_X) or not callable(callback_O):\n            raise Exception('TicTacToeAI need two functions to retrieve next moves')\n        self.callback_X = callback_X\n        self.callback_O = callback_O\n\n    def _resetBoard(self):\n        self.board = [\n            [None, None, None],\n            [None, None, None],\n            [None, None, None]\n        ]\n\n    def _getEmpty(self):\n        empty = []\n        for ri, row in enumerate(self.board):\n            for ci, cell in enumerate(row):\n                if cell is None:\n                    empty.append((ri, ci))\n        return empty\n\n    def _playMove(self, move, mark):\n        row, col = move\n        if self.board[row][col] != None:\n            return -1\n        self.board[row][col] = mark\n        return 1 if not self._getEmpty() else 0\n\n    def _checkBoard(self):\n        b = self.board\n        for i in range(3):\n            if (b[i][0] and b[i][0] == b[i][1] and b[i][1] == b[i][2]): # row\n                return b[i][0]\n            if (b[0][i] and b[0][i] == b[1][i] and b[1][i] == b[2][i]): # column\n                return b[0][i]\n        if (b[0][0] and b[0][0] == b[1][1] and b[1][1] == b[2][2]): # diagonal\n            return b[0][0]\n        if (b[0][2] and b[0][2] == b[1][1] and b[1][1] == b[2][0]): # diagonal\n            return b[0][2]\n        return None\n\n    def _printBoard(self):\n        p = lambda row, col: self.board[row][col] or ' '\n        print( '\\n -----')\n        print( '|' + p(0,0) + '|' + p(0,1) + '|' + p(0,2) + '|')\n        print( ' -----')\n        print( '|' + p(1,0) + '|' + p(1,1) + '|' + p(1,2) + '|')\n        print( ' -----')\n        print( '|' + p(2,0) + '|' + p(2,1) + '|' + p(2,2) + '|')\n        print( ' -----\\n')\n\n    def _getSeq(self, play_first):\n        if play_first == 'X':\n            return [('X', self.callback_X), ('O', self.callback_O)]\n        else:\n            return [('O', self.callback_O), ('X', self.callback_X)]\n\n    def simulateGame(self, play_first='X', verbose=False):\n        self._resetBoard()\n        sequence = self._getSeq(play_first)\n        printBoard = lambda: self._printBoard() if verbose else None\n        empty = self._getEmpty()\n        win = None\n        while empty and not win:\n            for mark, callback in sequence:\n                printBoard()\n                move = callback(self.board, empty, mark)\n                self._playMove(move, mark)\n                win = self._checkBoard()\n                empty = self._getEmpty()\n                if not empty or win:\n                    break\n        return win if win in ['X', 'O'] else 'D'\n\n    def simulate(self, n_games):\n        win_X = 0\n        win_O = 0\n        for _ in range(n_games):\n            play_first = random.choice(['X', 'O'])\n            res = self.simulateGame(play_first=play_first)\n            if res == 'X':\n                win_X += 1\n            elif res == 'O':\n                win_O += 1\n        return (win_X, win_O)\n\n\ndef placeMark1(board_state, empty_cells, mark):\n    # X\n    return random.choice(empty_cells)\n\ndef placeMark2(board_state, empty_cells, mark):\n    # O\n    return random.choice(empty_cells)\n\nif __name__ == '__main__':\n    from datetime import datetime\n    random.seed(datetime.now())\n\n    n_games = 5000\n    win_X, win_O = TicTacToeAI(placeMark1, placeMark2).simulate(n_games)\n    print(f'Player X won {win_X} out of {n_games} games (win rate = {round((win_X\/n_games) * 100, 2)}%)')\n    print(f'Player O won {win_O} out of {n_games} games (win rate = {round((win_O\/n_games) * 100, 2)}%)')\n","a7b066a2":"from sklearn.ensemble import RandomForestRegressor\n\nrf = RandomForestRegressor(n_estimators=100)\nrf.fit(X.values, y.ravel())","93aedd60":"def placeMarkRF(board_state, empty_cells, mark):\n    \"\"\" Predict the result for each possible move\n    \"\"\"\n    preds = []\n    empty_index = move_encoder.transform([toStr(e) for e in empty_cells]) # transform empty cells to index using encoder\n    for i in empty_index:\n        p = np.reshape([\n            bs_encoder.transform([toStr(board_state)])[0],\n            mark_encoder.transform([mark])[0],\n            i\n        ],  (1, -1))\n        preds.append((rf.predict(p), i)) # predict result for each possible move and store in a list\n    move = getMoveFromPred(preds, empty_cells)\n    \n    return move","25694df3":"def placeMark1(board_state, empty_cells, mark):\n    return random.choice(empty_cells)\n\ndef placeMark2(board_state, empty_cells, mark):\n    return empty_cells[0]","07507b6e":"n_games = 100\nwin_X, win_O = TicTacToeAI(placeMark1, placeMark2).simulate(n_games)\nprint(f'Player X won {win_X} out of {n_games} games (win rate = {round((win_X\/n_games) * 100, 2)}%)')\nprint(f'Player O won {win_O} out of {n_games} games (win rate = {round((win_O\/n_games) * 100, 2)}%)')","c512e489":"win_X, win_O = TicTacToeAI(placeMark1, placeMarkRF).simulate(n_games)\nprint(f'Player X won {win_X} out of {n_games} games (win rate = {round((win_X\/n_games) * 100, 2)}%)')\nprint(f'Player O won {win_O} out of {n_games} games (win rate = {round((win_O\/n_games) * 100, 2)}%)')","bfeca2a4":"win_X, win_O = TicTacToeAI(placeMark, placeMarkRF).simulate(n_games)\nprint(f'Player X won {win_X} out of {n_games} games (win rate = {round((win_X\/n_games) * 100, 2)}%)')\nprint(f'Player O won {win_O} out of {n_games} games (win rate = {round((win_O\/n_games) * 100, 2)}%)')","97a4cc6c":"# Discuss Your Results","353f4746":"# AI vs AI\nCan we train another model and play some games with **AI vs AI**?","f9e0085b":"# Tic-Tac-Toe Player\n\nTo play you need a function that return the next move expressed with a tuple of integer (row, col) in a range 0-8. The function receive the `board_state` parameter as a list of rows with the value inside or `None` otherwhise. The parameter `empty_cells` with a list of positions (tuples) that are currently empty and the parameter `mark` choosen by the user (X or O).\n\nHere is a simple (though unintelligent) example.","4ecc29bb":"# Simulate lots of random games\n\nI simulated 100K games saving info and results for each of them. Initial conditions for each game and the next move are choosen randomly from the empty-cells bucket. Finally, we put all the games logs into a new DataFrame.","07b0d23e":"Or try to simulate multiple random games","8e0a521e":"# Tic-Tac-Toe\n\nInspired by the [**Blackjack Microchallenge**](https:\/\/www.kaggle.com\/learn\/microchallenges) from the kaggle teams, I decided to create an AI for playing tic-tac-toe autonomously.\n\n<img src=\"https:\/\/upload.wikimedia.org\/wikipedia\/commons\/3\/32\/Tic_tac_toe.svg\" alt=\"Tic tac toe.svg\" height=\"145\" width=\"163\">\n\nIn the Blackjack exercise the results of the AI are not much better than play randomly. So I want to test the performance of a machine learning resolution approach with another game.\n\n# Rules\n\n1. The game is played on a grid that's 3 squares by 3 squares.\n\n2. You are X, your friend (or the computer in this case) is O. Players take turns putting their marks in empty squares.\n\n3. The first player to get 3 of her marks in a row (up, down, across, or diagonally) is the winner.\n\n4. When all 9 squares are full, the game is over. If no player has 3 marks in a row, the game ends in a tie.\n\n# Code\n\nI created a python implementation of the game with an opponent that play random moves.","863d8fb1":"We can try to simulate a single game or a lots of games and check the accuracy of the model.","a26d0f1d":"[My attemps](https:\/\/www.kaggle.com\/ikarus777\/blackjack-microchallenge-812b68) to improve the obtained results when I played blackjack randomly didn't go very well. Actually, the differences from random playing vs AI are very little with an accuracy of 41.7% vs 42.7%. So for my blackjack solution, the machine learning approach didn't improve the score obtained when I played randomly.\n\nIn this case the results are different. While play randomly gave us an accuracy around ~44%, the results obtained using the trained model are around ~92%. So a very good **increase**. Anyway, we should keep in mind that the adversary play *completely random* and cannot learn from the mistakes.","a8f830e1":"# Encode features\nI encode all the categorical features, saving the `LabelEncoder` instances for later.","02cdd63f":"# Testing our AI\nFor using the AI in our `placeMark` function, I created a loop for each empty cell, where we test the predicted results with the model. After that, I retrieved the move with the best predicted result and returned for placing my mark. I used the previously saved encoders to inverse transform the move from the integer value to the string one.","35580ae2":"# Model fitting","40258944":"The `TicTacToe` instance receive the place-mark function as a parameter. We can try to simulate a single game."}}