{"cell_type":{"df30fb37":"code","e07425d5":"code","932bd137":"code","e4ca5725":"code","2d796b5a":"code","5f32d721":"code","6777346b":"code","a473ee7a":"code","8d023ca8":"code","cd28bc0a":"code","0a7aba99":"code","de69211c":"code","b6beb4b1":"code","fe11a099":"code","64c565db":"code","c8d1560d":"code","3a1aed6b":"code","f28718d0":"code","e09d928a":"code","546425a7":"code","e5a3494c":"code","ba5fc3ff":"code","e9391516":"code","1495063b":"code","9ad6ff8f":"code","1661ad58":"code","83bf818e":"code","116824af":"code","a5ca2a16":"code","bbc6bdd9":"code","009cfbdd":"markdown","adbc95cc":"markdown","ec7da33f":"markdown","1b383484":"markdown","2f505b0f":"markdown","ea6842ae":"markdown","c30e9d8d":"markdown","32c34cd9":"markdown","94967ec8":"markdown","1fbacf29":"markdown","b0baadcd":"markdown","42bbd7a4":"markdown","3f5b93bb":"markdown","5adcfa16":"markdown","b5b274f0":"markdown","64e59356":"markdown","aec7b000":"markdown","03d33dd5":"markdown","4c7f666b":"markdown","3d48e536":"markdown"},"source":{"df30fb37":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","e07425d5":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import classification_report\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import confusion_matrix\nfrom keras.utils.np_utils import to_categorical\nfrom sklearn.utils import class_weight\nimport warnings\nwarnings.filterwarnings('ignore')\n","932bd137":"train_df=pd.read_csv('\/kaggle\/input\/heartbeat\/mitbih_train.csv',header=None)\ntest_df=pd.read_csv('\/kaggle\/input\/heartbeat\/mitbih_test.csv',header=None)","e4ca5725":"train_df[187]=train_df[187].astype(int)\nequilibre=train_df[187].value_counts()\nprint(equilibre)\n\n\n","2d796b5a":"plt.figure(figsize=(20,10))\nmy_circle=plt.Circle( (0,0), 0.7, color='white')\nplt.pie(equilibre, labels=['normal beat','unknown Beats','Ventricular ectopic beats','Supraventricular ectopic beats','Fusion Beats'], colors=['red','green','blue','skyblue','orange'],autopct='%1.1f%%')\np=plt.gcf()\np.gca().add_artist(my_circle)\nplt.show()","5f32d721":"from sklearn.utils import resample\ndf_1=train_df[train_df[187]==1]\ndf_2=train_df[train_df[187]==2]\ndf_3=train_df[train_df[187]==3]\ndf_4=train_df[train_df[187]==4]\ndf_0=(train_df[train_df[187]==0]).sample(n=20000,random_state=42)\n\ndf_1_upsample=resample(df_1,replace=True,n_samples=20000,random_state=123)\ndf_2_upsample=resample(df_2,replace=True,n_samples=20000,random_state=124)\ndf_3_upsample=resample(df_3,replace=True,n_samples=20000,random_state=125)\ndf_4_upsample=resample(df_4,replace=True,n_samples=20000,random_state=126)\n\ntrain_df=pd.concat([df_0,df_1_upsample,df_2_upsample,df_3_upsample,df_4_upsample])","6777346b":"equilibre=train_df[187].value_counts()\nprint(equilibre)\n","a473ee7a":"plt.figure(figsize=(20,10))\nmy_circle=plt.Circle( (0,0), 0.7, color='white')\nplt.pie(equilibre, labels=['normal beat','unknown Beats','Ventricular ectopic beats','Supraventricular ectopic beats','Fusion Beats'], colors=['red','green','blue','skyblue','orange'],autopct='%1.1f%%')\np=plt.gcf()\np.gca().add_artist(my_circle)\nplt.show()","8d023ca8":"c=train_df.groupby(187,group_keys=False).apply(lambda train_df : train_df.sample(1))","cd28bc0a":"c","0a7aba99":"\n\nplt.subplot(1, 5, 1)  # 1 line, 2 rows, index nr 1 (first position in the subplot)\nplt.plot(c.iloc[0,:186])\nplt.subplot(1, 5, 2)  # 1 line, 2 rows, index nr 2 (second position in the subplot)\nplt.plot(c.iloc[1,:186])\nplt.subplot(1, 5, 3)  # 1 line, 2 rows, index nr 2 (second position in the subplot)\nplt.plot(c.iloc[2,:186])\nplt.subplot(1, 5, 4)  # 1 line, 2 rows, index nr 2 (second position in the subplot)\nplt.plot(c.iloc[3,:186])\nplt.subplot(1, 5, 5)  # 1 line, 2 rows, index nr 2 (second position in the subplot)\nplt.plot(c.iloc[4,:186])\n\nplt.show()\n\n\n\n","de69211c":"def plot_hist(class_number,size,min_):\n    img=train_df.loc[train_df[187]==class_number].values\n    img=img[:,min_:size]\n    img_flatten=img.flatten()\n\n    final1=np.arange(min_,size)\n    for i in range (img.shape[0]-1):\n        tempo1=np.arange(min_,size)\n        final1=np.concatenate((final1, tempo1), axis=None)\n    print(len(final1))\n    print(len(img_flatten))\n    plt.hist2d(final1,img_flatten, bins=(80,80),cmap=plt.cm.jet)\n    plt.show()","b6beb4b1":"plot_hist(0,70,5)","fe11a099":" plt.plot(c.iloc[1,:186])","64c565db":"plot_hist(1,50,5)","c8d1560d":" plt.plot(c.iloc[2,:186])","3a1aed6b":"plot_hist(2,60,30)","f28718d0":"plt.plot(c.iloc[3,:186])","e09d928a":"plot_hist(3,60,25)","546425a7":"plt.plot(c.iloc[4,:186])","e5a3494c":"plot_hist(4,50,18)","ba5fc3ff":"def add_gaussian_noise(signal):\n    noise=np.random.normal(0,0.05,186)\n    return (signal+noise)\n","e9391516":"tempo=c.iloc[0,:186]\nbruiter=add_gaussian_noise(tempo)\n\nplt.subplot(2,1,1)\nplt.plot(c.iloc[0,:186])\n\nplt.subplot(2,1,2)\nplt.plot(bruiter)\n\nplt.show()\n\n","1495063b":"target_train=train_df[187]\ntarget_test=test_df[187]\ny_train=to_categorical(target_train)\ny_test=to_categorical(target_test)","9ad6ff8f":"X_train=train_df.iloc[:,:186].values\nX_test=test_df.iloc[:,:186].values\n#for i in range(len(X_train)):\n#    X_train[i,:186]= add_gaussian_noise(X_train[i,:186])\nX_train = X_train.reshape(len(X_train), X_train.shape[1],1)\nX_test = X_test.reshape(len(X_test), X_test.shape[1],1)","1661ad58":"def network(X_train,y_train,X_test,y_test):\n    \n\n    im_shape=(X_train.shape[1],1)\n    inputs_cnn=Input(shape=(im_shape), name='inputs_cnn')\n    conv1_1=Convolution1D(64, (6), activation='relu', input_shape=im_shape)(inputs_cnn)\n    conv1_1=BatchNormalization()(conv1_1)\n    pool1=MaxPool1D(pool_size=(3), strides=(2), padding=\"same\")(conv1_1)\n    conv2_1=Convolution1D(64, (3), activation='relu', input_shape=im_shape)(pool1)\n    conv2_1=BatchNormalization()(conv2_1)\n    pool2=MaxPool1D(pool_size=(2), strides=(2), padding=\"same\")(conv2_1)\n    conv3_1=Convolution1D(64, (3), activation='relu', input_shape=im_shape)(pool2)\n    conv3_1=BatchNormalization()(conv3_1)\n    pool3=MaxPool1D(pool_size=(2), strides=(2), padding=\"same\")(conv3_1)\n    flatten=Flatten()(pool3)\n    dense_end1 = Dense(64, activation='relu')(flatten)\n    dense_end2 = Dense(32, activation='relu')(dense_end1)\n    main_output = Dense(5, activation='softmax', name='main_output')(dense_end2)\n    \n    \n    model = Model(inputs= inputs_cnn, outputs=main_output)\n    model.compile(optimizer='adam', loss='categorical_crossentropy',metrics = ['accuracy'])\n    \n    \n    callbacks = [EarlyStopping(monitor='val_loss', patience=8),\n             ModelCheckpoint(filepath='best_model.h5', monitor='val_loss', save_best_only=True)]\n\n    history=model.fit(X_train, y_train,epochs=5,callbacks=callbacks, batch_size=32,validation_data=(X_test,y_test))\n    model.load_weights('best_model.h5')\n    return(model,history)","83bf818e":"def evaluate_model(history,X_test,y_test,model):\n    scores = model.evaluate((X_test),y_test, verbose=0)\n    print(\"Accuracy: %.2f%%\" % (scores[1]*100))\n    \n    print(history)\n    fig1, ax_acc = plt.subplots()\n    plt.plot(history.history['accuracy'])\n    plt.plot(history.history['val_accuracy'])\n    plt.xlabel('Epoch')\n    plt.ylabel('Accuracy')\n    plt.title('Model - Accuracy')\n    plt.legend(['Training', 'Validation'], loc='lower right')\n    plt.show()\n    \n    fig2, ax_loss = plt.subplots()\n    plt.xlabel('Epoch')\n    plt.ylabel('Loss')\n    plt.title('Model- Loss')\n    plt.legend(['Training', 'Validation'], loc='upper right')\n    plt.plot(history.history['loss'])\n    plt.plot(history.history['val_loss'])\n    plt.show()\n    target_names=['0','1','2','3','4']\n    \n    y_true=[]\n    for element in y_test:\n        y_true.append(np.argmax(element))\n    prediction_proba=model.predict(X_test)\n    prediction=np.argmax(prediction_proba,axis=1)\n    cnf_matrix = confusion_matrix(y_true, prediction)\n    ","116824af":"from keras.layers import Dense, Convolution1D, MaxPool1D, Flatten, Dropout\nfrom keras.layers import Input\nfrom keras.models import Model\nfrom keras.layers.normalization import BatchNormalization\nimport keras\nfrom keras.callbacks import EarlyStopping, ModelCheckpoint\n\nmodel,history=network(X_train,y_train,X_test,y_test)\n\n","a5ca2a16":"evaluate_model(history,X_test,y_test,model)\ny_pred=model.predict(X_test)\n","bbc6bdd9":"import itertools\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        print(\"Normalized confusion matrix\")\n    else:\n        print('Confusion matrix, without normalization')\n\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j], fmt),\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')\n\n# Compute confusion matrix\ncnf_matrix = confusion_matrix(y_test.argmax(axis=1), y_pred.argmax(axis=1))\nnp.set_printoptions(precision=2)\n\n# Plot non-normalized confusion matrix\nplt.figure(figsize=(10, 10))\nplot_confusion_matrix(cnf_matrix, classes=['N', 'S', 'V', 'F', 'Q'],normalize=True,\n                      title='Confusion matrix, with normalization')\nplt.show()\n\n","009cfbdd":"In this part i want to study the differente classes. ","adbc95cc":"Here is an exemple of the two classes :\n\n![4-Figure2-1.png](attachment:4-Figure2-1.png)\n\nin the second and third line you have the 2 et 3 class.","ec7da33f":"**Pretreat**","1b383484":"**Network**","2f505b0f":"**Classes**","ea6842ae":"We can underligned a huge difference in the balanced of the classes. After some try i have decided to  choose the resample technique more than the class weights for the algorithms. ","c30e9d8d":"**Balance of dataset**","32c34cd9":"![image.png](attachment:image.png)\n","94967ec8":"I will not comment a lot this one because it correspond to other class. ","1fbacf29":"Hi Professor Groza , I tried to predict different arrhytmia on ECG. There are two datasets avaialble and I considered at start only one : mitbih.\nThe MIT-BIH Arrhythmia Database contains 48 half-hour excerpts of two-channel ambulatory ECG recordings, obtained from 47 subjects studied by the BIH Arrhythmia Laboratory between 1975 and 1979. Twenty-three recordings were chosen at random from a set of 4000 24-hour ambulatory ECG recordings collected from a mixed population of inpatients (about 60%) and outpatients (about 40%) at Boston's Beth Israel Hospital; the remaining 25 recordings were selected from the same set to include less common but clinically significant arrhythmias that would not be well-represented in a small random sample.\n\n\n\nArrhythmia Dataset\n\n    Number of Samples: 109446\n    Number of Categories: 5\n    Sampling Frequency: 125Hz\n    Data Source: Physionet's MIT-BIH Arrhythmia Dataset\n    Classes: ['N': 0, 'S': 1, 'V': 2, 'F': 3, 'Q': 4]\n\n\n-N : Non-ecotic beats (normal beat)\n-S : Supraventricular ectopic beats\n-V : Ventricular ectopic beats\n-F : Fusion Beats\n-Q : Unknown Beats","b0baadcd":"Resample works perfectly we can go on. ","42bbd7a4":"i take the next function from : https:\/\/www.kaggle.com\/coni57\/model-from-arxiv-1805-00794","3f5b93bb":"I use a fonction ( will depend of the version) where i add a noise to the data to generilize my train.","5adcfa16":"Here is a representation for all the class. We take all the signal and map them. Like that we have an estimation what the signal can look like.","b5b274f0":"I take one sample per class and i store it in a datafrmae in order to have an exmeple. ","64e59356":"**Load Data**","aec7b000":"**INTRODUCTION**","03d33dd5":"In this part i will speak o n what i do to transform data. ","4c7f666b":"Here is a normal beat. I don't have something particular to say on that class.  ","3d48e536":"Fusion beat :\n![3-s2.0-B9780124159365000098-f09-10-9780124159365.jpg](attachment:3-s2.0-B9780124159365000098-f09-10-9780124159365.jpg)\n\nDon't really see the difference with the previous one but i'm not an expert of ECG!"}}