{"cell_type":{"f777c4ad":"code","c0550864":"code","7d8beb84":"code","a87aa84f":"code","ee56e065":"code","b1f054a9":"code","213f16f5":"code","f94ff8d1":"code","e5e01d3f":"code","910cf923":"code","d403a21c":"code","c6a0bf1e":"code","12c04715":"code","e713ced0":"code","7cbb79a3":"code","89e5c8c9":"code","f29367e8":"code","9230ea26":"code","0d6c6d30":"code","76550af6":"code","65768307":"code","9f1a74a5":"code","e62c60fc":"code","c9e3b772":"code","a855aecc":"code","ad9e7c8d":"code","ec0aafd6":"code","d935b2d2":"code","b6111835":"code","41d7fccc":"code","7fbc2960":"code","c83bd972":"code","0ad7419e":"code","24f6baa7":"code","86e8b066":"code","0d8602fe":"code","7b20adad":"code","aaf15c7c":"code","c879874c":"code","f7271670":"code","5d4f3d89":"code","c5e83826":"code","02d9f1df":"code","e05209f6":"code","74c5f4f1":"code","87b4efaf":"code","596631b3":"code","f7c3d1c3":"code","6562837d":"code","b3298a79":"code","66ad9cc4":"code","598ff010":"code","370a12af":"code","80363065":"code","f4f64176":"code","8da7a8c2":"code","6a818c9b":"code","13898404":"code","cbcbede4":"code","86f0a4dd":"code","f3e3c6c2":"markdown","2b10021b":"markdown","bb135767":"markdown","8dd27c01":"markdown","475a72a0":"markdown","5607af64":"markdown","8220bc01":"markdown","ec5c24f2":"markdown","09a78e28":"markdown","a63cbedc":"markdown","059b2ae8":"markdown","24a8893d":"markdown","2cef5da0":"markdown","f5272cfd":"markdown","d75746ca":"markdown","43a1e5b1":"markdown","01efb07b":"markdown","7befdc2c":"markdown","49bc1b91":"markdown","3e48d8c4":"markdown","4537d9c3":"markdown","552aed3b":"markdown","9e35ff41":"markdown","a7f50b02":"markdown","4a5be81e":"markdown","84a69ada":"markdown","cbaaba8c":"markdown","479ac76a":"markdown","e9b02c5f":"markdown","bfcb4a98":"markdown","65452f1e":"markdown","4a0ae132":"markdown","9e355916":"markdown","f70ab2ee":"markdown","ce9ab8a0":"markdown","7197fd5f":"markdown","fca03c1b":"markdown","ea28b8dd":"markdown","2637b97b":"markdown"},"source":{"f777c4ad":"# Imports\nimport torch\nimport torchvision\nfrom torchvision.datasets import MNIST","c0550864":"# Download training dataset\ndataset = MNIST(root='data\/', download=True)","7d8beb84":"len(dataset)","a87aa84f":"test_dataset = MNIST(root='data\/', train=False)\nlen(test_dataset)","ee56e065":"dataset[0]","b1f054a9":"import matplotlib.pyplot as plt\n%matplotlib inline","213f16f5":"image, label = dataset[0]\nplt.imshow(image, cmap='gray')\nprint('Label:', label)","f94ff8d1":"image, label = dataset[10]\nplt.imshow(image, cmap='gray')\nprint('Label:', label)","e5e01d3f":"import torchvision.transforms as transforms","910cf923":"# MNIST dataset (images and labels)\ndataset = MNIST(root='data\/', \n                train=True,\n                transform=transforms.ToTensor())","d403a21c":"img_tensor, label = dataset[0]\nprint(img_tensor.shape, label)","c6a0bf1e":"print(img_tensor[:,10:15,10:15])\nprint(torch.max(img_tensor), torch.min(img_tensor))","12c04715":"# Plot the image by passing in the 28x28 matrix\nplt.imshow(img_tensor[0,10:15,10:15], cmap='gray');","e713ced0":"from torch.utils.data import random_split\n\ntrain_ds, val_ds = random_split(dataset, [50000, 10000])\nlen(train_ds), len(val_ds)","7cbb79a3":"from torch.utils.data import DataLoader\n\nbatch_size = 128\n\ntrain_loader = DataLoader(train_ds, batch_size, shuffle=True)\nval_loader = DataLoader(val_ds, batch_size)","89e5c8c9":"!pip install jovian --upgrade --quiet","f29367e8":"import jovian","9230ea26":"# jovian.commit(project='03-logistic-regression', environment=None)","0d6c6d30":"import torch.nn as nn\n\ninput_size = 28*28\nnum_classes = 10\n\n# Logistic regression model\nmodel = nn.Linear(input_size, num_classes)","76550af6":"print(model.weight.shape)\nmodel.weight","65768307":"print(model.bias.shape)\nmodel.bias","9f1a74a5":"# for images, labels in train_loader:\n#     print(labels)\n#     print(images.shape)\n#     outputs = model(images)\n#     break","e62c60fc":"class MnistModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear = nn.Linear(input_size, num_classes)\n        \n    def forward(self, xb):\n        xb = xb.reshape(-1, 784)\n        out = self.linear(xb)\n        return out\n    \nmodel = MnistModel()","c9e3b772":"print(model.linear.weight.shape, model.linear.bias.shape)\nlist(model.parameters())","a855aecc":"for images, labels in train_loader:\n    outputs = model(images)\n    break\n\nprint('outputs.shape : ', outputs.shape)\nprint('Sample outputs :\\n', outputs[:2].data)","ad9e7c8d":"import torch.nn.functional as F","ec0aafd6":"# Apply softmax for each output row\nprobs = F.softmax(outputs, dim=1)\n\n# Look at sample probabilities\nprint(\"Sample probabilities:\\n\", probs[:3].data)\n\n# Add up the probabilities of an output row\nprint(\"Sum: \", torch.sum(probs[0]).item())","d935b2d2":"max_probs, preds = torch.max(probs, dim=1)\nprint(preds)\nprint(max_probs)","b6111835":"labels","41d7fccc":"def accuracy(outputs, labels):\n    _, preds = torch.max(outputs, dim=1)\n    return torch.tensor(torch.sum(preds == labels).item() \/ len(preds))","7fbc2960":"accuracy(outputs, labels)","c83bd972":"loss_fn = F.cross_entropy","0ad7419e":"# Loss for current batch of data\nloss = loss_fn(outputs, labels)\nprint(loss)","24f6baa7":"class MnistModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear = nn.Linear(input_size, num_classes)\n        \n    def forward(self, xb):\n        xb = xb.reshape(-1, 784)\n        out = self.linear(xb)\n        return out\n    \n    def training_step(self, batch):\n        images, labels = batch \n        out = self(images)                  # Generate predictions\n        loss = F.cross_entropy(out, labels) # Calculate loss\n        return loss\n    \n    def validation_step(self, batch):\n        images, labels = batch \n        out = self(images)                    # Generate predictions\n        loss = F.cross_entropy(out, labels)   # Calculate loss\n        acc = accuracy(out, labels)           # Calculate accuracy\n        return {'val_loss': loss, 'val_acc': acc}\n        \n    def validation_epoch_end(self, outputs):\n        batch_losses = [x['val_loss'] for x in outputs]\n        epoch_loss = torch.stack(batch_losses).mean()   # Combine losses\n        batch_accs = [x['val_acc'] for x in outputs]\n        epoch_acc = torch.stack(batch_accs).mean()      # Combine accuracies\n        return {'val_loss': epoch_loss.item(), 'val_acc': epoch_acc.item()}\n    \n    def epoch_end(self, epoch, result):\n        print(\"Epoch [{}], val_loss: {:.4f}, val_acc: {:.4f}\".format(epoch, result['val_loss'], result['val_acc']))\n    \nmodel = MnistModel()","86e8b066":"def evaluate(model, val_loader):\n    outputs = [model.validation_step(batch) for batch in val_loader]\n    return model.validation_epoch_end(outputs)\n\ndef fit(epochs, lr, model, train_loader, val_loader, opt_func=torch.optim.SGD):\n    history = []\n    optimizer = opt_func(model.parameters(), lr)\n    for epoch in range(epochs):\n        # Training Phase \n        for batch in train_loader:\n            loss = model.training_step(batch)\n            loss.backward()\n            optimizer.step()\n            optimizer.zero_grad()\n        # Validation phase\n        result = evaluate(model, val_loader)\n        model.epoch_end(epoch, result)\n        history.append(result)\n    return history","0d8602fe":"result0 = evaluate(model, val_loader)\nresult0","7b20adad":"history1 = fit(5, 0.05, model, train_loader, val_loader)","aaf15c7c":"history2 = fit(10, 0.001, model, train_loader, val_loader)","c879874c":"history3 = fit(5, 0.0001, model, train_loader, val_loader)","f7271670":"# Replace these values with your results\nhistory = [result0] + history1 + history2 + history3\naccuracies = [result['val_acc'] for result in history]\nplt.plot(accuracies, '-x')\nplt.xlabel('epoch')\nplt.ylabel('accuracy')\nplt.title('Accuracy vs. No. of epochs');","5d4f3d89":"# Replace these values with your results\nhistory = [result0] + history1 + history2 + history3\naccuracies = [result['val_acc'] for result in history]\nplt.plot(accuracies, '-x')\nplt.xlabel('epoch')\nplt.ylabel('accuracy')\nplt.title('Accuracy vs. No. of epochs');","c5e83826":"# Replace these values with your results\nhistory = [result0] + history1 + history2 + history3\naccuracies = [result['val_acc'] for result in history]\nplt.plot(accuracies, '-x')\nplt.xlabel('epoch')\nplt.ylabel('accuracy')\nplt.title('Accuracy vs. No. of epochs');","02d9f1df":"jovian.log_metrics(val_acc=history[-1]['val_acc'], val_loss=history[-1]['val_loss'])","e05209f6":"jovian.commit(project='logistic-regression-pytorch', environment=None)","74c5f4f1":"# Define test dataset\ntest_dataset = MNIST(root='data\/', \n                     train=False,\n                     transform=transforms.ToTensor())","87b4efaf":"img, label = test_dataset[0]\nplt.imshow(img[0], cmap='gray')\nprint('Shape:', img.shape)\nprint('Label:', label)","596631b3":"img.unsqueeze(0).shape","f7c3d1c3":"def predict_image(img, model):\n    xb = img.unsqueeze(0)\n    yb = model(xb)\n    _, preds  = torch.max(yb, dim=1)\n    return preds[0].item()","6562837d":"img, label = test_dataset[0]\nplt.imshow(img[0], cmap='gray')\nprint('Label:', label, ', Predicted:', predict_image(img, model))","b3298a79":"img, label = test_dataset[10]\nplt.imshow(img[0], cmap='gray')\nprint('Label:', label, ', Predicted:', predict_image(img, model))","66ad9cc4":"img, label = test_dataset[193]\nplt.imshow(img[0], cmap='gray')\nprint('Label:', label, ', Predicted:', predict_image(img, model))","598ff010":"img, label = test_dataset[1839]\nplt.imshow(img[0], cmap='gray')\nprint('Label:', label, ', Predicted:', predict_image(img, model))","370a12af":"test_loader = DataLoader(test_dataset, batch_size=256)\nresult = evaluate(model, test_loader)\nresult","80363065":"torch.save(model.state_dict(), 'mnist-logistic.pth')","f4f64176":"model.state_dict()","8da7a8c2":"model2 = MnistModel()\nmodel2.load_state_dict(torch.load('mnist-logistic.pth'))\nmodel2.state_dict()","6a818c9b":"test_loader = DataLoader(test_dataset, batch_size=256)\nresult = evaluate(model2, test_loader)\nresult","13898404":"img, label = test_dataset[0]\nplt.imshow(img[0], cmap='gray')\n\nprint('Label:', label, ', Predicted:', predict_image(img, model))","cbcbede4":"i = 0\nfor x in test_dataset:\n    img, label = test_dataset[i]\n    print('Label:', label, ', Predicted:', predict_image(img, model))\n    i = i+1\n    if(i==50):\n        break","86f0a4dd":"jovian.commit(project='logistic-regression-pytorch', environment=None, outputs=['mnist-logistic.pth'])","f3e3c6c2":"Here's a sample image from the dataset.","2b10021b":"## Saving and loading the model","bb135767":"For each of the 100 input images, we get 10 outputs, one for each class. As discussed earlier, we'd like these outputs to represent probabilities, but for that the elements of each output row must lie between 0 to 1 and add up to 1, which is clearly not the case here. \n\nTo convert the output rows into probabilities, we use the softmax function, which has the following formula:\n\n![softmax](https:\/\/i.imgur.com\/EAh9jLN.png)\n\nFirst we replace each element `yi` in an output row by `e^yi`, which makes all the elements positive, and then we divide each element by the sum of all elements to ensure that they add up to 1. \n\nWhile it's easy to implement the softmax function (you should try it!), we'll use the implementation that's provided within PyTorch, because it works well with multidimensional tensors (a list of output rows in our case).","8dd27c01":"## Evaluation Metric and Loss Function","475a72a0":"The `.state_dict` method returns an `OrderedDict` containing all the weights and bias matrices mapped to the right attributes of the model.","5607af64":"The `fit` function records the validation loss and metric from each epoch and returns a history of the training process. This is useful for debuggin & visualizing the training process. Before we train the model, let's see how the model performs on the validation set with the initial set of randomly initialized weights & biases.\n\nConfigurations like batch size, learning rate etc. need to picked in advance while training machine learning models, and are called hyperparameters. Picking the right hyperparameters is critical for training an accurate model within a reasonable amount of time, and is an active area of research and experimentation. Feel free to try different learning rates and see how it affects the training process.","8220bc01":"The numbers printed above are the predicted labels for the first batch of training images. Let's compare them with the actual labels.","ec5c24f2":"While the accuracy does continue to increase as we train for more epochs, the improvements get smaller with every epoch. This is easier to see using a line graph.","09a78e28":"When this statement is executed for the first time, it downloads the data to the `data\/` directory next to the notebook and creates a PyTorch `Dataset`. On subsequent executions, the download is skipped as the data is already downloaded. Let's check the size of the dataset.","a63cbedc":"The image is now converted to a 1x28x28 tensor. The first dimension is used to keep track of the color channels. Since images in the MNIST dataset are grayscale, there's just one channel. Other datasets have images with color, in which case there are 3 channels: red, green and blue (RGB). Let's look at some sample values inside the tensor:","059b2ae8":"Inside the `__init__` constructor method, we instantiate(represent) the weights and biases using `nn.Linear`. And inside the `forward` method, which is invoked when we pass a batch of inputs to the model, we flatten out the input tensor, and then pass it into `self.linear`.\n\n`xb.reshape(-1, 28*28)` indicates to PyTorch that we want a *view* of the `xb` tensor with two dimensions, where the length along the 2nd dimension is 28\\*28 (i.e. 784). One argument to `.reshape` can be set to `-1` (in this case the first dimension), to let PyTorch figure it out automatically based on the shape of the original tensor.\n\nNote that the model no longer has `.weight` and `.bias` attributes (as they are now inside the `.linear` attribute), but it does have a `.parameters` method which returns a list containing the weights and bias, and can be used by a PyTorch optimizer.","24a8893d":"Since we've trained our model for a long time and achieved a resonable accuracy, it would be a good idea to save the weights and bias matrices to disk, so that we can reuse the model later and avoid retraining from scratch. Here's how you can save the model.","2cef5da0":"We expect this to be similar to the accuracy\/loss on the validation set. If not, we might need a better validation set that has similar data and distribution as the test set (which often comes from real world data).","f5272cfd":"It's a pair, consisting of a 28x28 image and a label. The image is an object of the class `PIL.Image.Image`, which is a part of the Python imaging library [Pillow](https:\/\/pillow.readthedocs.io\/en\/stable\/). We can view the image within Jupyter using [`matplotlib`](https:\/\/matplotlib.org\/), the de-facto plotting and graphing library for data science in Python.","d75746ca":"The softmax function is included in the `torch.nn.functional` package, and requires us to specify a dimension along which the softmax must be applied.","43a1e5b1":"Clearly, the predicted and the actual labels are completely different. Obviously, that's because we have started with randomly initialized weights and biases. We need to train the model i.e. adjust the weights using gradient descent to make better predictions.","01efb07b":"That's a great result! With just 5 epochs of training, our model has reached an accuracy of over 80% on the validation set. Let's see if we can improve that by training for a few more epochs.","7befdc2c":"## Testing with individual images","49bc1b91":"To load the model weights, we can instante a new object of the class `MnistModel`, and use the `.load_state_dict` method.","3e48d8c4":"PyTorch datasets allow us to specify one or more transformation functions which are applied to the images as they are loaded. `torchvision.transforms` contains many such predefined functions, and we'll use the `ToTensor` transform to convert images into PyTorch tensors.","4537d9c3":"While we have been tracking the overall accuracy of a model so far, it's also a good idea to look at model's results on some sample images. Let's test out our model with some images from the predefined test dataset of 10000 images. We begin by recreating the test dataset with the `ToTensor` transform.","552aed3b":"The dataset has 60,000 images which can be used to train the model. There is also an additonal test set of 10,000 images which can be created by passing `train=False` to the `MNIST` class.","9e35ff41":"# Image Classification using Logistic Regression in\u00a0PyTorch","a7f50b02":"Finally, we can determine the predicted label for each image by simply choosing the index of the element with the highest probability in each output row. This is done using `torch.max`, which returns the largest element and the index of the largest element along a particular dimension of a tensor.","4a5be81e":"Now we'll define an `evaluate` function, which will perform the validation phase, and a `fit` function which will peform the entire training process.","84a69ada":"`jovian.commit` uploads the notebook to your [Jovian.ml](https:\/\/jovian.ml) account and creates a sharable link for the notebook. You can use this link to share your work and let anyone reproduce it easily with the jovian clone command. Jovian also includes a powerful commenting interface, so you (and others) can discuss & comment on specific parts of your notebook.","cbaaba8c":"Just as a sanity check, let's verify that this model has the same loss and accuracy on the test set as before.","479ac76a":"Let's define a helper function `predict_image`, which returns the predicted label for a single image tensor.","e9b02c5f":"It's quite clear from the above picture that the model probably won't cross the accuracy threshold of 90% even after training for a very long time. One possible reason for this is that the learning rate might be too high. It's possible that the model's paramaters are \"bouncing\" around the optimal set of parameters that have the lowest loss. You can try reducing the learning rate and training for a few more epochs to see if it helps.\n\nThe more likely reason that **the model just isn't powerful enough**. If you remember our initial hypothesis, we have assumed that the output (in this case the class probabilities) is a **linear function** of the input (pixel intensities), obtained by perfoming a matrix multiplication with the weights matrix and adding the bias. This is a fairly weak assumption, as there may not actually exist a linear relationship between the pixel intensities in an image and the digit it represents. While it works reasonably well for a simple dataset like MNIST (getting us to 85% accuracy), we need more sophisticated models that can capture non-linear relationships between image pixels and labels for complex tasks like recognizing everyday objects, animals etc. \n\nThis would be a good time to save our work. Along with the notebook, we can also record some metrics from our training.","bfcb4a98":"Identifying where our model performs poorly can help us improve the model, by collecting more training data, increasing\/decreasing the complexity of the model, and changing the hypeparameters.\n\nAs a final step, let's also look at the overall loss and accuracy of the model on the test set.","65452f1e":"Of course, this model is a lot larger than our previous model, in terms of the number of parameters. Let's take a look at the weights and biases.","4a0ae132":"It's important to choose a random sample for creating a validation set, because training data is often ordered by the target labels i.e. images of 0s, followed by images of 1s, followed by images of 2s and so on. If we were to pick a 20% validation set simply by selecting the last 20% of the images, the validation set would only consist of images of 8s and 9s, whereas the training set would contain no images of 8s and 9s. This would make it impossible to train a good model using the training set, which also performs well on the validation set (and on real world data).\n\nWe can now created data loaders to help us load the data in batches. We'll use a batch size of 128.","9e355916":"## Commit and upload the notebook\n\nAs a final step, we can save and commit our work using the jovian library. Along with the notebook, we can also attach the weights of our trained model, so that we can use it later.","f70ab2ee":"`img.unsqueeze` simply adds another dimension at the begining of the 1x28x28 tensor, making it a 1x1x28x28 tensor, which the model views as a batch containing a single image.\n\nLet's try it out with a few images.","ce9ab8a0":"This leads to an error, because our input data does not have the right shape. Our images are of the shape 1x28x28, but we need them to be vectors of size 784 i.e. we need to flatten them out. We'll use the `.reshape` method of a tensor, which will allow us to efficiently 'view' each image as a flat vector, without really chaging the underlying data.\n\nTo include this additional functionality within our model, we need to define a custom model, by extending the `nn.Module` class from PyTorch.","7197fd5f":"The `==` performs an element-wise comparison of two tensors with the same shape, and returns a tensor of the same shape, containing 0s for unequal elements, and 1s for equal elements. Passing the result to `torch.sum` returns the number of labels that were predicted correctly. Finally, we divide by the total number of images to get the accuracy. \n\nNote that we don't need to apply softmax to the outputs, since it doesn't change the relative order of the results. This is because `e^x` is an increasing function i.e. if `y1 > y2`, then `e^y1 > e^y2` and the same holds true after averaging out the values to get the softmax.\n\nLet's calculate the accuracy of the current model, on the first batch of data. Obviously, we expect it to be pretty bad.","fca03c1b":"The initial accuracy is around 10%, which is what one might expect from a randomly intialized model (since it has a 1 in 10 chance of getting a label right by guessing randomly). Also note that we are using the `.format` method with the message string to print only the first four digits after the decimal point.\n\nWe are now ready to train the model. Let's train for 5 epochs and look at the results.","ea28b8dd":"Just as with linear regression, we need a way to evaluate how well our model is performing. A natural way to do this would be to find the percentage of labels that were predicted correctly i.e. the **accuracy** of the predictions. ","2637b97b":"Although there are a total of 7850 parameters here, conceptually nothing has changed so far. Let's try and generate some outputs using our model. We'll take the first batch of 100 images from our dataset, and pass them into our model."}}