{"cell_type":{"512be7d8":"code","80713281":"code","a7e8df8b":"code","cf411159":"code","68eef854":"code","211d02e0":"code","6c8af869":"code","33d61452":"code","24cdb1f6":"code","958dc45b":"code","cf80a742":"code","a952a165":"code","c7b082eb":"code","66cc48b4":"code","77962bee":"code","727425dd":"code","fb1c26e2":"code","7a9ecc0c":"code","20385ed6":"code","80effeff":"code","c25a64ba":"code","e1d8690e":"code","685caeb5":"code","484bd482":"code","d9d09cae":"code","00e93abf":"code","dea95a03":"code","2fa5bcb3":"code","0e89faa4":"markdown","79a0bafc":"markdown","7d9e2012":"markdown","d0906975":"markdown","b394f4c0":"markdown","8db96a05":"markdown","ba28bbf5":"markdown","dd9ecfa1":"markdown","24d41e5d":"markdown","983d993c":"markdown","895b2e64":"markdown","1ad10984":"markdown","3c6defbc":"markdown","f9aa0f56":"markdown","579a94df":"markdown","dc96157d":"markdown","60bd1ea3":"markdown","86f3df27":"markdown","d2c5ce24":"markdown","730c489b":"markdown","4e75507a":"markdown","857441c7":"markdown","68b876cf":"markdown","7a356bed":"markdown","8acd3b40":"markdown","ac56a6e2":"markdown","f288cb03":"markdown","03da8236":"markdown","b61a39b8":"markdown","af8f46e3":"markdown","d5b78d7c":"markdown","d4bfd77c":"markdown","fdf7dddf":"markdown","4bfebdc7":"markdown","fc9d163f":"markdown","483afb2c":"markdown"},"source":{"512be7d8":"import pandas as pd\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.tree import DecisionTreeRegressor\nimport numpy as np\nfrom sklearn.preprocessing import LabelEncoder\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport seaborn as sns\ncolor = sns.color_palette()\nsns.set_style('darkgrid')\nimport warnings\ndef ignore_warn(*args, **kwargs):\n    pass \nwarnings.warn = ignore_warn #ignore warning from sklearn and seaborn\n\n#pd.set_option('display.float_format', lambda x: '{:.2f}'.format(x)) #Limiting floats output to 2 decimal points\n","80713281":"# Path of the file to read. \ntrain_set = '..\/input\/train.csv'\ntrain = pd.read_csv(train_set)\n\ntrain.head()\n","a7e8df8b":"#Save the Primary Key IDcolumn in case we need it later\ntrain_ID = train['Id']\n\n#Drop Primary Key - \ntrain.drop(\"Id\", axis = 1, inplace = True)","cf411159":"#correlation matrix\ncorrmat = train.corr()\nf, ax = plt.subplots(figsize=(12, 9))\nsns.heatmap(corrmat, square=True);\n","68eef854":"#scatterplot correlated variables.\nsns.set()\ncols = ['SalePrice', 'OverallQual', 'GrLivArea', 'GarageCars', 'TotalBsmtSF', 'FullBath', 'YearBuilt']\nsns.pairplot(train[cols], size = 2.5)\nplt.show()","211d02e0":"#plot scatter to identify any outliers\nvar='GrLivArea'\n\nfig, ax = plt.subplots()\nax.scatter(x = train[var], y = train['SalePrice'])\nplt.ylabel('SalePrice', fontsize=10)\nplt.xlabel(var, fontsize=10)\nplt.show()","6c8af869":"#Delete outliers\ntrain = train.drop(train[(train['GrLivArea']>4000) & (train['SalePrice']<300000)].index)\n\n#Check the graph again\nvari = 'GrLivArea'\nfig, ax = plt.subplots()\nax.scatter(train[vari], train['SalePrice'])\nplt.ylabel('SalePrice', fontsize=13)\nplt.xlabel(vari, fontsize=13)\nplt.show()","33d61452":"#Plot the distribution of the Target column Y.\nsns.distplot(train['SalePrice'])\n\n","24cdb1f6":"#Sort out the distribution by using Log1p\ntrain[\"SalePrice\"] = np.log1p(train[\"SalePrice\"])\n\n#Check the new distribution \nsns.distplot(train['SalePrice'])","958dc45b":"#Show % of nulls per column\ntrain_na_percent = (train.isnull().sum() \/ len(train)).sort_values(ascending=False)\ntrain_na_total = train.isnull().sum().sort_values(ascending=False)\nmissing_data = pd.concat([train_na_percent, train_na_total], axis=1, keys=['%', 'Total'])[:30]\nmissing_data.head()","cf80a742":"#Graph it \nf, ax = plt.subplots(figsize=(6, 4))\nplt.xticks(rotation='90')\nsns.barplot(x=missing_data.index, y=missing_data['%'])\nplt.xlabel('Feature')\nplt.ylabel('Percent of missing values')\n","a952a165":"#Drop Columns with poor data\n\n#train = train.drop(['PoolQC', 'MiscFeature', 'Alley', 'Fence', 'FireplaceQu'], axis=1)\n\n\n","c7b082eb":"##FillNA with String\nfor col in ('PoolQC', 'MiscFeature', 'Alley', 'Fence', 'FireplaceQu','GarageType', 'GarageFinish', 'GarageQual', 'GarageCond','MSSubClass', 'MasVnrType', 'BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2'):\n    train[col] = train[col].fillna('None')\n     \n#FillNA with Median\ntrain[\"LotFrontage\"] = train.groupby(\"Neighborhood\")[\"LotFrontage\"].transform(lambda x: x.fillna(x.median()))\n\n#fillNA with Zero    \nfor col in ('GarageYrBlt', 'GarageArea', 'GarageCars','BsmtFinSF1', 'BsmtFinSF2', 'BsmtUnfSF','TotalBsmtSF', 'BsmtFullBath', 'BsmtHalfBath', 'MasVnrArea'):\n    train[col] = train[col].fillna(0)\n\n#fillNA with Mode    \nfor col in ('MSZoning', 'Electrical', 'Exterior1st', 'Exterior2nd', 'KitchenQual', 'SaleType'):\n    train[col] = train[col].fillna(train[col].mode()[0])\n\n#Drop\ntrain = train.drop(['Utilities'], axis=1)\n\n#Functional replace NA with Typ as per data descritpion - thanks @Sergine\ntrain[\"Functional\"] = train[\"Functional\"].fillna(\"Typ\")\n\n\n","66cc48b4":"#Check remaining missing values if any \ntrain_na = (train.isnull().sum() \/ len(train)) * 100\ntrain_na = train_na.drop(train_na[train_na == 0].index).sort_values(ascending=False)\nmissing_data = pd.DataFrame(train_na)\nmissing_data.head()","77962bee":"#MSSubClass needs to be str\ntrain['MSSubClass'] = train['MSSubClass'].apply(str)\n\n\n#Changing OverallCond into a categorical variable\ntrain['OverallCond'] = train['OverallCond'].astype(str)\n\n\n#Year and month sold are transformed into categorical features.\ntrain['YrSold'] = train['YrSold'].astype(str)\ntrain['MoSold'] = train['MoSold'].astype(str)","727425dd":"#label encoding for all of the categorical varibles that are stored as object - also added in the remaining \"object\" type features.\n\n\ncols = ('PoolQC', 'MiscFeature', 'Alley', 'Fence', 'FireplaceQu', 'BsmtQual', 'BsmtCond', 'GarageQual', 'GarageCond', \n        'ExterQual', 'ExterCond','HeatingQC', 'KitchenQual', 'BsmtFinType1', \n        'BsmtFinType2', 'Functional', 'BsmtExposure', 'GarageFinish', 'LandSlope',\n        'LotShape', 'PavedDrive', 'Street', 'CentralAir', 'MSSubClass', 'OverallCond', \n        'YrSold', 'MoSold', 'MSZoning','LandContour', 'LotConfig', 'Neighborhood', 'Condition1', \n        'Condition2',  'BldgType', 'HouseStyle', 'RoofStyle', 'RoofMatl', 'Exterior1st', 'Exterior2nd', \n        'MasVnrType', 'Foundation', 'Heating', 'Electrical', 'GarageType', 'SaleType', 'SaleCondition')\n\n\n# process columns, apply LabelEncoder to categorical features\nfor c in cols:\n    lbl = LabelEncoder() \n    lbl.fit(list(train[c].values)) \n    train[c] = lbl.transform(list(train[c].values))\n\n","fb1c26e2":"#Check if there are any \"object\" types left (RandomForest doesnt like Object type.)\ntrain.info()","7a9ecc0c":"# Adding total sqfootage feature \ntrain['TotalSF'] = train['TotalBsmtSF'] + train['1stFlrSF'] + train['2ndFlrSF']","20385ed6":"train.head()","80effeff":"# Split Data set into X and Y - X is the features, Y is the varible we want to predict.\nX = train\nX = train.drop(['SalePrice'], axis=1) #remove when using test data\ny = train['SalePrice'] #remove when using test data\n\n","c25a64ba":"X.shape\n","e1d8690e":"# Define the model. Set random_state to 1\nrf_model = RandomForestRegressor(random_state=1)\nrf_model.fit(X, y)\n","685caeb5":"#Predict using X as our parameters\nrf_test_predictions = rf_model.predict(X)","484bd482":"print(rf_test_predictions)\n","d9d09cae":"#Add the targets and predictiions back into the data set also use expm1 to change them back to their original numbers\n\n#Create a column named Targets containing the original SalesPrice feature \nX['Targets'] = y #remove when using test data\n\n#Create a column named Predictions containing the predicted values from the model\nX['Predictions'] = rf_test_predictions\n\n#Create a column to undo the log1p on the original target\nX['TargetsAct']= np.expm1(X['Targets']) #remove when using test data\n\n#Create a column to undo the log1p on the predictions\nX['SalePrice'] = np.expm1(X['Predictions'])\n","00e93abf":"#Graph Targets vs Prediction to see correllation\nsns.scatterplot(x=X['TargetsAct'], y=X['SalePrice'])\nplt.xlabel('Target')\nplt.ylabel('Prediction')\nplt.show()","dea95a03":"from sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import mean_squared_log_error\nfrom math import sqrt\n\n\nrf_val_sq_error = sqrt(mean_squared_error(X['SalePrice'], X['TargetsAct']))\nprint(rf_val_sq_error)\n\nrf_val_sq_error2 = sqrt(mean_squared_error(X['Targets'], X['Predictions']))\nprint(rf_val_sq_error2)\n\n\n\n","2fa5bcb3":"#for submission of test data set\n#submission = X[['Id', 'SalePrice']]\n#submission.to_csv('submission.csv', index=False)\n\n\n","0e89faa4":"The purpose of this notebook is to expand on the basic training provided by Kaggle and add some more in depth data analyis and preparation activities.   I took some insight from a number of other Kernels.  The main two are listed here.\n\nCredits: \n\n[Comprehensive Data Exploration with Python ](\/https:\/\/www.kaggle.com\/pmarcelino\/comprehensive-data-exploration-with-python) - By Pedro Marcelino\n\n[Stacked Regressions](https:\/\/www.kaggle.com\/serigne\/stacked-regressions-top-4-on-leaderboard) - By Serigne","79a0bafc":"Are there any additional features that we can create from our current dataset that we believe could be useful in identifying the value of the house?  These will generally always be a numeric.","7d9e2012":"## Distribution \/ Skewedness of Values","d0906975":"Judging from the amount of missing data, its reasonable to remove PoolQC, MiscFeature, Alley, Fence and FireplaceQu.  Essentially I made the decision that these are not important because they are not things we consider when buying a house.  Ideally we would do more analysis on these features, but in the interest of keeping this simple I wont bother.  Lets just drop them altoghter. \n\nNote:  Model is actually more accurate with these in.  Will dig deeper and update further, for now the columns are included in the model.\n\n","b394f4c0":"Are there any linear relationships to 'SalePrice' that we feel we need to dig into further?   Looks like we have linear relationships between SalesPrice and GrLivArea, and TotBsmtSF.   Let create a scattergraph we can use to zoom in on these and pick put the outliers.","8db96a05":"## Train the Model (Train Data Only)","ba28bbf5":"## Predict Using Trained Model","dd9ecfa1":"## Submitting to Kaggle","24d41e5d":"The ID column is useless for analysis, first we save the ID column from the data set - then we drop it so we are left with just the data we want to analyze.","983d993c":"Now we have a trained model, we need to use it to create some predictions on our training (or test) data.  We simply create a variable which references the model we trained and pass in X, which is our list of features.","895b2e64":"## Split into X (Features) and Y (Target)","1ad10984":"As per Competition Rules, we validate the data using log mean squared error.  Which is the sqrt of mean_squared_error.","3c6defbc":"## Dealing with Missing Data","f9aa0f56":"# Machine Learning - Random Forest Regression for House Prices","579a94df":"Once we have made the changes to our dataset, we run a check to see if there are any nulls left ","dc96157d":"There are different methods we will use here to replace nulls with something dependent upon the type of feature we are dealing with.  We use the lines of code below to replace the nulls with either: \n1.  a string stating the word \"None\" - if the data descritpion defines this.\n2.  the median value of the feature (if its a numberic variable)\n3.  The modal class of the feature (if it is a categorical feature)\n4.  A zero - if the data description defines this.\n","60bd1ea3":"The distribution is left Skewed.  We can run Log1p to sort out the distribution of the data.   Log1p bascially applies Log(1+x) to the target column.","86f3df27":"Now we should check that our list of predictions make sense, remember they wont look like house prices because we applied log1p to the values, we can undo this afterwards. \n","d2c5ce24":"Now we run train.head() to check that our data is encoded. i.e. check that there are no text values in there, and everything is represented by a number.","730c489b":"Now we have a nice bell-shaped distribution of values for our data, let look for our other ","4e75507a":"You can see from the second plot that the outliers are now removed.   Lets move forwards and take a look at the distribution of the SalesPrice values.","857441c7":"Next we check the data description to see if we need to update the datatypes on any of our features.\nIf a numeric variable is actually a category, we need to convert this to a string, so the RandomForest will treat is as a category and not a numeric variable.   A good example of this is years,  we dont want 2019 to be treated as a greater value than 2001, we want the algorithm to understand that the years are a category, not a number.","68b876cf":"One of the most useful ways in which we can visualize the correlation between the different numeric features of our dataset is by producing a correlation matrix, then overlaying it with a heatmap.  Generally lighter colours will signify a high correlation.   ","7a356bed":"Notice when we plot GrLivArea against Saleprice there are a couple of particularly significant outliers on the bottom right of the diagram.  Lets run some code to remove these outliers so they dont reduce the accuracy of our model.","8acd3b40":"## Understanding the dataset - Initial Data Analysis","ac56a6e2":"## Feature Engineering","f288cb03":"## Scoring the Results","03da8236":"## Correlation of Numerical Features","b61a39b8":"This last box will save the columns required to submit to Kaggle and output a document named \"submission.csv\" to the root of your filesystem.","af8f46e3":"## Outliers","d5b78d7c":"We also should check if there are any \"object\" type categorical features left in our dataset.  Most ML algorithms need (or prefer) to accept encoded information.  Encoded inforomation is essentially changing values into numbers.  I.e. \"Street\" may contain values labelled \"King Street\" or \"West 25th Street\", an encoder will assign a number to the value and populate it throughout the dataset.  \n\nThe main two types of encoding you will come across will be Label and OneHot Encoders.  Both have separate use cases. [This link ](https:\/\/medium.com\/@contactsunny\/label-encoder-vs-one-hot-encoder-in-machine-learning-3fc273365621) is useful if you want to learn more about encoding. \n\n","d4bfd77c":"We are mostly interested in the target variable 'SalePrice'.  Judging from the heatmap, there is a strong correlation between SalePrice and two other numeric variables.  These are: GrLivArea and OverallCond. \n\nScatterPlot the different 'highly correlated' variables against eachother to investigate the linear relationship and identify any outliers. (Be patient, this may take some time to visualize. ","fdf7dddf":"Now we have a clean, encoded dataset that is ready to be used to train a model.  We need to split down our dataset into:\n\nX  - This contains all of the features \n\ny  - This is the variable that we will use to train the model","4bfebdc7":"First lets take a look at the percentage of nulls per column.   We sort this descending because we are only bothered about features with a high number of nulls","fc9d163f":"First we need to pick a model, for this is have used a RandomForest from SciKit.  Once we have selected the model we must fit the previously created X and y variables to it.   This is just for training data, you will not re-run this when it comes to submitting your test data. ","483afb2c":"Add the targets and predictions back into the data set also use expm1 to change them back to their original numbers"}}