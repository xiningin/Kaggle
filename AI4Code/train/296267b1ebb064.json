{"cell_type":{"d2ad98d2":"code","490f1376":"code","5e178d5d":"code","69133e1d":"code","4771b8e0":"code","ca0a6cf9":"code","448667cc":"code","66ff6d19":"code","8f723afa":"code","ffc2ce45":"code","ee2f6f4b":"code","ad57ade6":"code","25955160":"code","2c9c37db":"code","4a6e8180":"code","20136b30":"code","e943c155":"code","63790b72":"code","4d67fa70":"code","28030323":"code","62a97203":"code","0e4f41cf":"code","a366e7b8":"code","5fab7997":"code","aaca3e56":"code","748ed241":"code","21015b37":"code","34f1fdca":"code","8c905f79":"code","61086858":"code","00b2c211":"code","36ea5f2d":"code","31bfd765":"markdown","63f4a5b8":"markdown","1eabe98c":"markdown","006b2a3b":"markdown","b7048a44":"markdown","f524a2a6":"markdown","a518741a":"markdown","645e8a6e":"markdown","1719734f":"markdown"},"source":{"d2ad98d2":"# params\nNR_EPOCHS = 30\nMODEL_ARCH = 'MOBILE'\nBATCH_SIZE = 128\nDENSE_SIZE = 64\nIMG_X = 96\nIMG_Y = 96","490f1376":"%matplotlib inline\nimport os\nimport numpy as np\nimport pandas as pd\nfrom glob import glob\nimport matplotlib.pyplot as plt\nfrom pydicom import read_file as read_dicom\nimport SimpleITK as sitk\nbase_dir = os.path.join('..', 'input', 'qureai-headct')\nreads_dir = os.path.join('..', 'input', 'headctreads')","5e178d5d":"all_dicom_paths = glob(os.path.join(base_dir, '*', '*', '*', '*', '*'))\nprint(len(all_dicom_paths), 'dicom files')\ndicom_df = pd.DataFrame(dict(path = all_dicom_paths))\ndicom_df['SliceNumber'] = dicom_df['path'].map(lambda x: int(os.path.splitext(x.split('\/')[-1])[0][2:]))\ndicom_df['SeriesName'] = dicom_df['path'].map(lambda x: x.split('\/')[-2])\ndicom_df['StudyID'] = dicom_df['path'].map(lambda x: x.split('\/')[-3])\ndicom_df['PatientID'] = dicom_df['path'].map(lambda x: x.split('\/')[-4].split(' ')[0])\ndicom_df['PatSeries'] = dicom_df.apply(lambda x: '{PatientID}-{SeriesName}'.format(**x), 1)\ndicom_df.sample(3)","69133e1d":"small_scans = dicom_df.groupby('PatSeries').count().reset_index().query('SliceNumber<240')\ndicom_df = dicom_df[dicom_df['PatSeries'].isin(small_scans['PatSeries'])]\nprint('Removed big scans', dicom_df.shape[0], 'remaining images')","4771b8e0":"dicom_df.describe(include = 'all')","ca0a6cf9":"read_overview_df = pd.read_csv(os.path.join(reads_dir, 'reads.csv'))\nread_overview_df['PatientID'] = read_overview_df['name'].map(lambda x: x.replace('-', '')) \nread_overview_df.sample(2).T","448667cc":"from collections import OrderedDict\nnew_reads = []\nfor _, c_row in read_overview_df.iterrows():\n    base_dict = OrderedDict(PatientID = c_row['PatientID'], Category = c_row['Category'])\n    for reader in ['R1', 'R2', 'R3']:\n        c_dict = base_dict.copy()\n        c_dict['Reader'] = reader\n        for k,v in c_row.items():\n            if (reader+':') in k:\n                c_dict[k.split(':')[-1]] = v\n        new_reads += [c_dict]\nnew_reads_df = pd.DataFrame(new_reads)\nnew_reads_df.to_csv('formatted_reads.csv')\nnew_reads_df.sample(5)","66ff6d19":"avg_reads_df = new_reads_df.groupby(['PatientID', 'Category']).agg('mean').reset_index()\nread_dicom_df = pd.merge(avg_reads_df, dicom_df, on = 'PatientID')\nread_dicom_df['Bleed'] = read_dicom_df.apply(lambda x: np.clip(x['BleedLocation-Left']+x['BleedLocation-Right']+x['ChronicBleed'], 0, 1), 1)\nprint(read_dicom_df.shape[0], 'total weakly-labeled slices')\nread_dicom_df.sample(3)","8f723afa":"fig, m_axs = plt.subplots(3, 3, figsize = (20, 20))\nfor c_ax, (_, c_row) in zip(m_axs.flatten(), read_dicom_df.sample(9).iterrows()):\n    try:\n        c_img = sitk.ReadImage(c_row['path'])\n        c_slice = sitk.GetArrayFromImage(c_img)[0]\n        c_ax.imshow(c_slice, cmap = 'bone')\n        c_ax.set_title('Bleed: {Bleed:2.2f}, Fracture: {Fracture:2.2f}\\n{SeriesName}'.format(**c_row))\n    except Exception as e:\n        c_ax.set_title('{}'.format(str(e)[:40]))\n        print(e)\n    #c_ax.axis('off')","ffc2ce45":"from sklearn.model_selection import train_test_split\nvalid_df = read_dicom_df[['PatientID', 'Bleed']].drop_duplicates()\nprint('Patients', valid_df.shape[0])\ntrain_ids, test_ids = train_test_split(valid_df[['PatientID']], \n                                       test_size = 0.25, \n                                       stratify = valid_df['Bleed'].map(lambda x: x>0))\n\ntrain_unbalanced_df = read_dicom_df[read_dicom_df['PatientID'].isin(train_ids['PatientID'])]\ntest_df = read_dicom_df[read_dicom_df['PatientID'].isin(test_ids['PatientID'])]\nprint(train_unbalanced_df.shape[0], 'training images', test_df.shape[0], 'testing images')\ntrain_unbalanced_df['Bleed'].hist(figsize = (10, 5))","ee2f6f4b":"train_df = train_unbalanced_df.groupby(['Bleed', 'SeriesName']).apply(lambda x: x.sample(200, replace = True)\n                                                      ).reset_index(drop = True)\nprint('New Data Size:', train_df.shape[0], 'Old Size:', train_unbalanced_df.shape[0])\ntrain_df['Bleed'].hist(figsize = (20, 5))","ad57ade6":"from keras.preprocessing.image import ImageDataGenerator\nIMG_SIZE = (IMG_X, IMG_Y) # many of the ojbects are small so 512x512 lets us see them\nimg_gen_args = dict(samplewise_center=False, \n                              samplewise_std_normalization=False, \n                              horizontal_flip = True, \n                              vertical_flip = False, \n                              height_shift_range = 0.05, \n                              width_shift_range = 0.02, \n                              rotation_range = 3, \n                              shear_range = 0.01,\n                              fill_mode = 'nearest',\n                              zoom_range = 0.05)\nimg_gen = ImageDataGenerator(**img_gen_args)","25955160":"def flow_from_dataframe(img_data_gen, in_df, path_col, y_col, seed = None, **dflow_args):\n    base_dir = os.path.dirname(in_df[path_col].values[0])\n    print('## Ignore next message from keras, values are replaced anyways: seed: {}'.format(seed))\n    df_gen = img_data_gen.flow_from_directory(base_dir, \n                                     class_mode = 'sparse',\n                                              seed = seed,\n                                    **dflow_args)\n    df_gen.filenames = in_df[path_col].values\n    df_gen.classes = np.stack(in_df[y_col].values,0)\n    df_gen.samples = in_df.shape[0]\n    df_gen.n = in_df.shape[0]\n    df_gen._set_index_array()\n    df_gen.directory = '' # since we have the full path\n    print('Reinserting dataframe: {} images'.format(in_df.shape[0]))\n    return df_gen","2c9c37db":"import keras.preprocessing.image as KPImage\nfrom PIL import Image\ndef apply_window(data, center, width):\n    low = center - width\/2.\n    high = center + width\/2\n    data = np.clip(data, low, high)\n    data += -1 * low\n    data \/= width\n    return data\ndef read_dicom_image(in_path):\n    c_img = sitk.ReadImage(in_path)\n    c_slice = sitk.GetArrayFromImage(c_img)[0]\n    return c_slice\n    \nclass medical_pil():\n    @staticmethod\n    def open(in_path):\n        if '.dcm' in in_path:\n            # we only want to keep the positive labels not the background\n            c_slice = read_dicom_image(in_path)\n            wind_slice = apply_window(c_slice, 40, 80)\n            int_slice =  (255*wind_slice).clip(0, 255).astype(np.uint8) # 8bit images are more friendly\n            return Image.fromarray(int_slice)\n        else:\n            return Image.open(in_path)\n    fromarray = Image.fromarray\nKPImage.pil_image = medical_pil","4a6e8180":"batch_size = BATCH_SIZE\ntrain_gen = lambda: flow_from_dataframe(img_gen, train_df, \n                             path_col = 'path',\n                            y_col = 'Bleed', \n                            target_size = IMG_SIZE,\n                             color_mode = 'grayscale',\n                            batch_size = batch_size)\ntest_gen = lambda: flow_from_dataframe(img_gen, test_df, \n                             path_col = 'path',\n                            y_col = 'Bleed', \n                            target_size = IMG_SIZE,\n                             color_mode = 'grayscale',\n                            batch_size = batch_size)","20136b30":"t_x, t_y = next(train_gen())\nprint(t_x.shape, '->', t_y.shape)\nfig, m_axs = plt.subplots(2, 4, figsize = (16, 8))\nfor (c_x, c_y, c_ax) in zip(t_x, t_y, m_axs.flatten()):\n    c_ax.imshow(c_x[:,:,0], cmap = 'bone')\n    c_ax.set_title('Bleed: {:2.2f}'.format(c_y))\n    c_ax.axis('off')","e943c155":"if MODEL_ARCH=='NAS':\n    from keras.applications.nasnet import NASNetMobile as BaseModel\nelif MODEL_ARCH=='MOBILE':\n    from keras.applications.mobilenet import MobileNet as BaseModel\nelse:\n    raise ValueError('Model {} not supported'.format(MODEL_ARCH))\nfrom keras.models import Sequential\nfrom keras.layers import BatchNormalization, Dense, Dropout, GlobalAveragePooling2D\nct_model = Sequential()\nct_model.add(BatchNormalization(input_shape = t_x.shape[1:]))\nct_model.add(BaseModel(input_shape = t_x.shape[1:], include_top = False, weights = None))\nct_model.add(GlobalAveragePooling2D())\nct_model.add(Dropout(0.5))\nct_model.add(Dense(DENSE_SIZE))\nct_model.add(Dropout(0.25))\nct_model.add(Dense(1, activation = 'sigmoid'))\n\nct_model.compile(optimizer = 'adam', loss = 'binary_crossentropy',\n                           metrics = ['mae', 'binary_accuracy'])\nct_model.summary()","63790b72":"from keras.callbacks import ModelCheckpoint, LearningRateScheduler, EarlyStopping, ReduceLROnPlateau\nweight_path=\"{}_weights.best.hdf5\".format('cthead')\n\ncheckpoint = ModelCheckpoint(weight_path, monitor='val_loss', verbose=1, \n                             save_best_only=True, mode='min', save_weights_only = True)\n\nreduceLROnPlat = ReduceLROnPlateau(monitor='val_loss', factor=0.8, patience=3, verbose=1, mode='auto', epsilon=0.0001, cooldown=5, min_lr=0.0001)\nearly = EarlyStopping(monitor=\"val_loss\", \n                      mode=\"min\", \n                      patience=6) # probably needs to be more patient, but kaggle time is limited\ncallbacks_list = [checkpoint, early, reduceLROnPlat]","4d67fa70":"ct_model.fit_generator(train_gen(), \n                       steps_per_epoch = 8000\/\/BATCH_SIZE,\n                        validation_data = test_gen(), \n                       validation_steps = 4000\/\/BATCH_SIZE,\n                              epochs = NR_EPOCHS, \n                              callbacks = callbacks_list,\n                             workers = 4,\n                             use_multiprocessing=False, \n                             max_queue_size = 10\n                            )","28030323":"ct_model.load_weights(weight_path)\nct_model.save('full_bleed_model.h5')","62a97203":"%%time\nout_vals = ct_model.evaluate_generator(test_gen(), steps = 4000\/\/BATCH_SIZE, workers=4)\nprint('Mean Absolute Error: %2.1f%%\\nAccuracy %2.1f%%' % (out_vals[1]*100, out_vals[2]*100))","0e4f41cf":"eval_df = pd.DataFrame([dict(zip(ct_model.metrics_names, out_vals))])\neval_df.to_csv('test_score.csv', index = False)\neval_df","a366e7b8":"test_gen.batch_size = 128\nt_x, t_y = next(test_gen())\npred_y = ct_model.predict(t_x)\nprint(t_x.shape, '->', t_y.shape)\nfig, m_axs = plt.subplots(4, 4, figsize = (16, 16))\nfor (c_x, c_y, p_y, c_ax) in zip(t_x, t_y, pred_y, m_axs.flatten()):\n    c_ax.imshow(c_x[:,:,0], cmap = 'bone')\n    c_ax.set_title('Bleed: {:2.2f}%\\nPrediction: {:2.2f}%'.format(100*c_y, 100*p_y[0]))\n    c_ax.axis('off')","5fab7997":"import seaborn as sns\nfig,ax1 = plt.subplots(1,1)\nsns.swarmplot(x = (100*t_y).astype(int), y = pred_y[:,0], ax = ax1)\nax1.set_xlabel('Bleed')\nax1.set_ylabel('Prediction')","aaca3e56":"sns.lmplot(x = 'x', y = 'y', data = pd.DataFrame(dict(x = (100*t_y).astype(int), y = pred_y[:,0])))","748ed241":"bleed_patient_id = test_df.query('Bleed==1.0').query('SliceNumber>100 and SliceNumber<300').sample(1, random_state = 2018)[['PatientID', 'SeriesName']]\nscan_df = pd.merge(test_df,bleed_patient_id).sort_values('SliceNumber')\nprint('Slices', scan_df.shape[0])\nscan_df.head(5)","21015b37":"series_reader = sitk.ImageSeriesReader()\nscan_df['path'] = series_reader.GetGDCMSeriesFileNames(os.path.dirname(scan_df['path'].values[0]))","34f1fdca":"scan_gen = flow_from_dataframe(img_gen, scan_df, \n                             path_col = 'path',\n                            y_col = 'Bleed', \n                            target_size = IMG_SIZE,\n                             color_mode = 'grayscale',\n                            batch_size = scan_df.shape[0], \n                              shuffle = False)","8c905f79":"t_x, t_y = next(scan_gen)\npred_y = ct_model.predict(t_x, batch_size = batch_size)\nprint(t_x.shape, '->', t_y.shape)","61086858":"fig, m_axs = plt.subplots(8, 8, figsize = (16, 16))\nfor (c_x, c_y, p_y, c_ax) in zip(t_x, t_y, pred_y, m_axs.flatten()):\n    c_ax.imshow(c_x[:,:,0], cmap = 'bone')\n    c_ax.set_title('{:2.1f}%'.format(100*p_y[0]))\n    c_ax.axis('off')","00b2c211":"fig, ax1 = plt.subplots(1,1, figsize = (10, 10))\nax1.plot(scan_df['SliceNumber'], pred_y[:,0], 'r.-')\nax1.set_xlabel('Slice Number')\nax1.set_ylabel('Bleed Prediction')","36ea5f2d":"new_idx = np.argsort(-pred_y[:,0])\nfig, m_axs = plt.subplots(5, 5, figsize = (16, 16))\nfor (c_x, c_y, p_y, c_ax) in zip(t_x[new_idx], t_y[new_idx], pred_y[new_idx], m_axs.flatten()):\n    c_ax.imshow(c_x[:,:,0], cmap = 'bone')\n    c_ax.set_title('{:2.1f}%'.format(100*p_y[0]))\n    c_ax.axis('off')\nfig.savefig('suspicious_slices.png')","31bfd765":"# Using SimpleITK\nUsing SimpleITK instead of pydicom lets us load the images correctly now","63f4a5b8":"# Show the Most Suspicious Slices","1eabe98c":"# Regression Prediction\nIn a perfect world this would be a line, but as we see it is quite far from that","006b2a3b":"# Run a whole scan\nHere we take a random scan and run every slice","b7048a44":"# Overview\nIn this notebook we try and automatically detect bleeds in Head CT scans. We have readings from 3 independent physicians for the entire scan and we associate the readings with each slice","f524a2a6":"# Classify series name from image\nWe can make a simple model here to identify which series type an image came from","a518741a":"# Replace PIL with SimpleITK\nSince we want to open images that are DICOMs we use SimpleITK to open them","645e8a6e":"# Read Physician Reads\nHere we load the physician reads and preprocess them so we can associate them with each scan. We average them here to make it easier.","1719734f":"#### fix slice order (names arent always right)"}}