{"cell_type":{"8cb06c28":"code","ddfddd48":"code","ff5f122c":"code","e8b34601":"code","d298cea3":"code","e06a41e1":"code","545e6832":"code","b0b7c5b3":"code","35fb96d5":"code","120f31e6":"code","8d1c257b":"code","0ae32fbb":"code","67f77747":"code","74765a19":"code","2d704dbe":"code","1b7ec9b7":"code","bd5a4970":"code","c0d5efec":"code","597c9e7e":"code","9e95bfec":"code","1ead3999":"code","96e9f5bf":"code","5d83a198":"code","ce6e88cf":"code","10fd6065":"code","c0dc0c39":"code","17c5fc4b":"code","0a2a777c":"code","37fbd95c":"code","17794edd":"code","904caa96":"code","c82596cf":"code","9cc1a311":"code","2a8f3f0d":"code","38598809":"code","391e6de8":"code","fa21e657":"code","f74392ca":"code","771427ce":"code","872dd005":"code","fa779f70":"code","97fd8e9a":"code","090ab09d":"code","a035af4b":"code","330d22d8":"code","8ce00aa5":"code","fd3f28b9":"code","5062c77e":"code","5e62ae13":"code","ab191552":"code","6471d50e":"code","a7699d92":"code","8babb253":"code","a81904a8":"code","7c35b00a":"code","91517918":"code","a85b1f6e":"code","1495fa0a":"code","7282c4f6":"code","fcb8a0f4":"code","f9ce1d2c":"code","27fd96a8":"code","c73d128a":"code","88265dd7":"code","d496c174":"code","267898c6":"code","1684922e":"code","ea1e06cc":"code","f218de46":"code","7a7b2754":"code","38b41ca9":"code","0ac615bb":"code","6b255ced":"code","3ef4e0d0":"code","b64f435f":"code","71976c97":"code","e636b820":"code","f0fa1dd8":"code","a86d855b":"code","bf5be07f":"code","7608332f":"code","2e20658a":"code","2b8d8ddd":"code","2db5e1bd":"code","85a5d087":"code","41e920b1":"code","883bd701":"code","830d37aa":"code","68e373bd":"code","4f47a6ab":"code","9a1bf632":"code","b47738a9":"code","47aae720":"code","ab44ee67":"code","e05dfbde":"code","927513df":"code","a986e82c":"code","3ab0e772":"code","d82843c4":"code","8b558ec1":"code","1c74e364":"code","de5d721c":"code","4db5b4ad":"code","4ebd131b":"code","05703d00":"code","99593315":"code","8b73bffe":"code","3629fc9e":"code","5a06e32c":"code","d3f0a167":"code","ddda7ed4":"code","98fccad7":"code","302a1910":"code","d036c053":"code","b7b86ae4":"code","2fd6c564":"code","8e800dc6":"code","060f7bce":"code","590f9784":"code","0bbfd386":"code","153607fc":"code","e9464b78":"code","b3ea5607":"code","b6f48fba":"code","2e61304c":"code","50009562":"code","46b55add":"code","c3638211":"code","ab8a5cc5":"code","d428a194":"code","f00f9962":"code","75f00575":"code","b79e091a":"code","cff5b3f0":"code","afad7305":"code","de54b85e":"code","232337bc":"code","0c82ad66":"markdown","2c65dabd":"markdown","b05adfa7":"markdown","324d4e6f":"markdown","42fda0be":"markdown","7a58bde5":"markdown","81039118":"markdown","42a5e3f5":"markdown","d0b2abe0":"markdown","2fa13f31":"markdown","53a0ea8e":"markdown","a377fea0":"markdown","3fc5022f":"markdown","f3b9dd44":"markdown","f0a922df":"markdown","c2ff1d59":"markdown","803aedec":"markdown","bea83c1a":"markdown","6d31a074":"markdown","607f7e55":"markdown","21b4c3cd":"markdown","27e2cf3e":"markdown","02d40402":"markdown","3fb53932":"markdown","559926d8":"markdown","510900fe":"markdown","d8964798":"markdown","3f8787db":"markdown","b96661ea":"markdown","582f44f9":"markdown","a44ef053":"markdown","3c441192":"markdown","484f4f05":"markdown","f8306eb8":"markdown","a5ea8e05":"markdown","de37ae21":"markdown"},"source":{"8cb06c28":"# Suppressing Warnings\nimport warnings\nwarnings.filterwarnings('ignore')","ddfddd48":"# Importing Pandas and NumPy\nimport pandas as pd\nimport numpy as np","ff5f122c":"# Importingdatasets\ntrain = pd.read_csv(\"..\/input\/train.csv\")\ntrain.head()","e8b34601":"# Importingdatasets\ntest = pd.read_csv(\"..\/input\/test.csv\")\ntest.head()","d298cea3":"test1 = test['PassengerId']\ntest1.head()","e06a41e1":"test1 = test1.to_frame(name=None)","545e6832":"test1 = test1.set_index('PassengerId')","b0b7c5b3":"train.columns","35fb96d5":"# Let's check the dimensions of the dataframe\ntrain.shape","120f31e6":"test.shape","8d1c257b":"# let's look at the statistical aspects of the dataframe\ntrain.describe()","0ae32fbb":"# Let's see the type of each column\ntrain.info()","67f77747":"# List of variables to map\n\nvarlist1 =  ['Sex']\n\n# Defining the map function\ndef binary_map(x):\n    return x.map({'male': 1, \"female\": 0})\n\n# Applying the function to the train list\ntrain[varlist1] = train[varlist1].apply(binary_map)","74765a19":"train.head()","2d704dbe":"# Creating a dummy variable for some of the categorical variables and dropping the first one.\ndummy1 = pd.get_dummies(train[['Embarked', 'Pclass']], drop_first=True)\n\n# Adding the results to the dataframe\ntrain = pd.concat([train, dummy1], axis=1)","1b7ec9b7":"train.head()","bd5a4970":"# We have created dummies for the below variables, so we can drop them\ntrain = train.drop(['Embarked', 'Pclass','Name', 'Ticket', 'Fare', 'Cabin'], 1)","c0d5efec":"train.info()","597c9e7e":"# Adding up the missing values (column-wise)\ntrain.isnull().sum()","9e95bfec":"# Checking the percentage of missing values\nround(100*(train.isnull().sum()\/len(train.index)), 2)","1ead3999":"train[\"Age\"] = train[\"Age\"].fillna(value=train[\"Age\"].mean()) #replace NaN by mean","96e9f5bf":"# Adding up the missing values (column-wise)\ntrain.isnull().sum()","5d83a198":"from sklearn.model_selection import train_test_split","ce6e88cf":"# Putting feature variable to X\nX = train.drop(['Survived','PassengerId'], axis=1)\n\nX.head()","10fd6065":"# Putting response variable to y\ny = train['Survived']\n\ny.head()","c0dc0c39":"# Splitting the data into train and test\nX_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.7, test_size=0.3, random_state=100)","17c5fc4b":"from sklearn.preprocessing import StandardScaler","0a2a777c":"scaler = StandardScaler()\n\nX_train[['Age']] = scaler.fit_transform(X_train[['Age']])\n\nX_train.head()","37fbd95c":"### Checking the survival Rate\nsurvived = (sum(train['Survived'])\/len(train['Survived'].index))*100\nsurvived","17794edd":"# Importing matplotlib and seaborn\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline","904caa96":"# Let's see the correlation matrix \nplt.figure(figsize = (20,10))        # Size of the figure\nsns.heatmap(train.corr(),annot = True)\nplt.show()","c82596cf":"plt.figure(figsize = (20,10))\nsns.heatmap(X_train.corr(),annot = True)\nplt.show()","9cc1a311":"import statsmodels.api as sm","2a8f3f0d":"# Logistic regression model\nlogm1 = sm.GLM(y_train,(sm.add_constant(X_train)), family = sm.families.Binomial())\nlogm1.fit().summary()","38598809":"from sklearn.linear_model import LogisticRegression\nlogreg = LogisticRegression()","391e6de8":"from sklearn.feature_selection import RFE\nrfe = RFE(logreg, 5)             # running RFE with 13 variables as output\nrfe = rfe.fit(X_train, y_train)","fa21e657":"rfe.support_","f74392ca":"list(zip(X_train.columns, rfe.support_, rfe.ranking_))","771427ce":"col = X_train.columns[rfe.support_]","872dd005":"X_train.columns[~rfe.support_]","fa779f70":"X_train_sm = sm.add_constant(X_train[col])\nlogm2 = sm.GLM(y_train,X_train_sm, family = sm.families.Binomial())\nres = logm2.fit()\nres.summary()","97fd8e9a":"# Getting the predicted values on the train set\ny_train_pred = res.predict(X_train_sm)\ny_train_pred[:10]","090ab09d":"y_train_pred = y_train_pred.values.reshape(-1)\ny_train_pred[:10]","a035af4b":"y_train_pred_final = pd.DataFrame({'Survived':y_train.values, 'survival_prob':y_train_pred})\ny_train_pred_final['PassengerId'] = y_train.index\ny_train_pred_final.head()","330d22d8":"y_train_pred_final['predicted'] = y_train_pred_final.survival_prob.map(lambda x: 1 if x > 0.5 else 0)\n\n# Let's see the head\ny_train_pred_final.head()","8ce00aa5":"from sklearn import metrics","fd3f28b9":"# Confusion matrix \nconfusion = metrics.confusion_matrix(y_train_pred_final.Survived, y_train_pred_final.predicted )\nprint(confusion)","5062c77e":"# Predicted     not_churn    churn\n# Actual\n# not_churn        3270      365\n# churn            579       708  ","5e62ae13":"# Let's check the overall accuracy.\nprint(metrics.accuracy_score(y_train_pred_final.Survived, y_train_pred_final.predicted))","ab191552":"# Check for the VIF values of the feature variables. \nfrom statsmodels.stats.outliers_influence import variance_inflation_factor","6471d50e":"# Create a dataframe that will contain the names of all the feature variables and their respective VIFs\nvif = pd.DataFrame()\nvif['Features'] = X_train[col].columns\nvif['VIF'] = [variance_inflation_factor(X_train[col].values, i) for i in range(X_train[col].shape[1])]\nvif['VIF'] = round(vif['VIF'], 2)\nvif = vif.sort_values(by = \"VIF\", ascending = False)\nvif","a7699d92":"# Let's re-run the model using the selected variables\nX_train_sm = sm.add_constant(X_train[col])\nlogm3 = sm.GLM(y_train,X_train_sm, family = sm.families.Binomial())\nres = logm3.fit()\nres.summary()","8babb253":"y_train_pred = res.predict(X_train_sm).values.reshape(-1)","a81904a8":"y_train_pred[:10]","7c35b00a":"# Let's drop TotalCharges since it has a high VIF\ncol = col.drop('Parch')\ncol","91517918":"# Let's re-run the model using the selected variables\nX_train_sm = sm.add_constant(X_train[col])\nlogm4 = sm.GLM(y_train,X_train_sm, family = sm.families.Binomial())\nres = logm4.fit()\nres.summary()","a85b1f6e":"y_train_pred = res.predict(X_train_sm).values.reshape(-1)","1495fa0a":"y_train_pred[:10]","7282c4f6":"# Let's take a look at the confusion matrix again \nconfusion = metrics.confusion_matrix(y_train_pred_final.Survived, y_train_pred_final.predicted )\nconfusion","fcb8a0f4":"# Actual\/Predicted     not_survived    survived\n        # not_churn        3269      366\n        # churn            595       692  ","f9ce1d2c":"# Let's check the overall accuracy.\nmetrics.accuracy_score(y_train_pred_final.Survived, y_train_pred_final.predicted)","27fd96a8":"TP = confusion[1,1] # true positive \nTN = confusion[0,0] # true negatives\nFP = confusion[0,1] # false positives\nFN = confusion[1,0] # false negatives","c73d128a":"# Let's see the sensitivity of our logistic regression model\nTP \/ float(TP+FN)","88265dd7":"# Let us calculate specificity\nTN \/ float(TN+FP)","d496c174":"# Calculate false postive rate\nprint(FP\/ float(TN+FP))","267898c6":"# positive predictive value \nprint (TP \/ float(TP+FP))","1684922e":"# Negative predictive value\nprint (TN \/ float(TN+ FN))","ea1e06cc":"def draw_roc( actual, probs ):\n    fpr, tpr, thresholds = metrics.roc_curve( actual, probs,\n                                              drop_intermediate = False )\n    auc_score = metrics.roc_auc_score( actual, probs )\n    plt.figure(figsize=(5, 5))\n    plt.plot( fpr, tpr, label='ROC curve (area = %0.2f)' % auc_score )\n    plt.plot([0, 1], [0, 1], 'k--')\n    plt.xlim([0.0, 1.0])\n    plt.ylim([0.0, 1.05])\n    plt.xlabel('False Positive Rate or [1 - True Negative Rate]')\n    plt.ylabel('True Positive Rate')\n    plt.title('Receiver operating characteristic example')\n    plt.legend(loc=\"lower right\")\n    plt.show()\n\n    return None","f218de46":"fpr, tpr, thresholds = metrics.roc_curve( y_train_pred_final.Survived, y_train_pred_final.survival_prob, drop_intermediate = False )","7a7b2754":"draw_roc(y_train_pred_final.Survived, y_train_pred_final.survival_prob)","38b41ca9":"# Let's create columns with different probability cutoffs \nnumbers = [float(x)\/10 for x in range(10)]\nfor i in numbers:\n    y_train_pred_final[i]= y_train_pred_final.survival_prob.map(lambda x: 1 if x > i else 0)\ny_train_pred_final.head()","0ac615bb":"# Now let's calculate accuracy sensitivity and specificity for various probability cutoffs.\ncutoff_df = pd.DataFrame( columns = ['prob','accuracy','sensi','speci'])\nfrom sklearn.metrics import confusion_matrix\n\n# TP = confusion[1,1] # true positive \n# TN = confusion[0,0] # true negatives\n# FP = confusion[0,1] # false positives\n# FN = confusion[1,0] # false negatives\n\nnum = [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9]\nfor i in num:\n    cm1 = metrics.confusion_matrix(y_train_pred_final.Survived, y_train_pred_final[i] )\n    total1=sum(sum(cm1))\n    accuracy = (cm1[0,0]+cm1[1,1])\/total1\n    \n    speci = cm1[0,0]\/(cm1[0,0]+cm1[0,1])\n    sensi = cm1[1,1]\/(cm1[1,0]+cm1[1,1])\n    cutoff_df.loc[i] =[ i ,accuracy,sensi,speci]\nprint(cutoff_df)","6b255ced":"# Let's plot accuracy sensitivity and specificity for various probabilities.\ncutoff_df.plot.line(x='prob', y=['accuracy','sensi','speci'])\nplt.show()","3ef4e0d0":"y_train_pred_final['final_predicted'] = y_train_pred_final.survival_prob.map( lambda x: 1 if x > 0.25 else 0)\n\ny_train_pred_final.head()","b64f435f":"# Let's check the overall accuracy.\nmetrics.accuracy_score(y_train_pred_final.Survived, y_train_pred_final.final_predicted)","71976c97":"confusion2 = metrics.confusion_matrix(y_train_pred_final.Survived, y_train_pred_final.final_predicted )\nconfusion2","e636b820":"TP = confusion2[1,1] # true positive \nTN = confusion2[0,0] # true negatives\nFP = confusion2[0,1] # false positives\nFN = confusion2[1,0] # false negatives","f0fa1dd8":"# Let's see the sensitivity of our logistic regression model\nTP \/ float(TP+FN)","a86d855b":"# Let us calculate specificity\nTN \/ float(TN+FP)","bf5be07f":"# Calculate false postive rate\nprint(FP\/ float(TN+FP))","7608332f":"# Positive predictive value \nprint (TP \/ float(TP+FP))","2e20658a":"# Negative predictive value\nprint (TN \/ float(TN+ FN))","2b8d8ddd":"#Looking at the confusion matrix again","2db5e1bd":"confusion = metrics.confusion_matrix(y_train_pred_final.Survived, y_train_pred_final.predicted )\nconfusion","85a5d087":"confusion[1,1]\/(confusion[0,1]+confusion[1,1])","41e920b1":"confusion[1,1]\/(confusion[1,0]+confusion[1,1])","883bd701":"from sklearn.metrics import precision_score, recall_score","830d37aa":"precision_score","68e373bd":"precision_score(y_train_pred_final.Survived, y_train_pred_final.predicted)","4f47a6ab":"recall_score(y_train_pred_final.Survived, y_train_pred_final.predicted)","9a1bf632":"from sklearn.metrics import precision_recall_curve","b47738a9":"y_train_pred_final.Survived, y_train_pred_final.predicted","47aae720":"p, r, thresholds = precision_recall_curve(y_train_pred_final.Survived, y_train_pred_final.survival_prob)","ab44ee67":"plt.plot(thresholds, p[:-1], \"g-\")\nplt.plot(thresholds, r[:-1], \"r-\")\nplt.show()","e05dfbde":"X_test[['Age']] = scaler.transform(X_test[['Age']])","927513df":"X_test = X_test[col]\nX_test.head()","a986e82c":"X_test_sm = sm.add_constant(X_test)","3ab0e772":"y_test_pred = res.predict(X_test_sm)","d82843c4":"y_test_pred[:10]","8b558ec1":"# Converting y_pred to a dataframe which is an array\ny_pred_1 = pd.DataFrame(y_test_pred)","1c74e364":"# Let's see the head\ny_pred_1.head()","de5d721c":"# Converting y_test to dataframe\ny_test_df = pd.DataFrame(y_test)","4db5b4ad":"# Putting PassengerId to index\ny_test_df['PassengerId'] = y_test_df.index","4ebd131b":"# Removing index for both dataframes to append them side by side \ny_pred_1.reset_index(drop=True, inplace=True)\ny_test_df.reset_index(drop=True, inplace=True)","05703d00":"# Appending y_test_df and y_pred_1\ny_pred_final = pd.concat([y_test_df, y_pred_1],axis=1)","99593315":"y_pred_final.head()","8b73bffe":"# Renaming the column \ny_pred_final= y_pred_final.rename(columns={ 0 : 'survival_prob'})","3629fc9e":"# Rearranging the columns\ny_pred_final = y_pred_final.reindex_axis(['PassengerId','Survived','survival_prob'], axis=1)","5a06e32c":"# Let's see the head of y_pred_final\ny_pred_final.head()","d3f0a167":"y_pred_final['final_predicted'] = y_pred_final.survival_prob.map(lambda x: 1 if x > 0.4 else 0)","ddda7ed4":"y_pred_final.head()","98fccad7":"# Let's check the overall accuracy.\nmetrics.accuracy_score(y_pred_final.Survived, y_pred_final.final_predicted)","302a1910":"confusion2 = metrics.confusion_matrix(y_pred_final.Survived, y_pred_final.final_predicted )\nconfusion2","d036c053":"TP = confusion2[1,1] # true positive \nTN = confusion2[0,0] # true negatives\nFP = confusion2[0,1] # false positives\nFN = confusion2[1,0] # false negatives","b7b86ae4":"# Let's see the sensitivity of our logistic regression model\nTP \/ float(TP+FN)","2fd6c564":"# Let us calculate specificity\nTN \/ float(TN+FP)","8e800dc6":"test.isnull().sum()","060f7bce":"test[\"Age\"] = test[\"Age\"].fillna(value=test[\"Age\"].mean()) #replace NaN by mean","590f9784":"test.isnull().sum()","0bbfd386":"# List of variables to map\n\nvarlist =  ['Sex']\n\n# Defining the map function\ndef binary_map(x):\n    return x.map({'male': 1, \"female\": 0})\n\n# Applying the function to the train list\ntest[varlist] = test[varlist].apply(binary_map)","153607fc":"# Creating a dummy variable for some of the categorical variables and dropping the first one.\ndummy = pd.get_dummies(test[['Embarked', 'Pclass']], drop_first=True)\n\n# Adding the results to the dataframe\ntest = pd.concat([test, dummy], axis=1)","e9464b78":"# We have created dummies for the below variables, so we can drop them\ntest = test.drop(['Embarked', 'Pclass','Name', 'Ticket', 'Fare', 'Cabin'], 1)","b3ea5607":"test[['Age']] = scaler.transform(test[['Age']])","b6f48fba":"test = test[col]\ntest.head()","2e61304c":"test_sm = sm.add_constant(test)","50009562":"test_pred = res.predict(test_sm)","46b55add":"test_pred[:10]","c3638211":"# Converting y_pred to a dataframe which is an array\npred_1 = pd.DataFrame(test_pred)\n# Let's see the head\npred_1.head()","ab8a5cc5":"# Converting y_test to dataframe\ntest_df1 = pd.DataFrame(test)","d428a194":"# Putting PassengerId to index\ntest_df1['PassengerId'] = test1.index","f00f9962":"# Removing index for both dataframes to append them side by side \npred_1.reset_index(drop=True, inplace=True)\ntest_df1.reset_index(drop=True, inplace=True)","75f00575":"# Appending test_df and pred_1\npred_final1 = pd.concat([test_df1, pred_1],axis=1)\npred_final1.head()","b79e091a":"# Renaming the column \npred_final1= pred_final1.rename(columns={ 0 : 'survival_prob'})","cff5b3f0":"# Rearranging the columns\npred_final1 = pred_final1.reindex_axis(['PassengerId','survival_prob'], axis=1)\n# Let's see the head of pred_final1\npred_final1.head()","afad7305":"pred_final1['Survived'] = pred_final1.survival_prob.map(lambda x: 1 if x > 0.4 else 0)\npred_final1.head()","de54b85e":"gender_submission = pred_final1.drop('survival_prob', axis=1)\ngender_submission.head()","232337bc":"submission = pred_final1[['PassengerId','Survived']]\n\nsubmission.to_csv(\"submission.csv\", index=False)\n","0c82ad66":"##### Let's check the VIFs again","2c65dabd":"### Step 7: Model Building\nLet's start by splitting our data into a training set and a test set.","b05adfa7":"An ROC curve demonstrates several things:\n\n- It shows the tradeoff between sensitivity and specificity (any increase in sensitivity will be accompanied by a decrease in specificity).\n- The closer the curve follows the left-hand border and then the top border of the ROC space, the more accurate the test.\n- The closer the curve comes to the 45-degree diagonal of the ROC space, the less accurate the test.","324d4e6f":"Optimal cutoff probability is that prob where we get balanced sensitivity and specificity","42fda0be":"#### Checking the Correlation Matrix","7a58bde5":"### Step 4: Test-Train Split","81039118":"### Step 9: Plotting the ROC Curve","42a5e3f5":"## Titanic: Machine Learning from Disaster","d0b2abe0":"#### For categorical variables with multiple levels, create dummy features (one-hot encoded)","2fa13f31":"#### Checking VIFs","53a0ea8e":"#### Dropping the repeated variables","a377fea0":"##### Creating new column 'predicted' with 1 if survival_prob > 0.5 else 0","3fc5022f":"### Step 3: Data Preparation","f3b9dd44":"The accuracy is still practically the same.","f0a922df":"## Precision and Recall","c2ff1d59":"### Step 11: Making predictions on the splitted test set","803aedec":"##### Creating a dataframe with the actual survival flag and the predicted probabilities","bea83c1a":"### Step 5: Feature Scaling","6d31a074":"### Step 10: Finding Optimal Cutoff Point","607f7e55":"### Precision and recall tradeoff","21b4c3cd":"#### From the curve above, 0.3 is the optimum point to take it as a cutoff probability.","27e2cf3e":"##### Recall\nTP \/ TP + FN","02d40402":"Using sklearn utilities for the same","3fb53932":"Making predictions on the test set","559926d8":"##### Assessing the model with StatsModels","510900fe":"#### Checking for Missing Values and Inputing Them","d8964798":"#### Converting some binary variables to 1\/0","3f8787db":"## Metrics beyond simply accuracy","b96661ea":"#### Running Your First Training Model","582f44f9":"### Step 8: Feature Selection Using RFE","a44ef053":"There are a few variables with high VIF. It's best to drop these variables as they aren't helping much with prediction and unnecessarily making the model complex. The variable 'PhoneService' has the highest VIF. So let's start by dropping that.","3c441192":"##### Precision\nTP \/ TP + FP","484f4f05":"Now we don't have any missing values","f8306eb8":"### Step 1: Importing Data","a5ea8e05":"# checking on the given test set","de37ae21":"### Step 6: Looking at Correlations"}}