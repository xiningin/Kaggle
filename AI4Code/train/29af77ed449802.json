{"cell_type":{"90b6cfa3":"code","cbf2c441":"code","d4550e8a":"code","dec0ccd2":"code","4ab39d22":"code","bab47386":"code","f73450b0":"markdown"},"source":{"90b6cfa3":"# Imports\nimport pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport keras\nfrom keras import backend as K\nimport datetime as dt\nfrom IPython.display import display, HTML\nfrom sklearn.model_selection import train_test_split\nimport os\n\nRAND_SEED = 1\nnp.random.seed(RAND_SEED)","cbf2c441":"# Load SPY ETF data from Kaggle data set\ndef load_symbol_df(dir_path, file_name):\n    full_path = dir_path + file_name\n    if os.stat(full_path).st_size > 0: \n        df = pd.read_csv(full_path)\n        columns = list(df.columns.values)\n        symbol = file_name.split(\".\")[0]\n        df[\"Symbol\"] = \"sp500\"\n        columns.insert(0, \"Symbol\")\n        return df[columns]\n    \ndf = load_symbol_df(\"..\/input\/Data\/ETFs\/\", \"spy.us.txt\")\ndf = df.sort_values(by=\"Date\")\nprint(\"Dates: {}, from: {}, to: {}\".format(len(df), df[\"Date\"].min(), df[\"Date\"].max()))","d4550e8a":"# All functions\n\ndef prices_to_samples(prices, windowLength, predDaysForward):\n    X_data = []\n    Y_data = []\n    totalSamples = 0\n    endIdx = len(prices) - windowLength + 1 - predDaysForward    \n    for i in range(0, endIdx):\n        X, Y = to_XY(prices, i, windowLength, predDaysForward)\n        X_data.append(X)\n        Y_data.append(Y)\n        totalSamples += 1\n    return (np.array(X_data).reshape((totalSamples, windowLength)), np.array(Y_data).reshape((totalSamples, predDaysForward)))\n\ndef prices_to_percentage(prices, base_price):\n    base_price = max(base_price, 0.001)\n    return ((prices - base_price) \/ base_price).astype(\"float32\")\n\ndef percentage_to_prices(percentages, base_price):\n    base_price = max(base_price, 0.001)\n    return (base_price * (1.0 + percentages)).astype(\"float32\")\n\ndef to_X(prices, startIdx, windowLength):\n    winEndIdx = startIdx + windowLength\n    return prices_to_percentage(prices[startIdx:winEndIdx], prices[winEndIdx - 1])\n    #return prices[startIdx:winEndIdx].astype(\"float32\")\n\ndef to_Y(prices, startIdx, windowLength, predDaysForward):\n    predStartIdx = startIdx + windowLength\n    predEndIdx = predStartIdx + predDaysForward\n    return prices_to_percentage(prices[predStartIdx:predEndIdx], prices[predStartIdx - 1])\n    #return prices[predStartIdx:predEndIdx].astype(\"float32\")\n    \ndef to_XY(prices, startIdx, windowLength, predDaysForward):\n    return (to_X(prices, startIdx, windowLength), to_Y(prices, startIdx, windowLength, predDaysForward))\n\ndef prices_to_train_test_set(prices, trainSetProportion, windowLength, predDaysForward):\n    X, Y = prices_to_samples(prices, windowLength, predDaysForward)\n    return train_test_split(X, Y, test_size=1-trainSetProportion, random_state=RAND_SEED)\n\ndef plot_training_progress(history):\n    y_loss = np.array(history.history[\"loss\"]) * 100.0\n    y_val_loss = np.array(history.history[\"val_loss\"]) * 100.0\n    x = np.arange(len(y_loss))\n    fig, ax = plt.subplots(1,1, figsize=(20,8))\n    plt.scatter(x, y_loss, c=\"red\", label=\"Train loss\")\n    plt.plot(x, y_loss, color=\"red\")\n    plt.scatter(x, y_val_loss, c=\"blue\", label=\"Val loss\")\n    plt.plot(x, y_val_loss, color=\"blue\")\n    plt.title(\"Training progress\")\n    plt.xlabel('Epochs')\n    plt.ylabel('Loss')\n    plt.legend()\n    plt.show()\n\ndef test_model(prices, windowLength, predDaysForward, epochs):\n    print(\"Testing model with windowLength: {} and predDaysForward: {}\".format(windowLength, predDaysForward))\n    \n    # Create train\/test set\n    print(\"Creating samples...\")\n    X_train, X_test, Y_train, Y_test = prices_to_train_test_set(prices, 0.8, windowLength, predDaysForward)\n    print(\"Samples - Total: {}, Train:{}, Test: {}\".format(len(Y_train) + len(Y_test), len(Y_train), len(Y_test)))\n    \n    # Create Keras model\n    model = keras.models.Sequential([\n        keras.layers.Dense(32, input_shape=(windowLength,), activation='relu'),\n        keras.layers.Dense(32, activation='relu'),\n        keras.layers.Dense(predDaysForward)\n    ])\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.summary()\n    \n    # Callbacks\n    def print_progress(epoch, logs):\n        if epoch % 10 == 0:\n            loss = logs[\"loss\"]*100\n            val_loss = logs[\"val_loss\"]*100\n            print(\"\\tEpoch {}, Loss: {}%, Val Loss: {}%\".format(epoch, round(loss,6), round(val_loss,6)))\n        \n    model_base_path = \"models\/\"\n    if not os.path.exists(model_base_path):\n        os.makedirs(model_base_path)\n    model_path = model_base_path + \"sp500reg_history{}_forward{}\".format(windowLength, predDaysForward)\n    fit_callbacks = [\n        keras.callbacks.ModelCheckpoint(model_path, monitor=\"loss\", save_weights_only=True),\n        keras.callbacks.LambdaCallback(on_epoch_end = lambda epoch, logs: print_progress(epoch, logs))\n    ]\n    \n    # Train model\n    print(\"Training...\")\n    BATCH_SIZE = 128\n    history = model.fit(X_train, Y_train, batch_size=BATCH_SIZE, epochs=epochs, verbose=0, callbacks=fit_callbacks, validation_data=(X_test, Y_test))\n    print(\"Training done\")\n    \n    # Get predictions\n    print(\"Predicting...\")\n    score_train = model.evaluate(X_train, Y_train, verbose=0)\n    score_test = model.evaluate(X_test, Y_test, verbose=0)\n    print(\"Train loss: {}%, Test loss: {}%\".format(round(score_train*100, 6), round(score_test*100, 6)))\n    \n    # Save results\n    res = {\n        \"model\": model,\n        \"windowLength\": windowLength,\n        \"predDaysForward\": predDaysForward,\n        \"score_train\": score_train,\n        \"score_test\": score_test\n    }\n    \n    # Plot training\n    plot_training_progress(history)\n    \n    return res\n\ndef split_prices_by_date(df, date_threshold):\n    return (df[df[\"Date\"] < date_threshold][\"Close\"].values, df[df[\"Date\"] >= date_threshold][\"Close\"].values)\n\n# Function to show predicted return for specific symbol\/date\ndef predict_return_by_date(symbol, prices_df, date, windowLength, predDaysForward, model, show_history=1.0):\n    plot_num_hist_dates = int(windowLength * show_history)\n    \n    symbol_prices_df = prices_df[prices_df.Symbol == symbol][[\"Date\", \"Close\"]].sort_values(by=\"Date\")\n    all_dates = symbol_prices_df.Date.values\n    all_prices = symbol_prices_df.Close.values\n    \n    # Search current date\n    current_date_search = np.nonzero(all_dates == date)[0]\n    if len(current_date_search) == 0:\n        print(\"No data for date: {}. Next business day: {}\".format(date, next_business_day(date)))\n        return\n    current_date_idx = current_date_search[0]\n    \n    # Search first and prediction date\n    first_date_idx = current_date_idx - windowLength + 1\n    if first_date_idx < 0:\n        print(\"Not enough historical data for date: {}. Oldest date: {}. Next business day: {}\",format(date, all_dates[0], next_business_day(date)))\n        return\n    \n    # Check if we have historical data to validate prediction\n    last_pred_date_idx = current_date_idx + predDaysForward\n    has_pred_date = last_pred_date_idx < len(all_dates)\n    last_pred_date = all_dates[last_pred_date_idx] if has_pred_date else next_business_days(date, predDaysForward)[predDaysForward-1]\n    \n    # Predict future values\n    X = to_X(all_prices, first_date_idx, windowLength).reshape((1, windowLength))\n    Y_pred = model.predict(X)[0]\n    Y_pred_prices = percentage_to_prices(Y_pred, all_prices[current_date_idx])\n    Y_real_prices = all_prices[current_date_idx + 1 : last_pred_date_idx + 1] if has_pred_date else np.zeros(predDaysForward)\n    mse = np.power(Y_real_prices - Y_pred_prices, 2).sum() \/ len(Y_real_prices)\n\n    # Print summary\n    print(\"{} - Current date: {}, Historical data since: {} ({} days), Price: ${}\".format(symbol, date, all_dates[first_date_idx], windowLength, round(all_prices[current_date_idx],2)))\n    print(\"Prediction for +{} days - {}: ${}\".format(predDaysForward, last_pred_date, round(Y_pred_prices[-1],2)))\n    print(\"Error: ${}\".format(np.round(mse,4)))\n    \n    \n    # Gather results\n    report_data = []\n    report_data.append([date, round(all_prices[current_date_idx],2), \"0\", 0])\n    for i in range(0, predDaysForward):\n        date_idx = current_date_idx + 1 + i\n        next_date = all_dates[date_idx] if has_pred_date else next_business_days(date, i + 1)[i - 1]\n        report_data.append([next_date, \n                            round(Y_real_prices[i],2), \n                            round(Y_pred_prices[i],2), \n                            round(Y_real_prices[i] - Y_pred_prices[i],2), \n                           ])\n    report_df = pd.DataFrame(report_data, columns=[\"Date\", \"Price\", \"Prediction\", \"Diff\"]) \n    \n    # Plot historical prices\n    fig, ax = plt.subplots(1,1, figsize=(20,8))\n    plot_first_date_idx = current_date_idx - plot_num_hist_dates + 1\n    plot_labels = np.append(all_dates[plot_first_date_idx : current_date_idx + 1], next_business_days(date, predDaysForward))\n    #ax.set_xticklabels(plot_labels, rotation='horizontal')\n    x_plot_hist = np.arange(plot_first_date_idx, current_date_idx + 1) - plot_first_date_idx\n    y_plot_hist = all_prices[plot_first_date_idx : current_date_idx + 1]\n    plt.plot(x_plot_hist, y_plot_hist, color=\"blue\")\n    plt.scatter(x_plot_hist, y_plot_hist, c=\"blue\")\n    \n    # Plot vertical line to delimit historic vs prediction\n    plt.axvline(x=current_date_idx - plot_first_date_idx, linestyle=\"--\", color=\"gray\")\n    \n    # Plot prediction\n    x_plot_pred = np.arange(current_date_idx + 1, last_pred_date_idx + 1) - plot_first_date_idx\n    plt.plot(x_plot_pred, Y_pred_prices, color=\"red\")\n    plt.scatter(x_plot_pred, Y_pred_prices, c=\"red\")\n    plt.plot([current_date_idx, current_date_idx+1]-plot_first_date_idx, [all_prices[current_date_idx], Y_pred_prices[0]], color=\"red\", linestyle=\":\")\n    \n    # Plot actual future values (if available)\n    if has_pred_date:\n        plt.plot(x_plot_pred, Y_real_prices, color=\"green\")\n        plt.scatter(x_plot_pred, Y_real_prices, c=\"green\")\n        plt.plot([current_date_idx, current_date_idx+1]-plot_first_date_idx, all_prices[current_date_idx:current_date_idx+2], color=\"green\", linestyle=\":\")\n    \n    # Show all\n    plt.show()\n    display(HTML(report_df.to_html(index=False) ))\n\n    \ndef next_business_day(date_str):\n    date_format = \"%Y-%m-%d\"\n    date = dt.datetime.strptime(date_str, date_format)\n    shift = dt.timedelta(1 + ((date.weekday()\/\/4)*(6-date.weekday())))\n    return dt.datetime.strftime(date + shift, date_format)\n\ndef next_business_days(date_str, n):\n    days = []\n    for i in range(n):\n        date_str = next_business_day(date_str)\n        days.append(date_str)\n    return days\n\n\n# Backtest a given model for a periods of dates\ndef backtest(df, since_date, windowLength, predDaysForward, model):\n    # Find date to start evaluation\n    first_eval_date = df[df[\"Date\"] >= since_date].iloc[0][\"Date\"]\n    first_eval_date_idx = df[df[\"Date\"] == first_eval_date].index.item()\n    all_dates = df.Date.values\n    all_prices = df.Close.values\n    total_dates_to_eval = len(all_dates) - first_eval_date_idx - predDaysForward\n    \n    # Create samples\n    X = np.zeros((total_dates_to_eval, windowLength), dtype=\"float32\")\n    samples_ref = []\n    for i in range(0, total_dates_to_eval):\n        eval_idx = first_eval_date_idx + i\n        last_win_idx = eval_idx - predDaysForward\n        start_win_idx = last_win_idx - windowLength + 1\n        X[i] = to_X(all_prices, start_win_idx, windowLength)\n        samples_ref.append({\n            \"prev_date\": all_dates[last_win_idx],\n            \"eval_date\": all_dates[eval_idx],\n            \"prev_price\": all_prices[last_win_idx],\n            \"eval_price\": all_prices[eval_idx],\n            \"price_movement\": all_prices[eval_idx] - all_prices[last_win_idx]\n        })\n        \n    # Predict\n    Y_pred = model.predict(X)\n    \n    # Check results for each day\n    report_data = []\n    y_plot_pred = np.zeros(total_dates_to_eval)\n    y_plot_real = np.zeros(total_dates_to_eval)\n    for i in range(total_dates_to_eval):\n        ref = samples_ref[i]\n        pred_return = Y_pred[i][0]\n        prev_price = ref[\"prev_price\"]\n        real_price = ref[\"eval_price\"]\n        pred_price = prev_price * (1.0 + pred_return)\n        price_diff = pred_price - real_price\n        pred_return = (pred_price - prev_price) \/ prev_price * 100.0\n        action = \"Buy\" if pred_return > 0.5 else \"Nothing\"\n        profit = real_price - prev_price if action == \"Buy\" else 0\n        report_data.append([ref[\"prev_date\"], ref[\"eval_date\"], round(prev_price,2), round(real_price,2), \n                            round(pred_price,2), round(price_diff,2), ref[\"price_movement\"], \n                            action, round(profit,2), round(pred_return,2)])\n        y_plot_pred[i] = pred_price\n        y_plot_real[i] = real_price\n    report_df = pd.DataFrame(report_data, columns=[\"PrevDate\", \"PredDate\", \"PrevPrice\", \"RealPrice\", \"PredPrice\", \"Diff\", \n                                                   \"PriceMove\", \"PredAction\", \"Profit\", \"PredReturn\"]) \n    \n    # Print some stats\n    print(\"Backtesting since: {}, to: {}. Total dates: {}\".format(first_eval_date, all_dates[first_eval_date_idx + total_dates_to_eval - 1], total_dates_to_eval))\n    print(\"Profit: ${}, Buys: {}, Nothing: {}\".format(\n        round(report_df[\"Profit\"].sum(), 2), \n        len(report_df[report_df[\"PredAction\"] == \"Buy\"]),\n        len(report_df[report_df[\"PredAction\"] == \"Nothing\"])\n    ))\n    print(\"Worst loss: ${}. Total day losses: {}\/{}\".format(\n        round(report_df[\"Profit\"].min(), 2),\n        len(report_df[report_df[\"Profit\"] < 0]),\n        len(report_df)\n    ))\n    print(\"Best profit: ${}. Total day wins: {}\/{}\".format(\n        round(report_df[\"Profit\"].max(), 2),\n        len(report_df[report_df[\"Profit\"] > 0]),\n        len(report_df)\n    ))\n    \n    # Plot prices\n    fig, ax = plt.subplots(1,1, figsize=(20,8))\n    x_plot = np.arange(total_dates_to_eval)\n    plt.plot(x_plot, y_plot_real, color=\"green\")\n    plt.scatter(x_plot, y_plot_real, c=\"green\", label=\"Real\")\n    plt.plot(x_plot, y_plot_pred, color=\"red\")\n    plt.scatter(x_plot, y_plot_pred, c=\"red\", label=\"Prediction\")\n    plt.title(\"Real vs Prediction\")\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"Price $\")\n    plt.legend()\n    plt.show()\n    \n    # Display details\n    display(HTML(report_df.to_html(index=False)))\n    ","dec0ccd2":"# Don't use latest year for training\nrecent_prices_date = \"2017-01-01\"\nold_prices, recent_prices = split_prices_by_date(df, recent_prices_date)\n\n# Train model\nWINDOW_SIZE = 260\nFORWARD_DAYS = 30\nEPOCHS = 100\nresult = test_model(old_prices, WINDOW_SIZE, FORWARD_DAYS, EPOCHS)\nmodel = result[\"model\"]","4ab39d22":"# Backtest\nbacktest(df, recent_prices_date, WINDOW_SIZE, FORWARD_DAYS, model)","bab47386":"show_history_size = 0.1\npredict_return_by_date(\"sp500\", df, \"2017-01-03\", WINDOW_SIZE, FORWARD_DAYS, model, show_history_size)\npredict_return_by_date(\"sp500\", df, \"2017-02-28\", WINDOW_SIZE, FORWARD_DAYS, model, show_history_size)\npredict_return_by_date(\"sp500\", df, \"2017-04-03\", WINDOW_SIZE, FORWARD_DAYS, model, show_history_size)\npredict_return_by_date(\"sp500\", df, \"2017-06-01\", WINDOW_SIZE, FORWARD_DAYS, model, show_history_size)\npredict_return_by_date(\"sp500\", df, \"2017-08-01\", WINDOW_SIZE, FORWARD_DAYS, model, show_history_size)\npredict_return_by_date(\"sp500\", df, \"2017-10-02\", WINDOW_SIZE, FORWARD_DAYS, model, show_history_size)\npredict_return_by_date(\"sp500\", df, \"2017-10-10\", WINDOW_SIZE, FORWARD_DAYS, model, show_history_size)","f73450b0":"Prediction of S&P 500 future prices modeled as a regression problem.\nUsing a MLP neural network."}}