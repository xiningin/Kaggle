{"cell_type":{"09781c2c":"code","5c4dd328":"code","c74c58ed":"code","a13975cc":"code","b640cd3c":"code","3a76b570":"code","32fd25af":"code","c6df9dd8":"code","f567017d":"code","fefc6123":"code","740456cf":"code","427ab2ef":"code","49fb92a7":"markdown","203b787d":"markdown","71a5744f":"markdown","6961a043":"markdown","ea7fdf92":"markdown","3e776668":"markdown","aee4fe48":"markdown","024f83c1":"markdown","3eefd406":"markdown","f9795caf":"markdown","096bedc9":"markdown","9d84eed0":"markdown"},"source":{"09781c2c":"# modules\nfrom __future__ import print_function\nimport pandas as pd\nimport numpy as np\nfrom math import radians, sin, cos, atan2, sqrt\nimport folium\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp","5c4dd328":"# import the data\ndf = pd.read_csv('..\/input\/meteorite-landings\/meteorite_landings_prod.csv')\nprint('Data Imported!')","c74c58ed":"# tidy up the data\ndf.dropna(inplace=True)\ndf.drop(['Unnamed: 0','nametype','lat_lng'], axis = 1, inplace = True)\ndf = df.loc[(df['latitude']!=0)&(df['longitude']!=0),:].copy()\ndf.shape","a13975cc":"# set up the map\nm = folium.Map(location=[39.0, -100.0],width = '100%',height='100%',min_zoom = 2.5,zoom_start=4.3)\n\n# masks to filter data\ncand_mask = (df['mass']>=30000)&(df['mass']<=50000)&(df['location_code']=='US')\nother_mask = ((df['mass']<=30000)|(df['mass']>=50000))&(df['location_code']=='US')&(df['year']>=2000)\n\n\n# candidates in BLUE\nfor _, row in df.loc[cand_mask,:].iterrows():\n    folium.CircleMarker([row['latitude'],row['longitude']],radius=2.5,color='blue',fill_color = 'blue').add_to(m)\n\n# unsuitable meteorites in RED\nfor _, row in df.loc[other_mask,:].iterrows():\n    folium.CircleMarker([row['latitude'],row['longitude']],radius=2.5,color='red',fill_color = 'red').add_to(m)\n\n# then Area 51 base in PINK\nfolium.CircleMarker([37.23,-115.81],radius=5,color='magenta',fill_color = 'magenta').add_to(m)\n\n# display the chart\nm","b640cd3c":"# 1. distance between points\n\ndef haversine_distance(lat1,long1,lat2,long2):\n    \n    # approximate radius of earth in km\n    R = 6373.0\n    \n    # convert degrees to radians\n    lat1  = radians(abs(lat1))\n    long1 = radians(abs(long1))\n    lat2  = radians(abs(lat2))\n    long2 = radians(abs(long2))\n    \n    # calculate change\n    dlong = long2 - long1\n    dlat  = lat2 - lat1\n    \n    # Haversine formula for calculating distance between points on a sphere\n    a    = sin(dlat \/ 2)**2 + cos(lat1) * cos(lat2) * sin(dlong \/ 2)**2\n    c    = 2 * atan2(sqrt(a), sqrt(1 - a))\n    dist = round(R*c\/1.6,0)\n    \n    return dist","3a76b570":"# 2. function to create the distance matrix\n\ndef create_distance_matrix(lat,long):\n    # add some exception handling\n    n = len(lat)\n        \n    if len(long) == n:\n        X = np.zeros((n,n))\n        for i in range(n):\n            for j in range(n):\n                X[i,j] = haversine_distance(lat[i],long[i],lat[j],long[j])\n        return X\n        \n    else:\n        print('Check variable lengths')","32fd25af":"# get data\narea_51 = pd.DataFrame({'id':51,\n                        'meteorite_name':'NA',\n                        'recclass':'NA',\n                        'fall':'NA',\n                        'year':-1,\n                        'mass':0,\n                        'location':'United States',\n                        'location_code':'US',\n                        'location_type':'land',\n                        'distance':0,\n                        'latitude':37.23333333,\n                        'longitude':-115.80833333},index=[0])\ntemp = df.loc[(df['mass']>=30000)&(df['mass']<=50000)&(df['location_code']=='US'),df.columns != 'geometry'].copy().reset_index(drop=True)\ntemp = pd.concat([area_51,temp],axis=0,ignore_index=True)\n\n\n# data model\ndef create_data_model():\n    \"\"\"Stores the data for the problem.\"\"\"\n    data = {}\n    data['distance_matrix'] = create_distance_matrix(temp['latitude'],temp['longitude'])\n    data['demands'] = temp['mass']\n    data['vehicle_capacities'] = [200000,200000,200000,200000]\n    data['num_vehicles'] = 4\n    data['depot'] = 0\n    \n    return data\n\n\n# solution printer\ndef print_solution(data, manager, routing, assignment):\n    \"\"\"Prints assignment on console.\"\"\"\n    \n    # Display dropped nodes.\n    dropped_nodes = 'Dropped nodes:'\n    for node in range(routing.Size()):\n        if routing.IsStart(node) or routing.IsEnd(node):\n            continue\n        if assignment.Value(routing.NextVar(node)) == node:\n            dropped_nodes += ' {}'.format(manager.IndexToNode(node))\n    print(dropped_nodes)\n    \n    # Display routes\n    total_distance = 0\n    total_load = 0\n    for vehicle_id in range(data['num_vehicles']):\n        index = routing.Start(vehicle_id)\n        plan_output = 'Route for vehicle {}:\\n'.format(vehicle_id)\n        route_distance = 0\n        route_load = 0\n        while not routing.IsEnd(index):\n            node_index = manager.IndexToNode(index)\n            route_load += data['demands'][node_index]\n            plan_output += ' {0} Load({1}) -> '.format(node_index, route_load)\n            previous_index = index\n            index = assignment.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id)\n        plan_output += ' {0} Load({1})\\n'.format(manager.IndexToNode(index),\n                                                 route_load)\n        plan_output += 'Distance of the route: {}m\\n'.format(route_distance)\n        plan_output += 'Load of the route: {}\\n'.format(route_load)\n        print(plan_output)\n        total_distance += route_distance\n        total_load += route_load\n    print('Total Distance of all routes: {}m'.format(total_distance))\n    print('Total Load of all routes: {}'.format(total_load))\n\n    \n# create list of routes for each vehicle\ndef list_routes(data, manager, routing, assignment):\n    # empty dict to hold results\n    x = {}\n    \n    for vehicle_id in range(data['num_vehicles']):\n        index = routing.Start(vehicle_id) # set the start node\n        x['vehicle_'+str(vehicle_id)+'_route'] = []\n        while not routing.IsEnd(index):\n            node_index = manager.IndexToNode(index) # get the node index\n            x['vehicle_'+str(vehicle_id)+'_route'].append(node_index) # append the node index to the result list \n            index = assignment.Value(routing.NextVar(index)) # update the node index\n            \n        x['vehicle_'+str(vehicle_id)+'_route'].append(0)\n    \n    return x\n        \n\ndef main():\n    \"\"\"Solve the CVRP problem.\"\"\"\n    # Instantiate the data problem.\n    data = create_data_model()\n\n    # Create the routing index manager.\n    manager = pywrapcp.RoutingIndexManager(len(data['distance_matrix']),\n                                           data['num_vehicles'], data['depot'])\n\n    # Create Routing Model.\n    routing = pywrapcp.RoutingModel(manager)\n\n\n    # Create and register a transit callback.\n    def distance_callback(from_index, to_index):\n        \"\"\"Returns the distance between the two nodes.\"\"\"\n        # Convert from routing variable Index to distance matrix NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data['distance_matrix'][from_node][to_node]\n\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n    # Define cost of each arc.\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n\n    # Add Capacity constraint.\n    def demand_callback(from_index):\n        \"\"\"Returns the demand of the node.\"\"\"\n        # Convert from routing variable Index to demands NodeIndex.\n        from_node = manager.IndexToNode(from_index)\n        return data['demands'][from_node]\n\n    demand_callback_index = routing.RegisterUnaryTransitCallback(\n        demand_callback)\n    routing.AddDimensionWithVehicleCapacity(\n        demand_callback_index,0,data['vehicle_capacities'],True,'Capacity')\n    \n    # Allow the vehicle to skip over locations\n    for node in range(1, len(data['distance_matrix'])):\n        routing.AddDisjunction([manager.NodeToIndex(node)], # indices\n                               int(data['demands'][manager.NodeToIndex(node)]), # penalty\n                               1) # max cardinality\n\n    # Setting first solution heuristic\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)\n\n    # Solve the problem\n    assignment = routing.SolveWithParameters(search_parameters)\n\n    # Print solution on console\n    if assignment:\n        print_solution(data, manager, routing, assignment)\n        return list_routes(data, manager, routing, assignment)","c6df9dd8":"routes = main()","f567017d":"# validate for vehicle 0\n\nveh_route = pd.DataFrame({'route_node':routes['vehicle_0_route']})\n\n# add on meteorite weights, latitude, and longitude\nveh_route = veh_route.merge(right=temp[['mass','latitude','longitude']],left_on='route_node',right_index=True,how='left')\n\n# distances\nveh_route['distance'] = 0\n\nfor j in range(1,len(veh_route)):\n    while j <= (len(veh_route)-1):\n        veh_route.loc[j,'distance'] = haversine_distance(veh_route.loc[j,'latitude'],\n                                                         veh_route.loc[j,'longitude'],\n                                                         veh_route.loc[j-1,'latitude'],\n                                                         veh_route.loc[j-1,'longitude'])\n        j+=1\n\n\n# get a cumulative totals\nveh_route['mass_total'] = veh_route['mass'].cumsum()\nveh_route['dist_total'] = veh_route['distance'].cumsum()\n        \nveh_route","fefc6123":"# function to create route details\ndef get_routes(node_list):\n    \n    # DataFrame to hold results\n    x = pd.DataFrame({'route_node':node_list})\n    \n    # fetch latitude and longitude\n    x = x.merge(right=temp[['latitude','longitude']],\n                left_on='route_node',\n                right_index=True,\n                how='left')\n    \n    # create an origin->destination structure\n    y = pd.DataFrame()\n    y['origin_node'] = x['route_node']\n    y['ori_lat'] = x['latitude']\n    y['ori_lon'] = x['longitude']\n    \n    y['dest_node'] = y['origin_node'].shift(-1)\n    y['dest_lat'] = y['ori_lat'].shift(-1)\n    y['dest_lon'] = y['ori_lon'].shift(-1)\n    \n    y.dropna(inplace=True)\n    \n    return y","740456cf":"# put together the data\nveh_route_1 = get_routes(routes['vehicle_0_route'])\nveh_route_2 = get_routes(routes['vehicle_1_route'])\nveh_route_3 = get_routes(routes['vehicle_2_route'])\nveh_route_4 = get_routes(routes['vehicle_3_route'])","427ab2ef":"# plot the routes\nm = folium.Map(location=[39.0, -100.0],width = '100%',height='100%',min_zoom = 2.5,zoom_start=4.3)\n\n# candidates not selected\nfor _, row in df.loc[cand_mask,:].iterrows():\n    folium.CircleMarker([row['latitude'],row['longitude']],radius=2.5,color='grey',fill_color = 'grey').add_to(m)\n\n# vehicle 1\nfor _, row in veh_route_1.iterrows():\n    folium.CircleMarker([row['ori_lat'],row['ori_lon']],radius=2.5,color='blue',fill_color = 'blue').add_to(m)\n    folium.CircleMarker([row['dest_lat'],row['dest_lon']],radius=2.5,color='blue',fill_color = 'blue').add_to(m)\n    folium.PolyLine([[row['ori_lat'],row['ori_lon']],[row['dest_lat'],row['dest_lon']]],color='blue').add_to(m)\n\n# vehicle 2\nfor _, row in veh_route_2.iterrows():\n    folium.CircleMarker([row['ori_lat'],row['ori_lon']],radius=2.5,color='purple',fill_color = 'purple').add_to(m)\n    folium.CircleMarker([row['dest_lat'],row['dest_lon']],radius=2.5,color='purple',fill_color = 'purple').add_to(m)\n    folium.PolyLine([[row['ori_lat'],row['ori_lon']],[row['dest_lat'],row['dest_lon']]],color='purple').add_to(m)\n\n# vehicle 3\nfor _, row in veh_route_3.iterrows():\n    folium.CircleMarker([row['ori_lat'],row['ori_lon']],radius=2.5,color='red',fill_color = 'red').add_to(m)\n    folium.CircleMarker([row['dest_lat'],row['dest_lon']],radius=2.5,color='red',fill_color = 'red').add_to(m)\n    folium.PolyLine([[row['ori_lat'],row['ori_lon']],[row['dest_lat'],row['dest_lon']]],color='red').add_to(m)\n\n# vehicle 4\nfor _, row in veh_route_4.iterrows():\n    folium.CircleMarker([row['ori_lat'],row['ori_lon']],radius=2.5,color='orange',fill_color = 'orange').add_to(m)\n    folium.CircleMarker([row['dest_lat'],row['dest_lon']],radius=2.5,color='orange',fill_color = 'orange').add_to(m)\n    folium.PolyLine([[row['ori_lat'],row['ori_lon']],[row['dest_lat'],row['dest_lon']]],color='orange').add_to(m)\n\n# display the map    \nm","49fb92a7":"Let's set up and run the algorithm","203b787d":"Now for the matrix creation:","71a5744f":"A quick summary of what we'll do to the data:\n1. drop the `Na` observations\n2. drop unneeded columns\n3. exclude meteorite landings with latitude = 0 and longitude = 0.","6961a043":"And get the route data (we'll do away with Python's 0-indexation and start counting from 1 like normal people):","ea7fdf92":"It appears that although there is an abundance of meteorite surrounding the base, it is largely unsuitable for weaponisation. Our special vehicles will have to travel further afield in order to get the good stuff!\n\nLet's move on to identifying the \"optimal\" route.\n\n\n## 4. The optimisation problem, with help from OR-Tools\n\n__Let's build up the problem...__\n\nWe have 4 special vehicles, each with a limited carrying capacity. The vehices will leave Area 51 empty to harvest meteorite until they reach their carrying capacity, at which point they will return to base.\n\n__Initial Cost:__ To begin with, our algorithm will determine the \"cost\" of any particular route as simply the distance of the route. This means that as a starting point, the \"optimal\" route is simply the shortest route which maximises a vehicle's carrying capacity.\n\n__Site Prioritisation:__ Now, we need a way for our routing algorithm to prioritise harvest sites since in our case, the \"optimal\" route means the route that harvests the most meteorite in the shortest amount of time possible.\n\nAs an example, consider the following:\n- Site A contains 30 tons of meteorite\n- Site B contains 50 tons of meteorite\n- Both sites are equidistant from us\n\nAssuming we travel at the same speed at all times, we should prioritise site B as we can harvest more meteorite in the same amount of time.\n\n__Penalties:__ To translate our concept of prioritisation into something an algorithm can understand, we introduce _penalties_.\n\nA penalty is a value which we will assign to each harvest site. A harvest site's penalty will added to the route's total cost should the harvest site _not_ be visited, so _total cost = total  distance + $\\sum$ penalties  from  sites  not  visited_. \n\nOur optimal route then becomes the route which maximises the carrying capacity of the vehicle _and_ minimises the total cost.\n\nTo encourage our algorithm to visit larger meteorites we should penalise missing bigger meteorites more than smaller meteorites; the simplest way to do this is to set the harvest site's penalty = the weight of meteorite at the harvest site.\n\n### OR-Tools\nGoogle's `OR-Tools` is a handy optimisation package, and has functionality to solve vehicle routing problems with capacity constraints and penalties. Most of the heavy lifting is done by the package; even better is that the developers have provided full sample programs!\n\nWe still have to do some work however, as we need to create a data model which we feed into the algorithm. This structure will contain:\n- A matrix containing the distance between every location we will consider visiting, which includes all harvest sites as well as the depot in Area 51. This is a square matrix, where the entry $x_{ij}$ is the distance between location $i$ and location $j$.\n- The amount of meteorite available for harvest at each site.\n- Vehicle details, including vehicle carrying capacities.\n- Penalties for each harvest site (in this case, we're using meteorite mass).\n\nWe'll need some functionality to calculate the distance between any two co-ordinate points, and then a function which creates a matrix of distances. This is probably overkill for a single use, but we'll do it for practice.\n\nFirst up is the distance calculation. We'll use the Haversine formula for calculating the distance between two points on a sphere...","3e776668":"## 1. Get our (clean) data\n\nWe'll be using the \"Meteorite Landings on Earth\" data set, available n Kaggle here: https:\/\/www.kaggle.com\/brllrb\/meteorite-landings.\n\nLet's read it in and apply the necessary cleansing.","aee4fe48":"## 2. Setting the Problem\n\n- Hostile aliens are approaching the Earth, and it's up to the USA to save us from certain death.\n- To combat the little green men, Area 51's craziest scientist has designed special weapons.\n- Meteorite is a crucial element in the build of these weapons, and so must be gathered from where they lie in the wild.\n- Through strange calculations on a chalkboard, our crazy scientist has determined that we need at least 480 tons of meteorite to stand a fighting chance against the galaxy's worst villains. However the more guns available, the better (because America).\n- Due to the nature of the meteorite, our heroes need to use special vehicles to collect the meteorite. They currently have 4 of these vehicles available.\n- These vehicles can each carry a maximum of 200 tons of meteorite in total, _but_ can only load a maximum of 50 tons of meteorite onto the truck from each site. No field surgery is available to reduce the size of the meteor at the landing site.\n- Unfortunately, due to the nature of the currently immature weapons manufacturing process, a certain amount of meteorite is lost during processing. This means that only meteorites with mass in excess of 30 tons are viable for weapons manufacturing.\n- The aliens' arrival is imminent; we need to find the \"optimal route\" for our heroes to take in order to gather the most meteorite in the shortest amount of time.\n\n\n## 3. Visualising the problem\nTo visualise the problem, we'll use a package relatively new to me - `folium`. The package seems quite easy to use, and generates beautiful _interactive_ charts.\n\nOur base - where our heroes' journeys begin and end - will be highlighted in pink.\n\nMeteorites suitable for harvesting and weaponisation are plotted in blue.\n\nUnsuitable meteorites are highlighted in red.\n\n_Due to the sheer number of inapprioriate candidates, we've excluded all landings prior to the year 2000._","024f83c1":"Putting the route details together in the table above, total meteorite harvested (`mass`) and total distance travelled (`dist_total`) seem to align with what the algorithm has suggested. We'll leave it at that at the moment and assume that the algorithm is working as expected.\n\nLet's move on to something more interesting - visualising what the \"optimal\" routes look like.\n\n### Visualisation\nWe'll produce another `folium` visualisation of each of the suggested vehicle routes. This will require a little legwork but should be fairly straightforward.\n\nFirstly, we'll restructure the data into a format where each row of the table contains the latitude and logitude pair of the vehicle's current location and its next destination. We'll need to repeat this function for each vehicle route so a handy formula will make our lives easier.\n\nWe'll then create these data sets for each of the vehicle routes.\n\nLastly, we'll create a visualisation and add the route details by looping through our newly restructured vehicle route data sets.\n\nLet's get started with the function.","3eefd406":"The output from the optimisation algorithm is quite handily summarised above.\n\nAlong the top line we can see all of the \"nodes\" (locations) that our vehicles chose _not_ to visit.\n\nBelow that, we can see a print out of each vehicle route and their respective:\n- order of meteorite harvest sites visited\n- current meteorite being carried (\"load\")\n- total distance travelled in miles, including a return to Area 51 (\"distance of the route\")\n- and the total amount of meteorite harvested (in KG).\n\n\n## 5. Validation and visualisation\n\n### Validation\nLet's do a quick sense check to see if the results seem sensible - we'll validate the details for Vehicle 0's route, particularly the distance travelled and the meteorite harvested.","f9795caf":"Well, it certainly looks like our heroes are in for a considerable road trip.\n\nOn a more serious note, it's interesting the route length decreases with each vehicle dispatched - i.e. vehicle 1 travels furthest, vehicle 2 slightly less, and so on. I wonder if that is a by-product of this algorithm configuration but will need to investigate further to be sure.\n\n\n## Closing thoughts and comments\nWe've seen just how straightforward it is to visualise the problem, and how simple it is to use `folium` to produce beautiful map visualisations.\n\nThe route optimisation was a little more complicated, but handled in stride with help from Google's OR Tools and its sample programs. The package offers much more functionality than what is shown here; the user is encouraged to visit the website to read more.\n\nWe made some key assumptions when solving our contrived problem, and for more realism we would do well to consider the following augmentations:\n- we've currently only considered __distance between locations__ as the crow flies - i.e. our Haversine distance calculation calculates the straight-line distance between two points. Obviously this is a shortcoming as our vehicles need to travel on man-made roads! I believe that OR Tools offers some functionality to calculate actual distance using Google Maps.\n- we've also assumed that our harvest vehicles all travel at the same speed at all times. We should consider using __variable travelling speeds__, driven by certain factors - e.g. current vehicle load, motorways v narrow country lanes.\n- any __decay or breakage__ of the meteorite during transit. \n\nLast but not least, we would also do well to learn how to add a decent legend to a `folium` map.\n\nThat's a fair bit of food for thought, but for now we'll consider the little green men defeated!","096bedc9":"Finally, plot the vehicle routes:\n- vehicle 1's route will be plotted in blue\n- vehicle 2's route will be plotted in purple\n- vehicle 3's route will be shown in red\n- vehicle 4's route can be seen in orange\n- for context, we'll add the candidate sites which we didn't visit\n\nLet's see what it looks like.","9d84eed0":"# Falling Skies\n\n\n## Introduction\n\nBeing stuck at home during the lockdown has certainly been interesting. For a time, binge-watching Netflix shows and waiting for deliveries became the norm.\n\nStaring out of my lounge window one day I noticed how many delivery vans arrived at my apartment block, seemingly all at the same time. This got me thinking about how companies could efficiently schedule their delivery obligations, which naturally got me thinking about route optimisation - and here we are!\n\n\n## What will we be doing?\n1. Get our data. We will do a minimal amount of cleaning, with very little explanation. There are loads of great resources about data exploration and cleaning - this will not be one of them!\n2. Define our problem. This will be an interesting one, as we will be optimising humanity's fight against little green men from outer space.\n3. Visualise the problem.\n4. Use Google's OR-Tools to develop a solution.\n5. Quickly validate and visualise the solution.\n\nLet's get going!"}}