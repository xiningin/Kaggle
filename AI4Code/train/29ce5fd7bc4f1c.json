{"cell_type":{"9b1f974f":"code","de8cab43":"code","9d68d524":"code","cbe48b96":"code","130ca402":"code","70cf88af":"code","2f982b29":"code","6810337e":"code","227f0ebb":"code","8c1b63c0":"code","9c7d72f5":"code","68d2853e":"code","c9d1f1ae":"markdown","e70b4714":"markdown","d3a189b4":"markdown","edb9eaf6":"markdown","3980887f":"markdown","c8c5e548":"markdown","29b54b6b":"markdown"},"source":{"9b1f974f":"import numpy as np\nimport pandas as pd\nfrom PIL import Image\nimport matplotlib.pyplot as plt","de8cab43":"df = pd.read_csv('\/kaggle\/input\/age-gender-and-ethnicity-face-data-csv\/age_gender.csv')\ndf.head()","9d68d524":"ethnicity_mapping = {0:\"White\", 1:\"Black\", 2:\"Asian\", 3:\"Indian\", 4:\"Hispanic\"}\ngender_mapping = {0:\"Male\", 1:\"Female\"}","cbe48b96":"def get_image(row):\n    '''\n    functions takes a series and returns the image and it's labels\n    '''\n    age = row['age']\n    ethnicity = row['ethnicity']\n    gender = row['gender']\n    image = np.array(row['pixels'].split(), 'float64')\n    image = image.reshape(48, 48) \/ 255.0\n\n    return image, age, ethnicity, gender","130ca402":"#Show Images\ndef show_images():\n  plt.figure(figsize=(30, 30))\n\n  for i in range(25):\n    #select random image\n    index = np.random.randint(0, len(df))\n    image, age, ethnicity, gender = get_image(df.iloc[index])\n\n    plt.subplot(5, 5, i+1)\n    plt.imshow(image)\n    plt.title(' Age: {}\\n Ethnicity: {}\\n gender: {}'.format(age, ethnicity_mapping[ethnicity], gender_mapping[gender]))\n    # plt.axes('off')\n\n  plt.show()\n\nshow_images()","70cf88af":"'''\nDefining data generator\n'''\nfrom tensorflow.keras.utils import Sequence\nclass DataGenerator(Sequence):\n    'Generates data for Keras'\n    def __init__(self, name, images, age, ethnicity, gender, batch_size=32, shuffle=True):\n        \n        \n        'Initialization'\n        self.name = name\n        self.batch_size = batch_size\n        self.images = images\n        self.age = age\n        self.ethnicity = ethnicity\n        self.gender = gender\n        self.shuffle = shuffle\n        self.on_epoch_end()\n\n    def __len__(self):\n        'Denotes the number of batches per epoch'\n        #print('returning length')\n        #print(int(np.floor(len(self.sentences) \/ self.batch_size)))\n        return int(np.floor(len(self.age) \/ self.batch_size))\n\n    def __getitem__(self, index):\n        'Generate one batch of data'\n        # Generate indexes of the batch\n        #print(index)\n        indexes = self.indexes[index*self.batch_size:(index+1)*self.batch_size]\n\n        # Find list of IDs\n        images = [self.images[k] for k in indexes]\n        age = [self.age[k] for k in indexes]\n        ethnicity = [self.ethnicity[k] for k in indexes]\n        gender = [self.gender[k] for k in indexes]\n        \n        images = np.array(images)\n        age = np.array(age)\n        ethnicity = np.array(ethnicity)\n        gender = np.array(gender)\n        \n        X = images\n        y = [age, ethnicity, gender]\n        \n        return X, y\n\n    def on_epoch_end(self):\n        'Updates indexes after each epoch'\n        self.indexes = np.arange(len(self.age))\n        if self.shuffle == True:\n            np.random.shuffle(self.indexes)\n\n\n    def add_data(self, images, age, ethnicity, gender):\n        self.images=np.append(self.images, images, axis=0)\n        self.age=np.append(self.age, age, axis=0)\n        self.ethnicity=np.append(self.ethnicity, ethnicity, axis=0)\n        self.gender=np.append(self.gender, gender, axis=0)\n        self.on_epoch_end()","2f982b29":"'''\nfunction to make generators\n'''\ndef generate_images(df, generator_name, batch_size=32):\n    \n    total_images = len(df)\n    num_batches = total_images \/\/ batch_size\n    batch_count = 0\n    while batch_count < num_batches:\n        x_batch = np.zeros((batch_size, 48, 48, 1))\n        age_batch = np.zeros((batch_size,))\n        ethnicity_batch = np.zeros((batch_size,))\n        gender_batch = np.zeros((batch_size,))\n\n        for i in range(batch_size):\n            index = np.random.randint(0, total_images)\n            image, age, ethnicity, gender = get_image(df.iloc[index])\n            image = image.reshape(48, 48, 1)\n\n            x_batch[i] = image \/ 255.0\n            age_batch[i] = age\n            ethnicity_batch[i] = ethnicity\n            gender_batch[i] = gender\n            \n        if batch_count == 0:\n            generator = DataGenerator(generator_name, x_batch, age_batch, ethnicity_batch, gender_batch)\n        else:\n            generator.add_data(x_batch, age_batch, ethnicity_batch, gender_batch)\n            \n        batch_count += 1\n\n    return generator","6810337e":"# Create train and validation data generators\n\ndf_val = df.sample(1000)\ndf_train = df.sample(len(df) - 1000)\n\ntrain_gen = generate_images(df_train, generator_name='training_generator')\nvalidation_gen = generate_images(df_val, generator_name='validation_generator')","227f0ebb":"from tensorflow.keras.layers import Convolution2D, MaxPool2D, MaxPooling2D, Flatten, Dense, BatchNormalization, Dropout, Activation, Input\nfrom tensorflow.keras.models import Model\nimport tensorflow as tf","8c1b63c0":"input = Input(shape=(48, 48, 1), name='input')\n\nconv_1 = Convolution2D(32, 3, activation='relu')(input)\nconv_2 = Convolution2D(32, 3, activation='relu')(conv_1)\npool_1 = MaxPooling2D(pool_size=(2, 2))(conv_2)\n\nflat_1 = Flatten(name='flat_1')(pool_1)\ngender = Dense(1, activation='sigmoid', name='gender')(flat_1)\n\ndrop_1 = Dropout(0.2)(pool_1)\n\nconv_3 = Convolution2D(64, 3, activation='relu')(drop_1)\nconv_4 = Convolution2D(128, 3, activation='relu')(conv_3)\npool_2 = MaxPooling2D(pool_size=(2, 2))(conv_4)\n\nflat_2 = Flatten(name='flat_2')(pool_2)\nage = Dense(1, name='age')(flat_2)\n\ndrop_2 = Dropout(0.2)(pool_2)\n\nconv_5 = Convolution2D(64, 3, activation='relu')(drop_2)\nconv_6 = Convolution2D(128, 3, activation='relu')(conv_5)\n\nflat_3 = Flatten(name='flat_3')(conv_6)\nethnicity = Dense(5, activation='softmax', name='ethnicity')(flat_3)\n\nmodel = Model(inputs=input, outputs=[age, ethnicity, gender])\nmodel.compile(\n    loss={\n        'age': 'mean_squared_error',\n        'ethnicity': 'sparse_categorical_crossentropy',\n        'gender': 'binary_crossentropy'\n    },\n    metrics={\n        'age':'mean_squared_error',\n        'ethnicity': 'sparse_categorical_accuracy',\n        'gender': 'accuracy'\n    }, \n    optimizer='adam'\n)\n\nmodel.summary()","9c7d72f5":"class Logger(tf.keras.callbacks.Callback):\n    def on_epoch_end(self, epoch, logs=None):\n        print() #just for spacing between two epochs stats","68d2853e":"model.fit(train_gen, \n              validation_data=validation_gen, \n              epochs=100,\n              callbacks=[Logger(), tf.keras.callbacks.TensorBoard(log_dir='.\/logs')],\n              verbose=1)","c9d1f1ae":"#### Prepare data for training ","e70b4714":"Accuracy on validation data\n\nAge (mse): 55.59\n\nEthnicity (accuracy): 70.26 %\n\nGender (accuracy): 88.91 % ","d3a189b4":"#### Training ","edb9eaf6":"Here I am using multilabel classification model to predict Age, Gender and Ethnicity of person","3980887f":"#### Load Data","c8c5e548":"#### Import required libraries","29b54b6b":"#### Define Model"}}