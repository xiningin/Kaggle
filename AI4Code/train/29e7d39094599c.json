{"cell_type":{"5e7165f0":"code","d8b003a0":"code","9e8c0e2e":"code","38d04549":"code","dcc4ad97":"code","4d797982":"code","7931cba9":"code","6f060025":"code","847fd23b":"markdown","f2b928d0":"markdown"},"source":{"5e7165f0":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","d8b003a0":"from catboost import CatBoostClassifier\nfrom sklearn.metrics import accuracy_score, log_loss\nfrom sklearn.metrics import f1_score\nfrom tensorflow.keras.utils import to_categorical\nfrom sklearn.model_selection import KFold, StratifiedKFold\nfrom sklearn.model_selection import train_test_split\n\ncbc = CatBoostClassifier(verbose = 100, task_type = 'GPU', iterations = 10000, learning_rate = 0.1)\n\nX_train, X_val, y_train, y_val = train_test_split(train2, train['credit'], stratify= train['credit'], test_size=0.20, random_state = 420)\n\n\n\ndef run_kfold(cbc):\n    folds=StratifiedKFold(n_splits=5, shuffle=True, random_state= 420)\n    outcomes=[]\n    sub=np.zeros((test2.shape[0], 3))  \n    for n_fold, (train_index, val_index) in enumerate(folds.split(train2, train['credit'])):\n        X_train, X_val = train2.iloc[train_index], train2.iloc[val_index]\n        y_train, y_val = train['credit'].iloc[train_index], train['credit'].iloc[val_index]\n        cbc.fit(X_train, y_train, eval_set = (X_val, y_val), early_stopping_rounds = 25)\n        \n        predictions=cbc.predict_proba(X_val)\n        \n        logloss = log_loss(to_categorical(y_val), predictions)\n        outcomes.append(logloss)\n        print(f\"FOLD {n_fold} : logloss:{logloss}\")\n        \n        sub+=cbc.predict_proba(test2)\n        \n        \n    mean_outcome=np.mean(outcomes)\n    \n    \n    print(\"Mean:{}\".format(mean_outcome))\n    return sub\/folds.n_splits\n\nsubmission = run_kfold(cbc)","9e8c0e2e":"alldata2[\"money\"] = alldata2[\"car\"].replace({\"N\" : 0, \"Y\" : 1}) + alldata2[\"reality\"].replace({\"N\" : 0, \"Y\" : 1}) * 2  + alldata2[\"phone\"] + alldata2[\"work_phone\"] ","38d04549":"train.loc[train[\"DAYS_EMPLOYED\"] > 0, \"DAYS_EMPLOYED\"] = 1\ntest.loc[test[\"DAYS_EMPLOYED\"] > 0, \"DAYS_EMPLOYED\"] = 1\n\ntrain[\"EMPLOYED\"] = train[\"DAYS_EMPLOYED\"].apply(lambda x: False if x == 1 else True)\ntest[\"EMPLOYED\"] = test[\"DAYS_EMPLOYED\"].apply(lambda x: False if x == 1 else True)\n\ntrain.loc[(train[\"EMPLOYED\"] == False) & (train[\"occyp_type\"].isnull()), \"occyp_type\"] = \"None\"\ntest.loc[(test[\"EMPLOYED\"] == False) & (test[\"occyp_type\"].isnull()), \"occyp_type\"] = \"None\"","dcc4ad97":"train = train[train[\"child_num\"] < 7]","4d797982":"# train\uc758 income_total binning\nbins = np.linspace(train[\"income_total\"].min(), train[\"income_total\"].max(), 10)\ntrain[\"income_bin\"] = np.digitize(train[\"income_total\"], bins)\n\n# test\uc758 income_total binning\ntest[\"income_bin\"] = np.digitize(test[\"income_total\"], bins)\n \n# train\uc758 income_bin\uacfc income_type\uc73c\ub85c \ubb36\uc5b4\uc11c \uac19\uc740 \uc9d1\ub2e8\uc758 \uc9c1\uc5c5 \uc911 \ucd5c\ube48\uac12\uc73c\ub85c \uc9c1\uc5c5 \uacb0\uce21\uce58 \ucc44\uc6b0\uae30 \ntrain[\"occyp_type\"] = train.groupby([\"income_bin\", \"income_type\"])[\"occyp_type\"].transform(lambda x: x.fillna(x.mode()[0] if not x.mode().empty else \"Empty\"))\n\ntest[\"occyp_type\"] = test.groupby([\"income_bin\", \"income_type\"])[\"occyp_type\"].transform(lambda x: x.fillna(x.mode()[0] if not x.mode().empty else \"Empty\"))","7931cba9":"def binning_age(birth):\n    age = abs(birth) \/ 365\n    if 20 <= age < 30 :\n        return \"20s\"\n    elif 30 <= age < 40 :\n        return \"30s\"\n    elif 40 <= age < 50 :\n        return \"40s\"\n    elif 50 <= age < 60 :\n        return \"50s\"\n    else:\n        return \"60s\"\n\nalldata2[\"generation\"] = alldata2[\"DAYS_BIRTH\"].apply(binning_age)","6f060025":"alldata2[\"income_by_birth\"] = alldata2[\"income_total\"] \/ alldata2[\"DAYS_BIRTH\"]\nalldata2['income_birth_multiply'] = alldata2['income_total'] * alldata2['DAYS_BIRTH']\nalldata2['income_employed_multiply'] = alldata2['income_total'] * alldata2['DAYS_EMPLOYED']\nalldata2['income_employed_by'] = alldata2['income_total'] \/ alldata2['DAYS_EMPLOYED']\nalldata2['income_total_by_family_size'] = alldata2['income_total']  \/ alldata2['family_size']\nalldata2['DAYS_BIRTH_by_DAYS_EMPLOYED'] = alldata2['DAYS_BIRTH']  \/ (-alldata2['DAYS_EMPLOYED'])\nalldata2['DAYS_BIRTH_by_family_size'] = alldata2['DAYS_BIRTH']  \/ alldata2['family_size']\nalldata2['DAYS_BIRTH_by_family_size_multi'] = alldata2['DAYS_BIRTH']  * alldata2['family_size']\nalldata2['DAYS_BIRTH_by_begin_month_minus'] = alldata2['DAYS_BIRTH']  - alldata2['begin_month']\nalldata2['DAYS_EMPLOYED_by_family_size'] = alldata2['DAYS_EMPLOYED']  \/ alldata2['family_size']","847fd23b":"### Feature Engineering","f2b928d0":"## \uc2e4\ud589\uc2dc\ud0a4\uc9c0\ub9c8\uc2dc\uace0 \uc544\ub798 \uc140\uc5d0 \uc788\ub294 \ucf54\ub4dc\ub97c \uac00\uc838\uac00\uc11c \uc0ac\uc6a9\ud558\uc2dc\uba74 \ub429\ub2c8\ub2e4."}}