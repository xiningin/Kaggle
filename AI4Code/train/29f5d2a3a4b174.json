{"cell_type":{"4bf01c0c":"code","20e53f9d":"code","84cec9ca":"code","7db661d8":"code","6f3d18e4":"code","79be8c50":"code","344302c7":"code","5a06e0f6":"code","17d5878a":"code","4ee5b181":"markdown","46f56d5f":"markdown","5aa51346":"markdown","7b552aff":"markdown","8637daa5":"markdown","6769f35c":"markdown"},"source":{"4bf01c0c":"!pip install coinflip","20e53f9d":"from random import getrandbits\n\nRNG_output = [getrandbits(1) for _ in range(1000)]\n\nexample = \"\".join(str(x) for x in RNG_output[:24])\nprint(f\"These randomness tests only accept binary sequences e.g. {example}\")","84cec9ca":"from coinflip.randtests import monobit\n\nresult = monobit(RNG_output)\nprint(result)","7db661d8":"siglevel = 0.01\noutcome = \"PASSED\" if result.p > siglevel else \"FAILED\"\nprint(f\"The random number generator's output {outcome} the Frequency (Monobit) statistical test for\\nrandomness\")","6f3d18e4":"result.plot_counts()","79be8c50":"difference = result.maxcount.count - result.mincount.count\nprint(f\"difference = {result.maxcount.count} - {result.mincount.count}\")\nprint(f\"           = {difference}\")","344302c7":"print(f\"statistic = {difference} \/ {result.n}\")\nprint(f\"          = {round(result.statistic, 3)}\")","5a06e0f6":"result.plot_refdist()","17d5878a":"print(f\"p-value = erfc({round(result.statistic, 3)} \/ sqrt(2)) \/\/ erfc is the complimentary error function\")\nprint(f\"        = {round(result.p, 3)}\")\nprint()\n\npercentage = \"{:.1%}\".format(result.p)\nprint(f\"Finding the cumulative likelihood a true RNG would have such a difference or greater comes to the resulting probability of {percentage}\")\nprint()\n\nreject = \"would\" if result.p > siglevel else \"would NOT\"\nprint(f\"With a significant level of {siglevel}, you {reject} reject the hypothesis that the RNG is\\nnon-random.\")","4ee5b181":"This is my Python package [coinflip](https:\/\/github.com\/Honno\/coinflip\/), which implements the randomness tests recommended by NIST in their [SP800-22 paper](https:\/\/csrc.nist.gov\/publications\/detail\/sp\/800-22\/rev-1a\/final).","46f56d5f":"So how does this test actually work?\n\nFirst, the number of occurences for the `0` & `1` values are found and the difference is calculated.","5aa51346":"Another way of thinking about it: the lower the p-value, the less confident we can say that this data is random.","7b552aff":"For randomness testing, you'll want to generate a sample output from your RNG. Here we're testing `random.getrandbits(1)` as if it was our random number generator.","8637daa5":"I'll be demonstrating the use of the *Frequency (Monobit)* randomness test, which identifies that the proportion of both values in the sequence is roughly a 1:1 ratio","6769f35c":"We can compare this to the hypothetical output of a truly random RNG. A question is asked&mdash;how likely would such a RNG produce a sequence with *at least* a such a `difference` between the occurences of binary values?\n\nThe likelihood would decrease with higher differences, assuming that random outputs tends towards uniformity. Such a distribution would follow a half-normal distribution (i.e. a bell-curve shape, but with it's left side flipped and added to the right).\n\nTo compare the `difference` with this reference distribution, we first normalise it by dividing it by the square root of the sequences length `n`. This results in the normalised difference, which acts as the `statistic`."}}