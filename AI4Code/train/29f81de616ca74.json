{"cell_type":{"51255edf":"code","426227c9":"code","f0cc9f95":"code","21bc65cc":"code","8c88dc40":"code","49c0c81a":"code","f032b718":"code","bcd40683":"code","74d01f44":"code","d845f34b":"code","399a93a1":"code","9770aab4":"code","b9c0d49f":"code","a9f76219":"code","c7ee0eb2":"code","8071b58a":"markdown","7fa74bb8":"markdown","c915ea0c":"markdown","1751ccbe":"markdown","b019ed94":"markdown","61e1a0c6":"markdown","2f6a8d65":"markdown","d54c8f88":"markdown","a59dcc71":"markdown","b2caf671":"markdown","dfa95c4f":"markdown","7a0e203b":"markdown","9dc92bcd":"markdown","aa0b00ac":"markdown","3c952b15":"markdown","856fd3e9":"markdown","b048a80d":"markdown"},"source":{"51255edf":"from __future__ import print_function\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\n\nfrom PIL import Image\nimport matplotlib.pyplot as plt\n\nimport torchvision.transforms as transforms\nimport torchvision.models as models\n\nimport copy","426227c9":"# move the model to GPU, if available\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")","f0cc9f95":"def load_image(img_path, max_size=400, shape=None):\n    ''' Load in and transform an image, making sure the image\n       is <= 400 pixels in the x-y dims.'''\n    \n    image = Image.open(img_path).convert('RGB')\n    \n    # large images will slow down processing\n    if max(image.size) > max_size:\n        size = max_size\n    else:\n        size = max(image.size)\n    \n    if shape is not None:\n        size = shape\n        \n    in_transform = transforms.Compose([\n                        transforms.Resize(size),\n                        transforms.ToTensor(),\n                        transforms.Normalize((0.485, 0.456, 0.406), \n                                             (0.229, 0.224, 0.225))])\n\n    # discard the transparent, alpha channel (that's the :3) and add the batch dimension\n    image = in_transform(image)[:3,:,:].unsqueeze(0)\n    \n    return image","21bc65cc":"# load in content and style image\ncontent = load_image('\/kaggle\/input\/images\/lionKing.jpg').to(device)\n# Resize style to match content, makes code easier\nstyle = load_image('\/kaggle\/input\/images\/cartoon.jpg', shape=content.shape[-2:]).to(device)\n","8c88dc40":"# get the \"features\" portion of VGG19 (we will not need the \"classifier\" portion)\nvgg = models.vgg19(pretrained=True).features\n\n# freeze all VGG parameters since we're only optimizing the target image\nfor param in vgg.parameters():\n    param.requires_grad_(False)","49c0c81a":"vgg.to(device)","f032b718":"# helper function for un-normalizing an image \n# and converting it from a Tensor image to a NumPy image for display\ndef im_convert(tensor):\n    \"\"\" Display a tensor as an image. \"\"\"\n    \n    image = tensor.to(\"cpu\").clone().detach()\n    image = image.numpy().squeeze()\n    image = image.transpose(1,2,0)\n    image = image * np.array((0.229, 0.224, 0.225)) + np.array((0.485, 0.456, 0.406))\n    image = image.clip(0, 1)\n\n    return image","bcd40683":"# display the images\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 10))\n# content and style ims side-by-side\nax1.imshow(im_convert(content))\nax2.imshow(im_convert(style))","74d01f44":"def get_features(image, model, layers=None):\n    \"\"\" Run an image forward through a model and get the features for \n        a set of layers. Default layers are for VGGNet matching Gatys et al (2016)    \"\"\"\n    \n   \n    if layers is None:\n        layers = {'0': 'conv1_1',\n                  '5': 'conv2_1', \n                  '10': 'conv3_1', \n                  '19': 'conv4_1',\n                  '21': 'conv4_2',  ## content representation\n                  '28': 'conv5_1'}\n        \n    features = {}\n    x = image\n    # model._modules is a dictionary holding each module in the model\n    for name, layer in model._modules.items():\n        x = layer(x)\n        if name in layers:\n            features[layers[name]] = x\n            \n    return features","d845f34b":"\ndef gram_matrix(tensor):\n    \"\"\" Calculate the Gram Matrix of a given tensor \n        Gram Matrix: https:\/\/en.wikipedia.org\/wiki\/Gramian_matrix\n    \"\"\"\n    \n    # get the batch_size, depth, height, and width of the Tensor\n    _, d, h, w = tensor.size()\n    \n    # reshape so we're multiplying the features for each channel\n    tensor = tensor.view(d, h * w)\n    \n    # calculate the gram matrix\n    gram = torch.mm(tensor, tensor.t())\n    \n    return gram","399a93a1":"# get content and style features only once before training\ncontent_features = get_features(content, vgg)\nstyle_features = get_features(style, vgg)\n\n# calculate the gram matrices for each layer of our style representation\nstyle_grams = {layer: gram_matrix(style_features[layer]) for layer in style_features}\n\n# create a third \"target\" image and prep it for change\n# it is a good idea to start off with the target as a copy of our *content* image\n# then iteratively change its style\ntarget = content.clone().requires_grad_(True).to(device)","9770aab4":"# weights for each style layer \n# weighting earlier layers more will result in *larger* style artifacts\n# notice we are excluding `conv4_2` our content representation\nstyle_weights = {'conv1_1': 1.,\n                 'conv2_1': 0.75,\n                 'conv3_1': 0.2,\n                 'conv4_1': 0.2,\n                 'conv5_1': 0.2}\n\ncontent_weight = 1  # alpha\nstyle_weight = 1e6  # beta","b9c0d49f":"# for displaying the target image, intermittently\nshow_every = 400\n\n# iteration hyperparameters\noptimizer = optim.Adam([target], lr=0.003)\nsteps = 2000  # decide how many iterations to update your image (5000)\n\nfor ii in range(1, steps+1):\n    \n    # get the features from your target image\n    target_features = get_features(target, vgg)\n    \n    # the content loss\n    content_loss = torch.mean((target_features['conv4_2'] - content_features['conv4_2'])**2)\n    \n    # the style loss\n    # initialize the style loss to 0\n    style_loss = 0\n    # then add to it for each layer's gram matrix loss\n    for layer in style_weights:\n        # get the \"target\" style representation for the layer\n        target_feature = target_features[layer]\n        target_gram = gram_matrix(target_feature)\n        _, d, h, w = target_feature.shape\n        # get the \"style\" style representation\n        style_gram = style_grams[layer]\n        # the style loss for one layer, weighted appropriately\n        layer_style_loss = style_weights[layer] * torch.mean((target_gram - style_gram)**2)\n        # add to the style loss\n        style_loss += layer_style_loss \/ (d * h * w)\n        \n    # calculate the *total* loss\n    total_loss = content_weight * content_loss + style_weight * style_loss\n    \n    # update your target image\n    optimizer.zero_grad()\n    total_loss.backward()\n    optimizer.step()\n    \n    # display intermediate images and print the loss\n    if  ii % show_every == 0:\n        print('Total loss: ', total_loss.item())\n        plt.imshow(im_convert(target))\n        plt.show()","a9f76219":"# display content and final, target image\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 10))\nax1.imshow(im_convert(content))\nax2.imshow(im_convert(target))","c7ee0eb2":"torch.save(vgg, 'model.pt')","8071b58a":"**Table of Contents**\n\n1. [Introduction](#point1)\n2. [Principle](#point2)\n3. [Loading Images](#point3)\n4. [Visualization](#point4)\n5. [Loss Functions](#point5)  \n6. [Loading Vgg19](#point6)\n7. [Training the model](#point7)\n8. [Transfer Model output](#point8)\n9. [Conclusion](#point9)\n10. [Resources](#point10)","7fa74bb8":"### Loss Functions <a class=\"anchor\" id=\"point5\"><\/a>\nMapping of layer names to the content representation and the style representation.","c915ea0c":"### Introduction <a id='point1'><\/a>\n\nThe Neural-Style algorithm developed by Leon A. Gatys, Alexander S. Ecker and Matthias Bethge. \nStyle transfer method that is outlined in the paper, [Image Style Transfer Using Convolutional Neural Networks, by Gatys](https:\/\/www.cv-foundation.org\/openaccess\/content_cvpr_2016\/papers\/Gatys_Image_Style_Transfer_CVPR_2016_paper.pdf) in PyTorch.\n\nIn this paper, style transfer uses the features found in the 19-layer VGG Network, which is comprised of a series of convolutional and pooling layers, and a few fully-connected layers. ","1751ccbe":"## Neural Transfer Using Pytorch\n\nIn this notebook we are going to learn and explore in detail about neural style transfer.\n","b019ed94":"Putting it all Together\nNow that we've written functions for extracting features and computing the gram matrix of a given convolutional layer; let's put all these pieces together! We'll extract our features from our images and calculate the gram matrices for each layer in our style representation.","61e1a0c6":"#### Loss and Weights\nIndividual Layer Style Weights\nBelow, we have the option to weight the style representation at each relevant layer. It's suggested that you use a range between 0-1 to weight these layers. By weighting earlier layers (conv1_1 and conv2_1) more, you can expect to get larger style artifacts in your resulting, target image. Should you choose to weight later layers, you'll get more emphasis on smaller features. This is because each layer is a different size and together they create a multi-scale style representation!\n\nContent and Style Weight\nJust like in the paper, we define an alpha (content_weight) and a beta (style_weight). This ratio will affect how stylized your final image is. It's recommended that you leave the content_weight = 1 and set the style_weight to achieve the ratio you want.","2f6a8d65":"\n### Saving the Transfer Model <a class=\"anchor\" id=\"point8\"><\/a>","d54c8f88":"### Loading Vgg19 <a class=\"anchor\" id=\"point6\"><\/a>\nVGG19 is split into two portions:\n\n1. vgg19.features, which are all the convolutional and pooling layers.\n2. vgg19.classifier, which are the three linear, classifier layers at the end.\n\nWe only need the features portion, which we're going to load in and \"freeze\" the weights of, below.","a59dcc71":"### Display the Target Image","b2caf671":"### Conclusion <a class=\"anchor\" id=\"point9\"><\/a>\n\nWe have built a pytorch vgg19 model which performs nerural transfer.","dfa95c4f":"\n### Loading Images <a class=\"anchor\" id=\"point3\"><\/a>\n\nBelow, is a helper function for loading in any type and size of image. The load_image function also converts images to normalized Tensors.\n\nAdditionally, it will be easier to have smaller images and to squish the content and style images so that they are of the same size.","7a0e203b":"**Gram Matrix**\n\nThe output of every convolutional layer is a Tensor with dimensions associated with the batch_size, a depth, d and some height and width (h, w).\n\nThe Gram matrix of a convolutional layer can be calculated as follows:\n\nGet the depth, height, and width of a tensor using batch_size, d, h, w = tensor.size\nReshape that tensor so that the spatial dimensions are flattened\nCalculate the gram matrix by multiplying the reshaped tensor by it's transpose\n\n\nNote: You can multiply two matrices using torch.mm(matrix1, matrix2).","9dc92bcd":"**Content Loss**\n\nThe content loss is a function that represents a weighted version of the content distance for an individual layer.\n\n**Style Loss**\n\nIt will act as a transparent layer in a network that computes the style loss of that layer.","aa0b00ac":"### Training the model <a class=\"anchor\" id=\"point7\"><\/a>\nUpdating the Target & Calculating Losses we will decide on a number of steps for which to update the image, we are changing our target image and nothing else about VGG19 or any other image. Therefore, the number of steps is really up to us. We may want to start out with fewer steps if we are just testing out different weight values or experimenting with different images.\nInside the iteration loop, we will calculate the content and style losses and update your target image, accordingly.\n\nThe content loss will be the mean squared difference between the target and content features at layer conv4_2. This can be calculated as follows:\n\n**content_loss = torch.mean((target_features['conv4_2']- content_features['conv4_2'])**2)**\n\nThe style loss is calculated in a similar way, only we have to iterate through a number of layers, specified by name in our dictionary style_weights.\n\n\nwe will calculate the gram matrix for the target image, target_gram and style image style_gram at each of these layers and compare those gram matrices, calculating the layer_style_loss. Later, we will see that this value is normalized by the size of the layer.\nFinally, we will create the total loss by adding up the style and content losses and weighting them with your specified alpha and beta!\nIntermittently, we'll print out this loss; don't be alarmed if the loss is very large. It takes some time for an image's style to change and you should focus on the appearance of your target image rather than any loss value. Still, we should see that this loss decreases over some number of iterations.","3c952b15":"\n### Visualization <a class=\"anchor\" id=\"point4\"><\/a>","856fd3e9":"### Resources <a class=\"anchor\" id=\"point10\"><\/a>\n\nI referred the code from the below links.\n1. [Pytorch Official documentation](https:\/\/pytorch.org\/tutorials\/advanced\/neural_style_tutorial.html)\n2. [Udacity Pytorch Github](https:\/\/github.com\/udacity\/deep-learning-v2-pytorch\/blob\/master\/style-transfer\/Style_Transfer_Solution.ipynb)\n\n","b048a80d":"### Principle <a class=\"anchor\" id=\"point2\"><\/a>\n\nThe principle concept behind the neural transfer is that we define two distances, one for the content which measures how different the content is between two images and one for the style which measures how different the style is between two images.\n\nThen, we take a third image, the input, and transform it to minimize both its content-distance with the content-image and its style-distance with the style-image.\n\n**Importing Packages**\n\nBelow is a list of the packages needed to implement the neural transfer.\n\n* torch, torch.nn, numpy (indispensables packages for neural networks with PyTorch)\n* torch.optim (efficient gradient descents)\n* PIL, PIL.Image, matplotlib.pyplot (load and display images)\n* torchvision.transforms (transform PIL images into tensors)\n* torchvision.models (train or load pre-trained models)\n* copy (to deep copy the models; system package)"}}