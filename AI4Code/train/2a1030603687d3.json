{"cell_type":{"14b7f925":"code","58f05bba":"code","64c9b041":"code","a4ce55a2":"code","a61f8e49":"code","a74a7acf":"code","284f32f2":"code","b83c4ef1":"code","0a05932b":"code","23eeb673":"code","71b318e1":"code","c2129909":"code","f236765a":"code","a4fd2456":"code","8488443c":"code","4214cda1":"code","b2de61cd":"code","9caa3911":"code","5a7d42e0":"code","5247d1e1":"code","8ee1e8c9":"code","c7a254d9":"code","08932b5b":"code","ab59b05c":"code","59bd6b84":"code","3195e9fc":"code","8efd4544":"code","da8ddb25":"code","2b497832":"code","dadaf0a7":"code","d3d57659":"code","ab80099e":"code","412dbcc8":"code","3bed7023":"code","47179838":"code","5bdb910d":"code","ed8c0029":"code","2313f240":"code","e9c5290f":"code","729b42d7":"code","5a7f351c":"code","c995b572":"code","13a0d427":"code","210138a2":"code","f76759a6":"code","be040643":"code","172eb1d9":"code","b3595693":"code","87597fe6":"code","94c2a2b0":"code","ac1f10fe":"code","38240f2d":"code","c04c8a1d":"code","18beda11":"code","a3a07e79":"code","adaff3c5":"code","d7398f30":"code","6ddfea48":"code","f446b38d":"markdown","c894e8e4":"markdown","8420c782":"markdown","fbb3da2d":"markdown","706b6252":"markdown","ab30a764":"markdown","761fc1ed":"markdown","3781a61e":"markdown","3e4f586d":"markdown","2cb5bcff":"markdown","a65d800d":"markdown","07c2d933":"markdown","6030be9d":"markdown","28393e1b":"markdown","520173c9":"markdown","efd7775a":"markdown","3a2ad110":"markdown","2ccee108":"markdown","34aaf05b":"markdown","abab7a4e":"markdown","2a692cf6":"markdown","7f676abf":"markdown","6523924f":"markdown","a3431fa3":"markdown","9157cd17":"markdown","724e83c1":"markdown","d7cba81c":"markdown","723042e4":"markdown","5c14e0b6":"markdown","f1edffa7":"markdown","eb9488d5":"markdown","51f6f1a3":"markdown","6fcda2e5":"markdown","a3be6027":"markdown"},"source":{"14b7f925":"# importing the necessary modules\nimport nltk\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport string\nfrom sklearn.svm import SVC\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.metrics import classification_report, accuracy_score, log_loss\nimport warnings\nimport re\nwarnings.filterwarnings(\"ignore\")\n%matplotlib inline","58f05bba":"# importing train data\nmbti = pd.read_csv('..\/input\/train.csv')","64c9b041":"mbti.head()","a4ce55a2":"mbti.info()","a61f8e49":"mbti['type'].value_counts().plot(kind='bar')\nplt.show()","a74a7acf":"# M = 1 if extrovert M = 0 if introvert\nmbti['mind'] = mbti['type'].apply(lambda x: 1 if x[0] == 'E' else 0)","284f32f2":"# E = 1 if intuitive(N) E = 0 if observant(S)\nmbti['energy'] = mbti['type'].apply(lambda x: 1 if x[1] == 'N' else 0)","b83c4ef1":"# N = 1 if thinking N = 0 if feeling\nmbti['nature'] = mbti['type'].apply(lambda x: 1 if x[2] == 'T' else 0)","0a05932b":"# T = 1 if judging N = 0 if prospecting\nmbti['tactics'] = mbti['type'].apply(lambda x: 1 if x[3] == 'J' else 0)","23eeb673":"mbti.head()","71b318e1":"# mind category\nlabels = ['Extraversion', 'Introversion']\nsizes = [mbti['mind'].value_counts()[1], mbti['mind'].value_counts()[0]]\n\nfig, ax = plt.subplots(2, 2, figsize=(8, 8))\nax[0, 0].pie(sizes, labels=labels, autopct='%1.1f%%',\n             shadow=False, startangle=90)\nax[0, 0].axis('equal')\n\n# energy category\nlabels = ['Intuitive', 'Observant']\nsizes = [mbti['energy'].value_counts()[1], mbti['energy'].value_counts()[0]]\n\nax[0, 1].pie(sizes, labels=labels, autopct='%1.1f%%',\n             shadow=False, startangle=90)\nax[0, 1].axis('equal')\n\n# nature category\nlabels = ['Thinking', 'Feeling']\nsizes = [mbti['nature'].value_counts()[1], mbti['nature'].value_counts()[0]]\n\nax[1, 0].pie(sizes, labels=labels, autopct='%1.1f%%',\n             shadow=False, startangle=90)\nax[1, 0].axis('equal')\n\n# tactics category\nlabels = ['Judging', 'Prospecting']\nsizes = [mbti['tactics'].value_counts()[1], mbti['tactics'].value_counts()[0]]\n\nax[1, 1].pie(sizes, labels=labels, autopct='%1.1f%%',\n             shadow=False, startangle=90)\nax[1, 1].axis('equal')\nplt.tight_layout()\nplt.show()","c2129909":"# replacing url links with 'url-web'\nfirst_pattern = '[s]?:\/\/(?:[A-Za-z]|[0-9]|[$-_@.&+]|'\nsecond_pattern = '[!*,]|(?:%[0-9A-Fa-f][0-9A-Fa-f]))+'\npattern_url = r'http'+first_pattern+second_pattern\n\nsubs_url = r'url-web'\nmbti['posts'] = mbti['posts'].replace(\n                to_replace=pattern_url, value=subs_url, regex=True)","f236765a":"# replacing numbers with ''\npattern_numbers = r'\\d+'\nsubs_numbers = r''\nmbti['posts'] = mbti['posts'].replace(\n                to_replace=pattern_numbers, value=subs_numbers, regex=True)","a4fd2456":"mbti['posts'] = mbti['posts'].str.lower()","8488443c":"# replacing '|||' with ' '\npattern_lines = r'\\[|]|[|]|[|]+'\nsubs_lines = r' '\nmbti['posts'] = mbti['posts'].replace(to_replace = pattern_lines, value = subs_lines, regex = True)","4214cda1":"def remove_punctuation(post):\n    return ''.join([l for l in post if l not in string.punctuation])","b2de61cd":"mbti['posts'] = mbti['posts'].apply(remove_punctuation)","9caa3911":"mbti.head()","5a7d42e0":"# building our vectorizer\ncount_vec = CountVectorizer(stop_words='english',\n                            lowercase=True,\n                            max_df=0.5,\n                            min_df=2,\n                            max_features=200)","5247d1e1":"# transforming posts to a matrix of token counts\nX_count = count_vec.fit_transform(mbti['posts'])","8ee1e8c9":"X = X_count","c7a254d9":"y_mind = mbti['mind']","08932b5b":"a, b, c, d = train_test_split(X, y_mind, test_size=0.2, random_state=42)\nX_train_mind = a\nX_test_mind = b\ny_train_mind = c\ny_test_mind = d","ab59b05c":"svm = SVC()\nparams = {'C': [1.0, 0.001, 0.01],\n          'gamma': ['auto', 'scale', 1.0, 0.001, 0.01]}\nclf_mind = GridSearchCV(estimator=svm, param_grid=params)\nclf_mind.fit(X_train_mind, y_train_mind)","59bd6b84":"#  gives parameter setting that returned the best results\nclf_mind.best_params_","3195e9fc":"y_pred_mind = clf_mind.predict(X_test_mind)\nprint(\"Accuracy score:\", accuracy_score(y_test_mind, y_pred_mind))","8efd4544":"y_energy = mbti['energy']","da8ddb25":"a, b, c, d = train_test_split(X, y_energy, test_size=0.2, random_state=42)\nX_train_energy = a\nX_test_energy = b\ny_train_energy = c\ny_test_energy = d","2b497832":"svm = SVC()\nparams = {'C': [1.0, 0.001, 0.01],\n          'gamma': ['auto', 'scale', 1.0, 0.001, 0.01]}\nclf_energy = GridSearchCV(estimator=svm, param_grid=params)\nclf_energy.fit(X_train_energy, y_train_energy)","dadaf0a7":"# gives parameter setting that returned the best results\nclf_energy.best_params_","d3d57659":"y_pred_energy = clf_energy.predict(X_test_energy)\nprint(\"Accuracy score:\", accuracy_score(y_test_energy, y_pred_energy))","ab80099e":"y_nature = mbti['nature']","412dbcc8":"a, b, c, d = train_test_split(X, y_nature, test_size=0.2, random_state=42)\nX_train_nature = a\nX_test_nature = b\ny_train_nature = c\ny_test_nature = d","3bed7023":"svm = SVC()\nparams = {'C': [1.0, 0.001, 0.01],\n          'gamma': ['auto', 'scale', 1.0, 0.001, 0.01]}\nclf_nature = GridSearchCV(estimator=svm, param_grid=params)\nclf_nature.fit(X_train_nature, y_train_nature)","47179838":"# gives parameter setting that returned the best results\nclf_nature.best_params_","5bdb910d":"y_pred_nature = clf_nature.predict(X_test_nature)\nprint(\"Accuracy score:\", accuracy_score(y_test_nature, y_pred_nature))","ed8c0029":"y_tactics = mbti['tactics']","2313f240":"a, b, c, d = train_test_split(X, y_tactics, test_size=0.2, random_state=42)\nX_train_tactics = a\nX_test_tactics = b\ny_train_tactics = c\ny_test_tactics = d","e9c5290f":"svm = SVC()\nparams = {'C': [1.0, 0.001, 0.01, 0.1],\n          'gamma': ['auto', 'scale', 1.0, 0.001, 0.01, 0.1]}\nclf_tactics = GridSearchCV(estimator=svm, param_grid=params)\nclf_tactics.fit(X_train_tactics, y_train_tactics)","729b42d7":"# gives parameter setting that returned the best results\nclf_tactics.best_params_","5a7f351c":"y_pred_tactics = clf_tactics.predict(X_test_tactics)\nprint(\"Accuracy score:\", accuracy_score(y_test_tactics, y_pred_tactics))","c995b572":"# importing test data\ntest_mbti = pd.read_csv('..\/input\/test.csv')","13a0d427":"test_mbti.head()","210138a2":"# replacing url links with 'url-web'\nx = pattern_url\ny = subs_url\nz = True\ntest_mbti['posts'] = test_mbti['posts'].replace(to_replace=x, value=y, regex=z)","f76759a6":"# replacing numbers with ''\na = pattern_numbers\nb = subs_numbers\nc = True\ntest_mbti['posts'] = test_mbti['posts'].replace(to_replace=a, value=b, regex=c)","be040643":"test_mbti['posts'] = test_mbti['posts'].str.lower()","172eb1d9":"test_mbti['posts'] = test_mbti['posts'].replace(to_replace = pattern_lines, value = subs_lines, regex = True)","b3595693":"test_mbti['posts'] = test_mbti['posts'].apply(remove_punctuation)","87597fe6":"test_mbti.head()","94c2a2b0":"X_count_test = count_vec.fit_transform(test_mbti['posts'])\nX_test = X_count_test","ac1f10fe":"# mind predictions of the test data\nmind_predictions = clf_mind.predict(X_test)","38240f2d":"# energy predictions of the test data\nenergy_predictions = clf_energy.predict(X_test)","c04c8a1d":"# nature predictions of the test data\nnature_predictions = clf_nature.predict(X_test)","18beda11":"# tactics predictions of the test data\ntactics_predictions = clf_tactics.predict(X_test)","a3a07e79":"# creating a dataframe to be exported to a csv file,\n# containing all the relevant column names.\nlistym = ['id', 'mind', 'energy', 'nature', 'tactics']\nsubmission = pd.DataFrame(columns=listym)","adaff3c5":"submission['id'] = test_mbti['id']","d7398f30":"submission['mind'] = mind_predictions\n\nsubmission['energy'] = energy_predictions\n\nsubmission['nature'] = nature_predictions\n\nsubmission['tactics'] = tactics_predictions","6ddfea48":"# saving submission to csv file\nsubmission.to_csv('submission.csv', index=False)","f446b38d":"## 1.2 Importing the Data and necessary Packages","c894e8e4":"## 3.3 Nature Classifier\nThe _Nature_ category refers to how one makes decisions, either Thinking (T) or Feeling (F).","8420c782":"# MBTI personality profile prediction","fbb3da2d":"#### Remove numbers","706b6252":"#### Remove the web-urls","ab30a764":"#### Building SVM model for nature classifier\nBuilding the classifcation model to predict the _Nature_ category, using a Support Vector Machine model (SVM) as well as the GridSearchCV() model in order to select the best possible parameters.","761fc1ed":"#### Remove '|||' that separates posts","3781a61e":"Let's have a final look at the data after cleaning it up.","3e4f586d":"## 6. Submission\nBringing all our predicted data into a single dataframe, ready for export to .csv for submission.","2cb5bcff":"## 2.3 Vectorizer\nNext we need to build our vectorisor. This will convert our collection of text documents to a matrix of token counts, further allowing us to begin our Natural Language Processing.","a65d800d":"#### Making everything lower case","07c2d933":"# 1. Introduction\n## 1.1 Problem Brief","6030be9d":"## 1.3 Looking at the data\nSome exploratory analysis is always needed when processing new data. After getting an idea of some of the data's features, gaps, traits, we can begin our preprocessing.","28393e1b":"### Transforming posts in test data to a matrix of token counts\nOnce again using a CountVectorisor() to tokenise the data.","520173c9":"In this challenge, we are tasked with building and training a model(s) capable of predicting a person's MBTI label using only what they post in online forums.\n\nTo convert the post data into machine learning format, we are required to use Natural Language Processing. Ultimately, this converted data will be used to train a classifier capable of assigning MBTI labels to a person's online forum posts.\n\nEach MBTI personality type consists of four binary variables, they are: \n- Mind: Introverted (I) or Extraverted (E) \n- Energy: Sensing (S) or Intuitive (N) \n- Nature: Feeling (F) or Thinking (T) \n- Tactics: Perceiving (P) or Judging (J)\n\nWe will need to build and train a model to predict labels for each of the four MBTI variables. For each person, four separate labels are predicted that when combined results in that person's personality type.","efd7775a":"#### Remove punctuation","3a2ad110":"## 5. Predicting the test data labels","2ccee108":"#### Remove '|||' that separates posts","34aaf05b":"# 3. MBTI Categories\nWe need to split our data into the various train and test sets before we can begin our classification model building and training. Here we are separating the different MBTI categories into separate train and test sets, each going to be used in their own classification model.\n## 3.1 Mind Classifier\nThe _Mind_ category refers to where one focuses one's attention, either Extraversion (E) or Introversion (I).","abab7a4e":"### Removing noise\nJust like the train data before, the test data needs to be preprocessed to remove noise (i.e. URLs, punctuation, capital letters, numerical digits) so as to make our predictions as accurate as possible.\n#### Removing the web-urls","2a692cf6":"#### Building SVM model for tactics classifier\nBuilding the classifcation model to predict the _Tactics_ category, using a Support Vector Machine model (SVM) as well as the GridSearchCV optimiser in order to select the best possible parameters.","7f676abf":"## 3.4 Tactics Classifier\nThe _Tactics_ category refers to how one deals with the world, either Judging (J) or Perceiving (P).","6523924f":"#### Remove punctuation","a3431fa3":"#### Remove numbers","9157cd17":"From the information above, we can see that there are no missing values in the 6506 rows and two columns of the dataset.\nLet's have a look at how many of the different MBTI types we have data for.","724e83c1":"#### Building SVM model for energy classifier \nBuilding the classifcation model to predict the _Energy_ category, using a Support Vector Machine model (SVM) as well as the GridSearchCV() model in order to select the best possible parameters.","d7cba81c":"#### Building SVM model for mind classifier\nBuilding the classifcation model to predict the _Mind_ category, using a Support Vector Machine model (SVM) as well as the GridSearchCV() model in order to select the best possible parameters.","723042e4":"#### Making everything lower case","5c14e0b6":"# 2. Train Data Preprocessing\n## 2.1 Encoding categories\nConverting the categories from a single text item into a numerical format for each of the 4 MBTI categories, in order for our model to process the data.","f1edffa7":"## 2.2 Removing noise\nBefore the data can be fit and train to the model, the data needed to be preprocessed to remove noise (i.e. URLs, punctuation, capital letters, numerical digits) so as to make our predictions as accurate as possible. ","eb9488d5":"## 3.2 Energy Classifier\nThe _Energy_ category refers the way one takes in information, either Sensing (S) or INtuition (N).","51f6f1a3":"# 4. Test Data Preprocessing \nNow that the training data has been successfully preprocessed, the test data needs to go through the same processes in order to match the training dataset.","6fcda2e5":"## 7. Conclusion\nWe first tried to predict personality types without breaking them up into the 4 Functions they consist of (Mind, Energy, Nature and Tactics) but we found that approach to be significantly more inaccurate, so we instead decided to break them up and predict each of those 4 functions individually.\n\nInitially we tried using Logistic Regression and Random Forest models for the predictions, but Support Vector Classification models proved to be more accurate.\n\nThe single biggest step we took that managed to significantly improve our Kaggle score was using the GridSearchCV function to find the optimal parameters for our SVC models.","a3be6027":"By creating a pie chart for each of the 4 functions, we can see that there is quite a disparity in representation."}}