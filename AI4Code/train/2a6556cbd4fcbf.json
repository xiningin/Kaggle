{"cell_type":{"c17638c4":"code","7f439bc3":"code","5997ab8e":"code","11f8db89":"code","1b3b662a":"code","0ad0374b":"code","6bf1140d":"code","4fe3ad93":"code","a226b01e":"code","ee8686d4":"code","1d0bc29e":"code","c0d78861":"code","549711b2":"code","65050e7b":"markdown","63fd2c8a":"markdown","06b81e00":"markdown","25e8dfc1":"markdown","f56c3e41":"markdown","35f4539f":"markdown","c47cf5f2":"markdown","0b2be0b6":"markdown","e4934ae7":"markdown","063a2dbd":"markdown","23043251":"markdown","d1a33fb4":"markdown","d1c24fe9":"markdown"},"source":{"c17638c4":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport cv2 # cv2 for reading and processing the images\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# libraries for plotting\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nfrom pylab import *\nimport seaborn as sns\n\nfrom sklearn.model_selection import train_test_split\n# Keras libraries\nfrom keras import layers\nfrom keras import models\nfrom keras import optimizers\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.applications import ResNet50\nfrom keras.utils import to_categorical\nfrom keras.layers import Conv2D,MaxPooling2D,Dense,Flatten,Dropout\nfrom keras.optimizers import Adam\n# other libraries\nimport gc\nimport random\nimport os\n\n# Any results you write to the current directory are saved as output.","7f439bc3":"print(os.listdir(\"..\/input\/cell_images\/cell_images\"))","5997ab8e":"img_height = 112\nimg_width = 112\nimg_channels = 3\nnp_random_seed = 41","11f8db89":"def read_and_process_images(data_dir, image_dims = (56,56), num_of_imgs = None, convert_to_categorical = True):\n    \"\"\"\n    Function to read the images from the given directory and returns Numpy array of X, y and array of labels (names of the directory)\n    \n    The function reads from the given directory, it considers each immidiate sub-directory as a lable\n    \n    Parameters: \n    data_dir (String): Path to the directory\n    image_dims (tuple): Dimensions of the image (length, bredth). \n    num_of_imgs (int): Total number of images to be loaded, if None all the images are loaded. Equal amount of images from each sub-directory are loaded. eg: If input is 30 and there are three subdirectories then 10 images from each directory are loaded\n    convert_to_categorical (boolean): If true then y is converted to one hot vector else a single np array of series of number for each lable starting with 0\n  \n    Returns: \n    int: Description of return value \n  \n    \"\"\"\n    # initialize empty python arrays for X and y\n    X = []\n    y = []\n    \n    num_of_img_per_class = 0\n    labels = [ name for name in os.listdir(data_dir) if os.path.isdir(os.path.join(data_dir, name)) ]\n    if num_of_imgs is not None:\n        num_of_img_per_class = int(round(num_of_imgs\/len(labels)))\n        \n    print('num_of_img_per_class : '+str(num_of_img_per_class if num_of_img_per_class > 0 else 'All' ))\n    \n    lable_count = 0\n    #importing the Parasitized images\n    for label in labels:\n        size = 0\n        print('Importing lable : '+str(label))\n        for imgpath in os.listdir(data_dir+'\/'+label):\n            try:\n                X.append(cv2.resize(cv2.imread(data_dir+'\/'+label+'\/'+imgpath, cv2.IMREAD_COLOR), image_dims, interpolation=cv2.INTER_CUBIC))\n                y.append(lable_count)\n            except BaseException as err:\n                print('Error readding file :\"'+label+'\/'+imgpath+'\", '+str(err))\n            \n            size += 1\n            \n            if num_of_img_per_class == size :\n                break\n        print('Imported lable : '+str(label))\n        lable_count =+ 1\n    \n    # converting the python array into Numpy array\n    X_np = np.array(X)\n    y_temp = np.array(y)\n    \n    # converting the y variables to categorical\n    if(convert_to_categorical) :\n        y_np = to_categorical(y_temp,len(labels))\n        del y_temp\n        gc.collect()\n    else:\n        y_np = y_temp\n    print ('converted to np arrays')\n    \n    # deleting the python arrays as they are no longer required and it would reduce the memory\n    del X\n    del y\n    gc.collect()\n    print ('deleted temp arrays')\n\n    # Normalizing and converting the data into float\n    X_np.astype('float32')\/255.0\n    print ('data normalized')\n\n    return X_np, y_np, labels","1b3b662a":"np.random.seed(np_random_seed)\nX, y, lables = read_and_process_images('..\/input\/cell_images\/cell_images', image_dims=(img_height,img_width))\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1,shuffle = True,stratify = y)\nprint('X_train Shape : '+str(X_train.shape))\nprint('X_test Shape : '+str(X_test.shape))\nprint('y_train Shape : '+str(y_train.shape))\nprint('y_test Shape : '+str(y_test.shape))","0ad0374b":"def show_images(X, y, start_idx = 0,num_imgs = 10, img_per_row = 5):\n    \"\"\"\n    Displays the images from the given data X\n    \n    Parameters: \n    X (numpy.array) : Numpy array of images\n    start_idx(int) : Index from where we start viewing the, make sure that the number doesnot exceed the length of the X_train\n    num_imgs (int) : Total number of images that have to be displayed\n    img_per_row (int) : Number of images that have to be displayed per row\n    \"\"\"\n    num_rows = int(num_imgs\/img_per_row) + 1\n    plt.figure(figsize = (18,4 * num_rows))\n    for i in range(1,num_imgs+1):\n        plt.subplot(num_rows,img_per_row,i)\n        plt.title(str(lables[np.argmax(y[start_idx])]))\n        plt.imshow(X_train[start_idx])\n        start_idx += 1","6bf1140d":"show_images(X_test, y_test,100, 20,6)","4fe3ad93":"base_model = ResNet50(include_top=False, \n                      weights='imagenet', \n                      input_shape=(img_height, img_width, img_channels))\nbase_model.trainable = True #Tells that all the weights are to be trained","a226b01e":"model= models.Sequential()           #Creating the sequntial model\nmodel.add(base_model)                #Adding the imagenet model\nmodel.add(Flatten())                                #\nmodel.add(Dense(512,activation=\"relu\"))             #\nmodel.add(Dropout(0.2))                             #\nmodel.add(Dense(len(lables),activation=\"softmax\"))  #\nmodel.summary()","ee8686d4":"model.compile(loss='categorical_crossentropy', optimizer=Adam(4e-5), metrics=['accuracy'])","1d0bc29e":"his = model.fit(X_train,y_train,batch_size=32, epochs= 5, validation_split=0.2)","c0d78861":"accuracy = model.evaluate(X_test, y_test, verbose=1)\nprint('\\n', 'Test_Accuracy:-', accuracy[1])","549711b2":"train_accs = his.history['acc']\ntrain_losses = his.history['loss']\nval_accs = his.history['val_acc']\nval_losses = his.history['val_loss']\n\nepochs = range(1, len(train_accs)+1)\n\nplt.plot(epochs,train_accs, 'b', label='Train Accuracy')\nplt.plot(epochs,val_accs, 'r', label='Validation Accuracy')\nplt.title('Train and validation accuracy')\nplt.legend()\n\nplt.figure()\n\nplt.plot(epochs,train_losses, 'b', label='Train Loss')\nplt.plot(epochs,val_losses, 'r', label='Validation Loss')\nplt.title('Train and validation loss')\nplt.legend()\n\nplt.show()","65050e7b":"#### Viewing the data directory","63fd2c8a":"Loading the base resnet50 model trained on imagenet data","06b81e00":"#### Viewing images","25e8dfc1":"View how the accurecy and losses changed for every epoch","f56c3e41":"#### Call the above defined function to load the images","35f4539f":"#### Initializing the dimensions of the images","c47cf5f2":"### Import the required libraries","0b2be0b6":"### Detecting the malaria infected cells\nThis is my first attempt to use the transfer learing in Keras. I used ResNet50 with all the layers trainable and acheived 96.22 % accuracy on the test set.\n<br>\n<br>\nThanks to Rising Odegua for this post on Medium. It really helped me<br>\nhttps:\/\/towardsdatascience.com\/transfer-learning-and-image-classification-using-keras-on-kaggle-kernels-c76d3b030649","e4934ae7":"#### Create the model","063a2dbd":"#### Defining a function for reading and processing the images","23043251":"Fit the model","d1a33fb4":"compile the model","d1c24fe9":"Verify the model on test data"}}