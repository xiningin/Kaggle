{"cell_type":{"20af4206":"code","c9f185c0":"code","8783ef7e":"code","d21421b4":"code","c5f1124a":"code","532aa22c":"code","5f02f7f7":"code","61fa324c":"code","ed1b5389":"code","9d885347":"code","b836dab5":"code","80c05632":"code","2dab6e5f":"code","6b11ed84":"code","cb733bb8":"code","94e453da":"code","4f8ae0a2":"code","eab60402":"code","034cbe55":"code","28526c3f":"code","660938ad":"code","22a4ffc6":"code","5757110f":"code","966914c1":"code","13e4024e":"code","2a52ce3f":"code","862eea06":"code","ade8bcff":"code","3b785645":"code","af380414":"code","53072b9f":"code","32422758":"code","885d0958":"code","e92f50ab":"code","e8067876":"code","1f0fce04":"code","66711183":"markdown","26107b29":"markdown","f81ff970":"markdown","f53cd387":"markdown","963248c1":"markdown","8e8d9be5":"markdown","7647f790":"markdown","966ed0a1":"markdown","8f550262":"markdown","876b0f87":"markdown","5363786e":"markdown","a2357fc4":"markdown","accd3498":"markdown","dc83a6e9":"markdown","cd89f1b5":"markdown","12545963":"markdown","135432ab":"markdown","e17456d0":"markdown","47b6dd0a":"markdown","0ecdf9d8":"markdown","4b255552":"markdown","fe80c1ec":"markdown","a66d0d0a":"markdown","3771e3a7":"markdown","ab0042a0":"markdown","89652489":"markdown","e365d3ed":"markdown","98de2d72":"markdown","12b7c23f":"markdown","c06ff6d4":"markdown","e41a6a32":"markdown","15b9450a":"markdown","635dad9c":"markdown","3686eca1":"markdown","97f7106a":"markdown","e3e63ecd":"markdown","a4fe1396":"markdown","b0f4a538":"markdown"},"source":{"20af4206":"import warnings\nfrom sklearn.metrics import mean_squared_error\nfrom math import sqrt\nfrom math import log\nfrom math import exp\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nfrom matplotlib import pyplot\n\nfrom pandas import DataFrame\nfrom pandas import Grouper\n\nfrom statsmodels.tsa.stattools import adfuller\nfrom statsmodels.tsa.arima_model import ARIMA\nfrom statsmodels.graphics.tsaplots import plot_acf\nfrom statsmodels.graphics.tsaplots import plot_pacf\n\nfrom scipy.stats import boxcox\nfrom statsmodels.graphics.gofplots import qqplot\n\nfrom statsmodels.tsa.arima_model import ARIMAResults","c9f185c0":"series = pd.read_csv(\"..\/input\/monthly-armed-robberies-in-boston\/Robberies.csv\",\n                     header=0, index_col=0, parse_dates=True, squeeze=True)","8783ef7e":"series ","d21421b4":"split_point = len(series) - 12\ndataset, validation = series[0:split_point], series[split_point:]\nprint('Dataset %d, Validation %d' % (len(dataset), len(validation)))\ndataset.to_csv('dataset.csv', header=False)\nvalidation.to_csv('validation.csv', header=False)","c5f1124a":"X = series.values\nX = X.astype('float32')\ntrain_size = int(len(X) * 0.50)\ntrain, test = X[0:train_size], X[train_size:]","532aa22c":"# walk-forward validation\nhistory = [x for x in train]\npredictions = list()\n\nfor i in range(len(test)):\n    # predict\n    yhat = history[-1]\n    predictions.append(yhat)\n    # observation\n    obs = test[i]\n    history.append(obs)\n    print('>Predicted=%.3f, Expected=%.3f' % (yhat, obs))","5f02f7f7":"rmse = sqrt(mean_squared_error(test, predictions)) \nprint('RMSE: %.3f' % rmse)","61fa324c":"print(series.describe())","ed1b5389":"series = dataset\n\nseries.plot()\npyplot.show()","9d885347":"pyplot.figure(1)\npyplot.subplot(211)\nseries.hist()\n\npyplot.subplot(212)\nseries.plot(kind='kde')\npyplot.show()","b836dab5":"print(series)\ngroups = series['1966':'1973'].groupby(Grouper(freq='A')) \nyears = DataFrame()\nfor name, group in groups:\n    years[name.year] = group.values\nyears.boxplot()\npyplot.show()","80c05632":"def difference(dataset):\n    diff = list()\n    for i in range(1, len(dataset)):\n        value = dataset[i] - dataset[i - 1]\n        diff.append(value)\n    return pd.Series(diff)","2dab6e5f":"series = dataset\n\nX = series.values\n\n# difference data\nstationary = difference(X)\nstationary.index = series.index[1:]\n\n# check if stationary\nresult = adfuller(stationary) \nprint('ADF Statistic: %f' % result[0]) \nprint('p-value: %f' % result[1]) \nprint('Critical Values:')\nfor key, value in result[4].items():\n    print('\\t%s: %.3f' % (key, value)) # save\n\nstationary.to_csv('stationary.csv', header=False)","6b11ed84":"#series = read_csv('dataset.csv', header=None, index_col=0, parse_dates=True, squeeze=True) pyplot.figure()\n\nseries = dataset\npyplot.subplot(211)\nplot_acf(series, lags=50, ax=pyplot.gca())\npyplot.subplot(212)\nplot_pacf(series, lags=50, ax=pyplot.gca())\npyplot.show()","cb733bb8":"# load data\n#series = read_csv('dataset.csv', header=None, index_col=0, parse_dates=True, squeeze=True) # prepare data\nX = series.values\nX = X.astype('float32')\ntrain_size = int(len(X) * 0.50)\ntrain, test = X[0:train_size], X[train_size:]\n\n# walk-forward validation\nhistory = [x for x in train]\npredictions = list()\n\nfor i in range(len(test)):\n    # predict\n    model = ARIMA(history, order=(0,1,2))\n    model_fit = model.fit(disp=0)\n    yhat = model_fit.forecast()[0]\n    predictions.append(yhat)\n    # observation\n    obs = test[i]\n    history.append(obs)\n    print('>Predicted=%.3f, Expected=%.3f' % (yhat, obs))","94e453da":"rmse = sqrt(mean_squared_error(test, predictions))\nprint('RMSE: %.3f' % rmse)","4f8ae0a2":"def evaluate_arima_model(X, arima_order): # prepare training dataset\n    X = X.astype('float32')\n    train_size = int(len(X) * 0.50)\n    train, test = X[0:train_size], X[train_size:]\n    history = [x for x in train]\n    # make predictions\n    predictions = list()\n    \n    for t in range(len(test)):\n        model = ARIMA(history, order=arima_order)\n        model_fit = model.fit(disp=0)\n        yhat = model_fit.forecast()[0]\n        predictions.append(yhat)\n        history.append(test[t])\n    \n    # calculate out of sample error\n    rmse = sqrt(mean_squared_error(test, predictions))\n    return rmse","eab60402":"def evaluate_models(dataset, p_values, d_values, q_values):\n    dataset = dataset.astype(\"float32\")\n    best_score, best_cfg = float(\"inf\"), None\n    for p in p_values:\n        for d in d_values:\n            for q in q_values:\n                order = (p, d, q)\n                try:\n                    rmse = evaluate_arima_model(dataset, order)\n                    if rmse < best_score:\n                        best_score, best_cfg = rmse, order\n                    print(\"ARIMA%s RMSE=%.3f\" % (order, rmse))\n                except:\n                    continue\n    print(\"Best ARIMA%s RMSE=%.3f\" % (best_cfg, best_score))","034cbe55":"%%time\n# series = read_csv('dataset.csv', header=None, index_col=0, parse_dates=True, squeeze=True) # evaluate parameters\nseries = dataset\np_values = range(0,13)\nd_values = range(0, 4)\nq_values = range(0, 13)\nwarnings.filterwarnings(\"ignore\")\n#evaluate_models(series.values, p_values, d_values, q_values)","28526c3f":"# series = read_csv('dataset.csv', header=None, index_col=0, parse_dates=True, squeeze=True) # prepare data\nseries = dataset\nX = series.values\nX = X.astype('float32')\ntrain_size = int(len(X) * 0.50)\ntrain, test = X[0:train_size], X[train_size:]\n\n# walk-forward validation\nhistory = [x for x in train]\npredictions = list()\n\nfor i in range(len(test)):\n    # predict\n    model = ARIMA(history, order=(0,1,2))\n    model_fit = model.fit(disp=0)\n    yhat = model_fit.forecast()[0]\n    predictions.append(yhat)\n    # observation\n    obs = test[i]\n    history.append(obs)\n\n# errors\nresiduals = [test[i]-predictions[i] for i in range(len(test))]\nresiduals = DataFrame(residuals)","660938ad":"pyplot.figure()\npyplot.subplot(211)\nresiduals.hist(ax=pyplot.gca())\npyplot.subplot(212)\nresiduals.plot(kind='kde', ax=pyplot.gca())\npyplot.show()","22a4ffc6":"# from statsmodels.tsa.arima_model import ARIMA\n# from statsmodels.graphics.tsaplots import plot_acf\n# from statsmodels.graphics.tsaplots import plot_pacf\n\n# load data\n# series = read_csv('dataset.csv', header=None, index_col=0, parse_dates=True, squeeze=True) # prepare data\n\nseries = dataset\nX = series.values\nX = X.astype('float32')\ntrain_size = int(len(X) * 0.50)\ntrain, test = X[0:train_size], X[train_size:]\n# walk-forward validation\nhistory = [x for x in train]\npredictions = list()\n\nfor i in range(len(test)):\n    # predict\n    model = ARIMA(history, order=(0,1,2))\n    model_fit = model.fit(disp=0)\n    yhat = model_fit.forecast()[0]\n    predictions.append(yhat)\n\n    # observation\n    obs = test[i]\n    history.append(obs)\n\n# errors\nresiduals = [test[i]-predictions[i] for i in range(len(test))]\nresiduals = DataFrame(residuals)\npyplot.figure()\npyplot.subplot(211)\nplot_acf(residuals, lags=25, ax=pyplot.gca())\npyplot.subplot(212)\nplot_pacf(residuals, lags=25, ax=pyplot.gca())\npyplot.show()","5757110f":"# from scipy.stats import boxcox\n# from statsmodels.graphics.gofplots import qqplot","966914c1":"# series = read_csv('dataset.csv', header=None, index_col=0, parse_dates=True, squeeze=True) X = series.values\nseries = dataset\ntransformed, lam = boxcox(X)\nprint('Lambda: %f' % lam)\npyplot.figure(1)\n","13e4024e":"pyplot.subplot(311)\npyplot.plot(transformed)","2a52ce3f":"pyplot.subplot(312)\npyplot.hist(transformed)","862eea06":"pyplot.subplot(313)\nqqplot(transformed, line='r', ax=pyplot.gca())\npyplot.show()","ade8bcff":"def boxcox_inverse(value, lam):\n    if lam == 0:\n        return exp(value)\n    return exp(log(lam * value + 1) \/ lam)    ","3b785645":"# load data\n# series = read_csv('dataset.csv', header=None, index_col=0, parse_dates=True, squeeze=True) # prepare data\nseries = dataset\nX = series.values\nX = X.astype('float32')\ntrain_size = int(len(X) * 0.50)\n\ntrain, test = X[0:train_size], X[train_size:]\n\n# walk-forward validation\nhistory = [x for x in train]\npredictions = list()\n\nfor i in range(len(test)):\n    # transform\n    transformed, lam = boxcox(history)\n    if lam < -5:\n        transformed, lam = history, 1\n\n    # predict\n    model = ARIMA(transformed, order=(0,1,2))\n    model_fit = model.fit(disp=0)\n    yhat = model_fit.forecast()[0]\n\n    # invert transformed prediction\n    yhat = boxcox_inverse(yhat, lam)\n    predictions.append(yhat)\n    # observation\n    obs = test[i]\n    history.append(obs)\n    print('>Predicted=%.3f, Expected=%.3f' % (yhat, obs))\n","af380414":"rmse = sqrt(mean_squared_error(test, predictions))\nprint('RMSE: %.3f' % rmse)","53072b9f":"# from pandas import read_csv\n# from statsmodels.tsa.arima_model import ARIMA\n# from scipy.stats import boxcox\n# import numpy\n\n# monkey patch around bug in ARIMA class\ndef __getnewargs__(self):\n    return ((self.endog),(self.k_lags, self.k_diff, self.k_ma))\n\nARIMA.__getnewargs__ = __getnewargs__\n\n# load data\n\n# series = read_csv('dataset.csv', header=None, index_col=0, parse_dates=True, squeeze=True)\nseries = dataset\n# prepare data\n\nX = series.values\nX = X.astype('float32')\n\n\n# transform data\ntransformed, lam = boxcox(X)","32422758":"model = ARIMA(transformed, order=(0,1,2))\nmodel_fit = model.fit(disp=0)","885d0958":"model_fit.save('model.pkl') \nnp.save('model_lambda.npy', [lam])","e92f50ab":"# invert box-cox transform\ndef boxcox_inverse(value, lam):\n    if lam == 0:\n        return exp(value)\n    return exp(log(lam * value + 1) \/ lam)\n\nmodel_fit = ARIMAResults.load('model.pkl')\nlam = np.load('model_lambda.npy')\nyhat = model_fit.forecast()[0]\n\nyhat = boxcox_inverse(yhat, lam)\nprint('Predicted: %.3f' % yhat)","e8067876":"# from statsmodels.tsa.arima_model import ARIMA\n# from statsmodels.tsa.arima_model import ARIMAResults\n# from scipy.stats import boxcox\n# from sklearn.metrics import mean_squared_error\n# from math import sqrt\n# from math import exp\n# from math import log\n# import numpy\n\n# invert box-cox transform\ndef boxcox_inverse(value, lam):\n    if lam == 0:\n        return exp(value)\n    return exp(log(lam * value + 1) \/ lam)\n\n# load and prepare datasets\n# dataset = read_csv('dataset.csv', header=None, index_col=0, parse_dates=True, squeeze=True)\n\nX = dataset.values.astype('float32')\nhistory = [x for x in X]\n\n#validation = read_csv('validation.csv', header=None, index_col=0, parse_dates=True,squeeze=True)\ny = validation.values.astype('float32')\n\n# load model\nmodel_fit = ARIMAResults.load('model.pkl')\nlam = np.load('model_lambda.npy')\n\n# make first prediction\npredictions = list()\nyhat = model_fit.forecast()[0]\nyhat = boxcox_inverse(yhat, lam)\npredictions.append(yhat)\nhistory.append(y[0])\nprint('>Predicted=%.3f, Expected=%.3f' % (yhat, y[0])) \n\n# rolling forecasts\n\nfor i in range(1, len(y)):\n    # transform\n    transformed, lam = boxcox(history)\n    if lam < -5:\n        transformed, lam = history, 1\n\n    # predict\n    model = ARIMA(transformed, order=(0,1,2))\n    model_fit = model.fit(disp=0)\n    yhat = model_fit.forecast()[0]\n  \n    # invert transformed prediction\n    yhat = boxcox_inverse(yhat, lam)\n    predictions.append(yhat)\n\n    # observation\n    obs = y[i]\n    history.append(obs)\n    print('>Predicted=%.3f, Expected=%.3f' % (yhat, obs))","1f0fce04":"rmse = sqrt(mean_squared_error(y, predictions)) \nprint('RMSE: %.3f' % rmse)\n\npyplot.plot(y)\npyplot.plot(predictions, color='red')\npyplot.show()","66711183":"# 30.5.2 Line Plot \np262","26107b29":"# References\n\n- https:\/\/www.kaggle.com\/sujan97\/forecasting-monthly-robberies\n- https:\/\/www.kaggle.com\/noelmat\/univariate-analysis-of-armed-robberies-in-boston\n","f81ff970":"# Density Plot","f53cd387":"# Box-Cox Transformed Dataset\n\np275\n","963248c1":"# Load Data","8e8d9be5":"# Line Plot","7647f790":"## Evaluate an ARIMA model for a given order (p,d,q) and return RMSE\n","966ed0a1":"# Grid Search ARIMA Hyperparameters\n\np270","8f550262":"# 30.5.1 Summary Statistics","876b0f87":"# Evaluate\n\n## This takes a while","5363786e":"# ARIMA Model","a2357fc4":"# Evaluate the finalized model on the validation dataset","accd3498":"## Finalize Model\n\np280","dc83a6e9":"# Make Prediction\n\np281","cd89f1b5":"# Fit Model","12545963":"# q-q plot","135432ab":"# Histogram","e17456d0":"# ACF and PACF plots of time series","47b6dd0a":"# Evaluate combinations of p, d and q values for an ARIMA model","0ecdf9d8":"# Save Model","4b255552":"## Report Performance","fe80c1ec":"# Plot Residuals","a66d0d0a":"# Evaluate a persistence model","3771e3a7":"# Evaluate manually configured ARIMA model","ab0042a0":"# Walk-forward validation","89652489":"# Box and Whisker Plots","e365d3ed":"# Split Train\/Validation","98de2d72":"## Report Performance","12b7c23f":"# Model Validation","c06ff6d4":"# Review Residual Errors\n\np272","e41a6a32":"# ACF and PACF plots of forecast residual errors","15b9450a":"# Invert Box-Cox transform","635dad9c":"## Report Performance","3686eca1":"# Prepare Data","97f7106a":"# Manually Configured ARIMA\n\np267","e3e63ecd":"## Report Performance","a4fe1396":"# Create a differenced time series","b0f4a538":"# Load Libraries"}}