{"cell_type":{"513261cc":"code","3e434642":"code","9cd3a65b":"code","3ad3476f":"code","ea1e0868":"code","9c4a14ea":"code","7d2bf569":"code","ccb48bbd":"code","8bb5db71":"code","6cef59e2":"code","67c0297f":"code","4639bff7":"code","a0b339c3":"code","ff914d0c":"code","d604ef72":"code","2de238e0":"code","bda88622":"code","0bd57e69":"code","1e21a674":"code","0a0f5d3d":"code","6e21bc2c":"code","9bc49971":"code","78f51bee":"code","9ac4fff2":"code","8f49db23":"code","8a23a717":"code","0dc65fe4":"code","7aae1801":"code","82897960":"code","1375219b":"code","6eedd02a":"code","588ce26c":"code","46523b66":"code","61461666":"code","06d9e7ee":"code","27d384a2":"code","a2cfb988":"code","efc59783":"code","0a3bd439":"code","445f392d":"code","a7ba8b04":"markdown","221fb628":"markdown","5baa761d":"markdown","78268c4a":"markdown","9d8ff3fa":"markdown","5016ac94":"markdown","d0c44c8c":"markdown"},"source":{"513261cc":"import warnings\nwarnings.filterwarnings('ignore')","3e434642":"import os\nprint(os.listdir(\"..\/input\"))","9cd3a65b":"import numpy as np\nimport pandas as pd\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nfrom collections import Counter","3ad3476f":"data = pd.read_csv('..\/input\/sign_mnist_train.csv')\nprint('Dataframe Shape:', data.shape)","ea1e0868":"data.head()","9c4a14ea":"x = data.iloc[:, 1:].values\nprint(\"Number of images:\", x.shape[0])\nprint(\"Number of pixels in each image:\", x.shape[1])","7d2bf569":"y = data.iloc[:, :1].values.flatten()\nprint('Labels:\\n', y)\nprint('Shape of Labels:', y.shape)","ccb48bbd":"def next_batch(batch_size, data, labels):\n    idx = np.arange(0, len(data))\n    np.random.shuffle(idx)\n    idx = idx[: batch_size]\n    data_shuffle = [data[i] for i in idx]\n    labels_shuffle = [labels[i] for i in idx]\n    return np.asarray(data_shuffle), np.asarray(labels_shuffle)","8bb5db71":"def display_images(data):\n    x, y = data\n    fig, axes = plt.subplots(3, 3)\n    fig.subplots_adjust(hspace = 0.5, wspace = 0.5)\n    for i, ax in enumerate(axes.flat):\n        ax.imshow(x[i].reshape(28, 28), cmap = 'binary')\n        ax.set_xlabel(chr(y[i] + 65))\n        ax.set_xticks([])\n        ax.set_yticks([])\n    plt.show()","6cef59e2":"display_images(next_batch(9, x, y))","67c0297f":"z = dict(Counter(list(y)))\nlabels = z.keys()\nfrequencies = [z[i] for i in labels]\nlabels = [chr(i + 65) for i in z.keys()]\n\nplt.figure(figsize = (20, 10))\nplt.bar(labels, frequencies)\nplt.title('Frequency Distribution of Alphabets', fontsize = 20)\nplt.show()","4639bff7":"def one_hot_encode(y):\n    return np.eye(25)[y]\ny_encoded = one_hot_encode(y)\nprint('Shape of y after encoding:', y_encoded.shape)","a0b339c3":"# Training Parameters\nlearning_rate = 0.001\nepochs = 2000\nbatch_size = 128\ndisplay_step = 100","ff914d0c":"# Neural Network Hyperparameters\nn_input = 784\nn_classes = 25\ndropout = 0.75","d604ef72":"# Placeholders\nX = tf.placeholder(tf.float32, shape = [None, n_input]) # Placeholder for Feature Matrix\nY = tf.placeholder(tf.float32, shape = [None, n_classes]) # Placeholder for Labels\nkeep_prob = tf.placeholder(tf.float32) # Placeholder for Dropout Rate","2de238e0":"weights = {\n    # Weight for Convolutional Layer 1: 5x5 filter, 1 input channel, 32 output channels\n    'w1' : tf.Variable(tf.random_normal([5, 5, 1, 32])),\n    # Weight for Convolutional Layer 2: 5x5 filter, 32 input channels, 64 output channels\n    'w2' : tf.Variable(tf.random_normal([5, 5, 32, 64])),\n    # Weight for Fully Connected Layer 1: 49 * 64 input channels, 1024 output channels\n    'w3' : tf.Variable(tf.random_normal([7 * 7 * 64, 1024])),\n    # Weight for Convolutional Layer 1: 1024 input channels, 25(number of classes) output channels\n    'w4' : tf.Variable(tf.random_normal([1024, n_classes]))\n}","bda88622":"biases = {\n    # Bias for Convolutional Layer 1\n    'b1' : tf.Variable(tf.random_normal([32])),\n    # Bias for Convolutional Layer 2\n    'b2' : tf.Variable(tf.random_normal([64])),\n    # Bias for Fully Connected Layer 1\n    'b3' : tf.Variable(tf.random_normal([1024])),\n    # Bias for Outout Layer\n    'b4' : tf.Variable(tf.random_normal([n_classes]))\n}","0bd57e69":"# Wrapper function for creating a Convolutional Layer\ndef conv2d(x, W, b, strides = 1):\n    x = tf.nn.conv2d(x, W, strides = [1, strides, strides, 1], padding='SAME')\n    x = tf.nn.bias_add(x, b)\n    return tf.nn.relu(x)","1e21a674":"# Wrapper function for creating a Pooling Layer\ndef maxpool2d(x, k=2):\n    return tf.nn.max_pool(x, ksize = [1, k, k, 1], strides = [1, k, k, 1], padding = 'SAME')","0a0f5d3d":"def neural_network(x, weight, bias, dropout):\n    x = tf.reshape(x, shape = [-1, 28, 28, 1])\n    \n    conv1 = conv2d(x, weight['w1'], bias['b1']) # Convolutional Layer 1\n    conv1 = maxpool2d(conv1) # Pooling Layer 1\n    \n    conv2 = conv2d(conv1, weight['w2'], bias['b2']) # Convolutional Layer 1\n    conv2 = maxpool2d(conv2) # Pooling Layer 1\n    \n    # Fully Connected Layer 1\n    # Reshaping output of previous convolutional layer to fit the fully connected layer\n    fc = tf.reshape(conv2, [-1, weights['w3'].get_shape().as_list()[0]])\n    fc = tf.add(tf.matmul(fc, weight['w3']), bias['b3']) # Linear Function\n    fc = tf.nn.relu(fc) # Activation Function\n    \n    fc = tf.nn.dropout(fc, dropout) # Applying dropout on Fully Connected Layer\n    \n    out = tf.add(tf.matmul(fc, weight['w4']), bias['b4']) # Output Layer\n    return out","6e21bc2c":"logits = neural_network(X, weights, biases, keep_prob)","9bc49971":"loss_op = tf.nn.softmax_cross_entropy_with_logits_v2(logits = logits, labels = Y)\noptimizer = tf.train.AdamOptimizer(learning_rate = learning_rate)\ntrain_op = optimizer.minimize(loss_op)","78f51bee":"correct_pred = tf.equal(tf.argmax(logits, 1), tf.argmax(Y, 1))\naccuracy = tf.reduce_mean(tf.cast(correct_pred, tf.float32))","9ac4fff2":"init = tf.global_variables_initializer()","8f49db23":"# Splitting the dataset into Training and Holdout(Test set)\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(x, y_encoded, test_size = 0.33, random_state = 42)\nprint('X train shape', X_train.shape)\nprint('y train shape', y_train.shape)\nprint('X test shape', X_test.shape)\nprint('y test shape', y_test.shape)","8a23a717":"with tf.Session() as sess:\n    # Running Initializer\n    sess.run(init)\n    cost_hist, acc_hist = [], []\n    for epoch in range(1, epochs + 1):\n        _x, _y = next_batch(batch_size, X_train, y_train)\n        # Running Optimizer\n        sess.run(train_op, feed_dict = { X : _x, Y : _y, keep_prob : dropout })\n        if epoch % display_step == 0:\n            # Calculating Loss and Accuracy on the current Epoch\n            loss, acc = sess.run([loss_op, accuracy], feed_dict = { X : _x, Y : _y, keep_prob : 1.0 })\n            loss = sum(loss)\n            cost_hist.append(loss)\n            acc_hist.append(acc)\n            print('Epoch ' + str(epoch) + ', Cost: ' + str(loss) + ', Accuracy: ' + str(acc * 100) + ' %')\n    print('-' * 50)\n    print('\\nOptimization Finished\\n')\n    print('Accuracy on Training Data: ' + str(sess.run(accuracy,\n                                                       feed_dict = {\n                                                           X : X_train,\n                                                           Y : y_train,\n                                                           keep_prob : 1.0\n                                                       }) * 100) + ' %')\n    print('Accuracy on Test Data: ' + str(sess.run(accuracy,\n                                                   feed_dict = {\n                                                       X : X_test,\n                                                       Y : y_test,\n                                                       keep_prob : 1.0\n                                                   }) * 100) + ' %')","0dc65fe4":"plt.plot(list(range(len(cost_hist))), cost_hist)\nplt.title(\"Change in cost\")\nplt.show()","7aae1801":"plt.plot(list(range(len(acc_hist))), acc_hist)\nplt.title(\"Change in accuracy\")\nplt.show()","82897960":"print('Training on the whole dataset....\\n')\nwith tf.Session() as sess:\n    sess.run(init) # Running Initializer\n    cost_hist, acc_hist = [], []\n    for epoch in range(1, epochs + 1):\n        _x, _y = next_batch(batch_size, x, y_encoded)\n        # Running Optimizer\n        sess.run(train_op,\n                 feed_dict = {\n                     X : _x,\n                     Y : _y,\n                     keep_prob : dropout\n                 })\n        if epoch % display_step == 0:\n            # Calculating Loss and Accuracy on the current Epoch\n            loss, acc = sess.run([loss_op, accuracy],\n                                 feed_dict = {\n                                     X : _x,\n                                     Y : _y,\n                                     keep_prob : 1.0\n                                 })\n            loss = sum(loss)\n            cost_hist.append(loss)\n            acc_hist.append(acc)\n            print('Epoch ' + str(epoch) + ', Cost: ' + str(loss) + ', Accuracy: ' + str(acc * 100) + ' %')\n    print('-' * 50)\n    print('\\nOptimization Finished\\n')\n    print('Accuracy after training on whole dataset Data: ' + str(sess.run(accuracy,\n                                                       feed_dict = {\n                                                           X : x,\n                                                           Y : y_encoded,\n                                                           keep_prob : 1.0\n                                                       }) * 100) + ' %')\n    W = sess.run(weights)\n    B = sess.run(biases)","1375219b":"plt.plot(list(range(len(cost_hist))), cost_hist)\nplt.title(\"Change in cost\")\nplt.show()","6eedd02a":"plt.plot(list(range(len(acc_hist))), acc_hist)\nplt.title(\"Change in accuracy\")\nplt.show()","588ce26c":"data_test = pd.read_csv('..\/input\/sign_mnist_test.csv')\nprint('Dataframe Shape:', data_test.shape)","46523b66":"data_test.head()","61461666":"x_test = data_test.iloc[:, 1:].values\ny_test = data_test.iloc[:, :1].values.flatten()\ny_test = one_hot_encode(y_test)\nx_test.shape, y_test.shape","06d9e7ee":"X = tf.placeholder(tf.float32, shape = [None, n_input]) # Placeholder for Feature Matrix\nY = tf.placeholder(tf.float32, shape = [None, n_classes]) # Placeholder for Labels\nkeep_prob = tf.placeholder(tf.float32) # Placeholder for Dropout Rate","27d384a2":"y_pred = neural_network(X, W, B, 1.0)","a2cfb988":"def get_prediction(img):\n    with tf.Session() as sess:\n        pred = sess.run(y_pred, feed_dict = { X : img, keep_prob : 1.0 })\n    img = img.reshape(28, 28)\n    pred = list(pred.flatten())\n    pred = chr(pred.index(max(pred)) + 65)\n    return (img, pred)","efc59783":"image, pred = get_prediction(x_test[1].reshape(1, 784))\nplt.imshow(image, cmap = 'binary')\nplt.title(pred)\nplt.show()","0a3bd439":"for key in W.keys():\n    np.save(key, W[key])","445f392d":"for key in B.keys():\n    np.save(key, B[key])","a7ba8b04":"## Building the Convolutional Neural Network","221fb628":"## Importing Necessary Libraries","5baa761d":"## Saving Parameters","78268c4a":"## Training the Neural Network on the whole dataset to get the Optimized Weights and Biases","9d8ff3fa":"## Training the Neural Network","5016ac94":"## Predicting the Model on Test Data","d0c44c8c":"## Exploratory Analysis of Training Data"}}