{"cell_type":{"196fb4df":"code","c0f27092":"code","1c07c5b5":"code","30c94d1e":"code","a8bb1d89":"code","c33f48cd":"code","78e3961f":"code","916d5940":"code","3a04ea59":"code","e0cb4a47":"code","77e55790":"code","8a670916":"code","643939b5":"code","a03b49f3":"code","5c040a3f":"code","18481692":"markdown","3ded3cad":"markdown","41a2f538":"markdown","dad534e3":"markdown","2959954a":"markdown","77aa3b76":"markdown","81bbf4eb":"markdown","8c12b780":"markdown","8a457193":"markdown","c0ca85b0":"markdown","965e1c52":"markdown","4610ed07":"markdown","74697015":"markdown","a92c9411":"markdown","4a0d1235":"markdown","0352d1e2":"markdown"},"source":{"196fb4df":"import warnings\nwarnings.filterwarnings('ignore')\n\nimport torch \ndevice = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')\nprint(device)\n\nimport os, gc, random\nif device == 'cuda':\n    import cudf\n    import cupy as cp\nimport datatable as dtable\nimport pandas as pd\nimport numpy as np\nimport janestreet\nfrom numba import njit\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\nfrom joblib import dump, load","c0f27092":"def seed_everything(seed_value):\n    random.seed(seed_value)\n    np.random.seed(seed_value)\n    torch.manual_seed(seed_value)\n    os.environ['PYTHONHASHSEED'] = str(seed_value)\n    \n    if torch.cuda.is_available(): \n        torch.cuda.manual_seed(seed_value)\n        torch.cuda.manual_seed_all(seed_value)\n        torch.backends.cudnn.deterministic = True\n        torch.backends.cudnn.benchmark = False\n        \nseed_everything(42)","1c07c5b5":"test = pd.read_csv('..\/input\/jane-street-market-prediction\/example_test.csv')\nfeatures = [c for c in test.columns if 'feature' in c]\ntest = test[features].values\nf_mean = np.load('..\/input\/js-nn-models\/f_mean.npy')","30c94d1e":"# https:\/\/www.kaggle.com\/markmipt\/jane-street-how-to-deal-with-timeout-error\ndef fillna_minus_plus(array, values):\n    array -= values\n    array = np.nan_to_num(array)\n    array += values\n    return array\n\ndef fillna_vectorised(array, values):\n    array = np.nan_to_num(array) + np.isnan(array) * values\n    return array","a8bb1d89":"def fillna_minus_plus_with_check(array, values):\n    if np.isnan(array.sum()):\n        array -= values\n        array = np.nan_to_num(array)\n        array += values\n    return array\n\ndef fillna_vectorised_with_check(array, values):\n    if np.isnan(array.sum()):\n        array = np.nan_to_num(array) + np.isnan(array) * values\n    return array","c33f48cd":"def fillna_npwhere(array, values):\n    if np.isnan(array.sum()):\n        array = np.where(np.isnan(array), values, array)\n    return array\n\n@njit\ndef fillna_npwhere_njit(array, values):\n    if np.isnan(array.sum()):\n        array = np.where(np.isnan(array), values, array)\n    return array","78e3961f":"def for_loop(method, matrix, values):\n    for i in range(matrix.shape[0]):\n        matrix[i] = method(matrix[i], values)\n    return matrix","916d5940":"print('fillna_minus_plus:')\n%timeit for_loop(fillna_minus_plus, test[:, 1:], f_mean)\nprint('-' * 65)\n\nprint('fillna_vectorised:')\n%timeit for_loop(fillna_vectorised, test[:, 1:], f_mean)\nprint('-' * 65)\n\nprint('fillna_minus_plus_with_check:')\n%timeit for_loop(fillna_minus_plus_with_check, test[:, 1:], f_mean)\nprint('-' * 65)\n\nprint('fillna_vectorised_with_check:')\n%timeit for_loop(fillna_vectorised_with_check, test[:, 1:], f_mean)\nprint('-' * 65)\n\nprint('fillna_npwhere:')\n%timeit for_loop(fillna_npwhere, test[:, 1:], f_mean)\nprint('-' * 65)\n\nprint('fillna_npwhere_njit:')\n%timeit for_loop(fillna_npwhere_njit, test[:, 1:], f_mean)","3a04ea59":"test = pd.read_csv('..\/input\/jane-street-market-prediction\/example_test.csv', usecols = features[1:])\nf_mean_dict = dict(zip(features[1:], f_mean))","e0cb4a47":"def pandas_fillna(df, values):\n    return df.fillna(values)\n\ndef for_loop_pandas(method, df, values):\n    for i in range(df.shape[0]):\n        df.loc[i] = method(df.loc[i], values)\n    return df","77e55790":"print('pandas fillna:')\n%timeit for_loop_pandas(pandas_fillna, test, f_mean_dict)","8a670916":"def for_loop_ffill(method, matrix):\n    tmp = np.zeros(matrix.shape[1])\n    for i in range(matrix.shape[0]):\n        matrix[i] = method(matrix[i], tmp)\n        tmp = matrix[i]\n    return matrix","643939b5":"test = pd.read_csv('..\/input\/jane-street-market-prediction\/example_test.csv')\ntest = test[features].values","a03b49f3":"print('fillna_npwhere_njit (mean-filling):')\n%timeit for_loop(fillna_npwhere_njit, test[:, 1:], f_mean)\nprint('-' * 65)\n\nprint('fillna_npwhere_njit (forward-filling):')\n%timeit for_loop_ffill(fillna_npwhere_njit, test)","5c040a3f":"import numpy as np\nfrom numba import njit\n\n@njit\ndef fillna_npwhere_njit(array, values):\n    if np.isnan(array.sum()):\n        array = np.where(np.isnan(array), values, array)\n    return array","18481692":"First, we compare two basic fillna functions. One is from [Jane Street: How to deal with Timeout error][1] and the other is my vectorised version.\n\n[1]: https:\/\/www.kaggle.com\/markmipt\/jane-street-how-to-deal-with-timeout-error","3ded3cad":"# Loading Example Test\n\n`f_mean` contains the mean values that we would like to fill into the examples test, which is pre-calculated from the mean values in the train set","41a2f538":"Since not all samples in the test contain NaN values, we would better first check if there is any NaN value and then call the fillna function. This should accelerate the speed. The check function is from [Fast check for NaN in NumPy][1].\n\n[1]: https:\/\/stackoverflow.com\/questions\/6736590\/fast-check-for-nan-in-numpy","dad534e3":"Finally, we compare the baseline method - pandas.DataFrame.fillna","2959954a":"First, we create a for-loop function since we will fill NaN values one sample at each time during inference.","77aa3b76":"# Conclusion\n\nSo far, the fastest version is the numba version!","81bbf4eb":"Finally, let's also check the pandas `fillna` function which is widely used in many notebooks.","8c12b780":"We compare the time consumption of mean-filling and forward-filling","8a457193":"Forward-filling is a little bit slower than mean-filling since it needs to update the temporary array every iteration.","c0ca85b0":"# Optimise Speed of Filling-NaN Function\n\nIn this notebook, I compare the time-consumption of different filling-NaN function function implementations from discussion forum [Comparison between different fillna methods][1]. \n\nHere, I try filling the NaN values with an array containing all the mean values pre-calculated from the train set.\n\n[1]: https:\/\/www.kaggle.com\/c\/jane-street-market-prediction\/discussion\/201302","965e1c52":"# Time-Consumption Comparison","4610ed07":"Let's compare the time consumption of different methods.","74697015":"# Filling-NaN Functions","a92c9411":"Oooops, it is too slow!","4a0d1235":"# Forward-Filling Example\nHere is an example of using forward-filling (i.e., filling with the last seen valid value instead of filling with a constant array).","0352d1e2":"I just come up with an idea using `numpy.where` with `numba.njit`. Let's try them!"}}