{"cell_type":{"35b3536b":"code","7cca7785":"code","b7f9f8ff":"code","425e3ead":"code","d11ff746":"code","4a2fd684":"code","473fe02d":"code","b604273b":"code","42663249":"code","95a45b7b":"code","4c2285c2":"code","2fb5464c":"code","5919f885":"code","ef21f359":"code","1b86871d":"code","914a46d3":"code","b993de65":"code","a8e56b3d":"code","00439883":"code","d90bbf7d":"code","2cb30659":"code","6954cdae":"code","0f38c66b":"code","7d335827":"code","b6dcd076":"code","4b5dab32":"code","f30da175":"code","4837d988":"code","3a2cac44":"code","97fb4821":"code","7dbbe159":"code","062818e0":"code","784dd6aa":"code","5e1e58d7":"code","cb8c33d6":"markdown","9a436792":"markdown","d808f11f":"markdown","1745c55a":"markdown","85f57531":"markdown","c59de6fd":"markdown","059c8899":"markdown","4602a952":"markdown","414bafa9":"markdown","814efbe4":"markdown","301e7dc5":"markdown","0f0bedc5":"markdown","078d3526":"markdown","e09318c1":"markdown","22533a94":"markdown","5ba68fa9":"markdown","ffa74292":"markdown","d8e637e7":"markdown","607ac7c3":"markdown","e801d7ca":"markdown","8c5f87ca":"markdown","559a376d":"markdown","963f5b8a":"markdown","acf161e7":"markdown","56fb5533":"markdown","f411749d":"markdown","289c9265":"markdown","8675c04e":"markdown","a16d1f89":"markdown","e2bdffbf":"markdown","c4ab7abe":"markdown","05805fdf":"markdown","25f7cbf5":"markdown"},"source":{"35b3536b":"import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nimport re\nimport category_encoders as ce","7cca7785":"df = pd.read_csv('..\/input\/BlackFriday.csv')","b7f9f8ff":"df.head()","425e3ead":"df.tail()","d11ff746":"df.info()","4a2fd684":"fig1, ax1 = plt.subplots(figsize=(12,7))\nsns.countplot( x = 'Gender' , data = df)","473fe02d":"labels = ['City_A' , 'City_B', 'City_C']\nsizes = [ df['City_Category'].value_counts()[2], df['City_Category'].value_counts()[0], df['City_Category'].value_counts()[1]]\nexplode = (0, 0.1, 0) \n\nfig1, ax1 = plt.subplots(figsize=(12,7))\nax1.pie(sizes , labels = labels , explode = explode, autopct = '%1.1f%%' , shadow = True)\nax1.axis('equal')\nplt.show()","b604273b":"fig1, ax1 = plt.subplots(figsize=(12,7))\nsns.countplot( x = 'Age' , data = df)","42663249":"fig1, ax1 = plt.subplots(figsize=(12,7))\nsns.countplot( x = 'Occupation' , data = df)","95a45b7b":"labels = [ 1 ,2 ,3 , '4+' , 0]\nstay_count = df['Stay_In_Current_City_Years'].value_counts()\nsizes = [ stay_count[0] , stay_count[1] , stay_count[2] , stay_count[3] , stay_count[4] ]\nexplode = (0.1 , 0 , 0 , 0 , 0.1)\n\nfig1 , ax1 = plt.subplots(figsize = (12 ,7))\nax1.pie( sizes , labels = labels , explode = explode , autopct = '%1.1f%%' , shadow = True)\nax1.axis('equal')\nplt.show()","4c2285c2":"fig1, ax1 = plt.subplots(figsize=(12,7))\nsns.countplot( x = 'Marital_Status' , data = df)","2fb5464c":"fig1, ax1 = plt.subplots(figsize=(12,7))\nsns.countplot(df['City_Category'],hue=df['Age'])","5919f885":"fig1 , ax1 = plt.subplots(figsize = (12,7))\nsns.boxplot('Age' , 'Purchase' , data = df)\nplt.show()","ef21f359":"fig1 , ax1 = plt.subplots(figsize = (12,7))\nplt.hist( 'Purchase' , data = df)\nplt.show()","1b86871d":"pattern = re.compile('\\d*\\+')\n\ndef stay_in_city(row , pattern):\n    stay = row['Stay_In_Current_City_Years']\n    \n    if bool(pattern.match(stay)):\n        stay = stay.replace(\"+\",\"\")\n        return stay\n    else:\n        return stay\n    \ndf['Stay_In_Current_City_Years'] = df.apply( stay_in_city , axis = 1 , pattern = pattern )","914a46d3":"df[['Product_Category_1' , 'Product_Category_2' , 'Product_Category_3']] = df[['Product_Category_1' , 'Product_Category_2' , 'Product_Category_3']].fillna(0)","b993de65":"df.head()","a8e56b3d":"df.tail()","00439883":"df.info()","d90bbf7d":"#Creating the dataset copies\ndataset = df\n#dataset = dataset.drop( columns = 'Unnamed: 0')\ndf = dataset.copy()","2cb30659":"df_dummy = df.iloc[:, 2:].values\npd.DataFrame(df_dummy).head()","6954cdae":"#Encoding categorical Data\nfrom sklearn.preprocessing import LabelEncoder, OneHotEncoder\nlabelencoder_X_1 = LabelEncoder()\ndf_dummy[:, 0] = labelencoder_X_1.fit_transform(df_dummy[:, 0])\ndf_dummy[:, 1] = labelencoder_X_1.fit_transform(df_dummy[:, 1])\ndf_dummy[:, 3] = labelencoder_X_1.fit_transform(df_dummy[:, 3])\n#Creating Dummy Variables for City Categories\nonehotencoder = OneHotEncoder(categorical_features = [3])\ndf_dummy = onehotencoder.fit_transform(df_dummy).toarray()\n\n#Removing Dummy variable trap\ndf_dummy = df_dummy[:, 1:]","0f38c66b":"pd.DataFrame(df_dummy).head()","7d335827":"#Binary Encoding\nencoder = ce.BinaryEncoder(cols = [4 , 7 , 8 ,9]) \ndf_dummy = encoder.fit_transform(df_dummy)","b6dcd076":"df_dummy.head()","4b5dab32":"#Seprating Independent and Dependent variables\ny = df_dummy.iloc[: , 29].values\nX = df_dummy.iloc[:, 0:29].values","f30da175":"#Seprating Dataset into Test set and Training set\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 0)","4837d988":"# Fitting Random Forest Regression to the dataset\nfrom sklearn.ensemble import RandomForestRegressor\nregressor = RandomForestRegressor(n_estimators = 100, random_state = 0)\nregressor.fit(X_train, y_train)","3a2cac44":"# Predicting a new result\ny_pred = regressor.predict(X_test)","97fb4821":"data = { 'Actual_Purchase' : y_test , 'Predicted_Purchase' : y_pred }\npd.DataFrame(data).head(10)","7dbbe159":"data = { 'Actual_Purchase' : y_test , 'Predicted_Purchase' : y_pred }\npd.DataFrame(data).tail(10)","062818e0":"from sklearn.model_selection import cross_val_score\naccuracies = cross_val_score(estimator = regressor, X = X_train, y = y_train, cv = 5)","784dd6aa":"print ( \"Accuracies :\"+str(accuracies)+\"\\nMean_accuracies :\"+str(accuracies.mean())+\"\\nStandard_deviation :\"+str(accuracies.std()))","5e1e58d7":"from sklearn.metrics import mean_squared_error , r2_score\nprint (\"RMSE value :\"+str(np.sqrt(mean_squared_error(y_test, y_pred))))\nprint (\"R2 Score :\"+str(r2_score(y_test , y_pred)))","cb8c33d6":"* Visual inspection of the Dataset","9a436792":"* Above code Encodes the categorical features ('Gender' , 'Age'  and 'City') and also creates dummy variables for city categories.\n* **Now ,Our Data Looks Like This :- **","d808f11f":"* The BoxPlot between *Purchase amount* and *Age* demonstrates that there are some outliers in each category of Age which will affect the model calculations. ","1745c55a":"* Our Dataset now looks like this and ready to use :-","85f57531":"* The CountPlot of *Marital Status* shows that unmarried people are buying products more but here also the margin between the categories is not much high in order to determine clear relation with purchase.","c59de6fd":"* Here, we can observe that the Categories like *** Occupation , Product_Category_1 , Product_Category_2 and Product_Category_3 *** are of the type integer and float, We will need to consider them as Objects and handle them in the same manner as other Categorical data.","059c8899":"* Above code Encodes Categorical features *( Ocuupation ,Product_Category_1 , Product_Category_2 and Product_Category_3)*  in binary format because of their large set of range values.","4602a952":"# Data Cleaning","414bafa9":"* We can observe that the *Age* also needs to be cleaned but since it is a category and can also be compared with eachother hence, we will manage it in our Preprocessing step.","814efbe4":"## Import Libraries","301e7dc5":"* The CountPlot of the *Occupation Category* demonstrates that people with **Job Type 0 ,4 , 7** are purchasing more products but since the plot is spread over many values , nothing can be deduced decisively about purchase according to Occupation of a person.","0f0bedc5":"* Above code Removes the **\"+\"** from the feature *Stay_In_Current_City_Years* and makes the feature ready to be used.","078d3526":"#### Do upvote if you liked reading it.","e09318c1":"* Above Histogram proves that high amount of *Purchase* is in low numbers that is outliers won't affect our model much. ","22533a94":"* *Model predicted values with 61.75% accuracy rate which not bad given that all the features were Categorical and no clear Relation can established between Purchase amount and them.*","5ba68fa9":"* Number of people of **City B** are buying products more than **City A or City C**, Suggesting that although the margin is not much high but maintaining the stores and its supplies in **City B** can be more profitable.","ffa74292":"* **Our Data is now ready to for the Preprocessing steps.**","d8e637e7":"* The CountPlot of *Age* group shows that people between the age of **26-35** are the potential customers of the store and as such products consumed by them must be kept in supply and stocked.","607ac7c3":"* The countPlot of the Dataset clearly demonstrates that **Men** are purchasing products much more than the **Women**.","e801d7ca":"# Data Visualization","8c5f87ca":"# Data PreProcessing Step","559a376d":"* *Product_Category_1 , Product_Category_2 and Product_Category_3* all have missing data in them which we found out by observing and also from the info method,  hence the above code assign *0* to missing values.\n","963f5b8a":"* Here we can observe all the categorical data that we need to take care of by using various **Encoding methods**.","acf161e7":"### Import the Dataset and Evaluate it for Data Cleaning","56fb5533":"* Above chart demonstrates that percentage of people living in the current city buying products , it can be observed that people living in the current city for 2 years are buying more products but not with much higher margin than the others.","f411749d":"* Creating two Copies of Our Dataset , Not a necessary step but one can use it to keep track of changes. ","289c9265":"* **Visual Comparison of the Predicted values and True values.**","8675c04e":"# Predicting Purchase Using RandomForest Regression","a16d1f89":"# Black Friday Analysis and stepwise Prediction","e2bdffbf":"### **Our Dataset After Cleaning and Substituting Missing values in it is given Below : -**","c4ab7abe":"* From the Above Data sections it is easy to observe that Dataset has mostly Categorical Variables as features and most of them are untidy and hence cannot be used directly in the model.","05805fdf":"* Above CountPlot verifies our hunch that people of age group **26-35** and living in **City B** are the potential Customers, But here we can also see that **City A and C** also has considerable number of buyers between **26-35 Age**.","25f7cbf5":"### K-fold Cross-Validation "}}