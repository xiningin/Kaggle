{"cell_type":{"a9d3dd45":"code","73186851":"code","3857df9e":"code","ebeb3789":"code","1fb1ec22":"code","88695b13":"code","43e11646":"code","fc0cd1e1":"code","9bb21211":"code","2aee2779":"code","d9449ea9":"code","34bd2d07":"code","ed8c483f":"code","213969be":"code","c18a76f3":"code","abea7fde":"code","c21ab60d":"code","4b655019":"code","cf1ff6a5":"code","93900b8c":"code","a65d141a":"markdown","768b1dbf":"markdown"},"source":{"a9d3dd45":"!pip install imutils","73186851":"import numpy as np\nimport pandas as pd\nfrom keras.preprocessing.image import ImageDataGenerator\nimport os\nimport random \nimport cv2\nimport imutils\nimport random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.preprocessing import LabelBinarizer\nfrom keras.utils import np_utils\nfrom keras.models import Sequential\nfrom keras import optimizers\nfrom sklearn.preprocessing import LabelBinarizer\nfrom keras import backend as K\nfrom keras.layers import Dense, Activation, Flatten, Dense,MaxPooling2D, Dropout\nfrom keras.layers import Conv2D, MaxPooling2D, BatchNormalization","3857df9e":"dir = \"..\/input\/handwritten-characters\/Train\/\"\ntrain_data = []\nimg_size = 32\nnon_chars = [\"#\",\"$\",\"&\",\"@\"]\nfor i in os.listdir(dir):\n    if i in non_chars:\n        continue\n    count = 0\n    sub_directory = os.path.join(dir,i)\n    for j in os.listdir(sub_directory):\n        count+=1\n        if count > 4000:\n            break\n        img = cv2.imread(os.path.join(sub_directory,j),0)\n        img = cv2.resize(img,(img_size,img_size))\n        train_data.append([img,i])","ebeb3789":"len(train_data)","1fb1ec22":"val_dir = \"..\/input\/handwritten-characters\/Validation\/\"\nval_data = []\nimg_size = 32\nfor i in os.listdir(val_dir):\n    if i in non_chars:\n        continue\n    count = 0\n    sub_directory = os.path.join(val_dir,i)\n    for j in os.listdir(sub_directory):\n        count+=1\n        if count > 1000:\n            break\n        img = cv2.imread(os.path.join(sub_directory,j),0)\n        img = cv2.resize(img,(img_size,img_size))\n        val_data.append([img,i])","88695b13":"len(val_data)","43e11646":"random.shuffle(train_data)\nrandom.shuffle(val_data)","fc0cd1e1":"train_X = []\ntrain_Y = []\nfor features,label in train_data:\n    train_X.append(features)\n    train_Y.append(label)","9bb21211":"val_X = []\nval_Y = []\nfor features,label in val_data:\n    val_X.append(features)\n    val_Y.append(label)","2aee2779":"LB = LabelBinarizer()\ntrain_Y = LB.fit_transform(train_Y)\nval_Y = LB.fit_transform(val_Y)","d9449ea9":"train_X = np.array(train_X)\/255.0\ntrain_X = train_X.reshape(-1,32,32,1)\ntrain_Y = np.array(train_Y)","34bd2d07":"val_X = np.array(val_X)\/255.0\nval_X = val_X.reshape(-1,32,32,1)\nval_Y = np.array(val_Y)","ed8c483f":"print(train_X.shape,val_X.shape)","213969be":"print(train_Y.shape,val_Y.shape)","c18a76f3":"model = Sequential()\n\nmodel.add(Conv2D(32, (3, 3), padding = \"same\", activation='relu', input_shape=(32,32,1)))\nmodel.add(MaxPooling2D(pool_size=(2,2)))\nmodel.add(Conv2D(64, (3, 3), activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2,2)))\nmodel.add(Conv2D(128, (3, 3), activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2,2)))\nmodel.add(Dropout(0.25))\n \nmodel.add(Flatten())\nmodel.add(Dense(128, activation='relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(35, activation='softmax'))","abea7fde":"model.summary()","c21ab60d":"model.compile(loss='categorical_crossentropy', optimizer=\"adam\",metrics=['accuracy'])","4b655019":"history = model.fit(train_X,train_Y, epochs=50, batch_size=32, validation_data = (val_X, val_Y),  verbose=1)","cf1ff6a5":"plt.plot(history.history['accuracy'])\nplt.plot(history.history['val_accuracy'])\nplt.title('Training Accuracy vs Validation Accuracy')\nplt.ylabel('Accuracy')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Validation'], loc='upper left')\nplt.show()","93900b8c":"plt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title('Training Loss vs Validation Loss')\nplt.ylabel('Loss')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Validation'], loc='upper left')\nplt.show()","a65d141a":"# Offline Handwritten Text Recognition\n\n","768b1dbf":"## Approach\n\nStep1 :  Build a digit(0-9) + A-Z characters classifier using a CNN architecture.\nStep2 :  Apply character segmentation for the handwritten word image.\nStep3 :  Classify each segmented letter and then get the final word in the image."}}