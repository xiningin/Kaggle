{"cell_type":{"d57351eb":"code","b1518039":"code","508a2601":"code","b5661316":"code","a8365e68":"code","65b84485":"code","c65e0b2a":"code","6bc7ee0c":"code","6897f83e":"code","1e6f04d1":"code","53b6b9bb":"code","2d303c42":"code","ca9f114e":"code","02280c7f":"code","ce380c48":"code","f3cee337":"code","74a561ea":"code","c0add834":"code","e01caf05":"code","4f1d3a9b":"code","e4bb11ca":"code","5091d851":"code","14b2455b":"code","d20bc73d":"code","06c0b560":"code","10660bb2":"code","73f7cb6b":"code","416bc8f4":"code","9434712c":"code","7784564a":"code","d521f673":"code","5ac0aeaf":"code","18cb2304":"code","897744c6":"code","1a328384":"code","3ad377ea":"code","208c6095":"code","8a5fda4c":"code","6bb6249b":"code","01303130":"code","461da567":"code","f151bb50":"code","9c3c94a3":"code","dc25c24c":"code","37cf5252":"code","4f695704":"code","7059cc21":"code","c4093e1f":"code","c2ee8d91":"code","05d81b0e":"code","92cb22ff":"code","a6ad9e9c":"code","99341eb2":"code","1059f1b7":"code","ff6ddaed":"code","2ca615ca":"markdown","ea3139d3":"markdown","bcbe5cdb":"markdown","e244a66b":"markdown","cf79aed2":"markdown","0851b050":"markdown","344cc20a":"markdown"},"source":{"d57351eb":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","b1518039":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns","508a2601":"df_train = pd.read_csv(\"\/kaggle\/input\/house-prices-advanced-regression-techniques\/train.csv\")\ndf_test = pd.read_csv(\"\/kaggle\/input\/house-prices-advanced-regression-techniques\/test.csv\")","b5661316":"df_train.head()","a8365e68":"train_Id = df_train[\"Id\"]\ntest_Id = df_test[\"Id\"]","65b84485":"df_train.describe()\n# 37+1(y= saleprice) numerical data columns and 43 categorical data columns ","c65e0b2a":"df_test.head()","6bc7ee0c":"df_test.describe()","6897f83e":"sns.heatmap(df_train.isnull())","1e6f04d1":"sns.heatmap(df_test.isnull())","53b6b9bb":"mat=df_train.corr()\n\nfig,ax= plt.subplots(figsize=(30,30))\nsns.heatmap(mat,annot = True, annot_kws={'size' : 12})","2d303c42":"# from the heat plot shown above, we analysed by salePrice has maximum dependency on 'GrLivArea','OverallQual','GarageCars','GarageArea'. \nabc= df_train[['GrLivArea','OverallQual','GarageCars','GarageArea', 'SalePrice' ]]\nsns.pairplot(abc)\n","ca9f114e":"df_train.info()\n# 43 object data type means 43 categorical data type columns","02280c7f":"df_test.info()","ce380c48":"df_train.isnull().sum().sort_values(ascending = False)[0:20]","f3cee337":"df_test.isnull().sum().sort_values(ascending = False)[0:35]","74a561ea":"#deleting those columns which have more than 50% NaN values\n#as those columns are same for both test and train datas\n# why garageYrBlt\nlist_drop=[\"PoolQC\",\"MiscFeature\",\"Alley\",\"Fence\",\"GarageYrBlt\"]\n\nfor col in list_drop:\n    del df_train[col]\n    del df_test[col]\n    \n","c0add834":"df_train.shape","e01caf05":"df_train.isnull().sum().sort_values(ascending=False)[0:15]","4f1d3a9b":"df_test.isnull().sum().sort_values(ascending=False)[0:30]","e4bb11ca":"df_train.LotFrontage.value_counts(dropna=False)","5091d851":"df_train.LotFrontage.fillna(df_train.LotFrontage.mean(),inplace=True)\ndf_test.LotFrontage.fillna(df_test.LotFrontage.mean(),inplace=True)\ndf_train.shape\n","14b2455b":"list_fill_train=[\"BsmtCond\", \"BsmtQual\", \"GarageType\", \"GarageCond\", \"GarageFinish\",\n                 \"GarageQual\",\"MasVnrType\",\"BsmtFinType2\",\"BsmtExposure\",\"FireplaceQu\",\"MasVnrArea\"]\n\nfor j in list_fill_train:\n    #df_train[j].fillna(df_train[j].mode(),inplace=True).\n    # wrong way to do it.\n    # mode() return a tuple : mode value and freuency of that value , therefore using [0] gives access to mode value.\n    df_train[j] = df_train[j].fillna(df_train[j].mode()[0])\n    df_test[j] = df_test[j].fillna(df_train[j].mode()[0])\n\ndf_train.shape\n","d20bc73d":"print(df_train.isnull().sum().sort_values(ascending=False)[0:5])\nprint(df_test.isnull().sum().sort_values(ascending=False)[0:20])","06c0b560":"# BsmtFinType1    37\n#Electrical       has to be deleted i.E 1460-38 = 1422 \n# total =38 rows \ndf_train.dropna(inplace=True)","10660bb2":"df_train.shape","73f7cb6b":"list_test_str = ['BsmtFinType1', 'Utilities','BsmtFullBath', 'BsmtHalfBath', 'Functional', 'SaleType', 'Exterior2nd', \n           'Exterior1st', 'KitchenQual','MSZoning']\nlist_test_num= ['GarageCars', 'BsmtFinSF1', 'BsmtFinSF2', 'BsmtUnfSF',  'TotalBsmtSF', 'GarageArea',]\n\nfor item in list_test_str:\n    df_test[item] = df_test[item].fillna(df_test[item].mode()[0])\nfor item in list_test_num:\n    df_test[item] = df_test[item].fillna(df_test[item].mean())","416bc8f4":"print(df_train.isnull().sum().sort_values(ascending=False)[0:5])\nprint(df_test.isnull().sum().sort_values(ascending=False)[0:5])","9434712c":"df_test.shape","7784564a":"del df_train[\"Id\"]\ndel df_test[\"Id\"]","d521f673":"print(df_train.shape)\nprint(df_test.shape)","5ac0aeaf":"print(df_train.isnull().any().any())\nprint(df_test.isnull().any().any())\n# one time .any returns true or false for each column , if any 1 single vaule of column is na , it will return false against \n#that column. if we apply .any again, it will return if any sinfle column has an entry ,as false....i.e if the entire dataframe \n# is has any na value.\n\n\n","18cb2304":"#joining data sets\ndf_final=pd.concat([df_train,df_test],axis=0)\ndf_final.shape","897744c6":"\ndf_final.info()\n# 39 objecttype columns which has to be converted into numerical data so that lr can be applied.","1a328384":"columns = ['MSZoning', 'Street','LotShape', 'LandContour', 'Utilities',\n           'LotConfig', 'LandSlope','Neighborhood', 'Condition1', 'Condition2',\n           'BldgType', 'HouseStyle', 'RoofStyle', 'RoofMatl', 'Exterior1st',\n           'Exterior2nd', 'MasVnrType','ExterQual', 'ExterCond', 'Foundation',\n           'BsmtQual', 'BsmtCond','BsmtExposure', 'BsmtFinType1', 'BsmtFinType2',\n           'Heating', 'HeatingQC', 'CentralAir', 'Electrical','KitchenQual',\n           'Functional', 'FireplaceQu', 'GarageType', 'GarageFinish',\n           'GarageQual', 'GarageCond', 'PavedDrive', 'SaleType', 'SaleCondition']","3ad377ea":"def One_hot_encoding(columns):\n    final_df=df_final\n    i=0 # means MSZoning\n    for fields in columns:\n        #get dummies function numericalize(1s, 0s) the caterogical column and stored into df1\n        df1=pd.get_dummies(df_final[fields],drop_first=True)\n        \n        df_final.drop([fields],axis=1,inplace=True)\n        if i==0: #this will be executed only for MSZoning\n            final_df=df1.copy() # the new numerical data(1s ,0s) MSZoning is being copied into final_df  \n        else:           \n            final_df=pd.concat([final_df,df1],axis=1)\n        i=i+1\n       \n     # before execution of next statement, df_final has no categorical column and final_df has all the corresponding\n        # (to categorical column ) numericalised(1s, 0s) column. \n    final_df=pd.concat([df_final,final_df],axis=1)\n    \n        \n    return final_df","208c6095":"main_df=df_train.copy()","8a5fda4c":"df_final.head()","6bb6249b":"df_final = One_hot_encoding(columns)\ndf_final.shape","01303130":"df_final.head()","461da567":"df_final.shape ","f151bb50":"df_final =df_final.loc[:,~df_final.columns.duplicated()]","9c3c94a3":"df_final.shape","dc25c24c":"df_train_m=df_final.iloc[:1422,:]\ndf_test_m=df_final.iloc[1422:,:]\ndf_test_m.shape","37cf5252":"df_test_m.drop([\"SalePrice\"],axis=1,inplace=True)","4f695704":"df_test_m.shape","7059cc21":"x_train_final=df_train_m.drop([\"SalePrice\"],axis=1)\ny_train_final=df_train_m[\"SalePrice\"]","c4093e1f":"from sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import r2_score, mean_squared_error","c2ee8d91":"X_train, X_test, Y_train, Y_test = train_test_split(x_train_final, y_train_final)\nprint(X_train.shape,X_test.shape)\nprint(Y_train.shape,Y_test.shape)","05d81b0e":"##model building\nlinear_reg=LinearRegression()\nlinear_reg.fit(X_train,Y_train)","92cb22ff":"Y_pred = linear_reg.predict(X_test)","a6ad9e9c":"print(\"R-Squared Value for Training Set: {:.3f}\".format(linear_reg.score(X_train,Y_train)))\nprint(\"R-Squared Value for Test Set: {:.3f}\".format(linear_reg.score(X_test,Y_test)))","99341eb2":"print(r2_score(Y_test, Y_pred))","1059f1b7":"y_pred_test=linear_reg.predict(df_test_m)\npred_df = pd.DataFrame(y_pred_test, columns=['SalePrice'])\ntest_id_df = pd.DataFrame(test_Id, columns=['Id'])\nsubmission = pd.concat([test_id_df, pred_df], axis=1)\nsubmission.head()","ff6ddaed":"\nsubmission.to_csv('submission.csv', index=False)","2ca615ca":"# Applying Linear Regression","ea3139d3":"## checking if there is any missing value left. ##","bcbe5cdb":"## deleting columns which have very high frequency of Na","e244a66b":"- Separate the datasets again.","cf79aed2":"## Feature Engineering\n  - coverting all the categorical variables\n  - we have to combine both train and test data to convert categorical variables so that same no.s are assigned to particular category in train and test data after that we will split that again.","0851b050":"- ## for LotFrontage","344cc20a":"# replacing Na values"}}