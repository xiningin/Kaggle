{"cell_type":{"b8a73544":"code","4274b039":"code","d917b431":"code","27394009":"code","2f33a20d":"code","83fbfbdf":"code","57fc1a65":"code","b749782b":"code","8dea0b90":"code","8995ac01":"code","b5594d60":"code","aeb2648b":"code","4515b861":"code","64e2a3fa":"code","dc4e385d":"code","bebdfc9e":"code","e8c1d047":"code","7de4d6c0":"code","f86e8a9c":"code","9975fbd4":"code","a5dda270":"code","9bff1db1":"code","d3e872f7":"code","c8d368b4":"code","35667fdd":"code","5d8c4102":"code","7846ab3a":"code","b38fdb7d":"code","7a68dae7":"code","5a19b516":"code","e015522e":"code","fb9d87bf":"code","3fa7c0cf":"code","70d30dc3":"code","f24d6dbd":"code","be1e8374":"code","ce0b8002":"code","09622e4e":"code","af6876ea":"code","4349762e":"code","d63f5845":"code","088b28ec":"code","403d7a4a":"code","d301e0c5":"code","46e5be13":"code","491114f3":"code","1e0aacad":"code","9b7bc1d6":"markdown","abf48c5a":"markdown","f633c6ae":"markdown","ddf03809":"markdown","b499b26f":"markdown","585ca195":"markdown","69067017":"markdown","6b64b610":"markdown","20eee293":"markdown","9b2c6f44":"markdown","6a7b08b1":"markdown","da75cc68":"markdown","a1bb3d0b":"markdown","b2b85ce7":"markdown","3a9563c5":"markdown","9538155f":"markdown","87fdedb5":"markdown","c9c5f2dd":"markdown","c606f0d7":"markdown","4ea40896":"markdown","928d57c4":"markdown","e0fdc28c":"markdown","572ac3a6":"markdown","de5397d8":"markdown","14843d1e":"markdown","f1e74539":"markdown","95febb40":"markdown","8e0dba11":"markdown","f962f5d6":"markdown","f80d7b41":"markdown","6439d4b6":"markdown","f2131a1f":"markdown","af78d800":"markdown","5b280354":"markdown","41ed3589":"markdown","a287e5e8":"markdown","194972bf":"markdown","50d6da3d":"markdown","86cdc590":"markdown","622262a8":"markdown","b6c37ef4":"markdown","80b26125":"markdown","2f704a92":"markdown","ffd3d1e6":"markdown","75699c4b":"markdown","4bcf4525":"markdown","70fb7380":"markdown","2a8ba077":"markdown","736a4d4f":"markdown"},"source":{"b8a73544":"##########################Load Libraries  ####################################\nimport pandas as pd\nimport numpy as np\nimport dask.dataframe as dd\npd.set_option('display.max_columns', 500)\npd.set_option('display.max_rows', 500)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport lightgbm as lgb\nfrom sklearn import preprocessing, metrics\nfrom ipywidgets import widgets, interactive\nimport gc\nimport joblib\nimport warnings\nwarnings.filterwarnings('ignore')\nfrom datetime import datetime, timedelta \nfrom typing import Union\nfrom tqdm.notebook import tqdm_notebook as tqdm\nfrom itertools import cycle\nimport datetime as dt\nfrom torch.autograd import Variable\nimport random \nimport os\nfrom matplotlib.pyplot import figure\nfrom fastprogress import master_bar, progress_bar\nimport torch\nimport torch.nn as nn\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.preprocessing import MinMaxScaler\nimport time \nfrom torch.utils.data import Dataset\nfrom sklearn.metrics import mean_squared_error\nimport torch \n\n%matplotlib inline\n\n#from gensim.models import Word2Vec\n#import gensim.downloader as api\n\npd.set_option('max_columns', 50)\nplt.style.use('bmh')\ncolor_pal = plt.rcParams['axes.prop_cycle'].by_key()['color']\ncolor_cycle = cycle(plt.rcParams['axes.prop_cycle'].by_key()['color'])\n\n \n\n ","4274b039":"device = 'cuda:0'\n#device = 'cpu'","d917b431":"INPUT_DIR_PATH = '..\/input\/m5-forecasting-accuracy\/'","27394009":"def reduce_mem_usage(df, verbose=True):\n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    start_mem = df.memory_usage().sum() \/ 1024**2    \n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics: \n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)    \n    end_mem = df.memory_usage().sum() \/ 1024**2\n    if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n    return df\n\n\ndef read_data():\n    sell_prices_df = pd.read_csv(INPUT_DIR_PATH + 'sell_prices.csv')\n    sell_prices_df = reduce_mem_usage(sell_prices_df)\n    print('Sell prices has {} rows and {} columns'.format(sell_prices_df.shape[0], sell_prices_df.shape[1]))\n\n    calendar_df = pd.read_csv(INPUT_DIR_PATH + 'calendar.csv')\n    calendar_df = reduce_mem_usage(calendar_df)\n    print('Calendar has {} rows and {} columns'.format(calendar_df.shape[0], calendar_df.shape[1]))\n\n    sales_train_validation_df = pd.read_csv(INPUT_DIR_PATH + 'sales_train_validation.csv')\n    print('Sales train validation has {} rows and {} columns'.format(sales_train_validation_df.shape[0], sales_train_validation_df.shape[1]))\n\n    submission_df = pd.read_csv(INPUT_DIR_PATH + 'sample_submission.csv')\n    return sell_prices_df, calendar_df, sales_train_validation_df, submission_df\n    ","2f33a20d":"_,  calendar_df, sales_train_validation_df, _ = read_data()","83fbfbdf":"#Create date index\ndate_index = calendar_df['date']\ndates = date_index[0:1913]\ndates_list = [dt.datetime.strptime(date, '%Y-%m-%d').date() for date in dates]","57fc1a65":"# Create a data frame for items sales per day with item ids (with Store Id) as columns names  and dates as the index \nsales_train_validation_df['item_store_id'] = sales_train_validation_df.apply(lambda x: x['item_id']+'_'+x['store_id'],axis=1)\nDF_Sales = sales_train_validation_df.loc[:,'d_1':'d_1913'].T\nDF_Sales.columns = sales_train_validation_df['item_store_id'].values\n\n#Set Dates as index \nDF_Sales = pd.DataFrame(DF_Sales).set_index([dates_list])\nDF_Sales.index = pd.to_datetime(DF_Sales.index)\nDF_Sales.head()","b749782b":"#Select arbitrary index and plot the time series\nindex = 6780\ny = pd.DataFrame(DF_Sales.iloc[:,index])\ny = pd.DataFrame(y).set_index([dates_list])\nTS_selected = y \ny.index = pd.to_datetime(y.index)\nax = y.plot(figsize=(30, 9),color='red')\nax.set_facecolor('lightgrey')\nplt.xticks(fontsize=21 )\nplt.yticks(fontsize=21 )\nplt.legend(fontsize=20)\nplt.title(label = 'Sales Demand Selected Time Series Over Time',fontsize = 23)\nplt.ylabel(ylabel = 'Sales Demand',fontsize = 21)\nplt.xlabel(xlabel = 'Date',fontsize = 21)\nplt.show()\n","8dea0b90":"#del calendar_df, sales_train_validation_df,DF_Sales\n#gc.collect()","8995ac01":"SEED = 1345\ndef seed_everything(seed):\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n\n\nseed_everything(SEED)","b5594d60":"data = np.array(y)\nscaler = MinMaxScaler(feature_range=(-1, 1))\ntrain_data_normalized = scaler.fit_transform(data.reshape(-1, 1))","aeb2648b":"print(train_data_normalized[:5])\nprint(train_data_normalized[-5:])","4515b861":"fig, axs = plt.subplots(2)\n \nfig.suptitle('Data Distribution Before and After Normalization ',fontsize = 19)\npd.DataFrame(data).plot(kind='hist',ax = axs[0] , alpha=.4 , figsize=[12,6], legend = False,title = ' Before Normalization',color ='red') \npd.DataFrame(train_data_normalized).plot(kind='hist', ax = axs[1] ,figsize=[12,6], alpha=.4 , legend = False,title = ' After Normalization'\\\n                                         ,color = 'blue')\n   ","64e2a3fa":"###  This function creates a sliding window or sequences of 28 days and one day label ####\ndef sliding_windows(data, seq_length):\n    x = []\n    y = []\n\n    for i in range(len(data)-seq_length-1):\n        _x = data[i:(i+seq_length)]\n        _y = data[i+seq_length]\n        x.append(_x)\n        y.append(_y)\n\n    return np.array(x),np.array(y)","dc4e385d":"#train_inout_seq = create_inout_sequences(train_data_normalized, train_window)\nseq_length = 28\nx, y = sliding_windows(train_data_normalized, seq_length)\nprint(x.shape)\nprint(y.shape)","bebdfc9e":"train_size = int(len(y) * 0.67)\ntest_size = len(y) - train_size\n\ndataX = Variable(torch.Tensor(np.array(x)))\ndataY = Variable(torch.Tensor(np.array(y)))\n\ntrainX = Variable(torch.Tensor(np.array(x[0:train_size])))\ntrainY = Variable(torch.Tensor(np.array(y[0:train_size])))\n\ntestX = Variable(torch.Tensor(np.array(x[train_size:len(x)])))\ntestY = Variable(torch.Tensor(np.array(y[train_size:len(y)])))","e8c1d047":"print(\"train shape is:\",trainX.size())\nprint(\"train label shape is:\",trainY.size())\nprint(\"test shape is:\",testX.size())\nprint(\"test label shape is:\",testY.size())","7de4d6c0":"class LSTM(nn.Module):\n\n    def __init__(self, num_classes, input_size, hidden_size, num_layers):\n        super(LSTM, self).__init__()\n        \n        self.num_classes = num_classes\n        self.num_layers = num_layers\n        self.input_size = input_size\n        self.hidden_size = hidden_size\n        #self.seq_length = seq_length\n        self.dropout = nn.Dropout(p=0.2)\n        \n        self.lstm = nn.LSTM(input_size=input_size, hidden_size=hidden_size,\n                            num_layers=num_layers, batch_first=True,dropout = 0.25)\n        \n        self.fc = nn.Linear(hidden_size, num_classes)\n\n    def forward(self, x):\n        h_0 = Variable(torch.zeros(\n            self.num_layers, x.size(0), self.hidden_size).to(device))\n        \n        c_0 = Variable(torch.zeros(\n            self.num_layers, x.size(0), self.hidden_size).to(device))\n        \n        # Propagate input through LSTM\n        ula, (h_out, _) = self.lstm(x, (h_0, c_0))\n        \n        h_out = h_out.view(-1, self.hidden_size)\n        \n        out = self.fc(h_out)\n        out = self.dropout(out)\n       \n        return out","f86e8a9c":"# create a nn class (just-for-fun choice :-) \nclass RMSELoss(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.mse = nn.MSELoss()\n        \n    def forward(self,yhat,y):\n        return torch.sqrt(self.mse(yhat,y))","9975fbd4":"#####  Parameters  ######################\nnum_epochs = 500\nlearning_rate = 1e-3\ninput_size = 1\nhidden_size = 512\nnum_layers = 1\nnum_classes = 1\n\n#####Init the Model #######################\nlstm = LSTM(num_classes, input_size, hidden_size, num_layers)\nlstm.to(device)\n\n##### Set Criterion Optimzer and scheduler ####################\ncriterion = torch.nn.MSELoss().to(device)    # mean-squared error for regression\noptimizer = torch.optim.Adam(lstm.parameters(), lr=learning_rate,weight_decay=1e-5)\nscheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer,  patience=500,factor =0.5 ,min_lr=1e-7, eps=1e-08)\n#optimizer = torch.optim.SGD(lstm.parameters(), lr=learning_rate)\n\n# Train the model\n\nfor epoch in progress_bar(range(num_epochs)): \n    lstm.train()\n    outputs = lstm(trainX.to(device))\n    optimizer.zero_grad()\n    \n    # obtain the loss function\n    loss = criterion(outputs, trainY.to(device))\n    \n    loss.backward()\n    \n    \n    optimizer.step()\n    \n    #Evaluate on test     \n    lstm.eval()\n    valid = lstm(testX.to(device))\n    vall_loss = criterion(valid, testY.to(device))\n    scheduler.step(vall_loss)\n    \n    if epoch % 50 == 0:\n      print(\"Epoch: %d, loss: %1.5f valid loss:  %1.5f \" %(epoch, loss.cpu().item(),vall_loss.cpu().item()))\n","a5dda270":"######Prediction###############\n\n\nlstm.eval()\ntrain_predict = lstm(dataX.to(device))\ndata_predict = train_predict.cpu().data.numpy()\ndataY_plot = dataY.data.numpy()\n\n## Inverse Normalize \ndata_predict = scaler.inverse_transform(data_predict)\ndataY_plot = scaler.inverse_transform(dataY_plot)\n\n## Add dates\ndf_predict = pd.DataFrame(data_predict)\ndf_predict = df_predict.set_index([dates_list[:-29]])\ndf_labels = pd.DataFrame(dataY_plot)\ndf_labels = df_labels.set_index([dates_list[:-29]])\n\n# Plot \nfigure(num=None, figsize=(19, 6), dpi=80, facecolor='w', edgecolor='k')\nplt.axvline(x=dates_list[train_size], c='r')\nplt.plot( df_labels[0])\nplt.plot(df_predict[0])\nplt.legend(['Prediction','Time Series'],fontsize = 21)\nplt.suptitle('Time-Series Prediction Entire Set',fontsize = 23)\nplt.xticks(fontsize=21 )\nplt.yticks(fontsize=21 )\nplt.ylabel(ylabel = 'Sales Demand',fontsize = 21)\nplt.xlabel(xlabel = 'Date',fontsize = 21)\nplt.show()\n","9bff1db1":"\n#######Plot the test set ##########################\nfigure(num=None, figsize=(23, 6), dpi=80, facecolor='w', edgecolor='k')\nplt.plot(df_labels.iloc[-testX.size()[0]:][0])\nplt.plot(df_predict.iloc[-testX.size()[0]:][0])\nplt.legend(['Prediction','Time Series'],fontsize = 21)\nplt.suptitle('Time-Series Prediction Test',fontsize = 23)\nplt.xticks(fontsize=21 )\nplt.yticks(fontsize=21 )\nplt.ylabel(ylabel = 'Sales Demand',fontsize = 21)\nplt.xlabel(xlabel = 'Date',fontsize = 21)\nplt.show()","d3e872f7":"np.sqrt(((dataY_plot[-testX.size()[0]:] - data_predict[-testX.size()[0]:] ) ** 2).mean())","c8d368b4":"class LSTM2(nn.Module):\n\n    def __init__(self, num_classes, input_size, hidden_size, num_layers):\n        super(LSTM2, self).__init__()\n        \n        self.num_classes = num_classes\n        self.num_layers = num_layers\n        self.input_size = input_size\n        self.hidden_size = hidden_size\n        \n        self.batch_size = 1\n        #self.seq_length = seq_length\n        \n        self.LSTM2 = nn.LSTM(input_size=input_size, hidden_size=hidden_size, num_layers=num_layers,batch_first=True,dropout = 0.25)\n       \n        \n        \n        self.fc = nn.Linear(hidden_size, num_classes)\n        self.dropout = nn.Dropout(p=0.2)\n    def forward(self, x):\n        h_1 = Variable(torch.zeros(\n            self.num_layers, x.size(0), self.hidden_size).to(device))\n         \n        \n        c_1 = Variable(torch.zeros(\n            self.num_layers, x.size(0), self.hidden_size).to(device))\n        \n       \n        _, (hn, cn) = self.LSTM2(x, (h_1, c_1))\n     \n        #print(\"hidden state shpe is:\",hn.size())\n        y = hn.view(-1, self.hidden_size)\n        \n        final_state = hn.view(self.num_layers, x.size(0), self.hidden_size)[-1]\n        #print(\"final state shape is:\",final_state.shape)\n        out = self.fc(final_state)\n        #out = self.dropout(out)\n        #print(out.size())\n        return out\n    \n   \n        \n       \n        ","35667fdd":"def init_weights(m):\n    for name, param in m.named_parameters():\n        nn.init.uniform_(param.data, -0.08, 0.08)\n        \n","5d8c4102":"num_epochs = 700\nlearning_rate = 1e-3\ninput_size = 1\nhidden_size = 512\nnum_layers = 2\n\nnum_classes = 1\n\nlstm = LSTM2(num_classes, input_size, hidden_size, num_layers)\nlstm.to(device)\n\n\nlstm.apply(init_weights)\n\ncriterion = torch.nn.MSELoss().to(device)    # mean-squared error for regression\noptimizer = torch.optim.Adam(lstm.parameters(), lr=learning_rate,weight_decay=1e-5)\nscheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer,  patience=100, factor =0.5 ,min_lr=1e-7, eps=1e-08)\n#optimizer = torch.optim.SGD(lstm.parameters(), lr=learning_rate)\n\n# Train the model\n\nfor epoch in progress_bar(range(num_epochs)): \n    lstm.train()\n    outputs = lstm(trainX.to(device))\n    optimizer.zero_grad()\n    torch.nn.utils.clip_grad_norm_(lstm.parameters(), 1)\n    # obtain the loss function\n    loss = criterion(outputs, trainY.to(device))\n    \n    loss.backward()\n    \n    scheduler.step(loss)\n    optimizer.step()\n    lstm.eval()\n    valid = lstm(testX.to(device))\n    vall_loss = criterion(valid, testY.to(device))\n    scheduler.step(vall_loss)\n    \n    if epoch % 50 == 0:\n      print(\"Epoch: %d, loss: %1.5f valid loss:  %1.5f \" %(epoch, loss.cpu().item(),vall_loss.cpu().item()))","7846ab3a":"######Prediction###############\n\n\nlstm.eval()\ntrain_predict = lstm(dataX.to(device))\ndata_predict = train_predict.cpu().data.numpy()\ndataY_plot = dataY.data.numpy()\n\n## Inverse Normalize \ndata_predict = scaler.inverse_transform(data_predict)\ndataY_plot = scaler.inverse_transform(dataY_plot)\n\n## Add dates\ndf_predict = pd.DataFrame(data_predict)\ndf_predict = df_predict.set_index([dates_list[:-29]])\ndf_labels = pd.DataFrame(dataY_plot)\ndf_labels = df_labels.set_index([dates_list[:-29]])\n\n# Plot \nfigure(num=None, figsize=(19, 6), dpi=80, facecolor='w', edgecolor='k')\nplt.axvline(x=dates_list[train_size], c='r')\nplt.plot( df_labels[0])\nplt.plot(df_predict[0])\nplt.legend(['Prediction','Time Series'],fontsize = 21)\nplt.suptitle('Time-Series Prediction Entire Set',fontsize = 23)\nplt.xticks(fontsize=21 )\nplt.yticks(fontsize=21 )\nplt.ylabel(ylabel = 'Sales Demand',fontsize = 21)\nplt.xlabel(xlabel = 'Date',fontsize = 21)\nplt.show()\n","b38fdb7d":"\n#######Plot the test set ##########################\nfigure(num=None, figsize=(23, 6), dpi=80, facecolor='w', edgecolor='k')\nplt.plot(df_labels.iloc[-testX.size()[0]:][0])\nplt.plot(df_predict.iloc[-testX.size()[0]:][0])\nplt.legend(['Prediction','Time Series'],fontsize = 21)\nplt.suptitle('Time-Series Prediction Test',fontsize = 23)\nplt.xticks(fontsize=21 )\nplt.yticks(fontsize=21 )\nplt.ylabel(ylabel = 'Sales Demand',fontsize = 21)\nplt.xlabel(xlabel = 'Date',fontsize = 21)\nplt.show()","7a68dae7":"np.sqrt(((dataY_plot[-testX.size()[0]:] - data_predict[-testX.size()[0]:] ) ** 2).mean())","5a19b516":"# Re-Use the Time Series we have selected earlier\nDF = TS_selected\ncolnames = DF.columns\nDF = DF.rename(columns={colnames[0]:'sales'})\nDF.tail()","e015522e":"start_time = time.time()\nfor i in (1,7,14,28,365):\n    print('Shifting:', i)\n    DF['lag_'+str(i)] = DF['sales'].transform(lambda x: x.shift(i))\nprint('%0.2f min: Time for bulk shift' % ((time.time() - start_time) \/ 60))\n","fb9d87bf":" \nDF = DF.set_index([dates_list])\nProduct = \"Time Series\"\n\n################Create Plot ##############################################\nfig, axs = plt.subplots(6, 1, figsize=(33, 16))\naxs = axs.flatten()\nax_idx = 0\n\nfor i in (0,1,7,14,28,365):\n    if i == 0:\n        ax = DF['sales'].plot(fontsize = 21,\n                     legend =False,\n                     color=next(color_cycle),\n                     ax=axs[ax_idx])\n        ax.set_ylabel(\"Sales Demand\",fontsize = 21)\n        ax.set_xlabel(\"Date\",fontsize = 21)\n        ax.set_title(fontsize = 21,label = Product)\n\n        ax_idx += 1\n    else : \n        ax = DF[f'lag_{i}'].plot(fontsize = 21,\n                     legend =False,\n                     color=next(color_cycle),\n                     ax=axs[ax_idx])\n        ax.set_ylabel(\"Sales Demand\",fontsize = 21)\n        ax.set_xlabel(\"Date\",fontsize = 21)\n        ax.set_title(fontsize = 21,label = Product+f'  Lag {i}')\n\n        ax_idx += 1\n    \n   \n   \nplt.xticks(fontsize=21 )\nplt.yticks(fontsize=21 )\n\nplt.tight_layout()\nplt.show()\n","3fa7c0cf":"for i in [7,14,28,60,180,365]:\n    print('Rolling period:', i)\n    DF['rolling_mean_'+str(i)] = DF['sales'].transform(lambda x: x.shift(28).rolling(i).mean())\n    DF['rolling_std_'+str(i)]  = DF['sales'].transform(lambda x: x.shift(28).rolling(i).std())\n\n\nprint('%0.2f min: Time for loop' % ((time.time() - start_time) \/ 60))\nDF.head()","70d30dc3":"DF = DF.replace('nan', np.nan).fillna(0)\nDF.head()","f24d6dbd":"DF_normlized = DF.copy(deep=True)\nscaler = MinMaxScaler(feature_range=(-1, 1))\ny_scaler = MinMaxScaler(feature_range=(-1, 1))\nscaled_data = scaler.fit_transform(DF) \ny_scaler.fit_transform(DF['sales'].values.reshape(-1, 1))\nDF_normlized.iloc[:,:] =  scaled_data\nDF_normlized.head()","be1e8374":"DF_normlized = DF_normlized.reset_index()\nDF_normlized = DF_normlized.rename(columns={'index':'date'})\nDF_normlized.head()\nDF_normlized['date'] = DF_normlized['date'].apply(lambda x: x.strftime(\"%Y-%m-%d\"))\nDF_normlized = DF_normlized.merge(calendar_df[['date','weekday']],on='date')\nDF_normlized.head()","ce0b8002":"## Adding the embedded vectors \nDF_normlized['wd1'] =0\nDF_normlized['wd2'] =0\nDF_normlized['wd3'] =0\nDF_normlized['wd4'] =0\n\nDF_normlized.loc[:,'wd1'][DF_normlized['weekday'] =='Sunday'] , DF_normlized.loc[:,'wd2'][DF_normlized['weekday'] =='Sunday'],\\\nDF_normlized.loc[:,'wd3'][DF_normlized['weekday'] =='Sunday'] , DF_normlized.loc[:,'wd4'][DF_normlized['weekday'] =='Sunday']= 0.4 ,-0.3 ,0.6,0.1\n\nDF_normlized.loc[:,'wd1'][DF_normlized['weekday'] =='Monday'] , DF_normlized.loc[:,'wd2'][DF_normlized['weekday'] =='Monday'],\\\nDF_normlized.loc[:,'wd3'][DF_normlized['weekday'] =='Monday'] , DF_normlized.loc[:,'wd4'][DF_normlized['weekday'] =='Monday']= 0.2 ,0.2 ,0.5,-0.3\n\nDF_normlized.loc[:,'wd1'][DF_normlized['weekday'] =='Tuesday'] ,DF_normlized.loc[:,'wd2'][DF_normlized['weekday'] =='Tuesday'],\\\nDF_normlized.loc[:,'wd3'][DF_normlized['weekday'] =='Tuesday'] , DF_normlized.loc[:,'wd4'][DF_normlized['weekday'] =='Tuesday']= 0.1,-1.0,1.3,0.9\n\nDF_normlized.loc[:,'wd1'][DF_normlized['weekday'] =='Wednesday'] , DF_normlized.loc[:,'wd2'][DF_normlized['weekday'] =='Wednesday'],\\\nDF_normlized.loc[:,'wd3'][DF_normlized['weekday'] =='Wednesday'] , DF_normlized.loc[:,'wd4'][DF_normlized['weekday'] =='Wednesday']= -0.6,0.5,1.2,0.7\n\nDF_normlized.loc[:,'wd1'][DF_normlized['weekday'] =='Thursday'] , DF_normlized.loc[:,'wd2'][DF_normlized['weekday'] =='Thursday'],\\\nDF_normlized.loc[:,'wd3'][DF_normlized['weekday'] =='Thursday'] , DF_normlized.loc[:,'wd4'][DF_normlized['weekday'] =='Thursday']= 0.9,0.2,-0.1,0.6\n\nDF_normlized.loc[:,'wd1'][DF_normlized['weekday'] =='Friday'] , DF_normlized.loc[:,'wd2'][DF_normlized['weekday'] =='Friday'],\\\nDF_normlized.loc[:,'wd3'][DF_normlized['weekday'] =='Friday'] , DF_normlized.loc[:,'wd4'][DF_normlized['weekday'] =='Friday']= 0.4,1.1,0.3,-1.5\n\n\nDF_normlized.loc[:,'wd1'][DF_normlized['weekday'] =='Saturday'] , DF_normlized.loc[:,'wd2'][DF_normlized['weekday'] =='Saturday'],\\\nDF_normlized.loc[:,'wd3'][DF_normlized['weekday'] =='Saturday'] , DF_normlized.loc[:,'wd4'][DF_normlized['weekday'] =='Saturday']= 0.3,-0.2,0.6,0.0\n","09622e4e":"fig, axs = plt.subplots(2)\n \nfig.suptitle('rolling_mean_14 - Data Distribution Before and After Normalization ',fontsize = 19)\npd.DataFrame(DF['rolling_mean_14']).plot(kind='hist',ax = axs[0] , alpha=.4 , figsize=[12,6], legend = False,title = ' Before Normalization',color ='red') \npd.DataFrame(DF_normlized['rolling_mean_14']).plot(kind='hist', ax = axs[1] ,figsize=[12,6], alpha=.4 , legend = False,title = ' After Normalization'\\\n                                         ,color = 'blue')","af6876ea":"###  This function creates a sliding window or sequences of 28 days and one day label ####\n###  For Multiple features                                                            ####\ndef sliding_windows_mutli_features(data, seq_length):\n    x = []\n    y = []\n\n    for i in range((data.shape[0])-seq_length-1):\n        _x = data[i:(i+seq_length),:] ## 16 columns for features  \n        _y = data[i+seq_length,0] ## column 0 contains the labbel\n        x.append(_x)\n        y.append(_y)\n\n    return np.array(x),np.array(y).reshape(-1,1)","4349762e":"# Select only the features and the target for prediction  \ndata_with_features = DF_normlized[[\"sales\",\"lag_7\",\"lag_1\",\"lag_28\",\"lag_365\",\"rolling_mean_7\",\\\n\"rolling_std_7\",\"rolling_mean_14\",\"rolling_std_14\",\"rolling_mean_28\",\"rolling_std_28\",\"rolling_mean_60\",\"rolling_std_60\",'lag_28','wd1','wd2','wd3','wd4']].to_numpy()             \n\n#data_with_features = DF_normlized['sales'].to_numpy().reshape(-1,1)\ndata_with_features.shape","d63f5845":"x , y = sliding_windows_mutli_features(data_with_features,seq_length=28)\nprint(\"X_data shape is\",x.shape)\nprint(\"y_data shape is\",y.shape)","088b28ec":"train_size = int(len(y) * 0.67)\ntest_size = len(y) - train_size\n\ndataX = Variable(torch.Tensor(np.array(x)))\ndataY = Variable(torch.Tensor(np.array(y)))\n\ntrainX = Variable(torch.Tensor(np.array(x[0:train_size])))\ntrainY = Variable(torch.Tensor(np.array(y[0:train_size])))\n\ntestX = Variable(torch.Tensor(np.array(x[train_size:len(x)])))\ntestY = Variable(torch.Tensor(np.array(y[train_size:len(y)])))\n\n\nprint(\"train shape is:\",trainX.size())\nprint(\"train label shape is:\",trainY.size())\nprint(\"test shape is:\",testX.size())\nprint(\"test label shape is:\",testY.size())","403d7a4a":"class LSTM2(nn.Module):\n\n    def __init__(self, num_classes, input_size, hidden_size, num_layers):\n        super(LSTM2, self).__init__()\n        \n        self.num_classes = num_classes\n        self.num_layers = num_layers\n        self.input_size = input_size\n        self.hidden_size = hidden_size\n        \n        self.batch_size = 1\n        #self.seq_length = seq_length\n        \n        self.LSTM2 = nn.LSTM(input_size=input_size, hidden_size=hidden_size, num_layers=num_layers,batch_first=True,dropout = 0.2)\n       \n        \n        \n        self.fc1 = nn.Linear(hidden_size,256)\n        self.bn1 = nn.BatchNorm1d(256,eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        self.dp1 = nn.Dropout(0.25)\n        \n        self.fc2 = nn.Linear(256, 128)\n            \n        self.bn2 = nn.BatchNorm1d(128,eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        self.dp2 = nn.Dropout(0.2)\n        self.fc3= nn.Linear(128, 1)\n        self.relu = nn.ReLU()\n       \n    def forward(self, x):\n        h_1 = Variable(torch.zeros(\n            self.num_layers, x.size(0), self.hidden_size).to(device))\n         \n        \n        c_1 = Variable(torch.zeros(\n            self.num_layers, x.size(0), self.hidden_size).to(device))\n        \n       \n        _, (hn, cn) = self.LSTM2(x, (h_1, c_1))\n     \n        #print(\"hidden state shpe is:\",hn.size())\n        y = hn.view(-1, self.hidden_size)\n        \n        final_state = hn.view(self.num_layers, x.size(0), self.hidden_size)[-1]\n        #print(\"final state shape is:\",final_state.shape)\n        \n        x0 = self.fc1(final_state)\n        x0 = self.bn1(x0)\n        x0 = self.dp1(x0)\n        x0 = self.relu(x0)\n        \n        x0 = self.fc2(x0)\n        x0 = self.bn2(x0)\n        x0 = self.dp2(x0)\n        \n        x0 = self.relu(x0)\n        \n        out = self.fc3(x0)\n        #print(out.size())\n        return out\n    \n   ","d301e0c5":"num_epochs = 500\nlearning_rate = 1e-3\ninput_size = 18\nhidden_size = 512\nnum_layers = 4\nnum_classes = 1\n\nbest_val_loss = 100\n\nlstm = LSTM2(num_classes, input_size, hidden_size, num_layers)\nlstm.to(device)\n\n\nlstm.apply(init_weights)\n\ncriterion = torch.nn.MSELoss().to(device)    # mean-squared error for regression\noptimizer = torch.optim.Adam(lstm.parameters(), lr=learning_rate,weight_decay=1e-5)\n#optimizer = torch.optim.SGD(lstm.parameters(), lr=0.01, momentum=0.9,weight_decay=1e-5)\n\nscheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer,  patience=50, factor =0.5 ,min_lr=1e-7, eps=1e-08)\n#scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max = 5e-3, eta_min=1e-8, last_epoch=-1)\n#optimizer = torch.optim.SGD(lstm.parameters(), lr=learning_rate)\n\n# Train the model\n\nfor epoch in progress_bar(range(num_epochs)): \n    lstm.train()\n    outputs = lstm(trainX.to(device))\n    optimizer.zero_grad()\n    torch.nn.utils.clip_grad_norm_(lstm.parameters(), 1)\n    # obtain the loss function\n    loss = criterion(outputs, trainY.to(device))\n    \n    loss.backward()\n    #torch.nn.utils.clip_grad_norm_(lstm.parameters(), 1)\n    \n    optimizer.step()\n    lstm.eval()\n    valid = lstm(testX.to(device))\n    vall_loss = criterion(valid, testY.to(device))\n    scheduler.step(vall_loss)\n    #scheduler.step()\n    \n    if vall_loss.cpu().item() < best_val_loss:\n         torch.save(lstm.state_dict(), 'best_model.pt')\n         print(\"saved best model epoch:\",epoch,\"val loss is:\",vall_loss.cpu().item())\n         best_val_loss = vall_loss.cpu().item()\n        \n    \n    if epoch % 50 == 0:\n      print(\"Epoch: %d, loss: %1.5f valid loss:  %1.5f \" %(epoch, loss.cpu().item(),vall_loss.cpu().item()))","46e5be13":"######Prediction###############\nlstm.load_state_dict(torch.load('best_model.pt'))\n\nlstm.eval()\ntrain_predict = lstm(dataX.to(device))\ndata_predict = train_predict.cpu().data.numpy()\ndataY_plot = dataY.data.numpy()\nprint(data_predict.shape)\nprint(dataY_plot.shape)\n\n\n## Inverse Normalize \ndata_predict = y_scaler.inverse_transform(data_predict)\ndataY_plot = y_scaler.inverse_transform(dataY_plot.reshape(-1, 1))\n\n## Add dates\ndf_predict = pd.DataFrame(data_predict)\ndf_predict = df_predict.set_index([dates_list[:-29]])\ndf_labels = pd.DataFrame(dataY_plot)\ndf_labels = df_labels.set_index([dates_list[:-29]])\n\n# Plot \nfigure(num=None, figsize=(19, 6), dpi=80, facecolor='w', edgecolor='k')\nplt.axvline(x=dates_list[train_size], c='r')\nplt.plot( df_labels[0])\nplt.plot(df_predict[0])\nplt.legend(['Prediction','Time Series'],fontsize = 21)\nplt.suptitle('Time-Series Prediction Entire Set',fontsize = 23)\nplt.xticks(fontsize=21 )\nplt.yticks(fontsize=21 )\nplt.ylabel(ylabel = 'Sales Demand',fontsize = 21)\nplt.xlabel(xlabel = 'Date',fontsize = 21)\nplt.show()\n","491114f3":"\n#######Plot the test set ##########################\nfigure(num=None, figsize=(23, 6), dpi=80, facecolor='w', edgecolor='k')\nplt.plot(df_labels.iloc[-testX.size()[0]:][0])\nplt.plot(df_predict.iloc[-testX.size()[0]:][0])\nplt.legend(['Prediction','Time Series'],fontsize = 21)\nplt.suptitle('Time-Series Prediction Test',fontsize = 23)\nplt.xticks(fontsize=21 )\nplt.yticks(fontsize=21 )\nplt.ylabel(ylabel = 'Sales Demand',fontsize = 21)\nplt.xlabel(xlabel = 'Date',fontsize = 21)\nplt.show()","1e0aacad":"np.sqrt(((dataY_plot[-testX.size()[0]:] - data_predict[-testX.size()[0]:] ) ** 2).mean())","9b7bc1d6":"## Plot Lags\nLet's Plot our lags \nit is a bit hard to see the small lags (as the Time Series containing few years), but for the longer lags \nsuch as 365, we can see the shift ...","abf48c5a":"## Day Of the Week \nThis article : \n\nhttps:\/\/medium.com\/@davidheffernan_99410\/an-introduction-to-using-categorical-embeddings-ee686ed7e7f9\n\nI have decided to try it as-is on the day of the week - So I will add four-vectors which describe the days of the week \n\n![daysweek.JPG](attachment:daysweek.JPG)","f633c6ae":"# Multiple LSTM layers <a id=\"7\"><\/a> \nWe can Enhance the net by using multiple LSTM layers. \n![LSTMnet2.JPG](attachment:LSTMnet2.JPG)","ddf03809":"## Rolling windows \nFor rolling windows, we will use mean and std (standard deviation)","b499b26f":"The illustration below shoe a schematic of our simple LSTM net :\n![LSTMnet1.JPG](attachment:LSTMnet1.JPG)","585ca195":"## Multi-Dimensional Sliding Window","69067017":"# Resources \nHere are some useful resources that provide some background about deep learning, Time series, and various Reuicurent Networks :\n\n* Coursera has a course about Sequences, Time series prediction. It is a basic course that provides a preliminary overview of the concept \n  And building models to Univariate Time series. The course use Keras and TensorFlow,   but it provides a good starting point for this topic\n   \n   Link : https:\/\/www.coursera.org\/learn\/tensorflow-sequences-time-series-and-prediction\/home\/welcome\n* LSTM networks - Great post\/Blog that explains  the concept beyond  LSTM networks \n  \n  Link : https:\/\/colah.github.io\/posts\/2015-08-Understanding-LSTMs\/\n* Post about building Time Series deep learning  - The post cover the Keras\/TensorFlow framework, but it also gives a great overview of the main concepts and how to prepare the data.\n  \n  Link : https:\/\/machinelearningmastery.com\/how-to-develop-lstm-models-for-time-series-forecasting\/\n* Pytorch Basic example - This is a simple example of how to build a Pytorch LSTM network for simple Univariate Time Series.\n  \n  Link https:\/\/github.com\/pytorch\/examples\/tree\/master\/time_sequence_prediction\n","6b64b610":"### Load Libraries","20eee293":"# Add Features <a id=\"8\"><\/a> \nSo far we add only one feature - The Sales demand \nNow  let's add more features \n\n![Features.JPG](attachment:Features.JPG)","9b2c6f44":"## Plot The distribution \nPlot the distribution before and after the Normalization. \nAs you can see, we kept the distribution of the data, but we change its scales.","6a7b08b1":"## Predict on Entire Data Set ","da75cc68":"## Lag features ","a1bb3d0b":"Rolling window is some calculation over a window (example mean )\n\n![rollwindow.JPG](attachment:rollwindow.JPG)","b2b85ce7":"### Test RMSE","3a9563c5":"## LSTM model \nThe model is similar to the previous one with  some enhancement at the output layers ","9538155f":"The lags and rolling windows created Nan values \nWhen I tried to train with Nan values, the loss was also Nan \nNeed further understanding, but for now, I will replace the Nan by zero ","87fdedb5":"# Table Of Contents\n\n* [<font size=4>Main Steps<\/font>](#1)\n* [<font size=4>Load Data<\/font>](#2)\n* [<font size=4>One Time Series<\/font>](#3)\n* [<font size=4>Normlize Data<\/font>](#4)\n* [<font size=4>Create Sequances<\/font>](#5)\n* [<font size=4>Simple LSTM model<\/font>](#6)\n* [<font size=4>Multiple LSTM layers<\/font>](#7)\n* [<font size=4>Add Features <\/font>](#8)\n\n\n\n\n\n","c9c5f2dd":"Lets see the shape of our data","c606f0d7":"# Select One Time Series as an Example <a id=\"3\"><\/a>\nSelecting one arbitrary Time Series ","4ea40896":"## Predict","928d57c4":"Create the sliding window data-set ","e0fdc28c":"# Load Data <a id=\"2\"><\/a>","572ac3a6":"## Pytorch Tensor","de5397d8":"## Normalize\nDue to the multi-dimension, we need to adjust \nWe can normalize the full Data-Frame. However, we need to do \ndummy normalize to our target (the sales) as our prediction will be 1D \n\n","14843d1e":"Now we can start again with the selected Time Series, Add some features and modify a bit our model and training.","f1e74539":"## RMSE - Test","95febb40":"## Predicting Time Series with LSTM Deep Learning Network\n\n### Background \nSince this is my first Time Series competition in Kaggle, I am mainly using it for learning.\nThere are great kernel here, mostly using the boosting models (the most popular is LightGBM \nAnd I have learned how to prepare the data and use it with this popular model.\nMoving forwards, I have decided to learn a bit more about the use of deep learning for Time Series prediction.\nI do have a background from other competition with deep learning but for image vision, working mostly with Pytorch.\nTo go deeper and learn the topic, I have decided to build a learning kernel, that at least at the beginning will explain the topic and the concepts, the definition and the basics, From my experience when you try to explain to others, you learn the most.\n\nSo the first kernel is only trying to explain the basic idea using an arbitrary series from the M5 data.\nI hope that the next versions will go deeper and I can provide a full submission with deep learning. \n## If you like my kernel - Please Vote \n\nIf You like this kernel \nHere a similar one with Seq2Seq model : \n\nhttps:\/\/www.kaggle.com\/omershect\/learning-pytorch-seq2seq-with-m5-data-set\n\n","8e0dba11":"Let's Compare one example again to verify that the normalization was done properly","f962f5d6":"## Training \nSome enhancement  we save the best model (based on the lowest validation loss)","f80d7b41":"# Simple LSTM model <a id=\"6\"><\/a>\nIn this section, we create the Pytorch LSTM model.\nThe Model has one LST layer and one dense input layer.\nYou can read all the details about the LSTM \n(Versus RNN) - at the link, I provided above \nThe picture of one cell is taken from that blog.\n\n![LSTM.JPG](attachment:LSTM.JPG)\n\nNote: that Pytorch has the nn.LSTM  function and nn.LSTMCell.\nFrom what I have read you should use the nn.LSTM . \nIt is the layer that will automatically create multiple LSTM layer,\nand it seems that it uses more efficiently the Cuda drivers \nyou can see more in this discussion \nhttps:\/\/discuss.pytorch.org\/t\/nn-lstmcell-inside-nn-lstm\/51189","6439d4b6":"## Date List\nHere we create dates list, that will help later on to display the Time Series, with the right dates ","f2131a1f":"Also  I am happy to get comments or things that I need to fix.","af78d800":"The following parameters are provided to the net\n* Num-classes - is the number of output in this case 1\n* Input size - we don't use batch, so we have one input (of 28 samples)\n* Hidden layers, number of hidden layer in each cell, the more is better, but also will slow down the training\n* Num layers - we have one layer of LSTM (layer we will increase it)","5b280354":"## Versions\n* Version 1-2 First Draft. \n* Version 3 Add Table Of Content.\n* Version 4-7   Add Model with Multiple features\n* Version 8 - Add more epochs to the Multiple features model","41ed3589":"# Main Steps <a id=\"1\"><\/a>\n* These are the main steps for building a Time Series Prediction Model : \n![image.png](attachment:image.png)","a287e5e8":"The Basic idea of Time Series prediction and RNN (Recurrent Neural Network) is to re-arrange the data \ninto windows of sequences, and labels. \nFor this example, I will use a window or a sequence of 28 samples (28 days ) \nSo the data should look like this series.\n\n![TS3.JPG](attachment:TS3.JPG)\n\nWe create a sliding window which builds sequences and labels.\nIn our case, we have sequences of 28 days, that will use to predict the next day.","194972bf":"## Plot The TS","50d6da3d":"## GPU use \nSince this is a deep learning model, The use of GPU will accelerate the training. \nThe first models are not so demanding so you can still use CPU training (but it will be slower).","86cdc590":"# Create Sequances <a id=\"5\"><\/a>\nIn this part we allign the data into input features and labels with techniches whic adapt for Time series processing \nThis is out Time Series \n\n![TS2.JPG](attachment:TS2.JPG)\n\nOr in a more schematic ilustriation \n\n![TS1.JPG](attachment:TS1.JPG)","622262a8":"### Test RMSE","b6c37ef4":"So we got :\n* 1262 sets of 28 samples each as the features (X) and 1262 labels as our target(y) in the training set \n* 622 sets of 28 samples with 622 labels in our tests set \n\nYou can see that in Pytorch the tensor dimensions are opposite to the NumPy dimensions ","80b26125":"## SEED all ","2f704a92":"### What Next \n* Add more features \n* Calculate WRMSE \n* Change Loss function \n* Train MultiVarient series \n* Use batches \n* Add Convolotional Network \n* Use Cross Validiation \n* Create Submission \n\n\n## If you like the kernel, please vote, and this will encourage me to post more \n","ffd3d1e6":"## Normlize Data <a id=\"4\"><\/a>\nNormalization is a technique often applied as part of data preparation for machine learning.\nThe goal of normalization is to change the values of numeric columns in the dataset to use a common scale, without distorting differences in the ranges of values.\nFor machine learning, every dataset does not require normalization.\nIt is required only when features have different rangesor scales.\n\n\n\nNormalizes our data using the min\/max scaler with minimum and maximum values of -1 and 1, respectively","75699c4b":"If we print some of the examples, we can see that the values are now between -1 and 1 ","4bcf4525":"## Pytorch Tensors \nPytorch use tensors as the input to the model \nVariable is a wrapper to the tensor \nThis kernel is only a preliminary starter, \n\nSo I use the Variable wrapper\nA more common way is to train with batches and use the dataset class\nBut this is for later.\n\nIf you want to learn more about Tensors \nRead this tutorial \n\nhttps:\/\/pytorch.org\/tutorials\/beginner\/former_torchies\/tensor_tutorial.html\n\nWe also split the data to train and testing or validation sets.\nThere are multiple methods to do this (hold one-off, Cross-Validation),\nbut for Time Series, this needs careful and gentile planning.\nFor simplicity, at this stage, We will split the data for the training set and a test set","70fb7380":"Features can be lags or rolling windows. It is easier to implement using data-frame Lag is just shifting the sales demand.\n\n![Lag1.JPG](attachment:Lag1.JPG)","2a8ba077":"## Credits\nThe Basic data loading and the reduce memory function were taken from this great kernel \n\nhttps:\/\/www.kaggle.com\/kyakovlev\/m5-simple-fe\n\nAlso I have learned alot from this Pytorch LSTM kernel \nhttps:\/\/www.kaggle.com\/gopidurgaprasad\/m5-forecasting-eda-lstm-pytorch-modeling\/notebook?scriptVersionId=31373530","736a4d4f":"To use the day of the week - we will merge data from the calendar DF "}}