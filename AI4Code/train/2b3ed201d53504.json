{"cell_type":{"47aacfba":"code","06c93fda":"code","d2973c74":"code","30ed392c":"code","f1639abd":"code","7b8cf763":"code","dab274d3":"code","c473ef89":"code","3d7a117a":"code","b3c26e64":"code","ceebe314":"code","af7a03bb":"code","4db5a2a8":"code","4b097b55":"code","ccb372db":"code","de178d4e":"code","5d5aa92b":"code","a0559d33":"code","269e7db3":"code","668f0c58":"code","ea801f68":"code","b40b8bc9":"code","15e939a8":"code","720ce0e8":"code","710fe9d6":"markdown","024465a6":"markdown","5534337b":"markdown","1e40c061":"markdown","95538746":"markdown","c4503e13":"markdown","3e56da53":"markdown","84274f45":"markdown","8651f063":"markdown","1b43a6df":"markdown","dfbbec3a":"markdown","6e480a91":"markdown","97c8ccef":"markdown"},"source":{"47aacfba":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\n\nnp.random.seed(84541)\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix, classification_report\n\nfrom keras.utils.np_utils import to_categorical\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D\nfrom keras.optimizers import Adam\nfrom keras.preprocessing.image import ImageDataGenerator\n\nsns.set(style='white', context='notebook', palette='deep')","06c93fda":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","d2973c74":"train = pd.read_csv('\/kaggle\/input\/digit-recognizer\/train.csv', sep=',')\ntest= pd.read_csv('\/kaggle\/input\/digit-recognizer\/test.csv', sep=',')","30ed392c":"train.shape","f1639abd":"train","7b8cf763":"number = train.iloc[12][1:train.shape[1]]\nnumber_matrix = number.values.reshape(28,28)\nplt.imshow(number_matrix)\nplt.axis('off');","dab274d3":"number = train.iloc[0][1:]\nnumber_matrix =number.values.reshape(28,28)\nplt.subplot(221)\nplt.imshow(number_matrix)\nplt.axis('off');\nnumber = train.iloc[8][1:]\nnumber_matrix =number.values.reshape(28,28)\nplt.subplot(222)\nplt.imshow(number_matrix)\nplt.axis('off');\nnumber = train.iloc[85][1:]\nnumber_matrix =number.values.reshape(28,28)\nplt.subplot(223)\nplt.imshow(number_matrix)\nplt.axis('off');\nnumber = train.iloc[42][1:]\nnumber_matrix =number.values.reshape(28,28)\nplt.subplot(224)\nplt.imshow(number_matrix)\nplt.axis('off');","c473ef89":"X = train.drop(['label'],axis=1) \/ 255\ntest = test\/ 255\nY = train['label']\nY =  to_categorical(Y, num_classes = 10)","3d7a117a":"X_train, X_test, y_train, y_test = train_test_split(X,Y,random_state=42)","b3c26e64":"X_train = X_train.values.reshape(-1,28,28,1)\nX_test = X_test.values.reshape(-1,28,28,1)\ntest = test.values.reshape(-1,28,28,1)","ceebe314":"plt.imshow(X_train[0][:,:,0]);","af7a03bb":"plt.imshow(X_test[0][:,:,0]);","4db5a2a8":"model = Sequential()\n\n## 2 layers with Conv2D - reLu is used to add non linearity to the network\nmodel.add(Conv2D(filters=32, kernel_size=(5,5), padding='Same',\n                activation='relu', input_shape=(28,28,1)))\n\nmodel.add(Conv2D(filters=32, kernel_size=(5,5), padding='Same',\n                activation='relu'))\n## Max pool layer\nmodel.add(MaxPool2D(pool_size=(2,2)))#downsampling filter\n\n## Regularization - dropout layer\nmodel.add(Dropout(0.25))#regularization method\n\n# More Conv2D layers!\nmodel.add(Conv2D(filters=64, kernel_size=(3,3), padding='Same',\n                activation='relu'))\nmodel.add(Conv2D(filters=64, kernel_size=(3,3), padding='Same',\n                activation='relu'))\n\n## Max pool layer\nmodel.add(MaxPool2D(pool_size=(2,2),strides=(2,2)))\n#Strides of the convolution along the height and width\n#downsampling filter\n\n## Regularization - dropout layer\nmodel.add(Dropout(0.25))#regularization method\n\n# Flatten layer - Convert the it into a one single 1D vector\nmodel.add(Flatten())\n\n# Fully-connected (Dense) layers\nmodel.add(Dense(256,activation='relu'))\n\n## Regularization - dropout layer\nmodel.add(Dropout(0.5))#regularization method\n\n## last layer - Softmax: outputs distribution of probability of each class\nmodel.add(Dense(10,activation='softmax'))","4b097b55":"#Define the optimizer and compile the model!\nmodel.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])","ccb372db":"datagen = ImageDataGenerator(\n        featurewise_center=False,  # set input mean to 0 over the dataset\n        samplewise_center=False,  # set each sample mean to 0\n        featurewise_std_normalization=False,  # divide inputs by std of the dataset\n        samplewise_std_normalization=False,  # divide each input by its std\n        zca_whitening=False,  # apply ZCA whitening\n        rotation_range=10,  # randomly rotate images in the range (degrees, 0 to 180)\n        zoom_range = 0.1, # Randomly zoom image \n        width_shift_range=0.1,  # randomly shift images horizontally (fraction of total width)\n        height_shift_range=0.1,  # randomly shift images vertically (fraction of total height)\n        horizontal_flip=False,  # randomly flip images\n        vertical_flip=False)  # randomly flip images\n\n\ndatagen.fit(X_train)","de178d4e":"epochs = 30\nbatch_size = 88","5d5aa92b":"history = model.fit(datagen.flow(X_train,y_train, batch_size=batch_size),\n                              epochs = epochs, validation_data = (X_test,y_test),\n                              verbose = 8, steps_per_epoch=X_train.shape[0] \/\/ batch_size)","a0559d33":"# Predict the values from the test dataset\ny_pred = model.predict(X_test)\n# Convert predictions classes to one hot vectors \ny_pred_classes = np.argmax(y_pred,axis = 1) \n# Convert validation observations to one hot vectors\nY_true = np.argmax(y_test,axis = 1) \n# compute the confusion matrix\nconfusion_mtx = confusion_matrix(Y_true, y_pred_classes) \n# print the confusion matrix\nprint(confusion_mtx)","269e7db3":"print(classification_report(Y_true, y_pred_classes))","668f0c58":"y_pred_answer = model.predict(test)\n# Convert predictions classes to one hot vectors \ny_pred_classes = np.argmax(y_pred_answer,axis = 1) ","ea801f68":"y_pred_classes[:5]","b40b8bc9":"answer = pd.read_csv('\/kaggle\/input\/digit-recognizer\/sample_submission.csv', sep=',')","15e939a8":"answer['Label'] = y_pred_classes","720ce0e8":"answer.to_csv('submission.csv',index=False)","710fe9d6":"# Model training - Fit","024465a6":"#### Neural networks\n##### Phases\n\n     - Loading libraries\n     - Loading datasets\n     - Data visualization\n     - Target construction\n     - Model 1\n     - Model 1 training\n     - Evaluation - Model 1\n     \n[Download the Dataset](https:\/\/www.kaggle.com\/c\/digit-recognizer)","5534337b":"# Public Score: 0.99085 - 8 epochs, batch_size=86!\n# Public Score: 0.99357 - 30 epochs - batch_size = 88!","1e40c061":"# Target construction & encoding the target to one hot vectors!","95538746":"# Looking at train and test images","c4503e13":"# Defining the model!","3e56da53":"# Loading datasets","84274f45":"# Data augmentation  - Expanding our dataset (artificially)","8651f063":"# Reshaping","1b43a6df":"# Loading libraries","dfbbec3a":"# Let's predict the answer sheet","6e480a91":"# Evaluation","97c8ccef":"# Data visualization"}}