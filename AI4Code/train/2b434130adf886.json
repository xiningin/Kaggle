{"cell_type":{"9528d177":"code","89f1d278":"code","83e07027":"code","a2b6a72a":"code","fb1b1047":"code","9e2a794d":"code","3d997177":"code","5b90d81c":"code","f2589d7e":"code","d9a45b78":"code","884ec1ea":"code","358f3b0c":"code","ab026c3a":"code","c2a36ca9":"code","726ce7ad":"code","4dc18c95":"markdown","195be32f":"markdown","7e18cdd1":"markdown","a9e17dc3":"markdown","dac30bd2":"markdown","2fc583bb":"markdown","2c0d74f8":"markdown","14cfc9d3":"markdown"},"source":{"9528d177":"from fastai.vision.all import *\n\nlabels = pd.read_csv(\"..\/input\/dog-breed-identification\/labels.csv\")\nlabels","89f1d278":"from sklearn.model_selection import StratifiedShuffleSplit\n\nsplit = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)\ntrain_ids, valid_ids = next(split.split(labels, labels[\"breed\"]))\nlabels[\"is_valid\"] = [i in valid_ids for i in range(len(labels))]\n\nlabels[\"id\"] = labels[\"id\"].apply(lambda x: x + \".jpg\")","83e07027":"path = \"..\/input\/dog-breed-identification\/train\"\n\ndls = ImageDataLoaders.from_df(labels, path,\n                               item_tfms=Resize(460, method=\"squeeze\"),\n                               batch_tfms=[*aug_transforms(size=300),\n                                           Normalize.from_stats(*imagenet_stats)],\n                               bs=32, valid_col=\"is_valid\")\ndls.show_batch()","a2b6a72a":"from torchvision.models import inception_v3, mobilenet_v2\n\ninception = inception_v3(pretrained=True, aux_logits=False)\ninception = nn.Sequential(*list(inception.children())[:-2],\n                          nn.Flatten()).eval()","fb1b1047":"resnet = nn.Sequential(*list(resnet50(pretrained=True).children())[:-1], \n                          nn.Flatten()).eval()","9e2a794d":"mobile = nn.Sequential(*list(mobilenet_v2(pretrained=True).children())[:-1],\n                       nn.AdaptiveAvgPool2d((1,1)),\n                       nn.Flatten()).eval()","3d997177":"class NeuralNet(Module):\n    def __init__(self, extractors, hidden_size, vocab_size, device):\n        \n        self.extractors = extractors\n        for conv in self.extractors:\n            conv.to(device)\n                  \n        self.classifier = nn.Sequential(\n            nn.BatchNorm1d(hidden_size),\n            nn.Dropout(0.25),\n            nn.Linear(hidden_size, 1024),\n            nn.ReLU(),\n            nn.BatchNorm1d(1024),\n            nn.Dropout(0.5),\n            nn.Linear(1024, vocab_size)\n        )\n        \n    def forward(self, x):\n        \n        features = torch.cat([conv(x) for conv in self.extractors], dim=1)\n        \n        return self.classifier(features)","5b90d81c":"extractors = [inception, resnet, mobile]\nhidden_size = 2048 + 2048 + 1280\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\nmodel = NeuralNet(extractors, hidden_size, len(dls.vocab), device)","f2589d7e":"weights = [labels.shape[0] \/ (120 * labels[\"breed\"].value_counts()[breed]) for breed in dls.vocab]\nweights = tensor(weights, device=device)","d9a45b78":"learn = Learner(dls, model, metrics=accuracy, path=\".\").to_fp16()\nlearn.lr_find()","884ec1ea":"learn.fit_one_cycle(3, 1e-3)","358f3b0c":"torch.cuda.empty_cache()","ab026c3a":"test_files = get_image_files(\"..\/input\/dog-breed-identification\/test\")\ntest_dl = dls.test_dl(test_files, bs=32)","c2a36ca9":"preds, targs = learn.get_preds(dl=test_dl)","726ce7ad":"sub = pd.DataFrame({\"id\":test_files.map(lambda x:x.stem)})\nsub[list(dls.vocab)] = preds\nsub.to_csv(\"submission.csv\", index=False)","4dc18c95":"combine these CNNs and add a classifier","195be32f":"# Get predictions","7e18cdd1":"get images, resize each image, add data augmentation and normalize image tensors","a9e17dc3":"# Train our model","dac30bd2":"split the data into training and validation sets","2fc583bb":"downloading trained CNNs as feature extractor: inception, resnet50","2c0d74f8":"# Extracting feature using various pretrained CNN","14cfc9d3":"# Get the data"}}