{"cell_type":{"43ff50cf":"code","255a476a":"code","ba7c33fb":"code","0212c9ff":"code","9217b4b5":"code","299ac39d":"code","8858e13a":"code","c585730a":"code","cff30723":"code","e281e3e6":"code","3c33d8bb":"code","dbe7462e":"code","ec72a019":"code","587cfff0":"code","46eceb8e":"code","18c7e98a":"code","96d274ba":"code","2a125e79":"code","1f4052be":"code","59511d54":"code","840b82ba":"code","272236cb":"code","65f89ad4":"code","d8a695bf":"code","a65795f9":"code","e10cd045":"code","07f09e87":"code","33940a65":"code","29833d24":"code","11797fb6":"code","6c582495":"code","566e666d":"code","4837e2a5":"code","74a54f73":"code","08fd2003":"code","593a63b6":"code","aa89df1a":"code","80fa3562":"code","8e13c8b0":"code","55a62bd2":"code","fd8bda9b":"code","cf799673":"code","661c7558":"markdown","79060549":"markdown","6364e41d":"markdown","cb33da9f":"markdown","d0710efd":"markdown","1a28191e":"markdown","386b52ef":"markdown","f0f57e5c":"markdown","f1f311dc":"markdown","b11d4be5":"markdown","99f1fecd":"markdown","ba51056e":"markdown","ea894df6":"markdown","859e3dac":"markdown","af86802f":"markdown"},"source":{"43ff50cf":"import numpy as np\nimport pandas as pd\n\n# import sklearn\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.metrics import mean_squared_error\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","255a476a":"train_data_no_name = pd.read_csv(\"..\/input\/nasa-cmaps\/CMaps\/train_FD001.txt\", sep = \"\\s+\", header = None)\ntest_data_no_name = pd.read_csv(\"..\/input\/nasa-cmaps\/CMaps\/test_FD001.txt\", sep = \"\\s+\", header = None)\ntrue_rul_no_name = pd.read_csv('..\/input\/nasa-cmaps\/CMaps\/RUL_FD001.txt', sep = '\\s+', header = None)","ba7c33fb":"# Let's add columns' names for better identification\ncolumns = {0:'engineNumber',1:'cycleNumber',2:'opSetting1',3:'opSetting2',4:'opSetting3',5:'sensor1',6:'sensor2',\n           7:'sensor3',8:'sensor4',9:'sensor5',10:'sensor6',11:'sensor7',12:'sensor8',13:'sensor9',14:'sensor10',\n           15:'sensor11',16:'sensor12',17:'sensor13',18:'sensor14',19:'sensor15',20:'sensor16',\n           21:'sensor17',22:'sensor18',23:'sensor19',24:'sensor20',25:'sensor21'}","0212c9ff":"train_data = train_data_no_name.rename(columns=columns)\ntest_data = test_data_no_name.rename(columns=columns)\ntrue_rul = true_rul_no_name.rename(columns={0: 'RUL'})\ntrain_data.describe()\n#test_data.describe()","9217b4b5":"true_rul.describe()","299ac39d":"# How many engines are there?\nnum_machines = np.unique(train_data['engineNumber']).shape[0]\nnum_machines","8858e13a":"# After how many cycles does each engine fail?\nnum_cycles_to_failure = train_data.groupby('engineNumber')['cycleNumber'].count()\nnum_cycles_to_failure[:10]","c585730a":"# After how many cycles does engine 100 fail?\nnum_cycles_to_failure[-1:]","cff30723":"columns_to_keep = ['cycleNumber', 'sensor2', 'sensor3', 'sensor4', 'sensor7', 'sensor8', 'sensor9',\n                   'sensor11', 'sensor12', 'sensor13', 'sensor14', 'sensor15',\n                   'sensor17', 'sensor20', 'sensor21']\n\ncolumns_to_drop=['opSetting1', 'opSetting2', 'opSetting3',\n                 'sensor1','sensor5','sensor6','sensor10','sensor16','sensor18', 'sensor19']","e281e3e6":"train_data_ = train_data.drop(columns=columns_to_drop) #.values\ntest_data_  = test_data.drop(columns=columns_to_drop)","3c33d8bb":"train_data_.head()","dbe7462e":"# Linear degradation model\ndef process_targets_linear(data_length):\n    \"\"\" \n    Takes datalength (i.e., total number of cycles for each engine) and decrement 1 per cycle (row)\n    \"\"\"\n    return np.arange(data_length-1, -1, -1)","ec72a019":"# Test for a single engine\nengine_100_linear_degradation_model = np.arange(192-1, -1, -1)\nengine_number = 100\n\nengine_100_cycles_to_failure = train_data.groupby('engineNumber')['cycleNumber'].count().iloc[engine_number-1]\nengine_100_linear_degradation_model = process_targets_linear(engine_100_cycles_to_failure)\n","587cfff0":"# Piecewise linear degradation model if early_rul is provided\n#  Otherwise the output is the linear degradation model\ndef process_targets_RUL(data_length, early_rul = None):\n    \"\"\" \n    Takes datalength and earlyrul as input and \n    creates target rul.\n    \"\"\"\n    if early_rul == None:\n        return np.arange(data_length-1, -1, -1)\n    else:\n        early_rul_duration = data_length - early_rul\n        if early_rul_duration <= 0:\n            return np.arange(data_length-1, -1, -1)\n        else:\n            return np.append(early_rul*np.ones(shape = (early_rul_duration,)), np.arange(early_rul-1, -1, -1))","46eceb8e":"# Parameter for RUL piecewise linear model\nearly_rul = 125\n\n# Test for a single engine\nengine_100_linear_degradation_model = process_targets_RUL(engine_100_cycles_to_failure)\nengine_100_piecewise_degradation_model = process_targets_RUL(engine_100_cycles_to_failure, early_rul = early_rul)","18c7e98a":"plt.figure(figsize = (18, 6))\nplt.subplot(121)\nplt.plot(engine_100_linear_degradation_model)\nplt.title(\"Linear degradation (engine 100, 200 cycles)\")\nplt.xlabel(\"cycle number\")\nplt.ylabel(\"RUL\")\nplt.grid()\n\nplt.subplot(122)\nplt.plot(engine_100_piecewise_degradation_model)\nplt.title(\"Piecewise linear degradation (engine 100, 200 cycles)\")\nplt.xlabel(\"cycle number\")\nplt.ylabel(\"RUL\")\nplt.grid()\n\nplt.show()","96d274ba":"\n# How many rows to use for each machine in the testa data\n#   - We take those rows from the tail of data, i.e. points closer to the failure\nnum_test_rows = 5\n\n# Let's create empty output dataframes\nprocessed_train_data = pd.DataFrame(columns = train_data_.columns)\nprocessed_train_targets = pd.DataFrame(columns = ['RUL'])\nprocessed_test_data = pd.DataFrame(columns = train_data_.columns)\n\nfor i in np.arange(1, num_machines + 1):\n    # Extract dataset for machine i\n    i_train_data = train_data_[train_data_['engineNumber'] == i]  \n    # Create the target column (RUL): Choose one of two\n    # ------------------------- Linear degradation model --------------------------------------------\n    #i_train_targets = process_targets_RUL(data_length = i_train_data.shape[0])\n    # ------------------------- Piecewise linear model ----------------------------------------------\n    i_train_targets = process_targets_RUL(data_length = i_train_data.shape[0], early_rul = early_rul)\n    \n    # You ca optionally add RUL column to train dataframe\n    #i_train_data['RUL'] = i_train_targets.tolist()\n    \n    # Convert to dataframe\n    i_train_targets = pd.DataFrame(data=i_train_targets, columns=['RUL']) \n    \n    # Process test data\n    i_test_data  = test_data_[test_data_['engineNumber'] == i].iloc[-num_test_rows:, :]\n    \n    # Append to output dataframes\n    processed_train_targets = processed_train_targets.append(i_train_targets, ignore_index=True)\n    processed_test_data = processed_test_data.append(i_test_data, ignore_index=True)\n    #true_rul = true_rul[0].values","2a125e79":"# Train data did not need that transformation\nprocessed_train_data = train_data_\nprint(train_data_.shape, processed_train_data.shape, processed_train_data.equals(train_data_))","1f4052be":"# Target has the same number of rows than processed_train_data\nprocessed_train_targets.shape","59511d54":"plt.figure(figsize = (18, 6))\nplt.plot(processed_train_targets[:10334])\nplt.title(\"Degradation model for first half of all engines\")\nplt.xlabel(\"cycle number\")\nplt.ylabel(\"RUL\")\nplt.grid()","840b82ba":"plt.figure(figsize = (18, 6))\nplt.plot(processed_train_targets[10335:])\nplt.title(\"Degradation model for second half of all engines\")\nplt.xlabel(\"cycle number\")\nplt.ylabel(\"RUL\")\nplt.grid()","272236cb":"# In test data, we retain last 5 cycles of each of the 100 machine\nprint(test_data_.shape, processed_test_data.shape)","65f89ad4":"# Build the model, train it and predict for the test set\nrf_model = RandomForestRegressor(n_estimators= 300, max_features = \"sqrt\",\n                                 n_jobs = -1, random_state = 38)\n# rf_model.fit(processed_train_data.drop(columns= ['engineNumber','cycleNumber']), processed_train_targets)\nrf_model.fit(processed_train_data.drop(columns= ['engineNumber','cycleNumber']), processed_train_targets)\nrul_pred = rf_model.predict(processed_test_data.drop(columns= ['engineNumber','cycleNumber']))","d8a695bf":"# Prediction for the TRAIN data, last 5 cycles to failure\nrul_pred_train = rf_model.predict(processed_train_data.drop(columns= ['engineNumber','cycleNumber']))\nrul_pred_train[187:195] # Machine 1\n#rul_pred_train[-5:] # Machine 100\n\nprint(\"Machine 1 RUL\", rul_pred_train[187:192])\nprint(\"Machine 2 RUL\", rul_pred_train[192+287-5:192+287])\nprint(\"...\")\nprint(\"Machine 100 RUL\", rul_pred_train[-5:])","a65795f9":"# Prediction for the TEST data\nprint(\"Machine 1 pred.\", rul_pred[:5], \"\\t RUL at last cycle\", \"{:.2f}\".format(rul_pred[5-1]) )\nprint(\"Machine 2 pred.\", rul_pred[5:10], \"\\t RUL at last cycle\", \"{:.2f}\".format(rul_pred[10-1]) )\nprint(\"Machine 3 pred.\", rul_pred[11:15], \"\\t\\t\\t RUL at last cycle\", \"{:.2f}\".format(rul_pred[15-1]) )\nprint(\"Machine 4 pred.\", rul_pred[16:20], \"\\t\\t\\t RUL at last cycle\", \"{:.2f}\".format(rul_pred[20-1]) )\nprint(\"Machine 5 pred.\", rul_pred[21:25], \"\\t\\t\\t RUL at last cycle\", \"{:.2f}\".format(rul_pred[21-1]) )\nprint(\"...\")\nprint(\"Machine 100 RUL\", rul_pred[495:500], \"\\t\\t RUL at last cycle\", \"{:.2f}\".format(rul_pred[500-1]) )","e10cd045":"# Comparison with true RUL\nprint(\"Machine 1 pred.\", \"{:.2f}\".format(rul_pred[5-1]) , \"\\t true RUL\", true_rul.iloc[0].squeeze() )\nprint(\"Machine 2 pred.\", \"{:.2f}\".format(rul_pred[10-1]), \"\\t true RUL\", true_rul.iloc[1].squeeze() )\nprint(\"Machine 3 pred.\", \"{:.2f}\".format(rul_pred[15-1]), \"\\t true RUL\", true_rul.iloc[2].squeeze() )\nprint(\"Machine 4 pred.\", \"{:.2f}\".format(rul_pred[20-1]), \"\\t true RUL\", true_rul.iloc[3].squeeze() )\nprint(\"Machine 5 pred.\", \"{:.2f}\".format(rul_pred[21-1]), \"\\t true RUL\", true_rul.iloc[4].squeeze() )\nprint(\"...\")\nprint(\"Machine 100 RUL\", \"{:.2f}\".format(rul_pred[500-1]), \"\\t true RUL\", true_rul.iloc[99].squeeze() )","07f09e87":"# The prediction array is a column vector with 100 nachinex x 5 predictions each = 500 itens\nrul_pred.shape","33940a65":"# First split predictions according to number of cycles (last ones) of each engine\n#  - Take each group of rows (up to 100), and transpose the column vector to a row vector\npreds_for_each_engine = np.split(rul_pred, true_rul.shape[0]) # Split by 100 machines (groups of 100 rows)\npreds_for_each_engine = np.array(preds_for_each_engine)\nprint(\"Shape of preds_for_each_engine array\", np.array(preds_for_each_engine).shape)","29833d24":"# Last column contains the last cycle prediction for each engine\nlast_cycle_RUL = preds_for_each_engine[:, preds_for_each_engine.shape[1]-1] # preds_for_each_engine.shape[1] -1 = index of last column, i.e. 4\nlast_cycle_RUL.shape","11797fb6":"true_rul_np = np.array(true_rul)[:,0]\ntrue_rul_np.shape","6c582495":"# Plot true and predicted RUL values\nplt.figure(figsize = (22, 8))\n\nplt.plot(true_rul_np, label = \"True RUL\", color = \"red\", marker=\"3\")\nplt.plot(last_cycle_RUL, label = \"Pred RUL\", color = \"green\")\nplt.ylabel('Remaining Useful Life')\nplt.xlabel('Machine number')\nplt.legend()\nplt.show()","566e666d":"RMSE = np.sqrt(((true_rul_np - last_cycle_RUL) ** 2).mean())\nprint(\"RMSE is\", \"{:.2f}\".format(RMSE), \n      \"cycles, percentage {:.2f}\".format(RMSE\/processed_train_targets.mean()[0]*100),  \"% over mean RUL of 100 engines\" )","4837e2a5":"# RUL prediction error per machine\nRUL_pred_error = last_cycle_RUL - true_rul_np","74a54f73":"fig, ax1 = plt.subplots(figsize=(22,6))\n\nax2 = ax1.twinx()\nax1.plot(RUL_pred_error, 'bx')\nax1.grid()\nax2.plot(true_rul_np, 'r--')\n\nax1.set_xlabel('Machine number')\nax1.set_ylabel('Error per machine (cycles)', color='b')\nax2.set_ylabel('Remaining Useful Life (true RUL)', color='r')\n\nplt.show()","08fd2003":"plt.figure(figsize = (20, 6))\nsns.distplot(true_rul_np, bins = 30, kde= True, color = 'red', rug=True, label=\"Test (true) RUL\")\nsns.distplot(processed_train_targets, bins = 30, kde= True, color = 'grey', rug=True, label=\"Train RUL\")\n\nplt.xlim()\nplt.xlabel('Number of cycles to failure')\nplt.title('Test (true) vs. training RUL distribution for 100 engines')\nplt.legend()\nplt.show()","593a63b6":"plt.figure(figsize = (20, 6))\nsns.distplot(true_rul_np, bins = 40, kde= True, color = 'red', rug=True, label=\"Test (true) RUL\")\nsns.distplot(last_cycle_RUL, bins = 40, kde= True, color = 'green', rug=True, label=\"Predicted RUL\")\nplt.xlim()\nplt.xlabel('Number of cycles to failure')\nplt.title('True vs. predicted RUL distribution for 100 engines')\nplt.legend()\nplt.show()","aa89df1a":"plt.figure(figsize = (20, 6))\nsns.distplot(RUL_pred_error, bins = 40, kde= True, color = 'blue', rug=True)\nplt.xlim()\nplt.xlabel('Absolute RUL error (cycles)')\nplt.title('RUL prediction error distribution for 100 engines')\nplt.show()","80fa3562":"plt.figure(figsize = (20, 6))\nsns.distplot(RUL_pred_error\/true_rul_np*100, bins = 40, kde= True, color = 'orange', rug=True)\nRUL_pred_error = (last_cycle_RUL - true_rul_np) # \nplt.xlim()\nplt.xlabel('Relative RUL error (%)')\nplt.title('RUL prediction error distribution for 100 engines')\nplt.show()","8e13c8b0":"feature_importance = rf_model.feature_importances_\nfeature_importance.sum()","55a62bd2":"# Sort features by descending importance\nindices = np.argsort(feature_importance)[::-1]\n#processed_train_data.drop(columns= ['engineNumber','cycleNumber']).shape[1]\n\nnum_features = feature_importance.shape[0]","fd8bda9b":"feature_names = {0:'sensor2', 1:'sensor3', 2:'sensor4', 3:'sensor7', 4:'sensor8',\n                 5:'sensor9', 6:'sensor11', 7:'sensor12', 8:'sensor13', 9:'sensor14',\n                 10:'sensor15', 11:'sensor17', 12:'sensor20', 13:'sensor21'}\n\n# Reorder dict by descending feature importance\nfor key in indices:\n    feature_names[key] = feature_names.pop(key)\n\nfeatures = list(feature_names.values())","cf799673":"plt.figure(figsize = (16, 8))\nplt.title(\"Feature importances\")\n\nplt.bar(range(num_features), feature_importance[indices]*100,\n        color=\"blue\", align=\"center\")\nplt.xticks(range(num_features), features)\nplt.xlim([-1, num_features])\nplt.ylabel('% importance')\n#plt.xlabel(\"Feature Columns\")\nplt.show()","661c7558":"## Piecewise linear degradation model","79060549":"This dataset has 26 columns (as well as the datasets for the other 3 scenarios). Because of Python's numbering convention, the columns are numbered from 0 to 25. Description of each column is as follows:\n\n* `Column 1`: Corresponds to engine number (This column is indexed 0 because of Python's numbering convention)\n* `Column 2`: Corresponds to cycle number. If engine 1 fails after 192 cycles, the entries of second column for engine 1 will go from 1 to 192. Similarly for other engines. \n* `Columns 3,4,5`: 3 operational settings\n* `Columns 6-26`: 21 sensor measurements\n\n**Note**: Hence, we will always refer to the first column as column 1 even though it is indexed as 0 in Python. Similarly for other columns.","6364e41d":"## Compare train & test RUL distributions","cb33da9f":"## Plot true RUL vs. prediction","d0710efd":"## Error evaluation","1a28191e":"## Linear degradation model","386b52ef":"Let's plot them together:","f0f57e5c":"## Prepare data to build a RUL graph of all engines","f1f311dc":"# Data description","b11d4be5":"# Feature importance","99f1fecd":"# Random forest analysis","ba51056e":"## Evaluate the model","ea894df6":"# Dataset simplification\nRefer to Notebook [NASA_Turbofan_ExploratoryAnalysis](https:\/\/www.kaggle.com\/brjapon\/nasa-turbofan-exploratoryanalysis) for the EDA in which this simplification is based on.","859e3dac":"# RUL degradation models","af86802f":"## RUL error distribution"}}