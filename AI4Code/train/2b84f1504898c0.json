{"cell_type":{"6f1a3f00":"code","4c752f4b":"code","bfe45b9d":"code","b0eb0ffc":"code","51eae720":"code","ebfc7e82":"code","950c16ac":"code","21fb5c78":"code","8a007398":"code","9593cd2b":"code","6481c620":"code","64ce1911":"code","922e32ea":"code","e1ae4bf5":"code","2a3c84ac":"code","a9edc565":"code","09468c06":"code","40f3dccd":"code","33585eaf":"code","edb2bdf4":"code","82e8b9cd":"code","3d155dcf":"code","0562277c":"code","6304f427":"markdown","a4c47e34":"markdown","d77eaccc":"markdown","d1abc4ca":"markdown","8fcb4a3e":"markdown","66ce0e69":"markdown","5f771fe8":"markdown","4f0b128f":"markdown","9227b6f0":"markdown","1d2e09b9":"markdown","f48809bd":"markdown","f12b4693":"markdown","e05f550b":"markdown","2d410d6b":"markdown","5e6b5903":"markdown","760c1e37":"markdown","6047d2a7":"markdown","06d00ec2":"markdown","51bdfc12":"markdown","c26a5143":"markdown","40343d0f":"markdown","6be6b836":"markdown","90a137e2":"markdown","d5352a7c":"markdown","1ff983ce":"markdown","a9d69d42":"markdown","b051b112":"markdown","de9ba7dc":"markdown","a9dc29f1":"markdown","6e4255cf":"markdown","9a3de3e5":"markdown","681e3b25":"markdown","00ffed90":"markdown","97cab458":"markdown","7890a90f":"markdown","a1a908e1":"markdown","dd1551b6":"markdown"},"source":{"6f1a3f00":"%%HTML\n<iframe width=\"560\" height=\"315\" src=\"https:\/\/www.youtube.com\/embed\/uJEZC1SM0P0\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>","4c752f4b":"!pip install -q --upgrade pip\n!pip install -q efficientnet","bfe45b9d":"import re\nimport os\nimport numpy as np\nimport pandas as pd\nimport tensorflow as tf\nfrom functools import partial\nimport efficientnet.tfkeras as efn\nfrom kaggle_datasets import KaggleDatasets\nfrom sklearn.model_selection import train_test_split","b0eb0ffc":"try:\n    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n    print('Device:', tpu.master())\n    tf.config.experimental_connect_to_cluster(tpu)\n    tf.tpu.experimental.initialize_tpu_system(tpu)\n    strategy = tf.distribute.experimental.TPUStrategy(tpu)\nexcept:\n    strategy = tf.distribute.get_strategy()\nprint('Number of replicas:', strategy.num_replicas_in_sync)","51eae720":"AUTOTUNE = tf.data.experimental.AUTOTUNE\nGCS_PATH = KaggleDatasets().get_gcs_path('siim-isic-melanoma-classification')\nBATCH_SIZE = 8 * strategy.num_replicas_in_sync\nIMAGE_SIZE = [1024, 1024]","ebfc7e82":"TRAINING_FILENAMES, VALID_FILENAMES = train_test_split(\n    tf.io.gfile.glob(GCS_PATH + '\/tfrecords\/train*.tfrec'),\n    test_size=0.1, random_state=42\n)\nTEST_FILENAMES = tf.io.gfile.glob(GCS_PATH + '\/tfrecords\/test*.tfrec')\nprint('Train TFRecord Files:', len(TRAINING_FILENAMES))\nprint('Validation TFRecord Files:', len(VALID_FILENAMES))\nprint('Test TFRecord Files:', len(TEST_FILENAMES))","950c16ac":"def decode_to_tensor(image):\n    image = tf.image.decode_jpeg(image, channels=3)\n    image = tf.cast(image, tf.float32) \/ 255.0\n    image = tf.reshape(image, [*IMAGE_SIZE, 3])\n    return image","21fb5c78":"def read_tfrecord(example, labeled):\n    tfrecord_format = {\n        \"image\": tf.io.FixedLenFeature([], tf.string),\n        \"target\": tf.io.FixedLenFeature([], tf.int64)\n    } if labeled else {\n        \"image\": tf.io.FixedLenFeature([], tf.string),\n        \"image_name\": tf.io.FixedLenFeature([], tf.string)\n    }\n    example = tf.io.parse_single_example(example, tfrecord_format)\n    image = decode_to_tensor(example['image'])\n    if labeled:\n        label = tf.cast(example['target'], tf.int32)\n        return image, label\n    idnum = example['image_name']\n    return image, idnum","8a007398":"def load_dataset(filenames, labeled=True, ordered=False):\n    ignore_order = tf.data.Options()\n    if not ordered:\n        ignore_order.experimental_deterministic = False # disable order, increase speed\n    dataset = tf.data.TFRecordDataset(filenames, num_parallel_reads=AUTOTUNE) # automatically interleaves reads from multiple files\n    dataset = dataset.with_options(ignore_order) # uses data as soon as it streams in, rather than in its original order\n    dataset = dataset.map(partial(read_tfrecord, labeled=labeled), num_parallel_calls=AUTOTUNE)\n    # returns a dataset of (image, label) pairs if labeled=True or (image, id) pairs if labeled=False\n    return dataset","9593cd2b":"def augmentation_pipeline(image, label):\n    image = tf.image.random_flip_left_right(image)\n    return image, label","6481c620":"def get_training_dataset():\n    dataset = load_dataset(TRAINING_FILENAMES, labeled=True)\n    dataset = dataset.map(augmentation_pipeline, num_parallel_calls=AUTOTUNE)\n    dataset = dataset.repeat()\n    dataset = dataset.shuffle(2048)\n    dataset = dataset.batch(BATCH_SIZE)\n    dataset = dataset.prefetch(AUTOTUNE)\n    return dataset","64ce1911":"def get_validation_dataset(ordered=False):\n    dataset = load_dataset(VALID_FILENAMES, labeled=True, ordered=ordered)\n    dataset = dataset.batch(BATCH_SIZE)\n    dataset = dataset.cache()\n    dataset = dataset.prefetch(AUTOTUNE)\n    return dataset","922e32ea":"def get_test_dataset(ordered=False):\n    dataset = load_dataset(TEST_FILENAMES, labeled=False, ordered=ordered)\n    dataset = dataset.batch(BATCH_SIZE)\n    dataset = dataset.prefetch(AUTOTUNE)\n    return dataset","e1ae4bf5":"def count_data_items(filenames):\n    n = [int(re.compile(r\"-([0-9]*)\\.\").search(filename).group(1)) for filename in filenames]\n    return np.sum(n)","2a3c84ac":"NUM_TRAINING_IMAGES = count_data_items(TRAINING_FILENAMES)\nNUM_VALIDATION_IMAGES = count_data_items(VALID_FILENAMES)\nNUM_TEST_IMAGES = count_data_items(TEST_FILENAMES)\nSTEPS_PER_EPOCH = NUM_TRAINING_IMAGES \/\/ BATCH_SIZE\nprint(\n    'Dataset: {} training images, {} validation images, {} unlabeled test images'.format(\n        NUM_TRAINING_IMAGES, NUM_VALIDATION_IMAGES, NUM_TEST_IMAGES\n    )\n)","a9edc565":"def build_lrfn(lr_start=0.00001, lr_max=0.000075, lr_min=0.000001, lr_rampup_epochs=20, lr_sustain_epochs=0, lr_exp_decay=.8):\n    lr_max = lr_max * strategy.num_replicas_in_sync\n    def lrfn(epoch):\n        if epoch < lr_rampup_epochs:\n            lr = (lr_max - lr_start) \/ lr_rampup_epochs * epoch + lr_start\n        elif epoch < lr_rampup_epochs + lr_sustain_epochs:\n            lr = lr_max\n        else:\n            lr = (lr_max - lr_min) * lr_exp_decay ** (epoch - lr_rampup_epochs - lr_sustain_epochs) + lr_min\n        return lr\n    return lrfn","09468c06":"with strategy.scope():\n    \n    train_dataset = get_training_dataset()\n    valid_dataset = get_validation_dataset()\n    \n    model = tf.keras.Sequential([\n        efn.EfficientNetB6(\n            input_shape=(*IMAGE_SIZE, 3),\n            weights='imagenet',\n            include_top=False\n        ),\n        tf.keras.layers.GlobalAveragePooling2D(),\n        tf.keras.layers.Dense(512, activation= 'relu'), \n        tf.keras.layers.Dropout(0.25), \n        tf.keras.layers.Dense(1, activation='sigmoid')\n    ])\n    \n    model.compile(\n        optimizer='adam',\n        loss = 'binary_crossentropy',\n        metrics=['accuracy']\n    )\n\nmodel.summary()","40f3dccd":"lrfn = build_lrfn()\nSTEPS_PER_EPOCH = NUM_TRAINING_IMAGES \/\/ BATCH_SIZE\nVALID_STEPS = NUM_VALIDATION_IMAGES \/\/ BATCH_SIZE\n\n\nhistory = model.fit(\n    train_dataset, epochs=1,\n    steps_per_epoch=STEPS_PER_EPOCH,\n    validation_data=valid_dataset,\n    validation_steps=VALID_STEPS,\n    callbacks=[\n        tf.keras.callbacks.LearningRateScheduler(lrfn, verbose=1),\n        tf.keras.callbacks.ModelCheckpoint(\n            os.path.join(\".\/model.h5\"),\n            monitor='train_loss', verbose=0,\n            save_best_only=True, save_weights_only=False,\n            mode='auto', save_freq='epoch'\n        )\n    ]\n)","33585eaf":"sub = pd.read_csv('\/kaggle\/input\/siim-isic-melanoma-classification\/sample_submission.csv')\nsub.head()","edb2bdf4":"test_ds = get_test_dataset(ordered=True)\n\nprint('Computing predictions...')\ntest_images_ds = test_ds.map(lambda image, idnum: image)\nprobabilities = model.predict(test_images_ds)","82e8b9cd":"print('Generating submission.csv file...')\ntest_ids_ds = test_ds.map(lambda image, idnum: idnum).unbatch()\ntest_ids = next(iter(test_ids_ds.batch(NUM_TEST_IMAGES))).numpy().astype('U')","3d155dcf":"pred_df = pd.DataFrame({'image_name': test_ids, 'target': np.concatenate(probabilities)})\npred_df.head()","0562277c":"del sub['target']\nsub = sub.merge(pred_df, on='image_name')\nsub.to_csv('submission.csv', index=False)\nsub.head()","6304f427":"\ud83d\udccc **TPU Initialization:** TPUs  are usually on Cloud TPU workers and hence have to be connected to remote clusters and then initialized .\n\n\ud83d\udccc **Distribution strategies :** A distribution strategy is an abstraction that can be used to drive models on CPU, GPUs or TPUs. ","a4c47e34":"\ud83d\udccc **EfficientNet Performance**\n\n<div class=\"alert alert-block alert-info\">\n<b>Note:<\/b>\nThe EfficientNet models achieve both higher accuracy and better efficiency over existing CNNs like ResNet , DenseNet etc , reducing parameter size and FLOPS by an order of magnitude. <code><\/code> \n<\/div>\n","d77eaccc":"![](https:\/\/drive.google.com\/uc?id=1qomd1gdCbw7CA-vdlqtBWAYqsU6-aCtN)\n\nImage Source : mc.ai","d1abc4ca":"**_Note: If you like this kernel and\/or choose to fork it, please appreciate the hard work by up-voting the kernel with the <kbd>^<\/kbd> button above._**\n\nFollow me on Twitter @Urengaraju\n","8fcb4a3e":"Tensor Processing Units (TPUs) are Google's custom-developed application-specific integrated circuits (ASICs) used to accelerate machine learning workloads.It's easy to run replicated models on Cloud TPU using High-level Tensorflow APIs .\n","66ce0e69":"**EfficientNet Architecture :**\n\nThe effectiveness of model scaling also relies heavily on the baseline network which  is developed by performing a neural architecture search using the AutoML MNAS framework, which optimizes both accuracy and efficiency (FLOPS). The resulting architecture uses mobile inverted bottleneck convolution (MBConv), similar to MobileNetV2 and MnasNet, but is slightly larger due to an increased FLOP budget.The baseline network is then scaled up to obtain a family of models, called EfficientNets.","5f771fe8":"![](https:\/\/drive.google.com\/uc?id=10r4NCvxUdK6IhEFWI1UxwVUY4PYYMMVG)","4f0b128f":"# References :\n\nhttps:\/\/www.kaggle.com\/mgornergoogle\/getting-started-with-100-flowers-on-tpu\n\nhttps:\/\/www.tensorflow.org\/tutorials\/load_data\/tfrecord\n\nhttps:\/\/cloud.google.com\/tpu\n\nhttps:\/\/www.tensorflow.org\/guide\/tpu\n\nhttps:\/\/www.tensorflow.org\/tutorials\/images\/data_augmentation\n\nhttps:\/\/ai.googleblog.com\/2019\/05\/efficientnet-improving-accuracy-and.html\n\n","9227b6f0":"# **SIIM**\n\n\nThe Society for Imaging Informatics in Medicine (SIIM) is the leading healthcare professional organization for those interested in the current and future use of informatics in medical imaging. The society's mission is to advance medical imaging informatics across the enterprise through education, research, and innovation in a multi-disciplinary community","1d2e09b9":"![](https:\/\/drive.google.com\/uc?id=1bnsglJByd1lc1h9hGrz2WZa1LzVBgtWW)\n\nImage Source : https:\/\/arxiv.org\/abs\/1803.09820","f48809bd":"![](https:\/\/drive.google.com\/uc?id=1-EAdsgcuVsFKO1ru00TTrKePRnv-6FHv)","f12b4693":"\ud83d\udccc **Cyclic learning rates :**\n\n<div class=\"alert alert-block alert-info\">\nCyclic learning rates  is a learning rate scheduling technique for (1) faster training of a network and (2) a finer understanding of the optimal learning rate. Cyclic learning rates have an effect on the model training process known somewhat fancifully as<code>\"superconvergence\"<\/code> \n<\/div>\n\nSource : @residentmario Notebook","e05f550b":"![](https:\/\/drive.google.com\/uc?id=18ZzZw0U-4O4iPe1JBVZwUVcn4FCmTS_x)","2d410d6b":"# TF Records :\n\n\ud83d\udcccTF-Record is Tensorflow\u2019s own binary storage format.\n\n\ud83d\udcccAny byte-string that can be decoded in TensorFlow could be stored in a TFRecord file. Examples include: Lines of text, JSON ,encoded image data, or serialized tf.Tensors .\n\n\ud83d\udcccA TFRecord file contains a sequence of records and can only be read sequentially.Each record contains a byte-string, for the data-payload, plus the data-length, and CRC32C (32-bit CRC using the Castagnoli polynomial) hashes for integrity checking.\n","5e6b5903":"\ud83d\udcccThe tf.data API enables you to build complex input pipelines from simple, reusable pieces. The tf.data API also makes it possible to handle large amounts of data, read from different data formats, and perform complex transformations.\n\n\ud83d\udcccThe tf.data API introduces a tf.data.Dataset abstraction that represents a sequence of elements, in which each element consists of one or more components. For example, in an image pipeline, an element might be a single training example, with a pair of tensor components representing the image and its label.\n\n\ud83c\udfaf **Input Pipeline :**\n\n tf.data.TFRecordDataset() is used to create an input pipeline for data stored in TFRecord format .\n \n\ud83c\udfaf **Transformations :**\n\nThe Dataset object can be transformed into a new Dataset by chaining method calls on the tf.data.Dataset object . Some of the transformations which can be applied are Dataset.map() , Dataset.batch() , Dataset.shuffle() , Dataset.prefetch() .\n\nThe Dataset object is a Python iterable which  it possible to consume its elements using a for loop .\n","760c1e37":"![](https:\/\/drive.google.com\/uc?id=1jYu8AMPI9LVF2TQKUgJyKZaZqpsm3U0k)\n\nImage Source : EfficientNet Research Paper","6047d2a7":"Follow me on Twitter @Urengaraju","06d00ec2":"# TPU\n\n\n![](https:\/\/drive.google.com\/uc?id=1q6AUi9XZRRWBjov49PSl3thB9idGsUKV)","51bdfc12":"# **ISIC :**\n\nThe International Skin Imaging Collaboration: Melanoma Project is an academia and industry partnership designed to facilitate the application of digital skin imaging to help reduce melanoma mortality. When recognized and treated in its earliest stages, melanoma is readily curable. Digital images of skin lesions can be used to educate professionals and the public in melanoma recognition as well as directly aid in the diagnosis of melanoma through teledermatology, clinical decision support, and automated diagnosis.\n","c26a5143":"# **Installing the Libraries**","40343d0f":"![](https:\/\/drive.google.com\/uc?id=11uCu4Bl5YHEi_xcfZ1Q86W3sOhJ6tvLy)","6be6b836":"# TF-Data\n\n![](https:\/\/drive.google.com\/uc?id=10M07nrMGrKKVP0KGwAqsm7oNK1mXexsD)","90a137e2":"# Performance : \n\nTPU can achieve a high computational throughput on massive multiplications and additions for neural networks , at blazingly fast speeds with much less power consumption and smaller footprint.\n","d5352a7c":"![](https:\/\/drive.google.com\/uc?id=18f8gdJOsNad_ZBESxhxxo2SVIf-IaYGR)","1ff983ce":"# **Problem Statement :**\n\nIn this workshop , you\u2019ll identify melanoma in images of skin lesions and you\u2019ll use images within the same patient and determine which are likely to represent a melanoma. Using patient-level contextual information may help the development of image analysis tools, which could better support clinical dermatologists.\n","a9d69d42":"![](https:\/\/drive.google.com\/uc?id=1_uGNygnCZ--G_hOP7zEr_oscGjvnBnob)\n\nImage Source : medium.com","b051b112":"# **Skin Cancer :**\n\nSkin cancer is the most prevalent type of cancer. Melanoma, specifically, is responsible for 75% of skin cancer deaths, despite being the least common skin cancer. The American Cancer Society estimates over 100,000 new melanoma cases will be diagnosed in 2020. It's also expected that almost 7,000 people will die from the disease. As with other cancers, early and accurate detection\u2014potentially aided by data science\u2014can make treatment more effective.\n","de9ba7dc":"Credit : The code has been adapted from @mgornergooglestater kernel on Flower classification on TPUs","a9dc29f1":"![](https:\/\/drive.google.com\/uc?id=15QPJMCidq3gQM8oCZ6NNlRQHnImV28wP)","6e4255cf":"![](https:\/\/drive.google.com\/uc?id=1CLfEMEn9uiPGjhgVZc620djKmBQrwSZV)","9a3de3e5":"![](https:\/\/drive.google.com\/uc?id=1x383ghyybTV0jQqBSlHDEc8FWD8AqaHz)\n","681e3b25":"# EfficientNets\n\n**Compound Model Scaling: A Better Way to Scale Up CNNs**\n\nEfficientNets uses a new scaling method that uniformly scales all dimensions of depth\/width\/resolution using a simple yet highly effective compound coefficient The first step in the compound scaling method is to perform a grid search to find the relationship between different scaling dimensions of the baseline network under a fixed resource constraint.This determines the appropriate scaling coefficient for each of the dimensions mentioned above. We then apply those coefficients to scale up the baseline network to the desired target model size or computational budget.\n\nThis compound scaling method consistently improves model accuracy and efficiency for scaling up existing models such as MobileNet (+1.4% imagenet accuracy), and ResNet (+0.7%), compared to conventional scaling methods.\n\n","00ffed90":"![](https:\/\/drive.google.com\/uc?id=1KVGvxtN4XXvLbt3hCSSZBU04lv0LqgO-)","97cab458":"![](https:\/\/drive.google.com\/uc?id=1Yhk63WM5MCTj0KLhhdGeiXsp8oaSxhTK)\n\nImage Source : siim.org","7890a90f":"![](https:\/\/drive.google.com\/uc?id=1g8w3556Xxp_mKJZ7lH6b55AuNx_QIBr5)","a1a908e1":"# Data Augmentation :\n\n\ud83c\udfaf  Data augmentation is a technique through which one can increase the size of the data for the training of the model without adding the new data. Techniques like padding, cropping, rotating, and flipping are the most common methods that are used over the images to increase the data size. \n\n<div class=\"alert alert-block alert-info\">\n<b>Note:<\/b> Both <code>Keras Preprocessing Layers<\/code> and <code>tf.image<\/code> can be used for data augmentation. For finer control , <code>tf.image<\/code> is preferred.\n<\/div>\n","dd1551b6":"<div class=\"alert alert-block alert-info\">\n<b>Note:<\/b> TPUs read data directly from <code>Google Cloud Storage (GCS)<\/code> This Kaggle utility will copy the dataset to a GCS bucket co-located with the TPU. If you have multiple datasets attached to the notebook, you can pass the name of a specific dataset to the <code>get_gcs_path function<\/code>. The name of the dataset is the name of the directory it is mounted in. Use <code>!ls \/kaggle\/input\/<\/code> to list attached datasets.\n<\/div>"}}