{"cell_type":{"a00e5b20":"code","a1fb3477":"code","a41a7601":"code","ed302c4f":"code","f2343330":"code","ea045514":"code","6d23f639":"code","e0706d56":"code","5c76bd75":"code","76b78708":"code","d6911761":"code","a225ecad":"code","fc44428a":"code","550a3242":"code","993f0b2b":"code","3f31128b":"code","95d3e436":"code","3d47fc85":"code","985b66b5":"code","625c3f67":"code","36f7089a":"code","85bf19c1":"code","2399f30d":"code","299523a9":"code","fa6ebdb0":"code","34bafd14":"code","6dc1dcc0":"code","3fc367cd":"code","9df11191":"code","80922d13":"code","c97a2cbd":"code","6e5dd15c":"code","481c9767":"code","65d02ffd":"code","6d3d60b1":"code","bff7f351":"markdown","a24aed2a":"markdown","30959d47":"markdown","695136a2":"markdown","de468aee":"markdown","c6a65000":"markdown","8e6d2121":"markdown","bf0889a0":"markdown","0dffa293":"markdown","b827f103":"markdown","23316ddf":"markdown","22ed7c18":"markdown","aaba3672":"markdown","e6832a4c":"markdown","a15bb248":"markdown","540a53ac":"markdown"},"source":{"a00e5b20":"def get_soundex(word):\n    \n    # Change the word to Uppercase\n    word = word.upper()\n    \n    soundex = \"\"\n    \n    # Initialize a soundex variable - first alphabet of word\n    soundex += word[0]\n    \n    # Create a dictionary which maps letters to respective soundex codes. Vowels and 'H', 'W' and 'Y' will be represented by '.'\n    dictionary = {\"BFPV\": \"1\", \"CGJKQSXZ\":\"2\", \"DT\":\"3\", \"L\":\"4\", \"MN\":\"5\", \"R\":\"6\", \"AEIOUHWY\":\".\"}\n    \n    # Logic to prepare the soundex\n    for char in word[1:]:\n        for key in dictionary.keys():\n            if char in key:\n                code = dictionary[key] \n                if code != '.': \n                    if code != soundex[-1]: \n                        soundex += code\n    \n    # Trim or pad to make soundex a 4-character code\n    soundex = soundex[:4].ljust(4, \"0\")\n    \n    return soundex\n\nprint(\"Soundex Example :\", 1)\nprint(\"--------------------\")\nprint(\"Aggrawal :\", get_soundex(\"Aggrawal\"))\nprint(\"Agrawal  :\", get_soundex(\"Agrawal\"))\nprint(\"Aggarwal :\", get_soundex(\"Aggarwal\"))\nprint(\"Agarwal  :\", get_soundex(\"Agarwal\"))\nprint('\\n')\nprint(\"Soundex Example :\", 2)\nprint(\"--------------------\")\nprint(\"Bombay   :\", get_soundex(\"Bombay\"))\nprint(\"Bambai   :\", get_soundex(\"Bambai\"))\nprint(\"Mumbai   :\", get_soundex(\"Mumbai\"))","a1fb3477":"def lev_distance(source='', target=''):\n    \"\"\"Make a Levenshtein Distances Matrix\"\"\"\n    \n    # get length of both strings\n    n1, n2 = len(source), len(target)\n    \n    # create matrix using length of both strings - source string sits on columns, target string sits on rows\n    matrix = [ [ 0 for i1 in range(n1 + 1) ] for i2 in range(n2 + 1) ]\n    \n    # fill the first row - (0 to n1-1)\n    for i1 in range(1, n1 + 1):\n        matrix[0][i1] = i1\n    \n    # fill the first column - (0 to n2-1)\n    for i2 in range(1, n2 + 1):\n        matrix[i2][0] = i2\n    \n    # fill the matrix\n    for i2 in range(1, n2 + 1):\n        for i1 in range(1, n1 + 1):\n            \n            # check whether letters being compared are same\n            if (source[i1-1] == target[i2-1]):\n                value = matrix[i2-1][i1-1]               # top-left cell value\n            else:\n                value = min(matrix[i2-1][i1]   + 1,      # left cell value     + 1\n                            matrix[i2][i1-1]   + 1,      # top cell  value     + 1\n                            matrix[i2-1][i1-1] + 1)      # top-left cell value + 1\n            \n            matrix[i2][i1] = value\n    \n    # return bottom-right cell value\n    return matrix[-1][-1]\n\nprint(\"Levenshtein Edit Distance Example :\", 1)\nprint(\"--------------------------------------\")\nprint(\"cat vs cta :\", lev_distance('cat', 'cta'))","a41a7601":"# Import library\nfrom nltk.metrics.distance import edit_distance","ed302c4f":"print(\"apple vs appel :\", edit_distance(\"apple\", \"appel\"))","f2343330":"print(\"apple vs appel :\", edit_distance(\"apple\", \"appel\", transpositions=True))","ea045514":"# Importing SpaCy Library\nimport spacy\n\n# Load pre-trained SpaCy model for performing basic\n# NLP tasks such as POS tagging, parsing, etc.\nmodel = spacy.load(\"en_core_web_sm\")\n\ndef print_token(text):\n    \n    # Use the model to process the input sentence\n    tokens = model(text)\n\n    # Print the tokens and their respective PoS tags.\n    for token in tokens:\n        print(token.text, \"--\", token.pos_, \"--\", token.tag_)","6d23f639":"print_token(\"She wished she could desert him in the desert.\")","e0706d56":"print_token(\"The bass swam around the bass drum on the ocean floor.\")","5c76bd75":"!pip install nltk","76b78708":"from nltk import download\ndownload('wordnet')\n\nfrom nltk.corpus import wordnet","d6911761":"# Synsets\ntractor = wordnet.synsets(\"tractor\")\ntractor","a225ecad":"# Definitions of senses\ni = 1\nfor sys in tractor:\n    print(\"{:02d}\".format(i), \" : \", sys.definition())\n    i += 1","fc44428a":"# Hypernyms : Relation between a concept and its superordinate\ntractor = wordnet.synset('tractor.n.01')\ntractor.hypernyms()","550a3242":"self_propelled_vehicle = wordnet.synset('self-propelled_vehicle.n.01')\nself_propelled_vehicle.hypernyms()","993f0b2b":"# Meronyms : Relation between a part and its whole\nwheeled_vehicle = wordnet.synset('wheeled_vehicle.n.01')\nwheeled_vehicle.part_meronyms()","3f31128b":"# Hyponyms : Relation between a concept and its subordinate\nwheeled_vehicle.hyponyms()","95d3e436":"# Holonyms : Relation between whole and its parts\naxle = wordnet.synset('axle.n.01')\naxle.part_holonyms()","3d47fc85":"self_propelled_vehicle.hyponyms()","985b66b5":"motor_vehicle = wordnet.synset('motor_vehicle.n.01')\nmotor_vehicle.hyponyms()","625c3f67":"car = wordnet.synset('car.n.01')\ncar.part_meronyms()","36f7089a":"from nltk import wsd\nfrom nltk.corpus import wordnet as wn","85bf19c1":"X = 'The die is cast.'\nY = 'Roll the die to get a 6.'\nZ = 'What is dead may never die.'\n\n# To know the senses of 'die'\nwn.synsets('die')","2399f30d":"# To know the senses of 'die' which are 'noun'\nwn.synsets('die', pos=wn.NOUN)","299523a9":"# Different definitions for 'noun'\ni = 1\nfor syn in wn.synsets('die', pos=wn.NOUN):\n    print(\"{:02d}\".format(i), \" : \", syn.definition())\n    i += 1","fa6ebdb0":"# Different definitions for 'verb'\ni = 1\nfor syn in wn.synsets('die', pos=wn.VERB):\n    print(\"{:02d}\".format(i), \" : \", syn.definition())\n    i += 1","34bafd14":"# Trying to find nearest match for the word 'die'\nprint(\"Statement : \", X)\nsyn = wsd.lesk(X.split(), 'die')\nprint(\"Match     : \", syn)","6dc1dcc0":"# Getting the definition\nprint(\"Wrong Definition : \", syn.definition())","3fc367cd":"print(\"Right Definition : \", wsd.lesk(X.split(), 'die', pos=wn.NOUN).definition())","9df11191":"# Trying to find nearest match for the word 'die'\nprint(\"Statement        : \", Y)\nprint(\"\\n\")\nprint(\"Wrong Definition : \", wsd.lesk(Y.split(), 'die').definition())\nprint(\"Right Definition : \", wsd.lesk(Y.split(), 'die', pos=wn.NOUN).definition())","80922d13":"# Trying to find nearest match for the word 'die'\nprint(\"Statement        : \", Z)\nprint(\"\\n\")\nprint(\"Wrong Definition : \", wsd.lesk(Z.split(), 'die').definition())\nprint(\"Right Definition : \", wsd.lesk(Z.split(), 'die', pos=wn.VERB).definition())","c97a2cbd":"!pip install spacy","6e5dd15c":"from spacy import load\nfrom spacy.cli import download\n\nnlp = load(\"en_core_web_sm\")","481c9767":"import warnings\n\nPOS_MAP = {\n    'VERB': wn.VERB,\n    'NOUN': wn.NOUN,\n    'PROPN': wn.NOUN \n}\n\ndef lesk(doc, word):\n    found = False\n    for token in doc:\n        if token.text == word:\n            word = token\n            found = True\n            break\n    if not found:\n        raise ValueError(f'Word \\'{word}\\' does not appear in the document: {doc.text}.')\n    pos = POS_MAP.get(word.pos_, False)\n    if not pos:\n        warnings.warn(f'POS tag for {word.text} not found in wordnet. Falling back to default Lesk behaviour.')\n    args = [c.text for c in doc], word.text\n    kwargs = dict(pos=pos)\n    return wsd.lesk(*args, **kwargs)","65d02ffd":"# Trying to find nearest match for the word 'die'\nprint(\"Statement  : \", Y)\ndoc = nlp(Y)\nprint(\"Definition : \", lesk(doc, 'die').definition())","6d3d60b1":"# Trying to find nearest match for the word 'die'\nT = \"I work at google.\"\nprint(\"Statement  : \", T)\ndoc = nlp(T)\nprint(\"Definition : \", lesk(doc, 'google').definition())\nprint(\"\\n\")\nT = \"I will google it.\"\nprint(\"Statement  : \", T)\ndoc = nlp(T)\nprint(\"Definition : \", lesk(doc, 'google').definition())","bff7f351":"#### <font color='#4a8bad'>Example I<\/font>\n<a id=\"leski\"><\/a>","a24aed2a":"## <font color='#4a8bad'>Lesk Algorithm<\/font>\n***\n<a id=\"lesk\"><\/a>","30959d47":"## <font color='#4a8bad'>Soundex<\/font>\n***\n<a id=\"soundex\"><\/a>\n\nSoundex is a phonetic algorithm for indexing names by sound, as pronounced in English. The goal is for homophones to be encoded to the same representation so that they can be matched despite minor differences in spelling.\n\nIt converts an alphanumeric string to a four-character code that is based on how the string sounds when spoken in English. The first character of the code is the first character of character_expression, converted to upper case.","695136a2":"## <font color='#4a8bad'>Heteronyms Detection<\/font>\n***\n<a id=\"hd\"><\/a>","de468aee":"## <font color='#4a8bad'>Navigating Wordnet Relationships<\/font>\n***\n<a id=\"nwr\"><\/a>","c6a65000":"#### <font color='#4a8bad'>Example III<\/font>\n<a id=\"leskiii\"><\/a>","8e6d2121":"## <font color='#4a8bad'>Word-Sense Disambiguation<\/font>\n***\n<a id=\"wsd\"><\/a>","bf0889a0":"## <font color='#4a8bad'>Levenshtein Distance in 'nltk' Library<\/font>\n***\n<a id=\"lednltk\"><\/a>","0dffa293":"#### <font color='#4a8bad'>Levenshtein Distance<\/font>\n<a id=\"ld\"><\/a>","b827f103":"* [Soundex](#soundex)\n* [Levenshtein Edit Distance](#led)\n* [Levenshtein Distance in 'nltk' Library](#lednltk)\n    * [Levenshtein Distance](#ld)\n    * [Damerau-Levenshtein Distance](#dld)\n* [Heteronyms Detection](#hd)\n    * [Example I](#hdi)\n    * [Example II](#hdii)\n* [Navigating Wordnet Relationships](#nwr)\n* [Word-Sense Disambiguation](#wsd)\n* [Lesk Algorithm](#lesk)\n    * [Example I](#leski)\n    * [Example II](#leskii)\n    * [Example III](#leskiii)\n* [Automatic POS Tagging + Lesk with spaCy](#apt)","23316ddf":"#### <font color='#4a8bad'>Damerau-Levenshtein Distance<\/font>\n<a id=\"dld\"><\/a>\n\nThe Damerau-Levenshtein distance allows transpositions (swap of two letters which are adjacent to each other) as well.","22ed7c18":"## <font color='#4a8bad'>Automatic POS Tagging + Lesk with spaCy<\/font>\n***\n<a id=\"apt\"><\/a>","aaba3672":"## <font color='#4a8bad'>Levenshtein Edit Distance<\/font>\n***\n<a id=\"led\"><\/a>\n\nThe levenshtein distance calculates the number of steps (insertions, deletions or substitutions) required to go from source string to target string.","e6832a4c":"#### <font color='#4a8bad'>Example I<\/font>\n<a id=\"hdi\"><\/a>","a15bb248":"#### <font color='#4a8bad'>Example II<\/font>\n<a id=\"leskii\"><\/a>","540a53ac":"#### <font color='#4a8bad'>Example II<\/font>\n<a id=\"hdii\"><\/a>"}}