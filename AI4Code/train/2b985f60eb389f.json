{"cell_type":{"427e9096":"code","94a8d6f4":"code","7f606bbd":"code","c4ea2828":"code","f5a19489":"code","20215533":"code","bacb3c36":"code","5cc80c0f":"code","6ba1ebd2":"code","64905314":"code","085989a0":"code","2a3de83f":"code","f926db49":"code","e394c3ff":"code","1be593e2":"code","3b18c3cb":"code","d132c49c":"code","8409d986":"code","ab7ec620":"code","54f49185":"code","19ae6219":"code","9001c611":"code","01255698":"code","d0592fe0":"code","33c1530a":"code","d0b7282f":"code","eb356583":"code","e34b7369":"code","f810814e":"code","b72972e2":"markdown","bc57676c":"markdown","933adad5":"markdown","dbbf2b32":"markdown","a3ab556b":"markdown","910b906f":"markdown","dcdf5b57":"markdown","6a652e92":"markdown","c92eda1c":"markdown","ac8b0a10":"markdown"},"source":{"427e9096":"import numpy as np\nimport pandas as pd\nimport os\nfrom google.cloud import bigquery\n# For this Notebook, we will be using the Nakamoto python \n# module found here: https:\/\/github.com\/YazzyYaz\/nakamoto-coefficient\n!pip install nakamoto","94a8d6f4":"client = bigquery.Client()\nethereum_dataset_ref = client.dataset('crypto_ethereum_classic', project='bigquery-public-data')","7f606bbd":"# SQL query needed to get top 10K Ethereum Classic balances for the day\nquery = \"\"\"\n#standardSQL\n-- MIT License\n-- Copyright (c) 2018 Evgeny Medvedev, evge.medvedev@gmail.com\nwith double_entry_book as (\n    -- debits\n    select to_address as address, value as value\n    from `bigquery-public-data.crypto_ethereum_classic.traces`\n    where to_address is not null\n    and status = 1\n    and (call_type not in ('delegatecall', 'callcode', 'staticcall') or call_type is null)\n    union all\n    -- credits\n    select from_address as address, -value as value\n    from `bigquery-public-data.crypto_ethereum_classic.traces`\n    where from_address is not null\n    and status = 1\n    and (call_type not in ('delegatecall', 'callcode', 'staticcall') or call_type is null)\n    union all\n    -- transaction fees debits\n    select miner as address, sum(cast(receipt_gas_used as numeric) * cast(gas_price as numeric)) as value\n    from `bigquery-public-data.crypto_ethereum_classic.transactions` as transactions\n    join `bigquery-public-data.crypto_ethereum_classic.blocks` as blocks on blocks.number = transactions.block_number\n    group by blocks.miner\n    union all\n    -- transaction fees credits\n    select from_address as address, -(cast(receipt_gas_used as numeric) * cast(gas_price as numeric)) as value\n    from `bigquery-public-data.crypto_ethereum_classic.transactions`\n)\nselect address, \nsum(value) \/ 1000000000 as balance\nfrom double_entry_book\ngroup by address\norder by balance desc\nlimit 10000\n\"\"\"\n\n# We pass the query to the client\nquery_job = client.query(query)\niterator = query_job.result()","c4ea2828":"rows = list(iterator)\n# Transform the rows into a nice pandas dataframe\nbalances = pd.DataFrame(data=[list(x.values()) for x in rows], columns=list(rows[0].keys()))","f5a19489":"# Now that we have a dataframe of the top 100k balances for the day on ETC,\n# it's time to import it into a CustomSector in nakamoto to begin analysis\n\nfrom nakamoto.sector import CustomSector\n\n# data passed into nakamoto must be as a numpy array\nbalance_data = np.array(balances['balance'])\ntype(balance_data)","20215533":"# We build a config dictionary for Plotly like this:\nnakamoto_config = {\n    'plot_notebook': True,\n    'plot_image_path': None\n}\n\n# We also need a currency name and sector type, which is used for plotting information\ncurrency = 'ETC'\nsector_type = 'daily balance'\n\n# Since our balance data is sorted descending, we need to flip the data\n# for a proper gini and lorenz, otherwise the coefficient comes back negative\nbalance_data = balance_data[::-1]\n\n# Now, we instantiate the balance object\nbalance_sector = CustomSector(balance_data,\n                             currency,\n                             sector_type,\n                             **nakamoto_config)","bacb3c36":"# Let's get back the gini coefficient\nbalance_sector.get_gini_coefficient()","5cc80c0f":"balance_sector.get_nakamoto_coefficient()","6ba1ebd2":"balance_sector.get_plot()","64905314":"query = \"\"\"\n#standardSQL\n-- MIT License\n-- Copyright (c) 2019 Yaz Khoury, yaz.khoury@gmail.com\nWITH mined_block AS (\n  SELECT miner, DATE(timestamp)\n  FROM `bigquery-public-data.crypto_ethereum_classic.blocks` \n  WHERE DATE(timestamp) > DATE_SUB(CURRENT_DATE(), INTERVAL 1 MONTH)\n  ORDER BY miner ASC)\nSELECT miner, COUNT(miner) AS total_block_reward \nFROM mined_block \nGROUP BY miner \nORDER BY total_block_reward ASC\n\"\"\"\n\n# We pass the query to the client\nquery_job = client.query(query)\niterator = query_job.result()","085989a0":"rows = list(iterator)\n# Transform the rows into a nice pandas dataframe\nmining_rewards = pd.DataFrame(data=[list(x.values()) for x in rows], columns=list(rows[0].keys()))\nmining_rewards_data = np.array(mining_rewards['total_block_reward'])","2a3de83f":"sector_type = 'mining_rewards'\nmining_rewards_sector = CustomSector(mining_rewards_data,\n                             currency,\n                             sector_type,\n                             **nakamoto_config)","f926db49":"# Mining Gini\nmining_rewards_sector.get_gini_coefficient()","e394c3ff":"# Nakamoto Coefficient\nmining_rewards_sector.get_nakamoto_coefficient()","1be593e2":"mining_rewards_sector.get_plot()","3b18c3cb":"from nakamoto.sector import Market\n\nmarket_url = \"https:\/\/coinmarketcap.com\/currencies\/ethereum-classic\/#markets\"\nmarket_sector = Market(currency, market_url, **nakamoto_config)","d132c49c":"# Market Gini\nmarket_sector.get_gini_coefficient()","8409d986":"market_sector.get_nakamoto_coefficient()","ab7ec620":"market_sector.get_plot()","54f49185":"from nakamoto.sector import Client, Geography\n\nclient_sector = Client(currency, **nakamoto_config)\ngeography_sector = Geography(currency, **nakamoto_config)","19ae6219":"# Client Gini\nclient_sector.get_gini_coefficient()","9001c611":"# Geography Gini\ngeography_sector.get_gini_coefficient()","01255698":"# Client Nakamoto\nclient_sector.get_nakamoto_coefficient()","d0592fe0":"# Geography Nakamoto\ngeography_sector.get_nakamoto_coefficient()","33c1530a":"client_sector.get_plot()","d0b7282f":"geography_sector.get_plot()","eb356583":"from nakamoto.coefficient import Nakamoto\n\n\nsector_list = [geography_sector, \n               market_sector, \n               client_sector,  \n               balance_sector,\n               mining_rewards_sector]\n\nnakamoto = Nakamoto(sector_list)","e34b7369":"# Minimum Nakamoto Coefficient\nnakamoto.get_minimum_nakamoto()","f810814e":"# Maximum Gini Coefficient\nnakamoto.get_maximum_gini()","b72972e2":"Now, we will once again get the Gini, Nakamoto and Lorenz Plot of the Mining Reward Counts Per Miner in the Past 30 Days.","bc57676c":"## Nakamoto Coefficient of Miner Reward Count By Miner Address on Ethereum Classic\n\nHere, we will use Google BigQuery Ethereum Classic Dataset to run an SQL query to get back the total number of times a miner received a block reward in the last month. We will measure the income inequality by block reward count. This of course assumes the rewards are divided by entities, but of course those addresses can belong to pools.","933adad5":"## Nakamoto Coefficient\n\nNakamoto coefficient is a measure of the minimum amount of entities required to achieve > 51% control or influence to compromise a subsystem. In this example, we are measuring the minimum number of entities required to control more than 51% of the entire ETC circulating supply.","dbbf2b32":"## Nakamoto Coefficient of Wealth Distribution on Blockchain Addresses\n\nHere, we will first measure the wealth distribution and income inequality among all Ethereum Classic addresses, where we limit our measurement to the top 10k accounts.\n\nWe provide the query here for getting the top 10k balances for the day which was taken from [the article here](https:\/\/medium.com\/google-cloud\/how-to-query-balances-for-all-ethereum-addresses-in-bigquery-fb594e4034a7). ","a3ab556b":"## Gini\nThe Gini coefficient is a value between 0 and 1, with 0 being perfect equality and 1 being perfect inequality. It helps understand measurement of inequality. In this example, we measure inequality distribution using balances per address. The assumption here is that each person has only 1 address; Top addresses also belong to exchanges, which use their own accounting software on their app; Only top 10k balances analyzed, so not a complete picture.","910b906f":"# Measuring Decentralization of Ethereum Classic using Nakamoto Library on Python with Google BigQuery\n\n[Nakamoto](https:\/\/github.com\/YazzyYaz\/nakamoto-coefficient) is a python library built to measure the Nakamoto Coefficient as presented by the Medium article \"[Quantifying Decentralization](https:\/\/news.earn.com\/quantifying-decentralization-e39db233c28e)\".\n\nNakamoto is a measurement of the minimum entity needed to compromise a subsystem of the blockchain, or 51% attack it. It is not just limited to the hashrate of the blockchain but can used to measure wealth distribution, exchange volume, code contribution. \n\nNakamoto module here will go over each subsystem example and how to generate the Nakamoto Coefficient, the Gini Coefficient (to measure inequality distribution), and the Lorenz Curve (to measure curve to perfect equality).\n\nThis notebook will also be using Google BigQuery with the Ethereum Classic Dataset to measure two subsytems of the Nakamoto Coefficient.\n\nLet's get started!\n\nThe module we will be running is called `nakamoto` and can be installed by running the following chunk.","dcdf5b57":"## Client and Geography Nakamoto Coefficient\n\nHere, we have built in sector classes for `Geography` (mining nodes by country) and `Client` (mining nodes by client software) for ETC and ETH because the built-in sector takes data from [Ethernodes.org](http:\/\/ethernodes.org) which doesn't distinguish between `chainId`. We plan on being able to separate two datasets, but for now, it's assumed as the Client and Geography Nakamoto coefficients of EVM datasets.","6a652e92":"## Mininmum Nakamoto and Maximum Gini Coefficient of All Ethereum Classic Sectors\n\nTo get an overall idea of all the subsystems and the minimum nakamoto of all minimum nakamoto coefficients in the sectors as well as maximum gini which is most centralized\/inequal sector, we use `Nakamoto` class for analysis.","c92eda1c":"## Lorenz Curve\n\nThe lorenz curve can plot distribution of inequality. It has a straight line used as a measure of perfect equality. The curve, called the Lorenz curve highlights how far away the entities are from perfect equality.\n\nWe pass a line through the 51% mark to highlight the influence of the minimum number of entities who are capable of compromising the system. The minimum Nakamoto coefficient is the number of entities in red.","ac8b0a10":"## Market Nakamoto Coefficient Of Ethereum Classic Volume By Exchange\n\nWe will now measure the total 24 hour volume by the exchanges that trade Ethereum Classic. We will look into the distribution of ETC inequality among exchanges and the minimum amount of exchanges needed to compromise 51% of total circulating supply of ETC in exchanges.\n\nFor this, we use the special sector class `Market`. We pass it a CoinMarketCap `#market` type of url like the following we will use for ETC: `https:\/\/coinmarketcap.com\/currencies\/ethereum-classic\/#markets`"}}