{"cell_type":{"dc673d7c":"code","8898dae5":"code","0c76d124":"code","c642fc8f":"code","9c53db50":"code","4dfbf946":"code","f4ceb232":"code","fb2cec68":"code","90155796":"code","b70577ad":"code","250a74aa":"code","f1369b2f":"code","3a244f60":"code","bc2bd437":"code","584427fb":"code","f72afe0e":"code","694eb812":"code","1b00970f":"code","318d27c6":"code","0c87e35f":"code","39756952":"code","47f63d08":"code","0b84598e":"code","cab7fde2":"code","f82fd869":"code","ef40ca9c":"code","0ae84e71":"code","0fb616bb":"code","f5790128":"code","8891c1f6":"markdown","4e591757":"markdown","c3961358":"markdown","917b9d7f":"markdown","8acaa3fe":"markdown","33b239d8":"markdown","e469e25a":"markdown","921cd339":"markdown","0910d958":"markdown","b9b7bf0d":"markdown","de89041b":"markdown","81bfce59":"markdown","05110dc8":"markdown","c9f94e42":"markdown","6125a840":"markdown","42ca537e":"markdown","60be90d2":"markdown","53e7dd34":"markdown","f6f8cb35":"markdown","baa5ca42":"markdown","7170f5f8":"markdown","fc38fa7d":"markdown","55cf9c20":"markdown","730b3077":"markdown","a3cec9af":"markdown","d0ba593e":"markdown","916a42d6":"markdown","6e3798c4":"markdown","29d082b9":"markdown","a22286f5":"markdown","9856f0a9":"markdown","fe484f7d":"markdown","0d268c07":"markdown","0487aa20":"markdown","285ffa4e":"markdown","6aeb7237":"markdown","ff27abb4":"markdown","4570ed8e":"markdown","ef7c32a6":"markdown","6f8bbd49":"markdown","ec3cea98":"markdown","bd6cf885":"markdown","a785de4d":"markdown","b1c0818c":"markdown","88979ad3":"markdown","e618f91b":"markdown","6050182f":"markdown","a988d105":"markdown","78507477":"markdown","e88e516c":"markdown","3d9c130b":"markdown","0cef1610":"markdown","ac8d1171":"markdown","f57e1d4e":"markdown","15aea54d":"markdown","c9acd348":"markdown","ea45c484":"markdown","3d868f0f":"markdown","6f951892":"markdown","01638db9":"markdown","c5d0a9a6":"markdown","07c731ab":"markdown","7db661b0":"markdown","d466e8af":"markdown","d1c7ba36":"markdown","d625223c":"markdown","fe6a7920":"markdown","c5f00de4":"markdown","3e43b2cf":"markdown","00e3b174":"markdown","4859d9a5":"markdown","0e25550a":"markdown","55cc340b":"markdown","110e2ddd":"markdown","5066d7ab":"markdown","123bb9c4":"markdown","7ac6fa00":"markdown","edf9d606":"markdown","714b09f4":"markdown","7ec41ca1":"markdown","fd31faa3":"markdown","6d84dfaf":"markdown","67971cc2":"markdown","12151e8e":"markdown","7d9c5d2e":"markdown","db755b03":"markdown","0afc9412":"markdown","3fbd9782":"markdown","d376a956":"markdown"},"source":{"dc673d7c":"import numpy as np\n%matplotlib notebook\nimport matplotlib.pyplot as plt","8898dae5":"# ------------ INITIALISATION ---------------------\n\n# --- INPUT ---\n\nq_m_ratio = 1        # charge-to-mass ratio\nb0 = 1              # magnetic field (homogeneous, in z direction) \n\nv = 10               # enter the correct initial velocity.\nphi = 0              # enter the correct phase\n\nrxc = 0              # enter the correct x-coordinate of the centre of the circle\nryc = 0            # enter the correct y-coordinate of the centre of the circle\n\nstart_time = 0      # enter the start time of the propagation\nN_loops = 2          # enter number of loops the particle should complete \nsteps_rev = 1000        # enter the number of time steps per revolution \n\n# --- calculate values from input variables\n\nomega =  q_m_ratio*b0                       # calculate the cyclotron frequency (from the input variables)\n\nperiod_osc = 1\/omega                      # calculate the period of the oscillation (from the input variables)\n\nend_time =  N_loops * period_osc * 6  # calculate the end time of the propagation (from the input variables)\n\ntime_steps = N_loops * steps_rev                       # calculate the number of time steps (from the input variables)\n\n# --- defininition of time array for propagation \n\nstep = (end_time-start_time)\/(time_steps-1)\ntime = np.linspace(start_time,end_time,time_steps)","0c76d124":"#ANALYTICAL SOLUTION of the differential equations\nexact_position_x = v\/omega*np.sin(omega*time - phi) + rxc   # multiplication with numpy array time\nexact_position_y = v\/omega*np.cos(omega*time - phi) + ryc   # yields a numpy array\nexact_velocity_x = v*np.cos(omega*time - phi)\nexact_velocity_y = -v*np.sin(omega*time - phi)","c642fc8f":"#Plot of exact solutions to check that they make sense.\nplt.figure(1)\nplt.plot(time,exact_position_x,linewidth=3,label='x position')\nplt.plot(time,exact_position_y,linewidth=3,label='y position')\nplt.legend()\nplt.title(f\"x and y component of particle's position vs. time\")\nplt.xlabel(f\"time [s]\") \nplt.ylabel(f\"position [m]\") \nplt.show()","9c53db50":"# If we plot r_y(t) against r_x(t), the result should be a circle.\nplt.figure(2)\nplt.plot(exact_position_x,exact_position_y)\nplt.axis('equal') #scale of x and y axes is the same to show that motion is along a circle\nplt.title(f\"cyclotron motion of particle in x-y plane\")\nplt.xlabel(f\"x position [m]\") \nplt.ylabel(f\"y position [m]\") \nplt.show()","4dfbf946":"# initialisation of position and velocity arrays, setting everything to zero\nposition_x = np.zeros(time_steps)\nposition_y = np.zeros(time_steps)\nvelocity_x = np.zeros(time_steps)\nvelocity_y = np.zeros(time_steps)","f4ceb232":"# --- Definition of the derivative of y(t), F(y(t)) ---\n#\n# Input:  yin :  vector y (numpy array)\n#         omega: cyclotron frequency\n# Output: derivative of vector yin, F(yin) (numpy array)\n\ndef der(yin, omega):                                              # no explicit time dependence\n    return np.array([yin[2],yin[3],omega*yin[3],-omega*yin[2]])","fb2cec68":"# --- Implementation of Euler method\n# Input: yin - initial vector of position and velocity\n#        omega - cylcotron frequency\n#        step - time step\n#\n# Output: yout - propagated vector of position and velocity\n\ndef euler(yin,omega,step):\n    return yin + (der(yin, omega) * step)\n    ","90155796":"#--- Input of initial conditions\n\nposition_x[0] = 0.0        # initial position\nposition_y[0] = v\/omega  \nvelocity_x[0] = v          # initial velocity\nvelocity_y[0] = 0.0  \n\nyin = np.zeros(4)          # initialisation of yin\n\nyin[0] = position_x[0]     # start with initial conditions \nyin[1] = position_y[0]\nyin[2] = velocity_x[0]\nyin[3] = velocity_y[0]\n\n#--- Propagation\n\nfor ii in range(1,time_steps):\n    yin = euler(yin,omega,step)                    # calculation of yout (which immediately overwrites the old yin!)\n    \n    position_x[ii] = yin[0]                        # save the new position and velocity components\n    position_y[ii] = yin[1]\n    velocity_x[ii] = yin[2]\n    velocity_y[ii] = yin[3]","b70577ad":"plt.figure(3)\nplt.plot(exact_position_x,exact_position_y,linewidth=3,label='exact position')\nplt.plot(position_x,position_y,linewidth=1,label='numerical position')\nplt.axis('equal')\nplt.legend()\nplt.title(f\"Comparison for analytical and numerical solution\")\nplt.xlabel(f\"x position [m]\") \nplt.ylabel(f\"y position [m]\") \nplt.show()","250a74aa":"# y-t plot of cyclotron motion \n# comparison analytical vs. numerical solution\n\nplt.figure(4)\nplt.plot(time,position_y,'x',label='numerical position')\nplt.plot(time,exact_position_y,linewidth=1,label='Analytical position')\nplt.axis([0,N_loops*2*np.pi\/omega,-1*(position_y[0]+0.1),position_y[0]+0.1])\nplt.title(f\"Comparison analytical vs numerical result of y(t)\")\nplt.xlabel(f\"time [s]\") \nplt.ylabel(f\"y position [m]\") \nplt.legend\nplt.show()","f1369b2f":"import numpy as np\nimport matplotlib.pyplot as plt\n\n#Derivative Function\ndef der(yin, omega):                                              # no explicit time dependence\n    return np.array([yin[2],yin[3],omega*yin[3],-omega*yin[2]])\n\n#Euler Method\ndef euler(yin,omega,step):\n    return yin + (der(yin, omega) * step)\n\ndef cyclotron_motion(q_m_ratio, b0, v, phi, rxc, ryc, start_time, N_loops, steps_rev):\n    omega =  q_m_ratio*b0                      \n\n    period_osc = 1\/omega                      \n\n    end_time =  N_loops * period_osc * 6  \n    time_steps = N_loops * steps_rev                       \n\n    # --- defininition of time array for propagation \n\n    step = (end_time-start_time)\/(time_steps-1)\n    time = np.linspace(start_time,end_time,time_steps)\n    \n    #ANALYTICAL SOLUTION of the differential equations\n    exact_position_x = v\/omega*np.sin(omega*time - phi) + rxc   # multiplication with numpy array time\n    exact_position_y = v\/omega*np.cos(omega*time - phi) + ryc   # yields a numpy array\n    exact_velocity_x = v*np.cos(omega*time - phi)\n    exact_velocity_y = -v*np.sin(omega*time - phi)\n    \n    \n    \n    \n    #NUMERICAL SOLUTION \n    # initialisation of position and velocity arrays, setting everything to zero\n    position_x = np.zeros(time_steps)\n    position_y = np.zeros(time_steps)\n    velocity_x = np.zeros(time_steps)\n    velocity_y = np.zeros(time_steps)\n    \n    #--- Input of initial conditions\n\n    position_x[0] = 0.0        # initial position\n    position_y[0] = v\/omega  \n    velocity_x[0] = v          # initial velocity\n    velocity_y[0] = 0.0  \n\n    yin = np.zeros(4)          # initialisation of yin\n\n    yin[0] = position_x[0]     # start with initial conditions \n    yin[1] = position_y[0]\n    yin[2] = velocity_x[0]\n    yin[3] = velocity_y[0]\n\n    #--- Propagation\n\n    for ii in range(1,time_steps):\n        yin = euler(yin,omega,step)                    # calculation of yout (which immediately overwrites the old yin!)\n\n        position_x[ii] = yin[0]                        # save the new position and velocity components\n        position_y[ii] = yin[1]\n        velocity_x[ii] = yin[2]\n        velocity_y[ii] = yin[3]\n    \n    #COMPARISON PLOTS\n    plt.figure(3)\n    plt.plot(exact_position_x,exact_position_y,linewidth=3,label='exact position')\n    plt.plot(position_x,position_y,linewidth=1,label='numerical position')\n    plt.axis('equal')\n    plt.legend()\n    plt.title(f\"Comparison for analytical and numerical solution\")\n    plt.xlabel(f\"x position [m]\") \n    plt.ylabel(f\"y position [m]\") \n    plt.show()\n    \n    # y-t plot of cyclotron motion \n    # comparison analytical vs. numerical solution\n\n    plt.figure(4)\n    plt.plot(time,position_y,'x',label='numerical position')\n    plt.plot(time,exact_position_y,linewidth=1,label='Analytical position')\n    plt.axis([0,N_loops*2*np.pi\/omega,-1*(position_y[0]+0.1),position_y[0]+0.1])\n    plt.title(f\"Comparison analytical vs numerical result of y(t)\")\n    plt.xlabel(f\"time [s]\") \n    plt.ylabel(f\"y position [m]\") \n    plt.legend\n    plt.show()    \n    \n    return\n \n%matplotlib inline\n\nprint(\"Initial Velocity = 10, N_loops = 8, Timesteps = 1000\")\ncyclotron_motion(1, 1, 10, 0, 0, 0, 0, 8, 1000)\nprint(\"Initial Velocity = 10, N_loops = 8, Timesteps = 2000\")\ncyclotron_motion(1, 1, 10, 0, 0, 0, 0, 8, 2000)\nprint(\"Initial Velocity = 20, N_loops = 8, Timesteps = 1000\")\ncyclotron_motion(1, 1, 20, 0, 0, 0, 0, 8, 2000)\nprint(\"Initial Velocity = 5, N_loops = 8, Timesteps = 1000\")\ncyclotron_motion(1, 1, 5, 0, 0, 0, 0, 8, 2000)","3a244f60":"\ndef calculateanalytical(step, v, omega, phi, rxc, ryc):\n    exact_position_x = v\/omega*np.sin(omega*step - phi) + rxc   # multiplication with numpy array time\n    exact_position_y = v\/omega*np.cos(omega*step - phi) + ryc   # yields a numpy array\n    exact_velocity_x = v*np.cos(omega*step - phi)\n    exact_velocity_y = -v*np.sin(omega*step - phi)\n    return [exact_position_x, exact_position_y, exact_velocity_x, exact_velocity_y]\n\ndef error(numerical, analytical):\n    return (numerical - analytical)\/analytical \n    \n\ndef cyclotron_motion_with_error(q_m_ratio, b0, v, phi, rxc, ryc, start_time, N_loops, steps_rev):\n    omega =  q_m_ratio*b0                      \n\n    period_osc = 1\/omega                      \n\n    end_time =  N_loops * period_osc * 6  \n    time_steps = N_loops * steps_rev                       \n\n    # --- defininition of time array for propagation \n\n    step = (end_time-start_time)\/(time_steps-1)\n    time = np.linspace(start_time,end_time,time_steps)\n    \n    #ANALYTICAL SOLUTION of the differential equations\n    exact_position_x = v\/omega*np.sin(omega*time - phi) + rxc   # multiplication with numpy array time\n    exact_position_y = v\/omega*np.cos(omega*time - phi) + ryc   # yields a numpy array\n    exact_velocity_x = v*np.cos(omega*time - phi)\n    exact_velocity_y = -v*np.sin(omega*time - phi)\n    \n    \n    \n    \n    #NUMERICAL SOLUTION \n    # initialisation of position and velocity arrays, setting everything to zero\n    position_x = np.zeros(time_steps)\n    position_y = np.zeros(time_steps)\n    velocity_x = np.zeros(time_steps)\n    velocity_y = np.zeros(time_steps)\n    \n    #--- Input of initial conditions\n\n    position_x[0] = 0.0        # initial position\n    position_y[0] = v\/omega  \n    velocity_x[0] = v          # initial velocity\n    velocity_y[0] = 0.0  \n\n    yin = np.zeros(4)          # initialisation of yin\n\n    yin[0] = position_x[0]     # start with initial conditions \n    yin[1] = position_y[0]\n    yin[2] = velocity_x[0]\n    yin[3] = velocity_y[0]\n\n    #--- Propagation\n    \n    error_results = []\n\n    for ii in range(1,time_steps):\n        yin = euler(yin,omega,step)  # calculation of yout (which immediately overwrites the old yin!)\n        \n        analytical = calculateanalytical(ii, v, omega, phi, rxc, ryc)\n        error_results.append(error(yin, analytical))\n        \n        position_x[ii] = yin[0]                        # save the new position and velocity components\n        position_y[ii] = yin[1]\n        velocity_x[ii] = yin[2]\n        velocity_y[ii] = yin[3]\n    \n    plt.figure(3)\n    plt.plot(exact_position_x,exact_position_y,linewidth=3,label='exact position')\n    plt.plot(position_x,position_y,linewidth=1,label='numerical position')\n    plt.axis('equal')\n    plt.legend()\n    plt.title(f\"Comparison for analytical and numerical solution\")\n    plt.xlabel(f\"x position [m]\") \n    plt.ylabel(f\"y position [m]\") \n    plt.show()\n    \n    return error_results\n\ncalculated_error = cyclotron_motion_with_error(1, 1, 10, 0, 0, 0, 0, 8, 100)\ny_error = [e[0] for e in calculated_error]\n#print(y_error)\nfor e in y_error:\n    print(e)\nplt.plot(y_error)\nplt.show()","bc2bd437":"# --- Definition of the derivative of y(t) ---\n# Input: time: time at which the derivative is evaluated (not needed here, because we have no explicit time-dependence)\n#        yin : array for vector y (containing 4 components)\n#        omega: cyclotron frequency\n# Output: yout: propagated vector y\n\ndef der_rk(yin, omega):\n    return np.array([yin[2],yin[3],omega*yin[3],-omega*yin[2]])","584427fb":"# --- Implementation of the Runge Kutta method\n\ndef runge_kutta(yin,omega,step):\n    k1 = step*der_rk(yin,omega)  \n    k2 = step*der_rk(yin+k1\/2,omega)\n    k3 = step*der_rk(yin+k2\/2,omega)\n    k4 = step*der_rk(yin+k3,omega)\n    yout = yin+k1\/6.0+k2\/3.0+k3\/3.0+k4\/6.0\n    return yout","f72afe0e":"# initialisation of position and velocity arrays for Runge Kutta method, setting everything to zero\nposition_rk_x = np.zeros(time_steps)\nposition_rk_y = np.zeros(time_steps)\nvelocity_rk_x = np.zeros(time_steps)\nvelocity_rk_y = np.zeros(time_steps)","694eb812":"for ii in range(1,time_steps):\n    yin = runge_kutta(yin,omega_f,step,time[ii])   # calculation of yout (which immediately overwrites the old yin!)\n    \n    position_x[ii] = yin[0]                        # save the new position and velocity components\n    position_y[ii] = yin[1]\n    velocity_x[ii] = yin[2]\n    velocity_y[ii] = yin[3]","1b00970f":"# ------------ INITIALISATION ---------------------\n\n# --- INPUT ---\n\nq_m_ratio = 1.0    # charge-to-mass ratio\nb0 = 1.0           # magnetic field (homogeneous, in z direction) \n\nv = 10.0           #enter the correct initial velocity.\nphi = 0.0          #enter the correct phase\n\nrxc = 0.0          #enter the correct x-coordinate of the centre of the circle\nryc = 0.0          #enter the correct y-coordinate of the centre of the circle\n\nstart_time = 0.0   # enter the start time of the propagation\nN_loops = 2        # enter number of loops the particle should complete \nsteps_rev = 1000     # enter the number of time steps per revolution \n\n# --- calculate values from input variables\n\nomega_f = q_m_ratio * b0           # calculate the cyclotron frequency (from the input variables)\n\nperiod_osc = 2.0 * np.pi\/omega_f   # calculate the period of the oscillation (from the input variables)\n\nend_time = N_loops * period_osc    # calculate the end time of the propagation (from the input variables)\n\ntime_steps = N_loops * steps_rev   # calculate the number of time steps (from the input variables)\n\n# defininition of time array for propagation \n\nstep = (end_time-start_time)\/(time_steps-1)\ntime = np.linspace(start_time,end_time,time_steps)\n\n#ANALYTICAL SOLUTION of the differential equations\nexact_position_x = v\/omega_f*np.sin(omega_f*time - phi) + rxc   # multiplication with numpy array time\nexact_position_y = v\/omega_f*np.cos(omega_f*time - phi) + ryc   # yields a numpy array\nexact_velocity_x = v*np.cos(omega_f*time - phi)\nexact_velocity_y = -v*np.sin(omega_f*time - phi)\n\n\nradius = np.sqrt(exact_position_x[0]**2+exact_position_y[0]**2) # exact radius \n\n\n#NUMERICAL SOLUTION of the differential equations - Euler method\n\n# initialisation of position and velocity arrays, setting everything to zero\nposition_x = np.zeros(time_steps)\nposition_y = np.zeros(time_steps)\nvelocity_x = np.zeros(time_steps)\nvelocity_y = np.zeros(time_steps)\n\ndiff_radius = np.zeros(time_steps)\ndiff_velocity = np.zeros(time_steps)\n\n#Input of initial conditions\nposition_x[0] = 0.0        # Make sure you enter the correct initial conditions.\nposition_y[0] = v\/omega_f  # Enter them in terms of the speed of the particle and the frequency\nvelocity_x[0] = v          \nvelocity_y[0] = 0.0  \n\nyin = np.zeros(4)          #initialisation of yin\n\nyin[0] = position_x[0]     #start with initial conditions \nyin[1] = position_y[0]\nyin[2] = velocity_x[0]\nyin[3] = velocity_y[0]\n\n\n#numerical solution\nfor ii in range(1,time_steps):\n    yin = euler(yin,omega_f,step)                  # calculation of yout (which immediately overwrites the old yin!)\n    \n    position_x[ii] = yin[0]                        # save the new position and velocity components\n    position_y[ii] = yin[1]\n    velocity_x[ii] = yin[2]\n    velocity_y[ii] = yin[3]\n    \n    #derivation of numerical results from exact ones: radius and velocity\n    \n    diff_radius[ii] = np.abs(np.sqrt(position_x[ii]**2 + position_y[ii]**2) - radius)\n    diff_velocity[ii] = np.abs(np.sqrt(velocity_x[ii]**2 + velocity_y[ii]**2) - v)\n    \nplt.figure(5)\nplt.plot(time,diff_radius)\nplt.title(f\"Derivation of radius from exact one over time\")\nplt.xlabel(f\"time [s]\") \nplt.ylabel(f\"difference in radii [m]\") \nplt.show()\n\nplt.figure(6)\nplt.plot(time,diff_velocity)\nplt.title(f\"Derivation of velocity from exact one over time\")\nplt.xlabel(f\"time [s]\") \nplt.ylabel(f\"difference in velocities [m\/s]\") \nplt.show()\n","318d27c6":"time_steps=10000\nstart_time=0.0\nend_time=40.0\nstep=(end_time-start_time)\/(time_steps-1)\ntime=np.linspace(start_time,end_time,time_steps)\nposition_x=np.zeros(time_steps)\nposition_y=np.zeros(time_steps)\nposition_z=np.zeros(time_steps)","0c87e35f":"def der(time,yin,omega_f):\n    return np.array([10*(yin[1]-yin[0]),yin[0]*(28-yin[2])-yin[1],yin[0]*yin[1]-8\/3*yin[2]])","39756952":"position_x[0]=1.0  #make sure you enter the correct initial conditions.\nposition_y[0]=1.0  #make sure you enter the correct initial conditions.\nposition_z[0]=1.0  #make sure you enter the correct initial conditions.\nyin=np.zeros(3)\nyin[0]=position_x[0]\nyin[1]=position_y[0]\nyin[2]=velocity_x[0]","47f63d08":"for ii in range(1,time_steps):\n    yin=runge_kutta(yin,1.0,step,time[ii])\n    position_x[ii]=yin[0]\n    position_y[ii]=yin[1]\n    position_z[ii]=yin[2]\n   ","0b84598e":"plt.figure(7)\nplt.plot(position_x,position_z,linewidth=1,label='numerical position')\n#plt.axis('equal')\nplt.legend()\nplt.show()","cab7fde2":"from mpl_toolkits.mplot3d import Axes3D","f82fd869":"fig = plt.figure(8)\nax = fig.gca(projection='3d')\nax.plot(position_x,position_y,position_z,linewidth=1,label='numerical solution')\nax.legend()\nplt.show()","ef40ca9c":"from scipy.integrate import odeint","0ae84e71":"def lorenz(x,t,A,B,C):\n    return np.array([A*(x[1]-x[0]),x[0]*(B-x[2])-x[1],x[0]*x[1]-C*x[2]])\n","0fb616bb":"xout=odeint(lorenz,[1,1,1],time,args=(10,28,8\/3))\nxt=np.transpose(xout)\nxx=xt[0]\nyy=xt[1]\nzz=xt[2]","f5790128":"fig = plt.figure(9)\nax = fig.gca(projection='3d')\nax.plot(xx,yy,zz,linewidth=1,label='numerical solution')\nax.legend()\nplt.show()","8891c1f6":"## Section 4: Checking and using the code","4e591757":"At each time step we could calculate the relative error that is,\n$$\nrelative\\ error = \\frac{measured\\ value - expected\\ value }{expected\\ value} \\\\\n$$\n\nwhere the measured value is the numerical solution using the euler method at timestep n, and expected value is the analytical solution at time step n\n\nwe can also calculate a loss function which will analyze the overall performance. a common loss function is mean squared error.","c3961358":"The manual for odeint can be found at https:\/\/docs.scipy.org\/doc\/scipy\/reference\/generated\/scipy.integrate.odeint.html","917b9d7f":"where ${\\bf a}$ is the acceleration and ${\\bf r}$ the position of the particle.","8acaa3fe":"** Code snippet #7**","33b239d8":"$$\\begin{align}\n{\\bf k}_1 & = h \\: {\\bf F}({\\bf y}_0,t_0) \\\\\n{\\bf k}_2 & = h \\: {\\bf F}({\\bf y}_0+{\\bf k}_1\/2,t_0+h\/2) \\\\\n{\\bf k}_3 & = h \\: {\\bf F}({\\bf y}_0+{\\bf k}_2\/2,t_0+h\/2) \\\\\n{\\bf k}_4 & = h \\: {\\bf F}({\\bf y}_0+{\\bf k}_3,t_0+h) \\\\\n{\\bf y}_{\\rm out} & = {\\bf y}_0+ \\frac{1}{6} \\left({\\bf k}_1 +2 {\\bf k}_2 +2{\\bf k}_3 +{\\bf k}_4 \\right)\n\\end{align}\n$$","e469e25a":"A far superior algorithm to the Euler method is called the Runge-Kutta method. \n\n\nMore insight into the Runge-Kutta method can, e.g., be found on\nhttps:\/\/en.wikipedia.org\/wiki\/Runge%E2%80%93Kutta_methods\n","921cd339":"###  <span style=\"color: green;\">Marking Scheme: <\/span>\n\n8 marks for each part with 4 marks for plots and 4 marks for corresponding discussion","0910d958":"**Code Snippet #0** (You will use the different Code snippets later to combine them to obtain a complete program)","b9b7bf0d":"where $F$ is a function of $y$ and $t$. Note that $y$ itself depends on time and we should write $y(t)$, but we omit the explicit time dependence to simplify the notation here. \n\nKnowing the differential equation of a physical problem means that we know the slope of the sought solution $y(t)$ at every point in time $t$. In most physics problems, we also know the **initial condition** of the solution $y(t)$, ie. we know $y(t_0) = y_0$ at the initial time $t_0$.  \n\nBy multiplying the slope $F(y_0,t_0)$ with a small time step $h$ and adding it to the initial value $y_0$, we get an approximate solution for $y(t_1) = y_1$ at time $t_1 = t_0 + h$. Thus,\n\n$$ y_1= y_0 + h \\: F(y_0,t_0) \\: .$$\n\n","de89041b":"**Code snippet #2**","81bfce59":"Note that even at the end of the integration period the numerical solution is still quite accurate.","05110dc8":"Now we can implement the Runge-Kutta algorithm. First, we again define a function ```der_rk``` that returns a vector of the derivates. This is just given by the function  ${\\bf F}({\\bf y},t)$ that we defined above.","c9f94e42":"Thus, we have written the equations of motion as a set of 4 coupled first-order differential equations. We did this because a numerical or analytical solution is much easier for first-order differential equations than for second or higher-order differential equations. \nWe simplified the above differential equations further by introducing the cyclotron frequency $\\omega = B_0 q\/m$.","6125a840":"## DISCUSION \nBy increasing the number of loops, the numerical solution using euler's method started with the same inaccuracy as previous, but as time steps increased it became closer (more accurate) to the analytical solution.\n\nBy increasing time steps while keeping the number of loops constant, we increase the number of times we analyze the curve, producing a more accurate numerical solution. \n\nWhen the initial speed is doubled,\nThe radius doubles.\n\n\n\nWhen the intial speed is halved,\nThe radius havles.\n\nRadius is directly proportional to velocity that is $$ r = mv\/qB $$\n\n\nWe previously derived\n\n$$ \\begin{align}\n\\frac{d r_x}{d t} & = v_x \\\\\n\\frac{d r_y}{d t} & = v_y \\\\\n\\end{align}\n$$\n\nThese results were expected","42ca537e":"### Section 3b: Implementation ","60be90d2":"<span style=\"color: red;\"> **Write your name here**: <\/span>\n(You are welcome to discuss your work with peers and staff, but you should complete this independently and submit it as an individual submission.)","53e7dd34":"In this notebook, we will look at how to numerically solve the equations of motion for a charged particle with charge $q$, mass $m$ and velocity ${\\bf v} $ moving in a uniform magnetic field ${\\bf B}$. Our starting point is the equation for the Lorentz force (no electric field):","f6f8cb35":"### <span style=\"color: green;\"> CHECKPOINT 2: Make sure that the analytical and numerical solution give similar results. If not, check your implementation of the Euler method again. If unsure, you are welcome to pop in the drop-in tutoring sessions on Zoom (see Canvas announcements).<\/span>\n","baa5ca42":"Next, we define a second function that implements a single Euler step, $ y_{\\rm out}= y_{\\rm in} + h \\: F(y_{\\rm in})$.","7170f5f8":"While this algorithm is simple to implement, numerical errors in the scheme scale badly with the time step $h$, and in order to avoid numerical instabilities and incorrect results, one can be forced to use prohibitively small time steps $h$. Nevertheless, we will use this scheme here for its simplicity. \n\nA video tutorial on the Euler method can be found here:\nhttps:\/\/www.khanacademy.org\/math\/ap-calculus-bc\/bc-differential-equations-new\/bc-7-5\/v\/eulers-method\n\nIf you are interested in how to improve upon this method, you can learn about a superior algorithm, the Runge-Kutta scheme, in the Extra for Experts section at the end of this notebook. The numerical error in the Runge-Kutta method scales with $h^5$ instead of with $h$ for the Euler method. That means that halving the time step $h$ will halve the numerical  error made in the Euler scheme while it goes down to $2^{-5}$ for the Runge-Kutta algorithm.","fc38fa7d":"Now that we know how to numerically solve differential equations lets see what else we can do. \nOne example is the Lorentz attractor that corresponds to the set of equations:","55cf9c20":"We know from class that the component of motion parallel to the magnetic field remains unchanged. If we can align the $z$ axis so that ${\\bf B} = B_0\\, \\hat{\\bf{k}}$, then the acceleration in $z$ direction $a_z$ is zero and we can reduce the problem to a two-dimensional one. We obtain a set of two coupled differential equations of **second order** (since we have **second derivatives**):","730b3077":"Adding an additional library allows us to automate solving differential equations using the function odeint. So once we have learnt what to do we don't need to bother doing it every again. We do however have to rewrite the derivative function so that it is in the correct format for use with odeint. ","a3cec9af":"Now we can use the Runge-Kutta method to intergrate our equations of motions instead of the Euler method.","d0ba593e":"Note that ```time``` is an array going from ```time[0]``` to ```time[time_steps-1]```. The time interval of each time step is given by the variable ```step```.","916a42d6":"###  <span style=\"color: red;\"> Task 2: Complete the implementation of the Euler method below.  <\/span>\n                                                                                                        [8 marks]","6e3798c4":"## Section 3: Numerical solution of the differential equations for cyclotron motion","29d082b9":"## Section 5: Runge Kutta method","a22286f5":"One can then calculate an approximate solution for $y(t_2)=y_2$ from $y_1$ at $t_2 = t_1 + h$, using the slope at $y_1$ and $t_1$. We can then proceed to approximate $y_3$ at time $t_3$ from $y_2$ and so on. Thus, the general **Euler scheme** is given by:\n\n$$ y_{n+1}= y_n + h \\: F(y_n,t_n) \\quad {\\rm with} \\quad t_{n+1} = t_n + h .$$\n","9856f0a9":"## Section 1: Derivation of differential equations for cyclotron motion","fe484f7d":"### Section 3a: Euler method","0d268c07":"In Section 4 you are guided to explore your code a bit further, while Section 5 introduces you to a better numerical integration method, the Runge-Kutta scheme. Finally,  Section 6 uses your newly gained numerical integration knowledge to solve the Lorentz attractor differential equations.","0487aa20":"One can solve the set of four differential equations to arrive at the following general solutions (see Cyclotron_Motion_Solution.pdf on Canvas for more details):","285ffa4e":"**Code Snippet #3**","6aeb7237":"$$ {\\bf a} = \\frac{d^2 {\\bf r}}{d t^2} = \\frac{q}{m} {\\bf v} \\times {\\bf B},$$","ff27abb4":"$$ \\begin{align}\nr_x(t) =&\\; \\; \\frac{v}{\\omega} \\: \\sin(\\omega t)\\\\\nr_y(t) =&\\; \\; \\frac{v}{\\omega} \\: \\cos(\\omega t)\\\\\nv_x(t) =&\\, \\quad v \\cos(\\omega t) \\\\\nv_y(t) =&\\, -v \\sin(\\omega t) \n\\end{align} $$","4570ed8e":"... and the implementation of the Runge Kutta scheme:","ef7c32a6":"$$ \\begin{align}\n\\frac{d x}{d t} & = \\sigma (y -x) \\\\\n\\frac{d y}{d t} & = x (\\rho -z)-y \\\\\n\\frac{d z}{d t} & = x y -\\beta z\n\\end{align}\n$$","6f8bbd49":"The error term in the Runge Kutta method can be shown to scale like $h^5$ and the Runge Kutta scheme is therefore described as a fourth-order method. This means that if the step size is reduced by a factor of two ($h\\rightarrow h\/2$), the error reduces by a factor of $2^5=32$. This is quite an improvement, since reducing the step size by a factor of two only doubles the number of steps required to get from $t=0$ to $t=T$ (i.e., with fixed intergration time).","ec3cea98":"## Running on autopilot","bd6cf885":"After we have successfully implemented the code, it is interesting to look at the error made in the numerical solution in more detail. We should expect that the error in the numerical solution increases with time. It would be nice to quantify the numerical error and look at how it changes with the Euler time step $h$.","a785de4d":"<span style=\"color: green;\"> This notebook contains a total of 4 tasks. The marking scheme for every task is given below the task. You can get up to 60 marks in total.<\/span> \n    \nYou should **complete the whiteboard exercise on Canvas first**  (20 of 80 marks). Then, complete the notebook up to at least Task 1 and submit this preliminary version on Canvas by 6 pm on Monday 21st September. (Look out for the <span style=\"color: green;\"> green checkpoint markers!<\/span>) Submitting the partially completed notebook will enable the graduate teaching assistants to provide feedback for you prior to your final submission (we endeavour to get the feedback to you by the evening of Tuesday 22nd September). Complete the rest of PiP 2 and submit your whole notebook on Canvas by 6 pm on Thursday 24th September (60 of 80 marks).\n\nWhile you are completing this PiP online (and if possible in class on Monday 21st September), you are encouraged to view the introductory video and attend the class online or face-to-face on Monday 21st September. We also encourage you to discuss ideas on Piazza, and access the drop-in tutoring on Zoom during the 2nd week of the mid-semester break or in the first week back (see the Canvas announcement for more details).\n\nThere is also a bonus task at the end that allows you to get up to 10 extra marks. Nevertheless, the maximum score remains 60 marks for this PiP.","b1c0818c":"We can change these **second-order** differential equations to a set of 4 coupled differential equations of **first order**:","88979ad3":"We are now ready to try and solve the differential equations given above numerically. The numerical solution of differential equations is non-trivial and in fact scientists and mathematicians have spent decades designing algorithms for solving such equations.  The simplest algorithm for numerically integrating first-order differential equations is the Euler method. \n\nConsider a single-variable differential equation of the form:","e618f91b":"Note that ```time``` is a numpy array, thus the arrays ```exact_position_x\/_y``` and ```exact_velocity_x\/_y``` are also numpy arrays.\n\nAnd now let's plot:","6050182f":"### Initial conditions###\n\nNext, we have to define our **inital conditions** and then we plot the solutions:\n\nConsider a particle with  $\\frac{q}{m}=1~\\text{C\/kg}$  moving in a uniform magnetic field of $1~\\text{T}$ applied in $+z$-direction. At time $t=0$, it is located at $(r_{x0},r_{y0},r_{z0}) = (0, 10, 0)~\\text{m}$ and is travelling at a speed of $v = 10~\\text{m\/s}$  in the $+x$-direction. Remember that we set the origin of the coordinate system to be the centre of the circular path that the particle will follow and the phase $\\phi$ to 0.\n\nWe define the time range \\[```start_time```, ```end_time```\\] over which we want to track the motion of the particle by setting the initial time to zero and the number of loops to ```N_loops = 2```. Choose the number of steps per revolution to be ```steps_rev = 1000```. The cyclotron frequency ```omega``` as defined above determines the period of revolutions ```period_rev```. (Recall that the number $\\pi$ is implemented as ```np.pi```.) The ``end_time`` can then be determined from the number of loops and the period for one revolution. ","a988d105":"$$\\frac{d y}{d t} =  F(y,t)$$","78507477":"Next we define a second function that implements a single Runge-Kutta step.","e88e516c":"We are going to integrate the equations of motion from time $t=0$ to $t=$ ```end_time``` broken up into in a number of equally spaced time steps. We will use the same number of timesteps per revolution, given by the variable ```steps_rev``` as defined above, for the number of numerical integration steps that we will use for each loop. Increasing this variable decreases the time step $h$; it will give you a more accurate result but will also slow down the program. The array ```time``` contains the value of $t$ for each integration step. We will use the same array as used above for the plot of the analytical solution to make the comparison between the analytical and numerical solution easy. \n\nNext we define the arrays ```position_x``` and ```position_y``` as well as ```velocity_x``` and ```velocity_y``` to store the calculated values of the components of positions and velocities for each time step. Therefore, we set the length of the arrays to the number of time steps initialising the arrays with zeros.","3d9c130b":"As you can see this solution is similar to the one obtained using our simple Runge Kutta algorithm. The difference is due to the fact that the Lorenz system is chaotic and so even small differences in the starting conditions diverge exponentially in time. Since odeint uses a different algorithm for the integration the numerical error is different and this small difference get magnified as we continue our integration.","0cef1610":"### <span style=\"color: red;\"> Bonus Task: Try to implement one way of computing the numerical error. Use this implementation to show how the numerical error increases with time and discuss your results.  <\/span>\n\n                                                                                       \n                                                                                                  [10 bonus marks]","ac8d1171":"With a few extra libraries we can plot this is 3D.","f57e1d4e":"The Runge-Kutta method starts with an initial value ${\\bf y}(t_0)={\\bf y}_0$ and calculates an approximate solution ${\\bf y}_{\\rm out}$ at a later time $t_1=t_0+h$ using the following procedure:","15aea54d":"###  <span style=\"color: red;\"> Task 3: Combine the code snippets #0 - #8 to make a single program. Use the finished program to do the following:\n<\/span>\n\n<span style=\"color: red;\">    (a) Increase the number of loops to 8; comment on the change in accuracy you observe.<\/span>\n    \n    \n<span style=\"color: red;\">    (b) Think about a parameter you can change to make the error in the numerical solution smaller. Describe your idea and check it by running the program for 8 loops with the changed parameter. <\/span>\n\n<span style=\"color: red;\">    (c) Determine and describe what happens to the radius of the path if the initial speed is doubled? And then halved? Are these results what you expect from the equations derived above?<\/span>\n\n                                                                                                        [24 marks]","c9acd348":"###  <span style=\"color: red;\">  Task 4: Think of at least one way to quantify (compute) the numerical error and show how the error depends on the time step used. Write your idea(s) into the box below. <\/span>\n                                                                                                        [12 marks]","ea45c484":"$$ \\begin{align}\nr_x(t) =&\\;\\; \\frac{v}{\\omega}\\:\\sin(\\omega t-\\phi)+r_{xc}\\\\\nr_y(t) =&\\;\\; \\frac{v}{\\omega}\\: \\cos(\\omega t-\\phi) +r_{yc}\\\\\nv_x(t) =&\\quad \\, v \\cos(\\omega t-\\phi) \\\\\nv_y(t) =&\\, -v \\sin(\\omega t-\\phi) \n\\end{align} $$","3d868f0f":"Let's now calculate the analytical solution:","6f951892":"**Code Snippet #5**","01638db9":"**Code Snippet #4**","c5d0a9a6":"### Section 3c: Quantifying the numerical error ","07c731ab":"###  <span style=\"color: green;\">Marking Scheme: <\/span>\nMarks are given for correct implementation","7db661b0":"By inserting the solutions into the differential equations above, you can easily verify that the solutions are correct.","d466e8af":"Having found the analytical solutions we want to plot them to see what they look like. As usual, we start with importing a couple of standard Python libraries.","d1c7ba36":"$$ {\\bf F} = q {\\bf v} \\times {\\bf B}.$$","d625223c":"We can solve these equations with only minor modifications to what we did before. Since the Lorentz equations are three dimensional we define a new array position_z and also change the intergration time and number of steps.","fe6a7920":"# PiP 2: Analysis of Cyclotron Motion","c5f00de4":"where the phase $\\phi$ and initial velocities $v_x(t=0)=v_{x0}$ and $v_y(t=0)=v_{y0}$ are determined by the initial conditions. \n\nThe position ($r_{xc},r_{yc}$) defines the centre of the circle of the particle's motion. The speed of the particle is $v = (v_{x0}^2 + v_{y0}^2)^{1\/2}$. If we move the origin of the coordinate system to the centre of the circle  $(r_{xc},r_{yc}) = (0,0)$ and set the initial phase to zero, $\\phi =0$, we can simplify the solutions without loss of generality:","3e43b2cf":"**Code Snippet #6**","00e3b174":"$$ \\begin{align}\n\\frac{d r_x}{d t} & = v_x &\\\\\n\\frac{d r_y}{d t} & = v_y &\\\\\n\\frac{d v_x}{d t} & = \\frac{B_0 q}{m} v_y &=&  \\: \\omega \\:  v_y\\\\\n\\frac{d v_y}{d t} & = -\\frac{B_0 q}{m} v_x &=& - \\omega v_x\n\\end{align}\n$$","4859d9a5":"Using this force as the net force in Newton's second law, we can find","0e25550a":"We will use the same program function as the one used in task 3, but we will add a function call that will calculate the error at each time step","55cc340b":"You can check and use your code written above further in the following ways:\n \n* Record the error for the velocity for 200, 400, 800 and 1600 time steps (fixed time interval) and work out the ratio of the errors. Does it agree with the theory? \n\n*  Determine and describe what happens to the number of \u201cloops\u201d if the initial speed is double the initial speed on the whiteboard? And for half the initial speed? Is that result what you expect from the analytical solution?\n\n* Restore the particle's velocity to the initial value provided for the whiteboard exercise. Next, change the particle\u2019s initial velocity so that it has a positive, nonzero y-component, about 10 times smaller than the initial x-component of the velocity. Describe the path. Did this change affect how many \u201cloops\u201d the particle completed?\n\n* Turn the particle into an anti-particle (same mass, opposite charge). How does the path of the anti-particle compare to that of the original particle ? Explain the differences in terms of the force on the particles. \n                                                                                                                                                                                             ","110e2ddd":"Now, let's plot the numerical solution and compare with the analytical one.","5066d7ab":"###  <span style=\"color: red;\"> Task 1: <\/span>\n\n<span style=\"color: red;\">    (a) Enter the right initial conditions and formulae for the quantities calculated from the input in the code snippet #1 below. If unsure how to do this, re-read the section on ***initial conditions*** above.<\/span>\n    \n<span style=\"color: red;\">    (b) Use the following code snippets to plot the $x$ and $y$ positions of the particle over time and the trajectory of the particle in the $x$-$y$ plane. <\/span>\n \n                                                                                                        [16 marks]","123bb9c4":"### <span style=\"color: green;\"> CHECKPOINT 1: Do the plots look like you think they should? If not, check your initial conditions again. Complete and submit your **whiteboard exercise** and **Task 1** on Canvas by 6 pm on Monday 21st September.<\/span>","7ac6fa00":"## Section 6: Some fun with differential equations: Lorentz attractor ","edf9d606":"Next, we define the initial conditions (we can get them from using the exact solutions a $t$ = 0). Then, we go from one time step to the next using the function for the Euler method defined above.","714b09f4":"## Section 2: Analytical solution for cyclotron motion","7ec41ca1":"###  <span style=\"color: green;\">Marking Scheme: <\/span>\n8 marks for correct initial conditions, 8 for correct input of formulae for calculated values.","fd31faa3":"Jack Kettley","6d84dfaf":"$$ \\begin{align}\n\\frac{d^2 r_x}{d t^2} & = \\frac{B_0 q}{m} v_y \\\\\n\\frac{d^2 r_y}{d t^2} & = -\\frac{B_0 q}{m} v_x\n\\end{align}\n$$","67971cc2":"Now we can implement the Euler algorithm. We have seen above that our problem can be written in the form of four coupled differential equations of first order:\n\n$$ \\begin{align}\n\\frac{d r_x}{d t} & = v_x \\\\\n\\frac{d r_y}{d t} & = v_y \\\\\n\\frac{d v_x}{d t} & = \\omega \\: v_y \\\\\n\\frac{d v_y}{d t} & = -\\omega \\: v_x\n\\end{align}\n$$\n\nWe can re-write the above in vectorial notation, with ${\\bf{y}}(t) = \\begin{pmatrix} r_x(t)\\\\r_y(t)\\\\v_x(t)\\\\v_y(t) \\end{pmatrix}$:\n\n\\begin{equation}\n\\frac{d \\, {\\bf{y}}(t)}{dt} = \\begin{pmatrix} v_x \\\\ v_y \\\\ \\omega \\: v_y\\\\ -\\omega \\: v_x \\end{pmatrix} = \n{\\bf{F}}({\\bf{y}}(t),t) = {\\bf{F}}({\\bf{y}}(t)) \n\\end{equation}\n\nNote that there is no explicit time dependence of ${\\bf{F}}({\\bf{y}}(t),t)$, so we can just write ${\\bf{F}}({\\bf{y}}(t))$ here.\n\nRemember for the following part that, in Python notation, $y\\left[0\\right]=r_x$, $y\\left[1\\right]=r_y$, $y\\left[2\\right]=v_x$ and  $y\\left[3\\right]=v_y$. \n\nFirst, we will define a function ```der``` that returns the vector of the derivatives. ","12151e8e":"In order to implement the method and apply it to our problem, we first need to define arrays for ```time```, ```position``` and ```velocity```.","7d9c5d2e":"Recall that ```numpy``` is a numerical library that contains a lot of useful mathematical functions. In order to use those functions we have to use the prefix ```np.``` in front of the function. E.g. $sin(x)$ would be implemented as ```np.sin(x)``` in python. ```matplotlib``` is a plotting library that we will use.","db755b03":"**Code Snippet #1**","0afc9412":"# Extra for Experts","3fbd9782":"### Implementation","d376a956":"** Code snippet #8**"}}