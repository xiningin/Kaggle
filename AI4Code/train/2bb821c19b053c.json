{"cell_type":{"36cee545":"code","a68b5ed2":"code","b9acdf8a":"code","e2060090":"code","78db8c6d":"code","3fab4461":"code","47d81607":"code","950b19da":"code","509617b9":"code","6d711bb1":"code","00d62212":"code","38816eda":"code","42fca2d5":"code","93e8c82c":"code","a0b1fbfa":"code","984f65ba":"code","792f744d":"code","05bd3604":"code","fa2a5cc3":"code","def35696":"code","4c02b8b0":"code","174d51b5":"code","fc75ea1e":"code","dfd75197":"code","8bab628e":"code","de8ed633":"code","4f198100":"code","e94ee761":"code","807bb725":"code","06d72f36":"code","de4e4bba":"code","2d1d37f9":"code","387e9b86":"code","ee7f629a":"markdown","3f3f2bf2":"markdown","47ff8f03":"markdown","7816e993":"markdown","3f122bdc":"markdown","99f2ded3":"markdown","ba1a3b6d":"markdown","9b4a2f07":"markdown","efc1fbed":"markdown","c3bf16b2":"markdown","df856abd":"markdown","d842575f":"markdown","e6d08db0":"markdown","ccf4108b":"markdown","542730f5":"markdown","80a3c5b8":"markdown","c6c8a0a3":"markdown","6ff588ed":"markdown","1ba7f49e":"markdown","84c25f28":"markdown","89fb39fd":"markdown","9b36075e":"markdown","03faa3e7":"markdown","5edf4128":"markdown","6f48244e":"markdown","8ad7e013":"markdown","c8f9d2f3":"markdown","dae3d131":"markdown","070277a6":"markdown","60e43e1d":"markdown","8dfd7a51":"markdown","d27d45a8":"markdown","b650a1ac":"markdown","e35473d4":"markdown","3fcab60d":"markdown","e96bfc06":"markdown","d90f616f":"markdown"},"source":{"36cee545":"\"\"\"\n@author: Jack Hart\n\"\"\"\nimport numpy as np\nimport pandas as pd\nimport plotly\nimport plotly.plotly as py\nimport plotly.graph_objs as go\nimport networkx as nx\nimport itertools\nfrom collections import Counter\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom networkx.algorithms import community\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode(connected=True)\n","a68b5ed2":"character_details = pd.read_csv('..\/input\/characters.csv', encoding='latin-1')\n\n#node\/comics data\ncomics = pd.read_csv('..\/input\/comics.csv', encoding='latin-1')\n\n#edge data\nedges_CharacterComic = pd.read_csv('..\/input\/charactersToComics.csv', encoding='latin-1')","b9acdf8a":"comics['cleanTitles'] = comics.title.str.split('#', expand = True)[0]\n      \ntemp = comics.groupby(['cleanTitles']).size().reset_index()\ntemp = temp.rename(columns={0: \"count\"})\ncomics_unique = temp","e2060090":"#create functions for apply\ndef findComic(EdgeID, comicList):\n    return(comics['cleanTitles'][comicList.index(EdgeID)])\n\ndef findCharacter(EdgeID, characterList):\n    return(character_details['name'][characterList.index(EdgeID)])\n\n#create names in the edges dataframe\nlistofComics = list(comics['comicID'])\nedges_CharacterComic['comicName'] = edges_CharacterComic['comicID'].apply(lambda x: findComic(x,listofComics))\n\nlistofCharacters = list(character_details['characterID'])\nedges_CharacterComic['characterName'] = edges_CharacterComic['characterID'].apply(lambda x: findCharacter(x,listofCharacters))","78db8c6d":"#create edges list\nEdges=[(edges_CharacterComic['characterName'][k], edges_CharacterComic['comicName'][k]) for k in range(len(edges_CharacterComic))]\n\n#Remove duplicate edges created by \"cleaning\" comics to remove repeats\nEdges = list(set(Edges))","3fab4461":"#list of labels and group type for nodes\nlabels=[]\ngroup=dict()\n\nlabels.extend(list(set(comics_unique['cleanTitles'])))\nfor node in list(set(comics_unique['cleanTitles'])):\n    count = int(comics_unique[comics_unique['cleanTitles'] == node]['count'])\n    group[str(node)] = {'type': 'comic', 'count': count}\n\nlabels.extend(list(set(character_details['name'])))\nfor node in list(set(character_details['name'])):\n    group[str(node)] = {'type': 'character'}","47d81607":"#create graph\nG=nx.Graph()\n\n#add nodes to graph\nG.add_nodes_from(labels)\n\n#add in node attributes\nnx.set_node_attributes(G, group)\n\n#add edges to graph\nG.add_edges_from(Edges)","950b19da":"#keep nodes with >10 degrees\nkeep = [node for node,degree in G.degree() if degree > 10]\nkeep = dict((k, G.node(data=True)[k]) for k in tuple(keep))\n\n#significantly decreased number of nodes\nprint(G.number_of_nodes())\nprint(len(keep))\n\n#create new (smaller) graph\nf = nx.Graph()                                                                                          \nfedges = filter(lambda x: G.degree()[x[0]] > 10 and G.degree()[x[1]] > 10, G.edges())\nf.add_nodes_from(keep)\nf.add_edges_from(fedges)\nnx.set_node_attributes(f, keep)\n\n#reduced the number of edges\nprint(G.number_of_edges())\nprint(f.number_of_edges())","509617b9":"#Set the 3-d layout type\npos = nx.spring_layout(f, dim = 3)\n\n#Set the 2-d layout type\npos_2 = nx.kamada_kawai_layout(f, dim = 2)","6d711bb1":"#aveage density \nprint(nx.density(G))","00d62212":"print(nx.average_clustering(G))\n#Therefore, connot use closeness centrality for determining important nodes","38816eda":"#Create list of comic and character node names\ncomicNodes = [x for x,y in f.nodes(data=True) if y['type'] == 'comic']\ncharacterNodes = [x for x,y in f.nodes(data=True) if y['type'] == 'character']\n\n#Create lists of comic and character node degrees\ncomicdegrees = []\ncomicOrder = []\ncharacterdegrees = []\ncharacterOrder = []\nfor node, degree in G.degree():\n    if node in comicNodes:\n        comicdegrees.append(degree)\n        comicOrder.append(node)\n        \n    else:\n        characterdegrees.append(degree)\n        characterOrder.append(node)\n        \n#Count the frequency of degrrees and put them into dataframes\ncomicCounts = Counter(comicdegrees)\ncomicCounts = pd.DataFrame(list(dict(comicCounts).items()), columns=['degree', 'count']).sort_values(by=['degree'])\n\ncharacterCounts = Counter(characterdegrees)\ncharacterCounts = pd.DataFrame(list(dict(characterCounts).items()), columns=['degree', 'count']).sort_values(by=['degree'])","42fca2d5":"#Plot degrees\ntrace_comic_degree = go.Scatter(\n    x = list(comicCounts['degree']),\n    y = list(comicCounts['count']),\n    mode = 'lines+markers',\n    name = 'Comics'\n)\n\ntrace_character_degree = go.Scatter(\n    x = list(characterCounts['degree']),\n    y = list(characterCounts['count']),\n    mode = 'lines+markers',\n    name = 'Characters'\n)\n\nlayout=go.Layout(\n    title=\"<b>Marvel Character To Comic Network Degrees\",\n    titlefont=dict(size=16),\n    showlegend=True,\n    hovermode='closest',\n    xaxis = dict(title = 'Degree (# of connections to node)', range=[0, 150]),\n    yaxis = dict(title = 'Count (the amount of nodes with a certain # of connections)', range=[0, 100]) )\n\nfig = go.Figure(data=[trace_comic_degree, trace_character_degree], layout = layout)\n\n#plot offline\n#plotly.offline.plot(fig, filename = \"DegreeLinePlot.html\")\n\niplot(fig, filename='DegreeLinePlot')","93e8c82c":"#average degree conections of neighbors for a node with given # of connections.\nconectivity = pd.DataFrame(list(nx.average_degree_connectivity(G).items()), columns=['degree', 'averagedegree']).sort_values(by=['degree'])\n\n#plot average degree conections\ntrace_degree = go.Scatter(\n    x = list(conectivity['degree']),\n    y = list(conectivity['averagedegree']),\n    mode = 'lines+markers',\n    name = 'Average Degrees'\n)\n\nlayout=go.Layout(\n    title=\"<b>Marvel Character To Comic Network: Average Degree of Neighbors for Nodes of Given Degree\",\n    titlefont=dict(size=16),\n    showlegend=False,\n    hovermode='closest',\n    xaxis = dict(title = 'Node Degree (# of connections to node)', range=[0, 200]),\n    yaxis = dict(title = \"Average Degree of Neighbors (aveage # of connections for a nodes neighbors)\", range=[0, 250]) )\n\nfig = go.Figure(data=[trace_degree], layout = layout)\n\n#plot offline\n#plotly.offline.plot(fig, filename = \"ConectivityLinePlot.html\")\niplot(fig, filename='ConectivityLinePlot')","a0b1fbfa":"#Find comics and character nodes with greatest number of degrees\ncomicsByDegree = pd.DataFrame({'comic': comicOrder, 'degree': comicdegrees}).sort_values(by=['degree'], ascending = False)\ncharactersByDegree = pd.DataFrame({'character': characterOrder, 'degree': characterdegrees}).sort_values(by=['degree'], ascending = False)\ncomicsByDegreeHead = comicsByDegree.head(15)\ncharactersByDegreeHead = charactersByDegree.head(15)\n\nax = sns.barplot(x=charactersByDegreeHead.degree, y=charactersByDegreeHead.character,\n                 palette=\"Blues_d\")\nax.set(xlabel='Character', ylabel='Degree')\nplt.show()\n\nax2 = sns.barplot(x=comicsByDegreeHead.degree, y=comicsByDegreeHead.comic,\n                 palette=\"Greens_d\")\nax2.set(xlabel='Comic', ylabel='Degree')\nplt.show()","984f65ba":"#create the edges\nedge_trace = go.Scatter3d(\n    x=[],\n    y=[],\n    z=[],\n    line=dict(width=1,color='#888'),\n    hoverinfo='none',\n    mode='lines')\n\n\n#apply functions for adding edge positions\ndef returnxPositions(edge, formats):\n    return(tuple([formats[edge[0]][0],formats[edge[1]][0], None]))\n\ndef returnyPositions(edge, formats):\n    return(tuple([formats[edge[0]][1],formats[edge[1]][1], None]))\n\ndef returnzPositions(edge, formats):\n    return(tuple([formats[edge[0]][2],formats[edge[1]][2], None]))\n\n\n#add edge postions to trace\nedge_trace['x'] = tuple(itertools.chain(*pd.Series(f.edges()).apply(lambda x: returnxPositions(x,pos))))\nedge_trace['y'] = tuple(itertools.chain(*pd.Series(f.edges()).apply(lambda x: returnyPositions(x,pos))))\nedge_trace['z'] = tuple(itertools.chain(*pd.Series(f.edges()).apply(lambda x: returnzPositions(x,pos))))","792f744d":"#create the nodes for comics (with the color based on # of connections)\nnode_trace_comic = go.Scatter3d(\n    x=[],\n    y=[],\n    z=[],\n    text=[],\n    mode='markers',\n    hoverinfo='text',\n    marker=dict(\n        showscale=True,\n        # colorscale options\n        #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |\n        #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |\n        #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |\n        colorscale='Greens',\n        reversescale=True,\n        color=[],\n        size=20,\n        colorbar=dict(\n            thickness=10,\n            title='Node Connections for Comics',\n            xanchor='left',\n            titleside='right'\n        ),\n        line=dict(width=2))    \n        )\n\nfor node in comicNodes:\n    x, y, z = pos[node]\n    node_trace_comic['x'] += tuple([x])\n    node_trace_comic['y'] += tuple([y])\n    node_trace_comic['z'] += tuple([z])\n    \nfor node, adjacencies in f.adjacency():\n    if(node in comicNodes):\n        node_trace_comic['marker']['color']+=tuple([len(adjacencies)])\n        node_info = ('Comic: {comic}<br>'+ '# of Issues: {issues}<br>'+\n         '# of connections: {connections}<br>').format(comic = str(node),\n                                                       issues = keep[node]['count'],\n                                                       connections = str(len(adjacencies)))\n        node_trace_comic['text']+=tuple([node_info])\n\n\n\n#create the nodes for characters (with the color based on # of connections)\nnode_trace_character = go.Scatter3d(\n    x=[],\n    y=[],\n    z=[],\n    text=[],\n    mode='markers',\n    hoverinfo='text',\n    marker=dict(\n        showscale=True,\n        # colorscale options\n        #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |\n        #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |\n        #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |\n        colorscale='Blues',\n        reversescale=True,\n        color=[],\n        size=20,\n        colorbar=dict(\n            thickness=10,\n            title='Node Connections for Characters',\n            xanchor='right',\n            titleside='right'\n        ),\n        line=dict(width=2))    \n        )\n\n\nfor node in characterNodes:\n    x, y, z = pos[node]\n    node_trace_character['x'] += tuple([x])\n    node_trace_character['y'] += tuple([y])\n    node_trace_character['z'] += tuple([z])\n\nfor node, adjacencies in f.adjacency():\n    if(node in characterNodes):\n        node_trace_character['marker']['color']+=tuple([len(adjacencies)])\n        node_info = ('Character: {character}<br>'+ '# of connections: {connections}<br>').format(\n                     character = str(node),\n                     connections = str(len(adjacencies)))\n        node_trace_character['text']+=tuple([node_info])\n        \n        #node_info = str(node) + ': # of connections = '+str(len(adjacencies))\n        #node_trace_character['text']+=tuple([node_info])\n    \n","05bd3604":"#create the layout\nlayout=go.Layout(\n    title=\"<b>Marvel Network: Characters' Relationships to Comics\",\n    titlefont=dict(size=16),\n    showlegend=False,\n    hovermode='closest',\n    margin=dict(b=20,l=5,r=5,t=40),\n    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)\n    )\n\n\n#combine\nfig = go.Figure(data=[edge_trace, node_trace_character, node_trace_comic], layout = layout)\n\n#plot offline\n#plotly.offline.plot(fig, filename = \"SuperHeroComicNetwork.html\")\niplot(fig, filename='SuperHeroComicNetwork')","fa2a5cc3":"#create the edges\nedge_trace2 = go.Scatter(\n    x=[],\n    y=[],\n    line=dict(width=.3,color='#888'),\n    hoverinfo='none',\n    mode='lines')\n\n#add edge postions to trace\nedge_trace2['x'] = tuple(itertools.chain(*pd.Series(f.edges()).apply(lambda x: returnxPositions(x,pos_2))))\nedge_trace2['y'] = tuple(itertools.chain(*pd.Series(f.edges()).apply(lambda x: returnyPositions(x,pos_2))))\n\n#create the nodes for comics (with the color based on # of connections)\nnode_trace_comic_2 = go.Scatter(\n    x=[],\n    y=[],\n    text=[],\n    mode='markers',\n    hoverinfo='text',\n    marker=dict(\n        showscale=True,\n        # colorscale options\n        #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |\n        #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |\n        #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |\n        colorscale='Greens',\n        reversescale=True,\n        color=[],\n        size=20,\n        colorbar=dict(\n            thickness=10,\n            title='Node Connections for Comics',\n            xanchor='left',\n            titleside='right'\n        ),\n        line=dict(width=2))    \n        )\n\nfor node in comicNodes:\n    x, y = pos_2[node]\n    node_trace_comic_2['x'] += tuple([x])\n    node_trace_comic_2['y'] += tuple([y])\n    \nfor node, adjacencies in f.adjacency():\n    if(node in comicNodes):\n        node_trace_comic_2['marker']['color']+=tuple([len(adjacencies)])\n        node_info = ('Comic: {comic}<br>'+ '# of Issues: {issues}<br>'+\n         '# of connections: {connections}<br>').format(comic = str(node),\n                                                       issues = keep[node]['count'],\n                                                       connections = str(len(adjacencies)))\n        node_trace_comic_2['text']+=tuple([node_info])\n\n\n#create the nodes for characters (with the color based on # of connections)\nnode_trace_character_2 = go.Scatter(\n    x=[],\n    y=[],\n    text=[],\n    mode='markers',\n    hoverinfo='text',\n    marker=dict(\n        showscale=True,\n        # colorscale options\n        #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |\n        #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |\n        #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |\n        colorscale='Blues',\n        reversescale=True,\n        color=[],\n        size=20,\n        colorbar=dict(\n            thickness=10,\n            title='Node Connections for Characters',\n            xanchor='right',\n            titleside='right'\n        ),\n        line=dict(width=2))    \n        )\n\nfor node in characterNodes:\n    x, y = pos_2[node]\n    node_trace_character_2['x'] += tuple([x])\n    node_trace_character_2['y'] += tuple([y])\n\nfor node, adjacencies in f.adjacency():\n    if(node in characterNodes):\n        node_trace_character_2['marker']['color']+=tuple([len(adjacencies)])\n        node_info = ('Character: {character}<br>'+ '# of connections: {connections}<br>').format(\n                     character = str(node),\n                     connections = str(len(adjacencies)))\n        node_trace_character_2['text']+=tuple([node_info])\n\n\n#create the layout\nlayout=go.Layout(\n    title=\"<b>Marvel Network: Characters' Relationships to Comics\",\n    titlefont=dict(size=16),\n    showlegend=False,\n    hovermode='closest',\n    margin=dict(b=20,l=5,r=5,t=40),\n    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n    annotations=[\n        dict(\n        showarrow=False,\n        text=\"Original network had 10193 nodes and 23402 edges. <br> For simplicity, this is a network contains only the nodes of the original network with greater than 10 connections. \",\n        xref='paper',\n        yref='paper',\n        x=0,\n        y=0.05,\n        xanchor='left',\n        yanchor='bottom',\n        font=dict(\n        size=14\n        ))]\n    )\n\n\n#combine\nfig2 = go.Figure(data=[edge_trace2, node_trace_character_2, node_trace_comic_2], layout = layout)\n\n#plot offline\n#plotly.offline.plot(fig2, filename = \"SuperHeroComicNetwork2D.html\")\n\niplot(fig2, filename='SuperHeroComicNetwork2D')","def35696":"#create a sorted numpy array\nnumpyEdges = edges_CharacterComic.sort_values(by=['comicID']).values\n\n#sort into separte arrays by comic connection ~45 seconds\nx = numpyEdges[:,[2,3]]\ny = [x[x[:,0]==k] for k in np.unique(x[:,0])]\n\n#create a list of lists that have combinations for each comic\nlists = [list(itertools.combinations(y[x][:,1],2)) for x in range(len(y))]\n\n#put all into 1 list\nAllcombinations = [item for sublist in lists for item in sublist]\n\n#get only unique combinations\ncombinations = list(set(tuple(sorted(p)) for p in Allcombinations)) \n\n#remove edges with same nodes\ncombinations = [ (a,b) for a,b in combinations if a != b] \n\n#create a pandas dataframe\nhero_edges = pd.DataFrame(combinations, columns=['char1', 'char2'])","4c02b8b0":"#Create list of character (node) names\nlabels2 = list(set(character_details['name']))\n\n#create graph\nG2=nx.Graph()\n\n#add nodes to graph\nG2.add_nodes_from(labels2)\n\n#add edges to graph\nG2.add_edges_from(combinations)","174d51b5":"#keep nodes with >10 degrees\nkeep2 = [node for node,degree in G2.degree() if degree > 50]\nkeep2 = dict((k, G2.node(data=True)[k]) for k in tuple(keep2))\n\n#significantly decreased number of nodes\nprint(G2.number_of_nodes())\nprint(len(keep2))\n\n#create new (smaller) graph\nf2 = nx.Graph()                                                                                          \nfedges = filter(lambda x: G.degree()[x[0]] > 50 and G2.degree()[x[1]] > 50, G2.edges())\nf2.add_nodes_from(keep2)\nf2.add_edges_from(fedges)\nnx.set_node_attributes(f2, keep2)\n\n#reduced the number of edges\nprint(G2.number_of_edges())\nprint(f2.number_of_edges())","fc75ea1e":"#Remove nodes with no connections\nf2.remove_nodes_from(list(nx.isolates(f2)))\n","dfd75197":"#Set the 3-d layout type\npos_3 = nx.spring_layout(f2, dim = 3)\n\n#Set the 2-d layout type \npos_4 = nx.kamada_kawai_layout(f2, dim = 2)","8bab628e":"#create the edges\nedge_trace_4 = go.Scatter3d(\n    x=[],\n    y=[],\n    z=[],\n    line=dict(width=1,color='#888'),\n    hoverinfo='none',\n    mode='lines')\n\n#add edge postions to trace\nedge_trace_4['x'] = tuple(itertools.chain(*pd.Series(f2.edges()).apply(lambda x: returnxPositions(x,pos_3))))\nedge_trace_4['y'] = tuple(itertools.chain(*pd.Series(f2.edges()).apply(lambda x: returnyPositions(x,pos_3))))\nedge_trace_4['z'] = tuple(itertools.chain(*pd.Series(f2.edges()).apply(lambda x: returnzPositions(x,pos_3))))\n\n\n#create the nodes (with the color based on # of connections)\nnode_trace_4 = go.Scatter3d(\n    x=[],\n    y=[],\n    z=[],\n    text=[],\n    mode='markers',\n    hoverinfo='text',\n    marker=dict(\n        showscale=True,\n        # colorscale options\n        #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |\n        #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |\n        #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |\n        colorscale='Blues',\n        reversescale=True,\n        color=[],\n        size=20,\n        colorbar=dict(\n            thickness=10,\n            title='Node Connections',\n            xanchor='right',\n            titleside='right'\n        ),\n        line=dict(width=2))    \n        )\n\ncharacterNodes = [x for x,y in f2.nodes(data=True)]\nfor node in characterNodes:\n    x, y, z = pos_3[node]\n    node_trace_4['x'] += tuple([x])\n    node_trace_4['y'] += tuple([y])\n    node_trace_4['z'] += tuple([z])\n\nfor node, adjacencies in f2.adjacency():\n    if(node in characterNodes):\n        node_trace_4['marker']['color']+=tuple([len(adjacencies)])\n        node_info = ('Character: {character}<br>'+ '# of connections: {connections}<br>').format(\n                     character = str(node),\n                     connections = str(len(adjacencies)))\n        node_trace_4['text']+=tuple([node_info])\n\n#create the layout\nlayout=go.Layout(\n    title=\"<b>Marvel Network: Hero Relationships\",\n    titlefont=dict(size=16),\n    showlegend=False,\n    hovermode='closest',\n    margin=dict(b=20,l=5,r=5,t=40),\n    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)\n    )\n\n#combine\nfig = go.Figure(data=[edge_trace_4, node_trace_4], layout = layout)\n\n#plot offline\n#plotly.offline.plot(fig, filename = \"SuperHeroNetwork3D.html\")\n\niplot(fig, filename='SuperHeroNetwork3D')","de8ed633":"#create the edges\nedge_trace3 = go.Scatter(\n    x=[],\n    y=[],\n    line=dict(width=.3,color='#888'),\n    hoverinfo='none',\n    mode='lines')\n\n#add edge postions to trace\nedge_trace3['x'] = tuple(itertools.chain(*pd.Series(f2.edges()).apply(lambda x: returnxPositions(x, pos_4))))\nedge_trace3['y'] = tuple(itertools.chain(*pd.Series(f2.edges()).apply(lambda x: returnyPositions(x, pos_4))))\n\n\n#create the nodes (with the color based on # of connections)\nnode_trace_3 = go.Scatter(\n    x=[],\n    y=[],\n    text=[],\n    mode='markers',\n    hoverinfo='text',\n    marker=dict(\n        showscale=True,\n        # colorscale options\n        #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |\n        #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |\n        #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |\n        colorscale='Blues',\n        reversescale=True,\n        color=[],\n        size=20,\n        colorbar=dict(\n            thickness=10,\n            title='Node Connections',\n            xanchor='right',\n            titleside='right'\n        ),\n        line=dict(width=2))    \n        )\n\ncharacterNodes = [x for x,y in f2.nodes(data=True)]\n\nfor node in characterNodes:\n    x, y = pos_4[node]\n    node_trace_3['x'] += tuple([x])\n    node_trace_3['y'] += tuple([y])\n\nfor node, adjacencies in f2.adjacency():\n        node_trace_3['marker']['color']+=tuple([len(adjacencies)])\n        node_info = ('Character: {character}<br>'+ '# of connections: {connections}<br>').format(\n                     character = str(node),\n                     connections = str(len(adjacencies)))\n        node_trace_3['text']+=tuple([node_info])\n\n\n#create the layout\nlayout=go.Layout(\n    title='<b>Marvel Network: Hero Relationships',\n    titlefont=dict(size=16),\n    showlegend=False,\n    hovermode='closest',\n    margin=dict(b=20,l=5,r=5,t=40),\n    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n    annotations=[\n        dict(\n        showarrow=False,\n        xref='paper',\n        yref='paper',\n        x=0,\n        y=0.05,\n        xanchor='left',\n        yanchor='bottom',\n        font=dict(\n        size=14\n        ))]\n    )\n\n\n#combine\nfig3 = go.Figure(data=[edge_trace3, node_trace_3], layout = layout)\n\n#plot offline\n#plotly.offline.plot(fig3, filename = \"SuperHeroNetwork2D.html\")\n\niplot(fig3, filename='SuperHeroNetwork2D')","4f198100":"#aveage density \nprint(nx.density(G2))","e94ee761":"#average clustering -- 0.77\nprint(nx.average_clustering(G2))","807bb725":"conectivity2 = pd.DataFrame(list(nx.average_degree_connectivity(G2).items()), columns=['degree', 'averagedegree']).sort_values(by=['degree'])\n\n#plot average degree conections\ntrace_degree_2 = go.Scatter(\n    x = list(conectivity2['degree']),\n    y = list(conectivity2['averagedegree']),\n    mode = 'lines+markers',\n    name = 'Average Degrees'\n)\n\nlayout=go.Layout(\n    title=\"<b>Marvel Character Network: Average Degree of Neighbors for Nodes of Given Degree\",\n    titlefont=dict(size=16),\n    showlegend=False,\n    hovermode='closest',\n    xaxis = dict(title = 'Node Degree (# of connections to node)', range=[0, 900]),\n    yaxis = dict(title = \"Average Degree of Neighbors (aveage # of connections for a nodes neighbors)\", range=[0, 550]) )\n\nfig = go.Figure(data=[trace_degree_2], layout = layout)\n\n#plot offline\n#plotly.offline.plot(fig, filename = \"ConectivityLinePlotCharacter.html\")\niplot(fig, filename='ConectivityLinePlotCharacter')","06d72f36":"#Find character nodes with greatest number of degrees\ncharacterdegrees2 = []\ncharacterOrder2 = []\nfor node, degree in G2.degree():\n    characterdegrees2.append(degree)\n    characterOrder2.append(node)\n\ncharactersByDegree = pd.DataFrame({'character': characterOrder2, 'degree': characterdegrees2}).sort_values(by=['degree'], ascending = False)\ncharactersByDegreeHead = charactersByDegree.head(15)\n\nax = sns.barplot(x=charactersByDegreeHead.degree, y=charactersByDegreeHead.character,\n                 palette=\"Blues_d\")\nax.set(xlabel='Character', ylabel='Degree')\nplt.show()\n\n\n# Betweenness centrality\nbet_cen = nx.betweenness_centrality(G2)\n\nbetweeness_df = pd.DataFrame(list(bet_cen.items()), columns=['character', 'betweeness']).sort_values(by=['betweeness'], ascending = False)\nbetweeness_dfHead = betweeness_df.head(15)\n\nax2 = sns.barplot(x=betweeness_dfHead.betweeness, y=betweeness_dfHead.character,\n                 palette=\"Reds_d\")\nax2.set(xlabel='Character', ylabel='Betweenness')\nplt.show()","de4e4bba":"sub_graphs = list(community.kernighan_lin_bisection(f2))\n\n#list of nodes\nsub1Nodes = list(sub_graphs[0])\nsub2Nodes = list(sub_graphs[1])\n\n#list of edges\nsub1Edges = [ (a,b) for a,b in combinations if (a in sub1Nodes) and (b in sub1Nodes) ] \nsub2Edges = [ (a,b) for a,b in combinations if (a in sub2Nodes) and (b in sub2Nodes) ] \n\n#combine edge and node list together, because I will plot on one graph\ntotalEdges = sub1Edges + sub2Edges\ntotalNodes = sub1Nodes + sub2Nodes\n\n#This graph is technically two graphs, you can see this by the decrease in the number of edges\n# compared to the origonal\nprint(len(totalEdges))\nprint(len(combinations))\n\n\n#Create networkx graphs for each subgraph\n#First subgraph\nG3=nx.Graph()\n\n#add nodes to graph\nG3.add_nodes_from(totalNodes)\n\n#add edges to graph\nG3.add_edges_from(totalEdges)\n\n#Set the 2-d layout type \n#************************** ~5 minutes on my computer\npos_5 = nx.spring_layout(G3, dim = 2)","2d1d37f9":"#create the edges\nedge_trace5 = go.Scatter(\n    x=[],\n    y=[],\n    line=dict(width=.3,color='#888'),\n    hoverinfo='none',\n    mode='lines')\n\n#add edge postions to trace\nedge_trace5['x'] = tuple(itertools.chain(*pd.Series(G3.edges()).apply(lambda x: returnxPositions(x, pos_5))))\nedge_trace5['y'] = tuple(itertools.chain(*pd.Series(G3.edges()).apply(lambda x: returnyPositions(x, pos_5))))\n\n\n#create the nodes (with the color based on # of connections)\nnode_trace_5 = go.Scatter(\n    x=[],\n    y=[],\n    text=[],\n    mode='markers',\n    hoverinfo='text',\n    marker=dict(\n        showscale=True,\n        # colorscale options\n        #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |\n        #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |\n        #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |\n        colorscale='Blues',\n        reversescale=True,\n        color=[],\n        size=20,\n        colorbar=dict(\n            thickness=10,\n            title='Node Connections',\n            xanchor='right',\n            titleside='right'\n        ),\n        line=dict(width=2))    \n        )\n\ncharacterNodes = [x for x,y in G3.nodes(data=True)]\nfor node in characterNodes:\n    x, y = pos_5[node]\n    node_trace_5['x'] += tuple([x])\n    node_trace_5['y'] += tuple([y])\n\nfor node, adjacencies in G3.adjacency():\n        node_trace_5['marker']['color']+=tuple([len(adjacencies)])\n        node_info = ('Character: {character}<br>'+ '# of connections: {connections}<br>').format(\n                     character = str(node),\n                     connections = str(len(adjacencies)))\n        node_trace_5['text']+=tuple([node_info])\n\n\n#create the layout\nlayout=go.Layout(\n    title='<b>Marvel Sub-Networks: Hero Relationships',\n    titlefont=dict(size=16),\n    showlegend=False,\n    hovermode='closest',\n    margin=dict(b=20,l=5,r=5,t=40),\n    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n    annotations=[\n        dict(\n        showarrow=False,\n        xref='paper',\n        yref='paper',\n        x=0,\n        y=0.05,\n        xanchor='left',\n        yanchor='bottom',\n        font=dict(\n        size=14\n        ))]\n    )\n\n\n#combine\nfig5 = go.Figure(data=[edge_trace5, node_trace_5], layout = layout)","387e9b86":"#plot offline\n#plotly.offline.plot(fig5, filename = \"SuperHeroSubNetworks2D.html\")\niplot(fig5, filename='SuperHeroSubNetworks2D')","ee7f629a":"## Character to Comic Network Creation, Analysis, and Plots","3f3f2bf2":"average clustering -- this will be 0 because all neighbors of a node will not be connected due to the nature of this graph","47ff8f03":"#### Degree Analysis","7816e993":"Next, set the layouts for the 3-D and 2-D graphs","3f122bdc":"The following plot contains the partitioned networks.  One network is much less dense than the other.  This indicates some interesting realtionships between certain characters in the dense network.","99f2ded3":"### Create Network with Networkx\nCreate the network object and set the layouts","ba1a3b6d":"I was able to generate the entire graph in previous versions (view previous commits).  However, the network is too large to not lag in plotly and the notebook.   Therefore, the actual network will be created based on a subset that contains the nodes with the most connections.","9b4a2f07":"### Create List of Edges","efc1fbed":"### Network Analysis\nThe density of this network is much higher than the previous.","c3bf16b2":"This is too large to be efficiently computed with the spring_layout and kamada_kawai_layout functions. Remove nodes with low number of connections (and their edges).","df856abd":"### Create Attribute Values for Nodes\nThis code creates a list attribute values that distingish character nodes from comic nodes.","d842575f":"### Create Network with Networkx","e6d08db0":"### Create 2-D Partitioned Character to Character Network","ccf4108b":"Plot the degree frequencies of comic nodes and character nodes.  Characters have a much larger range of connections.  There is also a larger frequency of characters with lower degrees, compared to comics.","542730f5":"Finally, create the layout and plot.","80a3c5b8":"## Character to Character Network Creation, Analysis, and Plots","c6c8a0a3":"The following plots look at nodes with the greatest degree as well as the highest betweenness.  Both a measures that can be used to determine how *important* a particular node is for a network.","6ff588ed":"Next, compare the comic and character nodes with the highest degree.","1ba7f49e":"### Create the partioned Network\nPartition the network using the algorithm and create a new network object that contains both dijoint networks.  This code additonally creates the formatting for the network.","84c25f28":"### Process Data for Network\nThe data is formatted to show the relationship between comics and characters.  This code sorts through all of the edges to create a new network that removes the comics and shows the direct realtionships between characters.","89fb39fd":"### Import Data","9b36075e":"The clustering coeficient is relativly high, about 0.77.  This means nodes' neighbors are highly connected to one another.","03faa3e7":"### Plot 2-D Character to Comic Network\nCreation of the traces and layout follows a similar process. ","5edf4128":"Next, create the node traces for comics and characters.","6f48244e":"## Subgraphs of the Character to Character Network\nThe following analysis looks for possible clusters in the character network.  The Kernighan\u2013Lin algorithm algorithm is used to break the network into two points.  According the the function's [documention](https:\/\/networkx.github.io\/documentation\/stable\/reference\/algorithms\/generated\/networkx.algorithms.community.kernighan_lin.kernighan_lin_bisection.html#networkx.algorithms.community.kernighan_lin.kernighan_lin_bisection), the algorithm \"...paritions a network into two sets by iteratively swapping pairs of nodes to reduce the edge cut between the two sets.\"","8ad7e013":"### Plot 3-D Character to Comic Network\nFirst, create the edge trace.","c8f9d2f3":"### Plot 2-D Character to Character Network","dae3d131":"# Basic Marvel Network Analysis\nBy Jack Hart","070277a6":"### Group Comics by Issue\nThere are multiple issues for many comics.  To create a more interesting network, I'll group comics of the same issue together.","60e43e1d":"### Add Names to Edge List\nThe edge dataframe only has the ids for characters and comics.  ","8dfd7a51":"The following plot compares the average degree conectivity for nodes by their degree.  This is similar to the connectivity line plot made for the comic to character network.","d27d45a8":"### Create Network layout","b650a1ac":"## Initial Data Cleaning and Processing","e35473d4":"### Some Network Analysis\nFirst, look at the density of the graph.  The graph isn't very dense at all.  This makes sense, given character nodes can only be connected to comic nodes, and vice versa","3fcab60d":"### Plot 3-D Character to Character Network","e96bfc06":"### Import packages","d90f616f":"The average degree of connectivity is the average number of connections a particular nodes' neighbors have.  The following plot compares a given nodes degree, to the average degree of its neighbors.\n\nThere's a pretty significant difference in connectivity between nodes with a high degrees versus those with lower degrees.  Nodes with few connections tend to be connected to nodes with a high number of connections.  I'm assuming this can be explained by the principle behind the [friendship paradox](https:\/\/en.wikipedia.org\/wiki\/Friendship_paradox)."}}