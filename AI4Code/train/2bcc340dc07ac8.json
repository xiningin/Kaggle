{"cell_type":{"2371be3c":"code","5babc594":"code","14cea4ad":"code","ac7ed234":"code","dced04a6":"code","27a109af":"code","398f25e3":"code","d255765f":"code","6c11c282":"code","eb8323ed":"code","fd331230":"code","29e99102":"code","e7661923":"code","58a0ddc9":"code","ca52342c":"code","1eb8684c":"code","be167692":"code","1f6bf413":"code","56946254":"code","2583072e":"code","2f89404d":"code","2d2ed63c":"code","e17bbd3e":"code","7ae44c22":"code","66aac620":"code","4364b982":"code","4008cef1":"code","f3119bcb":"code","6c5a5493":"code","46f6985f":"code","18441618":"code","f070c682":"code","772a63b8":"code","3b0e8c5e":"code","ab0829ab":"markdown","ab8f36ef":"markdown","b7349ab5":"markdown","e0d6304a":"markdown","00dfa067":"markdown","a9951fb8":"markdown","73a4f6a1":"markdown"},"source":{"2371be3c":"# https:\/\/developers.google.com\/optimization\/introduction\/python\n# to do: \n# all or nothing flow - maximum one inflow and one outflow only (done)\n# prune variables for the model (so that it is not 100k variables but 4k variables)\n# add the const incurred on the difference between the largest and smallest cstcs\n# plotting - reduce clutter","5babc594":"%reset -sf\nimport numpy as np\nimport pandas as pd\nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom ortools.linear_solver import pywraplp\n!sha1sum ..\/input\/singapore-subzone-population\/processed_dataframe.pkl\n!pip freeze | grep ortools","14cea4ad":"df = pd.read_pickle(\"..\/input\/singapore-subzone-population\/processed_dataframe.pkl\")\n# df","ac7ed234":"for i,row in df.iterrows():\n    if len(row[\"adjacent\"]) != len(row[\"shared_param\"]): print(i)","dced04a6":"nodes = pd.DataFrame()\nnodes[\"supplies\"] = [max(2,z) for z in list(df[\"TOTAL\"])]\nnodes[\"x\"] = df[\"x_centre\"]\nnodes[\"y\"] = df[\"y_centre\"]\n\nstart_nodes = []\nend_nodes   = []\nunit_costs  = []\nfor i,row in df.iterrows():\n    for adj, cst in zip(row[\"adjacent\"], row[\"shared_param\"]):\n        start_nodes.append(i)\n        end_nodes.append(adj)\n        unit_costs.append(np.around(cst,10))\n\nedges = pd.DataFrame()\nedges[\"start_nodes\"] = start_nodes\nedges[\"end_nodes\"]   = end_nodes\nedges[\"unit_costs\"]  = unit_costs\nedges[\"capacities\"]  = [9999999]*len(start_nodes) # disabled\nedges[\"flows\"]       = [0]*len(start_nodes)\nedges[\"flowing\"]     = [0]*len(start_nodes)\nedges[\"names\"]       = \"x\"+edges[[\"start_nodes\",\n                                  \"end_nodes\"]].astype(str).apply('-'.join, axis=1)\nedges.index = edges[\"names\"]\nN = len(nodes) # the number of nodes at init","27a109af":"edges.sample(5)","398f25e3":"def augment_nodes(nodes, edges):\n    for i,ss in enumerate(nodes[\"supplies\"]):\n        edges.loc[len(edges)] = [i, N, 0, 9999999, 0, 0,\n                                 \"x\"+str(i)+\"-\"+str(N)]\n        edges.loc[len(edges)] = [N, i, 0, 9999999, 0, 0,\n                                 \"x\"+str(N)+\"-\"+str(i)]\n    nodes.loc[len(nodes)] = [-sum(nodes[\"supplies\"]), 103.7, 1.1]\n    edges.index = edges[\"names\"]\n    return nodes, edges","d255765f":"nodes, edges = augment_nodes(nodes, edges)\nassert sum(nodes[\"supplies\"]) == 0\n# nodes\n# edges","6c11c282":"def get_adjacency_matrix(edges):\n    start_nodes = edges[\"start_nodes\"]\n    end_nodes = edges[\"end_nodes\"]\n    unit_costs = edges[\"unit_costs\"]\n    capacities = edges[\"capacities\"]\n    flows = edges[\"flows\"]\n    flowing = edges[\"flowing\"]\n    names = edges[\"names\"]\n    \n    matrix_unit_costs = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    matrix_capacities = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    matrix_flows      = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    matrix_flowing    = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    matrix_names      = [[\"x\"+str(i)+\"-\"+str(j)\n                          for i in range(N+1)] \n                         for j in range(N+1)]\n    \n    for x,y,z,c,f,g in zip(start_nodes, end_nodes, unit_costs, capacities, flows, flowing):\n        matrix_unit_costs[x][y] = z\n        matrix_capacities[x][y] = c\n        matrix_flows     [x][y] = f\n        matrix_flowing   [x][y] = g\n        \n    for y,x,z,c,f,g in zip(start_nodes, end_nodes, unit_costs, capacities, flows, flowing):\n        matrix_unit_costs[x][y] = z\n        matrix_capacities[x][y] = c\n        matrix_flows     [x][y] = f\n        matrix_flowing   [x][y] = g\n\n    return matrix_unit_costs, matrix_capacities, matrix_flows, matrix_names, matrix_flowing\n\n(matrix_unit_costs, matrix_capacities, \n matrix_flows, matrix_names, matrix_flowing) = get_adjacency_matrix(edges)","eb8323ed":"# matrix_unit_costs, matrix_capacities, matrix_flows, matrix_names\nassert np.all(np.array(matrix_capacities)[:N,:N] == np.transpose(matrix_capacities)[:N,:N])\nassert np.all(np.array(matrix_unit_costs)[:N,:N] == np.transpose(matrix_unit_costs)[:N,:N])","fd331230":"edges.sample(5)","29e99102":"def plot_graph(nodes, edges):\n    start_nodes = edges[\"start_nodes\"]\n    end_nodes = edges[\"end_nodes\"]\n    unit_costs = edges[\"unit_costs\"]\n    capacities = edges[\"capacities\"]\n    flows = edges[\"flows\"]\n    names = edges[\"names\"]\n\n    G = nx.DiGraph()\n    for x,y,z,c,f,n in zip(start_nodes, end_nodes, unit_costs, capacities, flows, names):\n        G.add_edge(x, y, cost=z, capacity=c, flow=f, name=n)\n\n    labeldict = {}\n    for i,s in enumerate(nodes[\"supplies\"]):\n        labeldict[i] = int(s)\n\n    fig, ax = plt.subplots(figsize=(14,14))\n    \n    pos=nx.circular_layout(G)\n    pos={}\n    for i,node in nodes.iterrows():\n        pos[i] = [node[\"x\"], node[\"y\"]]\n    \n    for edge in G.edges(data=True):\n        w = edge[2]['flow']\n        if w > 0:\n            size = np.log(1+w)\n            nx.draw_networkx_edge_labels(G,pos, edgelist=[(edge[0],edge[1])], \n                                         edge_labels = {(edge[0],edge[1]): w})\n            nx.draw_networkx_edges(G, pos, edgelist=[(edge[0],edge[1])], \n                                   width=size, arrowsize=size*10)\n            \n    nx.draw_networkx_nodes(G, pos, with_labels=True, font_size=15, \n                           node_size=200, \n                           node_color=\"yellow\")\n    nx.draw_networkx_labels(G, pos, labels=labeldict)\n    \n    ax.autoscale()\n    ax.set_aspect(1)\n    ax.margins(0.1)\n    plt.show()","e7661923":"edges","58a0ddc9":"plt.show()\nplot_graph(nodes, edges)","ca52342c":"solver = pywraplp.Solver('hello_program',\n                         pywraplp.Solver.CBC_MIXED_INTEGER_PROGRAMMING)\n\n# define variables and capacities\ninfinity = solver.infinity()\nX = [[solver.NumVar(0.0, matrix_capacities[i][j], 'x'+str(i)+\"-\"+str(j)) \n      for j in range(N+1)]\n     for i in range(N+1)]\n\n# define supplies\nfor i in range(N+1):\n    solver.Add(sum([X[i][j] for j in range(N+1)])\n             - sum([X[j][i] for j in range(N+1)])\n            == nodes[\"supplies\"][i])","1eb8684c":"B = [[solver.IntVar(0.0, 1.0, 'b'+str(i)+\"-\"+str(j)) \n      for j in range(N+1)]\n     for i in range(N+1)]\nU = solver.IntVar(0.0, 9999999, 'U')\nL = solver.NumVar(0.0, 9999999, 'L')","be167692":"%%time\nNUM_CSTCS = 15\ncapacity_bound = int(sum(nodes[\"supplies\"][:-1]\/\/(NUM_CSTCS**0.5)))\nprint(\"capacity_bound\", capacity_bound)\nfor i in range(N):\n    for j in range(N+1):\n        if matrix_capacities[i][j] > 0:\n            solver.Add(X[i][j] <= B[i][j]*capacity_bound)\n    # solver.Add(X[i][N] >= B[i][N]*10)  # could not add lower bound :\/\n    solver.Add(sum([B[i][j] for j in range(N+1)]) <= 1)\n    solver.Add(U >= X[i][N])\n    solver.Add(L <= X[i][N] + (1-B[i][N])*19999999)","1f6bf413":"sum(nodes[\"supplies\"][:-1]\/\/(1.5*NUM_CSTCS)), capacity_bound","56946254":"# limit number of cstcs\nsolver.Add(sum(B[i][N] for i in range(N)) <= NUM_CSTCS)","2583072e":"# define objective\nsolver.Minimize(sum([sum([matrix_unit_costs[i][j] * X[i][j]\n                          for j in range(N+1)])\n                     for i in range(N+1)])\n#                 + sum([B[i][N] for i in range(N+1)])\n#                 + U \n#                 - 2*L\n)\nsolver.set_time_limit(15*1000)\n\nprint('Number of variables =', solver.NumVariables())\nprint('Number of constraints =', solver.NumConstraints())","2f89404d":"%%time\n# print(solver.ExportModelAsLpFormat(False).replace('\\\\', '').replace(',_', ','), sep='\\n')\nstatus = solver.Solve()","2d2ed63c":"if status == solver.NOT_SOLVED: print('Unsolved')\nif status == solver.FEASIBLE:   print('Stopped by time limit')\nif status == solver.OPTIMAL:    print('Optimal')\nif status == solver.INFEASIBLE: print('Infeasible')\nif status == solver.UNBOUNDED:  print('Unbounded')","e17bbd3e":"print('Solution:')\nprint('Objective value =', solver.Objective().Value())\nprint('')\nprint('Advanced usage:')\nprint('Problem solved in %f milliseconds' % solver.wall_time())\nprint('Problem solved in %d iterations'   % solver.iterations())\nprint('Problem solved in %d branch-and-bound nodes' % solver.nodes())\nprint('Number of cstcs %i' % sum(B[i][N].solution_value() for i in range(N+1)))\n# print('Bounds of cstcs', U.solution_value(), L.solution_value())","7ae44c22":"matrix_flows = [[x.solution_value() for x in xxx] for xxx in X]\nmatrix_flowing = [[b.solution_value() for b in bbb] for bbb in B]\nfor i,row in enumerate(matrix_flows):\n    for j,cell in enumerate(row):\n        if matrix_flows[i][j] > 0:\n            edges.at[\"x\"+str(i)+\"-\"+str(j),\"flows\"] = matrix_flows[i][j]\n            edges.at[\"x\"+str(i)+\"-\"+str(j),\"flowing\"] = matrix_flowing[i][j]\nedges.to_pickle(\"edges.pkl\")","66aac620":"plot_graph(nodes, edges)","4364b982":"edges.tail(10)","4008cef1":"edges.tail(318).head(10)","f3119bcb":"edges[edges[\"flows\"]>0]\\\n.sort_values(by=\"start_nodes\", ascending=False)\\\n.sort_values(by=\"end_nodes\", kind='mergesort')","6c5a5493":"arr = [sum([r > 0 for r in row]) for row in np.transpose(matrix_flows)][:-1]\nprint(sum(arr))\nplt.plot(arr)\nplt.show()","46f6985f":"arr = [sum(row) for row in np.transpose(matrix_flowing)][:-1]\nprint(sum(arr))\nplt.plot(arr)\nplt.show()","18441618":"arr = [sum([r > 0 for r in row]) for row in matrix_flows]\nprint(sum(arr))\nplt.plot(arr)\nplt.show()","f070c682":"arr = [sum(row) for row in matrix_flowing]\nprint(arr[-1])\nprint(sum(arr))\nplt.plot(arr)\nplt.show()","772a63b8":"from matplotlib.colors import LogNorm\nplt.figure(figsize=(10,10))\nplt.imshow(np.array(matrix_flows)+1,\n           norm=LogNorm(vmin=1, vmax=np.sqrt(1+np.max(matrix_flows))))\nplt.show()","3b0e8c5e":"from matplotlib.colors import LogNorm\nplt.figure(figsize=(10,10))\nplt.imshow(matrix_flowing)\nplt.show()","ab0829ab":"# Visualisation of results","ab8f36ef":"# Generate adjacency matrix","b7349ab5":"# Min-cost flow as a linear program","e0d6304a":"# Visualisation","00dfa067":"# Define problem","a9951fb8":"# Visualise output","73a4f6a1":"# Augment nodes to a common sink"}}