{"cell_type":{"ddb859da":"code","fe55beba":"code","f038e9e7":"code","5e80da6c":"code","b9598ed7":"code","ccd0ca57":"markdown","ac28b403":"markdown","4511376e":"markdown","c4f12ce0":"markdown","f6187287":"markdown"},"source":{"ddb859da":"import numpy as np\nimport pydicom\nimport cv2\nimport matplotlib.pyplot as plt\nfrom skimage.transform import resize","fe55beba":"# Grab a random DICOM file from the SIIM Covid-19 Detection set\nimg_file = \"..\/input\/siim-covid19-detection\/train\/00a76543ed93\/4a223cccbe04\/ad8d4a5ba8f0.dcm\"\nimg = pydicom.dcmread(img_file)","f038e9e7":"# Resize the pixels\nw = int(img.pixel_array.shape[0] * .25)\nh = int(img.pixel_array.shape[1] * .25)\nimg = resize(img.pixel_array, (w, h), anti_aliasing=True).astype(float)\n\n# scale the pixels\nimg = (np.maximum(img,0) \/ img.max()) * 255.0\nimg = np.uint8(img)","5e80da6c":"# Get the pixels in a list in binary format\nlst = []\nfor i in range(img.shape[0]):\n    for j in range(img.shape[1]):\n         lst.append(np.binary_repr(int(img[i][j]),width=8))\n            \n# grab the MSB at each level, ignoring the lower four for this demo\nbit_8 = (np.array([int(i[0]) for i in lst],dtype = np.uint8) * 128).reshape(img.shape[0],img.shape[1])\nbit_7 = (np.array([int(i[0]) for i in lst],dtype = np.uint8) * 64).reshape(img.shape[0],img.shape[1])\nbit_6 = (np.array([int(i[2]) for i in lst],dtype = np.uint8) * 32).reshape(img.shape[0],img.shape[1])\nbit_5 = (np.array([int(i[3]) for i in lst],dtype = np.uint8) * 16).reshape(img.shape[0],img.shape[1])","b9598ed7":"# Display the pixel planes\nfig, axes = plt.subplots(nrows=2, ncols=2,sharex=True, sharey=True, figsize=(12, 12))\nax = axes.ravel()\nax[0].imshow(bit_8, cmap='gray')\nax[1].imshow(bit_7, cmap='gray')\nax[2].imshow(bit_6, cmap='gray')\nax[3].imshow(bit_5, cmap='gray')\n\nplt.tight_layout()\nplt.show()","ccd0ca57":"**We'll do this manually for demo purposes. There are libraries for this. I'll explore them here in a later update ..**","ac28b403":"#### Here are some other processing notebooks I made:\n- Lung Segmentation Without CNN -> https:\/\/www.kaggle.com\/davidbroberts\/lung-segmentation-without-cnn\n- Applying filters to x-rays -> https:\/\/www.kaggle.com\/davidbroberts\/applying-filters-to-chest-x-rays\n- Rib supression on Chest X-Rays -> https:\/\/www.kaggle.com\/davidbroberts\/rib-suppression-poc\n- Manual DICOM VOI LUT -> https:\/\/www.kaggle.com\/davidbroberts\/manual-dicom-voi-lut\n- Apply Unsharp Mask to Chest X-Rays -> https:\/\/www.kaggle.com\/davidbroberts\/unsharp-masking-chest-x-rays\n- Cropping Chest X-Rays -> https:\/\/www.kaggle.com\/davidbroberts\/cropping-chest-x-rays\n- Bounding Boxes on Cropped Images -> https:\/\/www.kaggle.com\/davidbroberts\/bounding-boxes-on-cropped-images\n- DICOM full range pixels as CNN input -> https:\/\/www.kaggle.com\/davidbroberts\/dicom-full-range-pixels-as-cnn-input\n- Standardizing Chest X-Ray Dataset Exports -> https:\/\/www.kaggle.com\/davidbroberts\/standardizing-cxr-datasets","4511376e":"### Conclusion\n\n- Bit plane slices could be used as masks. When combined with thresholding and other filter techniques, they might prove useful. ","c4f12ce0":"<div class='alert alert-info' style='text-align: center'><h1>Visualizing Chest X-Ray Bit Planes<\/h1>\n    - yet another chest x-ray processing notebook -\n    <\/div>\n    \n### In this notebook, we'll use manual bit-plane slicing to extract pixel planes from CXR's.\n\n- The goal is to explore the possibility of getting segmentation masks or other useful diagnostic information.\n","f6187287":"#### Let's grab and image and slice it up!"}}