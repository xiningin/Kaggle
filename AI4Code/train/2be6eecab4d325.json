{"cell_type":{"fa3e9952":"code","d9378d3b":"code","03d33c65":"code","6eb0dbfb":"code","89da8769":"code","f1340bd5":"code","7535081b":"code","bfd91e45":"code","8f6a52ab":"code","e725c13b":"code","32a69d69":"code","f4a8acc8":"code","bca5e130":"code","1380899b":"code","550e2c8c":"code","a3347c51":"code","021ffbcb":"code","04b9b6ec":"code","cbd22714":"code","ad111d7d":"code","77a8bac3":"code","8f3094e0":"code","11b19dd7":"code","16038d9b":"code","c3c38d7d":"code","f382047f":"markdown","69f6ded7":"markdown","0f49d5d1":"markdown","db7bf4ad":"markdown","bc1944f6":"markdown","c5d94379":"markdown","51beb600":"markdown","ca9016e1":"markdown","b83e2091":"markdown","4991a58d":"markdown","9c445cb1":"markdown","4b854ae0":"markdown","93ac6326":"markdown","8a4e320c":"markdown","8d657280":"markdown","2a426c55":"markdown","25a61944":"markdown","6c772c15":"markdown","6a44ded0":"markdown","2f4d1126":"markdown","e3a0d60a":"markdown","5171fd2c":"markdown","82c09656":"markdown","f8a27e40":"markdown","9bb4892a":"markdown","6b25f3a4":"markdown"},"source":{"fa3e9952":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os # Processing\nimport time # Time handling\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\nfrom sklearn.feature_extraction.text import TfidfVectorizer # Word vectorizer\nos.system(\"cls\") # clear screen\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","d9378d3b":"print(\"STARTING DATA IMPORT AND PRE-PROCESSING\")\n\nmetadata = pd.read_csv('..\/input\/prod.csv', low_memory=False)# import data from database\nmetadata = metadata.apply(lambda x: x.str.lower() if x.dtype == \"object\" else x)  # convert to lower case to avoid discrepancies","03d33c65":"metadata.head()","6eb0dbfb":"metadata.columns.values","89da8769":"metadata = metadata[['prod_name','prod_cat','prod_cst','prod_weight','prod_features']] # extract feature\nmetadata.head() #view data","f1340bd5":"# handle inaccuracy\nmetadata = metadata.fillna('')\nprint(metadata['prod_features'].head()) #check feature range","7535081b":"# Call TFIDF \ntfidf = TfidfVectorizer(stop_words='english')\n#Fit data to tfidf\ntfidf_matrix = tfidf.fit_transform(metadata['prod_features'])\n#Check\nprint(tfidf_matrix.shape)\nprint(tfidf.get_feature_names())","bfd91e45":"from sklearn.metrics.pairwise import linear_kernel\n\n#Calculate cosine similarity matrix mat(A) * mat(A) = mat(a)^2\ncosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)\n\n#Check cosine matrix\nprint(cosine_sim.shape)\nprint(cosine_sim[1])","8f6a52ab":"indices = pd.Series(metadata.index, index=metadata['prod_name']).drop_duplicates()\n#time.sleep(5)\nprint(indices[:5]) #check","e725c13b":"def get_recommendations(name, cosine_sim):\n\n    #time.sleep(6)\n    indices = pd.Series(metadata.index, index=metadata['prod_name']).drop_duplicates()\n    idx = indices[name]\n\n    # Get the pairwsie similarity scores of all products with that product\n    sim_scores = list(enumerate(cosine_sim[idx]))\n\n    # Sort the products based on the similarity scores\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n\n    # Get the scores of the 5 most similar products\n    sim_scores = sim_scores[1:6]\n\n    # Get the product indices\n    prod_indices = [i[0] for i in sim_scores]\n\n    # Return the top 10 most similar product\n    return metadata['prod_name'].iloc[prod_indices]\n","32a69d69":"result = get_recommendations('apple', cosine_sim) #change product here\nresult #check","f4a8acc8":"from matplotlib import pyplot as plt\n#call matplotlib\nplt.plot(result,'b-') #plot results\nplt.plot(metadata['prod_name'], 'ro') #plot stock\nplt.title('Distribution')\nplt.ylabel(\"Product\")\nplt.xlabel(\"Cosine Similarity\")","bca5e130":"def clean_data(x):\n        return str.lower(str(x).replace(\" \", \"\")) #remove space\n\n#declare features to be cleaned\nfeatures = ['prod_cat','prod_cst','prod_weight','prod_features']\n\nfor feature in features:\n    metadata[feature] = metadata[feature].apply(clean_data) #apply clean method\n\nmetadata.head()\n","1380899b":"#Join all features with space as delimiter to create stringified description\ndef create_comb(x):\n    return ' '+ x['prod_cat'] + ' ' +x['prod_cst'] + ' ' + x['prod_weight'] + ' '+x['prod_features'].replace(\",\",\" \")\n\nmetadata['comb'] = metadata.apply(create_comb, axis=1) #apply combine factor\n    \nmetadata[['comb']].head(2) #check","550e2c8c":"# Import CountVectorizer and create the count matrix\nfrom sklearn.feature_extraction.text import CountVectorizer\n\ncount = CountVectorizer(stop_words='english')\n#fit stringified description\ncount_matrix = count.fit_transform(metadata['comb'])\n\ncount_matrix.shape\n","a3347c51":"from sklearn.metrics.pairwise import cosine_similarity\n\n#calculate mat(A) * mat(A) = mat(A)^2\ncosine_sim2 = cosine_similarity(count_matrix, count_matrix)","021ffbcb":"metadata = metadata.reset_index()\n#Map to product names\nindices = pd.Series(metadata.index, index=metadata['prod_name'])\nresult2 = get_recommendations('apple', cosine_sim2) #change product here\nresult2","04b9b6ec":"plt.plot(result2, 'y-')\nplt.plot(metadata['prod_name'], 'ro')\nplt.title('Distribution')\nplt.ylabel(\"Product\")\nplt.xlabel(\"Cosine Similarity\")","cbd22714":"plt.plot(cosine_sim2, 'ro')\nplt.plot(cosine_sim ,'b.')\nplt.title('Distribution MetaData vs Features')","ad111d7d":"coll_data = ['apple','lemon','potatoes','mangoes','kiwi']\nrecc_1 = get_recommendations(coll_data[0],cosine_sim2)\nrecc_2 = get_recommendations(coll_data[1],cosine_sim2)\nrecc_3 = get_recommendations(coll_data[2],cosine_sim2)\nrecc_4 = get_recommendations(coll_data[3],cosine_sim2)\nrecc_5 = get_recommendations(coll_data[4],cosine_sim2)\n    #print(recc_1[0])\nunion = list(set(recc_1) | set(recc_2) | set(recc_3) | set(recc_4) | set(recc_5))\nunion","77a8bac3":"print(\"CALCULATING SIMILARITIES IN SHOPPING PATTERN\")\nmy_dict = {}\nfor x in union:\n    my_dict[x] = 1\n\nfor x in union:\n    if x in set(recc_1):\n        my_dict[x] += 1\n    if x in set(recc_2):\n        my_dict[x] += 1\n    if x in set(recc_3):\n        my_dict[x] += 1\n    if x in set(recc_4):\n        my_dict[x] += 1\n    if x in set(recc_5):\n        my_dict[x] += 1","8f3094e0":"my_dict = {k: v for k, v in sorted(my_dict.items(), key=lambda item: item[1], reverse=True)}\nmy_dict","11b19dd7":"top_recc = list(my_dict.keys())\nfor x in range(5):\n    print(top_recc[x])","16038d9b":"listed = list(my_dict.items())\nlisted1 = listed[0:5]\nlisted2 = listed[5:10]\nx,y = zip(*listed1)\nx1,y1 = zip(*listed2)\nx2,y2 = zip(*listed)\nplt.plot(x,y,'r-')\nplt.title('Relative Demand Plot')\nplt.plot(x1,y1,'b-')\nplt.show()","c3c38d7d":"plt.plot(recc_1 , 'r.-')\nplt.plot(recc_2 , 'b--')\nplt.plot(recc_3 , 'g-')\nplt.plot(recc_4 , 'r-')\nplt.plot(recc_5 , 'b-')\nplt.plot(x2,y2 , 'y-')","f382047f":"Cleaning Metadata to be Vectorized","69f6ded7":"Map Feature Vectors to Product Names","0f49d5d1":"Using Metadata (Price, Weight, Description, Category) for Better Recommendation","db7bf4ad":"Extract Features","bc1944f6":"Sort Dictionary According to Values","c5d94379":"Combine all meta elements to form feature vector","51beb600":"Call Basic Recommendation based on features","ca9016e1":"View and Analyze Data","b83e2091":"Call Matrix Squaring Mat(A)*Mat(A) = Mat(A)^2","4991a58d":"Prepare Dictionary Data for Plotting","9c445cb1":"Collaborative Filtering Based on Past Purchases","4b854ae0":"Use updated cosine matrix to recommend based on metadata","93ac6326":"Plot results vs Stock","8a4e320c":"View Columns","8d657280":"Import Data","2a426c55":"Calculate Similarity Matrix","25a61944":"Plotting Collaborative Recommendations VS Metadata","6c772c15":"Plotting results","6a44ded0":"Ploting Distribution and Clustering Function","2f4d1126":"Extract Top 5 Recommendations","e3a0d60a":"Import Required Files","5171fd2c":"Vectorize Combination","82c09656":"Handle Features","f8a27e40":"Define Recommendation Method","9bb4892a":"Calculate Pattern By Frequency","6b25f3a4":"Call Vectorizer to Transform text"}}