{"cell_type":{"8376e82e":"code","127ed336":"code","30abef69":"code","cbb80547":"code","f8affc0d":"markdown"},"source":{"8376e82e":"from pathlib import Path\nimport pandas as pd\nfrom tqdm.auto import tqdm\nfrom scipy import ndimage\nimport numpy as np\nimport pickle\nfrom cytoolz import partition","127ed336":"data_dir = Path(\"\/kaggle\/input\/sartorius-cell-instance-segmentation\")\noutput_dir = Path(\"\/kaggle\/working\")","30abef69":"D=pd.read_csv(data_dir.joinpath(\"train.csv\"))\nD.head()","cbb80547":"def rle2mask(rle, width, height):\n    result = np.zeros(width * height, dtype=np.uint8)\n    for start, length in rle:\n        start -= 1\n        result[start : start + length] = 1\n    return result.reshape(height, width)\n\n\ndef row2mask(row):\n    return rle2mask(partition(2, map(int, row.annotation.split())), row.width, row.height)\n\n\nimg_masks = {}\nmask_dir=output_dir.joinpath(\"train_masks\")\nmask_dir.mkdir(exist_ok=True)\n\nfor id_, rows in tqdm(D.groupby(\"id\")):\n    masks = [ndimage.binary_fill_holes(row2mask(row)).astype(np.uint8) for row in rows.itertuples(False)]\n    full_mask = np.max(masks, axis=0)\n    with mask_dir.joinpath(f\"mask_{id_}.pkl\").open(\"wb\") as f:\n        pickle.dump(full_mask, f)","f8affc0d":"Creates binary masks for all images for semantic segmentation. Also fill faulty holes in masks."}}