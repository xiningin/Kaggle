{"cell_type":{"eaf45b74":"code","5c03727a":"code","167e96dc":"code","0b9884f1":"code","0d578539":"code","4c9d5c36":"code","c0a01734":"code","1f51d8c7":"code","58b50e44":"code","9b63ee1d":"code","75a57ac7":"code","548730c2":"code","50209bd8":"code","c128c619":"code","6c064224":"code","8ecdeb8a":"code","b1cfe57d":"code","f8ff3152":"code","9d997c19":"code","7709a16a":"code","c9ef9d63":"code","3d6bfaff":"code","d407548d":"code","22c16395":"code","106ffc99":"code","5d49ee30":"code","adbb3ab3":"code","902b130d":"code","ef1fd604":"code","a7dbc018":"code","d89a0e89":"code","78603a80":"code","82330686":"code","6aeda9ff":"code","8070b2bd":"code","d11072ae":"code","4d2c52b6":"code","a1b32550":"code","331dccd2":"code","7dc6f0d7":"code","1fb362ca":"code","70ee445c":"code","8fdc85f3":"code","0ea8b8cc":"code","b7c60aef":"code","ab24e2fd":"code","1b411a9b":"code","1a6f7df0":"markdown","a9f32a22":"markdown","1616cc5e":"markdown","3e0814af":"markdown","379824a1":"markdown","185d7f0a":"markdown","062b462f":"markdown","cf60d3b6":"markdown","fe710cdb":"markdown","a9311087":"markdown","b1145037":"markdown","229e4e38":"markdown","33f0172a":"markdown","1f346bbf":"markdown","2007b542":"markdown","d9661f5a":"markdown","60922057":"markdown"},"source":{"eaf45b74":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","5c03727a":"import matplotlib.pyplot as plt\nimport seaborn as sns","167e96dc":"data = pd.read_csv('..\/input\/paysim1\/PS_20174392719_1491204439457_log.csv')","0b9884f1":"data.head()","0d578539":"data.shape","4c9d5c36":"data.isnull().values.any()","c0a01734":"data.info()","1f51d8c7":"data.describe()","58b50e44":"data.isFraud.value_counts()","9b63ee1d":"fig,ax = plt.subplots()\nsns.countplot(x=data.isFraud,ax=ax)\nfor p in ax.patches:\n        val = p.get_height() #height of the bar\n        x = p.get_x() + p.get_width()\/2 # x- position \n        y = p.get_y() + p.get_height() #y-position\n        ax.annotate(val,(x,y))","75a57ac7":"fig,ax = plt.subplots(1,2,figsize=(10,3))\nsns.boxplot(x=data.isFraud,y=data.step,ax=ax[0])\nsns.scatterplot(x=data.isFraud,y=data.amount,ax=ax[1])","548730c2":"fig,ax = plt.subplots()\nsns.countplot(x=data.isFraud,hue=data.type,ax=ax)\nfor p in ax.patches:\n        val = p.get_height() \n        x = p.get_x() + p.get_width()  \n        y = p.get_y() + p.get_height() \n        ax.annotate(val,(x,y))","50209bd8":"print('Type of payments which are fraudulent are:',list(data.loc[(data.isFraud==1)].type.unique()))\nprint('No. of fraudulent transfers which are \"Transfer\" type are :', len(data.loc[(data.isFraud==1)&(data.type=='TRANSFER')]))\nprint('No. of fraudulent transfers which are \"CASH_OUT\" type are :', len(data.loc[(data.isFraud==1)&(data.type=='CASH_OUT')]))","c128c619":"data['nameOrig'].str.contains('M').any()","6c064224":"len(data.loc[data['nameDest'].str.contains('M') == True])","8ecdeb8a":"data.loc[data['type']=='TRANSFER'].nameDest.str.contains('M').any()","b1cfe57d":"data.loc[data['type']=='CASH_OUT'].nameDest.str.contains('M').any()","f8ff3152":"len(data.loc[(data['oldbalanceOrg']==0) & (data['newbalanceOrig']==0) & (data['amount']!=0)])","9d997c19":"print(len(data.loc[(data['oldbalanceOrg']==0) & (data['newbalanceOrig']==0) & (data['amount']!=0) & (data.isFraud==1)]))\nprint(len(data.loc[(data['oldbalanceOrg']==0) & (data['newbalanceOrig']==0) & (data['amount']!=0) & (data.isFraud==0)]))","7709a16a":"len(data.loc[(data['oldbalanceDest']==0) & (data['newbalanceDest']==0) & (data['amount']!=0)])","c9ef9d63":"print(len(data.loc[(data['oldbalanceDest']==0) & (data['newbalanceDest']==0) & (data['amount']!=0) & (data.isFraud==1)]))\nprint(len(data.loc[(data['oldbalanceDest']==0) & (data['newbalanceDest']==0) & (data['amount']!=0) & (data.isFraud==0)]))","3d6bfaff":"len(data.loc[(data['oldbalanceDest']==0) & (data['newbalanceDest']==0) & (data['amount']!=0) & (data.isFraud==0)& (data.nameDest.str.contains('M'))])","d407548d":"data['isFlaggedFraud'].value_counts()","22c16395":"data.loc[data['isFlaggedFraud']==1].amount.describe()","106ffc99":"data.loc[data['isFlaggedFraud']==0].amount.describe()","5d49ee30":"len(data.loc[(data['isFlaggedFraud']==1)& (data.isFraud==1)])","adbb3ab3":"data.drop(['nameOrig','nameDest','isFlaggedFraud'],axis=1,inplace=True)","902b130d":"df = data.loc[(data.type=='TRANSFER')|(data.type=='CASH_OUT')]","ef1fd604":"train = df.copy()","a7dbc018":"train.head()","d89a0e89":"train['errorOrig'] = train['amount'] + train['newbalanceOrig'] - train['oldbalanceOrg']\ntrain['errorDest'] = train['amount'] + train['oldbalanceDest'] - train['newbalanceDest']","78603a80":"train.head()","82330686":"from sklearn.preprocessing import LabelEncoder","6aeda9ff":"train['type'] = LabelEncoder().fit_transform(train['type'])","8070b2bd":"train.head()","d11072ae":"from sklearn.model_selection import train_test_split\nfrom sklearn.metrics import average_precision_score,accuracy_score,f1_score,classification_report,precision_recall_curve,confusion_matrix\nfrom sklearn.ensemble import RandomForestClassifier","4d2c52b6":"y = train['isFraud']\ntrain.drop('isFraud',axis=1,inplace=True)","a1b32550":"x_train,x_test,y_train,y_test = train_test_split(train,y,test_size=0.2)","331dccd2":"print(x_train.shape)\nprint(y_train.shape)\nprint(x_test.shape)\nprint(y_test.shape)","7dc6f0d7":"x_train.head()","1fb362ca":"random_forest = RandomForestClassifier()","70ee445c":"random_forest.fit(x_train,y_train)","8fdc85f3":"y_pred = random_forest.predict(x_train)","0ea8b8cc":"def model_result(clf,x_test,y_test):\n    y_prob=clf.predict_proba(x_test)\n    y_pred=clf.predict(x_test)\n    print('AUPRC :', (average_precision_score(y_test, y_prob[:, 1])))\n    print('F1 - score :',(f1_score(y_test,y_pred)))\n    print('Confusion_matrix : ')\n    print(confusion_matrix(y_test,y_pred))\n    print(\"accuracy_score\")\n    print(accuracy_score(y_test,y_pred))\n    print(\"classification_report\")\n    print(classification_report(y_test,y_pred))","b7c60aef":"model_result(random_forest,x_train,y_train)","ab24e2fd":"model_result(random_forest,x_test,y_test)","1b411a9b":"importances = pd.DataFrame({'feature':x_train.columns,'importance':np.round(random_forest.feature_importances_,3)})\nimportances = importances.sort_values('importance',ascending=False).set_index('feature')\nimportances","1a6f7df0":"According to our model newbalanceOrig, oldbalanceOrg are two of the most important features maybe because all fraudulent transactions involve wiping out complete amount which would make newbalanceOrig 0. To my surprise step is second least important feature, I thought it would be more important.","a9f32a22":"### Data Cleaning and Feature Engineering","1616cc5e":"## Modelling","3e0814af":"From the model evaluation (or confusion matrix), we know that\n\nAccuracy = (TP + TN) \/ Total                                               \nPresicion = TP \/ (TP + FP)                                                       \nRecall = TP \/ (TP + FN) \n\nAs such, specifically for this problem, we are interested in the recall score to capture the most fraudulent transactions. As we know, due to the imbalance of the data, many observations could be predicted as False Negatives, being, that we predict a normal transaction, but it is in fact a fraudulent one. Recall captures this.\n\nObviously, trying to increase recall, tends to come with a decrease of precision. However, in our case, if we predict that a transaction is fraudulent and turns out not to be, is not a massive problem compared to the opposite.\n\nDue to this, many evaluation will be based on recall score.","379824a1":"In description it is said 'isFlaggedFraud' will be 1 if amount of transaction is more than 200000, but the amount exceeds 200000 even when it is set to 0 as seen in above (where 75 percentile is more than 200000). Also whenever isFlaggedFraud is 1, value of isFraud is also 1. Therefore it doesn't so any correlation with other features and it can be dropped  ","185d7f0a":"As seen above step influences fraud detection. Therefore it might be a useful feature","062b462f":"Almost half of the transactions with 0 old and new balance of desinations are fraudulent.Therefore it is a strong indicator of fraud( Also there are no merchants in fraudulent transactions whose balance details are unknown, so this feature is strong indicator of fraud).\n\nAnd the genuine transactions where balance is 0 are mostly involved by merchants. Therefore it is better to only work with 'TRANSFER' and 'CASH_OUT' transactions as no merchants are involved and they also include all fraud transactions.","cf60d3b6":"nameOrig and nameDest can dropped as they dont impact fraud. Also there are no suspicious transfers to merchants. Therefore they can be dropped.","fe710cdb":"### Data Analysis","a9311087":"### conclusion\n\nWe explored the whole data using visualization techniques, added new features , removed unwanted features etc.\n\nWe also used random forest classifier because of skewness of the data, it is also robust to outliers.","b1145037":"All fraud transfers are under the type 'TRANSFER' and 'CASH-OUT'. ","229e4e38":"**Performance Metric selection**:\n\nSince the data is highly skewed, I am using the area under the precision-recall curve (AUPRC) rather than the conventional area under the receiver operating characteristic (AUROC). \n\nF1 score is the harmonic mean of the precision and recall. The highest possible value of F1 is 1, indicating perfect precision and recall, and the lowest possible value is 0, if either the precision or the recall is zero.\n\nWe should do more focus on FP & FN.","33f0172a":"As seen earlier, 0 values of oldbalanceOrg,newbalanceOrig,oldbalanceDest,newbalanceDest when amount is not 0 have a good chance of fraudulent transaction, we will create new freatures combining (oldbalanceOrg,newbalanceOrig,amount) and (oldbalanceDest,newbalanceDest,amount) ","1f346bbf":"Our default model performs good enough with recall score of 1.00 on both test and train data. By zooming in, only 5 prediction are False Negatives. ","2007b542":"**ML algorithm selection**:\n\n1. A first approach to deal with imbalanced data is to balance it by discarding the majority class before applying an ML algorithm. The disadvantage of undersampling is that a model trained in this way will not perform well on real-world skewed test data since almost all the information was discarded.\n\n2. I find, however, that the best result is obtained on the original dataset by using a ML algorithm based on ensembles of decision trees that intrinsically performs well on imbalanced data. Such algorithms not only allow for constructing a model that can cope with the missing values in our data, but they naturally allow for speedup via parallel-processing.","d9661f5a":"There are no null values.","60922057":"In future developments, the should be taking care of 'TRANSFER' and 'CASH-OUT' type of transactions as every fraud transaction is falls under these categories. The company sholud review the accounts whose balance becomes 0 after the transactions. "}}