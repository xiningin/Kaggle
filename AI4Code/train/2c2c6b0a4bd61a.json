{"cell_type":{"8635a64a":"code","12b55c52":"code","ddc8ef50":"code","38b0b98d":"code","648a6781":"code","cf957e72":"code","476d1f50":"code","c1a8f0e1":"code","bcf02031":"code","0e2b06d5":"code","0720e1a4":"code","377c171b":"code","c5d8500e":"code","39db3189":"code","8f7c695f":"code","b5b30ee6":"code","cf4368dc":"code","207c66e0":"code","e825a4d0":"markdown","222a6f46":"markdown","e39c4d96":"markdown","612c517a":"markdown","2b4fc087":"markdown","46b36a56":"markdown"},"source":{"8635a64a":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport json\nfrom pandas.io.json import json_normalize    \nimport os\n\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.metrics import cohen_kappa_score\nfrom sklearn.ensemble import RandomForestClassifier\n\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import accuracy_score\nimport matplotlib.pyplot as plt","12b55c52":"# Show the contents of the input directory\nprint(os.listdir(\"..\/input\"))","ddc8ef50":"train = pd.read_csv('..\/input\/train\/train.csv')\ntest = pd.read_csv('..\/input\/test\/test.csv')\n","38b0b98d":"# Define routines to read in the Training,Test sentiment score and magnitude;\n# 0,0 is returned if there is no file found.\n# Note that when used the argument fn will be one row of a dataframe\n# in shich case fn['PetID'] is the PetId.\n\ndef readFile(fn):\n    file = '..\/input\/train_sentiment\/'+fn['PetID']+'.json'\n    if os.path.exists(file):\n        with open(file) as data_file:    \n            data = json.load(data_file)  \n\n        df = json_normalize(data)\n        mag = df['documentSentiment.magnitude'].values[0]\n        score = df['documentSentiment.score'].values[0]\n        return pd.Series([mag,score],index=['mag','score']) \n    else:\n        return pd.Series([0,0],index=['mag','score'])\n    \ndef readTestFile(fn):\n    file = '..\/input\/test_sentiment\/'+fn['PetID']+'.json'\n    if os.path.exists(file):\n        with open(file) as data_file:    \n            data = json.load(data_file)  \n\n        df = json_normalize(data)\n        mag = df['documentSentiment.magnitude'].values[0]\n        score = df['documentSentiment.score'].values[0]\n        return pd.Series([mag,score],index=['mag','score']) \n    else:\n        return pd.Series([0,0],index=['mag','score'])","648a6781":"# Here the routines above are applied to each row of the dataframes.\n# This is done using panadas' `apply()` with a small \"anonymous function\" defined with a python `lambda`.\n# Note that just `train` could be used inplace of `train[['PetID']]`,\n# this would make it clearer that x is a row of the dataframe and not the PetID value.\n\ntrain[['SentMagnitude', 'SentScore']] = train[['PetID']].apply(lambda x: readFile(x), axis=1)\ntest[['SentMagnitude', 'SentScore']] = test[['PetID']].apply(lambda x: readTestFile(x), axis=1)\n","cf957e72":"# Setup the training X, y, and test X\ntrain_X = train.drop(['Name', 'Description', 'RescuerID', 'PetID', 'AdoptionSpeed'], axis=1)\ntrain_y = train['AdoptionSpeed']\ntest_X = test.drop(['Name', 'Description', 'RescuerID', 'PetID'], axis=1)\n","476d1f50":"# Define what will be the final predicted train and test values\ntrain_meta = np.zeros(train_y.shape)\ntest_meta = np.zeros(test_X.shape[0])\n\n# Choose and initialize a model.\nclf = RandomForestClassifier(bootstrap=True, criterion = 'gini', max_depth=80,\n                             max_features='auto', min_samples_leaf=5,\n                             min_samples_split=5, n_estimators=200)\n\n# Divide the training data into k-folds, k=4 here.\nsplits = list(StratifiedKFold(n_splits=4, shuffle=True, random_state=1812).split(train_X, train_y))\n\n# Loop over the folds and fit the model to the fold's training data.\n# Then evaluate that model on i) the validation data of that fold, \n# and ii) on all of the test data.\nfor idx, (train_idx, valid_idx) in enumerate(splits):\n        # The training and validation sets for this fold\n        X_train = train_X.iloc[train_idx]\n        y_train = train_y[train_idx]\n        X_val = train_X.iloc[valid_idx]\n        y_val = train_y[valid_idx]\n        \n        # Fit the model\n        clf.fit(X_train, y_train)\n        \n        # Look at the validation kappa and accuracy with classes right from the model\n        y_pred = clf.predict(X_val)\n        print(\"Fold {}: accuracy = {:.1f}%, kappa = {:.4f}  (no boundary adjustment)\".format(idx,\n                                100.0*accuracy_score(y_val, y_pred),     \n                                cohen_kappa_score(y_val, y_pred, weights='quadratic')))\n        #\n        # Assign real-valued classes in addition to the integer classes of y_pred.\n        # Start with the predicted probabilities by class\n        y_probs = clf.predict_proba(X_val)\n        # and get the class values (use a copy incase we change values)\n        class_vals = clf.classes_.copy()\n        # Change the ordinal weight of class 0 to be -1 as suggested by the plot in discussion:\n        # https:\/\/www.kaggle.com\/c\/petfinder-adoption-prediction\/discussion\/76265\n        # Does mot make much difference, though.\n        class_vals[0] = -1\n        # Create the float class values as the probability-weighted class\n        # Here a python \"list comprehension\" is used rather than a loop.\n        y_floats = [sum(y_probs[ix]*class_vals) for ix in range(len(y_probs[:,0]))]\n        #   \n        # Save these y_float values instead of the y_pred integers;\n        ##train_meta[valid_idx] = y_pred.reshape(-1)\n        train_meta[valid_idx] = y_floats\n        # the predictions for just this validation fold are saved in the train_meta array;\n        # looping over all folds will provide one prediction for each training sample.\n\n        # Now use this fold's same model to generate Test predictions.\n        ##y_test = clf.predict(test_X)\n        # Instead of integer classes, get the predicted probabilites\n        test_probs = clf.predict_proba(test_X)\n        # and turn these into float class values.\n        # Unlike the validation case, we get a test prediction from every fold,\n        # so those float predictions are averaged. python list comprehension is used again.\n        ##test_meta += y_test.reshape(-1) \/ len(splits)\n        test_meta += np.array([sum(test_probs[ix]*class_vals) for\n                               ix in range(len(test_probs[:,0]))]) \/ len(splits)","c1a8f0e1":"# Next two routines are a way to map float regression values to ordinal classes\n# by making use of the known distribution of the training classes.\n\n# In the following, y_pred is a floating value, e.g., the output of a regression to the class.\n# Many sklearn _classifiers_ can also provide probabilities of the classes which\n# can be turned into a floating value as the probability-weighted class, e.g.,:\n#       y_probs = clf.predict_proba(X_val)\n#       # The class values; use a copy incase we want to modify the values\n#       class_vals = clf.classes_.copy()\n#       y_floats = [sum(y_probs[ix]*class_vals) for ix in range(len(y_probs[:,0]))]\n\n\ndef get_class_bounds(y, y_pred, N=5, class0_fraction=-1):\n    \"\"\"\n    Find boundary values for y_pred to match the known y class percentiles.\n    Returns N-1 boundaries in y_pred values that separate y_pred\n    into N classes (0, 1, 2, ..., N-1) with same percentiles as y has.\n    Can adjust the fraction in Class 0 by the given factor (>=0), if desired. \n    \"\"\"\n    ysort = np.sort(y)\n    predsort = np.sort(y_pred)\n    bounds = []\n    for ibound in range(N-1):\n        iy = len(ysort[ysort <= ibound])\n        # adjust the number of class 0 predictions?\n        if (ibound == 0) and (class0_fraction >= 0.0) :\n            iy = int(class0_fraction * iy)\n        bounds.append(predsort[iy])\n    return bounds\n\ndef assign_class(y_pred, boundaries):\n    \"\"\"\n    Given class boundaries in y_pred units, output integer class values\n    \"\"\"\n    y_classes = np.zeros(len(y_pred))\n    for iclass, bound in enumerate(boundaries):\n        y_classes[y_pred >= bound] = iclass + 1\n    return y_classes.astype(int)","bcf02031":"# Look at the histogram of the predicted float class values.\nplt.hist(train_meta, bins=50)\nplt.title(\"Training: meta float values\")\nplt.xlabel(\"Training y float values\")\nplt.show()","0e2b06d5":"# This cell calculates and plots the kappa (and MSE) vs the class0 fraction adjustment.\n# Note that MSE prefers (lower MSE) a class0 fraction near\/at 0,\n# whereas kappa prefers (higher kappa) a fraction near 1.\n# Then the class0 fraction that gives best training kappa is selected.\n\n# Save values of kappa, MSE, and accuracy vs the class0 fraction\nkappas = []\nmses = []\naccurs = []\n# fractions to try... (could go larger than 1 if desired.)\ncl0fracs = np.array(np.arange(0.01,1.001,0.01))\nfor cl0frac in cl0fracs:\n    boundaries = get_class_bounds(train_y, train_meta, class0_fraction=cl0frac)\n    train_meta_ints = assign_class(train_meta, boundaries)\n    kappa = cohen_kappa_score(train['AdoptionSpeed'], train_meta_ints, weights='quadratic')\n    kappas.append(kappa)\n    mse = mean_squared_error(train['AdoptionSpeed'], train_meta_ints)\n    mses.append(mse)\n    accur = accuracy_score(train['AdoptionSpeed'], train_meta_ints)\n    accurs.append(accur)\n    \n# Use the class0 fraction that gives the highest training kappa\nifmax = np.array(kappas).argmax()\ncl0frac = cl0fracs[ifmax]\n\nprint(\"Best kappa for class0 fraction = {:.4f}\".format(cl0frac))","0720e1a4":"# Plots to show the kappa, MSE, and Accuracy vs class0 fraction\n\nplt.plot(cl0fracs, kappas)\n# indicate the highest-kappa point\nplt.plot([cl0frac],[kappas[ifmax]],marker=\"o\",color=\"green\")\nplt.title(\"Training: kappa vs class0_fraction\")\nplt.xlabel(\"class0_fraction\")\nplt.ylabel(\"kappa\")\nplt.show()\n\nplt.plot(cl0fracs, mses)\nplt.title(\"Training: MSE vs class0_fraction\")\nplt.xlabel(\"class0_fraction\")\nplt.ylabel(\"MSE\")\nplt.show()\n\nplt.plot(cl0fracs, accurs)\nplt.title(\"Training: Accuracy vs class0_fraction\")\nplt.xlabel(\"class0_fraction\")\nplt.ylabel(\"Accuracy\")\nplt.show()","377c171b":"# Can skip the class0_fraction adjustment and plotting cells above;\n# can delete those two cells and just uncomment this line:\n##cl0frac = 1.0\n\nprint(\"Using class0_fraction = {:.4f}, gives boundaries:\".format(cl0frac))\nboundaries = get_class_bounds(train_y, train_meta, class0_fraction=cl0frac)\nprint(boundaries)\n\ntrain_meta_ints = assign_class(train_meta, boundaries)\nkappa = cohen_kappa_score(train_y, train_meta_ints, weights='quadratic')\n\nprint(\"Adjusted boundaries give:\")\nprint(\"kappa = {:.4f}  (with accuracy = {:.1f}%)\".format(kappa,\n                                100.0*accuracy_score(train_y, train_meta_ints)))","c5d8500e":"# Confusion Matrix\ncon_mat = confusion_matrix(train_y, train_meta_ints)\n\n# Look at the number that are on the diagonal (exact agreement)\ndiag = 0.0\nfor id in range(5):\n    diag += con_mat[id,id]\nprint(\"\\nConfusion matrix - Columns are prediced 0, predicted 1, etc.\\n\")\nprint(con_mat)\nprint(\"\")\nprint(\"\\n{2:.2f}% = {0}\/{1} are on the diagonal (= accuracy)\".format(\n        int(diag), con_mat.sum(), 100.0*diag\/con_mat.sum()))","39db3189":"plt.hist(train_meta_ints, bins=40, color='blue')\nplt.hist(train_y, bins=20, bottom=0.0, alpha=0.2)\nplt.title(\"Train: Boundary-based Predictions\")\nplt.show()","8f7c695f":"plt.hist(test_meta, bins=50)\nplt.title(\"Test: meta float values\")\nplt.show()","b5b30ee6":"# Map the test values to integers using the training boundaries\ntest_meta_ints = assign_class(test_meta, boundaries)\nplt.hist(test_meta_ints.astype(int), bins=50)\nplt.title(\"Test: Boundary-based Predictions\")\nplt.show()","cf4368dc":"sub = pd.read_csv('..\/input\/test\/sample_submission.csv')\nsub['AdoptionSpeed'] = test_meta_ints\nsub['AdoptionSpeed'] = sub['AdoptionSpeed'].astype(int)\nsub.to_csv(\"submission.csv\", index=False)\n","207c66e0":"!head -5 submission.csv\n!echo ...\n!tail -5 submission.csv","e825a4d0":"This kernel uses Kseniia Palin's kernel [baseline random forest](https:\/\/www.kaggle.com\/beloruk1\/baseline-random-forest) to demonstrate a routine, `get_class_bounds()`, that maps real-valued ordinal classes to integer classes based on the known class-distribution of the target y values.\n\nComments have been added to Palin's code but otherwise the actual data preparation and model fitting are left as-is; the purpose of this kernel is to demonstrate `get_class_bounds()` rather than optimize the model. Note that Palin's implementation here generates Test predictions for each of the k-folds and averages those predictions; this is different from fitting the whole training set and using that model to generate a single Test prediction.\n\n`get_class_bounds()` is similar to the OptimizedRounder used in other kernels, but it runs more quickly and it may be less prone to overfitting. It could also be used in OptimizedRounder to set the initial boundary values, e.g., in place of `initial_coef = [0.5, 1.5, 2.5, 3.5]`.\n\n(v7) In the PetFinder data, class 0 seems unique\/harder-to-predict: added an option to adjust the fraction that are assigned to class 0; loop over this fraction and select its best value, this is essentially a crude one-bin OptimizedRounder ;-) <br>\n(v8) Added more comments to the code and also show plots of kappa, accuracy, and MSE vs the class0 fraction; these plots show, as expected, that kappa does not vary in the same way as accuracy or MSE.\n","222a6f46":"## Baseline Random Forest: demonstrating `get_class_bounds()`","e39c4d96":"## Read in the Data","612c517a":"### Adjusting the Class Boundaries","2b4fc087":"## Do Machine Learning","46b36a56":"## Generate and Output the Test Predictions"}}