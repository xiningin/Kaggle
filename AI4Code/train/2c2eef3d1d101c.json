{"cell_type":{"1de09c9e":"code","98fd05c5":"code","23b0385e":"code","84b5a34c":"code","26ad59ca":"code","bc840407":"code","e2eb83e2":"code","6813d21d":"code","36c95243":"code","a476f33b":"code","59c40131":"code","3b691824":"code","5ee422f7":"code","e1fd56f2":"code","20df3e72":"code","8d55c273":"code","7148679f":"code","318a115d":"code","598ba3d0":"code","c948705c":"code","528b9fa5":"code","10bdd0a8":"code","9ce64b1d":"code","dc20b0cb":"code","121503f9":"code","b7481cad":"code","6ffda491":"code","57f00151":"code","0201909f":"code","5776132c":"code","1305f95e":"code","69a21015":"code","604cdef2":"code","1f0b9034":"code","b84c093e":"code","e2e67818":"code","adb4f040":"code","bb4acbb6":"code","47c828fe":"code","526da783":"code","d0d8487d":"code","cf16c37b":"code","0fd37898":"code","0658b234":"code","c1a553b2":"code","436ba849":"code","e02071bf":"code","3ab97d4d":"code","76f23134":"code","8cb2312d":"code","b128eb43":"code","673f0283":"code","ed81fe0c":"code","0ce82593":"markdown","bc24381f":"markdown","04637e9c":"markdown","a799a411":"markdown","7b21de68":"markdown","10ff809a":"markdown","352ecacd":"markdown","9852c140":"markdown","126d1466":"markdown","6a0dd095":"markdown","fff2bde5":"markdown","fe525f71":"markdown","343c616d":"markdown","70388c2b":"markdown","111d1590":"markdown","5e7b2dd4":"markdown","f4177e80":"markdown"},"source":{"1de09c9e":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.\n\nimport matplotlib.pyplot as plt # graphs plotting\n%matplotlib inline\nfrom Bio import SeqIO # some BioPython that might come in handy\n\n","98fd05c5":"# Read the fasta-file and create a dictionary of its protein sequences\n\ninput_file_name = '..\/input\/spike-proteins-in-conona-viruses\/Aligned Spike Proteins (StrainName-AccessionNumber-HostSpecies-VirusSpecies).fasta'\n# input_file_name = '..\/input\/spike-proteins-in-conona-viruses\/upd1300.fasta'\n\n# The fasta defline (name of a sequence) has the following format:\n# Strain Name | Accession Number | Host Species | Virus Species) \nsequences_dictionary = {sequence.id : sequence.seq for sequence in SeqIO.parse(input_file_name,'fasta')}\n","23b0385e":"# From the newly formed sequences_dictionary, we create 3 lists:\n# a list of deflines,\n# a list of sequences,\n# and a list of target values\n\n# We want to mark all sequences that belong to the viruses that can infect humans as 1 (i.e., target = 1), \n# all other sequences as 0 (i.e., target = 0)\n\ndeflines = [entry for entry in sequences_dictionary.keys()]             # create a list of deflines\nprotein_sequences = [entry for entry in sequences_dictionary.values()]  # create a list of protein sequences \ntargets = [1 if 'Human' in entry else 0 for entry in deflines]          # create a list of target values","84b5a34c":"# Then we create a class fasta_sequence so that we would be able to use the sequence data easily \nclass fasta_sequence:\n    def __init__(self,defline,sequence,target):\n        \n        # we read the input data\n        \n        self.defline = defline\n        self.sequence = sequence\n        self.target = target\n        \n        # and create more descriptions of the input data\n        \n        # report the strain name (the 1st fiel of the defline)\n        self.strain_name = defline.split(\"|\")[0]\n        # report the accession number (the 2nd fiel of the defline)\n        self.accession_number = defline.split(\"|\")[1]        \n        # report the host species (the 3rd fiel of the defline)\n        self.host_species = defline.split(\"|\")[2]    \n        # report the virus species (the 4th fiel of the defline)\n        self.virus_species = defline.split(\"|\")[3]\n    \n    ","26ad59ca":"#create a list of sequences as objects of the class fasta_sequence\nsequences = []\nfor i in range(0, len(deflines)):\n    current_sequence = fasta_sequence(deflines[i],protein_sequences[i],targets[i])\n    sequences.append(current_sequence)","bc840407":"# Let's get the first look at out data\n\nprint(\"There are\", len(sequences), \"sequences in the fasta file\")\nprint(\"Each of the sequences has\", len(sequences[0].sequence), \"cites\")\n\nimport random\nrandom_id = random.randrange(0,len(sequences),1) # generates a random number within the range of sequence numbers\nprint(\"\\n\\nBelow you can see an example of a random sequence number\",random_id,\"\\n\")\nprint(\"The Defline:\\n\",sequences[random_id].defline)\nprint(\"\\nThe details of the Defline:\\nThe strain name: \", sequences[random_id].strain_name), \nprint(\"The accession number: \",sequences[random_id].accession_number)\nprint(\"The host species: \",sequences[random_id].host_species)\nprint(\"The virus species: \",sequences[random_id].virus_species)\nprint(\"\\nThe Sequence:\\n\",sequences[random_id].sequence)\nprint(\"\\nThe Target Value:\\n\",sequences[random_id].target)\n","e2eb83e2":"# Here we print the names of the sequences infective to humans among the first 100 sequence \nfor i in range(0,100):\n    if sequences[i].target == 1:\n        print(sequences[i].defline)","6813d21d":"# create a list of strain names (the 4th fiel of the defline)\nvirus_species = [entry.virus_species for entry in sequences]    \n# convert the list of strain names into a set \nvirus_species_set = set(virus_species)\n\nprint(\"There are\",len(virus_species_set)-1, \"unique virus species in our dataset\") # we don't count the NA entry\nprint(\"The list of all unique virus species in our dataset:\\n\", virus_species_set)\n","36c95243":"# create a list of strain names of the viruses that can affect humans\nhuman_virus_species = [entry.virus_species for entry in sequences if 'Human' in entry.defline]\n# turn this list into a set\nhuman_virus_species_set = set(human_virus_species)\n\nprint(\"There are\",len(human_virus_species_set)-1, \"unique virus human-infective species in our dataset\") # we don't count the NA entry\nprint(\"The list of all unique human-infective virus species in our dataset:\\n\", human_virus_species_set)","a476f33b":"idx = pd.Index(virus_species) # creates an index which allows counting the entries easily\nidx.value_counts()","59c40131":"# here we prepare the data to be plootted as a bar graph\ny_labels = idx.value_counts().index.values # virus species names\ncounts = idx.value_counts().values    # numbers of occuriencies\ncounts_as_series = pd.Series(counts)","3b691824":"# plot the bar graph\n\nplt.figure(figsize=(12, 9))\nax = counts_as_series.plot(kind ='barh')\nax.set_title('The data distribution')\nax.set_xlabel('Number of entries')\nax.set_ylabel('Species of virus')\nax.set_yticklabels(y_labels)\nax.set_xlim(-10, 295) # we change the x limits in order to make labels more readable\n\nrectangles = ax.patches\n\n# we place a label for each bar\nfor rectangle in rectangles:\n    \n    # we obtain x and y positions for the current label\n    x_value = rectangle.get_width()\n    y_value = rectangle.get_y() + rectangle.get_height()\/2\n    \n    # we annotate a current bar in the bar graph\n    plt.annotate(\n        x_value,                    # we use x_value as a label\n        (x_value, y_value),         # we place labels at end of the bars\n        xytext=(5, 0),              # we shift the label horizontally by 5\n        textcoords=\"offset points\", # we interpret xytext as an offset in points\n        va='center',                # we center the labels vertically \n        ha='left')                  # we specify the alignment for the labels                                   ","5ee422f7":"# How many viral sequences are marked as infective to humans?\n# To answer it, we can simply count 1's in the target list:\n\nprint(\"We have got\", targets.count(1), \"entries that can infect humans\") \n","e1fd56f2":"human_related_sequences = [entry for entry in sequences if 'Human' in entry.defline]  # create a list of human related sequences","20df3e72":"# We convert a string with the alphabet = 'ABCDEFGHIKLMNPQRSTUVWXYZ-' \n# !!!(B,X,Z are ``extra'' letters; we have to address this in the future) \n# into either a list mapping chars to integers (called integer encoding),\n# or a sparce list. In the latter, each amino acid is represented as an one-hot vector of length 20, \n# where each position, except one, is set to 0.  E.g., alanine is encoded as 10000000000000000000, cystine is encoded as 01000000000000000000\n# See the full table above.\n# Symbol '-' is encoded as a zero-vector.\n\ndef encoding(sequence, type_of_encoding = \"onehot\"):\n\n    # define universe of possible input values\n    alphabet = 'ABCDEFGHIJKLMNPQRSTUVWXYZ-'\n    # define a mapping of chars to integers\n    char_to_int = dict((c, i) for i, c in enumerate(alphabet))\n\n    \n    # integer encoding\n    integer_encoded = [char_to_int[char] for char in sequence]\n\n    # one-hot encoding\n    onehot_encoded = list()\n    for value in integer_encoded:\n        letter = [0 for _ in range(len(alphabet)-1)]\n        if value != len(alphabet)-1:\n            letter[value] = 1\n        onehot_encoded.append(letter)\n    flat_list = [item for sublist in onehot_encoded for item in sublist]\n\n    if type_of_encoding == \"onehot\":\n        return flat_list\n    else:\n        return integer_encoded\n    ","8d55c273":"# Encode sequences with a one-hot encoding\nencoded_sequences = []\nfor entry in sequences:\n    encoded_sequences.append(encoding(entry.sequence))","7148679f":"encoded_human_sequences = []\nhuman_targets = []\nfor entry in human_related_sequences:\n    encoded_human_sequences.append(encoding(entry.sequence))\n    human_targets.append(entry.virus_species)","318a115d":"# We prepare to mute Human_coronavirus_HKU1\nsequences_without_HKU1 = [entry for entry in sequences if 'Human_coronavirus_HKU1' not in entry.defline] \nsequences_HKU1 = [entry for entry in sequences if 'Human_coronavirus_HKU1' in entry.defline] \n\nprint(len(sequences_without_HKU1))\nprint(len(sequences_HKU1))","598ba3d0":"# Encode sequences without HKU1 with a one-hot encoding\nencoded_without_HKU1 = []\nencoded_HKU1 = []\n\nfor entry in sequences_without_HKU1:\n    encoded_without_HKU1.append(encoding(entry.sequence))\n\nfor entry in sequences_HKU1:\n    encoded_HKU1.append(encoding(entry.sequence))","c948705c":"# take care of targets while muting HKU1\ntargets_without_HKU1 = []\nfor entry in sequences_without_HKU1:\n    targets_without_HKU1.append(entry.target)\n    \ntargets_HKU1 = []\nfor entry in sequences_HKU1:\n    targets_HKU1.append(entry.target)\n    \nprint(targets_HKU1.count(1))","528b9fa5":"# We prepare to mute Severe_acute_respiratory_syndrome_related_coronavirus\nsequences_without_SARS1 = [entry for entry in sequences if 'Severe_acute_respiratory_syndrome_related_coronavirus' not in entry.defline] \nsequences_SARS1 = [entry for entry in sequences if 'Severe_acute_respiratory_syndrome_related_coronavirus' in entry.defline] \n\nprint(len(sequences_without_SARS1))\nprint(len(sequences_SARS1))","10bdd0a8":"for item in sequences_SARS1:\n    print(item.defline)","9ce64b1d":"# Encode sequences without SARS1 with a one-hot encoding\nencoded_without_SARS1 = []\nencoded_SARS1 = []\n\nfor entry in sequences_without_SARS1:\n    encoded_without_SARS1.append(encoding(entry.sequence))\n\nfor entry in sequences_SARS1:\n    encoded_SARS1.append(encoding(entry.sequence))","dc20b0cb":"# take care of targets while muting SARS1\ntargets_without_SARS1 = []\nfor entry in sequences_without_SARS1:\n    targets_without_SARS1.append(entry.target)\n    \ntargets_SARS1 = []\nfor entry in sequences_SARS1:\n    targets_SARS1.append(entry.target)\n    \nprint(targets_SARS1.count(1))","121503f9":"# Visualize all the sequences (encoded) as feature vectors with help of TSNE\nfrom sklearn.manifold import TSNE\nimport seaborn as sns\n\nX_embedded = TSNE(n_components=2).fit_transform(encoded_sequences)","b7481cad":"palette = sns.color_palette(\"bright\", 2)\nsns.scatterplot(X_embedded[:,0], X_embedded[:,1], hue=targets, legend='full', palette = palette)","6ffda491":"# we use TSNE to embed sequences that are infective for humans\nfrom sklearn.manifold import TSNE\nimport seaborn as sns\nX_embedded_human = TSNE(n_components=2).fit_transform(encoded_human_sequences)","57f00151":"data_frame = pd.DataFrame({'1st coordinate of the embedded vector': X_embedded_human[:,0], \n                           '2nd coordinate of the embedded vector': X_embedded_human[:,1], \n                           'Types of virus': human_targets})\nsns.relplot(x = '1st coordinate of the embedded vector', \n            y = '2nd coordinate of the embedded vector', \n            hue = 'Types of virus', \n            data = data_frame, \n            legend = \"full\",\n            style = 'Types of virus')\nplt.show()\n","0201909f":"multi_targets = []\n\nfor i in range(len(deflines)):\n    if 'human' in deflines[i].lower():\n        multi_targets.append('Human')\n    elif 'bat' in deflines[i].lower():\n        multi_targets.append('Bat')\n    elif 'avian' in deflines[i].lower():\n        multi_targets.append('Bird')\n    elif 'camel' in deflines[i].lower():\n        multi_targets.append('Camel')\n    else:\n        multi_targets.append('Other')\n        \ncoro_types = []\nfor i in range(len(deflines)):\n    vtl = deflines[i].lower()\n    if 'alpha' in vtl:\n        coro_types.append(\"Alpha\")\n    elif 'hku10' in vtl:\n        coro_types.append(\"Alpha\")\n    # do these before hku1 and hku2 so it counts it right\n    elif 'hku12' in vtl:\n        coro_types.append(\"Delta\")\n    elif 'hku13' in vtl:\n        coro_types.append(\"Delta\")\n    elif 'hku14' in vtl:\n        coro_types.append(\"Beta\")\n    elif 'hku16' in vtl:\n        coro_types.append(\"Delta\")\n    elif 'hku17' in vtl:\n        coro_types.append(\"Delta\")\n    elif 'hku18' in vtl:\n        coro_types.append(\"Delta\")\n    elif 'hku19' in vtl:\n        coro_types.append(\"Delta\")\n    elif 'hku20' in vtl:\n        coro_types.append(\"Delta\")\n    elif 'hku21' in vtl:\n        coro_types.append(\"Delta\")\n\n    elif 'nl63' in vtl:\n        coro_types.append(\"Alpha\")\n    elif 'hku2' in vtl:\n        coro_types.append(\"Alpha\")\n    elif 'hku11' in vtl:\n        coro_types.append(\"Delta\")\n    elif 'beta' in vtl:\n        coro_types.append(\"Beta\")\n    elif 'cattle' in vtl:\n        coro_types.append(\"Beta\")\n    elif 'mouse' in vtl:\n        coro_types.append(\"Beta\")\n    elif 'hku1' in vtl:\n        coro_types.append(\"Beta\")\n    elif 'hku4' in vtl:\n        coro_types.append(\"Beta\")\n    elif 'hku5' in vtl:\n        coro_types.append(\"Beta\")\n    elif 'hku9' in vtl:\n        coro_types.append(\"Beta\")\n    elif 'severe_acute_respiratory_syndrome' in vtl:\n        coro_types.append(\"Beta\")\n    elif 'SARS' in vtl:\n        coro_types.append(\"Beta\")\n    elif 'middle_east_respiratory_syndrome' in vtl:\n        coro_types.append(\"Beta\")\n    elif 'chicken' in vtl:\n        coro_types.append(\"Gamma\")\n    elif 'pheasant' in vtl:\n        coro_types.append(\"Gamma\")\n    elif 'pigeon' in vtl:\n        coro_types.append(\"Gamma\")\n    elif 'beluga' in vtl:\n        coro_types.append(\"Gamma\")\n    elif 'tcov' in vtl:\n        coro_types.append(\"Gamma\")\n    elif 'porcine' in vtl:\n        coro_types.append(\"Delta\")\n    else:\n        coro_types.append(\"N\/A\")","5776132c":"data_frame = pd.DataFrame({'1st coordinate of the embedded vector': X_embedded[:,0], \n                           '2nd coordinate of the embedded vector': X_embedded[:,1], \n                           'Types of virus': multi_targets})\nsns.relplot(x = '1st coordinate of the embedded vector', \n            y = '2nd coordinate of the embedded vector', \n            hue = 'Types of virus', \n            data = data_frame, \n            legend = \"full\",\n            style = 'Types of virus')\nplt.show()","1305f95e":"data_frame_coro_types = pd.DataFrame({'1st coordinate of the embedded vector': X_embedded[:,0], \n                           '2nd coordinate of the embedded vector': X_embedded[:,1], \n                           'Types of virus': coro_types})\nsns.relplot(x = '1st coordinate of the embedded vector', \n            y = '2nd coordinate of the embedded vector', \n            hue = 'Types of virus', \n            data = data_frame_coro_types, \n            legend = \"full\",\n            style = 'Types of virus')\nplt.show()","69a21015":"import matplotlib.pyplot as plt\n\nlabels = ['Human', 'Bat','Camel', 'Other', 'Bird']\noverall_size = len(multi_targets)\nsizes = [multi_targets.count('Human') \/ overall_size, \\\n         multi_targets.count('Bat') \/ overall_size, \\\n         multi_targets.count('Camel') \/ overall_size, \\\n         multi_targets.count('Other') \/ overall_size, \\\n         multi_targets.count('Bird') \/ overall_size]\n\nexplode = (0.1, 0, 0, 0, 0)\n\nfig1, ax1 = plt.subplots()\nax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',\n        shadow=True, startangle=90)\n\n# Equal aspect ratio ensures that pie is drawn as a circle\nax1.axis('equal')  \nplt.tight_layout()\nplt.show()","604cdef2":"ct_labels = ['Alpha', 'Beta', 'Gamma', 'Delta', 'N\/A']\nct_overall_size = len(coro_types)\nct_sizes = [coro_types.count('Alpha') \/ ct_overall_size, \\\n            coro_types.count('Beta') \/ ct_overall_size, \\\n            coro_types.count('Gamma') \/ct_overall_size, \\\n            coro_types.count('Delta') \/ ct_overall_size, \\\n            coro_types.count('N\/A') \/ ct_overall_size]\n\nct_explode = (0, 0, 0, 0, 0)\n\nct_fig1, ct_ax1 = plt.subplots()\nct_ax1.pie(ct_sizes, explode=ct_explode, labels=ct_labels, autopct='%1.1f%%',\n        shadow=True, startangle=90)\n\n# Equal aspect ratio ensures that pie is drawn as a circle\nct_ax1.axis('equal')  \nplt.tight_layout()\nplt.show()","1f0b9034":"# Calculate statictical parameters for the performance of a classifier\nfrom sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score, classification_report\n\ndef scores(y_test, y_predicted):  \n    precision = precision_score(y_test, y_predicted, pos_label = None,\n                                    average = 'weighted')             \n    recall = recall_score(y_test, y_predicted, pos_label = None, average = 'weighted')\n    f1 = f1_score(y_test, y_predicted, pos_label=None, average='weighted')\n    accuracy = accuracy_score(y_test, y_predicted)\n    print(\"accuracy = %.4f, f1 = %.4f, precision = %.4f, recall = %.4f\" % (accuracy, f1, precision, recall))\n    return accuracy, f1, precision, recall","b84c093e":"# Plot a confusion matrix\nimport itertools\nfrom sklearn.metrics import confusion_matrix\n\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion Matrix',\n                          cmap=plt.cm.spring):\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title, fontsize=26)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, fontsize=20)\n    plt.yticks(tick_marks, classes, fontsize=20)\n    \n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j], fmt), horizontalalignment=\"center\", \n                 color=\"white\" if cm[i, j] < thresh else \"black\", fontsize=40)\n    \n    plt.tight_layout()\n    plt.ylabel('True labels', fontsize=24)\n    plt.xlabel('Predicted labels', fontsize=24)\n\n    return plt","e2e67818":"# Use the default SVM-classifier\n\n# Split the dataset into a training set (80%) and a test set (20%)\nfrom sklearn.model_selection import train_test_split\nxTrain, xTest, yTrain, yTest = train_test_split(encoded_sequences, targets, test_size = 0.2, random_state = 42)\n\nfrom sklearn.svm import SVC\nclassifier_SVM = SVC(probability = True)\nclassifier_SVM.fit(xTrain, yTrain)\ny_predicted_SVM_default = classifier_SVM.predict(xTest)\n\n#report accuracy, f1, precision, recall for SVM\naccuracy, f1, precision, recall = scores(yTest, y_predicted_SVM_default)","adb4f040":"# The confusion matrix for the test data for SVM\ncm = confusion_matrix(yTest, y_predicted_SVM_default)\nfig = plt.figure(figsize=(8, 8))\nplot = plot_confusion_matrix(cm, classes=['Not Infective','Infective'], normalize=False, title='Confusion matrix\\n for SVM')\nplt.show()","bb4acbb6":"# SVM-classifier for muted HKU_1\n\nxTrain_without_HKU1, xTest_without_HKU1, yTrain_without_HKU1, yTest_without_HKU1 = train_test_split(encoded_without_HKU1, \n                                                                                                    targets_without_HKU1, \n                                                                                                    test_size = 0.2, \n                                                                                                    random_state = 42)\nx_Test_HKU1 = xTest_without_HKU1 + encoded_HKU1\ny_Test_HKU1 = yTest_without_HKU1 + targets_HKU1\n\nfrom sklearn.svm import SVC\nclassifier_SVM = SVC(probability = True)\nclassifier_SVM.fit(xTrain_without_HKU1,yTrain_without_HKU1)\ny_predicted_SVM_HKU1 = classifier_SVM.predict(x_Test_HKU1)\n\n#report accuracy, f1, precision, recall for SVM\naccuracy, f1, precision, recall = scores(y_Test_HKU1, y_predicted_SVM_HKU1)\n","47c828fe":"# SVM-classifier for TOTALLY muted HKU_1\nxTrain_without_HKU1_total = encoded_without_HKU1\nyTrain_without_HKU1_total = targets_without_HKU1\nx_Test_HKU1_total = encoded_HKU1\ny_Test_HKU1_total = targets_HKU1\n\nfrom sklearn.svm import SVC\nclassifier_SVM = SVC(probability = True)\nclassifier_SVM.fit(xTrain_without_HKU1_total,yTrain_without_HKU1_total)\ny_predicted_SVM_HKU1_total = classifier_SVM.predict(x_Test_HKU1_total)\n\n#report accuracy, f1, precision, recall for SVM\naccuracy, f1, precision, recall = scores(y_Test_HKU1_total, y_predicted_SVM_HKU1_total)","526da783":"# SVM-classifier for muted SARS_1\n\n\nxTrain_without_SARS1, xTest_without_SARS1, yTrain_without_SARS1, yTest_without_SARS1 = train_test_split(encoded_without_SARS1, \n                                                                                                        targets_without_SARS1, \n                                                                                                        test_size = 0.2,\n                                                                                                        random_state = 42)\n\nx_Test_SARS1 = xTest_without_SARS1 + encoded_SARS1\ny_Test_SARS1 = yTest_without_SARS1 + targets_SARS1  \nfrom sklearn.svm import SVC\nclassifier_SVM = SVC(probability = True)\nclassifier_SVM.fit(xTrain_without_SARS1,yTrain_without_SARS1)\ny_predicted_SVM_SARS1 = classifier_SVM.predict(x_Test_SARS1)\n\n#report accuracy, f1, precision, recall for SVM\naccuracy, f1, precision, recall = scores(y_Test_SARS1, y_predicted_SVM_SARS1)","d0d8487d":"# SVM-classifier for TOTALLY muted SARS1\nxTrain_without_SARS1_total = encoded_without_SARS1\nyTrain_without_SARS1_total = targets_without_SARS1\nx_Test_SARS1_total = encoded_SARS1\ny_Test_SARS1_total = targets_SARS1\n\nfrom sklearn.svm import SVC\nclassifier_SVM = SVC(probability = True)\nclassifier_SVM.fit(xTrain_without_SARS1_total,yTrain_without_SARS1_total)\ny_predicted_SVM_SARS1_total = classifier_SVM.predict(x_Test_SARS1_total)\n\n#report accuracy, f1, precision, recall for SVM\naccuracy, f1, precision, recall = scores(y_Test_SARS1_total, y_predicted_SVM_SARS1_total)","cf16c37b":"Avian_dataset = [entry for entry in sequences if 'Avian' in entry.defline]\n\nHuman_Avian_dataset = human_related_sequences + random.choices(Avian_dataset, k = targets.count(1))\n\n\naviantargets = [0 for entry in range(0,targets.count(1))]\nhumandtargets =[1 for entry in range(0,targets.count(1))]\nbalancedtargets = humandtargets + aviantargets\n\n\n#encoding balanced sequences with one-hot encoding\n\nbalanced_encoded_sequences =[]\n\nfor entry in Human_Avian_dataset:\n    balanced_encoded_sequences.append(encoding(entry.sequence))","0fd37898":"# SVM-classifier for Balanced Data set\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.svm import SVC\nxTrain_Balanced, xTest_Balanced, yTrain_Balanced, yTest_Balanced = train_test_split(balanced_encoded_sequences, \n                                                                                                    balancedtargets, \n                                                                                                    test_size = 0.2, \n                                                                                                    random_state = 42)\n\nclassifier_SVM_Balanced = SVC(probability = True)\nclassifier_SVM_Balanced.fit(xTrain_Balanced, yTrain_Balanced)\ny_predicted_SVM_Balanced = classifier_SVM_Balanced.predict(xTest_Balanced)\n\n#report accuracy, f1, precision, recall for SVM\naccuracy, f1, precision, recall = scores(yTest_Balanced, y_predicted_SVM_Balanced)","0658b234":"#determining unique viral hosts\nhost_species = [entry.host_species for entry in sequences]    \nhost_species_set = set(host_species)\n\nprint(\"There are\",len(host_species_set)-1, \"unique viral hosts in our dataset\") # we don't count the NA entry\nprint(\"The list of unique viral hosts in our dataset is: \\n\", host_species_set)","c1a553b2":"#Manual observation of unique viral hosts show 25 hosts with following names which are mammals: Chimpanzee, Anteater, Rat, Mink, Hedgehog, Alpaca, Human, Dolphin, Pig, Buffalo, Sus_scrofa_domesticus\n#Mus_Musculus__Severe_Combined_Immunedeficiency__Scid___Female__6_8_Weeks_Old__Liver__Sample_Id:_E4m31, Dog, Mouse, bat_BF_506I, Rabbit, Camel, Goat, Cattle, Horse, Cat, Bat, bat_BF_258I, Swine, Ferret        \n\n\n#manually adding each host's viral sequence to a single dataset\nmammal_dataset1 = [entry for entry in sequences if 'Chimpanzee' in entry.defline]\nmammal_dataset2 = [entry for entry in sequences if 'Anteater' in entry.defline]\nmammal_dataset3 = [entry for entry in sequences if 'Rat' in entry.defline]\nmammal_dataset4 = [entry for entry in sequences if 'Mink' in entry.defline]\nmammal_dataset5 = [entry for entry in sequences if 'Hedgehog' in entry.defline]\nmammal_dataset6 = [entry for entry in sequences if 'Alpaca' in entry.defline]\nmammal_dataset7 = [entry for entry in sequences if 'Ferret' in entry.defline]\nmammal_dataset8 = [entry for entry in sequences if 'Dolphin' in entry.defline]\nmammal_dataset9 = [entry for entry in sequences if 'Pig' in entry.defline]\nmammal_dataset10 = [entry for entry in sequences if 'Buffalo' in entry.defline]\nmammal_dataset11 = [entry for entry in sequences if 'Sus_scrofa_domesticus' in entry.defline]\nmammal_dataset12 = [entry for entry in sequences if 'Mus_Musculus__Severe_Combined_Immunedeficiency__Scid___Female__6_8_Weeks_Old__Liver__Sample_Id:_E4m31' in entry.defline]\nmammal_dataset13 = [entry for entry in sequences if 'Dog' in entry.defline]\nmammal_dataset14 = [entry for entry in sequences if 'Mouse' in entry.defline]\nmammal_dataset15 = [entry for entry in sequences if 'bat_BF_506I' in entry.defline]\nmammal_dataset16 = [entry for entry in sequences if 'Rabbit' in entry.defline]\nmammal_dataset17 = [entry for entry in sequences if 'Camel' in entry.defline]\nmammal_dataset18 = [entry for entry in sequences if 'Goat' in entry.defline]\nmammal_dataset19 = [entry for entry in sequences if 'Cattle' in entry.defline]\nmammal_dataset20 = [entry for entry in sequences if 'Horse' in entry.defline]\nmammal_dataset21 = [entry for entry in sequences if 'Cat' in entry.defline]\nmammal_dataset22 = [entry for entry in sequences if 'Bat' in entry.defline]\nmammal_dataset23 = [entry for entry in sequences if 'bat_BF_258I' in entry.defline]\nmammal_dataset24 = [entry for entry in sequences if 'Swine' in entry.defline]\nmammal_Human_dataset25 = [entry for entry in sequences if 'Human' in entry.defline]\n\nmammal_dataset = mammal_dataset1 + mammal_dataset2 + mammal_dataset3 + mammal_dataset4 + mammal_dataset5 + mammal_dataset6 + mammal_dataset7 + mammal_dataset8 + mammal_dataset9 + mammal_dataset10 + mammal_dataset11 + mammal_dataset12 + mammal_dataset13 + mammal_dataset14 + mammal_dataset15 + mammal_dataset16 + mammal_dataset17 + mammal_dataset18 + mammal_dataset19 + mammal_dataset20 + mammal_dataset21 + mammal_dataset22 + mammal_dataset23 + mammal_dataset24 + mammal_Human_dataset25\n\n\n#encodeing mammal dataset\n\nmammal_encoded_sequences = []\n\nfor entry in mammal_dataset:\n    mammal_encoded_sequences.append(encoding(entry.sequence))","436ba849":"#targets\nnonhumanmammaltargets = [0 for entry in mammal_dataset1 + mammal_dataset2 + mammal_dataset3 + mammal_dataset4 + mammal_dataset5 + mammal_dataset6 + mammal_dataset7 + mammal_dataset8 + mammal_dataset9 + mammal_dataset10 + mammal_dataset11 + mammal_dataset12 + mammal_dataset13 + mammal_dataset14 + mammal_dataset15 + mammal_dataset16 + mammal_dataset17 + mammal_dataset18 + mammal_dataset19 + mammal_dataset20 + mammal_dataset21 + mammal_dataset22 + mammal_dataset23 + mammal_dataset24]\nhumanmammaltargets = [1 for entry in mammal_Human_dataset25]\n\nmammaltargets = nonhumanmammaltargets + humanmammaltargets\n\nprint(mammaltargets)\nprint(len(mammaltargets))","e02071bf":"print('There are', len(mammal_dataset), 'mammals in the total dataset \\n')\nprint('Here are all of the host specieis in the dataset')\n\n#display host species \nidx2 = pd.Index(host_species)\nprint(idx2.value_counts())\n","3ab97d4d":"# here we prepare the data to be plootted as a bar graph\ny_labels = idx2.value_counts().index.values # viral host species names\ncounts = idx2.value_counts().values    # numbers of occuriencies\ncounts_as_series = pd.Series(counts)","76f23134":"plt.figure(figsize=(12, 9))\nax = counts_as_series.plot(kind ='barh')\nax.set_title('The data distribution of viral hosts')\nax.set_xlabel('Number of entries')\nax.set_ylabel('Species of viral host')\nax.set_yticklabels(y_labels)\nax.set_xlim(-10, 295) # we change the x limits in order to make labels more readable\n\nrectangles = ax.patches\n\n# we place a label for each bar\nfor rectangle in rectangles:\n    \n    # we obtain x and y positions for the current label\n    x_value = rectangle.get_width()\n    y_value = rectangle.get_y() + rectangle.get_height()\/2\n    \n    # we annotate a current bar in the bar graph\n    plt.annotate(\n        x_value,                    # we use x_value as a label\n        (x_value, y_value),         # we place labels at end of the bars\n        xytext=(5, 0),              # we shift the label horizontally by 5\n        textcoords=\"offset points\", # we interpret xytext as an offset in points\n        va='center',                # we center the labels vertically \n        ha='left')                  # we specify the alignment for the labels       ","8cb2312d":"# SVM-classifier for mammal Data set\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.svm import SVC\nxTrain_mammal, xTest_mammal, yTrain_mammal, yTest_mammal = train_test_split(mammal_encoded_sequences, \n                                                                                                    mammaltargets, \n                                                                                                    test_size = 0.2, \n                                                                                                    random_state = 42)\n\nclassifier_SVM_mammal = SVC(probability = True)\nclassifier_SVM_mammal.fit(xTrain_mammal, yTrain_mammal)\ny_predicted_SVM_mammal = classifier_SVM_mammal.predict(xTest_mammal)\n\n#report accuracy, f1, precision, recall for SVM\naccuracy, f1, precision, recall = scores(yTest_mammal, y_predicted_SVM_mammal)","b128eb43":"# import numpy as nu\n# from sklearn import datasets\n# from sklearn import metrics\n# from sklearn.metrics import roc_curve,auc\n# from sklearn.model_selection import StratifiedKFold\n# from scipy import interp\n# import matplotlib.pylab as plt\n\n# from sklearn.ensemble import AdaBoostClassifier as ad\n# from sklearn.svm import SVC #svm\n# from sklearn.ensemble import RandomForestClassifier as RF #random forest\n# from sklearn.ensemble import ExtraTreesClassifier as ET #extratree\n# from sklearn.metrics import plot_confusion_matrix\n# from sklearn.multiclass import OneVsRestClassifier as OR","673f0283":"# rf = RF(max_depth=2, random_state=0)\n# et=ET(n_estimators=100, random_state=0)\n# svc=SVC(probability=True)\n# pool=[rf,et,svc]\n\n# x=feature ####please change this part to fit your code#####\n# y=Label\n\n# cv = StratifiedKFold(n_splits=10,shuffle=False)","ed81fe0c":"def ROC(method):\n    tprs = []\n    aucs = []\n    mean_fpr = np.linspace(0,1,100)\n    i = 1\n    \n    acc=[]\n    sen=[]\n    spec=[]\n    f1=[]  \n    \n    def confusion_metrics (conf_matrix):\n        TP = conf_matrix[1][1]\n        TN = conf_matrix[0][0]\n        FP = conf_matrix[0][1]\n        FN = conf_matrix[1][0]\n        print('True Positives:', TP)\n        print('True Negatives:', TN)\n        print('False Positives:', FP)\n        print('False Negatives:', FN)\n    \n        #accuracy\n        conf_accuracy = (float (TP+TN) \/ float(TP + TN + FP + FN))\n\n        # calculate the sensitivity\n        conf_sensitivity = (TP \/ float(TP + FN))\n        \n        # calculate the specificity\n        conf_specificity = (TN \/ float(TN + FP))\n        \n        # calculate f_1 score\n        conf_f1 = 2 * ((conf_precision * conf_sensitivity) \/ (conf_precision + conf_sensitivity))\n    \n        acc.append(conf_accuracy)\n        sen.append(conf_sensitivity)\n        spec.append(conf_specificity)\n        f1.append(conf_f1)\n    \n    \n    for train,test in cv.split(x,y):\n        prediction = method.fit(x.iloc[train],y.iloc[train]).predict_proba(x.iloc[test])\n        y_pred=method.fit(x.iloc[train],y.iloc[train]).predict(x.iloc[test])\n        #create confusion matrix\n        cm = metrics.confusion_matrix(y.iloc[test], y_pred)\n        cm_df = pd.DataFrame(cm)\n        confusion_metrics (cm_df)\n      \n        fpr, tpr, t = roc_curve(y.iloc[test], prediction[:, 1])\n        tprs.append(interp(mean_fpr, fpr, tpr))\n        roc_auc = auc(fpr, tpr)\n        aucs.append(roc_auc)\n        plt.plot(fpr, tpr, lw=2, alpha=0.3, label='ROC fold %d (AUC = %0.2f)' % (i, roc_auc))\n        i= i+1\n        \n    plt.plot([0,1],[0,1],linestyle = '--',lw = 2,color = 'black')\n    mean_tpr = np.mean(tprs, axis=0)\n    mean_auc = auc(mean_fpr, mean_tpr)\n    plt.plot(mean_fpr, mean_tpr, color='blue',\n         label=r'Mean ROC (AUC = %0.2f )' % (mean_auc),lw=2, alpha=1)\n\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n    method1=str(method)\n    title=\"ROC of \"+method1[:method1.find(\"(\")]\n    plt.title(title)\n    plt.legend(loc=\"lower right\")\n    fig = plt.gcf()\n    fig.set_size_inches(10, 5)\n    plt.show()\n    \n    #boxplot\n    plt.plot()\n    labelY=[\"accurancy\",\"sensitivity\",\"specificity\",\"f1 score\"]\n    data=[acc,sen,spec,f1]\n    title3=\"performance of \"+method1[:method1.find(\"(\")]\n    plt.title(title3)\n    plt.ylim=(0,1,0.1)\n    plt.boxplot(data,labels=labelY)\n    plt.show()","0ce82593":"Everything (accuracy, f1, precision, recall) is close to 1 here, meaning: we are experiencing overfitting","bc24381f":"> # **Encoding**","04637e9c":"# New insights from Arthur (balancing the dataset)\n\nedited and slightly modified by Kiril","a799a411":"> # **How we assess the performance**","7b21de68":"> # **Visualization**","10ff809a":"# SVM","352ecacd":"# **Getting familiar with the data**","9852c140":"**Oh, dear!**","126d1466":"# Creating a mammal host species dataset   ","6a0dd095":"Muting Human_coronavirus_HKU1","fff2bde5":"There are only 7 known to be able to infect humans. \n\nIn the table belong the visur classification in gives as Genus -> Subgenus -> Species -> Subspecies -> Strain\nThe name that are in our database are hilighted **in bold**\n\n\n* 229E (a.k.a. HCoV-229E, Human coronavirus 229E) belongs to  Alphacoronavirus -> Duvinacovirus -> **Human coronavirus 229E** -> NA -> NA\n* NL63 (a.k.a. HCoV-NL63, Human coronavirus NL63) belongs to  Alphacoronavirus -> Setracovirus -> **Human coronavirus NL63** -> NA -> NA\n* OC43 (a.k.a. HCoV-OC43, Human coronavirus OC43) belongs to  Betacoronavirus -> NA -> **Betacoronavirus 1** -> Human coronavirus OC43 -> NA\n* HKU1 (a.k.a. HCoV-HKU1, **Human coronavirus HKU1**) belongs to  Betacoronavirus -> Embecovirus -> **Human coronavirus HKU1** -> NA -> NA\n* MERS-CoV (a.k.a. EMC\/2012, HCoV-EMC\/2012, Middle East respiratory syndrome-related coronavirus)\n   belongs to  Betacoronavirus -> Merbecovirus -> **Middle East respiratory syndrome-related coronavirus** -> NA -> NA\n* SARS-CoV (a.k.a. SARS-CoV, SARS-CoV-1, Severe acute respiratory syndrome coronavirus)\n   belongs to  Betacoronavirus -> NA-> **Severe acute respiratory syndrome-related coronavirus** -> NA -> Severe acute respiratory syndrome coronavirus\n* **SARS-CoV-2** (a.k.a. 2019-nCoV, Severe acute respiratory syndrome coronavirus 2)\n   belongs to  Betacoronavirus -> Sarbecovirus -> Severe acute respiratory syndrome-related coronavirus -> NA -> Severe acute respiratory syndrome coronavirus 2\n                  \n                  \n\n","fe525f71":"Looks like all NAs are the Middle_east beast :-)","343c616d":"Muting Severe_acute_respiratory_syndrome_related_coronavirus","70388c2b":"# Some insights from Kiki","111d1590":"# **Reading the data**","5e7b2dd4":"# Boxt plots from Lake Li","f4177e80":"taken from [Zhang Lab](https:\/\/zhanglab.ccmb.med.umich.edu\/FASTA\/)\n\nFASTA format is a text-based format for representing either nucleotide sequences or peptide sequences, in which base pairs or amino acids are represented using single-letter codes. A sequence in FASTA format begins with a single-line description, followed by lines of sequence data. The description line is distinguished from the sequence data by a greater-than (\">\") symbol in the first column. It is recommended that all lines of text be shorter than 80 characters in length.\nAn example sequence in FASTA format is:\n\n>S|spike_protein|MG996765|AWV66922.1|A0A3G1RFS9|P138\/72|NA|1972|Horse|Switzerland|NA|Equine_torovirus\nMFLCFCAATVLCFWINSGGADVVPNGTLIFSEPVPYPFSLDVLRSFSQHVVLRNKRAVTTISWSYSYQIT\nTSSLSVNSWYVTFTAPLGWNYYTGQSFGTVLNQNAMMRASQSTFTYDVISYVGQRPNLDCQVNSLVNGGL\nDGWYSTVRVDNCFNAPCHVGGRPGCSIGIPYMSNGVCTRVLSTTQSPGLQYEIYSGQQFAVYQITPYTQY\n\n\nSequences are expected to be represented in the standard IUB\/IUPAC amino acid and nucleic acid codes, with these exceptions:\nlower-case letters are accepted and are mapped into upper-case;\na single hyphen or dash can be used to represent a gap of indeterminate length;\nin amino acid sequences, U and * are acceptable letters (see below).\nany numerical digits in the query sequence should either be removed or replaced by appropriate letter codes (e.g., N for unknown nucleic acid residue or X for unknown amino acid residue).\nThe nucleic acid codes are:\n\n        A --> adenosine           M --> A C (amino)\n        C --> cytidine            S --> G C (strong)\n        G --> guanine             W --> A T (weak)\n        T --> thymidine           B --> G T C\n        U --> uridine             D --> G A T\n        R --> G A (purine)        H --> A C T\n        Y --> T C (pyrimidine)    V --> G C A\n        K --> G T (keto)          N --> A G C T (any)\n                                  -  gap of indeterminate length\nThe accepted amino acid codes are:\n\n    A ALA alanine                         P PRO proline\n    B ASX aspartate or asparagine         Q GLN glutamine\n    C CYS cystine                         R ARG arginine\n    D ASP aspartate                       S SER serine\n    E GLU glutamate                       T THR threonine\n    F PHE phenylalanine                   U     selenocysteine\n    G GLY glycine                         V VAL valine\n    H HIS histidine                       W TRP tryptophan\n    I ILE isoleucine                      Y TYR tyrosine\n    K LYS lysine                          Z GLX glutamate or glutamine\n    L LEU leucine                         X     any\n    M MET methionine                      *     translation stop\n    N ASN asparagine                      -     gap of indeterminate length"}}