{"cell_type":{"edc27212":"code","5d328934":"code","daa97610":"code","a0149d56":"code","1c31b914":"code","967a848d":"code","3010cbb4":"code","88d8debe":"code","4b93342c":"code","d7f18ea4":"code","6cce6ea2":"code","9bc40643":"code","0c2401f5":"markdown","08d59afe":"markdown"},"source":{"edc27212":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.utils.data import Dataset,DataLoader","5d328934":"class PATH:\n    TRAIN = '\/kaggle\/input\/digit-recognizer\/train.csv'\n    TEST = '\/kaggle\/input\/digit-recognizer\/test.csv'\n    \nclass CONFIG:\n    lr = 0.001\n    epoch = 10\n    batch_size = 256","daa97610":"df_train = pd.read_csv(PATH.TRAIN)","a0149d56":"l = len(df_train)","1c31b914":"_x = torch.Tensor(df_train.iloc[:,1:].values).reshape(l,28,28) \/ 256\n_x = _x.unsqueeze(1)\n_y = torch.Tensor(df_train.iloc[:,0].values).type(torch.long)\n\ntrain_x ,valid_x = _x[:39000],_x[39000:]\ntrain_y ,valid_y = _y[:39000],_y[39000:]","967a848d":"class DigitDataset(Dataset):\n    \n    def __init__(self,x,y=None):\n        super(DigitDataset).__init__()\n        self.x = x\n        self.y = y\n        \n    def __getitem__(self,idx):\n        if self.y == None:\n            return self.x[idx]\n        return self.x[idx],self.y[idx]\n    \n    def __len__(self):\n        return len(self.x)\n        ","3010cbb4":"class DigitModel(nn.Module):\n    \n    def __init__(self):\n        super(DigitModel,self).__init__()\n        \n        self.model = nn.Sequential(\n            nn.Conv2d(1,32,3),\n            nn.Conv2d(32,8,3),\n            nn.Flatten(),\n            nn.Linear(24*24*8,256),\n            nn.ReLU(),\n            nn.Linear(256,128),\n            nn.ReLU(),\n            nn.Linear(128,10)\n        )\n        \n    def forward(self,x):\n        x = self.model(x)\n        x = torch.softmax(x,dim=-1)\n        return x","88d8debe":"device = 'cuda' if torch.cuda.is_available() else 'cpu'\nprint(device)\n\nmodel = DigitModel().to(device)\ntrainset = DigitDataset(train_x,train_y)\nvalidset = DigitDataset(valid_x,valid_y)\ndl = DataLoader(trainset,batch_size = CONFIG.batch_size,shuffle=True)\nvalid_dl = DataLoader(validset,batch_size = CONFIG.batch_size)\nlossfn = nn.CrossEntropyLoss()\nopt = torch.optim.Adam(model.parameters(), lr=CONFIG.lr)","4b93342c":"for e in range(CONFIG.epoch):\n    print(f\"Training on progress... {e}\/{CONFIG.epoch}\")\n    acc =0\n    total =0\n    \n    model.train()\n    for x,y in dl:\n        x = x.to(device)\n        y = y.to(device)\n        y_hat = model(x)\n        loss = lossfn(y_hat,y)\n        \n        opt.zero_grad()\n        loss.backward()\n        opt.step()\n        \n    model.eval()\n    with torch.no_grad():\n        for vx,vy in valid_dl:\n            vx = vx.to(device)\n            vy = vy.to(device)\n            \n            vy_hat = model(vx)\n            pred = vy_hat.max(dim=1)[1]\n            acc += (pred == vy).sum().item()\n    print(f\"Epoch {e} : Acc {100*acc\/3000}\")","d7f18ea4":"df_test= pd.read_csv(PATH.TEST)\nl = len(df_test)\ntest_x = torch.Tensor(df_test.values).reshape(l,28,28) \/ 256\ntest_x = test_x.unsqueeze(1)","6cce6ea2":"outputs = model(test_x)\n_, pred = torch.max(outputs, 1)","9bc40643":"preds = pred.cpu()\nsubmission = pd.DataFrame({'ImageId': np.arange(1, (preds.size(0) + 1)), 'Label': preds})\nsubmission.to_csv(\"submission.csv\", index = False)","0c2401f5":"# Test and submit","08d59afe":"# Train model"}}