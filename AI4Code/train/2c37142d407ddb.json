{"cell_type":{"66529537":"code","8415dc0e":"code","00699b80":"code","34621da3":"code","da8ba26a":"code","f5555794":"code","2cc0aab0":"code","933b52cf":"code","a0a4e095":"code","e63d54ce":"code","bd0decd8":"code","a9e7310c":"code","f0622fa0":"code","c816b78b":"code","59397e30":"code","716e3897":"code","29e84327":"code","89342050":"code","2bb5a38a":"code","65e8b156":"code","3a1a23a5":"code","1058a4a2":"code","4ce462b6":"code","f73ef4ae":"code","b3f44a4c":"code","1c4e9743":"code","196912bf":"code","c4ce3697":"code","854b6dd3":"code","d736165b":"code","b836c73e":"code","f7972bf9":"code","370b2e76":"markdown"},"source":{"66529537":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport os\n\nprint(os.listdir(\"..\/input\"))\n#!pip install pytorch-pretrained-bert\n#!pip install seqeval","8415dc0e":"dframe = pd.read_csv(\"..\/input\/ner.csv\", encoding = \"ISO-8859-1\", error_bad_lines=False)","00699b80":"dframe.head()","34621da3":"dataset=dframe.drop(['Unnamed: 0', 'lemma', 'next-lemma', 'next-next-lemma', 'next-next-pos',\n       'next-next-shape', 'next-next-word', 'next-pos', 'next-shape',\n       'next-word', 'prev-iob', 'prev-lemma', 'prev-pos',\n       'prev-prev-iob', 'prev-prev-lemma', 'prev-prev-pos', 'prev-prev-shape',\n       'prev-prev-word', 'prev-shape', 'prev-word','shape'],axis=1)","da8ba26a":"dataset.head()","f5555794":"class SentenceGetter(object):\n    \n    def __init__(self, dataset):\n        self.n_sent = 1\n        self.dataset = dataset\n        self.empty = False\n        agg_func = lambda s: [(w,p, t) for w,p, t in zip(s[\"word\"].values.tolist(),\n                                                       s['pos'].values.tolist(),\n                                                        s[\"tag\"].values.tolist())]\n        self.grouped = self.dataset.groupby(\"sentence_idx\").apply(agg_func)\n        self.sentences = [s for s in self.grouped]\n    \n    def get_next(self):\n        try:\n            s = self.grouped[\"Sentence: {}\".format(self.n_sent)]\n            self.n_sent += 1\n            return s\n        except:\n            return None","2cc0aab0":"getter = SentenceGetter(dataset)","933b52cf":"sentences = [\" \".join([s[0] for s in sent]) for sent in getter.sentences]\nsentences[0]","a0a4e095":"labels = [[s[2] for s in sent] for sent in getter.sentences]\nprint(labels[0])","e63d54ce":"tags_vals = list(set(dataset[\"tag\"].values))\ntag2idx = {t: i for i, t in enumerate(tags_vals)}","bd0decd8":"import torch\nfrom torch.optim import Adam\nfrom torch.utils.data import TensorDataset, DataLoader, RandomSampler, SequentialSampler\nfrom keras.preprocessing.sequence import pad_sequences\nfrom sklearn.model_selection import train_test_split\nfrom pytorch_pretrained_bert import BertTokenizer, BertConfig\nfrom pytorch_pretrained_bert import BertForTokenClassification, BertAdam\nfrom tqdm import tqdm, trange","a9e7310c":"MAX_LEN = 40\nbs =64","f0622fa0":"device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nn_gpu = torch.cuda.device_count()","c816b78b":"torch.cuda.get_device_name(0) ","59397e30":"tokenizer = BertTokenizer.from_pretrained('bert-base-uncased', do_lower_case=True)","716e3897":"tokenized_texts = [tokenizer.tokenize(sent) for sent in sentences]\nprint(tokenized_texts[0])","29e84327":"input_ids = pad_sequences([tokenizer.convert_tokens_to_ids(txt) for txt in tokenized_texts],\n                          maxlen=MAX_LEN, dtype=\"long\", truncating=\"post\", padding=\"post\")","89342050":"tags = pad_sequences([[tag2idx.get(l) for l in lab] for lab in labels],\n                     maxlen=MAX_LEN, value=tag2idx[\"O\"], padding=\"post\",\n                     dtype=\"long\", truncating=\"post\")","2bb5a38a":"attention_masks = [[float(i>0) for i in ii] for ii in input_ids]","65e8b156":"tr_inputs, val_inputs, tr_tags, val_tags = train_test_split(input_ids, tags, \n                                                            random_state=2018, test_size=0.1)\ntr_masks, val_masks, _, _ = train_test_split(attention_masks, input_ids,\n                                             random_state=2018, test_size=0.1)","3a1a23a5":"tr_inputs = torch.tensor(tr_inputs)\nval_inputs = torch.tensor(val_inputs)\ntr_tags = torch.tensor(tr_tags)\nval_tags = torch.tensor(val_tags)\ntr_masks = torch.tensor(tr_masks)\nval_masks = torch.tensor(val_masks)","1058a4a2":"train_data = TensorDataset(tr_inputs, tr_masks, tr_tags)\ntrain_sampler = RandomSampler(train_data)\ntrain_dataloader = DataLoader(train_data, sampler=train_sampler, batch_size=bs)\n\nvalid_data = TensorDataset(val_inputs, val_masks, val_tags)\nvalid_sampler = SequentialSampler(valid_data)\nvalid_dataloader = DataLoader(valid_data, sampler=valid_sampler, batch_size=bs)","4ce462b6":"train_data","f73ef4ae":"model = BertForTokenClassification.from_pretrained(\"bert-base-uncased\", num_labels=len(tag2idx))","b3f44a4c":"model.cuda()","1c4e9743":"FULL_FINETUNING = True\nif FULL_FINETUNING:\n    param_optimizer = list(model.named_parameters())\n    no_decay = ['bias', 'gamma', 'beta']\n    optimizer_grouped_parameters = [\n        {'params': [p for n, p in param_optimizer if not any(nd in n for nd in no_decay)],\n         'weight_decay_rate': 0.01},\n        {'params': [p for n, p in param_optimizer if any(nd in n for nd in no_decay)],\n         'weight_decay_rate': 0.0}\n    ]\nelse:\n    param_optimizer = list(model.classifier.named_parameters()) \n    optimizer_grouped_parameters = [{\"params\": [p for n, p in param_optimizer]}]\noptimizer = Adam(optimizer_grouped_parameters, lr=3e-5)","196912bf":"#from seqeval.metrics import f1_score\n\ndef flat_accuracy(preds, labels):\n    pred_flat = np.argmax(preds, axis=2).flatten()\n    labels_flat = labels.flatten()\n    return np.sum(pred_flat == labels_flat) \/ len(labels_flat)","c4ce3697":"epochs = 3\nmax_grad_norm = 1.0\n\nfor _ in trange(epochs, desc=\"Epoch\"):\n    # TRAIN loop\n    model.train()\n    tr_loss = 0\n    nb_tr_examples, nb_tr_steps = 0, 0\n    for step, batch in enumerate(train_dataloader):\n        # add batch to gpu\n        batch = tuple(t.to(device) for t in batch)\n        b_input_ids, b_input_mask, b_labels = batch\n        # forward pass\n        loss = model(b_input_ids, token_type_ids=None,\n                     attention_mask=b_input_mask, labels=b_labels)\n        # backward pass\n        loss.backward()\n        # track train loss\n        tr_loss += loss.item()\n        nb_tr_examples += b_input_ids.size(0)\n        nb_tr_steps += 1\n        # gradient clipping\n        torch.nn.utils.clip_grad_norm_(parameters=model.parameters(), max_norm=max_grad_norm)\n        # update parameters\n        optimizer.step()\n        model.zero_grad()\n    # print train loss per epoch\n    print(\"Train loss: {}\".format(tr_loss\/nb_tr_steps))\n    # VALIDATION on validation set\n    model.eval()\n    eval_loss, eval_accuracy = 0, 0\n    nb_eval_steps, nb_eval_examples = 0, 0\n    predictions , true_labels = [], []\n    for batch in valid_dataloader:\n        batch = tuple(t.to(device) for t in batch)\n        b_input_ids, b_input_mask, b_labels = batch\n        \n        with torch.no_grad():\n            tmp_eval_loss = model(b_input_ids, token_type_ids=None,\n                                  attention_mask=b_input_mask, labels=b_labels)\n            logits = model(b_input_ids, token_type_ids=None,\n                           attention_mask=b_input_mask)\n        logits = logits.detach().cpu().numpy()\n        label_ids = b_labels.to('cpu').numpy()\n        predictions.extend([list(p) for p in np.argmax(logits, axis=2)])\n        true_labels.append(label_ids)\n        \n        tmp_eval_accuracy = flat_accuracy(logits, label_ids)\n        \n        eval_loss += tmp_eval_loss.mean().item()\n        eval_accuracy += tmp_eval_accuracy\n        \n        nb_eval_examples += b_input_ids.size(0)\n        nb_eval_steps += 1\n    eval_loss = eval_loss\/nb_eval_steps\n    print(\"Validation loss: {}\".format(eval_loss))\n    print(\"Validation Accuracy: {}\".format(eval_accuracy\/nb_eval_steps))\n    pred_tags = [tags_vals[p_i] for p in predictions for p_i in p]\n    valid_tags = [tags_vals[l_ii] for l in true_labels for l_i in l for l_ii in l_i]\n   # print(\"F1-Score: {}\".format(f1_score(pred_tags, valid_tags)))","854b6dd3":"model.eval()\npredictions = []\ntrue_labels = []\neval_loss, eval_accuracy = 0, 0\nnb_eval_steps, nb_eval_examples = 0, 0\nfor batch in valid_dataloader:\n    batch = tuple(t.to(device) for t in batch)\n    b_input_ids, b_input_mask, b_labels = batch\n\n    with torch.no_grad():\n        tmp_eval_loss = model(b_input_ids, token_type_ids=None,\n                              attention_mask=b_input_mask, labels=b_labels)\n        logits = model(b_input_ids, token_type_ids=None,\n                       attention_mask=b_input_mask)\n        \n    logits = logits.detach().cpu().numpy()\n    predictions.extend([list(p) for p in np.argmax(logits, axis=2)])\n    label_ids = b_labels.to('cpu').numpy()\n    true_labels.append(label_ids)\n    tmp_eval_accuracy = flat_accuracy(logits, label_ids)\n\n    eval_loss += tmp_eval_loss.mean().item()\n    eval_accuracy += tmp_eval_accuracy\n\n    nb_eval_examples += b_input_ids.size(0)\n    nb_eval_steps += 1\n\npred_tags = [[tags_vals[p_i] for p_i in p] for p in predictions]\nvalid_tags = [[tags_vals[l_ii] for l_ii in l_i] for l in true_labels for l_i in l ]\nprint(\"Validation loss: {}\".format(eval_loss\/nb_eval_steps))\nprint(\"Validation Accuracy: {}\".format(eval_accuracy\/nb_eval_steps))\n#print(\"Validation F1-Score: {}\".format(f1_score(pred_tags, valid_tags)))","d736165b":"#pred_tags","b836c73e":"test_sentence = [\"I have recently bought a new samsung galaxy phone\"]\n\ntokenized_test_texts = [tokenizer.tokenize(sent) for sent in test_sentence]\nprint(\"Tokenized Test Sentence\")\nprint(tokenized_test_texts[0])\n\nprint(\"Padding Test Sequence\")\ninput_ids = pad_sequences([tokenizer.convert_tokens_to_ids(txt) for txt in tokenized_test_texts],\n                          maxlen=MAX_LEN, dtype=\"long\", truncating=\"post\", padding=\"post\")\n\ntest_attention_masks = [[float(i>0) for i in ii] for ii in input_ids]\n\ntest_inputs = torch.tensor(input_ids)\ntest_masks = torch.tensor(test_attention_masks)\n\ntest_sentence_data = TensorDataset(test_inputs, test_masks)\ntrain_sentence_sampler = RandomSampler(test_sentence_data)\ntest_sentence_dataloader = DataLoader(test_sentence_data, sampler=train_sentence_sampler, batch_size=bs)\n\n\nmodel.eval()\npredictions = []\n#true_labels = []\neval_loss, eval_accuracy = 0, 0\nnb_eval_steps, nb_eval_examples = 0, 0\nfor batch in test_sentence_dataloader:\n    batch = tuple(t.to(device) for t in batch)\n    b_input_ids, b_input_mask = batch\n\n    with torch.no_grad():\n        tmp_eval_loss = model(b_input_ids, token_type_ids=None,\n                              attention_mask=b_input_mask)\n        logits = model(b_input_ids, token_type_ids=None,\n                       attention_mask=b_input_mask)\n        \n    logits = logits.detach().cpu().numpy()\n    predictions.extend([list(p) for p in np.argmax(logits, axis=2)])\n\n\npred_tags = [[tags_vals[p_i] for p_i in p] for p in predictions]\n","f7972bf9":"pred_tags","370b2e76":"TEST ON RANDOM INPUT"}}