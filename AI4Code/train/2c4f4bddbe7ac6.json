{"cell_type":{"c2236ba4":"code","27a59196":"code","4a4eeeb9":"code","8e8b73ca":"code","2bbdf4ec":"code","aee0b075":"code","903611d5":"code","731438f8":"code","e0359ee0":"code","0e6e8373":"code","e40c78f4":"code","42ea0014":"markdown"},"source":{"c2236ba4":"import os\nimport glob\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\nfrom tensorflow.keras.preprocessing.image import load_img, img_to_array\nfrom tensorflow.image import resize_with_pad\nfrom tensorflow.keras import Sequential\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.layers import Conv2D, Dropout, LeakyReLU, MaxPooling2D, UpSampling2D","27a59196":"BASE_IMAGE_PATH = '..\/input\/guns-object-detection\/Images'\nBASE_LABELS_PATH = '..\/input\/guns-object-detection\/Labels'\nTARGET_IMAGE_SIZE = (256, 256)\nLEARNING_RATE = 0.0001\nBATCH_SIZE = 16\nEPOCHS = 50\nVAL_SPLIT = 0.2","4a4eeeb9":"image_data = []\nimage_labels = []\n\nimage_count = len(os.listdir(BASE_IMAGE_PATH))\n\nfor i in range(1, image_count + 1):\n    img = load_img(os.path.join(BASE_IMAGE_PATH, str(i) + '.jpeg'))\n    img = img_to_array(img, dtype = 'uint8')\n    image_data.append(img)\n    \n    label_mask = np.zeros((*img.shape[:2], 1))\n    \n    with open(os.path.join(BASE_LABELS_PATH, str(i) + '.txt'), 'r') as label_file:\n        l_count = int(label_file.readline())\n        \n        for i in range(l_count):\n            box = list(map(int, label_file.readline().split()))\n            label_mask[box[1]:box[3], box[0]:box[2]] = 1.0\n        \n    image_labels.append(label_mask)","8e8b73ca":"plt.subplots(nrows = 2, ncols = 4, figsize = (20, 10))\n\nfor i, img_index in enumerate(np.random.randint(0, image_count, size = 4)):\n    plt.subplot(2, 4, i + 1)\n    plt.axis(False)\n    plt.grid(False)\n    plt.title(f'Image: {img_index}')\n    plt.imshow(image_data[img_index])\n    \n    plt.subplot(2, 4, i + 5)\n    plt.axis(False)\n    plt.grid(False)\n    plt.title(f'Label mask: {img_index}')\n    plt.imshow(image_labels[img_index], cmap = 'gray')\nplt.show()","2bbdf4ec":"for i in range(image_count):\n    image_data[i] = resize_with_pad(image_data[i], *TARGET_IMAGE_SIZE).numpy() \/ 255.0\n    image_labels[i] = resize_with_pad(image_labels[i], *TARGET_IMAGE_SIZE).numpy()","aee0b075":"plt.subplots(nrows = 2, ncols = 4, figsize = (20, 10))\n\nfor i, img_index in enumerate(np.random.randint(0, image_count, size = 4)):\n    plt.subplot(2, 4, i + 1)\n    plt.axis(False)\n    plt.grid(False)\n    plt.title(f'Image: {img_index}')\n    plt.imshow(image_data[img_index])\n    \n    plt.subplot(2, 4, i + 5)\n    plt.axis(False)\n    plt.grid(False)\n    plt.title(f'Label mask: {img_index}')\n    plt.imshow(image_labels[img_index], cmap = 'gray')\nplt.show()","903611d5":"image_data = np.array(image_data)\nimage_labels = np.array(image_labels)","731438f8":"def weighted_bce(y_true, y_pred):\n    LOSS_WEIGHT = 8\n    loss_ones = LOSS_WEIGHT * y_true * tf.math.log(y_pred + 1e-7)\n    loss_zeros = (1 - y_true) * tf.math.log(1 - y_pred + 1e-7)\n    loss = - loss_ones - loss_zeros\n    return tf.reduce_mean(loss)","e0359ee0":"model = Sequential([\n    Conv2D(32, 5, padding = 'same', input_shape = (*TARGET_IMAGE_SIZE, 3), activation = LeakyReLU()),\n    MaxPooling2D(),\n\n    Conv2D(64, 4, padding = 'same', activation = LeakyReLU()),\n    MaxPooling2D(),\n    \n    Conv2D(128, 3, padding = 'same', activation = LeakyReLU()),\n    Dropout(0.1),\n    \n    UpSampling2D(),\n    Conv2D(64, 4, padding = 'same', activation = LeakyReLU()),\n\n    UpSampling2D(),\n    Conv2D(32, 5, padding = 'same', activation = LeakyReLU()),\n\n    Dropout(0.1),\n    Conv2D(1, 3, padding = 'same', activation = 'sigmoid'),\n])\n\nmodel.compile(optimizer = Adam(LEARNING_RATE), loss = weighted_bce)\n\nmodel.summary()","0e6e8373":"%%time\n\nhistory = model.fit(image_data, image_labels, batch_size = BATCH_SIZE, epochs = EPOCHS, validation_split = VAL_SPLIT, verbose = 1)","e40c78f4":"plt.subplots(nrows = 3, ncols = 4, figsize = (20, 10))\n\nindices_to_predict = np.random.randint(0, image_count, size = 4)\n\nfor i, img_index in enumerate(indices_to_predict):\n    preds = model.predict(image_data[indices_to_predict])\n    \n    masked_images = preds * image_data[indices_to_predict]\n    \n    plt.subplot(3, 4, i + 1)\n    plt.axis(False)\n    plt.grid(False)\n    plt.title(f'Image: {img_index}')\n    plt.imshow(image_data[img_index])\n    \n    plt.subplot(3, 4, i + 5)\n    plt.axis(False)\n    plt.grid(False)\n    plt.title(f'Predicted mask: {img_index}')\n    plt.imshow(preds[i], cmap = 'gray')\n    \n    plt.subplot(3, 4, i + 9)\n    plt.axis(False)\n    plt.grid(False)\n    plt.title(f'Masked image: {img_index}')\n    plt.imshow(masked_images[i])\nplt.show()","42ea0014":"# Improvements required\n- Image augmentation\n- Custom loss function to give more weightage to the value 1 in the target - **Done**"}}