{"cell_type":{"e897644b":"code","b0366793":"code","488cf40a":"code","4e1436d1":"code","0b6692d8":"code","cd419e25":"code","404d651f":"code","e6ed5ce6":"code","29ba5d24":"code","dd6882f4":"code","dcac9f84":"code","05326465":"code","0c15d3c8":"code","e64bbe4d":"markdown","fb24e95e":"markdown","de06aff9":"markdown","92a31397":"markdown","516f88d0":"markdown","966d7416":"markdown","ef7f29fe":"markdown","c1aa6ba3":"markdown"},"source":{"e897644b":"from IPython.display import display, Markdown, Latex\nimport json\nimport numpy as np\nimport pandas as pd\nimport re\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport descartes\nimport geopandas as gpd\nfrom shapely.geometry import Point, Polygon\nimport contextily as ctx\n\n# Viz config\nplt.style.use('seaborn')\ncolors = [\"#4B88A2\", \"#BC2C1A\", \"#DACC3E\", \"#EA8C55\", \"#7FB7BE\"]\npalette = sns.color_palette(colors)\nsns.set_palette(palette)\nalpha = 0.7","b0366793":"raw_data_file = \"\/kaggle\/input\/netherlands-rent-properties\/properties.json\"\n\ndef load_raw_data(filepath):\n    raw_data = []\n    for line in open(filepath, 'r'):\n        raw_data.append(json.loads(line))\n    \n    df = pd.DataFrame(raw_data)\n    \n    return df\n    \ndf = load_raw_data(raw_data_file)\n\nMarkdown(f\"Successfully imported DataFrame with shape: {df.shape}.\")","488cf40a":"# Functions from: https:\/\/www.kaggle.com\/juangesino\/starter-netherlands-rent-properties\n\n# Define all columns that need to be flatten and the property to extract\nflatten_mapper = {\n    \"_id\": \"$oid\",\n    \"crawledAt\": \"$date\",\n    \"firstSeenAt\": \"$date\",\n    \"lastSeenAt\": \"$date\",\n    \"detailsCrawledAt\": \"$date\",\n}\n\n\n# Function to do all the work of flattening the columns using the mapper\ndef flatten_columns(df, mapper):\n    \n    # Iterate all columns from the mapper\n    for column in flatten_mapper:\n        prop = flatten_mapper[column]\n        raw_column_name = f\"{column}_raw\"\n        \n        # Check if the raw column is already there\n        if raw_column_name in df.columns:\n            # Drop the generated one\n            df.drop(columns=[column], inplace=True)\n            \n            # Rename the raw back to the original\n            df.rename(columns={ raw_column_name: column }, inplace=True)        \n    \n        # To avoid conflicts if re-run, we will rename the columns we will change\n        df.rename(columns={\n            column: raw_column_name,\n        }, inplace=True)\n\n        # Get the value inside the dictionary\n        df[column] = df[raw_column_name].apply(lambda obj: obj[prop])\n        \n    return df\n\n\ndef rename_columns(df):\n    # Store a dictionary to be able to rename later\n    rename_mapper = {}\n    \n    # snake_case REGEX pattern\n    pattern = re.compile(r'(?<!^)(?=[A-Z])')\n    \n    # Iterate the DF's columns\n    for column in df.columns:\n        rename_mapper[column] = pattern.sub('_', column).lower()\n        \n    # Rename the columns using the mapper\n    df.rename(columns=rename_mapper, inplace=True)\n    \n    return df\n\n\ndef parse_types(df):\n    \n    df[\"crawled_at\"] = pd.to_datetime(df[\"crawled_at\"])\n    df[\"first_seen_at\"] = pd.to_datetime(df[\"first_seen_at\"])\n    df[\"last_seen_at\"] = pd.to_datetime(df[\"last_seen_at\"])\n    df[\"details_crawled_at\"] = pd.to_datetime(df[\"details_crawled_at\"])\n    df[\"latitude\"] = pd.to_numeric(df[\"latitude\"])\n    df[\"longitude\"] = pd.to_numeric(df[\"longitude\"])\n    \n    return df\n\n\ndef add_features(df):\n    \n    df[\"rent_per_area\"] = df[\"rent\"] \/ df[\"area_sqm\"]\n    \n    return df","4e1436d1":"df = (df\n      .pipe(flatten_columns, mapper=flatten_mapper)\n      .pipe(rename_columns)\n      .pipe(parse_types)\n      .pipe(add_features)\n     )","0b6692d8":"geometry = [Point(xy) for xy in zip(df['longitude'],df['latitude'])]\ncrs = { 'init': 'epsg:4326' }\ngdf = gpd.GeoDataFrame(\n    df,\n    crs = crs,\n    geometry = geometry\n)","cd419e25":"netherlands_map = \"\/kaggle\/input\/netherlands-rent-properties\/2019_ggd_regios_kustlijn.gpkg\"\n\nnl_map = gpd.read_file(netherlands_map)\nfig, ax = plt.subplots(figsize=(10, 10))\nnl_map.to_crs(epsg=3857).plot(ax=ax, alpha=0.1, color='grey', edgecolor='black')\ngdf.to_crs(epsg=3857).plot(ax=ax, markersize=10, color=colors[0], marker='o')\nax.set_title('Properties in the Netherlands')\nax.set_axis_off()","404d651f":"fig, ax = plt.subplots(figsize=(10,10))\nnl_map.to_crs(epsg=3857).plot(ax=ax, alpha=0.1, color='grey', edgecolor='black')\ngdf.sort_values('rent_per_area').to_crs(epsg=3857).plot(ax=ax, markersize=10, marker='o', column='rent_per_area', cmap='inferno_r')\nax.set_title('Rental prices Netherlands')\nax.set_axis_off()\n# Create legend scale\ncax = fig.add_axes([1, 0.5, 0.01, 0.2])\nsm = plt.cm.ScalarMappable(cmap='inferno_r', norm=plt.Normalize(vmin=gdf['rent_per_area'].min(), vmax=gdf['rent_per_area'].max()))\nsm._A = []\ncbar = fig.colorbar(sm, cax=cax,)\ncbar.set_label('\\nPrice per $m^2$ $(\u20ac\/m^2)$')\ncbar.ax.tick_params(labelsize=10)","e6ed5ce6":"gdf = gdf[np.abs(gdf['area_sqm']-gdf['area_sqm'].mean()) <= (3*gdf['area_sqm'].std())]\ngdf = gdf[np.abs(gdf['rent']-gdf['rent'].mean()) <= (3*gdf['rent'].std())]","29ba5d24":"fig, ax = plt.subplots(figsize=(10,10))\nnl_map.to_crs(epsg=3857).plot(ax=ax, alpha=0.1, color='grey', edgecolor='black')\ngdf.sort_values('rent_per_area').to_crs(epsg=3857).plot(ax=ax, markersize=10, marker='o', column='rent_per_area', cmap='inferno_r')\nax.set_title('Rental prices Netherlands')\nax.set_axis_off()\n# Create legend scale\ncax = fig.add_axes([1, 0.5, 0.01, 0.2])\nsm = plt.cm.ScalarMappable(cmap='inferno_r', norm=plt.Normalize(vmin=gdf['rent_per_area'].min(), vmax=gdf['rent_per_area'].max()))\nsm._A = []\ncbar = fig.colorbar(sm, cax=cax,)\ncbar.set_label('\\nPrice per $m^2$ $(\u20ac\/m^2)$')\ncbar.ax.tick_params(labelsize=10)","dd6882f4":"# Extremly slow and inefficient. This can probably be improved by using Pandas' `.apply`\nfor index, row in nl_map.to_crs(epsg=3857).iterrows():\n    area = row.geometry\n    intersect = gdf[gdf.to_crs(epsg=3857).within(area)]\n    nl_map.loc[index, 'properties'] = len(intersect)\n    nl_map.loc[index, 'mean_rent'] = intersect['rent'].mean()\n    nl_map.loc[index, 'mean_rent_per_sqm'] = intersect['rent_per_area'].mean()\nnl_map = nl_map.fillna(0)","dcac9f84":"f,ax = plt.subplots(1, 3, figsize=(15,15), subplot_kw=dict(aspect='equal'))\n\nnl_map.to_crs(epsg=3857).plot(ax=ax[0], column='mean_rent', cmap='inferno_r', alpha=0.8, edgecolor='black')\nax[0].set_title(\"Average Rent (\u20ac)\")\nax[0].set_axis_off()\n\nnl_map.to_crs(epsg=3857).plot(ax=ax[1], column='mean_rent_per_sqm', cmap='inferno_r', alpha=0.8, edgecolor='black')\nax[1].set_title(\"Average Rent (\u20ac\/m2)\")\nax[1].set_axis_off()\n\nnl_map.to_crs(epsg=3857).plot(ax=ax[2], column='properties', cmap='inferno_r', alpha=0.8, edgecolor='black')\nax[2].set_title(\"Total Properties\")\nax[2].set_axis_off()","05326465":"\n# Create a map.\ndef print_map(centerX, centerY, title=None, \n              df=None, radius=6000, zoom=14, \n              height=8, width=8, markersize=10, \n              legend=False, ax=None, axis=False, \n              column=None, color=\"blue\", tiles=False, \n              cmap=\"inferno_r\", marker='o', epsg=3857, \n              legend_label=''):\n    \"\"\"Print a map in a figure\n    \n    Prints a map in a figure\/axis\n\n    Parameters\n    ----------\n    centerx : float\n        The X coordinate for the center of the map.\n    centery : float\n        The Y coordinate for the center of the map.\n    title : str, optional\n        A string to be used as a title for the map.\n    df : pandas.DataFame, optional\n        Pandas DataFrame to be used as data for plotting.\n    radius : int, optional\n        Coordinate radius around the center to be show\n        in the map. Notice this measure will be in whichever\n        coordinate system your map is.\n    zoom : int\n        A level of zoom to be used when getting the tiles.\n    height : int, optional\n        If no set axis are provided, this will be used\n        to create the figure and axis.\n    width : int, optional\n        If no set axis are provided, this will be used\n        to create the figure and axis.\n    markersize : int, optional\n        When displaying data, this will be used for the\n        size of the data points.\n    legend : bool, optional\n        Choose whether to show a legend or not.\n    ax : `.axes.Axes` object, optional\n        Single `~matplotlib.axes.Axes` object to be\n        used when plotting the map.\n    axis : bool, optional\n        Choose if showing the axis values.\n    column : str, optional\n        A sequence of column identifiers to plot.\n    color : str, optional\n        `~matplotlib.colors.Colormap` instance, or \n        the name of a registered colormap.\n    tile : bool, optional\n        Choose if showing tiles map as background.\n    cmap : str, optional\n        `~matplotlib.colors.Colormap` instance, or \n        the name of a registered colormap.\n    marker : str, optional\n        `~matplotlib.markers`, or the name of a registered maker.\n        https:\/\/matplotlib.org\/_modules\/matplotlib\/markers.html#MarkerStyle\n    epsg : str, optional\n        Coordinate system EPSG indentifier.\n    legend_label : str, optional\n        Text to be displayed as the title of the legend.\n    \"\"\"\n    \n    if ax is None:\n        fig, ax = plt.subplots(figsize=(height,width))\n    \n    if df is not None:\n        if column is None:\n            df.to_crs(epsg=epsg).plot(\n                ax=ax, markersize=markersize, \n                marker=marker, color=color)\n        else:\n            df.to_crs(epsg=epsg).plot(\n                ax=ax, markersize=markersize,\n                marker=marker, column=column, cmap=cmap)\n    \n    ax.set_xlim((centerX-radius), (centerX+radius))\n    ax.set_ylim((centerY-radius), (centerY+radius))\n    \n    if not axis:\n        ax.set_axis_off()\n    \n    # Add a color bar legend.\n    if legend and column and df is not None:\n        cax = fig.add_axes([1, 0.5, 0.01, 0.2])\n        sm = plt.cm.ScalarMappable(\n            cmap=cmap, \n            norm=plt.Normalize(\n                vmin=df[column].min(), \n                vmax=df[column].max()))\n        sm._A = []\n        cbar = fig.colorbar(sm, cax=cax,)\n        cbar.set_label(legend_label)\n        cbar.ax.tick_params(labelsize=10)\n    \n    if title is not None:\n        ax.set_title(title)\n    \n    if tiles:\n        tile_url = 'http:\/\/services.arcgisonline.com\/arcgis\/rest\/services\/Canvas\/World_Light_Gray_Base\/MapServer\/tile\/{z}\/{y}\/{x}'\n        add_basemap(ax, zoom, url=tile_url)\n\n        \ndef add_basemap(ax, zoom, url='http:\/\/tile.stamen.com\/terrain\/tileZ\/tileX\/tileY.png'):\n    \"\"\"Add tiles basemap.\n    \n    Adds a background map using tiles.\n\n    Parameters\n    ----------\n    ax : `.axes.Axes` object or array of Axes objects.\n        *ax* can be either a single `~matplotlib.axes.Axes` object or an\n        array of Axes objects if more than one subplot was created.  The\n        dimensions of the resulting array can be controlled with the squeeze\n        keyword, see above.\n    zoom : int\n        A level of zoom to be used when getting the tiles.\n    url :  str, optional\n        The tile url to be used to get the tiles.\n    \"\"\"\n    xmin, xmax, ymin, ymax = ax.axis()\n    basemap, extent = ctx.bounds2img(xmin, ymin, xmax, ymax, zoom=zoom, url=url)\n    ax.imshow(basemap, extent=extent, interpolation='bilinear')\n    ax.axis((xmin, xmax, ymin, ymax))","0c15d3c8":"f, ax = plt.subplots(figsize=(15,15), subplot_kw=dict(aspect='equal'))\n\nprint_map(545234.877387, 6867523.024796, ax=ax, df=gdf, column='rent_per_area', title=\"Amsterdam\", tiles=True)\n\ncax = f.add_axes([1, 0.5, 0.01, 0.2])\nsm = plt.cm.ScalarMappable(cmap='inferno_r', norm=plt.Normalize(vmin=df['rent_per_area'].min(), vmax=df['rent_per_area'].max()))\nsm._A = []\ncbar = f.colorbar(sm, cax=cax,)\ncbar.set_label('\\nPrice per $m^2$ $(\u20ac\/m^2)$')\ncbar.ax.tick_params(labelsize=10)","e64bbe4d":"## Introduction\n\nFollowing my previous notebook [Starter: Netherlands Rent Properties](https:\/\/www.kaggle.com\/juangesino\/starter-netherlands-rent-properties), I wanted to provide a notebook that shows how to handle the geographical data inside my [Netherlands Rent Properties](https:\/\/www.kaggle.com\/juangesino\/netherlands-rent-properties) dataset.\n\nBear in mind that this will not be the full extent of what can be done with this dataset, there's a lot more to do, but I want to show how to get started.","fb24e95e":"I have downloaded a shape for the map of the Netherlands from [this](https:\/\/www.imergis.nl\/htm\/opendata.htm) site. The one I used is \"Boundaries GGD regions\" it is in `gpkg` Geopackage format and uses the `EPSG: 28992` coordinate system.\n\n*Source: Jan-Willem van Aalst - www.imergis.nl*","de06aff9":"Last but not least, we can use a tiles services to ovrelay our data in some tile maps. To do so, I wrote some very simple helper functions.","92a31397":"We can iterate the polygons in the map of the Netherlands and assign each of them 3 new properties:\n\n- Number of properties in this area\n- Average rental price in this area\n- Average rental price per square meter in this area","516f88d0":"There are extremely big outliers that we should handle, for demonstration purposes, let's get rid of these big outliers.","966d7416":"## Geo Data\n\nNow we can explore the geographical contents of the data. First, we need to prepare the data for geographical analysis. We can create a GeoPandas' DataFrame. Notice that we will be using the coordinate system `EPSG: 4326`. Later on, we can project the maps whenever we are plotting so as to match the data.","ef7f29fe":"## Import Data\n\nWe'll start the same way I did in my previous notebook, by importing the dataset","c1aa6ba3":"## Clean Data\n\nIn order to clean and properly format the data, I'll simply copy the functions I used in my previous notebook and use them in my pipeline"}}