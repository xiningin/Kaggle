{"cell_type":{"222af21d":"code","e0cea024":"code","e0493746":"code","4138c377":"code","af9f3c87":"code","45e5e48f":"code","06ff6061":"code","e4ae15bf":"code","fdce76b4":"code","b337b5f2":"code","4f95f81a":"code","315a08c7":"code","9b166345":"code","064a8274":"code","60e2d331":"code","f33713d2":"code","7104e3bd":"code","264d73e5":"code","041c42e7":"code","fbc3111e":"code","ff2f86d8":"code","50af513d":"code","643d0f9a":"code","93c0b344":"code","3231b1b6":"code","4c0284ef":"code","e2ce8792":"code","43e697a4":"code","7e6612cb":"code","206a110f":"code","ef68bf42":"code","a4f8d8c2":"code","cfae0246":"code","5ca2c4fa":"code","ce30f55b":"code","4fa2cc2e":"code","263c92f7":"code","27031309":"code","99bd12ba":"code","9d709536":"code","c9fb36b8":"code","dc76d24d":"code","c80e5fd4":"code","0094d142":"code","d3e1ed01":"code","52cb1c52":"markdown","0c03e82e":"markdown","2c0618ce":"markdown","65137d00":"markdown","b2a642d0":"markdown","de205a39":"markdown","6c901b93":"markdown","3d6779c0":"markdown","e014c488":"markdown","d47288d0":"markdown","13dfa46c":"markdown","e0cfa955":"markdown","e8ff7474":"markdown","3bd250b2":"markdown","ea96b9d0":"markdown","c7de2bde":"markdown","459a9cc8":"markdown","e4738475":"markdown","d39f03db":"markdown","dcfb327c":"markdown","ef54dd2a":"markdown","d20f2470":"markdown","955bf1c3":"markdown","6463423f":"markdown","c7378b70":"markdown","ae6d152a":"markdown","987b1d5d":"markdown","20237290":"markdown","653b09ce":"markdown","1004d96d":"markdown","19a299b0":"markdown","615fa79e":"markdown","cf8127c5":"markdown","c5e769b4":"markdown","193396a4":"markdown","73632711":"markdown","779de1bc":"markdown","1e2e2cd6":"markdown","82acfc90":"markdown"},"source":{"222af21d":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas_profiling as pp\nimport warnings\nwarnings.filterwarnings('ignore')","e0cea024":"df = pd.read_csv(\"..\/input\/german-credit-risk\/german_credit.csv\", sep=\",\")","e0493746":"df.head()","4138c377":"df.isnull().values.any()","af9f3c87":"df.info()","45e5e48f":"import plotly.offline as py \npy.init_notebook_mode(connected=True) \nimport plotly.graph_objs as go \nimport plotly.tools as tls\nimport warnings \nfrom collections import Counter \n\ncredit1 = go.Bar(x = df[df[\"Creditability\"]== 1][\"Creditability\"].value_counts().index.values,\n                y = df[df[\"Creditability\"]== 1][\"Creditability\"].value_counts().values, name='Adimplentes')\n\ncredit0 = go.Bar(x = df[df[\"Creditability\"]== 0][\"Creditability\"].value_counts().index.values,\n                y = df[df[\"Creditability\"]== 0][\"Creditability\"].value_counts().values, name='Inadimplentes')\n\ndata = [credit1, credit0]\n\nlayout = go.Layout()\n\nlayout = go.Layout(yaxis=dict(title='Quantidade'),xaxis=dict(title='Vari\u00e1vel Classe'),title='Distribui\u00e7\u00e3o da Vari\u00e1vel Classe', xaxis_type='category')\n\nfig = go.Figure(data=data, layout=layout)\n\npy.iplot(fig, filename='grouped-bar')","06ff6061":"df_good = df.loc[df[\"Creditability\"] == 1]['Age (years)'].values.tolist()\ndf_bad = df.loc[df[\"Creditability\"] == 0]['Age (years)'].values.tolist()\ndf_age = df['Age (years)'].values.tolist()\n\n#plot 1\ncredit1 = go.Histogram(x=df_good, histnorm='percent', name=\"Adimplentes\")\n\n#plot 2\ncredit0 = go.Histogram(x=df_bad, histnorm='percent', name=\"Inadimplentes\")\n\n#plot 3\ncreditT = go.Histogram(x=df_age, histnorm='percent', name=\"Geral\")\n\n#Grid\nfig = tls.make_subplots(rows=2, cols=2, specs=[[{}, {}], [{'colspan': 2}, None]],\n                          subplot_titles=('Adimplentes','Inadimplentes', 'Geral'))\n\n#Figs\nfig.append_trace(credit1, 1, 1)\nfig.append_trace(credit0, 1, 2)\nfig.append_trace(creditT, 2, 1)\n\nfig['layout'].update(showlegend=True, title='Distribui\u00e7\u00e3o Idade %', bargap=0.05)\npy.iplot(fig)","e4ae15bf":"print ('Adimplente % ',round(df['Creditability'].value_counts()[1]\/len(df)*100,2))\nprint ()\nprint (df['Credit Amount'][df.Creditability == 1].describe().round(2))\nprint ()\nprint ()\nprint ('Inadimplente % ',round(df['Creditability'].value_counts()[0]\/len(df)*100,2))\nprint ()\nprint (df['Credit Amount'][df.Creditability == 0].describe().round(2))","fdce76b4":"ax = sns.boxplot(x=\"Creditability\", y=\"Credit Amount\", data=df, order=[1, 0])\nplt.xlabel('1: Adimplente       0: Inadimplente')\nplt.gcf().set_size_inches(12, 8)","b337b5f2":"plt.figure(figsize=(14,12))\nsns.heatmap(df.astype(float).corr(),linewidths=0.1,vmax=1.0, \n            square=True,  linecolor='white', annot=True)\nplt.show()","4f95f81a":"credit1 = go.Bar(x = df[df[\"Creditability\"]== 1][\"Type of apartment\"].value_counts().index.values,\n                 y = df[df[\"Creditability\"]== 1][\"Type of apartment\"].value_counts().values, name='Adimplente')\n\ncredit0 = go.Bar(x = df[df[\"Creditability\"]== 0][\"Type of apartment\"].value_counts().index.values,\n                 y = df[df[\"Creditability\"]== 0][\"Type of apartment\"].value_counts().values, name=\"Inadimplente\")\n\ndata = [credit1, credit0]\n\nlayout = go.Layout(title='Moradia')\n\nfig = go.Figure(data=data, layout=layout)\n\nfig.update_xaxes (ticktext = [ \"Alugada\" ,  \"Pr\u00f3pria\" ,  \"Outras\"],\n                  tickvals = [\"1\", \"2\", \"3\"])\n\npy.iplot(fig)","315a08c7":"prf = pp.ProfileReport(df)\nprf","9b166345":"feature_names = df.iloc[:, 1:21].columns\ntarget = df.iloc[:1, 0:1].columns\n\ndata_features = df[feature_names]\ndata_target = df[target]","064a8274":"feature_names","60e2d331":"target","f33713d2":"import numpy as np\n\nfrom sklearn.model_selection import train_test_split\nnp.random.seed(123)\nX_train, X_test, y_train, y_test = train_test_split(data_features, data_target, \n                                                    train_size = 0.70, test_size = 0.30, random_state = 1)","7104e3bd":"from sklearn.ensemble import RandomForestClassifier \n\nrf = RandomForestClassifier()","264d73e5":"rf.fit(X_train, y_train) ","041c42e7":"def PrintStats(cmat, y_test, pred):\n    tpos = cmat[0][0]\n    fneg = cmat[1][1]\n    fpos = cmat[0][1]\n    tneg = cmat[1][0]","fbc3111e":"def RunModel(model, X_train, y_train, X_test, y_test):\n    model.fit(X_train, y_train.values.ravel())\n    pred = model.predict(X_test)\n    matrix = confusion_matrix(y_test, pred)\n    return matrix, pred","ff2f86d8":"from sklearn.metrics import accuracy_score, confusion_matrix, classification_report, roc_auc_score, roc_curve\nimport scikitplot as skplt","50af513d":"cmat, pred = RunModel(rf, X_train, y_train, X_test, y_test)","643d0f9a":"import scikitplot as skplt\nskplt.metrics.plot_confusion_matrix(y_test, pred)","93c0b344":"accuracy_score(y_test, pred)","3231b1b6":"print (classification_report(y_test, pred))","4c0284ef":"bad_records = len(df[df.Creditability == 0]) \nbad_indices = df[df.Creditability == 0].index\ngood_indices = df[df.Creditability == 1].index\n\nunder_sample_indices = np.random.choice(good_indices, bad_records, False)\ndf_undersampled = df.iloc[np.concatenate([bad_indices, under_sample_indices]),:]\nX_undersampled = df_undersampled.iloc[:,1:21]\nY_undersampled = df_undersampled.Creditability\nX_undersampled_train, X_undersampled_test, Y_undersampled_train, Y_undersampled_test = train_test_split(X_undersampled, Y_undersampled, test_size = 0.30)","e2ce8792":"rf_undersampled = RandomForestClassifier() \ncmat, pred = RunModel(rf_undersampled, X_undersampled_train, Y_undersampled_train, X_undersampled_test, Y_undersampled_test)\nPrintStats(cmat, Y_undersampled_test, pred)","43e697a4":"skplt.metrics.plot_confusion_matrix(Y_undersampled_test, pred)","7e6612cb":"accuracy_score(Y_undersampled_test, pred)","206a110f":"print (classification_report(Y_undersampled_test, pred))","ef68bf42":"rf = RandomForestClassifier()\ncmat, pred = RunModel(rf, X_undersampled_train, Y_undersampled_train, X_test, y_test)\nPrintStats(cmat, y_test, pred)","a4f8d8c2":"skplt.metrics.plot_confusion_matrix(y_test, pred)","cfae0246":"accuracy_score(y_test, pred)","5ca2c4fa":"from sklearn.metrics import classification_report\nprint (classification_report(y_test, pred))","ce30f55b":"from sklearn.model_selection import GridSearchCV","4fa2cc2e":"param_grid = {\"criterion\": ['entropy', 'gini'],\n              \"n_estimators\": [25, 50, 75],\n              \"n_jobs\": [1, 2, 3, 4],\n              \"max_features\": ['auto', 0.1, 0.2, 0.3]}\n\ngrid_search_rf = GridSearchCV(rf, param_grid, scoring=\"precision\")\ngrid_search_rf.fit(y_test, pred)\n\nrf = grid_search_rf.best_estimator_ \ngrid_search_rf.best_params_, grid_search_rf.best_score_","263c92f7":"rf_undersampled = RandomForestClassifier(criterion = 'entropy', max_features = 'auto', n_estimators = 25, n_jobs = 1)\ncmat, pred = RunModel(rf_undersampled, X_undersampled_train, Y_undersampled_train, X_undersampled_test, Y_undersampled_test)\nPrintStats(cmat, Y_undersampled_test, pred)","27031309":"skplt.metrics.plot_confusion_matrix(Y_undersampled_test, pred)","99bd12ba":"accuracy_score(Y_undersampled_test, pred)","9d709536":"print (classification_report(Y_undersampled_test, pred))","c9fb36b8":"cmat, pred = RunModel(rf, X_undersampled_train, Y_undersampled_train, X_test, y_test)\nPrintStats(cmat, y_test, pred)","dc76d24d":"skplt.metrics.plot_confusion_matrix(y_test, pred)","c80e5fd4":"accuracy_score(y_test, pred)","0094d142":"print (classification_report(y_test, pred))","d3e1ed01":"from sklearn import metrics   \n\nclf = RandomForestClassifier(criterion='entropy', n_estimators = 25, n_jobs = 1, max_features='auto')\nclf.fit(X_train, y_train)\n\ny_pred_probability = clf.predict_proba(X_test)[::,1]\nfpr, tpr, _ = metrics.roc_curve(y_test, y_pred_probability)\nauc = metrics.roc_auc_score(y_test, pred)\nplt.plot(fpr,tpr,label=\"RandomForest, auc=\"+str(auc))\nplt.legend(loc=4)\nplt.show()","52cb1c52":"Aplicando o novo modelo para os dados de teste originais, a acur\u00e1cia aumentou para 83%, o recall para clientes adimplentes atingiu 78%, e para os inadimplentes aumentou consideravelmente para 92%!","0c03e82e":"### Descri\u00e7\u00e3o dos \u00edtens e categorias","2c0618ce":"### Aplicando a fun\u00e7\u00e3o RunModel para treinar o modelo e gerar previs\u00f5es em rela\u00e7\u00e3o aos dados de teste\n\nA fun\u00e7\u00e3o RunModel toma como entrada o modelo n\u00e3o treinado junto com todos os dados de teste e treinamento, incluindo r\u00f3tulos. Ele treina o modelo, executa a previs\u00e3o usando os dados de teste e retorna a matriz de confus\u00e3o juntamente com os r\u00f3tulos previstos.","65137d00":"### Utilizando o \"novo\" classificador para os dados balanceados - Random Forest","b2a642d0":"### Importando Bibliotecas Principais","de205a39":"O GridSearchCV \u00e9 um recurso da biblioteca Scikit-learn que nos ajuda a encontrar os melhores par\u00e2metros para o modelo.","6c901b93":"### Verificando o tipo de dado de cada coluna","3d6779c0":"### Utilizando o \"novo\" classificador para os dados de teste originais","e014c488":"### Undersampling","d47288d0":"![image.png](attachment:image.png)","13dfa46c":"## An\u00e1lise dos Dados de Cr\u00e9ditos Alem\u00e3es","e0cfa955":"### Construindo o modelo Random Forest","e8ff7474":"A curva \"ROC\" \u00e9 uma curva de probabilidade que mostra o quanto o classificador consegue distinguir entre duas coisas, atrav\u00e9s de dois par\u00e2metros: a taxa verdadeiro-positivo contra a taxa de falsos-positivos, ou seja, o n\u00famero de vezes que o classificador acertou a predi\u00e7\u00e3o contra o n\u00famero de vezes que o classificador errou a predi\u00e7\u00e3o.\n\nO \"AUC\" \u00e9 derivada da curva \"ROC\" e representa o grau ou medida de separabilidade. A AUC resume a curva ROC num \u00fanico valor, calculando a \u201c\u00e1rea sob a curva\u201d. Quanto maior o AUC melhor o modelo est\u00e1 em prever 0s como 0s e 1s como 1s. Neste caso, quanto maior a AUC melhor o modelo est\u00e1 em distinguir entre transa\u00e7\u00f5es de cr\u00e9ditos ruins de cr\u00e9ditos bons. O valor do AUC varia de 0,0 at\u00e9 1,0.\n\nUm modelo excelente tem AUC pr\u00f3ximo ao 1, o que significa que tem boa medida de separabilidade. Um modelo pobre tem AUC pr\u00f3ximo do 0, o que significa que tem a pior medida de separabilidade, ou seja, est\u00e1 prevendo 0s como 1s e 1s como 0s. E quando a AUC \u00e9 0,5, significa que o modelo n\u00e3o tem capacidade de separa\u00e7\u00e3o de classe.","3bd250b2":"### Pandas Profiling","ea96b9d0":"### GridSearchCV - Otimiza\u00e7\u00e3o de Par\u00e2metros - Random Forest","c7de2bde":"![image.png](attachment:image.png)","459a9cc8":"Podemos facilitar o processo de an\u00e1lise de dados utilizando o pandas profiling, que \u00e9 uma ferramenta capaz de gerar um relat\u00f3rio html com v\u00e1rias informa\u00e7\u00f5es estat\u00edsticas e as principais caracter\u00edsticas do dataframe em apenas uma linha de c\u00f3digo.","e4738475":"### Informa\u00e7\u00f5es estat\u00edsticas sobre a vari\u00e1vel target \"Creditability\"","d39f03db":"Este dataset cont\u00e9m ao todo a classifica\u00e7\u00e3o de cr\u00e9dito de 1000 clientes em um banco alem\u00e3o. Associado a cada cliente existem 20 vari\u00e1veis mais a vari\u00e1vel classe (Target), com a classifica\u00e7\u00e3o hist\u00f3rica de 700 clientes como adimplentes e 300 como idadimplentes. \n\nOs clientes adimplentes receberam o r\u00f3tulo de classifica\u00e7\u00e3o \u201c1\u201d, na vari\u00e1vel resposta classe, e os clientes inadimplentes receberam o r\u00f3tulo de classifica\u00e7\u00e3o \u201c0\u201d.\n\nUm ponto a se ressaltar nesta base de dados \u00e9 o fato das classes \u201c1\u201d e \u201c0\u201d serem desequilibradas, ou seja, a quantidade de clientes adimplentes, \u00e9 muito maior em rela\u00e7\u00e3o aos clientes inadimplentes. Grandes diferen\u00e7as entre as rela\u00e7\u00f5es de adimplentes x inadimplentes tendem a impactar o desempenho dos modelos de classifica\u00e7\u00e3o, com vi\u00e9s para a classe majorit\u00e1ria. \n\nUma das abordagens mais utilizadas \u00e9 o de balancear artificialmente o conjunto de dados: ou retirando exemplos aleat\u00f3rios da classe majorit\u00e1ria (undersampling) ou acrescentando exemplos artificiais para a classe minorit\u00e1ria (oversampling). \n\nNeste estudo, foi utilizada a t\u00e9cnica de retirar aleatoriamente exemplos da classe majorit\u00e1ria.","dcfb327c":"### Utilizando o \"novo\" classificador para os dados de teste originais ","ef54dd2a":"Este primeiro modelo atingiu uma acur\u00e1cia de 76% e foi capaz de identificar corretamente 89% dos clientes adimplentes (ver recall), mas apenas 44% dos clientes inadimplentes.","d20f2470":"### Verificando a presen\u00e7a de valores nulos","955bf1c3":"Neste caso, vamos utilizar a t\u00e9cnica de undersampling para obter uma divis\u00e3o uniforme entre clientes adimplentes e inadimplentes. Isso tornar\u00e1 o conjunto de treinamento pequeno, mas com dados suficientes para gerar um bom classificador.","6463423f":"Matriz de Confus\u00e3o - Utilizando a fun\u00e7\u00e3o PrintStats para compilar e exibir os resultados do modelo.\nA Matriz de confus\u00e3o \u00e9 basicamente uma matriz com valores reais e valores preditos pelo classificador utilizado, onde podemos avaliar o desempenho do algor\u00edtmo.\n\nO PrintStats toma como par\u00e2metros uma matriz de confus\u00e3o, r\u00f3tulos de teste e r\u00f3tulos de previs\u00e3o e separa a matriz de confus\u00e3o em suas partes constituintes.","c7378b70":"### Medi\u00e7\u00e3o de desempenho do modelo atrav\u00e9s da curva ROC e AUC","ae6d152a":"#### Podemos observar uma correla\u00e7\u00e3o positiva entre \"Credit amount\" e \"Duration of Credit\" de 0.62","987b1d5d":"O modelo gerado atingiu uma auc de 86,58%.","20237290":"### Gr\u00e1fico da vari\u00e1vel target Creditability","653b09ce":"Com o conjunto de dados definido, dividimos os dados em conjuntos de treinamento e teste, importando a fun\u00e7\u00e3o train_test_split.\n\nA fun\u00e7\u00e3o train_test_split usa um randomizador para separar os dados em conjuntos de treinamento e teste. Neste caso, foram definidos 70% dos dados para treinamento e 30% para testes.\n\nA semente aleat\u00f3ria (np.random.seed), \u00e9 utilizada para garantir que os mesmos dados sejam usados em todas as execu\u00e7\u00f5es.","1004d96d":"Com a otimiza\u00e7\u00e3o de alguns par\u00e2metros o modelo agora atingiu uma acur\u00e1cia de 84%, o recall para clientes adimplentes aumentou para 81% e para clientes inadimplentes se manteve em 92%.","19a299b0":"### Heatmap","615fa79e":"O modelo atingiu uma acur\u00e1cia de 71% e apesar de identificar corretamente apenas 61% dos clientes adimplentes, a capacidade de identificar os inadimplentes subiu para 80%.","cf8127c5":"### Treinando o modelo","c5e769b4":"Com as fun\u00e7\u00f5es PrintStats e RunModel criadas, criamos um modelo para fazer a detec\u00e7\u00e3o de clientes inadimplentes. A detec\u00e7\u00e3o de risco de cr\u00e9dito \u00e9 geralmente considerada um problema de duas classes, neste caso espec\u00edfico:\n\nClasse 1: Clientes Inadimplentes (Em nossa vari\u00e1vel target representada por \"0\")\n\nOu\n\nClasse 2: Clientes Adimplentes (Em nossa vari\u00e1vel target representada por \"1\")\n\nO objetivo aqui \u00e9 tentar determinar a qual classe uma transa\u00e7\u00e3o espec\u00edfica pertence.","193396a4":"### Gr\u00e1ficos Age x Creditability","73632711":"Acima podemos observar os par\u00e2metros padr\u00e3o que ser\u00e3o utilizados para a constru\u00e7\u00e3o do modelo.","779de1bc":"### GridSearchCV - Otimiza\u00e7\u00e3o de Par\u00e2metros - Regress\u00e3o Log\u00edstica","1e2e2cd6":"### Separa\u00e7\u00e3o das vari\u00e1veis de entrada da vari\u00e1vel alvo (target)","82acfc90":"### Matriz de Confus\u00e3o - Utilizando a fun\u00e7\u00e3o PrintStats para compilar e exibir os resultados do modelo."}}