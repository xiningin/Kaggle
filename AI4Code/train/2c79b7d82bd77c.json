{"cell_type":{"bb85d94a":"code","5dc8ca60":"code","b8102f73":"code","38283d04":"code","356a09f0":"code","1a038cc9":"code","03e71162":"code","39e1bbb9":"code","dc203869":"code","01d0efa8":"code","30564b5f":"code","07c3e9c3":"code","068b95f2":"code","20cdda81":"code","640ab348":"code","b1e0d60d":"code","66eefe42":"code","bf3a9510":"markdown","f72954ef":"markdown","1c62e858":"markdown","25360151":"markdown","fe67b0b1":"markdown","c29f7b8b":"markdown","2e67856c":"markdown","5012b87e":"markdown","abeca00c":"markdown","4687d8b6":"markdown","c7a0912c":"markdown","d427fbdf":"markdown","57a34804":"markdown","48896ce4":"markdown","99886b43":"markdown"},"source":{"bb85d94a":"# -- Helps us create paths to directories\nimport os\n\n# -- Data Processing\nimport numpy as np\nimport pandas as pd\n\n# -- Plotting libraries\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# -- Extra bits for plotting\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom matplotlib.ticker import MultipleLocator, AutoMinorLocator\nimport itertools\nimport math\n","5dc8ca60":"# -- Load pokemon.csv and review what columns are available\npoke_df = pd.read_csv('..\/input\/pokemon\/pokemon.csv')\npoke_df.columns","b8102f73":"# -- We want to create a new column called 'sprite_url' which links\n# -- the individual pokemon data to a png image located in the\n# -- pokemon-ruby-sapphire-sprites dataset\n\n# -- Declare the sprites filepath and create a list of all images that end with .png (we don't want jpegs).\n# -- Note that the file names in this dir is the pokedex_number of that sprite.\nsprites_dir = '..\/input\/pokemon-ruby-sapphire-sprites\/ruby-sapphire'\nsprites_png_list = [name for name in os.listdir(sprites_dir) if name.endswith('.png')]\n\n# -- This function takes a pokedex_number as an argument, then matches it to available sprites in the sprites dir.\n# -- This is because not all pokemon in our dataset have an image in the sprites dir (basically, up to generation III).\n# -- If a match is found, the function returns a complete path to that png as a string.\ndef match_sprite_png(pokedex_number):\n    if f\"{str(pokedex_number)}.png\" in sprites_png_list:\n        return os.path.join(sprites_dir, f\"{str(pokedex_number)}.png\")\n    return None\n\n# -- Create a new column called 'sprite_url' and then apply the match_sprite_png() function.\n# -- Afterwards, filter out all 'sprite_url' null rows.\npoke_df['sprite_url'] = poke_df['pokedex_number'].map(lambda x: match_sprite_png(x))\npoke_df = poke_df.loc[poke_df['sprite_url'].notnull()]","38283d04":"# -- We're declaring this as a class as it's more convenient since we'll be reusing\n# -- this specific plot ALOT. This class also includes functions to define the\n# -- gridlines to apply to the plot.\n\nclass Pokeplot_linear:\n    \n    def __init__(self,\n                 data=poke_df,\n                 x_var='defense',\n                 y_var='attack',\n                 axis_max=0,\n                 fig=None,\n                 ax=None):\n        \n        \"\"\"Takes a DataFrame of pokemon data and produces a scatterplot of the given\n        x and y variables. Each point of the plot will be supplmenented by a png of\n        the subject pokemon.\n        \n        \n        Args:\n            data (pd.DataFrame): (default=poke_df)\n            x_var (str): (default='defense')\n            y_var (str): (default='attack')\n            axis_max (int): (optional) \n            fig (plt.Figure): (optional) \n            ax (plt.Axes): (optional) \n        \n        Returns:\n            None\n        \"\"\"\n        \n        if fig and ax:\n            self.fig = fig\n            self.ax = ax\n        else:\n            self.fig, self.ax = plt.subplots(figsize=(12, 12))\n        \n        self.fig.set_facecolor('white')\n        \n        self.data = data\n        self.x_var = x_var\n        self.y_var = y_var\n\n        sns.scatterplot(data=self.data, x=self.x_var, y=self.y_var, ax=self.ax)\n\n        x_cords = self.data[self.x_var].tolist()\n        y_cords = self.data[self.y_var].tolist()\n        url = self.data['sprite_url'].tolist()\n\n        def getImage(path):\n            arr = plt.imread(path)\n            return OffsetImage(arr)\n\n        for x0, y0, url in zip(x_cords, y_cords, url):\n            ab = AnnotationBbox(getImage(url), (x0, y0), frameon=False)\n            self.ax.add_artist(ab)\n        \n        if axis_max:\n            self.axis_max = axis_max\n            self.ax.set_xlim([0, self.axis_max])\n            self.ax.set_ylim([0, self.axis_max])\n        else:\n            self.axis_max = max(itertools.chain(x_cords, y_cords)) * 1.1\n            self.ax.set_xlim([0, self.axis_max])\n            self.ax.set_ylim([0, self.axis_max])\n\n        self.apply_grid(True)\n        \n        # -- apply a cheeky watermark\n        ax.text(x=self.axis_max*0.8, \n                y=self.axis_max*0.025, \n                s='@mattbarty',\n                alpha=0.3, \n                fontsize=17.5,\n                zorder=999)\n        \n    def apply_grid(self, standard_grid=True):\n        if standard_grid:\n            self.ax.grid(b=True, which='major', alpha=0.5, lw=1.2)\n            self.ax.xaxis.set_minor_locator(AutoMinorLocator())\n            self.ax.yaxis.set_minor_locator(AutoMinorLocator())\n            self.ax.grid(b=True, which='minor', alpha=0.25, lw=0.8)\n            self.ax.minorticks_on()\n        else:\n            self.ax.grid(b=True, which='major', alpha=0.25, lw=0.8)\n            self.ax.xaxis.set_minor_locator(AutoMinorLocator())\n            self.ax.yaxis.set_minor_locator(AutoMinorLocator())\n            self.ax.grid(b=True, which='minor', alpha=0.25, lw=0.8)\n            self.ax.minorticks_on()\n            \n    def radiance_grid(self,\n                      interval=30,\n                      focus=None,\n                      x_cord=0,\n                      y_cord=0,\n                      standard_grid=False):\n        self.apply_grid(standard_grid)\n        lw = 1.2\n        ls = '--'\n        c = 'grey'\n        alpha = 0.75\n\n        if focus:\n            xcord_idx = self.data['name'].tolist().index(focus)\n            x_cord = self.data[self.x_var].tolist()[xcord_idx]\n            y_cord = self.data[self.y_var].tolist()[xcord_idx]\n\n        for i in range((math.ceil(self.axis_max \/ interval)) * 2):\n            circle = plt.Circle(xy=(x_cord, y_cord),\n                                radius=(interval) * (i + 1),\n                                color=c,\n                                lw=lw,\n                                ls=ls,\n                                alpha=alpha,\n                                fill=False)\n            self.ax.add_patch(circle)\n\n    def ratio_grid(self, segments=4, standard_grid=False):\n        self.apply_grid(standard_grid)\n        lw = 1.2\n        ls = '--'\n        c = 'grey'\n        alpha = 0.75\n\n        self.ax.plot([0, self.axis_max], [0, self.axis_max],\n                     lw=lw,\n                     ls=ls,\n                     c=c,\n                     alpha=alpha)\n\n        for y in range(segments):\n            y_cord = self.axis_max * (1 - (1 \/ segments) * (y + 1))\n            self.ax.plot([0, self.axis_max], [0, y_cord],\n                         lw=lw,\n                         ls=ls,\n                         c=c,\n                         alpha=alpha)\n        for x in range(segments):\n            x_cord = self.axis_max * (1 - (1 \/ segments) * (x + 1))\n            self.ax.plot([0, x_cord], [0, self.axis_max],\n                         lw=lw,\n                         ls=ls,\n                         c=c,\n                         alpha=alpha)\n\n    def power_bracket_grid(self, interval=50, standard_grid=False):\n        self.apply_grid(standard_grid)\n        lw = 1.2\n        ls = '--'\n        c = 'grey'\n        alpha = 0.75\n\n        for i in range((math.ceil(self.axis_max \/ interval)) * 2):\n            self.ax.plot([0, interval * (i + 1)], [interval * (i + 1), 0],\n                         lw=lw,\n                         ls=ls,\n                         c=c,\n                         alpha=alpha)","356a09f0":"fig, ax = plt.subplots(1, 2, figsize=(24, 12))\n\n# -- Non-sprites plot\nsns.scatterplot(data=poke_df, x='defense', y='attack', ax=ax[0])\nax[0].set_title('All Pokemon (non-sprite)', fontsize=25)\n\nx_cords = poke_df['defense'].tolist()\ny_cords = poke_df['attack'].tolist()\n\naxis_max = max(itertools.chain(x_cords, y_cords)) * 1.1\nax[0].set_xlim([0, axis_max])\nax[0].set_ylim([0, axis_max])\n\nax[0].grid(b=True, which='major', alpha=0.5, lw=1.2)\nax[0].xaxis.set_minor_locator(AutoMinorLocator())\nax[0].yaxis.set_minor_locator(AutoMinorLocator())\nax[0].grid(b=True, which='minor', alpha=0.25, lw=0.8)\nax[0].minorticks_on()\n\n# -- Sprites plot\np1 = Pokeplot_linear(ax=ax[1], fig=fig)\np1.ax.set_title(label='All Pokemon (with sprites!)', fontsize=25);","1a038cc9":"# -- We'll be isolating the starter Pokemon from generation 1 for these examples\ng1_starter_df = poke_df.copy().loc[(poke_df['pokedex_number'].isin([1, 2, 3, 4, 5, 6, 7, 8, 9]))]","03e71162":"fig, ax = plt.subplots(1, 3, figsize=(36, 12))\n\nfig.suptitle(\"Grid Types\", fontsize=50)\n\np1 = Pokeplot_linear(data=g1_starter_df, ax=ax[0], fig=fig)\np1.ratio_grid()\np1.ax.set_title('Ratio Grid', fontsize=25)\n\np2 = Pokeplot_linear(data=g1_starter_df, ax=ax[1], fig=fig)\np2.power_bracket_grid()\np2.ax.set_title('Power Bracket Grid', fontsize=25)\n\np3 = Pokeplot_linear(data=g1_starter_df, ax=ax[2], fig=fig)\np3.radiance_grid()\np3.ax.set_title('Radiance Grid', fontsize=25);","39e1bbb9":"fig, ax = plt.subplots(1, 3, figsize=(36, 12))\n\nfig.suptitle(\"Ratio Grid x Segment\", fontsize=50)\n\np1 = Pokeplot_linear(data=g1_starter_df, ax=ax[0], fig=fig)\np1.ratio_grid(1)\np1.ax.set_title('Ratio Grid (Segment Ratio=1)', fontsize=25)\n\np2 = Pokeplot_linear(data=g1_starter_df, ax=ax[1], fig=fig)\np2.ratio_grid(4)\np2.ax.set_title('Ratio Grid (Segment Ratio=0.25)', fontsize=25)\n\np3 = Pokeplot_linear(data=g1_starter_df, ax=ax[2], fig=fig)\np3.ratio_grid(10)\np3.ax.set_title('Ratio Grid (Segment Ratio=0.1)', fontsize=25);","dc203869":"fig, ax = plt.subplots(1, 3, figsize=(36, 12))\n\nfig.suptitle(\"Power Bracket Grid x Interval\", fontsize=50)\n\np1 = Pokeplot_linear(data=g1_starter_df, ax=ax[0], fig=fig)\np1.power_bracket_grid(80)\np1.ax.set_title('Power Bracket Grid (Interval=80)', fontsize=25)\n\np2 = Pokeplot_linear(data=g1_starter_df, ax=ax[1], fig=fig)\np2.power_bracket_grid(50)\np2.ax.set_title('Power Bracket Grid (Interval=50)', fontsize=25)\n\np3 = Pokeplot_linear(data=g1_starter_df, ax=ax[2], fig=fig)\np3.power_bracket_grid(20)\np3.ax.set_title('Power Bracket Grid (Interval=20)', fontsize=25);","01d0efa8":"fig, ax = plt.subplots(1, 3, figsize=(36, 12))\n\nfig.suptitle(\"Radiance Grid x Interval\", fontsize=50)\n\np1 = Pokeplot_linear(data=g1_starter_df, ax=ax[0], fig=fig)\np1.radiance_grid(60)\np1.ax.set_title('Radiance Grid (Interval=60)', fontsize=25)\n\np2 = Pokeplot_linear(data=g1_starter_df, ax=ax[1], fig=fig)\np2.radiance_grid(30)\np2.ax.set_title('Radiance Grid (Interval=30)', fontsize=25)\n\np3 = Pokeplot_linear(data=g1_starter_df, ax=ax[2], fig=fig)\np3.radiance_grid(15)\np3.ax.set_title('Radiance Grid (Interval=15)', fontsize=25);","30564b5f":"fig, ax = plt.subplots(1, 3, figsize=(36, 12))\n\nfig.suptitle(\"Radiance Grid x Focus\", fontsize=50)\n\np1 = Pokeplot_linear(data=g1_starter_df, ax=ax[0], fig=fig)\np1.radiance_grid(15, focus='Charizard')\np1.ax.set_title('Radiance Grid (Focus = Charizard)', fontsize=25)\n\np2 = Pokeplot_linear(data=g1_starter_df, ax=ax[1], fig=fig)\np2.radiance_grid(15, focus='Venusaur')\np2.ax.set_title('Radiance Grid (Focus = Venusaur)', fontsize=25)\n\np3 = Pokeplot_linear(data=g1_starter_df, ax=ax[2], fig=fig)\np3.radiance_grid(15, focus='Squirtle')\np3.ax.set_title('Radiance Grid (Focus = Squirtle)', fontsize=25);","07c3e9c3":"# -- Declare dataframes that filter by different conditions (i.e. generation, is_legendary, pokemon types, etc.)\n\n# - Legendary Pokemon\nleg_df = poke_df.copy().loc[poke_df['is_legendary'] == True]\n\n# - Pokemon grouped by generation\ng1_df = poke_df.copy().loc[poke_df['generation'] == 1]\ng2_df = poke_df.copy().loc[poke_df['generation'] == 2]\ng3_df = poke_df.copy().loc[poke_df['generation'] == 3]\n\n# - Starter Pokemon and their evolutions grouped by generation\ng1_starter_df = poke_df.copy().loc[(poke_df['pokedex_number'].isin([1, 2, 3, 4, 5, 6, 7, 8, 9]))]\ng2_starter_df = poke_df.copy().loc[(poke_df['pokedex_number'].isin([152, 153, 154, 155, 156, 157, 158, 159, 160]))]\ng3_starter_df = poke_df.copy().loc[(poke_df['pokedex_number'].isin([252, 253, 254, 255, 256, 257, 258, 259, 260]))]\n\n# - Evolutions of Eevee\neevee_df = poke_df.copy().loc[(poke_df['pokedex_number'].isin([133, 134, 135, 136, 197, 471, 470, 196, 700]))]\n\n# - Pokemon filtered by type1 & type2\ngrass_type_df = poke_df.copy().loc[(poke_df['type1'] == 'grass') | (poke_df['type2'] == 'grass')]\nfire_type_df = poke_df.copy().loc[(poke_df['type1'] == 'fire') | (poke_df['type2'] == 'fire')]\nwater_type_df = poke_df.copy().loc[(poke_df['type1'] == 'water') | (poke_df['type2'] == 'water')]\n\n# - Wildcard pokemon-type df\npoke_type = 'poison'\ntype_df = poke_df.copy().loc[(poke_df['type1'] == poke_type) | (poke_df['type2'] == poke_type)]","068b95f2":"fig, ax = plt.subplots(1, 3, figsize=(36, 12))\n\nfig.suptitle(\"Comparing Generation Starters\", fontsize=50)\n\np1 = Pokeplot_linear(data=g1_starter_df, ax=ax[0], fig=fig, axis_max=180)\np1.ax.set_title('Gen 1 Starters', fontsize=25)\np1.power_bracket_grid(interval=50)\np1.ratio_grid(2)\n\np2 = Pokeplot_linear(data=g2_starter_df, ax=ax[1], fig=fig, axis_max=180)\np2.ax.set_title('Gen 2 Starters', fontsize=25)\np2.power_bracket_grid(interval=50)\np2.ratio_grid(2)\n\np3 = Pokeplot_linear(data=g3_starter_df, ax=ax[2], fig=fig, axis_max=180)\np3.ax.set_title('Gen 3 Starters', fontsize=25)\np3.power_bracket_grid(interval=50)\np3.ratio_grid(2)","20cdda81":"fig, ax = plt.subplots(1, 3, figsize=(36, 12))\n\nfig.suptitle(\"Comparing Generation Legendaries\", fontsize=50)\n\np1 = Pokeplot_linear(data=leg_df.loc[leg_df['generation'] == 1], ax=ax[0], fig=fig, axis_max=200)\np1.ax.set_title('Gen 1 Legendaries', fontsize=25)\np1.power_bracket_grid(interval=50)\np1.ratio_grid(2)\n\np2 = Pokeplot_linear(data=leg_df.loc[leg_df['generation'] == 2], ax=ax[1], fig=fig, axis_max=200)\np2.ax.set_title('Gen 2 Legendaries', fontsize=25)\np2.power_bracket_grid(interval=50)\np2.ratio_grid(2)\n\np3 = Pokeplot_linear(data=leg_df.loc[leg_df['generation'] == 3], ax=ax[2], fig=fig, axis_max=200)\np3.ax.set_title('Gen 3 Legendaries', fontsize=25)\np3.power_bracket_grid(interval=50)\np3.ratio_grid(2)","640ab348":"fig, ax = plt.subplots(figsize=(12, 12))\n\np1 = Pokeplot_linear(data=eevee_df, ax=ax, fig=fig)\np1.ax.set_title('Comparing Eevee Evolutions', fontsize=25)\np1.power_bracket_grid(interval=50)\np1.ratio_grid(2)","b1e0d60d":"fig, ax = plt.subplots(1, 3, figsize=(36, 12))\n\nfig.suptitle(\"Comparing Pokemon Types\", fontsize=50)\n\np1 = Pokeplot_linear(data=grass_type_df, ax=ax[0], fig=fig, axis_max=200)\np1.ax.set_title('Grass Type Pokemon', fontsize=25)\np1.power_bracket_grid(interval=50)\np1.ratio_grid(2)\n\np2 = Pokeplot_linear(data=fire_type_df, ax=ax[1], fig=fig, axis_max=200)\np2.ax.set_title('Fire Type Pokemon', fontsize=25)\np2.power_bracket_grid(interval=50)\np2.ratio_grid(2)\n\np3 = Pokeplot_linear(data=water_type_df, ax=ax[2], fig=fig, axis_max=200)\np3.ax.set_title('Water Type Pokemon', fontsize=25)\np3.power_bracket_grid(interval=50)\np3.ratio_grid(2)","66eefe42":"fig, ax = plt.subplots(3, 3, figsize=(36, 36))\n\nfig.suptitle(\"Comparing Pokemon Types\", fontsize=50)\n\nfor gen in range(3):\n    p1 = Pokeplot_linear(data=grass_type_df.loc[grass_type_df['generation'] == gen + 1], ax=ax[gen, 0], fig=fig, axis_max=200)\n    p1.ax.set_title('Grass Type Pokemon', fontsize=25)\n    p1.power_bracket_grid(interval=50)\n    p1.ratio_grid(2)\n\n    p2 = Pokeplot_linear(data=fire_type_df.loc[fire_type_df['generation'] == gen + 1], ax=ax[gen, 1], fig=fig, axis_max=200)\n    p2.ax.set_title('Fire Type Pokemon', fontsize=25)\n    p2.power_bracket_grid(interval=50)\n    p2.ratio_grid(2)\n\n    p3 = Pokeplot_linear(data=water_type_df.loc[water_type_df['generation'] == gen + 1], ax=ax[gen, 2], fig=fig, axis_max=200)\n    p3.ax.set_title('Water Type Pokemon', fontsize=25)\n    p3.power_bracket_grid(interval=50)\n    p3.ratio_grid(2)","bf3a9510":"That's it for now! :) <br>Check back later","f72954ef":"# Story Telling with Gridlines","1c62e858":"# Ratio Grid Examples","25360151":"## Grass vs. Fire vs. Water Types by Generation","fe67b0b1":"# Preamble\nThis notebook and analysis is heavily inspired by the Medium article ['Gotta Grid'em All!'](https:\/\/medium.com\/nightingale\/gotta-gridem-all-2f768048f934) by the very skilled Benoit Pimpaud.\n<br>I wanted to try my hand at adding images to plots, and re-creating many of his fantastic gridlines plots.\n<br>So this notebook goes more for a 'Data is Beautiful' vibe rather than say, 'The Lancet' - Therefore, please don't consider this anymore than a fun exploratory exercise using some pokemon data (although the results may surprise you!)","c29f7b8b":"## Grass vs. Fire vs. Water Types","2e67856c":"## Comaparing Eevee Evolutions","5012b87e":"# Non-Sprite vs. Sprite ScatterPlot","abeca00c":"## Comparing Generation Legendaries by Generation","4687d8b6":"## Comparing Starter Pokemon by Generation","c7a0912c":"# Power Bracket Grid Examples","d427fbdf":"# Radiance Grid Examples","57a34804":"# Grid Types Examples","48896ce4":"# Data Loading & Preparation","99886b43":"# Pokeplot Class"}}