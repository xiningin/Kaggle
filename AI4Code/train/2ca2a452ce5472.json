{"cell_type":{"bff430bd":"code","fb8fcc94":"code","8210a997":"code","cee5cf42":"markdown","90b5870b":"markdown","f67e6f55":"markdown"},"source":{"bff430bd":"\"\"\"\nsearch the problem space of the wooden puzzle and find all solutions\n\"\"\"\n\nimport csv\nimport logging\nimport math\nimport os\nimport sys\nfrom os.path import join\n\nimport networkx as nx\nimport numpy as np\nimport pandas as pd\nfrom PIL import Image, ImageDraw, ImageFont\n\n# DATA_DIRECTORY = 'data'\n# for kaggle use\nDATA_DIRECTORY = '..\/input\/puzzle-data'\n# TABLE_DIRECTORY = 'data'\n# for kaggle use\nTABLE_DIRECTORY = '.'\n\n\nVALIDATION_PERIMETER_VIOLATION = 'PERIMETER_VIOLATION'\nVALIDATION_OVERLAP = 'OVERLAP'\nVALIDATION_VALID = 'VALID'\nVALIDATION_COMPLETE = 'COMPLETE'\nVALIDATION_ISOLATED_SINGLE = 'ISOLATED_SINGLE'\nVALIDATION_ISOLATED_DOUBLE = 'ISOLATED_DOUBLE'\nVALIDATION_ISOLATED_TRIPLE = 'ISOLATED_TRIPLE'\nVALIDATION_ISOLATED_QUAD = 'ISOLATED_QUAD'\nVALIDATION_ISOLATED_QUINT = 'ISOLATED_QUINT'\n\nVALID_SET = {VALIDATION_VALID, VALIDATION_COMPLETE}\n\nRED = (255, 0, 0, 255)\nBLACK = (0, 0, 0, 255)\n\nUNIT_VECTORS = {'k': (1, 0),\n                'i': (1 \/ 2, math.sqrt(3) \/ 2),\n                'u': (-1 \/ 2, math.sqrt(3) \/ 2),\n                'h': (-1, 0),\n                'n': (-1 \/ 2, -math.sqrt(3) \/ 2),\n                'm': (1 \/ 2, -math.sqrt(3) \/ 2)}\n\n\ndef get_polygon_points():\n    return 6\n\n\ndef reflect_over_x_axis(matrix) -> np.ndarray:\n    \"\"\"\n    matrix is expected to be a Nx2 matrix where the first column is the x values\n    and the second column is the y values\n    \"\"\"\n    reflect_matrix = np.array([[1, 0], [0, -1]])\n    return matrix.dot(reflect_matrix)\n\n\ndef cartesian_to_canvas(canvas_size, matrix: np.ndarray, pixels_per_unit=100):\n    \"\"\"\n    pixel canvas y values move things down instead of up. This function scales\n    and converts standard cartesian coordinates to the pixel canvas style of\n    coordinates\n    \"\"\"\n    centre = (canvas_size[0] \/ 2, -canvas_size[1] \/ 2)\n    return reflect_over_x_axis(matrix * pixels_per_unit + centre)\n\n\ndef place_polygon(polygon, orientation, shift, base_angle=math.pi \/ 3):\n    rotations_count = int(2 * math.pi \/ base_angle)\n    flip = orientation > rotations_count - 1\n    multiplier = orientation % rotations_count\n    rotation_angle = base_angle * multiplier\n    if flip:\n        polygon = reflect_over_x_axis(polygon)\n    polygon = rotate(rotation_angle, polygon)\n    polygon = translation(shift[0], shift[1], polygon)\n    return polygon\n\n\ndef rotate(theta, matrix):\n    \"\"\"\n    theta is the angle by which to rotate the points in matrix\n    matrix is expected to be a Nx2 matrix where the first column is the x values\n    and the second column is the y values\n    \"\"\"\n    r_matrix = np.array([[math.cos(theta), math.sin(theta)],\n                         [-math.sin(theta), math.cos(theta)]])\n    return matrix.dot(r_matrix)\n\n\ndef translation(x_shift, y_shift, matrix):\n    \"\"\"\n    Shift matrix by x_shift and y_shift values\n    \"\"\"\n    return matrix + (x_shift, y_shift)\n\n\ndef point_inside_polygon(x, y, poly, include_edges=True):\n    \"\"\"\n    This is not strictly a transform, but hey it is close enough\n\n    This code is lifted from\n    https:\/\/stackoverflow.com\/questions\/39660851\n\n    Test if point (x,y) is inside polygon poly.\n\n    poly is N-vertices polygon defined as\n    [(x1,y1),...,(xN,yN)] or [(x1,y1),...,(xN,yN),(x1,y1)]\n    (function works fine in both cases)\n\n    Geometrical idea: point is inside polygon if horizontal beam\n    to the right from point crosses polygon even number of times.\n    Works fine for non-convex polygons.\n    \"\"\"\n    n = len(poly)\n    inside = False\n\n    p1x, p1y = poly[0]\n    for i in range(1, n + 1):\n        p2x, p2y = poly[i % n]\n        if p1y == p2y:\n            if y == p1y:\n                if min(p1x, p2x) <= x <= max(p1x, p2x):\n                    # point is on horizontal edge\n                    inside = include_edges\n                    break\n                elif x < min(p1x, p2x):  # point is left of the current edge\n                    inside = not inside\n        else:  # p1y!= p2y\n            if min(p1y, p2y) <= y <= max(p1y, p2y):\n                x_intersect = (y - p1y) * (p2x - p1x) \/ float(p2y - p1y) + p1x\n\n                if x == x_intersect:  # point is right on the edge\n                    inside = include_edges\n                    break\n\n                if x < x_intersect:  # point is to the left from current edge\n                    inside = not inside\n\n        p1x, p1y = p2x, p2y\n\n    return inside\n\n\nclass GameState(object):\n    def __init__(self, screen_size, data_directory='data'):\n        self._screen_size = screen_size\n        self._data_directory = data_directory\n        self._graph_pd = None\n        self._load_data()\n        self._load_graph()\n        self._transforms = [list() for _ in self._original_polygons]\n        self._active_piece = 0\n\n    def _load_graph(self):\n        if self._graph_pd is None:\n            self._graph_pd = pd.read_csv(os.path.join(self._data_directory,\n                                                      'edges.csv'),\n                                         index_col=0)\n        self._graph = nx.from_pandas_edgelist(self._graph_pd)\n\n    def _load_data(self):\n        colour_data = pd.read_csv(os.path.join(self._data_directory,\n                                               'colours.csv'))\n        colours = colour_data.values[:, 1:4].tolist()\n        colours = [tuple(colour) for colour in colours]\n        self._colours = colours\n        self._perimeter_colour = self._colours.pop()\n\n        points_data = pd.read_csv(os.path.join(self._data_directory,\n                                               'points.csv'))\n        self._points = points_data.values\n        self._points_canvas = cartesian_to_canvas(self._screen_size,\n                                                  self._points)\n\n        points_data = pd.read_csv(os.path.join(self._data_directory,\n                                               'placement_points.csv'))\n        self._placement_points = points_data.values\n\n        perimeter_data = pd.read_csv(os.path.join(self._data_directory,\n                                                  'shape9_cartesian.csv'))\n        self._perimeter = cartesian_to_canvas(self._screen_size,\n                                              perimeter_data.values)\n\n        polygons = list()\n        shape_csv_file_names = \\\n            [os.path.join(self._data_directory,\n                          'shape{}_cartesian.csv'.format(i)) for i in\n             range(9)]\n        for in_csv in shape_csv_file_names:\n            data = pd.read_csv(in_csv)\n            polygons.append(data.values)\n        self._original_polygons = polygons\n\n        self._reset_state()\n\n    def _reset_state(self):\n        self._transformed_polygons = list()\n        for polygon in self._original_polygons:\n            self._transformed_polygons.append(np.array(polygon, copy=True))\n        self._visible = [False for _ in self._original_polygons]\n        self._load_graph()\n\n    def get_points(self):\n        return self._points_canvas.tolist()\n\n    def get_placement_points(self):\n        return self._placement_points.tolist()\n\n    def get_perimeter(self):\n        return self._perimeter\n\n    def get_polygons(self):\n        return [cartesian_to_canvas(self._screen_size, polygon) for\n                polygon\n                in self._transformed_polygons]\n\n    def get_polygon_colours(self):\n        return self._colours\n\n    def get_perimeter_colour(self):\n        return self._perimeter_colour\n\n    def get_polygons_visible(self):\n        return self._visible\n\n    def place_polygon(self, polygon_index, placement_index, orientation):\n        self._visible[polygon_index] = True\n        self._transformed_polygons[polygon_index] = place_polygon(\n            self._original_polygons[polygon_index], orientation,\n            self._placement_points[placement_index])\n\n    def do_action(self, action):\n        if action in '123456789':\n            active_piece = int(action) - 1\n            if active_piece == self._active_piece and self._visible[\n              active_piece]:\n                self._visible[active_piece] = False\n            else:\n                self._active_piece = active_piece\n                self._visible[active_piece] = True\n        if action in UNIT_VECTORS.keys():\n            shift = UNIT_VECTORS[action]\n            self._transformed_polygons[self._active_piece] = translation(\n                shift[0], shift[1],\n                self._transformed_polygons[self._active_piece])\n        if action == 'f':\n            self._transformed_polygons[\n                self._active_piece] = reflect_over_x_axis(\n                self._transformed_polygons[self._active_piece])\n        if action == 'r':\n            self._transformed_polygons[self._active_piece] = rotate(\n                math.pi \/ 3, self._transformed_polygons[self._active_piece])\n        if action == 't':\n            self._transformed_polygons[self._active_piece] = rotate(\n                -math.pi \/ 3, self._transformed_polygons[self._active_piece])\n        if action == 'g':\n            self._reset_state()\n\n    def get_active_piece(self):\n        return self._active_piece\n\n    def get_visible_points(self):\n        visible_points = set(range(len(self._points)))\n        for point in range(len(self._points)):\n            for polygon, visible in enumerate(self.get_polygons_visible()):\n                if visible:\n                    polygon = self._transformed_polygons[polygon]\n                    if point_inside_polygon(self._points[point][0],\n                                            self._points[point][1],\n                                            polygon):\n                        visible_points.discard(point)\n                        break\n        return visible_points\n\n    def get_score(self):\n        return len(self._points) - len(self.get_visible_points())\n\n    def reset(self):\n        self._reset_state()\n\n    def get_display_size(self):\n        return self._screen_size\n\n    def validate(self):\n        visible_count = sum(self.get_polygons_visible())\n        if visible_count * get_polygon_points() != self.get_score():\n            if visible_count == 1:\n                valid = VALIDATION_PERIMETER_VIOLATION\n            else:\n                valid = VALIDATION_OVERLAP\n        else:\n            if visible_count == len(self._original_polygons):\n                valid = VALIDATION_COMPLETE\n            else:\n                valid = VALIDATION_VALID\n        return valid\n\n\ndef draw_board(state: GameState, png_path, validation):\n    colours = state.get_polygon_colours()\n    perimeter = state.get_perimeter()\n    score = state.get_score()\n    # noinspection PyTypeChecker\n    max_score = len(state.get_points())\n    score_text = '{:02d}\/{:02d}'.format(score, max_score)\n    font = ImageFont.load_default()\n    if validation in VALID_SET:\n        background_colour = BLACK\n    else:\n        background_colour = RED\n    image = Image.new('RGBA', state.get_display_size(),\n                      color=background_colour)\n    draw_context = ImageDraw.Draw(image)\n    draw_context.text((500, 40), score_text, font=font)\n    draw_context.polygon(perimeter.flatten().tolist(),\n                         fill=state.get_perimeter_colour())\n    polygons = state.get_polygons()\n    for index, polygon, visible in zip(range(len(polygons)), polygons,\n                                       state.get_polygons_visible()):\n        if visible:\n            draw_context.polygon(polygon.flatten().tolist(),\n                                 fill=colours[index])\n    # noinspection PyTypeChecker\n    for index, point in enumerate(state.get_points()):\n        point_text = str(index)\n        draw_context.text(point, point_text, font=font, fill=BLACK)\n    image.save(png_path)\n\n\ndef draw_boards(boards):\n    filenames = list()\n    state = GameState((602, 522), data_directory=DATA_DIRECTORY)\n    filename_format = 'board{}.png'\n    for index, board in enumerate(boards):\n        logging.info('drawing board: {} with settings: {}'.format(\n            index,\n            board\n        ))\n        state.reset()\n        path = None\n        for placement in board:\n            polygon_index, point, orientation = placement\n            state.place_polygon(polygon_index, point, orientation)\n            path = join('images',\n                        'boards',\n                        state.validate(),\n                        filename_format.format(\n                            index))\n        if path is not None:\n            if not os.path.isdir(os.path.dirname(path)):\n                os.makedirs(os.path.dirname(path), exist_ok=True)\n            validation = evaluate_board(board)\n            draw_board(state, path, validation)\n        filenames.append(path)\n    return filenames\n\n\nclass CsvWriter(object):\n    \"\"\"\n    Write to a csv file\n    \"\"\"\n\n    def __init__(self, file_pattern,\n                 pattern_fill,\n                 header_fields):\n        self._file_pattern = file_pattern\n        self._pattern_fill = pattern_fill\n        self._header_fields = header_fields\n        self._file = None\n        self._writer = None\n\n    def _open_file(self):\n        filename = self._file_pattern.format(*self._pattern_fill)\n        directory = os.path.dirname(filename)\n        if not os.path.exists(directory):\n            os.makedirs(directory)\n        self._file = open(filename, 'wt')\n        self._writer = csv.writer(self._file)\n        self._writer.writerow(self._header_fields)\n        self._current_line = 0\n\n    def write_row(self, row):\n        if self._file is None:\n            self._open_file()\n        self._writer.writerow(row)\n\n\ndef get_coverage_dictionary():\n    coverage_map = dict()\n    with open('{}\/coverage.csv'.format(DATA_DIRECTORY)) as f:\n        reader = csv.reader(f)\n        for row in reader:\n            placement = tuple(map(int, row[0:3]))\n            coverage = tuple(map(int, row[3:]))\n            coverage_map[placement] = coverage\n    return coverage_map\n\n\nLOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n\nTABLE_FORMAT = '{}\/validation_table_{}.csv'\n\nCOVERAGE = get_coverage_dictionary()\nCOVERAGE_TO_PLACEMENT = {frozenset(value): key for key, value in\n                         COVERAGE.items()}\nALL_POINTS = set(range(54))\nPANDAS_GRAPH = pd.read_csv(os.path.join(DATA_DIRECTORY, 'edges.csv'),\n                           index_col=0)\n\n\ndef get_duplicates():\n    duplicates = set()\n    with open('{}\/shape_0_duplicates.csv'.format(DATA_DIRECTORY)) as f:\n        reader = csv.reader(f)\n        f.readline()\n        for row in reader:\n            row = map(int, row)\n            duplicates.add(tuple(row))\n    return frozenset(duplicates)\n\n\nDUPLICATES = get_duplicates()\n\n\ndef get_unique_single_piece_placements():\n    boards = list()\n    placements = set(COVERAGE_TO_PLACEMENT.values())\n    for polygon_index in range(9):\n        for point in range(39):\n            for orientation in range(12):\n                placement = (polygon_index, point, orientation)\n                coverage = COVERAGE[placement]\n                if len(coverage) == 6:\n                    if placement not in DUPLICATES and placement in placements:\n                        boards.append([placement])\n    return boards\n\n\ndef chunk_list(l, size=3):\n    it = iter(l)\n    return zip(*[it] * size)\n\n\ndef get_fieldnames_for_table(number):\n    fieldnames = list()\n    for index in range(number):\n        fieldnames.append('shape{}'.format(index))\n        fieldnames.append('shape{}_position'.format(index))\n        fieldnames.append('shape{}_orientation'.format(index))\n    fieldnames.append('validation_result')\n    return fieldnames\n\n\ndef evaluate_board(board):\n    result = VALIDATION_VALID\n    pieces_count = len(board)\n    expected_coverage = 6 * pieces_count\n    covered_points = set()\n    for placement in board:\n        covered_points.update(COVERAGE[placement])\n    visible_points = ALL_POINTS - covered_points\n    if len(covered_points) != expected_coverage:\n        unexpected = True\n    else:\n        unexpected = False\n    if unexpected:\n        if pieces_count == 1:\n            result = VALIDATION_PERIMETER_VIOLATION\n        else:\n            result = VALIDATION_OVERLAP\n    else:\n        graph = nx.from_pandas_edgelist(PANDAS_GRAPH)\n        graph.remove_nodes_from(covered_points)\n        processed_nodes = set()\n        for point in visible_points:\n            if point not in processed_nodes:\n                nodes = set()\n                for start, end in nx.dfs_edges(graph, source=point):\n                    nodes.add(start)\n                    nodes.add(end)\n                processed_nodes.update(nodes)\n                if len(nodes) == 0:\n                    result = VALIDATION_ISOLATED_SINGLE\n                    break\n                elif len(nodes) == 2:\n                    result = VALIDATION_ISOLATED_DOUBLE\n                    break\n                elif len(nodes) == 3:\n                    result = VALIDATION_ISOLATED_TRIPLE\n                    break\n                elif len(nodes) == 4:\n                    result = VALIDATION_ISOLATED_QUAD\n                    break\n                elif len(nodes) == 5:\n                    result = VALIDATION_ISOLATED_QUINT\n    return result\n\n\ndef parse_row(row):\n    status = row.pop()\n    placements = list()\n    for item in chunk_list(map(int, row)):\n        placements.append(item)\n    return placements, status\n\n\ndef filter_single_placement_boards(boards, wanted_piece):\n    filtered = list()\n    logging.debug('wanted piece = {}'.format(wanted_piece))\n    for board in boards:\n        logging.debug(board)\n        if board[0][0] == wanted_piece:\n            filtered.append(board)\n    return filtered\n\n\ndef load_boards_from_csv(filename, filter_piece=None):\n    logging.info('loading file: {}'.format(filename))\n    boards = list()\n    with open(filename, 'rt') as f:\n        # throw away the header\n        f.readline()\n        reader = csv.reader(f)\n        for row in reader:\n            placements, status = parse_row(row)\n            if status == VALIDATION_VALID:\n                boards.append(placements)\n    if filter_piece:\n        boards = filter_single_placement_boards(boards, filter_piece)\n    return boards\n\n\ndef iterate_boards_from_csv(filename, only_valid=True):\n    logging.info('loading file: {}'.format(filename))\n    with open(filename, 'rt') as f:\n        # throw away the header\n        f.readline()\n        reader = csv.reader(f)\n        for row in reader:\n            placements, status = parse_row(row)\n            if only_valid and status == VALIDATION_VALID:\n                yield placements\n            else:\n                yield placements\n\n\ndef iterate_empty_board(_):\n    boards = [[]]\n    for board in boards:\n        yield board\n\n\ndef extract_piece(placement_tuple):\n    return placement_tuple[0]\n\n\ndef get_all_possible_single_piece_placements():\n    boards = list()\n    size = (602, 522)\n    state = GameState(size)\n    placement_count = len(state.get_placement_points())\n    polygon_count = len(state.get_polygons())\n    del state\n    for polygon_index in range(polygon_count):\n        for point in range(placement_count):\n            for orientation in range(12):\n                boards.append([(polygon_index, point, orientation)])\n    return boards\n\n\ndef get_placements_for_piece(piece):\n    boards = list()\n    for board in get_unique_single_piece_placements():\n        if board[0][0] == piece and evaluate_board(board) == VALIDATION_VALID:\n            boards.append(board)\n    return boards\n\n\ndef generate_table(table_number):\n    placement_piece = table_number - 1\n    if table_number == 1:\n        placement_boards = get_placements_for_piece(placement_piece)\n        source_board_iterator = iterate_empty_board\n        source_board_filename = None\n    else:\n        logging.debug(\"Loading source boards\")\n        source_board_iterator = iterate_boards_from_csv\n        source_board_filename = \\\n            TABLE_FORMAT.format(TABLE_DIRECTORY,\n                                table_number - 1,)\n        logging.info(\"Loading placement boards\")\n        placement_boards = get_placements_for_piece(placement_piece)\n    field_names = get_fieldnames_for_table(table_number)\n    csv_writer = CsvWriter(file_pattern=TABLE_FORMAT,\n                           pattern_fill=(TABLE_DIRECTORY,\n                                         table_number,),\n                           header_fields=field_names)\n    logging.info('iterating source boards')\n    for source_board in source_board_iterator(source_board_filename):\n        pieces_on_board = set(map(extract_piece, source_board))\n        for placement_board in placement_boards:\n            placement_piece = placement_board[0]\n            new_piece = extract_piece(placement_piece)\n            if new_piece not in pieces_on_board:\n                evaluation_board = list(source_board)\n                evaluation_board.append(placement_piece)\n                status = evaluate_board(evaluation_board)\n                row = list()\n                for placement in evaluation_board:\n                    row.extend(placement)\n                row.append(status)\n                csv_writer.write_row(row)\n\n\ndef find_solutions():\n    for table_number in range(1, 10):\n        generate_table(table_number)\n\n\ndef draw_solutions():\n    final_board_table = TABLE_FORMAT.format(TABLE_DIRECTORY, 9)\n    boards = load_boards_from_csv(final_board_table)\n    draw_boards(boards)\n","fb8fcc94":"import csv\nimport shutil\nfrom io import StringIO\n\nimport matplotlib.image as mpimg\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndef get_boards(f):\n    boards = list()\n    reader = csv.reader(f)\n    # throw away the header\n    next(reader)\n    for row in reader:\n        placements, _ = parse_row(row)\n        boards.append(placements)\n    return boards\n    \n\nimage_dir = 'images'\nif os.path.isdir(image_dir):\n    shutil.rmtree(image_dir)\n\ntable = pd.read_csv('..\/input\/puzzle-output\/validation_table_3.csv')\nsample = table.sample(9)\nbuffer = sample.to_csv(index=False)\nprint(buffer)\nfile_like = StringIO(buffer)\nimage_files = draw_boards(get_boards(file_like))\n\nimages = [mpimg.imread(filename) for filename in image_files]\n\nfig, axs = plt.subplots(nrows=3, ncols=3, figsize=(15, 15),\n                        subplot_kw={'xticks': [], 'yticks': []},\n                        gridspec_kw = {'wspace':0, 'hspace':0.2})\n\nfor ax, image in zip(axs.flat, images):\n    ax.imshow(image)\n","8210a997":"boards = load_boards_from_csv('..\/input\/puzzle-output\/validation_table_9.csv')\nfile_names = draw_boards(boards)\nimages = [mpimg.imread(file_name) for file_name in file_names]\n\nfig, axs = plt.subplots(nrows=5, ncols=4, figsize=(15, 15),\n                        subplot_kw={'xticks': [], 'yticks': []},\n                        gridspec_kw = {'wspace':0, 'hspace':0.2})\n\nfor ax, image in zip(axs.flat, images):\n    ax.imshow(image)\n","cee5cf42":"### Defining Functions for Loading and Drawing Boards","90b5870b":"### Random Sample of Results from Table 3","f67e6f55":"### The Solutions"}}