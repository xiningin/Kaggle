{"cell_type":{"6676f28f":"code","15d772d4":"code","16f42a93":"code","0efc69dd":"code","6dd62353":"code","b2eb4a63":"code","18f11f98":"code","ce547c6c":"code","3aa2b79d":"code","796b66a8":"code","1cf86875":"code","c531f5fe":"code","d33a4f71":"code","24b2d747":"code","32e29e95":"code","dc1a6e49":"code","8fa0870c":"markdown","949d92e2":"markdown","0a7340d8":"markdown","1d8510d0":"markdown","f68bb644":"markdown"},"source":{"6676f28f":"import pandas as pd\nimport numpy as np","15d772d4":"cc_apps = pd.read_csv('..\/input\/uci-credit-approval\/crx.csv', header=None)\ncc_apps.head(5)","16f42a93":"# Print summary statistics\ncc_apps_description = cc_apps.describe()\nprint(cc_apps_description)\n\nprint(\"\\n\")\n\n# Print DataFrame information\ncc_apps_info = cc_apps.info()\nprint(cc_apps_info)\n\nprint(\"\\n\")\n\n# Inspect missing values in the dataset\ncc_apps.tail(17)","0efc69dd":"# Import numpy\nimport numpy as np\n\n# Inspect missing values in the dataset\nprint(cc_apps.tail(17))\n\n# Replace the '?'s with NaN\ncc_apps = cc_apps.replace(to_replace='?',value=np.nan)\n\n# Inspect the missing values again\ncc_apps.tail(17)","6dd62353":"# Impute the missing values with mean imputation\ncc_apps.fillna(cc_apps.mean(), inplace=True)\n\n# Count the number of NaNs in the dataset to verify\ncc_apps.isnull().count()","b2eb4a63":"# Print summary statistics\ncc_apps_description = cc_apps.describe()\nprint(cc_apps_description)\n\nprint(\"\\n\")\n\n# Print DataFrame information\ncc_apps_info = cc_apps.info()\nprint(cc_apps_info)\n\nprint(\"\\n\")\n\n# Inspect missing values in the dataset\ncc_apps.tail(17)","18f11f98":"# Import numpy\nimport numpy as np\n\n# Inspect missing values in the dataset\nprint(cc_apps.tail(17))\n\n# Replace the '?'s with NaN\ncc_apps = cc_apps.replace(to_replace='?',value=np.nan)\n\n# Inspect the missing values again\ncc_apps.tail(17)","ce547c6c":"# Impute the missing values with mean imputation\ncc_apps.fillna(cc_apps.mean(), inplace=True)\n\n# Count the number of NaNs in the dataset to verify\ncc_apps.isnull().count()","3aa2b79d":"for col in cc_apps.columns:\n    # Check if the column is of object type\n    if cc_apps[col].dtypes == 'object':\n        # Impute with the most frequent value\n        cc_apps = cc_apps.fillna(cc_apps[col].value_counts().index[0])","796b66a8":"# Import LabelEncoder\nfrom sklearn.preprocessing import LabelEncoder\n\n# Instantiate LabelEncoder\nle = LabelEncoder()\n\n# Iterate over all the values of each column and extract their dtypes\nfor col in cc_apps.columns:\n    # Compare if the dtype is object\n    if cc_apps[col].dtypes=='object':\n    # Use LabelEncoder to do the numeric transformation\n        cc_apps[col]=le.fit_transform(cc_apps[col])","1cf86875":"# Import train_test_split\nfrom sklearn.model_selection import train_test_split\n\n# Drop the features 11 and 13 and convert the DataFrame to a NumPy array\ncc_apps = cc_apps.drop([11, 13], axis=1)\ncc_apps = cc_apps.values\n\n# Segregate features and labels into separate variables\nX,y = cc_apps[:,0:12] , cc_apps[:,13]\n\n# Split into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X,\n                                y,\n                                test_size=0.33,\n                                random_state=42)","c531f5fe":"# Import MinMaxScaler\nfrom sklearn.preprocessing import MinMaxScaler\n\n# Instantiate MinMaxScaler and use it to rescale X_train and X_test\nscaler = MinMaxScaler(feature_range=(0, 1))\nrescaledX_train = scaler.fit_transform(X_train)\nrescaledX_test = scaler.fit_transform(X_test)","d33a4f71":"from sklearn.linear_model import LogisticRegression\n# Instantiate a LogisticRegression classifier with default parameter values\nlogreg = LogisticRegression()\n\n# Fit logreg to the train set\nlogreg.fit(rescaledX_train,y_train)","24b2d747":"# Import confusion_matrix\nfrom sklearn.metrics import confusion_matrix\n\n# Use logreg to predict instances from the test set and store it\ny_pred = logreg.predict(rescaledX_test)\n\n# Get the accuracy score of logreg model and print it\nprint(\"Accuracy of logistic regression classifier: \", logreg.score(rescaledX_test,y_pred))\n\n# Print the confusion matrix of the logreg model\nprint(confusion_matrix(y_test,y_pred))","32e29e95":"# Import GridSearchCV\nfrom sklearn.model_selection import GridSearchCV\n# Define the grid of values for tol and max_iter\ntol = [0.01,0.001,0.0001]\nmax_iter = [100,150,200]\n\n# Create a dictionary where tol and max_iter are keys and the lists of their values are corresponding values\nparam_grid = dict(tol=tol, max_iter=max_iter)","dc1a6e49":"# Instantiate GridSearchCV with the required parameters\ngrid_model = GridSearchCV(estimator=logreg, param_grid=param_grid, cv=5)\n\n# Use scaler to rescale X and assign it to rescaledX\nrescaledX = scaler.fit_transform(X)\n\n# Fit data to grid_model\ngrid_model_result = grid_model.fit(rescaledX, y)\n\n# Summarize results\nbest_score, best_params = grid_model_result.best_score_,grid_model_result.best_params_\nprint(\"Best: %f using %s\" % (best_score, best_params))","8fa0870c":"## Preprocessing","949d92e2":"## Gridsearch","0a7340d8":"## Handling Missing Values","1d8510d0":"## EDA","f68bb644":"### train test split"}}