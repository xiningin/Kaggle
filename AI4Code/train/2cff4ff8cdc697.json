{"cell_type":{"6469ee5b":"code","bf84d527":"code","a6441fef":"code","a44998f7":"code","b03c327f":"code","28a94555":"code","b86a7d70":"code","b6b5d308":"code","4aeeddaf":"code","fb73be9a":"code","5935e6ed":"code","f108bf43":"code","bb7e13de":"code","3af83ceb":"code","2cab1b6f":"code","b3149363":"code","1a9827d6":"code","20a81cf9":"code","c08cad1c":"code","3ba41070":"code","9baaa78d":"code","cde23b63":"code","cfdc768c":"code","a8e1e01c":"code","09f1d494":"code","dd5f5d40":"code","1f589ee8":"code","af6ed493":"code","e3bfd2c9":"code","887f0ad9":"code","1e8d7c27":"code","93575437":"code","8b8da4b4":"code","a55e4bea":"code","dcf6590b":"code","b1f58a5d":"code","cc31ce0e":"code","21336fdb":"code","4a366895":"code","0141fc85":"code","f88ec471":"code","97d50810":"code","1a7b43fc":"code","17e9a547":"code","4e3de8b6":"code","403f3bda":"code","5810ba40":"code","f8fa9479":"code","2fb61977":"code","9379e4ff":"code","d84a0652":"code","715742ed":"code","e0de0272":"code","915111fe":"code","99e97668":"code","f169cea9":"code","e77b2f33":"code","0da0168e":"code","45372741":"code","ff571bf6":"code","d713a81d":"code","8207c7e3":"code","b1d93274":"code","d64184be":"code","d8e38e10":"code","c3258945":"code","cba7fcd7":"code","83230676":"code","836e2fb6":"code","c56ec8a1":"code","085a8e83":"code","ced3041f":"code","51e573b1":"code","6c00c8af":"code","178e6d08":"code","e86c4b9a":"code","b85a8093":"code","96135824":"code","305f52bd":"code","74ca56d8":"code","53027caa":"code","481a2fc5":"code","aebdeba6":"code","00ce4e92":"code","b710cb1f":"code","9e10b148":"code","4fdb7de3":"code","5b6cccf1":"code","e020e4fd":"code","3ca1560a":"code","a062e228":"code","9b774f57":"code","7352e42f":"code","c722f25d":"code","904c11ed":"code","f28a3f69":"code","5e9cbb50":"code","16f477ec":"code","4b690c33":"code","b043fb76":"code","92952766":"code","efc8fa6e":"code","94b50002":"code","324e6bb2":"code","a2086893":"code","77911637":"code","3a7fb7da":"code","ae4f9599":"code","0d8133d1":"code","2b26af15":"code","7237c6b8":"code","a7cedad0":"code","5ed38c6b":"code","bbb68388":"code","1e1451a7":"code","5b68c5da":"code","e8f023a3":"code","59b26e47":"code","04d213d3":"code","f78f04ed":"code","a57a4e6f":"code","6347f34a":"code","2514a504":"code","9d8fe2ad":"code","91ccd044":"code","229eb85f":"code","100efc6a":"code","13fd08d9":"code","c1c94021":"code","1e5ed72b":"code","80b4c490":"code","504d6edb":"code","4709b044":"code","863976a9":"code","f45b43e1":"code","79177125":"code","19b72511":"code","9b06e405":"code","d3526ac4":"code","65053c05":"code","cc7ef219":"code","c6f2b9ed":"code","0ec06fae":"code","acb62425":"code","2b8e7951":"code","0b415653":"code","54f5aec1":"code","57eebc65":"markdown","a0debb24":"markdown","89e2e20a":"markdown","9908b23b":"markdown","4a80277f":"markdown","063a5735":"markdown","1d888b71":"markdown","9d48c98a":"markdown","e928b2e8":"markdown","75bb4dcd":"markdown","f47a223b":"markdown","897520cb":"markdown","2b5c5046":"markdown","f422a34d":"markdown","66556ead":"markdown","3ca49558":"markdown","06c7b5e7":"markdown","dcab27e9":"markdown","6e91eb48":"markdown","8ffdfa71":"markdown","321ad82d":"markdown","0c83a000":"markdown","617ba84c":"markdown","b2cf35f1":"markdown","37708d42":"markdown","adf99f06":"markdown","1a6f0d48":"markdown","cef6c6cc":"markdown","3ea232f1":"markdown","2221179f":"markdown","5f84e5f2":"markdown","a89792b5":"markdown","af069eba":"markdown","0f0be23b":"markdown","31dec0cd":"markdown","b07ed2e1":"markdown","222bd487":"markdown","4b607c99":"markdown","d8c43f87":"markdown","d38f9ed6":"markdown","534dc1a0":"markdown","80f53e7e":"markdown","ea7119ab":"markdown","a5b0c5e4":"markdown","a6e10d66":"markdown","9eea9415":"markdown","fa221c55":"markdown","00c452ab":"markdown","89fdec19":"markdown","3e2e4bde":"markdown","7b3f4054":"markdown","f82b5b56":"markdown","f60d24c0":"markdown","53fa4229":"markdown","7fe8387e":"markdown","b68ba807":"markdown","806a078f":"markdown","77936908":"markdown","3eb7bfb0":"markdown","c527afa8":"markdown","7305f1f4":"markdown","7abd3fed":"markdown","ca5f4359":"markdown","564f0cf2":"markdown","2743b5c4":"markdown","a6922a86":"markdown","c47718a5":"markdown","a502dd34":"markdown","0ec2b87a":"markdown","51fa35fc":"markdown","f5d08883":"markdown","1d6c720c":"markdown","f335258b":"markdown","4b2c1c40":"markdown","12f827d9":"markdown","890cbed3":"markdown","d1c5ac96":"markdown","c2b395a2":"markdown","8669868a":"markdown","cfa59ff2":"markdown","0af0334a":"markdown","3d0ae54d":"markdown","9e5bc897":"markdown","c48e882a":"markdown","7419f2d1":"markdown","cfc151b5":"markdown","cd1ab609":"markdown","f882db78":"markdown","30dac369":"markdown","4dcee441":"markdown","15863593":"markdown","06b2795c":"markdown","79d4e304":"markdown","75e865bb":"markdown","60a37047":"markdown","86b5805d":"markdown","11fae587":"markdown","6172a08b":"markdown","a711147c":"markdown","51d32b16":"markdown","34e68692":"markdown","1e8daf6c":"markdown","1f4d8a20":"markdown","763c42c3":"markdown","9c261fa0":"markdown","cc694080":"markdown","57b59a36":"markdown","c1fdea20":"markdown","a7b895d5":"markdown","109afb93":"markdown","750ade92":"markdown"},"source":{"6469ee5b":"import sys\nimport shutil\n\nshutil.rmtree('Data-Science-Tools',ignore_errors=True)\n\n!git clone https:\/\/github.com\/galmerom\/Data-Science-Tools.git\nSourceCodePath2 = 'Data-Science-Tools'\nsys.path.insert(2, SourceCodePath2 )\n","bf84d527":"!pip install openpyxl","a6441fef":"import pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom xgboost import XGBClassifier\n%matplotlib inline\nfrom datetime import timedelta\nfrom datetime import datetime\nimport calendar\nfrom collections import defaultdict\nimport sys\nfrom sklearn.model_selection import train_test_split\nimport seaborn as sns\nfrom sklearn.metrics import confusion_matrix, classification_report\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.feature_selection import SelectKBest, chi2\nfrom sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV\nfrom sklearn.ensemble import RandomForestClassifier,AdaBoostClassifier\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import roc_auc_score\n\nimport charts\nimport transformers as TR\nimport mega_classifier as MC","a44998f7":"data = pd.read_csv('..\/input\/australiaweather\/weatherAUS.csv', squeeze=True,parse_dates =[0])\nLocations = pd.read_excel('..\/input\/locationsinaustralia\/LocationsAndClimate.xlsx', squeeze=True,usecols =\"A:J\")","b03c327f":"data.head(5)\n","28a94555":"len(data.Location.unique())","b86a7d70":"Locations.head()","b6b5d308":"data.info()","4aeeddaf":"Locations.info()","fb73be9a":"data.isnull().sum()","5935e6ed":"data.sort_values(by='Date',inplace=True)\ndata_train=data.iloc[0:113747,:] # 80% train 20% test\ndata_test=data.iloc[113748:,:]","f108bf43":"TestClass=data_test['RainTomorrow'].value_counts()\nTrainClass=data_train['RainTomorrow'].value_counts()\ncharts.BarCharts([TestClass,TrainClass],['Test set classes','Train set classes'],1,2,txt2show=[('22% for YES label in\\n TEST dataset', 13,0.6,-0.15),('22% for YES label in\\n TRAIN dataset', 13,0.6,-0.15)]) ","bb7e13de":"data_train4EDA = data_train.copy()","3af83ceb":"from sklearn.base import BaseEstimator, TransformerMixin\nclass DirectionTransformer(BaseEstimator, TransformerMixin):\n  def __init__(self):\n    self.DirecDict = {'N':0,'NNE':1,'NE':2,'ENE':3,'E':4,'ESE':5,'SE':6,'SSE':7,'S':8,'SSW':9,'SW':10,'W':11,'WSW':12,'WNW':13,'NW':14,'NNW':15}\n  def fit(self,X,y=None):\n    return self\n  def transform(self, X):\n    X_new = X.copy()\n    X_new['WindGustDir']=X_new['WindGustDir'].apply(self.ChangeWindDirec2Int)\n    X_new['WindDir3pm']=X_new['WindDir3pm'].apply(self.ChangeWindDirec2Int)\n    X_new['WindDir9am']=X_new['WindDir9am'].apply(self.ChangeWindDirec2Int)\n    return X_new\n  def ChangeWindDirec2Int(self,x):\n    try:\n      return self.DirecDict[x]\n    except:\n      return x","2cab1b6f":"DirectTransformer = DirectionTransformer()\ndata_train4EDA=DirectTransformer.transform(data_train4EDA)","b3149363":"class MergeLocationTransformer(BaseEstimator, TransformerMixin):\n  def __init__(self,Locations):\n    self.Location = Locations\n  def fit(self,X,y=None):\n    return self\n  def transform(self, X):\n    X_new = X.copy()\n    X_new= pd.merge(X_new,self.Location, on='Location',how ='left')\n    Sameasdf = X_new.groupby(['Date','Same as']).mean()\n    Neardf = X_new.groupby(['Date','Nearest location']).mean()\n    Areadf = X_new.groupby(['Date','Area']).mean()\n    SameDaydf = X_new.groupby(['Date']).mean()\n    Climatedf=X_new.groupby(['Date','Climate']).mean()\n    X_new= pd.merge(X_new,Sameasdf, on=('Date','Same as'),suffixes=('', '_SameAS'),how ='left')\n    X_new= pd.merge(X_new,Neardf, on=('Date','Nearest location'),suffixes=('', '_Nearest'),how ='left')\n    X_new= pd.merge(X_new,Climatedf, on=('Date','Climate'),suffixes=('', '_Climate'),how ='left')\n    X_new= pd.merge(X_new,Areadf, on=('Date','Area'),suffixes=('', '_Area'),how ='left')\n    X_new= pd.merge(X_new,SameDaydf, on=('Date'),suffixes=('', '_All'),how ='left')\n    X_new.index = X.index\n    return X_new\n","1a9827d6":"MergeLocation = MergeLocationTransformer(Locations)\ndata_train4EDA=MergeLocation.transform(data_train4EDA)","20a81cf9":"class impute_nullsTransformer(BaseEstimator, TransformerMixin):\n  def __init__(self,WithTargetCol=True):\n    self.df=pd.DataFrame()\n    self.IncldTrgtcol=WithTargetCol\n  def fit(self,X,y=None):\n    return self\n  def transform(self, X):\n    X_new = X.copy()\n    self.df = X_new\n    AllCol = X_new.columns.to_list()\n    ColList = [AllCol[i] for i in range(2,21)]\n    list(map(self.impute_nulls, ColList))\n    # Update the target column to follow the rules over 1 mm is rain\n    X_new.loc[:,'RainToday'] = np.where(X_new.loc[:,'Rainfall']>1,'Yes','No')\n    \n    # remove extra columns\n    if self.IncldTrgtcol:\n      X_new=X_new.iloc[:,0:33]\n    else:\n      X_new=X_new.iloc[:,0:31]\n\n    return X_new\n\n  def impute_nulls(self,col_name):\n    df=self.df\n    prefixes = ['_SameAS','_Nearest','_Climate','_Area','_All']\n    # Go over the column that was given as a parameter. When you find null: go over all the prefixes in the right order\n    # and put the value that is in that col_name+prefix. If there is null there then in the next iteration, it will be fixed with \n    # the next prefix.\n    for pf in prefixes:\n      df.loc[:,col_name] = np.where(df.loc[:,col_name].isnull(),\n                                    df[col_name+pf],\n                                    df[col_name])\n    # In case there are still nulls, then give them the value of zero\n    df.loc[:,col_name] = np.where(df.loc[:,col_name].isnull(),\n                                  0,\n                                  df[col_name])","c08cad1c":"ImputeNulls = impute_nullsTransformer()\ndata_train4EDA=ImputeNulls.transform(data_train4EDA)","3ba41070":"data_train4EDA.loc[data_train4EDA.isnull().any(axis=1),:]","9baaa78d":"data_train4EDA.to_csv(\"No_nulls.csv\")","cde23b63":"df2= pd.read_csv(\"No_nulls.csv\",index_col=0)#,parse_dates =[1])\n","cfdc768c":"df2.describe()","a8e1e01c":"dfArea=pd.crosstab( df2['Area'],df2['RainTomorrow'], normalize='index')\ndfArea.style.set_precision(2).background_gradient(cmap='Blues')","09f1d494":"tmp=df2[['rain_district','Location','Height']].groupby(['rain_district','Location']).max().reset_index()\ntmp.groupby('rain_district').count()['Location'].to_frame().transpose()","dd5f5d40":"dfRD=pd.crosstab( df2['RainTomorrow'],df2['rain_district'], normalize='columns')\ndfRD.style.set_precision(2).background_gradient(cmap='Blues')","1f589ee8":"tmp2 = df2[['Climate','Location','Height']].groupby(['Climate','Location']).max().reset_index()\ntmp2.groupby('Climate').count()['Location'].to_frame().transpose()","af6ed493":"dfRD=pd.crosstab( df2['RainTomorrow'],df2['Climate'], normalize='columns')\ndfRD.style.set_precision(2).background_gradient(cmap='Blues')","e3bfd2c9":"ClimateDF=df2.groupby(['RainTomorrow','Climate']).count()['Date'].reset_index()\ncharts.StackBarCharts([(ClimateDF,'Climate','RainTomorrow','Date')],['Number of records per climate and the chances of rain'],ChartSize=(18, 6))","887f0ad9":"df2.Height.hist(bins= 200,figsize=(10,5))","1e8d7c27":"def HeightCatg(x):\n  if x<=40:\n    return '0000-0040'\n  elif x<= 260:\n    return '0040-0260'\n  elif x<= 1000:\n    return '0260-1000'\n  else:\n     return '1000+'\n\ndf2['HeightCategory']=  df2['Height'].apply(lambda x: HeightCatg(x))\ndfHeight = df2.groupby(['HeightCategory','RainTomorrow']).count()['Location'].to_frame().reset_index()","93575437":"charts.StackBarCharts([(dfHeight,'HeightCategory','RainTomorrow','Location')],['Num. of records in each Height category vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ColorInt=3,ChartSize=(15,7),TitleSize =22,txt2show=[('We can see that height does not\\n help predict the target.',12, 0.4,-0.09)])","8b8da4b4":"df2.Distance_from_Sea.hist(bins= 200,figsize=(10,5))","a55e4bea":"def DisFromSeaCatg(x):\n  if x<=0:\n    return '000-000'\n  elif x<= 40:\n    return '000-040'\n  elif x<= 100:\n    return '040-100'\n  elif x<= 200:\n    return '100-200'  \n  else:\n     return '500+'\n\ndf2['DisFromSeaCategory']=  df2['Distance_from_Sea'].apply(lambda x: DisFromSeaCatg(x))\ndfDisFromSea = df2.groupby(['DisFromSeaCategory','RainTomorrow']).count()['Location'].to_frame().reset_index()","dcf6590b":"charts.StackBarCharts([(dfDisFromSea,'DisFromSeaCategory','RainTomorrow','Location')],['Num. of records in each \\\"distance in KM from the sea\\\" category vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ChartSize=(15,7),TitleSize =20,txt2show=[('The distance from the sea correlates\\n with the rain tomorrow. The longer the distance,\\n the lower the chance for rain',12, 0.5,-0.15)]) ","b1f58a5d":"df2['Month'] = pd.DatetimeIndex(df2['Date']).month\ndf2['TommrRainBin']=np.where(df2['RainTomorrow']=='Yes',1,0)","cc31ce0e":"num_corr = df2.select_dtypes(include=np.number).corr()\nfig, ax = plt.subplots(figsize=(15, 15))\ntitle = 'Pearson correlation coefficients (PCC) for Australia Rain DS'\nplt.title(title, fontsize=18)\n\nmask = np.zeros_like(num_corr)\nmask[np.triu_indices_from(mask)] = True\n\nheat_map = sns.heatmap(num_corr, ax=ax, annot=True, linewidths=0.7, fmt='.2f', vmin=-0.80, vmax=0.8,\n                       cmap='magma_r', mask=mask, center=0.35, cbar_kws={\"shrink\": 0.75}, square=True)\nplt.show()","21336fdb":"df2['Sunshine'].hist(bins= 100,figsize=(10,5))","4a366895":"def SunshineCatg(x):\n  if x<=0.0:\n    return '00-00'\n  elif x<= 4:\n    return '00-04'\n  elif x<= 8.0:\n    return '04-08'\n  elif x<= 11.0:\n    return '08-11'\n  else:\n     return '11+'\n\ndf2['SunshineCategory']=  df2['Sunshine'].apply(lambda x: SunshineCatg(x))\ndfSun = df2.groupby(['SunshineCategory','RainTomorrow']).count()['Location'].to_frame().reset_index()","0141fc85":"charts.StackBarCharts([(dfSun,'SunshineCategory','RainTomorrow','Location')],['Num. of records in each Sunshine category vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ChartSize=(15,7),TitleSize =22,txt2show=[('The more sunshine we get,\\n the more dry days we get',12, 0.02,-0.09)])","f88ec471":"df2[(df2['Evaporation']<30)&(df2['Evaporation']>15)].hist(column='Evaporation',bins= 100,figsize=(10,5))","97d50810":"def EvapCatg(x):\n  if x<=0.0:\n    return '00-00'\n  elif x<= 2:\n    return '00-02'\n  elif x<= 5.0:\n    return '02-05'\n  elif x<= 10.0:\n    return '05-10'\n  elif x<=30.0:\n    return '11-30'\n  else:\n     return '30+'\n\ndf2['EvaporationCategory']=  df2['Evaporation'].apply(lambda x: EvapCatg(x))\ndfEvap = df2.groupby(['EvaporationCategory','RainTomorrow']).count()['Location'].to_frame().reset_index()","1a7b43fc":"charts.StackBarCharts([(dfEvap,'EvaporationCategory','RainTomorrow','Location')],['Num. of records in each Evap. category vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ChartSize=(15,7),ColorInt=3,TitleSize =25,txt2show=[('As the Evaporation value increases, we get\\n fewer chances of raining',12, 0.02,-0.09)])","17e9a547":"df2.Rainfall.hist(bins= 100,figsize=(10,5))","4e3de8b6":"df2[(df2['Rainfall']<100)&(df2['Rainfall']>10)].hist(column='Rainfall',bins= 100,figsize=(10,5))","403f3bda":"def RainfallCatg(x):\n  if x<=1:\n    return '00-01'\n  elif x<= 15:\n    return '01-15'\n  elif x<= 60:\n    return '15-60'\n  else:\n     return '60+'\n\ndf2['RainfallCategory'] =  df2['Rainfall'].apply(lambda x: RainfallCatg(x))\ndfRF = df2.groupby(['RainfallCategory','RainTomorrow']).count()['Location'].to_frame().reset_index()","5810ba40":"charts.StackBarCharts([(dfRF,'RainfallCategory','RainTomorrow','Location')],['Num. of records in each rainfall category vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ChartSize=(15,7),TitleSize =25,txt2show=[('We can see that 85% of days that did not have\\n rain will not have rain tomorrow.\\n As the amount of rain increases, the\\n chances for rain increases.',12, 0.55,-0.20)])","f8fa9479":"dfRFDFTS = df2[df2['Rainfall']>15].groupby(['DisFromSeaCategory','RainTomorrow']).count()['Location'].to_frame().reset_index()","2fb61977":"charts.StackBarCharts([(dfRFDFTS,'DisFromSeaCategory','RainTomorrow','Location')],['Num. of rain>15 as a distance from the sea vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ChartSize=(20,7),TitleSize =25,txt2show=[('We can see that 59% of days with rain over 15 and\\n is near the sea will have rain tomorrow.',12, 0.55,-0.20)]) ","9379e4ff":"dfAreaRF = df2[df2['Rainfall']>15].groupby(['Area','RainTomorrow']).count()['Location'].to_frame().reset_index()","d84a0652":"charts.StackBarCharts([(dfAreaRF,'Area','RainTomorrow','Location')],['Num. of records that rain>15 aggregate by area vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ChartSize=(20,7),TitleSize =25,txt2show=[('We can see that using area and rainfall over 15 \\nwe can get better prediction.\\nUnfortunattly, this is only 4.7% of the data,\\n and about 18% of the target class',12, 0.05,-0.2)])","715742ed":"df2.Humidity3pm.hist(bins= 100,figsize=(10,5))","e0de0272":"def HumidityCatg(x):\n  if x<=20:\n    return '00-20'\n  elif x<= 40:\n    return '20-40'\n  elif x<= 60:\n    return '40-60'\n  elif x<= 80:\n    return '60-80'\n  else:\n     return '80+'\n\ndf2['HumidityCategory'] =  df2['Humidity3pm'].apply(lambda x: HumidityCatg(x))\ndfHmdty = df2.groupby(['HumidityCategory','RainTomorrow']).count()['Location'].to_frame().reset_index()","915111fe":"charts.StackBarCharts([(dfHmdty,'HumidityCategory','RainTomorrow','Location')],['Num. of records in each humidity category vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ChartSize=(15,7),TitleSize =25,txt2show=[('We can see that humidity under 20 almost always\\n means no rain. Humidity over 80 gives\\n a strong prediction of rain',12, 0.05,-0.15)])","99e97668":"dfAreHum=df2[df2['Humidity3pm']<40].groupby(['Area','RainTomorrow']).count()['Location'].to_frame().reset_index()","f169cea9":"charts.StackBarCharts([(dfAreHum,'Area','RainTomorrow','Location')],['Num. of records humidity<40 in each area vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ChartSize=(15,7),TitleSize =25,txt2show=[('In the north and northeast, we can assume\\n that if the humidity is under 40,\\n next day will be dry',12, 0.05,-0.15)])","e77b2f33":"dfHumlimate=df2[(df2['Humidity3pm']<40)].groupby(['Climate','RainTomorrow']).count()['Location'].to_frame().reset_index()","0da0168e":"charts.StackBarCharts([(dfHumlimate,'Climate','RainTomorrow','Location')],['Num. of records humidity<40 in each climate vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ChartSize=(15,7),TitleSize =25,txt2show=[('We can see that in climates:\\n Am and Aw\\n if humidity <40 there is almost no chance for rain.',12, 0.05,-0.15)])","45372741":"df2[(df2['Humidity3pm']<25)&((df2['Climate']=='Aw')|(df2['Climate']=='Am'))].groupby('RainTomorrow').count()['Location']","ff571bf6":"df2.Cloud3pm.hist(bins= 100,figsize=(10,5))","d713a81d":"def CloudCatg(x):\n  if x<=0:\n    return '0'\n  elif x<= 1:\n    return '0-1'\n  elif x<= 2:\n    return '2-4'\n  elif x<= 6:\n    return '4-6'\n  elif x<= 7:\n    return '6-7'\n  else:\n     return '7+'\n\ndf2['CloudCategory'] =  df2['Cloud3pm'].apply(lambda x: CloudCatg(x))\ndfCloud = df2.groupby(['CloudCategory','RainTomorrow']).count()['Location'].to_frame().reset_index()","8207c7e3":"charts.StackBarCharts([(dfCloud,'CloudCategory','RainTomorrow','Location')],['Num. of records in each Cloud category vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ChartSize=(15,7),TitleSize =25,txt2show=[('We can see that if there is no cloud\\nin the sky, the chances for rain are\\nalmost zero. Also, very few clouds\\nrarely followed by rain. \\nWhen we get more than 7 we have\\nmore than 50% chance of raining.',12, 0.02,-0.3)])","b1d93274":"def Seasons(x):\n  if x in [9,10,11]:\n    return 'Spring'\n  elif x in [12,1,2]:\n    return 'Summer'\n  elif x in [3,4,5]:\n    return 'Autumn'\n  else:\n     return 'Winter'\n\ndf2['Seasons'] =  df2['Month'].apply(lambda x: Seasons(x))\ndfseason = df2.groupby(['Seasons','RainTomorrow']).count()['Location'].to_frame().reset_index()","d64184be":"charts.StackBarCharts([(dfseason,'Seasons','RainTomorrow','Location')],['Seasons vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ChartSize=(15,7),TitleSize =25,txt2show=[('Seasons as a whole does not help us predict rain.',12, 0.40,-0.05)])","d8e38e10":"df2['SeasonArea'] = 'S: '+ df2['Seasons'] + \" C: \"+df2['Area']\ndfseasonArea = df2[df2['Seasons']=='Winter'].groupby(['SeasonArea','RainTomorrow']).count()['Location'].to_frame().reset_index()","c3258945":"charts.StackBarCharts([(dfseasonArea,'SeasonArea','RainTomorrow','Location')],['Winter vs. will it rain tomorrow? per Area'],NumRows=1,NumCol=1,ColorInt=0,ChartSize=(20,7),TitleSize =25,txt2show=[('We can see that there is a significant difference in the probability between areas',14, 0.15,-0.1)])","cba7fcd7":"df2[(df2['Seasons']=='Winter')&(df2['Area']=='North')].groupby('RainTomorrow').count()['Location']","83230676":"df2['SeasonClimate'] = 'S: '+ df2['Seasons'] + \" C: \"+df2['Climate']\ndfWinterClimate = df2[df2['Seasons']=='Winter'].groupby(['SeasonClimate','RainTomorrow']).count()['Location'].to_frame().reset_index()","836e2fb6":"charts.StackBarCharts([(dfWinterClimate,'SeasonClimate','RainTomorrow','Location')],['Winter & Climate vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ColorInt=1,ChartSize=(20,7),TitleSize =25,txt2show=[('When we zoom in, we can see that the probability for rain in winter is different from climate to climate.\\nIn the winter, there is a high probability for rainfall in Csb climate and\\n relatively high probability in Csa Climate. Average probability in Cfa and Cfa climates and\\n low likelihood for the other Climates',14, 0.01,-0.2)])","c56ec8a1":"dfAutumnClimate = df2[df2['Seasons']=='Autumn'].groupby(['SeasonClimate','RainTomorrow']).count()['Location'].to_frame().reset_index()","085a8e83":"charts.StackBarCharts([(dfAutumnClimate,'SeasonClimate','RainTomorrow','Location')],['Autumn & Climate vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ColorInt=2,ChartSize=(20,7),TitleSize =25,txt2show=[('In the Autumn, there is a high probability of rain in the Am Climate.\\nRelative high probability in Cfa & Csb climates.\\nAverage probability in Aw & Cfb climates and low probability in the other Climates',14, 0.02,-0.15)])","ced3041f":"dfSpringClimate = df2[df2['Seasons']=='Spring'].groupby(['SeasonClimate','RainTomorrow']).count()['Location'].to_frame().reset_index()","51e573b1":"charts.StackBarCharts([(dfSpringClimate,'SeasonClimate','RainTomorrow','Location')],['Spring & Climate vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ColorInt=3,ChartSize=(20,7),TitleSize =25,txt2show=[('When we zoom in, we can see that the probability\\nfor rain in Spring is different from climate to climate.\\nHowever, In the Spring, the differences between climates\\n are lower than the other seasons',14, 0.02,-0.18)])","6c00c8af":"dfSummerClimate = df2[df2['Seasons']=='Summer'].groupby(['SeasonClimate','RainTomorrow']).count()['Location'].to_frame().reset_index()","178e6d08":"charts.StackBarCharts([(dfSummerClimate,'SeasonClimate','RainTomorrow','Location')],['Summer & Climate vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ColorInt=4,ChartSize=(20,7),TitleSize =25,txt2show=[('In the Summer, there is a very high probability for rain\\nin Am & Aw Climates. Average chance for rain\\n in Cfa & Cfb climates, and low likelihood for rain\\n in Csa & Csb climates',14, 0.03,-0.2)])","e86c4b9a":"df2.Pressure9am.hist(bins= 100,figsize=(10,5))","b85a8093":"def Pressure9am(x):\n  if x<=1000:\n    return '0000-1000'\n  elif x<= 1010:\n    return '1000-1010'\n  elif x<= 1020:\n    return '1010-1020'\n  elif x<= 1030:\n    return '1020-1030'\n  else:\n     return '1030+'\n\ndf2['PressureCategory'] =  df2['Pressure9am'].apply(lambda x: Pressure9am(x))\ndfPressure = df2.groupby(['PressureCategory','RainTomorrow']).count()['Location'].to_frame().reset_index()","96135824":"charts.StackBarCharts([(dfPressure,'PressureCategory','RainTomorrow','Location')],['Num. of records in each Pressure category vs. will it rain tomorrow?'],NumRows=1,NumCol=1,ChartSize=(15,7),ColorInt=1,TitleSize =25,txt2show=[('We can see that the lower the pressure,\\nthe higher the probability of raining.\\nIf the pressure <= 1,000, there is a 64% chance\\n of raining.\\nAbove 1,030 we have ONLY a 10%\\n chance of raining.',12, 0.03,-0.25)])","305f52bd":"df2.groupby('Location').count()['Date']","74ca56d8":"class OtherChangesTransformer(BaseEstimator, TransformerMixin):\n  def fit(self,X,y=None):\n    return self\n  def transform(self, X):\n    X_new = X.copy()\n    X_new['Month'] = pd.DatetimeIndex(X_new['Date']).month.astype(str)\n    X_new['Year'] = pd.DatetimeIndex(X_new['Date']).year\n    X_new['Rainfall']=np.where(X_new['Rainfall']>100,100,X_new['Rainfall'])\n    return X_new","53027caa":"class CatgTransformer(BaseEstimator, TransformerMixin):\n  def fit(self,X,y=None):\n    return self\n  def transform(self, X):\n    X_new = X.copy()\n    X_new['HeightCategory']=  X_new['Height'].apply(lambda x: self.HeightCatg(x))\n    X_new['DisFromSeaCategory']=  X_new['Distance_from_Sea'].apply(lambda x: self.DisFromSeaCatg(x))\n    X_new['SunshineCategory']=  X_new['Sunshine'].apply(lambda x: self.SunshineCatg(x))\n    X_new['EvaporationCategory']=  X_new['Evaporation'].apply(lambda x: self.EvapCatg(x))\n    X_new['RainfallCategory'] =  X_new['Rainfall'].apply(lambda x: self.RainfallCatg(x))\n    X_new['HumidityCategory'] =  X_new['Humidity3pm'].apply(lambda x: self.HumidityCatg(x))\n    X_new['CloudCategory'] =  X_new['Cloud3pm'].apply(lambda x: self.CloudCatg(x))\n    X_new['Seasons'] =  X_new['Month'].apply(lambda x: self.Seasons(x))\n    X_new['PressureCategory'] =  X_new['Pressure9am'].apply(lambda x: self.Pressure9am(x))\n\n    return X_new\n  def Pressure9am(self,x):\n    if x<=1000:\n      return '0000-1000'\n    elif x<= 1010:\n      return '1000-1010'\n    elif x<= 1020:\n      return '1010-1020'\n    elif x<= 1030:\n      return '1020-1030'\n    else:\n      return '1030+'    \n  def Seasons(self,x):\n    if x in [9,10,11]:\n      return 'Spring'\n    elif x in [12,1,2]:\n      return 'Summer'\n    elif x in [3,4,5]:\n      return 'Autumn'\n    else:\n      return 'Winter'\n  def CloudCatg(self,x):\n    if x<=0:\n      return '0'\n    elif x<= 1:\n      return '0-1'\n    elif x<= 2:\n      return '2-4'\n    elif x<= 6:\n      return '4-6'\n    else:\n      return '6+'\n  def HumidityCatg(self,x):\n    if x<=20:\n      return '00-20'\n    elif x<= 40:\n      return '20-40'\n    elif x<= 60:\n      return '40-60'\n    elif x<= 80:\n      return '60-80'\n    else:\n      return '80+'\n  def RainfallCatg(self,x):\n    if x<=1:\n      return '00-01'\n    elif x<= 15:\n      return '01-15'\n    elif x<= 60:\n      return '15-60'\n    else:\n      return '60+'\n  def EvapCatg(self,x):\n    if x<=0.0:\n      return '00-00'\n    elif x<= 2:\n      return '00-02'\n    elif x<= 5.0:\n      return '02-05'\n    elif x<= 10.0:\n      return '05-10'\n    elif x<=30.0:\n      return '11-30'\n    else:\n      return '30+'\n  def SunshineCatg(self,x):\n    if x<=0.0:\n      return '00-00'\n    elif x<= 4:\n      return '00-04'\n    elif x<= 8.0:\n      return '04-08'\n    elif x<= 11.0:\n      return '08-11'\n    else:\n      return '11+'\n  def DisFromSeaCatg(self,x):\n    if x<=0:\n      return '000-000'\n    elif x<= 40:\n      return '000-040'\n    elif x<= 100:\n      return '040-100'\n    elif x<= 200:\n      return '100-200'  \n    else:\n      return '500+'  \n  def HeightCatg(self,x):\n    if x<=40:\n      return '0000-0040'\n    elif x<= 260:\n      return '0040-0260'\n    elif x<= 1000:\n      return '0260-1000'\n    else:\n      return '1000+'","481a2fc5":"data.sort_values(by='Date',inplace=True)\ndata_train=data.iloc[0:113747,:] # 80% train 20% test\ndata_test=data.iloc[113748:,:]","aebdeba6":"# Train dataset\n\nX_train = data_train.drop(['RISK_MM','RainTomorrow'],axis=1)\ny_train = data_train[['RainTomorrow']]\n\n# Test dataset\n\nX_test = data_test.drop(['RISK_MM','RainTomorrow'],axis=1)\ny_test = data_test[['RainTomorrow']]","00ce4e92":"DirectTransformer = DirectionTransformer()\nMergeLocation = MergeLocationTransformer(Locations)\nImputeNulls = impute_nullsTransformer(False)\nOtherChangesTrans = OtherChangesTransformer()\nCatgTrans = CatgTransformer()","b710cb1f":"X_train = DirectTransformer.transform(X_train)\nX_train = MergeLocation.transform(X_train)\nX_train = ImputeNulls.transform(X_train)\nX_train = OtherChangesTrans.transform(X_train)\nX_train = CatgTrans.transform(X_train)","9e10b148":"X_test = DirectTransformer.transform(X_test)\nX_test = MergeLocation.transform(X_test)\nX_test = ImputeNulls.transform(X_test)\nX_test = OtherChangesTrans.transform(X_test)\nX_test = CatgTrans.transform(X_test)","4fdb7de3":"df3=X_train.iloc[:,[22,3,4,5,6,7,8,9,11,14,16,18,19,21,24,27,30,31,32,33,34,35,36,37,38,39,40,41]]","5b6cccf1":"df4=pd.get_dummies(df3)","e020e4fd":"X = df4\ny = y_train","3ca1560a":"Aus_dt1 = DecisionTreeClassifier(min_samples_leaf=5)\nAus_dt1.fit(X, y)","a062e228":"charts.PlotFeatureImportance(X,Aus_dt1)","9b774f57":"X['TommorowRain_pred'] = Aus_dt1.predict(X)","7352e42f":"charts.ClassicGraphicCM(X['TommorowRain_pred'],y,Aus_dt1.classes_,normalize=True)","c722f25d":"X_test_colPick = pd.get_dummies(X_test.iloc[:,[22,3,4,5,6,7,8,9,11,14,16,18,19,21,24,27,30,31,32,33,34,35,36,37,38,39,40,41]])","904c11ed":"X_test_colPick['TommorowRain_pred'] = Aus_dt1.predict(X_test_colPick)","f28a3f69":"charts.ClassicGraphicCM(X_test_colPick['TommorowRain_pred'],y_test,Aus_dt1.classes_,normalize=True)","5e9cbb50":"class PrepareForSelectKbestTransformer(BaseEstimator, TransformerMixin):\n  def fit(self,X,y=None):\n    return self\n  def transform(self, X):\n    X_new = X.copy()\n    X_new=pd.get_dummies(X_new.drop(['Date','Location','Long','Nearest location'],axis=1))\n    X_new.MaxTemp = X_new.MaxTemp + 10\n    X_new.MinTemp = X_new.MinTemp + 10\n    X_new.Latitude = X_new.Latitude + 50\n    X_new.Temp9am = X_new.Temp9am + 10\n    X_new.Temp3pm = X_new.Temp3pm + 10\n    return X_new","16f477ec":"PreSelectKbest = PrepareForSelectKbestTransformer()","4b690c33":"KBestModel=SelectKBest(chi2, k=100)\ntmpdf=PreSelectKbest.transform(X_train)\nX_np =KBestModel.fit_transform(tmpdf, y_train)\n\n# X_np is np array and we want it go back to data frame. The new dataframe is called X_new\n\nmask = KBestModel.get_support() #list of booleans\nnew_features = [] # The list of  K best features\n\nfor bool, feature in zip(mask, tmpdf.columns):\n    if bool:\n        new_features.append(feature)\n\nX_new=pd.DataFrame(X_np,columns=new_features,index=tmpdf.index)","b043fb76":"Aus_dt2 = DecisionTreeClassifier(min_samples_leaf=5,class_weight='balanced')\nAus_dt2.fit(X_new, y_train)\n","92952766":"charts.PlotFeatureImportance(X_new,Aus_dt2)","efc8fa6e":"X_new['TommorowRain_pred'] = Aus_dt2.predict(X_new)","94b50002":"charts.ClassicGraphicCM(X_new['TommorowRain_pred'],y_train,Aus_dt2.classes_,normalize=True)","324e6bb2":"X_test2=X_test.copy()","a2086893":"tmpdf_test=PreSelectKbest.transform(X_test2)","77911637":"X_np =KBestModel.transform(tmpdf_test)\n\nmask = KBestModel.get_support() #list of booleans\nnew_features = [] # The list of  K best features\n\nfor bool, feature in zip(mask, tmpdf_test.columns):\n    if bool:\n        new_features.append(feature)\n\nX_new_test=pd.DataFrame(X_np,columns=new_features,index=tmpdf_test.index)","3a7fb7da":"X_new_test['TommorowRain_pred'] = Aus_dt2.predict(X_new_test)","ae4f9599":"charts.ClassicGraphicCM(X_new_test['TommorowRain_pred'],y_test,Aus_dt2.classes_,normalize=True)","0d8133d1":"df4=pd.get_dummies(X_train.iloc[:,[22,3,4,5,6,7,8,9,11,14,16,18,19,21,24,27,30,31,32,33,34,35,36,37,38,39,40,41]])","2b26af15":"df44 = pd.get_dummies(X_test.iloc[:,[22,3,4,5,6,7,8,9,11,14,16,18,19,21,24,27,30,31,32,33,34,35,36,37,38,39,40,41]])","7237c6b8":"scaler = MinMaxScaler()\n\nX_train2 = scaler.fit_transform(df4)\nX_test2 = scaler.transform(df44)","a7cedad0":"logreg = LogisticRegression(solver='liblinear', random_state=0)\nlogreg.fit(X_train2, y_train)","5ed38c6b":"y_pred_train = logreg.predict(X_train2)","bbb68388":"charts.ClassicGraphicCM(y_pred_train,y,logreg.classes_,normalize=True)","1e1451a7":"y_pred_test = logreg.predict(X_test2)","5b68c5da":"charts.ClassicGraphicCM(y_pred_test,y_test,logreg.classes_,normalize=True)","e8f023a3":"PreSelectKbest = PrepareForSelectKbestTransformer()","59b26e47":"rf_model1 = RandomForestClassifier(n_estimators= 200,max_depth=50,min_samples_leaf=5, class_weight= 'balanced',random_state=1234)","04d213d3":"KBestModel=SelectKBest(chi2, k=100)\nX_df=PreSelectKbest.transform(X_train)\nX_np =KBestModel.fit_transform(X_df, y_train)\n\nmask = KBestModel.get_support() #list of booleans\nnew_features = [] # The list of  K best features\n\nfor bool, feature in zip(mask, X_df.columns):\n    if bool:\n        new_features.append(feature)\n\nX_new=pd.DataFrame(X_np,columns=new_features,index=X_df.index)","f78f04ed":"rf_model1.fit(X_new, y_train)","a57a4e6f":"charts.PlotFeatureImportance(X_new,rf_model1)","6347f34a":"charts.ClassicGraphicCM(rf_model1.predict(X_new),y_train,rf_model1.classes_,normalize=True)","2514a504":"x_tsetDF=PreSelectKbest.transform(X_test)\nX_np =KBestModel.transform(x_tsetDF)\n\nmask = KBestModel.get_support() #list of booleans\nnew_features = [] # The list of  K best features\n\nfor bool, feature in zip(mask, x_tsetDF.columns):\n    if bool:\n        new_features.append(feature)\n\nX_new_test=pd.DataFrame(X_np,columns=new_features,index=x_tsetDF.index)","9d8fe2ad":" charts.ClassicGraphicCM(rf_model1.predict(X_new_test),y_test,rf_model1.classes_,normalize=True)","91ccd044":"xgb_model = XGBClassifier( random_state=1234,n_estimators= 500,max_depth=50,)\nxgb_model.fit(X_new, y_train)","229eb85f":"y_X_train=xgb_model.predict(X_new)","100efc6a":"charts.ClassicGraphicCM(y_X_train,y_train,xgb_model.classes_,normalize=True)","13fd08d9":"y_tst_prd=xgb_model.predict(X_new_test)","c1c94021":"charts.ClassicGraphicCM(y_tst_prd,y_test,xgb_model.classes_,normalize=True)\n","1e5ed72b":"class PrepareForSelectKbestTransformer(BaseEstimator, TransformerMixin):\n  def fit(self,X,y=None):\n    return self\n  def transform(self, X):\n    X_new = X.copy()\n    X_new=pd.get_dummies(X_new.drop(['Date','Location','Long','Nearest location'],axis=1))\n    X_new.MaxTemp = X_new.MaxTemp + 10\n    X_new.MinTemp = X_new.MinTemp + 10\n    X_new.Latitude = X_new.Latitude + 50\n    X_new.Temp9am = X_new.Temp9am + 10\n    X_new.Temp3pm = X_new.Temp3pm + 10\n    return X_new","80b4c490":"PreSelectKbest = PrepareForSelectKbestTransformer()","504d6edb":"KBestModel=SelectKBest(chi2, k=100)\nX_df=PreSelectKbest.transform(X_train)\nX_np =KBestModel.fit_transform(X_df, y_train)\n\nmask = KBestModel.get_support() #list of booleans\nnew_features = [] # The list of  K best features\n\nfor bool, feature in zip(mask, X_df.columns):\n    if bool:\n        new_features.append(feature)\n\nX_new=pd.DataFrame(X_np,columns=new_features,index=X_df.index)","4709b044":"x_tsetDF=PreSelectKbest.transform(X_test)\nX_np =KBestModel.transform(x_tsetDF)\n\nmask = KBestModel.get_support() #list of booleans\nnew_features = [] # The list of  K best features\n\nfor bool, feature in zip(mask, x_tsetDF.columns):\n    if bool:\n        new_features.append(feature)\n\nX_new_test=pd.DataFrame(X_np,columns=new_features,index=x_tsetDF.index)","863976a9":"X_new['Climate']=X_train['Climate']\nX_new_test['Climate']=X_test['Climate']","f45b43e1":"climates = X_new['Climate'].unique()","79177125":"PredPerClimateDir = {}\nfor clm in climates:\n    print('Start:' + str(clm))\n    X_new2 = X_new[X_new['Climate']==clm]\n    X_new_test2 = X_new_test[X_new_test['Climate']==clm]\n    y_train2 = y_train[X_new['Climate']==clm]\n    y_test2 = y_test[X_new_test['Climate']==clm]\n    X_new2=X_new2.drop(['Climate'],axis=1)\n    X_new_test2 = X_new_test2.drop(['Climate'],axis=1)\n    xgb_model2 = XGBClassifier( random_state=1234,n_estimators= 500,max_depth=50,min_child_weight=3)\n    xgb_model2.fit(X_new2, y_train2)\n    y_tst_prd = xgb_model2.predict(X_new_test2)\n    PredPerClimateDir[clm] = {'y_pred':pd.Series(y_tst_prd,name='y_pred',index=X_new_test2.index),'model':xgb_model2}","19b72511":"flag = True\nfor clm in PredPerClimateDir.keys():\n    if flag:\n        DF = pd.DataFrame(PredPerClimateDir[clm],columns=['y_pred'],index=PredPerClimateDir[clm]['y_pred'].index)\n        DF['Climate'] = clm\n        flag=False\n    else:\n        CurrDF = pd.DataFrame(PredPerClimateDir[clm],columns=['y_pred'],index=PredPerClimateDir[clm]['y_pred'].index)\n        CurrDF['Climate'] = clm\n        DF = DF.append(CurrDF)\n\nDF = DF.reindex(X_new_test2.index.tolist())","9b06e405":"charts.ClassicGraphicCM(DF['y_pred'],y_test2,xgb_model2.classes_,normalize=True)","d3526ac4":"class PrepareForSelectKbestTransformer(BaseEstimator, TransformerMixin):\n  def fit(self,X,y=None):\n    return self\n  def transform(self, X):\n    X_new = X.copy()\n    X_new=pd.get_dummies(X_new.drop(['Date','Location','Long','Nearest location'],axis=1))\n    X_new.MaxTemp = X_new.MaxTemp + 10\n    X_new.MinTemp = X_new.MinTemp + 10\n    X_new.Latitude = X_new.Latitude + 50\n    X_new.Temp9am = X_new.Temp9am + 10\n    X_new.Temp3pm = X_new.Temp3pm + 10\n    return X_new","65053c05":"PreSelectKbest = PrepareForSelectKbestTransformer()","cc7ef219":"KBestModel=SelectKBest(chi2, k=100)\nX_df=PreSelectKbest.transform(X_train)\nX_np =KBestModel.fit_transform(X_df, y_train)\n\nmask = KBestModel.get_support() #list of booleans\nnew_features = [] # The list of  K best features\n\nfor bool, feature in zip(mask, X_df.columns):\n    if bool:\n        new_features.append(feature)\n\nX_new=pd.DataFrame(X_np,columns=new_features,index=X_df.index)","c6f2b9ed":"x_tsetDF=PreSelectKbest.transform(X_test)\nX_np =KBestModel.transform(x_tsetDF)\n\nmask = KBestModel.get_support() #list of booleans\nnew_features = [] # The list of  K best features\n\nfor bool, feature in zip(mask, x_tsetDF.columns):\n    if bool:\n        new_features.append(feature)\n\nX_new_test=pd.DataFrame(X_np,columns=new_features,index=x_tsetDF.index)","0ec06fae":"X_new['rain_district']=X_train['rain_district']\nX_new_test['rain_district']=X_test['rain_district']","acb62425":"RainDistricts = X_new['rain_district'].unique()","2b8e7951":"PredPerClimateDir = {}\nfor RD in RainDistricts:\n    print('Start:' + str(RD))\n    X_new2 = X_new[X_new['rain_district']==RD]\n    X_new_test2 = X_new_test[X_new_test['rain_district']==RD]\n    y_train2 = y_train[X_new['rain_district']==RD]\n    y_test2 = y_test[X_new_test['rain_district']==RD]\n    X_new2=X_new2.drop(['rain_district'],axis=1)\n    X_new_test2 = X_new_test2.drop(['rain_district'],axis=1)\n    xgb_model2 = XGBClassifier( random_state=1234,n_estimators= 500,max_depth=50,min_child_weight=3)\n    xgb_model2.fit(X_new2, y_train2)\n    y_tst_prd = xgb_model2.predict(X_new_test2)\n    PredPerClimateDir[RD] = {'y_pred':pd.Series(y_tst_prd,name='y_pred',index=X_new_test2.index),'model':xgb_model2}","0b415653":"flag = True\nfor clm in PredPerClimateDir.keys():\n    if flag:\n        DF = pd.DataFrame(PredPerClimateDir[clm],columns=['y_pred'],index=PredPerClimateDir[clm]['y_pred'].index)\n        DF['Climate'] = clm\n        flag=False\n    else:\n        CurrDF = pd.DataFrame(PredPerClimateDir[clm],columns=['y_pred'],index=PredPerClimateDir[clm]['y_pred'].index)\n        CurrDF['Climate'] = clm\n        DF = DF.append(CurrDF)\n\nDF = DF.reindex(X_new_test2.index.tolist())","54f5aec1":"charts.ClassicGraphicCM(DF['y_pred'],y_test2,xgb_model2.classes_,normalize=True)","57eebc65":"Let explore humidity under 40 with Climate","a0debb24":"Using bins to aggregate ","89e2e20a":"The following transformer create all the category features we used in the EDA. We can run the transormer without running the EDA","9908b23b":"# Conclusion","4a80277f":"# EDA","063a5735":"## logistic regression - 85% accuracy","1d888b71":"### Running a combined models sliced by each 'climate' value - 90% accuracy","9d48c98a":"**As the Evaporation value increases we get less chances of raining**","e928b2e8":"#### Running a basic decision tree","75bb4dcd":"# Running combined models - 90% accuracy","f47a223b":"# Transformers","897520cb":"### Exploring by feature  'rain_district'","2b5c5046":"The prediction of rain was always an important task that humanity tries to deal with. The Australian Bureau of Meteorology collects a lot of data published on [kaggle](https:\/\/www.kaggle.com\/jsphyg\/weather-dataset-rattle-package).\n\n The goal is to **explore today's data and predict if tomorrow there will be rain or not.**\n\n\nIn this notebook, we enriched the data and added many new features based on geography and climate. In the EDA, we explored many features and their effect on rain the next day.\n\nThis notebook was created by:\n\n\n*   Gal Merom\n*   Hanoch Gendelman\n\n\n","f422a34d":"Lets explore season with Area","66556ead":"We enriched the data by using Australia's geography, climate, and rain districts.\n\nWe then used it to fill out all the NULLs.\n\nWe created an intensive EDA to understand the data.\nAnd then we run the models.\n\n**Results:**\n\nThe dataset is consists of 78% of \"no rain\" ver. 22% of \"rain tomorrow.\"\nWe looked at simple models such as decision tree (80% accuracy), logistic regression (85% accuracy), random forest (84% accuracy), and XGBOOST (86% accuracy).\n\nWe wanted to get to 90%, so we used a different approach:\n\n**When running a different model on each climate and rain district, we achieved our goal of 90% accuracy overall stations, climates, and rain districts.**\n\nUsing XGBOOST for running on each rain district in Australia got a 90% accuracy with 73% precision for predicting \"It will rain tomorrow.\"\n\nNotice: **We don't use RISK_MM** as a feature since RISK_MM tells you how much rain did fall tomorrow, and it is a part of the goal feature. The only place we do look at it is when looking for correlations.","3ca49558":"By value columns","06c7b5e7":"Copy the data to a new dataset to avoid accidentally change of the original data","dcab27e9":"### rain fall","6e91eb48":"### Predicting over **Test** set","8ffdfa71":"#### Predicting over the **training** set","321ad82d":"Using bins to aggregate ","0c83a000":"No location had excess records. Some have about 50% less.","617ba84c":"# Other Transofrmations - After EDA","b2cf35f1":"We use the breaking point to back up all the data manipulation we did.","37708d42":"Run all transformers on **train** data","adf99f06":"### Training the model","1a6f0d48":"It seems that we don't get much more information than using the area column","cef6c6cc":"Using bins to aggregate ","3ea232f1":"That seems to be a very good indication to help predict the target","2221179f":"![Australia climate](https:\/\/theplanningmaster.com\/wp-content\/uploads\/2021\/03\/Australia-climate.png)","5f84e5f2":"#### Exploring 'rain fall' with 'distance from the sea'","a89792b5":"Many many NULLs in almost every feature","af069eba":"![Australia](https:\/\/theplanningmaster.com\/wp-content\/uploads\/2021\/03\/Australia-map.png)","0f0be23b":"Predicting over **Test** set","31dec0cd":"# Running all using transformers and Splitting to X and Y","b07ed2e1":"#### Test dataset","222bd487":"## **Scoring**  \nWe will look at the **accuracy score** since our goal is to tell people:\n\nTake an umbrella tomorrow or not.\n\nBy saying \"no rain tomorrow\", *all the time*, we will have a **78% accuracy**, so we will look for a better result than 78%.","4b607c99":"Lets start by preparing the data - again.","d8c43f87":"Removing the tail","d38f9ed6":"### Location","534dc1a0":"Using bins to aggregate ","80f53e7e":"### Second run - Using **SelectKBest**  - 78% accuracy","ea7119ab":"#### Explore rain fall and area","a5b0c5e4":"Import the data science tools  - used for creating charts ","a6e10d66":"Run all transformers on **test** data","9eea9415":"## Read data - Original data + data enrichment file.","fa221c55":"### First run - 80% accuracy","00c452ab":"###  Cloud3pm - measered in okta. Zero means the sky have no clouds. 8 means the sky is covered","89fdec19":"### Running a combined models sliced by each **rain district** value -\n\n### **90%** accuracy with **much better score over the YES class**","3e2e4bde":"**We know for sure** that Humidity3pm <25 in the following climates will have no rain the next day:\n\n\n*   Am\n*   Aw\n\n","7b3f4054":"## Merge with the locations data","f82b5b56":"#### **Test** dataset prediction","f60d24c0":"The following transformer add month and year and reduces the rainfall to maximum of 100","53fa4229":"Combine all models results - running on **Test** set","7fe8387e":"###  Exploring by feature  'distance from the sea'","b68ba807":"### humidity3pm","806a078f":"#### Pressure9am","77936908":"*   The chances of raining in the central area of Australia is only 7%\n*   The chances of raining on the Island east of Australia is about a third higher than the rest of the areas","3eb7bfb0":"#### Exploring humidity under 40 with area","c527afa8":"## Random forest - 84% accuracy","7305f1f4":"Predicting over the **TRAIN** dataset","7abd3fed":"### Exploring by feature 'area'","ca5f4359":"Using bins to aggregate ","564f0cf2":"Predicting over **Training** set","2743b5c4":"Using bins to aggregate ","a6922a86":"## Decision tree Classifier - 80% accuracy","c47718a5":"**Create a model for each climate value**","a502dd34":"Lets start by preparing the data - again.","0ec2b87a":"## Exploring NULLs","51fa35fc":"## Breaking point","f5d08883":"#  Notice: we don't use 'RISK_MM' for predictions.\n**'RISK_MM' is the amount of rain that will rain tomorrow so, we assume it is part of the target features**","1d6c720c":"Merge the original data and the location data (the data enrichment)","f335258b":"### Predicting over **Test** set","4b2c1c40":"Using bins to aggregate ","12f827d9":"### 'Month' -  defining [seasons](http:\/\/www.bom.gov.au\/climate\/glossary\/seasons.shtml)","890cbed3":"We can assume that in the **winter** there is no rain in the North area !!","d1c5ac96":"# Imports","c2b395a2":"Split the data to training set and test set by date.","8669868a":"## Correlations","cfa59ff2":"Make sure there are no NULLs.","0af0334a":"Find the number of stations in each rain district.","3d0ae54d":"# Models","9e5bc897":"## Exploring original features with high correlation","c48e882a":"**Create a model for each rain_district value**","7419f2d1":"## Exploring the differences between the weather stations by locations","cfc151b5":"Check if, after the split, we have the same class ratio.","cd1ab609":"# Split to train and test - for EDA","f882db78":"#### Running the transformation and the model","30dac369":"#### feature_importances","4dcee441":"![Rain districts](https:\/\/theplanningmaster.com\/wp-content\/uploads\/2021\/03\/Australia-rain-district.png)","15863593":"Combine all models results - running on **Test** set","06b2795c":"### Exploring by feature ' Climate'","79d4e304":"## XGBOOST - 86% accuracy","75e865bb":"### Evaporation","60a37047":"Predicting over **Training** set","86b5805d":"#### Transformer  - Remove negative values so selektkbest can work","11fae587":"#### Picking columns **manually**","6172a08b":"Using bins to aggregate ","a711147c":"Number of weather stations","51d32b16":"The EDA uses data that includes target columns. So from this section on, we will split the data again, run all the transformers on the train, and test data to avoid any data leakage.","34e68692":"### Exploring by feature 'Height'","1e8daf6c":"## Impute NULLs","1f4d8a20":"## Change \"wind Direction\" columns to integer","763c42c3":"#### feature_importances","9c261fa0":"#### feature_importances","cc694080":"Predicting over **Training** set","57b59a36":"New instance of each transformer","c1fdea20":"Number of stations in each climate","a7b895d5":"### Sunshine","109afb93":"Exploring the correlations between the different parameters:\n\n\n*   Obviously, Temp. parameters correlate to other Temp parameters\n*   We'll explore the parameters that correlate to the target parameter RISK_MM:\n\n\n1.   The most correlated parameter is Rainfall. So if there were rainfall today, we would see a 30% correlation to tomorrow's rain's value.\n2.   The next correlated parameter is obviously sunshine\n\nWe need to remember that the correlation looks for a connection between 2 sets of numbers. But we are looking for a binary result was there rain the next day or not. Look at the chart of the evaporation parameter. Although the correlation is only 0.04, the increase in evaporation reduces the chance of raining.\n\nAdding a binary column for RainTomorrow will help us find the correlation.","750ade92":"We have many features with many Nulls. The worst have 47% Nulls.\n\nTo fill this number, we will take the missing data from the following features by this order:\n\n(stop searching if a non NULL value exists)\n \n\n1.   A very close station\n2.   The nearest station\n3.   Stations that have the same climate (Average)\n4.   Stations that have the same 'Area' (Average)\n5.   If all of the above is NULL, then put zero\n\n"}}