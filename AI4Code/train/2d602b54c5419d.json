{"cell_type":{"6cdd24bf":"code","433aa2b6":"code","fe8264c0":"code","dc60c453":"code","5db53e96":"code","e45e4f0d":"code","bb076c85":"code","030627bf":"code","2ba183ac":"code","390ed837":"code","b179549f":"code","d7e5e28d":"code","abd412fc":"code","27e83e3b":"code","def2ccc4":"code","6e6df2d2":"code","148e1095":"code","ebc5fcf9":"code","5c5e263c":"markdown"},"source":{"6cdd24bf":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","433aa2b6":"import torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torchvision import datasets, transforms\nimport random\n\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\n\nrandom.seed(777)\ntorch.manual_seed(777)\nif device == 'cuda':\n    torch.cuda.manual_seed(777)","fe8264c0":"#\ub370\uc774\ud130 \ubd88\ub7ec\uc624\uae30\ntrain = pd.read_csv('..\/input\/2021-airlines-customer-satisfaction-prediction\/train.csv')\ntest = pd.read_csv('..\/input\/2021-airlines-customer-satisfaction-prediction\/test.csv')","dc60c453":"#\ub370\uc774\ud130 \ud655\uc778\ud558\uae30\ntrain.info()\ntest.info()","5db53e96":"train","e45e4f0d":"test","bb076c85":"#\ud0c0\uac9f \ub77c\ubca8 \ubd84\ub9ac(satisfaction) & \ud544\uc694\uc5c6\ub294 \ub77c\ubca8 \uc81c\uac70(ID) \ntrain_x = train.iloc[:,1:-1]\ntrain_y = train.iloc[:,-1]\ntest = test.iloc[:,1:]","030627bf":"#nan\uac12\uc774 \uc5bc\ub9c8\ub098 \uc788\ub294\uc9c0 \ud655\uc778\ntrain_nan_idx = train_x[train_x['Arrival Delay in Minutes'].isnull()].index\nprint(len(train_nan_idx))\ntest_nan_idx = test[test['Arrival Delay in Minutes'].isnull()].index\nprint(len(test_nan_idx))","2ba183ac":"#nan\uac12\uc744 \ubc14\ub85c \uc9c1\uc804 \uac12\uc73c\ub85c \ucc44\uc6b0\uae30\ntrain_x['Arrival Delay in Minutes'].fillna(method='pad', inplace=True)\ntest['Arrival Delay in Minutes'].fillna(method='pad', inplace=True)","390ed837":"#nan\uac12\uc774 \uc798 \uc81c\uac70\ub418\uc5c8\ub294\uc9c0 \ud655\uc778\ntrain_nan_idx = train_x[train_x['Arrival Delay in Minutes'].isnull()].index\nprint(len(train_nan_idx))\ntest_nan_idx = test[test['Arrival Delay in Minutes'].isnull()].index\nprint(len(test_nan_idx))","b179549f":"#object\ud615 \uceec\ub7fc \uc2e4\uc218\ud654\nfrom sklearn.preprocessing import LabelEncoder\ncolumns = ['Gender', 'Customer Type', 'Type of Travel', 'Class']\ntraintest = pd.concat([train_x, test], axis=0)\nfor column in columns:\n    le = LabelEncoder()\n    le.fit(traintest[column])\n    train_x[column] = le.transform(train_x[column])\n    test[column] = le.transform(test[column])\n    \nle = LabelEncoder()\ntrain_y = le.fit_transform(train_y)","d7e5e28d":"#\uc804\ucc98\ub9ac \uc644\ub8cc\ub41c \ub370\uc774\ud130 \ud655\uc778\ud558\uae30\ntrain_x.info()\ntest.info()","abd412fc":"#\ubaa8\ub378\uc5d0 \ub123\uae30 \uc704\ud55c \ub370\uc774\ud130 \ubcc0\ud615\ntrain_x = np.array(train_x)\ntrain_y = np.array(train_y)\ntest = np.array(test)\n\ntrain_x = torch.FloatTensor(train_x).to(device)\ntrain_y = torch.LongTensor(train_y).to(device) \ntest = torch.FloatTensor(test).to(device)\n\nprint(train_x.shape)\nprint(train_y.shape)\nprint(test.shape)","27e83e3b":"#\ubaa8\ub378 \ub9cc\ub4e4\uae30\ntrain_dataset = torch.utils.data.TensorDataset(train_x,train_y)\ndata_loader = torch.utils.data.DataLoader(dataset = train_dataset,batch_size = 28, shuffle = True, drop_last=True)\n\nlinear1 = torch.nn.Linear(19,512,bias=True)\nlinear2 = torch.nn.Linear(512,512,bias=True)\nlinear3 = torch.nn.Linear(512,512,bias=True)\nlinear4 = torch.nn.Linear(512,2,bias=True)\n\nrelu = torch.nn.ReLU()\ndropout = torch.nn.Dropout(p=0.3)\n\ntorch.nn.init.xavier_uniform_(linear1.weight) \ntorch.nn.init.xavier_uniform_(linear2.weight)\ntorch.nn.init.xavier_uniform_(linear3.weight)\ntorch.nn.init.xavier_uniform_(linear4.weight)\n\nmodel = torch.nn.Sequential(linear1,relu,dropout,\n                            linear2,relu,dropout,\n                            linear3,relu,dropout,\n                            linear4).to(device) \n\n# \uc190\uc2e4\ud568\uc218\uc640 \ucd5c\uc801\ud654 \ud568\uc218\nloss = torch.nn.CrossEntropyLoss().to(device) \noptimizer = torch.optim.Adam(model.parameters(), lr=0.0001)","def2ccc4":"#\ubaa8\ub378 \ud559\uc2b5\ntotal_epoch = 500  #100->50 100->200\ntotal_batch = len(data_loader)\nmodel.train()\n\nfor epoch in range(total_epoch+1): \n    avg_cost = 0\n    for X,Y in data_loader:\n        X = X.to(device)\n        Y = Y.to(device)\n\n        optimizer.zero_grad()\n        hypothesis = model(X)\n        cost = loss(hypothesis,Y) \n        cost.backward()\n        optimizer.step()\n\n        avg_cost += cost\/total_batch\n        \n    if epoch % 10 == 0:\n        print('Epoch {:4d} \/ Cost: {:.6f}'.format(epoch, avg_cost))","6e6df2d2":"#yy=train_y.cpu().numpy()\n#print(yy)","148e1095":"#y_pred = model(train_x)\n#y_pred=torch.argmax(y_pred, 1).cpu().numpy()\n#print(y_pred)\n#from sklearn.metrics import accuracy_score\n#accuracy_score(yy, y_pred)","ebc5fcf9":"#\ubaa8\ub378 \uc608\uce21\nwith torch.no_grad(): \n    model.eval()\n    prediction = model(test)\n    prediction = torch.argmax(prediction, 1) \n\n# \uc81c\ucd9c\ud30c\uc77c\uc5d0 \uc800\uc7a5\nsubmit = pd.read_csv('..\/input\/2021-airlines-customer-satisfaction-prediction\/sample_submit.csv')\n\nprediction = prediction.cpu().numpy()\nprediction = le.inverse_transform(prediction)\n\nsubmit['satisfaction']=prediction\nsubmit.to_csv('submit.csv', index = False)\nsubmit","5c5e263c":"'Arrival Delay in Minutes' \uceec\ub7fc\ub9cc \ub370\uc774\ud130\uc758 \uc218\uac00 \ub2e4\ub974\ub2e4.\n\ntrain['Arrival Delay in Minutes'].unique()\n\ntest['Arrival Delay in Minutes'].unique()\n\n\ub85c \ud655\uc778\ud574\ubcf4\uba74, nan\uac12\uc774 \uc874\uc7ac\ud558\ub294 \uac83\uc744 \ud655\uc778\ud560 \uc218 \uc788\ub2e4."}}