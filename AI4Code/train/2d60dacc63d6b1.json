{"cell_type":{"23106ea3":"code","a053e7c1":"code","4657dbb6":"code","a6c33d59":"code","2d128248":"code","3b8a56e7":"code","b570dff2":"code","7c74e8cc":"code","b9705413":"code","e13bb375":"code","6fc46785":"code","b963cd57":"code","abcd54eb":"code","1dc3cca4":"code","940ca7b1":"code","92d587cb":"code","682e1562":"code","1bbadba7":"code","5873c72b":"code","5c46da00":"code","75327637":"code","c5e195cf":"code","4c2af3e5":"code","911ed921":"code","a3fd0bf7":"code","b4d8aecd":"code","76b027f1":"markdown","5f7d4916":"markdown","501582a2":"markdown"},"source":{"23106ea3":"from numpy import *\nimport numpy\nnumpy.version.version","a053e7c1":"import cv2\nimport numpy\nimport matplotlib.pyplot as plt\nfrom scipy.cluster.vq import *\nimg = cv2.imread('..\/input\/defected-brain-image\/meningioma-care-scan.jpg')\nplt.imshow(img)","4657dbb6":"center = 3\ngray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)\ndatalab = cv2.cvtColor(img,cv2.COLOR_BGR2LAB)\n","a6c33d59":"column = len(datalab[1,])\nrows = len(datalab)","2d128248":"column","3b8a56e7":"rows","b570dff2":"ab = datalab[:,:,2:3]\n","7c74e8cc":"ab = reshape(ab,rows*column,order=\"C\")\nprint(ab.shape)","b9705413":"ans ,arr = kmeans2(ab.astype(float),center,iter=15,missing='warn')","e13bb375":"cluster = []\na = []\nfor i in range(center):\n    cluster.append(a)\n    a = []","6fc46785":"arr = reshape(arr,(rows,column),order='C')","b963cd57":"img_backup = img.copy()\nprint (ans)","abcd54eb":"for i in range(rows):\n    for j in range(column):\n        img_backup[i,j] = [0,0,0]","1dc3cca4":"for z in range(center):\n    for x in range(rows):\n        for y in range(column):\n            if arr[x,y] == z:\n                #print z\n                img_backup[x,y] = img[x,y]\n                #cluster[z].append([x,y])\n    cv2.imwrite('%s.jpg'%z,img_backup)\n    print ('cluster%s'%z)","940ca7b1":"img_0 = cv2.imread('.\/0.jpg')\nimg_0 = img_0[:,:,0]\nplt.imshow(img_0)","92d587cb":"img_1 = cv2.imread('.\/1.jpg')\nimg_1 = img_1[:,:,0]\nplt.imshow(img_1)","682e1562":"img_2 = cv2.imread('.\/2.jpg')\nimg_2 = img_2[:,:,0]\nplt.imshow(img_2)","1bbadba7":"img_0.shape","5873c72b":"import cv2\nimport numpy\nfrom scipy.cluster.vq import *\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import ndimage as ndi\n\nfrom skimage import data\nfrom skimage.metrics import (adapted_rand_error,\n                              variation_of_information)\nfrom skimage.filters import sobel\nfrom skimage.measure import label\nfrom skimage.util import img_as_float\nfrom skimage.feature import canny\nfrom skimage.morphology import remove_small_objects\nfrom skimage.segmentation import (morphological_geodesic_active_contour,\n                                  inverse_gaussian_gradient,\n                                  watershed,\n                                  mark_boundaries)\n \nimport matplotlib.pyplot as plt\nfrom skimage import data, img_as_float\nfrom skimage.segmentation import chan_vese","5c46da00":"#image = img_as_float(data.camera())\n# Feel free to play around with the parameters to see how they impact the result\ncv = chan_vese(img_0, mu=0.25, lambda1=1, lambda2=1, tol=1e-3, max_iter=40,\n               dt=0.5, init_level_set=\"checkerboard\", extended_output=True)\n\nfig, axes = plt.subplots(2, 2, figsize=(8, 8))\nax = axes.flatten()\n\nax[0].imshow(img_0, cmap=\"gray\")\nax[0].set_axis_off()\nax[0].set_title(\"Original Image\", fontsize=12)\n\nax[1].imshow(cv[0], cmap=\"gray\")\nax[1].set_axis_off()\ntitle = \"Chan-Vese segmentation - {} iterations\".format(len(cv[2]))\nax[1].set_title(title, fontsize=12)\n\nax[2].imshow(cv[1], cmap=\"gray\")\nax[2].set_axis_off()\nax[2].set_title(\"Final Level Set\", fontsize=12)\n\nax[3].plot(cv[2])\nax[3].set_title(\"Evolution of energy over iterations\", fontsize=12)\n\nfig.tight_layout()\nplt.show()","75327637":"img_cv = cv[1]\nplt.imshow(img_cv, cmap='gray')","c5e195cf":"elevation_map = sobel(img_cv)\nmarkers = np.zeros_like(img_cv)\nmarkers[img_0 < 30] = 1\nmarkers[img_0 > 150] = 2\nim_true = watershed(elevation_map, markers)\nim_true = ndi.label(ndi.binary_fill_holes(im_true - 1))[0]\nedges = sobel(img_cv)\nim_test1 = watershed(edges, markers=468, compactness=0.001)\nedges = canny(img_cv)\nfill_coins = ndi.binary_fill_holes(edges)\nim_test2 = ndi.label(remove_small_objects(fill_coins, 21))[0]\n\nimage = img_as_float(img_cv)\ngradient = inverse_gaussian_gradient(image)\ninit_ls = np.zeros(image.shape, dtype=np.int8)\ninit_ls[10:-10, 10:-10] = 1\nim_test3 = morphological_geodesic_active_contour(gradient, iterations=500,\n                                                 init_level_set=init_ls,\n                                                 smoothing=1, balloon=-1,\n                                                 threshold=0.69)\nim_test3 = label(im_test3)\n\nmethod_names = ['Compact watershed', 'Canny filter',\n                'Morphological Geodesic Active Contours']\nshort_method_names = ['Compact WS', 'Canny', 'GAC']\n\nprecision_list = []\nrecall_list = []\nsplit_list = []\nmerge_list = []\nfor name, im_test in zip(method_names, [im_test1, im_test2, im_test3]):\n    error, precision, recall = adapted_rand_error(im_true, im_test)\n    splits, merges = variation_of_information(im_true, im_test)\n    split_list.append(splits)\n    merge_list.append(merges)\n    precision_list.append(precision)\n    recall_list.append(recall)\n    print(f\"\\n## Method: {name}\")\n    print(f\"Adapted Rand error: {error}\")\n    print(f\"Adapted Rand precision: {precision}\")\n    print(f\"Adapted Rand recall: {recall}\")\n    print(f\"False Splits: {splits}\")\n    print(f\"False Merges: {merges}\")\n\nfig, axes = plt.subplots(2, 3, figsize=(9, 6), constrained_layout=True)\nax = axes.ravel()\n\nax[0].scatter(merge_list, split_list)\nfor i, txt in enumerate(short_method_names):\n    ax[0].annotate(txt, (merge_list[i], split_list[i]),\n                   verticalalignment='center')\nax[0].set_xlabel('False Merges (bits)')\nax[0].set_ylabel('False Splits (bits)')\nax[0].set_title('Split Variation of Information')\n\nax[1].scatter(precision_list, recall_list)\nfor i, txt in enumerate(short_method_names):\n    ax[1].annotate(txt, (precision_list[i], recall_list[i]),\n                   verticalalignment='center')\nax[1].set_xlabel('Precision')\nax[1].set_ylabel('Recall')\nax[1].set_title('Adapted Rand precision vs. recall')\nax[1].set_xlim(0, 1)\nax[1].set_ylim(0, 1)\n\nax[2].imshow(mark_boundaries(image, im_true))\nax[2].set_title('True Segmentation')\nax[2].set_axis_off()\n\nax[3].imshow(mark_boundaries(image, im_test1))\nax[3].set_title('Compact Watershed')\nax[3].set_axis_off()\n\nax[4].imshow(mark_boundaries(image, im_test2))\nax[4].set_title('Edge Detection')\nax[4].set_axis_off()\n\nax[5].imshow(mark_boundaries(image, im_test3))\nax[5].set_title('Morphological GAC')\nax[5].set_axis_off()\n\nplt.show()\n","4c2af3e5":"pic = plt.imread('..\/input\/skin-cancer\/cccc.jpg')\/255  # dividing by 255 to bring the pixel values between 0 and 1\nprint(pic.shape)\nplt.imshow(pic)","911ed921":"pic_n = pic.reshape(pic.shape[0]*pic.shape[1], pic.shape[2])\npic_n.shape","a3fd0bf7":"from sklearn.cluster import KMeans\nkmeans = KMeans(n_clusters=2, random_state=0).fit(pic_n)\npic2show = kmeans.cluster_centers_[kmeans.labels_]","b4d8aecd":"cluster_pic = pic2show.reshape(pic.shape[0], pic.shape[1], pic.shape[2])\nplt.imshow(cluster_pic)","76b027f1":"# **2nd way to do things ! **","5f7d4916":"**from  numpy import ***\n\n****this code comes with an error like this : ValueError: Non-string object detected for the array ordering. Please pass in 'C', 'F', 'A', or 'K' instead\n\n==> this error means that you are using an old version of numpy ","501582a2":"Credits to : https:\/\/github.com\/xiaoyu-z\/KNN-segmentation\/blob\/master\/segmentation.py"}}