{"cell_type":{"309a7495":"code","69d6295f":"code","121c154f":"code","da7abe39":"code","fa6a9de0":"code","cbd06571":"code","3f4bf7a4":"code","fdce1949":"code","9bee5ad4":"code","19f22ce9":"code","9595a3a4":"code","b672c519":"code","0c415bf3":"code","e2d17c1f":"code","74ed2dc2":"code","7ab3b84f":"code","8ed7ebf9":"code","3b1aebbe":"code","eae0268f":"code","dafb1760":"code","370a0893":"code","f4bf4b7b":"code","fa028b38":"code","593f59a7":"code","3d3bc062":"code","a4e0e53e":"code","87e3e246":"code","c8420077":"code","f00f19b1":"code","de74bef6":"code","5cf58d08":"code","a1fdd4c2":"code","c47bdfb6":"code","6445d5cb":"code","3411d65a":"code","8de14415":"code","2955c56f":"code","e3b9f29c":"code","b5a5324b":"code","cabed0f8":"code","5d6b52a5":"code","4fabbf77":"code","f33d6894":"code","9ec5f45a":"code","7b9076ba":"code","353af5a7":"code","3c0c6889":"code","6c779d6f":"code","e3c9a05b":"code","9a6efc0d":"code","fad1361a":"code","8c29ff2e":"code","9594e1a0":"code","b88bfbfe":"code","a8a44021":"code","aac7b3e6":"code","dc3ecf4b":"code","e1ce9082":"code","a39b4f04":"code","b68d2b8e":"code","47a954eb":"code","be629fa0":"code","15643973":"code","b754dace":"code","66009276":"code","28f41fac":"code","ff2eb20c":"code","d462561a":"code","3f1a588c":"code","ae192d71":"markdown","991cbb47":"markdown","735a3e5b":"markdown"},"source":{"309a7495":"!pip install jovian --upgrade --quiet","69d6295f":"import sklearn.datasets\nimport numpy as np\n","121c154f":"breast_cancer = sklearn.datasets.load_breast_cancer()","da7abe39":"X = breast_cancer.data\nY = breast_cancer.target","fa6a9de0":"print(X)\nprint(Y)","cbd06571":"print(X.shape,Y.shape)","3f4bf7a4":"import pandas as pd","fdce1949":"data = pd.DataFrame(breast_cancer.data, columns=breast_cancer.feature_names)","9bee5ad4":"data['class'] = breast_cancer.target","19f22ce9":"data.head()","9595a3a4":"data.describe()","b672c519":"print(data['class'].value_counts())","0c415bf3":"print(breast_cancer.target_names)","e2d17c1f":"data.groupby('class').mean()","74ed2dc2":"from sklearn.model_selection import train_test_split","7ab3b84f":"X = data.drop('class',axis=1)\nY = data['class']","8ed7ebf9":"type(X)","3b1aebbe":"X_train, X_test, Y_train, Y_test = train_test_split(X,Y)","eae0268f":"print(X.shape, X_train.shape, X_test.shape)","dafb1760":"print(Y.shape, Y_train.shape, Y_test.shape)","370a0893":"X_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size = 0.1)","f4bf4b7b":"print(Y.mean(), Y_train.mean(), Y_test.mean())","fa028b38":"X_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size = 0.1, stratify=Y)\n#as in the previous cell, the ratio of malignant cases in train and test set is not close\n#so stratify is used for more accuracy","593f59a7":"print(Y.mean(), Y_train.mean(), Y_test.mean())","3d3bc062":"print(X.mean(), X_train.mean(),X_test.mean())","a4e0e53e":"X_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size = 0.1, stratify=Y, random_state=1)","87e3e246":"import matplotlib.pyplot as plt","c8420077":"plt.plot(X_train.T,'*')\nplt.xticks(rotation='vertical')\nplt.show()","f00f19b1":"plt.plot(X_test.T,'*')\nplt.xticks(rotation='vertical')\nplt.show()","de74bef6":"X_binarised_3_train = X_train['mean area'].map(lambda x:0 if x<1000 else 1)","5cf58d08":"plt.plot(X_binarised_3_train,'*')\nplt.show()","a1fdd4c2":"X_binarised_train = X_train.apply(pd.cut,bins=2,labels=[0,1])","c47bdfb6":"plt.plot(X_binarised_train.T,'*')\nplt.xticks(rotation='vertical')\nplt.show()","6445d5cb":"X_binarised_test = X_test.apply(pd.cut,bins=2,labels=[0,1])","3411d65a":"X_binarised_test = X_binarised_test.values\nX_binarised_train = X_binarised_train.values","8de14415":"type(X_binarised_test)","2955c56f":"b = 3\ni = 100\nif(np.sum(X_binarised_train[100,:])>=b):\n    print('Malignant')\nelse:\n    print('Benign')\n    \nif(Y_train[i]==1):\n    print('Ground truth is malignant')\nelse:\n    print('Ground truth is benign')\n    ","e3b9f29c":"from random import randint","b5a5324b":"b = 3\ni = randint(0,X_binarised_train.shape[0])\nprint('For row',i)\nif(np.sum(X_binarised_train[100,:])>=b):\n    print('Malignant')\nelse:\n    print('Benign')\n    \nif(Y_train[i]==1):\n    print('Ground truth is malignant')\nelse:\n    print('Ground truth is benign')","cabed0f8":"b=3\n\nY_pred_train = []\naccurate_rows = 0\n\nfor x,y in zip(X_binarised_train, Y_train):\n    y_pred = (np.sum(x)>=b)\n    Y_pred_train.append(y_pred)\n    accurate_rows += (y==y_pred)\n    \nprint(accurate_rows,accurate_rows\/X_binarised_train.shape[0])","5d6b52a5":"print(X_binarised_train.shape[1])","4fabbf77":"for b in range(X_binarised_train.shape[1]+1):\n    Y_pred_train = []\n    accurate_rows = 0\n\n    for x,y in zip(X_binarised_train, Y_train):\n        y_pred = (np.sum(x)>=b)\n        Y_pred_train.append(y_pred)\n        accurate_rows += (y==y_pred)\n    \n    print(b,accurate_rows\/X_binarised_train.shape[0])","f33d6894":"X_binarised_train = X_train.apply(pd.cut,bins=2,labels=[1,0])\nX_binarised_test = X_test.apply(pd.cut,bins=2,labels=[1,0])","9ec5f45a":"X_binarised_test = X_binarised_test.values\nX_binarised_train = X_binarised_train.values","7b9076ba":"for b in range(X_binarised_train.shape[1]+1):\n    Y_pred_train = []\n    accurate_rows = 0\n\n    for x,y in zip(X_binarised_train, Y_train):\n        y_pred = (np.sum(x)>=b)\n        Y_pred_train.append(y_pred)\n        accurate_rows += (y==y_pred)\n    \n    print(b,accurate_rows\/X_binarised_train.shape[0])","353af5a7":"from sklearn.metrics import accuracy_score","3c0c6889":"b = 28\nY_pred_test = []\n\nfor x in X_binarised_test:\n    y_pred = (np.sum(x)>=b)\n    Y_pred_test.append(y_pred)\naccuracy = accuracy_score(Y_pred_test,Y_test)\nprint(b,accuracy)","6c779d6f":"class MPNeuron:\n    \n    def __init__(self):\n        self.b = None\n        \n    def model(self,x):\n        return(sum(x)>=self.b)\n    \n    def predict(self,X):\n        Y = []\n        for x in X:\n            result = self.model(x)\n            Y.append(result)\n        return np.array(Y)\n    \n    def fit(self,X,Y):\n        accuracy = {}\n        \n        for b in range(X.shape[1]+1):\n            self.b = b\n            Y_pred = self.predict(X)\n            accuracy[b] = accuracy_score(Y_pred,Y)\n            \n        best_b = max(accuracy,key=accuracy.get)\n        self.b = best_b\n        \n        print('Optimal value of b',best_b)\n        print('Highest Accuracy is',accuracy[best_b])","e3c9a05b":"mp_neuron = MPNeuron()\nmp_neuron.fit(X_binarised_train,Y_train)","9a6efc0d":"Y_test_pred = mp_neuron.predict(X_binarised_test)\naccuracy_test = accuracy_score(Y_test_pred,Y_test)","fad1361a":"print(accuracy_test)","8c29ff2e":"class Perceptron:\n    def __init__(self):\n        self.w = None\n        self.b = None\n        \n    def model(self,x):\n        return 1 if(np.dot(self.w,x)>=self.b) else 0\n    \n    def predict(self,X):\n        Y = []\n        for x in X:\n            result = self.model(x)\n            Y.append(result)\n        return np.array(Y)\n    \n    def fit(self,X,Y):\n        self.w = np.ones(X.shape[1])\n        self.b = 0\n        \n        for x,y in zip(X,Y):\n            y_pred = self.model(x)\n            if y == 1 and y_pred == 0:\n                self.w = self.w + x\n                self.b = self.b + 1\n            elif y == 0 and y_pred == 1:\n                self.w = self.w - x\n                self.b = self.b - 1\n        ","9594e1a0":"perceptron = Perceptron()","b88bfbfe":"X_train = X_train.values\nX_test = X_test.values","a8a44021":"perceptron.fit(X_train,Y_train)","aac7b3e6":"plt.plot(perceptron.w)\n","dc3ecf4b":"Y_pred_train = perceptron.predict(X_train)\nprint(accuracy_score(Y_pred_train,Y_train))","e1ce9082":"Y_pred_test = perceptron.predict(X_test)\nprint(accuracy_score(Y_pred_test,Y_test))","a39b4f04":"class Perceptron:\n    def __init__(self):\n        self.w = None\n        self.b = None\n        \n    def model(self,x):\n        return 1 if(np.dot(self.w,x)>=self.b) else 0\n    \n    def predict(self,X):\n        Y = []\n        for x in X:\n            result = self.model(x)\n            Y.append(result)\n        return np.array(Y)\n    \n    def fit(self,X,Y,epochs=1,lr=1):\n        self.w = np.ones(X.shape[1])\n        self.b = 0\n        \n        accuracy = {}\n        max_accuracy = 0\n        \n        wt_matrix = []\n        \n        for i in range(epochs):\n            for x,y in zip(X,Y):\n                y_pred = self.model(x)\n                if y == 1 and y_pred == 0:\n                    self.w = self.w + lr * x\n                    self.b = self.b + lr * 1\n                elif y == 0 and y_pred == 1:\n                    self.w = self.w - lr * x\n                    self.b = self.b - lr * 1\n            \n            wt_matrix.append(self.w)    \n                    \n            accuracy[i] = accuracy_score(self.predict(X),Y)\n            if (accuracy[i]>max_accuracy):\n                max_accuracy = accuracy[i]\n                chkptw = self.w\n                chkptb = self.b\n        \n        self.w = chkptw\n        self.b = chkptb\n        \n        print(max_accuracy)\n        plt.plot(list(accuracy.values()))\n        return np.array(wt_matrix)","b68d2b8e":"perceptron = Perceptron()","47a954eb":"wt_matrix = perceptron.fit(X_train,Y_train,100)","be629fa0":"Y_pred_train = perceptron.predict(X_train)\nprint(accuracy_score(Y_pred_train,Y_train))","15643973":"Y_pred_test = perceptron.predict(X_test)\nprint(accuracy_score(Y_pred_test,Y_test))","b754dace":"plt.plot(wt_matrix[-1,:])\nplt.show()","66009276":"%matplotlib inline\nfrom matplotlib import animation, rc\nfrom IPython.display import HTML","28f41fac":"# First set up the figure, the axis, and the plot element we want to animate\nfig, ax = plt.subplots()\n\nax.set_xlim(( 0, wt_matrix.shape[1]))\nax.set_ylim((-10000, 25000))\n\nline, = ax.plot([], [], lw=2)","ff2eb20c":"# animation function. This is called sequentially\ndef animate(i):\n    x = list(range(wt_matrix.shape[1]))\n    y = wt_matrix[i,:]\n    line.set_data(x, y)\n    return (line,)","d462561a":"# call the animator. blit=True means only re-draw the parts that have changed.\nanim = animation.FuncAnimation(fig, animate, frames=100, interval=200, blit=True)","3f1a588c":"HTML(anim.to_html5_video())","ae192d71":"> **MP NEURON**","991cbb47":"$y = 1,\\mbox{if}\\sum_i w_i x_i >=b$\n\n$y = 0,\\mbox{otherwise}$","735a3e5b":"> **PERCEPTRON CLASS**"}}