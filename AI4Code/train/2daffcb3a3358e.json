{"cell_type":{"d0a2c860":"code","0074e8bf":"code","9586c8ed":"code","11ce6538":"code","79d45831":"code","beb62fe7":"code","4839e119":"code","05b254f9":"code","af7d4f8e":"code","dbb940f5":"code","53c01c96":"code","29a1616d":"code","7ca0d457":"code","edcadb25":"code","e75b4567":"code","68a63066":"code","790dd842":"code","c3cc768a":"code","bce44394":"code","d8e8d564":"code","2c218b3f":"code","c4df4f3c":"code","5765f355":"code","38310687":"code","a6cf479b":"code","94c5ce1b":"code","a6117ce0":"code","c4d3cc79":"code","c9873b3e":"code","559e53c2":"code","49f88f4c":"code","9d3a935d":"code","1fd50391":"code","8cb7aadf":"code","df6dc150":"code","6b4e4331":"code","118b6e03":"code","b4f77486":"code","679a267b":"code","fd00d2fd":"code","24e138c6":"code","938d6c52":"code","42eadb99":"code","e47dee44":"code","beb2389f":"code","f0b3b2e9":"code","fbce9cde":"code","92889f7b":"code","7380462e":"code","8a2e7bfb":"code","eaceb29a":"code","3027d9b4":"code","e6bb4c22":"code","5563390d":"code","0f986505":"code","1dc25f76":"code","29d2d504":"code","0f3eff6a":"code","1d12422f":"code","ff172616":"code","d8f9d5f5":"code","2ce38ce3":"code","0641fc3f":"code","5161750f":"code","59419aa6":"code","b44e4ac1":"code","3f5da53e":"code","0f6e6bfa":"code","d4a4efc3":"code","b33e5a3c":"code","343a6df3":"code","a31623ae":"code","b858118b":"code","d4dc9e02":"code","391194aa":"code","8df18aa7":"code","b4cc03e8":"code","89334a3e":"code","86ebbb9b":"code","02bacf0c":"code","ab77a73c":"code","05e6108f":"code","76d570d5":"markdown","a191bb43":"markdown","3fc78716":"markdown","21b20aa8":"markdown","bcb5d35f":"markdown","b054c3c9":"markdown","faf02826":"markdown","4f443709":"markdown","2d370cd1":"markdown","132ffde4":"markdown","d6025cb2":"markdown","f5114496":"markdown","0774b1f0":"markdown","fadd66a0":"markdown","748ca760":"markdown","fb52c1e3":"markdown","44a3c6c7":"markdown","a63ebf72":"markdown","68a7e519":"markdown"},"source":{"d0a2c860":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","0074e8bf":"import pandas as pd\nimport numpy as np\nimport sys\nimport sklearn\nprint(pd.__version__)\nprint(np.__version__)\nprint(sys.version)\nprint(sklearn.__version__)","9586c8ed":"# attach the column names to the dataset\n#col_names = [\"id\",\"dur\",\"proto\",\"service\",\"state\",\"spkts\",\"dpkts\",\"sbytes\",\"dbytes\",\"rate\",\n#    \"sttl\",\"dttl\",\"sload\",\"dload\",\"sloss\",\"dloss\",\"sinpkt\",\"dinpkt\",\"sjit\",\"djit\",\n#    \"swin\",\"stcpb\",\"dtcpb\",\"dwin\",\"tcprtt\",\"synack\",\"ackdat\",\"smean\",\"dmean\",\"trans_depth\",\n#    \"response_body_len\",\"ct_srv_src\",\"ct_state_ttl\",\"ct_dst_ltm\",\"ct_src_dport_ltm\",\"ct_dst_sport_ltm\",\"ct_dst_src_ltm\",\"is_ftp_login\",\"ct_ftp_cmd\",\"ct_flw_http_mthd\",\n#    \"ct_src_ltm\",\"ct_srv_dst\",\"is_sm_ips_ports\",\"attack_cat\",\"label\"]\n\n# KDDTrain+_2.csv & KDDTest+_2.csv are the datafiles without the last column about the difficulty score\n# these have already been removed.\ndf = pd.read_csv(\"..\/input\/unsw-nb15-training\/UNSW_NB15_training-set.csv\")\ndf_test= pd.read_csv(\"..\/input\/unsw-nb15-testing\/UNSW_NB15_testing-set.csv\")\n\n# shape, this gives the dimensions of the dataset\nprint('Dimensions of the Training set:',df.shape)\nprint('Dimensions of the Test set:',df_test.shape)","11ce6538":"df.head(5)","79d45831":"df.describe()","beb62fe7":"df.info()","4839e119":"print('attack_cat distribution Training set:')\nprint(df['attack_cat'].value_counts())\nprint()\nprint('attack_cat distribution Test set:')\nprint(df_test['attack_cat'].value_counts())","05b254f9":"# colums that are categorical and not binary yet: protocol_type (column 2), service (column 3), flag (column 4).\n# explore categorical features\nprint('Training set:')\nfor col_name in df.columns:\n    if df[col_name].dtypes == 'object' :\n        unique_cat = len(df[col_name].unique())\n        print(\"Feature '{col_name}' has {unique_cat} categories\".format(col_name=col_name, unique_cat=unique_cat))\n\n#see how distributed the feature service is, it is evenly distributed and therefore we need to make dummies for all.\nprint()\nprint('Distribution of categories in state:')\nprint(df['state'].value_counts().sort_values(ascending=False).head())","af7d4f8e":"# Test set\nprint('Test set:')\nfor col_name in df_test.columns:\n    if df_test[col_name].dtypes == 'object' :\n        unique_cat = len(df_test[col_name].unique())\n        print(\"Feature '{col_name}' has {unique_cat} categories\".format(col_name=col_name, unique_cat=unique_cat))","dbb940f5":"from sklearn.preprocessing import LabelEncoder,OneHotEncoder\ncategorical_columns=['proto', 'service', 'state']\n# insert code to get a list of categorical columns into a variable, categorical_columns\ncategorical_columns=['proto', 'service', 'state'] \n # Get the categorical values into a 2D numpy array\ndf_categorical_values = df[categorical_columns]\ntestdf_categorical_values = df_test[categorical_columns]\ndf_categorical_values.head()","53c01c96":"# proto type\nunique_proto=sorted(df.proto.unique())\nstring1 = 'proto_'\nunique_proto2=[string1 + x for x in unique_proto]\n# service\nunique_service=sorted(df.service.unique())\nstring2 = 'service_'\nunique_service2=[string2 + x for x in unique_service]\n# state\nunique_state=sorted(df.state.unique())\nstring3 = 'state_'\nunique_state2=[string3 + x for x in unique_state]\n# put together\ndumcols=unique_proto2 + unique_service2 + unique_state2\nprint(dumcols)\n\n#do same for test set\n# proto type\nunique_proto_test=sorted(df_test.proto.unique())\nunique_proto2_test=[string1 + x for x in unique_proto_test]\n\n#unique_service_test=sorted(df_test.service.unique())\n#unique_service2_test=[string2 + x for x in unique_service_test]\n\n# state\nunique_state_test=sorted(df_test.state.unique())\nunique_state2_test=[string3 + x for x in unique_state_test]\n\ntestdumcols=unique_proto2_test + unique_service2 + unique_state2_test\nprint()\nprint(testdumcols)","29a1616d":"df_categorical_values_enc=df_categorical_values.apply(LabelEncoder().fit_transform)\nprint(df_categorical_values_enc.head())\ndf_categorical_values_enc.info()\n# test set\ntestdf_categorical_values_enc=testdf_categorical_values.apply(LabelEncoder().fit_transform)","7ca0d457":"enc = OneHotEncoder()\ndf_categorical_values_encenc = enc.fit_transform(df_categorical_values_enc)\ndf_cat_data = pd.DataFrame(df_categorical_values_encenc.toarray(),columns=dumcols)\n# test set\ntestdf_categorical_values_encenc = enc.fit_transform(testdf_categorical_values_enc)\ntestdf_cat_data = pd.DataFrame(testdf_categorical_values_encenc.toarray(),columns=testdumcols)\n\ndf_cat_data.head()","edcadb25":"#For proto\ntrainproto=df['proto'].tolist()\ntestproto= df_test['proto'].tolist()\ndifference=list(set(testproto) - set(trainproto))\nstring = 'proto_'\ndifference=[string + x for x in difference]\ndifference","e75b4567":"for col in difference:\n    df_cat_data[col] = 0\n\ndf_cat_data.shape","68a63066":"#For state\ntrainstate=df['state'].tolist()\nteststate= df_test['state'].tolist()\ndifference=list(set(teststate) - set(trainstate))\nstring = 'state_'\ndifference=[string + x for x in difference]\ndifference\n","790dd842":"for col in difference:\n    df_cat_data[col] = 0\n\ndf_cat_data.shape","c3cc768a":"#For state\ntrainstate=df['state'].tolist()\nteststate= df_test['state'].tolist()\ndifference=list(set(trainstate) - set(teststate))\nstring = 'state_'\ndifference=[string + x for x in difference]\ndifference","bce44394":"for col in difference:\n    testdf_cat_data[col] = 0\n\ntestdf_cat_data.shape","d8e8d564":"df_cat_data.shape","2c218b3f":"newdf=df.join(df_cat_data)\nnewdf.drop('state', axis=1, inplace=True)\nnewdf.drop('proto', axis=1, inplace=True)\nnewdf.drop('service', axis=1, inplace=True)\n# test data\nnewdf_test=df_test.join(testdf_cat_data)\nnewdf_test.drop('state', axis=1, inplace=True)\nnewdf_test.drop('proto', axis=1, inplace=True)\nnewdf_test.drop('service', axis=1, inplace=True)\nprint(newdf.shape)\nprint(newdf_test.shape)","c4df4f3c":"# take label column\nattack_catdf=newdf['attack_cat']\nattack_catdf_test=newdf_test['attack_cat']\n# change the label column\nnew_attack_catdf=attack_catdf.replace({ 'Normal' : 0, 'Generic' : 1 , 'Exploits': 2, \n                'Fuzzers': 3, 'DoS': 4, 'Reconnaissance': 5, 'Analysis': 6,'Backdoor': 7, 'Shellcode': 8, 'Worms': 9})\n#test \nnew_attack_catdf_test=attack_catdf_test.replace({ 'Normal' : 0, 'Generic' : 1 , 'Exploits': 2, \n                'Fuzzers': 3, 'DoS': 4, 'Reconnaissance': 5, 'Analysis': 6,'Backdoor': 7, 'Shellcode': 8, 'Worms': 9})\n# put the new label column back\nnewdf['attack_cat'] = new_attack_catdf\nnewdf_test['attack_cat'] = new_attack_catdf_test\nnewdf['attack_cat']=newdf['attack_cat'].astype('object')\nprint(newdf['attack_cat'].head())","5765f355":"#train\nto_drop_Generic = [2,3,4,5,6,7,8,9]\nto_drop_Exploits = [1,3,4,5,6,7,8,9]\nto_drop_Fuzzers = [1,2,4,5,6,7,8,9]\nto_drop_DoS = [1,2,3,5,6,7,8,9]\nto_drop_Reconnaissance = [1,2,3,4,6,7,8,9]\nto_drop_Analysis = [1,2,3,4,5,7,8,9]\nto_drop_Backdoor = [1,2,3,4,5,6,8,9]\nto_drop_Shellcode = [1,2,3,4,5,6,7,9]\nto_drop_Worms = [1,2,3,4,5,6,7,8]\nGeneric_df=newdf[~newdf['attack_cat'].isin(to_drop_Generic)];\nExploits_df=newdf[~newdf['attack_cat'].isin(to_drop_Exploits)];\nFuzzers_df=newdf[~newdf['attack_cat'].isin(to_drop_Fuzzers)];\nDoS_df=newdf[~newdf['attack_cat'].isin(to_drop_DoS)];\nReconnaissance_df=newdf[~newdf['attack_cat'].isin(to_drop_Reconnaissance)];\nAnalysis_df=newdf[~newdf['attack_cat'].isin(to_drop_Analysis)];\nBackdoor_df=newdf[~newdf['attack_cat'].isin(to_drop_Backdoor)];\nShellcode_df=newdf[~newdf['attack_cat'].isin(to_drop_Shellcode)];\nWorms_df=newdf[~newdf['attack_cat'].isin(to_drop_Worms)];\n#test\nGeneric_df_test=newdf_test[~newdf_test['attack_cat'].isin(to_drop_Generic)];\nExploits_df_test=newdf_test[~newdf_test['attack_cat'].isin(to_drop_Exploits)];\nFuzzers_df_test=newdf_test[~newdf_test['attack_cat'].isin(to_drop_Fuzzers)];\nDoS_df_test=newdf_test[~newdf_test['attack_cat'].isin(to_drop_DoS)];\nReconnaissance_df_test=newdf_test[~newdf_test['attack_cat'].isin(to_drop_Reconnaissance)];\nAnalysis_df_test=newdf_test[~newdf_test['attack_cat'].isin(to_drop_Analysis)];\nBackdoor_df_test=newdf_test[~newdf_test['attack_cat'].isin(to_drop_Backdoor)];\nShellcode_df_test=newdf_test[~newdf_test['attack_cat'].isin(to_drop_Shellcode)];\nWorms_df_test=newdf_test[~newdf_test['attack_cat'].isin(to_drop_Worms)];\n\nprint('Train:')\nprint('Dimensions of Generic:' ,Generic_df.shape)\nprint('Dimensions of Exploits:' ,Exploits_df.shape)\nprint('Dimensions of Fuzzers:' ,Fuzzers_df.shape)\nprint('Dimensions of DoS:' ,DoS_df.shape)\nprint('Dimensions of Reconnaissance:' ,Reconnaissance_df.shape)\nprint('Dimensions of Analysis:' ,Analysis_df.shape)\nprint('Dimensions of Backdoor:' ,Backdoor_df.shape)\nprint('Dimensions of Shellcode:' ,Shellcode_df.shape)\nprint('Dimensions of Worms:' ,Worms_df.shape)\nprint('Test:')\nprint('Dimensions of Generic:' ,Generic_df_test.shape)\nprint('Dimensions of Exploits:' ,Exploits_df_test.shape)\nprint('Dimensions of Fuzzers:' ,Fuzzers_df_test.shape)\nprint('Dimensions of DoS:' ,DoS_df_test.shape)\nprint('Dimensions of Reconnaissance:' ,Reconnaissance_df_test.shape)\nprint('Dimensions of Analysis:' ,Analysis_df_test.shape)\nprint('Dimensions of Backdoor:' ,Backdoor_df_test.shape)\nprint('Dimensions of Shellcode:' ,Shellcode_df_test.shape)\nprint('Dimensions of Worms:' ,Worms_df_test.shape)","38310687":"# Split dataframes into X & Y\n# assign X as a dataframe of feautures and Y as a series of outcome variables\nX_Generic = Generic_df.drop('attack_cat',1)\nY_Generic = Generic_df.attack_cat\nX_Exploits = Exploits_df.drop('attack_cat',1)\nY_Exploits = Exploits_df.attack_cat\nX_Fuzzers = Fuzzers_df.drop('attack_cat',1)\nY_Fuzzers = Fuzzers_df.attack_cat\nX_DoS = DoS_df.drop('attack_cat',1)\nY_DoS = DoS_df.attack_cat\nX_Reconnaissance = Reconnaissance_df.drop('attack_cat',1)\nY_Reconnaissance = Reconnaissance_df.attack_cat\nX_Analysis = Analysis_df.drop('attack_cat',1)\nY_Analysis = Analysis_df.attack_cat\nX_Backdoor = Backdoor_df.drop('attack_cat',1)\nY_Backdoor = Backdoor_df.attack_cat\nX_Shellcode = Shellcode_df.drop('attack_cat',1)\nY_Shellcode = Shellcode_df.attack_cat\nX_Worms = Worms_df.drop('attack_cat',1)\nY_Worms = Worms_df.attack_cat\n# test set\nX_Generic_test = Generic_df_test.drop('attack_cat',1)\nY_Generic_test = Generic_df_test.attack_cat\nX_Exploits_test = Exploits_df_test.drop('attack_cat',1)\nY_Exploits_test = Exploits_df_test.attack_cat\nX_Fuzzers_test = Fuzzers_df_test.drop('attack_cat',1)\nY_Fuzzers_test = Fuzzers_df_test.attack_cat\nX_DoS_test = DoS_df_test.drop('attack_cat',1)\nY_DoS_test = DoS_df_test.attack_cat\nX_Reconnaissance_test = Reconnaissance_df_test.drop('attack_cat',1)\nY_Reconnaissance_test = Reconnaissance_df_test.attack_cat\nX_Analysis_test = Analysis_df_test.drop('attack_cat',1)\nY_Analysis_test = Analysis_df_test.attack_cat\nX_Backdoor_test = Backdoor_df_test.drop('attack_cat',1)\nY_Backdoor_test = Backdoor_df_test.attack_cat\nX_Shellcode_test = Shellcode_df_test.drop('attack_cat',1)\nY_Shellcode_test = Shellcode_df_test.attack_cat\nX_Worms_test = Worms_df_test.drop('attack_cat',1)\nY_Worms_test = Worms_df_test.attack_cat","a6cf479b":"colNames=list(X_Generic)\ncolNames_test=list(X_Generic_test)","94c5ce1b":"#train\nfrom sklearn import preprocessing\nscaler1 = preprocessing.StandardScaler().fit(X_Generic)\nX_Generic=scaler1.transform(X_Generic) \nscaler2 = preprocessing.StandardScaler().fit(X_Exploits)\nX_Exploits=scaler2.transform(X_Exploits) \nscaler3 = preprocessing.StandardScaler().fit(X_Fuzzers)\nX_Fuzzers=scaler3.transform(X_Fuzzers) \nscaler4 = preprocessing.StandardScaler().fit(X_DoS)\nX_DoS=scaler4.transform(X_DoS) \nscaler5 = preprocessing.StandardScaler().fit(X_Reconnaissance)\nX_Reconnaissance=scaler5.transform(X_Reconnaissance) \nscaler6 = preprocessing.StandardScaler().fit(X_Analysis)\nX_Analysis=scaler6.transform(X_Analysis) \nscaler7 = preprocessing.StandardScaler().fit(X_Backdoor)\nX_Backdoor=scaler7.transform(X_Backdoor) \nscaler8 = preprocessing.StandardScaler().fit(X_Shellcode)\nX_Shellcode=scaler8.transform(X_Shellcode)\nscaler9 = preprocessing.StandardScaler().fit(X_Worms)\nX_Worms=scaler9.transform(X_Worms) \n#test\nscaler10 = preprocessing.StandardScaler().fit(X_Generic_test)\nX_Generic_test=scaler10.transform(X_Generic_test) \nscaler11 = preprocessing.StandardScaler().fit(X_Exploits_test)\nX_Exploits_test=scaler11.transform(X_Exploits_test) \nscaler12 = preprocessing.StandardScaler().fit(X_Fuzzers_test)\nX_Fuzzers_test=scaler12.transform(X_Fuzzers_test) \nscaler13 = preprocessing.StandardScaler().fit(X_DoS_test)\nX_DoS_test=scaler13.transform(X_DoS_test) \nscaler14 = preprocessing.StandardScaler().fit(X_Reconnaissance_test)\nX_Reconnaissance_test=scaler14.transform(X_Reconnaissance_test) \nscaler15 = preprocessing.StandardScaler().fit(X_Analysis_test)\nX_Analysis_test=scaler15.transform(X_Analysis_test) \nscaler16 = preprocessing.StandardScaler().fit(X_Backdoor_test)\nX_Backdoor_test=scaler16.transform(X_Backdoor_test) \nscaler17 = preprocessing.StandardScaler().fit(X_Shellcode_test)\nX_Shellcode_test=scaler17.transform(X_Shellcode_test) \nscaler18 = preprocessing.StandardScaler().fit(X_Worms_test)\nX_Worms_test=scaler18.transform(X_Worms_test) ","a6117ce0":"print(X_Generic.std(axis=0))","c4d3cc79":"#'Normal' : 0, 'Generic' : 1 , 'Exploits': 2, \n #               'Fuzzers': 3, 'DoS': 4, 'Reconnaissance': 5, 'Analysis': 6,'Backdoor': 7, 'Shellcode': 8, 'Worms': 9\nX_Exploits.std(axis=0);\nX_Fuzzers.std(axis=0);\nX_DoS.std(axis=0);\nX_Reconnaissance.std(axis=0);\nX_Analysis.std(axis=0);\nX_Backdoor.std(axis=0);\nX_Shellcode.std(axis=0);\nX_Worms.std(axis=0);","c9873b3e":"#univariate feature selection with ANOVA F-test. using secondPercentile method, then RFE\n#Scikit-learn exposes feature selection routines as objects that implement the transform method\n#SelectPercentile: removes all but a user-specified highest scoring percentage of features\n#f_classif: ANOVA F-value between label\/feature for classification tasks.\nfrom sklearn.feature_selection import SelectPercentile, f_classif\nnp.seterr(divide='ignore', invalid='ignore');\nselector=SelectPercentile(f_classif, percentile=10)\nX_newGeneric = selector.fit_transform(X_Generic,Y_Generic)\nX_newGeneric.shape","559e53c2":"# Get the features that were selected: Generic\ntrue=selector.get_support()\nnewcolindex_Generic=[i for i, x in enumerate(true) if x]\nnewcolname_Generic=list( colNames[i] for i in newcolindex_Generic )\nnewcolname_Generic","49f88f4c":"X_newExploits = selector.fit_transform(X_Exploits,Y_Exploits)\nX_newExploits.shape","9d3a935d":"#Get the features that were selected: Exploits\ntrue=selector.get_support()\nnewcolindex_Exploits=[i for i, x in enumerate(true) if x]\nnewcolname_Exploits=list( colNames[i] for i in newcolindex_Exploits )\nnewcolname_Exploits","1fd50391":"X_newFuzzers = selector.fit_transform(X_Fuzzers,Y_Fuzzers)\nX_newFuzzers.shape","8cb7aadf":"#Get the features that were selected: Fuzzers\ntrue=selector.get_support()\nnewcolindex_Fuzzers=[i for i, x in enumerate(true) if x]\nnewcolname_Fuzzers=list( colNames[i] for i in newcolindex_Fuzzers )\nnewcolname_Fuzzers","df6dc150":"X_newDoS = selector.fit_transform(X_DoS,Y_DoS)\nX_newDoS.shape","6b4e4331":"#Get the features that were selected: DoS\ntrue=selector.get_support()\nnewcolindex_DoS=[i for i, x in enumerate(true) if x]\nnewcolname_DoS=list( colNames[i] for i in newcolindex_DoS )\nnewcolname_DoS","118b6e03":"X_newReconnaissance = selector.fit_transform(X_Reconnaissance,Y_Reconnaissance)\nX_newReconnaissance.shape","b4f77486":"#Get the features that were selected: Reconnaissance\ntrue=selector.get_support()\nnewcolindex_Reconnaissance=[i for i, x in enumerate(true) if x]\nnewcolname_Reconnaissance=list( colNames[i] for i in newcolindex_Reconnaissance )\nnewcolname_Reconnaissance","679a267b":"X_newAnalysis = selector.fit_transform(X_Analysis,Y_Analysis)\nX_newAnalysis.shape","fd00d2fd":"#Get the features that were selected: Analysis\ntrue=selector.get_support()\nnewcolindex_Analysis=[i for i, x in enumerate(true) if x]\nnewcolname_Analysis=list( colNames[i] for i in newcolindex_Analysis )\nnewcolname_Analysis","24e138c6":"X_newBackdoor = selector.fit_transform(X_Backdoor,Y_Backdoor)\nX_newBackdoor.shape","938d6c52":"#Get the features that were selected: Backdoor\ntrue=selector.get_support()\nnewcolindex_Backdoor=[i for i, x in enumerate(true) if x]\nnewcolname_Backdoor=list( colNames[i] for i in newcolindex_Backdoor )\nnewcolname_Backdoor","42eadb99":"X_newShellcode = selector.fit_transform(X_Shellcode,Y_Shellcode)\nX_newShellcode.shape","e47dee44":"#Get the features that were selected: Shellcode\ntrue=selector.get_support()\nnewcolindex_Shellcode=[i for i, x in enumerate(true) if x]\nnewcolname_Shellcode=list( colNames[i] for i in newcolindex_Shellcode )\nnewcolname_Shellcode","beb2389f":"X_newWorms = selector.fit_transform(X_Worms,Y_Worms)\nX_newWorms.shape","f0b3b2e9":"#Get the features that were selected: Worms\ntrue=selector.get_support()\nnewcolindex_Worms=[i for i, x in enumerate(true) if x]\nnewcolname_Worms=list( colNames[i] for i in newcolindex_Worms )\nnewcolname_Worms","fbce9cde":"print('Features selected for Generic:',newcolname_Generic)\nprint()\nprint('Features selected for Exploits:',newcolname_Exploits)\nprint()\nprint('Features selected for Fuzzers:',newcolname_Fuzzers)\nprint()\nprint('Features selected for DoS:',newcolname_DoS)\nprint()\nprint('Features selected for Reconnaissance:',newcolname_Reconnaissance)\nprint()\nprint('Features selected for Analysis:',newcolname_Analysis)\nprint()\nprint('Features selected for Backdoor:',newcolname_Backdoor)\nprint()\nprint('Features selected for Shellcode:',newcolname_Shellcode)\nprint()\nprint('Features selected for Worms:',newcolname_Worms)","92889f7b":"'''from sklearn import preprocessing\nfrom sklearn import utils\n\nlab_enc = preprocessing.LabelEncoder()\nencoded = lab_enc.fit_transform(Y_Generic) '''","7380462e":"Y_Generic=Y_Generic.astype('int')\nY_Exploits=Y_Exploits.astype('int')\nY_Fuzzers=Y_Fuzzers.astype('int')\nY_DoS=Y_DoS.astype('int')\nY_Reconnaissance=Y_Reconnaissance.astype('int')\nY_Analysis=Y_Analysis.astype('int')\nY_Backdoor=Y_Backdoor.astype('int')\nY_Shellcode=Y_Shellcode.astype('int')\nY_Worms=Y_Worms.astype('int')","8a2e7bfb":"from sklearn.feature_selection import RFE\nfrom sklearn.tree import DecisionTreeClassifier\n# Create a decision tree classifier. By convention, clf means 'classifier'\nclf = DecisionTreeClassifier(random_state=0)\n\n#rank all features, i.e continue the elimination until the last one\nrfe = RFE(clf, n_features_to_select=1)\nrfe.fit(X_newGeneric, Y_Generic)\nprint (\"Generic Features sorted by their rank:\")\nprint (sorted(zip(map(lambda x: round(x, 4), rfe.ranking_), newcolname_Generic)))","eaceb29a":"rfe.fit(X_newExploits, Y_Exploits)\nprint (\"Exploits Features sorted by their rank:\")\nprint (sorted(zip(map(lambda x: round(x, 4), rfe.ranking_), newcolname_Exploits)))","3027d9b4":"rfe.fit(X_newFuzzers, Y_Fuzzers)\nprint (\"Fuzzers Features sorted by their rank:\")\nprint (sorted(zip(map(lambda x: round(x, 4), rfe.ranking_), newcolname_Fuzzers)))","e6bb4c22":"rfe.fit(X_newDoS, Y_DoS)\nprint (\"DoS Features sorted by their rank:\")\nprint (sorted(zip(map(lambda x: round(x, 4), rfe.ranking_), newcolname_DoS)))","5563390d":"rfe.fit(X_newReconnaissance, Y_Reconnaissance)\nprint (\"Reconnaissance Features sorted by their rank:\")\nprint (sorted(zip(map(lambda x: round(x, 4), rfe.ranking_), newcolname_Reconnaissance)))","0f986505":"rfe.fit(X_newAnalysis, Y_Analysis)\nprint (\"Analysis Features sorted by their rank:\")\nprint (sorted(zip(map(lambda x: round(x, 4), rfe.ranking_), newcolname_Analysis)))","1dc25f76":"rfe.fit(X_newBackdoor, Y_Backdoor)\nprint (\"Backdoor Features sorted by their rank:\")\nprint (sorted(zip(map(lambda x: round(x, 4), rfe.ranking_), newcolname_Backdoor)))","29d2d504":"rfe.fit(X_newShellcode, Y_Shellcode)\nprint (\"Shellcode Features sorted by their rank:\")\nprint (sorted(zip(map(lambda x: round(x, 4), rfe.ranking_), newcolname_Shellcode)))","0f3eff6a":"rfe.fit(X_newWorms, Y_Worms)\nprint (\"Worms Features sorted by their rank:\")\nprint (sorted(zip(map(lambda x: round(x, 4), rfe.ranking_), newcolname_Worms)))","1d12422f":"from sklearn.feature_selection import RFE\nclf = DecisionTreeClassifier(random_state=0)\nrfe = RFE(estimator=clf, n_features_to_select=20, step=1)\nrfe.fit(X_Generic, Y_Generic)\nX_rfeGeneric=rfe.transform(X_Generic)\ntrue=rfe.support_\nrfecolindex_Generic=[i for i, x in enumerate(true) if x]\nrfecolname_Generic=list(colNames[i] for i in rfecolindex_Generic)","ff172616":"rfe.fit(X_Exploits, Y_Exploits)\nX_rfeExploits=rfe.transform(X_Exploits)\ntrue=rfe.support_\nrfecolindex_Exploits=[i for i, x in enumerate(true) if x]\nrfecolname_Exploits=list(colNames[i] for i in rfecolindex_Exploits)","d8f9d5f5":"rfe.fit(X_Fuzzers, Y_Fuzzers)\nX_rfeFuzzers=rfe.transform(X_Fuzzers)\ntrue=rfe.support_\nrfecolindex_Fuzzers=[i for i, x in enumerate(true) if x]\nrfecolname_Fuzzers=list(colNames[i] for i in rfecolindex_Fuzzers)","2ce38ce3":"rfe.fit(X_DoS, Y_DoS)\nX_rfeDoS=rfe.transform(X_DoS)\ntrue=rfe.support_\nrfecolindex_DoS=[i for i, x in enumerate(true) if x]\nrfecolname_DoS=list(colNames[i] for i in rfecolindex_DoS)","0641fc3f":"rfe.fit(X_Reconnaissance, Y_Reconnaissance)\nX_rfeReconnaissance=rfe.transform(X_Reconnaissance)\ntrue=rfe.support_\nrfecolindex_Reconnaissance=[i for i, x in enumerate(true) if x]\nrfecolname_Reconnaissance=list(colNames[i] for i in rfecolindex_Reconnaissance)","5161750f":"rfe.fit(X_Analysis, Y_Analysis)\nX_rfeAnalysis=rfe.transform(X_Analysis)\ntrue=rfe.support_\nrfecolindex_Analysis=[i for i, x in enumerate(true) if x]\nrfecolname_Analysis=list(colNames[i] for i in rfecolindex_Analysis)","59419aa6":"rfe.fit(X_Backdoor, Y_Backdoor)\nX_rfeBackdoor=rfe.transform(X_Backdoor)\ntrue=rfe.support_\nrfecolindex_Backdoor=[i for i, x in enumerate(true) if x]\nrfecolname_Backdoor=list(colNames[i] for i in rfecolindex_Backdoor)","b44e4ac1":"rfe.fit(X_Shellcode, Y_Shellcode)\nX_rfeShellcode=rfe.transform(X_Shellcode)\ntrue=rfe.support_\nrfecolindex_Shellcode=[i for i, x in enumerate(true) if x]\nrfecolname_Shellcode=list(colNames[i] for i in rfecolindex_Shellcode)","3f5da53e":"rfe.fit(X_Worms, Y_Worms)\nX_rfeWorms=rfe.transform(X_Worms)\ntrue=rfe.support_\nrfecolindex_Worms=[i for i, x in enumerate(true) if x]\nrfecolname_Worms=list(colNames[i] for i in rfecolindex_Worms)","0f6e6bfa":"print('Features selected for Generic:',rfecolname_Generic)\nprint()\nprint('Features selected for Exploits:',rfecolname_Exploits)\nprint()\nprint('Features selected for Fuzzers:',rfecolname_Fuzzers)\nprint()\nprint('Features selected for DoS:',rfecolname_DoS)\nprint()\nprint('Features selected for Reconnaissance:',rfecolname_Reconnaissance)\nprint()\nprint('Features selected for Analysis:',rfecolname_Analysis)\nprint()\nprint('Features selected for Backdoor:',rfecolname_Backdoor)\nprint()\nprint('Features selected for Shellcode:',rfecolname_Shellcode)\nprint()\nprint('Features selected for Worms:',rfecolname_Worms)","d4a4efc3":"print(X_rfeGeneric.shape)\nprint(X_rfeExploits.shape)\nprint(X_rfeFuzzers.shape)\nprint(X_rfeDoS.shape)\nprint(X_rfeReconnaissance.shape)\nprint(X_rfeAnalysis.shape)\nprint(X_rfeBackdoor.shape)\nprint(X_rfeShellcode.shape)\nprint(X_rfeWorms.shape)","b33e5a3c":"# all features\nclf_Generic=DecisionTreeClassifier(random_state=0)\nclf_Exploits=DecisionTreeClassifier(random_state=0)\nclf_Fuzzers=DecisionTreeClassifier(random_state=0)\nclf_DoS=DecisionTreeClassifier(random_state=0)\nclf_Reconnaissance=DecisionTreeClassifier(random_state=0)\nclf_Analysis=DecisionTreeClassifier(random_state=0)\nclf_Backdoor=DecisionTreeClassifier(random_state=0)\nclf_Shellcode=DecisionTreeClassifier(random_state=0)\nclf_Worms=DecisionTreeClassifier(random_state=0)\nclf_Generic.fit(X_Generic, Y_Generic)\nclf_Exploits.fit(X_Exploits, Y_Exploits)\nclf_Fuzzers.fit(X_Fuzzers, Y_Fuzzers)\nclf_DoS.fit(X_DoS, Y_DoS)\nclf_Reconnaissance.fit(X_Reconnaissance, Y_Reconnaissance)\nclf_Analysis.fit(X_Analysis, Y_Analysis)\nclf_Backdoor.fit(X_Backdoor, Y_Backdoor)\nclf_Shellcode.fit(X_Shellcode, Y_Shellcode)\nclf_Worms.fit(X_Worms, Y_Worms)","343a6df3":"# selected features\nclf_rfeGeneric=DecisionTreeClassifier(random_state=0)\nclf_rfeExploits=DecisionTreeClassifier(random_state=0)\nclf_rfeFuzzers=DecisionTreeClassifier(random_state=0)\nclf_rfeDoS=DecisionTreeClassifier(random_state=0)\nclf_rfeReconnaissance=DecisionTreeClassifier(random_state=0)\nclf_rfeAnalysis=DecisionTreeClassifier(random_state=0)\nclf_rfeBackdoor=DecisionTreeClassifier(random_state=0)\nclf_rfeShellcode=DecisionTreeClassifier(random_state=0)\nclf_rfeWorms=DecisionTreeClassifier(random_state=0)\nclf_rfeGeneric.fit(X_rfeGeneric, Y_Generic)\nclf_rfeExploits.fit(X_rfeExploits, Y_Exploits)\nclf_rfeFuzzers.fit(X_rfeFuzzers, Y_Fuzzers)\nclf_rfeDoS.fit(X_rfeDoS, Y_DoS)\nclf_rfeReconnaissance.fit(X_rfeReconnaissance, Y_Reconnaissance)\nclf_rfeAnalysis.fit(X_rfeAnalysis, Y_Analysis)\nclf_rfeBackdoor.fit(X_rfeBackdoor, Y_Backdoor)\nclf_rfeShellcode.fit(X_rfeShellcode, Y_Shellcode)\nclf_rfeWorms.fit(X_rfeWorms, Y_Worms)","a31623ae":"clf_Generic.predict(X_Generic_test)","b858118b":"clf_Generic.predict_proba(X_Generic_test)[0:10]","d4dc9e02":"Y_Generic_pred=clf_Generic.predict(X_Generic_test)\n# Create confusion matrix\npd.crosstab(Y_Generic_test, Y_Generic_pred, rownames=['Actual attacks'], colnames=['Predicted attacks'])","391194aa":"Y_Exploits_pred=clf_Exploits.predict(X_Exploits_test)\n# Create confusion matrix\npd.crosstab(Y_Exploits_test, Y_Exploits_pred, rownames=['Actual attacks'], colnames=['Predicted attacks'])","8df18aa7":"Y_Fuzzers_pred=clf_Fuzzers.predict(X_Fuzzers_test)\n# Create confusion matrix\npd.crosstab(Y_Fuzzers_test, Y_Fuzzers_pred, rownames=['Actual attacks'], colnames=['Predicted attacks'])","b4cc03e8":"Y_DoS_pred=clf_DoS.predict(X_DoS_test)\n# Create confusion matrix\npd.crosstab(Y_DoS_test, Y_DoS_pred, rownames=['Actual attacks'], colnames=['Predicted attacks'])","89334a3e":"from sklearn.model_selection import cross_val_score\nfrom sklearn import metrics\naccuracy = cross_val_score(clf_Generic, X_Generic_test, Y_Generic_test, cv=10, scoring='accuracy')\nprint(\"Accuracy: %0.5f (+\/- %0.5f)\" % (accuracy.mean(), accuracy.std() * 2))\nprecision = cross_val_score(clf_Generic, X_Generic_test, Y_Generic_test, cv=10, scoring='precision')\nprint(\"Precision: %0.5f (+\/- %0.5f)\" % (precision.mean(), precision.std() * 2))\nrecall = cross_val_score(clf_Generic, X_Generic_test, Y_Generic_test, cv=10, scoring='recall')\nprint(\"Recall: %0.5f (+\/- %0.5f)\" % (recall.mean(), recall.std() * 2))\nf = cross_val_score(clf_Generic, X_Generic_test, Y_Generic_test, cv=10, scoring='f1')\nprint(\"F-measure: %0.5f (+\/- %0.5f)\" % (f.mean(), f.std() * 2))","86ebbb9b":"from sklearn.model_selection import cross_val_score\nfrom sklearn import metrics\naccuracy = cross_val_score(clf_Exploits, X_Exploits_test, Y_Exploits_test, cv=10, scoring='accuracy')\nprint(\"Accuracy: %0.5f (+\/- %0.5f)\" % (accuracy.mean(), accuracy.std() * 2))\nprecision = cross_val_score(clf_Exploits, X_Exploits_test, Y_Exploits_test, cv=10, scoring='precision')\nprint(\"Precision: %0.5f (+\/- %0.5f)\" % (precision.mean(), precision.std() * 2))\nrecall = cross_val_score(clf_Exploits, X_Exploits_test, Y_Exploits_test, cv=10, scoring='recall')\nprint(\"Recall: %0.5f (+\/- %0.5f)\" % (recall.mean(), recall.std() * 2))\nf = cross_val_score(clf_Exploits, X_Exploits_test, Y_Exploits_test, cv=10, scoring='f1')\nprint(\"F-measure: %0.5f (+\/- %0.5f)\" % (f.mean(), f.std() * 2))","02bacf0c":"X_Generic_test2=X_Generic_test[:,rfecolindex_Generic]\nX_Generic_test2.shape","ab77a73c":"Y_Generic_pred2=clf_rfeGeneric.predict(X_Generic_test2)\n# Create confusion matrix\npd.crosstab(Y_Generic_test, Y_Generic_pred2, rownames=['Actual attacks'], colnames=['Predicted attacks'])","05e6108f":"accuracy = cross_val_score(clf_rfeGeneric, X_Generic_test2, Y_Generic_test, cv=10, scoring='accuracy')\nprint(\"Accuracy: %0.5f (+\/- %0.5f)\" % (accuracy.mean(), accuracy.std() * 2))\nprecision = cross_val_score(clf_rfeGeneric, X_Generic_test2, Y_Generic_test, cv=10, scoring='precision')\nprint(\"Precision: %0.5f (+\/- %0.5f)\" % (precision.mean(), precision.std() * 2))\nrecall = cross_val_score(clf_rfeGeneric, X_Generic_test2, Y_Generic_test, cv=10, scoring='recall')\nprint(\"Recall: %0.5f (+\/- %0.5f)\" % (recall.mean(), recall.std() * 2))\nf = cross_val_score(clf_rfeGeneric, X_Generic_test2, Y_Generic_test, cv=10, scoring='f1')\nprint(\"F-measure: %0.5f (+\/- %0.5f)\" % (f.mean(), f.std() * 2))","76d570d5":"* Summary of features selected by Univariate Feature Selection","a191bb43":"* Add 2 missing categories from test set to train set","3fc78716":"# Split Dataset into 4 datasets for every attack category\n* Rename every attack label: 0=normal, 1=DoS, 2=Probe, 3=R2L and 4=U2R\n* Replace labels column with new labels column\n* Make new datasets","21b20aa8":"# Step 2: Feature Scaling:","bcb5d35f":"Conclusion: Need to make dummies for all categories as the distribution is fairly even. In total: 133+13+9=155 dummies.\n# LabelEncoder\nInsert categorical features into a 2D numpy array","b054c3c9":"* Join encoded categorical dataframe with the non-categorical dataframe","faf02826":"* * Use StandardScaler() to scale the dataframes","4f443709":"# 2. Recursive Feature Elimination for feature ranking (Option 1: get importance from previous selected)","2d370cd1":"* 2. Recursive Feature Elimination, select 20 features each of 155 (Option 2: get 20 best features from 155 from RFE)","132ffde4":"# Step 4: Build the model:","d6025cb2":"# One-Hot-Encoding","f5114496":"* Save a list of feature names for later use (it is the same for every attack category). Column names are dropped at this stage.","0774b1f0":"* Add 6 missing categories from train set to test set","fadd66a0":"1. Univariate Feature Selection using ANOVA F-test","748ca760":"# Summary of features selected by RFE","fb52c1e3":"# Step 5: Prediction & Evaluation (validation):\n* Using all Features for each category\n* Confusion Matrices\n* Generic","44a3c6c7":"# Step 3: Feature Selection:","a63ebf72":"* Transform categorical features into numbers using LabelEncoder()","68a7e519":"* Make column names for dummies"}}