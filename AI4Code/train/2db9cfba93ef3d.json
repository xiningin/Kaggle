{"cell_type":{"50abd2ba":"code","aa8c6176":"code","10b3e1a8":"code","9bba4a14":"code","a7090c9e":"code","e75cd2d1":"code","a774714e":"code","930ce64c":"markdown","71dbe3bf":"markdown","4b00024f":"markdown","6845186a":"markdown","45518fc5":"markdown","ee8e3356":"markdown","f50c79f2":"markdown","88fbdd32":"markdown"},"source":{"50abd2ba":"import numpy as np\nfrom scipy import fftpack # Fast Fourier Transform functions\n\nimport pyarrow.parquet as pq # for reading input data\n\n%matplotlib inline\nimport matplotlib.pyplot as plt # plotting\n\nplt.style.use('seaborn-whitegrid')","aa8c6176":"# load just three first signals (which belong to the same id measurement)\nn_signals_to_load = 3\nsignals = pq.read_pandas(\n    '..\/input\/train.parquet', \n    columns=[str(i) for i in range(n_signals_to_load)]).to_pandas()","10b3e1a8":"# sampling rate\nnum_samples = signals.shape[0] # 800,000 samples per signal\nperiod = 0.02 # over a 20ms period\nfs = num_samples \/ period # 40MHz sampling rate\n\n# time array support\nt = np.array([i \/ fs for i in range(num_samples)])\n\n# frequency vector fro FFT\nfreqs = fftpack.fftfreq(num_samples, d=1\/fs)","9bba4a14":"# get fft coeffs\ndef get_fft_coeffs(sig):\n    return fftpack.fft(sig)\n\n# get coeff with highest norm\ndef get_highest_coeff(fft_coeffs, freqs, verbose=True):\n    coeff_norms = np.abs(fft_coeffs) # get norms (fft coeffs are complex)\n    max_idx = np.argmax(coeff_norms)\n    max_coeff = fft_coeffs[max_idx] # get max coeff\n    max_freq = freqs[max_idx] # assess which is the dominant frequency\n    max_amp = (coeff_norms[max_idx] \/ num_samples) * 2 # times 2 because there are mirrored freqs\n    if verbose:\n        print('Dominant frequency is {:,.1f}Hz with amplitude of {:,.1f}\\n'.format(max_freq, max_amp))\n    \n    return max_coeff, max_amp, max_freq\n\n# get max coeff phase\ndef get_max_coeff_phase(max_coeff):\n    return np.angle(max_coeff)\n\n# construct the instant angular phase vector indexed by pi, i.e. ranges from 0 to 2\ndef get_instant_w(time_vector, f0, phase_shift):\n    w_vector = 2 * np.pi * time_vector * f0 + phase_shift\n    w_vector_norm = np.mod(w_vector \/ (2 * np.pi), 1) * 2 # range between cycle of 0-2 \n    return w_vector, w_vector_norm\n\n# find index of chosen phase to align\ndef get_align_idx(w_vector_norm, align_value=0.5):\n    candidates = np.where(np.isclose(w_vector_norm, align_value))\n    # since we are in discrete time, threre could be many values close to the desired one\n    # so let's take the one in the middle\n    return int(np.median(candidates))","a7090c9e":"fig = plt.figure(figsize=(16, 9))\nplot_number = 0\n\nfor signal_id in signals.columns:\n    # get samples\n    print('=== Signal {} ==='.format(signal_id))\n    sig = signals[signal_id]\n    \n    # fft\n    fft_coeffs = get_fft_coeffs(sig)\n    \n    # asses dominant frequency\n    max_coeff, amp, f0 = get_highest_coeff(fft_coeffs, freqs)\n    \n    # phase shift\n    ps = get_max_coeff_phase(max_coeff)\n    \n    # get angular phase vector\n    w, w_norm = get_instant_w(t, f0, ps)\n    \n    # generate dominant signal at f0\n    dominant_wave = amp * np.cos(w) # if np.sin(), then need to ajust by pi\/2\n    (w)\n    \n    # plot signals\n    plot_number += 1\n    ax = fig.add_subplot(3, 2, plot_number)\n    \n    ax.plot(t * 1000, sig, label='Original') # original signal\n    ax.plot(t * 1000, dominant_wave, color='red', label='Wave at {:.0f}Hz'.format(f0)) # wave at f0\n    ax.legend()\n    ax.set_xlabel('time (ms)')\n    ax.set_ylabel('Amplitude')\n    ax.set_title('Signal {}'.format(signal_id))\n    \n    # plot phase\n    plot_number += 1\n    ax = fig.add_subplot(3, 2, plot_number)\n    \n    ax.plot(t * 1000, w_norm, label='phase') # instant phase\n    ax2 = ax.twinx() # secondary y\n    ax2.plot(t * 1000, dominant_wave, color='red', label='Wave at {:.0f}Hz'.format(f0)) # wave at f0\n    ax.legend()\n    ax.set_xlabel('time (ms)')\n    ax.set_ylabel('$\\omega_i (\\pi$ rad)')\n    ax2.set_ylabel('Wave amplitude')\n    ax.set_title('Instant angular phase of dominant wave')\n    \nfig.tight_layout()","e75cd2d1":"# align waves with np.roll()\nalign_phase = 0.5 # w_i = pi\/2\n\n\nfig = plt.figure(figsize=(12, 9))\nplot_number = 0\n\nfor signal_id in signals.columns:\n    # get samples\n    sig = signals[signal_id]\n    \n    # fft\n    fft_coeffs = get_fft_coeffs(sig)\n    \n    # asses dominant frequency\n    max_coeff, amp, f0 = get_highest_coeff(fft_coeffs, freqs, verbose=False)\n    \n    # phase shift\n    ps = get_max_coeff_phase(max_coeff)\n    \n    # get angular phase vector\n    w, w_norm = get_instant_w(t, f0, ps)\n    \n    # generate dominant signal at f0\n    dominant_wave = amp * np.cos(w)\n    \n    # idx to roll\n    origin = get_align_idx(w_norm, align_value=align_phase)\n    \n    # roll signal and dominant wave\n    sig_rolled = np.roll(sig, num_samples - origin)\n    dominant_wave_rolled = np.roll(dominant_wave, num_samples - origin)\n    \n    # plot signals\n    plot_number += 1\n    ax = fig.add_subplot(3, 1, plot_number)\n    \n    ax.plot(t * 1000, sig_rolled, label='Rolled Original') # original signal\n    ax.plot(t * 1000, dominant_wave_rolled, color='red', label='Rolled Wave at {:.0f}Hz'.format(f0)) # wave at f0\n    ax.legend()\n    ax.set_xlabel('time (ms)')\n    ax.set_ylabel('Amplitude')\n    ax.set_title('Signal {} rolled'.format(signal_id))\n    \nfig.tight_layout()","a774714e":"# align waves with np.roll()\nalign_phase = 0.25 # w_i = pi\/4\n\n\nfig = plt.figure(figsize=(12, 9))\nplot_number = 0\n\nfor signal_id in signals.columns:\n    # get samples\n    sig = signals[signal_id]\n    \n    # fft\n    fft_coeffs = get_fft_coeffs(sig)\n    \n    # asses dominant frequency\n    max_coeff, amp, f0 = get_highest_coeff(fft_coeffs, freqs, verbose=False)\n    \n    # phase shift\n    ps = get_max_coeff_phase(max_coeff)\n    \n    # get angular phase vector\n    w, w_norm = get_instant_w(t, f0, ps)\n    \n    # generate dominant signal at f0\n    dominant_wave = amp * np.cos(w)\n    \n    # idx to roll\n    origin = get_align_idx(w_norm, align_value=align_phase)\n    \n    # roll signal and dominant wave\n    sig_rolled = np.roll(sig, num_samples - origin)\n    dominant_wave_rolled = np.roll(dominant_wave, num_samples - origin)\n    \n    # plot signals\n    plot_number += 1\n    ax = fig.add_subplot(3, 1, plot_number)\n    \n    ax.plot(t * 1000, sig_rolled, label='Rolled Original') # original signal\n    ax.plot(t * 1000, dominant_wave_rolled, color='red', label='Rolled Wave at {:.0f}Hz'.format(f0)) # wave at f0\n    ax.legend()\n    ax.set_xlabel('time (ms)')\n    ax.set_ylabel('Amplitude')\n    ax.set_title('Signal {} rolled'.format(signal_id))\n    \nfig.tight_layout()","930ce64c":"Signals aligned. It should work with any desired `align_phase`. Let's try with $\\pi \/ 4$","71dbe3bf":"All amplitude should be the same, since it is the same triphasic circuit, but FFT cannot recover it perfectly due to noise.","4b00024f":"**Load data**","6845186a":"# Outline\n\nThere are four main steps for each signal:\n1. Get FFT coefficients\n2. Find the coefficients with highest norm (should correspond to 50Hz)\n3. Find the phase of the complex coefficient\n4. Get the instant angular phase vector $\\omega_i$ of the main signal ($f_0 = 50$Hz), i.e. $\\omega_i = 2 \\pi t_i  f_0 + \\phi$, where $\\phi$ is found in step 3\n\nAfterwards, you only need to arbitrarily define a phase to align each signal (e.g. $\\frac{\\pi}{2}$).","45518fc5":"**Bookkeeping**","ee8e3356":"## Short kernel for aligning waves based on their phases, which are obtained from fft.  ","f50c79f2":"Worked!","88fbdd32":"**Align waves**"}}