{"cell_type":{"29fe2aca":"code","538f17ee":"code","bb203057":"code","9e583f32":"code","6bb522e7":"code","7e840a1d":"code","7658f623":"code","6ee930ca":"code","df758ff9":"code","62ea408f":"code","25ca904f":"markdown"},"source":{"29fe2aca":"import sys\nsys.path.append('..\/input\/timm-pytorch-image-models\/pytorch-image-models-master')","538f17ee":"SAMPLE_SIZE = 1000 # Due to long GPU runtime, this notebook only demonstrates training on a handfull of examples","bb203057":"import timm\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import DataLoader, Dataset\nfrom torchvision import transforms\nfrom tqdm.notebook import tqdm\nimport numpy as np \nimport pandas as pd \nimport sqlite3\nimport warnings\nimport cv2\nwarnings.filterwarnings(\"ignore\")\nimport concurrent\nimport os\n\ntorch.cuda.empty_cache()\n\ntorch.backends.cudnn.benchmark = True","9e583f32":"anchor_pos_neg = pd.read_csv('..\/input\/tripletloss-pytorch-data-preparation\/anchor_pos_neg.csv').sample(SAMPLE_SIZE)","6bb522e7":"file_name = '\/kaggle\/input\/timm-pretrained-mobilenetv3\/mobilenetv3\/mobilenetv3_large_100_ra-f55367f5.pth'\n\nmodel = timm.create_model('mobilenetv3_large_100', pretrained=False)\n\nmodel.load_state_dict(torch.load(file_name))\n\nmodel.reset_classifier(0)\n","7e840a1d":"IMAGENET_DEFAULT_MEAN = (0.485, 0.456, 0.406)\nIMAGENET_DEFAULT_STD = (0.229, 0.224, 0.225)\n\n\n\ntransform = transforms.Compose([transforms.RandomHorizontalFlip(),\n                                transforms.Normalize(\n                                    mean=torch.tensor(IMAGENET_DEFAULT_MEAN),\n                                    std=torch.tensor(IMAGENET_DEFAULT_STD)),\n                                transforms.RandomErasing()\n                               ])\n\ndef load_image(file_name):\n    file_path = f'\/kaggle\/input\/shopee-product-matching\/train_images\/{file_name}'\n\n    img = cv2.imread(file_path)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img = cv2.resize(img, (224, 224))\n    tensor_img = torch.tensor(img)\n    tensor_img = tensor_img.permute(( 2, 0, 1)).float()\n    tensor_img = transform(tensor_img)\n    return tensor_img\n    \nclass TrainDataset(Dataset):\n    def __init__(self, df):\n        self.df = df\n        self.anchor = df['anchor'].values\n        self.positive = df['positive'].values\n        self.negative = df['negative'].values\n        \n    def __len__(self):\n        return len(self.df)\n\n    def __getitem__(self, idx):\n        anchor = self.anchor[idx]\n        positive = self.positive[idx]\n        negative = self.negative[idx]\n        \n        anchor = load_image(anchor)\n        positive = load_image(positive)\n        negative = load_image(negative)\n\n\n        \n        return anchor, positive, negative","7658f623":"class TestDataset(Dataset):\n    def __init__(self, df):\n        self.df = df\n        self.anchor = df['anchor'].values\n\n        \n    def __len__(self):\n        return len(self.df)\n\n    def __getitem__(self, idx):\n        anchor = self.anchor[idx]\n        anchor = load_image(anchor)\n        return anchor","6ee930ca":"train_dataset = TrainDataset(anchor_pos_neg)\ntrain_loader = DataLoader(train_dataset,\n                         batch_size=200,\n                         shuffle=True,\n                         num_workers=4,\n                         pin_memory=True)","df758ff9":"device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\nmodel.to(device)\n\noptimizer = torch.optim.Adam(model.parameters(), lr=0.001)\ncriterion = nn.TripletMarginWithDistanceLoss(distance_function=nn.CosineSimilarity())\n\n","62ea408f":"epochs =10\nmodel.train()\n\nscaler = torch.cuda.amp.GradScaler()\n\nfor epoch in tqdm(range(epochs), desc=\"Epochs\"):\n    running_loss = []\n    for step, (anchor_img, positive_img, negative_img) in enumerate(tqdm(train_loader, desc=\"Training\", leave=False)):\n        anchor_img = anchor_img.to(device)\n        positive_img = positive_img.to(device)\n        negative_img = negative_img.to(device)\n        \n        optimizer.zero_grad()\n        with torch.cuda.amp.autocast():\n            anchor_out = model(anchor_img)\n            positive_out = model(positive_img)\n            negative_out = model(negative_img)\n        \n            loss = criterion(anchor_out, positive_out, negative_out)\n        \n        scaler.scale(loss).backward()\n        scaler.step(optimizer)\n        scaler.update()\n\n        \n        running_loss.append(loss.cpu().detach().numpy())\n    \n    print(\"Epoch: {}\/{} - Loss: {:.4f}\".format(epoch+1, epochs, np.mean(running_loss)))\ntorch.save(model, '.\/pretrained-model.pt')","25ca904f":"# Triplet Loss Pytorch\n\nIn this notebook I demonstrate how to train a Siamese Net with Triplet Loss. I use automatic mixed presicion to speed up training.  \n\nTriplet loss requires anchors, positives and negatives examples. This notebook demonstrates how to prepare the dataset: https:\/\/www.kaggle.com\/njelicic\/tripletloss-pytorch-data-preparation\n\nInference: WIP\n\n**Room for improvement:**\n* Larger sample size\n* Larger model \n* Longer training\n"}}