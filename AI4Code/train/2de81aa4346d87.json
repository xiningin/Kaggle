{"cell_type":{"a5f6dfb8":"code","942c37d6":"code","11fc7893":"code","13b19809":"code","33673904":"code","99ee42b3":"code","0e729179":"code","0cb3a0d2":"code","c4b1fde3":"code","d48d10c6":"code","5d3eff32":"code","0bf46a29":"code","688a6adc":"code","8e120b9f":"code","621a49d8":"code","9862cc7e":"code","530b3a5a":"code","1b16fcf5":"code","3fa6d6ba":"code","1f48c2a9":"code","3dd67a14":"code","69eb1110":"code","b28158d7":"code","9ffef96d":"code","0e8054e1":"code","0b7de2a5":"code","daeae5c2":"markdown","0ae3efa1":"markdown","0bc43315":"markdown","4fe812d5":"markdown","869c58ba":"markdown"},"source":{"a5f6dfb8":"!pip install surprise","942c37d6":"%matplotlib inline\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.sparse import csr_matrix\nfrom sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer\nfrom sklearn.metrics.pairwise import linear_kernel, cosine_similarity\nfrom surprise import Reader, Dataset, SVD\nfrom surprise.model_selection import cross_validate\n\nimport warnings; warnings.simplefilter('ignore')","11fc7893":"anime_info_df = pd.read_csv('..\/input\/anime-recommendation-database-2020\/anime.csv')\nanime_desc_df = pd.read_csv('..\/input\/anime-recommendation-database-2020\/anime_with_synopsis.csv')\nrating_df = pd.read_csv('..\/input\/anime-recommendations-database\/rating.csv')","13b19809":"anime_info_df.head(5)","33673904":"anime_df = pd.merge(anime_desc_df,anime_info_df[['MAL_ID','Type','Popularity','Members','Favorites']],on='MAL_ID')\nanime_df.head(10)","99ee42b3":"anime_df.info()","0e729179":"anime_df[\"Score\"].describe()","0cb3a0d2":"anime_df = anime_df[(anime_df[\"Score\"] != \"Unknown\")] \nanime_df.shape","c4b1fde3":"anime_df['sypnopsis'] = anime_df['sypnopsis'].fillna('')","d48d10c6":"tfidf = TfidfVectorizer(analyzer='word',ngram_range=(1, 2),min_df=0, stop_words='english')\ntfidf_matrix = tfidf.fit_transform(anime_df['sypnopsis'])\ntfidf_matrix.shape","5d3eff32":"cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)\ncosine_sim.shape","0bf46a29":"anime_df = anime_df.reset_index()\ntitles = anime_df['Name']\nindices = pd.Series(anime_df.index, index=anime_df['Name'])","688a6adc":"def content_recommendations(title):\n    idx = indices[title]\n    sim_scores = list(enumerate(cosine_sim[idx]))\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n    sim_scores = sim_scores[1:31]\n    anime_indices = [i[0] for i in sim_scores]\n    \n    anime_lst = anime_df.iloc[anime_indices][['Name', 'Members', 'Score']]\n    favorite_count = anime_lst[anime_lst['Members'].notnull()]['Members'].astype('int')\n    score_avg = anime_lst[anime_lst['Score'].notnull()]['Score'].astype('float')\n    C = score_avg.mean()\n    m = favorite_count.quantile(0.60)\n    qualified = anime_lst[(anime_lst['Members'] >= m) & (anime_lst['Members'].notnull()) & (anime_lst['Score'].notnull())]\n    qualified['Members'] = qualified['Members'].astype('int')\n    qualified['Score'] = qualified['Score'].astype('float')\n    def weighted_rating(x):\n        v = x['Members']\n        R = x['Score']\n        return (v\/(v+m) * R) + (m\/(m+v) * C)   \n    \n    qualified['wr'] = qualified.apply(weighted_rating, axis=1)\n    qualified = qualified.sort_values('wr', ascending=False).head(10)\n    \n    return qualified","8e120b9f":"content_recommendations('Naruto').head(10)","621a49d8":"rating_df.head(10)","9862cc7e":"rating_df['rating'].value_counts()","530b3a5a":"# rating_df['rating'] = rating_df['rating'].apply(lambda x: 1 if x < 0 else x)\nrating_df = rating_df[(rating_df[\"rating\"] != -1)] ","1b16fcf5":"rating_df.head(5)","3fa6d6ba":"reader = Reader()\nrating_data = Dataset.load_from_df(rating_df, reader)\nsvd = SVD()","1f48c2a9":"trainset = rating_data.build_full_trainset()","3dd67a14":"svd.fit(trainset)","69eb1110":"svd.predict(1, 356, 5)","b28158d7":"id_map = anime_df[['MAL_ID']]\nid_map['id'] = list(range(1,anime_df.shape[0]+1,1))\nid_map = id_map.merge(anime_df[['MAL_ID', 'Name']], on='MAL_ID').set_index('Name')","9ffef96d":"indices_map = id_map.set_index('id')","0e8054e1":"def hybrid_recommendations(user_id,title):\n    idx = indices[title]\n    sim_scores = list(enumerate(cosine_sim[idx]))\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n    sim_scores = sim_scores[1:31]    \n    anime_indices = [i[0] for i in sim_scores]\n            \n    anime_lst = anime_df.iloc[anime_indices][['MAL_ID','Name', 'Members', 'Score','Genres']]\n    favorite_count = anime_lst[anime_lst['Members'].notnull()]['Members'].astype('int')\n    score_avg = anime_lst[anime_lst['Score'].notnull()]['Score'].astype('float')\n    C = score_avg.mean()\n    m = favorite_count.quantile(0.60)\n    qualified = anime_lst[(anime_lst['Members'] >= m) & (anime_lst['Members'].notnull()) & (anime_lst['Score'].notnull())]    \n    qualified['Members'] = qualified['Members'].astype('int')\n    qualified['Score'] = qualified['Score'].astype('float')\n    def weighted_rating(x):\n        v = x['Members']\n        R = x['Score']\n        return (v\/(v+m) * R) + (m\/(m+v) * C)   \n    \n    qualified['wr'] = qualified.apply(weighted_rating, axis=1)\n    qualified = qualified.sort_values('wr', ascending=False).head(30)    \n    \n    qualified[['id']] = list(range(1,qualified.shape[0]+1,1))  \n    qualified['est'] = qualified['id'].apply(lambda x: svd.predict(user_id, indices_map.loc[x]['MAL_ID']).est)\n    qualified = qualified.sort_values('est', ascending=False)\n    result = qualified[['MAL_ID','Name','Genres','Score']]\n    return result.head(10)    ","0b7de2a5":"hybrid_recommendations(8, 'Trigun')","daeae5c2":"## Content  Filtering","0ae3efa1":"## Collaborative Filtering","0bc43315":"## Installing Dependencies","4fe812d5":"## Importing Libraries","869c58ba":"## Hybrid Filtering"}}