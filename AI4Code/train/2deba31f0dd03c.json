{"cell_type":{"b751961a":"code","50a8e574":"code","6cfa58ff":"code","b636cabf":"code","1f1ba8a9":"code","880f4af8":"code","b0529d5e":"code","3407a87e":"code","20ceaf1b":"code","406c86a4":"code","c3b3084a":"code","8c2a6168":"code","9f29558b":"code","90e78e2f":"code","ff8b6415":"code","53c47780":"code","b7a2b3d9":"code","e01a881b":"code","87f83da2":"code","cc5166af":"code","753a848e":"code","2315c116":"code","07473bf0":"code","24cc4202":"code","5dadc538":"code","a478dcdc":"code","50b78ad3":"code","f08187a4":"code","141800c8":"code","174a6958":"code","77d06909":"code","94425913":"code","51af4cb7":"code","75e788d2":"code","d835f9e7":"code","965d4d73":"code","b41943e0":"code","e7f45e9c":"code","1b90c037":"code","14a21510":"code","bd2989af":"code","27288591":"code","6cd8da01":"code","870e25ab":"code","b87328dd":"code","705b28ad":"code","a0f9e55e":"code","cac8a92c":"code","a9e0c0db":"code","19ed196e":"code","d961a766":"code","edaf5514":"code","5f86d1f0":"code","1664d7d8":"code","6a67deee":"code","0a37b330":"code","446f6fed":"code","9024e205":"code","74109355":"code","b1b42bf6":"code","4888d9af":"code","7d252d01":"code","0c2b906f":"code","e72e9b8a":"code","c9dedad6":"code","c7061549":"code","540b72a1":"code","2ff15f19":"code","5b8000a2":"code","b95cb31f":"code","def684ee":"code","168a45c9":"code","968d70f3":"code","81d28ea5":"code","90c08b2b":"code","6ee162f3":"code","fff34957":"code","7703ae93":"code","930d6fd2":"code","9f399ce7":"code","aad4d584":"code","71598e85":"code","6ee275a3":"code","9a2be690":"code","ba212be8":"code","ff44f380":"code","26ad9e1f":"code","2fb55aa6":"code","d37ce0b6":"code","f0eff12c":"code","d2ec9ef5":"code","011c653d":"code","4b9c5509":"code","928e4d8c":"code","91381e6c":"code","09586843":"code","eedbc9be":"code","d67c0655":"code","dc840d8f":"code","939afd5b":"code","4c98d57a":"code","3ba93ac1":"code","f6ea3798":"code","9a2cf747":"code","114da28e":"code","53802de4":"code","15af0941":"markdown","668d9aa5":"markdown","08ffe399":"markdown","7f56f017":"markdown","258e3d33":"markdown","71db9f39":"markdown","7e39a0e0":"markdown","ccee6817":"markdown","df1487c4":"markdown","e8a7ba4b":"markdown","eb926797":"markdown","b7c95390":"markdown","0a7db68c":"markdown","22bef791":"markdown","2a189b0f":"markdown","29fb2ef7":"markdown","15695566":"markdown","0b245f6a":"markdown","861230b0":"markdown","6cf145d2":"markdown","6f4b1bce":"markdown","5e61cb7d":"markdown","4856ef15":"markdown","67dda05a":"markdown","4f7d8f77":"markdown","0e784b0c":"markdown","58892c64":"markdown","5a974c78":"markdown","e28f61c9":"markdown","4837ebd8":"markdown","da11e9a6":"markdown","f8ae661f":"markdown","5216430f":"markdown","ab9de1ea":"markdown","08e9cbcd":"markdown","5be1037b":"markdown","15c003b2":"markdown","eeed3025":"markdown","9f4899f5":"markdown","fd3633fb":"markdown","3df2d709":"markdown","587e43c0":"markdown","a8267d65":"markdown","188b95f0":"markdown","f0cebc88":"markdown","28d1c3eb":"markdown","158ef747":"markdown","59b890b8":"markdown","a6c24510":"markdown","d94599f5":"markdown","97161cd2":"markdown","88fa4bce":"markdown","424d65c4":"markdown","90bf020f":"markdown","6e03f0f5":"markdown","689d10e9":"markdown","95489d3b":"markdown","7591f02e":"markdown","66a2677c":"markdown","468660f4":"markdown","639067af":"markdown","e117faca":"markdown","f96cfdaf":"markdown","d7ddea62":"markdown"},"source":{"b751961a":"# Importing modules.\nimport pandas as pd\nimport requests\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport datetime as dt\nimport os\n\nfrom bs4 import BeautifulSoup\nfrom tqdm.notebook import tqdm\nfrom catboost import CatBoostRegressor\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import KFold\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.base import clone\n\n%matplotlib inline","50a8e574":"# Setting the conditions.\nrandom_seed = 42\nvalid_size = 0.33\nnum_folds = 5\niterations = 2000\nlearning_rate = 0.1\nversion = 18\ncurrent_date = pd.to_datetime('02\/12\/2020')\npd.set_option('display.max_columns', None)\ndata_directory = '\/kaggle\/input\/sf-dst-car-price\/'\nparsed_directory = '\/kaggle\/input\/car-prediction-parsed-raw-data\/'\n!pip freeze > requirements.txt","6cfa58ff":"# Importing datasets.\ndata_test = pd.read_csv(data_directory+'test.csv')\ndata_train = pd.read_csv(parsed_directory+'raw_data_train.csv')\nsample_submission = pd.read_csv(data_directory+'\/sample_submission.csv')","b636cabf":"# Checking the data.\ndata_test.head(5)","1f1ba8a9":"# Checking the data.\ndata_test.info()","880f4af8":"# Checking the data.\ndata_test['bodyType'].value_counts()","b0529d5e":"# Checking the data.\ndata_test['brand'].value_counts()","3407a87e":"# Checking the data.\ndata_test['color'].value_counts()","20ceaf1b":"# Checking the data.\ndata_test['fuelType'].value_counts()","406c86a4":"# Sorting values.\ndata_test['modelDate'].sort_values()","c3b3084a":"# Checking the frequency distribution.\ndata_test['modelDate'].hist(bins=20)","8c2a6168":"# Checking the data.\ndata_test['name'].value_counts()","9f29558b":"# Checking the data.\ndata_test['numberOfDoors'].value_counts()","90e78e2f":"# Sorting values.\ndata_test['productionDate'].sort_values()","ff8b6415":"# Checking the frequency distribution.\ndata_test['productionDate'].hist(bins=20)","53c47780":"# Checking the correlation matrix.\ndata_test.corr()","b7a2b3d9":"# Checking the data.\ndata_test['vehicleConfiguration'].value_counts()","e01a881b":"# Checking the data.\ndata_test['vehicleTransmission'].value_counts()","87f83da2":"# Sorting values.\ndata_test['engineDisplacement'].sort_values()","cc5166af":"# Sorting values.\ndata_test['enginePower'].sort_values()","753a848e":"# Checking the data.\npd.set_option('display.max_rows', None)\ndata_test['enginePower'].value_counts()","2315c116":"# Checking the data.\npd.set_option('display.max_rows', 10)\ndata_test['description'][0]","07473bf0":"# Checking the data.\ndata_test['mileage'].value_counts()","24cc4202":"# Checking the frequency distribution.\ndata_test['mileage'].hist(bins=100)","5dadc538":"# Checking the frequency distribution.\ndata_test['mileage'][data_test['mileage']<10000].hist()","a478dcdc":"# Checking the frequency distribution.\ndata_test['mileage'][data_test['mileage']>200000].hist()","50b78ad3":"# Checking the data.\ndata_test[data_test['mileage']<1000]['description']","f08187a4":"# Checking the data.\ndata_test['\u041a\u043e\u043c\u043f\u043b\u0435\u043a\u0442\u0430\u0446\u0438\u044f'][15]","141800c8":"# Checking the data.\ndata_test['\u041f\u0440\u0438\u0432\u043e\u0434'].value_counts()","174a6958":"# Checking the data.\ndata_test['\u0420\u0443\u043b\u044c'].value_counts()","77d06909":"# Checking the data.\ndata_test['\u0421\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435'].value_counts()","94425913":"# Checking the data.\ndata_test['\u0412\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u044b'].value_counts()","51af4cb7":"# Checking the data.\ndata_test['\u041f\u0422\u0421'].value_counts()","75e788d2":"# Checking the data.\ndata_test['\u0422\u0430\u043c\u043e\u0436\u043d\u044f'].value_counts()","d835f9e7":"# Checking the data.\ndata_test['\u0412\u043b\u0430\u0434\u0435\u043d\u0438\u0435'].value_counts(dropna=False)","965d4d73":"# Checking the frequency distribution.\ndata_test['id'].hist()","b41943e0":"# Checking the frequency distribution.\nsample_submission['price'].hist()","e7f45e9c":"# Creating a list of links.\nmodel_url_list = [\n'https:\/\/auto.ru\/cars\/bmw\/1er\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/2er\/used\/',       \n'https:\/\/auto.ru\/cars\/bmw\/3er\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/4\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/5er\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/6er\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/7er\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/8er\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/i3\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/m3\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/m5\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/m6\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/x1\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/x2\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/x3\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/x4\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/x4_m\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/x5\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/x5_m\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/x6\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/x6_m\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/x7\/used\/',\n'https:\/\/auto.ru\/cars\/bmw\/z4\/used\/',\n]","1b90c037":"# Defining a function for page counting.\ndef pages_counter(model_url):\n    response = requests.get(model_url)\n    page = BeautifulSoup(response.text, 'html.parser')\n    total_pages = page.find_all(class_ = \"Button Button_color_whiteHoverBlue Button_size_s Button_type_link Button_width_default ListingPagination-module__page\")\n    if total_pages == []:\n        return 1\n    else:\n        return int(total_pages[-1].find(class_ = \"Button__text\").text)","14a21510":"# Creating a list for cards.\n# card_url_list = []","bd2989af":"# Defining a function for card parsing.\ndef card_url_parser(model_url):\n    response = requests.get(model_url)\n    page = BeautifulSoup(response.text, 'html.parser')\n    pages_for_model = pages_counter(model_url)\n    for parsed_page in range(1, pages_for_model):\n        if parsed_page == 1:\n            for card_url in page.find_all(class_=\"Link ListingItemTitle-module__link\"):\n                card_url_list.append(card_url['href'])\n        else:\n            page_url = model_url + '?page=' + str(parsed_page)\n            response = requests.get(page_url)\n            page = BeautifulSoup(response.text, 'html.parser')\n            for card_url in page.find_all(class_=\"Link ListingItemTitle-module__link\"):\n                card_url_list.append(card_url['href'])","27288591":"# Parsing the cards.\n# for model_url in model_url_list:\n#     card_url_parser(model_url)","6cd8da01":"# Checking the list of cards.\n# card_url_list","870e25ab":"# Saving the data.\n# card_url_data = pd.DataFrame(card_url_list)\n# card_url_data","b87328dd":"# Saving the data.\n# card_url_data.to_csv('all_urls.csv')","705b28ad":"# Defining a function for feature parsing.\ndef features_parser (url_list):\n    counter = 0\n    for card_url in url_list:\n        response = requests.get(card_url)\n        response.encoding = 'utf-8'\n        page = BeautifulSoup(response.text, 'html.parser')\n\n    # body type\n        body = page.find(itemprop = 'bodyType')\n        if body is None:\n            data_train.at[counter,'bodyType'] = None\n        else:\n            data_train.at[counter,'bodyType'] = body['content']\n\n    # color\n        color = page.find(itemprop = 'color')\n        if color is None:\n            data_train.at[counter,'color'] = None\n        else:\n            data_train.at[counter,'color'] = color['content']\n\n    # fuel type\n        fuel = page.find(itemprop = 'fuelType')\n        if fuel is None:\n            data_train.at[counter,'fuelType'] = None\n        else:\n            data_train.at[counter,'fuelType'] = fuel['content']\n\n    # model date\n        model_date = page.find(itemprop = 'modelDate')\n        if model_date is None:\n            data_train.at[counter,'modelDate'] = None\n        else:\n            data_train.at[counter,'modelDate'] = model_date['content']\n    \n    # number of doors\n        doors = page.find(itemprop = 'numberOfDoors')\n        if doors is None:\n            data_train.at[counter,'numberOfDoors'] = None\n        else:\n            data_train.at[counter,'numberOfDoors'] = doors['content']\n    \n    # production date\n        prod_date = page.find(itemprop = 'productionDate')\n        if prod_date is None:\n            data_train.at[counter,'productionDate'] = None\n        else:\n            data_train.at[counter,'productionDate'] = prod_date['content']\n    \n    # vehicle transmission\n        trans = page.find(itemprop = 'vehicleTransmission')\n        if trans is None:\n            data_train.at[counter,'vehicleTransmission'] = None\n        else:\n            data_train.at[counter,'vehicleTransmission'] = trans['content']\n    \n    # engine displacement\n        engine_ltr = page.find(itemprop = 'engineDisplacement')\n        if engine_ltr is None:\n            data_train.at[counter,'engineDisplacement'] = None\n        else:\n            data_train.at[counter,'engineDisplacement'] = engine_ltr['content']\n    \n    # engine power\n        engine_pwr = page.find(itemprop = 'enginePower')\n        if engine_pwr is None:\n            data_train.at[counter,'enginePower'] = None\n        else:\n            data_train.at[counter,'enginePower'] = engine_pwr['content']\n    \n    # mileage\n        mileage = page.find(class_ = 'CardInfoRow CardInfoRow_kmAge')\n        if mileage is None:\n            data_train.at[counter,'mileage'] = None\n        else:\n            mileage = mileage.text.replace('\u041f\u0440\u043e\u0431\u0435\u0433', '')\n            mileage = mileage.replace('\\xa0', '')\n            mileage = mileage.replace('\u043a\u043c', '')\n            data_train.at[counter,'mileage'] = mileage\n    \n    # drive type\n        drive = page.find(class_ = 'CardInfoRow CardInfoRow_drive')\n        if drive is None:\n            data_train.at[counter,'\u041f\u0440\u0438\u0432\u043e\u0434'] = None\n        else:\n            drive = drive.text.replace('\u041f\u0440\u0438\u0432\u043e\u0434', '')\n            data_train.at[counter,'\u041f\u0440\u0438\u0432\u043e\u0434'] = drive\n    \n    # wheel\n        wheel = page.find(class_ = 'CardInfoRow CardInfoRow_wheel')\n        if wheel is None:\n            data_train.at[counter,'\u0420\u0443\u043b\u044c'] = None\n        else:\n            wheel = wheel.text.replace('\u0420\u0443\u043b\u044c', '')\n            data_train.at[counter,'\u0420\u0443\u043b\u044c'] = wheel\n\n    # owners\n        owners = page.find(class_ = 'CardInfoRow CardInfoRow_ownersCount')\n        if owners is None:\n            data_train.at[counter,'\u0412\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u044b'] = None\n        else:\n            owners = owners.text.replace('\u0412\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u044b', '')\n            owners = owners.replace('\\xa0', '')\n            data_train.at[counter,'\u0412\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u044b'] = owners\n\n    # vehicle certificate\n        certificate = page.find(class_ = 'CardInfoRow CardInfoRow_pts')\n        if certificate is None:\n            data_train.at[counter,'\u041f\u0422\u0421'] = None\n        else:\n            certificate = certificate.text.replace('\u041f\u0422\u0421', '')\n            data_train.at[counter,'\u041f\u0422\u0421'] = certificate\n    \n    # ownership time\n        ownership = page.find(class_ = 'CardInfoRow CardInfoRow_owningTime')\n        if ownership is None:\n            data_train.at[counter,'\u0412\u043b\u0430\u0434\u0435\u043d\u0438\u0435'] = None\n        else:\n            ownership = ownership.text.replace('\u0412\u043b\u0430\u0434\u0435\u043d\u0438\u0435', '')\n            data_train.at[counter,'\u0412\u043b\u0430\u0434\u0435\u043d\u0438\u0435'] = ownership\n    \n    # price\n        price = page.find(class_ = 'OfferPriceCaption__price')\n        if price is None:\n            data_train.at[counter,'price'] = None\n        else:\n            price = price.text.replace('\\xa0', '')\n            price = price.replace('\u20bd', '')\n            data_train.at[counter,'price'] = price\n        \n    # counter up\n        counter += 1","a0f9e55e":"# Checking the data.\n# features_parser(card_url_list)","cac8a92c":"# Changing the data type to numeric.\n# data_train['modelDate'] = data_train['modelDate'].astype('float64')\n# data_train['numberOfDoors'] = data_train['numberOfDoors'].astype('float64')\n# data_train['productionDate'] = data_train['productionDate'].astype('float64')\n# data_train['mileage'] = data_train['mileage'].astype('float64')","a9e0c0db":"# Saving the data.\n# data_train.to_csv('raw_data_train.csv')","19ed196e":"# Checking the data.\ndata_train.info()\ndata_train.head(5)","d961a766":"# Dropping useless data.\ndata_train = data_train.drop(['Unnamed: 0',\n                              'brand',\n                              'name',\n                              'vehicleConfiguration',\n                              'description',\n                              '\u041a\u043e\u043c\u043f\u043b\u0435\u043a\u0442\u0430\u0446\u0438\u044f',\n                              '\u0421\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435',\n                              '\u0422\u0430\u043c\u043e\u0436\u043d\u044f',\n                              'id'], axis=1)","edaf5514":"# Dropping useless data.\nprice_nan = data_train[data_train['price'].isna()==True]\ndata_train = data_train.drop(price_nan.index)","5f86d1f0":"# Dropping useless data.\nowners_nan = data_train[data_train['\u0412\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u044b'].isna()==True]\ndata_train = data_train.drop(owners_nan.index)","1664d7d8":"# Processing the data.\ndata_train['engineDisplacement'] = data_train['engineDisplacement'].apply(\n    lambda string: string.replace(' LTR',''))","6a67deee":"# Processing the data.\nelectro_index_list = data_train[data_train['engineDisplacement']==''].index\n\nfor index in electro_index_list:\n    data_train.at[index,'engineDisplacement'] = 1.5","0a37b330":"# Changing the data type to numeric.\ndata_train['engineDisplacement'] = data_train['engineDisplacement'].astype('float64')","446f6fed":"# Processing the data.\ndata_train['engineDisplacement'] = data_train['engineDisplacement']*1000","9024e205":"# Processing the data.\ndata_train['enginePower'] = data_train['enginePower'].apply(\n    lambda string: string.replace(' N12',''))","74109355":"# Changing the data type to numeric.\ndata_train['enginePower'] = data_train['enginePower'].astype('float64')","b1b42bf6":"# Encoding a categorical variable.\nowners_dict = {\n    '1\u0432\u043b\u0430\u0434\u0435\u043b\u0435\u0446': 1,\n    '2\u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0430': 2,\n    '3 \u0438\u043b\u0438 \u0431\u043e\u043b\u0435\u0435': 3\n}\n\ndata_train['\u0412\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u044b'] = data_train['\u0412\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u044b'].map(owners_dict)","4888d9af":"# Encoding a categorical variable.\ntrans_dict = {\n    '\u043c\u0435\u0445\u0430\u043d\u0438\u0447\u0435\u0441\u043a\u0430\u044f': 1,\n    '\u0440\u043e\u0431\u043e\u0442\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u0430\u044f': 2,\n    '\u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0430\u044f': 3\n}\n\ndata_train['vehicleTransmission'] = data_train['vehicleTransmission'].map(trans_dict)","7d252d01":"# Encoding a categorical variable.\ndrive_dict = {\n    '\u043f\u0435\u0440\u0435\u0434\u043d\u0438\u0439': 1,\n    '\u0437\u0430\u0434\u043d\u0438\u0439': 2,\n    '\u043f\u043e\u043b\u043d\u044b\u0439': 3\n}\n\ndata_train['\u041f\u0440\u0438\u0432\u043e\u0434'] = data_train['\u041f\u0440\u0438\u0432\u043e\u0434'].map(drive_dict)","0c2b906f":"# Encoding a categorical variable.\npassport_dict = {\n    '\u0414\u0443\u0431\u043b\u0438\u043a\u0430\u0442': 0,\n    '\u041e\u0440\u0438\u0433\u0438\u043d\u0430\u043b': 1,\n}\n\ndata_train['\u041f\u0422\u0421'] = data_train['\u041f\u0422\u0421'].map(passport_dict)","e72e9b8a":"# Checking the correlation matrix.\ndata_train.corr().abs().sort_values(by='modelDate', ascending=False)","c9dedad6":"# Checking the correlation matrix.\ndata_train.corr().abs().sort_values(by='price', ascending=False)","c7061549":"# Dropping useless data.\nrigh_wheel_index = data_train[data_train['\u0420\u0443\u043b\u044c']=='\u041f\u0440\u0430\u0432\u044b\u0439'].index\ndata_train = data_train.drop(righ_wheel_index)","540b72a1":"# Dropping useless data.\ndata_train = data_train.drop(['\u0420\u0443\u043b\u044c'], axis=1)","2ff15f19":"# Checking for duplicates.\ndata_train.duplicated().value_counts()","5b8000a2":"# Dropping duplicates.\ndata_train = data_train.drop_duplicates()","b95cb31f":"# Checking the data.\ndata_train.info()","def684ee":"# Dropping the data.\ndata_train = data_train.drop(['\u0412\u043b\u0430\u0434\u0435\u043d\u0438\u0435'], axis=1)","168a45c9":"# Checking the data.\ndata_train.head()","968d70f3":"# Creating new features.\npopular_colors = ['\u0447\u0451\u0440\u043d\u044b\u0439', '\u0431\u0435\u043b\u044b\u0439', '\u0441\u0435\u0440\u044b\u0439', '\u0441\u0438\u043d\u0438\u0439', '\u0441\u0435\u0440\u0435\u0431\u0440\u0438\u0441\u0442\u044b\u0439', '\u043a\u043e\u0440\u0438\u0447\u043d\u0435\u0432\u044b\u0439']\nrare_colors = ['\u043a\u0440\u0430\u0441\u043d\u044b\u0439', '\u0437\u0435\u043b\u0451\u043d\u044b\u0439', '\u0433\u043e\u043b\u0443\u0431\u043e\u0439', '\u0431\u0435\u0436\u0435\u0432\u044b\u0439']\n\ndata_train['popular_color'] = 0\ndata_train['rare_color'] = 0\ndata_train['very_rare_color'] = 0","81d28ea5":"# Reseting indexes.\ndata_train = data_train.reset_index().drop('index',axis=1)","90c08b2b":"# Creating new features.\ncounter = 0\n\nfor color in data_train['color']:\n    if color in popular_colors:\n        data_train.at[counter,'popular_color'] = 1\n        counter += 1\n    elif color in rare_colors:\n        data_train.at[counter,'rare_color'] = 1\n        counter += 1\n    else:\n        data_train.at[counter,'very_rare_color'] = 1\n        counter += 1","6ee162f3":"# Creating new features.\ndata_train['low_mileage'] = 0\ndata_train['high_mileage'] = 0","fff34957":"# Creating new features.\ncounter = 0\n\nfor mileage in data_train['mileage']:\n    if mileage < 2000:\n        data_train.at[counter,'low_mileage'] = 1\n        counter += 1\n    elif mileage > 150000:\n        data_train.at[counter,'high_mileage'] = 1\n        counter += 1\n    else:\n        counter += 1","7703ae93":"# Creating new feature.\ndata_train['mileage_to_age'] = data_train['mileage']\/(2021-data_train['productionDate'])","930d6fd2":"# Creating new features.\ndata_train['low_MtA'] = 0\ndata_train['high_MtA'] = 0","9f399ce7":"# Creating new features.\ncounter = 0\n\nfor MtA in data_train['mileage_to_age']:\n    if MtA < 5000:\n        data_train.at[counter,'low_MtA'] = 1\n        counter += 1\n    elif MtA > 30000:\n        data_train.at[counter,'high_MtA'] = 1\n        counter += 1\n    else:\n        counter += 1","aad4d584":"# Checking the data.\npd.set_option('display.max_rows', 30)\ndata_train.nunique()","71598e85":"# Grouping features.\ncat_columns = ['bodyType',\n               'color',\n               'fuelType']\n\nbin_columns = ['\u041f\u0422\u0421',\n               'popular_color',\n               'rare_color',\n               'very_rare_color',\n               'low_mileage',\n               'high_mileage',\n               'low_MtA',\n               'high_MtA']\n\nnum_columns = ['modelDate', \n               'numberOfDoors', \n               'productionDate',\n               'vehicleTransmission',\n               'engineDisplacement',\n               'enginePower',\n               'mileage',\n               '\u041f\u0440\u0438\u0432\u043e\u0434',\n               '\u0412\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u044b',\n               'mileage_to_age',\n               'price']","6ee275a3":"# Changing the data type to integr.\ndata_train[num_columns] = data_train[num_columns].astype('int64')","9a2be690":"# Defining the preprocessing function.\ndef preproc_data(data_input):\n    \n    data_output = data_input.copy()\n    \n# Data Cleansing\n\n    # Dropping features\n    data_output = data_output.drop(['brand',\n                                    'name',\n                                    'vehicleConfiguration',\n                                    'description',\n                                    '\u041a\u043e\u043c\u043f\u043b\u0435\u043a\u0442\u0430\u0446\u0438\u044f', \n                                    '\u0420\u0443\u043b\u044c',\n                                    '\u0421\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435',\n                                    '\u0422\u0430\u043c\u043e\u0436\u043d\u044f', \n                                    '\u0412\u043b\u0430\u0434\u0435\u043d\u0438\u0435',\n                                    'id'], axis=1)\n    \n    \n    data_output['engineDisplacement'] = data_output['engineDisplacement'].apply(\n        lambda string: string.replace(' LTR',''))\n    \n    electro_index_list = data_output[data_output['engineDisplacement']=='undefined'].index\n    \n    for index in electro_index_list:\n        data_output.at[index,'engineDisplacement'] = 1.5\n        \n    data_output['engineDisplacement'] = data_output['engineDisplacement'].astype('float64')\n    data_output['engineDisplacement'] = data_output['engineDisplacement']*1000\n    \n    data_output['enginePower'] = data_output['enginePower'].apply(\n        lambda string: string.replace(' N12',''))\n    \n    data_output['enginePower'] = data_output['enginePower'].astype('float64')\n    \n    owners_dict = {\n        '1\\xa0\u0432\u043b\u0430\u0434\u0435\u043b\u0435\u0446': 1,\n        '2\\xa0\u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0430': 2,\n        '3 \u0438\u043b\u0438 \u0431\u043e\u043b\u0435\u0435': 3\n    }\n\n    data_output['\u0412\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u044b'] = data_output['\u0412\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u044b'].map(owners_dict)\n    \n    trans_dict = {\n        '\u043c\u0435\u0445\u0430\u043d\u0438\u0447\u0435\u0441\u043a\u0430\u044f': 1,\n        '\u0440\u043e\u0431\u043e\u0442\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u0430\u044f': 2,\n        '\u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0430\u044f': 3\n    }\n\n    data_output['vehicleTransmission'] = data_output['vehicleTransmission'].map(trans_dict)\n    \n    drive_dict = {\n        '\u043f\u0435\u0440\u0435\u0434\u043d\u0438\u0439': 1,\n        '\u0437\u0430\u0434\u043d\u0438\u0439': 2,\n        '\u043f\u043e\u043b\u043d\u044b\u0439': 3\n    }\n\n    data_output['\u041f\u0440\u0438\u0432\u043e\u0434'] = data_output['\u041f\u0440\u0438\u0432\u043e\u0434'].map(drive_dict)\n    \n    passport_dict = {\n        '\u0414\u0443\u0431\u043b\u0438\u043a\u0430\u0442': 0,\n        '\u041e\u0440\u0438\u0433\u0438\u043d\u0430\u043b': 1,\n    }\n\n    data_output['\u041f\u0422\u0421'] = data_output['\u041f\u0422\u0421'].map(passport_dict)\n    \n    popular_colors = ['\u0447\u0451\u0440\u043d\u044b\u0439', '\u0431\u0435\u043b\u044b\u0439', '\u0441\u0435\u0440\u044b\u0439', '\u0441\u0438\u043d\u0438\u0439', '\u0441\u0435\u0440\u0435\u0431\u0440\u0438\u0441\u0442\u044b\u0439', '\u043a\u043e\u0440\u0438\u0447\u043d\u0435\u0432\u044b\u0439']\n    rare_colors = ['\u043a\u0440\u0430\u0441\u043d\u044b\u0439', '\u0437\u0435\u043b\u0451\u043d\u044b\u0439', '\u0433\u043e\u043b\u0443\u0431\u043e\u0439', '\u0431\u0435\u0436\u0435\u0432\u044b\u0439']\n\n    data_output['popular_color'] = 0\n    data_output['rare_color'] = 0\n    data_output['very_rare_color'] = 0\n    \n    counter = 0\n\n    for color in data_output['color']:\n        if color in popular_colors:\n            data_output.at[counter,'popular_color'] = 1\n            counter += 1\n        elif color in rare_colors:\n            data_output.at[counter,'rare_color'] = 1\n            counter += 1\n        else:\n            data_output.at[counter,'very_rare_color'] = 1\n            counter += 1\n            \n    data_output['low_mileage'] = 0\n    data_output['high_mileage'] = 0\n    \n    counter = 0\n\n    for mileage in data_output['mileage']:\n        if mileage < 2000:\n            data_output.at[counter,'low_mileage'] = 1\n            counter += 1\n        elif mileage > 150000:\n            data_output.at[counter,'high_mileage'] = 1\n            counter += 1\n        else:\n            counter += 1\n            \n    data_output['mileage_to_age'] = data_output['mileage']\/(2021-data_output['productionDate'])\n    \n    data_output['low_MtA'] = 0\n    data_output['high_MtA'] = 0\n    \n    counter = 0\n\n    for MtA in data_output['mileage_to_age']:\n        if MtA < 5000:\n            data_output.at[counter,'low_MtA'] = 1\n            counter += 1\n        elif MtA > 30000:\n            data_output.at[counter,'high_MtA'] = 1\n            counter += 1\n        else:\n            counter += 1\n    \n    cat_columns = ['bodyType',\n                   'color',\n                   'fuelType']\n\n    bin_columns = ['\u041f\u0422\u0421',\n                   'popular_color',\n                   'rare_color',\n                   'very_rare_color',\n                   'low_mileage',\n                   'high_mileage',\n                   'low_MtA',\n                   'high_MtA']\n\n    num_columns = ['modelDate', \n                   'numberOfDoors', \n                   'productionDate',\n                   'vehicleTransmission',\n                   'engineDisplacement',\n                   'enginePower',\n                   'mileage',\n                   '\u041f\u0440\u0438\u0432\u043e\u0434',\n                   '\u0412\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u044b',\n                   'mileage_to_age']\n    \n    data_output[num_columns] = data_output[num_columns].astype('int64')\n    \n    return data_output","ba212be8":"# Preprocessing of data.\ndata_test = preproc_data(data_test)","ff44f380":"# Preparing data for learning.\nX = data_train.drop(['price'], axis=1)\nX_sub = data_test\ny = data_train.price.values\n\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size = valid_size, shuffle = True, random_state = random_seed)","26ad9e1f":"# CatBoost learning.\ncat_features_ids = np.where(X_train.apply(pd.Series.nunique) < 3000)[0].tolist()\n\nmodel = CatBoostRegressor(iterations = iterations,\n                          learning_rate = learning_rate,\n                          random_seed = random_seed,\n                          eval_metric='MAPE',\n                          custom_metric=['R2', 'MAE']\n                         )\n\nmodel.fit(X_train, y_train,\n         cat_features=cat_features_ids,\n         eval_set=(X_test, y_test),\n         verbose_eval=100,\n         use_best_model=True,\n         plot=True\n         )","2fb55aa6":"# Defining function for CatBoost.\ndef cat_model(y_train, X_train, X_test, y_test):\n    \n    model = CatBoostRegressor(iterations = iterations,\n                              learning_rate = learning_rate,\n                              random_seed = random_seed,\n                              eval_metric='MAPE')\n    \n    model.fit(X_train, y_train,\n              cat_features = cat_features_ids,\n              eval_set = (X_test, y_test),\n              verbose = False,\n              use_best_model = True,\n              plot = False)\n    \n    return(model)","d37ce0b6":"# Defining MAPE function.\ndef mape(y_true, y_pred):\n    return np.mean(np.abs((y_pred-y_true)\/y_true))","f0eff12c":"# Folds creating.\nsubmissions = pd.DataFrame(0,\n                           columns = [\"sub_1\"], \n                           index = sample_submission.index)\nscore_ls = []\n\nsplits = list(KFold(n_splits = num_folds, \n                    shuffle = True, \n                    random_state = random_seed).split(X, y))","d2ec9ef5":"# K-Fold cross-validation.\nfor idx, (train_idx, test_idx) in tqdm(enumerate(splits), total = num_folds):\n    \n    X_train, y_train, X_test, y_test = X.iloc[train_idx], y[train_idx], X.iloc[test_idx], y[test_idx]\n    \n    model = cat_model(y_train, X_train, X_test, y_test)\n    \n    test_predict = model.predict(X_test)\n    \n    test_score = mape(y_test, test_predict)\n    \n    score_ls.append(test_score)\n    \n    print(f\"{idx+1} Fold Test MAPE: {mape(y_test, test_predict):0.3f}\")\n    \n    submissions[f'sub_{idx+1}'] = model.predict(X_sub)\n    \n    model.save_model(f'catboost_fold_{idx+1}.model')\n    \nprint(f'Mean Score: {np.mean(score_ls):0.3f}')\nprint(f'Std Score: {np.std(score_ls):0.4f}')\nprint(f'Max Score: {np.max(score_ls):0.3f}')\nprint(f'Min Score: {np.min(score_ls):0.3f}')","011c653d":"# Checking the data.\nsubmissions.head(10)","4b9c5509":"# Submitting the results.\nsubmissions['blend'] = (submissions.sum(axis=1))\/len(submissions.columns)\nsample_submission['price'] = submissions['blend'].values*0.84\n# sample_submission.to_csv(f'submission_blend_v{version}.csv', index=False)","928e4d8c":"# One-hot encoding.\ndata_test_dummies = pd.get_dummies(data_test, prefix=cat_columns, columns=cat_columns)\ndata_train_dummies = pd.get_dummies(data_train, prefix=cat_columns, columns=cat_columns)","91381e6c":"# Checking the data.\nlist(set(data_test_dummies.columns) - set(data_train_dummies.columns))","09586843":"# Checking the data.\nlist(set(data_train_dummies.columns) - set(data_test_dummies.columns))","eedbc9be":"# Dropping the data.\ndata_test_dummies = data_test_dummies.drop(['bodyType_\u0440\u043e\u0434\u0441\u0442\u0435\u0440', \n                                            'bodyType_\u043a\u043e\u043c\u043f\u0430\u043a\u0442\u0432\u044d\u043d'], axis=1)","d67c0655":"# Dropping the data.\ndata_train_dummies = data_train_dummies.drop('color_\u0440\u043e\u0437\u043e\u0432\u044b\u0439', axis=1)","dc840d8f":"# Preparing data for learning.\nX_sub = data_test_dummies\ncolumn_order = X_sub.columns\n\nX = data_train_dummies.drop(['price'], axis=1)\nX = X[column_order]\n\ny = data_train_dummies.price.values\n\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size = valid_size, shuffle = True, random_state = random_seed)","939afd5b":"# Defining a function for calculating of meta-features.\ndef compute_meta_feature(model, X_train, X_test, y_train, cv):\n   \n    X_meta_train = np.zeros_like(y_train, dtype = np.float32)\n    \n    for train_fold_index, predict_fold_index in cv.split(X_train):\n        X_fold_train, X_fold_predict = X_train[train_fold_index], X_train[predict_fold_index]\n        y_fold_train = y_train[train_fold_index]\n        \n        folded_model = clone(model)\n        folded_model.fit(X_fold_train, y_fold_train)\n        X_meta_train[predict_fold_index] = folded_model.predict(X_fold_predict)\n        \n    meta_model = clone(model)\n    meta_model.fit(X_train, y_train)\n    \n    X_meta_test = meta_model.predict_proba(X_test)[:,1]\n    \n    return X_meta_train, X_meta_test","4c98d57a":"# CatBoost learning.\ncv = KFold(n_splits = num_folds, shuffle=True)\n\ncat_features_ids = np.where(X.apply(pd.Series.nunique) < 3000)[0].tolist()\n\nX_meta_train_features = []\nX_meta_test_features = []\n\nmodel = CatBoostRegressor(iterations = iterations,\n                          learning_rate = learning_rate,\n                          random_seed = random_seed,\n                          eval_metric='MAPE',\n                          custom_metric=['R2', 'MAE']\n                         )\n\nX_meta_train = np.zeros_like(y, dtype = np.float32)\nX_meta_test = np.zeros(len(X_sub), dtype = np.float32)\n\nfor train_fold_index, predict_fold_index in cv.split(X):\n    X_fold_train, X_fold_predict = X.iloc[train_fold_index], X.iloc[predict_fold_index]\n    y_fold_train = y[train_fold_index]\n\n    folded_model = clone(model)\n    folded_model.fit(X_fold_train, y_fold_train,\n                     cat_features=cat_features_ids,\n                     eval_set=(X_test, y_test),\n                     verbose_eval=1000,\n                     use_best_model=True,\n                     plot=False\n)\n    \n    X_meta_train[predict_fold_index] = folded_model.predict(X_fold_predict)\n    X_meta_test += folded_model.predict(X_sub)\n\nX_meta_test = X_meta_test \/ num_folds\n\nX_meta_train_features.append(X_meta_train)\nX_meta_test_features.append(X_meta_test)","3ba93ac1":"# RandomForest learning.\nmodel = RandomForestRegressor(n_estimators = 400, \n                              random_state = random_seed)\n\nX_meta_train = np.zeros_like(y, dtype = np.float32)\nX_train_num = X\nX_sub_num = X_sub\n\nfor train_fold_index, predict_fold_index in cv.split(X_train_num):\n    X_fold_train, X_fold_predict = X_train_num.iloc[train_fold_index], X_train_num.iloc[predict_fold_index]\n    y_fold_train = y[train_fold_index]\n\n    folded_model = clone(model)\n    folded_model.fit(X_fold_train, y_fold_train)\n    X_meta_train[predict_fold_index] = folded_model.predict(X_fold_predict)\n\nmeta_model = clone(model)\nmeta_model.fit(X_train_num, y)\n\nX_meta_test = meta_model.predict(X_sub_num)\n\nX_meta_train_features.append(X_meta_train)\nX_meta_test_features.append(X_meta_test)","f6ea3798":"# LinearRegression learning.\nmodel = LinearRegression(normalize = True)\n\nX_meta_train = np.zeros_like(y, dtype = np.float32)\n\nfor train_fold_index, predict_fold_index in cv.split(X_train_num):\n    X_fold_train, X_fold_predict = X_train_num.iloc[train_fold_index], X_train_num.iloc[predict_fold_index]\n    y_fold_train = y[train_fold_index]\n\n    folded_model = clone(model)\n    folded_model.fit(X_fold_train, y_fold_train)\n    X_meta_train[predict_fold_index] = folded_model.predict(X_fold_predict)\n\nmeta_model = clone(model)\nmeta_model.fit(X_train_num, y)\n\nX_meta_test = meta_model.predict(X_sub_num)\n\nX_meta_train_features.append(X_meta_train)\nX_meta_test_features.append(X_meta_test)","9a2cf747":"# Stacking features.\nstacked_features_train = np.vstack(X_meta_train_features[:2]).T\nstacked_features_test = np.vstack(X_meta_test_features[:2]).T","114da28e":"# Final model (LinearRegression) learning.\nfinal_model = LinearRegression()\nfinal_model.fit(stacked_features_train, y)","53802de4":"# Submitting the results.\nsample_submission['price'] = final_model.predict(stacked_features_test)*0.84\nsample_submission.head(10)\nsample_submission.to_csv(f'submission_stacked_v{version}.csv', index=False)","15af0941":"When parsing, we don't need battered cars. This feature can be dropped.","668d9aa5":"Let's define a function for collecting features from each URL.","08ffe399":"Let's change the numeric data type to int64 so that CatBoost can work correctly.","7f56f017":"This feature requires cleansing.","258e3d33":"Let's define a function for collecting links to car cards.","71db9f39":"Let's use one-hot encoding to prepare data for stacking.","7e39a0e0":"Let's delete these features, since they correspond to very few values.","ccee6817":"# 1. Initial setup","df1487c4":"## Best MAPE = 15.66713852","e8a7ba4b":"The ID attribute is a simple identifier that can be dropped.","eb926797":"Let's create the binary feature \"popular color\", \"rare color\" and \"very rare color\".","b7c95390":"Let's make a list of links for parsing to get around the 99-page limit. We will only need to parse used cars. Also, let's focus on popular models so our model could be well-balanced.","0a7db68c":"As expected, the model launch year strongly correlates with the production date. There is also a strong inverse correlation with mileage, which is logical - the longer the model's production year (i.e., the newer it is), the lower the mileage. It is logical to drop some of the characteristics. We will evaluate this later on the training dataset.","22bef791":"The 'name' feature duplicates existing variables, so we can drop it.","2a189b0f":"The car's production year should strongly correlate with the model's launch year and mileage. Let's check it.","29fb2ef7":"Let's define a preprocessing function and modify it to work with test data.","15695566":"The configuration feature is a candidate for deletion, because we need a lot of time to work through it, which is better spent on stacking.","0b245f6a":"The average MtA is 10-20 thousand km per year. The deviation from this number will be recorded in the binary features \"high mileage-to-age ratio\" and \"low mileage-to-age ratio\".","861230b0":"Adding a coefficient to compensate for the fall in the ruble exchange rate. The coefficient is calculated as follows: 75 (dollar exchange rate at the time of collecting training data - December 2020) \/ 63 (dollar exchange rate at the time of collecting test data - February 2020) = 0.84","6cf145d2":"The description is a candidate for deletion, because we need a lot of time to work through this feature, which is better spent on stacking.","6f4b1bce":"![](https:\/\/www.bmw.ru\/content\/dam\/bmw\/marketRU\/bmw_ru\/all-models\/5-series\/sedan\/2020\/bmw-5-series-sedan-highlights-sp-xxl-2.jpg.asset.1598856579983.jpg)\n\nThis was my first experience of parsing data, using the CatBoost library, and stacking, which I did in the data Science course from SkillFactory. The legend said that we have a dataset with the characteristics of used BMW cars. The task was to build a model for predicting the cost of such cars, based on data collected from the Internet.","5e61cb7d":"The \"Ownership\" column carries too many missed values, so let's drop it for now. Maybe later we will try to predict its values, if there is time left.","4856ef15":"# 9. Recap & Conclusions","67dda05a":"## Best MAPE = 12.06346","4f7d8f77":"CatBoost requires an integer format for input, so to save our data, we will convert the liter to milliliters.","0e784b0c":"All the engines presented are N12, so we don't need to parse the others. Also we can clear the feature from the text.","58892c64":"Let's remove the \"\u0420\u0443\u043b\u044c\" feature, because all the remaining cars are left-wheel.","5a974c78":"Let's remove the right-wheel cars.","e28f61c9":"Let's create the binary features \"close to zero mileage\" (less than 2 thousand km) and \"high mileage\" (over 150 thousand km).","4837ebd8":"# 5. Data cleansing & feature engineering","da11e9a6":"Let's define a function for determining the number of pages.","f8ae661f":"When parsing, we don't need right-hand drive cars. This feature can be dropped.","5216430f":"The vast majority of cars presented are 3-10 years old.","ab9de1ea":"Compact vans, roadsters, and two-door sedans can be ignored when parsing.","08e9cbcd":"* bodyType - car body type, categorical variable.\n* brand - car brand, categorical variable.\n* color - car color, categorical variable.\n* fuelType - car fuel type, categorical variable.\n* modelDate - manufacturing launch year, categorical variable.\n* name - combination of several features, requires processing.\n* numberOfDoors - number of car doors, categorical variable. \n* productionDate - year of manufacture, categorical variable.\n* vehicleConfiguration - combination of several features, requires processing.\n* vehicleTransmission - car transmission type, categorical variable.\n* engineDisplacement - car engine displacement, categorical variable, requires processing.\n* enginePower - car engine power, categorical variable, requires processing.\n* description - vehicle description,text variable, requires processing.\n* mileage - car mileage, continuous variable. \n* \u041a\u043e\u043c\u043f\u043b\u0435\u043a\u0442\u0430\u0446\u0438\u044f - combination of several features, requires processing.\n* \u041f\u0440\u0438\u0432\u043e\u0434 - car layout, categorical variable.\n* \u0420\u0443\u043b\u044c - car wheel position, categorical variable.\n* \u0421\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 - car condition, categorical variable.\n* \u0412\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u044b - number of owners, categorical variable. \n* \u041f\u0422\u0421 - car registration certificate, binary variable.\n* \u0422\u0430\u043c\u043e\u0436\u043d\u044f - customs clearance, categorical variable.  \n* \u0412\u043b\u0430\u0434\u0435\u043d\u0438\u0435 - ownership time, requires processing and missing values correction.","5be1037b":"Let's create the feature \"mileage\/age ratio per year\".","15c003b2":"As we can see, some of the cars with abnormally low mileage are demonstration cars from car dealerships.","eeed3025":"Let's remove the cards without data on price and owners.","9f4899f5":"Grouping features by data type.","fd3633fb":"# 3. Analysis of variables","3df2d709":"We are hindered by BMW i3 electric cars, which do not have a engine fuel capacity. Similar B-class hatchbacks (Ford Fiesta, Kia Rio, Chevrolet Aveo, Audi A1) that run on internal combustion engines have an engine capacity of 1.4-1.6 liters, so we will set 1.5 liters for our electric vehicles.","587e43c0":"'\u041f\u0422\u0421' is, in fact, a binary feature, where 1 is the presence of the original, and 0 is its absence, i.e. a duplicate.","a8267d65":"# 6. ML","188b95f0":"Let's check the data for duplicates.","f0cebc88":"# 2. Preliminary data examination","28d1c3eb":"## Best MAPE = 14.86577","158ef747":"The 'vehicle configuration' feature duplicates existing variables, so we can drop it.","59b890b8":"As we can see, the distribution might have been normal if not for the abundance of cars with almost zero mileage. Also interesting is the long tail of cars with very high mileage. Let's check it.","a6c24510":"Let's drop empty and useless columns.","d94599f5":"# 8. Stacking","97161cd2":"The most popular colors, as we can see, are black, white, blue, brown, and silver.","88fa4bce":"Let's deal with the 'owners' feature.","424d65c4":"# 7. Cross-validation","90bf020f":"Let's create an empty list for links to car cards.","6e03f0f5":"Transmission and drive are categorical features with hidden order - MT<robot<AT, front<rear<4x4.","689d10e9":"There are a lot of missed values in this column. Perhaps we should drop this feature, since it has a strong correlation with the year of production.","95489d3b":"# General information","7591f02e":"When parsing, we do not need cars without customs clearance. This feature can be dropped.","66a2677c":"Let's deal with the engine displacement.","468660f4":"Let's check if there are mismatched columns in the datasets.","639067af":"All presented cars are BMW, so we will only parse this brand. This feature can be dropped.","e117faca":"Let's follow the actions taken:\n\n* We initialized necessary libraries, set visualization conditions and loaded the dataset.\n* We analyzed the features, identified the target variable, looked at external sources, and suggested which features we can rely on for feature engineering.\n* We checked each variable, frequency distributions and created several new features.\n* We encoded categorical variables and changed data type for numeric features.\n* We parsed train data from external source and pre-processed it for CatBoost.\n* We trained CatBoost on the available data and evaluated the quality of its prediction using confusion MAPE.\n* We used cross-validation and stacking to improve our result.\n\nThe following conclusions can be drawn from the results:\n\n* CatBoost is a very unpretentious library and can use even partially processed data.\n* Stacking can have a significant impact on metrics.\n* When processing the results, we should take into account the circumstances (for example, currency fluctuations).","f96cfdaf":"# 4. Parsing","d7ddea62":"Let's deal with the engine power."}}