{"cell_type":{"67ac22be":"code","9d60c42e":"code","9d06f239":"code","8dd26280":"code","a5938572":"code","eee43405":"code","6a8f938f":"code","47b5c055":"code","8bc4abf6":"code","4e554aa6":"code","410e2a90":"code","554744f4":"code","3d2e730d":"code","3886f57f":"code","58cdcd42":"code","e37a42fb":"code","eb050747":"code","809dcea1":"code","8c605d8a":"code","08d86430":"code","968fc15e":"code","82b4d8c8":"code","744cbf1d":"code","430cdb7b":"code","aaeb15eb":"markdown","d315a2da":"markdown","7ab418f2":"markdown","9d56f6e4":"markdown","350893bb":"markdown","30d2eeca":"markdown","3ba296bc":"markdown","04c11be4":"markdown","ef0b9b8c":"markdown","b6110ac0":"markdown","bfcb999d":"markdown","e5dfad39":"markdown","97aa0c41":"markdown","b752893d":"markdown","cd9a866e":"markdown","37f4d19f":"markdown","502b53f4":"markdown"},"source":{"67ac22be":"import os, cv2\nimport numpy as np\nimport pandas as pd\nimport random, tqdm\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import DataLoader\nimport albumentations as album","9d60c42e":"!pip install -q -U segmentation-models-pytorch albumentations > \/dev\/null\nimport segmentation_models_pytorch as smp","9d06f239":"DATA_DIR = '..\/input\/clothing-coparsing-dataset'\n\nmetadata_df = pd.read_csv(os.path.join(DATA_DIR, 'metadata.csv'))\nmetadata_df = metadata_df[['image_path', 'label_type', 'label_path']]\nmetadata_df['image_path'] = metadata_df['image_path'].apply(lambda img_pth: os.path.join(DATA_DIR, img_pth))\nmetadata_df['label_path'] = metadata_df['label_path'].apply(lambda lbl_pth: os.path.join(DATA_DIR, 'labels', lbl_pth))\n\n# Select data subset with pixel-level annotations (ignoring image-level annotations)\nmetadata_df = metadata_df[metadata_df['label_type']=='pixel-level']\n\n# Shuffle DataFrame\nmetadata_df = metadata_df.sample(frac=1).reset_index(drop=True)\n\n# Perform 90\/10 split for train \/ val\nvalid_df = metadata_df.sample(frac=0.05, random_state=42)\ntrain_df = metadata_df.drop(valid_df.index)\nlen(train_df), len(valid_df)","8dd26280":"class_dict = pd.read_csv(os.path.join(DATA_DIR, 'class_dict.csv'))\n# Get class names\nclass_names = class_dict['class_name'].tolist()\n# Rewriting 'null' class to prevent a NaN value \nclass_names[0] = 'null'\n# Get class RGB values\nclass_rgb_values = class_dict[['r','g','b']].values.tolist()\n\nprint('All dataset classes and their corresponding RGB values in labels:')\nprint('\\nClass Names: ', class_names)\nprint('\\nClass RGB values: ', class_rgb_values)","a5938572":"# Useful to shortlist specific classes in datasets with large number of classes\nselect_classes = ['null', 'accessories', 'bag', 'belt', 'blazer', 'blouse', 'bodysuit',\n                  'boots', 'bra', 'bracelet', 'cape', 'cardigan', 'clogs', 'coat', 'dress',\n                  'earrings', 'flats', 'glasses', 'gloves', 'hair', 'hat', 'heels', 'hoodie',\n                  'intimate', 'jacket', 'jeans', 'jumper', 'leggings', 'loafers', 'necklace',\n                  'panties', 'pants', 'pumps', 'purse', 'ring', 'romper', 'sandals', 'scarf',\n                  'shirt', 'shoes', 'shorts', 'skin', 'skirt', 'sneakers', 'socks', 'stockings',\n                  'suit', 'sunglasses', 'sweater', 'sweatshirt', 'swimwear', 't-shirt', 'tie',\n                  'tights', 'top', 'vest', 'wallet', 'watch', 'wedges']\n\n# Get RGB values of required classes\nselect_class_indices = [class_names.index(cls.lower()) for cls in select_classes]\nselect_class_rgb_values =  np.array(class_rgb_values)[select_class_indices]\n\nprint('Selected classes and their corresponding RGB values in labels:')\nprint('\\nClass Names: ', class_names)\nprint('\\nClass RGB values: ', class_rgb_values)","eee43405":"# helper function for data visualization\ndef visualize(**images):\n    \"\"\"\n    Plot images in one row\n    \"\"\"\n    n_images = len(images)\n    plt.figure(figsize=(20,8))\n    for idx, (name, image) in enumerate(images.items()):\n        plt.subplot(1, n_images, idx + 1)\n        plt.xticks([]); \n        plt.yticks([])\n        # get title from the parameter names\n        plt.title(name.replace('_',' ').title(), fontsize=20)\n        plt.imshow(image)\n    plt.show()\n\n# Perform one hot encoding on label\ndef one_hot_encode(label, label_values):\n    \"\"\"\n    Convert a segmentation image label array to one-hot format\n    by replacing each pixel value with a vector of length num_classes\n    # Arguments\n        label: The 2D array segmentation image label\n        label_values\n        \n    # Returns\n        A 2D array with the same width and hieght as the input, but\n        with a depth size of num_classes\n    \"\"\"\n    semantic_map = []\n    for colour in label_values:\n        equality = np.equal(label, colour)\n        class_map = np.all(equality, axis = -1)\n        semantic_map.append(class_map)\n    semantic_map = np.stack(semantic_map, axis=-1)\n\n    return semantic_map\n    \n# Perform reverse one-hot-encoding on labels \/ preds\ndef reverse_one_hot(image):\n    \"\"\"\n    Transform a 2D array in one-hot format (depth is num_classes),\n    to a 2D array with only 1 channel, where each pixel value is\n    the classified class key.\n    # Arguments\n        image: The one-hot format image \n        \n    # Returns\n        A 2D array with the same width and hieght as the input, but\n        with a depth size of 1, where each pixel value is the classified \n        class key.\n    \"\"\"\n    x = np.argmax(image, axis = -1)\n    return x\n\n# Perform colour coding on the reverse-one-hot outputs\ndef colour_code_segmentation(image, label_values):\n    \"\"\"\n    Given a 1-channel array of class keys, colour code the segmentation results.\n    # Arguments\n        image: single channel array where each value represents the class key.\n        label_values\n\n    # Returns\n        Colour coded image for segmentation visualization\n    \"\"\"\n    colour_codes = np.array(label_values)\n    x = colour_codes[image.astype(int)]\n\n    return x","6a8f938f":"class ClothesDataset(torch.utils.data.Dataset):\n\n    \"\"\"Clothes Co-Parsing Dataset. Read images, apply augmentation and preprocessing transformations.\n    \n    Args:\n        df (str): DataFrame containing images \/ labels paths\n        class_rgb_values (list): RGB values of select classes to extract from segmentation mask\n        augmentation (albumentations.Compose): data transfromation pipeline \n            (e.g. flip, scale, etc.)\n        preprocessing (albumentations.Compose): data preprocessing \n            (e.g. noralization, shape manipulation, etc.)\n    \n    \"\"\"\n    def __init__(\n            self, \n            df,\n            class_rgb_values=None, \n            augmentation=None, \n            preprocessing=None,\n    ):\n        self.image_paths = df['image_path'].tolist()\n        self.mask_paths = df['label_path'].tolist()\n        \n        self.class_rgb_values = class_rgb_values\n        self.augmentation = augmentation\n        self.preprocessing = preprocessing\n    \n    def __getitem__(self, i):\n        \n        # read images and masks\n        image = cv2.imread(self.image_paths[i])[:,:,::-1]\n        mask = cv2.imread(self.mask_paths[i])[:,:,::-1]\n        \n        # one-hot-encode the mask\n        mask = one_hot_encode(mask, self.class_rgb_values).astype('float')\n        \n        # apply augmentations\n        if self.augmentation:\n            sample = self.augmentation(image=image, mask=mask)\n            image, mask = sample['image'], sample['mask']\n        \n        # apply preprocessing\n        if self.preprocessing:\n            sample = self.preprocessing(image=image, mask=mask)\n            image, mask = sample['image'], sample['mask']\n            \n        return image, mask\n        \n    def __len__(self):\n        # return length of \n        return len(self.image_paths)","47b5c055":"dataset = ClothesDataset(train_df, class_rgb_values=select_class_rgb_values)\nrandom_idx = random.randint(0, len(dataset)-1)\nimage, mask = dataset[random_idx]\n\nvisualize(\n    original_image = image,\n    ground_truth_mask = colour_code_segmentation(reverse_one_hot(mask), select_class_rgb_values),\n    one_hot_encoded_mask = reverse_one_hot(mask)\n)","8bc4abf6":"def get_training_augmentation():\n    train_transform = [\n        # album.PadIfNeeded(min_height=896, min_width=576, always_apply=True, border_mode=0),\n        album.ShiftScaleRotate(scale_limit=0.16, rotate_limit=30, shift_limit=0.16, p=0.8, border_mode=0),\n        album.RandomCrop(height=384, width=384, always_apply=True),\n        album.OneOf(\n            [\n                album.HorizontalFlip(p=1),\n            ],\n            p=0.5,\n        ),\n    ]\n    return album.Compose(train_transform)\n\n\ndef get_validation_augmentation():\n    # Add sufficient padding to ensure image is divisible by 64\n    test_transform = [\n        album.PadIfNeeded(min_height=896, min_width=576, always_apply=True, border_mode=0),\n    ]\n    return album.Compose(test_transform)\n\n\ndef to_tensor(x, **kwargs):\n    return x.transpose(2, 0, 1).astype('float32')\n\n\ndef get_preprocessing(preprocessing_fn=None):\n    \"\"\"Construct preprocessing transform    \n    Args:\n        preprocessing_fn (callable): data normalization function \n            (can be specific for each pretrained neural network)\n    Return:\n        transform: albumentations.Compose\n    \"\"\"   \n    _transform = []\n    if preprocessing_fn:\n        _transform.append(album.Lambda(image=preprocessing_fn))\n    _transform.append(album.Lambda(image=to_tensor, mask=to_tensor))\n        \n    return album.Compose(_transform)","4e554aa6":"augmented_dataset = ClothesDataset(\n    train_df, \n    augmentation=get_training_augmentation(),\n    class_rgb_values=select_class_rgb_values,\n)\n\nrandom_idx = random.randint(0, len(augmented_dataset)-1)\n\n# Different augmentations on image\/mask pairs\nfor idx in range(8):\n    image, mask = augmented_dataset[idx]\n    visualize(\n        original_image = image,\n        ground_truth_mask = colour_code_segmentation(reverse_one_hot(mask), select_class_rgb_values),\n        one_hot_encoded_mask = reverse_one_hot(mask)\n    )","410e2a90":"ENCODER = 'resnet50'\nENCODER_WEIGHTS = 'imagenet'\nCLASSES = select_classes\nACTIVATION = 'sigmoid' # could be None for logits or 'softmax2d' for multiclass segmentation\n\n# create segmentation model with pretrained encoder\nmodel = smp.PAN(\n    encoder_name=ENCODER, \n    encoder_weights=ENCODER_WEIGHTS, \n    classes=len(CLASSES), \n    activation=ACTIVATION,\n)\n\npreprocessing_fn = smp.encoders.get_preprocessing_fn(ENCODER, ENCODER_WEIGHTS)","554744f4":"# Get train and val dataset instances\ntrain_dataset = ClothesDataset(\n    train_df, \n    augmentation=get_training_augmentation(),\n    preprocessing=get_preprocessing(preprocessing_fn),\n    class_rgb_values=select_class_rgb_values,\n)\n\nvalid_dataset = ClothesDataset(\n    valid_df, \n    augmentation=get_validation_augmentation(), \n    preprocessing=get_preprocessing(preprocessing_fn),\n    class_rgb_values=select_class_rgb_values,\n)\n\n# Get train and val data loaders\ntrain_loader = DataLoader(train_dataset, batch_size=12, shuffle=True, num_workers=4)\nvalid_loader = DataLoader(valid_dataset, batch_size=4, shuffle=False, num_workers=4)","3d2e730d":"# Set flag to train the model or not. If set to 'False', only prediction is performed (using an older model checkpoint)\nTRAINING = True\n\n# Set num of epochs\nEPOCHS = 20\n\n# Set device: `cuda` or `cpu`\nDEVICE = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n# define loss function\nloss = smp.utils.losses.DiceLoss()\n\n# define metrics\nmetrics = [\n    smp.utils.metrics.IoU(threshold=0.5),\n]\n\n# define optimizer\noptimizer = torch.optim.Adam([ \n    dict(params=model.parameters(), lr=0.0001),\n])\n\n# define learning rate scheduler (not used in this NB)\nlr_scheduler = torch.optim.lr_scheduler.CosineAnnealingWarmRestarts(\n    optimizer, T_0=1, T_mult=2, eta_min=5e-5,\n)\n\n# load best saved model checkpoint from previous commit (if present)\nif os.path.exists('..\/input\/pyramid-attention-network-pan-resnet50-pytorch\/best_model.pth'):\n    model = torch.load('..\/input\/pyramid-attention-network-pan-resnet50-pytorch\/best_model.pth', map_location=DEVICE)","3886f57f":"train_epoch = smp.utils.train.TrainEpoch(\n    model, \n    loss=loss, \n    metrics=metrics, \n    optimizer=optimizer,\n    device=DEVICE,\n    verbose=True,\n)\n\nvalid_epoch = smp.utils.train.ValidEpoch(\n    model, \n    loss=loss, \n    metrics=metrics, \n    device=DEVICE,\n    verbose=True,\n)","58cdcd42":"%%time\n\nif TRAINING:\n\n    best_iou_score = 0.0\n    train_logs_list, valid_logs_list = [], []\n\n    for i in range(0, EPOCHS):\n\n        # Perform training & validation\n        print('\\nEpoch: {}'.format(i))\n        train_logs = train_epoch.run(train_loader)\n        valid_logs = valid_epoch.run(valid_loader)\n        train_logs_list.append(train_logs)\n        valid_logs_list.append(valid_logs)\n\n        # Save model if a better val IoU score is obtained\n        if best_iou_score < valid_logs['iou_score']:\n            best_iou_score = valid_logs['iou_score']\n            torch.save(model, '.\/best_model.pth')\n            print('Model saved!')","e37a42fb":"# load best saved model checkpoint from the current run\nif os.path.exists('.\/best_model.pth'):\n    best_model = torch.load('.\/best_model.pth', map_location=DEVICE)\n    print('Loaded PAN model from this run.')\n\n# load best saved model checkpoint from previous commit (if present)\nelif os.path.exists('..\/input\/pyramid-attention-network-pan-resnet50-pytorch\/best_model.pth'):\n    best_model = torch.load('..\/input\/pyramid-attention-network-pan-resnet50-pytorch\/best_model.pth', map_location=DEVICE)\n    print('Loaded PAN model from a previous commit.')","eb050747":"# create test dataloader (with preprocessing operation: to_tensor(...))\ntest_dataset = ClothesDataset(\n    valid_df, \n    augmentation=get_validation_augmentation(), \n    preprocessing=get_preprocessing(preprocessing_fn),\n    class_rgb_values=select_class_rgb_values,\n)\n\ntest_dataloader = DataLoader(test_dataset)\n\n# test dataset for visualization (without preprocessing augmentations & transformations)\ntest_dataset_vis = ClothesDataset(\n    valid_df,\n    class_rgb_values=select_class_rgb_values,\n)\n\n# get a random test image\/mask index\nrandom_idx = random.randint(0, len(test_dataset_vis)-1)\nimage, mask = test_dataset_vis[random_idx]\n\nvisualize(\n    original_image = image,\n    ground_truth_mask = colour_code_segmentation(reverse_one_hot(mask), select_class_rgb_values),\n    one_hot_encoded_mask = reverse_one_hot(mask)\n)","809dcea1":"# Center crop padded image \/ mask to original image dims\ndef crop_image(image, true_dimensions):\n    return album.CenterCrop(p=1, height=true_dimensions[0], width=true_dimensions[1])(image=image)","8c605d8a":"sample_preds_folder = 'sample_predictions\/'\nif not os.path.exists(sample_preds_folder):\n    os.makedirs(sample_preds_folder)","08d86430":"for idx in range(len(test_dataset)):\n\n    image, gt_mask = test_dataset[idx]\n    image_vis = test_dataset_vis[idx][0].astype('uint8')\n    true_dimensions = image_vis.shape\n    x_tensor = torch.from_numpy(image).to(DEVICE).unsqueeze(0)\n    # Predict test image\n    pred_mask = best_model(x_tensor)\n    pred_mask = pred_mask.detach().squeeze().cpu().numpy()\n    # Convert pred_mask from `CHW` format to `HWC` format\n    pred_mask = np.transpose(pred_mask,(1,2,0))\n    pred_mask = crop_image(colour_code_segmentation(reverse_one_hot(pred_mask), select_class_rgb_values), true_dimensions)['image']\n    # Convert gt_mask from `CHW` format to `HWC` format\n    gt_mask = np.transpose(gt_mask,(1,2,0))\n    gt_mask = crop_image(colour_code_segmentation(reverse_one_hot(gt_mask), select_class_rgb_values), true_dimensions)['image']\n    cv2.imwrite(os.path.join(sample_preds_folder, f\"sample_pred_{idx}.png\"), np.hstack([image_vis, gt_mask, pred_mask])[:,:,::-1])\n    \n    visualize(\n        original_image = image_vis,\n        ground_truth_mask = gt_mask,\n        predicted_mask = pred_mask,\n    )","968fc15e":"test_epoch = smp.utils.train.ValidEpoch(\n    model,\n    loss=loss, \n    metrics=metrics, \n    device=DEVICE,\n    verbose=True,\n)\n\nvalid_logs = test_epoch.run(test_dataloader)\nprint(\"Evaluation on Test Data: \")\nprint(f\"Mean IoU Score: {valid_logs['iou_score']:.4f}\")\nprint(f\"Mean Dice Loss: {valid_logs['dice_loss']:.4f}\")","82b4d8c8":"train_logs_df = pd.DataFrame(train_logs_list)\nvalid_logs_df = pd.DataFrame(valid_logs_list)\ntrain_logs_df.T","744cbf1d":"plt.figure(figsize=(20,8))\nplt.plot(train_logs_df.index.tolist(), train_logs_df.iou_score.tolist(), lw=3, label = 'Train')\nplt.plot(valid_logs_df.index.tolist(), valid_logs_df.iou_score.tolist(), lw=3, label = 'Valid')\nplt.xlabel('Epochs', fontsize=20)\nplt.ylabel('IoU Score', fontsize=20)\nplt.title('IoU Score Plot', fontsize=20)\nplt.legend(loc='best', fontsize=16)\nplt.grid()\nplt.savefig('iou_score_plot.png')\nplt.show()","430cdb7b":"plt.figure(figsize=(20,8))\nplt.plot(train_logs_df.index.tolist(), train_logs_df.dice_loss.tolist(), lw=3, label = 'Train')\nplt.plot(valid_logs_df.index.tolist(), valid_logs_df.dice_loss.tolist(), lw=3, label = 'Valid')\nplt.xlabel('Epochs', fontsize=20)\nplt.ylabel('Dice Loss', fontsize=20)\nplt.title('Dice Loss Plot', fontsize=20)\nplt.legend(loc='best', fontsize=16)\nplt.grid()\nplt.savefig('dice_loss_plot.png')\nplt.show()","aaeb15eb":"#### Set Hyperparams","d315a2da":"### Libraries \ud83d\udcda\u2b07","7ab418f2":"## Training Pyramid Attention Network","9d56f6e4":"### Model Evaluation on Test Dataset","350893bb":"### Plot Dice Loss & IoU Metric for Train vs. Val","30d2eeca":"### Read Data & Create train \/ valid splits \ud83d\udcc1","3ba296bc":"## Introduction\n\n### In this notebook we use [Pyramid Attention Network (PAN)](https:\/\/arxiv.org\/abs\/1805.10180) segmentation model for Human \/ Cloth Parsing on [Clothing Co-Parsing Dataset](http:\/\/www.sysu-hcp.net\/clothing-co-parsing-by-joint-image-segmentation-and-labeling\/).\n\n#### [Kaggle [Clothing Co-Parsing Dataset](https:\/\/www.kaggle.com\/balraj98\/clothing-coparsing-dataset\/notebooks)]","04c11be4":"#### Visualize Augmented Images & Masks","ef0b9b8c":"<h3><center>Pyramid Attention Network Model Architecture<\/center><\/h3>\n<img src=\"https:\/\/d3i71xaburhd42.cloudfront.net\/bea705a6a3793ffa2f61c33a82b759ad9f706947\/4-Figure3-1.png\" width=\"850\" height=\"850\"\/>\n<h2><\/h2>\n<h4><center><a href=\"https:\/\/arxiv.org\/abs\/1805.10180\">Image Courtesy: Pyramid Attention Network [Li et al.]<\/a><\/center><\/h4>","b6110ac0":"#### Get Train \/ Val DataLoaders","bfcb999d":"### Helper functions for viz. & one-hot encoding\/decoding","e5dfad39":"#### Visualize Sample Image and Mask \ud83d\udcc8","97aa0c41":"#### Shortlist specific classes to segment","b752893d":"### Model Definition","cd9a866e":"### Defining Augmentations \ud83d\ude43","37f4d19f":"### Training Pyramid Attention Network","502b53f4":"### Prediction on Test Data"}}