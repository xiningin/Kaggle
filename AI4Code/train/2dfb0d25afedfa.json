{"cell_type":{"d12c629c":"code","9b2bc2f6":"code","c5d80178":"code","abf1ab50":"code","0777c706":"code","c7a694de":"code","61f8c12f":"code","79095110":"code","d6bb07d7":"code","39444bfb":"code","74c81783":"code","c7af9be8":"code","ff79e497":"code","46d20fe5":"code","98b3fefa":"code","27693a4b":"code","bbc654e2":"code","0632a502":"code","df4c49d1":"code","b7bea9d5":"code","e8ea3477":"code","14d61204":"code","ec2e1421":"code","8671780b":"code","ed1c9404":"code","3f1b9674":"code","0875e62a":"code","8a45a20f":"code","7b39b0f5":"code","017587e3":"code","ba4e6767":"code","71791896":"code","5e615ee5":"code","0f57ef25":"code","0300eadb":"code","b6711bae":"code","27ede7d0":"code","3775ec67":"code","c188b6e4":"code","49ed8fe4":"code","6cb37a29":"code","e5b26423":"code","c56ea495":"code","5d1e1fcb":"code","7b6e4cbb":"code","59b698ab":"code","f4d9f296":"code","e3263510":"code","99ebceb5":"code","9d4438bd":"code","6caeedf1":"code","954e0eb4":"code","eefca4af":"code","e913dd28":"code","b12c5d5d":"code","0f7ccf9b":"code","2bf91628":"code","1d00b4a1":"code","7b5e0f9a":"code","8166d2ad":"code","d98bb3db":"code","5e67edc5":"code","4b6e4258":"code","4533f0b1":"code","cc4c7f46":"code","a005ae83":"code","a274db78":"code","17aa643a":"code","e5c026e0":"code","a1dde1a9":"code","5aa29a69":"code","1284560e":"code","d7bbb1cd":"code","d8b7941f":"code","b8964c48":"code","88147ffa":"code","fb39230e":"code","72cfc17e":"code","4b0d23f6":"code","bfc405bb":"code","44a0845b":"code","c81e84fb":"code","c4cd8dae":"code","f3f93a74":"code","3d624391":"code","b78b643d":"code","5efdba85":"markdown"},"source":{"d12c629c":"import numpy as np\nimport pandas as pd","9b2bc2f6":"import os","c5d80178":"from sklearn.impute import SimpleImputer","abf1ab50":"from sklearn.preprocessing import StandardScaler","0777c706":"from sklearn.model_selection import train_test_split, KFold","c7a694de":"import matplotlib.pyplot as plt\n","61f8c12f":"INPUT = '..\/input\/tabular-playground-series-sep-2021'\ntrain_path = os.path.join(INPUT, 'train.csv')\ntest_path = os.path.join(INPUT, 'test.csv')\ntrain = pd.read_csv(train_path)\ntest = pd.read_csv(test_path)","79095110":"train.head()","d6bb07d7":"test.head()","39444bfb":"train['claim'].value_counts()","74c81783":"train.describe()","c7af9be8":"test.describe()","ff79e497":"train.info()","46d20fe5":"test.info()","98b3fefa":"train.isnull().any().sum()","27693a4b":"test.isnull().any().sum()","bbc654e2":"train.head()","0632a502":"# missing_cols = [col for col in train.columns if train[col].isnull().any()]\nfeature_cols = [col for col in train.columns if 'f' in col]","df4c49d1":"\n\nsimple_imputer = SimpleImputer()\ntemp = train.drop('claim', axis=1)\nimputed_train = pd.DataFrame(simple_imputer.fit_transform(temp))\nimputed_test = pd.DataFrame(simple_imputer.transform(test))\n\nimputed_train['claim'] = train['claim']\n\nimputed_train.columns = train.columns\nimputed_test.columns = test.columns\n\n","b7bea9d5":"imputed_train.head()","e8ea3477":"type(imputed_train)","14d61204":"imputed_train.isnull().any().sum()","ec2e1421":"ss = StandardScaler()\nimputed_train[feature_cols] = ss.fit_transform(imputed_train[feature_cols])\nimputed_test[feature_cols] = ss.transform(imputed_test[feature_cols])","8671780b":"y = imputed_train['claim']","ed1c9404":"imputed_train.head()","3f1b9674":"imputed_test.head()","0875e62a":"y.head()","8a45a20f":"import optuna","7b39b0f5":"from xgboost import  XGBClassifier, XGBRegressor","017587e3":"import xgboost as xgb","ba4e6767":"from sklearn.metrics import mean_squared_error, accuracy_score","71791896":"from sklearn import metrics\n","5e615ee5":"from sklearn.feature_selection import SelectKBest\nfrom sklearn.feature_selection import chi2\n","0f57ef25":"xgb_fi_model = XGBClassifier(tree_method='gpu_hist', use_label_encoder=False)\nxgb_fi_model.fit(imputed_train[feature_cols], y)\nfeat_importances = pd.Series(xgb_fi_model.feature_importances_, index=feature_cols)\n","0300eadb":"# plt.rcParams['figure.figsize'] = [15, 18]\n# feat_importances.nlargest(100).plot(kind='barh')\n# plt.show()","b6711bae":"# feat_importances.keys","27ede7d0":"top_feature_names = [f for f, imp in feat_importances.nlargest(100).iteritems()]\ntop_feature_names","3775ec67":"# top_five = top_feature_names[0:5]\n# top_twenty = top_feature_names[0:20]\n# next_top_thirty = top_feature_names[20:50]\n# next_top_fifty = top_feature_names[50:]","c188b6e4":"# def objective(trial, X=imputed_train, y=y):\n# #     train_x, val_x, train_y, val_y = train_test_split(X, y, test_size=0.2,random_state=42)\n#     param_space = { \n#                'lambda': trial.suggest_loguniform('lambda', 1e-3, 10.0),\n#                 'alpha': trial.suggest_loguniform('alpha', 1e-3, 10.0),\n#                 'colsample_bytree': trial.suggest_float('colsample_bytree', 0.1, 0.9),\n#                 'colsample_bynode': trial.suggest_float('colsample_bynode', 0.1, 0.9),\n#                 'colsample_bylevel': trial.suggest_float('colsample_bylevel', 0.1, 0.9),\n#                 'subsample': trial.suggest_float('subsample', 0.1, 0.9),\n#                 'eta':trial.suggest_float('eta', 1e-2, 1e-2),\n#                 'grow_policy': trial.suggest_categorical(\"grow_policy\", ['depthwise','lossguide']),\n#                 'max_depth': trial.suggest_int('max_depth',2,25),\n#                 'seed': 0,\n#                 'min_child_weight': trial.suggest_int('min_child_weight', 0, 300),\n#                 'max_bin': trial.suggest_int('max_bin', 256, 512),\n#                 'deterministic_histogram':trial.suggest_categorical('deterministic_histogram',[False]),\n#                 \"tree_method\" : \"gpu_hist\",\n#                 \"predictor\" : 'gpu_predictor',\n#                 'objective': 'binary:logistic', \n\n# #                  \"num_class\":4\n#                 }\n#     k=5\n#     seed_list=[0]\n#     kf = StratifiedKFold(n_splits=k,shuffle=True,random_state=2001)\n#     oof = np.zeros(len(imputed_train))\n#     score_list = []\n\n\n#     splits = list(kf.split(X,y))\n#     for train_idx, val_idx in splits:\n#       X_train = X[X.kfold != fold].reset_index(drop=True)\n#       X_val = X[X.kfold == fold].reset_index(drop=True)\n\n\n\n#       y_train = X_train.claim\n#       y_val = X_val.claim\n\n#       X_train = X_train[top_feature_names]\n#       X_val = X_val[top_feature_names]\n#       val_preds_list = []\n\n#       for seed in seed_list:\n#         # fit and run model\n#         param_space['seed'] = seed\n#         dtrain = xgb.DMatrix(data=X_train, label=y_train)\n#         dval = xgb.DMatrix(data=X_val, label=y_val)\n#         dtest = xgb.DMatrix(data=imputed_test)\n#         xgb.set_config(verbosity=0)\n\n\n#         model = xgb.train(param_space, dtrain,\\\n#                        evals=[(dtrain,'train'),(dval,'val')],\\\n#                        verbose_eval=False,\n#                        early_stopping_rounds=100,\n#                        num_boost_round=100000)\n\n\n\n\n#         val_preds_list.append(model.predict(dval))\n#      #test_preds_list.append(model.predict_proba(imputed_test)[:,1])\n\n#       oof[val_idx] = np.mean(val_preds_list,axis=0)\n#       score = log_loss(y_val, oof[val_idx])\n\n#       score_list.append(score)\n     \n\n#     cv_logloss = np.mean(score_list)\n\n#     return cv_logloss","49ed8fe4":"from sklearn.model_selection import StratifiedKFold, KFold,cross_val_predict,cross_val_score,cross_validate","6cb37a29":"# study = optuna.create_study(direction='minimize')\n# study.optimize(objective, n_trials=20)\n# print('Number of finished trials:', len(study.trials))\n# print('Best trial:', study.best_trial.params)","e5b26423":"plt.rcParams['figure.figsize'] = [6, 6]","c56ea495":"def plot_roc(y, y_proba):\n    fpr, tpr, thresholds = metrics.roc_curve(y, y_proba, pos_label = 1)\n    roc_auc = metrics.auc(fpr, tpr)\n    display = metrics.RocCurveDisplay(fpr=fpr, tpr=tpr, roc_auc=roc_auc)\n    display.plot()\n    plt.show()","5d1e1fcb":"# xgb_params_top_twenty = {\n#     'use_label_encoder': False,\n#     'n_estimators': 10822,\n#     'learning_rate': 0.01963896664876902,\n#     'max_depth': 5,\n#     'tree_method':'gpu_hist',   \n#     'predictor': 'gpu_predictor',\n#     'use_label_encoder':False,\n#     'eval_metric':'auc'\n# }","7b6e4cbb":"# xgb_top_twenty = XGBClassifier(**xgb_params_top_twenty)","59b698ab":"# xgb_params_next_top_thirty = {\n#     'use_label_encoder': False,\n#     'n_estimators': 8797,\n#     'learning_rate': 0.006148024937823801,\n#     'max_depth': 5,\n#     'tree_method':'gpu_hist',   \n#     'predictor': 'gpu_predictor',\n#     'use_label_encoder':False,\n#     'eval_metric':'auc'\n# }","f4d9f296":"# xgb_next_top_thirty = XGBClassifier(**xgb_params_next_top_thirty)","e3263510":"# xgb_params_1 = {\n#     'eval_metric' : 'auc',\n#     'lambda': 0.004562711234493688, \n#     'alpha': 7.268146704546314, \n#     'colsample_bytree': 0.6468987558386358, \n#     'colsample_bynode': 0.29113878257290376, \n#     'colsample_bylevel': 0.8915913499148167, \n#     'subsample': 0.37130229826185135, \n#     'learning_rate': 0.021671163563123198, \n#     'grow_policy': 'lossguide', \n#     'max_depth': 18, \n#     'min_child_weight': 215, \n#     'max_bin': 272,\n#     'n_estimators': 10000,\n#     'random_state': 0,\n#     'use_label_encoder': False,\n#     'objective': 'binary:logistic',\n#     'tree_method': 'gpu_hist',\n#     'gpu_id': 0,\n#     'predictor': 'gpu_predictor'\n# }","99ebceb5":"# xgb_1 = XGBClassifier(**xgb_params_1)","9d4438bd":"# xgb_params_2 = {\n#     'eval_metric':'auc',\n#     'max_depth':3,\n#     'subsample':0.5,\n#     'colsample_bytree':0.5,\n#     'learning_rate':0.01187431306013263,\n#     'n_estimators':10000,\n#     'n_jobs':-1,\n#     'use_label_encoder':False,\n#     'objective':'binary:logistic',\n#     'tree_method':'gpu_hist',\n#     'gpu_id':0,\n#     'predictor':'gpu_predictor'\n# }","6caeedf1":"# xgb_2 = XGBClassifier(**xgb_params_2)","954e0eb4":"# xgb_params_3 = {\n#     'eval_metric': 'auc', \n#     'objective': 'binary:logistic', \n#     'tree_method': 'gpu_hist', \n#     'gpu_id': 0, \n#     'predictor': 'gpu_predictor', \n#     'n_estimators': 10000, \n#     'learning_rate': 0.01063045229441343, \n#     'gamma': 0.24652519525750877, \n#     'max_depth': 4, \n#     'min_child_weight': 366, \n#     'subsample': 0.6423040816299684, \n#     'colsample_bytree': 0.7751264493218339, \n#     'colsample_bylevel': 0.8675692743597421, \n#     'lambda': 0, \n#     'alpha': 10\n# }","eefca4af":"# xgb_3 = XGBClassifier(**xgb_params_3)","e913dd28":"# xgb_next_top_fifty = {\n#     'use_label_encoder': False,\n#     'n_estimators': 9074,\n#     'learning_rate': 0.003150164455468626,\n#     'max_depth': 6,\n#     'tree_method':'gpu_hist',   \n#     'predictor': 'gpu_predictor',\n#     'use_label_encoder':False,\n#     'eval_metric':'auc'\n# }","b12c5d5d":"# xgb_next_top_fifty = XGBClassifier(**xgb_next_top_fifty)","0f7ccf9b":"# solution_path = os.path.join(INPUT,'sample_solution.csv' )\n# solution = pd.read_csv(solution_path)\n# solution.head()","2bf91628":"# kf = KFold(n_splits=5, shuffle=True, random_state=42)\n# for fold, (train_indices, valid_indices) in enumerate(kf.split(imputed_train)):\n#     imputed_train.loc[valid_indices, 'kfold'] = fold","1d00b4a1":"# from catboost import CatBoostClassifier\n","7b5e0f9a":"# catb_params_1 = {\n#     'eval_metric' : 'AUC',\n#     'iterations': 15585, \n#     'objective': 'CrossEntropy',\n#     'bootstrap_type': 'Bernoulli', \n#     'od_wait': 1144, \n#     'learning_rate': 0.023575206684596582, \n#     'reg_lambda': 36.30433203563295, \n#     'random_strength': 43.75597655616195, \n#     'depth': 7, \n#     'min_data_in_leaf': 11, \n#     'leaf_estimation_iterations': 1, \n#     'subsample': 0.8227911142845009,\n#     'task_type' : 'GPU',\n#     'devices' : '0',\n#     'verbose' : 0\n# }","8166d2ad":"# catb_params_2 = {\n#     'eval_metric' : 'AUC',\n#     'depth' : 5,\n#     'grow_policy' : 'SymmetricTree',\n#     'l2_leaf_reg' : 3.0,\n#     'random_strength' : 1.0,\n#     'learning_rate' : 0.1,\n#     'iterations' : 10000,\n#     'loss_function' : 'CrossEntropy',\n#     'task_type' : 'GPU',\n#     'devices' : '0',\n#     'verbose' : 0\n# }","d98bb3db":"# catb_model_1 = CatBoostClassifier(**catb_params_1)","5e67edc5":"# catb_model_2 = CatBoostClassifier(**catb_params_2)","4b6e4258":"# solution_path = os.path.join(INPUT,'sample_solution.csv' )\n# solution = pd.read_csv(solution_path)\n\n# final_test_predictions = []\n# final_valid_predictions = {}\n# for fold in range(5):\n#     x_train = imputed_train[imputed_train.kfold != fold].reset_index(drop=True)\n#     x_val = imputed_train[imputed_train.kfold == fold].reset_index(drop=True)\n    \n#     valid_ids = x_val.id.values.tolist()\n    \n    \n#     y_train = x_train.claim\n#     y_val = x_val.claim\n    \n#     x_train = x_train[top_feature_names]\n#     x_val = x_val[top_feature_names]\n    \n    \n#     model = catb_model_1\n#     model.fit(x_train, y_train)\n#     preds_val = model.predict(x_val)\n# #     test_preds = model.predict(test)\n#     y_proba = model.predict_proba(x_val)[:,1]\n#     proba = model.predict_proba(imputed_test[top_feature_names])[:,1]\n#     final_test_predictions.append(proba)\n#     final_valid_predictions.update(dict(zip(valid_ids, y_proba)))\n#     plot_roc(y_val, y_proba)\n\n# final_valid_predictions = pd.DataFrame.from_dict(final_valid_predictions, orient=\"index\").reset_index()\n# final_valid_predictions.columns = [\"id\", \"pred_1\"]\n# final_valid_predictions.to_csv(\"train_pred_1.csv\", index=False)\n\n# solution.claim = np.mean(np.column_stack(final_test_predictions), axis=1)\n# solution.columns = [\"id\", \"pred_1\"]\n# solution.to_csv(\"test_pred_1.csv\", index=False)","4533f0b1":"# solution_path = os.path.join(INPUT,'sample_solution.csv' )\n# solution = pd.read_csv(solution_path)\n\n# final_test_predictions = []\n# final_valid_predictions = {}\n# for fold in range(5):\n#     x_train = imputed_train[imputed_train.kfold != fold].reset_index(drop=True)\n#     x_val = imputed_train[imputed_train.kfold == fold].reset_index(drop=True)\n    \n#     valid_ids = x_val.id.values.tolist()\n    \n    \n#     y_train = x_train.claim\n#     y_val = x_val.claim\n    \n#     x_train = x_train[top_feature_names]\n#     x_val = x_val[top_feature_names]\n    \n    \n#     model = catb_model_2\n#     model.fit(x_train, y_train)\n#     preds_val = model.predict(x_val)\n# #     test_preds = model.predict(test)\n#     y_proba = model.predict_proba(x_val)[:,1]\n#     proba = model.predict_proba(imputed_test[top_feature_names])[:,1]\n#     final_test_predictions.append(proba)\n#     final_valid_predictions.update(dict(zip(valid_ids, y_proba)))\n#     plot_roc(y_val, y_proba)\n\n# final_valid_predictions = pd.DataFrame.from_dict(final_valid_predictions, orient=\"index\").reset_index()\n# final_valid_predictions.columns = [\"id\", \"pred_6\"]\n# final_valid_predictions.to_csv(\"train_pred_6.csv\", index=False)\n\n# solution.claim = np.mean(np.column_stack(final_test_predictions), axis=1)\n# solution.columns = [\"id\", \"pred_6\"]\n# solution.to_csv(\"test_pred_6.csv\", index=False)","cc4c7f46":"# from lightgbm import LGBMClassifier","a005ae83":"# lgbm_params_1 = {\n#     'metric' : 'auc',\n#     'max_depth' : 3,\n#     'num_leaves' : 7,\n#     'n_estimators' : 5000,\n#     'colsample_bytree' : 0.3,\n#     'subsample' : 0.5,\n#     'random_state' : 42,\n#     'reg_alpha' : 18,\n#     'reg_lambda' : 17,\n#     'learning_rate' : 0.095,\n#     'device' : 'gpu',\n#     'objective' : 'binary'\n# }","a274db78":"# lgbm_params_2 = {\n#     'metric' : 'auc',\n#     'objective': 'binary',\n#     'n_estimators': 10000,\n#     'random_state': 42,\n#     'learning_rate': 0.095,\n#     'subsample': 0.6,\n#     'subsample_freq': 1,\n#     'colsample_bytree': 0.4,\n#     'reg_alpha': 10.0,\n#     'reg_lambda': 1e-1,\n#     'min_child_weight': 256,\n#     'min_child_samples': 20,\n#     'device' : 'gpu',\n#     'max_depth' : 3,\n#     'num_leaves' : 7\n# }","17aa643a":"# lgbm_params_3 = {\n#     'metric' : 'auc',\n#     'objective' : 'binary',\n#     'device_type': 'gpu', \n#     'n_estimators': 10000, \n#     'learning_rate': 0.12230165751633416, \n#     'num_leaves': 1400, \n#     'max_depth': 8, \n#     'min_child_samples': 3100, \n#     'reg_alpha': 10, \n#     'reg_lambda': 65, \n#     'min_split_gain': 5.157818977461183, \n#     'subsample': 0.5, \n#     'subsample_freq': 1, \n#     'colsample_bytree': 0.2\n# }","e5c026e0":"# lgbm_model_1 = LGBMClassifier(**lgbm_params_1)","a1dde1a9":"# lgbm_model_2 = LGBMClassifier(**lgbm_params_2)","5aa29a69":"# lgbm_model_3 = LGBMClassifier(**lgbm_params_3)","1284560e":"# solution_path = os.path.join(INPUT,'sample_solution.csv' )\n# solution = pd.read_csv(solution_path)\n\n# final_test_predictions = []\n# final_valid_predictions = {}\n# for fold in range(5):\n#     x_train = imputed_train[imputed_train.kfold != fold].reset_index(drop=True)\n#     x_val = imputed_train[imputed_train.kfold == fold].reset_index(drop=True)\n    \n#     valid_ids = x_val.id.values.tolist()\n    \n    \n#     y_train = x_train.claim\n#     y_val = x_val.claim\n    \n#     x_train = x_train[top_feature_names]\n#     x_val = x_val[top_feature_names]\n    \n    \n#     model = lgbm_model_1\n#     model.fit(x_train, y_train)\n#     preds_val = model.predict(x_val)\n# #     test_preds = model.predict(test)\n#     y_proba = model.predict_proba(x_val)[:,1]\n#     proba = model.predict_proba(imputed_test[top_feature_names])[:,1]\n#     final_test_predictions.append(proba)\n#     final_valid_predictions.update(dict(zip(valid_ids, y_proba)))\n#     plot_roc(y_val, y_proba)\n\n# final_valid_predictions = pd.DataFrame.from_dict(final_valid_predictions, orient=\"index\").reset_index()\n# final_valid_predictions.columns = [\"id\", \"pred_2\"]\n# final_valid_predictions.to_csv(\"train_pred_2.csv\", index=False)\n\n# solution.claim = np.mean(np.column_stack(final_test_predictions), axis=1)\n# solution.columns = [\"id\", \"pred_2\"]\n# solution.to_csv(\"test_pred_2.csv\", index=False)","d7bbb1cd":"# solution_path = os.path.join(INPUT,'sample_solution.csv' )\n# solution = pd.read_csv(solution_path)\n\n# final_test_predictions = []\n# final_valid_predictions = {}\n# for fold in range(5):\n#     x_train = imputed_train[imputed_train.kfold != fold].reset_index(drop=True)\n#     x_val = imputed_train[imputed_train.kfold == fold].reset_index(drop=True)\n    \n#     valid_ids = x_val.id.values.tolist()\n    \n    \n#     y_train = x_train.claim\n#     y_val = x_val.claim\n    \n#     x_train = x_train[top_feature_names]\n#     x_val = x_val[top_feature_names]\n    \n    \n#     model = lgbm_model_2\n#     model.fit(x_train, y_train)\n#     preds_val = model.predict(x_val)\n# #     test_preds = model.predict(test)\n#     y_proba = model.predict_proba(x_val)[:,1]\n#     proba = model.predict_proba(imputed_test[top_feature_names])[:,1]\n#     final_test_predictions.append(proba)\n#     final_valid_predictions.update(dict(zip(valid_ids, y_proba)))\n#     plot_roc(y_val, y_proba)\n\n# final_valid_predictions = pd.DataFrame.from_dict(final_valid_predictions, orient=\"index\").reset_index()\n# final_valid_predictions.columns = [\"id\", \"pred_5\"]\n# final_valid_predictions.to_csv(\"train_pred_5.csv\", index=False)\n\n# solution.claim = np.mean(np.column_stack(final_test_predictions), axis=1)\n# solution.columns = [\"id\", \"pred_5\"]\n# solution.to_csv(\"test_pred_5.csv\", index=False)","d8b7941f":"# solution_path = os.path.join(INPUT,'sample_solution.csv' )\n# solution = pd.read_csv(solution_path)\n\n# final_test_predictions = []\n# final_valid_predictions = {}\n# for fold in range(5):\n#     x_train = imputed_train[imputed_train.kfold != fold].reset_index(drop=True)\n#     x_val = imputed_train[imputed_train.kfold == fold].reset_index(drop=True)\n    \n#     valid_ids = x_val.id.values.tolist()\n    \n    \n#     y_train = x_train.claim\n#     y_val = x_val.claim\n    \n#     x_train = x_train[top_feature_names]\n#     x_val = x_val[top_feature_names]\n    \n    \n#     model = lgbm_model_3\n#     model.fit(x_train, y_train)\n#     preds_val = model.predict(x_val)\n# #     test_preds = model.predict(test)\n#     y_proba = model.predict_proba(x_val)[:,1]\n#     proba = model.predict_proba(imputed_test[top_feature_names])[:,1]\n#     final_test_predictions.append(proba)\n#     final_valid_predictions.update(dict(zip(valid_ids, y_proba)))\n#     plot_roc(y_val, y_proba)\n\n# final_valid_predictions = pd.DataFrame.from_dict(final_valid_predictions, orient=\"index\").reset_index()\n# final_valid_predictions.columns = [\"id\", \"pred_8\"]\n# final_valid_predictions.to_csv(\"train_pred_8.csv\", index=False)\n\n# solution.claim = np.mean(np.column_stack(final_test_predictions), axis=1)\n# solution.columns = [\"id\", \"pred_8\"]\n# solution.to_csv(\"test_pred_8.csv\", index=False)","b8964c48":"# solution_path = os.path.join(INPUT,'sample_solution.csv' )\n# solution = pd.read_csv(solution_path)\n\n# final_test_predictions = []\n# final_valid_predictions = {}\n# for fold in range(5):\n#     x_train = imputed_train[imputed_train.kfold != fold].reset_index(drop=True)\n#     x_val = imputed_train[imputed_train.kfold == fold].reset_index(drop=True)\n    \n#     valid_ids = x_val.id.values.tolist()\n    \n    \n#     y_train = x_train.claim\n#     y_val = x_val.claim\n    \n#     x_train = x_train[top_feature_names]\n#     x_val = x_val[top_feature_names]\n    \n    \n#     model = xgb_1\n#     model.fit(x_train, y_train)\n#     preds_val = model.predict(x_val)\n# #     test_preds = model.predict(test)\n#     y_proba = model.predict_proba(x_val)[:,1]\n#     proba = model.predict_proba(imputed_test[top_feature_names])[:,1]\n#     final_test_predictions.append(proba)\n#     final_valid_predictions.update(dict(zip(valid_ids, y_proba)))\n#     plot_roc(y_val, y_proba)\n\n# final_valid_predictions = pd.DataFrame.from_dict(final_valid_predictions, orient=\"index\").reset_index()\n# final_valid_predictions.columns = [\"id\", \"pred_3\"]\n# final_valid_predictions.to_csv(\"train_pred_3.csv\", index=False)\n\n# solution.claim = np.mean(np.column_stack(final_test_predictions), axis=1)\n# solution.columns = [\"id\", \"pred_3\"]\n# solution.to_csv(\"test_pred_3.csv\", index=False)","88147ffa":"# solution_path = os.path.join(INPUT,'sample_solution.csv' )\n# solution = pd.read_csv(solution_path)\n\n# final_test_predictions = []\n# final_valid_predictions = {}\n# for fold in range(5):\n#     x_train = imputed_train[imputed_train.kfold != fold].reset_index(drop=True)\n#     x_val = imputed_train[imputed_train.kfold == fold].reset_index(drop=True)\n    \n#     valid_ids = x_val.id.values.tolist()\n    \n    \n#     y_train = x_train.claim\n#     y_val = x_val.claim\n    \n#     x_train = x_train[top_feature_names]\n#     x_val = x_val[top_feature_names]\n    \n    \n#     model = xgb_2\n#     model.fit(x_train, y_train)\n#     preds_val = model.predict(x_val)\n# #     test_preds = model.predict(test)\n#     y_proba = model.predict_proba(x_val)[:,1]\n#     proba = model.predict_proba(imputed_test[top_feature_names])[:,1]\n#     final_test_predictions.append(proba)\n#     final_valid_predictions.update(dict(zip(valid_ids, y_proba)))\n#     plot_roc(y_val, y_proba)\n\n# final_valid_predictions = pd.DataFrame.from_dict(final_valid_predictions, orient=\"index\").reset_index()\n# final_valid_predictions.columns = [\"id\", \"pred_4\"]\n# final_valid_predictions.to_csv(\"train_pred_4.csv\", index=False)\n\n# solution.claim = np.mean(np.column_stack(final_test_predictions), axis=1)\n# solution.columns = [\"id\", \"pred_4\"]\n# solution.to_csv(\"test_pred_4.csv\", index=False)","fb39230e":"# solution_path = os.path.join(INPUT,'sample_solution.csv' )\n# solution = pd.read_csv(solution_path)\n\n# final_test_predictions = []\n# final_valid_predictions = {}\n# for fold in range(5):\n#     x_train = imputed_train[imputed_train.kfold != fold].reset_index(drop=True)\n#     x_val = imputed_train[imputed_train.kfold == fold].reset_index(drop=True)\n    \n#     valid_ids = x_val.id.values.tolist()\n    \n    \n#     y_train = x_train.claim\n#     y_val = x_val.claim\n    \n#     x_train = x_train[top_feature_names]\n#     x_val = x_val[top_feature_names]\n    \n    \n#     model = xgb_3\n#     model.fit(x_train, y_train)\n#     preds_val = model.predict(x_val)\n# #     test_preds = model.predict(test)\n#     y_proba = model.predict_proba(x_val)[:,1]\n#     proba = model.predict_proba(imputed_test[top_feature_names])[:,1]\n#     final_test_predictions.append(proba)\n#     final_valid_predictions.update(dict(zip(valid_ids, y_proba)))\n#     plot_roc(y_val, y_proba)\n\n# final_valid_predictions = pd.DataFrame.from_dict(final_valid_predictions, orient=\"index\").reset_index()\n# final_valid_predictions.columns = [\"id\", \"pred_7\"]\n# final_valid_predictions.to_csv(\"train_pred_7.csv\", index=False)\n\n# solution.claim = np.mean(np.column_stack(final_test_predictions), axis=1)\n# solution.columns = [\"id\", \"pred_7\"]\n# solution.to_csv(\"test_pred_7.csv\", index=False)","72cfc17e":"# solution_path = os.path.join(INPUT,'sample_solution.csv' )\n# solution = pd.read_csv(solution_path)\n\n# final_test_predictions = []\n# final_valid_predictions = {}\n# for fold in range(5):\n#     x_train = imputed_train[imputed_train.kfold != fold].reset_index(drop=True)\n#     x_val = imputed_train[imputed_train.kfold == fold].reset_index(drop=True)\n    \n#     valid_ids = x_val.id.values.tolist()\n    \n    \n#     y_train = x_train.claim\n#     y_val = x_val.claim\n    \n#     x_train = x_train[top_feature_names]\n#     x_val = x_val[top_feature_names]\n    \n    \n#     model = xgb\n#     model.fit(x_train, y_train, early_stopping_rounds=100, eval_set=[[x_val, y_val]], verbose=500)\n#     preds_val = model.predict(x_val)\n# #     test_preds = model.predict(test)\n#     y_proba = model.predict_proba(x_val)[:,1]\n#     proba = model.predict_proba(imputed_test[top_feature_names])[:,1]\n#     final_test_predictions.append(proba)\n#     final_valid_predictions.update(dict(zip(valid_ids, y_proba)))\n#     plot_roc(y_val, y_proba)\n\n# final_valid_predictions = pd.DataFrame.from_dict(final_valid_predictions, orient=\"index\").reset_index()\n# final_valid_predictions.columns = [\"id\", \"pred_4\"]\n# final_valid_predictions.to_csv(\"train_pred_4.csv\", index=False)\n\n# solution.claim = np.mean(np.column_stack(final_test_predictions), axis=1)\n# solution.columns = [\"id\", \"pred_4\"]\n# solution.to_csv(\"test_pred_4.csv\", index=False)","4b0d23f6":"# xgb_predictions = []\n# for fold in range(10):\n#     x_train = imputed_train[imputed_train.kfold != fold].reset_index(drop=True)\n#     x_val = imputed_train[imputed_train.kfold == fold].reset_index(drop=True)\n    \n#     y_train = x_train.claim\n#     y_val = x_val.claim\n    \n#     x_train = x_train[feature_cols]\n#     x_val = x_val[feature_cols]\n    \n#     model = xgb\n#     model.fit(x_train, y_train, early_stopping_rounds=100, eval_set=[[x_val, y_val]], verbose=500)\n#     preds_val = model.predict(x_val)\n# #     test_preds = model.predict(test)\n#     y_proba = model.predict_proba(x_val)[:,1]\n#     proba = model.predict_proba(imputed_test[feature_cols])[:,1]\n#     xgb_predictions.append(proba)\n#     plot_roc(y_val, y_proba)\n    ","bfc405bb":"# solution_path = os.path.join(INPUT,'sample_solution.csv' )\n# solution = pd.read_csv(solution_path)\n\n# df1 = pd.read_csv(\"train_pred_1.csv\")\n# df2 = pd.read_csv(\"train_pred_2.csv\")\n# df3 = pd.read_csv(\"train_pred_3.csv\")\n# df4 = pd.read_csv(\"train_pred_4.csv\")\n# df5 = pd.read_csv(\"train_pred_5.csv\")\n# df6 = pd.read_csv(\"train_pred_6.csv\")\n# df7 = pd.read_csv(\"train_pred_7.csv\")\n# df8 = pd.read_csv(\"train_pred_8.csv\")\n\n# df_test1 = pd.read_csv(\"test_pred_1.csv\")\n# df_test2 = pd.read_csv(\"test_pred_2.csv\")\n# df_test3 = pd.read_csv(\"test_pred_3.csv\")\n# df_test4 = pd.read_csv(\"test_pred_4.csv\")\n# df_test5 = pd.read_csv(\"test_pred_5.csv\")\n# df_test6 = pd.read_csv(\"test_pred_6.csv\")\n# df_test7 = pd.read_csv(\"test_pred_7.csv\")\n# df_test8 = pd.read_csv(\"test_pred_8.csv\")\n\n\n\n\n# imputed_train = imputed_train.merge(df1, on=\"id\", how=\"left\")\n# imputed_train = imputed_train.merge(df2, on=\"id\", how=\"left\")\n# imputed_train = imputed_train.merge(df3, on=\"id\", how=\"left\")\n# imputed_train = imputed_train.merge(df4, on=\"id\", how=\"left\")\n# imputed_train = imputed_train.merge(df5, on=\"id\", how=\"left\")\n# imputed_train = imputed_train.merge(df6, on=\"id\", how=\"left\")\n# imputed_train = imputed_train.merge(df7, on=\"id\", how=\"left\")\n# imputed_train = imputed_train.merge(df8, on=\"id\", how=\"left\")\n\n\n\n\n# imputed_test = imputed_test.merge(df_test1, on=\"id\", how=\"left\")\n# imputed_test = imputed_test.merge(df_test2, on=\"id\", how=\"left\")\n# imputed_test = imputed_test.merge(df_test3, on=\"id\", how=\"left\")\n# imputed_test = imputed_test.merge(df_test4, on=\"id\", how=\"left\")\n# imputed_test = imputed_test.merge(df_test5, on=\"id\", how=\"left\")\n# imputed_test = imputed_test.merge(df_test6, on=\"id\", how=\"left\")\n# imputed_test = imputed_test.merge(df_test7, on=\"id\", how=\"left\")\n# imputed_test = imputed_test.merge(df_test8, on=\"id\", how=\"left\")\n\n\n\n# imputed_train.head()\n","44a0845b":"# imputed_test.head()","c81e84fb":"# final_predictions = xgb_predictions","c4cd8dae":"from sklearn.linear_model import LinearRegression","f3f93a74":"useful_features = [\"pred_1\", \"pred_2\", \"pred_3\", \"pred_4\", \"pred_5\", \"pred_6\", \"pred_7\", \"pred_8\"]\n\nfinal_predictions = []\nscores = []\nfor fold in range(5):\n    xtrain =  imputed_train[imputed_train.kfold != fold].reset_index(drop=True)\n    xvalid = imputed_train[imputed_train.kfold == fold].reset_index(drop=True)\n    xtest = imputed_test.copy()\n\n    ytrain = xtrain.claim\n    yvalid = xvalid.claim\n    \n    xtrain = xtrain[useful_features]\n    xvalid = xvalid[useful_features]\n    \n    model = XGBRegressor(\n            tree_method='gpu_hist',   \n            predictor='gpu_predictor'\n        )\n\n#     model = LinearRegression()\n    model.fit(xtrain, ytrain)\n    \n    preds_valid = model.predict(xvalid)\n    test_preds = model.predict(xtest[useful_features])\n    final_predictions.append(test_preds)\n    rmse = mean_squared_error(yvalid, preds_valid, squared=False)\n    print(fold, rmse)\n    scores.append(rmse)\n\nprint(np.mean(scores), np.std(scores))","3d624391":"\npredictions = np.mean(np.column_stack(final_predictions), axis=1)\n","b78b643d":"solution['claim'] = predictions\n# submission['loss'] = final_predictions\nsolution.to_csv(\"solution.csv\", index=False)\n\nsolution","5efdba85":"from pathlib import Path"}}