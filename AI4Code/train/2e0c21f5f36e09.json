{"cell_type":{"061178dd":"code","1f9753ab":"code","4b219c9a":"code","86d7550f":"code","12e7b427":"code","ef9b1d5d":"code","c7e5a841":"code","97d10b49":"code","571221f3":"code","7b91d1cf":"code","303ef498":"code","41ab14a8":"code","2347bccb":"code","8f567748":"code","9a91bddc":"markdown","f9c1add2":"markdown","7c87a5af":"markdown","335a2d9c":"markdown","d1b02a06":"markdown","9b58fbd3":"markdown","d786dec9":"markdown","28d5ff77":"markdown","23ac12ce":"markdown","c4099548":"markdown","29b01c98":"markdown","e818ed29":"markdown","7394a8e9":"markdown","121ffc6f":"markdown","a03953c1":"markdown","31183927":"markdown"},"source":{"061178dd":"import pandas as pd\npd.core.common.is_list_like = pd.api.types.is_list_like\nfrom pandas_datareader import data as pdr\nimport fix_yahoo_finance as yf\nyf.pdr_override() # ajutes do fix_yahoo_finance para poder usar o yahoo finance novamente no pandas_datareader\nimport numpy as np\n\nfrom datetime import date\nfrom dateutil.relativedelta import relativedelta\n\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\n%matplotlib inline\nplt.style.use('seaborn')\n\n# Conjunto de criptomoedas da carteira\nmoedas = [\"BTC-USD\", \"ETH-USD\", \"XRP-USD\", \"BCH-USD\", \"LTC-USD\", \"IOT-USD\", \n          \"XMR-USD\", \"DASH-USD\"]\n\nfim = date(2018, 11, 28) # Data final\ninicio = fim + relativedelta(months = -2) # Data inicial (2 meses antes da final)\n\ndados = pdr.get_data_yahoo(moedas, start=inicio, end=fim)\nfechamento = dados['Adj Close']\n# Normalizar dados caso exista algum dado da s\u00e9rie temporal faltando\nfechamento = fechamento[moedas].fillna(method='ffill').fillna(method='bfill')\n\nfechamento.head(20)","1f9753ab":"mudanca_proporcional = fechamento \/ fechamento.iloc[0,:]\ncores = cm.rainbow(np.linspace(0, 1, len(moedas)))\nmudanca_proporcional.fillna(1).plot.line(figsize=(24, 8), grid=True, color=cores)\n\nmudanca_proporcional.head()","4b219c9a":"carteira_inicial = np.array([1.0\/len(moedas) for i in range(len(moedas))])\nevolucao = pd.DataFrame(dict(inicial = np.sum(mudanca_proporcional * carteira_inicial, axis=1)))\n\nevolucao.plot.line(figsize=(24, 8), grid=True, color=cores)\ncarteira_inicial","86d7550f":"retorno_percentual = fechamento.pct_change().dropna()\nretorno_percentual.plot.line(figsize=(24, 8), grid=True, color=cores)\nretorno_percentual.tail(10)","12e7b427":"retorno_inicial = np.dot(retorno_percentual.mean(), carteira_inicial)\nretorno_inicial","ef9b1d5d":"carteira_cov = retorno_percentual.cov()\ncarteira_cov","c7e5a841":"risco_inicial = np.sqrt(np.dot(carteira_inicial.T, np.dot(carteira_cov, carteira_inicial)))\nrisco_inicial","97d10b49":"sharpe_inicial = retorno_inicial \/ risco_inicial\nsharpe_inicial","571221f3":"def gerar_distribuicao_carteira(ativos, retorno_percentual, cov, num_simulacoes):\n    retornos = []\n    volatilidades = []\n    sharpes = []\n    pesos_portfolio = []\n\n    num_ativos = len(ativos)\n    media_variacao = retorno_percentual.mean()\n    \n    np.random.seed(4765)\n    for s in range(0, num_simulacoes):\n        pesos = np.random.random(num_ativos)\n        pesos \/= pesos.sum()\n        retorno = np.dot(pesos, media_variacao)\n        volatilidade = np.sqrt(np.dot(pesos.T, np.dot(cov, pesos)))\n        sharpe = retorno \/ volatilidade\n\n        retornos.append(retorno)\n        volatilidades.append(volatilidade)\n        sharpes.append(sharpe)\n        pesos_portfolio.append(pesos)\n\n    # um dicionario de Retorno e Risco para cada carteira\n    portfolio = {'Retornos': retornos, 'Riscos': volatilidades, 'Sharpes': sharpes}\n\n    # acrescentando a composicao de cada moeda da carteira ao dicionario\n    for counter, at in enumerate(ativos):\n        portfolio[at + ' comp'] = [peso[counter] for peso in pesos_portfolio]\n\n    # transformando o dicionario gerado em um Dataframe\n    df = pd.DataFrame(portfolio)\n    column_order = ['Retornos', 'Riscos', 'Sharpes'] + [at + ' comp' for at in ativos]    \n    return df[column_order].sort_values(['Retornos']).reset_index().set_index('index')\n  \ndf = gerar_distribuicao_carteira(moedas, retorno_percentual, carteira_cov, 10000)\ndf.head(20)","7b91d1cf":"df.plot.scatter(x='Riscos', y='Retornos', c='Sharpes', cmap='RdYlBu', edgecolors='black', \n                figsize=(24, 8), grid=True, sharex=False)\nplt.xlabel('Risco')\nplt.ylabel('Retorno Esperado')\nplt.title(u'Simula\u00e7\u00e3o Carteiras')\nplt.show()","303ef498":"import cvxpy as cp\n \ndef minimizar_riscos(medias, cov, epv):\n    pesos = cp.Variable(len(medias))\n    \n    risco_esperado = cp.quad_form(pesos, cov)   \n    retorno_esperado = pesos.T * medias\n\n    obj = cp.Minimize(risco_esperado)\n    cons = [\n        epv == retorno_esperado,\n        cp.sum(pesos) == 1,\n        pesos >= 0\n    ]\n\n    prob = cp.Problem(obj, cons)\n    prob.solve(solver='ECOS')\n    norm_pesos = pesos.value.round(4)\n    \n    return (norm_pesos, retorno_esperado.value.round(4), \n            cp.sqrt(risco_esperado).value.round(4))\n\ndef fronteira_risco_retorno(amostra_retornos, variacao_amostra, amostra_cov):\n    media = variacao_amostra.mean()\n    riscos = [minimizar_riscos(media, amostra_cov, rtr)[2] for rtr in amostra_retornos]\n    return pd.DataFrame({'Retornos': amostra_retornos, 'Riscos': np.array(riscos)})","41ab14a8":"xs = np.linspace(-0.01025, -0.00430, num = 50)\nfronteira = fronteira_risco_retorno(xs, retorno_percentual, carteira_cov)\n\nax = df.plot.scatter(x='Riscos', y='Retornos', c='Sharpes', cmap='RdYlBu', edgecolors='black', \n                     figsize=(24, 8), grid=True, sharex=False)\nfronteira.plot.line(x='Riscos', y='Retornos', color='DarkGreen', ax=ax,\n                    label='Fronteira Eficiente')\nplt.xlabel('Risco')\nplt.ylabel('Retorno Esperado')\nplt.title(u'Simula\u00e7\u00e3o Carteiras')\nplt.show()\n\nfronteira.head()","2347bccb":"def maximizar_retornos(medias, cov, risco_maximo):\n    top_risco = risco_maximo**2\n    pesos = cp.Variable(len(medias))\n    \n    risco_esperado = cp.quad_form(pesos, cov)\n    retorno_esperado = pesos.T * medias\n    \n    obj = cp.Maximize(retorno_esperado)\n    cons = [\n        risco_esperado <= top_risco,\n        cp.sum(pesos) == 1,\n        pesos >= 0\n    ]\n    \n    prob = cp.Problem(obj, cons)\n    prob.solve(solver='ECOS')\n    \n    return (pesos.value.round(4), retorno_esperado.value, \n            np.sqrt(risco_esperado.value))\n    \ndef fronteira_retorno_risco(amostra_riscos, variacao_amostra, amostra_cov):\n    media = variacao_amostra.mean()\n    retornos = [maximizar_retornos(media, amostra_cov, rsc)[1] for rsc in amostra_riscos]\n    return pd.DataFrame({'Retornos': np.array(retornos), 'Riscos': amostra_riscos})\n\nxs = np.linspace(0.03562, 0.04670, num = 50)\nfronteira = fronteira_retorno_risco(xs, retorno_percentual, carteira_cov)\nfronteira.head()\n\nax = df.plot.scatter(x='Riscos', y='Retornos', c='Sharpes', cmap='RdYlBu', edgecolors='black',\n                     figsize=(26, 8), grid=True, sharex=False)\nfronteira.plot.line(x='Riscos', y='Retornos', color='DarkGreen', ax = ax,\n                    label='Fronteira Eficiente')\nplt.xlabel('Risco')\nplt.ylabel('Retorno Esperado')\nplt.title(u'Simula\u00e7\u00e3o Carteiras')\nplt.show()","8f567748":"carteira_otimizada, _, _ = maximizar_retornos(retorno_percentual.mean(), carteira_cov,\n                                              risco_inicial)\ncarteira_arriscada, _, _ = maximizar_retornos(retorno_percentual.mean(), carteira_cov,\n                                              risco_inicial + 0.05)\ncarteira_segura, _, _ = maximizar_retornos(retorno_percentual.mean(), carteira_cov,\n                                           risco_inicial - 0.008)\n\ndistribuicao = pd.DataFrame(dict(inicial = carteira_inicial,\n                                 otimizada = carteira_otimizada,\n                                 arriscada = carteira_arriscada,\n                                 segura = carteira_segura),\n                            index = moedas)\ndistribuicao.plot.pie(subplots=True, figsize=(20, 4), autopct='%1.0f%%', \n                      pctdistance=1.1, labeldistance=1.2, legend=False,\n                      colors=cores)\n\nevolucao = pd.DataFrame(dict(\n    inicial = np.sum(mudanca_proporcional * carteira_inicial, axis=1),\n    otimizada = np.sum(mudanca_proporcional * carteira_otimizada, axis=1),\n    arriscada = np.sum(mudanca_proporcional * carteira_arriscada, axis=1),\n    segura = np.sum(mudanca_proporcional * carteira_segura, axis=1)))\n\nevolucao.plot.line(figsize=(24, 8), grid=True)\nevolucao.tail()","9a91bddc":"## Risco e Retorno\n\nA gest\u00e3o de investimentos tem incorporada uma rela\u00e7\u00e3o clara entre risco e retorno. O retorno esperado pelo investidor est\u00e1 relacionado com o risco que pretende correr.  Risco \u00e9 a probabilidade de o retorno efetivo de um investimento ser diferente do retorno esperado (inicialmente) do mesmo, ou seja, o risco \u00e9 uma incerteza e ao prolongar-se no tempo mais incerto se torna.\n\nEsta atitude tomada pelo investidor depende do seu perfil de risco, no caso de ser avesso ao risco ir\u00e1 optar por uma carteira com menor risco, logo menor retorno esperado, se for propenso ao risco ir\u00e1 optar neste caso por uma carteira de maior risco, logo maior retorno esperado. O perfil do investidor ser\u00e1 diferente para cada pessoa com base nas caracter\u00edsticas individuais a avers\u00e3o pelo risco. \n\nDe forma pr\u00e1tica, um investimento em a\u00e7\u00f5es est\u00e1 suscet\u00edvel a um alto risco, enquanto um investimento em t\u00edtulo p\u00fablicos apresentam um risco mais baixo. Sendo assim, uma boa carteira de investimentos pode conter, para um mesmo n\u00edvel de risco, um percentual investido em a\u00e7\u00f5es e t\u00edtulos e ainda assim apresentar um retorno esperado maior que uma aplica\u00e7\u00e3o apresentando somente t\u00edtulos (ou a\u00e7\u00f5es). Deste modo, para um mesmo n\u00edvel de risco existe uma poss\u00edvel carteira alternativa que tem melhor retorno esperado. \n\n### Exemplificando retorno\n\nO retorno esperado da carteira \u00e9 calculado como uma soma ponderada dos retornos dos ativos individuais. Se uma carteira contivesse quatro ativos igualmente ponderados com retornos esperados de 4, 6, 10 e 14%, o retorno esperado da carteira seria:\n\n(4% x 25%) + (6% x 25%) + (10% x 25%) + (14% x 25%) = 8.5%\n\nNo caso analisado das 8 criptomoedas selecionadas e igualmente ponderadas, o c\u00e1lculo seria a composi\u00e7\u00e3o da carteira inicial (12,5% para cada ativo) multiplicado pela m\u00e9dia aritm\u00e9tica dos retornos percentuais.","f9c1add2":"# Considera\u00e7\u00f5es\n\nO objetivo deste notebook \u00e9 mostrar que \u00e9 poss\u00edvel ter um bom retorno em uma carteira de investimentos, fazendo uso do conceito de diversifica\u00e7\u00e3o de modo inteligente. Dado um certo n\u00edvel de risco que o investidor est\u00e1 disposto a assumir, \u00e9 poss\u00edvel distribuir seus investimentos de modo a maximizar seus retornos.\n\nEntretanto, \u00e9 v\u00e1lido salientar que as distribui\u00e7\u00f5es assumidas aqui foram feitas com base em s\u00e9ries passadas e as simula\u00e7\u00f5es foram executadas em um dado momento do passado, portanto como se todas as varia\u00e7\u00f5es futuras, a partir deste ponto fossem conhecidas. Nada garante que esse mesmo bom resultado ser\u00e1 alcan\u00e7ado em aplica\u00e7\u00f5es futuras (pois ainda s\u00e3o desconhecidas).\n\nAl\u00e9m disso, o exemplo utilizado aqui fez uso de uma janela de tempo de 2 meses (2018-09-27 e 2018-11-28). N\u00e3o houve nenhum m\u00e9todo de escolha para usar este per\u00edodo.\n\nPara mitigar esses pontos levantados, \u00e9 importante fazer simula\u00e7\u00f5es com s\u00e9ries passadas para analisar, com mais seguran\u00e7a, o quanto uma estimativa de aloca\u00e7\u00e3o levantada, tem efeito em futuras varia\u00e7\u00f5es (at\u00e9 ent\u00e3o desconhecidas). Esta fase de testar um modelo de predi\u00e7\u00e3o utilizando dados hist\u00f3ricos chama-se **backtesting**, durante esta fase tamb\u00e9m pode-se calibrar e testar qual seria a melhor janela de tempo a ser utilizada na gera\u00e7\u00e3o deste modelo.\n\nExistem excelentes ferramentas para executar backtesting em python, mas isso \u00e9 assunto para um outro notebook.\n\n\n\n","7c87a5af":"Ap\u00f3s a declara\u00e7\u00e3o das ditas fun\u00e7\u00f5es, cria-se uma `fronteira` usando um intervalo de retornos esperados \\[-0.01025, -0.00430\\]. Em seguida essa fronteira \u00e9 plotada em cima do gr\u00e1fico de Retorno Esperado x Risco.\n\nPode-se observar no gr\u00e1fico gerado um limite chamado \"Fronteira Eficiente\", indicando que as simula\u00e7\u00f5es geradas aleatoriamente poderiam apresentar um maior Retorno Esperado para seus respectivos Riscos assumidos, se fossem distribu\u00eddos de maneira diferente.","335a2d9c":"Diferente do trecho de c\u00f3digo anterior, abaixo ser\u00e1 calculado o retorno percentual entre um dia corrente e o dia imediatamente anterior a ele. Ou seja, na tabela apresentada abaixo os valores em `2018-11-19`, apresentam a mudan\u00e7a percentual ocorrida entre `2018-11-18` e `2018-11-19`.\n\nEsta informa\u00e7\u00e3o \u00e9 \u00fatil para medir a mudan\u00e7a percentual em elementos em s\u00e9rie temporal. Que ser\u00e1 \u00fatil para c\u00e1lculos futuros como **retorno esperado, risco e \u00edndice de sharpe**.","d1b02a06":"O trecho abaixo armazena na vari\u00e1vel `mudanca_proporcional` a mudan\u00e7a de valores proporcional ao primeiro dia observado (`2018-09-27`).\n\nPode-se perceber pelo gr\u00e1fico que n\u00e3o foi um bom per\u00edodo para as criptomoedas, j\u00e1 que observa-se uma tend\u00eancia de queda nos per\u00edodos mais recentes.","9b58fbd3":"## Simula\u00e7\u00f5es de Carteiras\n\nAp\u00f3s as principais medidas levantadas neste notebook j\u00e1 esclarecidas (**retorno esperado, risco e \u00edndice de sharpe**), o pr\u00f3ximo passo \u00e9 iniciar uma s\u00e9rie de simula\u00e7\u00f5es para criar uma s\u00e9rie de carteiras, com propor\u00e7\u00f5es de ativos diferentes, e montar um comparativo entre as suas principais medidas.\n\nO trecho abaixo, define uma fun\u00e7\u00e3o chamada `gerar_distribuicao_carteira`, que tem por objetivo montar carteiras (propor\u00e7\u00f5es de ativos) de maneira aleat\u00f3ria e suas principais m\u00e9tricas.\n\nAo final, a fun\u00e7\u00e3o \u00e9 chamada com um total de 10000 simula\u00e7\u00f5es de par\u00e2metro. O resultado desta amostra gerada e armazenada na vari\u00e1vel `df`, como pode ser visto abaixo.","d786dec9":"De maneira semelhante as declara\u00e7\u00f5es passadas, o trecho abaixo declara uma fun\u00e7\u00e3o `maximizar_retornos`, onde \u00e9 poss\u00edvel maximizar o retorno esperado, dado um determinado risco. Em seguida, a fun\u00e7\u00e3o `fronteira_retorno_risco` tem como objetivo gerar um Dataframe contendo uma s\u00e9rie de riscos e m\u00e1ximos retornos de cada um deles (calculados com a fun\u00e7\u00e3o `maximizar_retornos`).","28d5ff77":"### Exemplificando risco\n\nUsualmente, o risco de um ativo financeiro \u00e9 medido pelo seu desvio-padr\u00e3o. Entretanto, um dos principais pontos levantados na [teoria de Markowitz](https:\/\/pt.wikipedia.org\/wiki\/Teoria_moderna_do_portf%C3%B3lio) \u00e9 que o risco de um ativo medido isoladamente torna-se diferente quando esse ativo \u00e9 incluso em uma carteira.\n\nPortanto, n\u00e3o se pode calcular o desvio-padr\u00e3o de uma carteira simplesmente somando ou obtendo a m\u00e9dia dos desvios de cada ativo isoladamente (como feito para o c\u00e1lculo do valor esperado).\n\nO risco da carteira \u00e9 uma fun\u00e7\u00e3o complicada das varia\u00e7\u00f5es de cada ativo e da covari\u00e2ncia de cada par de ativos. A covari\u00e2ncia \u00e9 uma medida que mostra o qu\u00e3o relacionados os ativos s\u00e3o entre si. Esta medida ajudar\u00e1 a encontrar a composi\u00e7\u00e3o apropriada. Idealmente a composi\u00e7\u00e3o de ativos n\u00e3o deve ser correlacionada, deste modo, se um ativo tiver uma tend\u00eancia negativa outro dever\u00e1 ter uma positiva e o retorno ser\u00e1 balanceado. \n\nUsando os valores hist\u00f3ricos de retorno percentual para calcular a covari\u00e2ncia de todas as criptomoedas resultar\u00e1 em uma tabela de 64 (8 x 8) elementos.","23ac12ce":"### \u00cdndice Sharpe\n\nO \u00edndice de Sharpe \u00e9 simplesmente uma medida do desempenho dos retornos de um investimento, dado seu risco. Essa rela\u00e7\u00e3o ajusta os retornos de um investimento, o que torna poss\u00edvel comparar diferentes investimentos em uma escala que incorpora o risco. Sem essa escala de compara\u00e7\u00e3o, seria virtualmente imposs\u00edvel comparar diferentes investimentos com diferentes combina\u00e7\u00f5es e seus riscos e retornos associados.\n\nO \u00edndice de sharpe \u00e9 calculado, de forma simplificada, por:","c4099548":"# Fontes\n\n* https:\/\/medium.com\/@asankhaya\/build-a-portfolio-of-cryptocurrencies-using-modern-portfolio-theory-d65217858660\n* https:\/\/www.investopedia.com\/terms\/m\/modernportfoliotheory.asp\n* https:\/\/pt.wikipedia.org\/wiki\/Teoria_moderna_do_portf\u00f3lio\n* https:\/\/medium.com\/python-data\/effient-frontier-in-python-34b0c3043314\n* https:\/\/blog.quantopian.com\/markowitz-portfolio-optimization-2\n* https:\/\/www.wrprates.com\/teoria-de-markowitz-teoria-da-carteira-e-a-fronteira-eficiente\/","29b01c98":"Em seguida \u00e9 plotado um gr\u00e1fico de Retorno Esperado x Risco para cada um das carteiras geradas na simula\u00e7\u00e3o. \nCada ponto deste gr\u00e1fico \u00e9 colorido com o valor do seu \u00edndice de sharpe (verde ser\u00e3o os valores maiores, enquanto vermelho os valores mais baixos).","e818ed29":"# Teoria moderna do portf\u00f3lio\n\nA teoria moderna do portf\u00f3lio, ou simplesmente teoria do portf\u00f3lio, explica como investidores racionais ir\u00e3o usar o princ\u00edpio da **diversifica\u00e7\u00e3o** para otimizar (ou maximizar o retorno esperado) as suas carteiras de investimentos, dado um determinado n\u00edvel de risco. \n\nAl\u00e9m de maximizar o retorno esperado (para um determinado risco), a teoria do portf\u00f3lio tamb\u00e9m permite encontrar a carteira de m\u00ednima vari\u00e2ncia (CMV), que se resume em encontrar o portf\u00f3lio \u00f3timo atrav\u00e9s de um ponto de m\u00ednimo (atrav\u00e9s de uma derivada). Este portf\u00f3lio ser\u00e1 o de menor risco dentre todas as combina\u00e7\u00f5es poss\u00edveis.\n\nDe acordo com a teoria, \u00e9 poss\u00edvel construir uma \"**fronteira eficiente**\" de portf\u00f3lios \u00f3timos, oferecendo o m\u00e1ximo retorno esperado poss\u00edvel para um dado n\u00edvel de risco.\n\n![Fronteira Eficiente](https:\/\/www.wrprates.com\/wp-content\/uploads\/2016\/11\/mvp.png)\n\nO trabalho pioneiro na \u00e1rea de otimiza\u00e7\u00e3o de portf\u00f3lio foi \u00e0 proposi\u00e7\u00e3o do modelo m\u00e9dia-vari\u00e2ncia por Harry Markowitz (1952). A teoria do portf\u00f3lio estabelece que decis\u00f5es relacionadas \u00e0 sele\u00e7\u00e3o de investimentos devam ser tomadas com base na rela\u00e7\u00e3o risco-retorno. Para auxiliar neste processo, modelos de otimiza\u00e7\u00e3o de portf\u00f3lio t\u00eam sido desenvolvidos. De modo a serem efetivos, tais modelos devem ser capazes de quantificar os n\u00edveis de risco e retorno dos investimentos.\n\nO trecho de c\u00f3digo abaixo faz uso da biblioteca `cvxpy` para calcular a os limites de risco e retorno poss\u00edveis dado um hist\u00f3rico de retornos esperados e covari\u00e2ncia entre os ativos.\n\nInicialmente \u00e9 declarado a fun\u00e7\u00e3o `minimizar_riscos` onde \u00e9 poss\u00edvel minimizar o risco de uma carteira, dado um retorno esperado. Em seguida, a fun\u00e7\u00e3o `fronteira_risco_retorno` tem como objetivo gerar um Dataframe contendo uma s\u00e9rie de retornos esperados e o menor risco esperado de cada um deles (calculados com a fun\u00e7\u00e3o `minimizar_riscos`).","7394a8e9":"# Introdu\u00e7\u00e3o \n\nEste notebook tem a finalidade de apresentar um caso de estudos sobre diversifica\u00e7\u00e3o de produtos em uma carteira de investimentos. A id\u00e9ia \u00e9 equilibrar risco e rentabilidade, garantindo que o conjunto tenha o desempenho esperado. \n\nO caso apresentado aqui \u00e9 focado na montagem de uma carteira de criptomoedas, entretanto seus conceitos podem ser aplicados a qualquer produtos de investimento, sejam a\u00e7\u00f5es, fundos, t\u00edtulos p\u00fablicos, deb\u00eantures, aplica\u00e7\u00f5es imobili\u00e1rias, etc.\n\n## Carteira de investimentos\n\nUma carteira de investimentos \u00e9 um grupo de ativos que pertence a um determinado investidor, seja pessoa f\u00edsica ou jur\u00eddica. Tamb\u00e9m chamada de **cesta** ou **portf\u00f3lio de investimentos**, ela re\u00fane ativos financeiros que podem pertencer a uma categoria de investimento.\n\nA carteira permite a **diversifica\u00e7\u00e3o** de ativos que tem como objetivo (mas n\u00e3o necessariamente) fornecer menos riscos ao investidor, pois o mesmo n\u00e3o confia seu dinheiro em apenas um \u00fanico produto. Al\u00e9m disso, como apresentado neste notebook, tem o potencial de aumentar seus retornos.\n\nO trecho abaixo apresenta uma forma de baixar dados (no caso, valores de fechamento em d\u00f3lar) de algumas criptomoedas pelo Yahoo Finance entre `2018-09-27` e `2018-11-28` e armazen\u00e1-los na vari\u00e1vel `fechamento`.\n\nAs criptomoedas utilizadas s\u00e3o:\n\n| Simbolo | Nome         |\n|---------|--------------|\n| BTC     | Bitcoin      |\n| ETH     | Ethereum     |\n| XRP     | Ripple       |\n| BCH     | Bitcoin Cash |\n| LTC     | Litecoin     |\n| IOT     | Iota         |\n| XMR     | Monero       |\n| DASH    | Dash         |","121ffc6f":"Para calcular o risco de uma carteira de quatro ativos, a seguinte f\u00f3rmula ser\u00e1 utilizada:\n\n$$\\sigma_p = \\sqrt{ w^T \\cdot C \\cdot w }$$, onde $w$ \u00e9 a propor\u00e7\u00e3o de cada ativo na carteira (no exemplo atual, 12,5% para cada ativo) e $C$ \u00e9 a pr\u00f3pria tabela de covari\u00e2ncia, j\u00e1 definida na vari\u00e1vel `carteira_cov`.","a03953c1":"Por quest\u00f5es de simplicidade, ser\u00e1 assumido que uma carteira inicial \u00e9 composta com todas as criptomoedas apresentadas at\u00e9 aqui, de maneira proporcional. Ou seja, como foram apresentadas 8 criptomoedas, cada uma delas ter\u00e1 uma composi\u00e7\u00e3o de 12,5% (12,5% x 8 = 100%) da carteira.\n\nCom esta composi\u00e7\u00e3o inicial, esta carteira apresentaria a evolu\u00e7\u00e3o abaixo.","31183927":"# Aplicando os conceitos\n\nFazendo uso da fun\u00e7\u00e3o `maximizar_retornos`, pode-se criar uma nova `carteira_otimizada` que possua o mesmo `risco_inicial` da `carteira_inicial`. Esta nova carteira ter\u00e1 uma nova distribui\u00e7\u00e3o de ativos e um novo retorno ao final do per\u00edodo que tende a ser maior (ou igual) que o da `carteira_inicial`. De modo semelhante, tamb\u00e9m foi criada uma carteira chamada `carteira_arriscada`, onde assume-se um risco 0.05 maior que o `risco_inicial` e uma outra chamada `carteira_segura`, que possui um risco 0.008 menor que o `risco_inicial`.\n\nO trecho de c\u00f3digo abaixo mostra em gr\u00e1ficos as diferentes composi\u00e7\u00f5es entre as tr\u00eas carteiras. Al\u00e9m disso tamb\u00e9m mostra um gr\u00e1fico de evolu\u00e7\u00e3o das carteiras.\n\n\u00c9 poss\u00edvel observar, dado ao p\u00e9ssimo momento da valoriza\u00e7\u00e3o das criptomoedas neste per\u00edodo analisado, que mesmo a `carteira_otimizada` n\u00e3o obteve uma boa evolu\u00e7\u00e3o neste per\u00edodo, apresentando uma queda apr\u00f3ximada de 30%. Entretanto ela ainda teve uma queda ainda menor, se comparada ao da `carteira_inicial`, que mostrou uma queda de aproximadamente 44%.\n\nTamb\u00e9m pode-se observar que ao assumir um risco maior o retorno final \u00e9 ainda maior que o da `carteira_otimizada`, entretanto a distribui\u00e7\u00e3o inteira ficou em apenas um ativo (XRP-USD). J\u00e1 o investimento com menor risco obteve uma retorno menos que a `carteira_otimizada` e a `carteira_arriscada`, entretanto ainda oferecendo uma risco menor que a `carteira_inicial`, ainda conseguiu um retorno maior."}}