{"cell_type":{"e59c738b":"code","2a98c3b4":"code","d6f6488d":"code","c66ddbf4":"code","fd7cb69b":"code","ba10ae26":"code","2eefa6d7":"code","b93bf03e":"code","0b68add2":"code","a8dc2af4":"code","dfe1a418":"code","c81b4ccc":"code","8897a2ba":"code","e4a75f7b":"code","2953ae85":"code","7e1c71bd":"code","3194f9f7":"code","bcaf835f":"code","9f7881f4":"code","e4796535":"code","e17aad80":"code","13b93d36":"code","3ab58cc7":"code","bb1b517e":"code","773b32bf":"markdown","a7551059":"markdown","0e6f5e64":"markdown","127332cc":"markdown","500319ee":"markdown","19930a55":"markdown","0aa9a989":"markdown","eb500ac0":"markdown","baa85b8a":"markdown","6378172c":"markdown"},"source":{"e59c738b":"# Importing Libraries\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline    \nimport warnings\nwarnings.filterwarnings('ignore')\nplt.style.use('Solarize_Light2') \nfrom pylab import rcParams  \n\nimport plotly.plotly as py\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport cufflinks","2a98c3b4":"# Processing the Data\n\ndf = pd.read_csv('..\/input\/prc_hicp.csv')\ndf.head(2)","d6f6488d":"df.drop(['GEO', 'UNIT', 'COICOP'], inplace=True, axis=1)","c66ddbf4":"df.info()   # time as object, need convert to data_time format","fd7cb69b":"df['TIME'].replace(regex=True,inplace=True, to_replace='M',value='')\ndf['TIME'] =  pd.to_datetime(df['TIME'], format='%Y%m', errors='ignore', infer_datetime_format=True)\ndf = df.set_index(['TIME'])","ba10ae26":"df.index","2eefa6d7":"df[pd.isnull(df['Value'])].count()","b93bf03e":"# Resulting Plot\nrcParams['figure.figsize'] = 12, 6\ndf.plot()\nplt.xlabel('Date')\nplt.ylabel('Index')\nplt.title(\"HICP\")","0b68add2":"# Test stationarity for model selection\n\nfrom statsmodels.tsa.stattools import adfuller\ndef testStationarity(ts):\n    dftest = adfuller(ts)\n    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\n    for key,value in dftest[4].items():\n        dfoutput['Critical Value (%s)'%key] = value\n    return dfoutput\n\ntestStationarity(df.Value)","a8dc2af4":"from statsmodels.tsa.seasonal import seasonal_decompose\nresult = seasonal_decompose(df, model='multiplicative')\n\n\nrcParams['figure.figsize'] = 12, 6\nplt.rc('lines', linewidth=1, color='r')\n\nfig = result.plot()\n#print(plt.style.available)","dfe1a418":"import statsmodels.api as sm\nmod = sm.tsa.statespace.SARIMAX(df,\n                                order=(1, 1, 0),\n                                seasonal_order=(0, 1, 1, 12),\n                                enforce_stationarity=False,\n                                enforce_invertibility=False)\n\nresults = mod.fit()\n\nprint(results.summary())","c81b4ccc":"results.plot_diagnostics(figsize=(14,10))\nplt.show()","8897a2ba":"pred = results.get_prediction(start=pd.to_datetime('2016-01-01'), dynamic=False)\npred_ci = pred.conf_int()","e4a75f7b":"pred_ci['Predicted'] = (pred_ci['lower Value'] + pred_ci['upper Value'])\/2\npred_ci['Observed'] = df['Value']\npred_ci['Diff, %%'] = ((pred_ci['Predicted'] \/ pred_ci['Observed'])-1) * 100\npred_ci.tail(5)","2953ae85":"ax = df['1990':].plot(label='observed')\npred.predicted_mean.plot(ax=ax, label='Forecast', alpha=.7)\n\nax.fill_between(pred_ci.index,\n                pred_ci.iloc[:, 0],\n                pred_ci.iloc[:, 1], color='k', alpha=.2)\n\nplt.xlabel('Date')\nplt.ylabel('Index')\nplt.title(\"HICP\")\nplt.legend()\nrcParams['figure.figsize'] = 12, 10\nplt.show()","7e1c71bd":"# Get forecast 3 years ahead in future\npred_uc = results.get_forecast(steps=36)\n\n# Get confidence intervals of forecasts\npred_ci = pred_uc.conf_int()","3194f9f7":"ax = df.plot(label='observed', figsize=(12, 6))\npred_uc.predicted_mean.plot(ax=ax, label='Forecast')\nax.fill_between(pred_ci.index,\n                pred_ci.iloc[:, 0],\n                pred_ci.iloc[:, 1], color='k', alpha=.25)\nplt.xlabel('Date')\nplt.ylabel('Index')\nplt.title(\"HICP\")\n\nplt.legend()\n\nplt.show()","bcaf835f":"pred_ci.head(11)","9f7881f4":"rcParams['figure.figsize'] = 12, 6\npred_ci.head(11).plot()\nplt.xlabel('Date')\nplt.ylabel('Index')\nplt.title(\"HICP\")","e4796535":"pred_ci['Mean'] = (pred_ci['lower Value'] + pred_ci['upper Value'])\/2","e17aad80":"pred_ci['Mean'].head(11)","13b93d36":"rcParams['figure.figsize'] = 12, 6\npred_ci['Mean'].head(11).plot()\nplt.xlabel('Date')\nplt.ylabel('Index')\nplt.title(\"HICP\")","3ab58cc7":"import seaborn as sns\n\nprint(\"                     HICP predicted monthly and annual rates of change Jan 2019 to Dec 2019 \")\nmonthly_roc = [-0.8, 0.3, 0.8, 0.4, 0.3, 0.1, -0.3, 0.2, 0.3, 0.2, -0.2, 0.2]\nannual_roc = [1.5, 1.6, 1.5, 1.5, 1.2, 1.2, 1.1, 1, 1, 0.9, 1.1, 1.3]\nindex = ['2019-01', '20190-02', '2019-03', '2019-04', '2019-05', '2019-06', '2019-07', '2019-08', '2019-09', '2019-10', '2019-11', '2019-12']\n\n\nf, (ax1, ax2) = plt.subplots(2, 1, figsize=(16, 8), sharex=True)\n\n# Generate some sequential data\n\nsns.barplot(x=index, y=monthly_roc, palette=\"rocket\", ax=ax1)\nax1.axhline(0, color=\"k\", clip_on=False)\nax1.set_ylabel(\"HICP monthly rate of change\")\n\n# Center the data to make it diverging\n\nsns.barplot(x=index, y=annual_roc, palette=\"vlag\", ax=ax2)\nax2.axhline(0, color=\"k\", clip_on=False)\nax2.set_ylabel(\"HICP annual rate of change\")\n\n\n","bb1b517e":"print(\"                     HICP original and predicted monthly and annual rates of change Jan 2018 to Dec 2019 \")\n\nmonthly_rocc = [-0.7, 0.2, 0.8, 0.4, 0.5, 0.1, -0.2, 0.2, 0.3, 0.2, -0.4, 0.0,\n-0.8, 0.3, 0.8, 0.4, 0.3, 0.1, -0.3, 0.2, 0.3, 0.2, -0.2, 0.2] \nannual_rocc = [1.6, 1.4, 1.6, 1.5, 2.0, 2.1, 2.2, 2.2, 2.2, 2.3, 2.0, 1.6,\n1.5, 1.6, 1.5, 1.5, 1.2, 1.2, 1.1, 1.0, 1.0, 0.9, 1.1, 1.3]\nindex = ['201801', '201802', '201803', '201804', '201805', '201806', '201807', '201808', '201809', '201810', '201811', '201812', '201901', '2019002', '201903', '201904', '201905', '201906', '201907', '201908', '201909', '201910', '201911', '201912']\n\n\nf, (ax1, ax2) = plt.subplots(2, 1, figsize=(16, 8), sharex=True)\n\n# Generate some sequential data\n\nsns.barplot(x=index, y=monthly_rocc, palette=\"rocket\", ax=ax1)\nax1.axhline(0, color=\"k\", clip_on=False)\nax1.set_ylabel(\"HICP monthly rate of change\")\n\n# Center the data to make it diverging\n\nsns.barplot(x=index, y=annual_rocc, palette=\"vlag\", ax=ax2)\nax2.axhline(0, color=\"k\", clip_on=False)\nax2.set_ylabel(\"HICP annual rate of change\")\n","773b32bf":"Decomposition separate HICP time series into distinct trend, seasonal, and residual components. The trend part reflects the long-term movement of the series, the seasonal part represents the changes with fixed and known periodicity and the residual part explains the non-periodic fluctuations, noisy or random movements.\n \nFrom the Trend component we see that trend is ascending, means HICP index values is raising over time. Residual element has irregularity, becouse inflation depends on various macroeconomical factors , that are unpredictable. We can clearly see the seasonal component of the data (seasonal curve changes in similar pattern over the years). ","a7551059":"results.aic()","0e6f5e64":"performing SARIMAX\n\nfrom pmdarima.arima import auto_arima","127332cc":"For model selection we used adfuller test. Time series are stationary if they do not have trend or seasonal effects, otherwire considered as not-stationary. For not-stationary time series best fit SARIMAX model. \n\nThe Augmented Dickey-Fuller test is a type of statistical test called a unit root test.\n\nThe null hypothesis of the test is that the time series can be represented by a unit root, that it is not stationary (has some time-dependent structure). The alternate hypothesis (rejecting the null hypothesis) is that the time series is stationary.\n- Null Hypothesis (H0): If failed to be rejected, it suggests the time series has a unit root, meaning it is non-stationary. It has some time dependent structure.\n- Alternate Hypothesis (H1): The null hypothesis is rejected; it suggests the time series does not have a unit root, meaning it is stationary. It does not have time-dependent structure.\n\nWe interpret this result using the p-value from the test.\n- p-value > 0.05: Fail to reject the null hypothesis (H0), the data has a unit root and is non-stationary.\n- p-value <= 0.05: Reject the null hypothesis (H0), the data does not have a unit root and is stationary.\n\nNull Hypothesis is failed to be rejected by Dickey-Fuller test and gave a result of Test statistical value -0.533887, which is higher than Critical value (10%). That is also indicated by p-value 0.885232 (p-value > 0.05), meaning, that out time series are not-stationary, having strong seasonal effects and we will fit SARIMAX model.\n\n  ","500319ee":"Output\n-209.6748286967192","19930a55":"results = auto_arima(df, start_p=1, start_q=1,\n                           max_p=3, max_q=3, m=12,\n                           start_P=0, seasonal=True,\n                           d=1, D=1, trace=True,\n                           error_action='ignore',  \n                           suppress_warnings=True, \n                           stepwise=True)","0aa9a989":"  Forecasting HICP Seasonal Time Series using Python and SARIMAX\n\n------------------------------------Dataset-----------------------------------------------------------\n \n Harmonised index of consumer prices (HICP) is a consumer price index calculated according to a methodology harmonised across the European Union (EU). The HICPs produced by each EU member state are used to measure inflation in the EU, make international comparisons between the EU Member States, implement the monetary policy of the European Central Bank, calculate the European index of consumer prices, the Monetary Union index of consumer prices, and the European Economic Area index of consumer prices. The country\u2019s compliance with the price stability criterion is assessed taking into consideration the HICP - based inflation rate. The HICP can be regarded as an indicator showing the amount the average consumer would have to spend in a given year to buy the same basic goods and services for which one would have to pay 100 monetary units in the reference period. \n  Index reference period \u2013 the reference period with the index equated to 100 points. Having the time series of price indices, calculated with a single index reference period, it is possible to determine the HICP for different periods.  \n  \n  We will use HICP dataset of all EU member states, published in official Eurostat database:        https:\/\/ec.europa.eu\/eurostat\/data\/database\n  \n-----------------------------------Analysis plan--------------------------------------------------------\n  \n   Economic or financial theory\n   \n    Economic model formulation\n                \n     Data mining and cleaning\n                \n         Model evaluation\n                \n       Model Interpretation\n                \n        Model application\n                \n        Results evaluation\n--------------------------------- About model----------------------------------------------------------\n \n Autoregressive Integrated Moving Average, or ARIMA, is one of the most widely used forecasting methods for univariate time series data forecasting. Although the method can handle data with a trend, it does not support time series with a seasonal component. An extension to ARIMA that supports the direct modeling of the seasonal component of the series is called SARIMA.\nWe will use the Seasonal Autoregressive Integrated Moving Average, or SARIMA, method for time series HICP forecasting with univariate data containing trends and seasonality.\n\n","eb500ac0":"Statespace model result in P>|z| - 0.000, and now our model is turned from non-stationary into stationary.\n\nFrom diagnostic results plots:\n- In the top right plot, we see that the red KDE line follows closely with the N(0,1) line (where N(0,1)) is the standard notation for a normal distribution with mean 0 and standard deviation of 1). This is a good indication that the residuals are normally distributed.\n- The qq-plot on the bottom left shows that the ordered distribution of residuals (blue dots) follows the linear trend of the samples taken from a standard normal distribution with N(0, 1). Again, this is a strong indication that the residuals are normally distributed.\n- The residuals over time (top left plot) don't display any obvious seasonality and appear to be white noise. This is confirmed by the autocorrelation (i.e. correlogram) plot on the bottom right, which shows that the time series residuals have low correlation with lagged versions of itself.","baa85b8a":"Output:\n\nFit ARIMA: order=(1, 1, 1) seasonal_order=(0, 1, 1, 12); AIC=-207.919, BIC=-190.039, Fit time=5.216 seconds\nFit ARIMA: order=(0, 1, 0) seasonal_order=(0, 1, 0, 12); AIC=-117.138, BIC=-109.987, Fit time=0.221 seconds\nFit ARIMA: order=(1, 1, 0) seasonal_order=(1, 1, 0, 12); AIC=-181.787, BIC=-167.484, Fit time=2.397 seconds\nFit ARIMA: order=(0, 1, 1) seasonal_order=(0, 1, 1, 12); AIC=-206.754, BIC=-192.450, Fit time=3.183 seconds\nFit ARIMA: order=(1, 1, 1) seasonal_order=(1, 1, 1, 12); AIC=-205.920, BIC=-184.465, Fit time=9.125 seconds\nFit ARIMA: order=(1, 1, 1) seasonal_order=(0, 1, 0, 12); AIC=-133.752, BIC=-119.448, Fit time=0.653 seconds\nFit ARIMA: order=(1, 1, 1) seasonal_order=(0, 1, 2, 12); AIC=-205.921, BIC=-184.465, Fit time=18.838 seconds\nFit ARIMA: order=(1, 1, 1) seasonal_order=(1, 1, 2, 12); AIC=-206.007, BIC=-180.976, Fit time=24.981 seconds\nFit ARIMA: order=(2, 1, 1) seasonal_order=(0, 1, 1, 12); AIC=-205.966, BIC=-184.511, Fit time=9.201 seconds\nFit ARIMA: order=(1, 1, 0) seasonal_order=(0, 1, 1, 12); AIC=-209.675, BIC=-195.371, Fit time=2.874 seconds\nFit ARIMA: order=(1, 1, 0) seasonal_order=(1, 1, 1, 12); AIC=-207.683, BIC=-189.804, Fit time=4.764 seconds\nFit ARIMA: order=(1, 1, 0) seasonal_order=(0, 1, 0, 12); AIC=-134.066, BIC=-123.339, Fit time=0.293 seconds\nFit ARIMA: order=(1, 1, 0) seasonal_order=(0, 1, 2, 12); AIC=-207.686, BIC=-189.806, Fit time=12.029 seconds\nFit ARIMA: order=(1, 1, 0) seasonal_order=(1, 1, 2, 12); AIC=-207.554, BIC=-186.098, Fit time=22.281 seconds\nFit ARIMA: order=(0, 1, 0) seasonal_order=(0, 1, 1, 12); AIC=-187.616, BIC=-176.888, Fit time=1.497 seconds\nFit ARIMA: order=(2, 1, 0) seasonal_order=(0, 1, 1, 12); AIC=-207.916, BIC=-190.036, Fit time=6.031 seconds\n\nTotal fit time: 123.596 seconds","6378172c":"SARIMA requires selecting hyperparameters for both the trend and seasonal elements of the series.Trend Elements: p - Trend autoregression order, d - Trend difference order, q - Trend moving average order. Seasonal Elements: P - Seasonal autoregressive order ,D - Seasonal difference order, Q - Seasonal moving average order and m - The number of time steps for a single seasonal period.\n\nTogether, the notation for an SARIMA model is specified as: SARIMA(p,d,q)(P,D,Q)m\n               \nWe used Auto Arima for automaticly identifying best hyperparameters for the trend and seasonal elements. And  the Model perform best with lowest AIC of -209.67, using Trend Elements - 1, 1, 0 and Seasonal Elements - - 0, 1, 1, where m - 12. Those hyperparameters we will fit into the SARIMAX."}}