{"cell_type":{"eeabd934":"code","448b314b":"code","54f75ef9":"code","1680cc45":"code","fbcb6397":"code","34bcf904":"code","fbb47fc7":"code","19178dbc":"code","ce450ceb":"code","ef6d6bd6":"code","8cbb3ee4":"code","e92ff876":"code","56354d32":"code","ab005aae":"code","2b84cf90":"code","9a98b707":"code","b7023d6d":"code","ca0ec5ec":"code","16d42cfc":"code","55167a28":"code","b2b968d3":"code","21972f3c":"code","1cf2543b":"code","70e7de4e":"code","ce67f92e":"code","642c4f12":"code","2f48b810":"code","5b6d7eed":"code","6182b334":"code","91ae644a":"code","96c0c873":"code","6d88029e":"markdown","359de1b1":"markdown","23741fe2":"markdown","f73ed27d":"markdown"},"source":{"eeabd934":"# importing libraries used in this notebook\n\nfrom keras.preprocessing import image\nfrom keras.applications.vgg16 import VGG16\nfrom keras.applications.vgg16 import preprocess_input\nimport numpy as np\nfrom sklearn.cluster import KMeans\nimport os, shutil, glob, os.path\nfrom PIL import Image\nimage.LOAD_TRUNCATED_IMAGES = True\nfrom tqdm.notebook import tqdm \nimport glob\nimport math\nimport pickle\n%pylab inline\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n%matplotlib inline","448b314b":"# storing the path of all the jpj file in filelist from our dataset\nfilelist = glob.glob(os.path.join('\/kaggle\/input\/change-cl\/dataset','*.jpg'))","54f75ef9":"#loading the featurelist that consist of bottleneck features of all the images\nwith open('\/kaggle\/input\/change-cl\/featurelist', 'rb') as f: \n    featurelist = pickle.load(f) ","1680cc45":"# loading the weights of vgg16 model that is train on imagenet data that consists of 1000 classes\nmodel = VGG16(weights='imagenet', include_top=False)","fbcb6397":"# converting the features list to array format for k means\nfeaturearray = np.asarray(featurelist)","34bcf904":"# printing shape of features array\nfeaturearray.shape","fbb47fc7":"# hyper parameter tuning for finding the best number of clusters\n\nfrom sklearn.cluster import KMeans\n\nclusters = [2,5,10,20,30,40,50]\nsquare_distance = []\n\nfor i in tqdm(clusters):\n    kmeans = KMeans(n_clusters=i, random_state=0).fit(featurearray)\n    square_distance.extend([kmeans.inertia_])","19178dbc":"# plot to find the value of k for which the loss is minimum\n\nplt.plot(clusters, square_distance)\n\nplt.scatter(clusters, square_distance, label='clustering points')\n\nplt.legend()\nplt.xlabel(\"N: hyperparameter\")\nplt.ylabel(\"Loss\")\nplt.title(\"Loss PLOT\")\nplt.grid()\nplt.show()","ce450ceb":"# so here loss may have been reduced further but due to computatinal complexity n = 50 looks good\nk_best = 50","ef6d6bd6":"# using the best_N\nkmeans = KMeans(n_clusters=k_best, random_state=0).fit(featurearray)\nlabels = kmeans.labels_","8cbb3ee4":"# length of labels list\nlen(labels)","e92ff876":"# printing the labels array\nlabels","56354d32":"# counting number of images per label\nfrom collections import Counter\nco = Counter(labels)","ab005aae":"co","2b84cf90":"# function that return the weight of a vector\n\ndef square_rooted(x):\n    return math.sqrt(sum([a*a for a in x]))\n\n\n# function to return the cosine similarity between two vectors\n\ndef cosine_similarity(x,y):\n    numerator = sum(a*b for a,b in zip(x,y))\n    denominator = square_rooted(x)*square_rooted(y)\n    return numerator\/float(denominator)","9a98b707":"# function to find cosine similarity of a given image with all the images in the dataset.\n#will only find cosine similarity of those images who belongs from the same cluster from where the input image belongs.\n\ndef find_similar(input_image_path,input_features,filelist,input_label,labels):\n    for i in tqdm(range(len(filelist))):\n        if filelist[i]== input_image_path:\n            continue\n        if input_label!= labels[i]:\n            continue\n        dic_store[filelist[i]] = cosine_similarity(input_features,featurelist[i])","b7023d6d":"# function to return the bottleneck feature of a given input image\n\ndef input_features(input_image_path):\n    img = image.load_img(input_image_path)\n    img_data = image.img_to_array(img)\n    img_data = np.expand_dims(img_data, axis=0)\n    img_data = preprocess_input(img_data)\n    features = np.array(model.predict(img_data))  \n    return features.flatten()","ca0ec5ec":"# function to represent the images as described in the problem statement\n\ndef print_images(N,input_image_path,sorted_x):\n    columns = 3\n    rows = ceil(N\/3) +1\n    fig=plt.figure(figsize=(8, 8))\n    input_image = mpimg.imread(input_image_path)\n    fig.add_subplot(rows, columns, 1)\n    plt.imshow(input_image)\n\n    i=3\n    for key in sorted_x:\n        i+=1\n        if(i>N+3):\n            break\n        fig.add_subplot(rows, columns, i)\n        img=mpimg.imread(key[0])\n        imgplot = plt.imshow(img)\n    plt.show()","16d42cfc":"# finding the cosine similarity between our image 3 and image 5\n\ncosine_similarity(featurelist[2],featurelist[5]) # for demonstration","55167a28":"# dictionary to store the cosine similarity of input image with other images\ndic_store = {}","b2b968d3":"# image for which you have to find similar images \n\ninput_image_path = '\/kaggle\/input\/change-cl\/dataset\/1000.jpg' # write image path","21972f3c":"# showing the input image\nim = Image.open(input_image_path)\nim","1cf2543b":"# will return input features of the input image\nfeatures = input_features(input_image_path)","70e7de4e":"#converting the features of input image in an array to fed it to the kmeans for prediction\ninputarray = np.asarray(features)","ce67f92e":"# predicting the label of the input image\ninputlabel = kmeans.predict(inputarray.reshape(1,-1))","642c4f12":"# printing the label of input image\ninputlabel","2f48b810":"# will find the cosine similarity of input image with other images\n\nfind_similar(input_image_path,features,filelist,inputlabel[0],labels)","5b6d7eed":"# sorting dictionary in descending order on values\nsorted_x = sorted(dic_store.items(), key=lambda kv: kv[1],reverse = True)","6182b334":"# printing top ten cosine similaity values and the images path\nsorted_x[0:10]","91ae644a":"# define the number of simailar images you want\nN = 10 #you can take any number","96c0c873":"# will return the N images similar to input image\nprint_images(N,input_image_path,sorted_x)","6d88029e":"**The result that we got after using clustering are not aspiring .So we were able to find the similar images more accurately without clustering**","359de1b1":" **Link of the change-cl notebook** https:\/\/www.kaggle.com\/karam123\/change-cl-clustering","23741fe2":"**In this notebook i am using clustering to reduce the time taken to find similar images**","f73ed27d":"**IN this notebook i am using the image features that i predict using the vgg model in chagne-cl notebook**"}}