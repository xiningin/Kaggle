{"cell_type":{"14c01228":"code","5e52140a":"code","da92b452":"code","10160420":"code","0595a5c6":"code","e10ee6c3":"code","f068913c":"markdown","91875b8a":"markdown","865214b6":"markdown","d36d1eab":"markdown","e8bcee5b":"markdown","011f8909":"markdown"},"source":{"14c01228":"import random\nimport time\nimport csv \n\ncsv_file =  open(\"master_data_csv.csv\", 'w')\ncsv_writer = csv.writer(csv_file, delimiter=\",\")\n\n#writing csv headers \nheader = ['product_id','product_name','supplier_id','brand_id','price']\ncsv_writer.writerow(header)\n\nfor product_id in range(1, 10, 1):\n    supplier_id = random.randint(1, 10000) #Randomly selecting supplier id \n    brand_id = random.randint(1, 10000) #Randomly selecting brand id \n    price = random.randint(1, 10000) #Randomly generating price \n        \n    master_tuple = (product_id, 'PN ' + str(product_id) ,supplier_id, brand_id ,price) \n    csv_writer.writerow(master_tuple)\n    \ncsv_file.close()","5e52140a":"import random \nimport bisect \nimport math \nimport csv \nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import special  \n\n#Function to genrate Zipfian Data \ndef randZipf(n, alpha, numSamples): \n    # Calculate Zeta values from 1 to n: \n    tmp = np.power( np.arange(1, n+1), -alpha )\n    zeta = np.r_[0.0, np.cumsum(tmp)]\n    # Store the translation map: \n    distMap = [x \/ zeta[-1] for x in zeta]\n    # Generate an array of uniform 0-1 pseudo-random values: \n    u = np.random.random(numSamples)\n    # bisect them with distMap\n    v = np.searchsorted(distMap, u)\n    samples = [t-1 for t in v]\n    return samples","da92b452":"#Generate graph of produced data \na = 0.5 # alpha parameter to control the zipfian exponenet \ns = randZipf(10000, a, 10000)\ncount, bins, ignored = plt.hist(s, 50, density=True)\nplt.show()","10160420":"#generate a CSV file \ncsv_file_t =  open(\"transaction_data_csv.csv\", 'w')\ncsv_writer = csv.writer(csv_file_t, delimiter=\",\")\n\n#writing csv headers \nheader = ['transaction_id','product_id','customer_id','store_id','brand_id','quantity','price']\ncsv_writer.writerow(header)\n\ntransaction_counter = 0\n\nfor product_id in s:\n    transaction_counter += 1 \n    customer_id = random.randint(1, 10000) #Randomly generating customer id \n    supplier_id = random.randint(1, 10000) #Randomly generating supplier id \n    brand_id = random.randint(1, 10000) #Randomly generating brand id \n    quantity = 1 #Randomly generating quantity     \n    price = random.randint(1, 500) #Randomly generating price \n        \n    transaction_tuple = (transaction_counter, product_id, customer_id, supplier_id, brand_id, quantity, price) \n    csv_writer.writerow(transaction_tuple)\n    \n    \ncsv_file_t.close()","0595a5c6":"#Generate graph of Two Way Zipfian Data \na = 0.5 # alpha parameter to control the zipfian exponenet \nmax_pid = 1000\ns1 = randZipf(1000, a, max_pid)\ns2 = [max_pid-t for t in s1] #reversing the trend \n\ns = [s1+s2] #Combine both trends \n\ncount, bins, ignored = plt.hist(s, 50, density=True)\nplt.show()\n","e10ee6c3":"#generate a CSV file \ncsv_file_t =  open(\"two_way_transaction_data_csv.csv\", 'w')\ncsv_writer = csv.writer(csv_file_t, delimiter=\",\")\n\n#writing csv headers \nheader = ['transaction_id','product_id','customer_id','store_id','brand_id','quantity','price']\ncsv_writer.writerow(header)\n\ntransaction_counter = 0\n\nfor product_id in s1:\n    transaction_counter += 1 \n    customer_id = random.randint(1, 10000) #Randomly generating customer id \n    supplier_id = random.randint(1, 10000) #Randomly generating supplier id \n    brand_id = random.randint(1, 10000) #Randomly generating brand id \n    quantity = 1 #Randomly generating quantity     \n    price = random.randint(1, 500) #Randomly generating price \n        \n    transaction_tuple = (transaction_counter, product_id, customer_id, supplier_id, brand_id, quantity, price) \n    csv_writer.writerow(transaction_tuple)\n\nfor product_id in s2:\n    transaction_counter += 1 \n    customer_id = random.randint(1, 10000) #Randomly generating customer id \n    supplier_id = random.randint(1, 10000) #Randomly generating supplier id \n    brand_id = random.randint(1, 10000) #Randomly generating brand id \n    quantity = 1 #Randomly generating quantity     \n    price = random.randint(1, 500) #Randomly generating price \n        \n    transaction_tuple = (transaction_counter, product_id, customer_id, supplier_id, brand_id, quantity, price) \n    csv_writer.writerow(transaction_tuple)\n\n    \ncsv_file_t.close()","f068913c":"***What is synthetic data?***\n\nSynthetic data, as the name suggests, is data that is artificially created rather than being generated by actual events. It is often created with the help of algorithms and is used for a wide range of activities, including as test data for new products and tools, for model validation, and in AI model training. Synthetic data is a type of data augmentation.\n\n***Why Synthetic Data:***\n\nDeveloping successful AI and ML models requires access to large amounts of high-quality data. However, collecting such data is challenging because\n\n* Many business problems that AI\/ML models could solve require access to sensitive customer data. Collecting and using sensitive data raises privacy concerns and leaves businesses vulnerable to data breaches. \n* Some types of data are costly to collect, or they are rare. In our case we are interested in E-commerce transactional data with long tail behavior, and also want to experiment with different variations of long tail. We also wanted to examine the multiple trend variations of the e-commerce transitions.  \n\nGenerating synthetic data that reflects the important statistical properties of the underlying real-world data can solve these problems. It is inexpensive compared to collecting large datasets and can support AI\/deep learning model development or software testing without compromising customer privacy.\n\n***Our Dataset Requirement:***\n\nThis code was my MS thesis part, I worked on Real-Time Data Warehousing technique. I needed controlled e-commerce data to verify my algorithm performance and results and do the comparative analysis of different algorithms on the same data. After doing some research and coding I came up with following code which can generate unlimited controlled transactions. \n\n","91875b8a":"***Our Dataset:***\n\nThere are two parts of our dataset. \n\n*Master Data:*\n\nMaster Data was based on products data, our requirement was to have minimum 2 million products with following attributes, \u2018Product Name\u2019, \u2018Supplier Id\u2019, \u2018Brand Id\u2019, \u2018Price\u2019. We generated this data using simple logic. We have provided steps to generate csv file from this data. \n","865214b6":"*Transaction Data:*\n\nFor transaction we needed transactions of products based on Zipfian distribution. We generated multiple data sets using different variation of Zipf\u2019s Law for our experiment. In following code, you will see how you can generate different variations of skewed data using Zif\u2019s Law. Later we will use this input data to generate Transaction CSV file. These lines are commented to avoid huge processing time.  \n","d36d1eab":"*Two Way Zipfian Data:*\n\nIn this section we will generate two way Zipfian data, it depicts the change in the trend. \n","e8bcee5b":"***Conclusion:***\n\nUsing this code, you can generate your desired master data and transactional data that can be utilized in any big data problem specially for Data warehousing. \n","011f8909":"*One way Zipfian Data:*\n\nIn this section we will generate one way Zipfian data. "}}