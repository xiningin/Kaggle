{"cell_type":{"ba1fe130":"code","313d1b1e":"code","72908d91":"code","adc89382":"code","c66c9965":"code","65513ed6":"code","c7a7b30c":"markdown","411c5ec6":"markdown","84b3edeb":"markdown"},"source":{"ba1fe130":"from numpy import random\nimport time\nimport math","313d1b1e":"def merge(arr, l, m, r):\n    n1 = m - l + 1\n    n2 = r - m\n\n    # cria os arrays\n    L = [0] * (n1)\n    R = [0] * (n2)\n\n    # copia os dados para os arrays tempor\u00e1rios\n    for i in range(0, n1):\n        L[i] = arr[l + i]\n\n    for j in range(0, n2):\n        R[j] = arr[m + 1 + j]\n\n    # Junta os arrays tempor\u00e1rios novamente a arr[l..r]\n    i = 0    # Index inicial para o primeiro subarray\n    j = 0    # Index inicial para o segundo subarray\n    k = l    # Index inicial para o subarray unido\n\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n\n    # Copia os elemantos restantes de L[], se houver\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n\n    # Copia os elemantos restantes de R[], se houver\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n\ndef mergeSort(arr, l, r):\n    if l < r:\n\n        m = l+(r-l)\/\/2\n\n        # Ordena as metades\n        mergeSort(arr, l, m)\n        mergeSort(arr, m+1, r)\n        merge(arr, l, m, r)","72908d91":"arr1 = random.randint(100000000, size=(100))\nn1 = len(arr1)\narr2 = random.randint(100000000, size=(1000))\nn2 = len(arr2)\narr3 = random.randint(100000000, size=(10000))\nn3 = len(arr3)\narr4 = random.randint(100000000, size=(100000))\nn4 = len(arr4)\narr5 = random.randint(100000000, size=(1000000))\nn5 = len(arr5)","adc89382":"inicia_tempo_arr1 = time.time_ns()\nmergeSort(arr1, 0, n1-1)\ntermina_tempo_arr1 = time.time_ns()\ntempo_arr1 = termina_tempo_arr1 - inicia_tempo_arr1\nprint(\"Tempo para ordenar arr1: {} nanosegundos.\".format(tempo_arr1))   \n\ninicia_tempo_arr2 = time.time_ns()\nmergeSort(arr2, 0, n2-1)\ntermina_tempo_arr2 = time.time_ns()\ntempo_arr2 = termina_tempo_arr2 - inicia_tempo_arr2\nprint(\"Tempo para ordenar arr2: {} nanosegundos.\".format(tempo_arr2))\n\ninicia_tempo_arr3 = time.time_ns()\nmergeSort(arr3, 0, n3-1)\ntermina_tempo_arr3 = time.time_ns()\ntempo_arr3 = termina_tempo_arr3 - inicia_tempo_arr3\nprint(\"Tempo para ordenar arr3: {} nanosegundos.\".format(tempo_arr3))\n\ninicia_tempo_arr4 = time.time_ns()\nmergeSort(arr4, 0, n4-1)\ntermina_tempo_arr4 = time.time_ns()\ntempo_arr4 = termina_tempo_arr4 - inicia_tempo_arr4\nprint(\"Tempo para ordenar arr4: {} nanosegundos.\".format(tempo_arr4))\n\ninicia_tempo_arr5 = time.time_ns()\nmergeSort(arr5, 0, n5-1)\ntermina_tempo_arr5 = time.time_ns()\ntempo_arr5 = termina_tempo_arr5 - inicia_tempo_arr5\nprint(\"Tempo para ordenar arr5: {} nanosegundos.\".format(tempo_arr5))","c66c9965":"print(tempo_arr1)\nprint(tempo_arr2)\nprint(tempo_arr3)\nprint(tempo_arr4)\nprint(tempo_arr5)\n\nprint(tempo_arr1\/tempo_arr2)\nprint(tempo_arr2\/tempo_arr3)\nprint(tempo_arr3\/tempo_arr4)\nprint(tempo_arr4\/tempo_arr5)","65513ed6":"def calc(n):\n    T = n*(math.log(n,10))\n    return T\n\nprint(calc(100))\nprint(calc(1000))\nprint(calc(10000))\nprint(calc(100000))\nprint(calc(1000000))\n\nprint(calc(100)\/calc(1000))\nprint(calc(1000)\/calc(10000))\nprint(calc(10000)\/calc(100000))\nprint(calc(100000)\/calc(1000000))","c7a7b30c":"Podemos encontrar equa\u00e7\u00e3o de recorr\u00eancia de um algoritmo do tipo *merge sort* considerando o seguinte:\n- n = comprimento do vetor ou da lista que ser\u00e1 ordenada;\n- a = n\u00famero de subproblems que resultam da divis\u00e3o. Como no merge sort sempre dividimos o vetor original em 2 partes, ent\u00e3o $a = 2$;\n- $1\/b*n$ \u00e9 o tamanho de cada subproblema $a$. Como no merge sort, $1\/2*n$ \u00e9 o tamanho de cada subproblema $a$, ent\u00e3o $b = 2$.\n\nLevando em conta o *Teorema do Mestre* padr\u00e3o, temos:\n\n$T(n)=aT(n\/b)+O(n^d)$\n\nPortanto, a equa\u00e7\u00e3o de recorr\u00eancia de um algoritmo do tipo *merge sort* \u00e9 a seguinte:\n\n$T(n)=2T(n\/2)+O(n)$\n\nPara sabermos qual caso do *Teorema do Mestre* podemos utilizar, precisamos analisar qual caso \u00e9 verdadeiro:\n- $a=b^d$; ou\n- $a<b^d$; ou\n- $a>b^d$\n\nNo caso do *merge sort* temos:\n- $a=b^d$ pois $2=2^1$\n\nSendo assim, a receita de complexidade de tempo a se utilizar \u00e9\n- $O(n^dlog(n))$, que para o merge sort \u00e9 $O(nlog(n))$\n\nVamos considerar os resultados das ordena\u00e7\u00f5es feitas acima:","411c5ec6":"## An\u00e1lise da complexidade de tempo do algoritmo","84b3edeb":"## Criando o algoritmo *merge sort*:"}}