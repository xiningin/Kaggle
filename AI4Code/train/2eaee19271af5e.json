{"cell_type":{"60ecf2aa":"code","7739c757":"code","3e6eb2e0":"code","4a64b58a":"code","5e2f4a37":"code","766af2fe":"code","86385d2f":"code","aa5671f2":"code","277922ba":"code","6a7841f3":"code","e5998e1a":"code","ad2d5c5f":"code","278bf654":"code","4100a9b7":"code","7b052079":"code","83d5cda1":"code","d7c40ef4":"code","bbb29a0d":"markdown","f8f4e9e5":"markdown","40ee44b8":"markdown","b45488bb":"markdown","b873f741":"markdown","4cbf4c97":"markdown"},"source":{"60ecf2aa":"import torch\nimport numpy as np","7739c757":"x = torch.empty(2,2,2)\nprint(x)","3e6eb2e0":"x = torch.rand(2,2)\nprint(x)","4a64b58a":"x = torch.zeros(2,2)\nprint(x)","5e2f4a37":"x = torch.ones(2,2)\nprint(x)","766af2fe":"# Set dtype for tensor\nx = torch.ones(2,2, dtype= torch.double)\nprint(x.dtype)\nprint(x.size())","86385d2f":"# Change a list into tensor\nx = torch.tensor([2.5,0.1])\nprint(x)","aa5671f2":"x = torch.rand(2,2)\ny = torch.rand(2,2)\nprint(x)\nprint(y)\nz = x+y\n# z = torch.add(x,y)\nprint(z)","277922ba":"# Inplace addition\nx = torch.rand(2,2)\ny = torch.rand(2,2)\nprint(x)\nprint(y)\ny.add_(x) # _ means that it will inplace value y\nprint(y)","6a7841f3":"# z = x-y\n# z = x*y\n# z = x\/y\n# z = torch.sub(x,y)\n# z = torch.mul(x,y)\n# z = torch.div(x,y)\n# y.mul_(x)","e5998e1a":"# Slicing\nx = torch.rand(5,3)\nprint(x)\nprint(x[1,:])\nprint(x[0,0].item()) # Retrieve just the value","ad2d5c5f":"x = torch.rand(4,4)\nprint(x)\ny = x.view(16)\nprint(y)\nprint(y.size())","278bf654":"x = torch.rand(4,4)\nprint(x)\ny = x.view(-1,8)\nprint(y)\nprint(y.size())","4100a9b7":"a = torch.ones(5)\nprint(a)\nprint(type(a))\n\n# Change tensor into numpy.ndarray\nb = a.numpy()\nprint(type(b))\n\n\n'''\nCautious !\nIf they run in CPU, that means they share same memory location, so if you change 'a' values, b would also change !\n'''","7b052079":"a = np.ones(5)\nprint(a)\n\nb = torch.from_numpy(a)\nprint(b)","83d5cda1":"if torch.cuda.is_available():\n    device = torch.device('cuda')\n    x = torch.ones(5, device=device) # Operation in GPU\n    y = torch.ones(5)\n    y = y.to(device) # Operation in GPU\n    z = x+y # Operation in GPU\n    #z.numpy() # Will get error, because only handle CPU tensor\n    # First convert it into CPU\n    z = z.to('cpu')","d7c40ef4":"# Allow to calculate gradient for this tensor in optimization step\nx = torch.ones(5, requires_grad = True)\nprint(x)","bbb29a0d":"## Set gradient","f8f4e9e5":"## Reshape Tensor","40ee44b8":"## Tensor Operation","b45488bb":"## Basic  Operation","b873f741":"## Checking GPU and Switching GPU to CPU (viceversa)","4cbf4c97":"## tensor to numpy.ndarray"}}