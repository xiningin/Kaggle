{"cell_type":{"0471bb08":"code","0052ca6a":"code","c5d4a456":"code","0bd280fc":"code","3afd741d":"code","ccb01b37":"code","84bac5e0":"code","101bb792":"code","ce49212f":"code","2c907b09":"code","a851119b":"code","b7708c4a":"code","40850174":"code","f55d075f":"code","10b75ba4":"markdown","47e5ce1d":"markdown","37c4d588":"markdown","52d4dce1":"markdown","1188bf6f":"markdown","c380ad28":"markdown","5b93e51c":"markdown","0b9e92a5":"markdown","f26d78ff":"markdown","a40f1c0e":"markdown","3751f22a":"markdown","12952792":"markdown"},"source":{"0471bb08":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sympy.ntheory.primetest import isprime\nfrom numba import jit\nfrom math  import sqrt","0052ca6a":"# Chargement des donn\u00e9es et ajout d'une colonne indiquant si le num\u00e9ro de la ville est un nombre premier\n# Dataframe utilis\u00e9 comme variable globale\ncities = pd.read_csv('..\/input\/traveling-santa-2018-prime-paths\/cities.csv')\ncities['IsPrime'] = cities['CityId'].apply(isprime)","c5d4a456":"cities.head()","0bd280fc":"def compute_score(path):\n    # path: list\n    path = path[ : len(path)-1] # Retirer le retour au dernier point (0)\n    cities_path = cities.reindex(path)\n    isPrime = cities_path.IsPrime.values\n    coord   = cities_path[['X', 'Y']].values\n    return compute_score_fast(coord, isPrime)","3afd741d":"@jit(nopython=True, parallel=True)\ndef compute_score_fast(coord, isPrime):\n    # coord: matrix float, isPrime vector boolean\n    score = 0\n    city_start_coord = coord[0]\n\n    for step in range(1,len(coord)):\n        city_end_coord = coord[step]\n        distance_step = distance(city_start_coord, city_end_coord)\n        if step%10 == 0 and  not isPrime[step-1]:\n            distance_step = 1.1 * distance_step\n\n        score = score + distance_step\n        \n        # La ville d'arriv\u00e9e est la nouvelle ville de d\u00e9part\n        city_start_coord = city_end_coord\n    \n    # Retour au p\u00f4le nord coord[0]\n    # (Pb si le retour au p\u00f4le nord se fait sur une \u00e9tape %10, a priori pas le cas avec la map donn\u00e9e )\n    score = score + distance(city_start_coord, coord[0])\n    \n    return score","ccb01b37":"@jit(nopython=True, parallel=True)\ndef distance(a, b):\n    return sqrt( pow(b[0] - a[0], 2) + pow(b[1] - a[1], 2))","84bac5e0":"path_init = pd.read_csv('..\/input\/lkh-solver\/submission.csv')['Path'].tolist()\nscore_init = compute_score(path_init)\nscore_init","101bb792":"path = path_init\npath = path[ : len(path)-1]\ncities_path = cities.reindex(path)\ncityId  = cities_path.CityId.values\nisPrime = cities_path.IsPrime.values\ncoord   = cities_path[['X', 'Y']].values\ncities_path.tail()","ce49212f":"# Permutation dans le cas t= s-1\nfor s in range(1,len(path)):\n    if s%10 == 0 and not isPrime[s-1]:\n\n        t = s-1\n        if isPrime[t-1]:\n            # Travail sur 4 points\n            d_10thstep_old = distance(coord[s-3], coord[s-2]) + distance(coord[s-2], coord[s-1]) + distance(coord[s-1], coord[s]) * 1.1\n            d_10thstep_new = distance(coord[s-3], coord[s-1]) + distance(coord[s-1], coord[s-2]) + distance(coord[s-2], coord[s])\n            \n            if d_10thstep_new < d_10thstep_old :\n                gain = d_10thstep_new - d_10thstep_old\n                print(s, \" gain: \", gain, \"  -- t = \", t)\n                path[t-1] , path[s-1]       = path[s-1] , path[t-1]\n                isPrime[t-1] , isPrime[s-1] = isPrime[s-1] , isPrime[t-1]\n                coord[t-1] , coord[s-1]     = coord[s-1] , coord[t-1]\nprint(\"Done\")\n","2c907b09":"# Permutation dans le cas t= s-1\n\nfor s in range(1,len(path)):\n    if s%10 == 0 and not isPrime[s-1]:\n\n        t = s+1\n        if isPrime[t-1]:\n            # Travail sur 4 points\n            d_10thstep_old = distance(coord[s-2], coord[s-1]) + distance(coord[s-1], coord[s])*1.1 + distance(coord[s], coord[s+1])\n            d_10thstep_new = distance(coord[s-2], coord[s]) + distance(coord[s], coord[s-1]) + distance(coord[s-1], coord[s+1])\n            \n            if d_10thstep_new < d_10thstep_old :\n                gain = d_10thstep_new - d_10thstep_old\n                print(s, \" gain: \", gain, \"  -- t = \", t)\n                path[t-1] , path[s-1]       = path[s-1] , path[t-1]\n                isPrime[t-1] , isPrime[s-1] = isPrime[s-1] , isPrime[t-1]\n                coord[t-1] , coord[s-1]     = coord[s-1] , coord[t-1]\n            \nprint(\"Done\")\n","a851119b":"## Cas g\u00e9n\u00e9ral","b7708c4a":"for s in range(1,len(path)):\n    if s%10 == 0 and not isPrime[s-1]:\n        # s: indice d'une ville travers\u00e9e au 10\u00e8me pas\n        # Intervalle de recherche d'un nombre premier: [path[s-1]-d, path[s-1]+d]\n        x0 = coord[s-1][0]\n        y0 = coord[s-1][1]\n        # \"Rayon\" de recherche : path[s-2] -> path[s-1] -> path[s] avec p\u00e9nalit\u00e9\n        d = distance(coord[s-2], coord[s-1]) + distance(coord[s-1], coord[s]) * 1.1\n        \n        # R\u00e9cup\u00e9ration des nombres premiers dans la cellule correspondante\n        cell = cities[(cities.X > x0-d ) & (cities.X < x0+d)]\n        cell = cell[(cell.Y > y0-d ) & (cell.Y < y0+d)]\n        cell = cell[cell.IsPrime]\n                \n        coord_primes_arround = cell[['X','Y']].values\n        cityId_primes_arround = cell.CityId.values\n        \n        for j in range(len(cell)):\n            d_10thstep_old = distance(coord[s-2], coord[s-1]) + distance(coord[s-1], coord[s]) * 1.1\n            # Pas de prise en compte d'optimisation dans le cas de multiples options\n\n            # index dans path de la ville nombre premier appartenant au voisinage : t-1\n            t = path.index(cityId_primes_arround[j]) + 1 # cf sch\u00e9ma\n            if (t%10 != 0) and (t!=s-1) and (t!=s+1) : \n                # On ne fait pas permutation si la ville cibl\u00e9e est d\u00e9j\u00e0 le point de d\u00e9part d'une 10\u00e8me \u00e9tape\n                # Les cas limites sont trait\u00e9s \u00e0 part\n                d_prime_old = distance(coord[t-2], coord[t-1]) + distance(coord[t-1], coord[t])\n\n                d_10thstep_new = distance(coord[s-2], coord[t-1]) + distance(coord[t-1], coord[s])\n                d_prime_new    = distance(coord[t-2], coord[s-1]) + distance(coord[s-1], coord[t])\n                \n                # Ajout de la p\u00e9nalit\u00e9 si t-2 n'est pas premier et t-1 %10\n                if  not isprime(cityId[t-2]) and (t-1)%10==0 :\n                    d_prime_old = distance(coord[t-2], coord[t-1])*1.1 + distance(coord[t-1], coord[t])\n                    d_prime_new = distance(coord[t-2], coord[s-1])*1.1 + distance(coord[s-1], coord[t])\n\n                d_old = d_10thstep_old + d_prime_old\n                d_new = d_10thstep_new + d_prime_new\n                \n                if d_new < d_old :\n                    gain = d_new - d_old\n                    print(s, \" gain: \", gain, \"  -- t = \", t)\n                    # Am\u00e9lioration choisir le min quand il y a plusieurs choix\n                    path[t-1] , path[s-1]       = path[s-1] , path[t-1]\n                    isPrime[t-1] , isPrime[s-1] = isPrime[s-1] , isPrime[t-1]\n                    coord[t-1] , coord[s-1]     = coord[s-1] , coord[t-1]\n                    \n                    \nprint(\"Done\")","40850174":"path.append(0)\nscore_final = compute_score(path)\nprint(score_final - score_init)","f55d075f":"pd.DataFrame({'Path':path}).to_csv('submission.csv', index=False)","10b75ba4":"![Prime%20path.jpg](attachment:Prime%20path.jpg)","47e5ce1d":"### Conditions aux limites\nCas o\u00f9 t=s-1 et o\u00f9 t=s+1","37c4d588":"## Voisinage de la ville de d\u00e9part de la %10\u00e8me \u00e9tape","52d4dce1":"## Chargement des donn\u00e9es ","1188bf6f":"D\u00e9finition d'une fonction de calcul de score avec optimisation de Numba\n`from numba import jit\n@jit(nopython=True, parallel = True)`\nNe fonctionne pas avec Pandas","c380ad28":"# Optimization for the prime twist\n\nAs a beginner as a data scientist, I have to face up the fact that I won't be able to rank high enough to get the bounty... I propose you a solution to optimize a given path taking into account the carrot rule. The basic idea is to check the surroundings of every 10th step to see if there's a prime city worthy to swap it with the city Santa is coming from. I did not take the time to translate all my comments in english, but here's a schema how it's done:","5b93e51c":"## Code pour proposer une solution","0b9e92a5":"## Fonction de calcul du score","f26d78ff":"Swap is done between p[s-1] and a prime city located in the path at p[t-1] when the green path is shorter than the blue path (with penalyt). We add a couple of conditions to do it and take into account two limits cases when t=s-1 and t=s+1 (in this two cases we will have to work on 4 points).\nCode isn't completely optimized, especially if there are several primes (except the 2 limits cases). And there's certainly room for improvement..","a40f1c0e":"Recherche de villes nombres premiers aux alentours et permutation s'il y a un gain de distance","3751f22a":"## Score de la solution initiale\nR\u00e9cup\u00e9ration d'un chemin d\u00e9j\u00e0 performant\n[jsaguiar\/lkh-solver](https:\/\/www.kaggle.com\/jsaguiar\/lkh-solver)","12952792":"https:\/\/docs.google.com\/drawings\/d\/1PxKsnE6rQopUf-CFOi1NpY7BLupDoFv3bm7NQ7-C5DQ\/edit?usp=sharing"}}