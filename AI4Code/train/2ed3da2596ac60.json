{"cell_type":{"25bca92a":"code","55e24fcf":"code","01a08c2d":"code","623cca90":"code","b2044965":"code","bd404c21":"code","93a3eac9":"code","d1ef1a89":"code","2255d010":"code","661b312e":"code","3ca06d90":"code","a373dd28":"code","68838c87":"code","419bdfe7":"code","a69bd940":"code","a24b8ee9":"code","bcd46a54":"code","e68f76da":"code","fbc61489":"code","ab378324":"code","01e5b38e":"code","9ec84dec":"code","4fc25851":"code","6af5c3d3":"code","25e3bc2f":"code","34c40fdb":"code","c60c39a8":"code","86931d6f":"code","ce23b83e":"code","4d152ffe":"code","793fdfe8":"markdown","548cc4b0":"markdown","416bdcdf":"markdown","2ed73401":"markdown","2483f15b":"markdown","2048edd7":"markdown","ba0d176c":"markdown","c37f418b":"markdown","53e71d66":"markdown","2c3e2f4e":"markdown","ccbf63b1":"markdown","3bdfe2c5":"markdown","34205ffd":"markdown","286f8b5c":"markdown","616903fe":"markdown","dd14c483":"markdown","c0b17ac1":"markdown","d98ca71e":"markdown","b39953d8":"markdown","f1efe0a9":"markdown","3ad4c585":"markdown","da77160d":"markdown","9857567a":"markdown","950efc21":"markdown","136434a3":"markdown","951c4b24":"markdown","5cdbafb7":"markdown","d8d27cee":"markdown","a47dac17":"markdown","315a26fe":"markdown","768f5a14":"markdown","3628f41b":"markdown","40dcc8c9":"markdown","43f292ac":"markdown","b9b2ec7e":"markdown","5bceae2c":"markdown","2778459a":"markdown","0e5e48d2":"markdown","4e872425":"markdown","bbf170b2":"markdown"},"source":{"25bca92a":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.linear_model import LinearRegression\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","55e24fcf":"df = pd.read_csv(\"..\/input\/house-prices-advanced-regression-techniques\/train.csv\")","01a08c2d":"df.head()","623cca90":"df.shape","b2044965":"df.info()","bd404c21":"df.describe().T","93a3eac9":"print(\"Missing value by column\")\nprint(\"-\"*20)\nprint(df.isna().sum())\nprint(\"-\"*20)\nprint(\"Total:\",df.isna().sum().sum())","d1ef1a89":"df = df.dropna(axis=1)\n\nprint(\"Missing value by column\")\nprint(\"-\"*20)\nprint(df.isna().sum())\nprint(\"-\"*20)\nprint(\"Total:\",df.isna().sum().sum())","2255d010":"X = df.drop([\"Id\",\"SalePrice\"], axis=1)\ny = df[\"SalePrice\"]","661b312e":"col_types = X.dtypes\nnumeric_col = col_types[col_types!='object'].index\n\nscaler = StandardScaler()\nX[numeric_col] = scaler.fit_transform(X[numeric_col])\nX.head()","3ca06d90":"X = pd.get_dummies(X)\nX.head()","a373dd28":"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)","68838c87":"model1 = LinearRegression()\nmodel1.fit(X_train, y_train)","419bdfe7":"def RMSE(target,pred):\n    return np.sqrt(mean_squared_error(target,pred))","a69bd940":"pred_train = model1.predict(X_train)\npred_test = model1.predict(X_test)\n\nprint(\"Train RMSE:\",RMSE(y_train, pred_train))\nprint(\"Test RMSE:\",RMSE(y_test, pred_test))","a24b8ee9":"correlation = df.corr()\ncorrelation_price = correlation[\"SalePrice\"]","bcd46a54":"plt.figure(figsize=(13,10))\nsns.heatmap(correlation, cmap=\"rainbow\")\nplt.title(\"Correlations Between Variables\", size=15)\nplt.show()","e68f76da":"positive_attributes = (correlation_price > 0.50)\nnegative_attributes = (correlation_price < -0.50)\nnumeric_col = list(correlation_price[positive_attributes | negative_attributes].index)\ncategory_col = [\"Utilities\",\"Heating\",\"KitchenQual\",\"SaleCondition\",\"LandSlope\"]\n\nimportant_cols = numeric_col + category_col\n\ntry:\n    important_cols.remove(\"Id\")\nexcept:\n    print(\"Column [Id] not in `important_cols`\")","fbc61489":"X = df[important_cols]\nX = X.drop(columns=\"SalePrice\",axis=1)\ny = df[\"SalePrice\"]\nnumeric_col.remove(\"SalePrice\")","ab378324":"scaler = StandardScaler()\nX[numeric_col] = scaler.fit_transform(X[numeric_col])\nX.head()","01e5b38e":"X = pd.get_dummies(X)\nX.head()","9ec84dec":"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)","4fc25851":"model2 = LinearRegression()\nmodel2.fit(X_train, y_train)","6af5c3d3":"pred_train = model2.predict(X_train)\npred_test = model2.predict(X_test)\n\nprint(\"Train RMSE:\",RMSE(y_train, pred_train))\nprint(\"Test RMSE:\",RMSE(y_test, pred_test))","25e3bc2f":"from  sklearn.impute import SimpleImputer\n\ntest = pd.read_csv(\"..\/input\/house-prices-advanced-regression-techniques\/test.csv\")","34c40fdb":"feature_cols = important_cols.copy()\nfeature_cols.remove(\"SalePrice\")\nX_final = test[feature_cols]\nX_final.info()","c60c39a8":"imp = SimpleImputer(missing_values=np.nan,strategy=\"most_frequent\")\nX_final[:] = imp.fit_transform(X_final)\nX_final.info()","86931d6f":"col_types = X_final.dtypes\nnumeric_col = col_types[col_types!='object'].index\n\nscaler = StandardScaler()\nX_final[numeric_col] = scaler.fit_transform(X_final[numeric_col])\nX_final.head()","ce23b83e":"X_final = pd.get_dummies(X_final)\nX_final = X_final.reindex(columns=X_train.columns,fill_value=0)\nX_final.head()","4d152ffe":"pred = model2.predict(X_final)\ntest['SalePrice'] = pred\nresult = test[[\"Id\",\"SalePrice\"]]\nprint(result)\n\nresult.to_csv(\"submission.csv\",index=False)","793fdfe8":"**Plot with heat map**","548cc4b0":"## Load and explore data","416bdcdf":"**Evaluation**","2ed73401":"## Reference\n- C\u00e1c ph\u01b0\u01a1ng ph\u00e1p tr\u00e1nh Overfitting - Tr\u1ea7n Trung Tr\u1ef1c - Viblo - $6^{th}$ Nov, 2020\n- Overfitting - V\u0169 H\u1eefu Ti\u1ec7p - Machine learning c\u01a1 b\u1ea3n - $4^{th}$ Mar, 2017\n- Overfitting - IBM Cloud Education - $3^{rd}$ Mar, 2021\n- Different methods for mitigating overfitting on Neural Networks - Pablo S\u00e1nchez - quantdare - $26^{th}$ May, 2021\n- House Price Prediction - Advanced regression techniques - Kaggle contest - GettingStarted Prediction Competition\n- House Price Prediction submission - Emre Arslan - Kaggle contest - $29^{th}$ Dec, 2021\n- Correlation Coefficient - The organic chemistry tutor - $25^{th}$ Jun, 2020 \n- Pearson correlation coefficient - Wikipedia - $27^{th}$ Dec, 2021","2483f15b":"**Normalize**","2048edd7":"**Evaluation**\n\nTo measure the performance of our model, I use the `root mean squared error (RMSE)` which is a common metric to evaluate the `linear regression` model.","ba0d176c":"# Feature selection using Pearson correlation coefficent","c37f418b":"**Create data**","53e71d66":"**Feature selection**\n\nIn the `Pearson correlation coeffecient`, I have said that we only choose the negative attribute and positive attribute respective to the target (`SalePrice`). Furthermore, the PCC only works for the `numeric` attribute, so we can select the `nominal` attribute with our prior knowledge.\n\nLook at the rightmost column of the heatmap, we can see that some typical selected attributes:\n- `OverallQual`\n- `YearBuilt`\n- `YearRemoteAdd`\n\nFor my knowledge, I also pick `nominal` attributes that is `Utilities`, `Heating`, etc. For instance, it is obvious that the utilities (e.g. electronics, gas, water) will also affact the price of that house. (This called domain knowledge)","2c3e2f4e":"## Using feature selection","ccbf63b1":"## Without using feature selection","3bdfe2c5":"**Split data**","34205ffd":"**One-hot encoding**","286f8b5c":"**Discuss**\n\nIt can be seen that after doing the feature selection, the result on the test set is much better. Instead of using $215$ features, we only select and pick out $31$ features. There are many different feature selection algorithm that we can apply to make our model being better, such as PCA, ICA, IDA, etc.","616903fe":"**Import libraries**","dd14c483":"# For submission","c0b17ac1":"## Detect overfitting\nIt can be seen that the key point to recognize the overfitting is the difference of error between training and testing\/validation set. With a naive idea, we can split into 2 dataset train and validation set. For instance, 80% train set and 20% validation set. (This is call `percentage split` strategy).\n\n![train-test-loss](https:\/\/i.imgur.com\/aiemPZC.png)\n\nFrom the image above, we can see that at the first stage, both train loss and validation loss are decrease. However, if we continue to train the model the validation loss will increase while the train loss is decrease.\n\nFurthermore, the `percentage split` strategy seem underestimate the model. In practice, we usually use `k-fold cross validation` to evaluate the overfitting. With `k-fold`, we split our dataset into `k` equal-size folds. And then we do the validation `k` times, each time we pick a fold to be test set, and the others to be the train set. Finally, we calculate the mean value of loss:\n\n![k-fold](https:\/\/i.imgur.com\/QzfsD8P.jpg)","d98ca71e":"# Housing price problem\n**Problem state**\n\nGiven a dataset contains many attributes about a house which is selling. The problem is to predict the price of that house.\n- Input: House's attributes\n- Output: House's price\n\n**Dataset**\n\nI use the dataset for contest [House prices - Advanced regression techniques](https:\/\/www.kaggle.com\/c\/house-prices-advanced-regression-techniques\/data).\n","b39953d8":"While using `linear regression` model, we can use `Pearson correlation coefficent` to do the feature selection. The `PCC` is a measure of **linear correlation** between **two sets of data**. That is the ratio between the `covariance` and `product of their standard deviation`:\n$$\\rho_{X,Y}=\\frac{cov(X,Y)}{\\sigma_X\\sigma_Y}$$\nIt means that, if our two sets:\n- Form an upward line, then $\\rho=1$\n- Form an downward line, then $\\rho=-1$\n- Scatter data randomly, then $\\rho=0$\n\nTo understand it clearly, look at the image below:\n\n![pearson-example](https:\/\/i.imgur.com\/Ga36VPp.png)\n\nThe pearson correlation only consider about the `linear` property. If the two sets form a strange shape, PCC also equal $0$:\n\n![pearson-strange](https:\/\/i.imgur.com\/uWZjK5i.png)\n\n> Note: The PCC only works for `numeric` type\n\nWe can see that the pearson correlation help us on selecting features while using linear regression model. We only select attributes that have the correlation with our target 50% (in term of both negative and positive).","f1efe0a9":"## How to reduce overfitting\n- Enlarge the training set. Some examples:\n    - Collect more data (but not practical)\n    - Data augumentation: Widely use with image problem (shift, scale, etc)\n    - Using GAN model to generate image\n- Using regularization to penalize the weight (weight decay)\n- Using drop-out (mostly in deep learning)\n- Using prune tree (in decision tree)\n- Using VC dimension\n- Early stopping\n- Doing feature selection\n- Using ensemble method\n\n**In this document, I use `linear regression` model and reduce overfitting with `feature selection`**\n\nUsing feature selection, we can reduce the complexity of our model (which also means dimensions)","3ad4c585":"**Train model**","da77160d":"## What is overfitting\nAs I already mentioned above, overfitting is a situation that your model work very well on the training data but not for the other (unseen) data. The reason why this happened is that your model is too complex which make it learn the \"noise\" (outliers) instead of being general. Looking at the example below, we can see that the model work perfectly on the training sample (red), but badly on the test\/valid samples. In this example, I used a linear regression model with $degree=16$:\n$$y=\\sum_{i=0}^{16}(w_i.x^i)$$\n\n![overfit-example](https:\/\/i.imgur.com\/bx589P7.png)","9857567a":"**Train model**","950efc21":"**Discussion**\n\nFrom the result, we can see that the overfitting problem happened since the `MSE` on:\n- `Training set`: is quite acceptable \n- `Test set`: is considerably huge\n\nThis is a evidence to show that with $215$ features, the `linear regression` model is overfitting.","136434a3":"**Load data**","951c4b24":"**One-hot encoding**\n\nIn our data attributes, there are both `numeric` and `nomial` type. To use the `linear regression`, all the data must be `numeric`, so I use the one-hot encoding to convert all the `nominal` into `numeric`.","5cdbafb7":"## Abstraction\nOverfitting is one of a common problem we need to deal with when working on a machine learning model. Whenever it is happened, your model works **perfectly on the training data**, but **badly on the real situation**. As it can be seen that, overfitting is an essential problem that we must know how to detect and avoid it.","d8d27cee":"**Drop missing column**\n\nBecause the data contains many missing column, I must drop the `NaN` value in order to use `linear regression`. We have two options here:\n- Drop the column that have `NaN`\n- Drop the row that have `NaN`\n\nIf we look in detail, we can see that we cannot drop by row since our data will be empty. So, I choose to drop the column.","a47dac17":"**Import imputer and load data**","315a26fe":"**Normalize**\n\nAs you may already know that we need to normalize the data in order to mantain their magnitude between each other. In normalization, we also have many choices, two common normalizations are:\n- `Z-score`\n- `Min-max`\n\nIn this project, I use `Z-score` normalization in order to handle the outliers better.","768f5a14":"**Create data**","3628f41b":"**Calculate pearson correlation**","40dcc8c9":"**Split data**\n\nAs mentioned above, I will split the data into two sets to detect the overfitting:\n- Train set (80%)\n- Test set (20%)","43f292ac":"**Normalize**","b9b2ec7e":"**Data analysis**","5bceae2c":"**One-hot encoding and re-index with model**","2778459a":"**Impute missing data**","0e5e48d2":"**Take feature selection**","4e872425":"**Predictions**","bbf170b2":"**Number of missing cell**\n"}}