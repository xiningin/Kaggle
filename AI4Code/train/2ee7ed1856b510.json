{"cell_type":{"c921319d":"code","63c13cd7":"code","22dca414":"code","3bf61168":"code","c5d6f9d1":"code","dea5623c":"code","257d02f7":"code","77d4f440":"code","6d97bafc":"code","706a2c69":"code","9bee3837":"markdown","4bdb23e7":"markdown","eb4fe62f":"markdown","1351ddeb":"markdown","4559455f":"markdown","bc17cded":"markdown","d8fc6fe2":"markdown","075a73cf":"markdown","0c271a97":"markdown","3f385828":"markdown","45a3f6b6":"markdown"},"source":{"c921319d":"import os\nimport gc\nimport pandas as pd\nimport numpy as np\n\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn import metrics, preprocessing\nfrom sklearn.preprocessing import OneHotEncoder\n\nimport tensorflow as tf\nfrom keras.layers import Dense, Input\nfrom collections import Counter\nfrom keras.layers import BatchNormalization\nfrom keras.optimizers import Adam\nfrom keras.models import Model, load_model\nfrom keras import callbacks\nfrom keras import backend as K\nfrom keras.layers import Dropout\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","63c13cd7":"def submit(predictions):\n    submit = pd.read_csv('..\/input\/sample_submission.csv')\n    submit[\"target\"] = predictions\n    submit.to_csv(\"submission.csv\", index=False)\n\ndef fallback_auc(y_true, y_pred):\n    try:\n        return metrics.roc_auc_score(y_true, y_pred)\n    except:\n        return 0.5\n\ndef auc(y_true, y_pred):\n    return tf.py_function(fallback_auc, (y_true, y_pred), tf.double)","22dca414":"df_tr = pd.read_csv(\"..\/input\/train.csv\")\ndf_test = pd.read_csv(\"..\/input\/test.csv\")","3bf61168":"NFOLDS = 3\nRANDOM_STATE = 42\nnumeric = [c for c in df_tr.columns if c not in ['id', 'target', 'wheezy-copper-turtle-magic']]","c5d6f9d1":"len_train = df_tr.shape[0]\ndf_test['target'] = -1\ndata = pd.concat([df_tr, df_test])\ndata['magic_count'] = data.groupby(['wheezy-copper-turtle-magic'])['id'].transform('count')\ndata = pd.concat([data, pd.get_dummies(data['wheezy-copper-turtle-magic'])], axis=1, sort=False)\n\ndf_tr = data[:len_train]\ndf_test = data[len_train:]","dea5623c":"folds = StratifiedKFold(n_splits=NFOLDS, shuffle=True, random_state=RANDOM_STATE)","257d02f7":"gc.collect()","77d4f440":"y = df_tr.target\nids = df_tr.id.values\ntrain = df_tr.drop(['id', 'target'], axis=1)\ntest_ids = df_test.id.values\ntest = df_test[train.columns]\n\noof_preds = np.zeros((len(train)))\ntest_preds = np.zeros((len(test)))\n\nscl = preprocessing.StandardScaler()\nscl.fit(pd.concat([train, test]))\ntrain = scl.transform(train)\ntest = scl.transform(test)","6d97bafc":"for fold_, (trn_, val_) in enumerate(folds.split(y, y)):\n    print(\"Current Fold: {}\".format(fold_))\n    trn_x, trn_y = train[trn_, :], y.iloc[trn_]\n    val_x, val_y = train[val_, :], y.iloc[val_]\n\n    inp = Input(shape=(trn_x.shape[1],))\n    x = Dense(4096, activation=\"relu\")(inp)\n    x = BatchNormalization()(x)\n    x = Dropout(0.1)(x)\n    x = Dense(2048, activation=\"relu\")(x)\n    x = BatchNormalization()(x)\n    x = Dropout(0.1)(x)\n    x = Dense(1024, activation=\"relu\")(x)\n    x = BatchNormalization()(x)\n    x = Dropout(0.1)(x)\n    x = Dense(512, activation=\"relu\")(x)\n    x = BatchNormalization()(x)\n    x = Dropout(0.1)(x)\n    x = Dense(256, activation=\"relu\")(x)\n    x = BatchNormalization()(x)\n    x = Dropout(0.4)(x)\n    x = Dense(64, activation=\"relu\")(x)\n    x = BatchNormalization()(x)\n    x = Dropout(0.1)(x)\n    out = Dense(1, activation=\"sigmoid\")(x)\n    clf = Model(inputs=inp, outputs=out)\n    clf.compile(loss='binary_crossentropy', optimizer='adamax', metrics=[auc])\n\n    es = callbacks.EarlyStopping(monitor='val_auc', min_delta=0.001, patience=10,\n                                 verbose=1, mode='max', baseline=None, restore_best_weights=True)\n\n    rlr = callbacks.ReduceLROnPlateau(monitor='val_auc', factor=0.5,\n                                      patience=3, min_lr=1e-4, mode='max', verbose=1)\n\n    clf.fit(trn_x, trn_y, validation_data=(val_x, val_y), callbacks=[es, rlr], epochs=40, batch_size=4096)\n    \n    val_preds = clf.predict(val_x)\n    test_fold_preds = clf.predict(test)\n    \n    print(\"AUC = {}\".format(metrics.roc_auc_score(val_y, val_preds)))\n    oof_preds[val_] = val_preds.ravel()\n    test_preds += test_fold_preds.ravel() \/ NFOLDS\n    \n    K.clear_session()\n    gc.collect()","706a2c69":"submit(test_preds)","9bee3837":"### One-hot encodings and basic statistic based on categorical column 'wheezy-copper-turtle-magic'","4bdb23e7":"### We all waited this moment! Training","eb4fe62f":"### Load data","1351ddeb":"## Thanks @abhishek for his kernel https:\/\/www.kaggle.com\/abhishek\/beating-the-benchmark-neural-network\n## Due to 'wheezy-copper-turtle-magic' is categorical feature, I decided to add one-hot encoding. ","4559455f":"### Decalare variables","bc17cded":"### Make submition","d8fc6fe2":"### Preparing data for Neural Network","075a73cf":"#### Clear garbage","0c271a97":"### If you found it usefull, upvote please :) ","3f385828":"### Some functions to make life easier","45a3f6b6":"### Let's make KFold validation with 3 folds"}}