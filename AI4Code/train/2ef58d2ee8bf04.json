{"cell_type":{"c33bc811":"code","56d11d94":"code","08c67809":"code","d8c19b22":"code","cc05debe":"code","cb4531ea":"code","e7890c69":"code","ec5d9e8e":"code","3d3c8b0b":"code","372e1704":"code","11a71c02":"code","1e61c4d1":"code","1fd2bbb2":"markdown","f79431cf":"markdown","567775b2":"markdown","21b69ef9":"markdown","1bd0849c":"markdown","7a42dced":"markdown","78823bac":"markdown","ab3758e9":"markdown","c7fbbd63":"markdown","234cde5f":"markdown"},"source":{"c33bc811":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","56d11d94":"df_battles= pd.read_csv(\"..\/input\/battles.csv\")\ndf_battles.head()","08c67809":"battles = [tuple(row) for row in (df_battles[[\"First_pokemon\", \"Second_pokemon\"]].values)]\nlen(battles)","d8c19b22":"len(battles) - len(set(battles))","cc05debe":"grouped = df_battles.groupby([\"First_pokemon\", \"Second_pokemon\"])\nlen(battles) - len(grouped.groups)","cb4531ea":"counters = grouped.count()\nduplicates = list(counters[counters.Winner == 2].index)\ntriplicates = list(counters[counters.Winner == 3].index)\nquadruplicates_or_more = list(counters[counters.Winner > 3].index)\nlen(duplicates), len(triplicates), len(quadruplicates_or_more)","e7890c69":"def battles(p1, p2):\n    return df_battles[(df_battles[\"First_pokemon\"] == p1) & (df_battles[\"Second_pokemon\"] == p2)]\n\nduplicates_winners = [\n    len(set(battles(p1, p2)[\"Winner\"].values)) for p1, p2 in list(counters[counters.Winner > 1].index)\n]\n\nduplicates_winners[0:10]","ec5d9e8e":"set(duplicates_winners)","3d3c8b0b":"normal = [tuple(row) for row in (df_battles[[\"First_pokemon\", \"Second_pokemon\"]].values)]\nrevers = [tuple(row) for row in (df_battles[[\"Second_pokemon\", \"First_pokemon\"]].values)]\nduplications = list(set(normal).intersection(set(revers)))\nlen(duplications)","372e1704":"def both_battles(p1, p2):\n    b1 = df_battles[(df_battles.First_pokemon == p1) & (df_battles.Second_pokemon == p2)]\n    b2 = df_battles[(df_battles.First_pokemon == p2) & (df_battles.Second_pokemon == p1)] \n    return b1.Winner.values[0] == b2.Winner.values[0]\n\nmissmatch = [(x, y) for (x, y) in duplications if both_battles(x,y)]\nlen(missmatch)","11a71c02":"df_pokemon = pd.read_csv(\"..\/input\/pokemon.csv\")\nf_pokemon = df_pokemon.rename(lambda x: \"f_%s\" % x, axis=\"columns\")\ns_pokemon = df_pokemon.rename(lambda x: \"s_%s\" % x, axis=\"columns\")\nmissmatch_battles = pd.concat([battles(p1,p2) for p1,p2 in missmatch])\nmissmatch_battles = missmatch_battles.merge(f_pokemon, left_on=\"First_pokemon\", right_on=\"f_#\")\nmissmatch_battles = missmatch_battles.merge(s_pokemon, left_on=\"Second_pokemon\", right_on=\"s_#\")\nmissmatch_battles","1e61c4d1":"220 \/ 3644 * 100","1fd2bbb2":"comprobamos que si existen duplicados","f79431cf":"### A por el 100%!","567775b2":"## Conclusiones:\n\n * Todas las batallas deber\u00edan ser predecibles, pero algunas estan sobrerrepresentadas y deberiamos eliminarlas antes de entrenar a los modelos.\n * Un **6.03%** de las batallas cruzadas\u00a0no pueden ser explicadas sin el orden de las columnas.","21b69ef9":"## Batallas duplicadas\n\nAntes de comprobar resultados diferentes para batallas en diferente orden vamos a comprobar que efectivamente no existen resultados diferentes en batallas con el mismo orden.","1bd0849c":"et voila! **220** missmatch!","7a42dced":"# \u00bfPor qu\u00e9?\n\nComo dice el enunciado:\n\n**Importante: El pokemon en la primera columna ataca primero.**\n\nPero en este kernel vamos a analizar como de importante es esto.","78823bac":"tenemos 1952 duplicados, comprobemos que no tienen resultados diferentes","ab3758e9":"## Batallas invertidas\nVamos a obtener las batallas que se encuentran en orden inverso.","c7fbbd63":"Genial! en todos los duplicados tienen un unico resultado en los winners, aun asi quizas estaria bien eliminarlos pues estan sobrerrepresentados en el dataset original.\n\nAdemas nuestro train-set y validation-set pueden tener colisiones y falsear nuestro score real","234cde5f":"Solo nos queda calcular cuantos resultados diferentes hay para las misma batallas"}}