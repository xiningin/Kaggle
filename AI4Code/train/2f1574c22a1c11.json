{"cell_type":{"8e55d9ce":"code","4f996786":"code","2fd121f2":"code","ebd98c42":"code","0161a06e":"code","43c8c082":"code","88be180c":"code","3faa0586":"code","af9cdd3a":"code","5e0a9601":"code","c84f52bd":"code","d9bc90ed":"code","948e629f":"code","364859b1":"code","9efa137d":"code","c99eeec0":"code","ba364f5d":"code","ff9696c3":"code","9281a27c":"code","b62f0f98":"code","0a08b926":"code","0fbe39ca":"code","440fef3e":"code","2ee396cc":"code","23c44f3e":"code","77981eb7":"code","01b33615":"code","d87fa7f1":"code","f24b40ef":"code","d0038230":"code","c1d1b4c4":"code","a3fc4394":"code","780e92c8":"code","853b739f":"code","edb4cb2d":"code","0a557e9f":"code","5e790104":"code","d5de96dc":"code","e6a4fc6d":"code","c9bfce27":"code","a11dc0ca":"code","30eca2e3":"code","0694bc28":"code","40aea941":"code","1451d675":"code","c7d5d780":"code","358d6ed7":"code","365a9470":"code","07edd554":"code","242b1900":"code","09843934":"code","ea250cf8":"code","dcbfd0a5":"code","e796318e":"code","8dc26386":"code","0a11277f":"code","79382e8f":"code","51981baa":"code","9e981df5":"code","723cc421":"code","c510db0c":"code","02e2bbd5":"code","298dfa68":"code","0a817843":"code","28fe8fca":"code","be067f68":"code","34595f1e":"code","bb2e8d89":"code","283c86b5":"code","9af6947a":"code","3bb0f621":"code","1982d5f1":"markdown","1e15423e":"markdown","2873a5a4":"markdown","c4d23cd3":"markdown","b7bca2b3":"markdown","e9a46756":"markdown","92623697":"markdown","fa17d459":"markdown","7501dadf":"markdown","86b10077":"markdown","64ce9fc1":"markdown","3611f164":"markdown"},"source":{"8e55d9ce":"%matplotlib inline\nimport json\nimport os\nimport pandas as pd\nimport seaborn as sns\nimport statsmodels.formula.api as smf\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn import metrics\nfrom sklearn.model_selection  import train_test_split\nimport numpy as np\nimport gc\nfrom scipy.stats import norm # for scientific Computing\nfrom scipy import stats, integrate\nimport matplotlib.pyplot as plt","4f996786":"#load the dataset\nASHRAE_train = pd.read_csv('\/kaggle\/input\/ashrae-energy-prediction\/train.csv')\nASHRAE_test = pd.read_csv('\/kaggle\/input\/ashrae-energy-prediction\/test.csv')\nweather_train = pd.read_csv('\/kaggle\/input\/ashrae-energy-prediction\/weather_train.csv')\nweather_test = pd.read_csv('\/kaggle\/input\/ashrae-energy-prediction\/weather_test.csv')\nbuilding_meta = pd.read_csv('\/kaggle\/input\/ashrae-energy-prediction\/building_metadata.csv')","2fd121f2":"ASHRAE_train.info()","ebd98c42":"weather_train.info()","0161a06e":"## Function to reduce the DF size\ndef reduce_memory_usage(df, verbose=True):\n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    start_mem = df.memory_usage().sum() \/ 1024**2    \n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)    \n    end_mem = df.memory_usage().sum() \/ 1024**2\n    if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n    return df","43c8c082":"reduce_memory_usage(building_meta)\nreduce_memory_usage(weather_train)\nreduce_memory_usage(ASHRAE_train)\n\nreduce_memory_usage(weather_test)\nreduce_memory_usage(ASHRAE_test)","88be180c":"ASHRAE_train.describe()","3faa0586":"building_meta.describe()","af9cdd3a":"print('number of categories used on \"primary_use\": ',building_meta['primary_use'].nunique())\nprint('list of categories used on \"primary_use\" : ')\nprint(building_meta['primary_use'].unique())","5e0a9601":"#print train data columns\nprint('Columns of the building dataset is', building_meta.columns)\nprint('Columns of the weather_train dataset is', weather_train.columns)\nprint('Columns of the train dataset is', ASHRAE_train.columns)","c84f52bd":"building_meta.isnull().sum()","d9bc90ed":"fig, ax = plt.subplots(figsize=(15,7))\nsns.heatmap(building_meta.isnull(), yticklabels=False, cmap='viridis')","948e629f":"print(\"Percentage of missing values in the building_meta dataset\")\nbuilding_meta.isna().sum()\/len(building_meta)*100","364859b1":"print(\"Percentage of missing values in the train dataset\")\nASHRAE_train.isna().sum()\/len(ASHRAE_train)*100","9efa137d":"print(\"Percentage of missing values in the weather_train dataset\")\nweather_train.isna().sum()\/len(weather_train)*100","c99eeec0":"#merging tables\nBuildingTrain = building_meta.merge(ASHRAE_train, left_on='building_id', right_on='building_id' , how='left')\nBuildingTest = building_meta.merge(ASHRAE_test, left_on='building_id', right_on='building_id' , how='left')\nBuildingTrain.shape, BuildingTest.shape","ba364f5d":"BuildingTrain.head()","ff9696c3":"del ASHRAE_test\ndel ASHRAE_train\ndel building_meta\ngc.collect()","9281a27c":"BTW_train=BuildingTrain.merge(weather_train,left_on=['site_id','timestamp'],right_on=['site_id','timestamp'],how='left')\nBTW_test = BuildingTest.merge(weather_test,left_on=['site_id','timestamp'],right_on=['site_id','timestamp'],how='left')\nBTW_train.shape","b62f0f98":"del BuildingTest\ndel BuildingTrain\ndel weather_test\ndel weather_train\ngc.collect()","0a08b926":"BTW_train.columns","0fbe39ca":"BTW_train.head()","440fef3e":"print(\"Percentage of missing values in the BTW_train dataset\")\nBTW_train.isna().sum()\/len(BTW_train)*100","2ee396cc":"BTW_train.hist('sea_level_pressure')\nBTW_train[['sea_level_pressure']].describe()","23c44f3e":"BTW_train.hist('cloud_coverage')\nBTW_train[['cloud_coverage']].describe()","77981eb7":"BTW_train.hist('precip_depth_1_hr')\nBTW_train[['precip_depth_1_hr']].describe()","01b33615":"def plot_dist(df, column):\n    plt.figure(figsize=(18,12))\n    ax = sns.distplot(df[column].dropna())\n    ax.set_title(column+\" Distribution\", fontsize=16)\n    plt.xlabel(column, fontsize=12)\n    #plt.ylabel(\"distribution\", fontsize=12)\n    plt.show()","d87fa7f1":"BTW_train[['wind_speed']].describe()\nplot_dist(BTW_train,'wind_speed')","f24b40ef":"BTW_train[['air_temperature']].describe()\nplot_dist(BTW_train,'air_temperature')","d0038230":"plot_dist(BTW_train, \"sea_level_pressure\")","c1d1b4c4":"sns.boxplot(x = 'meter', y = 'meter_reading', data = BTW_train)","a3fc4394":"def outlier_function(df, col_name):\n    ''' this function detects first and third quartile and interquartile range for a given column of a dataframe\n    then calculates upper and lower limits to determine outliers conservatively\n    returns the number of lower and uper limit and number of outliers respectively\n    '''\n    first_quartile = np.percentile(\n        np.array(df[col_name].tolist()), 25)\n    third_quartile = np.percentile(\n        np.array(df[col_name].tolist()), 75)\n    IQR = third_quartile - first_quartile\n                      \n    upper_limit = third_quartile+(3*IQR)\n    lower_limit = first_quartile-(3*IQR)\n    outlier_count = 0\n                      \n    for value in df[col_name].tolist():\n        if (value < lower_limit) | (value > upper_limit):\n            outlier_count +=1\n    return lower_limit, upper_limit, outlier_count","780e92c8":"print(\"{} percent of {} are outliers.\"\n      .format((\n              (100 * outlier_function(BTW_train, 'meter_reading')[2])\n               \/ len(BTW_train['meter_reading'])),\n              'meter_reading'))","853b739f":"# Distribution of the meter reading in meters without zeros\nplt.figure(figsize=(12,10))\n\n#list of different meters\nmeters = sorted(BTW_train['meter'].unique().tolist()) # [0, 1, 2, 3]\n\n# plot meter_reading distribution for each meter\nfor meter_type in meters:\n    subset = BTW_train[BTW_train['meter'] == meter_type]\n    sns.kdeplot(np.log1p(subset[\"meter_reading\"]), \n                label=meter_type, linewidth=2)\n\n# set title, legends and labels\nplt.ylabel(\"Density\")\nplt.xlabel(\"Meter_reading\")\nplt.legend(['electricity', 'chilled water', 'steam', 'hot water'])\nplt.title(\"Density of Logartihm(Meter Reading + 1) Among Different Meters\", size=14)","edb4cb2d":"BTW_train.head()","0a557e9f":"BTW_train.columns","5e790104":"corrmat=BTW_train.corr()\nfig,ax=plt.subplots(figsize=(12,10))\nsns.heatmap(corrmat,annot=True,annot_kws={'size': 12})","d5de96dc":"BTW_train = BTW_train.drop(columns=['year_built', 'floor_count', 'wind_direction', 'dew_temperature'])\nBTW_test = BTW_test.drop(columns=['year_built', 'floor_count','wind_direction', 'dew_temperature'])","e6a4fc6d":"BTW_train ['timestamp'] =  pd.to_datetime(BTW_train['timestamp'])\nBTW_test ['timestamp'] =  pd.to_datetime(BTW_test['timestamp'])\nBTW_train['Month']=pd.DatetimeIndex(BTW_train['timestamp']).month\nBTW_test['Month']=pd.DatetimeIndex(BTW_test['timestamp']).month\nBTW_train['Day']=pd.DatetimeIndex(BTW_train['timestamp']).day\nBTW_test['Day']=pd.DatetimeIndex(BTW_test['timestamp']).day","c9bfce27":"BTW_train= BTW_train.groupby(['meter',BTW_train['building_id'],'primary_use',BTW_train['Month'], BTW_train['Day']]).agg({'meter_reading':'sum', 'air_temperature': 'mean', 'wind_speed': 'mean', 'precip_depth_1_hr': 'mean', 'cloud_coverage': 'mean', 'square_feet': 'mean'})\nBTW_test_1= BTW_test.groupby(['row_id','meter',BTW_test['building_id'],'primary_use',BTW_test['Month'], BTW_test['Day']]).agg({ 'air_temperature': 'mean', 'wind_speed': 'mean', 'precip_depth_1_hr': 'mean', 'cloud_coverage': 'mean', 'square_feet': 'mean'})","a11dc0ca":"BTW_train.isna().sum()","30eca2e3":"BTW_train = BTW_train.reset_index()","0694bc28":"BTW_train.describe()","40aea941":"BTW_train['wind_speed'] = BTW_train['wind_speed'].astype('float32')\nBTW_train['air_temperature'] = BTW_train['air_temperature'].astype('float32')\nBTW_train['precip_depth_1_hr'] = BTW_train['precip_depth_1_hr'].astype('float32')\nBTW_train['cloud_coverage'] = BTW_train['cloud_coverage'].astype('float32')\nBTW_test['wind_speed'] = BTW_test['wind_speed'].astype('float32')\nBTW_test['air_temperature'] = BTW_test['air_temperature'].astype('float32')\nBTW_test['precip_depth_1_hr'] = BTW_test['precip_depth_1_hr'].astype('float32')\nBTW_test['cloud_coverage'] = BTW_test['cloud_coverage'].astype('float32')","1451d675":"BTW_train['precip_depth_1_hr'].fillna(method='ffill', inplace = True)\nBTW_train['cloud_coverage'].fillna(method='bfill', inplace = True)\n\nBTW_train['wind_speed'].fillna(BTW_train['wind_speed'].mean(), inplace=True)\nBTW_train['air_temperature'].fillna(BTW_train['air_temperature'].mean(), inplace=True)\n\nBTW_test['precip_depth_1_hr'].fillna(method='ffill', inplace = True)\nBTW_test['cloud_coverage'].fillna(method='bfill', inplace = True)\nBTW_test['precip_depth_1_hr'].fillna(BTW_test['precip_depth_1_hr'].mean(), inplace=True)\nBTW_test['cloud_coverage'].fillna(BTW_test['cloud_coverage'].mean(), inplace=True)\n\nBTW_test['wind_speed'].fillna(BTW_test['wind_speed'].mean(), inplace=True)\nBTW_test['air_temperature'].fillna(BTW_test['air_temperature'].mean(), inplace=True)\nBTW_train.isnull().sum()","c7d5d780":"BTW_train.shape,BTW_train.dtypes","358d6ed7":"#visualization of meter reading for a specific building_id\n# by Day\nbuilding_id = 213\nplt.figure(figsize=(14, 8))\nax = sns.lineplot(x=\"Day\", y=\"meter_reading\", hue=\"meter\", data=BTW_train[BTW_train['building_id'] == building_id])\nplt.title('Meter readings from building_id {}'.format(building_id))\nplt.show()","365a9470":"#visualization of meter reading for a specific building_id\n# by Month\nbuilding_id = 213\nplt.figure(figsize=(14, 8))\nax = sns.lineplot(x=\"Month\", y=\"meter_reading\", hue=\"meter\", data=BTW_train[BTW_train['building_id'] == building_id])\nplt.title('Meter readings from building_id {}'.format(building_id))\nplt.show()","07edd554":"BTW_train.primary_use.unique()","242b1900":"BTW_train.head()","09843934":"BTW_encoded = BTW_train[:]\nBTW_test_encoded = BTW_test[:]","ea250cf8":"# label encoding \nfrom sklearn.preprocessing import LabelEncoder\n\nle = LabelEncoder()\nBTW_encoded[\"primary_use\"] = le.fit_transform(BTW_encoded[\"primary_use\"])\nBTW_test_encoded[\"primary_use\"] = le.fit_transform(BTW_test_encoded[\"primary_use\"])","dcbfd0a5":"BTW_encoded.columns","e796318e":"X = BTW_encoded[['meter', 'building_id', 'primary_use', 'Month', 'Day','air_temperature', 'wind_speed', 'precip_depth_1_hr', 'cloud_coverage',\n       'square_feet']]\ny = BTW_encoded['meter_reading']","8dc26386":"x_train, x_val, y_train, y_val = train_test_split(X,y, test_size = 0.2, random_state= 45)","0a11277f":"from sklearn import preprocessing\nfrom keras import backend as K\nfrom keras.callbacks import ModelCheckpoint, EarlyStopping\nfrom keras.layers import Dense, LSTM, GRU, Dropout, BatchNormalization\nfrom keras.models import Sequential\nfrom keras.optimizers import RMSprop,Adam\nfrom keras import regularizers","79382e8f":"def root_mean_squared_error(y_true, y_pred):\n  return K.sqrt(K.mean(K.square(y_pred - y_true)))","51981baa":"def make_model(input_dim=10,metrics=root_mean_squared_error,loss='mse', optimizer=\"rmsprop\",drop_rate=0.5):\n\n  model = Sequential()\n  model.add(LSTM(128,return_sequences=True, input_shape=(None,input_dim)))\n  model.add(Dropout(drop_rate))\n  model.add(BatchNormalization())\n  model.add(LSTM(128,return_sequences=False))\n  model.add(BatchNormalization())\n  model.add(Dropout(drop_rate))\n  model.add(Dense(1))\n  model.compile(optimizer=optimizer, loss=loss, metrics=[metrics])\n  \n  return model","9e981df5":"def run_model(model,x_train,y_train,epochs=50,batch_size=500,verbose=1,validation_data=(x_val,y_val),callbacks =None):\n  x_train = x_train.values[:]\n  x_train= x_train.reshape((x_train.shape[0],1,x_train.shape[-1]))\n  y_train = np.log1p(y_train)\n  if validation_data != None:\n    x_val = validation_data[0].values[:]\n    x_val = x_val.reshape((x_val.shape[0],1,x_val.shape[-1]))\n    y_val = np.log1p(validation_data[-1])\n      \n  return model.fit(x_train,y_train,epochs=epochs,batch_size=batch_size,verbose=verbose,validation_data=(x_val,y_val),callbacks=callbacks)","723cc421":"#best_model_file = \"my_model.h5\"\n#mc = ModelCheckpoint(best_model_file, monitor='val_loss', mode='auto',verbose=True, save_best_only=True)\nes = EarlyStopping(monitor='val_root_mean_squared_error', min_delta=0.0001, patience=5, verbose=True, mode='auto')","c510db0c":"model = make_model(input_dim=x_train.shape[-1],drop_rate=0.2)","02e2bbd5":"model.summary()","298dfa68":"history = run_model(model,x_train,y_train,epochs=30,batch_size=500,verbose=1,validation_data=(x_val,y_val), callbacks =[es]) # callbacks =[mc, es]","0a817843":"loss = history.history\nloss.keys()","28fe8fca":"#rmse loss\nrmse_loss_train = loss['root_mean_squared_error']\nrmse_loss_val = loss['val_root_mean_squared_error']\nepochs_stops = es.stopped_epoch +1 # epochs number from early stopping\nepochs = range(1,epochs_stops + 1)  #len(loss_train)\nplt.figure(figsize=(12,6))\nplt.plot(epochs,rmse_loss_train,'r', label='RMSE train loss')\nplt.plot(epochs,rmse_loss_val,'b',label='RMSE val loss')\nplt.title(' root mean square error loss')\nplt.legend()\nplt.show()","be067f68":"# submit = pd.read_csv('\/kaggle\/input\/ashrae-energy-prediction\/sample_submission.csv')","34595f1e":"# x_test = BTW_test[['meter', 'building_id', 'primary_use', 'Month', 'Day','air_temperature', 'wind_speed', 'precip_depth_1_hr', 'cloud_coverage',#\n#        'square_feet']]\n# x_test = x_test.values[:]\n# x_test = x_test.reshape((x_test.shape[0],1,x_test.shape[-1]))","bb2e8d89":"# prediction = history.predict(x_test)","283c86b5":"# prediction = np.expm1(prediction)","9af6947a":"# submit['meter_reading'] = prediction","3bb0f621":"# submit.to_csv('submission.csv', index=False,float_format='%.4f')","1982d5f1":"## Submitting","1e15423e":"# Deep learning model","2873a5a4":"### Abstract:\n\nWe are using a dataset related to ASHRAE \u2013 Great Energy Predictor III (How much energy will a building consume?). The goal is to develop models from ASHRAE\u2019s 2016 data in order to better understand metered building energy usage in the following areas: chilled water, electric, hot water, and steam meters. The data comes from over 1,000 buildings over a one-year timeframe.","c4d23cd3":"## 3.Data modeling ","b7bca2b3":"## 2.Data preparation","e9a46756":"## 1.Data understanding","92623697":"Reduce some data types to save some memory usage.","fa17d459":"### Dropping columns and filling null value","7501dadf":"### Messing data in 'building_meta","86b10077":"meter - The meter id code Read as {0: electricity, 1: chilledwater, 2: steam, 3: hotwater}. Not every building has all meter types.\n\nmeter_reading - The target variable. Energy consumption in kWh (or equivalent). Note that this is real data with measurement error, which we expect will impose a baseline level of modeling error. UPDATE: as discussed here, the site 0 electric meter readings are in kBTU.","64ce9fc1":"# Great Energy predictor using LSTM model","3611f164":"Change data type to float 32 for filling NA value before transforming them into int for smooth modeling processing"}}