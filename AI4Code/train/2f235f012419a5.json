{"cell_type":{"a6ee6cfc":"code","82321969":"code","a08c02d2":"code","ee94ec65":"code","16bfe840":"code","721b3234":"markdown","8c0f72ee":"markdown","ec61441e":"markdown","e316b80d":"markdown","2a97583e":"markdown","5a789598":"markdown","e440b785":"markdown","0b1a0e8c":"markdown","80b61df3":"markdown","da97e2a5":"markdown","43116ed9":"markdown","e6c586f9":"markdown","8d6ca9e0":"markdown","c97865b7":"markdown"},"source":{"a6ee6cfc":"import numpy as np\nfrom math import sin, cos, atan2, sqrt\nfrom cv2 import Rodrigues","82321969":"# Euler Angles -> Rotation Matrix -> Rotation Vector\ndef a2v(yaw, pitch, roll):\n    # Euler Angle -> Rotation Matrix\n    # I think the pitch and yaw should be exchanged\n    yaw, pitch = pitch, yaw\n    Y = np.array([[cos(yaw), -sin(yaw), 0],\n                  [sin(yaw), cos(yaw), 0],\n                  [0, 0, 1]])\n    P = np.array([[cos(pitch), 0, sin(pitch)],\n                  [0, 1, 0],\n                  [-sin(pitch), 0, cos(pitch)]])\n    R = np.array([[1, 0, 0],\n                  [0, cos(roll), -sin(roll)],\n                  [0, sin(roll), cos(roll)]])\n    rotation_m = np.dot(Y, np.dot(P, R))\n    \n    \n    # Rotation Matrix -> Rotation Vector\n    rotation_v = Rodrigues(rotation_m)[0]\n    rotation_v = np.squeeze(rotation_v)\n    \n    return rotation_v","a08c02d2":"print(a2v(0.162877, 0.00519276, -3.02676))","ee94ec65":"# Rotation Vector -> Rotation Matrix -> Euler Angles\ndef v2a(rotation_v):\n    # Rotation Vector -> Rotation Matrix\n    R = Rodrigues(rotation_v)[0]\n    \n    sq = sqrt(R[0,0] ** 2 +  R[1,0] ** 2)\n\n    if  not (sq < 1e-6) :\n        roll = atan2(R[2,1] , R[2,2])\n        yaw = atan2(-R[2,0], sq)\n        pitch = atan2(R[1,0], R[0,0])\n    else :\n        roll = atan2(-R[1,2], R[1,1])\n        yaw = atan2(-R[2,0], sq)\n        pitch = 0\n\n    return yaw, pitch, roll","16bfe840":"v = np.array([-3.01748673, 0.00632166, 0.24673163])\nprint(v2a(v))","721b3234":"### 'In summary, the pose branch is trained to regress a 4-dimensional vector, in which the first three elements represent rotation part and the last element represents the z component of the translation part of the pose.'\n","8c0f72ee":"**' During training, we map the groundtruths of rotation matrices to their associated elements in so(3) by the closed form Rodrigues logarithm mapping [2]. The mapped values are used as regression targets when learning to predict the rotation. '**","ec61441e":"#### If you think it's useful, please give me an upvote, thanks.","e316b80d":"![1](http:\/\/www.pianshen.com\/images\/654\/e166052ae19a43a7a3e628f1722373d6.png)","2a97583e":"- Example 2:","5a789598":"![1](https:\/\/img-blog.csdnimg.cn\/2019041922363717.png?x-oss-process=image\/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDc1NTI5,size_16,color_FFFFFF,t_70)","e440b785":"# This paper shows a way to regress pose.","0b1a0e8c":"[Deep-6DPose: Recovering 6D Object Pose from a Single RGB Image](https:\/\/arxiv.org\/abs\/1802.10367v1)","80b61df3":"## In a word, they use 'Rotation Vector' as regression target.","da97e2a5":"# Theory may seems complicated, I'll show you codes.","43116ed9":"### 1. Translation\n> In stead of predicting full translation vector, our network is trained to regress the Z component only. Of course, It works.\n>\n> As we can see in below picture, if we get Zc, then we can convert pixel-coordinates (u, v) to world-coordinates (Xw, Yw, Zw).","e6c586f9":"### 2. Rotation\n- Representing the rotation part of the pose is more complicated than the translation part, there are some ways.\n * 1 - the Euler angles wrap around at 2\u03c0 radians, i.e., having multiple values representing the same angle. This causes difficulty in learning a uni-modal scalar regression task.\n * 2 - the use of 3\u00d73 orthonormal matrix is over-parametrised, and creates the problem of enforcing the orthogonality constraint when training the network through back-propagation.\n * 3 - A final common representation is the unit length 4-dimensional quaternion. One of the downsides of quaternion representation is its norm should be unit. This constraint may harm the optimization.\n * **4 - In this work, we use the Lie algebra so(3) associated with the Lie group SO(3) (which is space of 3D rotation matrices) as our rotation representation.We choose the Lie algebra so(3) to represent the rotation because an arbitrary element of so(3) admits a skew-symmetric matrix representation parameterized by a vector in R 3 which is continuous and smooth. This means that the network needs to regress only three scalar numbers for a rotation, without any constraints.**","8d6ca9e0":"![image.png](attachment:image.png)","c97865b7":"- Example 1:"}}