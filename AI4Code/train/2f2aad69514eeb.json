{"cell_type":{"e4ee07a3":"code","d5f1a298":"code","e8a3a170":"code","abcba96a":"code","fcb3827c":"code","a9f1975b":"code","8c1ddf7a":"code","9484186e":"code","24400b4e":"code","6db2677c":"code","cf3f5844":"code","8377fde0":"code","815152df":"code","45568a81":"code","dfdf0b57":"code","a53ea00a":"code","ed4ab4e0":"code","cdd9c219":"code","4122d39e":"code","71da89dd":"code","06766cfb":"code","1c88851d":"code","b2258f95":"code","5cad9c2f":"code","cb4f2bff":"code","7c61ccf9":"code","af3aa9c1":"code","5f11934b":"code","099b2372":"code","2cdc9b3d":"code","ac0dcd57":"code","2cc8671d":"code","f24b5e36":"code","bcf22a25":"code","7f521068":"code","dfa5da93":"code","32c372c6":"code","15c59c0b":"code","033e64da":"code","1e322a1c":"code","630fcf33":"code","f4738cbe":"code","bbe4ba17":"code","75d81467":"code","454d0e73":"code","cd829533":"code","5ec98bcb":"code","a2e3182a":"code","1114e098":"code","a757c73b":"code","688efc7d":"code","f4b1181f":"code","ebb859e1":"code","46f79b71":"code","d47dad06":"code","94a932e1":"code","7fc76dc6":"code","abf86f65":"code","e48e84f1":"code","e4f97284":"code","6b4959d2":"code","6dbcb672":"code","91adfe37":"code","5bdd1d9c":"code","d547e165":"code","aabb2ed6":"markdown","5a45ed36":"markdown","4712faf7":"markdown","28dab180":"markdown","d8771879":"markdown","21222423":"markdown","dd06bec2":"markdown","f3a93ba0":"markdown","849deafc":"markdown","de86b969":"markdown","0bcfaf32":"markdown","99f3286c":"markdown","2339f2ee":"markdown","8074fd03":"markdown","05e4fee0":"markdown","5ee650be":"markdown","fd0bcba7":"markdown"},"source":{"e4ee07a3":"import os, sys\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport sklearn\nfrom pandas.api.types import CategoricalDtype","d5f1a298":"plt.rcParams['figure.figsize'] = (8,8)\npd.set_option('display.max_columns', 500)","e8a3a170":"def create_col_name(base_str, start_int, end_int):\n    return [base_str + str(i) for i in range(start_int, end_int+1)]","abcba96a":"create_col_name('card', 1, 6)","fcb3827c":"cat_cols = (['ProductCD'] + create_col_name('card', 1, 6) + ['addr1', 'addr2', 'P_emaildomain', 'R_emaildomain'] + \n            create_col_name('M', 1, 9) + ['DeviceType', 'DeviceInfo'] + create_col_name('id_', 12, 38))\n\nid_cols = ['TransactionID', 'TransactionDT']\n\ntarget = 'isFraud'","a9f1975b":"type_map = {c: str for c in cat_cols + id_cols}","8c1ddf7a":"df_train_id = pd.read_csv('..\/input\/ieee-fraud-detection\/train_identity.csv', dtype=type_map)\ndf_train_trans = pd.read_csv('..\/input\/ieee-fraud-detection\/train_transaction.csv', dtype=type_map)\n","9484186e":"df_test_id = pd.read_csv('..\/input\/ieee-fraud-detection\/test_identity.csv', dtype=type_map)\ndf_test_trans = pd.read_csv('..\/input\/ieee-fraud-detection\/test_transaction.csv', dtype=type_map)","24400b4e":"df_train_id.shape, df_train_trans.shape","6db2677c":"df_train_id.head()","cf3f5844":"df_train_trans.head()","8377fde0":"df_test_id.head()","815152df":"df_train = df_train_trans.merge(df_train_id, on='TransactionID', how='left')","45568a81":"df_t = df_test_trans.merge(df_test_id, on='TransactionID', how='left')","dfdf0b57":"del df_train_id, df_train_trans","a53ea00a":"del df_test_id,df_test_trans","ed4ab4e0":"def reduce_mem_usage(df, verbose=True):\n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    start_mem = df.memory_usage().sum() \/ 1024**2    \n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)    \n    end_mem = df.memory_usage().sum() \/ 1024**2\n    if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n    return df","cdd9c219":"df_train = reduce_mem_usage(df_train)\ndf_t = reduce_mem_usage(df_t)","4122d39e":"import gc\ngc.collect()","71da89dd":"numeric_cols = [col for col in df_train.columns.tolist() if col not in cat_cols + id_cols + [target]]","06766cfb":"#assert(df_train.shape[0]==df_train_trans.shape[0])","1c88851d":"df_train.head()","b2258f95":"df_train[cat_cols].head()","5cad9c2f":"df_train[numeric_cols].head()","cb4f2bff":"df_t.head()","7c61ccf9":"df_test = df_t.rename(columns = {\"id-01\":\"id_01\", \"id-02\":\"id_02\",\"id-03\":\"id_03\",\"id-04\":\"id_04\",\"id-05\":\"id_05\",\n                                \"id-06\":\"id_06\",\"id-07\":\"id_07\",\"id-08\":\"id_08\",\"id-09\":\"id_09\",\"id-10\":\"id_10\",\n                                \"id-11\":\"id_11\",\"id-12\":\"id_12\",\"id-13\":\"id_13\",\"id-14\":\"id_14\",\"id-15\":\"id_15\",\n                                \"id-16\":\"id_16\",\"id-17\":\"id_17\",\"id-18\":\"id_18\",\"id-19\":\"id_19\",\"id-20\":\"id_20\",\n                                \"id-21\":\"id_21\",\"id-22\":\"id_22\",\"id-23\":\"id_23\",\"id-24\":\"id_24\",\"id-25\":\"id_25\",\n                                \"id-26\":\"id_26\",\"id-27\":\"id_27\",\"id-28\":\"id_28\",\"id-29\":\"id_29\",\"id-30\":\"id_30\",\n                                \"id-31\":\"id_31\",\"id-32\":\"id_32\",\"id-33\":\"id_33\",\"id-34\":\"id_34\",\"id-35\":\"id_35\",\n                                \"id-36\":\"id_36\",\"id-37\":\"id_37\",\"id-38\":\"id_38\",})","af3aa9c1":"df_test.head()","5f11934b":"del df_t","099b2372":"df_train['n_nulls'] = df_train.isnull().sum(axis=1)\ndf_test['n_nulls'] = df_test.isnull().sum(axis=1)\n\nnumeric_cols += ['n_nulls']","2cdc9b3d":"df_train['id_30'].unique()[:20]","ac0dcd57":"df_test['id_30'].unique()[:20]","2cc8671d":"for col in ['id_30', 'id_31']:\n    df_train[col+'_clean'] = df_test[col].str.replace(r'[^A-Za-z]', '', regex=True)\n    df_test[col+'_clean'] = df_test[col].str.replace(r'[^A-Za-z]', '', regex=True)\n    cat_cols += [col+'_clean']","f24b5e36":"def cat_to_int(df_train, df_test, col):\n    catDtype = CategoricalDtype(categories=df_train[col].value_counts().index.values)\n    return df_train[col].astype(catDtype).cat.codes.values, df_test[col].astype(catDtype).cat.codes.values","bcf22a25":"df_train.loc[:,cat_cols] = df_train[cat_cols].fillna('<UNK>')\ndf_test.loc[:,cat_cols] = df_test[cat_cols].fillna('<UNK>')\n\ndf_train = df_train.fillna(-999)\ndf_test = df_test.fillna(-999)","7f521068":"cat_cols_encoded = list()\nfor col in cat_cols:\n    df_train[col+'_code'], df_test[col+'_code'] = cat_to_int(df_train, df_test, col)\n    cat_cols_encoded.append(col+'_code')","dfa5da93":"from catboost import Pool, CatBoostClassifier\nimport lightgbm as lgb\nfrom sklearn.model_selection import KFold\nfrom pandas.api.types import CategoricalDtype","32c372c6":"features = cat_cols + numeric_cols","15c59c0b":"N_val = int(df_train.shape[0]*0.05)\ndf_val = df_train.sort_values(by='TransactionDT').tail(N_val)\ndf_train_sample = df_train[~df_train.index.isin(df_val.index)]\nshuffle_ks = True","033e64da":"df_train.shape[0], df_train_sample.shape[0], df_val.shape[0]","1e322a1c":"df_train_sample.head()","630fcf33":"def build_pool(df, features, cat_cols, target=None):\n    if target:\n        data = Pool(\n            data=df[features],\n            label=df[target],\n            cat_features=cat_cols\n        )\n    else:\n        data = Pool(\n            data=df[features],\n            cat_features=cat_cols\n        )\n        \n    return data","f4738cbe":"train_data = build_pool(df_train_sample, features, cat_cols, target)\nholdout_data = build_pool(df_val, features, cat_cols, target)","bbe4ba17":"len(train_data.get_label())","75d81467":"df_train_sample.shape","454d0e73":"w = (df_train_sample[target]==0).sum() \/ (df_train_sample[target]==1).sum() \/ 5","cd829533":"params = {\n    'iterations': 1500,\n    'learning_rate': 0.05,\n    #'depth': 15,\n    'eval_metric': 'AUC',\n    'od_type': 'Iter',\n    'od_wait': 50,\n     'task_type': 'CPU',\n     'devices': '3',\n    'scale_pos_weight': w,\n}","5ec98bcb":"import warnings\n\nmodel_single = CatBoostClassifier(**params)\nmodel_single.fit(train_data, eval_set=holdout_data, plot=True, verbose=False)","a2e3182a":"train_data_lgb = lgb.Dataset(\n    data=df_train_sample[numeric_cols + cat_cols_encoded], \n    label=df_train_sample[target],\n    categorical_feature=cat_cols_encoded,\n    free_raw_data=False,\n)\n\nholdout_data_lgb = lgb.Dataset(\n    data=df_val[numeric_cols + cat_cols_encoded], \n    label=df_val[target],\n    categorical_feature=cat_cols_encoded,\n    free_raw_data=False,\n)","1114e098":"# https:\/\/www.kaggle.com\/timon88\/lgbm-baseline-small-fe-no-blend\n\nlgb_params = {\n    'num_leaves': 491,\n    'min_data_in_leaf': 106,\n    'max_depth': -1,\n    'min_child_weight': 0.03,\n    'feature_fraction': 0.38,\n    'bagging_fraction': 0.42,\n    'objective': 'binary',\n    'learning_rate': 0.0069,\n    \"boosting_type\": \"gbdt\",\n    \"bagging_seed\": 0,\n    \"metric\": 'auc',\n    \"verbosity\": -1,\n    'reg_alpha': 0.39,\n    'reg_lambda': 0.65,\n    'random_state': 0,\n    'scale_pos_weight': w,\n}","a757c73b":"%%time \n\nnum_round = 3000\nbst = lgb.train(lgb_params, train_data_lgb, num_round, valid_sets=[holdout_data_lgb], early_stopping_rounds=100)","688efc7d":"bst.best_score","f4b1181f":"from sklearn.metrics import roc_curve, roc_auc_score","ebb859e1":"def plot_roc(y_trues, y_preds, labels, x_max=1.0):\n    fig, ax = plt.subplots()\n    for i, y_pred in enumerate(y_preds):\n        y_true = y_trues[i]\n        fpr, tpr, thresholds = roc_curve(y_true, y_pred)\n        auc = roc_auc_score(y_true, y_pred)\n        ax.plot(fpr, tpr, label='%s; AUC=%.3f' % (labels[i], auc), marker='o', markersize=1)\n\n    ax.legend()\n    ax.grid()\n    ax.plot(np.linspace(0, 1, 20), np.linspace(0, 1, 20), linestyle='--')\n    ax.set_title('ROC curve')\n    ax.set_xlabel('False Positive Rate')\n    ax.set_xlim([-0.01, x_max])\n    _ = ax.set_ylabel('True Positive Rate')","46f79b71":"plot_roc(\n    [df_val[target]]*2,\n    [model_single.predict_proba(holdout_data)[:,1], bst.predict(df_val[numeric_cols+cat_cols_encoded].values, num_iteration=bst.best_iteration)],\n    ['Single Catboost Model', 'LGB']\n)","d47dad06":"n_splits = 5\nkf = KFold(n_splits=n_splits, shuffle=True)\nmodels_cv = list()\nfor train_index, test_index in kf.split(df_train.index.values):\n    print(\"Train shape: \", len(train_index))\n    train_data = build_pool(df_train.iloc[train_index,:], features, cat_cols, target)\n    holdout_data = build_pool(df_train.iloc[test_index,:], features, cat_cols, target)\n    \n    model = CatBoostClassifier(ignored_features=None, **params)\n    model.fit(train_data, eval_set=holdout_data, plot=True, verbose=False)\n    models_cv.append(model)","94a932e1":"test_data = build_pool(df_test, features, cat_cols)","7fc76dc6":"y_test_catboost = model_single.predict_proba(test_data)[:,1]","abf86f65":"y_test_lgb = bst.predict(df_test[numeric_cols + cat_cols_encoded].values, num_iteration=bst.best_iteration)","e48e84f1":"fig, ax = plt.subplots()\nax.scatter(x=y_test_catboost, y=y_test_lgb, s=1)","e4f97284":"y_test_hats = list()\nfor model in models_cv:\n    y_test_hats.append(model.predict_proba(test_data)[:,1])","6b4959d2":"y_test_hat = np.vstack([y_test_catboost, y_test_lgb]+y_test_hats).mean(axis=0)\ndf_test['isFraud'] = y_test_hat","6dbcb672":"df_test[['TransactionID', 'isFraud']].to_csv('my_submission_v1.csv', index=False)","91adfe37":"submission = pd.read_csv('my_submission_v1.csv')","5bdd1d9c":"submission.head()","d547e165":"#!kaggle competitions submit -c ieee-fraud-detection -f my_submission_v1.csv -m \"Fraud Detection with CatBoost + LGB-weighted + Cat_5fold\"","aabb2ed6":"## Data Overview\n\n### Project Goals","5a45ed36":"According to the Data Description given by the data provider Vesta:\n\nhttps:\/\/www.kaggle.com\/c\/ieee-fraud-detection\/discussion\/101203\n\n**Continuous Variables**\n\n``TransactionDT``: timedelta from a given reference datetime (not an actual timestamp)\n\n``TransactionAMT``: transaction payment amount in USD\n\n``dist``: May be the distance from addresses\n\n``C1-C14``: counting, such as how many addresses are found to be associated with the payment card, etc. The actual meaning is masked.\n\n``D1-D15``: timedelta, such as days between previous transaction, etc.\n\n``V1`` - ``V339``: Vesta engineered rich features, including ranking, counting, and other entity relations.\n\n``id_01`` - ``id_11``(In identity table)\n\n**Categorical Variables**\n\nFrom **Transaction** Table:\n\n``ProductCD``: product code, the product for each transaction\n\n``card1`` - ``card6``: payment card information, such as card type, card category, issue bank, country, etc.\n\n``addr1``, ``addr2``: \nboth are for purchaser,\naddr1 as billing region,\naddr2 as billing country\n\n``Pemaildomain``, ``Remaildomain``: purchaser and recipient email domain\n\n``M1`` - ``M9``: match, such as names on card and address, etc.\n\nFrom **Identity** Table:\n\nVariables in this table are identity information \u2013 network connection information (IP, ISP, Proxy, etc) and digital signature (UA\/browser\/os\/version, etc) associated with transactions.\nThey're collected by Vesta\u2019s fraud protection system and digital security partners.\n\n``id12`` - ``id38``, ``DeviceType``, ``DeviceInfo``","4712faf7":"#### Merging the Train & Test Data","28dab180":"### Evaluate Performance","d8771879":"The data comes from Vesta's real-world e-commerce transactions and contains a wide range of features from device type to product features. The goal is to predict the probability that an online transaction is fraudulent, as denoted by the binary target isFraud.\n\nThe data is broken into two files identity and transaction, which are joined by TransactionID. Not all transactions have corresponding identity information.\n\nThe training dataset consists of more than 400 features and 5.9 Million samples. This is supervised binary classification problem and goal is to predict if a credit card transaction is Fraud based on input features mentioned below.","21222423":"### Import Packages","dd06bec2":"## Modeling\n\n#### Catboost Modeling","f3a93ba0":"### Information of Variables","849deafc":"### Loading the Data","de86b969":"****The id column names in the train and test dataset does not match. So, renaming the test columns according to the train id columns.****","0bcfaf32":"### Reduce Memory Usage","99f3286c":"### Convert Categories to Ints for LightGBM","2339f2ee":"#### Remove Version Numbers","8074fd03":"### Train LGB","05e4fee0":"## Feature Engineering\n\n#### Count NULL Values","5ee650be":"### Generate Test Predictions","fd0bcba7":"## CV\n\nUsing the full Dataset"}}