{"cell_type":{"5a77b15a":"code","2022ff02":"code","caf970db":"code","6866a292":"code","9b9ca990":"code","b0a78f9e":"code","9eac40ab":"code","39371a90":"code","adad41db":"code","39a05fc0":"code","58d7b27f":"code","7197a6f2":"code","f72d1e92":"code","cfdb1973":"code","956a612c":"code","7c3f695c":"code","d3155b5c":"code","20476c37":"code","4f0f5346":"code","60e04447":"code","334f24ae":"code","57d09c33":"code","951e7298":"code","612d2796":"code","d7d584d4":"code","c05778b4":"code","2bc77ef4":"code","ff9f944a":"code","7364cdd4":"code","bb725abe":"markdown","a3b5743a":"markdown","d48ccf1d":"markdown","98b65d36":"markdown"},"source":{"5a77b15a":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\nfrom sklearn.preprocessing import OneHotEncoder, LabelEncoder\nfrom tqdm import tqdm_notebook\nfrom sklearn.model_selection import KFold\n\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","2022ff02":"train = pd.read_csv('..\/input\/cat-in-the-dat-ii\/train.csv', index_col='id')\ntest = pd.read_csv('..\/input\/cat-in-the-dat-ii\/test.csv', index_col='id')","caf970db":"train.shape","6866a292":"train.head()","9b9ca990":"test.shape","b0a78f9e":"test.head()","9eac40ab":"target = train['target'].values\ndel train['target']","39371a90":"np.save('target', target)","adad41db":"columns = train.columns\n\nfor cc in tqdm_notebook(columns):\n    train[cc] = train[cc].fillna(train[cc].mode()[0])\n    test[cc] = test[cc].fillna(test[cc].mode()[0])","39a05fc0":"np.save('columns', columns.values)","58d7b27f":"%%time\n\nX_train = train.copy()\nX_test = test.copy()\n\nfor cc in tqdm_notebook(columns):\n    le = LabelEncoder()\n    le.fit(list(train[cc].values)+list(test[cc].values))\n    X_train[cc] = le.transform(train[cc].values)\n    X_test[cc] = le.transform(test[cc].values)","7197a6f2":"np.save('X_train_le', X_train)\nnp.save('X_test_le', X_test)","f72d1e92":"%%time\nX_train = train.copy()\nX_test = test.copy()\n\nohe = OneHotEncoder(dtype='uint16', handle_unknown=\"ignore\")\nohe.fit(train)\nX_train = ohe.transform(train)\nX_test = ohe.transform(test)","cfdb1973":"X_train.shape","956a612c":"X_test.shape","7c3f695c":"np.save('X_train_ohe', X_train)\nnp.save('X_test_ohe', X_test)","d3155b5c":"X_train","20476c37":"# Reading the data\nX = pd.read_csv(\"\/kaggle\/input\/cat-in-the-dat-ii\/train.csv\")\nXt = pd.read_csv(\"\/kaggle\/input\/cat-in-the-dat-ii\/test.csv\")\n\n# Separating target and ids\ny = X.target.values\nid_train = X.id\nid_test = Xt.id\n\nX.drop(['id', 'target'], axis=1, inplace=True)\nXt.drop(['id'], axis=1, inplace=True)\n\n# Classifying variables in binary, high and low cardinality nominal, ordinal and dates\nbinary_vars = [c for c in X.columns if 'bin_' in c]\n\nnominal_vars = [c for c in X.columns if 'nom_' in c]\nhigh_cardinality = [c for c in nominal_vars if len(X[c].unique()) > 16]\nlow_cardinality = [c for c in nominal_vars if len(X[c].unique()) <= 16]\n\nordinal_vars = [c for c in X.columns if 'ord_' in c]\n\ntime_vars = ['day', 'month']","4f0f5346":"# Some feature engineering\nX['ord_5_1'] = X['ord_5'].apply(lambda x: x[0] if type(x) == str else np.nan)\nX['ord_5_2'] = X['ord_5'].apply(lambda x: x[1] if type(x) == str else np.nan)\nXt['ord_5_1'] = Xt['ord_5'].apply(lambda x: x[0] if type(x) == str else np.nan)\nXt['ord_5_2'] = Xt['ord_5'].apply(lambda x: x[1] if type(x) == str else np.nan)\n\nordinal_vars += ['ord_5_1', 'ord_5_2']","60e04447":"# Converting ordinal labels into ordered values\nordinals = {\n    'ord_1' : {\n        'Novice' : 0,\n        'Contributor' : 1,\n        'Expert' : 2,\n        'Master' : 3,\n        'Grandmaster' : 4\n    },\n    'ord_2' : {\n        'Freezing' : 0,\n        'Cold' : 1,\n        'Warm' : 2,\n        'Hot' : 3,\n        'Boiling Hot' : 4,\n        'Lava Hot' : 5\n    }\n}\n\ndef return_order(X, Xt, var_name):\n    mode = X[var_name].mode()[0]\n    el = sorted(set(X[var_name].fillna(mode).unique())|set(Xt[var_name].fillna(mode).unique()))\n    return {v:e for e, v in enumerate(el)}\n\nfor mapped_var in ordinal_vars:\n    if mapped_var not in ordinals:\n        mapped_values = return_order(X, Xt, mapped_var)\n        X[mapped_var + '_num'] = X[mapped_var].replace(mapped_values)\n        Xt[mapped_var + '_num'] = Xt[mapped_var].replace(mapped_values)\n    else:\n        X[mapped_var + '_num'] = X[mapped_var].replace(ordinals[mapped_var])\n        Xt[mapped_var + '_num'] = Xt[mapped_var].replace(ordinals[mapped_var])","334f24ae":"# Transforming all the labels of all variables\nfrom sklearn.preprocessing import LabelEncoder\n\nlabel_encoders = [LabelEncoder() for _ in range(X.shape[1])]\n\nfor col, column in enumerate(X.columns):\n    unique_values = pd.Series(X[column].append(Xt[column]).unique())\n    unique_values = unique_values[unique_values.notnull()]\n    label_encoders[col].fit(unique_values)\n    X.loc[X[column].notnull(), column] = label_encoders[col].transform(X.loc[X[column].notnull(), column])\n    Xt.loc[Xt[column].notnull(), column] = label_encoders[col].transform(Xt.loc[Xt[column].notnull(), column])","57d09c33":"# Dealing with any residual missing value\nX = X.fillna(-1)\nXt = Xt.fillna(-1)","951e7298":"# Enconding frequencies instead of labels (so we have some numeric variables)\ndef frequency_encoding(column, df, df_test=None):\n    frequencies = df[column].value_counts().reset_index()\n    df_values = df[[column]].merge(frequencies, how='left', \n                                   left_on=column, right_on='index').iloc[:,-1].values\n    if df_test is not None:\n        df_test_values = df_test[[column]].merge(frequencies, how='left', \n                                                 left_on=column, right_on='index').fillna(1).iloc[:,-1].values\n    else:\n        df_test_values = None\n    return df_values, df_test_values\n\nfor column in X.columns:\n    train_values, test_values = frequency_encoding(column, X, Xt)\n    X[column+'_counts'] = train_values\n    Xt[column+'_counts'] = test_values","612d2796":"# Target encoding of selected variables\nX['fold_column'] = 0\nn_splits = 5\nkf = KFold(n_splits=n_splits, random_state=137)\n\nimport category_encoders as cat_encs\n\ncat_feat_to_encode = binary_vars + ordinal_vars + nominal_vars + time_vars\nsmoothing = 0.3\n\nenc_x = np.zeros(X[cat_feat_to_encode].shape)\n\nfor i, (tr_idx, oof_idx) in enumerate(kf.split(X, y)):\n    encoder = cat_encs.TargetEncoder(cols=cat_feat_to_encode, smoothing=smoothing)\n    \n    X.loc[oof_idx, 'fold_column'] = i\n    \n    encoder.fit(X[cat_feat_to_encode].iloc[tr_idx], y[tr_idx])\n    enc_x[oof_idx, :] = encoder.transform(X[cat_feat_to_encode].iloc[oof_idx], y[oof_idx])\n    \nencoder.fit(X[cat_feat_to_encode], y)\nenc_xt = encoder.transform(Xt[cat_feat_to_encode]).values\n\nfor idx, new_var in enumerate(cat_feat_to_encode):\n    new_var = new_var + '_enc'\n    X[new_var] = enc_x[:,idx]\n    Xt[new_var] = enc_xt[:, idx]","d7d584d4":"oof_idx","c05778b4":"# Setting all to dtype float32\nX = X.astype(np.float32)\nXt = Xt.astype(np.float32)\n\n# Defining categorical variables\ncat_features = nominal_vars + ordinal_vars\n\n# Setting categorical variables to int64\nX[cat_features] = X[cat_features].astype(np.int64)\nXt[cat_features] = Xt[cat_features].astype(np.int64)","2bc77ef4":"X.head()","ff9f944a":"X['target'] = y","7364cdd4":"X.to_csv('X_train_te.csv', index=False)\nXt.to_csv('X_test_te.csv', index=False)","bb725abe":"One Hot Encoding:","a3b5743a":"Handling missing values:","d48ccf1d":"Label encoding:","98b65d36":"The following features are taken from this kernel: https:\/\/www.kaggle.com\/lucamassaron\/catboost-beats-auto-ml"}}