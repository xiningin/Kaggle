{"cell_type":{"0e74102a":"code","81eef450":"code","636f54f2":"code","0c22b57c":"code","759181f2":"code","a59b966a":"code","6767fb83":"code","5404d32f":"code","b1bd8c0b":"code","5fe26816":"code","aaa8eeb5":"markdown","a9b3b61b":"markdown","2a1c2c34":"markdown","08a42022":"markdown","576588e9":"markdown","8017f26a":"markdown"},"source":{"0e74102a":"from time import time\nnotebook_start_time = time()","81eef450":"import os\nimport re\nimport cv2\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nimport torch\nfrom torch import nn, optim\nfrom torch.utils.data import Dataset\nfrom torch.utils.data import DataLoader as DL\nfrom torch.nn.utils import weight_norm as WN\nfrom torchvision import models, transforms\n\nfrom sklearn.model_selection import KFold\nfrom sklearn.preprocessing import StandardScaler","636f54f2":"SEED = 49\nDEVICE = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nPATH = \"..\/input\/petfinder-pawpularity-score\"\nPRETRAINED_WEIGHTS_PATH = \"..\/input\/pretrained-model-weights-all\"\nTRAINED_ANN_WEIGHTS_PATH = \"..\/input\/d169-baseline-nc-train\"\n\nMODEL_NAME = \"densenet169\"\nFEATURE_LENGTH = 1664\nNUM_FOLDS = len([name for name in os.listdir(TRAINED_ANN_WEIGHTS_PATH) if name[-2:] == \"pt\"])\n\nIMAGE_SIZE = 224\nTRANSFORM = transforms.Compose([transforms.ToTensor(), \n                                transforms.Normalize([0.485, 0.456, 0.406],\n                                                     [0.229, 0.224, 0.225]),\n                                ])\n\nsc_y = StandardScaler()","0c22b57c":"def breaker(num=50, char=\"*\") -> None:\n    print(\"\\n\" + num*char + \"\\n\")\n\n\ndef head(x, no_of_ele=5) -> None:\n    print(x[:no_of_ele])\n\n\ndef get_filenames_and_targets(path: str) -> tuple:\n    df = pd.read_csv(os.path.join(path, \"train.csv\"), engine=\"python\")\n    filenames = df.iloc[:, 0].copy().values\n    targets  = df.iloc[:, -1].copy().values\n    return filenames, targets\n\n\ndef get_filenames(path: str) -> np.ndarray:\n    df = pd.read_csv(os.path.join(path, \"test.csv\"), engine=\"python\")\n    filenames  = df[\"Id\"].copy().values\n    return filenames\n\n\ndef get_image(path: str, name: str, size: int) -> np.ndarray:\n    image = cv2.imread(os.path.join(path, name + \".jpg\"), cv2.IMREAD_COLOR)\n    image = cv2.cvtColor(src=image, code=cv2.COLOR_BGR2RGB)\n    image = cv2.resize(src=image, dsize=(size, size), interpolation=cv2.INTER_AREA)\n    return image\n\n\ndef make_submission(path: str, y_pred: np.ndarray) -> None:\n    submission = pd.read_csv(os.path.join(path, \"sample_submission.csv\"), engine=\"python\")\n    submission[\"Pawpularity\"] = y_pred\n    submission.to_csv(\".\/submission.csv\", index=False)","759181f2":"class ImageDS(Dataset):\n    def __init__(self, base_path=None, filenames=None, image_size=None, transform=None):\n        self.base_path = base_path\n        self.filenames = filenames\n        self.image_size = image_size\n        self.transform = transform\n    \n    def __len__(self):\n        return self.filenames.shape[0]\n    \n    def __getitem__(self, idx):\n        image = get_image(self.base_path, self.filenames[idx], self.image_size)\n        return self.transform(image)\n\n    \nclass FeatureDS(Dataset):\n    def __init__(self, features=None):\n        self.features = features\n    \n    def __len__(self):\n        return self.features.shape[0]\n    \n    def __getitem__(self, idx):\n        return torch.FloatTensor(self.features[idx])","a59b966a":"def build_models(IL: int, pretrained: bool, seed: int):\n\n    class ImageModel(nn.Module):\n        def __init__(self, pretrained=False):\n            super(ImageModel, self).__init__()\n\n            self.features = models.densenet169(pretrained=pretrained, progress=True)\n            if pretrained:\n                self.freeze()\n            self.features = nn.Sequential(*[*self.features.children()][:-1])\n            self.features.add_module(\"Adaptive Average Pool\", nn.AdaptiveAvgPool2d(output_size=(1, 1)))\n            self.features.add_module(\"Flatten\", nn.Flatten())\n\n        def freeze(self):\n            for params in self.parameters():\n                    params.requires_grad = False\n\n        def forward(self, x):\n            return self.features(x)\n    \n    torch.manual_seed(seed)\n    vision_model = ImageModel(pretrained=pretrained)\n    \n    \n    class ANN(nn.Module):\n        def __init__(self, IL=None):\n            super(ANN, self).__init__()\n\n            self.predictor = nn.Sequential()\n            self.predictor.add_module(\"BN\", nn.BatchNorm1d(num_features=IL, eps=1e-5))\n            self.predictor.add_module(\"FC\", WN(nn.Linear(in_features=IL, out_features=1)))\n\n        def get_optimizer(self, lr=1e-3, wd=0):\n            params = [p for p in self.parameters() if p.requires_grad]\n            return optim.Adam(params, lr=lr, weight_decay=wd)\n\n        def get_plateau_scheduler(self, optimizer=None, patience=5, eps=1e-8):\n            return optim.lr_scheduler.ReduceLROnPlateau(optimizer=optimizer, patience=patience, eps=eps, verbose=True)\n\n        def forward(self, x1, x2=None):\n            if x2 is not None:\n                return self.predictor(x1), self.predictor(x2)\n            else:\n                return self.predictor(x1)\n    \n    torch.manual_seed(seed)\n    ann_model = ANN(IL=IL)\n    \n    return vision_model, ann_model","6767fb83":"def get_features(model=None, dataloader=None, feature_length=None, path=None):\n    model.load_state_dict(torch.load(path, map_location=DEVICE))\n    model.to(DEVICE)\n    model.eval()\n\n    features = torch.zeros(1, feature_length).to(DEVICE)\n    for X in dataloader:\n        X = X.to(DEVICE)\n        with torch.no_grad():\n            output = model(X)\n        features = torch.cat((features, output.view(-1, feature_length)), dim=0)\n    \n    return features[1:].detach().cpu().numpy()\n\n\ndef predict_batch(model=None, dataloader=None, mode=\"test\", path=None):\n    model.load_state_dict(torch.load(path, map_location=DEVICE)[\"model_state_dict\"])\n    model.to(DEVICE)\n    model.eval()\n\n    y_pred = torch.zeros(1, 1).to(DEVICE)\n    if re.match(r\"valid\", mode, re.IGNORECASE):\n        for X, _ in dataloader:\n            X = X.to(DEVICE)\n            with torch.no_grad():\n                output = model(X)\n            y_pred = torch.cat((y_pred, output.view(-1, 1)), dim=0)\n    elif re.match(r\"test\", mode, re.IGNORECASE):\n        for X in dataloader:\n            X = X.to(DEVICE)\n            with torch.no_grad():\n                output = model(X)\n            y_pred = torch.cat((y_pred, output.view(-1, 1)), dim=0)\n    \n    return y_pred[1:].detach().cpu().numpy()","5404d32f":"def submit():\n    ts_filenames = get_filenames(PATH)\n    filenames, targets = get_filenames_and_targets(PATH)\n    \n    VisionModel, ANNModel = build_models(IL=FEATURE_LENGTH, pretrained=False, seed=SEED)\n    \n    ts_image_data_setup = ImageDS(base_path=os.path.join(PATH, \"test\"), \n                                  filenames=ts_filenames, \n                                  image_size=IMAGE_SIZE, \n                                  transform=TRANSFORM)\n    ts_image_data = DL(ts_image_data_setup, batch_size=64, shuffle=False)\n    ts_features = get_features(model=VisionModel, dataloader=ts_image_data, \n                               feature_length=FEATURE_LENGTH, \n                               path=os.path.join(PRETRAINED_WEIGHTS_PATH, \"{}_state.pt\".format(MODEL_NAME)))\n    \n    breaker()\n    print(\"Making Predictions on Test Features ...\")\n    breaker()\n    \n    fold = 1\n    final_y_pred = np.zeros((len(ts_filenames), 1))\n    for tr_idx, va_idx in KFold(n_splits=NUM_FOLDS, shuffle=True, random_state=SEED).split(filenames):\n        print(\"Processing Fold {} ...\".format(fold))\n        \n        tr_targets = targets[tr_idx]\n        tr_targets = tr_targets.reshape(-1, 1)\n        tr_targets = sc_y.fit_transform(tr_targets)\n    \n        ts_feature_data_setup = FeatureDS(features=ts_features)\n        ts_feature_data = DL(ts_feature_data_setup, batch_size=512, shuffle=False)\n\n        y_pred = predict_batch(model=ANNModel, dataloader=ts_feature_data, mode=\"test\",\n                               path=os.path.join(TRAINED_ANN_WEIGHTS_PATH, \"Fold_{}_state.pt\".format(fold)))\n        y_pred = sc_y.inverse_transform(y_pred)\n        \n        final_y_pred += y_pred\n        fold += 1\n    \n    final_y_pred = final_y_pred \/ NUM_FOLDS\n    \n    breaker()\n    print(\"Generating Submission File ...\")\n    make_submission(PATH, final_y_pred)\n    breaker()","b1bd8c0b":"submit()","5fe26816":"breaker()\nprint(\"Notebook Run Time : {:.2f} minutes\".format((time()-notebook_start_time)\/60))\nbreaker()","aaa8eeb5":"## Library Imports","a9b3b61b":"## Build Models","2a1c2c34":"## Constants and Utilities","08a42022":"## Feature Getter and Predict Helper","576588e9":"## Dataset Templates","8017f26a":"## Generate Submission"}}