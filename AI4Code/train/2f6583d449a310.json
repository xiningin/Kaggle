{"cell_type":{"ccf44068":"code","04575dd9":"code","6da9f131":"code","15fe6590":"code","a225f079":"code","563df384":"code","1a2b540d":"code","355b81c5":"code","f8c9666e":"markdown","9f84b1b2":"markdown","ef8571ca":"markdown"},"source":{"ccf44068":"import tensorflow as tf\nimport keras \nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport cv2\nimport os\nimport sys\nimport random","04575dd9":"from keras.preprocessing.image import ImageDataGenerator\ntest_dir = '..\/input\/neuron-cy5-images\/neuron cy5 test data\/Neuron Cy5 Test Data'\ninput_size = 331\n\n# Keras data generator to load image samples in batches\ndata_gen = ImageDataGenerator(samplewise_center=True,\n                              samplewise_std_normalization=True)\ntest_gen = data_gen.flow_from_directory(test_dir,\n                                        target_size=(input_size,input_size),\n                                        color_mode='grayscale',\n                                        class_mode='categorical',\n                                        batch_size=1,\n                                        shuffle=True)\n\nclasses = dict((v, k) for k, v in test_gen.class_indices.items())\nnum_classes = len(classes)\nnum_samples = len(test_gen)","6da9f131":"from tensorflow.python.keras.models import Model\nfrom tensorflow.python.keras.applications import VGG19\nfrom tensorflow.python.keras.layers import GlobalMaxPooling2D, Dense\n\n# Create a VGG19 architecture\npretrained_model = VGG19(include_top=False,\n                         pooling='none',\n                         input_shape=(input_size, input_size, 3),\n                         weights=None)\nx = GlobalMaxPooling2D()(pretrained_model.output)\nx = Dense(2048, activation='relu')(x)\nx = Dense(2048, activation='relu')(x)\noutput = Dense(num_classes, activation='softmax')(x)\nvgg19_model = Model(pretrained_model.input, output)\n\n# Create new model with modified config which accepts the input shape: [input_size, input_size, 1]\ncfg = vgg19_model.get_config()\ncfg['layers'][0]['config']['batch_input_shape'] = (None, input_size, input_size, 1)\nmodel = Model.from_config(cfg)\n\n# Load in the weights from training\nweights_dir = '..\/input\/fitting-deeper-networks-vgg19\/VGG19_weights.h5'\nmodel.load_weights(weights_dir)","15fe6590":"y_true = np.empty([num_samples, 2])\ny_pred = np.empty([num_samples, 2])\nX = np.empty([input_size, input_size, 1])\n\n# Generate predictions on the test set\nfor i in range(num_samples):\n    prog = ' Progress: '+str(i+1)+'\/'+str(num_samples)\n    X, y_true[i,:] = next(test_gen)\n    y_pred[i,:] = model.predict(X, steps=1)\n    sys.stdout.write('\\r'+prog)\nsys.stdout.write('\\rDone                ')","a225f079":"from sklearn.metrics import roc_curve, auc\nfpr = dict()\ntpr = dict()\nthresholds = dict()\nroc_auc = dict()\n\n# Compute False Positive and True Positive Rates for each class\nfor i in range(num_classes):\n    fpr[i], tpr[i], thresholds[i] = roc_curve(y_true[:, i], y_pred[:, i], drop_intermediate=False)\n    roc_auc[i] = auc(fpr[i], tpr[i])","563df384":"# Show the ROC curve for each class\nfig, ax = plt.subplots(1, 2, figsize=(20, 10))\nfor i in range(num_classes):\n    ax[i].plot(fpr[i], tpr[i], color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc[i])\n    ax[i].plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')\n    ax[i].set_xlim([0.0, 1.0])\n    ax[i].set_ylim([0.0, 1.05])\n    ax[i].set_xlabel('False Positive Rate', fontsize=20)\n    ax[i].set_ylabel('True Positive Rate', fontsize=20)\n    ax[i].set_title('ROC Curve for class: '+classes[i], fontsize=20)\n    ax[i].legend(loc=\"lower right\", prop={'size': 20})","1a2b540d":"J_stats = [None]*num_classes\nopt_thresholds = [None]*num_classes\n\n# Compute Youden's J Statistic for each class\nfor i in range(num_classes):\n    J_stats[i] = tpr[i] - fpr[i]\n    opt_thresholds[i] = thresholds[i][np.argmax(J_stats[i])]\n    print('Optimum threshold for '+classes[i]+': '+str(opt_thresholds[i]))","355b81c5":"# Save optimal statistics to a csv file\ndf = pd.DataFrame(opt_thresholds)\ndf.to_csv(\"optimum_thresholds.csv\")","f8c9666e":"To get a more in depth idea of how well the model performs, the [ROC curve](https:\/\/en.wikipedia.org\/wiki\/Receiver_operating_characteristic) is plotted.","9f84b1b2":"The model is then used to generate predictions on the test set and these predictions are used to give the ROC curve for each class","ef8571ca":"Youden's J Statistic, $J = sensitivity + specificity - 1$ is the distance between the ROC curve and the \"chance line\" - the ROC curve of a classifier that guesses randomly.  The optimal threshold is that which maximises the J Statistic."}}