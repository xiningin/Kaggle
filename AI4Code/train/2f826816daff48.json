{"cell_type":{"1f6ba9ce":"code","2d762d26":"code","7a54b443":"code","0abc06f3":"code","31759425":"code","6919dd2d":"code","164be128":"code","3bea9371":"code","bfdf6d82":"code","6b5b74cd":"code","d7c9a547":"code","7d04de97":"code","b248ce65":"code","c295e074":"code","2d41857e":"code","aea4829c":"code","92391c97":"code","5ae7b2bb":"code","0a6c34ed":"markdown","d1c87913":"markdown","06ef6c06":"markdown","1af4faeb":"markdown"},"source":{"1f6ba9ce":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nimport torch\nimport torchvision\nfrom torch.utils.data import random_split\nfrom torch.utils.data.dataloader import DataLoader\nfrom torchvision.utils import make_grid\nfrom torchvision.datasets import ImageFolder\nfrom torchvision.transforms import ToTensor\nimport torch.nn as nn\nfrom torch.optim import Adam\nfrom torch.autograd import Variable","2d762d26":"# Main data directory\n\ndata_dir = '..\/input\/cifar10-pngs-in-folders\/cifar10'","7a54b443":"# Data\n\ndataset = ImageFolder(data_dir+'\/train', transform=ToTensor())\ntest_data = ImageFolder(data_dir+'\/test', transform=ToTensor())","0abc06f3":"# Function to display image\n\ndef show_example(img, label):\n    print('Label: ', dataset.classes[label], \"(\"+str(label)+\")\")\n    plt.imshow(img.permute(1, 2, 0))","31759425":"show_example(*dataset[6598])","6919dd2d":"show_example(*dataset[11469])","164be128":"batch_size = 64","3bea9371":"train_dl = DataLoader(dataset, batch_size, shuffle=True)\ntest_dl = DataLoader(test_data, batch_size*2)","bfdf6d82":"# Displaying a batch of images in a grid\n\ndef show_batch(dl):\n    for images, labels in dl:\n        fig, ax = plt.subplots(figsize=(10, 5))\n        ax.set_xticks([]); ax.set_yticks([])\n        ax.imshow(make_grid(images, nrow=16).permute(1, 2, 0))\n        break","6b5b74cd":"# Batch of train data\n\nshow_batch(train_dl)","d7c9a547":"# Batch of test data\n\nshow_batch(test_dl)","7d04de97":"class Net(nn.Module):\n    def __init__(self, num_classes=10):\n        super(Net, self).__init__()\n        \n        # Input shape: (64, 3, 32, 32)\n        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, stride=1, padding=1)    # Shape: (64, 32, 32, 32)     \n        self.relu1 = nn.ReLU()                                               # Shape: (64, 32, 32, 32)\n        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)   # Shape: (64, 64, 32, 32)\n        self.relu2 = nn.ReLU()                                               # Shape: (64, 64, 32, 32)\n        self.pool1 = nn.MaxPool2d(kernel_size=2)                             # Shape: (64, 64, 16, 16)\n        \n        self.conv3 = nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=1)    # Shape: (64, 128, 16, 16)     \n        self.relu3 = nn.ReLU()                                                 # Shape: (64, 128, 16, 16)\n        self.conv4 = nn.Conv2d(128, 128, kernel_size=3, stride=1, padding=1)   # Shape: (64, 128, 16, 16)\n        self.relu4 = nn.ReLU()                                                 # Shape: (64, 128, 16, 16)\n        self.pool2 = nn.MaxPool2d(kernel_size=2)                               # Shape: (64, 128, 8, 8)\n        \n        self.conv5 = nn.Conv2d(128, 256, kernel_size=3, stride=1, padding=1)   # Shape: (64, 256, 8, 8)     \n        self.relu5 = nn.ReLU()                                                 # Shape: (64, 256, 8, 8)\n        self.conv6 = nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1)   # Shape: (64, 256, 8, 8)\n        self.relu6 = nn.ReLU()                                                 # Shape: (64, 256, 8, 8)\n        self.pool3 = nn.MaxPool2d(kernel_size=2)                               # Shape: (64, 256, 4, 4)\n        \n        self.fc = nn.Linear(in_features=256*4*4, out_features=num_classes)    # Fully Connected Layer\n        \n        \n    def forward(self, input):\n        output = self.conv1(input)\n        output = self.relu1(output) \n        output = self.conv2(output)  \n        output = self.relu2(output)\n        output = self.pool1(output)\n        output = self.conv3(output)\n        output = self.relu3(output) \n        output = self.conv4(output)  \n        output = self.relu4(output)\n        output = self.pool2(output)\n        output = self.conv5(output)\n        output = self.relu5(output) \n        output = self.conv6(output)  \n        output = self.relu6(output)\n        output = self.pool3(output)     \n       \n        output = output.view(-1, 256*4*4)    # Reshape the output\n        output = self.fc(output)\n        \n        return output","b248ce65":"# Checking for device\n\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\nprint(device)","c295e074":"model = Net(num_classes=10).to(device)","2d41857e":"print(model)","aea4829c":"# Optimizer and Loss Function\n\noptimizer = Adam(model.parameters(), lr=0.0001)\nloss_function = nn.CrossEntropyLoss()","92391c97":"epochs = 10","5ae7b2bb":"# Training\n\nbest_acc = 0.0\n\nfor epoch in range(epochs):\n    # Training\n    model.train()\n    train_accuracy = 0.0\n    train_loss = 0.0\n    # For each batch in train_dl\n    for i,(images, labels) in enumerate(train_dl):\n        if torch.cuda.is_available():\n            images=Variable(images.cuda())\n            labels=Variable(labels.cuda())\n        \n        optimizer.zero_grad()    # Making the gradients 0 at the start of a new batch\n        \n        outputs = model(images)\n        loss = loss_function(outputs, labels)\n        loss.backward()     # Backpropagation\n        optimizer.step()    # Update the weight and bias\n        \n        train_loss += loss.cpu().data*images.size(0)    # loss.cpu().data = loss\n        _, prediction = torch.max(outputs.data, 1)\n        \n        train_accuracy += int(torch.sum(prediction==labels.data))\n        \n    train_loss = train_loss\/len(dataset)\n    train_accuracy = train_accuracy\/len(dataset)\n    \n    # Evaluation on Validation data\n    model.eval()\n    test_loss = 0.0\n    test_accuracy = 0.0\n    # For each batch in test_dl\n    for i,(images, labels) in enumerate(test_dl):\n        if torch.cuda.is_available():\n            images=Variable(images.cuda())\n            labels=Variable(labels.cuda())\n        \n        outputs = model(images)\n        loss = loss_function(outputs, labels)\n        \n        test_loss += loss.cpu().data*images.size(0)    # loss.cpu().data = loss\n        _, prediction = torch.max(outputs.data, 1)\n        \n        test_accuracy += int(torch.sum(prediction==labels.data))\n        \n    test_loss = test_loss\/len(test_data)\n    test_accuracy = test_accuracy\/len(test_data)\n    \n    print('Epoch: '+str(epoch)+' Train Loss: '+str(train_loss)+' Train Accuracy: '+str(train_accuracy)+' Test Loss: '+str(test_loss)+' Test Accuracy: '+str(test_accuracy))\n    ","0a6c34ed":"## Importing libraries","d1c87913":"## Model","06ef6c06":"## Loading the dataset","1af4faeb":"### The accuracy on test data is 71.07%"}}