{"cell_type":{"76731eea":"code","6b9caaa6":"code","18d5dc83":"code","66f6b1c1":"code","4151bff7":"code","2899ac83":"code","85d6d9eb":"code","973068e4":"code","19b83d51":"code","c8a3abdf":"code","de05cbdf":"code","203c8535":"code","1a709a40":"code","4e88a375":"code","1eee7a11":"code","c4ab92b6":"code","bce443bb":"code","dd5a218c":"code","1303a86c":"code","579eee3c":"code","0f6b48db":"code","6f3a5cfb":"code","31f23c6b":"code","6c7166d1":"code","8ee2997d":"code","3a4c9c71":"code","11fed36d":"code","281e9281":"markdown","f9edb01b":"markdown","8dd492be":"markdown","7b167532":"markdown","c319459c":"markdown","dc9f34e4":"markdown","62bd9bd3":"markdown","94d199ea":"markdown","5bc558b3":"markdown","ca7fcc87":"markdown"},"source":{"76731eea":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","6b9caaa6":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import TensorDataset, DataLoader\nfrom torch.optim import SGD\nimport torch.nn.functional as F \n\nfrom sklearn.impute import KNNImputer # to deal with missing values\n\nfrom sklearn.preprocessing import MinMaxScaler # to rescale the data\n\nfrom seaborn import histplot","18d5dc83":"# loading the data\ntrain_original = pd.read_csv(\"\/kaggle\/input\/song-popularity-prediction\/train.csv\")\ntest_original = pd.read_csv(\"\/kaggle\/input\/song-popularity-prediction\/test.csv\")\nsample_submission = pd.read_csv(\"\/kaggle\/input\/song-popularity-prediction\/sample_submission.csv\")","66f6b1c1":"train_original.info()","4151bff7":"for c in train_original.columns:\n    c_unique =  np.unique(train_original[c].dropna()) # dropping the nan then counting the number of unique values\n    print(c, len(c_unique))","2899ac83":"to_categorical = {'key': 'category', 'audio_mode':'category', 'time_signature':'category'}\n\nfor k in to_categorical:\n    train_original[k].astype('category')\n    test_original[k].astype('category')\n#train_original.info()\n","85d6d9eb":"train_original.columns","973068e4":"# rescaling\nrescaled_train = train_original.copy()\nrescaled_test = test_original.copy()\nignore_columns = ['id', 'audio_mode', 'time_signature','song_popularity']\nscaler_dict = {}\n\nfor column in train_original.columns:\n    if column not in ignore_columns:\n        print(column)\n        scaler = MinMaxScaler(feature_range=(-0.5,0.5)) \n        transformed_column = scaler.fit_transform(train_original[column].values.reshape(40000,1))\n        rescaled_train[column] = transformed_column.squeeze()\n        rescaled_test[column] = scaler.transform(test_original[column].values.reshape(10000,1))\n        scaler_dict[column] = scaler\n        \n","19b83d51":"scaler_dict","c8a3abdf":"rescaled_train","de05cbdf":"train_original","203c8535":"#unique, count = np.unique(train_original[\"time_signature\"], return_counts=True)\n#unique, count # change to histogram when sharing \nhistplot(train_original[\"time_signature\"], discrete=True)\n","1a709a40":"\nimputer_continuous = KNNImputer(n_neighbors=15,weights='distance')\nimputed_train = rescaled_train.copy()\nimputed_test = rescaled_test.copy()\n# let the imputation use the song_popularity column and add song_popularity to the test data but\n# set it to 0.5 so that it does not contribute to the imputation. \nimputed_train = imputed_train.drop(columns='id') \nimputed_test = imputed_test.drop(columns='id')\nimputed_test['song_popularity']= 0.5\n\nimputed_train = pd.DataFrame(imputer_continuous.fit_transform(imputed_train), columns = imputed_train.columns)\nimputed_test = pd.DataFrame(imputer_continuous.transform(imputed_test), columns = imputed_test.columns)\n","4e88a375":"imputer_key = KNNImputer(n_neighbors=1)\nrescaled_train['key'] = train_original['key']\nrescaled_test['key'] = test_original['key']\n\n#print(imputed_train.info())\ntemp = pd.DataFrame(imputer_key.fit_transform(rescaled_train.drop(columns='id')), columns = imputed_train.columns)\nimputed_train['key'] = temp['key']\nimputed_train\n\nrescaled_test['song_popularity']=0.5\ntemp = pd.DataFrame(imputer_key.transform(rescaled_test.drop(columns='id')), columns = imputed_train.columns)\nimputed_test['key'] = temp['key']\nimputed_test = imputed_test.drop(columns='song_popularity') # drop the song popularity column since we do not need it anymore\nimputed_test.info()","1eee7a11":"train_original","c4ab92b6":"imputed_test","bce443bb":"new_order = ['song_duration_ms', 'acousticness', 'danceability', 'energy',\n       'instrumentalness', 'liveness', 'loudness',\n       'speechiness', 'tempo', 'audio_valence','key', 'audio_mode', 'time_signature',\n       ]\nreord_imputed_train=imputed_train[new_order]\nreord_imputed_train_label = imputed_train['song_popularity']\nreord_imputed_test = imputed_test[new_order]","dd5a218c":"x_train = torch.from_numpy(reord_imputed_train.values)\ny_train = torch.from_numpy(reord_imputed_train_label.values)\nx_test = torch.from_numpy(reord_imputed_test.values)\ntrain_dataset = TensorDataset(x_train,y_train)\ntrain_loader = DataLoader(train_dataset, batch_size=256,shuffle=True)\ntest_dataset = TensorDataset(x_test)\ntest_loader = DataLoader(test_dataset, batch_size=128,shuffle=False)","1303a86c":"device = torch.device(\"cuda\") if torch.cuda.is_available() else torch.device(\"cpu\")\nprint(device)","579eee3c":"class spp_mlp(nn.Module):\n    def __init__(self, num_neurons=64,drop_prob=0.00, lrelu_slope=0.00):\n        super(spp_mlp, self).__init__()\n        dim_continuous = 10\n        dim_key_embedding = 4\n        dim_ts_embedding = 2\n        dim_am_embedding = 2\n        dim_mlp_input = dim_continuous + dim_key_embedding + dim_ts_embedding + dim_am_embedding\n        self.key_embedding = nn.Embedding(12,dim_key_embedding).to(device) # 12 different values and each being embedded in a dim_key_embedding-dimensional vector\n        self.time_signature_embedding= nn.Embedding(4,dim_ts_embedding).to(device)\n        self.audio_mode_embedding = nn.Embedding(2,dim_am_embedding).to(device)\n        self.fc1 = nn.Linear(dim_mlp_input,num_neurons)\n        self.fc2 = nn.Linear(num_neurons,num_neurons)\n        self.output = nn.Linear(num_neurons,2)\n        self.dropout = nn.Dropout(p=drop_prob)\n        self.lrelu = nn.LeakyReLU(lrelu_slope)\n    \n    def forward(self,x):\n        continuous = x[:,:10].to(device)\n        categorical = x[:,10:].type(torch.LongTensor).to(device)\n        key_embedding = self.key_embedding(categorical[:,0]).clone().to(device)\n        am_embedding =self.audio_mode_embedding(categorical[:,1]).clone().to(device)\n        ts_embedding = self.time_signature_embedding(categorical[:,2]-2).clone().to(device) # -2 to bring the values from [2,3,4,5] to [0,1,2,3]\n        \n        \n        tensors_list = (continuous,key_embedding,ts_embedding,am_embedding)\n        mlp_input = torch.cat(tensors_list,1).to(device)\n        #print(mlp_input.shape)\n        \n        fc1 = self.fc1(mlp_input)\n        fc1 = self.lrelu(fc1)\n        fc1 = self.dropout(fc1)\n        \n        fc2 = self.fc2(fc1)\n        fc2 = self.lrelu(fc2)\n        fc2 = self.dropout(fc2)\n        \n        logit =self.output(fc2)\n        \n        return logit\n    \n    def train_1epoch(self,train_loader, optimizer, device = 'cpu'):\n        self.train()\n        weight = torch.tensor([1.\/3,2.\/3]).double()\n        for batch_x, batch_y in train_loader:\n            logit = self(batch_x.to(device))\n            label = batch_y.type(torch.LongTensor).to(device)\n            \n            \n            #loss = F.cross_entropy(logit,label,weight)\n            loss = F.cross_entropy(logit.to(device),label.to(device))\n            #print(f'loss before backward: {loss}')\n            loss.backward()\n            optimizer.step()\n            optimizer.zero_grad(set_to_none=True)#https:\/\/pytorch.org\/docs\/stable\/generated\/torch.optim.Optimizer.zero_grad.html\n            \n            #logit = self(batch_x)\n            #loss = F.cross_entropy(logit,label)\n            #print(f'loss after backward {loss}')\n            \n            \n    def evaluate(self,data_loader,device='cpu'):\n        self.eval()\n        eval_loss =0\n        accuracy = 0\n        w = torch.tensor([1.\/3,2.\/3]).double()\n        \n        #with torch.no_grad():\n        for batch_x, batch_y in data_loader:\n            logit = self(batch_x.to(device))\n            label = batch_y.type(torch.LongTensor).to(device)\n            #eval_loss += F.cross_entropy(logit, label, w,  reduction='sum')\n            eval_loss += F.cross_entropy(logit.to(device), label.to(device),  reduction='sum')\n            pred = logit.argmax(dim=int(1)).to(device)\n            accuracy += torch.sum(pred==label).double()\n        n_elements = len(data_loader.dataset)\n        return accuracy\/n_elements, eval_loss\/n_elements","0f6b48db":"from torch.optim import AdamW\n\nmlp = spp_mlp(num_neurons=1024)\nmlp.double()\nmlp = mlp.to(device)\n\n\naccuracy, loss = mlp.evaluate(train_loader)\nprint(f'the accuracy before trainig is : {accuracy} and the average loss is : {loss}')\n\nnum_epoch = 10\noptimizer = AdamW(mlp.parameters(), lr = 5e-5)\nfor i in range(num_epoch):\n    mlp.train_1epoch(train_loader, optimizer)\n    accuracy, loss = mlp.evaluate(train_loader)\n    print(f'epoch : {i} accuracy: {accuracy:.4f} loss: {loss:.4f}')\n    ","6f3a5cfb":"for i in range(10):\n    mlp.train_1epoch(train_loader, optimizer)\n    accuracy, loss = mlp.evaluate(train_loader)\n    #if i%4==0:\n    print(f'epoch : {i} accuracy: {accuracy:.4f} loss: {loss:.4f}')","31f23c6b":"# compute AUC on the training set \nfrom sklearn.metrics import roc_auc_score\n\nlogit = mlp(train_dataset[:][0])\nsoftmax = F.softmax(logit,dim=1).cpu().detach().numpy()\nlabel = train_dataset[:][1]\ntrain_auc = roc_auc_score(label,softmax[:,1])\nprint(train_auc)","6c7166d1":"torch.save(mlp.state_dict(), \"\/kaggle\/working\/spp_mlp_embedding.pth\")","8ee2997d":"#optimizer.param_groups[0]['lr'] *= 0.75\n #print(optimizer.param_groups[0]['lr'])","3a4c9c71":"logit = mlp(test_dataset[:][0])\nsoftmax = F.softmax(logit).cpu().detach().numpy()\nsoftmax, logit","11fed36d":"# submission \nsubmission = pd.read_csv(\"..\/input\/song-popularity-prediction\/sample_submission.csv\")\n\n\nlogit = mlp(test_dataset[:][0])\nsoftmax = F.softmax(logit).cpu().detach().numpy()\n#label = test_dataset[:][1]\n\nsubmission['song_popularity'] = softmax[:,1]\nsubmission\n#submission.to_csv(f\"sample_submission_{train_auc:.2f}_on_train.csv\", index=False)\nsubmission.to_csv(\"sample_submission.csv\",index=False)","281e9281":"\n### Imputing the categorical value, 'key'","f9edb01b":"# loading the data\n\nand get basic information about it","8dd492be":"### Imputing continuous values","7b167532":"### Preparing the dataset to be used with dataloader","c319459c":"# imports","dc9f34e4":"So key, audio_mode and time_signature are categorical features. We are going to use embeddings to deal with them and harness the power of multi-layer perceptron. We inform the train_original dataframe that those features are categorical in the following cell. ","62bd9bd3":"# comment : \nThe only categorical feature having missing values is 'key'. And since 'audio_mode' takes only two values, 0 and 1, it does not matter if it is ordinal or not.\nRegarding the 'time_signature', we assume it is ordinal and hence can be used to compute distance. Furthermore, 'time_signature' takes only 4 values [2,3,4,5] and mostly takes value 3 and 4 and rarely 2 and 5.\nSo we are going to consider them as ordinale and use them to compute distances in the KNNImputer. ","94d199ea":"### training the model \n\n\n","5bc558b3":"# dealing with missing values using the KNNImputer of sklearn\n\n1. We will first rescale all the numerical columns to be between -0.5 and 0.5 to have the same order of magnitude when using the KNNImputer.\n\n2. Then we use the KNNImputer to fit the numerical columns using the mean of the nearest neighbors.\n\n3. Then we use the KNNImputer to fit the categorical values using the most represented category. ","ca7fcc87":"# creating the spp_mlp class, a neural network class to predict \nHopefully predictions are more accurate than tree based models' prediction.  "}}