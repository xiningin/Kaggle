{"cell_type":{"3a54c852":"code","5202ca21":"code","207b509e":"code","84a8edf5":"code","9293975f":"code","6fc71995":"code","8383001b":"markdown","096f0c46":"markdown","256ad692":"markdown","d6bc9cb3":"markdown","2ba01a94":"markdown","2af1f0d0":"markdown"},"source":{"3a54c852":"def binary_search(a, key):\n    \"\"\"\n    inputs:\n        a: is a sorted list of integers\n        key: is the number to search in list a\n    output:\n        returns the index of key if exists in a, -1 if not found\n    \"\"\"\n    lo = 0\n    hi = len(a)-1\n    while lo <= hi:\n        mid = int(lo + (hi-lo)\/2)\n        if key < a[mid]:\n            hi = mid - 1  # If the key is smaller than the middle number, we need to skip the middle number \n        elif key > a[mid]:\n            lo = mid + 1  # if the key is larger than the middle number, we need to skip the middle number\n                          # That is why we add one\n        else:\n            return mid # return the index of key in the list a\n    return -1 # the key is not found in the list, so return -1","5202ca21":"# let's test it with a simple list (the number of elements is an EVEN number)\na = [1,2,3,4,5,6]\nprint(binary_search(a, 1)) # The key is in the leftmost index\nprint(binary_search(a, 2))\nprint(binary_search(a, 3))\nprint(binary_search(a, 6)) # The key is in the rightmost index","207b509e":"a = [1,2,3,3,3,3,4,4,4,4,5]\nprint(binary_search(a, 1))\nprint(binary_search(a, 3))","84a8edf5":"# what if the key is not in the list\na = [1,2,4,5,6,7]\nprint(binary_search(a, 7))\nprint(binary_search(a, 3))\nprint(binary_search(a, 30))","9293975f":"a = [1,1,1,1]\nprint(binary_search(a, 1))\nprint(binary_search(a, 2))","6fc71995":"# what if the list is empty\na = []\nprint(binary_search(a, 1))\nprint(binary_search(a, 2))","8383001b":"Binary search uses at most 1+lg(N) compares to search in a sorted array of size N.\n\nDef: T(N) is the number of compares to binary search in a sorted array of size N.\n\nProof:\n\n    T(N) <= T(N\/2) + 1\n         <= T(N\/2) + 1 + 1\n         <= T(N\/2) + 1 + 1 + 1 \n         .\n         .\n         .\n         <= T(N\/2) + 1 + 1 ... + 1\n         = 1+ lg (N)\n    \n    \nand the number of array accesses equals the number of compares (so, it is logarithmic)","096f0c46":"## This is so-called iterative approach (not recursive approach)","256ad692":"This notebook presents the implementation of binary search in Python. Although the binary search algorithm seems very simple, its implementation is not! \n\n\"First binary seach published in 1946, first bug-free one in 1962, and bug in Java's Arrays.binarySearch() discovered in 2006\"!! For more details see this [course](https:\/\/www.coursera.org\/learn\/algorithms-part1\/lecture\/Xk03a\/order-of-growth-classifications). \n\n\nThe following function assumes that the list (or array) is already sorted ascending.","d6bc9cb3":"# Examples \/ Edge Cases","2ba01a94":"# Introduction","2af1f0d0":"# Binary Search: Mathematical Analysis"}}