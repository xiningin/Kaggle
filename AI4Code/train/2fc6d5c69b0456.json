{"cell_type":{"37f23ea3":"code","42260a23":"code","0254d35c":"code","9920f374":"code","1c44d4c7":"code","0976218c":"code","001fbec5":"code","8df2e9bf":"code","5319b1ea":"code","52edfb67":"code","d0512fe6":"code","8b505225":"code","3a6f1ad3":"code","ed935d35":"code","fe9ad9a8":"code","c2a759a7":"code","3e102b9d":"code","5563d67d":"code","52e11c5d":"code","8c63f948":"code","326c228e":"code","7ef0c55a":"code","d2942319":"markdown","d34e7f29":"markdown","11b46b53":"markdown","b1b8273c":"markdown","f80231d9":"markdown","5e363cbc":"markdown","98f7771d":"markdown","5fa5c589":"markdown"},"source":{"37f23ea3":"import numpy as np\nimport torch\n\nprint(\"Torch version:\", torch.__version__)\nprint('Cuda available?',torch.cuda.is_available())","42260a23":"MODELS = {\n    \"ViT-B\/32\":       \"https:\/\/openaipublic.azureedge.net\/clip\/models\/40d365715913c9da98579312b702a82c18be219cc2a73407c4526f58eba950af\/ViT-B-32.pt\",\n}","0254d35c":"# Download the model weights\n! wget {MODELS[\"ViT-B\/32\"]} -O model.pt","9920f374":"model = torch.load(\"model.pt\").cuda().eval()\ninput_resolution = model.input_resolution.item()\ncontext_length = model.context_length.item()\nvocab_size = model.vocab_size.item()\n\nprint(\"Model parameters:\", f\"{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}\")\nprint(\"Input resolution:\", input_resolution)\nprint(\"Context length:\", context_length)\nprint(\"Vocab size:\", vocab_size)","1c44d4c7":"from torchvision.transforms import Compose, Resize, CenterCrop, ToTensor, Normalize\nfrom PIL import Image\n\npreprocess = Compose([\n    Resize(input_resolution, interpolation=Image.BICUBIC),\n    CenterCrop(input_resolution),\n    ToTensor()\n])\n\nimage_mean = torch.tensor([0.48145466, 0.4578275, 0.40821073]).cuda()\nimage_std = torch.tensor([0.26862954, 0.26130258, 0.27577711]).cuda()","0976218c":"! pip install ftfy regex\n! wget https:\/\/openaipublic.azureedge.net\/clip\/bpe_simple_vocab_16e6.txt.gz -O bpe_simple_vocab_16e6.txt.gz","001fbec5":"import gzip\nimport html\nimport os\nfrom functools import lru_cache\n\nimport ftfy\nimport regex as re\n\n\n@lru_cache()\ndef bytes_to_unicode():\n    \"\"\"\n    Returns list of utf-8 byte and a corresponding list of unicode strings.\n    The reversible bpe codes work on unicode strings.\n    This means you need a large # of unicode characters in your vocab if you want to avoid UNKs.\n    When you're at something like a 10B token dataset you end up needing around 5K for decent coverage.\n    This is a signficant percentage of your normal, say, 32K bpe vocab.\n    To avoid that, we want lookup tables between utf-8 bytes and unicode strings.\n    And avoids mapping to whitespace\/control characters the bpe code barfs on.\n    \"\"\"\n    bs = list(range(ord(\"!\"), ord(\"~\")+1))+list(range(ord(\"\u00a1\"), ord(\"\u00ac\")+1))+list(range(ord(\"\u00ae\"), ord(\"\u00ff\")+1))\n    cs = bs[:]\n    n = 0\n    for b in range(2**8):\n        if b not in bs:\n            bs.append(b)\n            cs.append(2**8+n)\n            n += 1\n    cs = [chr(n) for n in cs]\n    return dict(zip(bs, cs))\n\n\ndef get_pairs(word):\n    \"\"\"Return set of symbol pairs in a word.\n    Word is represented as tuple of symbols (symbols being variable-length strings).\n    \"\"\"\n    pairs = set()\n    prev_char = word[0]\n    for char in word[1:]:\n        pairs.add((prev_char, char))\n        prev_char = char\n    return pairs\n\n\ndef basic_clean(text):\n    text = ftfy.fix_text(text)\n    text = html.unescape(html.unescape(text))\n    return text.strip()\n\n\ndef whitespace_clean(text):\n    text = re.sub(r'\\s+', ' ', text)\n    text = text.strip()\n    return text\n\n\nclass SimpleTokenizer(object):\n    def __init__(self, bpe_path: str = \"bpe_simple_vocab_16e6.txt.gz\"):\n        self.byte_encoder = bytes_to_unicode()\n        self.byte_decoder = {v: k for k, v in self.byte_encoder.items()}\n        merges = gzip.open(bpe_path).read().decode(\"utf-8\").split('\\n')\n        merges = merges[1:49152-256-2+1]\n        merges = [tuple(merge.split()) for merge in merges]\n        vocab = list(bytes_to_unicode().values())\n        vocab = vocab + [v+'<\/w>' for v in vocab]\n        for merge in merges:\n            vocab.append(''.join(merge))\n        vocab.extend(['<|startoftext|>', '<|endoftext|>'])\n        self.encoder = dict(zip(vocab, range(len(vocab))))\n        self.decoder = {v: k for k, v in self.encoder.items()}\n        self.bpe_ranks = dict(zip(merges, range(len(merges))))\n        self.cache = {'<|startoftext|>': '<|startoftext|>', '<|endoftext|>': '<|endoftext|>'}\n        self.pat = re.compile(r\"\"\"<\\|startoftext\\|>|<\\|endoftext\\|>|'s|'t|'re|'ve|'m|'ll|'d|[\\p{L}]+|[\\p{N}]|[^\\s\\p{L}\\p{N}]+\"\"\", re.IGNORECASE)\n\n    def bpe(self, token):\n        if token in self.cache:\n            return self.cache[token]\n        word = tuple(token[:-1]) + ( token[-1] + '<\/w>',)\n        pairs = get_pairs(word)\n\n        if not pairs:\n            return token+'<\/w>'\n\n        while True:\n            bigram = min(pairs, key = lambda pair: self.bpe_ranks.get(pair, float('inf')))\n            if bigram not in self.bpe_ranks:\n                break\n            first, second = bigram\n            new_word = []\n            i = 0\n            while i < len(word):\n                try:\n                    j = word.index(first, i)\n                    new_word.extend(word[i:j])\n                    i = j\n                except:\n                    new_word.extend(word[i:])\n                    break\n\n                if word[i] == first and i < len(word)-1 and word[i+1] == second:\n                    new_word.append(first+second)\n                    i += 2\n                else:\n                    new_word.append(word[i])\n                    i += 1\n            new_word = tuple(new_word)\n            word = new_word\n            if len(word) == 1:\n                break\n            else:\n                pairs = get_pairs(word)\n        word = ' '.join(word)\n        self.cache[token] = word\n        return word\n\n    def encode(self, text):\n        bpe_tokens = []\n        text = whitespace_clean(basic_clean(text)).lower()\n        for token in re.findall(self.pat, text):\n            token = ''.join(self.byte_encoder[b] for b in token.encode('utf-8'))\n            bpe_tokens.extend(self.encoder[bpe_token] for bpe_token in self.bpe(token).split(' '))\n        return bpe_tokens\n\n    def decode(self, tokens):\n        text = ''.join([self.decoder[token] for token in tokens])\n        text = bytearray([self.byte_decoder[c] for c in text]).decode('utf-8', errors=\"replace\").replace('<\/w>', ' ')\n        return text","8df2e9bf":"import os\nimport skimage\nimport IPython.display\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\n\nfrom collections import OrderedDict\nimport torch\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'","5319b1ea":"# Store the preprocessed images in a list\nimages_chi_or_muf = []\ntexts_chi_or_muf = []\n\nfor filename in [filename for filename in os.listdir('..\/input\/chihuahua-or-muffin\/') if filename.endswith(\".jpeg\") or filename.endswith(\".jpg\")]:\n    name = filename.split('-')[0]\n    image = preprocess(Image.open(os.path.join('..\/input\/chihuahua-or-muffin', filename)).convert(\"RGB\"))\n    images_chi_or_muf.append(image)\n    texts_chi_or_muf.append(name)","52edfb67":"image_input_chi_or_muf = torch.tensor(np.stack(images_chi_or_muf)).cuda()\nimage_input_chi_or_muf -= image_mean[:, None, None]\nimage_input_chi_or_muf \/= image_std[:, None, None]","d0512fe6":"tokenizer = SimpleTokenizer()\nsot_token = tokenizer.encoder['<|startoftext|>']\neot_token = tokenizer.encoder['<|endoftext|>']","8b505225":"with torch.no_grad():\n    image_features_chi_or_muf = model.encode_image(image_input_chi_or_muf).float()","3a6f1ad3":"image_features_chi_or_muf \/= image_features_chi_or_muf.norm(dim=-1, keepdim=True)","ed935d35":"classes = ['chihuahua','muffin']","fe9ad9a8":"text_descriptions = [f\"This is a photo of a {label}\" for label in classes]\ntext_tokens = [[sot_token] + tokenizer.encode(desc) + [eot_token] for desc in text_descriptions]\ntext_input = torch.zeros(len(text_tokens), model.context_length, dtype=torch.long)\n\nfor i, tokens in enumerate(text_tokens):\n    text_input[i, :len(tokens)] = torch.tensor(tokens)\n\ntext_input = text_input.cuda()\ntext_input.shape","c2a759a7":"with torch.no_grad():\n    text_features = model.encode_text(text_input).float()\n    text_features \/= text_features.norm(dim=-1, keepdim=True)\n\ntext_probs = (100.0 * image_features_chi_or_muf @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(2, dim=-1)","3e102b9d":"plt.figure(figsize=(16, 16))\n\nfor i, image in enumerate(images_chi_or_muf[:8]):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image.permute(1, 2, 0))\n    plt.axis(\"off\")\n    plt.title(texts_chi_or_muf[i])\n\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n    plt.yticks(y, [classes[index] for index in top_labels[i].numpy()])\n    plt.xlabel(\"probability\")\n\nplt.subplots_adjust(wspace=0.5)\nplt.show()","5563d67d":"plt.figure(figsize=(16, 16))\n\nfor i, image in enumerate(images_chi_or_muf[8:16]):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image.permute(1, 2, 0))\n    plt.axis(\"off\")\n    plt.title(texts_chi_or_muf[i + 8])\n\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i + 8])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n    plt.yticks(y, [classes[index] for index in top_labels[i + 8].numpy()])\n    plt.xlabel(\"probability\")\n\nplt.subplots_adjust(wspace=0.5)\nplt.show()","52e11c5d":"# For some reason I have to load the model twice\n# When I run with torch.no_grad() model.encode_image, it causes it to fail on the second task\nmodel = torch.load(\"model.pt\").cuda().eval()\ninput_resolution = model.input_resolution.item()\ncontext_length = model.context_length.item()\nvocab_size = model.vocab_size.item()\n\nimages_pup_or_bag = []\ntexts_pup_or_bag = []\n    \nfor filename in [filename for filename in os.listdir('..\/input\/puppy-or-bagel\/') if filename.endswith(\".jpeg\") or filename.endswith(\".jpg\")]:\n    name = filename.split('-')[0]\n    image = preprocess(Image.open(os.path.join('..\/input\/puppy-or-bagel', filename)).convert(\"RGB\"))\n    images_pup_or_bag.append(image)\n    texts_pup_or_bag.append(name)\n\n\nimage_input_pup_or_bag = torch.tensor(np.stack(images_pup_or_bag)).cuda()\nimage_input_pup_or_bag -= image_mean[:, None, None]\nimage_input_pup_or_bag \/= image_std[:, None, None]\n\nwith torch.no_grad():\n    image_features_pup_or_bag = model.encode_image(image_input_pup_or_bag).float()\n\nimage_features_pup_or_bag \/= image_features_pup_or_bag.norm(dim=-1, keepdim=True)","8c63f948":"classes = ['puppy','bagel']\n\ntext_descriptions = [f\"This is a photo of a {label}\" for label in classes]\ntext_tokens = [[sot_token] + tokenizer.encode(desc) + [eot_token] for desc in text_descriptions]\ntext_input = torch.zeros(len(text_tokens), model.context_length, dtype=torch.long)\n\nfor i, tokens in enumerate(text_tokens):\n    text_input[i, :len(tokens)] = torch.tensor(tokens)\n\ntext_input = text_input.cuda()\ntext_input.shape\n\nwith torch.no_grad():\n    text_features = model.encode_text(text_input).float()\n    text_features \/= text_features.norm(dim=-1, keepdim=True)\n\ntext_probs = (100.0 * image_features_pup_or_bag @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(2, dim=-1)","326c228e":"plt.figure(figsize=(16, 16))\n\nfor i, image in enumerate(images_pup_or_bag[:8]):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image.permute(1, 2, 0))\n    plt.axis(\"off\")\n    plt.title(texts_pup_or_bag[i])\n\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n    plt.yticks(y, [classes[index] for index in top_labels[i].numpy()])\n    plt.xlabel(\"probability\")\n\nplt.subplots_adjust(wspace=0.5)\nplt.show()","7ef0c55a":"plt.figure(figsize=(16, 16))\n\nfor i, image in enumerate(images_pup_or_bag[8:16]):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image.permute(1, 2, 0))\n    plt.axis(\"off\")\n    plt.title(texts_pup_or_bag[i + 8])\n\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i + 8])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n    plt.yticks(y, [classes[index] for index in top_labels[i + 8].numpy()])\n    plt.xlabel(\"probability\")\n\nplt.subplots_adjust(wspace=0.5)\nplt.show()","d2942319":"# Zero shot: Puppy or bagel?","d34e7f29":"# Zero shot: Chihuahua or Muffin?","11b46b53":"A few days ago, OpenAI released the code for CLIP. I download a small version of the model. https:\/\/github.com\/openai\/CLIP","b1b8273c":" Following the guide from https:\/\/github.com\/openai\/CLIP\/blob\/main\/Interacting_with_CLIP.ipynb, I look at CLIP's performance on a funny adversarial task: Chihuahua or muffin? Puppy or bagel?","f80231d9":"<img src=\"blob:chrome-untrusted:\/\/media-app\/948ba441-018e-4d65-8908-bd558d5bc7de\" alt=\"Adversarial performance\"\/>![image.png](attachment:image.png)","5e363cbc":"# Looks like CLIP is pretty good.","98f7771d":"Due to being a \"zero-shot\" model, the authors claim CLIP is much more robust to distribution shift than standard ImageNet models. On page 15 they show that CLIP can adapt to Imagenet domain shifts much better than pretrained models, which is probably due to being trained on a diverse variety of images.\n\nFor example, in Imagenet, all photos of bananas are yellow fruits. But CLIP's training dataset is scraped online from literally anything and the labels are assigned by text accompaniments. Which means it probably trained on drawings of bananas, green bananas, dancing bananas, or the album cover of the Velvet Underground.","5fa5c589":"Last week OpenAI revealed CLIP, a neural network which efficiently learns visual concepts from natural language supervision. CLIP (Contrastive Language\u2013Image Pre-training) can be applied to any visual classification benchmark by simply providing the names of the visual categories to be recognized, similar to the \u201czero-shot\u201d capabilities of GPT-2 and 3. (https:\/\/openai.com\/blog\/clip\/)"}}