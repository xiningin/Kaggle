{"cell_type":{"2ba60c8e":"code","1a54bddc":"code","e7db4e25":"code","29aac6ff":"code","3d9ca403":"code","0251e0a9":"code","28bb328a":"code","9517696a":"code","2df7e02d":"code","b54b0fd5":"code","ca9623e8":"code","687c9f88":"code","80349657":"code","f48da1a0":"code","dee761fe":"code","0da44ef2":"code","96fb69c6":"markdown","1b7d7bb3":"markdown","f1f96286":"markdown","ea10b3c3":"markdown","dce16278":"markdown","45f486c9":"markdown"},"source":{"2ba60c8e":"%matplotlib notebook\nimport matplotlib.pyplot as plt\nimport matplotlib\n\nimport numpy as np\nimport scipy as sp\nimport pandas as pd\npd.set_option('display.max_rows', 500)\npd.set_option('display.max_columns', 100)\npd.set_option('max_colwidth', 120)\n   \nfrom IPython.display import display\nfrom tqdm.notebook import tqdm\n\n\nfrom collections import defaultdict\nimport networkx as nx","1a54bddc":"def gb(df,key):\n    groupby = df.groupby(key)\n    return tqdm(groupby,total=groupby.ngroups)","e7db4e25":"print('numpy  :',np.__version__)\nprint('pandas :',pd.__version__)","29aac6ff":"dataTemp =  r'..\/input\/data-science-bowl-2019\/{}.csv'\n\ntrain             = pd.read_csv(dataTemp.format('train'))\ntrain_labels      = pd.read_csv(dataTemp.format('train_labels'))","3d9ca403":"assessments = [x for x in train.title.unique() if 'Assessment' in x]\nworlds      = train.world.unique()\ntitles      = train.title.unique()","0251e0a9":"tupleCounts = defaultdict(lambda:0)\nfor insId,df in gb(train,'installation_id'):\n    sequence  = df.groupby('game_session',sort=False)['title'].first().values\n    for i in range(len(sequence)-1):\n        tupleCounts[(sequence[i],sequence[i+1])] += 1            ","28bb328a":"worldSeqs = {}\n\nworldSeqs['NONE'] = [train[train.world == 'NONE'].title.iloc[0]]\n\nfor world in np.setdiff1d(worlds,['NONE']):\n\n    worldTitles      = train[train.world == world].title.unique()\n    worldTupleCounts = {key:tupleCounts[key] for key in tupleCounts if key[0] in worldTitles and key[1] in worldTitles}\n    seq              = [x for x in worldTitles if 'Level 1' in x]\n\n    while len(seq) < len(worldTitles):\n        \n        # cheating start\n        \n        if seq[-1] == 'Fireworks (Activity)':\n            seq.append('12 Monkeys')\n            continue\n\n        if seq[-1] == 'Air Show':\n            seq.append('Treasure Map')\n            continue\n        \n        otherTitles = np.setdiff1d(worldTitles,seq)\n        if 'Level' in seq[-1]:\n            otherTitles = [x for x in otherTitles if 'Level' not in x]\n            \n        # cheating end\n\n            \n        counts = [worldTupleCounts[(seq[-1],title)] for title in otherTitles]\n        seq.append(otherTitles[np.argmax(counts)])\n    \n    assert len(seq) == len(np.unique(seq))\n    \n    print(world)\n    print(seq,'\\n')\n    \n    worldSeqs[world] = seq","9517696a":"from matplotlib.patches import Ellipse\n\ntitle2type = train.groupby('title')['type'].first().to_dict()\ntype2color = {'Clip':'y','Game':'g','Assessment':'r','Activity':'c'}\n\n#decide location of nodes\nworldLocs = {'NONE'        :(-30,15),\n             'TREETOPCITY' :(-30,0),\n             'MAGMAPEAK'   :(0  ,15),\n             'CRYSTALCAVES':(20 ,0),\n             }\ntitleLocs = {}\nfor world in worlds:\n    level = 0\n    x     = 0\n    for title in worldSeqs[world]:\n        if 'Level' in title:\n            level += 1\n            x      = 0\n        titleLocs[title] = (worldLocs[world][0]+x*6 + 1.0*level,worldLocs[world][1]-level*4)\n        x += 1\n            \ndef draw_nodes():\n    \n    plt.figure(figsize=(19,10))\n    \n    G = nx.Graph()\n    G.add_nodes_from(titleLocs.keys())\n    colors = []\n    for node in G:\n        colors.append(type2color[title2type[node]]) \n    nx.draw_networkx_nodes(G,pos=titleLocs,node_color=colors)    \n    \n    text = nx.draw_networkx_labels(G,{x:(y[0]+0.7,y[1]) for x,y in titleLocs.items()},{x:x for x in titleLocs})\n\n    for _,t in text.items():\n        t.set_rotation('20')   # rotation makes perfect\n        t.set_ha('left')\n        t.set_va('bottom')\n        \n    plt.xlim(-40,60)\n    plt.ylim(-17,20)\n    plt.tight_layout()\n        \n\ndef draw_edges(tupleCounts,connectionstyle=\"arc3,rad=0.5\",widthFunc=np.sqrt,width=5,cmap=plt.cm.Blues,alpha=0.9):\n    \n    DG = nx.DiGraph()\n    DG.add_weighted_edges_from([(key[0],key[1],tupleCounts[key]) for key in tupleCounts])\n    edges,weights = zip(*nx.get_edge_attributes(DG,'weight').items())\n    weights       = np.array(weights)   \n    nx.draw_networkx_edges(DG,pos=titleLocs,\n                           connectionstyle=connectionstyle,               # curvy looks better\n                           edgelist=edges,\n                           edge_color=weights,                           # deeper color bigger count\n                           horizontalalignment='left',\n                           arrowsize=20,\n                           width=widthFunc(weights\/np.max(weights))*width,     # width is proportional to square root of count\n                           edge_cmap=cmap,                       \n                           alpha=alpha)\n    \n  \n    r = 1.5\n    for edge,weight in zip(edges,weights):\n        if edge[0] == edge[1]:\n            x,y = titleLocs[edge[0]]\n            plt.gca().add_patch(Ellipse((x,y+0.5*r),\n                                        width=1.5*r,height=r,\n                                        lw    = widthFunc(weight\/np.max(weights))*width,\n                                        color = cmap(weight\/np.max(weights)),\n                                        fill= False,\n                                        alpha=alpha))\n    \n    \n    \n    \n    plt.tight_layout()\n    \n        \ndef draw(tupleCounts,plotTitle):\n    draw_nodes()\n    draw_edges(tupleCounts)\n    plt.title(plotTitle)\n    plt.tight_layout()\n    \n    from matplotlib.patches import FancyArrowPatch,Circle","2df7e02d":"topTupleCounts = {}\nfor title in titles:\n    dests  = np.array([key[0] for key in tupleCounts if key[1]==title])\n    counts = np.array([tupleCounts[(title,dest)] for dest in dests])\n\n    argsort      = np.argsort(counts)\n    sortedCounts = counts[argsort]\n    \n    n = np.where(np.cumsum(np.flip(sortedCounts)) > np.sum(counts)*0.7)[0][0]\n    for i in argsort[~n:]:\n        topTupleCounts[(title,dests[i])] = tupleCounts[(title,dests[i])]    \ndraw(topTupleCounts,'top 70% outgoing from each nodes')        ","b54b0fd5":"topTupleCounts = {}\nfor title in titles:\n    if 'Assess' in title:\n        origins  = np.array([key[0] for key in tupleCounts if key[1]==title])\n        counts   = np.array([tupleCounts[(o,title)] for o in origins])\n\n        argsort      = np.argsort(counts)\n        sortedCounts = counts[argsort]\n\n        n = np.where(np.cumsum(np.flip(sortedCounts)) > np.sum(counts)*0.99)[0][0]\n        for i in argsort[~n:]:\n            topTupleCounts[(origins[i],title)] = tupleCounts[(origins[i],title)]    \ndraw(topTupleCounts,'99% incoming to assessments')            ","ca9623e8":"def getSeqLength(length):\n    seq2assessment = defaultdict(lambda:0)\n    for insId,df in gb(train,'installation_id'):\n        sequence  = df.groupby('game_session',sort=False)['title'].first().values\n        for i in [j for j in range(len(sequence)) if 'Assessment' in sequence[j]]:\n            if i >= length:\n                seq2assessment[tuple([sequence[i-length+j] for j in range(0,length+1)])] += 1    \n    return seq2assessment","687c9f88":"seq2assessment = getSeqLength(5)\n\nkeys    = list(seq2assessment.keys())\ncounts  = np.array([seq2assessment[key] for key in keys])\nargsort = np.argsort(counts)\n\ntupleCounts5 = {}\nfor i in range(5):\n    key   = keys  [argsort[~i]]\n    count = counts[argsort[~i]]\n    for j in range(len(key)-1):\n        tupleCounts5[(key[j],key[j+1])] = count\ndraw(tupleCounts5,'most common length-5 path')   \n\nfor i in range(5):\n    key   = keys  [argsort[~i]]\n    count = counts[argsort[~i]]\n    print('{:30s} {:4d}\/{:4d}'.format(key[-1],count,train[train.title==key[-1]].game_session.nunique()))","80349657":"seq2assessment = getSeqLength(2)\n\nkeys    = list(seq2assessment.keys())\ncounts  = np.array([seq2assessment[key] for key in keys])\nargsort = np.argsort(counts)\n\ntupleCounts5 = {}\nfor i in range(5):\n    key   = keys  [argsort[~i]]\n    count = counts[argsort[~i]]\n    for j in range(len(key)-1):\n        tupleCounts5[(key[j],key[j+1])] = count\ndraw(tupleCounts5,'most common length-2 path')   \n\nfor i in range(5):\n    key   = keys  [argsort[~i]]\n    count = counts[argsort[~i]]\n    print('{:30s} {:4d}\/{:4d}'.format(key[-1],count,train[train.title==key[-1]].game_session.nunique()))","f48da1a0":"seq2assessment = getSeqLength(1)\n\nkeys    = list(seq2assessment.keys())\ncounts  = np.array([seq2assessment[key] for key in keys])\nargsort = np.argsort(counts)\n\ntupleCounts5 = {}\nfor i in range(5):\n    key   = keys  [argsort[~i]]\n    count = counts[argsort[~i]]\n    for j in range(len(key)-1):\n        tupleCounts5[(key[j],key[j+1])] = count\ndraw(tupleCounts5,'most common length-1 path')   \n\nfor i in range(5):\n    key   = keys  [argsort[~i]]\n    count = counts[argsort[~i]]\n    print('{:30s} {:4d}\/{:4d}'.format(key[-1],count,train[train.title==key[-1]].game_session.nunique()))","dee761fe":"np.random.seed(84)\nfor title,title_train_labels in train_labels.groupby('title'):\n    for iid in title_train_labels.installation_id.sample(5):\n        draw_nodes()\n        seq    = train[train.installation_id==iid].groupby('game_session',sort=False).title.first().values\n        if len(seq)>1:\n            tupleCounts = defaultdict(lambda:0)\n            for i in range(len(seq)-1):\n                tupleCounts[(seq[i],seq[i+1])] += 1\n            draw_edges(tupleCounts,cmap=plt.cm.Wistia,alpha=0.7)\n            plt.title(title + ' ' + iid)\n            plt.tight_layout()\n        else:\n            plt.title(title + ' ' + iid + ', this kid directly took the assessment without doing anything else prior and after')\n            plt.tight_layout()            ","0da44ef2":"np.random.seed(85)\nfor title,title_train_labels in train_labels.groupby('title'):\n    for ri,row in title_train_labels.sample(5).iterrows():\n        \n        installation_id = row.installation_id\n        game_session    = row.game_session\n        \n        draw_nodes()\n        seq    = train[train.installation_id==installation_id].groupby('game_session',sort=False).title.first()\n        seq    = seq.values[:list(seq.index).index(game_session)+1]\n        \n        \n        if len(seq)>1:\n            tupleCounts = defaultdict(lambda:0)\n            for i in range(len(seq)-1):\n                tupleCounts[(seq[i],seq[i+1])] += 1\n            draw_edges(tupleCounts,cmap=plt.cm.Wistia,alpha=0.7)\n            plt.title(title + ' ' + iid)\n            plt.tight_layout()\n        else:\n            plt.title(title + ' ' + iid + ', this kid directly took the assessment without doing anything else prior and after')\n            plt.tight_layout()            \n    ","96fb69c6":"I will attach app scrrenshots to verify these orders in the comments, since Kaggle does not allow me to upload large pictures in the kernel.","1b7d7bb3":"# ending with an tested assessment","f1f96286":"# kids population behaviors","ea10b3c3":"### I tried to obtain the app designed game\/video\/etc order without looking at the app, but failed. Need to cheat a bit.","dce16278":"After reading the nice [visualization](https:\/\/www.kaggle.com\/c\/data-science-bowl-2019\/discussion\/123102) by [J Hogg](https:\/\/www.kaggle.com\/jmhogg), I made some similar plots and by the way learn about package networkx, which in this case seems to not help much.\nIn this notebook, I did the following\n1. plot some common game\/clip\/activity\/assessment paths among the player population\n2. plot paths corresponding to individual players","45f486c9":"# individual installation sequence"}}