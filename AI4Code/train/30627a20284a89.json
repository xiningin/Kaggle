{"cell_type":{"7e928df0":"code","573e4787":"code","1e5ac0de":"code","bde59d57":"code","2b60b34d":"code","bb19b193":"code","eda1910b":"code","eb64db1b":"code","b393f764":"code","78ed547c":"code","e4e4fd12":"code","e2f96cfc":"code","9d8ab4b7":"code","7fe6f952":"code","ddff132e":"code","e44237c0":"code","1a4a28dd":"code","bbac1667":"code","48eb78e8":"code","d37fb7c0":"code","c8dc0781":"code","6afb0834":"code","d5f42ee2":"code","6a469768":"code","540da65f":"code","44a8ca95":"code","e5ca1df1":"code","de3a1898":"code","437f5cab":"code","47c69cbb":"code","01f5ce2e":"code","8c0bbc92":"code","f6f41d1a":"code","3c8d96a0":"code","385d078d":"code","e13f6d92":"code","b75774c6":"code","8beb2461":"markdown","e14b5bd7":"markdown"},"source":{"7e928df0":"import os\nimport random\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom tqdm.notebook import tqdm\nfrom torchvision import datasets, transforms, models \nfrom torchvision.datasets import ImageFolder\nfrom torchvision.transforms import ToTensor\nfrom torchvision.utils import make_grid\nfrom torch.utils.data import random_split\nfrom torch.utils.data.dataloader import DataLoader\nimport matplotlib.pyplot as plt\n%matplotlib inline","573e4787":"data_dir = '..\/input\/stanford-car-dataset-by-classes-folder\/car_data\/car_data\/train'\nclasses = os.listdir(data_dir)\nprint(classes)\nprint(len(classes))\ntest_dir = '..\/input\/stanford-car-dataset-by-classes-folder\/car_data\/car_data\/test'","1e5ac0de":"train_transform=transforms.Compose([\n        transforms.RandomRotation(10),      # rotate +\/- 10 degrees\n        transforms.RandomHorizontalFlip(),  # reverse 50% of images\n        transforms.Resize(100),             # resize shortest side to 100 pixels\n        transforms.CenterCrop(100),         # crop longest side to 100 pixels at center\n        transforms.ToTensor(),\n        transforms.Normalize([0.485, 0.456, 0.406],\n                             [0.229, 0.224, 0.225])\n])","bde59d57":"dataset = ImageFolder(data_dir, transform=train_transform)\ntestset = ImageFolder(test_dir, transform=train_transform)","2b60b34d":"# view one image shape of the dataset.\nimg, label = dataset[100]\nprint(img.shape)","bb19b193":"# function for the showing the image.\ndef show_image(img, label):\n    print('Label: ', dataset.classes[label], \"(\"+str(label)+\")\")\n    plt.imshow(img.permute(1, 2, 0))","eda1910b":"show_image(*dataset[200])","eb64db1b":"show_image(*dataset[5000])","b393f764":"torch.manual_seed(20)\nval_size = len(dataset)\/\/10\ntest_size = len(dataset)\ntrain_size = len(dataset) - val_size","78ed547c":"train_ds, val_ds = random_split(dataset, [train_size, val_size])\ntest_ds = testset\nlen(train_ds), len(val_ds), len(test_ds)   ","e4e4fd12":"batch_size = 64\ntrain_loader = DataLoader(train_ds, batch_size, shuffle=True, num_workers=4, pin_memory=True)\nval_loader = DataLoader(val_ds, batch_size*2, num_workers=4, pin_memory=True)\ntest_loader = DataLoader(test_ds, batch_size*2, num_workers=4, pin_memory=True)","e2f96cfc":"for images, labels in train_loader:\n    fig, ax = plt.subplots(figsize=(18,10))\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.imshow(make_grid(images, nrow=16).permute(1, 2, 0))\n    break","9d8ab4b7":"def accuracy(outputs, labels):\n    _, preds = torch.max(outputs, dim=1)\n    return torch.tensor(torch.sum(preds == labels).item() \/ len(preds))\n\nclass ImageClassificationBase(nn.Module):\n    def training_step(self, batch):\n        images, labels = batch \n        out = self(images)                  # Generate predictions\n        loss = F.cross_entropy(out, labels) # Calculate loss\n        return loss\n    \n    def validation_step(self, batch):\n        images, labels = batch \n        out = self(images)                    # Generate predictions\n        loss = F.cross_entropy(out, labels)   # Calculate loss\n        acc = accuracy(out, labels)           # Calculate accuracy\n        return {'val_loss': loss.detach(), 'val_acc': acc}\n        \n    def validation_epoch_end(self, outputs):\n        batch_losses = [x['val_loss'] for x in outputs]\n        epoch_loss = torch.stack(batch_losses).mean()   # Combine losses\n        batch_accs = [x['val_acc'] for x in outputs]\n        epoch_acc = torch.stack(batch_accs).mean()      # Combine accuracies\n        return {'val_loss': epoch_loss.item(), 'val_acc': epoch_acc.item()}\n    \n    def epoch_end(self, epoch, result):\n        print(\"Epoch [{}], train_loss: {:.4f}, val_loss: {:.4f}, val_acc: {:.4f}\".format(\n            epoch, result['train_loss'], result['val_loss'], result['val_acc']))","7fe6f952":"def evaluate(model, val_loader):\n    outputs = [model.validation_step(batch) for batch in val_loader]\n    return model.validation_epoch_end(outputs)\n\n\ndef fit(epochs, lr, model, train_loader, val_loader, opt_func=torch.optim.SGD):\n    history = []\n    optimizer = opt_func(model.parameters(), lr)\n    for epoch in range(epochs):\n        # Training Phase \n        model.train()\n        train_losses = []\n        for batch in tqdm(train_loader):\n            loss = model.training_step(batch)\n            train_losses.append(loss)\n            loss.backward()\n            optimizer.step()\n            optimizer.zero_grad()\n        # Validation phase\n        result = evaluate(model, val_loader)\n        result['train_loss'] = torch.stack(train_losses).mean().item()\n        model.epoch_end(epoch, result)\n        history.append(result)\n    return history","ddff132e":"torch.cuda.is_available()","e44237c0":"def get_default_device():\n    \"\"\"Pick GPU if available, else CPU\"\"\"\n    if torch.cuda.is_available():\n        return torch.device('cuda')\n    else:\n        return torch.device('cpu')\n    \ndef to_device(data, device):\n    \"\"\"Move tensor(s) to chosen device\"\"\"\n    if isinstance(data, (list,tuple)):\n        return [to_device(x, device) for x in data]\n    return data.to(device, non_blocking=True)\n\nclass DeviceDataLoader():\n    \"\"\"Wrap a dataloader to move data to a device\"\"\"\n    def __init__(self, dl, device):\n        self.dl = dl\n        self.device = device\n        \n    def __iter__(self):\n        \"\"\"Yield a batch of data after moving it to device\"\"\"\n        for b in self.dl: \n            yield to_device(b, self.device)\n\n    def __len__(self):\n        \"\"\"Number of batches\"\"\"\n        return len(self.dl)","1a4a28dd":"device = get_default_device()\ndevice","bbac1667":"train_loader = DeviceDataLoader(train_loader, device)\nval_loader = DeviceDataLoader(val_loader, device)\ntest_loader = DeviceDataLoader(test_loader, device)","48eb78e8":"input_size = 3*100*100\noutput_size = len(classes)","d37fb7c0":"def accuracy(outputs, labels):\n    _, preds = torch.max(outputs, dim=1)\n    return torch.tensor(torch.sum(preds == labels).item() \/ len(preds))\n\nclass ImageClassificationBase(nn.Module):\n    def training_step(self, batch):\n        images, labels = batch \n        out = self(images)                   # Generate predictions\n        loss = F.cross_entropy(out, labels)  # Calculate loss\n        return loss\n    \n    def validation_step(self, batch):\n        images, labels = batch \n        out = self(images)                    # Generate predictions\n        loss = F.cross_entropy(out, labels)   # Calculate loss\n        acc = accuracy(out, labels)           # Calculate accuracy\n        return {'val_loss': loss.detach(), 'val_acc': acc}\n        \n    def validation_epoch_end(self, outputs):\n        batch_losses = [x['val_loss'] for x in outputs]\n        epoch_loss = torch.stack(batch_losses).mean()   # Combine losses\n        batch_accs = [x['val_acc'] for x in outputs]\n        epoch_acc = torch.stack(batch_accs).mean()      # Combine accuracies\n        return {'val_loss': epoch_loss.item(), 'val_acc': epoch_acc.item()}\n    \n    def epoch_end(self, epoch, result):\n        print(\"Epoch [{}], train_loss: {:.4f}, val_loss: {:.4f}, val_acc: {:.4f}\".format(\n            epoch, result['train_loss'], result['val_loss'], result['val_acc']))","c8dc0781":"class CnnModel(ImageClassificationBase):\n    def __init__(self):\n        super().__init__()\n        self.network = nn.Sequential(\n            nn.Conv2d(3, 100, kernel_size=3, padding=1),\n            nn.ReLU(),\n            nn.Conv2d(100, 150, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.MaxPool2d(2, 2), # output: 150 x 16 x 16\n\n            nn.Conv2d(150, 200, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.Conv2d(200, 200, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.MaxPool2d(2, 2), # output: 200 x 8 x 8\n\n            nn.Conv2d(200, 250, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.Conv2d(250, 250, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.MaxPool2d(2, 2), # output: 250 x 4 x 4\n\n            nn.Flatten(), \n            nn.Linear(36000, 1000),\n            nn.ReLU(),\n            nn.Linear(1000, 500),\n            nn.ReLU(),\n            nn.Dropout(0.25),\n            nn.Linear(500, output_size))\n        \n    def forward(self, xb):\n        return self.network(xb)","6afb0834":"model = CnnModel()\n#model.cuda()","d5f42ee2":"model","6a469768":"for images, labels in train_loader:\n    out = model(images)\n    print('images.shape:', images.shape)\n    print('out.shape:', out.shape)\n    print('out[0]:', out[0])\n    break","540da65f":"device = get_default_device()\ndevice","44a8ca95":"train_dl = DeviceDataLoader(train_loader, device)\nval_dl = DeviceDataLoader(val_loader, device)\nto_device(model, device)","e5ca1df1":"@torch.no_grad()\ndef evaluate(model, val_loader):\n    model.eval()\n    outputs = [model.validation_step(batch) for batch in val_loader]\n    return model.validation_epoch_end(outputs)\n\ndef fit(epochs, lr, model, train_loader, val_loader, opt_func=torch.optim.SGD):\n    history = []\n    optimizer = opt_func(model.parameters(), lr)\n    for epoch in range(epochs):\n        # Training Phase \n        model.train()\n        train_losses = []\n        for batch in tqdm(train_loader):\n            loss = model.training_step(batch)\n            train_losses.append(loss)\n            loss.backward()\n            optimizer.step()\n            optimizer.zero_grad()\n        # Validation phase\n        result = evaluate(model, val_loader)\n        result['train_loss'] = torch.stack(train_losses).mean().item()\n        model.epoch_end(epoch, result)\n        history.append(result)\n    return history","de3a1898":"model = to_device(CnnModel(), device)","437f5cab":"history=[evaluate(model, val_loader)]\nhistory","47c69cbb":"num_epochs = 10\nopt_func = torch.optim.Adam\nlr = 0.001","01f5ce2e":"history+= fit(num_epochs, lr, model, train_dl, val_dl, opt_func)","8c0bbc92":"#history+= fit(num_epochs, lr\/10, model, train_dl, val_dl, opt_func)","f6f41d1a":"def plot_accuracies(history):\n    accuracies = [x['val_acc'] for x in history]\n    plt.plot(accuracies, '-x')\n    plt.xlabel('epoch')\n    plt.ylabel('accuracy')\n    plt.title('Accuracy vs. No. of epochs')\n    plt.show()\n    \ndef plot_losses(history):\n    train_losses = [x.get('train_loss') for x in history]\n    val_losses = [x['val_loss'] for x in history]\n    plt.plot(train_losses, '-bx')\n    plt.plot(val_losses, '-rx')\n    plt.xlabel('epoch')\n    plt.ylabel('loss')\n    plt.legend(['Training', 'Validation'])\n    plt.title('Loss vs. No. of epochs')\n    plt.show()","3c8d96a0":"plot_accuracies(history)","385d078d":"plot_losses(history)","e13f6d92":"evaluate(model, test_loader)","b75774c6":"from sklearn.metrics import classification_report\n\npred = []\nY = []\nfor i, (x,y) in enumerate(test_loader):\n    with torch.no_grad():\n        output = model(x)\n    pred += [int(l.argmax()) for l in output]\n    Y += [int(l) for l in y]\n\nprint(classification_report(Y, pred))","8beb2461":"# Stanford Car Classify Torch Conv2d","e14b5bd7":"# Conv2d Model"}}