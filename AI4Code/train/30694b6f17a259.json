{"cell_type":{"18559cac":"code","a6acc818":"code","052941a0":"code","8d5d8df8":"code","605fd7f5":"code","ca783144":"code","d6d26faa":"code","5a33507c":"code","c62464bd":"code","1c46af26":"code","02399246":"code","754d8583":"code","9f8e9bc2":"code","313a1f16":"code","ac9edded":"code","f95c47a9":"code","2619ba6c":"code","c5a63c0f":"code","85b8ec83":"code","039fa160":"markdown","f962f9b8":"markdown","9412c403":"markdown","600a5340":"markdown","62b4c53b":"markdown","2dfaa23d":"markdown","2a62d250":"markdown","bb5f8a84":"markdown","6ac830e1":"markdown","c2ce150b":"markdown","3bb9bf8b":"markdown"},"source":{"18559cac":"import numpy as np\nimport pandas as pd\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom keras.preprocessing.image import ImageDataGenerator,img_to_array,load_img\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport glob\nimport cv2\nfrom keras import Sequential\nfrom keras.layers import Flatten,Dense,BatchNormalization,Dropout,LeakyReLU,GlobalAveragePooling2D\nfrom keras.optimizers import Adam,RMSprop\nfrom keras.losses import BinaryCrossentropy\nfrom keras.applications import ResNet50V2\nfrom keras.callbacks import EarlyStopping","a6acc818":"train_path = \"\/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/train\/\"\nval_path = \"\/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/val\/\"\ntest_path = \"\/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/test\/\"","052941a0":"normal = glob.glob(train_path+\"NORMAL\/*.jpeg\")\npneumonia = glob.glob(train_path+\"PNEUMONIA\/*.jpeg\")","8d5d8df8":"number_of_normal_img = len(normal)\nnumber_of_pneumonia_img = len(pneumonia)\nprint(\"number of normal images:\", number_of_normal_img)\nprint(\"number of pneumonia images:\", number_of_pneumonia_img)","605fd7f5":"sns.set_theme(style=\"whitegrid\")\nplt.figure(figsize = (8,8))\nax = sns.barplot( x = [\"Normal\", \"Pneumonia\"], y = [number_of_normal_img, number_of_pneumonia_img])","ca783144":"fig, axes = plt.subplots(nrows=1, ncols=4, figsize=(15,10), subplot_kw={'xticks':[], 'yticks':[]})\nfor i, ax in enumerate(axes.flat):\n    img = cv2.imread(normal[i])\n    img = cv2.resize(img, (220,220))\n    ax.imshow(img)\n    ax.axis(\"off\")\n    ax.set_title(\"Normal Image\")\n    \n    \nplt.show()\n\nfig, axes = plt.subplots(nrows=1, ncols=4, figsize=(15,10), subplot_kw={'xticks':[], 'yticks':[]})\nfor i, ax in enumerate(axes.flat):\n    img = cv2.imread(pneumonia[i])\n    img = cv2.resize(img, (220,220))\n    ax.imshow(img)\n    ax.axis(\"off\")\n    ax.set_title(\"Pneumonia Image\")\nfig.tight_layout()    \nplt.show()","d6d26faa":"train_val_generator = ImageDataGenerator(rescale=1.\/255,horizontal_flip=True,zoom_range=0.3)\ntest_generator = ImageDataGenerator(rescale=1.\/255)","5a33507c":"train = train_val_generator.flow_from_directory(train_path,\n                                               batch_size=128,\n                                               target_size=(220,220),\n                                               color_mode=\"rgb\",\n                                               class_mode=\"binary\",\n                                               shuffle=True,\n                                               seed=42,\n                                               subset=\"training\")\n\n","c62464bd":"val = train_val_generator.flow_from_directory(val_path,\n                                               batch_size=4,\n                                               target_size=(220,220),\n                                               color_mode=\"rgb\",\n                                               class_mode=\"binary\",\n                                               shuffle=True,\n                                               seed=42)","1c46af26":"test = test_generator.flow_from_directory(test_path,\n                                          batch_size=32,\n                                          target_size=(220,220),\n                                          color_mode=\"rgb\",\n                                          class_mode=\"binary\")","02399246":"resnet50 = ResNet50V2(weights = \"imagenet\", input_shape = (220,220,3), include_top = False)","754d8583":"for layer in resnet50.layers:\n    layer.trainable = False","9f8e9bc2":"model = Sequential()\n\nmodel.add(resnet50)\n\nfor layer in resnet50.layers:\n    layer.trainable = False\n    \nmodel.add(Flatten())\n\nmodel.add(Dense(units = 128, activation = \"relu\"))\nmodel.add(Dropout(0.5))\n\nmodel.add(Dense(units = 1, activation = \"sigmoid\"))\n    ","313a1f16":"model.compile(optimizer = \"adam\", loss = \"binary_crossentropy\", metrics = [\"accuracy\"])","ac9edded":"model.summary()","f95c47a9":"tf.keras.utils.plot_model(\n    model, to_file='model1.png', show_layer_names=True, show_shapes=True)\n   \n","2619ba6c":"hist = model.fit(train,validation_data=val,epochs=5)","c5a63c0f":"plt.figure(figsize=(8,8))\nplt.plot(hist.history['loss'], color='b', label=\"Training loss\")\nplt.plot(hist.history['val_loss'], color='r', label=\"Validation loss\")\nplt.legend()\nplt.show()\n\nplt.figure()\n\nplt.figure(figsize=(8,8))\nplt.plot(hist.history['accuracy'], color='b', label=\"Training accuracy\")\nplt.plot(hist.history['val_accuracy'], color='r',label=\"Validation accuracy\")\nplt.legend(loc = \"lower right\")\nplt.show()","85b8ec83":"test_results = model.evaluate(test)","039fa160":"## Import Libraries","f962f9b8":"## Deep Residual Network (ResNet)","9412c403":"## Data Visualization","600a5340":"In general, in a deep convolutional neural network, several layers are stacked and are trained to the task at hand. The network learns several low\/mid\/high level features at the end of its layers. In residual learning, instead of trying to learn some features, we try to learn some residual. Residual can be simply understood as subtraction of feature learned from input of that layer. ResNet does this using shortcut connections (directly connecting input of nth layer to some (n+x)th layer. It has proved that training this form of networks is easier than training simple deep convolutional neural networks and also the problem of degrading accuracy is resolved.\n\nThis is the fundamental concept of ResNet.\n\nResNet50 is a 50 layer Residual Network. There are other variants like ResNet101 and ResNet152 also.\n\n","62b4c53b":"# X-Ray Images ( Pneumonia) Classification with ResNet50","2dfaa23d":"## Compining the Model","2a62d250":"- What is ResNet50 ?\n- Import Libraries\n- Loading Data & Data Processing\n- Data Visualization\n- Data Augmentation \n- ResNet \n- Compiling the Model\n- Fitting the Model\n- Evaluating the Model","bb5f8a84":"## Data Augmentation","6ac830e1":"## Loading Data & Data Processing","c2ce150b":"## Evaluate the Model","3bb9bf8b":"## What is ResNet50 ?"}}