{"cell_type":{"6c1bd813":"code","27d5c4da":"code","9f9bf09a":"code","0fe87857":"code","a14dd892":"code","5e13514a":"code","3bb8582d":"code","ea1339bc":"code","c5714619":"code","70f5c49a":"code","63ec02b8":"code","9092dc69":"code","fdd7dd17":"code","ff2e695f":"code","0bd0bfb3":"code","30ee6036":"code","c5c34bd2":"code","c3a38719":"code","7be22f03":"code","746588a7":"code","c115917e":"code","babaf871":"code","ac2125aa":"code","3af9fc31":"code","b8c353e9":"code","964dc6c9":"code","316a7367":"code","7e9b4791":"code","4e430d4d":"code","e2fff2b5":"code","b3d5fce5":"code","a7d8a8df":"code","5b3557bf":"code","a5ba3dd0":"code","8b68400d":"code","448c82b4":"code","32e84695":"code","49990618":"code","f8362d5b":"code","d2139bcf":"code","1d46b866":"code","43193ba6":"code","e9270dcb":"code","a50618a2":"code","8f5c452d":"code","4d725109":"code","d2865023":"markdown","5d3b37aa":"markdown","63941e90":"markdown","b4224f4f":"markdown","4ff323ec":"markdown","cb341059":"markdown","8a41fc0c":"markdown","5d6fb110":"markdown","ad474ff1":"markdown","d1b0c088":"markdown","68a665bc":"markdown","ea610115":"markdown","44df5a5a":"markdown","e47abc71":"markdown","d5f41fee":"markdown","cfb23619":"markdown","bccdbc15":"markdown","5d9bbb87":"markdown","5cf42302":"markdown","9687ccf6":"markdown","b52cb178":"markdown","2c71e9e5":"markdown","519478d7":"markdown","9b05c0d2":"markdown","439b8cdb":"markdown","8d54f7a7":"markdown","04db9ec1":"markdown"},"source":{"6c1bd813":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt","27d5c4da":"df = pd.read_csv(\"..\/input\/eshop.csv\")","9f9bf09a":"df.head()","0fe87857":"# convert datecol to datetime type\ndf.Date = pd.to_datetime(df.Date)","a14dd892":"# get last dates for each ID\nrfm = df.loc[df.groupby('Customer ID').Date.idxmax()]","5e13514a":"# subtract \"todays date (which is 12\/19\/2015 by the assigment)\" from dates to get number of days from today\nfrom datetime import datetime\nrfm['Recency'] = -(rfm.Date - datetime(2015, 12, 19)).dt.days.astype(int)\n# set index to customer id\nrfm = rfm.set_index('Customer ID')","3bb8582d":"# aggregate subtotal (sum it and count it)\nsum_and_count = df.groupby('Customer ID')['Subtotal'].agg(['sum', 'count'])","ea1339bc":"# put sum and count into rmf dataframe\nrfm['Frequency'] = sum_and_count['count']\nrfm['Monetary'] = sum_and_count['sum']","c5714619":"# drop not needed columns\nrfm.drop(columns=['Date', 'Subtotal', 'Country'], inplace=True)","70f5c49a":"# check out the dataset\nrfm.describe()","63ec02b8":"from sklearn.cluster import KMeans","9092dc69":"ix = np.zeros(10)\niy = np.zeros(10)\nfor k in range(ix.shape[0]):\n    kmeans = KMeans(n_clusters=k+1, random_state = 1)\n    kmeans.fit(rfm)\n    iy[k] = kmeans.inertia_\n    ix[k] = k+1\n\nplt.xlabel('$k$')\nplt.ylabel('\u00da\u010delov\u00e1 funkce')\nplt.plot(ix, iy, 'o-')\nplt.show()","fdd7dd17":"from mpl_toolkits.mplot3d import Axes3D\n\nk = 4\nkmeans = KMeans(n_clusters = k, random_state = 1).fit(rfm)\n\nfig = plt.figure(figsize=(25, 10))\nax = fig.add_subplot(111, projection='3d')\n\nax.scatter(rfm.Recency, rfm.Frequency, rfm.Monetary, c=kmeans.labels_, cmap='brg', alpha=0.4)  # plot points with cluster dependent colors\nax.scatter(kmeans.cluster_centers_[:,0], kmeans.cluster_centers_[:,1], kmeans.cluster_centers_[:,2], c = 'black', s=100, alpha=1)\nplt.legend(['Data','Cluster centers'])\nax.set_xlabel('Recency')\nax.set_ylabel('Frequency')\nax.set_zlabel('Monetary')\nplt.show()","ff2e695f":"fig = plt.figure(figsize=(25, 10))\nax = fig.add_subplot(111, projection='3d')\n\nax.scatter(rfm.Recency, rfm.Frequency, rfm.Monetary, c=kmeans.labels_, cmap='brg', alpha=0.01)  # plot points with cluster dependent colors\nax.scatter(kmeans.cluster_centers_[:,0], kmeans.cluster_centers_[:,1], kmeans.cluster_centers_[:,2], c = 'black', s=100, alpha=1)\nplt.legend(['Data','Cluster centers'])\nax.set_xlabel('Recency')\nax.set_ylabel('Frequency')\nax.set_zlabel('Monetary')\nplt.show()","0bd0bfb3":"from sklearn.preprocessing import scale","30ee6036":"scaled_matrix = scale(rfm.values)\nscaled_rfm = pd.DataFrame(scaled_matrix)","c5c34bd2":"scaled_rfm","c3a38719":"ix = np.zeros(10)\niy = np.zeros(10)\nfor k in range(ix.shape[0]):\n    kmeans = KMeans(n_clusters=k+1, random_state = 1)\n    kmeans.fit(scaled_rfm)\n    iy[k] = kmeans.inertia_\n    ix[k] = k+1\n\nplt.xlabel('$k$')\nplt.ylabel('\u00da\u010delov\u00e1 funkce')\nplt.plot(ix, iy, 'o-')\nplt.show()","7be22f03":"k = 4\nkmeans = KMeans(n_clusters = k, random_state = 1).fit(scaled_rfm)\n\nfig = plt.figure(figsize=(25, 10))\nax = fig.add_subplot(111, projection='3d')\n\nax.scatter(scaled_rfm[0], scaled_rfm[1], scaled_rfm[2], c=kmeans.labels_, cmap='brg', alpha=0.3, zorder=-1)  # plot points with cluster dependent colors\nax.scatter(kmeans.cluster_centers_[:,0], kmeans.cluster_centers_[:,1], kmeans.cluster_centers_[:,2], c = 'black', s=100, alpha=1)\nax.set_xlabel('Recency')\nax.set_ylabel('Frequency')\nax.set_zlabel('Monetary')\nplt.legend(['Data', 'Cluster centers'])\nplt.show()","746588a7":"fig = plt.figure(figsize=(25, 10))\nax = fig.add_subplot(111, projection='3d')\n\nax.scatter(scaled_rfm[0], scaled_rfm[1], scaled_rfm[2], c=kmeans.labels_, cmap='brg', alpha=0.01, zorder=-1)  # plot points with cluster dependent colors\nax.scatter(kmeans.cluster_centers_[:,0], kmeans.cluster_centers_[:,1], kmeans.cluster_centers_[:,2], c = 'black', s=100, alpha=1)\nax.set_xlabel('Recency')\nax.set_ylabel('Frequency')\nax.set_zlabel('Monetary')\nplt.legend(['Data', 'Cluster centers'])\nplt.show()","c115917e":"rfm['cluster'] = kmeans.labels_","babaf871":"# extracting \"supertar\" customers \nsuperstars = rfm[rfm.cluster == 2]\nsuperstars.head(5)","ac2125aa":"# extracting \"not-interesting\" customers \nnot_interesting = rfm[rfm.cluster == 3]\nnot_interesting.head(5)","3af9fc31":"from sklearn.metrics import silhouette_samples, silhouette_score\nsilhouette_avg = silhouette_score(rfm.drop(columns='cluster'), kmeans.labels_)\nsample_silhouette_values = silhouette_samples(rfm.drop(columns='cluster'), kmeans.labels_)","b8c353e9":"silhouette_avg","964dc6c9":"sample_silhouette_values","316a7367":"import matplotlib.cm as cm\ny_lower = 10\nplt.figure(figsize=(25, 10))\nfor i in range(4):\n        # Aggregate the silhouette scores for samples belonging to\n        # cluster i, and sort them\n        ith_cluster_silhouette_values = \\\n            sample_silhouette_values[kmeans.labels_ == i]\n\n        ith_cluster_silhouette_values.sort()\n\n        size_cluster_i = ith_cluster_silhouette_values.shape[0]\n        y_upper = y_lower + size_cluster_i\n\n        color = cm.nipy_spectral(float(i) \/ 4)\n        plt.fill_betweenx(np.arange(y_lower, y_upper),\n                          0, ith_cluster_silhouette_values,\n                          facecolor=color, edgecolor=color, alpha=0.7)\n        \n        # Label the silhouette plots with their cluster numbers at the middle\n        plt.text(-0.05, y_lower + 0.5 * size_cluster_i, str(i))\n\n        # Compute the new y_lower for next plot\n        y_lower = y_upper + 10  # 10 for the 0 samples\n\nplt.title(\"The silhouette plot for the various clusters.\")\nplt.xlabel(\"The silhouette coefficient values\")\nplt.ylabel(\"Cluster label\")\n\n# The vertical line for average silhouette score of all the values\nplt.axvline(x=silhouette_avg, color=\"red\", linestyle=\"--\")\n\nplt.yticks([])  # Clear the yaxis labels \/ ticks\nplt.xticks([-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1])","7e9b4791":"# copy IDs from rmf\nrfm2 = rfm.drop(columns=['Monetary', 'Frequency', 'Recency', 'cluster'])","4e430d4d":"last_date = df.loc[df.groupby('Customer ID').Date.idxmax()]\nlast_date = last_date.set_index('Customer ID')","e2fff2b5":"rfm2['Recency'] = -(last_date.Date - datetime(2015, 12, 19)).dt.days.astype(int)","b3d5fce5":"# for simplicity, lets just have 30 days in a month\nrfm2['Recency'] = (rfm2.Recency \/ 30).astype(int).replace(0, 1)","a7d8a8df":"# last 12 months is today(which is 12\/19\/2015) - 12 months\nvalid_dates = df[df.Date > datetime(2014, 12, 19)]","5b3557bf":"rfm2['Frequency'] = valid_dates.groupby('Customer ID')['Date'].count()","a5ba3dd0":"rfm2 = rfm2.fillna(value=1)","8b68400d":"rfm2['Monetary'] = df.groupby('Customer ID')['Subtotal'].max()","448c82b4":"rfm2.describe()","32e84695":"scaled_matrix2 = scale(rfm2.values)\nscaled_rfm2 = pd.DataFrame(scaled_matrix2)","49990618":"ix = np.zeros(10)\niy = np.zeros(10)\nfor k in range(ix.shape[0]):\n    kmeans = KMeans(n_clusters=k+1, random_state = 1)\n    kmeans.fit(scaled_rfm2)\n    iy[k] = kmeans.inertia_\n    ix[k] = k+1\n\nplt.xlabel('$k$')\nplt.ylabel('\u00da\u010delov\u00e1 funkce')\nplt.plot(ix, iy, 'o-')\nplt.show()","f8362d5b":"k = 4\nkmeans = KMeans(n_clusters = k, random_state = 1).fit(scaled_rfm2)\n\nfig = plt.figure(figsize=(25, 10))\nax = fig.add_subplot(111, projection='3d')\n\nax.scatter(scaled_rfm2[0], scaled_rfm2[1], scaled_rfm2[2], c=kmeans.labels_, cmap='brg', alpha=0.3, zorder=-1)  # plot points with cluster dependent colors\nax.scatter(kmeans.cluster_centers_[:,0], kmeans.cluster_centers_[:,1], kmeans.cluster_centers_[:,2], c = 'black', s=100, alpha=1)\nax.set_xlabel('Recency')\nax.set_zlabel('Frequency')\nax.set_ylabel('Monetary')\nplt.show()","d2139bcf":"fig = plt.figure(figsize=(25, 10))\nax = fig.add_subplot(111, projection='3d')\n\nax.scatter(scaled_rfm2[0], scaled_rfm2[1], scaled_rfm2[2], c=kmeans.labels_, cmap='brg', alpha=0.01, zorder=-1)  # plot points with cluster dependent colors\nax.scatter(kmeans.cluster_centers_[:,0], kmeans.cluster_centers_[:,1], kmeans.cluster_centers_[:,2], c = 'black', s=100, alpha=1)\nax.set_xlabel('Recency')\nax.set_ylabel('Frequency')\nax.set_zlabel('Monetary')\nplt.show()","1d46b866":"silhouette_avg = silhouette_score(rfm2, kmeans.labels_)\nsample_silhouette_values = silhouette_samples(rfm2, kmeans.labels_)","43193ba6":"silhouette_avg","e9270dcb":"sample_silhouette_values","a50618a2":"import matplotlib.cm as cm\ny_lower = 10\nplt.figure(figsize=(25, 10))\nfor i in range(4):\n        # Aggregate the silhouette scores for samples belonging to\n        # cluster i, and sort them\n        ith_cluster_silhouette_values = \\\n            sample_silhouette_values[kmeans.labels_ == i]\n\n        ith_cluster_silhouette_values.sort()\n\n        size_cluster_i = ith_cluster_silhouette_values.shape[0]\n        y_upper = y_lower + size_cluster_i\n\n        color = cm.nipy_spectral(float(i) \/ 4)\n        plt.fill_betweenx(np.arange(y_lower, y_upper),\n                          0, ith_cluster_silhouette_values,\n                          facecolor=color, edgecolor=color, alpha=0.7)\n        \n        # Label the silhouette plots with their cluster numbers at the middle\n        plt.text(-0.05, y_lower + 0.5 * size_cluster_i, str(i))\n\n        # Compute the new y_lower for next plot\n        y_lower = y_upper + 10  # 10 for the 0 samples\n\nplt.title(\"The silhouette plot for the various clusters.\")\nplt.xlabel(\"The silhouette coefficient values\")\nplt.ylabel(\"Cluster label\")\n\n# The vertical line for average silhouette score of all the values\nplt.axvline(x=silhouette_avg, color=\"red\", linestyle=\"--\")\n\nplt.yticks([])  # Clear the yaxis labels \/ ticks\nplt.xticks([-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1])","8f5c452d":"rfm2['clusters'] = kmeans.labels_\nrfm2[rfm2.clusters == 2]","4d725109":"rfm2[rfm2.clusters == 3]","d2865023":"### Interpreting clusters\nWe want indentify \"superstar\" customers and \"not-interesting\" customers.\n\nAs mentioned above, the green labeled datapoints are our \"not interesting\" customers, while the brown labeled datapoints are \"superstar\" customers. Let's map these clusters on our **rfm** dataset.","5d3b37aa":"### Conclusion","63941e90":"### Load the data","b4224f4f":"### Interpreting clusters with Silhouette method","4ff323ec":"### Optimalisation of n_clusters parameter: Elbow method","cb341059":"Since our plot is in 3d (because of 3 features), it's hard to see the cluster centers, let's plot it again with a lower alpha parameter for the datapoints to see our cluster ceters better.","8a41fc0c":"Clusters 2 and 3 don't seem to have been clustered well, let's see what data are in these clusters.","5d6fb110":"Using **k-means** clustering on customer segmentation problem proved to be fairly effective. But we have to keep in mind that methods such as **feature standardizing** had a considerable impact on our results.\n\nIn the 2nd modification of the **rfm** dataset, the model did not perform that well anymore, due to the fact that there was one datapoint (**Customer ID 4912**) which was far enough from other datapoints to create it's own cluster. This can be avoided by cleaning the dataset more throughoutly, which further proves the importance of **feature standardizing**.\n\nLastly, the **Silhouette method** is useful for clustering problems and should not be overlooked.","ad474ff1":"### Optimalisation of n_clusters parameter: Elbow method","d1b0c088":"### Feature standardization\nFeature standardization proved to be reliable, so we will standardize our data right away.","68a665bc":"### Optimalisation of n_clusters parameter: Elbow method","ea610115":"We can then conclude that the data was clustered fairly well.","44df5a5a":"The graph indicates that the optimal number of n_clusters is 4.","e47abc71":"### Silhouette method\nDefinition from wikipedia:\n> \"The silhouette value is a measure of how similar an object is to its own cluster (cohesion) compared to other clusters (separation). The silhouette ranges from \u22121 to +1, where a high value indicates that the object is well matched to its own cluster and poorly matched to neighboring clusters. If most objects have a high value, then the clustering configuration is appropriate. If many points have a low or negative value, then the clustering configuration may have too many or too few clusters.\"","d5f41fee":"### Data preprocessing\nLet us modify our dataset into a popular **RFM** type of dataset with features as follows:\n- **R**ecency: Number of days from the last purchase\n- **F**requency: Number of purchases\n- **M**onetary: Sum of prices of these purchases","cfb23619":"Looking at our graph, we can see that objects in the clusters 1 and 3 are matched mostly well. Although this does not apply for clusters 0 and 2, we know (from our scatter plots earlier in this document) that the data for better customers is scattered all over our 3D plot and there also aren't that many \"superstar customers\" compared to the number of \"not-interesting\" customers. This results in a larger distance between these data-points, thus the worse Silhouette score for such clusters.","bccdbc15":"### Clustering with K-means and plotting","5d9bbb87":"The clusters make more sense this time around, **blue** and **brown** clusters are \"interesting\" customers, while the **green** cluster contains \"not interesting\" customers due to the high recency, low frequency and low monetary. We cannot classify the **red** cluster customers the same way, since they have made their first purchase not too long ago.","5cf42302":"As we can see, our model did not yield good results. It clustered our data mainly along the Recency axis, which is also the weakest feature we want to count with.","9687ccf6":"Optimal clusters is still 4, although our graph looks a little different now.","b52cb178":"### Clustering with K-means and plotting","2c71e9e5":"### Clustering with K-means and plotting","519478d7":"The optimal number of n_estimators is still 4. This time though, 5 or 6 n_estimators wouldn't be much worse.","9b05c0d2":"As we can see, the different modification of our dataset allowed for a special case to be clustered alone (cluster 3). The data in the cluster 2, which we can label as \"frequent buyers\", have lower Silhouette values for the same reasons stated in the previous modification of our dataset.","439b8cdb":"### Clustering with differently modified data\nWe will try clustering on a modified rmf dataset as follows:\n- Recency = max(# of months from last purchase, 1)\n- Frequency = max(# of purchases last 12 months, 1)\n- Monetary = most expensive purchase","8d54f7a7":"### Feature standardization\nFor a better performing model, it's usually a good idea to standardize our data first.","04db9ec1":"# 3D Customer segmentation with k-means\nIn this work we will explore the basics of clustering data using k-means on a customer segmentation problem."}}