{"cell_type":{"8a2b60af":"code","729a7d77":"code","c3462ead":"code","0d1beb69":"code","dc9f49b7":"code","11fda141":"code","0e3a8f55":"code","011a5ed3":"code","fd4af921":"code","26fe9fd7":"code","d0a15259":"code","aa8952cd":"code","494b6f2a":"code","07135016":"code","543b3c46":"markdown","b2598e71":"markdown","fea84e30":"markdown","79c72a03":"markdown","bce13889":"markdown","04e1b44d":"markdown","59ae0b1b":"markdown","49861d29":"markdown","d436e860":"markdown","897b74bd":"markdown","24e07257":"markdown"},"source":{"8a2b60af":"# Utilities \nimport os\nimport datetime as dt\nfrom datetime import timedelta\n\n# Data manipulation\nimport numpy as np\nimport pandas as pd \n\n# Create plots\nimport plotly.graph_objects as go\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%config InlineBackend.figure_format ='retina'   # To get high resolution plots\n\n# To hide warnings\nimport warnings\nwarnings.filterwarnings('ignore');","729a7d77":"# Load and preprocessing\ndata = pd.read_csv('\/kaggle\/input\/price-volume-data-for-all-us-stocks-etfs\/Stocks\/cpsh.us.txt')\ndata['Date'] = pd.to_datetime(data['Date'])\ndata = data.set_index('Date')\ndata.head()","c3462ead":"# We have to define a date to separate training and test sets\ntrainig_set_size = 0.75\n\n#plt.style.context('dark_background')\nfirst_record = min(data.index)\nlast_record = max(data.index)\ntotal_days = (last_record - first_record).days\n\n# Total number of days\nprint('We have data from a total of ', total_days, ' days')   \ntraining_days = np.ceil(total_days * trainig_set_size)\ntest_days = np.floor(total_days * (1 - trainig_set_size))\n\n#date_split = first_record + int(total_test_days)\nprint('We are going to the data of ', int(training_days), ' days for training and ', int(test_days), ' days for testing.')\ndate_split = first_record + timedelta(days=training_days)\nprint('The train set goes from ' + str(first_record.year) + '-' + str(first_record.month) + '-' + str(first_record.day) + ' to ' + str(date_split.year) + '-' + str(date_split.month) + '-' + str(date_split.day))\nprint('The last day included in the training set is: ')\n\ntrain_data = data[:date_split]\ntest_data = data[date_split:]\n\nprint(first_record)\nprint(last_record)","0d1beb69":"try: \n    if sum(data['OpenInt']) == 0:\n        data = data.drop(columns=['OPE'], axis=1)\n        pritn('The feature OpenInt has been deleted of the dataset because does not contain usefull information.')\nexcept:\n    pass","dc9f49b7":"def plot_train_test(train, test, date_split, x_axis_title, y_axis_title):\n    \"\"\"Plot the time series, dividing it in train and test sets.\"\"\"\n    fig = go.Figure(data=[\n                    go.Candlestick(\n                            x=train.index,\n                            open=train['Open'], \n                            high=train['High'],\n                            low=train['Low'], \n                            close=train['Close'], \n                            name='Train',\n                            increasing_line_color= 'cyan',\n                            decreasing_line_color= 'gray'), \n                    go.Candlestick(\n                            x=test.index,\n                            open=test['Open'],\n                            high=test['High'],\n                            low=test['Low'],\n                            close=test['Close'],\n                            name='Test'), \n                    ])\n\n    fig.update_layout(\n        title=x_axis_title,\n        yaxis_title=y_axis_title,\n        shapes = [\n                dict(x0=date_split, x1=test.index[-1], y0=0, y1=1, xref='x', yref='paper',line_width=2),\n                dict(x0=train.index[0], x1=date_split, y0=0, y1=1, xref='x', yref='paper',line_width=2), ],\n        annotations=[\n                dict(x=date_split, y=0.05, xref='x', yref='paper', showarrow=False, xanchor='left', text='    Test set'),\n                dict(x=date_split, y=0.05, xref='x', yref='paper', showarrow=False, xanchor='right', text='Train set    '), ]\n    )\n\n    fig.show()\n    \nplot_train_test(train=train_data, \n                test=test_data, \n                date_split=date_split, \n                x_axis_title='Stocks evolution, train and test sets', \n                y_axis_title='CPS Technologies Corporation')","11fda141":"def Average(y_hat, y):\n    \"\"\"Compute the Average of errors.\n    :param y_hat: 1-Dimensional vector with predictions.\n    :param y: 1-Dimensional vector with true values.\n    :return average: Average.\n    \"\"\"\n    errors = [y_hat[i] - y[i] for i in range(len(y))]\n    T = len(errors)\n    average = sum(errors) \/ T\n    \n    return average\n\ndef MAE(y_hat, y):\n    \"\"\"Compute the Mean Absolute Error (MAE).\n    :param y_hat: 1-Dimensional vector with predictions.\n    :param y: 1-Dimensional vector with true values.\n    :return mae: Mean Absolute Error.\n    \"\"\"\n    errors = [abs(y_hat[i] - y[i]) for i in range(len(y))]\n    T = len(errors)\n    mae = sum(errors) \/ T\n    \n    return mae \n\ndef MSE(y_hat, y):\n    \"\"\"Compute the Mean Squared Error (MSR).\n    :param y_hat: 1-Dimensional vector with predictions.\n    :param y: 1-Dimensional vector with true values.\n    :return msr: Mean Squared Error.\n    \"\"\"\n    errors = [(y_hat[i] - y[i])**2 for i in range(len(y))]\n    T = len(errors)\n    msr = sum(errors) \/ T\n    \n    return msr\n\ndef RMSE(y_hat, y):\n    \"\"\"Compute the Root Mean Squared Error (RMSE).\n    :param y_hat: 1-Dimensional vector with predictions.\n    :param y: 1-Dimensional vector with true values.\n    :return rmse: Root Mean Squared Error.\n    \"\"\"\n    errors = [(y_hat[i] - y[i])**2 for i in range(len(y))]\n    T = len(errors)\n    rmse = np.sqrt(sum(errors) \/ T) \n    \n    return rmse\n\ndef MAPE(y_hat, y):\n    \"\"\"Compute the Mean Absolute Percentage Error (MAPE).\n    :param y_hat: 1-Dimensional vector with predictions.\n    :param y: 1-Dimensional vector with true values.\n    :return mape: Mean Absolute Percentage Error.\n    \"\"\"\n    errors = [y_hat[i] - y[i] for i in range(len(y))]\n    T = len(errors)\n    numerator = sum( [abs(errors[i] \/ y[i]) for i in range(T)] )\n    mape = 100 * (numerator \/ T)\n    \n    return mape\n\ndef MAPD(y_hat, y):\n    \"\"\"Compute Mean Absolute Percentage Deviation (MAPD).\n    :param y_hat: 1-Dimensional vector with predictions.\n    :param y: 1-Dimensional vector with true values.\n    :param mapd: Mean Absolute Percentage Deviation.\n    \"\"\"\n    errors = [y_hat[i] - y[i] for i in range(len(y))]\n    numerator = sum( [abs(errors[i]) for i in range(len(errors))] )\n    denominator = sum( [abs(y[i]) for i in range(len(y))] )\n    mapd = numerator \/ denominator\n    \n    return mapd\n\n\nresults = {\n    # Naive approach\n    'Average': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    'Naive': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    'Drift': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    # Time series methods\n    # Simple moving average for different values of window: 5, 10, 25, 50\n    'SMA_5': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    'SMA_10': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    'SMA_25': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    'SMA_50': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    # Cumulative moving average for different values of window: 5, 10, 25, 50\n    'CMA_5': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    'CMA_10': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    'CMA_25': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    'CMA_50': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    # Exponential moving average for different values of window: 5, 10, 25, 50\n    'EMA_5': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    'EMA_10': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    'EMA_25': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n    'EMA_50': { 'average': 0, 'mae': 0, 'mse': 0, 'rmse': 0, 'mape': 0, 'mapd': 0 },\n}\n\n# hear a helper function\ndef fillErrors(algorithm, y_hat, y):\n    \"\"\"Compute the different types of errors for and save the results in the resutls variable.\n    :param algorigthm: str, key for the results dictionary.\n    :y_hat: 1-Dimensional vector of predictions.\n    :y: 1-Dimensional vector of true values.\n    \"\"\"\n    results[algorithm]['average'] = Average(y_hat, y)\n    results[algorithm]['mae'] = MAE(y_hat, y)\n    results[algorithm]['mse'] = MSE(y_hat, y)\n    results[algorithm]['rmse'] = RMSE(y_hat, y)\n    results[algorithm]['mape'] = MAPE(y_hat, y)\n    results[algorithm]['mapd'] = MAPD(y_hat, y)","0e3a8f55":"X = train_data['Close']\ny = test_data['Close']\n\ny_hat_AF = pd.Series([np.mean(X) for _ in range(len(y))], index=y.index)\n\n                     \n# Graphic\nwith plt.style.context('dark_background'):\n    plt.figure(figsize=(20, 5.5))\n    plt.title(\"Average approach\")\n    plt.plot(X, label='Train values')\n    plt.plot(y, label='Real value')\n    # Predictions\n    plt.plot(y_hat_AF, label='Average prediction', color='red')\n    plt.plot(pd.Series([y_hat_AF.values[0] for _ in range(len(X))], index=X.index), color='red') # Extends to the previous values\n    \n    plt.legend()\n    plt.show()\n\n# Compute and save the results\nfillErrors(algorithm='Average',  y_hat=y_hat_AF, y=y)","011a5ed3":"y_hat_NF = pd.Series([X[date_split] for _ in range(len(y))], index=y.index)\n                     \n# Graphic\nwith plt.style.context('dark_background'):\n    plt.figure(figsize=(20, 5.5))\n    plt.title(\"Naive and Average approaches\")\n    plt.plot(X, label='Train values')\n    plt.plot(y, label='Real value')\n    # Predictions\n    plt.plot(y_hat_AF, label='Average Forecast', color='red')\n    plt.plot(pd.Series([y_hat_AF.values[0] for _ in range(len(X))], index=X.index), color='red') # Extends to the previous values\n    plt.plot(y_hat_NF, label='Naive Forecast', color='green')\n    plt.plot(pd.Series([y_hat_NF.values[0] for _ in range(len(X))], index=X.index), color='green') # Extends to the previous values\n    \n    plt.legend()\n    plt.show()\n\n# Compute the errors and save the resutls\nfillErrors(algorithm='Naive',  y_hat=y_hat_NF, y=y)","fd4af921":"y_t = X[-1]\nm = (y_t - X[0]) \/ len(X)\nh = np.linspace(0,len(y.index)-1, len(y.index))\ny_hat_DF = pd.Series([y_t + m * h[i] for i in range(len(y.index))], index=y.index)\n\n# Graphic\nwith plt.style.context('dark_background'):\n    plt.figure(figsize=(20, 5.5))\n    plt.title(\"Naive, Average and Drift approaches\")\n    plt.plot(y, label='Real value')\n    # Predictions\n    plt.plot(y_hat_AF, label='Average Forecast', color='red')\n    plt.plot(y_hat_NF, label='Naive Forecast', color='green')\n    plt.plot(y_hat_DF, label='Drift Forecast', color='Yellow')\n    plt.legend()\n    plt.show()\n\n# Compute the errors and save the resutls\nfillErrors(algorithm='Drift', y_hat=y_hat_DF, y=y)","26fe9fd7":"days = [5, 10, 25, 50]\ncolors = ['green', 'blue', 'yellow', 'purple']\n\nwith plt.style.context('dark_background'):\n    plt.figure(figsize=(20, 5.5))\n    plt.title(\"Simple Moving Average for different window size (train and test sets)\")\n    plt.plot(X, label='Train values', color='white')\n    plt.plot(y, label='Real value')\n    # Predictions\n    for i in range(len(days)):\n        SMA = data['Close'].rolling(window=days[i]).mean()\n        plt.plot(SMA, label=days[i], color=colors[i])\n        # Save the errors\n        fillErrors(algorithm='SMA_' + str(days[i]), y_hat=y_hat_DF, y=y)\n    plt.legend()\n    plt.show()\n\nwith plt.style.context('dark_background'):\n    plt.figure(figsize=(20, 5.5))\n    plt.title(\"Simple Moving Average for different window size (test set)\")\n    plt.plot(y, label='Real value')\n    # Predictions\n    for i in range(len(days)):\n        SMA = data['Close'].rolling(window=days[i]).mean()\n        plt.plot(SMA[y.index], label=days[i], color=colors[i])\n\n    plt.legend()\n    plt.show()\n\n","d0a15259":"days = [5, 10, 25, 50]\ncolors = ['green', 'blue', 'yellow', 'purple']\n\nwith plt.style.context('dark_background'):\n    plt.figure(figsize=(20, 5.5))\n    plt.title(\"Cumulative Moving Average for different window size (train and test set)\")\n    plt.plot(X, label='Train values', color='white')\n    plt.plot(y, label='Real value')\n    # Predictions\n    for i in range(len(days)):\n        SMA = data['Close'].expanding(min_periods=days[i]).mean()\n        plt.plot(SMA, label=days[i], color=colors[i])\n        # Save the errors\n        fillErrors(algorithm='CMA_' + str(days[i]), y_hat=y_hat_DF, y=y)\n    plt.legend()\n    plt.show()\n\nwith plt.style.context('dark_background'):\n    plt.figure(figsize=(20, 5.5))\n    plt.title(\"Cumulative Moving Average for different window size (test set)\")\n    plt.plot(y, label='Real value')\n    # Predictions\n    for i in range(len(days)):\n        SMA = data['Close'].expanding(min_periods=days[i]).mean()\n        plt.plot(SMA[y.index], label=days[i], color=colors[i])\n\n    plt.legend()\n    plt.show()\n","aa8952cd":"days = [5, 10, 25, 50]\ncolors = ['green', 'blue', 'yellow', 'purple']\n\nwith plt.style.context('dark_background'):\n    plt.figure(figsize=(20, 5.5))\n    plt.title(\"Cumulative Moving Average for different window size (train and test sets)\")\n    plt.plot(X, label='Train values', color='white')\n    plt.plot(y, label='Real value')\n    # Predictions\n    for i in range(len(days)):\n        SMA = data['Close'].ewm(span=days[i],adjust=False).mean()\n        plt.plot(SMA, label=days[i], color=colors[i])\n        # Save the errors\n        alg = 'EMA_' + str(days[i])\n        fillErrors(algorithm=alg, y_hat=y_hat_DF, y=y)\n    plt.legend()\n    plt.show()\n\nwith plt.style.context('dark_background'):\n    plt.figure(figsize=(20, 5.5))\n    plt.title(\"Cumulative Moving Average for different window size (test set)\")\n    plt.plot(y, label='Real value')\n    # Predictions\n    for i in range(len(days)):\n        SMA = data['Close'].ewm(span=days[i],adjust=False).mean()\n        plt.plot(SMA[y.index], label=days[i], color=colors[i])\n\n    plt.legend()\n    plt.show()","494b6f2a":"error_types = []\nmethods = []\nfor key in results:\n    methods.append(key)\nfor key in results[methods[0]]:\n    error_types.append(key)\n    \ndf = pd.DataFrame(index=methods, columns=error_types)\nfor method in methods:\n    for error in error_types:\n        df.loc[method, error] = results[method][error]\ndf","07135016":"for error in error_types:\n    plt.figure(figsize=(20, 5.5))\n    plt.title('Error type: ' + error)\n    df[error].plot(kind='bar', color=['green', 'blue', 'yellow', 'orange', 'red', 'brown', 'black', 'white',])\n    plt.show()","543b3c46":"# (4) Basic methods\n\n### (4.1) Average forecasting\n\n$$\n    \\hat{y}_{t + N} = \\frac{\\sum_{i = t}^{N} y_i }{N}\n$$","b2598e71":"### (5.3) Exponential moving average\n\nThis is computed recursively:\n\n$$ \nS_t\n  \\left\\{\n\\begin{array}{ll}\n      Y_1,  & t = 1 \\\\\n      \\alpha Y_t + (1 - alpha) S_{t - 1} & t > 1 \\\\\n\\end{array} \n\\right. \n$$\n\n* 0 < $\\alpha$ < 1 represent the degree of weighting decrease. A higher $\\alpha$ discounts older observations faster.\n* $Y_t$ is the value at a time period t.\n* $S_t$ is the value of the exponential moving average at time t.","fea84e30":"### (5.1) Simple moving average\n\n$$\n    \\bar{p}_{SM} = \\frac{1}{n} \\sum_{i = 0}^{n - 1} p_{M - i}\n$$","79c72a03":"### (4.3) Drift forecast\n\n$$\n    \\hat{y}_{t + N} = y_t + N \\Big( \\frac{y_t - y_1}{t - 1} \\Big)\n$$","bce13889":"### (5.2) Cumulative moving average\n\n$$\n    CMA_n = \\frac{p_1 + p_2 + ... + p_{n - 1} + p_n}{n}\n$$","04e1b44d":"<a name=\"DataInspection\"><\/a>\n# (2) Data inspection and preprocessing","59ae0b1b":"<a name=\"Error\"><\/a>\n# (3) Measuring the error\n\nWe will use compere the performance of the different approaches using the next measures , all based in the basic definition of **error**: $E_T = \\hat{y}_T - y_T$\n\n1. **Average of errors ($\\bar{E}$)**:\n$$\n    \\bar{E} = \\frac{\\sum_{i=1}^{T} E_i}{T}\n$$\n\n2. **Mean Absolute Error (MAE)**\n$$\n    MAE = \\frac{\\sum_{i=1}^{T} |E_i|}{T}\n$$\n\n3. **Mean Squared Error (MSR)**\n$$\n    MSE = \\frac{\\sum_{i=1}^{T} E_{i}^{2}}{T}\n$$\n\n4. **Root Mean Squared Error (RMSE)**\n$$\n    RMSE = \\sqrt{\\frac{\\sum_{i=1}^{T} E_{i}^{2}}{T}}\n$$\n\n5. **Mean Absolute Percentage Error (MAPE)**\n$$\n    MAPE = 100 \\times \\frac{\\sum_{i=1}^{T} | \\frac{E_i}{y_i} | }{T}\n$$\n\n6. **Mean Absolute Percentage Deviation (MAPD)**\n$$\n    MAPD = \\frac{\\sum_{i = 1}^{T} | E_i | }{\\sum_{i = 1}^{T} | y_i |}\n$$\n","49861d29":"# Content\n\n1. [Introduction](#Introduction)\n2. [Data inspection and preprocessing](#DataInspection)\n3. [Measuring the error](#Error)\n4. [Basic methods](#Basic)\n5. [Moving Averages](#Averages)\n6. [Concolusions](#Conclusions)\n\n***\n\n<a name=\"Introduction\"><\/a>\n# (1) Introduction\n\nIn this notebook I will study a few methods based in **time series** to forecast. With the intention of compare how well these methods work, I will focus on **one particular set of data**.\n\nThis set of data corresponds to the **stock prices** of the company **CPS Technologies Corporation** from **2015-01-20** to **2017-11-10** and I will focus on **predicting close prizes**.\n\nThis project has two main **goals**:\n* To understand the time series based algorithms that are use for forecasting and implement them in python, applying each one to the same problem.\n* To familiarize with the error metrics in time series. This ways to measure error are not exactly the same that I have encounter with in problems that dont rely on temporal structure (such as supervised and unsupervised problems of regression and classification).\n\nDue to this goals, I **will not include** in this first approach algorithms that I am already know, such as linear regression (and generalized versions of this one, such as LASSO or Polynomial Regression), tree based algorithms or deep learning techniques (LSTM for instance).","d436e860":"<a name=\"Averages\"><\/a>\n# (5) Moving averages","897b74bd":"### (4.2) Naive forecast\n\n$$\n    \\hat{y}_{t + N} = y_t\n$$","24e07257":"<a name=\"Conclusions\"><\/a>\n# (6) Conclusions\n\nWe are going to plot the erros, the best algorithm in this case will be the one that implies **less error in the predictions**.\n\nThese errors are computed on the same data set, this is an **important remark**: not all of these errors works for comparing the performance of one algorithm between different data sets and data periods.\n\nThe objetive of this sections **is not** claim that one algorithm is better than the others, this depends on the particular problem (set of data and time period). From this section we just can conclude that **for this set of data, this objetive variable and during the considered time period** the algorithm with less error (once we have choose under wich definition of error we are working on) the performance of one of the algorithms is better."}}