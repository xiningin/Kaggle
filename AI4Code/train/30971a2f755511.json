{"cell_type":{"9ab98235":"code","f149aacf":"code","01878a4b":"code","ef94968a":"code","69113326":"code","389ff29a":"code","a1556c08":"code","d37d0896":"code","93adbfd1":"code","909e7db2":"markdown"},"source":{"9ab98235":"import pandas as pd\nimport numpy as np\nimport glob\nfrom scipy.spatial.distance import cdist\nimport json\nimport matplotlib.pylab as plt\nimport pickle\n\nfrom shapely.geometry import Point, LineString\nfrom tqdm import tqdm\nimport warnings\nfrom shapely.geometry import Polygon\nfrom shapely.ops import nearest_points\nimport multiprocessing\nimport os\nimport math\n\nimport multiprocessing\nfrom multiprocessing import Pool\n\nnum_cores = multiprocessing.cpu_count()\n\nwarnings.simplefilter('ignore')","f149aacf":"# options\n\ntrain_waypoins = pd.read_csv('..\/input\/indoor-location-train-waypoints\/train_waypoints.csv')\nGRID_SIZE = 1 # meters\nWALL_THRESHOLD = 0.5 ","01878a4b":"submission = pd.read_csv('..\/input\/my-preds\/submission_3.645.csv')\ntarget_sites = submission['site_path_timestamp'].apply(lambda x: x.split('_')[0]).unique()","ef94968a":"metadata = pd.DataFrame(glob.glob('..\/input\/indoor-location-navigation\/metadata\/*'))\nmetadata.columns=['path']\nmetadata['site'] = metadata['path'].apply(lambda x: x.split('\/')[-1])\nmetadata = metadata[metadata['site'].isin(target_sites)]['path'].values","69113326":"floor_map = {\"B2\":-2, \"B1\":-1, \"F1\":0, \"F2\": 1, \"F3\":2,\n             \"F4\":3, \"F5\":4, \"F6\":5, \"F7\":6,\"F8\":7,\"F9\":8,\n             \"1F\":0, \"2F\":1, \"3F\":2, \"4F\":3, \"5F\":4, \"6F\":5,\n             \"7F\":6, \"8F\": 7, \"9F\":8}","389ff29a":"GRID_AREA = GRID_SIZE * GRID_SIZE\n\ndef generate_array_map(site):\n    \n    print(f' Started {site}')\n    \n    metadata_floor_paths = glob.glob(f'..\/input\/indoor-location-navigation\/metadata\/{site}\/*')\n    \n    for metadata_floor_path in metadata_floor_paths:\n        floor = metadata_floor_path.split('\/')[-1]\n        floor_val = floor_map[floor]\n\n        corridor_path = f'..\/input\/indoor-location-navigation-scaled-geojson\/scaled_geojson\/{site}\/{floor}\/shapely_geometry.pkl'\n        with open(corridor_path, 'rb') as f:\n            corridor = pickle.load(f)\n                        \n        minx, miny, maxx, maxy = corridor.bounds\n\n        encoded_map = []\n        for y in range(0, math.ceil(maxy)):\n            encoded_map.append([])\n            for x in range(0, math.ceil(maxx)):\n\n                cell_polygon = Polygon([(x * GRID_SIZE, y * GRID_SIZE),\n                                        (x * GRID_SIZE, (y + 1) * GRID_SIZE),\n                                        ((x + 1) * GRID_SIZE, (y + 1) * GRID_SIZE),\n                                        ((x + 1) * GRID_SIZE, y * GRID_SIZE)])\n\n                intersection_area = GRID_AREA - corridor.intersection(cell_polygon).area\n                if intersection_area >= WALL_THRESHOLD:\n                    encoded_map[y].append('#')\n                    continue\n\n\n                encoded_map[y].append('.')\n\n        waypoints_on_floor = train_waypoins[(train_waypoins['site']==site) & (train_waypoins['floor']==floor_val)]\n        for i, wp in waypoints_on_floor.iterrows():\n            x = math.floor(wp['x'] \/ GRID_SIZE)\n            y = math.floor(wp['y'] \/ GRID_SIZE)\n\n            encoded_map[y][x] = '*'\n            \n        encoded_map = np.array(encoded_map).T\n        \n        with open(f'{site}_{floor}_array_map.pkl', 'wb') as f:\n            pickle.dump(encoded_map, f)\n\n    print(f' Done! {site}')","a1556c08":"with Pool(num_cores) as pool:\n    pool.map(generate_array_map, [t for t in target_sites])  ","d37d0896":"def display_aa_map(array_map):\n    ar_map = array_map\n    for line in reversed(ar_map):\n        print()\n        for cell in line:\n            print(cell, end='')","93adbfd1":"# example   \nwith open('.\/5da138274db8ce0c98bbd3d2_F2_array_map.pkl', 'rb') as f:\n    ex= pickle.load(f)\n    \ndisplay_aa_map(np.array(ex))","909e7db2":"## Overview\nWe found that some paths after snap-to-grid are obviously not right.\n\nSuch as the image in the left. \n\nWhat I did in this notebook is, if the path obviously cross a wall, fix the path like the following image. \n\n<img src= \"https:\/\/i.imgur.com\/a8B34Hm.png\" alt =\"the structure of the model\" style='width: 500px;'>\n\nTo achieve it, I thought I need to calculate the distance of between 2 points take the wall into account, not the direct distance.\n\nSo I created the character version of maps. Then I applied Breadth First Search to get the rough distance in the notebook. "}}