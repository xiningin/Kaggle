{"cell_type":{"af6dd244":"code","889c4466":"code","97225446":"code","956cef59":"code","cc1cea01":"code","5463aa0d":"code","0fe5ddd5":"code","ee58ce5c":"code","77222362":"code","73200716":"code","b000ee0a":"code","ba8077fc":"code","9db0b703":"code","19cdeddc":"code","22105a62":"code","8651aa72":"code","816586a1":"code","1baaec37":"code","d1f18d43":"code","58cae9d2":"markdown","5051e879":"markdown","5dd0c92f":"markdown","62d0c0fd":"markdown","b5b525d1":"markdown","449130a0":"markdown","b2d2fb83":"markdown","2c63067a":"markdown","697ef4ac":"markdown","3a378d3a":"markdown","fd43af5f":"markdown","0af65240":"markdown","1004ba16":"markdown","ce609f2e":"markdown","55cd66db":"markdown","45e4e9a5":"markdown","a7569c62":"markdown","c89ad607":"markdown","f0abebf7":"markdown","d24d7201":"markdown","b6466fa4":"markdown","d351dbb7":"markdown"},"source":{"af6dd244":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","889c4466":"df = pd.read_csv(\"..\/input\/av-hackathon-4\/Train_awoL0xl.csv\")","97225446":"#Print sample few rows\ndf.head()","956cef59":"!pip install pmdarima","cc1cea01":"import os\nimport warnings\nwarnings.filterwarnings('ignore')\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nplt.style.use('fivethirtyeight')\nfrom pylab import rcParams\nrcParams['figure.figsize'] = 10, 6\nfrom statsmodels.tsa.stattools import adfuller\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nfrom statsmodels.tsa.arima_model import ARIMA\nfrom pmdarima.arima import auto_arima\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\nimport math\nimport numpy as np","5463aa0d":"df.shape","0fe5ddd5":"df2 = df[df.stock == 0]\nplt.figure(figsize=(10,6))\nplt.grid(True)\nplt.xlabel('Dates')\nplt.ylabel('Close Prices')\nplt.plot(df2['Close'])\nplt.title('Stock #1 closing price')\nplt.show()","ee58ce5c":"#Test for stationarity\ndef test_stationarity(timeseries):\n    #Determing rolling statistics\n    rolmean = timeseries.rolling(12).mean()\n    rolstd = timeseries.rolling(12).std()\n    #Plot rolling statistics:\n    plt.plot(timeseries, color='blue',label='Original')\n    plt.plot(rolmean, color='red', label='Rolling Mean')\n    plt.plot(rolstd, color='black', label = 'Rolling Std')\n    plt.legend(loc='best')\n    plt.title('Rolling Mean and Standard Deviation')\n    plt.show(block=False)\n    \n    print(\"Results of Dickey Fuller test\")\n    adft = adfuller(timeseries,autolag='AIC')\n    # output for dft will give us without defining what the values are.\n    #hence we manually write what values does it explains using a for loop\n    output = pd.Series(adft[0:4],index=['Test Statistics','p-value','No. of lags used','Number of observations used'])\n    for key,values in adft[4].items():\n        output['critical value (%s)'%key] =  values\n    print(output)\n    \ntest_stationarity(df2.Close)","77222362":"result = seasonal_decompose(df2.Close, model='multiplicative', freq = 30)\nfig = plt.figure()  \nfig = result.plot()  \nfig.set_size_inches(16, 9)","73200716":"from pylab import rcParams\nrcParams['figure.figsize'] = 10, 6\ndf_log = np.log(df2.Close)\nmoving_avg = df_log.rolling(12).mean()\nstd_dev = df_log.rolling(12).std()\nplt.legend(loc='best')\nplt.title('Moving Average')\nplt.plot(std_dev, color =\"black\", label = \"Standard Deviation\")\nplt.plot(moving_avg, color=\"red\", label = \"Mean\")\nplt.legend()\nplt.show()","b000ee0a":"#split data into train and training set\ntrain_data, test_data = df_log[3:int(len(df_log)*0.9)], df_log[int(len(df_log)*0.9):]\nplt.figure(figsize=(10,6))\nplt.grid(True)\nplt.xlabel('Dates')\nplt.ylabel('Closing Prices')\nplt.plot(df_log, 'green', label='Train data')\nplt.plot(test_data, 'blue', label='Test data')\nplt.legend()","ba8077fc":"df3 = df2[[\"holiday\",\"unpredictability_score\"]]\nmodel_autoARIMA = auto_arima(df2.Close, start_p=0, start_q=0,\n                      test='adf',       # use adftest to find             optimal 'd'\n                      max_p=3, max_q=3, # maximum p and q\n                      m=1,              # frequency of series\n                      d=None,           # let model determine 'd'\n                      seasonal=False,   # No Seasonality\n                      start_P=0, \n                      D=0, \n                      trace=True,\n                      error_action='ignore',  \n                      suppress_warnings=True, \n                      stepwise=True,\n                      exogenous= df3)\nprint(model_autoARIMA.summary())","9db0b703":"model_autoARIMA.plot_diagnostics(figsize=(15,8))\nplt.show()","19cdeddc":"from statsmodels.tsa.statespace.sarimax import SARIMAX\nmodel= SARIMAX(df2.Close, \n exog=df3,\n order=(1,0,3),\n enforce_invertibility=False, enforce_stationarity=False)","22105a62":"df_test = pd.read_csv(\"..\/input\/av-hackathon-4\/Test_QQKW4dv.csv\")\ndf_test.head()","8651aa72":"df_test2 = df_test[df_test.stock == 0]","816586a1":"df_test3 = df_test2[[\"holiday\",\"unpredictability_score\"]]\nresults= model.fit()\nforecast_1= results.forecast(steps=len(df_test2.stock), exog=df_test3)","1baaec37":"print(forecast_1)","d1f18d43":"train_data = df2.Close\ntest_data = forecast_1\nplt.figure(figsize=(10,6))\nplt.grid(True)\nplt.xlabel('Dates')\nplt.ylabel('Closing Prices')\nplt.plot(train_data, 'green', label='Train data')\nplt.plot(test_data, 'blue', label='Test data')\nplt.legend()","58cae9d2":"# 13. Append the forecast with the train set","5051e879":"### The best model is ARIMA(1,0,3) which means we are describing stock closing price response variable (Y) by combining a 1st order Auto-Regressive model and a 3rd order Moving Average model.","5dd0c92f":"# 10. Plot the diagnostic metrics for autoarima","62d0c0fd":"# 11. Pick the best model for ARIMAX","b5b525d1":"### Autoarima is useful as it selects the best values of p,d,q for time series stationarity through an iterative process. Below is brief explaination of p,d,q values\n\n### 1. p -> is the number of autoregressive terms\n### 2. d -> is the number of nonseasonal differences \n### 3. q -> is the number of lagged forecast errors","449130a0":"# 2. Install package pmdarima","b2d2fb83":"# 7. Check 12 month moving average","2c63067a":"### The forecast is linear line and not as good as expected,more work is required to get better forecast, will explore more in next version, stay tuned.","697ef4ac":"# 5. Test for stationarity","3a378d3a":"# 9. Run Autoarima with exogenous variables","fd43af5f":"### Based on the above diagnostic metrics we see the model is accurate\n\n### * Residual does not have specific trend\n### * Histogram is near normal","0af65240":"### Based on the high p-value = 0.90 we observe that the time series is non stationary","1004ba16":"### Based on multiplicative model we see that the time series has a strong trend and seasonal component. Residual is mostly flat so most of the variance is explained by trend and seasonality","ce609f2e":"# 0.Setup the environment","55cd66db":"# 4. Plot the closing price of Stock 1","45e4e9a5":"# 1. Read the training data","a7569c62":"### We have the stock number and date, we have the open, high, low and close price for each date. An indicator to show if a particular day was holiday or not and an unpredictability score showing how volatile the stock is","c89ad607":"# 12. Read in the test file","f0abebf7":"# 6. Check for seasonal decomposition","d24d7201":"### Stationarity check is important in time series as we need to check what mathematical operations on the series make it predictable for future. For stationary time series the mean and variance is constant, so it is more predictable compared to non stationary time series. One of the test for stationarity is Augmented Dickey Fuller Test (ADF for short)\n\n### Wiki link: https:\/\/en.wikipedia.org\/wiki\/Augmented_Dickey%E2%80%93Fuller_test\n\nCritical values for Dickey\u2013Fuller t-distribution.\nWithout trend\tWith trend\nSample size\t1%\t5%\t1%\t5%\nT = 25\t\u22123.75\t\u22123.00\t\u22124.38\t\u22123.60\nT = 50\t\u22123.58\t\u22122.93\t\u22124.15\t\u22123.50\nT = 100\t\u22123.51\t\u22122.89\t\u22124.04\t\u22123.45\nT = 250\t\u22123.46\t\u22122.88\t\u22123.99\t\u22123.43\nT = 500\t\u22123.44\t\u22122.87\t\u22123.98\t\u22123.42\nT = \u221e\t\u22123.43\t\u22122.86\t\u22123.96\t\u22123.41\nSource[2]:373","b6466fa4":"# 3.Import necessary libraries","d351dbb7":"# 8. Split the data in 90% test and 10% training"}}