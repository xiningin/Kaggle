{"cell_type":{"0223a739":"code","43359b1c":"code","53acf0d5":"code","addb7d28":"code","95eb70bd":"code","454b75f2":"code","49415aaa":"code","259b99a6":"markdown","b7b557d9":"markdown","870e2a1f":"markdown","0a647ce9":"markdown","dd8cfdd7":"markdown"},"source":{"0223a739":"import matplotlib.pyplot as plt\nimport numpy as np","43359b1c":"%matplotlib inline\ncenter_1 = np.array([1,1])\ncenter_2 = np.array([5,5])\ncenter_3 = np.array([8,1])\n\ndata_1 = np.random.randn(200, 2) + center_1\ndata_2 = np.random.randn(200,2) + center_2\ndata_3 = np.random.randn(200,2) + center_3\n\ndata = np.concatenate((data_1, data_2, data_3), axis = 0)\n\nplt.scatter(data[:,0], data[:,1], s=7)","53acf0d5":"def init_centroids(datapoints, amount):\n    return datapoints[np.random.choice(datapoints.shape[0], amount)]\n\ndef find_closest_centroids(datapoints, centroids):\n    idxs = np.zeros(datapoints.shape[0])\n    for i in range(len(datapoints)):\n        distances = np.power(np.array(datapoints[i] - centroids), 2)\n        idxs[i] = np.argmin(np.sum(distances, axis = 1))\n    return idxs\n\ndef centroid_means(data, idxs, no_centroids, dimensionality):\n    new_centroids = np.zeros((no_centroids, dimensionality))\n    for i in range(no_centroids):\n        matched_datapoints = data[i == idxs]\n        new_centroids[i] = np.mean(matched_datapoints, axis = 0)\n    return new_centroids","addb7d28":"%matplotlib inline\nno_centroids = 3\nold_centroids = init_centroids(data, no_centroids)\nnew_centroids = old_centroids\nerr = 1\nwhile err != 0:\n    idxs = find_closest_centroids(data, new_centroids)\n    plt.scatter(data[:,0], data[:,1], c = idxs, s=7)\n    plt.scatter(new_centroids[:,0], new_centroids[:,1], marker='*', c=\"0\", s=150)\n    old_centroids = new_centroids\n    new_centroids = centroid_means(data,idxs, no_centroids, 2)\n    err = np.power(np.array(new_centroids - old_centroids), 2)\n    err = np.sum(err)\n    plt.pause(0.2)","95eb70bd":"from PIL import Image\nimg_data = np.asarray(Image.open(\"..\/input\/Hellroter.jpg\"))\nplt.imshow(img_data)\nimg_data = img_data \/ 255.0 #normalize so all values are between 0 and 1\nimg_data = img_data.reshape(-1, 3)","454b75f2":"no_centroids = 16\ncentroids = init_centroids(img_data, no_centroids)\nfor i in range(10):\n    idxs = find_closest_centroids(img_data, centroids)\n    centroids = centroid_means(img_data,idxs, no_centroids, 3)\n    print(f\"Finished iteration {i+1} out of 10.\")","49415aaa":"compressed_img = np.array([centroids[int(idx)] for idx in idxs])\ncompressed_img = compressed_img.reshape(300,300,3)\nplt.imshow(compressed_img)","259b99a6":"---\nThe algorithm can be also used for image compression (although there are better alternatives), by finding clusters in the pixel values and then using the centroids instead. Below is an example of it.\n---","b7b557d9":"---\nHere's just a quick visualization of how K-Means works.","870e2a1f":"---\n# init_centroids(datapoihnts, amount)\ninit_centroids() initializes the centroids by sampling from the datapoints.\n# find_closest_centroids(datapoints, centroids)\nfind_closest_centroids() simply takes the euclidean distance from each datapoint to each centroid and returns a list of indices, which indicate the closest centroid.\n# centroid_means(data, idxs, no_centroids, dimensionality)\ncentroid_means() computes the new position of each centroid by calculating the mean of the datapoints which are assigned to it.","0a647ce9":"---\n## K-Means algorithm\nThis notebook represents my implementation of the K-Means algorithm, which finds clusters in data by successively updating their position based on the datapoints which are closest the respective cluster. ","dd8cfdd7":"We first create some random data for representation"}}