{"cell_type":{"ff3b310d":"code","ae7f6da0":"code","93df2603":"code","b24c010c":"code","d58b0ee0":"code","805e2b95":"code","a904ed9a":"code","9b5fb048":"code","cd3697e2":"code","5f294f0b":"code","9a181be0":"code","3451351e":"code","d8f17b53":"code","196c911e":"code","eaeb313e":"code","f34d2752":"code","a7016354":"code","77f5824f":"code","d72f6c11":"code","dea605fc":"code","68efacd2":"markdown","452ceb6a":"markdown","47b4a4b8":"markdown","8310f6c4":"markdown","f66c5c93":"markdown","84f8e267":"markdown","f35d0d15":"markdown","07036f13":"markdown","a0a8efc5":"markdown","f10b83e6":"markdown"},"source":{"ff3b310d":"#IMPORTING LIBRARIES\nimport tensorflow as tf\nimport numpy as np\nfrom keras.preprocessing.image import ImageDataGenerator","ae7f6da0":"#train_data is used for feature scaling and image augmentation (image augmentation is applied to avoid overfitting).\ntrain_data = ImageDataGenerator(rescale = 1.\/255,shear_range = 0.2, zoom_range = 0.2, horizontal_flip = True)\n\n#defining training set, here size of image is reduced to 64x64, batch of images is kept as 64 and class is defined as 'binary'.\ntraining_set = train_data.flow_from_directory('..\/input\/cat-and-dog\/training_set\/training_set', batch_size = 64, target_size = (64,64), class_mode = 'binary')","93df2603":"#applying same scale as training set, but only feature scaling is applied. image augmentation is avoided to prevent leakage of testing data.\ntest_data = ImageDataGenerator(rescale = 1.\/255)\n\n#defining testing set\ntesting_set = test_data.flow_from_directory('..\/input\/cat-and-dog\/test_set\/test_set', batch_size = 64, target_size = (64,64), class_mode = 'binary')","b24c010c":"#defining the CNN as a sequence of layers.\ncnn = tf.keras.models.Sequential()","d58b0ee0":"#adding 1st Convolutional layer\n#note that in image augmentation we kept the image size as 64x64, therefore input_shape should also be same [64,64,3] (here 3 signifies that this is a colorful image (R,G,B))\ncnn.add(tf.keras.layers.Conv2D(filters = 32,kernel_size = 3, input_shape = [64,64,3],activation = 'relu'))\n#activation function relu is applied to decrease any linearity that might have arrised while applying filters.","805e2b95":"# applying max pooling\ncnn.add(tf.keras.layers.MaxPool2D(pool_size = 2, strides = 2))","a904ed9a":"#adding 2nd Convolutional layer\ncnn.add(tf.keras.layers.Conv2D(filters = 32,kernel_size = 3, activation = 'relu'))\ncnn.add(tf.keras.layers.MaxPool2D(pool_size = 2, strides = 2))","9b5fb048":"#adding 3rd Convolutional layer\ncnn.add(tf.keras.layers.Conv2D(filters = 32,kernel_size = 3, activation = 'relu'))\ncnn.add(tf.keras.layers.MaxPool2D(pool_size = 2, strides = 2))","cd3697e2":"#the input of step 4 is an flattened array,\ncnn.add(tf.keras.layers.Flatten())","5f294f0b":"#forming an ann with 128 input neurons\ncnn.add(tf.keras.layers.Dense(units = 128, activation = 'relu'))","9a181be0":"#adding ouput layer of the ann\ncnn.add(tf.keras.layers.Dense(units = 1, activation = 'sigmoid'))","3451351e":"#compiling the CNN\ncnn.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])","d8f17b53":"#training the model\ncnn.fit(x = training_set, validation_data = testing_set, epochs = 25)","196c911e":"cnn.save('catdog_cnn_model.h5')","eaeb313e":"from keras.models import load_model \nclassifier = load_model('catdog_cnn_model.h5')","f34d2752":"import numpy as np\nfrom keras.preprocessing import image\ntraining_set.class_indices","a7016354":"image.load_img('..\/input\/cat-and-dog\/test_set\/test_set\/cats\/cat.4014.jpg')","77f5824f":"#importing images\ntest_img = image.load_img('..\/input\/cat-and-dog\/test_set\/test_set\/cats\/cat.4014.jpg',target_size = (64,64))\n#converting image to array\ntest_img = image.img_to_array(test_img)\ntest_img = np.expand_dims(test_img,axis = 0)\nresult = classifier.predict(test_img)\nif result[0][0] >= 0.5:\n    prediction = 'dog'\nelse:\n    prediction = 'cat'\nprint(prediction)","d72f6c11":"image.load_img('..\/input\/cat-and-dog\/test_set\/test_set\/dogs\/dog.4014.jpg')","dea605fc":"#importing images\ntest_img = image.load_img('..\/input\/cat-and-dog\/test_set\/test_set\/dogs\/dog.4014.jpg',target_size = (64,64))\n#converting image to array\ntest_img = image.img_to_array(test_img)\ntest_img = np.expand_dims(test_img,axis = 0)\nresult = classifier.predict(test_img)\nif result[0][0] >= 0.5:\n    prediction = 'dog'\nelse:\n    prediction = 'cat'\nprint(prediction)","68efacd2":"**CLASSIYING WHETHER THEIR IS A DOG OR A CAT IN A PICTURE USING CNN.**\n","452ceb6a":"**STEP -3 ) FLATTENING**","47b4a4b8":"**IT'S A DOG**","8310f6c4":"# HERE CNN IS DIVIDED INTO 4 STEPS\n**1. CONVOLUTION**\n\n**2. POOLING**\n\n**3. FLATTENING**\n\n**4. FULL CONNECTION**","f66c5c93":"# **PREDICTING VALUES**","84f8e267":"**IT'S A CAT**","f35d0d15":"**STEP - 4 ) FULL CONNECTION**","07036f13":"**0 MEANS CATS AND 1 MEANS DOGS**","a0a8efc5":"**STEP - 2) APPLYING MAX POOLING**","f10b83e6":"**STEP - 1) ADDING CONVOLUTIONAL LAYER**"}}