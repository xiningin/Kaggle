{"cell_type":{"8b74896a":"code","9d96d564":"code","a12f8c0f":"code","1ffc6610":"code","50082bc7":"code","ccb6685d":"code","dfe5e3e3":"code","2f5a026b":"code","2a1c25b5":"code","3845ecf2":"code","ae6faa2c":"code","154f5a04":"code","4af415d2":"code","cf96d778":"code","03f694d4":"code","7aa37aaf":"markdown","c80ed8be":"markdown","909914df":"markdown","ffef3dd0":"markdown","7cc10e5a":"markdown","5939cecd":"markdown","ce1db665":"markdown","493ddbd9":"markdown","3f8b90a0":"markdown","bb514c1f":"markdown","31a221d2":"markdown","3d0c1707":"markdown"},"source":{"8b74896a":"import random as rd\nimport time\n\nfrom functools import lru_cache\nfrom typing import Dict, List, Tuple","9d96d564":"global instance\n\n\"\"\"with open(input(\"Put here a (.txt) instance path : \"), 'r') as f:\n     instance = [[int(num) for num in line.split('\\t')] for line in f]\"\"\"\ninstance=[[0,12,10,19,8],[12,0,3,7,2],[10,3,0,6,20],[19,7,6,0,4],[8,2,20,4,0]]\n\nfor i in instance:\n    print(\"\\t\".join([str(l).rjust(4) for l in i]))","a12f8c0f":"def solve_tsp_dynamic_programming(first_city) -> Tuple[List, int]:\n    # Get initial set {0, 1, 2, ..., tsp_size} as a frozenset because since\n    # @lru_cache requires a hashable type\n    N = frozenset(range(0, len(instance)))\n    N = N.difference({first_city-1})\n    memo: Dict[Tuple, int] = {}\n\n    # Step 1: get minimum distance\n    @lru_cache(maxsize=len(instance)**2)\n    def dist(ni, N: frozenset):\n        if not N:\n            return instance[ni][first_city-1]\n\n        # Store the costs in the form (nj, dist(nj, N))    \n        costs = [\n            (nj, instance[ni][nj] + dist(nj, N.difference({nj})))\n            for nj in N\n        ]\n        nmin, min_cost = min(costs, key=lambda x: x[1])\n        memo[(ni, N)] = nmin\n        return min_cost\n\n    best_distance = dist(first_city-1, N)\n\n    # Step 2: get path with the minimum distance\n    ni = first_city-1\n    solution = [first_city]\n    while N:\n        ni = memo[(ni, N)]\n        solution.append(ni+1)\n        N = N.difference({ni})\n    solution.append(first_city)\n    return solution, best_distance\n    ","1ffc6610":"def f(x):\n    total_cost = 0\n    for c in range(1,len(x)):\n        total_cost += instance[x[c - 1]][x[c]]\n    return total_cost","50082bc7":"def NS_swapping(x, lb, ub): #lb>0 \n    bound = len(x)\n    xc = None    \n    if (lb < bound and ub < bound):\n        xc = x.copy()\n        xc[lb], xc[ub] = xc[ub], xc[lb]\n    return xc\n\ndef NS_insertion_before(x, lb, ub):  #lb>0 \n    bound = len(x)\n    xc = None\n    if (lb < bound and ub < bound):\n        xc = x.copy()\n        xc.insert(lb, x[ub]) \n        xc.pop(ub+1)\n    return xc\n\n\ndef NS_two_opt(x, lb, ub):\n    bound = len(x)\n    x1=[]\n    if lb < ub and (0 < lb < bound-1 and 0 < ub < bound-1) : \n        x1=x[:lb]\n        x1.extend(reversed(x[lb:ub+1]))\n        x1.extend(x[ub+1:])\n    return x1","ccb6685d":"def initialization(first_city):\n    bound = len(instance)\n    x=[first_city]\n    sol=rd.sample(range(0, bound), bound)\n    for i in range(0,len(sol)-1):\n        if sol[i] == first_city:\n            sol.pop(i)\n    x=x+sol+x\n    \n    return x","dfe5e3e3":"def neighbrehood(x, k):\n    bound = len(x)\n    N=[]\n    if(k==1):\n        for i in range(1,bound-2):\n            for j in range(i+1,bound-1):\n                N.append(NS_swapping(x,i,j))\n    elif(k==2):\n        for i in range(1,bound-2):\n            for j in range(i+1,bound-1):\n                N.append(NS_insertion_before(x,i,j))\n    elif(k==3):\n        for i in range(1,bound-2):\n            for j in range(i+1,bound-1):\n                N.append(NS_two_opt(x,i,j))\n    return N\n\nglobal voisins","2f5a026b":"def shake(x, k):\n    N=neighbrehood(x,k)\n    xp=rd.choice(N)\n    return xp","2a1c25b5":"def change_neighborhood(x, xp, k):\n    if f(xp) < f(x):\n        x = xp\n    else:\n        k += 1\n    return x,k","3845ecf2":"k_max = 3\ndef RVNS(x, k_max, t = 5):\n    start_time = time.time() \n    while time.time() - start_time < t*60:\n        k=1\n        while k <= k_max:\n            xp = shake(x,k)  \n            x, k = change_neighborhood(x, xp, k) \n    return x","ae6faa2c":"# first improvement : \ndef first_improvement(x, l): \n    N=neighbrehood(x,l)\n    for i in range(0,len(N)):\n        if f(N[i])< f(x):\n            x=N[i]\n            break\n    return x","154f5a04":"l_max=2\ndef VND(x, l_max):\n    l = 1\n    while l <= l_max:\n        xp = shake(x, l) \n        xp = first_improvement(x, l) \n        x,l = change_neighborhood(x, xp, l)\n    return x","4af415d2":"def GVNS(x, t=5, k_max=3, l_max=2):\n    start_time = time.time() \n    x=RVNS(x,k_max,0.2)\n    while time.time() - start_time < t*60:\n        k=1\n        while k <= k_max:\n            x1 = shake(x,k)  \n            x2 = VND(x1, l_max)\n            x, k = change_neighborhood(x, x2, k)\n    return x,f(x)","cf96d778":"def plot(solution):    \n    import numpy as np\n    import matplotlib.pyplot as plt\n    from matplotlib.offsetbox import AnchoredText\n\n    N = len(solution)\n    x = np.random.rand(N)\n    y = np.random.rand(N)\n\n    plt.figure(figsize=((10,8)))\n\n    for i in range(1,N-1):\n        plt.scatter(x[i-1], y[i-1])\n        plt.annotate(solution[i],xy=(x[i-1], y[i-1]), xytext=(x[i], y[i]), arrowprops=dict(arrowstyle=\"<-\",connectionstyle=\"arc3\"))\n\n    plt.scatter(x[N-2], y[N-2])    \n    plt.annotate(\"D\u00e9part\",xy=(x[N-2], y[N-2]), xytext=(x[0], y[0]),  arrowprops=dict(arrowstyle=\"<-\",connectionstyle=\"arc3\"))\n\n    plt.show()","03f694d4":"import os\nprint(\"TSP solver\\n\")\nprint(\" Menu \".center(20, '*'))\nprint(\"Please choose one of these methods :\")\nprint(\"1- Solve with dynamic programming \\n2- Solve with GVNS\")\n\nwhile True:\n    #choice=int(input(\"Your choice: \"))\n    choice=2\n    first_city = 3\n    if(choice==1):\n        os.system(\"cls\")\n        solution, dist_min=solve_tsp_dynamic_programming(first_city)\n        break\n    elif(choice==2):\n        os.system(\"cls\")\n        x = initialization((first_city-1))\n        #temps = int(input(\"Time : \")) #minute\n        solution,dist_min=GVNS(x,1)\n        for i in range(0,len(solution)) :\n            solution[i]+=1\n        break\n\nprint(\"\\n\\nOPTIMAL POLICY : {}\".format(solution))\nprint(\"OPTIMAL VALUE : {}\".format(dist_min))\nplot(solution)","7aa37aaf":"**Improuve intiale solution**","c80ed8be":"**Main program**","909914df":"**Reading data**","ffef3dd0":"**local serach VND**","7cc10e5a":"**Changing neighberhood**","5939cecd":"**GVNS**","ce1db665":"**Shaking**","493ddbd9":"**Neighborhood structure**","3f8b90a0":"**Affichage**","bb514c1f":"**Objective function**","31a221d2":"Solve TSP to optimality with dynamic programming.\n\n    Parameters\n    ----------\n\n    global instance\n        Distance matrix of shape (n x n) with the (i, j) entry indicating the\n        distance from node i to j.\n\n    first_city\n        Used to define the source city where the problem begins. \n\n    Returns\n    -------\n\n    solution\n        A permutation of nodes from 1 to n that produces the least total\n        distance.\n\n    best_distance\n        The total distance the optimal permutation produces.\n\n    Notes\n    -----\n\n    Algorithm: cost of the optimal path\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    Consider a TSP instance with 3 nodes: {0, 1, 2}. Let dist(0, {1, 2}) be the\n    distance from 0, visiting all nodes in {1, 2} and going back to 0. This can\n    be computed recursively as:\n        \n        dist(ni, N) =   min   ( c_{ni, nj} + dist(nj, N - {nj}) )\n                      nj in N\n    and\n        dist(ni, {}) = c_{ni, 0}\n\n    With starting point as dist(0, {1, 2, ..., tsp_size}). The notation\n    N - {nj} is the difference operator, meaning set N without node nj.\n\n    Algorithm: compute the optimal path\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    The previous process returns the distance of the optimal path. To find the\n    actual path, we need to store in a memory the following key\/values:\n        memo[(ni, N)] = nj_min\n\n    With nj_min the node in N that provided the smallest value of dist(ni, N).\n    Then, the process goes backwards starting from memo[(0, {1, 2, ..., tsp_size})].\n    In the previous example, suppose memo[(0, {1, 2})] = 1.\n    Then, look for memo[(1, {2})] = 2.\n    Then, since the next step would be memo[2, {}], stop there. \n    The optimal path would be 0 -> 1 -> 2 -> 0.","3d0c1707":"**Dynamic programming**"}}