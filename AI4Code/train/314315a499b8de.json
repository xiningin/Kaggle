{"cell_type":{"26909f63":"code","25b95c4d":"code","da2e50f5":"code","ca8e8320":"code","c85a259c":"code","684d64ba":"code","65760b57":"code","56d48968":"code","eb5aab36":"code","fd3d207b":"code","a6227603":"code","9e87b7d4":"code","5292f647":"code","f557ceb2":"code","61b3b403":"code","9e95ecfa":"code","24c762d5":"code","d6bb77bd":"markdown","a0d950e3":"markdown","d13f8d92":"markdown","e34cab87":"markdown","2f2fc427":"markdown","40b9446a":"markdown","97426b23":"markdown","a3d02ac4":"markdown","0c2e5b90":"markdown","69cc1447":"markdown","00182b69":"markdown","da5799f3":"markdown","8a644f86":"markdown"},"source":{"26909f63":"import numpy as np\nimport pandas as pd \nfrom sklearn.model_selection import KFold\n\nimport numpy as np\nimport pandas as pd \n\nimport os\nimport gc\nimport psutil\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set()\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import StandardScaler, Normalizer,MinMaxScaler\nfrom sklearn.preprocessing import RobustScaler\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import roc_auc_score\n\nfrom xgboost import XGBClassifier, XGBRegressor\nfrom sklearn.preprocessing import PowerTransformer\nfrom sklearn.preprocessing import PolynomialFeatures\n\nfrom optuna.integration import LightGBMPruningCallback\n\n# get skewed features to impute median instead of mean\nfrom scipy.stats import skew\nfrom sklearn.ensemble import AdaBoostClassifier\n\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn import linear_model\nfrom sklearn.linear_model import Ridge,Lasso\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.decomposition import PCA\n\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.metrics import roc_auc_score\nfrom xgboost import XGBRegressor, XGBRFRegressor\n\nimport itertools\nimport optuna\nfrom lightgbm import LGBMClassifier,LGBMRegressor\nimport lightgbm as lgb\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom catboost import CatBoostRegressor, CatBoostClassifier\n\nfrom sklearn.experimental import enable_hist_gradient_boosting\nfrom sklearn.ensemble import HistGradientBoostingClassifier\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","25b95c4d":"train_data = pd.read_csv('..\/input\/titanic-create-folds\/TITANIC_Folds.csv') # Read TITANIC_Folds as train_data\ntest_data = pd.read_csv(\"..\/input\/titanic\/test.csv\")","da2e50f5":"train_data.drop('Cabin',axis= 1,inplace= True)\ntest_data.drop('Cabin',axis= 1,inplace= True)\ntrain_data['Age'] = train_data['Age'].fillna(int(train_data['Age'].mean()))\ntest_data['Age'] = test_data['Age'].fillna(int(test_data['Age'].mean()))\ntrain_data['Embarked'] = train_data['Embarked'].fillna(train_data['Embarked'].mode()[0])\ntest_data['Fare'] = test_data['Fare'].fillna(test_data['Fare'].median())\ntrain_data['isTrain'] = 1\ntest_data['isTrain'] = 0\ntt = pd.concat([train_data,test_data])\ntt.drop(['Name','Ticket'],axis=1,inplace = True)\ntt = pd.get_dummies(tt,columns= ['Sex','Embarked'],drop_first = True)\ntrain_data = tt[tt.isTrain == 1]\ntest_data = tt[tt.isTrain == 0]\ntest_data.drop(['Survived','isTrain','fold'],axis=1,inplace = True)\ntrain_data.drop(['isTrain'],axis=1,inplace= True)\n\n# Note don't drop PassengerId column of train_data and test_data as it is used later. Instead drop it only for test and my_folds\nuseful_features = test_data.drop('PassengerId',axis=1).columns.tolist() #########################################\ntest = test_data[useful_features]\nmy_folds = train_data.copy()","ca8e8320":"test.shape, my_folds.shape, useful_features","c85a259c":"# specifing Level no and Round no is very important as it will be used while saving and calling back predictions.\nLevel = 1  \nRound = 1","684d64ba":"params1 = {'learning_rate': 0.06456493896248518,\n 'max_depth': 7,\n 'min_child_weight': 1,\n 'subsample': 0.04862356101154695,\n 'n_estimators': 500,\n 'objective': 'reg:squarederror',\n 'tree_method': 'gpu_hist',\n 'gpu_id': 0,\n 'predictor': 'gpu_predictor'}\nparams2 = {'class_weight': None, 'penalty': 'l1', 'C': 299.66433729038897} # make C capital manually\nparams3 = {'alpha': 11.0, 'solver': 'lsqr'}\nparams4 = {'alpha': 0.1, 'selection': 'random'}\nparams5 = {'device_type': 'gpu',\n 'n_estimators': 10000,\n 'learning_rate': 0.16252217907955982,\n 'num_leaves': 1680,\n 'max_depth': 3,\n 'min_data_in_leaf': 200,\n 'lambda_l1': 35,\n 'lambda_l2': 0,\n 'min_gain_to_split': 3.601576700672523,\n 'bagging_fraction': 0.9,\n 'bagging_freq': 1,\n 'feature_fraction': 0.5}\nparams6 = {'iterations': 1117,\n 'objective': 'Logloss',\n 'bootstrap_type': 'Bayesian',\n 'od_wait': 1782,\n 'learning_rate': 0.2066493569541376,\n 'reg_lambda': 81.15404582657435,\n 'random_strength': 48.51525970973446,\n 'depth': 2,\n 'min_data_in_leaf': 20,\n 'leaf_estimation_iterations': 1,\n 'bagging_temperature': 0.6529712609795437}\nparams7 = {'learning_rate': 'invscaling',\n 'hidden_layer_sizes': (100, 100),\n 'alpha': 0.01,\n 'activation': 'tanh'}\nparams8 = {'leaf_size': 45,\n 'n_neighbors': 10,\n 'algorithm': 'ball_tree',\n 'weights': 'uniform'}\nparams9 = {'class_weight': {1: 1, 0: 1.6080586080586081},\n 'criterion': 'gini',\n 'max_depth': 5,\n 'min_samples_leaf': 5,\n 'min_samples_split': 10}\nparams10 = {'n_estimators': 100,\n 'learning_rate': 0.14393201250983706,\n 'algorithm': 'SAMME.R'}\nparams11 = {'n_estimators': 500,\n 'learning_rate': 0.04332437986657178,\n 'max_depth': 10,\n 'loss': 'deviance',\n 'criterion': 'mse',\n 'max_features': 'log2',\n 'min_samples_split': 0.11746048102131365,  # sample to samples\n 'subsample': 0.95}\nparams12 = {'l2_regularization': 0.04576098032101297,\n 'early_stopping': 'False',\n 'learning_rate': 0.043249466934851565,\n 'max_iter': 10000,\n 'max_depth': 3,\n 'max_bins': 147,\n 'min_samples_leaf': 34,\n 'max_leaf_nodes': 63}\nparams13 = {'device_type': 'gpu',\n 'n_estimators': 10000,\n 'learning_rate': 0.23669948933688556,\n 'num_leaves': 420,\n 'max_depth': 5,\n 'min_data_in_leaf': 200,\n 'lambda_l1': 60,\n 'lambda_l2': 20,\n 'min_gain_to_split': 0.6500838782897054,\n 'bagging_fraction': 0.8,\n 'bagging_freq': 1,\n 'feature_fraction': 0.2}","65760b57":"Algo1 = XGBRegressor(**params1, random_state=141)\nAlgo2 = LogisticRegression(**params2, random_state= 141,fit_intercept=True,solver='liblinear') # make c capital in params\nAlgo3 = Ridge(**params3, random_state=141,fit_intercept=True)\nAlgo4 = Lasso(**params4, random_state = 141,fit_intercept=True)\nAlgo5 = LGBMRegressor(**params5, random_state = 141,objective='regression')\n################################################\nAlgo6 = CatBoostClassifier(**params6, random_state=141)\nAlgo7 = MLPClassifier(**params7, random_state = 141)\nAlgo8 = KNeighborsClassifier(**params8, )\nAlgo9 = DecisionTreeClassifier(**params9, random_state= 141)\nAlgo10 = AdaBoostClassifier(**params10, random_state=141)\nAlgo11 = GradientBoostingClassifier(**params11, random_state = 141)\nAlgo12 = HistGradientBoostingClassifier(**params12, random_state = 141)\nAlgo13 = LGBMClassifier(**params13, random_state = 141)\n#####################################################\n\n\nAlgos = [Algo1, Algo2, Algo3,  Algo4, Algo5, Algo6, Algo7, Algo8, Algo9, Algo10, Algo11, Algo12, Algo13]","56d48968":"my_folds1 = my_folds.copy()          \ntest1  = test.copy()\n\nfinal_test_predictions = [[],[],[],[],[],[],[],[],[],[],[],[],[]]\nfinal_valid_predictions = [dict(),dict(),dict(), dict(),dict(),dict(), dict(),dict(),dict(),dict(), dict(),dict(),dict()]\nscores = [[],[],[],[],[],[],[],[],[],[],[],[],[]]\n\nfor fold in range(5):\n    xtrain = my_folds[my_folds1.fold != fold].reset_index(drop=True)\n    xvalid = my_folds[my_folds1.fold == fold].reset_index(drop=True)\n    xtest = test1.copy()\n    \n    valid_ids = xvalid.PassengerId.values.tolist() # we require Id column so just keep PassengerId in training set don't drop it\n    # note we train of useful_features so PassengerId has no role there\n    \n    ytrain = xtrain.Survived\n    yvalid = xvalid.Survived\n    \n    xtrain = xtrain[useful_features]\n    xvalid = xvalid[useful_features]\n    \n    ## preprocess\n    si = SimpleImputer(strategy='median')\n    xtrain = si.fit_transform(xtrain)\n    xvalid = si.transform(xvalid)\n    xtest = si.transform(xtest)\n    \n    # scale\n    ss = MinMaxScaler()\n    xtrain = ss.fit_transform(xtrain)\n    xvalid = ss.transform(xvalid)\n    xtest = ss.transform(xtest)\n    \n    xtrain = pd.DataFrame(xtrain, columns=useful_features)\n    xvalid = pd.DataFrame(xvalid, columns=useful_features)\n    xtest = pd.DataFrame(xtest, columns=useful_features)\n    \n    \n    \n#     for col in useful_features:\n#         xtrain[col] = np.log1p(xtrain[col])\n#         xvalid[col] = np.log1p(xvalid[col])\n#         xtest[col] = np.log1p(xtest[col]) \n        \n    for i,clf in enumerate(Algos):\n        clf.fit(xtrain, ytrain)\n        if i in [0,1,2,3,4]:\n            #XGBoostRegressor\n            valid_preds = clf.predict(xvalid)\n            test_preds = clf.predict(xtest)\n        else:\n            valid_preds = clf.predict_proba(xvalid)[:,1]\n            test_preds = clf.predict_proba(xtest)[:,1]\n        score = roc_auc_score(yvalid, valid_preds)\n        final_test_predictions[i].append(test_preds)\n        final_valid_predictions[i].update(dict(zip(valid_ids, valid_preds)))\n        scores[i].append(score)","eb5aab36":"for i,clf in enumerate(Algos):\n    print(Algos[i])\n    print(\"score:- \")\n    print(scores[i])\n    print(\"score mean and std:- \")\n    print(np.mean(scores[i]), np.std(scores[i]))\n    temp_valid_predictions = pd.DataFrame.from_dict(final_valid_predictions[i], orient='index').reset_index()\n    temp_valid_predictions.columns = ['PassengerId', f'Level{Level}_Round{Round}_pred_{1+i}']\n    temp_valid_predictions.to_csv(f\"Level{Level}_Round{Round}_valid_pred_{1+i}.csv\", index=False)\n    \n    sample = pd.read_csv(\"..\/input\/titanic\/gender_submission.csv\")\n    sample.Survived = np.mean(np.column_stack(final_test_predictions[i]), axis=1)\n    sample.columns = ['PassengerId', f'Level{Level}_Round{Round}_pred_{1+i}']\n    sample.to_csv(f\"Level{Level}_Round{Round}_test_pred_{1+i}.csv\", index=False)\n    print(\"=\"*40)\n######################################################","fd3d207b":"Logs =pd.DataFrame(zip([type(i).__name__ for i in Algos],scores))\nLogs.columns = ['Algos','Scores']\nLogs['mean_score'] = Logs.Scores.apply(lambda x: np.mean(x))\nLogs['std_dvn'] = Logs.Scores.apply(lambda x: np.std(x))\nLogs['Level'] = Level\nLogs['Round'] = Round\ncol_names = list(Logs.columns)\nLogs = Logs.reset_index()\ncol_names =['model_no'] + col_names\nLogs.columns = col_names\nLogs.model_no = list(range(1,Logs.shape[0]+1))\nLogs.to_csv(f\"Logs_Level{Level}_Round{Round}.csv\",index=False)\nLogs","a6227603":"df = train_data.copy()\ndf_test = test_data.copy()\n\nfor i,algo in enumerate(Algos):\n    df1 =pd.read_csv(f\"Level{Level}_Round{Round}_valid_pred_{1+i}.csv\")\n    df= df.merge(df1, on='PassengerId', how='left')\n    df_test1 = pd.read_csv(f\"Level{Level}_Round{Round}_test_pred_{1+i}.csv\")\n    df_test=df_test.merge(df_test1, on='PassengerId', how='left')","9e87b7d4":"df.columns","5292f647":"df_test.columns","f557ceb2":"# Find the column name of added data\nfav_col=[f\"Level{Level}_Round{Round}_pred_{1+i}\" for i in range(len(Algos))]\nfav_col","61b3b403":"fig, ax = plt.subplots(1,2,figsize=(20,8))         # Sample figsize in inches\nax[0].title.set_text(\"OOF\")\nax[1].title.set_text(\"Test\")\nsns.heatmap(df[fav_col+ ['Survived']].corr(), annot=True, linewidths=.5, ax=ax[0])\nsns.heatmap(df_test[fav_col].corr(), annot=True, linewidths=.5, ax=ax[1])","9e95ecfa":"#import matplotlib as plt\nimport plotly.figure_factory as ff\nimport plotly.express as px\n\nhist_data = [df[str(i)] for i in fav_col] +[df.Survived] \ngroup_labels = fav_col +['True Label'] #['top1', 'top2', 'top3']\nfig = ff.create_distplot(hist_data, group_labels, bin_size=0.3, show_hist=False, show_rug=False)\nfig.show()","24c762d5":"#import matplotlib as plt\nimport plotly.figure_factory as ff\nimport plotly.express as px\n\nhist_data = [df_test[str(i)] for i in fav_col] #[sub4.target, sub4.target2, sub4.target3]\ngroup_labels = fav_col #['top1', 'top2', 'top3']\nfig = ff.create_distplot(hist_data, group_labels, bin_size=0.3, show_hist=False, show_rug=False)\nfig.show()","d6bb77bd":"<a id=\"3\"><\/a>\n# <p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">PREPROCESSING<\/p>\n","a0d950e3":"<p style=\"font-family:newtimeroman;font-size:120%;color:#444160;\">Either you can add the dataset whoose link I have given above or if you have TITANIC_Create_Folds notebook you can add it's output from <code>Add data<\/code> option. Both contains TITANIC_Folds.csv (modified train set). <br>\nNow read it as train_data.<\/p>","d13f8d92":"<p style=\"font-family:newtimeroman;font-size:120%;color:#444160;\">We draw correlation plot of  (OOF SET + Target) and TEST SET.<\/p>","e34cab87":"<a id=\"5\"><\/a>\n# <p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">TRAIN ALL MODELS<\/p>","2f2fc427":"<a id=\"8.1\"><\/a>\n# <p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">OOF PREDICTIONS vs TARGET<\/p>\n<p style=\"font-family:newtimeroman;font-size:120%;color:#444160;\">Here we plot OOF predictions of each model and Survived column on same plot to compare their distribution.<\/p>","40b9446a":"<a id=\"8.2\"><\/a>\n# <p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">TEST SET PREDICTIONS<\/p>\n<p style=\"font-family:newtimeroman;font-size:120%;color:#444160;\">Here we plot all the TEST SET predictions to see similarity between predictions of each model.<\/p>","97426b23":"<a id=\"7\"><\/a>\n# <p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">CREATE LOGS<\/p>","a3d02ac4":"\n<a id=\"0\"><\/a>\n# <p style=\"background-color:#FFCC70;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:5px 5px;\">LEVEL1 ROUND1<br><p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">INTRODUCTION<\/p>\n<p style=\"font-family:newtimeroman;font-size:120%;color:#444160;\">This is a part of the notebook series <i>\"My_Complete_Pipeline_for_any_ML_Competition\"<\/i> where we are building complete pipeline.<\/p> \n\n\ud83d\udcccLink of first notebook of the series <a href=\"https:\/\/www.kaggle.com\/raj401\/my-complete-pipeline-for-any-ml-competition\">https:\/\/www.kaggle.com\/raj401\/my-complete-pipeline-for-any-ml-competition<\/a><br>\n\ud83d\udcccLink of notebook where we have created folds <a href=\"https:\/\/www.kaggle.com\/raj401\/titanic-create-folds\">https:\/\/www.kaggle.com\/raj401\/titanic-create-folds<\/a><br>\n<p style=\"font-family:newtimeroman;font-size:120%;color:#444160;\">\n    If you like my effort please do <b><span style=\"color:crimson; font-size:20px\">UPVOTE\ud83d\udc4d<\/span><\/b>, it really keeps me motivated. <\/p>\n\n\n<p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:50%;text-align:center;border-radius:20px 60px;\">\"\"<\/p> \n<p style=\"font-family:newtimeroman;font-size:120%;color:#444160;\">This is the Last notebook of ROUND1. So far we have found optimal hyperparameters of several models in ROUND1. Now this is the time we use those models along with their hyperparameter to make predictions on test set.\n<br>In the <b>TITANIC_Create_Folds<\/b> notebook we have modified our training set by adding new column named 'fold' and then saved it as <i>TITANIC_folds.csv<\/i>. In this notebook we will use this modified training set instead of original training set and do hyperparameter tuning of LGBMClassifier using OPTUNA. I am providing the link of <i>TITANIC_folds.csv<\/i> you can just add it to your notebook and you are good to go.<b><br>[Make sure you have added it before moving further. If you have TITANIC_Create_Folds notebook you can also add that notebook instead.]<br><\/b>\n\ud83d\udcccLink of Dataset containing <i>TITANIC_folds.csv<\/i> <a href=\"https:\/\/www.kaggle.com\/raj401\/my-complete-pipeline-for-any-ml-competition\">https:\/\/www.kaggle.com\/raj401\/my-complete-pipeline-for-any-ml-competition<\/a><br><\/p> \n<p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:50%;text-align:center;border-radius:20px 60px;\">\"\"<\/p> \n<p style=\"font-family:newtimeroman;font-size:120%;color:#444160;\">\n    <br><b>So how does this work? [STACKING and BLENDING]<\/b>\n    <br>While training of model we will run a for loop for range(0,5) i.e in each loop we will pick one of the fold out of [0,1,2,3,4] folds. Like let say we picked 3. Then we will make it as validation set and train our model on folds 0,1,2,4. Once our model is trained we will make predictions on that validation set and find roc_auc_score. This will represent our current model. We will make predictions on our whole test set. Then we will store this test_prediction as well as our validation prediction which was only on a part of training set.\n<br>In next loop we will pick another fold let say fold4 then fold 4 will be our validataion set and fold 0,1,2,3 will be our training set. We will repeat the same process. \n<br> This way when we have covered all folds we will have 5 different predictions of test set and one completed prediction of whole training set i.e in each loop on fold was predicted. Also we will have 5 roc_auc_score. We will find it's variance. We will store all this information in a DataFrame called Logs. So basically for each model we will make predictions on test set and train set(called as OOF out of fold predictions because we made prediction only on that fold which we didn't trained current model, this we do to avoid data leakage because training on x dataset x and then predicting on same dataset x can't tell how our model is. It may be badly overfitting that is why we make OOF prediction)<br><b>Now one may ask why are we making prediction on train set as we needed to make prediction on test set.<\/b>\n<br>The answer is: Because we are again going to make predictions on these test prediction using new models called as meta models. So prediction of predicted test set. This will boost our score. But now for initial test set we had traininig set on which we trainied our model and predicted on test set. But now if we train on same initial training set then our answer will be wrong because now our new test set is not of same format(Initial test set and train set contained features like Age, Gender, Embarked etc but now our new test set contains columns like test_pred_from_algo1, test_pred_from_algo2.. etc.)\n<br> So here we will use that OOF predictions to train our meta models and then make predictions on this new test set.\n    <br><b> [That completes our explanation]<\/b>\n<br> Note this method works because we are making a very strong validation set and thus we will not be overfitting. Also it gives a correct way of measuring actual performance of our models. As each model has 5 roc_auc_score for each fold. Now since we did Stratified KFold mean distribution of labels in each fold is same so model score should be on same in each fold.But if there is too much variance in the score of each fold. It means our model is probably overfitting thus we can't trust on it. On the other hand if score in each fold are quite close mean our model is quite <b>STABLE<\/b> and we have created a very strong validation set. Our model will perform better on test set.\n<br>Now Let's start coding...<\/p>\n\n\n\n<a id='top'><\/a>\n<div class=\"list-group\" id=\"list-tab\" role=\"tablist\">\n<p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">TABLE OF CONTENTS<\/p>   \n    \n* [1. IMPORTING LIBRARIES](#1)\n    \n* [2. READ DATASETS](#2)\n\n* [3. PREPROCESSING](#3)\n    \n    \n* [4. ALL MODELS](#4)\n    \n* [5. TRAIN ALL MODELS](#5)\n    \n    \n* [6. SAVE TEST PREDICTION and OOF PREDICTION](#6)\n    \n* [7. CREATE LOGS](#7)\n    \n* [8. VISUALIZE](#8)\n    * [8.1. OOF PREDICTIONS vs TARGET](#8.1)\n    * [8.2. TEST SET PREDICTIONS](#8.2)\n    \n    \n* [9. CONCLUSION](#9)\n    \n* [10. END](#10)\n\n<a id=\"1\"><\/a>\n# <p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">IMPORTING LIBRARIES<\/p>","0c2e5b90":"<a id=\"4\"><\/a>\n# <p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">ALL MODELS<\/p>\n<p style=\"font-family:newtimeroman;font-size:120%;color:#444160;\">We will copy and paste the hyperparameter values of all the models which we have optimized previously using OPTUNA<\/p> ","69cc1447":"<a id=\"6\"><\/a>\n# <p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">SAVE TEST PREDICTION and OOF PREDICTION<\/p>","00182b69":"<a id=\"9\"><\/a>\n<p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">CONCLUSION<\/p>\n<p style=\"font-family:newtimeroman;font-size:120%;color:#444160;\">We will use these TEST predictions and OOF predictions while training meta models. In next notebook we will start with ROUND2. \n<br> That is all for now, If you have any doubt feel free to ask me in the comment. <br>\n    If you appreciate my effort please do <b>UPVOTE\ud83d\udc4d<\/b> and I will see you in the next Notebook\ud83d\udcd2. <\/p>\n\n**<span style=\"color:#444160;\"> Thanks!<\/span>**\n<a id=\"10\"><\/a>\n<p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">END<\/p>\n    <a href=\"#top\" role=\"button\" aria-pressed=\"true\" >\u2b06\ufe0fBack to Table of Contents \u2b06\ufe0f<\/a>","da5799f3":"<a id=\"8\"><\/a>\n# <p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">VISUALIZE<\/p>\n<p style=\"font-family:newtimeroman;font-size:120%;color:#444160;\">Now we will merge these new predictions of TEST set and OOF set to test_data and train_data respectively<\/p>","8a644f86":"<a id=\"2\"><\/a>\n# <p style=\"background-color:#B721FF;font-family:newtimeroman;color:#444160;font-size:150%;text-align:center;border-radius:20px 60px;\">READ DATASETS<\/p>"}}