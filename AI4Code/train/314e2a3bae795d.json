{"cell_type":{"ba93d8c2":"code","b17b8b3c":"code","81b8d20b":"code","3b0be5fc":"code","33b9e42a":"code","02bf5cad":"code","3abeec8d":"code","67808926":"code","a486d87b":"code","902d755d":"code","2915dd40":"code","1cf75eb7":"code","7dbfef2e":"markdown","a5198dcb":"markdown","2211e8e6":"markdown","c0c323eb":"markdown","ebc73f89":"markdown","d8a56897":"markdown","fbe4d68b":"markdown"},"source":{"ba93d8c2":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","b17b8b3c":"!pip install langdetect","81b8d20b":"from collections import Counter\nimport pandas as pd\nimport re\nfrom langdetect import detect\nimport matplotlib.pyplot as plt\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import linear_kernel\nfrom collections import Counter\n%matplotlib inline\nimport seaborn as sns\nsns.set(rc={'figure.figsize':(10,7)})\npd.set_option('max_colwidth', 400)","3b0be5fc":"df = pd.read_json('..\/input\/song-lyrics-from-genius\/lyrics.jl', lines=True)","33b9e42a":"df.sample(3)","02bf5cad":"def lang_detector(x):\n    '''\n        takes a string and returns language of string\n    '''\n    try:\n        return detect(x)\n    except:\n        return 'unknown language'\n\ndef cleaner(df):\n    '''\n        cleans song column\n        extract artist from song column\n        cleans lyrics column\n        applies lang_detector function \n        creates new column for song length\n        removes songs of laguage other than english\n        removes outliers calculated using song length\n        creates new column of song_length_quantiles for viz\n        returns cleand df\n    '''\n    df['artist'] = df['song'].apply(lambda x: ' '.join(x.split('-')[:2]))\n    df['song'] = df['song'].apply(lambda x: x[:-7])    \n    df['lyrics'] = df['lyrics'].apply(lambda x: re.sub(\"[\\(\\[].*?[\\)\\]]\", \"\", x))\n    df['lyrics'] = df['lyrics'].apply(lambda x: re.sub('\\n\\n', '', x))\n    df['lyrics'] = df['lyrics'].apply(lambda x: re.sub('\\n', ' ', x))\n    df['lang'] = df['lyrics'].apply(lambda x: lang_detector(x))\n    df = df[df['lang'] == 'en']\n    df['song_length'] = df['lyrics'].apply(lambda x: len(x))\n    Q1 = df['song_length'].quantile(0.25)\n    Q3 = df['song_length'].quantile(0.75)\n    IQR = Q3 - Q1\n    df = df[(df['song_length'] > (Q1 - 1.5 * IQR)) & (df['song_length'] < (Q3 + 1.5 * IQR))]\n    df['song_length_quantiles'] = pd.cut(df['song_length'], bins=10, precision=0)    \n    return df\n\ndf = cleaner(df)","3abeec8d":"song_len_df = df['song_length_quantiles'].value_counts(sort=True).reset_index().rename(columns={'index': 'quantiles', 'song_length_quantiles':'count'})\nsns.barplot(x='quantiles', y='count', data=song_len_df,   palette=\"Blues_d\")\nplt.xticks(rotation=45)\nplt.show()","67808926":"df = df.drop_duplicates(subset='artist', keep='first')\ndf = df.reset_index(level=0)\ndf['id'] = df['index']\ndf = df.drop(['index'], axis=1)","a486d87b":"# Calculating cosine similarities from lyrics and storing similar song results in results dict\ntf = TfidfVectorizer(analyzer='word', min_df=0, max_features= 100 ,stop_words='english', lowercase=True)\ntfidf_matrix = tf.fit_transform(df['lyrics'])\n\ncosine_similarities = linear_kernel(tfidf_matrix, tfidf_matrix)\nresults = {}\n\nfor idx, row in df.iterrows():\n    similar_indices = cosine_similarities[idx].argsort()[:-100:-1]\n    similar_items = [(cosine_similarities[idx][i], df['id'][i]) for i in similar_indices]\n    results[row['id']] = similar_items[1:]","902d755d":"def item(id):\n    return df.loc[df['id'] == id]['song']\n\ndef recommend(id, num):\n    print(\"Recommending \" + str(num) + \" songs similar to \" + item(id))\n    recs = results[id][:num]\n    i=0\n    for rec in recs:\n        print(\"We recommend : \" + item(rec[1]) + \" (score:\" + str(rec[0]) + \")\")","2915dd40":"recommend(14,3)","1cf75eb7":"recommend(1500,5)","7dbfef2e":"We have created song length quantiles from song length column. Now we can visualize the distribution of song length! Some songs are terribly long and some are short. Fortune cookie here - Try to find out the longest song, you will be surprised!","a5198dcb":"We will convert lyrics to TF-IDF matrix before calculating cosine similarity between songs and storing similar 50 songs in results dict.","2211e8e6":"We create new columns for artist from song column Also, we are going to use on songs from english language so we remove songs of other language after language detection A good sanity check is to know song lengths, while doing that we found out that some songs have length upto 30k and some as low as 5 words. We removed songs which had song length below and above cutoffs","c0c323eb":"Now that we have recommendations for every song in the dataset. We can query the dict for similar songs as per user request","ebc73f89":"In EDA we found out that datasets contains lot of songs of few artists and very few of some artist. At the same time dataset contains songs from 12K unique artists. We only want songs recommended from different artist. Thus dropping songs from same artists.","d8a56897":"Seems like recommendations are bang on with high confidence. Model is recommending artist in similar genre and those that have same style of music.\n\nI love listening to new music and love spotify\u2019s recommendation. With this exercise, I wanted to see if simple model like this can be good at song suggestion. Apparently, simple models can also work.\n\n**FIN**","fbe4d68b":"**About the dataset**\n- Dataset we are going to use is from Genius.com\n- We will use lyrics.jl file from the download\n- Dataset has two columns \u2018song\u2019 and \u2018lyrics\u2019\n- Song column contains artist name plus name of the song\n- Lyrics column contains lyrics as displayed on genius.com\n- We are going to clean the data set and extract new features before building recommender"}}