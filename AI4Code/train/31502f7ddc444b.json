{"cell_type":{"249c789f":"code","b8a69914":"code","43df874a":"code","c22e4df9":"code","41aae5ea":"code","ac6ee3d1":"code","b3db244d":"code","16c07f7b":"code","114f7677":"code","ded4ea92":"code","0061daef":"code","0cdcefaa":"code","4eea4eb2":"code","b0fffaba":"code","1b4252a1":"code","96fbeac6":"code","839f9177":"code","3c52c48f":"code","87f2d8eb":"code","d4742c81":"code","bd3bcf63":"markdown","5fd72a0f":"markdown","c8c23bf3":"markdown","beeb474d":"markdown","b2482fdb":"markdown","c1c025f0":"markdown","428783a5":"markdown","43925a63":"markdown","e88e631e":"markdown","7b97ba02":"markdown","ff0f7167":"markdown","4e3a65a1":"markdown","13cfba9d":"markdown","8cddde52":"markdown","256e2265":"markdown"},"source":{"249c789f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","b8a69914":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport Bio\nprint(\"Biopython v\" + Bio.__version__)","43df874a":"from Bio.Seq import Seq\nfrom Bio.SeqRecord import SeqRecord\nfrom Bio import SeqIO\n\nseq = pd.read_csv('..\/input\/n-virus-gene-data\/N GENE.txt')\nseq","c22e4df9":"my_seq = Seq('>AY029767.1_MY_1999')\nrecord = SeqRecord(my_seq, id=\"test\", annotations={\"molecule_type\": \"DNA\"})\nprint(record)\nprint(my_seq)","41aae5ea":"print(my_seq + \" - Sequence\")\nprint(my_seq.complement() + \" - Complement\")\nprint(my_seq.reverse_complement() + \" - Reverse Complement\")","ac6ee3d1":"from Bio import SeqIO\ncount = 0\nsequences = [] # Here we are setting up an array to save our sequences for the next step\n\nfor seq_record in SeqIO.parse(\"..\/input\/n-virus-gene-data\/N GENE.txt\", \"fasta\"):\n    if (count < 6):\n        sequences.append(seq_record)\n        print(\"Id: \" + seq_record.id + \" \\t \" + \"Length: \" + str(\"{:,d}\".format(len(seq_record))) )\n        print(repr(seq_record.seq) + \"\\n\")\n        count = count + 1","b3db244d":"chr2L = sequences[0].seq","16c07f7b":"chr2L","114f7677":"print(len(chr2L))","ded4ea92":"print(\"First Letter: \" + chr2L[0])\nprint(\"Third Letter: \" + chr2L[2])\nprint(\"Last Letter: \" + chr2L[-1])","0061daef":"print(\"Length:\\t\" + str(len(chr2L)))\nprint(\"G Count:\\t\" + str(chr2L.count(\"G\")))","0cdcefaa":"print(\"GC%:\\t\\t\" + str(100 * float((chr2L.count(\"G\") + chr2L.count(\"C\")) \/ len(chr2L) ) ))","4eea4eb2":"from Bio.SeqUtils import GC\nprint(\"GC% Package:\\t\" + str(GC(chr2L)))","b0fffaba":"print(\"GgCcSs%:\\t\" + str(100 * float((chr2L.count(\"G\") + chr2L.count(\"g\") + chr2L.count(\"C\") + chr2L.count(\"c\") + chr2L.count(\"S\") + chr2L.count(\"s\") ) \/ len(chr2L) ) ))\nprint(\"GC% Package:\\t\" + str(GC(chr2L)))","1b4252a1":"chr2LSHORT = chr2L[0:20]\nprint(\"Short chr2L: \" + chr2LSHORT)\nprint(\"Codon Pos 1: \" + chr2LSHORT[0::3])\nprint(\"Codon Pos 2: \" + chr2LSHORT[1::3])\nprint(\"Codon Pos 3: \" + chr2LSHORT[2::3])","96fbeac6":"print(\"Original: \" + chr2LSHORT)\nprint(\"Complement: \" + chr2LSHORT.complement())\nprint(\"Reverse Complement: \" + chr2LSHORT.reverse_complement())","839f9177":"print(\"Coding DNA: \" + chr2LSHORT)\ntemplate_dna = chr2LSHORT.reverse_complement()\nprint(\"Template DNA: \" + template_dna)","3c52c48f":"messenger_rna = chr2LSHORT.transcribe()\nprint(\"Messenger RNA: \" + messenger_rna)","87f2d8eb":"messenger_rna = Seq(\"AUGAGUGAUAUCUUUGAAGA\")\nprint(\"Protein Sequence: \" + messenger_rna.translate())","d4742c81":"coding_dna = Seq(\"ATGAGTGATATCTTTGAAGA\")\nprint(\"Coding DNA: \" + coding_dna)\nprint(\"Protein Sequence: \" + coding_dna.translate())","bd3bcf63":"**OR**","5fd72a0f":"# Translation\nUsing a new example, let\u2019s translate this mRNA into the corresponding protein sequence - again taking advantage of one of the Seq object\u2019s biological methods:","c8c23bf3":"# Transcription\nThe actual biological transcription process works from the template strand, doing a reverse complement (TCAG \u2192 CUGA) to give the mRNA. However, in Biopython and bioinformatics in general, we usually work directly with the coding strand because this means we can get the mRNA sequence just by switching T \u2192 U.","beeb474d":"While you could use the above snippet of code to calculate a GC%,the Bio.SeqUtils module has several GC functions already built","b2482fdb":"Counting the number of G shown in the sequence","c1c025f0":"You can also translate directly from the coding strand DNA sequence:","428783a5":"As you can see, all this does is switch T \u2192 U, and adjust the alphabet.","43925a63":"The GC Content of a DNA sequence is important and relates to how stable the molecule will be. We can calculate it manually like this:","e88e631e":"# Nucleotide sequences and (reverse) complements\nFor nucleotide sequences, you can easily obtain the complement or reverse complement of a Seq object using its built-in methods:","7b97ba02":"# Data Analysis with Biopython","ff0f7167":"Disputably, the central object in bioinformatics is the sequence. Thus, we\u2019ll start with a quick introduction to the Biopython mechanisms for dealing with sequences, the Seq object.\n\nMost of the time when we think about sequences we have in my mind a string of letters like \u2018AGTACACTGGT\u2019. We can create such Seq object with this sequence or allow the program to read sequences from a given file","4e3a65a1":"Sequences act like strings\nIn many ways, we can deal with Seq objects as if they were normal Python strings, for example getting the length, or iterating over the elements:","13cfba9d":"Biology Note: (remember by convention nucleotide sequences are normally read from the 5\u2019 to 3\u2019 direction)\n\nNow let\u2019s transcribe the coding strand into the corresponding mRNA, using the Seq object\u2019s built in transcribe method:","8cddde52":"# Parsing sequence file formats\n\nThe next most important class is the SeqRecord or Sequence Record. This holds a sequence (as a Seq object) with additional annotation including an identifier, name and description. The Bio.SeqIO module for reading and writing sequence file formats works with SeqRecord objects.","256e2265":"# Slicing a sequence\n\nWhen you do a slice the first item is included (i.e. 4 in this case) and the last is excluded (12 in this case)\n\nThe second thing to notice is that the slice is performed on the sequence data string, but the new object produced is another Seq object which retains the alphabet information from the original Seq object.\n\nAlso like a Python string, you can do slices with a start, stop and stride (the step size, which defaults to one). For example, we can get the first, second and third codon positions of this DNA sequence:"}}