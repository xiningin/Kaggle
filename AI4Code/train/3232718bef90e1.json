{"cell_type":{"3a063fb5":"code","a50867c3":"code","7102a173":"code","140202f6":"code","edee462a":"code","08de44cb":"code","8fe5ffb4":"markdown","d75a441b":"markdown","3d3e0fc5":"markdown","c7aa0929":"markdown","7a38e7fb":"markdown"},"source":{"3a063fb5":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.\nimport os\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom plotly import tools, subplots\nimport plotly.offline as py\npy.init_notebook_mode(connected = True)\nimport plotly.graph_objs as go\nimport plotly.express as px\npd.set_option('max_columns', 1000)\nfrom bokeh.models import Panel, Tabs\nfrom bokeh.io import output_notebook, show\nfrom bokeh.plotting import figure\nimport lightgbm as lgb\nimport plotly.figure_factory as ff\nimport gc\nfrom sklearn.model_selection import KFold\nfrom sklearn.preprocessing import LabelEncoder","a50867c3":"%%time\nprint('Reading train.csv file....')\ntrain = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/train.csv')\nprint('Training.csv file have {} rows and {} columns'.format(train.shape[0], train.shape[1]))\n\nprint('Reading test.csv file....')\ntest = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/test.csv')\nprint('Test.csv file have {} rows and {} columns'.format(test.shape[0], test.shape[1]))\n\nprint('Reading train_labels.csv file....')\ntrain_labels = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/train_labels.csv')\nprint('Train_labels.csv file have {} rows and {} columns'.format(train_labels.shape[0], train_labels.shape[1]))\n\nprint('Reading specs.csv file....')\nspecs = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/specs.csv')\nprint('Specs.csv file have {} rows and {} columns'.format(specs.shape[0], specs.shape[1]))\n\nprint('Reading sample_submission.csv file....')\nsample_submission = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/sample_submission.csv')\nprint('Sample_submission.csv file have {} rows and {} columns'.format(sample_submission.shape[0], sample_submission.shape[1]))","7102a173":"# funtions to get agg stadistics and merge with test and train\ndef get_object_columns(df, columns):\n    df = df.groupby(['installation_id', columns])['event_id'].count().reset_index()\n    df = df.pivot_table(index = 'installation_id', columns = [columns], values = 'event_id')\n    df.columns = list(df.columns)\n    df.fillna(0, inplace = True)\n    return df\n\ndef get_numeric_columns(df, column):\n    df = df.groupby('installation_id').agg({f'{column}': ['mean', 'sum', 'std']})\n    df.fillna(0, inplace = True)\n    df.columns = [f'{column}_mean', f'{column}_sum', f'{column}_std']\n    return df\n\ndef get_numeric_columns_2(df, agg_column, column):\n    df = df.groupby(['installation_id', agg_column]).agg({f'{column}': ['mean', 'sum', 'std']}).reset_index()\n    df = df.pivot_table(index = 'installation_id', columns = [agg_column], values = [col for col in df.columns if col not in ['installation_id', 'type']])\n    df.fillna(0, inplace = True)\n    df.columns = list(df.columns)\n    return df\n\nnumerical_columns = ['game_time']\ncategorical_columns = ['type', 'world']\n\nreduce_train = pd.DataFrame({'installation_id': train['installation_id'].unique()})\nreduce_train.set_index('installation_id', inplace = True)\nreduce_test = pd.DataFrame({'installation_id': test['installation_id'].unique()})\nreduce_test.set_index('installation_id', inplace = True)\n\n# train = get_time(train)\n\nfor i in numerical_columns:\n    reduce_train = reduce_train.merge(get_numeric_columns(train, i), left_index = True, right_index = True)\n    reduce_test = reduce_test.merge(get_numeric_columns(test, i), left_index = True, right_index = True)\n    \nfor i in categorical_columns:\n    reduce_train = reduce_train.merge(get_object_columns(train, i), left_index = True, right_index = True)\n    reduce_test = reduce_test.merge(get_object_columns(test, i), left_index = True, right_index = True)\n    \nfor i in categorical_columns:\n    for j in numerical_columns:\n        reduce_train = reduce_train.merge(get_numeric_columns_2(train, i, j), left_index = True, right_index = True)\n        reduce_test = reduce_test.merge(get_numeric_columns_2(test, i, j), left_index = True, right_index = True)\n    \n    \nreduce_train.reset_index(inplace = True)\nreduce_test.reset_index(inplace = True)\n    \nprint('Our training set have {} rows and {} columns'.format(reduce_train.shape[0], reduce_train.shape[1]))\n    \n# get the mode of the title\nlabels_map = dict(train_labels.groupby('title')['accuracy_group'].agg(lambda x:x.value_counts().index[0]))\n# merge target\nlabels = train_labels[['installation_id', 'title', 'accuracy_group']]\n# replace title with the mode\nlabels['title'] = labels['title'].map(labels_map)\n# get title from the test set\nreduce_test['title'] = test.groupby('installation_id').last()['title'].map(labels_map).reset_index(drop = True)\n# join train with labels\nreduce_train = labels.merge(reduce_train, on = 'installation_id', how = 'left')\nprint('We have {} training rows'.format(reduce_train.shape[0]))","140202f6":"reduce_train.head()","edee462a":"train_labels.query('installation_id==\"0006a69f\"')","08de44cb":"reduce_train.query('installation_id==\"0006a69f\"')","8fe5ffb4":"### Start getting familiar with training set labels\nafter find out what we're going to predict from this great kernel, [The goal is not clear to me](https:\/\/www.kaggle.com\/c\/data-science-bowl-2019\/discussion\/114198#latest-659333)\n\nWhen I try to get familiar with the labels of the training set,  i find that...\n\n\nthe code is from [Simple exploratory data analysis and model](https:\/\/www.kaggle.com\/ragnar123\/simple-exploratory-data-analysis-and-model)","d75a441b":"# Reading Files","3d3e0fc5":"### What's the label of the training set?\nI found that the red box of these three data, two are duplicate, there is another one, its input is the same as the other two, but the accuracy_group, I am a little confused, such a label is we should want to predict? Or do we just need to select one of the labels as the labels we need to predict?\n\n![image.png](attachment:image.png)","c7aa0929":"![image.png](attachment:image.png)","7a38e7fb":"### What's the label of the training set?\nI found that the red box of these three data, two are duplicate, there is another one, its input is the same as the other two, but the accuracy_group, I am a little confused, such a label is we should want to predict? Or do we just need to select one of the labels as the labels we need to predict?"}}