{"cell_type":{"a2cd04ef":"code","95bb8858":"code","cd3b1fc2":"code","5516cc78":"code","9cebbada":"code","5bf5971b":"code","747af0bd":"markdown","461fae67":"markdown"},"source":{"a2cd04ef":"# Grid and Variable Initialization -- stuff you might play around with\n\nncol = 5         # grid size (number of cells)\nnrow = ncol\nnSlices = 200    #nSlices, iRowOut, iColOut = input(\"\").split()\niRowOut = 3\niColOut = 3\nntAnim = 1          # number of time steps for each frame\nhorizontalWrap = False # determines whether the flow wraps around, connecting\n                       # the left and right-hand sides of the grid, or whether\n                       # there's a wall there. \ninterpolateRotation = False\nrotationScheme = \"PlusMinus\"   # \"WithLatitude\", \"PlusMinus\", \"Uniform\"\nwindScheme = \"\"  # \"Curled\", \"Uniform\"\ninitialPerturbation = \"Tower\"    # \"Tower\", \"NSGradient\", \"EWGradient\"\ntextOutput = False\nplotOutput = True\narrowScale = 30\n\ndT = 600 # seconds\nG = 9.8e-4 # m\/s2\nHBackground = 4000 # meters\ndX = 10.E3 # meters\ndxDegrees = dX \/ 110.e3\nflowConst = G  # m\/s2\ndragConst = 1.E-6  # about 10 days decay time\nmeanLatitude = 30 # degrees","95bb8858":"# Set up python environment\nimport numpy\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as tkr\nimport math","cd3b1fc2":"%matplotlib notebook","5516cc78":"# Here's stuff you probably won't need to change\n\nnSlices, iRowOut, iColOut = [ int(nSlices), int(iRowOut), int(iColOut) ]\n\nlatitude = []\nrotConst = []\nwindU = []\nfor irow in range(0,nrow):\n    if rotationScheme is \"WithLatitude\":\n        latitude.append( meanLatitude + (irow - nrow\/2) * dxDegrees )\n        rotConst.append( -7.e-5 * math.sin(math.radians(latitude[-1]))) # s-1\n    elif rotationScheme is \"PlusMinus\":\n        rotConst.append( -3.5e-5 * (1. - 0.8 * ( irow - (nrow-1)\/2 ) \/ nrow )) # rot 50% +-\n    elif rotationScheme is \"Uniform\":\n        rotConst.append( -3.5e-5 ) \n    else:\n        rotConst.append( 0 )\n\n    if windScheme is \"Curled\":\n        windU.append( 1e-8 * math.sin( (irow+0.5)\/nrow * 2 * 3.14 ) ) \n    elif windScheme is \"Uniform\":\n        windU.append( 1.e-8 )\n    else:\n        windU.append( 0 )\nitGlobal = 0\n\nU = numpy.zeros((nrow, ncol+1))\nV = numpy.zeros((nrow+1, ncol))\nH = numpy.zeros((nrow, ncol+1))\ndUdT = numpy.zeros((nrow, ncol))\ndVdT = numpy.zeros((nrow, ncol))\ndHdT = numpy.zeros((nrow, ncol))\ndHdX = numpy.zeros((nrow, ncol+1))\ndHdY = numpy.zeros((nrow, ncol))\ndUdX = numpy.zeros((nrow, ncol))\ndVdY = numpy.zeros((nrow, ncol))\nrotV = numpy.zeros((nrow,ncol)) # interpolated to u locations\nrotU = numpy.zeros((nrow,ncol)) #              to v\n    \nmidCell = int(ncol\/2)\nif initialPerturbation is \"Tower\":\n    H[midCell,midCell] = 1\nelif initialPerturbation is \"NSGradient\":\n    H[0:midCell,:] = 0.1\nelif initialPerturbation is \"EWGradient\":\n    H[:,0:midCell] = 0.1\n\n\"\"\"\nThis is the work-horse subroutine.  It steps forward in time, taking ntAnim steps of\nduration dT.  \n\"\"\"\n\ndef animStep():    \n\n    global stepDump, itGlobal\n\n    # Time Loop\n    for it in range(0,ntAnim):\n    \n        # Longitudinal Derivatives\n\n            # Loop over nrow and ncol (stepping from 0 to nrow-1 or ncol-1)\n\n                # Calculate dH\/dX (variable dHdX), making sure to put\n                # the value in each index [irow, icol] so that it\n                # applies to the horizontal velocity at that index\n                # location (U[irow, icol]).\n\n                # If the variable horizontalWrap is set to True, the\n                # flow out the right-hand side of the domain\n                # (U[:,ncol]) will equal the flow in from the left\n                # side (U[:,0]).  (The colon means, in this case, \"all\n                # rows\")\n\n                # Assume that there is are \"ghost cells\" at the\n                # right-hand end of the U and H arrays.  \n                # U[:,ncol] = U[:,0], and H[:,ncol] = H[:,0].\n\n                # For example, if ncol = 3, the H values that are in\n                # the domain will have indices 0, 1, and 2.  For\n                # convenience, we'll set up an H[:,3] set of cells,\n                # which equal the H[:,0] cells, so we can take a\n                # difference for dHdX[:,3] from H[:,2] and our ghost\n                # H[:,3], which are on either side of U[:,2].\n\n                # Or, if horizontalWrap is set to False, the U velocities\n                # at the left and right sides of the domain will be set to\n                # zero.  \n\n                # Also calculate dU\/dx (dUdX), again making sure that\n                # the result that has index [irow, icol] applies to\n                # the elevation H[irow, icol].  Assume that the ghost cells\n                # U[:,ncol] are already set, if it's wrapped, or that the\n                # boundary velocities U[:,0] and U[:,ncol-1] = 0, if it's\n                # a wall.  (There can be flow along the wall (V) but not \n                # through it (U)).  \n\n                # For a test 3x3 grid, after this routine has run one time,\n                # the values of H and dHdX will be (notice the ghost cells\n                # on the right, the fourth element in each line)\n\n                # H    [[ 0.  0.  0.  0.]\n                #       [ 0.  1.  0.  0.]\n                #       [ 0.  0.  0.  0.]]\n\n                # dHdX [[ 0.  0.  0.  0.]\n                #       [ 0.  1. -1.  0.]\n                #       [ 0.  0.  0.  0.]]\n\n                # The velocities are all zero, initially, so their gradient\n                # will also be zero.  On the second time through the routine,\n                # U and dUdX should look like\n\n                # U at beginning of second step:\n                # [[  0.00000000e+00   0.00000000e+00   0.00000000e+00   0.00000000e+00]\n                #  [  0.00000000e+00  -3.00000000e-05   3.00000000e-05   0.00000000e+00]\n                #  [  0.00000000e+00   0.00000000e+00   0.00000000e+00   0.00000000e+00]]\n\n                # dUdX after second step:\n                # [[  0.00000000e+00   0.00000000e+00   0.00000000e+00]\n                #  [ -3.00000000e-05   6.00000000e-05  -3.00000000e-05]\n                #  [  0.00000000e+00   0.00000000e+00   0.00000000e+00]]\n\n        for irow in range(0,nrow):\n            for icol in range(1,ncol+1):\n                dHdX[irow,icol] = ( H[irow,icol] - H[irow,icol-1] ) \/ \\\n                    dX                     # used to update u[ir,ic]\n            for icol in range(0,ncol):\n                dUdX[irow,icol] = ( U[irow,icol+1] - U[irow,icol] ) \/ \\\n                    dX                     # updates h[ir,ic]\n            if horizontalWrap is True:\n                dHdX[irow,0] = dHdX[irow,ncol] # fills from rhs ghost cell\n            else:\n                dHdX[irow,0] = 0\n    \n        # Latitudinal Derivatives\n\n            # Within a loop over all grid cells, calculate dHdY, remembering\n            # that dHdy[irow, icol] should be comprised of H values that straddle\n            # a particular V[irow, icol].  \n\n            # The northern and southern boundaries of the domains are always walls.\n            # This means that the flows at the north boundary (V[0,:]), and the \n            # south (a ghost cell would be V[ncol,:]) are both set to zero.  Assume\n            # that this will be true going into this loop, and that the ghost cell\n            # exists.  \n\n            # The gradient in the surface elevation, dHdY, should be set to zero\n            # at the top boundary.  dHdY[0,:] would be used to calculate V[0,:],\n            # which is going to be zero anyway.  \n\n            # After the first time through this time loop, dHdY should look like\n\n            # dHdY [[ 0.  0.  0.]\n            #       [ 0.  1.  0.]\n            #       [ 0. -1.  0.]]\n\n            # and entering the second time through the loop, the velocities (V, \n            # notice the ghost cells in the fourth row) should look like\n\n            # V [[  0.00000000e+00   0.00000000e+00   0.00000000e+00]\n            #    [  0.00000000e+00  -3.00000000e-05   0.00000000e+00]\n            #    [  0.00000000e+00   3.00000000e-05   0.00000000e+00]\n            #    [  0.00000000e+00   0.00000000e+00   0.00000000e+00]]\n\n            # and this will drive a gradient dVdY of \n\n            # dVdY [[  0.00000000e+00  -3.00000000e-05   0.00000000e+00]\n            #       [  0.00000000e+00   6.00000000e-05   0.00000000e+00]\n            #       [  0.00000000e+00  -3.00000000e-05   0.00000000e+00]]\n\n        for icol in range(0,ncol):\n            for irow in range(1,nrow):\n                dHdY[irow,icol] = ( H[irow,icol] - H[irow-1,icol] ) \/ \\\n                    dX                     # updates v[ir,ic]\n            dHdY[0,icol] = 0\n    \n            for irow in range(0,nrow):\n                dVdY[irow,icol] = ( V[irow+1,icol] - V[irow,icol] ) \/ \\\n                    dX                     # updates h[ir,ic]\n\n        # Rotation\n\n        # The effect of Earth's rotation is to transfer velocity\n        # between the U and V directions.  There are two ways to\n        # calculate this effect: an easy but somewhat biased way which\n        # will mostly work but lead to some weird flow patterns, and a\n        # better way.  \n\n        # Easier First Method: Loop over all rows and columns, and calculate \n\n            # rotU[irow,icol] = rotConst[irow] * U[irow,icol]\n\n            # This array will be used to update V[irow,icol].  rotConst is\n            # a function of latitude so that rotation can be stronger in\n            # high latitudes, like rotation on a real sphere.\n    \n            # Similarly, calculate rotV from rotConst and V.  \n\n        if interpolateRotation is False:\n            for irow in range(0,nrow):\n                for icol in range(0,ncol):\n                    rotU[irow,icol] = rotConst[irow] * U[irow,icol]        \n                    rotV[irow,icol] = rotConst[irow] * V[irow,icol]        \n\n        else:\n\n        # Better Method (Maybe add this later)\n\n            # 1.  The problem with the first method is that the U and\n            # V values are not located at the same places in the grid.\n            # The better method (save this task for later, after you\n            # get the first way working, is my advise) is, first, to\n            # interpolate the U and V values onto the cell centers.\n            # For U, this means averaging adjacent values, and putting\n            # them into the index so that the irow, icol values\n            # correspond to those of the H value in each cell.  Put\n            # them into a temporary variable array which you can call\n            # whatever you wish.  Declare and initialize the array\n            # using numpy.zeros, as was done above for U etc.  Do the\n            # same thing for V, interpolating them into its own array\n            # with grid points located in the cell centers.  It would\n            # be a good idea to print them out once, for a test, and\n            # make sure it's doing what you want it to.\n\n            UonH = numpy.zeros((nrow,ncol))\n            VonH = numpy.zeros((nrow,ncol))\n            for irow in range(0,nrow):\n                for icol in range(0,ncol):\n                    UonH[irow,icol] = ( U[irow,icol] + U[irow,icol+1] ) \/ 2\n                    VonH[irow,icol] = ( V[irow,icol] + V[irow+1,icol] ) \/ 2\n\n            if textOutput is True:\n                print(\"U\")\n                print(U)\n                print(\"UonH\")\n                print(UonH)\n\n            # 2.  Next calculate the rotational transformation of U\n            # and V as gridded on the H points, by multiplying each\n            # array by rotConst[].  You are done with the temporary\n            # arrays you generated before, so you could replace their\n            # values with the product, or you could create new arrays,\n            # whatever you like.\n\n            rotUOnH = numpy.zeros((nrow,ncol))\n            rotVOnH = numpy.zeros((nrow,ncol))\n            for irow in range(0,nrow):\n                for icol in range(0,ncol):\n                    rotUOnH[irow,icol] = rotConst[irow] * UonH[irow,icol]\n                    rotVOnH[irow,icol] = rotConst[irow] * VonH[irow,icol]\n\n            if textOutput is True:\n                print(\"rotUOnH\")\n                print(rotUOnH)\n\n            # 3. Finally, the rotated velocities, placed at the cell\n            # centers, need to be back-interpolated to the grid\n            # locations where the velocities are.  For example, the\n            # rotational addition to U velocity at the boundary\n            # between two cells should come from averaging the results\n            # you just got for the two cell centers on either side of\n            # the cell face you're interested in.\n    \n            # For the component that adds to V, generate a variable\n            # array called rotU (rotConst * U), each index of which\n            # corresponds with the placement of the V values on the\n            # grid.  rotU[0,:] will apply to V[0,:], which are set at\n            # zero because they are at the North wall of the\n            # simulation.  The velocities at the South wall, also\n            # zero, are stored in the ghost cells V[ncol,:], which\n            # won't get updated or need rotU[] values anyway.\n    \n            # For updating U, we'll use rotV (rotConst * V).  Here\n            # there are two cases to plan for, whether the flow wraps\n            # around connecting the left and right sides of the\n            # domain, or not.\n    \n            # If there's a wall at the boundaries, U[:,0] and\n            # U[:,ncol] (ghost cells) will be held at zero, so\n            # rotV[:,0] has to be set to zero (or left that way, as it\n            # was initialized).\n    \n            # If the flow wraps around, the rotational adjustment to\n            # U[:,0] (the eastern and western boundaries) should come\n            # from averaging the values in the centers of the eastern\n            # and western-most boxes.\n\n            for irow in range(0,nrow):\n                for icol in range(0,ncol):\n                    if irow>0: # u0 and u1 on h sites combine to make term for v1\n                        rotU[irow,icol] = ( rotUOnH[irow-1,icol] + rotUOnH[irow,icol] ) \/ 2\n                    if icol>0: # v0 and v1 make term for u1\n                        rotV[irow,icol] = ( rotVOnH[irow,icol-1] + rotVOnH[irow,icol] ) \/ 2\n                if horizontalWrap is True:\n                    rotV[irow,0] =  ( rotVOnH[irow,0] + rotVOnH[irow,ncol-1] ) \/ 2 # edge wrap\n\n#        print(\"rotU\")\n#        print(rotU)\n\n        # Time Derivatives\n\n            # Encode the equations for dU\/dT, dV\/dT, and dH\/dT, given\n            # above, by looping over the grid and calculating values\n            # to put in arrays dUdT, dVdT, and dHdT.  Be sure that the\n            # indices of the arrays correspond to those of the arrays\n            # U, V, and H that they are going to update.  It's very\n            # easy to make a mistake of this type, and the flow\n            # results you get will be strange and non-physical.\n\n        for irow in range(0,nrow):\n            for icol in range(0,ncol):\n                dUdT[irow,icol] = rotV[irow,icol] - \\\n                    flowConst * dHdX[irow,icol] - \\\n                    dragConst * U[irow,icol] + \\\n                    windU[irow]\n                dVdT[irow,icol] = - rotU[irow,icol] - \\\n                    flowConst * dHdY[irow,icol] - \\\n                    dragConst * V[irow,icol]\n                dHdT[irow,icol] = - ( dUdX[irow,icol] + dVdY[irow,icol] ) * \\\n                                  HBackground \/ dX\n\n        # Step Forward in Time\n\n            # Loop over the grid, updating each variable U, V, and H\n            # by adding the time derivative multiplied by the time\n            # step.\n\n        for irow in range(0,nrow):\n            for icol in range(0,ncol):\n                U[irow,icol] = U[irow,icol] + dUdT[irow,icol] * dT\n                V[irow,icol] = V[irow,icol] + dVdT[irow,icol] * dT\n                H[irow,icol] = H[irow,icol] + dHdT[irow,icol] * dT\n    \n        # Set Boundary and Ghost Cells\n\n            # The velocity through the North wall should be zeroed.\n\n            # If the horizontal flow wraps around the grid, set the\n            # ghost cells for U and H, for indices [:, ncol].  \n\n            # If the flow doesn't wrap, set U = zero at the eastern\n            # and western boundaries (indices [:,0] and [:,ncol]).  \n\n        V[0,:] = 0\n        if horizontalWrap is True:\n            H[:,ncol] = H[:,0] # ghost cells\n            U[:,ncol] = U[:,0]\n        else:\n            U[:,0] = 0\n            U[:,ncol] = 0\n\n#   End of gutted region\n\n    itGlobal = itGlobal + ntAnim\n\ndef firstFrame():\n    global fig, ax, hPlot\n    fig, ax = plt.subplots(figsize=(10,5))\n#    fig.subplots_adjust(left=0, right=1, bottom=1, top=1)\n    ax.set_title(\"H\")   \n    hh = H[:,0:ncol]\n    loc = tkr.IndexLocator(base=1, offset=1)\n    ax.xaxis.set_major_locator(loc)\n    ax.yaxis.set_major_locator(loc)\n    grid = ax.grid(which='major', axis='both', linestyle='-')\n    hPlot = ax.imshow(hh, interpolation='nearest', clim=(-0.5,0.5))   \n    plotArrows()\n    plt.show(block=False) \n\ndef plotArrows():\n    global quiv, quiv2\n    xx = []\n    yy = []\n    uu = []\n    vv = []\n    for irow in range( 0, nrow ):\n        for icol in range( 0, ncol ):\n            xx.append(icol - 0.5)\n            yy.append(irow )\n            uu.append( U[irow,icol] * arrowScale )\n            vv.append( 0 )\n    quiv = ax.quiver( xx, yy, uu, vv, color='white', scale=1)\n    for irow in range( 0, nrow ):\n        for icol in range( 0, ncol ):\n            xx.append(icol)\n            yy.append(irow - 0.5)\n            uu.append( 0 )\n            vv.append( -V[irow,icol] * arrowScale )\n    quiv2 = ax.quiver( xx, yy, uu, vv, color='white', scale=1)\n\n\ndef updateFrame():\n    global fig, ax, hPlot, quiv, quiv2\n    hh = H[:,0:ncol]\n    hPlot.set_array(hh)\n    quiv.remove()    \n    quiv2.remove()\n    plotArrows()\n    fig.canvas.draw()\n    if textOutput is True:\n        print(\"Time: \", math.floor( itGlobal * dT \/ 86400.*10)\/10, \"days\")\n\ndef textDump():\n    print(\"time step \", itGlobal)    \n    print(\"H\", H)\n    print(\"dHdX\" )\n    print( dHdX)\n    print(\"dHdY\" )\n    print( dHdY)\n    print(\"U\" )\n    print( U)\n    print(\"dUdX\" )\n    print( dUdX)\n    print(\"rotV\" )\n    print( rotV)\n    print(\"V\" )\n    print( V)\n    print(\"dVdY\" )\n    print( dVdY)\n    print(\"rotU\" )\n    print( rotU)\n    print(\"dHdT\" )\n    print( dHdT)\n    print(\"dUdT\" )\n    print( dUdT)\n    print(\"dVdT\" )\n    print( dVdT)","9cebbada":"if textOutput is True:\n    textDump()\nif plotOutput is True:\n    firstFrame()","5bf5971b":"for i_anim_step in range(0,nSlices):\n    animStep()\n    if textOutput is True:\n        textDump()\n    if plotOutput is True:\n        updateFrame()\nprint(H[iRowOut,iColOut],dHdT[iRowOut,iColOut],U[iRowOut,iColOut],V[iRowOut,iColOut],rotU[iRowOut,iColOut])\n#print(rotConst)","747af0bd":"Overview\n\nThis is a python code to solve the time evolution of a slab of shallow\nwater.  Variations in the depth of the water (height of the water\nsurface) generate differences in pressure in the water, which drive\nflow.  The water levels and flows are represented on a two-dimensional\ngrid, like a checkerboard.  Each time step, the pressure force acts to\ndrive the flow, which gets going, modifying the water surface\nelevation, and carrying around momentum of the flow.  The flow is also\naltered by rotation (as on a rotating planet), potentially by wind,\nand by friction.  In one configuration, for example, the run can start\nwith an initial \"hill\" of high water level in the center of the\ncomputational grid.  Water starts to flow outward from the hill, but\nit rotates to the side, and so tends to find a pattern where the flow\nis going around and around the hill, rather than simply flowing\nstraight down as it would if there were no rotation.\n\nThe Grid\n\nFor the simple 3x3 case, the placement of the velocities\nand elevations is as shown below.  Longitudinal velocities (u) are \ndefined on the left-hand cell faces, and latitudinal velocities (V) \non the cell tops.  The elevation of the fluid in each box (H) is\ndefined in the cell centers.  \n\n![placement_diagram.jpg](attachment:placement_diagram.jpg)\n\nVariables that are enclosed with square brackets in this diagram are\n\"ghost\" variables.  They aren't computed as part of the real grid, but\nare used to make it simpler to calculate differences, say between the\nNorth\/South velocities (V) at the top and the bottom of each cell.\n\nThe Differential Equations\n\ndU\/dT = C_rotation * V - C_flow * dH\/dX - C_drag * U + C_wind\n\ndV\/dT = -C_rotation * U - C_flow * dH\/dY - C_drag * V\n\ndH\/dT = - ( dU\/dX + dV\/dY ) * H \/ gridX\n\nThe terms like dU\/dT denote derivatives, in this case the rate of\nchange of the velocity (U) with time (t).  C_ terms are constants,\nfor rotation, induction of flow, drag, or wind input.  Terms like\ndV\/dY or dH\/dX are spatial derivatives, how much the velocity (V)\nchanges with latitude (y), for example.  Ultimately these \"time \ntendency\" (e.g. dU\/dT) terms will be used to update the values\naccording to, for example\n\nU(time+1) = U(time) + dU\/dT * delta_t\n\nwhere delta_t is a time step.  \n\nThe first equation can be interpreted as a list of things (on the\nright hand side) which tend to make the velocity (u) change with time\n(dU\/dT).  Rotation changes the flow direction, moving velocity between\nthe two directions U and V according to a rotational constant,\nC_rotate, where a higher number (away from zero) would rotate faster,\nand the sign of the constant determines the direction of rotation.\nThe term dh\/dX tells whether the sea surface is sloping; if it is, it\ndrives the flow to accellerate according to a flow constant C_flow.\nDrag slows the flow down, the larger the flow (U), the faster the\nslowdown (dU\/dT).  And finally we'll set up to allow wind to blow, in\nan East\/West (U) direction, driving circulation.\n\nMapping the Equations Numerically onto the Grid\n\nThe differential equations, above, apply to a continuous fluid, where\nyou can imagine a slope of the sea surface as a tangent to a wavy\nsurface.  Numerically, we cast these equations onto much\ncoarser systems of boxes, and derive our pressure driver, for example,\nfrom differences of heights between adjacent boxes.  We need to do \nthis paying attention to how the variables (U, V, and H) are arrayed\nin space on the grid (above).  \n\nFor example, in the equation for dU\/dT, above, the flow is driven by a\nsloping sea surface (dH\/dX).  Looking at the grid diagram, the slope\nin the sea surface (H), appropriate to the second U in from the left,\nU(01), would span the position of U(01), to be H(01) - H(00), divided\nby the grid spacing delta_x.  \n\n![sample_flow.jpg](attachment:sample_flow.jpg)\n\nIn the code, we want to have grids of the three important variables\nU, V, and H, and also we'll construct arrays of intermediate variables\nlike dH\/dX and dV\/dY.  They will be indexed in the grid, as in\n\n    dU\/dT[irow,icol] = flowConst * dH\/dX[irow,icol] + ...\n\nPay attention to the grid diagram to make sure the indexes work out in\nconstructing these arrays.  \n\nThere will probably be errors in your first attempts; half of the\nart of coding is finding bugs, figuring out why your code isn't doing\nwhat you expect it to.  To make things easiest to debug, the template\nprovided is set up for a very simple 3x3 case, just one time step,\nto give you results you can compare with what we'll give you.  \n\nThe first section of the code contains setup and initialization \ninformation.  Leave it alone for now, and you can play with them later \nafter you get the code filled in and running without bugs.  ","461fae67":"# Attribution:\n* Python code written by David Archer\n* Adapted to notebook format by Steven Neshyba (March 2021)"}}