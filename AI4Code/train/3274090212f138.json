{"cell_type":{"1f2a22c8":"code","b3b0ce92":"code","bb508691":"code","4744835a":"code","acf07dc7":"code","ae702497":"code","0022efd6":"code","d4d2ce55":"code","8d629a95":"code","d70910c8":"code","4483a6f0":"code","29393e3c":"code","cf948021":"code","00acd9e4":"code","380b5e34":"code","f5293d66":"code","2943e67a":"code","110dfa7f":"code","38f7aa92":"code","c2a45157":"code","03b391ef":"code","62162b93":"code","a12fb911":"code","31743d6c":"code","d86bc32f":"code","e09c978f":"code","d41fe277":"code","6ec5e610":"code","ee9ab0ed":"code","791eda8b":"code","a7d34f6f":"code","2f1872cd":"code","b708b3b7":"code","9c672764":"code","bb3697bd":"code","08c00143":"code","57a5bf25":"code","4e683eea":"code","90184ab3":"code","5f3e4400":"code","7f1b88ed":"code","dad14c91":"code","ae5afe49":"markdown","0701b71c":"markdown","417995fc":"markdown","b281a0a1":"markdown","5f21ceab":"markdown","dee2ae60":"markdown"},"source":{"1f2a22c8":"import tensorflow.keras\nimport tensorflow as tf\nimport os\nimport numpy as np\nimport pandas as pd\nimport random\nimport seaborn as sns\n\nimport matplotlib.pyplot as plt\nfrom tensorflow.keras.preprocessing.image import load_img\nfrom tensorflow.keras.layers import *\nfrom tensorflow.keras.applications.resnet50 import ResNet50\nfrom tensorflow.keras.applications.resnet50 import preprocess_input\nfrom tensorflow.keras.models import *\nfrom tensorflow.keras.losses import *\nfrom tensorflow.keras.optimizers import *\nfrom tensorflow.keras.preprocessing.image import img_to_array\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator, load_img\nfrom tensorflow.keras.utils import to_categorical\n\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.metrics import multilabel_confusion_matrix,roc_auc_score,confusion_matrix\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","b3b0ce92":"train_dir = '\/kaggle\/input\/brain-tumor-mri-dataset\/Training\/'\ntrain_paths = []\nfor label in os.listdir(train_dir):\n    for file in os.listdir(train_dir+label):\n        train_paths.append(train_dir+label+'\/'+file)\nrandom.shuffle(train_paths)\n# show an example of the list\nprint(train_paths[0])","bb508691":"test_dir = '\/kaggle\/input\/brain-tumor-mri-dataset\/Testing\/'\ntest_paths = []\nfor label in os.listdir(test_dir):\n    for file in os.listdir(test_dir+label):\n        test_paths.append(test_dir+label+'\/'+file)\nrandom.shuffle(test_paths)\n# show an example of the list\nprint(test_paths[0])","4744835a":"len(test_paths)","acf07dc7":"train_data = []\ntrain_labels = []\n\ntest_data = []\ntest_labels = []","ae702497":"# loop over the image paths\nfor imagePath in train_paths:\n    # extract the class label from the filename\n    label = imagePath.split(os.path.sep)[-2]\n    \n    # load the input image (224x224) and preprocess it\n    image = load_img(imagePath, target_size=(224, 224))\n    image = img_to_array(image)\n    image = np.array(image)\/255.0\n    \n    # update the data and labels lists, respectively\n    train_data.append(image)\n    train_labels.append(label)","0022efd6":"# loop over the image paths\nfor imagePath in test_paths:\n    # extract the class label from the filename\n    label = imagePath.split(os.path.sep)[-2]\n    \n    # load the input image (224x224) and preprocess it\n    image = load_img(imagePath, target_size=(224, 224))\n    \n    image = img_to_array(image)\n    image = np.array(image)\/255.0\n    \n    # update the data and labels lists, respectively\n    test_data.append(image)\n    test_labels.append(label)","d4d2ce55":"plt.imshow(test_data[2])","8d629a95":"\ndef convert_data_labels(data,labels):\n  # convert the data and labels to NumPy arrays\n  data = np.array(data, dtype=\"float32\")\n  labels = np.array(labels)\n\n  # perform one-hot encoding on the labels\n  le = LabelEncoder()\n  labels = le.fit_transform(labels)\n  labels_to_index=dict(zip(le.classes_, le.transform(le.classes_)))\n  labels = to_categorical(labels)\n  return  data,labels,labels_to_index","d70910c8":"pd.Series(train_labels).value_counts().plot(kind='barh')","4483a6f0":"pd.Series(test_labels).value_counts().plot(kind='barh')","29393e3c":"train_data,train_labels,labels_to_index = convert_data_labels(train_data,train_labels)\ntest_data,test_labels ,_= convert_data_labels(test_data,test_labels)","cf948021":"print(\"Size of train dataset : \",train_data.shape)\nprint(\"==================================\")\nprint(\"Size of test dataset : \",test_data.shape)\nprint(\"==================================\")","00acd9e4":"labels_to_index","380b5e34":"index_to_labels={}\nfor label,value in enumerate(labels_to_index):\n    index_to_labels[label]=value","f5293d66":"index_to_labels","2943e67a":"BS=32\n\n# train datagen\ntrain_datagen = ImageDataGenerator(\n#                   rescale = 1\/255,\n                  validation_split=0.25\n)\n\n\n# test datagen\ntest_datagen = ImageDataGenerator(\n#                     rescale = 1\/255\n)\n\ntrain_gen = train_datagen.flow(train_data, train_labels, batch_size=BS,subset=\"training\")\n\nval_gen = train_datagen.flow(train_data, train_labels, batch_size=BS,subset=\"validation\")\n\ntest_gen = train_datagen.flow(test_data, test_labels, batch_size=BS)\n","110dfa7f":"train_labels[0]","38f7aa92":"resnet_model = ResNet50(weights='imagenet', input_shape=(224,224,3), include_top=False)\n# Set all layers to non-trainable\nfor layer in resnet_model.layers[:171]:\n    layer.trainable = False\n\nfor layer in resnet_model.layers[171:]:\n    layer.trainable = True","c2a45157":"model = Sequential()\nmodel.add(Input(shape=(224,224,3)))\nmodel.add(resnet_model)\nmodel.add(Flatten())\nmodel.add(Dropout(0.25))\nmodel.add(Dense(128, activation='relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(4, activation='softmax')) # num labels = 4\n\nmodel.summary()","03b391ef":"model.compile(optimizer=Adam(learning_rate=0.0001),\n             loss='categorical_crossentropy',\n             metrics=['accuracy','AUC'])","62162b93":"\nhistory=model.fit(train_gen, \n          epochs=15,\n          validation_data=val_gen\n         )","a12fb911":"plt.figure(figsize=(5,5))\n# summarize history for accuracy\nhist=history.history\nplt.plot(hist[\"accuracy\"],color=\"b\",label=\"train_accuracy\")\nplt.plot(hist[\"val_accuracy\"],color=\"g\",label=\"val_accuracy\")\nplt.title('model accuracy')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(loc=\"lower right\")\nplt.show()\n\nplt.figure(figsize=(5,5))\n# summarize history for loss\nplt.plot(hist['loss'],color=\"b\",label=\"train_loss\")\nplt.plot(hist['val_loss'],color=\"g\",label=\"val_loss\")\nplt.title('model loss')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.legend( loc='upper left')\nplt.show()","31743d6c":"model.evaluate(train_gen)","d86bc32f":"model.evaluate(val_gen)","e09c978f":"model.evaluate(test_gen)","d41fe277":"test_pred=model.predict(test_gen)","6ec5e610":"test_pred","ee9ab0ed":"# # converting prediction to one-hot vector\n# for i in range(len(test_pred)):\n#     ind=np.argmax(test_pred[i])\n#     test_pred[i]=0.0\n#     test_pred[i][ind]=1.0","791eda8b":"#finding the class by np.argmax() from each prediction\ntest_pred_class=[]\ntest_labels_class=[]\nfor i,pred in enumerate(test_pred):\n    test_pred_class.append(np.int(np.argmax(pred)))\n    \nfor i,pred in enumerate(test_labels):\n    test_labels_class.append(np.int(np.argmax(pred)))","a7d34f6f":"# print(test_pred_class)","2f1872cd":"# print(test_labels_class)","b708b3b7":"labels=list(index_to_labels.values())\nlabels","9c672764":"cm = confusion_matrix(test_labels_class, test_pred_class)","bb3697bd":"import itertools\nfrom itertools import product\ndef plot_confusion_matrix(cm, classes,normalize=False,title='Confusion matrix',cmap=plt.cm.Blues):\n    \n    plt.figure(figsize=(10,10))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        print(\"Normalized confusion matrix\")\n    else:\n        print('Confusion matrix, without normalization')\n\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","08c00143":"plot_confusion_matrix(cm,labels)","57a5bf25":"AUC=roc_auc_score(test_labels,test_pred)\nAUC","4e683eea":"# sns.heatmap(cm, annot=True)","90184ab3":"path_to_label={}\nfor i,path in enumerate(test_paths):\n    label = path.split(os.path.sep)[-2]\n    path_to_label[path]=label\n","5f3e4400":"predictions=model.predict(test_gen)","7f1b88ed":"from PIL import Image","dad14c91":"fig = plt.figure(figsize=(18, 18))\ncolumns = 4\nrows = 4\nfor i in range(1, columns*rows +1):\n    img = load_img(test_paths[i], target_size=(224, 224))\n    img = img_to_array(img)\n    img = np.array(img)\/255.0\n    img=np.reshape(img,(-1,224,224,3))\n    pred=model.predict(img)\n    index=np.argmax(pred)\n    klass=index_to_labels[index] \n    actual=path_to_label[test_paths[i]]\n    img=np.reshape(img,(224,224,3))\n    fig.add_subplot(rows, columns, i)\n    plt.imshow(img)\n    plt.title(f'predicted: { klass} Actual :{actual}')\nplt.show()","ae5afe49":"# Image generator","0701b71c":"# Transfer learning","417995fc":"# model evaluation","b281a0a1":"# Class Distribution","5f21ceab":"# Model Prediction","dee2ae60":"# Confusion matrix"}}