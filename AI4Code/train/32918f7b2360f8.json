{"cell_type":{"a589cd66":"code","480acf2e":"code","6f573399":"code","23fa404b":"code","b7a5379f":"markdown"},"source":{"a589cd66":"\nimport random\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom scipy.spatial import distance\nfrom matplotlib import animation\nfrom itertools import product\nimport plotly as py\nimport plotly.graph_objs as go\nimport ipywidgets as widgets","480acf2e":"class game:\n\n    dataframelist = []   \n\n    def __init__(self,n,t):\n        self.n= n\n        self.t= t\n              \n    def iniz(self):\n        del self.dataframelist[:] #azzerare i valori del dataframe precedente,senn\u00f2 continua ad appendere \n        x_position= np.zeros((self.n,self.t))     \n        y_position= np.zeros((self.n,self.t))\n        x_values_initial = []\n        y_values_initial= []\n        positions = [[]]\n        distances = np.array(0)\n        alive = np.ones((self.n,self.t+1),dtype=bool)\n        for i in range(self.n):\n            x_values_initial.append(random.randint(1,50))\n            y_values_initial.append(random.randint(1,50))\n        x_position = np.insert(x_position,0,x_values_initial)\n        x_position = np.reshape(x_position,(self.n,self.t+1), order='F')\n        y_position = np.insert(y_position,0,y_values_initial)\n        y_position = np.reshape(y_position,(self.n,self.t+1), order='F')\n        for j in range(1,(self.t+1)):\n            for i in range(self.n):\n                x_position[i][j] = x_position[i][j-1] + random.choice((-1,0,+1))\n                y_position[i][j] = y_position[i][j-1] + random.choice((-1,0,+1))\n        for i in range(self.n):\n             for j in (range(self.t+1)):\n                positions.append([x_position[i][j],y_position[i][j]])\n        positions_array = np.array(positions)\n        positions_array = positions_array[1:]\n        positions_array = np.reshape(positions_array,(self.n,(self.t+1)))\n        for h in range(self.t+1):\n            for i in range(self.n):\n                for j in range(self.n):\n                    distances = np.append(distances,(distance.euclidean(positions_array[i][h],positions_array[j][h])))\n        distances = distances[1:]\n        distances = np.reshape(distances,(self.t+1,self.n,self.n))\n        \n        num_bias = np.count_nonzero(distances<7,axis=1)\n        num_corr = num_bias - 1\n        num_corr = np.transpose(num_corr)\n\n        position_neighborhood = []\n        for i in range(self.n):\n             position_neighborhood.append([list(a) for a in zip(positions_array[i],num_corr[i])])\n        for i in range(self.n):\n            self.dataframelist.append([list(a) for a in zip(position_neighborhood[i],alive[i])])\n        dataframe = pd.DataFrame(self.dataframelist)\n        for h in range(self.t):\n            for i in range(self.n):\n                if self.dataframelist[i][h][1] == True:                #se vero\n                    if self.dataframelist[i][h][0][1] < 2:                #se quelli vicino meno di 2\n                        self.dataframelist[i][h+1][1] = False               #allora falso\n                    if self.dataframelist[i][h][0][1] > 5:                #se quelli vicino maggiori di 5\n                        self.dataframelist[i][h+1][1] = False               #allora falso\n                    if self.dataframelist[i][h][0][1] == 5:               #se quelli vicino uguali a 5\n                        self.dataframelist[i][h+1][1] = True                #allora vero\n                    if self.dataframelist[i][h][0][1] == 4:               #se quelli vicino uguali a 4\n                        self.dataframelist[i][h+1][1] = True                #allora vero\n                    if self.dataframelist[i][h][0][1] == 3:               #se quelli vicino uguali a 3\n                        self.dataframelist[i][h+1][1] = True                #allora vero\n                    if self.dataframelist[i][h][0][1] == 2 :              #se quelli vicino uguali a 2\n                        self.dataframelist[i][h+1][1] = True                #allora vero\n                        \n                if self.dataframelist[i][h][1] == False:                #se falso\n                    self.dataframelist[i][h+1][1] = False                 #allora quello dopo falso                    \n                if self.dataframelist[i][h][1] == False:                #se falso\n                    if self.dataframelist[i][h][0][1] == 3:               #se quelli vicino uguale a 3\n                        self.dataframelist[i][h+1][1] = True                #allora vero\n                    if self.dataframelist[i][h][0][1] == 4:               #se quelli vicino uguale a 4\n                        self.dataframelist[i][h+1][1] = True                #allora vero         \n                    if self.dataframelist[i][h][0][1] == 5:               #se quelli vicino uguale a 5\n                        self.dataframelist[i][h+1][1] = True                #allora vero         \n       \n    \n    # return (dataframe)\n    def dataframe(self):\n        '''return the dataframe with all the data positions,the state and the number of neighbours'''\n        return (pd.DataFrame(self.dataframelist))\n    \n    \n    def prepare_plot(self):\n        '''not necessary to call'''\n        #signals= widgets.SelectMultiple(options=range((self.t+1)), value=[0,], description = 'm')\n        dataframe = pd.DataFrame(self.dataframelist)\n        x = []\n        y = []\n        for h in np.arange(self.t+1):\n            for i in np.arange(self.n):\n                if dataframe[h][i][1] == True:\n                    x.append(dataframe[h][i][0][0][0])\n                    y.append(dataframe[h][i][0][0][1])\n                else:\n                    x.append(-999)\n                    y.append(-999)\n        x=np.asarray(x)\n        y=np.asarray(y)\n        x=np.reshape(x,(self.t+1,self.n))\n        y=np.reshape(y, (self.t+1,self.n))  \n        return(x,y)","6f573399":"values = game(100,8)\ngame.iniz(values)\n#game.dataframe(values) #se si vogliono vedere i dati","23fa404b":"layout = go.Layout(\n    title= 'GAME',\n    yaxis=dict(range=[0,55]),\n    xaxis=dict(range=[0,55])\n)\n\ndef update_plot(signals):\n    datax = []\n    for i in signals:\n        trace1 = go.Scatter(\n            x = game.prepare_plot(values)[0][i],\n            y = game.prepare_plot(values)[1][i],\n            mode='markers'\n        )\n        datax.append(trace1)\n    \n    fig = go.Figure(data=datax,layout=layout)\n    py.offline.iplot(fig)\n    \nsignals= widgets.SelectMultiple(options=range((len(game.prepare_plot(values)[1]))), value=[0,], description = 'time')\nwidgets.interactive(update_plot,signals=signals)","b7a5379f":"This is my project for create by hand a game of life model, it is very basic and need to be improved, if anyone have any kind of suggestion, let me know :) Check on my Github for further improvements :)\nhttps:\/\/github.com\/domizianostingi?tab=repositories"}}