{"cell_type":{"ccfab4cc":"code","bbbc893b":"code","77b99dcd":"code","f29bd764":"code","55dc47fc":"code","bd37b5b8":"code","265818ff":"code","71469b73":"code","61fc31ff":"code","b2a87745":"code","4a8ed578":"code","54e24f3d":"code","42a95720":"code","c3da98aa":"code","74d5a18b":"code","56c88359":"code","9bf8345b":"code","862b87b2":"code","f3ed2020":"code","0ce5f89a":"markdown","195d8bbe":"markdown","0ba5f86a":"markdown","11cc932b":"markdown","97c430a2":"markdown","23fbeb9d":"markdown"},"source":{"ccfab4cc":"import random\nfrom tqdm import tqdm\nimport joblib\nimport pandas as pd\nimport numpy as np\n\nfrom sklearn.neighbors import NearestNeighbors\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.pipeline import make_pipeline\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport warnings\n\nwarnings.filterwarnings('ignore')","bbbc893b":"PATH = '..\/input\/russia-real-estate-20182021\/all_v2.csv'\n\nMIN_AREA = 20  # Outlier range for floor area\nMAX_AREA = 200\n\nMIN_KITCHEN = 6  # Outlier range for kitchen area\nMAX_KITCHEN = 30\n\nMIN_PRICE = 1_500_000  # Outlier range for price\nMAX_PRICE = 50_000_000\n\nMIN_SQM_PRICE = 75_000  # Outlier range for price per sq. meter\nMAX_SQM_PRICE = 250_000\n\nTEST_SIZE = 0.1\n\n# Features to use in Nearest Neighbours model.\nFEATURES = ['geo_lat', 'geo_lon', 'building_type', 'level', 'levels',\n            'area', 'kitchen_area', 'object_type', 'year', 'month',\n            'level_to_levels', 'area_to_rooms']","77b99dcd":"def set_display():\n    \"\"\"Function sets display options for charts and pd.DataFrames.\n    \"\"\"\n    # Plots display settings\n    plt.style.use('fivethirtyeight')\n    plt.rcParams['figure.figsize'] = 12, 8\n    plt.rcParams.update({'font.size': 14})\n    # DataFrame display settings\n    pd.set_option('display.max_columns', None)\n    pd.set_option('display.max_rows', None)\n    pd.options.display.float_format = '{:.4f}'.format\n\n\ndef add_features(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Function updates DataFrame adding temporal features\n    and ratios for \"area\" and \"level\" parameters.\n    :param df: Original DataFrame\n    :return: Updated DataFrame\n    \"\"\"\n    df['date'] = pd.to_datetime(df['date'])\n    # Replace \"date\" with numeric features for year and month.\n    df['year'] = df['date'].dt.year\n    df['month'] = df['date'].dt.month\n    df.drop(['date', 'time'], axis=1, inplace=True)\n    # Apartment floor in relation to total number of floors.\n    df['level_to_levels'] = df['level'] \/ df['levels']\n    # Average size of room in the apartment.\n    df['area_to_rooms'] = (df['area'] \/ df['rooms']).abs()\n    # Fix division by zero.\n    df.loc[df['area_to_rooms'] == np.inf, 'area_to_rooms'] = \\\n        df.loc[df['area_to_rooms'] == np.inf, 'area']\n    return df\n\n\ndef select_region(df: pd.DataFrame, region: str) -> pd.DataFrame:\n    \"\"\"Function selects the listings belonging to a specified region.\n    :param df: Original DataFrame with all listings\n    :param region: Region ID\n    :return: Filtered DataFrame\n    \"\"\"\n    df = df[df['region'] == region]\n    return df.drop('region', axis=1)\n\n\ndef clean_data(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Function removes outliers from the DataFrame.\n    :param df: Original DataFrame\n    :return: Updated DataFrame\n    \"\"\"\n    # Column actually contains -1 and -2 values presumably for studio apartments.\n    df['rooms'] = df['rooms'].apply(lambda x: 0 if x < 0 else x)\n    df['price'] = df['price'].abs()  # Fix negative values\n    # Drop price and area outliers.\n    df = df[(df['area'] <= MAX_AREA) & (df['area'] >= MIN_AREA)]\n    df = df[(df['price'] <= MAX_PRICE) & (df['price'] >= MIN_PRICE)]\n    # Drop outliers based on price per sq. meter.\n    df['sqm_price'] = df['price'] \/ df['area']\n    df = df[(df['sqm_price'] >= MIN_SQM_PRICE) & (df['sqm_price'] <= MAX_SQM_PRICE)]\n    # Fix kitchen area outliers.\n    # At first, replace all outliers with 0.\n    df.loc[(df['kitchen_area'] >= MAX_KITCHEN) | (df['area'] <= MIN_AREA), 'kitchen_area'] = 0\n    # Then calculate kitchen area based on the floor area, except for studios.\n    erea_mean, kitchen_mean = df[['area', 'kitchen_area']].quantile(0.5)\n    kitchen_share = kitchen_mean \/ erea_mean\n    df.loc[(df['kitchen_area'] == 0) & (df['rooms'] != 0), 'kitchen_area'] = \\\n        df.loc[(df['kitchen_area'] == 0) & (df['rooms'] != 0), 'area'] * kitchen_share\n\n    return df","f29bd764":"set_display()","55dc47fc":"data = pd.read_csv(PATH)\nprint(f'Data shape: {data.shape}')\ndata.head()","bd37b5b8":"data.info()","265818ff":"data.describe()","71469b73":"building_types = data['building_type'].value_counts()\nplt.pie(building_types.values, labels=building_types.index, autopct='%1.1f%%')\nplt.title('Building Types')\nplt.show()","61fc31ff":"apartment_types = data['object_type'].value_counts()\nplt.pie(apartment_types.values, labels=apartment_types.index, autopct='%1.1f%%')\nplt.title('Apartment Types')\nplt.show()","b2a87745":"rooms = data['rooms'].value_counts()\nplt.pie(rooms.values, labels=rooms.index, autopct='%1.1f%%')\nplt.title('Number of Rooms')\nplt.show()","4a8ed578":"# Regions are encoded with numeric IDs.\nregions = data['region'].value_counts()\n\nplt.hist(regions.values, bins=10)\nplt.title('Listings by Region')\nplt.show()","54e24f3d":"regions = regions[regions >= 100_000].index\nregion = random.choice(regions)\nprint(f'Selected region ID: {region}')","42a95720":"# Drop other regions and outliers, generate new features.\ndata = select_region(data, region).pipe(clean_data).pipe(add_features)\nprint(f'Data shape: {data.shape}')","c3da98aa":"# Basic statistics for the target value.\nmean_price = int(data['price'].mean())\nmedian_price = int(data['price'].median())\n\nstd = int(data['price'].std())\n\nmin_price = int(data['price'].min())\nmax_price = int(data['price'].max())\n\nprint(f'Price range: {min_price} - {max_price}')\nprint(f'Mean price: {mean_price}\\nMedian price: {median_price}')\nprint(f'Standard deviation: {std}')\n\nplt.hist(data['price'], bins=20)\nplt.axvline(mean_price, label='Mean Price', color='red')\nplt.axvline(median_price, label='Median Price', color='green')\nplt.legend()\nplt.xlabel('Apartment Price, Rubles')\nplt.title('Price Distribution')\nplt.show()","74d5a18b":"correlation = data.corr()\nax = sns.heatmap(correlation, center=0, cmap='RdBu_r')\nl, r = ax.get_ylim()\nax.set_ylim(l + 0.5, r - 0.5)\nplt.yticks(rotation=0)\nplt.title('Correlation Matrix')\nplt.show()","56c88359":"# To keep track of MAE and MSE for all apartment types.\nall_errors = []\nall_mse = []","9bf8345b":"# Create a separate model for each apartment type\n# (studio, 1-room, 2-room, etc.).\nfor n_rooms in data['rooms'].unique():\n    print('-' * 50)\n    print(f'Creating model for {n_rooms} rooms apartments.')\n    subset = data[data['rooms'] == n_rooms].copy()\n\n    # Select a random subset of data to use as queries.\n    n_test_samples = int(len(subset) * TEST_SIZE)\n    test_queries = subset.sample(n=n_test_samples)\n    subset = subset.drop(test_queries.index)\n    print(f'Train subset data shape: {subset.shape}')\n\n    # Check the size of the subset.\n    n_train_samples = len(subset)\n\n    if n_train_samples < 10:\n        print('Warning: Not enough samples for this apartment type.')\n        continue\n    \n    # Set number of neighbours to 10.\n    n_neighbours = 10\n \n    # Create a pipeline including scaler and neighbour search model.\n    pipe = make_pipeline(\n        StandardScaler(),\n        NearestNeighbors(n_neighbors=n_neighbours, radius=0.3, n_jobs=-1)\n    )\n\n    pipe.fit(subset[FEATURES])\n\n    # Save the pipeline using region ID and number of rooms to define a filename.\n    joblib.dump(value=pipe, filename=f'region{region}_rooms{n_rooms}.joblib')\n    \n    # Select the most similar apartments for all test samples.\n    query = pipe[0].transform(test_queries[FEATURES])  # Scale input features.\n    similar_idx = pipe[1].kneighbors(query, n_neighbours, return_distance=False)\n\n    \n    def median_price(idx: np.array):\n        return subset.iloc[idx, :]['price'].median()\n        \n\n    # Transform indexes of similar apartments into median prices.\n    y_pred = np.apply_along_axis(median_price, 1, similar_idx)\n    \n    # Compare with the actual price.\n    errors = np.abs(test_queries['price'].values - y_pred).tolist()\n\n    mse = [err ** 2 for err in errors]\n    print(f'Average MAE for {n_rooms} rooms apartment: {int(np.mean(errors))}')\n    print(f'Average RMSE for {n_rooms} rooms apartment: {int(np.sqrt(np.mean(mse)))}')\n\n    all_errors.extend(errors)\n    all_mse.extend(mse)","862b87b2":"mae = int(np.mean(all_errors))\nrmse = int(np.sqrt(np.mean(all_mse)))\n\nprint(f'Average MAE for all queries: {mae}')\nprint(f'Average RMSE for all queries: {rmse}')\nprint(f'MAE \/ std ratio: {mae \/ std}')","f3ed2020":"plt.hist(all_errors, bins=20)\nplt.axvline(std, label='Standard Deviation', color='red')\nplt.legend()\nplt.title('Price MAE')\nplt.show()","0ce5f89a":"Data set contains extreme outliers, errors and typos like negative prices, unrealistic total area of the apartment or kitchen area. Some of the outliers result from technical errors. Others are produced by humans: sometimes sellers or real estate agents fill in forms on a web site in the apartments section, when in reality they are selling one room in a multi-room apartment or a whole building.","195d8bbe":"## Functions","0ba5f86a":"# Nearest Neighbours Pricing Algorithm\nThis notebooks implements **apartment evaluation** approach, which is based on selecting the most **similar apartments from the listings** for each individual query object, dropping extreme outliers and predicting the most likely price by calculating the median price of the analogues.\n\nAlgorithm is based on the [data set](https:\/\/www.kaggle.com\/mrdaniilak\/russia-real-estate-20182021) containing listings of apartments offered for sale in various regions of Russia.","11cc932b":"# Creating Models\n\nWe will use **NearestNeighbours** from sklearn to find the most similar apartments for each apartment from the test set. Test set will be a randomly selected subset of data **for each apartment type**: modelling for studio apartments, 1-room apartments, 2-room apartments, etc. will be performed separately.\n\nWe assume that on average about the half of the selected analogues (nearest neighbours) will be better than the query object and more expansive, while other half of the analogues will be worse and cheaper. To predict the most likely price for the query apartment from the test set we will calculate the **median price among the selected nearest neighbours**.","97c430a2":"Listings are unequally distributed between the regions with most of the offerings concentrated in the largest and most developed cities and their surrounding areas. To test the algorithm we randomly select a region with at least 100,000 apartments (before data cleaning). It will ensure that train and test samples will be coming from the same geographical area.","23fbeb9d":"## Data Processing & Analysis\n\n#### Features and data types\n\n**Categorical features:**\n- Region (numerically encoded geographical area, identifies either a large city like Moscow or Saint Petersburg or a federal region \/ district)\n- Building type (numerically encoded type of the building where the apartment is located)\n- Object type (apartment type, where 1 stands for secondary real estate market, 11 - new building)\n\n**Numerical features:**\n- Area (total floor area of the apartment in sq. meters)\n- Kitchen area (kitchen area in sq. meters)\n- Rooms (number of rooms in the apartment, -1 stands for studios with open-space layout)\n- Level (floor the apartment is located on, could be treated as a categorical feature as well)\n- Levels (total number of storeys in the building)\n\n**Geospatial features:**\n- Latitude - geographical coordinate of the preperty\n- Longitude - geographical coordinate of the preperty\n\n**Temporal features:**\n- Date (date the listing was published)\n- Time (exact time the listing was published)"}}