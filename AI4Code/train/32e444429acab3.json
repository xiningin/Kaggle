{"cell_type":{"1f477958":"code","f090da6b":"code","ea45c594":"code","e197c06a":"code","b8ed772a":"code","62b8fbfa":"code","b85ec8c0":"code","f3a19817":"markdown","3b148455":"markdown","96af10c0":"markdown"},"source":{"1f477958":"import os\nimport cv2\nimport numpy as np \nimport matplotlib.pyplot as plt\n\ndata_dir = '\/kaggle\/input\/image-grid'\ndata_file = os.listdir(data_dir)\ndata_file.sort()\ndata_file","f090da6b":"n = len(data_file)\nfig, ax = plt.subplots(1, 4, figsize=(25, 5.5))\nfor k in range(n):\n    img = cv2.imread(os.path.join(data_dir, data_file[k]))\n    img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n    ax[k].imshow(img, aspect=\"auto\")\n    ax[k].set_title('original image : \"%s\"'%(data_file[k]))\nplt.show()","ea45c594":"def spliting_image_to_grid(img_id, nr, nc, new_shape = (256, 256)):\n    \"\"\"\n    Input:  img_id (str): image_id from the dataset of image file\n            nr, nc (int): number of rows, columns of grid\n            new_shape (tuple of int) : a shape of each image in grid\n    return: list of images size with a desired shapes\n    \"\"\"\n    ## read the image\n    img = cv2.imread(os.path.join(data_dir, f'{img_id}'))\n    ## convert color to display in matplotlib\n    img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n    ## return height and witdh of the image\n    h, w = img.shape[: 2]\n    ## calculate the original_size of height, with in each tiles of images\n    hs, ws = int(h \/ nr), int(w \/ nc)\n    img_ls = []\n    \n    for i in range(nr):\n        for j in range(nc):\n            image_dt = img[ int(i*hs) : int((i+1)*hs), int(j*ws) : int((j+1)*ws), :]\n            ## resize the image to the desired shape\n            image_dt = cv2.resize(image_dt, new_shape, interpolation = cv2.INTER_AREA)\n            img_ls.append(image_dt)\n                \n    return img_ls\n\nnrows = 3; ncols = 4\nX = spliting_image_to_grid(data_file[0], nrows, ncols)\ntype(X), np.array(X).shape","e197c06a":"def display_image_in_grid(img_id, nr, nc, new_shape = (256, 256), fs = (30, 30)):\n    \"\"\"\n    Input:  img_id (str): image_id from the dataset of image file\n            nr, nc (int): number of rows, columns of grid\n            new_shape (tuple of int) : a shape of each image in grid\n            fs (tupple of numbers): figsize of plot\n    return: display a grid of images size with a desired shapes\n    \"\"\"\n    X = spliting_image_to_grid(img_id, nr, nc, new_shape)\n    plt.figure(figsize = fs)\n    for k in range(nr*nc):\n        plt.subplot(nr, nc, k+1)\n        plt.imshow(X[k])\n        plt.axis('off')\n        \ndisplay_image_in_grid(data_file[0], nrows, ncols, fs = (12, 9))","b8ed772a":"display_image_in_grid(data_file[1], 4, 4, fs = (20, 16))","62b8fbfa":"display_image_in_grid(data_file[2], 4, 3, fs = (20, 16))","b85ec8c0":"display_image_in_grid(data_file[3], 3, 5, fs = (20, 14))","f3a19817":"### Loading all original images","3b148455":"### Define a function","96af10c0":"This meant for `nrows = 3` and `ncols = 4`, the `function` returns a `list` of `256 x 256 (default)` sub_images from w.r.t the grid `nrows x ncols`.\n\nNoting that, in many cases; we want to **store** the data of `3D_array` of the `image_in_grid` from a `very_large_image` to simplify the computation in `training` and `evaluation`. So this function only return a list of images, not showing!! \n\nTo showing the result of this function, we will define another type of this, named `display_image_in_grid()`"}}