{"cell_type":{"d13f1136":"code","babbdbad":"code","fed708f9":"code","6c49a7a7":"code","1951de57":"code","f6726a53":"code","44165bbc":"code","11dd38dc":"code","74847c4b":"code","44e3c6f5":"code","0e59cc80":"code","1a0a212b":"code","b5484d87":"code","5f82715d":"code","ae5f1420":"code","ca41473e":"code","00ec7f09":"code","df0feb73":"code","7b3cefd7":"code","c5bf285a":"code","3f9c74ae":"code","f64447a9":"markdown","d08f779d":"markdown","2271fe5c":"markdown","2f5c5e73":"markdown","8155c96f":"markdown","60f84607":"markdown","71be204a":"markdown","d9e04fa3":"markdown","ec76ad34":"markdown","42d22ade":"markdown","a36abf30":"markdown","e0e099f0":"markdown"},"source":{"d13f1136":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport pickle\n\nfrom sklearn.model_selection import train_test_split\n\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import *","babbdbad":"train = pd.read_csv(f'..\/input\/digit-recognizer\/train.csv')\n\nprint('Training Set Size:', train.shape)","fed708f9":"train.head()","6c49a7a7":"pixels = train.drop('label', axis=1).values\nlabels = train.label.values\n\nprint(pixels.shape)\nprint(labels.shape)","1951de57":"np.set_printoptions(linewidth=116)\n\nimg = pixels[8, :].reshape(28,28)\nprint(img)\n\nnp.set_printoptions(linewidth=75)","f6726a53":"plt.figure(figsize=[6,6])\nplt.imshow(img, cmap='binary')\nplt.axis('off')\nplt.show()","44165bbc":"sel = np.random.choice(range(len(train)), 40, replace=False)\n\nimage_sel = pixels[sel,:]\nlabel_sel = labels[sel]\n\nplt.close()\nplt.rcParams[\"figure.figsize\"] = [16,10]\n\nfor i in range(40):\n    img = image_sel[i].reshape(28,28)\n    lab = label_sel[i]\n    \n    plt.subplot(5,8,i+1)\n    plt.imshow(img, cmap='binary')\n    plt.text(-1, 10, s = str(lab), fontsize=16, color='b')\n    plt.axis('off')\n\nplt.show()","11dd38dc":"(train.label.value_counts() \/ len(train)).to_frame().sort_index().T","74847c4b":"X_train, X_valid, y_train, y_valid = train_test_split(\n    pixels, labels, test_size=0.2, stratify=labels, random_state=1\n)\n\n\nprint('X_train Shape:', X_train.shape)\nprint('y_train Shape:', y_train.shape)\nprint()\nprint('X_valid Shape:', X_valid.shape)\nprint('y_valid Shape:', y_valid.shape)","44e3c6f5":"Xs_train = X_train \/ 255\nXs_valid = X_valid \/ 255","0e59cc80":"digit_net = Sequential([\n    Dense(128, activation='relu', input_shape=(784,)),\n    Dense(64, activation='relu'), \n    Dense(10, activation='softmax')\n])\n\ndigit_net.summary()","1a0a212b":"opt = tf.keras.optimizers.Adam(0.001)\ndigit_net.compile(loss='sparse_categorical_crossentropy', optimizer=opt, metrics=['accuracy'])","b5484d87":"%%time\n\nh1 = digit_net.fit(Xs_train, y_train, batch_size=2048, epochs=30, \n                   validation_data=(Xs_valid, y_valid), verbose=1)","5f82715d":"history = h1.history\nn_epochs = len(history['loss'])\n\nplt.figure(figsize=[10,4])\nplt.subplot(1,2,1)\nplt.plot(range(1, n_epochs+1), history['loss'], label='Training')\nplt.plot(range(1, n_epochs+1), history['val_loss'], label='Validation')\nplt.xlabel('Epoch'); plt.ylabel('Loss'); plt.title('Loss')\nplt.legend()\nplt.subplot(1,2,2)\nplt.plot(range(1, n_epochs+1), history['accuracy'], label='Training')\nplt.plot(range(1, n_epochs+1), history['val_accuracy'], label='Validation')\nplt.xlabel('Epoch'); plt.ylabel('Accuracy'); plt.title('Accuracy')\nplt.ylim([0.9, 1])\nplt.legend()\nplt.show()","ae5f1420":"%%time\n\ntf.keras.backend.set_value(digit_net.optimizer.learning_rate, 0.0001)\n\nh2 = digit_net.fit(Xs_train, y_train, batch_size=2048, epochs=30, \n                   validation_data=(Xs_valid, y_valid), verbose=1)","ca41473e":"for k in history.keys():\n    history[k] += h2.history[k]","00ec7f09":"n_epochs = len(history['loss'])\n\nplt.figure(figsize=[10,4])\nplt.subplot(1,2,1)\nplt.plot(range(1, n_epochs+1), history['loss'], label='Training')\nplt.plot(range(1, n_epochs+1), history['val_loss'], label='Validation')\nplt.xlabel('Epoch'); plt.ylabel('Loss'); plt.title('Loss')\nplt.legend()\nplt.subplot(1,2,2)\nplt.plot(range(1, n_epochs+1), history['accuracy'], label='Training')\nplt.plot(range(1, n_epochs+1), history['val_accuracy'], label='Validation')\nplt.xlabel('Epoch'); plt.ylabel('Accuracy'); plt.title('Accuracy')\nplt.ylim([0.9, 1])\nplt.legend()\nplt.show()","df0feb73":"digit_net.save('digit_ann_v01.h5')\npickle.dump(history, open(f'digit_ann_v01_history.pkl', 'wb'))","7b3cefd7":"valid_probs = digit_net.predict(Xs_valid)\nprint(valid_probs[:10].round(2))","c5bf285a":"valid_pred = np.argmax(valid_probs, axis=1)\nprint(valid_pred[:10])","3f9c74ae":"sel = np.random.choice(range(len(X_valid)), 40, replace=False)\n\nX_sel = X_valid[sel]\ny_sel = y_valid[sel]\np_sel = valid_pred[sel]\n\nplt.close()\nplt.rcParams[\"figure.figsize\"] = [16,10]\nfor i in range(40):\n    img = X_sel[i].reshape(28,28)\n    lab = y_sel[i]\n    pred = p_sel[i]\n    \n    plt.subplot(5,8,i+1)\n    plt.imshow(img, cmap='binary')\n    plt.text(-1, 10, s = str(lab), fontsize=16, color='b')\n    plt.text(-1, 18, s = str(pred), fontsize=16, color='r')\n    plt.axis('off')\nplt.show()","f64447a9":"# Import Statements","d08f779d":"# Train Model","2271fe5c":"# MNIST Handwritten Digit Dataset\n\n","2f5c5e73":"# View Images","8155c96f":"## Training Run 2","60f84607":"# Label Distribution","71be204a":"## Training Run 1","d9e04fa3":"# Build Artificial Neural Network\n\n![](https:\/\/drbeane.github.io\/files\/images\/converting_bw_image.jpg)\n","ec76ad34":"# Load and Explore Data","42d22ade":"# Explore Validation Set Predictions","a36abf30":"# Save Model","e0e099f0":"# Split and Scale Datasets"}}