{"cell_type":{"92fbb828":"code","36cc13e4":"code","cb83db0b":"code","b879010b":"code","95ba873a":"code","f700102c":"code","3bd2dfbf":"code","205cbd9b":"code","51f8575d":"code","b18e94ee":"code","046d6387":"code","780aed6c":"code","b95c8ed0":"markdown","2a19c702":"markdown","c7b0fcb3":"markdown"},"source":{"92fbb828":"import os\nimport sys\nimport pickle\nimport numpy as np\nimport pandas as pd\nfrom PIL import Image, ImageFilter, ImageEnhance\nfrom tqdm import tqdm_notebook\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, mean_squared_error, log_loss, confusion_matrix\nimport matplotlib.pyplot as plt\nimport warnings\nimport cv2 as cv\n\nwarnings.simplefilter(\"ignore\")                      # To ignore warnings\n\nnp.random.seed(10)\nLEVEL = 'level_4a'","36cc13e4":"class SigmoidNeuron:\n  \n  def __init__(self):\n    self.w = None\n    self.b = None\n    \n  def perceptron(self, x):\n    return np.dot(x, self.w.T) + self.b\n  \n  def sigmoid(self, x):\n    return 1.0\/(1.0 + np.exp(-x))\n  \n  def grad_w_mse(self, x, y):\n    y_pred = self.sigmoid(self.perceptron(x))\n    return (y_pred - y) * y_pred * (1 - y_pred) * x\n  \n  def grad_b_mse(self, x, y):\n    y_pred = self.sigmoid(self.perceptron(x))\n    return (y_pred - y) * y_pred * (1 - y_pred)\n  \n  def grad_w_ce(self, x, y):\n    y_pred = self.sigmoid(self.perceptron(x))\n    if y == 0:\n      return y_pred * x\n    elif y == 1:\n      return -1 * (1 - y_pred) * x\n    else:\n      raise ValueError(\"y should be 0 or 1\")\n    \n  def grad_b_ce(self, x, y):\n    y_pred = self.sigmoid(self.perceptron(x))\n    if y == 0:\n      return y_pred \n    elif y == 1:\n      return -1 * (1 - y_pred)\n    else:\n      raise ValueError(\"y should be 0 or 1\")\n  \n  def fit(self, X, Y, epochs=1, learning_rate=1, initialise=True, loss_fn=\"mse\", display_loss=False):\n    \n    # initialise w, b\n    if initialise:\n      #self.w = np.random.randn(1, X.shape[1])\n      self.w = X.mean(axis=0)\n      self.b = 0\n      \n    if display_loss:\n      loss = {}\n    \n    for i in tqdm_notebook(range(epochs), total=epochs, unit=\"epoch\"):\n      dw = 0\n      db = 0\n      for x, y in zip(X, Y):\n        if loss_fn == \"mse\":\n          dw += self.grad_w_mse(x, y)\n          db += self.grad_b_mse(x, y) \n        elif loss_fn == \"ce\":\n          dw += self.grad_w_ce(x, y)\n          db += self.grad_b_ce(x, y)\n      self.w -= learning_rate * dw\n      self.b -= learning_rate * db\n      \n      if display_loss:\n        Y_pred = self.sigmoid(self.perceptron(X))\n        if loss_fn == \"mse\":\n          loss[i] = mean_squared_error(Y, Y_pred)\n        elif loss_fn == \"ce\":\n          loss[i] = log_loss(Y, Y_pred)\n    \n    if display_loss:\n      plt.plot(loss.values())\n      plt.xlabel('Epochs')\n      if loss_fn == \"mse\":\n        plt.ylabel('Mean Squared Error')\n      elif loss_fn == \"ce\":\n        plt.ylabel('Log Loss')\n      plt.show()\n    \n      min_key = min(loss, key=loss.get)\n      print(min_key)\n      print(loss.get(min_key))\n      \n  def predict(self, X):\n    Y_pred = []\n    for x in X:\n      y_pred = self.sigmoid(self.perceptron(x))\n      Y_pred.append(y_pred)\n    return np.array(Y_pred)","cb83db0b":"def increase_brightness(img,value):\n    hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)\n    h, s, v = cv.split(hsv)\n\n    lim = 255 - value\n    v[v > lim] = 255\n    v[v <= lim] += value\n\n    final_hsv = cv.merge((h, s, v))\n    image = cv.cvtColor(final_hsv, cv.COLOR_HSV2BGR)\n    return image","b879010b":"def read_all(folder_path, key_prefix=\"\"):\n    '''\n    It returns a dictionary with 'file names' as keys and 'flattened image arrays' as values.\n    '''\n    print(\"Reading:\")\n    images = {}\n    files = os.listdir(folder_path)\n    for i, file_name in tqdm_notebook(enumerate(files), total=len(files)):\n        file_path = os.path.join(folder_path, file_name)\n        image_index = key_prefix + file_name[:-4]\n        image = cv.imread(file_path)\n        \n        image = increase_brightness(image,10)                     # Increase brightness with 10 pixels\n        image = cv.cvtColor(image,cv.COLOR_BGR2GRAY)              # Convert image to Gray Scale\n        kernel = np.ones((2,2), np.uint8)                         # Define a kernel of size 2X2, small kernel because image is also very small i.e. 64X64 only\n        ret,image = cv.threshold(image,30,255,cv.THRESH_BINARY)   # Binary threshold to convert image into Black and White. All pixels having value above or equal to 30 will be converted into White (255) and lower than 30 will be converted to Black (0))\n        image = cv.bitwise_not(image)                             # Invert the image. Black pixels to white and white pixels to black\n        image = cv.morphologyEx(image, cv.MORPH_OPEN, kernel)     # Reducing Noise in an image\n        image = cv.bitwise_not(image)                             # Invert again\n        image = cv.medianBlur(image,3)                            # Increase the thickness of letter so that it's more prominent and easily recogonizable\n        \n        images[image_index] = image.flatten()      \n    return images","95ba873a":"languages = ['en','ta', 'hi']\n\nimages_train = read_all(\"..\/input\/\"+LEVEL+\"_train\/\"+LEVEL+\"\/\"+\"background\", key_prefix='bgr_') \nfor language in languages:\n  images_train.update(read_all(\"..\/input\/\"+LEVEL+\"_train\/\"+LEVEL+\"\/\"+language, key_prefix=language+\"_\" ))\nprint(len(images_train))\n\nimages_test = read_all(\"..\/input\/\"+LEVEL+\"_test\/kaggle_\"+LEVEL, key_prefix='') \nprint(len(images_test))","f700102c":"list(images_test.keys())[:5]","3bd2dfbf":"X_train = []\nY_train = []\nfor key, value in images_train.items():\n    X_train.append(value)\n    if key[:4] == \"bgr_\":\n        Y_train.append(0)\n    else:\n        Y_train.append(1)\n\nID_test = []\nX_test = []\nfor key, value in images_test.items():\n  ID_test.append(int(key))\n  X_test.append(value)\n  \n        \nX_train = np.array(X_train)\nY_train = np.array(Y_train)\nX_test = np.array(X_test)\n\nprint(X_train.shape, Y_train.shape)\nprint(X_test.shape)","205cbd9b":"scaler = StandardScaler()\nX_scaled_train = scaler.fit_transform(X_train)\nX_scaled_test = scaler.transform(X_test)","51f8575d":"sn_ce = SigmoidNeuron()\nsn_ce.fit(X_scaled_train, Y_train, epochs=100, learning_rate=1,loss_fn=\"ce\", display_loss=True)\nsn_ce.fit(X_scaled_train, Y_train, epochs=200, learning_rate=0.1,initialise=False,loss_fn=\"ce\", display_loss=True)\nsn_ce.fit(X_scaled_train, Y_train, epochs=200, learning_rate=0.01,initialise=False,loss_fn=\"ce\", display_loss=True)\nsn_ce.fit(X_scaled_train, Y_train, epochs=400, learning_rate=0.001,initialise=False,loss_fn=\"ce\", display_loss=True)\nsn_ce.fit(X_scaled_train, Y_train, epochs=500, learning_rate=0.0001,initialise=False,loss_fn=\"ce\", display_loss=True)","b18e94ee":"def print_accuracy(sn):\n  Y_pred_train = sn.predict(X_scaled_train)\n  Y_pred_binarised_train = (Y_pred_train >= 0.5).astype(\"int\").ravel()\n  accuracy_train = accuracy_score(Y_pred_binarised_train, Y_train)\n  print(\"Train Accuracy : \", accuracy_train)\n  print(\"-\"*50)","046d6387":"#print_accuracy(sn_mse)\nprint_accuracy(sn_ce)","780aed6c":"Y_pred_test = sn_ce.predict(X_scaled_test)\nY_pred_binarised_test = (Y_pred_test >= 0.5).astype(\"int\").ravel()\n\nsubmission = {}\nsubmission['ImageId'] = ID_test\nsubmission['Class'] = Y_pred_binarised_test\n\nsubmission = pd.DataFrame(submission)\nsubmission = submission[['ImageId', 'Class']]\nsubmission = submission.sort_values(['ImageId'])\nsubmission.to_csv(\"submisision.csv\", index=False)","b95c8ed0":"> *Define a function to increase the brightness of an image*","2a19c702":"> *Continous learning rates to learn quickly (bigger learning rates) and accurately (smaller learning rates)*","c7b0fcb3":"## Sample Submission"}}