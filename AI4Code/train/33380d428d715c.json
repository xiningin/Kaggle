{"cell_type":{"560a87c7":"code","c46203d4":"code","bec92465":"code","2269afe0":"code","2a96c466":"code","bd31e9e5":"code","dae69410":"code","1fdf6e04":"code","66229113":"code","3d8af60f":"code","c6d86515":"code","1b26c28e":"code","ad8429e3":"code","62a6e1b2":"code","0646a56c":"code","969c2b1d":"code","acde4c09":"code","2986fe0e":"code","9f139619":"code","08cbe4fb":"code","3883abd6":"code","25bac53e":"code","0f131bac":"code","1deac59b":"code","169e0a5d":"code","a0d86b84":"code","dfbb1f71":"code","2160adc6":"code","7fecda85":"code","f29793d2":"code","1be6451d":"code","98385541":"code","9a0ed343":"code","53105b0a":"code","ff1f53f6":"code","080f691a":"code","1124cc72":"code","3b2afa2e":"code","69c304a1":"code","6c69c0a7":"code","555553c7":"code","ac5c1bdc":"code","768efde2":"code","46fa665e":"code","a912dc13":"code","ac44b81f":"code","cc308915":"code","ef0581bc":"code","43938dc9":"code","6889063d":"code","375f1f3c":"code","79bb08ff":"code","e1c6d09f":"code","66b3d6f7":"code","f2cfebbb":"code","6fdb1ce8":"code","a1ffa6e1":"code","b7210fa0":"code","072975d6":"code","95fcd305":"markdown","d19a9240":"markdown","b3acb072":"markdown","ee053f80":"markdown","7920d3e6":"markdown","070f6534":"markdown","d87f2664":"markdown","0ac016f3":"markdown","b7a8d277":"markdown","31f71192":"markdown"},"source":{"560a87c7":"%load_ext autoreload\n%autoreload 2","c46203d4":"%matplotlib inline\n\nfrom fastai.imports import *\nfrom fastai.structured import *\nfrom sklearn.ensemble import RandomForestRegressor, RandomForestClassifier\nfrom IPython.display import display\nfrom sklearn import metrics","bec92465":"PATH = \"..\/input\/\"\n\ndf_raw = pd.read_feather('..\/input\/fast-ai-machine-learning-lesson-1\/tmp\/bulldozers-raw')\ndf_trn, y_trn, nas = proc_df(df_raw, 'SalePrice')","2269afe0":"def split_vals(a,n): return a[:n], a[n:]\nn_valid = 12000\nn_trn = len(df_trn)-n_valid\nX_train, X_valid = split_vals(df_trn, n_trn)\ny_train, y_valid = split_vals(y_trn, n_trn)\nraw_train, raw_valid = split_vals(df_raw, n_trn)","2a96c466":"x_sub = X_train[['YearMade', 'MachineHoursCurrentMeter']]","bd31e9e5":"class TreeEnsemble():\n    def __init__(self, x, y, n_trees, sample_sz, min_leaf=5):\n        np.random.seed(42)\n        self.x,self.y,self.sample_sz,self.min_leaf = x,y,sample_sz,min_leaf\n        self.trees = [self.create_tree() for i in range(n_trees)]\n\n    def create_tree(self):\n        rnd_idxs = np.random.permutation(len(self.y))[:self.sample_sz]\n        return DecisionTree(self.x.iloc[rnd_idxs], self.y[rnd_idxs], min_leaf=self.min_leaf)\n        \n    def predict(self, x):\n        return np.mean([t.predict(x) for t in self.trees], axis=0)","dae69410":"class DecisionTree():\n    def __init__(self, x, y, idxs=None, min_leaf=5):\n        self.x,self.y,self.idxs,self.min_leaf = x,y,idxs,min_leaf","1fdf6e04":"m = TreeEnsemble(X_train, y_train, n_trees=10, sample_sz=1000, min_leaf=3)","66229113":"m.trees[0]","3d8af60f":"class DecisionTree():\n    def __init__(self, x, y, idxs=None, min_leaf=5):\n        if idxs is None: idxs=np.arange(len(y))\n        self.x,self.y,self.idxs,self.min_leaf = x,y,idxs,min_leaf\n        self.n,self.c = len(idxs), x.shape[1]\n        self.val = np.mean(y[idxs])\n        self.score = float('inf')\n        self.find_varsplit()\n        \n    # This just does one decision; we'll make it recursive later\n    def find_varsplit(self):\n        for i in range(self.c): self.find_better_split(i)\n            \n    # We'll write this later!\n    def find_better_split(self, var_idx): pass\n    \n    @property\n    def split_name(self): return self.x.columns[self.var_idx]\n    \n    @property\n    def split_col(self): return self.x.values[self.idxs,self.var_idx]\n\n    @property\n    def is_leaf(self): return self.score == float('inf')\n    \n    def __repr__(self):\n        s = f'n: {self.n}; val:{self.val}'\n        if not self.is_leaf:\n            s += f'; score:{self.score}; split:{self.split}; var:{self.split_name}'\n        return s","c6d86515":"m = TreeEnsemble(X_train, y_train, n_trees=10, sample_sz=1000, min_leaf=3)","1b26c28e":"m.trees[0]","ad8429e3":"m.trees[0].idxs","62a6e1b2":"ens = TreeEnsemble(x_sub, y_train, 1, 1000)\ntree = ens.trees[0]\nx_samp,y_samp = tree.x, tree.y\nx_samp.columns","0646a56c":"tree","969c2b1d":"m = RandomForestRegressor(n_estimators=1, max_depth=1, bootstrap=False)\nm.fit(x_samp, y_samp)\ndraw_tree(m.estimators_[0], x_samp, precision=2)","acde4c09":"def find_better_split(self, var_idx):\n    x,y = self.x.values[self.idxs,var_idx], self.y[self.idxs]\n\n    for i in range(self.n):\n        lhs = x<=x[i]\n        rhs = x>x[i]\n        if rhs.sum()<self.min_leaf or lhs.sum()<self.min_leaf: continue\n        lhs_std = y[lhs].std()\n        rhs_std = y[rhs].std()\n        curr_score = lhs_std*lhs.sum() + rhs_std*rhs.sum()\n        if curr_score<self.score: \n            self.var_idx,self.score,self.split = var_idx,curr_score,x[i]","2986fe0e":"%timeit find_better_split(tree,1)\ntree","9f139619":"find_better_split(tree,0); tree","08cbe4fb":"tree = TreeEnsemble(x_sub, y_train, 1, 1000).trees[0]","3883abd6":"def std_agg(cnt, s1, s2): return math.sqrt((s2\/cnt) - (s1\/cnt)**2)\n\ndef find_better_split(self, var_idx):\n    x,y = self.x.values[self.idxs,var_idx], self.y[self.idxs]\n    \n    sort_idx = np.argsort(x)\n    sort_y,sort_x = y[sort_idx], x[sort_idx]\n    rhs_cnt,rhs_sum,rhs_sum2 = self.n, sort_y.sum(), (sort_y**2).sum()\n    lhs_cnt,lhs_sum,lhs_sum2 = 0,0.,0.\n\n    for i in range(0,self.n-self.min_leaf):\n        xi,yi = sort_x[i],sort_y[i]\n        lhs_cnt += 1; rhs_cnt -= 1\n        lhs_sum += yi; rhs_sum -= yi\n        lhs_sum2 += yi**2; rhs_sum2 -= yi**2\n        if i<self.min_leaf-1 or xi==sort_x[i+1]:\n            continue\n            \n        lhs_std = std_agg(lhs_cnt, lhs_sum, lhs_sum2)\n        rhs_std = std_agg(rhs_cnt, rhs_sum, rhs_sum2)\n        curr_score = lhs_std*lhs_cnt + rhs_std*rhs_cnt\n        if curr_score<self.score: \n            self.var_idx,self.score,self.split = var_idx,curr_score,xi","25bac53e":"%timeit find_better_split(tree,1)\ntree","0f131bac":"find_better_split(tree,0); tree","1deac59b":"DecisionTree.find_better_split = find_better_split","169e0a5d":"tree = TreeEnsemble(x_sub, y_train, 1, 1000).trees[0]; tree","a0d86b84":"m = RandomForestRegressor(n_estimators=1, max_depth=2, bootstrap=False)\nm.fit(x_samp, y_samp)\ndraw_tree(m.estimators_[0], x_samp, precision=2)","dfbb1f71":"def find_varsplit(self):\n    for i in range(self.c): self.find_better_split(i)\n    if self.is_leaf: return\n    x = self.split_col\n    lhs = np.nonzero(x<=self.split)[0]\n    rhs = np.nonzero(x>self.split)[0]\n    self.lhs = DecisionTree(self.x, self.y, self.idxs[lhs])\n    self.rhs = DecisionTree(self.x, self.y, self.idxs[rhs])","2160adc6":"DecisionTree.find_varsplit = find_varsplit","7fecda85":"tree = TreeEnsemble(x_sub, y_train, 1, 1000).trees[0]; tree","f29793d2":"tree.lhs","1be6451d":"tree.rhs","98385541":"tree.lhs.lhs","9a0ed343":"tree.lhs.rhs","53105b0a":"cols = ['MachineID', 'YearMade', 'MachineHoursCurrentMeter', 'ProductSize', 'Enclosure',\n        'Coupler_System', 'saleYear']","ff1f53f6":"%time tree = TreeEnsemble(X_train[cols], y_train, 1, 1000).trees[0]\nx_samp,y_samp = tree.x, tree.y","080f691a":"m = RandomForestRegressor(n_estimators=1, max_depth=3, bootstrap=False)\nm.fit(x_samp, y_samp)\ndraw_tree(m.estimators_[0], x_samp, precision=2, ratio=0.9, size=7)","1124cc72":"def predict(self, x): return np.array([self.predict_row(xi) for xi in x])\nDecisionTree.predict = predict","3b2afa2e":"if something:\n    x= do1()\nelse:\n    x= do2()","69c304a1":"x = do1() if something else do2()","6c69c0a7":"x = something ? do1() : do2()","555553c7":"def predict_row(self, xi):\n    if self.is_leaf: return self.val\n    t = self.lhs if xi[self.var_idx]<=self.split else self.rhs\n    return t.predict_row(xi)\n\nDecisionTree.predict_row = predict_row","ac5c1bdc":"%time preds = tree.predict(X_valid[cols].values)","768efde2":"plt.scatter(preds, y_valid, alpha=0.05)","46fa665e":"metrics.r2_score(preds, y_valid)","a912dc13":"m = RandomForestRegressor(n_estimators=1, min_samples_leaf=5, bootstrap=False)\n%time m.fit(x_samp, y_samp)\npreds = m.predict(X_valid[cols].values)\nplt.scatter(preds, y_valid, alpha=0.05)","ac44b81f":"metrics.r2_score(preds, y_valid)","cc308915":"class TreeEnsemble():\n    def __init__(self, x, y, n_trees, sample_sz, min_leaf=5):\n        np.random.seed(42)\n        self.x,self.y,self.sample_sz,self.min_leaf = x,y,sample_sz,min_leaf\n        self.trees = [self.create_tree() for i in range(n_trees)]\n\n    def create_tree(self):\n        idxs = np.random.permutation(len(self.y))[:self.sample_sz]\n        return DecisionTree(self.x.iloc[idxs], self.y[idxs], \n                    idxs=np.array(range(self.sample_sz)), min_leaf=self.min_leaf)\n        \n    def predict(self, x):\n        return np.mean([t.predict(x) for t in self.trees], axis=0)\n\ndef std_agg(cnt, s1, s2): return math.sqrt((s2\/cnt) - (s1\/cnt)**2)","ef0581bc":"class DecisionTree():\n    def __init__(self, x, y, idxs, min_leaf=5):\n        self.x,self.y,self.idxs,self.min_leaf = x,y,idxs,min_leaf\n        self.n,self.c = len(idxs), x.shape[1]\n        self.val = np.mean(y[idxs])\n        self.score = float('inf')\n        self.find_varsplit()\n        \n    def find_varsplit(self):\n        for i in range(self.c): self.find_better_split(i)\n        if self.score == float('inf'): return\n        x = self.split_col\n        lhs = np.nonzero(x<=self.split)[0]\n        rhs = np.nonzero(x>self.split)[0]\n        self.lhs = DecisionTree(self.x, self.y, self.idxs[lhs])\n        self.rhs = DecisionTree(self.x, self.y, self.idxs[rhs])\n\n    def find_better_split(self, var_idx):\n        x,y = self.x.values[self.idxs,var_idx], self.y[self.idxs]\n        sort_idx = np.argsort(x)\n        sort_y,sort_x = y[sort_idx], x[sort_idx]\n        rhs_cnt,rhs_sum,rhs_sum2 = self.n, sort_y.sum(), (sort_y**2).sum()\n        lhs_cnt,lhs_sum,lhs_sum2 = 0,0.,0.\n\n        for i in range(0,self.n-self.min_leaf):\n            xi,yi = sort_x[i],sort_y[i]\n            lhs_cnt += 1; rhs_cnt -= 1\n            lhs_sum += yi; rhs_sum -= yi\n            lhs_sum2 += yi**2; rhs_sum2 -= yi**2\n            if i<self.min_leaf-1 or xi==sort_x[i+1]:\n                continue\n\n            lhs_std = std_agg(lhs_cnt, lhs_sum, lhs_sum2)\n            rhs_std = std_agg(rhs_cnt, rhs_sum, rhs_sum2)\n            curr_score = lhs_std*lhs_cnt + rhs_std*rhs_cnt\n            if curr_score<self.score: \n                self.var_idx,self.score,self.split = var_idx,curr_score,xi\n\n    @property\n    def split_name(self): return self.x.columns[self.var_idx]\n    \n    @property\n    def split_col(self): return self.x.values[self.idxs,self.var_idx]\n\n    @property\n    def is_leaf(self): return self.score == float('inf')\n    \n    def __repr__(self):\n        s = f'n: {self.n}; val:{self.val}'\n        if not self.is_leaf:\n            s += f'; score:{self.score}; split:{self.split}; var:{self.split_name}'\n        return s\n\n    def predict(self, x):\n        return np.array([self.predict_row(xi) for xi in x])\n\n    def predict_row(self, xi):\n        if self.is_leaf: return self.val\n        t = self.lhs if xi[self.var_idx]<=self.split else self.rhs\n        return t.predict_row(xi)","43938dc9":"ens = TreeEnsemble(X_train[cols], y_train, 5, 1000)","6889063d":"preds = ens.predict(X_valid[cols].values)","375f1f3c":"plt.scatter(y_valid, preds, alpha=0.1, s=6);","79bb08ff":"metrics.r2_score(y_valid, preds)","e1c6d09f":"%load_ext Cython","66b3d6f7":"def fib1(n):\n    a, b = 0, 1\n    while b < n:\n        a, b = b, a + b","f2cfebbb":"%%cython\ndef fib2(n):\n    a, b = 0, 1\n    while b < n:\n        a, b = b, a + b","6fdb1ce8":"%%cython\ndef fib3(int n):\n    cdef int b = 1\n    cdef int a = 0\n    cdef int t = 0\n    while b < n:\n        t = a\n        a = b\n        b = t + b","a1ffa6e1":"%timeit fib1(50)","b7210fa0":"%timeit fib2(50)","072975d6":"%timeit fib3(50)","95fcd305":"# Random Forest from scratch!","d19a9240":"### Find best split given variable","b3acb072":"## Full single tree","ee053f80":"## Predictions","7920d3e6":"This is a copy of lesson 3 notebook from fast.ai course Introduction to Machine Learning for Coders. It was modified in the data input only, so that i can run on Kaggle kernels.\n\nSource: https:\/\/github.com\/fastai\/fastai\/blob\/master\/courses\/ml1\/lesson3-rf_foundations.ipynb\n\nBased on notebook version: 4381b2d\n    \nCourse page: http:\/\/course.fast.ai\/ml.html","070f6534":"## Basic data structures","d87f2664":"## Load in our data from last lesson","0ac016f3":"# Putting it together","b7a8d277":"### Speeding things up","31f71192":"## Single branch"}}