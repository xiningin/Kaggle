{"cell_type":{"7ceabcc6":"code","e46c8e42":"code","5efe0719":"code","543482ba":"code","71edd72f":"code","d4c07680":"markdown","3bb158af":"markdown","6e8a5549":"markdown","09bdaa9b":"markdown"},"source":{"7ceabcc6":"#NO CCS used in Model\nimport numpy as np \nimport pandas as pd \nimport math\nimport matplotlib.pyplot as plt\nimport seaborn as sns","e46c8e42":"#data = pd.read_csv(\"INPUT FILE HERE AS .CSV\")\n\n","5efe0719":"def Plot_data_seaborn():\n    sns.set()\n    columns = ['UCS (psi)','WOB (lbf)','RPM','Db (inch)','BR','SR','Blade Count','ROP (ft\/hr)']\n    sns.pairplot(data[columns], size = 1.5 , kind ='scatter')\n    plt.show()\n\ndef Turn_data_to_seperate_lists():\n    UCS = data['UCS (psi)']\n    WOB = data['WOB (lbf)']\n    RPM = data['RPM']\n    Db = data['Db (inch)']\n    BR = data['BR']\n    SR = data['SR']\n    Nb = data['Blade Count']\n    ROP_Data  = data['ROP (ft\/hr)']\n    \n    return UCS, WOB, RPM, Db, BR, SR, Nb, ROP_Data\n    \n\ndef Kerkar_Model(UCS, WOB, RPM, Db, BR, SR, Nb, ROP_Data, w):\n    \n    Pe=0\n    \n    #if UCS is 28000:\n        #Pe = 0\n    #else:\n        #Pe = INSERT CONFINING PRESSURE HERE\n    \n    \n    #CCS = UCS*(1+w[4]*Pe**w[5]) #Not important if we do not have confining pressures\n    \n    IFA = 41\n    ROP = ((w[0]*WOB**w[1]*RPM**w[2]*math.cos(math.radians(SR))) \/ (Db*math.tan(math.radians(BR+IFA))))\n    \n    #print(CCS) #Use this to ensure output of CCS matches calculated CCS values\n    \n    return ROP\n\ndef Objective_Function(w):\n    \n    Error = 0\n    ROP_pred_list = []\n    ROP_pred_list = [Kerkar_Model(UCS, WOB, RPM, Db, BR, SR, Nb,ROP_Data, w) for UCS, WOB, RPM, Db, BR, SR, Nb, ROP_Data in zip(UCS, WOB, RPM, Db, BR, SR, Nb, ROP_Data)]\n    Error = [((abs(ROP_Data - ROP_pred))\/ROP_Data) for ROP_Data, ROP_pred in zip(ROP_Data, ROP_pred_list)] \n    Ave_Error = sum(Error) \/ len(ROP_Data)\n    return Ave_Error*100\n\n\ndef De_Algorithm(fobj, bounds, mut=0.8, crossp=0.7, popsize=100, its=1000):\n    dimensions = len(bounds)\n    pop = np.random.rand(popsize, dimensions)\n    min_b, max_b = np.asarray(bounds).T\n    diff = np.fabs(min_b - max_b)\n    pop_denorm = min_b + pop * diff\n    fitness = np.asarray([fobj(ind) for ind in pop_denorm])\n    best_idx = np.argmin(fitness)\n    best = pop_denorm[best_idx]\n    for i in range(its):\n        for j in range(popsize):\n            idxs = [idx for idx in range(popsize) if idx != j]\n            a, b, c = pop[np.random.choice(idxs, 3, replace = False)]\n            mutant = np.clip(a + mut * (b - c), 0, 1)\n            cross_points = np.random.rand(dimensions) < crossp\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, dimensions)] = True\n            trial = np.where(cross_points, mutant, pop[j])\n            trial_denorm = min_b + trial * diff\n            f = fobj(trial_denorm)\n            if f < fitness[j]:\n                fitness[j] = f\n                pop[j] = trial\n                if f < fitness[best_idx]:\n                    best_idx = j\n                    best = trial_denorm\n                    \n                    \n        #print(\"Iteration number= %s\" % (i))\n        print(\"Best Fitness= %s\" % (fitness[best_idx]))\n        #print(\"Best values= %s\" % (best))\n        yield best, fitness[best_idx]\n\ndef Run_DEA(ite):\n    results = []\n    result = list(De_Algorithm(Objective_Function, \n                 [(0, 0.0001),         #k1 OG 0.01\n                  (2.61, 2.61),         #a1  3\n                  (0.71, 0.71),      #b1  0.65 0.75\n                 # (0, 0),          #c1 0.65 1.25\n                # (0,0),            #as 0,0 | CM 0.00288,0.00288\n                 #(0,0)\n                 ],           #bs 0,0 | CM 0.673,0.673\n                  mut=0.7, crossp=0.8, popsize=15, its=ite))\n    \n    df = pd.DataFrame(result)\n    return results, df\n\n\ndef Best_coffs(df):\n    \n    df['w1'], df['w2'], df['w3'], = zip(*df[0]) # Unzip\n    cols = [0] # Drop the first column\n    df.drop(df.columns[cols],axis = 1,inplace = True) # Drop the first column\n    df.columns.values[0] = \"Fitness\" # name the first column as Fitness\n    best_coff = df.iloc[len(df)-1,1:] # insert the best coefficients into the best_coff\n    \n    return best_coff\n\ndef Plot_DEA_Evolution(df):\n    \n    data_ncol=len(df.columns) # number of paramters \n    fig = plt.figure(figsize=(15,15)) # you may change these to change the distance between plots.\n\n    for i in range(1,(data_ncol+1)):\n        if i<data_ncol:\n            plt.subplot(3, 3, i)\n            plt.plot(df['w{}'.format(i)],'bo', markersize=4)\n            plt.xlabel('Iteration')\n            plt.ylabel('w{}'.format(i))\n            plt.grid(True)\n        else:       \n            plt.subplot(3, 3, data_ncol)\n            plt.plot(df['Fitness'],'red', markersize=4)\n            plt.xlabel('Iteration')\n            plt.ylabel('Fitness')\n            plt.grid(True)\n    plt.show()\n\ndef Plot_variables(x, y, xlab, ylab, xmin, xmax, ymin, ymax):\n    \n    fig = plt.figure(figsize=(7,7))\n    plt.scatter(x, y)\n    plt.xlim(xmin,xmax)\n    plt.ylim(ymin,ymax)\n    plt.xlabel(xlab)\n    plt.ylabel(ylab)\n\n### Data visualization","543482ba":"UCS, WOB, RPM, Db, BR, SR, Nb, ROP_Data = Turn_data_to_seperate_lists()\nresults, df = Run_DEA(1500)\nbest_coff = Best_coffs(df)\nprint(best_coff)","71edd72f":"Plot_DEA_Evolution(df)","d4c07680":"### Define Functions and Models","3bb158af":"### Import libraries","6e8a5549":"### Run program","09bdaa9b":"### Data"}}