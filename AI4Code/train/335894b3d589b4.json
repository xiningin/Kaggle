{"cell_type":{"bd4f8751":"code","613556d8":"code","7a91d756":"code","f80f9ad8":"code","c89637d5":"code","997947ca":"code","06b40ff6":"code","13c9a002":"code","18889836":"code","e0398815":"code","c2bf0926":"code","291a8932":"code","1fc4fcef":"code","afff6132":"code","3cd68865":"code","71b988a0":"code","135bb797":"code","4a8d842d":"code","4c02ad41":"code","60cb5354":"code","a6616e87":"code","7ff6ea49":"code","8383a471":"code","6fee51db":"code","3bb2972e":"code","f6582810":"code","04ec1967":"code","ceb300ee":"code","200afda9":"code","5deaae7e":"code","45905174":"code","1b2cd817":"code","c14ee52d":"code","f5dabd4c":"code","2bcb4ee7":"code","64a885da":"code","9eefc647":"code","85ed6715":"code","f856125b":"code","b61f6fcd":"code","fb2a7d88":"code","b9b0803a":"code","8030a500":"code","9b8f4213":"code","0cc3eda4":"code","6e1bff84":"markdown","183f6e9e":"markdown","44aa7de7":"markdown","b285ce62":"markdown","4d563af6":"markdown","9b8f5e6f":"markdown","1b9f926b":"markdown","f84879d7":"markdown","0a727b07":"markdown","e4b460cb":"markdown","66235b66":"markdown","63190a45":"markdown","f7bfe977":"markdown","d0183322":"markdown","3a5c05f8":"markdown","af74c583":"markdown","3a55ed33":"markdown","cd546271":"markdown"},"source":{"bd4f8751":"import pandas as pd\nimport re\nfrom sklearn.ensemble import RandomForestRegressor, RandomForestClassifier\nfrom IPython.display import display\nimport numpy as np\nimport math\nfrom sklearn import metrics\nfrom pandas.api.types import is_string_dtype, is_numeric_dtype\nimport matplotlib.pyplot as plt \nfrom sklearn.ensemble import forest\nimport scipy\nfrom scipy.cluster import hierarchy as hc","613556d8":"def rmse(x,y): \n    return math.sqrt(((x-y)**2).mean())\n\ndef print_score(m):\n    res = [rmse(m.predict(X_train), y_train), rmse(m.predict(X_valid), y_valid),\n                m.score(X_train, y_train), m.score(X_valid, y_valid)]\n    if hasattr(m, 'oob_score_'): res.append(m.oob_score_)\n    print(res)\n\ndef split_vals(a,n): \n    return a[:n].copy(), a[n:].copy()\n\ndef get_oob(df):\n    m = RandomForestRegressor(n_estimators=40, max_features=0.6, n_jobs=-1, oob_score=True)\n    x, _ = split_vals(df, n_trn)\n    m.fit(x, y_train)\n    return m.oob_score_\n\ndef add_datepart(df, fldname, drop=True, time=False):\n    fld = df[fldname]\n    fld_dtype = fld.dtype\n    if isinstance(fld_dtype, pd.core.dtypes.dtypes.DatetimeTZDtype):\n        fld_dtype = np.datetime64\n\n    if not np.issubdtype(fld_dtype, np.datetime64):\n        df[fldname] = fld = pd.to_datetime(fld, infer_datetime_format=True)\n    targ_pre = re.sub('[Dd]ate$', '', fldname)\n    attr = ['Year', 'Month', 'Week', 'Day', 'Dayofweek', 'Dayofyear',\n            'Is_month_end', 'Is_month_start', 'Is_quarter_end', 'Is_quarter_start', 'Is_year_end', 'Is_year_start']\n    if time: attr = attr + ['Hour', 'Minute', 'Second']\n    for n in attr: df[targ_pre + n] = getattr(fld.dt, n.lower())\n    df[targ_pre + 'Elapsed'] = fld.astype(np.int64) \/\/ 10 ** 9\n    if drop: df.drop(fldname, axis=1, inplace=True)\n        \ndef train_cats(df):\n    for n,c in df.items():\n        if is_string_dtype(c): df[n] = c.astype('category').cat.as_ordered()\n\ndef fix_missing(df, col, name, na_dict):\n    if is_numeric_dtype(col):\n        if pd.isnull(col).sum() or (name in na_dict):\n            df[name+'_na'] = pd.isnull(col)\n            filler = na_dict[name] if name in na_dict else col.median()\n            df[name] = col.fillna(filler)\n            na_dict[name] = filler\n    return na_dict\n\ndef proc_df(df, y_fld=None, skip_flds=None, ignore_flds=None, do_scale=False, na_dict=None,\n            preproc_fn=None, max_n_cat=None, subset=None, mapper=None):\n    if not ignore_flds: ignore_flds=[]\n    if not skip_flds: skip_flds=[]\n    if subset: df = get_sample(df,subset)\n    else: df = df.copy()\n    ignored_flds = df.loc[:, ignore_flds]\n    df.drop(ignore_flds, axis=1, inplace=True)\n    if preproc_fn: preproc_fn(df)\n    if y_fld is None: y = None\n    else:\n        if not is_numeric_dtype(df[y_fld]): df[y_fld] = df[y_fld].cat.codes\n        y = df[y_fld].values\n        skip_flds += [y_fld]\n    df.drop(skip_flds, axis=1, inplace=True)\n\n    if na_dict is None: na_dict = {}\n    else: na_dict = na_dict.copy()\n    na_dict_initial = na_dict.copy()\n    for n,c in df.items(): na_dict = fix_missing(df, c, n, na_dict)\n    if len(na_dict_initial.keys()) > 0:\n        df.drop([a + '_na' for a in list(set(na_dict.keys()) - set(na_dict_initial.keys()))], axis=1, inplace=True)\n    if do_scale: mapper = scale_vars(df, mapper)\n    for n,c in df.items(): numericalize(df, c, n, max_n_cat)\n    df = pd.get_dummies(df, dummy_na=True)\n    df = pd.concat([ignored_flds, df], axis=1)\n    res = [df, y, na_dict]\n    if do_scale: res = res + [mapper]\n    return res\n\ndef numericalize(df, col, name, max_n_cat):\n    if not is_numeric_dtype(col) and ( max_n_cat is None or col.nunique()>max_n_cat):\n        df[name] = col.cat.codes+1","7a91d756":"df_raw = pd.read_csv('..\/input\/bulldozer-training-dataset\/Train.csv', low_memory=False, parse_dates=['saledate'])","f80f9ad8":"df_raw.head()","c89637d5":"#Change SalePrice to log because the evaluation is for RMSLE\ndf_raw.SalePrice = np.log(df_raw.SalePrice)\n#Change dates to date parts\nadd_datepart(df_raw, 'saledate')\n#Add a column for age of bulldozer\ndf_raw['age'] = df_raw['saleYear'] - df_raw['YearMade'] ","997947ca":"#Change string variables to category type\ntrain_cats(df_raw)\n#Specify order for variable UsageBand and change to codes\ndf_raw.UsageBand.cat.set_categories(['High', 'Medium', 'Low'], ordered=True, inplace=True)\ndf_raw.UsageBand = df_raw.UsageBand.cat.codes\n#Change categories to code and missing values to 0, replace missing numeric values with median, \n#add column to indicate replaced missing values and separate the dependent variable as a separate df\ndf, y, nas = proc_df(df_raw, 'SalePrice')","06b40ff6":"df.head()","13c9a002":"df.shape","18889836":"#Split the dataset into training and validation sets. Use 12,000 as the validation set\n\nn_valid = 12000  # same as Kaggle's test set size\nn_trn = len(df)-n_valid\nraw_train, raw_valid = split_vals(df_raw, n_trn) #for using unprocessed data if needed.\nX_train, X_valid = split_vals(df, n_trn)\ny_train, y_valid = split_vals(y, n_trn)","e0398815":"X_train.shape, X_valid.shape, y_train.shape, y_valid.shape","c2bf0926":"#Run base model\nm = RandomForestRegressor(n_jobs=-1)\nm.fit(X_train, y_train)\nprint_score(m);","291a8932":"#Use the feature importance to find the most important ones\nfeature_importance = pd.DataFrame({'Feature' : X_train.columns, 'Importance' : m.feature_importances_})\nfeature_importance.sort_values('Importance', ascending=False, inplace=True)\nfeature_importance.head(30)","1fc4fcef":"feature_importance.plot('Feature', 'Importance')","afff6132":"# Run the model for various cut off values for the importance to find the best set of importance features\nfor i in [0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009, 0.010, 0.011, 0.012]:\n    important_features = feature_importance[feature_importance['Importance'] > i]\n    df_important = df[important_features['Feature']]\n    X_train, X_valid = split_vals(df_important, n_trn)\n    y_train, y_valid = split_vals(y, n_trn)\n\n    m = RandomForestRegressor(n_estimators=40, max_features=0.5, n_jobs=-1, oob_score=True)\n    m.fit(X_train, y_train)\n    print_score(m)\n","3cd68865":"#The best cut off point seems to be 0.0.006 when the RMSE score is 0.22312856564640468.\nimportant_features = feature_importance[feature_importance['Importance'] > 0.006]\ndf_important = df[important_features['Feature']]\nX_train, X_valid = split_vals(df_important, n_trn)\ny_train, y_valid = split_vals(y, n_trn)\n\nm = RandomForestRegressor(n_estimators=40, max_features=0.5, n_jobs=-1, oob_score=True)\nm.fit(X_train, y_train)\nprint_score(m)\n","71b988a0":"#Detect and remove redundant features\n#Draw dendogram of feature clusters\ncorr = np.round(scipy.stats.spearmanr(df_important).correlation, 4)\ncorr_condensed = hc.distance.squareform(1-corr)\nz = hc.linkage(corr_condensed, method='average')\nfig = plt.figure(figsize=(16,10))\ndendrogram = hc.dendrogram(z, labels=df_important.columns, orientation='left', leaf_font_size=16)\nplt.show()\n","135bb797":"#These feature pairs are in the same cluster'\ncluster_pairs = ['saleDayofyear', 'state', 'Drive_System', 'fiSecondaryDesc', 'MachineID', 'ModelID', 'saleElapsed', 'YearMade', 'Enclosure', 'Coupler_System', 'fiModelDescriptor', 'ProductSize','fiBaseModel', 'fiModelDesc']\n#Base OOB score\nget_oob(df_important)","4a8d842d":"#Get the OOB score after dropping each of the variables in the cluster pairs\nfor c in cluster_pairs:\n    print(c, get_oob(df_important.drop(c, axis=1)))\n","4c02ad41":"#For each pair select the attribute which impacts the score less (score is higher) and remove it and calculate OOB\nto_drop = ['state', 'Drive_System', 'MachineID', 'Coupler_System', 'fiModelDescriptor','fiModelDesc']\nget_oob(df_important.drop(to_drop, axis=1))\n","60cb5354":"#OOB score has decreased slightly after removing attributes but model has become simpler.\n#Run the random forest on the dataset after dropping the columns\ndf_keep = df_important.drop(to_drop, axis=1)\nX_train, X_valid = split_vals(df_keep, n_trn)\nm = RandomForestRegressor(n_estimators=40, max_features=0.5, n_jobs=-1, oob_score=True)\nm.fit(X_train, y_train)\nprint_score(m)\n","a6616e87":"df_keep.columns","7ff6ea49":"#Remove time related features to generalize the model more\n#Label the validation and training set and calculate the OOB score\ndf_ext = df_keep.copy()\ndf_ext['is_valid'] = 1\ndf_ext.is_valid[:n_trn] = 0\nx, y, nas = proc_df(df_ext, 'is_valid')\n\nm = RandomForestClassifier(n_estimators=40, max_features=0.5, n_jobs=-1, oob_score=True)\nm.fit(x, y);\nm.oob_score_\n","8383a471":"#Very high OOB score\n#Find the important features, i.e. the features which help rf predict the validation and training sets\nfeature_importance_ext = pd.DataFrame({'Feature' : x.columns, 'Importance' : m.feature_importances_})\nfeature_importance_ext.sort_values('Importance', ascending=False, inplace=True)\nfeature_importance_ext.head(30)\n","6fee51db":"#Drop the top 1 and see if the RMSe improves\nto_drop = ['SalesID']\ndf_keep = df_important.drop(to_drop, axis=1)\nX_train, X_valid = split_vals(df_keep, n_trn)\nm = RandomForestRegressor(n_estimators=40, max_features=0.5, n_jobs=-1, oob_score=True)\nm.fit(X_train, y_train)\nprint_score(m)\n","3bb2972e":"#Run the final model\nm = RandomForestRegressor(n_estimators=160, max_features=0.5, n_jobs=-1, oob_score=True)\nm.fit(X_train, y_train)\nprint_score(m)\n","f6582810":"#Import data\ndf_raw = pd.read_csv('..\/input\/bulldozer-training-dataset\/Train.csv', low_memory=False, parse_dates=['saledate'])\ndf_validation = pd.read_csv('..\/input\/bluebook-for-bulldozers\/Valid.csv', low_memory=False, parse_dates=['saledate'])\n","04ec1967":"print('training shape',df_raw.shape)\nprint('validation shape', df_validation.shape)\nprint('difference between training and validaiton', set(df_raw.columns) - set(df_validation.columns))","ceb300ee":"#Separate out the SalePrice as y and change it to log and drop it from the training set\ny = np.log(df_raw['SalePrice'])\ndf_raw = df_raw.drop('SalePrice', axis=1)","200afda9":"#Append the validation set to the training set\ndf_train_valid = df_raw.append(df_validation)\n","5deaae7e":"df_train_valid.shape","45905174":"#Change dates to date parts\nadd_datepart(df_train_valid, 'saledate')","1b2cd817":"#Add a column for age of bulldozer\ndf_train_valid['age'] = df_train_valid['saleYear'] - df_train_valid['YearMade'] \n","c14ee52d":"#Change string variables to category type\ntrain_cats(df_train_valid)\n","f5dabd4c":"#Specify order for variable UsageBand and change to codes\ndf_train_valid.UsageBand.cat.set_categories(['High', 'Medium', 'Low'], ordered=True, inplace=True)\ndf_train_valid.UsageBand = df_train_valid.UsageBand.cat.codes\n","2bcb4ee7":"#Change other categories into codes and replace NaNs with 0.\ncat_cols = list(df_train_valid.select_dtypes(include=['category']).columns)  #Above UsageType is changed to Int \nfor col in cat_cols:\n    s = df_train_valid[col] \n    df_train_valid[col] = s.cat.codes+1","64a885da":"#Replace the NaNs for the numerical column with mean\ndf_train_valid['auctioneerID'].fillna(df_train_valid['auctioneerID'].median(), inplace=True)\ndf_train_valid['MachineHoursCurrentMeter'].fillna(df_train_valid['MachineHoursCurrentMeter'].median(), inplace=True)","9eefc647":"#Check if df has NaNs\ndf_train_valid.isnull().sum()","85ed6715":"df_train_valid.head()","f856125b":"df_train_valid.shape","b61f6fcd":"# These were the columns in the final model\ndf_keep.columns","fb2a7d88":"#Choose only columns which were used in the final model\ndf_train_valid = df_train_valid[df_keep.columns]\n\n#Separate the training and validation sets\ndf_valid = df_train_valid.tail(11573)\ndf_train = df_train_valid.head(401125)\n","b9b0803a":"print(df_valid.shape)\nprint(df_train.shape)","8030a500":"#Train the model on training set and dependent variable using out final model\nm = RandomForestRegressor(n_estimators=160, max_features=0.5, n_jobs=-1, oob_score=True)\nm.fit(df_train, y) ","9b8f4213":"#Import the validation solution\nsolution = pd.read_csv('..\/input\/bluebook-for-bulldozers\/ValidSolution.csv', low_memory=False)\ny_actual = np.log(solution.SalePrice)     ","0cc3eda4":"#Calculate the RMSE using the prediction from the validation set and the actual provided by Kaggle in the file 'ValidSolutions.csv'\nrmse(m.predict(df_valid), y_actual)","6e1bff84":"#### Feature importance","183f6e9e":"This model is pretty good and we are already in the top 25% of the leaderboard!","44aa7de7":"#### Run the base model","b285ce62":"The pre-processed dataset is ready.  Now need to choose only columns which were in our final model and run the model.","4d563af6":"#### Dataset import and pre-processing","9b8f5e6f":"Now lets train the model on the full training dataset and check the score on the validation set provided by Kaggle.\n\nTo get the same set of category codes and uniformly imputing missing values, we are joining the training and validation sets and pre-processing them together. After preprocessing we will separate them again","1b9f926b":"Import necessary packages","f84879d7":"This notebook is mostly created using the steps explained in the excellent Machine Learning course by Jeremy Howard and developed by Jeremy Howard and Rachel Thomas.  The courses are available at http:\/\/www.fast.ai\/\n\nThe idea behind this notebook is to take the reader step by step of how to use RandomForest in any competition.  I have tried to clarify some aspects for a beginner and give reasons for some decision taken.\n\nThe high levels steps are as follows\n1. Create the best model possible using only the training set (Train.csv)\n    - Pre-process the training dataset and change all categories to codes, impute missing values and add some variables.\n    - Split the dataset into training and validation sets (validation set being nearly the same size as the Kaggle provided   validation set. \n    - Separate the dependent variable.\n    - Create the base model using all variables.\n    - From the base model, find out the most important features and remove all unimportant features from the dataset.\n    - Run the model again using only important features.\n    - Detect and remove redundant features\n    - Remove features which have a temporal sequence to make the model more general\n2. Train the model on the whole training set\n    - Run randomforest with a large number of entimators and finetuned paramters on the whole Kaggle provided training dataset.\n    - This is the final model.\n3. Apply the model on validation set (Valid.csv) and predict the SalePrice\n    - Combine the Kaggle provided training and validation sets and pre-process the data.\n    - Separate the datasets into training and validation and fit the above created model using the training data.\n    - Predict the dependent variable using this fitted model.\n4. Calculate the RMSLE using the actual SalePrice in the training set and the predicted SalePrice.\n\nNotes:\n1. I could not import the 'fastai' package into a Windows 10 environment and hence have included the 'fastai' functions I used in the notebook.\n2. To run the notebook, the path to the dataset needs to be provided.\n3. Further optimization of the model is possible by using the Machine_Appendix.csv which contains a more accurate year of manufacture and some more attributes.\n4. Jeremy Howard also suggested using one-hot encoding of some variables.  This has not been included here.\n5. The course by Jeremy stops at finding the RMSE score using a validation set derived from the training set.  I have used the actual validation set provided by Kaggle to calculate the final RMSE.  This is what Kaggle would do if you submit your preductions.","0a727b07":"#### Run model on actual validaiton set","e4b460cb":"#### Feature Engineering","66235b66":"There is a slight improvement.","63190a45":"That's it! Further fine tuning can be done by selecting a differnt combinations of features and perhaps replacing YearMade with the corrected data.  I leave to the reader to do these and better the score above.  \nHope this notebook helped!","f7bfe977":"Just to be sure, check the column names and columns in the Training and validation sets.  ","d0183322":"The final model looks pretty good and the RMSE decreased from to 0.21570860916579637, mainly due to feature selection and fine tuning parameters.\n\nWhat we have essentially done in the previous steps is to fine tune the hyper parameters and select the subset of features which gives the best score and generalizes the model the best. So the best model is RandomForestRegressor(n_estimators=160, max_features=0.5, n_jobs=-1, oob_score=True) and the features to use are df_keep.columns","3a5c05f8":"#### Compile necessary fastai functions","af74c583":"### Blue Book for Bulldozer - Kaggle Competition","3a55ed33":"#### Environment Setup","cd546271":"Various methods are used to remove unimportant and redundant features.  This not only simplifies the model but also improves the scores."}}