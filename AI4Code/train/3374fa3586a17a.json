{"cell_type":{"8187ccd1":"code","f0999d8f":"code","21b5c49c":"code","337e0d5e":"code","ea9416b6":"code","232f57ba":"code","1db37d19":"code","7dc8e21a":"code","c324697e":"code","fb4174a8":"code","bf15d95c":"code","1543d3e6":"code","b8e62ad7":"code","54510247":"code","bb3fbf4c":"code","b41af6b2":"markdown","8a87246d":"markdown","1009a590":"markdown","144541e7":"markdown","f67fb20a":"markdown","a8b087e7":"markdown","b3d9192e":"markdown"},"source":{"8187ccd1":"!pip install -q efficientnet","f0999d8f":"%%capture\n!pip install wandb","21b5c49c":"# Asthetics\n\nimport warnings\nimport sklearn.exceptions\nwarnings.filterwarnings('ignore', category=DeprecationWarning)\nwarnings.filterwarnings('ignore', category=FutureWarning)\nwarnings.filterwarnings(\"ignore\", category=sklearn.exceptions.UndefinedMetricWarning)\n\n# General\nfrom kaggle_datasets import KaggleDatasets\nfrom glob import glob\nimport pandas as pd\nimport numpy as np\nimport os\nimport time\nimport cv2\nimport random\nimport shutil\nimport math\nimport re\npd.set_option('display.max_columns', None)\n\n# Visualizations\nfrom PIL import Image\nfrom plotly.subplots import make_subplots\nfrom plotly.offline import iplot\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport cv2\nimport wandb\nimport plotly.graph_objs as go\nimport plotly.figure_factory as ff\nimport plotly.express as px\n%matplotlib inline\nsns.set(style=\"whitegrid\")\n\n# Machine Learning\n# Pre Procesing\nfrom sklearn.preprocessing import LabelEncoder, OneHotEncoder\n# Models\nfrom sklearn.model_selection import train_test_split, KFold\n# Deep Learning\nimport tensorflow as tf\nimport tensorflow.keras.backend as K\nimport efficientnet.tfkeras as efn\nfrom wandb.keras import WandbCallback\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.applications import EfficientNetB4\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, Activation, BatchNormalization, GlobalAveragePooling2D\nfrom tensorflow.keras.callbacks import TensorBoard, EarlyStopping, ReduceLROnPlateau, ModelCheckpoint\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.losses import CategoricalCrossentropy\nimport tensorflow_addons as tfa\nfrom tensorflow_addons.metrics import F1Score, FBetaScore\nfrom tensorflow_addons.callbacks import TQDMProgressBar\nfrom tensorflow.keras.utils import plot_model\n\n#Metrics\nfrom sklearn.metrics import confusion_matrix, classification_report, roc_auc_score\n\nprint('TF',tf.__version__)\n\n# Random Seed Fixing\nRANDOM_SEED = 42\n\ndef seed_everything(seed=RANDOM_SEED):\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    random.seed(seed)\n    tf.random.set_seed(seed)\n\nseed_everything()","337e0d5e":"# From https:\/\/www.kaggle.com\/xhlulu\/ranzcr-efficientnet-tpu-training\ndef auto_select_accelerator():\n    TPU_DETECTED = False\n    try:\n        tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n        tf.config.experimental_connect_to_cluster(tpu)\n        tf.tpu.experimental.initialize_tpu_system(tpu)\n        strategy = tf.distribute.experimental.TPUStrategy(tpu)\n        print(\"Running on TPU:\", tpu.master())\n        TPU_DETECTED =True\n    except ValueError:\n        strategy = tf.distribute.get_strategy()\n    print(f\"Running on {strategy.num_replicas_in_sync} replicas\")\n    \n    return strategy, TPU_DETECTED","ea9416b6":"strategy, TPU_DETECTED = auto_select_accelerator()\nAUTO = tf.data.experimental.AUTOTUNE\nREPLICAS = strategy.num_replicas_in_sync","232f57ba":"CFG = {\n    'version': 0,\n    'feature_name': 'cqt',\n    'fold': 0,\n    'EFFV': 1,\n    'size': 256,\n    'dropout': 0.2,\n    'label_smoothing': 0.,\n    'batch_size': 64,\n    'steps_multiplier': 0.25,\n    'epochs': 30,\n    'aug': True,\n    'MIX_UP_P': 0.2,\n    'S_SHIFT': 0.,\n    'T_SHIFT': 0.,\n    'R_ANGLE': 0. \/ 180 * np.pi,\n    'opt': 'AdamW',\n    'lr': 1e-3,\n    'lr_start': 1e-4,\n    'lr_max': 0.000015 * REPLICAS * 64,\n    'lr_min': 1e-5,\n    'lr_ramp_ep': 3,\n    'lr_sus_ep': 0,\n    'lr_decay': 0.7\n}","1db37d19":"from tqdm.notebook import tqdm\n\nfiles_train_g = []\nfor i,k in tqdm([(0, 1), (2, 3), (4,5), (6, 7), (8, 9) ,(10,11), (12, 13), (14, 15)]):\n    GCS_PATH = KaggleDatasets().get_gcs_path(f'cqt-g2net-v2-{i}-{k}')\n    files_train_g.extend(np.sort(np.array(tf.io.gfile.glob(GCS_PATH + '\/train*.tfrec'))).tolist())\nnum_train_files = len(files_train_g)\nprint('train_files:',num_train_files)","7dc8e21a":"\ndef mixup(image, label, PROBABILITY = 1.0, AUG_BATCH=CFG['batch_size'] * REPLICAS):\n    # input image - is a batch of images of size [n,dim,dim,3] not a single image of [dim,dim,3]\n    # output - a batch of images with mixup applied\n    DIM = CFG['size']\n    \n    imgs = []; labs = []\n    for j in range(AUG_BATCH):\n        # DO MIXUP WITH PROBABILITY DEFINED ABOVE\n        P = tf.cast( tf.random.uniform([],0,1)<=PROBABILITY, tf.float32)\n        # CHOOSE RANDOM\n        k = tf.cast( tf.random.uniform([],0,AUG_BATCH),tf.int32)\n        a = tf.random.uniform([],0,1)*P # this is beta dist with alpha=1.0\n        # MAKE MIXUP IMAGE\n        img1 = image[j,]\n        img2 = image[k,]\n        imgs.append((1-a)*img1 + a*img2)\n        # MAKE CUTMIX LABEL\n        lab1 = label[j,]\n        lab2 = label[k,]\n        labs.append((1-a)*lab1 + a*lab2)\n            \n    # RESHAPE HACK SO TPU COMPILER KNOWS SHAPE OF OUTPUT TENSOR (maybe use Python typing instead?)\n    image2 = tf.reshape(tf.stack(imgs),(AUG_BATCH,DIM,DIM,3))\n    label2 = tf.reshape(tf.stack(labs),(AUG_BATCH, 1))\n    return image2,label2\n\ndef time_shift(img, shift=CFG['T_SHIFT']):\n    if shift > 0:\n        T = CFG['size']\n        P = tf.random.uniform([],0,1)\n        SHIFT = tf.cast(T * P, tf.int32)\n        return tf.concat([img[-SHIFT:], img[:-SHIFT]], axis=0)\n    return img\n\n\ndef spector_shift(img, shift=CFG['S_SHIFT']):\n    if shift > 0:\n        T = CFG['size']\n        P = tf.random.uniform([],0,1)\n        SHIFT = tf.cast(T * P, tf.int32)\n        return tf.concat([img[:, -SHIFT:], img[:, :-SHIFT]], axis=1)\n    return img\n\ndef rotate(img, angle=CFG['R_ANGLE']):\n    if angle > 0:\n        P = tf.random.uniform([],0,1)\n        A = tf.cast(angle * P, tf.float32)\n        return tfa.image.rotate(img, A)\n    return img\n    \ndef img_aug_f(img):\n    img = time_shift(img)\n    img = spector_shift(img)\n    img = rotate(img)\n    return img\n\ndef imgs_aug_f(imgs, batch_size):\n    _imgs = []\n    DIM = CFG['size']\n    for j in range(batch_size):\n        _imgs.append(img_aug_f(imgs[j]))\n    return tf.reshape(tf.stack(_imgs),(batch_size,DIM,DIM,3))\n\ndef aug_f(imgs, labels, batch_size):\n    imgs, label = mixup(imgs, labels, CFG['MIX_UP_P'], batch_size)\n    imgs = imgs_aug_f(imgs, batch_size)\n    return imgs, labels\n\ndef read_labeled_tfrecord(example):\n    tfrec_format = {\n        'image'                        : tf.io.FixedLenFeature([], tf.string),\n        'image_id'                     : tf.io.FixedLenFeature([], tf.string),\n        'target'                       : tf.io.FixedLenFeature([], tf.int64)\n    }           \n    example = tf.io.parse_single_example(example, tfrec_format)\n    label = tf.cast(example['target'], tf.float32)\n    return prepare_image(example['image']), label\n\n\ndef read_unlabeled_tfrecord(example, return_image_id):\n    tfrec_format = {\n        'image'                        : tf.io.FixedLenFeature([], tf.string),\n        'image_id'                     : tf.io.FixedLenFeature([], tf.string),\n    }\n    example = tf.io.parse_single_example(example, tfrec_format)\n    return prepare_image(example['image']), example['image_id'] if return_image_id else 0\n\n \ndef prepare_image(img, dim=CFG['size']):    \n    img = tf.image.resize(tf.image.decode_png(img, channels=3), size=(dim, dim))\n    img = tf.cast(img, tf.float32) \/ 255.0\n    img = tf.reshape(img, [dim,dim, 3])\n            \n    return img\n\ndef count_data_items(fileids):\n    n = [int(re.compile(r\"-([0-9]*)\\.\").search(fileid).group(1)) \n         for fileid in fileids]\n    return np.sum(n)","c324697e":"def get_dataset(files, shuffle = False, repeat = False, \n                labeled=True, return_image_ids=True, batch_size=16, dim=CFG['size'], aug=False):\n    \n    ds = tf.data.TFRecordDataset(files, num_parallel_reads=AUTO)\n    ds = ds.cache()\n    \n    if repeat:\n        ds = ds.repeat()\n    \n    if shuffle: \n        ds = ds.shuffle(1024*2)\n        opt = tf.data.Options()\n        opt.experimental_deterministic = False\n        ds = ds.with_options(opt)\n        \n    if labeled: \n        ds = ds.map(read_labeled_tfrecord, num_parallel_calls=AUTO)\n    else:\n        ds = ds.map(lambda example: read_unlabeled_tfrecord(example, return_image_ids), \n                    num_parallel_calls=AUTO)      \n    \n    ds = ds.batch(batch_size * REPLICAS)\n    if aug:\n        ds = ds.map(lambda x, y: aug_f(x, y, batch_size * REPLICAS), num_parallel_calls=AUTO)\n    ds = ds.prefetch(AUTO)\n    return ds","fb4174a8":"import tensorflow as tf\nimport math\n\n\nclass AngularGrad(tf.keras.optimizers.Optimizer):\n    def __init__(\n          self,\n          method_angle: str = \"cos\",\n          learning_rate=1e-3,\n          beta_1=0.9,\n          beta_2=0.999,\n          eps=1e-7,\n          name: str = \"AngularGrad\",\n          **kwargs,\n      ):\n        super().__init__(name, **kwargs)\n\n        self.method_angle = method_angle\n        self._set_hyper(\"learning_rate\", kwargs.get(\"lr\", learning_rate))\n        self._set_hyper(\"beta_1\", beta_1)\n        self._set_hyper(\"beta_2\", beta_2)\n        self._set_hyper(\"eps\", eps)\n        self.eps = eps or tf.keras.backend.epsilon()\n\n    def _create_slots(self, var_list):\n        for var in var_list:\n            self.add_slot(var, \"exp_avg\")\n            self.add_slot(var, \"exp_avg_sq\")\n            self.add_slot(var, \"previous_grad\")\n            self.add_slot(var, \"min\", initializer=tf.keras.initializers.Constant(value=math.pi \/ 2))\n            self.add_slot(var, \"final_angle_function_theta\")\n\n    def _resource_apply_dense(self, grad, var):\n        var_dtype = var.dtype.base_dtype\n\n        lr = self._get_hyper(\"learning_rate\", var_dtype)\n        beta_1 = self._get_hyper(\"beta_1\", var_dtype)\n        beta_2 = self._get_hyper(\"beta_2\", var_dtype)\n        eps = self._get_hyper(\"eps\", var_dtype)\n\n        exp_avg = self.get_slot(var, \"exp_avg\")\n        exp_avg_sq = self.get_slot(var, \"exp_avg_sq\")\n        previous_grad = self.get_slot(var, \"previous_grad\")\n        min = self.get_slot(var, \"min\")\n        final_angle_function_theta = self.get_slot(var, \"final_angle_function_theta\")\n\n        step = tf.cast(self.iterations + 1, var_dtype)\n        beta_1_power = tf.pow(beta_1, step)\n        beta_2_power = tf.pow(beta_2, step)\n\n        new_exp_avg = exp_avg.assign(\n            beta_1 * exp_avg + (1.0 - beta_1) * grad,\n            use_locking=self._use_locking\n        )\n        exp_avg_corrected = new_exp_avg \/ (1.0 - beta_1_power)\n\n        new_exp_avg_sq = exp_avg_sq.assign(\n            beta_2 * exp_avg_sq + (1.0 - beta_2) * tf.square(grad),\n            use_locking=self._use_locking,\n        )\n        exp_avg_sq_corrected = new_exp_avg_sq \/ (1.0 - beta_2_power)\n\n        tan_theta = tf.abs((previous_grad - grad) \/ (1 + previous_grad * grad))\n        cos_theta = 1 \/ tf.sqrt(1 + tf.square(tan_theta))\n\n        angle = tf.atan(tan_theta) * (180 \/ math.pi)\n        ans = tf.greater(angle, min)\n        mean_ans = tf.reduce_mean(tf.cast(ans, tf.float32))\n\n        def true_fn():\n            new_min = min.assign(angle, use_locking=self._use_locking)\n            new_final_angle_function_theta = final_angle_function_theta.assign(\n            tf.identity(tan_theta if self.method_angle == \"tan\" else cos_theta),\n              use_locking=self._use_locking\n              )\n            return new_min, new_final_angle_function_theta\n\n        def false_fn():\n            return min, final_angle_function_theta\n\n        new_min, new_final_angle_function_theta = tf.cond(tf.less(mean_ans, 0.5), true_fn, false_fn)\n        angular_coeff = tf.tanh(tf.abs(final_angle_function_theta)) * 0.5 + 0.5\n\n        var_update = var.assign_sub(\n            lr * exp_avg_corrected * angular_coeff \/ (tf.sqrt(exp_avg_sq_corrected) + eps),\n            use_locking=self._use_locking\n        )\n\n        new_previous_grad = previous_grad.assign(grad, use_locking=self._use_locking)\n\n        updates = [var_update, new_exp_avg, new_exp_avg_sq, new_min, new_previous_grad, new_final_angle_function_theta]\n        return tf.group(*updates)\n\n    def _resource_apply_sparse(self, grad, var, indices):\n        raise NotImplementedError\n\n    def get_config(self):\n        config = super().get_config()\n        config.update(\n            {\n                \"learning_rate\": self._serialize_hyperparameter(\"learning_rate\"),\n                \"beta_1\": self._serialize_hyperparameter(\"beta_1\"),\n                \"beta_2\": self._serialize_hyperparameter(\"beta_2\"),\n                \"eps\": self._serialize_hyperparameter(\"eps\")\n            }\n        )\n        return config","bf15d95c":"EFNS = [efn.EfficientNetB0, efn.EfficientNetB1, efn.EfficientNetB2, efn.EfficientNetB3, \n        efn.EfficientNetB4, efn.EfficientNetB5, efn.EfficientNetB6, efn.EfficientNetB7]\n\ndef build_model(config, count=820):\n    inp = tf.keras.layers.Input(shape=(config['size'], config['size'],3))\n    base = EFNS[config['EFFV']](input_shape=(config['size'],config['size'],3),weights='imagenet',include_top=False)\n    \n    x = base(inp)\n    \n    x = tf.keras.layers.GlobalAvgPool2D()(x)\n    x = tf.keras.layers.Dropout(config['dropout'])(x)\n    x = tf.keras.layers.Dense(1, activation='sigmoid')(x)\n    model = tf.keras.Model(inputs=inp, outputs=x)\n\n    if config['opt'] == 'AngularGrad':\n        opt = AngularGrad(config['lr'])\n    else:\n        lr_decayed_fn = tf.keras.experimental.CosineDecay(\n                              config['lr'],\n                              count,\n        )\n\n        opt = tfa.optimizers.AdamW(lr_decayed_fn, learning_rate=config['lr'])\n    loss = tf.keras.losses.BinaryCrossentropy(label_smoothing=config['label_smoothing']) \n    model.compile(optimizer=opt,loss=loss,metrics=['AUC'])\n    return model","1543d3e6":"def vis_lr_callback(config=CFG):\n    lr_start   = config['lr_start']\n    lr_max     = config['lr_max']\n    lr_min     = config['lr_min']\n    lr_ramp_ep = config['lr_ramp_ep']\n    lr_sus_ep  = config['lr_sus_ep']\n    lr_decay   = config['lr_decay']\n   \n    def lrfn(epoch):\n        if epoch < lr_ramp_ep:\n            lr = (lr_max - lr_start) \/ lr_ramp_ep * epoch + lr_start\n            \n        elif epoch < lr_ramp_ep + lr_sus_ep:\n            lr = lr_max\n            \n        else:\n            lr = (lr_max - lr_min) * lr_decay**(epoch - lr_ramp_ep - lr_sus_ep) + lr_min\n            \n        return lr\n    plt.figure(figsize=(10, 7))\n    plt.plot([lrfn(i) for i in range(config['epochs'])])\n    plt.show()","b8e62ad7":"def get_lr_callback(config=CFG):\n    lr_start   = config['lr_start']\n    lr_max     = config['lr_max']\n    lr_min     = config['lr_min']\n    lr_ramp_ep = config['lr_ramp_ep']\n    lr_sus_ep  = config['lr_sus_ep']\n    lr_decay   = config['lr_decay']\n   \n    def lrfn(epoch):\n        if epoch < lr_ramp_ep:\n            lr = (lr_max - lr_start) \/ lr_ramp_ep * epoch + lr_start\n            \n        elif epoch < lr_ramp_ep + lr_sus_ep:\n            lr = lr_max\n            \n        else:\n            lr = (lr_max - lr_min) * lr_decay**(epoch - lr_ramp_ep - lr_sus_ep) + lr_min\n            \n        return lr\n\n    lr_callback = tf.keras.callbacks.LearningRateScheduler(lrfn, verbose=False)\n    return lr_callback","54510247":"vis_lr_callback()","bb3fbf4c":"skf = KFold(n_splits=4,shuffle=True,random_state=2809)\noof_pred = []; oof_tar = []; oof_val = []; oof_f1 = []; oof_ids = []; oof_folds = [] \n\nfiles_train_g = np.array(files_train_g)\n\nfor fold,(idxT,idxV) in enumerate(skf.split(files_train_g)):\n    # CREATE TRAIN AND VALIDATION SUBSETS\n    files_train = files_train_g[idxT]\n    np.random.shuffle(files_train);\n    files_valid = files_train_g[idxV]\n    CFG['fold'] = fold\n    run = wandb.init(project='g2net',\n                     config=CFG,\n                     mode='offline'\n                    )\n    config = wandb.config\n    print('#'*25); print('#### FOLD',fold+1)\n    print('#### Image Size: %i | model: %s | batch_size %i'%\n          (config['size'], EFNS[config['EFFV']].__name__,config['batch_size']*REPLICAS))\n    train_images = count_data_items(files_train)\n    val_images   = count_data_items(files_valid)\n    print('#### Training: %i | Validation: %i'%(train_images, val_images))\n    \n    # BUILD MODEL\n    K.clear_session()\n    with strategy.scope():\n        model = build_model(config, count=int(count_data_items(files_train)\/config['batch_size']\/\/REPLICAS*config['steps_multiplier']))\n    print('#'*25)   \n    # SAVE BEST MODEL EACH FOLD\n    sv = tf.keras.callbacks.ModelCheckpoint(\n        'fold-%i.h5'%fold, monitor='val_auc', verbose=0, save_best_only=True,\n        save_weights_only=True, mode='max', save_freq='epoch')\n   \n    # TRAIN\n    print('Training...')\n    history = model.fit(\n        get_dataset(files_train, shuffle=True, repeat=True,\n                dim=config['size'], batch_size = config['batch_size'], aug=config['aug']), \n        epochs=CFG['epochs'], \n        callbacks = [sv, get_lr_callback(), WandbCallback()], \n        steps_per_epoch=int(count_data_items(files_train)\/config['batch_size']\/\/REPLICAS*config['steps_multiplier']),\n        validation_data=get_dataset(files_valid, shuffle=False,\n                repeat=False,dim=config['size']),\n        verbose=1\n    )\n    \n    # Loading best model for inference\n    print('Loading best model...')\n    model.load_weights('fold-%i.h5'%fold)  \n    \n    ds_valid = get_dataset(files_valid,labeled=False,return_image_ids=False,\n            repeat=True,shuffle=False,dim=CFG['size'],batch_size=CFG['batch_size']*2)\n    model.eval(ds_valid,verbose=1)\n    run.join()","b41af6b2":"# Next steps\n* Generate Test Sets\n* Create Inference Notebook\n* Add augmentation\n* Add TTA Inference","8a87246d":"# Datasets\n* [Q-Transform TFRecords](https:\/\/www.kaggle.com\/miklgr500\/q-transform-tfrecords)\n    * [CQT G2Net V2 [0 - 1]](https:\/\/www.kaggle.com\/miklgr500\/cqt-g2net-v2-0-1)\n    * [CQT G2Net V2 [2 - 3]](https:\/\/www.kaggle.com\/miklgr500\/cqt-g2net-v2-2-3)\n    * [CQT G2Net V2 [4 - 5]](https:\/\/www.kaggle.com\/miklgr500\/cqt-g2net-v2-4-5)\n    * [CQT G2Net V2 [6 - 7]](https:\/\/www.kaggle.com\/miklgr500\/cqt-g2net-v2-6-7)\n    * [CQT G2Net V2 [8 - 9]](https:\/\/www.kaggle.com\/miklgr500\/cqt-g2net-v2-8-9)\n    * [CQT G2Net V2 [10 - 11]](https:\/\/www.kaggle.com\/miklgr500\/cqt-g2net-v2-10-11)\n    * [CQT G2Net V2 [12 - 13]](https:\/\/www.kaggle.com\/miklgr500\/cqt-g2net-v2-12-13)\n    * [CQT G2Net V2 [14 - 15]](https:\/\/www.kaggle.com\/miklgr500\/cqt-g2net-v2-14-15)","1009a590":"# Reading Tfrecords","144541e7":"# Build Model","f67fb20a":"# Training","a8b087e7":"# CFG","b3d9192e":"# Dataset Creation"}}