{"cell_type":{"1aecd4b6":"code","3e61b03a":"code","f6a6a70d":"code","2f44ae33":"code","a23786ac":"code","e1c8be3f":"code","c37b93c9":"code","b3e60554":"code","f896d604":"code","c4b13e22":"code","95ff0270":"code","ba74547b":"code","425aeb92":"code","0bcf4813":"code","5aa4a7c4":"code","9c3c058e":"code","2b96f4ae":"code","928113fb":"code","4130a6a9":"code","acb0ad70":"code","f595b3e7":"code","4f8e8d88":"code","01be8f35":"code","cc81966c":"code","1a95ef03":"code","c639aa7c":"code","709315da":"code","1cc8372b":"code","7751b032":"markdown"},"source":{"1aecd4b6":"#configure details for data processing run\n#machine configurations\n#----------------------\n#step pulses sent by controller per 100mm of travel in the real world based on 1000 pulses per rev\npulses_per_100mm = 830 \n\n#the servo motion controller records at 6400 pulses per rev for data recording\nservo_pulses_per_100mm = pulses_per_100mm * 6.4 \n\n#the experiment is zeroed to 600mm of travel to the surface of the ballistics gel\nsurface = 600\n\ncontrol_movement_end = 650\n\n%config InlineBackend.figure_format = 'retina'","3e61b03a":"# get the calibration of newtons per measured step in the sensor\n# here we average the 175 weight measurements that were taken and average them to \n# set a calibration\n# to find force we will use measured_force\/calibration_factor that we are calculating here\nimport numpy as np\nimport pandas as pd\n\ncalibration_data = pd.read_csv('..\/input\/swordbot-materialtests\/data\/calibration.csv',header=None)\n\ncalibration_grouping = {}\n\ncalibration_array = calibration_data.to_numpy()\nfor row in calibration_array:\n    if not (row[0] in calibration_grouping):\n        calibration_grouping[row[0]] = []\n    calibration_grouping[row[0]].append(row[1])\ngravity = .009807\nforce_avgs = {'newtons':[],'measurement':[]}\nfor weight_group in calibration_grouping:\n    force = weight_group * gravity\n    force_avgs['newtons'].append(force)\n    force_avgs['measurement'].append(round(np.mean(calibration_grouping[weight_group]),2))\nzero_offset = force_avgs['measurement'][0]\n\ndf = pd.DataFrame(force_avgs)\ndisplay(df)\n\ncalibration_set = []\nfor i in range(len(force_avgs)):\n    force_number = force_avgs['newtons'][i]\n    measurement = force_avgs['measurement'][i]\n    if not(force_number == 0.0):\n        calibration_set.append((measurement-zero_offset)\/force_number)\n        \ncalibration_factor = round(np.mean(calibration_set),2)\n\ndisplay(str(calibration_factor) + \" steps\/newton\")\n","f6a6a70d":"#no-target-control configuration\n#each run is made up of 3 files based on the run serial number\nrun_number = [355,356,357,358,359,360,361,362]\n\n#array of all of the file names for the baseline runs\ndata_files ={\"run_number\":[],\"servo_data_file\":[],\n             \"controller_movement_log\":[],\n             \"sensor_data_file\":[],\n             \"servo_loc_key\":[],\n             \"controller_time_key\":[],\n             \"sensor_time_key\":[]\n            }\nrollup_name = 'linen_shirt'\nfor run in run_number:\n    data_files['run_number'].append(run)\n    #servo data is recorded by the servo. The servo records the actual encoded rotations that have been executed\n    #and the error from that real world location with where it has been \"commanded\" to be by the controller\n    data_files[\"servo_data_file\"].append('..\/input\/swordbot-materialtests\/data\/'+str(run)+'.xml')\n    #movement log of each pulse sent to the servo, this data is used with the servo data to align the real world\n    #movements with the logged load cell data.\n    data_files[\"controller_movement_log\"].append('..\/input\/swordbot-materialtests\/data\/run-movement-log-'+str(run)+'.csv')\n    #the load cell data is the actual force data logged by the sensor pack\n    data_files[\"sensor_data_file\"].append('..\/input\/swordbot-materialtests\/data\/run-measurements-'+str(run)+'.csv')\n    data_files[\"servo_loc_key\"].append(-100000000)\n    data_files[\"controller_time_key\"].append(-100000000)\n    data_files[\"sensor_time_key\"].append(-100000000)\n\ndf = pd.DataFrame(data_files)\ndisplay(df)","2f44ae33":"#Sync \nimport types\nimport matplotlib.pyplot as plt\nplt.rcParams['figure.figsize'] = [25, 5]\nplt.rcParams.update({'font.size': 18})\nfrom xml.etree import ElementTree as ET\nservo_data = {}\n\ndef load_servo_log(file,index):\n    servo_data = {\n        #time the servo has reached the target (+\/- backlash in the mechanical system)\n        \"time_at_surface\":0, \n        #time the servo has received enough commands from the controller that it should \"try\" to be at the surface\n        \"time_at_commanded_surface\":0, \n        #time at the end of the programmed motion (any movement after this is unprogrammed motion correction)\n        \"time_at_end\": 0,\n        #array of servo commanded and actual movements\n        \"log\":{\n            \"time\":[],     #time of datapoint\n            \"actual\":[], #actual movement array\n            \"commanded\":[] #commanded movement array\n    }}\n    #load the XML \n    tree = ET.parse(file)\n    root = tree.getroot()\n    #we need to correct the time by removing the \"starting time\" so our counter starts at 0\n    time = 0\n    #read the variable that holds the scale for movement error\n    var0 = root.find('.\/\/ScopeMain\/DataAcq\/Variable0')\n    error_scale = float(var0.attrib[\"range\"])\n    #read the variable that holds the scale for actual movement\n    var2 = root.find('.\/\/ScopeMain\/DataAcq\/Variable2')\n    servo_pulse_range = float(var2.attrib[\"range\"])\n\n    #flag to ignore log entries until we get some movement as the XML usually \n    #has a few milliseconds of non-movement data\n    started_movement = False\n\n    i = 0\n    #loop through data\n    for p in root.findall('.\/\/ScopeMain\/DataAcq\/APnt'):\n\n        if(not started_movement):\n            if (float(p.attrib['val2']) > 0.0):\n                # we finally look like we are starting to get some data.\n                started_movement = True\n                #this is the time in milliseconds (with microsecond percision) that \n                #we will consider the start of the log. \n                time = float(p.attrib['time'])\n\n        if(started_movement):\n            #adjust the row time so that is based on starting the reading at \"0\"\n            #multiply to 1000 and round so that we go from milliseconds with 6 decimal places (more than microseconds)\n            #to rounded microseconds\n            rowtime = int((float(p.attrib[\"time\"]) - time)*1000)\n\n            val1 = float(p.attrib['val']) * error_scale # error from commanded to actual * scale\n            val2 =  float(p.attrib['val2']) * servo_pulse_range # actual location of the servo * scale\n            commanded = val1 + val2 #location that the controller has commanded the servo to be at\n            \n            #time of the log entry\n            servo_data['log']['time'].append(rowtime)\n            #actual movement converted from pulses to mm\n            actual_movement = (val2 \/ servo_pulses_per_100mm) * 100\n            servo_data['log']['actual'].append(actual_movement) \n            #commanded movement converted from pulses to mm\n            commanded_movement = (commanded \/ servo_pulses_per_100mm) * 100\n            servo_data['log']['commanded'].append(commanded_movement) \n            #if the servo has received enoough commands to reach the surface of the target\n            #record that time\n            if(servo_data['time_at_commanded_surface'] == 0 and commanded_movement >= surface):\n                #because things move so fast we actually want the record before this (closer to 600 than this record)\n                servo_data['time_at_commanded_surface'] = servo_data['log']['time'][i-1]\n                data_files['servo_loc_key'][index] = servo_data['log']['commanded'][i-1]\n\n            #if the servo has reached the surface of the target and we have not recorded a time yet\n            #record that time\n            if(servo_data['time_at_surface'] == 0 and actual_movement >= surface):\n                #because things move so fast we actually want the record before this (closer to 600 than this record)\n                servo_data['time_at_surface'] = servo_data['log']['time'][i-1]\n\n            #if the servo has reached the end of the commanded movement and we have not recorded a time yet\n            #record that time\n            if(servo_data['time_at_end'] == 0 and actual_movement >= control_movement_end):\n                #because things move so fast we actually want the record before this (closer to 600 than this record)\n                servo_data['time_at_end'] = servo_data['log']['time'][i-1]\n            i = i+1;\n    return servo_data\n\nservo_data['file_data'] = []\n#parse out the data we need from each XML file (see method above)\nfor i in range(len(data_files[\"servo_data_file\"])):\n    servo_data['file_data'].append(load_servo_log(data_files['servo_data_file'][i],i))\n    plt.subplot(2, 5, i+1)\n    plt.subplots_adjust(hspace=0.4, wspace=0.4)\n    plt.plot(servo_data['file_data'][i]['log']['time'],servo_data['file_data'][i]['log'][\"actual\"])\n    plt.plot(servo_data['file_data'][i]['log']['time'],servo_data['file_data'][i]['log'][\"commanded\"]) \n    plt.title(rollup_name + ':Servo Data for Run ' + str(data_files['run_number'][i]))\ndf = pd.DataFrame(data_files)\ndisplay(df)","a23786ac":"plt.title(rollup_name + ':Servo Data Stacked')\nfor i in range(len(data_files[\"servo_data_file\"])):\n    plt.plot(servo_data['file_data'][i]['log']['time'],servo_data['file_data'][i]['log'][\"actual\"])\n    plt.plot(servo_data['file_data'][i]['log']['time'],servo_data['file_data'][i]['log'][\"commanded\"])\n","e1c8be3f":"#recenter the data off of the time at commanded service, as this is where we will sync the \n#controller movement log\nplt.title(rollup_name + ':Servo Data Time Aligned when travel reached 600mm')\nfor file_data in servo_data['file_data']:\n    file_data['batch_offset'] = file_data['time_at_commanded_surface'] * -1\n    #add a new array to store the offset time of each record.\n    file_data['log']['offset_time'] = []\n    for i in range(len(file_data['log']['time'])):\n        file_data['log']['offset_time'].append(file_data['log']['time'][i] + file_data['batch_offset'])\n        if(file_data['log']['time'][i] + file_data['batch_offset'] == 0):\n            file_data['zero_index'] = i\n    plt.plot(file_data['log']['offset_time'],file_data['log'][\"actual\"])\n    plt.plot(file_data['log']['offset_time'],file_data['log'][\"commanded\"])\n    ","c37b93c9":"servo_data['ordered_data'] = []\n#starting at zero append all the N positive data so it can be averaged (both time and measurements)\nfor file_data in servo_data['file_data']:\n    for i in range(file_data['zero_index'],len(file_data['log']['time'])):\n        new_index = i - file_data['zero_index']\n        item = {}\n        try:\n            item = servo_data['ordered_data'][new_index]\n        except IndexError:\n            item = {}\n            item['time_series'] = []\n            item['actual_move_series'] = []\n            item['commanded_move_series'] = []\n            item['bucket'] = new_index\n            servo_data['ordered_data'].append(item)\n        item['time_series'].append(file_data['log']['offset_time'][i])\n        item['actual_move_series'].append(file_data['log']['actual'][i])\n        item['commanded_move_series'].append(file_data['log']['commanded'][i])","b3e60554":"#starting at zero insert all the N negative data so it can be averaged (both time and measurements)\nfor file_data in servo_data['file_data']:\n    processed_rows = -1;\n    for i in range(file_data['zero_index']-1,0,-1):\n        new_index = processed_rows + file_data['zero_index']\n        item = {}\n        item_index = -10000000\n        for j in range(len(servo_data['ordered_data'])):\n            if(servo_data['ordered_data'][j]['bucket'] == processed_rows):\n                item = servo_data['ordered_data'][j]\n                item_index = j\n        if(item_index == -10000000):\n            item = {}\n            item['time_series'] = []\n            item['actual_move_series'] = []\n            item['commanded_move_series'] = []\n            item['bucket'] = processed_rows\n            servo_data['ordered_data'].insert(0,item)\n        \n        item['time_series'].append(file_data['log']['offset_time'][i])\n        item['actual_move_series'].append(file_data['log']['actual'][i])\n        item['commanded_move_series'].append(file_data['log']['commanded'][i])\n        processed_rows = processed_rows - 1","f896d604":"#signal average the files and store the roled up new averaged data.\nservo_data['average_signal'] = []\n\nfor data in servo_data['ordered_data']:\n    data_row = [np.mean(data['time_series']),\n                np.mean(data['actual_move_series']),\n                np.mean(data['commanded_move_series'])]\n    servo_data['average_signal'].append(data_row)\n\nservo_average_df = pd.DataFrame(servo_data['average_signal'], \n                                         columns=[\"time\",\"actual\",\"commanded\"])\ntry:\n    os.remove('..\/working\/rollups\/rollup_'+rollup_name+'_servo_data.csv')\nexcept:\n    print(\"no file to delete\")\n    \nservo_average_df.to_csv('..\/working\/rollup_'+rollup_name+'_servo_data.csv')\n\nsync_loc = 0;\nfor row in servo_data['average_signal']:\n    if(row[0] == 0):\n        sync_loc = row[2]\n\nplt.title(rollup_name + ':Aligned Servo Data Averaged')\nplt.plot(servo_average_df['time'],servo_average_df['actual'])\nplt.plot(servo_average_df['time'],servo_average_df['commanded'])","c4b13e22":"#load the controller log captured by the controller (this shares the same internal clock with the load cell force data)\ndef load_controller_log(file,index):\n    pulse_log = pd.read_csv(file,skiprows=5)\n    servo_loc_key = data_files['servo_loc_key'][index]\n    controller_data = {\n        #time the controller sent the signal that should put the servo at the surface of the target\n        'time_at_surface':0,\n        #last command of the controller which is at the end of the controlled movement (650mm)\n        'time_at_end':0,\n        'log':{\n            #microsecond the pulse was sent\n            'time':[],\n            #command normalized to mm\n            'commanded':[] \n        },\n    }\n    for row in pulse_log.to_numpy():\n        #time of the command\n        time = int(row[0])\n        command_loc = (int(row[1])\/pulses_per_100mm) * 100\n        controller_data['log']['time'].append(time)\n        controller_data['log']['commanded'].append(command_loc) #command normalized to mm\n        \n        #if the controller has reached the surface movement command and we have not recorded a time yet\n        #record that time\n        if (command_loc >= servo_loc_key and controller_data['time_at_surface'] == 0):\n            controller_data['time_at_surface'] = int(row[0])\n            data_files[\"controller_time_key\"][index] = controller_data['time_at_surface']\n\n        #since this is always the last command just keep resetting the value till we get to the end\n        #not elegant but no need to be here, its just an int\n        controller_data['time_at_end'] = int(row[0])\n    return controller_data\n\ncontroller_data = {}\ncontroller_data['file_data'] = []\n#parse out the data we need from each CSV file (see method above)\nfor i in range(len(data_files['controller_movement_log'])):\n    controller_data['file_data'].append(load_controller_log(data_files['controller_movement_log'][i],i))\n    plt.subplot(2, 5, i+1)\n    plt.subplots_adjust(hspace=0.4, wspace=0.4)\n    plt.plot(controller_data['file_data'][i]['log']['time'],controller_data['file_data'][i]['log'][\"commanded\"])\n    plt.title(rollup_name + ':Controller Data for Run ' + str(data_files['run_number'][i]))\ndf = pd.DataFrame(data_files)\ndisplay(df)","95ff0270":"plt.title(rollup_name + ':Controller Data Stacked')\nfor i in range(len(data_files['controller_movement_log'])):\n    plt.plot(controller_data['file_data'][i]['log']['time'],controller_data['file_data'][i]['log'][\"commanded\"])\n    ","ba74547b":"#recenter the data off of the time at commanded servo zero, as this is where we will sync the \n#controller movement log\nplt.title(rollup_name + ':Controller Data Time Aligned when travel reached 600mm')\nfor file_data in controller_data['file_data']:\n    file_data['batch_offset'] = file_data['time_at_surface'] * -1\n    #add a new array to store the offset time of each record.\n    file_data['log']['offset_time'] = []\n    for i in range(len(file_data['log']['time'])):\n        file_data['log']['offset_time'].append(file_data['log']['time'][i] + file_data['batch_offset'])\n        if(file_data['log']['time'][i] + file_data['batch_offset'] == 0):\n            file_data['zero_index'] = i\n    plt.plot(file_data['log']['offset_time'],file_data['log'][\"commanded\"])","425aeb92":"controller_data['ordered_data'] = []\n#starting at zero append all the N positive data so it can be averaged (both time and measurements)\nfor file_data in controller_data['file_data']:\n    for i in range(file_data['zero_index'],len(file_data['log']['time'])):\n        new_index = i - file_data['zero_index']\n        item = {}\n        try:\n            item = controller_data['ordered_data'][new_index]\n        except IndexError:\n            item = {}\n            item['time_series'] = []\n            item['controller_time_series'] = []\n            item['commanded_move_series'] = []\n            item['bucket'] = new_index\n            controller_data['ordered_data'].append(item)\n            \n        item['controller_time_series'].append(file_data['log']['time'][i])\n        item['commanded_move_series'].append(file_data['log']['commanded'][i])\n        item['time_series'].append(file_data['log']['offset_time'][i])","0bcf4813":"#starting at zero insert all the N negative data so it can be averaged (both time and measurements)\nfor file_data in controller_data['file_data']:\n    processed_rows = -1;\n    for i in range(file_data['zero_index']-1,0,-1):\n        new_index = processed_rows + file_data['zero_index']\n        item = {}\n        item_index = -10000000\n        for j in range(len(controller_data['ordered_data'])):\n            if(controller_data['ordered_data'][j]['bucket'] == processed_rows):\n                item = controller_data['ordered_data'][j]\n                item_index = j\n        if(item_index == -10000000):\n            item = {}\n            item['time_series'] = []\n            item['controller_time_series'] = []\n            item['commanded_move_series'] = []\n            item['bucket'] = processed_rows\n            controller_data['ordered_data'].insert(0,item)\n\n        \n        item['controller_time_series'].append(file_data['log']['time'][i])\n        item['commanded_move_series'].append(file_data['log']['commanded'][i])\n        item['time_series'].append(file_data['log']['offset_time'][i])\n        processed_rows = processed_rows - 1","5aa4a7c4":"import os\ncontroller_data['average_signal'] = []\n\nfor data in controller_data['ordered_data']:\n    data_row = [np.mean(data['time_series'])\n                ,np.mean(data['controller_time_series'])\n                ,np.mean(data['commanded_move_series'])]\n    controller_data['average_signal'].append(data_row)\n\ncontroller_average_df = pd.DataFrame(controller_data['average_signal'], \n                                         columns=[\"time\",\"controller_time\",\"commanded\"])\ntry:\n    os.remove('..\/working\/rollup_'+rollup_name+'_command_data.csv')\nexcept:\n    print(\"no file to delete\")\ncontroller_average_df.to_csv('..\/working\/rollup_'+rollup_name+'_command_data.csv')\n\ncontroller_sync_loc = -10;\ncontroller_time_sync = 0;\nfor row in controller_data['average_signal']:\n    if(row[0] == 0):\n        controller_sync_loc = row[2]\n        controller_time_sync = row[1]\nplt.title(rollup_name + ':Aligned Controller Data Averaged')\nplt.plot(controller_average_df['time'],controller_average_df['commanded'])","9c3c058e":"#load the controller log captured by the controller (this shares the same internal clock with the load cell force data)\ndef load_sensor_log(file,index):\n    data_log = pd.read_csv(file,skiprows=5)\n    controller_time_key = data_files[\"controller_time_key\"][index]\n    sensor_data = {\n        #time that the sensor timestamp is at or after the time calculated to be the surface of the material\n        \"time_at_surface\":0,\n        \"log\":{\n            \"time\":[],\n            \"force\":[]\n        }\n    }\n\n    for row in data_log.to_numpy():\n        #time of the command\n        time = int(row[0])\n        force = int(row[1])\/calibration_factor #force\/calibration = newtons\n        sensor_data['log']['time'].append(time)\n        sensor_data['log']['force'].append(force)\n        \n        #if the controller has reached the surface movement command and we have not recorded a time yet\n        #record that time\n        if (time >= controller_time_key and sensor_data['time_at_surface'] == 0):\n            sensor_data['time_at_surface'] = int(row[0])\n            data_files[\"sensor_time_key\"][index] = sensor_data['time_at_surface']\n    return sensor_data\n\nsensor_data = {}\nsensor_data['file_data'] = []\n#parse out the data we need from each CSV file (see method above)\nfor i in range(len(data_files['sensor_data_file'])):\n    sensor_data['file_data'].append(load_sensor_log(data_files['sensor_data_file'][i],i))\n    plt.subplot(2, 5, i+1)\n    plt.subplots_adjust(hspace=0.4, wspace=0.4)\n    plt.plot(sensor_data['file_data'][i]['log']['time'],sensor_data['file_data'][i]['log'][\"force\"])\n    plt.title(rollup_name + ':Sensor' + str(data_files['run_number'][i]))\ndf = pd.DataFrame(data_files)\ndisplay(df)","2b96f4ae":"plt.title(rollup_name + ':Sensor Data Stacked')\nfor i in range(len(data_files['sensor_data_file'])):\n    plt.plot(sensor_data['file_data'][i]['log']['time'],sensor_data['file_data'][i]['log'][\"force\"])","928113fb":"#recenter the data off of the time at controller log, as this is where we will sync the \nplt.title(rollup_name + ':Sensor Data Time Aligned when travel reached 600mm')\nfor file_data in sensor_data['file_data']:\n    file_data['batch_offset'] = file_data['time_at_surface'] * -1\n    #add a new array to store the offset time of each record.\n    file_data['log']['offset_time']=[]\n    for i in range(len(file_data['log']['time'])):\n        file_data['log']['offset_time'].append(file_data['log']['time'][i] + file_data['batch_offset'])\n        if(file_data['log']['time'][i] + file_data['batch_offset'] == 0):\n            file_data['zero_index'] = i\n    plt.plot(file_data['log']['offset_time'],file_data['log'][\"force\"])","4130a6a9":"sensor_data['ordered_data'] = []\n#starting at zero append all the N positive data so it can be averaged (both time and measurements)\nfor file_data in sensor_data['file_data']:\n    for i in range(file_data['zero_index'],len(file_data['log']['time'])):\n        new_index = i - file_data['zero_index']\n        item = {}\n        try:\n            item = sensor_data['ordered_data'][new_index]\n        except IndexError:\n            item = {}\n            item['time_series'] = []\n            item['force'] = []\n            item['original_time_series'] = []\n            item['bucket'] = new_index\n            sensor_data['ordered_data'].append(item)\n            \n        item['original_time_series'].append(file_data['log']['time'][i])\n        item['force'].append(file_data['log']['force'][i])\n        item['time_series'].append(file_data['log']['offset_time'][i])","acb0ad70":"#starting at zero insert all the N negative data so it can be averaged (both time and measurements)\nfor file_data in sensor_data['file_data']:\n    processed_rows = -1;\n    for i in range(file_data['zero_index']-1,0,-1):\n        new_index = processed_rows + file_data['zero_index']\n        item = {}\n        item_index = -10000000\n        for j in range(len(sensor_data['ordered_data'])):\n            if(sensor_data['ordered_data'][j]['bucket'] == processed_rows):\n                item = sensor_data['ordered_data'][j]\n                item_index = j\n        if(item_index == -10000000):\n            item = {}\n            item['time_series'] = []\n            item['force'] = []\n            item['original_time_series'] = []\n            item['bucket'] = processed_rows\n            sensor_data['ordered_data'].insert(0,item)\n        \n        item['original_time_series'].append(file_data['log']['time'][i])\n        item['force'].append(file_data['log']['force'][i])\n        item['time_series'].append(file_data['log']['offset_time'][i])\n        processed_rows = processed_rows - 1","f595b3e7":"sensor_data['average_signal'] = []\n\nfor data in sensor_data['ordered_data']:\n    data_row = [np.mean(data['time_series']),np.mean(data['original_time_series']),np.mean(data['force'])]\n    sensor_data['average_signal'].append(data_row)\n\nsensor_average_df = pd.DataFrame(sensor_data['average_signal'], \n                                         columns=[\"time\",\"original_time\",\"force\"])\ntry:\n    os.remove('..\/working\/rollup_'+rollup_name+'_sensor_data.csv')\nexcept:\n    print(\"no file to delete\")\nsensor_average_df.to_csv('..\/working\/rollup_'+rollup_name+'_sensor_data.csv')\nplt.title(rollup_name + ':Aligned Sensor Data Averaged')\nplt.plot(sensor_average_df['time'],sensor_average_df['force'])\nsensor_average_df","4f8e8d88":"#load up the baseline\nfrom scipy.signal import savgol_filter\nbaseline_df = pd.read_csv('..\/input\/swordbot-baseline\/rollup_baseline_sensor_data.csv')\nsavgol_filtered_baseline_data = savgol_filter(baseline_df['force'], 51, 2)","01be8f35":"from scipy.signal import savgol_filter\n\n#get the time when the servo crossed the end of control\nservo_time_at_end = 0\nfor row in servo_data['average_signal']:\n    if(row[1] >= 650):\n        servo_time_at_end = row[0]\n        break\n\nfig, ax1 = plt.subplots()\n#first chart is raw load cell data\nax1.plot(sensor_average_df[\"time\"],sensor_average_df[\"force\"],color=\"gray\", label=\"Signal Averaged(newtons)\")\nax1.plot(baseline_df[\"time\"],savgol_filtered_baseline_data)\nax1.set_xlabel('time (microseconds)')\n# Make the y-axis label, ticks and tick labels match the line color.\nax1.set_ylabel('force(N)', color='b')\n\nsavgol_filtered_data = savgol_filter(sensor_average_df['force'], 51, 2)\nax1.plot(sensor_average_df[\"time\"],savgol_filtered_data,color=\"red\", label=\"Savitzky\u2013Golay(newtons)\")\ndisplay(len(savgol_filtered_data))\n#add some verticle at target surface & movement end times\nax1.axvspan(-6000, servo_time_at_end+6000, alpha=0.1, color='green', label='investigation zone')\nax1.axvspan(0, servo_time_at_end, alpha=0.25, color='green', label='time of interaction zone')\nax1.axvspan(servo_time_at_end, servo_time_at_end+108000, alpha=0.10, color='purple', label='servo deceleration')\n\n\n#second chart is of the movement data from servo and controller\nax2 = ax1.twinx()\nax2.plot(servo_average_df[\"time\"],servo_average_df[\"actual\"],color='blue', label=\"Servo Travel(mm)\")\nax2.set_ylabel('mm', color='blue')\n\n#ax2.plot(servo_average_df[\"time\"],servo_average_df[\"commanded_loc\"],color='green')\n#ax2.plot(controller_average_df[\"time\"],controller_average_df[\"commanded_loc\"],color='b')\n\n#add some horizontal lines at target surface & controlled movement end distances \n#a perfect movement will cut the rectangle created by these lines\n#and the lines above into two right triangles\nax2.axhspan(600,650, alpha=0.1, color=\"blue\", label=\"travel of interaction zone)\")\n\n\nfig.tight_layout()\nplt.title(rollup_name + ':Aligned Sensor Data with Savitzky\u2013Golay filter and meta-data overlays')\nax2.legend(loc=\"upper right\")\nleg = ax1.legend(loc='upper left')\nleg.remove()\nax2.add_artist(leg)\nfig.patch.set_facecolor('white')\nplt.plot()\n","cc81966c":"#get baseline force median using filtered data\nbaseline_force_set=[]\nfor i in range(len(baseline_df[\"time\"])):\n    row = baseline_df[\"time\"][i]\n    if(row > 0 and row < servo_time_at_end):\n        baseline_force_set.append(savgol_filtered_baseline_data[i])\n\n#median force here because this is a range of noise where \"nothing\" is going on\nbaseline_force = np.average(baseline_force_set) \nbaseline_variance = np.var(baseline_force_set)\ndisplay(baseline_force)\ndisplay(baseline_variance)\ndisplay(np.std(baseline_force_set))","1a95ef03":"#get peak force in the investigation zone (interaction zone +\/- 6 milliseconds)\npeak_force = -1000000\npeak_force_index = -1000000\nfor i in range(len(sensor_data['average_signal'])):\n    row = sensor_data['average_signal'][i]\n    if(row[0] > 0 -6000 and row[0] <= servo_time_at_end+6000):\n        if(savgol_filtered_data[i] > peak_force):\n            peak_force = savgol_filtered_data[i] \n            peak_force_index = i\n\npeak_force_time = sensor_average_df[\"time\"][peak_force_index]\nnet_force = peak_force - baseline_force\nnet_force","c639aa7c":"#because the peak force is outside of our interaction zone, and there is a clear downward movement in the baseline\n#net force is actually based on that the correct time mached datapoint in the baseline\nbaseline_time_found = False\nfor i in range(len(baseline_df[\"time\"])):\n    row = baseline_df[\"time\"][i]\n    if(row > peak_force_time and baseline_time_found == False):\n        #sence we are doing greater than we go back 1 measurement as that is usually closer in alignment\n        baseline_force = savgol_filtered_baseline_data[i -1] \n        baseline_time_found = True\n        break\nnet_force = peak_force - baseline_force\nnet_force","709315da":"peak_force_time - servo_time_at_end","1cc8372b":"fig, ax1 = plt.subplots()\n#first chart is raw load cell data\nax1.plot(sensor_average_df[\"time\"],sensor_average_df[\"force\"],color=\"gray\", alpha=.25, label=\"Signal Averaged(newtons)\")\nax1.plot(baseline_df[\"time\"],savgol_filtered_baseline_data)\nax1.set_xlabel('time (microseconds)')\n# Make the y-axis label, ticks and tick labels match the line color.\nax1.set_ylabel('force(N)', color='b')\n\nsavgol_filtered_data = savgol_filter(sensor_average_df['force'], 51, 2)\nax1.plot(sensor_average_df[\"time\"],savgol_filtered_data,color=\"red\", label=\"Savitzky\u2013Golay(newtons)\")\n\n#add some verticle at target surface & movement end times\nax1.axvspan(-6000, servo_time_at_end+6000, alpha=0.1, color='green', label='investigation zone')\nax1.axvspan(0, servo_time_at_end, alpha=0.25, color='green', label='time of interaction zone')\nax1.axvspan(servo_time_at_end, servo_time_at_end+108000, alpha=0.10, color='purple', label='servo deceleration')\nax1.axhline(baseline_force,linestyle=':', label=\"average measurement in interaction zone\")\nax1.axhline(peak_force, linestyle=\"-.\", label=\"peak force measured\")\nax1.plot([peak_force_time,peak_force_time],[baseline_force,peak_force], label=\"net force\")\n\n\nbbox = dict(boxstyle=\"round\", color=\"white\")\nax1.annotate(\"Net force:\" + str(round(net_force,2)) + \"n\"\n             ,xy=(peak_force_time-1400,(net_force\/2)+baseline_force)\n             ,bbox=bbox, fontsize=15)\nfig.tight_layout()\nplt.title(rollup_name + ':Closeup view of the investigation zone with peak force highlighted and net force calculated')\nleg = ax1.legend(loc='upper left')\nfig.patch.set_facecolor('white')\nplt.xlim(-7500,servo_time_at_end + 7500)\nplt.ylim(-10,net_force+5)\nplt.plot()","7751b032":"# What just happened #\n1. Load All of the Servo XML files\n2. Found the row that was commanded to be closest to the surface of the target (commanded because actual can be different) for each file\n3. Offset all of the times of the rows of data so that 0 is that \"surface\" row\n4. Align all of the files based on 0 being the \"center\" and data recorded before 0 being negative and after 0 being positive\n5. For each maching row across all the files average them this results in avg time and avg location data for all servo files recorded in the set\n6. Repeat 1 through 5 for all of the controller files for the run\n7. Save off the rolled up data so that it is available for other notebooks\n\n## Result ##\nThe servo data and the controller movement logs for the set of runs are aligned togeather (+\/- 600 microseconds). We also have the controller time which shares a clock with sensor data which we will use to align the positional data (from the servo) with the sensor data.\n\n# What is next #\nWe will load the sensor data sets, center all of the runs off of the controller time data, then average all of the data so that signal averaging can help with increasing the signal to noise ration."}}