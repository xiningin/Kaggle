{"cell_type":{"e78d950a":"code","e8b7a226":"code","ed0cb647":"code","a16bca7f":"code","da220372":"code","4d0ab2c4":"code","47b66510":"code","a5d9b655":"code","dd649e23":"code","efe7cb48":"code","8e66d0f4":"code","fafb0bcc":"code","428e2a48":"code","42464594":"code","9f4dac37":"code","dddcd827":"code","760dbad9":"code","5b47d386":"code","9fc1e0d4":"code","506edb5c":"code","287b46c3":"code","e63a788d":"code","43e7fa44":"code","2a7220cb":"code","ac2b95ae":"code","d47bce2e":"code","2543ed0e":"code","3f0b754a":"code","5eb78a0d":"code","f73d8678":"markdown","1a3f92e0":"markdown","e72bf783":"markdown","27898957":"markdown","ec1a4e2e":"markdown","da72b492":"markdown","f819947d":"markdown","27e12b2e":"markdown"},"source":{"e78d950a":"import string\nimport numpy as np\nimport PIL.Image\n\nfrom os import listdir\nfrom pickle import dump, load\n\nfrom numpy import array\nfrom numpy import argmax\n\nfrom keras.applications.vgg16 import VGG16, preprocess_input\nfrom keras.preprocessing.image import load_img, img_to_array\nfrom keras.preprocessing.text import Tokenizer\nfrom keras.preprocessing.sequence import pad_sequences\nfrom keras.utils import to_categorical\nfrom keras.layers.merge import add\nfrom keras.models import Model, load_model\nfrom keras.layers import Input, Dense, LSTM, Embedding, Dropout\nfrom keras.callbacks import ModelCheckpoint\n\nfrom nltk.translate.bleu_score import corpus_bleu","e8b7a226":"# Extract features from each photo in the directory\ndef extract_features(directory):\n    \n    # Loading the model\n    model = VGG16()\n\n    # Removing the last layer from the loaded model as we require only the features not the classification \n    model.layers.pop()\n    model = Model(inputs=model.inputs, outputs=model.layers[-1].output)\n    \n    # Summarizing the model \n    print(model.summary())\n\n    # Extracting features from each photo and storing it in a dictionary \n    features = dict()\n\n    for name in listdir(directory):\n\n        # Defining the path of the image \n        filename = directory + '\/' + name\n        \n        # Loading an image and converting it into size 224 * 224\n        image = load_img(filename, target_size=(224, 224))\n        \n        # Converting the image pixels into a numpy array\n        image = img_to_array(image)\n        \n        # Reshaping data for the model\n        image = image.reshape((1, image.shape[0], image.shape[1], image.shape[2]))\n\n        \n        # Preprocessing the images for the VGG model\n        # The preprocess_input function is meant to adequate your image to the format the model requires.\n        image = preprocess_input(image)\n\n        # Getting features of an image\n        feature = model.predict(image, verbose=0)\n        \n        # Getting the image name\n        image_id = name.split('.')[0]\n\n        # Storing the feature corresponding to the image in the dictionary\n        features[image_id] = feature\n        \n        # print('>%s' % name)\n        \n    return features","ed0cb647":"# Defining the directory we are using\ndirectory = '..\/input\/flickr8k_dataset\/Flicker8k_Dataset'\n\n# Extracting features from all the images\nfeatures = extract_features(directory)\n\nprint('Extracted Features: ', len(features))\n\n# Dumping the features in a pickle file for further use\ndump(features, open('features.pkl', 'wb'))","a16bca7f":"listdir('..\/input')","da220372":"# Loading the file containg all the descriptions into memory\n\ndef load_doc(filename):\n    # Opening the file as read only\n    file = open(filename, 'r')\n\n    # Reading all text and storing it.\n    text = file.read()\n\n    # Closing the file\n    file.close()\n    \n    return text\n","4d0ab2c4":"def photo_to_description_mapping(descriptions):\n    \n    # Dictionary to store the mapping of photo identifiers to descriptions\n    description_mapping = dict()\n    \n    # Iterating through each line of the descriptions\n    for line in descriptions.split('\\n'):\n        \n        # Splitting the lines by white space\n        words = line.split()\n        \n        # Skipping the lines with length less than 2\n        if len(line)<2:\n            continue\n            \n        # The first word is the image_id and the rest are the part of the description of that image\n        image_id, image_description = words[0], words[1:]\n        \n        # Retaining only the name of the image and removing the extension from it\n        image_id = image_id.split('.')[0]\n        \n        # Image_descriptions contains comma separated words of the description, hence, converting it back to string\n        image_description = ' '.join(image_description)\n        \n        # There are multiple descriptions per image, \n        # hence, corresponding to every image identifier in the dictionary, there is a list of description\n        # if the list does not exist then we need to create it\n        \n        if image_id not in description_mapping:\n            description_mapping[image_id] = list()\n            \n        # Now storing the descriptions in the mapping\n        description_mapping[image_id].append(image_description)\n    \n    return description_mapping","47b66510":"def clean_descriptions(description_mapping):\n    \n    # Preapring a translation table for removing all the punctuation\n    table = str.maketrans('','', string.punctuation)\n    \n    # Traversing through the mapping we created\n    for key, descriptions in description_mapping.items():\n        for i in range(len(descriptions)):\n            description = descriptions[i]\n            description = description.split()\n            \n            # Converting all the words to lower case\n            description = [word.lower() for word in description]\n            \n            # Removing the punctuation using the translation table we made\n            description = [word.translate(table) for word in description]\n            \n            # Removing the words with length =1\n            description = [word for word in description if len(word)>1]\n            \n            # Removing all words with number in them\n            description = [word for word in description if word.isalpha()]\n            \n            # Converting the description back to string and overwriting in the descriptions list\n            descriptions[i] = ' '.join(description)","a5d9b655":"# Converting the loaded descriptions into a vocabulary of words\n\ndef to_vocabulary(descriptions):\n    \n    # Build a list of all description strings\n    all_desc = set()\n    \n    for key in descriptions.keys():\n        [all_desc.update(d.split()) for d in descriptions[key]]\n    \n    return all_desc","dd649e23":"# save descriptions to file, one per line\ndef save_descriptions(descriptions, filename):\n    lines = list()\n    for key, desc_list in descriptions.items():\n        for desc in desc_list:\n            lines.append(key + ' ' + desc)\n    data = '\\n'.join(lines)\n    file = open(filename, 'w')\n    file.write(data)\n    file.close()","efe7cb48":"filename = '..\/input\/flickr8k_text\/Flickr8k.token.txt'\n\n# Loading descriptions\ndoc = load_doc(filename)\n\n# Parsing descriptions\ndescriptions = photo_to_description_mapping(doc)\nprint('Loaded: %d ' % len(descriptions))\n\n# Cleaning the descriptions\nclean_descriptions(descriptions)\n\n# Summarizing the vocabulary\nvocabulary = to_vocabulary(descriptions)\nprint('Vocabulary Size: %d' % len(vocabulary))\n\n# Saving to the file\nsave_descriptions(descriptions, 'descriptions.txt')","8e66d0f4":"# Function for loading a file into memory and returning text from it\ndef load_file(filename):\n    file = open(filename, 'r')\n    text = file.read()\n    file.close()\n    return text\n\n# Function for loading a pre-defined list of photo identifiers\ndef load_photo_identifiers(filename):\n    \n    # Loading the file containing the list of photo identifier\n    file = load_file(filename)\n    \n    # Creating a list for storing the identifiers\n    photos = list()\n    \n    # Traversing the file one line at a time\n    for line in file.split('\\n'):\n        if len(line) < 1:\n            continue\n        \n        # Image name contains the extension as well but we need just the name\n        identifier = line.split('.')[0]\n        \n        # Adding it to the list of photos\n        photos.append(identifier)\n        \n    # Returning the set of photos created\n    return set(photos)\n\n\n# loading the cleaned descriptions that we created earlier\n# we will only be loading the descriptions of the images that we will use for training\n# hence we need to pass the set of train photos that the above function will be returning\n\ndef load_clean_descriptions(filename, photos):\n    \n    #loading the cleaned description file\n    file = load_file(filename)\n    \n    #creating a dictionary of descripitions for storing the photo to description mapping of train images\n    descriptions = dict()\n    \n    #traversing the file line by line\n    for line in file.split('\\n'):\n        # splitting the line at white spaces\n        words = line.split()\n        \n        # the first word will be the image name and the rest will be the description of that particular image\n        image_id, image_description = words[0], words[1:]\n        \n        # we want to load only those description which corresponds to the set of photos we provided as argument\n        if image_id in photos:\n            #creating list of description if needed\n            if image_id not in descriptions:\n                descriptions[image_id] = list()\n            \n            #the model we will develop will generate a caption given a photo, \n            #and the caption will be generated one word at a time. \n            #The sequence of previously generated words will be provided as input. \n            #Therefore, we will need a \u2018first word\u2019 to kick-off the generation process \n            #and a \u2018last word\u2018 to signal the end of the caption.\n            #we will use 'startseq' and 'endseq' for this purpose\n            #also we have to convert image description back to string\n            \n            desc = 'startseq ' + ' '.join(image_description) + ' endseq'\n            descriptions[image_id].append(desc)\n            \n    return descriptions\n\n# function to load the photo features created using the VGG16 model\ndef load_photo_features(filename, photos):\n    \n    #this will load the entire features\n    all_features = load(open(filename, 'rb'))\n    \n    #we are interested in loading the features of the required photos only\n    features = {k: all_features[k] for k in photos}\n    \n    return features","fafb0bcc":"filename = '..\/input\/flickr8k_text\/Flickr_8k.trainImages.txt'\n\ntrain = load_photo_identifiers(filename)\nprint('Dataset: ',len(train))\n\ntrain_descriptions = load_clean_descriptions('descriptions.txt', train)\nprint('Descriptions: train=', len(train_descriptions))\n\ntrain_features = load_photo_features('features.pkl', train)\nprint('Photos: train=', len(train_features))","428e2a48":"# convert a dictionary of clean descriptions to a list of descriptions\ndef to_lines(descriptions):\n    all_desc = list()\n    for key in descriptions.keys():\n        [all_desc.append(d) for d in descriptions[key]]\n    return all_desc\n\n# Given the descriptions, fit a tokenizer\n\n# TOKENIZER CLASS:\n# This class allows to vectorize a text corpus, \n# by turning each text into either a sequence of integers \n# (each integer being the index of a token in a dictionary) \n# or, into a vector where the coefficient for each token could be binary, based on word count, based on tf-idf...\n\ndef create_tokenizer(descriptions):\n    lines = to_lines(descriptions)\n    tokenizer = Tokenizer()\n    tokenizer.fit_on_texts(lines)\n    return tokenizer","42464594":"tokenizer = create_tokenizer(train_descriptions)\n\nvocab_size = len(tokenizer.word_index) + 1\nprint('Vocabulary Size: ', vocab_size)","9f4dac37":"#calculated the length of description with most words\ndef max_lengthTEMP(descriptions):\n    lines = to_lines(descriptions)\n    return max(len(d.split()) for d in lines)","dddcd827":"#the below function loop forever with a while loop and within this, \n#loop over each image in the image directory. \n#For each image filename, we can load the image and \n#create all of the input-output sequence pairs from the image\u2019s description.\n\n#data generator, intended to be used in a call to model.fit_generator()\ndef data_generator(descriptions, photos, tokenizer, max_length):\n    while 1:\n        for key, description_list in descriptions.items():\n            #retrieve photo features\n            photo = photos[key][0]\n            input_image, input_sequence, output_word = create_sequences(tokenizer, max_length, description_list, photo)\n            yield [[input_image, input_sequence], output_word]\n\n            \n#we are calling the create_sequence() function to create \n#a batch worth of data for a single photo rather than an entire dataset. \n#This means that we must update the create_sequences() function \n#to delete the \u201citerate over all descriptions\u201d for-loop.            \n#Updated create sequence function for data_generator\ndef create_sequences(tokenizer, max_length, desc_list, photo):\n    X1, X2, y = list(), list(), list()\n    # walk through each description for the image\n    for desc in desc_list:\n        # encode the sequence\n        seq = tokenizer.texts_to_sequences([desc])[0]\n        # split one sequence into multiple X,y pairs\n        for i in range(1, len(seq)):\n            # split into input and output pair\n            in_seq, out_seq = seq[:i], seq[i]\n            # pad input sequence\n            in_seq = pad_sequences([in_seq], maxlen=max_length)[0]\n            # encode output sequence\n            out_seq = to_categorical([out_seq], num_classes=vocab_size)[0]\n            # store\n            X1.append(photo)\n            X2.append(in_seq)\n            y.append(out_seq)\n    return array(X1), array(X2), array(y)","760dbad9":"from keras.utils import plot_model\n# define the captioning model\ndef define_model(vocab_size, max_length):\n    \n    # feature extractor model\n    inputs1 = Input(shape=(4096,))\n    fe1 = Dropout(0.5)(inputs1)\n    fe2 = Dense(256, activation='relu')(fe1)\n\n    # sequence model\n    inputs2 = Input(shape=(max_length,))\n    se1 = Embedding(vocab_size, 256, mask_zero=True)(inputs2)\n    se2 = Dropout(0.5)(se1)\n    se3 = LSTM(256)(se2)\n\n    # decoder model\n    decoder1 = add([fe2, se3])\n    decoder2 = Dense(256, activation='relu')(decoder1)\n    outputs = Dense(vocab_size, activation='softmax')(decoder2)\n    \n    # tie it together [image, seq] [word]\n    model = Model(inputs=[inputs1, inputs2], outputs=outputs)\n    model.compile(loss='categorical_crossentropy', optimizer='adam')\n    \n    # summarize model\n    print(model.summary())\n    plot_model(model, to_file='model.png', show_shapes=True)\n    \n    return model","5b47d386":"\nfilename = '..\/input\/flickr8k_text\/Flickr_8k.trainImages.txt'\ntrain = load_photo_identifiers(filename)\nprint('Dataset: ', len(train))\ntrain_descriptions = load_clean_descriptions('descriptions.txt', train)\nprint('Descriptions: train=', len(train_descriptions))\ntrain_features = load_photo_features('features.pkl', train)\nprint('Photos: train=', len(train_features))\ntokenizer = create_tokenizer(train_descriptions)\nvocab_size = len(tokenizer.word_index) + 1\nprint('Vocabulary Size:', vocab_size)\nmax_length = max_lengthTEMP(train_descriptions)\nprint('Description Length: ', max_length)\n\nmodel = define_model(vocab_size, max_length)\nepochs = 1\nsteps = len(train_descriptions)\nfor i in range(epochs):\n    generator = data_generator(train_descriptions, train_features, tokenizer, max_length)\n    model.fit_generator(generator, epochs=10, steps_per_epoch=steps, verbose=1)\n    model.save('model_' + str(i) + '.h5')","9fc1e0d4":"#this function maps an integer to a word\ndef word_for_id(integer, tokenizer):\n    for word, index in tokenizer.word_index.items():\n        if index == integer:\n            return word\n    return None\n\n#The function below generates a textual description given a trained model, \n#and a given prepared photo as input. It calls the function word_for_id() \n#in order to map an integer prediction back to a word.\ndef generate_desc(model, tokenizer, photo, max_length):\n    #start tge generation process\n    in_text = 'startseq'\n    #iterating over the max_length since the maximum length of the description can be that only\n    for i in range(max_length):\n        #integer ncoding input sequence\n        sequence = tokenizer.texts_to_sequences([in_text])[0]\n        #padding the input\n        sequence = pad_sequences([sequence], maxlen=max_length)\n        #predicting next word\n        #the predict function will return probability\n        prob = model.predict([photo,sequence], verbose=0)\n        #converting the probability to integer\n        prob = argmax(prob)\n        #calling the word_for_id function in order to map integer to word\n        word = word_for_id(prob, tokenizer)\n        #breaking if word cannot be mapped\n        if word is None:\n            break\n        #appending as input\n        in_text += ' ' + word\n        #break if end is predicted\n        if word == 'endseq':\n            break\n    return in_text\n\n#the below function evaluates the skill of the model\ndef evaluate_model(model, descriptions, photos, tokenizer, max_length):\n    actual, predicted = list(), list()\n    for key, desc_list in descriptions.items():\n        prediction = generate_desc(model, tokenizer, photos[key], max_length)\n        actual_desc = [d.split() for d in desc_list]\n        actual.append(actual_desc)\n        predicted.append(prediction.split())\n\n    print('BLEU-1: ', corpus_bleu(actual, predicted, weights=(1.0, 0, 0, 0)))\n    print('BLEU-2: ', corpus_bleu(actual, predicted, weights=(0.5, 0.5, 0, 0)))\n    print('BLEU-3: ', corpus_bleu(actual, predicted, weights=(0.3, 0.3, 0.3, 0)))\n    print('BLEU-4: ', corpus_bleu(actual, predicted, weights=(0.25, 0.25, 0.25, 0.25)))\n    \ndef max_length(descriptions):\n    lines = to_lines(descriptions)\n    return max(len(d.split()) for d in lines)","506edb5c":"listdir()","287b46c3":"filename = '..\/input\/flickr8k_text\/Flickr_8k.trainImages.txt'\ntrain = load_photo_identifiers(filename)\nprint('Dataset: ', len(train))\ntrain_descriptions = load_clean_descriptions('descriptions.txt', train)\nprint('Descriptions: train=', len(train_descriptions))\ntokenizer = create_tokenizer(train_descriptions)\nvocab_size = len(tokenizer.word_index) + 1\nprint('Vocabulary Size: ', vocab_size)\nmax_length = max_lengthTEMP(train_descriptions)\nprint('Description Length: ,', max_length)\n\nfilename = '..\/input\/flickr8k_text\/Flickr_8k.testImages.txt'\ntest = load_photo_identifiers(filename)\nprint('Dataset: ', len(test))\ntest_descriptions = load_clean_descriptions('descriptions.txt', test)\nprint('Descriptions: test=', len(test_descriptions))\ntest_features = load_photo_features('features.pkl', test)\nprint('Photos: test=', len(test_features))\n\nfilename = 'model_0.h5'\nmodel = load_model(filename)\nevaluate_model(model, test_descriptions, test_features, tokenizer, max_length)","e63a788d":"filename = '..\/input\/flickr8k_text\/Flickr_8k.trainImages.txt'\ntrain = load_photo_identifiers(filename)\nprint('Dataset: ', len(train))\ntrain_descriptions = load_clean_descriptions('descriptions.txt', train)\nprint('Descriptions: train=', len(train_descriptions))\ntokenizer = create_tokenizer(train_descriptions)\ndump(tokenizer, open('tokenizer.pkl', 'wb'))","43e7fa44":"def extract_features(filename):\n    model = VGG16()\n    model.layers.pop()\n    model = Model(inputs=model.inputs, outputs=model.layers[-1].output)\n    image = load_img(filename, target_size=(224, 224))\n    image = img_to_array(image)\n    image = image.reshape((1, image.shape[0], image.shape[1], image.shape[2]))\n    image = preprocess_input(image)\n    feature = model.predict(image, verbose=0)\n    return feature\n\ndef word_for_id(integer, tokenizer):\n    for word, index in tokenizer.word_index.items():\n        if index == integer:\n            return word\n    return None\n\ndef generate_desc(model, tokenizer, photo, max_length):\n    in_text = 'startseq'\n    for i in range(max_length):\n        sequence = tokenizer.texts_to_sequences([in_text])[0]\n        sequence = pad_sequences([sequence], maxlen=max_length)\n        yhat = model.predict([photo,sequence], verbose=0)\n        yhat = argmax(yhat)\n        word = word_for_id(yhat, tokenizer)\n        if word is None:\n            break\n        in_text += ' ' + word\n        if word == 'endseq':\n            break\n    return in_text\n\ntokenizer = load(open('tokenizer.pkl', 'rb'))\nmax_length = 34","2a7220cb":"import matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nmodel = load_model('model_0.h5')\npath = '..\/input\/flickr8k_dataset\/Flicker8k_Dataset\/3016200560_5bf8a70797.jpg'\nphoto = extract_features(path)\n\ndescription = generate_desc(model, tokenizer, photo, max_length)\nprint(description)\nimg=mpimg.imread(path)\nimgplot = plt.imshow(img)\nplt.axis('off')\n\nplt.show()","ac2b95ae":"path = '..\/input\/flickr8k_dataset\/Flicker8k_Dataset\/182493240_40410254b0.jpg'\nphoto = extract_features(path)\n\ndescription = generate_desc(model, tokenizer, photo, max_length)\nprint(description)\nimg=mpimg.imread(path)\nimgplot = plt.imshow(img)\nplt.axis('off')\n\nplt.show()","d47bce2e":"path = '..\/input\/flickr8k_dataset\/Flicker8k_Dataset\/3372214646_cc2ceb182f.jpg'\nphoto = extract_features(path)\n\ndescription = generate_desc(model, tokenizer, photo, max_length)\nprint(description)\nimg=mpimg.imread(path)\nimgplot = plt.imshow(img)\nplt.axis('off')\n\nplt.show()","2543ed0e":"path = '..\/input\/flickr8k_dataset\/Flicker8k_Dataset\/3170897628_3054087f8c.jpg'\nphoto = extract_features(path)\n\ndescription = generate_desc(model, tokenizer, photo, max_length)\nprint(description)\nimg=mpimg.imread(path)\nimgplot = plt.imshow(img)\nplt.axis('off')\n\nplt.show()","3f0b754a":"path = '..\/input\/flickr8k_dataset\/Flicker8k_Dataset\/3532761259_14026c1e96.jpg'\nphoto = extract_features(path)\n\ndescription = generate_desc(model, tokenizer, photo, max_length)\nprint(description)\nimg=mpimg.imread(path)\nimgplot = plt.imshow(img)\nplt.axis('off')\n\nplt.show()","5eb78a0d":"from keras.layers import TimeDistributed\ndef define_model(vocab_size, max_length):\n    \n    # feature extractor model\n    inputs1 = Input(shape=(4096,))\n    fe1 = Dropout(0.5)(inputs1)\n    fe2 = Dense(256, activation='relu')(fe1)\n\n    # sequence model\n    inputs2 = Input(shape=(max_length,))\n    se1 = Embedding(vocab_size, 256, mask_zero=True)(inputs2)\n    se2 = Dropout(0.5)(se1)\n    se3 = LSTM(256)(se2)\n\n    # decoder model\n    decoder1 = TimeDistributed([fe2, se3])\n    decoder2 = TimeDistributed(256, activation='relu')(decoder1)\n    outputs = TimeDistributed(vocab_size, activation='softmax')(decoder2)\n    \n    # tie it together [image, seq] [word]\n    model = Model(inputs=[inputs1, inputs2], outputs=outputs)\n    model.compile(loss='categorical_crossentropy', optimizer='adam')\n    ","f73d8678":"Function to clean the descriptions in the following ways:\n","1a3f92e0":"1. Loading the data","e72bf783":"Developing Deep Learning Model","27898957":"\nSets are highly optimized, don't contain any duplicate values. There implementation is based on hash table. Hence we get a vocabulary that is both expressive and small.","ec1a4e2e":"### Load Libraries","da72b492":" Defining the Model","f819947d":"#### We can now encode the text.\nEach description will be split into words. The model will be provided one word and the photo and generate the next word. Then the first two words of the description will be provided to the model as input with the image to generate the next word. This is how the model will be trained.","27e12b2e":"Function to return a dictionary of photo identifiers to the descriptions"}}