{"cell_type":{"ae51bf86":"code","bba2ffaa":"code","573fb922":"code","4d06850c":"code","1fa3d2bd":"code","c83898f2":"code","4b6a9664":"code","d7dbb507":"code","eb311d95":"code","30a1bc4d":"code","2c304436":"code","3186ed29":"code","3a65f506":"code","a901d76a":"code","aab684e5":"code","0cbf5d4d":"code","960d6ab9":"code","fcaef763":"code","ab122bbf":"code","23a33d12":"code","4a685740":"code","400aaca1":"code","e89c9c72":"code","a62c576e":"markdown","72bf4a3d":"markdown","8edd3ae6":"markdown","4dc68c98":"markdown","4f956c02":"markdown","e9118b85":"markdown","3a955df7":"markdown","81684790":"markdown","2bdbcb25":"markdown","36539ab8":"markdown","8c469fc1":"markdown"},"source":{"ae51bf86":"import os\nimport sys\nfrom collections import Counter\nimport json\nimport cv2\nimport numpy as np\nimport pandas as pd\nfrom tqdm.notebook import tqdm\nfrom matplotlib import pyplot as plt\nfrom PIL import Image\nfrom sklearn.model_selection import train_test_split\n\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Conv2D, MaxPooling2D\nfrom tensorflow.keras.layers import Activation, Dropout, Flatten, Dense\nfrom tensorflow.keras.utils import to_categorical","bba2ffaa":"# What is inside the labels.csv\nDATA_PATH = \"..\/input\/flower-classification-dataset\/\"\ndf = pd.read_csv(os.path.join(DATA_PATH, 'labels.csv'))\ndf.tail()","573fb922":"X = []\ny = []\nfor image, label in tqdm(zip(df.image_id.values, df.category.values), total=len(df)):\n    try:\n        xt = np.array(Image.open(os.path.join(DATA_PATH, f\"files\/{image}.jpg\")).resize((128,128)))\n        yt = label\n        X.append(xt)\n        y.append(yt)\n    except:\n        print(os.path.join(DATA_PATH, f\"files\/{image}.jpg\"))\n    \nX = np.array(X)\ny = np.array(y)\n\nprint(X.shape, y.shape)","4d06850c":"files = os.listdir(os.path.join(DATA_PATH, 'files'))\nprint(f\"The total number of files in the dataset are {len(files)}\")","1fa3d2bd":"# Lets see that the number of images in the dataset equals to the provided labels\nprint(f\"The total number of points in the labels.csv are {len(df)}\")","c83898f2":"train_X, test_X, train_y, test_y = train_test_split(X, y, test_size=0.2)","4b6a9664":"train_y = to_categorical(train_y)\ntest_y = to_categorical(test_y)\n\nprint(train_y.shape, test_y.shape)","d7dbb507":"num_classes = 103","eb311d95":"print(train_X.shape, train_y.shape)","30a1bc4d":"# plot first few images\nplt.figure(figsize=(12,12))\nfor i in range(9):\n    # define subplot\n    plt.subplot(330 + 1 + i)\n    # plot raw pixel data\n    plt.imshow(train_X[i])\n# show the figure\nplt.show()","2c304436":"plt.figure(figsize=(18,6))\ndf[\"category\"].value_counts().plot(kind='bar')","3186ed29":"!rm -rf preview\n!mkdir preview","3a65f506":"datagen = ImageDataGenerator(\n        rotation_range=40,\n        width_shift_range=0.2,\n        height_shift_range=0.2,\n        shear_range=0.2,\n        zoom_range=0.2,\n        horizontal_flip=True,\n        fill_mode='nearest')\n\nimg = load_img(os.path.join(DATA_PATH, f\"files\/0.jpg\"))  # this is a PIL image\nx = img_to_array(img)  # this is a Numpy array with shape (3, 150, 150)\nx = x.reshape((1,) + x.shape)  # this is a Numpy array with shape (1, 3, 150, 150)\n\n# the .flow() command below generates batches of randomly transformed images\n# and saves the results to the `preview\/` directory\ni = 0\nfor batch in datagen.flow(x, batch_size=1,\n                          save_to_dir=\"preview\", save_prefix='f', save_format='jpg'):\n    i += 1\n    if i > 20:\n        break  # otherwise the generator would loop indefinitely","a901d76a":"!ls preview","aab684e5":"x=[]\nfor image in os.listdir('preview'):\n    xt = np.array(Image.open(os.path.join(\"preview\", image)).resize((128,128)))\n    x.append(xt)    \n    \n# plot first few images\nplt.figure(figsize=(12,12))\nfor i in range(9):\n    # define subplot\n    plt.subplot(330 + 1 + i)\n    # plot raw pixel data\n    plt.imshow(x[i])\n# show the figure\nplt.show()","0cbf5d4d":"model = Sequential()\nmodel.add(Conv2D(16, (3, 3), padding='same', activation='relu', input_shape=(128, 128, 3)))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Conv2D(32, (3, 3), padding='same', activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Conv2D(64, (3, 3), padding='same', activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Conv2D(128, (3, 3), padding='same', activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Flatten())\nmodel.add(Dense(512, activation='relu'))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(num_classes, activation='softmax'))\n\nmodel.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])","960d6ab9":"model.summary()","fcaef763":"batch_size = 16\n\n# this is the augmentation configuration we will use for training\ntrain_datagen = ImageDataGenerator(\n        rescale=1.\/255,\n        shear_range=0.2,\n        zoom_range=0.2,\n        horizontal_flip=True)\n\n# this is the augmentation configuration we will use for testing\ntest_datagen = ImageDataGenerator(rescale=1.\/255)","ab122bbf":"train_generator = train_datagen.flow(\n        train_X,\n        train_y,\n        batch_size=batch_size,\n        shuffle=True\n        )  # since we use binary_crossentropy loss, we need binary labels\n\n# this is a similar generator, for validation data\nvalidation_generator = test_datagen.flow(\n        test_X,\n        test_y,\n        shuffle=False,\n        )","23a33d12":"history = model.fit_generator(\n        train_generator,\n        epochs=50,\n        validation_data=validation_generator)","4a685740":"print(history.history.keys())","400aaca1":"# summarize history for accuracy\nplt.plot(history.history['accuracy'])\nplt.plot(history.history['val_accuracy'])\nplt.title('model accuracy')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()","e89c9c72":"# summarize history for loss\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title('model loss')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()","a62c576e":"### Let's explore the class distributions for now","72bf4a3d":"### Exploring images in the dataset","8edd3ae6":"### Exploring the dataset images","4dc68c98":"### Loading the dataset","4f956c02":"## Build Model","e9118b85":"### Spliting the dataset","3a955df7":"## Prepare Data","81684790":"## Plot Training History","2bdbcb25":"## Train Model","36539ab8":"## Understanding Image transformations","8c469fc1":"## Data Augmentation"}}