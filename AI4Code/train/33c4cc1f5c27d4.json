{"cell_type":{"e24965a5":"code","64630149":"code","5870e1f4":"code","129f5320":"code","ac30b148":"code","94704649":"code","a539804c":"code","905c76a4":"code","000f21ca":"code","526de6f2":"code","f5a88bb2":"code","b849de33":"code","3d6e4b39":"code","42521cf7":"markdown","2491fda0":"markdown","7ba3da27":"markdown","b7a3c9cf":"markdown","2d619df8":"markdown","bf46c518":"markdown","b54430af":"markdown","3546d39f":"markdown","e8a1745f":"markdown"},"source":{"e24965a5":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","64630149":"import numpy as np\nimport pandas as pd\nfrom pandasql import sqldf\nimport itertools\nfrom collections import defaultdict\nfrom itertools import permutations,combinations\n","5870e1f4":"data = pd.read_csv('\/kaggle\/input\/marketing-campaign\/marketing.csv')\ndata.dropna(axis = 0, inplace = True)\ndata[\"conversion\"]=data[\"converted\"].astype('int')\ndata.to_csv('marketing-clean.csv',index=False)","129f5320":"\ndata = data[['user_id','date_served','marketing_channel','conversion']]\n\ndata","ac30b148":"#set global funtions\npysqldf = lambda q: sqldf(q, globals())","94704649":"#SQL code for coalitions\n\nq = \"\"\"SELECT channels_subset, sum(b.conversion) as conversion_sum\nFROM(\nSELECT user_id, GROUP_CONCAT(DISTINCT(marketing_channel)) as channels_subset, max(conversion) as conversion\nFROM(\nSELECT user_id,marketing_channel,conversion\nFROM data\nORDER BY user_id,marketing_channel\n) a\nGROUP BY user_id)\nb\nGROUP BY channels_subset;\"\"\"\n\nnames = pysqldf(q)\nnames","a539804c":"def power_set(List):\n    PS = [list(j) for i in range(len(List)) for j in itertools.combinations(List, i+1)]\n    return PS","905c76a4":"def subsets(s):\n    '''\n    This function returns all the possible subsets of a set of channels.\n    input :\n            - s: a set of channels.\n    '''\n    if len(s)==1:\n        return s\n    else:\n        sub_channels=[]\n        for i in range(1,len(s)+1):\n            sub_channels.extend(map(list,itertools.combinations(s, i)))\n    return list(map(\",\".join,map(sorted,sub_channels)))","000f21ca":"def v_function(A,C_values):\n    '''\n    This function computes the worth of each coalition.\n    inputs:\n            - A : a coalition of channels.\n            - C_values : A dictionnary containing the number of conversions that each subset of channels has yielded.\n    '''\n    subsets_of_A = subsets(A)\n    #print(subsets_of_A)\n    #exit()\n    worth_of_A=0\n    for subset in subsets_of_A:\n        #print(\"subset:\", subset)\n        if subset in C_values:\n            #print(\"subset:\", subset, \"; Value:\", C_values[subset])\n            worth_of_A += C_values[subset]\n    return worth_of_A","526de6f2":"def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)","f5a88bb2":"def calculate_shapley(df, col_name):\n    '''\n    This function returns the shapley values\n            - df: A dataframe with the two columns: ['channels_subset', 'conversion_sum'].\n            The channel_subset column is the channel(s) associated with the conversion and the count is the sum of the conversions. \n            - col_name: A string that is the name of the column with conversions\n            **Make sure that that each value in channel_subset is in alphabetical order. Email,PPC and PPC,Email are the same \n            in regards to this analysis and should be combined under Email,PPC.\n            ***Be careful with the distinct number of channels because this can signifcantly slow the perfomance of this function.\n            Remember the total possible combinations of channels is 2^(n) where n is the number of channels. If you have 30 channels\n            this is 1,073,741,824 combinations. \n            \n    '''\n    c_values = df.set_index(\"channels_subset\").to_dict()[col_name]\n    df['channels'] = df['channels_subset'].apply(lambda x: x if len(x.split(\",\")) == 1 else np.nan)\n    channels = list(df['channels'].dropna().unique())\n    \n    v_values = {}\n    for A in power_set(channels):\n        v_values[','.join(sorted(A))] = v_function(A,c_values)\n    #print(v_values)\n    n=len(channels)\n    shapley_values = defaultdict(int)\n\n    for channel in channels:\n        for A in v_values.keys():\n            #print(A)\n            if channel not in A.split(\",\"):\n                #print(channel)\n                cardinal_A=len(A.split(\",\"))\n                A_with_channel = A.split(\",\")\n                A_with_channel.append(channel)            \n                A_with_channel=\",\".join(sorted(A_with_channel))\n                # Weight = |S|!(n-|S|-1)!\/n!\n                weight = (factorial(cardinal_A)*factorial(n-cardinal_A-1)\/factorial(n))\n                # Marginal contribution = v(S U {i})-v(S)\n                contrib = (v_values[A_with_channel]-v_values[A]) \n                shapley_values[channel] += weight * contrib\n        # Add the term corresponding to the empty set\n        shapley_values[channel]+= v_values[channel]\/n \n        \n    return shapley_values","b849de33":"calculate_shapley(names, 'conversion_sum')","3d6e4b39":"data.groupby(data['marketing_channel']).sum()\n\n#df.groupby(by=[\"b\"]).sum()\n","42521cf7":"Create a function that returns all possible combination of the channel\n","2491fda0":"Return all the possible subsets of a set of channels\n","7ba3da27":"**Import Libraries**","b7a3c9cf":"**Ingest Data**","2d619df8":"Thank the smart people at the below link for this code:\nhttps:\/\/medium.com\/analytics-vidhya\/the-shapley-value-approach-to-multi-touch-attribution-marketing-model-e345b35f3359\n\n","bf46c518":"**Reduce Features to Channels \/ Conversions and dates**","b54430af":"Final code here\n","3546d39f":"Calculate the factorial of a number (a non-negative integer)\n","e8a1745f":"Computes the worth of each coalition.\n"}}