{"cell_type":{"bdb5dd1f":"code","2388bb4a":"code","89fdcd2b":"code","59621cc9":"code","fdda1fc3":"code","f2befb43":"code","5abd34c6":"code","5fcd9630":"code","2858128c":"code","e0f1edd5":"code","6aaed16f":"code","44e7cf42":"code","4dadb189":"code","f5af93e7":"code","873c8636":"code","9e0f432b":"code","a3a82257":"code","2911dbcf":"code","caf96822":"code","e772f190":"markdown","3cfdf45c":"markdown","90b0d0e8":"markdown","2cd76c8d":"markdown","313e3ce2":"markdown"},"source":{"bdb5dd1f":"!pip install rasterfairy","2388bb4a":"import glob\nimport random\n\nimport numpy as np\nimport pandas as pd \nfrom PIL import Image\n\nimport tensorflow.keras as keras\nfrom tensorflow.keras.preprocessing import image\nfrom tensorflow.keras.applications.imagenet_utils import preprocess_input\nfrom tensorflow.keras.models import Model\n\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import MiniBatchKMeans\nfrom sklearn.cluster import KMeans\nfrom sklearn.neighbors import NearestNeighbors\nfrom sklearn.preprocessing import MinMaxScaler\n\nimport matplotlib.pyplot as plt\nimport umap\nimport rasterfairy","89fdcd2b":"model = keras.applications.VGG16(weights='imagenet', include_top=True)\n\nfeat_extractor = Model(inputs=model.input, outputs=model.get_layer(\"fc2\").output)\nfeat_extractor.summary()","59621cc9":"images = glob.glob('\/kaggle\/input\/facebook-hateful-meme-dataset\/data\/img\/*.png')\n\nrandom.shuffle(images)\n\nimages = images[:1000]","fdda1fc3":"features = []\nfor i, image_path in enumerate(images):\n    if i % 10 == 0:\n        print(\"analyzed \" + str(i) + \" out of \" + str(len(images)))\n    \n    img = image.load_img(image_path, target_size=model.input_shape[1:3])\n    x = image.img_to_array(img)\n    x = np.expand_dims(x, axis=0)\n    x = preprocess_input(x)\n    feat = feat_extractor.predict(x)[0]\n    features.append(feat)","f2befb43":"ss = StandardScaler()\nscaled = ss.fit_transform(features)","5abd34c6":"sum_squared = []\n\nK = range(1, 200)\n\nfor i in K:\n    print('Calculating ' + str(i))\n    kmeans = MiniBatchKMeans(n_clusters=i)\n    kmeans.fit(scaled)\n    sum_squared.append(kmeans.inertia_)","5fcd9630":"plt.plot(K, sum_squared, 'bx-')\nplt.xlabel('k')\nplt.ylabel('Sum of squared distances')\nplt.title('Elbow Method For Optimal k')\nplt.show()","2858128c":"num_classes = 5\n\nkmeans = KMeans(n_clusters=num_classes)\nclusters = kmeans.fit_predict(scaled)","e0f1edd5":"n = 5\nneighbors = NearestNeighbors(n_neighbors=n, metric='cosine').fit(scaled)\n_, closest = neighbors.kneighbors(kmeans.cluster_centers_)","6aaed16f":"img_width = 200\n\ngrid_image = Image.new('RGB', (5 * img_width, len(closest) * 240), (0, 0, 0, 255))\n\nmax_height = 0\nfor cluster_row in closest:\n    max_height_temp = 0\n    xpos = 0\n    for col_num in cluster_row:\n        img = Image.open(images[col_num])\n        img_ar = img.width \/ img.height\n        img = img.resize((img_width, int(img_width \/ img_ar)), Image.ANTIALIAS)\n        max_height_temp = max(max_height_temp, img.height)\n        grid_image.paste(img, (xpos, max_height))\n        xpos = xpos + img.width\n    max_height = max_height + max_height_temp + 20 # adding 20 pixel margin\n\nplt.figure(figsize = (32,24))\nplt.imshow(grid_image)","44e7cf42":"num_classes = 10\n\nkmeans = KMeans(n_clusters=num_classes)\nclusters = kmeans.fit_predict(scaled)","4dadb189":"n = 5\nneighbors = NearestNeighbors(n_neighbors=n, metric='cosine').fit(scaled)\n_, closest = neighbors.kneighbors(kmeans.cluster_centers_)","f5af93e7":"img_width = 200\n\ngrid_image = Image.new('RGB', (5 * img_width, len(closest) * 240), (0, 0, 0, 255))\n\nmax_height = 0\nfor cluster_row in closest:\n    max_height_temp = 0\n    xpos = 0\n    for col_num in cluster_row:\n        img = Image.open(images[col_num])\n        img_ar = img.width \/ img.height\n        img = img.resize((img_width, int(img_width \/ img_ar)), Image.ANTIALIAS)\n        max_height_temp = max(max_height_temp, img.height)\n        grid_image.paste(img, (xpos, max_height))\n        xpos = xpos + img.width\n    max_height = max_height + max_height_temp + 20 # adding 20 pixel margin\n\nplt.figure(figsize = (32,24))\nplt.imshow(grid_image)","873c8636":"embedding = umap.UMAP().fit_transform(scaled)","9e0f432b":"scaler = MinMaxScaler()\nscaler.fit(embedding)\nembedding_scaled = scaler.transform(embedding)","a3a82257":"width = 4000\nheight = 3000\nmax_dim = 100\n\nfull_image = Image.new('RGBA', (width, height), (0, 0, 0, 255))\nfor img, pos in zip(images, embedding_scaled):\n    x = pos[0]\n    y = pos[1]\n    tile = Image.open(img)\n    rs = max(1, tile.width\/max_dim, tile.height\/max_dim)\n    tile = tile.resize((int(tile.width\/rs), int(tile.height\/rs)), Image.ANTIALIAS)\n    full_image.paste(tile, (int((width-max_dim)*x), int((height-max_dim)*y)), mask=tile.convert('RGBA'))\n\nplt.figure(figsize = (32,24))\nplt.imshow(full_image)","2911dbcf":"nx = 40\nny = 25\n\ngrid_assignment = rasterfairy.transformPointCloud2D(embedding, target=(nx, ny))","caf96822":"tile_width = 100\ntile_height = 100\n\nfull_width = tile_width * nx\nfull_height = tile_height * ny\naspect_ratio = tile_width \/ tile_height\n\ngrid_image = Image.new('RGB', (full_width, full_height), (0, 0, 0, 255))\n\nfor img, grid_pos in zip(images, grid_assignment[0]):\n    idx_x, idx_y = grid_pos\n    x, y = tile_width * idx_x, tile_height * idx_y\n    tile = Image.open(img)\n    tile_ar = tile.width \/ tile.height\n    tile = tile.resize((int(0.8 * tile_width), int(0.8 * tile_height \/ tile_ar)), Image.ANTIALIAS)\n    grid_image.paste(tile, (int(x), int(y)))\n\nplt.figure(figsize = (16,12))\nplt.imshow(grid_image)","e772f190":"# Point Cloud","3cfdf45c":"* ## Experimenting with 10 clusters","90b0d0e8":"# Dimension Reduction","2cd76c8d":"# Clustering","313e3ce2":"* ## Experimenting with  5 clusters"}}