{"cell_type":{"3161e547":"code","af04d021":"code","f7b106b2":"code","76603b99":"code","ff47a11d":"code","50552691":"code","40e8a45a":"code","e44820d5":"code","91ffe155":"code","e65017b2":"code","5f280eb1":"code","0c1e3056":"code","56f3dffb":"code","bc772a0e":"code","7fd1e94b":"markdown","9c86e105":"markdown","4c957947":"markdown","5a20975b":"markdown","22d24ed5":"markdown","e5e15688":"markdown","4bc4d7b4":"markdown","8d1f34b8":"markdown","8da76a03":"markdown","da424584":"markdown","39b114ab":"markdown"},"source":{"3161e547":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nimport random\nimport sys\nimport gc\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport cv2\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split \nfrom sklearn.preprocessing import LabelBinarizer\nimport PIL\nfrom PIL import Image\nfrom IPython.display import SVG\nfrom keras.utils.vis_utils import model_to_dot\n\nimport keras\nfrom keras.applications import ResNet50\nfrom keras import layers\nfrom keras.layers import Dense, Flatten, Conv2D, Dropout, MaxPooling2D, GlobalAveragePooling2D, Dropout\nfrom keras import optimizers\nfrom keras import models\nfrom keras.models import Sequential, Model\nfrom keras import preprocessing\nfrom keras.preprocessing import image\nfrom keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img\nfrom keras.utils import plot_model","af04d021":"img_size = 224\nbatch_size = 32\nepochs = 40\ntrain_size = 0.7\nval_size = 0.2\ntest_size = 0.1\nseed = 4321\nchannels = 3\nlearning_rate = 0.00001","f7b106b2":"d = '..\/input\/tobacco3482-jpg\/Tobacco3482-jpg\/'\nPATH = '..\/'\n\nclasses = (os.listdir(d))\n\npaths = [os.path.join(d, o) for o in os.listdir(d) \n                    if os.path.isdir(os.path.join(d,o))]\n\nnbEntries = []\n\nfor i in range(len(classes)):\n    nbEntries.append(len(os.listdir(paths[i])))\n\n#################################################\n    \nprint(classes)\nprint(nbEntries)\n\ndf = pd.DataFrame({'classes':classes, 'entries':nbEntries})\nax = df.sort_values(by='entries', ascending=True).plot.bar(x='classes', y='entries', color='cornflowerblue',legend=False, figsize=(12,8))\nax.set_title('Tobacco3482 classes Distribution')\nax.set_ylabel(\"# entries\")\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), xy=(p.get_x(), p.get_height()-30))","76603b99":"total_set = []\ntotal_labels = []\n\n\nfor root, dirs, files in os.walk(d):\n    for file in files:\n        if file.endswith(\".jpg\"):\n            path = os.path.join(root, file)\n            total_set.append(path)\n            total_labels.append(root.split(os.path.sep)[-1])\n            \n\n# Return image class based on list entry (path)         \ndef getClass(img):\n    return img.split(os.path.sep)[-2]\n\n\nprint(total_set[0])\nprint('GetClass : ', getClass(total_set[0]))\nprint('Label : ', total_labels[0])","ff47a11d":"random.Random(seed).shuffle(total_set)\n\nfor ima in total_set[0:3] :\n    print(ima)\n    img = mpimg.imread(ima)\n    plt.figure(figsize=(7,7))\n    imgplot = plt.imshow(img, cmap=\"gray\")\n    plt.show()\n","50552691":"# Get data and separate it in sets\ntotal_len = len(total_set)\nindex = 0\n\ntrain_set = []\ntrain_label = []\n\nval_set = []\nval_label = []\n\ntest_set = []\ntest_label = []\n\n\nfor i in total_set[0: int(total_len*train_size)] :\n    train_set.append(i)\n    train_label.append(getClass(i))\n    \nindex = int(total_len*train_size)+1\n    \nfor i in total_set[index: int(index + total_len*val_size)] :\n    val_set.append(i)\n    val_label.append(getClass(i))\n    \nindex = int(index + total_len*val_size)+1 \n\nfor i in total_set[index: total_len] :\n    test_set.append(i)\n    test_label.append(getClass(i))\n\nprint(val_set[200])\nprint(val_label[200])\n","40e8a45a":"#################################################\n# TRAIN SET\ninstances = [0] * len(classes)\nfor index, val in enumerate(classes) :\n    for e in train_set :\n        if(val == getClass(e)) :\n            instances[index] += 1\n\n            \ndf = pd.DataFrame({'classes':classes, 'entries':instances})\nax = df.sort_values(by='entries', ascending=True).plot.bar(x='classes', y='entries', color='cornflowerblue',legend=False, figsize=(12,8))\nax.set_title('Tobacco3482 TRAIN SET Distribution')\nax.set_ylabel(\"# entries\")\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), xy=(p.get_x(), p.get_height()-20))\n\n#################################################\n# VAL SET\ninstances = [0] * len(classes)\nfor index, val in enumerate(classes) :\n    for e in val_set :\n        if(val == getClass(e)) :\n            instances[index] += 1\n\n            \ndf = pd.DataFrame({'classes':classes, 'entries':instances})\nax = df.sort_values(by='entries', ascending=True).plot.bar(x='classes', y='entries', color='cornflowerblue',legend=False, figsize=(12,8))\nax.set_title('Tobacco3482 VAL SET Distribution')\nax.set_ylabel(\"# entries\")\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), xy=(p.get_x(), p.get_height()-3))\n    \n#################################################\n# TEST SET\ninstances = [0] * len(classes)\nfor index, val in enumerate(classes) :\n    for e in test_set :\n        if(val == getClass(e)) :\n            instances[index] += 1\n\n            \ndf = pd.DataFrame({'classes':classes, 'entries':instances})\nax = df.sort_values(by='entries', ascending=True).plot.bar(x='classes', y='entries', color='cornflowerblue',legend=False, figsize=(12,8))\nax.set_title('Tobacco3482 TEST SET Distribution')\nax.set_ylabel(\"# entries\")\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), xy=(p.get_x(), p.get_height()-8))","e44820d5":"def process_images(img_set) : \n    processed_img = []\n\n    for i in range(len(img_set)) :\n        processed_img.append(cv2.resize(cv2.imread(img_set[i], cv2.IMREAD_COLOR), (img_size, img_size)))\n    \n    return processed_img\n    \nx_train = process_images(train_set)\nx_test = process_images(test_set)\nx_val = process_images(val_set)","91ffe155":"lb = LabelBinarizer()\nlb.fit(list(classes))\n\nx_train = np.array(x_train)\ny_train =lb.transform(np.array(train_label))\n\nx_test = np.array(x_test)\ny_test = lb.transform(np.array(test_label))\n\nx_val = np.array(x_val)\ny_val = lb.transform(np.array(val_label))\n\nprint(\"train shape : \", x_train.shape)\nprint(y_train.shape)\nprint(\"test shape : \", x_test.shape)\nprint(y_test.shape)\nprint(\"valdiation shape : \", x_val.shape)\nprint(y_val.shape)\n\n\nfor i in range(3) :\n    plt.figure(figsize=(6,6))\n    imgplot = plt.imshow(x_train[i])\n\nprint(train_label[0])\nprint(y_train[0])\nprint(lb.classes_)","e65017b2":"base_model = ResNet50(weights = \"imagenet\", include_top=False, input_shape = (img_size, img_size, channels))\n\n#for layer in base_model.layers:\n#    layer.trainable = False\n    \nbase_model.summary()","5f280eb1":"model = models.Sequential()\n\nmodel.add(base_model)\nmodel.add(layers.Flatten())\nmodel.add(layers.Dense(128, activation='relu',  name='dense'))\nmodel.add(layers.Dropout(0.5))\nmodel.add(layers.Dense(len(classes), activation='softmax',  name='predictions'))\n\nmodel.summary()\n\nprint('Number of trainable weights : ', len(model.trainable_weights))\n\nplot_model(model, to_file='model.png')\nSVG(model_to_dot(model).create(prog='dot', format='svg'))","0c1e3056":"model.compile(optimizer=optimizers.Adam(lr=learning_rate), loss='categorical_crossentropy', metrics=['accuracy'])\n\ntrain_model = model.fit(x_train, y_train,\n                        batch_size=batch_size,\n                        epochs=epochs,\n                        verbose=1,\n                        validation_data=(x_val, y_val))","56f3dffb":"plt.plot(train_model.history['loss'])\nplt.plot(train_model.history['val_loss'])\nplt.title('model loss')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.grid()\nplt.legend(['training loss', 'validation loss'], loc='upper right')\nplt.show()\n\nplt.plot(train_model.history['acc'])\nplt.plot(train_model.history['val_acc'])\nplt.title('model accuracy')\nplt.grid()\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(['training accuracy', 'validation accuracy'], loc='lower right')\nplt.show()","bc772a0e":"score = model.evaluate(x_test, y_test, verbose=1)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","7fd1e94b":"# Sorting data in usable sets\n![](https:\/\/cdn-images-1.medium.com\/max\/800\/1*HpvpA9pBJXKxaPCl5tKnLg.jpeg)","9c86e105":"# Get all images","4c957947":"# Get classes and entries per classes","5a20975b":"# Global variables","22d24ed5":"# Preprocess data (resize and transform to Numpy array)","e5e15688":"# Plot data ","4bc4d7b4":"# Imports","8d1f34b8":"# Creating model (pretrained CNN)","8da76a03":"# Test prediction accuracy","da424584":"# Plot accuracy and loss","39b114ab":"# Visualize classes distribution"}}