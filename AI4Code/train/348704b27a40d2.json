{"cell_type":{"9df9752b":"code","9784ef22":"code","3cfc235a":"code","59d1ccc9":"code","b079a8b1":"code","56e176f4":"code","2429c332":"code","cff542ca":"code","b4b45813":"code","7ace5f52":"code","f72d0ec4":"code","7180c2d6":"code","d5999df2":"code","741fdfb0":"code","6d53e2b1":"code","ba39bc3a":"code","5a57c14f":"code","6ddb3087":"code","ef3cf688":"code","ccc275de":"code","f8b9a635":"code","360c41f4":"code","fa1b2d2d":"code","732c71d1":"code","bc75a06a":"code","e5f80bc4":"code","5f59d926":"code","bf4a87c1":"code","b8c42ef4":"code","33f8ceb3":"code","29c5bcc8":"code","9b5ac9d9":"code","20ef9f0a":"code","cd8894c9":"markdown","24e9e201":"markdown","22610cab":"markdown","cf64a7a3":"markdown","fa0595d7":"markdown","c5519058":"markdown","8a2ef723":"markdown","773f5971":"markdown","113f2078":"markdown","9fccdf7f":"markdown","66b0485f":"markdown","ab0f30eb":"markdown","685f06b2":"markdown","f2117240":"markdown","57ff4b53":"markdown","a8cebc91":"markdown","5d741e86":"markdown","173bb4fb":"markdown","f7968724":"markdown","51fe46c9":"markdown","a0d1300f":"markdown"},"source":{"9df9752b":"import pandas as pd\nimport numpy as np\nimport math\n\nfrom datetime import timedelta\n\nfrom scipy.optimize import curve_fit\nfrom scipy.integrate import odeint\nfrom scipy.interpolate import interp1d\nfrom IPython.core.debugger import set_trace\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nplt.style.use('default')","9784ef22":" !rm -rf COVID-19 \n !git init \n root_git = 'https:\/\/github.com\/CSSEGISandData\/COVID-19.git'\n !git clone $root_git\n !git pull '.\/COVID-19'","3cfc235a":"data_dir = '.\/COVID-19\/csse_covid_19_data\/csse_covid_19_time_series\/'","59d1ccc9":"# !ls -alrth $data_dir","b079a8b1":"### Loading the data\nrename = {'Country\/Region': 'zone', \n          'Province\/State': 'sub_zone'}\n\ndf_recovery = pd.read_csv(data_dir + 'time_series_covid19_recovered_global.csv').rename(columns=rename)\ndf_deaths = pd.read_csv(data_dir + 'time_series_covid19_deaths_global.csv').rename(columns=rename)\ndf_confirmed = pd.read_csv(data_dir + 'time_series_covid19_confirmed_global.csv').rename(columns=rename)\nprint(df_confirmed.shape)\ndf_confirmed.head(100).T.head().T","56e176f4":"rename = {'Country\/Region': 'zone', \n          'Province\/States': 'sub_zone'}\ndata_dir_who ='.\/COVID-19\/who_covid_19_situation_reports\/who_covid_19_sit_rep_time_series\/'\ndf_confirmed_who = pd.read_csv(data_dir_who + 'who_covid_19_sit_rep_time_series.csv').rename(columns=rename)\nprint(df_confirmed_who.shape)\ndf_confirmed_who.head(100).T.head().T","2429c332":"zones = ['China','Korea, South', 'Italy', 'Iran', 'France', 'Spain','US', 'United Kingdom']\n#print(df_confirmed.zone.unique())\n#[sz for sz in df_confirmed.zone if sz in zones]\n\ndef clean_df(df):\n  df = df.sum(axis=0)\n  df = df[[d for d in df.index if d.find('\/')>0]].T\n  df.index = pd.to_datetime(df.index)\n  return df\n\ndef extract_cols(df, zones):\n  dic_comp = {\n      z: clean_df(df.query(\"zone == '{zone}'\".format(zone=z))) for z in zones}\n  return pd.DataFrame(dic_comp)\n\ndf_select_conf = extract_cols(df_confirmed, zones=zones)\ndf_select_conf_who = extract_cols(df_confirmed_who, zones=zones)\ndf_select_death = extract_cols(df_deaths, zones=zones)\ndf_select_reco = extract_cols(df_recovery, zones=zones)\npd.merge(df_select_conf, df_select_death,\n             left_index=True, right_index=True,\n             how='outer', suffixes=(' new cases', ' new death')).diff().tail()","cff542ca":"lag_onset_death = 15  ## estimate as reported by WHO\nlag_onset_recovery = 21 ## estimate as reported by WHO","b4b45813":"df_select_death.shift(-lag_onset_death) # deaths today must have been confirmed lag days before\ndf_select_reco.shift(-lag_onset_recovery)  # recovered today must have been confirmed lag days before","7ace5f52":"### CFR\n## estimate using last x data points from China\nfit_points = 110\ndeath_rate_estimate_conf = (df_select_death.shift(-lag_onset_death\\\n                                                 )\/df_select_conf.replace(0,np.nan))[\\\n                                                -fit_points-lag_onset_death:-lag_onset_death] ##estimate from confirmed cases\n","f72d0ec4":"death_rate_estimate_closed = (df_select_death.shift(-lag_onset_death\\\n                                                   )\/(df_select_death.shift(-lag_onset_death)+\\\n                                                      df_select_reco.shift(-lag_onset_recovery)).replace(\\\n                                                        0, np.nan))[-fit_points -lag_onset_recovery:\\\n                                                                    -lag_onset_recovery] ##estimate from closes cases\n","7180c2d6":"### Fitting a curve to mortality rate\ndef func(x, a, b, c):\n    return a * np.exp(-b * x) + c\n#   return a * np.log(b * x) + c\n\ndef func2(x, a, b, c):\n    return a * (2**(-b * x)) + c\n\npopt, pcov = curve_fit(func, range(fit_points), [np.log(death_rate_estimate_conf['China'].iloc[x]) for x in range(fit_points)])\n\npopt2, pcov2 = curve_fit(func2, range(len(death_rate_estimate_closed['China'])), death_rate_estimate_closed['China'])","d5999df2":"plt.figure(figsize=(10,8))\n\nax1 = plt.subplot(1, 1, 1)\nplt.title('Fatality Rate by confirmed vs closed cases in China', size=18)\n\nplt.plot(range(len(death_rate_estimate_closed['China'])), death_rate_estimate_closed['China'], 'bo', label='Closed')\nplt.plot(range(fit_points), np.exp(func(range(fit_points), *popt)), 'r--', label=\"Fitted Curve\")\n# Plots the data\nplt.plot(range(len(death_rate_estimate_conf['China'])), death_rate_estimate_conf['China'], 'ko', alpha=.65, label='Confirmed')\nplt.plot(range(fit_points), func2(range(fit_points), *popt2), 'g--', label=\"Fitted Curve\")\nplt.legend()","741fdfb0":"asymptotic_fatality_rate = (np.exp(func(100, *popt)) + func2(100, *popt2))\/2.0\nasymptotic_fatality_rate","6d53e2b1":"date_cutoff = '2020-02-22'\npopt3, pcov3 = curve_fit(func2, range(len(death_rate_estimate_conf.loc[date_cutoff:,'Korea, South'])),\\\n                         death_rate_estimate_conf.loc[date_cutoff:,'Korea, South'])","ba39bc3a":"\nplt.figure(figsize=(14,8))\n\nax1 = plt.subplot(1, 1, 1)\nplt.title('Infection Fatality Rate by confirmed cases in Korea after Patient 31', size=18)\n\n# plt.plot(death_rate_estimate_closed['Korea, South'], lw=2, alpha=.75, label='Closed')\n# # Plots the data\nplt.plot(range(len(death_rate_estimate_conf.loc[date_cutoff:,'Korea, South'])),death_rate_estimate_conf.loc[date_cutoff:,'Korea, South'], 'Pr', alpha=.65, label='Confirmed')\nplt.plot(range(150), func2(range(150), *popt3), 'g--', label=\"Fitted Curve\")\nplt.legend()","5a57c14f":"cCFR = asymptotic_fatality_rate\nIFR = func2(100, *popt3)\ncCFR, IFR","6ddb3087":"### estimates as reported by WHO\nsymptom_onset_to_death = lag_onset_death\nsymptom_onset_to_death_lb = 13.1\nsymptom_onset_to_death_ub = 17.7\ndoubling_time = 6.2\ndoubling_time_lb = 5.8\ndoubling_time_ub = 7.1\nincubation_period = 5","ef3cf688":"# The SEIR model differential equations.\ndef seir_deriv(y, t, N, beta1, beta2, alpha, epsilon, delta, zeta, eta, cCFR):\n#     alpha = 1\/incubation_period\n#     delta = 1\/lag_onset_death\n#     zeta = 1\/lag_onset_recovery\n#     eta = 1\/lag_onset_recovery\n    S, E, Ir, D, C, Iu, Cu= y\n    dSdt = -((beta1 * Iu) + (beta2 * Ir)) * S \/ N # Susecptible\n    dEdt = ((beta1 * Iu) + (beta2 * Ir)) * S \/ N - alpha * E # Exposed\n    dIudt = (1-epsilon) * alpha * E - eta * Iu # Infected but unreported\n    dCudt = eta * Iu # Cured but unreported\n    dIrdt = epsilon * alpha * E - delta * cCFR * Ir - zeta * (1-cCFR) * Ir # Infected and reported\n    dDdt = delta * cCFR * Ir # Deaths\n    dCdt = zeta *(1-cCFR) * Ir # Reported and Cured\n    return dSdt, dEdt, dIrdt, dDdt, dCdt, dIudt, dCudt","ccc275de":"### Function to setup the evolution for these models\ndef setup_SEIR(beta1, beta2, alpha, delta, zeta, cCFR, E0, S0, Iu0, N, df_conf, df_reco, df_death, t0, forward, generating_curve = False):\n    if generating_curve:\n        Ir0 = df_conf.iloc[-1] - df_reco.iloc[-1] - df_death.iloc[-1]\n        D0 = df_death.iloc[-1]\n        C0 = df_reco.iloc[-1]\n    else:\n        Ir0 = df_conf.iloc[0] - df_reco.iloc[0] - df_death.iloc[0]\n        D0 = df_death.iloc[0]\n        C0 = df_reco.iloc[0]\n    Cu0 = 0.1*Iu0\n\ndef setup_SEIR(beta1, beta2, alpha, epsilon, delta, zeta, eta, cCFR,\\\n               N, df_conf, df_reco, df_death, t0, IFR, forward, generating_curve = False):\n    \n    if generating_curve: ##generate from 15 days prior to today\n        D0 = df_death.iloc[-16] # intial number of deaths we know\n        C0 = max(df_reco.iloc[-16], .10*df_conf.iloc[-16])   # intial number of recoveries we know\n        Ir0 = df_conf.iloc[-16] - D0 - C0 ## initial reported infections\n\n        Iu0 = df_death.iloc[-1]\/IFR - Ir0 ## estimate unreported infections based on deaths in 15 days\n        Cu0 = np.maximum(0, df_death.iloc[-16]\/IFR - df_conf.iloc[-16]) ## assume everybody unreported from 15 days prior is recovered\n        E0 =30*df_conf.iloc[-16]\n    else:\n        # We use an optimization method to best fit these numbers \n        D0 = df_death.iloc[0] # intial number of deaths we know\n        C0 = max(df_reco.iloc[0], .10*df_conf.iloc[0])  # intial number of recoveries we know\n        Ir0 = df_conf.iloc[0] - D0 - C0 ## initial reported infections\n        Cu0 = np.maximum(0, df_death.iloc[0]\/IFR - df_conf.iloc[0]) ## assume everybody unreported from 15 days prior is recovered\n        Iu0 = 10*Cu0#df_death.iloc[15]\/IFR - Ir0 ## estimate unreported infections based on deaths in 15 days\n        E0 =30*df_conf.iloc[0]\n    S0 = N - E0 - Ir0 - Iu0 - C0 - D0 - Cu0 # rest are susceptible\n    \n                                          \n    # Initial conditions vector\n    y0 = S0, E0, Ir0, D0, C0, Iu0, Cu0\n#     print('Initial S0, E0, Ir0, D0, C0, Iu0, Cu0')\n#     print(y0)\n\n    forward_period = len(df_death) + forward\n    # A grid of time points (in days)\n    t = np.linspace(0, forward_period, forward_period)\n\n    # Integrate the SIR equations over the time grid, t.\n    ret = odeint(seir_deriv, y0, t, args=(N, beta1, beta2, alpha, epsilon, delta, zeta, eta, cCFR))\n    S, E, Ir, D, C, Iu, Cu0= ret.T\n    return S, E, Ir, D, C, Iu, Cu0, forward_period","f8b9a635":"### Function to calculate residuals for estimating parameters\nfrom scipy import optimize\n\ndef resid_seir(params, N, df_conf, df_reco, df_death, t0, IFR):\n    S, E, Ir, D, C, Iu, Cu0, _ = setup_SEIR(params[0], params[1], params[2], params[3], \n                                            params[4], params[5], params[6], params[7],\n                                            N, df_conf, df_reco, df_death, t0, IFR,0)\n    true_Ir = df_conf - df_reco - df_death\n    true_D = df_death\n    true_C = df_reco\n    fit_days = len(true_D)\n    return np.nan_to_num(np.array((\n#                                    np.abs(((Ir)[:len(true_Ir)] - true_Ir)) + \\\n                                   .3* np.abs(((Ir+D+C)[:len(true_Ir)] - df_conf)) + \\\n#                                     .5*np.abs((C[:len(true_C)] - true_C)) + \\\n                                   np.abs((D[len(true_D)-fit_days:len(true_D)]-true_D.iloc[-fit_days:]))+ \\\n                                 0)).astype(float))","360c41f4":"## Functions for plotting curves\ndef plot_curves_seir(t0, forward_period, Ir, E, D, C, true_Ir, true_D, true_C, Iu, Iu_long, Ir_long, D_long):\n    sim_dates = pd.date_range(start=t0, periods=(forward_period))\n    sim_dates2 = pd.date_range(start=t0, periods=(len(Iu_long)))\n    \n    fig = plt.figure(figsize=(10, 32))\n    ax1 = fig.add_subplot(811)  # , axis_bgcolor='#dddddd', axisbelow=True)\n\n    ax1.plot(sim_dates, Ir, 'b', alpha=0.5, lw=2, label='Projected Reported Active Infections')\n    ax1.plot(true_Ir.loc[t0:], \\\n             'ko', markersize=8, label='Reported Active Infections')\n\n    ax2 = fig.add_subplot(812)\n    ax2.plot(sim_dates, D, 'g', alpha=0.5, lw=2, label='Projected Deaths')\n    ax2.plot(true_D, \\\n             'ko', markersize=8, label='Reported Deaths')\n\n    ax3 = fig.add_subplot(813)\n    ax3.plot(sim_dates, Ir+D+C, 'r', alpha=0.5, lw=2, label='Projected Confirmed Cases')\n    ax3.plot(true_Ir+ true_D + true_C, \\\n             'ko', markersize=8, label='Reported Confirmed Cases')\n\n    ax4 = fig.add_subplot(814)\n    ax4.plot(sim_dates2, (Iu_long + Ir_long), 'k', alpha=0.5, lw=2, label='Projected Total Infections')\n    ax4.plot(sim_dates2, (Ir_long), 'g', alpha=0.5, lw=2, label='Projected reported Infections')\n    \n    \n    ax5 = fig.add_subplot(815)\n    ax5.plot(sim_dates2, (Ir_long), 'g', alpha=0.5, lw=2, label='Long Term Reported Infections')\n\n\n    ax6 = fig.add_subplot(816)\n    ax6.plot(sim_dates2, (Ir_long), 'g', alpha=0.5, lw=2, label='Projected reported Infections')\n    ax6.plot(sim_dates2, (D_long), 'b', alpha=0.5, lw=2, label='Long Term Death')\n    \n    ax7  = fig.add_subplot(817)\n    ax7.plot(sim_dates, Ir, 'b', alpha=0.5, lw=2, label='Projected Reported Active Infections')\n    ax7.plot(sim_dates, Iu, 'm', alpha=0.5, lw=2, label='Projected Unreported Active Infections')\n    ax7.plot(sim_dates, D, 'g', alpha=0.5, lw=2, label='Projected Deaths')\n    ax7.plot(sim_dates, C, 'r', alpha=0.5, lw=2, label='Projected Recoverd')\n    ax7.plot(sim_dates, (E), 'k', alpha=0.5, lw=2, label='Projected Exposed')\n    \n    ax8  = fig.add_subplot(818)\n    ax8.plot(sim_dates2, Ir_long, 'b', alpha=0.5, lw=2, label='Projected Reported Active Infections')\n    ax8.plot(sim_dates2, Iu_long, 'm', alpha=0.5, lw=2, label='Projected Unreported Active Infections')\n    ax8.plot(sim_dates2, D_long, 'g', alpha=0.5, lw=2, label='Projected Deaths')\n    ax8.plot(sim_dates2, C_long, 'r', alpha=0.5, lw=2, label='Projected Recoverd')\n    ax8.plot(sim_dates2, E_long, 'k', alpha=0.5, lw=2, label='Projected Exposed')\n\n    for ax in [ax1, ax2, ax3, ax4, ax5, ax6, ax7, ax8]:\n        ax.set_xlabel('Dates')\n        ax.set_ylabel('Population')\n        ax.yaxis.set_tick_params(length=0)\n        ax.xaxis.set_tick_params(length=0)\n        ax.grid(b=True, which='major', c='w', lw=2, ls='-')\n        legend = ax.legend()\n        legend.get_frame().set_alpha(0.5)\n        for spine in ('top', 'right', 'bottom', 'left'):\n            ax.spines[spine].set_visible(False)\n","fa1b2d2d":"country = 'United Kingdom'\n\npopulation_map = {'China' : 1400000000,\n                 'Korea, South' : 51500000,\n                'Italy': 60550000,\n                'Iran': 80000000,\n                'France': 67000000,\n                'Spain': 46700000,\n                'US': 327000000,\n                'United Kingdom': 66400000,\n                  'Belgium':11400000,\n                'Austria':8820000,\n                  'India':1250000000,\n}\n\nN = .7*population_map[country]","732c71d1":"df_conf_all = clean_df(df_confirmed[(df_confirmed['zone']==country) ])\ndf_reco_all = clean_df(df_recovery[(df_recovery['zone']==country) ])\ndf_death_all = clean_df(df_deaths[(df_deaths['zone']==country) ])","bc75a06a":"t0 = df_death_all[df_death_all>29999].index[0]#df_hubei_conf[df_hubei_conf>2].index[0]\ndf_conf = df_conf_all.loc[df_conf_all.index>=t0]\ndf_reco = df_reco_all.loc[df_reco_all.index>=t0]\ndf_death = df_death_all.loc[df_death_all.index>=t0]\n","e5f80bc4":"t0, len(df_conf), df_conf.iloc[0], df_reco.iloc[0], df_death.iloc[0]","5f59d926":"# Contact rate, beta, and mean recovery rate, gamma, (in 1\/days).\nR = 2.68\ngamma = 1\/lag_onset_death\ngrowth_rate = 2**(1\/doubling_time) - 1\nbeta = R*gamma#(growth_rate + gamma)\nrelative_contact_rate = 0\nbeta = beta * (1-relative_contact_rate) \n","bf4a87c1":"# N = 58000000\nincubation_period = 5\nprint('Population: ',N)\nbeta1= beta\nbeta2 = beta\nalpha = 1\/incubation_period\nepsilon = 0.2\ndelta = 1\/lag_onset_death\nzeta = 1\/lag_onset_recovery\neta = 1\/lag_onset_recovery\nprint('Initial Estimates')\nprint('beta1, beta2, alpha, epsilon, delta, zeta, eta, cCFR')\nprint('%.3f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f'%(beta1, beta2, alpha, epsilon, delta, zeta, eta, cCFR))\nE_up = N - df_conf.iloc[0]\nS_up = N - df_conf.iloc[0]\nCu_up = N - df_conf.iloc[0]\n\nres = optimize.least_squares(resid_seir, [beta1, beta2, alpha, epsilon, delta, zeta, eta, cCFR], \n                                 bounds=([0.05, 0.01, 1\/6.0, 0.01, 1\/21, 1\/25, 1\/25, 0.03], \\\n                                        [0.25, 0.2, 1\/4.0, .95, 1\/10, 1\/21, 1\/21, 0.150]),\\\n                             loss='linear', xtol = 3e-16, ftol = 3e-16,\\\n                             args=(N, df_conf, df_reco, df_death, t0, IFR))\n#beta1, beta2, alpha, epsilon, delta, zeta, eta, cCFR)\n# try: guass newton or bfgs\n# try calc gradient or hessian","b8c42ef4":"### check parameters\nres['x']","33f8ceb3":"print('Final Estimates')\nprint('R0_1, R0_2, incubation period, epsilon, time_to_death, time_to_recovery, time_to_recovery, cCFR')\nprint('%.3f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f'\\\n      %(res['x'][0]\/gamma, res['x'][1]\/gamma, 1\/res['x'][2],\\\n        res['x'][3], 1\/res['x'][4], 1\/res['x'][5], 1\/res['x'][6], res['x'][7]))","29c5bcc8":"S, E, Ir, D, C, Iu, Cu, _ = setup_SEIR(res['x'][0], res['x'][1], res['x'][2], res['x'][3],\n                                       res['x'][4], res['x'][5], res['x'][6], res['x'][7],\n                                       N, df_conf, df_reco, df_death, t0, IFR,0)\n# plt.plot(Ir)\ndistancing = 0\nS_long, E_long, Ir_long, D_long, C_long, Iu_long, Cu_long, _ = setup_SEIR(res['x'][0]*(1-distancing), \n                                                                          res['x'][1]*(1-distancing), \n                                                                          res['x'][2], res['x'][3],\n                                                                   res['x'][4], res['x'][5], res['x'][6], res['x'][7],\n                                                                   N, df_conf, df_reco, df_death, t0, IFR,180, generating_curve=True)\nplt.plot(Cu_long)\n","9b5ac9d9":"true_C = df_reco\ntrue_D = df_death\ntrue_R = true_C + true_D\ntrue_Ir = df_conf- true_R#\n%matplotlib inline\n\nforward_period = len(df_conf)\nplot_curves_seir(df_conf.index[0], forward_period, Ir, E, D, C, true_Ir, true_D, true_C, Iu, Iu_long, Ir_long, D_long)","20ef9f0a":"print('Estimated Final Infection Mortality Rate is: %.3f'%(D_long[-1]\/(C_long[-1]+D_long[-1]+Cu_long[-1])))\nprint('Estimated Final Observed Mortality Rate is: %.3f'%(D_long[-1]\/(C_long[-1]+D_long[-1])))\nprint('Estimated Final Deaths are: %i'%(D_long[-1]))","cd8894c9":"### Fitting model to current data\nWe now fit this model to the Reported deaths and Reported confirmed cases data we have so far on a country. At the moment, we are using WHO's estimates of incubation_period (5 days), time_to_death (15 days), and time_to_recovery (21 days) to fix $\\alpha$, $\\delta$, $\\eta$  and  $\\zeta$. We then fit the model to estimate $\\beta_1$, $\\beta_2$, $\\epsilon$ and $cCFR$\n\nThe function returned below is the residual, which is the loss function we're minimising in the fitting process. You can see that here we are fitting to confirmed cases and number of deaths.  You can change what data is being used to calculate the fit, or the ratio in which they're used. We recommend not fitting to recovery data as this is very low quality","24e9e201":"### Calculating mortality estimate from closed cases (CFR)\n","22610cab":"### Downloading and preparing the data\n\nWe are using the John Hopkins repository to get the data for number of infections and deaths.\n\nIf running this notebook for the first time, you will need to uncomment this next section to clone the github repo.","cf64a7a3":"### Fitting our modified SEIR to different countries\n\nFirst we are going to add some information on some of the countries we are interested in modelling. We can add other countries here as well.\n\nWe also want to limit the model to only train after the 10th death. The reason for this decision is that early infection data will be highly affected by noise and individual variation. By making the model wait untill this point to start the fitting process we're hoping to get a better fit to the underlying dynamics.","fa0595d7":"# Auquan & The HELP Project's Modified SEIR model to forecast coronavirus infection peaks \n\n## Introduction\nIn March my company Auquan began working on a community project to model coronavirus infections and predict future impact. Initially the scope was just to model the health impacts (deaths, infections, critical care capacity), but we are now working to create a unified model for explaining the health and economic impacts of different lockdown exit strategies. The disease model that we created is, as far as I'm aware, the only community created disease model to be used by the CDC (Center for Disease Control in the US) as part of there ensemble forcasting model. \n\n**You can see the CDC ensemble components here:** https:\/\/www.cdc.gov\/coronavirus\/2019-ncov\/covid-data\/forecasting-us.html\n\n**You can see the final version of our model here:** https:\/\/covid19-infection-model.auquan.com\/\nI would encourage you to select different countries \/ adjust the parameters to see how the virus impact changes.\n\nAs this is a community effort that aims to share information with people, we've decided to release this notebook containing an early version of the CDC model free to all. This notebook doesn't contains the exact CDC model as we've iterated from here a couple times and added complexity. It is the same structure and details our modified SEIR approach, so hopefully shows some of the stages required to create a robust disease model.\n\nThe community effort currently contains people from diverse companies such as Google, Microsoft, Goldman Sachs, Startups and Acedemia. If you're interested in helping work on this community effort, there are more details and a signup form here: **https:\/\/links.quant-quest.com\/helpproject**\n\nThe full credit for this effort goes to the whole team, but especially [Chandini](https:\/\/www.linkedin.com\/in\/chandinijain\/) & [Vishal](https:\/\/www.linkedin.com\/in\/vishaltomar28\/) for their massive input on this specific model. \n\nDavid\n\n----\n\n# Notebook\n\nIn this notebook, we are going to build a model to predict the actual number of infected people at any given point in any given geography based on current deceased cases, population of the country and virus spread\n\nParameters for virus spread is copied from here: https:\/\/github.com\/midas-network\/COVID-19\/tree\/master\/parameter_estimates\/2019_novel_coronavirus\n\nWe will use this to further predict lockdowns or policy actions and impact on portfolio","c5519058":"### Only fit to datapoints after tenth death - fit to lst 14 to 21 days\n\nHere we are fiiting to all data after the 10th death. This isn't the best way to do this as the model parameters change over time (due to government intervention such a social distancing). In our final model we train over the previous 2 weeks data. This is something you can experiment with.","8a2ef723":"### Loading the data\n\nHere we're just making some small changes to the format of the data from the CSV and changing the names to make them smaller.","773f5971":"We see that the two rates converge. We take the average value as asymptotic cCFR","113f2078":"### Our estimates of cCFR and IFR (these will be used later in the model)","9fccdf7f":"### Implementing our modified SEIR model\n\nFirst, we need to recreate the SEIR model differential equations from above.","66b0485f":"### IFR estimate from confirmed cases in Korea\n\nHere we're going to use data from South Korea as they were the first to introduce widespread population testing to identify COVID-19. We make sure to only consider data after this program was rolled out.","ab0f30eb":"### Defining our modified SEIR model\n\nWe use a modified SEIR for modeling the COVID-19 disease dynamics. A typical SEIR model breaks $N$, the total population, into four comparments.\n- S Susceptible\n- E Exposed\n- I Infected\n- R Recovered\n\nWe modify the model by breaking down infected category, $I$ into two:\n- the reported number of infections, I<sub>r<\/sub>\n- the unreported number of infections, I<sub>u<\/sub>\n\nThis is because testing is different across countries and a lot of countries are not doing enough tests. Additionally, people who are reported to be infected don't have the same rate of infecting others as the unreported infections. So use different $\\beta$ parameters for these classes. We also break down the recovered class, $R$ into deaths $D$ and cured $C$. We assume that all the unreported infections only get cured (C<sub>u<\/sub>) because if they were to develop serious symptoms they would probably get reported.\nThe model parameters are:\n\n- N Total Population\n- S Susceptible\n- E Exposed\n- I<sub>u<\/sub> Infected Unreported\n- I<sub>r<\/sub> Infected reported\n- C<sub>u<\/sub> Cured unreported\n- C Cured reported\n- D Death reported\n- $\\beta_1$ = the average number of contacts per infected person (reported) per time. Typical time between contacts is  Tc2 = 1\/ $\\beta_1$ \n- $\\beta_2$ = the average number of contacts per infected person (unreported) per time. Typical time between contacts is  Tc2 = 1\/ $\\beta_2$ \n- $\\alpha$ = $1\/incubation_period$, Time it takes for a person to become infectious after exposure to virus\n- $\\epsilon$ Ratio of exposed people who show symptoms and are reported as infectious\n- $\\delta$ = 1\/time_to_death, Time it takes for an reported infected person to die\n- $\\eta$ = 1\/time_to_recovery_unreported, Time it takes for an unreported infected person to recover\n- $\\zeta$ = 1\/time_to_recovery_reported, Time it takes for an reported infected person to recover\n\nThe differential equation governing this model are:\n\n$\\frac{dS}{dt}= -(\\beta_1 I_r + \\beta_2 I_u) * \\frac{S}{N}$\n\n$\\frac{dE}{dt}= (\\beta_1 I_r + \\beta_2 I_u) * \\frac{S}{N} - \\alpha * E$\n\n$\\frac{Ir}{dt}= \\epsilon * \\alpha * E - \\delta * cCFR * I_r - \\zeta * (1 - cCFR) * I_r$\n\n$\\frac{Iu}{dt}= (1 - \\epsilon) * \\alpha * E - \\eta * I_u$\n\n$\\frac{dD}{dt}= \\delta * cCFR * I_r$\n\n$\\frac{dC}{dt}= \\zeta * (1 - cCFR) * I_r$\n\n$\\frac{dCu}{dt}= \\eta * I_u$\n\nThe function below describes the dynamics of this model","685f06b2":"### Run simulation using optimum parameters derived from fitting to data\n\nNow we've done all the hard work to estimate the paramaters describing the disease spread we can run the model to create forcasts of what will happen looking forward.\n\nRemember, there are improvements we'd need to make to get a really good fit. I've mentioned some of these as we've gone through. But let's see how it looks:","f2117240":"### Calculating mortality estimate from confirmed cases (CFR)\n\nCFR: estimate using last x data points from China. We've selected the value of fit_points based on today, in the future you will need to change this to ensure you get a good fit.\n","57ff4b53":"## Setup\n\n### Importing required packages","a8cebc91":"#### To setup the model, we need some initial estimates\n- We estimate initial reported deaths $D_0$ as deaths reported on the first day of simulation\n- We estimate initial reported recoveries $C_0$ as recoveries reported on the first day of simulation\n- We estimate initial reported infections $I_r$$_0$ as (Confirmed Cases - recoveries - deaths) reported on the first day of simulation\n- Using $IFR$, reported deaths in *time lag from symtom onset to death*(15 days), we estimate the total infected population, $I_0$ today. We then estimate initial unreported infections $I_u$$_0$ as $I_0$ - $I_r$$_0$\n- Similarly, using $IFR$, reported deaths today, we estimate the total infected population, $I_{-15}$ 15 days prior to today. We estimate initial unreported recoveries $C_u$$_0$ as $I_{-15}$ - $I_r$$_0$ - $D_0$ - $C_0$ (everybody unreported from 15 days prior must have recovered)\n- We estimate initial exposed $E$ as 100*Confirmed Cases today\n\n*Note: In later versions of the model, instead of using estimates for these values, we allowed the model to find the values within certain bounds. We optimised this still further by giving random start points to avoid local minimas. Feel free to try and implement these changes yourself.*","5d741e86":"### Estimate the parameters, by fitting to the curve\n\nFor initial estimates, we use \n- $\\beta_1$, $\\beta_2$ calculated using estimates of $R_0$, *doubling time* and *time_to_death*\n- $\\epsilon$ = 0.2 \n- $cCFR$ estimated from China's data","173bb4fb":"## Estimating confirmed Case Fatality Rate and Infection Fatality Rate\n\nThe first step we need to take is to create an estimate for the severity of COVID-19 infection. There are a couple of statistics for doing this and each is important in different situations. The thing that most people want to know the most is how likely someone is to die once they've caught the disease. The problem in answering this question comes in defining and measuring 'someone'. Whilst most global media use various definitions without explanation, it's important that we understand what precisely we are measuring.\n\nWe are going to look at two metrics for disease fatality:\n\n- Confirmed Case Fatality Rate (cCFR)\n- Infection Fatality Rate (IFR)\n\n#### Confirmed Case Fatality Rate (cCFR)\ncCFR is a measure of the proportion of confirmed cases that result in a patient's death. The key point here is that the total population that is being considered is only those who've been diagnosed with COVID-19 and had their disease status confirmed (e.g. by PCR Test). This has the benefit that the total population is known and can be confirmed by counting all positive test results. [Paper calculating CFR](https:\/\/www.thelancet.com\/journals\/laninf\/article\/PIIS1473-3099%2820%2930246-2\/fulltext)\n\n#### Infection Fatality Rate (IFR)\nIFR is a measure of the proportion of total infections that result in a patient's death. The total population here includes the confirmed cases above, plus everyone else that was infected and not diagnosed. A diagnosis might not be confirmed if, for example, the patient is asymptomatic, they have mild symptoms and choose not to seek medical care, testing systems are overwhelmed so can't test people who are suspected to have the condition. This measure provides a much better picture of how dangerous an infectious disease is, as it represents the 'true' fatality rate. However, in the case of COVID-19 it is\/was extremely hard to measure as all three of the examples above were true. Some countries did manage to roll out widespread testing and can provide a CFR that is closer to the IFR value - including: South Korea and Iceland. [Paper calculating IFR](https:\/\/www.thelancet.com\/journals\/laninf\/article\/PIIS1473-3099%2820%2930246-2\/fulltext)\n\n### In our approach\nWe use data from China for cCFR. cCFR can be estimated as \n- deaths\/total cases or\n- deaths\/closed cases, where closed cases = (recovered cases + deaths)\n\nSince every case will eventually either recover or die, these two should eventually converge to the same number. We take the average of that asymptotic value as cCFR\n\nWe use data from S. Korea for IFR, since they have done extensive testing. IFR can be estimated as \n- deaths\/total cases\n\n### Calculating cCFR and IFR\n\nBefore we can actually calculate the cCFR and IFR we need to make some adjustments to our data. In order to compare cases and case outcomes (death or recoveries), we need to align the data. This is because the people who die from a disease today arn't the same people who were recorded as infected today. Diseases take some time to progress to their outcomes and during this period more people are being infected. \n\nIdeally we could avoid this problem by using individual level data, and only considering cases that have reached their outcomes, however this data is not readily avaliable. Instead what we need to do is take the outcomes and compare them to the number of infections at T-x and T-y (respectively). In this approach we used figures published by the WHO at the time:","f7968724":"### Fitting a curve to mortality rate (CFR)","51fe46c9":"## We are now going to try and fit a modified SEIR model to the data\n\nFirst we take some estimates reported by WHO as a starting point for our model. We will later let the model alter these to find the values it thinks leads to a good fit.","a0d1300f":"## Final remarks\n\nAs this isn't the final version of our model, it's performance can definately be improved. We've made these fixes in newer versions but you can see if you can do the same to this notebook. We can see despite this we did manage to achieve a decent fit for deaths.\n\nThis model is very sensitive to the starting point and the assumptions here are chosen to work for the UK. If you want it to work for other countries, you'll have to find assumptions that work, or implement the V2 or V3 fixes I outlined in the notebook.\n\nI hope you've found this interesting and informative. If you have any questions, please leave a comment.\n\nIf you're interested in joining the HELP project, please sign up here: https:\/\/links.quant-quest.com\/helpproject\n\n"}}