{"cell_type":{"4ca1f159":"code","5d18faf9":"code","8284b4bd":"code","cf189d68":"code","d4978166":"code","fc268842":"code","b7aeca37":"code","0fc95f44":"code","11e0ea3a":"code","322031eb":"code","c14509f7":"code","06460bbc":"code","85feb69c":"code","0146b887":"code","c646b619":"code","0a49ec5c":"code","406bc3ce":"code","adc319c4":"code","80e289b8":"code","97403e8a":"code","0854ea73":"markdown","79641310":"markdown","7f52e8ad":"markdown","24700942":"markdown","80814c1a":"markdown","a149e3ec":"markdown","e3e2fed5":"markdown","66fe5928":"markdown","fc7c8b38":"markdown","6b213d61":"markdown","b2339d25":"markdown","c23134c5":"markdown","d5954f3e":"markdown","cfd41c7b":"markdown","ebb6f950":"markdown","02ab70e3":"markdown","bb04dd0e":"markdown","f4127e55":"markdown","845014a6":"markdown","b0735107":"markdown","d9789b14":"markdown","fa7bb12d":"markdown"},"source":{"4ca1f159":"%matplotlib inline\nimport numpy as np\nimport pandas as pd\nimport torch\nfrom torch import nn\nfrom tqdm import tqdm\nfrom d2l import torch as d2l\nimport os\nos.environ[\"KMP_DUPLICATE_LIB_OK\"] = \"TRUE\"","5d18faf9":"# \u8bf7\u4fee\u6539\u4e3a\u81ea\u5df1\u7684\u8def\u5f84\ntrain_data = pd.read_csv(r'D:\\idea project\\\u623f\u4ef7\u9884\u6d4b\\data\\train.csv')\ntest_data = pd.read_csv(r'D:\\idea project\\\u623f\u4ef7\u9884\u6d4b\\data\\test.csv')","8284b4bd":"all_features = pd.concat((train_data.loc[:,train_data.columns != 'Sold Price'], test_data.iloc[:, 1:]))","cf189d68":"#\u6e05\u6d17\u4e00\u4e0bBedrooms\u5217\u7684\u6570\u636e\nBedrooms_col = all_features['Bedrooms']\ntemp_Bedrooms = []\nfor item in Bedrooms_col:\n    if item=='nan':\n        temp_Bedrooms.append(0)\n    elif isinstance(item,str):\n        n = len(item.split(','))\n        if n ==0:\n            temp_Bedrooms.append(1)\n        else:\n            temp_Bedrooms.append(n)\n    else:\n        temp_Bedrooms.append(item)\nBedrooms_col = temp_Bedrooms","d4978166":"numeric_features = all_features.dtypes[all_features.dtypes != 'object'].index\nall_features[numeric_features] = all_features[numeric_features].apply(\n    lambda x: (x - x.mean()) \/ (x.std()))\n#\u5728\u6807\u51c6\u5316\u6570\u636e\u4e4b\u540e\uff0c\u6240\u6709\u6570\u636e\u90fd\u610f\u5473\u7740\u6d88\u5931\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5c06\u7f3a\u5931\u503c\u8bbe\u7f6e\u4e3a0\nall_features[numeric_features] = all_features[numeric_features].fillna(0)","fc268842":"# \u62fc\u63a5 Bedrooms_col\nall_features = all_features[numeric_features[1:]] # \u539f\u672c\u7b2c\u4e00\u5217\u662fId\uff0c\u53bb\u6389\n# all_features['Type'] = type_col\nall_features['Bedrooms_col'] = Bedrooms_col\nall_features['Bedrooms_col'] = all_features['Bedrooms_col'].fillna(0).apply(\n    lambda x: (x - x.mean()) \/ (x.std()))\nall_features.info()","b7aeca37":"\n# \u4ecepandas\u683c\u5f0f\u4e2d\u63d0\u53d6NumPy\u683c\u5f0f\uff0c\u5e76\u5c06\u5176\u8f6c\u6362\u4e3a\u5f20\u91cf\u8868\u793a\nn_train = train_data.shape[0]\ntrain_features = torch.tensor(all_features[:n_train].values,\n                              dtype=torch.float32)\ntest_features = torch.tensor(all_features[n_train:].values,\n                             dtype=torch.float32)\n# \u6ce8\u610f\u8bfe\u4e0a\u6570\u636e\u7684\u6807\u7b7e\u5217\u4e3aSalePrice\uff0c\u4e0e\u6bd4\u8d5b\u7528\u7684\u6807\u7b7e\u5217\u540d\u4e0d\u540c\nlabel_list = []\nfor item in train_data.iterrows():\n    if item[1]['Listed Price'] ==0:\n        item= item[1]['Sold Price']\n        label_list.append(item)\n    else:\n        label_list.append(item[1]['Listed Price'])\ntrain_data['Listed Price'] = label_list\nfor item in train_data['Listed Price']:\n    if item ==0:\n        print('\u5b58\u57280\u503c')\ntrain_labels = torch.tensor(train_data['Sold Price'].values.reshape(-1, 1),\n                            dtype=torch.float32)","0fc95f44":"## \u5b9a\u4e49\u6a21\u578b\nloss = nn.MSELoss()\nin_features = train_features.shape[1]\nnet = nn.Sequential(\n    nn.Linear(in_features,10),\n    nn.ReLU(),\n    nn.Linear(10,1)\n\n)\ndef get_net():\n    return net","11e0ea3a":"def log_rmse(net, features, labels):\n    # \u4e3a\u4e86\u5728\u53d6\u5bf9\u6570\u65f6\u8fdb\u4e00\u6b65\u7a33\u5b9a\u8be5\u503c\uff0c\u5c06\u5c0f\u4e8e1\u7684\u503c\u8bbe\u7f6e\u4e3a1\n    clipped_preds = torch.clamp(net(features), 1, float('inf'))\n    rmse = torch.sqrt(loss(torch.log(clipped_preds), torch.log(labels)))\n    return rmse.item()","322031eb":"## \u8bad\u7ec3\ndef train(net, train_features, train_labels, test_features, test_labels,\n          num_epochs, learning_rate, weight_decay, batch_size):\n    train_ls, test_ls = [], []\n    train_iter = d2l.load_array((train_features, train_labels), batch_size)\n    # \u8fd9\u91cc\u4f7f\u7528\u7684\u662fAdam\u4f18\u5316\u7b97\u6cd5\n    optimizer = torch.optim.Adam(net.parameters(), lr=learning_rate, eps=1e-08,\n                                 weight_decay=weight_decay)\n    \n    for epoch in tqdm(range(num_epochs)):\n        for X, y in train_iter:\n            optimizer.zero_grad()\n            l = loss(net(X), y)\n            l.backward()\n            optimizer.step()\n        train_ls.append(log_rmse(net, train_features, train_labels))\n        if test_labels is not None:\n            test_ls.append(log_rmse(net, test_features, test_labels))\n        \n            \n    return train_ls, test_ls","c14509f7":"##K \u6298\u4ea4\u53c9\u9a8c\u8bc1\ndef get_k_fold_data(k, i, X, y):\n    assert k > 1\n    fold_size = X.shape[0] \/\/ k\n    X_train, y_train = None, None\n    for j in range(k):\n        \n        idx = slice(j * fold_size, (j + 1) * fold_size)\n        X_part, y_part = X[idx, :], y[idx]\n        if j == i:\n            X_valid, y_valid = X_part, y_part\n        elif X_train is None:\n            X_train, y_train = X_part, y_part\n        else:\n            X_train = torch.cat([X_train, X_part], 0)\n            y_train = torch.cat([y_train, y_part], 0)\n    return X_train, y_train, X_valid, y_valid\ndef k_fold(k, X_train, y_train, num_epochs, learning_rate, weight_decay,\n           batch_size):\n    train_l_sum, valid_l_sum = 0, 0\n    for i in range(k):\n        data = get_k_fold_data(k, i, X_train, y_train)\n        net = get_net()\n        train_ls, valid_ls = train(net, *data, num_epochs, learning_rate,\n                                   weight_decay, batch_size)\n        train_l_sum += train_ls[-1]\n        valid_l_sum += valid_ls[-1]\n        if i==0:\n            d2l.plot(list(range(1, num_epochs + 1)), [train_ls, valid_ls],\n                     xlabel='epoch', ylabel='rmse', xlim=[1, num_epochs],\n                     legend=['train', 'valid'], yscale='log')\n        print(f'fold {i + 1}, train log rmse {float(train_ls[-1]):f}, '\n              f'valid log rmse {float(valid_ls[-1]):f}')\n    return train_l_sum \/ k, valid_l_sum \/ k","06460bbc":"k, num_epochs, lr, weight_decay, batch_size = 5, 100, 1, 0, 64\ntrain_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr,\n                          weight_decay, batch_size)\nprint(f'{k}-\u6298\u9a8c\u8bc1: \u5e73\u5747\u8bad\u7ec3log rmse: {float(train_l):f}, '\n      f'\u5e73\u5747\u9a8c\u8bc1log rmse: {float(valid_l):f}')","85feb69c":"def train_and_pred(train_features, test_feature, train_labels, test_data,\n                   num_epochs, lr, weight_decay, batch_size):\n#     test_features = test_features.to(device)\n#     train_features = train_features.to(device)\n#     train_labels = train_labels.to(device)\n    \n    net = get_net()\n    \n    train_ls, _ = train(net, train_features, train_labels, None, None,\n                        1, lr, weight_decay, batch_size)\n#     d2l.plot(np.arange(1, num_epochs + 1), [train_ls], xlabel='epoch',\n#              ylabel='log rmse', xlim=[1, num_epochs], yscale='log')\n    print(f'train log rmse {float(train_ls[-1]):f}')\n    preds = net(test_features).detach().numpy()\n    print(preds)\n    # \u4e0d\u51fa\u6240\u6599\uff0c\u5217\u540d\u9700\u8981\u505a\u66ff\u6362\n    p = preds.reshape(1, -1)[0]\n    \n    test_data['Sold Price'] = pd.Series(p)\n    submission = pd.concat([test_data['Id'], test_data['Sold Price']], axis=1)\n    \n    # \u6700\u540e\u8fd4\u56de\u4e00\u4e0b\u63d0\u4ea4\u7684\u7ed3\u679c\uff0c\u4ee5\u4fbf\u67e5\u770b\n    return submission\n\nsubmission = train_and_pred(train_features, test_features, train_labels, test_data,\n               num_epochs, lr, weight_decay, batch_size)","0146b887":"submission.to_csv('submission.csv', index=False)","c646b619":"pip insall mlbox","0a49ec5c":"from mlbox.preprocessing import *\nfrom mlbox.optimisation import *\nfrom mlbox.prediction import *","406bc3ce":"target_name='Sold Price'\npaths = [\"california-house-prices\/train.csv\",\"california-house-prices\/test.csv\"] \ndata = Reader(sep=\",\").train_test_split(paths, 'Sold Price')\ndata = Drift_thresholder().fit_transform(data)","adc319c4":"rmse = make_scorer(lambda y_true, y_pred: np.sqrt(np.sum((np.log(y_true) - np.log(y_pred))**2)\/len(y_true))\n                    , greater_is_better=False, needs_proba=False)","80e289b8":"opt = Optimiser(scoring = rmse, n_folds = 5)\nspace = {\n        'ne__numerical_strategy':{\"search\":\"choice\",\n                                    \"space\":['mean','median']},\n        'est__strategy':{\"search\":\"choice\",\n                                  \"space\":[\"LightGBM\"]},    \n        'est__n_estimators':{\"search\":\"choice\",\n                                  \"space\":[250,500,700,1000]},    \n        'est__colsample_bytree':{\"search\":\"uniform\",\n                                  \"space\":[0.8,0.95]},\n        'est__subsample':{\"search\":\"uniform\",\n                                  \"space\":[0.8,0.95]},\n        'est__max_depth':{\"search\":\"choice\",\n                                  \"space\":[5,6,7,8,9]},\n        'est__learning_rate':{\"search\":\"uniform\",\n                                  \"space\":[0,1]} \n    \n        }\nbest = opt.optimise(space, data, max_evals = 200)\nPredictor().fit_predict(best, data)","97403e8a":"submit = pd.read_csv(\"california-house-prices\/sample_submission.csv\",sep=',')\npreds = pd.read_csv(\"save\/\"+target_name+\"_predictions.csv\")\n\nsubmit[target_name] =  preds[target_name+\"_predicted\"].values\n\nsubmit.to_csv(\"submission.csv\", index=False)","0854ea73":"## \u6a21\u578b\u6211\u7a0d\u5fae\u6539\u4e86\u4e00\u70b9\u70b9\uff0closs\u4e0b\u964d\u4f1a\u5feb\u5f88\u591a\uff0c\u4e0b\u9762\u4ee3\u7801\u57fa\u672c\u8ddf\u8001\u5e08\u5dee\u4e0d\u591a","79641310":"# \u524d\u8a00\n\u4f5c\u4e3a\u4e00\u4e2a\u521d\u5b66\u8005\uff0c\u4e00\u5f00\u59cb\u6211\u4e25\u683c\u6309\u7167\u8001\u5e08\u7684\u65b9\u6cd5\u8fdb\u884c\u64cd\u4f5c\uff0c\u5305\u62ec\u5bf9\u6570\u503c\u7684\u5904\u7406\u3001\u5b57\u7b26\u4e32\u7684\u5904\u7406\uff0c\u4f46\u662f\u53d1\u73b0\u73b0\u5b9e\u5f80\u5f80\u662f\u8fd9\u4e48\u7684\u6b8b\u9177\uff0c\u6709\u4e9b\u6570\u636e\u91cc\u9762\u6709\u201c\u810f\u4e1c\u897f\u201d\u3002\u5728\u6570\u636e\u9884\u5904\u7406\u8fd9\u4e00\u5757\uff0c\u6211\u662f\u60f3\u591a\u7b80\u5355\u5c31\u591a\u7b80\u5355\u89e3\u51b3\uff0c\u53ea\u4fdd\u7559\u4e86\u6570\u503c\u7684\u5217\uff0c\u5177\u4f53\u53ef\u4ee5\u53c2\u8003\u53e6\u5916\u4e00\u4f4d\u540c\u5b66\u7684notebook\u3002\u5c31\u5f53\u6211\u6ee1\u5fc3\u6b22\u559c\u8fd0\u884c\u7684\u65f6\u5019\u53d1\u73b0\u4e0d\u5bf9\u52b2\uff0c\u8fd9\u673a\u5668\u5b66\u4e60\u6c34\u592a\u6df1\u4e86\uff0c\u6211\u4e5f\u4e0d\u662f\u957f\u6c5f\uff0closs\u4e00\u76f4\u4e0b\u4e0d\u53bb\u5e76\u7ef4\u6301\u5728\u6bd4\u8f83\u9ad8\u7684\u6c34\u5e73\uff0c\u8c03\u4e86\u597d\u591a\u53c2\u6570\u90fd\u4e0d\u662f\u592a\u7406\u60f3\uff0c\u4e0b\u9762\u6211\u4f1a\u4ee5\u4e24\u79cd\u5f62\u5f0f\u8fdb\u884c\u7f16\u7801\uff0c\u5206\u6570\u4e0d\u662f\u592a\u597d\u4ec5\u4f9b\u53c2\u8003\u3002","7f52e8ad":"\u6211\u5efa\u8bae\u5728linux\u4e0b\u5b89\u88c5\uff0cWindows\u5b89\u88c5\u6210\u529f\u4e86\u4f46\u662f\u7528\u4e0d\u4e86\u5b83\u7684\u5305\uff0c\u5f88\u5947\u602a\uff0c\u5c31\u662f\u5bfc\u4e0d\u8fdb\u6765","24700942":"## \u4e0a\u8ff0\u5c31\u662f\u4f7f\u7528\u9b54\u6cd5\u6765\u6253\u8d25\u9b54\u6cd5\uff0c\u5206\u6570\u4e5f\u633a\u4e0d\u9519\u7684\u90fd\u80fd\u57280.2\u5de6\u53f3\uff0c\u5177\u4f53\u53c2\u6570\u6211\u786e\u5b9e\u4e0d\u77e5\u9053\u600e\u4e48\u8c03","80814c1a":"## \u63a5\u4e0b\u6765\u6211\u5c06\u4f7f\u7528\u5341\u884c\u4ee3\u7801\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898","a149e3ec":"## \u8bfb\u53d6\u6570\u636e\u548c\u5904\u7406\u6570\u636e","e3e2fed5":"## \u5b9a\u4e49loss","66fe5928":"\u8fdb\u5165\u5b83\u7684\u5b98\u7f51\uff0c\u5f80\u4e0b\u62c9\u4e00\u70b9\u5c31\u80fd\u770b\u5230\u5b83\u5728kaggle\u4e0a\u7684\u6ce2\u58eb\u987f\u623f\u4ef7\u7684\u9884\u6d4b\u4ee3\u7801\uff0c\u975e\u5e38\u7b80\u5355\uff0c\u672c\u6b21\u4ee3\u7801\u5b8c\u5168\u53c2\u8003\u5b83\u7684\u4ee3\u7801[\u70b9\u6211](https:\/\/www.kaggle.com\/axelderomblay\/running-mlbox-auto-ml-package-on-house-prices)","fc7c8b38":"# 1.\u6309\u7167\u8001\u5e08\u6559\u7684\u505a","6b213d61":"## \u4fdd\u5b58\u5206\u6570","b2339d25":"## \u5bfc\u5305","c23134c5":"# 2.\u5fc5\u987b\u4f7f\u7528\u9b54\u6cd5\u6253\u8d25\u9b54\u6cd5","d5954f3e":"**\u4ee5\u4e0a\u7684\u4ee3\u7801\u5c31\u662f\u6309\u7167\u8001\u5e08\u7684\u601d\u8def\u8fdb\u884c\u7684\uff0c\u6211\u4eec\u53bb\u9664\u4e86\u6240\u6709\u975e\u6570\u503c\u7684\u5217\uff0c\u7279\u5f81\u51cf\u5c11\u4e86\u597d\u591a\uff0c\u6574\u4f53\u7684\u5206\u6570\u5927\u6982\u57280.3~0.6\u4e4b\u95f4\uff0c\u8bd5\u8fc7\u6700\u597d\u7684\u6210\u7ee9\u662f\u57280.25\u5de6\u53f3\u3002**","cfd41c7b":"\u5929\u5929\u770b\u7740\u6392\u540d\uff0c\u4e5f\u4e0d\u77e5\u9053\u4e00\u4e2a\u4e2a\u5927\u4f6c\u662f\u600e\u4e48\u505a\u5230\u8fd9\u4e48\u9ad8\u7684\u5206\u6570\u7684\uff0c\u6211\u7ecf\u5e38\u5728\u7fa4\u91cc\u9762\u8fdb\u884c\u63d0\u95ee\u4f46\u662f\u6ca1\u6709\u4e00\u4e2a\u4eba\u51fa\u6765\u5e26\u5e26\u6211\u8fd9\u4e2a\u83dc\u9e1f\uff0c\u6211\u4ee5\u4e3a\u6211\u7684\u5206\u6570\u4f1a\u4e00\u76f4\u505c\u6ede\u4e0d\u524d\u7684\u65f6\u5019\u53d1\u73b0\u8001\u5e08\u7528automl\uff0c10\u884c\u4ee3\u7801\u5c31\u53ef\u4ee5\u89e3\u51b3\uff0c\u90a3\u6211\u4e3a\u4ec0\u4e48\u4e0d\u53bb\u4e86\u89e3\u4e00\u4e0b\u8fd9\u4e2aautoml\u662f\u4e2a\u4ec0\u4e48\u4e1c\u897f\u3002\u7ecf\u8fc7\u6211\u7684\u641c\u7d22\u6211\u6700\u7ec8\u9501\u5b9a\u4e86\u8001\u5e08\u53ef\u80fd\u4f7f\u7528\u7684automl\u6846\u67b6--------\u201cmlbox\u201d","ebb6f950":"## \u9884\u6d4b\u548c\u4fdd\u5b58\u6587\u4ef6","02ab70e3":"## \u5177\u4f53\u6211\u4e5f\u4e0d\u61c2\uff0c\u6211\u4e71\u586b\u7684","bb04dd0e":"## \u8bad\u7ec3","f4127e55":"## \u8bfb\u53d6\u6570\u636e","845014a6":"## \u5bfc\u5305","b0735107":"### \u5728\u5b9e\u9a8c\u4e2d\u6211\u53d1\u73b0Listed Price\u7684\u5217\u5bf9\u6574\u4e2a\u6a21\u578b\u975e\u5e38\u91cd\u8981\uff0c\u4f46\u662f\u91cc\u9762\u6709\u7f3a\u5931\u7684\u503c\uff0c\u5982\u679c\u53ea\u586b\u51450\u611f\u89c9\u4e0d\u592a\u597d\uff0c\u6240\u4ee5\u6211\u9009\u62e9\u586b\u5145Sold Price\u7684\u503c","d9789b14":"## \u5b89\u88c5","fa7bb12d":"mlbox\u5b98\u65b9\u7f51\u5740\uff1a[mlbox\u7f51\u5740](https:\/\/mlbox.readthedocs.io\/en\/latest\/index.html)"}}