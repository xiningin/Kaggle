{"cell_type":{"44b227b3":"code","f75463b1":"code","4922ad9a":"code","b90d402f":"code","73d80676":"code","c174ce77":"code","372caf93":"code","cb40c065":"code","08834b73":"code","84ce8889":"code","30cabba4":"code","e9e017a8":"code","034d29f0":"code","5bb2fd19":"code","f0ab687d":"code","8f83f7d6":"code","1acd46f6":"code","6c0354d2":"code","151dace8":"code","c7ffcf10":"code","6722a7fa":"code","13bcc1d4":"code","2ac49c17":"code","80533bb3":"code","851a42a9":"code","0ffdeddb":"code","9f402c4c":"code","c2846249":"code","1e0eb0b6":"code","792f0f03":"code","e076b4f2":"code","e479a260":"code","3359d964":"code","4c31fb57":"code","118b726e":"code","75babb0a":"code","700a0a11":"code","b180811f":"code","1ea78fa2":"code","8b982970":"code","60031bbd":"code","2d17d924":"code","b30ce298":"code","1baf13a7":"code","98551721":"code","74ed266f":"code","a8469924":"code","05a80cdf":"code","9a092a5c":"code","5d19bb84":"code","8d5d1cce":"code","dcb41c5e":"code","1ede5586":"code","7a200b85":"code","a03f474b":"code","389a1ada":"code","f55c1ef9":"code","d44f88a7":"code","9ab49a23":"markdown","7bbef772":"markdown","2dece010":"markdown","da21ff17":"markdown","d30289f5":"markdown","9a6cbbd3":"markdown","061b1c66":"markdown","9dc96187":"markdown","69b8809b":"markdown","e28390ad":"markdown","b9851fe4":"markdown","886d5a8c":"markdown","2ee22821":"markdown","1f20e78e":"markdown","4a1af7cf":"markdown"},"source":{"44b227b3":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline","f75463b1":"gapp = pd.read_csv(\"..\/input\/google-play-store-apps\/googleplaystore.csv\")\ngapp.head()","4922ad9a":"print(\"Column names before clean-up:: \", gapp.columns)\ngapp.columns = [colName.replace(\" \",\"_\") if(len(colName.split())>1) else colName for colName in gapp.columns]\nprint(\"======================================================================================================\")\nprint(\"Column names after clean-up:: \", gapp.columns)","b90d402f":"# Find the columns wise NaN counts\ngapp.isnull().sum(axis = 0)","73d80676":"gappC = gapp.dropna()\nprint(\"Number of rows after cleaning:: \", gappC.shape[0])\ngappC.isnull().sum(axis = 0)","c174ce77":"#sns.distplot(gapp[\"Rating\"]) # this will through an error because there are NaN\nprint(\"Unique values of ratings across apps:: \",gapp[\"Rating\"].unique())\nprint(\"==================================================\")\nprint(\"Number of rows before cleaning:: \", gapp.shape[0])","372caf93":"gappC = gappC[gappC.Rating != 19]\ngappC[\"Rating\"].unique()","cb40c065":"#So apparently there are no NaN values \n#From now on we will use the cleaned data frame for our anlysis\n#Let us c how the vlaues are distributed in ratings\nplt.figure(figsize=(26, 10))\nsns.distplot(gappC[\"Rating\"])","08834b73":"print(\"Unique values in Price column :: \", gappC[\"Price\"].unique()) # There are  $ signs so we can not plot them So let us remove them \ngappC[\"Price\"] = gappC[\"Price\"].replace({'\\$':''}, regex = True).astype(float) # remove the $ sign and make it a numeric column\nprint(\"=============================================================================\")\nprint(\"Unique values in price column post processing::\", gappC[\"Price\"].unique())","84ce8889":"gappC[\"Price\"].describe()","30cabba4":"gappC.loc[gappC['Price'] >=100, ['App', \"Price\"]]","e9e017a8":"gappC[\"Type\"].unique()","034d29f0":"plt.figure(figsize=(26, 10))\nsns.scatterplot(x = gappC.Price, y = gappC.Rating, s = 80)","5bb2fd19":"cvrF = gappC[gappC.Price == 0] # Category Vs rating for free apps\nplt.figure(figsize=(26, 10))\nplt.xticks(rotation=90, horizontalalignment='right')\nsns.scatterplot(x = cvrF.Category, y = cvrF.Rating, hue=cvrF.Content_Rating, s = 80)","f0ab687d":"cvrP = gappC[gappC.Price != 0] # Category Vs rating for free apps\nplt.figure(figsize=(26, 10))\nplt.xticks(rotation=90, horizontalalignment='right')\nsns.scatterplot(x = cvrP.Category, y = cvrP.Rating, hue=cvrP.Content_Rating, s = 80)","8f83f7d6":"plsf = gappC[(gappC.Price > 0) & (gappC.Price < 75) ] # Paid apps less than 75\nplt.figure(figsize=(26, 10))\nplt.xticks(rotation=90, horizontalalignment='right')\nsns.scatterplot(x = plsf.Category, y = plsf.Rating, hue=plsf.Content_Rating, s = 80)","1acd46f6":"plt.figure(figsize=(26, 10))\nplt.xticks(rotation=90, horizontalalignment='right')\nsns.boxplot(x = plsf.Category, y = plsf.Rating, hue=plsf.Content_Rating)","6c0354d2":"pgtf = gappC[gappC.Price > 250] # Paid apps greater than 250\nplt.figure(figsize=(26, 10))\nplt.xticks(rotation=90, horizontalalignment='right')\nsns.scatterplot(x = pgtf.Category, y = pgtf.Rating, hue=pgtf.Content_Rating, s = 80)","151dace8":"gappC[gappC.Price >100].shape[0]\n# so there are only 15 Applications above 100$.","c7ffcf10":"fig, axs = plt.subplots(2,2,figsize=(15, 10))\nsns.distplot(gappC[(gappC.Price >= 0.0)&(gappC.Price <= 0.99)].Price, ax=axs[0,0])\nsns.distplot(gappC[(gappC.Price >= 1.00)&(gappC.Price <= 10)].Price, ax=axs[0,1])\nsns.distplot(gappC[(gappC.Price >= 11.00)&(gappC.Price <= 100)].Price, ax=axs[1,0])\nsns.distplot(gappC[gappC.Price >= 101.00].Price, ax=axs[1,1])\n\n\nfig.suptitle(\"App distribution by Price segments\", fontsize=16)\naxs[0, 0].set_title('Free apps and below 1$')\naxs[0, 1].set_title('Apps Priced below 10 $ excluding free')\naxs[1, 0].set_title('Apps Priced below 100$ and above 11')\naxs[1, 1].set_title('Apps Priced above 100$')\n","6722a7fa":"gappC.groupby(['Category'])['Category'].count().sort_values(ascending = False).head(10)","13bcc1d4":"plt.figure(figsize=(26, 10))\nplt.xticks(rotation=90, horizontalalignment='right')\nplt.title('Count of app in each category',size = 20)\ng = sns.countplot(x=\"Category\",data=gappC, palette = \"Set1\")\ng ","2ac49c17":"gappC.groupby(['Category'])['Price'].max().sort_values(ascending = False).head(10)","80533bb3":"#Ratings by Category\nplt.figure(figsize=(26, 10))\nplt.xticks(rotation=90, horizontalalignment='right')\nsns.boxplot(x=\"Category\", y=\"Rating\", data=gappC)","851a42a9":"gappC.info()","0ffdeddb":"gappC.head(5)","9f402c4c":"gappC['Size'] = gappC['Size'].map(lambda x: x.rstrip('M'))\ngappC['Size'] = gappC['Size'].map(lambda x: str(round((float(x.rstrip('k'))\/1024), 1)) if x[-1]=='k' else x)\ngappC['Size'] = gappC['Size'].map(lambda x: np.nan if x.startswith('Varies') else x)","c2846249":"gappC['Installs'] = gappC['Installs'].map(lambda x: x.rstrip('+'))\ngappC['Installs'] = gappC['Installs'].map(lambda x: ''.join(x.split(',')))","1e0eb0b6":"gappC.info()","792f0f03":"gappC['Reviews'] = gappC['Reviews'].apply(lambda x: float(x))\ngappC['Size'] = gappC['Size'].apply(lambda x: float(x))\ngappC['Installs'] = gappC['Installs'].apply(lambda x: float(x))","e076b4f2":"gappC.info()","e479a260":"gappC.isnull().sum(axis = 0)","3359d964":"gappDF = gappC.dropna()","4c31fb57":"gappDFM = gappDF.drop(['App', 'Category', 'Type', 'Content_Rating', 'Genres', 'Last_Updated', 'Current_Ver', 'Android_Ver'], axis = 1)\ngappDFM.head()","118b726e":"plt.figure(figsize=(15, 5))\nsns.regplot(x = gappDFM.Rating, y = gappDFM.Reviews)","75babb0a":"plt.figure(figsize=(15, 5))\nsns.regplot(x = gappDFM.Rating, y = gappDFM.Installs)","700a0a11":"plt.figure(figsize=(15, 5))\nsns.regplot(x = gappDFM.Rating, y =gappDFM.Size )","b180811f":"from sklearn.linear_model import LinearRegression\nfrom sklearn import metrics\nfrom sklearn.model_selection import train_test_split","1ea78fa2":"#for evaluation of error term  \ndef evalMat(y_true, y_predict):\n    print ('Mean Squared Error: '+ str(metrics.mean_squared_error(y_true,y_predict)))\n    print ('Mean absolute Error: '+ str(metrics.mean_absolute_error(y_true,y_predict)))\n    print ('Mean squared Log Error: '+ str(metrics.mean_squared_log_error(y_true,y_predict)))","8b982970":"def evalMat_dict(y_true, y_predict, name = 'Linear Regression'):\n    dict_matrix = {}\n    dict_matrix['Regression Method'] = name\n    dict_matrix['Mean Squared Error'] = metrics.mean_squared_error(y_true,y_predict)\n    dict_matrix['Mean Absolute Error'] = metrics.mean_absolute_error(y_true,y_predict)\n    dict_matrix['Mean Squared Log Error'] = metrics.mean_squared_log_error(y_true,y_predict)\n    return dict_matrix","60031bbd":"x = gappDFM.drop([\"Rating\"], axis = 1)\ny = gappDFM.Rating","2d17d924":"x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2)","b30ce298":"linMod = LinearRegression()\nlinMod.fit(x_train, y_train)\nlinRes = linMod.predict(x_test)","1baf13a7":"resDF = pd.DataFrame()\nresDF = resDF.from_dict(evalMat_dict(y_test,linRes),orient = 'index')\nresDF = resDF.transpose()","98551721":"resDF.head()","74ed266f":"print('Actual mean of Population:: ', y.mean())\nprint('Predicted mean:: ', linRes.mean())","a8469924":"plt.figure(figsize = (12, 6))\nsns.regplot(linRes, y_test, marker = 'x')\nplt.title('Linear model')\nplt.xlabel('Predicted Ratings')\nplt.ylabel('Actual Ratings')\nplt.show()","05a80cdf":"linMod.coef_","9a092a5c":"linMod.intercept_","5d19bb84":"from sklearn import svm\n\nsvrMod = svm.SVR(gamma='auto')\nsvrMod.fit(x_train, y_train)\nsvrRes = svrMod.predict(x_test)","8d5d1cce":"print('Actual mean of Population:: ', y.mean())\nprint('Predicted mean:: ', svrRes.mean())","dcb41c5e":"resDF = resDF.append(evalMat_dict(y_test, svrRes, name = \"SVR\"), ignore_index = True)","1ede5586":"resDF","7a200b85":"plt.figure(figsize = (12, 6))\nsns.regplot(svrRes, y_test, marker = 'x')\nplt.title('SVR model')\nplt.xlabel('Predicted Ratings')\nplt.ylabel('Actual Ratings')\nplt.show()","a03f474b":"from sklearn.ensemble import RandomForestRegressor\nrfrMod = RandomForestRegressor()\nrfrMod.fit(x_train, y_train)\nrfrRes = rfrMod.predict(x_test)","389a1ada":"print('Actual mean of Population:: ', y.mean())\nprint('Predicted mean:: ', rfrRes.mean())","f55c1ef9":"resDF = resDF.append(evalMat_dict(y_test, rfrRes, name = \"RFR\"), ignore_index = True)\nresDF","d44f88a7":"plt.figure(figsize = (12, 6))\nsns.regplot(rfrRes, y_test, marker = 'x')\nplt.title('RFR model')\nplt.xlabel('Predicted Ratings')\nplt.ylabel('Actual Ratings')\nplt.show()","9ab49a23":"Convert some of the numeric columns to int\/float","7bbef772":"Fix installs by eliminating the + sign","2dece010":"Now let us look at the gaps in the data frame. ","da21ff17":"Couple of observations on Ratings columns. There are rows (apps) without rating (nan), which is quite understandable because not apps will be rated. But what is funny is though the rating scale is 1-5 there is a rating of 19. Let us see how to fix them. ","d30289f5":"It is good idea to clean column names especially the special charecters to avoid confusion\/errors while coding.","9a6cbbd3":"From above it is clear now that there are no NaN (Gaps) values in any columns. Now let us begin our analysis. Let us start our analysis with App Ratings. \n\n**App Ratings**","061b1c66":"A quick check on the Price column indicates that more than 75% of the apps are free. But the maximum price paid for an app is 400 \\$.\nSo let us see what are the apps that are Priced over 100$","9dc96187":"Now let us do the Random forest regressor. ","69b8809b":"Now let us begin the prediction of App ratings by the availbe data using regression techniques.","e28390ad":"Fix Size column so that it can become number","b9851fe4":"Let us explore the Price of apps. Zero indicates Free apps. ","886d5a8c":"So in summary through the MSE is ~0.2 Most ofthe predicted ratings are centered between 4.0 and 4.5. This needs to be improved. Now let us try Support Vector Regression","2ee22821":"Now let us try support vector regression","1f20e78e":"So there are 1474 rows (Apps) with-out rating and one without Content_Rating, 8 without current version numbers and 3 without Android version. Though there are several methods for dealing this depending on the question under investigation, for now let us drop those rows with NaN and store this data in gappC (google Apps clean)","4a1af7cf":"Import all the libraries to handle the Data processing."}}