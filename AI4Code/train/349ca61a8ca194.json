{"cell_type":{"12c19067":"code","e789eec8":"code","a9d98789":"code","76013ce3":"code","759650a8":"code","ed9ab3a2":"code","3838d311":"code","f981430d":"code","0329755e":"code","5c108c21":"code","5ecb93cc":"code","0e00db4b":"code","d62ae415":"code","f4f6a8e7":"code","2496ae3d":"code","a9315ac3":"code","fddd0033":"code","f3a26eb5":"code","7ec35022":"code","81426b5e":"code","07703054":"code","6158c56c":"markdown","bc9c2ee4":"markdown","1c98921c":"markdown","d25a8a92":"markdown","7faa2e0a":"markdown","7f0be003":"markdown","2cf27fae":"markdown","80f19e69":"markdown","80993b1a":"markdown","64995ced":"markdown","b67dd785":"markdown","afe27458":"markdown","746ddf8c":"markdown","9c1c9377":"markdown","4aeb760f":"markdown","b6b2ad99":"markdown","1f6e3b2e":"markdown","7ca38e74":"markdown","d680ecc9":"markdown","724e3b4d":"markdown","8d952287":"markdown","1774c636":"markdown"},"source":{"12c19067":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom keras.layers import Input, Dense, Reshape, Flatten, Dropout\nfrom keras.layers import BatchNormalization\nfrom keras.layers.advanced_activations import LeakyReLU\nfrom keras.models import Sequential, Model\nfrom keras.optimizers import Adam\n\nfrom keras.utils import np_utils\nfrom sklearn.preprocessing import LabelEncoder\n\nimport os\nimport time\nfrom pylab import *","e789eec8":"data_path = \"..\/input\/dataset\/dataset\"","a9d98789":"sample_data = os.path.join(data_path, \"00_010.csv\")\nsample_df = pd.read_csv(sample_data, index_col=None, header=None)\nsample_df","76013ce3":"%matplotlib inline\nfrom matplotlib import pyplot as plt\nplt.imshow(sample_df.values, interpolation='nearest')\nplt.axis('off')\nplt.show()","759650a8":"def loadData(path=data_path):\n    files = os.listdir(path)\n    data = []\n    labels = []\n    for fn in files:\n        ffn = os.path.join(path, fn)\n        df = pd.read_csv(ffn, index_col=None, header=None)\n        df[df==2]=0\n        data.append(df.values)\n        label = int(fn[0:2])\n        labels.append(label)\n    data = np.array(data) \n    return data, labels","ed9ab3a2":"data, labels = loadData() ","3838d311":"print(labels)","f981430d":"defined_path_classes = pd.read_csv(\"..\/input\/pathClasses.csv\", index_col=None)\ndefined_path_classes","0329755e":"class GAN():\n    def __init__(self, img_rows=19, img_cols=13, channels=1):\n        self.img_rows = img_rows\n        self.img_cols = img_cols\n        self.channels = channels\n        self.img_shape = (self.img_rows, self.img_cols, self.channels)\n\n        optimizer = Adam(0.0002, 0.5)\n\n        # Build and compile the discriminator\n        self.discriminator = self.build_discriminator()\n        self.discriminator.compile(loss='binary_crossentropy',\n                                   optimizer=optimizer,\n                                   metrics=['accuracy'])\n\n        # Build and compile the generator\n        self.generator = self.build_generator()\n        self.generator.compile(loss='binary_crossentropy', optimizer=optimizer)\n\n        # The generator takes noise as input and generated imgs\n        z = Input(shape=(100,))\n        img = self.generator(z)\n\n        # For the combined model we will only train the generator\n        self.discriminator.trainable = False\n\n        # The valid takes generated images as input and determines validity\n        valid = self.discriminator(img)\n\n        # The combined model  (stacked generator and discriminator) takes\n        # noise as input => generates images => determines validity \n        self.combined = Model(z, valid)\n        self.combined.compile(loss='binary_crossentropy', optimizer=optimizer)\n\n    def build_generator(self):\n\n        noise_shape = (100,)\n\n        model = Sequential()\n\n        model.add(Dense(256, input_shape=noise_shape))\n        model.add(LeakyReLU(alpha=0.2))\n        model.add(BatchNormalization(momentum=0.8))\n        model.add(Dense(512))\n        model.add(LeakyReLU(alpha=0.2))\n        model.add(BatchNormalization(momentum=0.8))\n        model.add(Dense(1024))\n        model.add(LeakyReLU(alpha=0.2))\n        model.add(BatchNormalization(momentum=0.8))\n        model.add(Dense(np.prod(self.img_shape), activation='tanh'))\n        model.add(Reshape(self.img_shape))\n\n        model.summary()\n\n        noise = Input(shape=noise_shape)\n        img = model(noise)\n\n        return Model(noise, img)\n\n    def build_discriminator(self):\n\n        img_shape = (self.img_rows, self.img_cols, self.channels)\n\n        model = Sequential()\n\n        model.add(Flatten(input_shape=img_shape))\n        model.add(Dense(512))\n        model.add(LeakyReLU(alpha=0.2))\n        model.add(Dense(256))\n        model.add(LeakyReLU(alpha=0.2))\n        model.add(Dense(1, activation='sigmoid'))\n        model.summary()\n\n        img = Input(shape=img_shape)\n        validity = model(img)\n\n        return Model(img, validity)\n\n    def train(self, X_train, y_, epochs=1000, batch_size=2):\n\n        X_train = 2 * (X_train.astype(np.float32)) - 1\n        X_train = np.expand_dims(X_train, axis=3)\n        half_batch = int(batch_size \/ 2)\n\n        for epoch in range(epochs):\n\n            # ---------------------\n            #  Train Discriminator\n            # ---------------------\n\n            # Select a random half batch of images\n            idx = np.random.randint(0, X_train.shape[0], half_batch)\n            imgs = X_train[idx]\n\n            noise = np.random.normal(0, 1, (half_batch, 100))\n\n            # Generate a half batch of new images\n            gen_imgs = self.generator.predict(noise)\n\n            # Train the discriminator\n            d_loss_real = self.discriminator.train_on_batch(imgs, np.ones((half_batch, 1)))\n            d_loss_fake = self.discriminator.train_on_batch(gen_imgs, np.zeros((half_batch, 1)))\n            d_loss = 0.5 * np.add(d_loss_real, d_loss_fake)\n\n            # ---------------------\n            #  Train Generator\n            # ---------------------\n\n            noise = np.random.normal(0, 1, (batch_size, 100))\n\n            # The generator wants the discriminator to label the generated samples as valid (ones)\n            valid_y = np.array([1] * batch_size)\n\n            # Train the generator\n            g_loss = self.combined.train_on_batch(noise, valid_y)","5c108c21":"gan = GAN()\nstart_time = time.time()\ngan.train(data, labels, epochs=10000, batch_size=8)\nprint(\"total training time: %s seconds ---\" % (time.time() - start_time))","5ecb93cc":"gen_samples_row, gen_samples_col = 3,4\ncount = gen_samples_row*gen_samples_col\nnoise = np.random.normal(0, 1, (count, 100))\nprint(noise.shape)","0e00db4b":"noise[0]","d62ae415":"# Generate images from noise data\ngen_imgs = gan.generator.predict(noise)\nprint(gen_imgs.shape)","f4f6a8e7":"gen_imgs = 0.5 * gen_imgs + 0.5","2496ae3d":"gen_imgs[0].shape","a9315ac3":"fig, axs = plt.subplots(gen_samples_row, gen_samples_col, figsize=(4.5,5))\ncnt = 0\nfig.subplots_adjust(hspace=0.5)\nfor i in range(gen_samples_row):\n    for j in range(gen_samples_col):\n        axs[i,j].imshow(gen_imgs[cnt, :,:,0], cmap=plt.cm.gray)\n        axs[i,j].axis('off')\n    autoAxis = axs[i,j].axis()\n    rec = Rectangle((autoAxis[0]-0.1,autoAxis[2]-0.2),(autoAxis[1]-autoAxis[0])+.2,(autoAxis[3]-autoAxis[2])+0.1,fill=False, lw=0.5)\n    rec = axs[i,j].add_patch(rec)\n    rec.set_clip_on(False)\n    cnt += 1\nplt.show()\nplt.close()","fddd0033":"class PathClassifier:\n    \n    def __init__(self, num_pixels=13*19, num_classes=6):\n        self.model = self.build_classifier_base(num_pixels, num_classes)\n\n    def build_classifier_base(self, num_pixels, num_classes):\n        # fix random seed for reproducibility\n        seed = 7\n        np.random.seed(seed)\n        model = Sequential()\n        model.add(Dense(num_pixels, input_dim=num_pixels, kernel_initializer='normal', activation='relu'))\n        model.add(Dropout(0.2))\n        model.add(Dense(num_classes, kernel_initializer='normal', activation='softmax'))\n        # Compile model\n        model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])\n        return model\n\n    def train_model(self, X_train, y_train, eps=10, batch_size=20):\n        num_classes = y_train.shape[1]\n        num_pixels = X_train.shape[1]        \n        self.model.fit(X_train, y_train, epochs=eps, batch_size=batch_size, verbose=2)\n        return self.model\n\n    def evaluate(self, X_test, y_test):        \n        scores = self.model.evaluate(X_test, y_test, verbose=0)\n        accuracy = scores[1] * 100\n        print(\"Classification accuracy: %.2f%%\" % accuracy)\n        return accuracy","f3a26eb5":"path_classifier = PathClassifier()\nlblEnc = LabelEncoder()\nlabels = lblEnc.fit_transform(labels)\n\nnum_pixels = data.shape[1] * data.shape[2]\ndata = data.reshape(data.shape[0], num_pixels).astype('float32')\nlabels = np_utils.to_categorical(labels)\n\nnum_classes = labels.shape[1]\n\nlnx = int(len(data) * 0.7)\nX_train, X_test = data[:lnx], data[lnx:]\ny_train, y_test = labels[:lnx], labels[lnx:]\n\npath_classifier.train_model(X_train, y_train, eps=10, batch_size=i*10)\n","7ec35022":"path_classifier.evaluate(X_test, y_test)","81426b5e":"gen_imgs2 = gen_imgs.reshape(gen_imgs.shape[0], gen_imgs.shape[1]*gen_imgs.shape[2]).astype('float32')\nclasses = path_classifier.model.predict(gen_imgs2)\nclasses = np.argmax(classes, axis=1)","07703054":"fig, axs = plt.subplots(gen_samples_row, gen_samples_col, figsize=(4.5,5))\ncnt = 0\nfig.subplots_adjust(hspace=0.5)\nfor i in range(gen_samples_row):\n    for j in range(gen_samples_col):\n        axs[i,j].imshow(gen_imgs[cnt, :,:,0], cmap=plt.cm.gray)\n        axs[i,j].set_title('class ' + str(classes[cnt]))\n        axs[i,j].axis('off')\n    autoAxis = axs[i,j].axis()\n    rec = Rectangle((autoAxis[0]-0.1,autoAxis[2]-0.2),(autoAxis[1]-autoAxis[0])+.2,(autoAxis[3]-autoAxis[2])+0.1,fill=False, lw=0.5)\n    rec = axs[i,j].add_patch(rec)\n    rec.set_clip_on(False)\n    cnt += 1\nplt.show()\nplt.close()","6158c56c":"Now we can identify the class of generated paths","bc9c2ee4":"### See how a trajectory data looks like","1c98921c":"In this notebook, I employ the concept of Generative Adversarial Network for path planning, i.e., generate paths between two points and classify them to be sure we get the right path.  The idea is to train the GAN based on the training data and later inqure the GAN to generate possible paths between two points. The potential applications of this work would be way finding and navigation for robots and autonomous vehicles. Training data includes different trajectories between 6 pairs of specified points. We treat each trajectory sample as an image. For more information about the data structure and experiment setup see the [dataset description](http:\/\/https:\/\/www.kaggle.com\/mehdimka\/path-planning\/home).","d25a8a92":"### Train the path classifier","7faa2e0a":"# Path planning using Generative Adversarial Network","7f0be003":"Generate 12 paths from noise vectors of size 100.","2cf27fae":"And see how it looks like visually","80f19e69":"### Load defined path classes ad their specification:\nWe have 6 classes. (x1,y1) and (x2,y2) specify tow end of the path.  ","80993b1a":"## Create Path Classifier","64995ced":"## Loading data\nHere we load all csv files into feature and label vectors. Note that all CSV files in the original dataset are zipped in dataset.zip file but when used in kaggle kernels they are unzipped automattically under dataset\/dataset folder. ","b67dd785":"### Build and Train the GAN","afe27458":"# Create GAN structure","746ddf8c":"After generating paths, we need to identify the class of generated path so we can check if they are what we expected.","9c1c9377":"Now load all tragectories and identify their labels","4aeb760f":"### *Chanllenge: How to automatically evaluate the accuracy of generative models? It is still an open research question.*","b6b2ad99":"Shape of a generated image:","1f6e3b2e":"Draw generated paths and their class label","7ca38e74":"Show the generated paths","d680ecc9":"Rescale image pixels in 0 - 1","724e3b4d":"A noise vector:","8d952287":"How accurate is our path classifier?","1774c636":"## Loading packages"}}