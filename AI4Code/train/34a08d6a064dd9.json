{"cell_type":{"90eead6c":"code","1feef052":"code","bb24de52":"code","58a55c45":"code","3fc656fa":"code","6172bdcd":"code","e99147ab":"code","d2c8e771":"code","8795e53b":"code","8fb290fe":"code","ef763148":"code","481bfbff":"code","dcabd7ff":"code","88de8b98":"code","7a0a1421":"code","45352052":"code","619de75c":"code","e9f9c826":"code","788cc023":"code","7e4ba254":"code","99877e16":"markdown","46db4e46":"markdown","e3f52131":"markdown","557878a8":"markdown","95d40f44":"markdown","2e9338d7":"markdown"},"source":{"90eead6c":"import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom skimage.util import montage\nfrom IPython.display import Image, display, SVG, clear_output, HTML\nimport networkx as nx\nplt.rcParams[\"figure.figsize\"] = (6, 6)\nplt.rcParams[\"figure.dpi\"] = 125\nplt.rcParams[\"font.size\"] = 14\nplt.rcParams['font.family'] = ['sans-serif']\nplt.rcParams['font.sans-serif'] = ['DejaVu Sans']\nplt.style.use('ggplot')\nsns.set_style(\"whitegrid\", {'axes.grid': False})\nplt.rcParams['image.cmap'] = 'gray' # grayscale looks better\n\ndef draw_graph_mpl(g, pos=None, ax=None, layout_func=nx.drawing.layout.kamada_kawai_layout):\n    if ax is None:\n        fig, ax = plt.subplots(1, 1, figsize=(25, 25))\n    else:\n        fig = None\n    if pos is None:\n        pos = layout_func(g)\n    node_color = []\n    node_labels = {}\n    shift_pos = {}\n    for k in g:\n        node_color.append(g.nodes[k].get('color', 'green'))\n        node_labels[k] = g.nodes[k].get('label', k)\n        shift_pos[k] = [pos[k][0], pos[k][1]]\n    \n    edge_color = []\n    edge_width = []\n    for e in g.edges():\n        edge_color.append(g.edges[e].get('color', 'black'))\n        edge_width.append(g.edges[e].get('width', 0.5))\n    nx.draw_networkx_edges(g, pos, font_weight='bold', edge_color=edge_color, width=edge_width, ax=ax, alpha=0.5)\n    nx.draw_networkx_nodes(g, pos, node_color=node_color, node_shape='p', node_size=300, alpha=0.75)\n    nx.draw_networkx_labels(g, shift_pos, labels=node_labels, ax=ax, arrows=True)\n    ax.autoscale()\n    return fig, ax, pos","1feef052":"\"\"\"\nThis code is largely take from M. Defferrard's Github\nhttps:\/\/github.com\/mdeff\/cnn_graph\/blob\/master\/nips2016\/mnist.ipynb.\n\"\"\"\n\nimport numpy as np\nimport scipy.sparse as sp\nfrom keras.datasets import mnist as m\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neighbors import kneighbors_graph\n\nMNIST_SIZE = 28","bb24de52":"def load_data(k=8, noise_level=0.0, random_state=None):\n    \"\"\"\n    Loads the MNIST dataset and a K-NN graph to perform graph signal\n    classification, as described by [Defferrard et al. (2016)](https:\/\/arxiv.org\/abs\/1606.09375).\n    The K-NN graph is statically determined from a regular grid of pixels using\n    the 2d coordinates.\n\n    The node features of each graph are the MNIST digits vectorized and rescaled\n    to [0, 1].\n    Two nodes are connected if they are neighbours according to the K-NN graph.\n    Labels are the MNIST class associated to each sample.\n\n    :param k: int, number of neighbours for each node;\n    :param noise_level: fraction of edges to flip (from 0 to 1 and vice versa);\n\n    :return:\n        - X_train, y_train: training node features and labels;\n        - X_val, y_val: validation node features and labels;\n        - X_test, y_test: test node features and labels;\n        - A: adjacency matrix of the grid;\n    \"\"\"\n    A = _mnist_grid_graph(k)\n    if random_state is not None:\n        np.random.seed(random_state)\n    A = _flip_random_edges(A, noise_level).astype(np.float32)\n\n    (X_train, y_train), (X_test, y_test) = m.load_data()\n    X_train, X_test = X_train \/ 255.0, X_test \/ 255.0\n    X_train = X_train.reshape(-1, MNIST_SIZE ** 2)\n    X_test = X_test.reshape(-1, MNIST_SIZE ** 2)\n\n    X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=10000, random_state=random_state)\n\n    return X_train, y_train, X_val, y_val, X_test, y_test, A\n\n\ndef _grid_coordinates(side):\n    \"\"\"\n    Returns 2D coordinates for a square grid of equally spaced nodes.\n    :param side: int, the side of the grid (i.e., the grid has side * side nodes).\n    :return: np.array of shape (side * side, 2).\n    \"\"\"\n    M = side ** 2\n    x = np.linspace(0, 1, side, dtype=np.float32)\n    y = np.linspace(0, 1, side, dtype=np.float32)\n    xx, yy = np.meshgrid(x, y)\n    z = np.empty((M, 2), np.float32)\n    z[:, 0] = xx.reshape(M)\n    z[:, 1] = yy.reshape(M)\n    return z\n\n\ndef _get_adj_from_data(X, k, **kwargs):\n    \"\"\"\n    Computes adjacency matrix of a K-NN graph from the given data.\n    :param X: rank 1 np.array, the 2D coordinates of pixels on the grid.\n    :param kwargs: kwargs for sklearn.neighbors.kneighbors_graph (see docs\n    [here](https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.neighbors.kneighbors_graph.html)).\n    :return: scipy sparse matrix.\n    \"\"\"\n    A = kneighbors_graph(X, k, **kwargs).toarray()\n    A = sp.csr_matrix(np.maximum(A, A.T))\n\n    return A\n\n\ndef _mnist_grid_graph(k):\n    \"\"\"\n    Get the adjacency matrix for the KNN graph.\n    :param k: int, number of neighbours for each node;\n    :return:\n    \"\"\"\n    X = _grid_coordinates(MNIST_SIZE)\n    A = _get_adj_from_data(\n        X, k, mode='connectivity', metric='euclidean', include_self=False\n    )\n\n    return A\n\n\ndef _flip_random_edges(A, percent):\n    \"\"\"\n    Flips values of A randomly.\n    :param A: binary scipy sparse matrix.\n    :param percent: percent of the edges to flip.\n    :return: binary scipy sparse matrix.\n    \"\"\"\n    if not A.shape[0] == A.shape[1]:\n        raise ValueError('A must be a square matrix.')\n    dtype = A.dtype\n    A = sp.lil_matrix(A).astype(np.bool)\n    n_elem = A.shape[0] ** 2\n    n_elem_to_flip = round(percent * n_elem)\n    unique_idx = np.random.choice(n_elem, replace=False, size=n_elem_to_flip)\n    row_idx = unique_idx \/\/ A.shape[0]\n    col_idx = unique_idx % A.shape[0]\n    idxs = np.stack((row_idx, col_idx)).T\n    for i in idxs:\n        i = tuple(i)\n        A[i] = np.logical_not(A[i])\n    A = A.tocsr().astype(dtype)\n    A.eliminate_zeros()\n    return A","58a55c45":"X_train, y_train, X_val, y_val, X_test, y_test, adj = load_data(k=4)","3fc656fa":"xx, yy = np.meshgrid(np.arange(28), np.arange(28))\nnode_id = ['X:{:02d}_Y:{:02d}'.format(x, y) for x, y in zip(xx.ravel(), yy.ravel())]","6172bdcd":"MAX_NODE = 28*15\nG = nx.from_scipy_sparse_matrix(adj[:MAX_NODE, :MAX_NODE])\nfor k, val in zip(G.nodes, X_train[0]):\n    G.nodes[k]['label'] = node_id[k]\n    G.nodes[k]['color'] = 'red' if val>0 else 'green'\ndraw_graph_mpl(G);\nprint(y_train[0])","e99147ab":"G = nx.from_scipy_sparse_matrix(adj)\nfor k, val in zip(G.nodes, X_train[1]):\n    G.nodes[k]['label'] = node_id[k]\n    G.nodes[k]['color'] = 'red' if val>0 else 'green'\ndraw_graph_mpl(G, pos=np.stack([xx.ravel(), yy.ravel()], -1));\nprint(y_train[1])","d2c8e771":"X_train, y_train, X_val, y_val, X_test, y_test, adj = load_data(noise_level=15\/784**2, k=8)\nG = nx.from_scipy_sparse_matrix(adj)\nfor k, val in zip(G.nodes, X_train[1]):\n    G.nodes[k]['label'] = node_id[k]\n    G.nodes[k]['color'] = 'red' if val>0 else 'green'\ndraw_graph_mpl(G, pos=np.stack([xx.ravel(), yy.ravel()], -1));\nprint(y_train[1])","8795e53b":"(X_train, y_train), (X_test, y_test) = m.load_data()","8fb290fe":"def _grid_coordinates_from_img(in_img, threshold):\n    \"\"\"\n    Returns 2D coordinates for a square grid of equally spaced nodes.\n    :param side: int, the side of the grid (i.e., the grid has side * side nodes).\n    :return: np.array of shape (side * side, 2).\n    \"\"\"\n    x = np.linspace(0, 1, in_img.shape[0], dtype=np.float32)\n    y = np.linspace(0, 1, in_img.shape[1], dtype=np.float32)\n    xx, yy = np.meshgrid(x, y)\n    z = np.stack([\n        xx[in_img>threshold].ravel(),\n        yy[in_img>threshold].ravel(),\n        in_img[in_img>threshold].ravel(),\n    ], -1)\n    z = z[np.argsort(-z[:, 2]), :] # sort by pixel value\n    return z\n\ndef _mnist_img_grid_graph(in_img, k, threshold=0.5):\n    \"\"\"\n    Get the adjacency matrix for the KNN graph.\n    :param k: int, number of neighbours for each node;\n    :return:\n    \"\"\"\n    X = _grid_coordinates_from_img(in_img, threshold=threshold)\n    A = _get_adj_from_data(\n        X[:, :2], k, mode='distance', metric='euclidean', include_self=False\n    )\n    return A, X","ef763148":"adj, vec = _mnist_img_grid_graph(X_train[0].reshape(28, 28), 6, threshold=0.0)\nplt.matshow(adj.todense(), cmap='viridis')","481bfbff":"G = nx.from_scipy_sparse_matrix(adj)\nfor k, (xval, yval, cval) in zip(G.nodes, vec):\n    G.nodes[k]['label'] = '{:2.1}_{:2.1}'.format(xval, yval)\n    G.nodes[k]['color'] = plt.cm.gray(cval\/2)\nfor e in G.edges():\n    G.edges[e]['width'] = 0.1\/G.edges[e]['weight']\n    G.edges[e]['color'] = plt.cm.magma(0.025\/G.edges[e]['weight'])\ndraw_graph_mpl(G);","dcabd7ff":"G = nx.from_scipy_sparse_matrix(adj)\nfor k, (xval, yval, cval) in zip(G.nodes, vec):\n    G.nodes[k]['color'] = plt.cm.jet(cval)\nfor e in G.edges():\n    G.edges[e]['width'] = 0.1\/G.edges[e]['weight']\n    G.edges[e]['color'] = plt.cm.magma(0.025\/G.edges[e]['weight'])\ndraw_graph_mpl(G, pos=vec[:, :2]);","88de8b98":"from tqdm import tqdm\ndef _package_images(img_stack, k, max_nodes):\n    X_feat = np.zeros((img_stack.shape[0], max_nodes, 3), dtype='float32')\n    X_adj = np.zeros((img_stack.shape[0], max_nodes, max_nodes), dtype='float32')\n    for i, x in enumerate(tqdm(img_stack)):\n        adj_vec, feat_vec = _mnist_img_grid_graph(x\/255.0, k)\n        c_len = min(feat_vec.shape[0], max_nodes)\n        X_feat[i, :c_len] = feat_vec[:c_len]\n        X_adj[i, :c_len, :c_len] = adj_vec.todense()[:c_len, :c_len]\n    return X_feat, [sp.csr_matrix(x) for x in X_adj] # list of sparse matrices\n\ndef load_disjoint_data(k=8, max_nodes=200, random_state=None):\n    \"\"\"\n    Loads the MNIST dataset and a K-NN graph to perform graph signal\n    classification, as described by [Defferrard et al. (2016)](https:\/\/arxiv.org\/abs\/1606.09375).\n    The K-NN graph is statically determined from a regular grid of pixels using\n    the 2d coordinates.\n\n    The node features of each graph are the MNIST digits vectorized and rescaled\n    to [0, 1].\n    Two nodes are connected if they are neighbours according to the K-NN graph.\n    Labels are the MNIST class associated to each sample.\n\n    :param k: int, number of neighbours for each node;\n\n    :return:\n        - X_train, y_train: training node features and labels;\n        - X_val, y_val: validation node features and labels;\n        - X_test, y_test: test node features and labels;\n        - adj_train, adj_val, adj_test: adjacency matrix of the grid;\n    \"\"\"\n    (img_train, y_train), (img_test, y_test) = m.load_data()\n    X_train, adj_train = _package_images(img_train, k=k, max_nodes=max_nodes)\n    X_train, X_val, y_train, y_val, adj_train, adj_val = train_test_split(X_train, y_train, adj_train, test_size=10000, random_state=random_state)\n    X_test, adj_test = _package_images(img_test, k=k, max_nodes=max_nodes)\n    return (X_train, y_train, adj_train), (X_val, y_val, adj_val), (X_test, y_test, adj_test)","7a0a1421":"(X_train, y_train, adj_train), (X_val, y_val, adj_val), (X_test, y_test, adj_test) = load_disjoint_data()","45352052":"fig, m_axs = plt.subplots(8, 8, figsize=(12, 12))\nfor i, c_ax in enumerate(m_axs.flatten()):\n    c_img = adj_train[i].todense()\n    c_img[c_img==0] = np.NAN\n    c_ax.imshow(c_img, cmap='viridis', vmin=0, vmax=0.25)\n    c_ax.set_title(y_train[i])\n    c_ax.axis('off')","619de75c":"fig, m_axs = plt.subplots(10, 10, figsize=(12, 12))\nfor i, n_axs in enumerate(m_axs.T):\n    c_idx, = np.where(y_train==i)\n    for j, c_ax in zip(c_idx, n_axs):\n        c_img = adj_train[j].todense()\n        c_img[c_img==0] = np.NAN\n        c_ax.imshow(c_img, cmap='viridis', vmin=0, vmax=0.25)\n        c_ax.set_title(y_train[j])\n        c_ax.axis('off')","e9f9c826":"import h5py\nwith h5py.File('disjoint_mnist.h5', 'w') as h:\n    for (x,y,a_list), c_seg in zip([(X_train, y_train, adj_train), \n                               (X_val, y_val, adj_val), \n                               (X_test, y_test, adj_test)], ['train', 'val', 'test']):\n        c_group = h.create_group(c_seg)\n        c_group.create_dataset('feature', data=x, dtype='float32', compression='gzip')\n        adj_dist = c_group.create_dataset('adjacency_distance', \n                                          shape=(x.shape[0],)+a_list[0].shape, \n                                          chunks=(1,)+a_list[0].shape, \n                                          dtype='float32', \n                                          compression='gzip')\n        for i, c_a in enumerate(tqdm(a_list)):\n            adj_dist[i] = c_a.todense()\n        c_group.create_dataset('label', data=y)","788cc023":"!ls -lh disjoint_mnist.h5","7e4ba254":"with h5py.File('disjoint_mnist.h5', 'r') as h:\n    for k1, v1 in h.items():\n        for k2, v2 in v1.items():\n            print(k1, k2, v2.shape)","99877e16":"# Overview\nThe idea is to show the MNIST graph and to make a new graph where each digit has it's own connectivity matrix. The original code has been taken from\n- https:\/\/github.com\/mdeff\/cnn_graph\/blob\/master\/nips2016\/mnist.ipynb\n- https:\/\/github.com\/danielegrattarola\/spektral\/blob\/master\/spektral\/datasets\/mnist.py (directly copied and pasted)","46db4e46":"### Patterns in the Adjacency\nHere we show the first 64 adjacency matrices to see if we can see patterns","e3f52131":"### Write Outputs to Disk","557878a8":"## Flip some edges","95d40f44":"# Create Edge Graph for Each Image\nAnd only include points above a threshold","2e9338d7":"# Standard Graph"}}