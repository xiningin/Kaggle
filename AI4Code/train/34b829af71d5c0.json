{"cell_type":{"3d3f27bc":"code","de481d59":"code","82b9785a":"code","074a0b00":"code","e672cbc8":"code","e773304f":"code","b9a730f5":"code","7b546d0d":"code","d19b7d8c":"code","37d04125":"code","4543114d":"code","8537088b":"code","0c4fe3e3":"code","a66e53ef":"code","32d81b61":"code","f683536e":"code","d0f060c6":"code","c7286c5f":"code","5108a088":"code","0058ecba":"code","3d9d4d21":"code","24eb65af":"code","f3b24b90":"code","38e824ea":"code","7fe1a236":"code","6a8e6f72":"code","57218940":"code","fc079d97":"code","2c6e23ec":"code","cd70b496":"code","258e3e20":"code","380ca09c":"code","0a9209f4":"code","53badbf3":"code","1b6dc982":"code","d74f2ea5":"code","68fa8ec3":"code","25b089fb":"code","fd0b0c88":"code","9e556d95":"code","fdb1da39":"code","c0182dd4":"code","af281cd4":"code","9655d20c":"code","e004aa58":"code","0c7d0559":"code","cb67b7ca":"markdown","f1dd31f4":"markdown","a984cf0f":"markdown","8962ed6e":"markdown","1bb0e721":"markdown","e8d1334b":"markdown","dbdb3d5d":"markdown"},"source":{"3d3f27bc":"import pandas as pd\nimport numpy as np\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport matplotlib.lines as mlines\nfrom mpl_toolkits.mplot3d import Axes3D\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split, learning_curve\nfrom sklearn.metrics import average_precision_score\nfrom xgboost.sklearn import XGBClassifier\nfrom xgboost import plot_importance, to_graphviz","de481d59":"import warnings\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n","82b9785a":"df = pd.read_csv('..\/input\/paysim1\/PS_20174392719_1491204439457_log.csv')\ndf = df.rename(columns={'oldbalanceOrg':'oldBalanceOrig', 'newbalanceOrig':'newBalanceOrig', \\\n                        'oldbalanceDest':'oldBalanceDest', 'newbalanceDest':'newBalanceDest'})\nprint(df.head())","074a0b00":"df.isna().sum()\ndf.isnull().values.any()","e672cbc8":"df.columns","e773304f":"df.type.unique()","b9a730f5":"## there are two kind of fraud transactions here, either through cashout\/transfer. \n\nfraudTransfer = df.loc[(df.isFraud == 1) & (df.type == 'TRANSFER')]\nfraudCashout = df.loc[(df.isFraud == 1) & (df.type == 'CASH_OUT')]\n\nprint(len(fraudTransfer))\nprint(len(fraudCashout))\n","7b546d0d":"# fraud occurs only in cashout\/transfer type of transactions, so lets filter it out.\n\nx = df.loc[(df.type == 'CASH_OUT') | (df.type == 'TRANSFER')]\nx","d19b7d8c":"sns.countplot(df.isFraud)\n","37d04125":"df.isFraud.value_counts()\n","4543114d":"y = x.isFraud\ny","8537088b":"x = x.drop(columns = ['isFraud'])","0c4fe3e3":"x","a66e53ef":"np.random.seed(3)\nx","32d81b61":"x = x.drop(columns = ['nameOrig', 'nameDest', 'isFlaggedFraud'])","f683536e":"x.head()","d0f060c6":"# converting categorical into numerical\n# convert column type having TRANSFER and CASH_OUT into 0 & 1 encoding\n\nx.type = pd.get_dummies(x.type)\nx.head()","c7286c5f":"# incase of fraud transaction the old and new balance is not updated, only the transaction shows the amount\n# incase of non fraud transaction both old and new balance are updated, lets have a look\n\nxfraud = x.loc[y == 1]\nxnonfraud = x.loc[y == 0]\n\nfraudpercent = len(xfraud.loc[(xfraud.oldBalanceDest == 0 ) &  (xfraud.newBalanceDest == 0) * xfraud.amount])\/len(xfraud)\nnonfraudpercent = len(xnonfraud.loc[(xnonfraud.oldBalanceDest == 0 ) &  (xnonfraud.newBalanceDest == 0) * xnonfraud.amount])\/len(xnonfraud)\n\n\nprint(\"% of fraud transactions where old ad new balance doesn't get updated is : \",fraudpercent*100)\nprint(\"% of nonfraud transactions where old ad new balance doesn't get updated is : \", nonfraudpercent*100)","5108a088":"x.loc[(x.oldBalanceDest == 0) & (x.newBalanceDest == 0) & (x.amount != 0), ['oldBalanceDest', 'newBalanceDest']] = -1\nx","0058ecba":"y","3d9d4d21":"x.loc[(x.oldBalanceOrig == 0) & (x.newBalanceOrig == 0) & (x.amount != 0), ['oldBalanceOrig', 'newBalanceOrig']] = np.nan\nx","24eb65af":"x['errorBalanceOrig'] = x.newBalanceOrig + x.amount - x.oldBalanceOrig\nx['errorBalanceDest'] = x.oldBalanceDest + x.amount - x.newBalanceDest\nx","f3b24b90":"# split into training and testing\n\n\nfrom sklearn.model_selection import train_test_split\n\nxtrain, xtest, ytrain, ytest = train_test_split(x, y, test_size = 0.2, random_state = 3)","38e824ea":"# Long computation in this cell (~1.8 minutes)\nweights = (y == 0).sum() \/ (1.0 * (y == 1).sum())\n\nclf = XGBClassifier(max_depth = 3, scale_pos_weight = weights, n_jobs = 4)\n\nprobabilities = clf.fit(xtrain, ytrain).predict_proba(xtest)\nprint('AUPRC = {}'.format(average_precision_score(ytest, probabilities[:, 1])))","7fe1a236":"fig = plt.figure(figsize = (14, 9))\nax = fig.add_subplot(111)\n\ncolours = plt.cm.Set1(np.linspace(0, 1, 9))\n\nax = plot_importance(clf, height = 1, color = colours, grid = False, \\\n                     show_values = False, importance_type = 'cover', ax = ax);\nfor axis in ['top','bottom','left','right']:\n            ax.spines[axis].set_linewidth(2)\n        \nax.set_xlabel('importance score', size = 16);\nax.set_ylabel('features', size = 16);\nax.set_yticklabels(ax.get_yticklabels(), size = 12);\nax.set_title('Ordering of features by importance to the model learnt', size = 20);","6a8e6f72":"ypred = clf.predict(xtest)","57218940":"from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score\n\ncmXGBoost = confusion_matrix(ytest, ypred)\ncmXGBoost","fc079d97":"sns.heatmap(cmXGBoost, annot = True)","2c6e23ec":"acc = accuracy_score(ytest, ypred)\nprec = precision_score(ytest, ypred)\nrec = recall_score(ytest, ypred)\nf1 = f1_score(ytest, ypred)","cd70b496":"results = pd.DataFrame([['XGBoost', acc, prec, rec, f1]],\n            columns = [\"Model\", 'accuray', 'precision' , 'recall', 'f1 score'])","258e3e20":"results","380ca09c":"xtrain.isna().sum()\n","0a9209f4":"xtrain = xtrain.fillna(0)\nxtest = xtest.fillna(0)","53badbf3":"lr = LogisticRegression(random_state = 0, penalty = 'l2')\nlr.fit(xtrain, ytrain)","1b6dc982":"ypred = lr.predict(xtest)","d74f2ea5":"acc = accuracy_score(ytest, ypred)\nprec = precision_score(ytest, ypred)\nrec = recall_score(ytest, ypred)\nf1 = f1_score(ytest, ypred)\n\nmodel_results = pd.DataFrame([['Logistic Regression', acc, prec, rec, f1]],\n            columns = [\"Model\", 'accuray', 'precision' , 'recall', 'f1 score'])\n\nresults = results.append(model_results, ignore_index = True)","68fa8ec3":"#results = results.loc[(results.index !=1)]","25b089fb":"results","fd0b0c88":"cmLR = confusion_matrix(ytest, ypred)\ncmLR","9e556d95":"from sklearn.ensemble import RandomForestClassifier\n\n\nrf = RandomForestClassifier(n_estimators= 20)\nrf.fit(xtrain, ytrain)","fdb1da39":"ypred = rf.predict(xtest)\n","c0182dd4":"acc = accuracy_score(ytest, ypred)\nprec = precision_score(ytest, ypred)\nrec = recall_score(ytest, ypred)\nf1 = f1_score(ytest, ypred)\n\nmodel_results = pd.DataFrame([['Random Forest', acc, prec, rec, f1]],\n            columns = [\"Model\", 'accuray', 'precision' , 'recall', 'f1 score'])\n\nresults = results.append(model_results, ignore_index = True)","af281cd4":"results","9655d20c":"cmRF = confusion_matrix(ytest, ypred)\ncmRF","e004aa58":"plt.figure(figsize=(24,8))\n\nplt.suptitle(\"Confusion Matrixes\",fontsize=24)\nplt.subplots_adjust(wspace = 0.4, hspace= 0.4)\n\nplt.subplot(1,3,1)\nplt.title(\"XGBoost Confusion Matrix\")\nsns.heatmap(cmXGBoost,annot=True,cmap=\"Blues\",fmt=\"d\",cbar=False, annot_kws={\"size\": 24})\n\nplt.subplot(1,3,2)\nplt.title(\"Logistic Regression Confusion Matrix\")\nsns.heatmap(cmLR,annot=True,cmap=\"Blues\",fmt=\"d\",cbar=False, annot_kws={\"size\": 24})\n\nplt.subplot(1,3,3)\nplt.title(\"Random forest Confusion Matrix\")\nsns.heatmap(cmRF,annot=True,cmap=\"Blues\",fmt=\"d\",cbar=False, annot_kws={\"size\": 24})\n\n\nplt.show()","0c7d0559":"results","cb67b7ca":"### Confusion matrix","f1dd31f4":"### we record the error in the transactions by creating two new columns, in order to record fraudulent transaction giving strength to our model.\n\n","a984cf0f":"### XGBoost algorithm","8962ed6e":"### there are also several transactions where old and new balance on non-zero transactions are zero in originating account, in this case we replace the values with null since their percentage is minimal and not to bias the data","1bb0e721":"### Random forest","e8d1334b":"### conclusion - 50% of fraudulent transactions don't update old and new balances in the destination accounts, where as only 0.06% of non-fraudulent transactions update old and new balances, this says that newBalanceDest being zero is a strong indicator or fraudulent transaction, hence we'll not impute the data but we'll replace it with -1 for our algorithm to be able to detect it more accurately.","dbdb3d5d":"### Logistic Regression"}}