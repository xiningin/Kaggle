{"cell_type":{"61f1e97e":"code","d189e3cf":"code","b04c7fe8":"code","69362650":"code","273a754d":"code","40741287":"code","10dc0d10":"code","20b1d65d":"code","31c0a344":"code","2f3ed8e2":"code","829ffbbe":"code","da84aa17":"code","02feb2a4":"code","588185f0":"code","046b1a4f":"code","d5de4017":"code","77721b45":"code","564a47fc":"code","99fc0e80":"code","61fedf3f":"code","f615de2a":"code","a0171753":"code","8f7ac87d":"code","fa552006":"code","d904c1fe":"code","f9ced621":"code","6c494857":"code","b4441e4d":"code","05ddfece":"code","ad5167f1":"code","d1f11d8e":"code","114daece":"code","934affca":"code","2770ba9b":"code","c1abb927":"code","266d37f1":"code","2d5e72c0":"code","001692d8":"code","7376e763":"code","fa1d6afe":"code","78c2d1de":"code","276caa69":"code","b43326c4":"code","73bbc326":"code","00b1ffab":"code","8a2db4ae":"code","602b1442":"code","f5da967b":"code","7e66124a":"code","4d38ef73":"code","ec68e040":"code","2a28431c":"code","c81eb1bc":"code","168ead81":"code","7fa1de70":"code","1d20c802":"code","e5ee180c":"code","ac05121f":"code","78575f88":"code","7a23417e":"code","e797946f":"code","08fc443e":"code","e69fded9":"code","4d7afbfd":"code","9d1d9c43":"code","f8cca5a2":"code","d68cd3b5":"code","08955ad7":"code","79864ee9":"code","d2596264":"code","9415a813":"code","bd8c083a":"code","a622756c":"code","a45cd4ef":"code","7b9e3d67":"code","ed4d9c6e":"code","50242c9c":"code","8b4cd638":"code","b1b82a64":"code","0b23e27d":"code","fef041fc":"code","29e92341":"code","12cdbbcc":"code","61df5be1":"code","7d66610b":"code","d1bb6adb":"code","06f16e51":"code","043e066b":"code","4c71231d":"code","94cc4fde":"code","22222298":"code","b327618a":"code","fe16925f":"code","f1b51279":"code","61dbd925":"code","fa6bd6cd":"code","52852e43":"markdown","84366f45":"markdown","cb19171b":"markdown","5dc279f5":"markdown","59ac6868":"markdown","ffdad546":"markdown","d18ae7c1":"markdown","81b497a4":"markdown","e107874c":"markdown","df1ac6fd":"markdown","4398a98a":"markdown","96676376":"markdown","6008103f":"markdown","ecb1ec96":"markdown","ffa3d1b1":"markdown","26a74314":"markdown","9d5ca273":"markdown","b868f9dc":"markdown","08060573":"markdown","9a0392de":"markdown","534e5349":"markdown","140cc738":"markdown","f73c7974":"markdown","f338ffec":"markdown","adbd0bde":"markdown","be064103":"markdown","54ededc5":"markdown","580f7620":"markdown","d31c5eab":"markdown","70d10284":"markdown","61a5a0b1":"markdown","d9b985e4":"markdown","da60e35a":"markdown","ee6171e6":"markdown","3fd1182d":"markdown","89b5ad43":"markdown","a6fa4e98":"markdown","4ec18a0d":"markdown","e11749bf":"markdown","ddedf12f":"markdown","1acd5851":"markdown","46e195aa":"markdown","a79fa79e":"markdown","b2a441d0":"markdown","896c1767":"markdown","9bba7703":"markdown","efdff5b3":"markdown","f5b11d0b":"markdown","6ab6562a":"markdown","823097e7":"markdown","eba99919":"markdown","0228f122":"markdown","da865481":"markdown","176fd0f6":"markdown"},"source":{"61f1e97e":"# debug mode\ndebug = False;\ndebug_rows = 10000;\n\n# import\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nimport xgboost as xgb\nimport lightgbm as lgb\n\nfrom xgboost import XGBRegressor\nfrom sklearn import model_selection\nfrom sklearn.metrics import confusion_matrix, mean_squared_error, mean_absolute_error\n\nimport gc, sys\ngc.enable()\n\npd.options.display.float_format = '{:,.2f}'.format\npd.set_option('display.max_columns', 100)\n\n%matplotlib inline\n# if(debug):\n#     plt.style.use(\"dark_background\")\n","d189e3cf":"if(debug):\n    train = pd.read_csv('..\/input\/train_V2.csv', nrows = debug_rows)\n    test  = pd.read_csv('..\/input\/test_V2.csv')\nelse:\n    train = pd.read_csv('..\/input\/train_V2.csv', nrows = debug_rows)\n    test  = pd.read_csv('..\/input\/test_V2.csv')","b04c7fe8":"train.shape","69362650":"test.shape","273a754d":"train.isnull().sum()","40741287":"train.dropna(axis=0, how='all')\nprint(train.isnull().any().any())","10dc0d10":"# Memory saving function credit to https:\/\/www.kaggle.com\/gemartin\/load-data-reduce-memory-usage\ndef reduce_mem_usage(df):\n    \"\"\" iterate through all the columns of a dataframe and modify the data type\n        to reduce memory usage.        \n    \"\"\"\n    #start_mem = df.memory_usage().sum() \/ 1024**2\n    #print('Memory usage of dataframe is {:.2f} MB'.format(start_mem))\n\n    for col in df.columns:\n        col_type = df[col].dtype\n\n        if col_type != object:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n\n    #end_mem = df.memory_usage().sum() \/ 1024**2\n    #print('Memory usage after optimization is: {:.2f} MB'.format(end_mem))\n    #print('Decreased by {:.1f}%'.format(100 * (start_mem - end_mem) \/ start_mem))\n\n    return df\n\n# train = reduce_mem_usage(train)\n# test = reduce_mem_usage(test)","20b1d65d":"train.describe()","31c0a344":"train.quantile(q=[0.10, 0.90], numeric_only=True)\n","2f3ed8e2":"assists = train['assists']\nassists.describe()","829ffbbe":"fig, ax = plt.subplots(figsize=(16,8))\nsns.boxplot(x=assists, y=train['winPlacePerc'], ax=ax)","da84aa17":"fig, ax = plt.subplots(figsize=(16,8))\nsns.distplot(assists, kde=False)","02feb2a4":"assists[assists>10].count()","588185f0":"boosts = train['boosts']\nboosts.describe()","046b1a4f":"fig, ax = plt.subplots(figsize=(16,8))\nsns.boxplot(x=boosts, y=train['winPlacePerc'], ax=ax)","d5de4017":"fig, ax = plt.subplots(figsize=(16,8))\nsns.distplot(boosts, kde=False)","77721b45":"train[['boosts', 'heals']].corr()","564a47fc":"eda = train['damageDealt']\neda.describe()","99fc0e80":"fig, ax = plt.subplots(figsize=(16,8))\nsns.regplot(x=eda, y=train['winPlacePerc'], fit_reg=False, ax=ax)","61fedf3f":"eda[eda>15].count()","f615de2a":"train[(train['damageDealt']>400) & (train['winPlacePerc']==0.0) & (train['matchType']=='solo')].head()","a0171753":"eda = train['DBNOs']\neda.describe()","8f7ac87d":"fig, ax = plt.subplots(figsize=(16,8))\nsns.boxplot(x=eda, y=train['winPlacePerc'], ax=ax)","fa552006":"eda[eda>10].count()","d904c1fe":"eda = train['walkDistance']\neda.describe()","f9ced621":"fig, ax = plt.subplots(figsize=(16,8))\nsns.regplot(x=eda, y=train['winPlacePerc'], fit_reg=False,ax=ax)","6c494857":"cheater = train[(train['walkDistance']<=50.0)&(train['damageDealt']>0.0)]\ncheater.head()","b4441e4d":"fig, ax = plt.subplots(figsize=(16,8))\nsns.regplot(x=cheater['walkDistance'], y=cheater['winPlacePerc'], fit_reg=False,ax=ax)","05ddfece":"train[train['walkDistance']>10000]","ad5167f1":"eda = train['headshotKills']\neda.describe()","d1f11d8e":"fig, ax = plt.subplots(figsize=(16,8))\nsns.boxplot(x=eda, y=train['winPlacePerc'],ax=ax)","114daece":"train[train['headshotKills']>10]","934affca":"eda = train['heals']\neda.describe()","2770ba9b":"fig, ax = plt.subplots(figsize=(16,8))\nsns.boxplot(x=eda, y=train['winPlacePerc'],ax=ax)","c1abb927":"train[train['heals']>40].describe()","266d37f1":"eda = train['killPlace']\neda.describe()","2d5e72c0":"fig, ax = plt.subplots(figsize=(16,8))\nsns.boxplot(x=eda, y=train['winPlacePerc'],ax=ax)","001692d8":"eda = train['killPoints']\neda.describe()","7376e763":"fig, ax = plt.subplots(figsize=(16,8))\nsns.regplot(x=eda, y=train['winPlacePerc'],fit_reg=False, ax=ax)","fa1d6afe":"eda = train['kills']\neda.describe()","78c2d1de":"fig, ax = plt.subplots(figsize=(16,8))\nsns.boxplot(x=eda, y=train['winPlacePerc'], ax=ax)","276caa69":"sns.heatmap(train[['damageDealt','kills', 'headshotKills', 'DBNOs']].corr(), annot=True)","b43326c4":"train[train['kills']>30].describe()","73bbc326":"sns.regplot(x=train[train['kills']>10]['kills'], y=train[train['kills']>10]['walkDistance'], fit_reg=False)","00b1ffab":"eda = train['killStreaks']\neda.describe()","8a2db4ae":"fig, ax = plt.subplots(figsize=(16,8))\nsns.boxplot(x=eda, y=train['winPlacePerc'], ax=ax)","602b1442":"sns.heatmap(train[['damageDealt','kills', 'headshotKills', 'DBNOs', 'killStreaks']].corr(), annot=True)","f5da967b":"train[train['killStreaks']>10].head()","7e66124a":"eda = train['longestKill']\neda.describe()","4d38ef73":"fig, ax = plt.subplots(figsize=(16,8))\nsns.regplot(x=eda, y=train['winPlacePerc'],fit_reg=False, ax=ax)","ec68e040":"train[(train['longestKill']<0.01) & (train['kills']!=0)].describe()","2a28431c":"sns.regplot(x=train[(train['longestKill']<1.0) & (train['kills']!=0)]['longestKill'], y=train[(train['longestKill']<1.0) & (train['kills']!=0)]['winPlacePerc'], fit_reg=False)","c81eb1bc":"eda = train['matchDuration']\neda.describe()","168ead81":"fig, ax = plt.subplots(figsize=(16,8))\nsns.regplot(x=eda, y=train['winPlacePerc'],fit_reg=False, ax=ax)","7fa1de70":"eda = train['rankPoints']\neda.describe()","1d20c802":"fig, ax = plt.subplots(figsize=(16,8))\nsns.regplot(x=eda, y=train['winPlacePerc'],fit_reg=False, ax=ax)","e5ee180c":"train[train['rankPoints']==-1].describe()","ac05121f":"eda = train['revives']\neda.describe()","78575f88":"fig, ax = plt.subplots(figsize=(16,8))\nsns.boxplot(x=eda, y=train['winPlacePerc'], ax=ax)","7a23417e":"eda = train['roadKills']\neda.describe()","e797946f":"fig, ax = plt.subplots(figsize=(16,8))\nsns.boxplot(x=eda, y=train['winPlacePerc'],ax=ax)","08fc443e":"train[(train['rideDistance']==0)&(train['roadKills']>0)]","e69fded9":"eda = train['swimDistance']\neda.describe()","4d7afbfd":"fig, ax = plt.subplots(figsize=(16,8))\nsns.regplot(x=eda, y=train['winPlacePerc'],fit_reg=False, ax=ax)","9d1d9c43":"eda = train['teamKills']\neda.describe()","f8cca5a2":"fig, ax = plt.subplots(figsize=(16,8))\nsns.boxplot(x=eda, y=train['winPlacePerc'], ax=ax)","d68cd3b5":"train[train['teamKills']>3]","08955ad7":"eda = train['vehicleDestroys']\neda.describe()","79864ee9":"fig, ax = plt.subplots(figsize=(16,8))\nsns.boxplot(x=eda, y=train['winPlacePerc'], ax=ax)","d2596264":"eda = train['walkDistance']\neda.describe()","9415a813":"fig, ax = plt.subplots(figsize=(16,8))\nsns.regplot(x=eda, y=train['winPlacePerc'],fit_reg=False, ax=ax)","bd8c083a":"eda = train['weaponsAcquired']\neda.describe()","a622756c":"fig, ax = plt.subplots(figsize=(16,8))\nsns.boxplot(x=eda, y=train['winPlacePerc'], ax=ax)","a45cd4ef":"train[(train['weaponsAcquired']>30) & (train['walkDistance']<100)].describe()","7b9e3d67":"eda = train['winPoints']\neda.describe()","ed4d9c6e":"fig, ax = plt.subplots(figsize=(16,8))\nsns.regplot(x=eda, y=train['winPlacePerc'],fit_reg=False, ax=ax)","50242c9c":"df = train # just to save train_df safe\n\ndf = df.drop(df[(df['walkDistance']<10.0) & (df['damageDealt']>0)].index)\ndf = df.drop(df[(df['walkDistance']<10.0) & (df['kills']>10)].index)\ndf = df.drop(df[(df['walkDistance']<100.0) & (df['weaponsAcquired']>30)].index)\ndf = df.drop(df[(df['walkDistance']<10.0) & (df['heals']>100)].index)\ndf = df.drop(df[(df['walkDistance']<10.0) & (df['headshotKills']>5)].index)\ndf = df.drop(df[(df['walkDistance']<10.0) & (df['headshotKills']>5)].index)\n\n# unrated guys (killPoints)\ndf['unrated_kill'] = 0\ndf.loc[df['killPoints']==0, 'unrated_kill']=1\n\n# poor on kill points\ndf['poor_kills'] = 0\ndf.loc[(df['killPoints']>10) & (df['killPoints']<800), 'poor_kills'] = 1\ndf.loc[(df['killPoints']>10) & (df['killPoints']<800), 'killPoints'] = 0\n\n# killPerDamage\ndf['killPerDamage'] = df['kills']\/df['damageDealt']\ndf = df.fillna(0)\n\n# drop savage killer (kill streak > 10)\ndf = df.drop(df[df['killStreaks']>=10].index)\n\n\n# rank unrated players\ndf['unrated_rank'] = 0\ndf.loc[df['rankPoints']==-1, 'unrated_rank']=1\n\n# roadDistance glitch drop\ndf = df.drop(df[(df['rideDistance']==0.0) & (df['roadKills']>0)].index)\n\n# insane weapon scavenger = cheater. drop\ndf = df.drop(df[(df['weaponsAcquired']>30) & (df['walkDistance']<100)].index)\n\n# winpoints unrated\ndf['unrated_win'] = 0\ndf.loc[(df['winPoints']==-1) | (df['winPoints'] == 0), 'unrated_win']=1\n\n# poor on winpoints\ndf['poor_wins'] = 0\ndf.loc[(df['winPoints']>250) & (df['winPoints']<1200), 'poor_wins'] = 1\ndf.loc[(df['winPoints']>250) & (df['winPoints']<1200), 'killPoints'] = 0\n\nprint('removed:' + str(train['Id'].count() - df['Id'].count()))\ndf.head()\n\n","8b4cd638":"# thanks to awesome https:\/\/www.kaggle.com\/chocozzz\/lightgbm-baseline\n\ndef feature_engineering(is_train=True,debug=True):\n    test_idx = None\n    if is_train: \n        print(\"processing train.csv\")\n        if debug == True:\n            df = pd.read_csv('..\/input\/train_V2.csv', nrows=1000000)\n        else:\n            df = pd.read_csv('..\/input\/train_V2.csv')\n\n        df = df[df['maxPlace'] > 1]\n    else:\n        print(\"processing test.csv\")\n        if debug == True:\n            df = pd.read_csv('..\/input\/test_V2.csv')\n        else:\n            df = pd.read_csv('..\/input\/test_V2.csv')\n        test_idx = df.Id\n    \n    # df = reduce_mem_usage(df)\n    #df['totalDistance'] = df['rideDistance'] + df[\"walkDistance\"] + df[\"swimDistance\"]\n    \n    # df = df[:100]\n    \n    print(\"remove some columns\")\n    target = 'winPlacePerc'\n    \n    if(is_train):\n        print(\"removing cheaters\")\n        df = df.drop(df[(df['walkDistance']<10.0) & (df['damageDealt']>0)].index)\n        df = df.drop(df[(df['walkDistance']<10.0) & (df['kills']>10)].index)\n        df = df.drop(df[(df['walkDistance']<100.0) & (df['weaponsAcquired']>30)].index)\n        df = df.drop(df[(df['walkDistance']<10.0) & (df['heals']>100)].index)\n        df = df.drop(df[(df['walkDistance']<10.0) & (df['headshotKills']>5)].index)\n        df = df.drop(df[(df['walkDistance']<10.0) & (df['headshotKills']>5)].index)\n\n        # drop savage killer (kill streak > 10)\n        df = df.drop(df[df['killStreaks']>=10].index)\n\n        # roadDistance glitch drop\n        df = df.drop(df[(df['rideDistance']==0.0) & (df['roadKills']>0)].index)\n\n        # insane weapon scavenger = cheater. drop\n        df = df.drop(df[(df['weaponsAcquired']>30) & (df['walkDistance']<100)].index)\n\n    # unrated guys (killPoints)\n    df['unrated_kill'] = 0\n    df.loc[df['killPoints']==0, 'unrated_kill']=1\n\n    # poor on kill points\n    df['poor_kills'] = 0\n    df.loc[(df['killPoints']>10) & (df['killPoints']<800), 'poor_kills'] = 1\n    df.loc[(df['killPoints']>10) & (df['killPoints']<800), 'killPoints'] = 0\n\n    \n\n\n    # rank unrated players\n    df['unrated_rank'] = 0\n    df.loc[df['rankPoints']==-1, 'unrated_rank']=1\n\n    \n\n    # winpoints unrated\n    df['unrated_win'] = 0\n    df.loc[(df['winPoints']==-1) | (df['winPoints'] == 0), 'unrated_win']=1\n\n    # poor on winpoints\n    df['poor_wins'] = 0\n    df.loc[(df['winPoints']>250) & (df['winPoints']<1200), 'poor_wins'] = 1\n    df.loc[(df['winPoints']>250) & (df['winPoints']<1200), 'killPoints'] = 0\n\n   \n    df[df == np.Inf] = np.NaN\n    df[df == np.NINF] = np.NaN\n    \n    print(\"Removing Na's From DF\")\n    df.fillna(0, inplace=True)\n\n    \n    features = list(df.columns)\n    features.remove(\"Id\")\n    features.remove(\"matchId\")\n    features.remove(\"groupId\")\n    features.remove(\"matchType\")\n    \n    # matchType = pd.get_dummies(df['matchType'])\n    # df = df.join(matchType)    \n    \n    y = None\n    \n    \n    if is_train: \n        print(\"get target\")\n        y = np.array(df.groupby(['matchId','groupId'])[target].agg('mean'), dtype=np.float64)\n        features.remove(target)\n\n    print(\"get group mean feature\")\n    agg = df.groupby(['matchId','groupId'])[features].agg('mean')\n    agg_rank = agg.groupby('matchId')[features].rank(pct=True).reset_index()\n    \n    if is_train: df_out = agg.reset_index()[['matchId','groupId']]\n    else: df_out = df[['matchId','groupId']]\n\n    df_out = df_out.merge(agg.reset_index(), suffixes=[\"\", \"\"], how='left', on=['matchId', 'groupId'])\n    df_out = df_out.merge(agg_rank, suffixes=[\"_mean\", \"_mean_rank\"], how='left', on=['matchId', 'groupId'])\n    \n    # print(\"get group sum feature\")\n    # agg = df.groupby(['matchId','groupId'])[features].agg('sum')\n    # agg_rank = agg.groupby('matchId')[features].rank(pct=True).reset_index()\n    # df_out = df_out.merge(agg.reset_index(), suffixes=[\"\", \"\"], how='left', on=['matchId', 'groupId'])\n    # df_out = df_out.merge(agg_rank, suffixes=[\"_sum\", \"_sum_rank\"], how='left', on=['matchId', 'groupId'])\n    \n    # print(\"get group sum feature\")\n    # agg = df.groupby(['matchId','groupId'])[features].agg('sum')\n    # agg_rank = agg.groupby('matchId')[features].agg('sum')\n    # df_out = df_out.merge(agg.reset_index(), suffixes=[\"\", \"\"], how='left', on=['matchId', 'groupId'])\n    # df_out = df_out.merge(agg_rank.reset_index(), suffixes=[\"_sum\", \"_sum_pct\"], how='left', on=['matchId', 'groupId'])\n    \n    print(\"get group max feature\")\n    agg = df.groupby(['matchId','groupId'])[features].agg('max')\n    agg_rank = agg.groupby('matchId')[features].rank(pct=True).reset_index()\n    df_out = df_out.merge(agg.reset_index(), suffixes=[\"\", \"\"], how='left', on=['matchId', 'groupId'])\n    df_out = df_out.merge(agg_rank, suffixes=[\"_max\", \"_max_rank\"], how='left', on=['matchId', 'groupId'])\n    \n    print(\"get group min feature\")\n    agg = df.groupby(['matchId','groupId'])[features].agg('min')\n    agg_rank = agg.groupby('matchId')[features].rank(pct=True).reset_index()\n    df_out = df_out.merge(agg.reset_index(), suffixes=[\"\", \"\"], how='left', on=['matchId', 'groupId'])\n    df_out = df_out.merge(agg_rank, suffixes=[\"_min\", \"_min_rank\"], how='left', on=['matchId', 'groupId'])\n    \n    print(\"get group size feature\")\n    agg = df.groupby(['matchId','groupId']).size().reset_index(name='group_size')\n    df_out = df_out.merge(agg, how='left', on=['matchId', 'groupId'])\n    \n    print(\"get match mean feature\")\n    agg = df.groupby(['matchId'])[features].agg('mean').reset_index()\n    df_out = df_out.merge(agg, suffixes=[\"\", \"_match_mean\"], how='left', on=['matchId'])\n    \n    # print(\"get match type feature\")\n    # agg = df.groupby(['matchId'])[matchType.columns].agg('mean').reset_index()\n    # df_out = df_out.merge(agg, suffixes=[\"\", \"_match_type\"], how='left', on=['matchId'])\n    \n    print(\"get match size feature\")\n    agg = df.groupby(['matchId']).size().reset_index(name='match_size')\n    df_out = df_out.merge(agg, how='left', on=['matchId'])\n    \n    print(\"Adding Features\")\n \n    df['headshotrate'] = df['kills']\/df['headshotKills']\n    df['killStreakrate'] = df['killStreaks']\/df['kills']\n    df['healthitems'] = df['heals'] + df['boosts']\n    df['totalDistance'] = df['rideDistance'] + df[\"walkDistance\"] + df[\"swimDistance\"]\n    df['killPlace_over_maxPlace'] = df['killPlace'] \/ df['maxPlace']\n    df['headshotKills_over_kills'] = df['headshotKills'] \/ df['kills']\n    df['distance_over_weapons'] = df['totalDistance'] \/ df['weaponsAcquired']\n    df['walkDistance_over_heals'] = df['walkDistance'] \/ df['heals']\n    df['walkDistance_over_kills'] = df['walkDistance'] \/ df['kills']\n    df['killsPerWalkDistance'] = df['kills'] \/ df['walkDistance']\n    df[\"skill\"] = df[\"headshotKills\"] + df[\"roadKills\"]\n    \n    df[df == np.Inf] = np.NaN\n    df[df == np.NINF] = np.NaN\n    print(\"Removing Na's From DF\")\n    df.fillna(0, inplace=True)\n    \n    df_out.drop([\"matchId\", \"groupId\"], axis=1, inplace=True)\n\n    X = df_out\n    \n    feature_names = list(df_out.columns)\n\n    del df, df_out, agg, agg_rank\n    gc.collect()\n\n    return X, y, feature_names, test_idx","b1b82a64":"x_train, y_train, train_columns, _ = feature_engineering(True, debug=debug)\nx_test, _, _ , test_idx = feature_engineering(False, debug=debug)\n","0b23e27d":"sns.heatmap(x_train.head(1000).corr())\n","fef041fc":"# Thanks and credited to https:\/\/www.kaggle.com\/gemartin who created this wonderful mem reducer\ndef reduce_mem_usage(df):\n    \"\"\" iterate through all the columns of a dataframe and modify the data type\n        to reduce memory usage.        \n    \"\"\"\n    start_mem = df.memory_usage().sum() \n    print('Memory usage of dataframe is {:.2f} MB'.format(start_mem))\n    \n    for col in df.columns:\n        col_type = df[col].dtype\n        \n        if col_type != object:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n        else:\n            df[col] = df[col].astype('category')\n\n    end_mem = df.memory_usage().sum() \n    print('Memory usage after optimization is: {:.2f} MB'.format(end_mem))\n    print('Decreased by {:.1f}%'.format(100 * (start_mem - end_mem) \/ start_mem))\n    \n    return df\n\nx_train = reduce_mem_usage(x_train)\nx_test = reduce_mem_usage(x_test)","29e92341":"#excluded_features = []\n#use_cols = [col for col in df_train.columns if col not in excluded_features]\ngc.collect();\ntrain_index = round(int(x_train.shape[0]*0.8))\ndev_X = x_train[:train_index] \nval_X = x_train[train_index:]\ndev_y = y_train[:train_index] \nval_y = y_train[train_index:] \ngc.collect();\n\n# custom function to run light gbm model\ndef run_lgb(train_X, train_y, val_X, val_y, x_test):\n    params = {\"objective\" : \"regression\", \"metric\" : \"mae\", 'n_estimators':20000, 'early_stopping_rounds':200,\n              \"num_leaves\" : 31, \"learning_rate\" : 0.05, \"bagging_fraction\" : 0.7,\n               \"bagging_seed\" : 0, \"num_threads\" : 4,\"colsample_bytree\" : 0.7\n             }\n    \n    lgtrain = lgb.Dataset(train_X, label=train_y)\n    lgval = lgb.Dataset(val_X, label=val_y)\n    model = lgb.train(params, lgtrain, valid_sets=[lgtrain, lgval], early_stopping_rounds=200, verbose_eval=1000)\n    \n    pred_test_y = model.predict(x_test, num_iteration=model.best_iteration)\n    return pred_test_y, model\n\n# Training the model #\npred_test, model = run_lgb(dev_X, dev_y, val_X, val_y, x_test)\npred_test","12cdbbcc":"\n\nprint(pred_test.shape[0])\npred_test\n\ndf_sub = pd.read_csv(\"..\/input\/sample_submission_V2.csv\")\ndf_sub['winPlacePerc'] = pred_test\ndf_sub.head()\n","61df5be1":"if(debug):\n    df_sub = pd.read_csv(\"..\/input\/sample_submission_V2.csv\", nrows=pred_test.shape[0])\n    df_test = pd.read_csv(\"..\/input\/test_V2.csv\", nrows=pred_test.shape[0])\nelse:\n    df_sub = pd.read_csv(\"..\/input\/sample_submission_V2.csv\")\n    df_test = pd.read_csv(\"..\/input\/test_V2.csv\")\ndf_sub['winPlacePerc'] = pred_test\n# Restore some columns\ndf_sub = df_sub.merge(df_test[[\"Id\", \"matchId\", \"groupId\", \"maxPlace\", \"numGroups\"]], on=\"Id\", how=\"left\")\n\n# Sort, rank, and assign adjusted ratio\ndf_sub_group = df_sub.groupby([\"matchId\", \"groupId\"]).first().reset_index()\ndf_sub_group[\"rank\"] = df_sub_group.groupby([\"matchId\"])[\"winPlacePerc\"].rank()\ndf_sub_group = df_sub_group.merge(\n    df_sub_group.groupby(\"matchId\")[\"rank\"].max().to_frame(\"max_rank\").reset_index(), \n    on=\"matchId\", how=\"left\")\ndf_sub_group[\"adjusted_perc\"] = (df_sub_group[\"rank\"] - 1) \/ (df_sub_group[\"numGroups\"] - 1)\n\ndf_sub = df_sub.merge(df_sub_group[[\"adjusted_perc\", \"matchId\", \"groupId\"]], on=[\"matchId\", \"groupId\"], how=\"left\")\ndf_sub[\"winPlacePerc\"] = df_sub[\"adjusted_perc\"]\n\n# Deal with edge cases\ndf_sub.loc[df_sub.maxPlace == 0, \"winPlacePerc\"] = 0\ndf_sub.loc[df_sub.maxPlace == 1, \"winPlacePerc\"] = 1\n\n# Align with maxPlace\n# Credit: https:\/\/www.kaggle.com\/anycode\/simple-nn-baseline-4\nsubset = df_sub.loc[df_sub.maxPlace > 1]\ngap = 1.0 \/ (subset.maxPlace.values - 1)\nnew_perc = np.around(subset.winPlacePerc.values \/ gap) * gap\ndf_sub.loc[df_sub.maxPlace > 1, \"winPlacePerc\"] = new_perc\n\n# Edge case\ndf_sub.loc[(df_sub.maxPlace > 1) & (df_sub.numGroups == 1), \"winPlacePerc\"] = 0\nassert df_sub[\"winPlacePerc\"].isnull().sum() == 0\n\ndf_sub[[\"Id\", \"winPlacePerc\"]].to_csv(\"submission_adjusted.csv\", index=False)\ndf_sub","7d66610b":"#small test in small batch data\n# train_small = df.sample(10000)","d1bb6adb":"# feature_list = ['DBNOs','headshotKills','heals','longestKill','assists','walkDistance', 'boosts','damageDealt', 'damageDealer','healer','deadEye','walker','booster','winPlacePerc']\n\n# train_small=train_small.drop('Id', axis=1)\n# train_small=train_small.drop('groupId', axis=1)\n# train_small=train_small.drop('matchId', axis=1)\n# train_small=train_small.drop('matchType', axis=1)\n\n# train_small_batch = train_small.copy()","06f16e51":"# corr = train_small_batch.corr()\n# fig, ax = plt.subplots(figsize=(20,20))\n# sns.heatmap(corr, annot=True,ax = ax)","043e066b":"# train_df, test_df = model_selection.train_test_split(train_small_batch, test_size=0.3, random_state=49)\n# train_df_y = train_df[['winPlacePerc']]\n# train_df_x = train_df.copy().drop('winPlacePerc', axis=1)\n# test_df_y = test_df[['winPlacePerc']]\n# test_df_x = test_df.copy().drop('winPlacePerc', axis=1)","4c71231d":"\n# clf = XGBRegressor()\n# clf_cv = model_selection.GridSearchCV(clf, {'max_depth': [2,4,6], 'n_estimators': [50,100,200]}, verbose=1)\n# clf_cv.fit(train_df_x, train_df_y)\n# print(clf_cv.best_params_, clf_cv.best_score_)","94cc4fde":"# clf = XGBRegressor(max_depth=4, n_estimators=200)\n# clf.fit(train_df_x, train_df_y)","22222298":"# pred = clf.predict(test_df_x)\n# rmse = np.sqrt(mean_absolute_error(test_df_y, pred))\n# mean_pred = [train_df_y.mean() for i in range(len(test_df_y))]\n# rmse_base = np.sqrt(mean_absolute_error(test_df_y, mean_pred))\n\n# print('trained feature list: ' + str(feature_list))\n\n# print(rmse_base)\n# print(rmse)\n\n# xgb.plot_importance(clf, max_num_features=100)\n","b327618a":"# _test  = pd.read_csv('..\/input\/test_V2.csv')\n# test = _test.copy()","fe16925f":"# # test['damageDealer']=0\n# # test.loc[test['damageDealt']>186.70, 'damageDealer'] = 1\n\n# # test['deadEye'] = 0\n# # test.loc[test['headshotKills']>3, 'deadEye'] = 1\n\n# # test['healer'] = 0\n# # test.loc[test['heals']>=5, 'healer'] = 1\n\n# # test['walker'] = 0\n# # test.loc[test['walkDistance']>3000.0, 'walker'] = 1\n\n# # test['booster'] = 0\n# # test.loc[test['boosts']>=4.0, 'booster'] = 1\n\n# # test['sniper'] = 0\n# # test.loc[test['headshotKills']>=2.0, 'sniper'] = 1\n\n# test['killPerddamage'] = test['kills']\/test['damageDealt']\n\n# test=test.drop('Id', axis=1)\n# test=test.drop('groupId', axis=1)\n# test=test.drop('matchId', axis=1)\n# test=test.drop('matchType', axis=1)\n","f1b51279":"\n# pred = clf.predict(test)\n","61dbd925":"# submission = pd.DataFrame({'Id':_test['Id'], 'winPlacePerc':pred})","fa6bd6cd":"# submission.head()","52852e43":"### DamageDealt","84366f45":"### winpoints","cb19171b":"___Findings___\n\n- 0 or -1 is treated as 'unrated'. consider removing these and create new feature.\n- winpoints ~250 to 1200 are losers. Consider removing these and make these as 'looser' feature.","5dc279f5":"___Findings___\n\n- more heals = more survival\n- insane heals (30~) : not a cheater...? but too junky drinking a lot of energydrink\n- oh, perhaps it's bandage heals: counts up 5 to 10 for healing","59ac6868":"## EDA\n\n### Assists","ffdad546":"### vehicleDestroys","d18ae7c1":"WTF? This weird curve of killplace-winplaceperc could have been caused by __area phase__ in the games (if the area started to shrink, there can be shootings but at the same time risk of being killed).","81b497a4":"### WalkDistance","e107874c":"## Feature engineering\n\nTODOs left in the ___Findings___ section of the notebook:\n\n- count assists as team kill= make team kill sum feature?\n- walkDistance ~ 10.0 with some damage, kill, weapons, heal, headshot: remove.\n- kill points = 0 -> unrated guys. remove these make new columns for them.\n- kill points 10~800 are poor at surving. remove these and make it one-hot kill-poor feature.\n- kill-damageDealt has multicorr. make kill per damageDealt column?\n- killstreak: 10~ are likely to be cheaters.\n- rankPoints == -1 : new players. consider remove and make new feature\n- roadDistance==0 and roadkills > 0 should be fixed.\n- walk<100m but acquires  30~ weapons: cheater or bug. remove.\n- winpoints: 0 and -1 is unrated. and 250 to 1200 are poor at gaming. consider removing these and make new feature 'unrated' and 'win_loosers'.\n","df1ac6fd":"### walkDistance","4398a98a":"### swimDistance","96676376":"### revives","6008103f":"___Findings___\n\n- very small walkDistance (less than meter) with kills, weapons, damages == ___mostly cheaters:___ less than meter and soon weapons is super wierd.\n- very small walkDistance + weapon, heals, damage, kills, headshots, etc. should be removed from the training data.","ecb1ec96":"### Boosts","ffa3d1b1":"## Data tweaking\n\n### Memory reduction\n\nFirst make memory reduced: credit to [this website](https:\/\/www.kaggle.com\/gemartin\/load-data-reduce-memory-usage)","26a74314":"___Findings___\n\n- There exists suspicious cheater (walking less than just a 100m but stil acquires 30~ weapons and kills a lot) consider removing such player from the train data as well.","9d5ca273":"### HeadshotKills","b868f9dc":"### Dropping NA value","08060573":"___Findings___\n\n- kills - damageDealt has multicorralatory. Consider removing these?\n- chaters: ~10 killStreaks are likely to be cheaters","9a0392de":"### TeamKills\nShame on TK!","534e5349":"## Feature engineering record\n\ntesting 10000 parameters.\n\n`clf_cv = model_selection.GridSearchCV(clf, {'max_depth': [2,4,6], 'n_estimators': [50,100,200]}, verbose=1)\n`\n\ndefault\n- 0.28...\n- 0.270245891656\n- 0.261273510973\n- 0.257954486653\n","140cc738":"___Findings___\n\n- more revive = more win.","f73c7974":"### killPoints","f338ffec":"### killstreaks\nkilling spree!","adbd0bde":"### roadkills","be064103":"___Findings___\n\n- How they killed more than 4 times...?","54ededc5":"There is a serial killer. Let's have a look if there's any cheater exists.","580f7620":"___Findings___\n\n- not a big correlation between kills and damages, but the win rate is larger if more vehicle destroys.","d31c5eab":"This graph looks same as headshot kills and damage dealt feature. Take a loook at correlations.","70d10284":"# PUBG prediction challenge\n\nWhile I intensively play PUBG mobile, I found this competition pretty interesting.\nHope such gaming-related conpetition continues, and I will present my first kernel here. Let's get to it!\n\n\n\n## Data colmuns\n\n- __DBNOs__ - Number of enemy players knocked.\n- __assists__ - Number of enemy players this player damaged that were killed by teammates.\n- __boosts__ - Number of boost items used.\n- __damageDealt__ - Total damage dealt. Note: Self inflicted damage is subtracted.\n- __headshotKills__ - Number of enemy players killed with headshots.\n- heals - Number of healing items used.\n- Id - Player\u2019s Id\n- killPlace - Ranking in match of number of enemy players killed.\n- killPoints - Kills-based external ranking of player. (Think of this as an Elo ranking where only kills matter.) If there is a value other than -1 in rankPoints, then any 0 in killPoints should be treated as a \u201cNone\u201d.\n- killStreaks - Max number of enemy players killed in a short amount of time.\n- kills - Number of enemy players killed.\n- longestKill - Longest distance between player and player killed at time of death. This may be misleading, as downing a player and driving away may lead to a large longestKill stat.\n- matchDuration - Duration of match in seconds.\n- matchId - ID to identify match. There are no matches that are in both the training and testing set.\n- matchType - String identifying the game mode that the data comes from. The standard modes are \u201csolo\u201d, \u201cduo\u201d, \u201csquad\u201d, \u201csolo-fpp\u201d, -\u201cduo-fpp\u201d, and \u201csquad-fpp\u201d; other modes are from events or custom matches.\n- rankPoints - Elo-like ranking of player. This ranking is inconsistent and is being deprecated in the API\u2019s next version, so use with -caution. Value of -1 takes place of \u201cNone\u201d.\n- revives - Number of times this player revived teammates.\n- rideDistance - Total distance traveled in vehicles measured in meters.\n- roadKills - Number of kills while in a vehicle.\n- swimDistance - Total distance traveled by swimming measured in meters.\n- teamKills - Number of times this player killed a teammate.\n- vehicleDestroys - Number of vehicles destroyed.\n- walkDistance - Total distance traveled on foot measured in meters.\n- weaponsAcquired - Number of weapons picked up.\n- winPoints - Win-based external ranking of player. (Think of this as an Elo ranking where only winning matters.) If there is a value other than -1 in rankPoints, then any 0 in winPoints should be treated as a \u201cNone\u201d.\n- groupId - ID to identify a group within a match. If the same group of players plays in different matches, they will have a different groupId each time.\n- numGroups - Number of groups we have data for in the match.\n- maxPlace - Worst placement we have data for in the match. This may not match with numGroups, as sometimes the data skips over placements.\n- __winPlacePerc__ - The target of prediction. This is a percentile winning placement, where 1 corresponds to 1st place, and 0 corresponds to last - place in the match. It is calculated off of maxPlace, not numGroups, so it is possible to have missing chunks in a match.","61a5a0b1":"### killPlace","d9b985e4":"___Findings___\n\n- rankPoints == -1 are new players. consider removing these and turn them into feature.","da60e35a":"___Findings___\n\n- kills - damageDealt has multicorralatory. Consider removing these?\n- chaters: ~70 kills, there are serial kills without not much traveling (~1000m). Consider removing these as cheaters.","ee6171e6":"___Findings___\n\n- more revive = more win.","3fd1182d":"### weaponsAcquired","89b5ad43":"___Findings___\n\n- 'winner' travels a lot.","a6fa4e98":"### kills\nwell, if you kill everyone on the game you get chicken dinner :) :)","4ec18a0d":"### DBNOs","e11749bf":"___Findings___\n\n- need to find out the rationale of this 'w' curve.","ddedf12f":"This graph looks same as headshot kills and damage dealt feature. Take a loook at correlations.","1acd5851":"### rankPoints","46e195aa":"___Findings___\n\n- those who have _DeadEye_ will likely to get checken dinner.\n- not that weird to have 10 headshots...? not definitely cheater but _DeadEye_ s","a79fa79e":"___Findings___\n\n- longest kill ~0.8 could be CQC range.","b2a441d0":"___Findings___\n\n- longest kill ~0.8 could be CQC range.","896c1767":"___Findings___\n- more boosts gets chicken dinner.\n- ~15 boosts = not cheater? just a junky drug guys?","9bba7703":"### Heals","efdff5b3":"high corr with 'kills'.","f5b11d0b":"cheaters on the left!","6ab6562a":"### matchDuration","823097e7":"___Findings___\n- more assists likely to be winners.\n- 5~ assists : rare\n- 10~ assists : cheater...? (TODO:check cheater for large assists again)\n- more assists = teammate killed = team wins or strong = winPlacePerc big. Consider adding teammate kill number to its feature","eba99919":"### longestKill","0228f122":"___Findings___\n\n- guys between 10 ~ 800 pts are poor at surviving. consider removing other range and use these as a feature.\n- guys on 0pt are somehow distributed. consider using these as another feature as well.","da865481":"___Findings___\n\n- There exists roadDistance==0 and roadKills > 0. Consider make these roadkills = 0 for better accuracy.","176fd0f6":"___Findings___\n- more damage gets c-dinner\n- there are 0.0 winPlacePerc with 0 - 1000 damage. cheater?\nyes, actually a lot of cheater here as well: walkDistance == 0.0. Consider removing these.\n\n- too many walks...?"}}