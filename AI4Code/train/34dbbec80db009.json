{"cell_type":{"0df5a417":"code","0eeb263c":"code","865799ed":"code","a5342226":"code","c084b187":"code","36aba646":"code","16bb4f2d":"code","85648280":"code","237c8af0":"code","84a2a49e":"code","7fcc8ccd":"code","e795bfaf":"code","47b3651c":"code","be3ade24":"code","7c2dff96":"code","ef328b56":"code","99bf6608":"code","0dfae29c":"code","e3787f28":"code","e50002e8":"code","cc66262f":"markdown","da2d72f2":"markdown","fd2d2e88":"markdown","446f878e":"markdown","a07df78e":"markdown","8dafc758":"markdown","3bc18ae2":"markdown","12416064":"markdown","4f320c3c":"markdown","3830ec3c":"markdown","be752d47":"markdown","99c1b4dd":"markdown","6c334218":"markdown","5e3a7b0d":"markdown"},"source":{"0df5a417":"import os # accessing directory structure\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn import preprocessing\n\nimport matplotlib.pyplot as plt # plotting\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom pandas.plotting import scatter_matrix\nfrom numpy.random import seed\nfrom tensorflow import set_random_seed\n\nset_random_seed(2)\nseed(1)","0eeb263c":"# Correlation matrix\ndef plotCorrelationMatrix(df, graphWidth):\n    filename = df.dataframeName\n    df = df.dropna('columns') # drop columns with NaN\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    if df.shape[1] < 2:\n        print(f'No correlation plots shown: The number of non-NaN or constant columns ({df.shape[1]}) is less than 2')\n        return\n    corr = df.corr()\n    plt.figure(num=None, figsize=(graphWidth, graphWidth), dpi=80, facecolor='w', edgecolor='k')\n    corrMat = plt.matshow(corr, fignum = 1)\n    plt.xticks(range(len(corr.columns)), corr.columns, rotation=90)\n    plt.yticks(range(len(corr.columns)), corr.columns)\n    plt.gca().xaxis.tick_bottom()\n    plt.colorbar(corrMat)\n    plt.title(f'Correlation Matrix for {filename}', fontsize=15)\n    plt.show()","865799ed":"df = pd.read_csv('..\/input\/data.csv', delimiter=',')\nnRow, nCol = df.shape # how many rows and columns do we have\ndf1 = df[0:761]\ndf2 = df[761:]\nc = list(df2)\nfor x in range(12):\n    c[x+1] = c[x+3]\ndf2.columns = c\ndf2 = df2.iloc[:, :-2]\ndf2.rename(columns={'campaign_id': 'reporting_start','fb_campaign_id': 'reporting_end'}, inplace=True)\ndf2.insert(3, 'campaign_id',np.NaN)\ndf2.insert(4,'fb_campaign_id',np.NaN)\ndf = df1.append(df2, ignore_index=True) # final dataframe\ndf.drop(columns=['reporting_start','reporting_end','total_conversion','ad_id','campaign_id','fb_campaign_id'],inplace=True)\n#lets encode labels and normalized values for ranges\nle_gender = preprocessing.LabelEncoder()\nle_ages = preprocessing.LabelEncoder()\nimpressions_normalized = preprocessing.minmax_scale(df.impressions)\nspent_normalized = preprocessing.minmax_scale(df.spent)\ngender_encoded = le_gender.fit_transform(df.gender)\nages_one_hot_encoding_df = pd.get_dummies(df.age,prefix=\"Ages\")\ndf = pd.concat([ages_one_hot_encoding_df,df], axis=1)\ndf.drop(columns='age',inplace=True)\n#replace columns with new columns\ndf['gender'], df['impressions'], df['spent'] = gender_encoded, impressions_normalized, spent_normalized\nprint(df.approved_conversion.value_counts())\ndf.loc[df.approved_conversion >= 1,'approved_conversion'] = 1 \nprint(df.approved_conversion.value_counts())\n# make sure everything is numerical Cause computers dont understand english yet\ndf = df.apply(pd.to_numeric)\ndata = df.values\ndf = df.sample(frac=1)\ndf.dataframeName = 'data.csv'\nprint(\"Dataframe: {}\".format(df.dataframeName))","a5342226":"max_interest_val = np.maximum(np.maximum(df.interest1.max(),df.interest2.max()),df.interest3.max())\nmin_interest_val = np.minimum(np.minimum(df.interest1.max(),df.interest2.max()),df.interest3.max())\n","c084b187":"plotCorrelationMatrix(df,8)","36aba646":"axs = scatter_matrix(df, alpha=0.2,diagonal='kde',figsize  = [15, 15])\nn = len(df.columns)\nfor x in range(n):\n    for y in range(n):\n        ax = axs[x, y]\n        ax.xaxis.label.set_rotation(90)\n        ax.yaxis.label.set_rotation(0)\n        ax.yaxis.labelpad = 50","16bb4f2d":"from sklearn.model_selection import train_test_split\ndata = np.asarray(df.values).astype(float)\nX = data[:,:11]\nY = data[:,11]\nx_train,x_test,y_train, y_test = train_test_split(X,Y,shuffle=True)\nprint(\"INPUT_SHAPE:\",x_train.shape)\nprint(\"OUTPUT_SHAPE:\",y_train.shape)","85648280":"# Simple Logistic Regression\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.linear_model import LogisticRegressionCV\nfrom sklearn.metrics import classification_report\nlogmodel = LogisticRegression()\nlogmodel.fit(x_train,y_train)\npredictions = logmodel.predict(x_test)\ntarget_names = ['Not Approved', 'Approved']\nprint(classification_report(y_test,predictions, target_names=target_names))","237c8af0":"logmodel = LogisticRegressionCV()\nlogmodel.fit(x_train,y_train)\npredictions = logmodel.predict(x_test)\ntarget_names = ['Not Approved', 'Approved']","84a2a49e":"print(classification_report(y_test,predictions, target_names=target_names))","7fcc8ccd":"from sklearn.svm import SVC\nclf = SVC(gamma='auto',probability=True)\nclf.fit(x_train,y_train) \npredictions = clf.predict(x_test)\nprint(classification_report(y_test,predictions, target_names=target_names))","e795bfaf":"from sklearn.tree import DecisionTreeClassifier\nclf = DecisionTreeClassifier(random_state=1,)\nclf.fit(x_train,y_train)\npredictions  = clf.predict(x_test)\nprint(classification_report(y_test,predictions, target_names=target_names))","47b3651c":"from sklearn.naive_bayes import BernoulliNB, MultinomialNB\nfrom sklearn.naive_bayes import GaussianNB","be3ade24":"clf = BernoulliNB()\nclf.fit(x_train,y_train)\npredictions  = clf.predict(x_test)\nprint(classification_report(y_test,predictions, target_names=target_names))","7c2dff96":"clf = MultinomialNB()\nclf.fit(x_train,y_train)\npredictions  = clf.predict(x_test)\nprint(classification_report(y_test,predictions, target_names=target_names))","ef328b56":"clf = GaussianNB()\nclf.fit(x_train,y_train)\npredictions  = clf.predict(x_test)\nprint(classification_report(y_test,predictions, target_names=target_names))","99bf6608":"from keras.models import Sequential\nfrom keras.layers import Dense, Activation\nfrom keras import backend as K","0dfae29c":"input_dimensions = X.shape[1]\n\n# Set up Model Topology\nmodel = Sequential()\nmodel.add(Dense(32,input_dim=input_dimensions))\nmodel.add(Activation('relu'))\nmodel.add(Dense(64,input_dim=32))\nmodel.add(Activation('relu'))\nmodel.add(Dense(128,input_dim=64))\nmodel.add(Activation('relu'))\nmodel.add(Dense(256,input_dim=128))\nmodel.add(Activation('relu'))\nmodel.add(Dense(128,input_dim=256))\nmodel.add(Activation('relu'))\nmodel.add(Dense(64,input_dim=128))\nmodel.add(Activation('relu'))\nmodel.add(Dense(32,input_dim=64))\nmodel.add(Activation('relu'))\nmodel.add(Dense(16,input_dim=32))\nmodel.add(Activation('relu'))\nmodel.add(Dense(1,input_dim=16))\nmodel.add(Activation('sigmoid'))\n\n# Set up Learning Processes\nmodel.compile(optimizer='rmsprop',\n              loss='binary_crossentropy', # we have a single output\n              metrics=['accuracy'])\n\n#Train the model (finally)\nmodel.fit(x_train,y_train,epochs=75)\npredictions = np.round(model.predict(x_test))\nprint(classification_report(y_test,predictions))\nscore = model.evaluate(x_test, y_test)","e3787f28":"# 75 epochs\npredictions = np.round(model.predict(x_test)) # either 0 or 1 since our training data is like that\nprint(classification_report(y_test,predictions,target_names=target_names))","e50002e8":"#87 epochs\nprint(classification_report(y_test,predictions,target_names=target_names))","cc66262f":"# Neural Network","da2d72f2":"Spliting data","fd2d2e88":"### Bernoulli","446f878e":"# Tree Classifier","a07df78e":"# Naive-Bayes Classifiers","8dafc758":"# ML Models","3bc18ae2":"# Data Analysis\/Visualization","12416064":"# Logistic Regression Model","4f320c3c":"####  Defining Custom Functions","3830ec3c":"# SVM Model","be752d47":"# Data Enconding\/Normalization\/Pre-processing","99c1b4dd":"### GaussianNB","6c334218":"### Multinomial","5e3a7b0d":"# Dependencies"}}