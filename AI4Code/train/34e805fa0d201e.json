{"cell_type":{"9d07f7f1":"code","bcd5cc4f":"code","21b4acb8":"code","40fc9558":"code","a24a6ba1":"code","192a05c9":"code","21d5c98f":"code","35f35f21":"code","b8d50727":"code","1037342e":"code","218bf2fc":"code","67716d4c":"code","2e1d272e":"code","414c24f7":"code","1d3b486d":"code","aef5aec1":"code","c8be5b2a":"code","1ba51fda":"code","85a871b0":"code","52b1f665":"code","28417474":"code","54929236":"code","d57002cb":"code","f479f50e":"code","339f65a0":"markdown","b939f39d":"markdown"},"source":{"9d07f7f1":"import numpy as np\nimport pandas as pd\n\nfrom pathlib import Path\nfrom typing import *\n\nimport torch\nimport torch.optim as optim","bcd5cc4f":"from fastai import *\nfrom fastai.vision import *\nfrom fastai.text import *\nfrom fastai.callbacks import *","21b4acb8":"%%bash\npip install pytorch-pretrained-bert","40fc9558":"class Config(dict):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        for k, v in kwargs.items():\n            setattr(self, k, v)\n    \n    def set(self, key, val):\n        self[key] = val\n        setattr(self, key, val)\n\nconfig = Config(\n    testing=False,\n    bert_model_name=\"bert-base-uncased\",\n    max_lr=3e-5,\n    epochs=4,\n    use_fp16=True,\n    bs=32,\n    discriminative=False,\n    max_seq_len=256,\n)","a24a6ba1":"from pytorch_pretrained_bert import BertTokenizer\nbert_tok = BertTokenizer.from_pretrained(\n    config.bert_model_name,\n)","192a05c9":"def _join_texts(texts:Collection[str], mark_fields:bool=False, sos_token:Optional[str]=BOS):\n    \"\"\"Borrowed from fast.ai source\"\"\"\n    if not isinstance(texts, np.ndarray): texts = np.array(texts)\n    if is1d(texts): texts = texts[:,None]\n    df = pd.DataFrame({i:texts[:,i] for i in range(texts.shape[1])})\n    text_col = f'{FLD} {1} ' + df[0].astype(str) if mark_fields else df[0].astype(str)\n    if sos_token is not None: text_col = f\"{sos_token} \" + text_col\n    for i in range(1,len(df.columns)):\n        #text_col += (f' {FLD} {i+1} ' if mark_fields else ' ') + df[i]\n        text_col += (f' {FLD} {i+1} ' if mark_fields else ' ') + df[i].astype(str)\n    return text_col.values","21d5c98f":"class FastAiBertTokenizer(BaseTokenizer):\n    \"\"\"Wrapper around BertTokenizer to be compatible with fast.ai\"\"\"\n    def __init__(self, tokenizer: BertTokenizer, max_seq_len: int=128, **kwargs):\n        self._pretrained_tokenizer = tokenizer\n        self.max_seq_len = max_seq_len\n\n    def __call__(self, *args, **kwargs):\n        return self\n\n    def tokenizer(self, t:str) -> List[str]:\n        \"\"\"Limits the maximum sequence length\"\"\"\n        return [\"[CLS]\"] + self._pretrained_tokenizer.tokenize(t)[:self.max_seq_len - 2] + [\"[SEP]\"]","35f35f21":"from sklearn.model_selection import train_test_split\n\nDATA_ROOT = Path(\"..\") \/ \"input\"\n\ntrain, test = [pd.read_csv(DATA_ROOT \/ fname) for fname in [\"train.csv\", \"test.csv\"]]\nval = train # we won't be using a validation set but you can easily create one using train_test_split","b8d50727":"if config.testing:\n    train = train.head(1024)\n    val = val.head(1024)\n    test = test.head(1024)","1037342e":"fastai_bert_vocab = Vocab(list(bert_tok.vocab.keys()))","218bf2fc":"fastai_tokenizer = Tokenizer(tok_func=FastAiBertTokenizer(bert_tok, max_seq_len=config.max_seq_len), pre_rules=[], post_rules=[])","67716d4c":"label_cols = [\"toxic\", \"severe_toxic\", \"obscene\", \"threat\", \"insult\", \"identity_hate\"]\n\n# databunch = TextDataBunch.from_df(\".\", train, val, test,\n#                   tokenizer=fastai_tokenizer,\n#                   vocab=fastai_bert_vocab,\n#                   include_bos=False,\n#                   include_eos=False,\n#                   text_cols=\"comment_text\",\n#                   label_cols=label_cols,\n#                   bs=config.bs,\n#                   collate_fn=partial(pad_collate, pad_first=False, pad_idx=0),\n#              )","2e1d272e":"class BertTokenizeProcessor(TokenizeProcessor):\n    def __init__(self, tokenizer):\n        super().__init__(tokenizer=tokenizer, include_bos=False, include_eos=False)\n\nclass BertNumericalizeProcessor(NumericalizeProcessor):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, vocab=Vocab(list(bert_tok.vocab.keys())), **kwargs)\n\ndef get_bert_processor(tokenizer:Tokenizer=None, vocab:Vocab=None):\n    \"\"\"\n    Constructing preprocessors for BERT\n    We remove sos\/eos tokens since we add that ourselves in the tokenizer.\n    We also use a custom vocabulary to match the numericalization with the original BERT model.\n    \"\"\"\n    return [BertTokenizeProcessor(tokenizer=tokenizer),\n            NumericalizeProcessor(vocab=vocab)]","414c24f7":"class BertDataBunch(TextDataBunch):\n    @classmethod\n    def from_df(cls, path:PathOrStr, train_df:DataFrame, valid_df:DataFrame, test_df:Optional[DataFrame]=None,\n                tokenizer:Tokenizer=None, vocab:Vocab=None, classes:Collection[str]=None, text_cols:IntsOrStrs=1,\n                label_cols:IntsOrStrs=0, label_delim:str=None, **kwargs) -> DataBunch:\n        \"Create a `TextDataBunch` from DataFrames.\"\n        p_kwargs, kwargs = split_kwargs_by_func(kwargs, get_bert_processor)\n        # use our custom processors while taking tokenizer and vocab as kwargs\n        processor = get_bert_processor(tokenizer=tokenizer, vocab=vocab, **p_kwargs)\n        if classes is None and is_listy(label_cols) and len(label_cols) > 1: classes = label_cols\n        src = ItemLists(path, TextList.from_df(train_df, path, cols=text_cols, processor=processor),\n                        TextList.from_df(valid_df, path, cols=text_cols, processor=processor))\n        src = src.label_for_lm() if cls==TextLMDataBunch else src.label_from_df(cols=label_cols, classes=classes)\n        if test_df is not None: src.add_test(TextList.from_df(test_df, path, cols=text_cols))\n        return src.databunch(**kwargs)","1d3b486d":"# this will produce a virtually identical databunch to the code above\ndatabunch = BertDataBunch.from_df(\".\", train, val, test,\n                  tokenizer=fastai_tokenizer,\n                  vocab=fastai_bert_vocab,\n                  text_cols=\"comment_text\",\n                  label_cols=label_cols,\n                  bs=config.bs,\n                  collate_fn=partial(pad_collate, pad_first=False, pad_idx=0),\n             )","aef5aec1":"from pytorch_pretrained_bert.modeling import BertConfig, BertForSequenceClassification\nbert_model = BertForSequenceClassification.from_pretrained(config.bert_model_name, num_labels=6)","c8be5b2a":"loss_func = nn.BCEWithLogitsLoss()","1ba51fda":"from fastai.callbacks import *\n\nlearner = Learner(\n    databunch, bert_model,\n    loss_func=loss_func,\n)\nif config.use_fp16: learner = learner.to_fp16()","85a871b0":"learner.lr_find()","52b1f665":"learner.recorder.plot()","28417474":"learner.fit_one_cycle(config.epochs, max_lr=config.max_lr)","54929236":"def get_preds_as_nparray(ds_type) -> np.ndarray:\n    \"\"\"\n    the get_preds method does not yield the elements in order by default\n    we borrow the code from the RNNLearner to resort the elements into their correct order\n    \"\"\"\n    preds = learner.get_preds(ds_type)[0].detach().cpu().numpy()\n    sampler = [i for i in databunch.dl(ds_type).sampler]\n    reverse_sampler = np.argsort(sampler)\n    return preds[reverse_sampler, :]","d57002cb":"test_preds = get_preds_as_nparray(DatasetType.Test)","f479f50e":"sample_submission = pd.read_csv(DATA_ROOT \/ \"sample_submission.csv\")\nif config.testing: sample_submission = sample_submission.head(test.shape[0])\nsample_submission[label_cols] = test_preds\nsample_submission.to_csv(\"predictions.csv\", index=False)","339f65a0":"Alternatively, we can pass our own list of Preprocessors to the databunch (this is effectively what is happening behind the scenes)","b939f39d":"# Model"}}