{"cell_type":{"af848b10":"code","15200581":"code","24b87d5f":"code","b9d26a1d":"code","83d94d44":"code","99b1e377":"code","adab490b":"markdown","0e766ee1":"markdown","f59c3404":"markdown","a39c7f61":"markdown","6d5808b7":"markdown","83b6bf94":"markdown","68a71a88":"markdown"},"source":{"af848b10":"import xlrd, pdb, numpy as np\nimport pandas as pd\nfrom scipy import stats\n\n\n\n##################### FIM IMPORTS\n\nclass patient():\n    def __init__(self, line, header):\n        self.id = line[0].value\n        data = dict()\n        i = 1\n        for key in header:\n            name = key.value.replace('\\xa0', ' ')\n            if name == 'Patient ID':\n                continue\n            if line[i].value == '':\n                data[name] = None\n            else:\n                if line[i].value == 'negative' or line[i].value == 'not_detected':\n                    data[name] = 0\n                else:\n                    if line[i].value == 'positive' or line[i].value == 'detected':\n                        data[name] = 1\n                    else:\n                        data[name] = line[i].value\n            i += 1\n        self.data = data\n\n\n####MAIN ANALISYS\n\n# DEFINICOES\nFILE_DATASET = \"\/kaggle\/input\/covid19\/dataset.xlsx\"  # destino do xlsx com a base de dados\nSHEET_NAME = \"All\"  # nome da planilha\nRATE_DATA_VALID = 0.9  # taxa do total de dados validas para validar analise da coluna\nRATE_DATA_TO_VERIFY = 0.7  # taxa de distorcao entre as integrais das duas distribuicoes normais das amostras\nRATE_DIFF_PROB_VALUE = 0.1  # taxa de diferen\u00e7a entre probabilidades\nCOLUMN_RESULT_COVID = \"SARS-Cov-2 exam result\"  # nome da coluna com resultado do exame do covid\nCOLUMN_VERIFY_HEMOGRAM = \"Hematocrit\"  # nome da colula para verificacao de hemograma presente\nCOVID = 1\nNO_COVID = 0\n\n# FIM DAS DEFINICOES\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\ncovid_base = xlrd.open_workbook(FILE_DATASET)\ndata = covid_base.sheet_by_name(SHEET_NAME)\n\npatient_list = dict()\nno_float_data = list()\n\n# inclusao dos dados na classe patient\nfor i in range(1, data.nrows):\n    p = patient(data.row(i), data.row(0))\n    patient_list[p.id] = p\n\nprint(\"Total de Registros:\",data.nrows)","15200581":"# verificando dados float\nfor patient in patient_list:\n    for data_type in patient_list[patient].data:\n        if ((type(patient_list[patient].data[data_type]) != float)\n            or (int(patient_list[patient].data[data_type]) == patient_list[patient].data[data_type]))   \\\n                and (patient_list[patient].data[data_type] != None):\n            if data_type not in no_float_data:\n                no_float_data.append(data_type)\n                \nprint(\"colunas n\u00e3o verificadas:\",no_float_data)","24b87d5f":"count_data_ok = dict()\n\ncount_hemogram = 0\nhas_hemogram = list()\n\nfor patient in patient_list:\n    # Verifica se paciente tem hemograma pelo dados nao nulos na coluna COLUMN_VERIFY_HEMOGRAM\n    if patient_list[patient].data[COLUMN_VERIFY_HEMOGRAM] != None:\n        count_hemogram += 1\n        has_hemogram.append(patient)\n        # conta o numero de amostras com dados de hemograma\n        for data_type in patient_list[patient].data:\n            if data_type not in count_data_ok:\n                count_data_ok[data_type] = 0\n            if patient_list[patient].data[data_type] != None:\n                count_data_ok[data_type] += 1\n\nvalid_data = list()\n\n# lista de colunas que ser\u00e3o excluidas da an\u00e1lise\nexclude_data = [\"Patient age quantile\"]\n\nlist_analisys = dict()\n\nprint(\"Colunas validadas:\")\n# verifica lista que tem dados validos\nfor data_type in count_data_ok:\n    if (count_data_ok[data_type] > RATE_DATA_VALID * count_hemogram) \\\n            and (data_type not in exclude_data) \\\n            and (data_type not in no_float_data):\n        # print(data_type, count_data_ok[data_type])\n        valid_data.append(data_type)\n        print(data_type,\"->\",count_data_ok[data_type],\"valores\")\n","b9d26a1d":"for patient in has_hemogram:\n    for data_type in valid_data:\n        if data_type not in list_analisys:\n            list_analisys[data_type] = dict()\n        if patient_list[patient].data[data_type] != None:\n            # separa dados v\u00e1lidas entre os pacientes diagnostidos com COVID e SEM COVID\n            if patient_list[patient].data[COLUMN_RESULT_COVID] == COVID:\n                if COVID not in list_analisys[data_type]:\n                    list_analisys[data_type][COVID] = list()\n                list_analisys[data_type][COVID].append(patient_list[patient].data[data_type])\n            else:\n                if NO_COVID not in list_analisys[data_type]:\n                    list_analisys[data_type][NO_COVID] = list()\n                list_analisys[data_type][NO_COVID].append(patient_list[patient].data[data_type])\n\nlist_to_verify = list()\nprint(\"Colunas Refer\u00eancia:\")\nfor data_type in list_analisys:\n\n    # calcula as medias e os desvios padrao das duas amostras\n    mean_covid = np.mean(list_analisys[data_type][COVID])\n    sigma_covid = np.std(list_analisys[data_type][COVID])\n    mean_no_covid = np.mean(list_analisys[data_type][NO_COVID])\n    sigma_no_covid = np.std(list_analisys[data_type][NO_COVID])\n\n    # determina a regiao de comparacao das distribui\u00e7\u00f5es normais das amostras (utilizamos 1 sigma)\n    center = (mean_covid + mean_no_covid)\/2\n\n    # calcula a integral das distribui\u00e7\u00f5es normais das amostras no ponto centro das medias mais o maior sigma\n\n    integral_covid = stats.norm.cdf(center, loc=mean_covid, scale=sigma_covid)\n    integral_no_covid = stats.norm.cdf(center, loc=mean_no_covid, scale=sigma_no_covid)\n\n    compare = np.amin([integral_covid, integral_no_covid]) \/ np.amax([integral_covid, integral_no_covid])\n\n    # verifica se existe distorcao entre as distribuicoes normais que possa ser utilizado para a comparacao\n    # entre pacientes com COVID e sem COVID\n    if compare < RATE_DATA_TO_VERIFY:\n        list_to_verify.append(data_type)\n\nprint(list_to_verify)\n","83d94d44":"score = dict()\n\nfor patient in has_hemogram:\n    if patient not in score:\n        score[patient] = dict()\n        score[patient][COVID] = 0\n        score[patient][NO_COVID] = 0\n\n    for data_type in list_to_verify:\n\n        outlier_covid = False\n        outlier_no_covid = False\n        # calcula as medias e os desvios padrao das duas amostras\n        mean_covid = np.mean(list_analisys[data_type][COVID])\n        sigma_covid = np.std(list_analisys[data_type][COVID])\n        mean_no_covid = np.mean(list_analisys[data_type][NO_COVID])\n        sigma_no_covid = np.std(list_analisys[data_type][NO_COVID])\n\n        # calcula a probabilidade das m\u00e9dias, como refer\u00eancia de valor m\u00e1ximo da curva\n        prob_mean_covid = stats.norm.pdf(mean_covid, scale=sigma_covid, loc=mean_covid)\n        prob_mean_no_covid = stats.norm.pdf(mean_no_covid, scale=sigma_no_covid, loc=mean_no_covid)\n\n        data_value_patient = patient_list[patient].data[data_type]\n        # se existe algum valor nulo nos dados da list_to_verify nao calcula\n        if data_value_patient == None:\n            continue\n\n        # calcula o valor da probabilidade dos valores nas duas curvas de distrbui\u00e7\u00e3o e divide pelo m\u00e1ximo (normaliza)\n        prob_data_value_patient_covid = stats.norm.pdf(data_value_patient, loc=mean_covid,\n                                                       scale=sigma_covid) \/ prob_mean_covid\n        prob_data_value_patient_no_covid = stats.norm.pdf(data_value_patient, loc=mean_no_covid,\n                                                          scale=sigma_no_covid) \/ prob_mean_no_covid\n        rate = abs(prob_data_value_patient_covid \/ prob_data_value_patient_no_covid)\n\n        # verifica qual a probabilidade maior COVID ou NAO COVID. SE diferen\u00e7a for menor que RATE_DIFF_PROB_VALUE\n        # o resultado \u00e9 inconclusivo\n        if NO_COVID not in score[patient]:\n            score[patient][NO_COVID] = 0\n        if COVID not in score[patient]:\n            score[patient][COVID] = 0\n\n        # verifica de valor esta fora de 3 sigma\n        if data_value_patient < mean_covid - 3 * sigma_covid or data_value_patient > mean_covid + 3 * sigma_covid:\n            outlier_covid = True\n\n        if data_value_patient < mean_no_covid - 3 * sigma_no_covid or data_value_patient > mean_no_covid + 3 * sigma_no_covid:\n            outlier_no_covid = True\n\n        if (outlier_covid is False) or (outlier_no_covid is False):\n            if (rate > 1 + RATE_DIFF_PROB_VALUE) or (outlier_no_covid):\n                score[patient][COVID] += 1\n            if rate < 1 - RATE_DIFF_PROB_VALUE or (outlier_covid):\n                score[patient][NO_COVID] += 1\n","99b1e377":"count_result_ok_covid = 0\ncount_total_covid = 0\ncount_result_ok_no_covid = 0\ncount_total_no_covid = 0\ncount_result_ok = 0\ncount_total = 0\n\n# verifica a lista de pacientes com todos os dados completos para a realizacao do teste\nhas_all_data = list()\n\nfor patient in has_hemogram:\n    miss_data = False\n    for data_type in list_to_verify:\n        data_value_patient = patient_list[patient].data[data_type]\n        if data_value_patient == None:\n            miss_data = True\n\n    if (miss_data == False):\n        has_all_data.append(patient)\n\n# compara os resultados previstos e os realidos\nfor patient in has_all_data:\n    if score[patient][COVID] > score[patient][NO_COVID]:\n        result = COVID\n    else:\n        result = NO_COVID\n\n    if (patient_list[patient].data[COLUMN_RESULT_COVID] == COVID):\n        count_total_covid += 1\n        if result == COVID:\n            count_result_ok_covid += 1\n    else:\n        count_total_no_covid += 1\n        if result == NO_COVID:\n            count_result_ok_no_covid += 1\n\ncount_result_ok = count_result_ok_covid + count_result_ok_no_covid\ncount_total = count_total_covid + count_total_no_covid\n\nprint(\"COVID => OK:\", count_result_ok_covid, \"TOTAL:\", count_total_covid, \"ACCURACY:\",\n      count_result_ok_covid \/ count_total_covid)\nprint(\"NO_COVID => OK:\", count_result_ok_no_covid, \"TOTAL:\", count_total_no_covid, \"ACCURACY:\",\n      count_result_ok_no_covid \/ count_total_no_covid)\nprint(\"TOTAL => OK:\", count_result_ok, \"TOTAL:\", count_total, \"ACCURACY:\", count_result_ok \/ count_total)\n\nmy_submission = pd.DataFrame({'TYPE': ['COVID', 'NO_COVID', 'TOTAL'],\n                              'OK': [count_result_ok_covid, count_result_ok_no_covid, count_result_ok],\n                              'TOTAL': [count_total_covid, count_total_no_covid, count_total],\n                              'ACCURACY': [count_result_ok_covid \/ count_total_covid,\n                                           count_result_ok_no_covid \/ count_total_no_covid,\n                                           count_result_ok \/ count_total] })\n# you could use any filename. We choose submission here\nmy_submission.to_csv('submission.csv', index=False )","adab490b":"Descartamos os pacientes que n\u00e3o tem dados suficientes para a an\u00e1lise. Deixamos somente os pacientes que possuem infoma\u00e7\u00f5es de hemograma, num total de 603 pacientes.<br \/>\nDescartamos da an\u00e1lise, colunas com menos de 540 valores, que \u00e9 90% (valor configur\u00e1vel) dos pacientes com hemograma.\n\n> Esta amostra \u00e9 muito pequena para uma predi\u00e7\u00e3o mais precisa. ","0e766ee1":"Este algor\u00edtmo foi construido baseado na an\u00e1lise da distribui\u00e7\u00e3o normal de probabilidade dos resultados dos exames, comparando pessoas infectadas e n\u00e3o infectadas com COVID-19.<br \/>\n![image.png](attachment:image.png)","f59c3404":"Definidos os conjuntos de dados que ser\u00e3o utilizados com refer\u00eancia na an\u00e1lise. Temos ent\u00e3o, nosso algoritmo \"treinado\" para receber as informa\u00e7\u00f5es dos pacientes e indicar se est\u00e3o infectados ou n\u00e3o.<br \/>\n\nQuando o programa recebe as informa\u00e7\u00f5es dos exames dos pacientes, ele obt\u00e9m o valor da probabilidade em cada uma das curvas de distribui\u00e7\u00e3o normal, infectadas e n\u00e3o infectadas. Esse valor \u00e9 dividido pelo valor de probabilidade m\u00e1xima da curva, tendo assim um valor percentual da probabilidade m\u00e1xima.<br \/>\nComparamos os valores obtidos nas duas curvas e indicamos a curva em que o valor de probabilidade foi maior.< br\/>\nFazemos este procedimento para todos os tipos de dados refer\u00eancia, e verificamos quantos valores est\u00e3o indicados como infectados e como n\u00e3o infectados. O grupo que obtiver a maioria ser\u00e1 a predi\u00e7\u00e3o do programa para aquele paciente.\n> Para a realiza\u00e7\u00e3o de testes, utilizamos os dados dos pacientes listados na base de dados.\n","a39c7f61":"Ap\u00f3s a importa\u00e7\u00e3o dos dados, filtramos as colunas que cont\u00e9m valores do tipo **float**.","6d5808b7":"Por fim totalizamos as informa\u00e7\u00f5es e calculamos a precis\u00e3o na an\u00e1lise.","83b6bf94":"Nesta fase do c\u00f3digo, separamos os dados entre pacientes infectados e n\u00e3o infectados pelo COVID-19. Geramos as curvas de  distribui\u00e7\u00e3o normal para cada conjunto de dados e verificamos se as duas distribui\u00e7\u00f5es possuem diferen\u00e7as suficientes para serem utilizadas como colunas refer\u00eancia.\n> Caso tenhamos maior quantidade de dados, poderiamos clusterizar os dados tamb\u00e9m por idade ou por exames parecidos. Neste momento, seccionar a amostra de pacientes infectados, por idade por exemplo, n\u00e3o melhoraria a predi\u00e7\u00e3o.","68a71a88":"Verificando o resultado obtido podemos concluir que o modelo \u00e9 excelente, com **80%** de precis\u00e3o, sendo **75%** para os casos positivos e **81%** para casos negativos do COVID-19. A precis\u00e3o no predi\u00e7\u00e3o dos infectados foi menor devido ao n\u00famero de dados de infectados ser 6 vezes menor que o de n\u00e3o infectados. A medida que a base de dados aumenta, a precis\u00e3o ir\u00e1 aumentar.<br \/>\nOutra oportunidade de melhoria seria o seccionamento dos dados por idade, por\u00e9m a quantidade de dados de infectados \u00e9 muito pequena para realizamos essa clusteriza\u00e7\u00e3o e podermos validar a efic\u00e1cia.\nO desempenho pode ainda ser otimizado com a ajuda de especialistas da \u00e1rea m\u00e9dica, pois assim, pode ser adicionado sentido biol\u00f3gico aos par\u00e2metros analisados, como por exemplo, atribuir diferentes pesos aos par\u00e2metros durante a tomada de decis\u00e3o de acordo com a influ\u00eancia desta infec\u00e7\u00e3o viral em sua grandeza.<br \/>\n\n"}}