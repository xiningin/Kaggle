{"cell_type":{"4b30b774":"code","ef631db8":"code","5c4b3051":"code","0cf9b7d9":"code","d11dc824":"code","064500b3":"code","ab7777da":"code","d50a80d6":"code","2f4de85d":"code","65ddbab5":"code","f5400505":"code","a4c83f11":"code","be30b62c":"code","48a56ef9":"code","a1f48eb0":"code","7cce23ef":"code","20538eda":"code","40c2e366":"code","27bad17e":"code","afae2df1":"code","6aba10d6":"code","33b47de2":"code","942ff181":"markdown","408191f1":"markdown","adaee088":"markdown","9a5ff6c8":"markdown","84450308":"markdown","81829efc":"markdown","1bcb389a":"markdown","876064d9":"markdown","dfba8ddf":"markdown","318f3d29":"markdown","0a59c701":"markdown","ccc29852":"markdown","3d7fc4ba":"markdown","e30ae54d":"markdown","3c704cfd":"markdown","0afffe5c":"markdown","ecf6e70a":"markdown","763a8f10":"markdown","df655d17":"markdown","619407ab":"markdown"},"source":{"4b30b774":"import time\nimport gc\nimport pickle\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\nfrom sklearn.metrics.pairwise import cosine_similarity\nimport tensorflow as tf\nimport keras\nfrom tensorflow.keras.layers import Input, Embedding, Reshape, Dot, Concatenate, Dense, Dropout\nfrom tensorflow.keras.models import Model","ef631db8":"with open('..\/input\/10-netflix-movie-recommender-part-1\/test_user_ids_list.txt', 'rb') as fp:\n    test_user_ids_list=pickle.load(fp)\n    \nwith open('..\/input\/10-netflix-movie-recommender-part-1\/test_movie_ids_list.txt', 'rb') as fp:\n    test_movie_ids_list=pickle.load(fp)\n    \nwith open('..\/input\/10-netflix-movie-recommender-part-1\/train_movie_ids_list.txt', 'rb') as fp:\n    train_movie_ids_list=pickle.load(fp)\n    \nwith open('..\/input\/10-netflix-movie-recommender-part-1\/train_movie_average_ratings_list.txt', 'rb') as fp:\n    train_movie_average_ratings_list=pickle.load(fp)","5c4b3051":"# {user_id_1: True, user_id_2: True, ...}\ntest_user_ids={}\n# {user_id_1: [movie_id_1, movie_id_2, ...], ...}\ntrain_movie_ids={}\n# {user_id_1: rating_1, user_id_2: rating_2, ...}\ntrain_movie_average_ratings={}\n\nfor ele in test_user_ids_list:\n    test_user_ids[ele]=True\n    \nfor ele in train_movie_ids_list:\n    train_movie_ids[ele[0]]=ele[1]\n    \nfor ele in train_movie_average_ratings_list:\n    train_movie_average_ratings[ele[0]]=ele[1]\n\n# {user_id_1: [movie_id_3, ...], ...} \n# the number of users in test_movie_ids is smaller than total number of users in the test set\n# because some users in the test set give all ratings as negative (lower than average in train set)\ntest_movie_ids={}\n\nfor ele in test_movie_ids_list:\n    test_movie_ids[ele[0]]=ele[1]\n\ndel test_movie_ids_list, test_user_ids_list, train_movie_average_ratings_list, train_movie_ids_list","0cf9b7d9":"len(test_user_ids), len(test_movie_ids), len(train_movie_average_ratings), len(train_movie_ids)","d11dc824":"df_train=pd.read_pickle(\"..\/input\/10-netflix-movie-recommender-part-1\/df_train.pkl\")\ndf_test=pd.read_pickle(\"..\/input\/10-netflix-movie-recommender-part-1\/df_test.pkl\")\ndf_val=pd.read_pickle(\"..\/input\/10-netflix-movie-recommender-part-1\/df_val.pkl\")\ncombined_df=pd.read_pickle(\"..\/input\/10-netflix-movie-recommender-part-1\/combined_df.pkl\")","064500b3":"# Create user and movie-id mapping to convert to numbers\nuser_id_mapping = {id:i for i, id in enumerate(df_train['User'].unique())}\nmovie_id_mapping = {id:i for i, id in enumerate(df_train['Movie'].unique())}","ab7777da":"# use dataframe map function to map users & movies to mapped ids based on above mapping\nX_train_user = df_train['User'].map(user_id_mapping).values\nX_train_movie = df_train['Movie'].map(movie_id_mapping).values\n\n# do the same for val and test sets\nX_val_user = df_val['User'].map(user_id_mapping).values\nX_val_movie = df_val['Movie'].map(movie_id_mapping).values\n\nX_test_user = df_test['User'].map(user_id_mapping).values\nX_test_movie = df_test['Movie'].map(movie_id_mapping).values","d50a80d6":"from collections import OrderedDict\ntemp=combined_df.reset_index()[['Id','weighted score']].sort_values('weighted score', ascending=False)\n\n# {movie_id: weighted_score, ....}\nrank_dic=OrderedDict()\nfor i in range(temp.shape[0]):\n    rank_dic[temp.iloc[i,0]]=temp.iloc[i,1]\n\ndel temp","2f4de85d":"Y_train=df_train['Rating'].values.copy()-df_train['Movie'].map(rank_dic).values.copy()\n\nY_val=df_val['Rating'].values.copy()-df_val['Movie'].map(rank_dic).values.copy()\n\n_=gc.collect()","65ddbab5":"# Get input variable-sizes\nusers = int(len(user_id_mapping) * 1.1)  # reserve space for new users\nmovies = len(movie_id_mapping)","f5400505":"embedding_size = 100\n\n# use Input() to create tensors for - 'user' and 'movie'\nuser_id_input = Input(shape=(1,), name='user')\nmovie_id_input =  Input(shape=(1,), name='movie')\n\n# Create embedding layer for users \nuser_embedding = Embedding(output_dim=embedding_size, \n                           input_dim=users,\n                           input_length=1, \n                           embeddings_regularizer=tf.keras.regularizers.l2(0.0000001),\n                           name='user_embedding')(user_id_input)\n\n# create embedding layer for movies \nmovie_embedding = Embedding(output_dim=embedding_size, \n                           input_dim=movies,\n                           input_length=1, \n                           embeddings_regularizer=tf.keras.regularizers.l2(0.0000001),\n                           name='movie_embedding')(movie_id_input)\n\nuser_vector = Reshape([embedding_size])(user_embedding)\nmovie_vector = Reshape([embedding_size])(movie_embedding)\n\noutput = Dot(1, normalize=False)([user_vector, movie_vector])\n\nmodel = Model(inputs=[user_id_input, movie_id_input], outputs=output)\nmodel.compile(loss='mse', optimizer=tf.keras.optimizers.Adam(learning_rate=3e-4))","a4c83f11":"batch_size = 1024\nepochs = 20\n\nes = tf.keras.callbacks.EarlyStopping(monitor='val_loss', \n                                      patience=1,\n                                      restore_best_weights=True,\n                                      verbose=1)\n\nmodel.fit([X_train_user, X_train_movie], Y_train,\n          batch_size=batch_size, \n          epochs=epochs,\n          validation_data=([X_val_user, X_val_movie], Y_val),\n          #validation_split=1\/280.0,\n          shuffle=True,\n          callbacks=[es],\n          verbose=1)\n\ndel X_train_user, X_train_movie, Y_train, X_val_user, X_val_movie, Y_val\n_=gc.collect()","be30b62c":"model.save('collaborative.h5')","48a56ef9":"y_pred=model.predict([X_test_user, X_test_movie]).flatten()\n\n# add back the weighted score\ny_pred+=df_test['Movie'].map(rank_dic).values.copy()\n\n# clip the predicted score that's lower than 1 or larger than 5\ny_pred = np.array(list(map(lambda x: 1.0 if x < 1 else 5.0 if x > 5.0 else x, y_pred)))\n\ny_true = df_test['Rating'].values\n\nrmse = np.sqrt(mean_squared_error(y_true=y_true, y_pred=y_pred))\nmae = mean_absolute_error(y_true=y_true, y_pred=y_pred)\nprint(\"The RMSE Value for the Mean Rating Recommender:\", rmse)\nprint(\"The MAE Value for the Mean Rating Recommender:\", mae)","a1f48eb0":"def make_pred(user_id, movie_id, model, rank_dic):\n    if type(user_id)!=type('asdf'):\n        print('please enter a string for user id')\n        return None\n    if movie_id not in movie_id_mapping:\n        print('movie id non-existent')\n        \n    if user_id not in user_id_mapping:\n        user=users-1\n    else:\n        user=user_id_mapping[user_id]\n        \n    movie=movie_id_mapping[movie_id]\n    pred=model.predict([np.array([user]), np.array([movie])])\n    pred+=rank_dic[movie_id]\n    return pred[0,0]","7cce23ef":"user_id='asdf'\nmovie_id=5\nmake_pred(user_id, movie_id, model, rank_dic), rank_dic[movie_id] ","20538eda":"user_id=list(test_user_ids.keys())[7]\nmovie_id=5\nmake_pred(user_id, movie_id, model, rank_dic), rank_dic[movie_id] ","40c2e366":"def average_precision_at_k(rel: [int], pred: [int], k: int) -> float:\n    # this function works only for a single user\n    # rel is an list of movie id's for all relevant movies in the test set \n    # pred is the prediction of the model excluding those ratings already in the training set\n    # pred is a list of movie id's whose scores are ranked from high to low\n    # len(pred) should be large enough for k\n    # k is the cutoff\n    temp=0\n    true_positive=0\n    for i in range(min(k,len(pred))):\n        if pred[i] in rel:\n            true_positive+=1\n            temp+=true_positive\/(i+1)\n    return temp\/len(rel)","27bad17e":"result1=[]\nresult2=[]\nuser_list=list(test_movie_ids.keys())\n\nmile=len(user_list)\/\/100\nct=0\n\nfor i in range(len(user_list)):\n    \n    if ct%mile==1: \n        print(ct\/\/mile)\n        print('collaborative ', sum(result1)\/len(result1))\n        print('global ', sum(result2)\/len(result2))\n    ct+=1\n\n    user=user_list[i]\n\n    rank_dic_copy=rank_dic.copy()\n\n    rel=test_movie_ids[user]\n\n    pred=[]\n    # list of movies already rated in train set\n    already=train_movie_ids[user]\n\n    # remove movies that are already in the train set\n    for ele in already:\n        rank_dic_copy.pop(ele)\n\n    # save a copy of movie ids\n    aaa=list(rank_dic_copy.keys())\n\n    # map movie ids to movie vocabulary number\n    X_movie=pd.Series(np.array(aaa)).map(movie_id_mapping).values\n    # map user ids to user vocabulary number\n    X_user=pd.Series(np.array([user for i in range(X_movie.shape[0])])).map(user_id_mapping).values\n\n    Y=model.predict([X_user, X_movie])\n    Y=Y[:,0]\n    Y=list(Y)\n\n    pred=[]\n    for iii, y in enumerate(Y):\n        pred.append([aaa[iii], y+rank_dic[aaa[iii]]])\n\n    # sort by score from high to low\n    pred.sort(key=lambda x : x[1], reverse=True)\n    pred=np.array(pred)\n    pred=pred[:,0]\n    pred=list(pred)\n    #print(len(pred))\n    result1.append(average_precision_at_k(rel, pred, 100000))\n\n    copy_dic=rank_dic.copy()\n    for ele in train_movie_ids[user]:\n        copy_dic.pop(ele)\n    pred=list(copy_dic.keys())\n    #print(len(pred))\n    result2.append(average_precision_at_k(rel, pred, 100000))","afae2df1":"print('there are {} users in the test set'.format(len(test_user_ids)))\nprint('there are {} users whose ratings in the test set are all negative'.format(len(test_user_ids)-len(test_movie_ids)))\nprint('mean average precision for collaborative method is {}'.format(sum(result1)\/len(result1)))\nprint('mean average precision for gloabl method is {}'.format(sum(result2)\/len(result2)))","6aba10d6":"result=[]\n\nuser_list=list(test_movie_ids.keys())\n\nfor i in range(len(user_list)):\n    \n    user=user_list[i]\n    rel=test_movie_ids[user]\n\n    copy_dic=rank_dic.copy()\n    for ele in train_movie_ids[user]:\n        copy_dic.pop(ele)\n    pred=list(copy_dic.keys())\n    #print(len(pred))\n    result.append(average_precision_at_k(rel, pred, 100))","33b47de2":"sum(result)\/len(result)","942ff181":"## build the collaborative filtering model","408191f1":"## model evaluation","adaee088":"## load output of Part 1","9a5ff6c8":"**for a known user, compare the predicted score and the weighted average score**","84450308":"### convert list to dictionaries","81829efc":"### <font color='red'> reserve space for new users, here we don't handle new movies <\/font> ","1bcb389a":"### load lists","876064d9":"**for a unknown\/new user, the predicted score is simply weighted average score**","dfba8ddf":"**loop through users in test set and apply the function we defined**","318f3d29":"**define the function that calculates average precision**","0a59c701":"## train the model","ccc29852":"# In part 2 of the project, we're trying to build a collaborative-filtering based movie recommender by following the matrix factorization approach. We will subtract the weighted average movie ratings from the actual ratings so that for a new user (or a user who hasn't rated any movies) the predicted rating will be the weighted avergae movie ratings instead of zero. At the end we will evaluate our model with RMSE, MAE and Mean Average Precision. The result will be compared to the global recommender baseline.","3d7fc4ba":"### evaluate mean average precision","e30ae54d":"### evaluate rmse on test set","3c704cfd":"**rank_dic defined for global recommender mean average precision evaluation**","0afffe5c":"## preparation for the collaborative filtering model","ecf6e70a":"### define a function that makes prediction","763a8f10":"## import dependencies","df655d17":"### <font color='red'> Subtract the weighted score from the actual rating. As a result, for users who haven't rated any movies we will use weighted average scores of movies as predictions <\/font> ","619407ab":"### load dataframes"}}