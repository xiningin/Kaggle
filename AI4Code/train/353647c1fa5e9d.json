{"cell_type":{"d598fd68":"code","6f93ef4b":"code","e0307404":"code","cefa6b7c":"code","896122c2":"code","f3e25f91":"code","98e34b62":"code","c6adcaef":"markdown","6eb4ea1b":"markdown","95baf4ea":"markdown","32b888cd":"markdown","0cfaedb1":"markdown","7666ae79":"markdown","9ecb737d":"markdown","9448f579":"markdown","f244b63a":"markdown","ef5288cc":"markdown","ad579b6f":"markdown","4279c193":"markdown","f1c59efe":"markdown","ba2dca18":"markdown","c0823eb3":"markdown"},"source":{"d598fd68":"import numpy as np\nfrom sklearn.datasets import make_blobs\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nX, y = make_blobs(n_samples=1000, centers=2, n_features=2, random_state=1, cluster_std=3)\n\nplt.figure(figsize=(8.0, 8.0))\nplt.scatter(X[:,0], X[:,1], c=y)","6f93ef4b":"class MyModel:\n  # \u5b66\u7fd2\u7d50\u679c\u3092\u683c\u7d0d\u3059\u308b\u30c4\u30ea\u30fc\n  tree = dict()\n\n  # \u30b8\u30cb\u4fc2\u6570\u306e\u7b97\u51fa\n  def gini(self, y, classes):\n    sum = 0\n    for c in classes:\n      count = np.count_nonzero(y == c)\n      sum += (count\/len(y))**2\n    return 1 - sum\n  \n  # 1\u3064\u306e\u30ab\u30e9\u30e0\u306e1\u3064\u306e\u5024\u3067\u5bfe\u8c61\u30c7\u30fc\u30bf\u3092\u5206\u3051\u305f\u3068\u304d\u306e\u5e73\u5747\u6642\u306b\u4fc2\u6570\u306e\u7b97\u51fa\n  def mean_gini(self, X, y, column, value):\n    classes = np.unique(y)\n    group_a_X = X[X[:,column] < value,:]\n    group_b_X = X[X[:,column] >= value,:]\n    if len(group_a_X) == 0 or len(group_b_X) == 0:\n      return None\n    group_a_y = y[X[:,column] < value]\n    group_b_y = y[X[:,column] >= value]\n    gini_a = self.gini(group_a_y,classes)\n    gini_b = self.gini(group_b_y,classes)\n    return len(group_a_X)\/len(X) * gini_a + len(group_b_X)\/len(X) * gini_b\n\n  # \u5b66\u7fd2\n  # self.tree\u306b\u5b66\u7fd2\u7d50\u679c\u3092\u683c\u7d0d\u3059\u308b\n  def fit(self, X, y, depth=4):\n    self.depth = depth\n    self.num_columns = X.shape[1]\n    self.min_values = np.amin(X, axis=0)\n    self.max_values = np.amax(X, axis=0)\n    self.tree = self.find_smallest_mean_gini(X, y, 1)\n  \n\n  def find_smallest_mean_gini(self, X, y, current_depth, prev_column=None, prev_value=None, condition=None):\n    if current_depth > self.depth:\n      if condition == 'lower':\n        group_a_y = y[X[:,prev_column] < prev_value]\n        counts = np.bincount(group_a_y)\n      if condition == 'greater':\n        group_b_y = y[X[:,prev_column] >= prev_value]\n        counts = np.bincount(group_b_y)\n      label = np.argmax(counts)\n      return dict({\n        'label':label,\n        'is_edge': True\n      })\n\n    gini_scores = []\n    # \u5168\u3066\u306e\u30ab\u30e9\u30e0\u30fb\u5024\u3067\u5e73\u5747\u30b8\u30cb\u4fc2\u6570\u3092\u8a08\u7b97\u3059\u308b\n    for column in range(self.num_columns):\n      if prev_column == column:\n        continue\n      all_value = X[:,column]\n      min_value = self.min_values[column]\n      max_value = self.max_values[column]\n      # \u73fe\u72b6\u30b8\u30cb\u4fc2\u6570\u3092\u8a08\u7b97\u3059\u308b\u9593\u9694\u30920.1\u306b\u3057\u3066\u3044\u308b\u304c\u3001\n      # \u30ab\u30e9\u30e0\u306e\u30b9\u30b1\u30fc\u30eb\u306b\u5408\u308f\u305b\u308b\u3088\u3046\u306b\u3057\u305f\u307b\u3046\u304c\u826f\u3055\u305d\u3046\n      for value in np.arange(min_value, max_value, 0.1):\n        mean_gini = self.mean_gini(X, y, column, value)\n        if mean_gini is not None:\n          gini_scores.append(dict({\n              'column': column,\n              'value': value,\n              'gini': mean_gini\n          }))\n    sorted_scores = sorted(gini_scores, key=lambda d: d['gini'])\n    if len(sorted_scores) == 0:\n      counts = np.bincount(y)\n      label = np.argmax(counts)\n      return dict({\n        'label':label,\n        'is_edge': True\n      })\n    best_score = sorted_scores[0]\n    condition = dict({\n      'column': best_score['column'],\n      'value': best_score['value'],\n      'children': dict(),\n      'is_edge': False,\n      'depth': current_depth\n    })\n    # \u6307\u5b9a\u3055\u308c\u305f\u6728\u306e\u6df1\u3055\u5206\u3001\u518d\u5e30\u7684\u306b\u540c\u3058\u95a2\u6570\u3092\u547c\u3073\u51fa\u3059\n    if current_depth <= self.depth:\n      group_a_X = X[X[:,best_score['column']] < best_score['value'],:]\n      group_b_X = X[X[:,best_score['column']] >= best_score['value'],:]\n      if len(group_a_X) != 0:\n        group_a_y = y[X[:,best_score['column']] < best_score['value']]\n        condition['children']['lower'] = self.find_smallest_mean_gini(group_a_X, group_a_y, current_depth+1, best_score['column'], best_score['value'], 'lower')\n      if len(group_b_X) != 0:\n        group_b_y = y[X[:,best_score['column']] >= best_score['value']]\n        condition['children']['greater'] = self.find_smallest_mean_gini(group_b_X, group_b_y, current_depth+1, best_score['column'], best_score['value'], 'greater')\n    return condition\n\n  # \u4e88\u6e2c\n  def predict(self, X):\n    result = []\n    for x in X:\n      node = self.tree\n      for _ in range(self.depth):\n        if node['is_edge'] is True:\n          break\n        if x[node['column']] < node['value']:\n          node = node['children']['lower']\n        elif x[node['column']] >= node['value']:\n          node = node['children']['greater']\n      result.append(node['label'])\n    return np.array(result)","e0307404":"import pprint\nmyModel = MyModel()\nmyModel.fit(X,y, depth=2)\npp = pprint.PrettyPrinter(indent=2)\npp.pprint(myModel.tree)","cefa6b7c":"def plotBoundary(X, y, depth=4):\n  # \u56f3\u306e\u7e26\u8ef8\u3001\u6a2a\u8ef8\u306e\u6700\u5c0f\u3001\u6700\u5927\u5024\u3092\u53d6\u5f97\u3059\u308b\n  min1, max1 = X[:, 0].min()-1, X[:, 0].max()+1\n  min2, max2 = X[:, 1].min()-1, X[:, 1].max()+1\n  # \u30b0\u30ea\u30c3\u30c9\u4f5c\u6210\u7528\u306e\u914d\u5217\u53d6\u5f97\n  x1grid = np.arange(min1, max1, 0.1)\n  x2grid = np.arange(min2, max2, 0.1)\n  xx, yy = np.meshgrid(x1grid, x2grid)\n  r1, r2 = xx.flatten(), yy.flatten()\n  r1, r2 = r1.reshape((len(r1), 1)), r2.reshape((len(r2), 1))\n  grid = np.hstack((r1,r2))\n  # \u30e2\u30c7\u30eb\u306e\u4f5c\u6210\n  myModel = MyModel()\n  # \u30e2\u30c7\u30eb\u306e\u5b66\u7fd2\n  myModel.fit(X, y, depth=depth)\n  # \u30b0\u30ea\u30c3\u30c9\u5168\u3066\u306e\u4e88\u6e2c\u3092\u884c\u3046\n  yhat = myModel.predict(grid)\n  # \u63cf\u5199\n  zz = yhat.reshape(xx.shape)\n  plt.contourf(xx, yy, zz, cmap='Paired')\n  for class_value in range(2):\n      row_ix = np.where(y == class_value)\n      plt.scatter(X[row_ix, 0], X[row_ix, 1], cmap='Paired')","896122c2":"plotBoundary(X,y, depth=1)","f3e25f91":"plotBoundary(X,y, depth=2)","98e34b62":"plotBoundary(X,y, depth=6)","c6adcaef":"## \u307e\u3068\u3081\n***","6eb4ea1b":"## \u30e2\u30c7\u30eb\u5b9a\u7fa9","95baf4ea":"# \u89e3\u8aac\n***","32b888cd":"\u6728\u306e\u6df1\u3055\u30921\u306b\u8a2d\u5b9a\u3057\u3066\u3001\u5206\u985e\u3057\u3066\u307f\u308b\u3002  \n\u6728\u306e\u6df1\u3055\u304c1\u306a\u306e\u3067\u7dda\u5f62\u306b\u3057\u304b\u5206\u985e\u3067\u304d\u306a\u3044\u3002","0cfaedb1":"\u30c4\u30ea\u30fc\u304c\u5f62\u6210\u3055\u308c\u3066\u3001\u672b\u7aef\u306b\u306f\u4e88\u6e2c\u7d50\u679c\u306elabel\u304c0\u307e\u305f\u306f1\u3067\u683c\u7d0d\u3055\u308c\u3066\u3044\u308b\u3002","7666ae79":"\u6c7a\u5b9a\u6728\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092Python,numpy\u3067\u5b9f\u88c5\u3057\u3066\u307f\u308b\u3002","9ecb737d":"\u6c7a\u5b9a\u6728\u306e\u30e2\u30c7\u30eb\u3092\u4f5c\u6210\u3057\u3066\u30012\u5024\u306e\u5206\u985e\u554f\u984c\u3092\u4e88\u6e2c\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u305f\u3002  \n\u8a08\u7b97\u65b9\u6cd5\u3060\u3051\u8abf\u3079\u3066\u65e2\u5b58\u306e\u30b3\u30fc\u30c9\u3092\u53c2\u8003\u306b\u305b\u305a\u4f5c\u6210\u3057\u305f\u306e\u3067\u3001\u5197\u9577\u306b\u306a\u3063\u3066\u3057\u307e\u3063\u305f\u6c17\u304c\u3059\u308b\u3002\u3002  \ntree\u306e\u69cb\u9020\u3082\u3082\u3063\u3068\u5de5\u592b\u306e\u4f59\u5730\u304c\u3042\u308a\u305d\u3046\u3002  \nsklearn\u3067\u306f\u3082\u3063\u3068\u52b9\u7387\u306e\u3044\u3044\u8a08\u7b97\u65b9\u6cd5\u3084tree\u306e\u69cb\u9020\u306b\u306a\u3063\u3066\u3044\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u306e\u3067\u53c2\u8003\u306b\u3057\u305f\u3044\u3002  ","9448f579":"## \u30b8\u30cb\u4fc2\u6570\n$$\nGini = 1 - \\sum_{i=1}^{K}(p_i)^2\n$$\nK\u306f\u5206\u985e\u3059\u308b\u30af\u30e9\u30b9\u306e\u7dcf\u6570\u3002\np\u306f\u30af\u30e9\u30b9i\u306e\u51fa\u73fe\u5272\u5408\u3002\n  \n## \u5e73\u5747\u30b8\u30cb\u4fc2\u6570\n\u30c7\u30fc\u30bf\u3092\u3042\u308b\u8aac\u660e\u5909\u6570\u306e\u3042\u308b\u95be\u5024\u3067\uff12\u3064\u306e\u90e8\u5c4b\u306b\u5206\u3051\u305f\u3068\u3059\u308b\u3002  \n\u305d\u308c\u305e\u308c\u306e\u90e8\u5c4b\u306e\u30b8\u30cb\u4fc2\u6570\u3092\u7b97\u51fa\u3057\u3001\u305d\u308c\u305e\u308c\u306e\u90e8\u5c4b\u306e\u30c7\u30fc\u30bf\u6570\u3067\u52a0\u91cd\u5e73\u5747\u3057\u305f\u5024\u3002  \n\u5e73\u5747\u30b8\u30cb\u4fc2\u6570\u306e\u5024\u304c\u5c0f\u3055\u3044\u307b\u3069\u3001\u305d\u306e\u8aac\u660e\u5909\u6570\u306e\u305d\u306e\u95be\u5024\u304c\u30c7\u30fc\u30bf\u3092\u5206\u985e\u3059\u308b\u4e0a\u3067\u59a5\u5f53\u3060\u3068\u8a00\u3048\u308b\u3002\n","f244b63a":"\u6728\u306e\u6df1\u3055\u304c6\u306b\u306a\u308b\u3068\u591a\u5c11\u904e\u5b66\u7fd2\u3057\u3066\u3044\u308b\u3068\u3053\u308d\u304c\u3042\u308a\u305d\u3046\u3002","ef5288cc":"\u6728\u306e\u6df1\u3055\u30922\u3067\u8a2d\u5b9a\u3057\u3066\u3001\u4f5c\u6210\u3057\u305f\u30c7\u30fc\u30bf\u3092\u5b66\u7fd2\u3055\u305b\u3066\u307f\u308b\u3002","ad579b6f":"# \u5b9f\u88c5\n***","4279c193":"## \u30c7\u30fc\u30bf\u4f5c\u6210","f1c59efe":"\u6728\u306e\u6df1\u3055\u304c2\u3060\u3068\u975e\u7dda\u5f62\u306b\u4e88\u6e2c\u3067\u304d\u308b\u3002","ba2dca18":"# \u6982\u8981\n***","c0823eb3":"\u5e73\u5747\u30b8\u30cb\u4fc2\u6570\u304c\u6700\u5c0f\u306b\u306a\u308b\u8aac\u660e\u5909\u6570\u306e\u95be\u5024\u3092\u898b\u3064\u3051\u3066\u3001\u30b5\u30f3\u30d7\u30eb\u3092\u5206\u3051\u308b\u624b\u7d9a\u304d\u3092\u6307\u5b9a\u3057\u305f\u6df1\u3055\u5206\u884c\u3046\u3002"}}