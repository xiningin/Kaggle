{"cell_type":{"06393077":"code","51e84460":"code","da0d7f4a":"code","0c69c11d":"code","3917914a":"code","0b74ee29":"code","23914862":"code","bb43c769":"code","0a46f105":"code","c5f75517":"code","6ad872f9":"code","9e35dbd8":"code","347788ce":"code","0c6fa17f":"code","a4ceb711":"code","3b2c6b87":"code","d90ef88f":"code","6aff2a1e":"code","85e1c6e1":"code","6379064d":"code","59fcf275":"code","c2b6418c":"code","624e58b0":"code","db545896":"code","146ef983":"code","240fef6f":"code","08ef7c3c":"code","911221e3":"code","6cfce2a8":"code","ff7593a2":"code","496b8d32":"code","f4bc11c2":"code","5cf67c0c":"code","e6dd6fea":"code","bf9e3ad4":"code","54584e78":"code","b92c8c45":"code","679a8b64":"code","5fde1d04":"code","91558659":"code","68ab010f":"markdown","a3469a55":"markdown","b3e5db79":"markdown","544d8f84":"markdown","42eec4b9":"markdown","26fc2436":"markdown","57eb6fd5":"markdown","2146d417":"markdown","65f4d60f":"markdown","dd1ef750":"markdown","fa97a405":"markdown","1c0b0bdc":"markdown","7346d406":"markdown","2f286af6":"markdown"},"source":{"06393077":"# feature extractoring and preprocessing data\nimport librosa\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport os\nfrom PIL import Image\nimport pathlib\nimport csv\n\n# Preprocessing\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder, StandardScaler\n\n#Keras\nimport keras\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nfrom sklearn.preprocessing import LabelEncoder, scale, StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report, confusion_matrix, accuracy_score\nfrom sklearn.decomposition import PCA\nfrom sklearn.linear_model import LogisticRegression\nfrom keras.utils import to_categorical\nfrom keras.models import Sequential, Model, load_model\nfrom keras.layers.normalization import BatchNormalization\nfrom keras.layers import Dense, Dropout, Activation, Flatten\nfrom keras.layers import Convolution2D, Conv2D, MaxPooling2D, GlobalAveragePooling2D, UpSampling2D, Input\nfrom keras.optimizers import Adam\nfrom keras.utils import np_utils\nfrom keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau\nfrom keras import optimizers\nfrom keras.regularizers import l1\nfrom keras.utils.vis_utils import plot_model\nfrom datetime import datetime\nfrom sklearn import metrics\nimport librosa, librosa.display, os, csv\nimport pandas as pd\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport pylab\nplt.switch_backend('agg')\nimport itertools\nimport scipy as sp\nfrom scipy import signal\nimport xgboost as xgb\nimport joblib\nfrom glob import glob\nimport urllib\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Conv2D, Flatten, Dense, MaxPool2D, Dropout\nfrom tensorflow.keras.utils import to_categorical \n\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import SVC\n\n# Basic Libraries\n\nimport pandas as pd\nimport numpy as np\n\npd.plotting.register_matplotlib_converters()\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report\nfrom sklearn.model_selection import GridSearchCV\n\nfrom sklearn.preprocessing import MinMaxScaler","51e84460":"#Loading CSV file\ntrain_csv = pd.read_csv(\"..\/input\/coughclassifier-trial\/cough_trial_extended.csv\")\ndataset = \"..\/input\/coughclassifier-trial\/cough_trial_extended.csv\"\ntrain_csv","da0d7f4a":"train_csv['class'].unique()","0c69c11d":"cmap = plt.get_cmap('inferno')\ntot_rows = train_csv.shape[0]\nfor i in range(tot_rows):\n    source = train_csv['file_properties'][i]\n    filename = '..\/input\/coughclassifier-trial\/trial_covid\/'+source\n    y,sr = librosa.load(filename, mono=True, duration=5)\n    plt.specgram(y, NFFT=2048, Fs=2, Fc=0, noverlap=128, cmap=cmap, sides='default', mode='default', scale='dB');\n    plt.axis('off');\n    plt.savefig(f'.\/{source[:-3].replace(\".\", \"\")}.png')\n    plt.clf()","3917914a":"filename","0b74ee29":"header = 'filename chroma_stft rmse spectral_centroid spectral_bandwidth rolloff zero_crossing_rate'\nfor i in range(1, 21):\n    header += f' mfcc{i}'\nheader += ' label'\nheader = header.split()","23914862":"file = open('data_new_extended.csv', 'w')\nwith file:\n    writer = csv.writer(file)\n    writer.writerow(header)\nfor i in range(tot_rows):\n        source = train_csv['file_properties'][i]\n        file_name = '..\/input\/coughclassifier-trial\/trial_covid\/'+source\n        y,sr = librosa.load(file_name, mono=True, duration=5)\n        chroma_stft = librosa.feature.chroma_stft(y=y, sr=sr)\n        rmse = librosa.feature.rms(y=y)\n        spec_cent = librosa.feature.spectral_centroid(y=y, sr=sr)\n        spec_bw = librosa.feature.spectral_bandwidth(y=y, sr=sr)\n        rolloff = librosa.feature.spectral_rolloff(y=y, sr=sr)\n        zcr = librosa.feature.zero_crossing_rate(y)\n        mfcc = librosa.feature.mfcc(y=y, sr=sr)\n        to_append = f'{source[:-3].replace(\".\", \"\")} {np.mean(chroma_stft)} {np.mean(rmse)} {np.mean(spec_cent)} {np.mean(spec_bw)} {np.mean(rolloff)} {np.mean(zcr)}'    \n        for e in mfcc:\n            to_append += f' {np.mean(e)}'\n        \n        file = open('data_new_extended.csv', 'a')\n        with file:\n            writer = csv.writer(file)\n            writer.writerow(to_append.split())","bb43c769":"data = pd.read_csv('..\/input\/coughclassifier-trial\/data_new_extended.csv')\ndata","0a46f105":"data.shape","c5f75517":"# Dropping unneccesary columns\ndata = data.drop(['filename'],axis=1)","6ad872f9":"data.head()","9e35dbd8":"genre_list = data.iloc[:, -1]\nencoder = LabelEncoder()\ny = encoder.fit_transform(genre_list)","347788ce":"scaler = StandardScaler()\nX = scaler.fit_transform(np.array(data.iloc[:, :-1], dtype = float))","0c6fa17f":"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33)","a4ceb711":"X_train.shape","3b2c6b87":"X_train.shape[1]","d90ef88f":"y_train.shape","6aff2a1e":"\nfrom keras import models\nfrom keras import layers\n\nmodel = models.Sequential()\nmodel.add(layers.Dense(512, activation='relu', input_shape=(X_train.shape[1],)))\n\nmodel.add(layers.Dense(256, activation='relu'))\n\nmodel.add(layers.Dense(128, activation='relu'))\n\nmodel.add(layers.Dense(64, activation='relu'))\n\nmodel.add(layers.Dense(10, activation='relu'))\n\nmodel.add(layers.Dense(2, activation='softmax'))\n\n# serialize model to JSON\nmodel_json = model.to_json()\nwith open(\"model.json\", \"w\") as json_file:\n    json_file.write(model_json)\n# serialize weights to HDF5\nmodel.save_weights(\"model.h5\")\nprint(\"Saved model to disk\")\n\n# plot model\nplot_model(model, to_file='model_plot.png', show_shapes=True, show_layer_names=True)","85e1c6e1":"model.summary()","6379064d":"# # loading weights into new model\n# loaded_model.load_weights(\"model.h5\")\n# print(\"Loaded model from disk\")\n \n# # evaluate loaded model on test data\n# loaded_model.compile(optimizer='adam',\n#               loss='sparse_categorical_crossentropy',\n#               metrics=['accuracy'])\n# score = loaded_model.evaluate(X, Y, verbose=0)\n# print(\"%s: %.2f%%\" % (loaded_model.metrics_names[1], score[1]*100))","59fcf275":"model.compile(optimizer='adam',\n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\nhistory = model.fit(X_train,\n                    y_train,\n                    epochs=100,\n                    batch_size=128)","c2b6418c":"test_loss, test_acc = model.evaluate(X_test,y_test)","624e58b0":"print('test_acc: ',test_acc)","db545896":"y_classes = predictions.argmax(axis=-1)\ny_classes","146ef983":"for label in y_classes:\n    if label==1:\n        print(\"Covid\")\n    else:\n        print(\"Not Covid\")","240fef6f":"y_prob = model.predict(x_test) \ny_classes = y_prob.argmax(axis=-1)","08ef7c3c":"pre=model.predict_classes(X_test)","911221e3":"from keras.utils import np_utils","6cfce2a8":"pred = model.predict(X_test)\nclasses = np.argmax(pred)","ff7593a2":"classes","496b8d32":"labels","f4bc11c2":"predictions = model.predict(X_test)\nprint(predictions[0].shape)\nprint(np.sum(predictions[0]))\nprint(predictions[:4])\nprint(y_test[:4])","5cf67c0c":"predictions","e6dd6fea":"!tar -zcvf outputname.tar.zip \/kaggle\/working","bf9e3ad4":"df = pd.DataFrame(predictions, columns = ['Negative','Positive'])","54584e78":"a = df.iloc[:,0] < df.iloc[:,1] \na = a*1","b92c8c45":"from sklearn.metrics import roc_curve\nfrom sklearn.metrics import roc_auc_score\nfrom matplotlib import pyplot","679a8b64":"a.to_numpy()","5fde1d04":"y_test","91558659":"# summarize score\nprint('Model: auROC=%.3f' % (roc_auc_score(y_test, a)))\n# calculate roc curves\nlr_fpr, lr_tpr, _ = roc_curve(y_test, a)\n# plot the roc curve for the model\npyplot.plot(lr_fpr, lr_tpr, marker='.', label='Model')\n# axis labels\npyplot.xlabel('False Positive Rate')\npyplot.ylabel('True Positive Rate')\n# show the legend\npyplot.legend()\n# show the plot\npyplot.show()","68ab010f":"## Extracting features from Spectrogram\n\n\nWe will extract\n\n* Mel-frequency cepstral coefficients (MFCC)(20 in number)\n* Spectral Centroid,\n* Zero Crossing Rate\n* Chroma Frequencies\n* Spectral Roll-off.","a3469a55":"# COVID-19 Cough classification notebook","b3e5db79":"## Encoding the Labels","544d8f84":"All the audio files get converted into their respective spectrograms .We can know easily extract features from them.","42eec4b9":"## Importing Libraries","26fc2436":"## Predictions on Test Data","57eb6fd5":"# Classification with Keras\n\n## Building our Network","2146d417":"# Analysing the Data in Pandas","65f4d60f":"## Scaling the Feature columns","dd1ef750":"## Extracting the Spectrogram for every Audio File","fa97a405":"## Dividing data into training and Testing set","1c0b0bdc":"### Test Accuracy","7346d406":"## Saving the Spectograms as a single output file","2f286af6":"## Writing data to csv file\n\nWe write the data to a csv file"}}