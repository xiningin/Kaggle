{"cell_type":{"0d1d844f":"code","a180ba48":"code","a6cfe540":"code","c427fc27":"code","3b6fb361":"code","803cdfac":"code","47c10da2":"code","506dd27f":"code","34a807fb":"code","5e4e3157":"code","683fb43b":"code","39d5091d":"code","cbc01af5":"code","0937903f":"code","0ca3335d":"code","18044578":"code","2d35ef98":"code","9b5d5364":"code","b4c47411":"code","933667d5":"code","804851c2":"code","46ad0352":"code","9b2deea9":"code","d160dd68":"code","2548f283":"markdown","c3b3db03":"markdown","33f000bf":"markdown","b0704e4d":"markdown","c2e5d229":"markdown","fcdb34a6":"markdown","01932e73":"markdown","3f863bbc":"markdown","58754b09":"markdown","97cef8ea":"markdown","e9364af7":"markdown","3a7c0b7b":"markdown","90d5318b":"markdown","8bc3eadc":"markdown","f9796e87":"markdown","7381ce59":"markdown"},"source":{"0d1d844f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","a180ba48":"import pandas as pd\nimport numpy as np","a6cfe540":"dataset = pd.read_csv('..\/input\/iris\/Iris.csv')\ndataset.head(5)","c427fc27":"dataset.describe()","3b6fb361":"labels = dataset['Species'] \nc = labels.astype('category')\nlabels = c.cat.codes\nclass_names = c.cat.categories\nlabels.head(5)\ndataset = dataset.drop(columns=['Id','Species'], axis=1)","803cdfac":"class_names","47c10da2":"som_width = 20\nsom_length = 20\nepochs = 50000\ninitial_learning_rate=0.01","506dd27f":"\nfrom sklearn.preprocessing import MinMaxScaler\ndataset= pd.DataFrame(MinMaxScaler(feature_range=(0, 1)).fit_transform(dataset.values))\ndataset.head()","34a807fb":"!pip install minisom\nfrom minisom import MiniSom","5e4e3157":"mini_som_net = MiniSom(som_length, som_width, 4, sigma=3, learning_rate =0.05, neighborhood_function='gaussian') \nmini_som_net.train_random(dataset.to_numpy(), 100000)","683fb43b":"from matplotlib import pyplot as plt\nimport seaborn as sns\n\nplt.figure(figsize=(10,10))\nplt.pcolor(mini_som_net.distance_map().T, cmap= 'viridis' )\nplt.colorbar()","39d5091d":"\nmarkers = ['o','s','D']\ncolors = ['r','g','b']\nplt.figure(figsize=(10,10))\nplt.pcolor(mini_som_net.distance_map().T, cmap= 'viridis' )\nplt.colorbar()\n\nfor cnt,xx in enumerate(dataset.to_numpy()):\n    w = mini_som_net.winner(xx)\n    plt.plot(w[0]+.5,w[1]+.5,markers[labels[cnt]],markersize=12, markerfacecolor=colors[labels[cnt]], markeredgecolor='k')\n","cbc01af5":"!pip install SimpSOM\nimport SimpSOM as sps","0937903f":"simp_net = sps.somNet(som_width, som_length, dataset.to_numpy(), PBC=True)\nsimp_net.train(0.01, 10000)\n\nsimp_net.nodes_graph(colnum=0)\nsimp_net.diff_graph()","0ca3335d":"initial_radius = max(som_width, som_length)\/2\ntime_const =  epochs\/np.log(initial_radius)\nsom_net = np.random.random((som_width, som_length, 4))","18044578":"def update_radius(initial_radius, i, time_const):\n    return initial_radius * np.exp(-i \/ time_const)\n\ndef update_learning_rate(initial_learning_rate, i, n_iterations):\n    return initial_learning_rate * np.exp(-i \/ n_iterations)\n\ndef calculate_euclidian_dis(point1, point2):\n    return np.sqrt(np.sum((point1 - point2) ** 2))\n\ndef find_best_matching_Unit(data_point):\n    bmu_pos = np.array([0, 0])\n    min_dist = np.iinfo(np.int).max\n    input_dim = len(data_point)\n    \n    for x in range(som_width):\n        for y in range(som_length):\n            som_weight_vector = som_net[x, y, :].reshape(1, 4)\n            euclidian_dist = calculate_euclidian_dis(som_weight_vector, data_point)\n            if euclidian_dist < min_dist:\n                min_dist = euclidian_dist\n                bmu_pos = np.array([x, y])\n    \n    bmu = som_net[bmu_pos[0], bmu_pos[1], :].reshape(1, 4)\n    return (bmu, bmu_pos)\n\ndef neighbourhood_function(bmu_location, selected_node_location, radius):\n    euclidien_dist_to_bmu = calculate_euclidian_dis(bmu_location, selected_node_location)\n    return np.exp(-euclidien_dist_to_bmu \/ (2* (radius**2)))","2d35ef98":"#shuffling the data set\ndataset_shuff = dataset.sample(frac=1)\n\nfor i in range(epochs):\n    rand_point = np.array(dataset_shuff.sample())\n    bmu, bmu_idx = find_best_matching_Unit(rand_point)\n\n    new_radius = update_radius(initial_radius, i, time_const)\n    new_learning_rate = update_learning_rate(initial_learning_rate, i, epochs)\n    #Updating the som net throughout  radius\n    for x in range(som_width):\n        for y in range(som_length):\n            w = som_net[x, y, :].reshape(1, 4)\n            w_dist = calculate_euclidian_dis(np.array([x, y]), bmu_idx)\n            #Update if the modification falls within the circle\n            if w_dist <= new_radius:\n                influence = neighbourhood_function(bmu, w, new_radius)\n                new_w = w + (new_learning_rate * influence * (rand_point - w))\n                som_net[x, y, :] = new_w.reshape(1, 4)    ","9b5d5364":"u_matrix = np.zeros((som_width, som_length))\n\nfor x in range(0, som_width):\n    for y in range(0, som_length):\n        neighbour_list = list()\n        #Finding the Neighbor indexs for (x, y) and making a list of them.\n        for u in range(x-1, x+2):\n            if (u < 0 or u > (som_width-1)):\n                continue\n            for v in range(y-1, y+2):\n                if(v < 0 or v > (som_length-1)):\n                    continue\n                if (u == x and v == y):\n                    continue\n                neighbour_list.append(np.array([u,v]))\n\n        sum=0\n        for idx in neighbour_list:\n            sum += calculate_euclidian_dis(som_net[x,y,:], som_net[idx[0],idx[1],:])\n        \n        avg = sum\/len(neighbour_list)\n        u_matrix[x-1,y-1] = avg","b4c47411":"from matplotlib import pyplot as plt\nimport seaborn as sns\nfig = plt.figure(figsize=(7,7))\nplt.title(\"U Matrix visualization of Iris data using SOM\")\nplt.pcolor(u_matrix.T, cmap=\"viridis\")\nplt.colorbar()","933667d5":"from matplotlib import pyplot as plt\nimport seaborn as sns\n\nmarkers = ['o','s','D']\ncolors = ['r','g','b']\nplt.figure(figsize=(10,10))\nplt.pcolor(u_matrix.T, cmap= 'viridis' )\nplt.colorbar()\n\nfor cnt,xx in enumerate(dataset.to_numpy()):\n    w = find_best_matching_Unit(np.array(xx))[1]\n    plt.plot(w[0]+.5,w[1]+.5,markers[labels[cnt]],markersize=12, markerfacecolor=colors[labels[cnt]],  markeredgecolor='k')\n","804851c2":"vector_map = np.zeros((som_width, som_length,2))\n\nfor x in range(0, som_width):\n    for y in range(0, som_length):\n        neighbour_list = list()\n        #Finding the Neighbor indexs for (x, y) and making a list of them.\n        for u in range(x-1, x+2):\n            if (u < 0 or u > (som_width-1)):\n                continue\n            for v in range(y-1, y+2):\n                if(v < 0 or v > (som_length-1)):\n                    continue\n                if (u == x and v == y):\n                    continue\n                neighbour_list.append(np.array([u,v]))\n\n        sum_dis=0\n        x_dir = 0\n        y_dir = 0\n        avg_dis = 0\n        u = 0\n        v = 0\n        for idx in neighbour_list:\n            dist = calculate_euclidian_dis(som_net[x,y,:], som_net[idx[0],idx[1],:])\n            x_dir += dist*((idx[0] - x)\/np.sqrt((idx[0] - x)**2 + (idx[1] - y)**2))\n            y_dir += dist*((idx[1] - y)\/np.sqrt((idx[0] - x)**2 + (idx[1] - y)**2))\n            sum_dis += dist\n        avg_dis = sum_dis\/len(neighbour_list)\n        u = avg_dis*(x_dir\/(np.sqrt(x_dir**2 + y_dir**2)))\n        v = avg_dis*(y_dir\/(np.sqrt(x_dir**2 + y_dir**2)))\n        vector_map[x-1,y-1,0] = u\n        vector_map[x-1,y-1,1] = v","46ad0352":"x,y = np.meshgrid(np.arange(0,som_width , 1), np.arange(0, som_length, 1))","9b2deea9":"u,v=vector_map.reshape(-1,2).T\nu = u.reshape(som_width, som_width)\nv = v.reshape(som_length, som_length)","d160dd68":"plt.quiver(y,x,u,v,angles = 'uv')","2548f283":"Following Cell train the SOM weights","c3b3db03":"### 3.1.2 U Matrix with Winner Neurons of each data point marked with its Class","33f000bf":"## 4.2 U Matrix with Winner Neurons of each data point marked with its Class","b0704e4d":"Following cell Create the U Matrix","c2e5d229":"# 1. Import Libraries and Data setting initial configurations","fcdb34a6":"## 3.1 Using MiniSom","01932e73":"## 4.1 U Matrix","3f863bbc":"# 3. Using Libraries to Train and Visualize SOM with U Matrix","58754b09":"# U Matrix Representation\n![U Matrix](https:\/\/miro.medium.com\/max\/825\/0*NDU-Hc3tGz4XZXHh.png)\n\n**U matrix which is comming as a visualization technique for Self Organized Maps, depicts the distance between the nodes of a SOM. Here, when plotted, darker areas of the matrix are far away from each other.**\n\nThis Notebook includes an impelementation of U Matrix and Vector Field Visualizations for Self Organised Map generated for Iris Dataset.\n> **Contents**\n> * 1. Libraries and Initial Configurations\n> * 2. Data Pre-Processing\n> * 3. Using Libraries to Train and Visualize SOM with U Matrix\n> * 4. Implementing from Scratch (Used functions from https:\/\/www.kaggle.com\/warunaw\/self-organizing-maps)\n> * 5. Vector Fields for SOM","97cef8ea":"### 3.1.1 U Matrix","e9364af7":"# 2. Pre-Processing the Data","3a7c0b7b":"Following Helper Functions are Referenced from https:\/\/www.kaggle.com\/warunaw\/self-organizing-maps","90d5318b":"# 5 Vector Field for SOM Generated in Section 4","8bc3eadc":"Based on the U Matrix Implementation, for vector fields other than taking the distance, the direction is computed. Here for each node a vector is generated proportional to distance as in U matrix and direction across u,v axes are depicted. ","f9796e87":"## 3.2 Using Simpson","7381ce59":"# 4. Implementing from Scratch"}}