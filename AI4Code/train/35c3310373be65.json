{"cell_type":{"e9ba9eeb":"code","edca77af":"code","3bfff5a6":"code","d8f0f0b6":"code","b8583caa":"code","090a5956":"code","892b6fae":"code","d904ff07":"code","4edc901c":"code","fd840966":"code","65247aca":"code","fb5790c4":"code","5cf2125c":"code","002444a3":"code","9ef6c3b5":"code","089c8b21":"code","082564f9":"code","1ded82e7":"code","045c397a":"code","ca6c20ec":"code","3b8e24f6":"code","a3627bdf":"code","cf217c77":"code","db37dca3":"code","d167ceeb":"markdown","eebd9d31":"markdown","e0b1787e":"markdown","25e52c3a":"markdown","265f85e9":"markdown","f7d20859":"markdown","6a12f68e":"markdown","d0128d9e":"markdown","88a6e3cb":"markdown"},"source":{"e9ba9eeb":"# data manipulation\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport librosa\nimport librosa.display\n\nimport seaborn as sns\nsns.set_palette(sns.color_palette(\"GnBu_r\"))\nimport matplotlib.pyplot as plt\nfrom IPython import display\n\n# set variables\nROOT = '..\/input\/coughvid-wav\/public_dataset\/'\n\n# load coughvid meta\ndata_raw = pd.read_csv(ROOT+'metadata_compiled.csv')\ndata_raw.head(3)","edca77af":"data_full = data_raw.fillna('unknown')\nf, axs = plt.subplots(1, 2, figsize=(12, 4), gridspec_kw=dict(width_ratios=[4, 4]))\nsns.countplot(data=data_full, x=\"gender\", ax=axs[0])\nsns.countplot(data=data_full, x=\"status\", ax=axs[1])\nf.tight_layout()","3bfff5a6":"f, axs = plt.subplots(1, 2, figsize=(12, 4), gridspec_kw=dict(width_ratios=[4, 4]))\nsns.countplot(data=data_full, x=\"respiratory_condition\", ax=axs[0])\nsns.countplot(data=data_full, x=\"fever_muscle_pain\", ax=axs[1])\nf.tight_layout()","d8f0f0b6":"sns.displot(data_full, x=\"cough_detected\", bins=10, height=4, aspect=3)","b8583caa":"def split_by_physicians(df):\n    column_names = ['uuid', 'datetime', 'cough_detected', 'SNR', 'latitude', 'longitude', \n                    'age', 'gender', 'respiratory_condition', 'fever_muscle_pain', 'status', \n                    'quality', 'cough_type', 'dyspnea', 'wheezing', 'stridor', 'choking', \n                    'congestion', 'nothing', 'diagnosis', 'severity' ]\n    physician_01 = df.iloc[:, 0:21]\n    physician_01 = physician_01[physician_01.quality_1.notna()].reset_index(drop=True)\n    physician_01.columns = column_names\n    physician_01['physician'] = 'P01'\n\n    physician_02 = pd.concat([df.iloc[:, 0:11], df.iloc[:, 21:31]], axis=1)\n    physician_02 = physician_02[physician_02.quality_2.notna()].reset_index(drop=True)\n    physician_02.columns = column_names\n    physician_02['physician'] = 'P02'\n\n    physician_03 = pd.concat([df.iloc[:, 0:11], df.iloc[:, 31:41]], axis=1)\n    physician_03 = physician_03[physician_03.quality_3.notna()].reset_index(drop=True)\n    physician_03.columns = column_names\n    physician_03['physician'] = 'P03'\n\n    physician_04 = pd.concat([df.iloc[:, 0:11], df.iloc[:, 41:51]], axis=1)\n    physician_04 = physician_04[physician_04.quality_4.notna()].reset_index(drop=True)\n    physician_04.columns = column_names\n    physician_04['physician'] = 'P04'\n    return physician_01, physician_02, physician_03, physician_04","090a5956":"physician_01, physician_02, physician_03, physician_04 = split_by_physicians(data_raw)\nannotated_df = pd.concat([physician_01,physician_02,physician_03,physician_04]).reset_index(drop=True)  \nannotated_df = annotated_df.fillna('unknown')\nannotated_df.head(3)","892b6fae":"f, axs = plt.subplots(1, 2, figsize=(12, 4), gridspec_kw=dict(width_ratios=[10, 4]))\nsns.countplot(data=annotated_df, x=\"status\", hue='physician', ax=axs[0])\nsns.countplot(data=annotated_df, x=\"physician\", ax=axs[1])\nf.tight_layout()","d904ff07":"f, axs = plt.subplots(1, 2, figsize=(12, 4), gridspec_kw=dict(width_ratios=[10, 4]))\nsns.countplot(data=annotated_df, x=\"diagnosis\", ax=axs[0])\nsns.countplot(data=annotated_df, x=\"severity\", ax=axs[1])\nf.tight_layout()","4edc901c":"f, axs = plt.subplots(1, 2, figsize=(12, 4), gridspec_kw=dict(width_ratios=[4, 4]))\nsns.countplot(data=annotated_df, x=\"cough_type\", ax=axs[0])\nsns.countplot(data=annotated_df, x=\"quality\", ax=axs[1])\nf.tight_layout()","fd840966":"f, axs = plt.subplots(1, 2, figsize=(12, 4), gridspec_kw=dict(width_ratios=[4, 4]))\nsns.countplot(data=annotated_df, x=\"dyspnea\", ax=axs[0])\nsns.countplot(data=annotated_df, x=\"wheezing\", ax=axs[1])\nf.tight_layout()","65247aca":"f, axs = plt.subplots(1, 2, figsize=(12, 4), gridspec_kw=dict(width_ratios=[4, 4]))\nsns.countplot(data=annotated_df, x=\"choking\", ax=axs[0])\nsns.countplot(data=annotated_df, x=\"congestion\", ax=axs[1])\nf.tight_layout()","fb5790c4":"healthy_sample = ROOT+data_raw[data_raw.uuid == 'a28776b5-b876-47ac-8973-9ca280156608'].uuid.values[0]+'.wav'\ncovid_sample = ROOT+data_raw[data_raw.uuid == 'ffbca476-8b35-4797-bc8a-b7f0a2f24b55'].uuid.values[0]+'.wav'\nsymptomatic_sample = ROOT+data_raw[data_raw.uuid == '6d8fcfb2-7aff-4143-a319-99d568035655'].uuid.values[0]+'.wav'","5cf2125c":"healthy_audio, fs = librosa.load(healthy_sample, mono=True)\ncovid_audio, fs = librosa.load(covid_sample, mono=True)\nsymptomatic_audio, fs = librosa.load(symptomatic_sample, mono=True)\n\nfig, (ax, ax1, ax2) = plt.subplots(nrows=3, figsize=(12,6))\nax.set(title='Sample Audio')\nlibrosa.display.waveshow(healthy_audio, sr=fs, ax=ax, label='Healthy')\nlibrosa.display.waveshow(covid_audio, sr=fs, ax=ax1, label='Covid')\nlibrosa.display.waveshow(symptomatic_audio, sr=fs,  ax=ax2, label='Symptomatic')\nax.axis('off')\nax.label_outer()\nax.legend()\nax1.axis('off')\nax1.label_outer()\nax1.legend()\nax2.axis('off')\nax2.label_outer()\nax2.legend()","002444a3":"# healthy sample\ndisplay.Audio(healthy_audio, rate=fs)","9ef6c3b5":"# covid sample\ndisplay.Audio(covid_audio, rate=fs)","089c8b21":"# symptomatic sample\ndisplay.Audio(symptomatic_audio, rate=fs)","082564f9":"from scipy import signal\nfrom scipy.io import wavfile\nfrom scipy.signal import butter,filtfilt\nfrom scipy.signal import cwt\nfrom scipy.signal import hilbert\nfrom scipy.signal import resample\nfrom scipy.signal import decimate\nfrom scipy.signal import spectrogram\nfrom scipy.signal.windows import get_window\n\ndef preprocess_cough(x,fs, cutoff = 6000, normalize = True, filter_ = True, downsample = True):\n    \n    # Normalize, lowpass filter, and downsample cough samples in a given data folder \n    fs_downsample = cutoff*2\n    \n    #Preprocess Data\n    if len(x.shape)>1:\n        x = np.mean(x,axis=1)                          # Convert to mono\n    if normalize:\n        x = x\/(np.max(np.abs(x))+1e-17)                # Norm to range between -1 to 1\n    if filter_:\n        b, a = butter(4, fs_downsample\/fs, btype='lowpass') # 4th order butter lowpass filter\n        x = filtfilt(b, a, x)\n    if downsample:\n        x = signal.decimate(x, int(fs\/fs_downsample)) # Downsample for anti-aliasing\n    \n    fs_new = fs_downsample\n\n    return np.float32(x), fs_new\n\ndef segment_cough(x,fs, cough_padding=0.2,min_cough_len=0.2, th_l_multiplier = 0.1, th_h_multiplier = 2):\n    #Preprocess the data by segmenting each file into individual coughs using a hysteresis comparator on the signal power\n                \n    cough_mask = np.array([False]*len(x))\n    \n    #Define hysteresis thresholds\n    rms = np.sqrt(np.mean(np.square(x)))\n    seg_th_l = th_l_multiplier * rms\n    seg_th_h =  th_h_multiplier*rms\n\n    #Segment coughs\n    coughSegments = []\n    padding = round(fs*cough_padding)\n    min_cough_samples = round(fs*min_cough_len)\n    cough_start = 0\n    cough_end = 0\n    cough_in_progress = False\n    tolerance = round(0.01*fs)\n    below_th_counter = 0\n    \n    for i, sample in enumerate(x**2):\n        if cough_in_progress:\n            if sample<seg_th_l:\n                below_th_counter += 1\n                if below_th_counter > tolerance:\n                    cough_end = i+padding if (i+padding < len(x)) else len(x)-1\n                    cough_in_progress = False\n                    if (cough_end+1-cough_start-2*padding>min_cough_samples):\n                        coughSegments.append(x[cough_start:cough_end+1])\n                        cough_mask[cough_start:cough_end+1] = True\n            elif i == (len(x)-1):\n                cough_end=i\n                cough_in_progress = False\n                if (cough_end+1-cough_start-2*padding>min_cough_samples):\n                    coughSegments.append(x[cough_start:cough_end+1])\n            else:\n                below_th_counter = 0\n        else:\n            if sample>seg_th_h:\n                cough_start = i-padding if (i-padding >=0) else 0\n                cough_in_progress = True\n    \n    return coughSegments, cough_mask","1ded82e7":"# Preprocess (Normalize, lowpass filter, and downsample cough samples)\nprocessed_audio, sample_rate = preprocess_cough(healthy_audio, fs)\n\n# Segment each audio into individual coughs using a hysteresis comparator on the signal power\ncough_segments, cough_mask = segment_cough(processed_audio, sample_rate, min_cough_len=0.1, cough_padding=0.1, th_l_multiplier = 0.1, th_h_multiplier = 2)\n\nfig = plt.figure(figsize=(12,4))\nplt.plot(processed_audio)\nplt.plot(cough_mask)\nplt.title(\"Segmentation Output\")\nplt.axis('off')","045c397a":"fig, axs = plt.subplots(len(cough_segments),1, figsize=(12,8))\nfor i in range(0,len(cough_segments)):\n    axs[i].plot(cough_segments[i])\n    axs[i].set_title(\"Cough segment \" + str(i))\n    axs[i].axis('off')","ca6c20ec":"# first segment healthy sample\ndisplay.Audio(cough_segments[0], rate=fs)","3b8e24f6":"# Short Term Fourier Transform\naudio_data = cough_segments[1]\nstft = np.abs(librosa.stft(audio_data))\nDstft = librosa.amplitude_to_db(stft, ref=np.max)\nax = librosa.display.specshow(Dstft)","a3627bdf":"# compute a mel-scaled spectrogram.\nmel = librosa.feature.melspectrogram(audio_data, sr=fs)\nDmel = librosa.amplitude_to_db(mel, ref=np.max)\nax = librosa.display.specshow(Dmel)","cf217c77":"# mel-frequency cepstral coefficients (MFCCs)\nmfcc = librosa.feature.mfcc(y=audio_data, sr=fs, n_mfcc=40)\nax = librosa.display.specshow(mfcc)","db37dca3":"# compute a chromagram from a waveform or power spectrogram.\nchroma = librosa.feature.chroma_stft(S=stft, sr=fs)\nax = librosa.display.specshow(chroma)","d167ceeb":"### Audio data examples","eebd9d31":"### Mel-Frequency Cepstral Coefficients\nThe Mel-Frequency Cepstrum Coefficients (MFCCs) are the coefficients that comprise the mel-frequency cepstrum. The cepstrum of a signal contains information about the rate of change in its spectral bands. \n\nA cepstrum is essentially a spectrum of the log of the time signal's spectrum. The resulting spectrum is neither in the frequency domain nor in the time domain and thus has been dubbed the quefrency domain. The cepstrum communicates the various values that contribute to the formation of a sound's formants (a characteristic component of the quality of a speech sound) and timbre.","e0b1787e":"### Expert annotation\nFour expert physician assisted with the data quality by revising 320 recordings each, selecting one of the predefined options to each of the following 10 items:\n* **Quality**: Good; Ok; Poor; No cough present.\n* **Type of cough**: Wet (productive); Dry; Can\u2019t tell.\n* **Audible dyspnea**: Checkbox.\n* **Audible wheezing**: Checkbox.\n* **Audible stridor**: Checkbox.\n* **Audible choking**: Checkbox.\n* **Audible nasal congestion**: Checkbox.\n* **Nothing specific**: Checkbox.\n* **Impression**: I think this patient has\u2026: An upper respiratory tract infection; A lower respiratory tract infection; Obstructive lung disease (Asthma, COPD, \u2026); COVID-19; Nothing (healthy cough).\n* **Impression**: the cough is probably\u2026: Pseudocough\/Healthy cough (from a healthy person); Mild (from a sick person); Severe (from a sick person); Can\u2019t tell.","25e52c3a":"#### Part 2 | Machine Learning Algorithm Comparison\n\nhttps:\/\/www.kaggle.com\/nasrulhakim86\/covid-19-screening-from-audio-part-2?scriptVersionId=73794324","265f85e9":"## Audio Data Features Extraction\n\nSound is represented in the form of an audio signal having parameters such as frequency, bandwidth, decibel, etc. A typical audio signal can be expressed as a function of Amplitude and Time.\n\nBecause the audio data presented cannot be interpreted directly by the models, feature extraction is utilised to convert it to a comprehensible format. It is a process that explains most of the data but in an understandable way. Commonly used features or representations that are directly fed into neural network architectures are spectrograms, mel-spectrograms, and Mel-Frequency Cepstral Coefficients (MFCCs).\n\n### Spectrogram\nA spectrogram is a graphical representation of the signal strength, or \"loudness,\" of a signal over time at various frequencies present in a waveform. Not only can one see whether there is more or less energy at a particular frequency, such as 2 Hz vs 10 Hz, but also how the energy levels vary over time. \n\n### Short-Time Fourier Transform\nThe Short-Time Fourier Transform (STFT) is an immensely useful tool for processing audio signals. It defines a particularly useful class of time-frequency distributions that specify the complex amplitude versus time and frequency characteristics of any signal. \n\nIt is obtained by applying the Short-Time Fourier Transform (STFT) on the signal. In the simplest of terms, the STFT of a signal is calculated by applying the Fast Fourier Transform (FFT) locally on small-time segments of the signal. Typically, a spectrogram is depicted as a heat map, that is, an image with the intensity indicated by varying the colour or brightness.","f7d20859":"### Mel-spectrogram\nHumans perceive sound logarithmically. We are more sensitive to differences in lower frequencies than to differences in higher frequencies. For example, while we can easily distinguish between 500 and 1000 Hz, we will struggle to distinguish between 10,000 and 10,500 Hz, even if the distance between the two pairs is the same. As a result, the mel scale was created. It is a logarithmic scale based on the axiom that equal distances on the scale correspond to the same perceived distance.","6a12f68e":"### Pre-processing and cough segmentation","d0128d9e":"### Chroma Features\nChroma features are a highly effective method of representing music audio in which we use a 12-element representation of spectral energy called a chroma vector in which each of the 12 bins represents one of the twelve equal-tempered pitch classes found in western-style music (semitone spacing). It can be calculated from the input sound signal's logarithmic short-time Fourier transform, also known as a chromatogram or pitch class profile.","88a6e3cb":"# Machine Learning and Artificial Neural Network approach for COVID-19 Early Detection From Audio Recording | Part 1\n\nby Nasrul Hakim\n\n![https:\/\/miro.medium.com\/max\/1400\/1*hJ7Hl9k1m0tqOFLh6mH2vA.jpeg](https:\/\/miro.medium.com\/max\/1400\/1*hJ7Hl9k1m0tqOFLh6mH2vA.jpeg)\n\n## Introduction\n\nThe SARS-CoV-2-caused novel coronavirus disease 2019 (COVID-19) pandemic remains a critical and urgent threat to global health. While advancements in testing have made these tools more widely available in recent months, there is still a need for low-cost, quick, and scalable COVID-19 screening technology.\nIn the context of the COVID-19 pandemic, considerable research activity has emerged to use respiratory sounds (e.g., coughs, breathing, and voice) as primary sources of information.\n\nCOVID-19 is a respiratory condition that affects breathing and voice, causing symptoms such as a dry cough, sore throat, an overly breathy voice, and typical breathing pattern. These are all symptoms that can distinguish patients' voices, resulting in recognisable voice signatures and allowing the training of algorithms to predict the presence of a SARS-COV-2 infection or as a tool to grade the disease's severity. The findings of Cambridge University (Area Under the ROC Curve, AUC = 80%) and MIT scientists (AUC = 97 percent, based on cough recordings only) on vocal biomarkers to aid in the diagnosis of COVID-19 are promising.\n\n\n## The COUGHVID crowdsourcing dataset\n\nCough audio signal classification has been successfully used to diagnose a variety of respiratory conditions, and there has been significant interest in leveraging Machine Learning (ML) to provide widespread COVID-19 screening. The COUGHVID dataset provides over 25,000 crowdsourced cough recordings representing a wide range of participant ages, genders, geographic locations, and COVID-19 statuses. Four experienced physicians labeled more than 2,800 recordings to diagnose medical abnormalities present in the coughs, contributing one of the largest expert-labeled cough datasets in existence that can be used for a plethora of cough audio classification tasks. \n\n### Recording quality estimation\nEvery user who uploaded their cough sound to the COUGHVID dataset presumably used a different device, potentially introducing a variation in recording quality due to the different recording hardware and software of each device. Furthermore, the recordings were captured at various locations around the world with non-constant degrees of background noise. In order to assist users of the COUGHVID dataset in estimating the quality of each signal, open-sourced code to estimate the Signal-to-Noise Ratio (SNR) of each cough recording is provided.\n\n#### Reference\nOrlandic, L., Teijeiro, T. & Atienza, D. <br>\nThe COUGHVID crowdsourcing dataset, a corpus for the study of large-scale cough analysis algorithms. Sci Data 8, 156 (2021). <br>\nhttps:\/\/doi.org\/10.1038\/s41597-021-00937-4<br>\nhttps:\/\/www.nature.com\/articles\/s41597-021-00937-4<br>\nhttps:\/\/c4science.ch\/diffusion\/10770\/\n\n## Data Analysis"}}