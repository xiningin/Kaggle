{"cell_type":{"f3b48695":"code","6d098a6b":"code","98f784cd":"code","0fd1a5fa":"code","49a945be":"code","13fd426f":"code","bb1b7a3c":"code","6dcde590":"code","69e860db":"code","975e412b":"markdown","ef5cbbed":"markdown","35735faa":"markdown","5a631813":"markdown","0576dbf0":"markdown","a2223f10":"markdown","6c242bb4":"markdown","edca42ec":"markdown","416157a5":"markdown","3dcab6fc":"markdown","4ea96bbf":"markdown","03479b74":"markdown","da0f5689":"markdown","5dc5b7e9":"markdown","134a246e":"markdown","93953f7b":"markdown","74c1c961":"markdown"},"source":{"f3b48695":"import pandas as pd\nimport numpy as np\nimport os\n\nimport cv2\n\nfrom keras.preprocessing.image import load_img, img_to_array\nfrom keras.applications.vgg16 import preprocess_input, decode_predictions\nimport numpy as np\nfrom keras import backend as K\n\nimport matplotlib.pyplot as plt\n%matplotlib inline","6d098a6b":"os.listdir('..\/input')","98f784cd":"from keras.applications.vgg16 import VGG16\n\nmodel = VGG16(weights='imagenet')\n\nmodel.summary()","0fd1a5fa":"path = '..\/input\/images\/Images\/n02106662-German_shepherd\/n02106662_22394.jpg'\nimage = plt.imread(path)\n\nplt.imshow(image)\nplt.show()","49a945be":"from keras.preprocessing.image import load_img, img_to_array\nfrom keras.applications.vgg16 import preprocess_input, decode_predictions\nfrom keras import backend as K\n\n# set the path to the image\nimg_path = '..\/input\/images\/Images\/n02106662-German_shepherd\/n02106662_22394.jpg'\n\n# Load the image and resize to 224x224\nimg = load_img(img_path, target_size=(224, 224))\nx = img_to_array(img)\n\n# Expand dims so the image has shape: (1, 224, 224, 3)\nx = np.expand_dims(x, axis=0)\n\n# Pre-process the image using the same pre-processing that was applied\n# to the original imagenet images that were used to train VGG16.\nx = preprocess_input(x)\n\n","13fd426f":"# Make a prediction\npreds = model.predict(x)\n\n# Decode the prediction vector into a human readable format.\ndecode_predictions(preds, top=3)[0]","bb1b7a3c":"# VGG16 predicts on 1000 classes.\n# Here we want the index of the class that has the highest prediction probability i.e. German_sheperd\nimagenet_class = np.argmax(preds[0])\n\nimagenet_class","6dcde590":"# Get the German_sheperd entry from the prediction vector.\ndog_output = model.output[:, imagenet_class]\n\n# Get the output feature map from the last conv layer.\nlast_conv_layer = model.get_layer('block5_conv3')\n\n# Gradient of the \u201cGerman_sheperd\u201d class with regard to the output feature map of block5_conv3.\ngrads = K.gradients(dog_output, last_conv_layer.output)[0] \n\npooled_grads = K.mean(grads, axis=(0, 1, 2))\niterate = K.function([model.input],\n                     [pooled_grads, last_conv_layer.output[0]])\n\n# Values of these two quantities, as Numpy arrays, given the sample image.\npooled_grads_value, conv_layer_output_value = iterate([x])\n\nfor i in range(512):\n    # Multiplies each channel in the feature-map array by \n    # \u201chow important this channel is\" with regard to the \u201cGerman_sheperd\u201d class.\n    conv_layer_output_value[:, :, i] *= pooled_grads_value[i]\n\n# The channel-wise mean of the resulting feature map is the heatmap of the class activation.\nheatmap = np.mean(conv_layer_output_value, axis=-1)\n\n# For visulaization we normalize the heatmap between 0 and 1.\nheatmap = np.maximum(heatmap, 0)\nheatmap \/= np.max(heatmap)\n\nplt.matshow(heatmap)","69e860db":"# Use cv2 to read the image.\nimg = cv2.imread(img_path)\n\n# Resize the heatmap to be the same size as the original image.\nheatmap = cv2.resize(heatmap, (img.shape[1], img.shape[0]))\n\n# Convert the heatmap to RGB.\nheatmap = np.uint8(255 * heatmap)\n\n# Apply the heatmap to the original image.\nheatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)\n\n# 0.4 is the heatmap intensity factor.\nsuperimposed_img = heatmap * 0.4 + img\n\n# Save the image.\ncv2.imwrite('dog_heatmap.jpg', superimposed_img)\n\n# Display the superimposed image\nimage = plt.imread('dog_heatmap.jpg')\nplt.imshow(image)\n\nplt.show()","975e412b":"## Citations","ef5cbbed":"You may see a different heatmap each time you run the next cell.","35735faa":"How does a model decide that one dog is a Poodle and another is a German Sheperd? What physical features does it actually look at to reach these conclusions?\n\nIn this quick kernel I will share some step-by-step code that will help you to construct a Class Activation Map (CAM). This is simply a heatmap of scores that show how important each image pixel is with respect to a particular target class. For example, the above picture is a heatmap superimposed on an image. In it we see that the VGG16 model considered the face area very important when it decided that this dog is a German Sheperd.\n\nThe CAM technique can be helpful when analysing the errors that a model is making. It's not too complicated. Simply follow the recipe set out below.","5a631813":"## Make a prediction on an image","0576dbf0":"We will make a prediction on this image.","a2223f10":"<hr>","6c242bb4":"In the above architecture take note that **block5_conv3** is the last convolutional layer. We will be using this layer to generate the heatmap.","edca42ec":"## Conclusion","416157a5":"## Introduction","3dcab6fc":"1. This code is taken from the book Deep Learning with Python by Francois Chollet, Chapter 5, Pg. 172.<br>\nhttps:\/\/www.manning.com\/books\/deep-learning-with-python\n\n2. Grad-CAM: Visual Explanations from Deep Networks via Gradient-based Localization<br>\nRamprasaath R. Selvaraju, Michael Cogswell, Abhishek Das, Ramakrishna Vedantam, Devi Parikh, Dhruv Batra<br>\nhttps:\/\/arxiv.org\/abs\/1610.02391","4ea96bbf":"## Set up the model","03479b74":"<img src=\"http:\/\/bee.test.woza.work\/assets\/dog_heatmap.jpg\" width=\"500\"><\/img>\n\n<h5 align=\"center\">Heatmap showing the area that VGG16 focused on <br> when it predicted \"German Sheperd\"<\/h5>","da0f5689":"We will use a pre-trained VGG16 model with imagenet weights. Please switch on the internet in your kernel in order to download the model weights.","5dc5b7e9":"## Create the heatmap","134a246e":"**Doggyness Visualizer**<br>\nby Marsh [ @vbookshelf ]<br>\n23 July 2019","93953f7b":"I hope you find this technique useful when debugging your machine learning models.<br>Thank you for reading.","74c1c961":"The heatmap will tell us which parts of the image are the most German Sheperd like."}}