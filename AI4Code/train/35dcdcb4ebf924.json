{"cell_type":{"0c5bfd68":"code","9625fb81":"code","cec637ab":"code","638b976f":"code","bd2db419":"code","68c56d1e":"code","298463f8":"code","81c73456":"code","b185a6ee":"code","ac41e2b9":"code","01d1e84e":"code","fc12459e":"code","a9ab3bb3":"code","11e97131":"code","e458cc47":"code","1d6f7812":"code","0325e6bf":"code","e81c7d86":"code","cf0b83ea":"code","30e8d60c":"code","a339fe6a":"code","11cf8766":"code","a712a32e":"code","f08fa74b":"code","7fbca726":"code","4c3b8dba":"code","051aa17c":"code","ef61616c":"code","b28a3d02":"code","cd45d0c8":"code","1f4e1b05":"code","d03c45d7":"code","70fbcd33":"code","595dd5df":"code","b29449d4":"code","fb110ca3":"code","1ffdc6e7":"code","3e757f3f":"code","5a361999":"code","8c6cb69f":"code","e510dca6":"code","4e128d19":"code","2c98229b":"code","a0a1837b":"code","e237d284":"code","3438719c":"code","960b73f0":"code","b9efe3ad":"code","77a66485":"code","531cf8a6":"code","cc900919":"code","7e1beddf":"code","047e26d3":"code","30aef3f8":"code","2ef0e22f":"code","98c891e7":"code","ef31433e":"code","9fad9f51":"code","805facea":"code","0b032a30":"markdown","93069b22":"markdown","cb936917":"markdown","2239047c":"markdown","5aed3087":"markdown","9f0732d5":"markdown","fe2591f2":"markdown","4b5d1f53":"markdown","74e73e3f":"markdown","9ea0837f":"markdown","ee0292e5":"markdown","0f25699c":"markdown","a2a276cb":"markdown","87764cea":"markdown","c298ed6a":"markdown","568827bc":"markdown","58b83383":"markdown","1e76396d":"markdown","707e3967":"markdown","2578722e":"markdown","315ea891":"markdown","0a03505e":"markdown"},"source":{"0c5bfd68":"# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","9625fb81":"import os\nimport math\nimport optuna\nimport warnings\nimport matplotlib\n%matplotlib inline\nimport pystan.misc\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom pprint import pprint\nimport matplotlib.cm as cm\nimport dask.dataframe as dd\nfrom fbprophet import Prophet\nfrom datetime import timedelta\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nfrom sklearn.cluster import KMeans\nfrom collections import defaultdict\nimport matplotlib.colors as mcolors\nfrom scipy.optimize import curve_fit\nfrom scipy.integrate import solve_ivp\noptuna.logging.disable_default_handler()\npd.plotting.register_matplotlib_converters()\nfrom matplotlib.ticker import ScalarFormatter\nfrom dateutil.relativedelta import relativedelta\nfrom fbprophet.plot import add_changepoints_to_plot\nfrom sklearn.feature_extraction.text import TfidfVectorizer","cec637ab":"confirmed_df  = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_covid19_confirmed_global.csv')\ndeaths_df     = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_covid19_deaths_global.csv')\nrecoveries_df = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_covid19_recovered_global.csv')","638b976f":"population_df = pd.read_csv('..\/input\/covid19-global-forecasting-locations-population\/locations_population.csv')\npopulation_df.head(5)","bd2db419":"x = pd.DataFrame(population_df.isnull().sum()).T\nx.style.background_gradient(cmap='Reds',axis=1)","68c56d1e":"df_pop = population_df.copy()\ndf_pop = df_pop.rename({ 'Province.State' : 'province', 'Country.Region': 'country'}, axis = 1)\ncols = ['country', 'province', 'Population']\ndf_pop = df_pop.loc[:,cols].fillna('-')\ndf_pop.loc[df_pop['country'] == df_pop['province'],'province'] = '-'\n\n\ntotal = df_pop.loc[df_pop['province'] != '-', :].groupby('country').sum()\ntotal_pop = total.reset_index().assign(Province=\"-\")\n\ndf_pop = pd.concat([df_pop, total_pop], axis=0, sort=True)\ndf_pop = df_pop.drop_duplicates(subset=[\"country\", \"province\"], keep=\"first\")\n# Global\nglobal_value = df_pop.loc[df_pop[\"province\"] == \"-\",'Population'].sum()\ndf_pop = df_pop.append(pd.Series([\"Global\", \"-\", global_value], index=cols), ignore_index=True)\n# Sorting\ndf_pop = df_pop.sort_values(\"Population\", ascending=False).reset_index(drop=True)\ndf_pop = df_pop.loc[:, cols]\npopulation_df = df_pop.copy()\npopulation_df.head()\npopulation_df.style.background_gradient(cmap='Wistia',axis=1)","298463f8":"df = population_df.loc[population_df[\"province\"] == \"-\", :]\npopulation_dict = df.set_index(\"country\").to_dict()[\"Population\"]\npopulation_dict","81c73456":"india = pd.read_csv('..\/input\/population-pyramid-2019\/India-2019.csv')\nindia","b185a6ee":"india.sum()","ac41e2b9":"pyramid_csv_list = list()\nfor dirname, _, filenames in os.walk(\"\/kaggle\/input\/population-pyramid-2019\/\"):\n    for filename in filenames:\n        name = os.path.join(dirname, filename)\n        df = pd.read_csv(name)\n        df[\"Country\"], df[\"Year\"], _ = filename.replace(\".\", \"-\").split(\"-\")\n        pyramid_csv_list.append(df)\npyramid_raw = pd.concat(pyramid_csv_list, sort=True)\npyramid_raw.head()","01d1e84e":"pyramid_raw[\"Country\"].unique()","fc12459e":"df = pyramid_raw.copy()\ndf[\"Country\"] = df[\"Country\"].replace(\n    {\n        \"United States of America\": \"US\",\n        \"United Kingdom\": \"UK\",\n    }\n)\n# Global (WORLD)\n_male = [\n    349432556, 342927576, 331497486, 316642222, 308286775, 306059387, 309236984,\n    276447037, 249389688, 241232876, 222609691, 192215395, 157180267, 128939392,\n    87185982, 54754941, 33648953, 15756942, 5327866, 1077791, 124144\n]\n_female = [\n    328509234, 321511867, 309769906, 295553758, 289100903, 288632766, 296293748,\n    268371754, 244399176, 238133281, 223162982, 195633743, 164961323, 140704320,\n    101491347, 69026831, 48281201, 26429329, 11352182, 3055845, 449279\n]\n_df = pd.DataFrame(\n    {\n        \"Age\": df[\"Age\"].unique(),\n        \"Country\": \"Global\",\n        \"F\": _female,\n        \"M\": _male,\n        \"Year\": 2019\n    }\n)\ndf = pd.concat([df, _df], axis=0, ignore_index=True, sort=True)\n# Sweden\n_male = [\n    307116,304759,296771,270840,291723,376952,343311,315086,312017,336452,342117,306949,279609,265511,\n    273061,195029,113166,61775,26170,6768,415]\n_female = [ 290553, 288817, 280944,257677, 274760, 361526, 330153,300752,301288,327453,331458,300084,\n    280009,272149,286879,212480,143654,97633,52624,18130,1771]\n_df = pd.DataFrame(\n    {\n        \"Age\": df[\"Age\"].unique(),\n        \"Country\": \"Sweden\",\n        \"F\": _female,\n        \"M\": _male,\n        \"Year\": 2019\n    }\n)\ndf = pd.concat([df, _df], axis=0, ignore_index=True, sort=True)\n# Philippines\n_male = [5534962,5820604,5538414,5383822,5149849,4710777,4061897,3581091,3237426, 2832825,2482953,2015857,\n    1556935,1082875,668107,364200,199400,73508,17327,3035,208 ]\n_female = [5240508,5541514,5273495,5029137,4896316,4589506,3982681,3544279,3191565,2825286,2521463,2112380,\n    1714689,1285782,895866,567282,360751,155294,57969,13376,1411]\n_df = pd.DataFrame(\n    {\n        \"Age\": df[\"Age\"].unique(),\n        \"Country\": \"Philippines\",\n        \"F\": _female,\n        \"M\": _male,\n        \"Year\": 2019\n    }\n)\ndf = pd.concat([df, _df], axis=0, ignore_index=True, sort=True)\n# Arrange\ndf[\"Population\"] = df[\"F\"] + df[\"M\"]\ndf = df.pivot_table(\n    index=\"Age\", columns=[\"Country\"], values=\"Population\", aggfunc=\"last\"\n)\ndf = df.astype(np.int64).reset_index().rename({\"Age\": \"Age_bin\"}, axis=1)\nseries = df[\"Age_bin\"].str.replace(\"+\", \"-122\")\ndf[[\"Age_first\", \"Age_last\"]] = series.str.split(\"-\", expand=True).astype(np.int64)\ndf = df.drop(\"Age_bin\", axis=1)\nseries = df[\"Age_last\"]\ndf = df.apply(lambda x: x[:-2] \/ (x[-1] - x[-2] + 1), axis=1)\ndf[\"Age\"] = series\ndf = pd.merge(df, pd.DataFrame({\"Age\": np.arange(0, 123, 1)}), on=\"Age\", how=\"right\", sort=True)\ndf = df.fillna(method=\"bfill\").astype(np.int64)\ndf = df.set_index(\"Age\")\npyramid_df = df.copy()\npyramid_df.style.background_gradient(cmap='Wistia',axis=1)","a9ab3bb3":"# @marcoferrante estimation\n_period_of_life_list = [\n    \"nursery\", \"nursery school\", \"elementary school\", \"middle school\",\n    \"high school\", \"university\/work\", \"work\", \"work\", \"work\", \"work\",\n    \"retired\", \"retired\", \"retired\"\n]\ndf = pd.DataFrame(\n    {\n        \"Age_first\": [0, 3, 6, 11, 14, 19, 26, 36, 46, 56, 66, 76, 86],\n        \"Age_last\": [2, 5, 10, 13, 18, 25, 35, 45, 55, 65, 75, 85, 95],\n        \"Period_of_life\": _period_of_life_list,\n        \"Days\": [3, 5, 6, 6, 7, 7, 6, 5, 5, 5, 4, 3, 2]\n    }\n)\n# Adjustment by author\ndf[\"Types\"] = df[\"Period_of_life\"].replace(\n    {\n        \"nursery\": \"school\",\n        \"nursery school\": \"school\",\n        \"elementary school\": \"school\",\n        \"middle school\": \"school\",\n        \"high school\": \"school\",\n        \"university\/work\": \"school\/work\"\n    }\n)\ndf[\"School\"] = df[[\"Types\", \"Days\"]].apply(lambda x: x[1] if \"school\" in x[0] else 0, axis=1)\ndf[\"Office\"] = df[[\"Types\", \"Days\"]].apply(lambda x: x[1] if \"work\" in x[0] else 0, axis=1)\ndf[\"Others\"] = df[\"Days\"] - df[[\"School\", \"Office\"]].sum(axis=1)\ndf.loc[df[\"Others\"] < 0, \"Others\"] = 0\ndf.loc[df.index[1:5], \"School\"] -= 1\ndf.loc[df.index[1:5], \"Others\"] += 1\ndf.loc[df.index[5], [\"School\", \"Office\", \"Others\"]] = [3, 3, 1]\ndf[[\"School\", \"Office\", \"Others\"]] = df[[\"Days\", \"School\", \"Office\", \"Others\"]].apply(\n    lambda x: x[1:] \/ sum(x[1:]) * x[0], axis=1\n).astype(np.int64)\ndf.loc[df.index[6:10], \"Others\"] += 1\ndf = df.drop([\"Days\", \"Types\"], axis=1)\n# Show dataset\n_out_df = df.copy()\n_out_df.style.background_gradient(cmap='Wistia',axis=1)","11e97131":"df = pyramid_df.cumsum()\ncountries = df.columns[:]\ndf = pd.merge(_out_df, df, left_on=\"Age_last\", right_on=\"Age\", how=\"left\")\n_first = df.loc[df.index[0], countries]\ndf[countries] = df[countries].diff()\ndf.loc[df.index[0], countries] = _first\ndf[countries] = df[countries].apply(lambda x: x \/ x.sum(), axis=0)\nout_df = df.copy()\n#out_df.style.background_gradient(cmap='Wistia',axis=1)","e458cc47":"def go_out(country, out_df=out_df):\n    df = out_df.copy()\n    try:\n        series = df[country]\n    except KeyError:\n        raise KeyError(f\"Population pyramid data of {country} is not defined!\")\n    df = df.iloc[:, :6]\n    df[\"Portion\"] = series\n    return df\ngo_out(\"Global\").style.background_gradient(cmap='Reds',axis=1)","1d6f7812":"def line_plot(df, title, xlabel=None, ylabel=\"Cases\",\n              h=None, v=None, xlim=(None, None), ylim=(0, None),\n              math_scale=True, y_logscale=False, y_integer=False,\n              show_legend=True, bbox_to_anchor=(1.02, 0),  bbox_loc=\"lower left\"):\n    ax = df.plot()\n    if math_scale:\n        ax.yaxis.set_major_formatter(ScalarFormatter(useMathText=True))\n        ax.ticklabel_format(style=\"sci\",  axis=\"y\",scilimits=(0, 0))\n    if y_logscale:\n        ax.set_yscale(\"log\")\n        if ylim[0] == 0:\n            ylim = (None, None)\n    if y_integer:\n        fmt = matplotlib.ticker.ScalarFormatter(useOffset=False)\n        fmt.set_scientific(False)\n        ax.yaxis.set_major_formatter(fmt)\n    \n    #ax.figure(figsize = (10,8)) \n    ax.grid()\n    ax.set_title(title)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.set_xlim(*xlim)\n    ax.set_ylim(*ylim)\n    if show_legend:\n        ax.legend(bbox_to_anchor=bbox_to_anchor, loc=bbox_loc, borderaxespad=0)\n    else:\n        ax.legend().set_visible(False)\n    if h is not None:\n        ax.axhline(y=h, color=\"black\", linestyle=\"--\")\n    if v is not None:\n        if not isinstance(v, list):\n            v = [v]\n        for value in v:\n            ax.axvline(x=value, color=\"black\", linestyle=\"--\")\n    plt.figure(figsize = (10,8))\n    plt.tight_layout()\n    plt.show()","0325e6bf":"raw = pd.read_csv(\"\/kaggle\/input\/novel-corona-virus-2019-dataset\/covid_19_data.csv\")\nraw.head().style.background_gradient(cmap='Reds',axis=1 )","e81c7d86":"raw.describe().style.background_gradient(cmap='Reds',axis=1)","cf0b83ea":"data_cols = [\"Infected\", \"Deaths\", \"Recovered\"]\ndata_cols_all = [\"Confirmed\", \"Infected\", \"Deaths\", \"Recovered\"]\nrate_cols = [\"Fatal per Confirmed\", \"Recovered per Confirmed\", \"Fatal per (Fatal or Recovered)\"]\nvariable_dict = {\"Susceptible\": \"S\", \"Infected\": \"I\", \"Recovered\": \"R\", \"Deaths\": \"D\"}","30e8d60c":"df = raw.rename({\"ObservationDate\": \"Date\", \"Province\/State\": \"Province\"}, axis=1)\ndf[\"Date\"] = pd.to_datetime(df[\"Date\"])\ndf[\"Country\"] = df[\"Country\/Region\"].replace(\n    {\n        \"Mainland China\": \"China\",\n        \"Hong Kong SAR\": \"Hong Kong\",\n        \"Taipei and environs\": \"Taiwan\",\n        \"Iran (Islamic Republic of)\": \"Iran\",\n        \"Republic of Korea\": \"South Korea\",\n        \"Republic of Ireland\": \"Ireland\",\n        \"Macao SAR\": \"Macau\",\n        \"Russian Federation\": \"Russia\",\n        \"Republic of Moldova\": \"Moldova\",\n        \"Taiwan*\": \"Taiwan\",\n        \"Cruise Ship\": \"Others\",\n        \"United Kingdom\": \"UK\",\n        \"Viet Nam\": \"Vietnam\",\n        \"Czechia\": \"Czech Republic\",\n        \"St. Martin\": \"Saint Martin\",\n        \"Cote d'Ivoire\": \"Ivory Coast\",\n        \"('St. Martin',)\": \"Saint Martin\",\n        \"Congo (Kinshasa)\": \"Congo\",\n        \"Congo (Brazzaville)\": \"Congo\",\n        \"The, Bahamas\": \"Bahamas\",\n    }\n)\ndf[\"Province\"] = df[\"Province\"].fillna(\"-\").replace(\n    {\n        \"Cruise Ship\": \"Diamond Princess\",\n        \"Diamond Princess cruise ship\": \"Diamond Princess\"\n    }\n)\ndf.loc[df[\"Country\"] == \"Diamond Princess\", [\"Country\", \"Province\"]] = [\"Others\", \"Diamond Princess\"]\ndf[\"Infected\"] = df[\"Confirmed\"] - df[\"Deaths\"] - df[\"Recovered\"]\ndf[data_cols_all] = df[data_cols_all].astype(np.int64)\nncov_df_ungrouped = df.loc[:, [\"Date\", \"Country\", \"Province\", *data_cols_all]]\nncov_df_ungrouped.tail().style.background_gradient(cmap='Reds',axis=1)","a339fe6a":"ncov_df_ungrouped.describe(include=\"all\").fillna(\"-\").style.background_gradient(cmap='Reds',axis=1)","11cf8766":"\", \".join(ncov_df_ungrouped[\"Country\"].unique().tolist())","a712a32e":"total_df = ncov_df_ungrouped.groupby(\"Date\").sum()\ntotal_df[rate_cols[0]] = total_df[\"Deaths\"] \/ total_df[data_cols].sum(axis=1)\ntotal_df[rate_cols[1]] = total_df[\"Recovered\"] \/ total_df[data_cols].sum(axis=1)\ntotal_df[rate_cols[2]] = total_df[\"Deaths\"] \/ (total_df[\"Deaths\"] + total_df[\"Recovered\"])\ntotal_df.tail().style.background_gradient(cmap='Reds',axis=1)","f08fa74b":"f\"{(total_df.index.max() - total_df.index.min()).days} days have passed from the date of the first record.\"","7fbca726":"line_plot(total_df[data_cols], \"Total number of cases over time\")","4c3b8dba":"\nconfirmed_df        = confirmed_df.groupby(['Country\/Region']).sum()\nrecoveries_df       = recoveries_df.groupby(['Country\/Region']).sum()\ndeaths_df           = deaths_df.groupby(['Country\/Region']).sum()\n\ndates               = np.array([dt[:-3] for dt in confirmed_df.columns[2:]])\n\ndate_ticks     = np.arange(0, len(dates), 7) \ndate_labels    = dates[date_ticks]\n\nprint('Data available till:', confirmed_df.columns[-1])","051aa17c":"def sir_model_fitting(country, cluster_population=500000000, passed_data=0, show_plots=1, days_to_predict=10):\n    \"\"\"Fit SIR model and plot data vs model result for 90 days for comparison\"\"\"\n    if passed_data:\n        ydata   = country\n        country = 'Worldwide (excluding China)' \n    else:\n        confirmed          = np.array(confirmed_df.loc[country, confirmed_df.columns[2:]])\n        recovered          = np.array(recoveries_df.loc[country, recoveries_df.columns[2:]])\n        deaths             = np.array(deaths_df.loc[country, deaths_df.columns[2:]])\n        ydata              = confirmed - recovered - deaths\n        \n    xdata = np.arange(len(ydata))+1\n    days_to_predict = len(xdata) + days_to_predict\n    ind   = np.where(ydata>0)[0][0]\n    model_output = ydata[ind:]\n    model_input = np.arange(len(model_output))\n\n    inf0 = model_output[0]\n    sus0 = cluster_population - inf0\n    rec0 = 0\n\n    def sir_model(y, x, beta, gamma):\n        sus = -beta * y[0] * y[1]\/cluster_population\n        rec = gamma * y[1]\n        inf = -(sus + rec)\n        return sus, inf, rec\n\n    def fit_odeint(x, beta, gamma):\n        return odeint(sir_model, (sus0, inf0, rec0), x, args=(beta, gamma))[:,1]\n\n    popt, pcov = curve_fit(fit_odeint, model_input, model_output)\n    fitted = fit_odeint(np.arange(days_to_predict-ind), *popt)\n    fitted = np.append(np.zeros((ind,1)), fitted)\n\n    if show_plots:\n        fig = plt.figure(figsize = (13,8))\n        plt.plot(xdata, ydata, 'o')\n        plt.plot(np.arange(len(fitted))+1, fitted)\n        plt.plot([len(xdata), len(xdata)],[0, np.max(fitted)], ':k')\n        plt.legend(['data', 'model prediction', \"today we're here\"])\n        plt.title(\"SIR model fit to 'active cases' of \" + country)\n        plt.ylabel(\"Population infected\")\n        plt.xlabel(\"Days since 22 Jan 2020\")\n        plt.grid('best')\n\n        print(\"Optimal parameters: beta =\", round(popt[0],3), \" gamma = \", round(popt[1],3))\n    #     print('Goodness of fit', round(r2_score(ydata, fit_odeint(xdata, *popt)),4)*100, ' %')\n        print('Optimal parameters Standard Dev: std_beta =', np.round(np.sqrt(pcov[0][0]),3), ' std_gamma =', np.round(np.sqrt(pcov[1][1]),3))\n    else:\n        return fitted","ef61616c":"#  def data_plot_country(country, show_plots=1): \n#     confirmed          = np.array(confirmed_df.loc[country, confirmed_df.columns[2:]])\n#     recovered          = np.array(recoveries_df.loc[country, recoveries_df.columns[2:]])\n#     deaths             = np.array(deaths_df.loc[country, deaths_df.columns[2:]])\n        \n#     if show_plots:\n#         fig = plt.figure()\n#         plt.stackplot(dates, confirmed - recovered - deaths, recovered, deaths, labels=['active cases', 'recovered','deaths'])\n#         plt.grid()\n#         plt.title('Cases in ' + country)\n#         plt.ylabel(\"# of cases\")\n#         plt.xticks(date_ticks, date_labels)\n#         plt.legend(loc='upper left')\n#         print('Mortality rate:', round(deaths[-1]\/confirmed[-1]*100,2), '%')\n    \n#     return confirmed, recovered, deaths","b28a3d02":"def select_area(ncov_df, group=\"Date\", places=None, areas=None, excluded_places=None,\n                start_date=None, end_date=None, date_format=\"%d%b%Y\"):\n    # Select the target records\n    df = ncov_df.copy()\n    if (places is not None) or (excluded_places is not None):\n        c_series = df[\"Country\"]\n        p_series = df[\"Province\"]\n        if places is not None:\n            df = pd.DataFrame(columns=ncov_df.columns)\n            for (c, p) in places:\n                if c is None:\n                    raise Exception(\"places: Country must be specified!\")\n                if p is None:\n                    new_df = ncov_df.loc[c_series == c, :]\n                else:\n                    new_df = ncov_df.loc[(c_series == c) & (p_series == p), :]\n                df = pd.concat([df, new_df], axis=0)\n        if excluded_places is not None:\n            for (c, p) in excluded_places:\n                if c is None:\n                    raise Exception(\"excluded_places: Country must be specified!\")\n                if p is None:\n                    df = df.loc[c_series != c, :]\n                else:\n                    c_df = df.loc[(c_series == c) & (p_series != p), :]\n                    other_df = df.loc[c_series != c, :]\n                    df = pd.concat([c_df, other_df], axis=0)\n    if areas is not None:\n        df = df.loc[df[\"Area\"].isin(areas), :]\n    if group is not None:\n        df = df.groupby(group).sum().reset_index()\n    # Range of date\n    if start_date is not None:\n        df = df.loc[df[\"Date\"] >= datetime.strptime(start_date, date_format), :]\n    if end_date is not None:\n        df = df.loc[df[\"Date\"] <= datetime.strptime(end_date, date_format), :]\n    # Only use the records with Confirmed > 0\n    try:\n        df = df.loc[df[\"Confirmed\"] > 0, :]\n    except KeyError:\n        pass\n    # Aleart empty\n    if df.empty:\n        raise Exception(\"The output dataframe is empty!\")\n    return df","cd45d0c8":"def create_target_df(ncov_df, total_population,\n                     confirmed=\"Confirmed\", recovered=\"Recovered\", fatal=\"Deaths\", **kwargs):\n    # Select the target records\n    df = select_area(ncov_df, **kwargs)\n    first_date = df.loc[df.index[0], \"Date\"]\n    # column T\n    df[\"T\"] = ((df[\"Date\"] - first_date).dt.total_seconds() \/ 60).astype(int)\n    # coluns except T\n    cols = [confirmed, recovered, fatal]\n    if not set(cols).issubset(set(df.columns)):\n        raise KeyError(f\"ncov_df must have {', '.join(cols)} column!\")\n    df[\"Susceptible\"] = total_population - df[confirmed]\n    df[\"Infected\"] = df[confirmed] - df[recovered] - df[fatal]\n    df[\"Recovered\"] = df[recovered]\n    df[\"Fatal\"] = df.loc[:, fatal]\n    response_variables = [\"Susceptible\", \"Infected\", \"Recovered\", \"Fatal\"]\n    # Return\n    target_df = df.loc[:, [\"T\", *response_variables]]\n    return (first_date, target_df)","1f4e1b05":"def simulation(model, initials, step_n, **params):\n    tstart, dt, tend = 0, 1, step_n\n    sol = solve_ivp(\n        fun=model(**params),\n        t_span=[tstart, tend],\n        y0=np.array(initials, dtype=np.float64),\n        t_eval=np.arange(tstart, tend + dt, dt),\n        dense_output=False  # True\n    )\n    t_df = pd.Series(data=sol[\"t\"], name=\"t\")\n    y_df = pd.DataFrame(data=sol[\"y\"].T.copy(), columns=model.VARIABLES)\n    sim_df = pd.concat([t_df, y_df], axis=1)\n    return sim_df","d03c45d7":"class ModelBase(object):\n    NAME = \"Model\"\n    VARIABLES = [\"x\"]\n    PRIORITIES = np.array([1])\n    QUANTILE_RANGE = [0.3, 0.7]\n    MONOTONIC = [\"x\"]\n\n    @classmethod\n    def param_dict(cls, train_df_divided=None, q_range=None):\n        param_dict = dict()\n        return param_dict\n\n    @staticmethod\n    def calc_variables(df):\n        return df\n\n    @staticmethod\n    def calc_variables_reverse(df):\n        return df\n\n    @classmethod\n    def create_dataset(cls, ncov_df, total_population, **kwargs):\n        start_date, target_df = create_target_df(ncov_df, total_population, **kwargs)\n        df = cls.calc_variables(target_df).set_index(\"T\") \/ total_population\n        df.columns = [n.lower() for n in df.columns]\n        initials = df.iloc[0, :].values\n        df = df.reset_index()\n        Tend = df.iloc[-1, 0]\n        return (start_date, initials, Tend, df)\n\n    def calc_r0(self):\n        return None\n\n    def calc_days_dict(self, tau):\n        return dict()","70fbcd33":"class SIR(ModelBase):\n    NAME = \"SIR\"\n    VARIABLES = [\"x\", \"y\", \"z\"]\n    PRIORITIES = np.array([1, 1, 1])\n    MONOTONIC = [\"z\"]\n\n    def __init__(self, rho, sigma):\n        super().__init__()\n        self.rho = rho\n        self.sigma = sigma\n\n    def __call__(self, t, X):\n        # x, y, z = [X[i] for i in range(len(self.VARIABLES))]\n        # dxdt = - self.rho * x * y\n        # dydt = self.rho * x * y - self.sigma * y\n        # dzdt = self.sigma * y\n        dxdt = - self.rho * X[0] * X[1]\n        dydt = self.rho * X[0] * X[1] - self.sigma * X[1]\n        dzdt = self.sigma * X[1]\n        return np.array([dxdt, dydt, dzdt])\n\n    @classmethod\n    def param_dict(cls, train_df_divided=None, q_range=None):\n        param_dict = super().param_dict()\n        q_range = super().QUANTILE_RANGE[:] if q_range is None else q_range\n        if train_df_divided is not None:\n            df = train_df_divided.copy()\n            # rho = - (dx\/dt) \/ x \/ y\n            rho_series = 0 - df[\"x\"].diff() \/ df[\"t\"].diff() \/ df[\"x\"] \/ df[\"y\"]\n            param_dict[\"rho\"] = rho_series.quantile(q_range)\n            # sigma = (dz\/dt) \/ y\n            sigma_series = df[\"z\"].diff() \/ df[\"t\"].diff() \/ df[\"y\"]\n            param_dict[\"sigma\"] = sigma_series.quantile(q_range)\n            return param_dict\n        param_dict[\"rho\"] = (0, 1)\n        param_dict[\"sigma\"] = (0, 1)\n        return param_dict\n\n    @staticmethod\n    def calc_variables(df):\n        df[\"X\"] = df[\"Susceptible\"]\n        df[\"Y\"] = df[\"Infected\"]\n        df[\"Z\"] = df[\"Recovered\"] + df[\"Fatal\"]\n        return df.loc[:, [\"T\", \"X\", \"Y\", \"Z\"]]\n\n    @staticmethod\n    def calc_variables_reverse(df):\n        df[\"Susceptible\"] = df[\"X\"]\n        df[\"Infected\"] = df[\"Y\"]\n        df[\"Recovered\/Deaths\"] = df[\"Z\"]\n        return df\n\n    def calc_r0(self):\n        if self.sigma == 0:\n            return np.nan\n        r0 = self.rho \/ self.sigma\n        return round(r0, 2)\n\n    def calc_days_dict(self, tau):\n        _dict = dict()\n        _dict[\"1\/beta [day]\"] = int(tau \/ 24 \/ 60 \/ self.rho)\n        _dict[\"1\/gamma [day]\"] = int(tau \/ 24 \/ 60 \/ self.sigma)\n        return _dict","595dd5df":"jpn_ncov_raw = pd.read_csv(\"\/kaggle\/input\/covid19-dataset-in-japan\/covid_jpn_total.csv\")\njpn_ncov_raw.tail()","b29449d4":"# https:\/\/www.kaggle.com\/lisphilar\/eda-of-japan-dataset\n# and remove returunee\/airport cases\ndf = jpn_ncov_raw.copy()\ndf.dropna(how=\"any\", inplace=True)\ndf[\"Date\"] = pd.to_datetime(df[\"Date\"])\ndf = df.groupby(\"Location\").apply(\n    lambda x: x.set_index(\"Date\").resample(\"D\").interpolate(method=\"linear\")\n)\ndf = df.drop(\"Location\", axis=1).reset_index()\ndf = df.loc[df[\"Location\"] == \"Domestic\", :].drop(\"Location\", axis=1)\ndf = df.set_index(\"Date\").resample(\"D\").last().fillna(\"ffill\")\nsel = df.columns.isin([\"Location\", \"Date\"])\ndf.loc[:, ~sel] = df.loc[:, ~sel].astype(np.int64)\njpn_ncov_df = df.copy()\njpn_ncov_df.tail()","fb110ca3":"df = ncov_df_ungrouped.pivot_table(\n    index=\"Date\", columns=\"Country\", values=\"Confirmed\", aggfunc=\"sum\"\n).fillna(method=\"ffill\").fillna(0)\n# Growth factor: (delta Number_n) \/ (delta Number_n)\ndf = df.diff() \/ df.diff().shift(freq=\"D\")\ndf = df.replace(np.inf, np.nan).fillna(1.0)\n# Rolling mean (window: 7 days)\ndf = df.rolling(7).mean()\ndf = df.iloc[6:, :]\n# round: 0.01\ngrowth_value_df = df.round(2)\ngrowth_value_df.tail()","1ffdc6e7":"df = growth_value_df.copy()\ndf = df.iloc[-7:, :].T\nday_cols = df.columns.strftime(\"%d%b%Y\")\ndf.columns = day_cols\nlast_date = day_cols[-1]\n# Grouping\nmore_col, less_col = \"GF > 1 [straight days]\", \"GF < 1 [straight days]\"\ndf[more_col] = (growth_value_df > 1).iloc[::-1].cumprod().sum(axis=0)\ndf[less_col] = (growth_value_df < 1).iloc[::-1].cumprod().sum(axis=0)\ndf[\"Group\"] = df[[more_col, less_col]].apply(\n    lambda x: \"Outbreaking\" if x[0] >= 7 else \"Stopping\" if x[1] >= 7 else \"Crossroad\",\n    axis=1\n)\n# Sorting\ndf = df.loc[:, [\"Group\", more_col, less_col, *day_cols]]\ndf[\"rank1\"] = df[more_col] * df[last_date]\ndf[\"rank2\"] = df[less_col] * df[last_date]\ndf = df.sort_values([\"Group\", \"rank1\", \"rank2\"], ascending=False)\ndf = df.drop([\"rank1\", \"rank2\"], axis=1)\ngrowth_df = df.copy()\ngrowth_df.head()","3e757f3f":"df = pd.merge(ncov_df_ungrouped, growth_df[\"Group\"].reset_index(), on=\"Country\")\nncov_df = df.loc[:, [\"Date\", \"Group\", *ncov_df_ungrouped.columns[1:]]]\nncov_df.tail()","5a361999":"pprint(growth_df.loc[growth_df[\"Group\"] == \"Outbreaking\", :].index.tolist(), compact=True)","8c6cb69f":"growth_df.loc[growth_df[\"Group\"] == \"Outbreaking\", :].head()","e510dca6":"df = ncov_df.loc[ncov_df[\"Group\"] == \"Outbreaking\", [\"Date\", *data_cols]].groupby(\"Date\").sum()\nline_plot(df, \"Group 1 (Outbreaking): Cases over time\", y_integer=True)\ndf.tail()","4e128d19":"pprint(growth_df.loc[growth_df[\"Group\"] == \"Stopping\", :].index.tolist(), compact=True)","2c98229b":"growth_df.loc[growth_df[\"Group\"] == \"Stopping\", :].head()","a0a1837b":"df = ncov_df.loc[ncov_df[\"Group\"] == \"Stopping\", [\"Date\", *data_cols]].groupby(\"Date\").sum()\nline_plot(df, \"Group 2 (Stopping): Cases over time\", y_integer=True)\ndf.tail()","e237d284":"pprint(growth_df.loc[growth_df[\"Group\"] == \"Crossroad\", :].index.tolist(), compact=True)","3438719c":"growth_df.loc[growth_df[\"Group\"] == \"Crossroad\", :].head()","960b73f0":"df = ncov_df.loc[ncov_df[\"Group\"] == \"Crossroad\", [\"Date\", *data_cols]].groupby(\"Date\").sum()\nline_plot(df, \"Group 3 (At a crossroad): Cases over time\", y_integer=True)\ndf.tail()","b9efe3ad":"critical_country = growth_df.loc[growth_df[\"Group\"] == \"Outbreaking\", :].index[0]\ncritical_country","77a66485":"critical_df = ncov_df.loc[ncov_df[\"Country\"] == critical_country, [\"Date\", *data_cols]].groupby(\"Date\").sum()\ncritical_df.tail()","531cf8a6":"line_plot(critical_df, f\"{critical_country}: Cases over time\", y_integer=True)","cc900919":"critical_country_start = \"25Mar2020\"","7e1beddf":"train_dataset = SIR.create_dataset(\n    ncov_df, population_dict[critical_country], excluded_places=[(critical_country, None)],\n    #start_date=critical_country_start\n)\ntrain_start_date, train_initials, train_Tend, train_df = train_dataset\npprint([train_start_date.strftime(\"%d%b%Y\"), train_initials, train_Tend])","047e26d3":"line_plot(\n    train_df.set_index(\"T\").drop(\"x\", axis=1),\n    \"Training data: y(T), z(T)\", math_scale=False, ylabel=\"\"\n)","30aef3f8":"eg_r0, eg_rho = (2.5, 0.2)\neg_sigma = eg_rho \/ eg_r0\n(eg_rho, eg_sigma)","2ef0e22f":"\neg_df = simulation(SIR, train_initials, step_n=200, rho=eg_rho, sigma=eg_sigma)","98c891e7":"line_plot(\n    eg_df.set_index(\"t\"),\n    title=r\"SIR: $R_0$={0} ($\\rho$={1}, $\\sigma$={2})\".format(eg_r0, eg_rho, eg_sigma),\n    ylabel=\"\",\n    h=1\n)","ef31433e":"sir_model_fitting('India')","9fad9f51":"sir_model_fitting('China')","805facea":"sir_model_fitting('Italy')","0b032a30":"# Grouping by growth factor\n<font color = 'blue'>\n    \n* The number of confirmed cases is increasing in many countries, but there are two of countries. In a first-type country, growth factor is larger than 1 and the number of cases is rapidly increasing. In a second-type country, growth factor is less than 1.","93069b22":"# **SIR Model**\n<font color = 'blue'>\n    \n- An SIR model is an epidemiological model that computes the theoretical number of people infected with a contagious illness in a closed population over time. The name of this class of models derives from the fact that they involve coupled equations relating the number of susceptible people S(t), number of people infected I(t), and number of people who have recovered R(t). One of the simplest SIR models is the Kermack-McKendrick model.\n             \n![5cacd542832adc4f625fae17_SIR-Analysis-illustration.png](attachment:5cacd542832adc4f625fae17_SIR-Analysis-illustration.png)\n ","cb936917":"<font color = 'blue'>\n* India seems to get its peak around the first week of May after that the number of cases will slow down.","2239047c":"## The number of cases in Japan","5aed3087":"## Group 2: Stopping, growth factor $<$ 1 for the last 7 days","9f0732d5":"## Calculate growth factor\n<font color = 'blue'>\n\nWhere $C$ is the number of confirmed cases,  \n$$\\mathrm{Growth\\ Factor} = \\cfrac{\\Delta \\mathrm{C}_{n}}{\\Delta \\mathrm{C}_{n-1}}$$ <\/font>","fe2591f2":"# Data Cleening: the number of cases\nNote: \"Infected\" = \"Confirmed\" - \"Deaths\" - \"Recovered\"","4b5d1f53":"### Non-dimensional SIR model\n<font color = 'blue'>\n    \n\nTo simplify the model, we will remove the units of the variables from ODE.\n\nSet $(S, I, R) = N \\times (x, y, z)$ and $(T, \\beta, \\gamma) = (\\tau t, \\tau^{-1} \\rho, \\tau^{-1} \\sigma)$.  \n\nThis results in the ODE  \n$\\frac{\\mathrm{d}x}{\\mathrm{d}t}= - \\rho x y$  \n$\\frac{\\mathrm{d}y}{\\mathrm{d}t}= \\rho x y - \\sigma y$  \n$\\frac{\\mathrm{d}z}{\\mathrm{d}t}= \\sigma y$  \n\nWhere $N$ is the total population and $\\tau$ is a coefficient ([min], is an integer to simplify).  \n\nThe range of variables and parameters:  \n$0 \\leq (x, y, z, \\rho, \\sigma) \\leq 1$  \n$1\\leq \\tau \\leq 1440$  \n\nBasic reproduction number, Non-dimentional parameter, is defined as  \n$R_0 = \\rho \\sigma^{-1} = \\beta \\gamma^{-1}$  \n\nEstimated Mean Values of $R_0$:  \n$R_0$ means \"the average number of secondary infections caused by an infected host\" ([Infection Modeling \u2014 Part 1](https:\/\/towardsdatascience.com\/infection-modeling-part-1-87e74645568a)).  \n(Secondary data: [Van den Driessche, P., & Watmough, J. (2002).](https:\/\/www.ncbi.nlm.nih.gov\/pmc\/articles\/PMC6002118))  \n2.06: Zika in South America, 2015-2016  \n1.51: Ebola in Guinea, 2014  \n1.33: H1N1 influenza in South Africa, 2009  \n3.5 : SARS in 2002-2003  \n1.68: H2N2 influenza in US, 1957  \n3.8 : Fall wave of 1918 Spanish influenza in Genova  \n1.5 : Spring wave of 1918 Spanish influenza in Genova  \n\nWhen $x=\\frac{1}{R_0}$, $\\frac{\\mathrm{d}y}{\\mathrm{d}t}=0$.\n<!--This means that the max value of confirmed ($=y+z$) is $1-\\frac{1}{R_0}$.-->","74e73e3f":"## Group 3: At a crossroad, the others","9ea0837f":"# **Functions**","ee0292e5":"# **Total Population**\n<font color = 'blue'>\n    \n- The highly populated country has more chances to get infected quickly. The following are top populated countries across the globe.<font>\n\n","0f25699c":"## Grouping countires based on growth factor\n<font color = 'blue'>\n    \n\n* Outbreaking: growth factor $>$ 1 for the last 7 days\n* Stopping: growth factor $<$ 1 for the last 7 days\n* At a crossroad: the others","a2a276cb":"# **Raw data: the number of cases**","87764cea":"# Trend analysis\n<font color = 'blue'>\n    \n* We will use the data in the most cirical country where the number of days with growth factor $>$ 1 is the longest.","c298ed6a":"* # Most critical country according to growth factor","568827bc":"## The number of days go out","58b83383":"# Remark","1e76396d":"<font color = 'blue'>\n    \n\u2022\tChina got the peak after 30 days. Compared to china India will get its peak after 50 days of its first case which shows a better result. ","707e3967":"# **The number of the day goes out**\n<font color = 'blue'>\n \n- There are different age groups people who go outside on different days. So here we have analyzed which age group has most days outside the home. The more they go outside can have more chances to infected by the COVID-19 virus. <font>","2578722e":"## Group 1: Outbreaking, growth factor $>$ 1 for the last 7 days","315ea891":"![cv.jfif](attachment:cv.jfif)\n<font color='blue'>\n    \n# Contents\n\n\n- Population Wise Analysis\n- The number of days go out (template data)\n- Functions\n- Raw data: the number of cases\n- Data Cleaning: the number of cases\n- SIR\n- Grouping by growth factor\n- Calculate growth factor\n- Grouping countires based on growth factor\n- Group 1: Outbreaking, growth factor >> 1 for the last 7 days\n- Group 2: Stopping, growth factor << 1 for the last 7 days\n- Group 3: At a crossroad, the others\n- Trend analysis\n- Most critical country\n- Non-dimensional SIR model\n\n# Introduction:\n\n- Coronavirus disease 2019 (COVID-19) is an infectious disease caused by severe acute respiratory syndrome coronavirus 2 (SARS-CoV-2). The disease was first identified in December 2019 in Wuhan, the capital of China's Hubei province, and has since spread globally, resulting in the ongoing 2019\u201320 coronavirus pandemic. Common symptoms include fever, cough, and shortness of breath. Other symptoms may include fatigue, muscle pain, diarrhea, sore throat, loss of smell and abdominal pain. While the majority of cases result in mild symptoms, some progress to viral pneumonia and multi-organ failure. As of 13 April 2020, more than 1.8 million cases have been reported in more than 200 countries and territories, resulting in more than 114090 deaths. More than 421497 people have recovered.\n\n\n# Transmission:\n\n- Some details about how the disease is spread are still being determined. The WHO and CDC say it is primarily spread during close contact and by small droplets produced when people cough, sneeze or talk; with close contact being within 1\u20133 m (3 ft. 3 in\u20139 ft. 10 in). A study in Singapore found that uncovered coughing can lead to droplets traveling up to 4.5 meters (15 feet). A second study, produced during the 2020 pandemic, found that advice on the distance droplets could travel might be based on old 1930s research which ignored the protective effect and speed of the warm moist outbreath surrounding the droplets; it advised that droplets can travel around 7\u20138 meters. \n<\/font>\n\n\n","0a03505e":"# Population catagory of different age group"}}