{"cell_type":{"0c935631":"code","5409811c":"code","cf452556":"code","c334054e":"code","f3089589":"code","88ebc35e":"code","71a53af5":"code","010ae508":"code","9392e681":"code","586c5daa":"code","63a5d3bf":"code","56be152f":"code","5ea74ec3":"code","e0cddc50":"code","dce61c6d":"code","9844f9ea":"code","70172d05":"code","883c1d7d":"code","89977847":"code","5aa5aecc":"code","35b17a21":"code","8f7da1f6":"code","0d3524ce":"code","25dc991a":"code","b94d4fbe":"code","4e958cb1":"markdown","87e1cb8a":"markdown","849f192c":"markdown","6d61cabf":"markdown","4a5fc02b":"markdown","dc73b08f":"markdown","283d7cec":"markdown","591f7f89":"markdown","008c3d66":"markdown","4ce68f10":"markdown","da1f17fa":"markdown","67f427a0":"markdown"},"source":{"0c935631":"import numpy as np\nimport math\nimport random\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n\nmatplotlib.rc('figure', max_open_warning = 0)\n\nunited_states_map = mpimg.imread(\"..\/input\/images\/united_states_map.png\")\ndef show_cities(path, w=12, h=8):\n    \"\"\"Plot a TSP path overlaid on a map of the US States & their capitals.\"\"\"\n    if isinstance(path, dict):      path = list(path.values())\n    if isinstance(path[0][0], str): path = [ item[1] for item in path ]    \n    plt.imshow(united_states_map)    \n    for x0, y0 in path:\n        plt.plot(x0, y0, 'y*', markersize=15)  # y* = yellow star for starting point        \n    plt.axis(\"off\")\n    fig = plt.gcf()\n    fig.set_size_inches([w, h])\n\n    \ndef show_path(path, starting_city=None, w=12, h=8):\n    \"\"\"Plot a TSP path overlaid on a map of the US States & their capitals.\"\"\"\n    if isinstance(path, dict):      path = list(path.values())\n    if isinstance(path[0][0], str): path = [ item[1] for item in path ]\n    \n    starting_city = starting_city or path[0]\n    x, y = list(zip(*path))\n    # (x0, y0) = starting_city\n    plt.imshow(united_states_map)\n    # plt.plot(x0, y0, 'y*', markersize=15)  # y* = yellow star for starting point\n    plt.plot(x + x[:1], y + y[:1])  # include the starting point at the end of path\n    plt.axis(\"off\")\n    fig = plt.gcf()\n    fig.set_size_inches([w, h])\n    \n    \ndef polyfit_plot(x,y,deg, **kwargs):\n    coefficients = np.polyfit(x,y,deg,**kwargs)\n    poly  = np.poly1d(coefficients)\n    new_x = np.linspace(x[0], x[-1])\n    new_y = poly(new_x)\n    plt.plot(x, y, \"o\", new_x, new_y)\n    plt.xlim([x[0]-1, x[-1] + 1 ])\n    \n    terms = []\n    for p, c in enumerate(reversed(coefficients)):\n        term = str(round(c,1))\n        if p == 1: term += 'x'\n        if p >= 2: term += 'x^'+str(p)\n        terms.append(term)        \n    plt.title(\" + \".join(reversed(terms)))    ","5409811c":"import string\ndef create_cities(size, max_x=1000, max_y=1000, image=None, color=1, border=30):\n    if (image is not None):\n        max_x = image.shape[0] - 1 - border*2\n        max_y = image.shape[1] - 1 - border*2\n    cities = {}\n    while len(cities) <= size:\n        name = ''.join(random.choices(string.ascii_lowercase, k=10))\n        x = round( border + random.random() * max_x,  1)\n        y = round( border + random.random() * max_y,  1)\n        if (image is not None) and not all( image[int(x)][int(y)] == color ): continue\n        cities[(int(x),int(y))] = ( name, (y,x) )               \n    return list(cities.values())\n\ncities = create_cities(256, image=united_states_map)\nprint(cities[:5])\nshow_cities(cities)","cf452556":"# Source: https:\/\/www.kaggle.com\/jamesmcguigan\/ant-colony-optimization-algorithm\/\nimport time\nfrom itertools import chain\nfrom typing import Any, Callable, List, Tuple, Union\n\nimport numpy as np\nimport random\n\n\n\nclass AntColonySolver:\n    def __init__(self,\n                 cost_fn: Callable[[Any,Any], Union[float,int]] = None,\n                 \n                 time=0,                  # run for a fixed amount of time\n                 min_time=0,              # minimum runtime\n                 timeout=0,               # maximum time in seconds to run for\n                 stop_factor=2,           # how many times to redouble effort after new new best path\n                 min_round_trips=4,       # minimum number of round trips before stopping\n                 max_round_trips=0,       # maximum number of round trips before stopping                 \n                 min_ants=0,              # Total number of ants to use\n                 max_ants=0,              # Total number of ants to use\n                 \n                 ant_count=1024,          # this is close to the optimal number for numpy performance\n                 ant_speed=1,             # how many steps do ants travel per epoch\n\n                 distance_power=1,        # power to which distance affects pheromones                 \n                 pheromone_power=1.25,    # power to which differences in pheromones are noticed\n                 decay_power=0,           # how fast do pheromones decay\n                 reward_power=0,          # relative pheromone reward based on best_path_length\/path_length \n                 best_path_smell=2,       # queen multiplier for pheromones upon finding a new best path                  \n                 start_smell=0,           # amount of starting pheromones [0 defaults to `10**self.distance_power`]\n\n                 verbose=False,\n\n    ):\n        self.cost_fn         = cost_fn or self.distance\n        self.time            = int(time)\n        self.min_time        = int(min_time)\n        self.timeout         = int(timeout)\n        self.stop_factor     = float(stop_factor)\n        self.min_round_trips = int(min_round_trips)\n        self.max_round_trips = int(max_round_trips)\n        self.min_ants        = int(min_ants)\n        self.max_ants        = int(max_ants)\n    \n        self.ant_count       = int(ant_count)\n        self.ant_speed       = int(ant_speed)\n        \n        self.distance_power  = float(distance_power)     \n        self.pheromone_power = float(pheromone_power)\n        self.decay_power     = float(decay_power)\n        self.reward_power    = float(reward_power)\n        self.best_path_smell = float(best_path_smell)\n        self.start_smell     = float(start_smell or 10**self.distance_power)\n        \n        self.verbose         = int(verbose)\n        self._initalized     = False\n        \n        if self.min_round_trips and self.max_round_trips: self.min_round_trips = min(self.min_round_trips, self.max_round_trips)\n        if self.min_ants and self.max_ants:               self.min_ants        = min(self.min_ants, self.max_ants)\n\n    \n    @staticmethod\n    def distance(xy1, xy2) -> float:\n        if isinstance(xy1[0], str): xy1 = xy1[1]; xy2 = xy2[1];               # if xy1 == (\"Name\", (x,y))\n        return math.sqrt( (xy1[0]-xy2[0])**2 + (xy1[1]-xy2[1])**2 )\n\n    @staticmethod\n    def path_distance(path) -> int:\n        if isinstance(path, dict):      path = list(path.values())            # if path == {\"Name\": (x,y)}\n        if isinstance(path[0][0], str): path = [ item[1] for item in path ]   # if path == (\"Name\", (x,y))\n        return int(sum(\n            [ distance(path[i],  path[i+1]) for i in range(len(path)-1) ]\n          + [ distance(path[-1], path[0]) ]                                   # include cost of return journey\n        ))            \n    \n    \n    def solve_initialize(\n            self,\n            problem_path: List[Any],\n    ) -> None:\n        ### Cache of distances between nodes\n        self.distances = {\n            source: {\n                dest: self.cost_fn(source, dest)\n                for dest in problem_path\n            }\n            for source in problem_path\n        }\n\n        ### Cache of distance costs between nodes - division in a tight loop is expensive\n        self.distance_cost = {\n            source: {\n                dest: 1 \/ (1 + self.distances[source][dest]) ** self.distance_power\n                for dest in problem_path\n            }\n            for source in problem_path\n        }\n\n        ### This stores the pheromone trail that slowly builds up\n        self.pheromones = {\n            source: {\n                # Encourage the ants to start exploring in all directions and furthest nodes\n                dest: self.start_smell\n                for dest in problem_path\n            }\n            for source in problem_path\n        }\n\n        ### Heuristic Exports\n        self.ants_used   = 0\n        self.epochs_used = 0\n        self.round_trips = 0\n        \n        self._initalized = True        \n\n\n    def solve(self,\n              problem_path: List[Any],\n              restart=False,\n    ) -> List[Tuple[int,int]]:\n\n        if restart or not self._initalized:\n            self.solve_initialize(problem_path)\n\n        ### Reset Heuristics\n        self.ants_used   = 0\n        self.epochs_used = 0\n        self.round_trips = 0\n            \n        ### Sanitise input parameters\n        if self.ant_count <= 0:\n            self.ant_count = len(problem_path)\n        if self.ant_speed <= 0:\n            self.ant_speed = np.median(list(chain(*[ d.values() for d in self.distances.values() ]))) \/\/ 5\n        self.ant_speed = int(max(1,self.ant_speed))\n        \n        ### Here come the ants!\n        ants = {\n            \"distance\":    np.zeros((self.ant_count,)).astype('int32'),\n            \"path\":        [ [ problem_path[0] ]   for n in range(self.ant_count) ],\n            \"remaining\":   [ set(problem_path[1:]) for n in range(self.ant_count) ],\n            \"path_cost\":   np.zeros((self.ant_count,)).astype('int32'),\n            \"round_trips\": np.zeros((self.ant_count,)).astype('int32'),\n        }\n\n        best_path       = None\n        best_path_cost  = np.inf\n        best_epochs     = []\n        epoch           = 0\n        time_start      = time.perf_counter()\n        while True:\n            epoch += 1\n\n            ### Vectorized walking of ants\n            # Small optimization here, testing against `> self.ant_speed` rather than `> 0` \n            #       avoids computing ants_arriving in the main part of this tight loop\n            ants_travelling = (ants['distance'] > self.ant_speed)\n            ants['distance'][ ants_travelling ] -= self.ant_speed\n            if all(ants_travelling):\n                continue  # skip termination checks until the next ant arrives\n            \n            ### Vectorized checking of ants arriving\n            ants_arriving       = np.invert(ants_travelling)\n            ants_arriving_index = np.where(ants_arriving)[0]\n            for i in ants_arriving_index:\n\n                ### ant has arrived at next_node\n                this_node = ants['path'][i][-1]\n                next_node = self.next_node(ants, i)\n                ants['distance'][i]  = self.distances[ this_node ][ next_node ]\n                ants['remaining'][i] = ants['remaining'][i] - {this_node}\n                ants['path_cost'][i] = ants['path_cost'][i] + ants['distance'][i]\n                ants['path'][i].append( next_node )\n\n                ### ant has returned home to the colony\n                if not ants['remaining'][i] and ants['path'][i][0] == ants['path'][i][-1]:\n                    self.ants_used  += 1\n                    self.round_trips = max(self.round_trips, ants[\"round_trips\"][i] + 1)\n\n                    ### We have found a new best path - inform the Queen\n                    was_best_path = False\n                    if ants['path_cost'][i] < best_path_cost:\n                        was_best_path  = True\n                        best_path_cost = ants['path_cost'][i]\n                        best_path      = ants['path'][i]\n                        best_epochs   += [ epoch ]\n                        if self.verbose:\n                            print({\n                                \"path_cost\":   int(ants['path_cost'][i]),\n                                \"ants_used\":   self.ants_used,\n                                \"epoch\":       epoch,\n                                \"round_trips\": ants['round_trips'][i] + 1,\n                                \"clock\":       int(time.perf_counter() - time_start),\n                            })\n\n                    ### leave pheromone trail\n                    # doing this only after ants arrive home improves initial exploration\n                    #  * self.round_trips has the effect of decaying old pheromone trails\n                    # ** self.reward_power = -3 has the effect of encouraging ants to explore longer routes\n                    #                           in combination with doubling pheromone for best_path\n                    reward = 1\n                    if self.reward_power: reward *= ((best_path_cost \/ ants['path_cost'][i]) ** self.reward_power)\n                    if self.decay_power:  reward *= (self.round_trips ** self.decay_power)\n                    for path_index in range( len(ants['path'][i]) - 1 ):\n                        this_node = ants['path'][i][path_index]\n                        next_node = ants['path'][i][path_index+1]\n                        self.pheromones[this_node][next_node] += reward\n                        self.pheromones[next_node][this_node] += reward\n                        if was_best_path:\n                            # Queen orders to double the number of ants following this new best path                            \n                            self.pheromones[this_node][next_node] *= self.best_path_smell\n                            self.pheromones[next_node][this_node] *= self.best_path_smell\n\n\n                    ### reset ant\n                    ants[\"distance\"][i]     = 0\n                    ants[\"path\"][i]         = [ problem_path[0] ]\n                    ants[\"remaining\"][i]    = set(problem_path[1:])\n                    ants[\"path_cost\"][i]    = 0\n                    ants[\"round_trips\"][i] += 1\n\n\n            ### Do we terminate?\n            \n            # Always wait for at least 1 solutions (note: 2+ solutions are not guaranteed)\n            if not len(best_epochs): continue \n            \n            # Timer takes priority over other constraints\n            if self.time or self.min_time or self.timeout:\n                clock = time.perf_counter() - time_start\n                if self.time:\n                    if clock > self.time: break\n                    else:                 continue\n                if self.min_time and clock < self.min_time: continue\n                if self.timeout  and clock > self.timeout:  break\n            \n            # First epoch only has start smell - question: how many epochs are required for a reasonable result?\n            if self.min_round_trips and self.round_trips <  self.min_round_trips: continue        \n            if self.max_round_trips and self.round_trips >= self.max_round_trips: break\n\n            # This factor is most closely tied to computational power                \n            if self.min_ants and self.ants_used <  self.min_ants: continue        \n            if self.max_ants and self.ants_used >= self.max_ants: break            \n            \n            # Lets keep redoubling our efforts until we can't find anything more\n            if self.stop_factor and epoch > (best_epochs[-1] * self.stop_factor): break\n                                \n            # Nothing else is stopping us: Queen orders the ants to continue!      \n            if True: continue\n            \n            \n            \n        ### We have (hopefully) found a near-optimal path, report back to the Queen\n        self.epochs_used = epoch\n        self.round_trips = np.max(ants[\"round_trips\"])\n        return best_path\n\n\n    def next_node(self, ants, index):\n        this_node   = ants['path'][index][-1]\n\n        weights     = []\n        weights_sum = 0\n        if not ants['remaining'][index]: return ants['path'][index][0]  # return home\n        for next_node in ants['remaining'][index]:\n            if next_node == this_node: continue\n            reward = (\n                    self.pheromones[this_node][next_node] ** self.pheromone_power\n                    * self.distance_cost[this_node][next_node]  # Prefer shorter paths\n            )\n            weights.append( (reward, next_node) )\n            weights_sum   += reward\n\n        # Pick a random path in proportion to the weight of the pheromone\n        rand = random.random() * weights_sum\n        for (weight, next_node) in weights:\n            if rand > weight: rand -= weight\n            else:             break\n        return next_node\n            \n        \ndef AntColonyRunner(cities, verbose=False, plot=False, label={}, algorithm=AntColonySolver, **kwargs):\n    solver     = algorithm(cost_fn=distance, verbose=verbose, **kwargs)\n    start_time = time.perf_counter()\n    result     = solver.solve(cities)\n    stop_time  = time.perf_counter()\n    if label: kwargs = { **label, **kwargs }\n        \n    for key in ['verbose', 'plot', 'animate', 'label', 'min_time', 'max_time']:\n        if key in kwargs: del kwargs[key]\n    print(\"N={:<3d} | {:5.0f} -> {:4.0f} | {:4.0f}s | ants: {:5d} | trips: {:2d} | \"\n          .format(len(cities), path_distance(cities), path_distance(result), (stop_time - start_time), solver.ants_used, solver.round_trips)\n          + \" \".join([ f\"{k}={v}\" for k,v in kwargs.items() ])\n    )\n    if plot:\n        show_path(result)\n    return result\n\n\ndistance      = AntColonySolver.distance\npath_distance = AntColonySolver.path_distance","c334054e":"from typing import Dict\nfrom sklearn.cluster import KMeans\nfrom sklearn.neighbors import NearestNeighbors\nfrom itertools import chain, product, combinations\nclass KmeansAntColonySolver(AntColonySolver):\n    def __init__(self, \n                 animate: Callable=None,\n                 \n                 cluster_factor=1.05,           # Multiple for subdividng the problem\n                 random_factor=1,               # Greate random subgroups - this doesn't work\n                 distance_power_multiple=1.5,   # Increase distance_power before final solve\n                 intercity_merge=0,             # For each pair of clusters, find a loop between the N nearest neighbours of each\n                 intercity_loop=0,              # Construct loops between clusters using N nearest neighbours for each cluster                 \n                 intercity_random=0,            # Construct loops between random members of each cluster\n\n                 start_smell=2,\n                 start_smell_normalization=0.5,\n                 min_round_trips=2,\n                 max_round_trips=0,             # performance shortcut\n                 best_path_smell=1.25,          # 2*1 + 1.25*0.5 work best\n                 best_path_smell_multiple=0.5,  # Increase best_path_smell before final solve                 \n                 min_clusters=2,\n                 min_cluster_size=3,\n                 \n                 **kwargs\n    ):\n        self.min_clusters         = min_clusters\n        self.min_cluster_size     = min_cluster_size\n\n        \n        self.animate              = animate\n        self.intercity_merge      = intercity_merge        \n        self.intercity_loop       = intercity_loop\n        self.intercity_random     = intercity_random\n        self.cluster_factor       = cluster_factor\n        self.random_factor        = random_factor\n        self.distance_power_multiple   = distance_power_multiple\n        self.best_path_smell_multiple  = best_path_smell_multiple        \n        self.start_smell_normalization = start_smell_normalization\n        \n        \n        self.kwargs = { \n            \"start_smell\":     start_smell, \n            \"min_round_trips\": min_round_trips,             \n            \"max_round_trips\": max_round_trips, \n            \"best_path_smell\": best_path_smell, \n            **kwargs \n        }        \n        super().__init__(**self.kwargs) \n    \n    \n    def get_numeric_path(self, problem_path: List[Any]) -> List[Tuple[int,int]]:\n        # KMeans requires: List[Tuple[int,int]]\n        numeric_path = list(problem_path)\n        try:\n            if isinstance(numeric_path, dict):      numeric_path = list(numeric_path.values())            # if path == {\"Name\": (x,y)}\n            if isinstance(numeric_path[0][0], str): numeric_path = [ item[1] for item in numeric_path ]   # if path == (\"Name\", (x,y))\n        except: pass\n        return numeric_path\n\n\n    def group_by_random(self, problem_path: List[Any], n_clusters) -> Dict[int, List[Any]]:\n            clusters = [\n                random.sample(problem_path, math.ceil(len(problem_path) \/ n_clusters) )\n                for n in range(int(n_clusters))\n            ]    \n            return clusters        \n        \n    \n    def group_by_kmeans(self, problem_path: List[Any], n_clusters) -> Dict[int, List[Any]]:        \n            if n_clusters == 1: return [ problem_path ]\n            \n            # Group the cities into KMeans cluster groups of increasing size\n            numeric_path = self.get_numeric_path(problem_path)            \n            cluster_ids  = KMeans(n_clusters=n_clusters).fit_predict(numeric_path)\n            clusters = [\n                list({ problem_path[n] for n in range(len(problem_path)) if cluster_ids[n] == cluster_id })\n                for cluster_id in np.unique(cluster_ids)\n            ]\n            return clusters\n\n        \n    def centroid(self, problem_path: List[Tuple[Any]]) -> Tuple[int,int]:\n        numeric_path = self.get_numeric_path(problem_path)\n        return tuple(np.median(numeric_path, axis=0))        \n        \n    # Returns the two nearest neighbours to the centeroid for each cluster         \n    def nearest_neighbors(self, clusters: List[List[Any]], n_neighbors=2) -> List[List[Any]]:\n        center_point = self.centroid(chain(*clusters))\n        clusters_of_nearest = []\n        for cluster in clusters:\n            numeric_path   = self.get_numeric_path(cluster)\n            nn             = NearestNeighbors(n_neighbors).fit(numeric_path)\n            dist, indicies = nn.kneighbors([center_point])  # inputs and outputs are both arrays\n            clusters_of_nearest.append([ cluster[i] for i in indicies[0] ])\n        return clusters_of_nearest            \n        \n        \n    def normalize_pheromones(self, norm: float=None):\n        norm   = norm or self.start_smell\n        mean   = np.mean(list(chain(*[ d.values() for d in self.pheromones.values() ])))\n        weight = norm \/ mean\n        for source in self.pheromones.keys():\n            for dest in self.pheromones.keys():           \n                self.pheromones[source][dest] *= norm\n                self.pheromones[source][dest] += norm * self.start_smell_normalization\n\n                \n    def solve(self,\n              problem_path: List[Any],\n              restart=True,\n    ) -> List[Tuple[int,int]]:\n        # Initialize the Solver - preserve the pheromone trail between runs        \n        self.solve_initialize(problem_path)\n\n        # Break the Travelling Salesman problem down into local clusters of nodes, as detected by KMeans\n        # Iteratively decrease the number of clusters, until we are back at the starting problem\n        \n        n_clusters = int( len(problem_path) \/ ( self.cluster_factor * self.random_factor ) )\n        random_clusters = self.group_by_random(problem_path, self.random_factor)\n        \n        results_plot = {}\n        while n_clusters > self.min_clusters:\n            \n            results_plot[n_clusters] = []\n            results_plot[f\"{n_clusters}_loop\"]  = []\n            results_plot[f\"{n_clusters}_merge\"] = []\n            \n            for random_cluster in random_clusters:\n                kmeans_clusters = self.group_by_kmeans(random_cluster, int(n_clusters))                \n                kmeans_clusters = [ cluster for cluster in kmeans_clusters if len(cluster) >= self.min_cluster_size ]\n                    \n                # Break the map down into kmeans subclusters and create a heuristic pheromone trail\n                for kmeans_cluster in kmeans_clusters:\n                    if len(kmeans_cluster) < self.min_cluster_size: continue\n                    results = self.solve_subproblem(kmeans_cluster, restart=False)\n                    results_plot[n_clusters] += [ results ]\n\n                if len(kmeans_clusters) <= 1: continue  # Can't do intercity with a single cluster\n\n                # Construct a loop between clusters, using the N closest members to the centeroid from each cluster\n                if self.intercity_loop:\n                    intercity = self.nearest_neighbors(kmeans_clusters, self.intercity_loop)\n                    intercity = list(chain(*intercity))                    \n                    results   = self.solve_subproblem(intercity, restart=False)\n                    results_plot[f\"{n_clusters}_loop\"] += [ results ]                \n\n                if self.intercity_random:\n                    intercity = [ random.sample(cluster, max(self.intercity_random, len(cluster)-1)) for cluster in kmeans_clusters ]\n                    intercity = list(chain(*intercity))                    \n                    results   = self.solve_subproblem(intercity, restart=False)\n                    results_plot[f\"{n_clusters}_loop\"] += [ results ]                \n                    \n                # For each pair of clusters, find the optimal path to join them using their N nearest neighbours\n                if self.intercity_merge:                    \n                    for clusters in combinations(kmeans_clusters, 2):\n                        intercity = self.nearest_neighbors(clusters, self.intercity_merge)\n                        intercity = list(chain(*intercity))\n                        results   = self.solve_subproblem(intercity, restart=False)\n                        results_plot[f\"{n_clusters}_merge\"] += [ results ]                \n                    \n\n            # self.normalize_pheromones()\n            n_clusters = int( (n_clusters) \/\/ ( self.cluster_factor * self.random_factor ) )\n\n        # Display the growth of clusters             \n        if callable(self.animate):\n            self.animate_results(results_plot, problem_path)\n            \n        # Now solve the original problem  \n        for key, value in self.kwargs.items(): \n            if hasattr(self, key): setattr(self, key, value)\n\n        self.normalize_pheromones()\n        self.distance_power  *= self.distance_power_multiple\n        self.best_path_smell *= self.best_path_smell_multiple\n        self.round_trips = 0\n        self.ant_count   = 4 * len(problem_path)\n        #self.min_ants    = self.ants_used + len(problem_path) ** 2 \/ 2\n        self.max_ants    = self.ants_used + len(problem_path) ** 2 * 2\n        result = super().solve(problem_path)\n\n        if callable(self.animate):\n            plt.figure()        \n            self.animate(result)\n            \n        return result\n    \n    \n    def solve_subproblem(self,\n              problem_path: List[Any],\n              restart=True,\n    ) -> List[Tuple[int,int]]:\n        verbose = self.verbose\n        self.round_trips = 0\n        self.ant_count   = 4 * len(problem_path)\n        #self.min_ants    = 0 # len(problem_path) ** 2 \/ 2\n        #self.max_ants    = 0 # self.ants_used + len(problem_path) ** 2           \n        \n        time_start    = time.perf_counter()\n        self.verbose  = False\n        result        = super().solve(problem_path, restart=False)\n        # self.normalize_pheromones_path(problem_path, 10000)\n        self.verbose  = verbose\n        if self.verbose: \n            print(\n                f'solve({len(problem_path)})', path_distance(problem_path), '->', path_distance(result), \n                { \"ant_count\": self.ant_count, \"ants_used\": self.ants_used, \"round_trips\": self.round_trips,  \"time\": round(time.perf_counter() - time_start, 1) }\n             )\n        return result \n    \n\n    def animate_results(self, results_plot: Dict[int, List[Any]], problem_path=[]) -> None:\n        results_plot = { k:v for k,v in results_plot.items() if len(v) }  # remove empty results\n        if not len(results_plot):      return                \n        if not callable(self.animate): return        \n            \n        grid_cols = max(4, math.ceil(np.sqrt(len(results_plot))))\n        grid_cols = min(grid_cols,len(results_plot))\n        grid_rows = math.ceil(len(results_plot)\/grid_cols)\n        grid_size = ( grid_rows, grid_cols )\n        figure, axes = plt.subplots(*grid_size, figsize=(grid_size[0]*10, grid_size[1]*10))\n        plt.tight_layout(pad=5)\n        try:\n            for ax in chain(*axes): ax.axis('off')\n        except: pass\n\n        for index, N in enumerate(results_plot.keys()):\n            plt.subplot(*grid_size, index+1)\n            unique_lengths = list(np.unique(list(map(len,results_plot[N]))))\n            plt.title(f'{len(problem_path)}\/{N} = {len(results_plot[N])} clusters')\n            for results in results_plot[N]:\n                self.animate(results)\n        #plt.close(figure)\n    \n    \n    \ndef KmeansAntColonyRunner(cities, animate=False, **kwargs):\n    if animate is True: animate=show_path\n    kwargs = { \"animate\": animate, \"algorithm\": KmeansAntColonySolver, **kwargs }\n    return AntColonyRunner(cities, **kwargs)","f3089589":"N = 32\nresult = KmeansAntColonyRunner(cities[:N], verbose=True, animate=True, cluster_factor=2)","88ebc35e":"N = 32\nresult = KmeansAntColonyRunner(cities[:N], verbose=False, animate=True)","71a53af5":"N = 32\nresult = KmeansAntColonyRunner(cities[:N], verbose=False, animate=True)","010ae508":"N = 64\nresult = KmeansAntColonyRunner(cities[:N], verbose=False, animate=True)","9392e681":"N = 128\nresult = KmeansAntColonyRunner(cities[:N], verbose=False, animate=True)","586c5daa":"N = 256\nresult = KmeansAntColonyRunner(cities[:N], verbose=False, animate=True)","63a5d3bf":"N = 32\nresult = KmeansAntColonyRunner(cities[:N], verbose=False, animate=True, intercity_loop=2)","56be152f":"N = 32\nresult = KmeansAntColonyRunner(cities[:N], verbose=False, animate=True, intercity_random=2)","5ea74ec3":"N = 32\nresult = KmeansAntColonyRunner(cities[:N], verbose=False, animate=True, intercity_merge=2)","e0cddc50":"import pandas as pd\nresults = {}\nfor N in [16,32,64]:\n    results[N] = [ KmeansAntColonyRunner(cities[:N]) for i in range(10) ]\n    print()\n    \nresults_stats = {\n    N: pd.Series([ path_distance(path) for path in results[N] ]).describe()\n    for N in results.keys()\n}\npd.DataFrame(results_stats).T.round(1)","dce61c6d":"N=32","9844f9ea":"for N in [32,64]:\n    for cluster_factor in [1.02, 1.03, 1.04, 1.05, 1.06, 1.07, 1.08, 1.09, 1.1, 1.25, 1.5, 1.75, 2, 2.5, 3, 4, 8, 16]:\n        result = KmeansAntColonyRunner(cities[:N], verbose=False, cluster_factor=cluster_factor)\n    print()","70172d05":"# Adding in `random_factor` clustering doesn't work\nfor N in [32,64]:\n    for random_factor in range(1,10):\n        result = KmeansAntColonyRunner(cities[:N], verbose=False, random_factor=random_factor)\n    print()","883c1d7d":"for N in [32,64]:\n    for distance_power_multiple in [0.0, 0.5, 1.0, 1.5, 2, 3, 10]:\n        result = KmeansAntColonyRunner(cities[:N], verbose=False, distance_power_multiple=distance_power_multiple)\n    print()","89977847":"for N in [32,64]:\n    for best_path_smell in [1.0, 1.25, 2.0]:\n        for best_path_smell_multiple in [0, 0.25, 0.5, 0.75, 1, 1.25, 2.0]:    \n            result = KmeansAntColonyRunner(cities[:N], best_path_smell=best_path_smell, best_path_smell_multiple=best_path_smell_multiple)\n        print()\n    print()","5aa5aecc":"for N in [32,64]:\n    for start_smell in [1, 2, 16, 128]:    \n        for start_smell_normalization in [-0.5, -0.25, 0, 0.25, 0.5, 1, 1.5, 2, 16, 128]:    \n            result = KmeansAntColonyRunner(cities[:N], start_smell=start_smell, start_smell_normalization=start_smell_normalization)\n        print()\n    print()","35b17a21":"for N in [32,64]:\n    for min_clusters in [1,2,3,4,8]:    \n        for min_cluster_size in [1,2,3,4,8]:        \n            result = KmeansAntColonyRunner(cities[:N], min_clusters=min_clusters, min_cluster_size=min_cluster_size)\n        print()        \n    print()        ","8f7da1f6":"for N in [32,64]:\n    for min_round_trips in [1,2,3,4,5,6,8,16,32]:    \n        result = KmeansAntColonyRunner(cities[:N], min_round_trips=min_round_trips)\n    print()","0d3524ce":"for N in [32,64]:\n    for intercity_merge in [0,2]:       \n        for intercity_loop in [0,1,2]:\n            for intercity_random in [0,1,2]:    \n                result = KmeansAntColonyRunner(cities[:N], intercity_merge=intercity_merge, intercity_loop=intercity_loop, intercity_random=intercity_random)  \n            print()\n        print()\n    print()","25dc991a":"for N in [4,8,16,32,64,128,256,512]:\n    plt.figure()\n    plt.title(f'N={N}')\n    result = AntColonyRunner(cities[:N], timeout=60*60, plot=True)   ","b94d4fbe":"for N in [4,8,16,32,64,128,256,512,1024]:\n    plt.figure()\n    plt.title(f'N={N}')    \n    result = KmeansAntColonyRunner(cities[:N], timeout=60*60, plot=True)","4e958cb1":"# AntColonySolver","87e1cb8a":"# Map definition","849f192c":"# Using Intercity Heuristics\n\nThese are expensive, especially for larger N, and don't always improve performance","6d61cabf":"min_round_trips\n- increases minimum compute time\n- min_round_trips=4 seems to provide the best results in reasonable time","4a5fc02b":"# NP-Hard Scalability\n\nSo lets see how this performs in practice\n- It is about one order of magnitude faster: \n    - it can solve N=64   (34s) in about the same time it used to solve N=32  (27s)\n    - it can solve N=128 (179s) in about the same time it used to solve N=64 (130s)","dc73b08f":"# Utility Code","283d7cec":"# Kmeans Ant Colony Solver\n\nFuture Ideas:\n- Try doing random resampling once before converging clusters  \n- Try solving for subsets composed of a random member in each clusters\n- Try minimum n_clusters = 4\n- Sum pheromones from neighbouring nodes \n    - If there is a strong path in a neighbouring nodes, try going directly to it\n- Add in a crowd control heuristic \n    - keep track of ants currently on each edge\n    - treat this as an anti-pheromone heuristic\n    - might lead to more efficent exploration around best path\n- Use Hill Climbing or Beam Search to detangle corners ","591f7f89":"# Hyperparameter Optimization","008c3d66":"# Statistical Random Variation","4ce68f10":"## Intercity Heuristics\n- Take exponentially long times for larger N\n- sometimes the simpest solution is the best\n- `intercity_merge`\n    - `1` is expensive and worsens performance (doesn't find a round trip route)\n    - `2` is the best merge setting, but doesn't really improve results\n    - `3` is expensive and worsens performance\n- occasionally `intercity_random=1` and\/or `intercity_loop=2` will improve performance","da1f17fa":"# Visualization\n","67f427a0":"# KMeans Ant Colony Optimization\n\nThis notebook extends my previous work on the Ant Colony Optimization Algorithm\n- https:\/\/www.kaggle.com\/jamesmcguigan\/ant-colony-optimization-algorithm\n\n\nThe Ant Colony Optimization Algorithm can be extended using KMeans clustering, to solve for larger map sizes `N=64` to `N=256` which is explored in this Notebook.\n\nThe basic idea is that while Ant Colony Optimization is NP-Hard with a time complexity of `O(N^2)`, the algorithm is fast to solve for small map sizes:\n- KMeans is used to subdivide the map into small regonalized clusters, which can be quickly solved for small `N`\n- The pheromone trail is persisted between runs, which provides a heuristic for solving large maps\n- The cluster size starts off small and gradually expands\n- Each new iteration presents the simplifies subproblem of how to add a few extra nodes to an existing local map\n- The number of clusters is eventually reduced to 1: the original problem definition\n- With a prebuilt pheromone trail, the ants can usually solve large maps within a small number of round trips"}}