{"cell_type":{"d92b6466":"code","bab4a9fb":"code","3eab12ca":"code","5e57c0ae":"code","b094fecf":"code","78c5e969":"code","a75ea54f":"code","8643020f":"code","1531f629":"code","75a80ae3":"code","9b66646d":"code","32a0bc34":"code","65123b13":"code","94ef5537":"code","ee8ef5a1":"code","6d90a8fe":"code","26bf723b":"code","be36da04":"code","c6f7a6ee":"code","38eec886":"code","bff7bafd":"code","713c63b1":"code","d22a33db":"code","04ac0c5d":"code","3a994c11":"code","60dc1b58":"code","9d33c113":"code","6e0302b5":"code","ae588142":"code","67f8f7f0":"code","c2985c38":"code","22f6449e":"code","0c7a24e3":"code","7813fbdb":"code","526f6975":"code","ce64788c":"code","ec4db410":"code","2644f4c3":"code","6c3bdf8c":"code","45f29ed0":"code","d6fe90ff":"code","3f604a58":"code","87592703":"code","273030b3":"code","281f6fd8":"markdown","266f557a":"markdown","537a55d7":"markdown","b32bd143":"markdown","d522a3e4":"markdown","1a3bfe1a":"markdown","f6f59290":"markdown","26c21d38":"markdown","fc77b2c4":"markdown","8f2accf7":"markdown","17e5d3c5":"markdown","b799ce50":"markdown"},"source":{"d92b6466":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n       os.path.join(dirname, filename)\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","bab4a9fb":"import matplotlib.pyplot as plt\nimport os\nfrom PIL import Image\nimport openslide","3eab12ca":"train_df = pd.read_csv(\"\/kaggle\/input\/prostate-cancer-grade-assessment\/train.csv\").set_index('image_id')","5e57c0ae":"train_df.head(10)","b094fecf":"train_img_path = \"\/kaggle\/input\/prostate-cancer-grade-assessment\/train_images\"\nlabel_path = \"\/kaggle\/input\/prostate-cancer-grade-assessment\/train_label_masks\"\n\ntrain_img = [img for img in os.listdir(train_img_path)]\ntrain_label = [label for label in os.listdir(label_path)]\n\ntrain_img = list(sorted(train_img))\ntrain_label = list(sorted(train_label))\n\nSIZE = 300\n\ndef preprocessing_img(img):\n    slide = openslide.OpenSlide(img)\n    img = np.array(slide.get_thumbnail(size=(SIZE, SIZE)))\n    img = Image.fromarray(img)\n    img = img.resize((SIZE, SIZE))\n    img = np.array(img)\n    return img\n\nimg_array = []\nfor i in range(10):\n    img = train_img_path + \"\/\" + train_img[i]\n    img = preprocessing_img(img)\n    img_array.append(img)","78c5e969":"plt.imshow(img_array[0])","a75ea54f":"img_test = img_array[0]\nimg_test.shape","8643020f":"train_img[0]","1531f629":"isup = train_df.iloc[0]['isup_grade']","75a80ae3":"import cv2\n\ndenoise = cv2.fastNlMeansDenoisingColored(img_test,None,10,10,7,21)\n","9b66646d":"f = plt.figure(figsize=(15,15))\nf.add_subplot(2, 1, 1).set_title(f'Original Image isup = {isup}')\nplt.imshow(img_array[0], cmap = \"gray\")\nf.add_subplot(2, 1, 2).set_title(f'Filtered Image isup = {isup}')\nplt.imshow(denoise, cmap = \"gray\")\nplt.show()","32a0bc34":"def RGB2HEX(color):\n    return \"#{:02x}{:02x}{:02x}\".format(int(color[0]), int(color[1]), int(color[2]))","65123b13":"def get_image(image_path):\n    image = cv2.imread(image_path)\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    return image","94ef5537":"modified_image = cv2.resize(img_array[0], (600, 400), interpolation = cv2.INTER_AREA)\nmodified_image = modified_image.reshape(modified_image.shape[0]*modified_image.shape[1], 3)","ee8ef5a1":"from sklearn.cluster import KMeans\nfrom collections import Counter\nfrom skimage.color import rgb2lab, deltaE_cie76\n\n\nclf = KMeans(n_clusters =8)\nlabels = clf.fit_predict(modified_image)","6d90a8fe":"counts = Counter(labels)\n\ncenter_colors = clf.cluster_centers_\n# We get ordered colors by iterating through the keys\nordered_colors = [center_colors[i] for i in counts.keys()]\nhex_colors = [RGB2HEX(ordered_colors[i]) for i in counts.keys()]\nrgb_colors = [ordered_colors[i] for i in counts.keys()]\ndel counts[0]\ndel hex_colors[0]\n\nprint(counts)\nplt.figure(figsize = (8, 6))\nplt.pie(counts.values(), labels = hex_colors, colors = hex_colors)","26bf723b":"def display(comp,name,ogName = \"Original Image isup\",img = img_test):\n    f = plt.figure(figsize=(15,15))\n    f.add_subplot(2, 1, 1).set_title(f'{ogName} = {isup}')\n    plt.imshow(img, cmap = \"gray\")\n    f.add_subplot(2, 1, 2).set_title(f'{name} isup = {isup}')\n    plt.imshow(comp, cmap = \"gray\")\n    return plt.show()","be36da04":"import cv2\nimg = cv2.blur(img_test, (3, 3))\n\nkernel = [\n            [-1, -1, -1],\n            [-1, 9, -1],\n            [-1, -1, -1]\n]\n\nkernel = np.array(kernel)\n\nsharpened = cv2.filter2D(img, -1, kernel)\n\ndisplay(sharpened, \"sharpened\")","c6f7a6ee":"\nkernel = [\n            [0, 1, 0],\n            [1, -4, 1],\n            [0, 1, 0]\n]\n\nkernel = np.array(kernel)\n\nfiltered = cv2.filter2D(sharpened, -1, kernel)","38eec886":"f = plt.figure(figsize=(15,15))\nf.add_subplot(2, 1, 1).set_title(f'Original Image isup = {isup}')\nplt.imshow(img_test, cmap = \"gray\")\nf.add_subplot(2, 1, 2).set_title(f'Filtered Image isup = {isup}')\nplt.imshow(filtered, cmap = \"gray\")\nplt.show()","bff7bafd":"# Segmentation\ngray = cv2.cvtColor(filtered, cv2.COLOR_RGB2GRAY)\nret, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)","713c63b1":"f = plt.figure(figsize=(15,15))\nf.add_subplot(2, 1, 1).set_title(f'Original Image isup = {isup}')\nplt.imshow(img_test, cmap = \"gray\")\nf.add_subplot(2, 1, 2).set_title(f'PreSegment Image isup = {isup}')\nplt.imshow(thresh, cmap = \"gray\")\nplt.show()","d22a33db":"# Further noise removal\nkernel = np.ones((3, 3), np.uint8)\nopening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=2)\n\n# sure background area\nsure_bg = cv2.dilate(opening, kernel, iterations=3)\n\n# Finding sure foreground area\ndist_transform = cv2.distanceTransform(opening, cv2.DIST_L2, 5)\nret, sure_fg = cv2.threshold(dist_transform, 0.7 * dist_transform.max(), 255, 0)\n\n# Finding unknown region\nsure_fg = np.uint8(sure_fg)\nunknown = cv2.subtract(sure_bg, sure_fg)\n\n#Displaying segmented back ground\ndisplay(sure_bg, 'Segmented Background')","04ac0c5d":"#will not use segmeted code from above but insteaf idetify unique clusters in the image\n\nimg_test = img_array[0]","3a994c11":"# Marker labelling\nret, markers = cv2.connectedComponents(thresh)\n\n# Add one to all labels so that sure background is not 0, but 1\nmarkers = markers + 1\n\n# Now, mark the region of unknown with zero\nmarkers[unknown == 255] = 0\n\nmarkers = cv2.watershed(img_test, markers)\nimg_test[markers == -1] = [255, 0, 0]\n\n# Displaying markers on the image\ndisplay(markers,  'Marked')","60dc1b58":"isup4 = img_array[3]","9d33c113":"plt.imshow(isup4)","6e0302b5":"isup = train_df.iloc[3]['isup_grade']","ae588142":"modified_image = cv2.resize(isup4, (600, 400), interpolation = cv2.INTER_AREA)\nmodified_image = modified_image.reshape(modified_image.shape[0]*modified_image.shape[1], 3)\n\n#color seperation\nclf = KMeans(n_clusters =8)\nlabels = clf.fit_predict(modified_image)\n\ncounts = Counter(labels)\n\ncenter_colors = clf.cluster_centers_\n# We get ordered colors by iterating through the keys\nordered_colors = [center_colors[i] for i in counts.keys()]\nhex_colors = [RGB2HEX(ordered_colors[i]) for i in counts.keys()]\nrgb_colors = [ordered_colors[i] for i in counts.keys()]\n\ndel counts[0]\ndel hex_colors[0]\n\nprint(counts)\nplt.figure(figsize = (8, 6))\nplt.pie(counts.values(), labels = hex_colors, colors = hex_colors)\n\nhex_colors","67f8f7f0":"counts","c2985c38":"counts.values()","22f6449e":"testing_image = isup4","0c7a24e3":"def image_sharpening(image,ogImage):\n    img = cv2.blur(image, (3, 3))\n    kernel = [\n            [-1, -1, -1],\n            [-1, 9, -1],\n            [-1, -1, -1]\n    ]\n\n    kernel = np.array(kernel)\n    image = cv2.filter2D(img, -1, kernel)\n\n    return display(image, 'sharpened', f\"Original Image isup = {isup}\",ogImage ) \n\ndef convolution_kernel(image,ogImage):\n    kernel = [\n            [0, 1, 0],\n            [1, -4, 1],\n            [0, 1, 0]\n    ]\n\n    kernel = np.array(kernel)\n    image = cv2.filter2D(image, -1, kernel)\n\n\n    return display(image, 'Convolution Kernel',  f\"Original Image isup = {isup}\",ogImage) \n    \ndef segmentation(image,ogImage, num):\n    \n    gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)\n    ret, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)\n    # Further noise removal\n    kernel = np.ones((3, 3), np.uint8)\n    opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=2)\n\n\n    # sure background area\n    sure_bg = cv2.dilate(opening, kernel, iterations=3)\n\n    # Finding sure foreground area\n    dist_transform = cv2.distanceTransform(opening, cv2.DIST_L2, 5)\n    ret, sure_fg = cv2.threshold(dist_transform, 0.7 * dist_transform.max(), 255, 0)\n\n    # Finding unknown region\n    sure_fg = np.uint8(sure_fg)\n    unknown = cv2.subtract(sure_bg, sure_fg)\n    \n    image = img_array[num]\n    # Marker labelling\n    ret, markers = cv2.connectedComponents(thresh)\n\n    # Add one to all labels so that sure background is not 0, but 1\n    markers = markers + 1\n\n    # Now, mark the region of unknown with zero\n    markers[unknown == 255] = 0\n\n    markers = cv2.watershed(img_test, markers)\n    image[markers == -1] = [255, 0, 0]\n\n    # Displaying markers on the image\n    return display(markers,  'Marked',  f\"Original Image isup = {isup}\",ogImage)","7813fbdb":"image_sharpening(testing_image,isup4)","526f6975":"convolution_kernel(testing_image,isup4)","ce64788c":"segmentation(testing_image,isup4,3)","ec4db410":"isup1 = img_array[9]","2644f4c3":"isup = train_df.iloc[9]['isup_grade']\nplt.imshow(isup1)","6c3bdf8c":"modified_image = cv2.resize(isup1, (600, 400), interpolation = cv2.INTER_AREA)\nmodified_image = modified_image.reshape(modified_image.shape[0]*modified_image.shape[1], 3)\n\n#color seperation\nclf = KMeans(n_clusters =8)\nlabels = clf.fit_predict(modified_image)\n\ncounts = Counter(labels)\n\ncenter_colors = clf.cluster_centers_\n# We get ordered colors by iterating through the keys\nordered_colors = [center_colors[i] for i in counts.keys()]\nhex_colors = [RGB2HEX(ordered_colors[i]) for i in counts.keys()]\nrgb_colors = [ordered_colors[i] for i in counts.keys()]\ndel counts[0]\ndel hex_colors[0]\n\nprint(counts)\n\nplt.figure(figsize = (8, 6))\nplt.pie(counts.values(), labels = hex_colors, colors = hex_colors)\n\nhex_colors","45f29ed0":"counts","d6fe90ff":"testing_image = isup1","3f604a58":"image_sharpening(testing_image,isup1)","87592703":"convolution_kernel(testing_image,isup1)","273030b3":"segmentation(testing_image,isup1,9)","281f6fd8":"### Image Segmentation","266f557a":"### Testing for ISUP 1","537a55d7":"## Pre Processing","b32bd143":"### Image Display Function","d522a3e4":"#### Not too sure if image denoising will be helpful so will not use it for now \n\n- Thinking that specific values of color in image may factor into calculation","1a3bfe1a":"## Image Processing","f6f59290":"### Image Sharpening\n<hr>","26c21d38":"### Denoising image","fc77b2c4":"### Testing Pipeline for new Image (ISUP 4)\n<hr>","8f2accf7":"## Convolution kernel","17e5d3c5":"#### Will use this filtered image for further analysis","b799ce50":"### Image Visualization\n--------------------------"}}