{"cell_type":{"1446788d":"code","85a3a451":"code","7806d4e1":"code","cb68be78":"code","7ec2e3cd":"code","71622f01":"code","2aa9d350":"code","5b30012b":"code","f061ab9a":"code","f945497d":"code","4a04052e":"code","aea6527f":"code","c07f8cd1":"code","07cd8cde":"code","f53e9129":"code","f6f96c4c":"code","e1d1dba5":"code","f8bba787":"code","d0283cc5":"code","310dabc0":"code","4f1e1cda":"code","bb641188":"code","036ac932":"code","17e449db":"code","05822c78":"code","d129d60f":"code","ff257db4":"code","c0372af9":"code","02677c74":"code","8019d525":"code","87f9e38a":"code","73e17e7b":"code","a4d36f0b":"code","bd047394":"code","2f7bf273":"code","135b18a4":"markdown","e1282a49":"markdown","e9898703":"markdown","691c37d6":"markdown","6521716d":"markdown","6927642f":"markdown","26a7222c":"markdown"},"source":{"1446788d":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nfrom sklearn.metrics import mean_squared_error\nimport warnings\nimport sys\nimport itertools\nfrom sklearn.metrics import classification_report\n\n\n# Pacotes de Manipula\u00e7\u00e3o de Dados\nimport sklearn \nfrom sklearn.metrics import confusion_matrix, recall_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import scale\n\n\n# Keras e TensorFlow\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Activation, Dropout\nfrom keras.models import load_model\nfrom keras.optimizers import SGD, Adam, RMSprop\nimport tensorflow as tf\n\n# Pacotes para Confusion Matrix e Balanceamento de Classes\nimport imblearn\n\nLABELS = [\"Noraml\", \"Com Diabetes\"]\n\n%matplotlib inline","85a3a451":"# Carregando a base de dados\ndf  = pd.read_csv('..\/input\/dataset_treino.csv', decimal=b',')\n# Eliminando a coluna id\ndf.drop(['id'], axis = 1, inplace = True)","7806d4e1":"# Verificando tipos de dados e estat\u00edsticas descritivas\nprint (df.info ()) \nprint (df.describe ())","cb68be78":"# Visualizando as primeiras 10 linhas do dataframe\ndf.head(10)","7ec2e3cd":"count_classes = pd.value_counts(df['classe'], sort = True)\ncount_classes.plot(kind = 'bar', rot=0)\nplt.title(\"Distribui\u00e7\u00e3o\")\nplt.xticks(range(2), LABELS)\nplt.xlabel(\"Classe\")\nplt.ylabel(\"Frequ\u00eancia\");","71622f01":"print('O Dataframe possui ' + str(df.shape[0]) + ' linhas e ' + str(df.shape[1]) + ' colunas')","2aa9d350":"diabetes = df.loc[df['classe'] == 1]\nsem_diabetes = df.loc[df['classe'] == 0]\nprint(\"Temos\", len(diabetes), \"pontos de dados como diabetes e\", len(sem_diabetes), \"pontos de dados considerados normais.\")","5b30012b":"# Atribuindo Valores \u00e0s Vari\u00e1veis X e Y do Modelo\nX = df.iloc[:,:-1]\ny = df['classe']\n\n\n# Aplicando Scala \nX = scale(X)\n\n# Gerando dados de treino, teste e valida\u00e7\u00e3o\nX1, X_valid, y1, y_valid = train_test_split(X, y, test_size = 0.10, random_state = 0)\nX_train, X_test, y_train, y_test = train_test_split(X1, y1, test_size = 0.23, random_state = 0)","f061ab9a":"print(\"Tamanho do Dataset de Treino: \", X_train.shape)","f945497d":"print(\"Tamanho do Dataset de Valida\u00e7ao: \", X_valid.shape)","4a04052e":"print(\"Tamanho do Dataset de Test: \", X_test.shape)","aea6527f":"from imblearn.under_sampling import RandomUnderSampler\nuds = RandomUnderSampler(random_state=42)\nX2_train, y2_train = uds.fit_sample(X_train, y_train)","c07f8cd1":"count_classes = pd.value_counts(y2_train, sort = True)\ncount_classes.plot(kind = 'bar', rot=0)\nplt.title(\"Distribui\u00e7\u00e3o\")\nplt.xticks(range(2), LABELS)\nplt.xlabel(\"Classe\")\nplt.ylabel(\"Frequ\u00eancia\");","07cd8cde":"from keras.callbacks import EarlyStopping\nfrom tensorflow import set_random_seed\nimport keras as keras\nfrom sklearn.metrics import precision_score, recall_score","f53e9129":"# Fun\u00e7\u00e3o para construir a Confusion Metrix\ndef pretty_print_conf_matrix(y_true, y_pred, \n                             classes,\n                             normalize=False,\n                             title='Confusion matrix',\n                             cmap=plt.cm.Blues):\n    \"\"\"\n    refer\u00eancia: http:\/\/scikit-learn.org\/stable\/auto_examples\/model_selection\/plot_confusion_matrix.html#sphx-glr-auto-examples-model-selection-plot-confusion-matrix-py\n\n    \"\"\"\n\n    cm = confusion_matrix(y_true, y_pred)\n\n    # Configure Confusion Matrix Plot Aesthetics (no text yet) \n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    cax = ax.matshow(cm, cmap=plt.cm.Blues)\n    fig.colorbar(cax)\n    plt.title(title, fontsize=14)\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n    plt.ylabel('True label', fontsize=12)\n    plt.xlabel('Predicted label', fontsize=12)\n\n    # Calculate normalized values (so all cells sum to 1) if desired\n    if normalize:\n        cm = np.round(cm.astype('float') \/ cm.sum(),2) #(axis=1)[:, np.newaxis]\n\n    # Place Numbers as Text on Confusion Matrix Plot\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\",\n                 fontsize=12)\n\n\n    # Add Precision, Recall, F-1 Score as Captions Below Plot\n    rpt = classification_report(y_true, y_pred)\n    rpt = rpt.replace('avg \/ total', '      avg')\n    rpt = rpt.replace('support', 'N Obs')\n\n    plt.annotate(rpt, \n                 xy = (0,0), \n                 xytext = (-50, -140), \n                 xycoords='axes fraction', textcoords='offset points',\n                 fontsize=12, ha='left')    \n\n    # Plot\n    plt.tight_layout()","f6f96c4c":"# Fun\u00e7\u00e3o para as estat\u00edsticas de precis\u00e3o, imprecis\u00e3o, falsos negativos e falsos positivos\ndef estatisticas(y_true, y_pred):\n    false_neg = 0\n    false_pos = 0\n    incorrect = 0\n    y2_true = np.array(y_true)\n    total = len(y_true)\n    for i in range(len(y_true)):        \n        if y_pred[i] != y2_true[i]:\n            incorrect += 1\n            if y2_true[i] == 1 and y_pred[i] == 0:\n                false_neg += 1\n            else:\n                false_pos += 1\n\n    inaccuracy = incorrect \/ total\n\n    print('Inacur\u00e1cia:', inaccuracy)\n    print('Acur\u00e1cia:', 1 - inaccuracy)\n    if incorrect > 0:\n        print('Taxa de Falsos Negativos:', false_neg\/incorrect)\n        print('Taxa de Falsos Positivos:', false_pos \/ incorrect )    \n    print('Falsos Negativos\/total:', false_neg\/total)\n    return inaccuracy, incorrect","e1d1dba5":"# Classe para calcular a m\u00e9trica de precis\u00e3o com base no recall\nclass Metrics(keras.callbacks.Callback):\n    def on_train_begin(self, logs={}):\n        self._data = []\n\n    def on_epoch_end(self, batch, logs={}):\n        X_val, y_val = self.validation_data[0], self.validation_data[1]\n        y_predict = np.round(model2.predict(X_val)).T[0]\n    \n        self._data.append({\n            'val_recall': recall_score(y_val, np.round(model2.predict(X_val)).T[0], pos_label = 1, average = 'binary'),\n            'val_precision': precision_score(y_val, np.round(model2.predict(X_val)).T[0],  pos_label = 0 , average = 'binary'),\n        })\n        return\n\n    def get_data(self):\n        return self._data","f8bba787":"# Parametrtos da rede\nbatch_size = 10\nseed = 7\nset_random_seed(seed)\nmetrics = Metrics()\n\nOPTIMIZER = RMSprop(lr=0.001, rho=0.9, epsilon=None, decay=0.001)","d0283cc5":"model2 = Sequential()\nmodel2.add(Dense(16, input_dim = 8, kernel_initializer='normal')) \nmodel2.add(Activation('relu'))\nmodel2.add(Dropout(0.20))\nmodel2.add(Dense(8,  kernel_initializer='uniform'))\nmodel2.add(Activation('tanh'))\nmodel2.add(Dense(1,  kernel_initializer='uniform'))\nmodel2.add(Activation('sigmoid'))\nmonitor = EarlyStopping(monitor = 'val_loss', min_delta = 1e-3, patience = 10, verbose = 1, mode = 'auto')   \nmodel2.compile(loss = 'binary_crossentropy', optimizer = OPTIMIZER, metrics = ['accuracy'])\nmodel2.summary()","310dabc0":"history = model2.fit(X2_train, y2_train, epochs = 42, batch_size = batch_size, validation_data=(X_valid, y_valid), callbacks = [metrics], shuffle=False)","4f1e1cda":"# Avaliando o modelo\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title('model train vs validation loss'), \nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.legend(['train', 'validation'], loc='upper right')\nplt.show()","bb641188":"print(\"Loss: \", model2.evaluate(X_valid, y_valid, verbose=0))","036ac932":"from sklearn import metrics\nprobs = model2.predict_proba(X_valid)\npreds = probs[:,0]\nfpr, tpr, threshold = metrics.roc_curve(y_valid, preds)\nroc_auc = metrics.auc(fpr, tpr)","17e449db":"plt.title('Receiver Operating Characteristic')\nplt.plot(fpr, tpr, 'b', label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],'r--')\nplt.xlim([0, 1])\nplt.ylim([0, 1])\nplt.ylabel('True  Positive rate')\nplt.xlabel('False Positive rate')\nplt.show()","05822c78":"y2_predicted = np.round(model2.predict(X_test)).T[0]\ny2_correct = y_test","d129d60f":"np.setdiff1d(y2_predicted, y2_correct)","ff257db4":"inaccuracy, incorrect = estatisticas(y2_correct, y2_predicted)","c0372af9":"print('Validation Results')\nprint(recall_score(y_valid,np.round(model2.predict(X_valid)).T[0]))\nprint('\\nTest Results')\nprint(1 - inaccuracy)\nprint(recall_score(y_test,np.round(model2.predict(X_test)).T[0]))","02677c74":"print(incorrect)","8019d525":"# Plot Confusion Matrix\nwarnings.filterwarnings('ignore')\npretty_print_conf_matrix(y2_correct, y2_predicted, \n                         classes= ['0', '1'],\n                         title='Confusion Matrix')","87f9e38a":"# Carregando o dataset de teste\ndfteste = pd.read_csv('..\/input\/dataset_teste.csv', decimal=b',')\ndft = dfteste.iloc[:,1:]","73e17e7b":"# Aplicando Scala\nX_test2 = scale(dft)","a4d36f0b":"# Fazendo as previs\u00f5es\ny_test2 = np.round(model2.predict(X_test2))\ndfteste['classe'] = y_test2.astype(np.int64)","bd047394":"# Eliminando as colunas para gerar o sampleSubmission.csv\ndfteste.drop(['num_gestacoes'], axis = 1, inplace = True)\ndfteste.drop(['glicose'], axis = 1, inplace = True)\ndfteste.drop(['pressao_sanguinea'], axis = 1, inplace = True)\ndfteste.drop(['grossura_pele'], axis = 1, inplace = True)\ndfteste.drop(['insulina'], axis = 1, inplace = True)\ndfteste.drop(['bmi'], axis = 1, inplace = True)\ndfteste.drop(['indice_historico'], axis = 1, inplace = True)\ndfteste.drop(['idade'], axis = 1, inplace = True)\n\nprint(dfteste)","2f7bf273":"# Salvando \ndfteste.to_csv('.\/sampleSubmission.csv', index=False)","135b18a4":"## Competi\u00e7\u00e3o DSA de Machine Learning - Edi\u00e7\u00e3o Janeiro\/2019","e1282a49":"## Aplicando uma Rede Multilayer-Perceptron de 3 camadas","e9898703":"## Inportando Bibliotecas","691c37d6":"## Introdu\u00e7\u00e3o\n\nO objetivo desta an\u00e1lise \u00e9 criar um modelo de Rede Neural Profunda (Deep Learning) capaz prever, com o mais alto grau de precis\u00e3o poss\u00edvel, os atendimentos prop\u00edcios a ocorr\u00eancia de Diabetes.","6521716d":"## Apresenta\u00e7\u00e3o dos dados\n\nO conjunto de dados \u00e9 do Instituto Nacional de Diabetes e Doen\u00e7as Digestivas e Renais (National Institute of Diabetes and Digestive and Kidney Diseases). O objetivo \u00e9 prever com base em medidas de diagn\u00f3stico, se um paciente tem diabetes. V\u00e1rias restri\u00e7\u00f5es foram colocadas na sele\u00e7\u00e3o dessas inst\u00e2ncias de um banco de dados maior. Em particular, todos os pacientes aqui s\u00e3o do sexo feminino com pelo menos 21 anos de idade.\n\nDescri\u00e7\u00e3o dos atributos:\n\nnum_gestacoes - N\u00famero de vezes gr\u00e1vida\n\nglicose - Concentra\u00e7\u00e3o plasm\u00e1tica de glicose em teste oral de toler\u00e2ncia \u00e0 glicose\n\npressao_sanguinea - Press\u00e3o arterial diast\u00f3lica em mm Hg\n\ngrossura_pele - Espessura da dobra da pele do tr\u00edceps em mm\n* \ninsulina - Insulina em mu U \/ ml\n\nbmi - \u00cdndice de massa corporal medido em peso em kg \/ (altura em m) ^ 2\n\nindice_historico - \u00cdndice de hist\u00f3rico de diabetes (Pedigree Function)\n\nidade - Idade em anos\n\nclasse - Classe (0 - n\u00e3o desenvolveu a doen\u00e7a \/ 1 - desenvolveu a doen\u00e7a)","6927642f":"## Aplicando Undersampling","26a7222c":"## Carregando os dados"}}