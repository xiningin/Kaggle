{"cell_type":{"ae86368a":"code","f8424f16":"code","568e87b6":"code","1c692ade":"code","4c959e7a":"code","a1bd2d1e":"code","4255319b":"code","d2355e65":"code","34689173":"code","56d3b693":"code","b2cd4f8f":"markdown"},"source":{"ae86368a":"# One feature constructing","f8424f16":"import pandas as pd\nimport numpy as np\nimport pyarrow.parquet as pq","568e87b6":"metatrain=pd.read_csv ('..\/input\/metadata_train.csv')\nm1i=metatrain[metatrain.target==1].index\nm0i=metatrain[metatrain.target==0].index","1c692ade":"\nsuin0 = pq.read_pandas('..\/input\/train.parquet', \\\n                        columns=[str(i) for i in m0i [:500]]).to_pandas()\nsuin0=suin0.transpose ()\nsuin0.index=suin0.index.astype ('int')\nsuin1 = pq.read_pandas('..\/input\/train.parquet', \\\n                        columns=[str(i) for i in m1i [:500]]).to_pandas()\nsuin1=suin1.transpose ()\nsuin1.index=suin1.index.astype ('int')","4c959e7a":"import matplotlib.pyplot as plt\nfrom scipy.fftpack import fft,dct,idct,dstn,idstn\nfrom scipy.signal import find_peaks, peak_widths\nfrom scipy.ndimage import maximum_filter1d\n","a1bd2d1e":"# This procedure shifts the maximum of the signal to zero\ndef shift1 (v):\n  nn=len (v)\n  s1=np.argmax (v); s4=s1\n  s2=set(find_peaks (v)[0])\n  s2.difference_update({s1})\n  for i2 in s2:\n    if v [i2]>0.85*v [s1]:\n      if (s1-i2) % nn < nn\/6:\n        s3=((s1-i2) % nn)\/\/2\n        s4=(i2+s3) % nn\n      elif (i2-s1) % nn < nn\/6:\n        s3=((i2-s1) % nn)\/\/2\n        s4=(s1+s3) % nn      \n  s4=s4.astype ('int') \n  return np.roll (v,-s4),s4\n\n# This procedure finds the difference between the signal and its approximation\n# using scipy.fftpack.dct (also shift1 used)\ndef redim (vec):\n  nidct=150\n  vec_trunc=np.zeros ([nidct])\n  vec_dct=dct (vec,n=800000,norm='ortho')\n  vec_nidct= idct (vec_dct,n=nidct, norm='ortho')\n  s1=np.argmax (vec_nidct)\n  vec_nidct_shift,s5=shift1 (vec_nidct)\n  vec_nidct_shift_dct =dct (vec_nidct_shift,norm='ortho')\n  vec_trunc[0:15]=vec_nidct_shift_dct [0:15]\n  vec_trunc_idct=idct (vec_trunc,n=800000, norm='ortho')\n  vec_shift=np.roll(vec,-s5*800000\/\/nidct)\n  vec_dif=vec_shift-vec_trunc_idct\n  return vec_dif\n                ","4255319b":"# This procedure uses some filter and constructs some characteristic\n# for 15 rectangulars formed by the signal. Why so? Don't know. The best\n# parameters I found are here\ndef shtuk2 (vecvdi):\n  nv=5; nv1=3; nve=800\/\/nv; ng=1000\/\/nv1; nyc=nve*ng; nb=nyc\/\/6\n  mat44=np.empty ([nv,nv1]); \n  for i1 in range (nv1):\n    for i0 in range(nv):\n      ve2=vecvdi.reshape (800,-1)[i0*nve:(i0+1)*nve,i1*ng:(i1+1)*ng].reshape (-1)\n      ve3=idct (ve2.reshape (-1),norm='ortho');\n      ve3s=ve3 [nb:]\n      ve4=maximum_filter1d(ve3s,58,mode='wrap')\n      ff=find_peaks (ve4,height=1,distance=2,width=1)\n      ff1=ff [1]['peak_heights'];\n      fs=ff1.sum ()\/ff1.mean ()\n      mat44 [i0,i1]=fs\n  vem=np.min(mat44)\n  return vem","d2355e65":"# We collect the values of shtuk2 procedure in two lists for 500 normal and \n# 500 fault signals\nmin0=[]; min1=[]; \nfor i in range(500):\n  no0=m0i[i]\n  ve0=suin0.loc [no0,:]\n  vdi0=redim (ve0)\n  chi0=shtuk2 (vdi0)\n  min0.append (chi0);\nfor i in range(500):  \n  no1=m1i[i]\n  ve1=suin1.loc [no1,:]\n  vdi1=redim (ve1)\n  chi1=shtuk2 (vdi1)\n  min1.append (chi1)\n  \n  ","34689173":"# For this number ku we have that 153 of 500 faults are greater than ku, and \n# only 4 of 500 normal signals are greater than ku\nku=np.sort(min0)[-5]\naa=pd.DataFrame(min1); bb=pd.DataFrame (min0);\nprint ((bb>ku).sum(), (aa>ku).sum())","56d3b693":"plt.title('500 normal vs 500 faults')\nplt.hist((min1,min0))\n","b2cd4f8f":"# Histogram of two lists\n\n\n"}}