{"cell_type":{"400327f2":"code","a885563a":"code","29ce9256":"code","50dfc892":"code","efe93520":"code","4f0ff37c":"code","234e8973":"code","6e59094d":"code","96ea246c":"code","1eebd12d":"code","b16cb98f":"code","d5b1bd79":"code","6a7133a6":"code","d52b71e3":"code","e62ef79d":"code","501a61c9":"code","87d58606":"code","fd295d9e":"code","8d919f3f":"code","437d8710":"code","066587dc":"code","8e868a3c":"code","3e4bbdf3":"code","c6b7f59b":"code","c86ca367":"code","78c57870":"code","3fd3d117":"markdown"},"source":{"400327f2":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport xgboost as xgb\nfrom scipy import ndimage\nimport cv2\nfrom skimage.transform import resize\nfrom skimage import img_as_bool","a885563a":"import os\nimport PIL\n## checking for xrays and their respective masks\nfrom glob import glob\nimport re\nfrom collections import defaultdict\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nDIR = \"\/kaggle\/input\/chest-xray-masks-and-labels\/data\/\"\n\nlung_image_paths = glob(os.path.join(DIR,\"Lung Segmentation\/CXR_png\/*.png\"))\nmask_image_paths = glob(os.path.join(DIR,\"Lung Segmentation\/masks\/*.png\"))\n\nrelated_paths = defaultdict(list)\n\nfor img_path in lung_image_paths:\n    img_match = re.search(\"CXR_png\/(.*)\\.png$\", img_path)\n    if img_match:\n        img_name = img_match.group(1)\n    for mask_path in mask_image_paths:\n        mask_match = re.search(img_name, mask_path)\n        if mask_match:\n            related_paths[\"image_path\"].append(img_path)\n            related_paths[\"mask_path\"].append(mask_path)\n\npaths_df = pd.DataFrame.from_dict(related_paths)","29ce9256":"import matplotlib.ticker as plticker\n\nimg = cv2.imread(paths_df.image_path[0])\n\nimg = cv2.resize(img, (256,256))\nimg = img[:,:,:]\nfig = plt.figure(figsize = (15,10))\nax = fig.add_subplot(111)\nloc = plticker.MultipleLocator(base=8)\n\nax.xaxis.set_major_locator(loc)\nax.yaxis.set_major_locator(loc)\nax.grid(which='major', axis='both', linestyle='-', color='r')\nax.imshow(img)\n\n## FAZER COM 3072X3072, windowSize = 12, pra no final ter uma imagem 256x256","50dfc892":"from tqdm import tqdm\nfrom sklearn.model_selection import train_test_split\nimport cv2\ndef prepare_img_mask(df = pd.DataFrame(), resize_shape = tuple(), start = 0, end = 30):\n    img_array = list()\n    mask_array = list()\n\n    for image_path in tqdm(paths_df.image_path[start:end]):\n        resized_image = cv2.resize(cv2.imread(image_path),resize_shape)\n        resized_image = resized_image\/255.\n        img_array.append(resized_image[:,:,0])\n      # img_array.append(resized_image)\n  \n    for mask_path in tqdm(paths_df.mask_path[start:end]):\n        resized_mask = cv2.resize(cv2.imread(mask_path),resize_shape)\n        resized_mask = resized_mask\/255.\n        mask_array.append(resized_mask[:,:,0])\n        # mask_array.append(resized_image)\n\n    return img_array, mask_array\n\nimg_array, mask_array = prepare_img_mask(df = paths_df, resize_shape = (1024,1024))\n\nimg_train, img_test, mask_train, mask_test = train_test_split(img_array, mask_array, test_size = 0.2, random_state= 42)\n\nimg_side_size = 1024\nimg_train = np.array(img_train).reshape(len(img_train), img_side_size, img_side_size, 1)\nimg_test = np.array(img_test).reshape(len(img_test), img_side_size, img_side_size, 1)\nmask_train = np.array(mask_train).reshape(len(mask_train), img_side_size, img_side_size, 1)\nmask_test = np.array(mask_test).reshape(len(mask_test), img_side_size, img_side_size, 1)","efe93520":"! pip install mahotas","4f0ff37c":"\n\n# windowSize = 4\n# img_num = 0\n# patch_gen = walkthrough_img(img_array[img_num], windowSize = windowSize)\n# mask_patch_gen = walkthrough_img(np.uint8(mask_array[img_num]), windowSize = windowSize)","234e8973":"import mahotas as mh\nnp.random.seed(42)\n\ndef walkthrough_img(img, windowSize = 8):\n    # shape of the kernel: windowSize x windowSize\n\n    ## walk through the image and its mask\n\n    stride = windowSize\n    for i in range(0,img.shape[0],stride):\n        for j in range(0,img.shape[1],stride):\n            cut_img = img[i:i+windowSize,j:j+windowSize]\n            yield cut_img\n\n\ndef plot_patches(img, patch_generator, windowSize):\n\n    n_side = np.uint8(img.shape[0]\/windowSize)\n    fig, axes = plt.subplots(nrows = n_side, ncols = n_side, figsize = (10,10))\n    axes = axes.flatten()\n\n    for ax in axes:\n        ax.imshow(next(patch_generator))\n        \ndef create_feats_df(img, patch_gen, mask_patch_gen, windowSize):\n    df = pd.DataFrame()\n\n    n_side = int(img.shape[0]\/windowSize)\n    \n    for i in range(n_side**2):\n        img = next(patch_gen)\n        mask = next(mask_patch_gen)\n        pixel_mean = np.mean(img)\n        feats = mh.features.haralick(np.uint8(img*255))\n        mean_feats = feats.mean(axis = 0)\n        label = np.median(np.uint8(mask)) # the label will be the median value of the patch mask\n        mean_feats = np.append(mean_feats, np.array(label))\n        mean_feats = np.append(mean_feats, np.array(pixel_mean))\n        temp_df = pd.DataFrame(mean_feats.reshape(1,-1))\n        df = df.append(temp_df, ignore_index = True)\n\n        \n    return df\n        \n# img_num = 8\n# plot_patches(img = img_array[img_num], patch_generator = mask_patch_gen, windowSize = windowSize)","6e59094d":"# mask_patch_gen = walkthrough_img(np.uint8(mask_array[0]), windowSize = 64)\n# plot_patches(np.uint8(mask_array[0]), patch_generator = mask_patch_gen, windowSize = 64)","96ea246c":"from tqdm import tqdm\ndef get_imgs_df(img_array,mask_array, windowSize = 8):\n    \n    final_df = pd.DataFrame()\n    for img_num, img in tqdm(enumerate(img_array[:25])):\n        patch_gen = walkthrough_img(img_array[img_num], windowSize = windowSize)\n        mask_patch_gen = walkthrough_img(np.uint8(mask_array[img_num]), windowSize = windowSize)\n        img_df = create_feats_df(img_array[0], patch_gen, mask_patch_gen, windowSize = windowSize)\n        final_df = final_df.append(img_df, ignore_index = True)\n        \n    return final_df\n\nfinal_df = get_imgs_df(img_array, mask_array, windowSize = 16)","1eebd12d":"col_names = [\"ang_sec_moment\", \"contrast\", \"correlation\", \"variance\", \"inverse_diff_moment\", \"sum_avg\",\"sum_variance\", \"sum_entropy\", \"entropy\", \"diff_variance\", \"diff_entropy\", \"inf_measure_corr1\", \"inf_measure_corr2\", \"label\", \"pixel_value\"]\nfinal_df.columns = col_names\nfinal_df","b16cb98f":"# from sklearn.ensemble import RandomForestClassifier\n# clf = RandomForestClassifier(random_state = 42)\nx = final_df.drop([\"label\"], axis = 1)\ny = np.uint8(final_df[\"label\"])\nxtrain, xval, ytrain, yval = train_test_split(x, y, test_size = 0.2, random_state = 42)\n# xval, xtest, yval, ytest = train_test_split(xval, yval, test_size = 0.5, random_state = 42)","d5b1bd79":"clf = xgb.XGBClassifier(objective = \"binary:logistic\", random_state = 42, eta = .3, n_estimators = 400, learning_rate = 0.03)\nclf.fit(X = xtrain, y= ytrain, eval_set = [(xtrain, ytrain), (xval, yval)], eval_metric = \"error\", verbose = True)","6a7133a6":"plt.plot(clf.evals_result_['validation_0'][\"error\"], label = \"perda de treinamento\")\nplt.plot(clf.evals_result_['validation_1'][\"error\"], label = \"perda de valida\u00e7\u00e3o\")\nplt.ylabel(\"Entropia cruzada bin\u00e1ria\")\nplt.xlabel(\"N\u00famero de estimadores\")\nplt.legend();","d52b71e3":"def dice(im1, im2):\n    \"\"\"\n    Computes the Dice coefficient, a measure of set similarity.\n    Parameters\n    ----------\n    im1 : array-like, bool\n        Any array of arbitrary size. If not boolean, will be converted.\n    im2 : array-like, bool\n        Any other array of identical size. If not boolean, will be converted.\n    Returns\n    -------\n    dice : float\n        Dice coefficient as a float on range [0,1].\n        Maximum similarity = 1\n        No similarity = 0\n        \n    Notes\n    -----\n    The order of inputs for `dice` is irrelevant. The result will be\n    identical if `im1` and `im2` are switched.\n    \"\"\"\n    im1 = np.asarray(im1).astype(np.bool)\n    im2 = np.asarray(im2).astype(np.bool)\n\n    if im1.shape != im2.shape:\n        raise ValueError(\"Shape mismatch: im1 and im2 must have the same shape.\")\n\n    # Compute Dice coefficient\n    intersection = np.logical_and(im1, im2)\n\n    return 2. * intersection.sum() \/ (im1.sum() + im2.sum())","e62ef79d":"img_array_test, mask_array_test = prepare_img_mask(df = paths_df, resize_shape = (1024,1024),start = 40, end = 80)","501a61c9":"test_df = get_imgs_df(img_array_test, mask_array_test, windowSize = 16)","87d58606":"test_df.columns = col_names\ntest_df","fd295d9e":"img_num = 17\ndataframe = final_df\npred_rows = range(img_num*4096,(img_num+1)*4096)\n\ntest = dataframe.drop(\"label\", axis = 1)\nimg_to_predict = test.loc[pred_rows,:]\npred = clf.predict(img_to_predict)\npred = pred.reshape(64,64)\nmedian_pred = ndimage.median_filter(pred,7)\n\nplt.figure(figsize = (15,10))\n\nplt.subplot(1,4,1)\nplt.imshow(median_pred, cmap = \"Blues\")\nplt.axis(\"off\")\nplt.title(\"Previs\u00e3o\")\n\nplt.subplot(1,4,2)\nplt.imshow(np.array(dataframe.loc[pred_rows, \"label\"]).reshape(64,64), cmap = \"Blues\")\nplt.axis(\"off\")\nplt.title(\"M\u00e1scara real\")\n\nplt.subplot(1,4,3)\nplt.imshow(median_pred, cmap = \"Blues\", alpha = 0.3)\nplt.imshow(np.array(dataframe.loc[pred_rows, \"label\"]).reshape(64,64), cmap = \"Blues\", alpha = 0.5)\nplt.axis(\"off\")\nplt.title(\"Sobreposi\u00e7\u00e3o\")\n\nplt.subplot(1,4,4)\nplt.imshow(img_array[img_num], cmap = \"gray\")\nplt.axis(\"off\")\nplt.title(\"Original\")\n\ndice(median_pred, np.array(dataframe.loc[pred_rows, \"label\"]).reshape(64,64))","8d919f3f":"teste = final_df.append(test_df, ignore_index = True)\nteste","437d8710":"dataframe = final_df\ndiceCoefs = list()\nfor img_num in tqdm(range(25)):\n    pred_rows = range(img_num*4096,(img_num+1)*4096)\n\n    test = dataframe.drop(\"label\", axis = 1)\n    img_to_predict = test.loc[pred_rows,:]\n    pred = clf.predict(img_to_predict)\n    pred = pred.reshape(64,64)\n    median_pred = ndimage.median_filter(pred,7)\n    \n    dice_coef = dice(median_pred, np.array(dataframe.loc[pred_rows, \"label\"]).reshape(64,64))\n    diceCoefs.append(dice_coef)\n\nprint(np.median(np.array(diceCoefs)))","066587dc":"diceCoefs","8e868a3c":"np.median(np.array(diceCoefs))\nplt.hist(np.array(diceCoefs), bins = 30)\nplt.ylabel(\"N\u00famero de ocorr\u00eancias\")\nplt.xlabel(\"Coeficiente Dice\")","3e4bbdf3":"resized_pred = cv2.resize(median_pred.reshape(64,64), dsize = (256,256), interpolation = cv2.INTER_CUBIC)\nresized_mask= cv2.resize(np.array(final_df.loc[pred_rows, \"label\"]).reshape(64,64), dsize = (256,256), interpolation = cv2.INTER_CUBIC)\n\nplt.figure(figsize = (10,10))\nplt.subplot(2,2,1)\nplt.imshow(resized_pred, cmap = \"Blues\")\nplt.subplot(2,2,2)\nplt.imshow(resized_mask, cmap = \"Blues\")","c6b7f59b":"img_num = 17\ndataframe = final_df\npred_rows = range(img_num*4096,(img_num+1)*4096)\n\ntest = dataframe.drop(\"label\", axis = 1)\nimg_to_predict = test.loc[pred_rows,:]\npred = clf.predict(img_to_predict)\npred = pred.reshape(64,64)\nmedian_pred = ndimage.median_filter(pred,7)\n\nplt.figure(figsize = (15,10))\n\nplt.subplot(1,4,1)\nplt.imshow(pred, cmap = \"Blues\")\nplt.axis(\"off\")\nplt.title(\"Previs\u00e3o\")\n\nplt.subplot(1,4,2)\nplt.imshow(median_pred, cmap = \"Blues\")\nplt.axis(\"off\")\nplt.title(\"Previs\u00e3o com filtro mediano\");","c86ca367":"features = list(final_df.columns)\nfeatures.remove(\"label\")\n\nvalues, variables = list(zip(*sorted(zip(clf.feature_importances_, features))))\nplt.barh(variables, values)\nplt.ylabel(\"Vari\u00e1vel\")\nplt.xlabel(\"Import\u00e2ncia relativa\")","78c57870":"\n\ndice(pred, np.array(final_df.loc[pred_rows, \"label\"]))","3fd3d117":"## Haralick features"}}