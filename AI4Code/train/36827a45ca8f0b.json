{"cell_type":{"622ab36c":"code","76dc5619":"code","c6171c94":"code","5efac262":"code","bd7d0834":"code","691d0803":"code","e812cad1":"code","203bceb9":"code","3d13e599":"code","8be8594e":"code","12f5792e":"code","699917a9":"code","e3d6eb3b":"code","73397a03":"markdown","ec1eccc0":"markdown","d9aef76c":"markdown","0e29f15f":"markdown","6b6745fc":"markdown","cd52635d":"markdown","65c41857":"markdown","3c29cc3a":"markdown"},"source":{"622ab36c":"# Importando bibliotecas\nimport numpy\nimport matplotlib.pyplot as plt\nimport pandas\nimport math\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import LSTM, Conv1D, Dropout\nfrom keras.callbacks import ReduceLROnPlateau, ModelCheckpoint, EarlyStopping\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error\nnumpy.random.seed(7)","76dc5619":"# Carrega apenas a coluna com o total de passageiros por m\u00eas, em milhares (112 = 122000 passageiros em v\u00f4os)\ndataframe = pandas.read_csv('..\/input\/airlines-passenger-data\/international-airline-passengers.csv', usecols=[1], engine='python', skipfooter=3)\ndataframe.head(3)","c6171c94":"dataframe.plot()","5efac262":"#Converte a coluna do dataframe pandas em um vetor numpy\ndataset = dataframe.values\ndataset = dataset.astype('float32')\n\nlook_back = 12\n\n# Divite os dados de treino (2\/3) e teste (1\/3)\n# Note que a divis\u00e3o n\u00e3o \u00e9 aleat\u00f3ria, mas sim sequencial\ntrain_size = int(len(dataset) * 0.67)\ntest_size = len(dataset) - train_size\ntrain, test = dataset[0:train_size,:], dataset[train_size-look_back-1:len(dataset),:]","bd7d0834":"# Recebe uma s\u00e9rie e converte em uma matriz com s\u00e9ries deslocadas.\ndef create_dataset(dataset, look_back=1, std=1):\n    dataX, dataY = [], []\n    for i in range(len(dataset)-look_back):\n        a = dataset[i:(i+look_back), 0]-dataset[i, 0]\n        a \/= std\n        dataX.append(a)\n        dataY.append(dataset[i + look_back, 0]-dataset[i + look_back-1, 0])\n    return numpy.array(dataX), numpy.array(dataY)\n\n# reshape into X=t and Y=t+1\nstd = train[:, 0].std()\ntrainX, trainY = create_dataset(train, look_back, std)\ntestX, testY = create_dataset(test, look_back, std)\n# shape is [samples, time steps, features]\n\ntrainX = trainX.reshape(-1, look_back, 1)\ntestX = testX.reshape(-1, look_back, 1)\ntrainY = trainY \/ 30\ntestY = testY \/ 30\n\ntrainX.shape, testX.shape","691d0803":"model = Sequential()\nmodel.add(LSTM(32, input_shape=(look_back, 1), return_sequences=False))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(1))\nmodel.compile(loss='mean_squared_error', optimizer='adam')\nmodel.summary()","e812cad1":"callbacks = [\n    ReduceLROnPlateau(patience=10, factor=0.5, verbose=True),\n    ModelCheckpoint('best.model', save_best_only=True),\n    EarlyStopping(patience=25, verbose=True)\n]\n\nhistory = model.fit(trainX, trainY, epochs=5000, batch_size=24, validation_data=(testX, testY),\n                    verbose=0, callbacks=callbacks)","203bceb9":"df_history = pandas.DataFrame(history.history)\nax = df_history[['val_loss', 'loss']].plot(figsize=(10, 5))\ndf_history['lr'].plot(ax=ax.twinx(), color='gray')","3d13e599":"# Realiza as previs\u00f5es. Notar que a utilidade de prever trainX \u00e9 nenhuma. Serve apenas para exibir no gr\u00e1fico.\nmodel.load_weights('best.model')\ntrainPredict = model.predict(trainX)\ntestPredict = model.predict(testX)","8be8594e":"plt.scatter(trainY, trainPredict.ravel())","12f5792e":"plt.scatter(testY, testPredict.ravel())","699917a9":"# Calcula os erros de previs\u00e3o\ntrainScore = math.sqrt(mean_squared_error(trainY, trainPredict[:,0]))\nprint('Train Score: %.2f RMSE' % (trainScore))\ntestScore = math.sqrt(mean_squared_error(testY, testPredict[:,0]))\nprint('Test Score: %.2f RMSE' % (testScore))","e3d6eb3b":"# shift train predictions for plotting\ntrainPredictPlot = (trainPredict.ravel() * 30) + dataset[look_back:len(trainPredict)+look_back, 0]\n\n# shift test predictions for plotting\ntestPredictPlot = (testPredict.ravel() * 30) + dataset[len(trainPredict)+(look_back)-1:len(dataset), 0]\n\n# plot baseline and predictions\nplt.figure(figsize=(20, 10))\nplt.plot(dataset)\nplt.plot(look_back+numpy.arange(len(trainPredictPlot)), trainPredictPlot)\nplt.plot(look_back+numpy.arange(len(testPredictPlot))+len(trainPredictPlot)-1, testPredictPlot)\nplt.show()","73397a03":"Ao final das previs\u00f5es, reescalonamos os dados para a escala original e calculamos as m\u00e9tricas de RMSE.","ec1eccc0":"Aqui criamos nossos pares de dados $X$ e $Y$, onde $Y_{t} = X_{t-1}$ (para look_bak=1). Uma outra forma de pensar no valor de $Y$ para um dado $X$ \u00e9 que ele \u00e9 o pr\u00f3ximo $X$ na s\u00e9rie temporal.","d9aef76c":"### Agora tente voc\u00ea melhorar o resultado do indicador RMSE","0e29f15f":"Imprime o gr\u00e1fico da previs\u00e3o (em vermelho)","6b6745fc":"Agora criamos nossa rede LSTM com 32 recorr\u00eancias (usa at\u00e9 32 pontos da s\u00e9rie para tentar prever o pr\u00f3ximo n\u00famero) e a treinamos.","cd52635d":"Nesse laborat\u00f3rio iremos demonstrar como uma LSTM pode ser usada para previs\u00e3o em s\u00e9ries temporais. Utilizaremos uma rede neuronal LSTM bem simples para tratar um caso de uma s\u00e9rie temporal de n\u00famero de passageiros que viajaram por m\u00eas em v\u00f4os internacionais nos Estados Unidos.","65c41857":"# LAB 6 - Usando LSTM para prever s\u00e9ries temporais","3c29cc3a":"Aqui tratamos os dados que vamos usar. Primeiro ajustamos a escala dos dados para ficarem entre 0 e 1. A seguir, dividimos os dados entre treino (67% primeiros meses) e testes (33% dos meses finais da s\u00e9rie)"}}