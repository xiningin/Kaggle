{"cell_type":{"9e8c6ceb":"code","85829829":"code","61b2404f":"code","de68fc7b":"code","c06f6ace":"code","3836fe16":"code","ed7f9cd5":"code","2fadd1f1":"code","b1daa129":"code","569ee995":"code","39801356":"code","b8c50d2a":"code","d019fea3":"code","e1738042":"code","de4ec41d":"code","17805e37":"code","e868080c":"code","742ff0d1":"code","f3e9ff6e":"code","b201785e":"code","96306250":"code","7f8404fa":"code","d9b20cd3":"code","cc01c49e":"code","ae5d912d":"code","8ee931a4":"code","f05a186d":"code","b8fef14a":"code","fc5f2d2d":"code","fbca47dd":"code","1fecfe96":"code","596f68f9":"code","55e292e5":"code","5fcef04f":"code","ba8e4e19":"code","bb1be676":"code","df2b4ffb":"code","98aa4759":"code","2c336353":"markdown","7b205849":"markdown","a03d4eb0":"markdown","98c4333f":"markdown","f0cf1dc4":"markdown","19808932":"markdown","e1fe54f0":"markdown","df092766":"markdown"},"source":{"9e8c6ceb":"import pandas as pd\nimport numpy as np\nimport time","85829829":"%%capture text\n#This hides output\n!wget http:\/\/webhotel4.ruc.dk\/~keld\/research\/LKH-3\/LKH-3.0.7.tgz\n!tar xvfz LKH-3.0.7.tgz;\n!cd LKH-3.0.7; make clean; make;\n","61b2404f":"def is_permutation(s):\n    return len(set(s))==len(s)\n\ndef get_permutations(s, length = 7):\n    answer = []\n    for i in range(len(s)-length+1):\n        x = s[i:i+length]\n        if is_permutation(x) and x not in answer:\n            answer.append(x)\n    return answer\n\ndef make_double(old_list,new_char):\n    length = len(old_list[0])\n    new_list = []\n    for x in old_list:\n        y = x+new_char+x\n        local_list = get_permutations(y, length+1)\n        for z in local_list:\n            if z not in new_list:\n                new_list.append(z)\n    return new_list\n\nabc = '3456712'\nall_permutations = ['']\n\nfor char in abc:\n    all_permutations = make_double(all_permutations, char)\nmandatory = []\n\nfor x in all_permutations:\n    if x[:2]=='12':\n        mandatory.append(x)\n        \nprint(len(all_permutations), len(mandatory))","de68fc7b":"def distance(s1, s2): \n    #This also works later for sequences that contain wildcards if the wildcard is not in the first 6 or in the last six digit of s1 or s2\n    j = 7\n    for k in range(0,7):\n        t = 7-k #length of possible overlap\n        if s1[len(s1)-t:] == s2[:t]: # Checking if the length t part of the end of s1 agrees with the beginning of s2\n            j=k\n            break\n    return j\n\ndef total_distance(list_of_permutations):\n    answer = 7\n    for i in range(len(list_of_permutations)-1):\n        x = list_of_permutations[i]\n        y = list_of_permutations[i+1]\n        answer+= distance(x,y)\n    return answer\n\ntotal_distance(all_permutations)\ndef permutations_to_string(list_of_permutations):\n    answer = list_of_permutations[0]\n    for i in range(len(list_of_permutations)-1):\n        x = list_of_permutations[i]\n        y = list_of_permutations[i+1]\n        d = distance(x,y)\n        answer+=y[7-d:]\n    return answer\n\nsuperpermutation = permutations_to_string(all_permutations)\nprint(len(superpermutation), total_distance(all_permutations))\nprint(len(get_permutations(superpermutation)))","c06f6ace":"#Checking uniform distribution of mandatory permutations\nM1, M2, M3 = [], [], []\nfor x in mandatory:\n    if x in all_permutations[:1680]:\n        M1.append(x)\n    elif x in all_permutations[1680:3360]:\n        M2.append(x)\n    elif x in all_permutations[3360:]:\n        M3.append(x)\nprint(len(M1), len(M2), len(M3))","3836fe16":"group1 = list(set(all_permutations[:1680]+mandatory))\ngroup1.sort()\ngroup2 = list(set(all_permutations[1680:3360]+mandatory))\ngroup2.sort()\ngroup3 = list(set(all_permutations[3360:]+mandatory))\ngroup3.sort()\nprint(len(group1), len(group2), len(group3))\nprint('We will use these groups in the next step')","ed7f9cd5":"# The function used in Chris Deotte's notebook with small changes\ndef get_tsp_solution(group, seed = 1, time = 100):\n    \n    # CREATE DISTANCE MATRIX\n    SIZE = len(group)\n    M = np.zeros((SIZE, SIZE), dtype='int8')\n    for j in range(SIZE):\n        #if j%25==0: print(j,', ',end='')\n        for k in range(SIZE):\n            M[j,k] = distance(group[j],group[k])\n            \n    # WRITE PROBLEM FILE\n    f = open(f'group.par','w')\n    f.write(\"PROBLEM_FILE = ..\/distances.atsp\\n\")\n    f.write(\"TOUR_FILE = ..\/output.txt\\n\")\n    f.write(f\"OPTIMUM = {SIZE}\\n\")\n    f.write(\"MOVE_TYPE = 5\\n\")\n    f.write(\"PATCHING_C = 3\\n\")\n    f.write(\"PATCHING_A = 2\\n\")\n    \n    f.write(\"SEED = \"+str(seed)+\"\\n\")\n    f.write(\"RUNS = 1\\n\")\n    f.write(\"TIME_LIMIT = \"+str(time)+\"\\n\") #seconds\n    f.close()\n    \n    # WRITE PARAMETER FILE\n    f = open(f'distances.atsp','w')\n    f.write(\"NAME: distances\\n\")\n    f.write(\"TYPE: ATSP\\n\")\n    f.write(\"COMMENT: Asymmetric TSP\\n\")\n    f.write(f\"DIMENSION: {SIZE}\\n\")\n    f.write(\"EDGE_WEIGHT_TYPE: EXPLICIT\\n\")\n    f.write(\"EDGE_WEIGHT_FORMAT: FULL_MATRIX\\n\")\n    f.write(\"EDGE_WEIGHT_SECTION\\n\")\n    for j in range(SIZE):\n        #if j%25==0: print(j,', ',end='')\n        for k in range(SIZE):\n            f.write(f\"{M[j,k]:2d} \") \n        f.write(\"\\n\")\n    f.close()\n    \n    # EXECUTE TSP SOLVER\n    !cd LKH-3.0.7; .\/LKH ..\/group.par\n    \n    # READ RESULTING ORDER\n    with open('output.txt') as f:\n        lines = f.readlines()\n    for i,ln in enumerate(lines):\n        if 'TOUR_SECTION' in ln: break\n    perms = [int(x[:-1]) for x in lines[i+1:-2] ]\n    \n    \n    best_d = 0\n    best_start = 0\n    for k in range(len(perms)):\n        t1 = (k+1)%(len(perms))\n        s1 = group[perms[k]-1]\n        s2 = group[perms[t1]-1]\n        d  = distance(s1,s2)\n        if d > best_d:\n            best_d = d\n            best_start=t1\n    result = group[ perms[best_start]-1 ]\n    for k in range(len(perms)-1):\n        ind1 = (best_start+k)%(len(perms))\n        ind2 = (ind1+1)%(len(perms))\n        s1 = group[ perms[ind1]-1 ]\n        s2 = group[ perms[ind2]-1 ]\n        d = distance(s1,s2)\n        assert(d!=0)\n        result += s2[7-d:]\n    \n    return result","2fadd1f1":"def get_best_solution(group, number_of_tries, time, desired_length):\n    best_string = ''.join(x for x in group)\n    for i in range(1,number_of_tries +1):\n        print(\"Seed number = \" + str(i))\n        new_string = get_tsp_solution(group, seed = i, time=time)\n        print(\"Length of String = \" + str(len(new_string)))\n        if len(new_string) < len(best_string):\n            best_string = new_string\n            if len(best_string) <= desired_length:\n                break\n    return best_string","b1daa129":"%%capture step1\n## Using the groups of permutations we found in the initialization step\nbegin = time.time()\nstring1 = get_best_solution(group1, number_of_tries = 15, time = 50, desired_length = 2480)\nstring2 = get_best_solution(group2, number_of_tries = 15, time = 50, desired_length = 2480)\nstring3 = get_best_solution(group3, number_of_tries = 15, time = 50, desired_length = 2480)\nend = time.time()","569ee995":"with open('output_step1.txt', 'w') as f:\n    f.write(step1.stdout)","39801356":"print('Time to find the three strings = '+ str(int(end-begin)) + ' seconds.')\nprint(len(string1), len(string2), len(string3))","b8c50d2a":"def is_good_solution(s1,s2,s3):\n    g1 = get_permutations(s1)\n    g2 = get_permutations(s2)\n    g3 = get_permutations(s3)\n    \n    for x in mandatory:\n        if x not in g1 or x not in g2 or x not in g3:\n            print(\"Some mandatory permutations are missing\")\n            return False\n    \n    if len(set(g1+g2+g3)) != 5040:\n        t = len(set(g1+g2+g3))\n        print('Missing '+str(5040-t)+' permutations')\n        return False\n              \n    return True \n\nprint('Checking the solution!')\n\nvalue = is_good_solution(string1, string2, string3)\n\nprint('Solution is correct = ' + str(value))","d019fea3":"def make_new_group(s1, s2, s3): \n    found_permutations = get_permutations(s2)+get_permutations(s3)\n    new_group = []\n    for x in all_permutations:\n        if x in mandatory or (x not in found_permutations):\n            new_group.append(x)\n    return new_group\n\ndef improve_string(s1, s2, s3, number_of_tries, time, desired_length):\n    group = make_new_group(s1, s2, s3)\n    return get_best_solution(group, number_of_tries, time, desired_length)\n\nn_old = len(get_permutations(string1))\nn_new = len(make_new_group(string1, string2, string3))\n\nprint('Number of permutations in string1 = '+  str(n_old))\nprint('Number of permutations for the new TSP problem to shorten string1 = ' +str(n_new))","e1738042":"%%capture step2\nbegin = time.time()\nstring1A = improve_string(string1, string2, string3, number_of_tries = 5, time = 50, desired_length = 2440)\nstring2A = improve_string(string2, string3, string1A, number_of_tries = 5, time = 50, desired_length = 2440)\nstring3A = improve_string(string3, string1A, string2A, number_of_tries = 5, time = 50, desired_length = 2440)\nend = time.time()","de4ec41d":"with open('output_step2.txt', 'w') as f:\n    f.write(step2.stdout)","17805e37":"print('Time to find the three strings = '+ str(int(end-begin)) + ' seconds.')\nprint(len(string1A), len(string2A), len(string3A))\nprint('Checking the solution!')\nvalue = is_good_solution(string1A, string2A, string3A)\nprint('Solution is correct = ' + str(value))","e868080c":"positions_of_mandatory = []\nfor i in range(len(string1A)-1):\n    if string1A[i:i+2] == '12':\n        positions_of_mandatory.append(i)\nprint(positions_of_mandatory) ","742ff0d1":"def finding_gaps(s):\n    gaps = []\n    positions = []\n    for i in range(len(s)-1):\n        if s[i:i+2] == '12':\n            positions.append(i)\n    for i in range(len(positions)-1):\n        pos1 = positions[i]\n        pos2 = positions[i+1]\n        gaps.append(pos2-pos1)\n    return gaps\nprint(finding_gaps(string1A))\nprint(finding_gaps(string2A))\nprint(finding_gaps(string3A))","f3e9ff6e":"print('We have only gaps of length 7 and 47')\n\nLong_Strings = []\nfor i in range(len(positions_of_mandatory)):\n    index1 = positions_of_mandatory[i]\n    if i < len(positions_of_mandatory)-1:\n        index2 = positions_of_mandatory[i+1]\n    else: \n        index2 = len(positions_of_mandatory)\n    if index2-index1==47:\n        Long_Strings.append(string1A[index1:index2])\n        \nprint('Number of Long strings :',len(Long_Strings))\n\nPatterns = {}\nfor p in Long_Strings:\n    Dict = {p[2]:'A', p[3]:'B', p[4]:'C', p[5]:'D', p[6]:'E'}\n    for k in Dict:\n        p = p.replace(k, Dict[k])\n    if p not in Patterns:\n        Patterns[p] = 1\n    else:\n        Patterns[p] +=1\nprint('Frequency of patterns of Long strings', Patterns)\nList = []\nfor p in Patterns:\n    List.append((Patterns[p],p))\nList.sort()\npattern = List[-1][1]\nprint('The most common pattern is :', pattern) ","b201785e":"print('Do we have similar patterns in the other strings as well?\\n')\n\ndef get_long_string(s): # s is a length 5 permutation:\n    typical_pattern ='12ABCDE21ABCDE2A1BCDE2AB1CDE2ABC1DE2ABCD1E2ABCD'\n    abc = 'ABCDE'\n    for i in range(5):\n        typical_pattern = typical_pattern.replace(abc[i], s[i])\n    return typical_pattern\n\nprint('Long string for length 5 permutation 34567 = ' + get_long_string('34567')+'\\n')\n\nP1, P2, P3 = [], [], []\nfor x in mandatory:\n    y = x[2:] # a length 5 permutation on 3,4,5,6,7\n    z = get_long_string(y)\n    if z in string1A:\n        P1.append(y)\n    elif z in string2A:\n        P2.append(y)\n    elif z in string3A:\n        P3.append(y)\n        \nprint('Number of long substrings found : ',  len(P1), len(P2), len(P3))\n\nnumber_of_same_patterns = len(P1)+len(P2)+len(P3)\n\nprint('\\nOut of all the 120 length-47-substrings we have '+ str(number_of_same_patterns) +' of the same pattern' )","96306250":"def transpose(s):\n    return s[:3]+s[4]+s[3]\nprint('Transpose of ABCDE = ' +transpose('ABCDE')+'\\n')\nprint('We look for some length 5 permutations for ABCDE. We need 2 for each 2440 string.\\n' )\nP12 = []\nP21 = []\nP13 = []\nP31 = []\nP23 = []\nP32 = []\nfor x in P1:\n    if transpose(x) in P2:\n        P12.append(x)\n        P21.append(transpose(x))\n        \nfor x in P1:\n    if transpose(x) in P3:\n        P13.append(x)\n        P31.append(transpose(x))\n        \nfor x in P2:\n    if transpose(x) in P3:\n        P23.append(x)\n        P32.append(transpose(x))\n    \nprint('Length of the groups : ', len(P12), len(P13), len(P23))\nprint('Given integers a, b, c we will use  wildcards for P12[a], P21[a], P13[b], P31[b], P23[c], P32[c]')\nprint('We start with the choices a = 0, b = 0, c = 0')","7f8404fa":"def get_wildcard_long_string(s):\n    return get_long_string(s)[:40]+'182'+transpose(s)\nprint('Wildcard string for 34567 : ', get_wildcard_long_string('34567'))\n\ndef use_wildcard(s, w1, w2): #s is the 2440 long string, w1, w2 are length 5 permutations on '12345'\n    wild = ''+s\n    wild = wild.replace(get_long_string(w1), get_wildcard_long_string(w1))\n    wild = wild.replace(get_long_string(w2), get_wildcard_long_string(w2))\n    wild = wild.replace('12'+transpose(w1), '')\n    wild = wild.replace('12'+transpose(w2), '')\n    return wild\n\n\nwild_string1 = use_wildcard(string1A, P12[0], P13[0])\nwild_string2 = use_wildcard(string2A, P21[0], P23[0])\nwild_string3 = use_wildcard(string3A, P31[0], P32[0])\nprint('\\n'+'The shortened lengths are : ', len(wild_string1), len(wild_string2), len(wild_string3))\n\nprint('\\n'+'We have the right length but some permutations are missing\\n')\n\ndef get_permutations_wild(s):\n    answer = []\n    for i in range(len(s)-6):\n        x = s[i:i+7]\n        if '8' not in x:\n            if is_permutation(x) and x not in answer:\n                answer.append(x)\n        if '8' in x:\n            for i in '1234567':\n                y = ''+x\n                y = y.replace('8', i)\n                if is_permutation(y) and y not in answer:\n                    answer.append(y)\n    return answer\n\ndef is_good_solution_wild(s1,s2,s3):\n    g1 = get_permutations_wild(s1)\n    g2 = get_permutations_wild(s2)\n    g3 = get_permutations_wild(s3)\n  \n    for x in mandatory:\n        if x not in g1 or x not in g2 or x not in g3:\n            print(\"Some mandatory permutations are missing\")\n            return False\n    if len(set(g1+g2+g3)) != 5040:\n        t = len(set(g1+g2+g3))\n        print('Missing '+str(5040-t)+' permutations') \n        return  False\n        \n    return True \n\nis_good_solution_wild(wild_string1, wild_string2, wild_string3);","d9b20cd3":"print('We now find a, b, c with the smallest number of permutations missing')\nbest_params = (0,0,0)\nsmallest_missing = 100\n\nfor a in range(len(P12)):\n    for b in range(len(P13)):\n        for c in range(len(P23)):\n            s1 = use_wildcard(string1A, P12[a], P13[b])\n            s2 = use_wildcard(string2A, P21[a], P23[c])\n            s3 = use_wildcard(string3A, P31[b], P32[c])\n            if len(s1) != 2428 or len(s2) != 2428 or len(s3)!= 2428:\n                print('Problem')\n            g1 = get_permutations_wild(s1)\n            g2 = get_permutations_wild(s2)\n            g3 = get_permutations_wild(s3)\n            missing = 5040-len(set(g1+g2+g3))\n            if missing < smallest_missing:\n                print(missing)\n                smallest_missing = missing\n                best_params = (a,b,c)  \nprint('Best parameters are ', best_params)\nprint('Still missing', smallest_missing, 'permutations')","cc01c49e":"print('We construct the corresponding strings.')\nprint('These will be modified later to get a solution.')\na, b, c = best_params\nwild_string1 = use_wildcard(string1A, P12[a], P13[b])\nwild_string2 = use_wildcard(string2A, P21[a], P23[c])\nwild_string3 = use_wildcard(string3A, P31[b], P32[c])","ae5d912d":"def make_new_group_wild(s1, s2, s3): # Assuming that there are two wildcards in s1 and they are at least 13 units apart\n    found_permutations = get_permutations_wild(s2)+get_permutations_wild(s3)\n    t1 = s1.find('8')\n    t2 = s1[t1+1:].find('8')+t1+1\n    assert(t1 >=  6 and t2 <= len(s1)-7 and t2-t1 >= 13)\n    wild1 = s1[t1-6:t1+7]\n    wild2 = s1[t2-6:t2+7]\n    new_group = [wild1, wild2]\n    extra_permutations = get_permutations_wild(wild1)+get_permutations_wild(wild2)\n    for x in all_permutations:\n        if x in extra_permutations:\n            continue\n        elif x in mandatory or x not in found_permutations:\n            new_group.append(x)\n    return new_group\n\ndef improve_string_wild(s1, s2, s3, number_of_tries, time, desired_length = 2428):\n    group = make_new_group_wild(s1, s2, s3)\n    return get_best_solution(group, number_of_tries, time, desired_length)","8ee931a4":"%%capture step3\nbegin = time.time()\nwild_string1B = improve_string_wild(wild_string1, wild_string2, wild_string3, 2, 200, desired_length = 2428)\nwild_string2B = improve_string_wild(wild_string2, wild_string3, wild_string1, 2, 200, desired_length = 2428)\nwild_string3B = improve_string_wild(wild_string3, wild_string1, wild_string2, 2, 200, desired_length = 2428)\nend = time.time()","f05a186d":"with open('output_step3.txt', 'w') as f:\n    f.write(step3.stdout)","b8fef14a":"print('Time to find the three candidate strings = '+ str(int(end-begin)) + ' seconds.')\nprint(len(wild_string1B), len(wild_string2B), len(wild_string3B))\nprint('We use the shortest, together with two of the length 2428 strings')\nt1 = len(wild_string1B)\nt2 = len(wild_string2B)\nt3 = len(wild_string3B)\nif t1 <= t2 and t1 <= t3:\n    wild_string1C = wild_string1B\n    wild_string2C = wild_string2\n    wild_string3C = wild_string3\nelif t2 <=t1 and t2 <=t3:\n    wild_string1C = wild_string2B\n    wild_string2C = wild_string1\n    wild_string3C = wild_string3\nelse:\n    wild_string1C = wild_string3B\n    wild_string2C = wild_string1\n    wild_string3C = wild_string2             ","fc5f2d2d":"print('Checking the solution!\\n')\nvalue = is_good_solution_wild(wild_string1C, wild_string2C, wild_string3C)\nprint('Solution is correct = ' + str(value)+'\\n')\nprint('The lengths are : ',len(wild_string1C), len(wild_string2C), len(wild_string3C))","fbca47dd":"Gap = 0\nfor i in range(len(wild_string1C)-10):\n    if wild_string1C[i:i+2]=='12' and wild_string1C[i+8:i+10]=='12':\n        print('Found a length 8 gap starting at :', i)\n        Gap =i\nprint(Gap)","1fecfe96":"print(wild_string1C[Gap:Gap+15], 'Split into 2 mandatory and a digit :', wild_string1C[Gap:Gap+7], wild_string1C[Gap+7], wild_string1C[Gap+8:Gap+15]) \nprint('Delete this digit to get a shorter sequence\\n')\nwild_string1D = wild_string1C[:Gap+7]+wild_string1C[Gap+8:]\nprint(len(wild_string1D), len(wild_string2C), len(wild_string3C))\nprint('\\n'+'We again have the right length but some permutations are missing\\n')\nis_good_solution_wild(wild_string1D, wild_string2C, wild_string3C);\nprint('\\nLuckily now there are only two missing permutations\\n')\nprint('Iterating one last time in the next cell')","596f68f9":"%%capture step4\nbegin = time.time()\nwild_string2D = improve_string_wild(wild_string2C, wild_string1D, wild_string3C, 1, 50)\nwild_string3D = improve_string_wild(wild_string3C, wild_string1D, wild_string2C, 1, 50)\nend = time.time()","55e292e5":"with open('output_step4.txt', 'w') as f:\n    f.write(step4.stdout)","5fcef04f":"print('Time to calcutate the new strings  = '+ str(int(end-begin)) + ' seconds.')\nprint('We get two possible solutions')\nprint('Replacing the second string gives a triple with lengths :', len(wild_string1D), len(wild_string2D), len(wild_string3C))\nprint('Replacing the third string gives a triple with lengths :', len(wild_string1D), len(wild_string2C), len(wild_string3D))\nif len(wild_string2D) <= len(wild_string3D):\n    solution1 = wild_string1D\n    solution2 = wild_string2D\n    solution3 = wild_string3C\nelse:\n    solution1 = wild_string1D\n    solution2 = wild_string2C\n    solution3 = wild_string3D\nprint('Lengths of the best triple found', len(solution1), len(solution2), len(solution3))\nprint('Checking the solution!')\nvalue = is_good_solution_wild(solution1, solution2, solution3)\nprint('Solution is correct = ' + str(value))","ba8e4e19":"len(solution1), len(solution2), len(solution3)","bb1be676":"is_good_solution_wild(solution1, solution2, solution3)","df2b4ffb":"# CONVERT NUMBERS TO EMOJIS\nreplace_dict = {\n '1': '\ud83c\udf85',\n '2': '\ud83e\udd36',\n '8': '\ud83c\udf1f',\n '3': '\ud83e\udd8c',\n '4': '\ud83e\udddd',\n '5': '\ud83c\udf84',\n '6': '\ud83c\udf81',\n '7': '\ud83c\udf80'}\n\nfor k,v in replace_dict.items():\n    solution1 = solution1.replace(k, v)\n    solution2 = solution2.replace(k, v)\n    solution3 = solution3.replace(k, v)","98aa4759":"# WRITE SUBMISSION CSV\nsubmission = pd.DataFrame()\nsubmission['schedule'] = [solution1, solution2, solution3]\nsubmission.to_csv('submission.csv',index=False)\nsubmission.head()","2c336353":"# Write Submission CSV","7b205849":"# Finding patterns\n\n## Let's investigate the 2440 (no wildcard) solution. We can make two observations:\n\n### Substrings starting at a mandatory '12ABCDE' and ending before the next mandatory always have length 7 or 47.\n\n### These 47 long subsequences are very similar and most of them have the form\n\n### 12ABCDE21ABCDE2A1BCDE2AB1CDE2ABC1DE2ABCD1E2ABCD","a03d4eb0":"# Finding 2480\n### Here we use the LKH package as explained in Chris Deotte's notebook: <a href=\"https:\/\/www.kaggle.com\/cdeotte\/santa-2021-tsp-baseline-2500\">Santa 2021 TSP Baseline - [2500] by CHRIS DEOTTE<\/a>\n\n### There is a small change in how the final string is computed:\n### The solver gives a tournament solution p(1),p(2),...,p(n).\n### If distance(p(n), p(1)) is less then 7, one can usually find another p(t) with distance(p(t),p(t+1)) =7.\n### Then glue p(t+1), p(t+2),..., p(t-1), p(t) to shorten the length.\n### An equivalent approach would be to use a dummy node.","98c4333f":"# Initialization\n### The best initial string I found was the known 5913 superpermutation (after relabeling).\n### Here the mandatory '12ABCDE' permutations appear more uniformly than in the 5906 superpermutation.\n","f0cf1dc4":"# Finding 2440 (no wildcards)\n### Observation: There are overlaps between the permutations covered by string1, string2 and string3.\n### Fix two of the strings and get an improved Travelling Salesman Problem to replace the third.\n### Then iterate.\n### We get lucky (due to the symmetric initial strings), and this gives an optimal \"no wildcard\" solution in just three iterations","19808932":"# Finding 2428\n### Manually shorten the longest string to have only the usual substrings between mandatory permutations.\n### This might deletes some permutations, and these can be moved to one of the other groups.\n### Note that this last part might be different if you get a longer solution in the previous step (in that case you may need to iterate this approach more than once)","e1fe54f0":"# Using the wildcards\n### The idea is to replace a long string (length 47) in some stringX (length 2440)\n### '12ABCDE21ABCDE2A1BCDE2AB1CDE2ABC1DE2ABCD1E2ABCD' with a 48 long sequence\n### '12ABCDE21ABCDE2A1BCDE2AB1CDE2ABC1DE2ABCD182ABCED',\n### then delete '12ABCED' from stringX.\n### For every wildcard this would add 1 character and delete 7, but some permutations might go missing.\n### This seems to work better if the long string starting with'12ABCED' is in stringY or in stringZ and we use the same modifications for them.","df092766":"# Finding 2429\n### We use the same ideas as earlier: Fix two of the wild strings, wild_stringX, wild_stringY and modify wild_stringZ to cover the missing permutations.\n### Here we fix the neighborhoods of the wildcards (a length 13 substring where the wildcard is in the middle).\n### In that way we can use the same TSP program with minimal modifications.\n### There are 3 options for Z. (In this example wild_string1 -> wild_string1B gives the shortest solution).\n### Note that using a different version of the LKH program (of different seed numbers) may give you different answers for this part."}}