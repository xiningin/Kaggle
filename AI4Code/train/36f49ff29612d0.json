{"cell_type":{"ae70eba7":"code","8b9d6b53":"code","a49a0a3e":"code","257fd1f0":"code","e23b159e":"code","b85014dc":"code","2e83449c":"code","ab9b0a55":"code","4f3bd215":"code","18c67d94":"code","73528495":"code","17961b23":"code","f887200f":"markdown","3e5eceec":"markdown","af84524f":"markdown","961569db":"markdown","a18ffb7e":"markdown","067382a4":"markdown","a19af71d":"markdown","a7efebad":"markdown","531e9d1d":"markdown","a156842b":"markdown","4032aec9":"markdown","1cc0d822":"markdown","258bc47f":"markdown","3cba3c8e":"markdown","2991d8c6":"markdown","368b0790":"markdown","8290e241":"markdown"},"source":{"ae70eba7":"from pathlib import Path\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.model_selection import train_test_split\n\nPATH_TO_DATA = Path('..\/input')\nN_ESTIMATORS = 1500\nSEED = 42","8b9d6b53":"y_train = pd.read_csv(PATH_TO_DATA \/ 'train_targets.csv', index_col='match_id_hash')['radiant_win']\ny_train = y_train.map({True: 1, False: 0})\ntrain_df = pd.read_csv(PATH_TO_DATA \/ 'train_features.csv', index_col='match_id_hash')\ntest_df = pd.read_csv(PATH_TO_DATA \/ 'test_features.csv', index_col='match_id_hash')\nfull_df = pd.concat([train_df, test_df], sort=False)\ntrain_size = train_df.shape[0]","a49a0a3e":"hero_columns = [c for c in full_df.columns if '_hero_' in c]\nfull_df = full_df[hero_columns]\nfull_df.head()","257fd1f0":"train_df = full_df.iloc[:train_size, :]\ntest_df = full_df.iloc[train_size:, :]\ntrain_df.corrwith(y_train).abs().sort_values(ascending=False).head(12)","e23b159e":"def evaluate():\n    from catboost import CatBoostClassifier, Pool\n    train_df_part, valid_df, y_train_part, y_valid = \\\n        train_test_split(train_df, y_train, test_size=0.25, random_state=SEED)\n    cat_features_idx = np.where(train_df.dtypes == 'object')[0].tolist()\n    catboost_dataset = Pool(train_df_part, label=y_train_part, cat_features=cat_features_idx)\n    catboost_dataset_valid = Pool(valid_df, label=y_valid, cat_features=cat_features_idx)\n    catboost_classifier = CatBoostClassifier(\n        eval_metric='AUC', depth=5, learning_rate=0.02,\n        random_seed=17, verbose=False, n_estimators=N_ESTIMATORS, task_type='GPU')\n    catboost_classifier.fit(catboost_dataset, eval_set=catboost_dataset_valid, plot=True)\n    valid_pred = catboost_classifier.predict_proba(valid_df)[:, 1]\n    score = roc_auc_score(y_valid, valid_pred)\n    print('Score:', score)\n    return catboost_classifier","b85014dc":"classifier = evaluate()","2e83449c":"full_df = full_df.astype(str)\ntrain_df = full_df.iloc[:train_size, :]\ntest_df = full_df.iloc[train_size:, :]\nclassifier = evaluate()","ab9b0a55":"for team in 'r', 'd':\n    players = [f'{team}{i}' for i in range(1, 6)]\n    hero_columns = [f'{player}_hero_id' for player in players]\n    d = pd.get_dummies(full_df[hero_columns[0]])\n    for c in hero_columns[1:]:\n        d += pd.get_dummies(full_df[c])\n    full_df = pd.concat([full_df, d.add_prefix(f'{team}_hero_')], axis=1)\n    full_df.drop(columns=hero_columns, inplace=True)\n    \ntrain_df = full_df.iloc[:train_size, :]\ntest_df = full_df.iloc[train_size:, :]","4f3bd215":"train_df.corrwith(y_train).abs().sort_values(ascending=False).head(12)","18c67d94":"!grep -oEm1 '\"hero_id\":32,\"hero_name\":\"[^\"]+?\"' $PATH_TO_DATA\/train_matches.jsonl\n!grep -oEm1 '\"hero_id\":22,\"hero_name\":\"[^\"]+?\"' $PATH_TO_DATA\/train_matches.jsonl\n!grep -oEm1 '\"hero_id\":19,\"hero_name\":\"[^\"]+?\"' $PATH_TO_DATA\/train_matches.jsonl\n!grep -oEm1 '\"hero_id\":91,\"hero_name\":\"[^\"]+?\"' $PATH_TO_DATA\/train_matches.jsonl\n!grep -oEm1 '\"hero_id\":92,\"hero_name\":\"[^\"]+?\"' $PATH_TO_DATA\/train_matches.jsonl","73528495":"classifier = evaluate()","17961b23":"submission_df = pd.read_csv(PATH_TO_DATA \/ 'sample_submission.csv', index_col='match_id_hash')\nsubmission_df['radiant_win_prob'] = classifier.predict_proba(test_df)[:, 1]\nsubmission_df.to_csv('submission.csv')","f887200f":"This kernel attempts to show how to process hero ids to make them useful for prediction.","3e5eceec":"We will use only hero columns in this kernel:","af84524f":"Let's check correlation of new dummy features with target:","961569db":"It can be seen from the above output that heroes 32, 22, 19, 91 and 92 play an important role for winning for both teams.\nLet's look up their names in `train_matches.jsonl`:","a18ffb7e":"The score has increased, but we can do it better.","067382a4":"Dota players, do you have something to say about the above heroes?\nProbably combining ids of these heroes with some other feature can give a boost? Please share your thoughts in comments.\n\nSince the features now correlate better with target, this approach should increase the score:","a19af71d":"Is there any sense in raw ids? Let's see what score these features can give as numbers.\nIf we look at correlation with target, we see that they don't correlate well with it:","a7efebad":"# Dota 2 Winner Prediction: How to make use of hero ids","531e9d1d":"Build a classifier and see the score for raw features. \nIf you run this kernel yourself, you will see nice interactive charts after each `evaluate()`.","a156842b":"## Raw ids","4032aec9":"Now let's think what hero ids mean. Some heroes might be stronger than other.\nBut what matters for victory is what heroes each team has, no matter what player.\nLet's build dummies for each column and sum them for each team.\nThis way we get a table with a column per hero. Each row will contain `1` if a corresponding hero was in this match.","1cc0d822":"## Dummies","258bc47f":"Do you know a better approach? Please share in comments.\nAnd good luck with feature engineering!","3cba3c8e":"Now let's convert raw ids to `str` so that they are processes as categorical ones, not as numerical.","2991d8c6":"Let's load the data and combine into one dataframe. We need `train_size` to split it back into train and test later.","368b0790":"## Categorical features","8290e241":"If we submit this, we get 0.59017"}}