{"cell_type":{"fa8957cb":"code","b5897446":"code","4716265d":"code","aa6b7a88":"code","37b3fa19":"code","fba11bc0":"code","470d2d02":"code","d35f4735":"code","64abbb1e":"code","5283b78a":"code","5f44c78e":"code","3219c4bb":"code","9ddaa12c":"code","cc411dc3":"code","b253a2c3":"code","bb45a70a":"code","e60f2ee7":"code","ccfee8b7":"code","59a9b7ad":"code","2a21c8b0":"code","8631d3fa":"code","0cb5d6ac":"code","5edd3957":"code","ac41e4ae":"code","e836b66a":"code","b266cefb":"code","5fd0be1b":"code","beaab1ea":"code","5b920484":"code","49fc8eb5":"code","709a4413":"code","ffb70e2f":"code","bb69865c":"code","1553b1f3":"code","2411d369":"code","e70784bc":"code","a70e1c70":"code","85e3fa19":"code","da4918ce":"code","08d32ba7":"code","105176db":"code","1a594e89":"code","951fa21a":"code","992d642c":"code","919fecc9":"code","757fc3bb":"code","4ff03796":"code","b25a24e2":"code","a4f300b0":"code","a003ab7e":"code","bf57bab2":"code","20bd67f6":"code","ad9d4d0c":"code","df72a55a":"code","59a8a5d4":"code","9d07e350":"code","641eac5b":"code","569cdbf5":"code","79659180":"code","9b3453ca":"code","81a3b2bc":"code","e69bb7f1":"code","f172786d":"code","e64e6474":"code","ecc77e44":"code","9cc39ef3":"code","e427bd73":"code","63d0dac4":"code","edbb26aa":"code","9a19d14e":"code","fdc366c7":"code","aa1b9d21":"code","ea201f2a":"code","5dcecd30":"code","259cf043":"code","b85d1f27":"code","4cb29740":"code","a5f6621c":"code","2f269982":"code","5b30ed97":"code","53bb610e":"code","d38f8ce4":"code","7459cce9":"code","20c080f6":"code","814837d5":"code","330abccd":"code","80492af2":"code","4da2c51a":"code","6c489202":"code","9e4fd33b":"code","5dc204c0":"code","3779ad89":"code","a0269e89":"code","fd89bd00":"code","8703380b":"code","8fe09ddf":"code","bf9d4365":"code","6b4f045b":"code","f69397b0":"code","08b1a803":"code","ed96606d":"code","8da6ac74":"code","50b4c466":"code","531dd088":"code","153c0ebc":"code","9d6db32d":"code","90da3a18":"code","46e18dbb":"code","bfad435f":"code","b7fdf966":"code","e1fb9924":"code","b6bbcc4d":"code","dae817c3":"markdown","0df00437":"markdown","d427298a":"markdown","f2d05913":"markdown","b329329d":"markdown","1b160fa5":"markdown","04f8fec5":"markdown","65f5d629":"markdown","eb8e1a99":"markdown","6f29a01f":"markdown","45a42980":"markdown","19774710":"markdown","e47e59a3":"markdown","e7a29936":"markdown","f19854dd":"markdown","8784515b":"markdown","912d1aef":"markdown","1c34b437":"markdown","64887648":"markdown","e421a42a":"markdown","1cce80d3":"markdown","755a14e8":"markdown","1120caf5":"markdown","20c646d3":"markdown","a1b1e8de":"markdown","955aa636":"markdown","f128782a":"markdown","c1fe65fb":"markdown","62f1e6ac":"markdown","ddb8469f":"markdown","b6a1d0d7":"markdown","223dc710":"markdown","c92acb43":"markdown","a47bc563":"markdown","3b19a87e":"markdown","8dc522ce":"markdown","5ee3ed5e":"markdown","a9952d03":"markdown"},"source":{"fa8957cb":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n# Any results you write to the current directory are saved as output.\nimport warnings\nwarnings.filterwarnings(\"ignore\")","b5897446":"#load the data\nspotify_song_data= pd.read_csv(\"..\/input\/19000-spotify-songs\/song_data.csv\")\nspotify_song_info= pd.read_csv(\"..\/input\/19000-spotify-songs\/song_info.csv\") ","4716265d":"song_info=spotify_song_info.copy()","aa6b7a88":"song_data=spotify_song_data.copy()\nsong_data.head(3)","37b3fa19":"song_data.shape","fba11bc0":"song_data.columns[song_data.isnull().any()]","470d2d02":"song_data.isnull().sum()","d35f4735":"song_data.info()","64abbb1e":"song_data.song_duration_ms= song_data.song_duration_ms.astype(float)\nsong_data.time_signature= song_data.time_signature.astype(float)\nsong_data.audio_mode= song_data.audio_mode.astype(float)","5283b78a":"song_data.describe()","5f44c78e":"song_data[\"popularity\"]= [ 1 if i>=66.5 else 0 for i in song_data.song_popularity ]\nsong_data[\"popularity\"].value_counts()","3219c4bb":"#popular songs' data\na=song_data[song_data[\"popularity\"]==1]\na.describe()","9ddaa12c":"song_data.corr()","cc411dc3":"f,ax = plt.subplots(figsize=(12, 12))\nmask = np.zeros_like(song_data.corr())\nmask[np.triu_indices_from(mask)] = True\nsns.heatmap(song_data.corr(), annot=True, linewidths=0.4,linecolor=\"white\", fmt= '.1f',ax=ax,cmap=\"Blues\",mask=mask)\nplt.show() ","b253a2c3":"def bar_plot(variable):\n    \n    var=song_data[variable]\n    var_value= var.value_counts()\n    \n    #visualize\n    plt.figure(figsize=(9,3))\n    plt.bar(var_value.index,var_value,color=\"orange\")\n    plt.xticks(var_value.index,var_value.index.values)\n    plt.ylabel(\"Frequency\")\n    plt.title(variable)\n    plt.show()\n    print(\"{}:\\n{}\".format(variable,var_value))\n","bb45a70a":"category1 = [\"popularity\",\"key\",\"audio_mode\",\"time_signature\"]\nfor c in category1:\n    bar_plot(c)","e60f2ee7":"# key vs popularity\nsong_data[[\"key\",\"popularity\"]].groupby([\"key\"], as_index = False).mean().sort_values(by=\"popularity\",ascending = False)","ccfee8b7":"# audio_mode vs popularity\nsong_data[[\"audio_mode\",\"popularity\"]].groupby([\"audio_mode\"], as_index = False).mean().sort_values(by=\"popularity\",ascending = False)","59a9b7ad":"# time_signature vs popularity\nsong_data[[\"time_signature\",\"popularity\"]].groupby([\"time_signature\"], as_index = False).mean().sort_values(by=\"popularity\",ascending = False)","2a21c8b0":"from collections import Counter\ndef detect_outliers(df,features):\n    outlier_indices = []\n    \n    for c in features:\n        # 1st quartile\n        Q1 = np.percentile(df[c],25)\n        # 3rd quartile\n        Q3 = np.percentile(df[c],75)\n        # IQR\n        IQR = Q3 - Q1\n        # Outlier step\n        outlier_step = IQR * 1.5\n        # detect outlier and their indeces\n        outlier_list_col = df[(df[c] < Q1 - outlier_step) | (df[c] > Q3 + outlier_step)].index #filtre\n        # store indeces\n        outlier_indices.extend(outlier_list_col) #The extend() extends the list by adding all items of a list (passed as an argument) to the end.\n    \n    outlier_indices = Counter(outlier_indices)\n    multiple_outliers = list(i for i, v in outlier_indices.items() if v > 2) \n    \n    return multiple_outliers","8631d3fa":"song_data.loc[detect_outliers(song_data,[\"song_popularity\",\"song_duration_ms\",\"danceability\",\"energy\",\"instrumentalness\",\"liveness\",\"loudness\",\"speechiness\",\"audio_valence\"])]","0cb5d6ac":"# drop outliers\nsong_data = song_data.drop(detect_outliers(song_data,[\"song_popularity\",\"song_duration_ms\",\"danceability\",\"energy\",\"instrumentalness\",\"liveness\",\"loudness\",\"speechiness\",\"audio_valence\"]),axis = 0).reset_index(drop = True)","5edd3957":"song_data[song_data[\"audio_mode\"].isnull()]","ac41e4ae":"g = sns.factorplot(x = \"key\", y = \"popularity\", data = song_data, kind = \"bar\", size = 6)\ng.set_ylabels(\"Popularity Probability\")\nplt.show()","e836b66a":"g = sns.factorplot(x = \"audio_mode\", y = \"popularity\", data = song_data, kind = \"bar\", size = 6)\ng.set_ylabels(\"Popularity Probability\")\nplt.show()","b266cefb":"g = sns.factorplot(x = \"time_signature\", y = \"popularity\", data = song_data, kind = \"bar\", size = 6)\ng.set_ylabels(\"Popularity Probability\")\nplt.show()","5fd0be1b":"g = sns.FacetGrid(song_data, row = \"audio_mode\", col = \"popularity\", size = 4)\ng.map(sns.barplot, \"key\", \"acousticness\")\ng.add_legend()\nplt.show()","beaab1ea":"g = sns.FacetGrid(song_data, row = \"audio_mode\", col = \"popularity\", size = 4)\ng.map(sns.barplot, \"key\", \"danceability\",color=\"purple\")\ng.add_legend()\nplt.show()","5b920484":"g = sns.FacetGrid(song_data, row = \"audio_mode\", col = \"popularity\", size = 4)\ng.map(sns.barplot, \"key\", \"instrumentalness\",color=\"green\")\ng.add_legend()\nplt.show()","49fc8eb5":"g = sns.FacetGrid(song_data, row = \"audio_mode\", col = \"popularity\", size = 4)\ng.map(sns.barplot, \"key\", \"loudness\",color=\"orange\")\ng.add_legend()\nplt.show()","709a4413":"f, axes = plt.subplots(3, 5, figsize=(12, 12))\nsns.distplot( song_data[\"song_duration_ms\"] , color=\"teal\", ax=axes[0, 0])\nsns.distplot( song_data[\"instrumentalness\"] , color=\"teal\", ax=axes[0, 1])\nsns.distplot( song_data[\"acousticness\"] , color=\"teal\", ax=axes[0, 2])\nsns.distplot( song_data[\"danceability\"] , color=\"teal\", ax=axes[0, 3])\nsns.distplot( song_data[\"energy\"] , color=\"teal\", ax=axes[0, 4])\nsns.distplot( song_data[\"song_popularity\"] , color=\"teal\", ax=axes[1, 0])\nsns.distplot( song_data[\"key\"] , color=\"teal\", ax=axes[1, 1])\nsns.distplot( song_data[\"liveness\"] , color=\"teal\", ax=axes[1, 2])\nsns.distplot( song_data[\"loudness\"] , color=\"teal\", ax=axes[1, 3])\nsns.distplot( song_data[\"audio_mode\"] , color=\"teal\", ax=axes[1, 4])\nsns.distplot( song_data[\"tempo\"] , color=\"teal\", ax=axes[2, 0])\nsns.distplot( song_data[\"speechiness\"] , color=\"teal\", ax=axes[2, 1])\nsns.distplot( song_data[\"time_signature\"] , color=\"teal\", ax=axes[2, 2])\nsns.distplot( song_data[\"audio_valence\"] , color=\"teal\", ax=axes[2, 3])\nf.delaxes(axes[2][4])\nplt.show()","ffb70e2f":"g = sns.FacetGrid(song_data, col = \"popularity\")\ng.map(sns.distplot, \"acousticness\", bins = 25)\nplt.show()","bb69865c":"g = sns.FacetGrid(song_data, col = \"popularity\")\ng.map(sns.distplot, \"danceability\", bins = 25)\nplt.show()","1553b1f3":"g = sns.FacetGrid(song_data, col = \"popularity\")\ng.map(sns.distplot, \"loudness\", bins = 25)\nplt.show()","2411d369":"g = sns.FacetGrid(song_data, col = \"popularity\")\ng.map(sns.distplot, \"instrumentalness\", bins = 25)\nplt.show()","e70784bc":"song_data3=song_data.copy()\nsong_data3[\"song_audio_valence\"]= [ \"Happy\" if i>=0.5 else \"Sad\" for i in song_data.audio_valence ]\nsong_data3[\"song_audio_valence\"].value_counts()","a70e1c70":"song_data1=song_data3[song_data3[\"song_popularity\"]>66.5]\nsong_data1[\"song_audio_valence\"]= [ \"Happy\" if i>=0.5 else \"Sad\" for i in song_data1.audio_valence ]\nsong_data1[\"song_audio_valence\"].value_counts()","85e3fa19":"song_data2_new=song_data1[song_data1[\"song_popularity\"]>90]\nsong_data2_new[\"song_audio_valence\"]= [ \"Happy\" if i>=0.5 else \"Sad\" for i in song_data2_new.audio_valence ]\nsong_data2_new[\"song_audio_valence\"].value_counts()","da4918ce":"song_data2= song_data2_new[song_data2_new.popularity==1]\na=song_data2.iloc[:,1]\na.to_numpy()\nb=song_data2.iloc[:,14]\nb.to_numpy()\nplt.figure(figsize=[8,8])\nmarkerline, stemlines, baseline = plt.stem(\n    a, b, linefmt='grey', markerfmt='D', bottom=0.5)\nmarkerline.set_markerfacecolor('none')\nplt.xlabel(\"Popularity\")\nplt.ylabel(\"Audio Valance\")\nplt.show()","08d32ba7":"new_data = pd.concat([song_info, song_data1],axis=1)\nnew_data=new_data[new_data[\"song_popularity\"]>90]","105176db":"# Top 500 Playlists Gender\nplt.figure(figsize=(12,5))\nnew_data= song_info['playlist'].head(500)\ng = sns.countplot(new_data, palette=\"icefire\")\nplt.title(\"Top 500 Genres\")\nplt.show()","1a594e89":"spotify_song_data[\"popularity\"]= [ 1 if i>=66.5 else 0 for i in spotify_song_data.song_popularity ]\nspotify_song_data[\"popularity\"].value_counts()","951fa21a":"data_plr = pd.concat([spotify_song_data.popularity,spotify_song_data.song_name],axis=1)\ndata_plr.head()","992d642c":"song_data['song_name'].value_counts(dropna=False)\nsong_data['song_name'].dropna(inplace=True)","919fecc9":"import re\nimport nltk \nimport nltk as nlp\n\nnltk.download(\"stopwords\") \nfrom nltk.corpus import stopwords","757fc3bb":"Song_Name = [ word for word in spotify_song_data.song_name if not word in set(stopwords.words(\"english\"))]\nlemma = nlp.WordNetLemmatizer()\nSong_Name = [ lemma.lemmatize(word) for word in Song_Name] ","4ff03796":"Song_Name_list = []\nfor Song_Name in data_plr.song_name:\n    Song_Name = re.sub(\"[^a-zA-Z]\",\" \",Song_Name)\n    Song_Name = Song_Name.lower() \n    Song_Name = nltk.word_tokenize(Song_Name)\n    lemma = nlp.WordNetLemmatizer()\n    Song_Name = [ lemma.lemmatize(word) for word in Song_Name]\n    Song_Name = \" \".join(Song_Name)\n    Song_Name_list.append(Song_Name)","b25a24e2":"# %% bag of words\nfrom sklearn.feature_extraction.text import CountVectorizer\nmax_features = 10\ncount_vectorizer = CountVectorizer(max_features=max_features,stop_words = \"english\")\nsparce_matrix = count_vectorizer.fit_transform(Song_Name_list).toarray()  \nprint(\"en sik kullanilan {} kelimeler: {}\".format(max_features,count_vectorizer.get_feature_names()))","a4f300b0":" a = count_vectorizer.get_feature_names()","a003ab7e":"df=pd.DataFrame(Song_Name_list,columns=['Names'])","bf57bab2":"artist= song_info.artist_name.tolist()\nname_count = Counter(artist)         \nmost_common_names2 = name_count.most_common(10) \nmost_common_names2\n","20bd67f6":"from textblob import TextBlob\ndata_plr['sentiment'] = data_plr['song_name'].map(lambda text: TextBlob(text).sentiment.polarity)","ad9d4d0c":"data_plr.head()","df72a55a":"import numpy as np\ncut = pd.cut(\n    data_plr['sentiment'],\n    [-np.inf, -.01, .01, np.inf],\n    labels=['negative', 'neutral', 'positive']\n)\ndata_plr['polarity'] = cut.values\ndata_plr[['polarity','sentiment']].head()","59a8a5d4":"plt.figure(figsize=(5,5))\ndata= data_plr.polarity\ng = sns.countplot(data, palette=\"Set3\")\nplt.title(\"Songs' Polarity\")\nplt.show()","9d07e350":"song_data =pd.concat([song_data,data_plr.sentiment],axis=1)\nsong_data.head(3)","641eac5b":"song_data[\"key\"] = song_data[\"key\"].astype(\"category\")\nsong_data = pd.get_dummies(song_data, columns=[\"key\"])\nsong_data.head()","569cdbf5":"song_data[\"audio_mode\"] = song_data[\"audio_mode\"].astype(\"category\")\nsong_data = pd.get_dummies(song_data, columns=[\"audio_mode\"])\nsong_data.head()","79659180":"song_data[\"time_signature\"] = song_data[\"time_signature\"].astype(\"category\")\nsong_data = pd.get_dummies(song_data, columns=[\"time_signature\"])\nsong_data.head()","9b3453ca":"song_data.drop([\"song_popularity\",\"song_name\"],axis=1,inplace=True)","81a3b2bc":"song_data.columns[song_data.isnull().any()]","e69bb7f1":"#fill nan values\nsong_data['song_duration_ms'] = song_data['song_duration_ms'].fillna(np.mean(song_data['song_duration_ms']))\nsong_data['acousticness'] = song_data['acousticness'].fillna(np.mean(song_data['acousticness']))\nsong_data['danceability'] = song_data['danceability'].fillna(np.mean(song_data['danceability']))\nsong_data['energy'] = song_data['energy'].fillna(np.mean(song_data['energy']))\nsong_data['instrumentalness'] = song_data['instrumentalness'].fillna(np.mean(song_data['instrumentalness']))\nsong_data['liveness'] = song_data['liveness'].fillna(np.mean(song_data['liveness']))\nsong_data['loudness'] = song_data['loudness'].fillna(np.mean(song_data['loudness']))\nsong_data['speechiness'] = song_data['speechiness'].fillna(np.mean(song_data['speechiness']))\nsong_data['tempo'] = song_data['tempo'].fillna(np.mean(song_data['tempo']))\nsong_data['audio_valence'] = song_data['audio_valence'].fillna(np.mean(song_data['audio_valence']))\nsong_data['popularity'] = song_data['popularity'].fillna(np.mean(song_data['popularity']))","f172786d":"song_data.columns[song_data.isnull().any()]","e64e6474":"def change_type(var):\n    song_data[var] = song_data[var].astype(int)","ecc77e44":"column= [\"sentiment\",\"key_0.0\",\"key_1.0\",\"key_2.0\",\"key_3.0\",\"key_4.0\",\"key_5.0\",\"key_6.0\",\"key_7.0\",\"key_8.0\",\"key_9.0\",\"key_10.0\",\"key_11.0\",\"audio_mode_0.0\",\"audio_mode_1.0\",\"time_signature_0.0\",\"time_signature_1.0\",\"time_signature_3.0\",\"time_signature_4.0\",\"time_signature_5.0\"]\nfor i in column:\n    change_type(i)","9cc39ef3":"#data preparation\ny = song_data[\"popularity\"].values\nx_data=song_data.drop([\"popularity\"],axis=1)\n#normalization\nx = (x_data - np.min(x_data))\/(np.max(x_data)-np.min(x_data)).values#train test split\nfrom sklearn.model_selection import train_test_split\nx_train, x_test, y_train, y_test = train_test_split(x,y,test_size = 0.2,random_state=42)\nx_train = x_train.T\nx_test = x_test.T\ny_train = y_train.astype(int).T\ny_test = y_test.astype(int).T\nprint(\"x_train: \",x_train.shape)\nprint(\"x_test: \",x_test.shape)\nprint(\"y_train: \",y_train.shape)\nprint(\"y_test: \",y_test.shape)","e427bd73":"# parameter initialize and sigmoid function\ndef initialize_weights_and_bias(dimension):\n    w=np.full((dimension,1),0.01)\n    b=0.0\n    return w,b\n\ndef sigmoid(z):\n    y_head = 1\/(1+ np.exp(-z))\n    return y_head","63d0dac4":"def forward_backward_propagation(w,b,x_train,y_train):\n    # forward propagation\n    z = np.dot(w.T,x_train) + b\n    y_head = sigmoid(z)\n    loss = -y_train*np.log(y_head)-(1-y_train)*np.log(1-y_head)\n    cost = (np.sum(loss))\/x_train.shape[1]      \n    # backward propagation\n    derivative_weight = (np.dot(x_train,((y_head-y_train).T)))\/x_train.shape[1] \n    derivative_bias = np.sum(y_head-y_train)\/x_train.shape[1]                 \n    gradients = {\"derivative_weight\": derivative_weight,\"derivative_bias\": derivative_bias}\n    return cost,gradients","edbb26aa":"# Updating(learning) parameters\ndef update(w, b, x_train, y_train, learning_rate,number_of_iterarion):\n    cost_list = []\n    cost_list2 = []\n    index = []\n\n    for i in range(number_of_iterarion):\n        # make forward and backward propagation and find cost and gradients\n        cost,gradients = forward_backward_propagation(w,b,x_train,y_train)\n        cost_list.append(cost)\n        # update\n        w = w - learning_rate * gradients[\"derivative_weight\"]\n        b = b - learning_rate * gradients[\"derivative_bias\"]\n        if i % 10 == 0:\n            cost_list2.append(cost)\n            index.append(i)\n            print (\"Cost after iteration %i: %f\" %(i, cost))\n    \n    parameters = {\"weight\": w,\"bias\": b}\n    plt.plot(index,cost_list2)\n    plt.xticks(index,rotation='vertical')\n    plt.xlabel(\"Number of Iterarion\")\n    plt.ylabel(\"Cost\")\n    plt.show()\n    return parameters, gradients, cost_list","9a19d14e":"def predict(w,b,x_test):\n    z = sigmoid(np.dot(w.T,x_test)+b)\n    Y_prediction = np.zeros((1,x_test.shape[1]))\n\n    for i in range(z.shape[1]):\n        if z[0,i]<= 0.5:\n            Y_prediction[0,i] = 0\n        else:\n            Y_prediction[0,i] = 1\n\n    return Y_prediction","fdc366c7":"def logistic_regression(x_train, y_train, x_test, y_test, learning_rate ,  num_iterations):\n    # initialize\n    dimension =  x_train.shape[0]\n    w,b = initialize_weights_and_bias(dimension)\n    #update\n    parameters, gradients, cost_list = update(w, b, x_train, y_train, learning_rate,num_iterations)\n    y_prediction_test = predict(parameters[\"weight\"],parameters[\"bias\"],x_test)\n    y_prediction_train = predict(parameters[\"weight\"],parameters[\"bias\"],x_train)\n\n    print(\"train accuracy: {} %\".format(100 - np.mean(np.abs(y_prediction_train - y_train)) * 100))\n    print(\"test accuracy: {} %\".format(100 - np.mean(np.abs(y_prediction_test - y_test)) * 100))\n    \nlogistic_regression(x_train, y_train, x_test, y_test,learning_rate =0.01, num_iterations = 200)","aa1b9d21":"x,y = song_data.loc[:,song_data.columns != 'popularity'], song_data.loc[:,'popularity']\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2, random_state=42)\ny=y.astype(int)\ny_train= y_train.astype(int)\ny_test= y_test.astype(int)","ea201f2a":"# ROC Curve with logistic regression\nfrom sklearn.metrics import roc_curve\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import confusion_matrix, classification_report\nlogreg = LogisticRegression()\nlogreg.fit(x_train,y_train)\ny_pred_prob = logreg.predict_proba(x_test)[:,1]\nfpr, tpr, thresholds = roc_curve(y_test, y_pred_prob)\n\n# Plot ROC curve\nplt.plot([0, 1], [0, 1], 'k--')\nplt.plot(fpr, tpr,color=\"red\")\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.title('ROC')\nplt.show()","5dcecd30":"from sklearn.model_selection import cross_val_score\nk = 10\ncv_result = cross_val_score(logreg,x_train,y_train,cv=k)\ncross_val_log=np.sum(cv_result)\/k\nprint('Cross_val Scores: ',cv_result)\nprint('Cross_val scores average: ',np.sum(cv_result)\/k)","259cf043":"#GridSearchCV with Logreg\nfrom sklearn.model_selection import GridSearchCV\nparam_grid = {'C': np.logspace(-3, 3, 7), 'penalty': ['l1', 'l2']}\nlogreg = LogisticRegression()\nlogreg_cv = GridSearchCV(logreg,param_grid,cv=3)\nlogreg_cv.fit(x_train,y_train)\nprint(\"Tuned hyperparameters : {}\".format(logreg_cv.best_params_))\nprint(\"Best Accuracy: {}\".format(logreg_cv.best_score_))\n##numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None, axis=0)","b85d1f27":"Logistic_score=logreg_cv.best_score_\nCrossVal_Logistic_score=cross_val_log","4cb29740":"from sklearn.metrics import mean_squared_error\ndef root_mean_squared_error(y_true, y_pred):\n    return np.sqrt(mean_squared_error(y_true, y_pred))","a5f6621c":"# Ridge\nfrom sklearn.linear_model import Ridge\nridge = Ridge(alpha = 0.1, normalize = True)\nridge.fit(x_train,y_train)\nridge_predict = ridge.predict(x_test)\n#print('Ridge score: ',ridge.score(x_test,y_test))\nprint(\"Test accuracy:\",root_mean_squared_error(y_test,ridge_predict))","2f269982":"Ridge_score= root_mean_squared_error(y_test,ridge_predict)","5b30ed97":"# Lasso\nfrom sklearn.linear_model import Lasso\nx = np.array(song_data.loc[:,['danceability','energy','audio_valence','tempo','song_duration_ms','acousticness','instrumentalness','key','liveness','loudness','audio_mode','speechiness']])\nlasso = Lasso(alpha = 0.1, normalize = True)\nlasso.fit(x_train,y_train)\nlasso_predict = lasso.predict(x_test)\nprint('Lasso coefficients: ',lasso.coef_)\nprint(\"Test accuracy:\",root_mean_squared_error(y_test,lasso_predict))","53bb610e":"Lasso_Score=root_mean_squared_error(y_test,lasso_predict)","d38f8ce4":"x= ['song_duration_ms', 'acousticness', 'danceability',\n     'energy', 'instrumentalness', 'key', 'liveness',\n     'loudness', 'audio_mode', 'speechiness', 'tempo', \n     'time_signature', 'audio_valence']\ny= ['popularity']","7459cce9":"from sklearn import linear_model\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.model_selection import GridSearchCV, train_test_split\nimport sklearn.metrics as metrics\n\ndef test(models, data, iterations = 100):\n    results = {}\n    for i in models:\n        r2_train = []\n        r2_test = []\n        for j in range(iterations):\n            r2_test.append(metrics.r2_score(y_test,\n                                            models[i].fit(x_train, \n                                                         y_train).predict(x_test)))\n            r2_train.append(metrics.r2_score(y_train, \n                                             models[i].fit(x_train, \n                                                          y_train).predict(x_train)))\n        results[i] = [np.mean(r2_train), np.mean(r2_test)]\n    return pd.DataFrame(results)","20c080f6":"models = {'OLS': linear_model.LinearRegression(),\n         'Lasso': linear_model.Lasso(),\n         'Ridge': linear_model.Ridge(),}\ntest(models,song_data)","814837d5":"test(models,song_data)","330abccd":"# KNN prediction\nfrom sklearn.neighbors import KNeighborsClassifier\nknn = KNeighborsClassifier(n_neighbors = 3)\nx,y = song_data.loc[:,song_data.columns != 'popularity'], song_data.loc[:,'popularity']\ny=y.astype(int)\nknn.fit(x,y)\nprediction = knn.predict(x)\nprint('Prediction: {}'.format(prediction))","80492af2":"#KNN Test\nknn = KNeighborsClassifier(n_neighbors = 1)\nknn.fit(x_train,y_train)\nprediction = knn.predict(x_test)\nprint('With KNN (K=3) train accuracy is: ',knn.score(x_train,y_train))\nprint('With KNN (K=3) test accuracy is: ',knn.score(x_test,y_test))","4da2c51a":"neig = np.arange(1, 25)\ntrain_accuracy = []\ntest_accuracy = []\n\nfor i, k in enumerate(neig):\n    knn = KNeighborsClassifier(n_neighbors=k)\n    knn.fit(x_train,y_train)\n    train_accuracy.append(knn.score(x_train, y_train))\n    test_accuracy.append(knn.score(x_test, y_test))\n\nplt.figure(figsize=[10,6])\nplt.plot(neig, test_accuracy, label = 'Testing Accuracy')\nplt.plot(neig, train_accuracy, label = 'Training Accuracy')\nplt.legend()\nplt.title('Knn k value VS Accuracy')\nplt.xlabel('Number of Neighbors')\nplt.ylabel('Accuracy')\nplt.xticks(neig)\nplt.savefig('graph.png')\nplt.show()\nprint(\"Best accuracy is {} with K = {}\".format(np.max(test_accuracy),1+test_accuracy.index(np.max(test_accuracy))))","6c489202":"from sklearn.model_selection import cross_val_score\nk = 10\ncv_result = cross_val_score(knn,x_train,y_train,cv=k)  \ncv_result_knn=np.sum(cv_result)\/k\nprint('Cross_val Scores: ',cv_result)\nprint('Cross_val scores average: ',np.sum(cv_result)\/k)","9e4fd33b":"from sklearn.model_selection import GridSearchCV\ngrid = {'n_neighbors': np.arange(1,50)}\nknn = KNeighborsClassifier()\nknn_cv = GridSearchCV(knn, grid, cv=3) \nknn_cv.fit(x,y)\nprint(\"Tuned hyperparameter k: {}\".format(knn_cv.best_params_)) \nprint(\"Best accuracy: {}\".format(knn_cv.best_score_))","5dc204c0":"KKN_Score= max(test_accuracy)\nCrossVal_KKN_Score=cv_result_knn","3779ad89":"from sklearn.svm import SVC\nsvm= SVC(random_state=1)  #kernel='rbf'\nsvm.fit(x_train,y_train)\nprint(\"Train accuracy of svm algo:\",svm.score(x_train,y_train))\nprint(\"Test accuracy of svm algo:\",svm.score(x_test,y_test))","a0269e89":"from sklearn.model_selection import cross_val_score\nk = 10\ncv_result = cross_val_score(svm,x_train,y_train,cv=k) \ncv_result_svm= np.sum(cv_result)\/k\nprint('Cross_val Scores: ',cv_result)\nprint('Cross_val scores average: ',np.sum(cv_result)\/k)","fd89bd00":"SVM_score= svm.score(x_test,y_test)\nCrossVal_SVM_score=cv_result_svm","8703380b":"from sklearn.svm import SVC\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.pipeline import Pipeline\n\nsteps = [('scalar', StandardScaler()),\n         ('SVM', SVC())]\npipeline = Pipeline(steps)\nparameters = {'SVM__C':[1, 10, 100],\n              'SVM__gamma':[0.1, 0.01]}\ncv = GridSearchCV(pipeline,param_grid=parameters,cv=10)\ncv.fit(x_train,y_train)\ny_pred = cv.predict(x_test)\n\nprint(\"Tuned Model Parameters: {}\".format(cv.best_params_))\nprint(\"Test accuracy: {}\".format(cv.score(x_test, y_test)))","8fe09ddf":"from sklearn.naive_bayes import GaussianNB\nnb= GaussianNB()\nnb.fit(x_train,y_train)\nprint(\"Train accuracy of naive bayes:\",nb.score(x_train,y_train))\nprint(\"Test accuracy of naive bayes:\",nb.score(x_test,y_test))\n","bf9d4365":"Naive_bayes_score=nb.score(x_test,y_test)","6b4f045b":"from sklearn.metrics import accuracy_score,recall_score,precision_score,confusion_matrix,f1_score\nfrom sklearn.tree import DecisionTreeClassifier\n\ndt= DecisionTreeClassifier()\ndt.fit(x_train,y_train)\ny_pred=dt.predict(x_test)\nDecisionTree_score=dt.score(x_test,y_test)\nprint(\"Train ccuracy of decision tree:\",dt.score(x_train,y_train))\nprint(\"Test accuracy of decision tree:\",dt.score(x_test,y_test))","f69397b0":"from sklearn.model_selection import cross_val_score\nk =10\ncv_result = cross_val_score(dt,x_train,y_train,cv=k) # uses R^2 as score \nprint('Cross_val Scores: ',cv_result)\nprint('Cross_val scores average: ',np.sum(cv_result)\/k)","08b1a803":"from sklearn.ensemble import RandomForestClassifier\nrf=RandomForestClassifier(n_estimators=150,random_state = 3)\nrf.fit(x_train,y_train)\nprint(\"Train ccuracy of random forest\",rf.score(x_train,y_train))\nprint(\"Test accuracy of random forest\",rf.score(x_test,y_test))\nRandomForestClassifier_score=rf.score(x_test,y_test)\ny_pred=rf.predict(x_test)\nt_true=y_test","ed96606d":"from sklearn.model_selection import cross_val_score\nk = 10\ncv_result = cross_val_score(rf,x_train,y_train,cv=k) # uses R^2 as score \ncv_result_randomforest=np.sum(cv_result)\/k\nprint('Cross_val Scores: ',cv_result)\nprint('Cross_val scores average: ',np.sum(cv_result)\/k)","8da6ac74":"CrossVal_RandomForestClassifier_score=cv_result_randomforest","50b4c466":"from sklearn.metrics import classification_report, confusion_matrix\nfrom sklearn.ensemble import RandomForestClassifier\n\nrf = RandomForestClassifier(random_state = 4)\nrf.fit(x_train,y_train)\ny_pred = rf.predict(x_test)\ncm = confusion_matrix(y_test,y_pred)\nprint('Confusion matrix: \\n',cm)\nprint('Classification report: \\n',classification_report(y_test,y_pred))","531dd088":"sns.heatmap(cm,annot=True,fmt=\"d\") \nplt.show()","153c0ebc":"#Voting Classifier\nfrom sklearn.ensemble import VotingClassifier\nensemble=VotingClassifier(estimators=[('Random Forest', rf), ('Logistic Regression', logreg)], \n                       voting='soft', weights=[2,1]).fit(x_train,y_train)\nprint('The train accuracy for Random Forest and Logistic Regression is:',ensemble.score(x_train,y_train))\nprint('The test accuracy for Random Forest and Logistic Regression is:',ensemble.score(x_test,y_test))","9d6db32d":"from sklearn.model_selection import cross_val_score\nk = 5\ncv_result = cross_val_score(ensemble,x_train,y_train,cv=k) # uses R^2 as score \nprint('Cross_val Scores: ',cv_result)\nprint('Cross_val scores average: ',np.sum(cv_result)\/k)","90da3a18":"# plot feature importance manually\nfrom numpy import loadtxt\nfrom xgboost import XGBClassifier\nfrom matplotlib import pyplot\n\n# fit model no training data\nmodel = XGBClassifier()\nmodel.fit(x_train, y_train)\n# feature importance\nprint(model.feature_importances_)\n# plot\n#pyplot.bar(range(len(model.feature_importances_)), model.feature_importances_)\n#pyplot.show()","46e18dbb":"from numpy import loadtxt\nfrom xgboost import XGBClassifier\nfrom xgboost import plot_importance\nfrom matplotlib import pyplot\n\nmodel = XGBClassifier()\nmodel.fit(x_train, y_train)\n\n# plot feature importance\nax = plot_importance(model)\nfig = ax.figure\nfig.set_size_inches(10, 7)\n#plot_importance(model)\npyplot.show()","bfad435f":"from numpy import sort\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.feature_selection import SelectFromModel\n\nmodel = XGBClassifier()\nmodel.fit(x_train, y_train)\ny_pred = model.predict(x_test)\npredictions = [round(value) for value in y_pred]\naccuracy = accuracy_score(y_test, predictions)\nprint(\"Accuracy: %.2f%%\" % (accuracy * 100.0))\n\nthresholds = sort(model.feature_importances_) # Fit model using each importance as a threshold\n\nfor thresh in thresholds:\n    # select features using threshold\n    selection = SelectFromModel(model, threshold=thresh, prefit=True) # if prefit=True, you should call transform directly.\n    select_X_train = selection.transform(x_train)\n    # train model \n    selection_model = XGBClassifier()\n    selection_model.fit(select_X_train, y_train)\n    # evaluate model\n    select_X_test = selection.transform(x_test)\n    y_pred = selection_model.predict(select_X_test)\n    predictions = [round(value) for value in y_pred]\n    accuracy = accuracy_score(y_test, predictions)\n    print(\"Thresh=%.3f, n=%d, Accuracy: %.2f%%\" % (thresh, select_X_train.shape[1], accuracy*100.0))","b7fdf966":"model_performances=pd.DataFrame({'Model':['RandomForestClassifier','SVM','DesicionTreeClassifier','K-NearestNeighbors','LogisticRegession','NaiveBayes','Ridge','Lasso'],\n                                 'Accuracy':[RandomForestClassifier_score,SVM_score,DecisionTree_score,KKN_Score,Logistic_score,Naive_bayes_score,Ridge_score,Lasso_Score]})\nmodel_performances.sort_values(by = \"Accuracy\",ascending=False)","e1fb9924":"model_list= list(model_performances['Model'].unique())\naccuracy_list= list(model_performances['Accuracy'].sort_values(ascending=False))\nf,ax = plt.subplots(figsize = (4,6))\nsns.barplot(x=accuracy_list,y=model_list,color='green',alpha = 0.5)\nax.set(xlabel='Test Accuracies', ylabel='Models')\nplt.show()\n","b6bbcc4d":"labels = ['RF','SVM', 'K-NN', 'LR']\naccuracy = [0.897531,0.885054, 0.789488,0.710711]\nvalidation = [0.878750, 0.875631, 0.714693, 0.710711]\n\nx = np.arange(len(labels))\nwidth = 0.35\n\nfig, ax = plt.subplots(figsize=(12, 5))\nrects1 = ax.bar(x - width\/2,accuracy, width, label='Accuracy')\nrects2 = ax.bar(x + width\/2, validation, width, label='Validation')\n\nax.set_xticks(x)\nax.set_xticklabels(labels)\nax.legend()\n\ndef autolabel(rects):\n    for rect in rects:\n        height = rect.get_height()\n        ax.annotate('{}'.format(height),\n                    xy=(rect.get_x() + rect.get_width() \/ 2, height),\n                    xytext=(0, 2),\n                    textcoords=\"offset points\",\n                    ha='center', va='bottom')\n        \nautolabel(rects1)\nautolabel(rects2)\nfig.tight_layout()\nplt.show()","dae817c3":"**ROC Curve with Logistic Regression**","0df00437":"> ## Features Distribution\n","d427298a":"<a id=\"2\"><\/a> \n## Import Libraries","f2d05913":"## Why Do Some Songs Become Popular?","b329329d":"## Basic Data Analysis","1b160fa5":"> ## People like Happy Songs or Sad Songs?\n- As we see in the feature explanations, audio valance describes the musical positiveness conveyed by a track (like sad or happiness - between 0 to 1). We supposed our threshold is 0.5.\n- With this threshold we have happy songs more in the general data and the numbers are pretty close in the popular songs, but when we looked at top 500, we can say that negative songs are twice as much as positives.","04f8fec5":"<a id=\"0\"><\/a> <br>\n\n> ## Introduction\n- Currently, being able to predict that something might be popular beforehand is an important research subject for every industry. It also has recently became a very important subject for the growing and competitive music industry as well. Since wide use of digital music platforms (Spotify, Billboard, Lastfm), data can be easily reached and the listening behaviors of the listeners can be easily observed. This provides convenience in forecasting techniques and it is also frequently used in recommendation systems.","65f5d629":"## Categorical Variable Analysis","eb8e1a99":"**All Songs**","6f29a01f":"<a id=\"6\"><\/a> <br>\n**KNN Algorithm**","45a42980":"# <a id=\"1\"><\/a> <br>\n> ## Feature Explanations\n- Dataset contains 19.000 songs and has 15 features like duration ms, key, audio mode, acousticness, danceability, energy and so on .\n- duration_ms: The duration of the track in milliseconds.\n- key: The estimated overall key of the track. Integers map to pitches using standard Pitch Class notation . E.g. 0 = C, 1 = C\u266f\/D\u266d, 2 = D, and so on. If no key was detected, the value is -1.\n- audio_mode: Mode indicates the modality (major or minor) of a track, the type of scale from which its melodic content is derived. Major is represented by 1 and minor is 0.\n- time_signature: An estimated overall time signature of a track. The time signature (meter) is a notational convention to specify how many beats are in each bar (or measure).\n- acousticness: A confidence measure from 0.0 to 1.0 of whether the track is acoustic. 1.0 represents high confidence the track is acoustic.\n- danceability: Danceability describes how suitable a track is for dancing based on a combination of musical elements including tempo, rhythm stability, beat strength, and overall regularity. A value of 0.0 is least danceable and 1.0 is most danceable.\n- energy: Energy is a measure from 0.0 to 1.0 and represents a perceptual measure of intensity and activity. Typically, energetic tracks feel fast, loud, and noisy. For example, death metal has high energy, while a Bach prelude scores low on the scale. \n- instrumentalness: Detects the presence of an audience in the recording. Higher liveness values represent an increased probability that the track was performed live. A value above 0.8 provides strong likelihood that the track is live.\n- loudness: The overall loudness of a track in decibels (dB). Loudness values are averaged across the entire track and are useful for comparing relative loudness of tracks. Loudness is the quality of a sound that is the primary psychological correlate of physical strength (amplitude). Values typical range between -60 and 0 db.\n- speechiness: Speechiness detects the presence of spoken words in a track. The more exclusively speech-like the recording (e.g. talk show, audio book, poetry), the closer to 1.0 the attribute value. Values above 0.66 describe tracks that are probably made entirely of spoken words. Values between 0.33 and 0.66 describe tracks that may contain both music and speech, either in sections or layered, including such cases as rap music.Values below 0.33 most likely represent music and other non-speech-like tracks.\n- audio_valence: A measure from 0.0 to 1.0 describing the musical positiveness conveyed by a track. Tracks with high valence sound more positive (e.g. happy, cheerful, euphoric), while tracks with low valence sound more negative (e.g. sad, depressed, angry).\n- tempo: The overall estimated tempo of a track in beats per minute (BPM). In musical terminology, tempo is the speed or pace of a given piece and derives directly from the average beat duration. \n- song_popularity: Song ratings of spotify audience.\n- liveness: Detects the presence of an audience in the recording. Higher liveness values represent an increased probability that the track was performed live.","19774710":"<a id=\"4\"><\/a> <br>\n**Logistic Regression**","e47e59a3":"> <a id=\"10\"><\/a> <br>\n**Random Forest Classifier**\n- RF is one of the most popular ensemble learning method in machine learning not only gives good results even without hyperparameter optimization\u00a0but also can use both classification and regression problems. But the common problem of the traditional decision trees is over-fitting. In order to avoid overfitting, random forest models select and train hundreds of different sub-samples (multiple deep decision trees) randomly and reduce the variance. We used 100 estimators and random state 3 gave the about % 89 accuracy. ","e7a29936":"- Correlation between loudness and energy is 0.8 which is strong and correlation between loudness and accusticness is 0.6 which is moderate. Except two of them all the correlations are quite low. When we compare the correlation between song_popularity and all other features, we don't see a strong correlation (a linear relationship) that gives us a clear information about popularity. Accusticness,danceability and loudness seems to have correlation with popularity feature(0.10) and istrumentalness has 0.20.","f19854dd":"**SENTIMENTAL ANALYSIS**","8784515b":"<a id=\"13\"><\/a> <br>\n## Conclusion\n\nFirst we tried to predict popular songs using audio features then we added song name texts\u2019 polarity to it and tried to improve our model. We also fitted the model using each importance as a threshold. Although accusticness is the most important of these features\u00a0did not lead us to a strong result.  \nWe had 18835 songs available. Decision Tree algorithms which mainly given better results when we don\u2019t have so much data got the best result with RF. There were no strong linear correlations in our data, so linear methods did not fit well. In LR, We built the model using the gradient decent and this gave the best result in 200 iterations which was a moderate result. As in many popularity studies, we achieved the second best result with SVM. Adding Polarity to features value has almost not changed the result at all .\nFor the future work, the following questions can be asked. Nowadays, the industrialization of popular music has became more common all over the world and most musicians are using computers when they create their songs. So are songs started to be more similar and less unique? Does these affect our predictions in a positive way? With industrialization, prediction of the popular and trendy items are getting easier? Could the prediction increase if we had data with all the songs are created by a computer?","912d1aef":"- LR is one of the basic classi\ufb01cation method is used prediction of categorical variables.Our problem has two possible outputs popular(1) and unpopular(0) which is suitable for binary logistic regression. Since it is a probability value that we want to get from the problem, we obtained a value between [0,1] using the sigmoid function.  \n\u03b1(z) = 1\/(1+e-z)\n- Binary cross entropy is used for the loss function and gradient descent for the update the parameters.","1c34b437":"**Confusion Matrix with Random Forest**","64887648":"<a id=\"7\"><\/a> <br>\n**SVM**","e421a42a":"- 60's and 70's rock music seems more popular in this data.","1cce80d3":"<a id=\"11\"><\/a> <br>\n## FEATURE IMPORTANCE","755a14e8":" <a id=\"3a\"><\/a> \n## Cleaning Data","1120caf5":"<a id=\"9\"><\/a> <br>\n**Decision Tree Classifier**","20c646d3":"- Checked popularity rating of songs that have been popular in the last 10 years in Spotify and took the mean value of them (66.5) . According to this value, the songs has above this rating could remain on the top lists for a long time. If song_popularity is higher than 66.5 (this is about 30% percent of data) we labeled it \"1\" and if is not we labeled it \"0\". So we have \"1\" for the popular songs and \"0\" for the unpopular ones.","a1b1e8de":" <a id=\"3c\"><\/a> \n## Feature Engineering","955aa636":"<a id=\"5\"><\/a> <br>\n**Ridge and Lasso Regression**","f128782a":" <a id=\"3b\"><\/a> \n## Analysis","c1fe65fb":"<a id=\"8\"><\/a> <br>\n**Naive Bayes**","62f1e6ac":" <a id=\"3\"><\/a> \n ## Data Preparation and Analysis","ddb8469f":"- Data distribution of songs display today's songs features like dancebility, energy, loudness and tempo are quite high. People like fast and loud music.\n- According to instrumentalness, liveness and speechness, most of the songs are not live performances and they have lyrics.\n- Keys like 0,1,5,6 and 11 seems more effective in songs. And if key== 0 or 1 or 6 song has more chance to be populer.\n- Time_signure is mostly 4 and 5 in both populer and general data.\n- If danceability>0.6 song has more chance to be popular.\n- If loudness > -10 song has more chance to be popular.\n","b6a1d0d7":"**Top 500**","223dc710":"![music.jpg](attachment:music.jpg)","c92acb43":"**Populer Songs**","a47bc563":"<a id=\"12\"><\/a> <br>\n## Comparison Of Performance","3b19a87e":"- SVM is an effective and simple method mostly used in classification problems. The aim of the SVM algorithm is to find a hyperplane in an N-dimensional space (N \u2014 the number of features) that distinctly classifies the data points. C and Gamma are the parameters for a nonlinear support vector machine (SVM) with a Gaussian radial basis function kernel.","8dc522ce":"<a id=\"4a\"><\/a> <br>\n## Models","5ee3ed5e":"- Since we set our threshold such that 70% of the songs in our dataset are named as not popular and 30% are named as popular, 70% accuracy can be achieved by predicting all 0s. In order to capture this, we should consider the precision and recall values. As we see in confusion matrix, model predicted \u201c695 popular\u201d songs and \u201c2596 unpopular\u201d songs correct.\n","a9952d03":"- [Introduction](#0)\n- [Feature explanations](#1)\n- [Import Libraries](#2)\n- [Data Preparation and Analysis](#3)\n    * [Cleaning the data](#3a)\n    * [Analysis](#3b)\n    * [Feature Engineering](#3c)\n- [Models](#4a)\n    * [Logistic Regression](#4)\n    * [Ridge and Lasso Regression](#5)\n    * [KNN Algorithm](#6)\n    * [SVM](#7)\n    * [Naive Bayes](#8)\n    * [Decision Tree Classifier](#9)\n    * [Random Forest Classifier](#10)\n    * [Feature Importance](#11)\n    * [Comparison Of Performance](#12)\n    * [Conclusion](#13)\n"}}