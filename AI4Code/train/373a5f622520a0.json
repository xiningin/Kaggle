{"cell_type":{"0ece6326":"code","870644f2":"code","6a8ba0a0":"code","1f22371a":"code","4eaef4c1":"code","f23b6af7":"code","1d4155fd":"code","acdbc72b":"code","9ef9b2a8":"code","2decab9c":"code","9931b698":"code","28b6c6cb":"code","929a471e":"code","e38d0373":"code","4cdc778e":"code","5191c01a":"code","69307590":"code","fe461796":"code","35d7b094":"code","8ac5f74e":"code","22e8b708":"code","e6be441b":"code","e70c8838":"code","97c40a05":"code","96f109df":"code","85e7b332":"code","7914ae17":"code","956bcbbb":"code","7c1fefe0":"code","57d774a1":"code","dfe6be98":"code","d88066f6":"code","973bfb22":"markdown","4461d029":"markdown","6481a5b0":"markdown","2132a29e":"markdown","233e8897":"markdown","63b10301":"markdown","349fe6ca":"markdown","8b6582b6":"markdown","be46ddbf":"markdown","d9c8da69":"markdown","09a33ee8":"markdown","9eb62550":"markdown"},"source":{"0ece6326":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","870644f2":"train=pd.read_csv('\/kaggle\/input\/pubg-finish-placement-prediction\/train_V2.csv')\ntest=pd.read_csv('\/kaggle\/input\/pubg-finish-placement-prediction\/test_V2.csv')\nsample_submission=pd.read_csv('\/kaggle\/input\/pubg-finish-placement-prediction\/sample_submission_V2.csv')\n","6a8ba0a0":"sample_submission.head()","1f22371a":"train.head()","4eaef4c1":"test.head()","f23b6af7":"train.isnull().sum()","1d4155fd":"train.dropna(axis=0,inplace=True)","acdbc72b":"test.isnull().sum()","9ef9b2a8":"train.columns","2decab9c":"import seaborn as sns\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(10,6))\nsns.distplot(train[\"DBNOs\"],hist=True)\nplt.show()","9931b698":"# Boxplot of DBNOs variable\n\ntrain[\"DBNOs\"].plot.box(figsize=(10,6))\nplt.show()","28b6c6cb":"train[\"kills\"].describe()","929a471e":"# Distribution plot of no. of kills\n\nplt.figure(figsize=(10,6))\nsns.distplot(train[\"kills\"],hist=True)\nplt.title(\"No. of Kills\")\nplt.show()","e38d0373":"# Grouping kills wrt matchType and plotting the barchart\n\nplt.figure(figsize=(10,6))\ntrain.groupby(\"matchType\")[\"kills\"].mean().plot.bar(color = \"lightgreen\")\nplt.title(\"kills wrt matchType\")\nplt.show()           ","4cdc778e":"fig,ax=plt.subplots(figsize=(20,15))\nax=sns.heatmap(train.corr(),annot=True)","5191c01a":"plt.figure(figsize=(9,7))\nmatch_dur=train.groupby('matchType')['matchDuration'].agg('mean')\nsns.barplot(x=match_dur.index,y=match_dur)\nplt.gca().set_xticklabels(match_dur.index,rotation='45')\nplt.gca().set_title('mean match-type duration')\nplt.show()\nplt.savefig('duration')\n","69307590":"train['boosts+heals'] = train['boosts']+train['heals']\ntrain['matchDuration_min'] = train['matchDuration']\/60\ntrain['teamwork'] = train['assists'] + train['revives']\ntrain['revives-teamKills'] = train['revives'] - train['teamKills']\ntrain['total_distance'] = train['swimDistance'] + train['rideDistance'] + train['walkDistance']\n\ntrain['headshotKills\/kills'] = train['headshotKills'] \/ train['kills']\ntrain['headshotKills\/kills'].fillna(0, inplace=True)\ntrain['headshotKills\/kills'].replace(np.inf, 0, inplace=True)\n\ntrain['killPlace\/maxPlace'] = train['killPlace'] \/ train['maxPlace']\ntrain['killPlace\/maxPlace'].fillna(0, inplace=True)\ntrain['killPlace\/maxPlace'].replace(np.inf, 0, inplace=True)\n\ntrain['walkDistance\/heals'] = train['walkDistance'] \/ train['heals']\ntrain['walkDistance\/heals'].fillna(0, inplace=True)\ntrain['walkDistance\/heals'].replace(np.inf, 0, inplace=True)\n\ntrain['walkDistance\/kills'] = train['walkDistance'] \/ train['kills']\ntrain['walkDistance\/kills'].fillna(0, inplace=True)\ntrain['walkDistance\/kills'].replace(np.inf, 0, inplace=True)\n\ntrain['killStreaks\/kills'] = train['killStreaks'] \/ train['kills']\ntrain['walkDistance\/kills'].fillna(0, inplace=True)\ntrain['walkDistance\/kills'].replace(np.inf, 0, inplace=True)\n\ntrain['total_distance\/weaponsAcquired'] = train['total_distance'] \/ train['weaponsAcquired']\ntrain['total_distance\/weaponsAcquired'].fillna(0, inplace=True)\ntrain['total_distance\/weaponsAcquired'].replace(np.inf, 0, inplace=True)\n\ntrain['heals\/walkDistance'] = train['heals'] \/train['walkDistance']  \ntrain['heals\/walkDistance'].fillna(0, inplace=True)\ntrain['heals\/walkDistance'].replace(np.inf, 0, inplace=True)\n\ntrain['kills\/walkDistance'] = train['kills'] \/ train['walkDistance']\ntrain['kills\/walkDistance'].fillna(0, inplace=True)\ntrain['kills\/walkDistance'].replace(np.inf, 0, inplace=True)\n\ntrain['killPlace\/kills'] = train['killPlace'] \/ train['kills']\ntrain['killPlace\/kills'].fillna(0, inplace=True)\ntrain['killPlace\/kills'].replace(np.inf, 0, inplace=True)\n\ntrain['walkDistance\/matchDuration'] =  train[\"walkDistance\"] \/ train[\"matchDuration\"]\ntrain['walkDistance\/matchDuration'].fillna(0, inplace=True)\ntrain['walkDistance\/matchDuration'].replace(np.inf, 0, inplace=True)\n","fe461796":"test['boosts+heals'] = test['boosts']+test['heals']\ntest['matchDuration_min'] = test['matchDuration']\/60\ntest['teamwork'] = test['assists'] + test['revives']\ntest['revives-teamKills'] = test['revives'] - test['teamKills']\ntest['total_distance'] = test['swimDistance'] + test['rideDistance'] + test['walkDistance']\n\ntest['headshotKills\/kills'] = test['headshotKills'] \/ test['kills']\ntest['headshotKills\/kills'].fillna(0, inplace=True)\ntest['headshotKills\/kills'].replace(np.inf, 0, inplace=True)\n\ntest['killPlace\/maxPlace'] = test['killPlace'] \/ test['maxPlace']\ntest['killPlace\/maxPlace'].fillna(0, inplace=True)\ntest['killPlace\/maxPlace'].replace(np.inf, 0, inplace=True)\n\ntest['walkDistance\/heals'] = test['walkDistance'] \/ test['heals']\ntest['walkDistance\/heals'].fillna(0, inplace=True)\ntest['walkDistance\/heals'].replace(np.inf, 0, inplace=True)\n\ntest['walkDistance\/kills'] = test['walkDistance'] \/ test['kills']\ntest['walkDistance\/kills'].fillna(0, inplace=True)\ntest['walkDistance\/kills'].replace(np.inf, 0, inplace=True)\n\ntest['killStreaks\/kills'] = test['killStreaks'] \/ test['kills']\ntest['walkDistance\/kills'].fillna(0, inplace=True)\ntest['walkDistance\/kills'].replace(np.inf, 0, inplace=True)\n\ntest['total_distance\/weaponsAcquired'] = test['total_distance'] \/ test['weaponsAcquired']\ntest['total_distance\/weaponsAcquired'].fillna(0, inplace=True)\ntest['total_distance\/weaponsAcquired'].replace(np.inf, 0, inplace=True)\n\ntest['heals\/walkDistance'] = test['heals'] \/test['walkDistance']  \ntest['heals\/walkDistance'].fillna(0, inplace=True)\ntest['heals\/walkDistance'].replace(np.inf, 0, inplace=True)\n\ntest['kills\/walkDistance'] = test['kills'] \/ test['walkDistance']\ntest['kills\/walkDistance'].fillna(0, inplace=True)\ntest['kills\/walkDistance'].replace(np.inf, 0, inplace=True)\n\ntest['killPlace\/kills'] = test['killPlace'] \/ test['kills']\ntest['killPlace\/kills'].fillna(0, inplace=True)\ntest['killPlace\/kills'].replace(np.inf, 0, inplace=True)\n\ntest['walkDistance\/matchDuration'] =  test[\"walkDistance\"] \/ test[\"matchDuration\"]\ntest['walkDistance\/matchDuration'].fillna(0, inplace=True)\ntest['walkDistance\/matchDuration'].replace(np.inf, 0, inplace=True)\n","35d7b094":"dropped_cols = [\"Id\", \"matchId\", \"groupId\", \"matchType\"]\ntrain.drop(dropped_cols,axis=1,inplace=True)\ntest.drop(dropped_cols,axis=1,inplace=True)","8ac5f74e":"X = train.drop('winPlacePerc',axis=1)\ny = train['winPlacePerc']","22e8b708":"from sklearn.model_selection import train_test_split\n\ntest_size=0.20\nseed=42\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=seed)","e6be441b":"import gc\ndel train\ngc.collect()","e70c8838":"params2 = {\n        \"objective\" : \"regression\", \n        \"metric\" : \"mae\", \n        \"num_leaves\" : 150, \n        \"learning_rate\" : 0.03, \n        \"bagging_fraction\" : 0.9,\n        \"bagging_seed\" : 0, \n        \"num_threads\" : 4,\n        \"colsample_bytree\" : 0.5,\n        'min_data_in_leaf':1900, \n        'lambda_l2':9\n}","97c40a05":"import lightgbm as lgb\nreg2 = lgb.LGBMRegressor(**params2, n_estimators=2000)","96f109df":"reg2.fit(X_train, y_train)","85e7b332":"pred2 = reg2.predict(X_test, num_iteration=reg2.best_iteration_)","7914ae17":"from sklearn.metrics import mean_absolute_error\nmean_absolute_error(y_test, pred2)","956bcbbb":"predictions = reg2.predict(test, num_iteration=reg2.best_iteration_)","7c1fefe0":"predictions","57d774a1":"sample_submission['winPlacePerc'] = predictions","dfe6be98":"sample_submission","d88066f6":"sample_submission.to_csv('submission.csv',index=False)","973bfb22":"## Loading the data","4461d029":"## Feature Engineering","6481a5b0":"That's a good score. So, I will continue with prediction on the test set.","2132a29e":"From the above boxplot, we can clearly see the presence of outliers in the DBNOs variable.","233e8897":"Using light-gbm with the following parameters","63b10301":"Deleting train dataframe as it will help free up space in RAM","349fe6ca":"Inferences that can be drawn the above heatmap are as follows: \n\n* killPoints and winPoints are highly correlated with each other having the correlation coefficient of 0.98.\n* walkDistance and winPlacePerc are strongly correlated having the correlation coefficient of 0.81.\n* kills and killStreaks are strongly correlated having the correlation coefficient of 0.80.\n* kills and damageDealth are strongly correlated with the correlation coefficient of 0.89.","8b6582b6":"The number of kills is highest for **normal-solo** and **normal-solo-fpp**.","be46ddbf":"From the above graph, it can be clearly seen that the values of DBNOs varies from 0 to 50 but the maximum values lies betwen 0 to 15.","d9c8da69":"## Modeling","09a33ee8":"# **Description of the features**\n\nDBNOs - Number of enemy players knocked.<br>\n\nassists - Number of enemy players this player damaged that were killed by teammates.<br>\n\nboosts - Number of boost items used.<br>\n\ndamageDealt - Total damage dealt. Note: Self inflicted damage is subtracted.<br>\n\nheadshotKills - Number of enemy players killed with headshots.<br>\n\nheals - Number of healing items used.<br>\n\nId - Player\u2019s Id<br>\n\nkillPlace - Ranking in match of number of enemy players killed.<br>\n\nkillPoints - Kills-based external ranking of player. (Think of this as an Elo ranking where only kills matter.) If there is a value other than -1 in rankPoints, then any 0 in killPoints should be treated as a \u201cNone\u201d.<br>\n\nkillStreaks - Max number of enemy players killed in a short amount of time.<br>\n\nkills - Number of enemy players killed.<br>\n\nlongestKill - Longest distance between player and player killed at time of death. This may be misleading, as downing a player and driving away may lead to a large longestKill stat.<br>\n\nmatchDuration - Duration of match in seconds.<br>\n\nmatchId - ID to identify match. There are no matches that are in both the training and testing set.<br>\n\nmatchType - String identifying the game mode that the data comes from. The standard modes are \u201csolo\u201d, \u201cduo\u201d, \u201csquad\u201d, \u201csolo-fpp\u201d, \u201cduo-fpp\u201d, and \u201csquad-fpp\u201d; other modes are from events or custom matches.<br>\n\nrankPoints - Elo-like ranking of player. This ranking is inconsistent and is being deprecated in the API\u2019s next version, so use with caution. Value of -1 takes place of \u201cNone\u201d.<br>\n\nrevives - Number of times this player revived teammates.<br>\n\nrideDistance - Total distance traveled in vehicles measured in meters.<br>\n\nroadKills - Number of kills while in a vehicle.<br>\n\nswimDistance - Total distance traveled by swimming measured in meters.<br>\n\nteamKills - Number of times this player killed a teammate.<br>\n\nvehicleDestroys - Number of vehicles destroyed.<br>\n\nwalkDistance - Total distance traveled on foot measured in meters.<br>\n\nweaponsAcquired - Number of weapons picked up.<br>\n\nwinPoints - Win-based external ranking of player. (Think of this as an Elo ranking where only winning matters.) If there is a value other than -1 in rankPoints, then any 0 in winPoints should be treated as a \u201cNone\u201d.<br>\n\ngroupId - ID to identify a group within a match. If the same group of players plays in different matches, they will have a different groupId each time.<br>\n\nnumGroups - Number of groups we have data for in the match.<br>\n\nmaxPlace - Worst placement we have data for in the match. This may not match with numGroups, as sometimes the data skips over placements.<br>\n\nwinPlacePerc - The target of prediction. This is a percentile winning placement, where 1 corresponds to 1st place, and 0 corresponds to last place in the match. It is calculated off of maxPlace, not numGroups, so it is possible to have missing chunks in a match.<br>\n","9eb62550":"## EDA"}}