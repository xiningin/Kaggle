{"cell_type":{"21998c4b":"code","52b069ea":"code","c3a84f09":"code","e5081e7a":"code","1b703509":"code","20af729c":"code","58b6e2b2":"code","9d7afca9":"code","e4ff4b69":"code","570dcafc":"code","4bb25123":"code","8780c14c":"code","785fa8b9":"code","6bb01ada":"code","e098d439":"code","99220926":"code","be9e6fd9":"code","d9101dbc":"code","01c948f4":"code","d65ca760":"code","94aa0f13":"code","e04003d0":"code","46036945":"code","96763e72":"code","42d03dfc":"code","be8a2f2c":"code","5a17d9bc":"code","9a5b5004":"code","b5330204":"code","61ade639":"code","b148c0b2":"code","baf0382f":"code","df8970d2":"markdown","0f1a3e19":"markdown","844c0d91":"markdown","31c5be37":"markdown","90f0f04d":"markdown","2681d262":"markdown","a0469113":"markdown","ca6931ea":"markdown","d1a1859e":"markdown","ac1a8359":"markdown","f8ba771a":"markdown","ba5c58a5":"markdown","74e0bfe2":"markdown"},"source":{"21998c4b":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","52b069ea":"import numpy as np \nimport pandas as pd\nimport os","c3a84f09":"import tensorflow as tf\ntf.__version__\ndevice_name = tf.test.gpu_device_name()\nif \"GPU\" not in device_name:\n    print(\"GPU device not found\")\nprint('Found GPU at: {}'.format(device_name))","e5081e7a":"tf.test.is_gpu_available()","1b703509":"from tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.metrics import Precision, Recall, AUC\nfrom tensorflow.keras.layers import Conv2D, MaxPooling2D, Dense, Dropout, Input, Flatten,BatchNormalization,Activation\nfrom tensorflow.keras.layers import GlobalMaxPooling2D, GlobalAveragePooling2D\nfrom tensorflow.keras.callbacks import ModelCheckpoint, Callback, EarlyStopping","20af729c":"main_path = '..\/input\/digit-recognizer\/'\ntrain_df = pd.read_csv(main_path + 'train.csv')\ntest_df = pd.read_csv(main_path + 'test.csv')","58b6e2b2":"i = 3*32\nimg_size = (28*28,)\nX, y = np.zeros((i,) + img_size, dtype = \"float32\"), np.zeros((i,) + img_size, dtype = \"float32\")\nfor sample in range(i):\n    img = train_df.iloc[sample,1:]\n    X[ sample,:] = img\n    y[ sample,:] = img","9d7afca9":"img.shape, X.shape, X.reshape(96,784,).shape","e4ff4b69":"# split the training and testing dataframes    \ndef split_train_DF(df, train_perc):\n    # train_perc --> the percentage in the training set\n    final_train_df = df.iloc[0:round(train_perc*len((df.label))),:]\n    val_df = df.iloc[round(train_perc*len((df.label))):,:]\n    \n    return final_train_df, val_df    \n\n\n# catch statement: checks and verifies if the split was correct and \n# information\/data was lost    \ndef verify_traintest_split(dataset, train_set, test_set):\n    \n    Total, train_A, train_B = len(dataset), len(train_set), len(test_set)\n    if Total == (train_A + train_B): print('Splitting the dataset into testing and training is successful ...\\n')\n    else: print('Splitting the dataset into testing and training failed ...')\n    return","570dcafc":"from sklearn.model_selection import KFold\nimport matplotlib.pyplot as plt\n\n\ntrain_perc = 0.8\nnew_train_df, val_df = split_train_DF(train_df, train_perc)\n# check if the dataframe was properly split ... \nverify_traintest_split(train_df, new_train_df, val_df)\ncolumn_names = train_df.columns","4bb25123":"from tensorflow.keras import layers\nfrom tensorflow.keras.models import Model\n\n\n\n\ndef get_model(latent_space = 32):\n\n    input_img = Input(shape = (28*28,))\n    encoded = Dense(latent_space, activation = 'relu')(input_img)\n    decoded = Dense(28*28, activation = 'sigmoid')(encoded)\n    return Model(input_img, decoded)\n\n\nperc_autoencoder = get_model()\nopt = tf.keras.optimizers.SGD(learning_rate=0.0100000231231)\nperc_autoencoder.compile(optimizer=opt, loss='binary_crossentropy')\nperc_autoencoder.summary()","8780c14c":"train_df.iloc[:,0]","785fa8b9":"from tqdm import tqdm \nfrom sklearn.model_selection import train_test_split\nimport numpy as np\n\n\nX = np.zeros((len(train_df), 28*28,), dtype='float32')\ny = np.zeros((len(train_df), 1), dtype='float32')\n\nfor sample in tqdm(range(len(train_df))):\n    X[sample,:] = train_df.iloc[sample,1:].values\n    X[sample,:] *= 1\/255.0\n    y[sample,0] = train_df.iloc[sample, 0]\n    \nX_train, X_val, y_train, y_val = train_test_split(X, y, test_size = 0.20, random_state = 42)","6bb01ada":"train_history = perc_autoencoder.fit(X_train,X_train,  validation_data = (X_val,X_val), \n                     epochs = 200, batch_size = 250, verbose = 2, shuffle = True)","e098d439":"plt.figure(figsize = (12,7))\nplt.plot(train_history.history['loss'], 'r', LineWidth = 3, alpha = 0.45, label = 'training loss')\nplt.plot(train_history.history['val_loss'], 'b', LineWidth = 3, alpha = 0.45, label = 'validation loss')\nplt.xlabel('Epochs', fontsize = 18)\nplt.ylabel('Loss', fontsize = 18)\nplt.title('Comparing  loss between training and validation datasets', fontsize = 18, fontweight = 'bold')\nplt.legend(fontsize = 18)\nplt.show()","99220926":"import gc\nimport psutil\n\n# Free up space\nprocess = psutil.Process(os.getpid())\nprint('Before deleting training data:', process.memory_info().rss)\ndel X, X_train, X_val; gc.collect()\nprint('After deleting training data:', process.memory_info().rss)","be9e6fd9":"X = np.zeros((len(train_df), 28, 28, 1))\ny = np.zeros((len(train_df), 1))\nfor sample in tqdm(range(len(train_df))):\n    X[sample,:,:,0] = train_df.iloc[sample,1:].values.reshape(28,28,)\n    y[sample,0] = train_df.iloc[sample,0]\nprint('Final shape:', X.shape, y.shape)\n\nX_train, X_val, y_train, y_val = train_test_split(X, y, test_size = 0.20, random_state = 42)","d9101dbc":"from tensorflow.keras import layers\nfrom tensorflow.keras.models import Model\n\n\ndef gen_DCNN_autoencoder():\n    input_layer = Input(shape = (28,28,1))\n\n    x = layers.Conv2D(8, (3,3), padding = 'same', activation = 'relu')(input_layer)\n    b = layers.BatchNormalization()(x)\n    x = layers.Conv2D(16, (3,3), padding = 'same', activation = 'relu')(b)\n    b = layers.BatchNormalization()(x)\n    mp = layers.MaxPooling2D((2,2), padding = 'same')(b)\n    x = layers.Conv2D(32, (3,3), padding = 'same', activation = 'relu')(mp)\n    b = layers.BatchNormalization()(x)\n    x = layers.Conv2D(32, (3,3), padding = 'same', activation = 'relu')(b)\n    b = layers.BatchNormalization()(x)    \n\n    encoder = layers.MaxPooling2D((2,2), padding = 'same', name = 'encoding_z-space')(b)\n\n\n    t = layers.Conv2DTranspose(32, (3,3), strides = (2,2),  padding = 'same', activation = 'relu')(encoder)\n    b = layers.BatchNormalization()(t)\n    t = layers.Conv2DTranspose(32, (3,3), padding = 'same', activation = 'relu')(b)\n    b = layers.BatchNormalization()(t)\n    t = layers.Conv2DTranspose(16, (3,3),  strides = (2,2), padding = 'same', activation = 'relu')(b)\n    b = layers.BatchNormalization()(t)\n    t = layers.Conv2DTranspose(8, (3,3), padding = 'same', activation = 'relu')(b)\n\n    decoded = layers.Conv2D(1, (3,3), padding = 'same', activation = 'sigmoid')(t)\n\n    autoencoder = Model(input_layer, decoded)\n    autoencoder.compile(optimizer = 'adam', loss = 'mean_squared_error')\n\n    return autoencoder","01c948f4":"# normalize the data such that pixels are binned between [0., 1.]\nX_train *= 1\/255.0\nX_val *= 1\/255.0","d65ca760":"autoencoder = gen_DCNN_autoencoder()\nhistory = autoencoder.fit(X_train, X_train, validation_data = (X_val,X_val), epochs = 30, batch_size = 250, shuffle=True, verbose = 2)","94aa0f13":"plt.figure(figsize = (25,5))\nplt.plot(history.history['loss'], 'r', LineWidth = 3, alpha = 0.45, label = 'training loss')\nplt.plot(history.history['val_loss'], 'b', LineWidth = 3, alpha = 0.45, label = 'validation loss')\nplt.xlabel('Epochs', fontsize = 18)\nplt.ylabel('Loss', fontsize = 18)\nplt.title('Comparing loss between training and validation datasets', fontsize = 18, fontweight = 'bold')\nplt.legend(fontsize = 18)\nplt.show()","e04003d0":"for sample in range(10):\n    plt.figure(figsize = (5,5))\n    plt.subplot(1,2,1)\n    plt.imshow(X_val[sample].reshape(28,28,), cmap = 'gray')\n    plt.title(\"Original image\", fontsize = 18, fontweight = 'bold')\n    plt.axis('off')\n\n    plt.subplot(1,2,2)\n    plt.imshow(autoencoder.predict(X_val[sample].reshape(1,28,28,1)).reshape(28,28,), cmap = 'gray')\n    plt.title(\"Model prediction\", fontsize = 18, fontweight = 'bold')\n    plt.axis('off')\n    plt.tight_layout()\n    plt.show()","46036945":"noise = np.random.uniform(0,1,(28,28,1))\nplt.figure(figsize=(12,5))\n\nplt.subplot(1,2,1)\nplt.imshow(noise.reshape(28,28,), cmap = 'gray')\nplt.title('Uniform distribution between [0,1]', fontsize = 18, fontweight = 'bold')\nplt.axis('off')\n\nplt.subplot(1,2,2)\nplt.imshow(autoencoder.predict(noise.reshape(1,28,28,1)).reshape(28,28,), cmap = 'gray')\nplt.title('Model predicted image', fontsize = 18, fontweight = 'bold')\nplt.axis('off')\n\nplt.tight_layout()\nplt.show()","96763e72":"\ndef Denoise_autoencoder(z):\n    input_layer = Input(shape = (28,28,1))\n\n    x = layers.Conv2D(8, (3,3), padding = 'same', activation = 'relu')(input_layer)\n    b = layers.BatchNormalization()(x)\n    mp = layers.MaxPooling2D((2,2), padding = 'same')(b)\n    x = layers.Conv2D(16, (3,3), padding = 'same', activation = 'relu')(mp)\n    b = layers.BatchNormalization()(x)\n    mp = layers.MaxPooling2D((2,2), padding = 'same')(b)\n    x = layers.Conv2D(16, (3,3), padding = 'same', activation = 'relu')(b)\n    b = layers.BatchNormalization()(x)    \n    mp = layers.MaxPooling2D((2,2), padding = 'same')(b)\n    x = layers.Conv2D(32, (3,3), padding = 'same', activation = 'relu')(mp)\n    b = layers.BatchNormalization()(x)    \n    mp = layers.MaxPooling2D((2,2), padding = 'same')(b)\n    x = layers.Conv2D(64, (3,3), padding = 'same', activation = 'relu')(mp)\n    b = layers.BatchNormalization()(x)    \n    mp = layers.MaxPooling2D((2,2), padding = 'same')(b)\n    x = layers.Conv2D(z, (3,3), padding = 'same', activation = 'relu')(mp)\n    b = layers.BatchNormalization()(x)    \n    \n    \n    encoder = layers.MaxPooling2D((2,2), padding = 'same', name = 'encoding_z-space')(b)\n    \n\n    t = layers.Conv2DTranspose(64, (3,3), strides = (2,2),  padding = 'valid', activation = 'relu')(encoder)\n    b = layers.BatchNormalization()(t)\n    t = layers.Conv2DTranspose(32, (3,3),  strides = (2,2), padding = 'valid', activation = 'relu')(b)\n    b = layers.BatchNormalization()(t)\n    t = layers.Conv2DTranspose(16, (3,3),  strides = (2,2), padding = 'same', activation = 'relu')(b)\n    b = layers.BatchNormalization()(t)\n    t = layers.Conv2DTranspose(16, (3,3),  strides = (2,2), padding = 'same', activation = 'relu')(b)\n    b = layers.BatchNormalization()(t)\n    t = layers.Conv2DTranspose(8, (3,3), padding = 'same', activation = 'relu')(b)\n    b = layers.BatchNormalization()(t)\n\n    \n    \n    decoded = layers.Conv2D(1, (3,3), padding = 'same', activation = 'sigmoid')(b)\n\n    opt = tf.keras.optimizers.Adam(learning_rate=0.000100000231231)\n    autoencoder = Model(input_layer, decoded)\n    autoencoder.compile(optimizer = 'adam', loss = 'mean_squared_error')\n\n    return autoencoder\ndenoise_ae = Denoise_autoencoder(3)\ndenoise_ae.summary()","42d03dfc":"import cv2 as cv\nimport random\n\nsample = random.randint(0, 3000)\nimg = X_train[sample,:,:,0].copy()\nnoise_uni = cv.randu(img,(0),(1))\n\n# Present the before and after adding noise ...\nplt.imshow(X_train[sample,:,:,0].reshape(28,28,), cmap='gray')\nplt.show()\nplt.imshow((X_train[sample,:,:,0] + noise_uni), cmap='gray')\nplt.show()","be8a2f2c":"X_train_noise, X_val_noise = np.zeros((len(X_train), 28,28,1)), np.zeros((len(X_val), 28, 28, 1))\n\nfor sample in tqdm(range(len(X_train))):\n    \n    img = X_train[sample,:,:,0].copy()\n    noise_img = cv.randu(img,(0),(0.35))\n    X_train_noise[sample,:,:,0] =  X_train[sample,:,:,0] + noise_img\n    \n    if sample < len(X_val):\n        img2 = X_val[sample,:,:,0].copy()\n        noise_img2 = cv.randu(img2,(0),(0.35))\n        X_val_noise[sample,:,:,0] =  X_val[sample,:,:,0] + noise_img2","5a17d9bc":"plt.imshow(X_val[0,:,:,:].reshape(28,28,))\nplt.show()\nplt.imshow(X_val_noise[0,:,:,:].reshape(28,28,))\nplt.show()\n\nplt.imshow(X_train[0,:,:,:].reshape(28,28,))\nplt.show()\nplt.imshow(X_train_noise[0,:,:,:].reshape(28,28,))\nplt.show()","9a5b5004":"denoise_ae = Denoise_autoencoder(3)\ndenoise_ae_history = denoise_ae.fit(X_train_noise, X_train, validation_data = (X_val_noise,X_val), epochs = 30, batch_size = 32, shuffle=True, verbose = 2)","b5330204":"alpha = random.randint(0, len(X_val))\n\nplt.figure(figsize = (15,5))\nplt.subplot(1,3,1)\nplt.imshow(X_train[alpha,:,:,:].reshape(28,28,))\nplt.title('original image')\nplt.axis('off')\nplt.subplot(1,3,2)\nplt.imshow(X_train_noise[alpha,:,:,:].reshape(28,28,))\nplt.title('+ noise')\nplt.axis('off')\nplt.subplot(1,3,3)\nplt.imshow(denoise_ae.predict(X_train_noise[alpha,:,:,:].reshape(1,28,28,1)).reshape(28,28,))\nplt.title('generated image')\nplt.axis('off')\nplt.show()\n\n\n\nplt.figure(figsize = (15,5))\nplt.subplot(1,3,1)\nplt.imshow(X_val[alpha,:,:,:].reshape(28,28,))\nplt.title('original image')\nplt.axis('off')\nplt.subplot(1,3,2)\nplt.imshow(X_val_noise[alpha,:,:,:].reshape(28,28,))\nplt.title('+ noise')\nplt.axis('off')\nplt.subplot(1,3,3)\nplt.imshow(denoise_ae.predict(X_val_noise[alpha,:,:,:].reshape(1,28,28,1)).reshape(28,28,))\nplt.title('generated image')\nplt.axis('off')\nplt.show()","61ade639":"\nencoder = Model(denoise_ae.input, denoise_ae.layers[-12].output)\nencoder.summary()","b148c0b2":"\ntrain_latent_space = np.zeros((500, 3))\nval_latent_space = np.zeros((500, 3))\nfor sample in tqdm(range(500)):\n    train_latent_space[sample,:] = encoder.predict(X_train[sample,:,:,0].reshape(1,28,28,1))[0][0][0]\n    val_latent_space[sample,:] = encoder.predict(X_val[sample,:,:,0].reshape(1,28,28,1))[0][0][0]","baf0382f":"\n\nfig = plt.figure(figsize = (10, 7)) \nax = plt.axes(projection =\"3d\") \n  \n# Creating plot \nax.scatter3D(train_latent_space[:,0], train_latent_space[:,1], train_latent_space[:,2], alpha = 0.4); \nax.scatter3D(val_latent_space[:,0], val_latent_space[:,1], val_latent_space[:,2], alpha = 0.4); \nplt.title(\"simple 3D scatter plot\") \n# show plot \nplt.show()\n\nplt.figure(figsize = (12,3))\nplt.subplot(1,3,1)\nplt.scatter(train_latent_space[:,0], train_latent_space[:,1], alpha = 0.4)\nplt.scatter(val_latent_space[:,0], val_latent_space[:,1], alpha = 0.4)\n#plt.scatter(train_latent_space_8[:,0], train_latent_space_8[:,1])\nplt.subplot(1,3,2)\nplt.scatter(train_latent_space[:,0], train_latent_space[:,2], alpha = 0.4)\nplt.scatter(val_latent_space[:,0], val_latent_space[:,2], alpha = 0.4)\n\n#plt.scatter(train_latent_space_8[:,0], train_latent_space_8[:,2])\nplt.subplot(1,3,3)\nplt.scatter(train_latent_space[:,1], train_latent_space[:,2], alpha = 0.4)\nplt.scatter(val_latent_space[:,1], val_latent_space[:,2], alpha = 0.4)\n\n#plt.scatter(train_latent_space_8[:,1], train_latent_space_8[:,2])\nplt.show()","df8970d2":"# Denoising Deep Autoencoder: \n\nHere, we add constraints to the previous Deep Autoencoder in two ways: \n    1. Decrease the size of the latent space\n    2. Add gaussian noise to the input images and let the neural network generate the original image\n    \nThe benefite of decreasing the latent space is that we lower dimensional of the feature space, allowing for additional analysis that much more amenable to humans comparative to deep neural networks, e.g., a logisitic regression or SVM. Additionally, adding noise to an input image and attempting to create a mapping function that generates the original image help avoid the trivial solution, where the neural network acts as an identity function.","0f1a3e19":"Here we convert the dataframe data columns corresponding to the pixel values to tensors, representing 2D image data rather 1D vectors.","844c0d91":"With out loss results on the training and validation datasets, we should be very impressed. However, in general for autoencoders, this is not a good sign because our neural network is potentially only acting as an identity function which maps the input image back to itself. This is an issue since we lose the opportunity to learn imperative feature representations in the latent space, and these imperative feature representations can be extracted so that we can find way to better construct classification models. To avoid these issues, we will need to add extra constraints to the autoencoder, e.g., we can always decrease the complexity of the model. While this a plausible approach, we will decrease the size of the latent space and also implement a denosing autoencoder in the section.","31c5be37":"With the additional constraints (lower dimensional latent space and added noise), our neural network still learns to manages to generate the majority of the digits. Changing the structure of the network and hyperparameters can help will improving the overall results, but here, we will move on and explore the latent space.","90f0f04d":"Here we construct the model architecture","2681d262":"# Deep Convolutional Autoencoder: \n\nEarlier, we showed how to construct a shallow autoencoder and train it on MNIST image data curated as vector representations. We achieved a poor loss performance ~0.3 for the validation and training data. This poor learning is mainly due to the lack of depth for the autoencoder, and more importantly, the lack of implementing convoltuional layers within the architecture. These convolutional layers allow to learn higher spatial features, drastically improving the represetnations found in the latent space of the autoencoder. So within the next example, we will construct a deep convoltuional autoencoder with a latent space that is amenable for our exploration and feature extraction.","a0469113":"Below, we will generate an image that contains only pixels plucked from a uniform distribution between [0,1] and compare it with the autoencoder generate image. Even though the output is nonsense, it is interesting to see how the output drastically changes comparative to the input.","ca6931ea":"Below, we will juxtapose the original input image with the correponding generate image from the neural network. We can see that the autoencoder generate a lower intensity image comparative to the original image. However, overall, the original and generated image is completely identical in terms of the spatial features.","d1a1859e":"Below we construct the encoder which take input images and output low dimensional vector representations called the latent space. We will also construct decoder model which inputs that same low dimensional lower dimensional vector representation and outputs images of the corresponding label. We can also explore this latent space by generating new vectors and seeing what the decoder generates on the other side.","ac1a8359":"Before we continue with implementing a deep convolutional autoencoder, let's free up some memory within our RAM ...","f8ba771a":"### Prep the data:","ba5c58a5":"# How do we implement Autoencoders? \n\n\nAutoencoders are unique because they are considered generative neural networks, and each autoencoder contains a latent space which potentially learns relevant features either in a lower or high representation than the input data. For our walkthrough, we will always focus on latent spaces which are lower dimensional than the input data, that way, we can work with lower-dimensional data amenable for further human analysis. The main takeways of an autoencoder is the neural networks map the input data back to itself. However, in most successful autoencoders, constraints are placed on top of the input data before mapping to the outputs. For example, denoising autoencoders constraints the mapping by adding noise to the input data and then generating the original data (before adding noise) as the output data. Adding constraints is important to have learn useful features in the latent space because these same constraints helps avoid f (neural network mapping) become an identity function. \n\nWe will walk through various autoencoders: \n\n    1.) Fully connected autoencoder\n    2.) Deep Convolutional Auotencoder\n    3.) Denoising Convolutional Autoencoder: Added noise to input image + convolutional operations\n    4.) Variational Autoencoder (to be completed ...): Assume and constraint the latent space as a Gaussian distribution\n    \n    \nNot only does autoencoder help lower dimensional of the input data and extract important features within the latent space, autoencoders can also generate completely new data by exploring the latent space and using the decoder end of the network to output data.","74e0bfe2":"## For the interested reader:\n\nEven though the current script is public, there is still much more work needed to fully complete it. I am personally aiming to add visualization to better understand autoencoders, and I want to add well developed summaries after each implemeneted autoencoder section. Furthermore, I aim to also go in more detail for latent space exploration on the denoising deep autoencoder, and I still need to start a walkthrough for the variation autoencoder. That being said, I did finish writing the script for a simple fully connected autoencoder and deep autoencoder along with a denoising deep autoencoder. Lastly, please leave comments on how should I add more information and context to improve this comprehensive walkthrough on autoencoders. "}}