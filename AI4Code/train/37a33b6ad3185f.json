{"cell_type":{"0852e3d2":"code","d646540b":"code","5207130e":"code","e66e1a3e":"code","7504678f":"code","9f861dba":"code","afe7554b":"code","8d935ffa":"code","bd291598":"code","7909e859":"code","2a672ec5":"code","325e807e":"code","396372c8":"code","cf08ae47":"code","d9d036f4":"code","f91e70c6":"code","468eb10e":"code","b750fa8f":"code","d048bf78":"code","b39cfaa1":"code","0bf5201b":"code","fdd07682":"code","9c58b510":"code","d3eb8236":"code","ee68fa6e":"code","9d18435d":"code","f89ab528":"code","36bb9c64":"code","ad9621e7":"code","dff0bd85":"code","f6995c0e":"code","83bafa91":"code","f45f314f":"code","28fc4b80":"code","36e7f155":"code","cc101997":"code","009e906e":"code","83d437f7":"code","0a6f2a85":"code","38fc3790":"code","584a50db":"markdown","d5314386":"markdown","a1120d40":"markdown","0acce530":"markdown","3656f619":"markdown","2e2d812b":"markdown","6f49c80d":"markdown","a257e9d6":"markdown","2aa29bf4":"markdown","e69cf0aa":"markdown","de81d282":"markdown","97c880c6":"markdown","9fa98b7e":"markdown","14ea82f5":"markdown","4bf2120c":"markdown","06472259":"markdown","82860830":"markdown","a38dc1be":"markdown","6178d48c":"markdown","77d992af":"markdown","9b9e27ea":"markdown","5151ca50":"markdown","8c0d74ee":"markdown","fd0f4dc7":"markdown","9871d9a0":"markdown"},"source":{"0852e3d2":"import numpy as np\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm","d646540b":"# Time step\ndt = 0.01 \n\n# total number of measurements\nm = 200 ","5207130e":"# positions at start\npx= 0.0 \npy= 0.0\npz= 1.0\n\n# velocities at start\nvx = 5.0 \nvy = 3.0 \nvz = 0.0\n\n# Drag Resistance Coefficient\nc = 0.1 \n\n# Damping\nd = 0.9 \n\n# Arrays to store location measurements\nXr=[]\nYr=[]\nZr=[]","e66e1a3e":"# generating data\nfor i in range(0, m):\n    \n # update acceleration (deceleration), velocity, position in x direction\n    accx = -c*vx**2 \n    vx += accx*dt\n    px += vx*dt\n # update acceleration (deceleration), velocity, position in y direction\n    accy = -c*vy**2\n    vy += accy*dt\n    py += vy*dt\n # update acceleration, velocity, position in x direction\n    accz = -9.806 + c*vz**2 \n    vz += accz*dt\n    pz += vz*dt\n # if the object is about to hit the base, \n # change direction, with damping\n    if pz<0.01:\n        vz=-vz*d\n        pz+=0.02\n # add to the arrays storing locations\n    Xr.append(px)\n    Yr.append(py)\n    Zr.append(pz)","7504678f":"# Add random noise to measurements\n# Standard Deviation for noise\nsp= 0.1 \nXm = Xr + sp * (np.random.randn(m))\nYm = Yr + sp * (np.random.randn(m))\nZm = Zr + sp * (np.random.randn(m))\n# stack the measurements together for ease of later use\nmeasurements = np.vstack((Xm,Ym,Zm))","9f861dba":"fig = plt.figure(figsize=(10,6))\nThree_dplot = fig.add_subplot(111, projection='3d')\nThree_dplot.scatter(Xm, Ym, Zm, c='red')\nThree_dplot.set_xlabel('$x$')\nThree_dplot.set_ylabel('$y$')\nThree_dplot.set_zlabel('$z$')\nplt.title('Noisy 3D Ball-Location observations')\nplt.show()","afe7554b":"# Identity matrix\nI = np.eye(9)\n\n# state matrix\nx = np.matrix([0.0, 0.0, 1.0, 5.0, 3.0, 0.0, 0.0, 0.0, -9.81]).T\n\n# P matrix\nP = 100.0*np.eye(9)","8d935ffa":"# A matrix\nA = np.matrix([[1.0, 0.0, 0.0, dt, 0.0, 0.0, 1\/2.0*dt**2, 0.0, 0.0],\n [0.0, 1.0, 0.0, 0.0, dt, 0.0, 0.0, 1\/2.0*dt**2, 0.0],\n [0.0, 0.0, 1.0, 0.0, 0.0, dt, 0.0, 0.0, 1\/2.0*dt**2],\n [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, dt, 0.0, 0.0],\n [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, dt, 0.0],\n [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, dt],\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0],\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0],\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]])","bd291598":"# H matrix\nH = np.matrix([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]])\n\n# R matrix\nr = 1.0\nR = np.matrix([[r, 0.0, 0.0],\n [0.0, r, 0.0],\n [0.0, 0.0, r]])\n\n# Q, G matrices\ns = 8.8\nG = np.matrix([[1\/2.0*dt**2],\n [1\/2.0*dt**2],\n [1\/2.0*dt**2],\n [dt],\n [dt],\n [dt],\n [1.0],\n [1.0],\n [1.0]])\nQ = G*G.T*s**2","7909e859":"B = np.matrix([[0.0], #Disturbance Control Matrix \n               [0.0],\n               [0.0],\n               [0.0],\n               [0.0],\n               [0.0],\n               [0.0],\n               [0.0],\n               [0.0]])","2a672ec5":"u = 0.0 #Control Input","325e807e":"xt = []\nyt = []\nzt = []\ndxt= []\ndyt= []\ndzt= []\nddxt=[]\nddyt=[]\nddzt=[]\nZx = []\nZy = []\nZz = []\nPx = []\nPy = []\nPz = []\nPdx= []\nPdy= []\nPdz= []\nPddx=[]\nPddy=[]\nPddz=[]\nKx = []\nKy = []\nKz = []\nKdx= []\nKdy= []\nKdz= []\nKddx=[]\nKddy=[]\nKddz=[]","396372c8":"onFloor = False\nfor i in range(0, m):\n# Model the direction switch, when hitting the plate\n    if x[2]<0.02 and not onFloor:\n        x[5] = -x[5]\n        onFloor=True\n# Prediction\n# state prediction\n    x = A*x + B*u \n# Project the error covariance ahead\n    P = A*P*A.T + Q \n# Update\n# Kalman Gain\n    S = H*P*H.T + R\n    K = (P*H.T) * np.linalg.pinv(S)\n# Update the estimate via z\n    Z = measurements[:,i].reshape(H.shape[0],1)\n    y = Z - (H*x) \n    x = x + (K*y)\n# error covariance\n    P = (I - (K*H))*P\n    \n    # Storing results\n    xt.append(float(x[0]))\n    yt.append(float(x[1]))\n    zt.append(float(x[2]))\n    dxt.append(float(x[3]))\n    dyt.append(float(x[4]))\n    dzt.append(float(x[5]))\n    ddxt.append(float(x[6]))\n    ddyt.append(float(x[7]))\n    ddzt.append(float(x[8]))\n    Zx.append(float(Z[0]))\n    Zy.append(float(Z[1]))\n    Zz.append(float(Z[2]))\n    Px.append(float(P[0,0]))\n    Py.append(float(P[1,1]))\n    Pz.append(float(P[2,2]))\n    Pdx.append(float(P[3,3]))\n    Pdy.append(float(P[4,4]))\n    Pdz.append(float(P[5,5]))\n    Pddx.append(float(P[6,6]))\n    Pddy.append(float(P[7,7]))\n    Pddz.append(float(P[8,8]))\n    Kx.append(float(K[0,0]))\n    Ky.append(float(K[1,0]))\n    Kz.append(float(K[2,0]))\n    Kdx.append(float(K[3,0]))\n    Kdy.append(float(K[4,0]))\n    Kdz.append(float(K[5,0]))\n    Kddx.append(float(K[6,0]))\n    Kddy.append(float(K[7,0]))\n    Kddz.append(float(K[8,0]))","cf08ae47":"# Plots\n#State Estimates\nplt.figure(figsize=(12,6))\nplt.subplot(311)\nplt.title('Location, Velocity, Acceleration Estimates')\nplt.plot(range(len(measurements[0])),xt, label='$x$')\nplt.plot(range(len(measurements[0])),yt, label='$y$')\nplt.plot(range(len(measurements[0])),zt, label='$z$')\nplt.legend(loc='right' )","d9d036f4":"plt.figure(figsize=(12,6))\n\nplt.subplot(312)\nplt.plot(range(len(measurements[0])),dxt, label='$v_x$')\nplt.plot(range(len(measurements[0])),dyt, label='$v_y$')\nplt.plot(range(len(measurements[0])),dzt, label='$v_z$')\nplt.legend(loc='right')\nplt.subplot(313)\nplt.plot(range(len(measurements[0])),ddxt, label='$ax$')\nplt.plot(range(len(measurements[0])),ddyt, label='$ay$')\nplt.plot(range(len(measurements[0])),ddzt, label='$az$')\nplt.legend(loc='right')\nplt.xlabel('Step')","f91e70c6":"# Location in 2D (z, y)\nplt.figure(figsize=(12,6))\nplt.subplot(311)\nplt.plot(xt,yt, label='Estimate')\nplt.scatter(Xm,Ym, label='Measurement', c='red', s=30)\nplt.plot(Xr, Yr, label='Real')\nplt.title('Location Tracking on the 2D-Planes')\nplt.legend(loc='best')\nplt.xlabel('$x$')\nplt.ylabel('$y$')","468eb10e":"plt.figure(figsize=(12,6))\nplt.subplot(312)\nplt.plot(xt,zt, label='Estimate')\nplt.scatter(Xm,Zm, label='Measurement', c='red', s=30)\nplt.plot(Xr, Zr, label='Real')\nplt.legend(loc='best')\nplt.xlabel('$x$')\nplt.ylabel('$z$')\n","b750fa8f":"plt.figure(figsize=(12,6))\nplt.subplot(313)\nplt.plot(yt,zt, label='Estimate')\nplt.scatter(Ym,Zm, label='Measurement', c='red', s=30)\nplt.plot(Yr, Zr, label='Real')\nplt.legend(loc='best')\nplt.axhline(0, color='k')\nplt.xlabel('$y$')\nplt.ylabel('$z$')","d048bf78":"# Position in x\/z Plane   \nplt.figure(figsize=(12,6))\nax = fig.add_subplot(111, projection='3d')\nplt.plot(xt,zt, label='Estimate')\nplt.scatter(Xm,Zm, label='Measurement', c='red')\nplt.plot(Xr,Zr, label='Real')\nax.set_xlabel('$x$')\nax.set_ylabel('$y$')\nplt.legend()\nplt.title('3D Location Tracking')\nplt.show()","b39cfaa1":"# Location in 3D (X, Y, Z)  \nfig = plt.figure(figsize=(16,9))\nax = fig.add_subplot(111, projection='3d')\nax.plot(xt,yt,zt, label='Kalman Filter Estimate')\nax.plot(Xr, Yr, Zr, label='Real')\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\nax.legend()","0bf5201b":"import numpy as np\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm","fdd07682":"# Time step\ndt = 0.01 \n\n# total number of measurements\nm = 200 ","9c58b510":"# positions at start\npx= 0.0 \npy= 0.0\npz= 1.0\n\n# velocities at start\nvx = 5.0 \nvy = 3.0 \nvz = 0.0\n\n# Drag Resistance Coefficient\nc = 0.1 \n\n# Damping\nd = 0.9 \n\n# Arrays to store location measurements\nXr=[]\nYr=[]\nZr=[]","d3eb8236":"# generating data\nfor i in range(0, m):\n    \n # update acceleration (deceleration), velocity, position in x direction\n    accx = -c*vx**2 \n    vx += accx*dt\n    px += vx*dt\n # update acceleration (deceleration), velocity, position in y direction\n    accy = -c*vy**2\n    vy += accy*dt\n    py += vy*dt\n # update acceleration, velocity, position in x direction\n    accz = -9.806 + c*vz**2 \n    vz += accz*dt\n    pz += vz*dt\n # if the object is about to hit the base, \n # change direction, with damping\n    if pz<0.01:\n        vz=-vz*d\n        pz+=0.02\n # add to the arrays storing locations\n    Xr.append(px)\n    Yr.append(py)\n    Zr.append(pz)","ee68fa6e":"# Add random noise to measurements\n# Standard Deviation for noise\nsp= 0.1 \nXm = Xr + sp * (np.random.randn(m))\nYm = Yr + sp * (np.random.randn(m))\nZm = Zr + sp * (np.random.randn(m))\n# stack the measurements together for ease of later use\nmeasurements = np.vstack((Xm,Ym,Zm))","9d18435d":"fig = plt.figure(figsize=(10,6))\nThree_dplot = fig.add_subplot(111, projection='3d')\nThree_dplot.scatter(Xm, Ym, Zm, c='red')\nThree_dplot.set_xlabel('$x$')\nThree_dplot.set_ylabel('$y$')\nThree_dplot.set_zlabel('$z$')\nplt.title('Noisy 3D Ball-Location observations')\nplt.show()","f89ab528":"# Identity matrix\nI = np.eye(9)\n\n# state matrix\nx = np.matrix([0.0, 0.0, 1.0, 5.0, 3.0, 0.0, 0.0, 0.0, -9.81]).T\n\n# P matrix\nP = 100.0*np.eye(9)","36bb9c64":"# A matrix\nA = np.matrix([[1.0, 0.0, 0.0, dt, 0.0, 0.0, 1\/2.0*dt**2, 0.0, 0.0],\n [0.0, 1.0, 0.0, 0.0, dt, 0.0, 0.0, 1\/2.0*dt**2, 0.0],\n [0.0, 0.0, 1.0, 0.0, 0.0, dt, 0.0, 0.0, 1\/2.0*dt**2],\n [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, dt, 0.0, 0.0],\n [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, dt, 0.0],\n [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, dt],\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0],\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0],\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]])","ad9621e7":"# H matrix\nH = np.matrix([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]])\n\n# R matrix\nr = 1.0\nR = np.matrix([[r, 0.0, 0.0],\n [0.0, r, 0.0],\n [0.0, 0.0, r]])\n\n# Q, G matrices\ns = 8.8\nG = np.matrix([[1\/2.0*dt**2],\n [1\/2.0*dt**2],\n [1\/2.0*dt**2],\n [dt],\n [dt],\n [dt],\n [1.0],\n [1.0],\n [1.0]])\nQ = G*G.T*s**2","dff0bd85":"B = np.matrix([[0.0], #Disturbance Control Matrix \n               [0.0],\n               [0.0],\n               [0.0],\n               [0.0],\n               [0.0],\n               [0.0],\n               [0.0],\n               [0.0]])","f6995c0e":"u = 0.0 #Control Input","83bafa91":"xt = []\nyt = []\nzt = []\ndxt= []\ndyt= []\ndzt= []\nddxt=[]\nddyt=[]\nddzt=[]\nZx = []\nZy = []\nZz = []\nPx = []\nPy = []\nPz = []\nPdx= []\nPdy= []\nPdz= []\nPddx=[]\nPddy=[]\nPddz=[]\nKx = []\nKy = []\nKz = []\nKdx= []\nKdy= []\nKdz= []\nKddx=[]\nKddy=[]\nKddz=[]","f45f314f":"onFloor = False\nfor i in range(0, m):\n# Model the direction switch, when hitting the plate\n    if x[2]<0.02 and not onFloor:\n        x[5] = -x[5]\n        onFloor=True\n# Prediction\n# state prediction\n    x = A*x + B*u \n# Project the error covariance ahead\n    P = A*P*A.T + Q \n# Update\n# Kalman Gain\n    S = H*P*H.T + R\n    K = (P*H.T) * np.linalg.pinv(S)\n# Update the estimate via z\n    Z = measurements[:,i].reshape(H.shape[0],1)\n    y = Z - (H*x) \n    x = x + (K*y)\n# error covariance\n    P = (I - (K*H))*P\n    \n    # Storing results\n    xt.append(float(x[0]))\n    yt.append(float(x[1]))\n    zt.append(float(x[2]))\n    dxt.append(float(x[3]))\n    dyt.append(float(x[4]))\n    dzt.append(float(x[5]))\n    ddxt.append(float(x[6]))\n    ddyt.append(float(x[7]))\n    ddzt.append(float(x[8]))\n    Zx.append(float(Z[0]))\n    Zy.append(float(Z[1]))\n    Zz.append(float(Z[2]))\n    Px.append(float(P[0,0]))\n    Py.append(float(P[1,1]))\n    Pz.append(float(P[2,2]))\n    Pdx.append(float(P[3,3]))\n    Pdy.append(float(P[4,4]))\n    Pdz.append(float(P[5,5]))\n    Pddx.append(float(P[6,6]))\n    Pddy.append(float(P[7,7]))\n    Pddz.append(float(P[8,8]))\n    Kx.append(float(K[0,0]))\n    Ky.append(float(K[1,0]))\n    Kz.append(float(K[2,0]))\n    Kdx.append(float(K[3,0]))\n    Kdy.append(float(K[4,0]))\n    Kdz.append(float(K[5,0]))\n    Kddx.append(float(K[6,0]))\n    Kddy.append(float(K[7,0]))\n    Kddz.append(float(K[8,0]))","28fc4b80":"# Plots\n#State Estimates\nplt.figure(figsize=(12,6))\nplt.subplot(311)\nplt.title('Location, Velocity, Acceleration Estimates')\nplt.plot(range(len(measurements[0])),xt, label='$x$')\nplt.plot(range(len(measurements[0])),yt, label='$y$')\nplt.plot(range(len(measurements[0])),zt, label='$z$')\nplt.legend(loc='right' )","36e7f155":"plt.figure(figsize=(12,6))\n\nplt.subplot(312)\nplt.plot(range(len(measurements[0])),dxt, label='$v_x$')\nplt.plot(range(len(measurements[0])),dyt, label='$v_y$')\nplt.plot(range(len(measurements[0])),dzt, label='$v_z$')\nplt.legend(loc='right')\nplt.subplot(313)\nplt.plot(range(len(measurements[0])),ddxt, label='$ax$')\nplt.plot(range(len(measurements[0])),ddyt, label='$ay$')\nplt.plot(range(len(measurements[0])),ddzt, label='$az$')\nplt.legend(loc='right')\nplt.xlabel('Step')","cc101997":"# Location in 2D (z, y)\nplt.figure(figsize=(12,6))\nplt.subplot(311)\nplt.plot(xt,yt, label='Estimate')\nplt.scatter(Xm,Ym, label='Measurement', c='red', s=30)\nplt.plot(Xr, Yr, label='Real')\nplt.title('Location Tracking on the 2D-Planes')\nplt.legend(loc='best')\nplt.xlabel('$x$')\nplt.ylabel('$y$')","009e906e":"plt.figure(figsize=(12,6))\nplt.subplot(312)\nplt.plot(xt,zt, label='Estimate')\nplt.scatter(Xm,Zm, label='Measurement', c='red', s=30)\nplt.plot(Xr, Zr, label='Real')\nplt.legend(loc='best')\nplt.xlabel('$x$')\nplt.ylabel('$z$')","83d437f7":"plt.figure(figsize=(12,6))\nplt.subplot(313)\nplt.plot(yt,zt, label='Estimate')\nplt.scatter(Ym,Zm, label='Measurement', c='red', s=30)\nplt.plot(Yr, Zr, label='Real')\nplt.legend(loc='best')\nplt.axhline(0, color='k')\nplt.xlabel('$y$')\nplt.ylabel('$z$')","0a6f2a85":"# Position in x\/z Plane   \nplt.figure(figsize=(12,6))\nax = fig.add_subplot(111, projection='3d')\nplt.plot(xt,zt, label='Estimate')\nplt.scatter(Xm,Zm, label='Measurement', c='red')\nplt.plot(Xr,Zr, label='Real')\nax.set_xlabel('$x$')\nax.set_ylabel('$y$')\nplt.legend()\nplt.title('3D Location Tracking')\nplt.show()","38fc3790":"# Location in 3D (X, Y, Z)  \nfig = plt.figure(figsize=(16,9))\nax = fig.add_subplot(111, projection='3d')\nax.plot(xt,yt,zt, label='Kalman Filter Estimate')\nax.plot(Xr, Yr, Zr, label='Real')\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\nax.legend()","584a50db":"## 3.2.1 Filtering\n> 1. Predicted (a priori) state estimate: $x\u0305_{k|k-1}$ = $A_{k}$$x\u0305_{k-1|k-1}$ + $B_{k}$$u_{k}$\n\n> 2. Predicted (a priori) estimate covariance: $P_{k|k-1}$ = $A_{k}$$P_{k-1|k-1}$**A**<sup>T<\/sup><sub>k<\/sub> + $Q_{k}$","d5314386":"## 3.2.2 Update\n>1. Innovation or measurement residual: $\u0177_{k}$ = $z_{k}$ \u2212 $H_{k}$$x\u0305_{k|k-1}$\n\n>2. Innovation (or residual) covariance: $S_{k}$ = $H_{k}$$P_{k|k-1}$**H**<sup>T<\/sup><sub>k<\/sub> + $R_{k}$\n\n>3. Optimal Kalman gain: $K_{k}$ = $P_{k|k-1}$**H**<sup>T<\/sup><sub>k<\/sub> **S**<sup>-1<\/sup><sub>k<\/sub>\n\n>4. Updated (a posteriori) state estimate: $x\u0305_{k|k}$ = $x\u0305_{k|k-1}$ + $K_{k}$$\u0177_{k}$\n\n>5. Updated (a posteriori) estimate covariance: $P_{k|k}$ = (I \u2212 $K_{k}$$H_{k}$)$P_{k|k-1}$","a1120d40":"## 3.1 Kalman Equations\nReproduced from Wikipedia (below) we have the systems of equations (in matrix format) that need to be solved as part of the Kalman Filtering algorithm. Our challenge is to adapt the problem setting to result in the model that satisfies the form of these equations which will allow us to use Kalman Filtering to track the object\u2019s position and velocity.\n\nThe Kalman filter model assumes the true state at time k is evolved from the state at (k - 1) according to:\n\n<center> $x_{k}$ = $A_{k}$$x_{k-1}$ + $B_{k}$$u_{k}$ + $w_{k}$ <\/center>\n\nwhere,\n\n\u2022 $A_{k}$ is the state transition model which is applied to the previous state $x_{k-1}$;\n\n\u2022 $B_{k}$ is the control-input model which is applied to the control vector $u_{k}$ (not relevant in this example);\n\n\u2022 $w_{k}$ is the process noise which is assumed to be drawn from a zero mean multivariate normal distribution with covariance $Q_{k}$:\n\n<center> $w_{k}$ ~ N(0,$Q_{k}$) <\/center>\n\nAt time k an observation (or measurement) $z_{k}$ of the true state $x_{k}$ is made according to:\n\n<center> $z_{k}$ =$H_{k}$$x_{k}$ +$v_{k}$$z_{k}$ <\/center>\n\nwhere $H_{k}$ is the observation model which maps the true state space into the observed space and $v_{k}$ is the observation noise which is assumed to be zero mean Gaussian white noise with covariance $R_{k}$.\n\n<center>$v_{k}$ ~ N(0,$R_{k}$)<\/center>\n\n<p>The initial state, and the noise vectors at each step {$x_{0}$,$w_{1}$,...,$w_{k}$,$v_{1}$...$v_{k}$}are all assumed to be mutually independent.<\/p>","0acce530":"## 3.3.5 Process Noise Covariance, $Q_{k}$\nProcess noise refers to the modeling of forces that could influence our constant velocity model by creating noise in the form of acceleration disturbance. Ac- cording to Wikipedia, for this constant velocity model we have:\n\n<center> $Q_{k}$ = $G_{}$ * $G^{T}$ * \u03c3<sup>2<\/sup><sub>v<\/sub> <\/center>\n\nwhere,\n\n<center> G = [0.5\u2206$t^{2}$  0.5\u2206$t^{2}$ \u2206t \u2206t]\n    \nAnd we can assume the acceleration process noise **\u03c3**<sup>2<\/sup><sub>v<\/sub> = 8.8m\/s2, according to Schubert, R., Adam, C., Obst, M., Mattern, N., Leonhardt, V., Wanielik, G. (2011). Empirical evaluation of vehicular models for ego motion estimation. 2011 IEEE Intelligent Vehicles Symposium (IV), 534\u2013539.","3656f619":"## <CENTER> CASE STUDY 2 - 3D Location Tracking <\/CENTER>","2e2d812b":"## 3.3.4 Measurement Noise Covariance, $R_{k}$\n\nWe have the following model for measurement noise covariance matrix:\n\n \\begin{pmatrix}\n     r & 0.0 \\\\ \n     0.0 & r \\\\ \n \\end{pmatrix}\n\nThe constant r denotes the belief about the variance of the measurement noise.","6f49c80d":"<img src='https:\/\/th.bing.com\/th\/id\/R.3754e9da32e8f68806ba5c7ca547dee9?rik=Rwt3giKUJMC7gQ&riu=http%3a%2f%2fwww.afdloans.com.au%2fwp-content%2fuploads%2f2018%2f05%2fcase-study-no-1.jpg&ehk=23KCuNg7e66ry%2fqAWZ2oK07qJm52ACsVfojOYQKhc5U%3d&risl=&pid=ImgRaw&r=0'>","a257e9d6":"## 3. Kalman Equations and Dynamic Model","2aa29bf4":"## <CENTER>  HAPPY LEARNING FOLKS!  <\/CENTER>","e69cf0aa":"<img src='http:\/\/mep.global\/wp-content\/uploads\/2017\/04\/mep-case-study-2-1024x681.png'>","de81d282":"## 1. Problem Statement\nOur goal is to track the location (and velocity) of a moving object, e.g. a car, in a 2-dimensional space. The only information available to us is the initial location (and velocity) and a series of noisy measurements of the velocity as the object moves in space. The key assumption of this problem is that the true velocity of the object is known to be a constant. However, the constant velocity is not known to us.","97c880c6":"*With this, we have come to the end of the extensive case studies using Kalman Filtering. The notebook, as you must have felt, has required immense dedication and efforts. Though I have checked it multiple times, if there is any error, please do let me know by directly contacting me.*\n\n*I hope you had a fruitful time looking at this notebook.*\n\n*Stay Safe,*\n*Take Care!*","9fa98b7e":"## 3. Kalman Equations and Dynamic Model\n\n*Refer to those at the starting of the notebook*","14ea82f5":"## 3.3 Constant Velocity Model\nIn our constant velocity model, we have the following:","4bf2120c":"## <CENTER> CASE STUDY 1 - Tracking Object Moving with Constant Velocity <\/CENTER>","06472259":"<img src='https:\/\/th.bing.com\/th\/id\/R.738313c80660738e930118388c782385?rik=1kAU0WY57e1OEg&riu=http%3a%2f%2fwww.ilectureonline.com%2fdownload%2flecture.thumbnail.98dd2924ad8064ef.31353039303720316f6631322e6a7067.jpg&ehk=u4GjoHLo%2bnI2Rk0B49Yk%2fND2Kz8Cz4VH%2foY48w6%2b%2fPc%3d&risl=&pid=ImgRaw&r=0'><\/img>","82860830":"## 2. State Space\nWe keep track of the following: \n1. $x_{1}$: location in the $x_{1}$ direction. \n2. $x_{2}$: location in the $x_{2}$ direction. \n3. $v_{1}$: velocity in the $x_{1}$ direction. \n4. $v_{2}$: velocity in the $x_{2}$ direction.","a38dc1be":"## 3.3.1 Dynamic Matrix, $A_{k}$\nThe Dynamic Matrix, $A_{k}$, is calculated from the dynamics of the motion:\n\n<center>$x_{1,k+1}$ = $x_{1,k}$ + $v_{1,k}$ \u00b7 \u2206t<\/center>\n<center>$x_{2,k+1}$ = $x_{2,k}$ + $v_{2,k}$ \u00b7 \u2206t <\/center>\n<center>$v_{1,k+1}$ = $v_{1,k}$ <\/center>\n<center>$v_{2,k+1}$ = $v_{2,k}$<\/center>\n\nHence,\n\n\\begin{pmatrix}\n     1.0 & 0.0 & \u2206t & 0.0 \\\\ \n     0.0 & 1.0 & 0.0 & \u2206t \\\\ \n     0.0 & 0.0 & 1.0 & 0.0 \\\\\n     0.0 & 0.0 & 0.0 & 1.0\n \\end{pmatrix}\n\n\u2206t specifies the time between consecutive steps.","6178d48c":"## 3.2  Filtering\nThe state of the Kalman filter is represented by two variables:\n\n$x\u0305_{k|k}$, the a posteriori state estimate at time k given observations up to and including at time k;\n\n$P_{k|k}$, the a posteriori error covariance matrix (a measure of the estimated accuracy of the state estimate).\n\nThe Kalman filter can be written as a single equation, however it is most often conceptualized as two distinct phases: \u201dPredict\u201d and \u201dUpdate\u201d. \n\nThe predict phase uses the state estimate from the previous timestep to produce an estimate of the state at the current timestep. This predicted state estimate is also known as the a priori state estimate because, although it is an estimate of the state at the current timestep, it does not include observation information from the current timestep. In the update phase, the current a priori prediction is combined with current observation information to refine the state estimate. This improved estimate is termed the a posteriori state estimate.\n\nTypically, the two phases alternate, with the prediction advancing the state until the next scheduled observation, and the update incorporating the obser- vation.","77d992af":"## 3.3.2 Matrix $B_{k}$ and vector $u_{k}$\nIn this constant velocity model we have $B_{k}$ = 0 and $u_{k}$ = 0.","9b9e27ea":"## 2.  State Space\nWe keep track of the following:\n1. $x_{1}$: location in the $x_{1}$ direction. \n2. $x_{2}$: location in the $x_{2}$ direction. \n3. $x_{3}$: location in the $x_{3}$ direction. \n4. $v_{1}$: velocity in the $v_{1}$ direction. \n5. $v_{2}$: velocity in the $v_{2}$ direction. \n6. $v_{3}$: velocity in the $v_{3}$ direction. \n7. $a_{1}$: velocity in the $a_{1}$ direction. \n8. $a_{2}$: velocity in the $a_{2}$ direction. \n9. $a_{3}$: velocity in the $a_{3}$ direction.\n","5151ca50":" ## <center> 2 EXTENSIVE CASE STUDIES USING KALMAN FILTERING <\/center>","8c0d74ee":"## 3.3.3 Observation Matrix, $H_{k}$\nWe always observe the velocity, $v_{1}$ and $v_{2}$, which results in the following simple\nmodel for $H_{k}$:\n\n\n \\begin{pmatrix}\n     0.0 & 0.0 & 1.0 & 0.0 \\\\ \n     0.0 & 0.0 & 0.0 & 1.0 \\\\ \n \\end{pmatrix}","fd0f4dc7":"## 1.  Problem Statement\n\nOur goal is to track the location (and velocity) of a moving object, e.g. a ball, in a 3-dimensional space. We will allow gravity to act on the ball and the initial position and velocities are assumed to be known. We will be using noisy location estimates using a (simulated) sensor. The objective is to estimate the true location (and velocity) of the ball in 3D space.","9871d9a0":"## <CENTER> HERE BEGINS THE PROGRAMMING FOR THE FIRST CASE STUDY <\/CENTER>"}}