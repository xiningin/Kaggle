{"cell_type":{"9f81ffb3":"code","df2108c7":"code","0644f440":"code","0ad6f8bf":"code","7841d591":"code","8760aced":"code","b17c58d7":"code","2f99f381":"code","f68013a3":"code","2d9c5ef3":"code","d4b7db52":"code","4accc887":"code","a0ea5697":"code","efe4d8b8":"code","70106720":"code","d632c078":"code","aaedd918":"code","5667991a":"code","a9522783":"code","dc24e0a2":"code","b48a4649":"code","5031f8d0":"code","d5ebd126":"code","1bf5a274":"code","998f98e4":"code","a86fba1f":"code","4abd83bd":"code","24595f30":"code","535846ff":"code","9303e2d7":"code","8e7cb87d":"code","f9d320c7":"code","f3f9a2bd":"code","9cce1c4f":"markdown","c9511f1a":"markdown","b3ba2dd8":"markdown","8e1d2e10":"markdown","df0bd1f4":"markdown","c24cfbe1":"markdown","3d874e66":"markdown","fef3f8c0":"markdown","95ba7489":"markdown","374b112f":"markdown","2686ebcb":"markdown","7e64ec72":"markdown","b7538a13":"markdown","bc966dae":"markdown","2e46b981":"markdown","b5b5c0f9":"markdown","add6cfc5":"markdown","e1f84c35":"markdown","01f52256":"markdown","b3127c82":"markdown","5bbfa8d1":"markdown","1d86c88e":"markdown","c3bd715e":"markdown","31f882c7":"markdown","9359f58b":"markdown","4c5e799d":"markdown","f3361428":"markdown","9af814b6":"markdown","767cd3e0":"markdown","635b5302":"markdown","0567905e":"markdown","ad38a98b":"markdown","65a30259":"markdown","fc8cf8f2":"markdown","aa19067e":"markdown","b32177a3":"markdown","7923f0ac":"markdown"},"source":{"9f81ffb3":"!pip install qiskit --upgrade","df2108c7":"import qiskit\nqiskit.__qiskit_version__","0644f440":"from qiskit import IBMQ\n\n# use your account credentials instead\nIBMQ.update_account()","0ad6f8bf":"# loading your account\nIBMQ.load_account()","7841d591":"# Do the necessary imports\nimport numpy as np\nfrom qiskit.extensions import Initialize\nfrom qiskit import QuantumCircuit, QuantumRegister\nfrom qiskit import ClassicalRegister, execute, BasicAer, IBMQ\nfrom qiskit_textbook.tools import random_state, array_to_latex\nfrom qiskit.visualization import plot_histogram, plot_bloch_multivector","8760aced":"## SETUP\n# Protocol uses 3 qubits and 2 classical bits in 2 different registers\n\nqr = QuantumRegister(3, name=\"q\")    # Protocol uses 3 qubits\ncrz = ClassicalRegister(1, name=\"crz\") # and 2 classical bits\ncrx = ClassicalRegister(1, name=\"crx\") # in 2 different registers\nteleportation_circuit = QuantumCircuit(qr, crz, crx)\nteleportation_circuit.draw('mpl')","b17c58d7":"def create_bell_pair(qc, a, b):\n    \"\"\"Creates a bell pair in qc using qubits a & b\"\"\"\n    qc.h(a) # Put qubit a into state |+>\n    qc.cx(a,b) # CNOT with a as control and b as target","2f99f381":"qr = QuantumRegister(3, name=\"q\")\ncrz, crx = ClassicalRegister(1, name=\"crz\"), ClassicalRegister(1, name=\"crx\")\nqc = QuantumCircuit(qr, crz, crx)\n\nqc.h(1) # Put qubit a into state |+>\nqc.cx(1,2) # CNOT with a as control and b as target\n\nprint(qc.qasm())","f68013a3":"## SETUP\n# Protocol uses 3 qubits and 2 classical bits in 2 different registers\nqr = QuantumRegister(3, name=\"q\")\ncrz, crx = ClassicalRegister(1, name=\"crz\"), ClassicalRegister(1, name=\"crx\")\nteleportation_circuit = QuantumCircuit(qr, crz, crx)\n\n## STEP 1\n# In our case, Telamon entangles qubits q1 and q2\n# Let's apply this to our circuit:\ncreate_bell_pair(teleportation_circuit, 1, 2)\n# And view the circuit so far:\nteleportation_circuit.draw()","2d9c5ef3":"print(teleportation_circuit.qasm())","d4b7db52":"def alice_gates(qc, psi, a):\n    qc.cx(psi, a)\n    qc.h(psi)","4accc887":"## SETUP\n# Protocol uses 3 qubits and 2 classical bits in 2 different registers\nqr = QuantumRegister(3, name=\"q\")\ncrz, crx = ClassicalRegister(1, name=\"crz\"), ClassicalRegister(1, name=\"crx\")\nteleportation_circuit = QuantumCircuit(qr, crz, crx)\n\n## STEP 1\ncreate_bell_pair(teleportation_circuit, 1, 2)\n\n## STEP 2\nteleportation_circuit.barrier() # Use barrier to separate steps\nalice_gates(teleportation_circuit, 0, 1)\nteleportation_circuit.draw()","a0ea5697":"def measure_and_send(qc, a, b):\n    \"\"\"Measures qubits a & b and 'sends' the results to Bob\"\"\"\n    qc.barrier()\n    qc.measure(a,0)\n    qc.measure(b,1)","efe4d8b8":"## SETUP\n# Protocol uses 3 qubits and 2 classical bits in 2 different registers\nqr = QuantumRegister(3, name=\"q\")\ncrz, crx = ClassicalRegister(1, name=\"crz\"), ClassicalRegister(1, name=\"crx\")\nteleportation_circuit = QuantumCircuit(qr, crz, crx)\n\n## STEP 1\ncreate_bell_pair(teleportation_circuit, 1, 2)\n\n## STEP 2\nteleportation_circuit.barrier() # Use barrier to separate steps\nalice_gates(teleportation_circuit, 0, 1)\n\n## STEP 3\nmeasure_and_send(teleportation_circuit, 0 ,1)\nteleportation_circuit.draw()","70106720":"# This function takes a QuantumCircuit (qc), integer (qubit)\n# and ClassicalRegisters (crz & crx) to decide which gates to apply\ndef bob_gates(qc, qubit, crz, crx):\n    # Here we use c_if to control our gates with a classical\n    # bit instead of a qubit\n    qc.x(qubit).c_if(crx, 1) # Apply gates if the registers \n    qc.z(qubit).c_if(crz, 1) # are in the state '1'","d632c078":"## SETUP\n# Protocol uses 3 qubits and 2 classical bits in 2 different registers\nqr = QuantumRegister(3, name=\"q\")\ncrz, crx = ClassicalRegister(1, name=\"crz\"), ClassicalRegister(1, name=\"crx\")\nteleportation_circuit = QuantumCircuit(qr, crz, crx)\n\n## STEP 1\ncreate_bell_pair(teleportation_circuit, 1, 2)\n\n## STEP 2\nteleportation_circuit.barrier() # Use barrier to separate steps\nalice_gates(teleportation_circuit, 0, 1)\n\n## STEP 3\nmeasure_and_send(teleportation_circuit, 0, 1)\n\n## STEP 4\nteleportation_circuit.barrier() # Use barrier to separate steps\nbob_gates(teleportation_circuit, 2, crz, crx)\nteleportation_circuit.draw()","aaedd918":"print(teleportation_circuit.qasm())","5667991a":"# Create random 1-qubit state\npsi = random_state(1)\n\n# Display it nicely\narray_to_latex(psi, pretext=\"|\\\\psi\\\\rangle =\")\n# Show it on a Bloch sphere\nplot_bloch_multivector(psi)","a9522783":"init_gate = Initialize(psi)\ninit_gate.label = \"init\"","dc24e0a2":"## SETUP\nqr = QuantumRegister(3, name=\"q\")   # Protocol uses 3 qubits\ncrz = ClassicalRegister(1, name=\"crz\") # and 2 classical registers\ncrx = ClassicalRegister(1, name=\"crx\")\nqc = QuantumCircuit(qr, crz, crx)\n\n## STEP 0\n# First, let's initialize Alice's q0\nqc.append(init_gate, [0])\nqc.barrier()\n\n## STEP 1\n# Now begins the teleportation protocol\ncreate_bell_pair(qc, 1, 2)\nqc.barrier()\n\n## STEP 2\n# Send q1 to Alice and q2 to Bob\nalice_gates(qc, 0, 1)\n\n## STEP 3\n# Alice then sends her classical bits to Bob\nmeasure_and_send(qc, 0, 1)\n\n## STEP 4\n# Bob decodes qubits\nbob_gates(qc, 2, crz, crx)\n\n# Display the circuit\nqc.draw()","b48a4649":"backend = BasicAer.get_backend('statevector_simulator')\nout_vector = execute(qc, backend).result().get_statevector()\nplot_bloch_multivector(out_vector)","5031f8d0":"inverse_init_gate = init_gate.gates_to_uncompute()","d5ebd126":"## SETUP\nqr = QuantumRegister(3, name=\"q\")   # Protocol uses 3 qubits\ncrz = ClassicalRegister(1, name=\"crz\") # and 2 classical registers\ncrx = ClassicalRegister(1, name=\"crx\")\nqc = QuantumCircuit(qr, crz, crx)\n\n## STEP 0\n# First, let's initialize Alice's q0\nqc.append(init_gate, [0])\nqc.barrier()\n\n## STEP 1\n# Now begins the teleportation protocol\ncreate_bell_pair(qc, 1, 2)\nqc.barrier()\n\n## STEP 2\n# Send q1 to Alice and q2 to Bob\nalice_gates(qc, 0, 1)\n\n## STEP 3\n# Alice then sends her classical bits to Bob\nmeasure_and_send(qc, 0, 1)\n\n## STEP 4\n# Bob decodes qubits\nbob_gates(qc, 2, crz, crx)\n\n## STEP 5\n# reverse the initialization process\nqc.append(inverse_init_gate, [2])\n\n# Display the circuit\nqc.draw()","1bf5a274":"# Need to add a new ClassicalRegister\n# to see the result\ncr_result = ClassicalRegister(1)\nqc.add_register(cr_result)\nqc.measure(2,2)\nqc.draw()","998f98e4":"backend = BasicAer.get_backend('qasm_simulator')\ncounts = execute(qc, backend, shots=1024).result().get_counts()\nplot_histogram(counts)","a86fba1f":"print(qc.qasm())","4abd83bd":"#IBMQ.load_account()\n\nmy_provider = IBMQ.get_provider()\nmy_provider.backends()","24595f30":"def new_bob_gates(qc, a, b, c):\n    qc.cz(a, c)\n    qc.cx(b, c)","535846ff":"qc = QuantumCircuit(3,1)\n\n# First, let's initialize Alice's q0\nqc.append(init_gate, [0])\nqc.barrier()\n\n# Now begins the teleportation protocol\ncreate_bell_pair(qc, 1, 2)\nqc.barrier()\n# Send q1 to Alice and q2 to Bob\nalice_gates(qc, 0, 1)\nqc.barrier()\n# Alice sends classical bits to Bob\nnew_bob_gates(qc, 0, 1, 2)\n\n# We undo the initialization process\nqc.append(inverse_init_gate, [2])\n\n# See the results, we only care about the state of qubit 2\nqc.measure(2,0)\n\n# View the results:\nqc.draw()","9303e2d7":"# First, see what devices we are allowed to use by loading our saved accounts\nIBMQ.load_account()\nprovider = IBMQ.get_provider(hub='ibm-q')\nprovider.backends()","8e7cb87d":"# get the least-busy backend at IBM and run the quantum circuit there\nfrom qiskit.providers.ibmq import least_busy\nbackend = least_busy(provider.backends(filters=lambda b: b.configuration().n_qubits >= 3 and\n                                   not b.configuration().simulator and b.status().operational==True))\njob_exp = execute(qc, backend=backend, shots=8192)","f9d320c7":"# Get the results and display them\nexp_result = job_exp.result()\nexp_measurement_result = exp_result.get_counts(qc)\nprint(exp_measurement_result)\nplot_histogram(exp_measurement_result)","f3f9a2bd":"error_rate_percent = sum([exp_measurement_result[result] for result in exp_measurement_result.keys() if result[0]=='1']) \\\n                    * 100.\/ sum(list(exp_measurement_result.values()))\nprint(\"The experimental error rate : \", error_rate_percent, \"%\")","9cce1c4f":"Let's say Alice owns $q_1$ and Bob owns $q_2$ after they part ways.\n\n#### Step 2 \n\nAlice applies a CNOT gate to $q_1$, controlled by $\\vert\\psi\\rangle$ (the qubit she is trying to send Bob). Then Alice applies a Hadamard gate to $|\\psi\\rangle$. In our quantum circuit, the qubit ($|\\psi\\rangle$) Alice is trying to send is $q_0$:","c9511f1a":"We can see we have a 100% chance of measuring $q_2$ (the leftmost bit in the string) in the state $|0\\rangle$. This is the expected result, and indicates the teleportation protocol has worked properly.","b3ba2dd8":"In this notebook, we will initialize Alice's qubit in a random state $\\vert\\psi\\rangle$ (`psi`). This state will be created using an `Initialize` gate on $|q_0\\rangle$. In this chapter we use the function `random_state` to choose `psi` for us, but feel free to set `psi` to any qubit state you want.","8e1d2e10":"### 5.1 IBM hardware and Deferred Measurement <a id='deferred-measurement'><\/a>\n\nThe IBM quantum computers currently do not support instructions after measurements, meaning we cannot run the quantum teleportation in its current form on real hardware. Fortunately, this does not limit our ability to perform any computations due to the _deferred measurement principle_ discussed in chapter 4.4 of [1]. The principle states that any measurement can be postponed until the end of the circuit, i.e. we can move all the measurements to the end, and we should see the same results.\n\n![deferred_measurement_gates](images\/defer_measurement.svg)\n\nAny benefits of measuring early are hardware related: If we can measure early, we may be able to reuse qubits, or reduce the amount of time our qubits are in their fragile superposition. In this example, the early measurement in quantum teleportation would have allowed us to transmit a qubit state without a direct quantum communication channel.\n\nWhile moving the gates allows us to demonstrate the \"teleportation\" circuit on real hardware, it should be noted that the benefit of the teleportation process (transferring quantum states via classical channels) is lost.\n\nLet us re-write the `bob_gates` function to `new_bob_gates`:","df0bd1f4":"## 6. References <a id='references'><\/a>\n[1] M. Nielsen and I. Chuang, Quantum Computation and Quantum Information, Cambridge Series on Information and the Natural Sciences (Cambridge University Press, Cambridge, 2000).\n\n[2] Eleanor Rieffel and Wolfgang Polak, Quantum Computing: a Gentle Introduction (The MIT Press Cambridge England, Massachusetts, 2011).","c24cfbe1":"![Summary](https:\/\/raw.githubusercontent.com\/praveentn\/ml-repos\/master\/Quantum\/images\/qtele-11.png)","3d874e66":"Again, there is a rendering issue with the `inverse_init_gate` (called 'disentangler' on the circuit diagram), but we can clearly see the gate appearing in the image. Finally, we measure the third qubit and store the result in the third classical bit:","fef3f8c0":"## 1. Overview <a id='overview'><\/a>","95ba7489":"This notebook demonstrates quantum teleportation. We first use Qiskit's built-in simulators to test our quantum circuit, and then try it out on a real quantum computer....\n\n## Contents\n\n1. [Overview](#overview)    \n2. [The Quantum Teleportation Protocol](#how)       \n3. [Simulating the Teleportation Protocol](#simulating)   \n    3.1 [How will we Test this Result on a Real Quantum Computer?](#testing)   \n    3.2 [Using the Statevector Simulator](#simulating-sv)     \n    3.3 [Using the QASM Simulator](#simulating-qs)  \n4. [Understanding Quantum Teleportation](#understanding-qt)\n5. [Teleportation on a Real Quantum Computer](#real_qc)    \n    5.1 [IBM hardware and Deferred Measurement](#deferred-measurement)    \n    5.2 [Executing](#executing)    \n6. [References](#references)\n\n","374b112f":"and create our quantum circuit:","2686ebcb":"#### Step 1\nA third party, Telamon, creates an entangled pair of qubits and gives one to Bob and one to Alice.\n\nThe pair Telamon creates is a special pair called a Bell pair. In quantum circuit language, the way to create a Bell pair between two qubits is to first transfer one of them to the X-basis ($|+\\rangle$ and $|-\\rangle$) using a Hadamard gate, and then to apply a CNOT gate onto the other qubit controlled by the one in the X-basis. ","7e64ec72":"## 2. The Quantum Teleportation Protocol <a id='how'><\/a>\nTo transfer a quantum bit, Alice and Bob must use a third party (Telamon) to send them an entangled qubit pair. Alice then performs some operations on her qubit, sends the results to Bob over a classical communication channel, and Bob then performs some operations on his end to receive Alice\u2019s qubit..\n\n![teleportation_doodle](images\/tele1.jpg)\n\nWe will describe the steps on a quantum circuit below. Here, no qubits are actually \u2018sent\u2019, you\u2019ll just have to imagine that part!\n\nFirst we set up our session:","b7538a13":"#### Step 3\n\nAlice measures the first two qubit (which she owns) and sends them as two classical bits to Bob. The result she obtains is always one of the four standard basis states $|00\\rangle, |01\\rangle, |10\\rangle,$ and $|11\\rangle$ with equal probability.  \n\nOn the basis of her measurement, Bob's state will be projected to, \n$$ |00\\rangle \\rightarrow (a|0\\rangle + b|1\\rangle)\\\\\n|01\\rangle \\rightarrow (a|1\\rangle + b|0\\rangle)\\\\\n|10\\rangle \\rightarrow (a|0\\rangle - b|1\\rangle)\\\\\n|11\\rangle \\rightarrow (a|1\\rangle - b|0\\rangle)$$.","bc966dae":"As you have worked with the Quantum Teleportation's implementation, it is time to understand the mathematics behind the protocol.\n\n#### Step 1\n\nQuantum Teleportation begins with the fact that Alice needs to transmit $|q\\rangle = a|0\\rangle + b|1\\rangle$ (a random qubit) to Bob. She doesn't know the state of the qubit. For this, Alice and Bob take the help of a third party (Telamon). Telamon prepares a pair of entangled qubits for Alice and Bob. The entangled qubits could be written in Dirac Notation as:\n\n$$ |\\psi \\rangle = \\frac{1}{\\sqrt{2}} (|00\\rangle + |11\\rangle) $$\n\nAlice and Bob each possess one qubit of the entangled pair (denoted as A and B respectively),\n\n$$|\\psi\\rangle = \\frac{1}{\\sqrt{2}} (|0\\rangle_A |0\\rangle_B + |1\\rangle_A |1\\rangle_B) $$\n\nThis creates a three qubit quantum system where Alice has the first two qubits and Bob the last one.\n\n$$ \\begin{align*}\n|q\\rangle \\otimes |\\psi\\rangle &= \\frac{1}{\\sqrt{2}} (a |0\\rangle \\otimes (|00\\rangle + |11\\rangle) + b |1\\rangle \\otimes (|00\\rangle + |11\\rangle))\\\\\n&= \\frac{1}{\\sqrt{2}} (a|000\\rangle + a|011\\rangle + b|100\\rangle + b|111\\rangle) \n\\end{align*}$$","2e46b981":"If the quantum teleportation circuit works, then at the end of the circuit the qubit $|q_2\\rangle$ will be in this state. We will check this using the statevector simulator.","b5b5c0f9":"Let's create our initialization gate to create $|\\psi\\rangle$ from the state $|0\\rangle$:","add6cfc5":"And voila! At the end of this protocol, Alice's qubit has now teleported to Bob.","e1f84c35":"## 5. Teleportation on a Real Quantum Computer <a id='real_qc'><\/a>","01f52256":"1. # Quantum Teleportation","b3127c82":"At the time of writing, there is a rendering issue with the `Initialize` gate in the image above, but the circuit operates just fine. We can see below, using our statevector simulator, that the state of $|q_2\\rangle$ is the same as the state $|\\psi\\rangle$ we created above, while the states of $|q_0\\rangle$ and $|q_1\\rangle$ have been collapsed to either $|0\\rangle$ or $|1\\rangle$. The state $|\\psi\\rangle$ has been teleported from qubit 0 to qubit 2.","5bbfa8d1":"As we see here, there are a few results in which we measured $|1\\rangle$. These arise due to errors in the gates and the qubits. In contrast, our simulator in the earlier part of the notebook had zero errors in its gates, and allowed error-free teleportation.","1d86c88e":"## 3. Simulating the Teleportation Protocol <a id='simulating'><\/a>","c3bd715e":"#### Step 3\n\nNext, Alice applies a measurement to both qubits that she owns, $q_1$ and $\\vert\\psi\\rangle$, and stores this result in two classical bits. She then sends these two bits to Bob.","31f882c7":"### Updating your IBM Quantum Experience credentials","9359f58b":"And create our new circuit:","4c5e799d":"## 4. Understanding Quantum Teleportation <a id=\"understanding-qt\">","f3361428":"### 3.2 Using the Statevector Simulator <a id='simulating-sv'><\/a>\n\nWe can use the statevector simulator to verify our qubit has been teleported.","9af814b6":"### 3.1 How Will We Test the Protocol on a Quantum Computer? <a id='testing'><\/a>","767cd3e0":"This operation has the property:\n\n$$ |\\psi\\rangle \\xrightarrow{\\text{Inverse Initialize}} |0\\rangle $$\n\nTo prove the qubit $|q_0\\rangle$ has been teleported to $|q_2\\rangle$, if we do this inverse initialization on $|q_2\\rangle$, we expect to measure $|0\\rangle$ with certainty. We do this in the circuit below:","635b5302":"### 5.2 Executing <a id='executing'><\/a> ","0567905e":"Alice wants to send quantum information to Bob. Specifically, suppose she wants to send the qubit state\n$\\vert\\psi\\rangle = \\alpha\\vert0\\rangle + \\beta\\vert1\\rangle$...\nThis entails passing on information about $\\alpha$ and $\\beta$ to Bob...\n\nThere exists a theorem in quantum mechanics which states that you cannot simply make an exact copy of an unknown quantum state. This is known as the no-cloning theorem. As a result of this we can see that Alice can't simply generate a copy of $\\vert\\psi\\rangle$ and give the copy to Bob. We can only copy classical states (not superpositions)..\n\nHowever, by taking advantage of two classical bits and an entangled qubit pair, Alice can transfer her state $\\vert\\psi\\rangle$ to Bob. We call this teleportation because, at the end, Bob will have $\\vert\\psi\\rangle$ and Alice won't anymore.","ad38a98b":"### 3.3 Using the QASM Simulator <a id='simulating-qs'><\/a>\n\nQuantum teleportation is designed to send qubits between two parties. We do not have the hardware to demonstrate this, but we can demonstrate that the gates perform the correct transformations on a single quantum chip. Here we use the QASM simulator to simulate how we might test our protocol.\n\nOn a real quantum computer, we would not be able to sample the statevector, so if we wanted to check our teleportation circuit is working, we need to do things slightly differently. You will remember that we used `Initialize` to turn our $|0\\rangle$ qubit into the state $|\\psi\\rangle$:\n\n$$ |0\\rangle \\xrightarrow{\\text{Initialize}} |\\psi\\rangle $$\n\nSince all quantum gates are reversible, we can find the inverse of Initialize using:","65a30259":"and we run our experiment:","fc8cf8f2":"#### Step 2\n\nNow according to the protocol Alice applies CNOT gate on her two qubits followed by Hadamard gate on the first qubit. This results in the state:\n\n$$ \n\\begin{align*} (H \\otimes I \\otimes I) (CNOT \\otimes I) (|q\\rangle \\otimes |\\psi\\rangle)\n&=(H \\otimes I \\otimes I) (CNOT \\otimes I) \\frac{1}{\\sqrt{2}} (a|000\\rangle + a|011\\rangle + b|100\\rangle + b|111\\rangle) \\\\\n&= (H \\otimes I \\otimes I) \\frac{1}{\\sqrt{2}} (a|000\\rangle + a|011\\rangle + b|110\\rangle + b|101\\rangle) \\\\\n&= \\frac{1}{2}  (a(|000\\rangle + |011\\rangle + |100\\rangle + |111\\rangle) + b(|010\\rangle + |001\\rangle - |110\\rangle - |101\\rangle)) \\\\\n\\end{align*}\n$$\n\nWhich can then be separated and written as: \n\n$$\n\\begin{align*}\n= \\frac{1}{2}(\n & \\phantom{+} |00\\rangle (a|0\\rangle + b|1\\rangle) \\hphantom{\\quad )} \\\\\n & + |01\\rangle (a|1\\rangle + b|0\\rangle) \\hphantom{\\quad )}\\\\[4pt]\n & + |10\\rangle (a|0\\rangle - b|1\\rangle) \\hphantom{\\quad )}\\\\[4pt]\n & + |11\\rangle (a|1\\rangle - b|0\\rangle) \\quad )\\\\\n\\end{align*}\n$$","aa19067e":"You can run this cell a few times to make sure. You may notice that the qubits 0 & 1 change states, but qubit 2 is always in the state $|\\psi\\rangle$.","b32177a3":"#### Step 4\n\nBob, who already has the qubit $q_2$, then applies the following gates depending on the state of the classical bits:\n\n00 $\\rightarrow$ Do nothing\n\n01 $\\rightarrow$ Apply $X$ gate\n\n10 $\\rightarrow$ Apply $Z$ gate\n\n11 $\\rightarrow$ Apply $ZX$ gate\n\n(*Note that this transfer of information is purely classical*.)","7923f0ac":"#### Step 4\n\nBob, on receiving the bits from Alice, knows he can obtain the original state $|q\\rangle$ by applying appropriate transformations on his qubit that was once part of the entangled pair.\n\nThe transformations he needs to apply are:\n\n![title](images\/teleportation-transformation.png)\n\nAfter this step Bob will have successfully reconstructed Alice's state."}}