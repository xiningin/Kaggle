{"cell_type":{"ce215e94":"code","29987329":"code","b8b40c20":"code","1f89a38a":"code","f749d872":"code","a613487c":"markdown","5d0e079a":"markdown","4ffcde80":"markdown","f10b1dc4":"markdown","c824ec4e":"markdown","993b1cf7":"markdown"},"source":{"ce215e94":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt","29987329":"def fobj(x):\n    obj = (x[0]**2) \/ 2\n    return obj\n\ndef side_obj_1(x):\n    side_obj_1 = (x[0]**3) \n    return side_obj_1","b8b40c20":"def De_Algorithm_new(fobj, side_obj_1, bounds, mut=0.8, crossp=0.7, popsize=100, its=1000):\n\n    def generate_candidate(fobj, side_obj_1, bounds):\n    \n        cond = True\n        while cond == True:\n\n            dimensions = len(bounds)\n            pop = np.random.rand(1, dimensions)\n            min_b, max_b = np.asarray(bounds).T\n            diff = np.fabs(min_b - max_b)\n            pop_denorm = min_b + pop * diff\n            # calculate the fitness using fitness function and save it into the fitness parameter\n            fitness = np.asarray([fobj(ind) for ind in pop_denorm])\n            # calculate the side objective function and save it into the side object_1 parameter\n            side_obj_1_fitness = np.asarray([side_obj_1(ind) for ind in pop_denorm])\n            #evaluate the side objective function and filter those candidates\n            #that are not satisfied the side_objective function.\n            # Here we use side objective function and we want to make sure that the DE performs evolution on those candidates \n            # that is between 900 and 1000 values generated by side objective function.\n            if side_obj_1_fitness[0] < 1000 and side_obj_1_fitness[0] > 900:\n                cond = False\n    #             print('candidate = ', pop_denorm)\n\n    #     print('fitness = ', fitness[0]), print('side_obj_1_fitness = ', side_obj_1_fitness[0])\n        return pop[0], pop_denorm[0]\n\n    dimensions = len(bounds)\n    pop_denorm = np.empty([dimensions])\n    pop = np.empty([dimensions])\n\n    for i in range(0, (popsize-1)):\n        #pop[0], pop_denorm[0]\n        ans1, ans2 = generate_candidate(fobj, side_obj_1, bounds)\n        \n        pop_denorm = np.vstack([pop_denorm,ans2])\n        pop = np.vstack([pop,ans1])\n\n    min_b, max_b = np.asarray(bounds).T\n    diff = np.fabs(min_b - max_b)\n    pop_denorm = min_b + pop * diff\n\n    fitness = np.asarray([fobj(ind) for ind in pop_denorm])\n    #Sub_Objective function are evaluated at the following.\n    side_obj_1_fitness = np.asarray([side_obj_1(ind) for ind in pop_denorm])\n    \n    best_idx = np.argmin(fitness)\n    best = pop_denorm[best_idx]\n\n    for i in range(its):\n\n        for j in range(popsize):\n\n            trial_denorm, trial = gene_trial_in_range(popsize, j, mut, dimensions, crossp, pop, min_b, diff)\n            # Objective function is evaluated at the following.\n            f = fobj(trial_denorm)\n            # Sub_Objective function is evaluated at the following.\n            f1 = side_obj_1(trial_denorm)\n\n            if f < fitness[j] and f1 < 10000000:\n\n                fitness[j] = f\n                pop[j] = trial\n                if f < fitness[best_idx]:\n                    best_idx = j\n                    best = trial_denorm\n                    \n#         yield best, fitness[best_idx]\n        yield min_b + pop * diff, fitness, best_idx","1f89a38a":"def gene_trial_in_range(popsize, j, mut, dimensions, crossp, pop, min_b, diff):\n    \n    cond = True\n    while cond == True:\n        \n        idxs = [idx for idx in range(popsize) if idx != j]\n        a, b, c = pop[np.random.choice(idxs, 3, replace = False)]\n        mutant = np.clip(a + mut * (b - c), 0, 1)\n        cross_points = np.random.rand(dimensions) < crossp\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, dimensions)] = True\n\n        trial = np.where(cross_points, mutant, pop[j])\n        trial_denorm = min_b + trial * diff\n        cond = False\n\n    return trial_denorm, trial","f749d872":"bounds = [(-10, 10)]\nres = De_Algorithm_new(fobj, side_obj_1, bounds,mut=0.7, crossp=0.8, popsize=5, its=4)\nres = list(res)\nres[-1]","a613487c":"### Define a function that generates trials in range.","5d0e079a":"![evolution-3885331_960_720.jpg](attachment:evolution-3885331_960_720.jpg)\nref:https:\/\/www.entrepreneur.com\/article\/333392","4ffcde80":"### Here we define the DE algorithm. The main DE algorithm codes were written by Pablo R. Mier. please check out main codes at https:\/\/pablormier.github.io\/2017\/09\/05\/a-tutorial-on-differential-evolution-with-python\/#\n\n### here I will  change the codes little bit so the main codes can accept and consider the side objective function.","f10b1dc4":"### Import some libraries.","c824ec4e":"# In this Kernel we will modify the DE algorithm codes. \n### Here you may use the DE algorithm along with side_objective function for your optimization.","993b1cf7":"### Define the main objective function and side objective function.\n#### you may add more side objective functions later and introude it to the DE algorithm."}}