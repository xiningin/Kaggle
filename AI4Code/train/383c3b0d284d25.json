{"cell_type":{"30340b73":"code","3e8c18c0":"code","1cf2258f":"code","d1d8f541":"code","cc1bd46e":"code","dd867c2e":"code","b5276f17":"code","228ec52f":"code","c25e6777":"code","8c2722d2":"code","fcef68f7":"code","16844d88":"code","8f9b6da5":"code","83ea6d29":"code","2e90a828":"code","a9ee03a2":"code","331f31c1":"code","fc37c658":"code","d1a31791":"code","f233afea":"code","e2b7a82a":"markdown","2357db1d":"markdown","9eb416b0":"markdown","7927840e":"markdown","6dd6d2e4":"markdown","75bc1d5a":"markdown"},"source":{"30340b73":"from fastai.vision.all import *","3e8c18c0":"set_seed(999)","1cf2258f":"%cd ..\/input\/timm030\/pytorch-image-models-master\/pytorch-image-models-master\/\nfrom timm import create_model\n%cd ..\/..\/..\/..\/","d1d8f541":"%ls","cc1bd46e":"from fastai.vision.learner import _update_first_layer\n\n# Cell\ndef create_timm_body(arch:str, pretrained=True, cut=None, n_in=3):\n    \"Creates a body from any model in the `timm` library.\"\n    model = create_model(arch, pretrained=pretrained, num_classes=0, global_pool='')\n    _update_first_layer(model, n_in, pretrained)\n    if cut is None:\n        ll = list(enumerate(model.children()))\n        cut = next(i for i,o in reversed(ll) if has_pool_type(o))\n    if isinstance(cut, int): return nn.Sequential(*list(model.children())[:cut])\n    elif callable(cut): return cut(model)\n    else: raise NamedError(\"cut must be either integer or function\")\n\n# Cell\ndef create_timm_model(arch:str, n_out, cut=None, pretrained=True, n_in=3, init=nn.init.kaiming_normal_, custom_head=None,\n                     concat_pool=True, **kwargs):\n    \"Create custom architecture using `arch`, `n_in` and `n_out` from the `timm` library\"\n    body = create_timm_body(arch, pretrained, None, n_in)\n    if custom_head is None:\n        nf = num_features_model(nn.Sequential(*body.children())) * (2 if concat_pool else 1)\n        head = create_head(nf, n_out, concat_pool=concat_pool, **kwargs)\n    else: head = custom_head\n    model = nn.Sequential(body, head)\n    if init is not None: apply_init(model[1], init)\n    return model\n\n# Cell\nfrom fastai.vision.learner import _add_norm\n\n# Cell\ndef timm_learner(dls, arch:str, loss_func=None, pretrained=True, cut=None, splitter=None,\n                y_range=None, config=None, n_out=None, normalize=True, **kwargs):\n    \"Build a convnet style learner from `dls` and `arch` using the `timm` library\"\n    if config is None: config = {}\n    if n_out is None: n_out = get_c(dls)\n    assert n_out, \"`n_out` is not defined, and could not be inferred from data, set `dls.c` or pass `n_out`\"\n    if y_range is None and 'y_range' in config: y_range = config.pop('y_range')\n    model = create_timm_model(arch, n_out, default_split, pretrained, y_range=y_range, **config)\n    learn = Learner(dls, model, loss_func=loss_func, splitter=default_split, **kwargs)\n    if pretrained: learn.freeze()\n    return learn","dd867c2e":"path = Path(\"input\")\ndata_path = path\/'cassava-leaf-disease-classification'","b5276f17":"data_path.ls()","228ec52f":"df = pd.read_csv(data_path\/'train.csv')","c25e6777":"df['image_id'] = df['image_id'].apply(lambda x: f'train_images\/{x}')","8c2722d2":"blocks = (ImageBlock, CategoryBlock)\nsplitter = RandomSplitter(valid_pct=0.2)\ndef get_x(row): return data_path\/row['image_id']\n\ndef get_y(row): return row['label']\nitem_tfms = [Resize(512)]\nbatch_tfms = [RandomResizedCropGPU(448), *aug_transforms(), Normalize.from_stats(*imagenet_stats)]\nblock = DataBlock(blocks = blocks,\n                 get_x = get_x,\n                 get_y = get_y,\n                 splitter = splitter,\n                 item_tfms = item_tfms,\n                 batch_tfms = batch_tfms)\ndls = block.dataloaders(df, bs=32)\n","fcef68f7":"learn = timm_learner(dls, 'efficientnet_b3', metrics=accuracy, pretrained=False)","16844d88":"learn.model_dir = Path('input\/b3_example_submission')","8f9b6da5":"load_model(Path('input\/b3-example-submission\/b3.pth'), learn.model, learn.opt)","83ea6d29":"sample_df = pd.read_csv(data_path\/'sample_submission.csv')\nsample_df.head()","2e90a828":"sample_copy = sample_df.copy()\nsample_copy['image_id'] = sample_copy['image_id'].apply(lambda x: f'test_images\/{x}')","a9ee03a2":"test_dl = learn.dls.test_dl(sample_copy)","331f31c1":"preds, _ = learn.tta(dl=test_dl)","fc37c658":"sample_df['label'] = preds.argmax(dim=-1).numpy()","d1a31791":"%cd working","f233afea":"sample_df.to_csv('submission.csv',index=False)","e2b7a82a":"Finally we can grab our predictions using TTA","2357db1d":"Recreate our data to get access to the `test_dl`:","9eb416b0":"To properly use timm we need to get creative with the imports:","7927840e":"Build a `Learner`","6dd6d2e4":"We'll want to be able to recreate our model fully, so we'll bring in the `wwf` code:","75bc1d5a":"And load in our weights"}}