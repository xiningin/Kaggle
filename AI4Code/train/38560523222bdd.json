{"cell_type":{"9882a1b9":"code","e07ebd3a":"code","05c57f26":"code","745ee72a":"code","fb6950a4":"code","9a72f068":"code","104c4bc4":"code","7cd57c2b":"code","b9105e9d":"code","c4b2e094":"code","de1685cf":"code","e5e1fd21":"code","9461c48e":"code","765b7a8d":"code","e35ff969":"code","a2b62be1":"code","5fe49fc2":"code","a938f247":"code","69b436da":"code","3fea4b8b":"code","0f530a61":"code","fef5d5cb":"code","57c30943":"code","380b0211":"code","c2cd7811":"code","9b64f9e9":"code","d41baa78":"markdown","ce526b59":"markdown","bbe0805b":"markdown","f0d75065":"markdown","accdf874":"markdown","6a8c00ca":"markdown","0ed8469e":"markdown","f712feff":"markdown","5c7a22c5":"markdown"},"source":{"9882a1b9":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import style\nimport seaborn as sns\n \n#configure\n# sets matplotlib to inline and displays graphs below the corressponding cell.\n%matplotlib inline  \nstyle.use('fivethirtyeight')\nsns.set(style='whitegrid',color_codes=True)\n\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score,precision_score,recall_score,confusion_matrix,roc_curve,roc_auc_score\nfrom sklearn.preprocessing import LabelEncoder\n\nfrom keras.preprocessing.image import ImageDataGenerator\n\nfrom keras import backend as K\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.optimizers import Adam,SGD,Adagrad,Adadelta,RMSprop\nfrom keras.utils import to_categorical\n\nfrom keras.layers import Dropout, Flatten,Activation\nfrom keras.layers import Conv2D, MaxPooling2D, BatchNormalization\n\n# specifically for manipulating zipped images and getting numpy arrays of pixel values of images.\nimport cv2                  \nimport os                   \nfrom random import shuffle  \nfrom zipfile import ZipFile\nfrom PIL import Image","e07ebd3a":"for dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","05c57f26":"# Distribution graphs (histogram\/bar graph) of column data\ndef plotPerColumnDistribution(df, nGraphShown, nGraphPerRow):\n    nunique = df.nunique()\n    df = df[[col for col in df if nunique[col] > 1 and nunique[col] < 50]] # For displaying purposes, pick columns that have between 1 and 50 unique values\n    nRow, nCol = df.shape\n    columnNames = list(df)\n    nGraphRow = (nCol + nGraphPerRow - 1) \/ nGraphPerRow\n    plt.figure(num = None, figsize = (6 * nGraphPerRow, 8 * nGraphRow), dpi = 80, facecolor = 'w', edgecolor = 'k')\n    for i in range(min(nCol, nGraphShown)):\n        plt.subplot(nGraphRow, nGraphPerRow, i + 1)\n        columnDf = df.iloc[:, i]\n        if (not np.issubdtype(type(columnDf.iloc[0]), np.number)):\n            valueCounts = columnDf.value_counts()\n            valueCounts.plot.bar()\n        else:\n            columnDf.hist()\n        plt.ylabel('counts')\n        plt.xticks(rotation = 90)\n        plt.title(f'{columnNames[i]} (column {i})')\n    plt.tight_layout(pad = 1.0, w_pad = 1.0, h_pad = 1.0)\n    plt.show()\n","745ee72a":"# Correlation matrix\ndef plotCorrelationMatrix(df, graphWidth):\n    filename = df.dataframeName\n    df = df.dropna('columns') # drop columns with NaN\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    if df.shape[1] < 2:\n        print(f'No correlation plots shown: The number of non-NaN or constant columns ({df.shape[1]}) is less than 2')\n        return\n    corr = df.corr()\n    plt.figure(num=None, figsize=(graphWidth, graphWidth), dpi=80, facecolor='w', edgecolor='k')\n    corrMat = plt.matshow(corr, fignum = 1)\n    plt.xticks(range(len(corr.columns)), corr.columns, rotation=90)\n    plt.yticks(range(len(corr.columns)), corr.columns)\n    plt.gca().xaxis.tick_bottom()\n    plt.colorbar(corrMat)\n    plt.title(f'Correlation Matrix for {filename}', fontsize=15)\n    plt.show()\n","fb6950a4":"# Scatter and density plots\ndef plotScatterMatrix(df, plotSize, textSize):\n    df = df.select_dtypes(include =[np.number]) # keep only numerical columns\n    # Remove rows and columns that would lead to df being singular\n    df = df.dropna('columns')\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    columnNames = list(df)\n    if len(columnNames) > 10: # reduce the number of columns for matrix inversion of kernel density plots\n        columnNames = columnNames[:10]\n    df = df[columnNames]\n    ax = pd.plotting.scatter_matrix(df, alpha=0.75, figsize=[plotSize, plotSize], diagonal='kde')\n    corrs = df.corr().values\n    for i, j in zip(*plt.np.triu_indices_from(ax, k = 1)):\n        ax[i, j].annotate('Corr. coef = %.3f' % corrs[i, j], (0.8, 0.2), xycoords='axes fraction', ha='center', va='center', size=textSize)\n    plt.suptitle('Scatter and Density Plot')\n    plt.show()\n","9a72f068":"data = \"..\/input\/minet\/\"\n\nfolders = os.listdir(data)\n\nprint(folders)","104c4bc4":"image_names = []\ntrain_labels = []\ntrain_images = []\n\nsize = 150,150\n\nfor folder in folders:\n    for file in os.listdir(os.path.join(data,folder)):\n        if file.endswith(\"jpg\"):\n            image_names.append(os.path.join(data,folder,file))\n            train_labels.append(folder)\n            img = cv2.imread(os.path.join(data,folder,file))\n            im = cv2.resize(img,size)\n            train_images.append(im)\n        else:\n            continue","7cd57c2b":"le=LabelEncoder()\nY=le.fit_transform(train_labels)\nY=to_categorical(Y,7)\nX=np.array(train_images)\nX=X\/255","b9105e9d":"x_train,x_test,y_train,y_test=train_test_split(X,Y,test_size=0.3,random_state=42)","c4b2e094":"x_train.shape, y_train.shape, x_test.shape, y_test.shape\n","de1685cf":"model = Sequential()\nmodel.add(Conv2D(filters = 32, kernel_size = (5,5),padding = 'Same',activation ='relu', input_shape = (150,150,3)))\nmodel.add(MaxPooling2D(pool_size=(2,2)))\n\nmodel.add(Conv2D(filters = 64, kernel_size = (3,3),padding = 'Same',activation ='relu'))\nmodel.add(MaxPooling2D(pool_size=(2,2), strides=(2,2)))\n \nmodel.add(Conv2D(filters =96, kernel_size = (3,3),padding = 'Same',activation ='relu'))\nmodel.add(MaxPooling2D(pool_size=(2,2), strides=(2,2)))\n\nmodel.add(Conv2D(filters = 96, kernel_size = (3,3),padding = 'Same',activation ='relu'))\nmodel.add(MaxPooling2D(pool_size=(2,2), strides=(2,2)))\n\nmodel.add(Flatten())\nmodel.add(Dense(512))\nmodel.add(Activation('relu'))\nmodel.add(Dense(7, activation = \"softmax\"))","e5e1fd21":"batch_size=128\nepochs=50\n\n#from keras.callbacks import ReduceLROnPlateau\n#red_lr= ReduceLROnPlateau(monitor='val_acc',patience=3,verbose=1,factor=0.1)","9461c48e":"datagen = ImageDataGenerator(\n        featurewise_center=False,  # set input mean to 0 over the dataset\n        samplewise_center=False,  # set each sample mean to 0\n        featurewise_std_normalization=False,  # divide inputs by std of the dataset\n        samplewise_std_normalization=False,  # divide each input by its std\n        zca_whitening=False,  # apply ZCA whitening\n        rotation_range=30,  # randomly rotate images in the range (degrees, 0 to 180)\n        zoom_range = 0.1, # Randomly zoom image \n        width_shift_range=0.2,  # randomly shift images horizontally (fraction of total width)\n        height_shift_range=0.2,  # randomly shift images vertically (fraction of total height)\n        horizontal_flip=True,  # randomly flip images\n        vertical_flip=False)  # randomly flip images\n\n\ndatagen.fit(x_train)","765b7a8d":"model.compile(optimizer=Adam(lr=0.001),loss='categorical_crossentropy',metrics=['accuracy'])","e35ff969":"sgd = SGD(lr=0.001, decay=1e-6, momentum=0.9, nesterov=True)\nmodel.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])","a2b62be1":"History = model.fit_generator(datagen.flow(x_train,y_train, batch_size=batch_size),\n                              epochs = epochs, validation_data = (x_test,y_test),\n                              verbose = 1, steps_per_epoch=x_train.shape[0] \/\/ batch_size)","5fe49fc2":"#Visualize Training and Validation Accuracy\/Loss\nacc = History.history['accuracy']\nval_acc = History.history['val_accuracy']\n\nloss = History.history['loss']\nval_loss = History.history['val_loss']\n\nepochs_range = range(50)\n\nplt.figure(figsize=(15, 6))\nplt.subplot(1, 2,1)\nplt.plot(epochs_range, acc, label='Training Accuracy')\nplt.plot(epochs_range, val_acc, label='Validation Accuracy')\nplt.legend(loc='upper left')\nplt.title('Training and Validation Accuracy')\n\nplt.subplot(1, 2, 2)\nplt.plot(epochs_range, loss, label='Training Loss')\nplt.plot(epochs_range, val_loss, label='Validation Loss')\nplt.legend(loc='upper right')\nplt.title('Training and Validation Loss')\nplt.show()","a938f247":"#pred=model.predict(x_test)\n#pred_digits=np.argmax(pred,axis=1)\npredictions = model.predict(x_test)\npredictionMineral=np.argmax(predictions,axis=1)","69b436da":"i=0\nprop_class=[]\nmis_class=[]\n\nfor i in range(len(y_test)):\n    if(np.argmax(y_test[i])==predictionMineral[i]):\n        prop_class.append(i)\n    if(len(prop_class)==16):\n        break\n\ni=0\nfor i in range(len(y_test)):\n    if(not np.argmax(y_test[i])==predictionMineral[i]):\n        mis_class.append(i)\n    if(len(mis_class)==16):\n        break","3fea4b8b":"c = np.argmax(y_test, axis=1)","0f530a61":"c.shape","fef5d5cb":"count=0\nfig,ax=plt.subplots(8,2)\nfig.set_size_inches(15,15)\nfor i in range (8):\n    for j in range (2):\n        ax[i,j].imshow(x_test[prop_class[count]])\n        ax[i,j].set_title(\"Mineral Predict : \"+str(le.inverse_transform([predictionMineral[prop_class[count]]]))+\"\\n\"+\"Actual Mineral : \"+str(le.inverse_transform([c[prop_class[count]]])))\n        plt.tight_layout()\n        count+=1\n        ","57c30943":"pred=model.predict(x_test)\npred_digits=np.argmax(pred,axis=1)","380b0211":"i=0\nprop_class=[]\nmis_class=[]\n\nfor i in range(len(y_test)):\n    if(np.argmax(y_test[i])==pred_digits[i]):\n        prop_class.append(i)\n    if(len(prop_class)==6):\n        break\n\ni=0\nfor i in range(len(y_test)):\n    if(not np.argmax(y_test[i])==pred_digits[i]):\n        mis_class.append(i)\n    if(len(mis_class)==6):\n        break","c2cd7811":"mis_class","9b64f9e9":"count=0\nfig,ax=plt.subplots(2,2)\nfig.set_size_inches(15,15)\nfor i in range (2):\n    for j in range (2):\n        ax[i,j].imshow(x_test[prop_class[count]])\n        ax[i,j].set_title(\"Predicted : \"+str(le.inverse_transform([pred_digits[prop_class[count]]])))\n        plt.tight_layout()\n        count+=1","d41baa78":"# We have 6 types of minerals\n**let's see what they are**\n* **muscovite**: is a hydrated phyllosilicate mineral of aluminium and potassium with formula KAl2(AlSi3O10)(F,OH)2, or (KF)2(Al2O3)3(SiO2)6(H2O). Muscovite is the most common mica, found in granites, pegmatites, gneisses, and schists, and as a contact metamorphic rock or as a secondary mineral resulting from the alteration of topaz, feldspar, kyanite.\n* **chrysocolla**: is a hydrated copper phyllosilicate mineral with formula: Cu2\u2212xAlx(H2\u2212xSi2O5)(OH)4\u00b7nH2O (x<1)[1] or (Cu,Al)2H2Si2O5(OH)4\u00b7nH2O. Associated minerals are quartz, limonite, azurite, malachite, cuprite, and other secondary copper minerals.\n* **quartz**: is a hard, crystalline mineral composed of silicon and oxygen atoms. Quartz is a defining constituent of granite and other felsic igneous rocks. It is very common in sedimentary rocks such as sandstone and shale. It is a common constituent of schist, gneiss, quartzite and other metamorphic rocks.\n* **bornite**: is a sulfide mineral with chemical composition Cu5FeS4. Bornite is an important copper ore mineral and occurs widely in porphyry copper deposits along with the more common chalcopyrite.\n* **pyrite**: is an iron sulfide with the chemical formula FeS2 (iron(II) disulfide).\n* **malachite**: is a copper carbonate hydroxide mineral, with the formula Cu2CO3 (OH)2. Malachite often results from the weathering of copper ores, and is often found with azurite (Cu3(CO3)2(OH)2), goethite, and calcite.\n* **biotite**: Biotite is a common group of phyllosilicate minerals within the mica group with the approximate chemical formula K(Mg,Fe)3AlSi3O10(F,OH)2.","ce526b59":"# Data preparation","bbe0805b":"## Introduction\nGreetings from the Kaggle bot! This is an automatically-generated kernel with starter code demonstrating how to read in the data and begin exploring. If you're inspired to dig deeper, click the blue \"Fork Notebook\" button at the top of this kernel to begin editing.","f0d75065":"There is 0 csv file in the current version of the dataset:\n","accdf874":"## Conclusion\nThis concludes your starter analysis! To go forward from here, click the blue \"Fork Notebook\" button at the top of this kernel. This will create a copy of the code and environment for you to edit. Delete, modify, and add code as you please. Happy Kaggling!","6a8c00ca":"# Splitting the dataset","0ed8469e":"## Exploratory Analysis\nTo begin this exploratory analysis, first import libraries and define functions for plotting the data using `matplotlib`. Depending on the data, not all plots will be made. (Hey, I'm just a simple kerneling bot, not a Kaggle Competitions Grandmaster!)","f712feff":"The next hidden code cells define functions for plotting data. Click on the \"Code\" button in the published kernel to reveal the hidden code.","5c7a22c5":"# Read the data and create label\/image list\n"}}