{"cell_type":{"df5eb284":"code","d009aee9":"code","bb1c39d8":"code","220709ef":"code","b18a424a":"code","49e1f54e":"code","ea5853ba":"code","f3e05bab":"code","13eef8f8":"code","1c0c55f1":"code","b4cd6135":"code","101967c4":"code","614b3bc8":"code","ee1db4af":"code","17478652":"code","17e5b9a4":"code","95a7ea10":"code","8d44641a":"code","812e9395":"code","98693cd9":"code","29b46c8c":"code","f2661c57":"code","1481b1a9":"code","1828e2e8":"code","2e0d15a2":"code","6126afca":"code","6dc7acbe":"code","19ab6e19":"code","fbc63297":"code","721704cf":"code","ea7cc760":"code","e84f146f":"code","fbd2f170":"code","389628a9":"code","2e730d0c":"code","adb08acd":"code","fb36d609":"code","ead9d2c7":"code","e82d0a99":"code","b9e0ac34":"code","e54b627a":"code","f40c62d0":"code","ba6bd87e":"code","76b2cf59":"code","1dee4388":"code","bb0218ba":"code","69147eda":"code","b8ab6053":"code","77e3da6f":"code","20bc2ddd":"code","804d0bd9":"code","442b7ad0":"code","722b5e51":"code","8e7e851c":"code","1fd80b4a":"code","08ca4937":"code","2cc3019a":"code","8623dca1":"code","046a7c1c":"code","976c54b0":"code","2b60172e":"code","3a769bd1":"code","ec4318f1":"code","83589cab":"code","3a7de190":"code","4b69172d":"code","035e6a68":"code","029afe19":"code","c77a2c88":"code","0afdd782":"code","c66f7929":"code","e29d698b":"code","18ce6638":"code","345a0dd6":"code","3505fa18":"code","b99f4f5f":"code","53892273":"code","e326bce8":"code","4f1131a8":"code","1f6d2824":"code","be31f6ec":"code","7fc941c0":"code","9d5dd9f6":"code","7e7cf877":"code","5d28ea72":"code","786c2a2b":"code","2c2f2275":"code","b0c24e83":"code","62fae76e":"code","2d1cde16":"markdown","77f42dc2":"markdown","e917a1cf":"markdown","e039353d":"markdown","cf9d268b":"markdown","e037517e":"markdown","56f40622":"markdown","060abf17":"markdown","6b79a761":"markdown","b3e316ed":"markdown","efbd4c09":"markdown","30d888b1":"markdown","dcf18410":"markdown","af17d1d5":"markdown","68e376bb":"markdown","0182c59d":"markdown","c11f7b81":"markdown","294af1b1":"markdown","c2e4afd3":"markdown","1b56b277":"markdown","e379195a":"markdown","cac3f78c":"markdown","99d768b4":"markdown"},"source":{"df5eb284":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","d009aee9":"\nimport matplotlib as plt\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import GridSearchCV","bb1c39d8":"path='..\/input\/'","220709ef":"train=pd.read_csv(path+'train.csv')\ntest=pd.read_csv(path+'test.csv')","b18a424a":"# save the passenger id for the final submission\npassengerId=test.PassengerId\n\n# merge train and test\ntitanic = train.append(test, ignore_index=True)\n\n## we use the ignore_index as in test data we have the labels columns which is not present in the train data.","49e1f54e":"train_id=len(train)\ntest_id=len(titanic)-len(test)","ea5853ba":"train_id","f3e05bab":"test_id","13eef8f8":"len(titanic)","1c0c55f1":"len(test)","b4cd6135":"titanic.head()","101967c4":"titanic.info()","614b3bc8":"titanic.drop(['PassengerId'],1,inplace=True)","ee1db4af":"titanic.head()","17478652":"titanic['Title']=titanic.Name.apply(lambda name:name.split(',')[1].split('.')[0].strip() )","17e5b9a4":"titanic.head()","95a7ea10":"## title counts\n#print(\"There are {} unique title.\".format(titanic.Title.nunique))\nprint(\"There are {} unique titles.\".format(titanic.Title.nunique()))\nprint(\"\\n\", titanic.Title.unique())","8d44641a":"titanic.head()","812e9395":"# normalize the titles\nnormalized_titles = {\n    \"Capt\":       \"Officer\",\n    \"Col\":        \"Officer\",\n    \"Major\":      \"Officer\",\n    \"Jonkheer\":   \"Royalty\",\n    \"Don\":        \"Royalty\",\n    \"Sir\" :       \"Royalty\",\n    \"Dr\":         \"Officer\",\n    \"Rev\":        \"Officer\",\n    \"the Countess\":\"Royalty\",\n    \"Dona\":       \"Royalty\",\n    \"Mme\":        \"Mrs\",\n    \"Mlle\":       \"Miss\",\n    \"Ms\":         \"Mrs\",\n    \"Mr\" :        \"Mr\",\n    \"Mrs\" :       \"Mrs\",\n    \"Miss\" :      \"Miss\",\n    \"Master\" :    \"Master\",\n    \"Lady\" :      \"Royalty\"\n}\n\ndef convert(val):\n    return normalized_titles[val]","98693cd9":"titanic.head()","29b46c8c":"type(titanic.Title.values[0])","f2661c57":"# view value counts for the normalized titles\nprint(titanic.Title.value_counts())\n","1481b1a9":"titanic.Title = titanic.Title.map(normalized_titles)\n","1828e2e8":"titanic.head()","2e0d15a2":"# view value counts for the normalized titles\nprint(titanic.Title.value_counts())","6126afca":"#groupby sex,Pclass and Title\ngrouped=titanic.groupby(['Sex','Pclass','Title'])\ngrouped.Age.median()","6dc7acbe":"titanic.Embarked.value_counts()","19ab6e19":"grouped1=titanic.groupby(['Sex','Pclass','Title','Embarked'])\ngrouped1.Age.median()","fbc63297":"## applying the grouped median age value\ntitanic.Age=grouped.Age.apply(lambda x:x.fillna(x.median()))\n\ntitanic.info()","721704cf":"titanic.head(10)","ea7cc760":"titanic.Embarked.value_counts()","e84f146f":"most_embarked=titanic.Embarked.value_counts().index[0]","fbd2f170":"most_embarked","389628a9":"titanic.info()","2e730d0c":"titanic.Embarked=titanic.Embarked.fillna(most_embarked)\ntitanic.info()","adb08acd":"titanic.head()","fb36d609":"titanic.info()","ead9d2c7":"##percentage of death vs percentage of survival\ntitanic.Survived.value_counts()","e82d0a99":"titanic.Survived.value_counts(normalize=True)","b9e0ac34":"## lets dig deeper and determine the survival rates based on the gender\ngroupbysex=titanic.groupby(['Sex'])\ngroupbysex.Survived.value_counts(normalize=True)","e54b627a":"##survival rates based on their sex\ngroupbysex.Survived.mean()","f40c62d0":"## group by passenge Pclass and sex\ngroup_class_sex=titanic.groupby(['Pclass','Sex'])\ngroup_class_sex.Survived.mean()","ba6bd87e":"##get stats on all other metrics\ntitanic.describe()","76b2cf59":"## size of the family including the passenger.\ntitanic['FamilySize']=titanic['Parch']+titanic['SibSp']+1","1dee4388":"titanic=titanic.drop(['Parch','SibSp'],1)\ntitanic.head()","bb0218ba":"titanic.info()","69147eda":"#Deck\ntitanic[\"Deck\"] = titanic[\"Cabin\"].str.slice(0,1)\ntitanic[\"Deck\"] = titanic[\"Deck\"].fillna(\"N\")\n\n#Room\ntitanic[\"Room\"] = titanic[\"Cabin\"].str.slice(1,5).str.extract(\"([0-9]+)\", expand=False).astype(\"float\")\ntitanic[\"Room\"] = titanic[\"Room\"].fillna(titanic[\"Room\"].mean())\ntitanic[\"Room\"] = titanic.Room.astype(int)","b8ab6053":"# ## map the first letter of the cabin to the cabin.\n# titanic.Cabin=titanic.Cabin.map(lambda x:x[0])\n\n# ## view the normalized count\n# titanic.Cabin.value_counts(normalize=True)\ntitanic=titanic.drop(['Cabin'],1)","77e3da6f":"titanic.head()","20bc2ddd":"titanic.Deck.value_counts()","804d0bd9":"titanic['Ticket_len']=titanic['Ticket'].apply(lambda x:len(x))\ntitanic.groupby(['Ticket_len']).Survived.mean()","442b7ad0":"titanic['Ticket_lett']=titanic['Ticket'].apply(lambda x:str(x)[0])\ntitanic.groupby(['Ticket_lett']).Survived.mean()","722b5e51":"#Ticket Letter Encoding\nreplacement = {\n    'A': 0,\n    'P': 1,\n    'S': 0,\n    '1': 1,\n    '2': 0,\n    'C': 0,\n    '7': 0,\n    'W': 0,\n    '4': 0,\n    'F': 1,\n    'L': 0,\n    '9': 1,\n    '6': 0,\n    '5': 0,\n    '8': 0,   \n    '3': 0,\n}\n\ntitanic['Ticket_lett']=titanic['Ticket_lett'].map(replacement)\ntitanic.head()","8e7e851c":"titanic=titanic.drop(['Ticket'],1)","1fd80b4a":"titanic.info()","08ca4937":"titanic['Name_len']=titanic['Name'].apply(lambda x:len(x))\ntitanic.groupby(['Name_len']).Survived.mean()","2cc3019a":"titanic=titanic.drop(['Name'],1)","8623dca1":"titanic['Fare'].value_counts()","046a7c1c":"type(titanic['Fare'][0])","976c54b0":"titanic.head()","2b60172e":"titanic.info()","3a769bd1":"titanic['Fare']=titanic['Fare'].fillna(titanic['Fare'].median())\ntitanic.info()","ec4318f1":"titanic.loc[titanic['Fare']<=7.896,'Fare_grouped']=0\ntitanic.loc[(titanic['Fare']>7.896) & (titanic['Fare']<=14.454),'Fare_grouped']=1\ntitanic.loc[(titanic['Fare']>14.454) & (titanic['Fare']<=31.275),'Fare_grouped']=2\ntitanic.loc[(titanic['Fare']>31.275),'Fare_grouped']=3\ntitanic['Fare_grouped']=titanic['Fare_grouped'].astype('int')","83589cab":"titanic.head()","3a7de190":"def handle_non_numeric_data(df):\n\tcolumns=df.columns.values\n\tfor column in columns:\n\t\ttext_digit_vals={}\n\t\tdef convert_to_int(val):\n\t\t\treturn text_digit_vals[val] \n\n\t\tif df[column].dtype!= np.int64 and df[column].dtype!= np.float64:\n\t\t\tcolumn_contents=df[column].values.tolist()\t\t#.values is used to get the values of a function\n\t\t\tunique_elements=set(column_contents)\t#converting to a set\n\t\t\tx=0\n\t\t\t\t\t\n\t\t\tfor unique in unique_elements:\n\t\t\t\tif unique not in text_digit_vals:\n\t\t\t\t\ttext_digit_vals[unique]=x\n\t\t\t\t\tx+=1\n\n\t\t\tdf[column]=list(map(convert_to_int,df[column]))\t\t#we are resetting the df column by mapping the function here to the value in the column\n\n\treturn df","4b69172d":"titanic=handle_non_numeric_data(titanic)","035e6a68":"titanic.head()","029afe19":"titanic=titanic.drop(['Fare'],1)","c77a2c88":"titanic.head()","0afdd782":"\ntrain=titanic[:train_id]\ntest=titanic[test_id:]","c66f7929":"## convert the survived back to int\ntrain.Suvived=train.Survived.astype(int)","e29d698b":"train.head()","18ce6638":"# create X and y for data and target values\nX = train.drop('Survived', axis=1).values\ny = train.Survived.values","345a0dd6":"test.head()","3505fa18":"X_test=test.drop('Survived',1).values","b99f4f5f":"# The parameters that we are going to optimise\nparameters = dict(\n    C = np.logspace(-5, 10, 15),\n    penalty = ['l1', 'l2']\n    #solver =[\u2018newton-cg\u2019, \u2018lbfgs\u2019, \u2018liblinear\u2019, \u2018sag\u2019, \u2018saga\u2019]\n    \n)","53892273":"## instantiate the logistic regression\nclf=LogisticRegression()\n\n# Perform grid search using the parameters and f1_scorer as the scoring method\ngrid_search=GridSearchCV(estimator=clf,param_grid=parameters,cv=6,n_jobs=-1)\n# here cv is used for the cross-validation strategy.\n","e326bce8":"grid_search.fit(X,y)","4f1131a8":"clf1=grid_search.best_estimator_        # get the best estimator(classifier)\nprint(clf1)","1f6d2824":"# Print the tuned parameters and score\nprint(\"Tuned Logistic Regression Parameters: {}\".format(grid_search.best_params_)) \nprint(\"Best score is {}\".format(grid_search.best_score_))","be31f6ec":"## prediction on test set\npred=grid_search.predict(X_test)\nprint(pred)","7fc941c0":"# create param grid object\nforrest_params = dict(\n    max_depth = [n for n in range(7, 14)],\n    min_samples_split = [n for n in range(4, 12)],\n    min_samples_leaf = [n for n in range(2, 6)],\n    n_estimators = [n for n in range(10, 60, 10)],\n)","9d5dd9f6":"forest=RandomForestClassifier()","7e7cf877":"# build and fit model\nforest_cv = GridSearchCV(estimator=forest, param_grid=forrest_params, cv=5)\nforest_cv.fit(X, y)","5d28ea72":"print(\"Best score: {}\".format(forest_cv.best_score_))\nprint(\"Optimal params: {}\".format(forest_cv.best_estimator_))","786c2a2b":"# random forrest prediction on test set\nforrest_pred = forest_cv.predict(X_test)","2c2f2275":"sub=pd.DataFrame({'PassengerId':passengerId,'Survived':forrest_pred})","b0c24e83":"sub.head()","62fae76e":"sub.to_csv('prediction1_titanic.csv',index=False)   \n## we initialise the index as false as we donot need the index","2d1cde16":"The first feature we will look at building is FamilySize. This is important to look at because we want to see if having a large or small family affected someone's chances of survival.\n\nThe relevant features that will help with this are Parch (number of parents\/children aboard) and SibSp (number of siblings\/spouses aboard). We combine the Parch and SibSp features and add 1 as well as we want to count the passenger for each observation.","77f42dc2":"# Creating new features from the data","e917a1cf":"For our next step, we are going to assume that their is a relationship between a person's age and their title since it makes sense that someone that is younger is more likely to be a titled a \"Miss\" vs a \"Mrs\".\n\nWith this in mind, we will group the data by Sex, Pclass, and Title and then view the median age for the grouped classes.","e039353d":"# Tickets\n\nIf the 'Ticket' column is examined randomly, some details will be noticed. Some tickets have a letter in front of them and others consist only of numbers. Furthermore, the tickets have a different length. Let's take a closer look at this. (Based on https:\/\/www.kaggle.com\/zlatankr\/titanic-random-forest-82-78)\n\nFirst we take the first character from the ticket number and in the next step we also determine the ticket length and look at the connection with the variable 'Survive'.","cf9d268b":"The best score using logistic regression was ~82% which wasn't bad. But let's see how we can fare with a Random Forrest Classifier algorithm instead.","e037517e":"For those who have seen the fateful story of titanic we know that the women and children were given priority oven men.Even though it is very astounding that only 19% of the men survived compared the 75% women.","56f40622":"We can conclude from the above result that people with bigger names such as the dignitaries have higher rates of survival.","060abf17":"The social status gives us a pretty good idea about the survival chance.","6b79a761":"Now we create a title feature which extracts the honorifc from the Name feature.Simply put, an honorific is the title or rank of a given person such as \u201cMrs\u201d or \u201cMiss\u201d. The following code takes a value like \u201cBraund, Mr. Owen Harris\u201d from the Name column and extracts \u201cMr\u201d.","b3e316ed":"# For submission on kaggle","efbd4c09":"\nIn theory, the deck can increase the probability of survival, as this includes the distance to the lifeboats. We've already seen this in the 'Class' attribute. The room cannot be assigned directly. In general it can be said that the variable is very experimental and needs further research. For example, it would be possible to predict the missing values using the ticket number, the fare and the surname. For the beginning of the missing cabins we assign an own deck and the mean value (50).","30d888b1":"As expected, those passengers with a title of \"Miss\" tend to be younger than those titled \"Mrs\". Also, it looks like we have some age variability amongst the different passenger classes as well as between the sexes, so this should help us more accurately estimate the missing ages for the observations that do not have an age recorded.","dcf18410":"\nIt appears that 1st class females had an incredible 97% survival rate while 1st class males only still had a 37% chance of survival. Even though you only had a 37% chance of surviving as a 1st class male, you still were almost 3 times more likely to survive than a 3rd class male who had the lowest survival rate amongst sex and class at 13.5%.","af17d1d5":"# Random Forest Model","68e376bb":"We can use the length of the name as the features.","0182c59d":"# Cabin","c11f7b81":"So there is a different distribution between the different ticket letters as well as the length of the ticket number. Therefore, we use both variables in the model.\n\nI'm forming two groups to split the ticket letters. However, you can also test with a different classification.","294af1b1":"Random forest classifier has a better accuracy than the logistic regression as deduced above.","c2e4afd3":"# Logistic Regression","1b56b277":"It looks like we have a few NaNs in the dataset across a few features. We will use the data to try and fill in the gaps. The info() method reveals that the Age, Cabin, Embarked, and Fare all have a few entries missing. Technically the Survived column also has entries missing, but this is actually correct since we merged the train and test together for future feature engineering and the test data doesn't have a Survived column.\n\nAdditionally, from looking at the features, it looks like we can just drop PassengerId from the dataset all together since it isn't really a helpful feature, but rather simply a row identifier.","e379195a":"The first model we will try is a Logistic Regression model which is a binary classifier algorithm. We will be using GridSearchCV to fit our model by specifying a few paramters and return the best possible combination of those parameters.","cac3f78c":" we can also generate info from the Cabin as cabins near the life boats will have higher chance of suvival compared to the others located elsewhere.So we extract the first letter from the cabin and generate features.","99d768b4":"# Modelling"}}