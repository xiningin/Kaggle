{"cell_type":{"cb6d0f37":"code","8ea12d6a":"code","94582970":"code","e3ed1aa3":"code","a7359a25":"code","edb160dc":"code","f0940bb5":"code","500326d3":"code","bbb70d7d":"code","c5e9ea51":"code","05a8f68d":"code","223dbb06":"code","adbb5a83":"code","6e600de2":"code","c6a323e2":"code","5ee013eb":"code","b81a6e63":"code","c940f595":"code","63c64b81":"code","796ebcb4":"markdown","1ca7bbf5":"markdown","b827ad33":"markdown","e6fec8d7":"markdown","a43556ca":"markdown","06c351eb":"markdown","c890a7ea":"markdown","03cc8036":"markdown","a4c11e42":"markdown","dea673f4":"markdown","1b61f83d":"markdown","5c11dabc":"markdown"},"source":{"cb6d0f37":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nprint(os.listdir(\"..\/input\"))\n\nimport matplotlib.pylab as plt\n%matplotlib inline\nfrom matplotlib.pylab import rcParams\nrcParams['figure.figsize'] = 15, 6\n\nfrom sklearn.preprocessing import MinMaxScaler\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import LSTM\nfrom keras.layers import Dropout\n\nimport math\nfrom sklearn.metrics import mean_squared_error","8ea12d6a":"train_data = pd.read_csv(\"..\/input\/train-data\/train.csv\", header=0)","94582970":"train_data.head()","e3ed1aa3":"test_data = pd.read_csv(\"..\/input\/test-data\/test.csv\")","a7359a25":"test_data.head()","edb160dc":"dateparse = lambda dates: pd.datetime.strptime(dates, '%Y-%m-%d')\ndata_train = pd.read_csv('..\/input\/train-data\/train.csv', parse_dates=['Date'], index_col='Date',date_parser=dateparse)","f0940bb5":"ts = data_train['Open'] \nplt.xlabel('Dates')\nplt.ylabel('Open Prices')\nplt.plot(ts)","500326d3":"data_test = pd.read_csv('..\/input\/test-data\/test.csv', parse_dates=['Date'], index_col='Date',date_parser=dateparse)","bbb70d7d":"ts = data_test['Open'] \nplt.xlabel('Dates')\nplt.ylabel('Open Prices')\nplt.plot(ts)","c5e9ea51":"train = train_data.iloc[:, 1:2].values","05a8f68d":"scaler = MinMaxScaler()\ntrain_scaled = scaler.fit_transform(train)","223dbb06":"X_train = []\ny_train = []\nfor i in range(60, train.shape[0]):\n    X_train.append(train_scaled[i-60:i, 0])\n    y_train.append(train_scaled[i, 0])\nX_train, y_train = np.array(X_train), np.array(y_train)","adbb5a83":"X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))","6e600de2":"model = Sequential()\n\n# Adding the first LSTM layer \n# Here return_sequences=True means whether to return the last output in the output sequence, or the full sequence.\n# it basically tells us that there is another(or more) LSTM layer ahead in the network.\nmodel.add(LSTM(units = 50, return_sequences = True, input_shape = (X_train.shape[1], 1)))\n# Dropout regularisation for tackling overfitting\nmodel.add(Dropout(0.20))\n\nmodel.add(LSTM(units = 50, return_sequences = True))\nmodel.add(Dropout(0.25))\n\nmodel.add(LSTM(units = 50, return_sequences = True))\nmodel.add(Dropout(0.25))\n\nmodel.add(LSTM(units = 50))\nmodel.add(Dropout(0.25))\n\n# Adding the output layer\nmodel.add(Dense(units = 1))\n\n# Compiling the RNN\n# RMSprop is a recommended optimizer as per keras documentation\n# check out https:\/\/keras.io\/optimizers\/ for more details\nmodel.compile(optimizer = 'adam', loss = 'mean_squared_error')\n\n# Fitting the RNN to the Training set\nmodel.fit(X_train, y_train, epochs = 100, batch_size = 32)","c6a323e2":"# this will be used later while comparing and visualization\nreal_stock_price = test_data.iloc[:,1:2].values","5ee013eb":"# combine original train and test data vertically\n# as previous Open Prices are not present in test dataset\n# e.g. for predicting Open price for first date in test data, we will need stock open prices on 60 previous dates  \ncombine = pd.concat((train_data['Open'], test_data['Open']), axis = 0)\n# our test inputs also contains stock open Prices of last 60 dates (as described above)\ntest_inputs = combine[len(combine) - len(test_data) - 60:].values\ntest_inputs = test_inputs.reshape(-1,1)\ntest_inputs = scaler.transform(test_inputs)","b81a6e63":"test_data.shape","c940f595":"# same steps as we followed while processing training data\nX_test = []\nfor i in range(60, 480):\n    X_test.append(test_inputs[i-60:i, 0])\nX_test = np.array(X_test)\nX_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))\npredicted_stock_price = model.predict(X_test)\n# inverse_transform because prediction is done on scaled inputs\npredicted_stock_price = scaler.inverse_transform(predicted_stock_price)","63c64b81":"plt.plot(real_stock_price, color = 'red', label = 'Real APPL Stock Price')\nplt.plot(predicted_stock_price, color = 'blue', label = 'Predicted APPL Stock Price')\nplt.title('APPL Stock Price Prediction')\nplt.xlabel('Time')\nplt.ylabel('APPL Stock Price')\nplt.legend()\nplt.show()","796ebcb4":"## Now making the predictions and visualising the results","1ca7bbf5":"## Visualizing test data Open Price trends with respect to date that will be predicted by our RNN model","b827ad33":"### Hello guys, today we will see how to predict the open stock price of APPL Stock. Wait a sec. What !! \"predict the open stock price\". Is that even possible?            Ofcourse not. Its impossible to predict open stock price otherwise we would all become billionaire.                                                                                                                                                                             \n### In this tutorial we will try to predict the upward and downward trends that exists in the APPL Stock Price, i.e. we are more interested in the directions taken by our predictions, rather than the closeness of their values to the real stock price.                                                                                                                                                                                               \n\n###                                                                                                              We will not use time series forecasting, rather use Long short-term memory (LSTM) for our prediction. It performs well better than than the ARIMA model. We will design a stacked LSTM having high dimensionality.                                                                                                                         \n\n###    We will train our LSTM model using 6 years of APPL stock price , starting from the last financial date of 2009 to last financial day of 2016. Based on the correlations captured by our model, we will try to predict the open stock price from 1st financial day of 2017 to last financial day of August 2018. Again, we won't predict the actual price but try to predict the upward and downward stock price trends.\n### So, without wasting more time, let's get started.","e6fec8d7":"### Hurray!! We made it. You can try with more than one indicators, not just one (in our case its 'Open'). But remember one thing these indicators \/factors should be something that can influence APPL open stock price.","a43556ca":"## Importing the libraries.","06c351eb":"## Now we will creating a data structure with 60 timesteps and 1 output, i.e.Open Stock Price ","c890a7ea":"## Building the RNN","03cc8036":"## Feature Scaling","a4c11e42":"## Visualising the results","dea673f4":"## Reshaping\n*  ### Here second argument is (batch_size, time_step ,input_dim)\n* ### batch_size is total number of stock price from 2009-12-31 to 2016, i.e. given by X_train.shape[0]\n* ### time_step is total number of previous stock price we want to consider while predicting present stock price, i.e given by X_train.shape[1]\n* ### third argument is input_dim-in our case it is 1, i.e.Open price, but it can be more than one. It basically includes all those factors\/indicators that can affect present stock price ","1b61f83d":"## Visualizing train data","5c11dabc":"## Loading APPL Stock Price train and test dataset"}}