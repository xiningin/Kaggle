{"cell_type":{"8752935f":"code","18400fa2":"code","0f3cfa02":"code","ac0932ad":"code","3449b4de":"code","1069abf4":"code","ae1b4fdb":"code","4ef26851":"code","6caf8af7":"code","2ac3b586":"code","75ab4281":"code","29fadfa4":"code","35fd5ae5":"code","d2b52e74":"code","818a27a7":"code","54032b4f":"code","8e340fdb":"code","41e201ba":"code","804dd37c":"code","057a8780":"code","54398874":"code","9a68f9a1":"code","0b9de36d":"code","4ec0c08f":"code","3a9e69f1":"code","b184c823":"code","b3c0669e":"code","07de38b0":"code","148443b0":"code","f0c24668":"code","b9a97fd3":"code","0fff7c87":"code","6ead3872":"code","af19278a":"code","bdffad10":"code","4e7965c6":"code","e1cb1ec6":"code","5bf46039":"code","0af74547":"code","38a53f5d":"code","0eb02020":"code","eade51b8":"code","147e7dfb":"code","ea43416a":"code","274a68e4":"code","9a9df070":"code","81a9beed":"code","4f50cb28":"code","66a09feb":"code","cc586873":"code","e7364a84":"code","f18387a9":"code","48726257":"code","f749e1cc":"code","a46246f8":"code","8a886618":"code","380d20e9":"code","730ab68d":"markdown","e2f510bd":"markdown","bc7d04e3":"markdown","2f562dbb":"markdown","7619e1ec":"markdown","d2034db6":"markdown","5e0fc90c":"markdown","69c02617":"markdown","71371d92":"markdown","78bf18d0":"markdown","c270e094":"markdown","0ab1b904":"markdown","9e723dc2":"markdown","5115d7bf":"markdown","79b78bff":"markdown","88523390":"markdown","11835988":"markdown","ea8b0f9e":"markdown","1492f1b3":"markdown","12a965e1":"markdown","fbfb97bc":"markdown","6f63e3aa":"markdown","7519b1b1":"markdown","b26a33ff":"markdown","8eacf606":"markdown","842a70d6":"markdown","5b749065":"markdown","94f26d59":"markdown","94b8a58d":"markdown","5b16d981":"markdown","b0f30818":"markdown","4739aabd":"markdown","eb3446d6":"markdown","53a15d3b":"markdown","ce3fc422":"markdown","66ddc37b":"markdown","41d360ff":"markdown","f7f01a2c":"markdown","fc8e2422":"markdown"},"source":{"8752935f":"# pandas and numpy for data manipulation\nimport pandas as pd\nimport numpy as np\n\n# matplotlib and seaborn for plotting\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Suppress warnings from pandas\nimport warnings\nwarnings.filterwarnings('ignore')\n\nplt.style.use('fivethirtyeight')","18400fa2":"# Read in bureau\nbureau = pd.read_csv('..\/input\/bureau.csv')\nbureau.head()","0f3cfa02":"# groupby the client id (SK_ID_CURR), count the # of previous loans, and rename the col.\n# every client has a # of prev. loans and we will count it and add them on main app DF\nprevious_loans_count = bureau.groupby('SK_ID_CURR', as_index=False)['SK_ID_BUREAU'].count().rename(columns = {'SK_ID_BUREAU' : 'previous_loan_counts'})\nprevious_loans_count.head()","ac0932ad":"# join to the main df \ntrain = pd.read_csv('..\/input\/application_train.csv')\ntrain = train.merge(previous_loans_count, on = 'SK_ID_CURR', how='left')\n\n# fill the missing values with 0\ntrain['previous_loan_counts'] = train['previous_loan_counts'].fillna(0)\ntrain.head()","3449b4de":"#  Plots the disribution of a variable colored by value of the target\ndef kde_target(var_name, df):\n    \n    # calc the correlation coeff. between the new var and the target\n    corr = df['TARGET'].corr(df[var_name])\n    \n    # calc the median for repaid vs not repaid\n    avg_repaid = df.ix[df['TARGET'] == 0, var_name].median()\n    avg_not_repaid = df.ix[df['TARGET'] == 1, var_name].median()\n    \n    plt.figure(figsize = (12, 6))\n    \n    # plot the dist for target == 0 and 1\n    sns.kdeplot(df.ix[df['TARGET'] == 0 ,var_name], label = 'TARGET == 0')\n    sns.kdeplot(df.ix[df['TARGET'] == 1 ,var_name], label = 'TARGET == 1')\n    \n    # label the plot\n    plt.xlabel(var_name); plt.ylabel('Density'); plt.title('%s Distribution' % var_name)\n    plt.legend();\n    \n    # print corr\n    print('The correlation between %s and the TARGET is %0.4f' % (var_name, corr))\n    # Print out average values\n    print('Median value for loan that was not repaid = %0.4f' % avg_not_repaid)\n    print('Median value for loan that was repaid =     %0.4f' % avg_repaid)","1069abf4":"kde_target('EXT_SOURCE_3', train)","ae1b4fdb":"kde_target('previous_loan_counts', train)","4ef26851":"# Group by the client id, calculate aggregation statistics\nbureau_agg = bureau.drop(columns=['SK_ID_BUREAU']).groupby('SK_ID_CURR', as_index=False).agg(['count', 'mean', 'max','min', 'sum']).reset_index()\nbureau_agg.head()","6caf8af7":"# list col names\ncolumns = ['SK_ID_CURR']\n\n# iterate through the variable names\nfor var in bureau_agg.columns.levels[0]:\n    # skip the id name\n    if var != 'SK_ID_CURR':\n        \n        # iter through the stat names\n        for stat in bureau_agg.columns.levels[1][:-1]:\n            columns.append('bureau_%s_%s' %(var, stat))","2ac3b586":"# Assign the list of columns names as the dataframe column names\nbureau_agg.columns = columns\nbureau_agg.head()","75ab4281":"# Merge with the training data\ntrain = train.merge(bureau_agg, on = 'SK_ID_CURR', how = 'left')\ntrain.head()","29fadfa4":"# List of new correlations\nnew_corrs = []\n\n# Iterate through the columns \nfor col in columns:\n    # Calculate correlation with the target\n    corr = train['TARGET'].corr(train[col])\n    \n    # Append the list as a tuple\n\n    new_corrs.append((col, corr))","35fd5ae5":"#  Make sure to reverse to put the largest values at the front of list\nnew_corrs = sorted(new_corrs, key = lambda x:abs(x[1]), reverse = True)\nnew_corrs[:15]","d2b52e74":"kde_target('bureau_DAYS_CREDIT_mean', train)","818a27a7":"def agg_numeric(df, group_var, df_name):\n    \"\"\" Aggregation the numeric values in a dataframe. thi can be\n    used to create features for each instance of the grouping variable.\n    \n    Parameters\n    ---------\n        df (dataframe):\n            the dataframe to calculate the statistics on\n        group_var (string):\n            the variable by which to griup df\n        df_name (string):\n            the variable used to rename the col\n            \n        return\n        ----------\n            agg (dataframe):\n                a dataframe with the statistics aggregated for \n                all numeric columns. Each instance of the grouping variable will have \n                the statistics (mean, min, max, sum; currently supported) calculated. \n                The columns are also renamed to keep track of features created.\n    \"\"\"\n    \n    # remove id variable other than grouping variable\n    for col in df:\n        if col != group_var and 'SK_ID' in col:\n            df = df.drop(columns = col)\n            \n    group_ids = df[group_var]\n    numeric_df = df.select_dtypes('number')\n    numeric_df[group_var] = group_ids\n    \n    # Group by the specified variable and calculate the statistics\n    agg = numeric_df.groupby(group_var).agg(['count', 'mean', 'max', 'min', 'sum']).reset_index()\n    \n    # Need to create new column names\n    columns = [group_var]\n    \n    # iter through var names\n    for var in agg.columns.levels[0]:\n        # Skip the grouping variable\n        if var != group_var:\n            # Iterate through the stat names\n            for stat in agg.columns.levels[1][:-1]:\n                # Make a new column name for the variable and stat\n                columns.append('%s_%s_%s' % (df_name, var, stat))\n\n    agg.columns = columns\n    return agg","54032b4f":"bureau_agg_new = agg_numeric(bureau.drop(columns = ['SK_ID_BUREAU']), group_var = 'SK_ID_CURR', df_name = 'bureau')\nbureau_agg_new.head()","8e340fdb":"bureau_agg.head()","41e201ba":"# Function to calculate correlations with the target for a dataframe\ndef target_corrs(df):\n    \n    # list of corr\n    corrs = []\n    \n    # Iterate through the columns \n    for col in df.columns:\n        print(col)\n        # skip the target col\n        if col != 'TARGET' :\n            corr = df['TARGET'].corr(df[col])\n            \n            # Append the list as a tuple\n            corrs.append((col, corr))\n            \n    # Sort by absolute magnitude of correlations\n    corrs = sorted(corrs, key = lambda x: abs(x[1]), reverse = True)\n    \n    return corrs","804dd37c":"categorical = pd.get_dummies(bureau.select_dtypes('object'))\ncategorical['SK_ID_CURR'] = bureau['SK_ID_CURR']\ncategorical.head()","057a8780":"categorical_grouped = categorical.groupby('SK_ID_CURR').agg(['sum', 'mean'])\ncategorical_grouped.head()","54398874":"categorical_grouped.columns.levels[0][:10]","9a68f9a1":"categorical_grouped.columns.levels[1]","0b9de36d":"group_var = 'SK_ID_CURR'\n\n# Need to create new column names\ncolumns = []\n\n# Iterate through the variables names\nfor var in categorical_grouped.columns.levels[0]:\n    # Skip the grouping variable\n    if var != group_var:\n        # Iterate through the stat names\n        for stat in ['count', 'count_norm']:\n            # Make a new column name for the variable and stat\n            columns.append('%s_%s' % (var, stat))\n\n#  Rename the columns\ncategorical_grouped.columns = columns\n\ncategorical_grouped.head()","4ec0c08f":"train = train.merge(categorical_grouped, left_on = 'SK_ID_CURR', right_index = True, how = 'left')\ntrain.head()","3a9e69f1":"train.shape","b184c823":"train.iloc[:10, 123:]","b3c0669e":"def count_categorical(df, group_var, df_name):\n    \"\"\"Computes counts and normalized counts for each observation\n    of `group_var` of each unique category in every categorical variable\n    \n    Parameters\n    --------\n    df : dataframe \n        The dataframe to calculate the value counts for.\n        \n    group_var : string\n        The variable by which to group the dataframe. For each unique\n        value of this variable, the final dataframe will have one row\n        \n    df_name : string\n        Variable added to the front of column names to keep track of columns\n\n    \n    Return\n    --------\n    categorical : dataframe\n        A dataframe with counts and normalized counts of each unique category in every categorical variable\n        with one row for every unique value of the `group_var`.\n        \n    \"\"\"\n    \n    # Select the categorical columns\n    categorical = pd.get_dummies(df.select_dtypes('object'))\n\n    # Make sure to put the identifying id on the column\n    categorical[group_var] = df[group_var]\n\n    # Groupby the group var and calculate the sum and mean\n    categorical = categorical.groupby(group_var).agg(['sum', 'mean'])\n    \n    column_names = []\n    \n    # Iterate through the columns in level 0\n    for var in categorical.columns.levels[0]:\n        # Iterate through the stats in level 1\n        for stat in ['count', 'count_norm']:\n            # Make a new column name\n            column_names.append('%s_%s_%s' % (df_name, var, stat))\n    \n    categorical.columns = column_names\n    \n    return categorical","07de38b0":"bureau_counts = count_categorical(bureau, group_var = 'SK_ID_CURR', df_name = 'bureau')\nbureau_counts.head()","148443b0":"bureau_counts.index","f0c24668":"# Read in bureau balance\nbureau_balance = pd.read_csv('..\/input\/bureau_balance.csv')\nbureau_balance.head()","b9a97fd3":"# Counts of each type of status for each previous loan\nbureau_balance_counts = count_categorical(bureau_balance, group_var='SK_ID_BUREAU', df_name='bureau_balance')\nbureau_balance_counts.head()","0fff7c87":"# Calculate value count statistics for each `SK_ID_CURR` \nbureau_balance_agg = agg_numeric(bureau_balance, group_var = 'SK_ID_BUREAU', df_name = 'bureau_balance')\nbureau_balance_agg.head()","6ead3872":"# Dataframe grouped by the loan\nbureau_by_loan = bureau_balance_agg.merge(bureau_balance_counts, right_index = True, left_on = 'SK_ID_BUREAU', how = 'outer')\n\n# Merge to include the SK_ID_CURR\nbureau_by_loan = bureau_by_loan.merge(bureau[['SK_ID_BUREAU', 'SK_ID_CURR']], on = 'SK_ID_BUREAU', how = 'left')\n\nbureau_by_loan.head()","af19278a":"bureau_balance_by_client = agg_numeric(bureau_by_loan.drop(columns = ['SK_ID_BUREAU']), group_var = 'SK_ID_CURR', df_name = 'client')\nbureau_balance_by_client.head()","bdffad10":"# Free up memory by deleting old objects\nimport gc\ngc.enable()\ndel  bureau_agg_new, bureau_balance_agg, bureau_balance_counts, bureau_by_loan, bureau_balance_by_client, bureau_counts\ngc.collect()","4e7965c6":"# Read in new copies of all the dataframes\ntrain = pd.read_csv('..\/input\/application_train.csv')\nbureau = pd.read_csv('..\/input\/bureau.csv')\nbureau_balance = pd.read_csv('..\/input\/bureau_balance.csv')","e1cb1ec6":"bureau_counts = count_categorical(bureau, group_var = 'SK_ID_CURR', df_name = 'bureau')\nbureau_counts.head()","5bf46039":"# bureau_count","0af74547":"bureau_agg = agg_numeric(bureau.drop(columns = ['SK_ID_BUREAU']), group_var = 'SK_ID_CURR', df_name = 'bureau')\nbureau_agg.head()","38a53f5d":"bureau_balance_counts = count_categorical(bureau_balance, group_var = 'SK_ID_BUREAU', df_name = 'bureau_balance')\nbureau_balance_counts.head()","0eb02020":"bureau_balance_agg = agg_numeric(bureau_balance, group_var = 'SK_ID_BUREAU', df_name = 'bureau_balance')\nbureau_balance_agg.head()","eade51b8":"# Dataframe grouped by the loan\nbureau_by_loan = bureau_balance_agg.merge(bureau_balance_counts, right_index = True, left_on = 'SK_ID_BUREAU', how = 'outer')\n\n# Merge to include the SK_ID_CURR\nbureau_by_loan = bureau[['SK_ID_BUREAU', 'SK_ID_CURR']].merge(bureau_by_loan, on = 'SK_ID_BUREAU', how = 'left')\n\n# Aggregate the stats for each client\nbureau_balance_by_client = agg_numeric(bureau_by_loan.drop(columns = ['SK_ID_BUREAU']), group_var = 'SK_ID_CURR', df_name = 'client')","147e7dfb":"original_features = list(train.columns)\nprint('original # of Features: ', len(original_features))","ea43416a":"# Merge with the value counts of bureau\ntrain = train.merge(bureau_counts, on = 'SK_ID_CURR' ,how = 'left')\n\n# Merge with the stats of bureau\ntrain = train.merge(bureau_agg, on = 'SK_ID_CURR', how = 'left')\n\n# Merge with the monthly information grouped by client\ntrain = train.merge(bureau_balance_by_client, on = 'SK_ID_CURR', how = 'left')","274a68e4":"new_features = list(train.columns)\nprint('Number of features using previous loans from other institutions data: ', len(new_features))","9a9df070":"# Function to calculate missing values by column# Funct \ndef missing_values_table(df):\n        # Total missing values\n        mis_val = df.isnull().sum()\n        \n        # Percentage of missing values\n        mis_val_percent = 100 * df.isnull().sum() \/ len(df)\n        \n        # Make a table with the results\n        mis_val_table = pd.concat([mis_val, mis_val_percent], axis=1)\n        \n        # Rename the columns\n        mis_val_table_ren_columns = mis_val_table.rename(\n        columns = {0 : 'Missing Values', 1 : '% of Total Values'})\n        \n        # Sort the table by percentage of missing descending\n        mis_val_table_ren_columns = mis_val_table_ren_columns[\n            mis_val_table_ren_columns.iloc[:,1] != 0].sort_values(\n        '% of Total Values', ascending=False).round(1)\n        \n        # Print some summary information\n        print (\"Your selected dataframe has \" + str(df.shape[1]) + \" columns.\\n\"      \n            \"There are \" + str(mis_val_table_ren_columns.shape[0]) +\n              \" columns that have missing values.\")\n        \n        # Return the dataframe with missing information\n        return mis_val_table_ren_columns","81a9beed":"missing_train = missing_values_table(train)\nmissing_train.head(10)","4f50cb28":"missing_train_vars = list(missing_train.index[missing_train['% of Total Values'] > 90])\nlen(missing_train_vars)","66a09feb":"# Read in the test dataframe\ntest = pd.read_csv('..\/input\/application_test.csv')\n\n# Merge with the value counts of bureau\ntest = test.merge(bureau_counts, on = 'SK_ID_CURR', how = 'left')\n\n# Merge with the stats of bureau\ntest = test.merge(bureau_agg, on = 'SK_ID_CURR', how = 'left')\n\n# Merge with the value counts of bureau balance\ntest = test.merge(bureau_balance_by_client, on = 'SK_ID_CURR', how = 'left')","cc586873":"print('Shape of Testing Data: ', test.shape)","e7364a84":"train_labels = train['TARGET']\n\n# Align the dataframes, this will remove the 'TARGET' column\ntrain, test = train.align(test, join = 'inner', axis = 1)\n\ntrain['TARGET'] = train_labels","f18387a9":"print('Training Data Shape: ', train.shape)\nprint('Testing Data Shape: ', test.shape)","48726257":"missing_test = missing_values_table(test)\nmissing_test.head(10)","f749e1cc":"missing_test_vars = list(missing_test.index[missing_test['% of Total Values'] > 90])\nlen(missing_test_vars)","a46246f8":"missing_columns = list(set(missing_test_vars + missing_train_vars))\nprint('There are %d columns with more than 65%% missing in either the training or testing data.' % len(missing_columns))","8a886618":"# Drop the missing columns\ntrain = train.drop(columns = missing_columns)\ntest = test.drop(columns = missing_columns)","380d20e9":"train.to_csv('train_bureau_raw.csv', index = False)\ntest.to_csv('test_bureau_raw.csv', index = False)","730ab68d":"# Putting the Functions Together","e2f510bd":"The `sum` columns represent the count of that category for the associated client and the `mean` represents the normalized count. One-hot encoding makes the process of calculating these figures very easy!","bc7d04e3":"we will remove any columns in either the training or the testing data that have greater than 90% missing values.","2f562dbb":"### Correlation Function\n\nBefore we move on, we can also make the code to calculate correlations with the target into a function.","7619e1ec":"### Manual Feature Engineering","d2034db6":"### Aggregated stats of Bureau Balance dataframe by loan","5e0fc90c":"From this it's difficult to tell if this variable will be important. The correlation coefficient is extremely weak and there is almost no noticeable difference in the distributions. \n\nLet's move on to make a few more variables from the bureau dataframe. We will take the mean, min, and max of every numeric column in the bureau dataframe.","69c02617":"### Aggregating Numeric Columns","71371d92":"To make sure the function worked as intended, we should compare with the aggregated dataframe we constructed by hand. ","78bf18d0":"The definition of this column is: \"How many days before current application did client apply for Credit Bureau credit\". My interpretation is this is the number of days that the previous loan was applied for before the application for a loan at Home Credit. Therefore, a larger negative number indicates the loan was further before the current loan application. We see an extremely weak positive relationship between the average of this variable and the target meaning that clients who applied for loans further in the past potentially are more likely to repay loans at Home Credit. With a correlation this weak though, it is just as likely to be noise as a signal. \n\n#### The Multiple Comparisons Problem\n\nWhen we have lots of variables, we expect some of them to be correlated just by pure chance, a [problem known as multiple comparisons](https:\/\/towardsdatascience.com\/the-multiple-comparisons-problem-e5573e8b9578). We can make hundreds of features, and some will turn out to be corelated with the target simply because of random noise in the data. Then, when our model trains, it may overfit to these variables because it thinks they have a relationship with the target in the training set, but this does not necessarily generalize to the test set. There are many considerations that we have to take into account when making features! ","c270e094":"#### we can test this function using the EXT_SOURCE_3","0ab1b904":"### Function to Handle Categorical Variables\n","9e723dc2":"sort the correlations by the magnitude (absolute value)","5115d7bf":"None of the new variables have a significant correlation with the TARGET. We can look at the KDE plot of the highest correlated variable, bureau_DAYS_CREDIT_mean, with the target in in terms of absolute magnitude correlation. ","79b78bff":"We will now turn to the bureau balance dataframe. This dataframe has monthly information about each client's previous loan(s) with other financial institutions. Instead of grouping this dataframe by the `SK_ID_CURR` which is the client id, we will first group the dataframe by the `SK_ID_BUREAU` which is the id of the previous loan. This will give us one row of the dataframe for each loan. Then, we can group by the `SK_ID_CURR` and calculate the aggregations across the loans of each client. The final result will be a dataframe with one row for each client, with stats calculated for their loans.","88523390":"### Correlations of Aggregated Values with Target\n\nWe can calculate the correlation of all new values with the target. Again, we can use these as an approximation of the variables which may be important for modeling. ","11835988":"We need to create new names for each of these columns. The following code makes new names by appending the stat to the name. Here we have to deal with the fact that the dataframe has a multi-level index. I find these confusing and hard to work with, so I try to reduce to a single level index as quickly as possible.","ea8b0f9e":"We can merge this dataframe into the training data.","1492f1b3":"### Applying Operations to another dataframe","12a965e1":"First, we can calculate the value counts of each status for each loan. Fortunately, we already have a function that does this for us! ","fbfb97bc":"First we one-hot encode a dataframe with only the categorical columns (`dtype == 'object'`).","6f63e3aa":"### Value counts of Bureau Balance dataframe by loan","7519b1b1":"Now we simply merge with the training data","b26a33ff":"### Feature Selection","8eacf606":"#### Counts of a client's previous loans","842a70d6":"## Calculate Information for Testing Data","5b749065":"## Function for Numeric Aggregations\nLet's encapsulate all of the previous work into a function","94f26d59":"The dataframes now have the same columns (with the exception of the `TARGET` column in the training data). This means we can use them in a machine learning model which needs to see the same columns in both the training and testing dataframes.\n\nLet's now look at the percentage of missing values in the testing data so we can figure out the columns that should be dropped.","94b8a58d":"### Insert Computed Features into Training Data","5b16d981":"Feature selection is the process of removing variables to help our model to learn and generalize better to the testing set. The objective is to remove useless\/redundant variables while preserving those that are useful. There are a number of tools we can use for this process, but in this notebook we will stick to removing columns with a high percentage of missing values and variables that have a high correlation with one another. Later we can look at using the feature importances returned from models such as the Gradient Boosting Machine or Random Forest to perform feature selection.\n","b0f30818":"### Counts of Bureau Dataframe","4739aabd":"##### Kernel Density Estimate Plots","eb3446d6":"### Aggregated Stats of Bureau Balance by Client","53a15d3b":"## Missing Values\n\nAn important consideration is the missing values in the dataframe. Columns with too many missing values might have to be dropped. ","ce3fc422":"#### Assessing Usefulness of New Variable with r value","66ddc37b":"The definition of this column is: \"How many days before current application did client apply for Credit Bureau credit\". My interpretation is this is the number of days that the previous loan was applied for before the application for a loan at Home Credit. Therefore, a larger negative number indicates the loan was further before the current loan application. We see an extremely weak positive relationship between the average of this variable and the target meaning that clients who applied for loans further in the past potentially are more likely to repay loans at Home Credit. With a correlation this weak though, it is just as likely to be noise as a signal. ","41d360ff":"### Aggregated Stats of Bureau Dataframe","f7f01a2c":"Now for the new variable we just made, the number of previous loans at other institutions.","fc8e2422":"We need to align the testing and training dataframes, which means matching up the columns so they have the exact same columns. This shouldn't be an issue here, but when we one-hot encode variables, we need to align the dataframes to make sure they have the same columns."}}