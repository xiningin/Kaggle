{"cell_type":{"4c42dfbc":"code","4d34fd6b":"code","42914c9d":"code","3117ae5e":"code","c5fb7c85":"code","cd502c15":"code","0316b33f":"code","332584a1":"code","c55b638a":"code","3c3d1a78":"code","8568b66f":"code","56eb9978":"code","a65521b8":"code","7408d7ff":"code","a5649fdb":"code","fe5c4ae3":"code","ccb4d96b":"code","0245d582":"code","32c8392a":"code","54f06a81":"markdown","98a0cd89":"markdown","ce60ae79":"markdown","a22754af":"markdown","1fbc6cdc":"markdown"},"source":{"4c42dfbc":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","4d34fd6b":"import numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom keras.utils.np_utils import to_categorical\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D, AvgPool2D, BatchNormalization, Reshape\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.callbacks import LearningRateScheduler\nimport matplotlib.pyplot as plt\n","42914c9d":"train = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')","3117ae5e":"Y_train = train[\"label\"]\nX_train = train.drop(labels=['label'], axis = 1)\nX_train = X_train\/255\nX_test = test\/255\nX_train = X_train.values.reshape(-1,28,28,1)\nX_test = X_test.values.reshape(-1,28,28,1)\nY_train = to_categorical(Y_train, num_classes=10)\n# GLOBAL VARIABLES\nannealer = LearningRateScheduler(lambda x: 1e-3 * 0.95 ** x, verbose=0)\nstyles=[':','-.','--','-',':','-.','--','-',':','-.','--','-']\n","c5fb7c85":"nets = 3\nmodel = [0]*nets\n\nfor j in range(3):\n    model[j] = Sequential()\n    model[j].add(Conv2D(24, kernel_size=5, padding='same', activation='relu', input_shape=(28,28,1)))\n    model[j].add(MaxPool2D())\n    if j>0:\n        model[j].add(Conv2D(48, kernel_size=5, padding='same', activation='relu'))\n        model[j].add(MaxPool2D())\n    if j>1:\n        model[j].add(Conv2D(64, kernel_size=5, padding='same', activation='relu'))\n        model[j].add(MaxPool2D(padding='same'))\n    model[j].add(Flatten())\n    model[j].add(Dense(256, activation='relu'))\n    model[j].add(Dropout(0.2))\n    model[j].add(Dense(10, activation='softmax'))\n    model[j].compile(optimizer='adam', loss = 'categorical_crossentropy', metrics = ['accuracy'])\n    ","cd502c15":"# CREATE VALIDATION SET\nX_train2, X_val2, Y_train2, Y_val2 = train_test_split(X_train, Y_train, test_size = 0.333)\n# TRAIN NETWORKS\nhistory = [0] * nets\nnames = [\"(C-P)x1\",\"(C-P)x2\",\"(C-P)x3\"]\nepochs = 50\nfor j in range(nets):\n    history[j] = model[j].fit(X_train2,Y_train2, batch_size=128, epochs = epochs, \n        validation_data = (X_val2,Y_val2), callbacks=[annealer], verbose=0)\n    print(\"CNN {0}: Epochs={1:d}, Train accuracy={2:.5f}, Validation accuracy={3:.5f}\".format(\n        names[j],epochs,max(history[j].history['acc']),max(history[j].history['val_acc']) ))","0316b33f":"plt.figure(figsize=(15,5))\nfor i in range(nets):\n    plt.plot(history[i].history['val_acc'], linestyle=styles[i])\nplt.title('model accuracy')\nplt.xlabel('epoch')\nplt.ylabel('accuracy')\nplt.legend(names, loc='upper left')\naxes = plt.gca()\naxes.set_ylim([0.98,1])\nplt.show()","332584a1":"nets = 6\nmodel = [0]*nets\nfor j in range(6):\n    model[j] = Sequential()\n    model[j].add(Conv2D(j*8+8, kernel_size=5, activation='relu', input_shape=(28,28,1)))\n    model[j].add(MaxPool2D())\n    model[j].add(Conv2D(j*16+16, kernel_size=5, activation='relu'))\n    model[j].add(MaxPool2D())\n    model[j].add(Flatten())\n    model[j].add(Dropout(0.2))\n    model[j].add(Dense(256, activation='relu'))\n    model[j].add(Dense(10, activation='softmax'))\n    model[j].compile(optimizer='adam', loss = 'categorical_crossentropy', metrics=['accuracy'])","c55b638a":"# CREATE VALIDATION SET\nX_train2, X_val2, Y_train2, Y_val2 = train_test_split(X_train, Y_train, test_size = 0.333)\n# TRAIN NETWORKS\nhistory = [0] * nets\nnames = [\"8 maps\",\"16 maps\",\"24 maps\",\"32 maps\",\"48 maps\",\"64 maps\"]\nepochs = 50\nfor j in range(nets):\n    history[j] = model[j].fit(X_train2,Y_train2, batch_size=128, epochs = epochs, \n        validation_data = (X_val2,Y_val2), callbacks=[annealer], verbose=0)\n    print(\"CNN {0}: Epochs={1:d}, Train accuracy={2:.5f}, Validation accuracy={3:.5f}\".format(\n        names[j],epochs,max(history[j].history['acc']),max(history[j].history['val_acc']) ))","3c3d1a78":"# PLOT ACCURACIES\nplt.figure(figsize=(15,5))\nfor i in range(nets):\n    plt.plot(history[i].history['val_acc'],linestyle=styles[i])\nplt.title('model accuracy')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(names, loc='upper left')\naxes = plt.gca()\naxes.set_ylim([0.98,1])\nplt.show()","8568b66f":"nets = 5\nmodel = [0] *nets\n\nj=0\nmodel[j] = Sequential()\nmodel[j].add(Conv2D(32,kernel_size=5,activation='relu',input_shape=(28,28,1)))\nmodel[j].add(MaxPool2D())\nmodel[j].add(Dropout(0.2))\nmodel[j].add(Conv2D(64,kernel_size=5,activation='relu'))\nmodel[j].add(MaxPool2D())\nmodel[j].add(Dropout(0.2))\nmodel[j].add(Flatten())\nmodel[j].add(Dense(128, activation='relu'))\nmodel[j].add(Dropout(0.5))\nmodel[j].add(Dense(10, activation='softmax'))\nmodel[j].compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])\n\nj=1\nmodel[j] = Sequential()\nmodel[j].add(Conv2D(32,kernel_size=3,activation='relu',input_shape=(28,28,1)))\nmodel[j].add(Conv2D(32,kernel_size=3,activation='relu'))\nmodel[j].add(MaxPool2D())\nmodel[j].add(Dropout(0.2))\nmodel[j].add(Conv2D(64,kernel_size=3,activation='relu'))\nmodel[j].add(Conv2D(64,kernel_size=3,activation='relu'))\nmodel[j].add(MaxPool2D())\nmodel[j].add(Dropout(0.2))\nmodel[j].add(Flatten())\nmodel[j].add(Dense(128, activation='relu'))\nmodel[j].add(Dropout(0.5))\nmodel[j].add(Dense(10, activation='softmax'))\nmodel[j].compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])\n\nj=2\nmodel[j] = Sequential()\nmodel[j].add(Conv2D(32,kernel_size=5,activation='relu',input_shape=(28,28,1)))\nmodel[j].add(Conv2D(32,kernel_size=5,strides=2,padding='same',activation='relu'))\nmodel[j].add(Dropout(0.4))\nmodel[j].add(Conv2D(64,kernel_size=5,activation='relu'))\nmodel[j].add(Conv2D(64,kernel_size=5,strides=2,padding='same',activation='relu'))\nmodel[j].add(Dropout(0.4))\nmodel[j].add(Flatten())\nmodel[j].add(Dense(128, activation='relu'))\nmodel[j].add(Dropout(0.4))\nmodel[j].add(Dense(10, activation='softmax'))\nmodel[j].compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])\n\nj=3\nmodel[j] = Sequential()\nmodel[j].add(Conv2D(32,kernel_size=3,activation='relu',input_shape=(28,28,1)))\nmodel[j].add(BatchNormalization())\nmodel[j].add(Conv2D(32,kernel_size=3,activation='relu'))\nmodel[j].add(BatchNormalization())\nmodel[j].add(Conv2D(32,kernel_size=5,strides=2,padding='same',activation='relu'))\nmodel[j].add(BatchNormalization())\nmodel[j].add(Dropout(0.4))\nmodel[j].add(Conv2D(64,kernel_size=3,activation='relu'))\nmodel[j].add(BatchNormalization())\nmodel[j].add(Conv2D(64,kernel_size=3,activation='relu'))\nmodel[j].add(BatchNormalization())\nmodel[j].add(Conv2D(64,kernel_size=5,strides=2,padding='same',activation='relu'))\nmodel[j].add(BatchNormalization())\nmodel[j].add(Dropout(0.4))\nmodel[j].add(Flatten())\nmodel[j].add(Dense(128, activation='relu'))\nmodel[j].add(Dropout(0.4))\nmodel[j].add(Dense(10, activation='softmax'))\nmodel[j].compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])","56eb9978":"j=4\nmodel[j] = Sequential()\n\nmodel[j].add(Conv2D(32,kernel_size=3,activation='relu',input_shape=(28,28,1)))\nmodel[j].add(BatchNormalization())\nmodel[j].add(Conv2D(32,kernel_size=3,activation='relu'))\nmodel[j].add(BatchNormalization())\nmodel[j].add(Conv2D(32,kernel_size=5,strides=2,padding='same',activation='relu'))\nmodel[j].add(BatchNormalization())\nmodel[j].add(Dropout(0.2))\n\nmodel[j].add(Conv2D(64,kernel_size=3,activation='relu'))\nmodel[j].add(BatchNormalization())\nmodel[j].add(Conv2D(64,kernel_size=3,activation='relu'))\nmodel[j].add(BatchNormalization())\nmodel[j].add(Conv2D(64,kernel_size=5,strides=2,padding='same',activation='relu'))\nmodel[j].add(BatchNormalization())\nmodel[j].add(Dropout(0.4))\n\nmodel[j].add(Flatten())\nmodel[j].add(Dense(128, activation='relu'))\nmodel[j].add(BatchNormalization())\nmodel[j].add(Dropout(0.4))\nmodel[j].add(Dense(10, activation='softmax'))\n\nmodel[j].compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])","a65521b8":"# CREATE VALIDATION SET\nX_train2, X_val2, Y_train2, Y_val2 = train_test_split(X_train, Y_train, test_size = 0.2)\n# TRAIN NETWORKS 1,2,3,4\nhistory = [0] * nets\nnames = [\"basic\",\"32C3-32C3\",\"32C5S2\",\"both+BN\",\"both+BN+DA\"]\nepochs = 50\nfor j in range(nets-1):\n    history[j] = model[j].fit(X_train2,Y_train2, batch_size=64, epochs = epochs,  \n        validation_data = (X_val2,Y_val2), callbacks=[annealer], verbose=0)\n    print(\"CNN {0}: Epochs={1:d}, Train accuracy={2:.5f}, Validation accuracy={3:.5f}\".format(\n        names[j],epochs,max(history[j].history['acc']),max(history[j].history['val_acc']) ))\n    \ndatagen = ImageDataGenerator(\n        rotation_range=10,  \n        zoom_range = 0.1,  \n        width_shift_range=0.1, \n        height_shift_range=0.1)\n# TRAIN NETWORK 5\nj = nets-1\nhistory[j] = model[j].fit_generator(datagen.flow(X_train2,Y_train2, batch_size=128), \n    epochs = epochs, steps_per_epoch = X_train2.shape[0]\/\/128,\n    validation_data = (X_val2,Y_val2), callbacks=[annealer], verbose=0)\nprint(\"CNN {0}: Epochs={1:d}, Train accuracy={2:.5f}, Validation accuracy={3:.5f}\".format(\n    names[j],epochs,max(history[j].history['acc']),max(history[j].history['val_acc']) ))","7408d7ff":"# PLOT ACCURACIES\nplt.figure(figsize=(15,5))\nfor i in range(nets):\n    plt.plot(history[i].history['val_acc'],linestyle=styles[i])\nplt.title('model accuracy')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(names, loc='upper left')\naxes = plt.gca()\naxes.set_ylim([0.98,1])\nplt.show()","a5649fdb":"# TRAIN OUR BEST NET MORE\nannealer = LearningRateScheduler(lambda x: 1e-3 * 0.95 ** (x+epochs))\nmodel[4].fit_generator(datagen.flow(X_train,Y_train, batch_size=64), epochs = 25, \n    steps_per_epoch = X_train.shape[0]\/\/64, callbacks=[annealer], verbose=0)\n\n# SUBMIT TO KAGGLE\nresults = model[4].predict(X_test)\nresults = np.argmax(results,axis = 1)\nresults = pd.Series(results,name=\"Label\")\nsubmission = pd.concat([pd.Series(range(1,28001),name = \"ImageId\"),results],axis = 1)\nsubmission.to_csv(\"MNIST-CNN.csv\",index=False)","fe5c4ae3":"# BUILD CONVOLUTIONAL NEURAL NETWORKS\nfrom keras.optimizers import RMSprop\nnets = 15\nmodel = [0] *nets\nfor j in range(nets):\n    model[j] = Sequential()\n\n    model[j].add(Conv2D(32, kernel_size = 5, activation='relu', input_shape = (28, 28, 1)))\n    model[j].add(BatchNormalization())\n    model[j].add(Conv2D(32, kernel_size = 5, activation='relu'))\n    model[j].add(BatchNormalization())\n    model[j].add(Conv2D(32, kernel_size = 3, strides=2, padding='same', activation='relu'))\n    model[j].add(BatchNormalization())\n    model[j].add(Dropout(0.2))\n\n    model[j].add(Conv2D(64, kernel_size = 3, activation='relu'))\n    model[j].add(BatchNormalization())\n    model[j].add(Conv2D(64, kernel_size = 3, activation='relu'))\n    model[j].add(BatchNormalization())\n    model[j].add(Conv2D(64, kernel_size = 3, strides=2, padding='same', activation='relu'))\n    model[j].add(BatchNormalization())\n    model[j].add(Dropout(0.2))\n\n    model[j].add(Conv2D(128, kernel_size = 3, activation='relu'))\n    model[j].add(BatchNormalization())\n    model[j].add(Flatten())\n    model[j].add(Dropout(0.4))\n    model[j].add(Dense(10, activation='softmax'))\n\n    # COMPILE WITH ADAM OPTIMIZER AND CROSS ENTROPY COST\n    model[j].compile(optimizer=\"rmsprop\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])","ccb4d96b":"datagen = ImageDataGenerator(\n        rotation_range=10,  \n        zoom_range = 0.10,  \n        width_shift_range=0.1, \n        height_shift_range=0.1)\n# DECREASE LEARNING RATE EACH EPOCH\nannealer = LearningRateScheduler(lambda x: 1e-3 * 0.95 ** x)\n# TRAIN NETWORKS\nhistory = [0] * nets\nepochs = 45\nfor j in range(nets):\n    X_train2, X_val2, Y_train2, Y_val2 = train_test_split(X_train, Y_train, test_size = 0.1)\n    history[j] = model[j].fit_generator(datagen.flow(X_train2,Y_train2, batch_size=64),\n        epochs = epochs, steps_per_epoch = X_train2.shape[0]\/\/64,  \n        validation_data = (X_val2,Y_val2), callbacks=[annealer], verbose=0)\n    print(\"CNN {0:d}: Epochs={1:d}, Train accuracy={2:.5f}, Validation accuracy={3:.5f}\".format(\n        j+1,epochs,max(history[j].history['acc']),max(history[j].history['val_acc']) ))","0245d582":"# ENSEMBLE PREDICTIONS AND SUBMIT\nresults = np.zeros( (X_test.shape[0],10) ) \nfor j in range(nets):\n    results = results + model[j].predict(X_test)\nresults = np.argmax(results,axis = 1)\nresults = pd.Series(results,name=\"Label\")\nsubmission = pd.concat([pd.Series(range(1,28001),name = \"ImageId\"),results],axis = 1)\nsubmission.to_csv(\"MNIST-CNN-ENSEMBLE.csv\",index=False)","32c8392a":"plt.figure(figsize=(15,6))\nfor i in range(40):  \n    plt.subplot(4, 10, i+1)\n    plt.imshow(X_test[i].reshape((28,28)),cmap=plt.cm.binary)\n    plt.title(\"predict=%d\" % results[i],y=0.9)\n    plt.axis('off')\nplt.subplots_adjust(wspace=0.3, hspace=-0.1)\nplt.show()","54f06a81":"**Model 3**","98a0cd89":"**Model 4**","ce60ae79":"**Model 2**","a22754af":"**# DATA AUGMENTATION**","1fbc6cdc":"**Built convolution neural network**"}}