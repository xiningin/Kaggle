{"cell_type":{"2250791f":"code","b2e8d328":"code","42d00b86":"code","036e10d4":"code","defc05ad":"code","1bdfb079":"code","3912f13d":"code","e154dfeb":"code","56f75341":"code","0a76d5c6":"code","ad4f8fef":"code","3763fb1a":"code","fe8bdd3a":"code","5f0bd196":"code","93e402de":"markdown","c769c65d":"markdown","14807b24":"markdown","63649b2c":"markdown","9ecd383c":"markdown","47608e52":"markdown"},"source":{"2250791f":"#import all the packages...\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport datetime as dt\nimport seaborn as sns\nimport statsmodels.api as sm\nfrom statsmodels.tsa.statespace.sarimax import SARIMAX\nimport itertools\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom dateutil import relativedelta\nimport datetime","b2e8d328":"df = pd.read_excel('..\/input\/timeseries-data\/Data.xlsx')","42d00b86":"df.describe()","036e10d4":"df.Date = pd.to_datetime(df.Date,format='%d-%m-%Y')\nBrand_list = df.Key.unique()","defc05ad":"Brand_list","1bdfb079":"pd.set_option('display.float_format', lambda x: '%.5f' % x)","3912f13d":"final = pd.DataFrame(columns=[\"Brand\",\"Forecast_values\",\"Actual_values\"])\nfor brand_name in Brand_list:\n    print(brand_name)\n    brand_df = df.loc[df.Key == brand_name]\n    brand_df.set_index('Date',inplace=True)\n    tmp = []\n    forecast = pd.DataFrame()\n    Actuals = pd.DataFrame()\n    s = pd.DataFrame()\n    k = pd.DataFrame()\n    \n    if len(brand_df)>12:\n        train_start = datetime.date(2019,1, 1)\n        train_till = datetime.date(2019, 7, 1)\n        Actuals_end = datetime.date(2020, 1, 1)\n        train_date = train_start\n        while train_date < train_till:\n            test_date = train_date + relativedelta.relativedelta(months=1)\n            dependent_colume = 'Volume'\n            x = brand_df.drop(columns=[dependent_colume,'Key'])\n            y = brand_df[[dependent_colume]]\n            train_x = x[:train_date]\n            train_y = y[:train_date][[dependent_colume]]\n            test_x = x[test_date:]\n            test_y = y[test_date:][[dependent_colume]]\n            train_date = train_date + relativedelta.relativedelta(months=1)\n\n#             if ((test_date.month == 8) or (test_date.month == 2)):\n#                 print(\"July imputation...\")\n#                 train_y[train_date:train_date] = np.nan\n\n            p = d= q = range(0,2)\n            # generate p,d,q value between 0 and 2\n            pdq = list(itertools.product(p, d, q))\n            seasonal_pdq = [(x[0], x[1], x[2], 12) for x in list(itertools.product(p, d, q))]\n            pdq_list = {}\n            spdq_list = {}\n            aic_value = {}\n            flag = 0\n            for param in pdq:\n                for param_seasonal in seasonal_pdq:\n                    try:\n                        mod = SARIMAX(exog=train_x,\n                                      endog=train_y,\n                                      order=param,\n                                      seasonal_order=param_seasonal,\n                                      enforce_stationarity=True,\n                                      enforce_invertibility=True)\n\n                        results = mod.fit()\n                        if flag == 0:\n                            aic_value['aic'] = results.aic\n                            pdq_list['pdq'] = param\n                            spdq_list['spdq_list'] = param_seasonal\n                        else :\n                            #check for least aic value and store pdq and seasonal parameters...\n                            if aic_value['aic'] > results.aic :\n                                aic_value['aic'] = results.aic\n                                pdq_list['pdq'] = param\n                                spdq_list['spdq_list'] = param_seasonal\n                        flag = flag + 1\n                    except:\n                        continue\n\n            #run sarima by best combination of parameters...\n            try:\n                mod = sm.tsa.statespace.SARIMAX(exog=train_x,\n                                                endog=train_y,\n                                                order=pdq_list['pdq'],\n                                                seasonal_order=spdq_list['spdq_list'],\n                                                enforce_stationarity=True,\n                                                enforce_invertibility=True)\n                results = mod.fit()\n        #         #forecast for next month....\n                if test_date > Actuals_end:\n                    s = pd.DataFrame()\n                    s[\"Forecast_values\"] = list(results.get_prediction(exog=test_x[test_date:],start=test_x.index.min(),end=test_x.index.max()).predicted_mean.values)\n                    s.index = test_y[test_date:].index\n                    s[\"Brand\"] = str(brand_name) +str(\"_\")+ s.index.month.astype(str) +str(\"_\")+s.index.year.astype(str)\n\n\n                    k = pd.DataFrame()\n                    k = test_y[test_date:]\n                    k.columns = ['Actual_values']\n                    k.index = test_y[test_date:].index\n                    k[\"Brand\"] = str(brand_name) +str(\"_\")+ k.index.month.astype(str) +str(\"_\")+k.index.year.astype(str)\n                    break\n                \n\n                forecast[str(brand_name)+str('_')+str(test_date.month)+str(\"_\")+str(test_date.year)] = results.get_prediction(exog=test_x[test_date:test_date],\n                                                                                            start=test_x.index.min()).predicted_mean.values\n                Actuals[str(brand_name)+str('_')+str(test_date.month)+str(\"_\")+str(test_date.year)] = test_y[test_date:test_date].values[0]\n           \n            except Exception as e:\n                print(\"in exception\")\n                continue\n        \n        if ((len(forecast)>0) & (len(Actuals)>0)):\n            forecast=forecast.T.reset_index()\n            forecast.columns=[\"Brand\",\"Forecast_values\"]\n            if(len(s)>0):\n                forecast= pd.concat([forecast,s],axis=0)\n            Actuals=Actuals.T.reset_index()\n            Actuals.columns=[\"Brand\",\"Actual_values\"]\n            if(len(k)>0):\n                Actuals= pd.concat([Actuals,k],axis=0)\n            brand_wise_merge = forecast.merge(Actuals,on=\"Brand\",how=\"left\")\n            final = final.append(brand_wise_merge,ignore_index=True)\n        else:\n            print(\"No forecast\")\n    else:\n        print(\"length mismatch\")","e154dfeb":"final.head(20)","56f75341":"final['Error']=np.abs(final['Actual_values']-final['Forecast_values'])\nfinal[['Brandname','leMonth','leYear']] = final.Brand.str.split(\"_\",expand=True)","0a76d5c6":"Agg_accuracy = final.groupby(by=['leMonth','leYear']).sum()[['Error','Actual_values','Forecast_values']]\nAgg_accuracy['Accuracy'] = np.round((1-(Agg_accuracy['Error']\/Agg_accuracy['Actual_values']))*100,2)","ad4f8fef":"Agg_accuracy_brand = final.groupby(by=['Brandname']).sum()[['Error','Actual_values','Forecast_values']]\nAgg_accuracy_brand['Accuracy'] = np.round((1-(Agg_accuracy_brand['Error']\/Agg_accuracy_brand['Actual_values']))*100,2)","3763fb1a":"Agg_accuracy","fe8bdd3a":"Agg_accuracy_brand","5f0bd196":"final.to_excel('Sarima_Forecast.xlsx')","93e402de":"For modelling we follow differnt steps:\n1. iterate over all brands and take out single brand each time.\n2. provide train and test date based on requirement.\n3. divide train and test data as le cycle works for whole year. ex apr is start so (3+9,4+8 etc..) each time upto december we have to complete, start date could be any.\n4. iterate over p,d,q and P,D,Q value. provide min and max value which basically decide by ACF and PACF lag.\n5. compare the aic and bic value and select least one. As least aic is best.\n6. foorecast for the aic value\n7. forecast for required no of steps ( basically ahead month or year based on freuqency).\n8. save the result and iterate till end","c769c65d":"load data from excel file. we can add up workbook sheet as well in which we can import multiple sheets but here as single sheet is required hence directly read_excel works fine.","14807b24":"# SARIMA","63649b2c":"Convert date column in datetime format as we have to create index as datetime format only. be careful while giving format of date as it might change later operations. get the unique brand list as we have to iterate over all the brands separately","9ecd383c":"Calculate the accuracy which is mape (1- ABS(actual-forcast)\/actual). we use mape as it is unit less and later can multiply with 100 so we can get results in percentage","47608e52":"SARIMA stands for seasonal arima.it is family of box jenkin method. ARIMA has 3 differnt component together which is basically AR ( Auto regressive), MA( Moving average ) and I ( Integrating factor). Seasonal arima works like arima model but it has separate component to learn seasonality. seasonal arima has six hyperparameter p,d,q and P,D,Q which basically stands for AR,MA and intergating factor. later 3 terms is useful for seasonal factor. We can add external driver as well by exog and endog parameter.\n\nImport all the requires packages. we are using statsmodel 0.10.0 latest stable version.need to be cautious while using date time."}}