{"cell_type":{"148b98a8":"code","a28eb4c9":"code","ca906aa8":"code","d7dc16b9":"code","cc7716ae":"code","c1b3857c":"code","8136ddde":"code","1c1a8864":"code","6d48ceb1":"code","64efbc0d":"markdown","1119428d":"markdown","2b41dadf":"markdown","d39776be":"markdown","995c2fcb":"markdown","59b072f5":"markdown","8fa479dc":"markdown"},"source":{"148b98a8":"#Simple Linear Regression\n\n#Importing\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n%matplotlib inline","a28eb4c9":"#generating data for simple linear regression\nnp.random.seed(1)\n\nx=np.random.randn(1000,1)  \nw=np.random.randn()\nb=np.random.randn()\n\ny=x*w+b +(np.random.randn(1000,1)*0.09)  #this last term of np.random.randn() is to add noise in data\n","ca906aa8":"# plt.title('Generated data')\nplt.figure(figsize=(12,8))\nplt.title('Generated data')\nplt.xlabel('input(x)')\nplt.ylabel('output(y)')\nsns.scatterplot(x=x[:,0],y=y[:,0])\nplt.grid(True)\nplt.show()\n","d7dc16b9":"class SimpleLinearRegression():\n    def __init__(self):\n        self.parameters={}\n        self.m=None\n    \n    \n    def predict(self,X):\n        self.m=X.shape[0]\n        try:\n            y_pred=self.parameters['w1']*X+self.parameters['b']\n            return y_pred\n        except KeyError:\n            print('First fit your data and then predict the values')\n\n            \n    def cost(self,y_pred,y_true):\n        return (np.sum(np.square(y_pred-y_true)))\/(2*self.m)\n     \n        \n    def fit(self,X,y,learning_rate=0.01,iterations=1000):\n        self.parameters['w1']=np.random.randn()\n        self.parameters['b']=np.random.randn()\n        cost=[]\n        y_pred=self.predict(X)\n        cost.append(self.cost(y_pred,y))\n        print('Cost at iteration number '+str(1)+' is : ',cost[0])\n        for i in range(iterations):\n            dw1=np.sum((y_pred-y)*X)\/self.m\n            db=np.sum(y_pred-y)\/self.m\n            \n            self.parameters['w1']=self.parameters['w1']-(learning_rate*dw1)\n            self.parameters['b']=self.parameters['b']-(learning_rate*db)\n            \n            y_pred=self.predict(X)\n            cost.append(self.cost(y_pred,y))\n            if (i+1)%100==0:\n                print('Cost at iteration number '+str(i+1)+' is : ',cost[i])\n        plt.title('cost v\/s iteration')\n        plt.plot(cost)\n        plt.xlabel('no. of iterations')\n        plt.ylabel('cost')\n        plt.show()","cc7716ae":"model=SimpleLinearRegression()","c1b3857c":"model.fit(x,y)","8136ddde":"y_pred=model.predict(x)","1c1a8864":"cost=model.cost(y_pred,y)\nprint(cost)","6d48ceb1":"plt.figure(figsize=(12,8))\nplt.title('Simple Linear Regression')\nsns.scatterplot(x=x[:,0],y=y[:,0],alpha=0.4)\nsns.lineplot(x=x[:,0],y=y_pred[:,0])\nplt.xlabel('x-input')\nplt.ylabel('y-input')\nplt.show()","64efbc0d":"# Visualising best fit line and the data","1119428d":"# Importing Libraries\n* numpy, also known as numerical python. It is a package that deals with multidimentional array.\n* seaborn and matplotlib are libraries that helps in data visualisation.","2b41dadf":"# Creating model\n* SimpleLinearRegression class is created which has three functions:-\n\n    1. predict() -> takes input 'x' and returns predicted output 'y_pred'.\n    2. cost() -> takes input 'true y' and 'predicted y' and returns the cost.\n    3. fit() ->takes input 'x' 'y' and optional arguments learning_rate and interations, it works as follows:-\n        * initailizes parameters with random values.\n        * predicts values.\n        * computes cost.\n        * uses gradient descent algorithm for optimisation.\n        * plots cost vs number of iterations.","d39776be":"# Visualising generated data","995c2fcb":"### If this notebook was helpful to you please do upvote and comment suggestions if any.","59b072f5":"# Implementing Simple Linear Regression from scratch.\n","8fa479dc":"# Generating Data\n* For performing Simple Linear Regression we need to generate data.\n* x -> input\n* y -> output\n* w and b -> parameters\n* To generate random data we use np.random.randn().\n* np.random.seed() is used to repeatedly generate same random data."}}