{"cell_type":{"b46301e8":"code","404fe042":"code","5e467227":"code","8260a3d0":"code","e04d5201":"code","abd218af":"code","46652459":"code","3ad87fef":"code","9f9d1233":"code","1098c5b5":"code","b6c88ee8":"code","c8c912c3":"code","46f27340":"code","1839da74":"code","f48cb060":"code","52359e73":"code","fd8d8b23":"code","7b00e753":"code","83c2697c":"code","9d837bc4":"code","d800d8ac":"code","a6e6abc4":"code","968141f5":"code","c579ef32":"code","002a7535":"code","068a8d52":"code","fb9a875f":"markdown","81936a65":"markdown","0eb7b734":"markdown","450e72e5":"markdown","3495f1e4":"markdown","77d07f03":"markdown","3f945c7a":"markdown","f02405e2":"markdown"},"source":{"b46301e8":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\nfrom glob import glob\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\n# for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#     for filename in filenames:\n#         print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","404fe042":"\n\n\nTRAIN_PATH = '..\/input\/severstal-steel-defect-detection\/train_images\/'\nTEST_PATH = '..\/input\/severstal-steel-defect-detection\/test_images\/'\n\n# loading training dataset\ntrain_df = pd.read_csv('..\/input\/severstal-steel-defect-detection\/train.csv')\ntrain_img = sorted(glob(TRAIN_PATH + '*.jpg'))\ntest_img = sorted(glob(TEST_PATH + '*.jpg'))\n\n","5e467227":"train_df.shape","8260a3d0":"train_df.head()","e04d5201":"#plotting the pie chart for demonstration train and test set\nlabels = 'Train', 'Test'\nsizes = [len(train_img), len(test_img)]\nexplode = 0, 0.1\n\n\ndef make_autopct(values):\n    def my_autopct(pct):\n        total = sum(values)\n        val = int(round(pct*total\/100.0))\n        return '{p:.2f}%  ({v:d})'.format(p=pct,v=val)\n    return my_autopct\n\n\nfig, ax = plt.subplots(figsize=(6,6))\nax.pie(sizes, explode=explode, labels=labels, autopct = make_autopct(sizes), shadow=True, startangle = 90)\nax.axis('equal')\nax.set_title('Train and Test Sets')\n\nplt.show()","abd218af":"print('There are {} empty records'.format(train_df.EncodedPixels.isnull().sum()))","46652459":"#plotting the pie chart for demonstration Empty and Non-Empty set\nlabels = 'Non-empty', 'Empty'\nsizes = [train_df.EncodedPixels.count(), train_df.EncodedPixels.isnull().sum()]\nexplode = 0, 0.1\n\n\ndef make_autopct(values):\n    def my_autopct(pct):\n        total = sum(values)\n        val = int(round(pct*total\/100.0))\n        return '{p:.2f}%  ({v:d})'.format(p=pct,v=val)\n    return my_autopct\n\n\nfig, ax = plt.subplots(figsize=(6,6))\nax.pie(sizes, explode=explode, labels=labels, autopct = make_autopct(sizes), shadow=True, startangle = 90)\nax.axis('equal')\nax.set_title('Empty and Non-Empty Sets')\n\nplt.show()","3ad87fef":"split_df = train_df['ImageId_ClassId'].str.split('_', n=1, expand=True)\ntrain_df['Image'] = split_df[0]\ntrain_df['Label'] = split_df[1]\n\ntrain_df.head()","9f9d1233":"labels_count = train_df.groupby('Image').count()['EncodedPixels']\nlabels_count","1098c5b5":"#plotting the pie chart for demonstration Defects\nlabels = 'Defect 1', 'Defect 2', 'Defect 3', 'Defect 4', 'No Defects'\ndefect_1 = train_df[train_df['Label'] == '1'].EncodedPixels.count()\ndefect_2 = train_df[train_df['Label'] == '2'].EncodedPixels.count()\ndefect_3 = train_df[train_df['Label'] == '3'].EncodedPixels.count()\ndefect_4 = train_df[train_df['Label'] == '4'].EncodedPixels.count()\nlabels_count = train_df.groupby('Image').count()['EncodedPixels']\nno_defects = len(labels_count) - labels_count.sum()\nsizes = [defect_1, defect_2, defect_3, defect_4, no_defects]\nprint('There are {} defect1 images'.format(defect_1))\nprint('There are {} defect2 images'.format(defect_2))\nprint('There are {} defect3 images'.format(defect_3))\nprint('There are {} defect4 images'.format(defect_4))\nprint('There are {} images with no defects'.format(no_defects))\nexplode = 0, 0.1\n\n\ndef make_autopct(values):\n    def my_autopct(pct):\n        total = sum(values)\n        val = int(round(pct*total\/100.0))\n        return '{p:.2f}%  ({v:d})'.format(p=pct,v=val)\n    return my_autopct\n\n\nfig, ax = plt.subplots(figsize=(6,6))\nax.pie(sizes, labels=labels, autopct = make_autopct(sizes), shadow=True, startangle = 90)\nax.axis('equal')\nax.set_title('Defects')\n\nplt.show()","b6c88ee8":"labels_per_image = train_df.groupby('Image')['EncodedPixels'].count()\nprint('The mean number of labels per image is {}'.format(labels_per_image.mean()))","c8c912c3":"fig, ax = plt.subplots(figsize=(6,6))\nax.hist(labels_per_image)\nax.set_title('Number of labels per image')","46f27340":"def get_image_sizes(train = True):\n    '''\n    Funtion to get the sizes of the images\n    '''\n    \n    if train:\n        path=TRAIN_PATH\n    else:\n        path = TEST_PATH\n        \n    widths = []\n    heights = []\n    \n    images = sorted(glob(path + '*.jpg'))\n    \n    max_im = Image.open(images[0])\n    min_im = Image.open(images[0])\n    \n    for im in range(0, len(images)):\n        image = Image.open(images[im])\n        width, height = image.size\n        if len(widths) > 0:\n            if width > max(widths):\n                max_im = image\n                \n            if width < min(widths):\n                min_im = image\n        \n        widths.append(width)\n        heights.append(height)\n        \n    return widths, heights, max_im, min_im","1839da74":"# get sizes of images from test and train sets\ntrain_widths, train_heights, max_train, min_train = get_image_sizes(train = True)\ntest_widths, test_heights, max_test, min_test = get_image_sizes(train = False)\n\nprint('Maximum width for training set is {}'.format(max(train_widths)))\nprint('Minimum width for training set is {}'.format(min(train_widths)))\nprint('Maximum height for training set is {}'.format(max(train_heights)))\nprint('Minimum height for training set is {}'.format(min(train_heights)))\n\nprint('Maximum width for test set is {}'.format(max(test_widths)))\nprint('Minimum width for test set is {}'.format(min(test_widths)))\nprint('Maximum height for test set is {}'.format(max(test_heights)))\nprint('Minimum height for test set is {}'.format(min(test_heights)))","f48cb060":"# https:\/\/www.kaggle.com\/titericz\/building-and-visualizing-masks\ndef rle2maskResize(rle):\n    # CONVERT RLE TO MASK \n    if (pd.isnull(rle))|(rle=='')|(rle=='-1'): \n        return np.zeros((256,1600) ,dtype=np.uint8)\n    \n    height= 256\n    width = 1600\n    mask= np.zeros( width*height ,dtype=np.uint8)\n\n    array = np.asarray([int(x) for x in rle.split()])\n    starts = array[0::2]-1\n    lengths = array[1::2]    \n    for index, start in enumerate(starts):\n        mask[int(start):int(start+lengths[index])] = 1\n    \n    return mask.reshape( (height,width), order='F' )","52359e73":"def plot_mask(image_filename):\n    '''\n    Function to plot an image and segmentation masks.\n    INPUT:\n        image_filename - filename of the image (with full path)\n    '''\n    img_id = image_filename.split('\/')[-1]\n    image = Image.open(image_filename)\n    train = train_df.fillna('-1')\n    rle_masks = train[(train['Image'] == img_id) & (train['EncodedPixels'] != '-1')]['EncodedPixels'].values\n    \n    defect_types = train[(train['Image'] == img_id) & (train['EncodedPixels'] != '-1')]['Label'].values\n    \n    if (len(rle_masks) > 0):\n        fig, axs = plt.subplots(1, 1 + len(rle_masks), figsize=(20, 3))\n\n        axs[0].imshow(image)\n        axs[0].axis('off')\n        axs[0].set_title('Original Image')\n\n        for i in range(0, len(rle_masks)):\n            mask = rle2maskResize(rle_masks[i])\n            axs[i + 1].imshow(image)\n            axs[i + 1].imshow(mask, alpha = 0.5, cmap = \"Reds\")\n            axs[i + 1].axis('off')\n            axs[i + 1].set_title('Mask with defect #{}'.format(defect_types[i]))\n\n        plt.suptitle('Image with defect masks')\n    else:\n        fig, axs = plt.subplots(figsize=(20, 3))\n        axs.imshow(image)\n        axs.axis('off')\n        axs.set_title('Original Image without Defects')","fd8d8b23":"plot_mask(train_img[0])","7b00e753":"# plot image without defects\nplot_mask(train_img[1])","83c2697c":"# plot image example with several defects\nfor image_code in train_df.Image.unique():\n    if (train_df.groupby(['Image'])['EncodedPixels'].count().loc[image_code] > 1):\n        plot_mask(TRAIN_PATH + image_code)\n        break;","9d837bc4":"def add_mask_areas(train_df):\n    masks_df = train_df.copy()\n    masks_df['Area'] = 0\n    \n    for i, row in masks_df.iterrows():\n        masks_df['Area'].loc[i] = np.sum(get_mask(i))\n        \n    return masks_df\n\ndef get_mask(line_id):\n    # convert rle to mask\n    rle = train_df.loc[line_id]['EncodedPixels']\n    \n    np_mask = rle2maskResize(rle)\n    np_mask = np.clip(np_mask, 0, 1)\n        \n    return np_mask","d800d8ac":"masks_df = add_mask_areas(train_df)","a6e6abc4":"# Plot Histograms and KDE plots\nplt.figure(figsize=(15,7))\n\nplt.subplot(221)\nsns.distplot(masks_df[masks_df['Label'] == '1']['Area'].values, kde=False, label='Defect #1')\nplt.legend()\nplt.title('Mask Area Histogram : Defect #1', fontsize=15)\n\nplt.subplot(222)\nsns.distplot(masks_df[masks_df['Label'] == '2']['Area'].values, kde=False, label='Defect #2')\nplt.legend()\nplt.title('Mask Area Histogram: Defect #2', fontsize=15)\n\nplt.subplot(223)\nsns.distplot(masks_df[masks_df['Label'] == '3']['Area'].values, kde=False, label='Defect #3')\nplt.legend()\nplt.title('Mask Area Histogram : Defect #3', fontsize=15)\n\nplt.subplot(224)\nsns.distplot(masks_df[masks_df['Label'] == '4']['Area'].values, kde=False, label='Defect #4')\nplt.legend()\nplt.title('Mask Area Histogram: Defect #4', fontsize=15)\n\nplt.tight_layout()\nplt.show()","968141f5":"plt.figure(figsize=(15,4))\n\nplt.subplot(111)\nsns.kdeplot(masks_df[masks_df['Label'] == '1']['Area'].values, label='Defict #1')\nsns.kdeplot(masks_df[masks_df['Label'] == '2']['Area'].values, label='Defict #2')\nsns.kdeplot(masks_df[masks_df['Label'] == '3']['Area'].values, label='Defict #3')\nsns.kdeplot(masks_df[masks_df['Label'] == '4']['Area'].values, label='Defict #4')\nplt.legend()\n\nplt.title('Mask Area KDE plot', fontsize=15)\n\n","c579ef32":"def plot_image_grid(df, n_images = 5):\n    \n    fig, axs = plt.subplots(n_images, 2, figsize=(20, 10))\n    \n    for i in range(n_images):\n        image_id = np.random.randint(0,len(df),1)[0]\n\n        image = Image.open(TRAIN_PATH + df.iloc[image_id]['Image'])\n        mask = rle2maskResize(df.iloc[image_id]['EncodedPixels'])\n        \n        defect = df.iloc[image_id]['Label']\n\n        axs[i,0].imshow(image)\n        axs[i,0].axis('off')\n        axs[i,0].set_title('Original Image')\n\n        axs[i, 1].imshow(image)\n        axs[i, 1].imshow(mask, alpha = 0.5, cmap = \"Reds\")\n        axs[i, 1].axis('off')\n        axs[i, 1].set_title('Mask with defect #{}'.format(defect))\n\n    plt.suptitle('Images with defect masks')","002a7535":"# filter the dataframe, so we have only images with very large masks\nlarge_masks_df = masks_df[masks_df['Area'] > 200000]","068a8d52":"# plot a grid of images with large masks\nplot_image_grid(large_masks_df, n_images = 5)","fb9a875f":"I borrowed the implementation from this [kernel](https:\/\/www.kaggle.com\/aleksandradeis\/steel-defect-detection-eda)","81936a65":"*train.csv* file contains:\n\n* 4 rows for each image from the train set. Each row corresponds to one of the defect labels.\n* ImageId_ClassId is a combination of an image filename and the defect label.\n* EncodedPixels column contains RLE encoded mask for the particular defect type or is empty, when the defect is not found.","0eb7b734":"# Visualise Masks","450e72e5":"# Analysing Images","3495f1e4":"Images are of same sizes and that is good","77d07f03":"Spliting the forst columns from the train_df DataFrame","3f945c7a":"Analyse Mask Areas","f02405e2":"* Almost half of images doesn't contain any defects;\n* Most of images with defects contain the defects of only one type;\n* In rare cases an image contains the defects of two different types."}}