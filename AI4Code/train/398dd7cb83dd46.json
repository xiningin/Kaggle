{"cell_type":{"0d3896b3":"code","2725af6c":"code","c1812267":"code","e131a719":"code","2efec5d4":"code","2bfeed91":"code","c7659557":"code","00092ea2":"code","75062ac7":"code","edc57329":"code","8d0acfae":"code","00e58aaa":"code","5b8d83ff":"code","bd8b67c4":"code","74225d23":"code","3af521a1":"code","2ed1d68e":"code","e7ffcc28":"code","8e3f4959":"code","a49287fb":"code","dccb8e11":"code","65b4a601":"code","9c800a49":"markdown","44203731":"markdown","5642cf5b":"markdown","5d11eecc":"markdown","c289ce11":"markdown","ec20d9ac":"markdown","c5a59f31":"markdown"},"source":{"0d3896b3":"import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport numpy as np\nfrom tqdm.notebook import tqdm \nimport matplotlib.pyplot as plt\nfrom pathlib import Path as p\nfrom datetime import datetime\n\nimport mnist_od_utils as utils\nimport general_utils\n\n\n# import importlib\n# importlib.reload(utils)","2725af6c":"# Create output folder\n\nresult_folder = p.cwd()\/'results'\ncurrent_time = datetime.now().strftime(\"%m-%d__%H-%M-%S\")\n# current_time = '09-09__03-52-38'\noutput_folder = general_utils.folder(result_folder\/current_time)\nprint(output_folder)","c1812267":"#neural network building blocks \nimport torch\nimport torch.nn as nn\nimport torch.nn.utils.spectral_norm as spectral_norm\nimport pandas as pd\n\nbasic_conv = nn.Conv2d #change this to 3d if needed \n\n#generally useful\nclass Pad_to_even_size(nn.Module):\n    def __init__(self):\n        super(Pad_to_even_size, self).__init__()\n        \n    def forward(self, x):\n        a = []\n        for i in x.shape[2:]:\n            if i%2 == 1:\n                a = [0,1] + a\n            else:\n                a = [0,0] + a\n        return torch.nn.functional.pad(x, a)\n\ndef pretty_print_module_list(module_list, x, print_net=True, max_colwidth=500):\n    '''x: dummyinput [batch=1, C, H, W]'''\n    pd.options.display.max_colwidth = max_colwidth\n    df = pd.DataFrame({'Layer': list(map(str, module_list))})\n    output_size = []\n    for i, layer in enumerate(module_list):\n        x = layer(x)\n        output_size.append(tuple(x.size()))\n    df['Output size'] = output_size\n    if print_net:\n        print('\\n', df, '\\n')        \n    return df['Output size'].tolist()\n\n#========================conv======================\nclass Conv(nn.Module):\n    def __init__(self, inC, outC, kernel_size=3, padding=1, stride=1, groups=1, spectral=False):\n        super(Conv, self).__init__()\n        if spectral:\n            self.conv = spectral_norm(basic_conv(inC, outC, kernel_size=kernel_size, padding=padding, stride=stride, groups=groups))\n        else:\n            self.conv = basic_conv(inC, outC, kernel_size=kernel_size, padding=padding, stride=stride, groups=groups)\n    def forward(self, x):\n        x = self.conv(x)\n        return x\n\n#=======================norm======================\nclass No_norm(nn.Module):\n    def __init__(self, c):\n        super(No_norm, self).__init__()\n    def forward(self, x):\n        return x\n\n","e131a719":"class MyDataset(torch.utils.data.Dataset):\n    def __init__(self, file_path, device):\n        super(MyDataset, self).__init__()\n        self.data = general_utils.pickle_load(file_path) #(img, boxes, labels)\n        self.img_size = self.data[0][0].shape[-1]\n        self.device = device\n\n    def __len__(self):\n        return len(self.data[2])\n\n    def __getitem__(self, idx):\n        img, boxes, labels = self.data[0][idx], self.data[1][idx], self.data[2][idx]\n        img = torch.tensor(img, dtype=torch.float).unsqueeze(0).to(self.device) #[c=1, h, w]\n        img = (img - img.mean())\/img.std() + 0.5 \n        boxes = torch.tensor(boxes, dtype=torch.uint8).to(self.device) \/ self.img_size#[n_objects, 4]\n        labels = torch.tensor(labels, dtype=torch.uint8).to(self.device) #[n_objects]\n        return img, boxes, labels\n\n    def collate_fn(self, batch):\n        img = []\n        boxes = []\n        labels=  []\n        for b in batch:\n            img.append(b[0])\n            boxes.append(b[1])\n            labels.append(b[2])\n        img = torch.stack(img)\n        return img, boxes, labels\n","2efec5d4":"def init_param(m):\n    \"\"\"\n    Initialize convolution parameters.\n    \"\"\"\n    if type(m) == nn.Conv2d:\n        nn.init.xavier_uniform_(m.weight)\n        nn.init.constant_(m.bias, 0.0)\n\nclass BaseConv(nn.Module):\n    def __init__(self, conv_layers, input_size, chosen_fm=[-1, -2], \n                 norm=nn.InstanceNorm2d, conv=Conv, act_fn=nn.LeakyReLU(0.01), spectral=False):\n        '''\n        conv_layers: list of channels from input to output\n        for example, conv_layers=[1,10,20] \n        --> module_list=[\n            conv(1,10), norm, act_fn, \n            conv(10,10), norm, act_fn, \n            maxpool, \n            conv(10, 20), norm, act_fn, \n            conv(20, 20), norm, act_fn]\n\n        input_size: int (assume square images)\n        '''\n        super(BaseConv, self).__init__()\n        #create module list\n        self.module_list = nn.ModuleList()\n        self.fm_id = []\n        for i in range(len(conv_layers)-1):\n            if input_size % 2 == 1:\n                self.module_list.append(Pad_to_even_size())\n            self.module_list.extend([\n                conv(inC=conv_layers[i], outC=conv_layers[i+1], spectral=spectral),\n                norm(conv_layers[i+1]),\n                act_fn,\n                conv(inC=conv_layers[i+1], outC=conv_layers[i+1], spectral=spectral),\n                norm(conv_layers[i+1]),\n                act_fn, \n                nn.MaxPool2d(kernel_size=2)]\n            )\n            input_size = np.ceil(input_size \/ 2)\n\n            #select feature maps for prediction. They are the output of act_fn right before maxpool layers\n            self.fm_id.append(len(self.module_list) - 2)\n\n        self.fm_id = [self.fm_id[i] for i in chosen_fm] #only use the last 2 fm in base conv \n\n        self.module_list = self.module_list[:-1] #ignore last maxpool layer\n\n        self.output_size = input_size\n\n    def forward(self, x):\n        fm = []\n        for i in range(len(self.module_list)):\n            x = self.module_list[i](x)\n            if i in self.fm_id:\n                fm.append(x)\n        return x, fm\n\nclass AuxConv(nn.Module):\n    def __init__(self, conv_layers, input_size, \n                 norm=nn.InstanceNorm2d, conv=Conv, act_fn=nn.LeakyReLU(0.01), spectral=False):\n        '''\n        conv_layers: list of channels from input to output. \n        for example, conv_layers=[c1,c2,c3] \n        --> module_list=[\n            conv(c1, c1\/\/2, kernel_size=1, pad=0), act_fn, \n            conv(c1\/\/2, c2, 3, 1, stride=2), act_fn, \n            conv(c2, c2\/\/2), norm, act_fn, \n            conv(c2\/\/2, c3), norm, act_fn]\n\n        input_size: int (assume square images)\n        '''\n        super(AuxConv, self).__init__()\n        self.module_list = nn.ModuleList()\n        self.fm_id = []\n        for i in range(len(conv_layers)-1):\n            self.module_list.extend([conv(conv_layers[i], conv_layers[i]\/\/2, kernel_size=1, padding=0, spectral=spectral),\n                                     norm(conv_layers[i]\/\/2),\n                                     act_fn,\n                                     conv(conv_layers[i]\/\/2, conv_layers[i+1], kernel_size=3, padding=1, stride=2, spectral=spectral),\n                                     norm(conv_layers[i+1]),\n                                     act_fn])\n            self.fm_id.append(len(self.module_list)-1)\n    def forward(self, x):\n        fm = []\n        for i in range(len(self.module_list)):\n            x = self.module_list[i](x)\n            if i in self.fm_id:\n                fm.append(x)\n        return fm\n\nclass PredictionConv(nn.Module):\n    def __init__(self, n_classes, fm_channels, n_prior_per_pixel, conv=Conv, norm=nn.InstanceNorm2d, spectral=False):\n        super(PredictionConv, self).__init__()\n        self.n_classes = n_classes\n        \n        #localization conv out layers\n        self.loc_module_list = nn.ModuleList()\n        for i in range(len(fm_channels)):\n            self.loc_module_list.append(nn.Sequential(norm(fm_channels[i]), \n                                         conv(fm_channels[i], n_prior_per_pixel[i]*4, kernel_size=3, padding=1, spectral=spectral)))\n        \n        #prediction conv out layers\n        self.cla_module_list = nn.ModuleList()\n        for i in range(len(fm_channels)):\n            self.cla_module_list.append(nn.Sequential(norm(fm_channels[i]),\n                                         conv(fm_channels[i], n_prior_per_pixel[i]*n_classes, kernel_size=3, padding=1, spectral=spectral)))\n\n    def postprocess(self, x, k):\n        '''x: output of self.(loc\/cla)module_list. size [batch, n_boxes*k, h, w]. reshape into [batch, n_boxes*h*w, k]\n           k: 4 or n_classes'''\n        x = x.permute([0, 2, 3, 1]).contiguous()\n        x = x.view(x.size(0), -1, k)\n        return x\n\n    def forward(self, fm):\n        '''\n        fm: list[n_fm] of torch tensors[batch, channel, h,w]: feature maps that contain priors\n        return: loc_output[]\n        '''\n        loc_output = []\n        cla_output = []\n        \n        for i in range(len(fm)):\n        \n            loc_output.append(self.postprocess(self.loc_module_list[i](fm[i]), 4))\n\n            cla_output.append(self.postprocess(self.cla_module_list[i](fm[i]), self.n_classes))\n\n        loc_output = torch.cat(loc_output, dim=1) # [batch, total_n_prior, 4]\n        cla_output = torch.cat(cla_output, dim=1) # [batch, total_n_prior, n_classes]\n\n        return loc_output, cla_output\n\n\nclass SSD(nn.Module):\n    def __init__(self, config, base_conv=None, aux_conv=None):\n        super(SSD, self).__init__()\n        self.config = config\n\n        if base_conv != None:\n            self.base_conv = base_conv\n        else:\n            self.base_conv = BaseConv(self.config['base_conv_conv_layers'], self.config['base_conv_input_size'], norm=No_norm)\n\n        if aux_conv != None:\n            self.aux_conv = aux_conv\n        else:\n            self.aux_conv = AuxConv(self.config['aux_conv_conv_layers'], self.config['aux_conv_input_size'], norm=No_norm)\n            \n        self.pred_conv = PredictionConv(self.config['n_classes'], self.config['fm_channels'], self.config['n_prior_per_pixel'])\n\n        #prior boxes\n        self.priors_cxcy = self.create_prior_boxes()\n        self.n_p = len(self.priors_cxcy)\n\n        self.apply(init_param)\n        print('Done initialization')\n\n    def forward(self, x):\n        '''\n        x: tensor[N, 3, 300, 300]\n        returns predictions: \n            loc_output (N, n_p, 4)\n            cla_output (N, n_p, n_classes)\n        '''\n        x, fm = self.base_conv(x)\n        \n        fm.extend(self.aux_conv(x))\n\n        loc_output, cla_output = self.pred_conv(fm)\n        return loc_output, cla_output, fm\n    \n    def create_prior_boxes(self):\n        '''\n        input: self.config['fm_size', \n        'fm_prior_scale', 'fm_prior_aspect_ratio']\n        \n        return: prior boxes in center-size coordinates. \n        Tensor size [n_p, 4]\n        '''\n        priors = []\n        for i in range(self.config['n_fm']):\n            d = self.config['fm_size'][i]\n            s = self.config['fm_prior_scale'][i]\n            for j in range(d):\n                for k in range(d):\n                    #Note the order of k, j vs x,y here. It must be consistent with the permute\/view operation in PredictionConv.post_process_output\n                    cx = (k + 0.5)\/d\n                    cy = (j + 0.5)\/d\n                    for r in self.config['fm_prior_aspect_ratio'][i]:\n                        priors.append([cx, cy, s*np.sqrt(r), s\/np.sqrt(r)])\n                        if r==1:\n                            try:\n                                additional_scale = np.sqrt(s*self.config['fm_prior_scale'][i+1])\n                            except IndexError:\n                                additional_scale = 1.\n                            priors.append([cx, cy, additional_scale, additional_scale])\n        priors = torch.FloatTensor(priors).to(self.config['device'])\n        priors.clamp_(0, 1)\n        print(f\"There are {len(priors)} priors in this model\")\n        return priors\n\n\n    def detect_object(self, loc_output, cla_output, min_score, max_overlap, top_k):\n        '''\n        loc_output: size [n, n_p, 4]\n        cla_output: size [n, n_p, n_classes]\n\n        return: \n        '''\n        # print('detecting...')\n        batch_size = loc_output.size(0)\n        \n        cla_output = F.softmax(cla_output, dim=2) #[N, N_P, n_classes]\n        all_images_boxes = []\n        all_images_labels = []\n        all_images_scores = []\n\n        for i in range(batch_size):\n            decoded_locs = utils.cxcy_to_xy(utils.gcxgcy_to_cxcy(loc_output[i], self.priors_cxcy)) # (n_p, 4), fractional pt. coord\n            # \n            image_boxes = []\n            image_labels = []\n            image_scores = []\n\n            max_score, best_label = cla_output[i].max(dim=1)\n            for c in range(self.config['n_classes'] - 1):\n                class_score = cla_output[i][:, c] #[n_p]\n                above_min_score_index = (class_score > min_score) #[n_p]\n                class_score = class_score[above_min_score_index] #[n_p_min]\n                if len(class_score) == 0:\n                    continue\n                sorted_score, sorted_index = class_score.sort(dim=0, descending=True) #[n_p_min]\n\n                # print('decoded_locs.size() = ', decoded_locs.size(), above_min_score_index.size(), sorted_index.size())\n\n                keep = torch.ones_like(sorted_score, dtype=torch.uint8).to(self.config['device']) #[n_p_min]\n                iou = utils.find_jaccard_overlap(decoded_locs[above_min_score_index][sorted_index], \n                                                 decoded_locs[above_min_score_index][sorted_index]) #[n_p_min, n_p_min]\n                # print(utils.rev_label_map[c], iou)\n                for j in range(len(sorted_index)-1):\n                    if keep[j] == 1:\n                        keep[j+1:] = torch.min(keep[j+1:], iou[j, j+1:] <= max_overlap)\n                # print(utils.find_jaccard_overlap(decoded_locs[above_min_score_index][sorted_index][keep], \n                #                                  decoded_locs[above_min_score_index][sorted_index][keep])) #[n_p_min, n_p_min])\n                image_boxes.append(decoded_locs[above_min_score_index][sorted_index][keep])  \n                image_labels += [c] * keep.sum()\n                image_scores.append(sorted_score[keep])\n            \n            if len(image_boxes) == 0:\n                image_boxes.append(torch.FloatTensor([[0., 0., 1., 1.]]).to(self.config['device']))\n                image_labels.append(torch.LongTensor([0]).to(self.config['device']))\n                image_scores.append(torch.FloatTensor([0.]).to(self.config['device']))\n\n            image_boxes = torch.cat(image_boxes, dim=0) #[n_detected_object_for_this_image, 4] \n            image_labels = torch.tensor(image_labels) # [n_detected_object_for_this_image, 1] \n            image_scores = torch.cat(image_scores, dim=0) #[n_detected_object_for_this_image, 1] \n            \n            assert len(image_boxes)==len(image_labels)==len(image_scores)\n            all_images_boxes.append(image_boxes)\n            all_images_labels.append(image_labels)\n            all_images_scores.append(image_scores)\n        return all_images_boxes, all_images_labels, all_images_scores \n\nclass MultiBoxLoss(nn.Module):   \n    def __init__(self, priors_cxcy, config):\n        super(MultiBoxLoss, self).__init__()\n        self.priors_cxcy = priors_cxcy\n        self.n_p = self.priors_cxcy.size(0)\n        self.config = config\n        self.priors_xy = utils.cxcy_to_xy(priors_cxcy)\n        self.loc_criterion = nn.L1Loss()\n        self.cla_criterion = nn.CrossEntropyLoss(reduction='none')\n        \n    def forward(self, loc_output, cla_output, boxes, labels):\n        '''\n        loc_output: [N, N_P, 4]\n        cla_output: [N, N_P, N_CLASSES]\n        boxes: list of N tensor, each tensor has size [N_objects, 4], frac. coord\n        labels: list of N tensor, each tensor has size [N_objects]\n        \n        return loss: scalar\n        '''\n        loc_gt = torch.zeros_like(loc_output, dtype=torch.float)\n        cla_gt = torch.zeros([len(boxes), self.n_p], dtype=torch.long).to(self.config['device'])\n        for i in range(len(boxes)): #for each image in batch\n            n_object = len(boxes[i])\n            iou = utils.find_jaccard_overlap(boxes[i], self.priors_xy) #(n_object, n_p)\n            max_overlap_for_each_prior, object_for_each_prior = iou.max(dim=0) #[n_p], [n_p]\n\n            #make sure all gt boxes corresponds to at least one prior\n            _, prior_for_each_object = iou.max(dim=1) #[n_object] \n            object_for_each_prior[prior_for_each_object] = torch.tensor(range(n_object)).to(self.config['device']) \n            max_overlap_for_each_prior[prior_for_each_object] = 1. \n\n            loc_gt[i] = utils.cxcy_to_gcxgcy(utils.xy_to_cxcy(boxes[i][object_for_each_prior]), self.priors_cxcy) \n\n            # print(cla_gt.size(), object_for_each_prior.size()), labels[i]\n            cla_gt[i] = labels[i][object_for_each_prior]\n            # print(cla_gt[i].size(), (max_overlap_for_each_prior < self.config['iou_threshold']).size())\n            cla_gt[i][max_overlap_for_each_prior < self.config['iou_threshold']] = utils.class_label['background'] \n\n        #get positives\n        positives = (cla_gt != utils.class_label['background']) # [n, n_p]\n        n_pos = positives.sum()\n        #loc_loss\n        self.loc_loss = self.loc_criterion(loc_output[positives], loc_gt[positives]) #scalar\n        # Note: indexing with a torch.uint8 (byte) tensor flattens the tensor when indexing is across multiple dimensions (N & 8732)\n        # So, if predicted_locs has the shape (N, 8732, 4), predicted_locs[positive_priors] will have (total positives, 4)\n\n        #cla_loss, use hard_negative_mining on neg priors\n        # print(cla_gt)\n        cla_loss = self.cla_criterion(cla_output.view(-1, self.config['n_classes']), cla_gt.view(-1)) # [N * n_p]\n        cla_loss = cla_loss.view(-1, self.n_p) #[N, n_p], so that we can use tensor positives for indexing\n\n        cla_loss_pos = cla_loss[positives] \n        cla_loss_neg = cla_loss[~positives].sort(dim=0, descending=True)[0][:int(n_pos*self.config['pos_neg_ratio'])]\n        self.cla_loss = self.config['multiboxloss_loc_cla_ratio'] * (cla_loss_pos.sum() + cla_loss_neg.sum()) \/ n_pos\n        return self.loc_loss + self.cla_loss\n\n","2bfeed91":"config = {}\n\nconfig['base_conv_conv_layers'] = [1, 16, 32, 64] \nconfig['base_conv_input_size'] = 32\nbase_conv = BaseConv(config['base_conv_conv_layers'], \n                     config['base_conv_input_size'], chosen_fm=[-2, -1],\n                     norm=nn.BatchNorm2d, act_fn=nn.ReLU(), spectral=False)\nbase_size = pretty_print_module_list(base_conv.module_list, torch.zeros([1,1,config['base_conv_input_size'], config['base_conv_input_size']]))","c7659557":"#define aux conv: aux_conv_input_size obtained from a chosen layer of base conv. Here I choose the last one, so channel=64, size=8\n\nconfig['aux_conv_conv_layers'] = [64, 64, 64]\nconfig['aux_conv_input_size'] = 8\naux_conv = AuxConv(config['aux_conv_conv_layers'], \n                   config['aux_conv_input_size'], norm=nn.BatchNorm2d, act_fn=nn.ReLU(), spectral=False)\naux_size = pretty_print_module_list(aux_conv.module_list, torch.zeros(base_size[-1]))\n","00092ea2":"#general config\nconfig['device'] = 'cuda' if torch.cuda.is_available() else 'cpu'\n\n#model config\nconfig['n_classes'] = 11\n\nconfig['fm_channels'] = [base_size[i][1] for i in base_conv.fm_id] + [aux_size[i][1] for i in aux_conv.fm_id]\nconfig['fm_size'] = [base_size[i][-1] for i in base_conv.fm_id] + [aux_size[i][-1] for i in aux_conv.fm_id]\nconfig['n_fm'] = len(config['fm_channels'])\nconfig['fm_prior_aspect_ratio'] = [[1., 2., 3., 1\/3, 0.5],\n                         [1., 2., 3., 0.5, 1\/3],\n                         [1., 2., 3., 0.5, 1\/3],\n                         [1., 2., 3., 0.5, 1\/3],\n                         [1., 2., 0.5], \n                         [1., 2., 0.5]]\n\nconfig['fm_prior_aspect_ratio'] = config['fm_prior_aspect_ratio'][:config['n_fm']]\n\nconfig['fm_prior_scale'] = np.linspace(0.1, 0.9, config['n_fm']) #[0.2, 0.375, 0.55, 0.725, 0.9] # [0.1, 0.2, 0.375, 0.55, 0.725, 0.9] \nassert len(config['fm_prior_scale']) == len(config['fm_prior_aspect_ratio'])\nconfig['n_prior_per_pixel'] = [len(i)+1 for i in config['fm_prior_aspect_ratio']] #in fm1, each pixel has 4 priors\n\n# training config\nconfig['checkpoint'] = ''#output_folder\/'checkpoint.pth'\nconfig['n_epoch'] = 40\nconfig['save_frequency'] = 20\nconfig['MultiStepLR_milestones'] = list(range(10, config['n_epoch'], 5))\nconfig['gamma'] = 0.5\nconfig['print_frequency'] = 1\nconfig['batch_size'] = 20\nconfig['iou_threshold'] = 0.5 #\nconfig['lr'] = 1e-3\nconfig['momentum'] = 0.9\nconfig['weight_decay'] = 5e-4\nconfig['pos_neg_ratio'] = 1.\nconfig['clip_grad'] = None\nconfig['multiboxloss_loc_cla_ratio'] = 0.25\n\n\nutils.img_size = base_size[0][-1]\n\nprint(config)","75062ac7":"# train data\ntrainset = MyDataset('..\/input\/objectdetectionmnist\/train.pkl', device=config['device'])\ntrainloader = torch.utils.data.DataLoader(trainset, batch_size=config['batch_size'], collate_fn=trainset.collate_fn, shuffle=True)","edc57329":"#visualize data\na,b,c = next(iter(trainloader))\nfig = utils.imshow_with_bbox(a[:4],b[:4],c[:4])","8d0acfae":"#create model\nmodel = SSD(config, base_conv, aux_conv).to(config['device'])","00e58aaa":"# create optimizer, scheduler, criterion, then load checkpoint if specified\nbias = []\nnot_bias = []\nfor name, param in model.named_parameters():\n    if param.requires_grad:\n        if 'bias' in name:\n            bias.append(param)\n        else:\n            not_bias.append(param)\noptimizer = torch.optim.Adam([{'params': bias, 'lr': config['lr']*2}, \n                              {'params': not_bias}], \n                             lr=config['lr'], weight_decay=config['weight_decay'])\nscheduler = torch.optim.lr_scheduler.MultiStepLR(optimizer, config['MultiStepLR_milestones'], gamma=config['gamma'], verbose=False)\ncriterion = MultiBoxLoss(priors_cxcy=model.priors_cxcy, config=config)\nplot_loss = []\n\n#load checkpoint\nif config['checkpoint']:\n    print('Loaded checkpoint')\n    checkpoint = torch.load(config['checkpoint'], map_location=config['device'])\n    model.load_state_dict(checkpoint['model_state_dict'])\n    optimizer.load_state_dict(checkpoint['optimizer_state_dict'])\n    scheduler.load_state_dict(checkpoint['scheduler_state_dict'])\n    plot_loss = checkpoint['plot_loss']\n","5b8d83ff":"training_progress_bar = tqdm(range(config['n_epoch']))\nepoch_progress_bar = tqdm(range(len(trainloader)))\n\nfor e in range(config['n_epoch']):\n    training_progress_bar.update()\n    epoch_progress_bar.reset()\n\n    mean_loss = 0\n    for img, boxes, labels in trainloader:\n        epoch_progress_bar.update()\n        # img: tensor [n, c=1, h, w]\n        # boxes: list[n] of tensor[n_object, 4]\n        # labels: list[n] of tensor[n_object]\n        loc_output, cla_output, _ = model(img)\n        loss = criterion(loc_output, cla_output, boxes, labels)\n        \n        optimizer.zero_grad()\n        loss.backward()\n\n        if config['clip_grad']:\n            utils.clip_gradient(optimizer, config['clip_grad'])\n        \n        optimizer.step()\n        mean_loss += loss.item()\n        # break\n    scheduler.step()\n    mean_loss \/= len(trainloader)\n    plot_loss.append(mean_loss)\n    \n    if (e%config['print_frequency'] == config['print_frequency'] - 1) or (e==0):\n        print(mean_loss)\n        print(criterion.loc_loss.item(), criterion.cla_loss.item())\n\n    if e % config['save_frequency'] == config['save_frequency'] - 1:\n        general_utils.plot_loss(plot_loss, output_folder\/'train_loss.png')\n        general_utils.plot_loss(plot_loss[-5:], output_folder\/'train_loss_tail.png')\n        torch.save({'model_state_dict': model.state_dict(), \n                    'optimizer_state_dict': optimizer.state_dict(),\n                    'scheduler_state_dict': scheduler.state_dict(),\n                    'config': config,\n                    'plot_loss': plot_loss}, output_folder\/'checkpoint.pth')\n    \n    \n","bd8b67c4":"# plot the training loss \ngeneral_utils.plot_loss(plot_loss, file_path='')","74225d23":"checkpoint = torch.load(output_folder\/'checkpoint.pth', map_location=torch.device('cpu'))\nmodel.load_state_dict(checkpoint['model_state_dict'])","3af521a1":"testset = MyDataset('..\/input\/objectdetectionmnist\/test.pkl', device=config['device'])\ntestloader = torch.utils.data.DataLoader(testset, batch_size=100, collate_fn=testset.collate_fn, shuffle=True)","2ed1d68e":"model.eval()\nimg, boxes_gt, labels_gt = next(iter(testloader))\nloc_output, cla_output, _ = model(img)\nboxes_output, labels_output, scores_output = model.detect_object(loc_output, cla_output, min_score=0.4, max_overlap=0.45, top_k=200)\n#plot detection in 4 samples\nfig = utils.imshow_with_bbox(img[:4], boxes_output[:4], labels_output[:4])","e7ffcc28":"# plot ground truth of those samples\n_ = utils.imshow_with_bbox(img[:4], boxes_gt[:4], labels_gt[:4])","8e3f4959":"all_boxes_output = []\nall_labels_output = []\nall_scores_output = []\nall_boxes_gt = []\nall_labels_gt = []\nall_difficulties_gt = []\n\nmodel.eval()\nwith torch.no_grad():\n    for images, boxes, labels in tqdm(testloader): #labels: list[n] of tensors[n_object]\n\n        loc_output, cla_output, _ = model(images) #loc_output: tensor[n,n_p,4], cla_output: tensor[n, n_p, n_classes]\n        boxes_output, labels_output, scores_output = model.detect_object(loc_output, cla_output, min_score=0.2, max_overlap=0.45, top_k=200)\n        \n        all_boxes_output.extend(boxes_output)\n        all_labels_output.extend(labels_output)\n        all_scores_output.extend(scores_output)\n        \n        all_boxes_gt.extend(boxes)\n        all_labels_gt.extend(labels) \n        # break\nall_difficulties_gt = [torch.zeros_like(i, dtype=torch.bool) for i in all_labels_gt]\n","a49287fb":"APs, mAP = utils.calculate_mAP(all_boxes_output, all_labels_output, all_scores_output, all_boxes_gt, all_labels_gt, all_difficulties_gt)","dccb8e11":"APs","65b4a601":"mAP","9c800a49":"# Import","44203731":"# dataset","5642cf5b":"# model","5d11eecc":"# eval","c289ce11":"# Object detection MNIST using SSD model\n![MNIST-object-detection.png](data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAADSIAAALpCAYAAAAdY7mbAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+\/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nOzdeZydBX3v8e9smSyQhSULa8IuiwaoIAUaIWBBLa5QLYhahLoVXFBsLd6orRcp1Wq91Vpcam2vVKuiIuAC3hZR9oBGlDUQtmwkJCFMkpk59w8LlQZ8ksBvzkzyfv+Xc04++b0mk5xznuf85ulotVoBAAAAAAAAAAAAAAAA+G062z0AAAAAAAAAAAAAAAAAMPxZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAYEPNTvKNJA8lWZPkgSSXJ3lxO4cCAAAAYGh0t3sAAAAAAAAAAABGhPOTvCfJfUm+lWRJku2THJzkhUm+27bJAAAAABgSHa1W62nvPLbzxKe\/EwAA2CjfH\/xqR7tnYOTzPg0AAJ493qfxTHmPBsCW5Pg3zc67PvvmfO+LP8rH\/+Qf0r+u\/0n3d3V3ZaB\/oE3TscXrKHxp\/1s+WzVsjdCvh\/doPFPeowEAwLPnt71H6xzKQQAAAAAAAAAAGFl6RnXnjX\/52iy8Z\/FTLiElsYQEAAAAsIXobvcAAAAAAAAAAAAMXwcd+9xMmjwh\/\/6338ng4GAOefFBmbH\/zlnbty6\/vPaO3PrT29o9IgAAAABDxCISAAAAAAAAAABPa+\/n75EkWdu3Lp+58a8z44BdnnT\/Lf\/vF\/nQiX+TR5asaMd4AAAAAAyhznYPAAAAAAAAAADA8DVx8oQkyUlnn5BWq5V3HHlu\/mDr1+X05747118+N8+dtW\/O\/bd3tXlKAAAAAIaCRSQAAAAAAAAAAJ5WR2dHkmSgfyAfeNlHM+\/Hv0zfo32Z\/\/N7M+eVf51FC5bkeS\/cL895wV5tnhQAAACAahaRAAAAAAAAAAB4Wo8ufzRJcsdN87PwnsVPum\/NY2tzw\/duTpLsc8geQz4bAAAAAEPLIhIAAAAAAAAAAE9rwa8eSJKs+q+FpP9p5bJf3z5qzKghmwkAAACA9rCIBAAAAAAAAADA07rphz\/L4OBgdt13p3R0dKx3\/\/T9dk6SPHT3oqEeDQAAAIAhZhEJAAAAAAAAAICntejeJfnpt2\/IlF23zyvOevGT7jv42Ofmd37\/eVm5bFWuu2xumyYEAAAAYKh0t3sAAAAAAAAAAACGpwuumJMk6entztq+tXnLx96QU859dR5b2ZdRY3oyYbvxSStZev\/D+dA339veYYFh5eyj57R7BAAAAAq4IhIAAAAAAAAAAOu54Io52X3m9CTJujX9ue2Gu7LkvqXpHTMq2+20TbaaOC4rlqzM7TfdnUeWrGzvsMCwsvvM6U8sMgIAALB5cUUkAAAAAAAAAACe0p1z57uqCcNfR0ddu9Wqa1cZBl8PS0gAAACbL1dEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAadbd7AADYGC96\/Qvzni+87bc+ZmBgMMf1\/OEQTQQAAAAAMHwc\/6bZOf602Zm+385JR7Lg1vtz6ed+mEs++4O0Wq12jwcAAAAAAIxwFpEAGFHunDs\/X\/rgvz3lfQcc8ZwcOPuAXHfpTUM8FQAAAABA+73vn8\/M7JOPzLKFy3PlV67KmtVrc9Axz81Znz4j+x62d85\/w6faPSIAAAAAADDCWUQCYES58+b5ufPm+U953yd+\/FdJku\/+4w+GcCIAAAAAgPY7\/OWHZPbJR+bBuxbm7Yf+WVYsXZkk6e7pzge+9u4ce+qsXH3xtbnqG9e2edJN0zVxQll73f4zSro9yx4r6SbJwLxflbUBoErX9tuXtfuet0tZ+3Of+0RZe8HAViXdv9ptZkkXAAAAkqSz3QMAwLNh+v67ZN\/D9sri+5bmmktubPc4AAAAAABD6vCXH5Ik+drHvv3EElKS9K\/rzz994KIkyQlvO74tswEAAAAAAJsPi0gAbBZecsYxSZLLPn9FBgcH2zwNAAAAAMDQ2mbqxCTJg3ctXO++x2874Mh90t3TPaRzAQAAAAAAmxeLSACMeKNGj8rsk4\/MQP9ALr3wh+0eBwAAAABgyD2y5NdXQZo6Y\/J6903bbUqSpLunO9N2W\/9+AAAAAACADWURCYARb9ZJh2XrSVvlusvmZvF9S9s9DgAAAADAkLvmuzckSV71zj\/I1pO2euL2ru6unDrnpCd+vdVv3AcAAAAAALCxuts9AAA8Uy85\/ZgkySWf\/X6bJwEAAAAAaI8ffeXqHHPKrDz\/uJm5cN7Hc\/W3rsu6vnU5cPYB2WbapCy8Z3Gm7Lp9WoOD7R4VAAAAAAAYwVwRCYARbdd9d8p+h++TRQuW5Nrv3tTucQAAAAAA2mJwcDDnnnBeLnzfl\/PI4hV50amzcuyps3L\/7Q\/mHYe\/P6tXPpYkWb5oRZsnBQAAAAAARjJXRAJgRHvJGccmSS77\/BUZ9JM8AQAAAIAt2ED\/QC46\/+JcdP7FT7q9p7cnO+45LcsXr8hD8xe1aToAAAAAAGBz4IpIAIxYPb09mX3K72WgfyCXfe6Kdo8DAAAAADAsHfWawzOqtydXfuWqdo8CAAAAAACMcBaRABixZp14WMZvs1WuvfSmLL5vabvHAQAAAABoq7Fbj1nvtt2fNz2nn\/+6rHh4VS4675ttmAoAAAAAANicdLd7AADYEBdcMWe923afOT1JMnX69k95P8BQOPvoOe0eAQAAANjCPX58dI+DZqQ12Erfo30Z6B\/M6HG9Gb\/N1hkcHMzdP7s3f\/YvZ7V30Gego7vutObguNEl3c7+wZJukrQeXV3WHi4cdwMAAAAAGJ5cEQmAYe+CK+Y8sXT0uN6xo7LVxHFZ27cuK5auas9gwBZv95nTLUICAAAAbfWbx08fWbwinV2dmTRlYrbfeduMHjc6Sx9cll9dd0cefWTzX1xh8+G4GwAAAADA8OWKSACMCHfOne+nHwLDjg9DAAAAAMPBlnD8tGvihLL2uv1nlHR7lj1W0k2SgXm\/KmsPB467AQAAAAAMX66IBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANOpu9wAAMKJ0dNS1W62SbOe4cSXdJBlcvbqsXfX1GKk6envL2o++eGZZe+GhNXvvU386UNJNkjHfvLasDQAAAMCmueN9+5a1bzv10yXddz94UEk3SX756l3L2v1331PWBuDZ0zV+fFn7oZP3K+neeG7Nc269rcrKu3QPlnS7d925pJsk\/fcsKGsDAAAwMrgiEgAAAAAAAAAAAAAAANDIIhIAAAAAAAAAAAAAAADQyCISAAAAAAAAAAAAAAAA0MgiEgAAAAAAAAAAAAAAANDIIhIAAAAAAAAAAAAAAADQyCISAAAAAAAAAAAAAAAA0MgiEgAAAAAAAAAAAAAAANDIIhIAAAAAAAAAAAAAAADQyCISAAAAAAAAAAAAAAAA0MgiEgAAAAAAAAAAAAAAANDIIhIAAAAAAAAAAAAAAADQyCISAAAAAAAAAAAAAAAA0MgiEgAAAAAAAAAAAAAAANDIIhIAAAAAAAAAAAAAAADQyCISAAAAAAAAAAAAAAAA0MgiEgAAAAAAAAAAAAAAANDIIhIAAAAAAAAAAAAAAADQyCISAAAAAAAAAAAAAAAA0MgiEgAAAAAAAAAAAAAAANDIIhIAAAAAAAAAAAAAAADQqLvdAwAAAAAAAAAAAACw+Tv+TbNz\/GmzM32\/nZOOZMGt9+fSz\/0wl3z2B2m1Wu0eDwCADWARCQAAAAAAAAAAAIBS7\/vnMzP75COzbOHyXPmVq7Jm9docdMxzc9anz8i+h+2d89\/wqXaPCADABrCIBAAbo\/AnrwzOOrCk2\/PBh0q6STL4wkfL2p0z9y1r33fsxJLuozsNlnSTZOaBd5a137PjhWXt2WMGSroHLH1rSTdJxpSVAQAAADZvK1\/zgrL23FM+Udb+0oodSrrf+PnMkm6S7HnhorJ2ZtelAYaljo6ydNc+e5S1v\/vDr5a1B1o\/KuqWZJMk\/9lX9xGoN\/7wtLL2c865o6Q7sGxBSRfgmTj85Ydk9slH5sG7Fubth\/5ZVixdmSTp7unOB7727hx76qxcffG1ueob17Z5UrZUXXvXvXZbdtB2Jd0V0ztLukky6baaz\/wkyYTrHyhr99\/jdRDAUKh7BgIAAAAAAAAAAABgi3f4yw9JknztY99+YgkpSfrX9eefPnBRkuSEtx3fltkAANg4FpEAAAAAAAAAAAAAKLPN1IlJkgfvWrjefY\/fdsCR+6S7p+4qdwAAPDssIgEAAAAAAAAAAABQ5pElv74K0tQZk9e7b9puU5Ik3T3dmbbb+vcDADC8WEQCAAAAAAAAAAAAoMw1370hSfKqd\/5Btp601RO3d3V35dQ5Jz3x661+4z4AAIYn17AEAAAAAAAAAAAAoMyPvnJ1jjllVp5\/3MxcOO\/jufpb12Vd37ocOPuAbDNtUhbeszhTdt0+rcHBdo8KAEADV0QCAAAAAAAAAAAAoMzg4GDOPeG8XPi+L+eRxSvyolNn5dhTZ+X+2x\/MOw5\/f1avfCxJsnzRijZPCgBAE1dEAgAAAAAAAAAAAKDUQP9ALjr\/4lx0\/sVPur2ntyc77jktyxevyEPzF7VpOgAANpQrIgEAAAAAAAAAAADQFke95vCM6u3JlV+5qt2jAACwASwiAQAAAAAAAAAAAFBq7NZj1rtt9+dNz+nnvy4rHl6Vi877ZhumAgBgY3W3ewAAAAAAAAAAAAAANm\/nfe\/crH1sbebPW5DVKx\/LLvvsmENfclDWPLY2Hzjho1n64LJ2jwgAwAawiAQAAAAAAAAAAABAiQuumJMkmbDd1pk4eUL2P2KfdHR2ZN2a\/ixftCKL7l2cU+ec1N4h2eJ1jF3\/il3PlnVb9ZR0B0aXZJMk3Y8VtleuKWu3+uraw8XZR89p9wgAFpEAAAAAAAAAAAAAePZdcMWc7D5zeu6cOz+LFyzN4gVL2z0SwIi1+8zpueCKOZaRgLaziAQAAAAAAAAAAABAiTvnzveheYa9rr33KGsvO2i7ku6K6Z0l3SSZdNtAWXvC9Q+UtfvvWVDWHg4ev8IcQLvVPQMBAAAAAAAAAAAAAAAAmw2LSAAAAAAAAAAAAAAAAEAji0gAAAAAAAAAAAAAAABAI4tIAAAAAAAAAAAAAAAAQCOLSAAAAAAAAAAAAAAAAEAji0gAAAAAAAAAAAAAAABAI4tIAAAAAAAAAAAAAAAAQKPudg+wMbbeZqsc8YpDcsiLD86MA3bJdjtuk\/61\/bn7Z\/fm8i9emcu\/cGVarVa7xwQAAGAL9qbzTs5eB++eHfealgnbjc+ax9Zm0T2L8+OLr83Fn7osKx9e1e4RAUYExwIBAAAAAABgaDlHB2yIEbWINOvEw3LWp8\/I0gceztwr52XRgiWZNGVCjnjFoXn3hW\/J8487MB8+6W\/aPSYAAABbsFe+46W548a7cuMPbsnyRSsyelxvnnPonnn9nD\/MS04\/Nmce9udZfN\/Sdo8JMOw5FggAAAAAAABDyzk6YEOMqEWk+257MOeecF6uueTGJ21Sfv7P\/28+dc3\/zu+9+gU54pWH5qqvX9PGKYefju6av+aunXYo6SZJOjrK0gPbbl3WTtWGb+HXo3PBorL2wMK6NmyOtv7wfSXdr+\/x\/ZJukhz1\/ZeVtd+y6yVl7YN77y\/pfnn5ISXdJDliq1+VtWePGShrz7jk9JLu3p+8oaSbJH5eB\/C47mlTN+n3vWqf92Tdmv71bn\/9OS\/Na878\/fzRh0\/O+6+7\/pmO95T6JpdkkyQDo+r+h5xwe1k6285dUdJt3TSvpAv8N8cCh59HTnlBWXtgVM3xr8mX31PSTZL++x8oawNU6p6+S1n7W39d9wGEJYN170n++fQ\/KOnuOq6rpJskl3\/+O2XtFx5fc0wvSXovva6sDbCpdr+2t6z9dztcVNZOOsvKZz1wWEn3jjP2KOkmSX5Wdy5tr\/6656+6s3QA0D6do0eXtW\/\/y5ll7ZmH3lHW\/shO\/1LSndlb91r2x32DZe0333xKWXvHD+1X0t2Szg+3+xzdpn5WY0Pc9s4ZZe0Tj\/1xWfsjU24p6f5HX0k2SfK2z7y1rL3D+VeXtdlwdUclCsy98uf56XduWO9ybssWLs93\/uF7SZLnvbDmCQQAAAA2xFMtISXJf3z7piTJDjO2H8pxAEYsxwIBAAAAAABgaDlHB2yIEbWI9Nv0r\/v1zwgZ6PezQgAAABh+Dj12\/yTJ3be6egLAM+VYIAAAAAAAAAwt5+iAx3W3e4BnQ2dXZ4593awkyfWXzW3zNAAAAJC86k+OzuhxvRk3fkz2fO4u2f\/Q3XPXL+7PVz\/1\/WTW5HaPBzBiORYIAAAAAAAAQ8s5OuA3bRaLSG867+TMOGCXXHPJjbn+eze3exwAAADIK988O9tMHv\/Er6+74hf52Du\/nEceXpXEIhLApnIsEAAAAAAAAIaWc3TAbxrxi0gv\/9Pjc+K7T8i9t96Xj576d+0eBwAAAJIkJx\/4\/iTJxO22zr6\/MyNv\/PMT8qnLz8n\/ev1n8kCbZwMYqRwLBAAAAAAAgKHlHB3wP3W2e4Bn4mVvOy5v+8QfZ\/68BTn76A9m5bJV7R4JAAAAnmT5kpW5+rJb8v7X\/p+MnzQ2Z3\/ide0eCWBEciwQAAAAAAAAhpZzdMBTGbGLSK8468V5+9+dlrt\/dm\/ec\/ScLFu4vN0jAQAAwNNadP+y3Hv7Q5m+zw6ZOG50u8cBGFEcCwQAAAAAAICh5Rwd8HS62z3ApvjD974sbzrvlNxx090550UfzoqlK9s9EgAAADTaZsqEJMnAYKvNkwCMHI4FAgAAAAAAwNByjg74bUbcFZFO\/otX5U3nnZLbrr8z7z3mQ\/5TAwAAYNjYcbftM3br9a921NHRkdef89JM2n585l13V1Y+tqYN0wGMPI4FAgAAAAAAwNByjg5oMiKuiHTBFXOSJJOmTMguz9kprVYrk6ZMzN\/f8NH1Hru2b12WPeSyb0\/S0VGT7R1V0v2velm51dNV1h6JOtasLWu31q4raw8XZx89p90jAAAwDHz0q2cmSbabNjFTd9k2j67sy9q+dRnoH0h3T1fGTRiT3tGjsm5tf7q7u3LhWa8umWOwpyT7a4U\/yqRrdV27Z9VATXjVozVd4AmOBQ4\/\/VPGl7VbRc8zo07rqwknaRUeV2PTOV4HAAAAAACb5oIr5rT9HF3HqLrPp6\/eef0fLPtsmTzpRWXtjlE1n0+YOViSTZJ84Ywdytq9x9V9rbcEz9a5tGG\/iHTBFXOy+8zpuXPu\/Iwa8+v\/WDo6OrL9zts+5eNXLX\/Uhw+AIbH7zOm54Io5PtwAALCF++hXz8xu++2Yu+bdn5WPrM6oRT0ZN35MxozrTVd3ZwYHBrOmb10WLliaJQ8uz0D\/YLJV3cEtgJFs\/yP2SZL8\/KpfOhYIbDTH6wAAAAAAYNM8\/pn9Vct\/vfTiHB1sfp7Nc2nDfhEpSe6cO9+Jw2ego7vmr7lrp7pNxaqrOCXJwLZbl7XTatV0C78enQsWlbUHFta1h4PHr9YGAAB3zbs\/55z4yQ1+\/AOv2K1kjr7JJdkkycCoovc7SSbcXpbOtnNXlHRbN80r6cKW7hsPfzGJK5oMV4+c8oKy9sComuNfky+\/p6SbJP33P1DWZtM4XgcAAAAAAJtuOHxmv3va1LL2be+cUdY+8dgfl7U\/MuWWku7cvpJskuRtn31rWXuH868ua2\/uns1zaZ3PWgkAAAAAAAAAAAAAAADYbFlEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGnW3e4BnXUdHWbr\/qIPK2vudf0tZ+53bX1nS\/eLyQ0u6SfKv855f1h7or9u\/aw3UfP9tP3lFSTdJrj3we2XtI878k7L2uK9dU9ZmiGzK\/9cb+ntarY1vb6BlbzisrP13u15QVB5X1E2u3O\/isvYB1\/xRWXvq3\/aWdFuFr0Nu\/tCOZe2+Hf6zrP2cjy0v6Q6sWVPSBXiS3lEb9rjOjo17fJKvnXP+JgzU7MSbTyvpJklXZ91rrIH9655Dd3vrPSXdS687pKSbJHt\/fnVZu3X9z8vawIbrHDu2rH37P+5d1r5l1ifL2mM7N\/x5dGO84NWvLukmyYQXl6UBSt36rmll7e266o5F7vUfp5a1Z\/znTSXdjmMOLukmyX39q8raX\/jMx8vab971iLI2sPmb\/+Ga83Tf2qHuvU5XR09Z+6g\/Pr2sPeqy64rK84q6ALABCj\/TUflZpUrLT615fdX6wyUl3SS548DPlLVr1XxWaV1roKSbJIeP7ipr\/+zQfy1r7\/aGN5d096w5fDSi9c+uOfb17n\/4Ukk3SV40dl1Z+633v6Csvdu\/13we+0cv+5uSbpJcf9YnytoHdZ9V1t7pI1eXtTc3rogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA06m7bHzx1ygY9rmPUqI16\/E7fWrHJMzW59ou9Ze3bDq\/bCXvzmiPK2lV2y9x2j7DF+NIvtytrrxlf9309rqzMkGm1yn5P9847bXx7A\/3un15X1t6rp+Y7+7OP7FDSTZIvzjmhrL3zD28vaw8sWVrTPeqgkm6SvGOn75e1\/\/gbby5r737rT8vaANX659+7QY9r9a3ZqMcnyRvPfNcmzdRkyg\/mlXSTpNXfX9bu3G2Xsvb1hxxY0u08tq+kmyT7\/MMvy9rfvfywsvaM9xc972\/Kewe2LB0dZenOMWNKuvtf9VhJN0kunfqFsva1a+q+1qff\/NqS7k9+559Kukny6u2OL2tXvW8FSJLWqLrXV8sGVpe19zh3VVl7oKjbe81tReXk\/EVHlbU\/uUPdcXBg89c9bWpZ+1enfbqo3FPUTX7vrWeUtcdcdm1ZO51dNd3BqmfdWl1771HWXrnvtiXdcffWvXZq3VB3HBogSd0x38rzDYccUJa+9z1l6Xz8wM+XdI8bu6akmyQDrcGydlfHyLu2Q09H0eu2EezrJ3yipHv63HeUdJNkmy\/8pKxd6e6X16whPL\/3kZJukuz3k9PL2ju9qu518p65pqQ7q\/edJd0kuful\/1jW\/tLpf1vW\/vOPHFLW3tyMvGdNAAAAAAAAAAAAAAAAYMhZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABp1t+sP7l+0ZIMe11q3bqMef98rp27yTE2mLLy+rN1at7aszcg3\/8OHlbWPG3dBWftfPv+Tsjb8NnecsXNZ+5Jp3ylrn3bvESXdB984raSbJFv\/8pqy9kCrVdbuHD26pDv\/6N6SbpIc2ruurD3+9o6yNgBPbczF15Z0B0uq9QZuvb2sPamovd03xpd0k+SGYw4uax\/1vrll7f9YW\/PedZcP1b3mzOBAXZuhU\/je4Z4v7VbSvXTql0u6SfKehw4sa\/\/8DXuXtXfsqzk+OvZHo0q6SfLgSXVfj8l\/f3VZG6B7eVdZ+z\/7titrD9x+V1m7SsfYMWXtST0Pl7XXtOqORQKbv1+9a0a7R9hov\/\/y15W1x1xbcxwwSVqHPa+s\/cDvjSvp3nDmJ0q6SdLb0VPWTuqOqY1Ev7\/DzHaPAGzuio75rjrx0JJukhz1\/rrjeZdP\/llZu8rqwbrPw47trDvm+8jgY2Xt9z5wdEn3+gvrnpc7Ck8+f\/B9Xyhrv2RsTXf5sXXfH9vUfTlK7fmnNedxTwf1cyUAACAASURBVPz620u6SbLTlTeWtUeiGf9W+A\/9pXXpg3vrngu6pkwu6Q4sXFTSbSdXRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAaWUQCAAAAAAAAAAAAAAAAGllEAgAAAAAAAAAAAAAAABpZRAIAAAAAAAAAAAAAAAAadbftTx4c2LDHtVob9fj+++7fxIHgmevcf5+S7sde+4WSbpK88cjXlrWTewvb8PRmHF73vbdqsK+sff9bdi3ptm6dV9IdyTq2GlfSfemLrynpJslVfaPL2tvPfbSsDQCbq4EVK8raY79e95riF61Dy9rPO\/uXJd2Hv7d\/STdJOq6+uazN5mGbrVaXdN\/z0IEl3ST5+e\/2lrUH+2r+nY9Ub\/nTb5a1\/\/3vJ5e1gRGko6Pk8ZMOWLIJw2yYc+a+qqy9S35W1i6zZk1ZelV\/3XN+b0dPWRvY\/HXuPPLOOVz+zX8uaz\/\/L95S1j7t7G+Vtd88seazNwOtrpJukiwZqPve+8W6mnOLSXJo77qSrudzYCTr2mNGSXfbt99T0k2Sv5xc9551TavmuSKpe74Y2zmqpJskB99wUll7\/KfGl7XH3rygpLvdQz8p6SZJ\/+yDy9o3rZ5e1n7J2JpzGS\/c\/faSbuKTtv9T15U3tnuELUZHq90TbJrVg2vL2gMLF5W1NzeuiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA0sogEAAAAAAAAAAAAAAAANLKIBAAAAAAAAAAAAAAAADSyiAQAAAAAAAAAAAAAAAA06m73ADDUOrrrvu3v+3DNbt+7LnpjSTdJpt\/z07I2tM0525SlT\/rVi8rarRXzytojUkdHWfqx39mtpPs30\/6xpJskM759ell7r59eV9YGAIaXcd++oay9418MlnTvn7pnSTdJxpaVGVKF7x3GHXdXSfeWkurj+krr\/LeJXY+2ewRgc9dqlTy+1ap77lzzkFdYv6lj9Oiy9t5jby9rX7K6bm5gmNiU91Eb+HtmvKbuHc8P7+wq6c4eM1DSTZLr\/vLTZe2BVs2xmCRZt7GvQzZQT0fN32GSPFz35cif3fbKsvZ39vtySbe3q6ekCzAU7jlpWkl33p5\/X9JNap+Xezvq\/k\/\/7CM7lHQ\/88mXlXSTZOpXbytrDyypa7f22r2ke8c5M0q6SfKtV3y8rL3fqDFl7X9ZuW1J95ZPPbekmyQT85OyNvw2D+\/T2+4RNsl7HzyysL6msL15cUUkAAAAAAAAAAAAAAAAoJFFJAAAAAAAAAAAAAAAAKCRRSQAAAAAAAAAAAAAAACgkUUkAAAAAAAAAAAAAAAAoJFFJAAAAAAAAAAAAAAAAKCRRSQAAAAAAAAAAAAAAACgkUUkAAAAAOD\/s3fncV4XdOLH33MBM8Bwi6EgMigpmZh3ahpl5hG2almp2WEe2+5aidbWbwt3a3+rYq6VP7XVzNKtje7DVTeJ8kxIISQVAfFAMA455wBm5veHq0VSnxnyzWeO5\/Mvne\/n++L9GIbv\/Z4PAAAAAAAAAEAhi0gAAAAAAAAAAAAAAABAIYtIAAAAAAAAAAAAAAAAQCGLSAAAAAAAAAAAAAAAAEAhi0gAAAAAAAAAAAAAAABAIYtIAAAAAAAAAAAAAAAAQCGLSAAAAAAAAAAAAAAAAEAhi0gAAAAAAAAAAAAAAABAIYtIAAAAAAAAAAAAAAAAQCGLSAAAAAAAAAAAAAAAAEAhi0gAAAAAAAAAAAAAAABAIYtIAAAAAAAAAAAAAAAAQCGLSAAAAAAAAAAAAAAAAEAhi0gAAAAAAAAAAAAAAABAIYtIAAAAAAAAAAAAAAAAQKHqsgeAnW3pPx2S1t576JKUbstnfpfShZ6qffb8tHZrWplXqMjbl37uqJyHQC3tW1K6ERHD5njYBgD89doOfV1i\/bcp1Zr1W1O69CDt7WVPwKuhsqrsCTqtrd3v+QK6p41zhqe1v3bWdWntf7zv3LR23e9zXtfb\/KlVKd2IiHMHPZfWPmD2e9Lau8RjaW2gE3bkeVQXeO51ecN+Kd3r7xmW0o2IuGz0j9LaY6rr0trd0Z7V\/dLas\/abkdaO6JvYBkjUmdfzKio6dZ3mfZp2YKByVSV+xuWataPT2j877fCU7ojf3Z\/SjYiICePT0s+eOyGtfeWHbkzpvrl2Y0r3Rd3zs0oPbdwjpTvksbzvdfnPtnqP9sP3T2vv95W8z60eVb8wpbtfn3tSui8akFY+Z\/iv0tqfHn5CSrd11eqUbpm8UwoAAAAAAAAAAAAAAAAUsogEAAAAAAAAAAAAAAAAFLKIBAAAAAAAAAAAAAAAABSyiAQAAAAAAAAAAAAAAAAUsogEAAAAAAAAAAAAAAAAFLKIBAAAAAAAAAAAAAAAABSyiAQAAAAAAAAAAAAAAAAUsogEAAAAAAAAAAAAAAAAFLKIBAAAAAAAAAAAAAAAABSyiAQAAAAAAAAAAAAAAAAUsogEAAAAAAAAAAAAAAAAFLKIBAAAAAAAAAAAAAAAABSyiAQAAAAAAAAAAAAAAAAUsogEAAAAAAAAAAAAAAAAFLKIBAAAAAAAAAAAAAAAABSyiAQAAAAAAAAAAAAAAAAUsogEAAAAAAAAAAAAAAAAFLKIBAAAAAAAAAAAAAAAABSyiAQAAAAAAAAAAAAAAAAUsogEAAAAAAAAAAAAAAAAFLKIBAAAAAAAAAAAAAAAABSyiAQAAAAAAAAAAAAAAAAUqi57ANierZMPTGv\/9wcuT2tfcOr5SeUVSV2ArqtqyKC09n5veiKl+92Nu6Z0IyJG3Dovrd2WVgYAdkTzOw5Jax80bU5ae\/3W2pRua21VSjcioiatDHRW1bChZY\/QaUOrNpY9AsAOGXfTM2nttWfUpbVnXDY9rf18a5+U7orW+pRuRMS9zXmv6q1bl\/f3uEtaGWDHrTtydVr7\/DgyrQ0ApWpr7fix7e2duk7\/h3Peb3jhmMaUbkTEkKq851GPN+Z9FuWpk4endPe4Ju+101vHfyOtnfn32NK+Ja3Ntt44cFFK94E9897DHTA7LZ2roiIlu\/Dag1O6ERFPTvlqWvtXzWnp+MA9H0rp\/uqYL6V0IyK2tHfisUInrW7Lu70+4965Kd2vnzMlpRsRUXn3w2ntv\/jnlvKnAgAAAAAAAAAAAAAAAN2KRSQAAAAAAAAAAAAAAACgkEUkAAAAAAAAAAAAAAAAoJBFJAAAAAAAAAAAAAAAAKCQRSQAAAAAAAAAAAAAAACgkEUkAAAAAAAAAAAAAAAAoJBFJAAAAAAAAAAAAAAAAKCQRSQAAAAAAAAAAAAAAACgkEUkAAAAAAAAAAAAAAAAoJBFJAAAAAAAAAAAAAAAAKBQddkDAAAAAAAAAADQNTVMGhvTZ04rewygm2mYNDYWz11a9hgAAAAkcEYkAAAAAAAAAABeYerkaRYJgB2yeO7SmDp5WtljAAAAkMAZkQAAAAAAAAAA2C6LBAAAAAD8MWdEAgAAAAAAAAAAAAAAAApZRAIAAAAAAAAAAAAAAAAKWUQCAAAAAAAAAAAAAAAACllEAgAAAAAAAAAAAAAAAApZRAIAAAAAAAAAAAAAAAAKWUQCAAAAAAAAAAAAAAAACllEAgAAAAAAAAAAAAAAAApZRAIAAAAAAAAAAAAAAAAKWUQCAAAAAAAAAAAAAAAAClWXPQDd19qzDk9r3\/dv16S1J5\/3ibR2vzkPprUBepvfv3NCWntOw7Up3T1vOyelGxGxd+OctHZUVOS129vz2gBAp\/3w7kPS2u2VOff7+170dEo3ImLJpDemtUd\/4ddp7WhrzWsDHXbhw+9Ja4+J+WltgK1PPZPWvvrv8m4bl56S9xpWRW3O46uGr7aldCMiWv5pXVq7sspregAAQHlGf2tJSvc9J747pRsRccc+P01rf2nU7LR2\/H1iO8mW9r6Jbe+\/\/LG+FTVp7V81p6XjX688I6U7\/Dv3p3TTVVZ1\/NiXPkPW0eskvWd5x\/FXpXQjIk5aeFpau23KprT2PsNWp3TbfpmSjYiIr64bm9b+2amHpbUH37AqpXvTrV9O6UZEfHjMkWntv8QZkQAAAAAAAAAAAAAAAIBCFpEAAAAAAAAAAAAAAACAQhaRAAAAAAAAAAAAAAAAgEIWkQAAAAAAAAAAAAAAAIBCFpEAAAAAAAAAAAAAAACAQhaRAAAAAAAAAAAAAAAAgEIWkQAAAAAAAAAAAAAAAIBCFpEAAAAAAAAAAAAAAACAQhaRAAAAAAAAAAAAAAAAgEIWkQAAAAAAAAAAAAAAAIBCFpEAAAAAAAAAAAAAAACAQhaRAAAAAAAAAAAAAAAAgEIWkQAAAAAAAAAAAAAAAIBCFpEAAAAAAAAAAAAAAACAQhaRAAAAAAAAAAAAAAAAgEIWkQAAAAAAAAAAAAAAAIBCFpEAAAAAAAAAAAAAAACAQhaRAAAAAAAAAAAAAAAAgEIWkQAAAAAAAAAAAAAAAIBCFpEAAAAAAAAAAAAAAACAQtVlDwAAAAB\/ziEnvCFO+YcTYsy+u0f9sIGxZvkL8cRvlsR3r\/ppPPrAwrLHAwAAAAAAAAAA6FUsIgEAANAlnfNvZ8Tpl7wz1q1aH\/f9aHasW7UhRjXsGoeffHAceeqhcfnZX4m7br277DEBAAAAAAAAAAB6DYtIvUD74fundO\/8v19M6UZE7P\/li9Lau\/30vrQ2O09VfX1Kt3X9+pQu0Hlr39KU1m5p35LSHXVHVUo3XXt72RMAvMKQkYPjtIumxJoVa+O8\/S+KtSv\/8Dht\/2MmxvSZ0+LsS0+3iER5KirS0v1+8mBae\/xP0tJpGt92UFr7HZflvUbw\/YGHp7XHXXJ\/Tjjx59pjToq07zai7BE6rW3hgLJHANgxiff5fe6Yk9aeMLNPWruiqjKl29bcnNKNiFi9cWJaGwAAoExbl69I6a7+Vt7r9td8YnRa+5QBj6a1a5JeIxhe1T+lGxHR2L45rT2osjatvSXpbZLKSHxvJ9EFD5+R1t79+qT30bqrttaOH\/vS+3kdvE7bXTm3fXvX5N2GtJ6wLq3d1tiY1n7yq2NTumOq897r+uG5b0lrVz46N629+oic7t\/98tSccEREPJ\/Y\/vNyXlUHAACAv8LIPYZHVVVlPPbrJ7ZZQoqImDdrQWxa3xiDRuQspwMAAAAAAAAAALB9FpEAAADocpY9sSI2t2yJCYeMj\/phA7e5bL+j9on+9XXx0M\/nlzQdAAAAAAAAAABA71Rd9gAAAADwpza8sDFu+NQtcf6VZ8cNC66K+340O9av3hCjxo2Mw6ccFL+5c15cff71ZY8JAAAAAAAAAADQq1hEAgAAoEv6wdW3xfNLV8ZFN\/5tnPiRt7789WVPLI87bp4Va1euL3E6AAAAAAAAAACA3qey7AEAAABge9598ZT47IyL4s6bZ8VZDR+Nk\/qfERcceEksX\/J8fPrWC+Ocy84se0QAAAAAAAAAAIBexSISAAAAXc7rj943PnLZWXH\/j+fE9RfdHCue\/H20NG2ORQ8\/GdNOuSJWPrs6TvvEO2LXPXcpe1QAAAAAAAAAAIBewyISAAAAXc5hJx0YERFzZz3yistamjbH4w8uiqqqyhh\/wJ47ezQAAAAAAAAAAIBeyyISAAAAXU5N35qIiBg8YtB2Lx80oj4iIrZu3rrTZgIAAAAAAAAAAOjtLCIBAADQ5cy\/+9GIiDjhI2+NYaOGbnPZwW+fFBOPmBAtTZtjwX2PlzEeAAAAAAAAAABAr1Rd9gAAAADwkukzp7383xvWbIyhuw6OW5f+v1i3akNs3bw1+tb1ifphA6OioiJWPbs6PvfdqeUN+78aJo2NiG1nh55g6uRpZY8AAAAAAAAAAEAX44xIAAAAdAnTZ057eaknImLJ\/Kdi2aLl0dzYEoOGD4wRo4dFXX1dbFizMRbPWxqrlq0pb1jo4RomjbVcBwAAAAAAAADAKzgjEgAAAF3G4rlLu91ZWF5a1uhuc\/NXqqjIa7e357U7yBISAAAAAAAAAADb44xIAAAAAAAAAAAAAAAAQCGLSAAAAAAAAAAAAAAAAEAhi0gAAAAAAAAAAAAAAABAIYtIAAAAAAAAAAAAAAAAQCGLSAAAAAAAAAAAAAAAAEAhi0gAAAAAAAAAAAAAAABAIYtIAAAAAAAAAAAAAAAAQCGLSAAAAAAAAAAAAAAAAECh6rIHAAAAAACgPEedeli8\/uh9o2H\/sTFu\/z2if31d\/PyWX8Vl7\/9y2aMBAAAAAAAA0MVYROoF1u5dl9L9xLPHpnQjInb7t\/vS2qkqq1KyT\/\/XvindiIirD\/h2Wvtf\/\/4Dae3aXy5IawNdw\/ffeF1a+4Z1e6V0B8z4dUoXADqq5cSD09p7\/tNjae2GupVp7dsvPTql2\/97iff7FRV57fb2vHbS3DV3zknpRkTMX9qQ1v7hnV9Ma5\/34MdSuv2\/6\/HszlJZl\/N6XUREW1NTp69zxmdOjYZJY6NxQ1OsenZ19K+ve\/Hf9J\/8u66srX21xnyFxe8ZlNJd19b570dHNfz7orR2a3e9LwC6h256O9C+ZXNiO6db0bdvTjgiDtnt6bT23YvHp7UBAADKMuyG+9PaP5mb835URMTVp52U1t4yZGtK98Q3\/DalGxHRtzLpSXxEXL5r3ntSbdGW0q2MnM+sRkRcujLvc6tj\/jnn+xERSd9ptues3fJuV7NsOH6\/tPbA2x9Jay980zdSur\/d3JzSjYiovGduWjtV0i5A09HPp3TLZBEJAAAAAKAXu\/aim2PVs6tj2aIV8fqj940rZ04reyQAAAAAAAAAuiiLSAAAAAAAvdi8Wc48DQAAAAAAAEDHVJY9AAAAAAAAAAAAAAAAAND1WUQCAAAAAAAAAAAAAAAACllEAgAAAAAAAAAAAAAAAApZRAIAAAAAAAAAAAAAAAAKWUQCAAAAAAAAAAAAAAAACllEAgAAAAAAAAAAAAAAAApZRAIAAAAAAAAAAAAAAAAKWUQCAAAAAAAAAAAAAAAAClWXPQAAAAAAADvf9Ls+FxER9cMHxqDhAyMiorrPiy8ZH3XKofGGt7wuIiK2bmmN5Yufj6jK+71WzXsMSOkOGHZ4Sjci4vLvD0trt2\/ZktbuyRomjY3Fc5eWPQYAAAAAAAD0aBaRAAAAAAB6mel3fe7lpY3aAf1i6K5Dtrm8b22f6FvbJyIiNjdvfnERCbq42gH9omHS2LLHAAAAAAAAgB7NIhIAAAAAQC+0eO7SmPqWSzt8fGVtbd4sn90\/pTv7zC+mdCMiLjllSlq7ddWqtHa0t+e1S\/aDNV8vewQAAAAAAADo8SrLHgAAAAAAAAAAAAAAAADo+iwiAQAAAAAAAAAAAAAAAIUsIgEAAAAAAAAAAAAAAACFLCIBAAAAAAAAAAAAAAAAhSwiAQAAAAAAAAAAAAAAAIUsIgEAAAAAAAAAAAAAAACFLCIBAAAAAAAAAAAAAAAAharLHgBgew47eFy8a8qBsceY4TFoYL9Y\/cKmeHzRivjOD+bEgseeK3s8AAAAAAAAAAAAAADodSwiAV3O+R88Ot532qGxdl1j3PPAoli3vjF2e82QOPLQveLoN06IL3zxZ3HPLxeUPSYAAAAAAAAAAAAAAPQqFpF6gSE335\/SffbmlGz31taakh3zrvkp3YiIK2NiWrtvzO70dYaMHByn\/3hqrFmxNs7b\/6JYu3L9y5ftf8zEmD5zWpxzysHxq0v8AFKO6nFj09q\/++SIlO7Uo25P6UZELN88OK39rls+ntYec0dzSrcyHk7pAtDzrPng4Sndb0+7IqUbEdFQMyCv\/e3z09rfmf6llO4nV+fNXDXrobR2qvb2sifotNaFi9Paf\/Ofn0hrjzp3eU74uznZ7qxqyJCU7rKbdk3pRkTMO+RbHTquYujGiIi4Y1nHn8ccdnHebd9BRz2W0v3i6oNSuhER644Zl9YeMGNlWjsqKnK63fB+ACBb5cC851FvGLgorX13jE9rAwAA9ETtcx5Ja+85Jy2d5onE9oof7pPWrnpN4nt0SS+fLtyS8xmoiIifXn10WnvovJzPNbNzvb9+VdkjdFr9\/LyZR\/+iLa2d5aKzL0hrd9vPUibtAvRElWUPAPDHRu4xPKqqKuOxXz+xzRJSRMS8WQti0\/rGGDSivqTpAAAAAAAAAAAAAACg97KIBHQpy55YEZtbtsSEQ8ZH\/bCB21y231H7RP\/6unjo53lniAIAAAAAAAAAAAAAALavuuwBAP7Yhhc2xg2fuiXOv\/LsuGHBVXHfj2bH+tUbYtS4kXH4lIPiN3fOi6vPv77sMQEAAAAAAAAAAAAAoNexiAR0OT+4+rZ4funKuOjGv40TP\/LWl7++7InlccfNs2LtyvUlTgcAAAAAAAAAAAAAAL1TZdkDAPypd188JT4746K48+ZZcVbDR+Ok\/mfEBQdeEsuXPB+fvvXCOOeyM8seEQAAAAAAAAAAAAAAeh2LSECX8vqj942PXHZW3P\/jOXH9RTfHiid\/Hy1Nm2PRw0\/GtFOuiJXPro7TPvGO2HXPXcoeFQAAAAAAAAAAAAAAehWLSECXcthJB0ZExNxZj7zispamzfH4g4uiqqoyxh+w584eDQAAAAAAAAAAAAAAejWLSECXUtO3JiIiBo8YtN3LB42oj4iIrZu37rSZAAAAAAAAAAAAAAAAi0hAFzP\/7kcjIuKEj7w1ho0aus1lB799Ukw8YkK0NG2OBfc9XsZ4AAAAAAAAAAAAAADQa1WXPQDAH7v7uw\/Eb\/7nt3Hgsa+PG393Vdz7gwfjhefXxpjX7h6HnvSGqKysjBv\/8dbYsGZj2aMCAAAAAAAAAAAAAECv0i0WkRomjY3pM6eVPQaQrGHS2Jf\/u6WpJfrV9Y1j3390RES0t0e0tbZGS+PmeP+0d8f7p727pCn\/oHZAv2ja2Oz2aSd46WejK3yvK2r7pbU3ja5J6Y4e\/LaUbkTE5ra8hxInnzEord33+LaUbsW6k1O6dF0Nk8bG4rlLyx4DAAAAAAAAAAAAYKeoLHuAIlMnT\/PhTugFGiaNjdoBf1jw2NKyNZo2NsemdY2xaV1jNK5vjOZNLdG6tbXEKbfVtLHZ7RNAL1c7oN82i7QAAAAAAAAAAAAAPVm3OCPS1MnTyh4BSPbSmW78e2d7utLPR\/W4sWnt331yREp36lG3p3QjIpZvHpzWnvHTI9PaY+5oTulW3v1wSpeu6wdrvl72CAAAAAAAAAAAAAA7TZc\/IxIAAAAAAAAAAAAAAABQPotIAAAAAAAAAAAAAAAAQCGLSAAAAAAAAAAAAAAAAEAhi0gAAAAAAAAAAAAAAABAIYtIAAAAAAAAAAAAAAAAQCGLSAAAAAAAAAAAAAAAAEAhi0gAAAAAAAAAAAAAAABAIYtIAAAAAAAAAAAAAAAAQCGLSAAAAAAAAAAAAAAAAECh6rIHAKCLq6hIyT7xpUM6fGzTXvUvXufLh3bo+Pcddd8OzdQRn9\/lh2ntLOvamtLaNVGV1v78h+antVs\/2JbSHX\/7uSndiIi9r29Ja8fsR\/La7e15bYBki688rEPHNTXUd+r4iIhF7712h2Yq8sGnj0\/pRkTcfc\/EtPY177wprX1g3z4p3dUfb0zpRkTsMistzU406t6tae1bzrwlpXtu\/Qkp3YiI1vXr09pVgweltZ\/\/xoiU7rwDv5XSjYj44aYBHTruqEEvPp+7u4PHR0Q0Dc\/7vVbTdv9pSnfP6n4p3YiIKZc\/nNY+d8iFae3hX70\/rQ0AAAAAUFlXl9b+2v43p7W3tOd9DqqmIqf9madPTulGRAz9mteSKUdre85n+yIifvKLGWntqoq899HedEHO5xJrf\/lgSpfewRmRAAAAAAAAAAAAAAAAgEIWkQAAAAAAAAAAAAAAAIBCFpEAAAAAAAAAAAAAAACAQhaRAAAAAAAAAAAAAAAAgEIWkQAAAAAAAAAAAAAAAIBCFpEAAAAAAAAAAAAAAACAQhaRAAAAAAAAAAAAAAAAgEIWkQAAAAAAAAAAAAAAAIBCFpEAAAAAAAAAAAAAAACAQhaRAAAAAAAAAAAAAAAAgEIWkQAAAAAAAAAAAAAAAIBCFpEAAAAAAAAAAAAAAACAQhaRAAAAAAAAAAAAAAAAgEIWkQAAAAAAAAAAAAAAAIBCFpEAAAAAAAAAAAAAAACAQhaRAAAAAAAAAAAAAAAAgEIWkQAAAAAAAAAAAAAAAIBCFpEAAAAAAAAAAAAAAACAQhaRAAAAAAAAAAAAaCSNvAAAIABJREFUAAAAgEIWkQAAAAAAAAAAAAAAAIBC1WUPwF\/nm0uuiV3H7rLdy9asWBunj\/rITp4IAAAAAAAAAAAAAACAnsgiUg+wce2m+P7VP3vF15s2NpcwDQAAAAAAAAAAAAAAAD2RRaQuomrk9s9qVKSiqio2bWiO\/7zul3+2u+bYcX\/NaH\/+zz5jZUo3ImLGxJvT2uecfF5au\/3hBWlt+EuqRoxIay+8ereU7pJjru\/wsRVDj3rxOqd2\/DpZPr\/qtWntbyw4NKVbM79\/Sjcior0qLR1jJy9Na399\/IyU7pPH35DSjYh4+tiNae1jfnJRWnvXuytSuoPvWpzSjYhoXZn3GAd49TW\/45C09qL3Xteh4yqGHtmp4yMi9pr1gR0ZqdC4981N6UZENMQDae2rpu6T1n77cznfkyNGPZnSjYhYkvj43v3cztP\/oWfS2lkPw9sm7JFUjojZ89PSiz61b1p74YHXpnT3\/sYFKd2IiHEz1nfouIbrhkdExHXnn9zx+JE7MlG52qItrT2qanNau61PznOpiIiFNx6U0t37w3NSugDdWkVlWrqmYmtau7U58YVfAAAAeryll0xKa+9TMyutnfl68o3rcj6Dt+7SMSndiIjq8L4if9lxo\/L+rbOt2niw7BHgFfJe\/QYAAAAAAAAAAAAAAAB6DGdE6gFq+lTH5FMPjhG7DY3mxpZ48nfL4pEHFkVbW3vZowEAAAAAAAAAAAAAANBDWETqAYaOHBSXfOUD23xt+VOr4osf\/2bMv39ROUMBAAAAAAAAAAAAAADQo1hE6ubu\/PYD8civF8VTjy+Ppk3NseuY4THlQ0fH8WceEf9y60fj4ydNjzVlDwkAAAAAAAAAAAAAAEC3V1n2APx1bv3ibTHv3oWxdtWGaGnaEk89vjy+\/Mlvx\/evnxn9avvEmVNPKHtEAAAAAAAAAAAAAAAAegCLSD3Uz75xT0RE7Hfo+JInAQAAAAAAAAAAAAAAoCewiNRDrVu9ISIi+tX1LXkSAAAAAAAAAAAAAAAAegKLSD3UPgfuGRERy59eVfIkAAAAAAAAAAAAAAAA9AQWkbqx0XuNjL61fV7x9ZG7D42\/\/cK7IyJi5vdm7+yxAAAAAAAAAAAAAAAA6IGqyx6AHXP59y6MkaOHxfBRQ2LT+sbY3LI12lrbok+\/mqgf3D8qqypj\/Qsb46BjXhvXvvOAnCFGbsnpRsQu\/aekta+4flRaOzZuymv3cA2TxkZExPSZ01719tTJr34TAAAAAAAAAAAAAHqKhkljUz7HC3QNDZPGxuK5S1+VljMidUOXf+\/CGDdx99i4rjE2rNkYffr2iSHDB8aI1wyJAfW1sWlDUzz9xPJY+uhz0d5e9rRQLg+KAAAAAAAAAAAAAODPmzp52qu2oAB0TYvnLn3VTvDhjEjd1JIFz8Ylp17doWPXHDsuZYaKM1amdCMiZky8Oa198XnnpbXbH16Q1u7pXloWerXPXmQJCQAAAAAAAAAAAAD+slf7M7xAz+WMSAAAAAAAAAAAAAAAAEAhi0gAAAAAAAAAAAAAAABAIYtIAAAAAAAAAAAAAAAAQCGLSAAAAAAAAAAAAAAAAEAhi0gAAAAAAAAAAAAAAABAIYtIAAAAAAAAAAAAAAAAQCGLSAAAAAAAAAAAAAAAAEAhi0gAAAAAAAAAAAAAAABAoeqyBwAAAAAAAAB6p7edfUxcfNNH\/+Ixra1t8faa03fSREB3NHy3oXH2P58eBx83KQYOGxhrlr8Q9\/1odnzz0hmxce2msscDAAAAgB7FIlIX0W9Ge4ePrZzYuetcN\/rqHRmp0Icu\/1hKNyLi7CsuTGvXzJ+X1oayLD13r7T27KOmJ5XrkroRh118flp76NwX0tp7Lsi5fdpw+mEp3YiI+666Lq194oFvT2ufctNZKd2fve7WlG5ExJjqAWntJX9zfVo7\/iYne\/R55+aEI6LfT1amtYFX3wsf3pDW\/n1rxz6kMrS9NSIi1nTw+IiIvc5fskMzFWlNqf6vioq8dnvHnxN31qObG1O6TzcOSelGRLSuXJHWZufZujzv77Ex6Z9M5fqmnHDk3j5NP\/XmtPaxj74jpbvnp+5P6UZEPPPpN3bouJahVS8ef9ygDrerfX5zG5k\/11VNefeNTx5\/Q0r3uIoDUroRkfpYAXh1VdT06fR1Fj+yLL75L9\/b7mWvO3JCHPDm18XsO+bFU9\/Z768d78\/asqx\/SrfuucqUbkTE987bPa09oTHvceHqDx7eoeO27FofERFrOnj80JvyHl\/R9b1m3Mi4+t7Px5CRg+PeHz4Yzzz+XEw4eHyccuGJcdBxk+JjR\/6f2LBmY9ljAhGx6ryO3a7viBeOaElrL3nr19La3dFxoyaVPQIAr5KK6pyPEJ\/3rttSutn6VtSktT\/\/wIkp3b3v+k1KNyK67fvDAOwcFpEAAAAAAACAUiz57VOx5LdPbfeyf\/\/ltIiIuO3GmRHv3YlDAd3KP1xzTgwZOTi+8g83xo++cvvLXz\/vyrPjtI+fFB\/6wnvj6gv+o8QJAQAAAKBnyfs1XAAAAAAAAAA7YOzE0bHvYXvFymfXxIO3PVz2OEAX9ZpxI+Og4ybF8id\/Hz++5o5tLvvG5\/4rmjY2x1vOfFP0q+tb0oQAAAAA0PNYRAIAAAAAAAC6lBPOeXNERNz+9VnR1tZe8jRAVzXpzRMjIuI3\/zMv2tu3va1o2tgcC+59LGr794t9DturjPEAAAAAoEeyiAQAAAAAAAB0GX361cRb3ntktG5tjdtv+kXZ4wBd2O4TdouIiGULn9vu5csWrYiIiN32HrXTZgIAAACAns4iEgAAAAAAANBlHH3aYTFwSP+YfedvY+Wza8oeB+jC+g+qi4iITesat3v5S18fMLhup80EAAAAAD2dRSQAAAAAAACgyzjhw5MjIuK2G+4qeRIAAAAAAOBPWUQCAAAAAAAAuoQ99tktJr5x71j5zOp48L\/nlj0O0MW9dMajl86M9Kde+vrGtds\/YxIAAAAA0HkWkQAAAAAAAIAu4YRzXjwb0u1fnxVtbe0lTwN0dc8+viwiInbbe9R2L99t\/K4REbFs4XM7bSYAAAAA6OksIgEAAAAAAAClq+lbE29535HRurU1bv\/6rLLHAbqBub9YEBERBx67f1RUVGxzWe2AfjHxiNdG06bmePSBJ8oYDwAAAAB6JItIAAAAAAAAQOnedOqhUT90QMy+Y16sfHZN2eMA3cDyJc\/HnDvmxmv23CWmfPS4bS57\/6WnR+2AfnHXLb+K5saWkiYEAAAAgJ6nuuwBAAAAAAAAgN7nijs\/s83\/N0waGxERI\/cY\/orLmvetS5ujvaUqpVuZuPfQ5z1tae2Ktva09pb+HfteTxgzIiIirr\/4XR06vuas44oP+iNTJ0\/r1PF0TdNnTouIiD79amLL5q3xd1\/6cJz12XdF86aWqKuvjYFDBkRzY0uMnTjm5WOBcm0ZVZ\/W3joo8b5xyOS0dnc0feaADh\/rPhcAAKBnckYkAAAAAAAAYKe64s7PRMP+e7z8\/33r+sSAQXWxuXlLrF+9scTJ6OkaJo21lNIDTJ857eXlxc3NW+KJ3yyONctfiLqBtTFi9LDoW9snVj67OhY9tCRat7aWOyxAL+U+FwAAoOdyRiQAAAAAAABgp1s876m4+G1f6NCxS2+dkDbHlmX9U7p1z+X9TshdH2hKa1c1bk5rr359x86E8dKZkM67YkaHjh960\/0dnsEHonuOxXOXOtMGdDOrzjs8rf3CEXmnIlzy1q+ltbujqZMndeg497kAAAA9lzMiAQAAAAAAAAAAAAAAAIUsIgEAAAAAAAAAAAAAAACFLCIBAAAAAAAAAAAAAAAAhSwiAQAAAAAAAAAAAAAAAIUsIgEAAAAAAAAAAAAAAACFLCIBAAAAAAAAAAAAAAAAhSwiAQAAAAAAAAAAAAAAAIWqyx4AAAAAAAAAAAAAgN7hgMmviykfPT72PXzvGDCkf2xYvSGenP90\/OBLt8WD\/\/1w2eMBAFDAIhIAAAAAAAAAAAAA6c657Mw4\/eKT4\/fPrIr7fzIn1q9aH4NG1MdebxgXrz9mokUkAIBuwCJSF\/HULeM7fGzzJ2o7dZ26z2zdoZmKjLj2\/pRutvayB4AENY157bVtbSndIVUp2YiIGDZzaVp764rn09pZBv98YVp7\/K0XpLWn3vXjtPZJAx5P6Q6qHJDSzXbwQ+9Oa9f+x+CUbv+ZC1K6ERE5t3pAlhEDNpU9wo7pU1P2BJ1WPWb3tHbb8yvT2vv0qUvpPjJ\/j5RuRMResSKtzc6z8vzD09orWh9K6bYtfSalm21K\/7wnxVddPjKlu+Zjo1O6ERF3nH95h47bZcShnTo+IuLEKy\/ZoZl6qoGVeS9utJ28Jq19\/Nvek9J976MzU7oREd967ai0NvDqeuofD+rwsc17DOzUdeYf8eUdmqkjWtq3pHRrKvLuK\/pWdL\/nlZ1RMfSIiIiY\/YVrO3T8cTdNyhwHoEta\/97D0tr\/n717j7a6rvM\/\/t7nbM7hcBdRkZsgBF4qKY3SafKWMaVlN53sp13MblaaSc5Mv9VPql+1TM2aMlGbymyymalfWWlWg9ZkoJZFpqIEgSJmCgICcjmX\/fsDnTWWy893n3qzOfB4\/NNa+dnP9Vl45Jyzz36d\/YJzb0\/pfn\/fz6d0I3I\/7wLw1\/PyM46Nv\/\/gifGjr\/wkLnnn5dHT\/dTXNrbXB+jf57VaXruR94rHZV99dkr384vy\/jxuePOYtPbcJbemtZ\/1xd60dprEjz0ABr62Vl8AAAAAAAAAAAAAgF3XoI56vPX\/nhJ\/vO+Rpx0hRUT09gzAsQYAwG7IOyIBAAAAAAAAAAAAkOb5xz039th7ZHzrM9+Pvr6+mPWK58eUZ0+MbVu6457blsbiW5a0+ooAAFRkiAQAAAAAAAAAAABAmhkvmBYREdu2dMe8X10YU54z6Sn\/\/I6f3h0fPeniWL\/6sVZcDwCAJrS1+gIAAAAAAAAAAAAA7LpG7T0yIiJOnvOqaDQa8f6\/\/XC8cvhp8fbnnhu\/\/OGieO6RB8WH\/\/0DLb4lAABVGCIBAAAAAAAAAAAAkKbWVouIiN6e3vg\/J14Qd\/38ntiyaUusuPP+mPvaC+PhlavjkKMOjgNfNL3FNwUAoMQQCQAAAAAAAAAAAIA0m9ZtioiIpb9eEX+875Gn\/LOtm7fF7T\/6TUREHDBr2g6\/GwAAzTFEAgAAAAAAAAAAACDNynsfjIiIjU8Mkv7UhrXb\/\/+Oro4ddicAAPrHEAkAAAAAAAAAAACANL+e\/9vo6+uL\/Q6aELVa7c\/++eSDJ0ZExEPLH97RVwMAoEmGSAAAAAAAAAAAAACkefj+1XHL926PffbbK15z9iue8s8OPe65cdjsQ2LD2o3xixsWteiGAABUVW\/1BQAAAAAAAAAAAADYNU2dOTkuunFuDOqsx7Yt2+Ldn35LnPrh18fmDVuio2tQjBwzIqIRsWbVo\/HR75zX6uvuNjYfNCwn3MjJRkR0\/XhTWnvy2MeaOn\/XQ29MugkA7Py8IxIAAAAAAAAAAAAAf3VTZ06OrmGDIyKie2tPLLn997H6gTXR2dURYyaMjmGjhsZjqzfE7369PNav3tDi20I1QzsOioPHfr3V1wCAlvGOSAAAAAAAAAAAAACk2LxxS8w5Zm6rr5GnVstrN\/LeXuj3X5+Z0m008v48pr35t2ntuUturXzWCAmA3Z13RAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAonqrL8B2Y65YWPnsoDfMbuoxx0+b0687lcy\/\/8KUbkTEqe\/7QFp72E33pLV7H3ssrQ3PZOwlC9LaLz30fSndW4\/8fOWzoxq9ERGxrndTpfPf+eV1\/bpTFUed85609qjbHkzpNr7ck9KNiFg647K0dm+jL619T3d7Svek37wupRsRMeTCUWnt0TfentbOkvfRAQw0D\/9oQlp774OGVjpXq23\/vLJ3e7XzERFvuPk3\/bpTyae+cnJKNyJi8CONtPZrz16S1l7WvTGlO\/7GlGxERGw8+UVp7RH3rq92cNiQiIhoO+TAyu3a\/Q\/150rl7tAhKd2IiHWH5\/0dctb7v5XWfte896Z0x23N+95yoLrpy19s9RWatrq3Vunck7+hanCt2vmIiL6OflyootFJvzKrLfF3cXUnft+69o8j0tr7rlmZ0n3LiIdTuhER18S4tDbw1zX6iOpfEw4asa2px8yY\/\/Z+3amK\/f416fNFE59nm7V5z5znOCMiOjblfY676rOfrnRuXN\/2nws8mPQ9HcD\/VN93bFr77o\/lPfew\/BXz0tpZvrNpZFr7vP84La095UPVX9PTrCWXzUrpLj\/xipQuAE+vrbMzrT3r1g1p7atHX5rSPeK\/cn6OERFRq+e97PmN159Z+ew3Thzf1GOe9fNb+3UnANhZeUckAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACiqt\/oC5Nv\/vIUp3dcs\/WBKNyLiwH9YnNbe9\/wNae1FZz8vpdv2s1+ndKGKaafmfPwdd+3bKp\/94uH7RkTEGb+q9phbDru6X3eq4tsXX5zWXtkzKKV7aGdHSjci4uHeTWntU+49Ja0dn9wrJTti\/u0pXYABr1ZLOz\/uUwuavEx1nzh1RqVzpw0fEhERV6+udj4i4kNj7u3XnUredNYXUroD2XGLc76meOCE3pRuRMThM5altScPWVPp3PCp27\/Oe95X7qrcXrJx737dqWS\/IX9I6UZE7N2xJK39mUtfn9Ye97m8v\/sGomPvflVae8bIh1O63X3tKd2IiPvOmVbp3MWfGx8REee+78zK7Un3rejPlSo54vnV79GMW198WUo3ImJwLe\/f46EHLE9rr586IaV74Lycf4cREZPC33swUIwftr7y2c723qYe89j8sf26UxUdPxx4f8\/kPesbUR8\/Lq09ZdCwSudqbe1NnQd2Dz3HHprSnXHBHSndiIjrxt2Q1s40e\/EJKd3293aldCMiJo\/enNaO+TnfR0VELJrx2aRy3p81AH9u9TcnpbUf2PxgWvuth5+c0p26alFKNyLiB6vyXkv54rMOqXy248jt\/zvuJzl3AYCdnXdEAgAAAAAAAAAAAAAAAIoMkQAAAAAAAAAAAAAAAIAiQyQAAAAAAAAAAAAAAACgyBAJAAAAAAAAAAAAAAAAKDJEAgAAAAAAAAAAAAAAAIoMkQAAAAAAAAAAAAAAAIAiQyQAAAAAAAAAAAAAAACgyBAJAAAAAAAAAAAAAAAAKDJEAgAAAAAAAAAAAAAAAIrqrb4AAFQxY+TY+OLhp1c62zH8+LR7jI6+tPaQRi2lW2vL2x2PbvSmtS8ZsndaOy7qSMnW1r4ypcvOq2vY4Ni8cUurrwEAAADs5qbOnBwX3Ti31deI+sGDKp+dPHRCRER85OAPVDq\/aZ+uft2pis6XvyytPRDVOnOeP42IqI1+Y7WD9QMjehan3QMAAAAAgP7zjkgA7PTOWPiluHf9Q62+BsCf2bxxSyxbtKLV1wAAAAB2Y3OOmev5CXY9PYuj8eiprb4FAAAAAABPwzsiATAgnLHwS5XP3nLY1Wn3WN+3La29sqf6bwttxqGJv73y0d5Nae1z7j0lrR2f3CslW59\/e0qXndfO8JuGAQAAAOYcM7fVV4iIiJE371n57JPvhHT+XZ+udH7xtTP6dacqxl24IK09ENXHj0trX\/eL69PaAAAAAADsGN4RCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACiqt\/oCDFxjrliY1n7030emte87elZa++NXXZ7SPeeuk1O6ERFjXrkkrQ3PZN3Dw9PaWxo9ae2924cmtnO6d23bnBOOiNd\/6YNp7UkfXZDWjrg\/sQ3An2k0cs8n2WfQ+krnBtV6mjofEfFAz8Z+3ankb+efndKNiOgcui2tfc+Lr05rH71X0vc8Hx2T042INT9dm9eu+DtpNtxYi4iI249p5nfYrO7HjcruTKk+Ke\/r+30i8+tZ\/qf6S\/O+vl+WVs5Tq91R7eD67Z+Lagsrno+InsTP0V23TE7p3vvCzpRuRMQLOmtp7Y9N\/G5a+81Tz03p5n4fDwwUqzZW\/\/nO1t72ph4z4cfr+nWnKvrSygPTPR+clNZ+7dLjksqPJHWBZq34+OFp7Z+96aKU7h5tg1O62yX9ADAijr7rxLT2kDdtTen2\/OF3Kd2IiHVvyfvY2\/SfeZ8bvzluSkr3bSMfSukCDGRL5uW9bvCqg65Ia39iRt69G92r0tpZZo+bmdYeGrdWPtt+5su3P+ab1R8DALsS74gEAAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAEWGSAAAAAAAAAAAAAAAAECRIRIAAAAAAAAAAAAAAABQZIgEAAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAEWGSAAAAAAAAAAAAAAAAECRIRIAAAAAAAAAAAAAAABQZIgEAAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAEX1Vl8AAAAABro9O6fF8RP\/ufL50e2bU+7xjdkTUroREW3tfWnt2sjZae3Thg9J6Z5wyYiUbkREbd2Jae2qps6cHBERF904t6X3YPfTNWxwRPjY2xH++7\/z+ee39iJP2DYh5+\/V6WMPT+lGRLTX0tIxuZH3effyf5iY0q2\/Oe\/zeVVdwwbH5o1bWn0NAAAAAP5E17DBLX\/e9\/Hpw9PaB45+SVr7wh\/l3Tsajbz2Ls7P0miVqTMnx7JFK1p9DQDviAQAAAB\/ietWnhVrti5t9TUAdgl33nxP3HnzPa2+BjBAbd64xQ9gAQAAAHYyyxat8MtjAP5Kli1aEXOOmdvqawB4RyQAAAD4S1238qymzs8emjNcesP8s1O6ERGdQ7elte958dVp7atXz0jp3nTOESndiIi2n\/46rV3Vk7+9zZPYMADVqr1Nz5PvhDTn2I9Ubyf+dsyHzs75e\/Xysz+X0o2IeEFn3lsirejOe2HGOy84N6W7x1ULU7rN8NtHAQAAAHZOO8ML55fMm5XWvuplV6S1P\/GyvHs3uvN+\/rer87M0AHZ33hEJAAAAAAAAAAAAAAAAKDJEAgAAAAAAAAAAAAAAAIoMkQAAAAAAAAAAAAAAAIAiQyQAAAAAAAAAAAAAAACgyBAJAAAAAAAAAAAAAAAAKDJEAgAAAAAAAAAAAAAAAIoMkQAAAAAAAAAAAAAAAIAiQyQAAAAAAAAAAAAAAACgyBAJAAAAAAAAAAAAAAAAKKq3+gLwdHrXrU9rD\/n2rWntT\/7gRSnd03+1MKUbEbH2jqFp7QWvPbDy2VrX4IiIaJ82pdL53qXL+3Wn8kVqOd2IiEYjr51o9TsOT+lef9zFKd2IiJFtQ9LamXobfSndIbXelG5ERFtPWhoAKlnyL4eltd828otp7WnXzEnpTj\/3lpRuREStnvcUwlGz357W\/smVV6Z0l12wV0o3IuKh149Pa\/c8sCqtDewkmn3+YSd5vmLcl36b0j3thW9L6UZE\/O6or6S1NzQGpbUHbd45\/p0Du6bhJ9xf+Wz7j7c29Zi+Hk9G7ijLTp6X1j7u79+a0m2LR1K60Eq1QR1p7fvPy3tO7edvujCtPaY952fbt23tTulGRLznY+9Na4\/+Ut7rCAbiZ929bnogrb3+jAlp7VcOW5bS7W10pXQBdoTeo56f0l3+qitSuhERR77zHWntwd23pbUBAPrLOyIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQFG91ReAXUnfli0p3e8etGdKNyKHiJUWAAAWIElEQVRiybxZae3Lbriq8tnx+54UERFn3XB9pfOXTDuwX3cqajRyuhFR339yWvvxy\/Pufe2MC1O6E+rDUroRERc+OjWtfdNJz09rLz5nVEp3+QlXpnQjIv7udbekte+6uDOt3di6Na0NwJ9rm3lQtYPDhjR3PiL+7ZjL+nOlSuatm5zWnnpu3ufQLI2enrR253W\/SGvP+qd3p3Rv+2Tex94Bbz8zrb3f+avS2gB\/ib4NG3K6fxyc0s02qm1bWnvNwTm\/n2zE4Lw\/66znXYG\/vqa+b3ji+fjM7zV2Zev\/14vS2su7b05rty\/8bUo376ck0DqPHz8zrX33e76Q1o4Ymla+Y1vO14UfPuUdKd2IiNG3LExr81S9Dz2c1p5y7ci09mdOODyl+4l97kjpAjypVm\/ipae1WlOPGfKRB\/tzpaIpP3xbSjciYvr3bktrAwDsjLwjEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAU1Vt9AaC1pr\/7F2ntl6zcUPlsV1vP9scMrvaYS\/p1o7L6hPFJ5Yhnf2tFWvuCfRaltdf25mxW9\/\/x6SndiIjpZ9yZ1m50\/y6tPe2rM3PCJ+RkIyI6n\/hvN0OtfXBau5FWBuDpPD5hWKVzfZ3tTZ2PiHheR97v15hzzvFp7a64La3NU+31sz+kdJd1b0zpRkSMPfzBtDbA7qYxQH8V1\/RBQ9Pac99wTUr38gWvS+lGRHT88JdpbYCB6gPn5\/x9HhFx\/BXnpbUn9ixIa0Or1PebmNL9ry9ckdLNdum6nD+PiIjrZx+SE155R06XHaqxdWtae8O06s9ZN+tDe2U9V5z3s1aAiIhaV1f1w21tTT3mu8+6oT9XKpp9ZNLrcgAAdkMD9MewAAAAAAAAAAAAAAAAwI5kiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAAUGSIBAAAAAAAAAAAAAAAARYZIAAAAAAAAAAAAAAAAQJEhEgAAAAAAAAAAAAAAAFBUb\/UFgBZrNNLSLz33rMpnv\/DhCRERcebHqj1mjwkrK52rdXZGRER9wvhK54d+Y0ulc\/1xwT6L0tqLtz2e1j7t4+emdJ915cKUbkRE3kd1rqVvHtTqKzRtSPu2tHajtzetDcCOtW5atW89e7pqTZ2PiBhUa+\/Xnaqo9aSl2YH6HlmT0j35jtNTuhERr5p0Z1p7QXSktQF2SvWB+ixBnrZaX6uvALDbqO8\/Oa198rC8nzl85QuL09qe9eUZ1Wp5j0n8mWjn1Xk\/XxyI\/uVzJ6S191qZ9\/NFeCZtPXl\/hwxrG5zWBsi0bdb0ymcbI4Y09Zj3rsp6LcrWpG7072vZqhK\/ll31j0ekdE865Scp3YiIby0\/JK2976vzvh8GgF2Nd0QCAAAAAAAAAAAAAAAAigyRAAAAAAAAAAAAAAAAgCJDJAAAAAAAAAAAAAAAAKDIEAkAAAAAAAAAAAAAAAAoMkQCAAAAAAAAAAAAAAAAigyRAAAAAAAAAAAAAAAAgCJDJAAAAAAAAAAAAAAAAKDIEAkAAAAAAAAAAAAAAAAoMkQCAAAAAAAAAAAAAAAAigyRAAAAAAAAAAAAAAAAgCJDJAAAAAAAAAAAAAAAAKDIEAkAAAAAAAAAAAAAAAAoMkQCAAAAAAAAAAAAAAAAigyRAAAAAAAAAAAAAAAAgCJDJAAAAAAAAAAAAAAAAKDIEAkAAAAAAAAAAAAAAAAoMkQCAAAAAAAAAAAAAAAAigyRAAAAAAAAAAAAAAAAgCJDJAAAAAAAAAAAAAAAAKDIEAkAAAAAAAAAAAAAAAAoMkQCAAAAAAAAAAAAAAAAigyRAAAAAAAAAAAAAAAAgKJ6qy8A7LqG\/8cvKp9tf9fLm3rM4s8cVunc45M6t58\/b0Kl87\/f\/\/JK53Y2J82bk9Yef+WCtHaWtuHD09qr3vGctPY\/vfg7Kd31fZtTuhER3\/jXY9La47cOvI89AJ7eqGU9lc7VNzeaOh8RsbFvS7\/uVMWqo\/J+d8fU76el+VPd3SnZtWuHpXQjIiZMezStHTE2sQ3Qf90vq\/ZcT7OOPezOlG62B3o2prX\/ceHpKd0Dlq1J6UZE9KaVAXLd\/cG909qXrpuY1u5duzatDc+o0Uh7zIY3vKj5dkXf3v+fk8odSd2Io+86Ma099pq709q+LuSZtI\/ZM6099N2r0toAA9UDR1X\/WmXrqFpTjxnf09mvO1W4SVI3oj5+XFr7b65fmtY+Yui8lO6iLZNSuhERt7\/ga2ntE+LQtDYA7Gq8IxIAAAAAAAAAAAAAAABQZIgEAAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAEWGSAAAAAAAAAAAAAAAAECRIRIAAAAAAAAAAAAAAABQZIgEAAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAEWGSAAAAAAAAAAAAAAAAECRIRIAAAAAAAAAAAAAAABQZIgEAAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAEWGSAAAAAAAAAAAAAAAAECRIRIAAAAAAAAAAAAAAABQZIgEAAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAEWGSAAAAAAAAAAAAAAAAECRIRIAAAAAAAAAAAAAAABQZIgEAAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAEWGSAAAAAAAAAAAAAAAAECRIRIAAAAAAAAAAAAAAABQZIgEAAAAAAAAAAAAAAAAFNVbfQGgxWY9Jy3d19Fe+WxjxNDtjzmi2n1OP+qnlc6NHTW7qfOZXvW7v0trT\/ry0rR2b1K3PnlSUjli1rV5fx7vHn1hWnvv9qEp3QOuPDelGxGx3wUL0toA7Dq6fvCrSufaPnB8U+cjIq7dNL5fd6ria6+9NK19\/pxD09rsGEdPX5LWvu6RvO\/TIh5JbAP03+AHHkvp3r12n5RuRERMzEt31Gpp7WMPuDele+P501O6ERHTTktLA6T64SsuSWu\/8aNz0tp71m5Ja0ejkdeGZ7B5zMD7Ha3LujemtR\/\/6ri0dse6+9La7Djte+yR0n3w1ANTuhERb3nX9Wnt9++xIq2d5e0r\/yaxvimxDQwUp7\/6PyufHTvmpU095mdrpvXrTiX1KTmf3yIirvv5tWnt5150Zlr75qtzXr9Vq1d\/3WCzTrzlzrQ2AFDdwHu2DQAAAAAAAAAAAAAAANjhDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAIkMkAAAAAAAAAAAAAAAAoMgQCQAAAAAAAAAAAAAAACgyRAIAAAAAAAAAAAAAAACKDJEAAAAAAAAAAAAAAACAonqrL8B29f0nVz5b6xrc1GN6fr+i+QuxU2mfNiWtff13rk5rz371aZXP1hqNiIho29Zb6fzD24ZXOtfd197U+UzffdYNae2jv3ZiWrveNjGl+\/UZ\/5bSjYgYXMv79Hbp2uekta9\/71Ep3f1+siClCwBVNXp6Kh5sNHc+Ij77iZP7c6VKbvvkZWntl9+1LqX7\/\/73y1K6ERHDbl6W1o5RI9LSS88Ym9L9waS8j4\/nXHJmWntcPJLWBvhL9N69JKU78uS8zzGHfPWUtPZvZl2T1r5y4s9Tujfs+cuUbkTEJXFgWhsgIqK+X87z4NMHDU3pRkTsc9Mf0to9T3x\/DruUvlZfoHkT6p1p7YPec2da+4HlM9PabTcvSun2Hfm8lG5ExPopg9Paa47dktb+1Au\/ldI9puu6lG5ExB7tQ9LamV7y29ekdIed1Z7S3W5pYhsYKL63qvrrZ2bvO7Tpx2R47JK8r6+mXfOutPbUT+e97qfaK\/X6Yf6ErHKs7xuU1gYAqvOOSAAAAAAAAAAAAAAAAECRIRIAAAAAAAAAAAAAAABQZIgEAAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAEWGSAAAAAAAAAAAAAAAAECRIRIAAAAAAAAAAAAAAABQZIgEAAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAEWGSAAAAAAAAAAAAAAAAECRIRIAAAAAAAAAAAAAAABQZIgEAAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAEWGSAAAAAAAAAAAAAAAAECRIRIAAAAAAAAAAAAAAABQZIgEAAAAAAAAAAAAAAAAFBkiAQAAAAAAAAAAAAAAAEWGSAAAAAAAAAAAAAAAAECRIRIAAAAAAAAAAADw\/9u7nxCryjAOwO+o4UxOalAEJTHjlBJG3BYFtgolZhkhEmFtE6KFgqto4S6KFiFFEZhFIllE6Cb7gwWClkkJBRZSGQglRdjUaJnObTFBudDv3Ot959w58zybWdzv\/PhguOc77535cQEAAIoUkQAAAAAAAAAAAAAAAIAiRSQAAAAAAAAAAAAAAACgSBEJAAAAAAAAAAAAAAAAKFpQ9waYNrr7x8prB1ec6+iafcdbXe2pZPGBoZTciIiFp9tp2TGQF\/3T2vMpuTvufSUlNyJi1fOPpWUvO3yw+uKJyemfh7+stPzY5jsrrZt8btG\/62+vtP7hpxdVWteNnSMfp2V\/tGpPWvaxc2dScrefrvY76cZLe8fTskefOJSWPT8+zwkeSLzxtRPv1wA0R6dnUQfrr30t72xuLcl7Vt7w6HspuY8\/szslNyLi2Nmb0rJvGzqSln3q76Upucvf3piSGxGx8oWjadlTackA\/enCxERa9sSplWnZs9Hk1MK6twDQta835807Wc5\/d6LuLcCsMng6byJ+98x1KbnrhvOeZXfcfCAtO95MzE6T91kMFzt5Pu+9uPbIg2nZw9uXpGUP7TmcknshJRXgP8NPXl157fwX53d0zb69O7vaU0nW\/0BFRGzZ\/FBa9i+PrE7LvmrDqZTc91e+kZIbEbF+9bq07IiTidkA0Cy+EQkAAAAAAAAAAAAAAAAoUkQCAAAAAAAAAAAAAAAAihSRAAAAAAAAAAAAAAAAgCJFJAAAAAAAAAAAAAAAAKBIEQkAAAAAAAAAAAAAAAAoUkQCAAAAAAAAAAAAAAAAihSRAAAAAAAAAAAAAAAAgCJFJAAAAAAAAAAAAAAAAKBIEQkAAAAAAAAAAAAAAAAoUkQCAAAAAAAAAAAAAAAAihSRAAAAAAAAAAAAAAAAgCJFJAAAAAAAAAAAAAAAAKBIEQkAAAAAAAAAAAAAAAAoUkQCAAAAAAAAAAAAAAAAihSRAAAAAAAAAAAAAAAAgCJFJAAAAAAAAAAAAAAAAKBIEQkAAAAAAAAAAAAAAAAoUkQCAAAAAAAAAAAAAAAAihSRAAAAAAAAAAAAAAAAgCJFJAAAAAAAAAAAAAAAAKBIEQkAAAAAAAAAAAAAAAAoUkQCAAAAAAAAAAAAAAAAihbUvQGmHb\/rr8prz+6fmr5mTbVrxuJoV3uic4t35eQ+FXfkBEfEsjiYlp1p3oEvKq0b+O3+jtb\/fE\/XWyoaj1ZeOBcZjUN1b6G\/tNt17wCAua7Ts6hPzq4btuU9K3+47Zqk5KzcXAdjtO4tdOzW+DQteyotGYBeWrHxs7Ts8Y0+RwKYSbds+iQld3yT+zn0i8W7ct7nEREv71qek5uSCs11fXxT9xYA5pT2ka+qL\/59sqNrxm+cjbPUD2nJS7\/Py47Xc2IfiLtzgiMi4mRiNgBQlW9EAgAAAAAAAAAAAAAAAIoUkQAAAAAAAAAAAAAAAIAiRSQAAAAAAAAAAAAAAACgSBEJAAAAAAAAAAAAAAAAKFJEAgAAAAAAAAAAAAAAAIoUkQAAAAAAAAAAAAAAAIAiRSQAAAAAAAAAAAAAAACgSBEJAAAAAAAAAAAAAAAAKFJEAgAAAAAAAAAAAAAAAIoW1L0BujPWGoln92+texvQM2OtkRgaHox3fn21p7lDw4Nx9o8\/vV8ASDHWGolvj56oexvQKGYd6A\/OOJgbnLs0jfMLZh9nEXVwXjSHewhAf3PmAv\/n2Y2mcc4BMNcNtNvtS75437z1l36RWnkop4nGWiMpuR74Aci0Zc3Wyms\/mHprIG8nzBVNn9PMOtA\/OjnjgNnJuUsTdXp+mdO4Uk2f0bI5i6iLeacZ3EMA+p8ZjZlmRutfnt1oIrMlAE13uRlNEQkAAGaIP57QC+Y0AADoHXMaV8qMBgAAvWNG40qZ0QAAoHcuN6PNm8mNAAAAAAAAAAAAAAAAALOTIhIAAAAAAAAAAAAAAABQpIgEAAAAAAAAAAAAAAAAFCkiAQAAAAAAAAAAAAAAAEWKSAAAAAAAAAAAAAAAAECRIhIAAAAAAAAAAAAAAABQpIgEAAAAAAAAAAAAAAAAFCkiAQAAAAAAAAAAAAAAAEWKSAAAAAAAAAAAAAAAAECRIhIAAAAAAAAAAAAAAABQNNBut+veAwAAAAAAAAAAAAAAANDnfCMSAAAAAAAAAAAAAAAAUKSIBAAAAAAAAAAAAAAAABQpIgEAAAAAAAAAAAAAAABFikgAAAAAAAAAAAAAAABAkSISAAAAAAAAAAAAAAAAUKSIBAAAAAAAAAAAAAAAABT9AxEdYo9vus+GAAAAAElFTkSuQmCC)","ec20d9ac":"# Create model","c5a59f31":"# train"}}