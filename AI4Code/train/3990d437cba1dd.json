{"cell_type":{"9bf80c32":"code","8f0f9ca2":"code","90836c1c":"code","16005b0a":"code","ea7cacb3":"code","845a5953":"code","3dcb4b89":"code","c4d62574":"code","e37f1670":"code","cc341f86":"code","bbc46e7f":"code","8e42c441":"code","2138ec0a":"code","26fd6bd9":"code","97f5261c":"code","cd5c984e":"code","e60efcfe":"code","02340833":"code","cbca73ff":"code","fa611597":"code","d676f684":"markdown","555216fe":"markdown","3bfaca0e":"markdown","a3b7b007":"markdown","8aeb4dc0":"markdown"},"source":{"9bf80c32":"import tensorflow as tf\nimport tensorflow_datasets as tfds\nfrom tensorflow.keras import layers\nfrom tensorflow.keras import models","8f0f9ca2":"(train_set, valid_set, test_set), info = tfds.load(\n    'cats_vs_dogs', \n    # take 50% for training, 25% for validation, and 25% for testing\n    split=[\"train[:50%]\", \"train[50%:75%]\", \"train[75%:100%]\"],\n    as_supervised=True,\n    with_info=True,\n)","90836c1c":"info","16005b0a":"class_names = info.features[\"label\"].names\nclass_names","ea7cacb3":"# number of images in the dataset\ninfo.splits[\"train\"].num_examples","845a5953":"import matplotlib.pyplot as plt\n\nimg_size = (150, 150)\nplt.figure(figsize=(10, 10))\ni = 0\nfor image, label in train_set.take(12):\n    plt.subplot(3, 4, i + 1)\n    image = tf.image.resize(image, img_size)\n    plt.imshow(image.numpy().astype(\"uint8\"))\n    plt.title(class_names[label])\n    plt.axis(\"off\")\n    i += 1","3dcb4b89":"def create_dataset(ds, batch_size=32, buffer_size=1000, shuffle=True):\n    ds = ds.map(\n            lambda x, y: (tf.image.resize(x, img_size), y), \n            num_parallel_calls=tf.data.AUTOTUNE\n        )\n    ds = ds.cache() # cache before shuffling for a better performance.\n    if shuffle:\n        ds = ds.shuffle(buffer_size, seed=42)\n    # batch after shuffling to get unique batches at each epoch\n    ds = ds.batch(batch_size) \n    return ds.prefetch(1)\n\ntrain_set = create_dataset(train_set, shuffle=True)\nvalid_set = create_dataset(valid_set)\ntest_set = create_dataset(test_set)","c4d62574":"images, labels = next(iter(train_set))\nprint(images.shape)\nprint(labels.shape)","e37f1670":"data_augmentation = tf.keras.Sequential([\n    layers.RandomFlip('horizontal'),\n    layers.RandomRotation(0.1),\n    layers.RandomZoom(0.1),\n])","cc341f86":"# take an image from the batch\nimage = images[3]\n\nplt.figure(figsize=(10, 10))\nfor i in range(9):\n    plt.subplot(3, 3, i + 1) \n    augmented_image = data_augmentation(image)\n    plt.imshow(augmented_image \/ 255)\n    plt.axis(\"off\")","bbc46e7f":"# load the pretrained model\nbase_model = tf.keras.applications.VGG19(\n        input_shape=(150, 150, 3),\n        include_top=False,\n        weights=\"imagenet\",\n)\n# freeze all layers of the model\nbase_model.trainable = False","8e42c441":"model = tf.keras.Sequential([\n    tf.keras.Input(shape=(150, 150, 3)),\n    data_augmentation,\n    layers.Rescaling(scale=1.0\/255), # rescale the pixel values to the [0, 1] range\n    base_model,\n    # add a new FC classifier on top of the base model\n    layers.Flatten(),\n    layers.Dense(256, activation='relu'),\n    layers.Dense(1, activation='sigmoid'),\n])","2138ec0a":"# compile and start training after freezing the layers\nlearning_rate = 1e-4\nmodel.compile(loss='binary_crossentropy',\n              optimizer=tf.keras.optimizers.RMSprop(learning_rate=learning_rate),\n              metrics=['acc']\n             )\n\nepochs = 10\nhistory = model.fit(train_set, epochs=epochs,\n                   validation_data=valid_set)","26fd6bd9":"def plot_learning_curves():\n    acc = history.history['acc']\n    val_acc = history.history['val_acc']\n\n    loss = history.history['loss']\n    val_loss = history.history['val_loss']\n\n    plt.figure(figsize=(10, 7))\n    plt.plot(range(epochs), acc, \"b\", label=\"Training Accuracy\")\n    plt.plot(range(epochs), val_acc, \"r\", label=\"Validation Accuracy\")\n    plt.legend()\n\n    plt.plot(range(epochs), loss, \"g\", label=\"Training Loss\")\n    plt.plot(range(epochs), val_loss, \"orange\", label=\"Validation Loss\")\n    plt.legend()\n    plt.grid(True)\n\n    plt.show()\n\nplot_learning_curves()","97f5261c":"# we start by unfreezing all layers of the base model\nbase_model.trainable = True","cd5c984e":"# Freeze all layers except the 10 last layers \nfor layer in base_model.layers[:-10]: \n    layer.trainable = False\n\n# compile and retrain with a low learning rate\nlow_lr = learning_rate \/ 10 # low learning rate\nmodel.compile(loss='binary_crossentropy',\n              optimizer=tf.keras.optimizers.RMSprop(learning_rate=low_lr), \n              metrics=['acc']\n)\n\nepochs = 10\nhistory = model.fit(train_set, epochs=epochs,\n                    validation_data=valid_set)","e60efcfe":"plot_learning_curves()","02340833":"import numpy as np\n\n\ntest_loss, test_acc = model.evaluate(test_set)\nprint(np.round(test_acc * 100, 2), '%')","cbca73ff":"image_batch, label_batch = next(iter(test_set))\nproba = model.predict(image_batch)\n# returns 0 if the probability of the prediction\n# is below 0.5, otherwise it returns 1\ny_preds = tf.where(proba < 0.5, 0, 1)","fa611597":"def show_prediction(image, y_pred):\n    plt.imshow(image \/ 255)\n    plt.title(class_names[y_pred.numpy()[0]])\n    plt.axis(\"off\")\n\n\nplt.figure(figsize=(10, 10))\nfor i in range(12):\n    plt.subplot(3, 4, i + 1)\n    show_prediction(image_batch[i], y_preds[i])","d676f684":"# Build an Input Pipeline","555216fe":"# Evaluate the Model on the Test Set","3bfaca0e":"# Load the Dogs vs Cats Dataset","a3b7b007":"# Feature Extraction","8aeb4dc0":"# Fine-tuning"}}