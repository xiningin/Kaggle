{"cell_type":{"3baf262e":"code","ed9cbfc7":"code","59440bc4":"code","a7806d87":"code","1d0ef091":"code","252f43dd":"code","18620ff2":"code","42074eab":"code","87b97eae":"code","42e2f696":"code","2e8e82fd":"code","d17e0eb9":"code","12e02583":"code","ab590a52":"code","52b261d9":"code","72109a66":"code","e608eba4":"code","c5579ead":"code","0efadfe6":"code","7fa195bf":"code","3e2f62ab":"code","e75c8ee1":"code","4f875ae7":"code","ffb264d9":"code","fccf0714":"code","588b55c0":"code","993a2c9b":"code","1bc79b3f":"code","f029ae5b":"code","cbbf5954":"code","7bad16f6":"code","925312c4":"code","6a1ccec4":"markdown","62f32c8d":"markdown","1ab06e9d":"markdown","33eae147":"markdown"},"source":{"3baf262e":"import pandas as pd\n\n# reading the training data\ndocs = pd.read_table('..\/input\/smsspamtable\/SMSSpamCollection', header=None, names=['Class', 'sms'])\ndocs.head()","ed9cbfc7":"# number of SMSes \/ documents\nlen(docs)","59440bc4":"# counting spam and ham instances\nham_spam = docs.Class.value_counts()\nham_spam","a7806d87":"print(\"spam rate is about {0}%\".format(\n    round((ham_spam[1]\/float(ham_spam[0]+ham_spam[1]))*100), 2))","1d0ef091":"# mapping labels to 0 and 1\ndocs['label'] = docs.Class.map({'ham':0, 'spam':1})","252f43dd":"docs.head()","18620ff2":"# we can now drop the column 'Class'\ndocs = docs.drop('Class', axis=1)\ndocs.head()","42074eab":"# convert to X and y\nX = docs.sms\ny = docs.label\nprint(X.shape)\nprint(y.shape)","87b97eae":"# splitting into test and train\nfrom sklearn.model_selection  import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=1)","42e2f696":"X_train.head()","2e8e82fd":"y_train.head()","d17e0eb9":"# vectorizing the sentences; removing stop words\nfrom sklearn.feature_extraction.text import CountVectorizer\nvect = CountVectorizer(stop_words='english')","12e02583":"vect.fit(X_train)","ab590a52":"# printing the vocabulary\nvect.vocabulary_","52b261d9":"# vocab size\nlen(vect.vocabulary_.keys())","72109a66":"# transforming the train and test datasets\nX_train_transformed = vect.transform(X_train)\nX_test_transformed = vect.transform(X_test)","e608eba4":"# note that the type is transformed (sparse) matrix\nprint(type(X_train_transformed))\nprint(X_train_transformed)","c5579ead":"# training the NB model and making predictions\nfrom sklearn.naive_bayes import MultinomialNB\nmnb = MultinomialNB()\n\n# fit\nmnb.fit(X_train_transformed,y_train)\n\n# predict class\ny_pred_class = mnb.predict(X_test_transformed)\n\n# predict probabilities\ny_pred_proba = mnb.predict_proba(X_test_transformed)\n","0efadfe6":"# note that alpha=1 is used by default for smoothing\nmnb","7fa195bf":"# printing the overall accuracy\nfrom sklearn import metrics\nmetrics.accuracy_score(y_test, y_pred_class)","3e2f62ab":"# confusion matrix\nmetrics.confusion_matrix(y_test, y_pred_class)\n# help(metrics.confusion_matrix)","e75c8ee1":"confusion = metrics.confusion_matrix(y_test, y_pred_class)\nprint(confusion)\nTN = confusion[0, 0]\nFP = confusion[0, 1]\nFN = confusion[1, 0]\nTP = confusion[1, 1]","4f875ae7":"sensitivity = TP \/ float(FN + TP)\nprint(\"sensitivity\",sensitivity)","ffb264d9":"specificity = TN \/ float(TN + FP)\nprint(\"specificity\",specificity)","fccf0714":"precision = TP \/ float(TP + FP)\nprint(\"precision\",precision)\nprint(metrics.precision_score(y_test, y_pred_class))","588b55c0":"print(\"precision\",precision)\nprint(\"PRECISION SCORE :\",metrics.precision_score(y_test, y_pred_class))\nprint(\"RECALL SCORE :\", metrics.recall_score(y_test, y_pred_class))\nprint(\"F1 SCORE :\",metrics.f1_score(y_test, y_pred_class))","993a2c9b":"y_pred_class","1bc79b3f":"y_pred_proba","f029ae5b":"# creating an ROC curve\nfrom sklearn.metrics import confusion_matrix as sk_confusion_matrix\nfrom sklearn.metrics import roc_curve, auc\nimport matplotlib.pyplot as plt\n\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_pred_proba[:,1])\nroc_auc = auc(false_positive_rate, true_positive_rate)","cbbf5954":"# area under the curve\nprint (roc_auc)","7bad16f6":"# matrix of thresholds, tpr, fpr\npd.DataFrame({'Threshold': thresholds, \n              'TPR': true_positive_rate, \n              'FPR':false_positive_rate\n             })","925312c4":"# plotting the ROC curve\n%matplotlib inline  \nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')\nplt.title('ROC')\nplt.plot(false_positive_rate, true_positive_rate)","6a1ccec4":"### 1. Importing and Preprocessing Data","62f32c8d":"## SMS Spam Classifier: Multinomial Naive Bayes\n\nThe notebook is divided into the following sections:\n1. Importing and preprocessing data\n2. Building the model: Multinomial Naive Bayes\n    - Model building \n    - Model evaluation","1ab06e9d":"### Model Evaluation","33eae147":"### 2. Building and Evaluating the Model"}}