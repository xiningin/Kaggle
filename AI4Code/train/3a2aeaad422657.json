{"cell_type":{"7a9f1fb0":"code","525632de":"code","afb79702":"code","35d7e917":"code","72cbd4d4":"code","8a1f6271":"code","bd391b63":"code","8f9e176f":"code","d96cc924":"code","e58628ba":"code","cf4ce72c":"code","ff6df151":"code","e9168cb5":"code","60cbadc5":"code","89d465d6":"code","452f9975":"code","a1d5a90c":"code","c942aaab":"code","2f7ddb15":"code","6d2af537":"code","9f08cfff":"code","438f67a8":"code","77ea0af6":"code","44f2f51b":"code","c0f62951":"code","dc63d576":"code","69c0d9bc":"code","1fd9647c":"code","66691be0":"code","6562602c":"code","1db24850":"code","28fa8dc3":"code","09917822":"code","a1cdcf94":"code","8058a5b5":"code","f06d81ea":"code","20878892":"code","92ffa00b":"code","1bb7d4f5":"code","e5904d07":"code","354193c2":"code","20feb99f":"code","e549db56":"code","030b4b05":"code","158fda86":"code","fb0ba80d":"code","f0ba410d":"code","3f93cc90":"code","3461b81a":"code","9ece58ef":"code","6633133e":"code","c6b232a8":"code","18e9397c":"code","4e65466c":"code","51b49e19":"code","cac00237":"code","87dffb56":"code","512d8629":"code","99632c1a":"code","57c39baa":"code","b3198c56":"code","b8f36181":"code","d9610a56":"code","379d36cc":"code","1e2d80ec":"code","12bf792a":"code","be75a5bd":"code","a71e62f6":"code","d7e8e2a5":"code","8fe381f0":"code","50524f09":"code","373d0142":"code","95d3099e":"code","df2209dd":"code","d77737b5":"code","ef5dc7f9":"code","9972236f":"code","38504b93":"code","0750804d":"code","286c83ab":"code","8ab99559":"code","2cb716d0":"code","05f308e9":"code","be35f7c9":"code","d0351dda":"code","6c8f6cf9":"code","b7c57a8a":"code","93e756dd":"markdown","769f6932":"markdown","583071a4":"markdown","4c39997e":"markdown","4cae302d":"markdown","f6b16b4f":"markdown","e230481b":"markdown","2d9521b9":"markdown","26d33be8":"markdown","f260fb94":"markdown","5c6bcb9b":"markdown","4d612401":"markdown","5a3da971":"markdown","2437be23":"markdown","08c79187":"markdown","913c6a1f":"markdown","053d3d92":"markdown","ae9de6ca":"markdown","343df5de":"markdown","67593346":"markdown","811ef678":"markdown","d42af0fa":"markdown","487b010c":"markdown","1e9d8e0e":"markdown","0a3f0546":"markdown","2c71225a":"markdown","6985645a":"markdown","7263116d":"markdown","d6d8823b":"markdown","1dd8e38f":"markdown","a7fc83ed":"markdown","2200d6fc":"markdown","b8890713":"markdown","5ea66cdb":"markdown","48ee5475":"markdown","82de48a2":"markdown","c17e680d":"markdown","40a144a4":"markdown","86bf439a":"markdown","1cf8cf2c":"markdown","27dfe05d":"markdown","e6f57ce8":"markdown","17eb477a":"markdown","528b5d62":"markdown","22d7a305":"markdown","21674df5":"markdown","bed4f3ad":"markdown","7c97005c":"markdown","64e82911":"markdown","5d612c3b":"markdown","9a7a8277":"markdown","b07d068b":"markdown","72b09cbc":"markdown","f19864da":"markdown","fe977736":"markdown","a61339c0":"markdown","2ea30d6c":"markdown","739fdebf":"markdown","a3deee7e":"markdown","bba4b997":"markdown","8c9490d2":"markdown","97118618":"markdown","eecd1407":"markdown","d02b1f8c":"markdown","5540b11b":"markdown","ce524fd0":"markdown","8235d8ed":"markdown","d800bd89":"markdown","14088caf":"markdown","f5ce86b4":"markdown","31d365cc":"markdown","4d119736":"markdown","c91551e1":"markdown","d2b99a63":"markdown","6fd86c3c":"markdown","24ec2f5b":"markdown","8b08b4f3":"markdown","39d8ae18":"markdown"},"source":{"7a9f1fb0":"# Please switch on the TPU before running these lines.\n\n!curl https:\/\/raw.githubusercontent.com\/pytorch\/xla\/master\/contrib\/scripts\/env-setup.py -o pytorch-xla-env-setup.py\n!python pytorch-xla-env-setup.py --apt-packages libomp5 libopenblas-dev","525632de":"# Imports required to use TPUs with Pytorch.\n# https:\/\/pytorch.org\/xla\/release\/1.5\/index.html\n\nimport torch_xla\nimport torch_xla.core.xla_model as xm","afb79702":"import pandas as pd\nimport numpy as np\nimport os\nimport gc\n\nimport random\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch.nn.functional as F\nfrom torch.utils.data import Dataset, DataLoader\n\n# set a seed value\ntorch.manual_seed(555)\n\nfrom sklearn.utils import shuffle\nfrom sklearn.metrics import roc_auc_score, accuracy_score\n\nimport transformers\nfrom transformers import BertTokenizer, BertForSequenceClassification \nfrom transformers import XLMRobertaTokenizer, XLMRobertaForSequenceClassification\nfrom transformers import AdamW\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n\nprint(torch.__version__)","35d7e917":"from transformers import XLMRobertaTokenizer, XLMRobertaForSequenceClassification\n\nMODEL_TYPE = 'xlm-roberta-base'\n\ntokenizer = XLMRobertaTokenizer.from_pretrained(MODEL_TYPE)","72cbd4d4":"# Check the vocab size\n\ntokenizer.vocab_size","8a1f6271":"# What are the special tokens\n\ntokenizer.special_tokens_map","bd391b63":"print('bos_token_id <s>:', tokenizer.bos_token_id)\nprint('eos_token_id <\/s>:', tokenizer.eos_token_id)\nprint('sep_token_id <\/s>:', tokenizer.sep_token_id)\nprint('pad_token_id <pad>:', tokenizer.pad_token_id)","8f9e176f":"# from transformers import XLMRobertaForSequenceClassification\n\n# MODEL_TYPE = 'xlm-roberta-base'\n\n# model = XLMRobertaForSequenceClassification.from_pretrained(\n#                  MODEL_TYPE, \n#                  num_labels = 3 # The number of output labels. 2 for binary classification.\n#               )\n\n\n# outputs = model(input_ids=b_input_ids, \n#                 attention_mask=b_input_mask, \n#                 labels=b_labels)\n\n\n\n# These are the model inputs:\n#   input_ids (type: torch tensor)\n#   attention_mask (type: torch tensor)\n#   labels (type: torch tensor)","d96cc924":"# 1. input_ids\n# -------------\n\n# The input_ids are the sentence or sentences represented as tokens. \n# These are special tokens:\n\n# bos_token_id <s>: 0\n# eos_token_id <\/s>: 2\n# sep_token_id <\/s>: 2\n# pad_token_id <pad>: 1\n    \n    \n# XLM-RoBERTa expects every row in the input_ids to have the special tokens included as follows:\n\n# For one sentence as input:\n# <s> ...word tokens... <\/s>\n\n# For two sentences as input:<br>\n# <s> ...sentence1 tokens... <\/s><\/s>..sentence2 tokens... <\/s>\n\n\n# This is an example of an encoded sentence with padding (pad token value: 1). \n\n# [0, 35378, 2685, 5, 2, 1, 1, 1, 1, 1]\n\n\n\n\n# 2. token_type_ids\n# ------------------\n\n# XLM-RoBERTa does not use token_type_ids like BERT does.\n# Therefore, there's no need to create token_type_ids.\n\n\n\n# 3. attention_mask\n# ------------------\n\n# The attention mask has the same length as the input_ids. \n# It tells the model which tokens in the input_ids are works and which are padding. \n# 1 indicates a word (or special token) and 0 indicates padding.\n\n# For example, the attention mask for the above input_ids is as follows:\n# [1, 1, 1, 1, 1, 0, 0, 0, 0, 0]\n\n\n# 3. labels\n# ----------\n\n# The label (target) for each row in the input_ids. \n# The labels are integers representing each target class e.g. 1, 2, 3 etc.\n\n# For example if we have three target classes (0, 1 and 2) then\n# the labels could look like this for a batch size of 8:\n\n# [0, 2, 0, 1, 2, 0, 3, 1]","e58628ba":"MAX_LEN = 10 # This value could be set as 256, 512 etc.\n\nsentence1 = 'Hello there.'\n\nencoded_dict = tokenizer.encode_plus(\n            sentence1,                \n            add_special_tokens = True,\n            max_length = MAX_LEN,     \n            pad_to_max_length = True,\n            return_attention_mask = True,  \n            return_tensors = 'pt' # return pytorch tensors\n       )\n\n\nencoded_dict","cf4ce72c":"# These have already been converted to torch tensors.\ninput_ids = encoded_dict['input_ids'][0]\natt_mask = encoded_dict['attention_mask'][0]\n\nprint(input_ids)\nprint(att_mask)","ff6df151":"MAX_LEN = 15\n\nsentence1 = 'Hello there.'\nsentence2 = 'How are you?'\n\nencoded_dict = tokenizer.encode_plus(\n            sentence1, sentence2,      \n            add_special_tokens = True,\n            max_length = MAX_LEN,     \n            pad_to_max_length = True,\n            return_attention_mask = True,   \n            return_tensors = 'pt' # return pytorch tensors\n       )\n\n\nencoded_dict","e9168cb5":"input_ids = encoded_dict['input_ids'][0]\natt_mask = encoded_dict['attention_mask'][0]\n\n# These are torch tensors.\nprint(input_ids)\nprint(att_mask)","60cbadc5":"# input_ids from above\n\ninput_ids = encoded_dict['input_ids'][0]\n\nprint(input_ids)","89d465d6":"# https:\/\/huggingface.co\/transformers\/main_classes\/tokenizer.html\n# skip_special_tokens \u2013 if set to True, will replace special tokens.\n\na = tokenizer.decode(input_ids,\n                skip_special_tokens=False)\n\nb = tokenizer.decode(input_ids,\n                skip_special_tokens=True)\n\n\n\nprint(a)\nprint(b)","452f9975":"MAX_LEN = 15 # This value could be set as 256, 512 etc.\n\nsentence1 = 'Hello there. How are you? Have a nice day. This is a test?'\n\n\nencoded_dict = tokenizer.encode_plus(\n            sentence1,                \n            max_length = MAX_LEN,\n            stride=0,\n            pad_to_max_length = True,\n            return_overflowing_tokens=True,\n       )\n\n\nencoded_dict","a1d5a90c":"MAX_LEN = 15 # This value could be set as 256, 512 etc.\n\nsentence1 = 'Hello there. How are you? Have a nice day. This is a test?'\n\n\nencoded_dict = tokenizer.encode_plus(\n            sentence1,                \n            max_length = MAX_LEN,\n            stride=3,\n            pad_to_max_length = True,\n            return_overflowing_tokens=True,\n       )\n\n\nencoded_dict","c942aaab":"# Here you can see the overlap.\n\nprint(encoded_dict['input_ids'])\nprint(encoded_dict['overflowing_tokens'])","2f7ddb15":"os.listdir('..\/input\/contradictory-my-dear-watson')","6d2af537":"# Load the training data.\n\npath = '..\/input\/contradictory-my-dear-watson\/train.csv'\ndf_train = pd.read_csv(path)\n\nprint(df_train.shape)\n\ndf_train.head()","9f08cfff":"# Load the test data.\n\npath = '..\/input\/contradictory-my-dear-watson\/test.csv'\ndf_test = pd.read_csv(path)\n\nprint(df_test.shape)\n\ndf_test.head()","438f67a8":"from sklearn.model_selection import KFold, StratifiedKFold\n\n# shuffle\ndf = shuffle(df_train)\n\n# initialize kfold\nkf = StratifiedKFold(n_splits=5, shuffle=True, random_state=1024)\n\n# for stratification\ny = df['label']\n\n# Note:\n# Each fold is a tuple ([train_index_values], [val_index_values])\n# fold_0, fold_1, fold_2, fold_3, fold_5 = kf.split(df, y)\n\n# Put the folds into a list. This is a list of tuples.\nfold_list = list(kf.split(df, y))\n\ntrain_df_list = []\nval_df_list = []\n\nfor i, fold in enumerate(fold_list):\n\n    # map the train and val index values to dataframe rows\n    df_train = df[df.index.isin(fold[0])]\n    df_val = df[df.index.isin(fold[1])]\n    \n    train_df_list.append(df_train)\n    val_df_list.append(df_val)\n    \n    \n\nprint(len(train_df_list))\nprint(len(val_df_list))","77ea0af6":"# Display one train fold\n\ndf_train = train_df_list[0]\n\ndf_train.head()","44f2f51b":"# Display one val fold\n\ndf_val = val_df_list[0]\n\ndf_val.head()","c0f62951":"MODEL_TYPE = 'bert-base-multilingual-uncased'\n\nNUM_FOLDS = 5\n\n# Saving 5 TPU models will exceed the 4.9GB disk space.\n# Therefore, will will only train on 3 folds.\nNUM_FOLDS_TO_TRAIN = 3 \n\nL_RATE = 1e-5\nMAX_LEN = 256\nNUM_EPOCHS = 3\nBATCH_SIZE = 32\nNUM_CORES = os.cpu_count()\n\nNUM_CORES","dc63d576":"# For GPU\n\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n\nprint(device)","69c0d9bc":"\"\"\"# For TPU\n\ndevice = xm.xla_device()\n\nprint(device)\"\"\"","1fd9647c":"from transformers import BertTokenizer\n\n# Load the BERT tokenizer.\nprint('Loading BERT tokenizer...')\ntokenizer = BertTokenizer.from_pretrained(MODEL_TYPE, do_lower_case=True)","66691be0":"\nclass CompDataset(Dataset):\n\n    def __init__(self, df):\n        self.df_data = df\n\n\n\n    def __getitem__(self, index):\n\n        # get the sentence from the dataframe\n        sentence1 = self.df_data.loc[index, 'premise']\n        sentence2 = self.df_data.loc[index, 'hypothesis']\n\n        # Process the sentence\n        # ---------------------\n\n        encoded_dict = tokenizer.encode_plus(\n                    sentence1, sentence2,           # Sentences to encode.\n                    add_special_tokens = True,      # Add '[CLS]' and '[SEP]'\n                    max_length = MAX_LEN,           # Pad or truncate all sentences.\n                    pad_to_max_length = True,\n                    return_attention_mask = True,   # Construct attn. masks.\n                    return_tensors = 'pt',          # Return pytorch tensors.\n               )  \n        \n        # These are torch tensors already.\n        padded_token_list = encoded_dict['input_ids'][0]\n        att_mask = encoded_dict['attention_mask'][0]\n        token_type_ids = encoded_dict['token_type_ids'][0]\n        \n        # Convert the target to a torch tensor\n        target = torch.tensor(self.df_data.loc[index, 'label'])\n\n        sample = (padded_token_list, att_mask, token_type_ids, target)\n\n\n        return sample\n\n\n    def __len__(self):\n        return len(self.df_data)\n    \n    \n    \n    \n    \n\nclass TestDataset(Dataset):\n\n    def __init__(self, df):\n        self.df_data = df\n\n\n\n    def __getitem__(self, index):\n\n        # get the sentence from the dataframe\n        sentence1 = self.df_data.loc[index, 'premise']\n        sentence2 = self.df_data.loc[index, 'hypothesis']\n\n        # Process the sentence\n        # ---------------------\n\n        encoded_dict = tokenizer.encode_plus(\n                    sentence1, sentence2,           # Sentence to encode.\n                    add_special_tokens = True,      # Add '[CLS]' and '[SEP]'\n                    max_length = MAX_LEN,           # Pad or truncate all sentences.\n                    pad_to_max_length = True,\n                    return_attention_mask = True,   # Construct attn. masks.\n                    return_tensors = 'pt',          # Return pytorch tensors.\n               )\n        \n        # These are torch tensors already.\n        padded_token_list = encoded_dict['input_ids'][0]\n        att_mask = encoded_dict['attention_mask'][0]\n        token_type_ids = encoded_dict['token_type_ids'][0]\n               \n\n        sample = (padded_token_list, att_mask, token_type_ids)\n\n\n        return sample\n\n\n    def __len__(self):\n        return len(self.df_data)\n\n","6562602c":"df_train = df_train.reset_index(drop=True)\ndf_val = df_val.reset_index(drop=True)","1db24850":"train_data = CompDataset(df_train)\nval_data = CompDataset(df_val)\ntest_data = TestDataset(df_test)\n\n\n\ntrain_dataloader = torch.utils.data.DataLoader(train_data,\n                                        batch_size=BATCH_SIZE,\n                                        shuffle=True,\n                                       num_workers=NUM_CORES)\n\nval_dataloader = torch.utils.data.DataLoader(val_data,\n                                        batch_size=BATCH_SIZE,\n                                        shuffle=True,\n                                       num_workers=NUM_CORES)\n\ntest_dataloader = torch.utils.data.DataLoader(test_data,\n                                        batch_size=BATCH_SIZE,\n                                        shuffle=False,\n                                       num_workers=NUM_CORES)\n\n\n\nprint(len(train_dataloader))\nprint(len(val_dataloader))\nprint(len(test_dataloader))","28fa8dc3":"# Get one train batch\n\npadded_token_list, att_mask, token_type_ids, target = next(iter(train_dataloader))\n\nprint(padded_token_list.shape)\nprint(att_mask.shape)\nprint(token_type_ids.shape)\nprint(target.shape)","09917822":"# Get one val batch\n\npadded_token_list, att_mask, token_type_ids, target = next(iter(val_dataloader))\n\nprint(padded_token_list.shape)\nprint(att_mask.shape)\nprint(token_type_ids.shape)\nprint(target.shape)","a1cdcf94":"# Get one test batch\n\npadded_token_list, att_mask, token_type_ids = next(iter(test_dataloader))\n\nprint(padded_token_list.shape)\nprint(att_mask.shape)\nprint(token_type_ids.shape)","8058a5b5":"# Load BertForSequenceClassification, the pretrained BERT model with a single \n# linear classification layer on top. \nmodel = BertForSequenceClassification.from_pretrained(\n    MODEL_TYPE, \n    num_labels = 3, \n    output_attentions = False,\n    output_hidden_states = False)\n\n# Send the model to the device.\nmodel.to(device)","f06d81ea":"# Get one train batch\n\ntrain_dataloader = torch.utils.data.DataLoader(train_data,\n                                        batch_size=8,\n                                        shuffle=True,\n                                       num_workers=NUM_CORES)\n\nbatch = next(iter(train_dataloader))\n\nb_input_ids = batch[0].to(device)\nb_input_mask = batch[1].to(device)\nb_token_type_ids = batch[2].to(device)\nb_labels = batch[3].to(device)","20878892":"outputs = model(b_input_ids, \n                token_type_ids=b_token_type_ids, \n                attention_mask=b_input_mask,\n                labels=b_labels)","92ffa00b":"outputs","1bb7d4f5":"# The output is a tuple: (loss, preds)\n\nlen(outputs)","e5904d07":"# This is the loss.\n\noutputs[0]","354193c2":"# These are the predictions.\n\noutputs[1]","20feb99f":"preds = outputs[1].detach().cpu().numpy()\n\ny_true = b_labels.detach().cpu().numpy()\ny_pred = np.argmax(preds, axis=1)\n\ny_pred","e549db56":"# This is the accuracy without any fine tuning.\n\nval_acc = accuracy_score(y_true, y_pred)\n\nval_acc","030b4b05":"# The loss and preds are Torch tensors\n\nprint(type(outputs[0]))\nprint(type(outputs[1]))","158fda86":"# For info: \n# Think in terms of fold models.\n# Fold model 0, for example, is only training on fold 0 in each epoch.\n# The same applies to the other fold models.","fb0ba80d":"%%time\n\n\n# Set a seed value.\nseed_val = 1024\n\nrandom.seed(seed_val)\nnp.random.seed(seed_val)\ntorch.manual_seed(seed_val)\ntorch.cuda.manual_seed_all(seed_val)\n\n\n\n# Store the accuracy scores for each fold model in this list.\n# [[model_0 scores], [model_1 scores], [model_2 scores], [model_3 scores], [model_4 scores]]\n# [[ecpoch 1, epoch 2, ...], [ecpoch 1, epoch 2, ...], [ecpoch 1, epoch 2, ...], [ecpoch 1, epoch 2, ...], [ecpoch 1, epoch 2, ...]]\n\n# Create a list of lists to store the val acc results.\n# The number of items in this list will correspond to\n# the number of folds that the model is being trained on.\nfold_val_acc_list = []\nfor i in range(0, NUM_FOLDS):\n    \n    # append an empty list\n    fold_val_acc_list.append([])\n    \n    \n    \n    \n\n# For each epoch...\nfor epoch in range(0, NUM_EPOCHS):\n    \n    print(\"\\nNum folds used for training:\", NUM_FOLDS_TO_TRAIN)\n    print('======== Epoch {:} \/ {:} ========'.format(epoch + 1, NUM_EPOCHS))\n    \n    # Get the number of folds\n    num_folds = len(train_df_list)\n\n    # For this epoch, store the val acc scores for each fold in this list.\n    # We will use this list to calculate the cv at the end of the epoch.\n    epoch_acc_scores_list = []\n    \n    # For each fold...\n    for fold_index in range(0, NUM_FOLDS_TO_TRAIN):\n        \n        print('\\n== Fold Model', fold_index)\n        \n        \n        # .........................\n        # Load the fold model\n        # .........................\n        \n        if epoch == 0:\n            \n            # define the model\n            model = BertForSequenceClassification.from_pretrained(\n            MODEL_TYPE, \n            num_labels = 3,       \n            output_attentions = False, \n            output_hidden_states = False,\n            )\n            \n            # Send the model to the device.\n            model.to(device)\n            \n            optimizer = AdamW(model.parameters(),\n              lr = L_RATE, \n              eps = 1e-8\n            )\n            \n        else:\n        \n            # Get the fold model\n            path_model = 'model_' + str(fold_index) + '.bin'\n            model.load_state_dict(torch.load(path_model))\n\n            # Send the model to the device.\n            model.to(device)\n        \n        \n        \n        # .....................................\n        # Set up the train and val dataloaders\n        # .....................................\n        \n        \n        # Intialize the fold dataframes\n        df_train = train_df_list[fold_index]\n        df_val = val_df_list[fold_index]\n        \n        # Reset the indices or the dataloader won't work.\n        df_train = df_train.reset_index(drop=True)\n        df_val = df_val.reset_index(drop=True)\n    \n        # Create the dataloaders\n        train_data = CompDataset(df_train)\n        val_data = CompDataset(df_val)\n\n        train_dataloader = torch.utils.data.DataLoader(train_data,\n                                                batch_size=BATCH_SIZE,\n                                                shuffle=True,\n                                               num_workers=NUM_CORES)\n\n        val_dataloader = torch.utils.data.DataLoader(val_data,\n                                                batch_size=BATCH_SIZE,\n                                                shuffle=True,\n                                               num_workers=NUM_CORES)\n    \n    \n    \n\n       \n\n        # ========================================\n        #               Training\n        # ========================================\n        \n        stacked_val_labels = []\n        targets_list = []\n\n        print('Training...')\n\n        # put the model into train mode\n        model.train()\n\n        # This turns gradient calculations on and off.\n        torch.set_grad_enabled(True)\n\n\n        # Reset the total loss for this epoch.\n        total_train_loss = 0\n\n        for i, batch in enumerate(train_dataloader):\n\n            train_status = 'Batch ' + str(i+1) + ' of ' + str(len(train_dataloader))\n\n            print(train_status, end='\\r')\n\n\n            b_input_ids = batch[0].to(device)\n            b_input_mask = batch[1].to(device)\n            b_token_type_ids = batch[2].to(device)\n            b_labels = batch[3].to(device)\n\n            model.zero_grad()        \n\n\n            outputs = model(b_input_ids, \n                        token_type_ids=b_token_type_ids, \n                        attention_mask=b_input_mask,\n                        labels=b_labels)\n\n            # Get the loss from the outputs tuple: (loss, logits)\n            loss = outputs[0]\n\n            # Convert the loss from a torch tensor to a number.\n            # Calculate the total loss.\n            total_train_loss = total_train_loss + loss.item()\n\n            # Zero the gradients\n            optimizer.zero_grad()\n\n            # Perform a backward pass to calculate the gradients.\n            loss.backward()\n            \n            # Clip the norm of the gradients to 1.0.\n            # This is to help prevent the \"exploding gradients\" problem.\n            torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n\n            # Use the optimizer to update Weights\n            \n            # Optimizer for GPU\n            # optimizer.step() \n            \n            # Optimizer for TPU\n            # https:\/\/pytorch.org\/xla\/\n            xm.optimizer_step(optimizer, barrier=True)\n            \n           \n\n\n        print('Train loss:' ,total_train_loss)\n\n\n        # ========================================\n        #               Validation\n        # ========================================\n\n        print('\\nValidation...')\n\n        # Put the model in evaluation mode.\n        model.eval()\n\n        # Turn off the gradient calculations.\n        # This tells the model not to compute or store gradients.\n        # This step saves memory and speeds up validation.\n        torch.set_grad_enabled(False)\n\n\n        # Reset the total loss for this epoch.\n        total_val_loss = 0\n\n\n        for j, val_batch in enumerate(val_dataloader):\n\n            val_status = 'Batch ' + str(j+1) + ' of ' + str(len(val_dataloader))\n\n            print(val_status, end='\\r')\n\n            b_input_ids = val_batch[0].to(device)\n            b_input_mask = val_batch[1].to(device)\n            b_token_type_ids = val_batch[2].to(device)\n            b_labels = val_batch[3].to(device)      \n\n\n            outputs = model(b_input_ids, \n                    token_type_ids=b_token_type_ids, \n                    attention_mask=b_input_mask, \n                    labels=b_labels)\n\n            # Get the loss from the outputs tuple: (loss, logits)\n            loss = outputs[0]\n\n            # Convert the loss from a torch tensor to a number.\n            # Calculate the total loss.\n            total_val_loss = total_val_loss + loss.item()\n\n            # Get the preds\n            preds = outputs[1]\n\n\n            # Move preds to the CPU\n            val_preds = preds.detach().cpu().numpy()\n\n            # Move the labels to the cpu\n            targets_np = b_labels.to('cpu').numpy()\n\n            # Append the labels to a numpy list\n            targets_list.extend(targets_np)\n\n            if j == 0:  # first batch\n                stacked_val_preds = val_preds\n\n            else:\n                stacked_val_preds = np.vstack((stacked_val_preds, val_preds))\n                \n                \n                \n        # .........................................\n        # Calculate the val accuracy for this fold\n        # .........................................      \n\n\n        # Calculate the validation accuracy\n        y_true = targets_list\n        y_pred = np.argmax(stacked_val_preds, axis=1)\n\n        val_acc = accuracy_score(y_true, y_pred)\n        \n        \n        epoch_acc_scores_list.append(val_acc)\n\n\n        print('Val loss:' ,total_val_loss)\n        print('Val acc: ', val_acc)\n        \n        \n        # .........................\n        # Save the best model\n        # .........................\n        \n        if epoch == 0:\n            \n            # Save the Model\n            model_name = 'model_' + str(fold_index) + '.bin'\n            torch.save(model.state_dict(), model_name)\n            print('Saved model as ', model_name)\n            \n        if epoch != 0:\n        \n            val_acc_list = fold_val_acc_list[fold_index]\n            best_val_acc = max(val_acc_list)\n            \n            if val_acc > best_val_acc:\n                # save the model\n                model_name = 'model_' + str(fold_index) + '.bin'\n                torch.save(model.state_dict(), model_name)\n                print('Val acc improved. Saved model as ', model_name)\n                \n                \n                \n        # .....................................\n        # Save the val_acc for this fold model\n        # .....................................\n        \n        # Note: Don't do this before the above 'Save Model' code or \n        # the save model code won't work. This is because the best_val_acc will\n        # become current val accuracy.\n                \n        # fold_val_acc_list is a list of lists.\n        # Each fold model has it's own list corresponding to the fold index.\n        # Here we choose a list corresponding to the fold number and append the acc score to that list.\n        fold_val_acc_list[fold_index].append(val_acc)\n        \n            \n\n        # Use the garbage collector to save memory.\n        gc.collect()\n        \n        \n    # .............................................................\n    # Calculate the CV accuracy score over all folds in this epoch\n    # .............................................................   \n        \n        \n    # Print the average val accuracy for all 5 folds\n    cv_acc = sum(epoch_acc_scores_list)\/NUM_FOLDS_TO_TRAIN\n    print(\"\\nCV Acc:\", cv_acc)\n    \n","f0ba410d":"# Check that the models have been saved\n\n!ls","3f93cc90":"# Display the accuracy scores for each fold model.\n# For info: \n# Fold model 0 is only training on fold 0 in each epoch.\n# The same applies to the other fold models.\n\nfold_val_acc_list","3461b81a":"# Create the dataloader\n\ntest_data = TestDataset(df_test)\n\n\ntest_dataloader = torch.utils.data.DataLoader(test_data,\n                                        batch_size=BATCH_SIZE,\n                                        shuffle=False,\n                                       num_workers=NUM_CORES)\n\nprint(len(test_dataloader))","9ece58ef":"# ========================================\n#               Test Set\n# ========================================\n\nprint('\\nTest Set...')\n\nmodel_preds_list = []\n\nprint('Total batches:', len(test_dataloader))\n\nfor fold_index in range(0, NUM_FOLDS_TO_TRAIN):\n    \n    print('\\nFold Model', fold_index)\n\n    # Load the fold model\n    path_model = 'model_' + str(fold_index) + '.bin'\n    model.load_state_dict(torch.load(path_model))\n\n    # Send the model to the device.\n    model.to(device)\n\n\n    stacked_val_labels = []\n    \n\n    # Put the model in evaluation mode.\n    model.eval()\n\n    # Turn off the gradient calculations.\n    # This tells the model not to compute or store gradients.\n    # This step saves memory and speeds up validation.\n    torch.set_grad_enabled(False)\n\n\n    # Reset the total loss for this epoch.\n    total_val_loss = 0\n\n    for j, h_batch in enumerate(test_dataloader):\n\n        inference_status = 'Batch ' + str(j + 1)\n\n        print(inference_status, end='\\r')\n\n        b_input_ids = h_batch[0].to(device)\n        b_input_mask = h_batch[1].to(device)\n        b_token_type_ids = h_batch[2].to(device)     \n\n\n        outputs = model(b_input_ids, \n                token_type_ids=b_token_type_ids, \n                attention_mask=b_input_mask)\n\n\n        # Get the preds\n        preds = outputs[0]\n\n\n        # Move preds to the CPU\n        val_preds = preds.detach().cpu().numpy()\n        \n        \n        # Stack the predictions.\n\n        if j == 0:  # first batch\n            stacked_val_preds = val_preds\n\n        else:\n            stacked_val_preds = np.vstack((stacked_val_preds, val_preds))\n\n        \n    model_preds_list.append(stacked_val_preds)\n    \n            \nprint('\\nPrediction complete.')        ","6633133e":"model_preds_list","c6b232a8":"# Sum the predictions of all fold models\nfor i, item in enumerate(model_preds_list):\n    \n    if i == 0:\n        \n        preds = item\n        \n    else:\n    \n        # Sum the matrices\n        preds = item + preds\n\n        \n# Average the predictions\navg_preds = preds\/(len(model_preds_list))\n\n\ntest_preds = np.argmax(avg_preds, axis=1)","18e9397c":"test_preds","4e65466c":"# Load the sample submission.\n# The row order in the test set and the sample submission is the same.\n\npath = '..\/input\/contradictory-my-dear-watson\/sample_submission.csv'\n\ndf_sample = pd.read_csv(path)\n\nprint(df_sample.shape)\n\ndf_sample.head()","51b49e19":"MODEL_TYPE = 'xlm-roberta-base'\n\n\nL_RATE = 1e-5\nMAX_LEN = 256\n\nNUM_EPOCHS = 3\nBATCH_SIZE = 32\nNUM_CORES = os.cpu_count()\n\nNUM_CORES","cac00237":"#device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n\n#print(device)","87dffb56":"# Tell PyTorch to use the TPU.    \ndevice = xm.xla_device()\n\nprint(device)","512d8629":"df_train = train_df_list[0]\n\ndf_train.head()","99632c1a":"df_val = val_df_list[0]\n\ndf_val.head()","57c39baa":"from transformers import XLMRobertaTokenizer, XLMRobertaForSequenceClassification\n\n# xlm-roberta-large\nprint('Loading XLMRoberta tokenizer...')\ntokenizer = XLMRobertaTokenizer.from_pretrained(MODEL_TYPE)","b3198c56":"df_train = df_train.reset_index(drop=True)\ndf_val = df_val.reset_index(drop=True)","b8f36181":"class CompDataset(Dataset):\n\n    def __init__(self, df):\n        self.df_data = df\n\n\n\n    def __getitem__(self, index):\n\n        # get the sentence from the dataframe\n        sentence1 = self.df_data.loc[index, 'premise']\n        sentence2 = self.df_data.loc[index, 'hypothesis']\n\n        # Process the sentence\n        # ---------------------\n\n        encoded_dict = tokenizer.encode_plus(\n                    sentence1, sentence2,           # Sentences to encode.\n                    add_special_tokens = True,      # Add the special tokens.\n                    max_length = MAX_LEN,           # Pad & truncate all sentences.\n                    pad_to_max_length = True,\n                    return_attention_mask = True,   # Construct attn. masks.\n                    return_tensors = 'pt',          # Return pytorch tensors.\n               )\n        \n        # These are torch tensors.\n        padded_token_list = encoded_dict['input_ids'][0]\n        att_mask = encoded_dict['attention_mask'][0]\n        \n        # Convert the target to a torch tensor\n        target = torch.tensor(self.df_data.loc[index, 'label'])\n\n        sample = (padded_token_list, att_mask, target)\n\n\n        return sample\n\n\n    def __len__(self):\n        return len(self.df_data)\n    \n    \n    \n    \n    \n\nclass TestDataset(Dataset):\n\n    def __init__(self, df):\n        self.df_data = df\n\n\n\n    def __getitem__(self, index):\n\n        # get the sentence from the dataframe\n        sentence1 = self.df_data.loc[index, 'premise']\n        sentence2 = self.df_data.loc[index, 'hypothesis']\n\n        # Process the sentence\n        # ---------------------\n\n        encoded_dict = tokenizer.encode_plus(\n                    sentence1, sentence2,           # Sentence to encode.\n                    add_special_tokens = True,      # Add the special tokens.\n                    max_length = MAX_LEN,           # Pad & truncate all sentences.\n                    pad_to_max_length = True,\n                    return_attention_mask = True,   # Construct attn. masks.\n                    return_tensors = 'pt',          # Return pytorch tensors.\n               )\n        \n        # These are torch tensors.\n        padded_token_list = encoded_dict['input_ids'][0]\n        att_mask = encoded_dict['attention_mask'][0]\n        \n               \n\n        sample = (padded_token_list, att_mask)\n\n\n        return sample\n\n\n    def __len__(self):\n        return len(self.df_data)","d9610a56":"train_data = CompDataset(df_train)\nval_data = CompDataset(df_val)\ntest_data = TestDataset(df_test)\n\ntrain_dataloader = torch.utils.data.DataLoader(train_data,\n                                        batch_size=BATCH_SIZE,\n                                        shuffle=True,\n                                       num_workers=NUM_CORES)\n\nval_dataloader = torch.utils.data.DataLoader(val_data,\n                                        batch_size=BATCH_SIZE,\n                                        shuffle=True,\n                                       num_workers=NUM_CORES)\n\ntest_dataloader = torch.utils.data.DataLoader(test_data,\n                                        batch_size=BATCH_SIZE,\n                                        shuffle=False,\n                                       num_workers=NUM_CORES)\n\n\n\nprint(len(train_dataloader))\nprint(len(val_dataloader))\nprint(len(test_dataloader))","379d36cc":"# Get one train batch\n\npadded_token_list, att_mask, target = next(iter(train_dataloader))\n\nprint(padded_token_list.shape)\nprint(att_mask.shape)\nprint(target.shape)","1e2d80ec":"# Get one val batch\n\npadded_token_list, att_mask, target = next(iter(val_dataloader))\n\nprint(padded_token_list.shape)\nprint(att_mask.shape)\nprint(target.shape)","12bf792a":"# Get one test batch\n\npadded_token_list, att_mask = next(iter(test_dataloader))\n\nprint(padded_token_list.shape)\nprint(att_mask.shape)","be75a5bd":"from transformers import XLMRobertaForSequenceClassification\n\nmodel = XLMRobertaForSequenceClassification.from_pretrained(\n    MODEL_TYPE, \n    num_labels = 3, # The number of output labels. 2 for binary classification.\n)\n\n# Send the model to the device.\nmodel.to(device)","a71e62f6":"# Create a batch of train samples\n# We will set a small batch size of 8 so that the model's output can be easily displayed.\n\ntrain_dataloader = torch.utils.data.DataLoader(train_data,\n                                        batch_size=8,\n                                        shuffle=True,\n                                       num_workers=NUM_CORES)\n\nb_input_ids, b_input_mask, b_labels = next(iter(train_dataloader))\n\nprint(b_input_ids.shape)\nprint(b_input_mask.shape)\nprint(b_labels.shape)","d7e8e2a5":"# Pass a batch of train samples to the model.\n\nbatch = next(iter(train_dataloader))\n\n# Send the data to the device\nb_input_ids = batch[0].to(device)\nb_input_mask = batch[1].to(device)\nb_labels = batch[2].to(device)\n\n# Run the model\noutputs = model(b_input_ids, \n                        attention_mask=b_input_mask, \n                        labels=b_labels)\n\n# The ouput is a tuple (loss, preds).\noutputs","8fe381f0":"outputs","50524f09":"# The output is a tuple: (loss, preds)\n\nlen(outputs)","373d0142":"# This is the loss.\n\noutputs[0]","95d3099e":"# These are the predictions.\n\noutputs[1]","df2209dd":"preds = outputs[1].detach().cpu().numpy()\n\ny_true = b_labels.detach().cpu().numpy()\ny_pred = np.argmax(preds, axis=1)\n\ny_pred","d77737b5":"# This is the accuracy without fine tuning.\n\nval_acc = accuracy_score(y_true, y_pred)\n\nval_acc","ef5dc7f9":"# The loss and preds are Torch tensors\n\nprint(type(outputs[0]))\nprint(type(outputs[1]))","9972236f":"# Define the optimizer\noptimizer = AdamW(model.parameters(),\n              lr = L_RATE, \n              eps = 1e-8 \n            )","38504b93":"# Create the dataloaders.\n\ntrain_data = CompDataset(df_train)\nval_data = CompDataset(df_val)\ntest_data = TestDataset(df_test)\n\ntrain_dataloader = torch.utils.data.DataLoader(train_data,\n                                        batch_size=BATCH_SIZE,\n                                        shuffle=True,\n                                       num_workers=NUM_CORES)\n\nval_dataloader = torch.utils.data.DataLoader(val_data,\n                                        batch_size=BATCH_SIZE,\n                                        shuffle=True,\n                                       num_workers=NUM_CORES)\n\ntest_dataloader = torch.utils.data.DataLoader(test_data,\n                                        batch_size=BATCH_SIZE,\n                                        shuffle=False,\n                                       num_workers=NUM_CORES)\n\n\n\nprint(len(train_dataloader))\nprint(len(val_dataloader))\nprint(len(test_dataloader))","0750804d":"%%time\n\n\n# Set the seed.\nseed_val = 101\n\nrandom.seed(seed_val)\nnp.random.seed(seed_val)\ntorch.manual_seed(seed_val)\ntorch.cuda.manual_seed_all(seed_val)\n\n# Store the average loss after each epoch so we can plot them.\nloss_values = []\n\n\n# For each epoch...\nfor epoch in range(0, NUM_EPOCHS):\n    \n    print(\"\")\n    print('======== Epoch {:} \/ {:} ========'.format(epoch + 1, NUM_EPOCHS))\n    \n\n    stacked_val_labels = []\n    targets_list = []\n\n    # ========================================\n    #               Training\n    # ========================================\n    \n    print('Training...')\n    \n    # put the model into train mode\n    model.train()\n    \n    # This turns gradient calculations on and off.\n    torch.set_grad_enabled(True)\n\n\n    # Reset the total loss for this epoch.\n    total_train_loss = 0\n\n    for i, batch in enumerate(train_dataloader):\n        \n        train_status = 'Batch ' + str(i) + ' of ' + str(len(train_dataloader))\n        \n        print(train_status, end='\\r')\n\n\n        b_input_ids = batch[0].to(device)\n        b_input_mask = batch[1].to(device)\n        b_labels = batch[2].to(device)\n\n        model.zero_grad()        \n\n\n        outputs = model(b_input_ids, \n                    attention_mask=b_input_mask,\n                    labels=b_labels)\n        \n        # Get the loss from the outputs tuple: (loss, logits)\n        loss = outputs[0]\n        \n        # Convert the loss from a torch tensor to a number.\n        # Calculate the total loss.\n        total_train_loss = total_train_loss + loss.item()\n        \n        # Zero the gradients\n        optimizer.zero_grad()\n        \n        # Perform a backward pass to calculate the gradients.\n        loss.backward()\n        \n        \n        # Clip the norm of the gradients to 1.0.\n        # This is to help prevent the \"exploding gradients\" problem.\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        \n        \n        \n        # Use the optimizer to update the weights.\n        \n        # Optimizer for GPU\n        # optimizer.step() \n        \n        # Optimizer for TPU\n        # https:\/\/pytorch.org\/xla\/\n        xm.optimizer_step(optimizer, barrier=True)\n\n    \n    print('Train loss:' ,total_train_loss)\n\n\n    # ========================================\n    #               Validation\n    # ========================================\n    \n    print('\\nValidation...')\n\n    # Put the model in evaluation mode.\n    model.eval()\n\n    # Turn off the gradient calculations.\n    # This tells the model not to compute or store gradients.\n    # This step saves memory and speeds up validation.\n    torch.set_grad_enabled(False)\n    \n    \n    # Reset the total loss for this epoch.\n    total_val_loss = 0\n    \n\n    for j, batch in enumerate(val_dataloader):\n        \n        val_status = 'Batch ' + str(j) + ' of ' + str(len(val_dataloader))\n        \n        print(val_status, end='\\r')\n\n        b_input_ids = batch[0].to(device)\n        b_input_mask = batch[1].to(device)\n        b_labels = batch[2].to(device)      \n\n\n        outputs = model(b_input_ids, \n                attention_mask=b_input_mask, \n                labels=b_labels)\n        \n        # Get the loss from the outputs tuple: (loss, logits)\n        loss = outputs[0]\n        \n        # Convert the loss from a torch tensor to a number.\n        # Calculate the total loss.\n        total_val_loss = total_val_loss + loss.item()\n        \n\n        # Get the preds\n        preds = outputs[1]\n\n\n        # Move preds to the CPU\n        val_preds = preds.detach().cpu().numpy()\n        \n        # Move the labels to the cpu\n        targets_np = b_labels.to('cpu').numpy()\n\n        # Append the labels to a numpy list\n        targets_list.extend(targets_np)\n\n        if j == 0:  # first batch\n            stacked_val_preds = val_preds\n\n        else:\n            stacked_val_preds = np.vstack((stacked_val_preds, val_preds))\n\n    \n    # Calculate the validation accuracy\n    y_true = targets_list\n    y_pred = np.argmax(stacked_val_preds, axis=1)\n    \n    val_acc = accuracy_score(y_true, y_pred)\n    \n    \n    print('Val loss:' ,total_val_loss)\n    print('Val acc: ', val_acc)\n\n\n    # Save the Model\n    torch.save(model.state_dict(), 'model.pt')\n    \n    # Use the garbage collector to save memory.\n    gc.collect()","286c83ab":"for j, batch in enumerate(test_dataloader):\n        \n        inference_status = 'Batch ' + str(j+1) + ' of ' + str(len(test_dataloader))\n        \n        print(inference_status, end='\\r')\n\n        b_input_ids = batch[0].to(device)\n        b_input_mask = batch[1].to(device)\n\n\n        outputs = model(b_input_ids, \n                attention_mask=b_input_mask)\n        \n        \n        # Get the preds\n        preds = outputs[0]\n\n\n        # Move preds to the CPU\n        preds = preds.detach().cpu().numpy()\n        \n        # Move the labels to the cpu\n        targets_np = b_labels.to('cpu').numpy()\n\n        # Append the labels to a numpy list\n        targets_list.extend(targets_np)\n        \n        # Stack the predictions.\n\n        if j == 0:  # first batch\n            stacked_preds = preds\n\n        else:\n            stacked_preds = np.vstack((stacked_preds, preds))","8ab99559":"stacked_preds","2cb716d0":"# Take the argmax. This returns the column index of the max value in each row.\n\npreds = np.argmax(stacked_preds, axis=1)\n\npreds","05f308e9":"# Load the sample submission.\n# The row order in the test set and the sample submission is the same.\n\npath = '..\/input\/contradictory-my-dear-watson\/sample_submission.csv'\n\ndf_sample = pd.read_csv(path)\n\nprint(df_sample.shape)\n\ndf_sample.head()","be35f7c9":"# Assign the preds to the prediction column\n\ndf_sample['prediction'] = preds\n\ndf_sample.head()","d0351dda":"# Create a submission csv file\n# Note that for this competition the submission file must be named submission.csv.\n# Therefore, it won't be possible to submit this csv file for leaderboard scoring.\ndf_sample.to_csv('xlmroberta_submission.csv', index=False)","6c8f6cf9":"# Check that the model has been saved.\n\n!ls","b7c57a8a":"# Check the distribution of the predicted classes.\n\ndf_sample['prediction'].value_counts()","93e756dd":"| <a id='Section_2'><\/a>","769f6932":"In this section we'll look at what input the Bert and XLM-RoBERTa models expect and what output they produce. We will also use a tokenizer to automatically process one sentence and a pair of sentences into the correct input format for each model. ","583071a4":"## Bert Vocabulary","4c39997e":"Above we see that 4 tokens were truncated. The token numbers are shown in the list called overflowing_tokens. \n\nWe can also specify a stride. This adds tokens to the front of the 'overflowing_tokens list creating an overlap. The best way to illustrate this is with an example:","4cae302d":"## Test the Model","f6b16b4f":"## A1 - Acronyms\n\n- NLP - Natural Language Processing\n- NLU - Natural Language Understanding\n- NLI - Natural Language Inference\n- NER - Named Entity Recognition\n- NSP - Next Sentence Prediction\n- MLM - Masked Language Model\n- PoS - Part of Speech\n- POST - Part of Speech Tagging\n- GLUE - The General Language Understanding Evaluation benchmark\n- SQuAD - Stanford Question Answering Dataset\n- SWAG - Situations With Adversarial Generations (Dataset)\n- XNLI - Cross Lingual Natural Language Inference (Dataset)\n- XLU - Cross-lingual Language Understanding\n\n","e230481b":"## 1.4. Overflowing tokens and Stride\n\nWhen a sentence is truncated (because it's length exceeds max_length) it's possible to get the tokenizer to return the tokens that were cut off. These truncated tokens will be returned in a list called overflowing_tokens.","2d9521b9":"## Make a prediction on the test set","26d33be8":"## 3.1. Train a Bert Model","f260fb94":"| <a id='Create_5_Folds'><\/a>","5c6bcb9b":"## 1.1. Explore BERT","4d612401":"## Make a Test Set Prediction","5a3da971":"## Contents\n\n<a href='#Section_1'>Section 1<\/a><br>\n<a href='#BERT'>1.1. Explore BERT<\/a><br>\n<a href='#XLM-Roberta'>1.2. Explore XLM-RoBERTa<\/a><br>\n<a href='#Manual_formatting_of_model_input_data'>1.3. Manual formatting of model input data<\/a><br>\n<a href='#Overflowing_tokens_and_Stride'>1.4. Overflowing tokens and Stride<\/a><br>\n\n<a href='#Section_2'>Section 2<\/a><br>\n<a href='#Load_the_Data'>2.1. Load the Data<\/a><br>\n<a href='#Create_5_Folds'>2.2. Create 5 Folds<\/a><br>\n\n<a href='#Section_3'>Section 3<\/a><br>\n<a href='#Train_a_Bert_Model'>3.1. Train a BERT Model<\/a><br>\n<a href='#Train_an_XLM-Roberta_Model'>3.2. Train an XLM-RoBERTa Model <\/a><br>\n\n<a href='#Appendix'>Appendix<\/a><br>\n<a href='#Acronyms'>A1 - Acronyms<\/a><br>\n<a href='#GLUE_Datasets'>A2 - GLUE Datasets<\/a><br>\n<a href='#Datasets_Separated_by_Task'>A3 - Datasets Separated by Task<\/a><br>\n<a href='#Papers'>A4 - Papers<\/a><br>\n<a href='#NLP_Applications'>A5 - What is NLP used for?<\/a><br>\n<a href='#Helpful_Resources'>A6 - Helpful Resources<\/a><br>\n\n","2437be23":"BERT is a pre-trained language model that can be fine tuned to perform NLP tasks. BERT stands for Bidirectional Encoder Representations from Transformers. Bidirectional means that the model is able to read text from both left-to-right and from right-to-left. This capability helps it to understand context. BERT's other super-power is that it can understand 100 languages.\n\nYou can access BERT and other pre-trained models through a library called [Transformers](https:\/\/github.com\/huggingface\/transformers). The team at Hugging Face created this library. It contains many transformer models and tokenizers that use a common interface. The Transformers library is available in Kaggle notebooks by default - simply type: import Transformers.\n\nSeveral pre-trained BERT models are available - different sizes, monolingual and multilingual. These are a few types:\n\n- bert-base-uncased\n- bert-base-cased\n- bert-large-uncased\n- bert-large-cased\n- bert-base-multilingual-uncased \n- bert-base-multilingual-cased\n\n*uncased* - All text was converted to lower case before training the model.<br>\n*cased* - The text used to train the model was not converted to lower case.\n\nThis is a link to a full searchable listing of all model types:<br>\nhttps:\/\/huggingface.co\/models\n\nThis is a link to the BERT paper:<br>\nhttps:\/\/arxiv.org\/pdf\/1810.04805.pdf\n\nIf you are new to BERT and to pre-trained transformer models then I suggest watching these video tutorials:<br>\n\nPart 1<br>\nhttps:\/\/www.youtube.com\/watch?v=FKlPCK1uFrc<br>\nPart 2<br>\nhttps:\/\/www.youtube.com\/watch?v=zJW57aCBCTk<br>\nPart 3<br>\nhttps:\/\/www.youtube.com\/watch?v=x66kkDnbzi4<br>\nPart 4<br>\nhttps:\/\/www.youtube.com\/watch?v=Hnvb9b7a_Ps<br>\n","08c79187":"## Instantiate the tokenizer","913c6a1f":"# Section 3","053d3d92":"## A4 - Papers\n\n- Attention is all you need<br>\nhttps:\/\/arxiv.org\/pdf\/1706.03762.pdf\n\n- BERT Paper<br>\nBERT: Pre-training of Deep Bidirectional Transformers for Language Understanding<br>\nhttps:\/\/arxiv.org\/pdf\/1810.04805.pdf\n\n- XLMRoberta Paper<br>\nUnsupervised Cross-lingual Representation Learning at Scale<br>\nhttps:\/\/arxiv.org\/pdf\/1911.02116.pdf\n\n- GLUE Paper<br>\nhttps:\/\/arxiv.org\/abs\/1804.07461<br>\nWebsite: https:\/\/gluebenchmark.com\/\n\n- MultiNLI Paper<br>\nA Broad-Coverage Challenge Corpus for Sentence Understanding through Inference<br>\nhttps:\/\/cims.nyu.edu\/~sbowman\/multinli\/paper.pdf<br>\nWebsite: https:\/\/cims.nyu.edu\/~sbowman\/multinli\/\n\n- XNLI Paper<br>\nhttps:\/\/arxiv.org\/pdf\/1809.05053.pdf<br>\nWebsite: https:\/\/cims.nyu.edu\/~sbowman\/xnli\/\n\n- SentencePiece Paper<br>\nSentencePiece: A simple and language independent subword tokenizer and detokenizer for Neural Text Processing\nhttps:\/\/arxiv.org\/abs\/1808.06226","ae9de6ca":"## Create a submission csv file","343df5de":"| <a id='Manual_formatting_of_model_input_data'><\/a>","67593346":"## XLM-RoBERTa Vocabulary","811ef678":"## 1.3. Manual formatting of model input data","d42af0fa":"## Process the predictions\n\nHere we are ensembling the predictons of all the fold models. We add all the matrices and then take the average.","487b010c":"| <a id='Appendix'><\/a>","1e9d8e0e":"## Train the Model","0a3f0546":"## Test the dataloader","2c71225a":"### For two input sentences","6985645a":"## 2.1. Load the Data","7263116d":"## 3.2. Train an XLM-RoBERTa Model","d6d8823b":"## 2.2. Create 5 Folds","1dd8e38f":"## Define the device","a7fc83ed":"| <a id='Helpful_Resources'><\/a>","2200d6fc":"## Introduction","b8890713":"## Inspect the model's output","5ea66cdb":"| <a id='Datasets_Separated_by_Task'><\/a>","48ee5475":"## Define the Optimizer","82de48a2":"| <a id='Section_3'><\/a>","c17e680d":"## 1.2. Explore XLM-RoBERTa","40a144a4":"In this section we will train a BERT Model on three folds and train an XLM-RoBERTa model on one fold. We will use PyTorch with a single TPU. For each model we will also make a prediction on the competition test set and create a submission csv file.\n\n### A few notes on using PyTorch with a TPU\n\n- Setting up PyTorch code to use a single xla device (TPU) is easier that setting it up to use all 8 TPU cores. Just a few lines of code need to be changed to switch from a GPU to a single TPU. The speed is not as fast as using all 8 TPU cores but the model does train faster than a GPU and there's more RAM available. \n\n- Pytorch XLA does not use memory as efficiently as Tensorflow. Therefore, my code tends to consistently crash when I try to use PyTorch with an 8 core TPU setup. \n\n- There is 4.9GB of disk space available in Kaggle notebooks. What I've found is that models trained on a TPU are larger than models trained on a GPU. For example, a Bert model trained on a GPU is 600MB. However, a BERT model trained on a TPU is approx. 1GB. Therefore, when running 5 fold cross validation, trying to save all 5 fold models (1GB each) will cause the Kaggle notebook to crash because the available disk space will be exceeded. For that reason here we will be training on three folds only.\n\n-  A TPU may take a few seconds to start running. Therefore, if you run your code and you see that nothing is happening, wait a little while. Don't cancel the run because you think that something is wrong.","86bf439a":"| <a id='Acronyms'><\/a>","1cf8cf2c":"XLM means Cross-lingual Language Model. XLM-RoBERTa (XLM-R) is a pre-trained multilingual model that outperforms multiligual BERT. One reason for this is that XLM-R was trained using a lot more data. XLM-R was also trained on 100 languages.\n\nSeveral versions of xlm roberta are available in the Transformers library. Here are two:\n\n- xlm-roberta-base\n- xlm-roberta-large\n\nThis is the link to the XLM-RoBERTa paper:<br>\nhttps:\/\/arxiv.org\/pdf\/1911.02116.pdf","27dfe05d":"Because stride is set to 3, three tokens (5155, 5, 3293) from the end of the input_ids (excl. special token 2) are added to the front of the overflowing_tokens list. This creates an overlap between the two lists.","e6f57ce8":"## Define the device","17eb477a":"### For one input sentence","528b5d62":"## A2 - GLUE Datasets\n\nGLUE (General Language Understanding Evaluation) is a performance bechmark that's used to compare the language understanding capability of machine learning models. A model's performance on 9 datasets is reduced to a single number. These are the datasets that are part of GLUE.\n\n1. MNLI -Multi-Genre Natural Language Inference\n2. QQP - Quora Question Pairs\n3. QNLI - Question Natural Langiage Inference\n4. SST-2 - Stanford Sentiment Treebank\n5. CoLA - Corpus of Linguistic Acceptability\n6. STS-B - Semantic Textual Similarity Benchmark\n7. MRPC - Microsoft Research Paraphrase Corpus\n8. RTE - Recognizing Textual Entailment\n9. WNLI - Winograd NLI\n\nMore Info:<br>\nGLUE Explained: Understanding BERT Through Benchmarks<br>\nhttps:\/\/mccormickml.com\/2019\/11\/05\/GLUE\/\n","22d7a305":"## Test the dataloader","21674df5":"# Section 2","bed4f3ad":"## Inspect the model's output","7c97005c":"| <a id='Overflowing_tokens_and_Stride'><\/a>","64e82911":"## How to use a tokenizer to create XLM-RoBERTa input","5d612c3b":"## A5 - What is NLP used for?\n\n- Text Classification\n- Translation\n- Named Entity Recognition\n- Part of Speech Tagging\n- Question Answering\n- Text Generation\n- Language Modeling\n- Text Summarization","9a7a8277":"## Instantiate the Tokenizer","b07d068b":"| <a id='NLP_Applications'><\/a>","72b09cbc":"## Create the Dataloader","f19864da":"## A3 - Datasets Separated by Task\n\na) Sentence Pair Classification Tasks<br>\nMNLI, QQP, QNLI, STS-B, MRPC, RTE, SWAG\n\nb) Single Sentence Classifications Tasks<br>\nSST-2, CoLA\n\nc) Question Answering Tasks<br>\nSQuAD (v1.1 and v2.0)\n\nd) Single Sentence Tagging Tasks<br>\nCoNLL-2003 NER","fe977736":"This notebook is divided into 3 Sections and an Appendix. In section 1 we will look at how to format input data for Bert and XLM-Roberta and review the ouput that these models produce. In section 2 we will load the competition data and create 5 folds. In section 3 we will fine-tune a 3 fold cv Bert model and a single fold XLM-RoBERTa model - using Pytorch with a single xla device (TPU). Finally, in the Appendix I've included some info that I'm finding helpful as I learn how to use pre-trained transformer models. ","a61339c0":"## Train the Model","2ea30d6c":"| <a id='GLUE_Datasets'><\/a>","739fdebf":"| <a id='BERT'><\/a>","a3deee7e":"## Create the Dataloader","bba4b997":"| <a id='Papers'><\/a>","8c9490d2":"So far we've used tokenizer.encode_plus to automatically format input data. I've included the following resource links because there are things that one needs to be aware of when writing code for manual formatting. For example XLM-RoBERTa uses a SentencePiece-based tokenizer but BERT does not. It's also good to know what SentencePiece tokenization is and how it works.\n\nHugging Face Tokenizer docs<br>\nhttps:\/\/huggingface.co\/transformers\/main_classes\/tokenizer.html\n\nAbhishek Thakur<br>\nData Processing For Question & Answering Systems: BERT vs. RoBERTa<br>\n(Note that this video covers RoBERTa and not XLM-RoBERTa)<br>\nhttps:\/\/www.youtube.com\/watch?v=6a6L_9USZxg\n\nAbhishek Thakur<br>\nSentencepiece Tokenizer With Offsets For T5, ALBERT, XLM-RoBERTa And Many More<br>\nhttps:\/\/youtu.be\/U51ranzJBpY\n\nSentencePiece Paper<br>\nhttps:\/\/arxiv.org\/abs\/1808.06226\n\nSentencePiece Github<br>\nhttps:\/\/github.com\/google\/sentencepiece\n\nThe following Hugging face models use a SentencePiece-based tokenizer:<br>\nT5, ALBERT, CamemBERT, XLMRoBERTa and XLNet","97118618":"## Process the Predictions","eecd1407":"# Appendix","d02b1f8c":"| <a id='XLM-Roberta'><\/a>","5540b11b":"| <a id='Train_a_Bert_Model'><\/a>","ce524fd0":"## What input does XLM-RoBERTa expect?","8235d8ed":"| <a id='Load_the_Data'><\/a>","d800bd89":"## Define the Model","14088caf":"## Test the model","f5ce86b4":"## Decoding a sequence of tokens","31d365cc":"# Section 1","4d119736":"| <a id='Section_1'><\/a>","c91551e1":"## A6 - Helpful Resources\n\n- GLUE Explained: Understanding BERT Through Benchmarks<br>\nhttps:\/\/mccormickml.com\/2019\/11\/05\/GLUE\/\n\n- Improving Language Understanding with Unsupervised Learning<br>\nhttps:\/\/openai.com\/blog\/language-unsupervised\/\n\n- Hugging Face Transformers Github<br>\nhttps:\/\/github.com\/huggingface\/transformers\n\n- Hugging Face Summary of Models<br>\nhttps:\/\/huggingface.co\/transformers\/model_summary.html\n\n- Hugging Face - Searchable model listing<br>\nhttps:\/\/huggingface.co\/models\n\n- Bert Video Series by ChrisMcCormickAI<br>\nPart 1<br>\nhttps:\/\/www.youtube.com\/watch?v=FKlPCK1uFrc<br>\nPart 2<br>\nhttps:\/\/www.youtube.com\/watch?v=zJW57aCBCTk<br>\nPart 3<br>\nhttps:\/\/www.youtube.com\/watch?v=x66kkDnbzi4<br>\nPart 4<br>\nhttps:\/\/www.youtube.com\/watch?v=Hnvb9b7a_Ps<br>\n\n- Data Processing For Question & Answering Systems: BERT vs. RoBERTa by Abhishek Thakur<br>\nhttps:\/\/www.youtube.com\/watch?v=6a6L_9USZxg\n\n- Sentencepiece Tokenizer With Offsets For T5, ALBERT, XLM-RoBERTa And Many More by Abhishek Thakur<br>\nhttps:\/\/youtu.be\/U51ranzJBpY\n\n- PyTorch on XLA Devices - docs<br>\nhttps:\/\/pytorch.org\/xla\/release\/1.5\/index.html\n","d2b99a63":"**Thank you for reading.**","6fd86c3c":"## Load the data\n\nHere we will only use fold_0 for training.","24ec2f5b":"## Create a submission csv file","8b08b4f3":"In this section we will load the competition train and test data. We will also create 5 folds that can be used for cross validation.","39d8ae18":"## Define the Model"}}