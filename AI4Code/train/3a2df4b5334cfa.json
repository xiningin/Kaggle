{"cell_type":{"268c6414":"code","90224723":"code","cc144a54":"code","e90eedb7":"code","b50f0852":"code","adc03790":"code","adba21a0":"code","7c086a68":"code","c664545c":"code","f3e43f9b":"code","5c4a6365":"code","20392c87":"code","ed5c5e37":"code","54947a87":"code","aa0bef4a":"code","ecd56a83":"code","397d401f":"code","7ae033eb":"code","136de4de":"code","ee03b352":"code","7b63d393":"code","b63e282c":"code","ac2d9af1":"code","0d009d15":"code","c200ef8f":"code","e0fbdba8":"code","f943d55f":"code","3b93da21":"code","f2db92d5":"markdown"},"source":{"268c6414":"import pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n# Import Datasets\ndf_seq = pd.read_csv('\/kaggle\/input\/protein-data-set\/pdb_data_seq.csv')\ndf_char = pd.read_csv('\/kaggle\/input\/protein-data-set\/pdb_data_no_dups.csv')\n\nprint('Datasets have been loaded...')","90224723":"# 2). ----- Filter and Process Dataset ------\n\n# Filter for only proteins\nprotein_char = df_char[df_char.macromoleculeType == 'Protein']\nprotein_seq = df_seq[df_seq.macromoleculeType == 'Protein']\n\n# Select only necessary variables to join\nprotein_char = protein_char[['structureId','classification']]\nprotein_seq = protein_seq[['structureId','sequence']]\nprotein_seq.head()","cc144a54":"protein_char.head()","e90eedb7":"model_f = protein_char.set_index('structureId').join(protein_seq.set_index('structureId'))\nmodel_f.head()","b50f0852":"print('%d rows in joined dataset' %model_f.shape[0])","adc03790":"model_f.isnull().sum()","adba21a0":"model_f = model_f.dropna()\nprint('%d rows in updated joined dataset' %model_f.shape[0])","7c086a68":"counts = model_f.classification.value_counts()\nprint(counts)","c664545c":"types = np.asarray(counts[(counts > 1000)].index)\nprint(types)","f3e43f9b":"#data = model_f[model_f.classification.isin(types)]\ndata = model_f.loc[(model_f.classification == 'FLUORESCENT PROTEIN') | (model_f.classification == 'BIOSYNTHETIC PROTEIN') | \n                   (model_f.classification == 'CONTRACTILE PROTEIN') | (model_f.classification == 'TRANSLATION') |\n                   (model_f.classification == 'METAL TRANSPORT') | (model_f.classification == 'PROTEIN FIBRIL') |\n                   (model_f.classification == 'MOTOR PROTEIN') | (model_f.classification == 'MEMBRANE PROTEIN')]\nprint('%d filtered dataset' %data.shape[0])","5c4a6365":"# Split Data\nX_train, X_test,y_train,y_test = train_test_split(data['sequence'], data['classification'], test_size = 0.2, random_state = 1)","20392c87":"# Exploring CountTokenizer\n\n# list of text documents\ntext = [\"The quick brown fox jumped over the lazy dog.\"]\n# create the transform\nvectorizer = CountVectorizer()\n# tokenize and build vocab\nvectorizer.fit(text)\n# summarize\nprint(vectorizer.vocabulary_)\n# encode document\nvector = vectorizer.transform(text)\n# summarize encoded vector\nprint(vector.shape)\nprint(type(vector))\nprint(vector.toarray())","ed5c5e37":"vect = CountVectorizer(analyzer = 'char_wb', ngram_range = (4,4))","54947a87":"# Fit and Transform CountVectorizer\nvect.fit(X_train)\nX_train_df = vect.transform(X_train)\nX_test_df = vect.transform(X_test)","aa0bef4a":"print(vect.vocabulary_)\nprint(X_train_df.shape)\nprint(type(X_train_df))\nprint(X_train_df.toarray())","ecd56a83":"print(vect.get_feature_names()[-20:])","397d401f":"prediction = dict()\n\n# Naive Bayes Model\nfrom sklearn.naive_bayes import MultinomialNB\nmodel = MultinomialNB()\nmodel.fit(X_train_df, y_train)\nNB_pred = model.predict(X_test_df)\nprediction[\"MultinomialNB\"] = accuracy_score(NB_pred, y_test)\nprint( prediction['MultinomialNB'])","7ae033eb":"print(classification_report(y_test,NB_pred))","136de4de":"from sklearn import svm\nclf_svc = svm.SVC(gamma=0.001, C=100) # experiment with one-vs-one\nclf_svc.fit(X_train_df, y_train)\nNB_pred = clf_svc.predict(X_test_df)\n\nprint(classification_report(y_test,NB_pred))\nprediction[\"SVM_SVC\"] = accuracy_score(y_test,NB_pred)\nprint( prediction['SVM_SVC'])","ee03b352":"clf = svm.LinearSVC(random_state=1, C=100) # experiment with one-vs-rest\nclf.fit(X_train_df, y_train)\nNB_pred = clf.predict(X_test_df)\n\nprint(classification_report(y_test,NB_pred))\nprediction[\"SVM_LINEARSVC\"] = accuracy_score(y_test,NB_pred)\nprint(prediction['SVM_LINEARSVC'])","7b63d393":"# test prediction\n\na = ['MHIPEGYLSPQTCAVMGAAMVPVLTVAAKKVNKSFDKKDVPAMAIGSAFAFTIMMFNVPIPGGTTAHAIGATLLATTLGPWAASISLTLALFIQALLFGDGGILALGANSFNMAFIAPFVGYGIYRLMLSLKLNKVLSSAIGGYVGINAAALATAIELGLQPLLFHTANGTPLYFPYGLNVAIPAMMFAHLTVAGIVEAVITGLVVYYLLEHHHHHH']\n\nprint('predicted : ', clf.predict(vect.transform(a)))\n\nprint('training data : ', model_f.loc[model_f.sequence=='MHIPEGYLSPQTCAVMGAAMVPVLTVAAKKVNKSFDKKDVPAMAIGSAFAFTIMMFNVPIPGGTTAHAIGATLLATTLGPWAASISLTLALFIQALLFGDGGILALGANSFNMAFIAPFVGYGIYRLMLSLKLNKVLSSAIGGYVGINAAALATAIELGLQPLLFHTANGTPLYFPYGLNVAIPAMMFAHLTVAGIVEAVITGLVVYYLLEHHHHHH'])","b63e282c":"from sklearn.model_selection import cross_val_score\n\nscores = cross_val_score(clf, X_train_df, y_train, cv=5)","ac2d9af1":"print(\"Accuracy: %0.2f (+\/- %0.2f)\" % (scores.mean(), scores.std() * 2))","0d009d15":"scores","c200ef8f":"from sklearn.model_selection import cross_val_score\n\nscores = cross_val_score(clf_svc, X_train_df, y_train, cv=5)\n\nprint(\"Accuracy: %0.2f (+\/- %0.2f)\" % (scores.mean(), scores.std() * 2))\n\nprint(scores)","e0fbdba8":"scores = cross_val_score(model, X_train_df, y_train, cv=5)","f943d55f":"print(\"Accuracy: %0.2f (+\/- %0.2f)\" % (scores.mean(), scores.std() * 2))","3b93da21":"scores","f2db92d5":"**ABSTRACT**\n\nMany combination of structures are available for proteins involved in the central processes of life, however it can be a challenge to find the information that we need, since protein data bank archives so many different structures, often with multiple combination of structures for a given molecule, or partial structures, or structures that have been modified from their native form. This paper presents SVM-based algorithm to identify protein structures and compare with a Naive Bayes-based algorithm on a set of protein database from Research Collaboratory for Structural Bioinformatics (RCSB) Protein Data Bank (PDB). Performance was measured for identification scenarios. The classification performance for SVM with one-vs-rest approach is ~94% versus Naive Bayes is ~90%.\n\n**Keywords**: support vector machine, sequences, pattern recognition, bag of words\n"}}