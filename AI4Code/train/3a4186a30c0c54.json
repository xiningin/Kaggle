{"cell_type":{"35ec6db4":"code","f8348e22":"code","87dfe610":"code","c0590074":"code","10c235d0":"code","ccc5e20b":"code","c296f54c":"markdown","93abd62b":"markdown","ab97dcac":"markdown","30437160":"markdown","386056b1":"markdown","f739b754":"markdown","3feea1fc":"markdown","d82a4e6d":"markdown","891afe8c":"markdown"},"source":{"35ec6db4":"import tensorflow as tf\nfrom tensorflow.keras.models import  load_model\nimport numpy as np\nimport pandas as pd\nimport cv2 as cv2\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import imshow\nimport os\nimport shutil\nimport logging\nlogging.getLogger(\"tensorflow\").setLevel(logging.ERROR)","f8348e22":"def predictor(sdir, csv_path,  model_path, averaged=True, verbose=True):    \n    # read in the csv file\n    class_df=pd.read_csv(csv_path) \n    class_count=len(class_df['class'].unique())\n    img_height=int(class_df['height'].iloc[0])\n    img_width =int(class_df['width'].iloc[0])\n    img_size=(img_width, img_height)    \n    scale=class_df['scale by'].iloc[0] \n    image_list=[]\n    # determine value to scale image pixels by\n    try: \n        s=int(scale)\n        s2=1\n        s1=0\n    except:\n        split=scale.split('-')\n        s1=float(split[1])\n        s2=float(split[0].split('*')[1]) \n        print (s1,s2)\n    path_list=[]\n    paths=os.listdir(sdir)    \n    for f in paths:\n        path_list.append(os.path.join(sdir,f))\n    if verbose:\n        print (' Model is being loaded- this will take about 10 seconds')\n    model=load_model(model_path)\n    image_count=len(path_list) \n    image_list=[]\n    file_list=[]\n    good_image_count=0\n    for i in range (image_count):        \n        try:\n            img=cv2.imread(path_list[i])\n            img=cv2.resize(img, img_size)\n            img=cv2.cvtColor(img, cv2.COLOR_BGR2RGB)             \n            good_image_count +=1 \n            img=img*s2 - s1 \n            image_list.append(img)\n            file_name=os.path.split(path_list[i])[1]\n            file_list.append(file_name)\n        except:\n            if verbose:\n                print ( path_list[i], ' is an invalid image file') \n    if good_image_count == 1:\n        averaged=True\n    image_array=np.array(image_list) \n    # make predictions on images, sum the probabilities of each class then find class index with\n    # highest probability\n    preds=model.predict(image_array)\n    if averaged:\n        tsum=[]    \n        for i in range (class_count): # create all 0 values list\n            tsum.append(0)\n        for p in preds:\n            tsum =list( map(lambda x, y: x + y, tsum, p)) \n        index=np.argmax(tsum) # find the class index with the highest probability sum\n        klass=class_df['class'].iloc[index] # get the class name that corresponds to the index\n        prob=tsum[index]\/good_image_count  # get the probability average \n        # to show the correct image run predict again and select first image that has same index\n        for img in image_array:  #iterate through the images    \n            test_img=np.expand_dims(img, axis=0) # since it is a single image expand dimensions \n            test_index=np.argmax(model.predict(test_img)) # for this image find the class index with highest probability\n            if test_index== index: # see if this image has the same index as was selected previously\n                if verbose: # show image and print result if verbose=1\n                    plt.axis('off')\n                    plt.imshow(img) # show the image\n                    print (f'predicted class is {klass} with a probability of {prob*100:6.2f} % ')\n                break # found an image that represents the predicted class      \n        return klass, prob, img, None\n    else: # create individual predictions for each image\n        pred_class=[]\n        prob_list=[]\n        for i, p in enumerate(preds):\n            index=np.argmax(p) # find the class index with the highest probability sum\n            klass=class_df['class'].iloc[index] # get the class name that corresponds to the index\n            image_file= file_list[i]\n            pred_class.append(klass)\n            prob_list.append(p[index]* 100)            \n        Fseries=pd.Series(file_list, name='image file')\n        Lseries=pd.Series(pred_class, name= 'class')\n        Pseries=pd.Series(prob_list, name='probability')\n        df=pd.concat([Fseries, Lseries, Pseries], axis=1)\n        if verbose:\n            length= len(df)\n            print (df.head(length))\n        return None, None, None, df","87dfe610":"sdir=r'..\/input\/musical-instruments-image-classification\/6 test samples'\ncsv_path=r'..\/input\/musical-instruments-image-classification\/class_dict.csv'\nmodel_path=r'..\/input\/musical-instruments-image-classification\/EfficientNetB3-instruments-99.33.h5'\nverbose=True # function will print out results and show image of predicted class\naveraged=False # do individual predictions on EACH image\nklass, prob, image, df=predictor(sdir, csv_path,  model_path, averaged=averaged, verbose=verbose)\n","c0590074":"verbose=False\nklass, prob, image, df=predictor(sdir, csv_path,  model_path, averaged=averaged, verbose=verbose)","10c235d0":"print(df.head(6))","ccc5e20b":"verbose=True\naveraged=True\nklass, prob, image, df=predictor(sdir, csv_path,  model_path, averaged=averaged, verbose=verbose)","c296f54c":"### predictor function using trained model and class_dict_csv","93abd62b":"### now set averaged = True  and verbose=True to get a single prediction\n### where the individual predictions are averaged and the class and image with the\n### highest average is predicted. Note in real use the images should be images\n### of the SAME instrument","ab97dcac":"### print the results returned by the function and show the image","30437160":"###  Note: probability is only 81.51 because banjo is the class with the\n### highest averaged probability and the accordian image reduces the average\n","386056b1":"### Make required imports","f739b754":"### test on 6 samples again but with verbose=False ie no printout","3feea1fc":"### Note predictions are correct if you look at the images","d82a4e6d":"### test on 6 images with averaged= False and verbose =True\n### to get 6 predictions","891afe8c":"### The Predictor kernel is used in association with the trained model produced by the classification kernel 285 Birds EfficientNetB3 F1 score =99% located on Kagle [here](https:\/\/www.kaggle.com\/gpiosenka\/285-birds-efficientnetb3-f1-score-99). That kernel produces the saved model EfficientNetB3-birds-98.87.h5 and an associated csv file class_dict.csv which contains information on the model parameters like the image width, image height, pixel scaling factor and a mapping of class names to class indices.\n\n### The Predictor call is off the form predictor(sdir, csv_path,  model_path, averaged=True, verbose=True) where:\n\n- __sdir__ is the path to the directory that contains one or more images to be predicted\n- __csv_path__ is the path to the class_dict csv file \n- __model_path__ is the path to the trained model\n- __averaged__ is a boolean that selects the mode of operation of the kernel.\n    if averaged=True then it is assumed the images to be predicted are images of the SAME subject. That is,\n    if you see a musical instrument you want to classify it is best to take several photos of it. Then place them\n    into a directory(sdir). I recommend you crop the image so the instrument occupes the majority of the pixels.\n    The kernel will make a prediction on each image and average the class probabilities\n    It then selects the class with the highest averaged probability as the predicted class. Note the predictor\n    will work best if the images you use cropped images where the bird takes up around 50% of the pixels\n    in the image. See the images in the test directory for examples of proper images to use for predictions.\n    If averaged=False it is assumed that the images in the sdir are of various instruments and you wish to obtain an\n    individual prediction for EACH image. In this case the kernel returns a dataframe of the form\n    image file  class and probabilty. The dataframe as as many rows as there are images in the sdir. The dataframe\n    output is shown below for the images in 6 test samples directory\n               image file     class  probability\n            0      6.jpg  acordian    98.335397\n            1      5.jpg     banjo    97.079092\n            2      1.jpg     banjo    97.950774\n            3      4.jpg     banjo    96.806526\n            4      3.jpg     banjo    98.933512\n            5      2.jpg     banjo    98.276585\n- __verbose__ is a boolean. If set to True the kernel prints the results of the predictions. In the case where\n     average=True it will also show the image of the predicted class. If averaged=False the kernel prints out\n     the content of the dataframe\n     \n\n"}}