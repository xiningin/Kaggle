{"cell_type":{"2e878b12":"code","2dca3d3b":"code","4999e25d":"code","195f269c":"markdown","a37bf0b3":"markdown","b6805c63":"markdown","a935f8f6":"markdown"},"source":{"2e878b12":"%%writefile copy.py\ndef copy_opponent_agent (observation, configuration):\n    if observation.step > 0:\n        return observation.lastOpponentAction\n    else:\n        return 0","2dca3d3b":"%%writefile random.py\nimport random\n\ndef copy_opponent_agent(observation, configuration):\n    return random.randint(0, 2)","4999e25d":"%%writefile submission.py\nimport sys\nimport time\nimport random\nimport math\nimport re\nimport numpy as np\nimport tensorflow as tf\nfrom typing import List\nfrom mpmath import mp\n\n\nhistory     = []\nmin_seed    = 0\nbest_method = 'random'\nsolutions   = []\n\n\n# Irrational numbers are pure random sequences that are immune to random seed search \nmp.dps     = random.randint(1234,9876)\nirrational = mp.e() + mp.pi() + mp.sqrt(2) + mp.euler()\nirrational = re.sub('[^1-9]', '', str(irrational))\nirrational = irrational[::-1] \nprint(f'len(irrational) = {len(irrational)}\\n{irrational[:1000]}\\n')\ndef random_agent(observation, configuration, seed=None):\n    return int(irrational[observation.step]) % configuration.signs\n\n\n# https:\/\/github.com\/JamesMcGuigan\/kaggle-digit-recognizer\/blob\/master\/src\/random\/random_seed_search.py\ndef get_random(length, seed, method='random') -> List[int]:\n    if method == 'random':\n        random.seed(seed)        \n        return [ random.randint(0,2) for n in range(length) ]\n    if method == 'np':\n        np.random.seed(seed)\n        return np.random.randint(0,2, length).tolist()\n    if method == 'tf':\n        tf.random.set_seed(seed)\n        return tf.random.uniform((length,), minval=0, maxval=3, dtype=tf.dtypes.int32).numpy().tolist()\n\n        \n# observation   =  {'step': 1, 'lastOpponentAction': 1}\n# configuration =  {'episodeSteps': 10, 'agentTimeout': 60, 'actTimeout': 1, 'runTimeout': 1200, 'isProduction': False, 'signs': 3}\ndef random_seed_search_agent(observation, configuration, warmup=10, seeds_per_turn=200_000):\n    # print(observation)\n    global min_seed, best_method, solutions\n    time_start      = time.perf_counter()\n    # time_end      = time_start + configuration.actTimeout - safety_time\n    opponent_action = observation.lastOpponentAction if observation.step > 0 else None\n    if opponent_action:\n        history.append(opponent_action)\n    \n    # Play the first few rounds as pure random to see what the opponent does\n    if observation.step <= warmup:\n        return random_agent(observation, configuration, seed=None)\n\n    action = random_agent(observation, configuration, seed=None)\n    try:\n        # Search through the list of previously found solutions and see if any still match\n        for seed, method in solutions:\n            guess      = get_random(length=len(history)+1, seed=seed, method=method)\n            prediction = guess[-1]\n            if guess[:-1] == history:    \n                action = (prediction + 1) % configuration.signs\n                print(f'Reused Seed: {method} {seed} | action = {action} | {solutions}')\n                return int(action)\n                break\n        else:\n            # Continue search for seeds until timeout\n            methods    = [ 'random', 'np', 'tf' ]\n            loop_count = int( seeds_per_turn \/ len(methods) \/ len(history) ) \n            for seed in range(min_seed, min_seed + loop_count):\n                for method in methods:\n                    guess      = get_random(length=len(history)+1, seed=seed, method=method)\n                    prediction = int(guess[-1])\n                    if guess[:-1] == history:\n                        solutions += [ (seed, method) ]\n                        action     = (prediction + 1) % configuration.signs\n                        print(f'Found  Seed: {method} {seed} | action = {action} | {solutions}')\n                        return int(action)\n                        break\n                    else:\n                        min_seed += 1\n            else:\n                action = random_agent(observation, configuration, seed=None)\n    except Exception as exception:\n        print(exception)\n                    \n    time_taken = time.perf_counter() - time_start\n    print(f'time = {time_taken:.2f}s | step = {observation.step:4d} | action = {action} | solutions = {solutions}')\n    return int(action) % configuration.signs","195f269c":"### 3. Random Irrational number","a37bf0b3":"Hey there! My name's Makar Baderko, I'm 12 years old and I love data science, today I will look, what will happen if I will use some intuitive solutions for the Rock, Paper, Scissors problem.","b6805c63":"## 2. Random number\nAlso easy to use, accuracy probably won't be awesome, but let's try it","a935f8f6":"## 1. Copy opponents turn\nThe easiest strategy to use is to copy what does your opponent do, so let's try to do it!"}}