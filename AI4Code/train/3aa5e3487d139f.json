{"cell_type":{"3bbe93df":"code","8160e3d6":"code","383feb41":"code","361dc443":"code","a6a3b555":"code","0ac82022":"code","903198de":"code","0f774f39":"markdown","293658ac":"markdown","77365b64":"markdown","cc94fa07":"markdown","3197fc11":"markdown","c7bb0ee6":"markdown"},"source":{"3bbe93df":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport matplotlib.pyplot as plt\n\nfrom sklearn.model_selection import train_test_split\nfrom keras.layers import Input, Flatten, Dense, Conv2D\nfrom keras.models import Model\nfrom keras.optimizers import Adam\nfrom keras.utils import to_categorical\n\nimport os\nimport cv2\n#for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#    for filename in filenames:\n#        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","8160e3d6":"# Cell taken from https:\/\/www.kaggle.com\/ibrahimsherify\/lenet-using-keras-accuracy-99\n\n# Create a basis for all imported objects\nPATH = \"..\/input\/four-shapes\/shapes\/\"\nIMG_SIZE = 64 # Since 64x64 imgs\nShapes = [\"circle\", \"square\", \"triangle\", \"star\"]\n\n# Create holding arrays for images\nLabels = []\nDataset = []\n\n# Parse through each folder and pull all images\nfor shape in Shapes:\n    print(\"Getting data for\", shape)\n    #iterate through each file in the folder\n    for path in os.listdir(PATH + shape):\n        #add the image to the list of images\n        img = cv2.imread(PATH + shape + '\/' + path)\n        img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))\n        Dataset.append(img)\n        #add an integer to the labels list \n        Labels.append(Shapes.index(shape))\n        \n# Print results\nprint(\"\\nDataset Images size:\", len(Dataset))\nprint(\"Image Shape:\", Dataset[0].shape)\nprint(\"Labels size:\", len(Labels))","383feb41":"# Normalize images\nDataset = np.array(Dataset)\nDataset = Dataset.astype(\"float32\") \/ 255.0\n\n# One hot encode labels (preventing any integer relation from forming)\nLabels = np.array(Labels)\nLabels = to_categorical(Labels)\n\n# Split Dataset to train\\test\n(trainX, testX, trainY, testY) = train_test_split(Dataset, Labels, test_size=0.2, random_state=42)\n\nprint(\"X Train shape:\", trainX.shape)\nprint(\"X Test shape:\", testX.shape)\nprint(\"Y Train shape:\", trainY.shape)\nprint(\"Y Test shape:\", testY.shape)","361dc443":"# Define the input layer to accept images\ninput_layer = Input((64,64,3))\n\n# Flatten the input for dense processing\nx = Flatten()(input_layer)\n\n# Compute some dense layer processing\nx = Dense(300, activation = 'relu')(x)\nx = Dense(200, activation = 'relu')(x)\nx = Dense(150, activation = 'relu')(x)\n\n# Output layer as an integer value\noutput_layer = Dense(len(Shapes), activation = 'softmax')(x)\n\nmodel = Model(input_layer, output_layer)\n\nmodel.summary()","a6a3b555":"# Declare the optimizer\nopt = Adam(lr=0.0005)\n\n# Compile the model\nmodel.compile(loss='categorical_crossentropy', optimizer=opt, metrics=['accuracy'])\n\n# Train the model\nmodel.fit(trainX\n          , trainY\n          , batch_size=32\n          , epochs=10\n          , shuffle=True)","0ac82022":"# Now try to test this against the test data\nmodel.evaluate(testX, testY)","903198de":"# See visually the predictions made\nCLASSES = np.array(Shapes)\n\npreds = model.predict(testX)\npreds_single = CLASSES[np.argmax(preds, axis = -1)]\nactual_single = CLASSES[np.argmax(testY, axis = -1)]\n\nn_to_show = 10\nindices = np.random.choice(range(len(testX)), n_to_show)\n\nfig = plt.figure(figsize=(15, 3))\nfig.subplots_adjust(hspace=0.4, wspace=0.4)\n\nfor i, idx in enumerate(indices):\n    img = testX[idx]\n    ax = fig.add_subplot(1, n_to_show, i+1)\n    ax.axis('off')\n    ax.text(0.5, -0.35, 'pred = ' + str(preds_single[idx]), fontsize=10, ha='center', transform=ax.transAxes) \n    ax.text(0.5, -0.7, 'act = ' + str(actual_single[idx]), fontsize=10, ha='center', transform=ax.transAxes)\n    ax.imshow(img)","0f774f39":"## Test","293658ac":"## Architecture (Deep Learning Network)","77365b64":"## Data","cc94fa07":"## Train","3197fc11":"## Outcome\nThis testing has shown that even with just a simple deep learning network, shapes can be easily identified by this system, and since the shapes are black images on a white background, with high contrast and little noise, a convolutional neural network would not be necessary to improve the score","c7bb0ee6":"# Test Shape Runthrough"}}