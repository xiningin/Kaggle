{"cell_type":{"3aa20d8d":"code","83d7501e":"code","cd257dde":"code","02c2f549":"code","8cb8aee6":"code","f3e390b8":"code","743bbd7b":"code","ddee4b21":"code","87622bf5":"code","fc93fd58":"code","6c507cb9":"code","5fccc5e5":"code","66950801":"code","856b605a":"code","5306cd0a":"code","67d5df08":"code","e3c1bd99":"code","ea1f6b97":"code","c1257576":"code","681249ef":"code","cdc87c1a":"code","14d1adfa":"code","99039d40":"code","798432d5":"code","50972b2d":"code","fa4ced61":"code","e3e6c182":"code","466293f1":"code","df66c0ce":"code","67a38895":"code","6d9e0f19":"code","3c282b34":"code","df1b0d3d":"code","c179574e":"code","b5427b15":"code","c36d3073":"code","099bb10f":"code","0438f53a":"code","8e450b73":"code","54322a97":"code","56883e50":"markdown","3e91c818":"markdown","44b9a2c5":"markdown","bf715b7a":"markdown","425efbcf":"markdown","354f4457":"markdown","a4fb94dc":"markdown","c82c855f":"markdown","66a03dcf":"markdown","0526211d":"markdown","b3b0b27a":"markdown","97e7e36d":"markdown","ac73360f":"markdown","34eeacb1":"markdown","919de5e9":"markdown","221495bc":"markdown","18de3bec":"markdown","a4944482":"markdown","726b872b":"markdown","1ddf6f38":"markdown","24bc923c":"markdown","7b7a4017":"markdown","3d8b480a":"markdown","a4862bec":"markdown","b71368b9":"markdown","00478021":"markdown","d6547993":"markdown","452aa67e":"markdown","6f179866":"markdown","22802289":"markdown","bda1ab90":"markdown","e4032e9b":"markdown"},"source":{"3aa20d8d":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport tensorflow as tf\nimport os\nfrom tensorflow import keras\nimport sys\nimport random\nimport warnings\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom matplotlib import rcParams\nfrom IPython.display import IFrame\nfrom IPython.core.display import display, HTML\nimport imageio\n\nfrom mpl_toolkits import mplot3d\nimport seaborn as sns\nfrom tqdm import tqdm\nfrom itertools import chain\nfrom pydicom.pixel_data_handlers.util import apply_voi_lut\nfrom tensorflow.keras import layers\nfrom tensorflow.keras import losses\nfrom tensorflow.keras import models\nfrom tensorflow.keras import callbacks\n\nimport matplotlib\nmatplotlib.rcParams['animation.html'] = 'jshtml'\nfrom PIL import Image\nimport cv2\nimport glob\nimport re\nimport random\nfrom scipy import ndimage, misc\n\nimport time\nimport cv2\nimport pydicom\nfrom multiprocessing import Pool\nfrom matplotlib.animation import FuncAnimation\nprint(tf.__version__)\nprint(keras.__version__)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","83d7501e":"allInputs = os.walk('\/kaggle\/input')\n# print(type(walking)) #<class 'generator'>\ncount = 0\nfor root, dirs, filenames in allInputs:\n    for filename in filenames:\n        count+=1\n        if(count > 10):\n            break\n        print(os.path.join(root, filename))\n    if(count > 10):\n        break","cd257dde":"!pwd","02c2f549":"config = {\n    'data_path': '\/kaggle\/input\/rsna-miccai-brain-tumor-radiogenomic-classification',\n    'train_data_path': '\/kaggle\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train',\n    'test_data_path': '\/kaggle\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/test',\n    'input_path': '\/kaggle\/input'\n}","8cb8aee6":"# Adapted a brilliant code snippet from StackOverFlow:\n# https:\/\/stackoverflow.com\/questions\/9727673\/list-directory-tree-structure-in-python\n\n# This function will print the first five sub-folders \/ sub files inside the parameter \"startpath\"\ndef list_files(startpath, num):\n    masterCount = 0\n    for root, dirs, files in os.walk(startpath):\n        level = root.replace(startpath, '').count(os.sep)\n        indent = ' ' * 4 * (level)\n        masterCount += 1\n        if(masterCount >= 12):\n            break\n        print('{}{}\/'.format(indent, os.path.basename(root)))\n        subindent = ' ' * 4 * (level + 1)\n        count = 0\n        for f in files:\n            count += 1\n            if(count> num):\n                break\n            print('{}{}'.format(subindent, f))","f3e390b8":"list_files(config['train_data_path'],3)","743bbd7b":"train_df = pd.read_csv(os.path.join(config['data_path'],'train_labels.csv'))\nprint(\"Total number of training data points (number of patient cases): \", len(train_df))\ntrain_df.head()","ddee4b21":"plt.figure(figsize=(5, 5))\nsns.countplot(data=train_df, x=\"MGMT_value\");","87622bf5":"# I did not write this\ndef natural_sort(li): \n    convert = lambda text: int(text) if text.isdigit() else text.lower()\n    alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)]\n    return sorted(li, key=alphanum_key)","fc93fd58":"imgFolders = glob.glob(config['train_data_path']+\"*\/*\/*\")\nfor i in range(5):\n    print(imgFolders[i])\n\nprint(\"Do we have four sub-folders per case?:\")\nprint(len(imgFolders) == 4*len(train_df))\nfor folder in tqdm(imgFolders):\n    filenames = glob.glob(folder+\"\/*\")\n    flag = True\n    for filename in natural_sort(filenames):\n        assert \"Image-\" in filename and \".dcm\" in filename\n        if(flag):\n            count = int(filename[7+len(folder):-4])\n            flag = False\n#         print(filename[7+len(folder):-4])\n        if(count == int(filename[7+len(folder):-4])):\n            count += 1\n        else:\n            print(\"there was a discontinuity, no file: \"+filename)\n            break\n        \n# for (root, dirs, filenames) in tqdm(os.walk(config['train_data_path'])):\n# #     print(root)\n#     count = 0\n#     print(root)\n#     for filename in filenames:\n#         count +=1\n#         if(count>2):\n#             break\n#         print(os.path.join(root, filename))\n    ","6c507cb9":"args={}\nargs['input'] = '..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification'\nargs['output'] = '.\/'\nargs['dataset'] = 'train'\nargs['n_jobs'] = 20\nargs['debug'] = 0\n\n\nFIELDS = [\n    'AccessionNumber',\n    'AcquisitionMatrix',\n#    'B1rms',  # Empty\n#    'BitsAllocated',  # = 16\n#    'BitsStored',  # = 16\n    'Columns',\n    'ConversionType',\n#    'DiffusionBValue',  # 0 or empty\n#    'DiffusionGradientOrientation',  # [0.0, 0.0, 0.0] or empty\n    'EchoNumbers',\n#    'EchoTime',  # empty\n    'EchoTrainLength',\n    'FlipAngle',\n#    'HighBit',  # = 15\n#    'HighRRValue',  #  0 or empty\n    'ImageDimensions',  # 2 or epty\n    'ImageFormat',\n    'ImageGeometryType',\n    'ImageLocation',\n    'ImageOrientation',\n    'ImageOrientationPatient',\n    'ImagePosition',\n    'ImagePositionPatient',\n#    'ImageType',  # ['DERIVED', 'SECONDARY']\n    'ImagedNucleus',\n    'ImagingFrequency',\n    'InPlanePhaseEncodingDirection',\n    'InStackPositionNumber',\n    'InstanceNumber',\n#    'InversionTime',   # empty\n#    'Laterality',  # empty\n#    'LowRRValue',  # empty\n    'MRAcquisitionType',\n    'MagneticFieldStrength',\n#    'Modality',  # MR\n    'NumberOfAverages',\n    'NumberOfPhaseEncodingSteps',\n    'PatientID',\n    'PatientName',\n#    'PatientPosition',  # HFS\n    'PercentPhaseFieldOfView',\n    'PercentSampling',\n#    'PhotometricInterpretation',  # MONOCHROME2\n    'PixelBandwidth',\n#    'PixelPaddingValue',  # empty or 0\n    'PixelRepresentation',\n    'PixelSpacing',\n#    'PlanarConfiguration',  # 0 or empty\n#    'PositionReferenceIndicator',  # 'NA' or empty\n    'PresentationLUTShape',\n    'ReconstructionDiameter',\n#    'RescaleIntercept',  # = 0\n#    'RescaleSlope',  # = 1\n#    'RescaleType',  # = US\n    'Rows',\n    'SAR',\n    'SOPClassUID',\n    'SOPInstanceUID',\n#    'SamplesPerPixel',  # = 1\n    'SeriesDescription',\n    'SeriesInstanceUID',\n    'SeriesNumber',\n    'SliceLocation',\n    'SliceThickness',\n    'SpacingBetweenSlices',\n    'SpatialResolution',\n    'SpecificCharacterSet',\n    'StudyInstanceUID',\n#    'TemporalResolution',  # 0 or empty\n#    'TransferSyntaxUID',  # = 1.2.840.10008.1.2\n#    'TriggerWindow',  # = 0\n    'WindowCenter',\n    'WindowWidth'\n]\n\n# All of the FM fields are empty\nFM_FIELDS = [\n    'FileMetaInformationGroupLength',\n    'FileMetaInformationVersion',\n    'ImplementationClassUID',\n    'ImplementationVersionName',\n    'MediaStorageSOPClassUID',\n    'MediaStorageSOPInstanceUID',\n    'SourceApplicationEntityTitle',\n    'TransferSyntaxUID',\n]\n\nfinal = []\n\n\ndef get_meta_info(dicom):\n    row = {f: dicom.get(f) for f in FIELDS}\n    row_fm = {f: dicom.file_meta.get(f) for f in FM_FIELDS}\n    row_other = {\n#        'is_original_encoding': dicom.is_original_encoding,  # = True\n#        'is_implicit_VR': dicom.is_implicit_VR,  # = True\n#        'is_little_endian': dicom.is_little_endian, # = True\n        'timestamp': dicom.timestamp,\n    }\n    return {**row,\n            #**row_fm,  # All are emtpy\n            **row_other}\n\n\ndef get_dicom_files(input_dir, ds='train'):\n    dicoms = []\n\n    for subdir, dirs, files in os.walk(f\"{input_dir}\/{ds}\"):\n        for filename in files:\n            filepath = subdir + os.sep + filename\n\n            if filepath.endswith(\".dcm\"):\n                dicoms.append(filepath)\n\n    return dicoms\n\n\ndef process_dicom(dicom_src, _x):\n    dicom = pydicom.dcmread(dicom_src)\n    file_data = dicom_src.split(\"\/\")\n    file_src = \"\/\".join(file_data[-4:])\n\n    tmp = {\"BraTS21ID\": file_data[-3], \"dataset\": file_data[-4], \"type\": file_data[-2], \"dicom_src\": f\".\/{file_src}\"}\n    tmp.update(get_meta_info(dicom))\n\n    return tmp\n\n\ndef update(res):\n    if res is not None:\n        final.append(res)\n\n    pbar.update()\n\n\ndef error(e):\n    print(e)\n\n\n# # Actually run this file\n# dicom_files = get_dicom_files(args[\"input\"], args[\"dataset\"])\n\n# if args[\"debug\"]:\n#     dicom_files = dicom_files[:1000]\n\n# pool = Pool(processes=args[\"n_jobs\"])\n# pbar = tqdm(total=len(dicom_files))\n\n# for dicom_file in dicom_files:\n#     pool.apply_async(\n#         process_dicom,\n#         args=(dicom_file, ''),\n#         callback=update,\n#         error_callback=error,\n#     )\n\n# pool.close()\n# pool.join()\n# pbar.close()\n\n# final = pd.DataFrame(final)\n# final.to_csv(f\"{args['output']}\/dicom_meta_{args['dataset']}.csv\", index=False)\n","5fccc5e5":"# final.head()","66950801":"def images_paths_from_patientID(BraTS21ID, imgs_per_folder = 1):\n    patientFolderPath = os.path.join(config['train_data_path'],str(BraTS21ID).zfill(5))\n    imgList = []\n    \n    # get the name of the four sub-folders\n    for dir in glob.glob(os.path.join(patientFolderPath,\"*\")):\n        for i in range(imgs_per_folder):\n            imgFileName = random.choice(glob.glob(os.path.join(dir,\"*\")))\n            imgList.append(imgFileName)\n    return imgList\n\nprint(images_paths_from_patientID(324, imgs_per_folder = 2))","856b605a":"# https:\/\/www.kaggle.com\/arnabs007\/part-1-rsna-miccai-btrc-understanding-the-data\ndef get_image_plane(dicomFile):\n    '''\n    Returns the MRI's plane from the dicom data.\n    \n    '''\n#     print(dicomFile.get(\"ImageOrientationPatient\"))\n    x1,y1,_,x2,y2,_ = [round(j) for j in dicomFile.get(\"ImageOrientationPatient\")]\n    cords = [x1,y1,x2,y2]\n\n    if cords == [1,0,0,0]:\n        return 'coronal'\n    if cords == [1,0,0,1]:\n        return 'axial'\n    if cords == [0,1,0,0]:\n        return 'sagittal'","5306cd0a":"def display_img_from_file(fileNames, resize = True):\n    num = len(fileNames)\n    print(num)\n    fig, axs = plt.subplots(num\/\/4, 4, sharex=True, sharey=True, figsize=(15,15))\n    count = 0\n    for img in fileNames:\n#         print(img)\n        image = pydicom.dcmread(img)\n        plane = get_image_plane(image)\n        \n        if resize:\n            imageArr = cv2.resize(image.pixel_array, (256,256))\n        else:\n            imageArr = image.pixel_array\n\n        ser = img.split(\"\/\")\n        title = ser[-2] + \" - \" + plane + \" | size: \" + str(imageArr.shape)\n        axs[count\/\/4, count%4].title.set_text(title)\n        axs[count\/\/4, count%4].imshow(imageArr, cmap='gray')\n        axs[count\/\/4, count%4].axis(\"off\")\n        count += 1","67d5df08":"patientIDs = train_df[\"BraTS21ID\"].sample(n=3).to_numpy()\nprint(patientIDs)\nfileNames = []\n\nfor patientID in patientIDs:\n    for fileName in images_paths_from_patientID(patientID, 2):\n        fileNames.append(fileName)\n        \nprint(len(fileNames))","e3c1bd99":"# Takes a list of fileName (specific to \"*\/*\/*.dcm\") and print metadata and original image\ndef display_img_from_file(fileNames, showHist = False):\n    num = len(fileNames)\n    print(num)\n    fig, axs = plt.subplots(num\/\/4, 4, sharex=True, sharey=True, figsize=(15,15))\n    fig.subplots_adjust(left=None, bottom=None, right=None, top=1.25, wspace=None, hspace=None)\n    count = 0\n    \n    for img in fileNames:\n        \n        image = pydicom.dcmread(img)\n        plane = get_image_plane(image)\n        image = image.pixel_array\n        \n        # display metadata in title\n        ser = img.split(\"\/\")\n        title = ser[-2] + \" - \" + plane + \" | size: \" + str(image.shape)\n        title += \"\\n\" + \"data type:\" + str(image.dtype)\n        title += \"\\n\" + \"range: \" + str(np.amax(image) - np.amin(image))\n        title +=  \" mean: \" + \"{:.2f}\".format(np.mean(image))\n        \n        axs[count\/\/4, count%4].title.set_text(title)\n        if(not showHist):\n            axs[count\/\/4, count%4].imshow(image, cmap='gray')\n        else:\n            histogram, bin_edges = np.histogram(image, bins=256)\n            axs[count\/\/4, count%4].plot(bin_edges[:-1], histogram)\n            \n        axs[count\/\/4, count%4].axis(\"off\")\n        count += 1      ","ea1f6b97":"display_img_from_file(fileNames)","c1257576":"def get_voxel(patientFolder, scan_type):\n    \n    dcm_dir = os.path.join(patientFolder, scan_type)\n#     dcm_dir = os.path.join(config[\"train\"], study_id, scan_type)\n#     dcm_dir = data_root.joinpath(DATASET, study_id, scan_type)\n\n    # This is a naive way of sorting, not based on metadata\n#     dcm_paths = sorted(glob.glob(dcm_dir + \"\/*.dcm\"), key=lambda x: int(x.stem.split(\"-\")[-1]))\n    dcm_paths = natural_sort(glob.glob(dcm_dir + \"\/*.dcm\"))\n    \n    imgs = []\n    positions = []\n    \n    size = -1\n    for dcm_path in dcm_paths:\n        img = pydicom.dcmread(str(dcm_path))\n        imgs.append(img.pixel_array)\n        if size == -1:\n            size = img.pixel_array.shape\n        elif size != img.pixel_array.shape:\n            print(\"Inconsistent size of image: \" + str(img.pixel_array.shape))\n\n        positions.append(img.ImagePositionPatient)\n    \n    plane = get_image_plane(img)\n    # Notice that all images are supposed to have the same size\n    voxel = np.stack(imgs)\n    \n    # reorder planes if needed and rotate voxel\n    # This is also a naive way to determine if the order of images need to be re-ordered.\n    if plane == \"coronal\":\n        if positions[0][1] < positions[-1][1]:\n            voxel = voxel[::-1]\n            print(f\"{dcm_dir[-9:]} {scan_type} {plane} reordered\")\n        voxel = voxel.transpose((1, 0, 2))\n    elif plane == \"sagittal\":\n        if positions[0][0] < positions[-1][0]:\n            voxel = voxel[::-1]\n            print(f\"{dcm_dir[-9:]} {scan_type} {plane} reordered\")\n        voxel = voxel.transpose((1, 2, 0))\n        voxel = np.rot90(voxel, 2, axes=(1, 2))\n    elif plane == \"axial\":\n        if positions[0][2] > positions[-1][2]:\n            voxel = voxel[::-1]\n            print(f\"{dcm_dir[-9:]} {scan_type} {plane} reordered\")\n        voxel = np.rot90(voxel, 2)\n    else:\n        raise ValueError(f\"Unknown plane {plane}\")\n#     return voxel, plane\n    return voxel","681249ef":"def normalize_contrast(voxel):\n    if voxel.sum() == 0:\n        return voxel\n    voxel = voxel - np.min(voxel)\n    voxel = voxel \/ np.max(voxel)\n    voxel = (voxel * 255).astype(np.uint8)\n    return voxel","cdc87c1a":"def crop_voxel(voxel):\n    if voxel.sum() == 0:\n        return voxel\n    keep = (voxel.mean(axis=(0, 1)) > 0)\n    voxel = voxel[:, :, keep]\n    keep = (voxel.mean(axis=(0, 2)) > 0)\n    voxel = voxel[:, keep, :]\n    keep = (voxel.mean(axis=(1, 2)) > 0)\n    voxel = voxel[keep, :, :]\n    return voxel","14d1adfa":"voxel = get_voxel(\"\/kaggle\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train\/00688\", \"T2w\")","99039d40":"print(type(voxel))\nprint(voxel.mean())\nprint(voxel.shape)\n\nprint(\"\\nNow crop this voxel \\n\")\nvoxel = crop_voxel(voxel)\nprint(voxel.mean())\nprint(voxel.shape)\n\nprint(\"\\nNow Downsample this voxel \\n\")\nx = voxel.shape[0]\ny = voxel.shape[1]\nz = voxel.shape[2]\n\ndownsampled_voxel = ndimage.zoom(voxel, (32\/x, 24\/y, 34\/z))\nprint(downsampled_voxel.mean())\nprint(downsampled_voxel.shape)","798432d5":"# after stacking along axis = 0, the z is supposed to be in the front\nz,x,y = downsampled_voxel.nonzero()\nfig = plt.figure(figsize=(15, 15))\nax = fig.add_subplot(111, projection='3d')\nax.set_xlabel('X Label')\nax.set_ylabel('Y Label')\nax.set_zlabel('Z Label')\n\nax.scatter(x, y, z)\nplt.show()","50972b2d":"# Randomly selects one patient and displays the origianl \/ unprocessed images \npatientIDs = train_df[\"BraTS21ID\"].sample(n=1).to_numpy()\nprint(patientIDs)\nfileNames = []\n\n# Get the filenames\nfor patientID in patientIDs:\n    for fileName in images_paths_from_patientID(patientID, 5): # 4 subfolders, 5 imgs from each = 20 total imgs\n        fileNames.append(fileName)\nprint(len(fileNames))","fa4ced61":"display_img_from_file(fileNames)","e3e6c182":"patientIDs[0]\nprint(type(patientIDs[0]))\npatientFolder = \"\/kaggle\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train\/\" + str(patientIDs[0]).zfill(5)\nprint(patientFolder)","466293f1":"# load all four subfolders of this specific patient\nvoxelT2w = get_voxel(patientFolder, \"T2w\")\nvoxelT1wCE = get_voxel(patientFolder, \"T1wCE\")\nvoxelT1w = get_voxel(patientFolder, \"T1w\")\nvoxelFLAIR = get_voxel(patientFolder, \"FLAIR\")","df66c0ce":"# Check basic dimensions\ndef check_basic_info():\n    print(type(voxelT2w))\n    print(voxelT2w.mean())\n    print(voxelT2w.shape)\n\n    print(type(voxelT1wCE))\n    print(voxelT1wCE.mean())\n    print(voxelT1wCE.shape)\n\n    print(type(voxelT1w))\n    print(voxelT1w.mean())\n    print(voxelT1w.shape)\n\n    print(type(voxelFLAIR))\n    print(voxelFLAIR.mean())\n    print(voxelFLAIR.shape)\n\ncheck_basic_info()","67a38895":"def resize_interpol(voxel, size = (128, 128, 128)):\n    x = voxel.shape[0]\n    y = voxel.shape[1]\n    z = voxel.shape[2]\n\n    downsampled_voxel = ndimage.zoom(voxel, (size[0]\/x, size[1]\/y, size[2]\/z))\n    return downsampled_voxel","6d9e0f19":"voxelT2w = crop_voxel(voxelT2w)\nvoxelT2w = resize_interpol(voxelT2w)\nvoxelT2w = normalize_contrast(voxelT2w)\n\nvoxelT1wCE = crop_voxel(voxelT1wCE)\nvoxelT1wCE = resize_interpol(voxelT1wCE)\nvoxelT1wCE = normalize_contrast(voxelT1wCE)\n\nvoxelT1w = crop_voxel(voxelT1w)\nvoxelT1w = resize_interpol(voxelT1w)\nvoxelT1w = normalize_contrast(voxelT1w)\n\nvoxelFLAIR = crop_voxel(voxelFLAIR)\nvoxelFLAIR = resize_interpol(voxelFLAIR)\nvoxelFLAIR = normalize_contrast(voxelFLAIR)\n\ncheck_basic_info()","3c282b34":"# https:\/\/www.kaggle.com\/sreevishnudamodaran\/rsna-3d-clahe-voxels-tpu-3d-augmentations\ndef show_animation(images, normalized=True):\n    fig = plt.figure(figsize=(4, 4))\n    plt.axis('off')\n    if normalized:\n        im = plt.imshow(images[0], cmap='gray', vmin=0.0, vmax=1.0)\n    else:\n#         print(\"hahahah\")\n        im = plt.imshow(images[0], cmap='gray', vmin=0.0, vmax=255.0)\n    def animate(i):\n        im.set_array(images[i])\n        # return the artists set\n        return [im]\n    display(FuncAnimation(fig, animate, frames=len(images),\n                                               interval=50))\n    plt.close()\n\nshow_animation(voxelT1w, False)","df1b0d3d":"show_animation(voxelT2w, False)","c179574e":"show_animation(voxelT1wCE, False)","b5427b15":"show_animation(voxelFLAIR, False)","c36d3073":"# axis = 0 should be cropping at ? axis?\n\n# Distance -> sampling distance. Pick one img from every stack of 5 images\n# Number of images output = original number of images on axis \/ sampling distance\n# Skip_imgs -> skip the first and last few selected images (as they are probably not useful anyway)\ndef resample_from_voxel(voxel, axis = 0, distance = 3, skip_imgs = 3):\n    output_imgs = []\n    counter = 0\n    for i in range(voxel.shape[axis]\/\/distance):\n        if axis == 0:\n            output_imgs.append(voxel[counter, :, :])\n#             print(\"added image\")\n        elif axis == 1:\n            output_imgs.append(voxel[:, counter, :])\n        elif axis ==2:\n            output_imgs.append(voxel[:, :, counter])\n        counter += distance\n        \n    output = np.array(output_imgs[skip_imgs: -skip_imgs])\n    return output","099bb10f":"# The size shows that cropping works.\noutputT2w = resample_from_voxel(voxelT2w, distance = 2,axis = 0)\noutputT1wCE = resample_from_voxel(voxelT1wCE, axis = 0)\noutputT1w = resample_from_voxel(voxelT1w, axis = 0)\noutputFLAIR = resample_from_voxel(voxelFLAIR, axis = 0)\n\nprint(outputT2w.shape)\nprint(outputT1wCE.shape)\nprint(outputT1w.shape)\nprint(outputFLAIR.shape)","0438f53a":"show_animation(outputT2w, False)","8e450b73":"# display imgs from data of shape (x,y,z)\ndef print_imgs_from_numpy_data(data, num = 10):\n\n    fig, axs = plt.subplots(num\/\/5, 5, sharex=True, sharey=True, figsize=(15,15))\n#     fig.subplots_adjust(left=None, bottom=None, right=None, top=1.25, wspace=None, hspace=None)\n    \n    sample_rate = data.shape[0]\/\/num\n    print(sample_rate)\n    count = 0\n    img_num = 0\n    \n    for i in range(num):\n        image = data[count,:,:]\n        assert len(image.shape) == 2\n        axs[img_num\/\/5, count%5].imshow(image, cmap='gray')\n        title = \"\"\n        title += \"\\n\" + \"data type:\" + str(image.dtype)\n        title += \"\\n\" + \"range: \" + str(np.amax(image) - np.amin(image))\n        title +=  \" mean: \" + \"{:.2f}\".format(np.mean(image))\n        \n        axs[img_num\/\/5, count%5].title.set_text(title)\n        axs[img_num\/\/5, count%5].axis(\"off\")\n        count += sample_rate\n        img_num+=1","54322a97":"print_imgs_from_numpy_data(outputT1wCE)","56883e50":"## Can we trust the integrity and organization of the images in each subfolder of each patient?\n**Iterate through the whole folder structure and check for problems**\n\n**Using tqdm to show the progress**","3e91c818":"### Define a Helper Function to print out structured files","44b9a2c5":"**All the labels(MGMT_value) are 0 and 1**","bf715b7a":"# Data Loader and Pre-processor","425efbcf":"### Print 10 filesname just to see what it looks like","354f4457":"### A function to get four images fileNames (each of one type) for one patient","a4fb94dc":"## Further Data Manipulation","c82c855f":"### Define a Helper Function\n\nThis is directly adapted from this brilliant kernel https:\/\/www.kaggle.com\/mikecho\/rsna-miccai-monai-ensemble\/notebook","66a03dcf":"### A function to get the image plane from DICOM file\n**This is directly adopted from this brilliant notebook: https:\/\/www.kaggle.com\/arnabs007\/part-1-rsna-miccai-btrc-understanding-the-data**","0526211d":"**We can see that the distribution is quite balanced.**\n\n**Note this: having a 0 MGMT_value doesn't mean there is no tumor!!!**","b3b0b27a":"## Showcasing our 3D-reconstruction works","97e7e36d":"## Now Re-sample down","ac73360f":"### There are indeed discontinuities in the filenames!!\n**For now, I will skip these. We will revisit them later after having defined a good image loader for DICOM images**","34eeacb1":"# Image Pre-processing\n\n**reconstruct to 3D and then re-sample**\n\n**resize the images**\n\n**normalize and standardize the pixel values**\n\n**auto center-cropping**","919de5e9":"##  Crop, normalize, resize and check again","221495bc":"# Folder Stucture and Simple Counting\n**In this section, we will go through:**\n\n**1. illustrating the folder structure of training data folder**\n\n**2. Quick note on the level of balance of input data**\n\n**3. try sort the paths stored in a random folder of images**\n\n**4. find out if there are any potential problems in the filenames of these images**\n\n**5. find out whether the images are named strictly consecutively**","18de3bec":"### Here's what they originally look like","a4944482":"**Note that: filesnames in folders can be continuous even if they don't start at \"Image-1.dcm\". It happens several times throughout the dataset.**\n\n**For example: \"\/kaggle\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train\/00547\/T2w\/Image-258.dcm\" was the first image in that folder... weird.**","726b872b":"## Actual Data Loader","1ddf6f38":"### Reconstruct to 3D\n**Adapted from this wonderful notebook: https:\/\/www.kaggle.com\/sreevishnudamodaran\/rsna-3d-clahe-voxels-tpu-3d-augmentations**","24bc923c":"## Test our get_voxel() method, see if it helps (new random patient)","7b7a4017":"# EDA\n### Author: Yuxing Zhou\n### Date: Sep 12\n\n## Referenced Kernels and Other Links:\nhttps:\/\/www.kaggle.com\/xhlulu\/siim-covid-19-convert-to-jpg-256px\n\nhttps:\/\/www.kaggle.com\/smoschou55\/advanced-eda-brain-tumor-data\/comments#Main-Competition-Workflow\n\nhttps:\/\/www.kaggle.com\/ihelon\/brain-tumor-eda-with-animations-and-modeling\n\nhttps:\/\/www.kaggle.com\/ayuraj\/brain-tumor-eda-and-interactive-viz-with-w-b\n\nhttps:\/\/case.edu\/med\/neurology\/NR\/MRI%20Basics.htm\n\nhttps:\/\/www.kaggle.com\/arnabs007\/part-1-rsna-miccai-btrc-understanding-the-data\n\nhttps:\/\/www.kaggle.com\/sreevishnudamodaran\/rsna-3d-clahe-voxels-tpu-3d-augmentations","3d8b480a":"### These pictures need to be normalized and correctly aligned!\n**Otherwise, we can see that there range, mean, and even size vary a lot**","a4862bec":"### Define a helper function\n\n**Display:**\n\n**1. Original image shape**\n\n**2. np.mean**\n\n**3. range of values**","b71368b9":"## Import libraries","00478021":"### A function to display 4*n images (with axis information)","d6547993":"### Combine them and show some sample images","452aa67e":"### Display some images to see how much improvements can be made","6f179866":"## Global Configurations","22802289":"# Table of Contents\n### 1. Make sense of provided data & files\n### 2. Check for corrupted\/weird data\n### 3. Visualize data of positive \/ negative cases\n### 4. Explore the data in 3D\n### 5. Explore ways to align images \/ center-crop \/ other augmentation\n### 6. My opinion on the ultimate goal of this competition","bda1ab90":"#### Important Questions\nWhich axis should we be cropping against?","e4032e9b":"## DICOM MetaData\n\n**Here we try to find out whether there are any useful metadata**\n\n**This code snippets is adapted from Peter's post https:\/\/www.kaggle.com\/c\/rsna-miccai-brain-tumor-radiogenomic-classification\/discussion\/252942**\n\n#### Three axis to take the MRI scans below:\n\n![image.png](attachment:d62e0845-5aaa-4fe8-94ee-53b1afc26f03.png)"}}