{"cell_type":{"551b800d":"code","64898656":"code","3122350b":"code","4796baa2":"code","1782fa72":"code","37f839fc":"code","e510d578":"code","6511f274":"code","453142d7":"code","88affd93":"code","6bd6ee50":"code","f4843912":"code","10404df0":"code","2f59d2c9":"code","a4afe407":"code","33b89b9b":"code","067e1094":"code","6caddbf7":"code","bb231ab5":"code","73152961":"code","f64b61c5":"code","e752ea58":"code","1677cf07":"code","a5e7a03a":"code","189db066":"code","e094108a":"code","03d4529d":"code","e8b742da":"code","e94c8639":"code","9dac5006":"code","5358f496":"code","b6461055":"code","2bcd3e99":"code","e3b77ea7":"code","60e5e5af":"code","1f42db62":"code","f292d247":"code","eb057151":"code","422f12bb":"code","da31dd58":"code","00e2bbdd":"code","e351df16":"code","d0f69a8f":"code","4bdb77e6":"code","4fce56f5":"code","f725d3b8":"code","a48df06b":"code","bae4c532":"code","68409c01":"code","e8b0a5fa":"markdown","2d3ab57f":"markdown","562e34e5":"markdown"},"source":{"551b800d":"#!pip install -U pandas-profiling","64898656":"!conda install -y pygraphviz pomegranate","3122350b":"#importing libs\nimport numpy as np \nimport pandas as pd \nimport pandas_profiling\nfrom pandas_profiling import ProfileReport\nimport matplotlib\nimport matplotlib.pyplot as plt \nimport seaborn as sns #data visualization\nimport warnings\nimport pygraphviz\nimport math\n\nfrom sklearn import preprocessing\n\n# Train Test Split\nfrom sklearn.model_selection import train_test_split\n\n# Models\nfrom sklearn.tree import DecisionTreeClassifier\nfrom pomegranate import *\n\n# Metrics\nfrom sklearn.metrics import accuracy_score, classification_report, roc_curve\nfrom sklearn import tree\nfrom sklearn.tree import plot_tree \nfrom sklearn.tree import _tree\n\n# Cross Validation\nfrom sklearn.metrics import accuracy_score, confusion_matrix, classification_report, recall_score, precision_score, f1_score\n\nwarnings.filterwarnings(\"ignore\")\n%matplotlib inline","4796baa2":"df = pd.read_csv('..\/input\/bank-loan-modelling\/bank_loan_modelling.csv')","1782fa72":"df.shape","37f839fc":"df.head(5)","e510d578":"# Performing Exploratory Data Analysis using Panda Profiling\n#profile = ProfileReport(df)\n# putting Exploratory Data Analysis report to the notebook\n#profile.to_file(\"Exploratory Data Analysis Report.html\")\n#profile.to_widgets()","6511f274":"fig = plt.figure(figsize=(15,10))\nsns.heatmap(df.corr(), cmap=\"Spectral\", annot=True)\nplt.title(\"Correlation Heatmap\")\nplt.show()","453142d7":"df.duplicated().sum()","88affd93":"df.drop_duplicates(inplace=True)\ndf.shape","6bd6ee50":"df = df[(df[['Experience']] >= 0).all(1)]\ndf.shape","f4843912":"df2 = df.copy()","10404df0":"min_income = df['Income'].min()\nmax_income = df['Income'].max()\nprint(min_income)\nprint(max_income)","2f59d2c9":"bins_income_labels = [1,2,3,4,5,6,7,8,9,10]\nbins_income = np.linspace(min_income,max_income,11)\nprint(bins_income)","a4afe407":"df2['income_bins'] = pd.cut(df2['Income'], bins=bins_income, labels=bins_income_labels,include_lowest=True)\ndf2.head(5)","33b89b9b":"plt.hist(df2['income_bins'])","067e1094":"min_CCAvg = df['CCAvg'].min()\nmax_CCAvg = df['CCAvg'].max()\nprint(min_CCAvg)\nprint(max_CCAvg)","6caddbf7":"bins_CCAvg_labels = [1,2,3,4,5,6,7,8,9,10]\nbins_CCAvg = np.linspace(min_CCAvg,max_CCAvg,11)\nprint(bins_CCAvg)","bb231ab5":"df2['CCAvg_bins'] = pd.cut(df2['CCAvg'], bins=bins_CCAvg, labels=bins_CCAvg_labels, include_lowest=True)\ndf2.head(5)","73152961":"plt.hist(df2['CCAvg_bins'])","f64b61c5":"min_Age = df['Age'].min()\nmax_Age = df['Age'].max()\nprint(min_Age)\nprint(max_Age)","e752ea58":"bins_age_labels = [1,2,3,4,5,6,7,8,9,10,11]\nbins_age = np.arange(15, 71, 5)\nprint(bins_age)","1677cf07":"df2['Age_bins'] = pd.cut(df2['Age'], bins=bins_age, labels=bins_age_labels, include_lowest=True)\ndf2.head(5)","a5e7a03a":"#Bin limits for Experience\nmin_Experience = df['Experience'].min()\nmax_Experience = df['Experience'].max()\nprint(min_Experience)\nprint(max_Experience)","189db066":"#Finding bins for Experience\nbins_exp_labels = [1,2,3,4,5,6,7,8,9]\nbins_exp = np.arange(0, 50, 5)\nprint(bins_exp)","e094108a":"#Binning Experience\ndf2['Exp_bins'] = pd.cut(df2['Experience'], bins=bins_exp, labels=bins_exp_labels, include_lowest=True)\ndf2.head(5)","03d4529d":"#Dropping without numerical variables\ndata_BBN = df2.drop(['Age', 'Experience', 'Income','CCAvg'],axis=1)\ndata_BBN.head()","e8b742da":"#Finding discrete probability for independent variable\ndef discreteProb(a, data):\n  Probs=data.groupby(a).size()\/len(data)\n  C = pd.DataFrame(Probs)\n  C.columns=['Probability']\n  return C \n\n#finding conditional probability\ndef condProbTable(a , given , data):\n    final = []\n    if len(given)!=0:\n        Given=list(given)\n        Given.append(a)\n        Probs=data.groupby(Given).size()\/data.groupby(given).size()\n        A = pd.DataFrame(Probs)\n        Indexes = A.index\n        \n        C=pd.DataFrame()\n        FirstColName='('\n        for i in range(0,len( Indexes.names )-1):\n            FirstColName=FirstColName+Indexes.names[i]+' '\n            if(i==len(Indexes.names)-2):\n                FirstColName=FirstColName+')'\n            else:\n                FirstColName=FirstColName+', '\n        C[FirstColName]=[Indexes[i][0:len(given)] for i in range(0,len(Indexes))]\n        D=C.copy()\n        C=C.drop_duplicates().reset_index(drop =True)\n        aValues= [Indexes[i][len(given)] for i in range(0,len(Indexes))]\n        for i in list(set(aValues)):\n            C[a+' = '+str(i)] = 0.\n        for i in range(0,len(C)):\n            for j in D[D.iloc[:,0]==C.iloc[:,0][i]].index.values:\n                x=list(C.iloc[i,0])\n                x.append(aValues[j])\n                #x.append(A.loc[x])\n                x=tuple(x)\n                bc = A.loc[x,0]\n                if math.isnan(bc):\n                  bc = 0\n                new = x + (bc,) \n                final.append(list(new))\n                #print(list(new))\n                \n                C[a+' = '+str(aValues[j])][i]=A.loc[x]\n    else:\n        print(\"Given is none\")   \n    return final","e94c8639":"#discrete probability of age\nage_prob = discreteProb('Age_bins', data=data_BBN)\nprint(age_prob)","9dac5006":"#discrete probability of family\nfamily_prob = discreteProb('Family', data=data_BBN)\nprint(family_prob)","5358f496":"# Age node has no parents\nage = Node(DiscreteDistribution({\n    1\t: 0.000000,\n    2\t: 0.009246,\n    3\t: 0.106226,\n    4\t: 0.131087,\n    5\t: 0.118143,\n    6\t: 0.132936,\n    7\t: 0.124101,\n    8\t: 0.130881,\n    9\t: 0.135813,\n    10\t: 0.104582,\n    11\t: 0.006986\n}), name=\"Age\")","b6461055":"# Family node has no parents\nfamily = Node(DiscreteDistribution({\n    1  :  0.297514,\n    2  :  0.257859,\n    3  :  0.201356,\n    4  :  0.243271\n}), name=\"Family\")","2bcd3e99":"# Education node is conditional on Age\neducation = Node(ConditionalProbabilityTable(condProbTable('Education', given= ['Age_bins'], data=data_BBN), [age.distribution]), name=\"Education\")\n\n# Experince node is conditional on Age\nexperince = Node(ConditionalProbabilityTable(condProbTable('Exp_bins', given= ['Age_bins'], data=data_BBN), [age.distribution]), name=\"Experince\")\n\n# Online node is conditional on Education\nonline = Node(ConditionalProbabilityTable(condProbTable('Online', given= ['Education'], data=data_BBN), [education.distribution]), name=\"Online\")\n\n# Income node is conditional on Education and Experince\nincome = Node(ConditionalProbabilityTable(condProbTable('income_bins', given= ['Exp_bins', 'Education'], data=data_BBN), [experince.distribution, education.distribution]), name=\"Income\")\n\n# CCAvg node is conditional on Income, Online and Family\nccavg = Node(ConditionalProbabilityTable(condProbTable('CCAvg_bins', given= ['income_bins', 'Online' , 'Family'], data=data_BBN), [income.distribution, online.distribution, family.distribution]), name=\"CCAvg\")\n\n# Personal Loan node is conditional on Income and CCAvg\npersonal_loan = Node(ConditionalProbabilityTable(condProbTable('Personal Loan', given= ['CCAvg_bins', 'income_bins'], data=data_BBN), [ccavg.distribution, income.distribution]), name=\"Personal Loan\")\n","e3b77ea7":"# Create a Bayesian Network and add states\nBBNmodel = BayesianNetwork('Loan Prediction')\nBBNmodel.add_states(age, family, education, experince, online, income, ccavg, personal_loan)","60e5e5af":"# Add edges connecting nodes\nBBNmodel.add_edge(age, education)\nBBNmodel.add_edge(education, online)\nBBNmodel.add_edge(age, experince)\nBBNmodel.add_edge(experince, income)\nBBNmodel.add_edge(education, income)\nBBNmodel.add_edge(online, ccavg)\nBBNmodel.add_edge(income, ccavg)\nBBNmodel.add_edge(family, ccavg)\nBBNmodel.add_edge(ccavg, personal_loan)\nBBNmodel.add_edge(income, personal_loan)","1f42db62":"# Finalize model\nBBNmodel.bake()","f292d247":"# Ploting model\nBBNmodel.plot()","eb057151":"# Print predictions for each node\ndef printPrediction(predictions):\n  for node, prediction in zip(BBNmodel.states, predictions):\n      if isinstance(prediction, str):\n          print(f\"{node.name}: {prediction}\")\n      else:\n          print(f\"{node.name}\")\n          for value, probability in prediction.parameters[0].items():\n              print(f\"    {value}: {probability:.4f}\")","422f12bb":"# Calculate probability that a customer with 4 people in their family, who uses online internet banking facilities, and has a graduate degree took a personal loan\npredictions = BBNmodel.predict_proba({\n    \"Online\" : \"1\",\n    \"Education\": \"2\",\n    \"Family\" : \"4\"\n})\n\n# Print predictions\nprintPrediction(predictions)","da31dd58":"# Calculate probability for a given observation (age, family, education, experince, online, income, ccavg, personal_loan)\nprobability = BBNmodel.probability([[5, 2, 3, 4, None, None, None, 1]])\n\n# Print predictions\nprint(probability)","00e2bbdd":"# Calculate probability that a customer with 4 people in their family, who uses online internet banking facilities, and has a graduate degree took a personal loan\npredictions = BBNmodel.predict_proba({\n    \"age\" : \"5\",\n    \"Education\": \"3\",\n    \"Family\" : \"2\",\n    \"Experince\" : \"4\",\n    \"Personal Loan\" : \"1\"\n})\n\nprintPrediction(predictions)","e351df16":"# defining the features and target\nX = df.drop(['Personal Loan'],axis=1)\ny = df[['Personal Loan']]\nX.head(5)","d0f69a8f":"#Train and test split\nX_train, X_test, y_train, y_test = train_test_split(X,y, test_size = 0.2, random_state = 42)\nprint(\"The shape of X_train is      \", X_train.shape)\nprint(\"The shape of X_test is       \",X_test.shape)\nprint(\"The shape of y_train is      \",y_train.shape)\nprint(\"The shape of y_test is       \",y_test.shape)","4bdb77e6":"#Create Decision Tree Classification Model\ndt_model = DecisionTreeClassifier(criterion = \"entropy\", random_state = 42)\ndt_model.fit(X_train, y_train) \n  \n#Predict the value for new, unseen data\npredict_dt = dt_model.predict(X_test)\n\ndt_model.tree_","4fce56f5":"#Getting the complete Classification Report for Decision Tree Classification Model\nprint(classification_report(y_test, predict_dt))","f725d3b8":"def get_readable_rules(tree, feature_names, class_names):\n    tree_ = tree.tree_\n    feature_name = [\n        feature_names[i] if i != _tree.TREE_UNDEFINED else \"undefined!\"\n        for i in tree_.feature\n    ]\n\n    paths = []\n    path = []\n    \n    def recurse(node, path, paths):\n        \n        if tree_.feature[node] != _tree.TREE_UNDEFINED:\n            name = feature_name[node]\n            threshold = tree_.threshold[node]\n            p1, p2 = list(path), list(path)\n            p1 += [f\"({name} <= {np.round(threshold, 3)})\"]\n            recurse(tree_.children_left[node], p1, paths)\n            p2 += [f\"({name} > {np.round(threshold, 3)})\"]\n            recurse(tree_.children_right[node], p2, paths)\n        else:\n            path += [(tree_.value[node], tree_.n_node_samples[node])]\n            paths += [path]\n            \n    recurse(0, path, paths)\n\n    # sort by samples count\n    samples_count = [p[-1][1] for p in paths]\n    ii = list(np.argsort(samples_count))\n    paths = [paths[i] for i in reversed(ii)]\n    \n    rules = []\n    for path in paths:\n        rule = \"if \"\n        \n        for p in path[:-1]:\n            if rule != \"if \":\n                rule += \" and \"\n            rule += str(p)\n        rule += \" then \"\n        if class_names is None:\n            rule += \"response: \"+str(np.round(path[-1][0][0][0],3))\n        else:\n            classes = path[-1][0][0]\n            l = np.argmax(classes)\n            rule += f\"class: {class_names[l]} (proba: {np.round(100.0*classes[l]\/np.sum(classes),2)}%)\"\n        rule += f\" | based on {path[-1][1]:,} samples\"\n        rules += [rule]\n        \n    return rules","a48df06b":"rules = get_readable_rules(dt_model, list(X_train.columns), ['0','1'])\nfor r in rules:\n    print(r)","bae4c532":"def get_prolog_rules(tree, feature_names, class_names):\n    tree_ = tree.tree_\n    feature_name = [\n        feature_names[i] if i != _tree.TREE_UNDEFINED else \"undefined!\"\n        for i in tree_.feature\n    ]\n\n    paths = []\n    path = []\n    \n    def recurse(node, path, paths):\n        \n        if tree_.feature[node] != _tree.TREE_UNDEFINED:\n            name = feature_name[node]\n            threshold = tree_.threshold[node]\n            p1, p2 = list(path), list(path)\n            p1 += [f\"{name} =< {np.round(threshold, 3)}\"]\n            recurse(tree_.children_left[node], p1, paths)\n            p2 += [f\"{name} > {np.round(threshold, 3)}\"]\n            recurse(tree_.children_right[node], p2, paths)\n        else:\n            path += [(tree_.value[node], tree_.n_node_samples[node])]\n            paths += [path]\n            \n    recurse(0, path, paths)\n\n    # sort by samples count\n    samples_count = [p[-1][1] for p in paths]\n    ii = list(np.argsort(samples_count))\n    paths = [paths[i] for i in reversed(ii)]\n    \n    rules = []\n    for path in paths:\n        rule = \":- \"\n        \n        for p in path[:-1]:\n            if rule != \":- \":\n                rule += \", \"\n            rule += str(p)\n        rule += \".\"\n        if class_names is None:\n            rule += \"response: \"+str(np.round(path[-1][0][0][0],3))\n        else:\n            classes = path[-1][0][0]\n            l = np.argmax(classes)\n            rule = \"class(\" + class_names[l] + \", Age, Experience, Income, Family, CCAvg, Education, Online) \" + rule\n        rules += [rule]\n        \n    return rules","68409c01":"rules = get_prolog_rules(dt_model, list(X_train.columns), ['0','1'])\nfor r in rules:\n    print(r)","e8b0a5fa":"**Probability for the data with the following properties:**\n\nAge\t= 41-45  \nFamily = 2\t\nEducation = 3\t\nExperience = 16-25\t\nPersonal Loan = 1\n\n","2d3ab57f":"# Decision Tree Classification Model","562e34e5":"# Bank Loan Modelling"}}