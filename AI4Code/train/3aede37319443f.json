{"cell_type":{"50a065b4":"code","c3cd0b7f":"code","4b7ceee3":"code","1051b687":"code","bad73a41":"code","3d96b8ec":"code","fffdc737":"code","a7114526":"code","c835bc59":"code","1c951f74":"code","0877c57a":"code","b0c6798f":"code","6c37ced2":"code","492e0399":"code","9349a356":"code","feaa7f85":"code","640df90a":"code","d2471511":"code","66834215":"code","38dac58a":"code","28ad1ed4":"code","7cc7087f":"code","d97e69a9":"code","8f71da30":"markdown","d1b03253":"markdown","fe521b5f":"markdown","c537cccb":"markdown","48a34eb3":"markdown","da9559d5":"markdown","af83141f":"markdown","5023ce03":"markdown","54dac9c5":"markdown","f4e701ec":"markdown","60073aa0":"markdown"},"source":{"50a065b4":"import pandas as pd\nimport numpy as np\nfrom torch.utils.data import DataLoader,Dataset\nfrom torchvision import transforms\nfrom torch import nn\nimport cv2\nimport pytorch_lightning as pl\nimport torch\nfrom sklearn.model_selection import train_test_split\nimport torchvision\nfrom pytorch_lightning.callbacks import ModelCheckpoint\nfrom pytorch_lightning import Trainer","c3cd0b7f":"input_df = \"..\/input\/images-of-randomly-generated-quadratic-equations\/Quadratic Equation Full Details.csv\"\ndf = pd.read_csv(input_df)\ndf","4b7ceee3":"class Quadratic_Dataset(Dataset):\n    def __init__(self,path,targets = None):\n        self.path =  path\n        self.targets = targets\n        self.dir_path = \"..\/input\/images-of-randomly-generated-quadratic-equations\/Images of Equations\/\"\n    \n    def __len__(self):\n        return len(self.path)\n    \n    def __getitem__(self, index):\n        image_path = self.dir_path + self.path[index] + \".png\"\n        image = cv2.imread(image_path)\n        image = cv2.resize(image,(100,100))\n        if self.targets is None:\n            return 1.0 - torch.tensor(image).float().reshape(3,100,100)\/256\n        else:\n            return 1.0 - torch.tensor(image).float().reshape(3,100,100)\/256 , torch.tensor(self.targets[index]).float().reshape(3)\n","1051b687":"dataset = Quadratic_Dataset(path = df[\"id\"].values , targets = df[[\"a\",\"b\",\"c\"]].values)\nnext(iter(DataLoader(dataset , batch_size = 1 , shuffle = True)))","bad73a41":"def normalize(df_values,min_,max_):\n    df_list = df_values\n    return [(x-min_)\/(max_ - min_) for x in df_values]","3d96b8ec":"def denormalize(df_values,min_,max_):\n    df_list = df_values\n    return [(x*(max_ - min_) + min_) for x in df_values]","fffdc737":"df['a_'] = normalize(df[\"a\"].values , 1 , 20)\ndf['b_'] = normalize(df[\"b\"].values,-48,96)\ndf['c_'] = normalize(df[\"c\"].values,-792,600)","a7114526":"train_df , test_df = train_test_split(df,test_size = 0.2 , random_state= 42)\ntrain_df , val_df = train_test_split(test_df,test_size = 0.33 , random_state= 42)","c835bc59":"class Quadratic_Module(pl.LightningDataModule):\n    def __init__(self):\n        super().__init__()\n        self.train_dataset = Quadratic_Dataset(path = train_df[\"id\"].values , targets = train_df[[\"a_\",\"b_\", \"c_\"]].values)\n        self.test_dataset = Quadratic_Dataset(path = test_df[\"id\"].values , targets = test_df[[\"a_\",\"b_\" , \"c_\"]].values)\n        self.val_dataset = Quadratic_Dataset(path = val_df[\"id\"].values , targets = val_df[[\"a_\",\"b_\" , \"c_\"]].values)\n        self.predictions = Quadratic_Dataset(path = test_df[\"id\"].values , targets = None)\n\n    def prepare_data(self) :\n        pass\n    \n    def train_dataloader(self):\n        return DataLoader(self.train_dataset , batch_size = 32  , shuffle = True)\n\n    def test_dataloader(self):\n        return DataLoader(self.test_dataset , batch_size = 32  , shuffle = False)\n\n    def val_dataloader(self):\n        return DataLoader(self.val_dataset , batch_size = 32  , shuffle = False)\n    \n    def predict_dataloader(self):\n        return DataLoader(self.predictions , batch_size = 1 , shuffle  = False)","1c951f74":"neural_network = torchvision.models.resnet50(pretrained = True)\nneural_network.fc = nn.Sequential(\n    nn.Linear(2048,1024),\n    nn.LeakyReLU(0.2),\n    nn.Linear(1024,512),\n    nn.LeakyReLU(0.2),\n    nn.Linear(512,256),\n    nn.LeakyReLU(0.2),\n    nn.Linear(256,100),\n    nn.LeakyReLU(0.2),\n    nn.Linear(100,10),\n    nn.Linear(10,3),\n    \n)","0877c57a":"x = torch.ones(1,3,100,100)\r\nneural_network(x)","b0c6798f":"class Quadratic_Model(pl.LightningModule):\n    def __init__(self):\n        super().__init__()\n        self.loss_func = nn.MSELoss()\n        self.net = neural_network\n        \n        \n    def forward(self,x):\n        out = self.net(x)\n        return out\n    \n    def configure_optimizers(self):\n        optimizer = torch.optim.Adam(self.parameters(), lr = 1e-3)\n        sch = torch.optim.lr_scheduler.StepLR(\n        optimizer, step_size  = 10 , gamma = 0.5) #learning raet scheduler\n        return {\n            \"optimizer\":optimizer,\n            \"lr_scheduler\" : {\n                \"scheduler\" : sch,\n                \"monitor\" : \"train_loss\",\n                \n            }\n        }\n\n    def training_step(self,batch,batch_idx):\n        x , y_true = batch\n        y_pred = self(x)\n        loss = self.loss_func(y_true, y_pred)\n        self.log(\"train_loss\" , loss)\n        return loss\n    \n    def test_step(self,batch,batch_idx):\n        x , y_true = batch\n        y_pred = self(x)\n        loss = self.loss_func(y_true, y_pred)\n        self.log(\"test_loss\" , loss)\n        return loss\n    \n    def validation_step(self,batch,batch_idx):\n        x , y_true = batch\n        y_pred = self(x)\n        loss = self.loss_func(y_true, y_pred)\n        self.log(\"val_loss\" , loss)\n        return loss\n\n","6c37ced2":"checkpoint = ModelCheckpoint(monitor= \"val_loss\" ,mode = \"min\") #Trainer returns the model with the lowest \"val_loss\"","492e0399":"model = Quadratic_Model()\nmodule = Quadratic_Module()\ntrainer = Trainer(max_epochs = 100,callbacks=[checkpoint] , gpus= 1)","9349a356":"trainer.fit(model,module)","feaa7f85":"trainer.test()\r\n","640df90a":"predictions = trainer.predict() # Makes predictions from the test set\nactual_values_a = test_df[\"a\"].values\nactual_values_b = test_df[\"b\"].values\nactual_values_c = test_df[\"c\"].values","d2471511":"prediction_a = []\nprediction_b = []\nprediction_c = []\ni = 0\nfor preds in predictions:  \n    preds = [float(x) for x in preds.reshape(3)]\n    prediction_a.append(float(preds[0]))\n    prediction_b.append(float(preds[1]))\n    prediction_c.append(float(preds[2]))\n    \nprediction_df = pd.DataFrame({\n    \"predictions_a\" : prediction_a,\n    \"predictions_b\" : prediction_b,\n    \"predictions_c\" : prediction_c,\n    \"actual_values_a\" : actual_values_a,\n    \"actual_values_b\" : actual_values_b,\n    \"actual_values_c\" : actual_values_c\n})","66834215":"prediction_df['predictions_a'] = denormalize(prediction_df[\"predictions_a\"].values , 1 , 20)\nprediction_df['predictions_b'] = denormalize(prediction_df[\"predictions_b\"].values ,-48,96)\nprediction_df['predictions_c'] = denormalize(prediction_df[\"predictions_c\"].values , -792,600)","38dac58a":"prediction_df.head(100)","28ad1ed4":"torch.save(model.state_dict(),\".\/save.pth\")","7cc7087f":"model_test = Quadratic_Model()\nmodel_test.load_state_dict(torch.load(\".\/save.pth\"))","d97e69a9":"model_test.eval()\nrandom_tensor = torch.ones(1,3,256,256)\nmodel_test(random_tensor)","8f71da30":"# Training the model","d1b03253":"# Lightning Datamodule","fe521b5f":"### Sanity Check ","c537cccb":"# Making Predictions","48a34eb3":"# Saving the model","da9559d5":"# Preprocessing the Data","af83141f":"# Dependencies","5023ce03":"###  Sanity Check to Make Sure of what you are sending to the model ###","54dac9c5":"# Testing the model","f4e701ec":"Medium Link :- https:\/\/keeganfdes03.medium.com\/29f040158ef3?source=friends_link&sk=c0367f499bcb04f71db88de26983462b","60073aa0":"# Standard Pytorch Dataset"}}