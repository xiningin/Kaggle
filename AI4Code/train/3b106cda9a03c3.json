{"cell_type":{"9274462d":"code","ddbf44b8":"code","74d0d0d4":"code","2614c5bc":"code","e8435264":"code","b7d7b286":"code","21d6b88b":"code","ffa58205":"code","f28a6f3d":"code","4f4090e2":"code","5272afba":"code","a1caaa0e":"markdown","4d4626fc":"markdown","c58f490e":"markdown","e20ed7c2":"markdown","a6772eec":"markdown","af790a2c":"markdown","d0850f3c":"markdown"},"source":{"9274462d":"# modules we'll use\nimport pandas as pd\nimport numpy as np\n\n# for Box-Cox Transformation\nfrom scipy import stats\n\n# for min_max scaling\nfrom mlxtend.preprocessing import minmax_scaling\n\n# plotting modules\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# set seed for reproducibility\nnp.random.seed(0)","ddbf44b8":"# generate 1000 data points randomly drawn from an exponential distribution\noriginal_data = np.random.exponential(size = 1000)\n\n# mix-max scale the data between 0 and 1\nscaled_data = minmax_scaling(original_data, columns = [0])\n\n# plot both together to compare\nfig, ax=plt.subplots(1,2)\nsns.distplot(original_data, ax=ax[0])\nax[0].set_title(\"Original Data\")\nsns.distplot(scaled_data, ax=ax[1])\nax[1].set_title(\"Scaled data\")","74d0d0d4":"# normalize the exponential data with boxcox\nnormalized_data = stats.boxcox(original_data)\n\n# plot both together to compare\nfig, ax=plt.subplots(1,2)\nsns.distplot(original_data, ax=ax[0])\nax[0].set_title(\"Original Data\")\nsns.distplot(normalized_data[0], ax=ax[1])\nax[1].set_title(\"Normalized data\")","2614c5bc":"# modules we'll use\nimport pandas as pd\nimport numpy as np\n\n# for Box-Cox Transformation\nfrom scipy import stats\n\n# for min_max scaling\nfrom mlxtend.preprocessing import minmax_scaling\n\n# plotting modules\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# read in all our data\nkickstarters_2016 = pd.read_csv(\"..\/input\/kickstarter-projects\/ks-projects-201612.csv\")\nkickstarters_2018 = pd.read_csv(\"..\/input\/kickstarter-projects\/ks-projects-201801.csv\")\n\n# set seed for reproducibility\nnp.random.seed(0)","e8435264":"kickstarters_2016.head()","b7d7b286":"kickstarters_2018.head()","21d6b88b":"# select the usd_goal_real column\nusd_goal = kickstarters_2018.usd_goal_real\n\n# scale the goals from 0 to 1\nscaled_data = minmax_scaling(usd_goal, columns = [0])\n\n# plot the original & scaled data together to compare\nfig, ax=plt.subplots(1,2)\nsns.distplot(kickstarters_2018.usd_goal_real, ax=ax[0])\nax[0].set_title(\"Original Data\")\nsns.distplot(scaled_data, ax=ax[1])\nax[1].set_title(\"Scaled data\")","ffa58205":"#Let's start by scaling the goals of each campaign, which is how much money they were asking for.\n# select the usd_goal_real column\noriginal_data = pd.DataFrame(kickstarters_2018.usd_goal_real)\n\n# scale the goals from 0 to 1\nscaled_data = minmax_scaling(original_data, columns=['usd_goal_real'])\n\n# plot the original & scaled data together to compare\nfig, ax=plt.subplots(1,2,figsize=(15,3))\nsns.distplot(kickstarters_2018.usd_goal_real, ax=ax[0])\nax[0].set_title(\"Original Data\")\nsns.distplot(scaled_data, ax=ax[1])\nax[1].set_title(\"Scaled data\")","f28a6f3d":"# We just scaled the \"usd_goal_real\" column. What about the \"goal\" column?\ngoal = kickstarters_2018.goal\n\n# scale the goals from 0 to 1\nscaled_goal_data = minmax_scaling(goal, columns = [0])\n\n# plot the original & scaled data together to compare\nfig, ax=plt.subplots(1,2)\nsns.distplot(kickstarters_2018.goal, ax=ax[0])\nax[0].set_title(\"Original Data\")\nsns.distplot(scaled_goal_data, ax=ax[1])\nax[1].set_title(\"Scaled data\")","4f4090e2":"#Ok, now let's try practicing normalization. We're going to normalize the amount of money pledged to each campaign.\n# get the index of all positive pledges (Box-Cox only takes postive values)\nindex_of_positive_pledges = kickstarters_2018.pledged > 0\n\n# get only positive pledges (using their indexes)\npositive_pledges = kickstarters_2018.pledged.loc[index_of_positive_pledges]\n\n# normalize the pledges (w\/ Box-Cox)\nnormalized_pledges = stats.boxcox(positive_pledges)[0]\n\n# plot both together to compare\nfig, ax=plt.subplots(1,2)\nsns.distplot(positive_pledges, ax=ax[0])\nax[0].set_title(\"Original Data\")\nsns.distplot(normalized_pledges, ax=ax[1])\nax[1].set_title(\"Normalized data\")","5272afba":"# We looked as the pledged column. What about the \"usd_pledged_real\" column? Does it have the same info?\n# get the index of all positive pledges (Box-Cox only takes postive values)\nindex_of_positive_pledges = kickstarters_2018.usd_pledged_real > 0\n\n# get only positive pledges (using their indexes)\npositive_pledges = kickstarters_2018.usd_pledged_real.loc[index_of_positive_pledges]\n\n# normalize the pledges (w\/ Box-Cox)\nnormalized_pledges = stats.boxcox(positive_pledges)[0]\n\n# plot both together to compare\nfig, ax=plt.subplots(1,2)\nsns.distplot(positive_pledges, ax=ax[0])\nax[0].set_title(\"Original Data\")\nsns.distplot(normalized_pledges, ax=ax[1])\nax[1].set_title(\"Normalized data\")","a1caaa0e":"# Scaling vs. Normalization: What's the difference?\n\nOne of the reasons that it's easy to get confused between scaling and normalization is because the terms are sometimes used interchangeably and, to make it even more confusing, they are very similar! In both cases, you're transforming the values of numeric variables so that the transformed data points have specific helpful properties. The difference is that:\n- in **scaling**, you're changing the *range* of your data, while \n- in **normalization**, you're changing the *shape of the distribution* of your data. \n\nLet's talk a little more in-depth about each of these options. \n\n# Scaling\n\nThis means that you're transforming your data so that it fits within a specific scale, like 0-100 or 0-1.  You want to scale data when you're using methods based on measures of how far apart data points are, like [support vector machines (SVM)](https:\/\/en.wikipedia.org\/wiki\/Support_vector_machine) or [k-nearest neighbors (KNN)](https:\/\/en.wikipedia.org\/wiki\/K-nearest_neighbors_algorithm). With these algorithms, a change of \"1\" in any numeric feature is given the same importance. \n\nFor example, you might be looking at the prices of some products in both Yen and US Dollars. One US Dollar is worth about 100 Yen, but if you don't scale your prices, methods like SVM or KNN will consider a difference in price of 1 Yen as important as a difference of 1 US Dollar! This clearly doesn't fit with our intuitions of the world. With currency, you can convert between currencies. But what about if you're looking at something like height and weight? It's not entirely clear how many pounds should equal one inch (or how many kilograms should equal one meter).\n\nBy scaling your variables, you can help compare different variables on equal footing. To help solidify what scaling looks like, let's look at a made-up example. (Don't worry, we'll work with real data in [**the following exercise**](https:\/\/www.kaggle.com\/kernels\/fork\/10824404)!)","4d4626fc":"# Get our environment set up\n\nThe first thing we'll need to do is load in the libraries we'll be using. ","c58f490e":"In this notebook, we're going to be looking at how to scale and normalize data (and what the difference is between the two!). \n\nLet's get started!","e20ed7c2":"Notice that the *shape* of our data has changed. Before normalizing it was almost L-shaped. But after normalizing it looks more like the outline of a bell (hence \"bell curve\"). \n\n# Your turn\n\nIt's time to [**apply what you just learned**](https:\/\/www.kaggle.com\/kernels\/fork\/10824404) a dataset of Kickstarter projects.","a6772eec":"Notice that the *shape* of the data doesn't change, but that instead of ranging from 0 to 8ish, it now ranges from 0 to 1.\n\n# Normalization\n\nScaling just changes the range of your data. Normalization is a more radical transformation. The point of normalization is to change your observations so that they can be described as a normal distribution.\n\n> **[Normal distribution:](https:\/\/en.wikipedia.org\/wiki\/Normal_distribution)** Also known as the \"bell curve\", this is a specific statistical distribution where a roughly equal observations fall above and below the mean, the mean and the median are the same, and there are more observations closer to the mean. The normal distribution is also known as the Gaussian distribution.\n\nIn general, you'll normalize your data if you're going to be using a machine learning or statistics technique that assumes your data is normally distributed. Some examples of these include linear discriminant analysis (LDA) and Gaussian naive Bayes. (Pro tip: any method with \"Gaussian\" in the name probably assumes normality.)\n\nThe method we're using to normalize here is called the [Box-Cox Transformation](https:\/\/en.wikipedia.org\/wiki\/Power_transform#Box%E2%80%93Cox_transformation). Let's take a quick peek at what normalizing some data looks like:","af790a2c":"1) Practice scaling\nWe just scaled the \"usd_goal_real\" column. What about the \"goal\" column?\n\nBegin by running the code cell below to create a DataFrame original_goal_data containing the \"goal\" column.","d0850f3c":"---\n\n\n\n\n*Have questions or comments? Visit the [Learn Discussion forum](https:\/\/www.kaggle.com\/learn-forum\/172650) to chat with other Learners.*"}}