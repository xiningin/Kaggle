{"cell_type":{"07b651f7":"code","9922c56f":"code","31938378":"code","b9278a16":"code","54e3f8ab":"code","82829a0b":"code","3e1810b8":"code","7514c297":"code","b96bef9f":"code","f251b087":"code","bb4a3c6e":"code","7a638c23":"code","a7f80978":"code","b00ca45e":"code","8829960a":"code","5be816ef":"code","0f99e443":"code","cbcf2239":"code","c1adfa48":"code","4e2bc2d1":"code","11cd0287":"code","49d145f2":"code","745418cb":"code","904b8234":"code","eee51a93":"code","25b6fa8b":"code","ae30e612":"code","644c0ac0":"code","dc2eea7b":"markdown","70807452":"markdown","2ddb614d":"markdown","06154a96":"markdown","4a543565":"markdown","8c888da4":"markdown","7989c6eb":"markdown","e1208e20":"markdown","4cf05feb":"markdown","ff6a4b36":"markdown","b7925638":"markdown","5a79fb81":"markdown","8d4ceea3":"markdown"},"source":{"07b651f7":"import torch\nimport numpy as np\n\n# check if CUDA is available\ntrain_on_gpu = torch.cuda.is_available()\n\nif not train_on_gpu:\n    print('CUDA is not available.  Training on CPU ...')\nelse:\n    print('CUDA is available!  Training on GPU ...')\n    \nprint(train_on_gpu)","9922c56f":"from torchvision import datasets\nimport torchvision.transforms as transforms\nfrom torch.utils.data.sampler import SubsetRandomSampler\n\n# number of subprocesses to use for data loading\nnum_workers = 0\n# how many samples per batch to load\nbatch_size = 20\n# percentage of training set to use as validation\nvalid_size = 0.2\n\n# convert data to a normalized torch.FloatTensor\ntransform = transforms.Compose([\n    transforms.ToTensor(),\n    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))\n    ])\n\n\n\n# choose the training and test datasets\ntrain_data = datasets.CIFAR10('data', train=True,\n                              download=True, transform=transform)\ntest_data = datasets.CIFAR10('data', train=False,\n                             download=True, transform=transform)\n\n# obtain training indices that will be used for validation\nnum_train = len(train_data)\nindices = list(range(num_train))\nnp.random.shuffle(indices)\nsplit = int(np.floor(valid_size * num_train))\ntrain_idx, valid_idx = indices[split:], indices[:split]\n\n# define samplers for obtaining training and validation batches\ntrain_sampler = SubsetRandomSampler(train_idx)\nvalid_sampler = SubsetRandomSampler(valid_idx)\n\n# prepare data loaders (combine dataset and sampler)\ntrain_loader = torch.utils.data.DataLoader(train_data, batch_size=batch_size,\n    sampler=train_sampler, num_workers=num_workers)\nvalid_loader = torch.utils.data.DataLoader(train_data, batch_size=batch_size, \n    sampler=valid_sampler, num_workers=num_workers)\ntest_loader = torch.utils.data.DataLoader(test_data, batch_size=batch_size, \n    num_workers=num_workers)\n\n# specify the image classes\nclasses = ['airplane', 'automobile', 'bird', 'cat', 'deer',\n           'dog', 'frog', 'horse', 'ship', 'truck']","31938378":"len(train_idx), len(valid_idx)","b9278a16":"valid_loader.dataset","54e3f8ab":"train_sampler.indices[10:13]\n","82829a0b":"train_loader.dataset.train_labels[0:22]","3e1810b8":"len(classes)","7514c297":"import matplotlib.pyplot as plt\n%matplotlib inline\n\n# helper function to un-normalize and display an image\ndef imshow(img):\n    img = img \/ 2 + 0.5  # unnormalize\n    plt.imshow(np.transpose(img, (1, 2, 0)))  # convert from Tensor image","b96bef9f":"# obtain one batch of training images\ndataiter = iter(train_loader)\nimages, labels = dataiter.next()\nimages = images.numpy() # convert images to numpy for display\n\n# plot the images in the batch, along with the corresponding labels\nfig = plt.figure(figsize=(25, 4))\n# display 20 images\nfor idx in np.arange(20):\n    ax = fig.add_subplot(2, 20\/2, idx+1, xticks=[], yticks=[])\n    imshow(images[idx])\n    ax.set_title(classes[labels[idx]])","f251b087":"rgb_img = np.squeeze(images[3])\nchannels = ['red channel', 'green channel', 'blue channel']\n\nfig = plt.figure(figsize = (36, 36)) \nfor idx in np.arange(rgb_img.shape[0]):\n    ax = fig.add_subplot(1, 3, idx + 1)\n    img = rgb_img[idx]\n    ax.imshow(img, cmap='gray')\n    ax.set_title(channels[idx])\n    width, height = img.shape\n    thresh = img.max()\/2.5\n    for x in range(width):\n        for y in range(height):\n            val = round(img[x][y],2) if img[x][y] !=0 else 0\n            ax.annotate(str(val), xy=(y,x),\n                    horizontalalignment='center',\n                    verticalalignment='center', size=8,\n                    color='white' if img[x][y]<thresh else 'black')","bb4a3c6e":"np.squeeze?","7a638c23":"import torch.nn as nn\nimport torch.nn.functional as F\n\n# define the CNN architecture\nclass Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        # convolutional layer\n        self.conv1 = nn.Conv2d(3, 16, 3, padding=1)\n        # max pooling layer\n        self.pool = nn.MaxPool2d(2, 2)\n        # convolutional layer\n        self.conv2 = nn.Conv2d(16, 32, 3, padding=1)\n        # convolutional layer\n        self.conv3 = nn.Conv2d(32, 64, 3, padding=1)\n        # fully connected layer\n        self.fc1 = nn.Linear(4*4*64,512)\n        self.fc2 = nn.Linear(512,120)\n        self.fc3 = nn.Linear(120,len(classes))\n        \n        #Dropout module\n        self.dropout = nn.Dropout(p=0.2)\n\n    def forward(self, x):\n        # add sequence of convolutional and max pooling layers\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = self.pool(F.relu(self.conv3(x)))\n        \n        #flatten image before going to fully connected layer\n        x = x.view(-1,4*4*64)\n        x = F.relu(self.fc1(x))\n        x = self.dropout(x)\n        x = F.relu(self.fc2(x))\n        x = self.dropout(x)\n        x = self.fc3(x)\n        \n        \n        return x\n\n# create a complete CNN\nmodel = Net()\nprint(model)\n\n# move tensors to GPU if CUDA is available\nif train_on_gpu:\n    model.cuda()","a7f80978":"import torch.optim as optim\n\n# specify loss function\ncriterion = nn.CrossEntropyLoss()\n\n# specify optimizer\noptimizer = optim.Adagrad(model.parameters(), lr=0.01)","b00ca45e":"loss.item()\/20","8829960a":"len(train_loader)","5be816ef":"valid_loader.batch_size","0f99e443":"len(valid_loader)","cbcf2239":"data.shape","c1adfa48":"target[0:22]","4e2bc2d1":"len(valid_loader.sampler)","11cd0287":"len(train_loader.sampler)","49d145f2":"len(train_loader.dataset)","745418cb":"len(valid_loader.dataset)","904b8234":"# number of epochs to train the model\nn_epochs = 70 # you may increase this number to train a final model\n\nvalid_loss_min = np.Inf # track change in validation loss\n\nfor epoch in range(1, n_epochs+1):\n\n    # keep track of training and validation loss\n    train_loss = 0.0\n    valid_loss = 0.0\n    tracktrainnum = 0\n    trackvalidnum = 0\n    \n    ###################\n    # train the model #\n    ###################\n    model.train()\n    for data, target in train_loader:\n        # move tensors to GPU if CUDA is available\n        if train_on_gpu:\n            data, target = data.cuda(), target.cuda()\n        # clear the gradients of all optimized variables\n        optimizer.zero_grad()\n        # forward pass: compute predicted outputs by passing inputs to the model\n        output = model(data)\n        # calculate the batch loss\n        loss = criterion(output, target)\n        #tracktrainnum += 1\n        #print(loss.item(),'tracktrainnum:',tracktrainnum)\n        # backward pass: compute gradient of the loss with respect to model parameters\n        loss.backward()\n        # perform a single optimization step (parameter update)\n        optimizer.step()\n        # update training loss\n        train_loss += loss.item()\n        #print('train_loss_acc:',train_loss,tracktrainnum)\n        \n    ######################    \n    # validate the model #\n    ######################\n    model.eval()\n    for data, target in valid_loader:\n        # move tensors to GPU if CUDA is available\n        if train_on_gpu:\n            data, target = data.cuda(), target.cuda()\n        # forward pass: compute predicted outputs by passing inputs to the model\n        output = model(data)\n        # calculate the batch loss\n        loss = criterion(output, target)\n        #trackvalidnum += 1\n        #print(loss.item(),'trackvalidnum:',trackvalidnum)\n        # update average validation loss \n        valid_loss += loss.item()\n        #print('validationloss_acc',valid_loss,trackvalidnum)\n    \n    # calculate average losses\n    train_loss = train_loss\/len(train_loader.sampler)\n    valid_loss = valid_loss\/len(valid_loader.sampler)\n        \n    # print training\/validation statistics \n    print('Epoch: {} \\tTraining Loss: {:.6f} \\tValidation Loss: {:.6f}'.format(\n        epoch, train_loss, valid_loss))\n    \n    # save model if validation loss has decreased\n    if valid_loss <= valid_loss_min:\n        print('Validation loss decreased ({:.6f} --> {:.6f}).  Saving model ...'.format(\n        valid_loss_min,\n        valid_loss))\n        torch.save(model.state_dict(), 'model_cifar.pt')\n        valid_loss_min = valid_loss","eee51a93":"len(valid_loader.sampler)","25b6fa8b":"model.load_state_dict(torch.load('model_cifar.pt'))","ae30e612":"# track test loss\ntest_loss = 0.0\nclass_correct = list(0. for i in range(10))\nclass_total = list(0. for i in range(10))\n\nmodel.eval()\n# iterate over test data\nfor data, target in test_loader:\n    # move tensors to GPU if CUDA is available\n    if train_on_gpu:\n        data, target = data.cuda(), target.cuda()\n    # forward pass: compute predicted outputs by passing inputs to the model\n    output = model(data)\n    # calculate the batch loss\n    loss = criterion(output, target)\n    # update test loss \n    test_loss += loss.item()*data.size(0)\n    # convert output probabilities to predicted class\n    _, pred = torch.max(output, 1)    \n    # compare predictions to true label\n    correct_tensor = pred.eq(target.data.view_as(pred))\n    correct = np.squeeze(correct_tensor.numpy()) if not train_on_gpu else np.squeeze(correct_tensor.cpu().numpy())\n    # calculate test accuracy for each object class\n    for i in range(batch_size):\n        label = target.data[i]\n        class_correct[label] += correct[i].item()\n        class_total[label] += 1\n\n# average test loss\ntest_loss = test_loss\/len(test_loader.dataset)\nprint('Test Loss: {:.6f}\\n'.format(test_loss))\n\nfor i in range(10):\n    if class_total[i] > 0:\n        print('Test Accuracy of %5s: %2d%% (%2d\/%2d)' % (\n            classes[i], 100 * class_correct[i] \/ class_total[i],\n            np.sum(class_correct[i]), np.sum(class_total[i])))\n    else:\n        print('Test Accuracy of %5s: N\/A (no training examples)' % (classes[i]))\n\nprint('\\nTest Accuracy (Overall): %2d%% (%2d\/%2d)' % (\n    100. * np.sum(class_correct) \/ np.sum(class_total),\n    np.sum(class_correct), np.sum(class_total)))","644c0ac0":"# obtain one batch of test images\ndataiter = iter(test_loader)\nimages, labels = dataiter.next()\nimages.numpy()\n\n# move model inputs to cuda, if GPU available\nif train_on_gpu:\n    images = images.cuda()\n\n# get sample outputs\noutput = model(images)\n# convert output probabilities to predicted class\n_, preds_tensor = torch.max(output, 1)\npreds = np.squeeze(preds_tensor.numpy()) if not train_on_gpu else np.squeeze(preds_tensor.cpu().numpy())\n\n# plot the images in the batch, along with predicted and true labels\nfig = plt.figure(figsize=(25, 4))\nfor idx in np.arange(20):\n    ax = fig.add_subplot(2, 20\/2, idx+1, xticks=[], yticks=[])\n    imshow(images[idx])\n    ax.set_title(\"{} ({})\".format(classes[preds[idx]], classes[labels[idx]]),\n                 color=(\"green\" if preds[idx]==labels[idx].item() else \"red\"))","dc2eea7b":"### Visualize a Batch of Training Data","70807452":"---\n## Define the Network [Architecture](http:\/\/pytorch.org\/docs\/stable\/nn.html)\n\nThis time, you'll define a CNN architecture. Instead of an MLP, which used linear, fully-connected layers, you'll use the following:\n* [Convolutional layers](https:\/\/pytorch.org\/docs\/stable\/nn.html#conv2d), which can be thought of as stack of filtered images.\n* [Maxpooling layers](https:\/\/pytorch.org\/docs\/stable\/nn.html#maxpool2d), which reduce the x-y size of an input, keeping only the most _active_ pixels from the previous layer.\n* The usual Linear + Dropout layers to avoid overfitting and produce a 10-dim output.\n\nA network with 2 convolutional layers is shown in the image below and in the code, and you've been given starter code with one convolutional and one maxpooling layer.\n\n<img src='https:\/\/github.com\/diskandarnerd\/deep-learning-v2-pytorch\/blob\/master\/convolutional-neural-networks\/cifar-cnn\/notebook_ims\/2_layer_conv.png?raw=1' height=50% width=50% \/>\n\n#### TODO: Define a model with multiple convolutional layers, and define the feedforward metwork behavior.\n\nThe more convolutional layers you include, the more complex patterns in color and shape a model can detect. It's suggested that your final model include 2 or 3 convolutional layers as well as linear layers + dropout in between to avoid overfitting. \n\nIt's good practice to look at existing research and implementations of related models as a starting point for defining your own models. You may find it useful to look at [this PyTorch classification example](https:\/\/github.com\/pytorch\/tutorials\/blob\/master\/beginner_source\/blitz\/cifar10_tutorial.py) or [this, more complex Keras example](https:\/\/github.com\/keras-team\/keras\/blob\/master\/examples\/cifar10_cnn.py) to help decide on a final structure.\n\n#### Output volume for a convolutional layer\n\nTo compute the output size of a given convolutional layer we can perform the following calculation (taken from [Stanford's cs231n course](http:\/\/cs231n.github.io\/convolutional-networks\/#layers)):\n> We can compute the spatial size of the output volume as a function of the input volume size (W), the kernel\/filter size (F), the stride with which they are applied (S), and the amount of zero padding used (P) on the border. The correct formula for calculating how many neurons define the output_W is given by `(W\u2212F+2P)\/S+1`. \n\nFor example for a 7x7 input and a 3x3 filter with stride 1 and pad 0 we would get a 5x5 output. With stride 2 we would get a 3x3 output.","2ddb614d":"### Question: What are your model's weaknesses and how might they be improved?\nprobably some more cat data? since it is the lowest. Apply adaptive learing rate.","06154a96":"---\n## Load the [Data](http:\/\/pytorch.org\/docs\/stable\/torchvision\/datasets.html)\n\nDownloading may take a minute. We load in the training and test data, split the training data into a training and validation set, then create DataLoaders for each of these sets of data.","4a543565":"### View an Image in More Detail\n\nHere, we look at the normalized red, green, and blue (RGB) color channels as three separate, grayscale intensity images.","8c888da4":"# Convolutional Neural Networks\n---\nIn this notebook, we train a **CNN** to classify images from the CIFAR-10 database.\n\nThe images in this database are small color images that fall into one of ten classes; some example images are pictured below.\n\n<img src='https:\/\/github.com\/diskandarnerd\/deep-learning-v2-pytorch\/blob\/master\/convolutional-neural-networks\/cifar-cnn\/notebook_ims\/cifar_data.png?raw=1' width=70% height=70% \/>","7989c6eb":"---\n## Train the Network\n\nRemember to look at how the training and validation loss decreases over time; if the validation loss ever increases it indicates possible overfitting.","e1208e20":"---\n## Test the Trained Network\n\nTest your trained model on previously unseen data! A \"good\" result will be a CNN that gets around 70% (or more, try your best!) accuracy on these test images.","4cf05feb":"### Specify [Loss Function](http:\/\/pytorch.org\/docs\/stable\/nn.html#loss-functions) and [Optimizer](http:\/\/pytorch.org\/docs\/stable\/optim.html)\n\nDecide on a loss and optimization function that is best suited for this classification task. The linked code examples from above, may be a good starting point; [this PyTorch classification example](https:\/\/github.com\/pytorch\/tutorials\/blob\/master\/beginner_source\/blitz\/cifar10_tutorial.py) or [this, more complex Keras example](https:\/\/github.com\/keras-team\/keras\/blob\/master\/examples\/cifar10_cnn.py). Pay close attention to the value for **learning rate** as this value determines how your model converges to a small error.\n\n#### TODO: Define the loss and optimizer and see how these choices change the loss over time.","ff6a4b36":"### Visualize Sample Test Results","b7925638":"### Test for [CUDA](http:\/\/pytorch.org\/docs\/stable\/cuda.html)\n\nSince these are larger (32x32x3) images, it may prove useful to speed up your training time by using a GPU. CUDA is a parallel computing platform and CUDA Tensors are the same as typical Tensors, only they utilize GPU's for computation.","5a79fb81":"###  Load the Model with the Lowest Validation Loss","8d4ceea3":"**Answer**: (double-click to edit and add an answer)"}}