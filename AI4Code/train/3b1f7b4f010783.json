{"cell_type":{"80c1e870":"code","87a938aa":"code","d61e6dfd":"markdown"},"source":{"80c1e870":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","87a938aa":"# -*- coding: utf-8 -*-\n# @Author: liuyulin\n# @Date:   2018-08-16 14:51:38\n# @Last Modified by:   liuyulin\n# @Last Modified time: 2018-10-03 15:51:55\n\n# api functions that are mostly called by other paks\n\n# Trajectory dimension reduction algo.\nimport numpy as np\nimport pandas as pd\nfrom pyproj import Geod\nfrom dateutil import parser\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\n\nglobal baseline_time\nbaseline_time = parser.parse('01\/01\/2013 0:0:0')\ng = Geod(ellps='WGS84')\n# reference:\n# http:\/\/hanj.cs.illinois.edu\/pdf\/sigmod07_jglee.pdf\n# Lee, Han and Whang (2007) trajectory clustering a partition-and-group framework\n\n\n### Legacy code\n### legacy code usually has non-pythonic naming convention\n\n# Returns pressure from altitude (ft)\ndef press(alt):\n    z = alt\/3.28084\n    return 1013.25*(1-(0.0065*z)\/288.15)**5.255\n\n# Returns the closest lvl from levels with altitude (atl)\ndef proxilvl(alt , lvls):\n    p = press(alt)\n    levels = np.array(sorted(lvls.keys()))\n    return levels[np.abs(levels - p).argmin()]\n\n\ndef GetAzimuth(flight_track_df, \n               course = True,\n               last_pnt = 1e-6, \n               canonical = False):\n    # return azimuth in degrees\n    # azimuth is from the North: if to the right then positive, if to the left then negative\n    # if want to switch to canonical form (rotation from the x-axis), then return (90 - azimuth)\n    # if want course (azimuth to the next point), then specify course = True;\n    # otherwise this function will return azimuth from last point\n\n    CenterTraj = flight_track_df[['FID', 'Lat', 'Lon']]\n    # CenterTraj.loc[:, 'azimuth'] = last_pnt\n    tmp_df = CenterTraj.shift(-1)\n    azimuth_arr = g.inv(CenterTraj.Lon.values[:-1], \n                        CenterTraj.Lat.values[:-1], \n                        tmp_df.Lon.values[:-1], \n                        tmp_df.Lat.values[:-1])[0]\n    if canonical:\n        # starting from x-axis\n        if course:\n            azimuth_arr = np.append(90 - azimuth_arr, last_pnt)\n        else:\n            azimuth_arr = np.append(last_pnt, 90 - azimuth_arr)\n    else:\n        if course:\n            azimuth_arr = np.append(azimuth_arr, last_pnt)\n        else:\n            azimuth_arr = np.append(last_pnt, azimuth_arr)\n    if course:\n        tmp_tail_idx = CenterTraj.groupby(\"FID\")['Lat'].tail(1).index\n        azimuth_arr[tmp_tail_idx] = last_pnt\n    else:\n        tmp_head_idx = CenterTraj.groupby(\"FID\")['Lat'].head(1).index\n        azimuth_arr[tmp_head_idx] = last_pnt\n    return azimuth_arr\n\n    # if canonical:\n    #     if course:\n    #         CenterTraj.iloc[:-1]['azimuth'] = (90 - azimuth_arr)\n    #     else:\n    #         CenterTraj.iloc[1:]['azimuth'] = (90 - azimuth_arr)\n    # else:\n    #     if course:\n    #         CenterTraj.iloc[:-1]['azimuth'] = azimuth_arr\n    #     else:\n    #         CenterTraj.iloc[1:]['azimuth'] = azimuth_arr\n    \n    # if course:\n    #     CenterTraj.loc[CenterTraj.groupby(\"FID\")['azimuth'].tail(1).index, 'azimuth'] = last_pnt\n    # else:\n    #     CenterTraj.loc[CenterTraj.groupby(\"FID\")['azimuth'].head(1).index, 'azimuth'] = last_pnt\n    \n    # return CenterTraj.azimuth\n\ndef ReshapeTrajLine(Traj):\n    RepeatIndex = np.ones(Traj.shape[0],dtype=int)*2\n    RepeatIndex[0] = 1\n    RepeatIndex[-1] = 1\n    NewTraj = np.repeat(Traj,RepeatIndex,axis = 0)\n    NewTraj = NewTraj.reshape(Traj.shape[0]-1,Traj.shape[1]*2)\n    return NewTraj\n\n#################################################################################\n#################################################################################\n\ndef LineDist(Si,Ei,Sj,Ej,Out = 'All'):\n    \"\"\"\n    Get line segment distance between SjEj and SiEi\n    Input must be numpy array\n    Line segment 1: SiEi\n    Line segment 2: SjEj\n    Project Line SjEj to SiEi\n    \n    test code\n    LineDist(np.array([0,1]),np.array([1,1]),np.array([0,0]),np.array([1,0]))\n    \"\"\"\n    SiEi = Ei - Si\n    SjEj = Ej - Sj\n    \n    SiSj = Sj - Si\n    SiEj = Ej - Si\n    \n    u1 = np.dot(SiSj, SiEi)\/np.dot(SiEi,SiEi)\n    u2 = np.dot(SiEj, SiEi)\/np.dot(SiEi,SiEi)\n    \n    Ps = Si + np.dot(u1,SiEi)\n    Pe = Si + np.dot(u2,SiEi)\n    \n    CosTheta = np.dot(SiEi,SjEj)\/np.sqrt(np.dot(SiEi,SiEi))\/np.sqrt(np.dot(SjEj,SjEj))   \n    \n    L_perp1 = np.sqrt(np.dot(Sj-Ps,Sj-Ps))\n    L_perp2 = np.sqrt(np.dot(Ej-Pe,Ej-Pe))\n    \n    if L_perp1 + L_perp2 == 0:\n        D_perp = 0\n    else:\n        D_perp = (L_perp1**2 + L_perp2**2)\/(L_perp1+L_perp2)\n    \n    L_para1 = min(np.dot(Ps-Si,Ps-Si),np.dot(Ps-Ei,Ps-Ei))\n    L_para2 = min(np.dot(Ei-Pe,Ei-Pe),np.dot(Si-Pe,Si-Pe))\n    D_para = np.sqrt(min(L_para1,L_para2))\n    \n    if CosTheta >= 0 and CosTheta < 1:\n        D_theta = np.sqrt(np.dot(SjEj,SjEj)) * np.sqrt(1-CosTheta**2)\n    elif CosTheta < 0:\n        D_theta = np.sqrt(np.dot(SjEj,SjEj))\n    else:\n        D_theta = 0\n    \n    D_line = D_perp + D_para + D_theta    \n    \n    if Out == 'All':\n        return D_perp, D_para, D_theta, D_line\n    elif Out == 'Total':\n        return D_line\n    elif Out == 'Nopara':\n        return D_perp + D_theta\n    else:\n        raise ValueError('Out can only be All, Total or Nopara')\n\ndef MDL_PAR(Traj, m, n, dist = lambda a, b: np.sqrt(sum((a - b)**2))):\n    LH  = (dist(Traj[m],Traj[n]))\n    LD = 0\n    for i in range(m,n):\n        DD = LineDist(Traj[m],Traj[n],Traj[i],Traj[i+1])\n        LD += np.log2(DD[0] + 1) + np.log2(DD[2] + 1)\n    LL = np.log2(LH + 1) + LD\n    return LL\n\ndef MDL_NOPAR(Traj, m, n, dist = lambda a, b: np.sqrt(sum((a - b)**2))):\n    LD = 0\n    LH = 0\n    for i in range(m,n):\n        LH += (dist(Traj[i],Traj[i+1]))\n\n    LL = np.log2(LH + 1) + np.log2(LD + 1)\n    return LL\n\ndef GetCharaPnt(Traj,alpha, dist = lambda a, b: np.sqrt(sum((a - b)**2))):\n    \"\"\"\n    Get Characteristic points\n    \n    # test code\n    Traj = np.random.random((300,2))\n    aa = time.time()\n    CP = GetCharaPnt(Traj,1.5)\n    print(time.time() - aa)\n    print(len(CP))\n    \"\"\"\n    startIndex = 1\n    Length = 1\n    CP = [Traj[0]]\n    while startIndex + Length < Traj.shape[0]:\n        currIndex = startIndex + Length\n        cost_par = MDL_PAR(Traj, startIndex, currIndex, dist)\n        cost_nopar = MDL_NOPAR(Traj, startIndex, currIndex, dist)\n        # print(currIndex, startIndex, Length, cost_par, cost_nopar)\n        if cost_par > cost_nopar * alpha:\n            startIndex = currIndex - 1\n            Length = 1\n            CP.append(Traj[startIndex])\n        else:\n            Length += 1\n    CP.append(Traj[-1])\n    return np.array(CP)\n\n#################################################################################\n#################################################################################\n\ndef downsample_track_data(path_to_fp,\n                          path_to_fp_util,\n                          path_to_track,\n                          downsamp_rate_ft = 2,\n                          downsamp_rate_fp = 1.05):\n    \"\"\"\n    use case:\n    downsamp_flight_tracks, \\\n        downsamp_flight_plans, \n            flight_plans, \\\n                flight_plans_util, \\\n                    flight_tracks = preprocess_track_data(path_to_fp = '\/media\/storage\/DATA\/DeepTPdata\/cleaned_FP_tracks.CSV',\n                                                                       path_to_fp_util = '\/media\/storage\/DATA\/DeepTPdata\/IAH_BOS_Act_Flt_Trk_20130101_1231.CSV',\n                                                                       path_to_track = '\/media\/storage\/DATA\/DeepTPdata\/New_IAHBOS2013.csv',\n                                                                       downsamp_rate_ft = 2,\n                                                                       downsamp_rate_fp = 1.05)\n    \"\"\"\n    flight_plans = pd.read_csv(path_to_fp)\n    flight_plans_util = pd.read_csv(path_to_fp_util)\n    flight_tracks = pd.read_csv(path_to_track, parse_dates=[6])\n    tmp_ft_head = flight_tracks.groupby('FID').head(1)\n    tmp_ft_tail = flight_tracks.groupby('FID').tail(1)\n    tmp_ft = flight_tracks.loc[flight_tracks.index.difference(tmp_ft_head.index).difference(tmp_ft_tail.index)[::downsamp_rate_ft]]\n    downsamp_flight_tracks = pd.concat([tmp_ft_head, tmp_ft_tail, tmp_ft])\n#     del tmp_ft\n#     del tmp_ft_head\n#     del tmp_ft_tail\n    downsamp_flight_tracks.sort_index(inplace=True)\n    downsamp_flight_tracks = downsamp_flight_tracks.reset_index(drop = True)\n    downsamp_flight_tracks['DT'] = downsamp_flight_tracks.groupby('FID')['Elap_Time'].apply(lambda x: (x - x.shift(1)).dt.seconds)\n    downsamp_flight_tracks['DT'] = downsamp_flight_tracks['DT'].fillna(0)\n    \n    downsamp_flight_plans = []\n    for gpidx, gp in flight_plans.groupby('FLT_PLAN_ID'):\n        tmp_fp_cp = GetCharaPnt(gp[['LONGITUDE', 'LATITUDE']].values, alpha=downsamp_rate_fp,dist = lambda a, b: g.inv(a[0], a[1], b[0], b[1])[2]\/1000)\n        tmp_fp_cp = pd.DataFrame(data = tmp_fp_cp, columns=['LONGITUDE', 'LATITUDE'])\n        tmp_fp_cp['FLT_PLAN_ID'] = gpidx\n        downsamp_flight_plans.append(tmp_fp_cp)\n    downsamp_flight_plans = pd.concat(downsamp_flight_plans).reset_index(drop = True)\n    return downsamp_flight_tracks, downsamp_flight_plans, flight_plans, flight_plans_util, flight_tracks\n\n#################################################################################\n#################################################################################\n\ndef rotate_coord(old_coord, theta):\n    \"\"\"\n    IMPORTANT NOTE:\n    theta could either be a single angle or an array with radian, NOT degree;\n    theta should be angle rotating from x-axis!!!\n    \"\"\"\n    rotation_matrix = np.array([np.cos(theta), -np.sin(theta), np.sin(theta), np.cos(theta)]).T.reshape(-1, 2, 2)\n    new_coord = rotation_matrix.dot(old_coord)\n    return new_coord\n    \ndef create_grid_orient(shift_xleft, shift_xright, shift_yup, shift_ydown, nx, ny, theta):\n    \"\"\"\n    rotate_grid = create_grid(center_x = -95, \n                        center_y = 30, \n                        shift_xleft = 0, \n                        shift_xright = 2, \n                        shift_yup = 1, \n                        shift_ydown = 1, \n                        nx = 10, \n                        ny = 10, \n                        theta = np.pi\/4)\n    \"\"\"\n    # x, y is in the unit of degrees\n    x = np.linspace(0 - shift_xleft, 0 + shift_xright, nx)\n    y = np.linspace(0 - shift_ydown, 0 + shift_yup, ny)\n    xv, yv = np.meshgrid(x, y, sparse = False)\n    grid_2d = np.vstack((xv.flatten(),yv.flatten()))\n    rotate_grid = rotate_coord(grid_2d, theta)\n    # .T + np.array([[center_x, center_y]])\n    # [Lon, Lat]\n    return np.transpose(rotate_grid, [0, 2, 1]) # shape of [M_point (theta.shape[0]), N_grid (i.e., nx * ny), 2]\n\ndef create_basemap(llon = -100, \n                   rlon = -68, \n                   tlat = 46, \n                   blat = 27, \n                   figsize = (8,6)):\n    fig = plt.figure(figsize = figsize)\n    m = Basemap(llcrnrlon = llon,llcrnrlat = blat,urcrnrlon = rlon, urcrnrlat = tlat,projection='merc')\n    m.fillcontinents(color='#c5c5c5', lake_color='#8aeaff')\n    m.drawcoastlines(linewidth=0.5)\n    m.drawcountries(linewidth=0.5)\n    m.drawstates(linewidth=0.5)\n    m.drawparallels(np.arange(10.,35.,5.))\n    m.drawmeridians(np.arange(-120.,-80.,10.))\n    return fig, m\n\ndef plot_fp_act(FP_ID, IAH_BOS_FP_utilize, IAH_BOS_ACT_track, IAH_BOS_FP_track):\n    \"\"\"\n    test code:\n    _, _ = plot_fp_act('FP_00001', flight_plans_util, downsamp_flight_tracks, downsamp_flight_plans)\n    \"\"\"\n    fig, m = create_basemap()\n\n    fid_fp1 = IAH_BOS_FP_utilize.loc[IAH_BOS_FP_utilize.FLT_PLAN_ID == FP_ID, 'FID'].values\n    print('%d flights filed flight plan %s'%(fid_fp1.shape[0], FP_ID))\n    plot_track = IAH_BOS_ACT_track.loc[IAH_BOS_ACT_track.FID.isin(fid_fp1)]\n    plot_fp = IAH_BOS_FP_track.loc[IAH_BOS_FP_track.FLT_PLAN_ID == FP_ID]\n    x_fp, y_fp = m(plot_fp.LONGITUDE.values, plot_fp.LATITUDE.values)\n\n    for gpidx, gp in plot_track.groupby('FID'):\n        x,y = m(gp.Lon.values, gp.Lat.values)\n        actual, = plt.plot(x,y,'-o', linewidth = 0.1, ms = 1, color='b', label = 'Actual Tracks')\n    fp, = plt.plot(x_fp, y_fp, '-o', linewidth = 2, ms = 5, color='r', label = 'Flight Plans', zorder = 999)\n    plt.show()\n    return plot_track, plot_fp\n\ndef plot_feature_grid(feature_grid_arr, flight_tracks_arr = None):\n    # feature_grid_arr should be np array with shape [None, 400, 2]\n    # the first dimension should be lon and second should be lat\n    fig, m = create_basemap()\n    xgrid, ygrid = m(feature_grid_arr[..., 0], feature_grid_arr[..., 1])\n    if flight_tracks_arr is not None:\n        xtrack, y_track = m(flight_tracks_arr[..., 0], flight_tracks_arr[..., 1])\n        _ = plt.plot(xtrack, y_track, 'o-', ms = 5, color = 'b')\n\n    _ = plt.plot(xgrid, ygrid, 'o', ms = 0.1, color = 'r')\n    \n    return\n\nwrite_function_to_file(press, \"utils.py\")\nwrite_function_to_file(proxilvl, \"utils.py\")\nwrite_function_to_file(GetAzimuth, \"utils.py\")\nwrite_function_to_file(ReshapeTrajLine, \"utils.py\")\nwrite_function_to_file(LineDist, \"utils.py\")\nwrite_function_to_file(MDL_PAR, \"utils.py\")\nwrite_function_to_file(MDL_NOPAR, \"utils.py\")\nwrite_function_to_file(GetCharaPnt, \"utils.py\")\nwrite_function_to_file(downsample_track_data, \"utils.py\")\nwrite_function_to_file(rotate_coord, \"utils.py\")\nwrite_function_to_file(create_grid_orient, \"utils.py\")\nwrite_function_to_file(create_basemap, \"utils.py\")\nwrite_function_to_file(plot_fp_act, \"utils.py\")\nwrite_function_to_file(plot_feature_grid, \"utils.py\")","d61e6dfd":"# Utils.py"}}