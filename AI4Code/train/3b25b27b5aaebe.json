{"cell_type":{"9c41acaf":"code","91a85b2b":"code","276a43c6":"code","3e5751f4":"code","dd8771ad":"code","49fbec09":"code","6e18a78f":"code","d2f93579":"code","a93a13c7":"code","fbad15c0":"code","141e730c":"code","d8ceae5c":"code","f8635a7c":"code","689b9b54":"code","2a3d8fa1":"code","1a58bb9f":"code","38224ed9":"code","de76fdaa":"code","e59a8b8d":"code","2bec59e1":"code","86d94394":"code","489a6313":"code","38d0cb73":"code","0ae3246d":"code","347c1db2":"code","33a50765":"code","229b9e0c":"code","e3621731":"code","45ce95ef":"code","83bad1f5":"code","15b6a004":"markdown","06312234":"markdown","dbb1f872":"markdown"},"source":{"9c41acaf":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport gc\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\n# import os\n# for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#     for filename in filenames:\n#         print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","91a85b2b":"from pathlib import Path\nfrom torch.utils.data import Dataset, DataLoader, sampler\nfrom PIL import Image\nimport torch\nimport matplotlib.pyplot as plt\nimport time\n\n\n# !pip install tensorflow==2.0","276a43c6":"# !pip install keras-unet\n# import tensorflow as tf","3e5751f4":"# from keras.layers import Input","dd8771ad":"class CloudDataset(Dataset):\n    def __init__(self, r_dir, g_dir, b_dir, nir_dir, gt_dir, pytorch=True):\n        super().__init__()\n        \n        # Loop through the files in red folder and combine, into a dictionary, the other bands\n        self.files = [self.combine_files(f, g_dir, b_dir, nir_dir, gt_dir) for f in r_dir.iterdir() if not f.is_dir()]\n        self.pytorch = pytorch\n        \n    def combine_files(self, r_file: Path, g_dir, b_dir,nir_dir, gt_dir):\n        \n        files = {'red': r_file, \n                 'green':g_dir\/r_file.name.replace('red', 'green'),\n                 'blue': b_dir\/r_file.name.replace('red', 'blue'), \n                 'nir': nir_dir\/r_file.name.replace('red', 'nir'),\n                 'gt': gt_dir\/r_file.name.replace('red', 'gt')}\n\n        return files\n                                       \n    def __len__(self):\n        \n        return len(self.files)\n     \n    def open_as_array(self, idx, invert=False, include_nir=False):\n\n        raw_rgb = np.stack([np.array(Image.open(self.files[idx]['red'])),\n                            np.array(Image.open(self.files[idx]['green'])),\n                            np.array(Image.open(self.files[idx]['blue'])),\n                           ], axis=2)\n    \n        if include_nir:\n            nir = np.expand_dims(np.array(Image.open(self.files[idx]['nir'])), 2)\n            raw_rgb = np.concatenate([raw_rgb, nir], axis=2)\n    \n        if invert:\n            raw_rgb = raw_rgb.transpose((2,0,1))\n    \n        # normalize\n        return (raw_rgb \/ np.iinfo(raw_rgb.dtype).max)\n    \n\n    def open_mask(self, idx, add_dims=False):\n        \n        raw_mask = np.array(Image.open(self.files[idx]['gt']))\n        raw_mask = np.where(raw_mask==255, 1, 0)\n        \n        return np.expand_dims(raw_mask, 0) if add_dims else raw_mask\n    \n    def __getitem__(self, idx):\n        \n        x = torch.tensor(self.open_as_array(idx, invert=self.pytorch, include_nir=True), dtype=torch.float32)\n        y = torch.tensor(self.open_mask(idx, add_dims=False), dtype=torch.torch.int64)\n        \n        return x, y\n    \n    def open_as_pil(self, idx):\n        \n        arr = 256*self.open_as_array(idx)\n        \n        return Image.fromarray(arr.astype(np.uint8), 'RGB')\n    \n    def __repr__(self):\n        s = 'Dataset class with {} files'.format(self.__len__())\n\n        return s","49fbec09":"base_path = Path('..\/input\/38cloud-cloud-segmentation-in-satellite-images\/38-Cloud_training')\ndata = CloudDataset(base_path\/'train_red', \n                    base_path\/'train_green', \n                    base_path\/'train_blue', \n                    base_path\/'train_nir',\n                    base_path\/'train_gt')\nlen(data)","6e18a78f":"x, y = data[1000]\nx.shape, y.shape","d2f93579":"fig, ax = plt.subplots(1,2, figsize=(10,9))\nax[0].imshow(data.open_as_array(150))\nax[1].imshow(data.open_mask(150))","a93a13c7":"train_ds, valid_ds = torch.utils.data.random_split(data, (6000, 2400))","fbad15c0":"train_ds","141e730c":"train_dl = DataLoader(train_ds, batch_size=12)\nvalid_dl = DataLoader(valid_ds, batch_size=12)","d8ceae5c":"xb, yb = next(iter(train_dl))\nxb.shape, yb.shape","f8635a7c":"from torch import nn\n\ndef doubleConv(in_channels, out_channels):\n    conv = nn.Sequential(\n        nn.Conv2d(in_channels, out_channels, kernel_size = 3, padding = True),\n        nn.ReLU(inplace = True),\n        nn.Conv2d(out_channels, out_channels, kernel_size = 3, padding = True),\n        nn.ReLU(inplace = True)\n        )\n    return conv\n\nclass UNET(nn.Module):\n    def __init__(self):\n        super(UNET, self).__init__()\n\n        self.max_pool= nn.MaxPool2d(kernel_size = 2, stride = 2)\n        self.down_conv1 = doubleConv(4, 64)\n        self.down_conv2 = doubleConv(64, 128)\n        self.down_conv3 = doubleConv(128, 256)\n        self.down_conv4 = doubleConv(256, 512)\n        self.down_conv5 = doubleConv(512, 1024)\n\n        self.up_pool1 = nn.ConvTranspose2d(in_channels = 1024, out_channels = 512, kernel_size = 2, stride = 2)\n        self.up_pool2 = nn.ConvTranspose2d(in_channels = 512, out_channels = 256, kernel_size = 2, stride = 2)\n        self.up_pool3 = nn.ConvTranspose2d(in_channels = 256, out_channels = 128, kernel_size = 2, stride = 2)\n        self.up_pool4 = nn.ConvTranspose2d(in_channels = 128, out_channels = 64, kernel_size = 2, stride = 2)\n        \n        self.upconv1 = doubleConv(1024, 512)\n        self.upconv2 = doubleConv(512, 256)\n        self.upconv3 = doubleConv(256, 128)\n        self.upconv4 = doubleConv(128, 64)\n        self.out = nn.Conv2d(in_channels = 64, out_channels = 2, kernel_size = 3, padding = True)\n        \n    def __call__(self, image):\n        x1 = self.down_conv1(image)\n        x2 = self.max_pool(x1)\n        x3 = self.down_conv2(x2)\n        x4 = self.max_pool(x3)\n        x5 = self.down_conv3(x4)\n        x6 = self.max_pool(x5)\n        x7 = self.down_conv4(x6)\n        x8 = self.max_pool(x7)\n        x9 = self.down_conv5(x8)\n        \n        x10 = self.up_pool1(x9)\n        x11 = self.upconv1(torch.cat([x10, x7], 1))\n        x12 = self.up_pool2(x11)\n        x13 = self.upconv2(torch.cat([x12, x5], 1))\n        x14 = self.up_pool3(x13)\n        x15 = self.upconv3(torch.cat([x14, x3], 1))\n        x16 = self.up_pool4(x15)\n        x17 = self.upconv4(torch.cat([x16, x1], 1))\n        x = self.out(x17)\n        \n#         x_arr = [x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17]\n#         for i in x_arr:\n#             print(i.shape)\n#         print(x.shape)\n\n        return x","689b9b54":"unet = UNET()\n\n# from keras_unet.models import vanilla_unet\n\n# unet = vanilla_unet(input_shape=(384, 384, 4))","2a3d8fa1":"# from tensorflow import keras\n# keras.utils.plot_model(unet, show_shapes=True)","1a58bb9f":"# testing one pass\nxb, yb = next(iter(train_dl))\n\nxb.shape, yb.shape","38224ed9":"# np_tensor = xb.numpy()\n# xb = tf.convert_to_tensor(np_tensor)\n\npred = unet(xb)","de76fdaa":"import time\nfrom IPython.display import clear_output\n\ndef train(model, train_dl, valid_dl, loss_fn, optimizer, acc_fn, epochs=300):\n    start = time.time()\n    model.cuda()\n\n    train_loss, valid_loss = [], []\n\n    best_acc = 0.0\n\n    for epoch in range(epochs):\n        print('Epoch {}\/{}'.format(epoch, epochs - 1))\n        print('-' * 10)\n\n        for phase in ['train', 'valid']:\n            if phase == 'train':\n                model.train(True)  # Set trainind mode = true\n                dataloader = train_dl\n            else:\n                model.train(False)  # Set model to evaluate mode\n                dataloader = valid_dl\n\n            running_loss = 0.0\n            running_acc = 0.0\n\n            step = 0\n\n            # iterate over data\n            for x, y in dataloader:\n                x = x.cuda()\n                y = y.cuda()\n                step += 1\n\n                # forward pass\n                if phase == 'train':\n                    # zero the gradients\n                    optimizer.zero_grad()\n                    outputs = model(x)\n                    loss = loss_fn(outputs, y)\n\n                    # the backward pass frees the graph memory, so there is no \n                    # need for torch.no_grad in this training pass\n                    loss.backward()\n                    optimizer.step()\n                    # scheduler.step()\n\n                else:\n                    with torch.no_grad():\n                        outputs = model(x)\n                        loss = loss_fn(outputs, y.long())\n\n                # stats - whatever is the phase\n                acc = acc_fn(outputs, y)\n\n                running_acc  += acc*dataloader.batch_size\n                running_loss += loss*dataloader.batch_size \n\n                if step % 100 == 0:\n                    # clear_output(wait=True)\n                    print('Current step: {}  Loss: {}  Acc: {}  AllocMem (Mb): {}'.format(step, loss, acc, torch.cuda.memory_allocated()\/1024\/1024))\n                    # print(torch.cuda.memory_summary())\n                \n                \n            epoch_loss = running_loss \/ len(dataloader.dataset)\n            epoch_acc = running_acc \/ len(dataloader.dataset)\n\n            clear_output(wait=True)\n            print('Epoch {}\/{}'.format(epoch, epochs - 1))\n            print('-' * 10)\n            print('{} Loss: {:.4f} Acc: {}'.format(phase, epoch_loss, epoch_acc))\n            print('-' * 10)\n\n            train_loss.append(epoch_loss) if phase=='train' else valid_loss.append(epoch_loss)\n\n    time_elapsed = time.time() - start\n    print('Training complete in {:.0f}m {:.0f}s'.format(time_elapsed \/\/ 60, time_elapsed % 60))    \n    \n    return train_loss, valid_loss    \n\ndef acc_metric(predb, yb):\n    return (predb.argmax(dim=1) == yb.cuda()).float().mean()","e59a8b8d":"loss_fn = nn.CrossEntropyLoss()\n# opt = torch.optim.Adam(unet.parameters(), lr=0.0001)\nopt = torch.optim.SGD(unet.parameters(), lr=0.0001, momentum=0.9)\n\n# Utpo 10^-8\n# unet.compile(optimizer=Adam(), loss=\"binary_crossentropy\", metrics=[\"accuracy\"])\n\ntrain_loss, valid_loss = train(unet, train_dl, valid_dl, loss_fn, opt, acc_metric, epochs=1)","2bec59e1":"# Specify a path to save to\nPATH = \".\/model.pt\"\n# Save\ntorch.save(unet.state_dict(), PATH)","86d94394":"# callbacks = [\n#     EarlyStopping(patience=10, verbose=1),\n#     ReduceLROnPlateau(factor=0.1, patience=5, min_lr=0.00001, verbose=1),\n#     ModelCheckpoint('model-tgs-salt.h5', verbose=1, save_best_only=True, save_weights_only=True)\n# ]\n\n# results = model.fit(X_train, y_train, batch_size=32, epochs=50, callbacks=callbacks,\\\n#                     validation_data=(X_valid, y_valid))","489a6313":"plt.figure(figsize=(10,8))\nplt.plot(train_loss, label='Train loss')\nplt.plot(valid_loss, label='Valid loss')\nplt.legend()","38d0cb73":"def batch_to_img(xb, idx):\n    img = np.array(xb[idx,0:3])\n    return img.transpose((1,2,0))\n\ndef predb_to_mask(predb, idx):\n    p = torch.functional.F.softmax(predb[idx], 0)\n    return p.argmax(0).cpu()","0ae3246d":"xb, yb = next(iter(train_dl))\n\nwith torch.no_grad():\n    predb = unet(xb.cuda())\n    \npredb.shape","347c1db2":"bs = 12\nfig, ax = plt.subplots(bs,3, figsize=(15,bs*5))\nfor i in range(bs):\n    ax[i,0].imshow(batch_to_img(xb,i))\n    ax[i,1].imshow(yb[i])\n    ax[i,2].imshow(predb_to_mask(predb, i))","33a50765":"class CloudTestDataset(Dataset):\n    def __init__(self, r_dir, g_dir, b_dir, nir_dir, pytorch=True):\n        super().__init__()\n        \n        # Loop through the files in red folder and combine, into a dictionary, the other bands\n        self.files = [self.combine_files(f, g_dir, b_dir, nir_dir) for f in r_dir.iterdir() if not f.is_dir()]\n        self.pytorch = pytorch\n        \n    def combine_files(self, r_file: Path, g_dir, b_dir,nir_dir):\n        \n        files = {'red': r_file, \n                 'green':g_dir\/r_file.name.replace('red', 'green'),\n                 'blue': b_dir\/r_file.name.replace('red', 'blue'), \n                 'nir': nir_dir\/r_file.name.replace('red', 'nir'),}\n\n        return files\n                                       \n    def __len__(self):\n        \n        return len(self.files)\n     \n    def open_as_array(self, idx, invert=False, include_nir=False):\n\n        raw_rgb = np.stack([np.array(Image.open(self.files[idx]['red'])),\n                            np.array(Image.open(self.files[idx]['green'])),\n                            np.array(Image.open(self.files[idx]['blue'])),\n                           ], axis=2)\n    \n        if include_nir:\n            nir = np.expand_dims(np.array(Image.open(self.files[idx]['nir'])), 2)\n            raw_rgb = np.concatenate([raw_rgb, nir], axis=2)\n    \n        if invert:\n            raw_rgb = raw_rgb.transpose((2,0,1))\n    \n        # normalize\n        return (raw_rgb \/ np.iinfo(raw_rgb.dtype).max)\n    \n\n    def open_mask(self, idx, add_dims=False):\n        \n        raw_mask = np.array(Image.open(self.files[idx]['gt']))\n        raw_mask = np.where(raw_mask==255, 1, 0)\n        \n        return np.expand_dims(raw_mask, 0) if add_dims else raw_mask\n    \n    def __getitem__(self, idx):\n        \n        x = torch.tensor(self.open_as_array(idx, invert=self.pytorch, include_nir=True), dtype=torch.float32)\n#         y = torch.tensor(self.open_mask(idx, add_dims=False), dtype=torch.torch.int64)\n        \n        return x\n    \n    def open_as_pil(self, idx):\n        \n        arr = 256*self.open_as_array(idx)\n        \n        return Image.fromarray(arr.astype(np.uint8), 'RGB')\n    \n    def __repr__(self):\n        s = 'Dataset class with {} files'.format(self.__len__())\n\n        return s","229b9e0c":"base_path = Path('..\/input\/38cloud-cloud-segmentation-in-satellite-images\/38-Cloud_test')\ndata = CloudTestDataset(base_path\/'test_red', \n                    base_path\/'test_green', \n                    base_path\/'test_blue', \n                    base_path\/'test_nir')","e3621731":"test_ds = data","45ce95ef":"test_dl = DataLoader(test_ds, batch_size=12)","83bad1f5":"# for xb in test_dl:\n#     xb = xb.cuda()\n#     with torch.no_grad():\n#         predb = unet(xb.cuda())\n#     bs = 12\n#     for i in range(bs):\n# #         plt.figure(figsize=(384,384))\n#         ax.imsave(predb_to_mask(predb, \"gt_\"+str(yb)))","15b6a004":"# This notebook creates a very simple U-Net to segment clouds\nImportant remarks:\n- The test-set is not being used\n- The train set will be splitted into train and validation sets.\n- The dataset creation is discussed in: https:\/\/medium.com\/@cordmaur\/how-to-create-a-custom-dataset-loader-in-pytorch-from-scratch-for-multi-band-satellite-images-c5924e908edf\n- More information full explanation can can be found on the medium article: https:\/\/medium.com\/@cordmaur\/creating-a-very-simple-u-net-model-with-pytorch-for-semantic-segmentation-of-satellite-images-223aa216e705\n- The training phase with 50 epochs takes around 3:30hs. ","06312234":"# The model","dbb1f872":"## Creating the dataset"}}