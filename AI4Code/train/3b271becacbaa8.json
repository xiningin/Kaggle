{"cell_type":{"f90274a0":"code","8863e3e1":"code","9e8ae952":"code","2b9a9c5c":"code","4a0d947b":"code","1a14d05a":"code","4cf07db4":"code","e1a1442d":"code","6b18a0a2":"code","42dd22b7":"code","e1655ba6":"code","ded80a71":"code","c9916479":"code","b80b038a":"code","02ba589e":"code","31f5f27d":"code","d0162db6":"code","22d2df2c":"code","16ff62d6":"code","c3cfca1b":"code","cbf9ca18":"code","7438fa14":"code","e779bb06":"code","4b4c8e8a":"code","d91542cf":"code","27a8e14f":"code","baea6f77":"code","f2a83afd":"code","57382b2a":"code","9572b0a6":"code","5a615d41":"code","1d72d004":"code","08025a24":"code","9a0a6539":"code","e8831256":"code","026ad74e":"code","d7d42629":"code","e5ad387d":"code","a42367a7":"code","f8b56b68":"code","c6bffc76":"code","497b23a4":"code","4a987667":"code","3fa7ea32":"code","5952e9d2":"code","38ccd757":"code","7040cfb5":"code","0a1cdf79":"code","042af14f":"code","5ee43033":"code","43621b36":"code","ec1e8c94":"code","2da02327":"code","16ae0aaa":"code","04058182":"code","27ee48ea":"code","274cca79":"code","654e5d7c":"code","b2cbc9a2":"code","e9ff7032":"code","c60e555c":"code","dc65de65":"code","53d748d0":"markdown","14755da4":"markdown","e92016ce":"markdown","227f18d4":"markdown","f285907b":"markdown","986791a4":"markdown","1088b1b5":"markdown","d9524a0e":"markdown","42e03f55":"markdown","3c49a6e5":"markdown","af6c49d1":"markdown","509a6c0b":"markdown","9a9e0189":"markdown","f6f45401":"markdown","8c446d12":"markdown","328cbca9":"markdown","0da5e148":"markdown","545dcae9":"markdown","8115849c":"markdown","7cb302db":"markdown","c540172a":"markdown","3dbd4518":"markdown","1bf8beba":"markdown","ce02e8c4":"markdown","52f93e6f":"markdown","0da2d98c":"markdown","47a4fca5":"markdown","3100ea79":"markdown","c21fe1af":"markdown","4df7bdea":"markdown","489492a8":"markdown","358e45da":"markdown","d17a5398":"markdown","bc0e4bae":"markdown","a11d82a4":"markdown","2ab2cb0b":"markdown","7a3f1d29":"markdown","1f479680":"markdown","5f5c618c":"markdown","c6d584f9":"markdown","e18402fb":"markdown","83bd5844":"markdown","3770c05d":"markdown","621c839d":"markdown","e3e650d3":"markdown","1b604fb4":"markdown","8e8a7d41":"markdown"},"source":{"f90274a0":"from IPython.core.display import display, HTML\ndef partnership():\n    display(HTML(\"\"\"<h3>Thanks for cooperation<\/h3>\n    Many thanks to <a href=\"http:\/\/www.esportbetting.eu\" rel=\"dofollow\">http:\/\/www.esportbetting.eu<\/a> for the help which enabled\n    me to complete this project.<br \/> The site is a great resource for eSport odds, betting statistics, and reviews. It is mainly focused on <a href=\"https:\/\/esportbetting.eu\/games\/csgo\" rel=\"dofollow\">CS:GO betting<\/a>, \n    but covers other eSports such as League of Legends or Dota2 as well.\"\"\"))","8863e3e1":"partnership()","9e8ae952":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import figure\nimport seaborn as sns\nimport matplotlib.patches as mpatches","2b9a9c5c":"EVENT_PATH = '..\/input\/cleaned-csgo-events\/cs_go_events_cleaned.csv'","4a0d947b":"df = pd.read_csv(EVENT_PATH)","1a14d05a":"df.head(3)","4cf07db4":"df.groupby('year').count()['event_link'].reset_index()\nyears_df = df.groupby('year').count().reset_index()\nyears, years_count = years_df.year, years_df.event_link","e1a1442d":"plt.figure(figsize=(8, 8), dpi=80)\nplt.bar(years, years_count)\nplt.xlabel('Year')\nplt.ylabel('Event count')\nplt.title('Event count by year')\nplt.show()","6b18a0a2":"event_type_by_year = df.groupby(['event_type', 'year']).count().reset_index()\nsns.set(style=\"whitegrid\")\ng = sns.catplot(x=\"year\", y=\"event_link\", hue=\"event_type\", data=event_type_by_year, height=9, kind=\"bar\", palette=\"muted\")\ng.despine(left=True)\ng.set_ylabels(\"event count\")","42dd22b7":"money_year = df.groupby('year').count().reset_index()\nmoney_by_year = df.groupby(['year']).sum()['prize_money'].reset_index()\nplt.figure(figsize=(8, 8), dpi=80)\nplt.bar(money_by_year.year, money_by_year.prize_money)\nplt.xlabel('Year')\nplt.ylabel('Money prize - 10 mln $')\nplt.title('Money prizes by year')\nplt.show()","e1655ba6":"x = df.groupby(['event_type', 'year']).sum()['prize_money']\/df.groupby(['event_type', 'year']).count()['event_link']\nmoney_by_event_by_year = x.reset_index() # inplace=True - > TypeError: Cannot reset_index inplace on a Series to create a DataFrame\nmoney_by_event_by_year.columns.values\nmoney_by_event_by_year.columns = ['event_type', 'year', 'average_money']\n\nsns.set(style=\"whitegrid\")\ng = sns.catplot(x=\"year\", y=\"average_money\", hue=\"event_type\", data=money_by_event_by_year, height=9, kind=\"bar\", palette=\"muted\")\ng.despine(left=True)\ng.set_ylabels(\"average money prize by event\")","ded80a71":"RANKING_PATH = '..\/input\/cleaned-csgo-rankings\/cs_go_hltv_ranking_clean.csv'","c9916479":"MATCHES_PATH = '..\/input\/cleaned-csgo-matches\/cs_go_matches_cleaned.csv'\n\ndf = pd.read_csv(MATCHES_PATH, low_memory=False)\n\ndf.columns.values\n\nprint(\"Maps played: \"+str(df.shape[0]))\nprint(\"Matches: \"+str(len(df.match_id.unique())))","b80b038a":"matches_type = df.best_of.value_counts().reset_index()\nmatches_type.columns = ['best_of_type', 'best_of_count']\nmatches_type = df.best_of.value_counts().reset_index()\nmatches_type.columns = ['best_of_type', 'best_of_count']\nplt.figure(figsize=(8, 8), dpi=80)\nplt.bar(matches_type.best_of_type, matches_type.best_of_count)\nplt.xlabel('Best of ')\nplt.ylabel('Matches count')\nplt.title('Count of different matches type')\nplt.show()","02ba589e":"len(df[df.best_of == 3]) \/ len(df.best_of)","31f5f27d":"matches_count_2016 = len(df[df.year == 2016].match_id.unique())\nmatches_count_2017 = len(df[df.year == 2017].match_id.unique())\nmatches_count_2018 = len(df[df.year == 2018].match_id.unique())\nprint(\"Matches in 2016: \" + str(matches_count_2016) )\nprint(\"Matches in 2017: \" + str(matches_count_2017) )\nprint(\"Matches in 2018: \" + str(matches_count_2018) )","d0162db6":"team_count_16 = len(pd.concat([df[df.year == 2016].home_team_id, df[df.year == 2016].away_team_id]).unique())\nteam_count_17 =len(pd.concat([df[df.year == 2017].home_team_id, df[df.year == 2017].away_team_id]).unique())\nteam_count_18 =len(pd.concat([df[df.year == 2018].home_team_id, df[df.year == 2018].away_team_id]).unique())\n\nprint(\"Teams in 2016: \" + str(team_count_16) )\nprint(\"Teams in 2017: \" + str(team_count_17) )\nprint(\"Teams in 2018: \" + str(team_count_18) )","22d2df2c":"round(team_count_17\/team_count_16, 3)\nround(matches_count_2017\/matches_count_2016, 3)","16ff62d6":"maps_count = df.maps.value_counts().reset_index()\nmaps_count = df.maps.value_counts().reset_index()\nmaps_count.columns = ['map_name', 'map_count']\nplt.figure(figsize=(9, 9), dpi=80)\nplt.bar(maps_count.map_name, maps_count.map_count)\nplt.xlabel('Map name ')\nplt.ylabel('Map count')\nplt.title('Number of games per map')\nplt.show()","c3cfca1b":"hfs = df.groupby(['fist_half_home_side','maps']).home_first_score.sum().reset_index()\nass = df.groupby(['fist_half_home_side','maps']).away_second_score.sum().reset_index()\nhss = df.groupby(['fist_half_home_side','maps']).home_second_score.sum().reset_index()\nafs = df.groupby(['fist_half_home_side','maps']).away_first_score.sum().reset_index()\nct_1 = hfs[hfs.fist_half_home_side == 0].home_first_score + ass[ass.fist_half_home_side == 0].away_second_score #ct\nt_1 = hfs[hfs.fist_half_home_side == 1].home_first_score + ass[ass.fist_half_home_side == 1].away_second_score #t\nt_2 = hss[hss.fist_half_home_side == 0].home_second_score + afs[afs.fist_half_home_side == 0].away_first_score #t\nct_2 = hss[hss.fist_half_home_side == 1].home_second_score + afs[afs.fist_half_home_side == 1].away_first_score #ct\nct_1 = ct_1.reset_index().drop('index', axis=1)\nct_2 = ct_2.reset_index().drop('index', axis=1)\nt_1 = t_1.reset_index().drop('index', axis=1)\nt_2 = t_2.reset_index().drop('index', axis=1)\nct_terro_percent = pd.DataFrame\nct_terro_percent = t_1 +t_2\nct_terro_percent.columns = ['terro_won_total']\nct_terro_percent['maps'] = afs[afs.fist_half_home_side == 0].maps\nct_terro_percent['ct_won_total'] = (ct_1 + ct_2)\nct_terro_percent['total_rounds'] = (ct_1 + ct_2) + (t_1 + t_2)\n","cbf9ca18":"r = [0,1,2,3,4,5,6,7]\nterro_percent = [i \/ j * 100 for i,j in zip(ct_terro_percent['terro_won_total'], ct_terro_percent['total_rounds'])]\nct_percent = [i \/ j * 100 for i,j in zip(ct_terro_percent['ct_won_total'], ct_terro_percent['total_rounds'])]\nplt.figure(figsize=(9, 9), dpi=80)\nbarWidth = 0.9\nnames = ('Cache','Cobblestone','Dust2','Inferno','Mirage', 'Nuke','Overpass','Train',)\nplt.bar(r, terro_percent, color='#FFFF66', edgecolor='white', width=barWidth)\nplt.bar(r, ct_percent, bottom=terro_percent, color='#00BFFF', edgecolor='white', width=barWidth)\nplt.xticks(r, names)\nplt.xlabel(\"Map\")\nplt.ylabel(\"Percentage\")\nplt.title(\"Rounds won by CT or T side by map\")\nblue_patch = mpatches.Patch(color='#00BFFF', label='Counter terrorist')\nyellow_patch = mpatches.Patch(color='#FFFF66', label='Terrorist')\nplt.legend(handles=[blue_patch, yellow_patch])\nplt.yticks([0,10,20,30,40,45,55,60,70,80,90,100])\nplt.axhline(y=50, color=\"red\")\nplt.show()","7438fa14":"overtime_count = df[(df.home_first_score + df.home_second_score) == (df.away_first_score + df.away_second_score)].shape[0]\nadventage_won_home = df[(df.home_first_score > df.away_first_score) & ((df.home_first_score + df.home_second_score) > (df.away_first_score+ df.away_second_score))].shape[0]\nadventage_won_away = df[(df.home_first_score < df.away_first_score) & ((df.home_first_score + df.home_second_score) < (df.away_first_score+ df.away_second_score))].shape[0]\ntotal_matches = df.shape[0]\nadv_won_percent = round((adventage_won_away + adventage_won_home) \/ total_matches *100, 2)\novertime_percent = round(overtime_count \/ total_matches * 100, 2)\nadv_lost_percent = round(100-(adv_won_percent+overtime_percent), 2)\nprint(\"Winning the map after winning the first half occurred in \" +str(adv_won_percent) + \"% cases\")\nprint(\"Overtime was the case in \" +str(overtime_percent) + \"% matches\")\nprint(\"Loosing map after adventage after first half: \" +str(adv_lost_percent) + \"%\")","e779bb06":"# reading dataframes","4b4c8e8a":"df_events = pd.read_csv(EVENT_PATH)","d91542cf":"df_matches = pd.read_csv(MATCHES_PATH, low_memory=False)","27a8e14f":"df_ranking = pd.read_csv(RANKING_PATH)","baea6f77":"# getting event\/tournament id from link","f2a83afd":"df_events.columns.values","57382b2a":"df_events['event_id'] = df_events.event_link.str.split(\"\/\")","9572b0a6":"events_id = df_events.event_id.reset_index()","5a615d41":"events_id.columns = ['h_index', 'event_id']","1d72d004":"for h_index in events_id.h_index:\n    df_events.loc[h_index, 'event_id'] = df_events.loc[h_index].event_id[4]","08025a24":"df_events.event_id.head(3)","9a0a6539":"# combining dataframes - matches with events by event id - ","e8831256":"event_id_list = df_events.event_id.astype(int).tolist()","026ad74e":"df_event_matches = pd.DataFrame","d7d42629":"df_matches.shape","e5ad387d":"# This loop is taking some time so after the first launch, I saved the data frame to CSV file\n\n# for event_id in range(0, len(df_matches.tournament_id)-1):\n#     if not df_matches.loc[event_id].tournament_id in event_id_list:\n#         df_matches = df_matches.drop(event_id)\n# df_matches.to_csv('matches_to_model.csv', index=False)\ndf_matches = pd.read_csv('..\/input\/cs-go-matches-to-model-clean\/matches_to_model.csv', low_memory=False)","a42367a7":"df_matches.shape","f8b56b68":"df_matches = df_matches.reset_index().drop(\"index\", axis=1)","c6bffc76":"df_matches.columns.values","497b23a4":"df_work_data = df_matches[['best_of','fist_half_home_side','maps',\n                           'year','month','home_team_id','away_team_id',\n                           'ht_p1_id','ht_p2_id','ht_p3_id','ht_p4_id','ht_p5_id',\n                           'at_p1_id','at_p2_id','at_p3_id','at_p4_id','at_p5_id',\n                           'home_first_score','away_first_score','home_second_score','away_second_score',\n                           'home_team_score','away_team_score']]","4a987667":"sel_rows = df_work_data[(((df_work_data.home_first_score + df_work_data.home_second_score) == \n              (df_work_data.away_first_score + df_work_data.away_second_score)) \n             & (df_work_data.best_of == 3))].index","3fa7ea32":"df_work_data = df_work_data.drop(sel_rows, axis=0)","5952e9d2":"df_work_data.shape","38ccd757":"# Target values for binary classification - home team win\/lose","7040cfb5":"df_work_data['target'] = np.where(df_work_data.home_team_score > df_work_data.away_team_score, 1, 0)","0a1cdf79":"df_work_data.columns.values","042af14f":"df_work_data.info()","5ee43033":"from sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import train_test_split # splits data set into Train\/Test.","43621b36":"lb_enc = LabelEncoder()","ec1e8c94":"df_work_data[\"maps\"] = lb_enc.fit_transform(df_work_data[\"maps\"])","2da02327":"df_work_data = df_work_data.drop(['home_second_score', 'away_second_score',\n                    'home_team_score', 'away_team_score'], axis =1 )","16ae0aaa":"df_work_data.columns.values","04058182":"y = df_work_data['target']\nX = df_work_data.drop('target', axis=1)","27ee48ea":"X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.1,random_state=123)","274cca79":"from keras.layers import Dense\nfrom keras.optimizers import Adam\nfrom keras.losses import sparse_categorical_crossentropy\nfrom keras import Sequential\nfrom keras.layers import Dropout\nimport xgboost as xgb\nimport time","654e5d7c":"def XGBoost(X_train,X_test,y_train,y_test,num_rounds=500):\n    dtrain = xgb.DMatrix(X_train,label=y_train)\n    dtest = xgb.DMatrix(X_test,label=y_test)\n\n    return xgb.train(params={\n                    'tree_method':'gpu_exact',\n                    'eval_metric':'error',\n                    'objective':'gpu:binary:logistic'}\n                    ,dtrain=dtrain,num_boost_round=num_rounds, \n                    early_stopping_rounds=50,evals=[(dtest,'test')],)","b2cbc9a2":"xgbm = XGBoost(X_train,X_test,y_train,y_test) # For output, click on the code button","e9ff7032":"iter_ = 0 \nbest_error = 0\nbest_iter = 0\nbest_model = None\n\ncol_sample_rates = [1]\nsubsamples = [1]\netas = [0.1]\nmax_depths = [8]\nreg_alphas = [0.004]\nreg_lambdas = [0.001]\nmin_child_weights = [3]\nntrees = [3000]\n\ntotal_models = len(col_sample_rates)*len(subsamples)*len(etas)*len(max_depths)*len(reg_alphas) *len(reg_lambdas)*len(ntrees)*len(min_child_weights)\nbest_error = 1\ndtrain = xgb.DMatrix(X_train,label=y_train)\ndtest = xgb.DMatrix(X_test,label=y_test)\n# determine mean y value in training\n# y_mean = train[y].mean()\n\nfor col_sample_rate in col_sample_rates:\n    for subsample in subsamples:\n        for eta in etas:\n            for max_depth in max_depths:\n                for reg_alpha in reg_alphas:\n                    for reg_lambda in reg_lambdas:\n                        for ntree in ntrees:\n                            for min_child_weight in min_child_weights:\n                                tic = time.time()\n\n                                print('---------- ---------')\n\n                                print('Training model %d of %d ...' % (iter_ + 1, total_models))\n                                print('col_sample_rate =', col_sample_rate)\n                                print('subsample =', subsample)\n                                print('eta =', eta)\n                                print('max_depth =', max_depth)\n                                print('reg_alpha =', reg_alpha)\n                                print('reg_lambda =', reg_lambda)\n                                print('ntree =', ntree)\n                                print('min_child_weights = ', min_child_weight)\n\n                                params = {\n                                     'booster': 'gbtree',\n                                     'colsample_bytree': col_sample_rate,\n                                     'eta': eta,\n                                     'max_depth': max_depth,\n                                     'nthread': -1,\n                                     'min_child_weight': min_child_weight,\n                                     'reg_alpha': reg_alpha,\n                                     'reg_lambda': reg_lambda,\n                                     'seed': 12345,\n                                     'silent': 1,\n                                     'n_estimators':ntree,\n                                     'tree_method':'gpu_exact',\n                                     'eval_metric':'error',\n                                     'objective':'gpu:binary:logistic',\n                                     'subsample': subsample}\n\n                                watchlist = [(dtrain, 'train'), (dtest, 'eval')]\n\n                                model = xgb.train(\n                                                params, \n                                                dtrain, \n                                                ntree,\n                                                early_stopping_rounds=100,\n                                                evals=watchlist, \n                                                verbose_eval=False)\n\n                                print('Model %d trained in %.2f s.'  % (iter_, time.time()-tic))\n                                print('Model %d best score = %.4f' % (iter_, model.best_score))\n\n                                if model.best_score < best_error:\n                                    best_error = model.best_score\n                                    best_iter = iter_\n                                    best_model = model \n                                    print('Best so far!!!')\n                                    print('Best error =', best_error)\n\n\n                                iter_ += 1\n\nprint('Best model found at iteration: %d, with error: %.4f.' % (best_iter + 1, best_error))   ","c60e555c":"model = Sequential()\nmodel.add(Dense(19, activation=\"relu\",input_shape=(19,)))\nmodel.add(Dense(15,activation=\"tanh\"))\nmodel.add(Dense(2))\nmodel.compile(loss=\"sparse_categorical_crossentropy\",optimizer=\"adam\",metrics=[\"accuracy\"])","dc65de65":"model.fit(x=X_train,y=y_train,batch_size=100,epochs=5)","53d748d0":"## Preparing data for prediction model\n[Table of content](#Table-of-content)","14755da4":"## Matches type distribution\n[Table of content](#Table-of-content)","e92016ce":"## Does it matter whether we play counter-terrorist or terrorist side on a particular map?\n[Table of content](#Table-of-content)","227f18d4":"The most popular map is a Mirage. The least popular maps are Nuke and Dust2. This is partly due to the fact that in recent years they have been outside the official map pool. The reason was the change in the graphic appearance of the map. There are no major differences between the other maps.","f285907b":"## XGBOOSTING matches\n[Table of content](#Table-of-content)","986791a4":"## Matches and team count by year \n[Table of content](#Table-of-content)","1088b1b5":"## Multilayer perceptron\n[Table of content](#Table-of-content)","d9524a0e":"The number of matches increased by 61% while the number of playing teams by 30% comparing 2016 to 2017.","42e03f55":"Are there more professional teams on the CS:GO scene or just the same teams play more matches?","3c49a6e5":"Dataset is small and one model with GPU support is trained in ~1 second, so why not try grid search with xgboost?","af6c49d1":"Accuracy score with MLP is very low (comparing to xgboost), but what to expect with a dataset that small.","509a6c0b":"The first run of xgboost gives ~22% error rate, on the LAN matches after the first half. Having only a few data points in dataset I think this is a pretty good result.","9a9e0189":"## Events count by year\n[Table of content](#Table-of-content)","f6f45401":"In this case, I consider only LAN events.","8c446d12":"In this case, I will check if the advantage after the first half can guarantee winning the whole map. Overtime will be treated as \"not winning\".","328cbca9":"Only one map clearly favors terrorist side(Cache), while Mirage, Overpass, Train, and Nuke are maps that are easier to play on the counter-terrorist side. Especially Nuke and Train - the defending side wins around 55% of the rounds played on these maps.","0da5e148":"Large average increase is on major tournament - prize pool has increased four times in 2016|. Local and regional lans are not focused on money prizes, looks like the main prize in these competitions is spot on more significant competitions (local>regional>international>major).","545dcae9":"## Does the advantage after the first half guarantee winning the map?\n[Table of content](#Table-of-content)","8115849c":"Let's see if the CS:GO scene has grown over the past years.","7cb302db":"## Average money prizes by event type by year\n[Table of content](#Table-of-content)","c540172a":"Big increase in 2017 is partly because of big local lans increase. This growth is a year after the prize pool has increased in 2016 almost 3 times in comparison to 2015. ","3dbd4518":"Local lans gained a lot of new events in 2016 and 2017, but in general, the biggest increase was between 2014-2017.","1bf8beba":"## XGBOOST Tuning\n[Table of content](#Table-of-content)","ce02e8c4":"A goal of this analysis is to explore some basic information about CS:GO competitive scene. At the end I will try to use available pieces of information to predict the outcome of the CS:GO match.","52f93e6f":"## Predicting match based on half time score\n[Table of content](#Table-of-content)","0da2d98c":"## Money prize by year\n[Table of content](#Table-of-content)","47a4fca5":"Due to missing information in matches dataset, I have to drop maps with overtime - in bo3, there is no option to tell if the particular map was won by the home team or away team. Overtimes with bo1 type are still used.","3100ea79":"Money prizes also reached their peak in 2017, the biggest growth was between 2015-2016. Till the end of 2018, there are no more tournaments with big money prizes, so total prize money will be similar as in 2017.","c21fe1af":"Let's see how the distribution of different events type looks like.","4df7bdea":"# Is competitive CS:GO scene still growing? How competitive CS:GO has changed? Predicting CS:GO match outcome.","489492a8":"# Abstract","358e45da":"Model was pre trained, I've left only best parameters in grid search. A score is the same as in case of default settings.","d17a5398":"In this analysis, I will use 3 datasets.\n    - CS:GO Events  - dataset with LAN events since 2012 (first CS:GO tournament)\n    - CS:GO Ranking - HLTV ranking, since October 2015\n    - CS:GO Matches - competitive matches since January 2016 - extended aftermatch data from the demo file has been introduced\nAll data has been scraped from www.hltv.org.","bc0e4bae":"# Predicting match outcome\n[Table of content](#Table-of-content)","a11d82a4":"## Feature engineering\n[Table of content](#Table-of-content)","2ab2cb0b":"## Events count by event type\n[Table of content](#Table-of-content)","7a3f1d29":"## Importing libraries\n[Table of content](#Table-of-content)","1f479680":"Most popular type is best of 3 (~61%), good for different tournament formats - eliminates randomity playing one map which could not be good for one of the teams at the moment, but also isn't too long - as playing one map takes about 40-50 minutes. The least popular is best of 5 type. It is often played as the final of the tournament.","5f5c618c":"# Exploring matches dataset\n[Table of content](#Table-of-content)","c6d584f9":"Almost 3\/4 matches are won in regular time by the team leading after the first half.","e18402fb":"# Exploring ranking dataset\n[Table of content](#Table-of-content)","83bd5844":"# Table of content\n* [All datasets have been previously cleaned](#Table-of-content)\n    * [Cleaning events dataset](https:\/\/www.kaggle.com\/twistplot\/cs-go-event-dataset-cleaning?scriptVersionId=6412209)\n    * [Cleaning ranking dataset](https:\/\/www.kaggle.com\/twistplot\/cs-go-hltv-ranking-basic-cleaning)\n    * [Cleaning matches dataset](https:\/\/www.kaggle.com\/twistplot\/cs-go-matches-dataset-basic-cleaning?scriptVersionId=6412200)\n*    [Exploring events dataset](#Exploring-events-dataset)\n    *      [Importing libraries](#Importing-libraries)\n    *      [Event count by year](#Events-count-by-year)\n    *      [Event count by event type](#Events-count-by-event-type)\n    *      [Money prize by year](#Money-prize-by-year)\n    *      [Average money prizes by event type by year](#Average-money-prizes-by-event-type-by-year)\n*    [Exploring ranking dataset](#Exploring-ranking-dataset)\n*    [Exploring matches dataset](#Exploring-ranking-dataset)\n    *      [Matches type distribution](#Matches-type-distribution)\n    *      [Matches and team count by year](#Matches-and-team-count-by-year)\n    *      [Exploring CS:GO maps](#Exploring-maps)\n    *      [Does side on particular map matter?](#Does-it-matter-whether-we-play-counter-terrorist-or-terrorist-side-on-a-particular-map?)\n    *      [First-half advantage - guarantee of winning?](#Does-the-advantage-after-the-first-half-guarantee-winning-the-map?)\n*      [Predicting match outcome](#Predicting-match-outcome)\n    *    [Feature engineering](#Feature-engineering)\n    *    [Preparing data for prediction model](#Preparing-data-for-prediction-model)\n    *    [Predicting match based on half time score](#Predicting-match-based-on-half-time-score)\n    *    [XGBOOSTING Matches](#XGBOOSTING-Matches)\n    *    [XGBOOST Tuning](#XGBOOST-Tuning)\n    *    [Multilayer perceptron](#Multilayer-perceptron)","3770c05d":"In CS:GO match dataset 39381 maps are played in 24015 matches. There are several types of matches on the CS: GO tournament stage - Best of(BO) 1, BO2, BO3, BO5. Let's see how the distribution of different types of matches looks.","621c839d":"Variables used to create data for model:\n    - best_of - game type\n    - fist_half_home_side - first side for home team\n    - maps - map on which game is played\n    - year - year in which the match was played\n    - month - month in which the match was played\n    - home_team_id - Unique home team id\n    - away_team_id - Unique away team id\n    - ht_p1_id - Unique home player 1 id, player 2 id...\n    - at_p1_id - Unique away player 1 id...\n    - home_first_score - first half score for home team\n    - away_first_score - first half score for away team\n    \n    Other variables were used for creating target variable - who won the match","e3e650d3":"## Exploring maps\n[Table of content](#Table-of-content)","1b604fb4":"# Exploring events dataset\n[Table of content](#Table-of-content)","8e8a7d41":"Looks like fast CS:GO scene growth since 2014 stopped this year. We still have some time till the end of this year but event count will be similar as in 2017. Beside online games and tournaments (not included in this dataset) we have four types of LAN events. Local LAN, regional LAN, international LAN, major tournament."}}