{"cell_type":{"b825b3b3":"code","93264929":"code","bdde8115":"code","a2ac764a":"code","7d10e379":"code","6d1d8715":"code","e4dbca11":"code","71233837":"code","97563226":"code","4109c9ed":"code","b4a919bc":"markdown","bf400fc6":"markdown","d49d5240":"markdown","0838c4db":"markdown","7268aaaf":"markdown","8d2d983a":"markdown","f70ec212":"markdown","5141083c":"markdown","43be7690":"markdown"},"source":{"b825b3b3":"# import required libraries\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib\n\ndef draw(x_axis,y_axis,x_label,y_label,show = True):\n    \"\"\" \n    function developed to produce plots in notebook\n    \"\"\"\n    plt.figure(figsize = (15,5))\n    plt.grid(alpha = 0.5)\n    plt.style.use('dark_background')\n    plt.plot(x_axis, y_axis)\n    plt.xlabel(x_label, fontsize = 20)\n    plt.ylabel(y_label, fontsize= 20)\n    if show:\n        plt.show()\n    return    ","93264929":"dt  =0.001                                                          #declared the differential of time \nt = np.arange(0,1,dt)                                               #sampled the time of one second in 1000 data points\n\n# uncomment below lines to see the samples and amount of samples\n\n#print(\"no of samples in one second are \" = t.shape)\n#print(t)\n\n########################\n\nsin_4t = np.sin(2 *  np.pi * 4 * t)                                        # producing the sin signal with frequency of 4 hertz\n\ndraw(x_axis = t,y_axis = sin_4t ,x_label = \"Time(s)\",y_label = \"Magnitude\",show = True)","bdde8115":"#similarly we can create a signal with frequency 10 hertz\n\n\nsin_10t = np.sin(2*np.pi*10*t)\ndraw(x_axis = t,y_axis = sin_10t ,x_label = \"Time(s)\",y_label = \"Magnitude\",show = True)","a2ac764a":"# here we mixed two signals with each other and then we created a signal composite of two frequecies 4 hertz and 10 hertz\n\nmixed = sin_4t + sin_10t\ndraw(x_axis = t,y_axis = mixed ,x_label = \"Time(s)\",y_label = \"Magnitude\",show = True)","7d10e379":"def add_noise(signal , noise_amplitude = 2.5):\n    \"\"\"\n    Noise addition function\n    signal = input signal or array\n    noise_amplitude = amplitude of white noise \n    \"\"\"\n    noisy = signal + 2.5*np.random.randn(len(t))\n    return noisy \n\noriginal = mixed\nnoisy = add_noise(original , 2.5)\n\n\nplt.figure(figsize = (15,5))\nplt.grid(alpha = 0.5)\nplt.style.use('dark_background')\nplt.plot(t, noisy,color = \"g\", label = \"Noisy Signal\")\nplt.plot(t, mixed,color = 'r', label = \"Original Signal\")\nplt.xlabel(\"Time(s)\", fontsize = 20)\nplt.ylabel(\"Magnitude\", fontsize= 20)\nplt.legend()\nplt.show()\n\n#I would highly recommend to play arounf with other signals as well ","6d1d8715":"n = len(t)                                                      # number of points in dataset\nf_transformed = np.fft.fft(noisy,n)                             # transformation done  \nf_real = f_transformed.real                                     # real values of fourier transform\nf_imag = f_transformed.imag                                     # imaginary values of fourier transform\nfrequecies = (1\/(dt*n)) * (np.arange(n))                        # frequencies in fourier transform\n\n# If you plot the real and imaginary components of the transform then you may get confused so always remember ,we \n# need to go for the power density of different frequecies in transform to get the most prominent frequencies of signal\n\ndraw(x_axis = frequecies,y_axis = f_real,x_label = \"Frequecy\",y_label = \"Real Magnitude\",show = True)\ndraw(x_axis = frequecies,y_axis = f_imag,x_label = \"Frequecy\",y_label = \"Imaginary Magnitude\",show = True)","e4dbca11":"psd = f_transformed * np.conjugate(f_transformed) \/ n               # formula for power spectral density\n\ndraw(x_axis = frequecies,y_axis = psd,x_label = \"Frequecy\",y_label = \"Magnitude\",show = True)","71233837":"draw(x_axis = frequecies[0:int(len(frequecies)\/2)],y_axis = psd[0:int(len(frequecies)\/2)],x_label = \"Frequecy\",y_label = \"Magnitude\",show = True)","97563226":"# selecting only prominent frequecies any nullifing all the other indices coefficients in fourier transform\n\nindices = [psd > 50]\nprint(indices)\nf_transformed = f_transformed*indices\n\n\n# doing inverse fourier transformation of the filtered FT\n\ninversed = np.fft.ifft(f_transformed)\n","4109c9ed":"draw(x_axis = t,y_axis = inversed.reshape((1000,)),x_label = \"Time(t)\",y_label = \"Recovered Signal Magnitude\",show = True)\ndraw(x_axis = t,y_axis = mixed ,x_label = \"Time(t)\",y_label = \"Original Signal Magnitude\",show = True) ","b4a919bc":"And Voilla!! we have recoverd our signal back in good health \n\nyou can observe that the recovered signal is not exactly the same original one due to high amplitude of introduced noise \nso get your hands dirty and play around with this notebook to explore more","bf400fc6":"now that's what we need, you will see two peaks one is at 4 and other one is at 10 hertz, remaining all are nothing but values of fourier coefficients for the white noise frequncies \n\nYou can run this notebook again by changing the frequecies of our input signals ","d49d5240":"# Power spectral Density\n\nA power spectral density (PSD) takes the amplitude of the FFT, multiplies it by its complex conjugate and normalizes it to the frequency bin width.  This allows for accurate comparison of random vibration signals that have different signal lengths.","0838c4db":"if you guys can observe then this graph is showing 4 long peaks but our original signal was only made up of 2 prominent frequencies so what should be done now\n\nwe actuall need to analyse the half of the spectrum because the spectrum mirrors itself on the account of negative frequencies so after this change we will get much better analysis","7268aaaf":"# Fourier Transform","8d2d983a":"**We will be using the sinusoidal signals as input because they are easier to understand so lets make some sinusoidal waves !!!**\n\nthe sinusoidal signal we have produced is of form\n\n**sin( 2\u03c0ft )**\n\n\u03c0 = np.pi,          f = frequency,           t = time","f70ec212":"# Fourier Transform Introduction\n<font size = 4><bold>\nPlease skip this introdution if you already know about the basics of fourier transform    \n<\/bold><\/font>\n\nSo, In general terms , fourier transforms can be defined as a method to decompose a signal into sum of various sinusoidal signals of different magnitude and frequecies.\nThat's it!! \nI don't want to mess up things so let's move forward with this definition\n\nAlthough the perfect definition is a little bit different but for the sake of simplicty stick to this\n\nfourier transform is the root concept of filtering and denoising signals. In this notebook we will be creating a function and then we will be adding some white noise to it \nand after that we will recovering the signal !!!\n\n![](https:\/\/mriquestions.com\/uploads\/3\/4\/5\/7\/34572113\/3311485_orig.gif)","5141083c":"Awesome!!! right\n\nnow it is the time to introduce some noise into the signal ","43be7690":"Use dark mode for Better Experience "}}