{"cell_type":{"524a0428":"code","ad875488":"code","421c2159":"code","8e7ece11":"code","af4d342e":"code","82d402dc":"code","687cf852":"code","01b1b381":"code","a21a9f6c":"code","85ad72e3":"code","92daf728":"code","6e38803c":"code","079a8402":"code","ba26af91":"code","86774a90":"code","cecfebd3":"code","45db8af5":"code","8ef65482":"code","11f2cda3":"code","1260afbb":"code","3d0b7995":"code","d06663a6":"code","7f929687":"code","cd949aba":"code","63e27a68":"code","5f18ed71":"code","6343cb7a":"code","75f17c36":"code","86b9d155":"code","b70dd1e6":"code","dad9b7aa":"code","5fae8629":"code","ef40cc96":"code","1ca383c4":"code","a3fbc78f":"code","8631e8c3":"code","487715a2":"code","6978c1d8":"code","4ab2acd4":"code","bbe655ee":"code","6dab03b3":"code","3e9f5f17":"code","23dc9a94":"code","eb66538d":"code","624459bb":"code","186e67cf":"code","cc38e8ee":"code","62997354":"code","a252f729":"code","7d647c34":"code","bdd00573":"code","8f3a9480":"code","0fa386ed":"code","a00fbde1":"code","d441f940":"code","32ff042c":"code","8f95608c":"code","e628265e":"code","fac5a27f":"code","8c7846a9":"code","a617cfa7":"code","ac402cec":"code","efaea3bb":"code","8fc51eb0":"code","d28a7faf":"code","ce4d0d3f":"code","db2ba7bc":"code","1d05f5d3":"code","50b83cfc":"code","a2278755":"code","cfab5d21":"code","5da48a2d":"code","3ab484c3":"code","8919f557":"markdown","7d1b89e5":"markdown","c2286aab":"markdown","7e51f9ff":"markdown","d3c6c2d8":"markdown","b5e627c9":"markdown","ad6f42a5":"markdown","be9d0580":"markdown","0207cea3":"markdown","d937d490":"markdown","802d1cae":"markdown","690168bc":"markdown","73813f91":"markdown","34279f10":"markdown","0c7b5e0b":"markdown","d161b9b3":"markdown","4214d024":"markdown","abceca6e":"markdown","aab5eda4":"markdown","a7fd33c9":"markdown","1e17a6cf":"markdown","3cf36cd4":"markdown","3181b496":"markdown","6f5f44ee":"markdown","3e6e1e9c":"markdown","d32b0319":"markdown","972f194a":"markdown","12588de9":"markdown","5dc89c2a":"markdown","aa305b98":"markdown","b3d97902":"markdown","deb028dd":"markdown","c92cc484":"markdown","d5de431b":"markdown","5984a55a":"markdown","38464bbf":"markdown","c3b92f19":"markdown","06d49fcb":"markdown","fa3f1669":"markdown","d89786f9":"markdown","fac37623":"markdown","bb0d13a1":"markdown","bfc82d38":"markdown","7ba20624":"markdown","aca9fc92":"markdown","000122d9":"markdown","15807b61":"markdown","fba32265":"markdown","1366b8b3":"markdown","97e15105":"markdown","64b51887":"markdown","64f5a963":"markdown","61d7527e":"markdown","2395db07":"markdown","2c3d7568":"markdown","d0e42945":"markdown","031c1a9e":"markdown","20b30593":"markdown","30b2c102":"markdown","7efccd0d":"markdown","d9c84909":"markdown","686ba804":"markdown","75493d07":"markdown","f8121d34":"markdown","47ed094e":"markdown","c969bb5f":"markdown","40b83007":"markdown","54cd8e44":"markdown","ebb4a278":"markdown","26382ab1":"markdown","3e336313":"markdown","c14f63bf":"markdown","858ee843":"markdown","8e240751":"markdown","a543049d":"markdown","734fb44e":"markdown","588cba4b":"markdown","5095bea9":"markdown","bd9e81e6":"markdown","e57fe928":"markdown","c357fb85":"markdown","ab95e514":"markdown","f84c0d10":"markdown","bd01da24":"markdown","8ba424ba":"markdown","1a661a89":"markdown","5ed5723e":"markdown","a8fdd5ec":"markdown","2fa869df":"markdown","6f7338b9":"markdown","d4f015ac":"markdown"},"source":{"524a0428":"import numpy as np\nimport matplotlib.pyplot as plt \nfrom scipy.stats import norm\nfrom scipy.optimize import minimize","ad875488":"starting_capital = 1000 # PV\nr = 0.05 # 5% interest\nn = 50 # Years","421c2159":"def fv_simple(pv: float, r: float, n: int):\n    return (1+r*n)*pv\n\ndef pv_simple(fv: float, r: float, n: int):\n    return fv \/ (1 + r * n)\n    \ndef r_simple(pv: float, fv: float, n: int):\n    return (fv\/pv - 1) \/  n","8e7ece11":"fv = fv_simple(starting_capital, r, n)\nfv","af4d342e":"pv = pv_simple(fv, r, n)\npv","82d402dc":"r_simple(pv, fv, n)","687cf852":"def fv_compound(pv, r: float, n: int):\n    return pv * (1+r)**n\n\ndef pv_compound(fv: float, r: float, n: int):\n    return fv \/ (1 + r)**n\n\ndef r_compound(pv: float, fv: float, n: int):\n    return (fv\/pv)**(1\/n) - 1","01b1b381":"fv = fv_compound(starting_capital, r, n)\nfv","a21a9f6c":"pv = pv_compound(fv, r, n)\npv","85ad72e3":"r_compound(pv, fv, n)","92daf728":"m = 12 # Monthly compounding","6e38803c":"def fv_interval(pv: float, r: float, n: int, m: int):\n    return ((1 + r \/ m)**(m * n)) * pv\n\ndef pv_interval(fv: float, r: float, n: int, m: int):\n    return fv \/ (1+r\/m)**(m*n)\n\ndef r_interval(pv: float, fv: float, n: int, m: int):\n    return ((fv \/ pv)**(1\/(m*n)) - 1)* m","079a8402":"fv = fv_interval(starting_capital, r, n, m)\nfv","ba26af91":"pv = pv_interval(fv, r, n, m)\npv","86774a90":"r_interval(pv, fv, n, m)","cecfebd3":"def fv_continuous(pv: float, r: float, n: int):\n    return np.exp(r * n) * pv\n\ndef pv_continuous(fv: float, r: float, n: int):\n    return fv \/ np.exp(r * n)\n\ndef r_continuous(pv: float, fv: float, n: int):\n    return np.log(fv\/pv) \/ n","45db8af5":"fv = fv_continuous(starting_capital, r, n)\nfv","8ef65482":"pv = pv_continuous(fv, r, n)\npv","11f2cda3":"r_continuous(pv, fv, n)","1260afbb":"A = 100. # Monthly added deposit","3d0b7995":"def fv_with_deposit(r: float, n: int, m: int, a: float):\n    return (a \/ (r\/m)) * ((1 + r\/m)**(m*n) - 1)\n\ndef pv_with_deposit(r: float, n: int, m: int, a: float):\n    return (a \/ (r\/m)) * (1 - 1 \/ (1 + r \/ m)**(m*n))","d06663a6":"fv = fv_with_deposit(r, n, m, A)\nfv","7f929687":"pv_with_deposit(r, n, m, A)","cd949aba":"var = 0.2 # Variance\nsigma = np.sqrt(var) # Standard deviation\nS = 44 # Stock price\nK = 45 # Strike price\nT = 2\/12 # Time period (two months = two steps)\nr = 0.06 # Risk-free interest rate\ndelta_t = 1\/12 # time-steps of one month\nR = np.exp(r * delta_t) # Discounted interest\n\nu = np.exp(sigma*np.sqrt(delta_t)) # Up scenario\nd = np.exp(-sigma*np.sqrt(delta_t)) # Down scenario\n\ndef price_binomial(R, Pu, Pd, u, d):\n    \"\"\" Compute option price for a step \"\"\"\n    q = (R-d)\/(u-d)\n    return (1\/R) * (q * Pu + (1-q)*Pd)","63e27a68":"c_ud = np.maximum(0, u * d * S - K)\nc_uu = np.maximum(0, u**2 * S - K)\nc_dd = np.maximum(0, d**2 * S - K)","5f18ed71":"Cu = price_binomial(R, c_uu, c_ud, u, d)\nprint(f\"Option price for 1-step up scenario: {Cu.round(2)}\")","6343cb7a":"Cd = price_binomial(R, c_ud, c_dd, u, d)\nprint(f\"Option price for 1-step down scenario: {Cd.round(2)}\")","75f17c36":"C = price_binomial(R, Cu, Cd, u, d)\nprint(f\"Fair option price given all scenario's: {C.round(2)}\")","86b9d155":"fig = plt.figure(figsize=[16, 8])\nfor i in range(2):\n    x = [1, 0, 1]\n    for j in range(i):\n        x.append(0)\n        x.append(1)\n    x = np.array(x) + i\n    y = np.arange(-(i+1), i+2)[::-1]\n    y = 100 * np.power(u, y)\n    plt.plot(x, y, 'bo-')\n    if i % 2 == 0:\n        for x_pos, y_value in zip(x,y):\n            plt.annotate(y_value.round(2), \n                         (x_pos, y_value), \n                         textcoords=\"offset points\",\n                         xytext=(0, 10), \n                         ha='center', fontsize=20)\nplt.xlabel('Time point t (months)', fontsize=20)\nplt.ylabel('Price (percentage from time t)', fontsize=20)\nplt.xticks([0, 1, 2], fontsize=16)\nplt.title('Two step Binomial lattice - European call option', fontsize=20, weight='bold')\nplt.tight_layout()","b70dd1e6":"class BlackScholes:\n    \"\"\" \n    Class to calculate (European) call and put option prices through the Black-Scholes formula \n    without dividends\n    \n    :param S: Price of underlying stock\n    :param K: Strike price\n    :param T: Time till expiration (in years)\n    :param r: Risk-free interest rate (0.05 indicates 5%)\n    :param sigma: Volatility (standard deviation) of stock (0.15 indicates 15%)\n    \"\"\"\n    @staticmethod\n    def _d1(S, K, T, r, sigma):\n        return (1 \/ (sigma * np.sqrt(T))) * (np.log(S\/K) + (r + sigma**2 \/ 2) * T)\n    \n    def _d2(self, S, K, T, r, sigma):\n        return self._d1(S, K, T, r, sigma) - sigma * np.sqrt(T)\n    \n    def call_price(self, S, K, T, r, sigma):\n        \"\"\" Main method for calculating price of a call option \"\"\"\n        d1 = self._d1(S, K, T, r, sigma)\n        d2 = self._d2(S, K, T, r, sigma)\n        return norm.cdf(d1) * S - norm.cdf(d2) * K * np.exp(-r*T)\n    \n    def put_price(self, S, K, T, r, sigma):\n        \"\"\" Main method for calculating price of a put option \"\"\"\n        d1 = self._d1(S, K, T, r, sigma)\n        d2 = self._d2(S, K, T, r, sigma)\n        return norm.cdf(-d2) * K * np.exp(-r*T) - norm.cdf(-d1) * S\n    \n    def call_in_the_money(self, S, K, T, r, sigma):\n        \"\"\" \n        Calculate probability that call option will be in the money at\n        maturity according to Black-Scholes.\n        \"\"\"\n        d2 = self._d2(S, K, T, r, sigma)\n        return norm.cdf(d2)\n    \n    def put_in_the_money(self, S, K, T, r, sigma):\n        \"\"\" \n        Calculate probability that put option will be in the money at\n        maturity according to Black-Scholes.\n        \"\"\"\n        d2 = self._d2(S, K, T, r, sigma)\n        return 1 - norm.cdf(d2)","dad9b7aa":"S = 44 # Stock price\nK = 45 # Strike price\nT = 2\/12 # Time till expiration (in years)\nr = 0.06 # Risk-free interest rate\nsigma = np.sqrt(0.2) # Volatility (standard deviation)","5fae8629":"BlackScholes().call_price(S, K, T, r, sigma)","ef40cc96":"BlackScholes().put_price(S, K, T, r, sigma)","1ca383c4":"BlackScholes().call_in_the_money(S, K, T, r, sigma)","a3fbc78f":"BlackScholes().put_in_the_money(S, K, T, r, sigma)","8631e8c3":"def call_implied_volatility(price, S, K, T, r):\n    \"\"\" Calculate implied volatility of a call option up to 2 decimals of precision. \"\"\"\n    sigma = 0.0001\n    while sigma < 1:\n        d1 = BlackScholes()._d1(S, K, T, r, sigma)\n        d2 = BlackScholes()._d2(S, K, T, r, sigma)\n        price_implied = S * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2)\n        if price - price_implied < 0.0001:\n            return sigma\n        sigma += 0.0001\n    return \"Not Found\"\n\ndef put_implied_volatility(price, S, K, T, r):\n    \"\"\" Calculate implied volatility of a put option up to 2 decimals of precision. \"\"\"\n    sigma = 0.0001\n    while sigma < 1:\n        call = BlackScholes().call_price(S, K, T, r, sigma)\n        price_implied = K * np.exp(-r*T) - S + call\n        if price - price_implied < 0.0001:\n            return sigma\n        sigma += 0.0001\n    return \"Not Found\"","487715a2":"S = 36 # Stock price\nK = 35 # Strike price\nT = 2\/12 # Time till expiration (in years)\nr = 0.05 # Risk-free interest rate\noption_price = 1.5 # Price of the option that is offered in the market","6978c1d8":"call_imp_vol = call_implied_volatility(option_price, S, K, T, r)\nput_imp_vol = put_implied_volatility(option_price, S, K, T, r)\n\nprint(f\"Implied volatility for call option = {round(call_imp_vol*100, 3)}%\")\nprint(f\"Implied volatility for put option = {round(put_imp_vol*100, 3)}%\")","4ab2acd4":"class OptionStrategies:\n    @staticmethod\n    def short_straddle(S, K, T, r, sigma):\n        call = BlackScholes().call_price(S, K, T, r, sigma)\n        put = BlackScholes().put_price(S, K, T, r, sigma)\n        return - put - call\n    \n    @staticmethod\n    def long_straddle(S, K, T, r, sigma):\n        call = BlackScholes().call_price(S, K, T, r, sigma)\n        put = BlackScholes().put_price(S, K, T, r, sigma)\n        return put + call\n    \n    @staticmethod\n    def short_strangle(S, K1, K2, T, r, sigma):\n        assert K1 < K2, f\"Please make sure that K1 < K2. Now K1={K1}, K2={K2}\"\n        put = BlackScholes().put_price(S, K1, T, r, sigma)\n        call = BlackScholes().call_price(S, K2, T, r, sigma)\n        return - put - call\n    \n    @staticmethod\n    def long_strangle(S, K1, K2, T, r, sigma):\n        assert K1 < K2, f\"Please make sure that K1 < K2. Now K1={K1}, K2={K2}\"\n        put = BlackScholes().put_price(S, K1, T, r, sigma)\n        call = BlackScholes().call_price(S, K2, T, r, sigma)\n        return put + call\n    \n    @staticmethod\n    def short_put_butterfly(S, K1, K2, K3, T, r, sigma):\n        assert K1 < K2 < K3, f\"Please make sure that K1 < K2 < K3. Now K1={K1}, K2={K2}, K3={K3}\"\n        put1 = BlackScholes().put_price(S, K1, T, r, sigma)\n        put2 = BlackScholes().put_price(S, K2, T, r, sigma)\n        put3 = BlackScholes().put_price(S, K3, T, r, sigma)\n        return - put1 + 2 * put2 - put3\n    \n    @staticmethod\n    def long_call_butterfly(S, K1, K2, K3, T, r, sigma):\n        assert K1 < K2 < K3, f\"Please make sure that K1 < K2 < K3. Now K1={K1}, K2={K2}, K3={K3}\"\n        call1 = BlackScholes().call_price(S, K1, T, r, sigma)\n        call2 = BlackScholes().call_price(S, K2, T, r, sigma)\n        call3 = BlackScholes().call_price(S, K3, T, r, sigma)\n        return call1 - 2 * call2 + call3\n    \n    @staticmethod\n    def short_iron_condor(S, K1, K2, K3, K4, T, r, sigma):\n        assert K1 < K2 < K3 < K4, f\"Please make sure that K1 < K2 < K3 < K4. Now K1={K1}, K2={K2}, K3={K3}, K4={K4}\"\n        put1 = BlackScholes().put_price(S, K1, T, r, sigma)\n        put2 = BlackScholes().put_price(S, K2, T, r, sigma)\n        call1 = BlackScholes().call_price(S, K3, T, r, sigma)\n        call2 = BlackScholes().call_price(S, K4, T, r, sigma)\n        return put1 - put2 - call1 + call2\n    \n    @staticmethod\n    def long_iron_condor(S, K1, K2, K3, K4, T, r, sigma):\n        assert K1 < K2 < K3 < K4, f\"Please make sure that K1 < K2 < K3 < K4. Now K1={K1}, K2={K2}, K3={K3}, K4={K4}\"\n        put1 = BlackScholes().put_price(S, K1, T, r, sigma)\n        put2 = BlackScholes().put_price(S, K2, T, r, sigma)\n        call1 = BlackScholes().call_price(S, K3, T, r, sigma)\n        call2 = BlackScholes().call_price(S, K4, T, r, sigma)\n        return - put1 + put2 + call1 - call2","bbe655ee":"T = 2\/12 # Time till expiration (in years)\nr = 0.05 # Risk-free interest rate\nsigma = np.sqrt(1\/68) # Volatility (standard deviation)\nend_prices = np.arange(5, 65, 1) # Possible scenarios for underlying stock price at expiration.","6dab03b3":"K1 = 35 # Strike price\nstraddle_payoffs = [OptionStrategies.long_straddle(S, K1, T, r, sigma) for S in end_prices]\nplt.plot(end_prices, straddle_payoffs)\nplt.xlabel('End Stock prices S')\nplt.ylabel('Payoff')\nplt.title(f'T={round(T, 2)}, r={r}, sigma={round(sigma, 4)}')\nplt.suptitle('Payoff function Black-Scholes using long straddle', weight='bold', fontsize=12);","3e9f5f17":"K1, K2 = 25, 45 # Strike prices\nstrangle_payoffs = [OptionStrategies.long_strangle(S, K1, K2, T, r, sigma) for S in end_prices]\nplt.plot(end_prices, strangle_payoffs)\nplt.xlabel('End Stock prices S')\nplt.ylabel('Payoff')\nplt.title(f'T={round(T, 2)}, r={r}, sigma={round(sigma, 4)}')\nplt.suptitle('Payoff function Black-Scholes using long strangle', weight='bold', fontsize=12);","23dc9a94":"K1, K2, K3 = 25, 35, 45 # Strike prices\nbutterfly_payoffs = [OptionStrategies.long_call_butterfly(S, K1, K2, K3, T, r, sigma) for S in end_prices]\nplt.plot(end_prices, butterfly_payoffs)\nplt.xlabel('End Stock prices S')\nplt.ylabel('Payoff')\nplt.title(f'T={round(T, 2)}, r={r}, sigma={round(sigma, 4)}')\nplt.suptitle('Payoff function Black-Scholes using long call butterfly', weight='bold', fontsize=12);","eb66538d":"K1, K2, K3, K4 = 20, 25, 45, 50 # Strike prices\niron_condor_payoffs = [OptionStrategies.long_iron_condor(S, K1, K2, K3, K4, T, r, sigma) for S in end_prices]\nplt.plot(end_prices, iron_condor_payoffs)\nplt.xlabel('End Stock prices S')\nplt.ylabel('Payoff')\nplt.title(f'T={round(T, 2)}, r={r}, sigma={round(sigma, 4)}')\nplt.suptitle('Payoff function Black-Scholes using long iron condor', weight='bold', fontsize=12);","624459bb":"def payoff_function(end_prices: np.ndarray, K: int, T: float, r: float, sigma: float, \n                    alpha: int = 3, beta: int = 1):\n    \"\"\" Some crazy custom payoff function \"\"\"\n    call_prices = np.array([BlackScholes().call_price(s, K, T, r, sigma) for s in end_prices])\n    put_prices = np.array([BlackScholes().put_price(s, K, T, r, sigma) for s in end_prices])\n    return alpha * call_prices**(alpha*put_prices) \/ (beta + put_prices)**(beta*call_prices)\n  \nK = 35 # Strike price\nT = 1 # Time till expiration (in years)\nr = 0.05 # Risk-free interest rate\nend_prices = np.arange(30, 50, 0.1)\npayoffs = payoff_function(end_prices, S, T, r, sigma)","186e67cf":"plt.plot(end_prices, payoffs)\nplt.xlabel('End Stock price S')\nplt.ylabel('Payoff')\nplt.title(f'K={K}, T={round(T, 2)}, r={r}, sigma={round(sigma, 4)}')\nplt.suptitle('Payoff function Black-Scholes using custom payoff function', weight='bold', fontsize=12);","cc38e8ee":"# Characteristics of portfolio\ninitial_investment = 100_000\nportfolio_mean = 0.2 # Average Returns\nportfolio_std = np.sqrt(0.044) # Standard deviation of portfolio\n\n# Compute statistics for portfolio\nmean_investment = (1 + portfolio_mean) * initial_investment\nstd_investment = portfolio_std * initial_investment\n\n# Cutoff point in distribution for several confidence intervals (95%, 98% and 99%)\ncutoff1 = norm.ppf(0.05, mean_investment, std_investment)\ncutoff2 = norm.ppf(0.02, mean_investment, std_investment)\ncutoff3 = norm.ppf(0.01, mean_investment, std_investment)\n\n# Calculate VaR for several confidence intervals\nVaR5 = initial_investment - cutoff1\nVaR2 = initial_investment - cutoff2\nVaR1 = initial_investment - cutoff3","62997354":"print(f\"The total value at risk (VaR) with 95% confidence is: {VaR5.round(2)}\")\nprint(f\"The total value at risk (VaR) with 98% confidence is: {VaR2.round(2)}\")\nprint(f\"The total value at risk (VaR) with 99% confidence is: {VaR1.round(2)}\")","a252f729":"def downside_risk(drift, r, sigma, t):\n    \"\"\" Calculate the approximate downside risk. \"\"\"\n    delta = (drift - r) \/ sigma * np.sqrt(t)\n    return sigma * np.sqrt((1 + delta**2) * norm.cdf(-delta) - delta * norm.pdf(delta)) ","7d647c34":"sigma = 1\/68\nr = 0.05\ndrift = r - 0.5 * sigma**2\nt = 1","bdd00573":"dr = downside_risk(drift, r, sigma, t)\nprint(f\"The downside risk is: {round(dr*100, 4)}%\")","8f3a9480":"class BlackScholesGreeks:\n    \"\"\" \n    Class to calculate (European) call and put option greeks.\n    \n    :param S: Price of underlying stock\n    :param K: Strike price\n    :param T: Time till expiration (in years)\n    :param r: Risk-free interest rate (0.05 indicates 5%)\n    :param sigma: Volatility (standard deviation) of stock (0.15 indicates 15%)\n    :param q: The annual dividend yield of a stock\n    \"\"\"\n    @staticmethod\n    def _d1(S, K, T, r, sigma):\n        return (1 \/ (sigma * np.sqrt(T))) * (np.log(S\/K) + (r + sigma**2 \/ 2) * T)\n    \n    def _d2(self, S, K, T, r, sigma):\n        return self._d1(S, K, T, r, sigma) - sigma * np.sqrt(T)\n    \n    def call_delta(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        return norm.cdf(d1)\n    \n    def call_gamma(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        return norm.pdf(d1) \/ (S * sigma * np.sqrt(T))\n    \n    def call_vega(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        return S * norm.pdf(d1) * np.sqrt(T)\n    \n    def call_theta(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        d2 = self._d2(S, K, T, r, sigma)\n        return - ((S * norm.pdf(d1) * sigma) \/ (2 * np.sqrt(T))) - r * K * np.exp(-r*T) * norm.cdf(d2)\n    \n    def call_rho(self, S, K, T, r, sigma):\n        d2 = self._d2(S, K, T, r, sigma)\n        return K * T * np.exp(-r*T) * norm.cdf(d2)\n    \n    def call_lambda(self, S, K, T, r, sigma):\n        delta = self.call_delta(S, K, T, r, sigma)\n        return delta * (S \/ V)\n    \n    def call_epsilon(self, S, K, T, r, sigma, q):\n        d1 = self._d1(S, K, T, r, sigma)\n        return -S * T * np.exp(-q*T) * norm.cdf(d1)\n    \n    def put_delta(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        return norm.cdf(d1) - 1\n    \n    def put_gamma(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        return norm.pdf(d1) \/ (S * sigma * np.sqrt(T))\n    \n    def put_vega(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        return S * norm.pdf(d1) * np.sqrt(T)\n    \n    def put_theta(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        d2 = self._d2(S, K, T, r, sigma)\n        return - ((S * norm.pdf(d1) * sigma) \/ (2 * np.sqrt(T))) + r * K * np.exp(-r*T) * norm.cdf(-d2)\n    \n    def put_rho(self, S, K, T, r, sigma):\n        d2 = self._d2(S, K, T, r, sigma)\n        return - K * T * np.exp(-r*T) * norm.cdf(-d2)\n    \n    def put_lambda(self, S, K, T, r, sigma):\n        delta = self.put_delta(S, K, T, r, sigma)\n        return delta * (S \/ V)\n    \n    def put_epsilon(self, S, K, T, r, sigma, q):\n        d1 = self._d1(S, K, T, r, sigma)\n        return S * T * np.exp(-q*T) * norm.cdf(-d1)\n    \n    def vanna(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        d2 = self._d2(S, K, T, r, sigma)\n        return norm.pdf(d1) * d2 \/ sigma\n    \n    def charm(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        d2 = self._d2(S, K, T, r, sigma)\n        return -norm.pdf(d1) * ((2 * r * T - d2 * sigma * np.sqrt(T)) \/ (2 * T * sigma * np.sqrt(T)))\n    \n    def vomma(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        d2 = self._d2(S, K, T, r, sigma)\n        return S * norm.pdf(d1) * np.sqrt(T) * ((d1 * d2) \/ sigma)\n    \n    def veta(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        d2 = self._d2(S, K, T, r, sigma)\n        return -S * norm.pdf(d1) * np.sqrt(T) * (r * d1 \/ (sigma * np.sqrt(T)) - (1 + d1 * d2) \/ (2 * T))\n    \n    def zomma(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        d2 = self._d2(S, K, T, r, sigma)\n        return norm.pdf(d1) * (d1*d2 - 1) \/ (S * sigma**2 * np.sqrt(T))\n    \n    def color(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        d2 = self._d2(S, K, T, r, sigma)\n        return norm.pdf(d1) \/ (2*S*T*sigma*np.sqrt(T)) * (2*T + 1 + ((2*r*T - d2*sigma*np.sqrt(T)) \/ sigma*np.sqrt(T)) * d1)\n    \n    def ultima(self, S, K, T, r, sigma):\n        d1 = self._d1(S, K, T, r, sigma)\n        d2 = self._d2(S, K, T, r, sigma)\n        vega = self.call_vega(S, K, T, r, sigma)\n        return -vega\/sigma**2 * (d1 * d2 * (1-d1*d2) + d1**2 + d2**2)","0fa386ed":"S = 36 # Stock price\nK = 35 # Strike price\nT = 2\/12 # Time till expiration (in years)\nr = 0.05 # Risk-free interest rate\nsigma = np.sqrt(1\/68) # Volatility (standard deviation)","a00fbde1":"print(\"----- Call option -----\")\nprint(f\"Delta: {BlackScholesGreeks().call_delta(S, K, T, r, sigma)}\")\nprint(f\"Gamma: {BlackScholesGreeks().call_gamma(S, K, T, r, sigma)}\")\nprint(f\"Vega: {BlackScholesGreeks().call_vega(S, K, T, r, sigma)}\")\nprint(f\"Theta: {BlackScholesGreeks().call_theta(S, K, T, r, sigma)}\")\nprint(f\"Rho: {BlackScholesGreeks().call_rho(S, K, T, r, sigma)}\")","d441f940":"print(\"----- Put option -----\")\nprint(f\"Delta: {BlackScholesGreeks().put_delta(S, K, T, r, sigma)}\")\nprint(f\"Gamma: {BlackScholesGreeks().put_gamma(S, K, T, r, sigma)}\")\nprint(f\"Vega: {BlackScholesGreeks().put_vega(S, K, T, r, sigma)}\")\nprint(f\"Theta: {BlackScholesGreeks().put_theta(S, K, T, r, sigma)}\")\nprint(f\"Rho: {BlackScholesGreeks().put_rho(S, K, T, r, sigma)}\")","32ff042c":"q = 0.05 # 5% annual dividend yield","8f95608c":"print(f\"Call epsilon: {BlackScholesGreeks().call_epsilon(S, K, T, r, sigma, q)}\")\nprint(f\"Put epsilon: {BlackScholesGreeks().put_epsilon(S, K, T, r, sigma, q)}\")\nprint(f\"Vanna: {BlackScholesGreeks().vanna(S, K, T, r, sigma)}\")\nprint(f\"Charm: {BlackScholesGreeks().charm(S, K, T, r, sigma)}\")\nprint(f\"Vomma: {BlackScholesGreeks().vomma(S, K, T, r, sigma)}\")\nprint(f\"Veta: {BlackScholesGreeks().veta(S, K, T, r, sigma)}\")\nprint(f\"Zomma: {BlackScholesGreeks().zomma(S, K, T, r, sigma)}\")\nprint(f\"Color: {BlackScholesGreeks().color(S, K, T, r, sigma)}\")\nprint(f\"Ultima: {BlackScholesGreeks().ultima(S, K, T, r, sigma)}\")","e628265e":"class BlackScholesDividend:\n    \"\"\" \n    Class to calculate (European) call and put option prices through the Black-Scholes formula \n    with dividends\n    \n    :param S: Price of underlying stock\n    :param K: Strike price\n    :param T: Time till expiration (in years)\n    :param r: Risk-free interest rate (0.05 indicates 5%)\n    :param sigma: Volatility (standard deviation) of stock (0.15 indicates 15%)\n    :param q: Annual dividend yield (0.05 indicates 5%)\n    \"\"\"\n    @staticmethod\n    def _d1(S, K, T, r, sigma, q):\n        return (1 \/ (sigma * np.sqrt(T))) * (np.log(S * np.exp(-q*T) \/ K) + (r + sigma**2 \/ 2) * T)\n    \n    def _d2(self, S, K, T, r, sigma, q):\n        return self._d1(S, K, T, r, sigma, q) - sigma * np.sqrt(T)\n    \n    def call_price(self, S, K, T, r, sigma, q):\n        \"\"\" Main method for calculating price of a call option \"\"\"\n        d1 = self._d1(S, K, T, r, sigma, q)\n        d2 = self._d2(S, K, T, r, sigma, q)\n        return norm.cdf(d1) * S * np.exp(-q*T) - norm.cdf(d2) * K * np.exp(-r*T)\n    \n    def put_price(self, S, K, T, r, sigma, q):\n        \"\"\" Main method for calculating price of a put option \"\"\"\n        d1 = self._d1(S, K, T, r, sigma, q)\n        d2 = self._d2(S, K, T, r, sigma, q)\n        return norm.cdf(-d2) * K * np.exp(-r*T) - norm.cdf(-d1) * S * np.exp(-q*T)\n    \n    def call_in_the_money(self, S, K, T, r, sigma, q):\n        \"\"\" \n        Calculate probability that call option will be in the money at\n        maturity according to Black-Scholes.\n        \"\"\"\n        d2 = self._d2(S, K, T, r, sigma, q)\n        return norm.cdf(d2)\n    \n    def put_in_the_money(self, S, K, T, r, sigma, q):\n        \"\"\" \n        Calculate probability that put option will be in the money at\n        maturity according to Black-Scholes.\n        \"\"\"\n        d2 = self._d2(S, K, T, r, sigma, q)\n        return 1 - norm.cdf(d2)","fac5a27f":"S = 44 # Stock price\nK = 45 # Strike price\nT = 2\/12 # Time till expiration (in years)\nr = 0.06 # Risk-free interest rate\nsigma = np.sqrt(0.2) # Volatility (standard deviation)\nq = 0.05 # Annual dividend yield","8c7846a9":"BlackScholesDividend().call_price(S, K, T, r, sigma, q)","a617cfa7":"BlackScholesDividend().put_price(S, K, T, r, sigma, q)","ac402cec":"S = 36 # Stock price\nK = 35 # Strike price\nT = 2\/12 # Time till expiration (in years)\nr = 0.05 # Risk-free interest rate\nsigma = np.sqrt(1\/68) # Volatility (standard deviation)","efaea3bb":"from scipy.special import ndtr\n\ndef _d1(S, K, T, r, sigma):\n    return (1 \/ (sigma * np.sqrt(T))) * (np.log(S\/K) + (r + sigma**2 \/ 2) * T)\n    \ndef _d2(S, K, T, r, sigma):\n    return _d1(S, K, T, r, sigma) - sigma * np.sqrt(T)\n    \ndef fast_theta(S, K, T, r, sigma):\n    d1 = _d1(S, K, T, r, sigma)\n    d2 = _d2(S, K, T, r, sigma)\n    return - ((S * norm.pdf(d1) * sigma) \/ (2 * np.sqrt(T))) - r * K * np.exp(-r*T) * ndtr(d2)","8fc51eb0":"bsg = BlackScholesGreeks()\nbsg.call_theta(S, K, T, r, sigma)","d28a7faf":"%%timeit\nbsg.call_theta(S, K, T, r, sigma)","ce4d0d3f":"fast_theta(S, K, T, r, sigma)","db2ba7bc":"%%timeit\nfast_theta(S, K, T, r, sigma)","1d05f5d3":"def faster_theta(S, K, T, r, sigma):\n    d1 = _d1(S, K, T, r, sigma)\n    d2 = _d2(S, K, T, r, sigma)\n    return - ((S * norm._pdf(d1) * sigma) \/ (2 * np.sqrt(T))) - r * K * np.exp(-r*T) * ndtr(d2)","50b83cfc":"faster_theta(S, K, T, r, sigma)","a2278755":"%%timeit\nfaster_theta(S, K, T, r, sigma)","cfab5d21":"from math import erf\nfrom numba import jit\n\n@jit\ndef pdf_phi(x):\n    \"\"\" PDF of standard normal distribution \"\"\"\n    return np.exp(-x**2\/2) \/ np.sqrt(2*np.pi)\n\n@jit\ndef cdf_phi(x):\n    \"\"\" CDF of standard normal distribution \"\"\"\n    return (1. + erf(x \/ np.sqrt(2.))) \/ 2.\n\n@jit\ndef _d1(S, K, T, r, sigma):\n    return (1 \/ (sigma * np.sqrt(T))) * (np.log(S\/K) + (r + sigma**2 \/ 2) * T)\n    \n@jit\ndef _d2(S, K, T, r, sigma):\n    return _d1(S, K, T, r, sigma) - sigma * np.sqrt(T)\n\n@jit\ndef faster_theta_jit(S, K, T, r, sigma):\n    d1 = _d1(S, K, T, r, sigma)\n    d2 = _d2(S, K, T, r, sigma)\n    return - ((S * pdf_phi(d1) * sigma) \/ (2 * np.sqrt(T))) - r * K * np.exp(-r*T) * cdf_phi(d2)","5da48a2d":"faster_theta_jit(S, K, T, r, sigma)","3ab484c3":"%%timeit\nfaster_theta_jit(S, K, T, r, sigma)","8919f557":"## Value-at-Risk (VaR)","7d1b89e5":"### Compound Interest\n\nThe simple formula above works for the case where we only get interest on the initial investment and does not take into account compound interest. The next equation takes compounding over $n$ periods into account. Note that this leads to a higher return.","c2286aab":"That's it! I hope this notebook gave you a clear overview of core concepts in financial mathematics and quantitative finance!\n\nIf you have any questions or feedback, feel free to comment and\/or upvote the notebook below. You can also contact me on Twitter [@carlolepelaars](https:\/\/twitter.com\/carlolepelaars).","7e51f9ff":"As we will code the concepts from scratch we will use only basic Python libraries:\n\n- NumPy for linear algebra\n- Matplotlib for visualization\n- Scipy for optimization and probability distributions.","d3c6c2d8":"### Advanced: Down the Greek rabbit hole\n\nWhile the five Greeks discussed above are still the core dimensions, further research and the rise in computing power has led us into exploring more complex dimensions. This allows us to hedge a lot more sophistically and develop trading strategies to profit from very specific situations. Here are some of the more obscure Greeks.\n\n#### Lambda\n\nLambda ($\\lambda$) is the percentage change in option value per percentage change in the underlying price, also called gearing.\n\nLambda call = $\\frac{\\partial C}{\\partial S} \\times \\frac{S}{C} = \\Delta \\frac{S}{C}$.\n\nLambda put = $\\frac{\\partial P}{\\partial S} \\times \\frac{S}{P} = \\Delta \\frac{S}{P}$.\n\n#### Epsilon\n\nEpsilon ($\\epsilon$) is the percentage change in option value per percentage change in the underlying dividend yield. It informs us about the risk in our option portfolio regarding changes in dividend yield. \n\nEpsilon call = $\\frac{\\partial C}{\\partial q}$ = $-ST e^{-qT} \\Phi(d_1^{(t)})$\n\nEpsilon put = $\\frac{\\partial P}{\\partial q}$ = $ST e^{-qT} \\Phi(-d_1^{(t)})$\n\n#### Vanna\n\nVanna is the change is Vega per percentage change of the underlying stock price.\n\nVanna = $\\frac{\\partial \\mathcal{C}}{\\partial S}$ = $-\\phi(d_1^{(t)}) \\frac{d_2^{(t)}}{\\sigma}$\n\nVanna is calculated the same for calls and puts.\n\n#### Charm\n\nCharm (delta decay) denotes the rate of change of delta over time.\n\nCharm = $\\frac{\\partial^2 C}{\\partial T \\partial S}$ = $-\\phi(d_1^{(t)}) \\frac{2rT - d_2^{(t)}\\sigma \\sqrt{T}}{2T\\sigma \\sqrt{T}}$\n\nCharm is calculated the same for calls and puts except if dividends are included.\n\n#### Vomma\n\nVomma computes the second order effect of volatility (vega). More clearly, it can be described as \"vega convexity\".\n\nVomma = $\\frac{\\partial^2 C}{\\partial \\sigma^2}$ = $S \\phi(d_1^{(t)})\\sqrt{T}\\frac{d_1^{(t)} d_2^{(t)}}{\\sigma}$ = $\\mathcal{V}\\frac{d_1^{(t)} d_2^{(t)}}{\\sigma}$\n\nSince Vega is the same for calls and puts, the same is the case for Vomma.\n\n#### Veta\n\nVeta shows the rate of change in vega with respect to time.\n\nVeta = $\\frac{\\partial^2 C}{\\partial \\sigma \\partial T}$ = $-S \\phi(d_1^{(t)}) \\sqrt{T} (\\frac{r d_1^{(t)}}{\\sigma \\sqrt{T}} - \\frac{1+d_1^{(t)} d_2^{(t)}}{2 T})$\n\nVeta is calculated the same for calls and puts.\n\n#### Speed\n\nSpeed is the rate of change in Gamma ($\\Gamma$) with respect to changes in underlying asset price. This makes it a third-order effect.\n\n\nSpeed = $\\frac{\\partial^3 C}{\\partial S^3}$ = $\\frac{\\partial \\Gamma}{\\partial S}$ = $\\frac{\\phi(d_1^{(t)})}{S^2 \\sigma \\sqrt{T}}(\\frac{d_1^{(t)}}{\\sigma \\sqrt{T}} + 1)$\n\nIt is calculated the same for calls and puts, since Gamma is also the same for calls and puts.\n\n#### Zomma\n\nZomma measure the rate of change of gamma with respect to change in volatility. Note that this is a third order greek and can be used to monitor the effectiveness of gamma hedging in an option portfolio. \n\nZomma = $\\frac{\\partial^3 C}{\\partial S^2 \\partial \\sigma}$ =  $\\frac{\\partial \\Gamma}{\\partial \\sigma}$ = $\\frac{\\phi(d_1^{(t)})(d_1^{(t)}d_2^{(t)}-1)}{S \\sigma^2 \\sqrt{T}}$\n\nAgain it is calculated the same for calls and puts, since Gamma is also the same for calls and puts.\n\n\n#### Color\n\nColor is gamma's rate of change with respect to time. It can also be thought of the gamma per year.\n\nColor = $\\frac{\\partial^3 C}{\\partial S^2 \\partial T} = \\frac{\\partial \\Gamma}{\\partial T} = \\frac{\\phi(d_1^{(t)})}{2ST\\sigma\\sqrt{T}}[2T + 1 + \\frac{2rT - d_2^{(t)}\\sigma \\sqrt{T}}{\\sigma \\sqrt{T}}d_1^{(t)}]$\n\nIt is calculated the same for calls and puts.\n\n#### Ultima\n\nThe last greek we will discuss, Ultima, is a third order greek on the option volatility. More technically, it measures the sensitivity of vomma with respect to volatility. Recall that Vomma measures the 2nd order effect of volatility and Vega the 1st order effect.\n\nUltima = $\\frac{\\partial^3 C}{\\partial sigma^3} = \\frac{\\partial vomma}{\\partial \\sigma} = \\frac{\\mathcal{V}}{\\sigma^2}[d_1 d_2 (1-d_1 d_2) + d_1^2 + d_2^2]$\n\nVega is the same for call and puts and as Ultima derives its value from Vega it is the same for calls and puts.\n\n----------------------------------------------------------------------------------------\nBelow you will find Python implementations for all the mentioned Greeks.","b5e627c9":"In this example we define drift as $v = r_f - \\frac{1}{2}\\sigma^2$.","ad6f42a5":"Note that the formula is extremely sensitive to the choice of distribution and therefore has limited practical applicability in the noisy world of finance. Do not be fooled by the elegant formulas and precise numbers that VaR and downside risk give. Good risk management is a complex topic in itself, which is outside the scope of this notebook. If you are interested in learning quantitative risk management I can highly recommend [this online course by Pasquale Cirillo](https:\/\/www.youtube.com\/playlist?list=PLgCR5H4IzggHyHw8dalrVHqHAqZfmTeWa).","be9d0580":"The $\\sigma$ for option pricing can be a hard parameter to determine. Taking the standard deviation over a stock price time-series likely does not work well, since it may have gone through changes that made it less or more volatile over time. Taking a short period like a week also is limited since it can grossly underestimate or overestimate future volatility. Maybe we do not even have enough data of the stock price to get a sense of its volatility. \n\nAs a solution we can calculate something called \"implied volatility\". This is the volatility that is implied by the prices of options currently on the market. In other words, implied volatility is what the market expects the volatility to be as expressed in option prices. This seems like a circular argument, but works remarkably well in practice. One of the most popular implied volatility measures is the [VIX](https:\/\/en.wikipedia.org\/wiki\/VIX), which denotes the implied volatility based on [S&P500](https:\/\/en.wikipedia.org\/wiki\/S%26P_500) index options and is also known as the \"fear index\", because it spikes in times of stock market panics and uncertainty.\n\n![](https:\/\/upload.wikimedia.org\/wikipedia\/commons\/5\/51\/CBOE_Volatlity_Index%2C_VIX.png)\n_Figure: VIX index from 2004 to 2020._\n\nTo calculate the implied volatility we compute the Black-Scholes value for several values of $sigma$ and return the value that is closest to the market price that is also given. The implied volatility can be calculated to an artbitrary number of decimals, but here we calculate it up to 2 decimals.","0207cea3":"One of the most fundamental concepts in financial mathematics is interest. A lot of investments are judged on percentage-wise returns and how they compound over time (i.e. build interest on interest). Investments are often compared to a \"risk-free interest rate\" $r_f$. This is the baseline of what we can earn on capital without risking its loss. $r_f$ changes over time and can even become negative as we have seen in recent years. In practice, assets like [US Treasury bonds](https:\/\/en.wikipedia.org\/wiki\/United_States_Treasury_security) are often regarded as risk-free, even though default is technically possible. \n\nTo calculate interest our input parameters are interest rate $r$, Present Value $PV$ and $n$ periods (often expressed in years). With these values we can calculate future value $FV$. \n\nBy rewriting the equation we can also derive $PV$ from $FV$. Lastly, we can derive the needed interest $r$ if we know both the desired $PV$ and $FV$.","d937d490":"# Introduction To Financial Mathematics","802d1cae":"### 2. norm._pdf","690168bc":"**Straddle**\n\nIn a straddle an investor holds a position in both a call option and a put option with the same strike price and expiration date. This allows the investor to profit from volatility regardless of the direction of the underlying asset.\n\nShort Straddle = $-P(K) - C(K)$\n\nLong Straddle = $P(K) + C(K)$\n\n\n**Strangle**\n\nThe strangle is similar to a straddle, but now the call and put option have different strike prices. Again they have the same expiration date. This strategy can be profitable if you have a strong conviction that the underlying asset will have a large movement, but don't want to bet on a particular direction. For the formula's and code we assume that the first strike price is smaller than the second ($K1 < K2$).\n\n\n\nShort Strangle = $-P(K_1) - C(K_2)$\n\nLong Strangle = $P(K_1) + C(K_2)$\n\n\n**Butterfly**\n\nA butterfly is an option strategy where we have a high probability of making a profit while once again not betting on a particular direction. We implement this strategy when we think the future volatility of the underlying asset\nis going to be lower or higher than the implied volatility when long or short respectively. It involves three different strike prices were we assume $K_1 < K_2 < K_3$. Almost always, we also want the option position to be symmetric so this requires that $K_2 - K_1 = K_3 - K_2$.\n\nShort put butterfly = $-P(K_1) + 2*P(K_2) - P(K_3)$\n\nLong call butterfly = $C(K_1) - 2*C(K_2) + C(K_3)$\n\n**Iron condor**\n\nThe iron condor makes use of four different strike prices and can be seen as a strangle variant of the butterfly strategy. We assume that $K_1 < K_2 < K_3 < K_4$ and for symmetry to hold we require that $K_4 - K_3 = K_2 - K_1$\n\nLong iron condor = $P(K_1) - P(K_2) - C(K_3) + C(K_4)$\n\nShort iron condor = $-P(K_1) + P(K_2) + C(K_3) - C(K_4)$\n\n","73813f91":"\n\nLet $dS_t = \\mu S_t dt + \\sigma S_t d W_t$, where $\\mu = 0$ and $\\sigma = \\sigma_t^2 = 1$ (Standard normal distribution), then:\n\n\\begin{equation}\nF(w, t)=t^{\\alpha} e^{\\beta+\\gamma w} \\\\\n\\frac{\\partial F}{\\partial w} = \\gamma  t^{\\alpha}  e^{\\beta+\\gamma  w} = \\gamma F \\\\\n\\frac{\\partial F}{\\partial t} = \\alpha  t^{\\alpha-1}  e^{\\beta+\\gamma  w} = \\alpha \\frac{1}{t} t^{\\alpha}e^{\\beta+\\gamma  w} = \\alpha t^{-1} F\\\\\n\\frac{\\partial^{2} F}{\\partial w^{2}} = \\gamma^{2}t^{\\alpha}  e^{\\beta+\\gamma  w} = \\gamma^{2} F\n\\end{equation}\n\n\n\n\\begin{equation} \n\\begin{split}\ndX_{t} & = dF(w, t) \\\\\n & = (\\mu_{t} \\frac{\\partial F}{\\partial w} + \\frac{\\partial F}{\\partial t} + \\frac{1}{2} \\sigma_{t}^{2}  \\frac{\\partial^{2} F}{\\partial w^{2}}) dt + \\sigma_{t} \\frac{\\partial F}{\\partial w} dW_{t} \\\\\n & = (0 \\frac{\\partial F}{\\partial w} + \\frac{\\partial F}{\\partial t} + \\frac{1}{2}  1   \\frac{\\partial^{2} F}{\\partial w^{2}}) dt + 1 \\frac{\\partial F}{\\partial w} dW_{t} \\\\\n & = (0 + \\alpha t^{-1} F  + \\frac{1}{2}  \\gamma^{2} F) dt + \\gamma F dW_{t} \\\\\n & = (\\alpha t^{-1}  + \\frac{1}{2}  \\gamma^{2})F dt + \\gamma F dW_{t} \\\\\n & = (\\alpha t^{-1}  + \\frac{1}{2}  \\gamma^{2})X_{t} dt + \\gamma X_{t} dW_{t}\n\\end{split}\n\\end{equation}","34279f10":"Financial instruments can get more complex than the trading strategies we just discussed. These products often have daunting names like [Barrier options](https:\/\/www.investopedia.com\/terms\/b\/barrieroption.asp), [Asian options](https:\/\/en.wikipedia.org\/wiki\/Asian_option), [Bermudan options](https:\/\/www.investopedia.com\/terms\/b\/bermuda.asp), [Mountain Range options](https:\/\/www.investopedia.com\/terms\/m\/mountain_range_option.asp#:~:text=Key%20Takeaways-,Mountain%20range%20options%20are%20a%20family%20of%20exotic%20options%20based,individual%20securities%20in%20the%20basket.) and [Structured products](https:\/\/www.investopedia.com\/articles\/optioninvestor\/07\/structured_products.asp). Sometimes investors even feel the need to trade [options on options](https:\/\/www.investopedia.com\/terms\/c\/compoundoption.asp)! As financial wizards we would like to able to do calculations with an arbitrary option strategy. The purpose of this can be for example to increase [leverage](https:\/\/www.investopedia.com\/terms\/l\/leverage.asp) or hedge against specific risks.\n\nLet's say an investment bank has made some crazy financial instrument for you that combines call and put options according to a payoff function $\\alpha C(K)^{\\alpha P(K)}\/(\\beta + P(K))^{C(K)}$ where $\\alpha=3$ and $\\beta=1$. Using Black-Scholes and Python we can set up something to visualize its payoff.","0c7b5e0b":"To get a clearer overview of the binomial lattice we can visualize the tree on which price calculation is based. It also allows us to analyze what returns are assumed for the up and down scenario after a time step.","d161b9b3":"## Trading strategies","4214d024":"If you are interested in learning more about quantitative finance, here are some resources I would recommend you check out.","abceca6e":"## Follow-ups","aab5eda4":"As a simple example we compute the price of a call option based on two steps of one month. This requires us to start at the end of the tree and compute $C_{ud}$ (One up scenario and one down), $C_{uu}$ (Two times down) and $C_{dd}$ (Two times up). These are all the possible scenarios after two time steps. We then use the result to compute $C_u$ and $C_d$, which are all the scenarios after one step. After this we can finally calculate $C$, which denotes the fair price of an option given all possible scenarios. Note that this setup is very simple and does not reflect reality where many other scenarios can happen. Still, the Binomial lattice gives us a good indication on how much an option if worth. Professional option traders will run software with many more time-steps and run the calculations for various values of $u$ and $d$.","a7fd33c9":"You might have noticed that working with Black-Scholes involves computing the cumulative distribution function (CDF) ($\\Phi(.)$) and probability density function (PDF) ($\\phi(.))$ of a standard normal distribution $N(0, 1)$. The library we use for this (scipy.norm) does multiple checks under the hood and can therefore be sped up substantially. We also leverage some other tricks to optimize our calculations.\n\n### 1. scipy.special.ndtr\n\nThe first trick is to replace [norm.cdf](https:\/\/docs.scipy.org\/doc\/scipy\/reference\/generated\/scipy.stats.norm.html) by [scipy.special.ndtr](https:\/\/docs.scipy.org\/doc\/scipy\/reference\/generated\/scipy.special.ndtr.html). ndtr is a function that norm.cdf also calls under the hood, but in this case we skip the datatype checks. Let's take the calculation of a call option's Theta as an example. We compare the run time with our original implementation from the section on The Greeks.","1e17a6cf":"## Interest","3cf36cd4":"## Stochastic differential equation (Wiener process)","3181b496":"By iterating over a range of outcomes we can visualize the payoff for these option strategies in different scenarios.","6f5f44ee":"Value at risk (VaR) expresses how much of our investment we can lose within a given confidence interval, for example 95%. Note that this requires us to assume a probability distibution. Often (log-)normal distributions are used for finance applications. Here we give a simple example if we assume returns are normally distributed using. Note that it can be dangerous to rely on this as often we don't know the exact distribution or parameters of an investment. It is likely that we could lose much more than VaR indicates. VaR can only inform us about ordinary fluctuations of an asset.\n\nFor more information about VaR you can read this series by Investopedia ([Part1](https:\/\/www.investopedia.com\/articles\/04\/092904.asp), [Part2](https:\/\/www.investopedia.com\/articles\/04\/101304.asp)).","3e6e1e9c":"$FV = (1+r)^nPV$\n\n$PV = \\frac{FV}{(1+r)^n}$\n\n$r = \\sqrt[n]{\\frac{FV}{PV}} - 1$","d32b0319":"We can adjust the Black-Scholes formula to account for dividends. Most of the formula will stay the same, but we now have an additional parameter $q$, indicating the annual dividend yield. The Black-Scholes model assumes that the underlying share price drops when a dividend is paid as money is taken out of the underlying business. Therefore, a dividend is discounted by multiplying parts of the formula by $e^{-qT}$.\n\n$S_t$ = Stock price at time $t$, $K$ = Strike price of option, $T$ is time till expiration in years, $r$ = risk-free interest rate $\\sigma$ = standard deviation (i.e. volatility), $q$=Annual dividend yield.\n\n$\\Phi$ is the Cumulative Density Function (CDF) of the standard normal distribution ($N(0, 1)$).\n\n\n$C(S_t, t) = \\Phi(d_1^{(t)})S_t e^{-qT} - \\Phi(d_2^{(t)})Ke^{-rT}$\n\n$P(S_t, t) = \\Phi(-d_2^{(t)})Ke^{-rT} - \\Phi(-d_1^{(t)})S_t e^{-qT}$\n\nwhere $d_1^{(t)} = \\frac{1}{\\sigma \\sqrt{T}}[ln(\\frac{S_t e^{-qT}}{K}) + (r+\\frac{\\sigma^2}{2})T]$\n\n$d_2^{(t)} = d_1^{(t)} - \\sigma \\sqrt{T}$","972f194a":"### 3. JIT compilation with Numba","12588de9":"### Periodic Interest\n\nIn some cases we receive interest more than once a year, for example every month. To take this into account we introduce a parameter $m$ that indicates how many times a year we receive the interest. The higher $m$ is, the faster our investment can compound.","5dc89c2a":"![](https:\/\/memegenerator.net\/img\/instances\/59439515.jpg)","aa305b98":"$C_{ud} = max\\{Sud - K, 0\\}$\n\n$C_{uu} = max\\{Su^2 - K, 0\\}$\n\n$C_{dd} = max\\{Sd^2 - K, 0\\}$","b3d97902":"And that is one last 35x speedup over the last version! Most functions that feature basic operations or a lot of NumPy can be transformed with JIT compilation, but the speedup may not be that large in some cases.","deb028dd":"We will show how you can use Black-Scholes to compute the theoretical probability of an option ending in the money. In the money means the option has a value at expiration. For a call option this means that the underlying stock price $S$ is higher than the strike price $K$ at experition. For a put option the stock price must be lower than the strike price. Note that this measure is solely dependent on the CDF of the Standard Normal distribution $N(0, 1)$.","c92cc484":"### Video material","d5de431b":"$D \\approx \\sigma \\sqrt{(1+\\delta^2)\\Phi(-\\delta) - \\delta\\phi(\\delta)}$\n\nwith $\\mathcal{G}_1 = log(S_t\/S_o)$ and where, $\\Phi{.}$ is the CDF of the standard normal distribution, $\\phi$ the PDF of the standard normal distribution, $\\delta = P_f\\sqrt{t}$ and $P_f=(v - r_f)\/\\sigma$. $v$ denotes drift, $r_f$ the risk-free interest rate, $\\sigma$ the standard deviation and $t$ the time index, which usually denotes years.","5984a55a":"## BONUS: Speeding up option price calculations","38464bbf":"[Patrick Boyle On Finance (Video playlists on Financial Mathematics and awesome finance channel in general)](https:\/\/www.youtube.com\/c\/PatrickBoyleOnFinance)\n\n[Quantatative Risk Management course by Pasquale Cirillo](https:\/\/www.youtube.com\/c\/PatrickBoyleOnFinance)","c3b92f19":"![](https:\/\/i.pinimg.com\/originals\/07\/48\/40\/07484051f93b50545e090eb302f6adc2.jpg)","06d49fcb":"### Straddle","fa3f1669":"$FV = \\frac{A}{r\/m}((1 + \\frac{r}{m})^{mn} - 1)$\n\n$PV = \\frac{A}{r\/m}(1 - \\frac{1}{(1+r\/m)^{mn}})$","d89786f9":"### Payoff function visualizations for trading strategies","fac37623":"Let $W_t$ be a Wiener process at time $t, t \\geq 0$.\n\nFor $t \\geq 0, X_t = t^{\\alpha}e^{\\beta + \\gamma W_t}$, with $\\alpha, \\beta$ and $\\gamma$ as known constants.\n\nWe apply Ito's Lemma to compute the stochastic differential equation $dX_t$.","bb0d13a1":"Probability call is in the money = $\\Phi(d_2^{(t)})$","bfc82d38":"**Textbooks:**\n\nInvestment Science - David Luenberger\n\n[Python for Finance - Yves Hilpisch](https:\/\/www.oreilly.com\/library\/view\/python-for-finance\/9781492024323\/)\n\n**(Auto)biographies:**\n\nMy life as a quant - Emanuel Derman\n\nA Man For All Markets: From Las Vegas to Wall Street, How I Beat the Dealer and the Market - Edward Thorp\n\nThe Man Who Solved The Market: How Jim Simons Launched the Quant Revolution - Gregory Zuckerman","7ba20624":"## Downside Risk","aca9fc92":"### Probability of option ending in the money","000122d9":"$S_t$ = Stock price at time $t$, $K$ = Strike price of option, $T$ is time till expiration in years, $r$ = risk-free interest rate $\\sigma$ = standard deviation (i.e. volatility).\n\n$\\Phi$ denotes the Cumulative Density Function (CDF) of the standard normal distribution ($N(0, 1)$).\n\n\n$C(S_t, t) = \\Phi(d_1^{(t)})S_t - \\Phi(d_2^{(t)})Ke^{-rT}$\n\n$P(S_t, t) = \\Phi(-d_2^{(t)})Ke^{-rT} - \\Phi(-d_1^{(t)})S_t$\n\nwhere $d_1^{(t)} = \\frac{1}{\\sigma \\sqrt{T}}[ln(\\frac{S_t}{K}) + (r+\\frac{\\sigma^2}{2})T]$\n\n$d_2^{(t)} = d_1^{(t)} - \\sigma \\sqrt{T}$","15807b61":"### Continuous Interest\n\nAs $m$ goes to infinity ($\\underset{m \\to \\infty}{lim}$) we encounter the notion of \"continuous compounding\". While this notion sounds abstract, continuous compounding is an important concept for financial theory and models that treat financial time series as continuous.","fba32265":"## Binomial Lattice plotting","1366b8b3":"$C_u = \\frac{1}{R}(q C_{uu} + (1-q)C_{ud})$\n\n$C_d = \\frac{1}{R}(q C_{ud} + (1-q)C_{dd})$\n\n$C = \\frac{1}{R}(q C_{u} + (1-q)C_{d})$\n\n\nwhere $q = \\frac{R - d}{u - d}$ and $R = e^{r \\Delta t}$.","97e15105":"### Simple interest\n\nThe easiest calculations will be for a percentage interest without compounding.\n\n$FV = (1+rn)PV$\n\n$PV = \\frac{FV}{1+rn}$\n\n$r = \\frac{\\frac{FV}{PV} - 1}{n}$","64b51887":"![This](https:\/\/img.memecdn.com\/Flying-Cat_o_24752.jpg)","64f5a963":"### Books","61d7527e":"## The Greeks (Black-Scholes)","2395db07":"### 5 Core Greeks","2c3d7568":"$FV = (1 + \\frac{r}{m})^{mn}PV$\n\n$PV = \\frac{FV}{(1 + \\frac{r}{m})^{mn}}$\n\n$r = (\\sqrt[mn]{\\frac{FV}{PV}} - 1)m$","d0e42945":"Voil\u00e0! An almost 2x speedup. Now we can further speed it up by replacing norm.pdf by norm._pdf. Note that this skips a few checks and we have to take care that our input variables are valid.","031c1a9e":"Black-Scholes is a formula to derive the price of an option based on stochastic calculus. The derivation of the formula can be daunting, so we start first with learning how to apply the formula and express it as Python code.\n\nIn 1969, [Edward Thorp](https:\/\/en.wikipedia.org\/wiki\/Edward_O._Thorp) discovered what came to be known as Black-Scholes and used it for his investing, but did not publish a paper on it. In 1973, [Fischer Black](https:\/\/en.wikipedia.org\/wiki\/Fischer_Black) and [Myron Scholes](https:\/\/en.wikipedia.org\/wiki\/Myron_Scholes) published their Black-Scholes model. In 1974 it was further formalized and worked out by [Robert C. Merton](https:\/\/en.wikipedia.org\/wiki\/Robert_C._Merton).","20b30593":"![black_scholes](https:\/\/memegenerator.net\/img\/instances\/35989759.jpg)","30b2c102":"The formula's for calculating The Greeks are defined as follows:\n\n$S_t$ = Stock price at time $t$, \n\n$K$ = Strike price of option, \n\n$T$ is time until expiration in years, \n\n$r$ = risk-free interest rate $\\sigma$ = standard deviation (i.e. volatility), \n\n$\\Phi$ is the Cumulative Density Function (CDF) of the standard normal distribution ($N(0, 1)$),\n\n$\\phi$ is the Probability Density Function (PDF) of $N(0, 1)$.\n\n$d_1^{(t)} = \\frac{1}{\\sigma \\sqrt{T}}[ln(\\frac{S_t}{K}) + (r+\\frac{\\sigma^2}{2})T]$\n\n$d_2^{(t)} = d_1^{(t)} - \\sigma \\sqrt{T}$\n\n**Call options (C)**\n\nDelta ($\\Delta$) = $\\frac{\\partial C}{\\partial S} = \\Phi(d_1^{(t)})$\n\nGamma ($\\Gamma$) = $\\frac{\\partial^2 C}{\\partial S^2} = \\frac{\\phi(d_1^{(t)})}{S \\sigma \\sqrt{T}}$\n\nVega ($\\mathcal{V}$) = $\\frac{\\partial C}{\\partial \\sigma} = S \\phi(d_1^{(t)})\\sqrt{T}$\n\nTheta $(\\Theta)$ = $\\frac{\\partial C}{\\partial t} = -\\frac{S\\phi(d_1^{(t)}) \\sigma}{2 \\sqrt{T}} - rKe^{-rT}\\Phi(d_2^{(t)})$\n\nRho ($\\mathrm{P}$) = $\\frac{\\partial C}{\\partial r} = KTe^{-rT}\\Phi(d_2^{(t)})$\n\n**Put options (P)**\n\nDelta ($\\Delta$) = $\\frac{\\partial P}{\\partial S} = \\Phi(d_1^{(t)}) - 1$\n\nGamma ($\\Gamma$) = $\\frac{\\partial^2 P}{\\partial S^2} = \\frac{\\phi(d_1^{(t)})}{S \\sigma \\sqrt{T}}$\n\nVega ($\\mathcal{V}$) = $\\frac{\\partial P}{\\partial \\sigma} = S \\phi(d_1^{(t)})\\sqrt{T}$\n\nTheta $(\\Theta)$ = $\\frac{\\partial P}{\\partial t} = -\\frac{S\\phi(d_1^{(t)}) \\sigma}{2 \\sqrt{T}} - rKe^{-rT}\\Phi(-d_2^{(t)})$\n\nRho ($\\rho$) = $\\frac{\\partial P}{\\partial r} = -KTe^{-rT}\\Phi(-d_2^{(t)})$","7efccd0d":"In the rare case that we have knowledge of the underlying distribution we can compute the downside risk. This would be more informative than VaR, since as prudent investors we are mainly interested in what we can lose in an extreme scenario.\nWe define the downside risk as:","d9c84909":"## Custom payoff function","686ba804":"### Advanced Greeks","75493d07":"And don't forget:","f8121d34":"An option portfolio can have different dimensions of risk exposure which we would like to manage as an option trader. There are a lot of risk dimensions in option portfolio's, but traders tend to focus on 5 core dimensions which are termed \"The Greeks\". They can be described as follows:\n\nDelta $\\Delta$: Rate of change in option price with respect to the underlying stock price (1st derivative). \n\nGamma $\\Gamma$: Rate of change in delta with respect to the underlying stock price (2nd derivative). \n\nVega $\\mathcal{V}$: Rate of change in option price with respect to the volatility ($\\sigma$) of the stock price. The funny thing is Vega is not a Greek letter, but somehow Vega ended up in what people call The Greeks. $\\mathcal{V}$ is actually the Greek letter \"Nu\".\n\nTheta $\\Theta$: Rate of change in option price with respect to time (i.e. time decay). In general the price of an option decreases over time given that all other values stay the same. The speed of this time decay differs based on the characteristics of an option and changes as time progresses.\n\nRho $\\mathrm{P}$: Rate of change in option price with respect to interest rate. This value is often small and not so big of an issue in practice, unless we have long-term options that are already deep in-the-money as changes in interest rate will greatly affect the value of the option.\n\nCalculation of the Greeks differs slightly between call and put options. Gamma and Vega are calculated the same for calls and puts. \n\nTo simplify things we will exclude the influence of annual stock dividends denoted by parameter $q$ (except for the greek Epsilon). The original five Greeks have versions which integrates the dividend yield, but this makes the formulas unnecessarily complex for an introduction. If you want to explore how the core Greeks are calculated with dividends check out https:\/\/en.wikipedia.org\/wiki\/Greeks_(finance).\n\nWe further assume that we calculate the Greeks at time $t=0$. In other words, right as the option is written.","47ed094e":"### Example of deriving stochastic differential equation","c969bb5f":"![](https:\/\/www.azquotes.com\/picture-quotes\/quote-a-99-value-at-risk-calculation-does-not-evaluate-what-happens-in-the-last-one-percent-david-einhorn-134-56-74.jpg)","40b83007":"## Binomial Lattice (European Call option)","54cd8e44":"### Interest with periodic deposit\n\nIn practical scenarios we periodically add money to our investment. This practice is also popularly known as [Dollar-Cost Averaging (DCA)](https:\/\/www.investopedia.com\/terms\/d\/dollarcostaveraging.asp). We define $A$ as the amount we periodically add and augment our periodic interest equation to account for this.","ebb4a278":"### Iron Condor","26382ab1":"![](https:\/\/i.redd.it\/bioues6bwfy31.jpg)","3e336313":"## Implied volatility","c14f63bf":"We have talked a lot about the Black-Scholes model, but not so much about the mathematical justification that led to the formula. It is not crucial that you know the mathematics in order to use Black-Scholes, but it does allow you to think about the formula in a general way and to adapt it to other financial situations. Feel free to skip this part if you are only interested in the code and computing the formula.\n\nAs early as 1900, the French Mathematician [Louis Bachelier](https:\/\/mathshistory.st-andrews.ac.uk\/Biographies\/Bachelier\/) modeled stock movement according to \"[Brownian motion](https:\/\/en.wikipedia.org\/wiki\/Brownian_motion)\", which basically means random. The insight that a stock price can be described by [Geometric Brownian Motion (GBM)](https:\/\/en.wikipedia.org\/wiki\/Geometric_Brownian_motion) as a [Wiener process](https:\/\/en.wikipedia.org\/wiki\/Wiener_process) is the first building block of the Black-Scholes formula. It allows us to set up the following Stochastic Differential equation (SDE):\n\n$dS_t = \\mu S_tdt + \\sigma S_t d W_t$, where $W_t \\sim \\mathcal{N}(0, t)$ is the Wiener process.\n\nThe next important component for the Black-Scholes formula was discovered around 1950 and is called [Ito's lemma](https:\/\/en.wikipedia.org\/wiki\/It%C3%B4%27s_lemma), which allows us to solve an SDE for an Ito process, which is the case for Black-Scholes:\n\nFor an Ito process $dX_t = \\mu S_tdt + \\sigma S_t d W_t$\n\nThrough Ito's lemma, for any twice differentiable function $F(x, t)$, we get\n\n$dF(x,t) = (\\mu \\frac{\\partial F}{\\partial x} + \\frac{\\partial F}{\\partial t} + \\frac{1}{2} \\sigma_t^2 \\frac{\\partial^2 F}{\\partial x^2})dt + \\sigma_t \\frac{\\partial F}{\\partial x} d W_t$.\n\nThe basic Black-Scholes model makes an additional set of assumptions:\n\n1. There are no transaction costs\n2. No dividends are involved\n3. One can easily borrow and lend cash at the risk-free interest rate $r_f$.\n4. One can buy fractions of assets.\n5. There are no restrictions on short selling (like share borrowing costs).\n\nWe now have enough tools to derive SDE's involving Wiener processes. Let's take an example to show the full derivation of some Wiener Process using Ito's Lemma.","858ee843":"Option trading strategies often involve buying and selling options with different strike prices and\/or maturities. Among other things, this allows the investor to bet on the volatility of the underlying asset instead of the direction. Some of the most well-known option strategies are the Straddle, Strangle, Butterfly and Iron Condor.","8e240751":"## Dependencies","a543049d":"## Courses","734fb44e":"We assume for each time-period a stock goes up or down a certain percentage. These movements are defined by $u$ (Up scenario) and $d$ (Down scenario), where $u > 1$ and $d < 1$. How far a stock can move will depend on the volatility $\\sigma$ and the time-period $\\Delta t$.\n\n$u = e^{\\sigma \\sqrt{\\Delta}t}$\n\n$d = e^{-\\sigma \\sqrt{\\Delta}t}$","588cba4b":"![](https:\/\/i.imgflip.com\/242qz3.jpg)","5095bea9":"### Two-step call option price","bd9e81e6":"### Butterfly","e57fe928":"The binomial lattice model simplifies pricing by assuming a stock either goes up or down a certain amount in a time-period. We assume the price of a stock follows a random path. Each node in the lattice will represent the possible stock price at a given point in time. We then recursively compute time-steps until we can compute the fair price of an option. Like with interest calculations, everything is discounted over time using a risk-free interest rate $r$.\nThe price will mainly be based on $K$ (Strike price) and $S$ = (Stock price at start)","c357fb85":"## Options","ab95e514":"An substantial speedup! Now for the nerds who have not fallen asleep yet, we can go one step further to compute this thing in a few hundred nanoseconds. Note that we use a lot of NumPy function and basic operations in our calculation. Therefore, we can leverage [just in time (JIT) compilation with Numba](http:\/\/numba.pydata.org\/) to speed up the computation. This requires us to reimplement the Scipy functions from scratch.","f84c0d10":"[Udacity - Machine Learning for Trading](https:\/\/www.udacity.com\/course\/machine-learning-for-trading--ud501)\n\n[Udacity - Artifial Intelligence for trading (paid Nanodegree program)](https:\/\/www.udacity.com\/course\/ai-for-trading--nd880)","bd01da24":"## Black-Scholes","8ba424ba":"Probability put is in the money = $1 - \\Phi(d_2^{(t)})$","1a661a89":"An option is a financial derivative that gives you the right, but not the obligation, to buy some underlying asset like a stock.\n\nDerivatives are financial products that derive their value based on some underlying asset. Common parameters that are important for this valuation are:\n- Underlying asset price\n- Volatility of underlying asset (standard deviation)\n- Time until expiration of derivative\n- Strike price (A cut-off value for option that are introduced in the following sections)\n- Risk-free interest rate\n\nIn this notebook we will analyze European options, which give the buyer the right to buy or sell a certain stock for a given price on a certain date. An option for buying is called a [Call option](https:\/\/www.investopedia.com\/terms\/c\/calloption.asp). The right to sell is called a [Put option](https:\/\/www.investopedia.com\/terms\/p\/putoption.asp). ","5ed5723e":"### Strangle","a8fdd5ec":"## Option pricing with dividends","2fa869df":"There are two popular ways to determine the price of an option:\n1. Binomial Lattice\n2. Black-Scholes\n\nThe mathematics and calculation of Black-Scholes is more involved so we start with explaining how a binomial lattice works.","6f7338b9":"$FV = e^{rn}PV$\n\n$PV = \\frac{FV}{e^{rn}}$\n\n$r = \\frac{ln(\\frac{FV}{PV})}{n}$","d4f015ac":"This notebook will give you an introduction into core concepts in financial mathematics, along with formulas and Python implementations. You will learn how to calculate (compound) interest, price options, option trading strategies, option portfolio hedging and basic risk management calculations. Some concepts will look complex at first, but become clear once you learn the intuition behind it and compare the formulas to the code. Let's dive into financial mathematics!\n\n![](https:\/\/memegenerator.net\/img\/instances\/81277641.jpg)"}}