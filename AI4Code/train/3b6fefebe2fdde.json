{"cell_type":{"0f0504b2":"code","f7ae366e":"code","73ba211d":"code","72d78511":"code","0aca95d6":"code","41879d30":"code","a11b570a":"code","a98b9e87":"code","febef48c":"markdown","4477a2f1":"markdown","a1b93f67":"markdown","a2199094":"markdown","f5e4a6a2":"markdown","e601c96f":"markdown","8fc4e82a":"markdown","a567bc6e":"markdown","e3c51f90":"markdown"},"source":{"0f0504b2":"# Imports von Numpy sowie PIL (zum Einlesen von Bildern) und Matplotlib (zum Plotten)\nimport numpy as np\nfrom PIL import Image\nimport matplotlib.pyplot as plt\n\n# Lese ein Bild als Numpy-Array ein\ndef read_jpg(path):\n    return np.asarray(Image.open(path))\n\ndef plot(X):\n    plt.imshow(X, cmap=plt.cm.gray, vmin=0, vmax=255)\n    plt.show()\n\nX = read_jpg('\/kaggle\/input\/d\/aulges\/potterfaces\/faces.png')\nplot(X)\n\nnp.shape(X)\nH,W,_ = np.shape(X)","f7ae366e":"Xgray = np.mean(X, axis = 2)\nplot(Xgray)\nnp.shape(Xgray)","73ba211d":"Xgray_mini = Xgray[::2,::2]\nplot(Xgray_mini)","72d78511":"h, w = H \/\/ 4, W \/\/ 7\nharry = X[:h,:w]\nplot(harry)","0aca95d6":"def get_face(i,j):\n    return Xgray[i*h : (i*h + h), j*w : (j*w + w)]\n    \nplot(get_face(0,6))","41879d30":"Xgray_array = []\n\n\nfor row in range(4):\n    for col in range(7):\n        Xgray_array.append(get_face(row,col))\n\nXgray_array = np.array(Xgray_array)\n\nXgray_a = np.array([get_face(row,col) for row in range(4) for col in range(7)])\n        \nplot(Xgray_array[2,:,:])","a11b570a":"for j in range(28):\n    img = Xgray_a[j]\n    _min = img.min()\n    _max = img.max()\n    img2 = 255 * (img - _min) \/ (_max - _min)\n    plot(np.hstack([img, img2]))","a98b9e87":"Xpop = ((X > 127) * 255).astype('uint8')","febef48c":"## 4. Harry ausschneiden\nZur\u00fcck zum Ausgangs-Farbbild X: Links oben befindet sich das Bild von Harry. Benutzen Sie **Slicing** das Bild von Harry aus und plotten sie es.","4477a2f1":"## 8. Pop Art\nZuletzt **binarisieren** wir das Ausgangsbild X. Setzen Sie hierzu jeden Farbwert > 127 auf 255 (wei\u00df) und jeden Pixelwert <= 127 auf 0 (schwarz). Plotten Sie das resultierende Bild.\n\n*Hinweis: Auch boolesche Operatoren wie '>' k\u00f6nnen Sie direkt auf alle Pixel des Bildes anwenden!*","a1b93f67":"## 2. Bild in Grauwert-Bild verwandeln\nVerwandeln Sie das (dreidimensionale) Ausgangsbild X nun in ein zweidimensionales Grauwertbild Xgray, indem Sie die Werte der drei Farbkan\u00e4le mitteln.\n*Hinweis: Numpy bietet hierf\u00fcr eine n\u00fctzliche Funktion <a href=\"https:\/\/numpy.org\/doc\/stable\/reference\/generated\/numpy.mean.html?highlight=mean#numpy.mean\">mean()<\/a>.*","a2199094":"## 1. Bild einlesen\nDigitale Farbbilder sind in Numpy dreidimensionale Arrays mit den Dimensionen *(H\u00f6he,Breite,3)*. Die letzte Dimension entspricht den drei Farbkan\u00e4len Rot, Gr\u00fcn und Blau. Die einzelnen Pixelwerte liegen zwischen 0 (dunkel) und 255 (hell). \nDer folgende Code liest ein Bild ein und plottet es. Das Bild zeigt 28 Gesichter aus den Harry-Potter-Filmen.\n\nBestimmen Sie die Breite und H\u00f6he des Bildes mittels der **shape** des Numpy-Arrays X.","f5e4a6a2":"## 3. Bild kleiner machen\nErstellen Sie ein kleineres Bild *Xgray_mini*, indem Sie nur jedes zweite Pixel in x- und y-Richtung verwenden.\n\n*Hinweis: Slicing besitzt einen dritten Parameter, die Schrittweite: z.B. w\u00e4hlt array[5:18:3] jedes dritte Element des Arrays zwischen 5 und 18.*","e601c96f":"## 7. Kontrastverst\u00e4rkung\nManche der Gesichter sind ziemlich dunkel.oder grau-in-grau. Wir wollen die Bilder deshalb kontrastverst\u00e4rken: \n\n* Duchlaufen Sie die einzelnen Gesichter.\n* Ermitteln Sie f\u00fcr jedes Gesicht das Minimum und Maximum (siehe die Numpy-Funktionen <a href=\"https:\/\/numpy.org\/doc\/stable\/reference\/generated\/numpy.ndarray.min.html\">min()<\/a> und max()).\n* Skalieren Sie die einzelnen Pixelwerte linear, so dass der maximale Wert hinterher 255 und der minimale Wert 0 betr\u00e4gt. \n* Plotten Sie das Vorher-Bild neben dem kontrastverst\u00e4rkten Nachher-Bild. F\u00fcr welche Gesichter bemerken Sie einen Unterschied?\n\n*Hinweis: Sie m\u00fcssen die Pixel nicht einzeln durchlaufen: Rechnen Sie z.B. gray_image = gray_image\/2, halbieren Sie die Werte **aller** Pixel des Bildes!*","8fc4e82a":" # Numpy 101 (mit Harry Potter)\nIn diesem Notebook lernen Sie **numpy** kennen, Pythons m\u00e4chtige Bibliothek f\u00fcr mehrdimensionale Arrays. Numpy bietet allerhand n\u00fctzliche Funktionalit\u00e4t, unter anderem ...\n\n* das kompakte Rechnen mit Vektoren, Matrizen, und generellen \"Tensoren\" (diese werden alle als Numpy-Arrays dargestellt)\n* die Selektion von Daten-Teilbereichen mit \"Slicing\"\n* viele m\u00e4chtige Operationen wie Eigenwertzerlegungen, automatische Optimierer\/L\u00f6ser, etc.","a567bc6e":"## 6. Mosaik in Bildsequenz zerlegen.\nXgray stellt bisher ein Mosaik aus 28 Gesichtern dar. Bauen Sie das Eingabebild Xgray um: Verwandeln Sie es in ein **28 x 131 x 131** - Array. In diesem stellt die vordere Dimension die Anzahl der Gesichter dar, X[j,:,:] ist das Bild des j-ten Gesichts.\n\n*Hinweis: Die obige Methode get_face() bietet sich an...*","e3c51f90":"## 5. Ein beliebiges Subbild ausschneiden\nSchreiben Sie eine Methode *get_face()*, die (gegeben eine Zeile i und eine Spalte j) das zugeh\u00f6rige Subbild, d.h. ein Gesicht unseres Mosaiks, ausw\u00e4hlt. Zum Beispiel sollte get_face(0,0) das Bild von Harry zur\u00fcckliefern, get_face(1,0) das von Dobby, get_face(0,6) das von Dumbledore.\n\nArbeiten Sie ab hier mit dem Grauwertbild Xgray."}}