{"cell_type":{"62fcce7e":"code","2e22b777":"code","9a09e49f":"code","7f933eb8":"code","1cdf05f8":"code","66f833fd":"code","201a9363":"code","4a4bfe2b":"code","31aaf3d0":"code","3b7908d2":"code","11478bdf":"code","c2fd7339":"code","f26e09e9":"code","964e4bc6":"code","0ccc46d1":"code","9546a7b6":"markdown","ebf01013":"markdown","9bed6ff8":"markdown","070c5094":"markdown"},"source":{"62fcce7e":"import pandas as pd\nimport numpy as np\n\nimport scipy.optimize as opt\n\nfrom pathlib import Path\nroot = Path(\"..\/input\/google-smartphone-decimeter-challenge\/\")\n","2e22b777":"def ecef2lla(x, y, z):\n    # x, y and z are scalars or vectors in meters\n    x = np.array([x]).reshape(np.array([x]).shape[-1], 1)\n    y = np.array([y]).reshape(np.array([y]).shape[-1], 1)\n    z = np.array([z]).reshape(np.array([z]).shape[-1], 1)\n\n    a=6378137\n    a_sq=a**2\n    e = 8.181919084261345e-2\n    e_sq = 6.69437999014e-3\n\n    f = 1\/298.257223563\n    b = a*(1-f)\n\n    # calculations:\n    r = np.sqrt(x**2 + y**2)\n    ep_sq  = (a**2-b**2)\/b**2\n    ee = (a**2-b**2)\n    f = (54*b**2)*(z**2)\n    g = r**2 + (1 - e_sq)*(z**2) - e_sq*ee*2\n    c = (e_sq**2)*f*r**2\/(g**3)\n    s = (1 + c + np.sqrt(c**2 + 2*c))**(1\/3.)\n    p = f\/(3.*(g**2)*(s + (1.\/s) + 1)**2)\n    q = np.sqrt(1 + 2*p*e_sq**2)\n    r_0 = -(p*e_sq*r)\/(1+q) + np.sqrt(0.5*(a**2)*(1+(1.\/q)) - p*(z**2)*(1-e_sq)\/(q*(1+q)) - 0.5*p*(r**2))\n    u = np.sqrt((r - e_sq*r_0)**2 + z**2)\n    v = np.sqrt((r - e_sq*r_0)**2 + (1 - e_sq)*z**2)\n    z_0 = (b**2)*z\/(a*v)\n    h = u*(1 - b**2\/(a*v))\n    phi = np.arctan((z + ep_sq*z_0)\/r)\n    lambd = np.arctan2(y, x)\n\n    return phi*180\/np.pi, lambd*180\/np.pi, h\n\ndef calc_haversine(lat1, lon1, lat2, lon2):\n    \"\"\"Calculates the great circle distance between two points\n    on the earth. Inputs are array-like and specified in decimal degrees.\n    \"\"\"\n    RADIUS = 6_367_000\n    lat1, lon1, lat2, lon2 = map(np.radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = np.sin(dlat\/2)**2 + \\\n      np.cos(lat1) * np.cos(lat2) * np.sin(dlon\/2)**2\n    dist = 2 * RADIUS * np.arcsin(a**0.5)\n    return dist","9a09e49f":"collection_name=\"2020-05-29-US-MTV-1\"\nfile_path = Path(f\"train\/{collection_name}\")\nphone = 'Pixel4'\nmeasurement_epoch_time = 1274827487438\n\n# baseline we'll compare our solution against\ndf_baseline = pd.read_csv(root\/\"baseline_locations_train.csv\")\n\n# ground truth to compute methods performance\ndf_groundtruth = pd.read_csv(root\/file_path\/f\"{phone}\/ground_truth.csv\")\n\n# Train df here only contains one collection and one measurement\ndf_train = pd.read_csv(root\/file_path\/f\"{phone}\/{phone}_derived.csv\")\ndf_train = df_train[df_train['millisSinceGpsEpoch'] == measurement_epoch_time] ","7f933eb8":"df_train.head()","1cdf05f8":"# Corrected pseudorange according to data instructions\ndf_train['correctedPrM'] = df_train.apply(\n    lambda r: r.rawPrM + r.satClkBiasM - r.isrbM - r.ionoDelayM - r.tropoDelayM,\n    axis=1\n)\n\n# Time it took for signal to travel\nlight_speed = 299_792_458\ndf_train['transmissionTimeSeconds'] = df_train['correctedPrM'] \/ light_speed","66f833fd":"# Compute true sat positions at arrival time\nomega_e = 7.2921151467e-5\ndf_train['xSatPosMRotated'] = \\\n    np.cos(omega_e * df_train['transmissionTimeSeconds']) * df_train['xSatPosM'] \\\n    + np.sin(omega_e * df_train['transmissionTimeSeconds']) * df_train['ySatPosM']\n    \ndf_train['ySatPosMRotated'] = \\\n    - np.sin(omega_e * df_train['transmissionTimeSeconds']) * df_train['xSatPosM'] \\\n    + np.cos(omega_e * df_train['transmissionTimeSeconds']) * df_train['ySatPosM']\n    \ndf_train['zSatPosMRotated'] = df_train['zSatPosM']","201a9363":"# Uncertainty weight for the WLS method\ndf_train['uncertaintyWeight'] = 1 \/ df_train['rawPrUncM']","4a4bfe2b":"# Set up least squares methods\ndef distance(sat_pos, x):\n    sat_pos_diff = sat_pos.copy(deep=True)\n    \n    sat_pos_diff['xSatPosMRotated'] = sat_pos_diff['xSatPosMRotated'] - x[0]\n    sat_pos_diff['ySatPosMRotated'] = sat_pos_diff['ySatPosMRotated'] - x[1]\n    sat_pos_diff['zSatPosMRotated'] = sat_pos_diff['zSatPosMRotated'] - x[2]\n\n    sat_pos_diff['d'] = sat_pos_diff.apply(\n        lambda r: r.uncertaintyWeight * \n            (np.sqrt((r.xSatPosMRotated**2 + r.ySatPosMRotated**2 + r.zSatPosMRotated**2)) + x[3] - r.correctedPrM),\n        axis=1\n    )\n\n    return sat_pos_diff['d']\n\ndef distance_fixed_satpos(x):\n    return distance(df_train[['xSatPosMRotated', 'ySatPosMRotated', 'zSatPosMRotated', 'correctedPrM', 'uncertaintyWeight']], x)","31aaf3d0":"# Start point for the optimiser\nx0= [0,0,0,0]\n\nopt_res = opt.least_squares(distance_fixed_satpos, x0)\n\n# Optimiser yields a position in the ECEF coordinates\nopt_res_pos = opt_res.x","3b7908d2":"# ECEF position to lat\/long\nwls_estimated_pos = ecef2lla(*opt_res_pos[:3])\nwls_estimated_pos = np.squeeze(wls_estimated_pos)","11478bdf":"val_baseline = df_baseline[\n    (df_baseline.collectionName==collection_name)\n    & (df_baseline.phoneName==phone)\n    & (df_baseline.millisSinceGpsEpoch==measurement_epoch_time)\n].iloc[0]","c2fd7339":"val_groundtruth = df_groundtruth[\n    (df_groundtruth.collectionName==collection_name)\n    & (df_groundtruth.phoneName==phone)\n    & (df_groundtruth.millisSinceGpsEpoch==measurement_epoch_time)\n].iloc[0]","f26e09e9":"print(\"Baseline distance with groundtruth position (m)\")\ncalc_haversine(val_baseline['latDeg'], val_baseline['lngDeg'], val_groundtruth['latDeg'], val_groundtruth['lngDeg'])","964e4bc6":"print(\"Our estimated position (with WLS) distance with groundtruth position (m)\")\ncalc_haversine(wls_estimated_pos[0], wls_estimated_pos[1], val_groundtruth['latDeg'], val_groundtruth['lngDeg'])","0ccc46d1":"# We are ~10meters from the groundtruth like the baseline","9546a7b6":"# Intro\n\nWe 'll simply try to replicate the baseline WLS method so that we can iterate from there\n\nInspirations:\n- https:\/\/www.kaggle.com\/c\/google-smartphone-decimeter-challenge\/discussion\/238583\n- https:\/\/www.kaggle.com\/foreveryoung\/least-squares-solution-from-gnss-derived-data\n- https:\/\/www.telesens.co\/2017\/07\/17\/calculating-position-from-raw-gps-data\/","ebf01013":"# Helper functions (ecef2lla and haversine formulas)","9bed6ff8":"# Apply WLS on one collection and one measurement","070c5094":"###### "}}