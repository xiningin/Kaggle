{"cell_type":{"64503b9b":"code","f7db2a79":"code","5a921347":"code","4b2263c7":"code","84e317d0":"code","b2c95075":"code","d8b20050":"code","e516a29f":"code","af7cae5b":"code","aa8ea0fb":"code","222ba48d":"code","432850d5":"code","84f9bd89":"code","93cae38c":"code","7086d8fa":"code","f74197fe":"code","edf07dc0":"markdown","8e6dc425":"markdown","41e2698b":"markdown","1abaa78a":"markdown","a18e9832":"markdown","abacdd0f":"markdown","fe3e2226":"markdown","39edfc00":"markdown","1e6cccaa":"markdown","c87d925d":"markdown","e39efbb8":"markdown","1417ea5a":"markdown","6f2615a9":"markdown","f977cbd6":"markdown","5e620737":"markdown","02fd0b0e":"markdown","e5f495ce":"markdown"},"source":{"64503b9b":"import warnings\nimport cufflinks\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom keras import optimizers\nfrom keras.layers import Dense\nfrom keras.utils import to_categorical\nfrom keras.models import Sequential, Model\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import train_test_split\n\n%matplotlib inline\nwarnings.filterwarnings(\"ignore\")\ncufflinks.go_offline(connected=True)\n\n# Set seeds to make the experiment more reproducible.\nfrom tensorflow import set_random_seed\nfrom numpy.random import seed\nset_random_seed(0)\nseed(0)","f7db2a79":"train = pd.read_csv('..\/input\/X_train.csv')\nlabels = pd.read_csv('..\/input\/y_train.csv')\ntest = pd.read_csv('..\/input\/X_test.csv')\n\nprint('Train features shape', train.shape)\ndisplay(train.head())\nprint('Train labels shape', labels.shape)\ndisplay(labels.head())\nprint('Test shape', test.shape)\ndisplay(test.head())","5a921347":"train = train.join(labels, on='series_id', rsuffix='_')\ntrain.drop('series_id_', axis=1, inplace=True)\nprint(train.shape)\ndisplay(train.head())","4b2263c7":"f, ax = plt.subplots(figsize=(12, 8))\nax = sns.countplot(y='surface', data=train, palette=\"rocket\", order=reversed(train['surface'].value_counts().index))\nax.set_ylabel(\"Surface type\")\nplt.show()","84e317d0":"group_df = train.groupby(['group_id', 'surface'])['surface'].agg({'surface':['count']}).reset_index()\ngroup_df.columns = ['group_id', 'surface', 'count']\nf, ax = plt.subplots(figsize=(18, 8))\nax = sns.barplot(x=\"group_id\", y=\"count\", data=group_df, palette=\"GnBu_d\")\n\nfor index, row in group_df.iterrows():\n    ax.text(row.name, row['count'], row['surface'], color='black', ha=\"center\", rotation=60)\n    \nplt.show()","b2c95075":"orientation_features = ['orientation_X', 'orientation_Y', 'orientation_Z', 'orientation_W']\ntrain[orientation_features].iplot(kind='histogram', bins=200, subplots=True, shape=(len(orientation_features), 1))\ntrain[orientation_features].iplot(kind='histogram', barmode='overlay', bins=200)\ntrain[orientation_features].iplot(kind='box')","d8b20050":"velocity_features = ['angular_velocity_X', 'angular_velocity_Y', 'angular_velocity_Z']\ntrain[velocity_features].iplot(kind='histogram', bins=200, subplots=True, shape=(len(velocity_features), 1))\ntrain[velocity_features].iplot(kind='histogram', barmode='overlay', bins=200)\ntrain[velocity_features].iplot(kind='box')","e516a29f":"acceleration_features = ['linear_acceleration_X', 'linear_acceleration_Y', 'linear_acceleration_Z']\ntrain[acceleration_features].iplot(kind='histogram', bins=200, subplots=True, shape=(len(acceleration_features), 1))\ntrain[acceleration_features].iplot(kind='histogram', barmode='overlay', bins=200)\ntrain[acceleration_features].iplot(kind='box')","af7cae5b":"target = train['surface']\nn_labels = target.nunique()\nlabels_names = target.unique()\nle = LabelEncoder()\ntarget = le.fit_transform(target.values)\ntarget = to_categorical(target)\ntrain.drop('surface', axis=1, inplace=True)","aa8ea0fb":"features = ['orientation_X', 'orientation_Y', 'orientation_Z', 'orientation_W', \n            'angular_velocity_X', 'angular_velocity_Y', 'angular_velocity_Z', \n            'linear_acceleration_X', 'linear_acceleration_Y', 'linear_acceleration_Z']\n\nX_train, X_val, Y_train, Y_val = train_test_split(train[features], target, test_size=0.2, random_state=0)\nprint('Train shape', X_train.shape)\nprint('Validation shape', X_val.shape)\ndisplay(X_train.head())","222ba48d":"epochs = 70\nbatch = 128\nlr = 0.001\nadam = optimizers.Adam(lr)","432850d5":"model = Sequential()\nmodel.add(Dense(20, activation='relu', input_dim=X_train.shape[1]))\nmodel.add(Dense(20, activation='relu'))\nmodel.add(Dense(n_labels, activation=\"softmax\"))\nmodel.compile(loss='categorical_crossentropy', optimizer=adam)\nmodel.summary()","84f9bd89":"history = model.fit(X_train.values, Y_train, validation_data=(X_val.values, Y_val), epochs=epochs, verbose=2)","93cae38c":"history_pd = pd.DataFrame.from_dict(history.history)\nhistory_pd.iplot(kind='line')","7086d8fa":"cnf_matrix = confusion_matrix(np.argmax(Y_train, axis=1), model.predict_classes(X_train))\ncnf_matrix_norm = cnf_matrix.astype('float') \/ cnf_matrix.sum(axis=1)[:, np.newaxis]\ndf_cm = pd.DataFrame(cnf_matrix_norm, index=labels_names, columns=labels_names)\n\nplt.figure(figsize=(20, 7))\nax = plt.axes()\nax.set_title('Train')\nsns.heatmap(df_cm, annot=True, fmt='.2f', cmap=\"Blues\", ax=ax)\nplt.show()\n\ncnf_matrix = confusion_matrix(np.argmax(Y_val, axis=1), model.predict_classes(X_val))\ncnf_matrix_norm = cnf_matrix.astype('float') \/ cnf_matrix.sum(axis=1)[:, np.newaxis]\ndf_cm = pd.DataFrame(cnf_matrix_norm, index=labels_names, columns=labels_names)\n\nplt.figure(figsize=(20, 7))\nax = plt.axes()\nax.set_title('Validation')\nsns.heatmap(df_cm, annot=True, fmt='.2f', cmap=\"Blues\", ax=ax)\nplt.show()","f74197fe":"predictions = model.predict_classes(test[features].values)\ntest['surface'] = le.inverse_transform(predictions)\ndf = test[['series_id', 'surface']]\ndf = df.groupby('series_id', as_index=False).agg(lambda x:x.value_counts().index[0])\ndf.to_csv('submission.csv', index=False)\ndf.head(10)","edf07dc0":"### Train\/validation split","8e6dc425":"The interesting part here is that \"orientation_Y\" and \"orientation_X\" are far more spread than the other two.","41e2698b":"<h1><center>Deep Learning Helping Navigate Robots<\/center><\/h1>\n<img src=\"https:\/\/storage.googleapis.com\/kaggle-competitions\/kaggle\/13242\/logos\/thumb76_76.png?t=2019-03-12-23-33-31\" width=\"300\"><\/img>\n\n### Dependencies","1abaa78a":"### Model","a18e9832":"### Angular velocity distribution","abacdd0f":"### Load data","fe3e2226":"#### Model confusion matrix","39edfc00":"#### Model loss plot","1e6cccaa":"Here all the angular velocity features seem to be centered around 0, but \"angular_velocity_Y\" is less spread than the others.","c87d925d":"### Surface distribution by \"group_id\"","e39efbb8":"### Join train features with labels","1417ea5a":"### Preprocess the labels","6f2615a9":"### Plotly graphs may take a while to load.\n\n# EDA\n\n## Surface distribution\n- Let's see what's the label distribution of our data","f977cbd6":"### Linear acceleration distribution","5e620737":"### Test predictions","02fd0b0e":"## Features distribution\n- Now would be a good idea to see how each other type of features behavior\n\n### Orientation distribution","e5f495ce":"The linear acceleration features seem to be the most different between itself, all 3 features have different mean and spread."}}