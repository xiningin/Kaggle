{"cell_type":{"a2eddfbe":"code","2f2fa267":"code","da163d63":"code","9e8e12c1":"code","dc09a0da":"code","34db82b8":"code","db38c127":"code","4f9fc3dd":"code","f06c7732":"code","5c178f5d":"code","c61de926":"code","5fdd36fe":"code","8eeef8bc":"markdown","f9e5532a":"markdown","81f3126d":"markdown","043cc4ea":"markdown","87618263":"markdown","ce2c5c85":"markdown","a97b9167":"markdown","6fda9d0f":"markdown","473dab88":"markdown","6008147c":"markdown","303bc17e":"markdown","4d696a25":"markdown","01831c27":"markdown","9a842f9f":"markdown"},"source":{"a2eddfbe":"#This is the basic solution, which does a straightforward comparison.\nimport re\ndef palindrome(string):\n    lowercase = string.lower()\n    punc_stripped = re.sub(\"[\\W_]\", \"\", lowercase)\n    reversed_string = punc_stripped[::-1]\n    return punc_stripped == reversed_string","2f2fa267":"palindromes = [\"eye\", \"_eye\", \"race car\", \"not a palindrome\", \"A man, a plan, a canal. Panama\",\n              \"never odd or even\", \"nope\", \"almostomla\", \"My age is 0, 0 si ega ym.\",\n              \"1 eye for of 1 eye.\", \"0_0 (: \/-\\ :) 0-0\", \"five|\\_\/|four\"]\nfor phrase in palindromes:\n    print(phrase, palindrome(phrase))","da163d63":"# Note that the use of the continue statement tells us to continue\n# with the next iteration of the loop after appropriately skipping\n# non-alphanumeric characters.\ndef efficient_palindrome(string):\n    # Assign pointers for the front and back of the string\n    front = 0\n    back = len(string) - 1\n    # Since the front and back pointers won't always meet in the middle, \n    # use (back > front) as the stopping condition\n    while (back > front):\n        # Increment front pointer if current character isn't alphanumeric\n        if (not string[front].isalnum()):\n            front += 1\n            continue\n        # Decrement back pointer if current character isn't alphanumeric\n        if (not string[back].isalnum()):\n            back -= 1\n            continue\n        # Compare the current pair of characters\n        if (string[front].lower() != string[back].lower()):\n            return False\n        front += 1\n        back -= 1\n    # If the whole string has been compared without returning false, it's a palindrome!\n    return True","9e8e12c1":"for phrase in palindromes:\n    print(phrase, efficient_palindrome(phrase))","dc09a0da":"def convertToRoman(num):\n    # Make a dictionary of digits and their Roman numerals\n    roman_numerals = {1: \"I\", 5: \"V\", 10: \"X\", 50: \"L\", 100: \"C\", 500: \"D\", 1000: \"M\"}\n    # Make an array of the digits by converting to a string and splitting\n    # before converting each digit back into an integer\n    digits = [int(char) for char in str(num)]\n    converted_num = \"\"\n    #Loop through the digits and convert them\n    for i in range(len(digits)):\n        converted_digit = \"\"\n        # Store the current place (current exponent for 10)\n        # E.g. the ones place corresponds to 10^0, the tens to 10^1, etc\n        current_place = len(digits) - (i + 1)\n        if (digits[i] == 4):\n            # Digit converts to the five numeral for the corresponding place, preceded by the one numeral\n            converted_digit = roman_numerals[10**current_place] + roman_numerals[5*10**current_place]\n        elif (5 <= digits[i] <= 8):\n            # Digit converts to the five numeral for the corresponding place, followed by the one numeral repeated up to three times\n            converted_digit = roman_numerals[5*10**current_place] + roman_numerals[10**current_place]*(digits[i] - 5)\n        elif (digits[i] == 9):\n            # Digit converts to the one numeral for the next place, preceded by the one numeral for the corresponding place\n            converted_digit = roman_numerals[10**current_place] + roman_numerals[10**(current_place + 1)]\n        else:\n            # Digit converts to the one numeral for the corresponding place, repeated up to three times\n            converted_digit = roman_numerals[10**current_place]*(digits[i])\n        converted_num += converted_digit\n    return converted_num","34db82b8":"roman_check = [2, 3, 4, 5, 9, 12, 16, 29, 44, 45, 68, 83, 97, 99, 400, 500, 501, 649, 798, 891, 1000, 1004, 1006, 1023, 2014, 3999]\nfor check in roman_check:\n    print(check, \"converts to\", convertToRoman(check))","db38c127":"def caesar_shift(string, shift = 13):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    shift_alpha = \"\".join([alphabet[(i + shift) % 26] for i in range(26)])\n    # After creating strings for the alphabet and the shifted alphabet,\n    # create a translation dictionary for both upper and lower case letters\n    # using the str.maketrans() function\n    shift_dict = str.maketrans(alphabet + alphabet.upper(), shift_alpha + shift_alpha.upper())\n    # Use the translation dictionary to apply the cipher.\n    return string.translate(shift_dict)","4f9fc3dd":"caesar_check = [\"SERR PBQR PNZC\", \"SERR CVMMN!\", \"SERR YBIR?\",\n               \"GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT.\"]\nfor check in caesar_check:\n    print(\"Before translating:\", check)\n    print(\"After translating:\", caesar_shift(check))\nmessage = \"This is a Caesar shifted message!\"\nencoded = caesar_shift(message, 5)\nprint(\"Shifted by 5:\", encoded)\nprint(\"Decoded message:\", caesar_shift(encoded, -5))","f06c7732":"import re\ndef telephoneCheck(string):\n    # First check to make sure that the first character is either a digit\n    # or an opening parenthesis. This will disallow \"-1 (757) 622-7382\"\n    first_char_check = string[0].isdecimal() or string[0] == \"(\"\n    # Extract just the digits from the string\n    tele_digits = [int(char) for char in string if char.isdecimal()]\n    num_digits = len(tele_digits)\n    # Check if the length is 10 or 11\n    # If the length is 11, check that the country code is 1\n    length_check = num_digits == 10 or (num_digits == 11 and tele_digits[0] == 1)\n    # Create a regular expression to check for the pattern \"(XXX)\"\n    # Where X is any character\n    parens_regex = r\"\\(.{3}\\)\"\n    # Check to see if the string contains any parentheses\n    # If it does, make sure that it matches the parentheses regex exactly once\n    parens_check = True\n    if (\"(\" in string) or (\")\" in string):\n        parens_match = re.findall(parens_regex, string)\n        #print(parens_match)\n        parens_check = (parens_match is not None) and (len(parens_match) == 1)\n    return first_char_check and length_check and parens_check","5c178f5d":"telephone_numbers = [\"555-555-5555\", \"1 555-555-5555\", \"1 (555) 555-5555\", \"5555555555\", \"555-555-5555\",\n                    \"(555)555-5555\", \"1(555)555-5555\", \"555-5555\", \"5555555\", \"1 555)555-5555\",\n                    \"1 555 555 5555\", \"1 456 789 4444\", \"123**&!!asdf#\", \"55555555\", \"(6054756961)\",\n                    \"2 (757) 622-7382\", \"0 (757) 622-7382\", \"-1 (757) 622-7382\", \"2 757 622-7382\", \"10 (757) 622-7382\",\n                    \"27576227382\", \"(275)76227382\", \"2(757)6227382\", \"2(757)622-7382\", \"555)-555-5555\",\n                    \"(555-555-5555\", \"(555)5(55?)-5555\"]\nfor number in telephone_numbers:\n    print(number, telephoneCheck(number))","c61de926":"def checkCashRegister(price, cash, cid):\n    # Create a dictionary mapping currency denominations to their values\n    currency_dict = {\"PENNY\":0.01, \"NICKEL\":0.05, \"DIME\":0.1, \"QUARTER\":0.25, \"ONE\":1, \"FIVE\":5, \"TEN\":10, \"TWENTY\":20, \"ONE HUNDRED\":100}\n    # Compute the change due and a secondary variable of the remaining\n    # change due for use in the computation of the change\n    change_due = cash - price\n    remaining_due = cash - price\n    change_given = [] # An array to store the change to be given\n    cash_available = 0 # For computing the total cash available in the drawer\n    # Loop through the currency in the drawer to both count the total\n    # and also compute how the change would be given\n    # Go from highest value currency to lowest value\n    for i in range(len(cid) - 1, -1, -1):\n        cash_available += round(cid[i][1], 2)\n        if remaining_due >= currency_dict[cid[i][0]]:\n            change_to_give = min(cid[i][1], (remaining_due\/\/currency_dict[cid[i][0]])*currency_dict[cid[i][0]])\n            change_given.append([cid[i][0], change_to_give])\n            remaining_due -= change_to_give\n            remaining_due = round(remaining_due, 2) #To account for floating point arithmetic rounding issues\n            #print(change_to_give)\n            #print(remaining_due)\n    if (change_due == cash_available):\n        return {\"status\": \"CLOSED\", \"change\": cid}\n    elif (change_due > cash_available or remaining_due > 0):\n        return {\"status\": \"INSUFFICIENT FUNDS\", \"change\": []}\n    else:\n        return {\"status\": \"OPEN\", \"change\": change_given}","5fdd36fe":"print(checkCashRegister(19.5, 20, [[\"PENNY\", 1.01], [\"NICKEL\", 2.05], [\"DIME\", 3.1], [\"QUARTER\", 4.25], [\"ONE\", 90], [\"FIVE\", 55], [\"TEN\", 20], [\"TWENTY\", 60], [\"ONE HUNDRED\", 100]]))\nprint(checkCashRegister(3.26, 100, [[\"PENNY\", 1.01], [\"NICKEL\", 2.05], [\"DIME\", 3.1], [\"QUARTER\", 4.25], [\"ONE\", 90], [\"FIVE\", 55], [\"TEN\", 20], [\"TWENTY\", 60], [\"ONE HUNDRED\", 100]]))\nprint(checkCashRegister(19.5, 20, [[\"PENNY\", 0.01], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 0], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]]))\nprint(checkCashRegister(19.5, 20, [[\"PENNY\", 0.01], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 1], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]]))\nprint(checkCashRegister(19.5, 20, [[\"PENNY\", 0.5], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 0], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]]))","8eeef8bc":"Return `True` if the passed string looks like a valid US telephone number. Note that an area code is required, and if a country code is provided it must be 1.","f9e5532a":"## Cash Register","81f3126d":"In this notebook, I will work through the final algorithms and data structures projects from freeCodeCamp. On freeCodeCamp, the challenges are done in JavaScript, so to get some additional Python practice I will do them here in Python.","043cc4ea":"## Roman Numeral Converter","87618263":"Return `True` if the given string is a palindrome. Otherwise, return `False`.\nRecall that a *palindrome* is a word or sentence that's spelled the same way both forward and backward, ignoring punctuation, case, and spacing.","ce2c5c85":"## Caesars Cipher","a97b9167":"Design a cash register drawer function `checkCashRegister()` that acceps purchase price as the first argument (`price`), payment as the second argument (`cash`), and cash-in-drawer (`cid`) as the third argument. `cid` is a 2D array listing the available currency in the drawer. The `checkCashRegister()` function should always return a dictionary with a `status` key and a `change` key. There are three situations.\n- Return `{\"status\": \"INSUFFICIENT_FUNDS\", \"change\": []}` if the cash-in-drawer is less than the change due, or if you cannot return the exact change.\n- Return `{\"status\": \"CLOSED\", \"change\": cid}` if the change due is exactly equal to the cash-in-drawer.\n- Otherwise, return `{\"status\": \"OPEN\", \"change\": [...]}`, with the change due in coins and bills, sorted in highest to lowest order by denomination, as the value of the `change` key.","6fda9d0f":"For my solution, I will do a more general function which takes an arbitry shift amount, `shift`, and applies that shift to the phrase. By default I will have `shift = 13`.I will also allow for arbitrary capitalization and preserve that capitalization in the shifted string.","473dab88":"The basic solution is inefficient for long strings (such as an entire novel) becasue it performs various options (`lower()`, `re.sub()`, reversing the string) on the entire string before comparing the entire string to its reversed version. A more advanced solution, which is much more efficient, checks two characters at a time working from the start and end of the string.","6008147c":"## Telephone Number Validator","303bc17e":"Convert the given number into a Roman numeral. All Roman numerals should be provided in upper-case. For simplicity, we will only convert numbers that are smaller than 5000, those require a [bit of extra formatting](https:\/\/www.mathsisfun.com\/roman-numerals.html).","4d696a25":"## Palindrome Checker","01831c27":"# Algorithms and Data Structures Projects","9a842f9f":"One of the simplest and most widely known ciphers is the *Caesar cipher*, also known as a *shift cipher*. In a shift cipher, the meanings of the letters are shifted by some set amount. A common modern use is the ROT13 cipher, where the values of the letters are shifted by 13 places. Thus A and N are swapped, B and O, and so on. Write a function which takes a ROT13 encoded string as input and returns a decoded string. Note that all letters will be uppercase, and do not transform any non-alphabetic characters (i.e. spaces, punctuation), but do pass them on."}}