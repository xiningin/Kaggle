{"cell_type":{"e6affdf9":"code","886bad45":"code","631bfec9":"code","f1264f21":"code","e41466f5":"code","02406d2f":"code","cfb95993":"code","ff66aa7b":"code","060ac17c":"code","f0e5c3bb":"code","435ff7ae":"code","074cb76d":"code","53632124":"code","cb326e1a":"code","a2447c6e":"code","cf2f1ed0":"code","21a37ad5":"code","1865d141":"markdown","6b348268":"markdown","c9e4ca1f":"markdown","0e50058b":"markdown","59cf25c5":"markdown","e795e9d7":"markdown","2769e905":"markdown","426997d3":"markdown","32aaac90":"markdown","e39528b5":"markdown","ed94d89b":"markdown"},"source":{"e6affdf9":"import os\nimport numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nfrom subprocess import check_output\nprint(check_output([\"ls\", \"..\/input\"]).decode(\"utf8\"))","886bad45":"sub_path = \"..\/input\/top-mol\"\nall_files = os.listdir(sub_path)\nall_files","631bfec9":"outs = [pd.read_csv(os.path.join(sub_path, f), index_col=0) for f in all_files]\nconcat_sub = pd.concat(outs, axis=1)\ncols = list(map(lambda x: \"mol\" + str(x), range(len(concat_sub.columns))))\nconcat_sub.columns = cols\nconcat_sub.reset_index(inplace=True)\nconcat_sub.head()\nncol = concat_sub.shape[1]","f1264f21":"# check correlation\nconcat_sub.iloc[:,1:ncol].corr()","e41466f5":"corr = concat_sub.iloc[:,1:7].corr()\nmask = np.zeros_like(corr, dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\n\n# Set up the matplotlib figure\nf, ax = plt.subplots(figsize=(11, 9))\n\n# Generate a custom diverging colormap\ncmap = sns.diverging_palette(220, 10, as_cmap=True)\n\n# Draw the heatmap with the mask and correct aspect ratio\nsns.heatmap(corr, mask=mask, cmap=cmap, vmax=.3, center=0,\n            square=True, linewidths=.5, cbar_kws={\"shrink\": .5})","02406d2f":"# get the data fields ready for stacking\nconcat_sub['m_max'] = concat_sub.iloc[:, 1:ncol].max(axis=1)\nconcat_sub['m_min'] = concat_sub.iloc[:, 1:ncol].min(axis=1)\nconcat_sub['m_mean'] = concat_sub.iloc[:, 1:ncol].mean(axis=1)\nconcat_sub['m_median'] = concat_sub.iloc[:, 1:ncol].median(axis=1)","cfb95993":"concat_sub.describe()","ff66aa7b":"cutoff_lo = 0.8\ncutoff_hi = 0.2","060ac17c":"concat_sub['scalar_coupling_constant'] = concat_sub['m_mean']\nconcat_sub[['id', 'scalar_coupling_constant']].to_csv('stack_mean.csv', \n                                        index=False, float_format='%.6f')","f0e5c3bb":"concat_sub['scalar_coupling_constant'] = concat_sub['m_median']\nconcat_sub[['id', 'scalar_coupling_constant']].to_csv('stack_median.csv', \n                                        index=False, float_format='%.6f')","435ff7ae":"concat_sub['scalar_coupling_constant'] = np.where(np.all(concat_sub.iloc[:,1:ncol] > cutoff_lo, axis=1), 1, \n                                    np.where(np.all(concat_sub.iloc[:,1:ncol] < cutoff_hi, axis=1),\n                                             0, concat_sub['m_median']))\nconcat_sub[['id', 'scalar_coupling_constant']].to_csv('stack_pushout_median.csv', \n                                        index=False, float_format='%.6f')","074cb76d":"concat_sub['scalar_coupling_constant'] = np.where(np.all(concat_sub.iloc[:,1:ncol] > cutoff_lo, axis=1), \n                                    concat_sub['m_max'], \n                                    np.where(np.all(concat_sub.iloc[:,1:ncol] < cutoff_hi, axis=1),\n                                             concat_sub['m_min'], \n                                             concat_sub['m_mean']))\nconcat_sub[['id', 'scalar_coupling_constant']].to_csv('stack_minmax_mean.csv', \n                                        index=False, float_format='%.6f')","53632124":"concat_sub['scalar_coupling_constant'] = np.where(np.all(concat_sub.iloc[:,1:ncol] > cutoff_lo, axis=1), \n                                    concat_sub['m_max'], \n                                    np.where(np.all(concat_sub.iloc[:,1:ncol] < cutoff_hi, axis=1),\n                                             concat_sub['m_min'], \n                                             concat_sub['m_median']))\nconcat_sub[['id', 'scalar_coupling_constant']].to_csv('stack_minmax_median.csv', \n                                        index=False, float_format='%.6f')","cb326e1a":"concat_sub['scalar_coupling_constant'] = concat_sub['mol0'].rank(method ='min') + concat_sub['mol1'].rank(method ='min') + concat_sub['mol2'].rank(method ='min') \nconcat_sub['scalar_coupling_constant'] = (concat_sub['scalar_coupling_constant']-concat_sub['scalar_coupling_constant'].min())\/(concat_sub['scalar_coupling_constant'].max() - concat_sub['scalar_coupling_constant'].min())\nconcat_sub.describe()\nconcat_sub[['id', 'scalar_coupling_constant']].to_csv('stack_rank.csv', index=False, float_format='%.8f')","a2447c6e":"sub1=pd.read_csv('..\/input\/another-one\/stackers_blend.csv')\nsub2=pd.read_csv('..\/input\/lgb-public-kernels-plus-more-features\/sub_lgb_model_individual.csv')\nsub3=pd.read_csv('..\/input\/yet-another-one\/stackers_blend.csv')\nsub4=pd.read_csv('..\/input\/giba-r-data-table-simple-features-1-17-lb\/submission-giba-1.csv')\n\ntemp=pd.read_csv('..\/input\/another-one\/stackers_blend.csv')","cf2f1ed0":"temp['scalar_coupling_constant'] = 0.6*sub1['scalar_coupling_constant'] + 0.4*sub1['scalar_coupling_constant']\ntemp.to_csv('submission4.csv', index=False )","21a37ad5":"sns.distplot(temp['scalar_coupling_constant'])","1865d141":"# Pushout + Median Stacking\n>* Pushout strategy is bit aggresive","6b348268":"## Averaging Ranks","c9e4ca1f":"## Blend","0e50058b":"submission4.csv gives best score.[ BLEND WINS ]\n## <font color=blue>Vote early and vote often!<\/font>\n","59cf25c5":"# Mean Stacking","e795e9d7":"## Stat Stack","2769e905":"# MinMax + Mean Stacking\n>* MinMax seems more gentle and it outperforms the previous one","426997d3":"## Blend Or Stack\n**After watching top kernal many of them are blend and stacking.**\n\nThis show how the scores can be imporved by add more models.\nThanks for show this kernals.\n\nref:\n1. https:\/\/www.kaggle.com\/danmusetoiu\/staking-and-stealing-like-a-molecule\n2. https:\/\/www.kaggle.com\/marcelotamashiro\/lgb-public-kernels-plus-more-features\n3. https:\/\/www.kaggle.com\/rajwardhanshinde\/blend-of-blends\n4. https:\/\/www.kaggle.com\/vaishvik25\/blend\n\n","32aaac90":"# MinMax + Median Stacking","e39528b5":"# Median Stacking","ed94d89b":"## <font color=blue>Vote early and vote often!<\/font>\n"}}