{"cell_type":{"acb35593":"code","fb2564d1":"code","7b1622eb":"code","4a7c23a1":"code","7b769a47":"code","17a95910":"code","5c2e4e10":"code","00c6cbb5":"code","5fd847ac":"code","7fea37a6":"code","e1f5ff05":"code","24d0d296":"code","3af5a340":"code","139ed9b5":"code","77b5e7a7":"code","305ed73f":"code","9a57a8b6":"code","86fbdf32":"code","013de3c1":"code","5f9abaca":"code","d78af3d8":"code","2a7a0501":"code","caf07d49":"code","adaff24f":"code","916a403a":"code","c5ac4ede":"code","a2ca5b59":"code","b617079d":"code","efaba3d3":"code","5d1a9af6":"code","037f815e":"code","cb26340d":"code","2e77b953":"code","eaf536ae":"code","afefb72c":"code","ca733e8a":"code","71b7c266":"code","a7d88531":"code","f5e5a675":"code","b8aa1866":"code","b417f83a":"code","feec254c":"code","e1d22332":"code","56bcce86":"code","caa6a194":"markdown","8e710c53":"markdown","0c7bfd9b":"markdown","1fca4cc2":"markdown","716c32a2":"markdown","c37efdcd":"markdown","47b10465":"markdown","07f7fc9a":"markdown","173bc203":"markdown","52c05f02":"markdown","594bc1d0":"markdown","981d28bb":"markdown","32b4e86f":"markdown","e4e308ef":"markdown","6b55409b":"markdown","ee886c84":"markdown","b5ddb32f":"markdown","2c7d6d9c":"markdown","0f10a973":"markdown","40310584":"markdown","beeda1e0":"markdown","b493e5f1":"markdown","6560ef21":"markdown","eee2c6a7":"markdown","44d1688a":"markdown","7b7b3338":"markdown","b91b169a":"markdown","e6ed34aa":"markdown","b88b085a":"markdown","55078e49":"markdown","0c190292":"markdown","ebb9d540":"markdown","8a6d07fe":"markdown","ab063b51":"markdown","5cb4a03d":"markdown","d10bb896":"markdown","e1ea86b1":"markdown","b7cd399b":"markdown","8598189c":"markdown","bc2225e8":"markdown","15524b96":"markdown","5d9b4c3f":"markdown","dee2a2a1":"markdown","16c705eb":"markdown","2bc1748e":"markdown","13752aa8":"markdown","2efdbbee":"markdown","4b43a40d":"markdown","cf7750cb":"markdown","56019d29":"markdown","3f31dddc":"markdown","5756b378":"markdown"},"source":{"acb35593":"# Basic numerical and other libraries\nimport random\nimport numpy as np\nimport pandas as pd\nfrom scipy import stats\nimport sys\nimport functools\n\n# Display option\nfrom IPython.display import display, HTML\npd.options.display.max_rows = 5000\npd.options.display.max_columns = 5000\n\n# Handle warnings (during execution of code)\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Datetime\nimport time\nfrom datetime import datetime\nfrom datetime import timedelta\n\n# Visulisation\nfrom pprint import pprint\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n# statsmodel\nimport statsmodels.api as statsm\nimport statsmodels.discrete.discrete_model as sm\nfrom statsmodels.stats.outliers_influence import variance_inflation_factor\n\n# Imbalanced Data Handling\nimport imblearn\nfrom imblearn.over_sampling import RandomOverSampler\nfrom imblearn.under_sampling import RandomUnderSampler\n\n# sklearn\nfrom sklearn.model_selection import StratifiedKFold, KFold, LeaveOneOut, cross_val_score, GridSearchCV, RandomizedSearchCV, train_test_split\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn import tree\nfrom sklearn.metrics import auc, roc_auc_score, roc_curve\n\n\n# xgboost, lightgbm\nfrom xgboost import XGBClassifier","fb2564d1":"def plot_stats(df, feature, target_ftr, label_rotation=False, horizontal_layout=True):\n    '''\n    This function plot the categorical feature distribution according to target variable\n    '''\n    temp = df[feature].value_counts()\n    df1 = pd.DataFrame({feature: temp.index,'Number of Patients': temp.values})\n\n    # Calculate the percentage of target=1 per category value\n    cat_perc = df[[feature, target_ftr]].groupby([feature],as_index=False).mean()\n    cat_perc.sort_values(by=target_ftr, ascending=False, inplace=True)\n    \n    sns.set_color_codes(\"pastel\")\n    s = sns.barplot(x = feature, y=\"Number of Patients\",data=df1)\n    if(label_rotation):\n        s.set_xticklabels(s.get_xticklabels(),rotation=60)\n\n    plt.tick_params(axis='both', which='major', labelsize=10)\n\n    plt.show();\n\n\ndef get_rocauc(model, xTest, yTest): \n    '''\n    This function produces the Area under the curve for the model. \n    The 'auto' method calculates this metric by using the roc_auc_score function from sklearn.\n    Range: 0 to 1 (0 being the worst predictive model, 0.5 being the random and 1 being the best)\n    '''\n    predictions = model.predict_proba(xTest)[:, 1]\n    roc_auc = roc_auc_score(yTest, predictions)\n    print('Model Performance:')\n    print('--'*5)\n    print('--'*5)\n    print('ROC = {:0.2f}%'.format(roc_auc))\n    \n    return roc_auc","7b1622eb":"df_train = pd.read_csv('..\/input\/siim-isic-melanoma-classification\/train.csv')\ndf_test  = pd.read_csv('..\/input\/siim-isic-melanoma-classification\/test.csv')\ndf_sub   = pd.read_csv('..\/input\/siim-isic-melanoma-classification\/sample_submission.csv')\n","4a7c23a1":"# shape of training, test and submission data\n\nprint(f'training data shape: {df_train.shape}')\nprint(f'test data shape: {df_test.shape}')\nprint(f'submission data shape: {df_sub.shape}')","7b769a47":"df_train.head()","17a95910":"df_test.head()","5c2e4e10":"df_sub.head()","00c6cbb5":"# training dataset\n\ndf_train['target'].unique()","5fd847ac":"# submission dataset\n\ndf_sub['target'].unique()","7fea37a6":"sns.countplot(df_train.target)","e1f5ff05":"df_train['target'].value_counts()","24d0d296":"# Gender Distribution\n\nplot_stats(df_train, 'sex', 'target', label_rotation=False, horizontal_layout=True)","3af5a340":"# anatom_site_general_challenge Distribution\n\nplot_stats(df_train, 'anatom_site_general_challenge', 'target', label_rotation=90, horizontal_layout=True)","139ed9b5":"# Age Distribution of Patients according to target\n\nfig, axes = plt.subplots(1, 2)\n\nfig.set_size_inches(12, 4)\n\ndf_train[df_train['target']==0].hist('age_approx', bins=100, ax=axes[0])\naxes[0].set_xlabel('benign')\ndf_train[df_train['target']==1].hist('age_approx', bins=100, ax=axes[1])\naxes[1].set_xlabel('malignant')\n\nplt.show()","77b5e7a7":"df_train.head(3)","305ed73f":"# Calculate missing value count and percentage\n\nmissing_value_df_train = pd.DataFrame(index = df_train.keys(), data =df_train.isnull().sum(), columns = ['Missing_Value_Count'])\nmissing_value_df_train['Missing_Value_Percentage'] = ((df_train.isnull().mean())*100)\nmissing_value_df_train.sort_values('Missing_Value_Count',ascending= False)","9a57a8b6":"# Calculate missing value count and percentage\n\nmissing_value_df_test = pd.DataFrame(index = df_test.keys(), data =df_test.isnull().sum(), columns = ['Missing_Value_Count'])\nmissing_value_df_test['Missing_Value_Percentage'] = ((df_test.isnull().mean())*100)\nmissing_value_df_test.sort_values('Missing_Value_Count',ascending= False)","86fbdf32":"# Replace age with median\n\nage_array = df_train[df_train[\"age_approx\"]!=np.nan][\"age_approx\"]\ndf_train[\"age_approx\"].replace(np.nan, age_array.median(), inplace=True)\n\n\n# Replace sex and anatom_site_general_challenge with mode\n\nsex_array = df_train[~(df_train[\"sex\"].isnull())][\"sex\"]\ndf_train['sex'].fillna(sex_array.mode().values[0], inplace=True)\n\nanatom_array = df_train[~(df_train[\"anatom_site_general_challenge\"].isnull())][\"anatom_site_general_challenge\"]\ndf_train['anatom_site_general_challenge'].fillna(anatom_array.mode().values[0], inplace=True)","013de3c1":"# Replace age with median for test data\n\n# age_array = df_test[df_test[\"age_approx\"]!=np.nan][\"age_approx\"]\n# df_test[\"age_approx\"].replace(np.nan, age_array.median(), inplace=True)\n\n\n# # Replace sex and anatom_site_general_challenge with mode\n\n# sex_array = df_test[~(df_test[\"sex\"].isnull())][\"sex\"]\n# df_test['sex'].fillna(sex_array.mode().values[0], inplace=True)\n\nanatom_array_test = df_test[~(df_test[\"anatom_site_general_challenge\"].isnull())][\"anatom_site_general_challenge\"]\ndf_test['anatom_site_general_challenge'].fillna(anatom_array_test.mode().values[0], inplace=True)","5f9abaca":"# Unique values for feature 'sex'\n\nprint('Unique values for gender:')\nprint(df_train['sex'].unique())\nprint('--'*20)\nprint('--'*20)\nprint('Unique values for anatom_site_general_challenge:')\nprint(df_train['anatom_site_general_challenge'].unique())","d78af3d8":"## Feature 'sex'\n\n# Need to convert the datatypes of the feature to 'category' before Label encoding.\ndf_train[\"sex\"] = df_train[\"sex\"].astype('category')\n\n# Label Encoding\ndf_train[\"sex_cat\"] = df_train[\"sex\"].cat.codes\n\ndf_train[[\"sex\", \"sex_cat\"]].head(3)","2a7a0501":"## Feature 'anatom_site_general_challenge'\n\n# Need to convert the datatypes of the feature to 'category' before Label encoding.\ndf_train[\"anatom_site_general_challenge\"] = df_train[\"anatom_site_general_challenge\"].astype('category')\n\n# Label Encoding\ndf_train[\"anatom_site_general_challenge_cat\"] = df_train[\"anatom_site_general_challenge\"].cat.codes\n\ndf_train[[\"anatom_site_general_challenge\", \"anatom_site_general_challenge_cat\"]].head(3)","caf07d49":"### Categorical Data Handling for test data\n\n\n## Feature 'sex'\n\n# Need to convert the datatypes of the feature to 'category' before Label encoding.\ndf_test[\"sex\"] = df_test[\"sex\"].astype('category')\n\n# Label Encoding\ndf_test[\"sex_cat\"] = df_test[\"sex\"].cat.codes\n\ndf_test[[\"sex\", \"sex_cat\"]].head(3)\n","adaff24f":"### Categorical Data Handling for test data\n\n## Feature 'anatom_site_general_challenge'\n\n# Need to convert the datatypes of the feature to 'category' before Label encoding.\ndf_test[\"anatom_site_general_challenge\"] = df_test[\"anatom_site_general_challenge\"].astype('category')\n\n# Label Encoding\ndf_test[\"anatom_site_general_challenge_cat\"] = df_test[\"anatom_site_general_challenge\"].cat.codes\n\ndf_test[[\"anatom_site_general_challenge\", \"anatom_site_general_challenge_cat\"]].head(3)","916a403a":"# feature set\n\nftr_set = ['sex_cat',\n           'age_approx',\n           'anatom_site_general_challenge_cat']","c5ac4ede":"# dependent and independent features of training and test datasets\n\nexog_train = df_train[ftr_set]\nendog_train = df_train['target']\n\nexog_test = df_test[ftr_set]","a2ca5b59":"# define oversampling strategy\noversample = RandomOverSampler(sampling_strategy=0.7)\nX_over, y_over = oversample.fit_resample(exog_train, endog_train)\n\nX_over = pd.DataFrame(X_over)\ny_over = pd.DataFrame(y_over)","b617079d":"# print(X_over.shape)\n# print(y_over.shape)","efaba3d3":"# define undersampling strategy\nundersample = RandomUnderSampler(sampling_strategy=0.1)\nX_under, y_under = undersample.fit_resample(exog_train, endog_train)\n\nX_under = pd.DataFrame(X_under)\ny_under = pd.DataFrame(y_under)","5d1a9af6":"# print(X_under.shape)\n# print(y_under.shape)","037f815e":"# Oversampled train and validation split\n\nx_train, x_val, y_train, y_val = train_test_split(X_over, y_over, test_size=0.2, stratify=y_over, random_state=42)\n","cb26340d":"# Undersampled train and validation split\n\nx_train, x_val, y_train, y_val = train_test_split(X_under, y_under, test_size=0.2, stratify=y_under, random_state=42)\n","2e77b953":"# Insample train and validation split\n\nx_train, x_val, y_train, y_val = train_test_split(exog_train, endog_train, test_size=0.1, stratify=endog_train, random_state=42)\n","eaf536ae":"# Random Forest Model\n\nrf = RandomForestClassifier(random_state = 42)","afefb72c":"# Parameters used by the current forest\n\nprint('Parameters currently in use:\\n')\npprint(rf.get_params())","ca733e8a":"rf_base_model = RandomForestClassifier(n_estimators = 100, max_depth=5, random_state = 42)\nrf_base_model.fit(x_train, y_train)\nbase_accuracy = get_rocauc(rf_base_model, x_val, y_val)","71b7c266":"# # Compute cross-validated AUC scores: cv_auc\n\n# cv_auc = cross_val_score(rf_base_model, x_val, y_val, cv=5, scoring = 'roc_auc')\n\n# print(\"AUC scores computed using 5-fold cross-validation: {}\".format(cv_auc))","a7d88531":"# fit model no training data\nxgb_model = XGBClassifier()\nxgb_model.fit(x_train, y_train)\n\n# # make predictions for test data\n# y_pred = xgb_model.predict(X_test)\nbase_accuracy_xgb = get_rocauc(xgb_model, x_val, y_val)","f5e5a675":"# Compute cross-validated AUC scores: cv_auc\n\nxgb_cv_auc = cross_val_score(xgb_model, x_val, y_val, cv=5, scoring = 'roc_auc')\n\nprint(\"AUC scores computed using 5-fold cross-validation: {}\".format(xgb_cv_auc))","b8aa1866":"rf_pred_test= rf_base_model.predict_proba(exog_test)[:, 1]\n\nprint(rf_pred_test)","b417f83a":"xgb_pred_test= xgb_model.predict_proba(exog_test)[:, 1]\n\nprint(xgb_pred_test)","feec254c":"# df_sub['target']=list(rf_pred_test)\ndf_sub['target']=list(xgb_pred_test)","e1d22332":"df_sub.head()","56bcce86":"df_sub.to_csv( 'submission.csv', index=False )","caa6a194":"### Predictions","8e710c53":"* Test Data","0c7bfd9b":"* Training Data","1fca4cc2":"### Training, Validation & Test Data Preparation","716c32a2":"#### XGBoost Model","c37efdcd":"* Training Data","47b10465":"* Need to analyse how more than 1 feature is less in test data than in training data.","07f7fc9a":"* 'diagnosis' and 'benign_malignant' are missing in test dataset. \n* So while building any algorithm we will not be able to use these 2 features.","173bc203":"#### Age Distribution of Patients according to target","52c05f02":"* Huge Class imbalance is there.\n* We may use some sampling techniques to treat the class-imbalance. (**Will try after running the baseline model)","594bc1d0":"### EDA","981d28bb":"* Undersampled","32b4e86f":"#### test dataset","e4e308ef":"* we need to impute these 3 features    \n\n  1. anatom_site_general_challenge\n  2. age_approx\n  3. sex","6b55409b":"#### submission dataset","ee886c84":"#### Oversampling","b5ddb32f":"#### Random Forest","2c7d6d9c":"* We need to prepare a validation set for simple baseline accuracy calculation.\n* I will try to make as small as possible the validation set as 33k records are there in training dataset.","0f10a973":"### Data Preprocessing","40310584":"#### Categorical Feature Handling","beeda1e0":"* target values in training dataset looks good and in submission each and every image is assumed as benign.\n* Our job is to predict the probability of an image being malignant.","b493e5f1":"#### Gender Distribution","6560ef21":"### User-Defined Functions","eee2c6a7":"### Imbalanced Data Handling","44d1688a":"* Train data consists a very balanced gender distribution of patients.\n","7b7b3338":"* Training Data ","b91b169a":"#### train dataset","e6ed34aa":"### Model Build","b88b085a":"#### Missing Values","55078e49":"#### Cross-Validation****","0c190292":"#### Target Class Distribution","ebb9d540":"* Test Data","8a6d07fe":"#### Imputation","ab063b51":"#### 1. #records and #features","5cb4a03d":"* This can help in distinguishing between benign and malignant as median is less for benign","d10bb896":"* Test Data","e1ea86b1":"#### Let's check the unique values in the targets of training and submission datasets","b7cd399b":"### Import Data","8598189c":"* Oversampled","bc2225e8":"#### Cross-validation score","15524b96":"#### How does each of the datasets look like ?","5d9b4c3f":"* Insample (Without imbalanced class treatment)","dee2a2a1":"#### Let's check the null values","16c705eb":"### Libraries","2bc1748e":"#### Future Work:\n\n1. Include image data\n2. Tune model","13752aa8":"#### Training & Validation data split","2efdbbee":"#### anatom_site_general_challenge Distribution","4b43a40d":"### Work in Progress !","cf7750cb":"* Here, we may need to replace target with the predicted values from the trained model.","56019d29":"#### Undersampling","3f31dddc":"## Upvote if you find this useful !","5756b378":"## Feature Selection"}}