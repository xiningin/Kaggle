{"cell_type":{"bd02ee97":"code","f8174c23":"code","f1c12432":"code","7991b762":"code","0952d9d7":"code","30148388":"code","d80beb91":"code","a00e8c68":"code","b24935bd":"code","a6d23306":"code","36aea5c7":"code","737f6951":"code","3b8cf0c6":"code","9617bec9":"code","7c57aea9":"code","12c8b628":"code","8c009195":"code","e44a4d3e":"code","7ff12419":"code","23303908":"code","55535223":"code","af563ee1":"code","319d4ff8":"code","5322ec75":"code","b23b80f9":"code","7d8b68c7":"code","e7cb7800":"code","3da1f19e":"code","1c4b4ad0":"code","fd899dea":"code","be0a8a93":"code","4229b2b4":"code","f628b1fb":"code","1de3ba3d":"code","2fadf0e7":"code","a47bda3f":"code","cf297585":"code","8e5587a4":"code","d2f462cd":"code","f11b941f":"code","a1bb0244":"code","d62aee49":"markdown","eca4905b":"markdown","7223e042":"markdown","3bac583e":"markdown","10503ce8":"markdown","a2025655":"markdown","84ef59a0":"markdown","c24663df":"markdown","3e748fa4":"markdown","5c4be06c":"markdown"},"source":{"bd02ee97":"import pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import Counter\nimport os\nfrom wordcloud import WordCloud","f8174c23":"data = pd.read_csv(\"\/kaggle\/input\/sms-spam-collection-dataset\/spam.csv\", encoding='latin-1', usecols=[0, 1])","f1c12432":"data.shape","7991b762":"# Rename the columns with more explicit names\ndata.rename(columns={'v1' : 'label', 'v2' : 'message'}, inplace=True)\n\n# Five first rows of the dataset\ndata.head(5)","0952d9d7":"# Give a brief description of the dataset\ndata.groupby('label').describe()","30148388":"data[\"label\"].value_counts().plot(kind = 'pie', explode = [0, 0.1], \n                                      figsize = (6, 6), autopct = '%1.1f%%', \n                                      shadow = True)","d80beb91":"data['message'].apply(lambda x: len(x.split(' '))).mean() # average words per sms","a00e8c68":"data['length'] = data['message'].map(lambda text: len(text))\ndata.head()","b24935bd":"data.length.describe()","a6d23306":"data.hist(column='length', by='label', bins=50)","36aea5c7":"import seaborn as sns\nham =data[data['label'] == 'ham']['message'].str.len()\nsns.distplot(ham, label='Ham')\nspam = data[data['label'] == 'spam']['message'].str.len()\nsns.distplot(spam, label='Spam')\nplt.title('Distribution by Length')\nplt.legend()","737f6951":"# Visualization of the most frequent words of the dataset\ncount1 = Counter(\" \".join(data[\"message\"]).split()).most_common(30)\ndf1 = pd.DataFrame.from_dict(count1)\ndf1 = df1.rename(columns={0: \"words\", 1 : \"count\"})\nfig = plt.figure()\nax = fig.add_subplot(111)\ndf1.plot.bar(ax=ax, legend = False)\nxticks = np.arange(len(df1[\"words\"]))\nax.set_xticks(xticks)\nax.set_xticklabels(df1[\"words\"])\nax.set_ylabel('Number of occurences')\nplt.show()","3b8cf0c6":"# Wordcloud paramters\nwc_height, wc_width = (512, 1024)\nwc_bckp_color = 'white'\nwc_max_words = 400\nwc_max_font_size = 60\nrandom_state = 42\nwc_figsize = (12, 10)","9617bec9":"# Extracting spam messages from DataFrame\nspam_df = data.loc[data['label'] == 'spam']\n\n# Creating wordcloud for spam\nspam_wc = WordCloud(\n    height=wc_height, width=wc_width, background_color=wc_bckp_color,\n    max_words=wc_max_words, max_font_size=wc_max_font_size,\n    random_state=random_state\n).generate(str(spam_df['message']))\n\n# Display the wordcloud\nfig = plt.figure(figsize=wc_figsize)\nplt.imshow(spam_wc)\nplt.axis('off')\nplt.show()","7c57aea9":"# Extracting ham messages from DataFrame\nham_df = data.loc[data['label'] == 'ham']\n\n# Creating wordcloud for ham\nham_wc = WordCloud(\n    height=wc_height, width=wc_width, background_color=wc_bckp_color,\n    max_words=wc_max_words, max_font_size=wc_max_font_size,\n    random_state=random_state\n).generate(str(ham_df['message']))\n\n# Display the wordcloud\nfig = plt.figure(figsize=wc_figsize)\nplt.imshow(ham_wc)\nplt.axis('off')\nplt.show()","12c8b628":"#read data in CSV format according to your PC's address\ndata = pd.read_csv(\"\/kaggle\/input\/sms-spam-collection-dataset\/spam.csv\",encoding='latin')","8c009195":"data.rename(columns={'v1':'label','v2':'Text'},inplace=True)\ndata['numClass'] = data['label'].map({'ham':0, 'spam':1})\ndata['Count']=0\nfor i in np.arange(0,len(data.Text)):\n    data.loc[i,'Count'] = len(data.loc[i,'Text'])\n\n# Unique values in target set\nprint(\"Unique values in the label set: \", data.label.unique())\nprint('Number of texts in the total set: {}'.format(data.shape[0]))","e44a4d3e":"ham  = data[data.numClass == 0]\nham_count  = pd.DataFrame(pd.value_counts(ham['Count'],sort=True).sort_index())\nprint(\"Number of ham messages in data set:\", ham['label'].count())\nprint(\"Ham Count value\", ham_count['Count'].count())\n","7ff12419":"spam = data[data.numClass == 1]\nspam_count = pd.DataFrame(pd.value_counts(spam['Count'],sort=True).sort_index())\nprint(\"Number of spam messages in data set:\", spam['label'].count())\nprint(\"Spam Count value:\", spam_count['Count'].count())","23303908":"from __future__ import print_function\nfrom nltk.corpus import stopwords\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.ensemble import AdaBoostClassifier\nfrom sklearn.svm import LinearSVC\nfrom sklearn.ensemble import AdaBoostClassifier\nfrom sklearn.metrics import f1_score,accuracy_score\nfrom sklearn.ensemble import VotingClassifier\nfrom sklearn.model_selection import KFold\nfrom sklearn.svm import SVC\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn import metrics\nfrom sklearn.metrics import make_scorer, accuracy_score, precision_score, recall_score, f1_score\nfrom scipy.stats import sem\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.metrics import mean_squared_error","55535223":"import nltk\nnltk.download('stopwords')","af563ee1":"#Removing stopwords of English\nstopset = set(stopwords.words(\"english\"))\nstopset","319d4ff8":"#Initialising Count Vectorizer\nvectorizer = CountVectorizer(stop_words=stopset,binary=True)\nvectorizer = CountVectorizer()\n    \nX = vectorizer.fit_transform(data.Text)\n# Extract target column 'label'\ny = data.numClass","5322ec75":"vectorizer.get_feature_names()","b23b80f9":"X","7d8b68c7":"doc_array = vectorizer.transform(data.Text).toarray()\ndoc_array","e7cb7800":"#Performing test train Split \nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30, train_size=0.70, random_state=None)\n\n# Show the results of the split\nprint(\"\\n\")\nprint(\"Training set has {} samples.\".format(X_train.shape[0]))\nprint(\"Testing set has {} samples.\".format(X_test.shape[0]))\nprint(\"\\n\")","3da1f19e":"objects = ('Multi-NB','SVM','KNN', 'RF')","1c4b4ad0":"def train_classifier(clf, X_train, y_train):    \n    clf.fit(X_train, y_train)","fd899dea":"# function to predict features \ndef predict_labels(clf, features):\n    return(clf.predict(features))","be0a8a93":"pip install catboost","4229b2b4":"# Initialize the four models\nA = MultinomialNB(alpha=1.0,fit_prior=True)\nB = SVC(kernel='linear',probability=True)\nC = KNeighborsClassifier(n_neighbors=1)\nD = RandomForestClassifier(n_estimators=10, max_depth=None, min_samples_split=2, random_state=None)","f628b1fb":"clf = [A,B,C,D]\nacc_score = [0,0,0,0]\naccuracy = [0,0,0,0]","1de3ba3d":"for a in range(0,4):\n    print(objects[a])\n    train_classifier(clf[a], X_train, y_train)\n    y_pred = predict_labels(clf[a],X_test)\n    pred_val = f1_score(y_test, y_pred)\n    acc_score[a]=accuracy_score(y_test, y_pred, normalize=True, sample_weight=None)\n    print(\"Accuracy in %:\")\n    print(acc_score[a]*100)\n    print(\"F1 Score\")\n    print(pred_val)\n    print(\"\\n\")\n    cm = confusion_matrix(y_test, y_pred)\n    class_label = [\"ham\", \"spam\"]\n    df_cm = pd.DataFrame(cm, index=class_label,columns=class_label)\n    sns.heatmap(df_cm, annot=True, fmt='d')\n    plt.title(\"Confusion Matrix\")\n    plt.xlabel(\"Predicted Label\")\n    plt.ylabel(\"True Label\")\n    plt.show()\n    print(\"Train accuracy: \", clf[a].fit(X_train, y_train).score(X_train, y_train))\n    print(\"mse test data: \",mean_squared_error(y_test, y_pred))\n    y_train_pred = predict_labels(clf[a],X_train)\n    print(\"mse train data: \",mean_squared_error(y_train, y_train_pred))\n    print(\"\\n\\n\")\n","2fadf0e7":"eclf = VotingClassifier(estimators=[ ('m1', clf[0]), ('m2', clf[1])], voting='soft', weights=[1,2])      \neclf = eclf.fit(X_train, y_train)                 \ny_pred = eclf.predict(X_test)\npred_val = f1_score(y_test, y_pred)\nacc = accuracy_score(y_test, y_pred)\nprint(\"Accuracy in 0,1 %:\")\nprint(acc*100)\nprint(\"F1 Score\")\nprint(pred_val)\nprint(\"\\n\")  \ncm = confusion_matrix(y_test, y_pred)\nclass_label = [\"ham\", \"spam\"]\ndf_cm = pd.DataFrame(cm, index=class_label,columns=class_label)\nsns.heatmap(df_cm, annot=True, fmt='d')\nplt.title(\"Confusion Matrix\")\nplt.xlabel(\"Predicted Label\")\nplt.ylabel(\"True Label\")\nplt.show()\nprint(\"\\n\\n\")\n\neclf = VotingClassifier(estimators=[ ('m1', clf[0]), ('m2', clf[2])], voting='soft', weights=[2,1])      \neclf = eclf.fit(X_train, y_train)                 \ny_pred = eclf.predict(X_test)\npred_val = f1_score(y_test, y_pred)\nacc=accuracy_score(y_test, y_pred)\nprint(\"Accuracy in 0,2 %:\")\nprint(acc*100)\nprint(\"F1 Score\")\nprint(pred_val)\nprint(\"\\n\")  \ncm = confusion_matrix(y_test, y_pred)\nclass_label = [\"ham\", \"spam\"]\ndf_cm = pd.DataFrame(cm, index=class_label,columns=class_label)\nsns.heatmap(df_cm, annot=True, fmt='d')\nplt.title(\"Confusion Matrix\")\nplt.xlabel(\"Predicted Label\")\nplt.ylabel(\"True Label\")\nplt.show()\nprint(\"\\n\\n\")\n\neclf = VotingClassifier(estimators=[ ('m1', clf[0]), ('m2', clf[3])], voting='soft', weights=[2,1])      \neclf = eclf.fit(X_train, y_train)                 \ny_pred = eclf.predict(X_test)\npred_val = f1_score(y_test, y_pred)\nacc=accuracy_score(y_test, y_pred)\nprint(\"Accuracy in 0,3 %:\")\nprint(acc*100)\nprint(\"F1 Score\")\nprint(pred_val)\nprint(\"\\n\")  \ncm = confusion_matrix(y_test, y_pred)\nclass_label = [\"ham\", \"spam\"]\ndf_cm = pd.DataFrame(cm, index=class_label,columns=class_label)\nsns.heatmap(df_cm, annot=True, fmt='d')\nplt.title(\"Confusion Matrix\")\nplt.xlabel(\"Predicted Label\")\nplt.ylabel(\"True Label\")\nplt.show()\nprint(\"\\n\\n\")\n\neclf = VotingClassifier(estimators=[ ('m1', clf[1]), ('m2', clf[2])], voting='soft', weights=[2,1])      \neclf = eclf.fit(X_train, y_train)                 \ny_pred = eclf.predict(X_test)\npred_val = f1_score(y_test, y_pred)\nacc=accuracy_score(y_test, y_pred)\nprint(\"Accuracy in 1,2 %:\")\nprint(acc*100)\nprint(\"F1 Score\")\nprint(pred_val)\nprint(\"\\n\")  \ncm = confusion_matrix(y_test, y_pred)\nclass_label = [\"ham\", \"spam\"]\ndf_cm = pd.DataFrame(cm, index=class_label,columns=class_label)\nsns.heatmap(df_cm, annot=True, fmt='d')\nplt.title(\"Confusion Matrix\")\nplt.xlabel(\"Predicted Label\")\nplt.ylabel(\"True Label\")\nplt.show()\nprint(\"\\n\\n\")\n\neclf = VotingClassifier(estimators=[ ('m1', clf[1]), ('m2', clf[3])], voting='soft', weights=[2,1])      \neclf = eclf.fit(X_train, y_train)                 \ny_pred = eclf.predict(X_test)\npred_val = f1_score(y_test, y_pred)\nacc=accuracy_score(y_test, y_pred)\nprint(\"Accuracy in 1,3 %:\")\nprint(acc*100)\nprint(\"F1 Score\")\nprint(pred_val)\nprint(\"\\n\")  \ncm = confusion_matrix(y_test, y_pred)\nclass_label = [\"ham\", \"spam\"]\ndf_cm = pd.DataFrame(cm, index=class_label,columns=class_label)\nsns.heatmap(df_cm, annot=True, fmt='d')\nplt.title(\"Confusion Matrix\")\nplt.xlabel(\"Predicted Label\")\nplt.ylabel(\"True Label\")\nplt.show()\nprint(\"\\n\\n\")\n\neclf = VotingClassifier(estimators=[ ('m1', clf[2]), ('m2', clf[3])], voting='soft', weights=[1,2])      \neclf = eclf.fit(X_train, y_train)                 \ny_pred = eclf.predict(X_test)\npred_val = f1_score(y_test, y_pred)\nacc=accuracy_score(y_test, y_pred)\nprint(\"Accuracy in 2,3 %:\")\nprint(acc*100)\nprint(\"F1 Score\")\nprint(pred_val)\nprint(\"\\n\")  \ncm = confusion_matrix(y_test, y_pred)\nclass_label = [\"ham\", \"spam\"]\ndf_cm = pd.DataFrame(cm, index=class_label,columns=class_label)\nsns.heatmap(df_cm, annot=True, fmt='d')\nplt.title(\"Confusion Matrix\")\nplt.xlabel(\"Predicted Label\")\nplt.ylabel(\"True Label\")\nplt.show()\nprint(\"\\n\\n\")\n\neclf = VotingClassifier(estimators=[ ('m1', clf[0]), ('m2', clf[1]), ('m3', clf[2])], voting='soft', weights=[2,3,1])      \neclf = eclf.fit(X_train, y_train)                 \ny_pred = eclf.predict(X_test)\npred_val = f1_score(y_test, y_pred)\nacc=accuracy_score(y_test, y_pred)\nprint(\"Accuracy in 0,1,2%:\")\nprint(acc*100)\nprint(\"F1 Score\")\nprint(pred_val)\nprint(\"\\n\")   \ncm = confusion_matrix(y_test, y_pred)\nclass_label = [\"ham\", \"spam\"]\ndf_cm = pd.DataFrame(cm, index=class_label,columns=class_label)\nsns.heatmap(df_cm, annot=True, fmt='d')\nplt.title(\"Confusion Matrix\")\nplt.xlabel(\"Predicted Label\")\nplt.ylabel(\"True Label\")\nplt.show()\nprint(\"\\n\\n\")\n\neclf = VotingClassifier(estimators=[ ('m1', clf[0]), ('m2', clf[2]), ('m3', clf[3])], voting='soft', weights=[3,1,2])      \neclf = eclf.fit(X_train, y_train)                 \ny_pred = eclf.predict(X_test)\npred_val = f1_score(y_test, y_pred)\nacc=accuracy_score(y_test, y_pred)\nprint(\"Accuracy in 0,2,3 %:\")\nprint(acc*100)\nprint(\"F1 Score\")\nprint(pred_val)\nprint(\"\\n\")  \ncm = confusion_matrix(y_test, y_pred)\nclass_label = [\"ham\", \"spam\"]\ndf_cm = pd.DataFrame(cm, index=class_label,columns=class_label)\nsns.heatmap(df_cm, annot=True, fmt='d')\nplt.title(\"Confusion Matrix\")\nplt.xlabel(\"Predicted Label\")\nplt.ylabel(\"True Label\")\nplt.show()\nprint(\"\\n\\n\")\n\neclf = VotingClassifier(estimators=[ ('m1', clf[1]), ('m2', clf[2]), ('m3', clf[3])], voting='soft', weights=[3,1,2])      \neclf = eclf.fit(X_train, y_train)                 \ny_pred = eclf.predict(X_test)\npred_val = f1_score(y_test, y_pred)\nacc=accuracy_score(y_test, y_pred)\nprint(\"Accuracy in 1,2,3 %:\")\nprint(acc*100)\nprint(\"F1 Score\")\nprint(pred_val)\nprint(\"\\n\")  \ncm = confusion_matrix(y_test, y_pred)\nclass_label = [\"ham\", \"spam\"]\ndf_cm = pd.DataFrame(cm, index=class_label,columns=class_label)\nsns.heatmap(df_cm, annot=True, fmt='d')\nplt.title(\"Confusion Matrix\")\nplt.xlabel(\"Predicted Label\")\nplt.ylabel(\"True Label\")\nplt.show()\nprint(\"\\n\\n\")\n\neclf = VotingClassifier(estimators=[ ('m1', clf[0]), ('m2', clf[1]), ('m3', clf[2]), ('m4', clf[3])], voting='soft', weights=[2,2,1,1])      \neclf = eclf.fit(X_train, y_train)                 \ny_pred = eclf.predict(X_test)\npred_val = f1_score(y_test, y_pred)\nacc=accuracy_score(y_test, y_pred)\nprint(\"Accuracy in all %:\")\nprint(acc*100)\nprint(\"F1 Score\")\nprint(pred_val)\nprint(\"\\n\")  \ncm = confusion_matrix(y_test, y_pred)\nclass_label = [\"ham\", \"spam\"]\ndf_cm = pd.DataFrame(cm, index=class_label,columns=class_label)\nsns.heatmap(df_cm, annot=True, fmt='d')\nplt.title(\"Confusion Matrix\")\nplt.xlabel(\"Predicted Label\")\nplt.ylabel(\"True Label\")\nplt.show()\nprint(\"\\n\\n\")\n","a47bda3f":"y_pos = np.arange(len(objects))\ny_val = [ x for x in acc_score]","cf297585":"plt.bar(y_pos,y_val, align='center', alpha=0.7)\nplt.xticks(y_pos, objects)\nplt.ylabel('Accuracy Score')\nplt.title('Accuracy of Models')\nplt.show()","8e5587a4":"for a in range(0,4):\n    print(objects[a])\n    kfolds = KFold(n_splits=10)\n    score = cross_val_score(clf[a], X, y, cv=kfolds)\n    print(\"Accuracy:\",(score.mean()*100), \"standard_error:\", sem(score))\n    accuracy[a]=score.mean()*100\n\ny_pos = np.arange(len(objects))\ny_val = [ x for x in accuracy]\nplt.bar(y_pos,y_val, align='center', alpha=0.7)\nplt.xticks(y_pos, objects)\nplt.ylabel('Accuracy Score')\nplt.title('Accuracy of Models')\nplt.show()","d2f462cd":"kfolds = KFold(n_splits=10)\neclf = VotingClassifier(estimators=[ ('m1', clf[0]), ('m2', clf[1])], voting='soft', weights=[1,2])      \nscore = cross_val_score(eclf, X, y, cv=kfolds)\nprint(\"Accuracy:\",(score.mean()*100), \"standard_error:\", sem(score))","f11b941f":"print(y.shape)","a1bb0244":"nums = np.random.choice([0, 1], size=5572)\naccuracy=accuracy_score(y, nums)\nprint(\"accuracy: \",accuracy*100)","d62aee49":"Training and testing sets:\n\nNow that we have understood how to deal with the Bag of Words problem we can get back to our dataset and proceed with our analysis. Our first step in this regard would be to split our dataset into a training and testing set so we can test our model later.\n\n    Instructions: Split the dataset into a training and testing set by using the train_test_split method in sklearn. Split the data using the following variables:\n\n        X_train is our training data for the 'text' column.\n        y_train is our training data for the 'label' column\n        X_test is our testing data for the 'text' column.\n        y_test is our testing data for the 'label' column Print out the number of rows we have in each our training and testing data.\n\n","eca4905b":"Training and Evaluating Models","7223e042":"DATA EXPLORATION","3bac583e":"CHANCE LEVEL","10503ce8":"Data Preprocessing:\n\nNow that we have a basic understanding of what our dataset looks like, lets convert our labels to binary variables, 0 to represent 'ham'(i.e. not spam) and 1 to represent 'spam' for ease of computation.\n\nYou might be wondering why do we need to do this step? The answer to this lies in how scikit-learn handles inputs. Scikit-learn only deals with numerical values and hence if we were to leave our label values as strings, scikit-learn would do the conversion internally(more specifically, the string labels will be cast to unknown float values).\n\nOur model would still be able to make predictions if we left our labels as strings but we could have issues later when calculating performance metrics, for example when calculating our precision and recall scores. Hence, to avoid unexpected 'gotchas' later, it is good practice to have our categorical values be fed into our model as integers.\n\n\n    Convert the values in the 'label' column to numerical values using map method as follows: {'ham':0, 'spam':1} This maps the 'ham' value to 0 and the\n        ' spam' value to 1.\n    Also, to get an idea of the size of the dataset we are dealing with, print out number of rows and columns using 'shape'.\n","a2025655":"Preparing the Data","84ef59a0":"Is there any difference in message length between spam and ham?","c24663df":"Bag of words:\n    \nWhat we have here in our data set is a large collection of text data (5,572 rows of data). Most ML algorithms rely on numerical data to be fed into them as input, and email\/sms messages are usually text heavy.\n\nHere we'd like to introduce the Bag of Words(BoW) concept which is a term used to specify the problems that have a 'bag of words' or a collection of text data that needs to be worked with. The basic idea of BoW is to take a piece of text and count the frequency of the words in that text. It is important to note that the BoW concept treats each word individually and the order in which the words occur does not matter.\n\nUsing a process which we will go through now, we can convert a collection of documents to a matrix, with each document being a row and each word(token) being the column, and the corresponding (row,column) values being the frequency of occurrence of each word or token in that document.\n\nNote:\n\n    The CountVectorizer method automatically converts all tokenized words to their lower case form so that it does not treat words like 'He' and 'he'\n        differently. It does this using the lowercase parameter which is by default set to True.\n    It also ignores all punctuation so that words followed by a punctuation mark (for example: 'hello!') are not treated differently than the same words not\n        prefixed or suffixed by a punctuation mark (for example: 'hello'). It does this using the token_pattern parameter which has a default regular \n        expression which selects tokens of 2 or more alphanumeric characters.\n    The third parameter to take note of is the stop_words parameter. Stop words refer to the most commonly used words in a language. They include words like \n        'am', 'an', 'and', 'the' etc. By setting this parameter value to english, CountVectorizer will automatically ignore all words(from our input text)\n        that are found in the built in list of english stop words in scikit-learn. This is extremely helpful as stop words can skew our calculations when we\n        are trying to find certain key words that are indicative of spam.\n","3e748fa4":"frequency_matrix = pd.DataFrame(doc_array, columns = vectorizer.get_feature_names())\nfrequency_matrix.head()","5c4be06c":"fig, ax = plt.subplots(figsize=(17,5))\nspam_count['Count'].value_counts().sort_index().plot(ax=ax, kind='bar',facecolor='red');\nham_count['Count'].value_counts().sort_index().plot(ax=ax, kind='bar',facecolor='green');"}}