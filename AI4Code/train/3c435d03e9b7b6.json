{"cell_type":{"1c63e6b1":"code","e522f363":"code","fb6fac4a":"code","273120f4":"code","8dcccdb2":"code","cac5ddab":"code","f720b6cc":"code","5a6c606b":"code","350d2125":"code","f97cedba":"code","0f50e34d":"code","1ffaf25d":"code","fa9981ca":"code","6d2f64bc":"code","f7d74302":"code","c60208c6":"code","3d30d200":"code","2b6c41da":"markdown","60171b42":"markdown","b3e7161a":"markdown","fc9bc576":"markdown","5bf0d337":"markdown","3e297efd":"markdown","e6d20832":"markdown","bef2f5da":"markdown","4bf20a62":"markdown","77f96a21":"markdown","626534e4":"markdown","fabf6a72":"markdown","fa7a5f79":"markdown","6f649cdb":"markdown","34b5d24e":"markdown","49617127":"markdown","1426d716":"markdown","acf5d5fe":"markdown","875bd719":"markdown","cc9d347a":"markdown","0f409412":"markdown","6ad685ac":"markdown"},"source":{"1c63e6b1":"# For example matching a time format\n\nimport re\n\nline = \"Jan  3 07:57:39 Kali sshd[1397]: Failed password 02:12:36 for root from 172.16.12.55 port 34380 ssh2\"\nregex = \"\\d+\"\nresult = re.findall(regex, line) # returns all of the digit matches as a list\nfirst_result = re.findall(regex, line)[0] # returns first match\nprint(result)\nprint(first_result)","e522f363":"word = \"I just realized how interesting coding is\"\nregex = \"\\w+\"\nresult = re.findall(regex, word) # returns each word as a list\nprint(result)","fb6fac4a":"word = \"The colors of the rainbow has many colours and the rainbow does not have a single colour\"\nregex = \"colou?rs?\" # ? before a string signifies that the string is optional\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","273120f4":"word = \"I just realized how interesting coding is\"\nregex = \"\\w{3}\"\nresult = re.findall(regex, word) # returns the first three character of each word as a list\nprint(result)","8dcccdb2":"word = \"[Google](http:\/\/google.com), [test] \\n [itp](http:itp.nyu.edu)\"\nregex = \"\\[.*\\]\" # ? before a string signifies that the string is optional\nresult = re.findall(regex, word) # return s all of the matches as a list\nprint(result)","cac5ddab":"word = \"[Google](http:\/\/google.com), [test] \\n [itp](http:itp.nyu.edu)\"\nregex = \"\\[.*?\\]\" # ? before a string signifies that the string is optional\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","f720b6cc":"word = \"The colors of the rainbow has many colours and the rainbow does not have a single colour\"\n# regex = \"\\w+$\" # means 1 or more word characters at the end of a line.\n# regex = \"^\\w+$\" # means 1 or more word characters at the beginning and end of a line (equally just a line with just one word).\nregex = \"^\\w+\" # means the beginning of a line followed by 1 or more word characters\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","5a6c606b":"word = \"The colors of the rainbow has many colours and the rainbow does not have a single colour\"\nregex = \"\\\\b\\w{3}\\\\b\" # this matches 3 word characters specifically\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","350d2125":"word = \"The colors of the rainbow has many colours and the rainbow does not have a single colour\"\nregex = \"\\\\b\\w{5,9}\\\\b\" # this matches 5 to 9 word characters specifically\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","f97cedba":"# shallow copy copies by referencing the original value, while deep copy copies with no reference\nimport copy \nx = [1,[2]] \ny = copy.copy(x) \nz = copy.deepcopy(x) \ny is z ","0f50e34d":"word = \"lynk is not the correct spelling of link\"\nregex = \"l[yi]nk\" # this matches either link or lynk\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","1ffaf25d":"word = \"I am in my 400L, I am currently XX years of age in the year 2018\"\nregex = \"[0-3]{2}\" # this matches characters from 0 to 3 and is max of two characters long\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","fa9981ca":"word = \"I am in my 400L, I am currently XX years of age in the year 2018\"\nregex = \"[^0-3]{2}\" # this matches characters from 0 to 3 and is max of two characters long\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","6d2f64bc":"word = \"I am in my 400L, I am currently XX years of age in the year 2018. My email addresses are stanleydukor@gmail.com, stanleydukor@yahoo.com, stanleydukor@hotmail.edu\"\nregex = \"\\w+@\\w+\\.(?:com|net|org|live|edu)\" # this matches email addresses\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","f7d74302":"word = \"These are some phone numbers 917-555-1234. Also, you can call me at 646.555.1234 and of course I'm always reachable at (212)867-5509\"\nregex = \"\\(?\\d{3}[-.)]\\d{3}[-.]\\d{4}\" # this matches phone numbers\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","c60208c6":"word = \"[Google](http:\/\/google.com), [test] \\n [itp](http:itp.nyu.edu)\"\nregex = \"\\[.*?\\]\\(http.*?\\)\" # ? matches the name of a link and the link itself\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","3d30d200":"word = \"2017-07-05 16:04:18.000000\"\nregex = \"\\d{4}-\\d{2}-\\d{2}\\s+\\d{2}:\\d{2}:\\d{2}\"\nresult = re.findall(regex, word) # returns all of the matches as a list\nprint(result)","2b6c41da":"- To replace with the name of the link and the link itself in an html format, we first group them (i.e. \"\\[(.*?)\\]\\((http.*?)\\)\" ","60171b42":"### Position","b3e7161a":"- '\\d' matches any character between 0 and 9 where d means digit\n- '\\w' matches any character A-Za-z0-9 where w means word\n- '\\s' matches any whitespace (can match a space, a tab etc.)\n- '.' matches any character whatsoever\n- Capitalizing 'd' or 'w' or 's' makes the expression the opposite\n","fc9bc576":"## Character classes","5bf0d337":"- Character classes are stuffs that appear in between square brackets.\n- Each string inside the square brackets are alternatives to each other\n- Also, characters in the square brackets do not possess there meta characteristics, instead they are just literal characters.","3e297efd":"### Quantifiers","e6d20832":"- The only two special characters inside the square brackets are the '-' and '^'\n- '-' inside a square brackets can be used when we want to get a range of strings, e.g. 'a-z1-9' matches any character from a to z and from 1 to 9","bef2f5da":" ### Single Characters","4bf20a62":"- In the example below, we get to see that '.*' is greedy by default. It will continue to match until it can no more match ","77f96a21":"- Suppose we have a stringm '212-555-1234', and we want to match it, we use:\n    \"\\d{3}-(\\d{3})-(\\d{4})\"\n- Note that the whole string is automatically grouped by regex as \"GROUP 0\". \n- Also, using a bracket in this context signifies that the content of the bracket is \"Group 1\" and \"Group 2\" respectively.\n- Accessing each group is with the use of a '$' or '\\'. e.g. $1 or \\1 signifies 'GROUP 1'","626534e4":"## Meta characters","fabf6a72":"- '.' means any character, and '*' means 0 or more \n- For example, if we write a regular expression \"rainbow.*\", it means all data that begins with rainbow, could be rainbow123, rainbow boy, rainbow city etc.\n- '.*' is a wildcard that matches the universe","fa7a5f79":"- A sequence of characters that defines a search pattern.\n- '\\d' means any character between 0 and 9 where d is digit (Meta character)\n- Literal characters are characters that are specified and will always occur.\n- Meta characters are characters that are more generalized not specific.\n- E.g. to match a number in the format \"917-55-1234\", the regular expression will be \"\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d\"","6f649cdb":"- They are meta characters that matches the position of a character in the string itself. \n- '^' means beginning\n- '$' means end\n- '\\b' word boundary (it is advisable to use escape before it (i.e. \"\\\\b\") otherwise \\b means a backspace characters","34b5d24e":"- '^' inside a square brackets can be used when we want to get anything that is not amongst the remaining characters after it.\n- Note that if '^' is not located at the beginning, after the first pair of square brackets, then it isn't a special\/meta character again, but a literal one.","49617127":"- Note that '?' paired with a quantifier makes '.*' not greedy","1426d716":"- They are meta characters that modify the previous character in a regular expression. (e.g. how many of those things you want to match in a row)\n- '*' matches 0 or more \n- '+' matches 1 or more \n- '?' matches 0 or 1 (optional)\n- {n} matches all n\n- {min, max}\n\nFor example, '\\w\\w\\w' means match all first 3 words. Also, '\\w{3}' does the same thing","acf5d5fe":"## Introduction","875bd719":"### Alternation","cc9d347a":"- We know that in Character classes, each string inside the square brackets are alternatives to each other, which is a limitation.\n- With alternation, multiple strings can be alternatives to each other.\n- For example, in '(com|net)', we mean 'com' or 'net'.","0f409412":"# Regular Expressions ","6ad685ac":"## Capturing Groups"}}