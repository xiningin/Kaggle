{"cell_type":{"d9f9c9a6":"code","005098f6":"code","0c2e9206":"code","69002700":"code","1cfd0f58":"code","5435da6c":"code","01e00292":"code","ff44f9f5":"code","b7aee42a":"code","f504518b":"code","f2e6ba92":"code","35b22fdc":"code","f3940fae":"code","65885690":"code","249c14a8":"code","9b2e5f35":"code","5aced103":"code","2f07caff":"code","7d0bc03a":"code","86c340ae":"code","178b0897":"code","fbddd5d5":"code","252a6199":"code","1e8432ec":"code","40d61e36":"markdown","15b52f96":"markdown","5522cc02":"markdown","7da0ff07":"markdown"},"source":{"d9f9c9a6":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","005098f6":"import seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn import preprocessing\nfrom sklearn.preprocessing import LabelEncoder\n# Reading the training dataset in a dataframe using Pandas\ndf = pd.read_csv(\"\/kaggle\/input\/loan-predication\/train_u6lujuX_CVtuZ9i (1).csv\")\ntest = pd.read_csv(\"\/kaggle\/input\/loan-predication\/train_u6lujuX_CVtuZ9i (1).csv\")\n# Reading the test dataset in a dataframe using Pandas\n","0c2e9206":"df.head(5)","69002700":"# Store total number of observation in training dataset\ndf_length =len(df)\n# Store total number of columns in testing data set\ntest_col = len(test.columns)","1cfd0f58":"# Impute missing values for Gender\ndf['Gender'].fillna(df['Gender'].mode()[0],inplace=True)\n\n# Impute missing values for Married\ndf['Married'].fillna(df['Married'].mode()[0],inplace=True)\n\n# Impute missing values for Dependents\ndf['Dependents'].fillna(df['Dependents'].mode()[0],inplace=True)\n\n# Impute missing values for Credit_History\ndf['Credit_History'].fillna(df['Credit_History'].mode()[0],inplace=True)\n\n# Convert all non-numeric values to number\ncat=['Gender','Married','Dependents','Education','Self_Employed','Credit_History','Property_Area']\n\nfor var in cat:\n    le = preprocessing.LabelEncoder()\n    df[var]=le.fit_transform(df[var].astype('str'))\ndf.dtypes","5435da6c":"#Combining both train and test dataset\n\n#Create a flag for Train and Test Data set\ndf['Type']='Train' \ntest['Type']='Test'\nfullData = pd.concat([df,test], axis=0)\n\n#Look at the available missing values in the dataset\nfullData.isnull().sum()","01e00292":"#Identify categorical and continuous variables\nID_col = ['Loan_ID']\ntarget_col = [\"Loan_Status\"]\ncat_cols = ['Credit_History','Dependents','Gender','Married','Education','Property_Area','Self_Employed']","ff44f9f5":"# Replace missing value of Self_Employed with more frequent category\ndf['Self_Employed'].fillna('No',inplace=True)","b7aee42a":"#Imputing Missing values with mean for continuous variable\nfullData['LoanAmount'].fillna(fullData['LoanAmount'].mean(), inplace=True)\nfullData['Loan_Amount_Term'].fillna(fullData['Loan_Amount_Term'].mean(), inplace=True)\nfullData['ApplicantIncome'].fillna(fullData['ApplicantIncome'].mean(), inplace=True)\nfullData['CoapplicantIncome'].fillna(fullData['CoapplicantIncome'].mean(), inplace=True)\n\n#Imputing Missing values with mode for categorical variables\nfullData['Gender'].fillna(fullData['Gender'].mode()[0], inplace=True)\nfullData['Married'].fillna(fullData['Married'].mode()[0], inplace=True)\nfullData['Dependents'].fillna(fullData['Dependents'].mode()[0], inplace=True)\nfullData['Loan_Amount_Term'].fillna(fullData['Loan_Amount_Term'].mode()[0], inplace=True)\nfullData['Credit_History'].fillna(fullData['Credit_History'].mode()[0], inplace=True)","f504518b":"# Summary of numerical variables for training data set\ndf.describe()","f2e6ba92":"# Get the unique values and their frequency of variable Property_Area\ndf['Property_Area'].value_counts()","35b22fdc":"# Box Plot for understanding the distributions and to observe the outliers.\n%matplotlib inline\n\n# Histogram of variable ApplicantIncome\ndf['ApplicantIncome'].hist()","f3940fae":"# Box Plot for variable ApplicantIncome by variable Education of training data set\ndf.boxplot(column='ApplicantIncome', by = 'Education')","65885690":"# Box Plot for variable LoanAmount of training data set\ndf.boxplot(column='LoanAmount')","249c14a8":"# Box Plot for variable LoanAmount by variable Gender of training data set\ndf.boxplot(column='LoanAmount', by = 'Gender')","9b2e5f35":"# Loan approval rates in absolute numbers\nloan_approval = df['Loan_Status'].value_counts()['Y']\nprint(loan_approval)","5aced103":"# Credit History and Loan Status\npd.crosstab(df ['Credit_History'], df ['Loan_Status'], margins=True)","2f07caff":"#Function to output percentage row wise in a cross table\ndef percentageConvert(ser):\n    return ser\/float(ser[-1])\n\n# # Loan approval rate for customers having Credit_History (1)\n#df['Y'] = pd.crosstab(df [\"Credit_History\"], df [\"Loan_Status\"], margins=True).apply(percentageConvert, axis=1)\n#loan_approval_with_Credit_1 = df['Y'][1]\n#print(loan_approval_with_Credit_1*100)","7d0bc03a":"df.head()","86c340ae":"# Add both ApplicantIncome and CoapplicantIncome to TotalIncome\ndf['TotalIncome'] = df['ApplicantIncome'] + df['CoapplicantIncome']\n\n# Looking at the distribtion of TotalIncome\ndf['LoanAmount'].hist(bins=20)","178b0897":"# Perform log transformation of TotalIncome to make it closer to normal\ndf['LoanAmount_log'] = np.log(df['LoanAmount'])\n\n# Looking at the distribtion of TotalIncome_log\ndf['LoanAmount_log'].hist(bins=20)","fbddd5d5":"#Create a new column as Total Income\n\nfullData['TotalIncome']=fullData['ApplicantIncome'] + fullData['CoapplicantIncome']\n\nfullData['TotalIncome_log'] = np.log(fullData['TotalIncome'])\n\n#Histogram for Total Income\nfullData['TotalIncome_log'].hist(bins=20) ","252a6199":"fullData['Total_Income']=fullData['ApplicantIncome']+fullData['CoapplicantIncome']\nbins=[0,2500,4000,6000,81000]\ngroup=['Low','Average','High','Very high']\nfullData['Total_Income_bin']=pd.cut(fullData['Total_Income'],bins,labels=group)\nTotal_Income_bin=pd.crosstab(fullData['Total_Income_bin'],fullData['Loan_Status'])\nTotal_Income_bin.div(Total_Income_bin.sum(1).astype(float), axis=0).plot(kind=\"bar\",stacked=True)\nplt.xlabel('Total_Income')\nP=plt.ylabel('Percentage')","1e8432ec":"matrix = fullData.corr()\nf, ax = plt.subplots(figsize=(9,6))\nsns.heatmap(matrix,vmax=.8,square=True,cmap=\"BuPu\", annot = True)","40d61e36":"- The extreme values are practically possible, i.e. some people might apply for high value loans due to specific needs. So instead of treating them as outliers, let\u2019s try a log transformation to nullify their effect:","15b52f96":"Understanding Distribution of categorical Variables","5522cc02":"We see that the most correlate variables are (ApplicantIncome \u2014 LoanAmount) and (Credit_History \u2014 Loan_Status). LoanAmount is also correlated with CoapplicantIncome.","7da0ff07":"We can see that Proportion of loans getting approved for applicants having low Total_Income is very less compared to that of applicants with Average, High & Very High Income."}}