{"cell_type":{"fd656909":"code","e1080a9f":"code","21943c0b":"code","8daa9b61":"code","c1c55359":"code","6db8c567":"code","a6d55410":"code","4e7f011c":"code","34546a4c":"code","68b584b2":"code","aefff31c":"code","65e309cb":"code","eb147ad9":"code","9e349e60":"code","3d6d8053":"code","a0ba96f3":"code","3aa8d034":"code","d32ab9fc":"code","9bc600bf":"code","3779ded8":"code","7709174e":"code","80c06b68":"code","54e6b0e2":"code","f6772640":"code","886a5d6b":"code","4fa4bdb8":"code","26448d40":"code","befe5e83":"code","29768bf3":"code","2e8e5cbe":"code","48542a71":"code","eb038cc1":"code","9e62f670":"code","4144be46":"code","17d1564b":"code","ef47d01d":"code","443e739b":"code","1e4105dd":"code","35c9a215":"code","7d235582":"code","8a61dd86":"code","7bfe7ea4":"code","233969bc":"code","ab6e51c7":"code","ab82d430":"code","fbeb78a7":"code","08cf8b32":"code","f6c03697":"code","9723ceed":"code","eafca5bf":"code","5d590927":"code","3c550cff":"code","97dad079":"code","95067b26":"code","12d6e746":"code","a049c3cf":"code","4cb68436":"code","a9a8b094":"code","14f91e07":"code","9991248f":"code","1639a6d6":"code","592e3882":"code","81f463e8":"code","78ad1750":"code","db306ce7":"code","c55d72c3":"code","67ad8296":"code","e705b594":"code","dae13fad":"code","de336f69":"code","25439092":"code","84d34ac9":"code","7b6b3efd":"code","0bd00228":"code","252ed261":"code","52d16e46":"code","47a07fcb":"code","ce5eae22":"code","4bbb42cf":"code","cdf84a4b":"code","46eeb3ff":"code","49aa1cba":"code","33a73a0e":"code","fe58206c":"code","e52dda31":"code","21cbd85f":"code","79d8fc06":"code","626aee01":"code","14609471":"code","51a0efac":"code","463f7593":"code","4286d7ba":"markdown","cd16895e":"markdown","5f7402b4":"markdown","31b3cc8a":"markdown","36383fb5":"markdown","d11c518a":"markdown","6e574a51":"markdown","644f0c38":"markdown","4069f157":"markdown","d330f20b":"markdown","e65f2eb0":"markdown","96dda4ca":"markdown","55300198":"markdown","d321c987":"markdown","bf1da5ee":"markdown","3483e899":"markdown","df2f3a44":"markdown","e98919a3":"markdown","e78d012c":"markdown","fe903ed3":"markdown","0e2dbf37":"markdown","518ce4a5":"markdown","5b1355b2":"markdown","a004bf1c":"markdown","33d12fba":"markdown","342d91c3":"markdown","525c4ef0":"markdown","bcca654d":"markdown","186a8fb3":"markdown","cf762388":"markdown","418784c7":"markdown","21270741":"markdown"},"source":{"fd656909":"import numpy as np \nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly.offline as pyo\nimport plotly.express as px\nimport plotly.graph_objects as go\npyo.init_notebook_mode()\n%matplotlib inline","e1080a9f":"df = pd.read_csv('\/kaggle\/input\/travel-insurance-prediction-data\/TravelInsurancePrediction.csv')\ndf","21943c0b":"df.columns","8daa9b61":"df.drop(columns=['Unnamed: 0'],inplace=True)\ndf","c1c55359":"df.info()","6db8c567":"df.describe()","a6d55410":"df.isna().sum()","4e7f011c":"df.shape","34546a4c":"for i in df.columns:\n    print(i,\"column's unique values are:\",df[i].unique())","68b584b2":"for i in df.columns:\n    print(i,\"column's total unique values are:\",df[i].nunique())","aefff31c":"def value_counts_to_dataframe(col):\n    temp_df = df[col].value_counts().rename_axis(col).reset_index(name='counts')\n    temp_df = temp_df.sort_values(by=[col])\n    temp_df = temp_df.reset_index()\n    temp_df.drop(columns=['index'],inplace=True)\n    return temp_df","65e309cb":"temp_df = value_counts_to_dataframe('Age')\npx.bar(data_frame = temp_df, x = 'Age', y = 'counts', color = 'counts', template = 'plotly_dark', \n       title = 'Total number of people with unique age values')","eb147ad9":"temp_df = value_counts_to_dataframe('Employment Type')\npx.bar(data_frame = temp_df, x = 'counts', y = 'Employment Type', color = 'counts', template = 'plotly_dark', \n       title = 'Total number of people who are self employed or working in government sector')","9e349e60":"temp_df = value_counts_to_dataframe('GraduateOrNot')\npx.bar(data_frame = temp_df, x = 'counts', y = 'GraduateOrNot', color = 'counts', template = 'plotly_dark', \n       title = 'Total number of people who are graduated or not')","3d6d8053":"temp_df = value_counts_to_dataframe('FrequentFlyer')\npx.bar(data_frame = temp_df, x = 'counts', y = 'FrequentFlyer', color = 'counts', template = 'plotly_dark', \n       title = 'Total number of people who are frequent flyers or not')","a0ba96f3":"temp_df = value_counts_to_dataframe('EverTravelledAbroad')\npx.bar(data_frame = temp_df, x = 'counts', y = 'EverTravelledAbroad', color = 'counts', template = 'plotly_dark', \n       title = 'Total number of people who have travelled abroad or not')","3aa8d034":"temp_df = value_counts_to_dataframe('AnnualIncome')\npx.bar(data_frame = temp_df, x = 'AnnualIncome', y = 'counts', color = 'counts', template = 'plotly_dark', \n       title = 'Total number of people with unique annual income')","d32ab9fc":"temp_df = value_counts_to_dataframe('FamilyMembers')\npx.bar(data_frame = temp_df, x = 'FamilyMembers', y = 'counts', color = 'counts', template = 'plotly_dark', \n       title = 'Total number of people with unique family members')","9bc600bf":"temp_df = value_counts_to_dataframe('ChronicDiseases')\npx.bar(data_frame = temp_df, x = 'ChronicDiseases', y = 'counts', color = 'counts', template = 'plotly_dark', \n       title = 'Total number of people with chronic diseases or not')","3779ded8":"temp_df = value_counts_to_dataframe('Employment Type')\nvalues_column = temp_df.loc[:,'counts']\nvalues = values_column.values\nfig = go.Figure(data=[go.Pie(labels=temp_df,values=values, hole=.3)])\nfig.update_layout(template='plotly_dark',title_text='Percentage of people who are working in private sector and government sector')\nfig.show()","7709174e":"temp_df = value_counts_to_dataframe('GraduateOrNot')\nvalues_column = temp_df.loc[:,'counts']\nvalues = values_column.values\nfig = go.Figure(data=[go.Pie(labels=temp_df,values=values, hole=.3)])\nfig.update_layout(template='plotly_dark',title_text='Percentage of people who are graduated or not')\nfig.show()","80c06b68":"temp_df = value_counts_to_dataframe('FrequentFlyer')\nvalues_column = temp_df.loc[:,'counts']\nvalues = values_column.values\nfig = go.Figure(data=[go.Pie(labels=temp_df,values=values, hole=.3)])\nfig.update_layout(template='plotly_dark',title_text='Percentage of people who are frequent flyer or not')\nfig.show()","54e6b0e2":"temp_df = value_counts_to_dataframe('EverTravelledAbroad')\nvalues_column = temp_df.loc[:,'counts']\nvalues = values_column.values\nfig = go.Figure(data=[go.Pie(labels=temp_df,values=values, hole=.3)])\nfig.update_layout(template='plotly_dark',title_text='Percentage of people who have travelled abroad or not')\nfig.show()","f6772640":"px.pie(df, \n       names='TravelInsurance', \n       color='TravelInsurance', \n       color_discrete_map={1:'#aee8fc', 0:'#aaaae4'}, \n       title='How many people have bought the insurance?',\n       template='plotly_dark'\n      )","886a5d6b":"grp1 = df.groupby('Employment Type')\ntemp_df = grp1.get_group('Government Sector')\ntemp_df","4fa4bdb8":"def value_counts_to_dataframe(col):\n    _df = temp_df[col].value_counts().rename_axis(col).reset_index(name='counts')\n    _df = _df.sort_values(by=[col])\n    _df = _df.reset_index()\n    _df.drop(columns=['index'],inplace=True)\n    return _df","26448d40":"x = value_counts_to_dataframe('GraduateOrNot')\nvalues_column = x.loc[:,'counts']\nvalues = values_column.values\nfig = go.Figure(data=[go.Pie(labels=x,values=values, hole=.3)])\nfig.update_layout(template='plotly_dark',title_text='Percentage of people who are in government sector and are graduated')\nfig.show()","befe5e83":"temp_df = grp1.get_group('Private Sector\/Self Employed')\ntemp_df","29768bf3":"x = value_counts_to_dataframe('GraduateOrNot')\nvalues_column = x.loc[:,'counts']\nvalues = values_column.values\nfig = go.Figure(data=[go.Pie(labels=x,values=values, hole=.3)])\nfig.update_layout(template='plotly_dark',title_text='Percentage of people who are in private sector and are graduated')\nfig.show()","2e8e5cbe":"data_emp_fly = pd.crosstab(df['Employment Type'],df['FrequentFlyer'])\ndata_emp_fly","48542a71":"data_emp_abr = pd.crosstab(df['Employment Type'],df['EverTravelledAbroad'])\ndata_emp_abr","eb038cc1":"data_emp_ins = pd.crosstab(df['Employment Type'],df['TravelInsurance'])\ndata_emp_ins","9e62f670":"px.histogram(df, \n             x='AnnualIncome', \n             color='TravelInsurance', \n             color_discrete_map={1:'#F30C0C', 0:'#0C23F3'}, \n             title='Role of annual income in purchasing travel insurance',\n             template='plotly_dark'\n            )","4144be46":"px.histogram(df, \n             x='FamilyMembers', \n             color='TravelInsurance', \n             color_discrete_map={1:'#F30C0C', 0:'#0C23F3'}, \n             title='Role of number of family members in purchasing travel insurance',\n             template='plotly_dark'\n            )","17d1564b":"px.histogram(df, \n             x='EverTravelledAbroad', \n             color='TravelInsurance', \n             color_discrete_map={1:'#F30C0C', 0:'#0C23F3'}, \n             title='Role of number of people who have travelled abroad or not purchasing travel insurance',\n             template='plotly_dark'\n            )","ef47d01d":"px.histogram(df, \n             x='FrequentFlyer', \n             color='TravelInsurance', \n             color_discrete_map={1:'#F30C0C', 0:'#0C23F3'}, \n             title='Role of number of people who are frequent flyers or not in purchasing travel insurance',\n             template='plotly_dark'\n            )","443e739b":"px.histogram(df, \n             x='Age', \n             color='TravelInsurance', \n             color_discrete_map={1:'#F30C0C', 0:'#0C23F3'}, \n             title='Role of age in purchasing travel insurance',\n             template='plotly_dark'\n            )","1e4105dd":"px.histogram(df, \n             x='GraduateOrNot', \n             color='TravelInsurance', \n             color_discrete_map={1:'#F30C0C', 0:'#0C23F3'}, \n             title='Role of education in purchasing travel insurance',\n             template='plotly_dark'\n            )","35c9a215":"px.histogram(df, \n             x='ChronicDiseases', \n             color='TravelInsurance', \n             color_discrete_map={1:'#F30C0C', 0:'#0CF3CD'}, \n             title='Role of health in purchasing travel insurance',\n             template='plotly_dark'\n            )","7d235582":"temp_df = df[[\"AnnualIncome\",\"Age\",\"Employment Type\"]]\ntemp_df","8a61dd86":"g = temp_df.groupby('Age')\ninterim_df = g.mean().reset_index()\npx.bar(\n         interim_df,\n         x='Age', \n         y='AnnualIncome', \n         color_discrete_sequence=['#0CF3CD'], \n         title='Average income by age',\n         template='plotly_dark'\n      )","7bfe7ea4":"income_greater = temp_df[temp_df['AnnualIncome']>1300000].groupby('Age').size()\nincome_greater = income_greater.reset_index(name='Total people whose Annual Income is greater than 1.3M') \npx.bar(income_greater,\n         x='Age',\n         y='Total people whose Annual Income is greater than 1.3M',\n         color_discrete_sequence=['#0CF3CD'],\n         title='Age group of people earning more than 1.3M',\n         template='plotly_dark'\n      )","233969bc":"df = pd.get_dummies(df,drop_first=True)\ndf.head(10)","ab6e51c7":"df.corr()","ab82d430":"correlation_mat = df.corr()\ncorr_features = correlation_mat.index\nplt.figure(figsize=(20,20))\ng = sns.heatmap(df[corr_features].corr(),annot=True,cmap='rainbow')\nplt.show()","fbeb78a7":"from sklearn.model_selection import train_test_split, RandomizedSearchCV\nfrom mlxtend.plotting import plot_decision_regions\nfrom sklearn.metrics import roc_curve, auc\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import RepeatedStratifiedKFold\nfrom sklearn.model_selection import cross_val_score\nimport matplotlib.pyplot as plt\nfrom sklearn.svm import SVC\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom imblearn.under_sampling import RandomUnderSampler\nfrom scipy.stats import reciprocal, uniform","08cf8b32":"X = df.drop(columns=['TravelInsurance'])\ny = df['TravelInsurance']","f6c03697":"undersample = RandomUnderSampler(sampling_strategy=0.8)\nX_sampled, y_sampled = undersample.fit_resample(X, y)","9723ceed":"X_train, X_test, y_train, y_test = train_test_split(X_sampled, y_sampled, test_size=0.3)\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled = scaler.transform(X_test)","eafca5bf":"clf = SVC(probability=True)\nclf.fit(X_train_scaled, y_train)\ncv = RepeatedStratifiedKFold(n_splits=5, n_repeats=3)\nscores = cross_val_score(clf, X, y, cv=cv, scoring='roc_auc')\npx.line(scores, title='Cross validation scores after every iteration: ',template='plotly_dark',labels=dict(x=\"No of iterations\"))\n","5d590927":"print(\"Accuracy of the SVC model after cross validation:\",np.mean(scores))\nsvc_score_1 = np.mean(scores)","3c550cff":"y_predicted = clf.predict_proba(X_test_scaled)[:,1]\n\nfpr, tpr, thresholds = roc_curve(y_test, y_predicted)\nroc_fig = px.area(\n    x=fpr, y=tpr,\n    title=f'ROC Curve (AUC={auc(fpr, tpr):.4f})',\n    labels=dict(x='False Positive Rate', y='True Positive Rate'),\n    width=800, height=500\n)\nroc_fig.add_shape(\n    type='line', line=dict(dash='dash'),\n    x0=0, x1=1, y0=0, y1=1\n)\n\nroc_fig.update_yaxes(scaleanchor=\"x\", scaleratio=1)\nroc_fig.update_xaxes(constrain='domain')\nroc_fig.show()","97dad079":"svm_clf = SVC(probability=True)\nkernel = ['rbf','linear','poly','sigmoid']\nparam_distributions = {\"kernel\":kernel,\"gamma\": reciprocal(0.001, 0.1), \"C\": uniform(1, 10)}\nrnd_search_cv = RandomizedSearchCV(svm_clf, param_distributions, n_iter=10, verbose=2)\nrnd_search_cv.fit(X_train_scaled,y_train)","95067b26":"rnd_search_cv.best_estimator_","12d6e746":"rnd_search_cv.best_score_","a049c3cf":"rnd_search_cv.best_estimator_.fit(X_train_scaled, y_train)\ncv = RepeatedStratifiedKFold(n_splits=5, n_repeats=3)\nscores = cross_val_score(rnd_search_cv.best_estimator_, X, y, cv=cv, scoring='roc_auc')\npx.line(scores, title='Cross validation scores after every iteration: ',template='plotly_dark',labels=dict(x=\"No of iterations\"))\n","4cb68436":"print(\"Accuracy of the SVC model after cross validation:\",np.mean(scores))\nsvc_score_2 = np.mean(scores)","a9a8b094":"y_predicted = rnd_search_cv.best_estimator_.predict_proba(X_test_scaled)[:,1]\n\nfpr, tpr, thresholds = roc_curve(y_test, y_predicted)\nroc_fig = px.area(\n    x=fpr, y=tpr,\n    title=f'ROC Curve (AUC={auc(fpr, tpr):.4f})',\n    labels=dict(x='False Positive Rate', y='True Positive Rate'),\n    width=800, height=500\n)\nroc_fig.add_shape(\n    type='line', line=dict(dash='dash'),\n    x0=0, x1=1, y0=0, y1=1\n)\n\nroc_fig.update_yaxes(scaleanchor=\"x\", scaleratio=1)\nroc_fig.update_xaxes(constrain='domain')\nroc_fig.show()","14f91e07":"svc_score = max(svc_score_1,svc_score_2)\nsvc_score","9991248f":"clf = DecisionTreeClassifier(criterion=\"gini\")\nclf.fit(X_train_scaled, y_train)\ncv = RepeatedStratifiedKFold(n_splits=5, n_repeats=3)\nscores = cross_val_score(clf, X, y, cv=cv, scoring='roc_auc')\npx.line(scores, title='Cross validation scores after every iteration: ',template='plotly_dark',labels=dict(x=\"No of iterations\"))","1639a6d6":"print(\"Accuracy of the Decision Tree model after cross validation:\",np.mean(scores))\ndtc_score_1 = np.mean(scores)","592e3882":"y_predicted = clf.predict_proba(X_test_scaled)[:,1]\n\nfpr, tpr, thresholds = roc_curve(y_test, y_predicted)\nroc_fig = px.area(\n    x=fpr, y=tpr,\n    title=f'ROC Curve (AUC={auc(fpr, tpr):.4f})',\n    labels=dict(x='False Positive Rate', y='True Positive Rate'),\n    width=800, height=500\n)\nroc_fig.add_shape(\n    type='line', line=dict(dash='dash'),\n    x0=0, x1=1, y0=0, y1=1\n)\n\nroc_fig.update_yaxes(scaleanchor=\"x\", scaleratio=1)\nroc_fig.update_xaxes(constrain='domain')\nroc_fig.show()","81f463e8":"dtc_clf = DecisionTreeClassifier()\ncriterion = ['gini','entropy']\nsplitter = ['best','random']\nmax_depth = [4,6,8,12]\nmax_features = list((range(1,len(X_train.columns) + 1)))\nparam_distributions = {\"criterion\":criterion,\"splitter\":splitter , \"max_depth\":max_depth, \"max_features\":max_features }\nrnd_search_cv = RandomizedSearchCV(dtc_clf, param_distributions, n_iter=10, verbose=2)\nrnd_search_cv.fit(X_train_scaled,y_train)","78ad1750":"rnd_search_cv.best_estimator_","db306ce7":"rnd_search_cv.best_score_","c55d72c3":"rnd_search_cv.best_estimator_.fit(X_train_scaled, y_train)\ncv = RepeatedStratifiedKFold(n_splits=5, n_repeats=3)\nscores = cross_val_score(rnd_search_cv.best_estimator_, X, y, cv=cv, scoring='roc_auc')\npx.line(scores, title='Cross validation scores after every iteration: ',template='plotly_dark',labels=dict(x=\"No of iterations\"))","67ad8296":"print(\"Accuracy of the Decision Tree model after cross validation:\",np.mean(scores))\ndtc_score_2 = np.mean(scores)","e705b594":"y_predicted = rnd_search_cv.best_estimator_.predict_proba(X_test_scaled)[:,1]\n\nfpr, tpr, thresholds = roc_curve(y_test, y_predicted)\nroc_fig = px.area(\n    x=fpr, y=tpr,\n    title=f'ROC Curve (AUC={auc(fpr, tpr):.4f})',\n    labels=dict(x='False Positive Rate', y='True Positive Rate'),\n    width=800, height=500\n)\nroc_fig.add_shape(\n    type='line', line=dict(dash='dash'),\n    x0=0, x1=1, y0=0, y1=1\n)\n\nroc_fig.update_yaxes(scaleanchor=\"x\", scaleratio=1)\nroc_fig.update_xaxes(constrain='domain')\nroc_fig.show()","dae13fad":"dtc_score = max(dtc_score_1,dtc_score_2)\ndtc_score","de336f69":"clf = RandomForestClassifier(criterion=\"gini\")\nclf.fit(X_train_scaled, y_train)\ncv = RepeatedStratifiedKFold(n_splits=5, n_repeats=3)\nscores = cross_val_score(clf, X, y, cv=cv, scoring='roc_auc')\npx.line(scores, title='Cross validation scores after every iteration: ',template='plotly_dark',labels=dict(x=\"No of iterations\"))","25439092":"print(\"Accuracy of the Random Forest Classifier model after cross validation:\",np.mean(scores))\nrfc_score_1 = np.mean(scores)","84d34ac9":"y_predicted = clf.predict_proba(X_test_scaled)[:,1]\n\nfpr, tpr, thresholds = roc_curve(y_test, y_predicted)\nroc_fig = px.area(\n    x=fpr, y=tpr,\n    title=f'ROC Curve (AUC={auc(fpr, tpr):.4f})',\n    labels=dict(x='False Positive Rate', y='True Positive Rate'),\n    width=800, height=500\n)\nroc_fig.add_shape(\n    type='line', line=dict(dash='dash'),\n    x0=0, x1=1, y0=0, y1=1\n)\n\nroc_fig.update_yaxes(scaleanchor=\"x\", scaleratio=1)\nroc_fig.update_xaxes(constrain='domain')\nroc_fig.show()","7b6b3efd":"rfc_clf = RandomForestClassifier()\nn_estimators = [int(x) for x in np.linspace(start = 200, stop = 2000, num = 10)]\nmax_features = ['auto', 'sqrt']\nmax_depth = [int(x) for x in np.linspace(10, 110, num = 11)]\nmax_depth.append(None)\nmin_samples_split = [2,3,4,5,6,8,10]\nmin_samples_leaf = [1, 2, 4]\nbootstrap = [True, False]\nparam_distributions = {\n                       'n_estimators': n_estimators,\n                       'max_features': max_features,\n                       'max_depth': max_depth,\n                       'min_samples_split': min_samples_split,\n                       'min_samples_leaf': min_samples_leaf,\n                       'bootstrap': bootstrap\n                      }\nrnd_search_cv = RandomizedSearchCV(rfc_clf, param_distributions, n_iter=10, verbose=2)\nrnd_search_cv.fit(X_train_scaled,y_train)","0bd00228":"rnd_search_cv.best_estimator_","252ed261":"rnd_search_cv.best_score_","52d16e46":"rnd_search_cv.best_estimator_.fit(X_train_scaled, y_train)\ncv = RepeatedStratifiedKFold(n_splits=5, n_repeats=3)\nscores = cross_val_score(rnd_search_cv.best_estimator_, X, y, cv=cv, scoring='roc_auc')\npx.line(scores, title='Cross validation scores after every iteration: ',template='plotly_dark',labels=dict(x=\"No of iterations\"))","47a07fcb":"print(\"Accuracy of the Random Forest Classifier model after cross validation:\",np.mean(scores))\nrfc_score_2 = np.mean(scores)","ce5eae22":"y_predicted = rnd_search_cv.best_estimator_.predict_proba(X_test_scaled)[:,1]\n\nfpr, tpr, thresholds = roc_curve(y_test, y_predicted)\nroc_fig = px.area(\n    x=fpr, y=tpr,\n    title=f'ROC Curve (AUC={auc(fpr, tpr):.4f})',\n    labels=dict(x='False Positive Rate', y='True Positive Rate'),\n    width=800, height=500\n)\nroc_fig.add_shape(\n    type='line', line=dict(dash='dash'),\n    x0=0, x1=1, y0=0, y1=1\n)\n\nroc_fig.update_yaxes(scaleanchor=\"x\", scaleratio=1)\nroc_fig.update_xaxes(constrain='domain')\nroc_fig.show()","4bbb42cf":"rfc_score  = max(rfc_score_1,rfc_score_2)\nrfc_score","cdf84a4b":"import xgboost as xgb\nclf = xgb.XGBClassifier(eval_metric='logloss',use_label_encoder=False)\nclf.fit(X_train_scaled, y_train)\ncv = RepeatedStratifiedKFold(n_splits=5, n_repeats=3)\nscores = cross_val_score(clf, X, y, cv=cv, scoring='roc_auc')\npx.line(scores, title='Cross validation scores after every iteration: ',template='plotly_dark',labels=dict(x=\"No of iterations\"))","46eeb3ff":"print(\"Accuracy of the XGB Classifier model after cross validation:\",np.mean(scores))\nxgb_score_1 = np.mean(scores)","49aa1cba":"y_predicted = clf.predict_proba(X_test_scaled)[:,1]\n\nfpr, tpr, thresholds = roc_curve(y_test, y_predicted)\nroc_fig = px.area(\n    x=fpr, y=tpr,\n    title=f'ROC Curve (AUC={auc(fpr, tpr):.4f})',\n    labels=dict(x='False Positive Rate', y='True Positive Rate'),\n    width=800, height=500\n)\nroc_fig.add_shape(\n    type='line', line=dict(dash='dash'),\n    x0=0, x1=1, y0=0, y1=1\n)\n\nroc_fig.update_yaxes(scaleanchor=\"x\", scaleratio=1)\nroc_fig.update_xaxes(constrain='domain')\nroc_fig.show()","33a73a0e":"xgb_clf = xgb.XGBClassifier(eval_metric='logloss',use_label_encoder=False)\n#learning_rate = [0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4],\n#max_depth = [3,4,5,6,8,10,12,13,15],\n#min_child_weight = [1,3,5,7],\n#gamma = [0,0.1,0.2,0.3,0.4,0.42,0.45]\nparams = {\n    \"learning_rate\" : [0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4],\n    \"max_depth\" : [3,4,5,6,8,10,12,13,15],\n    \"min_child_weight\" : [1,3,5,7],\n    \"gamma\" : [0,0.1,0.2,0.3,0.4,0.42,0.45],\n    \"colsample_bytree\" : [0.3,0.4,0.5,0.7],\n}\nrnd_search_cv = RandomizedSearchCV(xgb_clf, param_distributions=params, n_iter=10, verbose=2)\nrnd_search_cv.fit(X_train_scaled,y_train)","fe58206c":"rnd_search_cv.best_estimator_","e52dda31":"rnd_search_cv.best_score_","21cbd85f":"rnd_search_cv.best_estimator_.fit(X_train_scaled, y_train)\ncv = RepeatedStratifiedKFold(n_splits=5, n_repeats=3)\nscores = cross_val_score(rnd_search_cv.best_estimator_, X, y, cv=cv, scoring='roc_auc')\npx.line(scores, title='Cross validation scores after every iteration: ',template='plotly_dark')","79d8fc06":"print(\"Accuracy of the XGB Classifier model after cross validation:\",np.mean(scores))\nxgb_score_2 = np.mean(scores)","626aee01":"y_predicted = rnd_search_cv.best_estimator_.predict_proba(X_test_scaled)[:,1]\n\nfpr, tpr, thresholds = roc_curve(y_test, y_predicted)\nroc_fig = px.area(\n    x=fpr, y=tpr,\n    title=f'ROC Curve (AUC={auc(fpr, tpr):.4f})',\n    labels=dict(x='False Positive Rate', y='True Positive Rate'),\n    width=800, height=500\n)\nroc_fig.add_shape(\n    type='line', line=dict(dash='dash'),\n    x0=0, x1=1, y0=0, y1=1\n)\n\nroc_fig.update_yaxes(scaleanchor=\"x\", scaleratio=1)\nroc_fig.update_xaxes(constrain='domain')\nroc_fig.show()","14609471":"xgb_score = max(xgb_score_1,xgb_score_2)\nxgb_score","51a0efac":"models = pd.DataFrame({\n    'Model' : [ 'Support Vector Classifier', 'Decision Tree Classifier', 'Random Forest Classifier', 'XgBoost Classifier'],\n    'Score' : [ svc_score, dtc_score, rfc_score, xgb_score]\n})\nmodels.sort_values(by = 'Score', ascending = False)","463f7593":"px.bar(data_frame = models, x = 'Score', y = 'Model', color = 'Score', template = 'plotly_dark', \n       title = 'Comparison of Classification Algorithms')","4286d7ba":"> As we know that people whose annual income is higher than 1.3M are more likely to purchase the travel insurance. Now, we will check that what is the age of people who are earning more than 1.3M as their annual income.","cd16895e":"#### How many people are in govt or private sector and are frequent flyers or not?","5f7402b4":"> Here from the above graph we can describe that only 36.11% of the graduated people have bought the travel insurance. On the other hand, 33.55% of the undergraduated people have bought the insurance. ","31b3cc8a":"> In below snippet of code, I have created one function which will count the values of particular word or number present in a particular column.\n> Afterwards, I have simply plotted the bar graph of the count for each column.","36383fb5":"> It is clearly observable from the above figure that approx 36% of people have bought the travel insurance whereas only 64% of people have not bought the insurance.\n\n> Also, we can conclude that the dataset is slightly imbalanced.","d11c518a":"> From the above graph we can assume that diseases doesn't make more impact on buying the travel insurance or not as the ratio is almost similar for the people who are suffering from diseases or not. ","6e574a51":"> Now, I will apply SVC with different kernels and use the method of RandomSearchCV in order to find the best parameter.","644f0c38":"### Implementation of Random Forest Classifier","4069f157":"### 1) Reading the data from the file and performing simple operations on it","d330f20b":"### Name: Jay Shah\n### Date: 31-08-2021\n#### Predicting that whether a customer will buy a travel insurance or not","e65f2eb0":"#### How many people are in govt or private sector and have travelled abroad or not or not?","96dda4ca":"> For the below snippet of code, I have checked that how many people are working as a government employee, how many people are graduated or not, how many people have travelled abroad or not and how many people are frequent flyers or not.\n\n> For the visualization purpose, I have created simple pie-chart.","55300198":"#### How many people have already bought the travel insurance?","d321c987":"### 3) Converting categorical data into dummy variables and building correlation matrix","bf1da5ee":"### 2) Performing EDA and visualizations to gain insight from the data","3483e899":"#### How many people are in govt or private sector and have purchased travel insurance or not?","df2f3a44":"> From the above histogram it is clearly apparent, that people whose annual income is greater than 1.3M have bought more travel insurances than the people whose annual income is less than 1.3M","e98919a3":"> Now, we will tune the decision tree in order to obtain more accuracy.","e78d012c":"> Removing the irrelevant columns from the dataframe","fe903ed3":"> In the below block of code, I have grouped the dataframe by the type of employment and checked that whether the person is in government sector or private sector and is graduated or not.","0e2dbf37":"> From the above graph we can conclude that the total number of family members does not impact much on buying the travel insurance as the ratio is almost similar. However, the family having 8 to 9 members does not buy much travel insurance as compared to others.","518ce4a5":"### Implementation of XgBoost","5b1355b2":"> Now, we will hypertune the XgBoost model and try to increase the accuracy of the model.","a004bf1c":"> From the above output we can say that, people who are frequent flyers are more inclined towards buying the travel insurance whereas there are some minority of people who don't travel frequently but still have insurance.\n\n> Also, it does not mean here that the people who are frequent flyers are the ones who travel abroad only. There might be some group of people who prefer to travel via flights inside the country only.","33d12fba":"> Here we have imported all the required libraries which we will need. Our first step is to sample the data as the whole dataset is imbalanced. \n\n> Imbalanced datasets are those where there is a severe skew in the class distribution, such as 1:100 or 1:1000 examples in the minority class to the majority class.\n\n> This bias in the training dataset can influence many machine learning algorithms, leading some to ignore the minority class entirely. This is a problem as it is typically the minority class on which predictions are most important.\n\n> Random resampling provides a naive technique for rebalancing the class distribution for an imbalanced dataset.\n\n> In order to balance the data, I have approached the method of random undersampling which deletes the examples in the majority class.\n\n> Random undersampling deletes examples from the majority class and can result in losing information invaluable to a model.","342d91c3":"## 5) Comparison of Different Algorithms","525c4ef0":"### Implementation of Support Vector Classifier algorithm","bcca654d":"### Implementation of Decision Tree Classifier","186a8fb3":"> From the above graph we can summarize that there are only 380 people who have travelled abroad and 298 out of them has bought the insurance whereas 82 of them haven't bought it yet. Still there are majority of the people who have travelled abroad and bought the insurance.\n\n> As we know, that there are majority of people who haven't travel abroad and haven't bought the insurance. So one thing we can assume that people who haven't travelled abroad don't need the insurance policy while travelling inside the same country as they might find it less useful.\n\n> Another reason which shall be taken into consideration is that there are might be the people who have travelled abroad and earned more money.","cf762388":"> Now ,we will extract out the age and annual income into a separate dataframe and will perform the analysis on it.","418784c7":"### 4) Building Machine Learning Model and implementing various algorithms","21270741":"> It is clear from the graph that group of people below or equal to the age of 26 are more keen in buying the insurance whereas the people whose age lies between 27-32 are not interested much in buying the travel insurance. However, people after the age of 32 till 35 are still interested in buying the insurance."}}