{"cell_type":{"3099319c":"code","88c924de":"code","7ea5da5b":"code","38da6aaa":"code","e86b0faf":"markdown","c6a675a1":"markdown","1014cc73":"markdown"},"source":{"3099319c":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)","88c924de":"def innerproduct(X,Z=None):\n    # function innerproduct(X,Z)\n    #\n    # Computes the inner-product matrix.\n    # Syntax:\n    # D=innerproduct(X,Z)\n    # Input:\n    # X: nxd data matrix with n vectors (rows) of dimensionality d\n    # Z: mxd data matrix with m vectors (rows) of dimensionality d\n    #\n    # Output:\n    # Matrix G of size nxm\n    # G[i,j] is the inner-product between vectors X[i,:] and Z[j,:]\n    #\n    # call with only one input:\n    # innerproduct(X)=innerproduct(X,X)\n    #\n    if Z is None: # case when there is only one input (X)\n        Z=X;\n    G = np.dot(X,Z.T)\n    return(G)","7ea5da5b":"def l2distance(X,Z=None):\n    # function D=l2distance(X,Z)\n    #\n    # Computes the Euclidean distance matrix.\n    # Syntax:\n    # D=l2distance(X,Z)\n    # Input:\n    # X: nxd data matrix with n vectors (rows) of dimensionality d\n    # Z: mxd data matrix with m vectors (rows) of dimensionality d\n    #\n    # Output:\n    # Matrix D of size nxm\n    # D(i,j) is the Euclidean distance of X(i,:) and Z(j,:)\n    #\n    # call with only one input:\n    # l2distance(X)=l2distance(X,X)\n    #\n    if Z is None:\n        Z=X;\n\n    n,d1=X.shape\n    m,d2=Z.shape\n    assert (d1==d2), \"Dimensions of input vectors must match!\"\n    \n    if n!=m :\n        dists = -2 * innerproduct(X,Z)\n        dists += np.sum(X**2, axis=1)[:, np.newaxis]\n        dists += np.sum(Z**2, axis=1)\n    else:\n        dists = - 2 * innerproduct(X,Z)\n        dists += np.sum(X**2,axis=1)[:, np.newaxis]    \n        dists += np.sum(Z**2,axis=1) ;\n    \n    D = np.sqrt(np.abs(np.nan_to_num(dists))) ####Sometimes very small numvers can be non-negative due to numerical precision, you can just set them to 0.\n                               \n   \n   # D = np.na_to_num(D)\n\n    return(D)","38da6aaa":"import time\ncurrent_time = lambda: int(round(time.time() * 1000))\n\nX=np.random.rand(700,100)\nZ=np.random.rand(300,100)\n\nprint(\"Running the vectorized version...\")\nbefore = current_time()\nDfast=l2distance(X)\nafter = current_time()\nt_fast = after - before\nprint(\"{:2.0f} ms\".format(t_fast))\n","e86b0faf":"[![image.png](attachment:image.png)]\n\nSource: Wikipedia.","c6a675a1":"# 60 ms! That's fast!","1014cc73":"# Let's calculate L2 distance or Euclidean distance. Also, using TPU to speed up."}}