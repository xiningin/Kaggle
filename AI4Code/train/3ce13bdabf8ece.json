{"cell_type":{"e74b9bbd":"code","c34e22f1":"code","49db3074":"code","bbe6eeb6":"code","6a1dbd8f":"code","af99f2ba":"code","b8ceeb67":"code","c4a7419c":"code","761073eb":"code","01162830":"code","8ecd4710":"code","b1f55229":"code","40616b15":"code","03035e2d":"code","382cfd4a":"code","c39851e4":"code","a530af41":"code","608b56ed":"code","2e9fdba1":"code","23440ca5":"code","82fc9651":"markdown","caa0f957":"markdown","5d1b4dd2":"markdown","b6737488":"markdown","6b95dc1d":"markdown"},"source":{"e74b9bbd":"try:\n  import tes_optical_stack\nexcept ImportError:\n  !pip install git+https:\/\/github.com\/saewoonam\/tes_optical_stack --quiet\ntry:\n  import lmfit\nexcept ImportError:\n  !pip install lmfit --quiet","c34e22f1":"import numpy as np\nimport lmfit\nimport matplotlib.pyplot as plt","49db3074":"import tes_optical_stack.admittance as admittance","bbe6eeb6":"from tes_optical_stack.optimize import layers2t, build_gui, gui2layers, build_gui_v2, gui2layers_v2","6a1dbd8f":"admittance.nk.keys()","af99f2ba":"stack_description=['air', \n                   'SiO2_ECR_Filmetrics',\n                   'aSi_190312',\n                   'W_190321',\n                   #'W_trilayer_29',\n                   'aSi_190312',\n                   'SiO2_ECR_Filmetrics',\n                   'Ti_nk',\n                   'Ag_Palik',\n                   'air'\n                  ]\ninitial_guess = [np.inf,\n              160.6,\n              66.8,\n              20,\n              10,\n              254.8,\n              1,\n              20,\n             np.inf]\n\n\n\nstack_gui = build_gui_v2(stack_description, initial_guess, admittance.nk)","b8ceeb67":"layers = gui2layers_v2(stack_gui)","c4a7419c":"import glob\nfiles = glob.glob('\/kaggle\/input\/agmirror\/*.asc')\nagmirror = np.loadtxt(files[0], skiprows=90)\nprint(agmirror[:10,:])\nagmirror = agmirror[np.argsort(agmirror[:, 0])]\nagmirror","761073eb":"wl = np.arange(500, 1900)\nr = admittance.stack_v2(stack_description, np.array(initial_guess), wl)\n#r = admittance.stack_v2(stack_description, layers2t(layers), wl)\n\nimport matplotlib.pyplot as plt\nfor idx in [0, 3]:\n    text = stack_description[idx]\n    # mark labels which have the R and T values\n    if idx==0:\n        text += \"-R\"\n    if idx == r['RAT'].shape[1]-1:\n        text += \"-T\"\n    y = r['RAT'][:,idx]\n    #if idx == 4:\n    #    y = 1-y\n    plt.plot(wl, y, label=text)\n\nplt.plot(agmirror[:,0], agmirror[:,1]\/100, label='measured')\n\nplt.legend()\nplt.title('R, T, and A in each layer')\nplt.grid()","01162830":"#%matplotlib notebook\n#plt.figure()\nwl = np.arange(500, 1900)\n#r = admittance.stack_v2(stack_description, np.array(initial_guess), wl)\nimport matplotlib.pyplot as plt\nfor idx in range(r['RAT'].shape[1]):\n    text = stack_description[idx]\n    # mark labels which have the R and T values\n    if idx==0:\n        text += \"-R\"\n    if idx == r['RAT'].shape[1]-1:\n        text += \"-T\"\n    y = r['RAT'][:,idx]\n    #if idx == 4:\n    #    y = 1-y\n    plt.plot(wl, y, label=text)\n\nplt.legend()\nplt.title('R, T, and A in each layer')\nplt.xlabel('wavelength [nm]')\nplt.ylabel('Fraction')\n#plt.axis([1000, 1200, 0.5, 1])","8ecd4710":"for name in stack_description:\n    print(name, admittance.nk[name].min, admittance.nk[name].max)","b1f55229":"import plotly.graph_objects as go\n","40616b15":"wl = np.arange(500, 1900)\nr = admittance.stack_v2(stack_description, initial_guess, wl)\nfig = go.Figure()\nfor idx in range(r['RAT'].shape[1]):\n    text = stack_description[idx]\n    # mark labels which have the R and T values\n    if idx==0:\n        text += \"-R\"\n    if idx == r['RAT'].shape[1]-1:\n        text += \"-T\"\n    y = r['RAT'][:,idx]\n    #if idx == 4:\n    #    y = 1-y\n    fig.add_scatter(x=wl, y=y, name=text)\nfig.update_layout(\n  title={\n        'text': \"R, T, and A in each layer\",\n        'y':0.9,\n        'x':0.45,\n        'xanchor': 'center',\n        'yanchor': 'top'},\n  xaxis_title=\"wavelength [nm]\",\n  yaxis_title=\"fraction\",\n)\nfig.show()","03035e2d":"from scipy.io import savemat\n\nmdic = {\"Rpython\": r['RAT'][:,0], \"wl\": wl}\nsavemat('python.mat', mdic)","382cfd4a":"def optimize_W_a(layers):\n    t = []\n    stack = []\n    for key in layers.keys():\n        t.append(layers[key].value)\n        stack.append(layers[key].user_data['name'])\n    #wl = 1064 + np.arange(-100, 101, 10)\n    #wl = np.arange(630, 1800, 50)\n    wl = np.arange(1200, 1801, 10)\n    r = admittance.stack_v2(stack, t, wl)\n    w_idx = 3\n    \n    #error = ((1-1\/r['RAT'][:,w_idx])**2).sum() # + (r['RAT'][:,0]**2).sum() + (r['RAT'][:,-1]**2).sum()\n    #error = np.abs((1-1\/r['RAT'][:,w_idx])).sum() \n    error = (1-r['RAT'][:,w_idx]).sum() #  \n    #error = (r['RAT'][:,0]**2).sum() + (r['RAT'][:,-1]**2).sum()\n    return error\n","c39851e4":"stack_gui","a530af41":"layers = gui2layers_v2(stack_gui)\n#results = lmfit.minimize(optimize_W_a, layers, method='dual_annealing')\nresults = lmfit.minimize(optimize_W_a, layers, method='differential_evolution')\noptimize_W_a(layers), optimize_W_a(results.params), layers2t(results.params)","608b56ed":"stack_labels = []\nfor p in results.params.keys():\n    stack_labels.append(results.params[p].user_data['name'])\n\nwl = np.arange(500, 1900)\nr = admittance.stack_v2(stack_labels, layers2t(results.params), wl)\nfig = go.Figure()\nfor idx in range(r['RAT'].shape[1]):\n    text = stack_labels[idx]\n    # mark labels which have the R and T values\n    if idx==0:\n        text += \"-R\"\n    if idx == r['RAT'].shape[1]-1:\n        text += \"-T\"\n    y = r['RAT'][:,idx]\n    #if idx == 4:\n    #    y = 1-y\n    fig.add_scatter(x=wl, y=y, name=text)\nfig.update_layout(\n  title={\n        'text': \"R, T, and A in each layer\",\n        'y':0.9,\n        'x':0.45,\n        'xanchor': 'center',\n        'yanchor': 'top'},\n  xaxis_title=\"wavelength [nm]\",\n  yaxis_title=\"fraction\",\n)\nfig.show()","2e9fdba1":"stack_labels = []\nfor p in results.params.keys():\n    stack_labels.append(results.params[p].user_data['name'])","23440ca5":"layers['layer0'].user_data","82fc9651":"## Look at max and minimum wavelengths that are available for each layer","caa0f957":"## build gui to edit intial values and pick which layers will vary","5d1b4dd2":"### all length units are in nanometers\n","b6737488":"# Code to compare MATLAB with python","6b95dc1d":"## Plot using plotly"}}