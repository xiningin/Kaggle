{"cell_type":{"424b9f54":"code","86315209":"code","c52d5077":"code","e3c16a89":"code","6ebfbd86":"code","28464d41":"code","abfda346":"code","b4f158a2":"code","e6d11c88":"code","57fdb7e8":"code","ef519d4a":"code","f672517b":"code","b1ecd6d2":"code","c5a12ee5":"code","050da5c3":"code","bbff19ac":"code","8b7d70e2":"code","5a8556eb":"code","29b5002d":"code","38fbc38f":"code","2beac19a":"code","ce1d034a":"code","14e94fa1":"code","7473e184":"code","71ab30be":"code","246d2b26":"code","0ae9dfbf":"code","c5faa698":"code","cfd47751":"code","2327c43c":"code","303f69c1":"code","d84842b8":"code","95fbf7c3":"code","aae650b9":"code","cd97a3ec":"code","c57d92dc":"code","b2fce825":"code","515b2b3b":"code","9b3c7cee":"code","7d691a06":"code","99360d9a":"code","75a137f1":"code","3d2a5524":"code","091e9562":"code","808a596e":"code","f84d99fe":"code","c4cccf68":"code","ce663052":"code","43d9351e":"code","795d4aa9":"code","ee3322a5":"code","5aa13008":"markdown","741798ef":"markdown","cd633255":"markdown","d1b94666":"markdown","b837cbbf":"markdown","32b2a3e1":"markdown","c84e3d0c":"markdown","c4b27cf4":"markdown","fcf6eaef":"markdown","46fa4343":"markdown","e5ac5453":"markdown","ce1efa45":"markdown","bb87a816":"markdown","c49d8397":"markdown","f19adb35":"markdown","f2a52b96":"markdown","8ea337fd":"markdown","5b85ae87":"markdown","6686af7f":"markdown","4a8ee1d1":"markdown","5d4d358b":"markdown","de75b971":"markdown","502eaa96":"markdown","8e7bfc7a":"markdown","cbb2790b":"markdown","16cb4ae1":"markdown"},"source":{"424b9f54":"import re\n\nimport pandas as pd","86315209":"pattern = \"bc\"\nstring = \"dbthgbcerfbc\"\nre.search(pattern, string)","c52d5077":"pattern = \"bc\"\nstring = \"dbthgbcerfbc\"\nre.findall(pattern, string)","e3c16a89":"pattern = \"bc\"\nstring = \"dbthgbcerfbc\"\nfor i in re.finditer(pattern, string):\n    print(i)","6ebfbd86":"pattern = \"bc\"\nstring = \"dbthgbcerfbc\"\nmatch = re.search(pattern, string)\nprint(\n    f\"String matched between {match.start()} and {match.end()}\\n\"\n    f\"The matched part is {string[match.start():match.end()]}\"\n)","28464d41":"pattern = \"^cat\"\nstring = \"category\"\nprint(f\"{string}: {re.search(pattern, string)}\")","abfda346":"pattern = \"^cat\"\nstring = \"basic category\"\nprint(f\"{string}: {re.search(pattern, string)}\")","b4f158a2":"pattern = \"cat$\"\nstring = \"category\"\nprint(f\"{string}: {re.search(pattern, string)}\")","e6d11c88":"pattern = \"cat$\"\nstring = \"scat\"\nprint(f\"{string}: {re.search(pattern, string)}\")","57fdb7e8":"pattern = \"cat$\"\nstring = \"basic category\"\nprint(f\"{string}: {re.search(pattern, string)}\")","ef519d4a":"pattern = \"cat$\"\nstring = \"sCaT\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","f672517b":"pattern = \"$\"\nstring = \"sCaT\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","b1ecd6d2":"pattern = \"^\"\nstring = \"sCaT\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","c5a12ee5":"pattern = \"^$\"\nstring = \"sCaT\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","050da5c3":"pattern = \"^cat$\"\nstring = \"sCaT\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","bbff19ac":"pattern = \"^cat$\"\nstring = \"cat\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","8b7d70e2":"pattern = \"gr[ae]y\"\nstring = \"grey\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","5a8556eb":"pattern = \"sep[ae]rate\"\nstring = \"separate\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","29b5002d":"pattern = \"gr[ae]y\"\nstring = \"gracy\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","38fbc38f":"pattern = \"gr[ae]y\"\nstring = \"grdy\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","2beac19a":"pattern = \"gr[a-z]y\"\nstring = \"grxy\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","ce1d034a":"pattern = \"gr[^a-z]y\"\nstring = \"grEy\"\nmatch = re.search(pattern, string)\nprint(f\"{string}: {match}\")","14e94fa1":"pattern = \"14.Apr.2020\"\nstring = \"14\/Apr\/2020\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","7473e184":"pattern = \"14.Apr.2020\"\nstring = \"14-Apr-2020\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","71ab30be":"pattern = \"14.Apr.2020\"\nstring = \"14.Apr.2020\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","246d2b26":"pattern = \"14.Apr.2020\"\nstring = \"14:Apr:2020\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","0ae9dfbf":"pattern = \"First|1st\"\nstring = \"1st\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","c5faa698":"pattern = \"First|1st\"\nstring = \"Firstt\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","cfd47751":"pattern = \"First|1st\"\nstring = \"Firsst\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","2327c43c":"pattern = \"(Fir|1)st\"\nstring = \"1st\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","303f69c1":"pattern = \"(Fir|1)st\"\nstring = \"First\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","d84842b8":"pattern = \"(Fir|1)st [Ss]treet\"\nstring = \"1st street\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","95fbf7c3":"pattern = \"(Geo|Je)ff(re|er)y\"\nstring = \"Geoffery\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","aae650b9":"pattern = \"colou?r\"\nstring = \"color\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","cd97a3ec":"pattern = \"colou?r\"\nstring = \"colour\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","c57d92dc":"pattern = \"colou?r\"\nstring = \"colouur\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","b2fce825":"pattern = \"colou+r\"\nstring = \"colouur\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","515b2b3b":"pattern = \"colou*r\"\nstring = \"color\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","9b3c7cee":"pattern = \"colou*r\"\nstring = \"colour\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","7d691a06":"pattern = \"\\d+\"\nstring = \"98742adshui894\"\nflags = re.IGNORECASE\nfor match in re.finditer(pattern, string, flags):\n    print(f\"{string}: {match}\")","99360d9a":"pattern = \"[a-z]+\"\nstring = \"955868adShui\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","75a137f1":"pattern = \"<hr([\\s]+size[\\s]*=[\\s]*[\\d]*)?[\\s]*>\"\nstring = \"<hr\\tSiZe=\\n12      >\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","3d2a5524":"pattern = \"m{2,6}\"\nstring = \"m\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","091e9562":"pattern = \"m{2,6}\"\nstring = \"mmm\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","808a596e":"pattern = \"m{2,6}\"\nstring = \"mmmmmnmm\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","f84d99fe":"pattern = \"m{2,6}\"\nstring = \"mmmmmmmm\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","c4cccf68":"pattern = \"m{2,}\"\nstring = \"mmmmmmmmmmmmm\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","ce663052":"pattern = \"m{,6}\"\nstring = \"m\"\nflags = re.IGNORECASE\nmatch = re.search(pattern, string, flags)\nprint(f\"{string}: {match}\")","43d9351e":"pattern = \"^([01]?[\\d]|2[0-3])(:([0-5][\\d])){2}$\"\nstring = \"11:25:36\"\nflags = re.IGNORECASE\np = re.compile(pattern, flags)\nmatch = re.split(\":\", p.search(string).group())\nprint(f\"{string}: {match}\")","795d4aa9":"df = pd.Series(\n    {\"IN\": \"22:32:15\", \"AU\": \"11:25:36\", \"US\": \"05:57:00\", \"UK\": \"12:11:27\"},\n    dtype=pd.StringDtype(),\n)\n\ndf","ee3322a5":"df.str.match(p)","5aa13008":"Suppose we want to construct regex for a $24$-hour clock time. The possible syntax is *hh\\:mm\\:ss*. The possible values for *hh* ranges from $0$ to $23$. Often the single digit values may be written with a preceding $0$. For example, $5$ may be written as $05$. We can divide it in three alterations. For $00$ to $09$, we can write, `0[\\d]`. Since $0$ is optional, the pattern becomes `0?[\\d]`. Similarly, we can write for $10$ to $19$ as `1[\\d]` and for the remaining values, we can write `2[0-3]`. Thus the pattern for the *hh* part becomes `0?[\\d]|1[\\d]|2[0-3]`. This can further be reduced to `[01]?[\\d]|2[0-3]`.\n\nFor the *mm* and *ss* part, we have values ranging from $00$ to $59$ so we can simply write it as `[0-5][\\d]` since we have to match exactly two digits. Thus the entire constructed regex becomes `([01]?[\\d]|2[0-3])(:[0-5][\\d]}){2}`. We can further add `^` and `$` to match it entirely and nothing else. We can then use `re.split` function to split it through \":\". Often when we are going to reuse a particular regex multiple times, it is efficient to compile it and then use it.","741798ef":"The regex functionality can be accessed in Python using the `re` module available in the standard library.\n\nThe functions in `re` module are divided into three main categories:\n- Pattern Matching (`re.search`)\n- Substitution (`re.sub`)\n- Splitting (`re.split`)\n\nHere's the list of all the metacharacters:\n\n. ^ $ * + ? { } [ ] \\ | ( )\n\nThe functions generally have three main parameters:\n- pattern to be matched\n- string to run the regex on\n- flags","cd633255":"Here, if anywhere in the string there is a `b` immediately followed by a `c` is found, it is considered a match.\n\nBut, we see that we are only matched with the first instance of the pattern. If we want all the matches, we can use a `re.findall` or `re.finditer` function. `re.findall` returns a list of the matches while `re.finditer` returns an iterator which can be used in a loop.","d1b94666":"Uptil now, only one character was matched at a point in the string. If we wish to match from a set of characters at a point, we use `[...]` construct known as *character class*. We can specify characters individually like `[abcd]` or as a range `[a-d]`. Thus `[a-z]` represents that any character from `a` to `z` will be matched. We can specify multiple ranges like `[a-zA-Z0-9]`.","b837cbbf":"The simplest use can be finding literals in a string. We will use the `re.search` function here. This function returns `re.Match` object if a match is found otherwise it returns `None`. We have a similar function `re.match`. The difference between `re.search` and `re.match` is that `re.search` scans through the entire string while looking for a match and `re.match` tries to apply the pattern only at the start of the string.","32b2a3e1":"Repetition more than one time can be matched with help of `+` and `*` metacharacters. `*` will match \"any number of instances, including none\" while `+` will match \"one or more instances\" of the sequence. If there are no instances in case of `+`, the match is considered a failure.\n\n|Metacharacter|Minimum Required|Maximum to try|Description|\n|---|---|---|---|\n|?|0|1|one allowed; none required|\n|\\*|0|$\\infty$|unlimited allowed; none required|\n|+|1|$\\infty$|unlimited allowed; one required|","c84e3d0c":"By default, the matching is case sensitive. If we want to do case insensitive matching, we can pass `re.IGNORECASE` flag.","c4b27cf4":"This was a basic usage of `re` module. We can return to writing and understanding regex. The main use of regex lies in the use of metacharacters as it can extend far beyond what literals can represent. Each metacharacter has a special meaning and a context which it represents during the process of pattern matching. It is better to interpret regex in a literal way as it will be helpful in intrinsically understanding a new expression.","fcf6eaef":"`re.Match` object has certain helpful methods like `start`, `end`, `span` and `group`","46fa4343":"These are helpful in cases like matching empty lines which can be matched by `^$` which literally will match the beginning of a line followed by the end of the line which effectively means empty lines. `^cat$` will match all the lines that just have `cat` in them with no spaces or any other characters. `^` or `$` alone will match all the lines since all lines have an beginning and an ending including empty lines.","e5ac5453":"In certain regex implementations, `\\<` and `\\>` are special metasequences that match the start and the end of the word respectively. Note that `<` and `>` are not metacharacters but when combined with `\\`, they form special *metasequences*.","ce1efa45":"# Regular Expression - Primer","bb87a816":"We can mention the number of repetitions we as `{m,n}` where \"m\" is the lower limit and \"n\" is the upper limit. `m{3,12}` will match minimum 3 and maximum 12 \"m\" in the string. We can omit one of the limits.","c49d8397":"If a certain sequence is optional, we can represent it by `?` metacharacter. This will effectively match $0$ or $1$ instance of that sequence and no more. Suppose we want match \"color\" or \"colour\", we could use `col(o|ou)r`. But here \"o\" is redundant so a better way would be write it as `colou?r`.","f19adb35":"Pandas support vectorized string regex expressions. To check if a column contains all the values, we can do the following.","f2a52b96":"`re.findall` prints all the matches. But `re.finditer` is often more helpful.","8ea337fd":"Alteration can be done with `|` metacharacter which means \"or\". It can be used to combine multiple expressions into a single expression that matches any of the individual ones. Suppose we want to match \"First\" or \"1st\", in that case we could write it as `First|1st`. But here we can see that \"st\" is common and redundant. So we can separate it and put the alteration sequence in parentheses. Sequences between `(` and `)` are treated as a single group. Inside a character class, `|` will be treated literally.","5b85ae87":"`$` represents the start of the line. So a pattern `cat$` will report a match found if we have `c`, immediately followed by `a`, immediately followed by `t`, immediately followed by `EOL (End of Line)` which effectively matches any lines that end with `cat`. So even if there is a `cat` somewhere else in the string, it won't be matched.","6686af7f":"There are common shortcuts for multiple ranges. The common ones are:\n\n|Character class range|Equivalent shorthand|Description|\n|---|---|---|\n|`[0-9]`|`\\d`|Matches any decimal digit|\n|`[^0-9]`|`\\D`|Matches any non-digit character|\n|`[ \\t\\n\\r\\f\\v]`|`\\s`|Matches any whitespace character|\n|`[^ \\t\\n\\r\\f\\v]`|`\\S`|Matches any non-whitespace character|\n|`[a-zA-Z0-9_]`|`\\w`|Matches any alphanumeric character|\n|`[^a-zA-Z0-9_]`|`\\W`|Matches any non-alphanumeric character|\n|||\n\nThus `[\\s,.]` will match any whitespace character, `,` or `.`.","4a8ee1d1":"This concludes a basic primer of RegEx and well this is just the beginning...\n\nFor further reading, refer to the following:\n\n[re - Regular Expression Operations](https:\/\/docs.python.org\/3\/library\/re.html)\n\n[Regular Expression HOWTO](https:\/\/docs.python.org\/3\/howto\/regex.html)\n\n[JavaScript - Regular Expressions](https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Guide\/Regular_Expressions)\n\n[Golang - RegExp](https:\/\/pkg.go.dev\/regexp)","5d4d358b":"`(Geo|Je)ff(re|er)y` will effectively match any of \"Geoffrey\", \"Geoffery\", \"Jeffrey\" or \"Jeffery\" which we could have alternatively written as `Jeffrey|Geoffery|Jeffery|Geoffrey`","de75b971":"Outside the character class, there is still point-to-point matching. Inside the character class, metacharacters act as literals. This means that `[5^$]` will match either `5`, `^` or `$`. One subtle point here is that if `^` appears as the first character of the character class, it refers to negation. So `[^a-z]` will match everything other than `[a-z]`. If we need to match a literal `[`, `\\` or `]`, we need to escape it with a backslash `\\[`, `\\\\`, `\\]`. In that case, there is a function in `re` module that can be helpful which escapes all the special characters in a string or we can write it in a raw string.","502eaa96":"`^` represents the start of the line. So a pattern `^cat` will report a match found if after the beginning of a line, we immediately have `c`, immediately followed by `a`, immediately followed by `t` which will effectively match any lines that begin with `cat`. So even if there is a `cat` somewhere else in the string, it won't be matched.","8e7bfc7a":"Outside a character class, the metacharacter `.` is a shorthand for matching \"any character here\". For example, to construct a regex to match a date `14-Apr-2000` or `14\/Apr\/2000` or any such combination, we could write it as `14[\/-]Apr[\/-]2000`. But this would only match the three characters `\/` and `-`. Instead we could write `14.Apr.2020` which would match any character at that point including a literal `.`.","cbb2790b":"**Regular Expression (RegEx)** is a pattern used to match character combinations in strings. It is a very powerful tool that can be used in variety of context like pattern matching, text extraction and filtering, web scraping, natural language processing etc.\n\nA regex is composed of two types of characters:\n\n- Metacharacters: Special characters that enhance the functionality of the regex.\n- Literals: Normal text characters\n\nIt might help to consider regular expressions as their own language, with literal text acting as the words and metacharacters as the grammar.","16cb4ae1":"The following example will match HTML tag `<hr>` with an optional size attribute followed by a number with any number of whitespace characters in between with preceding and succeeding angular brackets."}}