{"cell_type":{"0b6433e4":"code","d9c11a08":"code","26c3421d":"code","b7193cb9":"code","e7bf9014":"code","a7659a23":"code","03e5ed85":"code","af143cb6":"code","898835d6":"code","27fd3572":"code","47955c1e":"code","1d4527f3":"code","d09c8430":"code","32da04e7":"code","adf2d04c":"code","004e2f65":"code","993f1b60":"code","85175c66":"code","72146501":"code","5a60ef2d":"code","1f21cf49":"code","8746e24a":"code","6cb000a0":"code","b3631c57":"code","0152a011":"code","f203782c":"code","dced2c3e":"code","e6308a07":"code","93635ab1":"code","5cf755ad":"code","85678d24":"code","19e5627a":"code","88022b6a":"code","a6ae751a":"code","8b74c021":"code","f042ec8a":"code","d963e157":"code","cd0ce94e":"code","a92caed2":"code","10580a65":"code","9d78c47b":"code","029e85f1":"code","ef5d937b":"code","4caba0ea":"code","e93e08ad":"code","57166d32":"code","0a20ddb5":"code","70e1d4a1":"code","9a7afc56":"code","5e6a8cc6":"code","e8ddf7ab":"code","d23d15c9":"code","dfb3eb24":"code","df3edf0d":"code","b0be8cec":"code","54583f81":"code","63faeb69":"code","aa017cb2":"code","45e2dfe7":"code","a0bed11c":"code","e430b8c9":"code","618b6595":"code","8e15269f":"code","c8fcfa90":"code","1ec7972a":"code","9ea99a0b":"code","98f40a46":"code","c21d7eb0":"code","b1deaf81":"code","76057b21":"code","be65afd5":"code","55a4ff0b":"code","33f65143":"code","e189549d":"code","ea3e4176":"code","bfe3eab6":"code","8ad627fa":"code","9fa8ce89":"code","53ab1841":"code","f6e23605":"code","7d960bfa":"code","c3fb7af2":"code","8d29f98c":"code","4e071555":"code","657b306f":"code","f860f92d":"code","2fb868fb":"code","aa9d0f76":"code","ca3ce9c5":"code","b981f4f9":"code","05e6aeaa":"code","ec04308c":"code","7f729321":"code","3ba9f881":"code","c1410262":"code","9d2eb234":"code","2087e18d":"code","5c7542c5":"code","97b64d10":"code","8f59f33e":"code","18e9a951":"code","3c8f1464":"code","8ead930e":"code","661b8dc9":"code","b3575bb7":"markdown","dd19fe6a":"markdown","b9c39779":"markdown","915ac3b5":"markdown","f3f3f0e0":"markdown","6eee654b":"markdown","ac2fb5a0":"markdown","9949077a":"markdown","2f66201c":"markdown","cde9a29e":"markdown","a2bab8b6":"markdown"},"source":{"0b6433e4":"%matplotlib inline\nfrom IPython.display import SVG\nfrom keras.utils.vis_utils import model_to_dot","d9c11a08":"import os\nimport shutil\nprint(os.listdir(\"..\/input\"))","26c3421d":"ls -la ..\/input\/keras-pretrained-models","b7193cb9":"try:\n    os.makedirs('\/tmp\/.keras\/datasets')\nexcept FileExistsError:\n    pass","e7bf9014":"try:\n    shutil.copytree(\"..\/input\/keras-pretrained-models\", \"\/tmp\/.keras\/models\")\nexcept FileExistsError:\n    pass","a7659a23":"import os.path\nimport itertools\nfrom itertools import chain\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn import datasets\nfrom sklearn import preprocessing\nfrom sklearn.decomposition import PCA\nfrom sklearn import cluster, datasets, mixture\nfrom sklearn.datasets import load_digits\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder\nfrom sklearn.metrics import f1_score, classification_report, confusion_matrix\nfrom sklearn.model_selection import train_test_split\n\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\nimport seaborn as sns\n\nfrom keras.layers import Input, Embedding, LSTM, GRU, Dense, Dropout, Lambda, \\\n    Conv1D, Conv2D, Conv3D, \\\n    Conv2DTranspose, \\\n    AveragePooling1D, AveragePooling2D, \\\n    MaxPooling1D, MaxPooling2D, MaxPooling3D, \\\n    GlobalAveragePooling1D, \\\n    GlobalMaxPooling1D, GlobalMaxPooling2D, GlobalMaxPooling3D, \\\n    LocallyConnected1D, LocallyConnected2D, \\\n    concatenate, Flatten, Average, Activation, \\\n    RepeatVector, Permute, Reshape, Dot, \\\n    multiply, dot, add, \\\n    PReLU, \\\n    Bidirectional, TimeDistributed, \\\n    SpatialDropout1D, \\\n    BatchNormalization\nfrom keras.models import Model, Sequential\nfrom keras import losses\nfrom keras.callbacks import BaseLogger, ProgbarLogger, Callback, History\nfrom keras.callbacks import ModelCheckpoint, LearningRateScheduler, ReduceLROnPlateau\nfrom keras.wrappers.scikit_learn import KerasClassifier\nfrom keras import regularizers\nfrom keras import initializers\nfrom keras.metrics import categorical_accuracy\nfrom keras.constraints import maxnorm, non_neg\nfrom keras.optimizers import RMSprop\nfrom keras.utils import to_categorical, plot_model\nfrom keras import backend as K","03e5ed85":"from PIL import Image\nfrom zipfile import ZipFile\nimport h5py\nimport cv2\nfrom tqdm import tqdm","af143cb6":"src_dir = '..\/input\/human-protein-atlas-image-classification'","898835d6":"train_labels = pd.read_csv(os.path.join(src_dir, \"train.csv\"))\nprint(train_labels.shape)\ntrain_labels.head(10)","27fd3572":"test_labels = pd.read_csv(os.path.join(src_dir, \"sample_submission.csv\"))\nprint(test_labels.shape)\ntest_labels.head()","47955c1e":"def show_arr(arr, nrows = 1, ncols = 4, figsize=(15, 5)):\n    fig, subs = plt.subplots(nrows=nrows, ncols=ncols, figsize=figsize)\n    for ii in range(ncols):\n        iplt = subs[ii]\n        try:\n            img_array = arr[:,:,ii]\n            if ii == 0:\n                cp = 'Greens'\n            elif ii == 1:\n                cp = 'Blues'\n            elif ii == 2:\n                cp = 'Reds'\n            else:\n                cp = 'Oranges'\n            iplt.imshow(img_array, cmap=cp)\n        except:\n            pass","1d4527f3":"def get_arr0(Id, test=False):\n    def fn(Id, color, test=False):\n        if test:\n            tgt = 'test'\n        else:\n            tgt = 'train'\n        with open(os.path.join(src_dir, tgt, Id+'_{}.png'.format(color)), 'rb') as fp:\n            img = Image.open(fp)\n            arr = (np.asarray(img) \/ 255.)\n        return arr\n    res = []\n    for icolor in ['green', 'blue', 'red', 'yellow']:\n        arr0 = fn(Id, icolor, test)\n        res.append(arr0)\n    arr = np.stack(res, axis=-1)\n    return arr","d09c8430":"arr = get_arr0('00008af0-bad0-11e8-b2b8-ac1f6b6435d0', test=True)\nprint(arr.shape)\nshow_arr(arr)","32da04e7":"arr = get_arr0('00070df0-bbc3-11e8-b2bc-ac1f6b6435d0')\nprint(arr.shape)\nshow_arr(arr)","adf2d04c":"SH = (139, 139)\nID_LIST_TRAIN = train_labels.Id.tolist()","004e2f65":"img_cache_train = np.load('..\/input\/139x139-resized-numpy-array\/img_cache_train_resize_139x139.npz')['x']","993f1b60":"img_cache_train.shape","85175c66":"def get_arr(Id, test=False):\n    if test:\n        arr = get_arr0(Id, test=True)\n        arr = cv2.resize(arr, SH).astype('float32')\n    else:\n        ii = ID_LIST_TRAIN.index(Id)\n        arr = img_cache_train[ii]\n        arr = arr.astype('float32')\n    return arr","72146501":"arr = get_arr('00070df0-bbc3-11e8-b2bc-ac1f6b6435d0')\narr.shape","5a60ef2d":"show_arr(arr)","1f21cf49":"arr = get_arr('00008af0-bad0-11e8-b2b8-ac1f6b6435d0', test=True)\nprint(arr.shape)\nshow_arr(arr)","8746e24a":"y_cat_train_dic = {}\nfor icat in range(28):\n    target = str(icat)\n    y_cat_train_5 = np.array([int(target in ee.split()) for ee in train_labels.Target.tolist()])\n    y_cat_train_dic[icat] = y_cat_train_5","6cb000a0":"up_sample = {}\nfor k in y_cat_train_dic:\n    v = y_cat_train_dic[k].sum()\n    up_sample[k] = np.ceil((train_labels.shape[0]\/28) \/ v)\n\nup_sample","b3631c57":"up_sample2 = list(zip(*sorted(list(up_sample.items()), key=lambda x: x[0])))[1]\nup_sample2 = np.array(up_sample2)\nup_sample2","0152a011":"import random\n\nclass Seq(object):\n    sections = None\n    index = None\n    \n    def __init__(self, df, extend=False, aug=False, test=False, batch_size=32):\n        self.shaffle = None\n        self.extend = extend\n        self.aug = aug\n        self.test = test\n        self.batch_size = batch_size\n        self.df = df\n        \n        # proccess\n        self.ids = self.df.Id.tolist()\n        self.reversed = sorted(range(SH[0]), reverse=True)\n        \n        # estimate self length\n        self.initialize_it()\n        self.len = 1\n        for _ in self.it:\n            self.len += 1\n        \n        self.initialize_it()\n    \n    def initialize_it(self):\n        if self.shaffle:\n            '''not implemented yet'''\n            raise NotImplementedError\n            #random.seed(self.state)\n            #random.shuffle(self.ids)\n        \n        self.it = iter(range(0, len(self.ids), self.batch_size))\n        self.idx_next = self.it.__next__()\n    \n    def __len__(self):\n        return self.len\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        idx = self.idx_next\n        self.ids_part = self.ids[idx:((idx+self.batch_size) if idx+self.batch_size<len(self.ids) else len(self.ids))]\n        res = self.getpart(self.ids_part)\n        try:\n            self.idx_next = self.it.__next__()\n        except StopIteration:\n            self.initialize_it()\n        return res\n    \n    def __getitem__(self, id0):\n        arr, tgts = self.get_data(id0)\n        cat = self.convert_tgts(tgts)\n        return arr, cat\n    \n    k_list = list(range(4))\n    def random_transform(self, arr):\n        k = random.choice(self.k_list)\n        arr0 = np.rot90(arr, k=k)\n        if random.randint(0,1):\n            arr0 = arr0[self.reversed,:,:]\n        if random.randint(0,1):\n            arr0 = arr0[:,self.reversed,:]\n        return arr0\n    \n    def convert_tgts(self, tgts):\n        try:\n            cats = to_categorical(tgts, num_classes=28)\n            cat = cats.sum(axis=0)\n        except TypeError:\n            cat = np.zeros((28,))\n        return cat\n    \n    def get_data(self, id0):\n        arr = get_arr(id0, test=self.test)\n        \n        try:\n            y0 = (self.df.Target[self.df.Id == id0]).tolist()[0]\n            y1 = y0.split()\n            y = [int(ee) for ee in y1]\n        except AttributeError:\n            y = None\n        return arr, y\n    \n    def getpart(self, ids):\n        xs = []\n        ys = []\n        for id0 in ids:\n            self.extend_data(id0, xs, ys)\n        \n        x = np.stack(xs)\n        y = np.stack(ys)\n        x_dummy = np.zeros((len(x), 1))\n        x_ret = {\n            'input': x,\n            'input_cls': y,\n        }\n        y_ret = {\n            'path_fit_cls_img': x_dummy,\n            'path_cls_img_cls': y,\n            'path_fit_imgA': x_dummy,\n            'path_fit_img_cls_img': x_dummy,\n            'path_cls_cls': y,\n            'path_img_cls': y,\n            'path_img_img_cls': y,\n            'path_fit_cls_img_imgE': x_dummy,\n        }\n        return (x_ret, y_ret)\n    \n    def split(self, arr, sections=sections):\n        res0 = np.vsplit(arr, sections)\n        res = [np.hsplit(ee, sections) for ee in res0]\n        res = list(chain.from_iterable(res))\n        return res\n    \n    def extend_data(self, id0, xs, ys):\n        arr0, cat = self[id0]\n        \n        # data augmentation\n        if self.extend:\n            mm = up_sample2[cat==1].max()\n            mm = int(mm)\n            #print(mm)\n            for ii in range(mm):\n                if self.aug:\n                    img = self.random_transform(arr0)\n                else:\n                    img = arr0\n                xs.append(img.flatten())\n                ys.append(cat)\n        else:\n            if self.aug:\n                img = self.random_transform(arr0)\n            else:\n                img = arr0\n            xs.append(img.flatten())\n            ys.append(cat)","f203782c":"from keras import applications","dced2c3e":"model_resnet = applications.inception_resnet_v2.InceptionResNetV2(\n    include_top=False,\n    weights='imagenet',\n    input_tensor=None,\n    input_shape=(139,139,3),\n    pooling='avg',\n    classes=None)","e6308a07":"model_resnet.summary()","93635ab1":"def make_trainable_false(model_resnet, trainable=False):\n    layers = model_resnet.layers\n    for ilayer in layers:\n        ilayer.trainable = trainable\n    return","5cf755ad":"model_resnet.layers[1].get_weights()[0][:,:,:,0]","85678d24":"img_shape = (139, 139, 4)\nimg_dim = np.array(img_shape).prod()\nprint(img_dim)","19e5627a":"def make_model_cnvt(img_dim, img_shape):\n    '''==============================\n    inputs\n    =============================='''\n    inp = Input(shape=(img_dim,))\n    oup = Reshape(img_shape)(inp)\n    #oup = Conv2D(3, kernel_size=1, strides=1, padding='same')(oup)\n    #oup = Conv2D(3, kernel_size=1, strides=1, padding='same', activation='sigmoid')(oup)\n    oup = Conv2D(3,\n                 kernel_size=1,\n                 strides=1,\n                 padding='same',\n                 activation='tanh',\n                 kernel_regularizer=regularizers.l2(1e-4))(oup)\n    #kernel_regularizer=regularizers.l2(1e-4)\n    model_cnvt = Model(inp, oup, name='model_cnvt')\n    return model_cnvt","88022b6a":"model_cnvt = make_model_cnvt(img_dim, img_shape)\nmodel_cnvt.summary()","a6ae751a":"def make_model_classifier(input_dim=1536):\n    inp_cls = Input((input_dim,))\n    oup_cls = Dense(28)(inp_cls)\n    oup_cls = Activation('sigmoid')(oup_cls)\n    model_classifier = Model(inp_cls, oup_cls, name='classifier')\n    return model_classifier","8b74c021":"model_classifier = make_model_classifier()\nmodel_classifier.summary()","f042ec8a":"def make_model(img_dim, model_cnvt, model_resnet, model_classifier):\n    '''==============================\n    inputs\n    =============================='''\n    inp = Input(shape=(img_dim,), name='input')\n    oup = model_cnvt(inp)\n    oup = model_resnet(oup)\n    oup = model_classifier(oup)\n    oup = Activation('linear', name='path_cls_cls')(oup)\n    \n    model = Model(inp, oup, name='model')\n    model.compile(loss='binary_crossentropy',\n                  optimizer='adam',\n                  metrics=['categorical_accuracy', 'binary_accuracy'])\n    \n    return {\n        'model_classifier': model_classifier,\n        'model_resnet': model_resnet,\n        'model_cnvt': model_cnvt,\n        'model': model\n    }\n\nmodels = make_model(img_dim, model_cnvt, model_resnet, model_classifier)\nmodels['model'].summary()","d963e157":"'''\nThanks Iafoss.\npretrained ResNet34 with RGBY\nhttps:\/\/www.kaggle.com\/iafoss\/pretrained-resnet34-with-rgby-0-460-public-lb\n'''\ngamma = 2.0\nepsilon = K.epsilon()\ndef focal_loss(y_true, y_pred):\n    pt = y_pred * y_true + (1-y_pred) * (1-y_true)\n    pt = K.clip(pt, epsilon, 1-epsilon)\n    CE = -K.log(pt)\n    FL = K.pow(1-pt, gamma) * CE\n    loss = K.sum(FL, axis=1)\n    return loss","cd0ce94e":"model_resnet.layers[1].get_weights()[0][:,:,:,0]","a92caed2":"make_trainable_false(model_resnet, trainable=False)\nmodels['model'].compile(loss=focal_loss,\n                        optimizer='adam',\n                        metrics=['categorical_accuracy', 'binary_accuracy'])","10580a65":"model_resnet.layers[1].get_weights()[0][:,:,:,0]","9d78c47b":"def lr_schedule(epoch):\n    lr = 1e-3\n    if epoch == 0:\n        pass\n    elif epoch == 1:\n        pass\n    elif epoch == 2:\n        pass\n    else:\n        lr *= 0.1\n    print('Learning rate: ', lr)\n    return lr\n\nlr_scheduler = LearningRateScheduler(lr_schedule)\ncallbacks = [lr_scheduler]","029e85f1":"seq = Seq(train_labels, extend=False, aug=True, batch_size=128)\nprint(len(seq))\n\nhst = models['model'].fit_generator(seq, epochs=5,\n                              steps_per_epoch=len(seq),\n                              callbacks=callbacks)","ef5d937b":"fig, ax = plt.subplots(1, 2, figsize=(15,5))\nax[0].set_title('loss')\nax[0].plot(hst.epoch, hst.history[\"loss\"], label=\"Train loss\")\nax[1].set_title('acc')\nax[1].plot(hst.epoch, hst.history[\"categorical_accuracy\"], label=\"categorical_accuracy\")\nax[1].plot(hst.epoch, hst.history[\"binary_accuracy\"], label=\"binary_accuracy\")\nax[0].legend()\nax[1].legend()","4caba0ea":"model_resnet.layers[1].get_weights()[0][:,:,:,0]","e93e08ad":"seq = Seq(train_labels, extend=False, aug=False, batch_size=32)\nprint(len(seq))\nxs, ys = next(seq)\nprint(xs['input'].shape)\ny_pred = models['model_cnvt'].predict(xs['input'])\nprint(y_pred.shape)","57166d32":"y_pred[0]","0a20ddb5":"show_arr(y_pred[0])","70e1d4a1":"Image.fromarray(np.uint8((y_pred[0]+1)\/2*255))","9a7afc56":"seq_pred = Seq(train_labels, test=False, aug=False, batch_size=128)\nlen(seq_pred)","5e6a8cc6":"pred = models['model'].predict_generator(seq_pred, steps=len(seq_pred), verbose=1)","e8ddf7ab":"def calc_threshold(pred):\n    ### calc threshold\n    threshold_dic = {}\n    for idx in tqdm(range(28)):\n        m = 0\n        for ii in range(100):\n            threshold0 = ii*0.01\n            f1_val = f1_score(y_cat_train_dic[idx], threshold0<(pred[:,idx]))\n            if m < f1_val:\n                threshold_dic[idx] = threshold0+0.005\n                m = f1_val\n    return threshold_dic","d23d15c9":"threshold_dic = calc_threshold(pred)","dfb3eb24":"threshold_dic","df3edf0d":"seq_test = Seq(test_labels, test=True, aug=False, batch_size=128)\nseq_test","b0be8cec":"pred_test = models['model'].predict_generator(seq_test, steps=len(seq_test), verbose=1)","54583f81":"def make_test(pred):\n    test_labels1 = test_labels.copy()\n    test_labels1['Predicted'] = [str(ee) for ee in np.argmax(pred, axis=1)]\n    print(test_labels1.head())\n    #test_labels1.to_csv(fn0, index=False)\n    \n    test_labels2 = test_labels1.copy()\n    for ii in range(test_labels2.shape[0]):\n        threshold = list(zip(*sorted(list(threshold_dic.items()), key=lambda x:x[0], reverse=False)))[1]\n        idx = threshold < pred[ii,:]\n        tgt = test_labels2['Predicted'][ii]\n        tgt = [tgt] + [str(ee) for ee in np.arange(28)[idx]]\n        tgt = set(tgt)\n        tgt = ' '.join(tgt)\n        test_labels2['Predicted'][ii] = tgt\n    print(test_labels2.head())\n    #test_labels2.to_csv(fn, index=False)\n    return test_labels1, test_labels2","63faeb69":"test_labels1_1, test_labels1_2 = make_test(pred_test)","aa017cb2":"test_labels1_2.head()","45e2dfe7":"test_labels1_2.to_csv('InceptionResNetV1_2.csv', index=False)","a0bed11c":"'''save weights for later loading'''\nNo = 1\nmodels['model_cnvt'].save_weights('model_{}_cnvt.h5'.format(No))\nmodels['model_resnet'].save_weights('model_{}_resnet.h5'.format(No))\nmodels['model_classifier'].save_weights('model_{}_classifier.h5'.format(No))","e430b8c9":"ls -la","618b6595":"# model_cnvt = make_model_cnvt(512*512*4, (512,512,4))\n# model_cnvt.summary()","8e15269f":"# model_cnvt.layers[2].get_weights()","c8fcfa90":"# model_cnvt.load_weights('model_1_cnvt.h5')\n# model_cnvt.layers[2].get_weights()","1ec7972a":"# model_classifier = make_model_classifier()\n# model_classifier.summary()","9ea99a0b":"# model_classifier.layers[1].get_weights()[1]","98f40a46":"# model_classifier.load_weights('model_1_classifier.h5')\n# model_classifier.layers[1].get_weights()[1]","c21d7eb0":"# model_resnet = applications.inception_resnet_v2.InceptionResNetV2(\n#     include_top=False,\n#     weights='imagenet',\n#     input_tensor=None,\n#     input_shape=(512,512,3),\n#     pooling='avg',\n#     classes=None)\n# model_resnet.summary()","b1deaf81":"# models2 = make_model(512*512*4, model_cnvt, model_resnet, model_classifier)\n# models2['model'].summary()","76057b21":"model_resnet = applications.inception_resnet_v2.InceptionResNetV2(\n    include_top=False,\n    weights='imagenet',\n    input_tensor=None,\n    input_shape=(139,139,3),\n    pooling='avg',\n    classes=None)\n# model_resnet.summary()","be65afd5":"models = make_model(img_dim, model_cnvt, model_resnet, model_classifier)\nmodels['model'].summary()","55a4ff0b":"models['model'].compile(loss=focal_loss,\n                        optimizer='adam',\n                        metrics=['categorical_accuracy', 'binary_accuracy'])","33f65143":"seq = Seq(train_labels, aug=True, batch_size=64)\nprint(len(seq))\n\nhst = models['model'].fit_generator(seq, epochs=5,\n                              steps_per_epoch=len(seq),\n                              callbacks=[])","e189549d":"fig, ax = plt.subplots(1, 2, figsize=(15,5))\nax[0].set_title('loss')\nax[0].plot(hst.epoch, hst.history[\"loss\"], label=\"Train loss\")\nax[1].set_title('acc')\nax[1].plot(hst.epoch, hst.history[\"categorical_accuracy\"], label=\"categorical_accuracy\")\nax[1].plot(hst.epoch, hst.history[\"binary_accuracy\"], label=\"binary_accuracy\")\nax[0].legend()\nax[1].legend()","ea3e4176":"model_resnet.layers[1].get_weights()[0][:,:,:,0]","bfe3eab6":"seq_pred = Seq(train_labels, test=False, aug=False, batch_size=128)\nlen(seq_pred)\npred = models['model'].predict_generator(seq_pred, steps=len(seq_pred), verbose=1)\nthreshold_dic = calc_threshold(pred)\nthreshold_dic","8ad627fa":"seq_test = Seq(test_labels, test=True, aug=False, batch_size=128)\nseq_test\npred_test = models['model'].predict_generator(seq_test, steps=len(seq_test), verbose=1)\ntest_labels2_1, test_labels2_2 = make_test(pred_test)\ntest_labels2_2.head()","9fa8ce89":"test_labels2_2.to_csv('InceptionResNetV2_2.csv', index=False)","53ab1841":"'''save weights for later loading'''\nNo = 2\nmodels['model_cnvt'].save_weights('model_{}_cnvt.h5'.format(No))\nmodels['model_resnet'].save_weights('model_{}_resnet.h5'.format(No))\nmodels['model_classifier'].save_weights('model_{}_classifier.h5'.format(No))","f6e23605":"seq = Seq(train_labels, aug=True, batch_size=128)\nprint(len(seq))\n\nhst = models['model'].fit_generator(seq, epochs=5,\n                              steps_per_epoch=len(seq),\n                              callbacks=[])","7d960bfa":"fig, ax = plt.subplots(1, 2, figsize=(15,5))\nax[0].set_title('loss')\nax[0].plot(hst.epoch, hst.history[\"loss\"], label=\"Train loss\")\nax[1].set_title('acc')\nax[1].plot(hst.epoch, hst.history[\"categorical_accuracy\"], label=\"categorical_accuracy\")\nax[1].plot(hst.epoch, hst.history[\"binary_accuracy\"], label=\"binary_accuracy\")\nax[0].legend()\nax[1].legend()","c3fb7af2":"seq_pred = Seq(train_labels, test=False, aug=False, batch_size=128)\nlen(seq_pred)\npred = models['model'].predict_generator(seq_pred, steps=len(seq_pred), verbose=1)\nthreshold_dic = calc_threshold(pred)\nthreshold_dic","8d29f98c":"seq_test = Seq(test_labels, test=True, aug=False, batch_size=128)\nseq_test\npred_test = models['model'].predict_generator(seq_test, steps=len(seq_test), verbose=1)\ntest_labels3_1, test_labels3_2 = make_test(pred_test)\ntest_labels3_2.head()","4e071555":"test_labels3_2.to_csv('InceptionResNetV3_2.csv', index=False)","657b306f":"'''save weights for later loading'''\nNo = 3\nmodels['model_cnvt'].save_weights('model_{}_cnvt.h5'.format(No))\nmodels['model_resnet'].save_weights('model_{}_resnet.h5'.format(No))\nmodels['model_classifier'].save_weights('model_{}_classifier.h5'.format(No))","f860f92d":"def lr_schedule(epoch):\n    lr = 1e-4\n    print('Learning rate: ', lr)\n    return lr","2fb868fb":"lr_scheduler = LearningRateScheduler(lr_schedule)\ncallbacks = [lr_scheduler]\n\nseq = Seq(train_labels, aug=True, batch_size=128)\nprint(len(seq))\n\nhst = models['model'].fit_generator(seq, epochs=5,\n                              steps_per_epoch=len(seq),\n                              callbacks=callbacks)","aa9d0f76":"fig, ax = plt.subplots(1, 2, figsize=(15,5))\nax[0].set_title('loss')\nax[0].plot(hst.epoch, hst.history[\"loss\"], label=\"Train loss\")\nax[1].set_title('acc')\nax[1].plot(hst.epoch, hst.history[\"categorical_accuracy\"], label=\"categorical_accuracy\")\nax[1].plot(hst.epoch, hst.history[\"binary_accuracy\"], label=\"binary_accuracy\")\nax[0].legend()\nax[1].legend()","ca3ce9c5":"seq_pred = Seq(train_labels, test=False, aug=False, batch_size=128)\nlen(seq_pred)\npred = models['model'].predict_generator(seq_pred, steps=len(seq_pred), verbose=1)\nthreshold_dic = calc_threshold(pred)\nthreshold_dic","b981f4f9":"seq_test = Seq(test_labels, test=True, aug=False, batch_size=128)\nseq_test\npred_test = models['model'].predict_generator(seq_test, steps=len(seq_test), verbose=1)\ntest_labels4_1, test_labels4_2 = make_test(pred_test)\ntest_labels4_2.head()","05e6aeaa":"test_labels4_2.to_csv('InceptionResNetV4_2.csv', index=False)","ec04308c":"'''save weights for later loading'''\nNo = 4\nmodels['model_cnvt'].save_weights('model_{}_cnvt.h5'.format(No))\nmodels['model_resnet'].save_weights('model_{}_resnet.h5'.format(No))\nmodels['model_classifier'].save_weights('model_{}_classifier.h5'.format(No))","7f729321":"def lr_schedule(epoch):\n    lr = 1e-4\n    print('Learning rate: ', lr)\n    return lr","3ba9f881":"lr_scheduler = LearningRateScheduler(lr_schedule)\ncallbacks = [lr_scheduler]\n\nseq = Seq(train_labels, aug=True, batch_size=128)\nprint(len(seq))\n\nhst = models['model'].fit_generator(seq, epochs=5,\n                              steps_per_epoch=len(seq),\n                              callbacks=callbacks)","c1410262":"fig, ax = plt.subplots(1, 2, figsize=(15,5))\nax[0].set_title('loss')\nax[0].plot(hst.epoch, hst.history[\"loss\"], label=\"Train loss\")\nax[1].set_title('acc')\nax[1].plot(hst.epoch, hst.history[\"categorical_accuracy\"], label=\"categorical_accuracy\")\nax[1].plot(hst.epoch, hst.history[\"binary_accuracy\"], label=\"binary_accuracy\")\nax[0].legend()\nax[1].legend()","9d2eb234":"seq_pred = Seq(train_labels, test=False, aug=False, batch_size=128)\nlen(seq_pred)\npred = models['model'].predict_generator(seq_pred, steps=len(seq_pred), verbose=1)\nthreshold_dic = calc_threshold(pred)\nthreshold_dic","2087e18d":"seq_test = Seq(test_labels, test=True, aug=False, batch_size=128)\nseq_test\npred_test = models['model'].predict_generator(seq_test, steps=len(seq_test), verbose=1)\ntest_labels5_1, test_labels5_2 = make_test(pred_test)\ntest_labels5_2.head()","5c7542c5":"test_labels5_2.to_csv('InceptionResNetV5_2.csv', index=False)","97b64d10":"'''save weights for later loading'''\nNo = 5\nmodels['model_cnvt'].save_weights('model_{}_cnvt.h5'.format(No))\nmodels['model_resnet'].save_weights('model_{}_resnet.h5'.format(No))\nmodels['model_classifier'].save_weights('model_{}_classifier.h5'.format(No))","8f59f33e":"ls -la","18e9a951":"seq = Seq(train_labels, extend=False, aug=False, batch_size=32)\nprint(len(seq))\nxs, ys = next(seq)\nprint(xs['input'].shape)\ny_pred = models['model_cnvt'].predict(xs['input'])\nprint(y_pred.shape)","3c8f1464":"y_pred[0]","8ead930e":"show_arr(y_pred[0])","661b8dc9":"Image.fromarray(np.uint8((y_pred[0]+1)\/2*255))","b3575bb7":"### predict and submit","dd19fe6a":"## #2\n* batch_size = 64\n* model_resnet.trainable=True\n\nmake model_resnet    \nmake model with model_cnvt, model_resnet and model_classifier","b9c39779":"* no data expand, but augment  \n* try batch_size=128  \n* pre-train\n* tanh\n* focul loss","915ac3b5":"## #3\nbatch_size = 128","f3f3f0e0":"## save weights for later loading","6eee654b":"### make model","ac2fb5a0":"## #1\n * frozen\n * model_resnet.trainable=False","9949077a":"## #4\nbatch_size = 128","2f66201c":"### load cache","cde9a29e":"load test","a2bab8b6":"## #5"}}