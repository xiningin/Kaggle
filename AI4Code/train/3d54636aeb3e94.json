{"cell_type":{"160feefc":"code","56bb0dd5":"code","ec998d0a":"code","0814a6d7":"markdown"},"source":{"160feefc":"!pip install 'kaggle-environments>=0.1.6'","56bb0dd5":"%%writefile submission.py\n\n# greenberg roshambo bot, winner of 2nd annual roshambo programming competition\n# http:\/\/webdocs.cs.ualberta.ca\/~darse\/rsbpc.html\n\n# original source by Andrzej Nagorko\n# http:\/\/www.mathpuzzle.com\/greenberg.c\n\n# Python translation by Travis Erdman\n# https:\/\/github.com\/erdman\/roshambo\n\n\nimport random\nimport numpy as np\n\n\ndef recall(age, hist):\n    \"\"\"Looking at the last 'age' points in 'hist', finds the\n    last point with the longest similarity to the current point,\n    returning 0 if none found.\"\"\"\n    end, length = 0, 0\n    for past in range(1, min(age + 1, len(hist) - 1)):\n        if length >= len(hist) - past: break\n        for i in range(-1 - length, 0):\n            if hist[i - past] != hist[i]: break\n        else:\n            for length in range(length + 1, len(hist) - past):\n                if hist[-past - length - 1] != hist[-length - 1]: break\n            else: length += 1\n            end = len(hist) - past\n    return end\n\ndef beat(i):\n    return (i + 1) % 3\ndef loseto(i):\n    return (i - 1) % 3\n\nclass Stats:\n    \"\"\"Maintains three running counts and returns the highest count based\n         on any given time horizon and threshold.\"\"\"\n    def __init__(self):\n        self.sum = [[0, 0, 0]]\n    def add(self, move, score):\n        self.sum[-1][move] += score\n    def advance(self):\n        self.sum.append(self.sum[-1])\n    def max(self, age, default, score):\n        if age >= len(self.sum): diff = self.sum[-1]\n        else: diff = [self.sum[-1][i] - self.sum[-1 - age][i] for i in range(3)]\n        m = max(diff)\n        if m > score: return diff.index(m), m\n        return default, score\n\nclass Predictor:\n    \"\"\"The basic iocaine second- and triple-guesser.    Maintains stats on the\n         past benefits of trusting or second- or triple-guessing a given strategy,\n         and returns the prediction of that strategy (or the second- or triple-\n         guess) if past stats are deviating from zero farther than the supplied\n         \"best\" guess so far.\"\"\"\n    def __init__(self):\n        self.stats = Stats()\n        self.lastguess = -1\n    def addguess(self, lastmove, guess):\n        if lastmove != -1:\n            diff = (lastmove - self.prediction) % 3\n            self.stats.add(beat(diff), 1)\n            self.stats.add(loseto(diff), -1)\n            self.stats.advance()\n        self.prediction = guess\n    def bestguess(self, age, best):\n        bestdiff = self.stats.max(age, (best[0] - self.prediction) % 3, best[1])\n        return (bestdiff[0] + self.prediction) % 3, bestdiff[1]\n\nages = [1000, 100, 10, 5, 2, 1]\n\nclass Iocaine:\n\n    def __init__(self):\n        \"\"\"Build second-guessers for 50 strategies: 36 history-based strategies,\n             12 simple frequency-based strategies, the constant-move strategy, and\n             the basic random-number-generator strategy.    Also build 6 meta second\n             guessers to evaluate 6 different time horizons on which to score\n             the 50 strategies' second-guesses.\"\"\"\n        self.predictors = []\n        self.predict_history = self.predictor((len(ages), 2, 3))\n        self.predict_frequency = self.predictor((len(ages), 2))\n        self.predict_fixed = self.predictor()\n        self.predict_random = self.predictor()\n        self.predict_meta = [Predictor() for a in range(len(ages))]\n        self.stats = [Stats() for i in range(2)]\n        self.histories = [[], [], []]\n\n    def predictor(self, dims=None):\n        \"\"\"Returns a nested array of predictor objects, of the given dimensions.\"\"\"\n        if dims: return [self.predictor(dims[1:]) for i in range(dims[0])]\n        self.predictors.append(Predictor())\n        return self.predictors[-1]\n\n    def move(self, them):\n        \"\"\"The main iocaine \"move\" function.\"\"\"\n\n        # histories[0] stores our moves (last one already previously decided);\n        # histories[1] stores their moves (last one just now being supplied to us);\n        # histories[2] stores pairs of our and their last moves.\n        # stats[0] and stats[1] are running counters our recent moves and theirs.\n        if them != -1:\n            self.histories[1].append(them)\n            self.histories[2].append((self.histories[0][-1], them))\n            for watch in range(2):\n                self.stats[watch].add(self.histories[watch][-1], 1)\n\n        # Execute the basic RNG strategy and the fixed-move strategy.\n        rand = random.randrange(3)\n        self.predict_random.addguess(them, rand)\n        self.predict_fixed.addguess(them, 0)\n\n        # Execute the history and frequency stratgies.\n        for a, age in enumerate(ages):\n            # For each time window, there are three ways to recall a similar time:\n            # (0) by history of my moves; (1) their moves; or (2) pairs of moves.\n            # Set \"best\" to these three timeframes (zero if no matching time).\n            best = [recall(age, hist) for hist in self.histories]\n            for mimic in range(2):\n                # For each similar historical moment, there are two ways to anticipate\n                # the future: by mimicing what their move was; or mimicing what my\n                # move was.    If there were no similar moments, just move randomly.\n                for watch, when in enumerate(best):\n                    if not when: move = rand\n                    else: move = self.histories[mimic][when]\n                    self.predict_history[a][mimic][watch].addguess(them, move)\n                # Also we can anticipate the future by expecting it to be the same\n                # as the most frequent past (either counting their moves or my moves).\n                mostfreq, score = self.stats[mimic].max(age, rand, -1)\n                self.predict_frequency[a][mimic].addguess(them, mostfreq)\n\n        # All the predictors have been updated, but we have not yet scored them\n        # and chosen a winner for this round.    There are several timeframes\n        # on which we can score second-guessing, and we don't know timeframe will\n        # do best.    So score all 50 predictors on all 6 timeframes, and record\n        # the best 6 predictions in meta predictors, one for each timeframe.\n        for meta, age in enumerate(ages):\n            best = (-1, -1)\n            for predictor in self.predictors:\n                best = predictor.bestguess(age, best)\n            self.predict_meta[meta].addguess(them, best[0])\n\n        # Finally choose the best meta prediction from the final six, scoring\n        # these against each other on the whole-game timeframe. \n        best = (-1, -1)\n        for meta in range(len(ages)):\n            best = self.predict_meta[meta].bestguess(len(self.histories[0]) , best) \n\n        # We've picked a next move.    Record our move in histories[0] for next time.\n        self.histories[0].append(best[0])\n\n        # And return it.\n        return best[0]\n\ndef player(my_moves, opp_moves):\n    import random\n    from operator import itemgetter\n    rps_to_text = ('rock','paper','scissors')\n    rps_to_num  = {'rock':0, 'paper':1, 'scissors':2}\n    wins_with = (1,2,0)      #superior\n    best_without = (2,0,1)   #inferior\n\n    lengths = (10, 20, 30, 40, 49, 0)\n    p_random = random.choice([0,1,2])  #called 'guess' in iocaine\n\n    TRIALS = 1000\n    score_table =((0,-1,1),(1,0,-1),(-1,1,0))\n    T = len(opp_moves)  #so T is number of trials completed\n\n    def min_index(values):\n        return min(enumerate(values), key=itemgetter(1))[0]\n\n    def max_index(values):\n        return max(enumerate(values), key=itemgetter(1))[0]\n\n    def find_best_prediction(l):  # l = len\n        bs = -TRIALS\n        bp = 0\n        if player.p_random_score > bs:\n            bs = player.p_random_score\n            bp = p_random\n        for i in range(3):\n            for j in range(24):\n                for k in range(4):\n                    new_bs = player.p_full_score[T%50][j][k][i] - (player.p_full_score[(50+T-l)%50][j][k][i] if l else 0)\n                    if new_bs > bs:\n                        bs = new_bs\n                        bp = (player.p_full[j][k] + i) % 3\n                for k in range(2):\n                    new_bs = player.r_full_score[T%50][j][k][i] - (player.r_full_score[(50+T-l)%50][j][k][i] if l else 0)\n                    if new_bs > bs:\n                        bs = new_bs\n                        bp = (player.r_full[j][k] + i) % 3\n            for j in range(2):\n                for k in range(2):\n                    new_bs = player.p_freq_score[T%50][j][k][i] - (player.p_freq_score[(50+T-l)%50][j][k][i] if l else 0)\n                    if new_bs > bs:\n                        bs = new_bs\n                        bp = (player.p_freq[j][k] + i) % 3\n                    new_bs = player.r_freq_score[T%50][j][k][i] - (player.r_freq_score[(50+T-l)%50][j][k][i] if l else 0)\n                    if new_bs > bs:\n                        bs = new_bs\n                        bp = (player.r_freq[j][k] + i) % 3\n        return bp\n\n\n    if not my_moves:\n        player.opp_history = [0]  #pad to match up with 1-based move indexing in original\n        player.my_history = [0]\n        player.gear = [[0] for _ in range(24)]\n        # init()\n        player.p_random_score = 0\n        player.p_full_score = [[[[0 for i in range(3)] for k in range(4)] for j in range(24)] for l in range(50)]\n        player.r_full_score = [[[[0 for i in range(3)] for k in range(2)] for j in range(24)] for l in range(50)]\n        player.p_freq_score = [[[[0 for i in range(3)] for k in range(2)] for j in range(2)] for l in range(50)]\n        player.r_freq_score = [[[[0 for i in range(3)] for k in range(2)] for j in range(2)] for l in range(50)]\n        player.s_len = [0] * 6\n\n        player.p_full = [[0,0,0,0] for _ in range(24)]\n        player.r_full = [[0,0] for _ in range(24)]\n    else:\n        player.my_history.append(rps_to_num[my_moves[-1]])\n        player.opp_history.append(rps_to_num[opp_moves[-1]])\n        # update_scores()\n        player.p_random_score += score_table[p_random][player.opp_history[-1]]\n        player.p_full_score[T%50] = [[[player.p_full_score[(T+49)%50][j][k][i] + score_table[(player.p_full[j][k] + i) % 3][player.opp_history[-1]] for i in range(3)] for k in range(4)] for j in range(24)]\n        player.r_full_score[T%50] = [[[player.r_full_score[(T+49)%50][j][k][i] + score_table[(player.r_full[j][k] + i) % 3][player.opp_history[-1]] for i in range(3)] for k in range(2)] for j in range(24)]\n        player.p_freq_score[T%50] = [[[player.p_freq_score[(T+49)%50][j][k][i] + score_table[(player.p_freq[j][k] + i) % 3][player.opp_history[-1]] for i in range(3)] for k in range(2)] for j in range(2)]\n        player.r_freq_score[T%50] = [[[player.r_freq_score[(T+49)%50][j][k][i] + score_table[(player.r_freq[j][k] + i) % 3][player.opp_history[-1]] for i in range(3)] for k in range(2)] for j in range(2)]\n        player.s_len = [s + score_table[p][player.opp_history[-1]] for s,p in zip(player.s_len,player.p_len)]\n\n\n    # update_history_hash()\n    if not my_moves:\n        player.my_history_hash = [[0],[0],[0],[0]]\n        player.opp_history_hash = [[0],[0],[0],[0]]\n    else:\n        player.my_history_hash[0].append(player.my_history[-1])\n        player.opp_history_hash[0].append(player.opp_history[-1])\n        for i in range(1,4):\n            player.my_history_hash[i].append(player.my_history_hash[i-1][-1] * 3 + player.my_history[-1])\n            player.opp_history_hash[i].append(player.opp_history_hash[i-1][-1] * 3 + player.opp_history[-1])\n\n\n    #make_predictions()\n\n    for i in range(24):\n        player.gear[i].append((3 + player.opp_history[-1] - player.p_full[i][2]) % 3)\n        if T > 1:\n            player.gear[i][T] += 3 * player.gear[i][T-1]\n        player.gear[i][T] %= 9 # clearly there are 9 different gears, but original code only allocated 3 gear_freq's\n                               # code apparently worked, but got lucky with undefined behavior\n                               # I fixed by allocating gear_freq with length = 9\n    if not my_moves:\n        player.freq = [[0,0,0],[0,0,0]]\n        value = [[0,0,0],[0,0,0]]\n    else:\n        player.freq[0][player.my_history[-1]] += 1\n        player.freq[1][player.opp_history[-1]] += 1\n        value = [[(1000 * (player.freq[i][2] - player.freq[i][1])) \/ float(T),\n                  (1000 * (player.freq[i][0] - player.freq[i][2])) \/ float(T),\n                  (1000 * (player.freq[i][1] - player.freq[i][0])) \/ float(T)] for i in range(2)]\n    player.p_freq = [[wins_with[max_index(player.freq[i])], wins_with[max_index(value[i])]] for i in range(2)]\n    player.r_freq = [[best_without[min_index(player.freq[i])], best_without[min_index(value[i])]] for i in range(2)]\n\n    f = [[[[0,0,0] for k in range(4)] for j in range(2)] for i in range(3)]\n    t = [[[0,0,0,0] for j in range(2)] for i in range(3)]\n\n    m_len = [[0 for _ in range(T)] for i in range(3)]\n\n    for i in range(T-1,0,-1):\n        m_len[0][i] = 4\n        for j in range(4):\n            if player.my_history_hash[j][i] != player.my_history_hash[j][T]:\n                m_len[0][i] = j\n                break\n        for j in range(4):\n            if player.opp_history_hash[j][i] != player.opp_history_hash[j][T]:\n                m_len[1][i] = j\n                break\n        for j in range(4):\n            if player.my_history_hash[j][i] != player.my_history_hash[j][T] or player.opp_history_hash[j][i] != player.opp_history_hash[j][T]:\n                m_len[2][i] = j\n                break\n\n    for i in range(T-1,0,-1):\n        for j in range(3):\n            for k in range(m_len[j][i]):\n                f[j][0][k][player.my_history[i+1]] += 1\n                f[j][1][k][player.opp_history[i+1]] += 1\n                t[j][0][k] += 1\n                t[j][1][k] += 1\n\n                if t[j][0][k] == 1:\n                    player.p_full[j*8 + 0*4 + k][0] = wins_with[player.my_history[i+1]]\n                if t[j][1][k] == 1:\n                    player.p_full[j*8 + 1*4 + k][0] = wins_with[player.opp_history[i+1]]\n                if t[j][0][k] == 3:\n                    player.p_full[j*8 + 0*4 + k][1] = wins_with[max_index(f[j][0][k])]\n                    player.r_full[j*8 + 0*4 + k][0] = best_without[min_index(f[j][0][k])]\n                if t[j][1][k] == 3:\n                    player.p_full[j*8 + 1*4 + k][1] = wins_with[max_index(f[j][1][k])]\n                    player.r_full[j*8 + 1*4 + k][0] = best_without[min_index(f[j][1][k])]\n\n    for j in range(3):\n        for k in range(4):\n            player.p_full[j*8 + 0*4 + k][2] = wins_with[max_index(f[j][0][k])]\n            player.r_full[j*8 + 0*4 + k][1] = best_without[min_index(f[j][0][k])]\n\n            player.p_full[j*8 + 1*4 + k][2] = wins_with[max_index(f[j][1][k])]\n            player.r_full[j*8 + 1*4 + k][1] = best_without[min_index(f[j][1][k])]\n\n    for j in range(24):\n        gear_freq = [0] * 9 # was [0,0,0] because original code incorrectly only allocated array length 3\n\n        for i in range(T-1,0,-1):\n            if player.gear[j][i] == player.gear[j][T]:\n                gear_freq[player.gear[j][i+1]] += 1\n\n        #original source allocated to 9 positions of gear_freq array, but only allocated first three\n        #also, only looked at first 3 to find the max_index\n        #unclear whether to seek max index over all 9 gear_freq's or just first 3 (as original code)\n        player.p_full[j][3] = (player.p_full[j][1] + max_index(gear_freq)) % 3\n\n    # end make_predictions()\n\n    player.p_len = [find_best_prediction(l) for l in lengths]\n\n    return rps_to_num[rps_to_text[player.p_len[max_index(player.s_len)]]]\n\nopponent_hist, my_hist = [], []\nact = None\niocaine = None\n\ndef greenberg_agent(observation, configuration):\n    global opponent_hist, my_hist, act, iocaine\n    \n    rps_to_text = ('rock','paper','scissors')\n    if observation.step > 0:\n        my_hist.append(rps_to_text[act])\n        opponent_hist.append(rps_to_text[observation.lastOpponentAction])\n    else:\n        iocaine = Iocaine()\n        \n    greenberg_act = player(my_hist, opponent_hist)\n    if observation.step > 0:\n        iocaine_act = iocaine.move(observation.lastOpponentAction)\n    else:\n        iocaine_act = iocaine.move(-1)\n    \n    if np.random.random() < 0.5:\n        act = greenberg_act\n    else:\n        act = iocaine_act\n    \n    return act","ec998d0a":"from kaggle_environments import evaluate, make, utils\nenv = make(\"rps\", debug=True)\nenv.render()\n\nenv.reset()\n# Play as the first agent against default \"random\" agent.\nenv.run([\"submission.py\", \"..\/input\/rps-opponent-transition-matrix\/submission.py\"])\nenv.render(mode=\"ipython\", width=800, height=800)\n","0814a6d7":"Source: https:\/\/github.com\/erdman\/roshambo\/blob\/master\/greenberg.py"}}