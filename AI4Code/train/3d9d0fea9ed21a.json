{"cell_type":{"132e7909":"code","18e67005":"code","26e24372":"code","1ce69622":"code","a6b61463":"code","181afc10":"code","d07f2ba8":"code","1120238a":"code","921cb99f":"code","c2544198":"code","c1d9c753":"code","aad27a52":"code","362a7fa5":"code","6158d4f6":"code","ae36e2b4":"code","7a4cae14":"code","f8107faa":"code","92482c73":"code","81434721":"code","9d4d4a30":"code","10d7cc86":"code","3e742cee":"markdown","c4cfbc2d":"markdown","74c046ea":"markdown","f83c6bbd":"markdown","48f801f3":"markdown","074fb855":"markdown"},"source":{"132e7909":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","18e67005":"import pandas as pd","26e24372":"recipes_df = pd.read_csv('..\/input\/foodcom-recipes-and-reviews\/recipes.csv')\nreviews_df = pd.read_csv('..\/input\/foodcom-recipes-and-reviews\/reviews.csv')","1ce69622":"recipes_df.head()","a6b61463":"recipes_df.iloc[0]","181afc10":"reviews_df.head()","d07f2ba8":"reviews_df.iloc[0]","1120238a":"recipe_cols = ['RecipeId', 'Name', 'CookTime', 'PrepTime', 'TotalTime', 'Description', 'Images',\\\n              'RecipeCategory', 'Keywords', 'RecipeIngredientQuantities', 'RecipeIngredientParts', \\\n              'AggregatedRating', 'Calories', 'RecipeServings', 'RecipeYield', 'RecipeInstructions']\nreview_cols = ['ReviewId', 'RecipeId', 'Rating', 'Review']","921cb99f":"# limit recipe entries\nrp_df = recipes_df[recipe_cols]\nrv_df = reviews_df[review_cols]\n# extract rows with reviews\nrp_df = pd.DataFrame.merge(rp_df, rv_df.RecipeId, on='RecipeId').drop_duplicates('RecipeId')","c2544198":"rp_df.info()","c1d9c753":"recipe_col_subset = ['RecipeId', 'Name', 'CookTime', 'PrepTime', 'TotalTime', 'Description', 'Images',\\\n              'RecipeCategory', 'Keywords', 'RecipeIngredientQuantities', 'RecipeIngredientParts', \\\n              'AggregatedRating', 'Calories', 'RecipeInstructions']\n\nrp_df = rp_df.dropna(subset=recipe_col_subset)\nrp_df = rp_df[rp_df.Images != 'character(0)']\nrp_df.info()","aad27a52":"# reduce rows\nrp_df = rp_df[:10000]\nrv_df = pd.DataFrame.merge(rv_df, rp_df.RecipeId, how='inner')","362a7fa5":"%%time\n# This take about 35s with 10000 rows\n# RecipeId as a key, list of dict as a value\nrc_rv_dict = dict()\nfor name, df in rv_df.groupby('RecipeId'):\n    # drop unnecessary column, set index and transpose (to create dict)\n    df = df.drop('RecipeId', axis=1).set_index('ReviewId').T\n    dict1 = df.to_dict('dict')\n    rc_rv_dict[name] = dict1","6158d4f6":"# add a new column\nrp_df['reviews_in_dict'] = rp_df.RecipeId.apply(lambda x: rc_rv_dict[x])","ae36e2b4":"import re\n\ndef map_str_to_list(string):\n    #pattern = re.compile(r'\\\"(.+)\\\"')\n    pattern = re.compile(r'\\\"([^\"]+)\\\"')\n    return pattern.findall(string)\n\ndef map_for_series(series: pd.Series):\n    return series.apply(lambda i: map_str_to_list(i))","7a4cae14":"modify_col_list = ['Images', 'Keywords', 'RecipeIngredientQuantities', 'RecipeIngredientParts', 'RecipeInstructions']\nrp_df = rp_df.apply(lambda x: map_for_series(x) if x.name in modify_col_list else x)","f8107faa":"rp_df.reviews_in_dict.iat[4]","92482c73":"rp_df.reset_index().to_json('recipe_10000.json')","81434721":"def score_recipes(user_input, df, best_num):\n    '''\n    user_input: list of strings\n    df: our list of recipes\n    best_num: number of best matching result to return\n    '''\n    df = df.copy()\n    \n    def score(ingredient_list):\n        score = 0\n        for w in user_input:\n            if w in ingredient_list:\n                score += 1\n        return score\n    \n    df['score'] = df['RecipeIngredientParts'].apply(lambda x: score(x))\n    df = df.sort_values(by='score', ascending=False).iloc[:best_num]\n    return df","9d4d4a30":"user_input = ['potato', 'carrots', 'pork', 'chestnuts', 'butter', 'salmon']\nscore_recipes(user_input, rp_df, 3)","10d7cc86":"user_input = ['potatoes', 'carrots', 'pork']\nscore_recipes(user_input, rp_df, 3)","3e742cee":"# Load the datasets","c4cfbc2d":"## Delete rows with null values","74c046ea":"# Pre-processing","f83c6bbd":"# Give reccomendations (testing exact match method)","48f801f3":"## Drop columns, reduce rows, and join reviews","074fb855":"# Clean the following columns:\n\nImages, Keywords, RecipeIngredientQuantities, RecipeIngredientParts, RecipeInstructions"}}