{"cell_type":{"8e9dae26":"code","c9f26109":"code","aa72c4c9":"code","d3b1917c":"code","903a9b9d":"code","8d1401bd":"code","0b27ae7e":"code","c4dac216":"code","78ef57d9":"code","3fb75de7":"code","771cf721":"code","1731b0b5":"code","9a0536e7":"code","fc7693dd":"code","bd762174":"code","a67ac2ee":"code","12fd4448":"code","e3e533f0":"code","f688d318":"code","38864c39":"code","30544fd7":"code","bca1b05e":"code","d51798b8":"code","ccea8fa4":"code","6fdf7f88":"code","622d2774":"code","e2238bab":"code","7e0ba810":"code","7f2b9643":"code","cc570837":"code","cefde678":"code","9ecbe26c":"code","743866be":"code","849649de":"code","9f0c807c":"code","309ef7ff":"code","52c24e9b":"code","a44df99e":"code","0e99233e":"code","1b908a15":"code","5c8cf713":"code","cfac8894":"markdown","a1236612":"markdown","40bfa155":"markdown","4aa1dcdf":"markdown","b22e420c":"markdown","45ffa399":"markdown","e3be1312":"markdown","11bfbd6b":"markdown","e3fa4285":"markdown","d91d0c97":"markdown","b6828826":"markdown","d984385b":"markdown","a862f673":"markdown"},"source":{"8e9dae26":"!pip install imutils","c9f26109":"# import the necessary packages\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\n\nfrom tensorflow.keras.utils import to_categorical\nfrom sklearn.preprocessing import LabelBinarizer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom IPython.display import FileLink\nfrom imutils import paths\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\nnp.random.seed(0)\n\nimport random\nimport shutil\nimport cv2\nimport os\n","aa72c4c9":"dataset_path = '.\/dataset'","d3b1917c":"%%bash\nrm -rf dataset\nmkdir -p dataset\/covid\nmkdir -p dataset\/normal","903a9b9d":"samples = 25","8d1401bd":"covid_dataset_path = '..\/input\/covid-chest-xray'","0b27ae7e":"# construct the path to the metadata CSV file and load it\ncsvPath = os.path.sep.join([covid_dataset_path, \"metadata.csv\"])\ndf = pd.read_csv(csvPath)\n\n# loop over the rows of the COVID-19 data frame\nfor (i, row) in df.iterrows():\n    # if (1) the current case is not COVID-19 or (2) this is not\n    # a 'PA' view, then ignore the row\n    if row[\"finding\"] != \"COVID-19\" or row[\"view\"] != \"PA\":\n        continue\n\n    # build the path to the input image file\n    imagePath = os.path.sep.join([covid_dataset_path, \"images\", row[\"filename\"]])\n\n    # if the input image file does not exist (there are some errors in\n    # the COVID-19 metadeta file), ignore the row\n    if not os.path.exists(imagePath):\n        continue\n\n    # extract the filename from the image path and then construct the\n    # path to the copied image file\n    filename = row[\"filename\"].split(os.path.sep)[-1]\n    outputPath = os.path.sep.join([f\"{dataset_path}\/covid\", filename])\n\n    # copy the image\n    shutil.copy2(imagePath, outputPath)","c4dac216":"pneumonia_dataset_path ='..\/input\/chest-xray-pneumonia\/chest_xray'","78ef57d9":"basePath = os.path.sep.join([pneumonia_dataset_path, \"train\", \"NORMAL\"])\nimagePaths = list(paths.list_images(basePath))\n\n# randomly sample the image paths\nrandom.seed(42)\nrandom.shuffle(imagePaths)\nimagePaths = imagePaths[:samples]\n\n# loop over the image paths\nfor (i, imagePath) in enumerate(imagePaths):\n    # extract the filename from the image path and then construct the\n    # path to the copied image file\n    filename = imagePath.split(os.path.sep)[-1]\n    outputPath = os.path.sep.join([f\"{dataset_path}\/normal\", filename])\n\n    # copy the image\n    shutil.copy2(imagePath, outputPath)","3fb75de7":"def ceildiv(a, b):\n    return -(-a \/\/ b)\n\ndef plots_from_files(imspaths, figsize=(10,5), rows=1, titles=None, maintitle=None):\n    \"\"\"Plot the images in a grid\"\"\"\n    f = plt.figure(figsize=figsize)\n    if maintitle is not None: plt.suptitle(maintitle, fontsize=10)\n    for i in range(len(imspaths)):\n        sp = f.add_subplot(rows, ceildiv(len(imspaths), rows), i+1)\n        sp.axis('Off')\n        if titles is not None: sp.set_title(titles[i], fontsize=16)\n        img = plt.imread(imspaths[i])\n        plt.imshow(img)","771cf721":"normal_images = list(paths.list_images(f\"{dataset_path}\/normal\"))\ncovid_images = list(paths.list_images(f\"{dataset_path}\/covid\"))","1731b0b5":"normal_images","9a0536e7":"covid_images","fc7693dd":"plots_from_files(normal_images, rows=5, maintitle=\"Normal X-ray images\")","bd762174":"plots_from_files(covid_images, rows=5, maintitle=\"Covid-19 X-ray images\")","a67ac2ee":"# grab the list of images in our dataset directory, then initialize\n# the list of data (i.e., images) and class images\n\nprint(\"[INFO] loading images...\")\nimagePaths = list(paths.list_images(dataset_path))\n\ndata = []\nlabels = []\n\n# loop over the image paths\nfor imagePath in imagePaths:\n    # extract the class label from the filename\n    label = imagePath.split(os.path.sep)[-2]\n    # load the image, swap color channels, and resize it to be a fixed\n    # 224x224 pixels while ignoring aspect ratio\n    image = cv2.imread(imagePath)\n    image = cv2.cvtColor(image, cv2.IMREAD_GRAYSCALE)\n    image = cv2.resize(image, (224, 224))\n    # update the data and labels lists, respectively\n    image_np = (image).flatten()\n    data.append(image_np)\n    labels.append(label)\n    \n# convert the data and labels to NumPy arrays while scaling the pixel\n# intensities to the range [0, 1]\ndata_train = np.array(data) \/ 255\nlabels_train = np.array(labels)","12fd4448":"data","e3e533f0":"len(data)","f688d318":"labels","38864c39":"len(labels)","30544fd7":"data_train","bca1b05e":"labels_train","d51798b8":"# perform one-hot encoding on the labels\nlb = LabelBinarizer()\nlabels_train_y = lb.fit_transform(labels_train)\nlabels_train_cat = to_categorical(labels_train_y)\n\n# partition the data into training and testing splits using 80% of\n# the data for training and the remaining 20% for testing\n\n(X_train, X_test, y_train, y_test) = train_test_split(data, labels, test_size=0.20, stratify=labels, random_state=42)\n\n","ccea8fa4":"X_train","6fdf7f88":"y_train","622d2774":"from sklearn.naive_bayes import GaussianNB\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import LinearSVC\nfrom sklearn.calibration import calibration_curve\n\n\n\n# Create classifiers\nlr = LogisticRegression(max_iter=10000)\ngnb = GaussianNB()\nsvc = LinearSVC(C=1.0, max_iter=10000)\nrfc = RandomForestClassifier()\n\n\n\n","e2238bab":"LR_Model = lr.fit(X_train, y_train)\nGNB_Model = gnb.fit(X_train, y_train)\nSVC_Model = svc.fit(X_train, y_train)\nRFC_Model = rfc.fit(X_train, y_train)","7e0ba810":"import pickle\n\nwith open('LR_model.pkl', 'wb') as f1:\n    pickle.dump(LR_Model,f1)\n    f1.close()\n\nwith open('GNB_model.pkl', 'wb') as f2:\n    pickle.dump(GNB_Model,f2)\n    f2.close()\n\nwith open('SVM_model.pkl', 'wb') as f3:\n    pickle.dump(SVC_Model,f3)\n    f3.close()\n\nwith open('RF_model.pkl', 'wb') as f4:\n    pickle.dump(RFC_Model,f4)\n    f4.close()\n\n\n    \n","7f2b9643":"from IPython.display import FileLink\n\nFileLink(r'LR_model.pkl')\n","cc570837":"FileLink(r'GNB_model.pkl')\n","cefde678":"FileLink(r'SVM_model.pkl')\n","9ecbe26c":"FileLink(r'RF_model.pkl')","743866be":"from sklearn.metrics import accuracy_score\n\n\nLR_y_pred = LR_Model.predict(X_test)\nGNB_y_pred = GNB_Model.predict(X_test)\nSVC_y_pred = SVC_Model.predict(X_test)\nRFC_y_pred = RFC_Model.predict(X_test)\n\n\n# accuracy_score(y_true, y_pred)\n","849649de":"LR_acc_sc = accuracy_score(y_test, LR_y_pred)\nLR_acc_sc","9f0c807c":"GNB_acc_sc = accuracy_score(y_test, GNB_y_pred)\nGNB_acc_sc","309ef7ff":"SVC_acc_sc = accuracy_score(y_test, SVC_y_pred)\nSVC_acc_sc","52c24e9b":"RFC_acc_sc = accuracy_score(y_test, RFC_y_pred)\nRFC_acc_sc","a44df99e":"print('LogisticRegression score: %f' % LR_Model.score(X_test, y_test))\nprint('Naive Bayes score: %f' % GNB_Model.score(X_test, y_test))\nprint('SVM score: %f' % SVC_Model.score(X_test, y_test))\nprint('Random Forest score: %f' % RFC_Model.score(X_test, y_test))","0e99233e":"# #############################################################################\n# Plot calibration plots\n\nplt.figure(figsize=(10, 10))\nax1 = plt.subplot2grid((3, 1), (0, 0), rowspan=2)\nax2 = plt.subplot2grid((3, 1), (2, 0))\n\nax1.plot([0, 1], [0, 1], \"k:\", label=\"Perfectly calibrated\")\nfor clf, name in [(lr, 'Logistic'),\n                  (gnb, 'Naive Bayes'),\n                  (svc, 'Support Vector Classification'),\n                  (rfc, 'Random Forest')]:\n    clf.fit(X_train, y_train)\n    if hasattr(clf, \"predict_proba\"):\n        prob_pos = clf.predict_proba(X_test)[:, 1]\n    else:  # use decision function\n        prob_pos = clf.decision_function(X_test)\n        prob_pos = \\\n            (prob_pos - prob_pos.min()) \/ (prob_pos.max() - prob_pos.min())\n    fraction_of_positives, mean_predicted_value = \\\n        calibration_curve(y_test, prob_pos, n_bins=10)\n\n    ax1.plot(mean_predicted_value, fraction_of_positives, \"s-\",\n             label=\"%s\" % (name, ))\n\n    ax2.hist(prob_pos, range=(0, 1), bins=10, label=name,\n             histtype=\"step\", lw=2)\n\nax1.set_ylabel(\"Fraction of positives\")\nax1.set_ylim([-0.05, 1.05])\nax1.legend(loc=\"lower right\")\nax1.set_title('Calibration plots  (reliability curve)')\n\nax2.set_xlabel(\"Mean predicted value\")\nax2.set_ylabel(\"Count\")\nax2.legend(loc=\"upper center\", ncol=2)\n\nplt.tight_layout()\nplt.show()\n","1b908a15":"\n\ntest_image = cv2.imread('..\/input\/covid-chest-xray\/images\/1-s2.0-S1684118220300608-main.pdf-002.jpg')\ntest_image = cv2.cvtColor(test_image, cv2.IMREAD_GRAYSCALE)\ntest_image = cv2.resize(test_image, (224, 224))\ntest_img = test_image.flatten().reshape(1, -1)\n\n\nLR_pred = LR_Model.predict(test_img)\nprint(LR_pred)\n\nGNB_pred = GNB_Model.predict(test_img)\nprint(GNB_pred)\n\nSVC_pred = SVC_Model.predict(test_img)\nprint(SVC_pred)\n\nRFC_pred = RFC_Model.predict(test_img)\nprint(RFC_pred)\n\n","5c8cf713":"\n\ntest_image = cv2.imread('..\/input\/chest-xray-pneumonia\/chest_xray\/test\/NORMAL\/IM-0003-0001.jpeg')\ntest_image = cv2.cvtColor(test_image, cv2.IMREAD_GRAYSCALE)\ntest_image = cv2.resize(test_image, (224, 224))\ntest_img = test_image.flatten().reshape(1, -1)\n\n\nLR_pred = LR_Model.predict(test_img)\nprint(LR_pred)\n\nGNB_pred = GNB_Model.predict(test_img)\nprint(GNB_pred)\n\nSVC_pred = SVC_Model.predict(test_img)\nprint(SVC_pred)\n\nRFC_pred = RFC_Model.predict(test_img)\nprint(RFC_pred)\n\n","cfac8894":"## Data preprocessing","a1236612":"> \/opt\/conda\/lib\/python3.7\/site-packages\/sklearn\/svm\/_base.py:977: ConvergenceWarning: Liblinear failed to converge, increase the number of iterations.\n>   \"the number of iterations.\", ConvergenceWarning)","40bfa155":"### Build normal xray dataset","4aa1dcdf":"## Plot x-rays","b22e420c":"# Now save the model","45ffa399":"## Comparison of Calibration of Classifiers","e3be1312":"Test on normal image:","11bfbd6b":"Test on covid image:","e3fa4285":"# Metrics","d91d0c97":"## Build Dataset","b6828826":"### Covid xray dataset","d984385b":"Helper function to plot the images in a grid","a862f673":"# FIT MODELS"}}