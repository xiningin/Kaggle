{"cell_type":{"fe7afa10":"code","bba7e7ff":"code","1c4236a6":"code","7c7dff61":"code","a2eb4516":"code","fa29b241":"code","6fb4bf11":"code","7b23a0a4":"code","d5433706":"markdown","6a9c7bd6":"markdown","18c85536":"markdown","5361af3c":"markdown","85d70db7":"markdown","d4c8530e":"markdown","0cafa0af":"markdown","8a203ea0":"markdown"},"source":{"fe7afa10":"import pandas as pd\nfrom math import exp\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt \n\n","bba7e7ff":"df1= pd.read_csv('\/kaggle\/input\/pima-indians-diabetes-database\/diabetes.csv')\nX1= df1.iloc[0:768,0:8]\nY= df1.iloc[0:768,8]\n","1c4236a6":"X2= ((X1-np.mean(X1))\/(np.max(X1)-np.min(X1)))","7c7dff61":"X_train= X2.iloc[0:614,:]\nY_train= Y.iloc[0:614]\n\nX_test1= X2.iloc[614:768,:]\nX_test= X_test1.reset_index(drop=True)\nY_test1= Y.iloc[614:768]\nY_test= Y_test1.reset_index(drop=True)","a2eb4516":"def predict(X,weights):\n        predictions= np.dot(X,weights)\n        predictions= -1* predictions\n        predictions= np.exp(predictions)\n        predictions= 1.0\/ (1.0 + predictions)\n        thr= 0.6\n    \n        for i in range(0,len(predictions)):\n            if(predictions[i]>=thr):\n                predictions[i]=1\n            else:      \n                predictions[i]=0 \n        predictions= predictions.tolist()         \n        return predictions\n        \n\n","fa29b241":"def accurate(predictions,Y):\n        correct=0\n        for i in range(0,len(Y)):\n            if predictions[i]==Y[i]:\n                correct+=1\n        return (correct\/ (len(Y)))*100        \n        ","6fb4bf11":"def weights(X,Y,l_r,epochs,lamb):\n        weight = np.zeros(len(X.columns)) \n        weight1= np.transpose(weight)\n        weights = pd.Series(weight1) \n        \n        for epoch in range(epochs):\n            predictions= predict(X,weights)\n            error= predictions- Y\n            Xt= X.transpose()\n            \n            weights= pd.Series(weights)\n            t1= np.dot(Xt,error)\n            t2=lamb* weights\n            \n            fac= l_r\/len(X)\n            term= t1+ t2\n                   \n            weights= weights- fac*(term)\n            weights= weights.tolist()\n        return weights","7b23a0a4":"epochs = 300\nl_r= 0.1\nlamb= [0,0.01,0.02,0.04,0.08,0.16,0.32,0.64,1.28,2.56,5.12,10.24]\n# lamb= [0]\naccuracy1= []\naccuracy2= []\naccuracy3= []\n    \nfor i in lamb:\n    weights1= weights(X2, Y,l_r,epochs,i)\n    predictions1= predict(X2,weights1)\n    accuracy= accurate(predictions1,Y)\n    accuracy1.append(accuracy)\n        \n   \n    predictions2= predict(X_test,weights1)\n    accuracy= accurate(predictions2,Y_test)\n    accuracy2.append(accuracy)\n        \n    \nplt.plot(lamb, accuracy1, label = \"train\")  \nplt.plot(lamb, accuracy2, label = \"test\") \n# plt.plot(lamb, accuracy3, label = \"test\")\nplt.ylabel('accuracy') \nplt.title('lamb choosing')   \nplt.legend() \nplt.show() \n# print(accuracy1)\n# print(accuracy2)\n\n","d5433706":"# 8. Measuring accuracy with Regularization","6a9c7bd6":"# 1. Load Libraries\n","18c85536":"# Estimating Weights","5361af3c":"# 4.Train and Test data","85d70db7":"# 5. Predict Function","d4c8530e":"# 3. Scalling Data","0cafa0af":"# 2. Read the Data\n","8a203ea0":"# 6. Accuracy Function"}}