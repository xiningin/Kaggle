{"cell_type":{"3399aec1":"code","ea794a3c":"code","b783a916":"code","12d2d7fe":"code","465cc6a3":"code","24c08b70":"code","b7a998f6":"code","1fe59d8d":"code","75611acb":"code","53e83024":"code","f403ae6b":"code","e75506a0":"code","6c091bfc":"code","af4375bd":"code","6aeac948":"code","eaa13ba2":"code","261ebfe3":"code","a6e2ca6e":"code","8512c0c7":"code","9347cd9b":"code","b8c1a0c1":"markdown","aa132d76":"markdown","f20e4650":"markdown","55e7617f":"markdown","0436c733":"markdown"},"source":{"3399aec1":"# importing the essential libraries\nimport tensorflow as tf\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\n# importing the libraries required for neural networks\nfrom tensorflow.keras.preprocessing import image\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout\n\nfrom sklearn.metrics import classification_report\nfrom sklearn.model_selection import train_test_split","ea794a3c":"# getting the training data\ntraining_data = pd.read_csv('\/kaggle\/input\/digit-recognizer\/train.csv')","b783a916":"training_data.head()","12d2d7fe":"# splitting the input features and target features.\nX = training_data.drop(['label'], axis = 1)\ny = training_data['label'].values","465cc6a3":"X.head()","24c08b70":"# Tensorflow layers expects the inputs in the form of Array \n# Conv2D expects the dimension to be ndim=4\nX = np.array(X)\nX = X.reshape(42000, 28, 28, 1)","b7a998f6":"# Splitting the data into training and evaluation\n# holdout validation method\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2)","1fe59d8d":"classes = len(set(y))","75611acb":"# I am creating a neural network with 13 deep hidden layers + 1 input and 1 output layer.\ncnn_model = Sequential(name = 'C-Neural_Network_Model')\ncnn_model.add(Conv2D(filters = 64, kernel_size = (5, 5), activation = 'relu', input_shape = (28, 28, 1), name = 'First_layer'))\ncnn_model.add(MaxPooling2D(pool_size = (2, 2), name = 'Second_layer'))\ncnn_model.add(Dropout(rate = 0.2, name = 'Third_layer'))\ncnn_model.add(Conv2D(filters = 128, kernel_size = (3, 3), activation = 'relu', name = 'Fourth_layer'))\ncnn_model.add(MaxPooling2D(pool_size = (2, 2), name = 'Fifth_layer'))\ncnn_model.add(Dropout(rate = 0.2, name = 'Sixth_layer'))\ncnn_model.add(Conv2D(filters = 128, kernel_size = (3, 3), activation = 'relu', name = 'Seventh_layer'))\ncnn_model.add(MaxPooling2D(pool_size = (2, 2), name = 'Eighth_layer'))\ncnn_model.add(Dropout(rate = 0.15, name = 'nineth_layer'))\ncnn_model.add(Flatten(name = 'tenth_layer'))\ncnn_model.add(Dense(units = 128, activation = 'relu', name = 'eleventh_layer'))\ncnn_model.add(Dropout(rate = 0.1, name = 'twelfth_layer'))\ncnn_model.add(Dense(units = 32, activation = 'relu', name = 'Thirteenth_layer'))\ncnn_model.add(Dropout(rate = 0.1, name = 'fourteenth_layer'))\ncnn_model.add(Dense(units = classes, activation = 'softmax', name = 'Output_layer'))\ncnn_model.compile(optimizer = 'adam', loss = 'sparse_categorical_crossentropy', metrics = ['accuracy'])","53e83024":"fitted_model = cnn_model.fit(X_train, y_train, epochs = 25)","f403ae6b":"# plotting the accuracy for each epoch\naccuracy = fitted_model.history['acc']\nplt.plot(range(len(accuracy)), accuracy, 'o', label = 'accuracy')\nplt.title('Accuracy of the model for each epoch')\nplt.legend()","e75506a0":"evaluation = cnn_model.predict_classes(X_test)","6c091bfc":"print(classification_report(evaluation, y_test))","af4375bd":"testing_data = pd.read_csv('\/kaggle\/input\/digit-recognizer\/test.csv')","6aeac948":"testing_data.shape","eaa13ba2":"# doing the same preprocessing steps that we done in training data\ntesting_data = np.array(testing_data)\ntesting_data = testing_data.reshape(28000, 28, 28, 1)","261ebfe3":"predictions = cnn_model.predict_classes(testing_data)","a6e2ca6e":"submissions = pd.DataFrame({'ImageId':range(1, len(testing_data)+1), 'Label':predictions})","8512c0c7":"submissions.head()","9347cd9b":"submissions.to_csv('submissions.csv', index = False)","b8c1a0c1":"Thank you very much for viewing my kernel. Please upvote and comment if you have any creative ideas or any suggestions to improve the code.","aa132d76":"The main goal of this kernel is to use Convolutional Neural Network to recognize the MNIST Digits. If you are a beginner, I hope this kernel would be helpful in clear understanding. ","f20e4650":"Once the satisfied accuracy is obtained, we can import the testing data and submit them","55e7617f":"Note - Thumb rule is to check for missing values, visualizing the data then and there. The data in Kaggle is mostly clean so I am skipping that part. ","0436c733":"Having all the preparation done for neural network, its time to create a model. "}}