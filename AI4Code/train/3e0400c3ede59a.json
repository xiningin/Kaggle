{"cell_type":{"5f18f154":"code","ba9b1c59":"code","9a8eaad3":"code","f5a6dbbd":"code","34a8e466":"code","d54346d9":"code","e2bb0369":"code","e1f19a4a":"code","069c7afa":"code","218cdc8f":"code","fc1ceadc":"code","ff72ea2c":"code","09f436c1":"code","f4ba9332":"code","66a6ae0e":"code","8ae4ea09":"code","0432a50c":"code","d53211a1":"code","2a15c84e":"code","efe654c2":"code","c471d600":"code","d229b272":"code","39381b3b":"code","911b7986":"code","024cf436":"code","8a29206e":"code","8e75f17b":"code","e7a7c15a":"code","de4e77a5":"code","c685eddc":"code","da60a705":"code","634d32da":"code","18311278":"code","2b57a6f7":"code","b5ee26ca":"code","1b15a52a":"code","fc528036":"code","a7231c31":"code","131510fa":"code","4e511248":"code","22d5111e":"code","fb20942e":"code","bc046a66":"code","52e2de53":"code","68e019f2":"code","530a07b7":"code","d6160b21":"code","a0f0605f":"code","44e82544":"code","109fc772":"code","41007348":"code","b69539a2":"code","ae7e4b69":"code","582513a9":"code","8cecad50":"code","d4b299c7":"code","e09855a1":"code","605d1f56":"code","31cc433c":"code","c3d10fcc":"code","477d5f59":"code","570dfb44":"code","8d581cad":"code","9b0a5466":"code","a0efb997":"code","59fca6a4":"code","d0cb88b5":"code","e47d441d":"code","40d1cffb":"code","440d7e9b":"code","9b9d3e28":"code","b2f7e88d":"code","b4a74905":"code","19a8a6f8":"code","69a3179d":"code","99022df3":"code","945c5cc3":"code","0ad0f4e7":"code","e1cd32f6":"code","bbefb083":"code","708111a7":"code","b308ef18":"code","cc5ce57f":"code","9b344fa7":"code","8df9ba12":"code","c3046f67":"code","ecda4ae2":"code","56d8b47d":"code","0e2adf94":"code","02a11c23":"code","d9925ca6":"code","e50f019c":"code","1d374ac2":"code","8972e932":"code","0bdd693a":"code","40bdabd2":"code","e113fba8":"code","7a1072c2":"code","9f25547d":"code","491116dd":"code","ebbd26fd":"code","2c54057b":"code","0cc3ef32":"code","46ee62cf":"markdown","a3b22a76":"markdown","050abcb7":"markdown","870a136d":"markdown","967bb38d":"markdown","986774a6":"markdown","73ac0535":"markdown","4d16c5cb":"markdown","e0c09ae6":"markdown","1ccba2d2":"markdown","c0d00931":"markdown","487a49c5":"markdown","90188044":"markdown","d0806c43":"markdown","6a924b3d":"markdown","bf2f95d0":"markdown","987ee143":"markdown","6488ec08":"markdown","d3542e51":"markdown","40f89731":"markdown","a08df66a":"markdown","61b4ba46":"markdown","a7bbe5d9":"markdown","fa7083f8":"markdown","dcbbb56e":"markdown","a9eeff0d":"markdown","d62ffc9f":"markdown","f8c7868d":"markdown","19839edc":"markdown","9df81c43":"markdown","34e073bf":"markdown","8bde0dbd":"markdown","dba1884c":"markdown","6d9b4bb7":"markdown","e646c309":"markdown","69666dbd":"markdown","8ed86951":"markdown","b0a775c9":"markdown","2ef207bc":"markdown"},"source":{"5f18f154":"# para comenzar con este an\u00e1lisis, primero procederemos a cargar algunas librerias\/m\u00f3dulos necesarias para llevarlo\n# adelante\nimport pandas as pd\nimport numpy as np\nfrom scipy import stats\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom matplotlib.gridspec import GridSpec","ba9b1c59":"# realizamos la carga de datos\ndf_bk_mktg_in = pd.read_csv('..\/input\/bank-marketing-dataset\/bank.csv'\n                            , sep = \",\")","9a8eaad3":"# realizamos una r\u00e1pida visualizaci\u00f3n de los mismos\ndf_bk_mktg_in","f5a6dbbd":"# observamos el n\u00famero de filas (observaciones) y columnas (variables)\ndf_bk_mktg_in.shape","34a8e466":"# visualizamos los nombres de las variables del df\ndf_bk_mktg_in.columns","d54346d9":"# observamos los tipos de datos de cada de una de las variables\ndf_bk_mktg_in.dtypes","e2bb0369":"# visualizamos los tipos de variables y observamos que la mayor\u00eda son nominales\nbk_mktg_in_dtypes = df_bk_mktg_in.dtypes\ndf_bk_mktg_in_dtypes = bk_mktg_in_dtypes.to_frame()\ndf_bk_mktg_in_dtypes = df_bk_mktg_in_dtypes.rename(columns={df_bk_mktg_in_dtypes.columns[0]: 'Data Types'})\ndf_bk_mktg_in_dtypes.groupby(['Data Types']).size()","e1f19a4a":"# visualizamos la cantidad de valores nulos existentes en cada variable\ndf_bk_mktg_in.isnull().sum()","069c7afa":"# realizamos un \u00a8describe\u00a8 para obtener una visualizaci\u00f3n r\u00e1pida del comportamiento de las variables num\u00e9ricas\ndf_bk_mktg_in.describe().round(decimals=2)","218cdc8f":"# remplazamos -1 por 999 en la variable \"pdays\"\ndf_bk_mktg_in['pdays'] = df_bk_mktg_in['pdays'].replace({-1: 999})","fc1ceadc":"# visualizamos el resultado\ndf_bk_mktg_in['pdays']","ff72ea2c":"# observamos la cantidad de valores \u00fanicos que posee cada variable, utilizando un bucle \"for\"\nfor j in df_bk_mktg_in.columns:\n        print(j)\n        print(len(df_bk_mktg_in[j].unique()))","09f436c1":"# generamos subplots y definimos el n\u00famero de filas y columnas, y el tama\u00f1o de los gr\u00e1ficos\nf, ax = plt.subplots(1,2, figsize=(18,9))\n\n# definimos varibles para los colores, las etiquetas, y el orden para gr\u00e1ficar las categor\u00edas\ncolors = [\"#0095ff\", \"#f58e00\"]\nlabels = \"No\", \"Yes\"\nhue_order = ['no', 'yes']\n\n# determinamos los t\u00edtulos del gr\u00e1fico y el tama\u00f1o de letra\nplt.suptitle('An\u00e1lisis de \"deposit\"', family = 'Serif', size = 15,weight = 'bold')\nplt.figtext(0.5,0.93,'Gr\u00e1fico de tarta e Histograma para visualizar la distribuci\u00f3n dep\u00f3sitos', \n            family = 'Serif', size = 12, ha = 'center')\n\n \n# generamos un gr\u00e1fico de \"pie\" que ir\u00e1 ubicado en la primera fila, en la primera columna, junto con sus par\u00e1metros\ndf_bk_mktg_in[\"deposit\"].value_counts().plot.pie(explode=[0,0.25], autopct='%1.2f%%', ax=ax[0],shadow=True, \n                                                 colors=[\"#0095ff\", \"#f58e00\"], labels=labels, fontsize=12, \n                                                 startangle=25, labeldistance=1.03)\n\n# definimos la etiqueta del eje \"y\" del gr\u00e1fico de \"pie\", y el tama\u00f1o de letra\nax[0].set_ylabel('% de dep\u00f3sitos suscriptos', fontsize=14)\n\n# generamos un histograma que ir\u00e1 ubicado en la primera fila, en la segunda columna, junto con sus par\u00e1metros\nsns.histplot(data=df_bk_mktg_in, x=\"deposit\", hue=\"deposit\",multiple=\"layer\", binwidth=3,\n             stat=\"count\", palette=colors, ax=ax[1], hue_order=hue_order)\n\n# definimos las etiquetas del histograma, el tama\u00f1o de letra, y mostramos los gr\u00e1ficos\nax[1].set_ylabel('Cant. de dep\u00f3sitos suscriptos', fontsize=14)\nplt.show()","f4ba9332":"# ahora visulizamos los histogramas de las variables num\u00e9ricas, definiendo el estilo de los gr\u00e1ficos y los\n# diferentes par\u00e1metros\nplt.style.use('seaborn-whitegrid')\ndf_bk_mktg_in.hist(bins=20, figsize=(14,10), color=\"#f58e00\")\n# determinamos el t\u00edtulo del gr\u00e1fico y su formato\nplt.suptitle('Conjunto de histogramas de frecuencia de variables n\u00famericas', family = 'Serif', \n             size = 15,weight = 'bold')\nplt.show()","66a6ae0e":"# generamos una lista con los nombres de las columnas de las variables categ\u00f3ricas, para analizar la distribuci\u00f3n \n# de frecuencias de este tipo de variables\nlist_bk_mktg_cat = df_bk_mktg_in.select_dtypes(include=['object']).columns.tolist()","8ae4ea09":"# removemos el nombre de la columna \"deposit\" de la lista, ya que esta variable ya fue representada en solitario\n# en un gr\u00e1fico anterior\nlist_bk_mktg_cat.remove(\"deposit\")","0432a50c":"# observamos la lista\nlist_bk_mktg_cat","d53211a1":"# nos quedamos con los primeros 4 valores de la lista para tener una visualizaci\u00f3n m\u00e1s n\u00edtida\ncategorical_features = list_bk_mktg_cat[:4]\n\n# definimos \"subplots\" para representar varios gr\u00e1ficos a la vez, as\u00ed como el estilo de los mismos\nfig, ax = plt.subplots(1, len(categorical_features), figsize=(16,5))\nplt.style.use('seaborn-whitegrid')\n\n# mediante el uso de un bulce \"for\" y la funci\u00f3n \"enumerate\", generamos los gr\u00e1ficos correspondiente a cada\n# una de las variables categ\u00f3ricas seleccionadas, y visualizamos los gr\u00e1ficos \nfor i, categorical_feature in enumerate(df_bk_mktg_in[categorical_features]):\n    df_bk_mktg_in[categorical_feature].value_counts().plot(kind=\"bar\", ax=ax[i], color=\"#f58e00\").set_title(categorical_feature)\n    ax[i].set_xticklabels(df_bk_mktg_in[categorical_feature].unique(),rotation=315, ha=\"left\", rotation_mode=\"anchor\", size=13)\n# determinamos el t\u00edtulo del gr\u00e1fico y su formato\nplt.suptitle('Conjunto de histogramas de frecuencia de variables categ\u00f3ricas', family = 'Serif', size = 15,weight = 'bold')\nfig.show()","2a15c84e":"# nos quedamos con los restantes 5 valores de la lista de nombres de las columnas categ\u00f3ricas\ncategorical_features = list_bk_mktg_cat[4:]\n\n# definimos \"subplots\" para representar varios gr\u00e1ficos a la vez, as\u00ed como el estilo de los mismos\nfig, ax = plt.subplots(1, len(categorical_features), figsize=(18,5))\nplt.style.use('seaborn-whitegrid')\n\n# mediante el uso de un bulce \"for\" y la funci\u00f3n \"enumerate\", generamos los gr\u00e1ficos correspondiente a cada\n# una de las variables categ\u00f3ricas seleccionadas, y visualizamos los gr\u00e1ficos \nfor i, categorical_feature in enumerate(df_bk_mktg_in[categorical_features]):\n    df_bk_mktg_in[categorical_feature].value_counts().plot(kind=\"bar\", ax=ax[i], \n                                                           color=\"#f58e00\").set_title(categorical_feature)\n    ax[i].set_xticklabels(df_bk_mktg_in[categorical_feature].unique(),rotation=315, \n                          ha=\"left\", rotation_mode=\"anchor\", size=12.5)\nfig.show()","efe654c2":"# definimos unos gr\u00e1ficos de barras combinado con un gr\u00e1ficos de l\u00edneas, donde se puede observar la distribuci\u00f3n \n# de los dep\u00f3sitos (y \"no\" dep\u00f3sitos) por edad\nfig = plt.figure(figsize = (15,8), facecolor = (0.2,0.0,0.0,0.0), edgecolor = 'black')\n\n# generamos los t\u00edtulos para los gr\u00e1ficos\nplt.suptitle('Comparaci\u00f3n de \"dep\u00f3sit\" por \"age\"', family = 'Serif', size = 15,weight = 'bold')\nplt.figtext(0.5,0.93,'Histograma para visualizar la distribuci\u00f3n depositos por edad', \n            family = 'Serif', size = 12, ha = 'center')\n\n# definimos el n\u00famero de filas y de columnas que tendr\u00e1 el \"grid\" de los gr\u00e1ficos\ngs = GridSpec(nrows = 2, ncols = 4, figure = fig)\n\n# determinamos el espacio en el \"grid\" que ocupar\u00e1 el primer gr\u00e1fico\nax1 = plt.subplot(gs[0,:3])\n\n# generamos un histograma con sus repectivos par\u00e1metros, teniendo en cuenta la totalidad de las observaciones,\n# y agrupando las mismas en funci\u00f3n de la variable \"deposit\"\nsns.histplot(data = df_bk_mktg_in, x = 'age', bins=10, ax = ax1, kde = True, hue = 'deposit', multiple = 'layer',\n             element = 'bars', palette = colors, hue_order=hue_order)\n\n# determinamos el espacio en el \"grid\" que ocupar\u00e1 el segundo gr\u00e1fico\nax2 = plt.subplot(gs[0,3:4], sharey = ax1)\n\n# generamos otro histograma con sus repectivos par\u00e1metros, teniendo en cuenta s\u00f3lo las observaciones\n# correspondientes a personas que hayan suscripto un dep\u00f3sito a plazo fijo (\"yes\")\nsns.histplot(data = df_bk_mktg_in[df_bk_mktg_in['deposit'] == 'yes'], x = 'age', bins = 10, ax = ax2,\n             kde = True, color = \"#f58e00\")\n\n# quitamos las etiquetas del segundo histograma, ya que las mismas se encuentran en el eje de las \"y\"\n# del primer histograma, y la escala es la misma para ambos gr\u00e1ficos\nax2.yaxis.set_visible(False)","c471d600":"# definimos unos gr\u00e1ficos de boxplot, donde se puede observar la distribuci\u00f3n de los dep\u00f3sitos (y \"no\" dep\u00f3sitos)\n# por edad, pudiendo visualizar distitos valores estad\u00edsticos como la media, la mediana, y la moda\nfig = plt.figure(figsize = (15,8), facecolor = (0.2,0.0,0.0,0.0), edgecolor = 'black')\n\n# generamos los t\u00edtulos para los gr\u00e1ficos\nplt.suptitle('Comparaci\u00f3n de \"dep\u00f3sit\" por \"age\"', family = 'Serif', size = 15, weight = 'bold')\nplt.figtext(0.5,0.93,'Boxplot para visualizar la distribuci\u00f3n de dep\u00f3sitos por edad', \n            family = 'Serif', size = 12, ha = 'center')\n\n# definimos el n\u00famero de filas y de columnas que tendr\u00e1 el \"grid\" de los gr\u00e1ficos\ngs = GridSpec(nrows = 2, ncols = 4, figure = fig)\n\n# determinamos el espacio en el \"grid\" que ocupar\u00e1 el primer gr\u00e1fico\nax1 = plt.subplot(gs[0,:4])\n\n# generamos otro histograma con sus repectivos par\u00e1metros, teniendo en cuenta s\u00f3lo las observaciones\n# correspondientes a personas que hayan no hayan suscripto un dep\u00f3sito a plazo fijo (\"no\")\nsns.boxplot(data = df_bk_mktg_in[df_bk_mktg_in['deposit'] == 'no'], x = 'age', ax = ax1, palette = [\"#0095ff\"])\n\n# a\u00f1adimos el c\u00e1lculo de la media, la mediana, la moda en el gr\u00e1fico, para personas que no hayan suscripto\n# el dep\u00f3sito (\"no\")\nax1.text(60,0.15,\"Media: {:.2f}\".format(df_bk_mktg_in[df_bk_mktg_in['deposit'] == 'no']['age'].mean()))\nax1.text(60,0.20,\"Mediana: {:.2f}\".format(df_bk_mktg_in[df_bk_mktg_in['deposit'] == 'no']['age'].median()))\nax1.text(60,0.25,\"Moda: {:.2f}\".format(df_bk_mktg_in[df_bk_mktg_in['deposit'] == 'no']['age'].mode().max()))\n\n# generamos el t\u00edtulo para el primer gr\u00e1fico\nax1.set_title(\"no\", family = 'Serif', size = 11, weight = 'bold')\n\n# dejamos el t\u00edtulo del eje de las \"x\" vac\u00edo, ya que el mismo se encuentran en el eje de las \"x\"\n# del segundo boxplot, y la escala es la misma para ambos gr\u00e1ficos \nax1.set_xlabel(\"\")\n\n# determinamos el espacio en el \"grid\" que ocupar\u00e1 el segundo gr\u00e1fico\nax2 = plt.subplot(gs[1,:4])\n\n# generamos otro histograma con sus repectivos par\u00e1metros, teniendo en cuenta s\u00f3lo las observaciones\n# correspondientes a personas que hayan hayan suscripto un dep\u00f3sito a plazo fijo (\"yes\")\nsns.boxplot(data = df_bk_mktg_in[df_bk_mktg_in['deposit'] == 'yes'], x = 'age', ax = ax2, palette = [\"#f58e00\"])\n\n# a\u00f1adimos el c\u00e1lculo de la media, la mediana, la moda en el gr\u00e1fico, para personas que hayan suscripto\n# el dep\u00f3sito (\"yes\")\nax2.text(60,0.15,\"Media: {:.2f}\".format(df_bk_mktg_in[df_bk_mktg_in['deposit'] == 'yes']['age'].mean()))\nax2.text(60,0.20,\"Mediana: {:.2f}\".format(df_bk_mktg_in[df_bk_mktg_in['deposit'] == 'yes']['age'].median()))\nax2.text(60,0.25,\"Moda: {:.2f}\".format(df_bk_mktg_in[df_bk_mktg_in['deposit'] == 'yes']['age'].mode().max()))\n\n# generamos el t\u00edtulo para el segundo gr\u00e1fico\nax2.set_title(\"yes\", family = 'Serif', size = 11, weight = 'bold')","d229b272":"# definimos unos gr\u00e1ficos de barras combinado con un gr\u00e1ficos de l\u00edneas, donde se puede observar la distribuci\u00f3n \n# de los dep\u00f3sitos (y \"no\" dep\u00f3sitos) por la duraci\u00f3n del ultimo contacto (\"duration\")\nfig = plt.figure(figsize = (15,8), facecolor = (0.2,0.0,0.0,0.0), edgecolor = 'black')\n\n# generamos los t\u00edtulos para los gr\u00e1ficos\nplt.suptitle('Comparaci\u00f3n de \"dep\u00f3sit\" por \"duration\"', family = 'Serif', size = 15,\n             weight = 'bold')\nplt.figtext(0.5,0.93, \"Histograma para visualizar la distribuci\u00f3n de depositos \\\npor la duraci\u00f3n del \u00faltimo contacto\", family = 'Serif', size = 12, ha = 'center')\n\n# definimos el n\u00famero de filas y de columnas que tendr\u00e1 el \"grid\" de los gr\u00e1ficos\ngs = GridSpec(nrows = 2, ncols = 4, figure = fig)\n\n# determinamos el espacio en el \"grid\" que ocupar\u00e1 el primer gr\u00e1fico\nax1 = plt.subplot(gs[0,:3])\n\n# generamos un histograma con sus repectivos par\u00e1metros, teniendo en cuenta la totalidad de las observaciones,\n# y agrupando las mismas en funci\u00f3n de la variable \"deposit\"\nsns.histplot(data = df_bk_mktg_in, x = 'duration', bins = 10, ax = ax1, kde = True, hue = 'deposit',\n             multiple = 'layer', element = 'bars', binwidth = 100, palette = colors, hue_order=hue_order)\n\n# determinamos el espacio en el \"grid\" que ocupar\u00e1 el segundo gr\u00e1fico\nax2 = plt.subplot(gs[0,3:4], sharey = ax1)\n\n# generamos otro histograma con sus repectivos par\u00e1metros, teniendo en cuenta s\u00f3lo las observaciones\n# correspondientes a personas que hayan suscripto un dep\u00f3sito a plazo fijo (\"yes\")\nsns.histplot(data = df_bk_mktg_in[df_bk_mktg_in['deposit'] == 'yes'], x = 'duration', bins = 10, ax = ax2,\n             kde = True, binwidth = 100, color = \"#f58e00\")\n\n# quitamos las etiquetas del segundo histograma, ya que las mismas se encuentran en el eje de las \"y\"\n# del primer histograma, y la escala es la misma para ambos gr\u00e1ficos\nax2.yaxis.set_visible(False)","39381b3b":"# definimos unos gr\u00e1ficos de barras combinado con un gr\u00e1ficos de l\u00edneas, donde se puede observar la distribuci\u00f3n \n# de los dep\u00f3sitos (y \"no\" dep\u00f3sitos), por la cantidad de d\u00edas que han pasado desde que el cliente fue contactado\n# por una campa\u00f1a anterior\nfig = plt.figure(figsize = (15,8), facecolor=(0.2,0.0,0.0,0.0), edgecolor = 'black')\n\n# generamos los t\u00edtulos para los gr\u00e1ficos\nplt.suptitle('Comparaci\u00f3n de \"deposit\" por \"pdays\"', family = 'Serif', size = 15, weight = 'bold')\nplt.figtext(0.5,0.93, \"Histograma para visualizar la distribuci\u00f3n de dep\u00f3sitos \\\npor la cantidad de d\u00edas que han pasado desde que el cliente fue contactado\", \n            family = 'Serif', size = 12, ha = 'center')\n\n# definimos el n\u00famero de filas y de columnas que tendr\u00e1 el \"grid\" de los gr\u00e1ficos\ngs = GridSpec(nrows = 2, ncols = 4, figure = fig)\n\n# determinamos el espacio en el \"grid\" que ocupar\u00e1 el primer gr\u00e1fico\nax1 = plt.subplot(gs[0,:3])\n\n# generamos un histograma con sus repectivos par\u00e1metros, teniendo en cuenta la totalidad de las observaciones,\n# y agrupando las mismas en funci\u00f3n de la variable \"deposit\"\nsns.histplot(data = df_bk_mktg_in, x = 'pdays', bins = 10, ax = ax1, kde = True, hue = 'deposit', \n             multiple = 'layer', element = 'bars', binwidth = 10, palette = colors, hue_order=hue_order)\n\n# determinamos el espacio en el \"grid\" que ocupar\u00e1 el segundo gr\u00e1fico\nax2 = plt.subplot(gs[0,3:4], sharey = ax1)\n\n# generamos otro histograma con sus repectivos par\u00e1metros, teniendo en cuenta s\u00f3lo las observaciones\n# correspondientes a personas que hayan suscripto un dep\u00f3sito a plazo fijo (\"yes\")\nsns.histplot(data = df_bk_mktg_in[df_bk_mktg_in['deposit'] == 'yes'], x = 'pdays', bins = 10, ax = ax2, kde = True,\n             binwidth = 10, color = \"#f58e00\")\n\n# quitamos las etiquetas del segundo histograma, ya que las mismas se encuentran en el eje de las \"y\"\n# del primer histograma, y la escala es la misma para ambos gr\u00e1ficos\nax2.yaxis.set_visible(False)","911b7986":"# generamos unos gr\u00e1ficos de viol\u00edn, donde se puede observar la distribuci\u00f3n de los dep\u00f3sitos (y \"no\" dep\u00f3sitos), \n# por mes y por d\u00eda\nfig = plt.figure(figsize = (16,8))\n\n# generamos los t\u00edtulos para el conjunto de gr\u00e1ficos\nplt.suptitle('Comparaci\u00f3n de \"deposit\" por \"month\" y \"day\"', family = 'Serif', size = 15, weight = 'bold')\nplt.figtext(0.5,0.93, \"Gr\u00e1ficos de viol\u00edn para visualizar la distribuci\u00f3n de dep\u00f3sitos \\\npor mes y por d\u00eda\", family = 'Serif', size = 12, ha = 'center')\n\n# definimos el gr\u00e1fico con sus respectivos par\u00e1metros\nax = sns.violinplot(data = df_bk_mktg_in, x = \"day\", y = \"month\", hue = \"deposit\", palette = [\"#f58e00\", \"#0095ff\"],\n                    split=True)\n\n# determinamos que el eje de las \"x\" vaya de 1 a 31 d\u00edas\nax.set_xlim(1, 31)","024cf436":"# generamos unos gr\u00e1ficos de barras, donde se puede observar la distribuci\u00f3n de los dep\u00f3sitos (y \"no\" dep\u00f3sitos), \n# por d\u00eda y en funci\u00f3n de la cantidad de contactos realizados a cada individuo\nfig=plt.figure(figsize=(18,9))\n# determinamos el t\u00edtulo del conjunto de gr\u00e1ficos\nplt.suptitle('An\u00e1lisis de \"deposit\" por \"day\" y \"campaign\"', family='Serif', size=15,\n             ha='center', weight='bold')\nplt.figtext(0.5,0.93,\"Gr\u00e1ficos de barras que muestran la distribuci\u00f3n de dep\u00f3sitos \\\npor d\u00eda del mes y n\u00famero de veces que se contacto al individuo\", family='Serif', size=12, ha='center')\n# establecemos el formato del \"grid\" (3 filas y 1 columna) y el tama\u00f1o de las alturas\ngs = GridSpec(nrows=3, ncols=1, height_ratios=[2,2,5])\n\n# determinamos la ubicaci\u00f3n del primer gr\u00e1fico\nax1=plt.subplot(gs[0,0])\n# generamos unos gr\u00e1ficos de barras, donde se puede observar la distribuci\u00f3n de los dep\u00f3sitos por d\u00eda \nax1=sns.countplot(data=df_bk_mktg_in,x='day',hue='deposit', palette=colors, hue_order=hue_order)\n# definimos la distancia de la leyenda del eje \"x\" y el texto del eje \"y\" \nax1.xaxis.labelpad = -1\nax1.set_ylabel(\"Cant. de individuos\")\n\n# determinamos la ubicaci\u00f3n del segundo gr\u00e1fico\nax2=plt.subplot(gs[1,0])\n# generamos unos gr\u00e1ficos de barras apiladas (\"multiple = 'fill'\"), donde se puede observar la distribuci\u00f3n\n# de los dep\u00f3sitos por d\u00eda \nax2=sns.histplot(data=df_bk_mktg_in,x='day',hue='deposit', multiple = \"fill\", palette=colors, binwidth=1, \n                 hue_order=hue_order)\n# definimos la distancia de la leyenda del eje \"x\" y el texto del eje \"y\" \nax2.xaxis.labelpad = -5\nax2.set_ylabel(\"Cant. de individuos\")\n\n# determinamos la ubicaci\u00f3n del tercer gr\u00e1fico\nax3=plt.subplot(gs[2,0])\n# generamos unos gr\u00e1ficos de barras, donde se puede observar la distribuci\u00f3n de los dep\u00f3sitos\n# en funci\u00f3n de la cantidad de contactos realizados a cada individuo\nax3=sns.countplot(data=df_bk_mktg_in,x='campaign',hue='deposit', palette=colors, hue_order=hue_order)\n# definimos el texto del eje \"y\" \nax3.set_ylabel(\"Cant. de individuos\")","8a29206e":"# ahora vamos a generar un conjunto gr\u00e1ficos de barras, donde se puede observar la distribuci\u00f3n de los dep\u00f3sitos \n# (y \"no\" dep\u00f3sitos), teniendo en cuenta las diferentes ocupaciones (\"job\") de las personas;\n# el conjunto posee 1 fila y 3 columnas donde ir\u00e1n ubicados cada uno de los gr\u00e1ficos\nf, ax = plt.subplots(1,3, figsize=(16,8))\n\n# generamos los t\u00edtulos para el conjunto de gr\u00e1ficos\nplt.suptitle('An\u00e1lisis de \"deposit\" por \"job\"', family = 'Serif', size = 15, weight = 'bold')\nplt.figtext(0.5,0.93, \"Histogramas para visualizar la distribuci\u00f3n de dep\u00f3sitos \\\npor ocupaci\u00f3n\", family = 'Serif', size = 12, ha = 'center')\n\n# generamos un histograma donde se muestra las cantidades de observaciones existentes para cada \n# una de las ocupaciones; para ello utilizamos el par\u00e1metro \"stat = 'count'\", para que sea representada la \n# frecuencia con la que aparecen las ocupaciones en el dataset\nsns.histplot(data=df_bk_mktg_in, x=\"job\", multiple=\"layer\", binwidth=3, stat=\"count\", palette=colors, ax=ax[0])\n\n# definimos el t\u00edtulo del eje de las \"y\"\nax[0].set_ylabel('Cant. de observaciones', fontsize=14)\n\n# determinamos los par\u00e1metros de las etiquetas del eje \"x\"; rotamos las mismas para que no se superpongan\nax[0].set_xticklabels(df_bk_mktg_in[\"job\"].unique(),rotation=315, ha=\"left\", rotation_mode=\"anchor\", size=13)\n\n# generamos un histograma donde se muestra las cantidades de observaciones existentes para cada \n# una de las ocupaciones, pero en este caso agrupando las observaciones en funci\u00f3n de las categor\u00edas de la variable\n# objetivo \"deposit\" (\"hue = 'deposit'\"); para ello utilizamos el par\u00e1metro \"stat = 'count'\", para que \n# sea representada la frecuencia con la que aparecen las ocupaciones en cada categor\u00eda\nsns.histplot(data=df_bk_mktg_in, x=\"job\", hue=\"deposit\",multiple=\"layer\", binwidth=3, stat=\"count\", \n             palette=colors, ax=ax[1], hue_order=hue_order)\n\n# definimos el t\u00edtulo del eje de las \"y\"\nax[1].set_ylabel('Cant. de dep\u00f3sitos suscriptos y no suscriptos', fontsize=14)\n\n# determinamos los par\u00e1metros de las etiquetas del eje \"x\"; rotamos las mismas para que no se superpongan\nax[1].set_xticklabels(df_bk_mktg_in[\"job\"].unique(),rotation=315, ha=\"left\", rotation_mode=\"anchor\", size=13)\n\n# generamos un histograma donde se muestra las proporciones de observaciones existentes para cada \n# una de las ocupaciones, agrupando las observaciones en funci\u00f3n de las categor\u00edas de la variable\n# objetivo \"deposit\" (\"hue = 'deposit'\"); para ello utilizamos los par\u00e1metros \"stat = 'count'\", \n# y \"multiple= 'fill'\" para que se muestre las barras de un modo apilado \nsns.histplot(data=df_bk_mktg_in, x=\"job\", hue=\"deposit\",multiple=\"fill\", binwidth=3, stat=\"count\", palette=colors, \n             ax=ax[2], hue_order=hue_order)\n\n# definimos el t\u00edtulo del eje de las \"y\"\nax[2].set_ylabel('Porcentaje de dep\u00f3sitos suscriptos y no suscriptos', fontsize=14)\n\n# determinamos los par\u00e1metros de las etiquetas del eje \"x\"; rotamos las mismas para que no se superpongan y\n# mostramos los gr\u00e1ficos\nax[2].set_xticklabels(df_bk_mktg_in[\"job\"].unique(),rotation=315, ha=\"left\", rotation_mode=\"anchor\", size=13)\nplt.show()","8e75f17b":"# generamos gr\u00e1ficos de dona (\"donat\") para visualizar la distribuci\u00f3n de los dep\u00f3sitos por nivel educativo\nfig = plt.figure(figsize=(14,8))\n# definimos la forma que tendr\u00e1 el \"grid\" del conjunto de gr\u00e1ficos (1 fila y 2 columnas) y el tama\u00f1o de los \n# gr\u00e1ficos\ngs = GridSpec(nrows=1, ncols=2, width_ratios=[5,2.5])\n# generamos los t\u00edtulos para el conjunto de gr\u00e1ficos\nplt.suptitle('An\u00e1lisis de \"deposit\" por \"education\"', family='Serif', size=15, ha='center', weight='bold')\nplt.figtext(0.5,0.93, \"Gr\u00e1ficos de dona para visualizar los dep\u00f3sitos teniendo en cuenta el nivel educativo\",\n            family='Serif', size=12, ha='center')\n\n# definimos el lugar en el \"grid\" que ocupar\u00e1 el primer gr\u00e1fico\nax1=plt.subplot(gs[0,0])\n# generamos un gr\u00e1fico de dona, donde se representar\u00e1 la distribuci\u00f3n de porcentajes de cada nivel educativo,\n# dentro de aquellas personas que hayan adquirido un deposito\nax1=plt.pie(df_bk_mktg_in[df_bk_mktg_in['deposit']=='yes']['education'].value_counts(), \n            labels=df_bk_mktg_in[df_bk_mktg_in['deposit']=='yes']['education'].unique(), \n            autopct='%2d%%', textprops={\"fontsize\":15}, pctdistance=0.85,\n            colors=[\"#4a98ff\", \"#f58e00\", \"#f7e382\", \"#85b96f\"])\n# definimos el t\u00edtulo del gr\u00e1fico y el tama\u00f1o de fuente\nax1=plt.title(\"yes\", family='Serif', size=11,weight='bold')\nax1.set_fontsize(15)\n# dibujamos el c\u00edrculo que ir\u00e1 dentro de la dona\ncentre_circle = plt.Circle((0, 0), 0.70, fc='white')\nfig = plt.gcf()\n# a\u00f1adimos al c\u00edrulo al gr\u00e1fico\nfig.gca().add_artist(centre_circle)\n\n# definimos el lugar en el \"grid\" que ocupar\u00e1 el primer gr\u00e1fico\nax2=plt.subplot(gs[0,1])\n# generamos un gr\u00e1fico de dona, donde se representar\u00e1 la distribuci\u00f3n de porcentajes de cada nivel educativo,\n# dentro de aquellas personas que no hayan adquirido un deposito\nax2=plt.pie(df_bk_mktg_in[df_bk_mktg_in['deposit']=='no']['education'].value_counts(),\n            labels=df_bk_mktg_in[df_bk_mktg_in['deposit']=='no']['education'].unique(),\n            autopct='%2d%%', textprops={\"fontsize\":15}, pctdistance=0.85,\n            colors=[\"#f7e382\", \"#4a98ff\", \"#f58e00\", \"#85b96f\"])\n# definimos el t\u00edtulo del gr\u00e1fico y el tama\u00f1o de fuente\nax2=plt.title(\"no\", family='Serif', size=11,weight='bold')\nax2.set_fontsize(15)\n# dibujamos el c\u00edrculo que ir\u00e1 dentro de la dona\ncentre_circle = plt.Circle((0, 0), 0.70, fc='white')\nfig = plt.gcf()\n# a\u00f1adimos al c\u00edrulo al gr\u00e1fico\nfig.gca().add_artist(centre_circle)","e7a7c15a":"# generamos distintos box plots para visualizar la distribuci\u00f3n de los dep\u00f3sitos por nivel de educaci\u00f3n y edad \nfig = plt.figure(figsize=(12,8))\n# definimos la forma que tendr\u00e1 el \"grid\" del conjunto de gr\u00e1ficos (2 filas y 4 columnas)\ngs = GridSpec(ncols=4, nrows=2, figure=fig)\n# generamos los t\u00edtulos para el conjunto de gr\u00e1ficos\nplt.suptitle('An\u00e1lisis de \"deposit\" por \"education\" y \"age\"', family = 'Serif', size = 15, weight = 'bold')\nplt.figtext(0.5,0.93, \"Box plots para visualizar la distribuci\u00f3n de dep\u00f3sitos \\\npor nivel educativo y edad\", family = 'Serif', size = 12, ha = 'center')\n\n# generamos un conjunto de box plots mediante el uso de un bucle \"for\" y \"enumerate\", los cuales ir\u00e1n ubicados \n# en la primera fila del \"grid\", y que presentar\u00e1n la distribuci\u00f3n de los dep\u00f3sitos por estado civil y edad \n# inicializamos una variable a \"0\", que variar\u00e1 en 1 unidad con cada iteraci\u00f3n del bucle, y servir\u00e1 para determinar\n# el t\u00edtulo de cada gr\u00e1fico\ncount = 0\nfor i,c in enumerate(df_bk_mktg_in['education'].unique()):\n    # definimos el lugar en el \"grid\" que ocupar\u00e1 cada gr\u00e1fico\n    ax=plt.subplot(gs[0,i])\n    # generamos los box plots con cada iteraci\u00f3n del bucle\n    ax=sns.boxplot(y=df_bk_mktg_in[df_bk_mktg_in['education']==c]['age'], x=df_bk_mktg_in['deposit'],\n                   palette=[\"#f58e00\", \"#0095ff\"])\n    # quitamos los recuadros que envuelven a cada gr\u00e1fico, configurando los par\u00e1metros de \"spines\" a \"False\"\n    ax.spines['left'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.spines['bottom'].set_visible(False)\n    # definimos los t\u00edtulos\n    ax.set_title(df_bk_mktg_in['education'].unique()[count], family='Serif', size=11,weight='bold')\n    # a\u00f1adimos 1 unidad a la variable \"count\"\n    count += 1\n\n# generamos un segundo box plot que ocupara la segunda fila del \"grid\" en su totalidad\nax=plt.subplot(gs[1,:])\n# generamos un conjunto de box plots, los cuales presentar\u00e1n la distribuci\u00f3n de los dep\u00f3sitos por nivel educativo\n# y edad, teniendo en cuenta s\u00f3lo aquellas observaciones donde se haya suscripto un dep\u00f3sito\nax=sns.boxplot(data=df_bk_mktg_in[df_bk_mktg_in['deposit']=='yes'],y='education',x='age',\n               palette=[\"#ffb042\",\"#ffd08f\",\"#f58e00\", \"#f56200\"])\n# quitamos el recuadro que envuelve al conjunto de gr\u00e1ficos, configurando los par\u00e1metros de \"spines\" a \"False\"\nax.spines['left'].set_visible(False)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.spines['bottom'].set_visible(False)\n# definimos el t\u00edtulo del gr\u00e1fico\nax.set_title(\"yes\", family='Serif', size=11,weight='bold')","de4e77a5":"# generamos distintos box plots para visualizar la distribuci\u00f3n de los dep\u00f3sitos por estado civil y edad\nfig = plt.figure(figsize = (12,8))\n# definimos la forma que tendr\u00e1 el \"grid\" del conjunto de gr\u00e1ficos (2 filas y 3 columnas)\ngs = GridSpec(ncols = 3, nrows = 2, figure = fig)\n# generamos los t\u00edtulos para el conjunto de gr\u00e1ficos\nplt.suptitle('An\u00e1lisis de \"deposit\" por \"marital\" y \"age\"', family = 'Serif', size = 15, weight = 'bold')\nplt.figtext(0.5,0.93, \"Box plots para visualizar la distribuci\u00f3n de dep\u00f3sitos \\\npor estado civil y edad\", family = 'Serif', size = 12, ha = 'center')\n\n# generamos un conjunto de box plots mediante el uso de un bucle \"for\" y \"enumerate\", los cuales ir\u00e1n ubicados \n# en la primera fila del \"grid\", y que presentar\u00e1n la distribuci\u00f3n de los dep\u00f3sitos por estado civil y edad \n# inicializamos una variable a \"0\", que variar\u00e1 en 1 unidad con cada iteraci\u00f3n del bucle, y servir\u00e1 para determinar\n# el t\u00edtulo de cada gr\u00e1fico\ncount = 0\nfor i,c in enumerate(df_bk_mktg_in['marital'].unique()):\n    # definimos el lugar en el \"grid\" que ocupar\u00e1 cada gr\u00e1fico\n    ax=plt.subplot(gs[0,i])\n    # generamos los box plots con cada iteraci\u00f3n del bucle\n    ax=sns.boxplot(y=df_bk_mktg_in[df_bk_mktg_in['marital']==c]['age'], x=df_bk_mktg_in['deposit'],\n                   palette=[\"#f58e00\", \"#0095ff\"])\n    # quitamos los recuadros que envuelven a cada gr\u00e1fico, configurando los par\u00e1metros de \"spines\" a \"False\"\n    ax.spines['left'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.spines['bottom'].set_visible(False)\n    # definimos los t\u00edtulos\n    ax.set_title(df_bk_mktg_in['marital'].unique()[count], family='Serif', size=11,weight='bold')\n    # modificamos la ubicaci\u00f3n de la etiqueta del eje de las \"x\" para que no se superponga con el t\u00edtulo del \n    # gr\u00e1fico que esta debajo\n    ax.xaxis.labelpad = -5\n    # a\u00f1adimos 1 unidad a la variable \"count\"\n    count += 1\n\n# generamos un segundo box plot que ocupar\u00e1 la segunda fila del \"grid\" en su totalidad\nax=plt.subplot(gs[1,:])\n# generamos un conjunto de box plots, los cuales presentar\u00e1n la distribuci\u00f3n de los dep\u00f3sitos por estado civil y \n# edad, teniendo en cuenta s\u00f3lo aquellas observaciones donde se haya suscripto un dep\u00f3sito\nax=sns.boxplot(data=df_bk_mktg_in[df_bk_mktg_in['deposit']=='yes'],y='marital',x='age',\n               palette=[\"#ffb042\",\"#ffd08f\",\"#f58e00\"])\n# quitamos el recuadro que envuelve al conjunto de gr\u00e1ficos, configurando los par\u00e1metros de \"spines\" a \"False\"\nax.spines['left'].set_visible(False)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.spines['bottom'].set_visible(False)\n# definimos el t\u00edtulo\nax.set_title(\"yes\", family='Serif', size=11,weight='bold')","c685eddc":"# generamos un gr\u00e1fico de barras para visualizar el valor peromedio del balance por dep\u00f3sito y estado civil\nfig, ax = plt.subplots(1, figsize=(14, 7))\n# definimos los t\u00edtulos para el gr\u00e1fico\nplt.suptitle('An\u00e1lisis de \"balance\" por \"marital\" y \"deposit\"', family = 'Serif', size = 15, weight = 'bold')\nplt.figtext(0.5,0.93, \"Gr\u00e1fico de barras para visualizar el balance promedio \\\npor estado civil y dep\u00f3sito\", family = 'Serif', size = 12, ha = 'center')\n# originamos el gr\u00e1fico descripto m\u00e1s arriba \nsns.barplot(x=\"balance\", y=\"marital\", hue= \"deposit\",data=df_bk_mktg_in, palette=colors, ci=False,\n            hue_order=hue_order)\n# definimos el tama\u00f1o de los valores y categor\u00edas en los ejes y de las etiquetas, y mostramos el gr\u00e1fico\nplt.xlabel(\"balance\",size= 20)\nplt.xticks(size= 16)\nplt.ylabel(\"marital\",size= 20)\nplt.yticks(size= 16)\nplt.show()","da60a705":"# generamos unos gr\u00e1ficos de torta (\"pie\") para visualizar la distribuci\u00f3n de los dep\u00f3sitos en funci\u00f3n\n# del resultado de campa\u00f1a anterior, y del tipo de medio de comunicaci\u00f3n donde la persona fue contactada (tel\u00e9fono\n# o celular)\nfig = plt.figure(figsize=(16,8))\n# definimos la forma que tendr\u00e1 el \"grid\" del conjunto de gr\u00e1ficos (2 filas y 2 columnas)\ngs = GridSpec(nrows=2, ncols=2)\n# generamos los t\u00edtulos para el conjunto de gr\u00e1ficos\nplt.suptitle('An\u00e1lisis de \"deposit\" por \"poutcome\" y \"contact\"', family='Serif', size=15, ha='center',\n             weight='bold')\nplt.figtext(0.5,0.93, \"Gr\u00e1ficos de torta para visualizar la distribuci\u00f3n de dep\u00f3sitos \\\npor el resultado de la comapa\u00f1a anterior y el medio donde se contact\u00f3 al individuo\", family = 'Serif',\n            size = 12, ha = 'center')\n\n# definimos el lugar en el \"grid\" que ocupar\u00e1 el primer gr\u00e1fico\nax1=plt.subplot(gs[0,0])\n# generamos un gr\u00e1fico de torta (\"pie\") para visualizar la distribuci\u00f3n de los dep\u00f3sitos en funci\u00f3n\n# del resultado de la campa\u00f1a anterior, teniendo en cuenta el conjunto de personas que suscribieron un dep\u00f3sito\nax1=plt.pie(df_bk_mktg_in[df_bk_mktg_in['deposit']=='yes']['poutcome'].value_counts(),\n            labels=df_bk_mktg_in[df_bk_mktg_in['deposit']=='yes']['poutcome'].unique(),\n            autopct='%2d%%', textprops={\"fontsize\":15}, pctdistance=0.85,\n            colors=[\"#4a98ff\", \"#f58e00\", \"#f7e382\", \"#85b96f\"])\n# determinamos el t\u00edtulo del gr\u00e1fico \nax1=plt.title(\"poutcome - yes\", family='Serif', size=11,weight='bold')\n# establecemos el valor del tama\u00f1o de la fuente del gr\u00e1fico\nax1.set_fontsize(15)\n\n# definimos el lugar en el \"grid\" que ocupar\u00e1 el segundo gr\u00e1fico\nax2=plt.subplot(gs[0,1])\n# generamos un gr\u00e1fico de torta (\"pie\") para visualizar la distribuci\u00f3n de los dep\u00f3sitos en funci\u00f3n\n# del resultado de la campa\u00f1a anterior, teniendo en cuenta el conjunto de personas que no suscribieron un dep\u00f3sito\nax2=plt.pie(df_bk_mktg_in[df_bk_mktg_in['deposit']=='no']['poutcome'].value_counts(),\n            labels=df_bk_mktg_in[df_bk_mktg_in['deposit']=='no']['poutcome'].unique(),\n            autopct='%2d%%', textprops={\"fontsize\":15}, pctdistance=0.85,\n            colors=[\"#4a98ff\", \"#85b96f\", \"#f7e382\", \"#f58e00\"])\n# determinamos el t\u00edtulo del gr\u00e1fico \nax2=plt.title(\"poutcome - no\", family='Serif', size=11,weight='bold')\n# establecemos el valor del tama\u00f1o de la fuente del gr\u00e1fico\nax2.set_fontsize(15)\n\n# definimos el lugar en el \"grid\" que ocupar\u00e1 el tercer gr\u00e1fico\nax1=plt.subplot(gs[1,0])\n# generamos un gr\u00e1fico de torta (\"pie\") para visualizar la distribuci\u00f3n de los dep\u00f3sitos en funci\u00f3n\n# del medio de comunicaci\u00f3n donde fue contactada la persona, teniendo en cuenta el conjunto de individuos \n# que suscribieron un dep\u00f3sito\nax1=plt.pie(df_bk_mktg_in[df_bk_mktg_in['deposit']=='yes']['contact'].value_counts(),\n            labels=df_bk_mktg_in[df_bk_mktg_in['deposit']=='yes']['contact'].unique(),\n            autopct='%2d%%', textprops={\"fontsize\":15},\n            pctdistance=0.85, colors=[\"#4a98ff\", \"#f58e00\", \"#f7e382\"])\n# determinamos el t\u00edtulo del gr\u00e1fico\nax1=plt.title(\"contact - yes\", family='Serif', size=11,weight='bold')\n# establecemos el valor del tama\u00f1o de la fuente del gr\u00e1fico\nax1.set_fontsize(15)\n\n# definimos el lugar en el \"grid\" que ocupar\u00e1 el cuarto gr\u00e1fico\nax2=plt.subplot(gs[1,1])\n# generamos un gr\u00e1fico de torta (\"pie\") para visualizar la distribuci\u00f3n de los dep\u00f3sitos en funci\u00f3n\n# del medio de comunicaci\u00f3n donde fue contactada la persona, teniendo en cuenta el conjunto de individuos \n# que no suscribieron un dep\u00f3sito\nax2=plt.pie(df_bk_mktg_in[df_bk_mktg_in['deposit']=='no']['contact'].value_counts(),\n            labels=df_bk_mktg_in[df_bk_mktg_in['deposit']=='no']['contact'].unique(),\n            autopct='%2d%%', textprops={\"fontsize\":15}, pctdistance=0.85,\n            colors=[\"#f58e00\", \"#4a98ff\", \"#f7e382\"])\n# determinamos el t\u00edtulo del gr\u00e1fico\nax2=plt.title(\"contact - no\", family='Serif', size=11,weight='bold')\n# establecemos el valor del tama\u00f1o de la fuente del gr\u00e1fico\nax2.set_fontsize(15)","634d32da":"# generamos unos gr\u00e1ficos de barras para visualizar la distribuci\u00f3n de los dep\u00f3sitos en funci\u00f3n de si el individuo\n# posee un pr\u00e9stamo personal, si tiene cr\u00e9ditos impagos, y si posee un pr\u00e9stamo de vivienda\nf, ax = plt.subplots(2,3, figsize=(16,8))\n# generamos los t\u00edtulos para el conjunto de gr\u00e1ficos\nplt.suptitle('An\u00e1lisis de \"deposit\" por \"loan\", \"default\", y \"housing\"', family='Serif', size=15,\n             ha='center', weight='bold')\nplt.figtext(0.5,0.93, \"Gr\u00e1ficos de barras para visualizar la distribuci\u00f3n de dep\u00f3sitos \\\nteniendo en cuenta pr\u00e9stamos personales, cr\u00e9ditos impagos, y pr\u00e9stamos de vivienda\", family = 'Serif',\n            size = 12, ha = 'center')\n\n# establecemos un gr\u00e1fico de barras (\"count plot\") para representar la cantidad de dep\u00f3sitos, teniendo en cuenta \n# si el individuo posee un pr\u00e9stamo personal\nsns.countplot(data=df_bk_mktg_in, x='loan', hue='deposit', palette=colors, ax=ax[0,0], hue_order=hue_order)\n# quitamos el recuadro que envuelve al gr\u00e1fico, configurando los par\u00e1metros de \"spines\" a \"False\"\nax[0,0].spines['left'].set_visible(False)\nax[0,0].spines['right'].set_visible(False)\nax[0,0].spines['top'].set_visible(False)\nax[0,0].spines['bottom'].set_visible(False)\n# definimos un t\u00edtulo para el gr\u00e1fico y el texto del eje \"y\"\nax[0,0].set_title('\"loan\" y \"deposit\"', family='Serif', size=11,weight='bold')\nax[0,0].set_ylabel(\"Cant. de individuos\")\n\n# establecemos un gr\u00e1fico de barras (\"count plot\") para representar la cantidad de dep\u00f3sitos, teniendo en cuenta \n# si el individuo posee cr\u00e9ditos impagos\nsns.countplot(data=df_bk_mktg_in, x='default', hue='deposit', palette=colors, ax=ax[0,1], hue_order=hue_order)\n# quitamos el recuadro que envuelve al gr\u00e1fico, configurando los par\u00e1metros de \"spines\" a \"False\"\nax[0,1].spines['left'].set_visible(False)\nax[0,1].spines['right'].set_visible(False)\nax[0,1].spines['top'].set_visible(False)\nax[0,1].spines['bottom'].set_visible(False)\n# definimos un t\u00edtulo para el gr\u00e1fico y el texto del eje \"y\"\nax[0,1].set_title('\"default\" y \"deposit\"', family='Serif', size=11,weight='bold')\nax[0,1].set_ylabel(\"Cant. de individuos\")\n\n# establecemos un gr\u00e1fico de barras (\"count plot\") para representar la cantidad de dep\u00f3sitos, teniendo en cuenta \n# si el individuo posee un pr\u00e9stamo de vivienda\nsns.countplot(data=df_bk_mktg_in, x='housing', hue='deposit', palette=colors, ax=ax[0,2], hue_order=hue_order)\n# quitamos el recuadro que envuelve al gr\u00e1fico, configurando los par\u00e1metros de \"spines\" a \"False\"\nax[0,2].spines['left'].set_visible(False)\nax[0,2].spines['right'].set_visible(False)\nax[0,2].spines['top'].set_visible(False)\nax[0,2].spines['bottom'].set_visible(False)\n# definimos un t\u00edtulo para el gr\u00e1fico y el texto del eje \"y\"\nax[0,2].set_title('\"housing\" y \"deposit\"', family='Serif', size=11,weight='bold')\nax[0,2].set_ylabel(\"Cant. de individuos\")\n\n# establecemos un histograma para representar el porcentaje de dep\u00f3sitos suscriptos, teniendo en cuenta \n# si el individuo posee un pr\u00e9stamo personal; utilizamos el par\u00e1metro \"multiple = 'fill'\" para que las barras\n# se muestren de forma apilada\nsns.histplot(data=df_bk_mktg_in, x='loan', hue='deposit', multiple=\"fill\", stat=\"count\", palette=colors,\n             ax=ax[1,0], hue_order=hue_order)\n# quitamos el recuadro que envuelve al gr\u00e1fico, configurando los par\u00e1metros de \"spines\" a \"False\"\nax[1,0].spines['left'].set_visible(False)\nax[1,0].spines['right'].set_visible(False)\nax[1,0].spines['top'].set_visible(False)\nax[1,0].spines['bottom'].set_visible(False)\n# definimos el texto del eje \"y\"\nax[1,0].set_ylabel(\"Porcentaje de individuos\")\n\n# establecemos un histograma para representar el porcentaje de dep\u00f3sitos suscriptos, teniendo en cuenta \n# si el individuo posee cr\u00e9ditos impagos; utilizamos el par\u00e1metro \"multiple = 'fill'\" para que las barras\n# se muestren de forma apilada\nsns.histplot(data=df_bk_mktg_in, x='default', hue='deposit', multiple=\"fill\", stat=\"count\", palette=colors,\n             ax=ax[1,1], hue_order=hue_order)\n# quitamos el recuadro que envuelve al gr\u00e1fico, configurando los par\u00e1metros de \"spines\" a \"False\"\nax[1,1].spines['left'].set_visible(False)\nax[1,1].spines['right'].set_visible(False)\nax[1,1].spines['top'].set_visible(False)\nax[1,1].spines['bottom'].set_visible(False)\n# definimos el texto del eje \"y\"\nax[1,1].set_ylabel(\"Porcentaje de individuos\")\n\n# establecemos un histograma para representar el porcentaje de dep\u00f3sitos suscriptos, teniendo en cuenta \n# si el individuo posee un pr\u00e9stamo de vivienda; utilizamos el par\u00e1metro \"multiple = 'fill'\" para que las barras\n# se muestren de forma apilada\nsns.histplot(data=df_bk_mktg_in, x='housing', hue='deposit', multiple=\"fill\", stat=\"count\", \n             palette=colors, ax=ax[1,2], hue_order=hue_order)\n# quitamos el recuadro que envuelve al gr\u00e1fico, configurando los par\u00e1metros de \"spines\" a \"False\"\nax[1,2].spines['left'].set_visible(False)\nax[1,2].spines['right'].set_visible(False)\nax[1,2].spines['top'].set_visible(False)\nax[1,2].spines['bottom'].set_visible(False)\n# definimos el texto del eje \"y\"\nax[1,2].set_ylabel(\"Porcentaje de individuos\")","18311278":"# generamos unos gr\u00e1fico de lineas y unos gr\u00e1ficos de barras donde se muestra la distribuci\u00f3n de depositos por\n# edad y balance\nfig=plt.figure(figsize=(15,8))\n# determinamos los t\u00edtulos del conjunto de gr\u00e1ficos\nplt.suptitle('An\u00e1lisis de \"balance\" por \"age\" y \"deposit\"', family='Serif', size=15, ha='center', weight='bold')\nplt.figtext(0.5,0.93,\"Gr\u00e1ficos de lineas y barras que muestran la distribuci\u00f3n del balance por edad y dep\u00f3sito\",\n            family='Serif', size=12, ha='center')\n\n# establecemos el formato del \"grid\", que tendr\u00e1 3 filas y 1 columna\ngs = GridSpec(nrows=3, ncols=1, height_ratios=[5,2,2])\n\n# definimos la ubicaci\u00f3n del primer gr\u00e1fico en el \"grid\"\nax1=plt.subplot(gs[0,0])\n# generamos unos gr\u00e1fico de lineas donde se muestra la distribuci\u00f3n del balance por edad y dep\u00f3sito\nax1=sns.lineplot(data=df_bk_mktg_in,y='balance',x='age', hue='deposit',palette=colors, hue_order=hue_order)\n# dejamos el t\u00edtulo del eje de las \"x\" vac\u00edo, ya que el mismo se encuentran en el eje de las \"x\"\n# del tercer gr\u00e1fico de barras\nax1.set_xlabel(\"\")\n\n# definimos la ubicaci\u00f3n del segundo gr\u00e1fico en el \"grid\"\nax2=plt.subplot(gs[1,0])\n# generamos unos gr\u00e1fico de barras donde se muestra la distribuci\u00f3n del balance por edad y dep\u00f3sitos \n# teniendo en cuenta los no suscriptos\nax2=sns.barplot(data=df_bk_mktg_in[df_bk_mktg_in['deposit']=='no'],y='balance',x='age', hue='deposit',\n                palette=[\"#0095ff\"], ci=False)\n# dejamos el t\u00edtulo del eje de las \"x\" vac\u00edo, ya que el mismo se encuentran en el eje de las \"x\"\n# del tercer gr\u00e1fico de barras\nax2.set_xlabel(\"\")\n\n# definimos la ubicaci\u00f3n del tercer gr\u00e1fico en el \"grid\"\nax3=plt.subplot(gs[2,0])\n# generamos unos gr\u00e1fico de barras donde se muestra la distribuci\u00f3n del balance por edad y dep\u00f3sitos suscriptos\nax3=sns.barplot(data=df_bk_mktg_in[df_bk_mktg_in['deposit']=='yes'],y='balance',x='age', hue='deposit',\n                palette=[\"#f58e00\"], ci=False)\n\n# realizamos un bulcle \"for\" para quitar el recuadro que envuelve a cada uno de los gr\u00e1ficos\nfor i in ['left','right','bottom','top']:\n    ax1.spines[i].set_visible(False)\n    ax2.spines[i].set_visible(False)\n    ax3.spines[i].set_visible(False)","2b57a6f7":"# generamos unos gr\u00e1fico de dispersi\u00f3n (\"scatter plot\") que muestra la distribuci\u00f3n de depositos por\n# edad y balance\nfig = plt.figure(figsize=(12,8))\n# determinamos el t\u00edtulo del gr\u00e1fico\nplt.suptitle('An\u00e1lisis de relaci\u00f3n entre \"age\" y \"balance\" por \"deposit\"', family='Serif', size=15,\n             ha='center', weight='bold')\nplt.figtext(0.5,0.93,\"Gr\u00e1fico de dispersi\u00f3n que muestra la relaci\u00f3n entre edad y balance por la variable \\\nde dep\u00f3sito\", family='Serif', size=12, ha='center')\n# creamos el gr\u00e1fico descripto anteriormente\nax=sns.scatterplot(data=df_bk_mktg_in, x='age',y='balance', hue='deposit',palette=[\"#f58e00\", \"#0095ff\"])\n# configuramos los valores del eje \"y\" entre 0 y 4000\nax.set_ylim(0,4000)\n# determinamos los textos y el tama\u00f1o de fuente de las descripciones de los ejes\nax.set_xlabel(\"age\",size=15)\nax.set_ylabel(\"balance\",size=15)","b5ee26ca":"# generamos un conjunto de gr\u00e1ficos (\"Pair Plot\") donde se muestra la relaci\u00f3n existente entre las distintas\n# variables num\u00e9ricas del dataset\nax = sns.pairplot(df_bk_mktg_in, hue='deposit', palette=colors, hue_order=hue_order)\n# definimos los t\u00edtulos y mostramos el conjunto de gr\u00e1ficos\nax.fig.suptitle('Gr\u00e1ficos de Pares (\"Pair Plot\") que presenta las relaciones entre las variables n\u00famericas',\n                family='Serif', size=20, ha='center', weight='bold', y = 1.01)\nplt.show()","1b15a52a":"!pip install dython\n# realizamos los imports necesarios\nfrom dython import nominal\n# generamos un mapa de calor (\"heat map\") donde se muestra la correlaci\u00f3n\/asociaci\u00f3n existente entre \n# las distintas variables del dataset, ya sean num\u00e9ricas o categ\u00f3ricas\nfig, ax = plt.subplots(figsize=(20,10))\n# definimos los t\u00edtulos\nplt.suptitle('An\u00e1lisis de relaciones entre las variables', family='Serif', size=15,\n             ha='center', weight='bold')\nplt.figtext(0.5,0.93,\"Mapa de Calor que muestra las relaciones entre las variables num\u00e9ricas \\\ny categ\u00f3ricas\", family='Serif', size=12, ha='center')\n# establecemos el mencionado mapa de calor\nnominal.associations(df_bk_mktg_in,figsize=(20,10),mark_columns=False, ax=ax)","fc528036":"# generamos una copia del dataset inicial\ndf_bk_mktg_cero_uno = df_bk_mktg_in.copy()\n# remplazamos \"yes\" por 1 y \"no\" por 0\ndf_bk_mktg_cero_uno['deposit']=df_bk_mktg_cero_uno['deposit'].replace({'yes':1,'no':0})","a7231c31":"# visualizamos el resultado\ndf_bk_mktg_cero_uno['deposit']","131510fa":"# visualizamos los resultados\ndf_bk_mktg_cero_uno.columns","4e511248":"# nos quedamos con todas las variables excepto con la variable objetivo\nX= df_bk_mktg_cero_uno.drop(['deposit'], axis=1)\n# inicializamos una variable que contiene la variable objetivo\ny= df_bk_mktg_cero_uno['deposit']","22d5111e":"# visualizamos el resultado\nX","fb20942e":"# visualizamos el resultado\ny","bc046a66":"# realizamos los imports necesarios para efectuar el muestreo\nfrom sklearn.model_selection import train_test_split\n\n# realizamos un muestreo estratificado en funci\u00f3n de la varibale objetivo, con un 60%, 20%, y 20%,  \n# para train, validaci\u00f3n, y test, respectivamente\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)\nX_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.25, random_state=42,\n                                                  stratify=y_train)","52e2de53":"# visualizamos las dimensiones del conjunto de las variables independientes en train\nprint('Dimensiones de los datos de train: ', X_train.shape)","68e019f2":"# visualizamos las dimensiones del conjunto de las variables independientes en validaci\u00f3n\nprint('Dimensiones de los datos de validaci\u00f3n: ', X_val.shape)","530a07b7":"# visualizamos las dimensiones del conjunto de las variables independientes en test\nprint('Dimensiones de los datos de test: ', X_test.shape)","d6160b21":"# visualizamos las dimensiones de la variable target en train\nprint('Dimensiones de los datos de train (objetivo): ', y_train.shape)","a0f0605f":"# visualizamos las dimensiones de la variable target en validaci\u00f3n\nprint('Dimensiones de los datos de validaci\u00f3n (objetivo): ', y_val.shape)","44e82544":"# visualizamos las dimensiones de la variable target en test\nprint('Dimensiones de los datos de test (objetivo): ', y_test.shape)","109fc772":"# seleccionamos s\u00f3lo las variables num\u00e9ricas para los distintos conjuntos de datos\nX_train_num = X_train.select_dtypes(include='int64')\nX_val_num = X_val.select_dtypes(include='int64')\nX_test_num = X_test.select_dtypes(include='int64')","41007348":"# seleccionamos s\u00f3lo las variables categ\u00f3ricas para los distintos conjuntos de datos\nX_train_cat = X_train.select_dtypes(include='object')\nX_val_cat = X_val.select_dtypes(include='object')\nX_test_cat = X_test.select_dtypes(include='object')","b69539a2":"# realizamos los imports necesarios\nfrom sklearn.preprocessing import StandardScaler\n# inicializamos el \"Standard Scaler\" a una variable \nscaler = StandardScaler()\n\n# transformamos los datos\nX_train_num_s = scaler.fit_transform(X_train_num)\nX_val_num_s = scaler.transform(X_val_num)\nX_test_num_s = scaler.transform(X_test_num)","ae7e4b69":"# convertimos la salida en un \"DataFrame\" ya que se trataba de un \"Array\"\nX_train_num_s = pd.DataFrame(X_train_num_s, index=X_train_num.index, columns=X_train_num.columns)","582513a9":"# convertimos la salida en un \"DataFrame\" ya que se trataba de un \"Array\"\nX_val_num_s = pd.DataFrame(X_val_num_s, index=X_val_num.index, columns=X_val_num.columns)","8cecad50":"# convertimos la salida en un \"DataFrame\" ya que se trataba de un \"Array\"\nX_test_num_s = pd.DataFrame(X_test_num_s, index=X_test_num.index, columns=X_test_num.columns)","d4b299c7":"# unimos las variables num\u00e9ricas estandarizadas, con las variables categ\u00f3ricas\nX_train_s = X_train_num_s.join(X_train_cat)","e09855a1":"# unimos las variables num\u00e9ricas estandarizadas, con las variables categ\u00f3ricas\nX_val_s = X_val_num_s.join(X_val_cat)","605d1f56":"# unimos las variables num\u00e9ricas estandarizadas, con las variables categ\u00f3ricas\nX_test_s = X_test_num_s.join(X_test_cat)","31cc433c":"# visualizamos los resultados\nX_train_s.round(decimals=2)","c3d10fcc":"# visualizamos los resultados\nX_val_s.round(decimals=2)","477d5f59":"# visualizamos los resultados\nX_test_s.round(decimals=2)","570dfb44":"# realizamos los imports necesarios para generar las variables \"dummy\"\n!pip install feature_engine\nfrom feature_engine.encoding import OneHotEncoder\n\n# generamos el encoder\nencoder = OneHotEncoder(drop_last = False)\n\n# hacemos un fit del encoder\nencoder.fit(X_train_s)\n\n# transformamos los datos\nX_train_s = encoder.transform(X_train_s)\nX_val_s = encoder.transform(X_val_s)\nX_test_s = encoder.transform(X_test_s)\n\n# visualizamos las variables del encoder y sus valores\nencoder.encoder_dict_  ","8d581cad":"# visualizamos los resultados \nX_train_s.round(decimals=2)","9b0a5466":"# visualizamos los resultados \nX_val_s.round(decimals=2)","a0efb997":"# visualizamos los resultados \nX_test_s.round(decimals=2)","59fca6a4":"# Cargamos algunos paquetes\nfrom sklearn.datasets import make_classification\nfrom sklearn.metrics import roc_auc_score, accuracy_score, auc, confusion_matrix, f1_score, precision_score, recall_score, roc_curve","d0cb88b5":"# generamos una funci\u00f3n \"reporte_modelo\" para obtener y visualizar diferentes m\u00e9tricas que necesitamos conocer \n# para evaluar los modelos\n!pip install yellowbrick\ndef reporte_modelo(X_train, X_val, y_train, y_val, pred, model):\n    # realizamos los imports necesarios\n    from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n    from yellowbrick.classifier import ROCAUC\n    # imprimimos las diferentes metricas y el \"classification_report\"\n    print(\"Reporte de m\u00e9tricas del modelo\")\n    print(\"\")\n    print(\"Matriz de Confusion\")\n    print(confusion_matrix(y_val, pred))\n    print(classification_report(y_val,pred))\n    print(\"Accuracy:\", accuracy_score(y_val,pred).round(decimals=4))\n    print(\"ROC AUC:\", roc_auc_score(y_val,pred).round(decimals=4))\n    # generamos un gr\u00e1fico de la Curva ROC \n    fig = plt.figure(figsize=(20,8))\n    gs=GridSpec(nrows=1, ncols=2)\n    ax1=plt.subplot(gs[0,0])\n    ax1=plt.title(\"Gr\u00e1fico de la Curva de ROC del modelo\", family='Serif', size=9)\n    ax1.set_fontsize(12)\n    visual = ROCAUC(model, classes=[0,1])\n    visual.fit(X_train,y_train)\n    ax1=visual.score(X_val,y_val)","e47d441d":"# efectuamos los imports necesarios\nfrom sklearn.linear_model import LogisticRegression\n\n# generamos el modelo, lo entrenamos, realizamos predicciones, y visualizamos los resultados\nmodel = LogisticRegression(random_state = 0, solver='liblinear') # fijamos la semilla\nmodel.fit(X_train_s, y_train)\npred = model.predict(X_val_s)\nreporte_modelo(X_train_s, X_val_s, y_train, y_val, pred, model)","40d1cffb":"# efectuamos los imports necesarios\nfrom sklearn.ensemble import GradientBoostingClassifier\n\n# generamos el modelo, lo entrenamos, realizamos predicciones, y visualizamos los resultados\nmodel = GradientBoostingClassifier(random_state = 0) # fijamos la semilla\nmodel.fit(X_train_s, y_train)\npred = model.predict(X_val_s)\nreporte_modelo(X_train_s, X_val_s, y_train, y_val, pred, model)","440d7e9b":"# efectuamos los imports necesarios\nfrom xgboost import XGBClassifier\n\n# generamos el modelo, lo entrenamos, realizamos predicciones, y visualizamos los resultados\nmodel = XGBClassifier(random_state = 0) # fijamos la semilla\nmodel.fit(X_train_s, y_train)\npred = model.predict(X_val_s)\nreporte_modelo(X_train_s, X_val_s, y_train, y_val, pred, model)","9b9d3e28":"!pip install lightgbm\n# efectuamos los imports necesarios\nimport lightgbm\nfrom lightgbm import LGBMClassifier\n\n# generamos el modelo, lo entrenamos, realizamos predicciones, y visualizamos los resultados\nmodel = LGBMClassifier(random_state = 0) # fijamos la semilla\nmodel.fit(X_train_s, y_train)\npred = model.predict(X_val_s)\nreporte_modelo(X_train_s, X_val_s, y_train, y_val, pred, model)","b2f7e88d":"!pip install catboost\n# efectuamos los imports necesarios\nimport catboost\nfrom catboost import CatBoostClassifier\nfrom yellowbrick.contrib.wrapper import wrap\n\n# generamos el modelo, lo entrenamos, realizamos predicciones, y visualizamos los resultados\nmodel = CatBoostClassifier(verbose=0, random_state = 0) # fijamos la semilla y quitamos el \"verbose\" para que \n                                                        # nos muestre los resultados de forma directa\nmodel.fit(X_train_s, y_train)\npred = model.predict(X_val_s)\nreporte_modelo(X_train_s, X_val_s, y_train, y_val, pred, wrap(model)) # utilizamos un \"wrapper\" para\n                                                                        # poder ejecutar el reporte","b4a74905":"# efectuamos los imports necesarios\nfrom sklearn.ensemble import AdaBoostClassifier\n\n# generamos el modelo, lo entrenamos, realizamos predicciones, y visualizamos los resultados\nmodel = AdaBoostClassifier(random_state = 0) # fijamos la semilla\nmodel.fit(X_train_s, y_train)\npred = model.predict(X_val_s)\nreporte_modelo(X_train_s, X_val_s, y_train, y_val, pred, model)","19a8a6f8":"# efectuamos los imports necesarios\nfrom sklearn.tree import DecisionTreeClassifier\n\n# generamos el modelo, lo entrenamos, realizamos predicciones, y visualizamos los resultados\nmodel = DecisionTreeClassifier(random_state = 0) # fijamos la semilla\nmodel.fit(X_train_s, y_train)\npred = model.predict(X_val_s)\nreporte_modelo(X_train_s, X_val_s, y_train, y_val, pred, model)","69a3179d":"# efectuamos los imports necesarios\nfrom sklearn.ensemble import RandomForestClassifier\n\n# generamos el modelo, lo entrenamos, realizamos predicciones, y visualizamos los resultados\nmodel = RandomForestClassifier(random_state = 0) # fijamos la semilla\nmodel.fit(X_train_s, y_train)\npred = model.predict(X_val_s)\nreporte_modelo(X_train_s, X_val_s, y_train, y_val, pred, model)","99022df3":"# efectuamos los imports necesarios\nfrom sklearn.svm import SVC\n\n# generamos el modelo, lo entrenamos, realizamos predicciones, y visualizamos los resultados\nmodel = SVC(probability=True, random_state = 0) # utilizamos los estimadores de probabilidad y validaci\u00f3n cruzada\n                                                # y fijamos la semilla\nmodel.fit(X_train_s, y_train)\npred = model.predict(X_val_s)\nreporte_modelo(X_train_s, X_val_s, y_train, y_val, pred, model)","945c5cc3":"# efectuamos los imports necesarios\nfrom sklearn import naive_bayes\n\n# generamos el modelo, lo entrenamos, realizamos predicciones, y visualizamos los resultados\nmodel = naive_bayes.GaussianNB() # no fijamos la semilla porque no es necesario (el modelo no tiene \n                                 # el par\u00e1metro \"random_state\")\nmodel.fit(X_train_s, y_train)\npred = model.predict(X_val_s)\nreporte_modelo(X_train_s, X_val_s, y_train, y_val, pred, model)","0ad0f4e7":"# efectuamos los imports necesarios\nfrom sklearn.neighbors import KNeighborsClassifier\n\n# generamos el modelo, lo entrenamos, realizamos predicciones, y visualizamos los resultados\nmodel = KNeighborsClassifier() # no fijamos la semilla porque no es necesario (el modelo no tiene\n                               # el par\u00e1metro \"random_state\")\nmodel.fit(X_train_s, y_train)\npred = model.predict(X_val_s)\nreporte_modelo(X_train_s, X_val_s, y_train, y_val, pred, model)","e1cd32f6":"# realizamos los imports necesarios\nfrom sklearn.neural_network import MLPClassifier\n\n# generamos el modelo, lo entrenamos, realizamos predicciones, y visualizamos los resultados\nmodel = MLPClassifier(hidden_layer_sizes=(64,64), alpha=1, random_state=0) # utilizamos una \n                                                                         # regularizaci\u00f3n con \"alpha=1\", y dos \n                                                                        # capas ocultas con 64 neuronas\n                                                                        # y fijamos la semilla\nmodel.fit(X_train_s, y_train)\npred = model.predict(X_val_s)\nreporte_modelo(X_train_s, X_val_s, y_train, y_val, pred, model)","bbefb083":"# generamos un disccionario vac\u00edo para ir agregando los distintos modelos en el, utilizando los mismos par\u00e1mteros \n# que usamos previamente\nmodels = {}\n\n# Logistic Regression\nmodels['Logistic Regression'] = LogisticRegression(random_state = 0, solver='liblinear')\n\n# Gradient Boosting\nmodels['Gradient Boosting'] = GradientBoostingClassifier(random_state = 0)\n\n# Extreme Gradient Boosting\nmodels['XGB'] = XGBClassifier(random_state = 0)\n\n# Light Gradient Boosting\nmodels['LGB'] = LGBMClassifier(random_state = 0)\n\n# CatBoost\nmodels['CatBoost'] = CatBoostClassifier(verbose=0, random_state = 0)\n\n# AdaBoost\nmodels['AdaBoost'] = AdaBoostClassifier(random_state = 0)\n\n# Decision Tree\nmodels['Decision Tree'] = DecisionTreeClassifier(random_state = 0)\n\n# Random Forest\nmodels['Random Forest'] = RandomForestClassifier(random_state = 0)\n\n# Support Vector Machines\nmodels['SVM'] = SVC(probability=True, random_state = 0) \n\n# Naive Bayes\nmodels['Naive Bayes'] = naive_bayes.GaussianNB()\n\n# K-Nearest Neighbors\nmodels['K-Nearest Neighbors'] = KNeighborsClassifier()\n\n# Multi-layer Perceptron\nmodels['MLP'] = MLPClassifier(hidden_layer_sizes=(64,64), alpha=1, random_state=0)","708111a7":"# importamos las librerias necesarias para calcular las distintas m\u00e9tricas\nfrom sklearn.metrics import roc_auc_score, accuracy_score, precision_score, recall_score, f1_score \n\n# generamos 3 diccionarios para almacenar los valores de las m\u00e9tricas de los diferentes modelos\nROC_AUC, accuracy, precision, recall, f1 = {}, {}, {}, {}, {} \n\n# utilizamos un bucle \"for\" para entrenar los modelos, predecir, y obtener los resultados, recorriendo las \"keys\"\n# del diccionario de modelos\nfor key in models.keys():    \n    # entrenamos los modelos\n    models[key].fit(X_train_s, y_train)\n    # hacemos la predicci\u00f3n\n    predictions = models[key].predict(X_val_s)\n    # calculamos las m\u00e9tricas\n    ROC_AUC[key] = roc_auc_score(y_val, predictions)\n    accuracy[key] = accuracy_score(y_val, predictions)\n    precision[key] = precision_score(y_val, predictions, average=\"macro\") # utilizamos \"macro avg\"\n    recall[key] = recall_score(y_val, predictions, average='macro') # utilizamos \"macro avg\"\n    f1[key] = f1_score(y_val, predictions, average='macro') # utilizamos \"macro avg\"","b308ef18":"# generamos un \"DataFrame\" con los valores de las m\u00e9tricas\ndf_model = pd.DataFrame(index=models.keys(), columns=['ROC AUC', 'Accuracy', 'Precision', 'Recall', 'F1'])\ndf_model['ROC AUC'] = ROC_AUC.values()\ndf_model['Accuracy'] = accuracy.values()\ndf_model['Precision'] = precision.values()\ndf_model['Recall'] = recall.values()\ndf_model['F1'] = f1.values()\n\n# ordenamos el \"DataFrame\" por \"Accuracy\" de forma descendente \ndf_model.sort_values('Accuracy', ascending=False).round(decimals=4)","cc5ce57f":"# generamos un gr\u00e1fico de barras con los resultados de las m\u00e9tricas para cada modelo\nax  = df_model.plot.bar(rot=45, figsize = (14,7))\n# definimos los t\u00edtulos\nplt.suptitle('An\u00e1lisis de m\u00e9tricas', family='Serif', size=15, ha='center', weight='bold')\nplt.figtext(0.5,0.93,\"Gr\u00e1ficos de barras que muestra los valores de las m\u00e9tricas de los modelos\",\n            family='Serif', size=12, ha='center')\n# definimos las leyendas y el estilo del gr\u00e1fico\nax.legend(ncol= len(models.keys()), bbox_to_anchor=(0, 1), loc='lower left', prop={'size': 14})\nplt.tight_layout()","9b344fa7":"# realizamos los imports necesarios\nfrom sklearn.feature_selection import SelectFromModel\n\n# generamos el selector\nsel = SelectFromModel(CatBoostClassifier(verbose=0, random_state = 0))\n\n# lo entrenamos\nsel.fit(X_train_s, y_train)","8df9ba12":"# observamos la cantidad de variables seleccionadas\nselected_feat= pd.DataFrame(X_train_s).columns[(sel.get_support())]\nprint('El n\u00famero de variables seleccionadas es:', len(selected_feat))","c3046f67":"# hacemos un print de las variables seleccionadas\nprint(selected_feat)","ecda4ae2":"# guardamos los nombres de las variables seleccionadas en una lista\ncolumnas = list(selected_feat)","56d8b47d":"# definimos los nuevos conjuntos de train y test s\u00f3lo con las variables seleccionadas\nX_train_sel = X_train_s[columnas]\nX_val_sel = X_val_s[columnas]","0e2adf94":"# aplicamos la selecci\u00f3n al modelo de CatBoost que nos hab\u00eda dado los mejores resultados hasta ahora\nmodel = CatBoostClassifier(verbose=0, random_state = 0)\nmodel.fit(X_train_sel, y_train)\npred = model.predict(X_val_sel)\nreporte_modelo(X_train_sel, X_val_sel, y_train, y_val, pred, wrap(model))","02a11c23":"# primero tomamos el mejor modelo hasta ahora\nmodel = CatBoostClassifier(verbose=0, random_state = 0).fit(X_train_s, y_train)","d9925ca6":"# hacemos los imports necesarios\nfrom sklearn.model_selection import GridSearchCV\n\n#definimos los diferentes hiperpar\u00e1metros con los que vamos a trabajar y sus valores\ngrid_param = {'learning_rate': [0.03, 0.1],\n        'depth': [4, 6, 10],\n        'l2_leaf_reg': [1, 3, 5, 7, 9]}","e50f019c":"# generamos el grid\nmodel_grid = GridSearchCV(estimator=model,\n                     param_grid=grid_param,\n                     scoring='accuracy',\n                     cv=5,\n                     n_jobs=-1)","1d374ac2":"# entrenamos el modelo\nmodel_grid_fit = model_grid.fit(X_train_s, y_train)","8972e932":"# visualizamos los mejores par\u00e1metros para el modelo\nprint(model_grid_fit.best_params_)","0bdd693a":"# visualizamos el score del modelo\nprint('Accuracy promedio con hiperpar\u00e1metros: ', model_grid_fit.best_score_.round(decimals=4))","40bdabd2":"# realizamos los imports necesarios\nfrom sklearn.model_selection import cross_val_score\n\n# generamos el modelo que di\u00f3 mejores resultados hasta ahora\nmodel = CatBoostClassifier(verbose=0, random_state = 0) # fijamos la semilla\n\n# aplicamos validaci\u00f3n cruzada para chequear la estabilidad del modelo \nresults = cross_val_score(estimator = model, X = X_train_s, y= y_train, cv=5)","e113fba8":"# visualizamos el \"accuracy\" obtenido \nresults.round(decimals=4)","7a1072c2":"# observamos la media de los resultados obtenidos\nprint('Accuracy promedio del mejor modelo: ', results.mean().round(decimals=4))","9f25547d":"# visualizamos la variaci\u00f3n de los resultados\nprint('Desviaci\u00f3n Est\u00e1ndar del mejor modelo: ', results.std().round(decimals=4))","491116dd":"# generamos el modelo de CatBoost surgido de la automatizaci\u00f3n de modelos, que fue el que nos di\u00f3 el \n# mejor resultado durante nuestro an\u00e1lisis, y an\u00e1lizamos los resultados finales sobre el conjunto de validaci\u00f3n\nmodel = CatBoostClassifier(verbose=0, random_state = 0, depth = 6, l2_leaf_reg = 7, learning_rate = 0.03)# fijamos \n                                                                                                # los par\u00e1metros \n                                                                                               # obtenidos del \n                                                                                                # GridSearchCV\nmodel.fit(X_train_s, y_train)\npred = model.predict(X_val_s)\nreporte_modelo(X_train_s, X_val_s, y_train, y_val, pred, wrap(model)) # utilizamos un \"wrapper\" para\n                                                                        # poder ejecutar el reporte","ebbd26fd":"# realizamos los imports necesarios\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import OneHotEncoder\n\n# generamos una lista con las variables num\u00e9ricas \nnumeric_features = list(X_train.select_dtypes(exclude='object').columns)\n\n# almacenamos el estandarizador en una variable\nnumeric_transformer = StandardScaler()\n\n# generamos una lista con las variables categ\u00f3ricas\ncategorical_features = list(X_train.select_dtypes(include='object').columns)\n\n# almacenamos el encoder en una variable\ncategorical_transformer = OneHotEncoder()\n\n# generamos \"ColumnTransformer\" para procesar los datos\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('num', numeric_transformer, numeric_features),\n        ('cat', categorical_transformer, categorical_features)])\n\n# agregamos el modelo a nuestro pipeline de procesamiento\n# ahora tenemos un pipeline de predicci\u00f3n completo\nmodel = Pipeline(steps=[('preprocessor', preprocessor),\n                      ('classifier', CatBoostClassifier(verbose=0, random_state = 0, depth = 6,\n                                                        l2_leaf_reg = 7, learning_rate = 0.03))])\n# visualizamos el pipeline\nmodel","2c54057b":"# generamos el modelo, lo entrenamos, realizamos predicciones, y visualizamos los resultados en test,\n# partiendo de los datos crudos \nmodel.fit(X_train, y_train)\npred = model.predict(X_test)\nreporte_modelo(X_train, X_test, y_train, y_test, pred, wrap(model)) ","0cc3ef32":"# usamos \"pickle\" para guardar el modelo de pipeline y utiliarlo en el futuro en producci\u00f3n\nimport pickle\n\n# guardamos el modelo en el disco\nfilename = 'final_model.sav'\npickle.dump(model, open(filename, 'wb'))\n  \n# cargamos el modelo desde el disco para asegurarnos de que podemos volver a utilizarlo\nloaded_model = pickle.load(open(filename, 'rb'))\nreporte_modelo(X_train, X_test, y_train, y_test, pred, wrap(loaded_model)) ","46ee62cf":"### El objetivo de este an\u00e1lisis es generar modelos de Machine Learning y Deep Learning, que posean un alto grado de acierto a la hora de predecir, en base a ciertas variables predictoras, el comportamiento de la variable target, que en este caso ser\u00e1 el resultado de una campa\u00f1a de marketing de un banco portugu\u00e9s, pudiendo este tomar 2 valores diferentes: \u00a8yes\u00a8 (si los clientes aquieren un dep\u00f3sito a plazo fijo), y \u00a8no\u00a8 (si los clientes no aquieren un dep\u00f3sito a plazo fijo). El conjunto de datos a analizar se encuentra en el siguiente link:\n\n### https:\/\/www.kaggle.com\/janiobachmann\/bank-marketing-dataset?select=bank.csv","a3b22a76":"### Multi-layer Perceptron","050abcb7":"# 1) Introducci\u00f3n ","870a136d":"## 5.2) Automatizaci\u00f3n de modelos","967bb38d":"### Light Gradient Boosting","986774a6":"## 6.2) Productivizaci\u00f3n del modelo ganador y resultados en test","73ac0535":"### AdaBoost","4d16c5cb":"## 1.1) Presentaci\u00f3n","e0c09ae6":"## 5.1) Selecci\u00f3n de variables","1ccba2d2":"## El modelo ganador fue el modelo CatBoost que surgi\u00f3 de la automatizaci\u00f3n de modelos, ya que es el que presenta mejores resultados al ser expuesto a validaci\u00f3n cruzada, demostrando que es el modelo m\u00e1s estable. En este sentido, el modelo ganador tiene un poder predictivo bastante bueno, ya que este logr\u00f3 valores de accuracy en el entorno del 86% en validaci\u00f3n, y 87% en test.","c0d00931":"## 3.1) Modificaciones iniciales","487a49c5":"## 6.1) Modelo ganador y resultados en validaci\u00f3n ","90188044":"## 1.2) Descripci\u00f3n de las variables","d0806c43":"# 2) An\u00e1lisis exploratorio y descriptivo de los datos","6a924b3d":"## 4.2) An\u00e1lisis de resultados:","bf2f95d0":"# Anexo\n# 8.2) C\u00f3digo en Python\n\n## Bank Marketing - Trabajo de Fin de M\u00e1ster\n\n### Gonzalo Cairo Acosta\n\n#### 28\/09\/2021","987ee143":"## 2.2) Visualizaci\u00f3n gr\u00e1fica de los datos","6488ec08":"### SVM","d3542e51":"## 2.1) An\u00e1lisis primario de los datos  ","40f89731":"# 3) Transformaci\u00f3n de datos","a08df66a":"## 3.2) Muestreo de los datos ","61b4ba46":"# 7) Conclusiones","a7bbe5d9":"# 4) Modelizaci\u00f3n predictiva:","fa7083f8":"### Random Forest","dcbbb56e":"### Naive Bayes","a9eeff0d":"## 3.3) Estandarizaci\u00f3n de variables num\u00e9ricas","d62ffc9f":"### El presente an\u00e1lisis forma parte de un proceso de evaluaci\u00f3n de mi Trabajo de Fin de M\u00e1ster (TFM), asociado al M\u00e1ster de Big Data y Data Science, con aplicaciones al comercio, empresa y finanzas 2020-2021 (online), impartido por la Facultad de Comercio y Turismo, de la Universidad Complutense de Madrid.","f8c7868d":"## Variables predictivas:\n### 1 - age: edad (num\u00e9rica).\n### 2 - job: ocupaci\u00f3n (categ\u00f3rica: \u201cadmin.\u201d, \u201cblue-collar\u201d, \u201centrepreneur\u201d, \u201chousemaid\u201d, \u201cmanagement\u201d, \u201cretired\u201d, \u201cself-employed\u201d, \u201cservices\u201d, \u201cstudent\u201d, \u201ctechnician\u201d, \u201cunemployed\u201d, y \u201cunknown\u201d).\n### 3 - marital: estado civil (categ\u00f3rica: \u201cdivorced\u201d, \u201cmarried\u201d, y \u201csingle\u201d; nota: \u201cdivorced\u201d refiere a divorciado o viudo).\n### 4 \u2013 education: (categ\u00f3rica: \u201cprimary\u201d, \u201csecondary\u201d, \u201ctertiary\u201d, y \u201cunknown\u201d).\n### 5 - default: \u00bftiene cr\u00e9ditos impagos? (categ\u00f3rica binaria: \u201cno\u201d y \u201cyes\u201d).\n### 6 - housing: \u00bftiene un pr\u00e9stamo de vivienda? (categ\u00f3rica binaria: \u201cno\u201d y \u201cyes\u201d).\n### 7 - loan: \u00bftiene un pr\u00e9stamo personal?  (categ\u00f3rica binaria: \u201cno\u201d y \u201cyes\u201d).\n### 8 - balance: balance del individuo (num\u00e9rica).\n### 9 - contact: medio donde se contact\u00f3 al individuo (categ\u00f3rica: \u201ccelular\u201d, \u201ctelephone\u201d, y \u201cunknown\u201d).\n### 10 - month: mes del a\u00f1o del \u00faltimo contacto (categ\u00f3rica: \u201cjan\u201d, \u201cfeb\u201d, \u201cmar\u201d, ..., \u201cnov\u201d, y \u201cdec\u201d).\n### 11 - day: d\u00eda del mes del \u00faltimo contacto (categ\u00f3rica: 1, \u2026, 31).\n### 12 - duration: duraci\u00f3n del \u00faltimo contacto en segundos (num\u00e9rica). \n### 13 - campaign: n\u00famero de contactos realizados con respecto a un cliente dado, durante esta campa\u00f1a (num\u00e9rica; incluye el \u00faltimo contacto).\n### 14 - pdays: n\u00famero de d\u00edas que han pasado desde el \u00faltimo contacto a un cliente por una campa\u00f1a previa (num\u00e9rica; \u201c-1\u201d significa que el cliente no fue contactado previamente).\n### 15 - previous: n\u00famero de contactos realizados con respecto a un cliente dado, antes de esta campa\u00f1a (num\u00e9rica).\n### 16 - poutcome: resultado de la campa\u00f1a anterior (categ\u00f3rica: \u201cfailure\u201d, \u201cother\u201d, \u201csuccess\u201d, y \u201cunknown\u201d).\n\n## Variable objetivo:\n### 17 - deposit: \u00bfel cliente suscribi\u00f3 un dep\u00f3sito a plazo fijo? (categ\u00f3rica binaria: \u201cyes\u201d y \u201cno\u201d).\n","19839edc":"## 5.3) Validaci\u00f3n Cruzada","9df81c43":"### CatBoost","34e073bf":"# 6) Resultados finales","8bde0dbd":"### Regresi\u00f3n Log\u00edstica","dba1884c":"### Decision Tree","6d9b4bb7":"###  Gradient Boosting","e646c309":"## 3) 4) OneHotEncoder","69666dbd":"# 5) Mejora de modelos","8ed86951":"## 4.1) Aplicaci\u00f3n de modelos","b0a775c9":"### K-Nearest Neighbors","2ef207bc":"###  Extreme Gradient Boosting"}}