{"cell_type":{"c54cdb9c":"code","ce46e6cd":"code","2c78a7d2":"code","9c9ee0b8":"code","122be058":"code","00331818":"code","d93779ba":"code","e449f488":"code","e708f38c":"code","df36ce37":"code","feec84ca":"code","a486f852":"code","0b4b8f6b":"code","770673ba":"code","377d850e":"code","d2b9013f":"markdown","01515d44":"markdown","0617cacf":"markdown","820416bb":"markdown","9373223b":"markdown","72c5cd2b":"markdown","62dbdead":"markdown","1938c2a9":"markdown","a37034a9":"markdown","2ed13546":"markdown","b8f41e09":"markdown","896446a1":"markdown","36c5432c":"markdown","0135d4f2":"markdown"},"source":{"c54cdb9c":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n\nimport matplotlib\nmatplotlib.rcParams['figure.figsize'] = [10, 10]\n\nimport matplotlib.pyplot as plt # For plotting the points.\nfrom IPython import display # A convinient way of plotting \nimport random\nimport time\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","ce46e6cd":"df = pd.read_csv(\"..\/input\/Mall_Customers.csv\")\ndf.head()","2c78a7d2":"data = df[['Annual Income (k$)', 'Spending Score (1-100)']]\npoints = data.values # Now you have a 2d array(list) of (x,y) points.\n\n# here is graph of our points.\ndata.plot(kind='scatter', x='Annual Income (k$)', y='Spending Score (1-100)')","9c9ee0b8":"def plot_points_by_centers(points, centers):\n    display.clear_output(wait=True)\n    plt.clf()\n    colors = ['magenta', 'blue', 'pink', 'black', 'green']\n    \n    label = \"Centeriods\"\n    for c in centers:\n        plt.scatter(c[0], c[1], color='red', label=label, marker = 'X', s=300)\n        label = \"_nolegend_\"\n\n    for p in points:\n        c = get_closest_centroids(p, centers)\n        i = centers.index(c)\n        plt.scatter(p[0], p[1], color=colors[i], alpha=1)\n\n        time.sleep(0.001)\n        \n    plt.xlabel('Annual Income (k$)')\n    plt.ylabel('Spending Score (1-100)')\n    plt.legend()\n    display.display(plt.gcf())\n    \ndef compute_residual_error(points, centers):\n    d_sum = 0\n    for p in points:\n        c = get_closest_centroids(p, centers)\n        d_sum += get_distance(c, p)\n        \n    return d_sum","122be058":"def get_distance(p1, p2):\n    '''\n    Get the eucleidan distance between 2 given points p1 and p2.\n    '''\n    \ndef get_closest_centroids(p, centroids):\n    '''\n    Given a point and a list of candidates points returns the closet candidate to the given points.\n    Distance is calculated using the euclidean distance.\n    \n    Example : point=[2, 1] candidates = [[3,2], [5,1], [2,2]] return value should be [2,2]\n    '''\n        \n\ndef get_random_points(k):\n    '''\n    Return a 2d array consisting of n random points.\n    Each x and y value of each point should be sampled from numbers between 0 and 100.\n    \n    Example : if k==2 a possible return value is : [[1,3], [24,50]] or [[62,15], [1, 0]]\n    '''\n\ndef compute_array_mean(arr):\n    '''\n    Compute the x and y mean of a 2d array of points\n    \n    Example : if arr=[[1, 4], [2, 6], [3, 8]] return value is : [2, 6]\n    '''","00331818":"def test_get_distance():\n    if (get_distance([0.,0.], [2.,0.]) != 2):\n        print(\"p1 = [0,0], p2 = [2,0] and distance is not 2\")\n        return False\n    \n    if (get_distance([0, 0], [3,4]) != 5):\n        print(\"p1 = [0,0], p2=[3,4] and distance is not 5\")\n        return False\n    \n    if (get_distance([0, 0], [6,8]) != 10):\n        print(\"p1 = [0,0], p2=[6,8] and distance is not 10\")\n        return False\n    return True\n        \nif test_get_distance():\n    print (\"Test get_distance Passed!\")\nelse:\n    print (\"Test get_distance Failed!\")\n","d93779ba":"def test_get_closest_centroids():\n    if get_closest_centroids([1,0], [[2,5], [3,0]]) != [3,0]:\n        print(\"p = [1,0], centroids = [[2,5], [3,0]], closest point is not [3,0]\")\n        return False\n    \n    if get_closest_centroids([2,1], [[3,2], [5,1], [2,2]]) != [2,2]:\n        print(\"p = [2,1], centroids = [[2,5], [3,0]], closest point is not [2,2]\")\n        return False\n    \n    if get_closest_centroids([1,4], [[2,5], [3,0]]) != [2,5]:\n        print(\"p = [1,4], centroids = [[2,5], [3,0]], closest point is not [2,5]\")\n        return False\n    \n    if get_closest_centroids([1,4], [[2,5], [3,0], [1,4], [5,5], [6,100]]) != [1,4]:\n        print(\"p = [1,4], centroids = [[2,5], [3,0], [1,4], [5,5], [6,100]], closest point is not [1,4]\")\n        return False\n    \n    return True\n\nif test_get_closest_centroids():\n    print (\"Test get_closest_centroids Passed!\")\nelse:\n    print (\"Test get_closest_centroids Failed!\")","e449f488":"def test_get_random_points():\n    rnd_points = get_random_points(1)\n    if len(rnd_points) != 1 or len(rnd_points[0]) != 2:\n        return False\n    \n    rnd_points = get_random_points(2)\n    if len(rnd_points) != 2 or len(rnd_points[0]) != 2:\n        return False\n    \n    rnd_points = get_random_points(3)\n    if len(rnd_points) != 3 or len(rnd_points[0]) != 2:\n        return False\n    \n    return True\n        \nif test_get_random_points():\n    print (\"Test get_random_points Passed!\")\nelse:\n    print (\"Test get_random_points Failed!\")","e708f38c":"def test_compute_array_mean():\n    if compute_array_mean([[1,2], [1,2], [1,2]]) != [1, 2]:\n        print(\"arr = [[1,2], [1,2], [1,2]] but mean in not [1,2]\")\n        return False\n    \n    if compute_array_mean([[1,2], [2,4], [3,6]]) != [2, 4]:\n        print(\"arr = [[1,2], [2,4], [1,6]] but mean in not [2, 4]\")\n        return False\n    \n    if compute_array_mean([[0,2], [0,5], [0,8]]) != [0, 5]:\n        print(\"arr = [[0,2], [0,5], [0,8]] but mean in not [1, 5]\")\n        return False\n    \n    if compute_array_mean([[1,2], [2,2.5], [3,3.5], [4,4]]) != [2.5, 3]:\n        print(\"arr = [[1,2], [2,2.5], [3,3.5], [4,4]] but mean in not [2.5, 4]\")\n        return False\n    return True\n\nif test_compute_array_mean():\n    print (\"Test compute_array_mean Passed!\")\nelse:\n    print (\"Test compute_array_mean Failed!\")","df36ce37":"import random\ndef k_means(points, k, t):\n    \"\"\"\n    K means algorithm\n    Given a set of points, k and t finds the best k centroids for clustering the points.\n    The algorithm runs for t iterations before coming to an halt.\n    \n    Returns the k best centroids(points) (those who minimize the overall distance.)\n    \"\"\"\n    # Start with setting random points as your centers\n    # --------------- Your Code Here -----------------\n    centroids = 0 # Replace 0 with the appropriate method call. \n    \n    # Iterate for t times and update your centroids.\n    for i in range(t):\n        # Create empty clusters using a dictionary.\n        clusters = {i:[] for i in range(k)}\n    \n        # Allocate each point to the closest centroid\n        # HINT : centroids.index method will give you the index of a specific centroid.\n        # --------------- Your Code Here ------------\n            \n        # This function will plot the points and the clusters.\n        plot_points_by_centers(points, centroids)\n\n        \n        # Compute the new means for each of the centroids\n        # --------------- Your Code Here -----------------\n\n    \n    # Leave this for plotting purposes.\n    display.clear_output(wait=True)\n    return centroids\n            \n    ","feec84ca":"centers_2 = k_means(points, 2, 20)\nr2 = compute_residual_error(points, centers_2)","a486f852":"centers_3 = k_means(points, 3, 20)\nr3 = compute_residual_error(points, centers_3)","0b4b8f6b":"centers_4 = k_means(points, 4, 20)\nr4 = compute_residual_error(points, centers_4)\n    ","770673ba":"centers_5 = k_means(points, 5, 20)\nr5 = compute_residual_error(points, centers_5)","377d850e":"plt.plot(range(2, 6), [r2, r3, r4, r5])\nplt.xlabel(\"K\")\nplt.ylabel(\"Residual Sum of Squares\")","d2b9013f":"### K-means with k=5","01515d44":"### K-means with k=3","0617cacf":"Next, we take the 2 relevant features for our clustering : **Annual Income** and __Spending Score__\n\n### Just run the following cell no code needed.","820416bb":"## K-means\nImplement the k-means algorithm in the next cell.<br>\nYou have the signature of the function.<br>\nIn class you talked about 2 stopping conditions:\n1. No change in cluster centers\n1. No change to cluster assignment.<br><br>\nFor simplicity reasons we are going to use a simpler stopping condition : <br>\nWe will run the algorithm for a fixed number of iterations. ","9373223b":"# Ex 1\n*You can hand in the assignment in pairs.*\nIn this exercise we will implement the k-means algorithm we learned in class.<br>\nWe are going to preform the k-menas clustering algorithm on the supplied Mall segementation dataset.\n\nDon't forget to run the cells.\n### Just run the following cell no code needed.","72c5cd2b":"### K-means - with k=2","62dbdead":"## Test Methods\nRun the following cells to test your functions. <br>\nYou don't need to implement anything, but if at any of the cells you run and get an error <br>\nthis means your implementation is not good.","1938c2a9":"# Auxiliry Function\nThis function is implemented for you and we will use it to plot the condition\nof the k-means algorithm through out it's iterations.\n\n### Just run the following cell no code needed.","a37034a9":"# Plot behaviour\nWe will now plot the sum of residual error to see how it decrease as k increases","2ed13546":"# Loading the data\nWe start off by loading the data into a pandas dataframe which we talked about in trecitation 2.<br>\nWe use the head command to peek into the data\n\n### Just run the following cell no code needed.","b8f41e09":"## Running the k-means algorithm and visualizing the results.\nRun the following cells and see if your implementation is good.<br>\nThis will give you a better intution of how the algorithm works.<br>\nNotice that on each cell we run the k_means algorithm and then save the residual error in a variable.<br>\nAt the end we will use this variables to visualize how the error decreases as k increases.","896446a1":"### K-means with k=4","36c5432c":"# End of Exercise\nTo submit the exercise, click *File* -> *Download Notebook*.<br>\nSubmit the downloaded file in the moodle under ex1.","0135d4f2":"## Helper functions\nYou first assignment is to implement the functions in the cell below, <br>\nThis will make implementing the k-menas algorithm much simpler."}}