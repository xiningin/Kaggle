{"cell_type":{"4af6f114":"code","4416499b":"code","d24a9819":"code","4887e973":"code","bac8830b":"code","ba255f67":"code","9a2242ec":"code","1601cb38":"code","626994bb":"code","3dee10c6":"code","0a03fe74":"code","029cd81f":"code","d3713040":"code","0e9f4e9c":"code","1ce561d9":"code","7cc42d94":"code","c1c2c326":"code","50e5e78b":"code","44b5be37":"code","13f4a38f":"code","33a8d6bf":"code","82d68f6d":"code","ee0453bf":"markdown","d7cb0e86":"markdown","cfc080fa":"markdown","fe538095":"markdown","f15c7c15":"markdown","250a8e62":"markdown","63ae292a":"markdown"},"source":{"4af6f114":"import ast\nimport numba\nimport string\n\nimport numpy as np\nimport pandas as pd\n\nfrom itertools import combinations, permutations, product\nfrom math import sqrt, factorial\nfrom sklearn.neighbors import KDTree\nfrom sympy import isprime, primerange\nfrom tqdm import tqdm_notebook","4416499b":"K = 5#!","d24a9819":"def frunkopt_func_generator(K):\n    K = K - 1 # Dont look like that, K-Opt means, \n              # that we will remove K links between 2K points \n              # p1 - p2, p3 - p4, ..., p2K-1 - p2K\n              # so we will get K-1 unmoved segments\n              # p2..p3, p4..p5, ..., p2K-2..p2K-1\n    letters = np.array(list(string.ascii_uppercase[:K]))\n    i = 0\n    tab = '    '\n    function_name = f'move_{K}opt'\n    function_strings = []\n    function_strings.append(\"@numba.jit('void(i8[:], i8[:], i8)', nopython=True, parallel=False)\")\n    function_strings.append(f\"def {function_name}(path, idx, move_type):\")\n    function_strings.append(\"{}pslice = slice(idx[0]+1, idx[-1]+1)\".format(tab))\n    function_strings.append(\"{}{} = {}\".format(tab, ', '.join(letters), ', '.join([f'path[idx[{t}]+1:idx[{t+1}]+1]' for t in np.arange(K)])))\n    function_strings.append(\"{}{} = {}\".format(tab, ', '.join(string.ascii_lowercase[:K]), '[::-1], '.join(letters) + '[::-1]'))\n    for p in permutations(np.arange(K)):\n        for r in product([0, 1], repeat=K):\n            out_arr = [letters[j].lower() if r[j] else letters[j] for j in p]\n            function_strings.append('{}{} move_type == {}:'.format(tab, 'elif' if i else 'if', i))\n            function_strings.append(\"{}path[pslice] = np.concatenate(({}))\".format(tab * 2, ', '.join(out_arr)))\n            i += 1\n    return function_name, \"\"\"{}\"\"\".format('\\n'.join(function_strings))","4887e973":"frunktion_name, frunktion_body = frunkopt_func_generator(K)","bac8830b":"%%time\nexec(compile(ast.parse(frunktion_body), '<string>', mode='exec'))","ba255f67":"frunkopt_move = locals()[frunktion_name]","9a2242ec":"cities = pd.read_csv(\n    '..\/input\/traveling-santa-2018-prime-paths\/cities.csv', \n    index_col=['CityId'])\n\nXY = np.stack(\n    (\n        cities.X.astype(np.float32), \n        cities.Y.astype(np.float32)\n    ), \n    axis=1)\n\nis_not_prime = np.array([0 if isprime(i) else 1 for i in cities.index], dtype=np.int32)","1601cb38":"@numba.jit('f8(i8, i8, i8)', nopython=True, parallel=False)\ndef cities_dist(id_from, id_to, offset):\n    xy_from, xy_to = XY[id_from], XY[id_to]\n    dx, dy = xy_from[0] - xy_to[0], xy_from[1] - xy_to[1]\n    distance = sqrt(dx * dx + dy * dy)\n    if offset % 10 == 9 and is_not_prime[id_from]:\n        return 1.1 * distance\n    return distance\n\n@numba.jit('f8(i8[:], i8)', nopython=True, parallel=False)\ndef chunk_score(chunk, offset):\n    pure_distance, penalty = 0.0, 0.0\n    penalty_modulo = 9 - offset % 10\n    for path_index in numba.prange(chunk.shape[0] - 1):\n        id_from, id_to = chunk[path_index], chunk[path_index+1]\n        xy_from, xy_to = XY[id_from], XY[id_to]\n        dx, dy = xy_from[0] - xy_to[0], xy_from[1] - xy_to[1]\n        distance = sqrt(dx * dx + dy * dy)\n        pure_distance += distance\n        if path_index % 10 == penalty_modulo and is_not_prime[id_from]:\n            penalty += distance\n    return pure_distance + 0.1 * penalty\n\n\n@numba.jit('f8(i8[:])', nopython=True, parallel=False)\ndef path_score(path):\n    return chunk_score(path, 0)\n\ndef path_score_full(path):\n    pure_distance, penalty = 0.0, 0.0\n    penalty_modulo = 9\n    for path_index in numba.prange(path.shape[0] - 1):\n        id_from, id_to = path[path_index], path[path_index + 1]\n        xy_from, xy_to = XY[id_from], XY[id_to]\n        dx, dy = xy_from[0] - xy_to[0], xy_from[1] - xy_to[1]\n        distance = sqrt(dx * dx + dy * dy)\n        pure_distance += distance\n        if path_index % 10 == penalty_modulo and is_not_prime[id_from]:\n            penalty += distance\n    return (\n        round(pure_distance, 4), \n        round(0.1 * penalty, 4), \n        round(pure_distance + 0.1 * penalty, 4)\n    )","626994bb":"N_NEIGHBORS = 2*K + 2\nRADIUS = 3*K + 3","3dee10c6":"kdt = KDTree(XY[1:])\nneighbors_N = kdt.query(XY[1:], N_NEIGHBORS, return_distance=False)[:, K:]\nneighbors_R = kdt.query_radius(XY[1:], RADIUS, count_only=False, return_distance=False)","0a03fe74":"neighbors = set()\n\nfor city_id in tqdm_notebook(cities.index[1:]):\n    for neib_triplet in combinations(neighbors_N[city_id - 1] + 1, K):\n        neighbors.add(tuple(sorted(neib_triplet)))\n        \n    for neib_triplet in combinations(neighbors_R[city_id - 1][:N_NEIGHBORS-K] + 1, K):\n        neighbors.add(tuple(sorted(neib_triplet)))\n    \nprint(f'{len(neighbors)} cities {K}-neighbors are selected.')","029cd81f":"@numba.jit('f8(i8[:])', nopython=True, parallel=False)\ndef sum_distance(ids):\n    res = 0\n    for i in numba.prange(len(ids)):\n        for j in numba.prange(i + 1, len(ids)):\n            res += cities_dist(ids[i], ids[j], 0)\n    return res","d3713040":"neighbors = np.array(list(neighbors))\ndistances = np.array(list(map(sum_distance, tqdm_notebook(neighbors))))\norder = distances.argsort()\nneighbors = neighbors[order]","0e9f4e9c":"initial_path = pd.read_csv('..\/input\/not-a-5-and-5-halves-opt-0efc12\/1515559.6779840707.csv').Path.values","1ce561d9":"path = initial_path.copy()\npath_index = np.argsort(path[:-1])\ninitial_score = total_score = path_score(path)\n\nprint(path_score_full(path))\nprint(f'Total score is {path_score(path):.2f}.')","7cc42d94":"frunkopt_moves_count = factorial(K - 1) * 2 ** (K - 1)\nprint(frunkopt_moves_count)","c1c2c326":"runs = 2\nneighbors_len = len(neighbors)\ncases_improved = np.zeros((runs, frunkopt_moves_count))","50e5e78b":"def make_submission(name, path):\n    pd.DataFrame({'Path': path}).to_csv(f'{name}.csv', index=False)","44b5be37":"for run in np.arange(1, runs + 1):\n    magic_number = 4223 * K * N_NEIGHBORS * RADIUS \/\/ run\n    print(f'Run #{run} | {magic_number}')\n    for step, ids in tqdm_notebook(enumerate(neighbors[:magic_number], 1), total=magic_number):\n        if step % 10 ** 6 == 0:\n            new_total_score = path_score(path)\n            last_improvement = total_score - new_total_score\n            print(f\"score {new_total_score:.2f} | last 10^6 {last_improvement:.2f} | total {initial_score - new_total_score:.2f}.\")\n            print(cases_improved[run - 1])\n            total_score = new_total_score\n            if last_improvement > K:\n                make_submission(f'frunkopt_{path_score(path):.4f}', path)\n\n        idx = sorted(path_index[ids])\n        new_idx = idx - idx[0]\n\n        pslice = slice(idx[0], idx[-1] + 2)\n        chunk = path[pslice]\n        best_score = chunk_score(chunk, idx[0])\n        best_move = -1\n        \n        for move_type in numba.prange(1, frunkopt_moves_count): # since move_type == 0 will not change chunk\n            new_chunk = chunk.copy()\n            frunkopt_move(new_chunk, new_idx, move_type)\n            new_score = chunk_score(new_chunk, idx[0])\n            if new_score < best_score:\n                best_score = new_score\n                best_move = move_type\n                best_chunk = new_chunk.copy()\n        \n        if best_move > -1:\n            path[pslice] = best_chunk\n            path_index = np.argsort(path[:-1])\n            cases_improved[run - 1, best_move] += 1","13f4a38f":"print(cases_improved)","33a8d6bf":"total_score = path_score(path)\nprint(f'Total improvement | {initial_score - total_score:.2f}')\nprint('Final scores |', path_score_full(path))","82d68f6d":"make_submission(f'final_frunkopt_{path_score(path):.4f}', path)","ee0453bf":"I'm going to share fully automated K-Optimization :D","d7cb0e86":"Since we get `frunktion_body`, we have to revive it. *abracadabra*","cfc080fa":"It's Alive!!!","fe538095":"Since we have `K - 1` tour's segments to manipulate, total number of legal moves is equal number of permutations `(K-1)!` multiplied by `2^(K-1)`, because each segment can be in 2 states: reversed or not.","f15c7c15":"That's all, good luck to all and happy kaggling!","250a8e62":"This is the main part of kernel. We will generate function for K-Opt move!","63ae292a":"Then you know what to do :)"}}