{"cell_type":{"4e77bac6":"code","8aa1e46f":"code","9e9e7eba":"code","a2519db8":"code","690290d9":"code","6f02fd85":"code","1acac8de":"code","425bac98":"code","1946ed05":"code","248e5321":"code","74141ad9":"code","234c13fa":"code","517ec0ad":"code","87bceea5":"code","3fa17159":"code","14377025":"code","3c5a677e":"code","92436291":"markdown","ceceefa8":"markdown","5ad2470d":"markdown","365238c3":"markdown","21802b07":"markdown","27ec7c73":"markdown","af3f87fe":"markdown","2eaf3188":"markdown","12191efc":"markdown","569b8d2f":"markdown"},"source":{"4e77bac6":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","8aa1e46f":"df_pokemon = pd.read_csv('..\/input\/pokemon.csv')\ndf_battles = pd.read_csv('..\/input\/battles.csv')\ndf_test = pd.read_csv('..\/input\/test.csv')\ndf_sub = pd.read_csv('..\/input\/sampleSubmission.csv')","9e9e7eba":"battles = df_battles \\\n    .merge(df_pokemon.rename(columns=lambda x: \"F%s\" % x) , left_on=\"First_pokemon\", right_on=\"F#\") \\\n    .merge(df_pokemon.rename(columns=lambda x: \"S%s\" % x) , left_on=\"Second_pokemon\", right_on=\"S#\") \\","a2519db8":"import matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set()\n\nsns.heatmap(battles.corr(), cmap=\"coolwarm\")\nbattles.corr()[\"Winner\"].sort_values()","690290d9":"df_pokemon_speed = df_pokemon[[\"#\", \"Speed\"]]\ndf_pokemon_speed.head()","6f02fd85":"battles = df_battles \\\n    .merge(df_pokemon_speed.rename(columns=lambda x: \"F%s\" % x) , left_on=\"First_pokemon\", right_on=\"F#\") \\\n    .merge(df_pokemon_speed.rename(columns=lambda x: \"S%s\" % x) , left_on=\"Second_pokemon\", right_on=\"S#\") \\\n    .drop([\"F#\", \"S#\", \"First_pokemon\", \"Second_pokemon\", \"battle_number\"], axis=1)\nbattles.head()","1acac8de":"from sklearn.model_selection import train_test_split\ntrain, validation = train_test_split(battles, test_size=0.2, random_state=42)","425bac98":"from sklearn import datasets\nfrom sklearn.naive_bayes import GaussianNB","1946ed05":"train_X = train[[\"FSpeed\", \"SSpeed\"]].values\ntrain_y = train[\"Winner\"].values\nval_X = validation[[\"FSpeed\", \"SSpeed\"]].values\nval_y = validation[\"Winner\"].values\n\n\ngnb = GaussianNB()\ngnb.fit(train_X, train_y)\n\ny_pred = gnb.predict(train_X)\nprint(\"accuracy = %.4f\" % ((train_y == y_pred).sum() \/ y_pred.shape[0]))\n\ny_pred = gnb.predict(val_X)\nprint(\"accuracy = %.4f\" % ((val_y == y_pred).sum() \/ y_pred.shape[0]))","248e5321":"battles = df_battles.assign(first_turn = 1 )\n\nbattles2 = pd.DataFrame({\n    \"idx\" : battles['battle_number'] + battles['battle_number'].max() + 1,\n    \"battle_number\" : battles['battle_number'] + battles['battle_number'].max() + 1,\n    \"First_pokemon\" : battles[\"Second_pokemon\"],\n    \"Second_pokemon\" : battles[\"First_pokemon\"],\n    \"Winner\": np.abs(battles[\"Winner\"] - 1),\n    \"first_turn\": -1\n}\n).set_index(\"idx\")\nbattles2.index.name = None\nbattles = pd.concat([battles, battles2])\n\nbattles.reset_index(drop=True)\nbattles.head()","74141ad9":"battles.tail()","234c13fa":"battles = battles \\\n    .merge(df_pokemon_speed.rename(columns=lambda x: \"F%s\" % x) , left_on=\"First_pokemon\", right_on=\"F#\") \\\n    .merge(df_pokemon_speed.rename(columns=lambda x: \"S%s\" % x) , left_on=\"Second_pokemon\", right_on=\"S#\") \\\n    .drop([\"F#\", \"S#\", \"First_pokemon\", \"Second_pokemon\", \"battle_number\"], axis=1)\n\ntrain, validation = train_test_split(battles, test_size=0.2, random_state=42)\ntrain_X = train[[\"FSpeed\", \"SSpeed\", \"first_turn\"]].values\ntrain_y = train[\"Winner\"].values\nval_X = validation[[\"FSpeed\", \"SSpeed\", \"first_turn\"]].values\nval_y = validation[\"Winner\"].values\n\n\ngnb = GaussianNB()\ngnb.fit(train_X, train_y)\n\ny_pred = gnb.predict(train_X)\nprint(\"accuracy = %.4f\" % ((train_y == y_pred).sum() \/ y_pred.shape[0]))\n\ny_pred = gnb.predict(val_X)\nprint(\"accuracy = %.4f\" % ((val_y == y_pred).sum() \/ y_pred.shape[0]))","517ec0ad":"battles[\"FSpeed2\"] = battles.FSpeed ** 2\nbattles[\"SSpeed2\"] = battles.SSpeed ** 2","87bceea5":"train, validation = train_test_split(battles, test_size=0.2, random_state=42)\ntrain_X = train[[\"FSpeed\", \"SSpeed\", \"first_turn\", \"FSpeed2\", \"SSpeed2\"]].values\ntrain_y = train[\"Winner\"].values\nval_X = validation[[\"FSpeed\", \"SSpeed\", \"first_turn\", \"FSpeed2\", \"SSpeed2\"]].values\nval_y = validation[\"Winner\"].values\n\ngnb = GaussianNB()\ngnb.fit(train_X, train_y)\n\n\ny_pred = gnb.predict(train_X)\nprint(\"accuracy = %.4f\" % ((train_y == y_pred).sum() \/ y_pred.shape[0]))\n\ny_pred = gnb.predict(val_X)\nprint(\"accuracy = %.4f\" % ((val_y == y_pred).sum() \/ y_pred.shape[0]))","3fa17159":"train_X = battles[[\"FSpeed\", \"SSpeed\", \"first_turn\", \"FSpeed2\", \"SSpeed2\"]].values\ntrain_y = battles[\"Winner\"].values\n\ngnb = GaussianNB()\ngnb.fit(train_X, train_y)\n\ntest = df_test.assign(first_turn = 1 ) \\\n    .merge(df_pokemon_speed.rename(columns=lambda x: \"F%s\" % x) , left_on=\"First_pokemon\", right_on=\"F#\") \\\n    .merge(df_pokemon_speed.rename(columns=lambda x: \"S%s\" % x) , left_on=\"Second_pokemon\", right_on=\"S#\") \\\n    .sort_values(\"battle_number\") \\\n    .reset_index(drop=True)\n\ntest[\"FSpeed2\"] = test.FSpeed ** 2\ntest[\"SSpeed2\"] = test.SSpeed ** 2\n\ntest_X = test[[\"FSpeed\", \"SSpeed\", \"first_turn\", \"FSpeed2\", \"SSpeed2\"]].values\ny_pred = gnb.predict(test_X)","14377025":"df_sub.Winner = y_pred\ndf_sub.head()","3c5a677e":"df_sub.to_csv(\"submission.csv\", index=False)","92436291":"Pues ya lo tenemos 91% de accuracy, pero... no nos vamos a conformar que esto es un kernel y asi solo queda soso, vamos a darle un poco de sobreingenieria y overfitting!","ceceefa8":"En este kernel vamos a ver como llegar a mas del 90% de accuracy solo utilizando una stat del pokemon **speed** y con un `fit` de menos de 1 segundo!","5ad2470d":"Feliz domingo!","365238c3":"y otro puntito mas!","21802b07":"Y asi es como emos llegado con una sola variable a un 93% de resultados en validacion, probemos ahora contra el de test a ver que nos dice kaggle:","27ec7c73":"## Adornando nuestras battles\nlo primero que vamos a hacer es sacarle un poco mas de jugo a nuestras batallas, duplicando el numero de batallas para entrenar. \u00bfcomo? \n\nPues muy sencillo, segun el dataset siempre ataca el primero, es decir A vs B es similar a B vs A pero con una peque\u00f1a ventaja para A. Y como introudcimos este concepto, pues a\u00f1adiremos una columna para indicar quien tiene la ventaja,\nes decir a\u00f1adiremos 1 para las batallas normales, y -1 para las batallas invertidas","af3f87fe":"pues ya tenemos un puntito mas! pero aun podemos seguir rascando algo mas. Porque si en la ecuacion mas famosa del mundo ${e = mc}^2$ la velocidad va al cuadrado, aqui porque no?","2eaf3188":"Como no todo van a ser redes neuronales y tiempos infintos mientras el modelo entrena, vamos a probar hoy con [naive_bayes](https:\/\/scikit-learn.org\/stable\/modules\/naive_bayes.html)","12191efc":"Antes de nada, porque speed?","569b8d2f":"como podemos ver tanto grafica como numericamente `FSpeed` y `SSpeed` son las variables mas correlacionadas con winner, con lo cual sera nuestra elegida para intentar predecir el mayor numero de batallas."}}