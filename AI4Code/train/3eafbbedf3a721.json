{"cell_type":{"86a74345":"code","e407c4a9":"code","e362736d":"markdown","c0fea9ca":"markdown","3ac9a7ee":"markdown","ce33e5d8":"markdown","adf9fa1c":"markdown"},"source":{"86a74345":"from ortools.linear_solver import pywraplp\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nNUMBER_DAYS = 100\nNUMBER_FAMILIES = 6000\ndata = pd.read_csv('\/kaggle\/input\/santa-2019-revenge-of-the-accountants\/family_data.csv')\nsubmission = pd.read_csv('\/kaggle\/input\/baseline\/submission.csv')\nassigned_days = submission['assigned_day'].values\ncolumns = data.columns[1:11]\nDESIRED = data[columns].values\nCOST_PER_FAMILY        = [0,50,50,100,200,200,300,300,400,500]\nCOST_PER_FAMILY_MEMBER = [0, 0, 9,  9,  9, 18, 18, 36, 36,235]\nN_PEOPLE = data['n_people'].values\n\ndef get_daily_occupancy(assigned_days):\n    daily_occupancy = np.zeros(100, int)\n    for fid, assigned_day in enumerate(assigned_days):\n        daily_occupancy[assigned_day-1] += N_PEOPLE[fid]\n    return daily_occupancy\n    \ndef cost_function(prediction):\n    N_DAYS = 100\n    MAX_OCCUPANCY = 300\n    MIN_OCCUPANCY = 125\n    penalty = 0\n    days = list(range(N_DAYS,0,-1))\n    tmp = pd.read_csv('\/kaggle\/input\/santa-2019-revenge-of-the-accountants\/family_data.csv', index_col='family_id')\n    family_size_dict = tmp[['n_people']].to_dict()['n_people']\n\n    cols = [f'choice_{i}' for i in range(10)]\n    choice_dict = tmp[cols].to_dict()\n\n    # We'll use this to count the number of people scheduled each day\n    daily_occupancy = {k:0 for k in days}\n    \n    # Looping over each family; d is the day for each family f\n    for f, d in enumerate(prediction):\n        # Using our lookup dictionaries to make simpler variable names\n        n = family_size_dict[f]\n        choice_0 = choice_dict['choice_0'][f]\n        choice_1 = choice_dict['choice_1'][f]\n        choice_2 = choice_dict['choice_2'][f]\n        choice_3 = choice_dict['choice_3'][f]\n        choice_4 = choice_dict['choice_4'][f]\n        choice_5 = choice_dict['choice_5'][f]\n        choice_6 = choice_dict['choice_6'][f]\n        choice_7 = choice_dict['choice_7'][f]\n        choice_8 = choice_dict['choice_8'][f]\n        choice_9 = choice_dict['choice_9'][f]\n\n        # add the family member count to the daily occupancy\n        daily_occupancy[d] += n\n\n        # Calculate the penalty for not getting top preference\n        if d == choice_0:\n            penalty += 0\n        elif d == choice_1:\n            penalty += 50\n        elif d == choice_2:\n            penalty += 50 + 9 * n\n        elif d == choice_3:\n            penalty += 100 + 9 * n\n        elif d == choice_4:\n            penalty += 200 + 9 * n\n        elif d == choice_5:\n            penalty += 200 + 18 * n\n        elif d == choice_6:\n            penalty += 300 + 18 * n\n        elif d == choice_7:\n            penalty += 300 + 36 * n\n        elif d == choice_8:\n            penalty += 400 + 36 * n\n        elif d == choice_9:\n            penalty += 500 + 36 * n + 199 * n\n        else:\n            penalty += 500 + 36 * n + 398 * n\n\n    # for each date, check total occupancy\n    #  (using soft constraints instead of hard constraints)\n    for _, v in daily_occupancy.items():\n        if v > MAX_OCCUPANCY or v < MIN_OCCUPANCY:\n            penalty += 100000000\n\n    # Calculate the accounting cost\n    # using the max function because the soft constraints might allow occupancy to dip below 125\n    accounting_costs = 0\n    # Loop over the rest of the days, keeping track of previous count\n    for j in range(1,6):\n        for day in days[0:]:\n            today_count = daily_occupancy[day]\n            diff = abs(daily_occupancy[day] - daily_occupancy[min(100, day+j)])\n            accounting_costs += max(0, (today_count-125.0) \/ 400.0 * today_count**(0.5 + diff \/ 50.0))\/j\/j\n\n    return penalty, accounting_costs, penalty + accounting_costs","e407c4a9":"from ortools.linear_solver import pywraplp\nMAX_BEST_CHOICE = 5\nNUM_SWAP = 3000\nNUM_SECONDS = 1800\nNUM_THREADS = 4\nfor _ in range(20):\n    solver = pywraplp.Solver('Optimization preference cost', pywraplp.Solver.CBC_MIXED_INTEGER_PROGRAMMING)\n    daily_occupancy = get_daily_occupancy(assigned_days).astype(float)\n    fids = np.random.choice(range(NUMBER_FAMILIES), NUM_SWAP, replace=False)\n    PCOSTM, B = {}, {}\n    for fid in range(NUMBER_FAMILIES):\n        if fid in fids:\n            for i in range(MAX_BEST_CHOICE):\n                PCOSTM[fid, DESIRED[fid][i]-1] = COST_PER_FAMILY[i] + N_PEOPLE[fid] * COST_PER_FAMILY_MEMBER[i]\n                B[     fid, DESIRED[fid][i]-1] = solver.BoolVar('')\n        else:\n            daily_occupancy[assigned_days[fid]-1] -= N_PEOPLE[fid]\n\n    solver.set_time_limit(NUM_SECONDS*NUM_THREADS*1000)\n    solver.SetNumThreads(NUM_THREADS)\n\n    for day in range(NUMBER_DAYS):\n        if daily_occupancy[day]:\n            solver.Add(solver.Sum([N_PEOPLE[fid] * B[fid, day] for fid in range(NUMBER_FAMILIES) if (fid,day) in B]) == daily_occupancy[day])\n        \n    for fid in fids:\n        solver.Add(solver.Sum(B[fid, day] for day in range(NUMBER_DAYS) if (fid, day) in B) == 1)\n\n    solver.Minimize(solver.Sum(PCOSTM[fid, day] * B[fid, day] for fid, day in B))\n    sol = solver.Solve()\n    \n    status = ['OPTIMAL', 'FEASIBLE', 'INFEASIBLE', 'UNBOUNDED', 'ABNORMAL', 'MODEL_INVALID', 'NOT_SOLVED']\n    if status[sol] in ['OPTIMAL', 'FEASIBLE']:\n        tmp = assigned_days.copy()\n        for fid, day in B:\n            if B[fid, day].solution_value() > 0.5:\n                tmp[fid] = day+1\n        if cost_function(tmp)[2] < cost_function(assigned_days)[2]:\n            assigned_days = tmp\n            submission['assigned_day'] = assigned_days\n            submission.to_csv('submission.csv', index=False)\n        print('Result:', status[sol], cost_function(tmp))\n    else:\n        print('Result:', status[sol])","e362736d":"In this kernel, we will optimize **only preference cost** in submission file from [C++ Stochastic Product Search](https:\/\/www.kaggle.com\/golubev\/baseline)\n\nMIP(Mix Integer Programming) it's a great decision for the current task.\n\nWe will use not commercial library ortools from google. It's not fast like commercial libraries, but still very fast.\n\nIf use all variables(6000*100) it would take a lot of time.\n\nWe setup ***MAX_BEST_CHOICE = 5*** and ***NUM_SWAP = 3000***, how result we get 5*3000 variables and it is enough for get some result in resonable time:","c0fea9ca":"## Let's try my Santa2019 kernels:\n* https:\/\/www.kaggle.com\/golubev\/baseline\n* https:\/\/www.kaggle.com\/golubev\/mip-optimization-preference-cost\n* https:\/\/www.kaggle.com\/golubev\/c-stochastic-product-search-65ns\n* https:\/\/www.kaggle.com\/golubev\/manual-to-improve-submissions","3ac9a7ee":"## Only profit:\n* We improved preference cost!\n* And at least we didn't pay more accounting costs because we didn't change the daily occupation! ","ce33e5d8":"### Please upvote kernel if you like my work!","adf9fa1c":"\n### Merry Christmas and Happy New Year!"}}