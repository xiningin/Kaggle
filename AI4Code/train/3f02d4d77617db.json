{"cell_type":{"82e5eb71":"code","37a010e2":"code","4be39ace":"code","91e736fa":"code","53ee55f4":"code","6c738633":"code","bbbcbb39":"code","f9be0542":"code","6e79c1a2":"code","e13eca2a":"code","dd1bddc5":"code","d434e44a":"code","8c2795ae":"code","ec575aa4":"code","2bceafc4":"code","c826710d":"code","28cab4cf":"code","d36a5db6":"code","b4b6d0b0":"code","15091705":"code","acaedfbe":"code","15a12761":"code","5bd33ef2":"code","224cdb82":"markdown","262f0bf7":"markdown","be9be746":"markdown","32e422ce":"markdown","9ab10869":"markdown","68d34d8b":"markdown","1504ad05":"markdown","4361f865":"markdown","efe9c17f":"markdown","9857c817":"markdown","758ec4eb":"markdown","02fac71e":"markdown"},"source":{"82e5eb71":"%matplotlib inline\nimport sys\nimport math\nimport requests\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nfrom ipywidgets import interact\nfrom datetime import datetime\nfrom IPython.display import HTML\nimport plotly.express as px\nimport plotly.graph_objects as go","37a010e2":"states_url = \"https:\/\/covidtracking.com\/api\/states\/daily\"\ncase_threshold = 100 # TODO I don't want to drop states below 100\n\nr = requests.get(states_url)\nstates_df = pd.DataFrame(r.json())\nstates_df['date'] = pd.to_datetime(states_df.date, format=\"%Y%m%d\")\nstates_df = states_df[['date', 'state', 'positive']].sort_values('date')\nstates_df = states_df.rename(columns={'positive': 'confirmed'})\ncols = {}\nfor state in states_df.state.unique():\n    cases = states_df[(states_df.state == state) & (states_df.confirmed > case_threshold)]\n    cases = cases.reset_index().confirmed.reset_index(drop=True)\n    if len(cases) > 1:\n        cols[state] = cases\n\ndf = states_df.reset_index()\n","4be39ace":"df = (df.assign(daily_new=df.groupby('state', as_index=False)[['confirmed']]\n                            .diff().fillna(0)\n                            .reset_index(0, drop=True)))","91e736fa":"df = (df.assign(avg_daily_new=df.groupby('state', as_index=False)[['daily_new']]\n                                .rolling(7).mean()\n                                .reset_index(0, drop=True)))","53ee55f4":"state_names = {\n    \"AL\": \"Alabama\",\n    \"AK\": \"Alaska\",\n    \"AS\": \"American Samoa\",\n    \"AZ\": \"Arizona\",\n    \"AR\": \"Arkansas\",\n    \"CA\": \"California\",\n    \"CO\": \"Colorado\",\n    \"CT\": \"Connecticut\",\n    \"DE\": \"Delaware\",\n    \"DC\": \"District Of Columbia\",\n    \"FM\": \"Federated States Of Micronesia\",\n    \"FL\": \"Florida\",\n    \"GA\": \"Georgia\",\n    \"GU\": \"Guam\",\n    \"HI\": \"Hawaii\",\n    \"ID\": \"Idaho\",\n    \"IL\": \"Illinois\",\n    \"IN\": \"Indiana\",\n    \"IA\": \"Iowa\",\n    \"KS\": \"Kansas\",\n    \"KY\": \"Kentucky\",\n    \"LA\": \"Louisiana\",\n    \"ME\": \"Maine\",\n    \"MH\": \"Marshall Islands\",\n    \"MD\": \"Maryland\",\n    \"MA\": \"Massachusetts\",\n    \"MI\": \"Michigan\",\n    \"MN\": \"Minnesota\",\n    \"MS\": \"Mississippi\",\n    \"MO\": \"Missouri\",\n    \"MT\": \"Montana\",\n    \"NE\": \"Nebraska\",\n    \"NV\": \"Nevada\",\n    \"NH\": \"New Hampshire\",\n    \"NJ\": \"New Jersey\",\n    \"NM\": \"New Mexico\",\n    \"NY\": \"New York\",\n    \"NC\": \"North Carolina\",\n    \"ND\": \"North Dakota\",\n    \"MP\": \"Northern Mariana Islands\",\n    \"OH\": \"Ohio\",\n    \"OK\": \"Oklahoma\",\n    \"OR\": \"Oregon\",\n    \"PW\": \"Palau\",\n    \"PA\": \"Pennsylvania\",\n    \"PR\": \"Puerto Rico\",\n    \"RI\": \"Rhode Island\",\n    \"SC\": \"South Carolina\",\n    \"SD\": \"South Dakota\",\n    \"TN\": \"Tennessee\",\n    \"TX\": \"Texas\",\n    \"UT\": \"Utah\",\n    \"VT\": \"Vermont\",\n    \"VI\": \"Virgin Islands\",\n    \"VA\": \"Virginia\",\n    \"WA\": \"Washington\",\n    \"WV\": \"West Virginia\",\n    \"WI\": \"Wisconsin\",\n    \"WY\": \"Wyoming\"\n}","6c738633":"df['day'] = df.date.apply(lambda x: x.date()).apply(str)\ndf = df.sort_values(by='day')\ndfc = df[df.avg_daily_new > 0]","bbbcbb39":"days = dfc.day.unique().tolist()\nstates = dfc.state.unique().tolist()\nstates.sort()","f9be0542":"fig_dict = {\n    \"data\": [],\n    \"layout\": {},\n    \"frames\": []\n}\n\n# fill in most of layout\nfig_dict[\"layout\"][\"height\"] = 700\nfig_dict[\"layout\"][\"width\"] = 900\nfig_dict[\"layout\"][\"xaxis\"] = {\"range\": [np.log10(5), np.log10(dfc['confirmed'].max() + 5000)], \"title\": \"Total Confirmed Cases (log scale)\", \"type\": \"log\"}\nfig_dict[\"layout\"][\"yaxis\"] = {\"range\": [np.log10(1), np.log10(dfc['avg_daily_new'].max() + 500)], \"title\": \"Average Daily New Cases (log scale)\", \"type\": \"log\"}\nfig_dict[\"layout\"][\"hovermode\"] = \"closest\"\nfig_dict[\"layout\"][\"sliders\"] = {\n    \"args\": [\n        \"transition\", {\n            \"duration\": 100,\n            \"easing\": \"cubic-in-out\"\n        }\n    ],\n    \"initialValue\": min(days),\n    \"plotlycommand\": \"animate\",\n    \"values\": days,\n    \"visible\": True\n}\n\n# buttons\nfig_dict[\"layout\"][\"updatemenus\"] = [\n    {\n        \"buttons\": [\n            {\n                \"args\": [None, {\"frame\": {\"duration\": 300, \"redraw\": True},\n                                \"fromcurrent\": True, \"transition\": {\"duration\": 300,\n                                                                    \"easing\": \"linear\"}}],\n                \"label\": \"Play\",\n                \"method\": \"animate\"\n            },\n            {\n                \"args\": [[None], {\"frame\": {\"duration\": 0, \"redraw\": False},\n                                  \"mode\": \"immediate\",\n                                  \"transition\": {\"duration\": 0}}],\n                \"label\": \"Pause\",\n                \"method\": \"animate\"\n            }\n        ],\n        \"direction\": \"left\",\n        \"pad\": {\"r\": 10, \"t\": 87},\n        \"showactive\": False,\n        \"type\": \"buttons\",\n        \"x\": 0.05,\n        \"xanchor\": \"right\",\n        \"y\": 0.05,\n        \"yanchor\": \"top\"\n    }\n]\n\n# sliders\nsliders_dict = {\n    \"active\": len(days)-1,\n    \"yanchor\": \"top\",\n    \"xanchor\": \"left\",\n    \"currentvalue\": {\n        \"font\": {\"size\": 20},\n#         \"prefix\": \"Date: \",\n        \"visible\": True,\n        \"xanchor\": \"right\"\n    },\n    \"transition\": {\"duration\": 100},\n    \"pad\": {\"b\": 10, \"t\": 50},\n    \"len\": 0.9,\n    \"x\": 0.1,\n    \"y\": 0,\n    \"steps\": []\n}","6e79c1a2":"day = max(days)\nfor state in states:\n    dataset_by_day = dfc[dfc[\"day\"] <= day]\n    dataset_by_day_and_state = dataset_by_day[ dataset_by_day[\"state\"]==state ]\n    \n    data_dict = {\n        \"x\": list(dataset_by_day_and_state[\"confirmed\"]),\n        \"y\": list(dataset_by_day_and_state[\"avg_daily_new\"]),\n        \"mode\": \"lines\",\n        \"text\": dataset_by_day_and_state[['confirmed', 'avg_daily_new']],\n        \"name\": state,\n        'hoverlabel': {'namelength': 0},\n        'hovertemplate': '<b>%{hovertext}<\/b><br>Confirmed: %{x:,d}<br>Average Daily: %{y:,.2f}',\n        'hovertext': dataset_by_day_and_state['state'].apply(lambda s: state_names.get(s, '??') + f' ({s})')\n    }\n    fig_dict[\"data\"].append(data_dict)\n\n# make frames\nfor day in days:\n    frame = {\"data\": [], \"name\": day}\n    for state in states:\n        dataset_by_day = dfc[dfc[\"day\"] <= day]\n        dataset_by_day_and_state = dataset_by_day[\n            dataset_by_day[\"state\"] == state]\n\n        data_dict = {\n            \"x\": list(dataset_by_day_and_state[\"confirmed\"]),\n            \"y\": list(dataset_by_day_and_state[\"avg_daily_new\"]),\n            \"mode\": \"lines\",\n            \"text\": dataset_by_day_and_state[['confirmed', 'avg_daily_new']],\n            \"name\": state\n        }\n        frame[\"data\"].append(data_dict)\n\n    fig_dict[\"frames\"].append(frame)\n    slider_step = {\"args\": [\n        [day],\n        {\"frame\": {\"duration\": 100, \"redraw\": True},\n         \"mode\": \"immediate\",\n         \"transition\": {\"duration\": 100, 'easing': 'linear'}}\n    ],\n        \"label\": day,\n        \"method\": \"animate\"}\n    sliders_dict[\"steps\"].append(slider_step)","e13eca2a":"fig_dict[\"layout\"][\"sliders\"] = [sliders_dict]\nfig = go.Figure(fig_dict)","dd1bddc5":"africa_names = [\n    'Algeria',\n    'Angola',\n    'Benin',\n    'Botswana',\n    'Burkina Faso',\n    'Burundi',\n    'Cabo Verde',\n    'Cameroon',\n    'Central African Republic',\n    'Chad',\n    'Congo (Brazzaville)',\n    'Congo (Kinshasa)',\n    'Djibouti',\n    'Egypt',\n    'Equatorial Guinea',\n    'Eritrea',\n    'Eswatini',\n    'Ethiopia',\n    'Gabon',\n    'Gambia',\n    'Ghana',\n    'Guinea',\n    'Guinea-Bissau',\n    'Ivory Coast',\n    'Kenya',\n    'Liberia',\n    'Libya',\n    'Madagascar',\n    'Malawi',\n    'Mali',\n    'Mauritania',\n    'Mauritius',\n    'Morocco',\n    'Mozambique',\n    'Namibia',\n    'Niger',\n    'Nigeria',\n    'Rwanda',\n    'Sao Tome and Principe',\n    'Senegal',\n    'Seychelles',\n    'Sierra Leone',\n    'Somalia',\n    'South Africa',\n    'South Sudan',\n    'Sudan',\n    'Tanzania',\n    'Togo',\n    'Tunisia',\n    'Uganda',\n    'Western Sahara',\n    'Zambia',\n    'Zimbabwe'\n]","d434e44a":"america_names = [\n    'Antigua and Barbuda',\n    'Argentina',\n    'Bahamas',\n    'Barbados',\n    'Belize',\n    'Bolivia',\n    'Brazil',\n    'Canada',\n    'Chile',\n    'Colombia',\n    'Costa Rica',\n    'Cuba',\n    'Dominica',\n    'Dominican Republic',\n    'Ecuador',\n    'El Salvador',\n    'Grenada',\n    'Guatemala',\n    'Guyana',\n    'Haiti',\n    'Honduras',\n    'Jamaica',\n    'Mexico',\n    'Nicaragua',\n    'Panama',\n    'Paraguay',\n    'Peru',\n    'Saint Kitts and Nevis',\n    'Saint Lucia',\n    'Saint Vincent and the Grenadines',\n    'Suriname',\n    'Trinidad and Tobago',\n    'United States of America',\n    'Uruguay',\n    'Venezuela'\n]","8c2795ae":"\nasiapacific_names = [\n    'Afghanistan',\n    'Armenia',\n    'Australia',\n    'Azerbaijan',\n    'Bahrain',\n    'Bangladesh',\n    'Bhutan',\n    'Brunei',\n    'Cambodia',\n    'China',\n    'Cyprus',\n    'East Timor',\n    'Fiji',\n    'Georgia',\n    'Hong Kong',\n    'India',\n    'Indonesia',\n    'Iran',\n    'Iraq',\n    'Israel',\n    'Japan',\n    'Jordan',\n    'Kazakhstan',\n    'Kuwait',\n    'Kyrgyzstan',\n    'Laos',\n    'Lebanon',\n    'Malaysia',\n    'Maldives',\n    'Mongolia',\n    'Myanmar',\n    'Nepal',\n    'New Zealand',\n    'Oman',\n    'Pakistan',\n    'Papua New Guinea',\n    'Philippines',\n    'Qatar',\n    'Russia',\n    'Saudi Arabia',\n    'Singapore',\n    'South Korea',\n    'Sri Lanka',\n    'Syria',\n    'Taiwan',\n    'Thailand',\n    'Turkey',\n    'United Arab Emirates',\n    'Uzbekistan',\n    'Vietnam',\n    'West Bank and Gaza'\n]","ec575aa4":"\neurope_names = [\n    'Albania',\n    'Andorra',\n    'Armenia',\n    'Austria',\n    'Azerbaijan',\n    'Belarus',\n    'Belgium',\n    'Bosnia Herzegovina',\n    'Bulgaria',\n    'Croatia',\n    'Cyprus',\n    'Czechia',\n    'Denmark',\n    'Estonia',\n    'Finland',\n    'France',\n    'Georgia',\n    'Germany',\n    'Greece',\n    'Hungary',\n    'Iceland',\n    'Ireland',\n    'Italy',\n    'Kazakhstan',\n    'Kosovo',\n    'Latvia',\n    'Liechtenstein',\n    'Lithuania',\n    'Luxembourg',\n    'Malta',\n    'Moldova',\n    'Monaco',\n    'Montenegro',\n    'Netherlands',\n    'North Macedonia',\n    'Norway',\n    'Poland',\n    'Portugal',\n    'Romania',\n    'Russia',\n    'San Marino',\n    'Serbia',\n    'Slovakia',\n    'Slovenia',\n    'Spain',\n    'Sweden',\n    'Switzerland',\n    'Turkey',\n    'Ukraine',\n    'United Kingdom',\n    'Vatican City'\n]","2bceafc4":"import pandas as pd\nimport numpy as np\n\ndef load_individual_timeseries(name):\n    base_url='https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series'\n    url = f'{base_url}\/time_series_covid19_{name}_global.csv'\n    df = pd.read_csv(url, \n                     index_col=['Country\/Region', 'Province\/State', 'Lat', 'Long'])\n    df['type'] = name.lower()\n    df.columns.name = 'date'\n    \n    df = (df.set_index('type', append=True)\n            .reset_index(['Lat', 'Long'], drop=True)\n            .stack()\n            .reset_index()\n            .set_index('date')\n         )\n    df.index = pd.to_datetime(df.index)\n    df.columns = ['country', 'state', 'type', 'cases']\n    \n    # Move HK to country level\n    df.loc[df.state =='Hong Kong', 'country'] = 'Hong Kong'\n    df.loc[df.state =='Hong Kong', 'state'] = np.nan\n    \n    # Aggregate large countries split by states\n    df = pd.concat([df, \n                    (df.loc[~df.state.isna()]\n                     .groupby(['country', 'date', 'type'])\n                     .sum()\n                     .rename(index=lambda x: x+' (total)', level=0)\n                     .reset_index(level=['country', 'type']))\n                   ])\n    return df\n\ndef load_data(drop_states=False, p_crit=.05, filter_n_days_100=None):\n    df = load_individual_timeseries('confirmed')\n    df = df.rename(columns={'cases': 'confirmed'})\n    if drop_states:\n        # Drop states for simplicity\n        df = df.loc[df.state.isnull()]\n        \n    # Estimated critical cases\n    df = df.assign(critical_estimate=df.confirmed*p_crit)\n\n    # Compute days relative to when 100 confirmed cases was crossed\n    df.loc[:, 'days_since_100'] = np.nan\n    for country in df.country.unique():\n        if not df.loc[(df.country == country), 'state'].isnull().all():\n            for state in df.loc[(df.country == country), 'state'].unique():\n                df.loc[(df.country == country) & (df.state == state), 'days_since_100'] = \\\n                    np.arange(-len(df.loc[(df.country == country) & (df.state == state) & (df.confirmed < 100)]), \n                              len(df.loc[(df.country == country) & (df.state == state) & (df.confirmed >= 100)]))\n        else:\n            df.loc[(df.country == country), 'days_since_100'] = \\\n                np.arange(-len(df.loc[(df.country == country) & (df.confirmed < 100)]), \n                          len(df.loc[(df.country == country) & (df.confirmed >= 100)]))\n\n    # Add recovered cases\n#     df_recovered = load_individual_timeseries('Recovered')\n#     df_r = df_recovered.set_index(['country', 'state'], append=True)[['cases']]\n#     df_r.columns = ['recovered']\n\n    # Add deaths\n    df_deaths = load_individual_timeseries('deaths')\n    df_d = df_deaths.set_index(['country', 'state'], append=True)[['cases']]\n    df_d.columns = ['deaths']\n\n    df = (df.set_index(['country', 'state'], append=True)\n#             .join(df_r)\n            .join(df_d)\n            .reset_index(['country', 'state'])\n    )\n    \n    if filter_n_days_100 is not None:\n        # Select countries for which we have at least some information\n        countries = pd.Series(df.loc[df.days_since_100 >= filter_n_days_100].country.unique())\n        df = df.loc[lambda x: x.country.isin(countries)]\n\n    return df","c826710d":"df = load_individual_timeseries('confirmed')\ndf = df[~df['country'].str.contains(' \\(total\\)')].drop(['state', 'type'], axis=1).reset_index()\n\n# clean data\ndf['country'] = df['country'].replace({'Bosnia and Herzegovina':'Bosnia Herzegovina'      })\ndf['country'] = df['country'].replace({'Timor-Leste'           :'East Timor'              })\ndf['country'] = df['country'].replace({\"Cote d'Ivoire\"         :'Ivory Coast'             })\ndf['country'] = df['country'].replace({'Burma'                 :'Myanmar'                 })\ndf['country'] = df['country'].replace({'Korea, South'          :'South Korea'             })\ndf['country'] = df['country'].replace({'Taiwan*'               :'Taiwan'                  })\ndf['country'] = df['country'].replace({'US'                    :'United States of America'})\ndf['country'] = df['country'].replace({'Holy See'              :'Vatican City'            })\n\n# append usa-by-states data\ndfc['country'] = dfc['state'].map(state_names)\ndf = (df.rename(columns={'cases': 'confirmed'})\n        .append(dfc.drop(['index', 'state', 'daily_new', 'avg_daily_new', 'day'], axis=1)\n                   .astype({'confirmed': 'int64'})))\n\n# aggregate data\ndf = (df.sort_values(by=['country', 'date'])\n        .groupby(['country', 'date'])['confirmed']\n        .agg(sum)).reset_index()\n\n# additional measurements\ndf = df.assign(daily_new_abs=(df.groupby('country', as_index=False)[['confirmed']]\n                                .diff()\n                                .fillna(0)\n                                .astype('int64')))\ndf = df.assign(daily_new_avg=(df.groupby('country', as_index=False)[['daily_new_abs']]\n                                .rolling(7)\n                                .mean()\n                                .fillna(0)\n                                .round(decimals=2)\n                                .reset_index(drop=True)))\n\n# slice data\ndf_usa         = df[(df.confirmed > case_threshold) & (df.daily_new_avg > 0) & (df['country'].isin(state_names.values()))]\ndf_africa      = df[(df.confirmed > case_threshold) & (df.daily_new_avg > 0) & (df['country'].isin(africa_names        ))]\ndf_america     = df[(df.confirmed > case_threshold) & (df.daily_new_avg > 0) & (df['country'].isin(america_names       ))]\ndf_asiapacific = df[(df.confirmed > case_threshold) & (df.daily_new_avg > 0) & (df['country'].isin(asiapacific_names   ))]\ndf_europe      = df[(df.confirmed > case_threshold) & (df.daily_new_avg > 0) & (df['country'].isin(europe_names        ))]\n\ndf.to_csv('data.csv')","28cab4cf":"#hide\nimport altair as alt\n\ndef make_chart(data=df):\n\n    countries = data.country.unique().tolist()\n\n    highlighted = data.sort_values('confirmed', ascending=False).groupby('country').head(1).country.tolist()[:5]\n\n    selection = alt.selection_multi(bind='legend',\n                                    fields=['country'],\n                                    init=[{'country': x} for x in highlighted])\n\n    base = (alt.Chart(data=data)\n               .properties(width=550)\n               .encode(x=alt.X(scale=alt.Scale(type='log'),\n                               shorthand='confirmed:Q',\n                               title='Total Confirmed Cases (log scale)'),\n                       y=alt.Y(scale=alt.Scale(type='log'),\n                               shorthand='daily_new_avg:Q',\n                               title='Average Daily New Cases (log scale)'),\n                       color=alt.Color(legend=alt.Legend(columns=3,\n                                                         symbolLimit=len(countries),\n                                                         title='Country\/State:'),\n                                       scale=alt.Scale(scheme='category20b'),\n                                       shorthand='country:N'),\n                       tooltip=list(data),\n                       opacity=alt.condition(selection, alt.value(1), alt.value(0.05))))\n\n    chart = (base.mark_line()\n                 .add_selection(selection)\n                 .configure_legend(labelFontSize=10,\n                                   titleFontSize=12)\n                 .configure_axis(labelFontSize=10,\n                                 titleFontSize=12))\n\n    return chart","d36a5db6":"#hide_input\nmake_chart(df_usa)","b4b6d0b0":"#hide_input\nmake_chart(df_africa)","15091705":"#hide_input\nmake_chart(df_america)","acaedfbe":"#hide_input\nmake_chart(df_asiapacific)","15a12761":"#hide_input\nmake_chart(df_europe)","5bd33ef2":"#hide\nfig.show()","224cdb82":"# South and North America","262f0bf7":"# Where is the curve flattening?\n\nInflection-sensitive chart for detecting successful interventions, from the article \"How To Tell If We're Beating COVID-19\".\n","be9be746":"## Caveats\n\n1. The logarithmic scales can make it seem as if states are closer together than they actually are. For example, at time of writing (April 5th) New York (the leader in US cases) and New Jersey (the runner-up) look as though it's a close race, but New York has over three times as any cases as New Jersey.\n2. The logarithmic scale can also obscure a resurgence of infections after a significant downturn, since the trace won't move much to the right during a short period late in time.\n3. Time is represented by the animation, not by the x-axis, which is unusual for most charts made about COVID-19. This is the plot's main advantage, because it aligns states onto _roughly_ the same trajectory regardless of population or testing rate, but it may be unexpected.\n4. The true number of cases is unknown, so the actual slope of the log-log change plot is unknown. All states are also increasing their testing rate over time, so these data may imply that the infection rate is increasing faster than it actually is.\n5. The data these plots rely on are incomplete, and come in less smoothly than they may imply. Healthcare systems around the world collect and report data when they can.\n6. This chart plots the logarithm of the sliding window average of the daily growth rate on the y-axis, not the raw daily growth rate, because there's too much variability day-to-day to visually detect the trend. This also makes the plot a pessimistic estimate of where each state is on its trajectory.","32e422ce":"## Appendix USA - Animated visualization of growth\n","9ab10869":"## Explanation\n\nThe exponential growth stage of a pandemic must end sometime, either as the virus runs out of people to infect, or as societies get it under control. However, it can be difficult to tell exactly when exponential growth is ending, for several reasons:\n\n* Humans aren't wired to understand exponentials at a glance.\n* It can be difficult to compare regions with differing first-infection dates, testing rates, and populations.\n* The news tends to report individual data points, without the contextual information necessary to interpret it.\n* If the plot doesn't explicitly plot the rate of new cases, a change must be quite dramatic before it becomes distinguishable.\n\nThis visualization plots the (sliding average of) daily new cases against the total cases, for each US state (with other countries and regions to come). This has the advantage of aligning all of them onto a baseline trajectory of exponential growth, with a very clear downward plummet when a given state gets the virus under control. As explained in the caveats below, this visualization has a very specific purpose: to make it clear whether a given state has managed to exit the exponential trajectory or not.\n\n_minutephysics_ has an excellent video on this visualization type, [How To Tell If We're Beating COVID-19](https:\/\/youtu.be\/54XLXg4fYsc).","68d34d8b":"**Note: This work is highly inspired from few other kaggle kernels , github sources and other data science resources. Any traces of replications, which may appear , is purely co-incidental. Due respect & credit to all my fellow kagglers.**","1504ad05":"#  United States of America","4361f865":"# Europe","efe9c17f":"The animated visualization for the US and the descriptions were made by Daniel Cox, with thanks to Henry of minutephysics for How To Tell If We're Beating COVID-19, and covidtracking.com for US data.\n\n**Code Referance & courtesy & Credit : Daniel Cox, Martin Boehler**\n\n\nThe static visualizations for the US, Africa, America, Asia-Pacific and Europe were made by Martin Boehler, with thanks to Daniel Cox for this great inspiration and implementation, and Johns Hopkins University CSSE for the 2019 Novel Coronavirus COVID-19 (2019-nCoV) Data Repository.","9857c817":"States\/countries will drift off the diagonal when they are flattening the curve.\n\nOnly entries with at least 100 confirmed cases are considered.\n\nThe top 5 entries are initially highlighted.","758ec4eb":"# Africa","02fac71e":"# Asia-Pacific"}}