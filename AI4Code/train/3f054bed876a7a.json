{"cell_type":{"4ba7b69c":"code","131ab508":"code","dfec581e":"code","9813cf68":"code","26859f3c":"code","e81528ad":"code","42d64e64":"code","a2d29885":"markdown","4b6478c4":"markdown","2824636b":"markdown","6efe142f":"markdown","d52c7c2d":"markdown"},"source":{"4ba7b69c":"from pandas import read_csv\nimport math\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.optimizers import SGD\nfrom sklearn.preprocessing import LabelEncoder\nfrom keras.callbacks import LearningRateScheduler\nimport matplotlib.pyplot as plt","131ab508":"path = \"..\/input\/ionosphere\/ionosphere.csv\"\ndataframe = read_csv(path, header=None)\ndataset = dataframe.values\n\nX = dataset[:,0:34].astype(float)\nY = dataset[:,34]\n\nencoder = LabelEncoder()\nencoder.fit(Y)\nY = encoder.transform(Y)","dfec581e":"model = Sequential()\nmodel.add(Dense(34, input_dim=34, activation='relu'))\nmodel.add(Dense(1, activation='sigmoid'))\n\nsgd = SGD(lr=0.0, momentum=0.9)\nmodel.compile(loss='binary_crossentropy', optimizer=sgd, metrics=['accuracy'])","9813cf68":"def step_decay(epoch):\n\tinitial_lrate = 0.1\n\tdrop = 0.5\n\tepochs_drop = 10.0\n\tlrate = initial_lrate * math.pow(drop, math.floor((1+epoch)\/epochs_drop))\n\treturn lrate","26859f3c":"lrate = LearningRateScheduler(step_decay)\ncallbacks_list = [lrate]\n\nhistory = model.fit(X, Y, validation_split=0.33, epochs=20, \n                    batch_size=8, callbacks=callbacks_list, verbose=0)","e81528ad":"plt.title(\"Loss over epoch\")\nplt.plot(history.history['loss'])","42d64e64":"plt.title(\"Accuracy over epoch\")\nplt.plot(history.history['accuracy'])","a2d29885":"# Model","4b6478c4":"# Dataset","2824636b":"# Analyze","6efe142f":"# Ionosphere - Learning Rate Schedules","d52c7c2d":"# Learning Rate Schedule"}}