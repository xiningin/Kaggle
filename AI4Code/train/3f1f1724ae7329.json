{"cell_type":{"9bdde354":"code","47d4a079":"code","e402d677":"code","98378a49":"code","edbdae17":"code","49be4d2e":"code","e3b3f6d1":"code","7df5f72c":"code","55b68a57":"code","c6fe06ed":"code","d6498019":"code","6ba38776":"code","5c8a89bb":"code","e13c7d00":"code","cd2b719f":"code","729d3b34":"code","70a9325b":"code","d60be6b2":"code","8017ac83":"code","ccd5d8d2":"code","691cca14":"markdown","54d4edf2":"markdown","ecb71166":"markdown","a3e0f747":"markdown","4db4247d":"markdown","27f72283":"markdown","fe5d8183":"markdown","03ab3fd2":"markdown","972fbd84":"markdown","d77f7b8f":"markdown","e2d448b7":"markdown","db07198a":"markdown","96c22f92":"markdown","0cbcfbe6":"markdown","8bef4a9f":"markdown","1c51f32b":"markdown","1bd1039c":"markdown","3be11e82":"markdown","f00825a9":"markdown"},"source":{"9bdde354":"%%html\n<style> \n@import url('https:\/\/fonts.googleapis.com\/css?family=Orbitron|Roboto');\nbody {background-color: gainsboro;} \na {color: #37c9e1; font-family: 'Roboto';} \nh1 {color: #37c9e1; font-family: 'Orbitron'; text-shadow: 4px 4px 4px #aaa;} \nh2, h3 {color: slategray; font-family: 'Orbitron'; text-shadow: 4px 4px 4px #aaa;}\nh4 {color: #818286; font-family: 'Roboto';}\n#span {text-shadow: 4px 4px 4px #aaa;}\ndiv.output_prompt, div.output_area pre {color: white;}\ndiv.input_prompt, div.output_subarea {color: #37c9e1;}      \ndiv.output_stderr pre {background-color: gainsboro;}  \ndiv.output_stderr {background-color: slategrey;}       \n<\/style>","47d4a079":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sn\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","e402d677":"pd.options.display.max_columns = 999\ncourses = pd.read_csv(\"..\/input\/export-1-pt-utf.csv\", parse_dates=['cr-Date'])\ncourses.head()","98378a49":"\n\ndataTypeDf = pd.DataFrame(courses.dtypes.value_counts()).reset_index().rename(columns={\"index\":\"variableType\",0:\"count\"})\nfig,ax = plt.subplots()\nfig.set_size_inches(20,5)\nsn.barplot(data=dataTypeDf,x=\"variableType\",y=\"count\",ax=ax,color=\"#34495e\")\nax.set(xlabel='Type de Variables', ylabel='Quantit\u00e9',title=\"Quantit\u00e9 variables par type\")\n\n","edbdae17":"courses.info(memory_usage='deep')","49be4d2e":"for dtype in ['float','int','object']:\n    # Pour retourner un sous ensemble d'un Dataframe en fonction du type des colonne\n    selected_dtype = courses.select_dtypes(include=[dtype])\n    # memory_usage retourne la m\u00e9moire utilis\u00e9e en byte des colonnes\n    usage_moyen_b = selected_dtype.memory_usage(deep=True).mean()\n    usage_moyen_mb = usage_moyen_b \/ 1024 ** 2\n    print(\"Usage moyen de la m\u00e9moire pour le type {} : {:03.2f} MB\".format(dtype,usage_moyen_mb))","e3b3f6d1":"int_types = [\"uint8\", \"int8\", \"int16\", \"uint16\", \"int32\", \"uint32\", \"int64\", \"uint64\"]\nfor it in int_types:\n    print(np.iinfo(it))","7df5f72c":"# Cr\u00e9ation d'une fonction de mesure de la m\u00e9moire\ndef usage_memoire(pandas_obj):\n    # Notre objet est il un Dataframe ?\n    if isinstance(pandas_obj,pd.DataFrame):\n        # Somme de toutes nos colonnes\n        usage_b = pandas_obj.memory_usage(deep=True).sum()\n    else: # C'est alors une s\u00e9rie\n        usage_b = pandas_obj.memory_usage(deep=True)\n    # convertion des bytes en Mo\n    usage_mb = usage_b \/ 1024 ** 2 \n    return \"{:03.2f} MB\".format(usage_mb)\n\n#On cr\u00e9\u00e9 un nouveau dataFrame avec uniquement les colonnes de types entiers\ncourses_int = courses.select_dtypes(include=['int'])\n# On va forcer la conversion en entier non sign\u00e9\nconvertion_int = courses_int.apply(pd.to_numeric,downcast='unsigned')\n\nprint(usage_memoire(courses_int))\nprint(usage_memoire(convertion_int))\n\n# on va cr\u00e9er un nouveau dataframe pour voir les changement de type\ncompare_ints = pd.concat([courses_int.dtypes,convertion_int.dtypes],axis=1)\ncompare_ints.columns = ['avant','apres']\ncompare_ints.apply(pd.Series.value_counts)","55b68a57":"courses_float = courses.select_dtypes(include=['float'])\nconvertion_float = courses_float.apply(pd.to_numeric,downcast='float')\n\nprint(usage_memoire(courses_float))\nprint(usage_memoire(convertion_float))\n\ncompare_floats = pd.concat([courses_float.dtypes,convertion_float.dtypes],axis=1)\ncompare_floats.columns = ['avant','apres']\ncompare_floats.apply(pd.Series.value_counts)","c6fe06ed":"optimise_gl = courses.copy()\n\noptimise_gl[convertion_int.columns] = convertion_int\noptimise_gl[convertion_float.columns] = convertion_float\n\nprint(usage_memoire(courses))\nprint(usage_memoire(optimise_gl))","d6498019":"# On cr\u00e9\u00e9 un dataframe avec uniquement les colonnes de types objet\ncourses_obj = courses.select_dtypes(include=['object']).copy()\ncourses_obj.describe()","6ba38776":"etat_terrain = courses_obj[\"cr-etat du terrain\"]\nprint(etat_terrain.head())\n\netat_terrain_cat = etat_terrain.astype('category')\nprint(etat_terrain_cat.head())","5c8a89bb":"etat_terrain_cat.head(10).cat.codes","e13c7d00":"print(usage_memoire(etat_terrain))\nprint(usage_memoire(etat_terrain_cat))","cd2b719f":"convertion_obj = pd.DataFrame()\n\n# On parcours les diff\u00e9rentes colonnes\nfor col in courses_obj.columns:\n    # Nombre de valeurs uniques\n    num_unique_valeurs = len(courses_obj[col].unique())\n    # Nombre de valeurs\n    num_total_valeurs = len(courses_obj[col])\n    # Si moins de 50% de valeurs uniques alors on change le type de colonne\n    if num_unique_valeurs \/ num_total_valeurs < 0.5:\n        convertion_obj.loc[:,col] = courses_obj[col].astype('category')\n    else:\n        convertion_obj.loc[:,col] = courses_obj[col]\n        \nprint(usage_memoire(courses_obj))\nprint(usage_memoire(convertion_obj))\n\ncompare_obj = pd.concat([courses_obj.dtypes,convertion_obj.dtypes],axis=1)\ncompare_obj.columns = ['avant','apres']\ncompare_obj.apply(pd.Series.value_counts)","729d3b34":"optimise_gl[convertion_obj.columns] = convertion_obj\n\nusage_memoire(optimise_gl)","70a9325b":"date = optimise_gl[\"cr-Date\"]\nprint(usage_memoire(date))\ndate.head()","d60be6b2":"# On supprime la colonne cr-Date\ndtypes = optimise_gl.drop('cr-Date',axis=1).dtypes\n\n# Serie avec le nom de la colonne\ndtypes_col = dtypes.index\n# Serie avec le type de la colonne\ndtypes_type = [i.name for i in dtypes.values]\n\n#Cr\u00e9ation d'un dictionnaire \ncolumn_types = dict(zip(dtypes_col, dtypes_type))\n\n#Affichage des r\u00e9sultats\nfor keys,values in column_types.items():\n    print(keys+\" : \"+values)\n\n","8017ac83":"courses_optimisees = pd.read_csv('..\/input\/export-1-pt-utf.csv',dtype=column_types,parse_dates=['cr-Date'],infer_datetime_format=True)\n\nprint(usage_memoire(courses_optimisees))\ncourses_optimisees.head()","ccd5d8d2":"dataTypeDf = pd.DataFrame(courses_optimisees.dtypes.value_counts()).reset_index().rename(columns={\"index\":\"variableType\",0:\"count\"})\nfig,ax = plt.subplots()\nfig.set_size_inches(20,5)\nsn.barplot(data=dataTypeDf,x=\"variableType\",y=\"count\",ax=ax,color=\"#34495e\")\nax.set(xlabel='Type de Variables', ylabel='Quantit\u00e9',title=\"Quantit\u00e9 variables par type\")","691cca14":"# &#128203;  Introduction\n\nLorsque vous travaillez avec pandas sur des petits dataframe (moins de 100 m\u00e9gaoctets), la performance est rarement un probl\u00e8me. Lorsque nous passons \u00e0 des donn\u00e9es plus volumineuses (de 100 m\u00e9gaoctets \u00e0 plusieurs gigaoctets), les probl\u00e8mes de performance peuvent allonger consid\u00e9rablement la dur\u00e9e d'ex\u00e9cution et faire \u00e9chouer le code en raison d'une m\u00e9moire insuffisante.\n\nDans cet article, nous allons apprendre \u00e0 optimiser  la m\u00e9moire, comment r\u00e9duire l'empreinte m\u00e9moire d'un dataframe sur les courses hippiques de pr\u00e8s de 90%, simplement en s\u00e9lectionnant les types de donn\u00e9es appropri\u00e9s pour les colonnes.","54d4edf2":"On remarque que nous sommes pass\u00e9s d'une taille de 1,52 Mb \u00e0 0,19 Mb soit une baisse de 87% de l'occupation en m\u00e9moire !\n\nOn peut voir dans le tableau qu'avant nos entiers \u00e9taient de la forme int64. D\u00e9sormais, ils sont au forat unint8.\n\nNous allons poursuivre en faisant la m\u00eame chose mais avec nos flottants.\n","ecb71166":"Si vous avez appr\u00e9ci\u00e9 ce petit article, merci de voter pour lui. \n\nSi vous voulez me joindre directement sur linkedin.\n[https:\/\/fr.linkedin.com\/in\/developpeur-windev](https:\/\/fr.linkedin.com\/in\/developpeur-windev)\n\n","a3e0f747":"![](https:\/\/cdn-images-1.medium.com\/max\/2000\/1*d-ZbdImPx4zRW0zK4QL49w.jpeg)","4db4247d":"Pour rappel, au d\u00e9but nous \u00e9tions \u00e0 17,1 Mo et maintenant 4,5 Mo. On a gagn\u00e9 au final 73% de m\u00e9moire. &#x1F4A3; ","27f72283":"# &#128203;  Analyse de la m\u00e9moire\n\nPar d\u00e9faut, pandas se rapproche de l'utilisation de la m\u00e9moire de la trame de donn\u00e9es pour gagner du temps. Parce que nous sommes int\u00e9ress\u00e9s par la pr\u00e9cision, nous allons r\u00e9gler le param\u00e8tre memory_usage sur'deep' pour obtenir un nombre pr\u00e9cis.","fe5d8183":"Wow, on a vraiment fait des progr\u00e8s ! Nous avons une autre optimisation que nous pouvons faire - si vous vous souvenez de notre tableau des types, il y avait un type datetime que nous pouvons utiliser pour la premi\u00e8re colonne de notre ensemble de donn\u00e9es.\n\nIl nous reste encore un colone de type date. Pouvons nous essayer de l'optimiser ?\n","03ab3fd2":"Nous pouvons voir que nous avons 19 869 lignes et 69 colonnes. Pandas a d\u00e9tect\u00e9 automatiquement les types pour nous, avec 63 colonnes num\u00e9riques et 6 colonnes d'objets. Les colonnes d'objets sont utilis\u00e9es pour les cha\u00eenes de caract\u00e8res ou lorsqu'une colonne contient des types de donn\u00e9es mixtes.\n\nAfin de mieux comprendre o\u00f9 nous pouvons r\u00e9duire l'utilisation de la m\u00e9moire, examinons comment pandas stockent les donn\u00e9es en m\u00e9moire.\n\nDans Pandas, chaque type de donn\u00e9es entiers, flottants et objets sont stock\u00e9s s\u00e9paremment. Chaque type a une classe sp\u00e9cialis\u00e9e dans le module pandas.core.internals. Pandas utilise la classe ObjectBlock pour repr\u00e9senter le bloc contenant les colonnes de cha\u00eenes et la classe FloatBlock pour repr\u00e9senter le bloc contenant les colonnes de floats et IntBlock pour les entiers.\n\nComme chaque type de donn\u00e9es est stock\u00e9 s\u00e9par\u00e9ment, nous allons examiner l'utilisation de la m\u00e9moire par type de donn\u00e9es. Commen\u00e7ons par examiner l'utilisation moyenne de la m\u00e9moire pour le type de donn\u00e9es.","972fbd84":"Nous sommes pass\u00e9s de float 64 en float 32. Du coup, on gagne presque 50% en m\u00e9moire.\n\nA partir de cela, on peut cr\u00e9er un DataFrame avec ces nouveaux types.","d77f7b8f":"Maintenant nous pouvons utiliser le dictionnaire, avec quelques param\u00e8tres pour la date \u00e0 lire dans les donn\u00e9es avec les types corrects en quelques lignes :","e2d448b7":"Nous pouvons voir au premier coup d'oeil que la majeure partie de notre m\u00e9moire est utilis\u00e9e par nos colonnes d'objets. Nous y reviendrons plus tard, mais voyons d'abord si nous pouvons am\u00e9liorer l'utilisation de la m\u00e9moire pour nos colonnes num\u00e9riques.\n\n# &#128203; Diff\u00e9rents types d'entiers et de flottants\n\nOn trouve plusieurs types d'entiers :\n* int8\n* uint8\n* uint16\n* int16\n* int32\n* uint32\n* int64\n* uint64\n\nOn trouve plusieurs types de flottants :\n* float16\n* float32\n* float64\n\nNumpy nous permet d'avoir des infos sur les diff\u00e9rents types. La fonction numpy.iinfo nous donne les infos sur les valeurs max et min du type de variable.\n","db07198a":"On peut voir que globalement on a gagn\u00e9 environ 30% en m\u00e9moire. Ce qui est d\u00e9j\u00e0 pas mal. Imaginez si notre dataFrame faisait plusieurs Gigas...\n\nMaintenant essayons de nous attaquer au type Objet.\n\nLes cha\u00eenes de caract\u00e8res sont stock\u00e9es de mani\u00e8re fragment\u00e9e, ce qui consomme plus de m\u00e9moire et ralentit l'acc\u00e8s. Chaque \u00e9l\u00e9ment d'une colonne d'objet est en r\u00e9alit\u00e9 un pointeur qui contient l'\"adresse\" de l'emplacement de la valeur r\u00e9elle dans la m\u00e9moire.\n\n# &#128203; Optimisation des types Object\n\nPandas poss\u00e8de un type Categoricals. Ce type utilise des valeurs enti\u00e8res sous le capot pour repr\u00e9senter les valeurs dans une colonne, plut\u00f4t que les valeurs brutes. Pandas utilise un dictionnaire de mappage s\u00e9par\u00e9 qui mappe les valeurs enti\u00e8res sur les valeurs brutes. Cette disposition est utile lorsqu'une colonne contient un ensemble limit\u00e9 de valeurs. Lorsque nous convertissons une colonne dans la cat\u00e9gorie dtype, pandas utilise le sous-type int le plus efficace en espace qui peut repr\u00e9senter toutes les valeurs uniques dans une colonne.\n\n![](http:\/\/www.logiciels-professionnels.com\/Capture.PNG)\n\nPour avoir un aper\u00e7u des colonnes o\u00f9 nous pourrions utiliser ce type pour r\u00e9duire la m\u00e9moire, jetons un coup d'oeil au nombre de valeurs uniques de chacun de nos types d'objets.\n\n","96c22f92":"Sur les premi\u00e8res courses l'\u00e9tat du terrain ne change pas et nous avons toujours la valeur 1, qui correspond \u00e0 \"terrain bon\".\n\nV\u00e9rifions ce que cela donne au niveau de la m\u00e9moire.\n","0cbcfbe6":"On peut voir de suite les diff\u00e9rences avec les uint qui ne sont pas sign\u00e9s.\n\n# &#128203;  Optimiser nos colonnes en fonction du sous type\n\nPandas nous propose une fonction pour changer le type d'une colonne. Cette fonction est **to_numeric()**.\nComme nous l'avons vue pr\u00e9c\u00e9demment, nous utiliserons DataFrame.select_dtypes pour ne s\u00e9lectionner que les colonnes enti\u00e8res, puis nous optimiserons les types et comparerons l'utilisation de la m\u00e9moire.\n","8bef4a9f":"Nous sommes pass\u00e9s de 1,3 Mo de m\u00e9moire utilis\u00e9e \u00e0 0,02 Mo de m\u00e9moire utilis\u00e9e, soit une r\u00e9duction de 98 % ! En effet, nous sommes pass\u00e9s \u00e0 6 valeurs uniques sur plus de 19 000 lignes.\n\nBien que la conversion de toutes les colonnes de ce type semble attrayante, il est important d'\u00eatre conscient des compromis \u00e0 faire. Le plus important est l'incapacit\u00e9 d'effectuer des calculs num\u00e9riques. Nous ne pouvons pas faire d'arithm\u00e9tique avec des colonnes de cat\u00e9gories ou utiliser des m\u00e9thodes comme Series.min() et Series.max() sans d'abord convertir en un vrai dtype num\u00e9rique.\n\nNous devrions nous en tenir au type de cat\u00e9gorie principalement pour les colonnes d'objets o\u00f9 moins de 50% des valeurs sont uniques. Si toutes les valeurs d'une colonne sont uniques, le type de cat\u00e9gorie finira par utiliser plus de m\u00e9moire. \n\nNous allons \u00e9crire une boucle \u00e0 it\u00e9rer sur chaque colonne d'objet, v\u00e9rifier si le nombre de valeurs uniques est inf\u00e9rieur \u00e0 50%, et si oui, le convertir au type de cat\u00e9gorie.","1c51f32b":"Comme vous pouvez le voir, outre le fait que le type de colonne a chang\u00e9, les donn\u00e9es sont exactement les m\u00eames. \n\nDans le code suivant, nous utilisons l'attribut Series.cat.codes pour retourner les valeurs enti\u00e8res que le type de cat\u00e9gorie utilise pour repr\u00e9senter chaque valeur.","1bd1039c":"Dans ce cas, toutes nos colonnes d'objets ont \u00e9t\u00e9 converties en type de cat\u00e9gorie, mais ce ne sera pas le cas avec tous les ensembles de donn\u00e9es, vous devriez donc vous assurer d'utiliser le processus ci-dessus pour v\u00e9rifier.\n\nDe plus, notre utilisation de m\u00e9moire pour nos colonnes d'objets est pass\u00e9e de 7,93 Mo \u00e0 0,15 Mo, soit une r\u00e9duction de 95 %. Combinons ceci avec le reste de notre dataframe et voyons o\u00f9 nous nous situons par rapport \u00e0 l'utilisation de m\u00e9moire de 17,1 MB que nous avons commenc\u00e9 avec.","3be11e82":"On remarque de suite que ma colonne cr-Date est d\u00e9j\u00e0 au format date. En effet, durant l'importation depuis csv, on avait sp\u00e9cifier que cette colonne \u00e9tait au format date. Cela nous permet d'optimiser dircetement cette colonne au chargement du dataframe.\n\n# &#128203;  Importation des donn\u00e9es en fixant le type\n\nJusqu'\u00e0 pr\u00e9sent, nous avons explor\u00e9 des moyens de r\u00e9duire l'empreinte m\u00e9moire d'un dataFrame existant. En important notre fichier et puis en changeant le types des colonnes, nous avons pu optimiser la taille de notre empreinte m\u00e9moire. \n\nMais imaginons que notre fichier soit trop gros pour \u00eatre charg\u00e9 ou que nus ayons une m\u00e9moire trop petite pour le charger. Comment pouvons-nous appliquer des techniques d'\u00e9conomie de m\u00e9moire alors que nous ne pouvons m\u00eame pas cr\u00e9er le dataframe ?\n\nHeureusement, nous pouvons sp\u00e9cifier les types de colonnes  lorsque nous lisons l'ensemble des donn\u00e9es. La fonction pandas.read_csv() a quelques param\u00e8tres  qui nous permettent de le faire. C'est ce que nous venons de voir avec l'importation de la date. \nLe param\u00e8tre dtype accepte un dictionnaire dont les cl\u00e9s sont des noms de colonnes (cha\u00eenes de caract\u00e8res) et les valeurs des objets de type NumPy.\n\nTout d'abord, nous allons stocker les types finaux de chaque colonne dans un dictionnaire avec des cl\u00e9s pour les noms de colonnes, en supprimant d'abord la colonne de la date puisque celle-ci doit \u00eatre trait\u00e9e s\u00e9par\u00e9ment.\n","f00825a9":"Un coup d'\u0153il rapide r\u00e9v\u00e8le de nombreuses colonnes o\u00f9 il y a peu de valeurs uniques par rapport \u00e0 l'ensemble des 19869 lignes  de notre ensemble de donn\u00e9es.\n\nAvant d'aller plus loin, nous allons commencer par s\u00e9lectionner une seule de nos colonnes d'objets, et regarder ce qui se passe dans les coulisses lorsque nous la convertissons en type cat\u00e9gorique. Nous utiliserons la troisi\u00e8me colonne de notre ensemble de donn\u00e9es, cr-etat du terrain.\n\nEn regardant le tableau ci-dessus, nous pouvons voir qu'il ne contient que six valeurs uniques. Nous allons le convertir en cat\u00e9gorique en utilisant la m\u00e9thode .astype()."}}