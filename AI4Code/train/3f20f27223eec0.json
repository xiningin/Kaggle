{"cell_type":{"12c8a92a":"code","64794ae0":"code","323728db":"code","ba18ad43":"code","57f91c69":"code","d3547e5e":"code","ce049689":"code","df0f1434":"code","8258ba0c":"code","f463812d":"code","43981378":"code","c894f9e2":"code","0ff80af7":"code","155f7f67":"code","7f1255b3":"code","06529fcb":"code","a0dc27a7":"code","ce5353be":"code","c9f2f172":"code","d889a6ee":"code","f8a2a159":"code","e1279747":"code","775154c5":"code","de10a032":"markdown","beb44688":"markdown","f6fcf65b":"markdown","0e3edf4c":"markdown","43915967":"markdown","e5e475e2":"markdown","def65d7c":"markdown","28a11ff8":"markdown","5e94f47f":"markdown","1ea92ad8":"markdown","ac7a411c":"markdown","9ff748a9":"markdown","9c634feb":"markdown","62302982":"markdown","d13c0274":"markdown","6e0ebee7":"markdown","0a47b32b":"markdown","bf3a4f63":"markdown","504bbf2c":"markdown","3447f4ac":"markdown"},"source":{"12c8a92a":"import numpy as np\nimport pandas as pd\n\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\n%matplotlib inline\n\nfrom sklearn.svm import SVC\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import RandomForestClassifier\n\nfrom sklearn.metrics import accuracy_score","64794ae0":"training_data = pd.read_csv('..\/input\/human-activity-recognition-with-smartphones\/train.csv')\ntesting_data = pd.read_csv('..\/input\/human-activity-recognition-with-smartphones\/test.csv')","323728db":"training_data.head()","ba18ad43":"print(\"Training Data: {}\".format(training_data.shape))","57f91c69":"print(\"Null values present in training data: {}\".format(training_data.isnull().values.any()))","d3547e5e":"print(\"Testing Data: {}\".format(testing_data.shape))","ce049689":"print(\"Null values present in testing data: {}\".format(testing_data.isnull().values.any()))","df0f1434":"# Get X and y for training data\nX_train = training_data.drop(columns = ['Activity', 'subject'])\ny_train = training_data[\"Activity\"]\n\n# Get X and y for testing data\ny_test = testing_data['Activity']\nX_test = testing_data.drop(columns = ['Activity', 'subject'])","8258ba0c":"count_of_each_activity = np.array(y_train.value_counts())","f463812d":"activities = sorted(y_train.unique())","43981378":"colors = cm.rainbow(np.linspace(0, 1, 4))\nplt.figure(figsize=(10,6))\nplt.bar(activities,count_of_each_activity,width=0.3,color=colors)\nplt.xticks(rotation=45,fontsize=12)\nplt.yticks(rotation=45,fontsize=12)","c894f9e2":"plt.figure(figsize=(16,8))\nplt.pie(count_of_each_activity, labels = activities, autopct = '%0.2f')","0ff80af7":"Acc = 0\nGyro = 0\nother = 0\n\nfor value in X_train.columns:\n    if \"Acc\" in str(value):\n        Acc += 1\n    elif \"Gyro\" in str(value):\n        Gyro += 1\n    else:\n        other += 1","155f7f67":"plt.figure(figsize=(12,8))\nplt.bar(['Accelerometer', 'Gyroscope', 'Others'],[Acc,Gyro,other],color=('r','g','b'))","7f1255b3":"training_data['subject'].unique()","06529fcb":"standing_activity = training_data[training_data['Activity'] == 'STANDING']\n# Reset the index for this dataframe\nstanding_activity = standing_activity.reset_index(drop=True)","a0dc27a7":"standing_activity.shape","ce5353be":"time = 1\nindex = 0\ntime_series = np.zeros(standing_activity.shape[0])\nprint(time_series)","c9f2f172":"for row_number in range(standing_activity.shape[0]):\n    if (row_number == 0 \n        or standing_activity.iloc[row_number]['subject'] == standing_activity.iloc[row_number - 1]['subject']):\n        time_series[index] = time\n        time += 1\n    else:\n        time_series[index] = 1\n        time = 2\n    index += 1\n\n# Combine the time_series with the standing_activity dataframe\ntime_series_df = pd.DataFrame({ 'Time': time_series })\nstanding_activity_df = pd.concat([standing_activity, time_series_df], axis = 1)","d889a6ee":"standing_activity_df.head()","f8a2a159":"colors = cm.rainbow(np.linspace(0, 1, len(standing_activity_df['subject'].unique())))\n\n# Create plot for each subject, which will all be displayed overlapping on one plot\nid = 0\nfor subject in standing_activity_df['subject'].unique():\n    plt.rcParams.update({'figure.figsize': [40, 30], 'font.size': 24})\n    plt.plot(standing_activity_df[standing_activity_df['subject'] == subject]['Time'], \n             standing_activity_df[standing_activity_df['subject'] == subject]['angle(X,gravityMean)'],\n             c = colors[id], \n             label = 'Subject ' + str(subject),\n             linewidth = 4)\n    plt.xlabel('Time',fontsize=28)\n    plt.ylabel('Angle',fontsize=28)\n    plt.title('Angle between X and mean Gravity v\/s Time for various subjects')\n    plt.legend(prop = {'size': 24})\n    id += 1","e1279747":"accuracy_scores = np.zeros(4)\n\n# Support Vector Classifier\nclf = SVC().fit(X_train, y_train)\nprediction = clf.predict(X_test)\naccuracy_scores[0] = accuracy_score(y_test, prediction)*100\nprint('Support Vector Classifier accuracy: {}%'.format(accuracy_scores[0]))\n\n# Logistic Regression\nclf = LogisticRegression().fit(X_train, y_train)\nprediction = clf.predict(X_test)\naccuracy_scores[1] = accuracy_score(y_test, prediction)*100\nprint('Logistic Regression accuracy: {}%'.format(accuracy_scores[1]))\n\n# K Nearest Neighbors\nclf = KNeighborsClassifier().fit(X_train, y_train)\nprediction = clf.predict(X_test)\naccuracy_scores[2] = accuracy_score(y_test, prediction)*100\nprint('K Nearest Neighbors Classifier accuracy: {}%'.format(accuracy_scores[2]))\n\n# Random Forest\nclf = RandomForestClassifier().fit(X_train, y_train)\nprediction = clf.predict(X_test)\naccuracy_scores[3] = accuracy_score(y_test, prediction)*100\nprint('Random Forest Classifier accuracy: {}%'.format(accuracy_scores[3]))","775154c5":"plt.figure(figsize=(12,8))\ncolors = cm.rainbow(np.linspace(0, 1, 4))\nlabels = ['Support Vector Classifier', 'Logsitic Regression', 'K Nearest Neighbors', 'Random Forest']\nplt.bar(labels,\n        accuracy_scores,\n        color = colors)\nplt.xlabel('Classifiers',fontsize=18)\nplt.ylabel('Accuracy',fontsize=18)\nplt.title('Accuracy of various algorithms',fontsize=20)\nplt.xticks(rotation=45,fontsize=12)\nplt.yticks(fontsize=12)","de10a032":"For now, I will keep the default values of parameters as defined in `sklearn` for each classifier.","beb44688":"## Activity Recognition using Machine Learning","f6fcf65b":"plotting a bar graph of the accuracies to compare them visually.\n","0e3edf4c":"### Set time series for each subject","43915967":"For each subject, I can now plot the graph of their angles with time. I use the cm subpackage of matplotlib to get a set of colors which shall be used for differentiating subjects.","e5e475e2":"## Understand the data","def65d7c":"If I take a closer look at the graph, we can see that each line on an average, transitions between a maximum range of 0.2\u20130.3 values. This is indeed the expected behaviour as slight variations can be attributed to minor human errors.","28a11ff8":"### Import libraries\nI import numpy and pandas for managing arrays and dataset. Then, matplotlib is included to be used to create visualisations. To use various machine learning algorithms, I import SVM, Logistic Regression, K Nearest Neighbors Classifier and Random Forest Classifier from sklearn. Also, included is accuracy_score to calculate accuracy.","5e94f47f":"I can see that the dataset consists of accelerometer and gyroscope sensor values for each record. Further, the last two columns are `subject` which refers to subject number and `Activity` which defines the type of activity. The `Activity` column acts as the label `y` and all the rest columns are features `X`. ","1ea92ad8":"## Conclusion\n\nIn this particular project, I explored the activity recognition dataset. I visualized the data using matplotlib. Then, I applied numerous machine learning algorithms and found out that `Logistic Regression` performed the best in classifying different activities with accuracy of almost 96%","ac7a411c":"## Classify activities\n\nTo begin, I'll use various machine learning algorithms available inside the sklearn package that I have already imported. For each algorithm, I'll calculate the accuracy of prediction and identify the most accurate algorithm.","9ff748a9":"There are total 7352 records in the training dataset. Further, there are no null values in the dataset.The testing dataset has 2947 records for testing our models. This dataset has no null values.","9c634feb":"## Visualize the dataset","62302982":"I will select all rows from the dataset that have the \u2018Activity\u2019 label as \u2018STANDING\u2019 and store it in standing_activity. ","d13c0274":"On inspecting the dataset, I can see that there are many features. It's easy to identify that there are Accelerometer, Gyroscope and some other values in the dataset. I can check the share of each by plotting a bar graph of each type. Accelerometer values have Acc in them, Gyroscope values have Gyro and rest can be considered as others","6e0ebee7":"I will now visualise the training data to get a better understanding of the available dataset.","0a47b32b":"The data collected is in continuous time series for each individual and was recorded at the `same rate`. So, I can simply assign time values to each activity starting from `0` each time the subject changes. For each subject, the `Standing activity` records will start with a time value of 0 and increment by `1` till the previous row\u2019s subject matches the present row\u2019s subject. I store all the time series in a variable `time_series` and convert it into a dataframe using pandas method DataFrame() and store it in a variable `time_series_df`. Lastly, I combine the records and the time series variable together in `standing_activity_d`f using pandas `concatenate()` method. ","bf3a4f63":"Clearly seen that `Logistic Regression` performed the best with the highest accuracy.","504bbf2c":"The percenage values show that the data size for each activity is comparable. The dataset is equally distributed.","3447f4ac":"Accelerometer constitutes the maximum features, followed by Gyroscope. Other features are very less"}}