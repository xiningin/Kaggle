{"cell_type":{"28c762de":"code","c52517fd":"code","592c0f53":"code","7a5529cf":"code","9f872be8":"code","3ed832ad":"code","c3463440":"code","3ebb8fca":"code","8217ea01":"code","8372ded5":"code","26f77e84":"code","e6d31ed9":"code","731f50e8":"code","a2b17db2":"code","bb213668":"code","a767c2fa":"code","4cd1f7d2":"code","43781f46":"code","910f61eb":"code","9bb6dd1f":"code","0baf2b30":"code","91392100":"code","11552f19":"code","468812d3":"code","3787d264":"code","17f964e9":"code","6f38f456":"code","05543055":"code","dc7963ad":"code","cb86c15a":"code","00065222":"code","fe6cda4a":"code","032d4179":"code","d487472f":"code","f68aadf4":"code","a8044fb7":"code","020f26e9":"code","ab770747":"code","6747b7e2":"code","3bdb8651":"code","8b300d76":"code","133055c9":"code","6824f03b":"code","fa3186b4":"code","d76139ea":"code","fdbef247":"code","35061362":"code","3fc02015":"code","0f78029b":"code","2ad1f5d0":"code","b18ff98a":"code","46ded637":"code","8e68cce6":"code","52cad943":"code","fc28a7f6":"code","8a733b46":"code","d8ccfbee":"code","4b8c4191":"code","2bec48c7":"code","bc2e26e2":"code","f2cc6902":"code","3763c1e7":"code","e8f7f090":"code","1307026e":"code","f5830e65":"code","b7b2d64d":"code","a14c275b":"code","2f4c2766":"code","c5030bd4":"code","832d0174":"code","b9512aca":"code","06990a1c":"code","2463ee27":"code","e4b7efcd":"code","8bcba92c":"code","05a67717":"code","becece52":"code","1b813e39":"code","5a6fe314":"code","7cb7a744":"code","0fa35aca":"code","a660d881":"code","ef89bfea":"code","1a42d01d":"code","2381194b":"code","7d67d00d":"code","9e08f605":"code","e8b21fe4":"code","d5749a93":"code","3701e519":"code","e931146b":"code","06b421a9":"code","3f13717c":"code","9923fb37":"code","28f019e0":"code","ab25240e":"markdown","15a3650b":"markdown","95a93468":"markdown","538e0480":"markdown","c76e2044":"markdown","3b371a2f":"markdown","fd1add18":"markdown","5bacc9d2":"markdown","ee1d35c1":"markdown","75d3a161":"markdown","d1488c47":"markdown","41aa5663":"markdown","54195bad":"markdown","c5940b66":"markdown","09060f80":"markdown","264caac5":"markdown","1349bd66":"markdown","43861a26":"markdown","fb5cf510":"markdown","39368614":"markdown","535ab91a":"markdown","01033fc2":"markdown","3638a509":"markdown","87a910ce":"markdown"},"source":{"28c762de":"#caricamento e analisi dei dataset\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport seaborn as sns \nimport datetime\nimport sklearn\nfrom matplotlib import pyplot\nfrom plotly.offline import plot, iplot, init_notebook_mode\ninit_notebook_mode(connected=True)\nfrom sklearn.metrics import r2_score,mean_squared_error,mean_absolute_error\nfrom scipy.optimize import curve_fit\nfrom pandas.tseries.offsets import DateOffset\n\n! pip install pyspark\nimport pyspark\nfrom pyspark.sql import SparkSession\nfrom pyspark.conf import SparkConf\nfrom pyspark import SparkContext\nfrom pyspark.sql.functions import substring\nfrom pyspark.sql.types import IntegerType\nfrom pyspark.ml.feature import VectorAssembler\nfrom pyspark.ml.regression import GBTRegressor\n\nimport warnings\nwarnings.filterwarnings('ignore')\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","c52517fd":"#apertura e lettura dei vari dataset presi in considerazione \nsolar = pd.read_csv(r'..\/input\/residential-solar-vs-weather-nc-usa\/Weather_and_energy_Final_2020_2021.csv', header=0)\npanels = pd.read_csv(r'..\/input\/residential-solar-vs-weather-nc-usa\/Panel_Monthly_totals_2020_2021.csv', header=0)\n\np1gd = pd.read_csv(\"..\/input\/solar-power-generation-data\/Plant_1_Generation_Data.csv\")\np2gd = pd.read_csv(\"..\/input\/solar-power-generation-data\/Plant_2_Generation_Data.csv\")\n#lettura del tempo metereologico\np1wd = pd.read_csv('..\/input\/solar-power-generation-data\/Plant_1_Weather_Sensor_Data.csv')\np1wd.drop('PLANT_ID',1,inplace=True)\np2wd = pd.read_csv('..\/input\/solar-power-generation-data\/Plant_2_Weather_Sensor_Data.csv')\np2wd.drop('PLANT_ID',1,inplace=True)\n\np1gd['DATE_TIME']= pd.to_datetime(p1gd['DATE_TIME'],format='%d-%m-%Y %H:%M')\np1wd['DATE_TIME']= pd.to_datetime(p1wd['DATE_TIME'],format='%Y-%m-%d %H:%M:%S')\n\np2gd['DATE_TIME']= pd.to_datetime(p2gd['DATE_TIME'],format='%Y-%m-%d %H:%M')\np2wd['DATE_TIME']= pd.to_datetime(p2wd['DATE_TIME'],format='%Y-%m-%d %H:%M:%S')","592c0f53":"print(solar.head())\nprint('_______________________')\nprint(panels.head())\n","7a5529cf":"\npg1_inverters=p1gd['SOURCE_KEY'].nunique()\npg2_inverters=p2gd['SOURCE_KEY'].nunique()\nprint(f\"L'impianto 1 ha  {pg1_inverters} inverter.\")\nprint(f\"L'impianto 2 ha {pg2_inverters} inverter.\")\n\nprint(f\"\")\nprint(f\"Impianto 1 Media corrente alternata (AC) per ogni inverter\")\nax=sns.barplot(data=p1gd,x='SOURCE_KEY',y='AC_POWER',color='green',ci=None)\n\n\nplt.xticks([])\nax.set(ylabel='Media corrente alternata AC(kW)')\nplt.show()\nprint(f\"\")\nprint(f\"Impianto 2 Media corrente alternata (AC) per ogni inverter\")\nax=sns.barplot(data=p2gd,x='SOURCE_KEY',y='AC_POWER',color='green',ci=None)\nplt.xticks([])\nax.set(ylabel='Media corrente alternata AC(kW)')\nplt.show()","9f872be8":"s1 = p1gd.groupby('SOURCE_KEY').mean()['AC_POWER'].std()\nprint(f\"Gli inverter dell'impianto 1 sono relativamente \"\n      f'stabili con solo una deviazione standard di {s1:.2f} kW nella media')\n\ns2 = p2gd.groupby('SOURCE_KEY').mean()['AC_POWER'].std()\nprint(f\"Gli inverter dell'impianto 2 sono relativamente \"\n      f'instabili con solo una deviazione standard di {s2:.2f} kW nella media')","3ed832ad":"p1gd\n","c3463440":"p2gd","3ebb8fca":"p1wd","8217ea01":"p2wd","8372ded5":"df_gen1=p1gd.groupby('DATE_TIME').sum().reset_index()\ndf_gen1['time']=df_gen1['DATE_TIME'].dt.time\n\nfig,ax = plt.subplots(ncols=2,nrows=1,dpi=100,figsize=(20,5))\n# daily yield plot\ndf_gen1.plot(x='DATE_TIME',y='DAILY_YIELD',color='navy',ax=ax[0])\n# AC & DC power plot\ndf_gen1.set_index('time').drop('DATE_TIME',1)[['AC_POWER','DC_POWER']].plot(style='o',ax=ax[1])\n\nax[0].set_title('Rendimento giornaliero',)\nax[1].set_title('Energia AC\/DC durante le ore diurne')\nax[0].set_ylabel('kW',color='navy',fontsize=17)\nplt.show()","26f77e84":"df_gen3=df_gen1.copy();\ndf_gen3['time']=df_gen1['DATE_TIME'].dt.time\ndf_gen3['DC_POWER(AGG)']=df_gen3['DC_POWER']\/10\n\ndf_gen3.max()","e6d31ed9":"fig,ax = plt.subplots(ncols=2,nrows=1,dpi=100,figsize=(20,5))\n# daily yield plot\ndf_gen3.plot(x='DATE_TIME',y='DAILY_YIELD',color='navy',ax=ax[0])\n# AC & DC power plot\ndf_gen3.set_index('time').drop('DATE_TIME',1)[['AC_POWER','DC_POWER(AGG)']].plot(style='o',ax=ax[1])\n\nax[0].set_title('Rendimento giornaliero',)\nax[1].set_title('Energia AC\/DC durante le ore diurne')\nax[0].set_ylabel('kW',color='navy',fontsize=17)\nplt.show()","731f50e8":"df_gen2=p2gd.groupby('DATE_TIME').sum().reset_index()\ndf_gen2['time']=df_gen2['DATE_TIME'].dt.time\n\nfig,ax = plt.subplots(ncols=2,nrows=1,dpi=100,figsize=(20,5))\n# daily yield plot\ndf_gen2.plot(x='DATE_TIME',y='DAILY_YIELD',color='navy',ax=ax[0])\n# AC & DC power plot\ndf_gen2.set_index('time').drop('DATE_TIME',1)[['AC_POWER','DC_POWER']].plot(style='o',ax=ax[1])\n\nax[0].set_title('Rendimento giornaliero',)\nax[1].set_title('Energia AC\/DC durante le ore diurne')\nax[0].set_ylabel('kW',color='navy',fontsize=17)\nplt.show()","a2b17db2":"p1gd.describe()","bb213668":"p2gd.describe()","a767c2fa":"losses=p1gd.copy()\nlosses['day']=losses['DATE_TIME'].dt.date\nlosses=losses.groupby('day').sum()\nlosses['losses']=losses['AC_POWER']\/losses['DC_POWER']*100\n\nlosses['losses'].plot(style='o--',figsize=(17,5),label='Potenza effettiva')\n\nplt.title('% di potenza DC convertita in corrente alternata AC',size=17)\nplt.ylabel('Potenza DC  convertita (%)',fontsize=14,color='red')\nplt.axhline(losses['losses'].mean(),linestyle='--',color='gray',label='Media')\nplt.legend()\nplt.show()","4cd1f7d2":"losses.mean()","43781f46":"losses=p2gd.copy()\nlosses['day']=losses['DATE_TIME'].dt.date\nlosses=losses.groupby('day').sum()\nlosses['losses']=losses['AC_POWER']\/losses['DC_POWER']*100\n\nlosses['losses'].plot(style='o--',figsize=(17,5),label='Potenza effettiva')\n\nplt.title('% di potenza DC convertita in corrente alternata AC',size=17)\nplt.ylabel('Potenza DC  convertita (%)',fontsize=14,color='red')\nplt.axhline(losses['losses'].mean(),linestyle='--',color='gray',label='Media')\nplt.legend()\nplt.show()","910f61eb":"losses","9bb6dd1f":"dc_gen=p1gd.copy()\ndc_gen['time']=dc_gen['DATE_TIME'].dt.time\ndc_gen=dc_gen.groupby(['time','SOURCE_KEY'])['DC_POWER'].mean().unstack()\n\ncmap = sns.color_palette(\"Set2\", n_colors=12)\n\nfig,ax=plt.subplots(ncols=2,nrows=1,dpi=100,figsize=(20,6))\ndc_gen.iloc[:,0:11].plot(ax=ax[0],color=cmap)\ndc_gen.iloc[:,11:22].plot(ax=ax[1],color=cmap)\n\nax[0].set_title('Primi 11 inverter')\nax[0].set_ylabel('DC POWER ( kW )',fontsize=17,color='navy')\nax[1].set_title('Ultimi 11 inverter')\nplt.show()","0baf2b30":"# Import all available data \ndf_gen1 = pd.read_csv(\"..\/input\/solar-power-generation-data\/Plant_1_Generation_Data.csv\")\ndf_gen2 = pd.read_csv(\"..\/input\/solar-power-generation-data\/Plant_2_Generation_Data.csv\")\ndf_weather1 = pd.read_csv(\"..\/input\/solar-power-generation-data\/Plant_1_Weather_Sensor_Data.csv\")\ndf_weather2 = pd.read_csv(\"..\/input\/solar-power-generation-data\/Plant_2_Weather_Sensor_Data.csv\")\n# adjust datetime format\ndf_gen1['DATE_TIME'] = pd.to_datetime(df_gen1['DATE_TIME'],format = '%d-%m-%Y %H:%M')\ndf_weather1['DATE_TIME'] = pd.to_datetime(df_weather1['DATE_TIME'],format = '%Y-%m-%d %H:%M:%S')\n\n# drop unnecessary columns and merge both dataframes along DATE_TIME\ndf_plant1 = pd.merge(df_gen1.drop(columns = ['PLANT_ID']), df_weather1.drop(columns = ['PLANT_ID', 'SOURCE_KEY']), on='DATE_TIME')\n# add inverter number column to dataframe\nsensorkeys = df_plant1.SOURCE_KEY.unique().tolist() # unique sensor keys\nsensornumbers = list(range(1,len(sensorkeys)+1)) # sensor number\ndict_sensor = dict(zip(sensorkeys, sensornumbers)) # dictionary of sensor numbers and corresponding keys\n\n# add column\ndf_plant1['SENSOR_NUM'] = 0\nfor i in range(df_gen1.shape[0]):\n    df_plant1['SENSOR_NUM'][i] = dict_sensor[df_gen1[\"SOURCE_KEY\"][i]]\n\n# add Sensor Number as string\ndf_plant1[\"SENSOR_NAME\"] = df_plant1[\"SENSOR_NUM\"].apply(str) # add string column of sensor name\n# adding separate time and date columns\ndf_plant1[\"DATE\"] = pd.to_datetime(df_plant1[\"DATE_TIME\"]).dt.date # add new column with date\ndf_plant1[\"TIME\"] = pd.to_datetime(df_plant1[\"DATE_TIME\"]).dt.time # add new column with time\n\n# add hours and minutes for ml models\ndf_plant1['HOURS'] = pd.to_datetime(df_plant1['TIME'],format='%H:%M:%S').dt.hour\ndf_plant1['MINUTES'] = pd.to_datetime(df_plant1['TIME'],format='%H:%M:%S').dt.minute\ndf_plant1['MINUTES_PASS'] = df_plant1['MINUTES'] + df_plant1['HOURS']*60\n\n# add date as string column\ndf_plant1[\"DATE_STR\"] = df_plant1[\"DATE\"].astype(str) # add column with date as string\ndf_plant1.head()","91392100":"fig = px.scatter(df_plant1, x=\"TIME\", y=\"DC_POWER\", title=\"DC Power: Daily Distribution\", color = \"DATE_STR\")\nfig.update_traces(marker=dict(size=5, opacity=0.7), selector=dict(mode='markers'))\nfig.show()","11552f19":"fig = px.scatter(df_plant1, x=\"TIME\", y=\"IRRADIATION\", title=\"Irradiation: Daily Distribution\", color = \"DATE_STR\")\nfig.update_traces(marker=dict(size=5, opacity=0.7), selector=dict(mode='markers'))\nfig.show()","468812d3":"\ntemp_gen1=p1gd.copy()\n\ntemp_gen1['time']=temp_gen1['DATE_TIME'].dt.time\ntemp_gen1['day']=temp_gen1['DATE_TIME'].dt.date\n\ntemp_sens1=p1wd.copy()\n\ntemp_sens1['time']=temp_sens1['DATE_TIME'].dt.time\ntemp_sens1['day']=temp_sens1['DATE_TIME'].dt.date\n\n\np1gd_time_grp= temp_gen1.groupby(['time']).sum()\np1gd_time_grp\n\n\n","3787d264":"temp_gen2=p2gd.copy()\ntemp_gen2['time']=temp_gen2['DATE_TIME'].dt.time\ntemp_gen2['day']=temp_gen2['DATE_TIME'].dt.date\ntemp_sens2=p1wd.copy()\ntemp_sens2['time']=temp_sens2['DATE_TIME'].dt.time\ntemp_sens2['day']=temp_sens2['DATE_TIME'].dt.date\np2gd_time_grp = temp_gen2.groupby(['time']).sum()\np2gd_time_grp","17f964e9":"p1gd_time_grp['DAILY_YIELD'].plot(figsize=(20,5))\nplt.title(\"Resa totale di 34 giorni dell'impianto 1 con l'ora indicativa\")\nplt.ylabel('Rendimento in kWH')\n\n","6f38f456":"p1gd_DT = p1gd.groupby(['DATE_TIME'],as_index=False).sum()\np1gd_DT_Select = p1gd_DT[['DATE_TIME','DC_POWER','AC_POWER','DAILY_YIELD']]\np1gd_DT_Select\np1wd_drp = p1wd.drop([ 'SOURCE_KEY'], axis=1)\nmerged_data = pd.merge(p1gd_DT_Select, p1wd_drp, how='inner', on='DATE_TIME')\nmerged_data['time']=merged_data['DATE_TIME'].dt.time\nmerged_data.iloc[25:35]","05543055":"merged_data_Irr = merged_data.copy()\nmerged_data_Irr_t = merged_data_Irr.groupby(['time']).mean()\n\nfig,ax=plt.subplots(ncols=2,nrows=2,dpi=200,figsize=(15,5))\nmerged_data_Irr_t['IRRADIATION'].plot(ax=ax[0,0])\nmerged_data_Irr_t['AMBIENT_TEMPERATURE'].plot(ax=ax[0,1])\nmerged_data_Irr_t['MODULE_TEMPERATURE'].plot(ax=ax[1,0])\nmerged_data_Irr_t['DC_POWER'].plot(ax=ax[1,1])\n\nax[0,0].set_ylabel('IRRADIATION')\nax[0,1].set_ylabel('AMBIENT TEMPERATURE')\nax[1,0].set_ylabel('MODULE TEMPERATURE')\nax[1,1].set_ylabel('DC POWER')","dc7963ad":"merged_data_num = merged_data[['DC_POWER','AC_POWER','DAILY_YIELD','AMBIENT_TEMPERATURE','MODULE_TEMPERATURE','IRRADIATION']]\ncorr = merged_data_num.corr()\nfig_dims = (2, 2) \nsns.heatmap(round(corr,2), annot=True, mask=(np.triu(corr,+1)))","cb86c15a":"plt.figure(figsize=(10,8))\nsolarcorr = solar.corr()\nsns.heatmap(solarcorr, cmap='YlGnBu', annot=True)\nplt.show()","00065222":"#Genera una linea di regressione con un adattamento per escludere i valori anomali\nimport seaborn as sns; sns.set_theme(color_codes=True)\nax = sns.regplot(x='Cloud Cover', y='Energy Discharged (Wh)', data=solar, robust=True)","fe6cda4a":"IBM_path = '..\/input\/residential-solar-vs-weather-nc-usa\/Weather_and_energy_Final_2020_2021.csv'\ndf = pd.read_csv(IBM_path, delimiter = ',', usecols=['Date time','Energy Discharged (Wh)', 'Snow', 'Snow Depth', 'Visibility', 'Cloud Cover'])","032d4179":"#df.sort_values('Date time', inplace=True)\n# replace 0 to avoid dividing by 0 later on\ndf['Energy Discharged (Wh)'].replace(to_replace=0, method='ffill', inplace=True) \ndf['Snow'].replace(to_replace=0, method='ffill', inplace=True) \ndf['Snow Depth'].replace(to_replace=0, method='ffill', inplace=True) \ndf['Visibility'].replace(to_replace=0, method='ffill', inplace=True) \ndf['Cloud Cover'].replace(to_replace=0, method='ffill', inplace=True) \ndf.sort_values('Date time', inplace=True)\n\n# Apply moving average with a window of 10 days to all columns\ndf[['Energy Discharged (Wh)', 'Snow', 'Snow Depth', 'Visibility', 'Cloud Cover']]= df[['Energy Discharged (Wh)', 'Snow', 'Snow Depth', 'Visibility', 'Cloud Cover']].ewm(span=10, adjust=False).mean()\n# Drop all rows with NaN values\ndf.dropna(how='any', axis=0, inplace=True) \ndf.head()","d487472f":"fig = plt.figure(figsize=(30,10))\nst = fig.suptitle(\"Energy Discharged (Wh)\", fontsize=20)\nst.set_y(0.92)\npred_df=df.groupby('Date time').sum()\npred_df=pred_df['Energy Discharged (Wh)'].reset_index()\npred_df.set_index('Date time',inplace=True)\n#df = df.drop(df[<some boolean condition>].index)\npred_df.drop(pred_df[pred_df['Energy Discharged (Wh)']>30000].index, inplace=True)\nplt.figure(figsize=(25,10))\nplt.plot(pred_df,label='Addestramento')\nplt.title('Energy Discharged (Wh)',fontsize=17)\n\nplt.legend()\nplt.show()","f68aadf4":"#Adding a second independent variable\nimport statsmodels.api as sm\n\nX = solar[['Snow', 'Snow Depth',\"Visibility\", \"Cloud Cover\", ]]\ny = solar[\"Energy Discharged (Wh)\"]\nsolar_model = sm.OLS(y, X).fit()\npredictions = solar_model.predict(X) \nsolar_model.summary()","a8044fb7":"#Compare model to energy output\nplt.figure(figsize=(30,10))\nax = solar_model.predict(X).plot(label=\" Predicted\")\nax2 = ax.twinx()\nax.plot(solar['Energy Discharged (Wh)'], 'mediumseagreen', marker='.', label=\"Energia reale\")\nplt.tight_layout()\nax.legend(loc=\"best\")\nplt.show()","020f26e9":"print(' MAE Score: %f' % (mean_absolute_error(y ,predictions)))\nprint('-'*15)\nprint(' RMSE Score: %f' % (mean_squared_error(y,predictions,squared=False)))","ab770747":"from fbprophet import Prophet\npred_gen=p1gd.copy()\npred_gen=pred_gen.groupby('DATE_TIME')['DAILY_YIELD'].sum().reset_index()\npred_gen.rename(columns={'DATE_TIME':'ds','DAILY_YIELD':'y'},inplace=True)\npred_gen.plot(x='ds',y='y',figsize=(20,10))\nplt.title('DAILY_YIELD',size=17)\nplt.show()","6747b7e2":"import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas\nimport math\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import LSTM\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error\n","3bdb8651":"\npred_g1=p1gd.copy()\npred_g1=pred_g1.groupby('DATE_TIME').sum()\npred_g1=pred_g1['DAILY_YIELD'].reset_index()\npred_g1.set_index('DATE_TIME',inplace=True)\npred_g1\n\ntrain=pred_g1[:3158]\ntest=pred_g1[-1042:]\n#67% e 33%\nplt.figure(figsize=(20,10))\nplt.plot(train,label='Addestramento')\nplt.plot(test,label='Test', color='green')\nplt.title('Giorni totali di rendimento giornaliero',fontsize=17)\nplt.legend()\nplt.show()","8b300d76":"def create_dataset(dataset, look_back=1):\n\tdataX, dataY = [], []\n\tfor i in range(len(dataset)-look_back-1):\n\t\ta = dataset[i:(i+look_back), 0]\n\t\tdataX.append(a)\n\t\tdataY.append(dataset[i + look_back, 0])\n\treturn np.array(dataX), np.array(dataY)","133055c9":"# split into train and test sets\ndataframe= pred_g1[\"DAILY_YIELD\"]\ndataset = dataframe.values\ndataset = dataset.astype('float32')\ndataset= dataset.reshape(-1, 1)\n\n# normalize the dataset\nscaler = MinMaxScaler(feature_range=(0, 1))\ndataset = scaler.fit_transform(dataset)\n\n# split into train and test sets\ntrain_size = int(len(dataset) * 0.67)\ntest_size = len(dataset) - train_size\n\ntrain= dataset[0:train_size]\ntest = dataset[train_size:len(dataset)]\n\nlook_back = 1\ntrainX, trainY = create_dataset(train, look_back)\ntestX, testY = create_dataset(test, look_back)\n\n# reshape input to be [samples, time steps, features]\ntrainX = np.reshape(trainX, (trainX.shape[0], 1, trainX.shape[1]))\ntestX = np.reshape(testX, (testX.shape[0], 1, testX.shape[1]))","6824f03b":"# create and fit the LSTM network\nmodel = Sequential()\nmodel.add(LSTM(4, input_shape=(1, look_back)))\nmodel.add(Dense(1))\nmodel.compile(loss='mean_squared_error', optimizer='adam')\nmodel.fit(trainX, trainY, epochs=10, batch_size=1, verbose=2)","fa3186b4":"# make predictions\ntrainPredict = model.predict(trainX)\ntestPredict = model.predict(testX)\n# invert predictions\ntrainPredict = scaler.inverse_transform(trainPredict)\ntrainY = scaler.inverse_transform([trainY])\ntestPredict = scaler.inverse_transform(testPredict)\ntestY = scaler.inverse_transform([testY])\n\n\n# calculate root mean squared error\ntrainScore = math.sqrt(mean_squared_error(trainY[0], trainPredict[:,0]))\nprint('Train Score: %.2f RMSE' % (trainScore))\ntestScore = math.sqrt(mean_squared_error(testY[0], testPredict[:,0]))\nprint('Test Score: %.2f RMSE' % (testScore))\nprint('-'*15)\nprint('MAE Train Score: %f' % (mean_absolute_error(trainY[0], trainPredict[:,0])))\nprint('MAE Test Score: %f' % (mean_absolute_error(testY[0], testPredict[:,0])))\nprint('-'*15)\nprint('Prophet Train R2 Score: %f' % (r2_score(trainY[0], trainPredict[:,0])))\nprint('Prophet Test R2 Score: %f' % (r2_score(testY[0], testPredict[:,0])))\n","d76139ea":"# shift train predictions for plotting\ntrainPredictPlot = np.empty_like(dataset)\ntrainPredictPlot[:, :] = np.nan\ntrainPredictPlot[look_back:len(trainPredict)+look_back, :] = trainPredict\n# shift test predictions for plotting\ntestPredictPlot = np.empty_like(dataset)\ntestPredictPlot[:, :] = np.nan\ntestPredictPlot[len(trainPredict)+(look_back*2)+1:len(dataset)-1, :] = testPredict\n# plot baseline and predictions\nfig,ax= plt.subplots(ncols=1,nrows=1,dpi=100,figsize=(30,10))\nplt.plot(scaler.inverse_transform(dataset))\nplt.plot(trainPredictPlot)\nplt.plot(testPredictPlot)\nplt.show()","fdbef247":"p = Prophet()\np.fit(pred_gen)\n\nfuture = [pred_gen['ds'].iloc[-1:] + DateOffset(minutes=x) for x in range(0,2910,15)]\ntime1=pd.DataFrame(future).reset_index().drop('index',1)\ntime1.rename(columns={3157:'ds'},inplace=True)\n\ntimeline=pd.DataFrame(pred_gen['ds'])\nfut=timeline.append(time1,ignore_index=True)\n\nforecast = p.predict(fut)","35061362":"p.plot(forecast,figsize=(30,10))\nplt.legend(labels=['Dati reali','Prediction'])\nplt.title('Predizioni')\nplt.show()","3fc02015":"fig1 = p.plot_components(forecast)","0f78029b":"from sklearn.metrics import r2_score,mean_squared_error,mean_absolute_error\ntest2=pd.DataFrame(pred_gen)\ntest2.rename(columns={'DATE_TIME':'ds'},inplace=True)\ntest_prophet=p.predict(test2)","2ad1f5d0":"pred_gen2=p1gd.copy()\npred_gen2=pred_gen2.groupby('DATE_TIME')['DAILY_YIELD'].sum().reset_index()","b18ff98a":"print('Prophet R2 Score: %f' % (r2_score(pred_gen2['DAILY_YIELD'],test_prophet['yhat'])))\nprint('-'*15)\nprint('Prophet MAE Score: %f' % (mean_absolute_error(pred_gen2['DAILY_YIELD'],test_prophet['yhat'])))\nprint('-'*15)\nprint('Prophet RMSE Score: %f' % (mean_squared_error(pred_gen2['DAILY_YIELD'],test_prophet['yhat'],squared=False)))","46ded637":"# Funzione per controllare se l'ora \u00e8 durante il funzionamento diurno\ndef time_in_range(start, end, x):\n    \"\"\"Return true if x is in the range [start, end]\"\"\"\n    if start <= end:\n        return start <= x <= end\n    else:\n        return start <= x or x <= end\n    \nstart=datetime.time(6,30,0) # alba\nend=datetime.time(17,30,0) # tramonto\n\n# Crea una nuova colonna per verificare il corretto funzionamento\n# Restituisce \"Normale\" se il funzionamento \u00e8 normale e \"Guasto\" se il funzionamento \u00e8 difettoso\ndf_plant1[\"STATUS\"] = 0\nfor index in df_plant1.index:\n    if  time_in_range(start, end, df_plant1[\"TIME\"][index]) and df_plant1[\"DC_POWER\"][index] == 0:\n        df_plant1[\"STATUS\"][index] = \"Guasto\"\n    else:\n        df_plant1[\"STATUS\"][index] = \"Normale\"","8e68cce6":"df_plant1","52cad943":"fig = px.scatter(df_plant1, x=\"IRRADIATION\", y=\"DC_POWER\", title=\"Identificazione dei guasti\", color=\"STATUS\", labels={\"DC_POWER\":\"Potenza DC (kW)\", \"IRRADIATION\":\"Irradiazione\"})\nfig.update_traces(marker=dict(size=3, opacity=0.7), selector=dict(mode='marker'), color='navy')\nfig.show()\n","fc28a7f6":"df_plant1[df_plant1[\"STATUS\"]== \"Guasto\"][\"DATE\"].value_counts()","8a733b46":"df_plant1.STATUS.value_counts()","d8ccfbee":"fig=px.bar(df_plant1[df_plant1[\"STATUS\"]== \"Guasto\"][\"SOURCE_KEY\"].value_counts(), title=\"Guasti inverter\", labels={\"value\":\"Guasti\", \"index\":\"Inverter\", \"SENSOR_NAME\":\"Inverter\"})\nfig.update(layout_showlegend=False)","4b8c4191":"print(\"La maggior parte dei guasti \u00e8 stata registrata su {} e {}.\" .format(df_plant1[df_plant1[\"STATUS\"]== \"Guasto\"][\"DATE\"].value_counts().index[0], df_plant1[df_plant1[\"STATUS\"]== \"Guasto\"][\"DATE\"].value_counts().index[1]))\nprint(\"Gli inverter {} e {} hanno avuto il maggior numero di guasti.\" .format(df_plant1[df_plant1[\"STATUS\"]== \"Guasto\"][\"SOURCE_KEY\"].value_counts().index[0],df_plant1[df_plant1[\"STATUS\"]== \"Guasto\"][\"SOURCE_KEY\"].value_counts().index[1]))","2bec48c7":"from sklearn.linear_model import LinearRegression\n\n# Modello\nreg = LinearRegression()\n\n# training data\ntrain_dates = [\"2020-05-16\", \"2020-05-17\",\"2020-05-18\" ,\"2020-05-19\", \"2020-05-20\", \"2020-05-21\"]\ndf_train = df_plant1[df_plant1[\"DATE_STR\"].isin(train_dates)]\n\n#previsione e adattamento\nreg.fit(df_train[[\"IRRADIATION\"]], df_train.DC_POWER)\nprediction = reg.predict(df_plant1[[\"IRRADIATION\"]])\n\n# salva previsione, residuo e residuo assoluto\ndf_train[\"Prediction\"] = reg.predict(df_train[[\"IRRADIATION\"]])\ndf_train[\"Residual\"] = df_train[\"Prediction\"] - df_train[\"DC_POWER\"]\ndf_plant1[\"Prediction\"] = reg.predict(df_plant1[[\"IRRADIATION\"]])\ndf_plant1[\"Residual\"] = df_plant1[\"Prediction\"] - df_plant1[\"DC_POWER\"]\ndf_plant1[\"Residual_abs\"] = df_plant1[\"Residual\"].abs()","bc2e26e2":"def func(X, a, b, c, d):\n    '''Funzione non lineare per prevedere l'uscita di potenza CC dall'irradiazione e dalla temperatura.'''\n    x,y = X\n    x=x*1000\n    y=y*1000\n    return a*x*(1-b*(y+x\/800*(c-20)-25)-d*np.log(x+1e-10))\n\n# funzione adattamento\np0 = [1.,0.,-1.e4,-1.e-1] # avvio valori\npopt, pcov = curve_fit(func, (df_train.IRRADIATION, df_train.MODULE_TEMPERATURE), df_train.DC_POWER, p0, maxfev=5000)\nsigma_abcd = np.sqrt(np.diagonal(pcov))\n\n# predizioni e salvataggio\ndf_train[\"Prediction_NL\"] = func((df_train.IRRADIATION, df_train.MODULE_TEMPERATURE), *popt)\ndf_train[\"Residual_NL\"] = df_train[\"Prediction_NL\"] - df_train[\"DC_POWER\"]\n\ndf_plant1[\"Prediction_NL\"] = func((df_plant1.IRRADIATION, df_plant1.MODULE_TEMPERATURE), *popt)\ndf_plant1[\"Residual_NL\"] = df_plant1[\"Prediction_NL\"] - df_plant1[\"DC_POWER\"]","f2cc6902":"plt.figure(figsize=(20,7))\nplt.scatter(df_plant1.IRRADIATION, df_plant1.DC_POWER, label=\"Misurazioni\")\nplt.scatter(df_plant1.IRRADIATION, df_plant1.Prediction_NL, color=\"r\", label=\"Predizioni NL\")\nplt.legend()\nplt.xlabel(\"Irradiazione (kW\/m\u00b2)\")\nplt.ylabel(\"Potenza DC(kW)\")\nplt.title(\"Modello Predizione NL\")\nplt.legend();","3763c1e7":"data_T_start=pd.read_csv(\"..\/input\/wind-turbine-scada-dataset\/T1.csv\")\ndata_T_start","e8f7f090":"data1_T=data_T_start.copy()\ndata_T_start.rename(columns={'LV ActivePower (kW)':'Potenza attiva (kW)',\"Wind Speed (m\/s)\":\"Velocit\u00e0 vento(m\/s)\",\"Theoretical_Power_Curve (KWh)\":\"Curva Potenza Teorica (KWh)\",\"Wind Direction (\u00b0)\":\"Direzione Vento\"},\n                inplace=True)\ndata1_T.rename(columns={'LV ActivePower (kW)':'Potenza attiva (kW)',\"Wind Speed (m\/s)\":\"Velocit\u00e0 vento(m\/s)\",\"Theoretical_Power_Curve (KWh)\":\"Curva Potenza Teorica (KWh)\",\"Wind Direction (\u00b0)\":\"Direzione Vento\"},\n                inplace=True)\ndata1_T.rename(columns={'Date\/Time':'Tempo'},inplace=True)","1307026e":"#funzione per ricerca del mese\ndef find_month(x):\n    if \" 01 \" in x:\n        return \"Gen\"\n    elif \" 02 \" in x:\n        return \"Feb\"\n    elif \" 03 \" in x:\n        return \"Mar\"    \n    elif \" 04 \" in x:\n        return \"Apr\"    \n    elif \" 05 \" in x:\n        return \"Mag\"    \n    elif \" 06 \" in x:\n        return \"Giu\"    \n    elif \" 07 \" in x:\n        return \"Lug\"    \n    elif \" 08 \" in x:\n        return \"Ago\"    \n    elif \" 09 \" in x:\n        return \"Set\"    \n    elif \" 10 \" in x:\n        return \"Ott\"    \n    elif \" 11 \" in x:\n        return \"Nov\"    \n    else:\n        return \"Dic\"    \n    #aggiunge mese al dataset\ndata1_T['Mese']=data1_T.Tempo.apply(find_month)\ndata1_T.head()","f5830e65":"#funzione per riscrivere la velocit\u00e0 del vento per intervalli di 0,5.\ndef mean_speed(x):\n    list=[]\n    i=0.25\n    while i<=25.5:\n        list.append(i)\n        i+=0.5\n    for i in list:\n        if x < i:\n            x=i-0.25\n            return x","b7b2d64d":"data1_T[\"Media Velocit\u00e0 vento\"]=data1_T[\"Velocit\u00e0 vento(m\/s)\"].apply(mean_speed)\ndata1_T.head()","a14c275b":"#funzione per riscrivere la direzione del vento per 30 intervalli.\ndef mean_direction(x):\n    list=[]\n    i=15\n    while i<=375:\n        list.append(i)\n        i+=30\n        \n    for i in list:\n        if x < i:\n            x=i-15\n            if x==360:\n                return 0\n            else:\n                return x","2f4c2766":"data1_T[\"Direzione media\"]=data1_T[\"Direzione Vento\"].apply(mean_direction)\ndata1_T.head()","c5030bd4":"#funzione per la direzione del vento\ndef find_direction(x):\n    if x==0:\n        return \"NORD\"\n    if x==30:\n        return \"NNE\"\n    if x==60:\n        return \"NEE\" \n    if x==90:\n        return \"EST\" \n    if x==120:\n        return \"SEE\" \n    if x==150:\n        return \"SSE\" \n    if x==180:\n        return \"SUD\" \n    if x==210:\n        return \"SSW\" \n    if x==240:\n        return \"SWW\" \n    if x==270:\n        return \"OVEST\" \n    if x==300:\n        return \"NWW\" \n    if x==330:\n        return \"NNW\"\n  ","832d0174":"data1_T[\"Direzione\"]=data1_T[\"Direzione media\"].apply(find_direction)\ndata1_T.head()","b9512aca":"#Rimuoviamo i dati che indicano che la velocit\u00e0 del vento \u00e8 inferiore a 3,5 e superiore a 25,5\n#Lo facciamo poich\u00e8 secondo la curva di potenza della turbina a livello domestico, la turbina lavora solo tra questi valori.\ndata2_T=data1_T[(data1_T[\"Velocit\u00e0 vento(m\/s)\"]>3.5) & (data1_T[\"Velocit\u00e0 vento(m\/s)\"]<=25.5)]","06990a1c":"#Numero di valori in cui la velocit\u00e0 del vento \u00e8 maggiore di 3,5 e la potenza attiva \u00e8 0.\n#Se la velocit\u00e0 del vento \u00e8 maggiore di 3,5 e la potenza attiva \u00e8 zero, significa che la turbina \u00e8 fuori servizio.\n\nlen(data2_T[\"Potenza attiva (kW)\"][(data2_T[\"Potenza attiva (kW)\"]==0)&(data2_T[\"Velocit\u00e0 vento(m\/s)\"]>3.5)])\n","2463ee27":"data3_T=data2_T[((data2_T[\"Potenza attiva (kW)\"]!=0)&(data2_T[\"Velocit\u00e0 vento(m\/s)\"]>3.5)) | (data2_T[\"Velocit\u00e0 vento(m\/s)\"]<=25.5)]","e4b7efcd":"from math import radians\n\nplt.figure(figsize=(8,8))\nax = plt.subplot(111, polar=True)\n# All'interno dei cerchi ci sono la velocit\u00e0 del vento e il colore e la dimensione dell'indicatore rappresenta la quantit\u00e0 di produzione di energia\nsns.scatterplot(x=[radians(x) for x in data2_T['Direzione Vento']], \n                y=data2_T['Velocit\u00e0 vento(m\/s)'],\n                size=data2_T['Potenza attiva (kW)'],\n                hue=data2_T['Potenza attiva (kW)'],\n                alpha=0.7, legend=None)\n# L'impostazione della parte superiore del diagramma polare rappresenta il Nord\nax.set_theta_zero_location('N')\n# Imposto -1 per avviare la direzione del vento in senso orario\nax.set_theta_direction(-1)\nax.set_rlabel_position(110)\nplt.title('Velocit\u00e0 del vento - Direzione del vento - Diagramma di produzione di energia \\n\\n\\n')\nplt.ylabel(None);","8bcba92c":"data3_T[\"Curva Potenza Teorica (KWh)\"][data3_T[\"Media Velocit\u00e0 vento\"]==5.5].mean()","05a67717":"data_T_clean=data3_T.sort_values(\"Tempo\")\ndata_T_clean[\"Valore Perdita(kW)\"]=data_T_clean[\"Curva Potenza Teorica (KWh)\"]-data_T_clean[\"Potenza attiva (kW)\"]\ndata_T_clean[\"Perdita(%)\"]=data_T_clean[\"Valore Perdita(kW)\"]\/data_T_clean[\"Curva Potenza Teorica (KWh)\"]*100\ndata_T_clean=data_T_clean.round({'Potenza attiva (kW)': 2, 'Velocit\u00e0 vento(m\/s)': 2, 'Curva Potenza Teorica (KWh)': 2,\n                                   'Direzione Vento': 2, 'Valore Perdita(kW)': 2, 'Perdita': 2})\n\ndata_T_clean.head()","becece52":"#creazione di dataframe di velocit\u00e0 di riepilogo da dati puliti.\nDepGroupT_speed = data_T_clean.groupby(\"Media Velocit\u00e0 vento\")\ndata_T_speed=DepGroupT_speed.mean()\n#rimuoviamo le colonne non necessarie\ndata_T_speed.drop(columns={\"Velocit\u00e0 vento(m\/s)\",\"Direzione Vento\",\"Direzione media\"},inplace=True)\n#creiamo una colonna della velocit\u00e0 del vento dai valori dell'indice.\nlistTspeed_WS=data_T_speed.index.copy()\ndata_T_speed[\"Velocit\u00e0 vento(m\/s)\"]=listTspeed_WS\n\ndata_T_speed=data_T_speed[[\"Velocit\u00e0 vento(m\/s)\",\"Potenza attiva (kW)\",\"Curva Potenza Teorica (KWh)\",\"Valore Perdita(kW)\",\"Perdita(%)\"]]\ndata_T_speed[\"Index\"]=list(range(1,len(data_T_speed.index)+1))\ndata_T_speed.set_index(\"Index\",inplace=True)\ndata_T_speed=data_T_speed.round({\"Velocit\u00e0 vento(m\/s)\": 1, 'Potenza attiva (kW)': 2, 'Curva Potenza Teorica (KWh)': 2, 'Valore Perdita(kW)': 2, 'Perdita(%)': 2})\n#creando una colonna di conteggio che mostra il numero di velocit\u00e0 del vento da dati puliti.\ndata_T_speed[\"count\"]=[len(data_T_clean[\"Media Velocit\u00e0 vento\"][data_T_clean[\"Media Velocit\u00e0 vento\"]==i]) \n                        for i in data_T_speed[\"Velocit\u00e0 vento(m\/s)\"]]\ndata_T_speed","1b813e39":"#creazione di dataframe di velocit\u00e0 di riepilogo da dati puliti.\nDepGroupT_direction = data_T_clean.groupby(\"Direzione\")\ndata_T_direction=DepGroupT_direction.mean()\n#rimuoviamo le colonne non necessarie\ndata_T_direction.drop(columns={\"Velocit\u00e0 vento(m\/s)\",\"Direzione Vento\"},inplace=True)\n#creo un index\nlistTdirection_Dir=data_T_direction.index.copy()\ndata_T_direction[\"Direzione\"]=listTdirection_Dir\n\ndata_T_direction[\"Velocit\u00e0 vento(m\/s)\"]=data_T_direction[\"Media Velocit\u00e0 vento\"]\ndata_T_direction.drop(columns={\"Media Velocit\u00e0 vento\"},inplace=True)\n#cambiamo il posto delle colonne.\ndata_T_direction=data_T_direction[[\"Direzione\",\"Direzione media\",\"Potenza attiva (kW)\",\"Curva Potenza Teorica (KWh)\",\"Velocit\u00e0 vento(m\/s)\",\n                                     \"Valore Perdita(kW)\",\"Perdita(%)\"]]\n#cambiamo l'indice dei numeri\ndata_T_direction[\"Index\"]=list(range(1,len(data_T_direction.index)+1))\ndata_T_direction.set_index(\"Index\",inplace=True)\n#create a count column that shows the number of directions from clean data.\ndata_T_direction[\"count\"]=[len(data_T_clean[\"Direzione\"][data_T_clean[\"Direzione\"]==i]) \n                        for i in data_T_direction[\"Direzione\"]]\n#arrotondiamo i valori a 2 cifre\ndata_T_direction=data_T_direction.round({'Velocit\u00e0 vento(m\/s)': 1,'Potenza attiva (kW)': 2, 'Curva Potenza Teorica (KWh)': 2,\n                                           'Valore Perdita(kW)': 2, 'Perdita(%)': 2})\n\ndata_T_direction=data_T_direction.sort_values(\"Direzione media\")\ndata_T_direction.drop(columns={\"Direzione media\"},inplace=True)\ndata_T_direction","5a6fe314":"#Disegno grafico delle potenze medie in base alla direzione del vento.\ndef bar_graph():\n    turbine_no=\"T1\"\n    fig = plt.figure(figsize=(20,10))\n    plt.bar(data_T_direction[\"Direzione\"],data_T_direction[\"Curva Potenza Teorica (KWh)\"],label=\"Curva Potenza Teorica (KWh)\",align=\"edge\",width=0.3)\n    plt.bar(data_T_direction[\"Direzione\"],data_T_direction[\"Potenza attiva (kW)\"],label=\"Curva di potenza effettiva\",align=\"edge\",width=-0.3)\n    plt.xlabel(\"Direzione Vento\")\n    plt.ylabel(\"Potenza (kW)\")\n    plt.title(\"Impianto eolico {} Valori medi di potenza rispetto alla direzione\".format(turbine_no))\n    plt.legend()\n    plt.show()\nbar_graph()","7cb7a744":"#creazione di dataframe di velocit\u00e0 di riepilogo da dati puliti.\ndata_T_direction_total=data_T_direction.copy()\n#rimuoviamo le colonne non necessarie\ndata_T_direction_total.drop(columns={\"count\",\"Potenza attiva (kW)\",\"Curva Potenza Teorica (KWh)\",\"Valore Perdita(kW)\",\"Perdita(%)\"},inplace=True)\n\ndata_T_direction_total[\"Generazione totale(MWh)\"]=data_T_direction[\"Potenza attiva (kW)\"]*data_T_direction[\"count\"]\/6000\ndata_T_direction_total[\"Generazione teorica totale(MWh)\"]=data_T_direction[\"Curva Potenza Teorica (KWh)\"]*data_T_direction[\"count\"]\/6000\ndata_T_direction_total[\"Perdita Totale(MWh)\"]=data_T_direction_total[\"Generazione teorica totale(MWh)\"]-data_T_direction_total[\"Generazione totale(MWh)\"]\ndata_T_direction_total[\"Perdita(%)\"]=data_T_direction_total[\"Perdita Totale(MWh)\"]\/data_T_direction_total[\"Generazione teorica totale(MWh)\"]*100\n#arrotondiamo i valori a 2 cifre\ndata_T_direction_total=data_T_direction_total.round({'Velocit\u00e0 vento(m\/s)': 1,'Generazione totale(MWh)': 2, 'Generazione teorica totale(MWh)': 2,\n                                           'Perdita Totale(MWh)': 2, 'Perdita(%)': 2})\n#cambiamo il posto delle colonne.\ndata_T_direction_total=data_T_direction_total[[\"Direzione\",\"Generazione totale(MWh)\",\"Generazione teorica totale(MWh)\",\"Velocit\u00e0 vento(m\/s)\",\n                                     \"Perdita Totale(MWh)\",\"Perdita(%)\"]]\ndata_T_direction_total","0fa35aca":"def bar_graph():\n    turbine_no=\"T1\"\n    fig = plt.figure(figsize=(20,10))\n    plt.bar(data_T_direction_total[\"Direzione\"],data_T_direction_total[\"Generazione teorica totale(MWh)\"],label=\"Curva Potenza Teorica (KWh)\",align=\"edge\",width=0.3)\n    plt.bar(data_T_direction_total[\"Direzione\"],data_T_direction_total[\"Generazione totale(MWh)\"],label=\"Curva di potenza effettiva\",align=\"edge\",width=-0.3)\n    plt.xlabel(\"Direzione Vento\")\n    plt.ylabel(\"Generazione Energia (MWh)\")\n    plt.title(\"Impianto eolico {} Valori di generazione totale di energia rispetto alla direzione\".format(turbine_no))\n    plt.legend()\n    plt.show()\nbar_graph()","a660d881":"#Disegno grafico della perdita totale in base alla direzione del vento.\ndef bar_graph():\n    turbine_no=\"T1\"\n    fig = plt.figure(figsize=(20,10))\n    plt.bar(data_T_direction_total[\"Direzione\"],data_T_direction_total[\"Perdita Totale(MWh)\"],\n            label=\"Perdita totale(MWh)\",align=\"center\",width=0.5, color=\"lightgreen\",picker=5)\n    plt.xlabel(\"Direzione Vento\")\n    plt.ylabel(\"Totale perdita(MWh)\")\n    plt.title(\"Impianto eolico {} Valori di perdita totale rispetto alla direzione\".format(turbine_no))\n    plt.legend()\n    plt.show()\nbar_graph()","ef89bfea":"#correlazione tra i valori\ncorr = data_T_start.corr()\nplt.figure(figsize=(10, 8))\nax = sns.heatmap(corr, vmin = -1, vmax = 1, annot = True)\nbottom, top = ax.get_ylim()\nax.set_ylim(bottom + 0.5, top - 0.5)\nplt.show()\ncorr","1a42d01d":"# Configuraione Spark\nspark = SparkSession.builder.master(\"local\").appName(\"wind_turbine_project\").getOrCreate()\nsc = spark.sparkContext\n# Lettura dataset come Spark DataFrame\nData1_start = spark.read.csv('..\/input\/wind-turbine-scada-dataset\/T1.csv', header=True, inferSchema=True)\nData1_start.cache()\nData1_start = Data1_start.toDF(*[c.lower() for c in Data1_start.columns])\n# Estrazione mese ora e giorno dallo Spark\n\nData1_start = Data1_start.withColumn(\"month\", substring(\"date\/time\", 4,2))\nData1_start = Data1_start.withColumn(\"hour\", substring(\"date\/time\", 12,2))\n\n\n# Conversione in intero \nData1_start = Data1_start.withColumn('month', Data1_start.month.cast(IntegerType()))\nData1_start = Data1_start.withColumn('hour', Data1_start.hour.cast(IntegerType()))\n# Campione casuale dai big data\nsample_df = Data1_start.sample(withReplacement=False, fraction=0.1, seed=42).toPandas()\n\n# lv activepower (kw) in label\nData1_start = Data1_start.withColumn('label', Data1_start['lv activepower (kw)'])\n# variabili da utilizzare\nvariables = ['month', 'hour', 'wind speed (m\/s)', 'wind direction (\u00b0)']\nvectorAssembler = VectorAssembler(inputCols = variables, outputCol = 'features')\nva_df = vectorAssembler.transform(Data1_start)\n\nfinal_df = va_df.select('features', 'label')\nsplits = final_df.randomSplit([0.8, 0.2])\ntrain_df = splits[0]\ntest_df = splits[1]\n\n# creazione modello GBM\ngbm = GBTRegressor(featuresCol='features', labelCol='label')\n\n#Allenamento del modello\ngbm_model = gbm.fit(train_df)\n\n# Predizioni sul test_df\ny_pred = gbm_model.transform(test_df)\n","2381194b":"Data1_start.select('wind speed (m\/s)', 'lv activepower (kw)')\\\n.filter(Data1_start['wind speed (m\/s)'] >= 20)\\\n.filter(Data1_start['wind speed (m\/s)'] <= 25 )\\\n.agg({'lv activepower (kw)':'mean'}).show()","7d67d00d":"print('Train dataset: ', train_df.count())\nprint('Test dataset : ', test_df.count())","9e08f605":"test_df","e8b21fe4":"# Initial model success\nfrom pyspark.ml.evaluation import RegressionEvaluator\n\nevaluator = RegressionEvaluator(predictionCol='prediction', labelCol='label')\n\nprint('R2 SCORE : ', evaluator.evaluate(y_pred, {evaluator.metricName: 'r2'}))\nprint('MAE      : ', evaluator.evaluate(y_pred, {evaluator.metricName: 'mae'}))\nprint('RMSE     : ', evaluator.evaluate(y_pred, {evaluator.metricName: 'rmse'}))","d5749a93":"# Converto sample_df in Spark dataframe\neva_df = spark.createDataFrame(sample_df)\n#  lv activepower (kw) in label\neva_df = eva_df.withColumn('label', eva_df['lv activepower (kw)'])\n# Variabili da utilizzare\nvariables = ['month', 'hour', 'wind speed (m\/s)', 'wind direction (\u00b0)']\nvectorAssembler = VectorAssembler(inputCols = variables, outputCol = 'features')\nvec_df = vectorAssembler.transform(eva_df)\n# Combino features e label\nvec_df = vec_df.select('features', 'label')\n# Modello ML \npreds = gbm_model.transform(vec_df)\npreds_df = preds.select('label','prediction').toPandas()\n\n# Concateno i dataframes \nframes = [sample_df[['wind speed (m\/s)', 'theoretical_power_curve (kwh)']], preds_df]\nsample_data = pd.concat(frames, axis=1)\n\n# Visual Potenza Reale, teorica e predizione \nplt.figure(figsize=(10,7))\nsns.scatterplot(x='wind speed (m\/s)', y='label',alpha=0.5, label= 'Potenza reale', data=sample_data)\nsns.scatterplot(x='wind speed (m\/s)', y='prediction', alpha=0.7, label='Predizione', marker='o', color='pink', data=sample_data)\nsns.lineplot(x='wind speed (m\/s)', y='theoretical_power_curve (kwh)', label='Potenza Teorica',color='purple', data=sample_data)\nplt.title('Previsione della produzione di energia della turbina eolica')\nplt.ylabel('Produzione di energia (kw)')\nplt.xlabel('Velocit\u00e0 vento(m\/s)')\nplt.legend();","3701e519":"MedOraria = Data1_start.groupby('hour').mean('lv activepower (kw)').sort('avg(lv activepower (kw))').toPandas()\nsns.barplot(x='hour', y='avg(lv activepower (kw))', data=MedOraria)\nplt.xlabel('Orario')\nplt.ylabel('Media Potenza Attiva (Kw)')\nplt.title('Produzione media oraria di energia');","e931146b":"# Average power production by month\nmonthly = Data1_start.groupby('month').mean('lv activepower (kw)').sort('avg(lv activepower (kw))').toPandas()\nsns.barplot(x='month', y='avg(lv activepower (kw))', data=monthly)\nplt.xlabel('Mese')\nplt.ylabel('Media Potenza Attiva (Kw)')\nplt.title('Media Potenza Attiva mensile');","06b421a9":"sample_df['DATE_TIME']= pd.to_datetime(sample_df['date\/time'],format='%d %m %Y %H:%M')\nsample_df[\"DATE\"] = pd.to_datetime(sample_df[\"DATE_TIME\"]).dt.date # add new column with date\n\nsample_df['Mese']=pd.to_datetime(sample_df[\"DATE_TIME\"]).dt.month\nsample_df['Giorno']=pd.to_datetime(sample_df[\"DATE_TIME\"]).dt.day \nsample_df['hour']=pd.to_datetime(sample_df[\"DATE_TIME\"]).dt.hour\n\n\nFinalPred=sample_df.drop('month', axis = 1)\nFinalPred=sample_df.drop('hour', axis = 1)\nFinalPred\n","3f13717c":"# Converto sample_df in Spark dataframe\neva_df = spark.createDataFrame(FinalPred)\n#  lv activepower (kw) in label\neva_df = eva_df.withColumn('label', eva_df['lv activepower (kw)'])\n# Variabili da utilizzare\nvariables = ['Mese', 'Giorno', 'wind speed (m\/s)', 'wind direction (\u00b0)']\nvectorAssembler = VectorAssembler(inputCols = variables, outputCol = 'features')\nvec_df = vectorAssembler.transform(eva_df)\n# Combining features and label column\nvec_df = vec_df.select('features', 'label')\n# Modello ML \npreds = gbm_model.transform(vec_df)\npreds_df = preds.select('label','prediction').toPandas()\n\n# Concateno i  dataframes \nframes = [FinalPred[['Mese', 'Giorno','wind speed (m\/s)', 'theoretical_power_curve (kwh)', \"DATE\"]], preds_df]\nsample_data1 = pd.concat(frames, axis=1)\nsample_data1= sample_data1.groupby(['DATE']).sum()\nsample_data1","9923fb37":"y_actual= sample_data1[\"label\"]\ny_predicted= sample_data1[\"prediction\"]\ny_theorical= sample_data1[\"theoretical_power_curve (kwh)\"]\n\n# Visual Potenza Reale, teorica e predizione \nplt.figure(figsize=(30,10))\nsns.lineplot(x='DATE', y=y_actual, label= 'Potenza reale',color='navy', data=sample_data1)\nsns.lineplot(x='DATE', y=y_theorical, label='Potenza Teorica',color='red', data=sample_data1)\nsns.lineplot(x='DATE', y=y_predicted, label='Predizione', color='Green', data=sample_data1)\nplt.title('Previsione della produzione di energia della turbina eolica')\nplt.ylabel('Produzione di energia (kw)')\nplt.xlabel('Giorno')\nplt.legend();","28f019e0":"print(' R2 Score: %f' % (r2_score(sample_data1[\"label\"],sample_data1[\"prediction\"])))\nprint('-'*15)\nprint(' MAE Score: %f' % (mean_absolute_error(sample_data1[\"label\"],sample_data1[\"prediction\"])))\nprint('-'*15)\nprint(' RMSE Score: %f' % (mean_squared_error(sample_data1[\"label\"],sample_data1[\"prediction\"],squared=False)))","ab25240e":"## **Impianti PV e impianti eolici** \n\nL'obiettivo di questo studio \u00e8 quello di rilevare come un impianto fotovoltaico o eolico incida sull'efficientamento energetico, inoltre, quanto un malfunzionamento possa incidere su quest'ultimo. \nEsamineremo in particolare i valori di un anno sulla generazione di energia residenziale e sui dati metereologici","15a3650b":"Innanzitutto, combiniamo le variabili metereologiche alle variabili dei pannelli fotovoltaici","95a93468":"Possiamo osservare dai grafici come mediamente Irradiazione, Temperatura Ambiente, Temperatura Modulo e Potenza DC prima aumentano e poi diminuiscono dall'alba al tramonto.\nGeneralmente la temperatura del modulo aumenta con l'aumento della temperatura e dell'irraggiamento.\n","538e0480":"La generazione di corrente continua \u00e8 correlata in modo altamente positivo con l'irradiazione, la temperatura del modulo e la temperatura ambiente.\n\nTuttavia, non si dovrebbe concludere qui che la generazione di energia DC aumenta con l'aumento della temperatura del modulo poich\u00e9 sappiamo che l'efficienza del modulo solare diminuisce con l'aumento della temperatura. ","c76e2044":"# Prediction LSTM","3b371a2f":"## Prediction ","fd1add18":"A questo punto il nostro obbiettivo \u00e8 calcolare la perdita. La perdita \u00e8 la differenza tra Nordex_Powercurve e la potenza attiva.","5bacc9d2":"### Correlazione tra le variabili ","ee1d35c1":"Nell' Impianto 2 la generazione minima di corrente continua e alternata (AC\/DC) \u00e8 0kW in assenza di luce solare\/irradiazione.\nLa massima generazione di potenza DC \u00e8 1420,93 kW associata a 1 SOURCE_KEY\/Inverter.\nIl rendimento giornaliero massimo per inverter \u00e8 9873 kWHr.","75d3a161":"Analizziamo i due **ambienti** dei due impianti, dove SOURCE_KEY \u00e8 l'unit\u00e0 di monitoraggio metereologico in posizione ottimale dei singoli impianti.","d1488c47":"## Prediction OLS ","41aa5663":"## Predizioni","54195bad":"Possiamo notare chiaramente che **1BY6WEcLGh8j5v7** e **bvBOhCH3iADSZry** hanno prestazioni inferiori ad altri inverter.\nForse questi inverter richiedono manutenzione o devono essere sostituiti. ","c5940b66":"# Analisi della potenza di una turbina eolica a livello domestico (Microeolico)","09060f80":"# Influenza degli agenti atmosferici sui pannelli","264caac5":"Sembra che in alcuni giorni ci siano stati problemi con l'impianto:\ntra il 19-05-2020 e il 21-05-2020 possiamo vedere un periodo con degli sbalzi nelle curve dovuti a malfunzionamenti, nella generazione di corrente continua. Quindi \u00e8 confermato un guasto negli inverter.","1349bd66":"Dalla heatmap possiamo notare che la copertura nuvolosa (Cloud Cover) \u00e8 il valore pi\u00f9 correlato con la scarica di energia (Energy Dischaged).","43861a26":"## ","fb5cf510":"# **Impianto 1 e Impianto 2 - I confronti**\nAnalizziamo i due impianti fotovoltaici, dove SOURCE_KEY \u00e8 la singola unit\u00e0 di condizionamento.\nIn questo caso i dati generati sono registrati con un intevallo metereologico di 15 minuti.","39368614":"Sembra che l'alimentazione AC e l'alimentazione DC non siano nella stessa unit\u00e0 di potenza. Perch\u00e9 in genere l'efficienza dell'inverter (AC\/DC) \u00e8 superiore al 95%, il che non \u00e8 questo il caso.\n\n","535ab91a":"Possiamo chiaramente notare dunque, che la copertura del cielo pu\u00f2 enormemente influenzare l'energia scaricata dai pannelli.","01033fc2":"Attraverso la distribuzione dei dati possiamo osservare la generazione di energia e le varie condizioni metereologiche. Si hanno bassi livelli di energia in prossimit\u00e0 di condizioni meteo nuuvolose. Le condizioni di scarico di energia rimangono distrete.","3638a509":"Possiamo subito notare che gli inverter dell'impianto 1 appaiono ampiamente stabili nella potenza AC generata. \nGli inverter dell'impianto 2, tuttavia, fluttuano selvaggiamente. Ci\u00f2 potrebbe essere dovuto a diversi fattori, ma \u00e8 probabilme che la manutenzione possa essere un problema di quest'ultimo impianto. Un rapido sguardo alla deviazione standard dei dati in queste cifre quantifica meglio la misura in cui i dati fluttuano.","87a910ce":"# Prediction in Prophet"}}