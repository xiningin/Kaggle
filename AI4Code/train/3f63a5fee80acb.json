{"cell_type":{"1e3e9e42":"code","d8547ac9":"code","53903f0f":"code","6ca87490":"code","7076a621":"code","abeee4d0":"code","4e0dcb3f":"code","75eb09c3":"code","103b1269":"code","aea095cd":"code","df859295":"code","0ee89f95":"code","d4c3930a":"code","c82395d6":"code","c182c9bb":"code","82b28c0a":"code","e1033420":"code","5a22c9c1":"markdown","0b0af8dd":"markdown","c0dbc5b5":"markdown","f02fd66d":"markdown","b0d5eea6":"markdown","784dd619":"markdown","252c6bb7":"markdown","5f2da67a":"markdown","afee6857":"markdown","4e6de5c4":"markdown","2d70f975":"markdown","8027cd0e":"markdown","b56dc067":"markdown"},"source":{"1e3e9e42":"from fastai.tabular import *","d8547ac9":"path = Path('..\/input\/house-prices-advanced-regression-techniques')\noutput_path = Path('..\/working')\n\ndf = pd.read_csv(path\/'train.csv')\ntest_df = pd.read_csv(path\/'test.csv')\n\nlen(df), len(test_df)","53903f0f":"df.info()","6ca87490":"df.describe()","7076a621":"df.head()","abeee4d0":"dep_var = 'SalePrice'\nprocs = [FillMissing, Categorify, Normalize]","4e0dcb3f":"cont_names = ['1stFlrSF', '2ndFlrSF', '3SsnPorch', 'BedroomAbvGr',\n 'EnclosedPorch', 'Fireplaces', 'FullBath',\n 'GarageYrBlt', 'GrLivArea',\n 'HalfBath', 'KitchenAbvGr', \n 'LotArea', 'LotFrontage', 'LowQualFinSF', 'MasVnrArea',\n 'OpenPorchSF', 'PoolArea', 'ScreenPorch',\n 'TotRmsAbvGrd', 'WoodDeckSF']\n\ncat_names = ['MSSubClass', 'MSZoning', 'Street', 'Alley', 'LotShape', 'LandContour', 'Utilities', 'LotConfig', 'LandSlope',\n           'Neighborhood', 'Condition1', 'Condition2', 'BldgType', 'HouseStyle', 'OverallQual', 'OverallCond', 'YearBuilt',\n           'YearRemodAdd', 'RoofStyle', 'RoofMatl', 'Exterior1st', 'Exterior2nd', 'MasVnrType', 'ExterQual', 'ExterCond', \n           'Foundation', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2', 'Heating', 'HeatingQC', 'CentralAir',\n           'Electrical', 'Functional', 'FireplaceQu', 'GarageType', 'GarageFinish', 'GarageQual', 'GarageCond', 'PavedDrive',\n           'PoolQC', 'Fence', 'MiscFeature', 'MiscVal', 'MoSold', 'YrSold', 'SaleType', 'SaleCondition', 'BsmtQual', 'KitchenQual']\n","75eb09c3":"test = TabularList.from_df(test_df, path=path, cat_names=cat_names, cont_names=cont_names, procs=procs)","103b1269":"data = (TabularList.from_df(df, path=output_path, cat_names=cat_names, cont_names=cont_names, procs=procs)\n                           .split_by_idx(list(range(600,800)))\n                           #.split_by_rand_pct(0.2)\n                           .label_from_df(cols=dep_var, label_cls=FloatList, log=True)\n                           .add_test(test)\n                           .databunch())","aea095cd":"data.show_batch(rows=10)","df859295":"max_log_y = np.log(np.max(df[dep_var])*1.2)\ny_range = torch.tensor([0, max_log_y], device=defaults.device)","0ee89f95":"learn = tabular_learner(data, layers=[200,100], y_range=y_range, ps=[0.05, 0.1], metrics=exp_rmspe)","d4c3930a":"learn.lr_find()\nlearn.recorder.plot()","c82395d6":"learn.fit(80, 1e-2)","c182c9bb":"learn.recorder.plot_losses(skip_start=100)","82b28c0a":"learn.recorder.plot_metrics(skip_start=200)","e1033420":"predictions, *_ = learn.get_preds(DatasetType.Test)\nlabels = np.exp(predictions.data).numpy().T[0]\n\nsub_df = pd.DataFrame({'Id': test_df['Id'], 'SalePrice': labels})\nsub_df.to_csv(output_path\/'submission.csv', index=False)","5a22c9c1":"dep_var = the target variable\n\nprocs = preprocesses built in fastai\n\nThe big job here is separating the columns into continous- and categorical value types.","0b0af8dd":"# Create databunch","c0dbc5b5":"# Create model","f02fd66d":"## Create the dataset\nI chose to create a validation set by a set slice of the data instead of a random split, for a more comparable validation.\n\nSince this is a regression problem, for our target variable, we tell fastai that it is a list of floats that we have taken the logarithm of.","b0d5eea6":"# Intro\n\nThis kernel is meant to show you how I used the fast.ai library in the House Price competition without using any manual feature engineering. The only preprocessing made is the builtin methods Categorize, FillMissing and Normalize. \n\nThe number of epochs and learning rate gave me a good result after some experimenting, but I think you can do even better!","784dd619":"# Predictions and submission","252c6bb7":"The model has two layers with specified dropout probabilities for each (ps).\nAs metric I used exp_rmspe. Tried som a while to get my own RMSLE metric function (as used for the competition) to work, but without success.","5f2da67a":"## Create the test set","afee6857":"Get predictions frpom the test data set with get_preds. The model is trained on the log of the target value, here we calculate the real values to submit to the competition.","4e6de5c4":"# Explore data","2d70f975":"To further help the model, here we specify the range for the target variable.","8027cd0e":"# Setup","b56dc067":"Show the ready databunch. All categorical variables have been mapped to ints behind the scenes, but fastai is showing the strings."}}