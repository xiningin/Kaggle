{"cell_type":{"ee86d874":"code","956e5bf1":"code","e8e6b451":"code","82779ee6":"code","3c249b90":"code","bbd9042e":"code","eca791bb":"code","c212497f":"code","3d468f1a":"code","fc0aa563":"code","a7e95ff7":"code","77c2d803":"code","5f8aa0b0":"code","0919728c":"code","3c05bcf4":"code","05621159":"code","5c04d67f":"code","35d1d98f":"code","5d421ba4":"code","7ae9b13d":"code","60a0d277":"code","09ef4b3e":"code","41beaf87":"code","ae2dd432":"code","099e77a5":"code","64ed3f10":"code","3eb3bc23":"code","442e2dc3":"code","89e1e5dd":"code","f7ed2c5a":"code","f3ea0b8b":"code","cba1d133":"markdown","4efb1487":"markdown","bc776709":"markdown","a4b34fb2":"markdown","4db5f3e3":"markdown","80589f5a":"markdown","ba3f344f":"markdown","aa436e9e":"markdown","a98042b9":"markdown","5f70eab0":"markdown"},"source":{"ee86d874":"!pip install pyecharts","956e5bf1":"import numpy as np \nimport pandas as pd\nfrom tqdm import tqdm_notebook as tqdm\nfrom pyecharts import options as opts\nfrom pyecharts.charts import Graph\nimport torch\nimport torch.nn.functional as F\nfrom torch.utils.data import Dataset,TensorDataset,DataLoader\nfrom keras.preprocessing import sequence\nfrom transformers import BertTokenizer, BertForSequenceClassification\n\nimport warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)\nwarnings.filterwarnings('ignore')","e8e6b451":"marked_sentence_df = pd.read_csv('\/kaggle\/input\/covid19-knowledge-graph\/marked_sentence.csv')","82779ee6":"marked_sentence_df.sample(5)","3c249b90":"def Build_graph(df,relation=False,repulsion=40,title='COVID-19 knowledge graph',labelShow=False):\n    entity_type_dic = dict(df.drop_duplicates(['start_entity']).set_index(['start_entity'])['start_entity_type'])\n    entity_type_dic.update(dict(df.drop_duplicates(['end_entity']).set_index(['end_entity'])['end_entity_type']))\n    color = {'Disease':'#FF7F50','Gene':'#48D1CC','Chemical':'#B3EE3A'}\n    cate =  {'Disease':0,'Gene':1,'Chemical':2}\n    categories = [{'name':'Disease','itemStyle': {'normal': {'color': color['Disease']}}},{'name':'Gene','itemStyle': {'normal': {'color': color['Gene']}}},{'name':'Chemical','itemStyle': {'normal': {'color': color['Chemical']}}}]\n    nodes = []\n    for entity in list(set(df['start_entity'])|set(df['end_entity'])):\n        nodes.append({'name': entity, 'symbolSize': max(10,np.log1p(df.loc[(df['start_entity']==entity)|(df['end_entity']==entity)].shape[0])*10\/\/1),\n                     'category':cate[entity_type_dic[entity]]})\n    links = []\n    for i in df.index:\n        if not relation:\n            links.append({'source': df.loc[i,'start_entity'], 'target': df.loc[i,'end_entity']})\n        else:\n            links.append({'source': df.loc[i,'start_entity'], 'target': df.loc[i,'end_entity'], 'value':df.loc[i,'pred']})\n    g = (\n        Graph()\n        .add('', nodes, links,categories, repulsion=repulsion,label_opts=opts.LabelOpts(is_show=labelShow))\n        .set_global_opts(title_opts=opts.TitleOpts(title=title),legend_opts=opts.LegendOpts(orient='vertical', pos_left='2%', pos_top='40%',legend_icon='circle'))\n        .render_notebook()\n        )\n    return g","bbd9042e":"g = Build_graph(marked_sentence_df.sample(100),title='subsample of topology graph')\ng","eca791bb":"class Args:\n    task_type = 'chemical-disease'\n    max_seq_len = 64\n    bs = 64\n\nclass Conf:\n    # some information can be found in:\n    # Percha B, Altman R B. A global network of biomedical relationships derived from text[J]. Bioinformatics, 2018, 34(15): 2614-2624.\n    relation_type = {'chemical-disease':['T', 'C', 'Sa', 'Pr', 'Pa', 'J'],\n                     'disease-chemical':['Mp'],\n                     'chemical-gene':['A+', 'A-', 'B', 'E+', 'E-', 'E', 'N'],\n                     'gene-chemical':['O', 'K', 'Z'],\n                     'gene-disease':['U', 'Ud', 'D', 'J', 'Te', 'Y', 'G'],\n                     'disease-gene':['Md', 'X', 'L'],\n                     'gene-gene':['B', 'W', 'V+', 'E+', 'E', 'I', 'H', 'Rg', 'Q'],\n                     }\n\nargs = Args()\nconf = Conf()\ndevice = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\ndevice","c212497f":"# load pretrained Bert model\ndef Bert_model(taskType,bertPath):\n    label_df = pd.read_csv('\/kaggle\/input\/covid19-knowledge-graph\/%s_label.csv'%taskType)\n    tokenizer = BertTokenizer.from_pretrained(bertPath,do_lower_case=False)\n    model = BertForSequenceClassification.from_pretrained(bertPath, num_labels=label_df['label'].nunique())\n    return label_df,tokenizer,model\n\n# bulid data loader\ndef Data_loader(x,y=None,bs=128,shuffle=False,numWorkers=0):\n    if y is not None:\n        data = TensorDataset(x,y)\n    else:\n        data = TensorDataset(x)\n    data_loader = DataLoader(dataset=data,batch_size=bs,shuffle=shuffle,num_workers=numWorkers)\n    return data_loader\n\ndef Prepare_predict_data(tokenizer,bs):\n    marked_sentences = marked_sentence_df.loc[(marked_sentence_df['start_entity_type'].apply(lambda x:x.lower())==args.task_type.split('-')[0])&\\\n                                              (marked_sentence_df['end_entity_type'].apply(lambda x:x.lower())==args.task_type.split('-')[1]),'marked_sentence']\n    # convert tokens to ids\n    ids = marked_sentences.apply(lambda x:tokenizer.convert_tokens_to_ids(tokenizer.tokenize(x))).tolist()\n    # padding ids\n    ids = sequence.pad_sequences(ids,args.max_seq_len, truncating='post', padding='post')\n    # we cannot confirm order of entities, so predict two possibilities\n    reverse_marked_sentences = marked_sentence_df.loc[(marked_sentence_df['start_entity_type'].apply(lambda x:x.lower())==args.task_type.split('-')[0])&\\\n                                              (marked_sentence_df['end_entity_type'].apply(lambda x:x.lower())==args.task_type.split('-')[1]),'marked_sentence']\\\n                                              .apply(lambda x:x.replace('start_entity','init_start_entity').replace('end_entity','start_entity').replace('init_start_entity','end_entity'))\n    reverse_ids = reverse_marked_sentences.apply(lambda x:tokenizer.convert_tokens_to_ids(tokenizer.tokenize(x))).tolist()\n    reverse_ids = sequence.pad_sequences(reverse_ids,args.max_seq_len, truncating='post', padding='post')\n    predict_data_loader = Data_loader(torch.LongTensor(ids),torch.LongTensor(reverse_ids),bs=bs)\n    return marked_sentences.values,predict_data_loader\n\ndef Predict():\n    reverse_task_type = args.task_type.split('-')[1] + '-' + args.task_type.split('-')[0]\n    def Filter(x):\n        if x['init_pred'] in conf.relation_type[args.task_type]:\n            if x['reverse_pred'] not in conf.relation_type[reverse_task_type]:\n                # init_pred is a correct relation but reverse_pred not\n                return 'init_pred'\n            else:\n                # init_pred and reverse_pred both are correct relations\n                if x['init_pred_prob'] >= x['reverse_pred_prob']:\n                    # init_pred_prob greater than or equal to reverse_pred_prob\n                    return 'init_pred'\n                else:\n                    return 'reverse_pred'\n        else:\n            if x['reverse_pred'] not in conf.relation_type[reverse_task_type]:\n                # init_pred and reverse_pred both are uncorrect relations\n                return 'uncorrect'\n            else:\n                # reverse_pred is a correct relation but init_pred not\n                return 'reverse_pred'\n    label_df,tokenizer,model = Bert_model(args.task_type,'\/kaggle\/input\/covid19-knowledge-graph\/%s\/'%args.task_type)\n    marked_sentences,predict_data_loader = Prepare_predict_data(tokenizer,args.bs)\n    model = model.to(device)\n    preds = []\n    preds_prob = []\n    reverse_preds = []\n    reverse_preds_prob = []\n    for data in tqdm(predict_data_loader):\n        ids,reverse_ids = [t.to(device) for t in data]\n        outputs = model(input_ids=ids)\n        logits = outputs[0]\n        pred_prob, pred = torch.max(F.softmax(logits.data,1), 1)\n        preds.extend(list(pred.cpu().detach().numpy()))\n        preds_prob.extend(list(pred_prob.cpu().detach().numpy()))\n        reverse_outputs = model(input_ids=reverse_ids)\n        reverse_logits = reverse_outputs[0]\n        reverse_pred_prob, reverse_pred = torch.max(F.softmax(reverse_logits.data,1), 1)\n        reverse_preds.extend(list(reverse_pred.cpu().detach().numpy()))\n        reverse_preds_prob.extend(list(reverse_pred_prob.cpu().detach().numpy()))\n\n    pred_df = pd.DataFrame({'marked_sentence':marked_sentences,'init_pred':preds,'init_pred_prob':preds_prob,'reverse_pred':reverse_preds,'reverse_pred_prob':reverse_preds_prob})\n    # map label(0, 1, 2...) to raw label(T, C, Sa...) \n    pred_df['init_pred'] = pred_df['init_pred'].replace(dict(label_df.set_index(['label'])['label_raw']))\n    pred_df['reverse_pred'] = pred_df['reverse_pred'].replace(dict(label_df.set_index(['label'])['label_raw']))\n    # judge the order of a pair of entities\n    pred_df['filter'] = pred_df.apply(lambda x:Filter(x), axis=1)\n    pred_df['pred'] = pred_df['init_pred']\n    pred_df['pred_prob'] = pred_df['init_pred_prob']\n    pred_df.loc[pred_df['filter']=='reverse_pred','pred'] = pred_df.loc[pred_df['filter']=='reverse_pred','reverse_pred']\n    pred_df.loc[pred_df['filter']=='reverse_pred','pred_prob'] = pred_df.loc[pred_df['filter']=='reverse_pred','reverse_pred_prob']\n    pred_df = pred_df.loc[pred_df['filter']!='uncorrect']\n    pred_df = marked_sentence_df.merge(pred_df,how='inner',on='marked_sentence')\n    pred_df['init_start_entity'] = pred_df['start_entity']\n    pred_df['init_start_entity_type'] = pred_df['start_entity_type']\n    pred_df.loc[pred_df['filter']=='reverse_pred','start_entity'] = pred_df.loc[pred_df['filter']=='reverse_pred','end_entity']\n    pred_df.loc[pred_df['filter']=='reverse_pred','start_entity_type'] = pred_df.loc[pred_df['filter']=='reverse_pred','end_entity_type']\n    pred_df.loc[pred_df['filter']=='reverse_pred','end_entity'] = pred_df.loc[pred_df['filter']=='reverse_pred','init_start_entity']\n    pred_df.loc[pred_df['filter']=='reverse_pred','end_entity_type'] = pred_df.loc[pred_df['filter']=='reverse_pred','init_start_entity_type']\n    pred_df.drop(['init_start_entity','init_start_entity_type'],axis=1,inplace=True)\n    torch.cuda.empty_cache()\n    return label_df,pred_df","3d468f1a":"# chemical-disease relation prediction\nargs.task_type = 'chemical-disease'\nc_d_label_df,c_d_pred_df = Predict()","fc0aa563":"# chemical-disease relation theme\nc_d_label_df","a7e95ff7":"# chemical-disease classification results\nc_d_pred_df.sample(5)","77c2d803":"# chemical-gene relation prediction\nargs.task_type = 'chemical-gene'\nc_g_label_df,c_g_pred_df = Predict()","5f8aa0b0":"# chemical-gene relation theme\nc_g_label_df","0919728c":"# chemical-gene classification results\nc_g_pred_df.sample(5)","3c05bcf4":"# gene-disease relation prediction\nargs.task_type = 'gene-disease'\ng_d_label_df,g_d_pred_df = Predict()","05621159":"# gene-disease relation theme\ng_d_label_df","5c04d67f":"# gene-disease classification results\ng_d_pred_df.sample(5)","35d1d98f":"# gene-gene relation prediction\nargs.task_type = 'gene-gene'\ng_g_label_df,g_g_pred_df = Predict()","5d421ba4":"# gene-gene relation theme\ng_g_label_df","7ae9b13d":"# gene-gene classification results\ng_g_pred_df.sample(5)","60a0d277":"# chemicl-COVID-19 relations\ng = Build_graph(c_d_pred_df.loc[(c_d_pred_df['start_entity']=='COVID-19')|(c_d_pred_df['end_entity']=='COVID-19')],relation=True,repulsion=800,title='chemical-COVID-19 knowledge graph',labelShow=True)\ng","09ef4b3e":"# gene-COVID-19 relations\ng = Build_graph(g_d_pred_df.loc[(g_d_pred_df['start_entity']=='COVID-19')|(g_d_pred_df['end_entity']=='COVID-19')],relation=True,repulsion=60,title='gene-COVID-19 knowledge graph',labelShow=False)\ng","41beaf87":"# gene-COVID-19 relations\ng = Build_graph(marked_sentence_df.loc[(marked_sentence_df['start_entity']=='COVID-19')&(marked_sentence_df['end_entity_type']=='Disease')|(marked_sentence_df['start_entity_type']=='Disease')&(marked_sentence_df['end_entity']=='COVID-19')],relation=False,repulsion=60,title='disease-COVID-19 topology graph',labelShow=False)\ng","ae2dd432":"# merge all relation prediction and save results\ncols = ['start_entity','end_entity','start_entity_type','end_entity_type','marked_sentence','pred','pred_prob']\nrelation_df = pd.concat([c_d_pred_df[cols],c_g_pred_df[cols],g_d_pred_df[cols],g_g_pred_df[cols]]).append(marked_sentence_df.loc[(marked_sentence_df['start_entity_type'].isin(['Chemical','Disease'])&(marked_sentence_df['start_entity_type']==marked_sentence_df['end_entity_type']))]).reset_index(drop=True)\nrelation_df.loc[(relation_df['pred'].isna())&(relation_df['start_entity_type']=='Chemical'),'pred'] = 'CC'\nrelation_df.loc[(relation_df['pred'].isna())&(relation_df['start_entity_type']=='Disease'),'pred'] = 'DD'\nrelation_df = relation_df[cols]\nrelation_df.to_csv('relation.csv',index=False)","099e77a5":"relation_df","64ed3f10":"# subsample of knowledge graph\ng = Build_graph(relation_df.sample(1000),relation=True,repulsion=15,title='subsample of COVID-19 knowledge graph',labelShow=False)\ng","3eb3bc23":"# 1. What chemicals have Sa(Side effect\/adverse event) to COVID-19 and revelant disease?\n\n# due to a large number of negative words, these predictions may be wrong\nc_d_pred_df.loc[c_d_pred_df['pred']=='Sa']","442e2dc3":"# 2. What genes have U(Causal mutations), Ud(Mutations affect disease course), Y(Polymorphisms alter risk) to COVID-19?\n\n\ng_d_pred_df.loc[(g_d_pred_df['end_entity']=='COVID-19')&(g_d_pred_df['pred'].isin(['U','Ud','Y']))]","89e1e5dd":"# 3. What diseases are associated to COVID-19 (like complication)?\nd_d_df = relation_df.loc[((relation_df['start_entity']=='COVID-19')&(relation_df['end_entity_type']=='Disease'))|((relation_df['start_entity_type']=='Disease')&(relation_df['end_entity']=='COVID-19'))]\nvalue_counts_dic = dict(d_d_df['start_entity'].value_counts())\nend_entity_value_counts_dic = dict(d_d_df['end_entity'].value_counts())\nfor key in end_entity_value_counts_dic:\n    if key in value_counts_dic:\n        value_counts_dic[key] += end_entity_value_counts_dic[key]\n    else:\n        value_counts_dic[key] = end_entity_value_counts_dic[key]\nmost_relevant_disease = []\nfor key in value_counts_dic:\n    if value_counts_dic[key] > 10:\n        most_relevant_disease.append(key)\nrelation_df.loc[((relation_df['start_entity'].isin(most_relevant_disease))&(relation_df['end_entity']=='COVID-19'))|((relation_df['start_entity']=='COVID-19')&(relation_df['end_entity'].isin(most_relevant_disease)))]","f7ed2c5a":"# 1. What chemicals have Pa(Alleviates, reduces), Pr(Prevents, suppresses), T(Treatment\/therapy (incl. investigatory)) to COVID-19 and revelant disease?\n\nc_d_pred_df.loc[(c_d_pred_df['end_entity']=='COVID-19')&(c_d_pred_df['pred'].isin(['Pa','Pr','T']))]","f3ea0b8b":"# 2. What genes have D(Drug targets), G(Promotes progression), J(Role in pathogenesis), Te(Possible therapeutic effect), X(Overexpression in disease) to COVID-19 and revelant disease?\n\ng_d_pred_df.loc[(g_d_pred_df['end_entity']=='COVID-19')&(g_d_pred_df['pred'].isin(['D','G','J','Te','X']))]","cba1d133":"# Acknowledgement\n\nThis work is supported by [Aladdin Healthcare Technologies](https:\/\/aladdinid.com\/)\n<span style=\"display: inline-block;\"> <img src=\"https:\/\/github.com\/jxzly\/Biomedical-Relation-Classification\/blob\/master\/figure\/Aladdin.png?raw=true\" width=40\/><\/span>","4efb1487":"# Show relation between covid-19 and other entities\n\npycharts cannot show multiple relations between two entities, so the graph is incomplete. Complete relations can be seen in ***pred_df***.","bc776709":"## Abstract\n\nRelations between chemicals, genes and disease offer insights into the mechanisms behind higher order biochemical phenomena, such as drug-drug interactions, drug response and gene-disease associations.\nThis work focused on extracting relations between chemicals, genes and disease from research articles to build a biomedical knowledge graph related to COVID-19. We used entities collected by [BioSNAP](http:\/\/snap.stanford.edu\/biodata\/index.html) to identify instances of chemical, gene and disease names in abstracts.\n\nTo understand what relationship types are possible and map unstructured natural language descriptions onto these structured classes, we used labeled sentences in [Percha B 2018](https:\/\/academic.oup.com\/bioinformatics\/article\/34\/15\/2614\/4911883) to classify relations bewteen entities.\nThe source code for classification model can be seen [here](https:\/\/github.com\/jxzly\/Biomedical-Relation-Classification).","a4b34fb2":"# COVID-19 knowledge graph","4db5f3e3":"## What do we know about COVID-19 risk factors?","80589f5a":"## What do we know about vaccines and therapeutics?","ba3f344f":"# Future work\n\nThe classification model is just a baseline. We will enrich medical vocabulary and do further fune-tuning. On the other hand, reasoning unknown relations is an important application of knowledge graph. We are trying to find candidate drugs or other treatments for COVID-19 via graph embedding techniques.","aa436e9e":"# Results and answer for task","a98042b9":"# Classify relations\n\n[Percha B 2018](https:\/\/academic.oup.com\/bioinformatics\/article\/34\/15\/2614\/4911883) revealed 10 broad themes for chemical-gene relations, 7 for chemical-disease, 10 for gene-disease and 9 for gene\u2013gene in Medline abstracts. We used these labeled sentences to train a model to classify sentences in this work. As we cannot confirm order of entities, we predicted two possibilities(init_pred and reverse_pred) and retrieved the higher one. The details can be seen [here](https:\/\/github.com\/jxzly\/Biomedical-Relation-Classification)\n","5f70eab0":"# Load marked sentences\n\nThese sentences containing more than two biomedical entities were extracted from abstracts. We combined the pairwise entities in each sentence to build relations.\n"}}