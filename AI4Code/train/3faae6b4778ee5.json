{"cell_type":{"4abfa27f":"code","13713f98":"code","e4659c2a":"code","a5884e79":"code","6a4484c6":"code","a8e4a97d":"code","467c8bd7":"code","752ded19":"code","27d50b00":"code","679b6ce2":"code","6a252409":"code","d238996a":"code","17645349":"code","0323945f":"code","4109cc1d":"code","0b650798":"code","d15dc210":"code","9a3f32ca":"code","fa7e23ac":"code","20eae273":"code","063bde31":"code","96fc7dee":"code","9af21d86":"code","0ee9d7f6":"code","ac80722c":"markdown","fa197aba":"markdown","01c11607":"markdown","68d5c0c4":"markdown","283eb72c":"markdown","cbbfafcc":"markdown","8e55d0ae":"markdown","073c147b":"markdown","d0c32edc":"markdown","67bc04ed":"markdown","1061f843":"markdown","7e896828":"markdown","c6643dcd":"markdown","17885e73":"markdown","7ae239d2":"markdown","d0426269":"markdown","5748fbb2":"markdown","0bfacb8c":"markdown","cac7bd88":"markdown","afca8479":"markdown","1acfde71":"markdown","89b43239":"markdown","9b6de5db":"markdown","84775ea1":"markdown","3332474c":"markdown","5c4144d5":"markdown","c196e1f6":"markdown","8fe8832a":"markdown","1c903888":"markdown","a2cd50ab":"markdown"},"source":{"4abfa27f":"# Installing EfficientNet module \n!pip install efficientnet","13713f98":"# Computation Specific\nimport re\nimport os\nimport numpy as np\nimport pandas as pd\nfrom functools import partial\n\n# Machine Learning Specific\nimport tensorflow as tf\nfrom kaggle_datasets import KaggleDatasets\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import auc\nfrom tensorflow.keras.callbacks import ReduceLROnPlateau\nfrom tensorflow.keras.callbacks import CSVLogger\n\n\n# Augmentation and Visualization Specific\nimport imgaug\nimport matplotlib.pyplot as plt\n\n# Pretrained Model\nimport efficientnet.tfkeras as efn\n\n\nTPU_used = True\nif TPU_used:\n    try:\n        tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n        print('Device:', tpu.master())\n        tf.config.experimental_connect_to_cluster(tpu)\n        tf.tpu.experimental.initialize_tpu_system(tpu)\n        strategy = tf.distribute.experimental.TPUStrategy(tpu)\n    except:\n        strategy = tf.distribute.get_strategy()\n    print('Number of replicas:', strategy.num_replicas_in_sync)\n    \nprint(tf.__version__)","e4659c2a":"AUTOTUNE = tf.data.experimental.AUTOTUNE\nGCS_PATH = KaggleDatasets().get_gcs_path()\nBATCH_SIZE = 8 * strategy.num_replicas_in_sync\nIMAGE_SIZE = [1024, 1024]","a5884e79":"TRAINING_FILENAMES, VALID_FILENAMES = train_test_split(\n    tf.io.gfile.glob(GCS_PATH + '\/tfrecords\/train*.tfrec'),\n    test_size=0.2, random_state=42\n)\nTEST_FILENAMES = tf.io.gfile.glob(GCS_PATH + '\/tfrecords\/test*.tfrec')\nprint('Train TFRecord Files:', len(TRAINING_FILENAMES))\nprint('Validation TFRecord Files:', len(VALID_FILENAMES))\nprint('Test TFRecord Files:', len(TEST_FILENAMES))","6a4484c6":"def decode_image(image):\n    image = tf.image.decode_jpeg(image, channels=3)\n    image = tf.cast(image, tf.float32) \/ 255.0\n    image = tf.reshape(image, [*IMAGE_SIZE, 3])\n    return image","a8e4a97d":"def read_tfrecord(example, labeled):\n    tfrecord_format = {\n        \"image\": tf.io.FixedLenFeature([], tf.string),\n        \"target\": tf.io.FixedLenFeature([], tf.int64)\n    } if labeled else {\n        \"image\": tf.io.FixedLenFeature([], tf.string),\n        \"image_name\": tf.io.FixedLenFeature([], tf.string)\n    }\n    example = tf.io.parse_single_example(example, tfrecord_format)\n    image = decode_image(example['image'])\n    if labeled:\n        label = tf.cast(example['target'], tf.int32)\n        return image, label\n    idnum = example['image_name']\n    return image, idnum","467c8bd7":"def load_dataset(filenames, labeled=True, ordered=False):\n    ignore_order = tf.data.Options()\n    dataset = tf.data.TFRecordDataset(filenames,num_parallel_reads=AUTOTUNE) \n    dataset = dataset.map(partial(read_tfrecord, labeled=labeled),num_parallel_calls=AUTOTUNE)\n    if not ordered:\n        ignore_order.experimental_deterministic = False \n        dataset.with_options(ignore_order)\n    return dataset","752ded19":"def augmentation_pipeline(image,label):\n    image = tf.image.convert_image_dtype(image,tf.float32)\n    image  =tf.image.random_flip_up_down(image)\n    image = tf.image.random_brightness(image,max_delta=0.5)    \n    return image,label\n\n#image = tf.image.random_brightness(image,max_delta=0.3)\n#image = tf.image.random_flip_left_right(image)\n#image  =tf.image.random_flip_up_down(image)\n#image = tf.image.random_saturation(image,3,8)","27d50b00":"class Dataset():\n    \n    def __init__(self,batch_size):\n        self.batch_size = batch_size\n    \n    def get_dataset(self,filenames,labeled,ordered,mode=\"train\"):\n        \n        assert(mode in [\"train\",\"valid\",\"test\"])    # Checking if the mode is one of the correct ones.\n        \n        # Prepairing dataset according to the provided mode.\n        \n        dataset = load_dataset(filenames, labeled=labeled,ordered=ordered)\n        if mode==\"train\":\n            dataset = dataset.map(augmentation_pipeline)\n            dataset = dataset.repeat()\n            dataset = dataset.shuffle(2048)\n        \n        dataset = dataset.batch(self.batch_size)\n        dataset = dataset.prefetch(AUTOTUNE)\n                                                    \n        if mode==\"valid\":\n            dataset = dataset.cache()\n            \n        return dataset\n    ","679b6ce2":"def count_data_items(filenames):\n    n = [int(re.compile(r\"-([0-9]*)\\.\").search(filename).group(1)) for filename in filenames]\n    return np.sum(n)\n\n\nNUM_TRAINING_IMAGES = count_data_items(TRAINING_FILENAMES)\nNUM_VALIDATION_IMAGES = count_data_items(VALID_FILENAMES)\nNUM_TEST_IMAGES = count_data_items(TEST_FILENAMES)\nSTEPS_PER_EPOCH = NUM_TRAINING_IMAGES \/\/ BATCH_SIZE\nprint(\n    'Dataset: {} training images, {} validation images, {} unlabeled test images and the steps per epoch is {}'.format(\n        NUM_TRAINING_IMAGES, NUM_VALIDATION_IMAGES, NUM_TEST_IMAGES, STEPS_PER_EPOCH\n    )\n)","6a252409":"# Note that learning rate first increase till 10 epochs and then reduces as the epoch increases.\ndef build_lrfn(lr_start=0.00001, lr_max=0.000075, lr_min=0.0000001, lr_rampup_epochs=5, lr_sustain_epochs=0, lr_exp_decay=.8):\n    lr_max = lr_max * strategy.num_replicas_in_sync\n    def lrfn(epoch):\n        if epoch < lr_rampup_epochs:\n            lr = (lr_max - lr_start) \/ lr_rampup_epochs * epoch + lr_start\n        elif epoch < lr_rampup_epochs + lr_sustain_epochs:\n            lr = lr_max\n        else:\n            lr = (lr_max - lr_min) * lr_exp_decay ** (epoch - lr_rampup_epochs - lr_sustain_epochs) + lr_min\n        return lr\n    return lrfn","d238996a":"def Callbacks():\n    cb = []\n    \n    # Drop based LR Scheduling.\n    reducelr = ReduceLROnPlateau(monitor=\"val_loss\", mode=\"min\", patience=5, min_lr = 1e-06, factor=0.2)\n    log = CSVLogger(\"Melanoma_classification.csv\")\n    cb.append(reducelr)\n    cb.append(log)\n    return cb","17645349":"def make_model(output_bias = None, metrics = None):\n    \n    if output_bias is not None:\n        output_bias = tf.keras.initializers.Constant(output_bias)\n        \n    base_model = efn.EfficientNetB7(input_shape=(*IMAGE_SIZE, 3),\n                                             include_top=False,\n                                             weights=\"imagenet\")\n    \n    base_model.trainable = False\n    \n    model = tf.keras.Sequential([\n        base_model,\n        tf.keras.layers.Conv2D(64,kernel_size=(3,3),activation=\"relu\"),\n        tf.keras.layers.GlobalAveragePooling2D(),\n        tf.keras.layers.Dense(32,activation=\"relu\"),\n        tf.keras.layers.Dropout(0.2),\n        tf.keras.layers.Dense(16,activation=\"relu\"),\n        tf.keras.layers.Dense(8,activation=\"relu\"),\n        tf.keras.layers.Dense(1, activation='sigmoid',\n                              bias_initializer=output_bias\n                             )\n    ])\n    \n    lr_schedule = tf.keras.optimizers.schedules.InverseTimeDecay(\n                                                  0.001,\n                                                  decay_steps=(NUM_TRAINING_IMAGES \/\/ BATCH_SIZE)*100,\n                                                  decay_rate=1,\n                                                  staircase=False\n                                                )\n\n    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=lr_schedule),\n                  loss='binary_crossentropy',\n                  metrics=[metrics])\n    \n    return model","0323945f":"dataset = Dataset(BATCH_SIZE)\ntrain_dataset = dataset.get_dataset(TRAINING_FILENAMES,labeled = True,ordered = False,mode=\"train\")\nvalid_dataset = dataset.get_dataset(VALID_FILENAMES,labeled = True,ordered = False,mode=\"valid\")","4109cc1d":"train_csv = pd.read_csv('..\/input\/siim-isic-melanoma-classification\/train.csv')\ntest_csv = pd.read_csv('..\/input\/siim-isic-melanoma-classification\/test.csv')\n\ntotal_img = train_csv['target'].size\n\nmalignant = np.count_nonzero(train_csv['target'])\nbenign = total_img - malignant\n\nprint('Examples:\\n    Total: {}\\n    Positive: {} ({:.2f}% of total)\\n'.format(\n    total_img, malignant, 100 * malignant \/ total_img))","0b650798":"initial_bias = np.log([malignant\/benign])\ninitial_bias","d15dc210":"weight_for_0 = (1 \/ benign)*(total_img)\/2.0 \nweight_for_1 = (1 \/ malignant)*(total_img)\/2.0\n\nclass_weight = {0: weight_for_0, 1: weight_for_1}\n\nprint('Weight for class 0: {:.2f}'.format(weight_for_0))\nprint('Weight for class 1: {:.2f}'.format(weight_for_1))","9a3f32ca":"lrfn = build_lrfn()\nSTEPS_PER_EPOCH = NUM_TRAINING_IMAGES \/\/ BATCH_SIZE\nVALID_STEPS = NUM_VALIDATION_IMAGES \/\/ BATCH_SIZE","fa7e23ac":"with strategy.scope():\n    model = make_model(metrics=tf.keras.metrics.AUC(name='auc'),output_bias=initial_bias)","20eae273":"callback = Callbacks()\n\nhistory = model.fit(\n    train_dataset, epochs=20,\n    steps_per_epoch=STEPS_PER_EPOCH,\n    validation_data=valid_dataset,\n    validation_steps=VALID_STEPS,\n    callbacks= [tf.keras.callbacks.CSVLogger(\"Melanoma_classification.csv\")],\n    class_weight=class_weight,\n    verbose=1\n)\n# tf.keras.callbacks.LearningRateScheduler(lrfn)\n# tf.keras.callbacks.CSVLogger(\"Melanoma_classification_new.csv\")","063bde31":"## Visualizing Model Performance\ndef visualize(epochs,x,y,label=\"\"):\n    plt.plot(epochs,x,marker=\"o\",c=\"red\",label=f\"Training {label}\")\n    plt.plot(epochs,y,marker=\"x\",c=\"green\",label=f\"Validation {label}\")\n    plt.legend()\n    plt.grid(False)\n\nvisualize_df = pd.read_csv(\"\/kaggle\/working\/Melanoma_classification.csv\")\nepochs       = visualize_df[\"epoch\"]\nauc          = visualize_df[\"auc\"]\nval_auc      = visualize_df[\"val_auc\"]\nloss         = visualize_df[\"loss\"]\nval_loss     = visualize_df[\"val_loss\"]\n\nfig = plt.figure(figsize=(12,4))\nplt.subplot(1,2,1)\nvisualize(epochs,auc,val_auc,label=\"AUC\")\nplt.subplot(1,2,2)\nvisualize(epochs,loss,val_loss,label=\"LOSS\")\nplt.tight_layout()\nplt.show()","96fc7dee":"# Getting test Dataset.\n# Note that here test dataset is ordered. \ntest_ds = dataset.get_dataset(TEST_FILENAMES,labeled=False,ordered=True,mode=\"test\")","9af21d86":"%%time\ndef submit(filename=\"submission.csv\"):\n    print('Generating submission.csv file...')\n    print('Computing predictions...')\n    test_images_ds = test_ds.map(lambda image, idnum: image)\n    probabilities = model.predict(test_images_ds)\n    repr(\"Prediction done\")\n    test_ids_ds = test_ds.map(lambda image, idnum: idnum).unbatch()\n    test_ids = next(iter(test_ids_ds.batch(NUM_TEST_IMAGES))).numpy().astype('U')\n    pred_df = pd.DataFrame({'image_name': test_ids, 'target': np.concatenate(probabilities)})\n    sub = pd.read_csv(\"\/kaggle\/input\/siim-isic-melanoma-classification\/sample_submission.csv\")\n    del sub['target']\n    sub = sub.merge(pred_df, on='image_name')\n    sub.to_csv(open(filename,\"w\"), index=False)\n    print(\"Submitted Successfully.....\")","0ee9d7f6":"submit()","ac80722c":"## 4.5 Define Dataset\n<a id=\"9\"><\/a>\nWe define a class named `Dataset` through which we would be getting different datasets for `training`, `validation` and `testing`. <br>\nHere we have implemented a function named `get_dataset` within this class which returns dataset for one of the given mode [`train`,`valid`,`test`].\n\n- Note that most of data preprocessing steps are same for all the three modes. We have also seperated the ones which are specific to a particular mode. ","fa197aba":"# 5) Load Dataset<a id=\"13\"><\/a>\n- **Now we will load the training as well as validation dataset.**","01c11607":"## Thanks For Reading :)","68d5c0c4":"## 4.7.1 Define Learning Rate\n\nThe following function allows for the model to change the learning rate as it runs each epoch. Having a learning rate that is too high will prevent our model from converging. However, having a learning rate that is too small will cause our model to run for far too long. With this function, the model will know how to change its learning rate after each epoch and update the learning rate itself to allow for increased efficiency while still allowing the model to converge.","283eb72c":"# 8) Visualize Scores\n<a id=\"16\"><\/a>\n- **In the following function we would visualize AUC score and loss of the model for both training and validation mode.** ","cbbfafcc":"- **As you can see that 1.76% of malignant samples out of 100% data we have. This clearly is a sign of class imbalanace.** <br>\n\n- **We would correct it by setting initial bias and class weights for the model.**","8e55d0ae":"As we load in our data, we need both our ```X``` and our ```Y```. The X is our image; the model will find features and patterns in our image dataset. We want to predict Y, the probability that the lesion in the image is malignant. When we input our training dataset into the model, it is necessary know what the labels of our images are. For our testing set, we do not need to feed in the labels because the model will predict it for us. In this particular dataset, our label is the ```target``` feature. We will to through our TFRecords and parse out the image and the target values.","073c147b":"# 7) Start Training\n<a id=\"15\"><\/a>\nHere we would take `AUC (Area Under the Curve)` as evaluation metric for our model becuase if the model would have `accuracy` as evaluation metric then it would give false confidence on the model.With predicting all examples as `benign (0)` the model could get **98%** accuracy which is false.\nMoreover the competition scores the model by finding the area under the ROC curve, which is also why our metric will be set to `AUC`.","d0c32edc":"## 6.1 Set initial bias\n\nWe want to set the correct initial bias for our model so that it will not waste time figuring out that there are not many malignant images in our dataset. We want our output layer to reflect the inbalance that we have in our data.\n\nThe correct bias to set can be derived from:\n<pre class=\"tab\">p0 = pos\/(pos+neg) = 1\/(1+ e<sup>-b0<\/sup>)\nb0 = -log(1\/p0 -1)\nb0 = log(pos\/neg)<\/pre>","67bc04ed":"## Import Required Libraries <a id=\"2\"><\/a>\nTo enable training with TPU's we need to configure them first.\n\nHere's what each line of its configration works:\n- `TPUClusterResolver` : Locates the cluster on the network\n- `experimental_connect_to_cluster`: Will make devices on the cluster available to use\n- `initialize_tpu_system`: Initialize the TPU devices.\n- `TPUStrategy`:  Contains necessary distributed training code that will work on TPUs with their 8 compute cores ","1061f843":"## 4.6 Get total number of Train, Validation and Test images.<a id=\"10\"><\/a>\nBelow functions uses a python module named `re` to count the number of images from the given list of Images. <br>\nFor more details on `re` or `Regular Expressions` refer [this](https:\/\/docs.python.org\/3\/library\/re.html).","7e896828":"## #2. Drop Based\n\nIn this approach we change learning rate conditionally. This function introduces discontinuous graph.<br>\n\nFor example if we decrease the learning rate in interval of 10 epochs and considering 100 epochs in total we would get the following graph. Also the learning rate is `0.1` intially.\n\n![image.png](attachment:image.png)\nExample taken from [here](https:\/\/machinelearningmastery.com\/using-learning-rate-schedules-deep-learning-models-python-keras\/). ","c6643dcd":"# 6) Checking for Class Imbalance and correcting it\n<a id=\"14\"><\/a>\nLet's have a look at our dataset to see if it has class Imbalance or not.\n- What is Class Imbalance though? \n<pre class=\"tab\">Basically it is when the ratio between number of samples between classes is either too large or too   small. <\/pre>","17885e73":"## 4.3 Prepare Dataset <a id=\"7\"><\/a>\n- Our dataset is not ordered in any meaningful way, so the order can be ignored when loading our dataset for training. By ignoring the order and reading files as soon as they come in, it will take a shorter time to load the data.\n- Note that the above function `read_tfrecord` is called from `load_dataset` to parse `TfRecord Dataset` to get `tf.Example` object.","7ae239d2":"## 4.7.2 Build base model\n<a id=\"12\"><\/a>\nHere we will use `EfficientNetB0` pretrained model with custom architecture on the top. <br>\nWhat we have just done is called `Transfer Learning`. For more info on transfer learning we recommend [this](https:\/\/towardsdatascience.com\/a-comprehensive-hands-on-guide-to-transfer-learning-with-real-world-applications-in-deep-learning-212bf3b2f27a) article.","d0426269":"# Table of Contents\n\n* [Introduction](#1)\n* [Import Required Libraries](#2)\n* [Configration](#3)\n* [Load the Data](#4)\n* [Utility Functions](#5)\n    * [Decoding the Data](#5)\n    * [Convert TfRecord to tf.Example](#6)\n    * [Preparing Dataset](#7)\n    * [Data Augmentation](#8)\n    * [Define Dataset](#9) \n    * [Get Images Count](#10)\n    * [Build Model](#11)\n        * [Define Learning Rate](#11)\n        * [Build Base Model](#12)\n* [Load Dataset](#13)\n* [Class Imbalance](#14)\n* [Train Model](#15)\n* [Visualize Scores](#16)\n* [Make Submission](#17)","5748fbb2":"- **Define learning rate and other configrations for model training.**","0bfacb8c":"# 3) Load the data <a id=\"4\"><\/a>\nNow we will load in our data. For this notebook, we will be importing the TFRecord Files.\n- `glob` would return a list of filenames matching a certain pattern provided to it.","cac7bd88":" ## 4.4 Data augmentation<a id=\"8\"><\/a>\n\nImage augmentation introduces new images into our data, and generally prevents the model from overfitting and leads to higher accuracy on testing datasets. We will perform following augmentations in the dataset.\n\n- `tf.image.random_flip_left_right`: Randomly flips the image either to left or right.\n- `tf.image.random_saturation`: Adds random saturation to image. Sometimes beneficial if image is deem or fade.\n- `tf.image.random_brightness`: Adds random brightness to the image.\n- `tf.image.random_flip_up_down`: Randomly flips the image either to up or down.","afca8479":"# 2) Configration <a id=\"3\"><\/a>\nLets define some configrations used throughout the notebook.\n- `AUTOTUNE` : Tune values dynamically at runtime.\n- `GCS_PATH` : Get the Corresponding Google Cloud Storage path where this dataset is hosted.\n- `BATCH_SIZE`: Set batch size for the model.\n- `IMAGE_SIZE` : Set the shape of the images which are used throughout the notebook.<br>\n\n**Because TPUs are very fast, many models ported to TPU end up with a data bottleneck. And hence its a good practice to read data from GCS (Google Cloud Storage). TPUs read training data exclusively from GCS.**","1acfde71":"# 1) Introduction <a id=\"1\"><\/a>\n\nBasically this problem is about image classification where we have to find the probability of a patient having `Melanoma` given images of his `skin lesions`. This is accomplished by classifying the sample as malignant. One thing to note here is that we don't have to predict the classes but the probabilty of positive class (malignant) and hence we won't have to apply any thresholds here. Just return score calculated by model.<br>\n\nWhat you will learn in this notebook: <br>\n- EfficientNet - A family of image classification models which acheive state-of-the-art accuracy.\n- How to Work with TPU.\n- Transfer Learning\n- Working with tensorflow input pipelines.\n- How to handle data in `tfrecord` format.\n- How to deal with Class Imbalance.\n\n**Please let me know in the Comments about what you learnt from the notebook that is not in the above list :)**","89b43239":"# SIIM-ISIC Competition Submission\n## Authors - Sarthak Khandelwal, Sergei Issaev","9b6de5db":"## 4.1 Decoding the data\n\n- Tensorflow model needs data to be Tensors or numpy arrays for training. <br>\n\n- Here we are using `tf.image.decode_jpeg` to decode the image into JPEG format and as this would be an RGB image, we kept number of channels to be 3.<br>\n\n- We would also normalize the images such that pixel values would now range from `[0,1]` instead of `[0,255]`.\n<br>","84775ea1":"**We will define two approaches to which changes learning rate dynamically. First we should understand what they are.**\n\n### #1. Time based\nThis method deals with reducing the learning rate over time. <br> \nFor example consider we reduce learning rate as epochs increases by the rule -<br>\n  \n  &nbsp;&nbsp;  **learning_rate = learning_rate \/ (1 + decay * epoch )** <br>\n  \nLet the initial Learning-rate is `0.1` and decay be `0.001` LR at first five epochs are: <br>\n\nepoch-1 = 0.1<br>\nepoch-2 = 0.0999000999<br>\nepoch-3 = 0.0997006985<br>\nepoch-4 = 0.09940249103<br>\nepoch-5 = 0.09900646517<br>\n\n\n![image.png](attachment:image.png)\nExample taken from [here](https:\/\/machinelearningmastery.com\/using-learning-rate-schedules-deep-learning-models-python-keras\/). \n","3332474c":"## 4.7 Build the Model\n<a id=\"11\"><\/a>\n- **The following set of utility functions would help us building our model for the given task.**","5c4144d5":"# 9) Making Submission\n<a id=\"17\"><\/a>\n- **Let's make a submission file for our Test Dataset by predicting the correct classes for samples in Test Dataset.**","c196e1f6":"## 4.2 Convert  TfRecord to tf.Example <a id=\"6\"><\/a>\n- The Below Function is used to convert the `.tfrecord` file into `tf.Example`. This gives us features and labels of our dataset, feature being the image and label being the class-id (0 or 1) for benign or malignant. <br>\n- As we know that we would not be needing labels for our test set and hence we would have two formats that data resides in our `.tfrecord` files namely labelled and unlabelled data. Unlabelled is used for testing and its format also would be different and hence we are toggling between different formats based on whether the given image is labelled or not. ","8fe8832a":"# 4) Utility Functions <a id=\"5\"><\/a>","1c903888":"By looking above graph we can say that Learning Rate changes continuously in Time Based Approach of Schedulling Learning Rate.","a2cd50ab":"## 6.2 Set class weights\n\nSince there are not enough malignant images, we want these malignant images to have more weight in our model. By increasing the weight of these malignant images, the model will pay more attention to them, and this will help balance out the difference in quantity."}}