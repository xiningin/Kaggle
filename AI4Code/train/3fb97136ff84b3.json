{"cell_type":{"254ec201":"code","6e2cb9b1":"code","d9cc5efd":"code","2800a280":"code","2eaabb1a":"code","2f88c992":"code","a6223346":"code","6d9ad935":"code","05f536c6":"code","1a0fc7d7":"code","fc50a803":"code","27b507fa":"code","675c2406":"code","88bde4c6":"code","03b24e13":"code","902fd7e0":"code","6c88e935":"code","64d0ddbd":"code","5ff4b7eb":"code","9e434fa6":"code","e40b8aac":"code","b243f4a1":"code","0e6630e8":"code","3074d674":"code","67b59ef9":"code","522d1623":"code","f7a53987":"code","fbd80f07":"code","e571a6d9":"code","fb51484d":"code","45281097":"markdown","e1e53ad7":"markdown","ddadb0be":"markdown","04596784":"markdown","77874837":"markdown","2f29b85a":"markdown","c45e27f0":"markdown","71f41d72":"markdown"},"source":{"254ec201":"# Potential additions\n# Column combinations \/ modifications\n# Grid search","6e2cb9b1":"import os\nimport numpy as np\nimport pandas as pd\nimport sklearn as sk\nfrom sklearn.decomposition import PCA\nfrom sklearn.impute import SimpleImputer, KNNImputer\nfrom sklearn.preprocessing import OrdinalEncoder, StandardScaler, OneHotEncoder\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.cluster import KMeans\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom scipy.sparse import issparse\nfrom sklearn.metrics import silhouette_score","d9cc5efd":"np.random.seed(42)\nsk.set_config(display='diagram')","2800a280":"# Kaggle dirs: \/kaggle\/input\/, \/kaggle\/working\/ and \/kaggle\/temp\/\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename)) # listing all inputs\n\ntrain = pd.read_csv('\/kaggle\/input\/datasets-for-churn-telecom\/cell2celltrain.csv')\ntrain = train.drop(\"CustomerID\", axis=1)","2eaabb1a":"train","2f88c992":"train.describe()","a6223346":"train.columns","6d9ad935":"train.corr()[\"MonthlyRevenue\"].sort_values(ascending=False)","05f536c6":"train_num = train.select_dtypes(np.number)\ntrain_cat = train.select_dtypes(np.object)\nnum_attributes = train_num.columns\ncat_attributes = train_cat.columns\n\nwith_missing = train.isnull().sum() > 0\nmissing_data = train[with_missing[with_missing].index]\nmissing_num, missing_cat = missing_data.select_dtypes(np.number), missing_data.select_dtypes(exclude=np.number)","1a0fc7d7":"train_cat.iloc[:,8:]\n# ordinal - CreditRating\n# onehot - Occupation, PrizmCode, ServiceArea, MaritalStatus\n# the rest is boolean, using Ordinal (with a caveat described in the cell below)","fc50a803":"# handling Unknown (aka extra NA)\ntrain_cat[train_cat[train_cat == \"Unknown\"].dropna(how='all', axis=1).columns].nunique()\n# Unknown in Homeownership is boolean (Known\/Unkown - 1\/0)\n# in MaritalStatus it is N\/A in boolean (with other values being Yes\/No)\n# in HandsetPrice, it is actual N\/A\n# a customer transformer needed\n# boolean goes with ordinal encoder\n# check if order matters","27b507fa":"n_unique_cat = train_cat.nunique()\nnon_boolean_cat = n_unique_cat > 2\nn_unique_cat","675c2406":"train_cat[non_boolean_cat[non_boolean_cat].index]\n# train_cat.iloc[:, np.flatnonzero(train_cat.nunique() > 2)]","88bde4c6":"class NAValueFiller(BaseEstimator, TransformerMixin):\n    def __init__(self, val_to_fill=\"Unknown\"):\n        self.val_to_fill = val_to_fill\n    def fit(self, X, y=None):\n        return self # nothing else to do\n    def transform(self, X, y=None):\n        return X.replace(np.nan, self.val_to_fill)\n\nclass ToNumeric(BaseEstimator, TransformerMixin):\n    def fit(self, X, y=None):\n        return self\n    def transform(self, X, y=None):\n        tf = X.apply(pd.to_numeric, errors='coerce')\n        return tf\n\nclass Debug(BaseEstimator, TransformerMixin):\n    def fit(self, X, y=None, **params):\n        return self\n\n    def transform(self, X):\n        print(pd.DataFrame(X).head())\n        print(X.shape)\n        return X\n\nclass Densifier(BaseEstimator, TransformerMixin):\n    def fit(self, X, y=None):\n        return self\n\n    def transform(self, X):\n        if issparse(X):\n            return X.todense()\n        return X","03b24e13":"# missing_cat - ServiceArea\ncat_filling_pipeline = ColumnTransformer([\n    (\"navf\", NAValueFiller(), missing_cat.columns)\n], remainder='passthrough')\nto_one_hot_attribs = [\"Occupation\", \"PrizmCode\", \"ServiceArea\", \"MaritalStatus\"]\nto_one_hot, to_ordinal = train_cat[to_one_hot_attribs], train_cat.drop(to_one_hot_attribs + ['HandsetPrice'], axis=1)\none_hot_pipeline = Pipeline([\n    (\"filling\", cat_filling_pipeline),\n    ('encoder', OneHotEncoder()),\n#     (\"dbg\", Debug()),\n])\nordinal_pipeline = Pipeline([\n    ('encoder', OrdinalEncoder()),\n#     (\"dbg\", Debug()),\n])","902fd7e0":"# Note:\n# ColumnTransformer will split a given step into *n* funnels, whereas Pipeline just applies steps sequentially","6c88e935":"to_nan_impute = [train_cat.HandsetPrice.name] + missing_num.columns.tolist()\nnum_attribtues = train_num.columns.tolist() + [train.HandsetPrice.name]\n\nhandset_pipeline = ColumnTransformer([\n    ('to_numeric', ToNumeric(), [train.HandsetPrice.name])\n], remainder='passthrough')\nnan_impute_pipeline = Pipeline([\n    (\"handset\", handset_pipeline),\n    ('imputer', SimpleImputer(strategy=\"median\"))\n])\n\nnum_prep_pipeline = ColumnTransformer([\n    (\"inpute_pipeline\", nan_impute_pipeline, to_nan_impute),\n], remainder='passthrough')\nnum_pipeline = Pipeline([\n    (\"num_prep\", num_prep_pipeline),\n#     (\"dbg\", Debug()),\n    ('scaler', StandardScaler()),\n])","64d0ddbd":"prep_pipeline = ColumnTransformer([\n    (\"num\", num_pipeline, num_attribtues),\n    (\"one_hot_cat\", one_hot_pipeline, to_one_hot_attribs),\n    (\"ordinal_cat\", ordinal_pipeline, to_ordinal.columns),\n])","5ff4b7eb":"prep_pipeline","9e434fa6":"prepared = prep_pipeline.fit_transform(train)","e40b8aac":"full_pipeline = Pipeline([\n        (\"preparation\", prep_pipeline),\n        (\"densify_for_pca\", Densifier()),\n        (\"pca\", PCA(n_components=0.9)),\n        (\"model\", KMeans())\n    ])","b243f4a1":"silhouette_scores = {}\nfor k in range(2,10):\n    full_pipeline.set_params(model__n_clusters=k)\n    full_pipeline.fit_predict(train)\n    labels = full_pipeline.named_steps[\"model\"].labels_\n    silhouette_scores[k] = silhouette_score(prepared, labels, sample_size=2000)","0e6630e8":"full_pipeline.set_params(model__n_clusters=max(silhouette_scores, key=silhouette_scores.get))","3074d674":"result = full_pipeline.fit_predict(train)","67b59ef9":"# explained var ~90%\nfull_pipeline.named_steps[\"pca\"].explained_variance_ratio_.sum()","522d1623":"print(\"% of customers per cluster\")\npd.Series(result).value_counts() \/ len(result)","f7a53987":"# getting column names\n# ordering num names according to the pipeline diagram (1. HandsetPrice, 2. to_nan_impute, 3. the rest)\nremovables = to_nan_impute.copy()\nremovables.remove('HandsetPrice')\nnum_names = np.concatenate([to_nan_impute, train_num.columns.drop(removables)])\none_hot_names = full_pipeline.named_steps['preparation'].transformers_[1][1]['encoder'].get_feature_names()\nordinal_cat_names = full_pipeline.named_steps['preparation'].transformers_[2][2]\nordered_names = np.concatenate([num_names, one_hot_names, ordinal_cat_names])","fbd80f07":"prepared_frame = pd.DataFrame(prepared.todense(), columns=ordered_names)\nprepared_frame[\"Segment\"] = result","e571a6d9":"# unscale numericals\nprepared_frame.iloc[:, :len(num_names)] = full_pipeline.named_steps['preparation'].transformers_[0][1]['scaler'].inverse_transform(prepared_frame[num_names])","fb51484d":"prepared_frame.groupby(\"Segment\").mean()","45281097":"# Profiling","e1e53ad7":"# Categorical variable analysis]\n(Optional)","ddadb0be":"# Prep-Pipelining","04596784":"# PCA + Model (KMeans) - Full Pipeline","77874837":"# General Outlook\n(Optional)","2f29b85a":"# Setup","c45e27f0":"# Data Division","71f41d72":"---"}}