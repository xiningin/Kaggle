{"cell_type":{"8114b0ce":"code","c7d33e95":"code","e352e7b9":"code","783efe70":"code","aeb9d043":"code","2b297898":"code","a4f4af36":"code","ca50ed8c":"code","d6f7f5cf":"code","71fbd32e":"code","b487663f":"code","c1262572":"code","7b5c46e6":"code","86744050":"code","7edee9ae":"code","a4f54aad":"code","6b47c2dc":"code","21038d25":"code","2b9a8a8b":"code","f0280754":"code","263d364b":"markdown","2db0e65b":"markdown","d976e525":"markdown","c9757684":"markdown","4036794a":"markdown","31e1a491":"markdown","0969173c":"markdown","7556b4a6":"markdown","0b34a414":"markdown","3175fed8":"markdown","8a84023f":"markdown","204c2adb":"markdown","3b3c287d":"markdown","66c4ecdb":"markdown","9cb1f34d":"markdown","231ec9f3":"markdown","b59fa3ad":"markdown","0682288b":"markdown","f9b78026":"markdown"},"source":{"8114b0ce":"import matplotlib.pyplot as plt\nimport seaborn as sns \nimport numpy as np\nimport pandas as pd\nimport numpy as np\nimport random as rnd\nfrom sklearn.metrics import confusion_matrix\nimport seaborn as sns\nimport matplotlib.gridspec as gridspec\nfrom sklearn.preprocessing import StandardScaler\nfrom numpy import genfromtxt\nfrom scipy.stats import multivariate_normal\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import recall_score , average_precision_score\nfrom sklearn.metrics import precision_score, precision_recall_curve\n%matplotlib inline\nimport plotly.graph_objs as go\nfrom plotly.offline import download_plotlyjs,init_notebook_mode,plot,iplot\ninit_notebook_mode(connected=True)\nfrom sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier, ExtraTreesClassifier, VotingClassifier\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.model_selection import GridSearchCV, cross_val_score, StratifiedKFold, learning_curve","c7d33e95":"train_df = pd.read_csv(\"..\/input\/\/creditcard.csv\")\nprint(train_df.columns.values)","e352e7b9":"train_df.head(5)","783efe70":"x = train_df['Class'].value_counts().index\ny = train_df['Class'].value_counts().values\n\ntrace2 = go.Bar(\n     x=x ,\n     y=y,\n     marker=dict(\n         color=y,\n         colorscale = 'Viridis',\n         reversescale = True\n     ),\n     name=\"Imbalance\",    \n )\nlayout = dict(\n     title=\"Data imbalance\",\n     #width = 900, height = 500,\n     xaxis=go.layout.XAxis(\n     automargin=True),\n     yaxis=dict(\n         showgrid=False,\n         showline=False,\n         showticklabels=True,\n #         domain=[0, 0.85],\n     ), \n)\nfig1 = go.Figure(data=[trace2], layout=layout)\niplot(fig1)","aeb9d043":"def estimateGaussian(dataset):\n    mu = np.mean(dataset, axis=0)\n    sigma = np.cov(dataset.T)\n    return mu, sigma\n\ndef multivariateGaussian(dataset,mu,sigma):\n    p = multivariate_normal(mean=mu, cov=sigma)\n    return p.pdf(dataset)\n","2b297898":"def selectThresholdByCV(probs,gt):\n    best_epsilon = 0\n    best_f1 = 0\n    f = 0\n    farray = []\n    Recallarray = []\n    Precisionarray = []\n    epsilons = (0.0000e+00, 1.0527717316e-70, 1.0527717316e-50, 1.0527717316e-24)\n    #epsilons = np.asarray(epsilons)\n    for epsilon in epsilons:\n        predictions = (p_cv < epsilon)\n        f = f1_score(train_cv_y, predictions, average = \"binary\")\n        Recall = recall_score(train_cv_y, predictions, average = \"binary\")\n        Precision = precision_score(train_cv_y, predictions, average = \"binary\")\n        farray.append(f)\n        Recallarray.append(Recall)\n        Precisionarray.append(Precision)\n        print ('For below Epsilon')\n        print(epsilon)\n        print ('F1 score , Recall and Precision are as below')\n        print ('Best F1 Score %f' %f)\n        print ('Best Recall Score %f' %Recall)\n        print ('Best Precision Score %f' %Precision)\n        print ('-'*40)\n        if f > best_f1:\n            best_f1 = f\n            best_recall = Recall\n            best_precision = Precision\n            best_epsilon = epsilon    \n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.5, 0.7, 0.3])\n    #plt.subplot(3,1,1)\n    plt.plot(farray ,\"ro\")\n    plt.plot(farray)\n    ax.set_xticks(range(5))\n    ax.set_xticklabels(epsilons,rotation = 60 ,fontsize = 'medium' )\n    ax.set_ylim((0,1.0))\n    ax.set_title('F1 score vs Epsilon value')\n    ax.annotate('Best F1 Score', xy=(best_epsilon,best_f1), xytext=(best_epsilon,best_f1))\n    plt.xlabel(\"Epsilon value\") \n    plt.ylabel(\"F1 Score\") \n    plt.show()\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.5, 0.9, 0.3])\n    #plt.subplot(3,1,2)\n    plt.plot(Recallarray ,\"ro\")\n    plt.plot(Recallarray)\n    ax.set_xticks(range(5))\n    ax.set_xticklabels(epsilons,rotation = 60 ,fontsize = 'medium' )\n    ax.set_ylim((0,1.0))\n    ax.set_title('Recall vs Epsilon value')\n    ax.annotate('Best Recall Score', xy=(best_epsilon,best_recall), xytext=(best_epsilon,best_recall))\n    plt.xlabel(\"Epsilon value\") \n    plt.ylabel(\"Recall Score\") \n    plt.show()\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.5, 0.9, 0.3])\n    #plt.subplot(3,1,3)\n    plt.plot(Precisionarray ,\"ro\")\n    plt.plot(Precisionarray)\n    ax.set_xticks(range(5))\n    ax.set_xticklabels(epsilons,rotation = 60 ,fontsize = 'medium' )\n    ax.set_ylim((0,1.0))\n    ax.set_title('Precision vs Epsilon value')\n    ax.annotate('Best Precision Score', xy=(best_epsilon,best_precision), xytext=(best_epsilon,best_precision))\n    plt.xlabel(\"Epsilon value\") \n    plt.ylabel(\"Precision Score\") \n    plt.show()\n    return best_f1, best_epsilon","a4f4af36":"v_features = train_df.iloc[:,1:29].columns","ca50ed8c":"plt.figure(figsize=(12,8*4))\ngs = gridspec.GridSpec(7, 4)\nfor i, cn in enumerate(train_df[v_features]):\n    ax = plt.subplot(gs[i])\n    sns.distplot(train_df[cn][train_df.Class == 1], bins=50)\n    sns.distplot(train_df[cn][train_df.Class == 0], bins=50)\n    ax.set_xlabel('')\n    ax.set_title('feature: ' + str(cn))\nplt.show()","d6f7f5cf":"rnd_clf = RandomForestClassifier(n_estimators = 100 , criterion = 'entropy',random_state = 0)\nrnd_clf.fit(train_df.iloc[:,1:29],train_df.iloc[:,30]);","71fbd32e":"x, y = (list(x) for x in zip(*sorted(zip(rnd_clf.feature_importances_, train_df.iloc[:,1:29].columns), \n                                                            reverse = False)))\ntrace2 = go.Bar(\n    x=x ,\n    y=y,\n    marker=dict(\n        color=x,\n        colorscale = 'Viridis',\n        reversescale = True\n    ),\n    name='Random Forest Feature importance',\n    orientation='h',\n)\n\nlayout = dict(\n    title='Barplot of Feature importances',\n     width = 600, height = 1000,\n    yaxis=dict(\n        showgrid=False,\n        showline=False,\n        showticklabels=True,\n#         domain=[0, 0.85],\n    ),\n    margin=dict(\n    l=300,\n),\n)\n\nfig1 = go.Figure(data=[trace2], layout=layout)\niplot(fig1)","b487663f":"for name, importance in zip(train_df.iloc[:,1:29].columns, rnd_clf.feature_importances_):\n    if importance > 0.020 :\n        print('\"' + name + '\"'+',')","c1262572":"train_df.drop(['V19','V21','V1','V2','V6','V5','V28','V27','V26','V25','V24','V23','V22','V20','V15','V13','V8'], axis =1, inplace = True)","7b5c46e6":"train_df.drop(labels = [\"Amount\",\"Time\"], axis = 1, inplace = True)","86744050":"train_strip_v1 = train_df[train_df[\"Class\"] == 1]\ntrain_strip_v0 = train_df[train_df[\"Class\"] == 0]","7edee9ae":"Normal_len = len (train_strip_v0)\nAnomolous_len = len (train_strip_v1)\n\nstart_mid = Anomolous_len \/\/ 2\nstart_midway = start_mid + 1\n\ntrain_cv_v1  = train_strip_v1 [: start_mid]\ntrain_test_v1 = train_strip_v1 [start_midway:Anomolous_len]\n\nstart_mid = (Normal_len * 60) \/\/ 100\nstart_midway = start_mid + 1\n\ncv_mid = (Normal_len * 80) \/\/ 100\ncv_midway = cv_mid + 1\n\ntrain_fraud = train_strip_v0 [:start_mid]\ntrain_cv    = train_strip_v0 [start_midway:cv_mid]\ntrain_test  = train_strip_v0 [cv_midway:Normal_len]\n\ntrain_cv = pd.concat([train_cv,train_cv_v1],axis=0)\ntrain_test = pd.concat([train_test,train_test_v1],axis=0)\n\n\nprint(train_fraud.columns.values)\nprint(train_cv.columns.values)\nprint(train_test.columns.values)\n\ntrain_cv_y = train_cv[\"Class\"]\ntrain_test_y = train_test[\"Class\"]\n\ntrain_cv.drop(labels = [\"Class\"], axis = 1, inplace = True)\ntrain_fraud.drop(labels = [\"Class\"], axis = 1, inplace = True)\ntrain_test.drop(labels = [\"Class\"], axis = 1, inplace = True)","a4f54aad":"mu, sigma = estimateGaussian(train_fraud)\np = multivariateGaussian(train_fraud,mu,sigma)\np_cv = multivariateGaussian(train_cv,mu,sigma)\np_test = multivariateGaussian(train_test,mu,sigma)","6b47c2dc":"fscore, ep= selectThresholdByCV(p_cv,train_cv_y)","21038d25":"predictions = (p_test < ep)\nRecall = recall_score(train_test_y, predictions, average = \"binary\")    \nPrecision = precision_score(train_test_y, predictions, average = \"binary\")\nF1score = f1_score(train_test_y, predictions, average = \"binary\")    \nprint ('F1 score , Recall and Precision for Test dataset')\nprint ('Best F1 Score %f' %F1score)\nprint ('Best Recall Score %f' %Recall)\nprint ('Best Precision Score %f' %Precision)","2b9a8a8b":"fig, ax = plt.subplots(figsize=(10, 10))\nax.scatter(train_test['V14'],train_test['V11'],marker=\"o\", color=\"lightBlue\")\nax.set_title('Anomalies(in red) vs Predicted Anomalies(in Green)')\nfor i, txt in enumerate(train_test['V14'].index):\n       if train_test_y.loc[txt] == 1 :\n            ax.annotate('*', (train_test['V14'].loc[txt],train_test['V11'].loc[txt]),fontsize=13,color='Red')\n       if predictions[i] == True :\n            ax.annotate('o', (train_test['V14'].loc[txt],train_test['V11'].loc[txt]),fontsize=15,color='Green')","f0280754":"predictions = (p_cv < ep)\nRecall = recall_score(train_cv_y, predictions, average = \"binary\")    \nPrecision = precision_score(train_cv_y, predictions, average = \"binary\")\nF1score = f1_score(train_cv_y, predictions, average = \"binary\")    \nprint ('F1 score , Recall and Precision for Cross Validation dataset')\nprint ('Best F1 Score %f' %F1score)\nprint ('Best Recall Score %f' %Recall)\nprint ('Best Precision Score %f' %Precision)\n","263d364b":"Performance wrt to Epsilon values\n    ----\nCheck out how well we are performing with the given set of epsilon values from the function called here.","2db0e65b":"**Feature Importance**\n    -------\nLets use Feqture importqnce to get rid of unwanted features whose existance will not improve our prediction model. <br>\nI have used random forest classifier to identify the influential fetures. You can validate the below result with the feature analysis I conducted above.","d976e525":"In the Anomalized technique  we distribute this large dataset into 3 parts .\n\n1) Normal Transactons: classified as 0 , no anomalized transaction should be present here since it is not a supervised method<br>  How to get this dataset :- 60% of normal transactions should be added here. <br> \nFind out Epsilon by using  min(Probability) command \n\n2) dataset for Cross validation : from the remaining normal transaction take 50 % (i.e. 20 % as a whole since we have already took the data in the first step)  and add 50% of the Anomalized data with this .\n\n3) dataset for testing the algorithm :- this step is similar to what we did for Cross validattion. <br>\n Test dataset = leftover normal transaction + leftover Anomalized data \n","c9757684":"\n Summary of above Algorithm: \n \n 1) Find Epsilon value by considering only Normal Transaction.\n \n 2) Use this Epsilon value on CV dataset (Normal transaction + Anomalous transaction)\n \n 3) Come up with set of Epsilon values to see how your algorithm performs and note down the Best F1 score along with\n      Recall and Precision percentage \n      \n 4) Choose the Epsilon value with highest F1 score \n \n 5) Use this Epsilon value to predict the Anomalous transaction on Test Dataset   \n \nPlease comment and let me know to help improve this kernel.","4036794a":"Lets get the dataframe for the Credit card transation data ","31e1a491":"**Lets visualize which features are not much of help in detecting the anamoly **","0969173c":"Split the dataset into 2 part one with Class 1 and other with class 0","7556b4a6":"Below is the most crucial function used to detect how well we are doing with our subset (Cross validation subset) .\nI have decided values for Epsilon for detecting the fradulent transactions from the Subsets.  <br><br>\n**(Tip :- Ideally you should provide range of epsilon values, due to time constraint on running this kernel i have provided few values here for demonstration purpose)**\n\n **For now remember Epsilon value is the threshold value below which we will mark transaction as Anomalous.**\n           ----\n\nRewriting above sentense again \nP(x) for X if less than the epsilon value then mark that transaction as anomalous transaction. \n\nWe need to maintain healthy balance between the Recall and Precision . We may get Recall value above 0.80 and close to 0.90 here but at the expense of reducing our precision which is not advisable.\n","0b34a414":"I have removed Amount and Time feature since they wont add much value in calculating gaussian distribution.","3175fed8":"**Anomaly Detection using Gaussian Distribution**\n------\n<p><img src=\"http:\/\/www.clipartable.com\/images\/17\/1mA7AFRb.jpg\" align=\"left\" height=\"200\" width=\"300\" margin=\"0 auto\" \/> <br>Credit card fraud methods have become increasingly sophisticated with use of latest technology today by criminals. It is not a simple task anymore to identify outliers\/Anamolous transactions before hand unless reported by the customer. So the use of Machine learning algorithms becomes imperative when we are dealing with financial data or sensitive data of customer as these algorithms can look at volumes of data including texts, images, and videos, analyze a pattern and detect an anomaly within seconds with high accuracy.  We have many supervised and unsupervised learning methods today to choose the algorithm from but choosing them in it self is a big task.  Lets see why \n <\/p>\n","8a84023f":"Luckily we have ready to use dataframe with clean data. <br> \nIn the overview of the data it has been mentioned that \"Class\" field in this dataframe consists binary data in 1 and zeros <br>\n**1 for fraudulent transactions, 0 otherwise**","204c2adb":"Epsilon value = 1.0527717316e-70 is selected as threshold to identify Anomalous transactions \n\nnow time to Predict and calculate  F1 , Recall and Precision score for our Test Dataset","3b3c287d":"I will be defining the below two functions which are required to calculate Gaussian Distribution of the normalized variables provided in the dataset (V1, V2 ....V28, Amount ).  <br>\nnote- These functions will be invoked for building the model\n\n1) Find out mu and Sigma for the dataframe variables passed to this function. <br>\n      ----\n2) Calculate Probability Distribution for the each row (I will explain why we need Probality for each row as we proceed) <br>\n       ----\n       \nFormula:- \nif each example x has N dimensiona(features) then below formula is used to calculate the P value <br>\n**P(x) = p(x1,u1,sigma1^2)p(x2,u2,sigma2^2)p(x3,u3,sigma3^2).....p(xn,un,sigma'N'^2)**\n      ---","66c4ecdb":"From the above result we can see that we are able to maintain the balance between Recall and Precision. \n\nPrecision of around 87% with Recall of 68% is not bad at all when we have such highly unbalanced data. \nThese numbers are not fixed and can vary . \n \n These numbers were different for Cross validation dataset and we shortlisted our Epsilon value by comparing the results of F1 Score.\n\nI will show you the result we achieved on Cross validation dataset again.","9cb1f34d":"Lets Visualize our predictions in below scatter plot \n         -------","231ec9f3":"Choosing Epsilon Values <br>\n    ---\nI calculated P value for all the rows present in Normal Transaction and found the minimum P value \nby using below command\n **min(p)** \n      ---\nsimilalrly I found the minimum P Value for rest of the datasets and found this value to be very close to 0 and then i found the max(p) value which is again somewhat far from 0. <br><br>\nInstead of looping between the epsilon values (between min and max of P) , i chose set of epsilon values for demonstration purpose to see how well i can perform to find the fraudulent transactions.","b59fa3ad":"Lets look at the class field and check how many fraudulent transactions we have in this data ","0682288b":"Quickly check \n1. which columns consists what ?\n1. how clean our data is ?\n1. Identify Label and Fatures ","f9b78026":"Fraudulent transactions provided here contributes mere **0.17%** which indicates<br>\n**we have a highly imbalanced data to work on.** <br>\nIf I can summarize what Andrew Ng has mentioned in his lecture on Anomaly detection is \nSupervised Classification technique is not the perfect candidate for highly imbalanced data. In this case it is \n 0.172% (near to 0)\n\nIf We think from the persepctive of building the model to find out the anomalous data which is not seen very frequently \nWe should go for Anomaly detection technique using Gaussian Distribution.  \n"}}