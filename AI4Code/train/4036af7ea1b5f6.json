{"cell_type":{"f060e542":"code","cf52dc1a":"code","a0febe38":"code","69fd5f3f":"code","95c6797c":"code","7ae074c3":"code","e68324da":"code","37efdff5":"code","bffd02d3":"code","9c07ef9c":"code","b0aa0c26":"code","de988ccc":"code","9d5ccde7":"code","5194d239":"code","779ab69f":"code","63ce6a59":"markdown","d7b5fa2d":"markdown","536707ac":"markdown"},"source":{"f060e542":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom scipy import sparse\nfrom sklearn.metrics.pairwise import cosine_similarity\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","cf52dc1a":"ratings = pd.read_csv('..\/input\/anime-recommendation-database-2020\/rating_complete.csv')\nratings.head()\n","a0febe38":"anime = pd.read_csv('..\/input\/anime-recommendation-database-2020\/anime.csv')\nanime.head()\n","69fd5f3f":"type(anime)","95c6797c":"#Just checking everything's size\nprint(ratings.shape)\nprint(anime.shape)","7ae074c3":"#I only care about TV anime, not movies, OVA, ONA or Music. So I'll get rid of those\nanime = anime.loc[anime['Type'] == 'TV']\nprint(anime.shape)\n#Knocked out a solid 12000+ rows!","e68324da":"#Now to carry that over and remove all reviews which aren't about TV anime!\nratings = ratings.loc[ratings['anime_id'].isin(anime['MAL_ID'])]\nprint(ratings.shape)\n#Knocked out a solid 14,565,494 rows.... That'll improve processing quite a bit","37efdff5":"#But I'm not QUITE done yet. I'd like to cut out users who have not given out enough ratings, as it might be harder to\n#normalize and they may skew the data, so I'm getting rid of all users who have 10 or under animes watched\n\nratings = ratings.groupby('user_id').filter(lambda x : len(x)>10)\nprint(ratings.shape)\n\n#Not too many ratings knocked out, barely any actually, but at least the data's quality improved!","bffd02d3":"#Basic Helper Function\n\ndef GetAnime(ID):\n    row = anime.loc[anime['MAL_ID'] == ID]\n    return row['Name'].to_string(index=False)\n\nprint(GetAnime(7))","9c07ef9c":"#Get averages for normalization later on\n\nusers = ratings['user_id'].unique()\n\nUserMeans = ratings.groupby(['user_id']).mean()\nUserMeans\n#You can ignore the anime id normalizations obviously","b0aa0c26":"UserMeans.loc[0]","de988ccc":"def GetRelevant(ID):\n    #Get all ratings of the specific anime, figure out which users, not as relevant anymore and will probably go unused \n    RatingsOfAnime = ratings.loc[ratings['anime_id'] == ID]\n    RelevantUsers = RatingsOfAnime['user_id']\n    \n    #Gets all the users ratings\n    #So basically, find all the users who have watched anime ID, then get all the anime ratings they've given out\n    \n    Relevant = ratings.loc[ratings['user_id'].isin(RelevantUsers)]\n    \n    return Relevant\n\ndef BuildRecs():\n    #This was originally a function because I wanted to build a matrix of only anime which users who have watched this\n    #anime have seen. I later realized though that if I was doing multiple runs, it was much simpler just run it once\n    #Relevant = GetRelevant(ID) #Function to get the relevant dataframe\n    \n    Relevant = ratings[0:1000000] #Currently only using a portion of the ratings dataset due to computational limitations, feel free to increase\n    \n    #Filter out all anime without enough reviews, here the minimum to make the cut is 200\n    Relevant = Relevant.groupby('anime_id').filter(lambda x : len(x)>100)\n    \n    \n    #LAMBDA TIME: this lambda function is to normalize the ratings by subtracting the User's average score from\n    # the User's score for a specific item average score \n    Relevant['rating'] = Relevant.apply(lambda x: x['rating']-UserMeans.loc[x['user_id']]['rating'], axis = 1)\n    \n    #Crosstabs to make the data workable with in a nice little matrix thingy\n    Matrix = pd.crosstab(Relevant.user_id , Relevant.anime_id, Relevant.rating, aggfunc='sum')\n    \n    #because N\/A is really ugly... and kinda hard to work with\n    Matrix = Matrix.fillna(0)\n    \n    #Calculate similarity, since item to item gonna need to transpose it\n    SimilarityNP = cosine_similarity(Matrix.T)\n    \n    #Convert the array into a dataframe \n    Similarity = pd.DataFrame(SimilarityNP,index = Matrix.columns,columns = Matrix.columns)\n    \n    \n    \n    return Similarity\n\n\n\nSimilarity = BuildRecs()\nprint(Similarity)\n\n\n    ","9d5ccde7":"#Quickly shearing down the anime dataset to stuff I actually need\nNewAnime = anime.filter(['MAL_ID','Name'], axis=1)\nNewAnime.rename(columns = {'MAL_ID' : 'anime_id'}, inplace = True)\n    \nprint(NewAnime)","5194d239":"#Reccomender code!\n\ndef RecAnime(AnimeID,Rating):\n    SimilarScores = Similarity[AnimeID]*Rating\n    SimilarScores = SimilarScores.sort_values(ascending = False)\n    SimilarScoresDF = pd.DataFrame(SimilarScores)\n    SimilarScoresDF.columns = ['Similarity Score']\n    \n   \n    \n    SimilarScoresDF = SimilarScoresDF[1:11]\n    #SimilarScoresDF['Anime Name'] = anime.loc[anime[MAL_ID == SimilarScoresDF['anime_id']]]['Name']\n                                              #ratings.loc[ratings['anime_id'].isin(anime['MAL_ID'])]\n    #SimilarScoresDF = SimilarScoresDF.apply(lambda x: )\n    SimilarScoresDF = pd.merge(SimilarScoresDF, NewAnime, on=\"anime_id\", how=\"inner\")\n    \n    \n    return SimilarScoresDF\n    \nRecAnime(1,10)","779ab69f":"#Fun little user input thing so they can manually pick which anime they would like reccomendations for\n\n#Apparently kaggle doesn't support input though :(\n\n#InpID = input(\"Please pick the anime ID you would like reccomendations for: \")\n#InpRate = input(\"Please pick what you rated this anime from 1 to 10: \")\n#RecAnime(int(InpID),int(InpRate))","63ce6a59":"# Some Data Preprocessing\n\nThe data is a big unwieldy at the moment, so let's try to reduce the size *while* improving the dataset","d7b5fa2d":"Hello! My name is Karthik Ayyalasomayajula and today I'll be creating an Anime Reccomendation System for my CPTS 315 class!\n\n","536707ac":"# The Code"}}