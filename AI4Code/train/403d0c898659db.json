{"cell_type":{"34effdfe":"code","68ef38fd":"code","8c64732f":"code","047eb384":"code","b297a884":"code","1cc2afe0":"code","c21117a5":"code","94e54089":"code","7983d657":"code","bb2e582b":"code","3b61225b":"code","3d9f0dd3":"code","007f323b":"code","285f3ef8":"code","7b2b490a":"code","b3ba375d":"code","4e98c19d":"code","5703f7cd":"code","475c7ad9":"code","6203e4e1":"code","e2f30786":"code","14bc9cef":"code","18888831":"code","7938de95":"code","a81900cd":"code","7d73ca3a":"code","fbcc7eda":"code","5b497965":"markdown","a0179513":"markdown","06a5e5b1":"markdown","2baa594b":"markdown","201a9ca9":"markdown","30bfe112":"markdown","b5503526":"markdown","c99122fe":"markdown","35ffc07b":"markdown","60dc9ac8":"markdown","19f76bd5":"markdown","d5cb9dc5":"markdown","65b4d737":"markdown","b35abcd2":"markdown","168d2853":"markdown","fdc1fcc8":"markdown","546f8136":"markdown","773e8021":"markdown","74fe4586":"markdown","eec6a782":"markdown","1234274f":"markdown","82def3f9":"markdown","e8c113d6":"markdown","34f22bac":"markdown","a82a3f01":"markdown","ef709136":"markdown"},"source":{"34effdfe":"import numpy as np \nimport pandas as pd\nfrom sklearn import *\nimport lightgbm as lgb\nimport xgboost as xgb\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nimport scipy as sp\nsns.set(style=\"whitegrid\")","68ef38fd":"PLOT_ALL = True","8c64732f":"df_train = pd.read_csv('\/kaggle\/input\/liverpool-ion-switching\/train.csv')\ndf_test = pd.read_csv('\/kaggle\/input\/liverpool-ion-switching\/test.csv')","047eb384":"df = pd.concat([df_train.drop(['open_channels'], axis=1), df_test])\ndf_train.shape, df_test.shape, df.shape","b297a884":"batch_time = 500000 # The signal batch time period","1cc2afe0":"df_train.describe()","c21117a5":"df_test.describe()","94e54089":"df.describe()","7983d657":"oc_vc = df_train['open_channels'].value_counts()\nax = sns.barplot(x=oc_vc.index, y=oc_vc.values)","bb2e582b":"if PLOT_ALL:\n    plt.figure(figsize=(12,12))\n    for i in range(10):\n        plt.subplot(5,2,i+1)\n        idx = range(batch_time*i, batch_time*(i+1)-1)\n        oc_vc = df_train.loc[idx, 'open_channels'].value_counts()\n        ax = sns.barplot(x=oc_vc.index, y=oc_vc.values)","3b61225b":"if PLOT_ALL:\n    plt.figure(figsize=(12,12))\n    for i in range(10):\n        plt.subplot(5,2,i+1)\n        idx = range(batch_time*i, batch_time*(i+1)-1)\n        ax = sns.lineplot(x=\"time\", y=\"open_channels\", data=df_train[batch_time*i:batch_time*(i+1)-1])","3d9f0dd3":"idx = 0\nplt.figure(figsize=(18,24))\nfor i, d in df_train.groupby('open_channels'):\n    plt.subplot(4,3,idx+1)\n    sns.distplot(d['signal'], bins=50)\n    plt.title('Signal Distribution for %d number of open channels' % i)\n    idx += 1","007f323b":"if PLOT_ALL:\n    sns.pairplot(x_vars=[\"signal\"], y_vars=[\"open_channels\"], data=df_train, size=6)\n    plt.title('Signal Distribution for different number of open channels')","285f3ef8":"non_zero_chn_index = df_train.index[df_train['open_channels'] > 0]\nprint(non_zero_chn_index.shape)\n\ndef plot_signal(mid_idx, plot_len):\n    plt.figure(figsize=(12,12))\n    for i in range(1,3):\n        start = mid_idx[i-1] - plot_len\n        end = mid_idx[i-1] + plot_len\n\n        plt.subplot(2,2,i)\n        plt.title('Open Channels, Time: %d - %d' % (start, end))\n        sns.lineplot(df_train.loc[start:end, 'time'], df_train.loc[start:end, 'open_channels'])\n\n        plt.subplot(2,2,i+2)\n        plt.title('Signal, Time: %d - %d' % (start, end))\n        sns.lineplot(df_train.loc[start:end, 'time'], df_train.loc[start:end, 'signal'])","7b2b490a":"if PLOT_ALL:\n    mid_idx = [non_zero_chn_index[100000], non_zero_chn_index[1759848]]\n    plot_len = 1000\n    plot_signal(mid_idx, plot_len)","b3ba375d":"if PLOT_ALL:\n    mid_idx = [non_zero_chn_index[10000], non_zero_chn_index[1759848]]\n    plot_len = 20\n    plot_signal(mid_idx, plot_len)","4e98c19d":"if PLOT_ALL:\n    plt.figure(figsize=(6,6))\n    sns.distplot(df_train['signal'], bins=20)\n    sns.distplot(df_test['signal'], bins=20)\n    plt.title('Signal Distribution for Test and Train')\n    plt.legend(labels=['Train', 'Test'])","5703f7cd":"plt.figure(figsize=(18,24))\nfor i in range(12):\n    ax = plt.subplot(4,3,i+1)\n    batch_idx = 2\n    pd.plotting.lag_plot(df_train['open_channels'][batch_time*batch_idx:batch_time*(batch_idx+1)-1], lag=i+1, ax=ax)\n    plt.title('Signal lag plot for batch %d' % (i+1))","475c7ad9":"plt.figure(figsize=(18,24))\nfor i in range(10):\n    ax = plt.subplot(4,3,i+1)\n    pd.plotting.autocorrelation_plot(df['signal'][batch_time*i:batch_time*(i+1)-1], ax=ax)\n    plt.ylim([-0.25, 0.25])\n    plt.title('Signal Autocorrelation for batch %d' % (i+1))","6203e4e1":"f_s = 10000\n\nplt.figure(figsize=(18,18))\nfor i in range(10):\n    plt.subplot(5,2,i+1)\n    x = df['signal'][batch_time*i:batch_time*(i+1)-1]\n    X = np.fft.fft(x)\n    freqs = np.fft.fftfreq(len(x)) * f_s\n\n    start = 0\n    end = len(x) \/\/ 100\n    plt.plot(freqs[start:end], np.abs(X)[start:end])\n    plt.title(\"Frequency spectrum of the signal, Batch %d\" % (i+1))","e2f30786":"def add_window_feature(df):\n    window_sizes = [10, 25, 50, 100, 500, 1000, 5000, 10000, 25000]\n    for window in window_sizes:\n        df[\"rolling_mean_\" + str(window)] = df['signal'].rolling(window=window).mean()\n        df[\"rolling_std_\" + str(window)] = df['signal'].rolling(window=window).std()\n        df[\"rolling_var_\" + str(window)] = df['signal'].rolling(window=window).var()\n        df[\"rolling_min_\" + str(window)] = df['signal'].rolling(window=window).min()\n        df[\"rolling_max_\" + str(window)] = df['signal'].rolling(window=window).max()\n        \n    df = df.replace([np.inf, -np.inf], np.nan)\n    df.fillna(0, inplace=True)\n    \n    return df","14bc9cef":"df_train = add_window_feature(df_train)\nprint(df_train.columns)\ndf_test = add_window_feature(df_test)\nprint(df_test.columns)","18888831":"X = df_train.drop(['time', 'open_channels'], axis=1)\ny = df_train['open_channels']","7938de95":"model = xgb.XGBRegressor(max_depth=3)\nmodel.fit(X,y)","a81900cd":"model = lgbm.LGBMRegressor(n_estimators=100)\nmodel.fit(X, y)","7d73ca3a":"X_test = df_test.drop(['time'], axis=1)\npreds = model.predict(X_test)","fbcc7eda":"df_test['open_channels'] = np.round(np.clip(preds, 0, 10)).astype(int)\ndf_test[['time','open_channels']].to_csv('submission.csv', index=False, float_format='%.4f')","5b497965":"# Modeling","a0179513":"# Lag plot of signals","06a5e5b1":"# Exploratory Data Analysis\n## University of Liverpool Ion Switching","2baa594b":"This is my first data analysis notebook and pleaes **UPVOTE** for this notebook if you find it useful!","201a9ca9":"# Load Data","30bfe112":"# Prediction","b5503526":"## Autocorrelation of signals\nAutocorrelation is the correlation of a signal with a delayed copy of itself as a function of delay. This will show whether there are repetitive patterns inside different batches of signal.","c99122fe":"This is the end of my first EDA notebook. Any feedback or comments are greatly welcomed!","35ffc07b":"From this plot, it does look like that higher signal strength leads to a larger number of open channels.","60dc9ac8":"# Signal Distribution Visualization","19f76bd5":"The plot above is quite interesting, showing that in some batches, there are only 0 or 1 open channels, where in other batches, there are open channels variation from 1-5.","d5cb9dc5":"From the zoomed in plots, it does look like the shape of the signal and the shape of the number of open channels have a strong correlation. The number of open channels look like a delayed version of the input signal.","65b4d737":"This shows that all the active signals are below 100 Hz, except batch 4 has a particularly noisy signal.","b35abcd2":"## XGBoost","168d2853":"# Feature Engineering","fdc1fcc8":"# Configuration","546f8136":"## Signal distribution for different open channel numbers","773e8021":"For batch 1-4, there seems to be a more repetitive pattern based on the autocorrelation plot.","74fe4586":"## Signal in Time vs Open Channel","eec6a782":"# Data Overview","1234274f":"The focus of this notebook is for data visualization and it will focus on using SNS as the plotting library. It hopes to use the plots to help each other to find possible better features.","82def3f9":"# Import Configuration","e8c113d6":"## Frequency Domain","34f22bac":"# Configuration","a82a3f01":"## LGBM","ef709136":"# Channel Distribution Visualization"}}