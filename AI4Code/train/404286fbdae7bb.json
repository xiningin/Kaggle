{"cell_type":{"2083625d":"code","94ba4152":"code","ad59854d":"code","e8f9d9d5":"code","f3b6147f":"code","ea19ba8a":"code","568d5164":"code","e65c3ec3":"code","f7add9c9":"code","22447bb0":"code","b382bcc0":"code","5360e462":"code","d6594728":"code","22985f93":"code","50e3c5c1":"code","87bb8f9c":"code","b6b2ba1d":"code","337c52c3":"code","6b774b9a":"code","cb708938":"code","2eb15e22":"code","9a192b82":"code","d459c143":"markdown","344c72d8":"markdown","d9be7012":"markdown","29fc383b":"markdown","15b1cb2f":"markdown","22d8a881":"markdown","e3e9e8b8":"markdown","3b841a66":"markdown","f90750a3":"markdown","4d4014ba":"markdown","6c4799e5":"markdown","6e7d7cf7":"markdown","e4bfbd1a":"markdown","f02bfb89":"markdown","c355d198":"markdown","cb6e21bb":"markdown","7390976e":"markdown","8a39ac39":"markdown","b4a67734":"markdown","3da4351b":"markdown","0f045903":"markdown"},"source":{"2083625d":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport random\nimport os\nfrom random import *\nfrom collections import Counter\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn import linear_model\nfrom keras.layers import Dense\nfrom keras.models import Sequential\nfrom keras.models import load_model\nfrom keras.layers import Dropout\n\n\n\n%matplotlib inline","94ba4152":"df = pd.read_csv(\"\/kaggle\/input\/atpdata\/ATP.csv\",dtype=str)","ad59854d":"df['tourney_month']=df.tourney_date.astype(str).str[:6]\ndf = df[df['tourney_month'].between('199101','201909')]\n\ndf.info()\n\ndf = df.drop(columns=['draw_size','winner_entry','winner_seed','loser_entry','loser_seed'])\ndf = df.dropna()\ndf.shape\n\n#nb_data=df.shape[0]\n#nb_param=df.shape[1]\n#count=np.zeros(nb_param)\n#for i in range(1,nb_data):\n#    for j in range(1,nb_param):\n#        if np.isnan(df[df.columns[j]].iloc[i]):\n#            count[j]+=1\n\n    \n\n#df = df.dropna().astype(float)","e8f9d9d5":"df.describe().transpose()","f3b6147f":"#Visualisation des variables propres aux joueurs\n\ndf['winner_age']=pd.to_numeric(df['winner_age'])\ndf['winner_ht']=pd.to_numeric(df['winner_ht'])\ndf['winner_id']=pd.to_numeric(df['winner_id'])\ndf['winner_rank']=pd.to_numeric(df['winner_rank'])\ndf['winner_rank_points']=pd.to_numeric(df['winner_rank_points'])\n\ndf['loser_age']=pd.to_numeric(df['loser_age'])\ndf['loser_ht']=pd.to_numeric(df['loser_ht'])\ndf['loser_id']=pd.to_numeric(df['loser_id'])\ndf['loser_rank']=pd.to_numeric(df['loser_rank'])\ndf['loser_rank_points']=pd.to_numeric(df['loser_rank_points'])\n\n\nplt.figure(figsize=(20,10))\nplt.subplot(2,4,1)\ndf['winner_age'].plot(kind='hist',bins=26, xlim=(15,40), ylim=(0,10000), title='Age du gagnant')\n\nplt.subplot(2,4,2)\ndf['loser_age'].plot(kind='hist',bins=26, xlim=(15,40), ylim=(0,10000), title='Age du perdant')\n\nplt.subplot(2,4,3)\ndf['winner_ht'].plot(kind='hist',bins=15, xlim=(160,210), ylim=(0,25000), title='Taille du gagnant')\n\nplt.subplot(2,4,4)\ndf['loser_ht'].plot(kind='hist',bins=15, xlim=(160,210), ylim=(0,25000), title='Taille du perdant')\n\nplt.subplot(2,4,5)\ndf['winner_rank'].plot(kind='hist',bins=100, xlim=(0,800), ylim=(0,25000), title='Rang du gagnant')\n\nplt.subplot(2,4,6)\ndf['loser_rank'].plot(kind='hist',bins=100, xlim=(0,800), ylim=(0,25000), title='Rang du perdant')\n\nplt.subplot(2,4,7)\ndf['winner_rank_points'].plot(kind='hist',bins=100, xlim=(0,14000), ylim=(0,15000), title='Points de classement du gagnant')\n\nplt.subplot(2,4,8)\ndf['loser_rank_points'].plot(kind='hist',bins=100, xlim=(0,14000), ylim=(0,15000), title='Points de classement du perdant')","ea19ba8a":"df['w_1stWon']=pd.to_numeric(df['w_1stWon'])\ndf['w_2ndWon']=pd.to_numeric(df['w_2ndWon'])\ndf['w_SvGms']=pd.to_numeric(df['w_SvGms'])\ndf['w_ace']=pd.to_numeric(df['w_ace'])\ndf['w_bpFaced']=pd.to_numeric(df['w_bpFaced'])\ndf['w_bpSaved']=pd.to_numeric(df['w_bpSaved'])\ndf['w_df']=pd.to_numeric(df['w_df'])\ndf['w_svpt']=pd.to_numeric(df['w_svpt'])\n\ndf['l_1stWon']=pd.to_numeric(df['l_1stWon'])\ndf['l_2ndWon']=pd.to_numeric(df['l_2ndWon'])\ndf['l_SvGms']=pd.to_numeric(df['l_SvGms'])\ndf['l_ace']=pd.to_numeric(df['l_ace'])\ndf['l_bpFaced']=pd.to_numeric(df['l_bpFaced'])\ndf['l_bpSaved']=pd.to_numeric(df['l_bpSaved'])\ndf['l_df']=pd.to_numeric(df['l_df'])\ndf['l_svpt']=pd.to_numeric(df['l_svpt'])\n\n\nplt.figure(figsize=(20,15))\n\nplt.subplot(3,4,1)\ndf['w_1stWon'].plot(kind='hist', title='Premiers services remport\u00e9s par le gagnant (%)', bins=100, xlim=(0,100), ylim=(0,10000))\n\nplt.subplot(3,4,2)\ndf['l_1stWon'].plot(kind='hist', title='Premiers services remport\u00e9s par le perdant (%)', bins=100, xlim=(0,100), ylim=(0,10000))\n\nplt.subplot(3,4,3)\ndf['w_2ndWon'].plot(kind='hist', title='Seconds services remport\u00e9s par le gagnant (%)', bins=50, xlim=(0,50), ylim=(0,10000))\n\nplt.subplot(3,4,4)\ndf['l_2ndWon'].plot(kind='hist', title='Seconds services remport\u00e9s par le perdant (%)', bins=50, xlim=(0,50), ylim=(0,10000))\n\nplt.subplot(3,4,5)\ndf['w_bpFaced'].plot(kind='hist', title='Breakpoints endur\u00e9s par le gagnant', bins=30, xlim=(0,30), ylim=(0,20000))\n\nplt.subplot(3,4,6)\ndf['l_bpFaced'].plot(kind='hist', title='Breakpoints endur\u00e9s par le perdant', bins=30, xlim=(0,30), ylim=(0,20000))\n\nplt.subplot(3,4,7)\ndf['w_bpSaved'].plot(kind='hist', title='Breakpoints sauv\u00e9s par le gagnant', bins=25, xlim=(0,25), ylim=(0,20000))\n\nplt.subplot(3,4,8)\ndf['l_bpSaved'].plot(kind='hist', title='Breakpoints sauv\u00e9s par le perdant', bins=25, xlim=(0,25), ylim=(0,20000))\n\nplt.subplot(3,4,9)\ndf['w_ace'].plot(kind='hist', title='Aces du gagnant', bins=40, xlim=(0,40), ylim=(0,30000))\n\nplt.subplot(3,4,10)\ndf['l_ace'].plot(kind='hist', title='Aces du perdant', bins=40, xlim=(0,40), ylim=(0,30000))\n\nplt.subplot(3,4,11)\ndf['w_df'].plot(kind='hist', title='Double fautes du gagnant', bins=20, xlim=(0,20), ylim=(0,30000))\n\nplt.subplot(3,4,12)\ndf['l_df'].plot(kind='hist', title='Double fautes du perdant', bins=20, xlim=(0,20), ylim=(0,30000))","568d5164":"plt.figure(1, figsize=(20,12))\n\ncountry_names_loser=np.array(Counter(df['loser_ioc']).most_common())[:,0]\ncountry_appearances_loser=list(map(int,np.array(Counter(df['loser_ioc']).most_common())[:,1]))\nplt.subplot(2,4,1)\nP1=plt.pie(country_appearances_loser,labels=country_names_loser)\n\ncountry_names_winner=np.array(Counter(df['winner_ioc']).most_common())[:,0]\ncountry_appearances_winner=list(map(int,np.array(Counter(df['winner_ioc']).most_common())[:,1]))\nplt.subplot(2,4,2)\nP2=plt.pie(country_appearances_winner,labels=country_names_winner)","e65c3ec3":"#On d\u00e9finit les variables d'entr\u00e9e (= param\u00e8tres connus avant le match)\ninput_param=['p1_hand','p1_ht','p1_age','p1_rank','p1_rank_points','p2_hand','p2_ht','p2_age','p2_rank','p2_rank_points','surface']\n\n#On d\u00e9finit les variables de sortie (= statistiques du match utilis\u00e9es sur les sites de paris sportifs)\noutput_param=['p1_1stWon', 'p1_2ndWon', 'p1_SvGms', 'p1_ace', 'p1_bpFaced', 'p1_bpSaved', 'p1_df', 'p1_svpt', 'p2_1stWon', 'p2_2ndWon', 'p2_SvGms', 'p2_ace', 'p2_bpFaced', 'p2_bpSaved', 'p2_df', 'p2_svpt', 'winner_number']","f7add9c9":"df_shuffle=df.copy()\nwinner_number=np.zeros(df.shape[0])\n\npd.options.mode.chained_assignment = None  # default='warn'\n\n#for i in range(0,1000):\nfor i in range(0,df.shape[0]):\n    n=randint(1,2)\n    winner_number[i]=n-1\n    if n==1:\n        \n        #Inputs\n        \n        tmp=df_shuffle.iloc[i]['loser_id']\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('loser_id')]=df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_id')]\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_id')]=tmp\n  \n        tmp=df_shuffle.iloc[i]['loser_hand']\n        if (df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_hand')]=='R'):\n            df_shuffle.iloc[i,df_shuffle.columns.get_loc('loser_hand')]=0\n        else:\n            df_shuffle.iloc[i,df_shuffle.columns.get_loc('loser_hand')]=1\n            \n        if (tmp=='R'):\n            df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_hand')]=0\n        else:\n            df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_hand')]=1\n        \n        tmp=df_shuffle.iloc[i]['loser_ht']\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('loser_ht')]=df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_ht')]\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_ht')]=tmp\n        \n        tmp=df_shuffle.iloc[i]['loser_age']\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('loser_age')]=df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_age')]\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_age')]=tmp\n        \n        tmp=df_shuffle.iloc[i]['loser_rank']\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('loser_rank')]=df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_rank')]\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_rank')]=tmp\n        \n        tmp=df_shuffle.iloc[i]['loser_id']\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('loser_rank_points')]=df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_rank_points')]\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_rank_points')]=tmp\n        \n        #Outputs\n        \n        tmp=df_shuffle.iloc[i]['l_1stWon']\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('l_1stWon')]=df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_1stWon')]\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_1stWon')]=tmp\n        \n        tmp=df_shuffle.iloc[i]['l_2ndWon']\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('l_2ndWon')]=df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_2ndWon')]\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_2ndWon')]=tmp\n        \n        tmp=df_shuffle.iloc[i]['l_SvGms']\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('l_SvGms')]=df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_SvGms')]\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_SvGms')]=tmp\n        \n        tmp=df_shuffle.iloc[i]['l_ace']\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('l_ace')]=df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_ace')]\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_ace')]=tmp\n        \n        tmp=df_shuffle.iloc[i]['l_bpFaced']\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('l_bpFaced')]=df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_bpFaced')]\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_bpFaced')]=tmp\n        \n        tmp=df_shuffle.iloc[i]['l_bpSaved']\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('l_bpSaved')]=df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_bpSaved')]\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_bpSaved')]=tmp\n        \n        tmp=df_shuffle.iloc[i]['l_df']\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('l_df')]=df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_df')]\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_df')]=tmp\n        \n        tmp=df_shuffle.iloc[i]['l_svpt']\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('l_svpt')]=df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_svpt')]\n        df_shuffle.iloc[i,df_shuffle.columns.get_loc('w_svpt')]=tmp\n        \n    else:\n        if (df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_hand')]=='R'):\n            df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_hand')]=0\n        else:\n            df_shuffle.iloc[i,df_shuffle.columns.get_loc('winner_hand')]=1\n            \n        if (df_shuffle.iloc[i,df_shuffle.columns.get_loc('loser_hand')]=='R'):\n            df_shuffle.iloc[i,df_shuffle.columns.get_loc('loser_hand')]=0\n        else:\n            df_shuffle.iloc[i,df_shuffle.columns.get_loc('loser_hand')]=1   ","22447bb0":"#input_df=pd.DataFrame(columns=['p1_id','p1_hand','p1_ht','p1_age','p1_rank','p1_rank_points','p2_id','p2_hand','p2_ht','p2_age','p2_rank','p2_rank_points'])#,'surface'])\ninput_df=pd.DataFrame(columns=['p1_hand','p1_ht','p1_age','p1_rank','p1_rank_points','p2_hand','p2_ht','p2_age','p2_rank','p2_rank_points'])#,'surface'])\n\n#input_df.iloc[:,input_df.columns.get_loc('p1_id')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('loser_id')].copy()\n#input_df.iloc[:,input_df.columns.get_loc('p2_id')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('winner_id')].copy()\ninput_df.iloc[:,input_df.columns.get_loc('p1_hand')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('loser_hand')].copy()\ninput_df.iloc[:,input_df.columns.get_loc('p2_hand')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('winner_hand')].copy()\ninput_df.iloc[:,input_df.columns.get_loc('p1_ht')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('loser_ht')].copy()\ninput_df.iloc[:,input_df.columns.get_loc('p2_ht')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('winner_ht')].copy()\ninput_df.iloc[:,input_df.columns.get_loc('p1_age')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('loser_age')].copy()\ninput_df.iloc[:,input_df.columns.get_loc('p2_age')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('winner_age')].copy()\ninput_df.iloc[:,input_df.columns.get_loc('p1_rank')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('loser_rank')].copy()\ninput_df.iloc[:,input_df.columns.get_loc('p2_rank')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('winner_rank')].copy()\ninput_df.iloc[:,input_df.columns.get_loc('p1_rank_points')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('loser_rank_points')].copy()\ninput_df.iloc[:,input_df.columns.get_loc('p2_rank_points')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('winner_rank_points')].copy()\n#input_df.iloc[:,input_df.columns.get_loc('surface')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('surface')].copy()","b382bcc0":"output_df=pd.DataFrame(columns=['p1_1stWon', 'p1_2ndWon', 'p1_SvGms', 'p1_ace', 'p1_bpFaced', 'p1_bpSaved', 'p1_df', 'p1_svpt', 'p2_1stWon', 'p2_2ndWon', 'p2_SvGms', 'p2_ace', 'p2_bpFaced', 'p2_bpSaved', 'p2_df', 'p2_svpt', 'winner_number'])\n\noutput_df.iloc[:,output_df.columns.get_loc('p1_1stWon')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_1stWon')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p2_1stWon')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_1stWon')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p1_2ndWon')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_2ndWon')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p2_2ndWon')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_2ndWon')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p1_SvGms')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_SvGms')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p2_SvGms')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_SvGms')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p1_ace')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_ace')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p2_ace')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_ace')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p1_bpFaced')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_bpFaced')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p2_bpFaced')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_bpFaced')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p1_bpSaved')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_bpSaved')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p2_bpSaved')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_bpSaved')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p1_df')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_df')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p2_df')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_df')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p1_svpt')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_svpt')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('p2_svpt')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_svpt')].copy()\n#output_df.iloc[:,output_df.columns.get_loc('winner_number')]=df_shuffle.iloc[:,df.columns.get_loc('winner_id')].copy()\noutput_df.iloc[:,output_df.columns.get_loc('winner_number')]=winner_number","5360e462":"X_train, X_test, y_train, y_test = train_test_split(input_df[:],output_df[:],test_size=0.2) #20%\nprint(X_train.shape)\nprint(y_train.shape)\nprint(X_test.shape)\nprint(y_test.shape)","d6594728":"print(X_train)\nprint(y_train)","22985f93":"linear_model = LinearRegression()\n\nm = linear_model.fit(X_train,y_train['winner_number'])","50e3c5c1":"#calcul du RMSE\nRMSE_train = np.sqrt(((y_train['winner_number'] - linear_model.predict(X_train))**2).sum()\/len(y_train['winner_number']))\nRMSE_test = np.sqrt(((y_test['winner_number'] - linear_model.predict(X_test))**2).sum()\/len(y_test['winner_number']))\n\nprint(\"RMSE en apprentissage : \", RMSE_train)\nprint(\"RMSE en test : \", RMSE_test)","87bb8f9c":"from sklearn.linear_model import LogisticRegression\nlogistic_model = LogisticRegression(solver='lbfgs', max_iter=5000)\nlogistic_model.fit(X_train, y_train['winner_number'])","b6b2ba1d":"RMSE_train = np.sqrt(((y_train['winner_number'] - logistic_model.predict(X_train))**2).sum()\/len(y_train['winner_number']))\nRMSE_test = np.sqrt(((y_test['winner_number'] - logistic_model.predict(X_test))**2).sum()\/len(y_test['winner_number']))\nprint(\"RMSE en apprentissage : \", RMSE_train)\nprint(\"RMSE en test : \", RMSE_test)","337c52c3":"model = Sequential()\nX_param_nb = X_train.shape[1]\nmodel.add(Dropout(0.1, input_shape = (X_param_nb, )))\nmodel.add(Dense(X_param_nb, activation = 'relu'))\nmodel.add(Dense(30, activation = 'relu'))\nmodel.add(Dense(5, activation = 'relu'))\nmodel.add(Dense(1, activation = 'sigmoid'))\nmodel.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])\nhistory = model.fit(X_train, y_train['winner_number'], epochs = 20, validation_split = 0.2, batch_size = 256, shuffle=True)\n\nplt.plot(history.history['acc'])\nplt.plot(history.history['val_acc'])\nplt.title('Model accuracy')\nplt.ylabel('Accuracy')\nplt.xlabel('Epoch')\nplt.legend(['Training_set', 'Validation_set'])\nplt.show()\n\n#Affichage du taux de pr\u00e9diction sur la base de test\nprint(model.evaluate(X_test, y_test['winner_number']))","6b774b9a":"input_df_2=pd.DataFrame(columns=['p1_1stWon', 'p1_2ndWon', 'p1_SvGms', 'p1_ace', 'p1_bpFaced', 'p1_bpSaved', 'p1_df', 'p1_svpt', 'p2_1stWon', 'p2_2ndWon', 'p2_SvGms', 'p2_ace', 'p2_bpFaced', 'p2_bpSaved', 'p2_df', 'p2_svpt'])\n\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p1_1stWon')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_1stWon')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p2_1stWon')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_1stWon')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p1_2ndWon')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_2ndWon')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p2_2ndWon')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_2ndWon')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p1_SvGms')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_SvGms')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p2_SvGms')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_SvGms')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p1_ace')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_ace')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p2_ace')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_ace')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p1_bpFaced')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_bpFaced')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p2_bpFaced')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_bpFaced')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p1_bpSaved')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_bpSaved')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p2_bpSaved')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_bpSaved')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p1_df')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_df')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p2_df')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_df')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p1_svpt')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('l_svpt')].copy()\ninput_df_2.iloc[:,input_df_2.columns.get_loc('p2_svpt')]=df_shuffle.iloc[:,df_shuffle.columns.get_loc('w_svpt')].copy()\n\nX_train, X_test, y_train, y_test = train_test_split(input_df_2[:],output_df[:],test_size=0.2) #20%","cb708938":"linear_model = LinearRegression()\n\nm = linear_model.fit(X_train,y_train['winner_number'])\n\nRMSE_train = np.sqrt(((y_train['winner_number'] - linear_model.predict(X_train))**2).sum()\/len(y_train['winner_number']))\nRMSE_test = np.sqrt(((y_test['winner_number'] - linear_model.predict(X_test))**2).sum()\/len(y_test['winner_number']))\n\nprint(\"RMSE en apprentissage : \", RMSE_train)\nprint(\"RMSE en test : \", RMSE_test)","2eb15e22":"from sklearn.linear_model import LogisticRegression\nlogistic_model = LogisticRegression(solver='lbfgs', max_iter=5000)\nlogistic_model.fit(X_train, y_train['winner_number'])\n\nRMSE_train = np.sqrt(((y_train['winner_number'] - logistic_model.predict(X_train))**2).sum()\/len(y_train['winner_number']))\nRMSE_test = np.sqrt(((y_test['winner_number'] - logistic_model.predict(X_test))**2).sum()\/len(y_test['winner_number']))\nprint(\"RMSE en apprentissage : \", RMSE_train)\nprint(\"RMSE en test : \", RMSE_test)","9a192b82":"from keras.callbacks import EarlyStopping\nmodel = Sequential()\nX_param_nb = X_train.shape[1]\nes = EarlyStopping(monitor='val_loss', mode='min', verbose=0, patience=20)\nmodel.add(Dropout(0.1, input_shape = (X_param_nb, )))\nmodel.add(Dense(X_param_nb, activation = 'relu'))\nmodel.add(Dense(30, activation = 'relu'))\nmodel.add(Dense(1, activation = 'sigmoid'))\nmodel.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])\nhistory = model.fit(X_train, y_train['winner_number'], epochs = 1000, validation_split = 0.2, batch_size = 256, shuffle=True, callbacks=[es])\n\nplt.plot(history.history['acc'])\nplt.plot(history.history['val_acc'])\nplt.title('Model accuracy')\nplt.ylabel('Accuracy')\nplt.xlabel('Epoch')\nplt.legend(['Training_set', 'Validation_set'])\nplt.show()\n\n#Affichage du taux de pr\u00e9diction sur la base de test\nprint(\"Loss value for test data : \", model.evaluate(X_test, y_test['winner_number'])[0])\nprint(\"Accuracy value for test data : \", model.evaluate(X_test, y_test['winner_number'])[1])","d459c143":"La premi\u00e8re \u00e9tape consiste simplement en l'importation des donn\u00e9es du fichier ATP.csv.","344c72d8":"Afin d'anonymiser l'identit\u00e9 du gagnant et du perdant, on affecte al\u00e9atoirement un num\u00e9ro \"1\" ou \"2\" aux joueurs gagnants et perdants, et donc \u00e0 l'ensemble des variables utilis\u00e9es dans cette analyse.\n\nEn pratique, on passe ici par un \u00e9change de valeurs entre le joueur gagnant et le joueur perdant dans une copie de notre jeu de donn\u00e9es.\n\nCependant, cet algorithme est tr\u00e8s long \u00e0 ex\u00e9cuter (30 minutes pour l'ensemble des donn\u00e9es), et m\u00e9riterait d'\u00eatre optimis\u00e9.","d9be7012":"Par la suite, on effectue le m\u00eame type de visualisation pour les variables propres \u00e0 l'issue du match, telles que les statistiques de services, de breakpoints ou encore d'aces.","29fc383b":"Enfin, suite au temps perdu \u00e0 chercher l'explication des r\u00e9sultats des mod\u00e8les de r\u00e9gression, j'ai exp\u00e9riment\u00e9 diff\u00e9rents mod\u00e8les de deep learning pour tenter d'obtenir des r\u00e9sultats plus fiables.","15b1cb2f":"Le premier mod\u00e8le est un mod\u00e8le de r\u00e9gression lin\u00e9aire basique, pour obtenir une sorte de \"probabilit\u00e9\" pour faire un choix du gagnant entre le joueur 1 et le joueur 2.\n\nCe mod\u00e8le pr\u00e9sente l'avantage de pouvoir, si n\u00e9cessaire, \u00e9tablir des intervalles de rejet du r\u00e9sultat, par exemple avec une affectation \u00e0 0 si les r\u00e9sultats sont inf\u00e9rieurs \u00e0 0.3, une affectation \u00e0 1 si les r\u00e9sultats sont sup\u00e9rieurs \u00e0 0.7, et un rejet (qui pourrait correspondre \u00e0 l'absence de pari, jug\u00e9 trop risqu\u00e9) pour un r\u00e9sultat compris entre 0.3 et 0.7.","22d8a881":"Par ailleurs, il est n\u00e9cessaire pour cette base de donn\u00e9es, o\u00f9 de nombreuses variables sont manquantes, de la nettoyer. \n\nOn passera ici, d'abord, par la s\u00e9lection des donn\u00e9es int\u00e9ressantes pour notre cas, \u00e0 savoir les donn\u00e9es \u00e0 partir de 1991, qui contiennent davantage de statistiques sur les matchs. Au vu de la quantit\u00e9 de matchs disponibles, le rejet des donn\u00e9es avant 1991 ne devrait pas poser de probl\u00e8me, et nous simplifiera la t\u00e2che.\n\nPar la suite, on constate que plusieurs variables contiennent de trop nombreuses valeurs manquantes. On les retire donc de notre \u00e9tude.\n\nEnfin, on retire de notre base de donn\u00e9es les matchs dont au moins une variable est manquante, encore une fois pour simplifier la t\u00e2che par la suite. On aurait \u00e9galement pu chercher \u00e0 remplir certaines de ces valeurs manquantes, par exemple en affectant \"0\" ou \"-1\" \u00e0 toutes les valeurs quantitatives manquantes, ou en cr\u00e9ant une cat\u00e9gorie \"inconnu\" pour les valeurs qualitatives telles que la nationalit\u00e9 ou la main dominante.","e3e9e8b8":"J'ai \u00e9galement essay\u00e9 un mod\u00e8le de r\u00e9gression logistique, qui est largement utilis\u00e9 dans le cas d'une pr\u00e9diction d'un certain r\u00e9sultat pr\u00e9cis parmi un nombre fini de r\u00e9sultats possibles, ce qui est ici notre cas.","3b841a66":"On d\u00e9finit \u00e9galement notre jeu de donn\u00e9es de sortie","f90750a3":"La commande ci-dessous nous permet d'explorer rapidement le panel de valeurs prises par les variables utilis\u00e9es, et notamment les valeurs les plus fr\u00e9quentes.","4d4014ba":"On s\u00e9pare notre jeu de donn\u00e9es en une base d'entra\u00eenement pour nos mod\u00e8les, et une base de test, pour \u00e9valuer l'efficacit\u00e9 de nos mod\u00e8les.\n\nJ'ai ici choisi de s\u00e9parer les donn\u00e9es sans les m\u00e9langer, pour pr\u00e9dire les 20% de matchs les plus r\u00e9cents en s'appuyant sur les 80% de matchs les plus anciens, comme si les matchs de test \u00e9taient situ\u00e9s dans le futur du point o\u00f9 notre mod\u00e8le est entra\u00een\u00e9.","6c4799e5":"On calcule le RMSE des pr\u00e9dictions de l'\u00e9chantillon d'apprentissage et de l'\u00e9chantillon de test. \n\nCependant, il appara\u00eet visiblement que les r\u00e9sultats sont \"trop\" parfaits et qu'un probl\u00e8me est donc rencontr\u00e9.\n\nMalgr\u00e9 une longue p\u00e9riode pass\u00e9e \u00e0 chercher une explication \u00e0 ces r\u00e9sultats, je n'ai pu comprendre la raison de ces r\u00e9sultats.","6e7d7cf7":"On choisit ensuite les variables que l'on souhaite prendre en compte pour les mod\u00e8les pr\u00e9dictifs.\n\nAu d\u00e9part, j'ai pens\u00e9 que l'objectif ne se limitait pas uniquement \u00e0 la pr\u00e9diction du r\u00e9sultat (gagn\u00e9\/perdu) du match, mais aussi \u00e0 la pr\u00e9diction de quelques statistiques sur lesquelles on peut \u00e9galement parier sur les sites de paris en ligne. J'ai donc ajout\u00e9 l'ensemble des statistiques du match \u00e0 la liste des variables souhait\u00e9es en sortie de nos mod\u00e8les.\n\nPar ailleurs, utiliser ces statistiques du match, indisponibles pour les parieurs avant le d\u00e9but du match, pour tenter de pr\u00e9dire l'issue du match, ne me semblait pas \u00eatre une bonne id\u00e9e, je ne les ai donc pas inclues dans les variables d'entr\u00e9e de notre mod\u00e8le, m\u00eame lorsque l'on m'a confirm\u00e9 que l'objectif \u00e9tait uniquement d'obtenir l'issue du match (Joueur gagnant).","e4bfbd1a":"On peut \u00e9galement regarder quelques statistiques qualitatives et non quantitatives, telles que la nationalit\u00e9 des joueurs.","f02bfb89":"On passe ensuite par la construction d'histogrammes pour visualiser la r\u00e9partition des valeurs prises par quelques statistiques propres aux joueurs, et les \u00e9ventuelles diff\u00e9rences notables entre gagnants et perdants.","c355d198":"Ce mod\u00e8le ne r\u00e9ussit cependant pas \u00e0 pr\u00e9dire avec fiabilit\u00e9 l'issue du match.\n\nBien que je ne m'attendais pas \u00e0 un extr\u00eamement bon r\u00e9sultat au vu des variables prises en compte dans la m\u00e9thode, ce r\u00e9sultat est cependant tr\u00e8s d\u00e9cevant. La variable de score et celle de classement notamment auraient d\u00fb fournir suffisamment d'informations pour qu'une l\u00e9g\u00e8re tendance \u00e0 la victoire pour les joueurs les mieux class\u00e9s se d\u00e9gage, et soit obtenue par ce mod\u00e8le.","cb6e21bb":"Si j'avais eu davantage de temps, plusieurs pistes auraient pu \u00eatre int\u00e9ressantes pour am\u00e9liorer les r\u00e9sultats ou pousser davantage le sujet, \u00e0 savoir :\n* Une simple normalisation (ou centrage et r\u00e9duction) des donn\u00e9es aurait pu \u00eatre int\u00e9ressante pour \u00e9viter les biais qui ont pu \u00eatre apport\u00e9s par les diff\u00e9rentes \u00e9chelles de valeurs prises par les variables\n* \u00c9tudier les pr\u00e9c\u00e9dents r\u00e9sultats des joueurs (par exemple par le biais d'un mod\u00e8le LSTM) pourrait apporter de solides mod\u00e8les davantage personnalis\u00e9s\n* D\u00e9finir des caract\u00e9ristiques suppl\u00e9mentaires, notamment la diff\u00e9rence entre les statistiques du joueur 1 et du joueur 2, pour les donner en entr\u00e9e des mod\u00e8les, pourrait aider les mod\u00e8les \u00e0 apprendre et pr\u00e9dire plus efficacement\n* J'aurais souhait\u00e9 comprendre la cause des r\u00e9sultats obtenus dans les mod\u00e8les de r\u00e9gression sur les premi\u00e8res donn\u00e9es d'entr\u00e9e.\n* Un calcul des covariances ou l'\u00e9valuation des corr\u00e9lations entre les joueurs \"gagnants\" et \"perdants\" pourrait permettre de d\u00e9tecter les variables permettant de discriminer les joueurs selon leur classe \"gagnant\" ou \"perdant\", pour laisser de c\u00f4t\u00e9 les variables moins utiles.\n* Certaines variables qualitatives, notamment la surface, le Round et le Tourney_level, pourraient \u00eatre transform\u00e9es en plusieurs variables quantitatives binaires pour les fournir en entr\u00e9e aux mod\u00e8les devrait \u00e9galement apporter de meilleurs r\u00e9sultats.\n* En outre de l'issue du match, tenter de pr\u00e9dire le score des diff\u00e9rents sets pourrait \u00e9galement \u00eatre int\u00e9ressant, dans une optique de paris en ligne sur les scores pr\u00e9cis;\n* Enfin, la m\u00e9thode actuellement utilis\u00e9e pour \"anonymiser\" les joueurs \"gagnants\" et \"perdants\" est tr\u00e8s longue \u00e0 ex\u00e9cuter et est \u00e9galement co\u00fbteuse en ressources (CPU \u00e0 100% durant 30 minutes). Trouver une meilleure m\u00e9thode ou au moins l'optimiser devrait permettre de r\u00e9duire fortement ce co\u00fbt en temps et en ressources.","7390976e":"L'objectif de ce challenge Kaggle est de pr\u00e9dire, avec le plus de succ\u00e8s possible, l'issue de matchs de tennis afin de r\u00e9aliser des paris sportifs.\n\nOn passera tout d'abord par une exploration et une visualisation des donn\u00e9es, et l'on poursuivra par des mod\u00e8les pr\u00e9dictifs.","8a39ac39":"Cependant, comme pour la r\u00e9gression lin\u00e9aire classique, les r\u00e9sultats obtenus sont \"trop\" bons, avec un taux d'erreur \u00e9gal \u00e0 0 en apprentissage comme en test. ","b4a67734":"Par la suite, j'ai exp\u00e9riment\u00e9 les r\u00e9sultats obtenus en modifiant les statistiques utilis\u00e9es pour pr\u00e9dire le r\u00e9sultat du match. \n\nCette fois-ci, on utilise donc les statistiques directement issues du match, ce qui est cependant un abus et qui ne pourrait \u00eatre r\u00e9ellement appliqu\u00e9 pour de vrais paris sportifs.","3da4351b":"On r\u00e9essaie donc les mod\u00e8les test\u00e9s plus t\u00f4t, en obtenant cette fois-ci de bien meilleurs r\u00e9sultats","0f045903":"Une fois l'anonymisation effectu\u00e9e, on d\u00e9finit r\u00e9ellement notre jeu de donn\u00e9es d'entr\u00e9e"}}