{"cell_type":{"9d218acf":"code","084de468":"code","876571e9":"code","1ad37330":"code","dd267b95":"code","105dc503":"code","2f71a587":"code","60bb08b2":"code","435fe644":"code","933f96df":"code","2992c8b5":"code","168fdb31":"code","3d757ae4":"code","e08d9df2":"markdown","20879932":"markdown","2c998cd1":"markdown","c4475a15":"markdown","f980866a":"markdown","0a21f42c":"markdown"},"source":{"9d218acf":"!pip install https:\/\/github.com\/ceshine\/shap\/archive\/master.zip","084de468":"import sys\nimport gc","876571e9":"import torch.nn as nn\nimport torch\nfrom torch.nn.utils.weight_norm import weight_norm\nfrom sklearn import preprocessing\nimport shap\nimport numpy as np\nimport joblib","1ad37330":"%ls ..\/input\/data\/cache\/model_cache\/","dd267b95":"MODEL = \"..\/input\/data\/cache\/model_cache\/snapshot_PUBG_0.02873547.pth\"","105dc503":"class MLPModel(nn.Module):\n    def __init__(self, num_features):\n        super().__init__()\n        self.model = nn.Sequential(\n            weight_norm(nn.Linear(num_features, 64)),\n            nn.ELU(),\n            weight_norm(nn.Linear(64, 64)),\n            nn.ELU(),\n            weight_norm(nn.Linear(64, 64)),\n            nn.ELU(),\n            weight_norm(nn.Linear(64, 64)),\n            nn.ELU(),          \n            weight_norm(nn.Linear(64, 1)),\n        )\n\n    def forward(self, input_tensor):\n        return torch.clamp(self.model(input_tensor), 0, 1)","2f71a587":"x_train, features = joblib.load(\"..\/input\/x_train_dump.jl\")","60bb08b2":"DEVICE = \"cpu\"\nmodel = MLPModel(len(features)).to(DEVICE)\nmodel.load_state_dict(torch.load(MODEL, map_location='cpu'))","435fe644":"%%time\ne = shap.DeepExplainer(\n        model, \n        torch.from_numpy(\n            x_train[np.random.choice(np.arange(len(x_train)), 10000, replace=False)]\n        ).to(DEVICE))","933f96df":"%%time\nx_samples = x_train[np.random.choice(np.arange(len(x_train)), 300, replace=False)]\nprint(len(x_samples))\nshap_values = e.shap_values(\n    torch.from_numpy(x_samples).to(DEVICE)\n)","2992c8b5":"shap_values.shape","168fdb31":"import pandas as pd\ndf = pd.DataFrame({\n    \"mean_abs_shap\": np.mean(np.abs(shap_values), axis=0), \n    \"stdev_abs_shap\": np.std(np.abs(shap_values), axis=0), \n    \"name\": features\n})\ndf.sort_values(\"mean_abs_shap\", ascending=False)[:10]","3d757ae4":"shap.summary_plot(shap_values, features=x_samples, feature_names=features)","e08d9df2":"### Plotting Overall Shap Values","20879932":"## Deep Explainer\n\nHere we only use a small sample (300) to save time:","2c998cd1":"Install my forck of the  *shap* package:\n\n(The PyTorchDeepExplainer from the official master branch needs some tweaking to work)","c4475a15":"### Shap Values As a Data Frame","f980866a":"# Preparation","0a21f42c":"## Load a Model"}}