{"cell_type":{"fe348870":"code","5acd5942":"code","8c65007e":"code","e56f791f":"code","6c75cbff":"code","dff9da9b":"code","395699dd":"code","b869a4d3":"code","4cba6c49":"code","b50876e9":"code","22af11ce":"code","a3b9927d":"code","276f79a2":"code","dd09ab79":"code","11b6ce10":"code","6041c857":"code","8cc86db4":"code","0a121775":"code","bb4ee41f":"code","088cdb4b":"code","f6c254be":"code","6015200f":"code","90ed049a":"code","e787d53b":"code","f1b50cf3":"code","12f7a1df":"code","c7f84df8":"code","4eb9c9f4":"code","2b6bfd2f":"markdown"},"source":{"fe348870":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n\n# load help packages\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt # basic plotting\nimport seaborn as sns # additional plotting functionality\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running the below code (by clicking run or pressing Shift+Enter) will list the files in the input directory\nimport os\nprint(os.listdir(\"..\/input\"))","5acd5942":"# load data\nxray_data = pd.read_csv('..\/input\/Data_Entry_2017.csv')\n\n# see how many observations there are\nnum_obs = len(xray_data)\nprint('Number of observations:',num_obs)\n\n# examine the raw data before performing pre-processing\nxray_data.head(5) # view first 5 rows\n#xray_data.sample(5) # view 5 randomly sampled rows","8c65007e":"from glob import glob\n#import os # already imported earlier\n\nmy_glob = glob('..\/input\/images*\/images\/*.png')\nprint('Number of Observations: ', len(my_glob)) # check to make sure I've captured every pathway, should equal 112,120","e56f791f":"full_img_paths = {os.path.basename(x): x for x in my_glob}\nxray_data['full_path'] = xray_data['Image Index'].map(full_img_paths.get)\n","6c75cbff":"num_unique_labels = xray_data['Finding Labels'].nunique()\nprint('Number of unique labels:',num_unique_labels)\n\n# let's look at the label distribution to better plan our next step\ncount_per_unique_label = xray_data['Finding Labels'].value_counts() # get frequency counts per label\ndf_count_per_unique_label = count_per_unique_label.to_frame() # convert series to dataframe for plotting purposes\n","dff9da9b":"print(df_count_per_unique_label) # view tabular results","395699dd":"sns.barplot(x = df_count_per_unique_label.index[:20], y=\"Finding Labels\", data=df_count_per_unique_label[:20], color = \"green\")\nplt.xticks(rotation = 90) ","b869a4d3":"# define dummy labels for one hot encoding - simplifying to 14 primary classes (excl. No Finding)\ndummy_labels = ['Atelectasis', 'Consolidation', 'Infiltration', 'Pneumothorax', 'Edema', 'Emphysema', 'Fibrosis', 'Effusion', 'Pneumonia', 'Pleural_Thickening', \n'Cardiomegaly', 'Nodule', 'Mass', 'Hernia'] # taken from paper\n\n# One Hot Encoding of Finding Labels to dummy_labels\nfor label in dummy_labels:\n    xray_data[label] = xray_data['Finding Labels'].map(lambda result: 1.0 if label in result else 0)\nxray_data.head(20) # check the data, looking good!","4cba6c49":"clean_labels = xray_data[dummy_labels].sum().sort_values(ascending= False) # get sorted value_count for clean labels\nprint(clean_labels) # view tabular results\n\n# plot cases using seaborn barchart\nclean_labels_df = clean_labels.to_frame() # convert to dataframe for plotting purposes\nsns.barplot(x = clean_labels_df.index[::], y= 0, data = clean_labels_df[::], color = \"green\"), plt.xticks(rotation = 90) # visualize results graphically","b50876e9":"## MODEL CREATION PHASE STARTS HERE\n\n# create vector as ground-truth, will use as actuals to compare against our predictions later\nxray_data['target_vector'] = xray_data.apply(lambda target: [target[dummy_labels].values], 1).map(lambda target: target[0])","22af11ce":"xray_data.head() ","a3b9927d":"# split the data into a training and testing set\nfrom sklearn.model_selection import train_test_split\ntrain_set, test_set = train_test_split(xray_data, test_size = 0.2, random_state = 1993)\n\n# quick check to see that the training and test set were split properly\nprint('training set - # of observations: ', len(train_set))\nprint('test set - # of observations): ', len(test_set))\nprint('prior, full data set - # of observations): ', len(xray_data))","276f79a2":"from keras.preprocessing.image import ImageDataGenerator\ndata_gen = ImageDataGenerator(\n        rescale=1.\/255,\n        shear_range=0.2,\n        zoom_range=0.2,\n        rotation_range=20,\n        width_shift_range=0.2,\n        height_shift_range=0.2,\n        horizontal_flip=True)","dd09ab79":"def flow_from_dataframe(img_data_gen, in_df, path_col, y_col, **dflow_args):\n    base_dir = os.path.dirname(in_df[path_col].values[0])\n    print('## Ignore next message from keras, values are replaced anyways')\n    df_gen = img_data_gen.flow_from_directory(base_dir, \n                                     class_mode = 'sparse',\n                                    **dflow_args)\n    df_gen.filenames = in_df[path_col].values\n    df_gen.classes = np.stack(in_df[y_col].values)\n    df_gen.samples = in_df.shape[0]\n    df_gen.n = in_df.shape[0]\n    df_gen._set_index_array()\n    df_gen.directory = '' # since we have the full path\n    print('Reinserting dataframe: {} images'.format(in_df.shape[0]))\n    return df_gen","11b6ce10":"image_size = (128, 128) # image re-sizing target\n\ntrain_gen = flow_from_dataframe(data_gen, train_set, path_col = 'full_path', y_col = 'target_vector', \n                                target_size = image_size, \n                                color_mode = 'grayscale',\n                                batch_size = 32)\n\nvalid_gen = flow_from_dataframe(data_gen, test_set, path_col = 'full_path', y_col = 'target_vector', \n                                target_size = image_size, \n                                color_mode = 'grayscale', \n                                batch_size = 128)\n\n# define test sets\ntest_X, test_Y = next(flow_from_dataframe(data_gen, test_set, path_col = 'full_path', y_col = 'target_vector', \n                                          target_size = image_size, \n                                          color_mode = 'grayscale', \n                                          batch_size = 2048))","6041c857":"## On to the fun stuff! Create a convolutional neural network model to train from scratch\n\n# Import relevant libraries\nfrom keras.layers import Conv2D, MaxPooling2D, GlobalAveragePooling2D\nfrom keras.layers import Dropout, Flatten, Dense\nfrom keras.models import Sequential\n\n# Create CNN model\n# Will use a combination of convolutional, max pooling, and dropout layers for this purpose\nmodel = Sequential()\n\nmodel.add(Conv2D(filters = 8, kernel_size = 3, padding = 'same', activation = 'relu', input_shape = test_X.shape[1:]))\nmodel.add(MaxPooling2D(pool_size = 2))\nmodel.add(Dropout(0.2))\n\nmodel.add(Conv2D(filters = 16, kernel_size = 3, padding = 'same', activation = 'relu'))\nmodel.add(MaxPooling2D(pool_size = 2))\nmodel.add(Dropout(0.2))\n          \nmodel.add(Conv2D(filters = 32, kernel_size = 3, padding = 'same', activation = 'relu'))\nmodel.add(MaxPooling2D(pool_size = 2))\nmodel.add(Dropout(0.2))\n\nmodel.add(Conv2D(filters = 64, kernel_size = 3, padding = 'same', activation = 'relu'))\nmodel.add(MaxPooling2D(pool_size = 2))\nmodel.add(Dropout(0.2))\n          \nmodel.add(Conv2D(filters = 128, kernel_size = 3, padding = 'same', activation = 'relu'))\nmodel.add(MaxPooling2D(pool_size = 3))\nmodel.add(Dropout(0.2))\n\n# add in fully connected dense layers to model, then output classifiction probabilities using a softmax activation function\nmodel.add(Flatten())\nmodel.add(Dense(500, activation = 'relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(len(dummy_labels), activation = 'softmax'))\n\n# compile model, run summary\nmodel.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])\nmodel.summary()","8cc86db4":"# set up a checkpoint for model training\n# https:\/\/keras.io\/callbacks\/\nfrom keras.callbacks import ModelCheckpoint\n\ncheckpointer = ModelCheckpoint(filepath='weights.best.{epoch:02d}-{val_loss:.2f}.hdf5', verbose=1, save_best_only = True)\ncallbacks_list = [checkpointer]","0a121775":"model.fit_generator(generator = train_gen, steps_per_epoch = 20, epochs = 1, callbacks = callbacks_list, validation_data = (test_X, test_Y))","bb4ee41f":"# Make prediction based on our fitted model\npredictions = model.predict(test_X, batch_size = 64, verbose = 1)","088cdb4b":"from PIL import Image\nfrom random import shuffle\nfrom keras.preprocessing.image import ImageDataGenerator, load_img\nfrom keras.models import Sequential,Model\nfrom keras.utils.data_utils import Sequence\nfrom keras.layers import Conv2D, MaxPooling2D\nfrom keras.layers import Activation, Dropout, Flatten, Dense\nfrom keras import backend as K\n%matplotlib inline","f6c254be":"from keras.applications.vgg16 import VGG16\nbase_model = VGG16(weights=('imagenet'), include_top=False, input_shape = (224,224,3) )\nbase_model.summary()","6015200f":"base_model.output_shape","90ed049a":"add_model = Sequential()\nadd_model.add(Flatten(input_shape=base_model.output_shape[1:]))\nadd_model.add(Dense(1024, activation='relu'))\nadd_model.add(Dense(512, activation='relu'))\nadd_model.add(Dense(128, activation='relu'))\nadd_model.add(Dense(len(dummy_labels), activation = 'softmax'))\n\n\nmodel1 = Model(inputs=base_model.input, outputs=add_model(base_model.output))\nmodel1.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])\nmodel1.summary()","e787d53b":"image_size = (224,224) # image re-sizing target\n\ntrain_gen = flow_from_dataframe(data_gen, train_set, path_col = 'full_path', y_col = 'target_vector', \n                                target_size = image_size,\n                                batch_size = 32)\n\nvalid_gen = flow_from_dataframe(data_gen, test_set, path_col = 'full_path', y_col = 'target_vector', \n                                target_size = image_size,  \n                                batch_size = 128)\n\n# define test sets\ntest_X, test_Y = next(flow_from_dataframe(data_gen, test_set, path_col = 'full_path', y_col = 'target_vector', \n                                          target_size = image_size,  \n                                          batch_size = 2048))","f1b50cf3":"from keras.callbacks import ModelCheckpoint\n\ncheckpointer = ModelCheckpoint(filepath='weights.best.{epoch:02d}-{val_loss:.2f}.hdf5', verbose=1, save_best_only = True)\ncallbacks_list = [checkpointer]","12f7a1df":"model1.fit_generator(generator = train_gen, steps_per_epoch = 20, epochs = 1, callbacks = callbacks_list, validation_data = (test_X, test_Y))","c7f84df8":"# Credit: Helper function for Plotting - Code sourced directly from Kevin Mader - Simple XRay CNN on 12\/09\/18\n# https:\/\/www.kaggle.com\/kmader\/train-simple-xray-cnn\n\n# import libraries\nfrom sklearn.metrics import roc_curve, auc\n\n# create plot\nfig, c_ax = plt.subplots(1,1, figsize = (9, 9))\nfor (i, label) in enumerate(dummy_labels):\n    fpr, tpr, thresholds = roc_curve(test_Y[:,i].astype(int), predictions[:,i])\n    c_ax.plot(fpr, tpr, label = '%s (AUC:%0.2f)'  % (label, auc(fpr, tpr)))\n\n# Set labels for plot\nc_ax.legend()\nc_ax.set_xlabel('False Positive Rate')\nc_ax.set_ylabel('True Positive Rate')\nfig.savefig('quick_trained_model.png')","4eb9c9f4":"## See previous code snippets for all references\n\n# Run a longer, more detailed model\nmodel1.fit_generator(generator = train_gen, steps_per_epoch = 50, epochs = 5, callbacks = callbacks_list, validation_data = (test_X, test_Y))\n\n# Make prediction based on our fitted model\ndeep_model_predictions = model1.predict(test_X, batch_size = 64, verbose = 1)\n\n# create plot\nfig, c_ax = plt.subplots(1,1, figsize = (9, 9))\nfor (i, label) in enumerate(dummy_labels):\n    fpr, tpr, thresholds = roc_curve(test_Y[:,i].astype(int), deep_model_predictions[:,i])\n    c_ax.plot(fpr, tpr, label = '%s (AUC:%0.2f)'  % (label, auc(fpr, tpr)))\n\n# Set labels for plot\nc_ax.legend()\nc_ax.set_xlabel('False Positive Rate')\nc_ax.set_ylabel('True Positive Rate')\nfig.savefig('deep_trained_model.png')","2b6bfd2f":"**VGG**"}}