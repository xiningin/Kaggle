{"cell_type":{"370e0c39":"code","dd7fcfc7":"code","7f6706b8":"code","5bafe24b":"code","e6a01e2b":"code","bb7ca614":"code","3fd737e2":"code","6873e766":"code","fe20faa2":"code","da018a50":"markdown","a19a7e06":"markdown","0deccc17":"markdown","1d94ce9d":"markdown","f7904f7e":"markdown","fd48bf52":"markdown","07cfe7f5":"markdown","623f817e":"markdown","b3f17526":"markdown","7adb7841":"markdown","282b3035":"markdown","f5891588":"markdown","1d43f31d":"markdown"},"source":{"370e0c39":"import numpy as np\nimport pandas as pd\nimport pylab\nfrom matplotlib.ticker import MultipleLocator\npylab.rc(\"figure\", figsize=(16, 12))\npylab.rc(\"font\", size=16)\n\n\n# selects season and round (race) number\nyear = 2011\nround_n = 1\ndatadir = '..\/input\/formula-1-race-data-19502017\/'\n\n# reads driver data\ndrivers = pd.read_csv(datadir+'drivers.csv', encoding='ISO-8859-1')\nall_races = pd.read_csv(datadir+'races.csv')\n\nrace = all_races[all_races.year == year].iloc[round_n-1]\nrace_id = race.raceId\n\n# reads lap times\nlaptimes = pd.read_csv(datadir+'lapTimes.csv')\nrace_laptimes = laptimes[laptimes.raceId == race_id].copy()\n\n# reads pitstop info\npitstops = pd.read_csv(datadir+'pitStops.csv')\nrace_pitstops = pitstops[pitstops.raceId == race_id].copy()\n\n# reads results\nresults = pd.read_csv(datadir+'results.csv')\nrace_results = results[(results.raceId == race_id) & (results.grid > 0)].copy()\n\n# sorts the results by grid position\nrace_results.sort_values(by = 'grid', inplace=True)\nndrivers = len(race_results)\n\ndriver_ids = race_results.driverId.to_numpy()\nvettel_id = 20\ndriver_id = vettel_id # Id of the driver the race pace of whom is analysed.","dd7fcfc7":"# useful functions\n\ndef ms_to_msm(ms):\n    sec = ms\/1000.\n    m = sec\/\/60\n    s = ''\n    if m > 0:\n        s += '%d:'%m\n    s += '%6.3f'%(sec%60)\n    return s\n\ndef driverId_to_lastname(driverId):\n    return drivers[drivers.driverId == driverId].surname.values[0]\n","7f6706b8":"# takes the first driver, looks for overtakes on or by other drivers\n\novertakes = {'gainer_id': [], 'loser_id': [], 'gainer_lap': [], 'loser_lap': [], 'loser_inpits': []}\n\nfor n in range(ndrivers):\n    \n    d1_id = driver_ids[n]\n    \n    d1_laptimes = race_laptimes[race_laptimes.driverId == d1_id].copy()\n    tend_d1 = d1_laptimes.milliseconds.cumsum().to_numpy()\n    tstart_d1 = np.append(0., tend_d1[:-1])\n    \n    d1_laptimes['tstart_ms'] = tstart_d1\n    d1_laptimes['tend_ms'] = tend_d1\n    \n    nlaps_d1 = len(tend_d1)\n    \n    d1_pitstops = race_pitstops[race_pitstops.driverId == d1_id].copy()\n    \n    for i in range(n+1, ndrivers):\n        d2_id = race_results.iloc[i]['driverId']\n        d2 = drivers[drivers.driverId == d2_id]\n        \n        d2_laptimes = race_laptimes[race_laptimes.driverId == d2_id]\n        tend_d2 = d2_laptimes.milliseconds.cumsum().to_numpy()\n        tstart_d2 = np.append(0., tend_d2[:-1])\n        \n        nlaps_d2 = len(tend_d2)\n        laparr_d2 = np.arange(nlaps_d2) + 1\n        \n        d2_pitstops = race_pitstops[race_pitstops.driverId == d2_id].copy()\n        \n        # loops through driver 1's laps\n        for l1 in range(nlaps_d1):\n            # checks if there's a lap that starts after and ends before one of driver 2's laps\n            starts_later = tstart_d1[l1] > tstart_d2\n            ends_sooner = tend_d1[l1] < tend_d2\n            passes = starts_later & ends_sooner\n            if passes.sum() > 0:\n                overtakes['gainer_id'].append(d1_id)\n                overtakes['loser_id'].append(d2_id)\n                overtakes['gainer_lap'].append(l1+1)\n                overtakes['loser_lap'].append(laparr_d2[passes][0])\n                if laparr_d2[passes][0] in d2_pitstops.lap.values or laparr_d2[passes][0] - 1 in d2_pitstops.lap.values:\n                    overtakes['loser_inpits'].append(True)\n                else:\n                    overtakes['loser_inpits'].append(False)\n            # then checks if there's a lap that starts before and ends after one of driver 2's laps\n            starts_sooner = tstart_d1[l1] < tstart_d2\n            ends_later = tend_d1[l1] > tend_d2\n            ispassed = starts_sooner & ends_later\n            nispassed = ispassed.sum()\n            for n in range(nispassed):\n                overtakes['gainer_id'].append(d2_id)\n                overtakes['loser_id'].append(d1_id)\n                overtakes['gainer_lap'].append(laparr_d2[ispassed][n])\n                overtakes['loser_lap'].append(l1+1)\n                if l1+1 in d1_pitstops.lap.values or l1 in d1_pitstops.lap.values:\n                    overtakes['loser_inpits'].append(True)\n                else:\n                    overtakes['loser_inpits'].append(False)\n\n# stores overtake info into a Pandas DataFrame\novertakes_df = pd.DataFrame(overtakes)","5bafe24b":"overtakes_df[(overtakes_df.gainer_id == vettel_id) | (overtakes_df.loser_id == vettel_id)]","e6a01e2b":"def classify_laps(driver_id, held_delta=1.5):\n    driver_laptimes = race_laptimes[race_laptimes.driverId == driver_id].copy().set_index('lap')\n    nlaps = len(driver_laptimes)\n    \n    laps = np.arange(nlaps) + 1\n    \n    isclean = np.ones(nlaps, dtype=bool)\n    reason = np.zeros(nlaps, dtype=object)\n    reason[:] = ''\n    isclean[0] = False # discards the first lap of the race\n    reason[0] += 'S' # S as in 'start'\n    \n    # discards pit stop laps\n    driver_pitstops = race_pitstops[race_pitstops.driverId == driver_id]\n    \n    for pitlap in driver_pitstops.lap.values:\n        isclean[pitlap-1:pitlap+1] = False\n        reason[pitlap-1:pitlap+1] += 'P' # P as in 'Pit stop'\n    \n    # discards laps with overtakes\n    # gained positions\n    passes = overtakes_df[(overtakes_df.gainer_id == driver_id) & -(overtakes_df.loser_inpits) & (overtakes_df.gainer_lap == overtakes_df.loser_lap)]\n    for lap in passes.gainer_lap.values:\n        isclean[lap-1] = False\n        reason[lap-1] += 'G' # G as in 'gained a position'\n    \n    # lost positions (including being lapped)\n    losses = overtakes_df[(overtakes_df.loser_id == driver_id) & -(overtakes_df.loser_inpits)]\n    for lap in losses.loser_lap.values:\n        isclean[lap-1] = False\n        reason[lap-1] += 'L' # L as in 'lost a position'\n    \n    # backmarkers\n    backmarkers = overtakes_df[(overtakes_df.gainer_id == driver_id) & -(overtakes_df.loser_inpits) & (overtakes_df.gainer_lap > overtakes_df.loser_lap)]\n    for lap in backmarkers.gainer_lap.values:\n        isclean[lap-1] = False\n        reason[lap-1] += 'B' # B as in 'backmarker'\n    \n    # loops through the laps to check if the driver was held up\n    for n in range(nlaps):\n        if isclean[n]:\n            # reads the driver position\n            pos = driver_laptimes.loc[n+1].position\n            if pos > 1:\n                tend_d1 = driver_laptimes.milliseconds.cumsum()[n]\n                # checks the driver ahead of them\n                ahead_id = race_laptimes[(race_laptimes.position == pos-1) & (race_laptimes.lap == n+1)].driverId.values[0]\n                ahead_laptimes = race_laptimes[race_laptimes.driverId == ahead_id].set_index('lap')\n                tend_ahead = ahead_laptimes.milliseconds.cumsum()[n]\n                tdiff = tend_d1 - tend_ahead\n                if tend_ahead > tend_d1 - 1000. * held_delta:\n                    isclean[n] = False\n                    reason[n] += 'H' # H as in 'held up'\n    \n    driver_laptimes['is_clean'] = isclean\n    driver_laptimes['reason'] = reason\n    return driver_laptimes","bb7ca614":"# plots lap times, pitstops and overtakes\n\ndef plot_laptimes(driver_id):\n    \n    driver_laptimes = classify_laps(driver_id)\n    driver_nlaps = len(driver_laptimes)\n    \n    fig = pylab.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    \n    ax.plot(driver_laptimes.index, driver_laptimes.milliseconds\/1000., color='r', linewidth=2)\n    \n    fastest_lap = driver_laptimes.milliseconds.min()\/1000.\n    pylab.axhline(fastest_lap, color='k', linestyle='--')\n    pylab.text(2, fastest_lap*1.003, 'Fastest lap: %s'%ms_to_msm(fastest_lap*1000.))\n    \n    pit_labeldone = False\n    held_labeldone = False\n    back_labeldone = False\n    pass_labeldone = False\n    lost_labeldone = False\n\n    pylab.xlim(1, driver_nlaps)\n    \n    dirty_laps = driver_laptimes[-driver_laptimes.is_clean]\n    for lap, row in dirty_laps.iterrows():\n        if 'P' in row.reason:\n            if not pit_labeldone:\n                pylab.axvspan(lap-0.5, lap+0.5, color='grey', alpha=0.5, label='Pit stop')\n                pit_labeldone = True\n            else:\n                pylab.axvspan(lap-0.5, lap+0.5, color='grey', alpha=0.5)\n        if 'G' in row.reason:\n            if not pass_labeldone:\n                pylab.axvspan(lap-0.5, lap+0.5, color='g', alpha=0.5, label='Overtake (gain)')\n                pass_labeldone = True\n            else:\n                pylab.axvspan(lap-0.5, lap+0.5, color='g', alpha=0.5)\n        if 'L' in row.reason:\n            if not lost_labeldone:\n                pylab.axvspan(lap-0.5, lap+0.5, color='k', alpha=0.5, label='Overtake (loss)')\n                lost_labeldone = True\n            else:\n                pylab.axvspan(lap-0.5, lap+0.5, color='k', alpha=0.5)\n        if 'B' in row.reason:\n            if not back_labeldone:\n                pylab.axvspan(lap-0.5, lap+0.5, color='b', alpha=0.5, label='Backmarker')\n                back_labeldone = True\n            else:\n                pylab.axvspan(lap-0.5, lap+0.5, color='b', alpha=0.5)\n        if 'H' in row.reason:\n            if not held_labeldone:\n                pylab.axvspan(lap-0.5, lap+0.5, color='orange', alpha=0.5, label='Held up')\n                held_labeldone = True\n            else:\n                pylab.axvspan(lap-0.5, lap+0.5, color='orange', alpha=0.5)\n    \n    pylab.xlabel('Lap number')\n    pylab.ylabel('Time (s)')\n\n    pylab.ylim(0.99*fastest_lap, 1.07*fastest_lap)\n    \n    pylab.legend(loc='upper right')\n    pylab.title('%s'%driverId_to_lastname(driver_id))\n    \n    ax.xaxis.set_major_locator(MultipleLocator(10))\n    ax.xaxis.set_minor_locator(MultipleLocator(1))\n    \n    ax.yaxis.set_major_locator(MultipleLocator(1))\n    ax.yaxis.set_minor_locator(MultipleLocator(0.1))\n    \n    ax.tick_params(axis='both', which='both', direction='in')\n    \n    return ax\n\nax = plot_laptimes(20)","3fd737e2":"from scipy.optimize import minimize\n\n\ndef fit_model(driver_id, show_plot=True, mask=None, ax=None):\n    # gets lap times and clean lap info\n\n    driver_laptimes = classify_laps(driver_id)\n    nlap_all = driver_laptimes.index.to_numpy()\n    tlap_all = driver_laptimes.milliseconds.to_numpy()\/1000.\n    fastest_lap = tlap_all.min()\n    nlap_tot = len(driver_laptimes) + 1\n    \n    clean_laps = driver_laptimes['is_clean'].to_numpy()\n    if mask is not None:\n        clean_laps = clean_laps * mask\n    \n    # splits the data in different stints\n    stops = race_pitstops[race_pitstops.driverId == driver_id].set_index('stop')\n    nstops = len(stops)\n    \n    if nstops > 0:\n        stints = []\n        tire_ages = []\n        \n        stint = nlap_all <= stops.loc[1].lap\n        tire_age = nlap_all[stint]\n        stints.append(stint)\n        tire_ages.append(tire_age)\n        for i in range(1, nstops):\n            stint = (nlap_all > stops.loc[i].lap+1) & (nlap_all <= stops.loc[i+1].lap)\n            tire_age = nlap_all[stint] - stops.loc[i].lap\n            stints.append(stint)\n            tire_ages.append(tire_age)\n        stint = nlap_all > stops.loc[nstops].lap+1\n        tire_age = nlap_all[stint] - stops.loc[nstops].lap\n        stints.append(stint)\n        tire_ages.append(tire_age)\n    else:\n        stints = [np.ones(len(nlap_all), dtype=bool)]\n        tire_ages = [nlap_all]\n        \n    nstints = len(stints)\n    \n    # defines model functions\n    def F_fuel(p):\n        return (nlap_tot - nlap_all) * p[1] + (nlap_tot - nlap_all)**2 * p[2]\n    \n    def F_tires(p):\n        tmp = 0.*nlap_all\n        for i in range(nstints):\n            #tmp[stints[i]] = p[3+3*i] + p[4+3*i]*(tire_ages[i]) * np.exp(tire_ages[i]\/p[5+3*i])\n            tmp[stints[i]] = p[3+2*i]*(tire_ages[i]) * np.exp(tire_ages[i]\/p[4+2*i])\n            #tmp[stints[i]] = p[3+i]*(tire_ages[i])\n        return tmp\n            \n    def model(p):\n        return p[0] * (1. + F_fuel(p)) * (1. + F_tires(p))\n    \n    def cost_func(p):\n        return ((model(p) - tlap_all)**2)[clean_laps].sum()\n    \n    # starting guess of the parameter values\n    \n    p_guess = np.zeros(3 + 2*nstints)\n    p_guess[0] = fastest_lap\n    p_guess[1] = 0.0001 # 1% increase in lap time every 10 laps due to fuel\n    p_guess[2] = 0.\n    \n    bounds = []\n    bounds.append((0.9*fastest_lap, 1.1*fastest_lap))\n    bounds.append((0., 1.))\n    bounds.append((-1., 1.))\n    for i in range(nstints):\n        p_guess[4+2*i] = 20.\n        bounds.append((0., 1.))\n        bounds.append((1., 100.))\n    \n    res = minimize(cost_func, p_guess, method='Nelder-Mead', bounds=bounds)\n    \n    print('Best-fit parameter values:')\n    print('t_best: %s'%ms_to_msm(res.x[0]*1000.))\n    print('alpha_1: %e'%res.x[1])\n    print('alpha_2: %e'%res.x[2])\n    for i in range(nstints):\n        print('beta_1(%d): %e'%(i+1, res.x[3+2*i]))\n        print('beta_2(%d): %2.1f'%(i+1, res.x[4+2*i]))\n    \n    if show_plot:\n        \n        if ax is None:\n            fig = pylab.figure()\n            ax = fig.add_subplot(1, 1, 1)\n        \n        ax.plot(nlap_all, tlap_all, color='r', linewidth=2)\n        labeldone = False\n        for stint in stints:\n            if not labeldone:\n                pylab.plot(nlap_all[stint], model(res.x)[stint], color='g', linewidth=2, label='Full Model')\n                labeldone = True\n            else:\n                pylab.plot(nlap_all[stint], model(res.x)[stint], color='g', linewidth=2)\n    \n        p_fuelonly = res.x.copy()\n        p_fuelonly[3:] = 0.\n    \n        pylab.plot(nlap_all, p_fuelonly[0] * (1. + F_fuel(p_fuelonly)), color='k', linewidth=2, label='Fuel model only')\n        \n        if mask is not None:\n            for i in range(len(nlap_all)):\n                if not mask[i]:\n                    pylab.axvspan(nlap_all[i]-0.5, nlap_all[i]+0.5, color='grey')\n    \n        #for i in range(len(nlap_all)):\n        #    if not clean_laps[i]:\n        #        pylab.axvspan(nlap_all[i]-0.5, nlap_all[i]+0.5, color='grey', alpha=0.5)\n        #pylab.ylim(0.99*fastest_lap, 1.07*fastest_lap)\n        pylab.legend(loc=\"upper right\")\n    \n    return res.x\n\nax = plot_laptimes(20)\npars = fit_model(20, ax=ax)\n","6873e766":"lap_mask = np.ones(58, dtype=bool)\nlap_mask[37] = 0\n\nax = plot_laptimes(20)\npars = fit_model(20, ax=ax, mask=lap_mask)","fe20faa2":"ax = plot_laptimes(17)\npars = fit_model(17, ax=ax)","da018a50":"## Modelling the race pace\n\nLet's come up with a simple model to describe how the race pace varies from one lap to another. The goal here is to capture two main features:\n1. The decrease in lap time as a result of the decreasing fuel load\n2. The increase in lap time as a result of tire wear\n\nLet's define as $t_{\\rm{best}}$ the theoretical best time. This is the lap time a driver would be able to do with a low fuel load (in the last lap of the race) with fresh tires of the softest available compound (that is, the set of tires with the best performance on a single lap). Let $n_{\\rm{tot}}$ be the total number of laps in a race. We can try to describe the lap time as a function of lap number $n$ as follows:\n\n$t^{(\\mathrm{model})}(n) = t_{\\rm{best}}\\left[1 + F_{\\rm{fuel}}(n)\\right][1 + F_{\\rm{tires}}(n)],$\n\nwhere $F_{\\rm{fuel}}$ and $F_{\\rm{tires}}$ are two terms describing the fractional increase in lap time with fuel load and tire wear, respectively. The $1 + \\ldots$ are there so that when $F_{\\rm{fuel}},F_{\\rm{tire}}\\rightarrow 0$ the lap time reaches $t_{\\rm{best}}$.\n\n### Fuel term\n\nLet's use a quadratic function for $F_{\\rm{fuel}}$:\n\n$F_{\\rm{fuel}}(n) = \\alpha_1(n_{\\rm{tot}} - n) + \\alpha_2(n_{\\rm{tot}} - n)^2,$\n\nwhere $\\alpha_1$ and $\\alpha_2$ are two coefficients to be determined from the data. Notice that there's no constant term: this is because we want $F_{\\rm{fuel}} = 0$ when $n = n_{\\rm{tot}}$ (that is, on the last lap of the race).\n\n### Tire term\n\nModelling tire performance is a bit more tricky. This is because there are multiple types of tires available to the drivers (for example: soft, medium, hard), each with a different performance. Since we've defined $t_{\\rm{best}}$ to be the best lap time achievable with the softest available tire, it follows that $F_{\\rm{tire}}$ should be larger than zero for all of the harder compound tires. In principle one should be able to see that from the data, but $F_{\\rm{tire}}$ is degenerate with $F_{\\rm{fuel}}$ and it's going to be really difficult to disentangle the effect of varying the tire compound vs. having a lower fuel load, when all we have is information from only three race stints.\n\nAnyway, $F_{\\rm{tire}}$ should be a positive number that increases with the age of the tire (the number of laps they have been used for). The loss in performance, however, does not go at a constant rate: it is usually relatively low for a given amount of laps and then shoots up (\"Bono, my tires are gone!\"). With this in mind, one possible choice for $F_{\\rm{tire}}$ is the following:\n\n$F_{\\rm{tire}} = \\beta_1 n_{\\rm{age}}e^{n_{\\rm{age}}\/\\beta_2},$\n\nwhere $n_{\\rm{age}}$ is the age of the tire in number of laps. This function is described by two parameters. For a set of new tires, $n_{\\rm{age}}=0$ and $F_{\\rm{tire}} = 0$. This is not super accurate for harder tires, for the reasons discussed above, but we'll stick with this model for simplicity. For small values of $n_{\\rm{age}}$, the function above is approximately linear, with a slope given by $\\beta_1$. For large values of $n_{\\rm{age}}$ instead, the exponential part of the function dominates, and performance worsens exponentially. The parameters $\\beta_1$ and $\\beta_2$ can in principle vary from one stint to another, so we'll indicate the stint number with a superscript, as follows:\n\n$\\beta_1^{(1)}$:= Tire parameter $\\beta_1$ of the first stint.\n$\\beta_2^{(1)}$:= Tire parameter $\\beta_2$ of the first stint.\n\n$\\ldots$\n\n\n## Optimization problem\n\nOur model is described by a set of parameters, which we refer collectively to with the symbol $\\theta$: \n\n$\\theta\\equiv\\left\\{t_{\\rm{best}},\\alpha_1,\\alpha_2,\\beta_1^{(1)},\\beta_2^{(1)},\\ldots,\\beta_1^{(n_s)}\\beta_2^{(n_s)}\\right\\},$\n\nwhere $n_s$ is the number of stints.\nWe want to find that set of values of the parameters that minimizes the following cost function:\n\n$J(\\theta) = \\sum_{n\\in\\rm{clean}} (t^{(\\mathrm{model})}(n) - t^{(\\mathrm{data})}(n))^2$\n\nWe can use one of Scipy's optimizers to find the solution.\n\nIt's important to put bounds on the parameter values, or priors, to avoid unphysical solutions.\nFor example, if we want $F_{\\rm{fuel}}$ to be positive (higher load = slower car), we should impose $\\alpha_1 > 0$. Similarly, if we want tire performance to worsen with tire age, we should impose $\\beta_1 > 0$.","a19a7e06":"Vettel made two stops. We can see his lap times going down in each stint, as a result of his lower fuel load. Lap times tend to oscillate by a few tens of a second. In some cases, a slower lap corresponds to a lapped backmarker, but not always. We can also clearly see the lap times shooting up right before a pit stop (lap 13 and lap 35). This indicates that the tires are quickly running out of performance at that point, hence the pit stop in the following lap.","0deccc17":"### Driver held up\n\nWe know when our driver made overtakes and pitstops. Now we need to figure out if they were held up by another driver at any point in the race. The definition of \"being held up\" is a bit subjective: how close does a driver have to be to another driver, before their performance takes a hit? It depends on the track: often, riding close behind another driver will cause the tires to wear out faster. Therefore, especially if there are no overtaking opportunities, drivers will sometimes leave a bit of a cushion between them and the driver in front. Let's pick 1.5s as the maximum gap below which a driver is \"officially\" being held up.\n\nWith all these definitions, let's classify the race laps in \"clean\" vs. \"not clean\".","1d94ce9d":"This makes more sense. \n\nLet's now look at some of the parameter values. According to the model, the theoretical best lap time is\n\n$t_{\\rm{best}} = 1.29.746$\n\nwhich is very close to the actual fastest lap done by Vettel in the race.","f7904f7e":"# Race pace analysis\n\nThis notebook looks at the race pace of a driver in a given race.\nI define the race pace to be the average lap time done under clear track conditions.\n\nThe race pace is usually not constant: lap times typically get lower as the race progresses and the car gets lighter. But the pace varies also as a function of tire wear. This notebook tries to separate the two effects, by modelling (more on this later).\n\n## Clean lap selection\nWhen quantifying the race pace, it's important to only consider *clean laps*. Here is a list of what are NOT clean laps:\n- The first lap of a race\n- The in-lap or out-lap of a pit stop\n- A lap in which a driver is held up behind a slower car\n- A lap in which an overtake took place (including lapping a backmarker)\n- A lap under safety car or virtual safety car conditions\n- A lap in which the driver made a major mistake\n\nDetermining whether a lap was a clean one is not always straightforward: ultimately, only the drivers themselves know which laps were clean and which weren't. But this notebook tries to figure that out from the available data.\n\nAs an example, we'll look at Sebastian Vettel's pace at the 2011 Australian Gran Prix.","fd48bf52":"Let's have a look at the overtakes in which Sebastian Vettel was involved.","07cfe7f5":"## Discussion\n\nThe model looks... meh. It is able to sort of pick up the exponential degradation behavior of the tires in the first two stints, but the third stint doesn't make much sense: it looks like the tire performance stays pretty much constant. Throughout the stint. This is probably caused by the fact that Vettel had a horrible lap 38, one lap after he got out of the pits. Let's try repeating the fit while removing lap 38 from the dataset.","623f817e":"That's a lot of overtakes. The first entry in the DataFrame is an instance in which Vettel (driverId=20) lost a position to Hamilton (driverId=1) on lap 14. That's because Vettel went into the pits on that lap. He then gained his position back when Hamilton pitted on lap 17. \n\nMore interesting is what happened on lap 16, in which Vettel passed Jenson Button (driverId=18) on track.\nThat's the only time Vettel gained a position with an overtake on track, in that race. All of the other overtakes were either the result of pit stops or involved backmarkers.\n\nBackmarkers can be identified by the fact that, when the overtake took place, they were on an earlier lap compared to the overtaking driver.\n\nAlso in that case, it's important to keep track whether the lapped driver was in the pits. For example: it looks like Vettel passed driverId=10 (Timo Glock) several times on consecutive laps (rows 21 to 29 of the output above). But apparently Glock was stuck in the pits for a very long time on that occasion.","b3f17526":"## Conclusions\n\nWhat did we learn? Well, if we want to figure out how car performance varies with fuel load and tire wear, looking at race data is probably not the best. There are too many variables that we just don't know anything about: how much was the driver pushing? Was the driver held up by a backmarker? How did track conditions change over the course of the race? What about tire temperature? Moreover, the derived model parameters are very sensitive to which laps are considered in the fit. In this example we handpicked one lap and removed it from the dataset, and the model changed dramatically. We could try to make the process less arbitrary by adopting an automatic clipping of \"bad laps\", but still...\n\nAnyway, this is one possible way to look at these data. Hope you enjoyed it.","7adb7841":"Webber made three stops and ended up fifth. It looks like he was running closely behind another driver for at least seven laps. What's interesting here is that his lap times right after the tire changes seem to be sistematically higher than in the rest of the stint, which is something we observed in Vettel's third stint. This is a bit counter-intuitive: shouldn't tires work best when they're fresh? However, it could be related to the tires not being yet at the right operating temperature.\n\nIf we look at the inferred values of the parameters, we see that $\\beta_2$ is pretty much all over the place. That makes it hard to use these measurements for anything quantitative.","282b3035":"### Overtakes\n\nAs a first thing, let's gather information on overtakes that took place during the race. The most reliable way to catch an overtake would be to use GPS data, but we don't have it here. So we'll have to use lap times instead.\n\n*Given two drivers, D1 and D2, an overtake took place if D1 started a lap after D2 and finished it before D2.*\n\nWith this definition, we can find all of the overtakes of the race by looping through pairs of drivers and laps. It can be useful to also take note of whether a driver was coming in or out of the pits when the overtake took place: this can help distinguish an actual on-track overtake from one following a pit stop.","f5891588":"Let's look at another driver, for instance Mark Webber, Sebastian Vettel's teammate at the time.","1d43f31d":"Let's have a look at Sebastian Vettel lap times"}}