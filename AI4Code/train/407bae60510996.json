{"cell_type":{"560206d6":"code","0fdfe102":"code","35563348":"code","8df7687d":"code","c9ea133c":"code","c5fd81b8":"code","14e42f2e":"code","ffd0df05":"code","b9721930":"code","61ed29a8":"code","c83c355f":"code","a4b78abe":"code","c07cfe8e":"code","4945b7cc":"code","fb85953e":"code","a90f2b4d":"code","e6a74a2f":"code","bfe591c8":"code","eb14e305":"code","b75bc1a6":"code","e7a09259":"code","ec8a6b4d":"markdown","d9fe6620":"markdown","23792826":"markdown","064e53a5":"markdown","131b57b3":"markdown","311a2cd5":"markdown","02e94e66":"markdown","70de6ff9":"markdown","3abf8dd1":"markdown","17d68ae4":"markdown","21780bec":"markdown","190853e5":"markdown","2b32b303":"markdown"},"source":{"560206d6":"import pandas as pd\nimport os\nfrom sklearn.model_selection import train_test_split\nimport glob\n\nimport torch\nfrom torch import nn\nimport torchvision\nfrom torch.utils.data import Dataset,DataLoader\nimport cv2\nimport pytorch_lightning as pl\nimport torchvision.transforms as transforms","0fdfe102":"vehicles = glob.glob(f\"..\/input\/vehicle-detection-image-set\/data\/vehicles\/*.png\")#returns a list of paths of images in Vehicles folder\nnon_vehicles = glob.glob(f\"..\/input\/vehicle-detection-image-set\/data\/non-vehicles\/*.png\")#returns a list of paths of images in non-Vehicles folder","35563348":"data1 = {\n    \"mask_id\": vehicles,\n    \"mask\":\"vehicles\"\n}\ndata2 = {\n    \"mask_id\": non_vehicles,\n    \"mask\":\"non_vehicles\"\n}\nvehicles = pd.DataFrame(data1)# a dataframe with the path and labels\nnon_vehicles = pd.DataFrame(data2)\n\ndf  = pd.concat([vehicles,non_vehicles],ignore_index= True)#combining the two datasets\ndf","8df7687d":"def label(x):\n    if x == \"vehicles\":\n        return 1\n    if x == \"non_vehicles\":\n        return 0","c9ea133c":"df[\"mask\"] = df[\"mask\"].apply(label)# encoding the label numerically\ndf","c5fd81b8":"X  = df[\"mask_id\"]\ny = df[\"mask\"]\nx_train , x_test , y_train, y_test = train_test_split(X,y,test_size = 0.25,random_state = 42 ,)\nx_val , x_test , y_val, y_test = train_test_split(x_test,y_test,test_size = 0.25,random_state = 42 ,)\n","14e42f2e":"class MaskDataset(torch.utils.data.Dataset):\n    def __init__(self,image,targets = None):\n        self.image = image\n        self.targets = targets\n        \n    def __len__(self):\n        return len(self.image)\n    \n    def __getitem__(self,index):\n        path = self.image[index]\n        image = cv2.imread(path)\n        image = cv2.resize(image,(256,256))\n        #image = transformations(image)\n        if self.targets is None:\n            return torch.tensor(image).float().reshape(3,256,256)\n        return torch.tensor(image).float().reshape(3,256,256) , torch.tensor(self.targets[index])","ffd0df05":"mask = MaskDataset(image = x_train.values , targets = y_train.values)\nimage , label = next(iter(DataLoader(mask,batch_size = 6,shuffle = True)))\nimage","b9721930":"train_dataset = MaskDataset(\n                x_train.values,\n                y_train.values\n)\n\ntest_dataset = MaskDataset(\n                    x_test.values,\n                    y_test.values\n)\nprediction_dataset = MaskDataset(\n                    x_test.values,\n)\n\nvalidation_dataset = MaskDataset(\n                    x_val.values,\n                    y_val.values\n)\n\n","61ed29a8":"class Vehicle_DataModule(pl.LightningDataModule):\n    def __init__(self):\n        super().__init__()\n        self.train = train_dataset\n        self.val = validation_dataset\n        self.test = test_dataset\n        self.prediction = prediction_dataset\n        \n    def train_dataloader(self):\n        return DataLoader(self.train,batch_size = 64,shuffle = True,num_workers=2)\n    def val_dataloader(self):  \n        return DataLoader(self.val,batch_size = 32,shuffle = False,num_workers=1)\n    def test_dataloader(self):\n        return DataLoader(self.test,batch_size = 32,shuffle = False,num_workers=1)\n    def predict_dataloader(self):\n        return DataLoader(self.prediction,batch_size = 1,shuffle = False,num_workers=1)","c83c355f":"neural_network = torchvision.models.resnet50(pretrained= True)\nneural_network.fc = torch.nn.Linear(2048,2)# changing the number of output features to 2","a4b78abe":"loss_func = torch.nn.CrossEntropyLoss()","c07cfe8e":"loss_func = torch.nn.CrossEntropyLoss()","4945b7cc":"class Vehicle_Model(pl.LightningModule):\n    def __init__(self):\n        super().__init__()\n        self.neural_net = neural_network\n        \n    def forward(self,x):\n        return self.neural_net(x)\n    \n    def configure_optimizers(self):\n        optimizer = torch.optim.Adam(self.parameters() , lr = 1e-4)\n        #choosing a optimizer\n        sch = torch.optim.lr_scheduler.StepLR(optimizer, step_size = 20, gamma=0.5, last_epoch=-1, verbose=False)\n        return {\n        \"optimizer\": optimizer,\n        \"lr_scheduler\": {\n            \"scheduler\": sch,\n            \"monitor\": \"val_loss\",\n        },\n    }\n    \n    def training_step(self,batch,batch_idx):\n        x,y = batch\n        y_pred = self(x)\n        #y = y.unsqueeze(-1)\n        loss = loss_func(y_pred,y)\n        return loss\n    \n    def validation_step(self,batch,batch_idx):\n        x,y = batch\n        y_pred = self(x)\n        #y = y.unsqueeze(-1)\n        loss = loss_func(y_pred,y)\n        self.log(\"val_loss\" ,loss )\n        return loss\n    def test_step(self,batch,batch_idx):\n        x,y = batch\n        y_pred = self(x)\n        #y = y.unsqueeze(-1)\n        loss = loss_func(y_pred,y)\n        self.log(\"test_loss : \" , loss)\n        return loss","fb85953e":"from pytorch_lightning.callbacks import ModelCheckpoint\ncheckpoint_callback = ModelCheckpoint(\n                            monitor = \"val_loss\",#monitors val loss\n                            mode = \"min\",#Picks the fold with the lowest val_loss\n)","a90f2b4d":"%%time # Checking the amount of time the cell takes to run\nfrom pytorch_lightning import Trainer\nmodel = Vehicle_Model()\nmodule = Vehicle_DataModule()\ntrainer = Trainer(max_epochs=1,gpus = 1,callbacks = [checkpoint_callback])\ntrainer.fit(model,module)","e6a74a2f":"trainer.test()# testing the loss on the test set","bfe591c8":"predictons = trainer.predict()","eb14e305":"probs = nn.Softmax() # since the outputs are logits we use the softmax function to obtain probabilities\n\ndef get_score(y_pred,y):\n    probabilities = []\n    accuracy = 0\n    for x in y_pred:\n        prob = probs(x)\n        top_p, top_class = prob.topk(1, dim = -1)\n        probabilities.append(float(top_class))\n    i = 0\n    for x in y:\n        if int(x) == int(probabilities[i]):\n            accuracy = accuracy + 1\n        i = i +1\n    score = accuracy\/len(probabilities)\n    return score # returns accuracy","b75bc1a6":"get_score(predictons,y_test.values)","e7a09259":"predictons = trainer.predict()","ec8a6b4d":"# The Model","d9fe6620":"Medium Link:- https:\/\/keeganfdes03.medium.com\/image-classification-using-pytorch-lightning-b3399e6f2acb","23792826":"# Dataset","064e53a5":"![car](https:\/\/images.pexels.com\/photos\/3422964\/pexels-photo-3422964.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=650&w=940)","131b57b3":"Dividing the dataframe into train test and validation sets","311a2cd5":"# Sanity Check","02e94e66":"# Model","70de6ff9":"#  Datamodule","3abf8dd1":"# Preprocessing","17d68ae4":"# Trainer","21780bec":"# Testing","190853e5":"# Dependencies","2b32b303":"Checking the Acuuracy"}}