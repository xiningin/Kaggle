{"cell_type":{"f04ebf7d":"code","7f44c401":"code","08a9418c":"code","463920ba":"code","2b46d75d":"code","4838b2cb":"code","e75d1afb":"code","0953be03":"code","6b89e85b":"code","0ea0df4a":"code","d177b84e":"code","b09b3480":"code","0bd869c1":"code","17fabe23":"code","0b818ab8":"code","33fde9fe":"code","1503462a":"markdown","e6d89001":"markdown","ca66d501":"markdown","bc2b5b64":"markdown"},"source":{"f04ebf7d":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport math\nimport os\nimport random\nfrom pandas_datareader import data as wb\nimport matplotlib.pyplot as plt\nfrom datetime import datetime","7f44c401":"def period(start, end, distance = 1):\n    s = start.split('-')\n    e = end.split('-')\n    y1 = int(s[0])\n    m1 = int(s[1])\n    d1 = int(s[2])\n    y2 = int(e[0])\n    m2 = int(e[1])\n    d2 = int(e[2])\n    dates = []\n    dates.append(start)\n    while((y1 < y2) or (y1 == y2 and m1 < m2) or (y1 == y2 and m1 == m2 and d1 <= d2 - distance)):\n        if(np.isin(m1, [1,3,5,7,8,10])):\n            d1 += distance\n            if(d1 > 31):\n                d1 = d1%31\n                m1 += 1\n        elif(m1 == 12):\n            d1 += distance\n            if(d1 > 31):\n                d1 = d1%31\n                m1 = 1\n                y1 += 1\n        elif(np.isin(m1, [4,6,9,11])):\n            d1 += distance\n            if(d1 > 30):\n                d1 = d1%30\n                m1 += 1\n        elif(m1 == 2):\n            d1 += distance\n            if((y1\/4 - math.floor(y1\/4)) == 0):\n                if(d1 > 29):\n                    d1 = d1%29\n                    m1 += 1\n            else:\n                if(d1 > 28):\n                    d1 = d1%28\n                    m1 += 1\n        else:\n            print(\"Error: month > 12\")\n        dates.append(str(y1)+'-'+str(m1)+'-'+str(d1))\n        df = pd.DataFrame(dates,columns=['Date'])\n        df['Date'] =  pd.to_datetime(df['Date'], format='%Y-%m-%d')\n        df = df.set_index(['Date'])\n        #df = pd.to_datetime(df)\n    return df\ndef month_list(start_date,end_date):\n    start_d = start_date.split('-')[2]\n    start_m = start_date.split('-')[1]\n    start_y = start_date.split('-')[0]\n    end_d = end_date.split('-')[2]\n    end_m = end_date.split('-')[1]\n    end_y = end_date.split('-')[0]\n    n_months = ((int(end_y) - int(start_y))*12) + ((int(end_m) - int(start_m)))\n    months = []\n    y = int(start_y)\n    for i in range(n_months):\n        m = ((int(start_m) - 1 + i)%12) + 1\n        if(((int(start_m)-1 + i)%12) == 0 and i != 0):\n            y += 1 \n        date = str(y) + '-' + str(m) + '-' + str(1)\n        months.append(date)\n    months = pd.DataFrame(months, columns=['Date'])\n    months['Date'] =  pd.to_datetime(months['Date'], format='%Y-%m-%d')\n    months = months.set_index(['Date'])\n    return months\n\ndef load_table(path, dvd = True):\n    files = os.listdir(path)\n    df_list = list()\n    for i in range(len(files)):\n        table = pd.read_csv(path+files[i],index_col='Date',parse_dates=True)[['Close']]\n        name = files[i].replace(\".csv\",\"\")\n        table.columns = [name]\n        df_list.append(table)\n    df = df_list[0]\n    for df_ in df_list[1:]:\n        df = pd.concat([df,df_], axis=1)\n    df.fillna(method='ffill',inplace=True)\n    return df_list, df\n\ndef monthly_returns(price, start_date, end_date):\n    months = month_list(start_date,end_date)\n    returns_df = pd.DataFrame(months.index,columns=['Date'])\n    for col in price.columns:\n        values = []\n        for i in range(len(months)-1):\n            idx = price.loc[(price.index >= months.index[i]) & (price.index < months.index[i+1])].index\n            v = price.loc[idx,col].iloc[0]\n            values = np.append(values,v)\n            values = pd.DataFrame(values,columns=[col])\n        returns_df = pd.concat([returns_df,values],axis=1)\n    returns_df.drop(len(months)-1,axis=0,inplace=True)\n    returns_df = returns_df.set_index(\"Date\")\n    returns = returns_df.pct_change()*100\n    returns = returns.drop(returns.index[0], axis=0)\n    return returns_df\n\ndef tree_to_table(tree, name_str):\n    n_gen = len(tree)\n    n_chrom = len(tree[0])\n    name = []\n    gen = []\n    chrom = []\n    ret = []\n    vol = []\n    sr = []\n    res = []\n    for i in range(n_gen):\n        for j in range(n_chrom):\n            name.append(name_str)\n            gen.append(i)\n            chrom.append(j)\n            ret.append(tree[i][j].get_expected_return())\n            vol.append(tree[i][j].get_volatility())\n            sr.append(tree[i][j].get_sharpe_ratio())\n    d = {'name': name, 'generation': gen, 'chromosome': chrom, 'return': ret, 'volatility': vol, 'sharpe_ratio': sr}\n    df = pd.DataFrame(data=d)\n    return df","08a9418c":"class Portfolio:\n    def __init__(self, returns_df, corr_matrix, risk_free):\n        self.returns = returns_df\n        self.corr = corr_matrix\n        self.description = self.returns.describe()\n        self.n_assets = self.returns.shape[1]\n        self.risk_free = risk_free\n        self.initialize_weights()\n        self.set_expected_return()\n        self.set_volatility()\n        self.set_sharpe_ratio()\n        return None\n    def initialize_weights(self):\n        self.weights = np.random.rand(self.n_assets)\n        self.weights = (self.weights\/self.weights.sum())\n        return None\n    def set_weights(self, weights):\n        self.weights = (weights\/weights.sum())\n        self.set_discrete_weights = self.weights\n        return None\n    def set_expected_return(self):\n        weighted = self.weights*self.description.loc['mean']\n        self.expected_return = weighted.sum().round(2)\n        return None\n    def set_volatility(self):\n        std = self.description.loc['std'].values\n        m1 = (self.weights*std).reshape(self.n_assets,1)\n        m2 = m1.reshape(1,self.n_assets)\n        self.volatility = math.sqrt((m1*self.corr*m2).sum())\n        return None\n    def set_sharpe_ratio(self):\n        self.sharpe_ratio = (self.expected_return-self.risk_free)\/self.volatility\n        return None\n    def get_weights(self):\n        return self.weights\n    def get_expected_return(self):\n        return self.expected_return\n    def get_volatility(self):\n        return self.volatility\n    def get_sharpe_ratio(self):\n        return self.sharpe_ratio","463920ba":"class Genetic_algorithm:\n    def __init__(self, returns_df, corr_matrix, risk_free, size):\n        self.returns = returns_df\n        self.corr = corr_matrix\n        self.risk_free = risk_free\n        self.size = size\n        return None\n    def run(self, iterations, variable):\n        self.initialize()\n        for i in range(iterations):\n            self.set_fitness(variable)\n            self.select_fittest()\n            self.crossover()\n            self.mutation()\n            self.pass_generation(variable)\n        return None\n    def initialize(self):\n        self.population = []\n        self.offspring = []\n        self.population_best = []\n        self.population_fitness = []\n        self.population_mean  = []\n        self.tree = list()\n        for i in range(self.size):\n            self.population.append(Portfolio(self.returns, self.corr, self.risk_free))\n        self.population_df = self.to_table(self.population)\n        self.tree.append(self.population)\n        return None\n    def set_fitness(self, variable):\n        if(variable == 'volatility'):\n            max_volatility = self.population_df[variable].max()\n            self.population_df.sort_values(by=variable, inplace=True, ascending=True)\n            self.population_df['fitness'] = max_volatility - self.population_df[variable] + 1\n            self.population_df['fitness'] = self.population_df['fitness']\/self.population_df['fitness'].sum()\n        else:\n            self.population_df.sort_values(by=variable, inplace=True, ascending=False)\n            self.population_df['fitness'] = self.population_df[variable]\/self.population_df[variable].sum()\n        self.population_df['selection_prob'] = self.population_df['fitness']\n        for i in range(1, len(self.population_df['selection_prob'])):\n            self.population_df['selection_prob'].iloc[i] = self.population_df['selection_prob'].iloc[i-1] + self.population_df['selection_prob'].iloc[i]\n        return self.population_df\n    def select_fittest(self, rand = True):\n        third = int(self.size\/3)\n        idx = self.population_df.head(third).index.values\n        if(rand == True):\n            for i in idx:\n                self.offspring.append(self.population[i])\n                p = Portfolio(self.returns, self.corr, self.risk_free)\n                self.offspring.append(p)\n        else:\n            for i in idx:\n                self.offspring.append(self.population[i])\n        return None\n    def crossover(self):\n        rest = self.size - len(self.offspring)\n        for i in range(rest):\n            idx_parent1 = self.select_parent()\n            idx_parent2 = self.select_parent()\n            alpha = random.random()\n            w3 = alpha*self.population[idx_parent1].get_weights() + (1-alpha)*self.population[idx_parent2].get_weights()\n            p = Portfolio(self.returns, self.corr, self.risk_free)\n            p.set_weights(w3)\n            self.offspring.append(p)\n        return None\n    def mutation(self):\n        n_assets = len(self.population[0].get_weights())\n        for child in self.offspring:\n            idx1 = random.randrange(0,n_assets)\n            idx2 = random.randrange(0,n_assets)\n            w = child.get_weights()\n            minimo = min(w[idx1],w[idx2])\n            rand = random.uniform(0,minimo)\n            w[idx1] += rand\n            w[idx2] -= rand\n            child.set_weights(w)\n        return None\n    def pass_generation(self, variable):\n        self.population = self.offspring\n        self.offspring = []\n        self.population_df = self.to_table(self.population)\n        self.tree.append(self.population)\n        best = self.population[0]\n        mean_fit = self.population_df[variable].mean()\n        if(variable == 'volatility'):\n            max_fit = self.population_df.sort_values(by=variable, ascending=True).head(1)[variable].iloc[0]\n        else:\n            max_fit = self.population_df.sort_values(by=variable, ascending=False).head(1)[variable].iloc[0]\n        self.population_best.append(best)\n        self.population_fitness.append(max_fit)\n        self.population_mean.append(mean_fit)\n        return None\n    def select_parent(self):\n        roulette = random.random()\n        i = 0\n        while roulette > self.population_df['selection_prob'].iloc[i]: \n            i += 1\n        if(i > 0):\n            i = i - 1\n        return self.population_df.iloc[i,:].name\n    def to_table(self, array):\n        exp_returns = [s.get_expected_return() for s in array]\n        volatilities = [s.get_volatility() for s in array]\n        sharpe_ratios = [s.get_sharpe_ratio() for s in array]\n        d = {'return': exp_returns, 'volatility': volatilities, 'sharpe_ratio' : sharpe_ratios}\n        df = pd.DataFrame(data=d) \n        return df\n    def get_samples(self):\n        return self.samples\n    def get_population(self,variable):\n        self.population_df.sort_values(by=variable, inplace=True, ascending=False)\n        idx = self.population_df.head(1).index.values[0]\n        return self.population[idx]\n    def get_tree(self, variable):\n        return self.tree\n    def get_analysis(self):\n        d = {'best_fitness':self.population_fitness,'fitness_mean':self.population_mean}\n        output = pd.DataFrame(data=d) \n        return output","2b46d75d":"folder = \"..\/input\/stocks-historical-price-data\/historical_data\/\"\n\nstart_date = '2019-5-29'\nend_date = '2021-7-1'\n\nstock_names = ['AAPL', 'ADBE', 'AMZN','BTC-USD', 'FB', 'GC=F', '^IRX','MSFT', 'NVDA', 'QCOM','TSLA','TXN']\n\nrisk_free = 1.28","4838b2cb":"df_list, df = load_table(folder)\ndaily = period('2019-5-31', end_date, distance=1)\nstock_price = pd.merge(daily, df, on='Date', how='left')\nstock_price.fillna(method='ffill',inplace=True)\nmonths = month_list('2019-6-1',end_date)\nmonthly_price = pd.merge(months, stock_price, on='Date', how='left')\nmonthly_returns = monthly_price.pct_change()*100\nmonthly_returns = monthly_returns.drop(monthly_returns.index[0], axis=0)\ncorr = monthly_returns.corr()\ncorr_matrix = corr.values","e75d1afb":"sns.set()\nplt.figure(figsize=(15,8))\nmask = np.triu(np.ones_like(corr, dtype=bool))\nax = sns.heatmap(data=corr, annot=True, mask=mask)\nbottom, top = ax.get_ylim()\nax.set_ylim(bottom + 0.5, top - 0.5)","0953be03":"population_size = 50\nn_generations = 100\nGA = Genetic_algorithm(monthly_returns, corr_matrix, risk_free, population_size)","6b89e85b":"variable = 'return'\nGA.run(n_generations,variable)\ntree1 = GA.get_tree(variable)\nanalysis1 = GA.get_analysis()\nvariable = 'volatility'\nGA.run(n_generations,variable)\ntree2 = GA.get_tree(variable)\nanalysis2 = GA.get_analysis()\nvariable = 'sharpe_ratio'\nGA.run(n_generations,variable)\ntree3 = GA.get_tree(variable)\nanalysis3 = GA.get_analysis()","0ea0df4a":"result1_df = tree_to_table(tree1, 'tree_1')\nresult2_df = tree_to_table(tree2, 'tree_2')\nresult3_df = tree_to_table(tree3, 'tree_3')\nresults_df = pd.concat([result1_df, result2_df, result3_df])","d177b84e":"results_df.sort_values(by = ['return','volatility'], inplace=True, ascending=[False,True])\nb1 = results_df.head(1)\nresults_df","b09b3480":"results_df.sort_values(by = ['volatility','return'], inplace=True, ascending=[True,False])\nb2 = results_df.head(1)\nresults_df","0bd869c1":"results_df.sort_values(by='sharpe_ratio', inplace=True, ascending=False)\nb3 = results_df.head(1)\nresults_df","17fabe23":"plt.figure(figsize=(16,9))\nsns.scatterplot(x = results_df['volatility'],y = results_df['return'], size=results_df['generation'], hue=results_df['generation']) #, style=results_df['name'])\nplt.scatter(x = b1['volatility'].iloc[0], y = b1['return'].iloc[0], marker = '*', color = 'r', s =500, label = 'Max E[Retorno]')\nplt.scatter(x = b2['volatility'].iloc[0], y = b2['return'].iloc[0], marker = '*', color = 'g', s =500, label = 'Max E[Retorno]')\nplt.scatter(x = b3['volatility'].iloc[0], y = b3['return'].iloc[0], marker = '*', color = 'y', s =500, label = 'Max E[Retorno]')","0b818ab8":"best_portfolios = pd.concat([b1,b2,b3])\nbest_portfolios","33fde9fe":"w1 = tree2[best_portfolios['generation'].iloc[0]][best_portfolios['chromosome'].iloc[0]].get_weights()\nw2 = tree2[best_portfolios['generation'].iloc[1]][best_portfolios['chromosome'].iloc[1]].get_weights()\nw3 = tree1[best_portfolios['generation'].iloc[2]][best_portfolios['chromosome'].iloc[2]].get_weights()\nd = {'stock_name': stock_names, 'Weights_Portafolio_retorno_maximo': w1, 'Weights_Portafolio_volatilidad_minima': w2, 'Weights_Portafolio_sharperatio_optimo': w3}\nbest_portfolios_weights = pd.DataFrame(data=d)\nbest_portfolios_weights","1503462a":"## 2. Data load and preparation\n\nFirst we set the date period to be analyzed and the stocks of the portfolio. In this example we select the stocks of Apple, Adobe, Amazon, Facebook, Microsoft, Nvidia, Qualcomm, Tesla, Texas instruments and for diversification Bitcon, Gold and the 13 Week Treasury Bil. We choose a period of two years between the first of june of 2019 and the first of july of 2021 with a month periodicty.\n\nThen we load the historical prices and calculate the monthly returns, and correlation matrix.","e6d89001":"# Genetic algorithm for portfolio optimization\n\n<ul style=\"list-style-type:none;\">\n    <li>1. Introduction<\/li>\n    <li>2. Data load and preparation<\/li>\n    <li>3. Genetic algorithm setings<\/li>\n    <li>4. Results and conclusions<\/li>\n<\/ul>\n\n### 1. Introduction\n\n#### Portfolio theory\n\nA portfolio is a collection of financial investments like stocks, bonds, commodities, cash, and cash equivalents. A portfolio may contain a wide range of assets including real estate, art, and private investments. \n\nOne of the key concepts in portfolio management is the diversification of assets. Diversification tries to reduce risk by allocating investments among various financial instruments, industries, and other categories. It aims to maximize returns by investing in different areas that would each react differently to the same event. Uncorrelated assets or assets with low correlation are very useful for diversification, because correlation contributes to the calculation of risk, and if you have low assets correlation it help to reduce risk. \n\nAn investment portfolio is a partition of the total capital, this partition defines the portion of the capital to be alocated at each asset, this proportion of assets are called the weights of the portfolio, and the election of assets and weights determine the expected return of the portfolio and the risk associated to it. Investors aim to construct a well-diversified portfolio to achieve a risk-return portfolio allocation that is appropriate for their level of risk tolerance. Your goals for the future, your appetite for risk, and your personality are all factors in deciding how to build your portfolio and how to determine the weights.\n\n#### Portfolio optimization\n\nPortfolio optimization is the process of selecting the best portfolio posible out of all posible portfolios acording to some objectives of expected returns, aversion of risk and available capital. The portfolio optimization problem is specified as a constrained utility-maximization problem. Common formulations of portfolio utility functions define it as the expected portfolio return (net of transaction and financing costs) minus a cost of risk.\n\nCentral to this optimization is the construction of the covariance matrix for the rates of return on the assets in the portfolio. Some of the most used portfolio optimization techniques are:\n\n<ul style=\"list-style-type:none;\">\n    <li>Linear and non-linear programming<\/li>\n    <li>Stochastic programming<\/li>\n    <li>Meta-heuristic methods<\/li>\n    <li>Principal component-based methods<\/li>\n    <li>Genetic algorithms<\/li>\n<\/ul>\n\n#### Genetic algorithms\n\nA genetic algorithm is a search heuristic that is inspired by Charles Darwin\u2019s theory of natural evolution. This algorithm reflects the process of natural selection where the fittest individuals are selected for reproduction in order to produce offspring of the next generation.\n\nNotion of Natural Selection\n\nThe process of natural selection starts with the selection of fittest individuals from a population. They produce offspring which inherit the characteristics of the parents and will be added to the next generation. If parents have better fitness, their offspring will be better than parents and have a better chance at surviving. This process keeps on iterating and at the end, a generation with the fittest individuals will be found.\n\nThis notion can be applied for a search problem. We consider a set of solutions for a problem and select the set of best ones out of them. Five phases are considered in a genetic algorithm.\n\nInitial population.- In this case the initial population are constructed all weights at random.\n\nFitness function.- The fitness function assigns a probability to be selected depend on the value of the spected return or volatility. High expected return or low volatility leads to a high probability of being selected.\n\nSelection.- After assing a probability of being selected, a random number determines which portfolio of the population will pass to the next generation.\n\nCrossover.- The elements selected are object to a crossover process at which some of the weight are combine with the weights of another elemnt of the selected population.\n\nMutation.- Finally some little changes are apply to the next generation population in order to have variety at the population.","ca66d501":"## 3. Genetic algorithm setings\n\nWe can set the population size and the number of iterations of mating and selection. After running the algorithm we can plot all the results of posible portfolios and the best portfolios considering the biggest expected return, the smallest volatility and the best sharpe ratio.","bc2b5b64":"## 4. Results and conclusions\n\nAfter running the algorithm we obtain three posible portfolios one with the highest expected return, another with the minimun risk and another with the best sharpe ratio, each of this portfolios comes with a list of weights. The list of weights is continuos so it's not useful for the real world, we have to modify it in order to consider the capital available, the actual prices of each stock, the fees, etc. This implementations can be addressed at further work."}}