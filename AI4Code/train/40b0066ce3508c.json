{"cell_type":{"3be7eff0":"code","47cbd2f3":"code","9f1830b8":"code","6df0d290":"code","8e97c761":"code","426468d3":"code","ce6ce030":"code","bfcd2eb1":"code","044666a5":"code","d7ce2d43":"code","1ab8e035":"code","d3fcca93":"code","0d6b516b":"code","17d303ba":"code","bb48c0f2":"code","fbe54c8a":"code","b5a1ed26":"code","9f9303f8":"code","9ebc1e82":"code","ade8095d":"code","1ce566e7":"code","b7e70785":"code","16395446":"code","1d66180c":"code","08c48b5c":"code","38e18fdf":"code","c1aab6d4":"code","8b4a304e":"code","a6a3e6d7":"code","917fe6ee":"code","a2506279":"markdown","0ebdfa7f":"markdown","96936716":"markdown","ad95fd7e":"markdown","b502519d":"markdown","fa1c1ad2":"markdown","4ceb294e":"markdown","3facbb81":"markdown","7bd5675a":"markdown","7e85bdbf":"markdown"},"source":{"3be7eff0":"# libraries\nimport pandas as pd\nimport numpy as np\nfrom sklearn.svm import SVC\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import metrics\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.model_selection import GridSearchCV\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.preprocessing import scale\n\nimport warnings\nwarnings.filterwarnings('ignore')","47cbd2f3":"# dataset\ntrain = pd.read_csv(\"..\/input\/train.csv\")\ntrain.head()","9f1830b8":"mnist.shape","6df0d290":"A, mnist=train_test_split(train, test_size = 0.40, random_state = 42)","8e97c761":"mnist.shape","426468d3":"mnist.info()","ce6ce030":"mnist.describe","bfcd2eb1":"mnist.isnull().sum()","044666a5":"mnist.drop_duplicates(subset=None, keep='first', inplace=True)","d7ce2d43":"mnist.shape","1ab8e035":"# lets see the distribution in numbers\nmnist.label.astype('category').value_counts()","d3fcca93":"# splitting into X and y\nX = mnist.drop(\"label\", axis = 1)\ny = mnist['label']","0d6b516b":"# scaling the features\nX_scaled = scale(X)\n\n# train test split\nX_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size = 0.3, random_state = 101)","17d303ba":"# linear model\n\nmodel_linear = SVC(kernel='linear')\nmodel_linear.fit(X_train, y_train)\n\n# predict\ny_pred = model_linear.predict(X_test)\n","bb48c0f2":"# confusion matrix\n\nprint(metrics.confusion_matrix(y_true=y_test, y_pred=y_pred))","fbe54c8a":"# print other metrics\n\n# accuracy\nprint(\"accuracy\", metrics.accuracy_score(y_true=y_test, y_pred=y_pred),\"\\n\")\n\n# precision\nprint(\"precision\", metrics.precision_score(y_true=y_test, y_pred=y_pred, average='macro'),\"\\n\")\n\n# recall\/sensitivity\nprint(\"recall\", metrics.recall_score(y_true=y_test, y_pred=y_pred, average='macro'),\"\\n\")\n","b5a1ed26":"# non-linear model\n# using rbf kernel, C=1, default value of gamma\n\n# model\nnon_linear_model = SVC(kernel='rbf')\n\n# fit\nnon_linear_model.fit(X_train, y_train)\n\n# predict\ny_pred = non_linear_model.predict(X_test)","9f9303f8":"# confusion matrix\n\nprint(metrics.confusion_matrix(y_true=y_test, y_pred=y_pred))","9ebc1e82":"# print other metrics\n\n# accuracy\nprint(\"accuracy\", metrics.accuracy_score(y_true=y_test, y_pred=y_pred),\"\\n\")\n\n# precision\nprint(\"precision\", metrics.precision_score(y_true=y_test, y_pred=y_pred, average='macro'),\"\\n\")\n\n# recall\/sensitivity\nprint(\"recall\", metrics.recall_score(y_true=y_test, y_pred=y_pred, average='macro'),\"\\n\")\n","ade8095d":"# creating a KFold object with 5 splits \nfolds = KFold(n_splits = 5, shuffle = True, random_state = 100)\n\n# specify range of hyperparameters\n# Set the parameters by cross-validation\nhyper_params = [ {'gamma': [1e-2, 1e-3, 1e-4],\n                     'C': [1, 10, 100, 1000]}]\n\n\n# specify model\nmodel = SVC(kernel=\"rbf\")\n\n# set up GridSearchCV()\nmodel_cv = GridSearchCV(estimator = model, \n                        param_grid = hyper_params, \n                        scoring= 'accuracy', \n                        cv = folds, \n                        verbose = 1,\n                        return_train_score=True)      \n\n# fit the model\nmodel_cv.fit(X_train, y_train)                  \n","1ce566e7":"# cv results\ncv_results = pd.DataFrame(model_cv.cv_results_)\ncv_results.head()","b7e70785":"# print 5 accuracies obtained from the 5 folds\nprint(cv_results)\nprint(\"mean accuracy = {}\".format(cv_results.mean()))","16395446":"# converting C to numeric type for plotting on x-axis\ncv_results['param_C'] = cv_results['param_C'].astype('int')\n\n# # plotting\nplt.figure(figsize=(16,6))\n\n# subplot 1\/3\nplt.subplot(131)\ngamma_01 = cv_results[cv_results['param_gamma']==0.01]\n\nplt.plot(gamma_01[\"param_C\"], gamma_01[\"mean_test_score\"])\nplt.plot(gamma_01[\"param_C\"], gamma_01[\"mean_train_score\"])\nplt.xlabel('C')\nplt.ylabel('Accuracy')\nplt.title(\"Gamma=0.01\")\nplt.ylim([0.60, 1])\nplt.legend(['test accuracy', 'train accuracy'], loc='lower right')\nplt.xscale('log')\n\n# subplot 2\/3\nplt.subplot(132)\ngamma_001 = cv_results[cv_results['param_gamma']==0.001]\n\nplt.plot(gamma_001[\"param_C\"], gamma_001[\"mean_test_score\"])\nplt.plot(gamma_001[\"param_C\"], gamma_001[\"mean_train_score\"])\nplt.xlabel('C')\nplt.ylabel('Accuracy')\nplt.title(\"Gamma=0.001\")\nplt.ylim([0.60, 1])\nplt.legend(['test accuracy', 'train accuracy'], loc='lower right')\nplt.xscale('log')\n\n\n# subplot 3\/3\nplt.subplot(133)\ngamma_0001 = cv_results[cv_results['param_gamma']==0.0001]\n\nplt.plot(gamma_0001[\"param_C\"], gamma_0001[\"mean_test_score\"])\nplt.plot(gamma_0001[\"param_C\"], gamma_0001[\"mean_train_score\"])\nplt.xlabel('C')\nplt.ylabel('Accuracy')\nplt.title(\"Gamma=0.0001\")\nplt.ylim([0.60, 1])\nplt.legend(['test accuracy', 'train accuracy'], loc='lower right')\nplt.xscale('log')\n","1d66180c":"# printing the optimal accuracy score and hyperparameters\nbest_score = model_cv.best_score_\nbest_hyperparams = model_cv.best_params_\n\nprint(\"The best test score is {0} corresponding to hyperparameters {1}\".format(best_score, best_hyperparams))","08c48b5c":"# model with optimal hyperparameters\n\n# model\nmodel = SVC(C=10, gamma=0.001, kernel=\"rbf\")\n\nmodel.fit(X_train, y_train)\ny_pred = model.predict(X_test)\n\n# metrics\nprint(\"accuracy\", metrics.accuracy_score(y_test, y_pred), \"\\n\")\nprint(metrics.confusion_matrix(y_test, y_pred), \"\\n\")\n\n","38e18fdf":"test = pd.read_csv(\"..\/input\/test.csv\")\n","c1aab6d4":"test1 = scale(test)","8b4a304e":"predicted_digit = model.predict(test1)","a6a3e6d7":"submission = pd.DataFrame({'ImageId': range(1,len(test)+1) ,'Label': predicted_digit })","917fe6ee":"submission.to_csv(\"submission.csv\",index=False)","a2506279":"The plots above show some useful insights:\n- Non-linear models (high gamma) perform *much better* than the linear ones\n- At any value of gamma, a high value of C leads to better performance\n- None of the models tend to overfit (even the complex ones), since the training and test accuracies closely follow each other\n\nThis suggests that the problem and the data is **inherently non-linear** in nature, and a complex model will outperform simple, linear models in this case.","0ebdfa7f":"## Data Preparation\n\nLet's conduct some data preparation steps before modeling. Firstly, let's see if it is important to **rescale** the features, since they may have varying ranges. For example, here are the average values:","96936716":"The linear model gives approx. 91% accuracy. Let's look at a sufficiently non-linear model with randomly chosen hyperparameters.","ad95fd7e":"The non-linear model gives approx. 93% accuracy. Thus, going forward, let's choose hyperparameters corresponding to non-linear models.","b502519d":"## Model Building\n\nLet's fist build two basic models - linear and non-linear with default hyperparameters, and compare the accuracies.","fa1c1ad2":"### Building and Evaluating the Final Model\n\nLet's now build and evaluate the final model, i.e. the model with highest test accuracy.","4ceb294e":"## Grid Search: Hyperparameter Tuning\n\nLet's now tune the model to find the optimal values of C and gamma corresponding to an RBF kernel. We'll use 5-fold cross validation.","3facbb81":"In this case, the average values do not vary a lot (e.g. having a diff of an order of magnitude). Nevertheless, it is better to rescale them.","7bd5675a":"Let's now choose the best hyperparameters. ","7e85bdbf":"# Assignment - Support Vector Machines\n\nLet's now tackle a slightly more complex problem - letter recognition. We'll first explore the dataset a bit, prepare it (scale etc.) and then experiment with linear and non-linear SVMs with various hyperparameters.\n\n\n## Data Understanding \n\nLet's first understand the shape, attributes etc. of the dataset."}}