{"cell_type":{"b1eaf7bf":"code","6d2ee028":"code","aeca173c":"code","57099eb9":"code","9ee28124":"code","031cae12":"code","1408330e":"code","010c4176":"code","e3b5ce61":"code","52d03be5":"code","691b01e8":"code","5a2a785d":"code","7b55f5d7":"code","c2b89059":"code","e253baaa":"code","07233d7a":"code","241062ad":"code","8c50319c":"code","ef9394cb":"code","4c8c3540":"code","1b4d7282":"code","92902467":"code","6b0b8c92":"code","6086e79d":"code","85681335":"code","68711985":"code","ee858543":"code","b66582ae":"code","cb7abdeb":"code","623c6672":"code","192a5691":"code","1bcac80c":"code","89b38a52":"code","5de1e1d4":"code","d0fba77a":"code","14f2afc2":"markdown","f5a95b2f":"markdown","ee58279a":"markdown","2e9eb115":"markdown","c7c3da3b":"markdown","c0b7c373":"markdown","9f983d56":"markdown","9e60c4f7":"markdown","8506d4fb":"markdown","db957d45":"markdown","76fe327a":"markdown","3d912cdd":"markdown","67098585":"markdown","70a907e7":"markdown","ba8a9ad3":"markdown","aa8fd192":"markdown","31e76915":"markdown","603b2aee":"markdown","796aa4cc":"markdown"},"source":{"b1eaf7bf":"# import relevant modules\n%matplotlib inline\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport sklearn\nimport imblearn\n\n# Ignore warnings\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Settings\npd.set_option('display.max_columns', None)\nnp.set_printoptions(threshold=np.nan)\nnp.set_printoptions(precision=3)\nsns.set(style=\"darkgrid\")\nplt.rcParams['axes.labelsize'] = 14\nplt.rcParams['xtick.labelsize'] = 12\nplt.rcParams['ytick.labelsize'] = 12","6d2ee028":"train = pd.read_csv(\"..\/input\/Train_data.csv\")\ntest = pd.read_csv(\"..\/input\/Test_data.csv\")","aeca173c":"print(train.head(4))\n\nprint(\"Training data has {} rows & {} columns\".format(train.shape[0],train.shape[1]))","57099eb9":"print(test.head(4))\n\nprint(\"Testing data has {} rows & {} columns\".format(test.shape[0],test.shape[1]))","9ee28124":"# Descriptive statistics\ntrain.describe()","031cae12":"print(train['num_outbound_cmds'].value_counts())\nprint(test['num_outbound_cmds'].value_counts())","1408330e":"#'num_outbound_cmds' is a redundant column so remove it from both train & test datasets\ntrain.drop(['num_outbound_cmds'], axis=1, inplace=True)\ntest.drop(['num_outbound_cmds'], axis=1, inplace=True)","010c4176":"# Attack Class Distribution\ntrain['class'].value_counts()","e3b5ce61":"from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\n\n# extract numerical attributes and scale it to have zero mean and unit variance  \ncols = train.select_dtypes(include=['float64','int64']).columns\nsc_train = scaler.fit_transform(train.select_dtypes(include=['float64','int64']))\nsc_test = scaler.fit_transform(test.select_dtypes(include=['float64','int64']))\n\n# turn the result back to a dataframe\nsc_traindf = pd.DataFrame(sc_train, columns = cols)\nsc_testdf = pd.DataFrame(sc_test, columns = cols)","52d03be5":"from sklearn.preprocessing import LabelEncoder\nencoder = LabelEncoder()\n\n# extract categorical attributes from both training and test sets \ncattrain = train.select_dtypes(include=['object']).copy()\ncattest = test.select_dtypes(include=['object']).copy()\n\n# encode the categorical attributes\ntraincat = cattrain.apply(encoder.fit_transform)\ntestcat = cattest.apply(encoder.fit_transform)\n\n# separate target column from encoded data \nenctrain = traincat.drop(['class'], axis=1)\ncat_Ytrain = traincat[['class']].copy()\n","691b01e8":"train_x = pd.concat([sc_traindf,enctrain],axis=1)\ntrain_y = train['class']\ntrain_x.shape","5a2a785d":"test_df = pd.concat([sc_testdf,testcat],axis=1)\ntest_df.shape","7b55f5d7":"from sklearn.ensemble import RandomForestClassifier\nrfc = RandomForestClassifier();\n\n# fit random forest classifier on the training set\nrfc.fit(train_x, train_y);\n# extract important features\nscore = np.round(rfc.feature_importances_,3)\nimportances = pd.DataFrame({'feature':train_x.columns,'importance':score})\nimportances = importances.sort_values('importance',ascending=False).set_index('feature')\n# plot importances\nplt.rcParams['figure.figsize'] = (11, 4)\nimportances.plot.bar();","c2b89059":"from sklearn.feature_selection import RFE\nimport itertools\nrfc = RandomForestClassifier()\n\n# create the RFE model and select 10 attributes\nrfe = RFE(rfc, n_features_to_select=15)\nrfe = rfe.fit(train_x, train_y)\n\n# summarize the selection of the attributes\nfeature_map = [(i, v) for i, v in itertools.zip_longest(rfe.get_support(), train_x.columns)]\nselected_features = [v for i, v in feature_map if i==True]\n\nselected_features","e253baaa":"from sklearn.model_selection import train_test_split\n\nX_train,X_test,Y_train,Y_test = train_test_split(train_x,train_y,train_size=0.70, random_state=2)","07233d7a":"from sklearn.svm import SVC \nfrom sklearn.naive_bayes import BernoulliNB \nfrom sklearn import tree\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.linear_model import LogisticRegression\n\n# Train KNeighborsClassifier Model\nKNN_Classifier = KNeighborsClassifier(n_jobs=-1)\nKNN_Classifier.fit(X_train, Y_train); \n\n# Train LogisticRegression Model\nLGR_Classifier = LogisticRegression(n_jobs=-1, random_state=0)\nLGR_Classifier.fit(X_train, Y_train);\n\n# Train Gaussian Naive Baye Model\nBNB_Classifier = BernoulliNB()\nBNB_Classifier.fit(X_train, Y_train)\n            \n# Train Decision Tree Model\nDTC_Classifier = tree.DecisionTreeClassifier(criterion='entropy', random_state=0)\nDTC_Classifier.fit(X_train, Y_train)","241062ad":"from sklearn import metrics\n\nmodels = []\nmodels.append(('Naive Baye Classifier', BNB_Classifier))\nmodels.append(('Decision Tree Classifier', DTC_Classifier))\nmodels.append(('KNeighborsClassifier', KNN_Classifier))\nmodels.append(('LogisticRegression', LGR_Classifier))\n\nfor i, v in models:\n    scores = cross_val_score(v, X_train, Y_train, cv=10)\n    accuracy = metrics.accuracy_score(Y_train, v.predict(X_train))\n    confusion_matrix = metrics.confusion_matrix(Y_train, v.predict(X_train))\n    classification = metrics.classification_report(Y_train, v.predict(X_train))\n    print()\n    print('============================== {} Model Evaluation =============================='.format(i))\n    print()\n    print (\"Cross Validation Mean Score:\" \"\\n\", scores.mean())\n    print()\n    print (\"Model Accuracy:\" \"\\n\", accuracy)\n    print()\n    print(\"Confusion matrix:\" \"\\n\", confusion_matrix)\n    print()\n    print(\"Classification report:\" \"\\n\", classification) \n    print()","8c50319c":"for i, v in models:\n    accuracy = metrics.accuracy_score(Y_test, v.predict(X_test))\n    confusion_matrix = metrics.confusion_matrix(Y_test, v.predict(X_test))\n    classification = metrics.classification_report(Y_test, v.predict(X_test))\n    print()\n    print('============================== {} Model Test Results =============================='.format(i))\n    print()\n    print (\"Model Accuracy:\" \"\\n\", accuracy)\n    print()\n    print(\"Confusion matrix:\" \"\\n\", confusion_matrix)\n    print()\n    print(\"Classification report:\" \"\\n\", classification) \n    print()        \n","ef9394cb":"# PREDICTING FOR TEST DATA using KNN\npred_knn = KNN_Classifier.predict(test_df)\npred_NB = BNB_Classifier.predict(test_df)\npred_log = LGR_Classifier.predict(test_df)\npred_dt = DTC_Classifier.predict(test_df)","4c8c3540":"def perf_measure(y_actual, y_pred):\n    TP = 0\n    FP = 0\n    TN = 0\n    FN = 0\n\n    for i in range(len(y_pred)): \n        if y_actual.iat[i]==y_pred[i]=='anomaly':\n           TP += 1\n        if y_pred[i]=='anomaly' and y_actual.iat[i]!=y_pred[i]:\n           FP += 1\n        if y_actual.iat[i]==y_pred[i]=='normal':\n           TN += 1\n        if y_pred[i]=='normal' and y_actual.iat[i]!=y_pred[i]:\n           FN += 1\n        \n    return (TP, FP, TN, FN)\n\n\nfor i, v in models:\n    print(\"For model:\", i)\n    TP, FP, TN, FN = perf_measure(Y_test, v.predict(X_test))\n    print (\"TP:\", TP, \"\\tFP:\", FP, \"\\t\\tTN:\", TN, \"\\tFN:\", FN)\n    \n    # Testing for first row\n    #print (\"Expected: \", Y_test.iloc[0], \"Predicted: \", v.predict(X_test).reshape(1, -1)[0][0] )\n    print()\n    ","1b4d7282":"# Testing for second row\nfor i, v in models:\n    print(\"For model: \", i)\n    print (\"Expected: \", Y_test.iloc[2], \"\\tPredicted: \", v.predict(X_test).reshape(1, -1)[0][2] )\n    print()","92902467":"type(Y_test)","6b0b8c92":"def find_FP(y_actual, y_pred):\n    FP = []\n\n    for i in range(len(y_pred)): \n        if y_pred[i]=='anomaly' and y_actual.iat[i]!=y_pred[i]:\n           FP.append(i)   \n    return (pd.Series(FP))\n    \ndef find_FN(y_actual, y_pred):\n    FN = []\n\n    for i in range(len(y_pred)): \n        if y_pred[i]=='normal' and y_actual.iat[i]!=y_pred[i]:\n           FN.append(i)\n    return (pd.Series(FN))\n","6086e79d":"FP_NB= find_FP(Y_test, models[0][1].predict(X_test))\nprint(\"Size of number of FP:\", FP_NB.size) \nFN_NB= find_FN(Y_test, models[0][1].predict(X_test))\nprint(\"Size of number of FN:\", FN_NB.size) \n\n# Testing \nFP_NB.head(4)","85681335":"X_test_subset=[]\nY_test_subset=[]\nfor i in FP_NB:\n    X_test_subset.append(X_test.iloc[i])\n    Y_test_subset.append(Y_test.iat[i])\nfor i in FN_NB:\n    X_test_subset.append(X_test.iloc[i])\n    Y_test_subset.append(Y_test.iat[i])\n    \nX_test_sub=pd.DataFrame(X_test_subset)\nY_test_sub=pd.Series(Y_test_subset)\nprint(\"Size of X_test_sub:\", X_test_sub.shape[0]) \nprint(\"Size of Y_test_sub:\", Y_test_sub.size) \n\n# To check for each false positive\n#for i in FP_NB:\n#    print (\"Expected: \", Y_test.iloc[i], \"Predicted: \", models[1][1].predict(X_test).reshape(1, -1)[0][i] )","68711985":"print(type(X_test)) \nX_test.head(4)","ee858543":"print(type(X_test_sub))\nX_test_sub.head(4)\n","b66582ae":"print(type(Y_test)) \nY_test.head(4)","cb7abdeb":"print(type(Y_test_sub))\nY_test_sub.head(4)","623c6672":"accuracy = metrics.accuracy_score(Y_test_sub, models[1][1].predict(X_test_sub))\nconfusion_matrix = metrics.confusion_matrix(Y_test_sub, models[1][1].predict(X_test_sub))\nclassification = metrics.classification_report(Y_test_sub, models[1][1].predict(X_test_sub))\nprint()\nprint('============================== {} Model Test Results =============================='.format(\"NB -> DT\"))\nprint()\nprint (\"Model Accuracy:\" \"\\n\", accuracy)\nprint()\nprint(\"Confusion matrix:\" \"\\n\", confusion_matrix)\nprint()\nprint(\"Classification report:\" \"\\n\", classification) \nprint() ","192a5691":"print(\"For Naive Bayes:\")\nTP_old, FP_old, TN_old, FN_old = perf_measure(Y_test, BNB_Classifier.predict(X_test))\nprint (\"TP:\", TP_old, \"\\tFP:\", FP_old, \"\\t\\tTN:\", TN_old, \"\\tFN:\", FN_old)\n\nprint()\nprint(\"For Naive Bayes -> Decision Tress:\")\nTP_new, FP_new, TN_new, FN_new = perf_measure(Y_test_sub, DTC_Classifier.predict(X_test_sub))\nprint (\"TP:\", TP_new, \"\\tFP:\", FP_new, \"\\t\\tTN:\", TN_new, \"\\tFN:\", FN_new)\n\nprint()\nprint(\"For Naive Bayes + Decision Tress:\")\ntp = TP_old +TP_new\nfp = FP_new\ntn = TN_old +TN_new\nfn = FN_new\nprint (\"TP:\", tp, \"\\tFP:\", fp, \"\\t\\tTN:\", tn, \"\\tFN:\", fn)","1bcac80c":"acc_old= (TP_old + TN_old) \/ (TP_old + FP_old + TN_old + FN_old)\nmis_old= (FP_old + FN_old) \/ (TP_old + FP_old + TN_old + FN_old)\nprec_old= TP_old \/ (TP_old + FP_old)\nsen_old= TP_old \/ (TP_old + FN_old)\nspec_old= TN_old \/ (TN_old + FP_old)\n\nacc= (tp + tn) \/ (tp + fp + tn + fn)\nmis= (fp + fn) \/ (tp + fp + tn + fn)\nprec= tp \/ (tp + fp)\nsen= tp \/ (tp + fn)\nspec= tn \/ (tn + fp)\n\nprint (\"Accuracy\")\nprint (\"Old: \", acc_old, \"\\tNew: \", acc)\nprint (\"\\nMisclassification\")\nprint (\"Old: \", mis_old, \"\\tNew: \", mis)\nprint (\"\\nPrecision\")\nprint (\"Old: \", prec_old, \"\\tNew: \", prec)\nprint (\"\\nSensitivity\")\nprint (\"Old: \", sen_old, \"\\tNew: \", sen)\nprint (\"\\nSpecificity\")\nprint (\"Old: \", spec_old, \"\\tNew: \", spec)","89b38a52":"# set width of bar\nbarWidth = 0.25\nfig = plt.subplots(figsize =(12, 8))\n \n# set height of bar\nNB = [TP_old, FP_old, TN_old, FN_old]\nNBandDT = [tp, fp, tn, fn]\n \n# Set position of bar on X axis\nbr1 = np.arange(len(NB))\nbr2 = [x + barWidth for x in br1]\n \n# Make the plot\nplt.bar(br1, NB, color ='b', width = barWidth, edgecolor ='grey', label ='Naive Bayes')\nplt.bar(br2, NBandDT, color ='g', width = barWidth, edgecolor ='grey', label ='Naive Bayes and Decision Tree')\n \n# Adding Xticks\nplt.xlabel('Confusion Matrix Element', fontweight ='bold', fontsize = 15)\nplt.ylabel('Value', fontweight ='bold', fontsize = 15)\nplt.xticks([r + barWidth for r in range(len(NB))], ['TP', 'FP', 'TN', 'FN'])\n \nplt.legend()\nplt.title(\"Confusion Matrix\")\nplt.show()","5de1e1d4":"# set width of bar\nbarWidth = 0.25\nfig = plt.subplots(figsize =(12, 8))\n \n# set height of bar\nOld = [acc_old, mis_old, prec_old, sen_old, spec_old]\nNew = [acc, mis, prec, sen, spec]\n \n# Set position of bar on X axis\nbr1 = np.arange(len(Old))\nbr2 = [x + barWidth for x in br1]\n \n# Make the plot\nplt.bar(br1, Old, color ='b', width = barWidth, edgecolor ='grey', label ='Old')\nplt.bar(br2, New, color ='g', width = barWidth, edgecolor ='grey', label ='New')\n\n\n# Adding Xticks\nplt.xlabel('Performance Metrics', fontweight ='bold', fontsize = 15)\nplt.ylabel('Value', fontweight ='bold', fontsize = 15)\nplt.xticks([r + barWidth for r in range(len(NB))], ['Accuracy', 'Misclassification', 'Precision', 'Sensitivity', 'Specificity'])\n \nplt.legend()\nplt.title(\"Comparison of performance metrics\")\nplt.show()","d0fba77a":"accPercent= ((acc- acc_old)\/acc_old) *100\nmisPercent= ((mis_old- mis)\/mis_old) *100\nprecPercent= ((prec- prec_old)\/prec_old) *100\nsenPercent= ((sen- sen_old)\/sen_old) *100\nspecPercent= ((spec- spec_old)\/spec_old) *100\n\nprint (\"Accuracy increase percentage: \" ,accPercent, \"%\")\nprint (\"Missclasification decrease percentage: \" ,misPercent, \"%\")\nprint (\"Precison increase percentage: \", precPercent, \"%\")\nprint (\"Sensitivity increase percentage: \", senPercent, \"%\")\nprint (\"Specificity increase percentage: \", specPercent, \"%\")","14f2afc2":"# Plotting Results","f5a95b2f":"# LOAD DATA","ee58279a":"# VALIDATING MODELS","2e9eb115":"# Combining Naive Bayes and Decision Tree","c7c3da3b":"## Validating results for the FP FN subset in the combined model","c0b7c373":"# FEATURE SELECTION","9f983d56":"# Functions to extract locations of FP, FN as a pandas series","9e60c4f7":"# FITTING MODELS","8506d4fb":"# Extracting TP FP TN FN","db957d45":"# EVALUATE MODELS","76fe327a":"## 1. Accuracy (all correct \/ all) = TP + TN \/ TP + TN + FP + FN\n## 2. Misclassification (all incorrect \/ all) = FP + FN \/ TP + TN + FP + FN\n## 3. Precision (true positives \/ predicted positives) = TP \/ TP + FP\n## 4. Sensitivity aka Recall (true positives \/ all actual positives) = TP \/ TP + FN\n## 5. Specificity (true negatives \/ all actual negatives) =TN \/ TN + FP","3d912cdd":"# Validating the combined model","67098585":"# SCALING NUMERICAL ATTRIBUTES","70a907e7":"## Getting FP FN row entry from X_test and Y_test as pd.DataFrame and pd.Series respectively","ba8a9ad3":"# EXPLORATORY ANALYSIS","aa8fd192":"# ENCODING CATEGORICAL ATTRIBUTES","31e76915":"## Validating hybrid model, NB + DT","603b2aee":"## Getting FP and FN row location from NB output as pd.Series","796aa4cc":"# DATASET PARTITION"}}