{"cell_type":{"15e17428":"code","0c34bdd4":"code","21b7cf3d":"code","4a60dd35":"code","a2756572":"code","4e7e208c":"code","4f7e3b45":"code","6c258aa0":"code","f0bf9f60":"code","b7e41f08":"code","73ad83b7":"code","94913dcb":"code","50cce3b2":"markdown","a9bac2e7":"markdown","d5ae052d":"markdown","a260328c":"markdown","1c57f6fc":"markdown","d8de9bbd":"markdown","432fd8f2":"markdown","7e7a284f":"markdown","57ab2c95":"markdown","b7101b91":"markdown","06842ac9":"markdown","62a4ff95":"markdown","8e50621e":"markdown","491c09a7":"markdown","f06b6ab3":"markdown","f8682f03":"markdown"},"source":{"15e17428":"# Implement function f as a Python method.\ndef f(x):\n    x = x + 1\n    return x\n\n# Execute the method.\ny = f(2)\nprint(\"Result from f: %d\" % y)","0c34bdd4":"# Provide examples to illustrate dynamic typing and impact on arithmetic operations.\na = 2    # a is an integer type\na = 2.5  # a is NOW a floating point type.\n\nb = 8\nc = a + b\n\n# Put the result in 'c'.\nprint(\"What is c? %f\" % c)\n\n\n# Arithmetic operations\na = a + b\nprint(\"a+b = %f\" % c)\n\na += 1\nprint(\"a = %f\" % a)\n\nc = a*b\nprint(\"c = %f\" % c)\n\nc = a\/b\nprint(\"c = %f\" % c)\n","21b7cf3d":"# An example.\na_dict = {\n    \"key1\": \"hello\",\n    \"key2\": \"world\"\n}\n\n# Read the values out and print them out as a concatenated string separated by a space.\ndict_str = a_dict['key1'] + ' ' + a_dict['key2'] + '!'\nprint(dict_str)\n\n# Get the keys of a dictionary.\nprint(\"What keys? %s\" % str(a_dict.keys()))","4a60dd35":"# We import a very useful python package known as Numpy to create arrays and operate on them.\nimport numpy as np\n\n# Array initialisation.\na = np.array([1,3,2,4])\nb = np.zeros(4)\nc = np.ones(4)\n\n# Arithmetic operations on arrays.\nd = str(a + b)\nprint(\"d = %s\" % d)\n\nd = str(a * b)\nprint(\"d = %s\" % d)\n\n# Passing an array to a method.\ndef theMtd(what):\n    print(str(what))\n\ntheMtd(b)","a2756572":"# Create 2D matrix populated by zeros.\na = np.zeros((2,2))\nprint(\"a =\" + str(a) + \"\\n\")\n\n# Create 2D matrix populated by twos.\nb = np.ones((2,2))*2.0\nprint(\"b =\" + str(b) + \"\\n\")\n\n# Create method to multiply 2 matrices\ndef mat_mul(m1, m2):\n  O = m1*m2\n  return O\n      \n# Call method and print out the results.\nc = mat_mul(a, b)\nmsg = str(c) + \", size: \" + str(c.shape)\nprint(str(msg))\n","4e7e208c":"# Import package to work with pickle files.\nimport pickle as pk\n\n# Unpickle the data.\nwith open('..\/input\/exa-data\/data.pkl', \"rb\") as fid:\n    data = pk.load(fid)\n\n# Print out the type for data.\nprint(\"Data type: %s\" % str(type(data)))\n\n# Print out the keys.\nprint(\"Keys: %s\" % str(data.keys()))\n\n# Have a look at some of the values.\nprint(\"signal: \" + str(data['signal'][:10]))\nprint(\"noise: \" + str(data['noise'][:10]))\n","4f7e3b45":"# Import package used for plotting charts.\nimport matplotlib.pyplot as plt\n\n# Create the figure & axis handles for the plot.\nfig, (ax1, ax2) = plt.subplots(2,1,figsize=(30,15))\n\n# Create time axis.\ntime = np.arange(len(data['signal']))   # This creates an array starting from 0, 1, .. length of the signal-1.\ntime = time\/data['sampling_freq_Hz']        # Divides each element by the sampling frequency to obtain seconds.\n\n# Plot the signals signal and noise.\nax1.plot(time, data['signal'])\nax1.set(xlabel = 'Time\/s',\n       ylabel = 'Amp',\n       title = 'Original signal')\n\nax2.plot(time, data['noise'])\nax2.set(xlabel = 'Time\/s',\n       ylabel = 'Amp',\n       title = 'Noise')\n\nplt.show()\n\n# Add them together and plot the resulting signal.\nnoisy_signal = data['signal'] + data['noise']\n\n# Write this to the dictionary.\ndata['noisy_signal'] = noisy_signal\n\n# Create another plot.\nfig, ax = plt.subplots(figsize=(30,7.5))\n\nax.plot(time, noisy_signal)\nax.set(xlabel = 'Time\/s',\n      ylabel = 'Amp',\n      title = 'Noisy Signal')\n\nplt.show()","6c258aa0":"# We obtain the fft module from the SCIPY package.\nfrom scipy.fft import fft\n\n# Create the frequency axis. \nfrequency = np.arange(len(data['noisy_signal']))*(data['sampling_freq_Hz']\/len(data['noisy_signal']))\n\n# Carry out the FFT on the noisy signal.\nspectrum = fft(data['noisy_signal'])\n\n# Take magnitude of the spectrum.\nspectrum_abs = np.abs(spectrum)\n\n# Plot the spectrum.\nfig, ax = plt.subplots(figsize=(30,7.5))\n\nax.plot(frequency, spectrum_abs)\nax.set(xlabel = 'Frequency\/Hz',\n      ylabel = 'Amp',\n      title = 'Spectrum of Noisy Signal')\n\nplt.show()\n\n# Identity location of peaks.\nthreshold = np.max(spectrum_abs)\/2.0\nindices = np.argwhere(spectrum_abs > threshold)\nprint(\"Frequencies of interest\/Hz:\\n %s\" % frequency[indices])","f0bf9f60":"# Import the filter design package.\nfrom scipy import signal\n\n# Filter parameters.\nN = 4                                               # Filter order.\ncutOff = 30.0\/(data['sampling_freq_Hz']\/2)          # Cut-Off frequency in rad\/s.\nbtype = 'low'\n\n# Obtain filter coefficients here.\nb, a = signal.butter(N, cutOff, btype)\n\n# Use the filter here.\nfiltered = signal.filtfilt(b, a, noisy_signal)\n\n# Let's have a look at the signal.\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(30,15))\n\nax1.plot(time, data['noisy_signal'])\nax1.set(xlabel = 'Time\/s',\n      ylabel = 'Amp',\n      title = 'Noisy Signal')\n\nax2.plot(time, filtered)\nax2.set(xlabel = 'Time\/s',\n      ylabel = 'Amp',\n      title = 'Filtered Signal')\n\nplt.show()","b7e41f08":"# Obtain the frequency response of the filter.\nfrequency, freq_response = signal.freqz(b, a, fs=data['sampling_freq_Hz'])\n\n# Obtain the magnitude response.\nmagnitude_response = np.abs(freq_response)\n\n# Obtain the phase response of the filter.\nphase_response = np.unwrap(np.angle(freq_response))\n\n# Plot frequency response.\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(30,15))\n\nax1.plot(frequency, magnitude_response)\nax1.set(xlabel = 'Frequency\/Hz',\n      ylabel = 'Magnitude',\n      title = 'Filter Magnitude Response')\n\nax2.plot(frequency, phase_response)\nax2.set(xlabel = 'Frequency\/Hz',\n      ylabel = 'Phase',\n      title = 'Filter Phase Response')\n\n# Find the 3 dB point.\ndeltas = np.abs(magnitude_response - np.ones(magnitude_response.shape)*(10**(-3\/20.0)))\nindex = np.argmin(deltas)\nprint(\"3 dB point at %f Hz\" % frequency[index])\n\nax1.plot(frequency[index], magnitude_response[index], 'ro')\n","73ad83b7":"def moving_avg(input_signal, window_sz=8):\n    result = np.zeros(input_signal.shape)\n    result[:window_sz] = np.mean(input_signal[:window_sz])*np.ones(window_sz)\n    \n    index=window_sz\n    while index<len(input_signal):\n        l = index-window_sz+1\n        window = input_signal[l:(index+1)]\n        mean_val = np.mean(window)\n        result[index] = mean_val\n        index += 1\n        \n    return result\n\n# Smooth data with moving average. Start with window size of 8 and increase to 64.\noutput = moving_avg(data['noisy_sine_one'], 8)\n\n# Plot averaged signal.\nfig, ax1 = plt.subplots(figsize=(30,15))\n\nax1.plot(data['noisy_sine_one'])\nax1.plot(output)\nax1.set(xlabel = 'Time\/s',\n      ylabel = 'Magnitude',\n      title = 'Moving Average')\nax1.legend(['Raw', 'Filtered'])\nplt.show()","94913dcb":"def median_filter(input_signal, window_sz=3):\n    result = np.zeros(len(input_signal))\n    \n    result[:window_sz] = np.mean(input_signal[:window_sz])\n    index=window_sz\n    while index<len(input_signal):\n        l = index-window_sz+1\n        window = input_signal[l:(index+1)]\n        median_val = np.median(window)\n        result[index] = median_val\n        index += 1\n    \n    return result\n\n# Outlier removal with the median filter. Start with window size of 3 and increase to 64.\noutput = median_filter(data['noisy_sine_two'], 5)\n\n# Plot averaged signal.\nfig, ax1 = plt.subplots(figsize=(30,15))\n\nax1.plot(data['noisy_sine_two'])\nax1.plot(output)\nax1.set(xlabel = 'Time\/s',\n      ylabel = 'Magnitude',\n      title = 'Median Filter')\nax1.legend(['Raw', 'Filtered'])\nplt.show()","50cce3b2":"## Matrices\n\nArrays are one-dimensional entities. To generalise, we create multi-dimensional entities or matrices. Similar arithmetic operations can be carried out on these matrices.","a9bac2e7":"## 3. Data Types\n\nIn mathematics, there are different types of numbers. Examples include real numbers, integers, and complex numbers.\n\nIn Python, real numbers are represented using floating point numbers. Exactly implementing a number like $\\pi = 3.142...$ is impossible because it has an infinite number of places after the decimal point. A floating point representation could be $3.142 \\times 10^0$ where there is a truncation after 3 decimal places and an exponent of 0 (in reality, numbers are stored in binary and precision for mantissa (3.142 in this case) and exponent (0 in this case) are higher). \n\nRepresenting integers is simpler as there is no need for an exponent. We simply need a representation with sufficient range. Complex numbers simply involve 2 floats to represent the real and the imaginary parts. Usually, we do not need to worry about the number type because of a Python feature known as dynamic binding, where the type assumed by a variable is determined at the last possible moment. Arithmetic operations involving different data types are automatically handled.","d5ae052d":"## 2. Methods\n\nPython methods share similarities with mathematical functions. One example is shown below.\n\n$y = f(x)$\n\nFunction $f$ takes in the input $x$ and maps it to output $y$. We further define the function $f$ as follows.\n\n$f(x) = x + 1$\n\nTrivially, if $x = 2$, it follows that $f(x) = 3$. Implementation in Python is straightforward as follows. After defining the method, we have to execute it to perform our calculation.","a260328c":"# A Terribly Quick Introduction to Python\n\n## Contents:\n\n1. What is Python and how is it different from programming languages like 'C'?\n2. Methods\n3. Data types and Arithmetic operations\n4. Arrays and Matrices\n5. Importing data\n6. Visualising the data\n7. Fast Fourier Transform\n8. Designing a Low Pass Butterworth filter\n9. Analysing filter response\n10. Other types of IIR filters\n11. Moving Average and Median filters\n12. Downloading the notebook","1c57f6fc":"## 5. Importing data\n\nSo far, it hasn't been very interesting. What we lack is a dataset that we can play with. To this, let's import some data. Refer to the link below for how to do it - the data file should should be accompanied with this notebook.\n\nhttps:\/\/mftechno.com\/wp-content\/uploads\/2021\/05\/file_upload.mp4\n\nNote that the file 'data.pkl' is known to be in pickle format. We need to extract the data from this file first before its useable. The code below is used to 'unpickle' the file. Note that you need to specify the PATH or location of the file precisely - you can copy it from the top right panel. ","d8de9bbd":"Python offers an important and tremendously useful data type known as dictionaries. A dictionary consists of a 'key, value' pair where the value is retrieved by a unique key within the dictionary. We illustrate this below.","432fd8f2":"## 9. Analysing filter response\n\nTo understand the filter that we designed a little more, we look at its frequency response below. Have a look at the freqz method.\n\nhttps:\/\/docs.scipy.org\/doc\/scipy\/reference\/generated\/scipy.signal.freqz.html","7e7a284f":"## 4. Arrays and Matrices\n\nAn array hold mulitple numbers as a single entity and each entry is located at a specific location in the array. Further, each array element can be accessed via an array index. An example is shown below. ","57ab2c95":"## 11. Moving Average and Median filters\n\nSimpler types of filters such as the Moving average and the Median filters are frequently used as well.\n\nThe Moving average filter is popular because of its simplicity and because there are few parameters to adjust. It is used primarily to 'smoothen' signals. An example is shown below.","b7101b91":"## 7. Fast Fourier Transform\n\nEyeballing the data tells us that the actual signal is low frequency and noise is high frequency. We can certainly take measurements between the peaks to determine what the respective frequencies are. However, in this case, we are lucky to have the original signal and noise signals. If we pretend that we don't, it will be more difficult to measure periods of the noisy signal in an accurate manner as there are more than one frequency component within the signal.\n\nAnother way to perform this analysis is to make use of the FFT to map the signal to the frequency domain and analyse the signal in that space. We do this below.","06842ac9":"## 1. What is Python and how is it different from programming languages like 'C'?\n\nPython is a programming language that is extremely varsatile as it can be used for a huge variety of applications, from web servers to Digital Signal Processing (DSP). It has a gentle learning curve and a lot of support. One complaint about Python is that it is slower than other languages such as 'C' but there is ongoing work to improve it's efficiency. It is one reason why Python is rarely used in environments with tight resource constraints (e.g. slower processor and smaller memory) like the microprocessors in refrigerators.\n\nIn conventional programming languages like 'C', Individual files written in C code (files with '.c' extension) is processed by the compiler to generate object code (files with '.o' extension). Subsequently, a linker is used to combine the intermediate object code together to form a single executable (files with '.exe' extensions) - this comprises of the assembly code or instructions that are executed by the processor. In addition, the program makes use of memory to store objects e.g. arrays containing signal samples. The object\/s might be abandoned at some point in the program and it is the responsibility of the programmer to deallocate the memory so it might useful somewhere else. This process is known as 'manual deallocation'. \n\nPython is different in the following ways.\n\n1. A compilation step is necessary for python as well, creating files with '.pyc' extension. Rather than generating object code or executables, the compiler generates bytecode, which is then executed by an interpreter on a Virtual Machine instead of the processor. Doing it in this manner allows the same bit of code to be executed in very different environments (such as a PC and a Linux based machine) as different types of bytecode suitable to the target machine can be generated. For this reason, Python is known as an 'interpreted language'.\n\n2. Another important feature in Python where previously useful and currently unuseful memory is automatically deallocated. This feature is known as garbage collection.\n\nOne trick used by Python to speed up execution is by caching bytecode in folders called '__pycache__' so that the compilation step can be skipped if no changes to the original Python source code are detected. ","62a4ff95":"Next, we show a sine wave corrupted by spikes - extreme values or outliers. The median filter is an excellent choice for removing this sort of noise.","8e50621e":"## 10. Other types of filters\n\nButterworth filters have a flat response in the passband and the stopband. The transition band is usually gradual as compared to other filter types. Even within the Butterworth framework, there are different types of filters that serve different purposes according to the [documentation](https:\/\/docs.scipy.org\/doc\/scipy\/reference\/generated\/scipy.signal.butter.html).  \n\n```\nbtype{\u2018lowpass\u2019, \u2018highpass\u2019, \u2018bandpass\u2019, \u2018bandstop\u2019}, optional\nThe type of filter. Default is \u2018lowpass\u2019.\n```\nApart from the Butterworth, there are other types of IIR filters that are useful. We list a few here.\n\nChebyshev Type I filter: [cheby1(N, rp, Wn, btype='low', analog=False, output='ba')](https:\/\/docs.scipy.org\/doc\/scipy-0.14.0\/reference\/generated\/scipy.signal.cheby1.html)\n\nChebyshev Type II filter: [scipy.signal.cheby2(N, rs, Wn, btype='low', analog=False, output='ba')](https:\/\/docs.scipy.org\/doc\/scipy-0.14.0\/reference\/generated\/scipy.signal.cheby2.html)\n\nElliptic filter: [ellip(N, rp, rs, Wn, btype='low', analog=False, output='ba', fs=None)](https:\/\/docs.scipy.org\/doc\/scipy\/reference\/generated\/scipy.signal.ellip.html#scipy.signal.ellip)\n\n","491c09a7":"## 8. Designing a Low Pass Butterworth filter\n\nFrom our analysis, the signal content is a sinusoid at 14 Hz and the noise is at a higher frequency of 50 Hz. Therefore, we can design a low pass filter with a cut-off frequency of 30 Hz.\n\nWe will use the Scipy package to create our filter. This link provides information about the method and describes the inputs and outputs.\n\nhttps:\/\/docs.scipy.org\/doc\/scipy\/reference\/generated\/scipy.signal.butter.html\n\nThe filter design method will create the filter coefficients for us. We will then need to deploy this filter. To do so, we make use of another method known as 'filtfilt'. More information here.\n\nhttps:\/\/docs.scipy.org\/doc\/scipy\/reference\/generated\/scipy.signal.filtfilt.html\n\nThere are other deployment methods such as 'filter'. We choose 'filtfilt' here because of its phase correction properties but we will not discuss this in detail here.","f06b6ab3":"## 12. Downloading the Notebook\n\nYou need to download the Notebook from Kaggle (if this is the environment that you are working in) in order to submit you assignment. Follow the video link below to do so.\n\nhttps:\/\/mftechno.com\/wp-content\/uploads\/2021\/05\/download_notebook.mp4","f8682f03":"## 6. Visualising the Data\n\nOften, it is far quicker and more intuitive to illustrate the data in the form of a chart rather than printing them out as strings. \n\nWe will now chart the signal, noise, as well as the summation of both for use later on."}}