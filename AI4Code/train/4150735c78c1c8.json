{"cell_type":{"139aa340":"code","5cf7cd00":"code","827adc84":"code","2500a0a3":"code","d18ef134":"code","71f4abc8":"code","2f5984e6":"code","b3e53e0a":"code","7afc58c6":"code","622f9ec8":"code","f289fb3e":"code","84d0037d":"code","166b34fe":"code","7ecacbed":"code","4b2cb103":"code","62a26c6c":"code","514f97dc":"code","4e123152":"code","cd1c8a7c":"markdown","df602771":"markdown","b79f22cc":"markdown","3b6055a6":"markdown","e8ac2def":"markdown","5be7eedb":"markdown","13310913":"markdown","7c5cdc17":"markdown","27695844":"markdown","cffb235d":"markdown","c3772b2d":"markdown","4471203d":"markdown","5e06f15d":"markdown"},"source":{"139aa340":"# import torch\nimport torch","5cf7cd00":"# Number\nt1=torch.tensor(5.)\nt1\n# t1 = torch.tensor(4.)\n# t1","827adc84":"t1.dtype\n# t1.dtype","2500a0a3":"# Vector\nt2 = torch.tensor([1, 3, 4, 9.4, 4])\nprint(t2)\nprint(t2.dtype)\n\n# t2 = torch.tensor([1., 2, 3, 4])\n# t2","d18ef134":"# Matrix\nt3 = torch.tensor([[4,5],\n                   [6,7],\n                   [4,1],\n                   [0,9],\n                   [3,1]])\n\nprint(t3)\nprint(t3.dtype)\n\n# t3 = torch.tensor([[5., 6], \n#                    [7, 8], \n#                    [9, 10]])\n# t3","71f4abc8":"# 3-dimensional array\n\nt4 = torch.tensor([\n    [11,4,2,6],\n    [0,5,5,3],\n    [2,7,5,4],\n    [4,5,6,23],\n    [4,1,0,0]\n])\n\nprint(t4)\nprint(t4.dtype)\n\n# t4 = torch.tensor([\n#     [[11, 12, 13], \n#      [13, 14, 15]], \n#     [[15, 16, 17], \n#      [17, 18, 19.]]])\n# t4","2f5984e6":"print('t1\\n',t1)\nprint(t1.shape,'\\n')\nprint('t2\\n',t2,'\\n',t2.shape,'\\n')\nprint('t3\\n',t3,'\\n',t3.shape,'\\n')\nprint('t4\\n',t4,'\\n',t4.shape)","b3e53e0a":"# Create tensors.\nx = torch.tensor(3.)\nw = torch.tensor(4., requires_grad=True)\nb = torch.tensor(5., requires_grad=True)\nx, w, b\ny = w * x + b\ny\n# Compute derivatives\ny.backward()\n# Display gradients\nprint('dy\/dx:', x.grad)\nprint('dy\/dw:', w.grad)\nprint('dy\/db:', b.grad) #3 * 4 + 5 = 17","7afc58c6":"# Create tensors.\nx = torch.tensor(3.)\nw = torch.tensor(4., requires_grad=True)\nb = torch.tensor(5., requires_grad=True)\nprint(x, w, b)","622f9ec8":"# Arithmetic operations\nz = w * x + b\nprint(z)","f289fb3e":"# Compute derivatives\nz.backward()","84d0037d":"# Display gradients\nprint('dy\/dx:', x.grad)\nprint('dy\/dw:', w.grad)\nprint('dy\/db:', b.grad) #3 * 4 + 5 = 17","166b34fe":"import numpy as np\n\nx = np.array([\n    [1,2,3],\n    [3,5,6],\n    [6,2,4]\n ])\nx","7ecacbed":"# Convert the numpy array to a torch tensor.\ny = torch.from_numpy(x)\ny","4b2cb103":"x.dtype,y.dtype","62a26c6c":"# Convert a torch tensor to a numpy array\nz = y.numpy()\nz","514f97dc":"!pip install jovian --upgrade --quiet\nimport jovian","4e123152":"jovian.commit(project='01-basics-pytorch')","cd1c8a7c":"## Tensor operations and gradients\n\nWe can combine tensors with the usual arithmetic operations. Let's look an example:","df602771":"We can convert a PyTorch tensor to a Numpy array using the `.numpy` method of a tensor.","b79f22cc":"Here's how we create an array in Numpy:","3b6055a6":"`4.` is a shorthand for `4.0`. It is used to indicate to Python (and PyTorch) that you want to create a floating point number. We can verify this by checking the `dtype` attribute of our tensor:","e8ac2def":"We can convert a Numpy array to a PyTorch tensor using `torch.from_numpy`.","5be7eedb":"# PyTorch Basics: Tensors & Gradients","13310913":"Tensors can have any number of dimensions, and different lengths along each dimension. We can inspect the length along each dimension using the `.shape` property of a tensor.","7c5cdc17":"As expected, `dy\/dw` has the same value as `x` i.e. `3`, and `dy\/db` has the value `1`. Note that `x.grad` is `None`, because `x` doesn't have `requires_grad` set to `True`. \n\nThe \"grad\" in `w.grad` stands for gradient, which is another term for derivative, used mainly when dealing with matrices. ","27695844":"Let's verify that the numpy array and torch tensor have similar data types.","cffb235d":"The interoperability between PyTorch and Numpy is really important because most datasets you'll work with will likely be read and preprocessed as Numpy arrays.","c3772b2d":"## Tensors\n\nAt its core, PyTorch is a library for processing tensors. A tensor is a number, vector, matrix or any n-dimensional array. Let's create a tensor with a single number:","4471203d":"## Interoperability with Numpy\n\n[Numpy](http:\/\/www.numpy.org\/) is a popular open source library used for mathematical and scientific computing in Python. It enables efficient operations on large multi-dimensional arrays, and has a large ecosystem of supporting libraries:\n\n* [Matplotlib](https:\/\/matplotlib.org\/) for plotting and visualization\n* [OpenCV](https:\/\/opencv.org\/) for image and video processing\n* [Pandas](https:\/\/pandas.pydata.org\/) for file I\/O and data analysis\n\nInstead of reinventing the wheel, PyTorch interoperates really well with Numpy to leverage its existing ecosystem of tools and libraries.","5e06f15d":"Let's try creating slightly more complex tensors:"}}