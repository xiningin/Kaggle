{"cell_type":{"c412ca48":"code","dca5d3a3":"code","55a9db34":"code","ddc4515e":"code","96c09e74":"code","dcb42d86":"code","3e4d3f53":"code","0acaf0fa":"code","5ced4a80":"code","2346ae68":"code","915cf090":"code","093a16db":"code","9d0617e4":"code","6e184f21":"code","2624a6ce":"markdown","dc22d2c9":"markdown","22038062":"markdown","c14043f9":"markdown","d15bf1bd":"markdown","20de863c":"markdown","f020443e":"markdown"},"source":{"c412ca48":"import numpy as np\nimport pandas as pd\n\nimport cv2\n\nimport matplotlib.pyplot as plt","dca5d3a3":"original_image = cv2.imread('..\/input\/famous-iconic-women\/output\/train\/Ada Lovelace\/000001.jpg')\n\n# Convert the image in grayscale\nimg = cv2.cvtColor(original_image, cv2.COLOR_BGR2GRAY)","55a9db34":"original_image.shape","ddc4515e":"img.shape","96c09e74":"img","dcb42d86":"# Threshold = 120\n# All pixels value above threshold will be set to 255\nret, thresh = cv2.threshold(img, 120, 255, cv2.THRESH_BINARY)\n\n# Display\nfig, axes = plt.subplots(nrows=1, ncols=2)\n\nimgs = [img, thresh]\nfor i, ax in enumerate(axes):\n    ax.imshow(imgs[i], cmap='gray')\n    ax.axis('off')\nplt.tight_layout()\nplt.show()","3e4d3f53":"thresh","0acaf0fa":"# Threshold = 120\nthresh = []\nfor i in range(img.shape[0]):\n    for j in range(img.shape[1]):\n        if img[i][j]> 120: \n            thresh.append(255)\n        else:\n            thresh.append(0) \n\nthres_img = np.array(thresh).reshape(img.shape[0],img.shape[1])\nfig, axes = plt.subplots(nrows=1, ncols=2)\n\nimgs = [img, thres_img]\nfor i, ax in enumerate(axes):\n    ax.imshow(imgs[i], cmap='gray')\n    ax.axis('off')\nplt.tight_layout()\nplt.show()\n","5ced4a80":"# Iterate over each pixel and change pixel value to binary using np.binary_repr() and store it in a list.\nlst = []\nfor i in range(img.shape[0]):\n    for j in range(img.shape[1]):\n         lst.append(np.binary_repr(img[i][j] ,width=8)) \n# width = no. of bits\n \n# We have a list of strings where each string represents binary pixel value. \n# To extract bit planes, iterate over the strings and store the characters corresponding to bit planes into lists.\n# reshape to reconstruct the binary image.\neight_bit_img = (np.array([int(i[0]) for i in lst],dtype = np.uint8)).reshape(img.shape[0],img.shape[1])\nseven_bit_img = (np.array([int(i[1]) for i in lst],dtype = np.uint8)).reshape(img.shape[0],img.shape[1])\nsix_bit_img = (np.array([int(i[2]) for i in lst],dtype = np.uint8)).reshape(img.shape[0],img.shape[1])\nfive_bit_img = (np.array([int(i[3]) for i in lst],dtype = np.uint8)).reshape(img.shape[0],img.shape[1])\nfour_bit_img = (np.array([int(i[4]) for i in lst],dtype = np.uint8)).reshape(img.shape[0],img.shape[1])\nthree_bit_img = (np.array([int(i[5]) for i in lst],dtype = np.uint8)).reshape(img.shape[0],img.shape[1])\ntwo_bit_img = (np.array([int(i[6]) for i in lst],dtype = np.uint8)).reshape(img.shape[0],img.shape[1])\none_bit_img = (np.array([int(i[7]) for i in lst],dtype = np.uint8)).reshape(img.shape[0],img.shape[1])\n \n# Concatenate these images for ease of display using cv2.hconcat()\nfinalr = cv2.hconcat([eight_bit_img,seven_bit_img,six_bit_img,five_bit_img])\nfinalv =cv2.hconcat([four_bit_img,three_bit_img,two_bit_img,one_bit_img])\n \n# Vertically concatenate\nfinal = cv2.vconcat([finalr,finalv])\n\n# Display\nfig, axes = plt.subplots(nrows=1, ncols=2)\n\n# cmap maps the color, here we give value 'gray' to cmap for binary image as well bit image, \n# cmap = 'binary' gives negative image\nimgs = [img, final]\nfor i, ax in enumerate(axes):\n    ax.imshow(imgs[i], cmap='gray') \n    ax.axis('off')\nplt.tight_layout()\nplt.show()","2346ae68":"eight_bit_img.shape","915cf090":"lst = []\nfor i in range(img.shape[0]):\n    for j in range(img.shape[1]):\n         lst.append(np.binary_repr(img[i][j] ,width=8)) ","093a16db":"plt.figure(figsize = (20, 10))\nplt.axis('off')\nplt.imshow(final, cmap='gray')","9d0617e4":"# Histograms Equalization\nequ = cv2.equalizeHist(img)","6e184f21":"fig = plt.figure(figsize = (20, 10))\n\n# show original image\nfig.add_subplot(221)\nplt.title('Original Image')\nplt.set_cmap('gray')\nplt.imshow(img)\n\nfig.add_subplot(222)\nplt.title('Histogram for Original Image')\nplt.hist(img.ravel(),256,[0,256])\n\nfig.add_subplot(223)\nplt.title('Equalized Image')\nplt.set_cmap('gray')\nplt.imshow(equ)\n\nfig.add_subplot(224)\nplt.title('HIstogram for Equalized Image')\nplt.hist(equ.ravel(),256,[0,256])\n\nplt.show() ","2624a6ce":"## How Thresholding Works ?","dc22d2c9":"# 2. Bit Plane Slicing","22038062":"### Read the Image","c14043f9":"# B. Histogram Processing and Equalization","d15bf1bd":"# A. Some Basic Gray Level Transformations","20de863c":"# 1. Thresholding","f020443e":"# Image Enhancement in Spatial Domain\n\nThe term **spatial domain** refers to the aggregate of pixels composing an image.\nSpatial domain methods are procedures that operate directly on these pixels.\nMost spatial domain enhancement operations can be reduced in the form:\n### g(x, y) = T [ f(x, y) ]\nwhere: <br \/>\n**f(x, y)** is the input image <br \/>\n**g(x, y)** is the processed image <br \/>\n**T** is some operator defined over some neighbourhood of (x, y) <br \/>"}}