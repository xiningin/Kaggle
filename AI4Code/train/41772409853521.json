{"cell_type":{"2810f9ec":"code","22894f06":"code","b3247355":"code","968c8c80":"code","78e58b6b":"code","85ca88bb":"code","c8c2a7dd":"code","7c2db28b":"code","5dbb26e1":"code","e42d4934":"code","8f23bf44":"code","12acb68a":"code","ec550890":"code","e1635435":"code","032c2525":"code","312c2755":"code","97b6e21c":"code","b4bedd20":"code","0e85889a":"code","bd3411b0":"code","1003f2ca":"code","99a6412e":"code","097356e0":"code","fd9c047f":"markdown","428bdfca":"markdown"},"source":{"2810f9ec":"import numpy as np\nimport pandas as pd\nimport joblib\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport optuna\n\nimport sklearn\nfrom sklearn import ensemble\nfrom sklearn.ensemble import RandomForestClassifier, ExtraTreesClassifier, GradientBoostingRegressor, VotingClassifier,\\\nGradientBoostingClassifier, AdaBoostClassifier\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.decomposition import PCA\nfrom sklearn.model_selection import ShuffleSplit, train_test_split, GridSearchCV, RepeatedStratifiedKFold\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import confusion_matrix, classification_report\nfrom sklearn.feature_selection import SelectFromModel\nimport featuretools as ft\nfrom lightgbm import LGBMClassifier","22894f06":"train = pd.read_csv('..\/input\/forest-cover-type-prediction\/train.csv')\ntest = pd.read_csv('..\/input\/forest-cover-type-prediction\/test.csv')\ntrain.head()","b3247355":"train = train.iloc[:,1:]\ntest = test.iloc[:,1:]","968c8c80":"X_train = train.iloc[:, 0:54]\nX_test = test.iloc[:, 0:54]","78e58b6b":"from IPython.display import Image\n\ndef plota(a1,a2):\n    fig = plt.figure(figsize=(16,8))\n    sel = np.array(list(train.Cover_Type.values))\n    plt.scatter(a1, a2, c=sel, s=100)\n    plt.xlabel(a1.name)\n    plt.ylabel(a2.name)","85ca88bb":"plota(train.Elevation, train.Horizontal_Distance_To_Hydrology)","c8c2a7dd":"plota(train.Elevation - 0.2 * train.Horizontal_Distance_To_Hydrology, train.Horizontal_Distance_To_Hydrology)","7c2db28b":"plota(train.Elevation, train.Horizontal_Distance_To_Roadways)","5dbb26e1":"plota(train.Elevation - .05 * train.Horizontal_Distance_To_Roadways, train.Horizontal_Distance_To_Roadways)","e42d4934":"plota(train.Elevation, train.Vertical_Distance_To_Hydrology)","8f23bf44":"plota(train.Elevation - train.Vertical_Distance_To_Hydrology, train.Vertical_Distance_To_Hydrology)","12acb68a":"#X_train['Slope_Hydrology'] = np.sqrt(X_train.Vertical_Distance_To_Hydrology**2 + X_train.Horizontal_Distance_To_Hydrology**2)\n#X_train.Slope_Hydrology = X_train.Slope_Hydrology.map(lambda x: 0 if np.isinf(x) else x)\n#X_train['Slope_Hydrology_PCT'] = (X_train.Vertical_Distance_To_Hydrology \/ X_train.Horizontal_Distance_To_Hydrology)*100\n#X_train.Slope_Hydrology_PCT=X_train.Slope_Hydrology_PCT.map(lambda x: 0 if np.isinf(x) else x)\n#X_train.Slope_Hydrology_PCT = X_train.Slope_Hydrology_PCT.fillna(0)\n\nX_train['Elev_to_Horizontal_Hyd']=X_train['Elevation'] - 0.2 * X_train['Horizontal_Distance_To_Hydrology'] \nX_train['Elev_to_Horizontal_Road']=X_train.Elevation - 0.05 * X_train.Horizontal_Distance_To_Roadways  \nX_train['Elev_to_Verticle_Hyd']=X_train.Elevation - X_train.Vertical_Distance_To_Hydrology \n\nX_train['Mean_Horizontal_Dist']=(X_train.Horizontal_Distance_To_Fire_Points + X_train.Horizontal_Distance_To_Hydrology + \n                                 X_train.Horizontal_Distance_To_Roadways)\/3 \nX_train['Mean_Fire_Hydro']=(X_train.Horizontal_Distance_To_Fire_Points + X_train.Horizontal_Distance_To_Hydrology)\/2","ec550890":"#X_test['Slope_Hydrology'] = np.sqrt(X_test.Vertical_Distance_To_Hydrology**2 + X_test.Horizontal_Distance_To_Hydrology**2)\n#X_test.Slope_Hydrology = X_test.Slope_Hydrology.map(lambda x: 0 if np.isinf(x) else x)\n#X_test['Slope_Hydrology_PCT'] = (X_test.Vertical_Distance_To_Hydrology \/ X_test.Horizontal_Distance_To_Hydrology)*100\n#X_test.Slope_Hydrology_PCT=X_test.Slope_Hydrology_PCT.map(lambda x: 0 if np.isinf(x) else x)\n#X_test.Slope_Hydrology_PCT = X_test.Slope_Hydrology_PCT.fillna(0)\n\nX_test['Elev_to_Horizontal_Hyd']=X_test.Elevation - 0.2 * X_test.Horizontal_Distance_To_Hydrology \nX_test['Elev_to_Horizontal_Road']=X_test.Elevation - 0.05 * X_test.Horizontal_Distance_To_Roadways  \nX_test['Elev_to_Verticle_Hyd']=X_test.Elevation - X_test.Vertical_Distance_To_Hydrology \n\nX_test['Mean_Horizontal_Dist']=(X_test.Horizontal_Distance_To_Fire_Points + X_test.Horizontal_Distance_To_Hydrology + \n                                 X_test.Horizontal_Distance_To_Roadways)\/3 \nX_test['Mean_Fire_Hydro']=(X_test.Horizontal_Distance_To_Fire_Points + X_test.Horizontal_Distance_To_Hydrology)\/2","e1635435":"X_cat = X_train.iloc[:, 10:54].values\nX_cat_columns = X_train.iloc[:, 10:54].columns\nX_num = X_train.iloc[:, np.r_[0:10, 54:59]].values\nX_num_columns = X_train.iloc[:, np.r_[0:10, 54:59]].columns\ny = train['Cover_Type'].values\n\nscaler = StandardScaler()\nscaler.fit(X_num)\nX_num = scaler.transform(X_num)\nX_train = pd.DataFrame(np.hstack((X_num, X_cat)), columns=list(X_num_columns) + list(X_cat_columns))\nprint(X_train.shape)","032c2525":"X_cat_test = X_test.iloc[:, 10:54].values\nX_cat_test_columns = X_test.iloc[:, 10:54].columns\nX_num_test = X_test.iloc[:, np.r_[0:10, 54:59]].values\nX_num_test_columns = X_test.iloc[:, np.r_[0:10, 54:59]].columns\n\nscaler.fit(X_num_test)\nX_num_test = scaler.transform(X_num_test)\nX_test = pd.DataFrame(np.hstack((X_num_test, X_cat_test)), columns=list(X_num_test_columns)+list(X_cat_test_columns))\nprint(X_test.shape)","312c2755":"cor_matrix = X_train.corr().abs()\nprint(cor_matrix)","97b6e21c":"simple_model = ExtraTreesClassifier()\nsimple_model = simple_model.fit(X_train, y)\nselector = SelectFromModel(simple_model, prefit=True)\nX_reduced = pd.DataFrame(selector.transform(X_train), columns = X_train.columns[(selector.get_support())])","b4bedd20":"%%time\n\n# optuna hyperparameter tuning\ndef objective(trial):\n    max_depth = trial.suggest_int('max_depth', 30, 50)\n    min_samples_leaf = trial.suggest_int('min_samples_leaf', 1, 20)\n    cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)\n    tree_clf = ExtraTreesClassifier(random_state = 0, n_estimators = 200, max_depth = max_depth, min_samples_leaf = min_samples_leaf)\n    return sklearn.model_selection.cross_val_score(tree_clf, X_train, y, n_jobs = -1, cv = cv).mean()\n    \ntree_study = optuna.create_study(direction='maximize')\ntree_study.optimize(objective, n_trials=20)\ntree = tree_study.best_trial\nprint('Accuracy: {}'.format(tree.value))\nprint(\"Best hyperparameters: {}\".format(tree.params))","0e85889a":"tree_model = ExtraTreesClassifier(random_state = 1, \n                                  n_estimators = 200, \n                                  max_depth =  tree.params['max_depth'],\n                                  min_samples_leaf = tree.params['min_samples_leaf'])\n\n\ntree_model.fit(X_train, y)","bd3411b0":"y_pred = tree_model.predict(X_test)","1003f2ca":"submission = pd.read_csv('..\/input\/forest-cover-type-prediction\/sampleSubmission.csv')","99a6412e":"submission['Cover_Type'] = y_pred","097356e0":"submission.to_csv('submission.csv', index = False, header = True)","fd9c047f":"### Pre-Processing","428bdfca":"### Feature Engineering"}}