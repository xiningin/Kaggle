{"cell_type":{"c2e29a10":"code","746c3108":"code","962361c3":"code","04e95a02":"markdown"},"source":{"c2e29a10":"%%writefile submission.py\n\nfrom kaggle_environments.envs.hungry_geese.hungry_geese import Observation, Configuration, Action, row_col\nimport numpy as np\nimport random\n\nlast_step = None\n\ndef get_nearest_cells(x,y):\n    # returns all cells reachable from the current one\n    result = []\n    for i in (-1,+1):\n        result.append(((x+i+7)%7, y))\n        result.append((x, (y+i+11)%11))\n    return result\n\ndef find_closest_food(table):\n    # returns the first step toward the closest food item\n    new_table = table.copy()\n    \n    \n    # (direction of the step, axis, code)\n    possible_moves = [\n        (1, 0, 1),\n        (-1, 0, 2),\n        (1, 1, 3),\n        (-1, 1, 4)\n    ]\n    \n    # shuffle possible options to add variability\n    random.shuffle(possible_moves)\n    \n    \n    updated = False\n    for roll, axis, code in possible_moves:\n\n        shifted_table = np.roll(table, roll, axis)\n        \n        if (table == -2).any() and (shifted_table[table == -2] == -3).any(): # we have found some food at the first step\n            return code\n        else:\n            mask = np.logical_and(new_table == 0,shifted_table == -3)\n            if mask.sum() > 0:\n                updated = True\n            new_table += code * mask\n        if (table == -2).any() and shifted_table[table == -2][0] > 0: # we have found some food\n            return shifted_table[table == -2][0]\n        \n        # else - update new reachible cells\n        mask = np.logical_and(new_table == 0,shifted_table > 0)\n        if mask.sum() > 0:\n            updated = True\n        new_table += shifted_table * mask\n\n    # if we updated anything - continue reccurison\n    if updated:\n        return find_closest_food(new_table)\n    # if not - return some step\n    else:\n        return table.max()\n\ndef agent(obs_dict, config_dict):\n    global last_step\n    \n    observation = Observation(obs_dict)\n    configuration = Configuration(config_dict)\n    player_index = observation.index\n    player_goose = observation.geese[player_index]\n    player_head = player_goose[0]\n    player_row, player_column = row_col(player_head, configuration.columns)\n\n\n    table = np.zeros((7,11))\n    # 0 - emply cells\n    # -1 - obstacles\n    # -4 - possible obstacles\n    # -2 - food\n    # -3 - head\n    # 1,2,3,4 - reachable on the current step cell, number is the id of the first step direction\n    \n    legend = {\n        1: 'SOUTH',\n        2: 'NORTH',\n        3: 'EAST',\n        4: 'WEST'\n    }\n    \n    # let's add food to the map\n    for food in observation.food:\n        x,y = row_col(food, configuration.columns)\n        table[x,y] = -2 # food\n        \n    # let's add all cells that are forbidden\n    for i in range(4):\n        opp_goose = observation.geese[i]\n        if len(opp_goose) == 0:\n            continue\n            \n        is_close_to_food = False\n            \n        if i != player_index:\n            x,y = row_col(opp_goose[0], configuration.columns)\n            possible_moves = get_nearest_cells(x,y) # head can move anywhere\n            \n            for x,y in possible_moves:\n                if table[x,y] == -2:\n                    is_close_to_food = True\n            \n                table[x,y] = -4 # possibly forbidden cells\n        \n        # usually we ignore the last tail cell but there are exceptions\n        tail_change = -1\n        if obs_dict['step'] % 40 == 39:\n            tail_change -= 1\n        \n        # we assume that the goose will eat the food\n        if is_close_to_food:\n            tail_change += 1\n        if tail_change >= 0:\n            tail_change = None\n            \n\n        for n in opp_goose[:tail_change]:\n            x,y = row_col(n, configuration.columns)\n            table[x,y] = -1 # forbidden cells\n    \n    # going back is forbidden according to the new rules\n    x,y = row_col(player_head, configuration.columns)\n    if last_step is not None:\n        if last_step == 1:\n            table[(x + 6) % 7,y] = -1\n        elif last_step == 2:\n            table[(x + 8) % 7,y] = -1\n        elif last_step == 3:\n            table[x,(y + 10)%11] = -1\n        elif last_step == 4:\n            table[x,(y + 12)%11] = -1\n        \n    # add head position\n    table[x,y] = -3\n    \n    step = None\n    if len(player_goose) < 4:\n        # the first step toward the nearest food\n        step = int(find_closest_food(table))\n    elif len(player_goose) == 4:\n        head_x, head_y = row_col(player_head, configuration.columns)\n        tail_x, tail_y = row_col(player_goose[-1], configuration.columns)\n        \n        # if the tail is close let's move to the place of tail\n        if abs(head_x - tail_x) + abs(head_y - tail_y) == 1:\n            if (head_x - tail_x + 7) % 7 == 1:\n                step = 2\n            elif (head_x - tail_x + 7) % 7 == 6:\n                step = 1\n            elif (head_y - tail_y + 11) % 11 == 1:\n                step = 4\n            elif (head_y - tail_y + 11) % 11 == 10:\n                step = 3\n        # else try to turn\n        elif last_step in (1, 2):\n            possible_steps = []\n            if table[head_x,(head_y + 12)%11] == 0:\n                possible_steps.append(3)\n            if table[head_x,(head_y + 10)%11] == 0:\n                possible_steps.append(4)\n            if len(possible_steps)>0:\n                step = np.random.choice(possible_steps)\n        elif last_step in (3, 4):\n            possible_steps = []\n            if table[(head_x + 8) % 7,head_y] == 0:\n                possible_steps.append(1)\n            if table[(head_x + 6) % 7,head_y] == 0:\n                possible_steps.append(2)\n            if len(possible_steps)>0:\n                step = np.random.choice(possible_steps)\n           \n    # if there is not available steps try to go to safe or possibly dangerous cell\n    if step not in [1,2,3,4]:\n        x,y = row_col(player_head, configuration.columns)\n        if table[(x + 8) % 7,y] in [0,-2]:\n            step = 1\n        elif table[(x + 6) % 7,y] in [0,-2]:\n            step = 2\n        elif table[x,(y + 12)%11] in [0,-2]:\n            step = 3\n        elif table[x,(y + 10)%11] in [0,-2]:\n            step = 4\n                \n    if step not in [1,2,3,4]:\n        if table[(x + 8) % 7,y] == -4:\n            step = 1\n        elif table[(x + 6) % 7,y] == -4:\n            step = 2\n        elif table[x,(y + 12)%11] == -4:\n            step = 3\n        elif table[x,(y + 10)%11] == -4:\n            step = 4                \n    # else - do a random step and lose\n        else:\n            step = np.random.randint(4) + 1\n    \n    last_step = step\n    return legend[step]","746c3108":"from kaggle_environments import evaluate, make\nenv = make(\"hungry_geese\", debug = True)","962361c3":"env.reset()\nenv.run(['submission.py', 'submission.py', 'submission.py', 'submission.py'])\nenv.render(mode=\"ipython\", width=800, height=700)","04e95a02":"In my [baseline notebook](https:\/\/www.kaggle.com\/ilialar\/risk-averse-greedy-goose) the goose is always moving to the nearest piece of food, but [in this discussion](https:\/\/www.kaggle.com\/c\/hungry-geese\/discussion\/215010) is was proposed not to eat but stay small to decrease chances to bite yourself.\n\nSo here I have updated my previous agent. It behaves greedily when its length is less than 4 and tries to move in the safe square when it is 4 and randomly when it is more than 4."}}