{"cell_type":{"a13182db":"code","336e2fea":"code","d1b8de71":"code","88ad009d":"code","f260da76":"code","ec94f7bc":"code","eac0ad59":"code","4280eb99":"code","222984f2":"code","2a50a450":"code","c8e4ed5b":"code","779b8ef5":"code","8e9daebc":"code","d7d5ee3c":"code","17e62ff1":"code","998b19a6":"code","43cf83a7":"code","6895f0d7":"code","2b55d741":"code","9468bc46":"code","858c55b4":"code","3270cecb":"code","0d9ba958":"code","6c58eca0":"code","480f82d7":"code","7ef0f12c":"code","05d3f35e":"code","7a8bd23a":"code","3e55c408":"code","8c63a6c5":"code","0d995a0e":"code","89322671":"code","55597f03":"code","0b0f2fea":"code","03af2107":"code","90a61297":"code","04e219a5":"code","17a4f30b":"code","14e342d8":"code","c93eb46b":"code","23011fba":"code","3b05e341":"markdown","ca3f1950":"markdown","26725fa1":"markdown","db7debe0":"markdown","21eae2d4":"markdown","28e647ea":"markdown","1765cd9c":"markdown","2ad99592":"markdown","e7042f0b":"markdown","66402a7f":"markdown"},"source":{"a13182db":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport datetime as dt\n\nimport sklearn\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import KMeans\nfrom sklearn.metrics import silhouette_score\n\nfrom scipy.cluster.hierarchy import linkage\nfrom scipy.cluster.hierarchy import dendrogram\nfrom scipy.cluster.hierarchy import cut_tree","336e2fea":"# read the dataset\nretail_df = pd.read_csv(\"..\/input\/online-retail-customer-clustering\/OnlineRetail.csv\", sep=\",\", encoding=\"ISO-8859-1\", header=0)\nretail_df.head()","d1b8de71":"# basics of the df\nretail_df.info()","88ad009d":"# missing values\nround(100*(retail_df.isnull().sum())\/len(retail_df), 2)","f260da76":"# drop all rows having missing values\nretail_df = retail_df.dropna()\nretail_df.shape","ec94f7bc":"retail_df.head()","eac0ad59":"# new column: amount \nretail_df['amount'] = retail_df['Quantity']*retail_df['UnitPrice']\nretail_df.head()","4280eb99":"# monetary\ngrouped_df = retail_df.groupby('CustomerID')['amount'].sum()\ngrouped_df = grouped_df.reset_index()\ngrouped_df.head()","222984f2":"# frequency\nfrequency = retail_df.groupby('CustomerID')['InvoiceNo'].count()\nfrequency = frequency.reset_index()\nfrequency.columns = ['CustomerID', 'frequency']\nfrequency.head()","2a50a450":"# merge the two dfs\ngrouped_df = pd.merge(grouped_df, frequency, on='CustomerID', how='inner')\ngrouped_df.head()","c8e4ed5b":"retail_df.head()","779b8ef5":"# recency\n# convert to datetime\nretail_df['InvoiceDate'] = pd.to_datetime(retail_df['InvoiceDate'], \n                                          format='%d-%m-%Y %H:%M')","8e9daebc":"retail_df.head()","d7d5ee3c":"# compute the max date\nmax_date = max(retail_df['InvoiceDate'])\nmax_date","17e62ff1":"# compute the diff\nretail_df['diff'] = max_date - retail_df['InvoiceDate']\nretail_df.head()","998b19a6":"# recency\nlast_purchase = retail_df.groupby('CustomerID')['diff'].min()\nlast_purchase = last_purchase.reset_index()\nlast_purchase.head()","43cf83a7":"# merge\ngrouped_df = pd.merge(grouped_df, last_purchase, on='CustomerID', how='inner')\ngrouped_df.columns = ['CustomerID', 'amount', 'frequency', 'recency']\ngrouped_df.head()","6895f0d7":"# number of days only\ngrouped_df['recency'] = grouped_df['recency'].dt.days\ngrouped_df.head()","2b55d741":"# 1. outlier treatment\nplt.boxplot(grouped_df['recency'])","9468bc46":"# two types of outliers:\n# - statistical\n# - domain specific","858c55b4":"# removing (statistical) outliers\nQ1 = grouped_df.amount.quantile(0.05)\nQ3 = grouped_df.amount.quantile(0.95)\nIQR = Q3 - Q1\ngrouped_df = grouped_df[(grouped_df.amount >= Q1 - 1.5*IQR) & (grouped_df.amount <= Q3 + 1.5*IQR)]\n\n# outlier treatment for recency\nQ1 = grouped_df.recency.quantile(0.05)\nQ3 = grouped_df.recency.quantile(0.95)\nIQR = Q3 - Q1\ngrouped_df = grouped_df[(grouped_df.recency >= Q1 - 1.5*IQR) & (grouped_df.recency <= Q3 + 1.5*IQR)]\n\n# outlier treatment for frequency\nQ1 = grouped_df.frequency.quantile(0.05)\nQ3 = grouped_df.frequency.quantile(0.95)\nIQR = Q3 - Q1\ngrouped_df = grouped_df[(grouped_df.frequency >= Q1 - 1.5*IQR) & (grouped_df.frequency <= Q3 + 1.5*IQR)]\n\n","3270cecb":"# 2. rescaling\nrfm_df = grouped_df[['amount', 'frequency', 'recency']]\n\n# instantiate\nscaler = StandardScaler()\n\n# fit_transform\nrfm_df_scaled = scaler.fit_transform(rfm_df)\nrfm_df_scaled.shape","0d9ba958":"rfm_df_scaled = pd.DataFrame(rfm_df_scaled)\nrfm_df_scaled.columns = ['amount', 'frequency', 'recency']\nrfm_df_scaled.head()","6c58eca0":"# k-means with some arbitrary k\nkmeans = KMeans(n_clusters=4, max_iter=50)\nkmeans.fit(rfm_df_scaled)","480f82d7":"kmeans.labels_","7ef0f12c":"# help(KMeans)","05d3f35e":"# elbow-curve\/SSD\nssd = []\nrange_n_clusters = [2, 3, 4, 5, 6, 7, 8]\nfor num_clusters in range_n_clusters:\n    kmeans = KMeans(n_clusters=num_clusters, max_iter=50)\n    kmeans.fit(rfm_df_scaled)\n    \n    ssd.append(kmeans.inertia_)\n    \n# plot the SSDs for each n_clusters\n# ssd\nplt.plot(ssd)","7a8bd23a":"# silhouette analysis\nrange_n_clusters = [2, 3, 4, 5, 6, 7, 8]\n\nfor num_clusters in range_n_clusters:\n    \n    # intialise kmeans\n    kmeans = KMeans(n_clusters=num_clusters, max_iter=50)\n    kmeans.fit(rfm_df_scaled)\n    \n    cluster_labels = kmeans.labels_\n    \n    # silhouette score\n    silhouette_avg = silhouette_score(rfm_df_scaled, cluster_labels)\n    print(\"For n_clusters={0}, the silhouette score is {1}\".format(num_clusters, silhouette_avg))\n    \n    ","3e55c408":"# final model with k=3\nkmeans = KMeans(n_clusters=3, max_iter=50)\nkmeans.fit(rfm_df_scaled)","8c63a6c5":"kmeans.labels_","0d995a0e":"# assign the label\ngrouped_df['cluster_id'] = kmeans.labels_\ngrouped_df.head()","89322671":"# plot\nsns.boxplot(x='cluster_id', y='amount', data=grouped_df)","55597f03":"rfm_df_scaled.head()","0b0f2fea":"grouped_df.head()","03af2107":"# single linkage\nmergings = linkage(rfm_df_scaled, method=\"single\", metric='euclidean')\ndendrogram(mergings)\nplt.show()","90a61297":"# complete linkage\nmergings = linkage(rfm_df_scaled, method=\"complete\", metric='euclidean')\ndendrogram(mergings)\nplt.show()","04e219a5":"# 3 clusters\ncluster_labels = cut_tree(mergings, n_clusters=3).reshape(-1, )\ncluster_labels","17a4f30b":"# assign cluster labels\ngrouped_df['cluster_labels'] = cluster_labels\ngrouped_df.head()","14e342d8":"# plots\nsns.boxplot(x='cluster_labels', y='recency', data=grouped_df)","c93eb46b":"# plots\nsns.boxplot(x='cluster_labels', y='frequency', data=grouped_df)","23011fba":"# plots\nsns.boxplot(x='cluster_labels', y='amount', data=grouped_df)","3b05e341":"- R (Recency): Number of days since last purchase\n- F (Frequency): Number of tracsactions\n- M (Monetary): Total amount of transactions (revenue contributed)","ca3f1950":"# 3. Prepare the data for modelling","26725fa1":"# 1. Read and visualise the data","db7debe0":"**Overview**<br>\n<a href=\"https:\/\/archive.ics.uci.edu\/ml\/datasets\/online+retail\">Online retail is a transnational data set<\/a> which contains all the transactions occurring between 01\/12\/2010 and 09\/12\/2011 for a UK-based and registered non-store online retail. The company mainly sells unique all-occasion gifts. Many customers of the company are wholesalers.\n\nThe steps are broadly:\n1. Read and understand the data\n2. Clean the data\n3. Prepare the data for modelling\n4. Modelling\n5. Final analysis and reco","21eae2d4":"### Silhouette Analysis\n\n$$\\text{silhouette score}=\\frac{p-q}{max(p,q)}$$\n\n$p$ is the mean distance to the points in the nearest cluster that the data point is not a part of\n\n$q$ is the mean intra-cluster distance to all the points in its own cluster.\n\n* The value of the silhouette score range lies between -1 to 1. \n\n* A score closer to 1 indicates that the data point is very similar to other data points in the cluster, \n\n* A score closer to -1 indicates that the data point is not similar to the data points in its cluster.","28e647ea":"# 2. Clean the data","1765cd9c":"## Hierarchical Clustering","2ad99592":"## Finding the Optimal Number of Clusters\n\n### SSD","e7042f0b":"## K-Means Clustering","66402a7f":"# 4. Modelling"}}