{"cell_type":{"0d26b9cd":"code","6e78f06e":"markdown"},"source":{"0d26b9cd":"import numpy as np\nimport pandas as pd\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\nfrom PIL import Image\nimport os\nimport torchvision.transforms as transforms\n\nclass CustomDatasetImage(Dataset):\n    def __init__(self, csv_file, root_dir, transform=None, threechannel=True, image_idx=0, label_idx=1):\n        self.customdataDF = pd.read_csv(csv_file) #csv file containing image names\u3000\/\u3000\u753b\u50cf\u540d\u304c\u5165\u3063\u3066\u3044\u308bcsv\u306e\u8aad\u307f\u8fbc\u307f\n        self.root_dir = root_dir #root directory of where images are stored\u3000\/\u3000\u753b\u50cf\u304c\u4fdd\u5b58\u3055\u308c\u3066\u3044\u308bdir\n        self.transform = transform #transformations to apply to images if any\u3000\/\u3000\u753b\u50cf\u306e\u5909\u63db\n        self.threechannel = threechannel #default is true for standard 3 channel images. false for greyscale images.\u3000\/\u3000RGB\u753b\u50cf\u306e\u5834\u5408\u5165\u529b\u304c\u4e0d\u8981\u3001\u767d\u9ed2\u306e\u5834\u5408\u306fFalse\u306e\u5165\u529b\n        self.image_idx = image_idx\n        self.label_idx = label_idx\n    \n    def __len__(self):\n        return len(self.customdataDF) #return the total number of images\u3000\/ \u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306e\u6570\n    \n    def __getitem__(self,idx):\n        img_path = os.path.join(self.root_dir,self.customdataDF.iloc[idx,self.image_idx]) #obtain the file path of the nth item of the csv \/ idx\u500b\u76ee\u306e\u753b\u50cf\u306e\u30d5\u30a1\u30a4\u30eb\u30d1\u30b9\n        \n        if self.threechannel:\n            img = Image.open(img_path).convert(\"RGB\") #ensure that the channels are in RGB order \/ \u30c1\u30e3\u30f3\u30cd\u30eb\u306f\u3061\u3083\u3093\u3068RGB\u306b\u3059\u308b\n        else:\n            img = Image.open(img_path).convert(\"L\") #greyscale \/ \u767d\u9ed2\u306e\u5834\u5408\n        \n        label = torch.tensor(int(self.customdataDF.iloc[idx,self.label_idx])) #get label and convert to tensor \/\u3000\u30e9\u30d9\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u3068\u30c6\u30f3\u30bd\u30eb\u3078\u306e\u5909\u63db\n        \n        if self.transform: #if there are any transformations, apply\u3000\/ \u5909\u63db\u304c\u3042\u308c\u3070\u5b9f\u884c\u3059\u308b\n            img=self.transform(img)\n        \n        return (img,label)\n\ndef ObtainMeanStdDataset(csv_file, root_dir, batch_size, device, img_resize=None, num_workers=4, threechannel=True, image_idx=0, label_idx=1):\n    #input: csv_file, root_dir, batch_size, device, img_resize, num_workers, threechannel, image_idx, label_idx, batch_size, device\u3000\n    # if wish to resize image, pass desired size tuple through img_resize argument\n    #\u3000\u5165\u529b\uff1acsv\u30d5\u30a1\u30a4\u30eb\u540d\u3001\u753b\u50cf\u30c0\u30a4\u30ec\u30af\u30c8\u30ea\u30fc\u3001\u5e73\u5747\u30fb\u5206\u6563\u3092\u8a08\u7b97\u3059\u308b\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba\u3001\u30c7\u30d0\u30a4\u30b9\u3001\u65b0\u753b\u50cf\u306e\u30b5\u30a4\u30ba\uff08\u30bf\u30d7\u30eb\uff09\u3001worker\u6570\u3001\u30c1\u30e3\u30f3\u30cd\u30eb\u3001\u753b\u50cf\u540d\u306e\u884c\u5217(csv\u5185)\u3001\u30e9\u30d9\u30eb\u306e\u884c\u5217(csv\u5185)\n    #return mean, std\u3000\/\u3000\u51fa\u529b\uff1a\u5e73\u5747\u3001\u6a19\u6e96\u504f\u5dee\n    # VAR(X)= E(X**2)-(E(X))**2\n    # std is calculated by taking root of VAR\u3001\u6a19\u6e96\u504f\u5dee\u306f\u5206\u6563\u306e\u5e73\u65b9\u6839\u3067\u8a08\u7b97\u3059\u308b\n    \n    sum_each_mb_channel, sum_each_mb_squared_channel = 0 , 0\n    \n    if img_resize:\n        transform = transforms.Compose([transforms.Resize(img_resize),transforms.ToTensor()]) #if there's a resize, resize\n    else:\n        transform = transform.ToTensor()\n    \n    customdata = CustomDatasetImage(csv_file, root_dir, transform, threechannel, image_idx, label_idx)\n    loader = DataLoader(customdata, batch_size=batch_size, shuffle=True, num_workers=num_workers)\n    \n    for minibatch_idx, (img,label) in enumerate(loader):\n        img = img.to(device = device)\n        sum_each_mb_channel += torch.mean(img, dim=[0,2,3]) # N X C X H x W mean to be taken across N, H and W\u3000\/\u3000N,H,W\u306e\u5e73\u5747\n        sum_each_mb_squared_channel += torch.mean(img**2, dim=[0,2,3]) #E(X**2)\n    \n    mean = sum_each_mb_channel\/(minibatch_idx+1)#index starts from 0 need to add 1\u3000\/\u3000\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306f\uff10\u304b\u3089\u59cb\u307e\u308b\uff08\u30df\u30cb\u30d0\u30c3\u30c1\u6570\u306f+\uff11\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u3044\uff09\n    variance = sum_each_mb_squared_channel\/(minibatch_idx+1) - mean**2\n    std = variance**0.5\n    \n    return mean, std","6e78f06e":"Just a notebook of some pytorch utility functions\/classes so I don't have to rewrite them everytime I do a DL\/ML task.\n\nCurrently contains:\n* Class for custom dataset (images)\n* Function to find the mean and standard deviation of the custom dataset (Useful for normalizing inputs)\n\n\u30b3\u30f3\u30da\u3084\u901a\u5e38\u306e\uff24\uff2c\u30fb\uff2d\uff2c\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u4f7f\u3048\u305d\u3046\u306a\u95a2\u6570\u3068\u30af\u30e9\u30b9\u3092\u3053\u306e\u30ce\u30fc\u30c8\u30d6\u30c3\u30af\u306b\u307e\u3068\u3081\u307e\u3057\u305f\u3002\uff08Pytorch\u7528\uff09\n\n\u542b\u3093\u3067\u3044\u308b\u30a2\u30a4\u30c6\u30e0\uff1a\n* \u30ab\u30b9\u30bf\u30e0\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306e\u30af\u30e9\u30b9\uff08\u753b\u50cf\uff09\n* \u30ab\u30b9\u30bf\u30e0\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306e\u5e73\u5747\u3068\u6a19\u6e96\u504f\u5dee\u3092\u5f97\u308b\u95a2\u6570\uff08\u5165\u529b\u306e\u6b63\u898f\u5316\u306b\u4f7f\u7528\u3059\u308b\uff09"}}