{"cell_type":{"1bc9813f":"code","86101f8f":"code","0aa92d08":"code","3b8a3125":"code","a2231dc6":"code","cfbc485f":"code","8e257969":"code","b7a2aaf8":"code","98aab214":"code","eaeba3ca":"code","af998984":"code","9f0766ab":"code","26d5d0e6":"code","b098be12":"code","428d6258":"code","127e76af":"code","d6f81b97":"code","52a3b6ed":"code","b6209a70":"code","230ab76f":"code","5acdb37d":"code","fb68ab6d":"code","1571e14f":"code","50ffc1fd":"code","e071a6bd":"code","a80ddff5":"code","5e8ff343":"code","e95ab4e4":"code","54af9e80":"code","2f3d43ea":"code","6a1b53cc":"code","46a0ea9a":"code","2c1daf37":"code","b391e3e5":"code","f854ded1":"code","4e7bc966":"code","725900f5":"code","9e94fff7":"code","9fd45a19":"code","a5a78fa9":"code","c9d96878":"code","0e1d2bf0":"code","dacb4dad":"code","5c13edbb":"code","be4b11d1":"markdown","e7b61aff":"markdown","b74f8273":"markdown","204fc678":"markdown","00a3f535":"markdown","eab7a696":"markdown","e286d19f":"markdown","5141bdb7":"markdown","190a4113":"markdown","a5ad42e8":"markdown","0b3f6cde":"markdown","26f9c9ab":"markdown","50f196d6":"markdown","389a61f8":"markdown","fe9a8f39":"markdown","df6c8afb":"markdown","72e7b635":"markdown","56260b96":"markdown","84cb05c7":"markdown","da5b4d92":"markdown","5ecf4644":"markdown","944a5de1":"markdown","c0661a91":"markdown","8533b6ab":"markdown","986a3b84":"markdown","2a0eb890":"markdown","2d9bd3e3":"markdown","b17c5032":"markdown","f16e0101":"markdown","baaa3204":"markdown","04c00f8c":"markdown","7a9d79f1":"markdown","7a5df92a":"markdown","f16e1fdf":"markdown","cd1e339a":"markdown","428d6f67":"markdown","c86e502d":"markdown","4fea6782":"markdown","f95babc8":"markdown","72741365":"markdown","d03c116b":"markdown","5d514edd":"markdown","42d6122d":"markdown","6ba2a912":"markdown","11d812aa":"markdown","99ea7f49":"markdown"},"source":{"1bc9813f":"#basic packages \nimport numpy as np\nimport pandas as pd\n\n#for plotting graphs\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style('darkgrid')\nsns.set(font_scale=1.2)\nimport plotly.express as px\nfrom plotly import graph_objects as go\n\n#plot wordcloud\nfrom collections import Counter\nfrom wordcloud import WordCloud\n\n#sklearn NLP tools\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.metrics.pairwise import  cosine_similarity\n\n#silence warnings\nimport warnings\nwarnings.filterwarnings('ignore')","86101f8f":"all_data = pd.read_csv('..\/input\/netflix-shows\/netflix_titles.csv')","0aa92d08":"#display top few rows\nall_data.head()","3b8a3125":"all_data.info()","a2231dc6":"labels = all_data.type.value_counts().index\nvals = all_data.type.value_counts().values\nplt.pie(vals, explode=[0, 0.08], radius=1.6, labels=labels, autopct='%.1f', textprops={'fontsize': 14})\nplt.title('Proportion of Movies & TV Shows', fontsize=14, fontfamily='calibri', fontweight='bold', position=(0.20, 1.22+0.02))\nplt.show()","cfbc485f":"#create year column and parse year from date_added column\nall_data['year'] = all_data['date_added'].dropna().apply(lambda x: x.split(',')[-1])\n\n#parse month from date_added column\nall_data['month'] = all_data['date_added'].dropna().apply(lambda x: x.lstrip().split(' ')[0])\nmonth_order = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', \\\n               'September', 'October', 'November', 'December'][::-1]","8e257969":"month_count = all_data.groupby('year')['month'].value_counts().unstack().fillna(0)[month_order].T\n\nplt.figure(figsize=(10, 7), dpi=150)\n\n# plot heatmap of content addition\nplt.pcolormesh(month_count, cmap='gist_heat_r', edgecolors='white', linewidths=2) \nplt.xticks(np.arange(0.5, len(month_count.columns), 1), month_count.columns, fontsize=7, fontfamily='serif')\nplt.yticks(np.arange(0.5, len(month_count.index), 1), month_count.index, fontsize=7, fontfamily='serif')\nplt.title('Netflix Content Addition', fontsize=12, fontfamily='calibri', fontweight='bold', position=(0.20, 1.0+0.02))\ncbar = plt.colorbar()\ncbar.ax.tick_params(labelsize=8) \ncbar.ax.minorticks_on()\nplt.show()","b7a2aaf8":"all_data['date_added'] = pd.to_datetime(all_data['date_added'])","98aab214":"movies = all_data[all_data['type']=='Movie']\ntv_shows = all_data[all_data['type']=='TV Show']\nyear_added = pd.DataFrame(index=np.unique(all_data.date_added.dt.year))\nmov = movies['date_added'].dt.year.value_counts()\ntv = tv_shows['date_added'].dt.year.value_counts()\nyear_added['Movie'] = mov\nyear_added['TV_show'] = tv \nyear_added = year_added.fillna(0).astype(int)\n\nplt.figure(figsize=(10,6), dpi=110)\nplt.plot(year_added.index, year_added.Movie, 'go-', label='Movie')\nplt.plot(year_added.index, year_added.TV_show, 'ro-', label='TV Show')\nplt.title('Content growth over the years', fontweight='bold')\nplt.legend()\nplt.show()","eaeba3ca":"imdb_movies = pd.read_csv('..\/input\/imdb-movie-ratings\/IMDb movies.csv', usecols=['title','genre'])\nimdb_ratings = pd.read_csv('..\/input\/imdb-movie-ratings\/IMDb ratings.csv', usecols=['weighted_average_vote'])","af998984":"ratings = pd.DataFrame({'title':imdb_movies.title, 'genre':imdb_movies.genre, \\\n                       'imdb_rating':imdb_ratings.weighted_average_vote})\nratings.drop_duplicates(subset=['title', 'imdb_rating'], inplace=True)\nratings.dropna()\n\n# merging the ratings table with all_data table using inner join to drop any movies present in netflix table \n# but not in imdb ratings table\nnetflix_ratings = ratings.merge(all_data, left_on='title', right_on='title', how='inner')\nnetflix_ratings = netflix_ratings.sort_values(by='imdb_rating', ascending=False).dropna()","9f0766ab":"top_rated=netflix_ratings[0:10]\n\n# Plotly suburst plot showing release_year, released countries & title\nfig =px.sunburst(\n    top_rated,\n    path=['release_year', 'country', 'title'],\n    values='imdb_rating',\n    color='imdb_rating', title='Movies with high ratings')\nfig.show()","26d5d0e6":"lowest_rated=netflix_ratings[-10:]\nfig =px.sunburst(\n    lowest_rated,\n    path=['release_year', 'country', 'title'],\n    values='imdb_rating',\n    color='imdb_rating', title='Movies with low ratings')\nfig.show()","b098be12":"movies[['title', 'release_year']].sort_values(by='release_year').head(15)","428d6258":"tv_shows[['title', 'release_year']].sort_values(by='release_year').head(15)","127e76af":"rating_content_type = all_data[['type', 'rating']]\nplt.figure(figsize=(12,7))\nsns.countplot(rating_content_type['rating'], hue=rating_content_type['type'])\nplt.xticks(rotation=45)\nplt.title('Count of ratings by content type', fontsize=14, fontweight='bold', fontfamily='calibri')\nplt.legend(loc='upper right')\nplt.show()","d6f81b97":"movies_duration = movies.duration.apply(lambda x: x.split()[0])\nplt.figure(figsize=(12,6))\nsns.distplot(movies_duration)\nplt.title('Distribution of duration of Movies in minutes')\nplt.show()","52a3b6ed":"season_order = ['1 Season', '2 Seasons', '3 Seasons', '4 Seasons', '5 Seasons', \\\n                                         '6 Seasons', '7 Seasons', '8 Seasons', '9 Seasons', '10 Seasons', \\\n                                         '11 Seasons', '12 Seasons', '13 Seasons', '14 Seasons', '15 Seasons']\nplt.figure(figsize=(12,6))\nsns.countplot(tv_shows.duration, order = season_order).set_title('Most frequent no. of seasons')\nplt.xticks(rotation=90)\nplt.show()","b6209a70":"duration = tv_shows['duration'].apply(lambda x: x.split()[0]).astype(int)\ntv_shows['no_of_seasons'] = duration\nmost_seasons = tv_shows[['title', 'no_of_seasons']].sort_values(by='no_of_seasons', ascending=False)[:25]\nplt.figure(figsize=(16,8))\nsns.barplot(x = 'title', y='no_of_seasons', data=most_seasons).set_title('Shows with most seasons')\nplt.xticks(rotation=90)\nplt.show()","230ab76f":"# get the top 10 countries by overall content\ntop_countries = all_data['country'].value_counts() \ntop_countries = pd.DataFrame(top_countries)\ntop10_countries = top_countries[:10].reset_index()\n\n# creating a new dataframe which has country names in descending order of movies \nmov_vals = pd.DataFrame(movies['country'].value_counts()).reset_index()\n\n# merging the mov_vals dataframe with top10_countries dataframe on country names and renaming columns\ntop10_countries=top10_countries.merge(mov_vals, left_on='index', right_on='index', \\\n                                      how='inner').rename(columns={\"country_x\":\"Overall\", \"country_y\":\"Movies\"})\n\n# creating a new dataframe which has country names in descending order of TV shows \ntv_vals = pd.DataFrame(tv_shows['country'].value_counts()).reset_index()\n\n# merging the tv_vals dataframe with top10_countries dataframe on country names and renaming columns \ntop10_countries=top10_countries.merge(tv_vals, left_on='index', right_on='index', \\\n                                      how='inner').rename(columns={\"country\":\"TV_Shows\", \"index\":\"Country\"})\n\n# preparing the top10_countries dataframe for plotly funnel plot\ncountries = list(top10_countries['Country'])\n\ndf1 = pd.DataFrame(dict(count=top10_countries.Movies, Country=countries))\ndf1['Content type'] = 'Movies'\n\ndf2 = pd.DataFrame(dict(count=top10_countries.TV_Shows, Country=countries))\ndf2['Content type'] = 'TV Shows'\n\ndf = pd.concat([df1, df2], axis=0)\n\n# plotting the graph\nfig = px.funnel(df, x='count', y='Country', color='Content type', title=\"Countries with most content\")\nfig.show()","5acdb37d":"genre = list(all_data['listed_in'])\ngenres = []\n\nfor i in genre:\n    j = list(i.split(','))\n    for k in j:\n        genres.append(k.strip())\ngenre_count = dict(Counter(genres).most_common(15)) #get the top 15 genres \ngenre_count","fb68ab6d":"fig, ax = plt.subplots(figsize=(10,6), dpi=105)\nx=list(genre_count.keys())\ny=list(genre_count.values())\nax.vlines(x, ymin=0, ymax=y, color='blue', linestyle='dashdot')\nax.plot(x,y, \"o\", color='maroon', markersize=8)\nax.set_xticklabels(x, rotation = 90)\nax.set_ylabel(\"Count\")\nax.set_title(\"Count of shows by genre\")\nplt.show()","1571e14f":"plt.figure(figsize=(15,12))\nwc = WordCloud(width=1000, height=800, max_words=100, prefer_horizontal=0.7, min_font_size=8).generate(' '.join(genres))\nplt.imshow(wc)\nplt.axis('off')\nplt.show()","50ffc1fd":"def genre_tree_map(country):\n    \"\"\"\n    This function plots tree map depicting the count of titles by  genre for a chosen country\n    \"\"\"\n    tree=all_data[all_data['country']==country]\n    tree=tree.dropna()\n    import plotly.express as px\n    fig = px.treemap(tree, path=['country','type','listed_in'],\n                      color='listed_in', hover_data=['country','type','listed_in'])\n    return fig.show()","e071a6bd":"genre_tree_map('United States')","a80ddff5":"genre_tree_map('India')","5e8ff343":"def list_top_actors(country, num_actors):\n    \n    \"\"\"\n    This function returns a table with top num_actors of actors from a chosen country\n    \"\"\"\n    df = pd.DataFrame(all_data['cast'][all_data.country==country]).dropna()\n    top_actors = []\n    cast = list(df.cast)\n    for i in cast:\n        j = i.split(',')\n        for k in j:\n            top_actors.append(k.strip()) \n    top_actors = pd.DataFrame(Counter(top_actors).most_common(num_actors)).rename(columns={0:'Cast', 1:'Count'})\n    return top_actors","e95ab4e4":"indian_actors = list_top_actors('India', 15)\nus_actors = list_top_actors('United States',15)\nuk_actors = list_top_actors('United Kingdom',15)\n\n# plotting three bar graphs in one row \nfig, (ax1, ax2, ax3) = plt.subplots(1,3, figsize=(15,6))\nsns.barplot(x='Count', y='Cast', data=indian_actors, ax=ax1)\nax1.set_title('Indian actors')\nsns.barplot(x='Count', y='Cast', data=us_actors, ax=ax2)\nax2.set_title('US actors')\nsns.barplot(x='Count', y='Cast', data=uk_actors, ax=ax3)\nax3.set_title('UK actors')\nplt.tight_layout()\nplt.show()","54af9e80":"def list_top_directors(country, num_directors):\n    \"\"\"\n    This function returns a table with top num_directors of directors from chosen country\n    \"\"\"\n    df = pd.DataFrame(all_data['director'][all_data.country==country]).dropna()\n    top_directors = []\n    crew = list(df.director)\n    for i in crew:\n        j = i.split(',')\n        for k in j:\n            top_directors.append(k.strip()) \n    top_actors = pd.DataFrame(Counter(top_directors).most_common(num_directors)).rename(columns={0:'Crew', 1:'Count'})\n    return top_actors","2f3d43ea":"indian_directors = list_top_directors('India', 15)\nus_directors = list_top_directors('United States',15)\nuk_directors = list_top_directors('United Kingdom',15)\n\n# plotting three bar graphs in one row \nfig, (ax1, ax2, ax3) = plt.subplots(1,3, figsize=(15,6))\nsns.barplot(x='Count', y='Crew', data=indian_directors, ax=ax1)\nax1.set_title('Indian directors')\nsns.barplot(x='Count', y='Crew', data=us_directors, ax=ax2)\nax2.set_title('US directors')\nsns.barplot(x='Count', y='Crew', data=uk_directors, ax=ax3)\nax3.set_title('UK directors')\nplt.tight_layout()\nplt.show()","6a1b53cc":"new_movies = movies[['title', 'release_year', 'country']].sort_values(by='release_year', ascending=False).dropna().head(10)\nnew_movies","46a0ea9a":"new_shows = tv_shows[['title', 'release_year', 'country']].sort_values(by='release_year', ascending=False).dropna().head(10)\nnew_shows","2c1daf37":"df=all_data.fillna('') #fill all null values with empty string\n\n#selecting columns which will be used for computing similarity scores between movies\nfeatures=['title','director','cast','listed_in','description']\ndf=df[features]\n\ndf.head(2)","b391e3e5":"#convert all text into lowercase\ndef clean_data(x):\n        return str.lower(x)\n    \nfor feature in features:\n    df[feature] = df[feature].apply(clean_data)","f854ded1":"def bag_of_words(r):\n    return r['title']+ ' ' + r['director'] + ' ' + r['cast'] + ' ' +r['listed_in']+' '+ r['description']\n\ndf['bag_of_words'] = df.apply(bag_of_words, axis=1)","4e7bc966":"df.head(2)","725900f5":"count = CountVectorizer(stop_words='english')\n\ncount_matrix = count.fit_transform(df['bag_of_words'])\n\ncount_matrix","9e94fff7":"# compute cosine similarity matrix\ncosine_sim = cosine_similarity(count_matrix, count_matrix)","9fd45a19":"df=df.reset_index() \n\n#create a reference table to extract movies based on index value \nindices = pd.Series(df.index, index=df['title'])","a5a78fa9":"def get_movie_recommendations(title, cosine_sim=cosine_sim):\n    \n    \"\"\"\n    This function accepts a movie title, cosine_similarity matrix and returns 10 similar movies as recommendation\n    \"\"\"\n    \n    title=title.lower()\n    \n    if title not in all_data['title'].str.lower().to_list():\n        print (f'Sorry! {title.upper()} is not present in Netflix movie database')\n        \n    else:\n        idx = indices[title]\n\n        # Get the pairwsie similarity scores of all movies with that movie\n        sim_scores = list(enumerate(cosine_sim[idx]))\n\n        # Sort the movies based on the similarity scores\n        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n\n        # Get the scores of the 10 most similar movies\n        sim_scores = sim_scores[1:11]\n\n        # Get the movie indices\n        movie_indices = [i[0] for i in sim_scores]\n\n        # Return the top 10 most similar movies\n        recommended_movies = all_data['title'].iloc[movie_indices]\n\n        return print(f'Recommended movies based on your selection - {title.upper()}:\\n', recommended_movies)","c9d96878":"get_movie_recommendations('Die Another Day')","0e1d2bf0":"get_movie_recommendations('The Conjuring')","dacb4dad":"get_movie_recommendations('Lagaan')","5c13edbb":"get_movie_recommendations('The Dark Knight')","be4b11d1":"# 3. Growth trend","e7b61aff":"# 10. Which are the latest TV Shows?","b74f8273":"**Cosine Similarity**\n\nCosine similarity is the dot product of two vectors divided by the product of the magnitude of each vector. Here we are only interested in the angle between the vectors, so we normalize the data by dividing with magnitude.\nThe cosine of a 0 degree angle is 1, therefore the closer to 1 the cosine similarity is, the more similar the items are. ","204fc678":"Among the movies with high ratings, there are a couple of movies which released in 1970's. Let's see which are the oldest movies & TV shows available on Netflix","00a3f535":"**Actors with most shows on Netflix from India, US & UK**","eab7a696":"# Exploratory Data Analysis","e286d19f":"# Import necessary packages","5141bdb7":"There are broadly two types of recommender systems - collaborative filtering and content based recommender systems. \n* With collaborative filtering, unseen movies are recommended to users based on ratings provided by similar users who already watched those movies. With content based filtering, unseen movies are recommended to users based on the movies they watched before. \n* With collaborative filtering, a user may get recommendations in new genres based on content liked by similar users, whereas with content based filtering, a user gets recommendations mostly from genres in which he already liked movies. I will be developing a basic content based recommender system using the netflix dataset.\n\n<a href='https:\/\/www.linkpicture.com\/view.php?img=LPic5fb8c85a7af2a955064582'><img src='https:\/\/www.linkpicture.com\/q\/data-science-movie-recommendation-project.jpg' type='image'><\/a>","190a4113":"# Basic Recommender System","a5ad42e8":"Most of the content is added in the year 2019. Also in terms of months, it appears that maximum content is added towards the year end. ","0b3f6cde":"**Which are the top genres in India?**","26f9c9ab":"**Some oldest movies**","50f196d6":"# 5. Duration of movies and TV Shows","389a61f8":"# Test the Model","fe9a8f39":"Over the years, more Movies have been added in Netflix than TV shows. The peak for both these types of content was in 2019 - about 1550 for Movies and 800 for TV Shows. Growth of content on the platform started picking up rapidly from 2015. ","df6c8afb":"# 6. Which countries have a high share of contribution in terms of Content?","72e7b635":"Netflix is one of the fastest growing OTT platforms in the world today. It has acquired a big viewer base of movie and TV show lovers across the globe especially in the last decade. It is rather exciting to make use of data science techniques to gather insights about this entertainment giant.\n\nThe netflix dataset consists of TV shows and Movies available on Netflix as of 2019. There are 6234 rows, one row for each show and 12 columns listing the attributes as mentioned below. The data fields are as follows:\n* show_id: a unique id for each  show\n* type: Type of content - either movie or tv show\n* title: Title of the movie\/tv show\n* director: Director of the movie\/tv show\n* cast: Actors in the movie\/tv show\n* country: Country where the show is available\n* date_added: Date when the show was added on Netflix\n* release_year: Year of release of the movie\/tv show\n* rating: TV\/Movie rating for the show\n* duration: Duration of movie (in minutes)\/tv show (in seasons)\n* listed_in: Category in which the show is listed\n* description: A brief description of the plot","56260b96":"**Directors with most shows on Netflix from India, US & UK**","84cb05c7":"More than two-thirds of the content on Netflix consists of Movies","da5b4d92":"**Which are the low rated movies?**","5ecf4644":"Click on the right vertical bar to view tree map for TV Shows category","944a5de1":"**What if we want to see the top genres in a particular country?**","c0661a91":"# 9. Which are the latest movies in the database?","8533b6ab":"# Modeling\n\nNow the data is ready for modeling. The next step is to convert the text to numbers using CountVectorizer which returns a sparse matrix in which each row represents one table record and the columns denote tokenized words comprising the complete vocabulary.","986a3b84":"**Word Cloud for genres**","2a0eb890":"# Conclusion\n\n* This basic recommender system seems to be doing a decent job at recommending similar movies.\n* There is a major drawback with this model which is it will not work with any movie title which is not present in the dataset or if the spelling does not match. \n* To overcome this issue, we can provide the users with a list of available titles to get the recommendations. ","2d9bd3e3":"# 4. Movie & TV Show rating analysis","b17c5032":"**Which are the top genres by count of shows?**","f16e0101":"# 8. Analysis of Cast & Crew","baaa3204":"# 7. Genre Analysis","04c00f8c":"In the next step, I will concatenate text in all the selected columns to get a single group of words. This group will be used to convert text to tokens and to compute a cosine similarity matrix later.","7a9d79f1":"**Top genres in The United States**","7a5df92a":"# Load data","f16e1fdf":"Let's test the model with some movie names","cd1e339a":"# Data Cleaning & Preparation\n\nThe key idea behind the recommender system is to find the similarity between two movies (or any entites in general) with the help of a similarity score. Therefore the text data first needs to be converted to numbers with the help of NLP tools. But before that the data needs to be cleaned.","428d6f67":"# 2. When was the content added during the observation period: 2008 - 2020?","c86e502d":"Besides the IMDB ratings, there are general TV show and film rating systems.\n\nTelevision rating systems are meant to evaluate the content and report the suitability of television programs for children, teenagers, or adults. Many countries have their own television rating system and countries' rating processes vary by local priorities. Some of the ratings are: \n* TV-MA: These programs are intended to be viewed by mature, adult audiences and may be unsuitable for children under 17\n* TV-14; This program may be unsuitable for children under 14 years of age\n* TV-G: This program is suitable for all ages\nand so on.\n\nSimilarly for movies:\n\n* PG-13: Some material may be inappropriate for children under 13\n* NC-17: Adults only etc","4fea6782":"![image.png](attachment:image.png)","f95babc8":"# 1. Netflix content type","72741365":"**Some oldest TV Shows**","d03c116b":"There are 6234 records in our data and the vocabulary size is 42956. The matrix has 215337 non-zero values.","5d514edd":"As already mentioned, this data offers scope for doing some interesting analysis on movies and tv shows on Netflix and this would be my major focus in this notebook. To make this more interesting, I would integrate this dataset with IMDB ratings to carry out rating related analysis. I will also build a simple movie recommender system using NLP to get 10 movie recommendations based on a selected movie. This notebook contains\n1. Loading the necessary packages and dataset\n2. Exploratory Data Analysis\n3. Data Cleaning & Preparation\n4. Building a Basic Recommender system\n5. Testing the system\n6. Conclusion\n","42d6122d":"**Movies with highest & lowest IMDB ratings**\n\nAs IMDB ratings are not readily available in netflix dataset, I'll be merging two separate IMDB datasets in order to get the ratings for the movies listed in netflix. ","6ba2a912":"**Plotting count of shows by genre**","11d812aa":"**Count of TV Shows by number of seasons**","99ea7f49":"<img src=\"https:\/\/media.giphy.com\/media\/wG4p10gt7UqmOzGkMe\/giphy.gif\">"}}