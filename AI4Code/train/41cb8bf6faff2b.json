{"cell_type":{"3f21d95c":"code","5a910a53":"code","d0404dfa":"code","f459b0ec":"code","6cc97af6":"code","dae513cc":"code","23a8b42d":"code","8bdf0baf":"code","efffd7dc":"code","3b97013f":"code","b4d20ef9":"code","20f554f4":"code","4b407066":"code","a4cc39ce":"code","6c82b2ac":"code","6ff3c5f0":"code","0502d65f":"code","8ac9f4df":"code","abbdd212":"code","08388dd9":"code","57948c1a":"code","28b17d42":"code","f202fef2":"code","b0a56649":"code","0e514469":"code","166917a5":"code","c43f7aca":"code","3093042f":"code","c6a6e770":"markdown","6e3f0a86":"markdown","fdacdb0b":"markdown","fd6eb04e":"markdown","bc10cf75":"markdown","7aee96ae":"markdown","56fa2391":"markdown","177b53e4":"markdown","01d1148a":"markdown","4c69b4e2":"markdown","3b72871b":"markdown","7d00302d":"markdown","2d6dff7c":"markdown","244eac21":"markdown","b2d75c34":"markdown","89ba7275":"markdown","a20157c8":"markdown","ca1025c5":"markdown"},"source":{"3f21d95c":"import numpy as np \nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n#import os\n#for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#    for filename in filenames:\n#        print(os.path.join(dirname, filename))","5a910a53":"apps_df = pd.read_csv('..\/input\/google-play-store-apps\/googleplaystore.csv')\nreviews_df = pd.read_csv('..\/input\/google-play-store-apps\/googleplaystore_user_reviews.csv')\napps_df.info()","d0404dfa":"print('Duplicate rows: ', apps_df.duplicated().sum())\napps_df.drop_duplicates(inplace = True)\nprint('Duplicate rows after drop: ', apps_df.duplicated().sum())\n","f459b0ec":"apps_df.isnull().sum()","6cc97af6":"#Remove all rows with null rating data. It is essential for a row to have Rating data and other NaN values are few, so they won't be imputed\napps_df.dropna(inplace=True)\napps_df.isnull().sum()","dae513cc":"apps_df['Category'].unique()","23a8b42d":"apps_df['Rating'].unique()","8bdf0baf":"apps_df['Reviews'].unique()","efffd7dc":"#Convert number of reviews to integer\napps_df['Reviews'] = pd.to_numeric(apps_df['Reviews'])","3b97013f":"apps_df['Size'].unique()","b4d20ef9":"#Convert all to kilobytes\napps_df['Size'] = apps_df.Size.replace(\"Varies with device\",np.nan)\napps_df['Size'] = apps_df.Size.str.replace(\"M\",\"000\")\napps_df['Size'] = apps_df.Size.str.replace(\"k\",\"\")\napps_df['Size'] =apps_df['Size'].astype(float)\napps_df['Reviews'] = pd.to_numeric(apps_df['Reviews'])\napps_df['Size'].dtypes","20f554f4":"apps_df['Installs'] = apps_df.Installs.str.replace(\",\",\"\", regex = True)\napps_df['Installs'] = apps_df.Installs.str.replace(\"+\",\"\", regex = True)\napps_df['Installs'] = pd.to_numeric(apps_df['Installs'])\napps_df['Installs'].unique()","4b407066":"apps_df['Price'].unique()","a4cc39ce":"apps_df['Price'] = apps_df.Price.str.replace('$','', regex = True)\napps_df['Price'] = pd.to_numeric(apps_df['Price'])","6c82b2ac":"#Check for NaN values raised by errors in the above cleaning\napps_df.isnull().sum()","6ff3c5f0":"#Remove all rows with null rating data\napps_df.dropna(inplace=True)\napps_df.isnull().sum()","0502d65f":"sns.kdeplot(x=apps_df['Rating'], fill = True)\nplt.title('Distribution of Ratings', fontdict = {'fontsize':16, 'fontweight': 'bold'})\n\napps_df['Rating'].describe()","8ac9f4df":"plt.figure(figsize = (6,6))\nsns.heatmap(apps_df.corr(), annot = True, cmap = 'Greens')","abbdd212":"plt.figure(figsize=(14,6))\nsns.set_style('whitegrid')\nsns.histplot(data=apps_df, x='Rating', hue='Type', hue_order = ['Free', 'Paid'], bins=25, stat = 'probability',\n             common_norm=False, kde=True, alpha=0.7)\nplt.title('Free App Rating vs. Paid App Rating', fontdict = {'fontsize':16, 'fontweight': 'bold'})","08388dd9":"# Sorting\norder = apps_df.groupby('Category').count().sort_values('App', ascending=False).index\n\n\n#bar plot\nplt.figure(figsize=(16,8))\nplt.title('App Rating by Category', fontdict = {'fontsize':16, 'fontweight': 'bold'})\nplt.xticks(rotation = 85)\nsns.set_style('whitegrid')\nsns.countplot(data=apps_df, x='Category', order=order)","57948c1a":"#sorting\norder = apps_df.groupby('Category')['Rating'].median().sort_values(ascending=False).index\n\n#plot\nplt.figure(figsize=(16,8))\nplt.title('App Rating by Category', fontdict = {'fontsize':16, 'fontweight': 'bold'})\nplt.xticks(rotation = 85)\nsns.set_style('whitegrid')\nsns.boxplot(data=apps_df, x='Category', y='Rating', order = order, fliersize = 4)\n\n","28b17d42":"#sorting\norder = apps_df.groupby('Content Rating')['Rating'].median().sort_values(ascending=False).index\n\n#plot\nplt.figure(figsize=(6,8))\nplt.title('App Rating by Content Rating', fontdict = {'fontsize':16, 'fontweight': 'bold'})\nplt.xticks(rotation = 85)\nsns.set_style('whitegrid')\nsns.boxplot(data=apps_df, x='Content Rating', y='Rating', fliersize = 4, order = order)","f202fef2":"apps_df.drop(['App', 'Last Updated', 'Android Ver', 'Current Ver', 'Type'], axis=1, inplace=True)","b0a56649":"apps_df = pd.concat([apps_df, pd.get_dummies(apps_df['Category'], drop_first = True)], axis = 1)\napps_df.drop('Category', axis = 1, inplace = True)\n\napps_df = pd.concat([apps_df, pd.get_dummies(apps_df['Content Rating'], drop_first = True)], axis = 1)\napps_df.drop('Content Rating', axis = 1, inplace = True)","0e514469":"# Identify all unique genres\n\nall_genres = set()\n\nfor index, row in apps_df.iterrows():\n    app_genres = row[5].split(';')\n    \n    for genre in app_genres:\n        all_genres.add(genre)\n        \n\n# Concat dummy variables for every genre, with a default of 0\n\nall_genres = pd.Series(list(all_genres))\n\nfor genre in all_genres:\n    apps_df[genre] = 0\n\n# Change genre column value to 1 if the app is labeled as that genre\n\nfor index, row in apps_df.iterrows():\n    app_genres = row[5].split(';')\n    \n    for genre in app_genres:\n        apps_df.at[index, genre] = 1\n        \n        \n# Drop original Genres column\n\napps_df.drop('Genres', axis=1, inplace = True)","166917a5":"from sklearn.ensemble import RandomForestRegressor\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error\nfrom sklearn.model_selection import train_test_split\n\n# Split Data\nX = apps_df.drop('Rating', axis = 1)\ny = apps_df['Rating']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=101)\n\n# Create Model & Predict\nrfr = RandomForestRegressor(n_estimators=200)\nrfr.fit(X_train, y_train)\npredictions = rfr.predict(X_test)","c43f7aca":"plt.figure(figsize = (8,7))\nsns.scatterplot(x=y_test, y=predictions)\nplt.ylabel('RFR Prediction')\nplt.xlabel('Actual')\nplt.title('Actual Rating vs. RFR Predictioned Rating', fontdict = {'fontsize':12, 'fontweight': 'bold'})\n\nplt.figure(figsize = (10,7))\nsns.displot(predictions - y_test)\nplt.ylabel('Count')\nplt.xlabel('Prediction - Actual')\nplt.title('Prediction Error', fontdict = {'fontsize':12, 'fontweight': 'bold'})","3093042f":"print('Mean Absolute Error: ', mean_absolute_error(y_test, predictions))\nprint('Root Mean Squared Error: ', np.sqrt(mean_squared_error(y_test, predictions)))","c6a6e770":"**Installs**","6e3f0a86":"Remove 'App' column due to irrelevancy. The app name may have an impact based on inclusion of buzz words or trending topics, but that is quite the complicated calculation.\n\nApp versions and last updated may impact ratings. For example, apps that have been updated had the time and opportunity to make improvements based on reviews. Nonetheless, we will not include this data in our predictions. If we are predicting the rating of a new app, it cannot begin at any version other than '1'\n\nType is also removed because 'Free' and 'Paid' information is already communicated in the 'Price' column ","fdacdb0b":"**Price**","fd6eb04e":"**Null Values**","bc10cf75":"# **4. Predict App Ratings**","7aee96ae":"**Observation:** Price was previously shown to be negatively correlated with rating, but here we see that Paid apps are more positively skewed in rating than Free apps. Therefore, Paid apps are generally rated higher, but ratings decrease as cost increases. This is perhaps due to higher expectations from the customer as the cost increases.","56fa2391":"# **1. Describe Data**\n\n\nThe objective of the following  work is to accurately predict the rating of an app","177b53e4":"**Category**","01d1148a":"**Duplicates**","4c69b4e2":"# **3. Exploratory Data Analysis**","3b72871b":"**Observation:** There is only light correlation between rating and the quantitative values listed above. Let's now explore relationships between qualitative values","7d00302d":"# **2. Clean Data**","2d6dff7c":"Random Forest Regression","244eac21":"Many apps have multiple genres listed. pd.get_dummies() would provide dummy variables for all combinations of genres, such as'Art & Design, Creativity.' Instead, we want dummy variables for each *individual* genre. The following lines achieve this.","b2d75c34":"**Null Values** (again)","89ba7275":"**Rating**","a20157c8":"**Size**","ca1025c5":"**Reviews**"}}