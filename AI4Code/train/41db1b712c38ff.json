{"cell_type":{"0118cdd1":"code","1bbec95e":"code","9ff41b4e":"code","954de6d1":"markdown"},"source":{"0118cdd1":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport random\nimport json\n\nimport os","1bbec95e":"# NOTE something to create an more skewed split could be created by not splitting uniformly. \n\ndef split_one_class_uniform(groups, folds, n_folds=3):\n    \"\"\" Generates folds for one class\n    \"\"\"\n    if len(folds) != n_folds:\n        raise ValueError('number of folds provided does not match n_folds argument')\n        \n    # shuffle groups\n    random.shuffle(groups)\n    while True:\n        if len(groups) <= 0:\n            break\n            \n        # there are enough groups left to add one to each fold\n        elif len(groups) >= n_folds:\n            for i in range(n_folds):\n                folds[i].append(groups.pop())\n        # we have more then 0 groups, but not enough to add to each fold\n        # randomly assign remaining groups to folds\n        else:\n            # select random fold to contain remaining\n            rand_nums = random.sample(range(len(groups)), len(groups)) \n            for i in rand_nums:\n                folds[i].append(groups.pop())\n    return folds\n\ndef create_cv_split(y_tr, n_folds=4):\n    \"\"\" splits data in n_folds for cv\n    \"\"\"\n    group_dict =  dict()\n    for (gid, g) in y_tr.groupby(['surface']):\n        group_dict[gid] = g['group_id'].unique().tolist()\n\n    folds = [[] for x in range(n_folds)]\n\n    for key, value in group_dict.items():\n        folds = split_one_class_uniform(value, folds, n_folds)\n        \n    return folds\n\ndef load_data():\n    x_tr = pd.read_csv('..\/input\/X_train.csv', index_col=0)\n    x_ts = pd.read_csv('..\/input\/X_test.csv', index_col=0)\n    y_tr = pd.read_csv('..\/input\/y_train.csv', index_col=0)\n\n    # remove hard_tile from data \n    # TODO something more intelligent then this.\n    # reasoning here: there is a lot of things to improve besides differentiating these classes\n    # ignore extra class initially and be ok with 0.06 auto penelty on leaderboard\n    # later try to differentiate hard_tile, from hard_tiles_large_space\n    y_tr['surface'] = y_tr['surface'].replace('hard_tiles', 'hard_tiles_large_space')\n    return x_tr, x_ts, y_tr\n","9ff41b4e":"x_tr, x_ts, y_tr = load_data()\n\n# lets create 5 random splits, and keep them for later\n# using same splits allows for consistant comparison between models\n# currently not setting seed so these are different each time this is run. \nfor i in range(5):\n    folds = create_cv_split(y_tr)\n    with open('splits{}.json'.format(i), 'w') as f:\n        json.dump(folds, f)","954de6d1":"Some cv split generating code. version 1, so simple(and maybe hidden bug). removed class `hard_tile` later something better should be done.\n\nNote that if you create n_fold=6(as example), some folds won't have all the classes. using 4fold because all folds have all classes that way. This is simple but likely other ways."}}