{"cell_type":{"a55da240":"code","ec65892e":"code","a4c0a201":"code","ecee9f86":"code","8d2c9f84":"code","652f15fb":"code","93d10891":"code","a6e2bb57":"code","51d87b80":"code","69642786":"code","144de9a3":"code","05c01219":"code","2ab21e43":"code","94438fb7":"code","8787dc4a":"code","ecae7cc0":"code","517e16b7":"code","3429a954":"code","7637c04c":"code","7c409ea1":"code","b2c90ec8":"code","fc9d6738":"code","e605a8f2":"code","4ebdf155":"code","6aea3268":"code","0c919054":"code","a59c2f7c":"code","443fad29":"code","2516d827":"code","08a95636":"code","8441918b":"code","cd558e82":"code","35e6b50a":"code","caa61085":"code","5a210d3d":"code","4d0c17c6":"code","0eec9448":"code","e76e86c6":"code","d83f08b1":"code","6c07d703":"code","7ed13789":"code","22d97298":"code","9e08f96d":"code","f714e38b":"code","95524376":"code","62b44456":"code","db8df75e":"code","99b74a91":"code","a64ecce2":"code","97448a88":"code","12a5c885":"code","746589d5":"code","f9ffedae":"code","f210c35d":"code","0ff364fd":"markdown","13d3e850":"markdown","c9fa566f":"markdown","0460bc57":"markdown","928233ef":"markdown","784a130b":"markdown","f085e8aa":"markdown","fc9b486e":"markdown","022580ea":"markdown","b2184816":"markdown","e7315aa3":"markdown","00961d73":"markdown","a1bfc0ed":"markdown","0c24849f":"markdown","3ff82a34":"markdown","3d864ea7":"markdown","97e5b9aa":"markdown","5a09a9f0":"markdown","8c61b5e2":"markdown","69eb16f4":"markdown","a3427efc":"markdown","09738d77":"markdown","5750296b":"markdown","02f909e8":"markdown","21070f7f":"markdown","9fdb3611":"markdown","ad0549bc":"markdown","c09ea496":"markdown","a15392fe":"markdown","30603288":"markdown","bcebf187":"markdown","e68f6a91":"markdown","1c25b340":"markdown","8b2adbf7":"markdown","6c522bea":"markdown","788413e8":"markdown","b2761498":"markdown","a1688a53":"markdown","622613ec":"markdown","6bc16459":"markdown","52ec592d":"markdown","2d36f7dd":"markdown","b5f4c157":"markdown","d599a1ac":"markdown","f8ffc12a":"markdown","e4b539f3":"markdown","4a7ee05a":"markdown","cb6a3dd5":"markdown","f5150f6b":"markdown","66da5478":"markdown","22178537":"markdown","57bcb89c":"markdown","bd987a0d":"markdown","c8406fa7":"markdown","5566853e":"markdown","226a8cd4":"markdown","3688e08f":"markdown","bb83edaa":"markdown","7f257e06":"markdown","a963a7f6":"markdown","17592731":"markdown","8ed40c78":"markdown","6220e42a":"markdown","2f66e994":"markdown","f3610785":"markdown","a7772d96":"markdown","0f4ba9c9":"markdown","a2f04085":"markdown","9694cc16":"markdown","4aa5f32f":"markdown","b8c9a5f4":"markdown","f00eb637":"markdown","d7013d59":"markdown"},"source":{"a55da240":"import sys\nimport numpy as np","ec65892e":"mb = 1024 * 1024\n\npython_list = list(range(0, 1000000))\nnumpy_array = np.array(range(0, 1000000))\n\nprint(\"Python list size: {0:.3f} MB\".format(sys.getsizeof(python_list) \/ mb))\nprint(\"Numpy array size: {0:.3f} MB\".format(numpy_array.nbytes \/ mb, \"MB\"))\nprint(\"ArraySize\/ListSize ratio: {0:.2f}\".format(numpy_array.nbytes \/ sys.getsizeof(python_list)))","a4c0a201":"mixed_list = [1, 2, 3, 4.0, 5.0, 'abc', 'def', True, False]","ecee9f86":"np_array_mixed = np.array([i if i % 2 == 0 else str(i) for i in range(0, 1000000)])\nnp_array_mixed_size = np_array_mixed.nbytes\nprint(\"Mixed numpy array size:\", np_array_mixed_size \/ mb, \"MB\")","8d2c9f84":"np_array_str = np.array([str(i) for i in range(0, 1000000)])\nnp_array_str_size = np_array_str.nbytes\nprint(\"Strings-only numpy array size:\", np_array_str_size \/ mb, \"MB\")","652f15fb":"print('String array contains type:', np_array_str.dtype)\nprint('\"Mixed\" array contains type:', np_array_mixed.dtype)\nprint('\"Mixed\" array elements:\"', np_array_mixed[:6])","93d10891":"nums_list = list(range(1, 10000000))\nnumpy_nums = np.array(nums_list)","a6e2bb57":"%%time\nreciprocal_list = []\nfor num in nums_list:\n    reciprocal_list.append(1 \/ num)","51d87b80":"%%time\nreciprocal_list = [1 \/ num for num in nums_list]","69642786":"%%time\nreciprocal_array = 1 \/ numpy_nums","144de9a3":"%%time \nnums_list = list(range(1, 10000000))","05c01219":"%%time\nnumpy_nums = np.array(nums_list)","2ab21e43":"%%time\nnumpy_nums = np.array(range(1, 10000000))","94438fb7":"%%time\nnumpy_nums = np.arange(1, 10000000)","8787dc4a":"%%time\nreciprocal_array = 1 \/ numpy_nums","ecae7cc0":"%%time\npoint = [1.0, 1.0]\nother_points = list([float(x), x + 1.0] for x in range(10000000))\ndists = [((point[0] - op[0])**2 + (point[1] - op[1])**2)**0.5 for op in other_points]","517e16b7":"dists[:10]","3429a954":"%%time\nnp_point = np.ones(2)\nnp_other_points = np.vstack([np.arange(0.0, 10000000.0), np.arange(1.0, 10000001.0)]).T\nnp_dists = np.sum((np_point - np_other_points)**2, axis=1)**0.5","7637c04c":"np_dists[:10]","7c409ea1":"M = np.ones((3, 3))\nprint(\"M:\")\nprint(M)\n\nscalar = 2\nM_added = M + scalar\n\nprint()\nprint(\"M +\", scalar, \":\")\nprint(M_added)","b2c90ec8":"M = np.ones((3, 3))\nprint(M)\n\nv = np.array([0, 1, 2])\nprint()\nprint(v)\n\nM_added = M + v\nprint()\nprint(M_added)","fc9d6738":"a = np.arange(3)\nb = np.arange(3)[:, np.newaxis]\n\nprint(\"a:\", a)\nprint(\"b:\\n\", b)\n\nsummed = a + b\nprint(\"\\nSummed:\")\nprint(summed)","e605a8f2":"M = np.ones((2, 3))\na = np.arange(3)\nprint(\"M:\", M.shape)\nprint(M)\nprint()\nprint(\"a:\", a.shape)\nprint(a)","4ebdf155":"M + a","6aea3268":"a = np.arange(3).reshape((3, 1))\nb = np.arange(3)\n\nprint(\"a:\", a.shape)\nprint(a)\nprint()\nprint(\"b:\", b.shape)\nprint(b)","0c919054":"a + b","a59c2f7c":"M = np.ones((3, 2))\nprint(\"M:\", M.shape)\nprint(M)\nprint()\n\na = np.arange(3)\nprint(\"a:\", a.shape)\nprint(a)\nprint()","443fad29":"M + a","2516d827":"a = a[:, np.newaxis]\n\nprint(\"a:\", a.shape)\nprint(a)\nprint()","08a95636":"M + a","8441918b":"np.newaxis is None","cd558e82":"arr = np.arange(3)\narr.shape","35e6b50a":"row_vec = arr[np.newaxis, :]\nprint(row_vec.shape)\nprint(row_vec)","caa61085":"col_vec = arr[:, np.newaxis]\nprint(col_vec.shape)\nprint(col_vec)","5a210d3d":"M = np.ones((5, 5))","4d0c17c6":"M[np.newaxis, :, :, np.newaxis, np.newaxis].shape","0eec9448":"M[np.newaxis, ..., np.newaxis, np.newaxis].shape","e76e86c6":"M.reshape(1, -1, -1, 1, 1 ).shape","d83f08b1":"M.reshape(1, *M.shape, 1, 1 ).shape","6c07d703":"A = np.full((2, 2), 2)\nprint(\"A:\")\nprint(A)\nprint()\n\nB = np.full((2, 2), 3)\nprint(\"B:\")\nprint(B)\nprint()\n\nprint(\"A*B:\")\nprint(A*B)","7ed13789":"A = np.arange(1, 10).reshape(3,3)\nprint(\"A:\")\nprint(A)\nprint()\n\nB = np.full((3,), 3)\nprint(\"B:\")\nprint(B)\nprint()\n\nprint(\"A*B:\")\nprint(A*B)\n\nprint()\nprint(\"A@B:\")\nprint(A@B)","22d97298":"import matplotlib.pyplot as plt\nfrom matplotlib import cm\n\nxvalues = np.arange(-1, 1.05, 0.5)\nyvalues = np.arange(-1, 1.05, 0.5)\n\nxx, yy = np.meshgrid(xvalues, yvalues)\nprint(xx)\nprint()\nprint(yy)\ngrid = plt.plot(xx, yy, marker='.', color='k', linestyle='none')","9e08f96d":"x = np.arange(-8, 8, 0.01)\ny = np.arange(-8, 8, 0.01)\nxx, yy = np.meshgrid(x, y, sparse=True)\nz = np.sin(xx**2 + yy**2) \/ (xx**2 + yy**2)\n\nh = plt.contourf(x,y,z, cmap=cm.PuBu_r)","f714e38b":"from mpl_toolkits.mplot3d import Axes3D\n\nfig = plt.figure(figsize=(10, 8))\nax = fig.gca(projection='3d')\nax.view_init(60, 35)\n\n# Make data.\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\n# Plot the surface.\nsurf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm, linewidth=0, antialiased=False)","95524376":"%matplotlib inline\nimport matplotlib.pyplot as plt\nimport seaborn; seaborn.set()\n\nrand = np.random.RandomState(42)\nX = rand.rand(10, 2)\nplt.scatter(X[:, 0], X[:, 1], s=100);","62b44456":" dist_sq = np.sum((X[:, np.newaxis, :] - X[np.newaxis, :, :]) ** 2, axis=-1)","db8df75e":"dist_sq.diagonal()","99b74a91":"nearests = np.argsort(dist_sq, axis=1)\nprint(nearests)","a64ecce2":"K = 2\nnearest_partition = np.argpartition(dist_sq, K + 1, axis=1)\nprint(nearest_partition[:, :K+1])","97448a88":"cmap = plt.get_cmap('viridis')\ncolors = cmap(np.linspace(0, 1, 10))\nplt.scatter(X[:, 0], X[:, 1], s=150, color=colors)\n\n# draw lines from each point to its two nearest neighbors\nK = 2\n\nfor i in range(X.shape[0]):\n    for j in nearest_partition[i, :K+1]:\n        # plot a line from X[i] to X[j]\n        # the lines colors correspond to outgoing point color, but some lines obviously overlap\n        # using some zip magic:\n        plt.plot(*zip(X[j], X[i]), c=colors[i])","12a5c885":"def iterate(Z):\n    # Count neighbours\n    N = (Z[0:-2,0:-2] + Z[0:-2,1:-1] + Z[0:-2,2:] +\n         Z[1:-1,0:-2]                + Z[1:-1,2:] +\n         Z[2:  ,0:-2] + Z[2:  ,1:-1] + Z[2:  ,2:])\n\n    # Apply rules\n    birth = (N==3) & (Z[1:-1,1:-1]==0)\n    survive = ((N==2) | (N==3)) & (Z[1:-1,1:-1]==1)\n    Z[...] = 0\n    Z[1:-1,1:-1][birth | survive] = 1\n    return Z","746589d5":"import matplotlib.pyplot as plt\nimport numpy as np\n%matplotlib notebook\nplt.ion()\n\n#initialize game field\nZ = np.random.choice([0,1],size=(100,100))\n\nfig = plt.figure()\nax = fig.add_subplot(111)\nfig.show()\n\nfor _ in range(1000):    \n    #update\n    Z = iterate(Z)\n    \n    #re-draw image\n    ax.clear()\n    ax.imshow(Z,cmap='gray')\n    fig.canvas.draw()","f9ffedae":"filters = np.array([[1,1,1],\n                    [1,0,1],\n                    [1,1,1]])","f210c35d":"from scipy import signal\n\nZ = np.random.choice([0,1],size=(10,10))\n\nN1 = (Z[0:-2,0:-2] + Z[0:-2,1:-1] + Z[0:-2,2:] +\n      Z[1:-1,0:-2]                + Z[1:-1,2:] +\n      Z[2:  ,0:-2] + Z[2:  ,1:-1] + Z[2:  ,2:]) \n\nN2 = signal.convolve2d(Z, filters, mode='valid')\n\nprint(\"Are N1 and N2 identical?\")\nprint(np.array_equal(N1, N2))","0ff364fd":"The shape of a is pad on the left, as it has fewer dimensions:<br>\n    M.shape -> (2, 3)<br>\n    a.shape -> (1, 3)<br><br>\nThe the 1-dimension of a is stretched to match M:<br>\n    M.shape -> (2, 3)<br>\n    a.shape -> (2, 3)<br>\n\nNow the shapes match and matrixes can be summed:","13d3e850":"Matrixes shape does not match, the error is raised when trying to perform operations with them:","c9fa566f":"There was a sample above, that counts distances from a single point to set of others. But if it is needed to find the closest points for each point in the set, that can be performed this way:","0460bc57":"<center>\n<img src=\"https:\/\/nbviewer.jupyter.org\/github\/prickly-u\/mlcourse.ai\/blob\/master\/img\/ods_stickers.jpg\" \/>\n    \n## [mlcourse.ai](https:\/\/mlcourse.ai) \u2013 Open Machine Learning Course \n### <center> Author: Kseniia Terekhova, ODS Slack Kseniia\n    \n## <center> Tutorial\n## <center> A little more info about NumPy","928233ef":"So, just a convenient alias. The <i>np.newaxis<\/i> constant is useful when converting a 1D array into a row vector or a column vector, by adding new dimensions from left or right side:","784a130b":"What it takes to implement this game using NumPy arrays? It's tricky, but not so long:","f085e8aa":"In a more complex case the both matrixes are broadcasted:","fc9b486e":"### 3. What is np.newaxis?","022580ea":"While NumPy contains data in a continious area in memory, a Python list stores only pointers to the real data. And yes, not only \"list in Python is more than just list\" but also \"an integer in Python is more than just integer\". ","b2184816":"It is not only convenient API that makes NumPy so useful for scientific purposes, but also its performance characteristics. Python is not the most quick and memory-economical language. When you are often getting MemoryError while working with large ML datasets it does not look as a minor disadvantage.<br>\nLet's first compare amounts of bytes taken by standard Python list and identical NumPy array. ","e7315aa3":"That's what happens when both arrays need to be broadcasted:","00961d73":"### 6. Some interesting samples","a1bfc0ed":"This will work:","0c24849f":"That allows to make a conclusion that NumPy was designed for high performance computing over large blocks of same-type numbers. Let's try to compare such computations made with NumPy and with Python intrinsics on the example of calculating reciprocals (1\/x) of ten million integers. ","3ff82a34":"#### 6.2 Conway's Game of Life","3d864ea7":"M.shape -> (3, 2) <br>\na.shape -> (1, 3) <br>\n<br>\nM.shape -> (3, 2)<br>\na.shape -> (3, 3)<br>","97e5b9aa":"The possible solution in such situation is padding \"a\" with 1 dimention in the <i>right<\/i> manually. This way the Rule 1 will be skipped and according to the Rule 2 NumPy will just expand matrix to the needed size: ","5a09a9f0":"<p>One of the things that should be noticed about the example above is that it handles matrixes with different dimensions. The np_point has shape (2,) and np_other_points - (10000000, 2). Nevertheless, element-wise operations are performed with them, producing a matrix with shape (10000000,). That is possible by the virtue of <b><i>matrix broadcasting<\/i><\/b> mechanism.<\/p>\n<p>Matrix broadcasting in NumPy is a set of rules that allowes to expand two matrixes with different dimentions to  match shapes of each other, in order to perform element-by-element operations. What is important, this set of rules is a  \"virtual\" mechanism, that just allows to understand how matrixes will interact. No real expansion and memory allocation is performed.<\/p>\n<p>Its simplest case is summing a matrix with a scalar number, that will be added to each element of the matrix:<\/p>","8c61b5e2":"Nevertheless, the first time I've saw its usage was in the <a href=\"https:\/\/towardsdatascience.com\/convnets-series-spatial-transformer-networks-cff47565ae81\" target=__blank>article<\/a> about Spatial Transformer Networks, on the step with \"Identity meshgrid\" and \"Transformed meshgrid\". So, it can be a useful stuff. <br>\nActually, this function just creates a set of grids with coordinates of x, y, etc. on the corresponding grid locations. ","69eb16f4":"To be honest, there was a small deceit. The amounts of time spent creating list and array were not measured. They are different:","a3427efc":"But when speaking about matrix multiplication, especially in linear algebra (and ML) another operation is often implied, the <i>matrix product<\/i>, that is defined this way (formula from <a href=\"https:\/\/en.wikipedia.org\/wiki\/Matrix_multiplication#Definition\" target=__blank>wikipedia<\/a>):","09738d77":"The results are the same, but the performance advantage is significant.","5750296b":" Adding several new dimensions is useful in ML when working with, for example, convolutional neural networks. Such frameworks as <b>Pytorch<\/b> allows to initialize its \"Tensors\" <a href=\"https:\/\/pytorch.org\/docs\/master\/torch.html#torch.from_numpy\">from numpy arrays<\/a>, but often requires input in the form \"minibatch \u00d7 in_channels \u00d7 iW\" or \"minibatch \u00d7 in_channels \u00d7 iH \u00d7 iW\" (<a href=\"https:\/\/pytorch.org\/docs\/master\/nn.html#torch-nn-functional\" target=__blank>torch.nn.functional<\/a>). There, minibatch and in_channels can be equal to 1, but they must be  present. ","02f909e8":"#### 6.3 Convolutional layers in Convolutional Neural Networks","21070f7f":"<center>\n<img src=\"https:\/\/nbviewer.jupyter.org\/github\/prickly-u\/mlcourse.ai\/blob\/master\/img\/convolution.png\" style=\"width: 600px;\" \/>","9fdb3611":"Neural networks usually offers such operation as a ready functionality (<a href=\"https:\/\/pytorch.org\/docs\/master\/nn.html#torch-nn-functional\" target=__blank>Pytorch for example<\/a>). And even scipy model has such a <a href=\"https:\/\/docs.scipy.org\/doc\/scipy\/reference\/generated\/scipy.signal.convolve2d.html\" target=__blank>function<\/a>. <br>\nLet's see if it indeed does the same thing:","ad0549bc":"Of course, summing is not the only operation that can be applied to matrixes; a number of arithmetic operations can be used, along with several \u201cuniversal functions\u201d. The operation that I would like to pay some attention is multiplication, i.e. '*'. As other arithmetic operations, in NumPy it is applied elementwise:","c09ea496":"Much more better!","a15392fe":"Here, adding newaxis allows to convert the X matrix with shape (10, 2) into two matrices (10, 1, 2) and (1, 10, 2), that have ten 2D-points in rows and cols correspondingly; then, the broadcasting allows to calculate difference between coordinates of points on the i-th row and j-th column; then square and sum operations give squared euclidean distance between those points. <br>\nThe dist_qs matrix has zeros on its diagonal, that proves calculation correctness. Distance between ii element is distance between i-th point and itself; that is zero.","30603288":"In fact it is similar to <i>np.reshape(-1, 1)<\/i> and <i>np.reshape(1, -1)<\/i> down to minor implementation details. But the np.newaxis allows to stack dimentions using slice syntax, without specifying original shape: ","bcebf187":"but doesn't it look a little bit clumsy?","e68f6a91":"And lastly a few examples that shows how NumPy allows to write short and elegant code for computational and ML-related tasks.","1c25b340":"### 3. NumPy matrix broadcasting","8b2adbf7":"$$ A = \\begin{pmatrix} a_{11}, a_{12} & \\cdots & a_{1m}\\\\a_{21}, a_{22} & \\cdots & a_{2m} \\\\ \\vdots & \\ddots & \\vdots \\\\ a_{n1}, a_{n2} & \\cdots & a_{nm} \\end{pmatrix},  B = \\begin{pmatrix} b_{11}, b_{12} & \\cdots & b_{1p}\\\\b_{21}, b_{22} & \\cdots & b_{2p} \\\\ \\vdots & \\ddots & \\vdots \\\\ b_{m1}, b_{m2} & \\cdots & b_{mp} \\end{pmatrix} $$\nMatrix product <b>C<\/b> = <b>AB<\/b>:\n$$C = \\begin{pmatrix} c_{11}, c_{12} & \\cdots & c_{1p} \\\\c_{21}, c_{22} & \\cdots & c_{2p} \\\\ \\vdots & \\ddots & \\vdots \\\\ c_{n1}, c_{n2} & \\cdots & c_{np} \\end{pmatrix} $$ \n$c_{ij} = a_{i1}b_{1j} + ... +  a_{im}b_{mj} = \\sum_{k=1}^{m} a_{ik}b_{kj}$","6c522bea":"### 4. A quick note about matrix multiplication","788413e8":"However, broadcasting is not always possible:","b2761498":"<center>\n<img src=\"https:\/\/nbviewer.jupyter.org\/github\/prickly-u\/mlcourse.ai\/blob\/master\/img\/numpy_array_vs_python_list.png\" style=\"width: 600px;\" \/>","a1688a53":"### 2. NumPy performance","622613ec":"The topic above is quite close to the ML area, as the action performed there is similar to the principle of convolutional layers in Convolution Neural Networks (CNN).<br>\nWhen convolution is applied, for example to an image in computer vision, it takes the matrix with image pixels and  slides across it with small window called \"filter\" or \"kernel\". The kernel is just little (3x3, 5x5, 7x7 or smth. like this) weight matrix that contains numerical coefficients. Each of these coefficients has to be multiplied by the value of pixel that is currently under the corresponding kernel cell. Then, all such multiplied element are summed, giving the value of an element of the resulting map. After that, the kernel is moved by 1 or more strides horizontaly or verticaly, to the next group of pixels, and the next weighted sum is calculated.<br>\nThis image illustrates the process of applying the filter and calculating an element of resulting map:","6bc16459":"The <a href=\"https:\/\/en.wikipedia.org\/wiki\/Conway%27s_Game_of_Life\" target=__blank>Conway's Game of Life<\/a> is a classical model of cellular automaton model and a zero-player game. Given an initial state, it starts to live its own life by applying the following rules on each step:<br>1) Each cell on a 2D grid is \"alive\"(1) or \"dead\"(0)<br>\n2) Any living cell that has 2 or 3 neighbors survives, else it dies (0,1 or 4+ neighbors)<br>\n3) Any cell with exactly 3 neighbors becomes alive (if it was dead)","52ec592d":"<center>\n<img src=\"https:\/\/nbviewer.jupyter.org\/github\/prickly-u\/mlcourse.ai\/blob\/master\/img\/cint_vs_pyint.png\" style=\"width: 400px;\" \/>","2d36f7dd":"And when storing string only:","b5f4c157":"Then <i>np.argsort<\/i> function allows to sort elements in the each row and print indexes of other points in the order of their remoteness from the i-th point:","d599a1ac":"The rules of matrix broadcasting are this way:<br>\n<b>Rule 1:<\/b> If the two arrays differ in their number of dimensions, the shape of the one with fewer dimensions is padded with ones on its leading (left) side.<br>\n<b>Rule 2:<\/b> If the shape of the two arrays does not match in any dimension, the array with shape equal to 1 in that dimension is stretched to match the other shape.<br>\n<b>Rule 3:<\/b> If in any dimension the sizes disagree and neither is equal to 1, an error is raised.<br>","f8ffc12a":"We used np.meshgrid function somewhere in the course, but without any explanations. That's pity in my opinion, as it is not so easy to grasp what it does from the NumPy <a href=\"https:\/\/docs.scipy.org\/doc\/numpy\/reference\/generated\/numpy.meshgrid.html\" target=__blank>documentation<\/a>:\n<blockquote cite=\"https:\/\/docs.scipy.org\/doc\/numpy\/reference\/generated\/numpy.meshgrid.html\">\nnumpy.meshgrid(*xi, **kwargs)<br>\n\nReturn coordinate matrices from coordinate vectors.<br>\n\nMake N-D coordinate arrays for vectorized evaluations of N-D scalar\/vector fields over N-D grids, given one-dimensional coordinate arrays x1, x2,\u2026, xn.\n<\/blockquote>","e4b539f3":"Then, those coordinate grids can be used to calculate values of multivariable functions, or to visualize something beautiful.","4a7ee05a":"#### 6.1 K-Nearest Neighbors","cb6a3dd5":"### 5. No mess with np.meshgrid","f5150f6b":"A matrix can be summed with a vector in the similar way:","66da5478":"The <i>numpy.dot()<\/i> function or \"@\" shortcut is used for this purpose in NumPy. That is unpleasant to confuse these two operations, especially when matrix broadcasting exists:","22178537":"All the elements in the \"mixed\" array were converted to unicode string. And they were converted in very awkward way: \"mixed\" elements take more bytes than in string-only array. Not sure how did it work internally, but I can suppose that U21 was selected during int conversion in order to accommodate even large numbers, though string representations of all integers < 1000000 fit into 6-characters string.","57bcb89c":"So, adding a two-dimensional array to a one-dimensional array is performed this way:","bd987a0d":"The shape of b is pad left with ones:<br>\na.shape -> (3, 1)<br>\nb.shape -> (1, 3)<br>\n<br>\nThen both matrixes has dimension to be expanded:<br>\na.shape -> (3, 3)<br>\nb.shape -> (3, 3)<br>\n<br>\nThen the matrixes can be easily summed:","c8406fa7":"Creating mixed int and string array:","5566853e":"That can be visualized:","226a8cd4":"In the example in the previous section used a np.newaxis constant was used. What is it? Actually it is None.","3688e08f":"<p>First, it slices original matrix with 0, 1 and 2 vertical strides, thus getting matrices with \"middle\" rows, rows shifted by -1 from the \"middle\" ones, and rows shifted by +1. The similar action is performed with the columns. Combining this steps in different directions creates 8 shifted matrices; their elementwise sum gives amount of \"alive\" neighbors for every element of N matrix.<\/p>\n<p>Then, by applying game rules to the N and Z matrices the boolean mask matrices \"birth\" and \"survive\" can be calculated. After that, NumPy boolean indexing allows to set to \"1\" only those cells that were born or had survived.<\/p>\n<p>The folowing code allows to animate the game process when running the notebook. <\/p>","bb83edaa":"A little bit. What about NumPy?","7f257e06":"Such way of storing data incurs additional metadata overhead, but gives more flexibility. There is no problems with having such mixed-type list in Python:","a963a7f6":"11% of gain is something noticeable. But were Python lists implemented so inefficiently? No, actually, they just were implemented differently.","17592731":"### 1. Introduction\/justification","8ed40c78":"In general, NumPy allows such notation too, but as its datastorage is continious, with equal strides, it has to convert all the data to one type. ","6220e42a":"And reshape allows to use -1 only once, requiring to explicitly pass original shape when working with multidimentional arrays:","2f66e994":"That's all by this moment. Hopping, it was informative :)","f3610785":"## References\n<ol>\n    <li><a href=\"http:\/\/shop.oreilly.com\/product\/0636920034919.do\" target=__blank>\"Python Data Science Handbook\"<\/a> by Jake VanderPlas<\/li><ul><li><a href=\"https:\/\/jakevdp.github.io\/blog\/2014\/05\/09\/why-python-is-slow\/\" target=__blank>\"Why Python is slow\"<\/a> article<\/li>\n        <li><a href=\"https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/02.05-computation-on-arrays-broadcasting.html\" target=__blanl>Computation on Arrays: Broadcasting<\/a><\/li>\n    <li><a href=\"https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/02.08-sorting.html#Example:-k-Nearest-Neighbors\" target=__blank>K-Nearest Neighbors sample<\/a><\/li>\n    <\/ul>\n    <li><a href=\"https:\/\/medium.com\/@ian.dzindo01\/what-is-numpy-newaxis-and-when-to-use-it-8cb61c7ed6ae\">What is numpy.newaxis and when to use it<\/a><\/li>\n    <li>NumPy documentation about <a href=\"https:\/\/docs.scipy.org\/doc\/numpy\/reference\/generated\/numpy.dot.html\" target=__blank>numpy.dot<\/a>, <a href=\"https:\/\/docs.scipy.org\/doc\/numpy\/reference\/constants.html#numpy.newaxis\" target=__blank>numpy.newaxis<\/a>, <a href=\"https:\/\/docs.scipy.org\/doc\/numpy\/reference\/generated\/numpy.meshgrid.html\" target=__blank>numpy.meshgrid<\/a><\/li>\n    <li><a href=\"https:\/\/matplotlib.org\/examples\/mplot3d\/surface3d_demo.html\">Matplotlib 3d surface example<\/a><\/li>\n    <li>Exercise 88 from the <a href=\"https:\/\/github.com\/rougier\/numpy-100\/blob\/master\/100_Numpy_exercises.ipynb\">100 NumPy exercises<\/a><\/li>\n<\/ol>","a7772d96":"In fact, the N matrix, calculating amount of cell's neighbors is similar convolution result, using a filter with wieght \"0\" for the middle element and \"1\" for all its neighbors.<br>","0f4ba9c9":"Does it mean that there was no gain in reality? No, only that it is better to create NumPy arrays using NumPy initialization functions. Numpy.arange in this case.","a2f04085":"Python loops shows as quite slow. Maybe list comprehension are quicker?","9694cc16":"Though NumPy was not denoted as prerequisite for mlcourse.ai, there is no doubt that most participants are familiar with it and have no difficulties in performing common actions. However, pieces of interesting information encountered here and there seem to be worth sharing. No one knows everything, NumPy was not covered in the course in details -  but it is a powerful scientific library that can make many mathematical calculations simpler and nicer.<br>\nLinks to materials the tutorial is based on can be found in the end of the notebook, in the \"References\" section. And sure, I'm not going to retell NumPy <a href=\"https:\/\/docs.scipy.org\/doc\/numpy\/user\/quickstart.html\" target=__blank>quickstart tutorial<\/a>.","4aa5f32f":"What? Half-integer half-string array occupies four times more space than string-only one? In reality, there are no integers in the first array: ","b8c9a5f4":"One more example, slightly more complex. Calculating distances from a point to long sequence of other ones:","f00eb637":"So, be attentive :)","d7013d59":"If only K nearest points (unsorted) are needed, the <i>np.argpartition<\/i> function allows to take them only, without sorting the whole rows: "}}