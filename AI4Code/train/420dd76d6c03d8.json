{"cell_type":{"44ee2417":"code","8972b36e":"code","45726e47":"code","d27ddb03":"code","48b9aae2":"code","87c977f1":"markdown"},"source":{"44ee2417":"import pandas as pd\nimport numpy as np\nimport torch\nimport random\nfrom sklearn import preprocessing \nimport torch.nn as nn\nfrom torch.utils.data import DataLoader, TensorDataset\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\nif device == 'cuda':\n  torch.cuda.manual_seed_all(777)\n\n\ntrain = pd.read_csv('..\/input\/traffic-accident\/train.csv', usecols=range(3,12))\ntest = pd.read_csv('..\/input\/traffic-accident\/test.csv', usecols=range(3,11)) \n\n#\ube44\uc5b4\uc788\ub294 \uac12\uc774 \ub9ce\uc740 \uc5f4 \uc0ad\uc81c\ntrain.drop(['snowFall','deepSnowfall','fogDuration'], axis=1, inplace=True)\ntest.drop(['snowFall','deepSnowfall','fogDuration'], axis=1, inplace=True)\n\ntrain = train.fillna(0)\n\ntest = test.fillna(0)\ntest","8972b36e":"xtrain = train.loc[:,[i for i in train.keys()[:-1]]]\nytrain = train[train.keys()[-1]]\n\nxtrain = np.array(xtrain)\n#xtrain = Scaler.fit_transform(xtrain) <-\uc815\uaddc\ud654 \ud558\uc9c0 \uc54a\uc74c\nxtrain = torch.FloatTensor(xtrain).to(device)\n\nytrain = np.array(ytrain)\nytrain = torch.FloatTensor(ytrain).view(-1,1).to(device)\n\nprint(xtrain.shape, ytrain.shape)\n\nxtrain","45726e47":"dataset = TensorDataset(xtrain, ytrain)\n\ndataloader = DataLoader(dataset, batch_size=64, shuffle=True)\n\n\nrandom.seed(1)\ntorch.manual_seed(1)\ntorch.cuda.manual_seed_all(1)\n\nlin1 = nn.Linear(5,5, bias = True)\nlin2 = nn.Linear(5,5, bias = True)\nlin3 = nn.Linear(5,1, bias = True)\n\nnn.init.xavier_uniform_(lin1.weight)\nnn.init.xavier_uniform_(lin2.weight)\nnn.init.xavier_uniform_(lin3.weight)\n\nrelu = nn.ReLU()\nmodel = nn.Sequential(lin1,\n                      lin2,\n                      lin3).to(device)\n\n\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-3)\nloss = nn.MSELoss().to(device)\n\nnb_epochs = 300\n\nfor epoch in range(nb_epochs + 1):\n  for batch_idx, samples in enumerate(dataloader):\n    x, y = samples\n\n    H = model(x)\n    cost = loss(H, y)\n\n    optimizer.zero_grad()\n    cost.backward()\n    optimizer.step()\n\n  if epoch%50 == 0:\n      print('Epoch {}  Cost {}'.format(epoch, cost.item()))\n\nprint('Learning Finished')","d27ddb03":"with torch.no_grad(): \n  xtest = test.loc[:,[i for i in train.keys()[:-1]]]\n\n  xtest = np.array(xtest)\n\n  #xtest = Scaler.transform(xtest)\n\n  xtest = torch.from_numpy(xtest).float().to(device)\n\n  H = model(xtest)\n\n  correct_prediction = H.cpu().numpy().reshape(-1,1) ","48b9aae2":"submit = pd.read_csv('..\/input\/traffic-accident\/submit_sample.csv')\n\nfor i in range(len(correct_prediction)):\n  submit['Expected'][i] = correct_prediction[i]\n","87c977f1":"baseline\uacfc\uc758 \ucc28\uc774\uc810\n\n* \ube44\uc5b4\uc788\ub294 \uac12\uc774 \ub9ce\uc740 \uc5f4 rainfall, snowfall, deepsnowfall, fogduration \uc911 rainfall\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \uc5f4\ub4e4\uc744 \uc81c\uac70\ud568\n* rainfall\uc758 \ube44\uc5b4\uc788\ub294 \uac12\uc740 0\uc73c\ub85c \ucc44\uc6c0.\n* \uc815\uaddc\ud654 \ud558\uc9c0 \uc54a\uc74c"}}