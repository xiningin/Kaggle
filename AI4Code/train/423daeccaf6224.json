{"cell_type":{"3c031970":"code","ec71b13e":"code","ba47f631":"code","92b73162":"code","ce5ab2eb":"code","8bbc1a37":"code","fb61e863":"code","9d76dcd0":"code","fea35215":"code","8d593a62":"code","bda9c5cc":"code","135315d4":"code","5e4ff927":"code","a552c16d":"code","8c51cd46":"code","b4722b67":"code","8e86d3c5":"code","0c23a7a5":"code","ac72cb4b":"code","495b4191":"code","99fa810a":"code","1e996187":"code","7cadf146":"code","b46f6322":"code","f82a1b51":"code","ed50c7dc":"code","b4da0416":"code","b87fe4b4":"code","f35139d0":"code","30e6789a":"code","02f3d0d8":"code","9b313deb":"code","f6c44bdc":"code","764650ba":"code","0c1721ae":"code","c80739b4":"code","709561dc":"code","02498f2c":"code","a5cca4bc":"code","9dc5f8ad":"markdown","890a7b74":"markdown","0fe836fb":"markdown","6c4775e1":"markdown","a1d8deac":"markdown","826b94d4":"markdown","82b731b9":"markdown","f75f61e9":"markdown","41554661":"markdown","b6ec3753":"markdown","81721285":"markdown","3d2ee9ba":"markdown","4a35e284":"markdown","6e35cc05":"markdown","7e919a1c":"markdown","ec0b0d18":"markdown","6ae427e4":"markdown","61fd87c7":"markdown","1e54c85a":"markdown","93d3f57c":"markdown","9ca4b8fe":"markdown","4a1e2e39":"markdown","ff963edf":"markdown","3d21cfaf":"markdown","654c691b":"markdown","cdd56a41":"markdown","ed7ad587":"markdown","a093f33c":"markdown","84593f05":"markdown","ae6c1b9a":"markdown"},"source":{"3c031970":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nplt.style.use('fivethirtyeight')\nsns.set_style('whitegrid')\n\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n\nfrom sklearn.preprocessing import StandardScaler, LabelEncoder, OneHotEncoder\nfrom sklearn.model_selection import train_test_split, RandomizedSearchCV, StratifiedKFold\nfrom sklearn import feature_extraction, linear_model, model_selection, preprocessing\nfrom scipy.stats import uniform\nfrom scipy import interp\n\n\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom xgboost import XGBClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.cluster import KMeans\n\n\n#metrics\nfrom sklearn.metrics import accuracy_score, classification_report, confusion_matrix, roc_curve, auc\nfrom sklearn.metrics import silhouette_samples, silhouette_score\nfrom bayes_opt import BayesianOptimization\n\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","ec71b13e":"df = pd.read_csv('..\/input\/german-credit-data-with-risk\/german_credit_data.csv')","ba47f631":"#show data frame\ndf.head()","92b73162":"def show_info(data):\n    print('DATASET SHAPE: ', data.shape, '\\n')\n    print('-'*50)\n    print('FETURE DATA TYPES:')\n    print(data.info())\n    print('\\n', '-'*50)\n    print('NUMBER OF UNIQUE VALUES PER FEATURE:', '\\n')\n    print(data.nunique())\n    print('\\n', '-'*50)\n    print('NULL VALUES PER FEATURE')\n    print(data.isnull().sum())","ce5ab2eb":"show_info(df)","8bbc1a37":"fig, ax = plt.subplots(1,3,figsize=(20,5))\nplt.suptitle('DISTRIBUTION PLOTS')\nsns.distplot(df['Credit amount'], bins=40, ax=ax[0]);\nsns.distplot(df['Duration'], bins=40, ax=ax[1], color='salmon');\nsns.distplot(df['Age'], bins=40, ax=ax[2], color='darkviolet');\n\nfig, ax = plt.subplots(1,3,figsize=(20,5))\nplt.suptitle('BOX PLOTS')\nsns.boxplot(df['Credit amount'], ax=ax[0]);\nsns.boxplot(df['Duration'], ax=ax[1], color='salmon');\nsns.boxplot(df['Age'], ax=ax[2], color='darkviolet');","fb61e863":"fig, ax = plt.subplots(1,2,figsize=(15,5))\n\nsns.countplot(df['Sex'], ax=ax[0], palette='magma');\nsns.countplot(df.Risk, ax=ax[1], palette='spring');","9d76dcd0":"#Show basic stats\ndf[['Age', 'Duration', 'Credit amount']].describe()","fea35215":"fig, ax = plt.subplots(3,1,figsize=(10,10))\nplt.suptitle('BIVARIATE ANALYSIS (HUE=SEX)', fontsize=20)\nplt.tight_layout(2)\n\nsns.lineplot(data=df, x='Age', y='Credit amount', hue='Sex', lw=2, ax=ax[0]);\nsns.lineplot(data=df, x='Duration', y='Credit amount', hue='Sex', lw=2, ax=ax[1]);\nsns.lineplot(data=df, x='Age', y='Duration', hue='Sex', lw=2, ax=ax[2]);\n","8d593a62":"ig, ax = plt.subplots(3,1,figsize=(10,10))\nplt.suptitle('BIVARIATE ANALYSIS (HUE=RISK)', fontsize=20)\nplt.tight_layout(2)\n\nsns.lineplot(data=df, x='Age', y='Credit amount', hue='Risk', lw=2, ax=ax[0], palette='deep');\nsns.lineplot(data=df, x='Duration', y='Credit amount', hue='Risk', lw=2, ax=ax[1], palette='deep');\nsns.lineplot(data=df, x='Age', y='Duration', hue='Risk', lw=2, ax=ax[2], palette='deep');","bda9c5cc":"sns.pairplot(df);","135315d4":"fig, ax =plt.subplots(3,1,figsize=(10,10))\nplt.tight_layout(2)\n\nsns.countplot(df['Saving accounts'], hue=df.Risk, ax=ax[0], palette='Greens');\nsns.boxenplot(df['Saving accounts'], df['Credit amount'], hue=df.Risk, ax=ax[1], palette='Greens');\nsns.violinplot(df['Saving accounts'], df['Job'], hue=df.Risk, ax=ax[2], palette='Greens');","5e4ff927":"df.groupby('Saving accounts')[['Duration', 'Job', 'Credit amount']].describe().T","a552c16d":"fig, ax =plt.subplots(3,1,figsize=(15,10))\nplt.tight_layout(4)\n\nfor i in range(3):\n    ax[i].set_xticklabels(ax[i].get_xticklabels(),rotation=10)\n\n\nsns.countplot(df['Purpose'], hue=df.Risk, ax=ax[0], palette='muted');\nsns.boxenplot(df['Purpose'], df['Credit amount'], hue=df.Risk, ax=ax[1], palette='muted');\nsns.violinplot(df['Purpose'], df['Job'], hue=df.Risk, ax=ax[2], palette='muted');","8c51cd46":"fig, ax =plt.subplots(3,1,figsize=(10,10))\nplt.tight_layout(2)\n\nsns.countplot(df['Housing'], hue=df.Risk, ax=ax[0], palette='magma');\nsns.boxenplot(df['Housing'], df['Credit amount'], hue=df.Risk, ax=ax[1], palette='magma');\nsns.violinplot(df['Housing'], df['Job'], hue=df.Risk, ax=ax[2], palette='magma');","b4722b67":"# replace null values with unknown\ndf= df.fillna('unknown')","8e86d3c5":"#check the null values again\ndf.isnull().sum()","0c23a7a5":"#drop the unnamed feature\ndf.drop('Unnamed: 0', axis=1, inplace=True)\ncategorical_features = ['Sex', 'Job', 'Housing', 'Saving accounts', 'Checking account', 'Purpose', 'Risk']\n","ac72cb4b":"#labelencode the categorical features\nfor i, cat in enumerate(categorical_features):\n    df[cat] = LabelEncoder().fit_transform(df[cat])","495b4191":"#show new df\ndf.head()","99fa810a":"num_df = df[['Age', 'Duration', 'Credit amount']]\nnum_df = np.log(num_df)","1e996187":"fig, ax = plt.subplots(1,3,figsize=(20,5))\nplt.suptitle('DISTRIBUTION PLOTS AFTER LOG TRANSFORMATION')\nsns.distplot(num_df['Credit amount'], bins=40, ax=ax[0]);\nsns.distplot(num_df['Duration'], bins=40, ax=ax[1], color='salmon');\nsns.distplot(num_df['Age'], bins=40, ax=ax[2], color='darkviolet');","7cadf146":"scaler = StandardScaler()\nnum_df_scaled = scaler.fit_transform(num_df)","b46f6322":"#show new values\nprint(num_df_scaled.shape)\nnum_df_scaled","f82a1b51":"inertias = []\n\nfor i in range(2,16):\n    kmeans = KMeans(n_clusters=i, random_state=0).fit(num_df_scaled)\n    inertias.append(kmeans.inertia_)\n\nplt.figure(figsize=(10,5))\nplt.title('ELBOW METHOD')\nplt.plot(np.arange(2,16),inertias, marker='o', lw=2, color='steelblue');","ed50c7dc":"results = []\n\nfor i in range(2,16):\n    for r in range(20):\n        kmeans = KMeans(n_clusters=i, random_state=r)\n        c_labels = kmeans.fit_predict(num_df_scaled)\n        sil_ave = silhouette_score(num_df_scaled, c_labels)\n        results.append([i, r, sil_ave])\n        \nres_df = pd.DataFrame(results, columns=['num_cluster', 'seed', 'sil_score'])\npivot_kmeans = pd.pivot_table(res_df, index='num_cluster', columns='seed', values='sil_score')\n\nplt.figure(figsize=(15,6))\nplt.tight_layout\nsns.heatmap(pivot_kmeans, annot=True, linewidths=0.5, fmt='.3f', cmap='magma', annot_kws={\"size\":8});","b4da0416":"km = KMeans(n_clusters=3, random_state=0)\nclusters = km.fit_predict(num_df_scaled)","b87fe4b4":"#show a 3D plot of clusters\nfrom mpl_toolkits.mplot3d import Axes3D \nfig = plt.figure(figsize=(10,6))\nax = fig.add_subplot(111, projection='3d')\n\nfor i in range(3):\n    ax.scatter(num_df_scaled[clusters ==i,0], num_df_scaled[clusters ==i,1], num_df_scaled[clusters ==i,2])\n    \n","f35139d0":"fig, ax  = plt.subplots(1,3,figsize=(20,5))\nsns.scatterplot(df['Duration'], df['Credit amount'], hue=clusters, ax=ax[0], palette='cividis');\nsns.scatterplot(df['Age'], df['Credit amount'], hue=clusters, ax=ax[1], palette='cividis');\nsns.scatterplot(df['Age'], df['Duration'], hue=clusters, ax=ax[2], palette='cividis');","30e6789a":"df_clustered = df[['Age', 'Duration', 'Credit amount']]\ndf_clustered['cluster'] = clusters","02f3d0d8":"df_clustered.groupby('cluster').mean()","9b313deb":"num_df_scaled = pd.DataFrame(num_df_scaled, columns=['Age', 'Duration', 'Credit Amount'])\ncat_df = df[categorical_features]\n\ndata = pd.concat([cat_df, num_df_scaled], axis=1)","f6c44bdc":"#show new dataframe\ndata.head()","764650ba":"x = data.drop('Risk', axis=1)\ny = data['Risk']\n\nx_train, x_test, y_train, y_test = train_test_split(x,y, test_size=0.2, random_state=101)\n\nprint('xtrain shape: ', x_train.shape)\nprint('xtest shape: ', x_test.shape)\nprint('ytrain shape: ', y_train.shape)\nprint('ytest shape: ', y_test.shape)\n","0c1721ae":"#RandomSearchCV\n# define the parameters to tune\nparam_dist = {\"learning_rate\": uniform(0, 2),\n              \"gamma\": uniform(1, 0.000001),\n              \"max_depth\": range(1,50),\n              \"n_estimators\": range(1,300),\n              \"min_child_weight\": range(1,10),\n              'n_jobs': range(1,5)}\n#instance of RandomSearchCV\nrs = RandomizedSearchCV(XGBClassifier(), param_distributions=param_dist, n_iter=25) #25 iterations","c80739b4":"rs.fit(x_train, y_train)","709561dc":"predictions = rs.predict(x_test)\n\nprint(classification_report(y_test, predictions))","02498f2c":"def plot_roc(X, y, estemator,n_splits, lns = 100):\n    #creating an instance of KFold\n    kfold = StratifiedKFold(n_splits=n_splits,shuffle=False)\n    #define estemator\n    rf = estemator\n    #deifne figuresize\n    plt.rcParams['figure.figsize'] = (10,5)\n    \n    tprs = []\n    aucs = []\n    mean_fpr = np.linspace(0,1,lns)\n    i = 1\n\n    for train,test in kfold.split(X,y):\n        #get prediction\n        prediction = rf.fit(X.iloc[train],y.iloc[train]).predict_proba(X.iloc[test])\n        #get the true pos. rate, false positive rate and thresh \n        fpr, tpr, t = roc_curve(y[test], prediction[:, 1])\n        tprs.append(interp(mean_fpr, fpr, tpr))\n        #get the area under the curve\n        roc_auc = auc(fpr, tpr)\n        aucs.append(roc_auc)\n        #plot the tpr and fpr\n        plt.plot(fpr, tpr, lw=2, alpha=0.3, label='ROC fold %d (AUC = %0.2f)' % (i, roc_auc))\n        i= i+1\n\n    #plot the mean ROC\n    plt.plot([0,1],[0,1],linestyle = '--',lw = 2,color = 'black')\n    mean_tpr = np.mean(tprs, axis=0)\n    mean_auc = auc(mean_fpr, mean_tpr)\n    plt.plot(mean_fpr, mean_tpr, color='gold',\n    label=r'Mean ROC (AUC = %0.2f )' % (mean_auc),lw=2, alpha=1)\n\n    #setup the labels\n    plt.legend(bbox_to_anchor=(1, 1))\n    plt.title('ROC PLOT', fontsize=16)\n    plt.xlabel('False Positive Rate', fontsize=12)\n    plt.ylabel('True Positive Rate', fontsize=12)","a5cca4bc":"xgb_model = XGBClassifier()\nxgb_model.set_params(**rs.best_params_)\n\nplot_roc(x,y, xgb_model, n_splits=10)","9dc5f8ad":"### ANALYSIS BY CREDIT CARD PURPOSE","890a7b74":"#### APPLYING ELBOW METHOD TO FIND THE BEST NUMBER OF CLUSTERS","0fe836fb":"### UNIVARIATE ANALYSIS","6c4775e1":"### PLOTTING ROC CURVE","a1d8deac":"### PER HOUSING","826b94d4":"#### SPLIT THE DATA","82b731b9":"#### APPLYING LOG TRANSFORMATION","f75f61e9":"### PAIRPLOT TO VISUALIZE FEATURES WITH LINEAR RELATIONSHIP","41554661":"#### HYPERPARAMETER TUNING","b6ec3753":"### XGBOOST MODEL","81721285":"* Cluster 0 are the older customers.\n* Cluster 1 are the middle-Aged customers.\n* Cluster 2 are the younger customers.","3d2ee9ba":"#### SHOW BASIC STATS PER SAVING ACCOUNT","4a35e284":"## PREDICTIVE MODELLING\n---","6e35cc05":"#### STANDARDSCALING","7e919a1c":"### INSIGHTS\n---\n* Most of the credit cards have an amount of 1500 - 4000\n* The Credit amount is positively skewed, So the samples are dispersed","ec0b0d18":"### INSIGHTS\n---\n* There is a linear relationship between Duration and Creadit Amount, Which makes sense because usually, people take bigger credits for longer periods. \n* The trend Between Age and Credit amount is not clear.","6ae427e4":"#### LET'S CREATE A DATAFRAME TO SUMMARIZE THE RESULT","61fd87c7":"## EDA\n---","1e54c85a":"* The scores of 2,3,4 and 5 are pretty stable, Let's pick a number of cluster from that range.","93d3f57c":"## DATA PREPROCESSING\n---","9ca4b8fe":"#### PREDICT THE TEST DATA","4a1e2e39":"### BIVARIATE ANALYSIS","ff963edf":"## OVERVIEW\n---\n* Bivariate & Univariate Analysis\n* Data Cleaning\n* Data Preprocessing & Sampling\n* Unsupervised & Supervised Machine Learning\n* Segmentation of Customers\n* Hyperparameter Tuning\n* Predictive Modelling with XGBoost to classify the Risk.\n* ROC Analysis","3d21cfaf":"## CLUSTERING\n---","654c691b":"#### ALTERNATIVE METHOD: SILHOUTE SCORE WITH RANDOM SAMPLING","cdd56a41":"#### COUNTPLOTS (SEX & RISK FACTOR)","ed7ad587":"### NORMALIZE THE NUMERIC FEATURES","a093f33c":"#### AT 3 NUMBER OF CLUSTERS","84593f05":"### SAVING ACCOUNT ANALYSIS","ae6c1b9a":"### K-MEANS"}}