{"cell_type":{"e9b70e84":"code","b8a97510":"code","9431dc07":"code","17f64073":"code","927f8e66":"code","10ed9063":"code","57bbd365":"code","e26fa68c":"code","aa0fe209":"code","36daaa44":"code","765d89c1":"code","af758aee":"code","4d43bbdb":"code","673a2df2":"code","b2a17025":"code","fe194b3c":"code","1564b527":"markdown","61514882":"markdown","aced6a41":"markdown","5cfb627f":"markdown","118ed365":"markdown","ceb020f8":"markdown","8b40b1d1":"markdown","aca03cbc":"markdown","bac474e2":"markdown","af84e537":"markdown","91b77557":"markdown","4a3b874e":"markdown","d8b4c7e6":"markdown","6fca9d3b":"markdown","7d47c3bb":"markdown","5728854d":"markdown"},"source":{"e9b70e84":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nimport random\nimport sys\nimport gc\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport cv2\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split \nfrom sklearn.preprocessing import LabelBinarizer\nimport PIL\nfrom PIL import Image\nfrom IPython.display import SVG\nfrom keras.utils.vis_utils import model_to_dot\n\nimport keras\nfrom keras import layers\nfrom keras import metrics\nfrom keras.models import load_model\nfrom keras.layers import Dense, Flatten, Conv2D, Dropout, MaxPooling2D, GlobalAveragePooling2D, Dropout\nfrom keras import optimizers\nfrom keras import models\nfrom keras.models import Sequential\nfrom keras import preprocessing\nfrom keras.preprocessing import image\nfrom keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img\nfrom keras.applications import VGG16\nfrom keras.utils import plot_model","b8a97510":"img_size = 224\nbatch_size = 32\nepochs = 100\ntrain_size = 0.7\nval_size = 0.2\ntest_size = 0.1\nseed = 4321\nchannels = 3\nlearning_rate = 0.00001","9431dc07":"d = '..\/input\/tobacco3482-jpg\/Tobacco3482-jpg\/'\nPATH = '..\/'\n\nclasses = (os.listdir(d))\n\npaths = [os.path.join(d, o) for o in os.listdir(d) \n                    if os.path.isdir(os.path.join(d,o))]\n\nnbEntries = []\n\nfor i in range(len(classes)):\n    nbEntries.append(len(os.listdir(paths[i])))\n\n#################################################\n    \nprint(classes)\nprint(nbEntries)\n\ndf = pd.DataFrame({'classes':classes, 'entries':nbEntries})\nax = df.sort_values(by='entries', ascending=True).plot.bar(x='classes', y='entries', color='cornflowerblue',legend=False, figsize=(12,8))\nax.set_title('Tobacco3482 classes Distribution')\nax.set_ylabel(\"# entries\")\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), xy=(p.get_x(), p.get_height()-30))","17f64073":"total_set = []\ntotal_labels = []\n\n\nfor root, dirs, files in os.walk(d):\n    for file in files:\n        if file.endswith(\".jpg\"):\n            path = os.path.join(root, file)\n            total_set.append(path)\n            total_labels.append(root.split(os.path.sep)[-1])\n            \n\n# Return image class based on list entry (path)         \ndef getClass(img):\n    return img.split(os.path.sep)[-2]\n\n\nprint(total_set[0])\nprint('GetClass : ', getClass(total_set[0]))\nprint('Label : ', total_labels[0])","927f8e66":"random.Random(seed).shuffle(total_set)\n\nfor ima in total_set[0:3] :\n    print(ima)\n    img = mpimg.imread(ima)\n    plt.figure(figsize=(7,7))\n    imgplot = plt.imshow(img, cmap=\"gray\")\n    plt.show()\n","10ed9063":"# Get data and separate it in sets\ntotal_len = len(total_set)\nindex = 0\n\ntrain_set = []\ntrain_label = []\n\nval_set = []\nval_label = []\n\ntest_set = []\ntest_label = []\n\n\nfor i in total_set[0: int(total_len*train_size)] :\n    train_set.append(i)\n    train_label.append(getClass(i))\n    \nindex = int(total_len*train_size)+1\n    \nfor i in total_set[index: int(index + total_len*val_size)] :\n    val_set.append(i)\n    val_label.append(getClass(i))\n    \nindex = int(index + total_len*val_size)+1 \n\nfor i in total_set[index: total_len] :\n    test_set.append(i)\n    test_label.append(getClass(i))\n\nprint(val_set[200])\nprint(val_label[200])\n","57bbd365":"#################################################\n# TRAIN SET\ninstances = [0] * len(classes)\nfor index, val in enumerate(classes) :\n    for e in train_set :\n        if(val == getClass(e)) :\n            instances[index] += 1\n\n            \ndf = pd.DataFrame({'classes':classes, 'entries':instances})\nax = df.sort_values(by='entries', ascending=True).plot.bar(x='classes', y='entries', color='cornflowerblue',legend=False, figsize=(12,8))\nax.set_title('Tobacco3482 TRAIN SET Distribution')\nax.set_ylabel(\"# entries\")\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), xy=(p.get_x(), p.get_height()-20))\n\n#################################################\n# VAL SET\ninstances = [0] * len(classes)\nfor index, val in enumerate(classes) :\n    for e in val_set :\n        if(val == getClass(e)) :\n            instances[index] += 1\n\n            \ndf = pd.DataFrame({'classes':classes, 'entries':instances})\nax = df.sort_values(by='entries', ascending=True).plot.bar(x='classes', y='entries', color='cornflowerblue',legend=False, figsize=(12,8))\nax.set_title('Tobacco3482 VAL SET Distribution')\nax.set_ylabel(\"# entries\")\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), xy=(p.get_x(), p.get_height()-3))\n    \n#################################################\n# TEST SET\ninstances = [0] * len(classes)\nfor index, val in enumerate(classes) :\n    for e in test_set :\n        if(val == getClass(e)) :\n            instances[index] += 1\n\n            \ndf = pd.DataFrame({'classes':classes, 'entries':instances})\nax = df.sort_values(by='entries', ascending=True).plot.bar(x='classes', y='entries', color='cornflowerblue',legend=False, figsize=(12,8))\nax.set_title('Tobacco3482 TEST SET Distribution')\nax.set_ylabel(\"# entries\")\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), xy=(p.get_x(), p.get_height()-8))","e26fa68c":"def process_images(img_set) : \n    processed_img = []\n\n    for i in range(len(img_set)) :\n        processed_img.append(cv2.resize(cv2.imread(img_set[i], cv2.IMREAD_COLOR), (img_size, img_size)))\n    \n    return processed_img\n    \ndata_train = process_images(train_set)\ndata_test = process_images(test_set)\ndata_val = process_images(val_set)","aa0fe209":"lb = LabelBinarizer()\nlb.fit(list(classes))\n\nx_train = np.array(data_train)\ny_train =lb.transform(np.array(train_label))\n\nx_test = np.array(data_test)\ny_test = lb.transform(np.array(test_label))\n\nx_val = np.array(data_val)\ny_val = lb.transform(np.array(val_label))\n\nprint(\"train images shape : \", x_train.shape)\nprint(\"train labels shape : \", y_train.shape)\nprint(x_train[0])\n\nprint(\"test shape : \", x_test.shape)\nprint(y_test.shape)\nprint(\"valdiation shape : \", x_val.shape)\nprint(y_val.shape)\n\n\nfor i in range(3) :\n    plt.figure(figsize=(6,6))\n    imgplot = plt.imshow(x_train[i])\n\nprint(train_label[0])\nprint(y_train[0])\nprint(lb.classes_)","36daaa44":"base_model = VGG16(weights = \"imagenet\", include_top=False, input_shape = (img_size, img_size, channels))\n\n#for layer in base_model.layers:\n#    layer.trainable = False\n    \nbase_model.summary()","765d89c1":"model = models.Sequential()\n\nmodel.add(base_model)\nmodel.add(layers.Flatten())\nmodel.add(layers.Dense(128, activation='relu',  name='dense'))\nmodel.add(layers.Dropout(0.5))\nmodel.add(layers.Dense(len(classes), activation='softmax',  name='predictions'))\n\nmodel.summary()\n\nprint('Number of trainable weights : ', len(model.trainable_weights))\n\nplot_model(model, to_file='model.png')\nSVG(model_to_dot(model).create(prog='dot', format='svg'))","af758aee":"model.compile(optimizer=optimizers.Adam(lr=learning_rate), loss='categorical_crossentropy', metrics=['accuracy'])\n\ntrain_model = model.fit(x_train, y_train,\n                        batch_size=batch_size,\n                        epochs=epochs,\n                        verbose=1,\n                        validation_data=(x_val, y_val))","4d43bbdb":"plt.plot(train_model.history['loss'])\nplt.plot(train_model.history['val_loss'])\nplt.title('model loss')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.grid()\nplt.legend(['training loss', 'validation loss'], loc='upper right')\nplt.show()\n\nplt.plot(train_model.history['acc'])\nplt.plot(train_model.history['val_acc'])\nplt.title('model accuracy')\nplt.grid()\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(['training accuracy', 'validation accuracy'], loc='lower right')\nplt.show()","673a2df2":"# combine predictions + average for better score ? \n\nscore = model.evaluate(x_test, y_test, verbose=1)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","b2a17025":"model.save('trained_model.h5')","fe194b3c":"predictions = model.predict_classes(x_test, verbose=1)\npredictions_list = predictions.tolist()\npredicted_classes = lb.classes_\n\ncount_true = 0;\ncount_false = 0;\n\nfor i, prediction in enumerate(predictions_list):\n    state = True\n    if (predicted_classes[prediction] != test_label[i]) :\n        state = False\n        count_false += 1\n    else :\n        count_true += 1\n    print(\"Prediction : \", predicted_classes[prediction], \"   |   Real class : \", test_label[i],  \"   |   Result : \", state)\n\nprint(\"\\nNumber of success : \", count_true) \nprint(\"Number of error : \", count_false) \nprint(\"Error rate : \", count_true\/len(test_label))\n","1564b527":"# Save model\n* the architecture of the model, allowing to re-create the model\n* the weights of the model\n* the training configuration (loss, optimizer)\n* the state of the optimizer, allowing to resume training exactly where you left off.","61514882":"# Create custom model\nBase is VGG16, adding a flatten layer, a Dense layer and a dropout layer. Last Dense layer specify the number of classes\n\n[https:\/\/keras.io\/getting-started\/sequential-model-guide\/](https:\/\/keras.io\/getting-started\/sequential-model-guide\/)\n\n[https:\/\/keras.io\/layers\/core\/](https:\/\/keras.io\/layers\/core\/)","aced6a41":"# Use model on test set","5cfb627f":"# Preprocess data (resize, transform to Numpy array and binarize)\n\n[https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.preprocessing.LabelBinarizer.html](https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.preprocessing.LabelBinarizer.html)","118ed365":"**Compile** : Configures the model for training.\n\n**Fit** : Trains the model for a given number of epochs (iterations on a dataset).\n\n[https:\/\/keras.io\/models\/model\/](https:\/\/keras.io\/models\/model\/)","ceb020f8":"# Get all images","8b40b1d1":"# Visualize classes distribution (bar chart)","aca03cbc":"# Sorting data in usable sets\n![](https:\/\/cdn-images-1.medium.com\/max\/800\/1*HpvpA9pBJXKxaPCl5tKnLg.jpeg)","bac474e2":"# Get classes and entries per classes","af84e537":"# Plot data ","91b77557":"# Create base model (using pretrained CNN)\n\n[https:\/\/keras.io\/applications\/](https:\/\/keras.io\/applications\/)\n\nTrainable weights : TRUE\n\nTo \"freeze\" a layer means to exclude it from training. Allows to train the whole model and not only the last added layers --> 5\/10% better accuracy. it takes about three to four times longer for training since there are way more parameters to train.\n","4a3b874e":"# Plot accuracy and loss of trained model (line chart)","d8b4c7e6":"# Test prediction accuracy on test set","6fca9d3b":"# Global variables","7d47c3bb":"# Imports","5728854d":"# Training the model"}}