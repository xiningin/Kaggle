{"cell_type":{"894671e4":"code","42fea413":"code","ff318e73":"code","8151d8e5":"code","685fc998":"code","16523bc8":"code","2b4071d1":"code","6fc1a21c":"code","b86010b1":"code","affb1874":"code","ab0987fc":"code","b769c17c":"markdown","dd791372":"markdown","d6084c5b":"markdown","eff89047":"markdown","dbba8c02":"markdown","913cf84a":"markdown"},"source":{"894671e4":"%%time\n# INSTALL RAPIDS OFFLINE (FROM KAGGLE DATASET). TAKES 1 MINUTE :-)\nimport sys\n!cp ..\/input\/rapids\/rapids.0.11.0 \/opt\/conda\/envs\/rapids.tar.gz\n!cd \/opt\/conda\/envs\/ && tar -xzvf rapids.tar.gz\nsys.path = [\"\/opt\/conda\/envs\/rapids\/lib\"] + [\"\/opt\/conda\/envs\/rapids\/lib\/python3.6\"] + [\"\/opt\/conda\/envs\/rapids\/lib\/python3.6\/site-packages\"] + sys.path\n!cp \/opt\/conda\/envs\/rapids\/lib\/libxgboost.so \/opt\/conda\/lib\/","42fea413":"# INSTALL RAPIDS ONLINE (WITH CONDA). TAKES 6 MINUTES :-(\n#import sys\n#!conda create -n rapids -c rapidsai\/label\/xgboost -c rapidsai -c nvidia -c conda-forge rapids=0.11 python=3.6 cudatoolkit=10.1 --yes\n#sys.path = [\"\/opt\/conda\/envs\/rapids\/lib\"] + [\"\/opt\/conda\/envs\/rapids\/lib\/python3.6\"] + [\"\/opt\/conda\/envs\/rapids\/lib\/python3.6\/site-packages\"] + sys.path\n#!cp \/opt\/conda\/envs\/rapids\/lib\/libxgboost.so \/opt\/conda\/lib\/","ff318e73":"# LOAD LIBRARIES\nimport cudf, cuml\nimport pandas as pd, numpy as np, os\nfrom cuml.neighbors import KNeighborsClassifier\nimport matplotlib.pyplot as plt\nprint('cuML version',cuml.__version__)","8151d8e5":"# LOAD TRAIN DATA\ntrain = pd.read_csv('..\/input\/digit-recognizer\/train.csv').values\n#train = np.array( cudf.read_csv('..\/input\/digit-recognizer\/train.csv').to_gpu_matrix() )\nprint('Original train shape =', train.shape )","685fc998":"stderr = sys.stderr; sys.stderr = open(os.devnull, 'w')\nfrom keras.preprocessing.image import ImageDataGenerator; sys.stderr = stderr\n# PREVIEW AUGMENTED IMAGES\ndatagen = ImageDataGenerator(rotation_range=10, zoom_range = 0.10, width_shift_range=0.1, height_shift_range=0.1)\ndigit = train[21,1:].reshape((1,28,28,1))\nplt.figure(figsize=(15,5.5))\nfor i in range(24):  \n    plt.subplot(3, 8, i+1)\n    new_digit = datagen.flow(digit).next()\n    plt.imshow(new_digit[0].reshape((28,28)),cmap=plt.cm.binary)\n    if i==0: plt.title('Original')\n    elif i<8: plt.title('Augmented')\n    plt.xticks([], []); plt.yticks([], [])\n    if i==7: digit = train[22,1:].reshape((1,28,28,1))\n    if i==15: digit = train[25,1:].reshape((1,28,28,1))\nplt.subplots_adjust(wspace=-0.1, hspace=0.1)\nplt.show()","16523bc8":"%%time\nfrom keras.preprocessing.image import ImageDataGenerator\ndatagen = ImageDataGenerator(rotation_range=10, zoom_range = 0.10, width_shift_range=0.1, height_shift_range=0.1)\nda = 50; bs=4200\ntrain2 = np.zeros((train.shape[0]*da,train.shape[1]),dtype=np.float32)\nfor k,(X,Y) in enumerate( datagen.flow( train[:,1:].reshape((-1,28,28,1)), train[:,0].reshape((-1,1)) ,batch_size=bs ) ):\n    train2[bs*k:bs*(k+1),1:] = X.reshape((-1,784))\n    train2[bs*k:bs*(k+1),0] = Y.reshape((-1))\n    if k%10==0: print(k\/\/10,', ',end='')\n    if k==train2.shape[0]\/\/bs-1: break\nprint(); print('New train shape =', train2.shape )","2b4071d1":"# LOAD TEST DATA\ntest = cudf.read_csv('..\/input\/digit-recognizer\/test.csv')\nprint('test shape =', test.shape )","6fc1a21c":"%%time\n# CONVERT NumPy array to cuDF array\ntrain3 = cudf.from_pandas( pd.DataFrame(train2) )\n# train3 = cudf.DataFrame.from_gpu_matrix(cupy.asarray(train2))","b86010b1":"%%time\n# FIT KNN MODEL\nknn = KNeighborsClassifier(n_neighbors=3)\nknn.fit( train3.iloc[:,1:], train3.iloc[:,0] )\n# We can train directly from NumPy array but cuML v0.11.0 has bug\n# knn.fit(train2[:,1:], train2[:,0])","affb1874":"%%time\n# PREDICT TEST DATA\ny_hat_p = knn.predict_proba(test)\ny_hat = y_hat_p.to_pandas().values.argmax(axis=1)\n# We could use knn.predict() but cuML v0.11.0 has bug\n# y_hat = knn.predict(test)","ab0987fc":"# SAVE PREDICTIONS TO CSV\nsub = pd.read_csv('..\/input\/digit-recognizer\/sample_submission.csv')\nsub.Label = y_hat\nsub.to_csv('submission_cuML_DAx50.csv',index=False)\nsub.head()","b769c17c":"# Data Augmentation - 2 Million Images!\nIf we rotate the image of a digit, it is still the same digit. Likewise if we shift or scale an image, it is the same digit. We would like our model to learn this, so will will create 2 million additional training data images where we randomly rotate, shift, and scale the original training images.\n  \nWe will use [`keras.preprocessing.image.ImageDataGenerator()`][1] to augment our data. This function uses CPU and isn't very fast. If we want more speed, we could write our own augmentation function on GPU or use an existing GPU augmentation package. Since rotation, shift, and scaling are all matrix computations we would see a huge speed increase on GPU (600x or more). \n  \n[1]: https:\/\/keras.io\/preprocessing\/image\/","dd791372":"# RAPIDS - Do More in Less Time - kNN - MNIST - [0.985]\nIn our previous kernel [here][1], we saw that RAPIDS cuML's kNN algorithm could predict all the test images in Kaggle's Digit-Recognizer competition in an incredible 2.5 seconds (compared to Scikit-learn's 25 minutes). Since RAPIDS cuML is so fast, we can use this speed advantage to increase our model's accuracy by doing additional tasks. Some ways to increase model accuracy are:\n* Feature Engineering and Selection\n* Hyperparameter Search\n* Data Augmentation\n* Ensembling with Bagging and Boosting\n  \nIn this kernel, we will apply Data Augmentation to generate more training data and increase model accuracy.\n\n[1]: https:\/\/www.kaggle.com\/cdeotte\/rapids-gpu-knn-mnist-0-97","d6084c5b":"# RESULT without Data Augmentation\nIn our last notebook without data augmentation, we achieved an accuracy of 96.9%:\n  \n![1-24-20-cuML.png](attachment:1-24-20-cuML.png)","eff89047":"# Predict Test\nIn our previous notebook we witnessed GPU RAPIDS kNN infer the entire Kaggle test dataset of 28,000 images against a training set of 48,000 images in an incredible 2.5 seconds. Below we witness GPU RAPIDS kNN infer the entire Kaggle test dataset of 28,000 images against an augmented training set of 2,400,000 images in an incredible 14.5 seconds. That's an amazing 131.7 trillion multiplies, additions, and subtractions in only 14.5 seconds! Unbelieveable!","dbba8c02":"# Install Nvidia RAPIDS in 1 minute\nNvidia RAPIDS is described [here][1]. The RAPIDS library allows us to perform all our data science on GPUs. The library cuDF provides Pandas functionality on GPU, and cuML provides Scikit-learn functionality on GPU. \n\nIn Kaggle notebooks, we can either install RAPIDS from a local Kaggle dataset [here][2], or install RAPIDS from its online source using Conda. Local takes 1 minute and Conda takes 6 minutes. If the local install doesn't work or we want a more recent version of RAPIDS, we should install with Conda, otherwise local is the fast choice.\n\n[1]: https:\/\/rapids.ai\/\n[2]: https:\/\/www.kaggle.com\/cdeotte\/rapids","913cf84a":"# RESULT with Data Augmentation\nIn this notebook with data augmentation, we achieve an accuracy of 98.5%. If we create more augmented data and\/or create non-linear augmentations, we can achieve accuracy over 99%. Additionally, one can scale columns of the dataset to prioritize certain regions of pixels and increase accuracy further! Or one can ensemble multiple models created with bagging. Because RAPIDS cuML is so fast, we can do kNN plus additional tasks and achieve state of the art accuracies!\n\n![cuML_DAx50.png](attachment:cuML_DAx50.png)"}}