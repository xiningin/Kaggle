{"cell_type":{"c083eed4":"code","aedb91d8":"code","70dd535b":"code","e70c3a13":"code","f22a2f86":"code","07f06abd":"code","95bb5a32":"code","45740c6c":"code","8941e275":"code","9e30a079":"code","d95e9206":"code","305c9be6":"code","e1ed3d3b":"code","fcfb2990":"code","971adfef":"code","96ac9b3c":"code","a1716b52":"code","a821b6bb":"code","a39cba30":"markdown","78497403":"markdown","3b9793d8":"markdown","483b299d":"markdown","6dd9dc6a":"markdown","8bcfbd30":"markdown","7e90f692":"markdown","fac7148d":"markdown","0f513797":"markdown","2ed8a16e":"markdown","a176e2dc":"markdown","dac23fc3":"markdown","4f53a6bc":"markdown","c82c131c":"markdown","2928fe11":"markdown","06321253":"markdown"},"source":{"c083eed4":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# KMeans e Single Linkage\nfrom sklearn.cluster import KMeans, AgglomerativeClustering","aedb91d8":"# Carregando os datasets\ndataset_aggregation = pd.read_csv(\"..\/input\/unifesp-2021-01-ia\/Dataset_Aggregation.csv\")\ndataset_d31 = pd.read_csv(\"..\/input\/unifesp-2021-01-ia\/Dataset_D31.csv\")\ndataset_flame = pd.read_csv(\"..\/input\/unifesp-2021-01-ia\/Dataset_Flame.csv\")\ndataset_pathbased = pd.read_csv(\"..\/input\/unifesp-2021-01-ia\/Dataset_Pathbased.csv\")","70dd535b":"dataset_aggregation.head()","e70c3a13":"dataset_d31.head()","f22a2f86":"dataset_flame.head()","07f06abd":"dataset_pathbased.head()","95bb5a32":"# Transforma as linhas da planilha em um array\nX = np.array(dataset_aggregation) \n\n# Calcula quantidade de clusters\nn_clusters = int(max(dataset_aggregation['Z']))\n\n# Plota o gr\u00e1fico dos grupos com base nos dados fornecidos no dataset\nplt.scatter(X[:, 0], X[:, 1], c=np.array(dataset_aggregation['Z']), s=50,  cmap='viridis')","45740c6c":"# Realiza a divis\u00e3o dos clusters pelo algoritmo KMeans\nclf_kmeans = KMeans(n_clusters=n_clusters, random_state=0)\nclf_kmeans.fit(X)\n\nlabels = clf_kmeans.labels_\n\n# Plota o gr\u00e1fico dos clusters encontrados\nplt.scatter(X[:, 0], X[:, 1], c=labels, s=50, cmap='viridis')","8941e275":"# Realiza a divis\u00e3o dos clusters pelo algoritmo Single Linkage\nclf_single_linkage = AgglomerativeClustering(n_clusters = n_clusters, linkage = 'single')\nclf_single_linkage.fit(X)\n\nlabels = clf_single_linkage.labels_\n\n# Plota o gr\u00e1fico dos clusters encontrados\nplt.scatter(X[:, 0], X[:, 1], c=labels, s=50, cmap='viridis')","9e30a079":"X = np.array(dataset_d31) \nn_clusters = int(max(dataset_d31['Z']))\n\nplt.scatter(X[:, 0], X[:, 1], c=np.array(dataset_d31['Z']), s=50, cmap='viridis')","d95e9206":"clf_kmeans = KMeans(n_clusters=n_clusters, random_state=0)\nclf_kmeans.fit(X)\n\nlabels = clf_kmeans.labels_\n\nplt.scatter(X[:, 0], X[:, 1], c=labels, s=50, cmap='viridis')","305c9be6":"clf_single_linkage = AgglomerativeClustering(n_clusters = n_clusters, linkage = 'single')\nclf_single_linkage.fit(X)\n\nlabels = clf_single_linkage.labels_\n\nplt.scatter(X[:, 0], X[:, 1], c=labels, s=50, cmap='viridis')","e1ed3d3b":"X = np.array(dataset_flame) \nn_clusters = int(max(dataset_flame['Z']))\n\nplt.scatter(X[:, 0], X[:, 1], c=np.array(dataset_flame['Z']), s=50, cmap='viridis')","fcfb2990":"clf_kmeans = KMeans(n_clusters=n_clusters, random_state=0)\nclf_kmeans.fit(X)\n\nlabels = clf_kmeans.labels_\n\nplt.scatter(X[:, 0], X[:, 1], c=labels, s=50, cmap='viridis')","971adfef":"clf_single_linkage = AgglomerativeClustering(n_clusters = n_clusters, linkage = 'single')\nclf_single_linkage.fit(X)\n\nlabels = clf_single_linkage.labels_\n\nplt.scatter(X[:, 0], X[:, 1], c=labels, s=50, cmap='viridis')","96ac9b3c":"X = np.array(dataset_pathbased) \nn_clusters = int(max(dataset_pathbased['Z']))\n\nplt.scatter(X[:, 0], X[:, 1], c=np.array(dataset_pathbased['Z']), s=50, cmap='viridis')","a1716b52":"clf_kmeans = KMeans(n_clusters=n_clusters, random_state=0)\nclf_kmeans.fit(X)\n\nlabels = clf_kmeans.labels_\n\nplt.scatter(X[:, 0], X[:, 1], c=labels, s=50, cmap='viridis')","a821b6bb":"clf_single_linkage = AgglomerativeClustering(n_clusters = n_clusters, linkage = 'single')\nclf_single_linkage.fit(X)\n\nlabels = clf_single_linkage.labels_\n\nplt.scatter(X[:, 0], X[:, 1], c=labels, s=50, cmap='viridis')","a39cba30":"* ### **Single Linkage**","78497403":"## **Dataset D31**","3b9793d8":"* ### **KMeans**","483b299d":"## **Dataset Agreggation**","6dd9dc6a":"* ### **KMeans**","8bcfbd30":"- ### **Resultado**\n\n#### Para o seguinte dataset, ambos os algoritmos foram muito bem, gerando um resultado quase igual ao esperado, neste caso definiria como empate em rela\u00e7\u00e3o aos agrupamentos obtidos.","7e90f692":"* ### **Single Linkage**","fac7148d":"- ### **KMeans**","0f513797":"- ### **Resultado**\n\n#### Para o seguinte dataset, assim como foi no dataset anterior, a diferen\u00e7a entre os dois algoritmos tamb\u00e9m foi bem expl\u00edcita, o KMeans novamente conseguiu encontrar todos os clusters esperados, enquanto o Single Linkage obteve mais uma vez um cluster dominante, sendo assim, o KMeans novamente nos retornou o melhor agrupamento.","2ed8a16e":"- ### **Resultado**\n\n#### Para o seguinte dataset, os dois algoritmos n\u00e3o tiveram bons resultados, apesar de gerarem o mesmo esqueleto, e ambos bem parecidos com o esqueleto do gr\u00e1fico esperados, os grupos est\u00e3o diferentes. Visualmente, analisando os dois gr\u00e1ficos gerados, acredito que o Single Linkage teve uma pequena vantagem.","a176e2dc":"## **Dataset Pathbased**","dac23fc3":"- ### **Resultado**\n\n#### Para o seguinte dataset, a diferen\u00e7a entre os dois algoritmos ficou bastante expl\u00edcita, enquanto o KMeans conseguiu dividir bem os elementos nos dois clusters encontrados, no Single Linkage o grupo em amarelo apareceu como outliers, sendo que o outro cluster foi dominante, portanto, fica claro que o KMeans realizou o melhor agrupamento.","4f53a6bc":"* ### **Single Linkage**","c82c131c":"* ### **KMeans**","2928fe11":"- ### **Single Linkage**","06321253":"## **Dataset Flame**"}}