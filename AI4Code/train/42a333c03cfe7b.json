{"cell_type":{"752e0ba3":"code","45f760ea":"code","1ebd7ee0":"code","715ec052":"code","f8f62cc8":"code","179c5db2":"code","f2738a4d":"code","3d3f2731":"code","2789b944":"code","3a2011de":"code","b02133cb":"code","330d1990":"code","e6d3d9c8":"code","9518a4b6":"code","07b25b36":"code","965c23ef":"code","43caee43":"code","3302b2b1":"code","2cc837d5":"code","afd921d8":"code","2dd3bc9f":"code","441421eb":"code","581590d3":"code","aa0d83b8":"code","32e7baaf":"code","37b10ed5":"code","448eea5a":"code","6f5b9f50":"code","585ab9ab":"code","5975259f":"code","e91e2b87":"code","6ec5130d":"code","eda36bbe":"code","f6941fa8":"code","f3014fb0":"code","4e7ad655":"code","b7bb5fa5":"code","62ddb7a2":"code","e9b4331c":"code","8138a6c2":"code","105b648e":"code","3593432c":"code","b77fb08c":"code","70cb3d6c":"code","e57ca1a3":"code","0bad9b4b":"code","f53ba96c":"code","bda79c96":"code","14b1bbcc":"code","6c54d240":"code","f9e68800":"code","2f41f9d6":"code","f0fec1b2":"code","3cc18a76":"code","58146243":"code","3b921b59":"code","473a60c1":"code","6ab1f4b4":"code","7110bf6f":"code","e8683759":"code","107df914":"code","eb48e923":"code","0a3107fd":"code","e2b04767":"code","23bd2e51":"code","5c3e43a4":"code","f1418a6d":"code","857ca7e6":"code","b7d80fb1":"code","4d520eaa":"code","539b1113":"code","4ffa6437":"code","49c46575":"code","5c2ae80b":"code","78b5a6d2":"code","8071b8c0":"code","f57af3c9":"code","4ef93d2e":"code","ec126e8b":"markdown","8b3eaf67":"markdown","d0db7ac4":"markdown","c8c6dcdb":"markdown","07c17f0d":"markdown","643a1f83":"markdown","d98ba500":"markdown","ab0693d2":"markdown","07dc17ad":"markdown","1ac9a0fa":"markdown","fa8d6259":"markdown","61c992de":"markdown","d9c67cce":"markdown","0bba3de7":"markdown","45492858":"markdown","c38726ce":"markdown","6bb37fb4":"markdown","337fa6a8":"markdown","475431df":"markdown","3df92356":"markdown","fe07ae47":"markdown","aa79e740":"markdown","14ee5f86":"markdown","aa28112b":"markdown","f10a6c48":"markdown","aa35385e":"markdown","face6cf5":"markdown","8f527298":"markdown","acd95bb3":"markdown","83db3986":"markdown","25da1779":"markdown","65039d44":"markdown","f30c8129":"markdown","a0377186":"markdown","d5d592a8":"markdown","00ac70a9":"markdown","50a995f0":"markdown","b0d0957c":"markdown","6b76f29e":"markdown"},"source":{"752e0ba3":"country_main = 'Ukraine'","45f760ea":"import os\nimport io\nimport pandas as pd\nimport numpy as np\nimport requests\nimport seaborn as sns\nimport openpyxl\nimport matplotlib\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\n\nfrom datetime import date, timedelta, datetime\nfrom fbprophet import Prophet\nfrom fbprophet.make_holidays import make_holidays_df\nfrom fbprophet.diagnostics import cross_validation, performance_metrics\nfrom fbprophet.plot import plot_cross_validation_metric\nimport holidays\nfrom collections import Counter\nimport pycountry\n\nfrom PIL import Image\nfrom IPython.display import FileLink\n\nimport warnings\nwarnings.simplefilter('ignore')","1ebd7ee0":"# Thank to https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ukraine-daily-data\n#data = pd.read_csv(\"..\/input\/covid19-in-ukraine-daily-data\/COVID-19-in-Ukraine-from-April.csv\")\n#data = data[103:]\n#data","715ec052":"# Thanks https:\/\/api-covid19.rnbo.gov.ua\/\nfor filename in ['main-data?mode=ukraine&fbclid=IwAR1vNXEE0nkmorUmGP4StG4cLrj1Z9VoX3c3Bi8dfltr0elgOj4b0M3ONvk']:\n    print(f'Download daily data from RNBO of Ukraine')\n    url = f'https:\/\/api-covid19.rnbo.gov.ua\/charts\/{filename}'\n    myfile = requests.get(url)\n    open(filename, 'wb').write(myfile.content)\n    \ndata = pd.read_json('main-data?mode=ukraine&fbclid=IwAR1vNXEE0nkmorUmGP4StG4cLrj1Z9VoX3c3Bi8dfltr0elgOj4b0M3ONvk')\ndata","f8f62cc8":"data['n_confirmed'] = data['deaths'].diff()\ndata = data[179:].reset_index(drop=True)\ndata['n_confirmed'] = data['n_confirmed'].astype('int')\ndata","179c5db2":"data['n_confirmed'].plot()","f2738a4d":"df2 = data[['dates','n_confirmed']].dropna()\ndf2 = df2[df2['n_confirmed'] > 0].reset_index(drop=True)\ndf2['n_confirmed'].plot()","3d3f2731":"# The new data (probable value)\nn = len(df2)\ndf2.loc[n, 'dates'] = '2020-12-07'\ndf2.loc[n, 'n_confirmed'] = 145","2789b944":"df2['n_confirmed'] = df2['n_confirmed'].rolling(7).mean()\ndf2['n_confirmed'].plot()","3a2011de":"# As in my original notebook https:\/\/www.kaggle.com\/vbmokin\/covid-19-in-ukraine-prophet-holidays-tuning\ndf2.columns = ['Date', 'Confirmed']\ndf2['Country'] = 'Ukraine'","b02133cb":"# latest_date = df2['Date'].max()\n# latest_date","330d1990":"df2.tail(20)","e6d3d9c8":"# Thanks to dataset https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries\nholidays_df = pd.read_csv('..\/input\/covid19-holidays-of-countries\/holidays_df_of_70_countries_for_covid_19.csv')\nholidays_df[holidays_df['country'] == country_main]","9518a4b6":"holidays_df_code_countries = holidays_df['code'].unique()\nholidays_df_code_countries","07b25b36":"# From notebook https:\/\/www.kaggle.com\/vbmokin\/covid-19-prophet-forecast-next-2-weeks\ndef dict_code_countries_with_holidays(list_name_countries: list,\n                                      holidays_df: pd.DataFrame()):\n        \n    \"\"\"\n    Defines a dictionary with the names of user countries and their two-letter codes (ISO 3166) \n    in the dataset \"COVID-19: Holidays of countries\" \n    \n    Returns: \n    - countries: dictionary with the names of user countries and their two-letter codes (ISO 3166) \n    - holidays_df_identificated: DataFrame with holidays data for countries from dictionary 'countries'\n    \n    Args: \n    - list_name_countries: list of the name of countries (name or common_name or official_name or alha2 or alpha3 codes from ISO 3166)\n    - holidays_df: DataFrame with holidays \"COVID-19: Holidays of countries\"\n    \"\"\"\n    \n    import pycountry\n    \n    # Identification of countries for which there are names according to ISO\n    countries = {}\n    dataset_all_countries = list(holidays_df['code'].unique())\n    list_name_countries_identificated = []\n    list_name_countries_not_identificated = []\n    for country in list_name_countries:\n        try: \n            country_id = pycountry.countries.get(alpha_2=country)\n            if country_id.alpha_2 in dataset_all_countries:\n                countries[country] = country_id.alpha_2\n        except AttributeError:\n            try: \n                country_id = pycountry.countries.get(name=country)\n                if country_id.alpha_2 in dataset_all_countries:\n                    countries[country] = country_id.alpha_2\n            except AttributeError:\n                try: \n                    country_id = pycountry.countries.get(official_name=country)\n                    if country_id.alpha_2 in dataset_all_countries:\n                        countries[country] = country_id.alpha_2\n                except AttributeError:\n                    try: \n                        country_id = pycountry.countries.get(common_name=country)\n                        if country_id.alpha_2 in dataset_all_countries:\n                            countries[country] = country_id.alpha_2\n                    except AttributeError:\n                        try: \n                            country_id = pycountry.countries.get(alpha_3=country)\n                            if country_id.alpha_2 in dataset_all_countries:\n                                countries[country] = country_id.alpha_2\n                        except AttributeError:\n                            list_name_countries_not_identificated.append(country)\n    holidays_df_identificated = holidays_df[holidays_df['code'].isin(countries.values())]\n    \n    print(f'Thus, the dataset has holidays in {len(countries)} countries from your list with {len(list_name_countries)} countries')\n#     if len(countries) == len(dataset_all_countries):\n#         print('All available in this dataset holiday data is used')\n#     else:\n#         print(\"Holidays are available in the dataset for such countries (if there are countries from your list, then it's recommended making changes to the list)\")\n#         print(np.array(holidays_df[~holidays_df['code'].isin(countries.values())].country_official_name.unique()))\n        \n    return countries, holidays_df_identificated.reset_index(drop=True)","965c23ef":"countries_dict, holidays_df_base = dict_code_countries_with_holidays([country_main],holidays_df)\ncountries_dict","43caee43":"holidays_df_base['ds'] = holidays_df_base['ds'].apply(lambda x: (datetime.strptime(x, \"%Y-%m-%d\")+timedelta(days = 14)).strftime(\"%Y-%m-%d\"))\nholidays_df_base['type'] = 'holiday'\nholidays_df = holidays_df_base.copy()\nholidays_df","3302b2b1":"# From https:\/\/www.kaggle.com\/vbmokin\/covid-19-prophet-forecast-next-2-weeks\ndef adaption_df_to_holidays_df_for_prophet(df, col, countries_dict):\n    # Adaptation the dataframe df (by column=col) to holidays_df by list of countries in dictionary countries_dict\n    \n    # Filter df for countries which there are in the dataset with holidays\n    df = df[df[col].isin(list(countries_dict.keys()))].reset_index(drop=True)\n    \n    # Add alpha_2 (code from ISO 3166) for each country\n    df['iso_alpha'] = None\n    for key, value in countries_dict.items():\n        df.loc[df[col] == key, 'iso_alpha'] = value    \n    \n    return df","2cc837d5":"df2 = adaption_df_to_holidays_df_for_prophet(df2, 'Country', countries_dict)\ndf2.columns = ['Date', 'Confirmed', 'Country', 'iso_alpha']\ndf2","afd921d8":"country_iso_alpha = df2.loc[0,'iso_alpha']\ncountry_iso_alpha","2dd3bc9f":"def aux_holidays_df_generator(holidays_df, dates_list, name, source, window_size, shift7=True):\n    # Add dates from dates_list with anomalies of various kinds to the holiday dataset holidays_df\n    # name - the name of the anomaly\n    # source - the source of the primary information used for processing\n    \n    last_row = len(holidays_df)\n    if shift7:\n        holidays_dates = holidays_df['ds_holidays'].tolist()\n    else: holidays_dates = holidays_df['ds'].tolist()\n    common_dates = list(set(holidays_dates).intersection(set(dates_list)))\n    dates_list = list(set(dates_list).difference(set(common_dates)))\n        \n    for i in range(len(dates_list)):\n        holidays_df = holidays_df.append([holidays_df.loc[last_row-1,:]], ignore_index=True)\n        ds_dt = datetime.strptime(dates_list[i], '%Y-%m-%d')\n        holidays_df.loc[last_row+i, 'ds_holidays'] = dates_list[i]\n        holidays_df.loc[last_row+i, 'holiday'] = name\n        \n        if shift7:\n            # Make shift with 7 day ahead\n            holidays_df.loc[last_row+i, 'ds'] = (ds_dt + timedelta(days=14)).strftime('%Y-%m-%d')\n        else:\n            # Don't make shift with 7 day ahead\n            holidays_df.loc[last_row+i, 'ds'] = ds_dt.strftime('%Y-%m-%d')\n            \n        holidays_df.loc[last_row+i, 'source'] = source\n        holidays_df.loc[last_row+i, 'lower_window'] = -window_size\n        holidays_df.loc[last_row+i, 'upper_window'] = window_size\n    \n        # Type of holidays or pseudo-holidays\n        if name == 'the weakening of quarantine':\n            holidays_df.loc[last_row+i, 'type'] = 'SI'\n        elif name == 'Very comfortable conditions for rest':\n            holidays_df.loc[last_row+i, 'type'] = 'meteo'\n        elif name == 'Holidays as days of less efficient work of laboratories':\n            holidays_df.loc[last_row+i, 'type'] = 'lab'\n    \n    holidays_df[holidays_df['ds_holidays'].isin(dates_list)]['lower_window'] = -window_size\n    holidays_df[holidays_df['ds_holidays'].isin(dates_list)]['upper_window'] = window_size\n        \n    return holidays_df.sort_values(by=['ds'])","441421eb":"def plot_with_anomalies(df, cols_y_list, cols_y_list_name, dates_x, col_anomalies, val_anomal, log_y=False):\n    # Draws a plot with title - the features cols_y_list (y) and dates_x (x) from the dataframe df\n    # and with vertical lines in the date with col_anomalies == 1 \n    # with the length between the minimum and maximum of feature cols_y_list[0]\n    # with log_y = False or True\n    # cols_y_list - dictionary of the names of cols from cols_y_list (keys - name of feature, value - it's name for the plot legend), \n    # name of cols_y_list[0] is the title of the all plot\n    \n    fig = px.line(df, x=dates_x, y=cols_y_list[0], title=cols_y_list_name[cols_y_list[0]], log_y=log_y, template='gridon',width=700, height=800)\n    y_max = df[cols_y_list[0]].max()\n    for i in range(len(cols_y_list)-1):\n        fig.add_trace(go.Scatter(x=df[dates_x], y=df[cols_y_list[i+1]], mode='lines', name=cols_y_list_name[cols_y_list[i+1]]))\n        max_i = df[cols_y_list[i+1]].max()\n        y_max = max_i if max_i > y_max else y_max\n    \n    anomal_dates_list = df[df[col_anomalies] == val_anomal][dates_x].tolist()\n    y_min = min(df[cols_y_list[0]].min(),0)\n    for i in range(len(anomal_dates_list)):\n        anomal_date = anomal_dates_list[i]\n        fig.add_shape(dict(type=\"line\", x0=anomal_date, y0=y_min, x1=anomal_date, y1=y_max, line=dict(color=\"red\", width=1)))\n    fig.show()","581590d3":"# Thank to https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data\ndata = pd.read_csv(f\"https:\/\/storage.googleapis.com\/covid19-open-data\/v2\/UA\/main.csv\")","aa0d83b8":"data['stringency_index_jump'] = 0\nfor i in range(len(data)-1):\n    if (data.loc[i+1,'stringency_index'] is not None) and (data.loc[i,'stringency_index'] is not None) and (data.loc[i+1,'stringency_index'] < data.loc[i,'stringency_index']):\n        data.loc[i+1, 'stringency_index_jump'] = 1\nsource_gov = 'https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker'\ndates_gov_list = data[data['stringency_index_jump'] == 1]['date'].tolist()\nholidays_df = aux_holidays_df_generator(holidays_df, dates_gov_list, 'the weakening of quarantine', source_gov, 2)\nplot_with_anomalies(data, [\"stringency_index\"], {\"stringency_index\" : \"Stringency index and dates of the weakening of quarantine in \" + country_main}, 'date', 'stringency_index_jump', 1)","32e7baaf":"data.columns.tolist()","37b10ed5":"data['rest_comfort'] = 0\ndata.loc[(data['average_temperature'] >= data['average_temperature'].quantile(.95)) & (data['rainfall'] <= data['rainfall'].quantile(.05)), 'rest_comfort'] = 1\ndates_weather_list = data[data['rest_comfort'] == 1]['date'].tolist()\nholidays_df = aux_holidays_df_generator(holidays_df, dates_weather_list, 'Very comfortable conditions for rest', 'https:\/\/www.ncei.noaa.gov\/', 2)\nplot_with_anomalies(data, [\"average_temperature\", \"rainfall\"], {\"average_temperature\" : \"Average temperature over time in \" + country_main, \"rainfall\" : \"rainfall\"}, 'date', 'rest_comfort', 1)","448eea5a":"df2.info()","6f5b9f50":"holidays_dates = holidays_df_base['ds_holidays'].tolist()\nholidays_dates","585ab9ab":"data['holidays_date'] = 0\nholidays_df = aux_holidays_df_generator(holidays_df, holidays_dates, 'Holidays as days of less efficient work of laboratories', \n                                        'https:\/\/github.com\/dr-prodigy\/python-holidays', 0, False)\nholidays_df","5975259f":"# pd.set_option('max_rows', 300)\n# df2","e91e2b87":"fig = px.line(df2, x=\"Date\", y=\"Confirmed\", \n              title=\"Confirmed cases in \" + country_main, \n              log_y=False,template='gridon',width=700, height=600)\nfig.show()","6ec5130d":"fig = px.line(df2, x=\"Date\", y=\"Confirmed\", \n              title=\"Confirmed cases (logarithmic scale) in \" + country_main, \n              log_y=True,template='gridon',width=700, height=600)\nfig.show()","eda36bbe":"df2['holiday'] = 0\nholidays_df_dates = holidays_df['ds'].tolist()\ndf2.loc[df2['Date'].isin(holidays_df_dates), 'holiday'] = 1\nplot_with_anomalies(df2, [\"Confirmed\"], {\"Confirmed\" : \"Confirmed cases and holidays data in \" + country_main}, 'Date', 'holiday', 1)\ndf2 = df2.drop(columns=['holiday'])","f6941fa8":"holidays_df_dates","f3014fb0":"df2.describe()","4e7ad655":"df2.head()","b7bb5fa5":"df2.tail()","62ddb7a2":"# For stage 1 of tuning\nchangepoint_prior_scale_initial_level = 0.15\nweekly_season_reg_coef = 0.75\nseveral_days_period = 4\nseveral_days_season_reg_coef = 0.5\nlower_window_list = [0, -1, -2, -3] # must be exactly 4 values (identical allowed)\nupper_window_list = [0, 1, 2, 3] # must be exactly 4 values (identical allowed)\nprior_scale_list = [1.5, 2, 2.5, 3] # must be exactly 4 values (identical allowed)\n\n# For stage 2 of tuning\nchangepoint_prior_scale_list = [0.15, 0.2, 0.25, 0.3] # must be exactly 4 values (identical allowed)\nweekly_fourier_order_list = [4, 8, 10, 12] # must be exactly 4 values (identical allowed), \nseveral_days_fourier_order_list = [0, 1, 2, 3] # must be exactly 4 values (identical allowed)\n# 0 in fourier_order lists means the absence of this component\n\n# Check length of lists\nif (len(lower_window_list) != 4) or (len(upper_window_list) != 4) or \\\n   (len(prior_scale_list) != 4) or (len(weekly_fourier_order_list) != 4) or (len(several_days_fourier_order_list) != 4):\n    print('Number of data is wrong!')","e9b4331c":"df2 = df2.drop(columns = ['Country', 'iso_alpha'])\ndf2.columns = ['ds','y']\ndf2","8138a6c2":"days_to_forecast = 14 # in future (after training data)\ndays_to_forecast_for_evalution = 14 # on the latest training data - for model training\nfirst_forecasted_date = sorted(list(set(df2['ds'].values)))[-days_to_forecast_for_evalution]\nend_forecasted_date = (datetime.strptime(df2['ds'].max(), \"%Y-%m-%d\")+timedelta(days = days_to_forecast)).strftime(\"%Y-%m-%d\")\nfirst_data_date = df2['ds'].min()\n\nprint('The first date of data for modeling is: ' + first_data_date)\nprint('The first date to perform forecasts for evaluation is: ' + first_forecasted_date)\nprint('The end date to perform forecasts in future for is: ' + end_forecasted_date)","105b648e":"def convert10_base4(n):\n    # convert decimal to base 4\n    alphabet = \"0123\"\n    if n < 4:\n        return alphabet[n]\n    else:\n        return (convert10_base4(n \/\/ 4) + alphabet[n % 4]).format('4f')","3593432c":"def export_plot_to_tiff(plot, fig_name):\n    DPI = 100 # this value controls the quality of final image\n    fig_name = \"{}.tiff\".format(fig_name)\n    buf = io.BytesIO()\n    try:\n        plot.figure.savefig(buf, format=\"png\", dpi=DPI)\n    except AttributeError:\n        plot.savefig(buf, format=\"png\", dpi=DPI)\n    else:\n        print(\"Function supports only objects that have savefig() method.\")\n        return\n    buf.seek(0)\n    im = Image.open(buf)\n    im.save(fig_name)\n    im.save(buf, format=\"tiff\")\n    buf.close()\n    return FileLink(fig_name)","b77fb08c":"def export_df_to_excel(df, sheet_name):\n    sheet_name = \"{}.xlsx\".format(sheet_name)\n    with pd.ExcelWriter(sheet_name, engine='openpyxl', date_format='yyyy-mm-dd') as writer:\n        df.to_excel(writer, index=False)\n    return FileLink(sheet_name)","70cb3d6c":"def export_forecast_to_excel(df, sheet_name):\n    df.ds = df.ds.apply(lambda row: row.strftime(\"%Y-%m-%d\"))\n    df.rename(columns={\n        \"ds\": \"\u0414\u0430\u0442\u0430\",\n        \"yhat_lower\": \"\u041d\u0438\u0436\u043d\u044f \u043c\u0435\u0436\u0430 \u0434\u043e\u0432\u0456\u0440\u0447\u043e\u0433\u043e \u0456\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0443, \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u043b\u0435\u0442\u0430\u043b\u044c\u043d\u0438\u0445 \u0432\u0438\u043f\u0430\u0434\u043a\u0456\u0432\",\n        \"yhat\": \"\u041f\u0440\u043e\u0433\u043d\u043e\u0437\u043e\u0432\u0430\u043d\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f, \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u043b\u0435\u0442\u0430\u043b\u044c\u043d\u0438\u0445 \u0432\u0438\u043f\u0430\u0434\u043a\u0456\u0432\",\n        \"yhat_upper\":  \"\u0412\u0435\u0440\u0445\u043d\u044f \u043c\u0435\u0436\u0430 \u0434\u043e\u0432\u0456\u0440\u0447\u043e\u0433\u043e \u0456\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0443, \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u043b\u0435\u0442\u0430\u043b\u044c\u043d\u0438\u0445 \u0432\u0438\u043f\u0430\u0434\u043a\u0456\u0432\"\n    }, inplace=True)\n    return export_df_to_excel(df, sheet_name)","e57ca1a3":"def make_forecasts(country_df, holidays_df, days_to_forecast, days_to_forecast_for_evalution, first_forecasted_date):\n    \n    def eval_error(forecast_df, country_df_val, first_forecasted_date, title):\n        # Evaluate forecasts with validation set val_df and calculaction and printing with title the relative error\n        forecast_df[forecast_df['yhat'] < 0]['yhat'] = 0\n        result_df = forecast_df[(forecast_df['ds'] >= pd.to_datetime(first_forecasted_date))]\n        result_val_df = result_df.merge(country_df_val, on=['ds'])\n        result_val_df['rel_diff'] = (result_val_df['y'] - result_val_df['yhat'].round()).abs()\n        relative_error = sum(result_val_df['rel_diff'].values)*100\/result_val_df['y'].sum()        \n        return relative_error\n    \n    def model_training_forecasting(df, forecast_days, holidays_df=None, mode_main='multiplicative'):\n        # Prophet model training and forecasting\n        \n        model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False, \n                        holidays=holidays_df, changepoint_range=1, changepoint_prior_scale = changepoint_prior_scale_initial_level,\n                        seasonality_mode = mode_main)\n        model.add_seasonality(name='weekly', period=7, fourier_order=8, mode = 'multiplicative', \n                              prior_scale = changepoint_prior_scale_initial_level\/weekly_season_reg_coef)\n        model.fit(df)\n        future = model.make_future_dataframe(periods=forecast_days)\n        forecast = model.predict(future)\n        forecast[forecast['yhat'] < 0]['yhat'] = 0\n        return model, forecast\n\n    cols_w = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'multiplicative_terms','multiplicative_terms_lower', 'multiplicative_terms_upper', 'weekly', 'weekly_lower', 'weekly_upper']\n    cols_h = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'holidays', 'holidays_lower', 'holidays_upper', 'multiplicative_terms','multiplicative_terms_lower', 'multiplicative_terms_upper', 'weekly',\n              'weekly_lower', 'weekly_upper']\n    mode_main_list = ['additive', 'multiplicative']\n    relative_errors_holidays = []\n    counter = 0\n    results = pd.DataFrame(columns=['Conf_real', 'Conf_pred', 'Conf_pred_h', 'mode', 'n_h', 'err', 'err_h', 'prior_scale', 'how_less, %'])\n    \n    country_holidays_df = holidays_df[holidays_df['code'] == country_iso_alpha][['ds', 'holiday', 'lower_window', 'upper_window', 'prior_scale', 'type']].reset_index(drop=True)\n    country_dfs = []            \n\n    # Data preparation for forecast with Prophet\n    country_df['ds'] = pd.to_datetime(country_df['ds'])\n\n    # Set training and validation datasets\n    country_df_future = country_df.copy()\n    country_df_val = country_df[(country_df['ds'] >= pd.to_datetime(first_forecasted_date))].copy()\n    country_df = country_df[(country_df['ds'] < pd.to_datetime(first_forecasted_date))]\n\n    n = 64 # number of combination of parameters lower_window \/ upper_window \/ prior_scale\n    for k in range(2):\n        # 'additive' and 'multiplicative' mode tuning\n        # Without holidays\n        # Model training and forecasting without holidays\n        model, forecast = model_training_forecasting(country_df, days_to_forecast_for_evalution, mode_main=mode_main_list[k])\n        #fig = model.plot_components(forecast)\n\n        # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n        forecast_df = forecast[['ds', 'yhat']].copy()\n        relative_error = eval_error(forecast_df, country_df_val, first_forecasted_date, 'without holidays')\n\n        # With holidays\n        # Model training with tuning prior_scale and forecasting\n        for i in range(n):\n            parameters_iter = convert10_base4(i).zfill(3)\n            lower_window_i = lower_window_list[int(parameters_iter[0])]\n            upper_window_i = upper_window_list[int(parameters_iter[1])]\n            prior_scale_i = prior_scale_list[int(parameters_iter[2])]\n            country_holidays_df.loc[country_holidays_df['type'] != 'lab', 'lower_window'] = lower_window_i\n            country_holidays_df.loc[country_holidays_df['type'] != 'lab', 'upper_window'] = upper_window_i\n            country_holidays_df.loc[country_holidays_df['type'] != 'lab', 'prior_scale'] = prior_scale_i\n            number_holidays = len(country_holidays_df[(country_holidays_df['ds'] > first_data_date) & (country_holidays_df['ds'] < end_forecasted_date)])\n            model_holidays, forecast_holidays = model_training_forecasting(country_df, days_to_forecast_for_evalution, country_holidays_df, \n                                                                           mode_main=mode_main_list[k])\n\n            # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n            forecast_holidays_df = forecast_holidays[['ds', 'yhat']].copy()\n            relative_error_holidays = eval_error(forecast_holidays_df, country_df_val, first_forecasted_date, 'with holidays impact')\n\n            # Save results\n            if (k == 0) and (i == 0):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                lower_window_best = lower_window_i\n                upper_window_best = upper_window_i\n                prior_scale_best = prior_scale_i\n                mode_best = mode_main_list[k]\n\n            elif (relative_error_holidays < relative_error_holidays_min):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                lower_window_best = lower_window_i\n                upper_window_best = upper_window_i\n                prior_scale_best = prior_scale_i\n                mode_best = mode_main_list[k]\n\n            # Save results to dataframe with result for the last date\n            confirmed_real_last = country_df_val.tail(1)['y'].values[0].astype('int')\n            results.loc[i+n*k,'Conf_real'] = confirmed_real_last if confirmed_real_last > 0 else 0\n            confirmed_pred_last = round(forecast_df.tail(1)['yhat'].values[0]).astype('int')\n            results.loc[i+n*k,'Conf_pred'] = confirmed_pred_last if confirmed_pred_last > 0 else 0\n            confirmed_pred_holidays_last = round(forecast_holidays_df_best.tail(1)['yhat'].values[0],0).astype('int')\n            results.loc[i+n*k,'Conf_pred_h'] = confirmed_pred_holidays_last if confirmed_pred_holidays_last > 0 else 0\n            results.loc[i+n*k,'mode'] = mode_main_list[k]\n            results.loc[i+n*k,'n_h'] = number_holidays\n            results.loc[i+n*k,'err'] = relative_error\n            results.loc[i+n*k,'err_h'] = relative_error_holidays\n            results.loc[i+n*k,'lower_window'] = lower_window_i\n            results.loc[i+n*k,'upper_window'] = upper_window_i\n            results.loc[i+n*k,'prior_scale'] = prior_scale_i\n            results.loc[i+n*k,'how_less, %'] = round((relative_error-relative_error_holidays)*100\/relative_error,1)\n\n            print('i =',i+n*k,' from',2*n-1,':  lower_window =', lower_window_i, 'upper_window =',upper_window_i, 'prior_scale =', prior_scale_i)\n            print('relative_error_holidays =',relative_error_holidays, 'relative_error_holidays_min =',relative_error_holidays_min, '\\n')\n\n        # Results visualization\n        print('Seasonality mode is', mode_main_list[k])\n        print('The best errors of model with holidays is', relative_error_holidays_min, 'with lower_window =', str(lower_window_best),\n              ' upper_window =', str(upper_window_best), ' prior_scale =', str(prior_scale_best))\n        print('The error of model without holidays is', relative_error, '\\n')\n\n    # Save results to dataframe with all dates\n    forecast_holidays_df_best['country'] = country_main\n    forecast_holidays_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)\n    forecast_holidays_dfs = forecast_holidays_df_best.tail(days_to_forecast_for_evalution)\n\n    # Forecasting the future\n    if relative_error < relative_error_holidays_min:\n        # The forecast without taking into account the holidays is the best\n        model_future_best, forecast_future_best = model_training_forecasting(country_df_future, days_to_forecast, mode_main=mode_best)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting without holidays) - ' + mode_main_list[k])\n        cols = cols_w\n        print('The best model is model without holidays')\n    else:\n        # The forecast taking into account the holidays is the best\n        print('The best model is model with holidays')\n        model_future_best, forecast_future_best = model_training_forecasting(country_df_future, days_to_forecast, holidays_df,\n                                                                             mode_main=mode_best)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting with holidays) - ' + mode_best)\n        cols = cols_h\n    # Save forecasting results \n    forecast_future_df_best = forecast_future_best[cols]\n    forecast_future_df_best['country'] = country_main\n    forecast_future_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)    \n    forecast_future_dfs = forecast_future_df_best.tail(days_to_forecast)\n    fig = model_future_best.plot_components(forecast_future_best)\n    return forecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results","0bad9b4b":"%%time\nforecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results = make_forecasts(df2, holidays_df, \n                                                                                               days_to_forecast, days_to_forecast_for_evalution, first_forecasted_date)","f53ba96c":"forecast_future_dfs.head(3)","bda79c96":"forecast_holidays_dfs.head(3)","14b1bbcc":"forecast_holidays_dfs.to_csv('forecast_holidays_dfs.csv', index=False)\nforecast_future_dfs.to_csv('forecast_future_dfs.csv', index=False)\nresults.to_csv('results.csv', index=False)","6c54d240":"# Visualization or results\nprint(f'5D plot of Prophet model parameters and COVID-19 error of forecasting to {str(days_to_forecast_for_evalution)} days')","f9e68800":"# Determination of the best parameters\nresults['err_h'] = results['err_h'].astype('float')\nresults['lower_window'] = results['lower_window'].astype('int')\nresults['upper_window'] = results['upper_window'].astype('int')\nresults_a = results[results['mode'] == 'additive']\nresults_m = results[results['mode'] == 'multiplicative']","2f41f9d6":"# Interactive plot with results of parameters tuning\nfig = px.scatter_3d(results_a, x='lower_window', y='upper_window', z='err_h',\n                     color='prior_scale', color_discrete_sequence= px.colors.sequential.Plasma_r, opacity=1,\n                    title='Interactive plot with results of parameters tuning for additive mode')\nfig.update(layout=dict(title=dict(x=0.5)))","f0fec1b2":"# Interactive plot with results of parameters tuning\nfig = px.scatter_3d(results_m, x='lower_window', y='upper_window', z='err_h',\n                     color='prior_scale', color_discrete_sequence= px.colors.sequential.Plasma_r, opacity=1,\n                    title='Interactive plot with results of parameters tuning for multiplicative mode')\nfig.update(layout=dict(title=dict(x=0.5)))","3cc18a76":"display(results_a.nsmallest(5, 'err_h'))\ndisplay(results_m.nsmallest(5, 'err_h'))","58146243":"# The smallest WAPE:\nbest_result = results.nsmallest(1, 'err_h').reset_index(drop=True)\nlower_window_opt = best_result.lower_window[0]\nupper_window_opt = best_result.upper_window[0]\nprior_scale_opt = best_result['prior_scale'][0]\nmode_opt = best_result['mode'][0]","3b921b59":"print(f\"Thus, for {country_main} the optimal parameters of Prophet model that gave an WAPE = {best_result['err_h'][0]} are:\")\nprint(\"* lower_window =\", lower_window_opt)\nprint(\"* upper_window =\", upper_window_opt)\nprint(\"* prior_scale =\", prior_scale_opt)\nprint(\"* mode_opt =\", mode_opt)","473a60c1":"holidays_df['lower_window'] = lower_window_opt\nholidays_df['upper_window'] = upper_window_opt\nholidays_df['prior_scale'] = prior_scale_opt","6ab1f4b4":"# The smallest WAPE:\ndisplay(best_result)","7110bf6f":"def make_forecasts_stage2(country_df, holidays_df, days_to_forecast, days_to_forecast_for_evalution, first_forecasted_date,\n                          mode_main='multiplicative'):\n    \n    def eval_error(forecast_df, country_df_val, first_forecasted_date, title):\n        # Evaluate forecasts with validation set val_df and calculaction and printing with title the relative error\n        forecast_df[forecast_df['yhat'] < 0]['yhat'] = 0\n        result_df = forecast_df[(forecast_df['ds'] >= pd.to_datetime(first_forecasted_date))]\n        result_val_df = result_df.merge(country_df_val, on=['ds'])\n        result_val_df['rel_diff'] = (result_val_df['y'] - result_val_df['yhat'].round()).abs()\n        relative_error = sum(result_val_df['rel_diff'].values)*100\/result_val_df['y'].sum()\n        return relative_error\n    \n    def model_training_forecasting(df, forecast_days, holidays_df=None, mode_main='multiplicative', \n                                  weekly_fourier_order=10, several_days_fourier_order=10,\n                                  changepoint_prior_scale = changepoint_prior_scale_initial_level, mode_seasonality = 'additive'):\n        # Prophet model training and forecasting\n        \n        model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False, \n                        holidays=holidays_df, changepoint_range=1, changepoint_prior_scale = changepoint_prior_scale,\n                        seasonality_mode = mode_main)\n        if weekly_fourier_order > 0:\n            model.add_seasonality(name='weekly', period=7, fourier_order=weekly_fourier_order, mode = mode_seasonality, \n                                  prior_scale = changepoint_prior_scale\/weekly_season_reg_coef)\n        if several_days_fourier_order > 0:\n            model.add_seasonality(name='several_days', period=several_days_period, fourier_order=several_days_fourier_order, mode = mode_seasonality, \n                                  prior_scale = changepoint_prior_scale\/several_days_season_reg_coef)\n        model.fit(df)\n        future = model.make_future_dataframe(periods=forecast_days)\n        forecast = model.predict(future)\n        forecast[forecast['yhat'] < 0]['yhat'] = 0\n        return model, forecast\n\n    \n    cols_w = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'multiplicative_terms','multiplicative_terms_lower', 'multiplicative_terms_upper']\n    cols_h = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'holidays', 'holidays_lower', 'holidays_upper', 'multiplicative_terms','multiplicative_terms_lower', 'multiplicative_terms_upper']\n    mode_seasonality_list = ['additive', 'multiplicative']\n    relative_errors_holidays = []\n    counter = 0\n    results = pd.DataFrame(columns=['Conf_real', 'Conf_pred', 'Conf_pred_h', 'mode_s', 'err', 'err_h', 'weekly_fn', 'several_days_fn', 'ch_p_s_fn', 'how_less, %'])\n    \n    country_dfs = []\n    # Data preparation for forecast with Prophet\n    country_df['ds'] = pd.to_datetime(country_df['ds'])\n\n    # Set training and validation datasets\n    country_df_future = country_df.copy()\n    country_df_val = country_df[(country_df['ds'] >= pd.to_datetime(first_forecasted_date))].copy()\n    country_df = country_df[(country_df['ds'] < pd.to_datetime(first_forecasted_date))]\n\n    n = 64 # number of combination of parameters weekly_fourier_order \/ several_days_fourier_order\n    relative_error_min = 100\n    for k in range(2):\n        # 'additive' and 'multiplicative' mode tuning\n        # Without holidays\n        # Model training and forecasting without holidays\n        model, forecast = model_training_forecasting(country_df, days_to_forecast_for_evalution, mode_main=mode_main,\n                                                     mode_seasonality = mode_seasonality_list[k])\n        #fig = model.plot_components(forecast)\n\n        # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n        forecast_df = forecast[['ds', 'yhat']].copy()\n        relative_error = eval_error(forecast_df, country_df_val, first_forecasted_date, 'without holidays')\n        mode_seasonality_w_best = mode_seasonality_list[1] if relative_error < relative_error_min else mode_seasonality_list[0]\n\n        # With holidays\n        # Model training with tuning prior_scale and forecasting\n        for i in range(n):\n            parameters_iter = convert10_base4(i).zfill(3)\n            weekly_fourier_order_i = weekly_fourier_order_list[int(parameters_iter[0])]\n            several_days_fourier_order_i = several_days_fourier_order_list[int(parameters_iter[1])]\n            changepoint_prior_scale_i = changepoint_prior_scale_list[int(parameters_iter[2])]\n            model_holidays, forecast_holidays = model_training_forecasting(country_df, days_to_forecast_for_evalution, \n                                                                           holidays_df, mode_main=mode_main,\n                                                                           weekly_fourier_order = weekly_fourier_order_i, \n                                                                           several_days_fourier_order = several_days_fourier_order_i,\n                                                                           changepoint_prior_scale = changepoint_prior_scale_i,\n                                                                           mode_seasonality = mode_seasonality_list[k])\n            \n            # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n            forecast_holidays_df = forecast_holidays[['ds', 'yhat']].copy()\n            relative_error_holidays = eval_error(forecast_holidays_df, country_df_val, first_forecasted_date, 'with holidays impact')\n\n            # Save results\n            if (k == 0) and (i == 0):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                weekly_fourier_order_best = weekly_fourier_order_i\n                several_days_fourier_order_best = several_days_fourier_order_i\n                changepoint_prior_scale_best = changepoint_prior_scale_i\n                mode_seasonality_best = mode_seasonality_list[k]\n\n            elif (relative_error_holidays < relative_error_holidays_min):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                weekly_fourier_order_best = weekly_fourier_order_i\n                several_days_fourier_order_best = several_days_fourier_order_i\n                changepoint_prior_scale_best = changepoint_prior_scale_i\n                mode_seasonality_best = mode_seasonality_list[k]\n\n            # Save results to dataframe with result for the last date\n            confirmed_real_last = country_df_val.tail(1)['y'].values[0].astype('int')\n            results.loc[i+n*k,'Conf_real'] = confirmed_real_last if confirmed_real_last > 0 else 0\n            confirmed_pred_last = round(forecast_df.tail(1)['yhat'].values[0]).astype('int')\n            results.loc[i+n*k,'Conf_pred'] = confirmed_pred_last if confirmed_pred_last > 0 else 0\n            confirmed_pred_holidays_last = round(forecast_holidays_df_best.tail(1)['yhat'].values[0],0).astype('int')\n            results.loc[i+n*k,'Conf_pred_h'] = confirmed_pred_holidays_last if confirmed_pred_holidays_last > 0 else 0\n            results.loc[i+n*k,'mode_s'] = mode_seasonality_list[k]\n            results.loc[i+n*k,'err'] = relative_error\n            results.loc[i+n*k,'err_h'] = relative_error_holidays\n            results.loc[i+n*k,'weekly_fn'] = weekly_fourier_order_i\n            results.loc[i+n*k,'several_days_fn'] = several_days_fourier_order_i\n            results.loc[i+n*k,'ch_p_s_fn'] = changepoint_prior_scale_i\n            results.loc[i+n*k,'how_less, %'] = round((relative_error-relative_error_holidays)*100\/relative_error,1)\n\n            print('i =',i+n*k,' from',2*n-1,':  weekly_fourier_order =', weekly_fourier_order_i, 'several_days_fourier_order =', several_days_fourier_order_i,\n                  'changepoint_prior_scale =', changepoint_prior_scale_i)\n            print('relative_error_holidays =',relative_error_holidays, 'relative_error_holidays_min =',relative_error_holidays_min, '\\n')\n\n        # Results visualization\n        print('Seasonality mode is', mode_seasonality_list[k])\n        print('The best errors of model with holidays is', relative_error_holidays_min,\n              'weekly_fourier_order =', weekly_fourier_order_i, 'several_days_fourier_order =', several_days_fourier_order_i,\n              'changepoint_prior_scale =', changepoint_prior_scale_i)\n        print('The error of model without holidays is', relative_error, '\\n')\n\n    # Save results to dataframe with all dates\n    forecast_holidays_df_best['country'] = country_main\n    forecast_holidays_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)\n    forecast_holidays_dfs = forecast_holidays_df_best.tail(days_to_forecast_for_evalution)\n\n    # Forecasting the future\n    if relative_error < relative_error_holidays_min:\n        # The forecast without taking into account the holidays is the best\n        model_future_best, forecast_future_best = model_training_forecasting(country_df, days_to_forecast_for_evalution, mode_main=mode_main,\n                                                                             mode_seasonality = mode_seasonality_w_best)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting without holidays) - ' + mode_seasonality_w_best)\n        cols = cols_w\n        print('The best model is model without holidays')\n    else:\n        # The forecast taking into account the holidays is the best\n        print('The best model is model with holidays')\n        model_future_best, forecast_future_best = model_training_forecasting(country_df, days_to_forecast_for_evalution, \n                                                                             holidays_df, mode_main=mode_main,\n                                                                             weekly_fourier_order = weekly_fourier_order_best, \n                                                                             several_days_fourier_order = several_days_fourier_order_best,\n                                                                             changepoint_prior_scale = changepoint_prior_scale_i,\n                                                                             mode_seasonality = mode_seasonality_best)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting with holidays) - ' + mode_seasonality_best)\n        cols = cols_h\n    # Save forecasting results \n    forecast_future_df_best = forecast_future_best[cols]\n    forecast_future_df_best['country'] = country_main\n    forecast_future_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)    \n    forecast_future_dfs = forecast_future_df_best.tail(days_to_forecast)\n    fig = model_future_best.plot_components(forecast_future_best)\n    return forecast_future_df_best, forecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results","e8683759":"%%time\nforecast_future_df_best, forecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results = make_forecasts_stage2(df2, holidays_df, days_to_forecast, days_to_forecast_for_evalution, first_forecasted_date, mode_main=mode_opt)","107df914":"forecast_future_df_best.to_csv('forecast_future_df_best.csv', index=False)\nforecast_holidays_dfs.to_csv('forecast_holidays_dfs2.csv', index=False)\nforecast_future_dfs.to_csv('forecast_future_dfs2.csv', index=False)\nresults.to_csv('results2.csv', index=False)","eb48e923":"results","0a3107fd":"# Visualization or results\nprint(f'3D plot of Prophet model parameters and COVID-19 error of forecasting to {str(days_to_forecast_for_evalution)} days')","e2b04767":"# Determination of the best parameters\nresults['err_h'] = results['err_h'].astype('float')\nresults['weekly_fn'] = results['weekly_fn'].astype('int')\nresults['several_days_fn'] = results['several_days_fn'].astype('int')\nresults_a = results[results['mode_s'] == 'additive']\nresults_m = results[results['mode_s'] == 'multiplicative']","23bd2e51":"results_a","5c3e43a4":"# Interactive plot with results of parameters tuning - additive\nfig = px.scatter_3d(results_a, x='weekly_fn', y='several_days_fn', z='err_h',\n                    color='ch_p_s_fn', color_discrete_sequence= px.colors.sequential.Plasma_r, opacity=1,\n                    title='Interactive plot with results of parameters tuning for additive mode')\nfig.update(layout=dict(title=dict(x=0.5)))","f1418a6d":"# Interactive plot with results of parameters tuning - multiplicative\nfig = px.scatter_3d(results_m, x='weekly_fn', y='several_days_fn', z='err_h',\n                    color='ch_p_s_fn', color_discrete_sequence= px.colors.sequential.Plasma_r, opacity=1,\n                    title='Interactive plot with results of parameters tuning for multiplicative mode')\nfig.update(layout=dict(title=dict(x=0.5)))","857ca7e6":"display(results_a.nsmallest(5, 'err_h'))\ndisplay(results_m.nsmallest(5, 'err_h'))","b7d80fb1":"# The smallest WAPE:\nbest_result2 = results.nsmallest(1, 'err_h').reset_index(drop=True)\nweekly_fourier_order_opt = best_result2.weekly_fn[0]\nseveral_days_fourier_order_opt = best_result2.several_days_fn[0]\nmode_seasonality_opt = mode_seasonality_weekly_opt = mode_seasonality_several_days_opt = best_result2['mode_s'][0]\nchangepoint_prior_scale_opt = best_result2['ch_p_s_fn'][0]\nweekly_seasonality_prior_scale_opt = changepoint_prior_scale_opt\/weekly_season_reg_coef\nseveral_days_seasonality_prior_scale_opt = changepoint_prior_scale_opt\/several_days_season_reg_coef","4d520eaa":"# The smallest WAPE:\ndisplay(best_result2)","539b1113":"print(f\"Thus, for {country_main} the optimal 11 parameters of Prophet model that gave an WAPE = {best_result2.err_h[0]} are:\")\nprint(\"* lower_window =\", lower_window_opt)\nprint(\"* upper_window =\", upper_window_opt)\nprint(\"* prior_scale =\", prior_scale_opt)\nprint(\"* changepoint_prior_scale =\", changepoint_prior_scale_opt)\nprint(\"* mode_opt =\", mode_opt)\nprint(\"* weekly_fourier_order =\", weekly_fourier_order_opt)\nprint(\"* mode_seasonality_weekly =\", mode_seasonality_weekly_opt)\nprint(\"* weekly_seasonality_prior_scale =\", weekly_seasonality_prior_scale_opt)\nprint(\"* several_days_fourier_order =\", several_days_fourier_order_opt)\nprint(\"* mode_seasonality_several_days =\", mode_seasonality_several_days_opt)\nprint(\"* several_days_seasonality_prior_scale =\", several_days_seasonality_prior_scale_opt)","4ffa6437":"def model_training_forecasting(df, forecast_days, holidays_df=None, mode_main='multiplicative', \n                               weekly_fourier_order=10, several_days_fourier_order=10, \n                               changepoint_prior_scale = changepoint_prior_scale_initial_level, mode_seasonality = 'additive'):\n    # Optimal Prophet model training and forecasting\n\n    model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False, \n                    holidays=holidays_df, changepoint_range=1, changepoint_prior_scale = changepoint_prior_scale,\n                    seasonality_mode = mode_main)\n    if weekly_fourier_order > 0:\n        model.add_seasonality(name='weekly', period=7, fourier_order=weekly_fourier_order, mode = mode_seasonality, \n                              prior_scale = changepoint_prior_scale\/weekly_season_reg_coef)\n    if several_days_fourier_order > 0:\n        model.add_seasonality(name='several_days', period=several_days_period, fourier_order=several_days_fourier_order, mode = mode_seasonality, \n                              prior_scale = changepoint_prior_scale\/several_days_season_reg_coef)\n    model.fit(df)\n    future = model.make_future_dataframe(periods=forecast_days)\n    forecast = model.predict(future)\n    \n    forecast[forecast['yhat'] < 0]['yhat'] = 0\n    forecast['yhat_lower'] = forecast['yhat_lower'].round().astype('int')\n    forecast['yhat'] = forecast['yhat'].round().astype('int')\n    forecast['yhat_upper'] = forecast['yhat_upper'].round().astype('int')\n    \n    return model, forecast","49c46575":"model_future_opt, forecast_future_opt = model_training_forecasting(df2, days_to_forecast, holidays_df, mode_main=mode_opt,\n                                                                   weekly_fourier_order = weekly_fourier_order_opt, \n                                                                   several_days_fourier_order = several_days_fourier_order_opt,\n                                                                   changepoint_prior_scale = changepoint_prior_scale_opt,\n                                                                   mode_seasonality = mode_seasonality_opt)","5c2ae80b":"fig_opt = model_future_opt.plot(forecast_future_opt)\nexport_df_to_excel(forecast_future_opt, 'forecast_future_opt_death')\nexport_plot_to_tiff(fig_opt, 'fig_forecast_future_opt_death')","78b5a6d2":"fig_components = model_future_opt.plot_components(forecast_future_opt)\nexport_plot_to_tiff(fig_components, 'fig_forecast_future_opt_components_death')","8071b8c0":"forecast_future_opt_future = forecast_future_opt[['ds', 'yhat_lower', 'yhat', 'yhat_upper']]\nforecast_future_opt_future_days = forecast_future_opt_future.tail(days_to_forecast)\nforecast_future_opt_future_days","f57af3c9":"export_forecast_to_excel(forecast_future_opt_future_days, 'forecast_future_opt_future_days_death')","4ef93d2e":"forecast_future_opt_future.to_csv('forecast_future_opt_future.csv', index=False)\nbest_result2.to_csv('best_result2.csv', index=False)\nholidays_df.to_csv('holidays_df_all.csv', index=False)","ec126e8b":"## Latest Cases","8b3eaf67":"#### Thanks to https:\/\/api-covid19.rnbo.gov.ua\/","d0db7ac4":"# Dataset [COVID-19 in Ukraine: daily data](https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ukraine-daily-data)","c8c6dcdb":"## Earliest Cases","07c17f0d":"## 6. Prediction <a class=\"anchor\" id=\"6\"><\/a>\n\n[Back to Table of Contents](#0.1)","643a1f83":"## 5.1.2. Results visualization<a class=\"anchor\" id=\"5.1.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","d98ba500":"There are many studies in the field of coronavirus forecasting. Many researchers use **Prophet** (from Facebook). But for some reason, no one takes into account the holidays impact. After all, despite all the prohibitions, it is difficult for people to stay at home and they still somehow celebrate the **holidays** to which they are accustomed. The desire to celebrate is especially strong when people are sitting at home all the time looking for something to do. In my opinion, the impact of the holidays is manifested in the fact that within 14-20 days after these holidays there may be a jump in the number of confirmed cases, due to the fact that people went shopping, and even visiting each other, perhaps even in violation of quarantine requirements. \n\nThe Prophet uses the library [holidays](https:\/\/github.com\/dr-prodigy\/python-holidays) with information about the main holidays of 67 countries, but and its package has some disadvantages. That's why I created a more perfect own dataset and plan to update it periodically. Now **my dataset [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries) has holidays for 70 countries** and more adapted for use in the prediction of coronavirus diseases.\n\nHolidays and pseudo-holidays (**anomalies dates**) are defined in three ways:\n- dates of official public holidays;\n- the weakening of quarantine according to open data;\n- dates of very comfortable conditions for rest (there are more 95% quantile on average temperature and not more 5% quantile of rainfall) - for each country it should be adapted individually (open data NOAA are used)\n\nThe model is **tuning in two stages** - makes a complete search of values from 4 possible for each feature at first for one part of parameters, then - for another. In the second stage, the optimal parameters determined in the first stage are used. Each stage ends with an interactive graph (library \"plotly\"), which clearly shows the WAPE for each combination of parameters.\n\nThe Prophet model with all optimized parameters and holidays is used for **forecasting** future data for the next days and visualization of forecasting results. The data is taken from [COVID-19 Open Data](https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data) (usually this dataset are updated there daily and are available as of yesterday), so the next days are counted from the date of the last committee of this notebook.","ab0693d2":"### 3.2.2. Very comfortable conditions for rest <a class=\"anchor\" id=\"3.2.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","07dc17ad":"I hope you find this kernel useful and enjoyable.","1ac9a0fa":"## Describe statistics","fa8d6259":"## 5.2.2. Results visualization<a class=\"anchor\" id=\"5.2.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","61c992de":"<a class=\"anchor\" id=\"0.1\"><\/a>\n## Table of Contents\n\n1. [Import libraries](#1)\n1. [Download data](#2)\n1. [Selection data with holidays](#3)\n    - [Holidays with a shift](#3.1)\n    - [Additional dates of anomalies as holidays](#3.2)    \n        - [The weakening of quarantine](#3.2.1)\n        - [Very comfortable conditions for rest](#3.2.2)\n        - [Holidays as days of less efficient work of laboratories](#3.2.3)        \n1. [EDA](#4)\n    - [Plots - Confirmed cases over time](#4.1)\n    - [Statistics](#4.2)\n    - [Set initial values for tuning](#4.3)\n1. [Tuning Prophet model and holidays parameters](#5)\n    - [Stage 1 - Tuning holiday parameters](#5.1)\n        - [Model training, forecasting and evaluation](#5.1.1)\n        - [Results visualization](#5.1.2)\n    - [Stage 2 - Tuning seasonality parameters](#5.2)\n        - [Model training, forecasting and evaluation](#5.2.1)\n        - [Results visualization](#5.2.2)\n    - [Results of all tuning](#5.3)\n1. [Prediction](#6)","d9c67cce":"## 5.2. Stage 2 - Tuning seasonality parameters<a class=\"anchor\" id=\"5.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","0bba3de7":"## 5.1.1. Model training, forecasting and evaluation<a class=\"anchor\" id=\"5.1.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","45492858":"## 2. Download data<a class=\"anchor\" id=\"2\"><\/a>\n\n[Back to Table of Contents](#0.1)","c38726ce":"### 3.2.1. The weakening of quarantine<a class=\"anchor\" id=\"3.2.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","6bb37fb4":"## 5.2.1. Model training, forecasting and evaluation<a class=\"anchor\" id=\"5.2.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","337fa6a8":"<a class=\"anchor\" id=\"0\"><\/a>\n# COVID-19 in Ukraine: EDA & Forecasting with holidays impact for death cases. Prophet with holidays and pseudo-holidays - 11 parameters tuning:\n* lower_window\n* upper_window\n* prior_scale\n* mode\n* changepoint_prior_scale\n* weekly_fourier_order\n* mode_seasonality_weekly\n* weekly_seasonality_prior_scale\n* several_days_fourier_order (for period = n days, n = 2, 3, ... 6)\n* mode_seasonality_several_days\n* several_days_seasonality_prior_scale","475431df":"## 5. Tuning Prophet model and holidays parameters<a class=\"anchor\" id=\"5\"><\/a>\n\n[Back to Table of Contents](#0.1)","3df92356":"#### Thanks to [COVID-19 in Ukraine: daily data](https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ukraine-daily-data)","fe07ae47":"### We will select only the last wave: from the middle of July","aa79e740":"[Go to Top](#0)","14ee5f86":"## 3.1. Holidays with a shift<a class=\"anchor\" id=\"3.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","aa28112b":"Your comments and feedback are most welcome.","f10a6c48":"# Acknowledgements\n\n### Datasets:\n- my dataset [COVID-19 in Ukraine: daily data](https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ukraine-daily-data) - only up to commit 11\n- official data of Ukraine (https:\/\/covid19.rnbo.gov.ua\/) - from commit 12 via API\n- dataset [COVID-19 Open Data](https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data) (including dataset [Oxford COVID-19 government response tracker](https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker) and dataset [NOAA](https:\/\/www.ncei.noaa.gov\/)) : @article{Wahltinez2020,author = \"Oscar Wahltinez and Matt Lee and Anthony Erlinger and Mayank Daswani and Pranali Yawalkar and Kevin Murphy and Michael Brenner\", year = 2020, title = \"COVID-19 Open-Data: curating a fine-grained, global-scale data repository for SARS-CoV-2\", note = \"Work in progress\",  url = {https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data},} \n- my dataset with holidays data [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries) - it is recommended to follow the updates\n\n### Notebooks:\n- notebook [COVID-19-in-Ukraine: Prophet & holidays tuning](https:\/\/www.kaggle.com\/vbmokin\/covid-19-in-ukraine-prophet-holidays-tuning)\n- notebook [COVID-19 Novel Coronavirus EDA & Forecasting Cases](https:\/\/www.kaggle.com\/khoongweihao\/covid-19-novel-coronavirus-eda-forecasting-cases) from [@Wei Hao Khoong](https:\/\/www.kaggle.com\/khoongweihao)\n\n### Libraries from GitHub:\n- https:\/\/facebook.github.io\/prophet\/\n- https:\/\/facebook.github.io\/prophet\/docs\/\n- https:\/\/github.com\/facebook\/prophet\n- https:\/\/github.com\/dr-prodigy\/python-holidays","aa35385e":"## 5.3. Results of all tuning<a class=\"anchor\" id=\"5.3\"><\/a>\n\n[Back to Table of Contents](#0.1)","face6cf5":"### Thank to dataset [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries)","8f527298":"## 4. EDA<a class=\"anchor\" id=\"4\"><\/a>\n\n[Back to Table of Contents](#0.1)","acd95bb3":"## 3. Selection data with holidays<a class=\"anchor\" id=\"3\"><\/a>\n\n[Back to Table of Contents](#0.1)","83db3986":"## 1. Import libraries<a class=\"anchor\" id=\"1\"><\/a>\n\n[Back to Table of Contents](#0.1)","25da1779":"## 5.1. Stage 1 - Tuning holiday parameters<a class=\"anchor\" id=\"5.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","65039d44":"## 4.2. Statistics<a class=\"anchor\" id=\"4.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","f30c8129":"#### Thanks to:\n* [COVID-19 Open Data](https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data)\n* [NOAA](https:\/\/www.ncei.noaa.gov\/)","a0377186":"#### Thanks to [Oxford COVID-19 government response tracker](https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker)","d5d592a8":"## 4.3. Set initial values for tuning<a class=\"anchor\" id=\"4.3\"><\/a>\n\n[Back to Table of Contents](#0.1)","00ac70a9":"## 4.1. Plots - Confirmed cases over time<a class=\"anchor\" id=\"4.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","50a995f0":"## 3.2. Additional dates of anomalies as holidays<a class=\"anchor\" id=\"3.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","b0d0957c":"### 3.2.3. Holidays as days of less efficient work of laboratories <a class=\"anchor\" id=\"3.2.3\"><\/a>\n\n[Back to Table of Contents](#0.1)","6b76f29e":"Import libraries"}}