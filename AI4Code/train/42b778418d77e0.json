{"cell_type":{"12945a4f":"code","60807817":"code","fd5d4c9f":"code","e1b70245":"code","a1e2c7ae":"code","991c3a6b":"code","243148b7":"code","9411089a":"code","4b98d23f":"code","ee6b123b":"code","e391d580":"code","8ab5f321":"code","6f9e5917":"code","4d30c429":"code","86b27a12":"code","8dc7f74d":"code","65b8d166":"code","46328ed2":"code","582ae95b":"code","cfbf4379":"code","58f7878f":"code","f1c60e75":"code","7a5e6fd2":"code","b391ee36":"code","1b53344a":"code","6a4a271e":"code","595bdfe3":"code","92c253fb":"code","b7dad664":"code","7cc53e53":"code","3e6cd973":"markdown","e280265c":"markdown","31c829df":"markdown","cfbb1230":"markdown","8949815c":"markdown","1f9de14c":"markdown","68a02207":"markdown","d6e9c247":"markdown","1364319d":"markdown","237696d0":"markdown","6b0a0cd6":"markdown","11dbc5f5":"markdown","6ee9d718":"markdown","f9058c97":"markdown","df154165":"markdown","66a0e55c":"markdown","01fe9bef":"markdown","6929c5b4":"markdown","14831c1d":"markdown","67df3b26":"markdown","b3f1867a":"markdown","358de24c":"markdown"},"source":{"12945a4f":"import os\nimport re\nimport string\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nfrom nltk.tokenize import WordPunctTokenizer\nfrom nltk.corpus import stopwords\nfrom nltk.stem import SnowballStemmer\n\nfrom sklearn.feature_extraction.text import CountVectorizer","60807817":"df_yelp_business = pd.read_json('..\/input\/yelp_academic_dataset_business.json', lines=True)\ndf_yelp_business.fillna('NA', inplace=True)\n# we want to make sure we only work with restaurants -- nothing else\ndf_yelp_business = df_yelp_business[df_yelp_business['categories'].str.contains('Restaurants')]\nprint('Final Shape: ',df_yelp_business.shape)","fd5d4c9f":"df_yelp_review_iter = pd.read_json('..\/input\/yelp_academic_dataset_review.json', chunksize=100000, lines=True)","e1b70245":"df_yelp_review = pd.DataFrame()\ni=0\nfor df in df_yelp_review_iter:\n    df = df[df['business_id'].isin(df_yelp_business['business_id'])]\n    df_yelp_review = pd.concat([df_yelp_review, df])\n    i=i+1\n    print(i)\n    if i==4: break","a1e2c7ae":"df_yelp_business = df_yelp_business[df_yelp_business['business_id'].isin(df_yelp_review['business_id'])]","991c3a6b":"print('Final businesses shape: ', df_yelp_business.shape)\nprint('Final review shape: ', df_yelp_review.shape)","243148b7":"def clean_text(text):\n    ## Remove puncuation\n    text = text.translate(string.punctuation)\n    \n    ## Convert words to lower case and split them\n    text = text.lower().split()\n    \n    ## Remove stop words\n    stops = set(stopwords.words(\"english\"))\n    text = [w for w in text if not w in stops and len(w) >= 3]\n    \n    text = \" \".join(text)\n    \n    # Clean the text\n    text = re.sub(r\"[^A-Za-z0-9^,!.\\\/'+-=]\", \" \", text)\n    text = re.sub(r\"what's\", \"what is \", text)\n    text = re.sub(r\"\\'s\", \" \", text)\n    text = re.sub(r\"\\'ve\", \" have \", text)\n    text = re.sub(r\"n't\", \" not \", text)\n    text = re.sub(r\"i'm\", \"i am \", text)\n    text = re.sub(r\"\\'re\", \" are \", text)\n    text = re.sub(r\"\\'d\", \" would \", text)\n    text = re.sub(r\"\\'ll\", \" will \", text)\n    text = re.sub(r\",\", \" \", text)\n    text = re.sub(r\"\\.\", \" \", text)\n    text = re.sub(r\"!\", \" ! \", text)\n    text = re.sub(r\"\\\/\", \" \", text)\n    text = re.sub(r\"\\^\", \" ^ \", text)\n    text = re.sub(r\"\\+\", \" + \", text)\n    text = re.sub(r\"\\-\", \" - \", text)\n    text = re.sub(r\"\\=\", \" = \", text)\n    text = re.sub(r\"'\", \" \", text)\n    text = re.sub(r\"(\\d+)(k)\", r\"\\g<1>000\", text)\n    text = re.sub(r\":\", \" : \", text)\n    text = re.sub(r\" e g \", \" eg \", text)\n    text = re.sub(r\" b g \", \" bg \", text)\n    text = re.sub(r\" u s \", \" american \", text)\n    text = re.sub(r\"\\0s\", \"0\", text)\n    text = re.sub(r\" 9 11 \", \"911\", text)\n    text = re.sub(r\"e - mail\", \"email\", text)\n    text = re.sub(r\"j k\", \"jk\", text)\n    text = re.sub(r\"\\s{2,}\", \" \", text)    \n    return text","9411089a":"%%time\ndf_yelp_review['text'] = df_yelp_review['text'].apply(clean_text)","4b98d23f":"vectorizer_reviews = CountVectorizer(min_df = .01,max_df = .99, tokenizer = WordPunctTokenizer().tokenize)\nvectorized_reviews = vectorizer_reviews.fit_transform(df_yelp_review['text'])","ee6b123b":"print(vectorized_reviews.shape)","e391d580":"' | '.join(vectorizer_reviews.get_feature_names()[:100]) # only the first 100","8ab5f321":"vectorizer_categories = CountVectorizer(min_df = 1, max_df = 1., tokenizer = lambda x: x.split(', '))\nvectorized_categories = vectorizer_categories.fit_transform(df_yelp_business['categories'])","6f9e5917":"print(vectorized_categories.shape)","4d30c429":"' | '.join(vectorizer_categories.get_feature_names()[:100]) # only the first 100","86b27a12":"%%time\nfrom scipy import sparse\nbusinessxreview = sparse.csr_matrix(pd.get_dummies(df_yelp_review['business_id']).values)","8dc7f74d":"print('restuarants x categories: \\t', vectorized_categories.shape) \nprint('restuarants x reviews: \\t\\t' , businessxreview.shape) \nprint('reviews x words: \\t\\t', vectorized_reviews.shape)","65b8d166":"# to choose a restaurant, just copy the business id and paste it in the next cell\n# you can always rerun the cell to choose another restuarant. \ndf_yelp_business.sample(10)","46328ed2":"business_choose = 'aUrOyWFKxKeVXiFzwbTXSA' # vegan, vegetarian, cafes","582ae95b":"new_reviews = df_yelp_review.loc[df_yelp_review['business_id'] == business_choose, 'text']","cfbf4379":"print('\\n'.join([r[:100] for r in new_reviews.tolist()])) # restaurant reviews","58f7878f":"new_categories = df_yelp_business.loc[df_yelp_business['business_id'] == business_choose, 'categories']","f1c60e75":"new_categories.tolist() #  restaurant categories","7a5e6fd2":"from scipy.spatial.distance import cdist\n# find most similar reviews\ndists1 = cdist(vectorizer_reviews.transform(new_reviews).todense().mean(axis=0), \n              vectorized_reviews.T.dot(businessxreview).T.todense(), \n               metric='correlation')\n# find most similar categories\ndists2 = cdist(vectorizer_categories.transform(new_categories).todense().mean(axis=0), \n              vectorized_categories.todense(), \n               metric='correlation')","b391ee36":"# combine the two vectors in one matrix\ndists_together = np.vstack([dists1.ravel(), dists2.ravel()]).T","1b53344a":"dists_together","6a4a271e":"# this is a key cell: how are we going to prioritize ?\ndists = dists_together.mean(axis=1)","595bdfe3":"dists","92c253fb":"# select the closest 10\nclosest = dists.argsort().ravel()[:10]","b7dad664":"df_yelp_business.loc[df_yelp_business['business_id']== business_choose, ['business_id', 'categories', 'name', 'stars']]","7cc53e53":"df_yelp_business.loc[df_yelp_business['business_id'].isin(df_yelp_business['business_id'].iloc[closest]), ['business_id', 'categories', 'name', 'stars']]","3e6cd973":"Then we pull up the categories:","e280265c":"Let's begin by importing libraries and making sure we only deal with valid data.","31c829df":"Now we want to vectorize both reviews and categories. Note that min_df and max_df arguments in both.","cfbb1230":"Sometimes, you don't want Yelp to recommend \"similar\" restaurants per se, but rather restaurants that worth exploring given your rating of the current restaurant. The problem with many recommendation systems including those in popular apps is their focus on *similarity* -- not the differences. Ultimately, however, I don't want to eat the same or have the same experience, but rather I would like to find a \"surprisingly good\" restaurant that may be a little different. This notion might be a bit hard to quantify, but in this tutorial, I would like to explore very simple techniques for doing this using Yelp Dataset.","8949815c":"Let's select the closest 10 restaurants to the seed restaurant.","1f9de14c":"Here, we compute two sets of distancecs: we compute the correlation distance of the average vectorized reviews to all the reviews, and compute the correlation distance between this category and all other categories. The category trick will be clearer when we see the results.","68a02207":"Because reviews are too big, we will read them in chunks, and make sure we delete reviews of places that are not in our list of businesses filtered earlier. Note here we choose 5 chunks, but we could have chosen any number (larger numbers will give MemoryError later on).","d6e9c247":"Let's print out the shapes of the matrices we have prepared and make sure they make sense (by matching their dimensions):","1364319d":"Although many of those seem to come from the same category (Vegetarian and Vegan), there is a considerable variation in those categories (Ethiopian, African, Asian Fusion, .. etc). Most importantly, they all seem highly rated.\n\nWould you go and try those out and be little surprised ? It is really up to you.","237696d0":"Now we combine the two sets of distances and take the average of those (we can take other metrics such as min or max, depending on your priority).","6b0a0cd6":"Now we are ready to choose a seed restaurant and find  other restaurants that might be as good as the seed restaurant. We make sure to choose a restaurant with good number of reviews and ratings.","11dbc5f5":"The next step will apply those transformations. Note that it will take a couple of minutes to finish.","6ee9d718":"Also make sure we only get businesses that already show up in our review list and delete the rest.","f9058c97":"Now we want to processes reviews in a reasonable way. The following function is adopted from [here](https:\/\/github.com\/msahamed\/yelp_comments_classification_nlp\/blob\/master\/word_embeddings.ipynb) which really does a good deal to preprocess the text.","df154165":"Show top 100 vocabularies:","66a0e55c":"Here is our seed restaurant:","01fe9bef":"We also show 100 categories..","6929c5b4":"We will explore the techniques later in details, but here I would like to highlight the core idea: First, we want to find a way to represent reviews using a bag-of-words representation. After doing so, we will also represent categories using a one-hot encoding representation. Then, we can manipulate those representations to find similarities and differences while balancing the weights of the two. Note that the core idea assume that you are more likely to love a restaurant if its reviews are similar to the reviews of the restaurants you already love.","14831c1d":"Now we bring the reviews and perform some preprocessing on those reviews..","67df3b26":"Now let's see what the top matches:","b3f1867a":"We will use sparse representations to make dot products easier to speed up dot products (and also save memory).","358de24c":"First, we pull up the reivews and then show some of them"}}