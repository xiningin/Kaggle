{"cell_type":{"238b51a0":"code","818c0cec":"code","f28b1078":"code","b488ec92":"code","3f531246":"code","006ccce1":"code","ddcaa6bf":"code","2a45b469":"code","f4183c73":"code","d2515b4a":"code","d10b4b8d":"code","c88a619d":"code","340f06fe":"code","808c66b9":"code","bc156b85":"code","6278f548":"code","3ddf777c":"code","5e43208f":"code","9ed5b5b4":"code","d81fb26a":"code","e8ed1451":"code","9b5040c2":"code","d5c0871f":"code","54f28d44":"markdown","822e1226":"markdown","5bb1e874":"markdown","a1c11103":"markdown","b7f026c7":"markdown","00f252da":"markdown","26b14602":"markdown","3b889104":"markdown","04d1481d":"markdown","63b001d6":"markdown","2435a56c":"markdown","0c36592a":"markdown","0024dde9":"markdown","ba232c17":"markdown","b4526e0a":"markdown","2d8f0a02":"markdown","ff5f47c5":"markdown","2e5d2e31":"markdown","57819146":"markdown","ac40d402":"markdown","1471fa07":"markdown","70445874":"markdown","2102256f":"markdown","f5c5070b":"markdown","c236bdef":"markdown","2c50a5d8":"markdown","464e68aa":"markdown","70f94eb0":"markdown"},"source":{"238b51a0":"from IPython.core.display import HTML\nHTML(\"\"\"\n<style>\n.output_png {\n    display: table-cell;\n    text-align: center;\n    vertical-align: middle;\n    horizontal-align: middle;\n}\nimg {\n    width:500px;\n    height:500px;\n    vertical-align: middle;\n    horizontal-align: middle;\n    display: table-cell;\n    text-align: center;\n}\nh1,h2 {\n    text-align: center;\n    background-color: #f7786b;\n    border : 5px solid red;\n    padding: 20px;\n    margin: 0;\n    color: white;\n    font-family: ariel;\n    border-radius: 80px;\n    border-color: black;\n}\n\nh3 {\n    text-align: center;\n    border-style: solid;\n    border-width: 3px;\n    padding: 12px;\n    margin: 0;\n    color: black;\n    font-family: ariel;\n    border-radius: 80px;\n    border-color: gold;\n}\n\nbody, p {\n    font-family: ariel;\n    font-size: 15px;\n    color: charcoal;\n}\ndiv {\n    font-size: 14px;\n    margin: 0;\n\n}\n\nh4 {\n    padding: 0px;\n    margin: 0;\n    font-family: ariel;\n    color: purple;\n}\n<\/style>\n\"\"\")","818c0cec":"import plotly.graph_objects as go\nimport numpy as np\nimport pandas as pd\nfrom plotly.colors import n_colors\nfrom plotly.subplots import make_subplots\nimport plotly.figure_factory as ff\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import StratifiedKFold, train_test_split\nimport plotly.express as px\nfrom sklearn.metrics import confusion_matrix, classification_report, accuracy_score","f28b1078":"df = pd.read_csv('..\/input\/water-potability\/water_potability.csv')","b488ec92":"df.head()","3f531246":"df.shape","006ccce1":"df.describe()","ddcaa6bf":"from sklearn.preprocessing import StandardScaler\nsc = StandardScaler()\ndf_1 = sc.fit_transform(df.iloc[:, :-1])\ndf_scaled = pd.DataFrame(df_1, columns = df.columns[:-1])\ndf_scaled['Potability'] = df['Potability']","2a45b469":"df_scaled.head()","f4183c73":"columns = df.columns","d2515b4a":"fig = go.Figure()\n\ncolors = n_colors('rgb(5, 200, 200)', 'rgb(200, 10, 10)', 9, colortype='rgb')\nfor idx, color in enumerate(colors):\n    fig.add_trace(go.Violin(x=df_scaled[df_scaled['Potability']==1][columns[idx]]-idx\/4, line_color=color, name=columns[idx], showlegend=False, hoverinfo='skip'))\n\nfig.update_traces(orientation='h', side='positive', width=3, points=False)\nfig.update_layout(yaxis_showgrid=False, xaxis_zeroline=False, template='ggplot2', title_text='Distribution of features (Potability=1)')\nfig.update_xaxes(showticklabels=False, title='Potable', showgrid=False)\nfig.show()","d10b4b8d":"fig = go.Figure()\n\ncolors = n_colors('rgb(5, 200, 200)', 'rgb(200, 10, 10)', 9, colortype='rgb')\nfor idx, color in enumerate(colors):\n    fig.add_trace(go.Violin(x=df_scaled[df_scaled['Potability']==0][columns[idx]]+idx\/4, line_color=color, name=columns[idx], showlegend=False, hoverinfo='skip'))\n\nfig.update_traces(orientation='h', side='positive', width=3, points=False)\nfig.update_layout(yaxis_showgrid=False, xaxis_zeroline=False, template='ggplot2', title_text='Distribution of features (Potability=0)')\nfig.update_xaxes(showticklabels=False, title='Not Potable', showgrid=False)\nfig.show()","c88a619d":"index_vals = df['Potability'].astype('category').cat.codes\nfig = go.Figure(data=go.Splom(\n                dimensions=[dict(label=columns[idx],\n                                 values=df[columns[idx]]) for idx in range(10)],\n                showupperhalf=False,\n                text=df['Potability'],\n                marker=dict(color=index_vals,\n                            showscale=False, \n                            line_color='pink', line_width=0.7), hoverinfo='skip'\n                ))\n\n\nfig.update_layout(\n    title='Scatter Matrix',\n    width=1200,\n    height=1200,\n    template='ggplot2'\n)\n\nfig.show()","340f06fe":"fig = go.Figure(data=go.Heatmap(\n    z=df.corr(),\n    x=df.columns,\n    y=df.columns,\n    colorscale='mint'\n))\nfig.update_layout(\n    title='Correlation Matrix',\n    template='ggplot2',\n    width=1000,\n    height=1000,\n    yaxis_autorange='reversed'\n)\nfig.show()","808c66b9":"z=(df_scaled.T).fillna(999999)\n\nfig = go.Figure(data=go.Heatmap(\n    z=z,\n    y=df.columns, showscale=False,\n    colorscale='purples'\n))\nfig.update_layout(\n    title='Missing Values',\n    template='ggplot2'\n)\nfig.update_xaxes(showticklabels=False, showgrid=False)\nfig.show()","bc156b85":"df.fillna(np.mean(df), inplace=True)","6278f548":"df_cat = df.copy()","3ddf777c":"\nfig = make_subplots(rows=5, cols=2)\nidx=0\nlegend=[True]+[False]*8\nfor i in range(5):\n    for j in range(2):\n        try:\n            fig.add_trace(go.Violin(y=df[df['Potability']==0][columns[idx]], box_visible=True, line_color='black',\n                                    meanline_visible=True, fillcolor='pink', opacity=0.6, showlegend=legend[idx],\n                                    x0=columns[idx], side='negative', name='Not Potable', hoverinfo='skip'), row=i+1, col=j+1)\n            fig.add_trace(go.Violin(y=df[df['Potability']==1][columns[idx]], box_visible=True, line_color='black',\n                                    meanline_visible=True, fillcolor='lightgreen', opacity=0.6, showlegend=legend[idx],\n                                    x0=columns[idx], side='positive', name='Potable', hoverinfo='skip'), row=i+1, col=j+1)\n            fig.update_yaxes(showgrid=False, zeroline=False)\n            idx+=1\n        except Exception:\n            pass\n\nfig.update_traces(meanline_visible=False, points=False)\nfig.update_layout(height=3000, width=1200, violingap=0.5, violinmode='overlay',\n                  title_text=\"Distribution of Features (Violin+Box)\")\n\nfig.show()","5e43208f":"### Potability ###\ndf_cat['color'] = df['Potability']\npotability = []\nfor v in df.Potability:\n    if v==1:\n        potability.append('Potable')\n    else:\n        potability.append('Not Potable')\ndf_cat['Potability'] = potability \n\n### pH ###\nph = []\nfor v in df.ph:\n    if v>8 and v<=11:\n        ph.append('Alkaline')\n    elif v<6 and v>=3:\n        ph.append('Acidic')\n    elif v<3:\n        ph.append('Highly Acidic')\n    elif v>11:\n        ph.append('Highly Alkaline')\n    elif v==7:\n        ph.append('Neutral')\n    else:\n        ph.append('Almost Neutral')\ndf_cat['ph'] = ph  \n \n### Hardness ###\nhardness = []\nfor v in df.Hardness:\n    if v<=60:\n        hardness.append('Soft')\n    elif v<=120:\n        hardness.append('Moderately Hard')\n    elif v<=180:\n        hardness.append('Hard')\n    elif v>180:\n        hardness.append('Very Hard')\n        \ndf_cat['Hardness'] = hardness  \n\n### Solids ###\nsolids = []\nfor v in df.Solids:\n    if v<=150:\n        solids.append('Very Low')\n    elif v<=250:\n        solids.append('Low')\n    elif v<=300:\n        solids.append('Moderate')\n    elif v<=500:\n        solids.append('High')\n    elif v<=900:\n        solids.append('Very High')\n    else:\n        solids.append('Extremely High')\ndf_cat['Solids'] = solids \n\n\n### Chloramine ###\nchloramine = []\nfor v in df.Chloramines:\n    if v<=4:\n        chloramine.append('Acceptable')\n    else:\n        chloramine.append('Unacceptable')\ndf_cat['Chloramines'] = chloramine \n\n### Chloramine ###\nsulfate = []\nfor v in df.Sulfate:\n    if v<=250:\n        sulfate.append('Acceptable')\n    else:\n        sulfate.append('Unacceptable')\ndf_cat['Sulfate'] = sulfate \n\n### Conductivity ###\nconductivity = []\nfor v in df.Conductivity:\n    if v<=1500:\n        conductivity.append('Consumable')\n    else:\n        conductivity.append('Non Consumable')\ndf_cat['Conductivity'] = conductivity \n\n### Organic_carbon ###\noc = []\nfor v in df.Organic_carbon:\n    if v<=20:\n        oc.append('Consumable')\n    else:\n        oc.append('Non Consumable')\ndf_cat['Organic_carbon'] = oc ","9ed5b5b4":"\nfig = px.parallel_categories(df_cat, dimensions=['ph', 'Hardness', 'Solids', 'Chloramines', 'Sulfate', 'Conductivity', 'Organic_carbon', 'Potability'],\n                color=\"color\", color_continuous_scale='reds')\nfig.update_layout(\n    title='Connection Between Features',\n    template='ggplot2'\n)\nfig.show()","d81fb26a":"def create_fold(df, num_folds):\n    skf = StratifiedKFold(n_splits=num_folds, shuffle=True, random_state=42)\n    for f , (k, v) in enumerate(skf.split(X=df, y=df.Potability)):\n        df.loc[v , \"kfold\"] = int(f)\n    df[\"kfold\"] = df[\"kfold\"].astype(int)\n    return df","e8ed1451":"def train(df, fold):\n    print('-'*50)\n    print(f'Fold : {fold}')\n    print('-'*50)\n    traindf = df[df['kfold']!=fold]\n    validdf = df[df['kfold']==fold]\n    xtrain = traindf.drop(['Potability', 'kfold'], axis=1).values\n    ytrain = traindf['Potability'].values\n    \n    xvalid = validdf.drop(['Potability', 'kfold'], axis=1).values\n    yvalid = validdf['Potability'].values\n    \n    xtest = testdf.drop(['Potability'], axis=1).values\n    ytest = testdf['Potability'].values\n    \n    rf = RandomForestClassifier()\n    \n    rf.fit(xtrain, ytrain)\n    \n    pred = rf.predict(xvalid)\n    acc = accuracy_score(pred, yvalid)\n    test = rf.predict(xtest)\n    print()\n    print(f'Model f1 Score : {rf.score(xvalid, yvalid):.2f}')\n    print()\n    print(f'OOF accuracy : {acc:.2f}')\n    print()\n    print(f'Test set accuracy : {accuracy_score(test, ytest):.2f}')\n    print()\n    print('Classification Report (OOF):')\n    print()\n    print(classification_report(pred, yvalid))\n    print()\n    print('Confusion Matrix (OOF):')\n    z = confusion_matrix(pred, yvalid)\n    fig = ff.create_annotated_heatmap(z, x=['Potable', 'Not Potable'], y=['Potable', 'Not Potable'],\n                                      colorscale='greys', hoverinfo='skip')\n    fig.update_layout(width=300, height=300, yaxis_autorange='reversed', template='ggplot2')\n    fig.show()\n    \n    return pred, yvalid, test","9b5040c2":"df = df.fillna(np.mean(df))\ntraindf, testdf = train_test_split(df, test_size=0.2)\ntrain_5folds = create_fold(traindf.reset_index(drop=True), 5)","d5c0871f":"all_preds = []\nall_true = []\nensembled_test = []\nfor fold in range(5):\n    pred, true, test = train(train_5folds, fold)\n    all_preds.append(np.hstack(pred))\n    all_true.append(np.hstack(true))\n    ensembled_test.append(np.array(test)\/5)\nall_preds = np.hstack(all_preds)\nall_true = np.hstack(all_true)\nprint('='*50)\nprint('Overall :')\nprint('='*50)\nprint(f'Overall accuracy : {accuracy_score(all_preds, all_true):.2f}')\nprint()\nprint(classification_report(all_preds, all_true))\nprint()\nprint('Confusion Matrix :')\nz = confusion_matrix(all_preds, all_true)\nfig = ff.create_annotated_heatmap(z, x=['Potable', 'Not Potable'], y=['Potable', 'Not Potable'],\n                                  colorscale='mint', hoverinfo='skip')\nfig.update_layout(width=300, height=300, yaxis_autorange='reversed', template='ggplot2')\nfig.show()\n\nprint('='*60)\nprint(f'Ensemble accuracy on the test set : {np.round(accuracy_score(sum(ensembled_test)>=0.5, testdf.Potability), 2)}')\nprint('='*60)","54f28d44":"So there are significant number of missing values for **Trihalomethanes**, **Sulfate** and **pH**. We need to think of how to fill out missing data :) For now I will be using the mean value to fill up. You can refer to other notebooks regarding different techniques on filling up missing data.","822e1226":"# <span style=\"color:white;font-size:38px;font-family:arial;\">2. Scatter Matrix<\/span>","5bb1e874":"#### Training function for each fold","a1c11103":"To see the correlation between the features we will plot a Scatter matrix. This matrix consists of several graphs (all scatter plots) taking any 2 features as the axes. We can observe the behaviour of the features and how it affects the result (Potability). ","b7f026c7":"![EDA](https:\/\/user-images.githubusercontent.com\/74188336\/143453528-2442d6f4-c07d-4c34-a05c-780095ebecf3.gif)","00f252da":"Let's check out the missing values...","26b14602":"![EDA (1)](https:\/\/user-images.githubusercontent.com\/74188336\/143454613-af02b6d7-1339-4b53-9253-0c4af81e0a41.gif)\n","3b889104":"Let's check out the correlation matrix, so see the value of correlation. A correlation value of >0.8 is considered to be good.","04d1481d":"#### Let's try building a model (using RF picked at random)","63b001d6":"# <span style=\"color:white;font-size:38px;font-family:arial;\">1. Scaling down for distribution plots<\/span>","2435a56c":"# <span style=\"color:white;font-size:38px;font-family:arial;\">6. Model Training<\/span>","0c36592a":"### <span style=\"color:red;font-size:38px;font-family:arial;\">If you like it please UPVOTE :)<\/span>","0024dde9":"### Observations\n\n* **pH :** Mostly potable solutions have neutral pH. Some are a little acidic and some a little alkaline.\n* **Hardness :** Hard and very hard water are considered potable (**higher the hardness more potable**)\n* **Solids (ppm) :** Seems like **lower** the dissolved solids concentration better it is suited for drinking.\n* **Sulfate, Conductivity, Organic_carbon :** **Lower** the value **better** suited for drinking\n\nThis shows some kind of relation between the features and potability. The single lines that doesn't seem to follow the trend are either outliers or noisy data.\n\nThe reasons for outliers, noisy data and missing values are caused due to human error, machine mal-functioning, caliberation error and other physical factors that cannot be avoided. Dropping outliers results in much stable model. But since there is scarcity of data, we will be using the whole dataset. Moreover, this notebook isn't focussed on model building, rather on **Exploratory Data Analysis**.","ba232c17":"# <span style=\"color:white;font-size:38px;font-family:arial;\">4. Distribution plots (with Box Plots)<\/span>","b4526e0a":"#### Filling missing values and splitting into folds","2d8f0a02":"### <span style=\"color:green;font-size:38px;font-family:arial;\">Checking out missing values<\/span>","ff5f47c5":"We observed that the data for different features are widely ranged and their distributions cannot be compared on a single scale. So we will be Scaling down the data (Standardizing) so that the distributions can be compared. Some features are in the range of 100s some in 10ks. This operation will bring down the scale in the range of ~ -3 to +3.\n\nI have show 2 different distribution plots (one for potable water and one for non potable water)\n\nAlso, we observe there are some missing values. We will be handling them in a later part.","2e5d2e31":"Seems like there isn't much of a visible relation between the features. The data points are mostly randomly scattered in the space. This might be the result of noisy data, or data that isn't much correlated with the result. This might lead to bad performing models.","57819146":"## <span style=\"color:white;font-size:38px;font-family:arial;\">5. Categorial Plot (Parallel Categories)<\/span>","ac40d402":"# Content\n\n\n1. Scaling down for distribution plots\n2. Scatter Matrix\n3. Correlation Matrix\n4. Distribution Plots (with Box Plots)\n5. Categorial Plot (Parallel Categories)\n6. Model Training","1471fa07":"Nothing.....\n\nNo correlation at all. It seems like the features aren't affecting the result. Pheww....","70445874":"So, here I am taking a diversion from the traditional approach and converting the continuos data into categorical data. These informations are collected from the internet. Since there isn't much of a correlation between the features and the result, I will be checking out a parallel categorical plot to see the behaviour of the feature values and how it affects the **Potability**.","2102256f":"Firstly, since there is not test set explicitly provided, I will divide into train set and test set.\n\nFurther the train set will be divided and trained.\n\n#### For the model training I will be dividing the dataset into **5 folds** and training 5 models on the dataset with each fold as the validation set for each model. Each model will then predict on the test set and will be taking a simple avg. of the results as the final output.","f5c5070b":"Plotting the distribution graphs for each feature. Checking for any outliers with box plot","c236bdef":"### Training, validation and prediction loop\n\n#### The outputs:\n* The model score \n* The Out of Fold accuracy score (OOF)\n* The model score on the test set\n* Classification report for each OOF set\n* Confusion matrix for each OOF set\n\n* **Finally** : The total score on the train set (combined all OOF scores) and the ensembled score for the test set.","2c50a5d8":"#### Creating folds","464e68aa":"# <span style=\"color:white;font-size:38px;font-family:arial;\">3. Correlation Matrix<\/span>","70f94eb0":"# <span style=\"color:white;font-size:38px;font-family:arial;\">Overview<\/span>\n\nAccess to safe drinking-water is essential to health, a basic human right and a component of effective policy for health protection. This is important as a health and development issue at a national, regional and local level. In some regions, it has been shown that investments in water supply and sanitation can yield a net economic benefit, since the reductions in adverse health effects and health care costs outweigh the costs of undertaking the interventions.\n\n#### The task:\nTo perform Exploratory Data Analysis on the dataset and try builing a simple model to predict the **potability** of water based on the inputs.\n\n#### The Input features:\n* pH\n* Hardness\n* Solid concentration\n* Chloramine Conc.\n* Sulfate Conc.\n* Conductivity\n* Organic Carbon Conc.\n* Trihalomethane Conc.\n* Turbidity"}}