{"cell_type":{"eec740dc":"code","cc4b292a":"code","151553d8":"code","deec17b7":"code","b1513f74":"code","7b6508ff":"code","b2627d6e":"code","dae485df":"code","81093e6d":"code","b1113475":"code","f90eef11":"code","0bb47b3b":"code","aa28a478":"code","1fd8a189":"markdown","3b93432c":"markdown","cae1f368":"markdown","2dd28abd":"markdown","c8916d9f":"markdown","af7dfb86":"markdown","f09f70d2":"markdown","a10658b4":"markdown"},"source":{"eec740dc":"import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import OrdinalEncoder, StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\nimport matplotlib.pyplot as plt\nfrom sklearn.pipeline import Pipeline\nimport tensorflow as tf\nimport keras\nfrom keras.layers import Dense, BatchNormalization, Dropout, LSTM\nfrom keras.models import Sequential\nfrom keras.utils import to_categorical\nimport seaborn as sns\nfrom sklearn.compose import ColumnTransformer\nfrom statistics import stdev\nfrom keras import regularizers","cc4b292a":"df_raw = pd.read_csv(\"..\/input\/crystal-system-properties-for-liion-batteries\/lithium-ion batteries.csv\")","151553d8":"df_raw.head()","deec17b7":"data = df_raw # temporary save","b1513f74":"data = data.drop(['Materials Id'], axis=1)","7b6508ff":"numerical_transformer = StandardScaler()\nlabel_transformer = OrdinalEncoder()\n\nn_cols = [c for c in data.columns if data[c].dtype in ['int64', 'float64', 'int32', 'float32']]\nobj_cols = [c for c in data.columns if data[c].dtype in ['object', 'bool']]\nprint(n_cols, obj_cols)\n\nct = ColumnTransformer([('num', numerical_transformer, n_cols), ('non_num', label_transformer, obj_cols),])\nprocessed = ct.fit_transform(data)\nnew_data = pd.DataFrame(columns=data.columns, data=processed)\nnew_data.head()","b2627d6e":"new_data.hist(figsize=(14,14), xrot=-45)\nplt.show()","dae485df":"X = new_data.drop('Crystal System', axis=1)\ny = new_data['Crystal System']\nprint(X.shape)\nprint(y.shape)","81093e6d":"plt.figure(figsize=(12, 10))\ncorr_matrix = X.corr()\nsns.heatmap(corr_matrix, lw=0.5, cmap='coolwarm', annot=True)","b1113475":"corr_matrix = X.corr()\nsns.pairplot(corr_matrix)","f90eef11":"def train_model(n_runs, t_size=0.25):\n    score = []\n    for j in range(n_runs):\n        X_train, X_test, y_train, y_test = train_test_split(np.array(X), np.array(y), test_size=t_size, shuffle=True)\n        y_encoded = to_categorical(y_train)\n        model = Sequential()\n        model.add(Dense(1024, activation='relu', kernel_regularizer=regularizers.l2(0.01)))\n        model.add(BatchNormalization())\n        model.add(Dense(512, activation='relu', kernel_regularizer=regularizers.l2(0.01)))\n        model.add(Dense(256, activation='relu', kernel_regularizer=regularizers.l2(0.01)))\n        model.add(Dropout(0.2))\n        model.add(Dense(128, activation='softsign', kernel_regularizer=regularizers.l2(0.01)))\n        model.add(Dropout(0.2))\n        model.add(Dense(3, activation='softmax'))\n\n        model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])\n\n        global history \n        history = model.fit(X_train, y_encoded, epochs=100, verbose=False, validation_split=0.2)\n\n        preds=model.predict_classes(X_test)\n\n        score.append(accuracy_score(y_test, preds))\n            \n    print(f'Average score: '+ str(sum(score)\/len(score)))\n    print(f'Standard deviation: ' + str(stdev(score)))\n    \n    plt.title('Accuracy over ' + str(n_runs) + ' runs')\n    plt.plot(score, label='Accuracy Score')\n    plt.ylabel('Accuracy %')\n    plt.xlabel('Runs')\n    plt.legend()\n    plt.show()\n    \ntrain_model(20, 0.3)","0bb47b3b":"plt.title('Loss \/ Mean Squared Error')\nplt.plot(history.history['loss'], label='train loss')\nplt.plot(history.history['val_loss'], label='test loss')\nplt.ylabel('Loss')\nplt.xlabel('Epochs')\nplt.legend()\nplt.show()","aa28a478":"plt.title('Model Accuracy')\nplt.plot(history.history['val_accuracy'], label='test accuracy')\nplt.plot(history.history['accuracy'], label='train accuracy')\nplt.ylabel('Accuracy')\nplt.xlabel('Epochs')\nplt.legend()\nplt.show()","1fd8a189":"# About Li-Ion Battery Classification\n![](http:\/\/cdn.pixabay.com\/photo\/2020\/01\/28\/15\/18\/battery-4800010_960_720.jpg)\n\nThis dataset contains data about the physical and chemical properties of the Li-ion silicate cathodes. These properties can be useful to predict the class of a Li-ion battery. These batteries can be classified on the basis of their crystal system. There are a total of 7 crystal structures in crystallography viz. monoclinic, orthorhombic, triclinic, hexagonal, cubic, tetragonal and trigonal. In this data we will classify them in three major classes of crystal system: monoclinic, orthorhombic and triclinic.","3b93432c":"# 2. Preprocessing of the data\nNecessary scaling of the variables is required.","cae1f368":"Drop \"Material Id\" because it is merely an identifier! ","2dd28abd":"# 3. Data Visualization","c8916d9f":"# 1. Necessary Imports and reading the data","af7dfb86":"# 5. Plotting the result scores","f09f70d2":"# 4. Training the model","a10658b4":"This work is an attempt to improve the Deep Neural Network originally created by [vtech6](http:\/\/www.kaggle.com\/vtech6) here: [www.kaggle.com\/vtech6\/classifying-li-ion-batteries-with-dnn](http:\/\/www.kaggle.com\/vtech6\/classifying-li-ion-batteries-with-dnn)\nThanks for sharing such an awesome work!"}}