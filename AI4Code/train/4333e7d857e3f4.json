{"cell_type":{"6ae53f84":"code","915284fb":"code","c3914f43":"code","8632c8a1":"code","d8807545":"code","01dc6649":"code","24a6ebe0":"code","0d5cd3c6":"code","657e4fd6":"code","f336e6b5":"code","3c3ff917":"code","c0c01f1f":"code","a1aff3e8":"code","da0ed3e2":"code","feb3e940":"code","73a92e5b":"code","25325d23":"code","83dac76d":"code","c90859c4":"code","9c28f8f5":"code","5b06cde0":"code","048e1934":"code","d63db54f":"code","139f9d35":"code","758060e0":"code","25056348":"code","a853a7bc":"code","0e4d28d9":"code","9ff70dc9":"code","c331d193":"code","c3403467":"code","3ed6480d":"code","847933c3":"code","e25909ad":"code","17b8eecd":"code","e1ad18b5":"code","3d77f921":"code","3c8d5e7e":"code","ea9919f5":"code","93390870":"code","db476ad6":"code","a1c8f14b":"code","5d5484b1":"code","a12085cb":"code","7d4fcf7c":"code","6aefb9f8":"code","8338aef5":"code","61df6973":"code","53f26df8":"code","fd3b9823":"code","ea020c91":"code","aea12755":"markdown","47af62fb":"markdown","bc212f0c":"markdown","51b6006a":"markdown","e87ce6d1":"markdown","bc2f5c91":"markdown","fac0d1e1":"markdown","007d2a75":"markdown","ed8fee87":"markdown","136eabc9":"markdown","61912251":"markdown"},"source":{"6ae53f84":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","915284fb":"# import Libraries\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings('ignore')\nfrom scipy import stats\nfrom scipy.stats import norm\nfrom sklearn.preprocessing import StandardScaler\n% matplotlib inline","c3914f43":"# Read and load Data\ntrain = pd.read_csv(\"..\/input\/train.csv\")\ntest = pd.read_csv(\"..\/input\/test.csv\")","8632c8a1":"# check index of dataframe\ntrain.columns","d8807545":"train.SalePrice.describe()","01dc6649":"#PLot Histogram for 'SalePrice'\nsns.distplot(train['SalePrice'])","24a6ebe0":"# Skewness and Kurtosis\nprint(\"Skewness : %f\" % train['SalePrice'].skew())\nprint(\"Kurtosis : %f\" % train['SalePrice'].kurt())","0d5cd3c6":"target = np.log(train.SalePrice)\nprint(\"Skewness : %f\" % target.skew())\nprint(\"Kurtosis : %f\" % target.kurt())","657e4fd6":"numeric_features = train.select_dtypes(include=[np.number])\nnumeric_features.dtypes","f336e6b5":"corr = numeric_features.corr()\n\nprint (corr['SalePrice'].sort_values(ascending=False)[:5], '\\n')\nprint (corr['SalePrice'].sort_values(ascending=False)[-5:])","3c3ff917":"#'SalePrice' Correlation Matrix\nk = 10\ncols = corr.nlargest(k , 'SalePrice')['SalePrice'].index\ncm = np.corrcoef(train[cols].values.T)\nsns.set(font_scale = 1.00)\nhm = sns.clustermap(cm , cmap = \"Greens\",cbar = True,square = True,\n                 yticklabels = cols.values, xticklabels = cols.values)","c0c01f1f":"quality_pivot = train.pivot_table(index='OverallQual',\n                                  values='SalePrice', aggfunc=np.median)\nquality_pivot.plot(kind='bar', color='blue')\nplt.xlabel('Overall Quality')\nplt.ylabel('Median Sale Price')\nplt.xticks(rotation=0)\nplt.show()","a1aff3e8":"#Analyse SalePrice\/GrLiveArea\n#data = pd.concat([train['SalePrice'], train['GrLivArea']], axis = 1)\ntrain.plot.scatter(x ='GrLivArea', y= 'SalePrice', ylim = (0,800000)); #, alpha=0.3);","da0ed3e2":"train.plot.scatter(x ='LotFrontage', y= 'SalePrice', ylim = (0,800000)); ","feb3e940":"train.plot.scatter(x ='GarageArea', y= 'SalePrice', ylim = (0,800000));","73a92e5b":"train.columns","25325d23":"train = train.drop(train[(train['OverallQual'] < 5 ) & (train['SalePrice'] > 200000)].index)\ntrain = train.drop(train[(train['GrLivArea'] > 4000) & (train['SalePrice'] < 300000)].index)\ntrain = train[train['GarageArea']<1200]\ntrain = train[train['LotFrontage']<200]","83dac76d":"# Histogram and normal probability plot\nsns.distplot(train['SalePrice'], fit = norm)\nfig = plt.figure()\nres = stats.probplot(train['SalePrice'],plot = plt)","c90859c4":"# Missing Data\ntotal = train.isnull().sum().sort_values(ascending = False)\npercent = (train.isnull().sum()\/train.isnull().count()).sort_values(ascending = False)\nmissing_data = pd.concat([total,percent], axis = 1, keys = ['Total', 'Percent'])\nmissing_data.head(20)","9c28f8f5":"categoricals = train.select_dtypes(exclude=[np.number])\ncategoricals.describe()","5b06cde0":"cate = test.select_dtypes(exclude=[np.number])\ncate.describe()","048e1934":"from sklearn.preprocessing import LabelEncoder, OneHotEncoder\n\ncols = ('MSZoning', 'Street', 'Alley', 'LotShape', 'LandContour', 'Utilities',\n       'LotConfig', 'LandSlope', 'Neighborhood', 'Condition1', 'Condition2',\n       'BldgType', 'HouseStyle', 'RoofStyle', 'RoofMatl', 'Exterior1st',\n       'Exterior2nd', 'MasVnrType', 'ExterQual', 'ExterCond', 'Foundation',\n       'BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2',\n       'Heating', 'HeatingQC', 'CentralAir', 'Electrical', 'KitchenQual',\n       'Functional', 'FireplaceQu', 'GarageType', 'GarageFinish', 'GarageQual',\n       'GarageCond', 'PavedDrive', 'PoolQC', 'Fence', 'MiscFeature',\n       'SaleType', 'SaleCondition')\n\n# process columns, apply LabelEncoder to categorical features\nfor c in cols:\n    lbl = LabelEncoder() \n    lbl.fit(list(train[c].values)) \n    train[c] = lbl.transform(list(train[c].values))\n    lbl.fit(list(test[c].values)) \n    test[c] = lbl.transform(list(test[c].values))","d63db54f":"train = train.dropna(thresh=0.70*len(train), axis=1)\n\ntest = test.dropna(thresh=0.70*len(test), axis=1)","139f9d35":"train = train.fillna(train.mean())\ntest = test.fillna(test.mean())","758060e0":"corr = train.corr()\n\nprint (corr['SalePrice'].sort_values(ascending=False)[:5], '\\n')\nprint (corr['SalePrice'].sort_values(ascending=False)[-5:])","25056348":"y = np.log(train.SalePrice)\nX = train.drop(['SalePrice', 'Id'], axis=1)\n","a853a7bc":"# Threshold for removing correlated variables\nthreshold = 0.8\n\n# Absolute value correlation matrix\ncorr_matrix = X.corr().abs()\n\n# Upper triangle of correlations\nupper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(np.bool))\n\n# Select columns with correlations above threshold\nto_drop = [column for column in upper.columns if any(upper[column] > threshold)]\n\n# Remove the columns\nX = X.drop(columns = to_drop)","0e4d28d9":"print(X.shape)\nprint(y.shape)","9ff70dc9":"import lightgbm as lgb\nfrom sklearn.model_selection import train_test_split\n\ndef identify_zero_importance_features(X, y, iterations = 2):\n    \"\"\"\n    Identify zero importance features in a training dataset based on the \n    feature importances from a gradient boosting model. \n    \n    Parameters\n    --------\n    train : dataframe\n        Training features\n        \n    train_labels : np.array\n        Labels for training data\n        \n    iterations : integer, default = 2\n        Number of cross validation splits to use for determining feature importances\n    \"\"\"\n    \n    # Initialize an empty array to hold feature importances\n    feature_importances = np.zeros(X.shape[1])\n\n    # Create the model with several hyperparameters\n    model = lgb.LGBMRegressor(objective='regression', boosting_type = 'goss', \n                               n_estimators =550, class_weight = 'balanced')\n    \n    # Fit the model multiple times to avoid overfitting\n    for i in range(iterations):\n\n        # Split into training and validation set\n        train_features, valid_features, train_y, valid_y = train_test_split(X, y, \n                                                                            test_size = 0.25, \n                                                                            random_state = i)\n\n        # Train using early stopping\n        model.fit(train_features, train_y, early_stopping_rounds=100, \n                  eval_set = [(valid_features, valid_y)])\n\n        # Record the feature importances\n        feature_importances += model.feature_importances_ \/ iterations\n    \n    feature_importances = pd.DataFrame({'feature': list(X.columns), \n                            'importance': feature_importances}).sort_values('importance', \n                                                                            ascending = False)\n    \n    # Find the features with zero importance\n    zero_features = list(feature_importances[feature_importances['importance'] == 0.0]['feature'])\n    print('\\nThere are %d features with 0.0 importance' % len(zero_features))\n    \n    return zero_features, feature_importances\n\nzero_features, feature_importances = identify_zero_importance_features(X, y, iterations = 2)\nprint('zero_features:',zero_features)\nprint('feature_importances : ', feature_importances)","c331d193":"feature_importances.describe()","c3403467":"#X = X.drop(zero_features, axis = 1)\n#test = test.drop(zero_features, axis =1)","3ed6480d":"pp =np.percentile(feature_importances['importance'], 20) \nprint(pp)","847933c3":"to_drop = feature_importances[feature_importances['importance'] <= pp]['feature']\nX = X.drop(columns = to_drop)","e25909ad":"print(X.shape)\nprint(y.shape)","17b8eecd":"from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1)             ","e1ad18b5":"# Linear Regression\nfrom sklearn import linear_model\nfrom sklearn.metrics import r2_score\nfrom sklearn.metrics import mean_squared_error\n# Create linear regression object\nregr = linear_model.LinearRegression()\n\n# Train the model using the training sets\nregr.fit(X_train, y_train)\n\n# Make predictions using the testing set\ny_pred = regr.predict(X_test)\nprint('The accuracy of the Linear Regression is',r2_score(y_test,y_pred))\nprint ('RMSE is: \\n', mean_squared_error(y_test, y_pred))","3d77f921":"import xgboost as xgb\n\nxg_reg = xgb.XGBRegressor(learning_rate =0.01, n_estimators=5580, \n                                     max_depth=3,min_child_weight=0 ,\n                                     gamma=0, subsample=0.7,\n                                     colsample_bytree=0.7,\n                                     objective= 'reg:linear',nthread=4,\n                                     scale_pos_weight=1,seed=27, \n                                     reg_alpha=0.00006)\nxg_reg.fit(X_train,y_train)\n\npreds = xg_reg.predict(X_test)\nprint('The accuracy of the xgboost is',r2_score(y_test,preds))\nprint ('RMSE is: \\n', mean_squared_error(y_test,preds))","3c8d5e7e":"from sklearn.ensemble import GradientBoostingRegressor\ngbr_model = GradientBoostingRegressor(n_estimators=6380, learning_rate=0.01,\n                                   max_depth=10, max_features='sqrt',\n                                   min_samples_leaf=1, min_samples_split=250, \n                                   loss='huber', random_state =6).fit(X_train,y_train)\ngbr_preds = gbr_model.predict(X_test)\nprint('The accuracy of the Gradient boost is',r2_score(y_test,gbr_preds))\nprint ('RMSE is: \\n', mean_squared_error(y_test,gbr_preds))","ea9919f5":"from lightgbm import LGBMRegressor\nfrom sklearn.preprocessing import RobustScaler\nfrom sklearn.pipeline import make_pipeline\nlgbm_model = LGBMRegressor(objective='regression',\n                              num_leaves=4,\n                              learning_rate=0.05, \n                              n_estimators=1250,\n                              max_bin=75, \n                              bagging_fraction=0.8,\n                              bagging_freq=9, \n                              feature_fraction=0.45,\n                              feature_fraction_seed=9, \n                              bagging_seed=12,\n                              min_data_in_leaf=3, \n                              min_sum_hessian_in_leaf=2).fit(X_train, y_train)\nlgbm_preds = lgbm_model.predict(X_test)\nprint('The accuracy of the lgbm Regressor is',r2_score(y_test,lgbm_preds))\nprint ('RMSE is: \\n', mean_squared_error(y_test,lgbm_preds))","93390870":"from sklearn.linear_model import RidgeCV\nfrom sklearn.preprocessing import RobustScaler\nfrom sklearn.pipeline import make_pipeline\nr_alphas =  [0.005, 0.01, 0.05, 1]\nridge_model = make_pipeline(RobustScaler(), RidgeCV(alphas = r_alphas, cv =3)).fit(X_train, y_train)\n\nridge_preds = ridge_model.predict(X_test)\nprint('The accuracy of the ridge Regressor is',r2_score(y_test,ridge_preds))\nprint ('RMSE is: \\n', mean_squared_error(y_test,ridge_preds))   \n    ","db476ad6":"from sklearn.linear_model import LassoCV\n\nalpha_lasso = np.logspace(-3, -1, 30)\n\n\nlasso_model = make_pipeline(RobustScaler(),\n                             LassoCV(max_iter=1e6,\n                                    alphas = alpha_lasso,\n                                    random_state = 1)).fit(X_train, y_train)\n\nlasso_preds = lasso_model.predict(X_test)\nprint('The accuracy of the lasso Regressor is',r2_score(y_test,lasso_preds))\nprint ('RMSE is: \\n', mean_squared_error(y_test,lasso_preds))   \n    ","a1c8f14b":"from sklearn.linear_model import ElasticNetCV\n\ne_alphas = np.logspace(-3 -2, 30)\n\ne_l1ratio = [0.8, 0.85, 0.9, 0.95, 0.99, 1]\n\nelastic_model= make_pipeline(RobustScaler(), \n                           ElasticNetCV(max_iter=1e6, alphas=e_alphas, \n                                         l1_ratio=e_l1ratio)).fit(X_train, y_train)\n\nelastic_preds = elastic_model.predict(X_test)\nprint('The accuracy of the  Elastic Net CV is',r2_score(y_test,elastic_preds))\nprint ('RMSE is: \\n', mean_squared_error(y_test,elastic_preds))   \n    ","5d5484b1":"from mlxtend.regressor import StackingCVRegressor\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import RobustScaler\n#setup models\nridge = make_pipeline(RobustScaler(), \n                      RidgeCV(alphas = r_alphas))\n\nlasso = make_pipeline(RobustScaler(),\n                      LassoCV(max_iter=1e6,\n                                    alphas = alpha_lasso,\n                                    random_state = 1)).fit(X_train,y_train)\n\nelasticnet = make_pipeline(RobustScaler(), \n                           ElasticNetCV(max_iter=1e6, alphas=e_alphas, \n                                         l1_ratio=e_l1ratio)).fit(X_train,y_train)\n\nlgbm_model = LGBMRegressor(objective='regression',\n                              num_leaves=4,\n                              learning_rate=0.05, \n                              n_estimators=1250,\n                              max_bin=75, \n                              bagging_fraction=0.8,\n                              bagging_freq=9, \n                              feature_fraction=0.45,\n                              feature_fraction_seed=9, \n                              bagging_seed=12,\n                              min_data_in_leaf=3, \n                              min_sum_hessian_in_leaf=2).fit(X_train,y_train)\n\ngbr_model = GradientBoostingRegressor(n_estimators=6080, learning_rate=0.01,\n                                   max_depth=10, max_features='sqrt',\n                                   min_samples_leaf=1, min_samples_split=250, \n                                   loss='huber', random_state =6).fit(X_train,y_train)\n\n#stack\nstack_gen = StackingCVRegressor(regressors=(ridge,\n                                            lasso, elasticnet, gbr_model,\n                                             lgbm_model), \n                               meta_regressor=gbr_model,\n                               use_features_in_secondary=True)\n\n#prepare dataframes\nstackX = np.array(X_train)\nstacky = np.array(y_train)\nstack_gen_model = stack_gen.fit(stackX, stacky)","a12085cb":"em_preds = elastic_model.predict(X_test)\nlasso_preds = lasso_model.predict(X_test)\nridge_preds = ridge_model.predict(X_test)\nstack_gen_preds = stack_gen_model.predict(X_test)\nlgbm_preds = lgbm_model.predict(X_test)\ngbr_preds = gbr_model.predict(X_test)","7d4fcf7c":"print('The accuracy of the stack Regressor is',r2_score(y_test,stack_gen_preds))\nprint ('RMSE is: \\n', mean_squared_error(y_test,stack_gen_preds))","6aefb9f8":"stack_preds_1 = ((0.1*em_preds) +(0.1*ridge_preds) + (0.1*lasso_preds) + (0.4 * gbr_preds ) \n               + (0.1*lgbm_preds) + (0.2*stack_gen_preds) )\nprint('The accuracy of the stack Regressor is',r2_score(y_test,stack_preds_1))\nprint ('RMSE is: \\n', mean_squared_error(y_test,stack_preds_1))   \n    ","8338aef5":"#feats = test.select_dtypes(include=[np.number]).interpolate().dropna()\nfeats = test.drop(['Id'], axis=1)\n\nfeats = feats[X_train.columns]","61df6973":"lasso_preds = lasso_model.predict(feats)\nem_preds = elastic_model.predict(feats)\n#ridge_preds = ridge_model.predict(feats)\nstack_gen_preds = stack_gen_model.predict(feats)\nlgbm_preds = lgbm_model.predict(feats)\ngbr_preds = gbr_model.predict(feats)","53f26df8":"stack_preds = ((0.1*em_preds) + (0.1*lasso_preds) + (0.2 * gbr_preds ) \n               + (0.1*lgbm_preds) + (0.5*stack_gen_preds) )","fd3b9823":"#predictions = model.predict(feats)\nfinal_predictions = np.exp(stack_preds)\nprint (\"Original predictions are: \\n\", stack_preds[:5], \"\\n\")\nprint (\"Final predictions are: \\n\", final_predictions[:5])","ea020c91":"submission = pd.DataFrame()\nsubmission['Id'] = test.Id\nsubmission['SalePrice'] = final_predictions \nsubmission.to_csv('submission1.csv', index=False)","aea12755":"Cleaning missing data\n\nIn statistics, missing data, or missing values, occur when no data value is stored for the variable in an observation. Missing data are a common occurrence and can have a significant effect on the conclusions that can be drawn from the data. The goal of cleaning operations is to prevent problems caused by missing data that can arise when training a model.","47af62fb":"use np.log() to transform train.SalePric and calculate the skewness and kurtosis again.","bc212f0c":"Working with Numeric Features","51b6006a":"Let's have a look at the distribution of 'SalePrice' by plotting a simple histogram","e87ce6d1":"Transforming and engineering features\nHere we are using label encoding.\nLabel encoding refers to transforming the word labels into numerical form so that the algorithms can understand how to operate on them.","bc2f5c91":"OUTLIERS : -\n\nFocusing on outliers, defined by Gladwell as people who do not fit into our normal understanding of achievement. Outliers deals with exceptional people, especially those who are smart, rich, and successful, and those who operate at the extreme outer edge of what is statistically plausible. An outlier is a data point that is distant from other similar points. They may be due to variability in the measurement or may indicate experimental errors. If possible, outliers should be excluded from the data set. We'll do a quick analysis through the standard deviation of 'SalePrice' and a set of scatter plots.","fac0d1e1":"**2. Remove Collinear Variables:**\nCollinear variables are variables that are highly correlated with one another. ","007d2a75":"**1. Remove Missing Columns :**\nwe\u2019ll remove any columns with more than 70% missing values in either the training or testing set.\n\n","ed8fee87":" non-numeric Features","136eabc9":"Skewness: -\n\nThe term \u2018skewness\u2019 is used to mean the absence of symmetry from the mean of the dataset. Skewness is used to indicate the shape of the distribution of data.In a skewed distribution, the curve is extended to either left or right side. So, when the plot is extended towards the right side more, it denotes positive skewness. On the other hand, when the plot is stretched more towards the left direction, then it is called as negative skewness.\n\nKurtosis:-\nIn statistics, kurtosis is defined as the parameter of relative sharpness of the peak of the probability distribution curve.It is used to indicate the flatness or peakedness of the frequency distribution curve and measures the tails or outliers of the distribution.Positive kurtosis represents that the distribution is more peaked than the normal distribution, whereas negative kurtosis shows that the distribution is less peaked than the normal distribution.","61912251":"**Drop Columns having features importance less than 25%**"}}