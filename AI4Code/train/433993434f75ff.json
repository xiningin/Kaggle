{"cell_type":{"80b0782a":"code","6bf75ccd":"code","eaa0a5dc":"code","b630db5c":"code","2b611936":"code","b17e2468":"code","5a9288fd":"code","730ddc24":"code","79fd3177":"code","0fd6c88e":"code","2d176355":"code","d8429a85":"code","c739e6c5":"code","8d2fd93c":"code","9d743e10":"code","aa2d2025":"code","0ea0f3b0":"code","3055abb7":"code","b7ed44ec":"code","7074dac4":"code","79a13b4b":"code","880e8246":"code","ccad1a15":"code","fd0d4453":"code","5a66b68c":"code","e2cab786":"code","da55a46f":"code","2aa7cb6b":"code","7df4f003":"code","946f585a":"code","439a1e6c":"code","bf3233ef":"code","3ff42628":"code","bc2ebb10":"code","642c25bb":"code","b1801550":"code","aa3865e7":"code","0b769ee2":"code","2c156e4e":"code","a812cbef":"code","51f59113":"code","811c8838":"code","761dac43":"code","d6b0a174":"code","638e7611":"code","9a8e8c50":"code","30a30e07":"code","207a586e":"code","f049ec62":"code","dd1ddcfb":"code","e71367cd":"code","ddf9275e":"code","17c34043":"code","33487a64":"code","8ef5149a":"code","3ae33e86":"code","e9f9e383":"code","1a0a0d71":"code","ddefbd07":"code","0ff970e1":"code","a12fdff7":"code","1033d96d":"code","d9786516":"code","030238cf":"code","dbfd7695":"code","0a39c8c8":"code","0b68642e":"code","c7aefa10":"code","47f60929":"code","247d926e":"code","92e69e00":"code","cf2a20cb":"code","93678ae5":"code","ddad9428":"code","2d2c8a4a":"code","e9662862":"code","008a8a48":"code","0052d137":"code","2d188ef6":"code","5e4adf28":"code","68141a0e":"code","c2898138":"code","0eaad3a3":"code","1b016d35":"markdown","e61f9edb":"markdown","6612e279":"markdown","53fac5cd":"markdown","1275c507":"markdown","32e7acce":"markdown","3df1e861":"markdown","c6de0613":"markdown","fd03f74f":"markdown","5e9ababd":"markdown","badf6206":"markdown","70ed0548":"markdown","7ca366fc":"markdown","5829a8a9":"markdown","b42cc9f3":"markdown","36575c28":"markdown","e14de3e3":"markdown","a3dfc363":"markdown","d5cfc04e":"markdown","3b892852":"markdown","772550b1":"markdown","fe646ce9":"markdown","ddfe1fd5":"markdown","1245fafc":"markdown","69427702":"markdown","c073cf90":"markdown","0021fe40":"markdown","8efcb45c":"markdown","d55ac83c":"markdown","b2a513ad":"markdown"},"source":{"80b0782a":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy import stats\nfrom pandas.plotting import scatter_matrix\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import KMeans","6bf75ccd":"pokemon_df = pd.read_csv('..\/input\/complete-pokemon-dataset-updated-090420\/pokedex_(Update_05.20).csv')\npokemon_df.head()","eaa0a5dc":"pokemon_df.tail()","b630db5c":"pokemon_df.info()","2b611936":"pokemon_df.shape","b17e2468":"pokemon_df.columns","5a9288fd":"pokemon_df = pokemon_df.drop('Unnamed: 0', axis=1)\n\ncolumns_to_drop = ['japanese_name', 'german_name', 'against_normal', 'against_fire',\n                  'against_water', 'against_electric', 'against_grass', 'against_ice',\n                  'against_fight', 'against_poison', 'against_ground', 'against_flying',\n                  'against_psychic', 'against_bug', 'against_rock', 'against_ghost',\n                  'against_dragon', 'against_dark', 'against_steel', 'against_fairy'\n                  ]\n\npokemon_df = pokemon_df.drop(columns_to_drop, axis = 1)","730ddc24":"# Get index and print row of pokemon having highest total_points\nhighest_tot_points_idx = pokemon_df['total_points'].idxmax()\npokemon_df.loc[highest_tot_points_idx,:]","79fd3177":"# Select mega pokemons, dinamax and alolan pokemons\nmega_pokemons = pokemon_df.index[pokemon_df['name'].apply(lambda x: 'Mega ' in x)].tolist()\ndinamax_pokemons = pokemon_df.index[pokemon_df['name'].apply(lambda x: 'max' in x)].tolist()\nalolan_pokemons = pokemon_df[pokemon_df.name.apply(lambda x: 'Alolan' in x) == True].index.tolist()\n\n# Concatenate\nto_delete = np.concatenate((mega_pokemons, dinamax_pokemons, alolan_pokemons))\n\n# Remove\npokemon_df = pokemon_df.drop(to_delete, axis=0)","0fd6c88e":"# Cheacking again after dropping mega, dinamax and alolan:\n# Get index and print row of pokemon having highest total_points\nhighest_tot_points_idx = pokemon_df['total_points'].idxmax()\npokemon_df.loc[highest_tot_points_idx,:]","2d176355":"features_stats = ['total_points', 'hp', 'attack', 'defense',\n       'sp_attack', 'sp_defense', 'speed']","d8429a85":"def find_min_and_max(column_name):\n    '''\n    Get pokemon name according to its max and min attribute: column_name\n    column_name: array of int or float\n    '''\n    \n    # Find max\n    max_index = pokemon_df[column_name].idxmax()\n    max_pokemon = pokemon_df.loc[max_index, 'name']\n    \n    # Find min\n    min_index = pokemon_df[column_name].idxmin()\n    min_pokemon = pokemon_df.loc[min_index, 'name']\n    \n    print(f'Pokemon with min {column_name}: {min_pokemon}\\nPokemon with max {column_name}: {max_pokemon}\\n')\n    return min_index, max_index","c739e6c5":"features_stats","8d2fd93c":"\nmin_dict = {}\nmax_dict = {}\nmax_labels=[]\nmin_labels=[]\n\nfor stat in features_stats:\n    min_index, max_index = find_min_and_max(stat)\n    max_dict[stat] = pokemon_df.loc[max_index, stat]\n    min_dict[stat] = pokemon_df.loc[min_index, stat]\n    max_labels.append(pokemon_df.loc[max_index, 'name'])\n    min_labels.append(pokemon_df.loc[min_index, 'name'])","9d743e10":"X = np.arange(len(max_dict))\nfig, ax = plt.subplots(1, figsize=(10,10))\n\np1 = ax.bar(X, max_dict.values(), width=0.4, color='b', align='center')\np2 = ax.bar(X-0.4, min_dict.values(), width=0.4, color='g', align='center')\nax.legend(('Max values','Min values'))\nplt.xticks(X, max_dict.keys())\nplt.title(\"Min Max values\", fontsize=17)\nplt.grid()\n\ndef autolabel(bar_plot, bar_label):\n    for idx,rect in enumerate(bar_plot):\n        height = rect.get_height()\n        ax.text(rect.get_x() + rect.get_width()\/2., 1.05*height,\n                bar_label[idx],\n                ha='center', va='bottom', rotation=45)\nautolabel(p1, max_labels)\nautolabel(p2, min_labels)\nplt.ylim((0,900))\nplt.show()","aa2d2025":"t1_by_gen = pd.crosstab(pokemon_df['generation'],pokemon_df['type_1'])\nt1_by_gen","0ea0f3b0":"fig, ax = plt.subplots(figsize=(20,10))\nsns.heatmap(t1_by_gen, annot=True, linewidths=0.5, cmap=\"BuPu\");","3055abb7":"t2_by_gen = pd.crosstab(pokemon_df['generation'],pokemon_df['type_2'])","b7ed44ec":"fig, ax = plt.subplots(figsize=(20,10))\nsns.heatmap(t2_by_gen, annot=True, linewidths=0.5, cmap=\"BuPu\");","7074dac4":"stats_df = pokemon_df[features_stats]","79a13b4b":"stats_df.head()","880e8246":"stats_df.describe()","ccad1a15":"stats_df.corr().round(2)","fd0d4453":"sns.jointplot(x=stats_df['attack'], y=stats_df['sp_defense'], kind=\"kde\");","5a66b68c":"sns.jointplot(x=stats_df['speed'], y=stats_df['total_points'], kind=\"kde\");","e2cab786":"scatter_matrix(stats_df, figsize=[12,12])\n\nplt.show()","da55a46f":"# Checking sp attack vs. speed\nscatter_matrix(stats_df.iloc[: , [4,6]])\n\nplt.show()","2aa7cb6b":"# Using seaborn to analyze distributions\n\n# Let's check total_points first\n\nsns.distplot(stats_df['total_points']);","7df4f003":"# Defining a function to plot distribtion of stat and fiting to a normal curve\n# Function plots the fitting parameters\n\ndef fit_stats(df, stat, show = True, label=None):\n    # attack\n    ax = sns.distplot(df[stat], label=label, kde=False, fit=stats.norm);\n\n    # Get the fitted parameters used by sns\n    (mu, sigma) = stats.norm.fit(df[stat])\n\n    print (f\"mu={mu}, sigma={sigma}\")\n    # Legend and labels \n    plt.legend([\"normal dist. fit ($\\mu=${0:.2g}, $\\sigma=${1:.2f})\".format(mu, sigma)])\n    plt.ylabel('Frequency')\n\n    # Cross-check this is indeed the case - should be overlaid over black curve\n    x_dummy = np.linspace(stats.norm.ppf(0.01), stats.norm.ppf(0.99), 100)\n    ax.plot(x_dummy, stats.norm.pdf(x_dummy, mu, sigma))\n    plt.legend([\"normal dist. fit ($\\mu=${0:.2g}, $\\sigma=${1:.2f})\".format(mu, sigma),\n               \"cross-check\"])\n        \n    if not show:\n        plt.close()\n\n    return [mu, sigma]","946f585a":"fit_stats(stats_df,'attack')","439a1e6c":"fit_stats(stats_df,'speed')","bf3233ef":"features_stas_gen = ['total_points', 'hp', 'attack', 'defense',\n       'sp_attack', 'sp_defense', 'speed', 'status', 'generation']","3ff42628":"status_df = pokemon_df[features_stas_gen]\nstatus_df.head()","bc2ebb10":"fig, ax = plt.subplots(1,1,figsize=(8,8))\ny = pd.value_counts(status_df['generation'].values) \ny.plot(kind='barh', ax=ax)\nfor i, v in enumerate(y):\n    ax.text(v + 3, i , str(v), color='blue', fontweight='bold')\nplt.xlim((0,185))\nplt.xlabel('Count')\nplt.ylabel('Generation')\nplt.grid()","642c25bb":"# Encoding 'status' column\nle = LabelEncoder()\nstatus_df['status_encoded'] = le.fit_transform(status_df['status'])","b1801550":"status_df.head()","aa3865e7":"status_df.tail()","0b769ee2":"status_df['status_encoded'].unique()","2c156e4e":"status_df['status'].unique()","a812cbef":"status_name_dict = {'Legendary' : 0,\n                    'Mythical' : 1,\n                    'Normal' : 2,\n                    'Sub Legendary' : 3}\n\nscatter = plt.scatter(status_df['attack'], status_df['sp_attack'],\n                      c = status_df['status_encoded'])\n\nplt.xlabel('attack')\nplt.ylabel('sp_attack')\n\nplt.legend(handles=scatter.legend_elements()[0], labels = status_name_dict.keys())\n\nplt.grid()\nplt.show()","51f59113":"scatter = plt.scatter(status_df['attack'], status_df['sp_attack'],\n                      c = status_df['generation'])\n\nplt.xlabel('attack')\nplt.ylabel('sp_attack')\n\nplt.legend(handles=scatter.legend_elements()[0], labels = list(range(1,9)))\n\nplt.grid()\nplt.show()","811c8838":"# Filtering by generation:\n\ngen_1 = status_df.loc[status_df['generation'] == 1]\ngen_1.head()","761dac43":"gen_1.describe()","d6b0a174":"gen_dict = {}\nfor i in range(1,9):\n    gen_dict[f'gen_{i}'] = status_df.loc[status_df['generation'] == i]","638e7611":"def plot_radar(gen):\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection=\"polar\")\n\n    # theta has 6 different angles, and the first one repeated\n    use = gen.drop(['total_points','generation','status_encoded'], axis=1).describe()\n    theta = np.arange(len(use.columns) + 1) \/ float(len(use.columns)) * 2 * np.pi\n    # values has the 6 values from stats, with the first element repeated\n    values = use.loc['mean'].values\n    values = np.append(values, values[0])\n\n    # draw the polygon and the mark the points for each angle\/value combination\n    l1, = ax.plot(theta, values, color=\"C2\", marker=\"o\", label=\"Name of Col B\")\n    plt.xticks(theta[:-1], use.columns, color='grey', size=12)\n    ax.tick_params(pad=10) # to increase the distance of the labels to the plot\n    # fill the area of the polygon with green and some transparency\n    ax.fill(theta, values, 'green', alpha=0.1)\n\n    # plt.legend() # shows the legend, using the label of the line plot (useful when there is more than 1 polygon)\n    plt.title(\"Mean generation 1 Pokemon\")\n    plt.show()","9a8e8c50":"plot_radar(gen_dict['gen_1'])","30a30e07":"def plot_radar_all(gen_dict):\n    fig = plt.figure(figsize=(15,15))\n    i=1\n    for k in gen_dict:\n        gen=gen_dict[k]\n        ax = fig.add_subplot(2,4,i, projection=\"polar\")\n\n        # theta has 6 different angles, and the first one repeated\n        use = gen.drop(['total_points','generation','status_encoded'], axis=1).describe()\n        theta = np.arange(len(use.columns) + 1) \/ float(len(use.columns)) * 2 * np.pi\n        # values has the 6 values from stats, with the first element repeated\n        values = use.loc['mean'].values\n        values = np.append(values, values[0])\n\n        # draw the polygon and the mark the points for each angle\/value combination\n        l1, = ax.plot(theta, values, color=\"C2\", marker=\"o\", label=\"Name of Col B\")\n        plt.xticks(theta[:-1], use.columns, color='grey', size=12)\n        ax.tick_params(pad=10) # to increase the distance of the labels to the plot\n        # fill the area of the polygon with green and some transparency\n        ax.fill(theta, values, 'green', alpha=0.1)\n\n        # plt.legend() # shows the legend, using the label of the line plot (useful when there is more than 1 polygon)\n        plt.title(\"Mean gen\"+ str(i) +\" Pokemon\")\n        i+=1\n        fig.tight_layout(pad=3.0)\n    plt.show()","207a586e":"plot_radar_all(gen_dict)","f049ec62":"# Function to plot stat by generation\ndef plotStatGen(df, stat):\n    gen_dict = {}\n    for i in range(1,9):\n        gen_dict[f'gen_{i}'] = df.loc[df['generation'] == i]\n        \n    gen_stat = []\n    for k in gen_dict:\n        gen_stat.append(gen_dict[k][stat].mean())\n    \n    plt.plot(range(1,9), gen_stat, 'o-')\n    plt.title('Mean '+ stat + ' by genertion')\n    plt.xlabel('Generation')\n    plt.ylabel('Mean ' + stat)\n\n    plt.grid()\n    plt.show()","dd1ddcfb":"plotStatGen(status_df, 'attack')","e71367cd":"plotStatGen(status_df, 'sp_attack')","ddf9275e":"for i in features_stats:\n    plotStatGen(status_df, i)","17c34043":"# We can look at the mean and std of a stat distribution by generation using seaborn and the gen's dataframes.\n\n# Example with 'attack' in gen 1\nfit_stats(gen_dict['gen_1'], 'attack')\n","33487a64":"for k in gen_dict:\n    fit_stats(gen_dict[k], 'attack', show=True, label=k)\nplt.legend();","8ef5149a":"# Let's just plot the mean and std from fit by generation\ngen_attack_params=[]\nfor k in gen_dict:\n    gen_attack_params.append(fit_stats(gen_dict[k], 'attack', show=False, label=k))","3ae33e86":"gen_attack_params = np.array(gen_attack_params)\ngen_attack_params","e9f9e383":"# As function\ndef mean_std_gen(gen_dict, stat):\n    gen_params=[]\n    \n    for k in gen_dict:\n        gen_params.append(fit_stats(gen_dict[k], stat, show=False, label=k))\n    plt.close()\n    gen_params = np.array(gen_params)\n    \n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,5))\n    ax1.plot(range(1,9),gen_params[:,0], 'o-')\n    ax1.grid()\n    ax1.set_xlabel('Generation')\n    ax1.set_ylabel('Mean '+stat)\n    ax2.plot(range(1,9),gen_params[:,1], 'o-')\n    ax2.grid()\n    ax2.set_xlabel('Generation')\n    ax2.set_ylabel('std of '+stat)\n    \n    fig.suptitle('Parameters for '+stat)\n","1a0a0d71":"mean_std_gen(gen_dict, 'total_points')","ddefbd07":"mean_std_gen(gen_dict, 'speed')","0ff970e1":"# Instantiate the scaler\nscaler = StandardScaler()\n\n# Compute mean and std to be used for scaling\n\nscaler.fit(stats_df)","a12fdff7":"# Mean\nprint(scaler.mean_)\n\n# Std\nprint(scaler.scale_)","1033d96d":"X = scaler.transform(stats_df)\n\nX","d9786516":"# Sanity check\nX.mean(axis = 0)","030238cf":"X.std(axis=0)","dbfd7695":"# K-means modeling\n\n# Instantiate\nkmeans = KMeans(n_clusters = 3)\n\n# Fit\nkmeans.fit(X)\n\n# Make predictions\ny_preds = kmeans.predict(X)\n\nprint(y_preds)","0a39c8c8":"unique_poke, counts_poke = np.unique(y_preds, return_counts=True)\nprint(unique_poke)\nprint(counts_poke)","0b68642e":"# Turn into dict\nclusters = dict(zip(unique_poke, counts_poke))\n\nclusters","c7aefa10":"# Coordinates of the three centroids\nkmeans.cluster_centers_","47f60929":"stats_df.head()","247d926e":"plt.scatter(X[:,0], X[:,1], c = y_preds)\n\n# Identifying centroids\nplt.scatter(kmeans.cluster_centers_[:,0], kmeans.cluster_centers_[:,1],\n            marker='*', s = 250, c = [0,1,2], edgecolors='k')\n\nplt.xlabel('total_points')\nplt.ylabel('hp')\nplt.title('k-means - k=3')\nplt.show();","92e69e00":"plt.scatter(X[:,2], X[:,4], c = y_preds)\n\n# Identifying centroids\nplt.scatter(kmeans.cluster_centers_[:,2], kmeans.cluster_centers_[:,4],\n            marker='*', s = 250, c = [0,1,2], edgecolors='k')\n\nplt.xlabel('attack')\nplt.ylabel('sp_attack')\nplt.title('k-means - k=3')\nplt.show();","cf2a20cb":"# Calculate inertia for a range of clusters number\ninertia = []\n\nfor i in np.arange(1,11):\n    km = KMeans(n_clusters = i)\n    km.fit(X)\n    inertia.append(km.inertia_)\n    \n# Plotting\nplt.plot(np.arange(1,11), inertia, marker = 'o')\nplt.xlabel('Number of clusters')\nplt.ylabel('Inertia')\nplt.grid()\nplt.show();","93678ae5":"sns.jointplot(x=stats_df['speed'], y=stats_df['total_points'], kind=\"kde\");","ddad9428":"reduced_df = stats_df[['speed', 'total_points']]\nreduced_df","2d2c8a4a":"scatter_matrix(reduced_df)\n\nplt.show()","e9662862":"# Instantiate the scaler\nscaler = StandardScaler()\n\n# Compute mean and std to be used for scaling\n\nscaler.fit(reduced_df)\nX = scaler.transform(reduced_df)\n\n# Instantiate\nkmeans = KMeans(n_clusters = 2)\n\n# Fit\nkmeans.fit(X)\n\n# Make predictions\ny_preds = kmeans.predict(X)\n\nprint(y_preds)","008a8a48":"plt.scatter(X[:,0], X[:,1], c = y_preds)\n\n# Identifying centroids\nplt.scatter(kmeans.cluster_centers_[:,0], kmeans.cluster_centers_[:,1],\n            marker='*', s = 250, c = [0,1], edgecolors='k')\n\nplt.xlabel('speed')\nplt.ylabel('total_points')\nplt.title('k-means - k=2')\nplt.show();","0052d137":"# Calculate inertia for a range of clusters number\ninertia = []\n\nfor i in np.arange(1,11):\n    km = KMeans(n_clusters = i)\n    km.fit(X)\n    inertia.append(km.inertia_)\n    \n# Plotting\nplt.plot(np.arange(1,11), inertia, marker = 'o')\nplt.xlabel('Number of clusters')\nplt.ylabel('Inertia')\nplt.grid()\nplt.show();","2d188ef6":"cluster_df = pokemon_df\ncluster_df['cluster'] = y_preds\n\ncluster_df.head(10)","5e4adf28":"cluster_1 = cluster_df.loc[cluster_df['cluster'] == 0]\ncluster_2 = cluster_df.loc[cluster_df['cluster'] == 1]","68141a0e":"def cluster_dist(col):\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,5))\n    pd.value_counts(cluster_1[col].values).plot(kind='barh', ax = ax1)\n    ax1.grid()\n    ax1.set_xlabel('Cluster 1 count')\n    ax1.set_ylabel(col)\n\n    pd.value_counts(cluster_2[col].values).plot(kind='barh', ax = ax2)\n    ax2.grid()\n    ax2.set_xlabel('Cluster 2 count')\n    ax2.set_ylabel(col)\n\n    fig.suptitle('Cluster distribution')\n    fig.tight_layout(pad=3.0)\n    \ncluster_dist('generation')\n","c2898138":"cluster_dist('type_1')","0eaad3a3":"cluster_dist('status')","1b016d35":"### If we try to see all generations in a single graph:","e61f9edb":"## 1. Preprocessing","6612e279":"As expected, there are no Mythical, Legendary or Sub Legendary pokemon in cluster 1.","53fac5cd":"## 2. Using KMeans","1275c507":"# Stats for individual generations\n\nNow, we are going to look into the generations separately.","32e7acce":"## Checking min and max values for stats","3df1e861":"To get a visual of how stats are distributed, we can check the `scatter_matrix` for the whole data set.","c6de0613":"# DataFrame with only `stats`","fd03f74f":"### Plotting mean values for all stats by generation","5e9ababd":"As expected, **Legendary** pokemon have high attack and special attack.\n\nIf we use **generation** as the color column we see it is very balanced.","badf6206":"That's very messy!","70ed0548":"## How are stats distributed in generations?\n\nFirst we filter the DataFrame to check each generation separately.","7ca366fc":"## Doing a heatmap to see distribution of types across generations","5829a8a9":"# Basic EDA with pokemon dataset\n\n[<img src=\"https:\/\/i.ytimg.com\/vi\/KD-geIz-J0c\/maxresdefault.jpg\">](https:\/\/i.ytimg.com\/vi\/KD-geIz-J0c\/maxresdefault.jpg)\n\nThe purpose of this notebook is to share some ideas on analysing pokemom statistics with simple visuals.\n\nI focus on the differences between generations and end with a simple Kmeans model to group pokemons into similar clusters.\n\nHopefully this will be interesting and even helpful!","b42cc9f3":"### Radar chart for \"mean Pokemon\" by generation","36575c28":"Let's check the `attack` vs. `sp_attack` graph with colors representing status.","e14de3e3":"We will reduce dimensionality by selecting only two features: `speed` and `toal_points`.","a3dfc363":"Lets add `y_preds` as a new column in our **pokemon_df** dataframe.","d5cfc04e":"### Thak you very much for reading this far! Any comments, suggestions and criticsm is very welcome. This is my very first kaggle notebook, so I am here to learn!\nCheers!","3b892852":"### Distributions along the two clusters\n\nWe are naming **cluster 1** the slow-speed low-points cluster amd **cluster 2** the high-speed high-points one.","772550b1":"Generation 2 is home to some slow pokemon...","fe646ce9":"## Data Cleaning","ddfe1fd5":"There is no clear elbow in the inertia graph besides from 1 to 2 clusters.","1245fafc":"For example, if we look at the `attack` stat, it's lowest correlation is with the `sp_defense` stat (0.26) and it's highest is with `total_points`.\n\nCorrelation with `total_points` is actually a bit cheap, as it is the highest correlation of every stat, which makes sense.\n\nTo visualize this correlations, we plot a 2D KDE plot with seaborn:","69427702":"We can see that generation 7 has the highest mean `total_points` and generation 2 has the lowest.\nFrom the second graph, generation 8 has the more spread out distribution of `total_points`.","c073cf90":"### 3. Reducing dimensionality","0021fe40":"From the graphs, there are no clear clusters forming. \nHowever, let's remember that the distribution of `total_points` has two separet peaks:","8efcb45c":"## Radar chart of \"mean pokemon\" for all generations","d55ac83c":"This is the only stat that shows two distinct peaks in distribution.","b2a513ad":"# Modelling: unsupervised learning"}}