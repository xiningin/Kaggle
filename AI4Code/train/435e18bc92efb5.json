{"cell_type":{"81652faa":"code","9b5394c4":"code","7a1c41af":"code","6b723c84":"markdown"},"source":{"81652faa":"import numpy as np\nimport math\nimport sys\nfrom time import time\nfrom contextlib import contextmanager","9b5394c4":"def sieve_primes(n):\n    # Based on the script https:\/\/www.kaggle.com\/chefele\/scripts-first-try\/script\n    \n    # Find all primes n > prime > 2 using the Sieve of Eratosthenes \n    # For efficiency, track only odd numbers (evens are nonprime)\n    # PB: this does miss 2 (the oddest prime :) ) but that\n    # does not matter for our purposes.\n\n    sieve = np.ones( n \/\/ 2 , dtype=bool) \n    limit = int(math.sqrt(n)) + 1 \n    \n    for i in range(3, limit, 2): \n        if sieve[i \/\/ 2]:\n            sieve[(i * i) \/\/ 2 :: i] = False\n            \n    prime_indexes = np.nonzero(sieve)[0][1::]\n    primes  = 2 * prime_indexes.astype(np.int64) + 1 \n    return primes\n\n\ndef count_first_digit(ints_arr):\n    # to get first digit in a \"vectorised\" manner\n    # take the remainder mod 10 until we can no longer\n    # divide by 10\n    buf  = np.zeros(shape=(len(ints_arr)), dtype=np.int8) \n    while True:\n        mods = np.mod(ints_arr, 10)\n        ints_arr \/\/= 10\n        buf += np.where(ints_arr == 0, mods, 0)\n        # are they all zero?\n        # we only need to test the last (largest) prime\n        if ints_arr[-1] == 0:\n            break\n\n    counts = np.bincount(buf)\n    return counts\n\n\n@contextmanager\ndef timer(label):\n    output = '{label}: {time:03.3f} sec'\n    start = time()\n    try:\n        yield\n    finally:\n        end = time()\n    print(output.format(label=label, time=end-start))\n    sys.stdout.flush()","7a1c41af":"billion = 1000000000\nupper_bound = int(10 * billion)\n\nprint(\"\\nBased on all primes less than :\", upper_bound)\nprint(\"\\nCount of primes by leading digit:\")\n\nwith timer(\"Evaluated in\"):\n    counts = count_first_digit(sieve_primes(upper_bound))\n    for i in range(1, 10):\n        print(i, counts[i])\n    print()\n\nprint()","6b723c84":"What kind of distribiution do the first digits of primes up to a Billion follow?\n\nAn interesting discussion is here: https:\/\/math.stackexchange.com\/questions\/267164\/the-prime-numbers-do-not-satisfies-benfords-law\/1511928#1511928\n\n> The question of Benford's Law for prime numbers has some wrinkles to it. Back in 1972, R. E. Whitney proved that prime numbers exhibited the Benford's Law distribution in the logarithmic density, which generalizes the \"natural density\" (they agree on all sets for which the natural density exists). That was published in the American Mathematical Monthly, vol 79, pages 150-152 (\"Initial digits for the sequence of primes\"). Shortly after that, Bombieri showed that the prime numbers had the Benford's Law distribution in the Riemann Zeta density, which also generalizes the natural density; I don't think that proof was ever published, but J.-P. Serre mentions the result on page 76 of \"A Course in Arithmetic\" (https:\/\/www.math.purdue.edu\/~lipman\/MA598\/Serre-Course%20in%20Arithmetic.pdf). In 1984, Cohen et al showed in \"Prime Numbers and the First Digit Phenomenon,\" Journal of Number Theory, vol 18, pages 261 - 268, that any density that generalizes the natural density with certain intuitive properties (e.g., when you multiply by two you halve the density) and which could measure the density of first digits of primes would follow Benford's Law (http:\/\/ac.els-cdn.com\/0022314X84900611\/1-s2.0-0022314X84900611-main.pdf?_tid=509b9d70-826f-11e5-8d70-00000aacb361&acdnat=1446585211_c0f3dcdb9846df09399024856bdf16f3).\n\nThis script generates the primes up to 10 billion and counts the first digit. The results are close to uniform."}}