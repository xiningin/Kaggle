{"cell_type":{"cecd20c1":"code","ae7aaf0e":"code","4a3de018":"code","0bcb6dcb":"code","db33ac69":"code","ca5b9276":"markdown","7269ab3d":"markdown","c3fe3eeb":"markdown"},"source":{"cecd20c1":"# Import required modules \nimport cv2 \nimport numpy as np \nimport os \n  \n  \n# Define the dimensions of checkerboard \nCHECKERBOARD = (6, 9) \n  \n  \n# stop the iteration when specified \n# accuracy, epsilon, is reached or \n# specified number of iterations are completed. \ncriteria = (cv2.TERM_CRITERIA_EPS + \n            cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001) \n  \n  \n# Vector for 3D points \nthreedpoints = [] \n  \n# Vector for 2D points \ntwodpoints = [] \n  \n  \n#  3D points real world coordinates \nobjectp3d = np.zeros((1, CHECKERBOARD[0]  \n                      * CHECKERBOARD[1],  \n                      3), np.float32) \nobjectp3d[0, :, :2] = np.mgrid[0:CHECKERBOARD[0], \n                               0:CHECKERBOARD[1]].T.reshape(-1, 2) \nprev_img_shape = None\n  \n  \n# import images\nimages = {'..\/input\/checkerboard\/checkerboard0-200x155.jpg', \n          '..\/input\/checkerboard\/checkerboard1-156x200.jpg', \n          '..\/input\/checkerboard\/checkerboard2-156x200.jpg'} ","ae7aaf0e":"def convert_image_to_array(image_dir):\n    try:\n        image = cv2.imread(image_dir)\n        if image is not None :\n            return list(image)\n        else :\n            return np.array([])\n    except Exception as e:\n        print(f\"Error : {e}\")\n        return None","4a3de018":"p1 = []\np1.append(convert_image_to_array(\"..\/input\/checkerboard\/checkerboard2-156x200.jpg\"))\np1.append(convert_image_to_array(\"..\/input\/checkerboard\/checkerboard0-200x155.jpg\"))\np1.append(convert_image_to_array(\"..\/input\/checkerboard\/checkerboard1-156x200.jpg\"))\n","0bcb6dcb":"import matplotlib.pyplot as plt\n\nplt.figure(figsize=(8,8))\nfor i in range(1,4):\n    plt.subplot(1,3,i)\n    plt.grid(False)\n    plt.imshow(p1[i-1])\n    #plt.xlabel(label_list[i])\nplt.show()","db33ac69":"for filename in images: \n    image = cv2.imread(filename) \n    grayColor = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) \n  \n    # Find the chess board corners \n    # If desired number of corners are \n    # found in the image then ret = true \n    ret, corners = cv2.findChessboardCorners( \n                    grayColor, CHECKERBOARD,  \n                    cv2.CALIB_CB_ADAPTIVE_THRESH  \n                    + cv2.CALIB_CB_FAST_CHECK + \n                    cv2.CALIB_CB_NORMALIZE_IMAGE) \n  \n    # If desired number of corners can be detected then, \n    # refine the pixel coordinates and display \n    # them on the images of checker board \n    if ret == True: \n        threedpoints.append(objectp3d) \n  \n        # Refining pixel coordinates \n        # for given 2d points. \n        corners2 = cv2.cornerSubPix( \n            grayColor, corners, (11, 11), (-1, -1), criteria) \n  \n        twodpoints.append(corners2) \n  \n        # Draw and display the corners \n        image = cv2.drawChessboardCorners(image,  \n                                          CHECKERBOARD,  \n                                          corners2, ret) \n  \nh, w = image.shape[:2] \n  \n  \n# Perform camera calibration by \n# passing the value of above found out 3D points (threedpoints) \n# and its corresponding pixel coordinates of the \n# detected corners (twodpoints) \nret, matrix, distortion, r_vecs, t_vecs = cv2.calibrateCamera( \n    threedpoints, twodpoints, grayColor.shape[::-1], None, None) \n  \n  \n# Displayig required output \nprint(\" Camera matrix:\") \nprint(matrix) \n  \nprint(\"\\n Distortion coefficient:\") \nprint(distortion) \n  \nprint(\"\\n Rotation Vectors:\") \nprint(r_vecs) \n  \nprint(\"\\n Translation Vectors:\") \nprint(t_vecs)","ca5b9276":"# Do camera calibration using OpenCV","7269ab3d":"# Show Images","c3fe3eeb":"# Import required libraries and images"}}