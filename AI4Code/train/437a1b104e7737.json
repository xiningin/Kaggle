{"cell_type":{"ef76b59c":"code","5195314c":"code","e5f980b8":"code","4cfad536":"code","3ded6130":"code","d438ce86":"code","b1be5114":"code","868488db":"code","af61b06b":"markdown","670986c5":"markdown","129e3cad":"markdown","98fb582c":"markdown","8a6ef319":"markdown","d894cec3":"markdown","4ba123ad":"markdown"},"source":{"ef76b59c":"!pip install torchsummary\n\n# system \nimport os\nfrom glob import glob\n\n# util\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport numpy as np\nimport pandas as pd\nimport cv2\n\n# torch\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torchvision import datasets, transforms\nfrom torchsummary import summary\n\nfrom torch.utils.data import Dataset, DataLoader\n\nimport numpy as np\nfrom PIL import Image","5195314c":"# hardware info & setting\nprint(torch.cuda.is_available())\nprint(torch.cuda.get_device_name())\nprint(torch.cuda.device_count())\nprint(torch.cuda.current_device())\n\nos.environ[\"CUDA_VISIBLE_DEVICES\"]='0'","e5f980b8":"# dataset load, tensorlized\nCIFAR10_train = datasets.CIFAR10(root='CIFAR10_data\/', train=True, transform=transforms.ToTensor(), download=True)\nCIFAR10_test = datasets.CIFAR10(root='CIFAR10_data\/', train=False, transform=transforms.ToTensor(), download=True)\nclasses = ['plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck']\n# .data -> nparray \ubcc0\ud658\nprint('Format : batches,height,width,channel')\nprint('train set : ',CIFAR10_train.data.shape)\nprint('test set : ',CIFAR10_test.data.shape)\nprint('classes : ',set(CIFAR10_train.targets))\nprint('classes : ',classes)\n\n# dataset sample \nimg = CIFAR10_train.data[5]\n# (option)resize methods\nimg_np_resize = np.resize(img,(256,256,3))\nimg_cv_resize = cv2.resize(img,(256,256),interpolation=cv2.INTER_CUBIC)\n\n# plot \nfig1, axs1 = plt.subplots(1,3,figsize=(15,5))\naxs1[0].imshow(img)\naxs1[1].imshow(img_np_resize)\naxs1[2].imshow(img_cv_resize)\n\nplt.show()","4cfad536":"device = torch.device(\"cuda\")\nbatch_size = 100\ntraining_epochs = 20\nlearning_rate = 0.001\n\n# drop_last=True : \ubc30\uce58\ub85c \ub098\ub234\uc744\ub54c  \ub9c8\uc9c0\ub9c9 \ubc30\uce58\uac1c\uc218\uac00 \uc791\uc744\uacbd\uc6b0 \uc0ac\uc6a9\uc5ec\ubd80\ndata_loader = torch.utils.data.DataLoader(CIFAR10_train, batch_size=batch_size, shuffle=True)\ntotal_batch = len(data_loader)\nprint('num of batches : ',total_batch)","3ded6130":"class CNN(torch.nn.Module):\n    def __init__(self):\n        super(CNN,self).__init__()\n        self.layer1 = torch.nn.Sequential(\n            torch.nn.Conv2d(in_channels=3, out_channels=32, kernel_size=3,stride=1,padding=1),\n            torch.nn.ReLU(),\n            torch.nn.MaxPool2d(kernel_size=2, stride=2))\n        \n        self.layer2 = torch.nn.Sequential(\n            torch.nn.Conv2d(in_channels=32, out_channels=64, kernel_size=3,stride=1,padding=1),\n            torch.nn.ReLU(),\n            torch.nn.MaxPool2d(kernel_size=2, stride=2))\n        \n        self.layer3 = torch.nn.Sequential(\n            torch.nn.Conv2d(in_channels=64, out_channels=128, kernel_size=3,stride=1,padding=1),\n            torch.nn.ReLU(),\n            torch.nn.MaxPool2d(kernel_size=2, stride=2))\n        \n        self.layer4 = torch.nn.Sequential(\n            torch.nn.Conv2d(in_channels=128, out_channels=625, kernel_size=3,stride=1,padding=2),\n            torch.nn.ReLU(),\n            torch.nn.MaxPool2d(kernel_size=2, stride=2))\n        \n        self.adaptive_avg_pool = torch.nn.AdaptiveAvgPool2d((2,2))\n        \n        self.fc_layer = torch.nn.Linear(625*2*2,10,bias=True)\n    \n    def forward(self,x):\n        # (500, 3, 32, 32)\n        L1 = self.layer1(x)\n        # (500, 32, 16, 16)\n        L2 = self.layer2(L1)\n        # (500, 64, 8, 8)\n        L3 = self.layer3(L2)\n        # (500, 128, 4, 4)\n        L4 = self.layer4(L3)\n        # (500, 625, 3, 3)\n        L4 = self.adaptive_avg_pool(L4)\n        # (500, 625, 2, 2)\n        fc_input = L4.view(L4.size(0), -1)\n        fc = self.fc_layer(fc_input)\n        return fc\n    \n\nmodel = CNN().to(device)\nsummary(model, (3, 32, 32))","d438ce86":"loss_func = torch.nn.CrossEntropyLoss().to(device)\noptimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)\n\nfor epoch in range(training_epochs):\n    avg_cost = 0\n\n    for img, label in data_loader:\n        X = img.to(device)\n        Y = label.to(device)\n        optimizer.zero_grad()\n        hypothesis = model(X)\n        cost = loss_func(hypothesis, Y)\n        cost.backward()\n        optimizer.step()\n\n        avg_cost += cost \/ total_batch\n\n    print('[Epoch: %d, cost = %.9f' %(epoch + 1, avg_cost))","b1be5114":"transform = transforms.Compose([transforms.ToTensor()])\n\ncorrect_cnt = 0\nwith torch.no_grad():\n    for img, label in zip(CIFAR10_test.data, CIFAR10_test.targets):\n        test_img = transform(img).unsqueeze(0).to(device)\n        prediction = model(test_img)\n        correct_prediction = torch.argmax(prediction, 1).item()\n        if correct_prediction == label:\n            correct_cnt += 1\n\nprint('Accuracy of the network on the 10000 test images: %.4f %%' % (100 * correct_cnt \/ len(CIFAR10_test.data)))","868488db":"pred_cnt = 49\ntest_data_loader = torch.utils.data.DataLoader(CIFAR10_test, batch_size=pred_cnt, shuffle=True)\nCIFAR10_test_tensor_imgs, CIFAR10_test_labels = next(iter(test_data_loader))\n\npred_labels = model(CIFAR10_test_tensor_imgs.to(device))\ncompare_labels = list(zip(CIFAR10_test_labels, torch.argmax(pred_labels, 1).tolist()))\n\nwrong_cnt = 0\nnum_grids = 7\nfig, axes = plt.subplots(num_grids,num_grids, figsize=(15, 15))\nfor i, ax in enumerate(axes.flat):\n    if i < pred_cnt:\n        img = CIFAR10_test_tensor_imgs[i].numpy().transpose(1, 2, 0)\n        ax.imshow(img, interpolation='nearest')\n        ax.set_xticks([])\n        ax.set_yticks([])\n        if compare_labels[i][0] != compare_labels[i][1]:\n            ax.set_xlabel(\"T: {}, P: {}\".format(classes[compare_labels[i][0]], classes[compare_labels[i][1]]), color='r')\n            wrong_cnt += 1\n        else:\n            ax.set_xlabel(\"T: {}, P: {}\".format(classes[compare_labels[i][0]], classes[compare_labels[i][1]]))\n\nprint('Accuracy : %.5f%%' % ((1-wrong_cnt \/ pred_cnt ) * 100))\nplt.show()","af61b06b":"---\n## 4. model structure","670986c5":"---\n## 5. model train","129e3cad":"---\n## 1. import packages","98fb582c":"---\n## 3. dataset load","8a6ef319":"---\n## 2. check hardwares","d894cec3":"# Contents\n  - [1. import packages](#1.-import-packages)\n  - [2. check hardwares](#2.-check-hardwares)\n  - [3. dataset load](#3.-dataset-load)\n  - [4. model structure](#4.-model-structure)\n  - [5. model train](#5.-model-train)\n  - [6. validation](#6.-validation)","4ba123ad":"---\n## 6. validation"}}