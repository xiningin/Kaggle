{"cell_type":{"bd4ae881":"code","9f5f2d21":"code","222f1050":"code","9db57f79":"code","8a17c370":"code","dc178139":"code","1ece99e4":"code","7b342c45":"code","893a6168":"markdown","d7c1fbd3":"markdown","6e4a03a6":"markdown","1fb80b50":"markdown","f2c35c74":"markdown"},"source":{"bd4ae881":"import numpy as np \nimport pandas as pd \nimport math\nimport itertools\nimport datetime","9f5f2d21":"def datasets_creating():\n    pro = pd.read_csv('..\/input\/professionals.csv')\n    qs = pd.read_csv(\"..\/input\/questions.csv\")\n    ans = pd.read_csv('..\/input\/answers.csv')\n    tags = pd.read_csv('..\/input\/tags.csv')\n    qs_tags = pd.read_csv('..\/input\/tag_questions.csv')\n    user_tag = pd.read_csv('..\/input\/tag_users.csv')\n    email = pd.read_csv('..\/input\/emails.csv')\n    match = pd.read_csv('..\/input\/matches.csv')\n    \n    ans_proff = pd.merge(qs, ans, left_on='questions_id', right_on='answers_question_id')\n    ans_proff = ans_proff.filter(['answers_author_id','answers_date_added']) \n    \n    email_matches = pd.merge(email, match, left_on='emails_id', right_on='matches_email_id')\n    email_proff = pd.merge(email_matches, qs, left_on='matches_question_id', right_on='questions_id')\n    email_proff = pd.merge(email_proff, ans, left_on='questions_id', right_on='answers_question_id') \n    email_proff = email_proff.drop(['answers_body', 'questions_body', 'questions_title', 'emails_frequency_level'],axis=1)\n    \n    qs_tags.sort_values('tag_questions_question_id')\n    qs_tagnames = pd.merge(qs_tags, tags, left_on='tag_questions_tag_id',right_on='tags_tag_id')\n    qs_tagnames = qs_tagnames.drop(['tags_tag_id','tag_questions_tag_id'], axis=1)\n    user_tag_exp = pd.merge(tags,user_tag, left_on='tags_tag_id', right_on='tag_users_tag_id')\n    user_tag_exp = user_tag_exp.drop(['tags_tag_id','tag_users_tag_id'], axis=1)\n    user_tag_exp.sort_values('tag_users_user_id')\n    tag_pivot = user_tag_exp.pivot_table(values='tags_tag_name', index='tag_users_user_id', aggfunc=lambda x: \" \".join(x))\n    tag_pivot['tag_users_user_id'] = tag_pivot.index\n    tag_pivot=tag_pivot.reset_index(drop=True)\n    qs_tag_pivot = qs_tagnames.pivot_table(index='tag_questions_question_id', values='tags_tag_name', aggfunc=lambda x: \" \".join(x))\n    qs_tag_pivot['tag_questions_question_id']=qs_tag_pivot.index\n    qs_tag_pivot = qs_tag_pivot.reset_index(drop=True)\n    qs_with_tags = pd.merge(qs, qs_tag_pivot, left_on='questions_id', right_on='tag_questions_question_id')\n    qs_with_tags = qs_with_tags.merge(right=ans, how='inner', left_on='questions_id', right_on='answers_question_id')\n    tags = qs_with_tags.merge(right=tag_pivot, left_on='answers_author_id', right_on='tag_users_user_id')\n    tags = tags.filter(['tags_tag_name_x', 'answers_author_id', 'tags_tag_name_y', 'tag_users_user_id'])\n    \n    return ans_proff, email_proff, tags\n    \nans_proff, email_proff, df = datasets_creating()","222f1050":"class Professionals:\n    \"\"\"Selects the most suitable professionals for a particular question.\n\n    Args:\n        ans_proff (pandas.DataFrame): Questions with professional answers.\n        email_proff (pandas.DataFrame): Email matches with professional, questions and professional answers.\n        num_of_prof (int): The number of professionals who will receive an email.\n        \n    Returns:\n        list: Sorted list of the most suitable professionals.\n    \n    \"\"\"\n    def __init__(self, ans_proff, email_proff, num_of_prof=10):\n        \n        self.num_of_prof = num_of_prof\n        self.ans_proff = ans_proff\n        self.email_proff = email_proff \n        self.proffessional_tags = None\n        self.sigmoid = lambda x: 1 \/ (1 + np.exp(-x))\n          \n        \n    def fit_for_tags(self, df, ind=1):\n        \"\"\"Create list with relevance values of the tags, for each professional.\n\n        Args:\n            df (pandas.DataFrame): The number of professionals who will receive an email.\n\n        \"\"\"\n        if ind == 1: #Fitting data for the first time\n            proffessional_tags = {}\n        else: #Fitting data not for the first time\n            proffessional_tags = self.proffessional_tags\n        \n\n        for tags in np.array(df):\n            for tag in tags[2].split():\n                if tags[1] in proffessional_tags:\n                    proffessional_tags[tags[1]][tag] = 1.0\n                else:\n                    proffessional_tags[tags[1]] = {tag: 1.0}\n                    \n        for proff in proffessional_tags: \n            #Professional answers on the questions.\n            proff_ans = df['tags_tag_name_x'][(df['answers_author_id'] == proff)]\n\n            for tags in proff_ans:\n                for question_tag in tags.split():\n                    #Increasing values of tags, that were in the questions \n                    #that were answered recently by professionals\n                    if question_tag in proffessional_tags: \n                        if proffessional_tags[proff][question_tag] != 1.0: \n                            proffessional_tags[proff][question_tag] = proffessional_tags[proff][question_tag] + 0.125\n                    else:\n                        proffessional_tags[proff][question_tag] = 1.0\n\n                for proff_tag in proffessional_tags[proff]:\n                    if proff_tag not in tags.split():\n                        if ind == 0:\n                            \n                            print(proff_tag)\n                            print(proffessional_tags[proff][proff_tag])\n                        proffessional_tags[proff][proff_tag] = proffessional_tags[proff][proff_tag] - 0.125\n                        if ind == 0:\n                            print(proffessional_tags[proff][proff_tag] - 0.125, proffessional_tags[proff][proff_tag])\n        \n        #Delete unnecessary data\n        for proff in proffessional_tags.copy():\n            for ex_tag in proffessional_tags[proff].copy():\n                if proffessional_tags[proff][ex_tag] <= 0:\n                    proffessional_tags[proff].pop(ex_tag)\n                    \n        self.proffessional_tags = proffessional_tags   \n        \n    def predict_by_tags(self, tags):\n        \"\"\"First Tag Module.\n\n        Args:\n            tags (str): Tags of the question.\n\n        Returns:\n            list: Sorted list of the most suitable professionals; based on their tags relevance values.\n\n        \"\"\"\n        proffessional_tags = self.proffessional_tags\n        candidates = []\n        tags = tags.split()\n        num = 0\n\n        while len(candidates) < self.num_of_prof: \n            max_candidates = []\n            \n            for i in itertools.combinations(tags, len(tags)-num):\n                if len(tags) == num: \n                    return max_candidates\n                \n                for proff in proffessional_tags:\n                    ind_ = 0\n                    for tag in i:\n                        if str(tag) not in list(proffessional_tags[proff]):\n                            ind_ = 1\n                            \n                    if ind_ == 0:\n                        normilaze_data = 0\n                        for tag in proffessional_tags[proff]:\n                            tag_value = proffessional_tags[proff][tag]\n                            normilaze_data = normilaze_data + tag_value\n\n                        normilaze_data = 1 \/ (1 + np.exp(-normilaze_data))\n                        candidates.append([normilaze_data, proff])\n                        \n                candidates = sorted(candidates, key=lambda x: x[0]) \n                candidates.reverse()     \n                \n                if len(max_candidates) < len(candidates):\n                    max_candidates = candidates\n\n            num = num + 1\n\n        return candidates\n        \n        \n    def predict_by_activity(self, proff, max_last_activity=500):\n        \"\"\"Second Activity Module.\n\n        Args:\n            proff (str): List of professionals preprocessed by First Activity module.\n            max_last_activity (int): Last date of professional activity must be leass than max_last_activity ago.\n\n        Returns:\n            list: Sorted list of the most suitable professionals.\n\n        \"\"\"\n        \n        ans_num = {}\n        ans_email_num = {}\n        ans_email_time = {}\n        last_day_activity = {}\n\n        for i in proff:\n            email_ind = [0.5, 1]\n\n            proff_all_ans = self.ans_proff[:][(self.ans_proff[\"answers_author_id\"] == i)]\n            \n            if len(proff_all_ans) == 0:\n                ans_num[i] = 2\n                last_day_activity[i] = 2\n            else:\n                #First factor\n                ans_num[i] = self.sigmoid(len(proff_all_ans))\n\n                #Second factor\n                days = (datetime.datetime.now() - datetime.datetime.strptime(datetime.datetime.strptime(proff_all_ans[-1:][\"answers_date_added\"].values[0], \"%Y-%m-%d %H:%M:%S UTC%z\").strftime(\"%Y-%m-%d\"), \"%Y-%m-%d\")).days\n\n                if max_last_activity < days:\n                    last_day_activity[i] = 2\n                else:\n                    last_day_activity[i] = self.sigmoid(np.sqrt(days))\n            \n            ans_email_match = self.email_proff[:][(self.email_proff[\"answers_author_id\"] == i)]\n            ans_email_match = ans_email_match[:][(ans_email_match[\"emails_recipient_id\"] == i)]\n\n            if len(ans_email_match) == 0:\n                email_ind = email_ind[0]\n                ans_email_num[i] = 1\n                ans_email_time[i] = 1\n            else:\n                email_ind = email_ind[1]\n\n                #Third factor\n                ans_email_num[i] = self.sigmoid(len(ans_email_match))\n\n                #Fourth factor\n                ans_time = [] #Days between sending email and getting the answer on the question from email\n\n                for index, row in ans_email_match.iterrows():\n                    ans_time.append([row[\"emails_date_sent\"], row[\"answers_date_added\"]])\n\n                mean = 0\n                for item in ans_time:\n                    email_send_date = datetime.datetime.strptime(datetime.datetime.strptime(item[0], \"%Y-%m-%d %H:%M:%S UTC%z\").strftime(\"%Y-%m-%d\"), \"%Y-%m-%d\")\n                    ans_made_date = datetime.datetime.strptime(datetime.datetime.strptime(item[1], \"%Y-%m-%d %H:%M:%S UTC%z\").strftime(\"%Y-%m-%d\"), \"%Y-%m-%d\")\n\n                    mean = mean + (ans_made_date - email_send_date).days\n\n                mean = mean \/ len(ans_email_match)\n                ans_email_time[i] = self.sigmoid(mean)\n\n        #Get activity value for each candidate and sort them\n        professionals = []\n        for i in ans_email_num:\n            activity_value = 1 + (ans_email_num[i] - ans_email_time[i]) * email_ind + ans_num[i] - last_day_activity[i]\n            professionals.append([activity_value, i])\n\n        professionals = sorted(professionals, key=lambda x: x[0]) \n        professionals.reverse()\n\n        return professionals","9db57f79":"num_of_prof = 10\n\nmodel = Professionals(ans_proff, email_proff, num_of_prof=num_of_prof)\n\nmodel.fit_for_tags(df) \nprofessionals = model.predict_by_tags('job')","8a17c370":"professionals","dc178139":"professionals = np.array(professionals)","1ece99e4":"professionals_best = model.predict_by_activity(professionals[:num_of_prof, 1])","7b342c45":"professionals_best","893a6168":"## Example of work:","d7c1fbd3":"\n\n\n# Model realization","6e4a03a6":"Solution is implemented as Professionals class. This class create sorted list which contains the most appropriate professionals to answer the question.  \n\nProfessionals class contains two modules: \n\n<ul>\n<li>First of them is implemented for selecting most suitable professionals by tags. \n<\/li>\n<li>Second is for sorting most suitable professionals (from preprocessed list by first module) by their activity.<\/li>\n<\/ul>\n\n<h3>Brief description of First Tag Module realization:<\/h3>\n\n<ol>\n        <li>For each professional:\n            <ol><li>Each tag has its own relevance value, this value is between 0 and 1. At the beginning of the algorithm, all tags contained in the professional profile are 1.0\n<\/li>\n<li>The cycle contains questions (answered by a professional) sorted by date. Depending on the tags in each question, the relevance values for each tag change.<\/li> <\/ol>\n        <\/li>\n\n<li>From the current question for which we want to get the best candidates, tags are extracted.<\/li>\n<li>Using the list obtained in 2. using the sigmoid function, a single value of relevance for the current question is calculated.<\/li>\n<li>Returns a list with relevance values sorted in descending order and professionals.<\/li>\n<\/ol>\n\nIt is implemented in the function predict_by_tags().\n\n<h3>Brief description of Second Activity Module realization:<\/h3>\n\nFormula of calculation professional activity:\n$$activity = 1 + (e_i^n - e_i^t)*ind_i + a_i^n - d_i$$\n\n$$where, i - \\text{professional index};$$\n\n$$e_i^n - \\text{number of answers on the questions that were emailed};$$\n\n$$e_i^t - \\text{time of answering on the questions that were emailed};$$\n\n$$ind_i - \\begin{cases} 0.5 &  \\text{if no emails were sent to professional} \\\\ 1.0  &  \\text{if emails were sent to professional}\\end{cases};$$\n\n$$a_i^n - \\text{number of answers on the questions};$$\n\n$$d_i - \\text{last date of (professional activity) answering on the questions}$$\n\nIt is implemented in the function predict_by_activity().","1fb80b50":"### A proposal to improve the efficiency of choosing the number of professionals to whom an email will be sent\n\nMy approach is not only to ask on the question: \u201cWho of the professionals should receive an email?\u201d, but also answer on the question \u201cHow many of the professionals should receive an email?\u201d.\n\nI will describe a fairly simple solution to this question: \n<br><br>\n<div style=\"width:60%; text-align:center; margin: 0 auto;\">  To select the optimal number of professionals, you need to add a block with data of the views number for each question, to the site. With this module, one could form a datatset containing data on how many times the question was viewed and how many answers it had, and then create a model and train it on this dataset.<br><br>\nOr, one could simply get the ratio of the number of views and answers to a particular class of questions.\n<\/div>","f2c35c74":"Here we're creating 3 datasets for further work with them:"}}