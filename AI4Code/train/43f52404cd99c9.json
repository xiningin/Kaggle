{"cell_type":{"5d2eb733":"code","c219e2e0":"code","bbee39db":"code","0cfb46e3":"code","434fdabd":"code","959d2089":"code","5ce2d8ff":"code","5d69cedc":"code","dfad6fff":"code","ffff9e83":"code","83852764":"code","6bf4a9a5":"code","2822aa03":"code","83d5ecee":"markdown","1165a973":"markdown"},"source":{"5d2eb733":"#Imports\nimport torch\nimport torch.nn as nn\nimport numpy as np\nfrom sklearn import datasets\nimport matplotlib.pyplot as plt","c219e2e0":"# Data prep\nX_numpy, y_numpy = datasets.make_regression(n_samples=100, n_features=1, noise=20, random_state=4)\n\n# cast to float Tensor\nX = torch.from_numpy(X_numpy.astype(np.float32))\ny = torch.from_numpy(y_numpy.astype(np.float32))\ny = y.view(y.shape[0], 1) #to make it column\n\nn_samples, n_features = X.shape","bbee39db":"# Create the model\n\nmodel = nn.Linear(n_features, 1)","0cfb46e3":"# Calculate loss and  define the optimizer\nlearning_rate = 0.01\n\ncriterion = nn.MSELoss()\noptimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)","434fdabd":"# Training \nnum_epochs = 100\nfor epoch in range(num_epochs):\n    # Forward pass and loss\n    y_predicted = model(X)\n    loss = criterion(y_predicted, y)\n    \n    # Backward pass and update\n    loss.backward()\n    optimizer.step()\n\n    # zero grad before new step\n    optimizer.zero_grad()\n\n    if (epoch+1) % 10 == 0:\n        print(f'epoch: {epoch+1}, loss = {loss.item():.4f}')","959d2089":"# Plot\npredicted = model(X).detach().numpy()\n\nplt.plot(X_numpy, y_numpy, 'ro')\nplt.plot(X_numpy, predicted, 'b')\nplt.show()","5ce2d8ff":"# Imports\nimport torch\nimport torch.nn as nn\nimport numpy as np\nfrom sklearn import datasets\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split","5d69cedc":"# Data prep\n\nbc = datasets.load_breast_cancer()\nX, y = bc.data, bc.target\n\nn_samples, n_features = X.shape\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1234)","dfad6fff":"# scale\nsc = StandardScaler()\nX_train = sc.fit_transform(X_train)\nX_test = sc.transform(X_test)\n\nX_train = torch.from_numpy(X_train.astype(np.float32))\nX_test = torch.from_numpy(X_test.astype(np.float32))\ny_train = torch.from_numpy(y_train.astype(np.float32))\ny_test = torch.from_numpy(y_test.astype(np.float32))\n\ny_train = y_train.view(y_train.shape[0], 1)\ny_test = y_test.view(y_test.shape[0], 1)","ffff9e83":"# Create custom model\n# Linear model f = wx + b , sigmoid at the end\nclass Model(nn.Module):\n    def __init__(self, n_input_features):\n        super(Model, self).__init__()\n        self.linear = nn.Linear(n_input_features, 1)\n\n    def forward(self, x):\n        y_pred = torch.sigmoid(self.linear(x))\n        return y_pred\n\nmodel = Model(n_features)","83852764":"# Calculate loss and  define the optimizer\nnum_epochs = 100\nlearning_rate = 0.01\ncriterion = nn.BCELoss()\noptimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)","6bf4a9a5":"# Training \nfor epoch in range(num_epochs):\n    # Forward pass and loss\n    y_pred = model(X_train)\n    loss = criterion(y_pred, y_train)\n\n    # Backward pass and update\n    loss.backward()\n    optimizer.step()\n\n    # zero grad before new step\n    optimizer.zero_grad()\n\n    if (epoch+1) % 10 == 0:\n        print(f'epoch: {epoch+1}, loss = {loss.item():.4f}')","2822aa03":"# Test\nwith torch.no_grad():\n    y_predicted = model(X_test)\n    y_predicted_cls = y_predicted.round()\n    acc = y_predicted_cls.eq(y_test).sum() \/ float(y_test.shape[0])\n    print(f'accuracy: {acc.item():.4f}')","83d5ecee":"# 1- Linear Regression","1165a973":"# 2- Logistic Regression"}}