{"cell_type":{"f6d38bd6":"code","e38a9836":"code","cea48a3e":"code","01566b66":"code","ffdbe780":"code","8183bc3e":"code","0e042814":"code","ab909738":"code","00b4a849":"code","3124279c":"code","10113ca5":"code","e1255f77":"code","c87a599d":"code","b6d8593a":"code","207feee0":"code","38a0f371":"code","f910c99b":"code","82a8d2cc":"code","06cba0af":"code","6cdbf98a":"code","d906688b":"code","d51caee9":"code","2dcf404a":"code","08416514":"code","00b4e47a":"code","69b97c11":"code","4f53bde0":"code","4e088552":"code","631d47a4":"code","0ea2c856":"code","69865be6":"code","17fb8e54":"code","a60cd29f":"code","204c2cfb":"code","867aa67d":"code","59ff7256":"code","d2c4c334":"code","e9b98730":"code","91b7cc32":"code","8ade552a":"code","7782284f":"code","4ad63e9e":"code","037bde23":"code","7d8c027c":"code","ecd16f96":"markdown","2b35a8ba":"markdown","e72df1df":"markdown","d8fc5daf":"markdown","a99ad723":"markdown","76e8bb03":"markdown","791a2ef4":"markdown","30eb8c10":"markdown","6a3bd993":"markdown"},"source":{"f6d38bd6":"!ls ..\/input\/tmlcchackathon\/'archive (2)'","e38a9836":"!ls ..\/input\/tmlcchackathon\/","cea48a3e":"!cp -r ..\/input\/tmlcchackathon .\/\n!cp -r __notebook_source__.ipynb .\/tmlcchackathon\/'archive (2)'\/tmlcc-hackathon-dev\/tmlcc-hackathon-dev\/","01566b66":"!cp  ..\/input\/tmlcchackathon\/'archive (2)'\/test.csv  tmlcchackathon\/'archive (2)'\/tmlcc-hackathon-dev\/tmlcc-hackathon-dev\/","ffdbe780":"!ls tmlcchackathon\/\"archive (2)\"\/tmlcc-hackathon-dev\/tmlcc-hackathon-dev","8183bc3e":"import os\nos.chdir('tmlcchackathon\/archive (2)\/tmlcc-hackathon-dev\/tmlcc-hackathon-dev')","0e042814":"!ls","ab909738":"import os\nimport pandas as pd\n\n\nimport numpy as np\nfrom sklearn.impute import KNNImputer\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.preprocessing import power_transform\nfrom catboost import CatBoostRegressor\n\n# Local dependencies\nfrom src.constants import (\n    PREPROCESSING_PATH,\n    TARGET\n)\nfrom utils.classes.extractor import FunctionalGroupToGramExtractor\n\nfrom typing import (\n    Optional,\n    List,\n    Any\n)\nfrom sklearn.model_selection import KFold, RepeatedKFold, RepeatedStratifiedKFold\n\nimport pickle\nimport json\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","00b4a849":"Train = pd.read_csv(f\"{PREPROCESSING_PATH}\/train_merged_CIF\/Train.csv\")\nTrain = Train.set_index(Train.columns[0])\n\nPretest = pd.read_csv(f\"test.csv\")\nPretest = Pretest.set_index(Pretest.columns[0])\n\nfuntional_group_extractor = FunctionalGroupToGramExtractor()","3124279c":"# !ls ..\/..\/..\/sra_2to15.csv","10113ca5":"sra = pd.read_csv(\"..\/..\/..\/sra_2to15.csv\")\nsra = sra.set_index(sra.columns[0])","e1255f77":"flag = 'train'\nquery = Train.MOFname.isin(sra[sra['flag'] == flag].index)\nselect = ['metal_linker', 'organic_linker1', 'organic_linker2']\nTrain.at[query, select] = sra.loc[sra['flag'] == flag][select].values\n\nflag = 'test'\nquery = Pretest.MOFname.isin(sra[sra['flag'] == flag].index)\nPretest.at[query, select] = sra.loc[sra['flag'] == flag][select].values","c87a599d":"Train[\"_cell_angle_alpha\"] = np.deg2rad(Train[\"_cell_angle_alpha\"])\nTrain[\"_cell_angle_beta\"] = np.deg2rad(Train[\"_cell_angle_beta\"])\nTrain[\"_cell_angle_gamma\"] = np.deg2rad(Train[\"_cell_angle_gamma\"])\n\nPretest[\"_cell_angle_alpha\"] = np.deg2rad(Pretest[\"_cell_angle_alpha\"])\nPretest[\"_cell_angle_beta\"] = np.deg2rad(Pretest[\"_cell_angle_beta\"])\nPretest[\"_cell_angle_gamma\"] = np.deg2rad(Pretest[\"_cell_angle_gamma\"])\n","b6d8593a":"train_transformer = pd.read_csv(\"..\/..\/..\/train_rdf_encoded_df_v3.csv\")\ntest_transformer = pd.read_csv(\"..\/..\/..\/test_rdf_encoded_df_v3.csv\")\nTrain = Train.merge(\n    train_transformer,\n    left_on='MOFname',\n    right_on='MOFname'\n)\n\nPretest = Pretest.merge(\n    test_transformer,\n    left_on='MOFname',\n    right_on='MOFname'\n)","207feee0":"corr = Train.corr()\nnan_features = corr[TARGET][corr[TARGET].isna()].index\nTrain = Train.drop(nan_features, axis=1)\nPretest = Pretest.drop(nan_features, axis=1)","38a0f371":"# train_transformer = pd.read_csv(\"..\/..\/..\/train_rdf_encoded_df_v1.csv\")\n# test_transformer = pd.read_csv(\"..\/..\/..\/test_rdf_encoded_df_v1.csv\")\n# Train = Train.merge(\n#     train_transformer,\n#     left_on='MOFname',\n#     right_on='MOFname'\n# )\n\n# Pretest = Pretest.merge(\n#     test_transformer,\n#     left_on='MOFname',\n#     right_on='MOFname'\n# )","f910c99b":"# train_pseudo_label = pd.read_csv(\"..\/..\/..\/train_pseudo_label_v3.csv\")\n# test_pseudo_label = pd.read_csv(\"..\/..\/..\/test_pseudo_label_v3.csv\")\n# Train = Train.merge(\n#     train_pseudo_label,\n#     left_on='MOFname',\n#     right_on='MOFname'\n# )\n\n# Pretest = Pretest.merge(\n#     test_pseudo_label,\n#     left_on='MOFname',\n#     right_on='MOFname'\n# )","82a8d2cc":"# def apply_rdf(df):\n#     la = df[\"_cell_length_a\"]\n#     lb = df[\"_cell_length_b\"]\n#     lc = df[\"_cell_length_c\"]\n#     aa = df[\"_cell_angle_alpha\"]\n#     ab = df[\"_cell_angle_beta\"]\n#     ag = df[\"_cell_angle_gamma\"]\n#     cv = df[\"_cell_volume\"]\n#     prop_names = [\"electronegativity\", \"hardness\", \"vdWaalsVolume\"]\n#     prop_list = [apd[name] for name in prop_names]\n#     n_props = len(prop_names)\n    \n#     # frac2cart = np.zeros([3, 3], dtype=float)\n#     lb_cos_ag = lb * np.cos(ag)\n#     lc_cos_ab = lc * np.cos(ab)\n#     lb_sin_ag = lb * np.sin(ag)\n#     lc_cos_sin = lc * (np.cos(aa) - np.cos(ab)*np.cos(ag)) \/ np.sin(ag)\n#     cv_la_lb_sin = cv \/ (la * lb * np.sin(ag))\n    \n#     return pd.Series(\n#         [lb_cos_ag, lc_cos_ab, lb_sin_ag, lc_cos_sin, cv_la_lb_sin],\n#         index=[\n#             \"lb_cos_ag\",\n#             \"lc_cos_ab\",\n#             \"lb_sin_ag\",\n#             \"lc_cos_sin\",\n#             \"cv_la_lb_sin\"\n#         ]\n#     )\n\n\n# Pretest[[\n#     \"lb_cos_ag\",\n#     \"lc_cos_ab\",\n#     \"lb_sin_ag\",\n#     \"lc_cos_sin\",\n#     \"cv_la_lb_sin\"\n# ]] = Pretest.apply(lambda x: apply_rdf(x), axis=1)\n","06cba0af":"Pretest.index.name = \"id\"\nPretest","6cdbf98a":"# metal_linker = pd.read_csv(\"metal_linker_agg.csv\", index_col=0)\n# metal_linker = metal_linker[[\n#     \"metal_linker__convex_hull_area\",\n#     \"metal_linker__convex_hull_volume\",\n#     \"metal_linker__convex_hull_npoints\",\n#     \"metal_linker__convex_hull_nsimplex\"\n# ]]","d906688b":"# metal_linker = pd.read_csv(\"metal_linker_agg.csv\", index_col=0)\n# metal_linker = metal_linker[[\n#     \"metal_linker__convex_hull_area\",\n#     \"metal_linker__convex_hull_volume\",\n#     \"metal_linker__convex_hull_npoints\", \n#     \"metal_linker__convex_hull_nsimplex\"\n# ]]\n\n# organic_linker = pd.read_csv(\"organic_linker_agg.csv\", index_col=0)\n# organic_linker = organic_linker.drop([\n#     \"organic_linker__convex_hull_area\",\n#     \"organic_linker__convex_hull_volume\",\n#     \"organic_linker__convex_hull_npoints\",\n#     \"organic_linker__convex_hull_nsimplex\"\n# ], axis=1)\n\n\n# Train = Train.merge(\n#     metal_linker,\n#     left_on='metal_linker',\n#     right_index=True,\n\n# )\n\n# Train = Train.merge(\n#     organic_linker,\n#     left_on='organic_linker1',\n#     right_index=True,\n# )\n\n# Train = Train.merge(\n#     organic_linker,\n#     left_on='organic_linker2',\n#     right_index=True,\n#     suffixes=(\"_1\", \"_2\")\n# )\n\n# Pretest = Pretest.merge(\n#     metal_linker,\n#     left_on='metal_linker',\n#     right_index=True,\n# )\n\n# Pretest = Pretest.merge(\n#     organic_linker,\n#     left_on='organic_linker1',\n#     right_index=True,\n# )\n\n# Pretest = Pretest.merge(\n#     organic_linker,\n#     left_on='organic_linker2',\n#     right_index=True,\n#     suffixes=(\"_1\", \"_2\")\n# )","d51caee9":"# stat = pd.read_csv(\"..\/..\/functionalgroup_stat2.csv\")\n\n# Train['functional_groups'] = np.where(\n#     pd.isna(Train['functional_groups']),\n#     'unknown',\n#     Train['functional_groups']\n# )\n\n# Train = Train.merge(stat, on=['functional_groups','topology'], how = 'left')\n\n# Pretest['functional_groups'] = np.where(\n#     pd.isna(Pretest['functional_groups']),\n#     'unknown',\n#     Pretest['functional_groups']\n# )\n\n# Pretest = Pretest.merge(stat, on=['functional_groups','topology'], how = 'left')","2dcf404a":"# train_imputation = pd.read_csv(\"imputer\/xgboost\/train.csv\", index_col=0).drop(\n#     [\n#         'MOFname',\n#         'void_fraction_imputed',\n#         'void_volume_imputed',\n#         'surface_area_imputed',\n#     ],\n#     axis=1\n# )\n# # Train = Train.rename(columns={'surface_area [m^2\/g]': 'surface_area_old'})\n# Train = pd.concat(\n#     [\n#         Train.drop([\n#             'void_fraction',\n#             'void_volume [cm^3\/g]',\n#             'surface_area [m^2\/g]'\n#         ], axis=1),\n#         train_imputation\n#     ], axis=1\n# )\n\n# pretest_imputation = pd.read_csv(\"imputer\/xgboost\/pretest.csv\", index_col=0).drop(\n#     [\n#         'MOFname',\n#         'void_fraction_imputed',\n#         'void_volume_imputed',\n#         'surface_area_imputed'\n#     ],\n#     axis=1\n# )\n# Pretest = pd.concat(\n#     [\n#         Pretest.drop([\n#             'void_fraction',\n#             'void_volume [cm^3\/g]',\n#             'surface_area [m^2\/g]'\n#         ], axis=1),\n#         pretest_imputation\n#     ], axis=1\n# )","08416514":"class PreprocessingPipeline:\n    funcgroup2num = None\n    topology2num = None\n    spacegroup2num = None\n    organic_linker1 = None\n    organic_linker2 = None\n\n    def label(self, df):\n        # if self.funcgroup2num is None:\n        #     self.funcgroup2num = {\n        #         c: i\n        #         for i, c\n        #         in enumerate(df[\"functional_groups\"].unique())\n        #     }\n\n        # if self.topology2num is None:\n        #     self.topology2num = {\n        #         c: i\n        #         for i, c\n        #         in enumerate(df[\"topology\"].unique())\n        #     }\n        # df[\"label_topology\"] = df[\"topology\"].map(self.topology2num)\n\n        df[\"label_topology_pcu\"] = (df[\"topology\"] == \"pcu\").astype(int)\n        df[\"label_topology_sra\"] = (df[\"topology\"] == \"sra\").astype(int)\n        df[\"label_topology_acs\"] = (df[\"topology\"] == \"acs\").astype(int)\n        df[\"label_topology_etb\"] = (df[\"topology\"] == \"etb\").astype(int)\n        df[\"label_topology_bcu\"] = (df[\"topology\"] == \"bcu\").astype(int)\n        df[\"label_topology_nbo\"] = (df[\"topology\"] == \"nbo\").astype(int)\n        \n        \n        df[\"label_spacegroup_triclinic\"] = (\n            df[\"_space_group_crystal_system\"] == \"triclinic\"\n        ).astype(int)\n\n        df[\"metal_linker_1\"] = (\n            df[\"metal_linker\"] == 1\n        ).astype(int)\n        df[\"metal_linker_2\"] = (\n            df[\"metal_linker\"] == 2\n        ).astype(int)\n        df[\"metal_linker_3\"] = (\n            df[\"metal_linker\"] == 3\n        ).astype(int)\n        df[\"metal_linker_4\"] = (\n            df[\"metal_linker\"] == 4\n        ).astype(int)\n        df[\"metal_linker_9\"] = (\n            df[\"metal_linker\"] == 9\n        ).astype(int)\n        df[\"metal_linker_10\"] = (\n            df[\"metal_linker\"] == 10\n        ).astype(int)\n        df[\"metal_linker_12\"] = (\n            df[\"metal_linker\"] == 12\n        ).astype(int)\n\n        if self.organic_linker1 is None:\n            self.organic_linker1 = set(df['organic_linker1'])\n        for linker in self.organic_linker1:\n            if linker == 59:\n                continue\n            df[f\"organic_linker1_{linker}\"] = (\n                df[\"organic_linker1\"] == linker\n            ).astype(int)\n\n        if self.organic_linker2 is None:\n            self.organic_linker2 = set(df['organic_linker2'])\n        for linker in self.organic_linker2:\n            if linker == 59:\n                continue\n            df[f\"organic_linker2_{linker}\"] = (\n                df[\"organic_linker2\"] == linker\n            ).astype(int)\n\n        return df\n    \n\n    @staticmethod\n    def get_density(df: pd.DataFrame):\n        df['density'] = (df[\"weight [u]\"] \/ df[\"volume [A^3]\"]) * 1.66054\n        df['void_volume [cm^3\/g]'] = df['void_fraction'] \/ df[\"density\"]\n        return df\n\n    @staticmethod\n    def replace_surface_area_equal_0_with_null(df: pd.DataFrame):\n        df[\"surface_area [m^2\/g]\"] = df[\"surface_area [m^2\/g]\"].replace(0, np.nan)\n        return df\n\n    @staticmethod\n    def replace_inf_with_null(df: pd.DataFrame):\n        df = df.replace(np.inf, 999999)\n        df = df.replace(-np.inf, -999999)\n        return df\n\n    @staticmethod\n    def drop_unused_columns(\n        df, unused_columns: Optional[List[str]] = None\n    ) -> pd.DataFrame:\n        if not unused_columns:\n            unused_columns = [\n                \"MOFname\",\n                # 'functional_groups',\n                #\"topology\",\n                \"cif_filepath\",\n                \"_audit_creation_date\",\n                \"_symmetry_Int_Tables_number\",\n                \"_symmetry_space_group_name_H-M\",\n                #\"_space_group_crystal_system\",\n                #'metal_linker',\n#                 'organic_linker1',\n#                 'organic_linker2'\n                \"partial_charge_mean\",\n                \"partial_charge_std\",\n                \"_cell_volume\",\n#                 \"bond_type_countAm\",\n                'mof_convex_hull_volume',\n                'mof_convex_hull_area'\n                'mof_convex_hull_npoints',\n                'mof_convex_hull_nsimple',\n#                 'bond_type_countT'\n            ]\n        for col in unused_columns:\n            try:\n                df.drop(col, axis=1, inplace=True)\n            except KeyError:\n                pass\n        return df\n\n    @staticmethod\n    def set_imputer(X: pd.DataFrame) -> KNNImputer:\n        imputer = KNNImputer(n_neighbors=5)\n        imputer.fit(X)\n        return imputer\n\n    @staticmethod\n    def impute_value(X: pd.DataFrame, imputer: KNNImputer):\n        return imputer.transform(X)\n\n    @staticmethod\n    def extract_functional_group(X: pd.DataFrame, fit: bool) -> pd.DataFrame:\n        funtional_group_extacted = funtional_group_extractor.transform(X, fit)\n        return pd.concat([X, funtional_group_extractor], axis=1)\n\n\nclass TrainDataPreprocessingPipeline(PreprocessingPipeline):\n    @staticmethod\n    def drop_surface_area_equal_minus_1(df):\n        return df.drop(df[df[\"surface_area [m^2\/g]\"] == -1].index)\n    \n    @staticmethod\n    def drop_surface_area_equal_0(df):\n        return df.drop(df[df[\"surface_area [m^2\/g]\"] == 0].index)\n    \n    @staticmethod\n    def drop_CO2_N2_selectivity_equal_0(df):\n        return df.drop(df[df[\"CO2\/N2_selectivity\"] == 0].index)\n    \n    \n    @staticmethod\n    def drop_heat_adsorption(df):\n        df = df.drop(df[df[\"heat_adsorption_CO2_P0.15bar_T298K [kcal\/mol]\"] == 0].index)\n        df = df.drop(df[df[\"heat_adsorption_CO2_P0.15bar_T298K [kcal\/mol]\"] == np.inf].index)\n        df = df.drop(df[df[\"heat_adsorption_CO2_P0.15bar_T298K [kcal\/mol]\"] == -np.inf].index)\n        df = df.drop(df[df[\"heat_adsorption_CO2_P0.15bar_T298K [kcal\/mol]\"].isna()].index)\n        return df\n\n    def impute(self):\n        temp_columns = self.X.columns\n        temp_index = self.X.index\n\n        if not self.imputer:\n            self.imputer = self.set_imputer(self.X)\n\n        self.X = self.impute_value(self.X, self.imputer)\n\n        self.X = pd.DataFrame(self.X)\n        self.X.columns = temp_columns\n        self.X.index = temp_index\n\n    def run(self):\n        self.functional_group_extractor = FunctionalGroupToGramExtractor()\n\n        # Drop and add featrures\n        print(\"Print droping and replace null\")\n        self.df = self.drop_surface_area_equal_minus_1(self.df)\n        self.df = self.drop_surface_area_equal_0(self.df)\n        self.df = self.replace_surface_area_equal_0_with_null(self.df)\n        self.df = self.drop_heat_adsorption(self.df)\n        \n        self.df = self.replace_inf_with_null(self.df)\n        self.df = self.label(self.df)\n        self.df = self.drop_unused_columns(self.df)\n        self.df = self.df.drop(self.df[self.df[\"CO2\/N2_selectivity\"] == 0].index)\n        self.df = self.get_density(self.df)\n        # Split\n        print(\"Split X, y\")\n        self.X = self.df.drop(TARGET, axis=1)\n        self.y = self.df[[TARGET]]\n\n        # Extract\n        print(\"Extract functional group\")\n        functional_group = self.functional_group_extractor.transform(\n            self.X[['functional_groups']],\n            fit=True\n        )\n        \n        # Impute\n        print(\"Impute\")\n        self.X = self.X.drop(\"functional_groups\", axis=1)\n        self.impute()\n        self.X = pd.concat([self.X, functional_group], axis=1)\n        assert not (np.any(self.X.isin([-np.inf, np.inf, np.nan])))\n\n    def __init__(self, df: pd.DataFrame, imputer: Any = None):\n        self.df = df\n        self.imputer = imputer\n","00b4e47a":"class TestDataPreprocessingPipeline(PreprocessingPipeline):\n    def impute(self):\n        temp_columns = self.X.columns\n        temp_index = self.X.index\n\n        if not self.imputer:\n            self.imputer = self.set_imputer(self.X)\n\n        self.X = self.impute_value(self.X, self.imputer)\n\n        self.X = pd.DataFrame(self.X)\n        self.X.columns = temp_columns\n        self.X.index = temp_index\n\n    def run(self):\n        # Drop\n        print(\"Print droping and replace null\")\n        self.X = self.replace_surface_area_equal_0_with_null(self.df)\n        self.X = self.replace_inf_with_null(self.X)\n        self.X = self.label(self.X)\n        self.X = self.drop_unused_columns(self.X)\n        self.X = self.get_density(self.X)\n\n        # Extract\n        print(\"Extract functional group\")\n        functional_group = self.functional_group_extractor.transform(\n            self.X[['functional_groups']],\n        )\n\n        # Impute\n        print(\"Impute\")\n        self.X = self.X.drop('functional_groups', axis=1)\n        self.impute()\n        self.X = pd.concat([self.X, functional_group], axis=1)\n        self.X = self.X[self.columns]\n\n    \n    def __init__(\n        self,\n        df: pd.DataFrame,\n        imputer: Any = None,\n        functional_group_extractor: FunctionalGroupToGramExtractor = None,\n        columns: list = None\n    ):\n        self.df = df\n        self.imputer = imputer\n        self.functional_group_extractor = functional_group_extractor\n        self.columns = columns\n\n","69b97c11":"class Imputer9999:\n    def transform(self, df):\n        return df.replace(np.nan, -9999)\n\nimputer = Imputer9999()\ntrain = TrainDataPreprocessingPipeline(Train, imputer)\ntrain.run()","4f53bde0":"test = TestDataPreprocessingPipeline(\n    Pretest,\n    train.imputer,\n    train.functional_group_extractor,\n    train.X.columns\n)\ntest.organic_linker1 = train.organic_linker1\ntest.organic_linker2 = train.organic_linker2\ntest.topology2num = train.topology2num\ntest.spacegroup2num = train.spacegroup2num\ntest.run()","4e088552":"assert all(train.X.columns == test.X.columns)","631d47a4":"len(train.X.columns)","0ea2c856":"df = pd.concat([train.X, train.y], axis =1)\ndf.head()","69865be6":"df_test = test.X","17fb8e54":"df = df[df['CO2\/N2_selectivity']<172]\ndf = df[df['volume [A^3]']<78969]\ndf = df[df['weight [u]']<21348]\ndf = df[df['surface_area [m^2\/g]']<6956]\ndf = df[df['void_volume [cm^3\/g]']<6.1666]\ndf = df[df['heat_adsorption_CO2_P0.15bar_T298K [kcal\/mol]']<11.02]\ndf = df[df['organic_linker1'] != 59]\ndf = df[df['organic_linker2'] != 59]\ndf = df.reset_index(drop = True)\nlen(df)","a60cd29f":"df.insert(\n    loc=3,\n    column=\"density [g\/cm^3]\",\n    value=(df[\"weight [u]\"] \/ df[\"volume [A^3]\"]) * 1.66054,\n)\n\ndf_test.insert(\n    loc=3,\n    column=\"density [g\/cm^3]\",\n    value=(df_test[\"weight [u]\"] \/ df_test[\"volume [A^3]\"]) * 1.66054,\n)\n#Add volumetric suface area\ndf['volume_surface_area'] = df['surface_area [m^2\/g]']*df['density [g\/cm^3]']\n#df_pretest['volume_surface_area'] = df_pretest['surface_area [m^2\/g]']*df_pretest['density [g\/cm^3]']\ndf_test['volume_surface_area'] = df_test['surface_area [m^2\/g]']*df_test['density [g\/cm^3]']","204c2cfb":"from sklearn.preprocessing import LabelEncoder\nle = LabelEncoder()\n'''\ndf['functional_groups'] = df['functional_groups'].fillna('NO_values')\n#df_pretest['functional_groups'] = df_pretest['functional_groups'].fillna('NO_values')\ndf_test['functional_groups'] = df_test['functional_groups'].fillna('NO_values')\n\nstat = pd.read_csv('functionalgroup_stat2.csv')\ndf['functional_groups'] = np.where(pd.isna(df['functional_groups']),'NO_values', df['functional_groups'])\ndf = df.merge(stat, on=['functional_groups','topology'], how = 'left')\n\ndf_test['functional_groups'] = np.where(pd.isna(df_test['functional_groups']),'NO_values', df_test['functional_groups'])\ndf_test = df_test.merge(stat, on=['functional_groups','topology'], how = 'left')\n'''\ndf_processed = df\n#df_processed_pretest = df_pretest.drop('MOFname', axis = 1)\ndf_processed_test = df_test\n\ndf_processed['topology'] = le.fit_transform(df_processed['topology'].values)\n#df_processed_pretest['topology'] = le.transform(df_processed_pretest['topology'].values)\ndf_processed_test['topology'] = le.transform(df_processed_test['topology'].values)\n\n#df_processed['functional_groups'] = le.fit_transform(df_processed['functional_groups'].values)\n#df_processed_pretest['functional_groups'] = le.transform(df_processed_pretest['functional_groups'].values)\n#df_processed_test['functional_groups'] = le.transform(df_processed_test['functional_groups'].values)\n\ndf_processed['_space_group_crystal_system'] = le.fit_transform(df_processed['_space_group_crystal_system'].values)\n#df_processed_pretest['_space_group_crystal_system'] = le.fit_transform(df_processed_pretest['_space_group_crystal_system'].values)\ndf_processed_test['_space_group_crystal_system'] = le.fit_transform(df_processed_test['_space_group_crystal_system'].values)\n\n#df_processed = df_processed[df_processed['heat_adsorption_CO2_P0.15bar_T298K [kcal\/mol]']!=np.inf]\ndf_processed.shape, df_processed_test.shape#, df_processed_pretest.shape","867aa67d":"df_processed[\"metal_encoded\"] = df_processed.groupby(\"metal_linker\")[\"CO2_working_capacity [mL\/g]\"].transform(\"median\")\ndf_processed[\"organic1_encoded\"] = df_processed.groupby(\"organic_linker1\")[\"CO2_working_capacity [mL\/g]\"].transform(\"median\")\ndf_processed[\"organic2_encoded\"] = df_processed.groupby(\"organic_linker2\")[\"CO2_working_capacity [mL\/g]\"].transform(\"median\")\ndf_processed[\"topology_encoded\"] = df_processed.groupby(\"topology\")[\"CO2_working_capacity [mL\/g]\"].transform(\"median\")\ndf_processed[\"_space_group_crystal_system_encoded\"] = df_processed.groupby(\"_space_group_crystal_system\")[\"CO2_working_capacity [mL\/g]\"].transform(\"median\")\n#df_processed[\"functional_groups_encoded\"] = df_processed.groupby(\"functional_groups\")[\"CO2_working_capacity [mL\/g]\"].transform(\"median\")","59ff7256":"di = df_processed[[\"metal_linker\",\"metal_encoded\"]].drop_duplicates().set_index('metal_linker').to_dict()['metal_encoded']\ndf_processed= df_processed.replace({\"metal_linker\":di})\n#df_processed_pretest= df_processed_pretest.replace({\"metal_linker\":di})\ndf_processed_test= df_processed_test.replace({\"metal_linker\":di})\n\ndi = df_processed[[\"organic_linker1\",\"organic1_encoded\"]].drop_duplicates().set_index('organic_linker1').to_dict()['organic1_encoded']\ndf_processed= df_processed.replace({\"organic_linker1\":di})\n#df_processed_pretest= df_processed_pretest.replace({\"organic_linker1\":di})\ndf_processed_test= df_processed_test.replace({\"organic_linker1\":di})\n\ndi = df_processed[[\"organic_linker2\",\"organic2_encoded\"]].drop_duplicates().set_index('organic_linker2').to_dict()['organic2_encoded']\ndf_processed= df_processed.replace({\"organic_linker2\":di})\n#df_processed_pretest= df_processed_pretest.replace({\"organic_linker2\":di})\ndf_processed_test= df_processed_test.replace({\"organic_linker2\":di})\n\ndi = df_processed[[\"topology\",\"topology_encoded\"]].drop_duplicates().set_index('topology').to_dict()['topology_encoded']\ndf_processed= df_processed.replace({\"topology\":di})\n#df_processed_pretest= df_processed_pretest.replace({\"topology\":di})\ndf_processed_test= df_processed_test.replace({\"topology\":di})\n\ndi = df_processed[[\"_space_group_crystal_system\",\"_space_group_crystal_system_encoded\"]].drop_duplicates().set_index('_space_group_crystal_system').to_dict()['_space_group_crystal_system_encoded']\ndf_processed= df_processed.replace({\"_space_group_crystal_system\":di})\n#df_processed_pretest = df_processed_pretest.replace({\"_space_group_crystal_system\":di})\ndf_processed_test = df_processed_test.replace({\"_space_group_crystal_system\":di})\n\n#di = df_processed[[\"functional_groups\",\"functional_groups_encoded\"]].drop_duplicates().set_index('functional_groups').to_dict()['functional_groups_encoded']\n#df_processed= df_processed.replace({\"functional_groups\":di})\n#df_processed_pretest = df_processed_pretest.replace({\"functional_groups\":di})\n#df_processed_test = df_processed_test.replace({\"functional_groups\":di})\n\ndf_processed = df_processed.drop(['metal_encoded','organic1_encoded','organic2_encoded',\n                                  'topology_encoded',\n                                  '_space_group_crystal_system_encoded',\n                                  #'functional_groups_encoded'\n                                 ],\n                                axis = 1)","d2c4c334":"from sklearn.impute import KNNImputer\nimputer = KNNImputer(n_neighbors=5)\n#from sklearn.impute import SimpleImputer\n#imputer = SimpleImputer(missing_values=np.nan, strategy='mean')\n\ndf_filled = imputer.fit_transform(df_processed.drop(['CO2_working_capacity [mL\/g]'], axis = 1))\ndf_filled = pd.DataFrame(df_filled, columns = df_processed.drop('CO2_working_capacity [mL\/g]', axis = 1).columns)\ndf_filled = pd.concat([df_filled, df_processed['CO2_working_capacity [mL\/g]']], axis = 1)\ndf_filled.info()\n'''\ndf_filled_pretest = imputer.transform(df_processed_pretest.drop(['Unnamed: 0'], axis = 1))\ndf_filled_pretest = pd.DataFrame(df_filled_pretest, columns = df_processed_pretest.columns)\ndf_filled_pretest.info()\n'''\ndf_filled_test = imputer.transform(df_processed_test)\ndf_filled_test = pd.DataFrame(df_filled_test, columns = df_processed_test.columns)\ndf_filled_test.info()","e9b98730":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy import stats\nfrom scipy.stats import norm, skew\nfrom sklearn import preprocessing\nfrom sklearn.metrics import r2_score\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import ElasticNetCV, ElasticNet\nfrom xgboost import XGBRegressor, plot_importance\nfrom sklearn.model_selection import RandomizedSearchCV\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.preprocessing import MinMaxScaler, LabelEncoder\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.linear_model import ElasticNet, Lasso,  BayesianRidge, LassoLarsIC\nfrom sklearn.ensemble import RandomForestRegressor,  GradientBoostingRegressor\nfrom sklearn.kernel_ridge import KernelRidge\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import RobustScaler\nfrom sklearn.base import BaseEstimator, TransformerMixin, RegressorMixin, clone\nfrom sklearn.model_selection import KFold, cross_val_score, train_test_split\nfrom sklearn.metrics import mean_squared_error\nimport xgboost as xgb\nimport lightgbm as lgb\nfrom lightgbm import LGBMRegressor\nfrom sklearn.experimental import enable_hist_gradient_boosting\nfrom sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor, AdaBoostRegressor, BaggingRegressor, HistGradientBoostingRegressor, StackingRegressor, VotingRegressor\nfrom sklearn.kernel_ridge import KernelRidge\nfrom sklearn.linear_model import Ridge, RidgeCV\nfrom sklearn.linear_model import ElasticNet, ElasticNetCV\nfrom sklearn.svm import SVR\nfrom mlxtend.regressor import StackingCVRegressor\nfrom xgboost import XGBRegressor\nimport datetime\nfrom dateutil.relativedelta import *\nimport pandas as pd\nimport numpy as np\n\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom catboost import CatBoostClassifier, CatBoostRegressor\nfrom xgboost import XGBClassifier, XGBRegressor\nfrom lightgbm import LGBMRegressor, LGBMClassifier\n\nfrom sklearn.linear_model import LogisticRegressionCV, LogisticRegression, LinearRegression, LassoLarsCV, BayesianRidge, SGDClassifier, SGDRegressor\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor, AdaBoostClassifier, AdaBoostRegressor, ExtraTreesClassifier, ExtraTreesRegressor, GradientBoostingRegressor, GradientBoostingClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.neighbors import KNeighborsClassifier, KNeighborsRegressor\nfrom sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor\nfrom sklearn.neural_network import MLPClassifier, MLPRegressor\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error, accuracy_score\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.model_selection import learning_curve\nfrom sklearn.model_selection import ShuffleSplit","91b7cc32":"X_train_final = df_filled.drop('CO2_working_capacity [mL\/g]', axis = 1)\n#X_train_final = X_masked\ny_train_final = df_filled['CO2_working_capacity [mL\/g]']\nX_submission = df_filled_test\n#X_submission = df_filled_test.iloc[:,mask]\nscaler = MinMaxScaler().fit(X_train_final)\nscaler.transform(X_train_final)\nscaler.transform(X_submission)\n#Rename columns\nX_train_final.columns = range(len(X_train_final.columns))\nX_submission.columns = range(len(X_submission.columns))","8ade552a":"estimators = [\n(\n                'cat', CatBoostRegressor(\n                    iterations=3000,\n                    grow_policy='Lossguide',\n                    verbose=False,\n                    task_type='GPU',\n                    l2_leaf_reg=200.5,\n                    learning_rate=0.1\n                    # depth=14\n                    # l2_leaf_reg=0.001\n                )\n            ),\n            (\n                'xgb_1', XGBRegressor(\n                    grow_policy='lossguide',\n                    tree_method='gpu_hist',\n                    n_estimators=3000,\n                    eta=0.1,\n                    max_depth=14,\n                    reg_lambda=200.5\n                )\n            ),\n            (\n                'light', LGBMRegressor(\n                    num_iterations=3000,\n                    device=\"gpu\",\n                    learning_rate=0.1,\n                    reg_lambda=200.5\n                )\n            )\n]\n\n\nmodel = VotingRegressor(estimators=estimators, verbose = True)\nmodel.fit(X_train_final, y_train_final)\ny_pred = model.predict(X_submission)","7782284f":"y_pred = model.predict(X_submission)","4ad63e9e":"pd.DataFrame(y_pred).median()","037bde23":"pd.DataFrame(np.abs(y_pred)).mean()","7d8c027c":"index = pd.Series([str(i) for i in (np.arange(68614,85614))])\nsubmission = pd.DataFrame([index, y_pred]).T\nsubmission.columns = ['id','CO2_working_capacity [mL\/g]']\nsubmission = submission.set_index('id')\nsubmission.to_csv('submission2.csv')\nsubmission","ecd16f96":"# Set up pipeline","2b35a8ba":"# Transformer","e72df1df":"# SRA","d8fc5daf":"# Add stat","a99ad723":"# Import modules","76e8bb03":"# Load essentials","791a2ef4":"# Pseudo","30eb8c10":"# Run pipeline","6a3bd993":"# Add imputor"}}