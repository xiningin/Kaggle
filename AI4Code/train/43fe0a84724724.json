{"cell_type":{"4b9fc780":"code","038e6e6b":"code","248ac907":"code","f7e5d898":"code","51c13aa8":"code","0778e629":"code","486f3ea7":"code","1d278053":"code","8870b8bb":"code","735d08bf":"code","75e3567e":"code","7a04a67f":"code","7ae1e281":"code","8911e7be":"code","e711989a":"code","172ca631":"code","4ad25900":"code","c9398daa":"code","61f64b30":"markdown"},"source":{"4b9fc780":"import numpy as np \nimport pandas as pd \n\nimport os\n\nfrom IPython.core.display import display\nfrom sklearn.datasets import fetch_20newsgroups","038e6e6b":"competition_path = '20-newsgroups-ciphertext-challenge'","248ac907":"test = pd.read_csv('..\/input\/' + competition_path + '\/test.csv').rename(columns={'ciphertext' : 'text'})","f7e5d898":"train_p = fetch_20newsgroups(subset='train')\ntest_p = fetch_20newsgroups(subset='test')","51c13aa8":"df_p = pd.concat([pd.DataFrame(data = np.c_[train_p['data'], train_p['target']],\n                                   columns= ['text','target']),\n                      pd.DataFrame(data = np.c_[test_p['data'], test_p['target']],\n                                   columns= ['text','target'])],\n                     axis=0).reset_index(drop=True)","0778e629":"df_p['target'] = df_p['target'].astype(np.int8)","486f3ea7":"def find_targets(p_indexes_set):\n    return np.sort(df_p.loc[p_indexes_set]['target'].unique())","1d278053":"pickle_1_path = '..\/input\/test-1\/'\n\ndf_p_indexes_1 = pd.read_pickle(pickle_1_path + 'df_p_indexes-1.pkl')\ndf_p_indexes_1['target'] = df_p_indexes_1['p_indexes'].map(find_targets)\ndisplay(df_p_indexes_1[df_p_indexes_1['target'].map(len) > 1 ])","8870b8bb":"test = test.join(df_p_indexes_1[['target']])","735d08bf":"pickle_2_path = '..\/input\/test-2\/'\n\ndf_p_indexes_2 = pd.read_pickle(pickle_2_path + 'df_p_indexes-2.pkl')\ndf_p_indexes_2['target'] = df_p_indexes_2['p_indexes'].map(find_targets)\ndisplay(df_p_indexes_2[df_p_indexes_2['target'].map(len) > 1 ])","75e3567e":"test.loc[df_p_indexes_2.index,'target'] = df_p_indexes_2['target']","7a04a67f":"pickle_3_path = '..\/input\/cipher-3-solution\/'\n\ndf_p_indexes_3 = pd.read_pickle(pickle_3_path + 'test_3.pkl')\ndf_p_indexes_3['target'] = df_p_indexes_3['p_indexes'].map(find_targets)\ndisplay(df_p_indexes_3[df_p_indexes_3['target'].map(len) > 1 ])","7ae1e281":"test.loc[df_p_indexes_3.index,'target'] = df_p_indexes_3['target']","8911e7be":"test.head()","e711989a":"test[test['target'].isnull()]['difficulty'].unique()","172ca631":"test.to_pickle('test_123.pkl')","4ad25900":"test.loc[test['difficulty'] < 4,'target'] = test.loc[test['difficulty'] < 4,'target'].map(lambda x: x[0])\n#You can implement the target choice you want within the possible targets here","c9398daa":"test.to_pickle('test_sub.pkl')","61f64b30":"This kernel provides targets for the competition test set using exact matchings with plain-text chunks, for cipher #1, #2 & #3.\n\nIt outputs two dataframes as pickles:\n* test_123.pkl which contains as target for cipher #1, #2 & #3 the list of all possible targets from decrypted ciphertext exact matchin (see https:\/\/www.kaggle.com\/leflal\/you-cannot-avoid-multiple-targets)\n* test_sub.pkl which contains one target for cipher #1, #2 & #3 (chosen among the above list of possible targets), ready for submission\n\nIf you use the output pickle in your work, be it to cross-check your model or enhance your submission,  or if you simply appreciate this contribution, ** please upvote this kernel, thanks and have a nice 2019**."}}