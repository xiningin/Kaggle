{"cell_type":{"dc6fa3c7":"code","ea0a13de":"code","b4fd5df2":"code","39027952":"code","18c8ddfa":"markdown","780f7c4b":"markdown","bab828dd":"markdown","809b8e24":"markdown","b4b02ab0":"markdown","a960047e":"markdown","4d4a9e34":"markdown","6a7c9174":"markdown","15df16cc":"markdown","a323a330":"markdown","1b4c1b53":"markdown","aec8c2b9":"markdown"},"source":{"dc6fa3c7":"'''\nRun this code in the AutoDesk Maya Python Script Editor!\nStart with a new empty scene. The script will setup the cameras and softbox lighting for you.\nCopyright Joost Hazelzet, script is provided under MIT License.\n'''\n\nimport maya.cmds as cmds\nfrom mtoa.cmds.arnoldRender import arnoldRender\nimport mtoa.ui.arnoldmenu as arnoldmenu; \nimport mtoa.utils as mutils\nfrom os import listdir\nfrom os.path import isfile, join\nimport random\n\n#Setup the cameras\ncmds.camera(centerOfInterest=5, focalLength=170, lensSqueezeRatio=1, cameraScale=1, horizontalFilmAperture=1.41732, \n        horizontalFilmOffset=0, verticalFilmAperture=0.94488, verticalFilmOffset=0, filmFit='fill', overscan=1, \n        motionBlur=0, shutterAngle=144, nearClipPlane=0.1, farClipPlane=10000, orthographic=0, orthographicWidth=30,\n        panZoomEnabled=0, horizontalPan=0, verticalPan=0, zoom=1)\nnameCameraRight = cmds.ls(selection=True)[0]\ncmds.move( 19., 0., 19., r=False )\ncmds.rotate( 0., 45., 0., r=False )\n\ncmds.camera(centerOfInterest=5, focalLength=170, lensSqueezeRatio=1, cameraScale=1, horizontalFilmAperture=1.41732, \n        horizontalFilmOffset=0, verticalFilmAperture=0.94488, verticalFilmOffset=0, filmFit='fill', overscan=1, \n        motionBlur=0, shutterAngle=144, nearClipPlane=0.1, farClipPlane=10000, orthographic=0, orthographicWidth=30,\n        panZoomEnabled=0, horizontalPan=0, verticalPan=0, zoom=1)\nnameCameraLeft = cmds.ls(selection=True)[0]\ncmds.move( -19., 0., 19., r=False )\ncmds.rotate( 0., -45., 0., r=False )\n\nprint(nameCameraRight, nameCameraLeft)\n\n\n#Setup the lighting\ncmds.polyPlane(width=1, height=1, subdivisionsX=10, subdivisionsY=10, axis=[0,1,0], createUVs=2,constructionHistory=True)\nmutils.createMeshLight()\nnameLight = cmds.ls(selection=True)[0]\ncmds.setAttr(nameLight+\"Shape.intensity\", 10)\ncmds.setAttr(nameLight+\"Shape.aiExposure\", 5)\ncmds.setAttr(nameLight+\".scaleX\", 20)\ncmds.setAttr(nameLight+\".scaleZ\", 20)\ncmds.setAttr(nameLight+\".rotateX\", -90)\ncmds.setAttr(nameLight+\".translateZ\", 3)\n\nprint(nameLight)\n","ea0a13de":"'''\nRun this code in the AutoDesk Maya Python Script Editor!\nBe sure to run the scene setup first including the necessary import statements.\nCopyright Joost Hazelzet, script is provided under MIT License.\n'''\n\n#Prepare the renderer\ncmds.setAttr(\"defaultArnoldDriver.ai_translator\", \"png\", type=\"string\")\nrandom.seed(1)\n\ndef RenderLegoBrick(pathBricks, frames, cameraRight, cameraLeft, test):\n    if test:\n        brickFiles = ['3001 brick 2x4.dae']\n    else:\n        brickFiles = [f for f in listdir(pathBricks) if isfile(join(pathBricks, f))]\n\n    print('{0} brick models found.'.format(len(brickFiles)))\n    processed=0\n    images=0\n    \n    for brickFile in brickFiles:\n        \n        print('Process Collada file: '+brickFile)\n        brickName = brickFile.split('.')[0]\n       \n        #Remove all former brick parts if any\n        if cmds.ls('Part_*') != []:\n            cmds.select('Part_*')\n            cmds.delete()\n        \n        #Import the Collada file. This generates a Part_.. node in the scene\n        daeFile = pathBricks+brickFile\n        cmds.file(daeFile, type=\"DAE_FBX\", i=True, ra=True, ignoreVersion=True, options=\"v=0;\", \n                importTimeRange=\"combine\", pr=True, mergeNamespacesOnClash=True )\n  \n        #Set the reflectivity, color and center the Part node\n        cmds.select('Part_*', r=True)\n        part = cmds.ls(sl=True,long=False)[0] \n        phong = cmds.defaultNavigation(defaultTraversal=True, destination=part+'*.surfaceShader')[0]\n        if test:\n            print('Internal Maya part: '+part)\n            print('Phong of part: '+phong)\n        cmds.setAttr(phong+'.reflectivity', 0.24)\n        cmds.setAttr(phong+'.color', 0.5, 0.5, 0.5, type='float3')\n        cmds.xform(centerPivots=True)\n        cmds.move( 0., 0., 0., rpr=True ) #Move pivot to center of brick\n\n        #Rotate the Part node randomly along the x, y and z axis, render via the 2 cameras and saves the result\n        for i in range(frames):\n            rotx = random.random()*360\n            roty = random.random()*360\n            rotz = random.random()*360\n            cmds.rotate( rotx, roty, rotz, r=False )\n            fileName = \"{0} {1:03d}\".format(brickName, i)\n            if test:\n                print(i, rotx, roty, rotz)\n            else:\n                cmds.setAttr(\"defaultArnoldDriver.pre\", fileName+\"R\", type=\"string\")\n                arnoldRender(400, 400, False, False, cameraRight, ' -layer defaultRenderLayer')\n                cmds.setAttr(\"defaultArnoldDriver.pre\", fileName+\"L\", type=\"string\")\n                arnoldRender(400, 400, False, False, cameraLeft, ' -layer defaultRenderLayer')\n        processed += 1\n        images += frames*2\n        \n    print('{0} brick models processed.'.format(processed))\n    print('{0} images generated.'.format(images))\n\n\n# Use this command to start the rendering process. \n# The import statements, nameCameraRight and nameCameraLeft are defined in the previous scene setup script.\nRenderLegoBrick('C:\/Users\/joost\/Documents\/LEGO Creations\/Original Bricks\/', 400, nameCameraRight, nameCameraLeft, False)\n","b4fd5df2":"#Remove _1 from file\nimport os, sys\nfrom ipywidgets import IntProgress\nfrom IPython.display import display\n\npathRename = 'C:\/Users\/joost\/Documents\/maya\/projects\/lego_bricks\/images\/tmp\/'\n\nfiles = [f for f in os.listdir(pathRename) if os.path.isfile(os.path.join(pathRename, f))]\npbar = IntProgress(min=0, max=len(files)) # instantiate the bar\ndisplay(pbar) # display the bar\n\nfor f in files:\n    lstr = len(f)\n    start = f[:lstr-6]\n    purge = f[lstr-6:lstr-4]\n    end = f[lstr-4:lstr]\n    newName = f'{start}{end}'\n    if purge == '_1':\n        os.rename(f'{pathRename}{f}', f'{pathRename}{newName}')  \n    pbar.value +=1","39027952":"import os, sys\n\n# Path where all 50 Collada files are stored\npath = 'C:\/Users\/joost\/Documents\/LEGO Creations\/Original Bricks\/processed'\n\ntxt= open('C:\/Users\/joost\/Documents\/LEGO Creations\/Original Bricks\/validation.txt','w')\nfiles = [f for f in os.listdir(path) if os.path.isfile(os.path.join(path, f))]\nfor f in files:\n    brickName = f.split('.')[0]\n    for i in range(80):\n        fileName = \"{0} {1:03d}\".format(brickName, i)\n        txt.write(fileName+\"R.png\\n\")\n        txt.write(fileName+\"L.png\\n\")\ntxt.close()","18c8ddfa":"# How to create a LEGO bricks dataset using Maya","780f7c4b":"This issue especially happens if a brick image is taken from the top with one camera. However, using a second offset camera, it becomes clear that this is a brick:\n<div>\n<img src=\"https:\/\/raw.githubusercontent.com\/JoostHazelzet\/rawimages\/master\/3001R.png\" align=\"left\" width=\"200\"\/>\n<\/div>","bab828dd":"## Introduction\nIn the summer of 2018 I decided to create a dataset containing computer rendered LEGO bricks. I used a small set of digital bricks and next made images of the brick while it was rotated in the x, y and z axis. At that time I used Blender as the rendering software. Based on the feedback I got from Kaggler users, thanks for this, I decided to create a version 2 dataset. This time I am going to use Maya software from Autodesk (I used the Maya 2020 trial version) which is in my opinion easier to use. In this notebook I explain step by step how I created the dataset.","809b8e24":"I decided to use two cameras. The reason is to solve an issue that occurs with one camera: it is not possible to determine the brick type correctly. See the following example where it is difficult to predict if this is a brick of a plate:\n<div>\n<img src=\"https:\/\/raw.githubusercontent.com\/JoostHazelzet\/rawimages\/master\/3001L.png\" align=\"left\" width=\"200\"\/>\n<\/div>\n","b4b02ab0":"## Creating the set of digital Lego bricks\nI decided to use [Mecabricks](https:\/\/www.mecabricks.com\/) to selected and generate digital models of the LEGO bricks. Each brick is exported as Collada (.dae) file because this is file format recognized by Autodesk Maya. I decided to take middle gray tone as color (so centered approximately around half RGB range 0..255) because if color is required then this can be applied later on the finished rendered image.\n\nA list is provided of all Collada files in the [Kaggle Lego Bricks dataset](https:\/\/www.kaggle.com\/joosthazelzet\/lego-brick-images\/).","a960047e":"The folowing Python script set processes the digital bricks found from the indicated path. Each brick is 400 times rotated randomly in the x, y and z axis. This results in 400 unique frames and, because of the 2 cameras setup, a total of 800 images are rendered. Each frame is saved as png image and has a left (L) and right (R) indicator in the file.","4d4a9e34":"Finally, we need to take care of the lighting. I decided to use a softbox setup using a square light. A softbox diffuses the light into a pleasing soft, even light. The softbox is depicted as the raster:\n<div>\n<img src=\"https:\/\/raw.githubusercontent.com\/JoostHazelzet\/rawimages\/master\/perspective-view.png\" align=\"left\" width=\"600\"\/>\n<\/div>","6a7c9174":"## Setting up the scene in Maya using 2 cameras\nThe approach is to load a digital brick to a pivot point. The brick is rotated stepwise around the x, y and z axis while rendering and save an image at each step. \n\n<div>\n<img src=\"https:\/\/raw.githubusercontent.com\/JoostHazelzet\/rawimages\/master\/scene.png\" align=\"left\" width=\"400\"\/>\n<\/div>","15df16cc":"## Post processing\nProbably it is me but I had 2 issues with the rendering process I couldn't resolve in Maya itself:\n1. The background turns black while I was expecting it to be transparent.\n2. The files are saved with a \\_1.png while I was expecting without \\_1.   \nI except the first issue as given, the second issue is crrected using this small script.","a323a330":"![](https:\/\/raw.githubusercontent.com\/JoostHazelzet\/rawimages\/master\/HighRes_LEGO_bricksloose.jpg)\n*Copyright The LEGO Group*","1b4c1b53":"## Conclusion\nI used 50 digital Collada models of LEGO bricks and rendered each brick 800 times (400 Left camera images and 400 Left camera images). This resulted in a total of 40.000 images in the dataset.\nBecause all images are randomly generated, you have quite some freedom in chosing the validation set. The following script creates a csv file with the 80 frames (=20% of 400 frames) selected of each brick.","aec8c2b9":"The scene setup in Maya is created using a Python script in order to be able to regenerate it."}}