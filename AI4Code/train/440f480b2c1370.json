{"cell_type":{"4a545233":"code","754a7f85":"code","83e197b0":"code","9e6fcc04":"code","40d9a298":"code","79cd16fd":"code","ec1c09af":"code","3d6f74f3":"code","ba9b8382":"code","5b5cf627":"code","867c9446":"code","196e75fa":"markdown","6ea07176":"markdown","81d90565":"markdown","ab4d0f97":"markdown","31c73647":"markdown","e3d87180":"markdown","33a7d49c":"markdown"},"source":{"4a545233":"import os\nimport cv2\nimport numpy as np\nfrom sklearn.utils import shuffle\nfrom random import randint\n\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nfrom keras.preprocessing.image import ImageDataGenerator,img_to_array,load_img\nfrom PIL import Image\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom keras.callbacks import ReduceLROnPlateau\nfrom keras.applications.inception_v3 import InceptionV3\n\nprint(\"Setup Complete!\")","754a7f85":"def get_images(directory):\n    Images = []\n    Labels = []  # 0 for Building , 1 for forest, 2 for glacier, 3 for mountain, 4 for Sea , 5 for Street\n    label = 0\n    \n    for labels in os.listdir(directory): #Main Directory where each class label is present as folder name.\n        if labels == 'glacier': #Folder contain Glacier Images get the '2' class label.\n            label = 2\n        elif labels == 'sea':\n            label = 4\n        elif labels == 'buildings':\n            label = 0\n        elif labels == 'forest':\n            label = 1\n        elif labels == 'street':\n            label = 5\n        elif labels == 'mountain':\n            label = 3\n        \n        for image_file in os.listdir(directory+labels): #Extracting the file name of the image from Class Label folder\n            image = cv2.imread(directory+labels+r'\/'+image_file) #Reading the image (OpenCV)\n            image = cv2.resize(image,(150,150)) #Resize the image, Some images are different sizes. (Resizing is very Important)\n            Images.append(image)\n            Labels.append(label)\n        \n#     return Images, Labels\n    return shuffle(Images,Labels,random_state=817328462) #Shuffle the dataset you just prepared.\n\ndef get_classlabel(class_code):\n    labels = {2:'glacier', 4:'sea', 0:'buildings', 1:'forest', 5:'street', 3:'mountain'}\n    \n    return labels[class_code]","83e197b0":"Images, Labels = get_images('..\/input\/intel-image-classification\/seg_train\/seg_train\/') #Extract the training images from the folders.\n\nImages = np.array(Images, dtype=np.float32) #converting the list of images to numpy array.\nImages = Images\/255.0\nLabels = np.array(Labels)","9e6fcc04":"f,ax = plt.subplots(5,5) \nf.subplots_adjust(0,0,3,3)\nfor i in range(0,5,1):\n    for j in range(0,5,1):\n        rnd_number = randint(0,len(Images))\n        ax[i,j].imshow(Images[rnd_number])\n        ax[i,j].set_title(get_classlabel(Labels[rnd_number]))\n        ax[i,j].axis('off')","40d9a298":"\ntrain_DIR = \"\/kaggle\/input\/intel-image-classification\/seg_train\/seg_train\/\"\n\ntrain_datagen = ImageDataGenerator( rescale = 1.0\/255,\n                                          width_shift_range=0.2,\n                                          height_shift_range=0.2,\n                                          zoom_range=0.2,\n                                          vertical_flip=True,\n                                          fill_mode='nearest')\n\n\ntrain_generator = train_datagen.flow_from_directory(train_DIR,\n                                                    batch_size=32,\n                                                    class_mode='categorical',\n                                                    target_size=(150, 150))\n\ntest_DIR = \"\/kaggle\/input\/intel-image-classification\/seg_test\/seg_test\/\"\n\nvalidation_datagen = ImageDataGenerator(rescale = 1.0\/255)\n\n\nvalidation_generator = validation_datagen.flow_from_directory(test_DIR,\n                                                    batch_size=128,\n                                                    class_mode='categorical',\n                                                    target_size=(150, 150))","79cd16fd":"inceptionV3 = InceptionV3(include_top= False, input_shape=(150,150,3))\n\nfor layer in inceptionV3.layers:\n\tlayer.trainable = False","ec1c09af":"last_layer = inceptionV3.get_layer('mixed9')\n\nprint('last layer output shape: ', last_layer.output_shape)\n\nlast_output = last_layer.output","3d6f74f3":"\nx = tf.keras.layers.Flatten()(last_output)\nx = tf.keras.layers.Dense(units = 1024, activation = tf.nn.relu)(x)\nx = tf.keras.layers.Dropout(0.2)(x)\nx = tf.keras.layers.Dense  (6, activation = tf.nn.softmax)(x)\n\nmodel = tf.keras.Model( inceptionV3.input, x)\n\nlearning_rate_reduction = ReduceLROnPlateau(monitor='val_acc',\n                                            patience=1,\n                                            verbose=1,\n                                            factor=0.25,\n                                            min_lr=0.000003)\n\nmodel.compile(loss = 'categorical_crossentropy', optimizer= tf.keras.optimizers.Adam(), metrics=['acc'])\n\nmodel.summary()","ba9b8382":"history = model.fit(train_generator,\n                    epochs = 10,\n                    verbose = 1,\n                   validation_data = validation_generator,\n                   callbacks=[learning_rate_reduction])","5b5cf627":"%matplotlib inline\nacc = history.history['acc']\nval_acc = history.history['val_acc']\nloss = history.history['loss']\nval_loss = history.history['val_loss']\n\nepochs = range(len(acc))\n\nplt.plot(epochs, acc, 'r', label='Training accuracy')\nplt.plot(epochs, val_acc, 'b', label='Validation accuracy')\nplt.title('Training and validation accuracy')\nplt.legend()\nplt.figure()\n\nplt.plot(epochs, loss, 'r', label='Training Loss')\nplt.plot(epochs, val_loss, 'b', label='Validation Loss')\nplt.title('Training and validation loss')\nplt.legend()\n\nplt.show()","867c9446":"import numpy as np\nfrom keras.preprocessing import image\n\nfile_path =  '..\/input\/intel-image-classification\/seg_pred\/seg_pred\/10073.jpg'\n\ntest_image = image.load_img(file_path, target_size = (150, 150))\nplt.imshow(test_image)\ntest_image = image.img_to_array(test_image)\ntest_image = np.expand_dims(test_image, axis = 0)\nresult = model.predict(test_image)\n\nclasses=train_generator.class_indices\n\nclasses=['buildings','forest','glacier','mountain','sea','street']\n\nprint(\"Prediction for this image is :\",classes[np.argmax(result)])","196e75fa":"The dataset can be dowloaded from here : https:\/\/www.kaggle.com\/puneet6060\/intel-image-classification","6ea07176":"### Display random images from the dataset","81d90565":"## The objective of this kernel is to implement CNN with Keras in order to classify natural images.\n\n","ab4d0f97":"### Load all the required libraries","31c73647":"The input is image data of Natural Scenes around the world.\n\nThis Data contains around 25k images of size 150x150 distributed under 6 categories.\n\n'buildings' -> 0,\n\n'forest' -> 1,\n\n'glacier' -> 2,\n\n'mountain' -> 3,\n\n'sea' -> 4,\n\n'street' -> 5 \n\n","e3d87180":"# Image Scene Classification of Multiclass labels","33a7d49c":"### Predictions "}}