{"cell_type":{"1f7ba57c":"code","1b96502e":"code","f062d0cf":"code","15c5c478":"code","81534e53":"code","1b31d33a":"code","9358fc20":"code","44b1dfd8":"code","4bb5ad19":"code","419e6b3c":"code","56d0cf1d":"code","8e21b1ae":"code","348779d4":"code","6e823fb6":"code","b32d5844":"code","790736f6":"code","b14ae92d":"code","fc84fc41":"code","f0968239":"code","6565503a":"code","254a11c9":"code","22afa218":"code","157132fd":"code","09fbab95":"code","71d5a4e5":"code","45a82bc7":"code","15ece7d8":"code","c5491034":"code","38478743":"code","2dc62c4c":"code","10aa4c90":"code","faeb6174":"code","e3fcdd3e":"code","7dea2f68":"code","ee2a0204":"markdown","b7cf8306":"markdown","dc0f81bc":"markdown","99ee8e2f":"markdown","f785a2c8":"markdown","09da6532":"markdown","b81fe953":"markdown","859112e5":"markdown","d822930b":"markdown","caeef402":"markdown","f967969d":"markdown","f51c9012":"markdown","80ae7479":"markdown","a5b9f551":"markdown","16f81638":"markdown","544f2542":"markdown","3e690019":"markdown","b671ceb6":"markdown","017141b8":"markdown","f020d257":"markdown","adad8fed":"markdown"},"source":{"1f7ba57c":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport tqdm\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","1b96502e":"train = pd.read_csv('..\/input\/train.csv', index_col='plaintext_id')\ntest = pd.read_csv('..\/input\/test.csv', index_col='ciphertext_id')\nsub = pd.read_csv('..\/input\/sample_submission.csv', index_col='ciphertext_id')","f062d0cf":"train['length'] = train.text.apply(len)\ntest['length'] = test.ciphertext.apply(len)","15c5c478":"train[train['length']<=100]['length'].hist(bins=99)","81534e53":"train.head()","1b31d33a":"test.head(10)","9358fc20":"KEYLEN = 4 # len('pyle')\ndef decrypt_level_1(ctext):\n    key = [ord(c) - ord('a') for c in 'pyle']\n    key_index = 0\n    plain = ''\n    for c in ctext:\n        cpos = 'abcdefghijklmnopqrstuvwxy'.find(c)\n        if cpos != -1:\n            p = (cpos - key[key_index]) % 25\n            pc = 'abcdefghijklmnopqrstuvwxy'[p]\n            key_index = (key_index + 1) % KEYLEN\n        else:\n            cpos = 'ABCDEFGHIJKLMNOPQRSTUVWXY'.find(c)\n            if cpos != -1:\n                p = (cpos - key[key_index]) % 25\n                pc = 'ABCDEFGHIJKLMNOPQRSTUVWXY'[p]\n                key_index = (key_index + 1) % KEYLEN\n            else:\n                pc = c\n        plain += pc\n    return plain\n\ndef encrypt_level_1(ptext, key_index=0):\n    key = [ord(c) - ord('a') for c in 'pyle']\n    ctext = ''\n    for c in ptext:\n        pos = 'abcdefghijklmnopqrstuvwxy'.find(c)\n        if pos != -1:\n            p = (pos + key[key_index]) % 25\n            cc = 'abcdefghijklmnopqrstuvwxy'[p]\n            key_index = (key_index + 1) % KEYLEN\n        else:\n            pos = 'ABCDEFGHIJKLMNOPQRSTUVWXY'.find(c)\n            if pos != -1:\n                p = (pos + key[key_index]) % 25\n                cc = 'ABCDEFGHIJKLMNOPQRSTUVWXY'[p]\n                key_index = (key_index + 1) % KEYLEN\n            else:\n                cc = c\n        ctext += cc\n    return ctext\n\ndef test_decrypt_level_1():\n    c_id = 'ID_4a6fc1ea9'\n    ciphertext = test.loc[c_id]['ciphertext']\n    print('Ciphertxt:', ciphertext)\n    decrypted = decrypt_level_1(ciphertext)\n    print('Decrypted:', decrypted)\n    encrypted = encrypt_level_1(decrypted)\n    print('Encrypted:', encrypted)\n    print(\"Encrypted == Ciphertext:\", encrypted == ciphertext)\n\ntest_decrypt_level_1()    ","44b1dfd8":"plain_dict = {}\nfor p_id, row in train.iterrows():\n    text = row['text']\n    plain_dict[text] = p_id\nprint(len(plain_dict))","4bb5ad19":"matched, unmatched = 0, 0\nfor c_id, row in tqdm.tqdm(test[test['difficulty']==1].iterrows()):\n    decrypted = decrypt_level_1(row['ciphertext'])\n    found = False\n    for pad in range(100):\n        start = pad \/\/ 2\n        end = len(decrypted) - (pad + 1) \/\/ 2\n        plain_pie = decrypted[start:end]\n        if plain_pie in plain_dict:\n            p_id = plain_dict[plain_pie]\n            row = train.loc[p_id]\n            sub.loc[c_id] = train.loc[p_id]['index']\n            matched += 1\n            found = True\n            break\n    if not found:\n        unmatched += 1\n        print(decrypted)\n            \nprint(f\"Matched {matched}   Unmatched {unmatched}\")","419e6b3c":"import math\nfrom itertools import cycle\n\ndef rail_pattern(n):\n    r = list(range(n))\n    return cycle(r + r[-2:0:-1])\n\ndef encrypt_level_2(plaintext, rails=21):\n    p = rail_pattern(rails)\n    # this relies on key being called in order, guaranteed?\n    return ''.join(sorted(plaintext, key=lambda i: next(p)))\ndef decrypt_level_2(ciphertext, rails=21):\n    p = rail_pattern(rails)\n    indexes = sorted(range(len(ciphertext)), key=lambda i: next(p))\n    result = [''] * len(ciphertext)\n    for i, c in zip(indexes, ciphertext):\n        result[i] = c\n    return ''.join(result)","56d0cf1d":"matched, unmatched = 0, 0\nfor c_id, row in tqdm.tqdm(test[test['difficulty']==2].iterrows()):\n    decrypted = decrypt_level_1(decrypt_level_2(row['ciphertext']))\n    found = False\n    for pad in range(100):\n        start = pad \/\/ 2\n        end = len(decrypted) - (pad + 1) \/\/ 2\n        plain_pie = decrypted[start:end]\n        if plain_pie in plain_dict:\n            p_id = plain_dict[plain_pie]\n            row = train.loc[p_id]\n            sub.loc[c_id] = train.loc[p_id]['index']\n            matched += 1\n            found = True\n            break\n    if not found:\n        unmatched += 1\n        print(decrypted)\n            \nprint(f\"Matched {matched}   Unmatched {unmatched}\")\nsub.to_csv('submit-level-2.csv')","8e21b1ae":"level12_train_index = list(sub[sub[\"index\"] > 0][\"index\"])\nprint(len(level12_train_index))\ntrain34 = train[~train[\"index\"].isin(level12_train_index)].copy()\ntest3 = test[test['difficulty']==3].copy()\ntest4 = test[test['difficulty']==4].copy()\nprint(train34.shape, test3.shape[0] + test4.shape[0])","348779d4":"test3.sort_values(\"length\", ascending=False).head(5)","6e823fb6":"test3[\"nb\"] = test3[\"ciphertext\"].apply(lambda x: len(x.split(\" \")))\ntest3.sort_values(\"length\", ascending=False).head(5)","b32d5844":"train34.sort_values(\"length\", ascending=False).head(5)","790736f6":"c_id = 'ID_f0989e1c5' # length = 700\nindex = 34509 # length = 671\nsub.loc[c_id] = index # train.loc[p_id]['index']","b14ae92d":"test4.sort_values(\"length\", ascending=False).head(5)","fc84fc41":"test4.head(1)[\"ciphertext\"].values[0]","f0968239":"import base64\n\ndef encode_base64(x):\n    return base64.b64encode(x.encode('ascii')).decode()\n\ndef decode_base64(x):\n    return base64.b64decode(x)\n\ntrain34[\"nb\"] = train34[\"length\"].apply(lambda x: math.ceil(x\/100)*100)\nratio = test3[\"length\"].mean() \/ train34[\"nb\"].mean()\nprint(ratio)\n\ndef get_length_level1(x):\n    n = len(decode_base64(x))\/ratio\n    n = round(n \/ 100) * 100\n    return n\n\ntrain34.head(3)","6565503a":"test4[\"nb\"] = test4[\"ciphertext\"].apply(lambda x: get_length_level1(x)) \ntest4.sort_values(\"nb\", ascending=False).head(5)","254a11c9":"c_id = 'ID_0414884b0' # length = 900\nindex = 42677 # length = 842\nsub.loc[c_id] = index # train.loc[p_id]['index']","22afa218":"sub.head(3)","157132fd":"def is_correct_mapping(ct_l2, ct_l3):\n    tmp = pd.DataFrame([(c,n) for c,n in zip(list(ct_l2), ct_l3.split(\" \")) if c.isalpha()])\n    tmp.drop_duplicates(inplace=True)\n    tmp.columns = [\"ch\", \"num\"]\n    tmp = tmp.groupby(\"num\")[\"ch\"].nunique()\n    return tmp.shape[0] == tmp.sum()\n\ndef pad_str(s, special_char = '?'):\n    nb = len(s)\n    nb_round = math.ceil(nb \/ 100) * 100\n    nb_left = (nb_round - nb) \/\/ 2\n    nb_right = nb_round - nb - nb_left\n    \n    left_s = ''.join([special_char] * nb_left)\n    right_s = ''.join([special_char] * nb_right)\n    return left_s + s + right_s\n\ndef is_correct_mapping_low(pt, ct):\n    all_ct_l2 = [encrypt_level_2(encrypt_level_1(pad_str(pt), key_index)) for key_index in range(4)]\n\n    for i, ct_l2 in enumerate(all_ct_l2):\n        if is_correct_mapping(ct_l2, ct):\n            return i\n    return -1\n\ndef find_mapping(ciphertext_id, ct, train_df):\n    nb = len(ct.split(\" \"))\n    nb_low = ((nb \/\/ 100) - 1) * 100\n    \n    rs = []\n    selected_rows = train_df[(train_df[\"length\"] > nb_low) & (train_df[\"length\"] < nb)]\n    for row_id, row in selected_rows.iterrows():\n        pt = row[\"text\"]\n        key_index = is_correct_mapping_low(pt, ct)\n        if key_index >= 0:\n            t = row[\"index\"], key_index\n            rs.append(t)\n    if len(rs) == 1:\n        return rs[0]\n    return -1, -1","09fbab95":"for ciphertext_id, row in test3[test3[\"nb\"] >= 200].iterrows():\n    ct = row[\"ciphertext\"]\n    index, key_index = find_mapping(ciphertext_id, ct, train34)\n    if index > 0:\n        print(ciphertext_id, index, key_index, \"(length: {})\".format(row[\"nb\"]))\n        sub.loc[ciphertext_id] = index # train.loc[p_id]['index']","71d5a4e5":"print(sub[sub[\"index\"] > 0].shape[0], sub[sub[\"index\"] > 0].shape[0]\/sub.shape[0])\nsub.to_csv('submit-level-2-plus.csv')\nsub.head(3)","45a82bc7":"dict_level3 = {}\nfor ciphertext_id, row in test3[test3[\"nb\"] >= 200].iterrows():\n    ct = row[\"ciphertext\"]\n    index, key_index = find_mapping(ciphertext_id, ct, train34)\n    if index > 0:\n        print(ciphertext_id, index, key_index, \"(length: {})\".format(row[\"nb\"]))\n        dict_level3[ciphertext_id] = (index, key_index) # train.loc[p_id]['index']","15ece7d8":"dict_level3[\"ID_11070f053\"] = (40234, 1)\ndict_level3[\"ID_c1694eb06\"] = (43773, 3)\n\nfor ciphertext_id, (index, key_index) in dict_level3.items():\n    sub.loc[ciphertext_id] = index\n    \nprint(sub[sub[\"index\"] > 0].shape[0], sub[sub[\"index\"] > 0].shape[0]\/sub.shape[0])\nsub.to_csv('submit-level-2-plus2.csv')\nsub.head(3)","c5491034":"df_mapping = []\nspecial_chars = \"?\"\n\ndef get_mapping(ct_l2, ct):\n    tmp = pd.DataFrame([(c,n) for c,n in zip(list(ct_l2), ct.split(\" \")) if c not in special_chars])\n    tmp.drop_duplicates(inplace=True)\n    tmp.columns = [\"ch\", \"num\"]\n    return tmp\n\nfor ciphertext_id, (index, key_index) in dict_level3.items():\n    ct = test3.loc[ciphertext_id][\"ciphertext\"]\n    pt = train34[train34[\"index\"]==index][\"text\"].values[0]\n    ct_l2 = encrypt_level_2(encrypt_level_1(pad_str(pt), key_index))\n    print(len(ct.split(\" \")), len(pt))\n    tmp = get_mapping(ct_l2, ct)\n    df_mapping.append(tmp)\n\ndf_mapping = pd.concat(df_mapping)\nprint(df_mapping.shape)\ndf_mapping.head(3)\ndf_mapping.reset_index(drop=True, inplace=True)\ndf_mapping.tail(3)","38478743":"pd.set_option('display.max_rows', 5000)\npd.set_option('display.max_columns', 5000)\npd.set_option('display.max_colwidth', 5000)\npd.set_option('display.width', 5000)\n\ndf_ch_num = df_mapping[[\"ch\", \"num\"]].drop_duplicates().groupby(\"ch\")[\"num\"].apply(list)\ndf_ch_num = df_ch_num.to_frame(\"num\").reset_index()\ndf_ch_num[\"num\"] = df_ch_num[\"num\"].apply(lambda x: np.sort([int(n) for n in x]))\ndf_ch_num[\"num_alpha\"] = df_ch_num[\"num\"].apply(lambda x: np.sort([str(n) for n in x]))\ndf_ch_num[\"num_hex\"] = df_ch_num[\"num\"].apply(lambda x: np.sort([hex(n) for n in x]))\ndf_ch_num","2dc62c4c":"from collections import Counter\nimport matplotlib.pyplot as plt\n\nplt.rcParams[\"figure.figsize\"] = (20,10)","10aa4c90":"test2 = test[test[\"difficulty\"] == 2].copy()\nfullcipher2 = \"\".join((test2[\"ciphertext\"].values))\ndict_fullcipher2 = Counter(fullcipher2)\ndf_fullcipher2 = pd.DataFrame.from_dict(dict_fullcipher2, orient='index')\ndf_fullcipher2 = df_fullcipher2.reset_index()\ndf_fullcipher2.columns = [\"ch\", \"nb\"]\ndf_fullcipher2.sort_values(\"nb\", ascending=False, inplace=True)\nprint(df_fullcipher2.shape)\ndf_fullcipher2.head()","faeb6174":"print(df_fullcipher2[\"nb\"].mean(), df_fullcipher2[\"nb\"].median())\ndf_fullcipher2.plot(x=\"ch\", y=[\"nb\"], kind=\"bar\");","e3fcdd3e":"fullcipher3 = \" \".join((test3[\"ciphertext\"].values))\ndict_fullcipher3 = Counter(fullcipher3.split(\" \"))\ndf_fullcipher3 = pd.DataFrame.from_dict(dict_fullcipher3, orient='index')\ndf_fullcipher3 = df_fullcipher3.reset_index()\ndf_fullcipher3.columns = [\"num\", \"nb\"]\ndf_fullcipher3.sort_values(\"nb\", ascending=False, inplace=True)\nprint(df_fullcipher3.shape)\ndf_fullcipher3.head()","7dea2f68":"df_fullcipher3[df_fullcipher3[\"nb\"] > 1500].plot(x=\"num\", y=[\"nb\"], kind=\"bar\");","ee2a0204":"# Level 3 - mapping for few pairs\n## 3 easy pairs\nAssume that one number is associated to only a single char, let's find 2 pontential matches as listed above.","b7cf8306":"## Update sub with level 2 decrypted matching texts","dc0f81bc":"##  Let's submit it the score should be a little bit higher","99ee8e2f":"## Level 4\nEven more, index 34509 could be a text in level 4 as it does not seems to match any cipher text in level 3","f785a2c8":"Make a dictionary for fast lookup of plaintext","09da6532":"OOM, what are they","b81fe953":"* If you find this useful - let me know by giving it a like ;-)","859112e5":"# Level 3 and level 4 - exploration","d822930b":"## Functions to decrypt and encrypt from\/to level 1","caeef402":"Look better, let's see the train set","f967969d":"## Read the train, test and sub files","f51c9012":"Cool, we found an exact match for level 3 and 2 possible matches.","80ae7479":"# Further exploration\n\nkaggleuser58: Have you tried finding the corresponding plaintext letters for each group and see if you can see something if you sort the groups in the correct order - it might help in finding the solution.\n","a5b9f551":"## Level 3 - Let's see some cipher text","16f81638":"[Credit to https:\/\/www.kaggle.com\/kaggleuser58\/cipher-challenge-iii-level-1]\n\n# Introduction\n\n### Time to share solution of cipher level 2 so you can look at the next level.\nIn the previous Cipher Challenge II one of the levels was a cipher with multiple substitutions generated from a key of length 8 if I remember correct.\n\nThe level 1 of this Cipher Challenge III is the same kind but with a key of length 4, so only 4 substitutions are used for each character mapping.\nSee https:\/\/www.kaggle.com\/kaggleuser58\/cipher-challenge-iii-level-1\n\nThe level 2 of this Cipher Challenge III is a transposition cipher on top of level 1.\nSee https:\/\/www.kaggle.com\/c\/ciphertext-challenge-iii\/discussion\/103969#latest-598262\n\n## The cipher\n- The cipher only apllies to UPPERCASE and LOWERCASE letters.\n- The key only shifts every time an UPPERCASE or LOWERCASE letter is met.\n\n## Padding\nFrom Cipher Challenge II it was found that padding could be done both up front and in the end. Number of padding characters in the end was always equal to or at most 1 character more (if number of characters to pad with was odd) than the number of padding characters up front.\n\n# Level 1 and level 2 - solution","544f2542":"It makes sense now. We found a match for level 4","3e690019":"## Update sub with level 1 decrypted matching texts","b671ceb6":"## Frequency analysis on Level 3","017141b8":"## Frequency analysis on Level 2","f020d257":"Then it must be a base64 text, but base64 is just a encoding method and this text is just a way to hide the real content. Let's do a count as well. Note that we have to count the number of chars in the level 1.","adad8fed":"OK, look like it is too long. Probably each number is one character. Let's count the numbers."}}