{"cell_type":{"c1f77f2b":"code","a027b8f8":"code","b54d48ff":"code","9f2fec49":"code","6a7eb2b8":"code","4a8a7852":"code","c49666a0":"code","4910333a":"code","0de6ce92":"code","980b5c64":"code","109a5a1a":"code","e1e4b35f":"code","e0935bed":"code","2a924bb2":"code","c7a99ee3":"code","1eb34316":"code","65e9596e":"code","1ea8c5b0":"code","33f24673":"code","132c5e81":"code","5b482fb0":"code","06beddc1":"code","073471c1":"code","64e819e5":"code","ae112cd2":"code","7e2790ed":"code","5273522d":"code","400f80d1":"code","2c8f70ca":"code","009a4b71":"code","5543e135":"code","2e03dd13":"code","87cd8e54":"code","1c39fd49":"code","be2b394d":"code","05b172fb":"markdown","534598c3":"markdown","e00c0a67":"markdown","705116fc":"markdown","4c02fef6":"markdown","8ff08b41":"markdown","6fd02ce0":"markdown","aef70ee5":"markdown","1a0862d1":"markdown","63d9b3f9":"markdown","17727204":"markdown","7f567e8f":"markdown","262635c7":"markdown","0141fa32":"markdown","32110d7c":"markdown","7fccc9eb":"markdown","72d42f2d":"markdown"},"source":{"c1f77f2b":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\nimport os # Working with files\nimport rasterio as rs # Reading and manupulating Raster files\nfrom rasterio.plot import show  # Imshow for raster\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling # Reprojecting raster files\nfrom rasterio.merge import merge # For merging rasters\nfrom rasterio.mask import mask # For cropping rasters\nimport geopandas as gpd\nfrom shapely.geometry import Polygon  # for geometry processing\nimport contextily as ctx # This is what we need to tiles from arbitrary tile provider\nimport folium # Gives us an interactive map to see our ROI\nimport cv2 # For Resizing the images","a027b8f8":"ctx.set_cache_dir('.\/cache') # This will set the cache folder path for downloaded tiles","b54d48ff":"ROOT_DIR = '..\/input\/spacenet-6-multisensor-allweather-mapping\/AOI_11_Rotterdam\/'","9f2fec49":"MODES=os.listdir(ROOT_DIR)\nMODES.sort()\nMODES=MODES[:-2]","6a7eb2b8":"MODES","4a8a7852":"def get_filepath(image_id, mode='PS-RGB'):\n    return f'{ROOT_DIR}{mode}\/SN6_Train_AOI_11_Rotterdam_{mode}_{image_id}.tif'\n\ndef get_raster(image_id, mode='PS-RGB'):\n    return rs.open(get_filepath(image_id, mode))\n\n# I anticipated adding mode options, but I think the tile boundaries are the same for each mode\ndef create_geometry(mode, image_ids):\n    geometry = []\n    coordinate_system = rs.open(get_filepath(image_ids[0], mode)).crs\n    for image_id in tqdm(image_ids):\n        # read the raster\n        ex_raster = rs.open(get_filepath(image_id, mode))\n        \n        # grab its boundaries\n        lbox, bbox, rbox, tbox = ex_raster.bounds\n        # convert into coordinates\n        geometry.append(Polygon([\n            (lbox,tbox),\n            (rbox,tbox),\n            (rbox,bbox),\n            (lbox,bbox)]))\n\n    # create geodataframe\n    d = {'image_id': image_ids, 'geometry': geometry}\n    gdf = gpd.GeoDataFrame(d, crs=coordinate_system)\n\n    # saving to geojson file\n    gdf.to_file(f'{mode}.geojson', driver='GeoJSON')\n    print(f'{mode}.geojson saved successfully!')","c49666a0":"def create_graphic_maps(geo_data_frame ,root_dir,data_set_name='WorldTopoMap',zoom=16,source=ctx.providers.Esri.WorldTopoMap,verbose=False):\n    assert os.path.exists(root_dir)\n    data_set_path = root_dir + data_set_name\n    if not os.path.exists(data_set_path):\n        os.mkdir(data_set_path)\n    coordinate_system = geo_data_frame.crs\n    for _ ,(image_id,geometry) in tqdm(geo_data_frame[['image_id','geometry']].iterrows()):\n        bounds = geometry.bounds\n        if verbose:\n            tiles_to_download = ctx.howmany(*bounds,zoom=zoom,ll=False,)\n            print (f'for zoom lelev{zoom} and bouding box{tr.transform_bounds(*bounds)} you need to download {tiles_to_download} tiles ')\n        file_name = os.path.join(data_set_path, f'SN6_Train_AOI_11_Rotterdam_{data_set_name}_{image_id}.tif')\n        ctx.bounds2raster(*bounds, ll=False, path=file_name, zoom=zoom, source=source,)\n\n        ","4910333a":"df = pd.read_csv(ROOT_DIR+'SummaryData\/SN6_Train_AOI_11_Rotterdam_Buildings.csv')\nimage_ids = df.ImageId.unique()","0de6ce92":"create_geometry('PS-RGB', image_ids)\ngdf = gpd.read_file('PS-RGB.geojson')\nfig, ax1 = plt.subplots(figsize=(20,10))\ngdf.plot(color='grey', alpha=0.3, edgecolor='black',ax=ax1)","980b5c64":"mereged_gdf = gdf.dissolve()\nfig,ax = plt.subplots(1,1,figsize=(8,14))\nmereged_gdf.plot(color='grey', alpha=0.3, edgecolor='black',ax=ax)","109a5a1a":"Map = mereged_gdf.explore()\nfolium.LayerControl().add_to(Map)\nMap","e1e4b35f":"mereged_gdf.to_crs(epsg=3857,inplace=True) #\nDATA_DIR_FOR_MAPS = '.\/'\nsrc = ctx.providers.Esri.WorldTopoMap # We're interested in Data with no label\nzoom_lvl = 17 # This the zoom level that is the closest to the data resolution we are using here\ncreate_graphic_maps(mereged_gdf,DATA_DIR_FOR_MAPS ,data_set_name='WorldTopoMap',zoom=zoom_lvl ,source=src,verbose=False)","e0935bed":"file_path = 'WorldTopoMap\/SN6_Train_AOI_11_Rotterdam_WorldTopoMap_20190822070610_20190822070846_tile_3721.tif'\nmap_raster = rs.open(file_path)\nshow(map_raster)","2a924bb2":"map_raster.shape #our data dimentions","c7a99ee3":"map_crs = map_raster.crs # CRS \nmap_crs","1eb34316":"tiles=[]\nfor image_id in tqdm(image_ids):\n    tiles.append(get_raster(image_id,mode=MODES[1]))\n    \nmosaic, transformation = merge(tiles) #Merge the tiles","65e9596e":"rgb_raster_file = get_raster(image_ids[0],mode=MODES[1])\nrgb_meta_data = rgb_raster_file.meta.copy()\nrgb_crs = rgb_raster_file.crs","1ea8c5b0":"rgb_meta_data.update({\"driver\": \"GTiff\",\n                  \"height\": mosaic.shape[1],\n                 \"width\": mosaic.shape[2],\n                 \"transform\": transformation,\n                 \"crs\": rgb_crs\n                   }\n                )","33f24673":"output_file = 'RGB.tif'\nwith rs.open(output_file, \"w\", **rgb_meta_data) as dest:\n     dest.write(mosaic)\n        ","132c5e81":"rgb_raster = rs.open('RGB.tif')\nprint(rgb_raster.crs) # CRS.from_epsg(32631)","5b482fb0":"dst_crs = 'EPSG:3857'\n\nwith rs.open(output_file) as src:\n    transform, width, height = calculate_default_transform(\n        src.crs, dst_crs, src.width, src.height, *src.bounds)\n    kwargs = src.meta.copy()\n    kwargs.update({\n        'crs': dst_crs,\n        'transform': transform,\n        'width': width,\n        'height': height\n    })\n    \n    with rs.open('RGB_Resampled.tif', 'w', **kwargs) as dst:\n        for i in range(1, src.count + 1):\n            reproject(\n                source=rs.band(src, i),\n                destination=rs.band(dst, i),\n                src_transform=src.transform,\n                src_crs=src.crs,\n                dst_transform=transform,\n                dst_crs=dst_crs,\n                resampling=Resampling.nearest)\n","06beddc1":"rgb_raster = rs.open('RGB_Resampled.tif')\ndisplay(rgb_raster.crs) # CRS.from_epsg(3857)\nshow(rgb_raster)","073471c1":"min_x ,min_y ,max_x ,max_y = map_raster.bounds # Map's bouding box\nmap_poly = Polygon([(min_x,min_y),(min_x,max_y),(max_x,max_y),(max_x,min_y)])\n\nmin_x ,min_y ,max_x ,max_y = rgb_raster.bounds #RGB's bounding box\nrgb_poly = Polygon([(min_x,min_y),(min_x,max_y),(max_x,max_y),(max_x,min_y)])\n\nintersection_poly = rgb_poly.intersection(map_poly)\n\nscene = gpd.GeoDataFrame([1,2],geometry=[rgb_poly,map_poly],crs=map_crs)\nintersection_bound = gpd.GeoDataFrame([3],geometry=[intersection_poly])\n","64e819e5":"fig,ax = plt.subplots(1,1,figsize=(10,10))\nscene.plot(color=['red','green'], alpha=0.35, edgecolor='black',ax=ax)# Red:Map, Green:RGB\nintersection_bound.boundary.plot(color='blue',ax=ax) # Intersection Bounding Box: Blue\nctx.add_basemap(ax=ax)\n","ae112cd2":"def getFeatures(gdf):\n    \"\"\"Function to parse features from GeoDataFrame in such a manner that rasterio wants them\"\"\"\n    import json\n    return [json.loads(gdf.to_json())['features'][0]['geometry']]","7e2790ed":"coords = getFeatures(intersection_bound)\n\nmap_cropped, _ = mask(dataset=map_raster, shapes=coords, crop=True)\nmap_cropped = rs.plot.reshape_as_image(map_cropped)\n\nrgb_cropped,_ = mask(dataset=rgb_raster, shapes=coords, crop=True)\nrgb_cropped = rs.plot.reshape_as_image(rgb_cropped)","5273522d":"display(map_cropped.shape) #(10653, 9022, 4) , The last channel is just a nodata mask\ndisplay(rgb_cropped.shape) #(15709, 13305, 3)","400f80d1":"resampled_map = cv2.resize(map_cropped[:,:,:3],rgb_cropped.shape[:2][::-1])","2c8f70ca":"display(resampled_map.shape) #(15709, 13305, 3)\ndisplay(rgb_cropped.shape) #(15709, 13305, 3)","009a4b71":"fig,ax = plt.subplots(1,2,figsize=(20,10))\nax[0].imshow(rgb_cropped)\nax[1].imshow(resampled_map)","5543e135":"# A simple function to make grid like masks\ndef get_mask(img,grid_size=45):\n    mask = np.zeros_like(img,dtype=np.bool)\n    h,w = img.shape[:2]\n    n_h = h\/\/grid_size\n    n_w = w\/\/grid_size\n    skip =- 1\n    for m in range(n_h-1):\n        for n in range(n_w-1):\n            skip *=- 1\n            if skip == 1:\n                mask[m*grid_size:(m+1)*grid_size,n*grid_size:(n+1)*grid_size] = True\n    return mask\n","2e03dd13":"m1, m2 ,n1 ,n2 =2000 ,2500 ,5000 ,5500\ndm, dn = 10, 10 # find the right offset\nresized_graphic_map = cv2.resize(map_cropped[:,:,:3], rgb_cropped.shape[:2][::-1])\nfig,ax = plt.subplots(1,3,figsize=(24,8))\nimg1 = resampled_map[m1 + dm:m2+dm,n1+dn:n2+dn]\nimg2 = rgb_cropped[m1:m2,n1:n2]\n\nmask = get_mask(img1,60)\nmasked_img = img1.copy()\nmasked_img [mask] = img2[mask]*.75+ .0*masked_img [mask]\nax[0].imshow(img1)\nax[1].imshow(img2)\nax[2].imshow(masked_img)","87cd8e54":"plt.figure(figsize=(20,20))\nplt.imshow(masked_img)","1c39fd49":"resized_graphic_map = cv2.resize(map_cropped[:,:,:3], rgb_cropped.shape[:2][::-1])\nmask = get_mask(rgb_cropped,200)\nresized_graphic_map[mask] = rgb_cropped[mask]\nplt.figure(figsize=(20,20))\nplt.imshow(resized_graphic_map[2000:3000,6000:7000])","be2b394d":"extends = [479772.0995437933,  490480.21953905135,6773365.216157863, 6786024.545012578]","05b172fb":"Now let's write it down on the disk","534598c3":"Take a better look at our data location","e00c0a67":"Let's take a look at the tiles","705116fc":"This is the function that downloads the tiles for us","4c02fef6":"The Bouding box of the tiles we've downloaded is not exacty aligned with the data we have. Let's take a look at it","8ff08b41":"Let's see how does our downloader data looks like","6fd02ce0":"grab unique image_id from the annotation csv\n","aef70ee5":"Perfect, Let's see what we've done so far","1a0862d1":"The file we've written this far is not in the standard CRS. This is important for us since the tiles we've downloaded are in Web Spherical Coordinate system So we need to reproject the data. there is probaly a clean way to write and reproject it at the same time but let's go with this ugly way for now. You can find this piece of code in rasterio documentation","63d9b3f9":"Now what we need to resample the data again, because our map raster doesn't have exactly the same number of pixels as the rgb raster files \nwe use opencv here","17727204":"**Let's download the tiles from the ROI above and save it as raster file <\/br>**\nThere are afew things to note: <\/br>\n- The raster file's CRS (Coordinate Reference System) our data is not standard. Contextily expect us coordinates in form of lon\/lat of [Spherical Web Mercator](https:\/\/en.wikipedia.org\/wiki\/Web_Mercator_projection) which is known as **EPSG:3857**\n- There are lots of tile providers out ther in the web you can choose amonge many of them [there](https:\/\/leaflet-extras.github.io\/leaflet-providers\/) is a demo of some of them \n- Our data is high resolution the closest zoom level to our data is 17, every unint increase in zoom level means increase in height and width of the downloaded tiles in proportion of x2 means by increasing zoom level by 1 you need to download 4 times more data\n","7f567e8f":"Let's Merge the areas","262635c7":"Now let's merge the the raster files we got and make a big raster file. For this task I'm using the RGB modality \n","0141fa32":"Some Utility Functions from  [this](https:\/\/www.kaggle.com\/sandhiwangiyana\/sn6-working-with-geo-reference-images-eda) notebook","32110d7c":"Hi <\/br>\nin this notebook I will be exploring tools for retrieveing tiles of any given raster file and making pathces of them. The raster file I'm using here are files from SN6 competition ","7fccc9eb":"Cool, Let's check it out then \n","72d42f2d":"Let's choose the intersection of two bounding box as our Region of Interest and crop our data. check out rasterio documentation for details"}}