{"cell_type":{"bcf5603f":"code","f99a6573":"code","3955a980":"code","118f4615":"code","67d7c71b":"code","6850a148":"code","2fc8147a":"code","f46bee7d":"code","3e1795bf":"code","4c5dffb2":"code","3db2cf60":"code","b6b0ff96":"code","10f92380":"code","c59a42a7":"code","0f362e34":"code","ae57dcdc":"code","9f7e9d30":"code","e4e4447d":"code","8728fb67":"code","78863944":"code","43e3bf25":"code","9691f0e7":"code","5725311b":"code","38701df7":"code","408857c9":"code","6cbaec1b":"code","3536c793":"code","5e3f6b75":"code","e4f1656a":"code","808faec1":"code","a0f49384":"code","539eb2cf":"code","826b83f6":"code","6e1abed4":"code","e14505c3":"code","9e1f9e46":"code","ecd13732":"code","fb64c508":"code","d448b523":"code","9af5d170":"code","6350c381":"code","d32fe1f2":"code","756ee64f":"code","f23d7e92":"code","807df314":"code","02711a6f":"code","f97fe5d5":"code","e49299ea":"code","14aab4c5":"code","cf42255c":"code","c617e190":"code","0828c509":"code","a53e8eef":"code","b7cf04c7":"code","2d034e67":"code","776ee050":"code","c12001cc":"code","2bb76478":"code","07cf9fe1":"code","7aa771c5":"code","fcec04ef":"code","20f1a382":"code","5a0c14b8":"code","83446cc3":"code","e6faa722":"code","4008a9e0":"code","7d365c5d":"code","e1a8410e":"code","5c151dc0":"code","92782283":"code","5ee320e4":"code","859fe875":"code","63196f81":"code","abf8462a":"code","e47d2ece":"code","df2e1932":"code","67e6ddfe":"code","907e2f88":"code","dbeab6fb":"code","b8e0d31b":"code","fb84a1d5":"code","3e475915":"code","f5dcdb7f":"code","4f052bdc":"code","2b944cf3":"code","eb95098f":"code","cf17ecd1":"code","c470518b":"code","384a4701":"code","fb0de4d2":"code","9cdf16a1":"code","a954dfe9":"code","a832cc1f":"code","e70b212e":"code","cf3731d2":"code","f7864b55":"code","83ddf6e4":"code","7f33b833":"code","8e2f9d53":"code","9b649843":"code","2e8cd2ce":"code","528fae5d":"code","d0e35dd8":"code","8882b724":"code","ea861879":"code","a9b137bc":"code","21ab9407":"code","fdefb5c9":"code","6881e037":"code","a75560d9":"code","0bab1487":"code","50f06c88":"code","531ca17e":"code","9bd2eebd":"code","a7893000":"code","12002ab7":"code","80af0776":"code","49e7522a":"code","d95527bd":"code","cbebdc59":"code","11a69f36":"code","28d8ab33":"code","b1cbbb6f":"code","70a170dc":"code","7087f491":"code","1561a176":"code","998e058f":"code","97f6d93e":"markdown","a29b946e":"markdown","c7f986a0":"markdown","15ef44f0":"markdown","67b32578":"markdown","17fae98f":"markdown","39263bf0":"markdown","26a3f0f6":"markdown","fe06bcbb":"markdown","dd3d39d3":"markdown","c8af1208":"markdown","fac7e6cf":"markdown","651a8bf5":"markdown","f47b8c02":"markdown","8e8f43a3":"markdown","fca48aff":"markdown","2f6daa54":"markdown","822f282a":"markdown","a27d1df6":"markdown","065c1273":"markdown","50476ca8":"markdown","4b2d2ebe":"markdown","0e8140da":"markdown","d84bb228":"markdown","695dc40b":"markdown","efc370c1":"markdown","d0a3b7ed":"markdown","41580812":"markdown","e012decf":"markdown","63c5e509":"markdown","8b22ad53":"markdown","d9cde46a":"markdown","d5082f56":"markdown","83b8b811":"markdown","f4b29bd2":"markdown","1d99e377":"markdown","cbe4493e":"markdown","e6d13ee2":"markdown","3dc75e15":"markdown","55cecf83":"markdown","76d0289a":"markdown","5a2e50ec":"markdown","18c639a5":"markdown","e60f6cdd":"markdown","99a7d1fe":"markdown","0805d8bc":"markdown"},"source":{"bcf5603f":"import numpy as np\na = np.array([3.2,4,6,5]) # array\nprint('\\n',a)\nb = np.array([1,4,2,5,3]) # integer array:\nprint('\\n',b)","f99a6573":"np.array([1,2,3,4], dtype=\"str\")","3955a980":"np.array([3,6,2,3], dtype=\"float32\")","118f4615":"# nested lists result in multidimensional arrays\n\nnp.array([range(i,i+3) for i in [2,4,6]])","67d7c71b":"# Create a 3x5 array filled with 5\n\nnp.full((3,5), 5)","6850a148":"# Create an array filled with a linear sequence\n# Starting at 0, ending at 20, stepping by 2\n# (this is similar to the built-in range() function)\n\nnp.arange(0,20,2)","2fc8147a":"x1 = np.array([5, 0, 3, 3, 7, 9])\nx1","f46bee7d":"#To index from the start of the array, you can use positive indices:\n\nx1[0]","3e1795bf":"#To index from the end of the array, you can use negative indices:\n\nx1[-1]","4c5dffb2":"import numpy as np\nnp.array","3db2cf60":"import numpy as np\n\n# From list: 1d array\nmy_list = [10, 20, 30]\nnp.array(my_list)","b6b0ff96":"# From list: 2d array\nlist_of_lists =  [[5, 10, 15], [20, 25, 30], [35, 40, 45]]\nnp.array(list_of_lists)","10f92380":"x = np.array([[3, 5, 2, 4],\n       [7, 6, 8, 8],\n       [1, 6, 7, 7]])\nx","c59a42a7":"x[2,1]","0f362e34":"x[2,-4]","ae57dcdc":"x[-2,-3]","9f7e9d30":"#You can also modify values using any of the above index notation:\n\nx[0,0]=12\nx","e4e4447d":"#Check data type of ndarray\ntype(np.array(x))","8728fb67":"a =  np.array([[1, 2, 3,4,5,6],[7,8,9,10,11,12]]) \nprint(a)\nprint(a.shape)","78863944":"import numpy as np\n\nnp.arange(0, 10)","43e3bf25":"arr = np.array(my_list)\n\nprint(arr.dtype)","9691f0e7":"string = 'My_name'\nprint(string)","5725311b":"names = ['dumbledore', 'beeblebrox', 'skywalker', 'hermione', 'leia'] #list\nnames","38701df7":"names = ['dumbledore', 'beeblebrox', 'skywalker', 'hermione', 'leia']\ncapitalized_names = []\nfor name in names:\n    capitalized_names.append(name.title())\n\n# equals (do.. for)\ncapitalized_names = [name.title() for name in names]\ncapitalized_names","408857c9":"squares = [x**2 for x in range(9) if x % 2 == 0]  # square of Even integer \nprint(squares)\n# to add else statements, move the conditionals to the beginning\nsquares = [x**2 if x % 2 == 0 else x + 3 for x in range(9)]","6cbaec1b":"location = (13.4125, 103.866667)   #Create Tuples\nlocation","3536c793":"print(\"Latitude:\", location[0])   #Access tuples\nprint(\"Longitude:\", location[1])","5e3f6b75":"# can also be used to assign multiple variables in a compact way\ndimensions = 52, 40, 100    # tuple packing","e4f1656a":"# tuple unpacking\nlength, width, height = dimensions\nprint(\"The dimensions are {} x {} x {}\".format(length, width, height))","808faec1":"numbers = [1, 2, 6, 3, 1, 1, 6]   #list convert to set\nunique_nums = set(numbers)\nprint(unique_nums) # {1, 2, 3, 6}","a0f49384":"fruit = {\"apple\", \"banana\", \"orange\", \"grapefruit\"} #create set\nprint(fruit)  #print set\nprint(\"watermelon\" in fruit)  #check element in set\nfruit.add(\"watermelon\")   #add element in set\nprint(fruit)   #after adding print set\nprint(\"watermelon\" in fruit)  #check element in set","539eb2cf":"print(fruit.pop())   #remove a random element from set\nprint(fruit)","826b83f6":"elements={}       # Create empty dictionary\nelements = {\"hydrogen\": 1, \"helium\": 2, \"carbon\": 6}       #create dict\nelements","6e1abed4":"print(elements[\"helium\"])  #accing element","e14505c3":"elements[\"lithium\"] = 3   #addind element\nelements","9e1f9e46":"# Just keys\nfor key in elements:\n    print(key)\n# Keys and values\nfor key, value in elements.items():\n    print(\"Actor: {}    Role: {}\".format(key, value))","ecd13732":"del elements['carbon']  #delete value from dict\nelements\n#alternative way\nelements.pop('helium')\nelements","fb64c508":"# check whether a value is in a dictionary, the same way we check whether a value is in a list or set with the in keyword.\nprint(\"carbon\" in elements) # True","d448b523":"# get() looks up values in a dictionary, but unlike square brackets, get returns None (or a default value of your choice) if the key isn't found.\n# If you expect lookups to sometimes fail, get might be a better tool than normal square bracket lookups.\nprint(elements.get(\"dilithium\")) # None\nprint(elements.get('kryptonite', 'There\\'s no such element!'))\n# \"There's no such element!\"","9af5d170":"n = elements.get(\"dilithium\")\nprint(n is None) # True\nprint(n is not None) # False","6350c381":"a = [1, 2, 3]\nb = a\nc = [1, 2, 3]\nprint(a == b) # True\nprint(a is b) # True\nprint(a == c) # True\nprint(a is c) # False\n# List a and list b are equal and identical.\n# List c is equal to a (and b for that matter) since they have the same contents. But a and c (and b for that matter, again) point to two different objects, i.e., they aren't identical objects.\n# That is the difference between checking for equality vs. identity.","d32fe1f2":"elements = {\"hydrogen\": {\"number\": 1,\n                         \"weight\": 1.00794,\n                         \"symbol\": \"H\"},\n              \"helium\": {\"number\": 2,\n                         \"weight\": 4.002602,\n                         \"symbol\": \"He\"}}\nhelium = elements[\"helium\"]  # get the helium dictionary\nhydrogen_weight = elements[\"hydrogen\"][\"weight\"]  # get hydrogen's weight\noxygen = {\"number\":8,\"weight\":15.999,\"symbol\":\"O\"}  # create a new oxygen dictionary \nelements[\"oxygen\"] = oxygen  # assign 'oxygen' as a key to the elements dictionary\nprint('elements = ', elements)","756ee64f":"words =  ['great', 'expectations','the', 'adventures', 'of', 'sherlock','holmes','the','great','gasby','hamlet','adventures','of','huckleberry','fin'];\nword_counter = {}\nfor word in words:\n    word_counter[word] = word_counter.get(word,0)+1;\nprint(word_counter);","f23d7e92":"z = np.zeros((2, 3))\nprint('Zeros: \\n',z)\n\no = np.ones((2, 4))\nprint('Ones: \\n',o)\n\ne = np.eye(3)\nprint('Eye: \\n',e)\n# divide into 7 interval from 0 to 10\nls  =  np.linspace(0, 10, 7)\nprint('linespace:\\n',ls)\n\n# 2 x 3 ndarray full of fives\n# np.full(shape, constant value)\nX = np.full((2,3), 5)\nprint('X:\\n',X)","807df314":"# random number (uniform distribution) array of shape (3 , 4)\n\na = np.random.rand(3, 4)\nprint('a:\\n',a)\n# random number (standard normal distribution) array of shape (2, 3)\n\nb = np.random.randn(2, 3)\nprint ('b:\\n',b)\n\n# 10 random integers between 4 (inclusive) to 40 (exclusive)\n\nc = np.random.randint(4, 40, 10)\nprint('c:\\n',c)\n# 10 random integers upto 50 (exclusive). This makes the start value default to 0.\n# The size parameter dictates the return array shape\n\nd = np.random.randint(50, size=(4,4))\nprint('d:\\n',d)","02711a6f":"a1= np.arange(1, 10, dtype=np.float16).reshape(3, 3)\na2 = np.arange(100, 109, dtype=np.float16).reshape(3, 3)\n\nprint('a1:',a1)\nprint('a2:',a2)\n\nprint('Vector Division:\\n',a2 \/ a1)  # Vector Division\nprint('Scalar Division:\\n',a2 \/ 3)    # Scalar Division\n\nab= np.arange(1, 10, dtype=np.float16).reshape(3, 3)\nabc = a1 > 5   #comparison \n\nprint(ab)\nprint(abc)\n\nprint(type(ab))\nprint(abc.dtype)","f97fe5d5":"x = np.array([1,2,3,4,5])\n\nprint(x<3)  # less than\nprint(x>3)  # greater than\nprint(x<=3) #less than or equal\nprint(x>=3) #greater than or equal\nprint(x!=3) #not equal\nprint(x==3) #equal","e49299ea":"# In Python, all nonzero integers will evaluate as True .\nbool(42), bool(0), bool(-1)","14aab4c5":"bool(42 and 0)","cf42255c":"bool(42 or 0)","c617e190":"# When you have an array of Boolean values in NumPy, this can be thought of as a\n# string of bits where 1 = True and 0 = False , and the result of  | operates in a\n# similar manner as before:\n\nA = np.array([1, 0, 1, 0, 1, 0], dtype=bool)\nB = np.array([1, 1, 1, 0, 1, 1], dtype=bool)\nA | B","0828c509":"# When you have an array of Boolean values in NumPy, this can be thought of as a\n# string of bits where 1 = True and 0 = False , and the result of & operates in a\n# similar manner as before:\n\nA = np.array([1, 0, 1, 0, 1, 0], dtype=bool)\nB = np.array([1, 1, 1, 0, 1, 1], dtype=bool)\nA & B","a53e8eef":"# Find max, min, mean of given ndarray\nmy_list = [10, 20, 30, 40, 50, 60, 70, 80, 90]\ntemp = np.array(my_list)\nprint('Max: ', temp.max())\nprint('Min: ', temp.min())\nprint('Mean: ', temp.mean())\n\n# Find index of max\/min \nprint('Argmax: ', temp.argmax())\nprint('Argmin: ', temp.argmin())","b7cf04c7":"# As a quick example, consider computing the sum of all values in an array. Python\n# itself can do this using the built-in sum function:\n\nL = np.random.random(100)\nsum(L)","2d034e67":"#The syntax is quite similar to that of NumPy\u2019s sum function, and the result is the same\n#in the simplest case:\n\nnp.sum(L)","776ee050":"# One common type of aggregation operation is an aggregate along a row or column.\n# Say you have some data stored in a two-dimensional array:\n\nM = np.random.random((3,4))\nprint(M)\n\nM.sum()","c12001cc":"# Aggregation functions take an additional argument specifying the axis along which\n# the aggregate is computed. For example, we can find the minimum value within each\n# column by specifying axis=0:\n\nprint(M.min(axis=0))\n#or use that way\nprint(np.min(M,axis=0))\nM","2bb76478":"# Similarly, we can find the maximum value within each row:\n\nM.max(axis=1)","07cf9fe1":"# Note that some of these NaN-safe functions were not added until\n# NumPy 1.8, so they will not be available in older NumPy versions.\n\nx = np.array([1,2,np.nan,4,5])\n\nprint(\"np.sum       =\",np.sum(x))\nprint(\"np.nansum    =\",np.nansum(x))\n\nprint(\"np.mean      =\",np.mean(x))\nprint(\"np.nanmean   =\",np.nanmean(x))\n\nprint(\"np.std       =\",np.std(x))\nprint(\"np.nanstd    =\",np.nanstd(x))\n\n\n#Be careful that this is not a real index of minimum value.\nprint(\"np.argmin    =\",np.argmin(x)) \n#if there is a nan value in an array, it returns index of nan value.\n\n\nprint(\"np.nanargmin =\",np.nanargmin(x))\n","7aa771c5":"import numpy as np \nx = np.array([[5.3, 10.2, 15.1], [20.4, 25.3, 30.9], [35.4, 40.1,45.6]])\nprint(x.dtype)\nprint(x.shape)","fcec04ef":"# Another useful type of operation is reshaping of arrays. The most flexible way of\n# doing this is with the reshape() method. For example, if you want to put the numbers\n# 1 through 9 in a 3\u00d73 grid, you can do the following:\n\ngrid = np.arange(1,10,1).reshape(3,3)\nprint(grid)","20f1a382":"x = np.random.randn(4,3)\nx.reshape(3,4)","5a0c14b8":"x = np.arange(10)\nx","83446cc3":"x[:5] # first five elements","e6faa722":"x[5:] # elements after index 5","4008a9e0":"x[4:7]# middle subarray","7d365c5d":"x[::2] # every other element\n","e1a8410e":"x[1::2] #every other element, starting at index 1","5c151dc0":"x[-7:-2:2]","92782283":"# A potentially confusing case is when the step value is negative. In this case, the\n# defaults for start and stop are swapped. This becomes a convenient way to reverse\n# an array:\n\nx[::-1] # all elements, reversed","5ee320e4":"x[5::-2]# reversed every other from index 5","859fe875":"x[5:-8:-1]","63196f81":"z = np.array([[12,  5,  2,  4],\n       [ 7,  6,  8,  8],\n       [ 1,  6,  7,  7]])\nz","abf8462a":"# two rows, three columns\n\nz[:2, :3]","e47d2ece":"# all rows, every other column\n\nz[:3,::2]","df2e1932":"#Finally, subarray dimensions can even be reversed together:\n\nz[::-1,::-1]","67e6ddfe":"print(z[:, 0]) # first column of z","907e2f88":"print(z[0,:]) # first row of z","dbeab6fb":"#In the case of row access, the empty slice can be omitted for a more compact syntax:\n\nprint(z[0]) # equivalent to z[0, :]","b8e0d31b":"#Let\u2019s extract a 2\u00d72 subarray from this:\n\nx2_sub = z[:2,:2]\nprint(x2_sub)","fb84a1d5":"#Now if we modify this subarray, we\u2019ll see that the original array is changed! Observe:\n\nx2_sub[0,0] = 99\nprint(x2_sub)\nprint(z)","3e475915":"x2_sub_copy = z[:2,:2].copy()\nprint(x2_sub_copy)","f5dcdb7f":"#If we now modify this subarray, the original array is not touched:\n\nx2_sub_copy[0,0] = 42\nprint(x2_sub_copy)","4f052bdc":"x = np.array([1,2,3])\ny = np.array([3,2,1])\nnp.concatenate((x, y))\n","2b944cf3":"#You can also concatenate more than two arrays at once:\nz = np.array([99,99,99]) \n\n\nprint(np.concatenate((x,y,z)))","eb95098f":"grid = np.array([[1,2,3],\n                [4,5,6]])","cf17ecd1":"# concatenate along the first axis\n\nnp.concatenate((grid,grid))","c470518b":"# concatenate along the second axis (zero-indexed)\n\nnp.concatenate((grid, grid), axis=1)","384a4701":"# For working with arrays of mixed dimensions, it can be clearer to use the np.vstack\n# (vertical stack) and np.hstack (horizontal stack) functions:\n\nx = np.array([1,2,3])\ngrid = np.array([[9,8,7],\n                 [6,5,4]])\n\n\n# vertically stack the arrays\nnp.vstack([x,grid])","fb0de4d2":"#horizontally stack the arrays\n\ny = np.array([[99],\n            [99]])\nnp.hstack([grid,y])","9cdf16a1":"x = [1,2,3,99,99,3,2,1]\nx1, x2, x3 = np.split(x, [3,5])\nprint(x1, x2, x3)","a954dfe9":"x = np.array([1,2,3,99,99,3,2,1])\nx1, x2, x3, x4 = np.split(x, [3,4,5])\nprint(x1, x2, x3,x4)","a832cc1f":"grid = np.arange(36,dtype=np.float).reshape((6,6))\ngrid","e70b212e":"upper, lower = np.vsplit(grid, [2])\nprint(upper)\nprint(lower)","cf3731d2":"upper,middle, lower = np.vsplit(grid, [2,3])\nprint(\"upper: \",upper)\nprint(\"middle: \",middle)\nprint(\"lower: \",lower)","f7864b55":"left, right = np.hsplit(grid, [2])\nprint(left)\nprint(right)","83ddf6e4":"left, right = np.hsplit(grid, 2)\nprint(left)\nprint(right)","7f33b833":"x = np.array([2,1,4,3,5])\nnp.sort(x)","8e2f9d53":"x.sort()\nprint(x)","9b649843":"#return indices\nx = np.array([2,1,4,3,5])\ni = np.argsort(x)\nprint(i)\n\nx[i]","2e8cd2ce":"# A useful feature of NumPy\u2019s sorting algorithms is the ability to sort along specific\n# rows or columns of a multidimensional array using the axis argument. For example:\n\nrand = np.random.RandomState(42)\nX = rand.randint(0,10,(4,6))\nprint(X)","528fae5d":"# sort each column of X\n\nnp.sort(X, axis=0)","d0e35dd8":"# sort each row of X\n\nnp.sort(X, axis=1)","8882b724":"# Note that the first three values in the resulting array are the three smallest in the\n# array, and the remaining array positions contain the remaining values. Within the\n# two partitions, the elements have arbitrary order.\n\nx = np.array([7, 2, 1, 3, 6, 5, 4])\nnp.partition(x, 3)","ea861879":"# The result is an array where the first two slots in each row contain the smallest values\n# from that row, with the remaining values filling the remaining slots.\n\nnp.partition(X, 2, axis=1)","a9b137bc":"np.partition(X, 2, axis=0)","21ab9407":"np.argpartition(X, 2, axis=1)","fdefb5c9":"np.argpartition(X, 2, axis=0)","6881e037":"# indexing one dimensional array\nimport numpy as np\n\narr = np.arange(10)\nprint(\"Array:\", arr)\n\n# get the element at index 5\nprint(\"Element:\", arr[5])\n\n#Get values in a range\nprint(\"Slice:\", arr[1:9:2])","a75560d9":"# indexing two dimensional array\narr = np.array([[1,2,3],[4,5,6],[7,8,9]])\n                 #0      #1       #2\nprint (arr)\nprint (arr[1])    # select a row\nprint (arr[2][2]) #[row], [column]\nprint (arr[0,2])  # [row, column] ","0bab1487":"# Slicing one dimensional array\narr = np.arange(10)\nprint (arr)\n\nprint (arr[0:3])\n\n# start from first index and get every 3rd elemnt\nprint (arr[1::3])","50f06c88":"# Slicing two-dimensional array\n\narr = np.array([[1, 2, 3, 4, 5],\n                [6, 7, 8, 9, 10],\n                [11,12,13,14,15]])\n\n\n# 1st row to 2nd row , all columns\nprint(arr[1:3, 1:4])\n\n# notice that the output is also a 2d array","531ca17e":"arr = np.array([[1,2,3],[4,5,6],[7,8,9]])\n\nbelow5_filter = (arr < 5)\nprint(below5_filter)\nprint(arr[below5_filter])","9bd2eebd":"# Replacing Values\nimport numpy as np\n\nvector = np.array([5, 10, 15, 20])\nprint (vector)\n\nequal_to_ten_or_five = (vector == 10) | (vector == 5)\nvector[equal_to_ten_or_five] = 50\n\nprint (vector)","a7893000":"# Delete\n# np.delete(ndarray, elements, axis)\nx = np.array([1, 2, 3, 4, 5])\n# delete the first and fifth element of x\nx = np.delete(x, [0,4])\nprint(x)\nY = np.array([[1,2,3],[4,5,6],[7,8,9]])\n# delete the first row of Y\nw = np.delete(Y, 0, axis=0)\nprint(w)\n# delete the first and last column of Y\nv = np.delete(Y, [0,2], axis=1)\nprint(v)","12002ab7":"# Append\n# np.append(ndarray, elements, axis)\n# append the integer 6 to x\nx = np.append(x, 6)\nprint(x)\n# append the integer 7 and 8 to x\nx = np.append(x, [7,8])\nprint(x)\n# append a new row containing 7,8,9 to y\nv = np.append(Y, [[10,11,12]], axis=0)\nprint(v)\n# append a new column containing 9 and 10 to y\nq = np.append(Y,[[13],[14],[15]], axis=1)\nprint(q)","80af0776":"# Insert\n# np.insert(ndarray, index, elements, axis)\n# inserts the given list of elements to ndarray right before\n# the given index along the specified axis\nx = np.array([1, 2, 5, 6, 7])\nprint('x:\\n',x)\nY = np.array([[1,2,3],[7,8,9]])\nprint('y:\\n',y)\n# insert the integer 3 and 4 between 2 and 5 in x. \nx = np.insert(x,2,[3,4])\nprint('x:\\n',x)\n# insert a row between the first and last row of Y\nw = np.insert(Y,1,[4,5,6],axis=0)\nprint('w:\\n',w)\n# insert a column full of 5s between the first and second column of Y\nv = np.insert(Y,1,5, axis=1)\nprint('v:\\n',v)","49e7522a":"# Stacking\n# NumPy also allows us to stack ndarrays on top of each other,\n# or to stack them side by side. The stacking is done using either\n# the np.vstack() function for vertical stacking, or the np.hstack()\n# function for horizontal stacking. It is important to note that in\n# order to stack ndarrays, the shape of the ndarrays must match.\nx = np.array([1,2])\nprint('x:\\n',x)\nY = np.array([[3,4],[5,6]])\nprint('y:\\n',Y)\nz = np.vstack((x,Y)) # [[1,2], [3,4], [5,6]]\nprint('z:\\n',z)\nw = np.hstack((Y,x.reshape(2,1))) # [[3,4,1], [5,6,2]]\nprint('w:\\n',w)","d95527bd":"# Copy\n# if we want to create a new ndarray that contains a copy of the\n# values in the slice we need to use the np.copy()\n# create a copy of the slice using the np.copy() function\nZ = np.copy(X[1:4,2:5])\nprint(Z)\n#  create a copy of the slice using the copy as a method\nW = X[1:4,2:5].copy()\nprint(W)","cbebdc59":"# Extract elements along the diagonal\nd0 = np.diag(X)\n# As default is k=0, which refers to the main diagonal.\n# Values of k > 0 are used to select elements in diagonals above\n# the main diagonal, and values of k < 0 are used to select elements\n# in diagonals below the main diagonal.\nd1 = np.diag(X, k=1)\nprint(d1)\nd2 = np.diag(X, k=-1)\nprint(d2)","11a69f36":"#Find Unique Elements in ndarray\nX = [1,2,3,4,5,5,6,6,6,7,8,9,9,9]\nu = np.unique(X)\nu","28d8ab33":"# Boolean Indexing\nX = np.arange(25).reshape(5, 5)\nprint('The elements in X that are greater than 10:', X[X > 10])\nprint('The elements in X that less than or equal to 7:', X[X <= 7])\nprint('The elements in X that are between 10 and 17:', X[(X > 10) & (X < 17)])\n\n# use Boolean indexing to assign the elements that\n# are between 10 and 17 the value of -1\nX[(X > 10) & (X < 17)] = -1","b1cbbb6f":"# Set Operations\nx = np.array([1,2,3,4,5])\ny = np.array([6,7,2,8,4])\nprint('The elements that are both in x and y:', np.intersect1d(x,y))\nprint('The elements that are in x that are not in y:', np.setdiff1d(x,y))\nprint('All the elements of x and y:',np.union1d(x,y))","70a170dc":"# Sorting\n# When used as a function, it doesn't change the original ndarray\ns = np.sort(x)\nprint(s)\n# When used as a method, the original array will be sorted\nx.sort()\nprint(x)\n\n# sort x but only keep the unique elements in x\ns = np.sort(np.unique(x))\n\n# sort the columns of X\ns = np.sort(X, axis = 0)\n\n# sort the rows of X\ns = np.sort(X, axis = 1)","7087f491":"#Math Functions\n# NumPy allows element-wise operations on ndarrays as well as\n# matrix operations. In order to do element-wise operations,\n# NumPy sometimes uses something called Broadcasting.\n# Broadcasting is the term used to describe how NumPy handles\n# element-wise arithmetic operations with ndarrays of different shapes.\n# For example, broadcasting is used implicitly when doing arithmetic\n# operations between scalars and ndarrays.\nx = np.array([1,2,3,4])\ny = np.array([5.5,6.5,7.5,8.5])\nprint(np.add(x,y))\nprint(np.subtract(x,y))\nprint(np.multiply(x,y))\nprint(np.divide(x,y))\n\n# in order to do these operations the shapes of the ndarrays\n# being operated on, must have the same shape or be broadcastable\nX = np.array([1,2,3,4]).reshape(2,2)\nprint(X)\nY = np.array([5.5,6.5,7.5,8.5]).reshape(2,2)\nprint(Y)\nprint(np.add(X,Y))\nprint(np.subtract(X,Y))\nprint(np.multiply(X,Y))\nprint(np.divide(X,Y))\n\n# apply mathematical functions to all elements of an ndarray at once\nprint(np.exp(x))\nprint(np.sqrt(x))\nprint(np.power(x,2))","1561a176":"# Statistical Functions\nprint('Average of all elements in X:', X.mean())\nprint('Average of all elements in the columns of X:', X.mean(axis=0))\nprint('Average of all elements in the rows of X:', X.mean(axis=1))\nprint()\nprint('Sum of all elements in X:', X.sum())\nprint('Standard Deviation of all elements in X:', X.std())\nprint('Median of all elements in X:', np.median(X))\nprint('Maximum value of all elements in X:', X.max())\nprint('Minimum value of all elements in X:', X.min())","998e058f":"# Broadcasting\n# NumPy is working behind the scenes to broadcast 3 along the ndarray\n# so that they have the same shape. This allows us to add 3 to each\n# element of X with just one line of code.\nprint(4*X)\nprint(4+X)\nprint(4-X)\nprint(4\/X)\n# NumPy is able to add 1 x 3 and 3 x 1 ndarrays to 3 x 3 ndarrays\n# by broadcasting the smaller ndarrays along the big ndarray so that\n# they have compatible shapes. In general, NumPy can do this provided\n# that the smaller ndarray can be expanded to the shape of the larger\n# ndarray in such a way that the resulting broadcast is unambiguous.\nx = np.array([1,2,3])\nY = np.array([[1,2,3],[4,5,6],[7,8,9]])\nZ = np.array([1,2,3]).reshape(3,1)\nprint(x + Y)\nprint(Z + Y)","97f6d93e":"**Sorting Arrays**\n\nFast Sorting in NumPy: np.sort and np.argsort","a29b946e":"**Practice for NumPy**","c7f986a0":"# Conclusion\n* **If you like it, please upvote   :)**\n* **If you have any question, I will be appreciate to hear it   :)**","15ef44f0":"**Understanding Data Types in Python**","67b32578":"**ndarray**\n\nThe most important object defined in NumPy is an *N-dimensional array type called ndarray*. **It describes the collection of items of the same type**. Items in the collection can be accessed using a zero-based index.\n\nEvery item in an ndarray takes the same size of block in the memory. Each element in ndarray is an object of data-type object (called dtype).Any item extracted from ndarray object (by slicing) is represented by a Python object of one of array scalar types. An instance of ndarray class can be constructed by different array creation routines described later.\n\nAt the core of NumPy is the ndarray, where nd stands for n-dimensional.\nAn ndarray is a multidimensional array of elements all of the same type.\nUnlike Python lists, all the elements of an ndarray must be of the same type. If you provide the np.array() function with a Python list that has both integers and strings, NumPy will interpret all elements as strings.\nWhen we create an ndarray with both floats and integers, NumPy assigns its elements a float64 dtype. This is called upcasting. Since all the elements of an ndarray must be of the same type, in this case NumPy upcasts the integers in z to floats in order to avoid losing precision in numerical computations.\nWe refer to 1D arrays as rank 1 arrays. In general N-Dimensional arrays have rank N. Therefore, we refer to a 2D array as a rank 2 array.\n\nYou import the function in python by calling import numpy. The basic ndarray is created using an array function in NumPy as follows \u2212","17fae98f":"**Splitting of arrays**\n\nThe opposite of concatenation is splitting, which is implemented by the functions np.split, np.hsplit, and np.vsplit. For each of these, we can pass a list of indices giving the split points:","39263bf0":"Create a matrix from the list of lists [[5.3, 10.2, 15.1], [20.4, 25.3, 30.9], [35.4, 40.1,45.6]]. Print the dtype and shape.","26a3f0f6":"**Creating copies of arrays**\n\nDespite the nice features of array views, it is sometimes useful to instead explicitly copy the data within an array or a subarray. This can be most easily done with the copy() method:","fe06bcbb":"**Compound Data Structure (dict)**","dd3d39d3":"**Sorting along rows or columns**","c8af1208":"**Data Structures**\n\nThere are two things to keep in mind for each of the data types you are using:\n\n* Are they mutable?\n\nMutability is about whether or not we can change an object once it has been created. A list can be changed so it is mutable. However, strings cannot be changed without creating a completely new object, so they are immutable.\n* Are they ordered?\n\nOrder is about whether the order of the elements in an object matters, and whether this position of an element can be used to access the element. Both strings and lists are ordered. We can use the order to access parts of a list and string.\nFor each of the upcoming data structures you see, it is useful to understand how you index, are they mutable, and are they ordered.\nAdditionally, you will see how these each have different methods, so why you would use one data structure vs. another is largely dependent on these properties, and what you can easily do with it!","fac7e6cf":"**Filters**\n\nAnything that takes in data, processes it, and provides an output\n\nInput Data \u27f6 Filter \u27f6 Output Data","651a8bf5":"**Array Slicing: Accessing Subarrays**\n\nJust as we can use square brackets to access individual array elements, we can also use them to access subarrays with the slice notation, marked by the colon (:) character.\n\nThe NumPy slicing syntax follows that of the standard Python list; to access a slice of an array x, use this:\nx[start:stop:step]\n\nIf any of these are unspecified, they default to the values start=0, stop=size of dimension, step=1. We\u2019ll take a look at accessing subarrays in one dimension and in multiple dimensions.","f47b8c02":"Using Filter\nA filter can simply be used in an indexing operation (instead of numbers or slices)","8e8f43a3":"Iterating through a dictionary","fca48aff":"**List[]**\n\nmutable, ordered sequence of elements.\n\nMix of data types.\nAre ordered - can lookup elements by index.\nAre mutable - can be changed.","2f6daa54":"**List Comprehensions - (do.. for)**\n","822f282a":"# This kernel will be updated regularly.","a27d1df6":"**Sets{}**\n\nmutable, unordered collections of unique elements.\n\nAre unordered - can not lookup elements by index.\nAre mutable - can be changed.\nSets support the in operator the same as lists do.\nOne application of a set is to quickly remove duplicates from a list.\nYou cannot have the same item twice and you cannot sort sets. For these two properties a list would be more appropriate.\nYou can add elements to sets using the add() method, and remove elements using the pop() method, similar to lists. Although, when you pop an element from a set, a random element is removed. Remember that sets, unlike lists, are unordered so there is no \"last element\".\nOther operations you can perform with sets include those of mathematical sets. Methods like union, intersection, and difference are easy to perform with sets, and are much faster than such operators with other containers.","065c1273":"***Aggregation***\n* sum(): Computes the sum of all the elements in a vector, or the sum along a dimension in a matrix.\n* mean(): Computes the average of all the elements in a vector, or the average along a dimension in a matrix.\n* max()\/min(): Identifies the maximum\/minimum value among all the elements in a vector, or along a dimension in a matrix.\n* argmax()\/argmin(): Returns the index of maximum\/minimum element.","50476ca8":"Summing the Values in an Array","4b2d2ebe":"**Identity Operator**\n\n","0e8140da":"np.concatenate can also be used for two-dimensional arrays:\n","d84bb228":"In a multidimensional array, you access items using a comma-separated tuple of indices","695dc40b":"**Rank** \n\nNumPy\u2019s main object is the homogeneous multidimensional array. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of positive integers. In NumPy dimensions are called axes. The number of axes is rank.\n\nFor example, the coordinates of a point in 3D space [1,2,3]** is an array of rank 1, because it has one axis. That axis has a length of 3.\n\nIn the example below, the array has rank 2 (it is 2-dimensional). The first dimension (axis) has a length of 6, the second dimension has a length of 6.","efc370c1":"**Introduction to NumPy**\n\nNumPy is the fundamental package for scientific computing in Python","d0a3b7ed":"**Tuples()**\n\nimmutable ordered sequences of elements.\n\nThey are often used to store related pieces of information. The parentheses are optional when defining tuples.\nAre ordered - can lookup elements by index.\nAre immutable - can not be changed. You can't add and remove items from tuples, or sort them in place.","41580812":"**Replacing Value**\n\nWe can also use comparisons to replace values in an array, based on certain conditions. The code to do the same is as shown below. The code to replacing values on certain conditions is as follows.","e012decf":"**Zeros and Ones:** \nGenerate arrays of all zeros and ones\n\n**eye:**\nCreates an identity matrix of given size. Identity matrix is one in which all the diagonal elements are 1s. Rest all of the elemnts are zeros\n\n**Linspace:**\nReturn evenly spaced numbers over a specified interval.\n\n*linspace(start, stop, num=50, endpoint=True, retstep=False)*\n* Will return num number of values\n* Equally spaced samples in the closed interval [start, stop] or the half-open interval [start, stop)\n* Closed or half-open interval depends on whether 'endpoint' is True or False.","63c5e509":"**anange**\n\narange([start,] stop[, step,][, dtype]) : Returns an array with evenly spaced elements as per the interval. The interval mentioned is half opened i.e. [Start, Stop) (similar to the Python range() function).","8b22ad53":"It creates an ndarray from any object exposing array interface, or from any method that returns an array.","d9cde46a":"**NumPy :**<br>\n**NumPy**, which stands for *Numerical Python*, is a library consisting of multidimensional array objects and a collection of routines for processing those arrays. Using NumPy, mathematical and logical operations on arrays can be performed. \n\n**Numpy** is a Linear Algebra Library for Python, the reason it is so important for *Data Science* with Python is that almost all of the libraries in the PyData Ecosystem rely on NumPy as one of their main building blocks. Numpy is also incredibly fast, as it has bindings to C libraries. We will only learn the basics of NumPy, to get started we need to install it!\nWe can install numpy by pip install numpy\n\nNumPy provides Python with an extensive math library capable of performing numerical computations effectively and efficiently.\nEven though Python lists are great on their own, NumPy has a number of key features that give it great advantages over Python lists. One such feature is speed. When performing operations on large arrays NumPy can often perform several orders of magnitude faster than Python lists. This speed comes from the nature of NumPy arrays being memory-efficient and from optimized algorithms used by NumPy for doing arithmetic, statistical, and linear algebra operations.\nAnother great feature of NumPy is that it has multidimensional array data structures that can represent vectors and matrices. Another great advantage of NumPy over Python lists is that NumPy has a large number of optimized built-in mathematical functions. These functions allow you to do a variety of complex mathematical computations very fast and with very little code (avoiding the use of complicated loops) making your programs more readable and easier to understand.\n\nIn this part, along with the basics of python, NumPy such as its architecture and environment, we shall also discuss the various array functions, types of indexing, etc.","d5082f56":"**numpy.dtype**\nThe data type or dtype describes the kind of elements that are contained within the array.\n* bool: Boolean values\n\n* int: Integer values. Can be int16, int32, or int64.\n\n* float: Floating point values. Can be float16, float32, or float64.\n\n** string**: Text. Can be string or unicode (this distinction is greatly simplified in Python 3)","83b8b811":"**Partial Sorts: Partitioning**","f4b29bd2":"**Operations with NumPy arrays**\n\n* Computation on Arrays: Broadcasting\nRules of Broadcasting\nBroadcasting in NumPy follows a strict set of rules to determine the interaction between the two arrays:\n\nRule 1: If the two arrays differ in their number of dimensions, the shape of the one with fewer dimensions is padded with ones on its leading (left) side.\n\nRule 2: If the shape of the two arrays does not match in any dimension, the array with shape equal to 1 in that dimension is stretched to match the other shape.\n\nRule 3: If in any dimension the sizes disagree and neither is equal to 1, an error is raised.\n* Vector Arithmetic\nAll operations between arrays are element-wise\nThis means that if you multiply two 2d vectors, it will NOT perform matrix multiplication\n\n* Scalar Arithmetic\nAny operation of an array with a scalar will result in element-wise computation of that operation\nFor example my_array + 2 is the same as adding 2 to each element of array\n\n* Comparison\nComparing two numpy arrays for equality, element-wise\n\n* Comparison Operators as ufuncs\nThe result of these comparison operators is always an array with a Boolean data type. All six of the standard comparison operations are available:\n\nfor example, you might wish to count all values greater than a certain value, or perhaps remove all outliers that are above some threshold. In NumPy, Boolean masking is often the most efficient way to accomplish these types of tasks.","1d99e377":"Multidimensional subarrays","cbe4493e":"**Array Indexing: **\n* Accessing Single Elements\nIf you are familiar with Python\u2019s standard list indexing, indexing in NumPy will feel quite familiar. In a one-dimensional array, you can access the ith value (counting from zero) by specifying the desired index in square brackets, just as with Python lists:","e6d13ee2":"***Random number***\nNumpy also has lots of ways to create random number arrays of given shape\n* rand:\n*numpy.random.rand(d0, d1, \u2026, dn) *\nCreate an array of the given shape and populate it with random samples from a uniform distribution\n\n* randn:\n*numpy.random.randn(d0, d1, \u2026, dn)*\ncreates an array of specified shape and fills it with random values as per standard normal distribution.\n\nIf positive arguments are provided, randn generates an array of shape (d0, d1, \u2026, dn), filled with random floats sampled from a univariate \u201cnormal\u201d (Gaussian) distribution of mean 0 and variance 1 (if any of the d_i are floats, they are first converted to integers by truncation).\n\nA single float randomly sampled from the distribution is returned if no argument is provided.\n\n* randint:\nReturn random integers from the \u201cdiscrete uniform\u201d distribution of the specified dtype in the \u201chalf-open\u201d interval [low, high). If high is None (the default), then results are from [0, low).","3dc75e15":"**Dicts{}**\n\nmutable data type that stores mappings of unique keys to values.\n\n* Are ordered - can lookup elements by key.\n* Are mutable - can be changed.\nDictionaries can have keys of any immutable type, like integers or tuples, not just strings. It's not even necessary for every key to have the same type!\nWe can look up values or insert new values in the dictionary using square brackets that enclose the key.","55cecf83":"**Array Concatenation and Splitting***","76d0289a":"One-dimensional subarrays","5a2e50ec":"**Dictionary Frequency Counter**","18c639a5":"**Indexing and Selection**\n\nBasic slicing extends Python's basic concept of slicing to N dimensions. Basic slicing occurs when obj is a :class: slice object (constructed by start:stop:step notation inside of brackets), an integer, or a tuple of slice objects and integers. :const:Ellipsis and :const:newaxis objects can be interspersed with these as well. In order to remain backward compatible with a common usage in Numeric, basic slicing is also initiated if the selection object is any non-ndarray sequence (such as a :class:list) containing :class:slice objects.\n\nLet us look at creating an array with numpy and indexing and selection follows from what we have learnt in python","e60f6cdd":"**adding conditionals (do.. for.. if)**","99a7d1fe":"Create an ndimensional array from randomly genrated numbers of shape (3,4), then rehape the array to (4,3)","0805d8bc":"Equality (==) and identity (is)"}}