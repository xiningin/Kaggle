{"cell_type":{"2e537d06":"code","c4bc6f81":"code","a82b83f4":"code","6a622fc5":"code","de0a390c":"code","8b402083":"code","8cde51df":"code","44df813b":"code","3f811ebc":"code","50149e31":"code","7957caef":"code","383c05eb":"code","118ae1a5":"code","e112f216":"code","608e9ca9":"code","858fd1f9":"code","25d766e2":"code","d3e1d89c":"code","e40adab4":"markdown","b56d2167":"markdown","912a5b8b":"markdown","0525b937":"markdown","d00d4e67":"markdown","e7ad5e33":"markdown","1203d60e":"markdown","bc3229be":"markdown","ee363131":"markdown","f42f3296":"markdown","62f1ec36":"markdown","b07fa274":"markdown","1b38c2b7":"markdown","81e27f32":"markdown","14361155":"markdown","e7fbb804":"markdown","5f55f75c":"markdown","2bdea384":"markdown","94ff82ad":"markdown"},"source":{"2e537d06":"import numpy  as np\nimport pandas as pd\n\nimport math\nimport time\n\nfrom collections import Counter\nfrom IPython.display import HTML","c4bc6f81":"ciphers_df = pd.read_csv('..\/input\/test.csv')\nciphers_df = ciphers_df.query(\"difficulty==1\")\nciphers_df['length'] = ciphers_df['ciphertext'].apply(lambda x: len(x))\nciphers_df.head()","a82b83f4":"plaintext_df = pd.read_csv(\"..\/input\/training.csv\", index_col='index')\nplaintext_df['length'] = plaintext_df['text'].apply(lambda x: len(x))\nplaintext_df['padded_length'] = (np.ceil(plaintext_df['length'] \/ 100) * 100).astype(int)\nplaintext_df.head()","6a622fc5":"plaintext_corpus = ''.join(list(plaintext_df['text']))\nciphrtext_corpus = ''.join(list(ciphers_df['ciphertext']))","de0a390c":"def count_characters(text):\n    counter = Counter(text)\n    df = pd.DataFrame(list(counter.items()), columns=['Character', 'Count'])\n    df['Percent'] = df['Count'] \/ df['Count'].sum()\n    df_sorted = df.sort_values(by='Count', ascending=False)\n    return df_sorted","8b402083":"def display_counts(plain_counts, ciphr_counts, n=5):\n    plain_html = wrap_html(\"PlainText\", plain_counts, n)\n    ciphr_html = wrap_html(\"Cipher\",    ciphr_counts, n)\n    display(HTML(plain_html + ciphr_html))\n\ndef wrap_html(name, df, n):\n    return \\\n        \"<div style='float: left; padding: 10px;'>\" + \\\n            \"<h3>\" + name + \"<\/h3>\" + \\\n            df[:n].to_html() + \\\n            \"...\" + \\\n            df[-n:].to_html() + \\\n            str(df.shape) + \\\n        \"<\/div>\"","8cde51df":"plaintext_counts = count_characters(plaintext_corpus)\nciphrtext_counts = count_characters(ciphrtext_corpus)\n\ndisplay_counts(plaintext_counts, ciphrtext_counts)","44df813b":"class SubstitutionCipher:\n    def __init__(self, plain_alphabet, ciphr_alphabet):\n        self.decrypt_mapping = {}\n        self.encrypt_mapping = {}\n        \n        for p, c in zip(plain_alphabet, ciphr_alphabet):\n            self.update(p, c)\n\n    def update(self, p, c):\n        self.decrypt_mapping[c] = p\n        self.encrypt_mapping[p] = c\n\n    def encrypt(self, text):\n        return self.substitute(text, self.encrypt_mapping)\n    \n    def decrypt(self, text):\n        return self.substitute(text, self.decrypt_mapping)\n    \n    def substitute(self, text, mapping):\n        result = [\n            mapping[c]\n            for c in list(text)\n        ]\n        return ''.join(result)","3f811ebc":"substitution = SubstitutionCipher(plaintext_counts['Character'], ciphrtext_counts['Character'])\nsubstitution.decrypt(ciphers_df.iloc[2]['ciphertext'])","50149e31":"alphabet_per_cipher = [ set(text) for text in list(ciphers_df['ciphertext'].str[50:-50])]\ncharacter_presence  = pd.DataFrame([\n    {\n        c: c in alphabet\n        for c in ciphrtext_counts['Character'].values\n    }\n    for alphabet in alphabet_per_cipher\n], index=ciphers_df.index)\ncharacter_presence.head()","7957caef":"character_presence.any().all()","383c05eb":"subset_indexes = [2]\n\nwhile not character_presence.loc[subset_indexes].any().all():\n    ant = character_presence.loc[subset_indexes].any()\n    unfound_characters = ant[ant == False]\n    unfound_character  = unfound_characters.index[0]\n    found_here = character_presence[character_presence[unfound_character]].index[0]\n    subset_indexes.append(found_here)\n\ndisplay(len(subset_indexes))\ndisplay(subset_indexes)","118ae1a5":"def analyze(decrypted, plaintext):\n    corrects = []\n    mistakes = {}\n\n    for d,p in zip(decrypted, plaintext):\n        if d == p:\n            corrects.append(d)\n        else:\n            mistakes[d] = p\n    \n    return set(corrects), mistakes, len(corrects) \/ len(plaintext)\n\n\nPRINT_LENGTH = 100\nall_corrects = set()\nall_mistakes = {}\n\nfor cipher_index, cipher_row in ciphers_df.loc[subset_indexes].iterrows():\n    decrypted = substitution.decrypt(cipher_row['ciphertext'])\n\n    plaintext_candidates = plaintext_df.query(f\"padded_length=={cipher_row['length']}\")\n    for plaintext_index, plaintext_row in plaintext_candidates.iterrows():\n        # work around the padding\n        padding_left_length = math.floor((plaintext_row['padded_length'] - plaintext_row['length']) \/ 2)\n        unpadded_decrypted_text = decrypted[padding_left_length:]\n\n        corrects, mistakes, score = analyze(unpadded_decrypted_text, plaintext_row['text'])\n\n        if score >= 0.9:\n            match = (cipher_index, plaintext_index)\n\n            all_corrects.update(corrects)\n            all_mistakes.update(mistakes)\n\n            print(f\"Score: {score}\")\n            print(cipher_row['ciphertext'][padding_left_length:padding_left_length+PRINT_LENGTH])\n            print(unpadded_decrypted_text[:PRINT_LENGTH])\n            print(plaintext_row['text'][:PRINT_LENGTH])\n            print(f\"---\")\n            print(f\"CorrectsVerified:{len(all_corrects)}; MistakesNoted:{len(all_mistakes)}\")\n            print(f\"TotalCharactersAccountedFor: {len(all_corrects) + len(all_mistakes)} out of 85\")\n            print()","e112f216":"mistakes = [\n    (correct_plaintext, substitution.encrypt(wrong_plaintext))\n    for wrong_plaintext, correct_plaintext in all_mistakes.items()\n]\n\nfor correct_plaintext, cipher_character in mistakes:\n    substitution.update(correct_plaintext, cipher_character)","608e9ca9":"matches = []\n\nfor cipher_index, cipher_row in ciphers_df.iterrows():\n    decrypted = substitution.decrypt(cipher_row['ciphertext'])\n    match = None\n    \n    plaintext_candidates = plaintext_df.query(f\"padded_length=={cipher_row['length']}\")\n    for plaintext_index, plaintext_row in plaintext_candidates.iterrows():\n        if plaintext_row['text'] in decrypted:\n            match = (cipher_row['ciphertext_id'], plaintext_index)\n\n    if match is None:\n        print(f\"No match found for {cipher_index}!\")\n    else:\n        matches.append(match)\n\nmatches = pd.DataFrame(matches, columns=['ciphertext_id', 'index'])\nmatches.head()","858fd1f9":"sub = pd.read_csv('..\/input\/sample_submission.csv')\nsub['index'] = -1 # totally not necessary but i don't want to get the 0-index right for the wrong reason\nsub_higher_difficulty = sub[~sub['ciphertext_id'].isin(matches['ciphertext_id'])]\n\nsub = pd.concat([matches, sub_higher_difficulty])\nsub.to_csv('submission_diff1.csv', index=False)\nsub.head()","25d766e2":"len(ciphers_df) \/ len(plaintext_df)","d3e1d89c":"plaintext_df['encrypt1'] = plaintext_df['text'].apply(lambda text: substitution.encrypt(text))\nplaintext_df.to_csv('plaintext_encrypt1.csv')\nplaintext_df.head()","e40adab4":"Perfect. Everything was found.","b56d2167":"## Substitution Cipher","912a5b8b":"Confirm that all characters are found:","0525b937":"### Now we correct them\n\nCorrecting our substitution mapping is trivial:","d00d4e67":"## Perfecting the substitution\n\nThe idea is to get a subset of cipher texts that contains all the cipher characters. Matching these to their plaintext should be easy with our current substitution mapping; we'll just look for matches with >90% accuracy. We'll also visually confirm that they are indeed correct matches.\n\nOnce we have that, we can now easily note which characters we have a correct substitution for and which characters we got wrong - and what its correct plain text should be.","e7ad5e33":"## Create submission","1203d60e":"Let's try decrypting one of the ciphers:","bc3229be":"This should get us a score of:","ee363131":"Awesome. They're almost an exact match save for a few characters and we've recorded exactly which characters are wrong.","f42f3296":"Below is an algorithm to quickly obtain a small subset of ciphers that contain all of the cipher characters.\n\nIt starts with including the cipher index#2, this decision is arbitrary. It then loops as long as all characters have not yet been represented, each time adding a cipher containing a previously unrepresented character.","62f1ec36":"Now we can match all ciphers to their plaintext without requiring the arbitrary 90% accuracy threshold.\n\nNote that this takes about an hour! Decrypting is fast but matching takes way too long because of the padding. ","b07fa274":"### Match these ciphers with their plaintext","1b38c2b7":"## The Data","81e27f32":"### Get a subset of ciphers\n\nFirst, we get a small subset of ciphers that contains all the characters. These characters must not be in the padding since we'd have no way to confirm if those are accurate. This is very tricky as we can't tell the padding length from the cipher text alone. So, we just assume 50 on both sides to be safe.\n\nLet's create a dataframe that records whether each cipher character appears in each cipher text:","14361155":"Excellent! We're on the right track.","e7fbb804":"This notebook is based on https:\/\/www.kaggle.com\/group16\/cracking-the-code-difficulty-1.\n\nHere, I present an algorithm for acquiring the perfect substitution instead of doing tedious manual correction.","5f55f75c":"## Frequency Analysis","2bdea384":"## Add 1st level encryption to plaintext \n\nFor use in the next level","94ff82ad":"Looks like a straightforward substitution cipher. We can already see a promising mapping:"}}