{"cell_type":{"cc37bb50":"code","d4922bba":"code","8a730542":"code","e716f0c6":"code","c061ac6c":"code","9eb0ba13":"code","81d91bc3":"code","f723b1b0":"code","d71131ad":"code","5dddc161":"code","cf480b01":"code","7b91b556":"code","4fe4004f":"code","904dc37b":"code","ce40f235":"code","418964ec":"code","9726ad42":"code","e97af674":"code","795d3fda":"code","004f4e2d":"code","b2d04de8":"code","5b29103b":"code","7797d9f5":"code","f60de9aa":"code","18724c4b":"code","e93e206e":"markdown","9915a867":"markdown","3c3e59af":"markdown","6c95b64b":"markdown","95c67584":"markdown","88d6552c":"markdown","e363e74d":"markdown","14e7206d":"markdown","db8f4221":"markdown","d7ef5217":"markdown","083cea2f":"markdown","9b325083":"markdown"},"source":{"cc37bb50":"# General Libraries\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# sklearn libraries\nfrom sklearn.model_selection import KFold, train_test_split\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn import preprocessing\nfrom sklearn.metrics import accuracy_score, confusion_matrix\nfrom xgboost import XGBClassifier\n\n# for plotting graph in jupyter cell\n%matplotlib inline","d4922bba":"df = pd.read_csv(\"..\/input\/datasetfraud\/PS_20174392719_1491204439457_log.csv\")","8a730542":"# check the data set (first 10 rows)\ndf.head(10)","e716f0c6":"# Check the shaoe of the data\nprint(\"Shape of Data :-\")\nprint(f\"Number of Rows : {df.shape[0]}\")\nprint(f\"Number of Columns : {df.shape[1]}\")","c061ac6c":"# Look for missing values\ndf.isnull().sum()","9eb0ba13":"# Find the number of fraud transaction happens each hour\n\n# in this function we returnig a list\n# of \n# 1. houre, 2. no. of transactions happend in that houre, 3. no. fraud transaction happened in that houre\n# 4. no. of valid transactions happened in that houre\ndef fraud_per_houre(df):\n    l1, l2, l3, l4 = [], [], [], []\n    \n    for h in df[\"step\"].unique():\n        t_df = df.loc[df[\"step\"] == h]\n        l1.append(h)\n        l2.append(t_df.shape[0])\n        l3.append(t_df.loc[t_df[\"isFraud\"] == 1].shape[0])\n        l4.append(t_df.loc[t_df[\"isFraud\"] == 0].shape[0])\n        \n    return (l1, l2, l3, l4)\n\n# getting generated list of Data\nl1, l2, l3, l4 = fraud_per_houre(df)\n\n# Create a new DataFrame\nfraud_tx_per_houre = pd.DataFrame()\n\n# Add new Columns to the DataFrame\nfraud_tx_per_houre[\"houre\"] = l1\nfraud_tx_per_houre[\"total_tx\"] = l2\nfraud_tx_per_houre[\"fraud_tx\"] = l3\nfraud_tx_per_houre[\"valid_tx\"] = l4","81d91bc3":"# Look for new dataFrame\nfraud_tx_per_houre","f723b1b0":"# Visualizing the fraud transaction happened per houre\nplt.figure(figsize=(12, 150))\nsns.barplot(y=\"houre\", x=\"fraud_tx\", orient=\"h\", data=fraud_tx_per_houre)","d71131ad":"# general statistics for fraud \nfraud_tx_per_houre[\"fraud_tx\"].describe()","5dddc161":"# Finding Fraud transaction happend each day\n\n# Add new \"day\" Columns to fraud_tx_per_houre\ndef get_day_data(df):\n    day = []\n    val = 1\n    for i in df[\"houre\"]:\n        day.append(val)\n        if i % 24 == 0:\n            val += 1\n    return day\n\nday = get_day_data(fraud_tx_per_houre)\n\nfraud_tx_per_houre[\"day\"] = day","cf480b01":"fraud_tx_per_houre","7b91b556":"# Function to plot the graph for per day with (total_tx, fraud_tx, valid_tx)\ndef plot_tx_per_day(df, day_num):\n    fig, axes = plt.subplots(3, 1, figsize=(10, 20))\n    axes[0].set_title(f\"day - {day_num}\")\n    sns.barplot(x=\"houre\", y=\"total_tx\", data=df, ax=axes[0])\n    sns.barplot(x=\"houre\", y=\"fraud_tx\", data=df, ax=axes[1])\n    sns.barplot(x=\"houre\", y=\"valid_tx\", data=df, ax=axes[2])\n    \nd1 = fraud_tx_per_houre.loc[fraud_tx_per_houre[\"day\"] == 1]\nplot_tx_per_day(d1, 1)\n\n\n## if you want see all day data uncomment following code\n# for day in range(1, 32):\n#     day_df = fraud_tx_per_houre.loc[fraud_tx_per_houre[\"day\"] == day]\n#     plot_tx_per_day(day_df, day)","4fe4004f":"# check how much fraud happed with payment methods\n\ndef payment_m_fraud(df):\n    l1, l2, l3 = [], [], []\n    for p_type in df[\"type\"].unique():\n        t_df = df.loc[df[\"type\"] == p_type]\n        l1.append(p_type)\n        l2.append(t_df.shape[0])\n        l3.append(t_df.loc[t_df[\"isFraud\"] == 1].shape[0])\n    return (l1, l2, l3)\n\nl1, l2, l3 = payment_m_fraud(df)\n    \npf_df = pd.DataFrame()\npf_df[\"type\"] = l1\npf_df[\"total\"] = l2\npf_df[\"total_fraud\"] = l3","904dc37b":"pf_df","ce40f235":"# look at the valid transaction\nvalid_tx = df.loc[df[\"isFraud\"] == 0, [\"amount\", \"type\", \"oldbalanceOrg\", \"newbalanceOrig\", \"oldbalanceDest\", \"newbalanceDest\", \"isFlaggedFraud\"]]\nprint(f\"Total Transaction : {valid_tx.shape[0]}\")\nvalid_tx[:50]","418964ec":"# look at the fraud transaction\nfraud_tx = df.loc[(df[\"isFraud\"] == 1), [\"amount\", \"type\", \"oldbalanceOrg\", \"newbalanceOrig\", \"oldbalanceDest\", \"newbalanceDest\", \"isFlaggedFraud\"]]\nprint(f\"Total Transaction : {fraud_tx.shape[0]}\")\nfraud_tx[:50]","9726ad42":"# Look for the transaction that is fraud and also Flaged as Fraud\nfraud_tx = df.loc[((df[\"isFraud\"] == 1) & (df[\"isFlaggedFraud\"] == 1)), [\"amount\", \"type\", \"oldbalanceOrg\", \"newbalanceOrig\", \"oldbalanceDest\", \"newbalanceDest\"]]\nprint(f\"Total Transaction : {fraud_tx.shape[0]}\")\nfraud_tx[:50]","e97af674":"## Add new Feature to dataset (day)\n# create new dict with key as \"houre\" and values as \"day\"\nd = {}\n\nfor i, j in zip(fraud_tx_per_houre[\"houre\"], fraud_tx_per_houre[\"day\"]):\n    d[i] = j\n\n# generate a list with same size of dataset\ndays = [d[x] for x in df[\"step\"]]\n\n# create new columns in dataset\ndf[\"day\"] = days","795d3fda":"df.head()","004f4e2d":"# make the new \"kfold\" columns in train_df and set all values to -1 \ndf[\"kfold\"] = -1\n\n# initialize the kfold \nkf = KFold(n_splits=5, shuffle=True, random_state=42)\n\n# with help of KFold we going to generate the train and valid indicies\n# and assign the fold vaues for kfold feature in valid_indicies\nfor fold, (train_indicies, valid_indicies) in enumerate(kf.split(X=df)):\n    df.loc[valid_indicies, \"kfold\"] = fold\n    \n# save into csv \ndf.to_csv(\"fraud_5_fold.csv\", index=False)","b2d04de8":"df.kfold.value_counts()","5b29103b":"# load new 5 fold data\ntrain_df = pd.read_csv(\".\/fraud_5_fold.csv\")","7797d9f5":"usefull_cols = (train_df\n               .drop([\"isFraud\", \"isFlaggedFraud\", \"kfold\"], axis=1)\n               .columns\n               .to_list()\n               )\nprint(usefull_cols)","f60de9aa":"# RandomForestClassifier takes too much time run\n\n# score = []\n# for fold in range(5):\n#     xtrain = train_df[train_df.kfold != fold].reset_index(drop=True)\n#     xvalid = train_df[train_df.kfold == fold].reset_index(drop=True)\n    \n#     ytrain = xtrain.isFraud\n#     yvalid = xvalid.isFraud\n    \n#     object_cols = xtrain.select_dtypes(include=[\"object\"]).columns.to_list()\n    \n#     enc = preprocessing.OrdinalEncoder()\n#     xtrain[object_cols] = enc.fit_transform(xtrain[object_cols])\n#     xvalid[object_cols] = enc.fit_transform(xvalid[object_cols])\n\n#     xtrain = xtrain[usefull_cols]\n#     xvalid = xvalid[usefull_cols]\n\n#     rf = RandomForestClassifier()\n#     rf.fit(xtrain, ytrain)\n#     ypred = rf.predict(xvalid)\n    \n#     acc = accuracy_score(yvalid, ypred)\n#     score.append(acc)\n#     print(f\"fold : {fold}, Accuracy : {acc}\")\n    \n# print(f\"Overall Score : {np.mean(score)}\")","18724c4b":"score = []\nfor fold in range(5):\n    xtrain = df[df.kfold != fold].reset_index(drop=True)\n    xvalid = df[df.kfold == fold].reset_index(drop=True)\n    \n    ytrain = xtrain.isFraud\n    yvalid = xvalid.isFraud\n    \n    object_cols = xtrain.select_dtypes(include=[\"object\"]).columns.to_list()\n    \n    enc = preprocessing.OrdinalEncoder()\n    xtrain[object_cols] = enc.fit_transform(xtrain[object_cols])\n    xvalid[object_cols] = enc.fit_transform(xvalid[object_cols])\n    \n    \n    xtrain = xtrain[usefull_cols]\n    xvalid = xvalid[usefull_cols]\n    \n    xgb = XGBClassifier(tree_method=\"gpu_hist\", gpu_id=0, predictor=\"gpu_predictor\", eval_metric=\"error\", use_label_encoder=False)\n    xgb.fit(xtrain, ytrain)\n    ypred = xgb.predict(xvalid)\n\n    acc = accuracy_score(yvalid, ypred)\n    score.append(acc)\n    print(f\"fold : {fold}, Accuracy : {acc}\")\n    \nprint(f\"Overall Score : {np.mean(score)}\")","e93e206e":"In this case may be the payment method(type) will give us attension\n1. if the payment type is TRANSFER check the old account get deducted and new account get credited.\n2. if the payment type is CASH_OUT check the old account get deducted.","9915a867":"#### What are the key factors that predict fraudulent customer?","3c3e59af":"## ---------------------------------------------------------------------------------------------------------------------------------------------","6c95b64b":"This are all TRANSFER type payment \n1. the amount of transfer get transfered to the new account but not deducted from old account","95c67584":"## Create 5 Fold data","88d6552c":"at 212 houre the maximum fraud happed (that is 40)","e363e74d":"## Random Forest","14e7206d":"## XGBoost Classifier (with default setting)","db8f4221":"Looks like there is no missing value in dataset","d7ef5217":"## Exploratory Data Analysis","083cea2f":"## Load Data","9b325083":"Most of the fraud happen in \"TRANSFER\" and \"CASH_OUT\" payment type"}}