{"cell_type":{"ea9c31af":"code","6733bb9b":"code","e2e5ee17":"code","ab5f12be":"code","de2aa02b":"code","a07af48f":"code","1c9e1695":"markdown","f8ebfa8d":"markdown","fda0ad1f":"markdown","308a7f14":"markdown","6943ccfd":"markdown","9de1a524":"markdown"},"source":{"ea9c31af":"# run me first!\n# import the necessary packages\n# You don't need to change any of this, but feel free to read it\nimport cv2          # we need OpenCV\nimport numpy as np  # and Numpy\nfrom matplotlib import pyplot as plt  # for showing images\nimport pandas as pd\nimport requests  # for loading the images\nimport random    # for random pixel values\n\n# utility function for loading an image from any URL\ndef load_image_from_url(url: str):\n    r = requests.get(url)\n    image = np.asarray(bytearray(r.content), dtype=\"uint8\")\n    image = cv.imdecode(image, cv.IMREAD_COLOR)\n    return image\n\n# utility function to display an image\ndef show_image(img):\n    plt.figure(figsize=(6*img.shape[1] \/ img.shape[0], 6))\n    plt.axis('off')\n    if np.ndim(img) == 2:\n        if img.dtype == np.uint8:\n            plt.imshow(img, cmap='gray', vmin=0, vmax=255)\n        else:\n            plt.imshow(img, cmap='gray', vmin=0, vmax=1)\n    else:\n        plt.imshow(img[:,:,::-1])","6733bb9b":"# read an image\n# Extension: can you use load_image_from_url to load another image from an arbitrary URL of your choice?\nimg = cv2.imread(\"..\/input\/images\/king_fisher_2.png\")\n\n# TODO: replace this, using    img_gr = cv2.cvtColor(img, cv2.______)    # for ______ figure out which conversion gives you a greyscale image\nimg_gr = img \n\n# show images\nshow_image(img)\nshow_image(img_gr)","e2e5ee17":"img1 = cv2.imread(\"..\/input\/images\/king_fisher_2.png\")\ngr1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)\n\n# TODO: either using a loop or with cv2.threshold, make sure that gr1 contains\n# only 0s and 1s\n\nshow_image(gr1)","ab5f12be":"img = cv2.cvtColor(cv2.imread(\"..\/input\/images\/mushroom.png\"), cv2.COLOR_BGR2GRAY)\nimg_for_canny = np.uint8(img * 255)  # Canny wants an unsigned Byte image, no floats\n\n# TODO: use cv2.Canny on the uint8 image. Experiment with the parameters (.,.,140, 150) might be a good starting point \nimg_canny = np.zeros_like(img)\n\nshow_image(np.concatenate((img, img_canny), 1))","de2aa02b":"# TODO: use either Lenna or Luke picture instead. Mushrooms don't have faces :)\nimg = cv2.imread(\"..\/input\/images\/Lenna.png\")\n\n# TODO: turn that image to be greyscale\ngreyscale = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n# TODO: create a CascadeClassifier using `path`, then use its detectMultiScale method\n# on the image to populate the faces list\nface_cascade = cv2.CascadeClassifier(\"..\/input\/haar-cascades-for-face-detection\/haarcascade_frontalface_default.xml\")\n\n# TODO: complete this line. For sensitivity, try a few values (from 1 to 1000). What happens with low values? What happens with high values?\nfaces = face_cascade.detectMultiScale(____name_of_greyscale_image_____, 1.1, _____sensitivity_parameter)   \n\n# visualise faces\nfor (x, y, w, h) in faces:\n    cv2.rectangle(img, (x, y), (x+w, y+h), (255, 0, 0), 2)\n\n# Extension: can you also find the eyes using haarcascade_eye.xml?\n    \n# display the output\nshow_image(img)","a07af48f":"img = cv2.imread(\"..\/input\/images\/LukeTLJ.png\")\ngr = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n# laplacian is the kernel that we want to use for edge detection\nlaplacian = np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]])\nprint(laplacian)\n\n# for each scale. \n# TODO: let's use 5 levels instead\nfor i in range(2):\n    # sigma determines how strong the blurring will be\n    # don't change these magic numbers yet\n    sigma = 0.01 + (2 ** i) * 0.3  \n    \n    # TODO:\n    # apply the laplacian and the Gaussian to the image\n    # for Gaussian blur, you might want to use cv.GaussianBlur(..., (0, 0), sigma);\n    # you can apply the laplacian kernel using cv.filter2D \n    # try applying these in different orders\n    img2 = np.zeros_like(gr)\n    show_image(np.abs(img2) * 4**i)","1c9e1695":"## Edges\nIn this exercise, you will use OpenCV's built-in *Canny* edge detector. Note how this has a few magic numbers you need to experiment with.\n\nDocs: https:\/\/docs.opencv.org\/master\/da\/d22\/tutorial_py_canny.html","f8ebfa8d":"## Thresholds\nOnce we have a greyscale image, we might want to threshol it to a binary (black\/white) image. Let's say that every pixel less than 0.5 should be black (0), otherwise it should be white (1).\n\nWrite a nested loop to achieve this, or take a look at OpenCV's `cv2.threshold` function. ","fda0ad1f":"## Faces\nThresholding and edge detection highlights low-level features.\nOne popular approch to detect faces is the use of Viola-Jones face detection (https:\/\/en.wikipedia.org\/wiki\/Viola%E2%80%93Jones_object_detection_framework). You can think of this as filtering with a *cascade* of kernels, looking for faces at every poing of the image.\n\nOpenCV has a simple implementation through the CascadeClassifier class, which inputs the path to an xml file which contains the cascade features. We use pnslib to locate the xml file.\n\nReference source: https:\/\/opencv-python-tutroals.readthedocs.io\/en\/latest\/py_tutorials\/py_objdetect\/py_face_detection\/py_face_detection.html\n\nNow complete the code below to find the face(s) in the image. You can also use `load_image_from_url` to use another image of your choice","308a7f14":"# Images using OpenCV (part 2)\nThe following exercises will help you get some hands-on experience with images (bitmaps) using the duly popular Open Computer Vision (OpenCV) library.\n\nOpenCV doesn't use Pandas to store its pixels, instead it relies on a similarly convenient library called Numpy (np).\n\nFor documentation, take a look here:\nOpenCV: https:\/\/docs.opencv.org\/4.1.2\/\n\nThis notebook walks you through feature detection including low-level features such as edges, and high-level features such as faces","6943ccfd":"## To greyscale\nWhile colour images look great, sometimes they contain too much information for our algorithms to process. Imagine for instance, if you are looking for edges in an image; perhaps the colour of each pixel is less important, the brightness of each pixel is what really matters.\n\nAs you have seen, colour bitmaps are stored as 3D `np` arrays, with a shape of (height, width, 3), where 3 indicated that we want 3 colour channels (blue, green, red). However, for greyscale images, we only really need a 2D array (height, width)!\n\nAmend the code below using the documentation below to convert your colour image to greyscale\nhttps:\/\/docs.opencv.org\/4.1.2\/d8\/d01\/group__imgproc__color__conversions.html","9de1a524":"## Extension\nSee if you can complete this code to look for edges of *different scale*"}}