{"cell_type":{"bf07d3e0":"code","e78d5f45":"code","9fa7c2de":"code","5c1e42da":"code","6bb66efe":"code","5dfe4490":"code","1596201e":"code","0c17abdb":"code","cabc470e":"code","add94d57":"code","904f5645":"code","b9013bed":"code","acf1d752":"markdown","d8908ad4":"markdown","fbb2f517":"markdown","ebdf4984":"markdown","59597e65":"markdown","62c8d226":"markdown","efc5996e":"markdown","148c8f31":"markdown"},"source":{"bf07d3e0":"# Input data files are available in the \"..\/input\/\" directory..\n\nimport numpy as np # linear algebra.\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\n# print(os.listdir(\"....\/input\"))","e78d5f45":"# Create zero and one states..\nstate_zero = np.array([[1.0],[0.0]])\nstate_one = np.array([[0.0],[1.0]])","9fa7c2de":"# Superposition\nc1 = 1.0 \/ 2**0.5\nc2 = 1.0 \/ 2**0.5\nstate_superposition = c1 * state_zero + c2 * state_one\nprint(state_superposition)","5c1e42da":"# Assembling qunatum states\nstate_three = np.kron(np.kron(state_zero, state_one), state_one)\nprint(state_three)\n\ndef multi_kron(*args):\n    ret = np.array([[1.0]])\n    for q in args:\n        ret = np.kron(ret, q)\n    return ret\n\nstate_multi = multi_kron(state_zero, state_one, state_one, \n                         state_one, state_zero, state_one)\n\nprint(state_multi)\nprint(state_multi.shape)","6bb66efe":"# Qunatum gates\ngate_H = 1.0 \/ 2**0.5 * np.array([[1, 1],\n                                  [1, -1]])\nstate_new = np.dot(gate_H, state_zero)\nprint(state_new)","5dfe4490":"gate_SWAP = np.array([[1,0,0,0],\n                      [0,0,1,0],\n                      [0,1,0,0],\n                      [0,0,0,1]])\n    \nstate_t0 = multi_kron(state_zero, state_one)\nstate_t1 = np.dot(gate_SWAP, state_t0)\nprint(state_t1)","1596201e":"gate_I = np.eye(2)\nstate_t0 = multi_kron(state_zero, state_one)\nstate_t1 = np.dot(multi_kron(gate_H, gate_I), state_t0)\nprint(state_t1)","0c17abdb":"# Prepare state\nstate = np.dot(multi_kron(gate_H, gate_H), multi_kron(state_zero, state_zero))","cabc470e":"# Projectors\nP0 = np.dot(state_zero, state_zero.T)\nP1 = np.dot(state_one, state_one.T)","add94d57":"# Probability of first qubit being in state 0\nrho = np.dot(state, state.T)\nprob0 = np.trace(np.dot(multi_kron(P0, gate_I), rho))","904f5645":"# Simulate\nif np.random.rand() < prob0:\n    ret = 0\n    state_ret = np.dot(multi_kron(P0, gate_I), state)\nelse:\n    ret = 1\n    state_ret = np.dot(multi_kron(P1, gate_I), state) ","b9013bed":"# Normalize\nfrom scipy import linalg\nstate_ret \/= linalg.norm(state_ret)\n\nprint(\"Qubit Measured: \\n {} \\n After-Measurment State: \\n {}\".format(ret, state_ret))","acf1d752":"# Quantum Computing In Python\n\n![](https:\/\/www.ias.edu\/sites\/default\/files\/styles\/grid_feature_teaser\/public\/images\/featured-thumbnails\/ideas\/dt_c120417.jpg)\n\n* This Notebook will show that we can successfully simulate simple quantum computation on classical computers. Quantum computation in its simplest form can be represented by just a bunch of vector and matrix operations. After reading this post we will be ready to code simple quantum circuit in Python.\n\n<img src=\"https:\/\/www.autodesk.com\/products\/eagle\/blog\/wp-content\/uploads\/2017\/05\/qubit.png)\" alt=\"Smiley face\" height=\"200\" width=\"300\">\n\n* The de\ufb01nition of qubit lies in the center of quantum computation theory. Before we dive into the explanation of qubit, let us recall the de\ufb01nition of classical bit. The state of classical bit can be in two states represented by column vectors:..\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-bf3537e27e958d50f7fdeb10396e6af7_l3.svg\" alt=\"Smiley face\" height=\"40\" width=\"100\">\n\n\nIn Python they can be represented by two numpy arrays:","d8908ad4":"## Assembling qubits\n\nQuantum computer built by IBM is made up of 16 qubits. How to describe a system composed of more than one qubit? The answer comes with the concept of tensor product and allows us to correctly describe a multi-particle quantum state. The tensor product between two states is denoted by symbol shown below and we can write an example of multi-qubit state as shown in the image\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-2b2475ecc276827f9d210ac1061c1391_l3.svg\" alt=\"Smiley face\" height=\"300\" width=\"400\">\n\n\nTensor product that deals with vectors and matrices is also called Kronecker product and has been implemented in Numpy. Let\u2019s build a state \\011}:","fbb2f517":"A 2\u00d72 matrix is acting on a single qubit state, 4\u00d74 matrix on 2-qubit state, and so on. To see what is the action of Hadamard gate on |0} we need to use matrix multiplication np.dot in Python:\n    \n**state_new = np.dot(gate_H, state_zero)**\n\nNotice that state_new is just a superposition state_superposition from Eq.(4):\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-b30de54cbe99c2edd232093aaa74597d_l3.svg\" alt=\"Smiley face\" height=\"250\" width=\"350\">\n\nTherefore the role of Hadamard gate is to create a superposition of states!\n\nQuantum gates can be also performed on multi-qubit states, for instance SWAP gate represented by a matrix:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-94964473b1451d7e6fb328ea9e27d825_l3.svg\" alt=\"Smiley face\" height=\"200\" width=\"200\">\n\nIt swaps two qubits so that an example state |01} is evolved into state |10}:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-2560282243561f175908098004e28cd8_l3.svg\" alt=\"Smiley face\" height=\"250\" width=\"350\">","ebdf4984":"The  state_multi  is 2^6=64 dimensional vector and the dimensionality of an assembled state grows exponentially with number of qubits in a system.  This illustrates the overwhelming di\ufb00erence between quantum and classical computers. In order to simulate 64 qubit system 2^{64}=18,446,744,073,709,551,616 complex numbers are required.","59597e65":"## Quantum Gates\n\nWe successfully created single and multi qubit states in Python. Now, we would like to find out how to perform various transformation of these states. The quantum gates are a way of qubits manipulation.\n\n![](https:\/\/cdn-images-1.medium.com\/max\/1600\/1*POeoWmy78HJDZRPgp8pVIA.png)\n\nA state enters a gate in quantum circuit and exits as another state, thus quantum gates represent time evolution of a state describing qubits and must satisfy following criteria:\n\n* **Must preserve norms i.e. norm squared probability amplitudes sum to one after application of gate,**\n* **Must be reversible i.e. evolution of each not measured quantum state must be reversible.**\n\nIt turns out that unitary matrices meet the conditions and a trivial example is just identity matrix:\n\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-2f317569ee0c99935023e17bcbe18f4e_l3.svg\" alt=\"Smiley face\" height=\"40\" width=\"100\">\n\n\nAnother example of quantum gate, this time more interesting, is Hadamard gate:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-4c69760f054bedd43c0d9446ab12b60e_l3.svg\" alt=\"Smiley face\" height=\"40\" width=\"100\">\n\n![](https:\/\/www.researchgate.net\/profile\/Francois_Impens\/publication\/3409658\/figure\/fig1\/AS:394692047982605@1471113325853\/Basic-quantum-gates-and-their-matrix-representations.png)","62c8d226":"## References\n* [IBM Builds Its Most Powerful Universal Quantum Computing Processors](https:\/\/www-03.ibm.com\/press\/us\/en\/pressrelease\/52403.wss (2017)).\n* N. S. Yanofsky and M. A. Mannucci, Quantum Computing for Computer Scientists, Cambridge University press (2008).","efc5996e":"## Measurement\n\nTo get information from quantum computer we need to perform measurement. Unfortunately (or fortunately) the universe works in such a way that a qubit after measurement collapses to state |0} or |1} with given probability corresponding to probability amplitudes. Remember parameters c_1 and c_2 from Eq.(2)?.\n\nTo simulate measurement in Python, we will need objects called projectors defined as:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-49a5e1a40c1fdd0d3ee79bdaa2e37ccb_l3.svg\" alt=\"Smiley face\" height=\"200\" width=\"300\">\n\n\nNote that {0| is just a complex conjugate of |0}. The projector P_0 applied on state |0} gives back state |0}:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-1e7766091dd65d8ec80b85050435084b_l3.svg\" alt=\"Smiley face\" height=\"200\" width=\"300\">\n\nwhereas applied on state |1} returns 0:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-a80c82656d2bc48227185146751789ef_l3.svg\" alt=\"Smiley face\" height=\"200\" width=\"300\">\n\ndue to the fact that states |0} and |1} are orthogonal, so that {0|1} vanishes. The projector P_0 applied on an arbitrary qubit state would give.:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-1bd9a6d31374b14811161594e164ed4d_l3.svg\" alt=\"Smiley face\" height=\"200\" width=\"300\">\n\nso intuitively we can say that projector P_0 has something to do with checking the fraction of |0} in an arbitrary state. Indeed, the probability that qubit i of an arbitrary multi-qubit state |psi} when measured is in state |0} can be expressed as:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-e371d387c7d662ad0e855dd5973d4644_l3.svg\" alt=\"Smiley face\" height=\"50\" width=\"130\">\n\n\nIf we measure that the qubit i is in state |0} then the system just after the measurement would be in a state:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-ce0ec8ef89f5cbe3c6bd4b63e6c5181b_l3.svg\" alt=\"Smiley face\" height=\"50\" width=\"100\">\n\nwhere the denominator is just a normalization factor thanks to which probabilities add to one.\n\nLet\u2019s assume we have prepared following state:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-5ce1e429e531db28038aa8e82611a390_l3.svg\" alt=\"Smiley face\" height=\"200\" width=\"300\">\n\nand want to simulate in Python the measurement of first qubit.","148c8f31":"* Qubit can be in superposition of two states defined in Eq.(1):\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-6b29717806a32429f6008459053b6e02_l3.svg\" alt=\"Smiley face\" height=\"100\" width=\"200\">\n\n\n* Parameters c_1 and c_2 are called probability amplitudes and are complex numbers. Their norm squares |of c_1|^2 and |c_2|^2 are probabilities that as a result of measurement of a qubit would be found in state |0} and |1}, respectively. \n* Since these are probabilities the sum of these norm squares for a given state must sum to one:\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-ab025cd81091d26c1a98a65ad958635f_l3.svg\" alt=\"Smiley face\" height=\"100\" width=\"200\">\n\n***A state in superposition:***\n\n<img src=\"http:\/\/dkopczyk.quantee.co.uk\/wp-content\/ql-cache\/quicklatex.com-e7e1a2544c21c18f7faa67ef642bc920_l3.svg\" alt=\"Smiley face\" height=\"100\" width=\"200\">"}}