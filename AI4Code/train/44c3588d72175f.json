{"cell_type":{"508af736":"code","683d2b42":"code","5b8b7627":"code","3a2178f1":"code","c1984c63":"code","a0a1ff51":"code","9db751a3":"code","3a155440":"code","80af196e":"code","f5ab9601":"code","a5cc25ce":"code","90c6bf6c":"code","91034537":"code","c0d4c8df":"code","f5342085":"code","95c25dd1":"code","08dcdc94":"code","734f9dd4":"code","c3bb1297":"code","951b47e6":"code","a63e2904":"code","f2762178":"code","fa59e9d1":"code","fff46d82":"code","f436c6ad":"code","e7b94bed":"code","b67836b3":"code","c4419859":"code","03638023":"code","9899217b":"code","33c2c511":"code","e610f689":"code","51e3329c":"code","b77f3054":"code","94c735a4":"code","80ff1eab":"code","c440891e":"code","6c791974":"code","7da8605a":"code","6a9a04cb":"code","615e444c":"code","36f8158c":"code","76288902":"code","04ec7798":"code","ab750e18":"code","bcf4d897":"code","2417a380":"code","a67f2283":"code","be1ca30f":"code","f940777e":"code","70c6b6b6":"code","caa47a5f":"code","778489ac":"code","d7489e7e":"code","d11bd1c2":"code","526d32ee":"code","f05a1c40":"code","66b068bf":"code","4c04b196":"code","4f568ae4":"code","5cc02a11":"code","59e2095e":"code","6fcd234b":"code","64878614":"code","16c6baef":"code","195a0a96":"code","e9942f5d":"code","98f66ecf":"code","55085c84":"code","baf34b0b":"code","ec57e0d2":"code","8b7796a5":"code","8ba4f350":"code","34e55436":"code","6764eced":"code","5a110ed0":"code","98a0e1df":"code","5b56e3e6":"code","e87cd627":"code","0e5d35ca":"markdown","d8803193":"markdown","1dbf95bd":"markdown","48cf4b88":"markdown","e10c1655":"markdown","3196437f":"markdown","2b9ae7fd":"markdown","cfdf149b":"markdown","a03f84f4":"markdown","c00415b9":"markdown","1f8208c7":"markdown","e4381ccf":"markdown","a3848d15":"markdown","931d4c97":"markdown","ea8eefce":"markdown","7aefefc5":"markdown","b3016142":"markdown","d092f159":"markdown","e6647026":"markdown","47795bcb":"markdown","0956cf40":"markdown"},"source":{"508af736":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns","683d2b42":"df = pd.read_csv('..\/input\/paris-housing-classification\/ParisHousingClass.csv', sep = \",\" , encoding=\"utf-8\")","5b8b7627":"df2 = df.copy()  # Making a copy of the data frame\n                 # Now, we can freely edit the copy without loss of original data","3a2178f1":"df2.head() # Taking a look at the data","c1984c63":"df2.info()\n# Checking data types and some info\n# We notice that 'category' is of object type","a0a1ff51":"sns.heatmap(df2.isnull(), cbar = False)\n# There seems to be no nulls","9db751a3":"df2.isnull().sum() # Searching for nulls\n# We can see that there are no nulls","3a155440":"df2['category'].unique()\n# We notice that there are only 2 values, so we \n# can change them manually","80af196e":"df2['category'].replace(\"Basic\", 0 , inplace = True)\ndf2['category'].replace(\"Luxury\", 1 , inplace = True)\n# Changing to numeric type","f5ab9601":"df2['category'].value_counts()\n# They have all successfully changed into 0 and 1","a5cc25ce":"df2.info()\n# All data is of numeric type","90c6bf6c":"df2.duplicated().sum()\n# Checking for duplicates\n# No duplicates found","91034537":"df2.describe()\n# Getting more insight on data","c0d4c8df":"plt.figure(figsize=(20,15))\nsns.heatmap(df2.corr(), cbar = True,annot = True, cmap='RdPu', linewidths=1, linecolor='black')\n# We notice a few key points here, which will be the main basis of our project\n# 1- category's three strongest correlations are with: hasYard, hasPool, isNewBuilt\n#    so we will check for more info about those three specifically.\n# 2- SquareMeters and Price are 100% correlated, so we should drop one of them.\n# 3- Most features are weakly correlated.","f5342085":"# Initializing some variables with colours, this makes it\n# easier in case we want to change the colour mid-project.\nbackground_color = 'lightcoral'\ngraph_color = 'mistyrose'","95c25dd1":"fig = plt.figure(figsize=(14, 6))  # the figure size\ngs = fig.add_gridspec(1, 2)        # making 2 grids (1 row, 2 columns)\ngs.update(wspace=0.3)              # Changing this would change the width of graphs, and might\n                                   # cause them to overlap each other (0.05 for example)\n\nax0 = fig.add_subplot(gs[0, 0])    # assigning a variable fo each grid\nax1 = fig.add_subplot(gs[0, 1])    # to be able to change each graph independently\n\naxes = [ax0, ax1]                  # putting them in a list, to change the graph colour easily \nfig.patch.set_facecolor(background_color) # Setting the background colours for the wall behind the graphs\n\n# Title\nax0.text(0.5, 0.5, 'Countplot of Category\\n____________',   # determining the coordinates of the title\n        horizontalalignment='center',                       \n        verticalalignment='center',                         # determining the alignment\n        fontsize=18, fontfamily='serif', fontweight='bold', color='black')\n# determining the font size, type, weight, and colour (the default colour \n# is black so we needn't have wrote it)\n\nax0.set_xticklabels([])\nax0.set_yticklabels([])\n# Setting the labels (we chose to leave them empty)\n\nax0.tick_params(left=False, bottom=False)    # Removes the marking points at the axes of a graph\nfor s in ['top', 'right', 'left', 'bottom']:\n    ax0.spines[s].set_visible(False)\n# a for loop that removes the lines enclosing a graph\n\n\n# Graph\nsns.countplot(x='category', data=df,  ax=ax1, palette='PuRd') # shows numbers of each category\nax1.grid(color='#000000', linestyle=':', axis='y', zorder=0, dashes=(1,5))\n\n# axis: whether to draw the dotted lines vertically or horizontally\n# zorder: which drawn figure gets put on top\n# dashes: the distance between dots\n\nax1.set_xlabel('category') # Setting X-label\nax1.set_ylabel('number')   # Setting Y-label\nfor s in ['top', 'right']:\n    ax1.spines[s].set_visible(False)\n# a for loop that removes the top and right lines enclosing the graph\n\n# Settings\nfor ax in axes:\n    ax.set_facecolor(graph_color)\n# Changing the colour of the graph itself, not the background","08dcdc94":"# We can see that Basic category is much more prevalent than the luxurious one\n# However, we drew a pie chart to check for percentages as well\nround(df['category'].value_counts()\/df.shape[0]*100,2).plot.pie(autopct = '%1.1f%%', colors = ['lightcoral', 'pink'])","734f9dd4":"fig = plt.figure(figsize=(16, 5))  # the figure size\ngs = fig.add_gridspec(1, 3)        # making 3 grids (1 row, 3 columns)\ngs.update(hspace=0.2, wspace=0.3)  # Changing the wspace would change the width of graphs, and might\n                                   # cause them to overlap each other (0.05 for example)\n                                   # Similarly for hspace (vertical elongation)\n\nax0 = fig.add_subplot(gs[0, 0])    # assigning a variable fo each grid\nax1 = fig.add_subplot(gs[0, 1])    # to be able to change each graph independently\nax2 = fig.add_subplot(gs[0, 2])\n\naxes = [ax0, ax1, ax2]             # putting them in a list, to change the graph colour easily \nfig.patch.set_facecolor(background_color) # Setting the background colours for the wall behind the graphs\n\n\n# Title\nax0.text(0.5, 0.5, \"Countplot of 'hasYard'\\n_________________\",  # determining the coordinates of the title\n        horizontalalignment='center',\n        verticalalignment='center',                         # determining the alignment\n        fontsize=18, fontweight='bold', fontfamily='serif')\n# determining the font size, type, weight, and colour\n\nax0.set_xticklabels([])\nax0.set_yticklabels([])\n# Setting the labels (we chose to leave them empty)\nax0.tick_params(left=False, bottom=False)    # Removes the marking points at the axes of a graph\nfor s in ['top', 'right', 'left', 'bottom']:\n    ax0.spines[s].set_visible(False)\n# a for loop that removes the lines enclosing a graph\n\n\n# Graph1\nsns.countplot(x='hasYard', data=df, ax=ax1, palette='PuRd') # shows numbers of each category\nax1.grid(color='#000000', linestyle=':', axis='y', zorder=0, dashes=(1,5))\n\n# axis: whether to draw the dotted lines vertically or horizontally\n# zorder: which drawn figure gets put on top\n# dashes: the distance between dots\n\nax1.set_xlabel('hasYard')  # Setting X-label\nax1.set_ylabel('number')   # Setting Y-label\nfor s in ['top', 'right']:\n    ax1.spines[s].set_visible(False)\n# a for loop that removes the top and right lines enclosing the graph\n\n\n# Graph2\n# Drawing the hasYard feature against the category feature\nsns.countplot(x='hasYard', data=df, hue='category', ax=ax2, palette='PuRd')\nax2.grid(color='#000000', linestyle=':', axis='y', zorder=0, dashes=(1,5))\nax2.set_xlabel('')\nax2.set_ylabel('')\nfor s in ['top', 'right']:\n    ax2.spines[s].set_visible(False)\n\n# Settings\nfor ax in axes:\n    ax.set_facecolor(graph_color)\n# Changing the colour of the graph itself, not the background","c3bb1297":"# A table showing the numbers of basic houses that have yards, and those that don't\n# and also the luxurious houses that have yards, and those that don't\npd.crosstab(df['category'], df['hasYard'], margins=True).style.background_gradient(cmap=\"Blues\")","951b47e6":"fig = plt.figure(figsize=(16, 5))  # the figure size\ngs = fig.add_gridspec(1, 3)        # making 3 grids (1 row, 3 columns)\ngs.update(hspace=0.2, wspace=0.3)  # Changing the wspace would change the width of graphs, and might\n                                   # cause them to overlap each other (0.05 for example)\n                                   # Similarly for hspace (vertical elongation)\n\nax0 = fig.add_subplot(gs[0, 0])    # assigning a variable fo each grid\nax1 = fig.add_subplot(gs[0, 1])    # to be able to change each graph independently\nax2 = fig.add_subplot(gs[0, 2])\n\naxes = [ax0, ax1, ax2]             # putting them in a list, to change the graph colour easily \nfig.patch.set_facecolor(background_color) # Setting the background colours for the wall behind the graphs\n\n\n# Title\nax0.text(0.5, 0.5, \"Countplot of 'hasPool'\\n_________________\",  # determining the coordinates of the title\n        horizontalalignment='center',\n        verticalalignment='center',                         # determining the alignment\n        fontsize=18, fontweight='bold', fontfamily='serif')\n# determining the font size, type, weight, and colour\n\nax0.set_xticklabels([])\nax0.set_yticklabels([])\n# Setting the labels (we chose to leave them empty)\nax0.tick_params(left=False, bottom=False)    # Removes the marking points at the axes of a graph\nfor s in ['top', 'right', 'left', 'bottom']:\n    ax0.spines[s].set_visible(False)\n# a for loop that removes the lines enclosing a graph\n\n\n# Graph1\nsns.countplot(x='hasPool', data=df, ax=ax1, palette='PuRd') # shows numbers of each category\nax1.grid(color='#000000', linestyle=':', axis='y', zorder=0, dashes=(1,5))\n\n# axis: whether to draw the dotted lines vertically or horizontally\n# zorder: which drawn figure gets put on top\n# dashes: the distance between dots\n\nax1.set_xlabel('hasPool')  # Setting X-label\nax1.set_ylabel('number')   # Setting Y-label\nfor s in ['top', 'right']:\n    ax1.spines[s].set_visible(False)\n# a for loop that removes the top and right lines enclosing the graph\n\n\n# Graph2\n# Drawing the hasYard feature against the category feature\nsns.countplot(x='hasPool', data=df, hue='category', ax=ax2, palette='PuRd')\nax2.grid(color='#000000', linestyle=':', axis='y', zorder=0, dashes=(1,5))\nax2.set_xlabel('')\nax2.set_ylabel('')\nfor s in ['top', 'right']:\n    ax2.spines[s].set_visible(False)\n\n# Settings\nfor ax in axes:\n    ax.set_facecolor(graph_color)\n# Changing the colour of the graph itself, not the background","a63e2904":"# A table showing the numbers of basic houses that have pools, and those that don't\n# and also the luxurious houses that have pool, and those that don't\npd.crosstab(df['category'], df['hasPool'], margins=True).style.background_gradient(cmap=\"Blues\")","f2762178":"fig = plt.figure(figsize=(16, 5))  # the figure size\ngs = fig.add_gridspec(1, 3)        # making 3 grids (1 row, 3 columns)\ngs.update(hspace=0.2, wspace=0.3)  # Changing the wspace would change the width of graphs, and might\n                                   # cause them to overlap each other (0.05 for example)\n                                   # Similarly for hspace (vertical elongation)\n\nax0 = fig.add_subplot(gs[0, 0])    # assigning a variable fo each grid\nax1 = fig.add_subplot(gs[0, 1])    # to be able to change each graph independently\nax2 = fig.add_subplot(gs[0, 2])\n\naxes = [ax0, ax1, ax2]             # putting them in a list, to change the graph colour easily \nfig.patch.set_facecolor(background_color) # Setting the background colours for the wall behind the graphs\n\n\n# Title\nax0.text(0.5, 0.5, \"Countplot of 'isNewBuilt'\\n_________________\",  # determining the coordinates of the title\n        horizontalalignment='center',\n        verticalalignment='center',                         # determining the alignment\n        fontsize=17, fontweight='bold', fontfamily='serif')\n# determining the font size, type, weight, and colour\n\nax0.set_xticklabels([])\nax0.set_yticklabels([])\n# Setting the labels (we chose to leave them empty)\nax0.tick_params(left=False, bottom=False)    # Removes the marking points at the axes of a graph\nfor s in ['top', 'right', 'left', 'bottom']:\n    ax0.spines[s].set_visible(False)\n# a for loop that removes the lines enclosing a graph\n\n\n# Graph1\nsns.countplot(x='isNewBuilt', data=df, ax=ax1, palette='PuRd') # shows numbers of each category\nax1.grid(color='#000000', linestyle=':', axis='y', zorder=0, dashes=(1,5))\n\n# axis: whether to draw the dotted lines vertically or horizontally\n# zorder: which drawn figure gets put on top\n# dashes: the distance between dots\n\nax1.set_xlabel('isNewBuilt')  # Setting X-label\nax1.set_ylabel('number')   # Setting Y-label\nfor s in ['top', 'right']:\n    ax1.spines[s].set_visible(False)\n# a for loop that removes the top and right lines enclosing the graph\n\n\n# Graph2\n# Drawing the hasYard feature against the category feature\nsns.countplot(x='isNewBuilt', data=df, hue='category', ax=ax2, palette='PuRd')\nax2.grid(color='#000000', linestyle=':', axis='y', zorder=0, dashes=(1,5))\nax2.set_xlabel('')\nax2.set_ylabel('')\nfor s in ['top', 'right']:\n    ax2.spines[s].set_visible(False)\n\n# Settings\nfor ax in axes:\n    ax.set_facecolor(graph_color)\n# Changing the colour of the graph itself, not the background","fa59e9d1":"# A table showing the numbers of basic houses that are newly built, and those that aren't\n# and also the luxurious houses that are newly built, and those that aren't\npd.crosstab(df['category'], df['isNewBuilt'], margins=True).style.background_gradient(cmap=\"Blues\")","fff46d82":"fig = plt.figure(figsize=(16, 5))  # the figure size\ngs = fig.add_gridspec(1, 3)        # making 3 grids (1 row, 3 columns)\ngs.update(hspace=0.2, wspace=0.3)  # Changing the wspace would change the width of graphs, and might\n                                   # cause them to overlap each other (0.05 for example)\n                                   # Similarly for hspace (vertical elongation)\n\nax0 = fig.add_subplot(gs[0, 0])    # assigning a variable fo each grid\nax1 = fig.add_subplot(gs[0, 1])    # to be able to change each graph independently\nax2 = fig.add_subplot(gs[0, 2])\n\naxes = [ax0, ax1, ax2]             # putting them in a list, to change the graph colour easily \nfig.patch.set_facecolor(background_color) # Setting the background colours for the wall behind the graphs\n\n\n# Title\nax0.text(0.5, 0.5, \"Countplot of 'cityPartRange'\\n_________________\",  # determining the coordinates of the title\n        horizontalalignment='center',\n        verticalalignment='center',                         # determining the alignment\n        fontsize=15, fontweight='bold', fontfamily='serif')\n# determining the font size, type, weight, and colour\n\nax0.set_xticklabels([])\nax0.set_yticklabels([])\n# Setting the labels (we chose to leave them empty)\nax0.tick_params(left=False, bottom=False)    # Removes the marking points at the axes of a graph\nfor s in ['top', 'right', 'left', 'bottom']:\n    ax0.spines[s].set_visible(False)\n# a for loop that removes the lines enclosing a graph\n\n\n# Graph1\nsns.countplot(x='cityPartRange', data=df, ax=ax1, palette='PuRd') # shows numbers of each category\nax1.grid(color='#000000', linestyle=':', axis='y', zorder=0, dashes=(1,5))\n\n# axis: whether to draw the dotted lines vertically or horizontally\n# zorder: which drawn figure gets put on top\n# dashes: the distance between dots\n\nax1.set_xlabel('cityPartRange')  # Setting X-label\nax1.set_ylabel('number')   # Setting Y-label\nfor s in ['top', 'right']:\n    ax1.spines[s].set_visible(False)\n# a for loop that removes the top and right lines enclosing the graph\n\n\n# Graph2\n# Drawing the hasYard feature against the category feature\nsns.countplot(x='cityPartRange', data=df, hue='category', ax=ax2, palette='PuRd')\nax2.grid(color='#000000', linestyle=':', axis='y', zorder=0, dashes=(1,5))\nax2.set_xlabel('')\nax2.set_ylabel('')\nfor s in ['top', 'right']:\n    ax2.spines[s].set_visible(False)\n\n# Settings\nfor ax in axes:\n    ax.set_facecolor(graph_color)\n# Changing the colour of the graph itself, not the background","f436c6ad":"pd.crosstab(df['category'], df['cityPartRange'], margins=True).style.background_gradient(cmap=\"Blues\")","e7b94bed":"fig = plt.figure(figsize=(16, 5))  # the figure size\ngs = fig.add_gridspec(1, 3)        # making 3 grids (1 row, 3 columns)\ngs.update(hspace=0.2, wspace=0.3)  # Changing the wspace would change the width of graphs, and might\n                                   # cause them to overlap each other (0.05 for example)\n                                   # Similarly for hspace (vertical elongation)\n\nax0 = fig.add_subplot(gs[0, 0])    # assigning a variable fo each grid\nax1 = fig.add_subplot(gs[0, 1])    # to be able to change each graph independently\nax2 = fig.add_subplot(gs[0, 2])\n\naxes = [ax0, ax1, ax2]             # putting them in a list, to change the graph colour easily \nfig.patch.set_facecolor(background_color) # Setting the background colours for the wall behind the graphs\n\n\n# Title\nax0.text(0.5, 0.5, \"Countplot of 'numPrevOwners'\\n_________________\",  # determining the coordinates of the title\n        horizontalalignment='center',\n        verticalalignment='center',                         # determining the alignment\n        fontsize=14, fontweight='bold', fontfamily='serif')\n# determining the font size, type, weight, and colour\n\nax0.set_xticklabels([])\nax0.set_yticklabels([])\n# Setting the labels (we chose to leave them empty)\nax0.tick_params(left=False, bottom=False)    # Removes the marking points at the axes of a graph\nfor s in ['top', 'right', 'left', 'bottom']:\n    ax0.spines[s].set_visible(False)\n# a for loop that removes the lines enclosing a graph\n\n\n# Graph1\nsns.countplot(x='numPrevOwners', data=df, ax=ax1, palette='PuRd') # shows numbers of each category\nax1.grid(color='#000000', linestyle=':', axis='y', zorder=0, dashes=(1,5))\n\n# axis: whether to draw the dotted lines vertically or horizontally\n# zorder: which drawn figure gets put on top\n# dashes: the distance between dots\n\nax1.set_xlabel('numPrevOwners')  # Setting X-label\nax1.set_ylabel('number')   # Setting Y-label\nfor s in ['top', 'right']:\n    ax1.spines[s].set_visible(False)\n# a for loop that removes the top and right lines enclosing the graph\n\n\n# Graph2\n# Drawing the hasYard feature against the category feature\nsns.countplot(x='numPrevOwners', data=df, hue='category', ax=ax2, palette='PuRd')\nax2.grid(color='#000000', linestyle=':', axis='y', zorder=0, dashes=(1,5))\nax2.set_xlabel('')\nax2.set_ylabel('')\nfor s in ['top', 'right']:\n    ax2.spines[s].set_visible(False)\n\n# Settings\nfor ax in axes:\n    ax.set_facecolor(graph_color)\n# Changing the colour of the graph itself, not the background","b67836b3":"pd.crosstab(df['category'], df['numPrevOwners'], margins=True).style.background_gradient(cmap=\"Blues\")","c4419859":"fig = plt.figure(figsize=(16, 5))  # the figure size\ngs = fig.add_gridspec(1, 3)        # making 3 grids (1 row, 3 columns)\ngs.update(hspace=0.2, wspace=0.3)  # Changing the wspace would change the width of graphs, and might\n                                   # cause them to overlap each other (0.05 for example)\n                                   # Similarly for hspace (vertical elongation)\n\nax0 = fig.add_subplot(gs[0, 0])    # assigning a variable fo each grid\nax1 = fig.add_subplot(gs[0, 1])    # to be able to change each graph independently\nax2 = fig.add_subplot(gs[0, 2])\n\naxes = [ax0, ax1, ax2]             # putting them in a list, to change the graph colour easily \nfig.patch.set_facecolor(background_color) # Setting the background colours for the wall behind the graphs\n\n\n# Title\nax0.text(0.5, 0.5, \"Countplot of 'hasStormProtector'\\n_________________\",  # determining the coordinates of the title\n        horizontalalignment='center',\n        verticalalignment='center',                         # determining the alignment\n        fontsize=14, fontweight='bold', fontfamily='serif')\n# determining the font size, type, weight, and colour\n\nax0.set_xticklabels([])\nax0.set_yticklabels([])\n# Setting the labels (we chose to leave them empty)\nax0.tick_params(left=False, bottom=False)    # Removes the marking points at the axes of a graph\nfor s in ['top', 'right', 'left', 'bottom']:\n    ax0.spines[s].set_visible(False)\n# a for loop that removes the lines enclosing a graph\n\n\n# Graph1\nsns.countplot(x='hasStormProtector', data=df, ax=ax1, palette='PuRd') # shows numbers of each category\nax1.grid(color='#000000', linestyle=':', axis='y', zorder=0, dashes=(1,5))\n\n# axis: whether to draw the dotted lines vertically or horizontally\n# zorder: which drawn figure gets put on top\n# dashes: the distance between dots\n\nax1.set_xlabel('hasStormProtector')  # Setting X-label\nax1.set_ylabel('number')   # Setting Y-label\nfor s in ['top', 'right']:\n    ax1.spines[s].set_visible(False)\n# a for loop that removes the top and right lines enclosing the graph\n\n\n# Graph2\n# Drawing the hasYard feature against the category feature\nsns.countplot(x='hasStormProtector', data=df, hue='category', ax=ax2, palette='PuRd')\nax2.grid(color='#000000', linestyle=':', axis='y', zorder=0, dashes=(1,5))\nax2.set_xlabel('')\nax2.set_ylabel('')\nfor s in ['top', 'right']:\n    ax2.spines[s].set_visible(False)\n\n# Settings\nfor ax in axes:\n    ax.set_facecolor(graph_color)\n# Changing the colour of the graph itself, not the background","03638023":"pd.crosstab(df['category'], df['hasStormProtector'], margins=True).style.background_gradient(cmap=\"Blues\")","9899217b":"df.head()","33c2c511":"plt.scatter(data = df2 , x=\"numberOfRooms\" , y=\"floors\" , c =df2[\"category\"], cmap = 'Purples', alpha = 0.3)\nplt.colorbar ()\nplt.show()\n# Luxurious apartments are distributed almost evenly","e610f689":"plt.scatter(data = df2 , x=\"squareMeters\" , y=\"numberOfRooms\" , c =df2[\"category\"], cmap = 'Purples', alpha = 0.3)\nplt.colorbar ()\nplt.show()\n# Luxurious apartments are distributed almost evenly","51e3329c":"# Checking price against squareMeters\ndf['price']\/df['squareMeters']\n# The relation between them is that price is almost 100* the square meters\n# so we will drop one of them","b77f3054":"# We decided to drop the price, as we believe it is more logical to assume that\n# people who buy luxurious apartments, would not care as much about the price, but\n# would care more about the size of the apartment\ndf2 = df2.drop([\"price\"], axis = 1)","94c735a4":"df2.info()\n# Price has been dropped","80ff1eab":"# Checking outliers\ndf2.plot(kind = \"box\" , subplots = True , figsize = (18,18) ,  layout = (6,3))\nplt.show()\n# There are almost no outliers, except in the category. Which makes sense\n# since luxurious apartments are a minority (around 12.6% as shown previously)","c440891e":"df2.hist(bins=120 , figsize=(14,16))\nplt.show()\n# Data does not appear to show any irregularities","6c791974":"# sns.pairplot(df2, hue=\"category\")\n# This was used to obtain more data, then was removed as it took\n# Too much time to run, and had already served its purpose","7da8605a":"x_equal_lux = df2[df2['category']==1]\nx_equal_lux\n# dh luxury bs","6a9a04cb":"x_equal_lux.shape","615e444c":"x_equal_basic = df2[df2['category']==0].sample(1265)\nx_equal_basic\n# dh basic ad el luxury","36f8158c":"x_equal_basic.shape","76288902":"# X=df2[['PC1','PC2']]\n#frames = [df1, df2]\nX_equal = [x_equal_basic,x_equal_lux]\nbalanced_result = pd.concat(X_equal) # dh 3lshan ydom el etnein ganb ba3d\nbalanced_result\n# dyh kda balanced 5ales","04ec7798":"balanced_result['category'].value_counts()\n# Data has been balanced","ab750e18":"X = balanced_result.drop('category',axis=1)\ny = balanced_result['category']","bcf4d897":"from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nstd_df = scaler.fit_transform(X)\nfrom sklearn.model_selection import train_test_split\nX_train,X_test,Y_train,Y_test = train_test_split(X,y, test_size=0.3 , random_state=42)","2417a380":"from sklearn.ensemble import RandomForestClassifier\nrf = RandomForestClassifier()\nrf.fit(X_train, Y_train)\nY_pred = rf.predict(X_test)\nrf.score(X_train,Y_train)\n# Accuracy is high, but might be due to overfitting","a67f2283":"from sklearn.metrics import confusion_matrix, classification_report\nconfusion_matrix(Y_test, Y_pred)\n# Same as above, all basic apartments were correctly classified\n# But here, also luxurious ones were correctly classified\n# Which means 100% accuracy, with no overfitting\n\n\n# 377: Predicted to be Basic, and they really are basic\n# 0 : Predicted to be luxurious, but they are basic\n# 0 : Predicted to be Basic, but they actually are luxurious\n# 382 : Predicted to be luxurious, and they really are luxurious","be1ca30f":"rf.score(X_test,Y_test)\n# Indeed, 100% accuracy","f940777e":"categories = ['Basic','Luxurious']\nprint(classification_report(Y_test, Y_pred, target_names=categories))\n# we can see that we got perfect scored this time","70c6b6b6":"Y_pred = rf.predict(X_test)\ntest = pd.DataFrame({'Predicted_Y':Y_pred, 'Actual_Y':Y_test})\nfig = plt.figure(figsize=(15,8))\ntest = test.reset_index()\ntest = test.drop(['index'],axis=1)\nplt.plot(test[100:200])\nplt.legend(['Predicted_Y','Actual_Y'])\n# All predictions were correct.","caa47a5f":"from sklearn.utils import resample\n# Create two different dataframes of majority and minority class\ndf_majority = df2[(df2['category']==0)]\ndf_minority = df2[(df2['category']==1)]\n# upsample minority class\ndf_minority_upsampled = resample(df_minority,\n                                replace = True,   # sample with replacement\n                                n_samples = 7500, # to match majority class\n                                random_state =42) # reproducible results\n# Combine majority class with upsampled minority class\ndf_upsampled = pd.concat([df_minority_upsampled, df_majority])","778489ac":"df_upsampled.shape","d7489e7e":"df_upsampled['category'].value_counts()","d11bd1c2":"X = df_upsampled.drop('category',axis=1)\ny = df_upsampled['category']","526d32ee":"scaler = StandardScaler()\nstd_df = scaler.fit_transform(X)\nX_train,X_test,Y_train,Y_test = train_test_split(X,y, test_size=0.3 , random_state=42)","f05a1c40":"from sklearn.neighbors import KNeighborsClassifier\nkclf = KNeighborsClassifier(n_neighbors=3 )\nkclf.fit(X_train, Y_train)\nkclf.score(X_train,Y_train)","66b068bf":"Y_pred = kclf.predict(X_test)\ntest = pd.DataFrame({'Predicted_Y':Y_pred, 'Actual_Y':Y_test})\nfig = plt.figure(figsize=(15,8))\ntest = test.reset_index()\ntest = test.drop(['index'],axis=1)\nplt.plot(test[100:200])\nplt.legend(['Predicted_Y','Actual_Y'])","4c04b196":"from sklearn.metrics import confusion_matrix, classification_report\nconfusion_matrix(Y_test, Y_pred)","4f568ae4":"kclf.score(X_test,Y_test)","5cc02a11":"categories = ['Basic','Luxurious']\nprint(classification_report(Y_test, Y_pred, target_names=categories))","59e2095e":"# Grid search would have been good here","6fcd234b":"X = df2.drop('category',axis=1)\ny = df2['category']","64878614":"#from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nstd_df = scaler.fit_transform(X)\n# Scaling the data first","16c6baef":"#from sklearn.model_selection import train_test_split\nX_train,X_test,Y_train,Y_test = train_test_split(X,y, test_size=0.3 , random_state=42)\n# Splitting the data 30-70","195a0a96":"#from sklearn.neighbors import KNeighborsClassifier\nkclf = KNeighborsClassifier(n_neighbors=10 )\nkclf.fit(X_train, Y_train)\nkclf.score(X_train,Y_train)\n# Not very promising","e9942f5d":"kclf.score(X_test,Y_test)\n# Not a very good score","98f66ecf":"Y_pred = kclf.predict(X_test)\ntest = pd.DataFrame({'Predicted_Y':Y_pred, 'Actual_Y':Y_test})\nfig = plt.figure(figsize=(15,8))\ntest = test.reset_index()\ntest = test.drop(['index'],axis=1)\nplt.plot(test[100:200])\nplt.legend(['Predicted_Y','Actual_Y'])\n# All basic houses were correctly predicted, while all luxurious ones\n# were incorrectly classified","55085c84":"#from sklearn.metrics import confusion_matrix, classification_report\n# Importing confusion matrix to check accuracy","baf34b0b":"from sklearn.linear_model import LogisticRegression\nlr = LogisticRegression()\nlr.fit(X_train,Y_train)\nY_pred = lr.predict(X_test)\nlr.score(X_train,Y_train)\n# Almost the same as KNN","ec57e0d2":"lr.score(X_test,Y_test)\n# Almost the same as KNN","8b7796a5":"#categories = ['Basic','Luxurious']","8ba4f350":"#print('Accuracy Score of Logistic Regression : ', accuracy_score(Y_test, Y_pred))\nconfusion_matrix(Y_test, Y_pred)\n# All basic category were correctly classified\n# But luxurious ones were incorrectly classified\n# 2608: Predicted to be Basic, and they really are basic\n# 0 : Predicted to be luxurious, but they are basic\n# 392 : Predicted to be Basic, but they actually are luxurious\n# 0 : Predicted to be luxurious, and they really are luxurious","34e55436":"print(classification_report(Y_test, Y_pred, target_names=categories))\n# we can see that Luxurious houses were all incorrectly classified","6764eced":"#from sklearn.ensemble import RandomForestClassifier\nrf = RandomForestClassifier()\nrf.fit(X_train, Y_train)\nY_pred = rf.predict(X_test)\nrf.score(X_train,Y_train)\n# Accuracy is high, but might be due to overfitting","5a110ed0":"confusion_matrix(Y_test, Y_pred)\n# Same as above, all basic apartments were correctly classified\n# But here, also luxurious ones were correctly classified\n# Which means 100% accuracy, with no overfitting","98a0e1df":"rf.score(X_test,Y_test)\n# Indeed, 100% accuracy","5b56e3e6":"print(classification_report(Y_test, Y_pred, target_names=categories))\n# we can see that we got perfect scored this time","e87cd627":"Y_pred = rf.predict(X_test)\ntest = pd.DataFrame({'Predicted_Y':Y_pred, 'Actual_Y':Y_test})\nfig = plt.figure(figsize=(15,8))\ntest = test.reset_index()\ntest = test.drop(['index'],axis=1)\nplt.plot(test[100:200])\nplt.legend(['Predicted_Y','Actual_Y'])\n# All predictions were correct.","0e5d35ca":"#### we notice that there are luxurious apartments in all city part ranges, unlike the case with pools, yards, and newly built features","d8803193":"# Comparing results to if the imbalance had not been handled","1dbf95bd":"### We notice that all luxurious apartments must have pools, but not all apartments with pools are luxurious","48cf4b88":"# Team name:\n### Outliers","e10c1655":"# Project 1","3196437f":"# Reading file","2b9ae7fd":"# EDA","cfdf149b":"#### Now that we have visualized the features with the strongest correlation to category, we will also visualize some other features with weaker correlations, to make sure that the phenomenon we have noticed so far, is not just a mere coincidence","a03f84f4":"#### The same is true here, not all luxurious houses must have a storm protector","c00415b9":"### We notice that all luxurious apartments must have pools, but not all apartments with pools are luxurious","1f8208c7":"#### we notice that there are luxurious apartments for all number of previous owners, unlike the case with pools, yards, and newly built features. This confirms our initial speculation","e4381ccf":"# Github link:\n### https:\/\/github.com\/MahmoudHamdyMahmoud\/Paris-Housing-Classification","a3848d15":"# Importing the necessary libraries","931d4c97":"# Training and Testing","ea8eefce":"# Handling imbalanced data by undersampling the majority class","7aefefc5":"### We notice that all luxurious apartments must have yards, but not all apartments with yards are luxurious","b3016142":"# Paris Housing Classification","d092f159":"# Team member names:\n### Mahmoud Hamdy\n### Ali Mohamed Hashish\n### Ali Elsabaa","e6647026":"# Bonus:\n# Deep Learning model \nOnly works on google collab, or if tensor flow is installed\n\nRefer to older versions for the deep learning model","47795bcb":"# Data preprocessing & Visualization","0956cf40":"# Kaggle links:\n### https:\/\/www.kaggle.com\/alimohamedhashish\/paris-housing-classification"}}