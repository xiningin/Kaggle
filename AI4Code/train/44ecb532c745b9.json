{"cell_type":{"b461fc9e":"code","837cfd17":"code","c727674a":"code","9cec6f50":"code","9e9842c6":"code","cd90a79d":"code","efc3111f":"code","626d6cc6":"code","4f593d8d":"code","c6bda5ae":"code","a1fefc00":"code","af0d4ebe":"code","a36f764d":"code","a4c4d207":"code","cd3fe90f":"code","b68891a8":"markdown","9e087743":"markdown","9f48807e":"markdown","a030ffa1":"markdown","9ad49f12":"markdown","68e2905d":"markdown","f6e07659":"markdown","ff5cae33":"markdown","991127d5":"markdown","974e5939":"markdown","3f4a4da8":"markdown"},"source":{"b461fc9e":"import numpy as np\nimport glob\nimport random\nimport imageio\nimport PIL, cv2\nimport pandas as pd\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom skimage.morphology import convex_hull_image, erosion\nfrom skimage.morphology import square\nimport matplotlib.image as mpimg\nimport skimage\nimport math\nfrom scipy.ndimage.filters import convolve\nfrom PIL import Image,ImageFilter\nfrom skimage.feature import hessian_matrix, hessian_matrix_eigvals","837cfd17":"# KAGGLE FINGERPRINT DATA\n\nDATA_DIR = \"..\/input\/socofing\/SOCOFing\/Real\/\"\nlist_dirs = list(glob.glob(DATA_DIR+\"*.BMP\"))\nnum_images = len(list_dirs)","c727674a":"random.seed(42)\n\nr = random.randint(0,num_images)\ndisplay_list = list_dirs[r:r+3]\n\nimage1 = imageio.imread(display_list[0])\nimage2 = imageio.imread(display_list[1])\nimage3 = imageio.imread(display_list[2])\n\nfig, axes = plt.subplots(1,3,figsize = (16,16));\naxes[0].imshow(image1);\naxes[1].imshow(image2);\naxes[2].imshow(image3);","9cec6f50":"gauss_blur = cv2.GaussianBlur(image1,(1,1),0)\nmedian_blur = cv2.medianBlur(image1,1)\n\nfig, axes = plt.subplots(1,3,figsize = (16,16));\naxes[0].set_title(\"original Image\");\naxes[0].imshow(image1);\naxes[1].set_title(\"Gaussian Blurred Image\");\naxes[1].imshow(gauss_blur);\naxes[2].set_title(\"Median Blurred Image\");\naxes[2].imshow(median_blur);","9e9842c6":"fig, axes = plt.subplots(1,3,figsize = (18,5))\naxes[0].hist(image1.ravel(), bins=256, color =\"r\");\naxes[1].hist(image2.ravel(), bins=256);\naxes[2].hist(image3.ravel(), bins=256, color =\"g\");","cd90a79d":"# mean thresholding - gives bad results\nTHRESHOLD1 = image1.mean()\nTHRESHOLD2 = image2.mean()\nTHRESHOLD3 = image3.mean()\n\nimage1 = np.array(image1 > THRESHOLD1).astype(int) * 255\nimage2 = np.array(image2 > THRESHOLD2).astype(int) * 254\nimage3 = np.array(image3 > THRESHOLD3).astype(int) * 254\n\nfig, axes = plt.subplots(1,3,figsize = (16,16));\naxes[0].imshow(image1);\naxes[1].imshow(image2);\naxes[2].imshow(image3);","efc3111f":"# Adaptive thresholding from OpenCV library - better than Mean Thresholding\n\nimg1 = cv2.imread(display_list[0],0)\nimg2 = cv2.imread(display_list[1],0)\nimg3 = cv2.imread(display_list[2],0)\n\n# Otsu's thresholding\nret1,th1 = cv2.threshold(img1,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)\nret2,th2 = cv2.threshold(img2,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)\nret3,th3 = cv2.threshold(img3,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)\n\nfig, axes = plt.subplots(1,3,figsize = (12,12));\naxes[0].set_title(\"Otsu's thresholding - Image 1\");\naxes[0].imshow(th2);\naxes[1].set_title(\"Otsu's thresholding - Image 2\");\naxes[1].imshow(th2);\naxes[2].set_title(\"Otsu's thresholding - Image 3\");\naxes[2].imshow(th2);","626d6cc6":"# convert to grayscale\nimg_name = display_list[0]\ngray_img_array = np.array(Image.open(img_name).convert('P'))","4f593d8d":"vertical_robert_filter = np.array([[1,0],[0,-1]])\nhorizontal_robert_filter = np.array([[0,1],[-1,0]])\n\nvertical_sobel_filter = np.array([[-1,0,1],[-2,0,2],[-1,0,1]])\nhorizontal_sobel_filter = np.array([[-1,-2,-1],[0,0,0],[1,2,1]])\n\nvertical_prewitt_filter = np.array([[-1,0,1],[-1,0,1],[-1,0,1]])\nhorizontal_prewitt_filter = np.array([[-1,-1,-1],[0,0,0],[1,1,1]])\n\nprint(\"vertical robert filter\\n\",vertical_robert_filter )\nprint(\"horizontal robert filter\\n\",horizontal_robert_filter)\nprint(\"vertical sobel filter: \\n\", vertical_sobel_filter)\nprint(\"horizontal sobel filter: \\n\", horizontal_sobel_filter)\n\nprint(\"vertical prewitt filter: \\n\", vertical_prewitt_filter)\nprint(\"horizontal prewitt filter: \\n\", horizontal_prewitt_filter)","c6bda5ae":"# implementing:\ngray_img = Image.fromarray(gray_img_array)\n\nconvolved_img1 = convolve(gray_img,vertical_robert_filter)\nconvolved_img1 = convolve(convolved_img1,horizontal_robert_filter)\n\nconvolved_img2 = convolve(gray_img,vertical_sobel_filter)\nconvolved_img2 = convolve(convolved_img2,horizontal_sobel_filter)\n\nconvolved_img3 =  convolve(gray_img,vertical_prewitt_filter )\nconvolved_img3 =  convolve(gray_img,horizontal_prewitt_filter )","a1fefc00":"fig, axes = plt.subplots(1,3,figsize = (12,12));\naxes[0].set_title(\"Robert\");\naxes[0].imshow(convolved_img1);\naxes[1].set_title(\"Sobel\");\naxes[1].imshow(convolved_img2);\naxes[2].set_title(\"Prewitt\");\naxes[2].imshow(convolved_img3);","af0d4ebe":"src_path = img_name\n\ndef detect_ridges(gray, sigma= 0.1):\n    H_elems = hessian_matrix(gray, sigma=sigma, order='rc')\n    maxima_ridges, minima_ridges = hessian_matrix_eigvals(H_elems)\n    return maxima_ridges, minima_ridges\n\ndef plot_images(*images):\n    images = list(images)\n    n = len(images)\n    fig, ax = plt.subplots(ncols=n, sharey=True, figsize = (12,12))\n    for i, img in enumerate(images):\n        ax[i].imshow(img, cmap='gray')\n        ax[i].axis('off')\n    plt.subplots_adjust(left=0.03, bottom=0.03, right=0.97, top=0.97)\n    plt.show()\n\nimg = cv2.imread(src_path, 0) # 0 imports a grayscale\nif img is None:\n    raise(ValueError(f\"Image didn\\'t load. Check that '{src_path}' exists.\"))\n\na, b = detect_ridges(img, sigma=0.15)\n\nplot_images(img, a, b)","a36f764d":"def getTerminationBifurcation(img, mask):\n    img = img == 255;\n    (rows, cols) = img.shape;\n    minutiaeTerm = np.zeros(img.shape);\n    minutiaeBif = np.zeros(img.shape);\n    \n    for i in range(1,rows-1):\n        for j in range(1,cols-1):\n            if(img[i][j] == 1):\n                block = img[i-1:i+2,j-1:j+2];\n                block_val = np.sum(block);\n                if(block_val == 2):\n                    minutiaeTerm[i,j] = 1;\n                elif(block_val == 4):\n                    minutiaeBif[i,j] = 1;\n    \n    mask = convex_hull_image(mask>0)\n    mask = erosion(mask, square(5))         \n    minutiaeTerm = np.uint8(mask)*minutiaeTerm\n    return(minutiaeTerm, minutiaeBif)","a4c4d207":"class MinutiaeFeature(object):\n    def __init__(self, locX, locY, Orientation, Type):\n        self.locX = locX;\n        self.locY = locY;\n        self.Orientation = Orientation;\n        self.Type = Type;\n\ndef computeAngle(block, minutiaeType):\n    angle = 0\n    (blkRows, blkCols) = np.shape(block);\n    CenterX, CenterY = (blkRows-1)\/2, (blkCols-1)\/2\n    if(minutiaeType.lower() == 'termination'):\n        sumVal = 0;\n        for i in range(blkRows):\n            for j in range(blkCols):\n                if((i == 0 or i == blkRows-1 or j == 0 or j == blkCols-1) and block[i][j] != 0):\n                    angle = -math.degrees(math.atan2(i-CenterY, j-CenterX))\n                    sumVal += 1\n                    if(sumVal > 1):\n                        angle = float('nan');\n        return(angle)\n    elif(minutiaeType.lower() == 'bifurcation'):\n        (blkRows, blkCols) = np.shape(block);\n        CenterX, CenterY = (blkRows - 1) \/ 2, (blkCols - 1) \/ 2\n        angle = []\n        sumVal = 0;\n        for i in range(blkRows):\n            for j in range(blkCols):\n                if ((i == 0 or i == blkRows - 1 or j == 0 or j == blkCols - 1) and block[i][j] != 0):\n                    angle.append(-math.degrees(math.atan2(i - CenterY, j - CenterX)))\n                    sumVal += 1\n        if(sumVal != 3):\n            angle = float('nan')\n        return(angle)\n\n\ndef extractMinutiaeFeatures(skel, minutiaeTerm, minutiaeBif):\n    FeaturesTerm = []\n\n    minutiaeTerm = skimage.measure.label(minutiaeTerm, connectivity=2);\n    RP = skimage.measure.regionprops(minutiaeTerm)\n    \n    WindowSize = 2          \n    FeaturesTerm = []\n    for i in RP:\n        (row, col) = np.int16(np.round(i['Centroid']))\n        block = skel[row-WindowSize:row+WindowSize+1, col-WindowSize:col+WindowSize+1]\n        angle = computeAngle(block, 'Termination')\n        FeaturesTerm.append(MinutiaeFeature(row, col, angle, 'Termination'))\n\n    FeaturesBif = []\n    minutiaeBif = skimage.measure.label(minutiaeBif, connectivity=2);\n    RP = skimage.measure.regionprops(minutiaeBif)\n    WindowSize = 1 \n    for i in RP:\n        (row, col) = np.int16(np.round(i['Centroid']))\n        block = skel[row-WindowSize:row+WindowSize+1, col-WindowSize:col+WindowSize+1]\n        angle = computeAngle(block, 'Bifurcation')\n        FeaturesBif.append(MinutiaeFeature(row, col, angle, 'Bifurcation'))\n    return(FeaturesTerm, FeaturesBif)\n\ndef ShowResults(skel, TermLabel, BifLabel):\n    minutiaeBif = TermLabel * 0;\n    minutiaeTerm = BifLabel * 0;\n\n    (rows, cols) = skel.shape\n    DispImg = np.zeros((rows, cols, 3), np.uint8)\n    DispImg[:, :, 0] = skel;\n    DispImg[:, :, 1] = skel;\n    DispImg[:, :, 2] = skel;\n\n    RP = skimage.measure.regionprops(BifLabel)\n    for idx, i in enumerate(RP):\n        (row, col) = np.int16(np.round(i['Centroid']))\n        minutiaeBif[row, col] = 1;\n        (rr, cc) = skimage.draw.circle_perimeter(row, col, 1);\n        skimage.draw.set_color(DispImg, (rr, cc), (255, 0, 0));\n\n    RP = skimage.measure.regionprops(TermLabel)\n    for idx, i in enumerate(RP):\n        (row, col) = np.int16(np.round(i['Centroid']))\n        minutiaeTerm[row, col] = 1;\n        (rr, cc) = skimage.draw.circle_perimeter(row, col, 1);\n        skimage.draw.set_color(DispImg, (rr, cc), (0, 0, 255));\n        \n    plt.figure(figsize=(6,6))\n    plt.title(\"Minutiae extraction results\")\n    plt.imshow(DispImg)","cd3fe90f":"\nimg_name = display_list[1]\nimg = cv2.imread(img_name,0);\nimg = np.array(img > THRESHOLD1).astype(int)\nskel = skimage.morphology.skeletonize(img)\nskel = np.uint8(skel)*255;\nmask = img*255;\n\n(minutiaeTerm, minutiaeBif) = getTerminationBifurcation(skel, mask);\nFeaturesTerm, FeaturesBif = extractMinutiaeFeatures(skel, minutiaeTerm, minutiaeBif)\nBifLabel = skimage.measure.label(minutiaeBif, connectivity=1);\nTermLabel = skimage.measure.label(minutiaeTerm, connectivity=1);\nShowResults(skel, TermLabel, BifLabel)","b68891a8":"### Introduction:\n\nFingerprint biometrics involve: Image Acquisition, Image Enhancing, Feature extraction and matching with template. Since the dataset has unique fingerprints I will implement feature extraction and different techniques for enhancing images such as Edge detection, adaptive thresholding. Feature extraction constitutes of Ridge detection (level 1 feature) and Minutiae extraction (level 3 feature) to generate a template after whicha query image is matched using the metric ROC AUC curve.\n","9e087743":"### Termination and Bifurcation detection and Minutiae Extraction\n\nThe given code extracts features like Termination, Bifurcation and Minutiae from finger prints, the output is shown below the code:\n","9f48807e":"### Dependencies and Data","a030ffa1":"### Image Transforms\n\n1. Image Smoothening\n2. Thresholding\n3. Edge Detection\n\nImage enhancement and preprocessing techniques such as smoothing, thresholding and edge detection are used to make features more prominent in data for extraction to be more accurate.","9ad49f12":"### Ridge Detection","68e2905d":"### Displaying random images from data","f6e07659":"Robert, Sobel, Prewitt Filters","ff5cae33":"### Edge detection:","991127d5":"#### Histograms","974e5939":"#### Data seems to be almost binary - implementing mean and adaptive thresholding","3f4a4da8":"# Fingerprint Feature Extraction\n"}}