{"cell_type":{"924a908d":"code","50c790e3":"code","25307d06":"code","eba94442":"code","61a17723":"code","441f20fb":"code","3e4b44f7":"code","79241f72":"code","c23a7beb":"code","a8e9514e":"code","b31ee77b":"code","5216b878":"code","5e520cef":"code","3f033974":"code","5375b293":"code","042ef950":"code","e03eaa1e":"code","35a9b35d":"code","a97e3b5a":"code","8c689812":"code","417bddc4":"code","dd09baa5":"code","9300268a":"code","226d966b":"code","ce30e159":"code","05fbe785":"markdown","3c8e514d":"markdown","54a6b69a":"markdown","7b268402":"markdown","ab5ceddf":"markdown","95408c3d":"markdown","d9fca210":"markdown","d0aa9472":"markdown","e4418e26":"markdown","a99ad7a2":"markdown"},"source":{"924a908d":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly.graph_objects as go\nimport requests\nimport json\nimport datetime\nfrom kaggle_environments import list_episodes\nimport warnings\nwarnings.filterwarnings('ignore')\npd.set_option(\"display.max_rows\", 1500)\npd.options.display.float_format = '{:,.1f}'.format","50c790e3":"f = requests.get(\"https:\/\/www.kaggle.com\/c\/hungry-geese\/leaderboard.json?includeBeforeUser=true&includeAfterUser=true\")\njsn = f.json()\nleaderboard = pd.DataFrame(columns = [\"teamName\", \"teamId\", \"teamMembers\", \"rank\", \"medal\",\"score\", \"n_agents\", \"lastSubmission\", \"best_submissionId\"])\nfor user in jsn[\"beforeUser\"]+jsn[\"afterUser\"]:\n    leaderboard = leaderboard.append({\"teamName\": user[\"teamName\"], \n                                      \"teamId\": user[\"teamId\"],\n                                      \"teamMembers\": user[\"teamMembers\"],\n                                      \"rank\": user[\"rank\"],\n                                      \"medal\": user[\"medal\"],\n                                      \"score\": user[\"score\"], \n                                      \"n_agents\": user[\"entries\"],\n                                      \"lastSubmission\": datetime.datetime.strptime(user[\"lastSubmission\"][:19], \"%Y-%m-%dT%H:%M:%S\"),\n                                      \"best_submissionId\": user[\"submissionId\"]\n                                     }, \n                                     ignore_index=True)\ndel f, jsn, user\nleaderboard = leaderboard.astype({'rank': int, 'n_agents': int, \"score\": float} )\ngold_min_score = leaderboard[leaderboard[\"medal\"] == \"gold\"][\"score\"].min()\nsilver_min_score = leaderboard[leaderboard[\"medal\"] == \"silver\"][\"score\"].min()\nbronze_min_score = leaderboard[leaderboard[\"medal\"] == \"bronze\"][\"score\"].min()\n\nepisodes = pd.read_csv(\"..\/input\/meta-kaggle\/Episodes.csv\")\nepisodes = episodes[episodes[\"CompetitionId\"] == 25401].reset_index(drop=True)\nepisodes = episodes.drop(columns=[\"Type\", \"CompetitionId\"])\nepisodes[\"CreateTime\"] = pd.to_datetime(episodes[\"CreateTime\"], format=\"%m\/%d\/%Y %H:%M:%S\")\nepisodes[\"EndTime\"] = pd.to_datetime(episodes[\"EndTime\"], format=\"%m\/%d\/%Y %H:%M:%S\")\nepisodes = episodes.rename(columns={\"Id\": \"EpisodeId\", \"CreateTime\": \"EpisodeStartTime\", \"EndTime\": \"EpisodeEndTime\"})\nepisode_agents = pd.read_csv(\"..\/input\/meta-kaggle\/EpisodeAgents.csv\")\nepisode_agents = episode_agents.drop(columns=[\"Id\", \"State\"])\nepisode_agents = pd.merge(episode_agents, episodes, on=\"EpisodeId\").drop_duplicates()\n\nagents_mapping = pd.DataFrame(columns = [\"teamId\", \"SubmissionId\", \"SubmissionDate\"])\nepisodes_to_consider = episode_agents.groupby([\"SubmissionId\"])[\"EpisodeId\"].max().to_list()\nfor i in range(0, len(episodes_to_consider), 1000):\n    batch = episodes_to_consider[i:(i + 1000)]\n    try:\n        resp = list_episodes(batch)  \n        for episode in resp[\"result\"][\"submissions\"]:\n            agents_mapping = agents_mapping.append({\"teamId\": episode[\"teamId\"],\n                                \"SubmissionId\":  episode[\"id\"] ,\n                                \"SubmissionDate\": datetime.datetime.strptime(episode[\"dateSubmitted\"][:19], \"%Y-%m-%dT%H:%M:%S\")\n                               }, ignore_index=True)\n        del episode, batch\n    except Exception as ex:\n        print(\"Error:\", ex)\n        continue\n        \nepisode_agents = pd.merge(episode_agents, agents_mapping, on=\"SubmissionId\", how=\"left\").drop_duplicates()\nepisode_agents = pd.merge(episode_agents, leaderboard.loc[:, [\"teamId\", \"teamName\"]], on=\"teamId\", how=\"left\").drop_duplicates()\ndel episodes, episodes_to_consider, agents_mapping","25307d06":"plt.figure(figsize=(25,8))\nplt.hist(leaderboard[\"score\"], color=\"mistyrose\", bins=50)\nplt.axvline(x=gold_min_score, color=\"gold\")\nplt.axvline(x=silver_min_score, color=\"silver\")\nplt.axvline(x=bronze_min_score, color=\"peru\")\nplt.xlabel(\"Team score\")\nplt.ylabel(\"Number of teams\")\nplt.legend(title=\"Team score (vertical lines are medal thresholds)\", loc=\"upper center\", title_fontsize=25)\nplt.show()","eba94442":"print(\"Descriptive statistics for team score:\", leaderboard[\"score\"].describe(), sep='\\n')","61a17723":"day_stat = episode_agents.groupby(episode_agents[\"EpisodeStartTime\"].dt.date)[\"UpdatedScore\"].describe().drop(columns=[\"std\", \"count\"])\nday_stat.index.name = 'date'\nday_stat.plot(figsize=(25,10), title=\"Score summary statistics for individual agents (data for the last day is incomplete)\")\nplt.show()\ndel day_stat","441f20fb":"plt.figure(figsize=(25,7))\nplt.hist(leaderboard[\"n_agents\"], color=\"beige\", bins=int(len(leaderboard[\"n_agents\"].unique())\/2))\nplt.xlabel(\"Team agents\")\nplt.ylabel(\"Number of teams\")\nplt.legend(title=\"Number of submissions (agents)\", loc=\"upper center\", title_fontsize=25)\nplt.show()","3e4b44f7":"print(\"Descriptive statistics for number of submissions (agents):\", leaderboard[\"n_agents\"].describe(), sep='\\n')","79241f72":"plt.figure(figsize=(25,8))\nplt.hist(leaderboard[\"lastSubmission\"], color=\"lightblue\", bins=int(len(leaderboard[\"lastSubmission\"].unique())\/3))\nplt.xlabel(\"Last submission time\")\nplt.ylabel(\"Number of teams\")\nplt.legend(title=\"Last submission date by team\", loc=\"upper center\", title_fontsize=25)\nplt.show()","c23a7beb":"episode_agents.groupby([\"SubmissionId\"]).head(1)[\"SubmissionDate\"].dt.date.value_counts().\\\n    plot(figsize=(25,7), title=\"Number of new submissions by date (data for the last day is incomplete)\", color=\"brown\")\nplt.show()","a8e9514e":"episode_agents.groupby(\"teamId\")[\"SubmissionDate\"].min().dt.date.value_counts().\\\n    plot(figsize=(25,7), title=\"Number of new teams by date (data for the last day is incomplete)\", color=\"darkorange\")\nplt.show()","b31ee77b":"print(\"Correlation coef.:\", np.corrcoef(leaderboard[\"n_agents\"], leaderboard[\"score\"])[0, 1])","5216b878":"sns.set(style=\"white\")\nsns.lmplot(\"n_agents\", \"score\", data=leaderboard, scatter_kws={\"alpha\": 0.5}, line_kws={\"color\": \"green\"}, height=10)\nplt.legend(title=\"Number of agents vs team score\", loc=\"lower center\", title_fontsize = 25)\nplt.show()","5e520cef":"sns.set(style=\"white\")\nsns.lmplot(\"n_agents\", \"score\", data=leaderboard[leaderboard[\"rank\"] <= 100], \n           scatter_kws={\"alpha\": 0.5}, line_kws={\"color\": \"green\"}, height=8)\nplt.legend(title=\"Number of agents vs team score (medal-winning teams)\", loc=\"lower center\", title_fontsize = 25)\nplt.show()","3f033974":"episode_agents.groupby([\"Index\"])[\"Reward\"].describe().reset_index(drop=False).drop(columns=['count'])","5375b293":"episode_agents.groupby(\"Index\").boxplot(column=\"Reward\", subplots=False, figsize=(25,7), grid=False, \n                                        color={\"medians\": \"DarkBlue\", \"boxes\": \"DarkGreen\"})\nplt.show()","042ef950":"last_submissions = episode_agents.sort_values([\"SubmissionId\", \"EpisodeStartTime\"], ascending=False).drop_duplicates([\"SubmissionId\"])\nteam_rating = pd.merge(\n    leaderboard.loc[:, [\"teamId\", \"teamName\", \"teamMembers\", \"n_agents\"]],\n    last_submissions.groupby([\"teamId\"])[\"UpdatedScore\"].describe().drop(columns=[\"count\", \"std\"]).\\\n        rename(columns={\"mean\": \"mean score\", \"min\": \"min score\", \"25%\": \"Q1 score\", \"50%\": \"median score\", \"75%\": \"Q3 score\", \"max\": \"max score\"}).\\\n        reset_index(level=0),\n    on=\"teamId\")\nteam_rating = pd.merge(team_rating, last_submissions[last_submissions[\"UpdatedScore\"]>=gold_min_score].groupby(\"teamId\")[\"EpisodeId\"].count().\\\n                       reset_index(level=0).rename(columns={\"EpisodeId\": \"gold medal agents\"}), on=\"teamId\", how=\"left\")\nteam_rating = pd.merge(team_rating, last_submissions[last_submissions[\"UpdatedScore\"]>=silver_min_score].groupby(\"teamId\")[\"EpisodeId\"].count().\\\n                       reset_index(level=0).rename(columns={\"EpisodeId\": \"silver medal agents\"}), on=\"teamId\", how=\"left\")\nteam_rating = pd.merge(team_rating, last_submissions[last_submissions[\"UpdatedScore\"]>=bronze_min_score].groupby(\"teamId\")[\"EpisodeId\"].count().\\\n                       reset_index(level=0).rename(columns={\"EpisodeId\": \"bronze medal agents\"}), on=\"teamId\", how=\"left\")\nteam_rating = team_rating.fillna({\"gold medal agents\": 0, \"silver medal agents\": 0, \"bronze medal agents\": 0})\ndel last_submissions\nteam_rating = team_rating.drop(columns=[\"teamId\"])\nteam_rating.sort_values(\"max score\", ascending=False).style.format({\n    \"teamMembers\": lambda x: \"\".join(f'<div style=\"float: right; margin: -4px 2px;\"><a href=\"https:\/\/www.kaggle.com{xi[\"profileUrl\"]}\"><img src=\"{xi[\"thumbnailUrl\"]}\" width=\"24\" height=\"24\" alt=\"{xi[\"displayName\"]}\"><\/a><\/div>' for xi in x)\n    ,\"mean score\": '{:,.1f}'.format\n    ,\"min score\": '{:,.1f}'.format\n    ,\"Q1 score\": '{:,.1f}'.format\n    ,\"median score\": '{:,.1f}'.format\n    ,\"Q3 score\": '{:,.1f}'.format\n    ,\"max score\": '{:,.1f}'.format  \n    ,\"gold medal agents\": '{:,.0f}'.format\n    ,\"silver medal agents\": '{:,.0f}'.format\n    ,\"bronze medal agents\": '{:,.0f}'.format\n    }).background_gradient(subset=['mean score', 'min score', 'Q1 score', 'median score', 'Q3 score', 'max score'], cmap=\"Wistia\").\\\n    background_gradient(subset=['gold medal agents', 'silver medal agents', 'bronze medal agents'], cmap=\"YlGn\").hide_index()","e03eaa1e":"score_by_day_final = episode_agents.sort_values([\"SubmissionId\", \"EpisodeStartTime\"], ascending=False).drop_duplicates([\"SubmissionId\"]).\\\n    groupby([episode_agents[\"SubmissionDate\"].dt.date])[\"UpdatedScore\"].mean().reset_index().\\\n    rename(columns={\"UpdatedScore\": \"Recent score (average by date of submission)\"}).dropna()\nplt.figure(figsize=(25, 7))\nsns.lineplot(data=score_by_day_final, x=\"SubmissionDate\", y=\"Recent score (average by date of submission)\", color=\"rosybrown\", legend=False).\\\n    set_title(\"Average final score by date of submission\")\nplt.show()\ndel score_by_day_final","35a9b35d":"score_by_day = episode_agents.groupby([episode_agents[\"SubmissionDate\"].dt.date, episode_agents[\"EpisodeStartTime\"].dt.date])[\"UpdatedScore\"].\\\n    mean().reset_index().rename(columns={\"EpisodeStartTime\": \"EpisodeDate\", \"UpdatedScore\": \"Average score\"})\nplt.figure(figsize=(25, 10))\nsns.lineplot(data=score_by_day, x=\"EpisodeDate\", y=\"Average score\", hue=\"SubmissionDate\", legend=False).\\\n    set_title(\"Dynamics of average agent score by date of submission\")\nplt.show()\ndel score_by_day","a97e3b5a":"score_by_day_final = episode_agents.sort_values([\"SubmissionId\", \"EpisodeStartTime\"], ascending=False).drop_duplicates([\"SubmissionId\"]).\\\n    groupby([episode_agents[\"SubmissionDate\"].dt.date])[\"UpdatedScore\"].max().reset_index().\\\n    rename(columns={\"UpdatedScore\": \"Recent score (max by date of submission)\"}).dropna()\nplt.figure(figsize=(25, 7))\nsns.lineplot(data=score_by_day_final, x=\"SubmissionDate\", y=\"Recent score (max by date of submission)\", color=\"brown\", legend=False).\\\n    set_title(\"Maximum final agent score by date of submission - max\")\nplt.show()\ndel score_by_day_final","8c689812":"score_by_day = episode_agents.groupby([episode_agents[\"SubmissionDate\"].dt.date, episode_agents[\"EpisodeStartTime\"].dt.date])[\"UpdatedScore\"].\\\n    max().reset_index().rename(columns={\"EpisodeStartTime\": \"EpisodeDate\", \"UpdatedScore\": \"Max score\"})\nplt.figure(figsize=(25, 10))\nsns.lineplot(data=score_by_day, x=\"EpisodeDate\", y=\"Max score\", hue=\"SubmissionDate\", legend=False).\\\n    set_title(\"Dynamics of max agent score by date of submission\")\nplt.show()\ndel score_by_day","417bddc4":"top100_agents = episode_agents.sort_values([\"SubmissionId\", \"EpisodeStartTime\"], ascending=False).drop_duplicates([\"SubmissionId\"]).\\\n    sort_values(by=[\"UpdatedScore\"], ascending=False).head(100).reset_index(drop=True).rename(columns={\"UpdatedScore\": \"Score\"})\ntop100_agents.loc[:, [\"teamName\", \"SubmissionId\", \"Score\"]].style.background_gradient(subset=[\"Score\"], cmap=\"Wistia\")","dd09baa5":"plt.figure(figsize=(20, 20))\nax = sns.countplot(y=top100_agents['teamName'], \n              order=top100_agents['teamName'].value_counts().index, \n              palette=\"Set3\")\nfor p, label in zip(ax.patches, top100_agents['teamName'].value_counts()):\n    ax.text(p.get_width() + 0.1, p.get_y()+0.5, label, ha=\"center\") \nplt.legend(title=\"TOP-100 agents by team\", loc=\"center right\", title_fontsize = 15)\nplt.show()","9300268a":"team_day_stat = episode_agents.groupby([episode_agents[\"teamName\"], episode_agents[\"EpisodeStartTime\"].dt.date])[\"UpdatedScore\"].\\\n    describe().reset_index().drop(columns=[\"std\", \"count\"]).rename(columns={\"EpisodeStartTime\": \"EpisodeDate\", \"mean\": \"mean score\", \n                                        \"min\": \"min score\", \"25%\": \"Q1 score\", \"50%\": \"median score\", \"75%\": \"Q3 score\", \"max\": \"max score\"})\nteams = leaderboard[leaderboard[\"teamName\"].isin(episode_agents[\"teamName\"])].sort_values(\"rank\")[\"teamName\"].to_list()\nteam_day_stat = team_day_stat[team_day_stat[\"EpisodeDate\"] != team_day_stat[\"EpisodeDate\"].max()] # the data for the last day is incomplete\ndefault_team = teams[0]\nlayout = go.Layout(\n    title='Team score tracking',    \n    width=1400,\n    height=800,\n    xaxis=dict(title='Date'),\n    yaxis=dict(title='Score statistics'),\n\n)\nfig=go.Figure(layout=layout)\nteam_plt_names = []\nbuttons=[]\nfor team in teams:\n    dt_team = team_day_stat[team_day_stat[\"teamName\"] == team]\n    for col in [\"mean score\", \"median score\", \"min score\", \"max score\", \"Q1 score\", \"Q3 score\"]:\n        fig.add_trace(go.Scatter(x=dt_team[\"EpisodeDate\"], \n                                 y=dt_team[col], \n                                 mode='lines',\n                                 visible=(team==default_team),\n                                 name=col\n                                ))\n        team_plt_names.extend([team])\n\nfor team in teams:\n    buttons.append(dict(method='update',\n                        label=team,\n                        args = [{'visible': [team==t for t in team_plt_names]}]))\nfig.update_layout(showlegend=False, updatemenus=[{\"buttons\": buttons, \n                                                  \"direction\": \"down\", \n                                                  \"active\": teams.index(default_team), \n                                                  \"showactive\": True, \"x\": 0.5, \"y\": 1.1}],\n                 template=\"simple_white\")\nfig.show()\ndel team_day_stat","226d966b":"last_agent_score = episode_agents.sort_values([\"SubmissionId\", \"EpisodeStartTime\"], ascending=False).drop_duplicates([\"SubmissionId\"]).\\\n    loc[:, [\"teamName\", \"SubmissionId\", \"UpdatedScore\"]].reset_index(drop=True).rename(columns={\"UpdatedScore\": \"Recent Score\"}).dropna(subset=[\"Recent Score\"])\nteams = leaderboard[leaderboard[\"teamName\"].isin(episode_agents[\"teamName\"])].sort_values(\"rank\")[\"teamName\"].to_list()\ndefault_team = teams[0]\nlayout = go.Layout(\n    title=\"Team agents\\' score distribution\",\n    paper_bgcolor='rgba(0,0,0,0)',\n    plot_bgcolor='rgba(0,0,0,0)',\n    width=1400,\n    height=800,\n    xaxis=dict(title='Last (final) score', linecolor=\"black\"),\n    yaxis=dict(title='Number of agents', linecolor=\"black\"), # , dtick=1\n)\nfig=go.Figure(layout=layout)\nteam_plt_names = []\nbuttons=[]\nfor team in teams:\n    dt_team = last_agent_score[last_agent_score[\"teamName\"] == team].reset_index(drop=True)\n    fig.add_trace(go.Histogram(x=dt_team[\"Recent Score\"],\n                               visible=(team==default_team),\n                               name=team,\n                               opacity=0.75,\n                               histnorm=\"\", #probability density\n                               marker_color='darksalmon',\n                            ))\n    team_plt_names.extend([team])\n\nfor team in teams:\n    buttons.append(dict(method='update',\n                        label=team,\n                        args = [{'visible': [team==t for t in team_plt_names]}]))\nfig.update_layout(showlegend=False, updatemenus=[{\"buttons\": buttons, \n                                                  \"direction\": \"down\", \n                                                  \"active\": teams.index(default_team), \n                                                  \"showactive\": True, \"x\": 0.5, \"y\": 1.1}])\nfig.add_vline(x=gold_min_score, line_color=\"gold\")\nfig.add_vline(x=silver_min_score, line_color=\"silver\")\nfig.add_vline(x=bronze_min_score, line_color=\"peru\")\nfig.show()\ndel last_agent_score","ce30e159":"teams = leaderboard[leaderboard[\"teamName\"].isin(episode_agents[\"teamName\"])].sort_values(\"rank\")[\"teamName\"].to_list()\ndefault_team = teams[0]\nlayout = go.Layout(\n    title='Team agents\\' tracking',\n    paper_bgcolor='rgba(0,0,0,0)',\n    plot_bgcolor='rgba(0,0,0,0)',\n    width=1400,\n    height=800,\n    xaxis=dict(title=\"Episodes\\' date and time\", linecolor=\"black\"),\n    yaxis=dict(title='Scores', linecolor=\"black\"),\n)\nfig=go.Figure(layout=layout)\nteam_plt_names = []\nbuttons=[]\nfor team in teams:\n    dt_team = episode_agents[episode_agents[\"teamName\"] == team].dropna(subset=[\"EpisodeStartTime\", \"UpdatedScore\"]).reset_index(drop=True)\n    dt_team = dt_team.sort_values([\"SubmissionId\", \"EpisodeStartTime\"], ascending=False)\n    for submission in dt_team[\"SubmissionId\"].unique().tolist():\n        fig.add_trace(go.Scatter(x=dt_team.loc[dt_team[\"SubmissionId\"]==submission, \"EpisodeStartTime\"], \n                                 y=dt_team.loc[dt_team[\"SubmissionId\"]==submission, \"UpdatedScore\"], \n                                 #mode='lines',\n                                 visible=(team==default_team),\n                                 name=str(submission)\n                                ))\n        team_plt_names.extend([team])\n        \nfor team in teams:\n    buttons.append(dict(method='update',\n                        label=team,\n                        args = [{'visible': [team==t for t in team_plt_names]}]))\nfig.update_layout(showlegend=False, updatemenus=[{\"buttons\": buttons, \n                                                  \"direction\": \"down\", \n                                                  \"active\": teams.index(default_team), \n                                                  \"showactive\": True, \"x\": 0.5, \"y\": 1.1}])\nfig.add_hline(y=gold_min_score, line_color=\"gold\")\nfig.add_hline(y=silver_min_score, line_color=\"silver\")\nfig.add_hline(y=bronze_min_score, line_color=\"peru\")\nfig.show()","05fbe785":"# 4. Geese index stats\n\n[@chankhavu](https:\/\/www.kaggle.com\/chankhavu) suggests that there is [unfair advantage](https:\/\/www.kaggle.com\/c\/hungry-geese\/discussion\/228967) for geese with smaller index. Nevertheless, this advantage seems to have small (if any) effect on the outcome (game reward statistics):","3c8e514d":"# 6. Agents grouped by the day of submission","54a6b69a":"# 7. Top-100 agents","7b268402":"# 3. Number of submissions vs team score","ab5ceddf":"# 8. Team score tracking","95408c3d":"# 1. General stats: score ","d9fca210":"# 5. Score distribution by team\n\n*NB: team members are clickable*","d0aa9472":"<h2><center> Hungry Geese - leaderboard exploratory data analysis (EDA) and team tracking <\/center><\/h2>","e4418e26":"<h2><center> <img src=\"https:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/5\/52\/Flying_goose.svg\/236px-Flying_goose.svg.png\" alt=\"Geese img\"><\/center><\/h2>","a99ad7a2":"# 2. General stats: participation"}}