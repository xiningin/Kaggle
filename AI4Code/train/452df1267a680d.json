{"cell_type":{"77d5f7e6":"code","123840c9":"code","fc0dc07c":"code","198f5f12":"code","7821c85b":"code","f1f89bad":"code","b354f49b":"code","e7b9fce5":"code","162f8e6b":"code","ec536bac":"code","690a6ebc":"code","e0783d87":"code","b9465a0a":"code","418b202b":"code","3da3b236":"code","52596015":"code","58b7a958":"code","d8d74fa1":"code","98e7c9d9":"code","4789fdc3":"code","82b41c46":"code","9d534fe8":"code","afce368b":"code","a4789215":"code","1470bac1":"code","e24f8e07":"code","f1bad29a":"code","e371e8ed":"code","411b943f":"code","37e22de1":"markdown","45fd1b73":"markdown","d56ccfde":"markdown","bb519c65":"markdown","8c080129":"markdown","5da67645":"markdown","5c1dba98":"markdown","da5cc70d":"markdown","1caad721":"markdown","1c5043a9":"markdown","1a45df05":"markdown","428135b6":"markdown"},"source":{"77d5f7e6":"%cd \/kaggle\n!rm -r temp\n!mkdir temp\n%cd \/kaggle\/temp","123840c9":"# !pip install -q -U --pre tensorflow==\"2.2.0\"\n!pip install strsimpy\n!pip install -q -U albumentations\n!echo \"$(pip freeze | grep albumentations) is successfully installed\"","fc0dc07c":"import os\nimport pathlib\n \n# Clone the tensorflow models repository if it doesn't already exist\nif \"models\" in pathlib.Path.cwd().parts:\n  while \"models\" in pathlib.Path.cwd().parts:\n    os.chdir('..')\nelif not pathlib.Path('models').exists():\n  !git clone --depth 1 https:\/\/github.com\/tensorflow\/models","198f5f12":"# Install the Object Detection API\n%cd \/kaggle\/temp\/models\/research\/\n!protoc object_detection\/protos\/*.proto --python_out=.\n!cp object_detection\/packages\/tf2\/setup.py .\n!python -m pip install .","7821c85b":"import matplotlib\nimport matplotlib.pyplot as plt\n \nimport os\nimport random\nimport io\nimport imageio\nimport glob\nimport scipy.misc\nimport numpy as np\nimport pandas as pd\nfrom tqdm.notebook import tqdm\nfrom six import BytesIO\nfrom PIL import Image, ImageDraw, ImageFont\nfrom IPython.display import display, Javascript\nfrom IPython.display import Image as IPyImage\nfrom strsimpy.levenshtein import Levenshtein\n\nimport tensorflow as tf\nimport tensorflow_addons as tfa\n \nfrom object_detection.utils import label_map_util\nfrom object_detection.utils import config_util\nfrom object_detection.utils import visualization_utils as viz_utils\n# from object_detection.utils import colab_utils\nfrom object_detection.builders import model_builder\n \nfrom functools import partial\nimport albumentations as alb\n \nAUTOTUNE = tf.data.AUTOTUNE\n \n%matplotlib inline","f1f89bad":"# \u0414\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044f \u0441 \u0434\u0430\u043d\u043d\u044b\u043c\u0438\n!ls \/kaggle\/input\/payment-detection","b354f49b":"def load_image_into_numpy_array(path):\n  \"\"\"Load an image from file into a numpy array.\n \n  Puts image into numpy array to feed into tensorflow graph.\n  Note that by convention we put it into a numpy array with shape\n  (height, width, channels), where channels=3 for RGB.\n \n  Args:\n    path: a file path.\n \n  Returns:\n    uint8 numpy array with shape (img_height, img_width, 3)\n  \"\"\"\n  img_data = tf.io.gfile.GFile(path, 'rb').read()\n  image = Image.open(BytesIO(img_data))\n  (im_width, im_height) = image.size\n  return np.array(image.getdata()).reshape(\n      (im_height, im_width, 3)).astype(np.uint8)\n \ndef plot_detections(image_np,\n                    boxes,\n                    classes,\n                    scores,\n                    category_index,\n                    figsize=(14, 18),\n                    image_name=None,\n                    min_score_thresh=0.5):\n  \"\"\"Wrapper function to visualize detections.\n \n  Args:\n    image_np: uint8 numpy array with shape (img_height, img_width, 3)\n    boxes: a numpy array of shape [N, 4]\n    classes: a numpy array of shape [N]. Note that class indices are 1-based,\n      and match the keys in the label map.\n    scores: a numpy array of shape [N] or None.  If scores=None, then\n      this function assumes that the boxes to be plotted are groundtruth\n      boxes and plot all boxes as black with no classes or scores.\n    category_index: a dict containing category dictionaries (each holding\n      category index `id` and category name `name`) keyed by category indices.\n    figsize: size for the figure.\n    image_name: a name for the image file.\n  \"\"\"\n  image_np_with_annotations = image_np.copy()\n  viz_utils.visualize_boxes_and_labels_on_image_array(\n      image_np_with_annotations,\n      boxes,\n      classes,\n      scores,\n      category_index,\n      use_normalized_coordinates=True,\n      min_score_thresh=min_score_thresh,\n      line_thickness=6)\n  if image_name:\n    plt.imsave(image_name, image_np_with_annotations)\n  else:\n    plt.imshow(image_np_with_annotations)","e7b9fce5":"data_dir_train = '\/kaggle\/input\/payment-detection\/train\/*\/*'\ndata_dir_test = '\/kaggle\/input\/payment-detection\/test\/*\/*'\n \ntrain_info = pd.read_csv('\/kaggle\/input\/payment-detection\/train.csv')\n \ncards = {\n            'VI':1,\n            'MA':2,\n            'EX':3, \n            'PC':4, \n            'ST':5,\n            'UY':6\n}\nlabel_id_offset = 1\n \ntrain_labels = tf.convert_to_tensor(\n    train_info['label'].apply(lambda x: cards[x] - label_id_offset), dtype=tf.uint8\n)\n \ntrain_names = tf.convert_to_tensor(train_info['image'], dtype=np.object)\ntrain_boxes = tf.convert_to_tensor(train_info[['x1', 'y1', 'w', 'h', 'width', 'height']], dtype=tf.float32)\n \ntrain_info.head()","162f8e6b":"list_ds_train = tf.data.Dataset.list_files(data_dir_train, shuffle=False)\nlist_ds_train = list_ds_train.shuffle(len(list_ds_train), reshuffle_each_iteration=False)\nlist_ds_test = tf.data.Dataset.list_files(data_dir_test, shuffle=False)\n \nimage_count_train, image_count_test = len(list_ds_train), len(list_ds_test)\n \nprint(image_count_train, image_count_test)\nfor f in list_ds_train.take(5):\n    print(f.numpy())","ec536bac":"# \u041f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0434\u0435\u043b\u0430\u0442\u044c \u0430\u0443\u0433\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0441 \u0431\u043e\u043a\u0441\u0430\u043c\u0438 \u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c tf.data.Dataset\n!pip install tf-image","690a6ebc":"# \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u043c \u0430\u0443\u0433\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438: \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0435 \u0432\u0440\u0430\u0449\u0435\u043d\u0438\u0435, \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0439 \u043a\u0440\u043e\u043f \u0438 \u044d\u0440\u0435\u0439\u0441\nfrom tf_image.core.convert_type_decorator import convert_type\nfrom tf_image.core.bboxes.rotate import random_rotate\nfrom tf_image.core.bboxes.flip import flip_left_right\nfrom tf_image.core.bboxes.clip import clip_random_with_bboxes\nfrom tf_image.core.bboxes.erase import multiple_erase\nfrom tf_image.core.random import random_function_bboxes, random_function\nfrom tf_image.core.colors import grayscale\n\n@convert_type\ndef augment_image(image, boxes):\n    image, boxes = random_function_bboxes(\n        image, boxes, random_rotate, 0.5, min_rotate=-180, max_rotate=180\n    )\n    image, boxes = random_function_bboxes(\n        image, boxes, clip_random_with_bboxes, 0.5\n    )\n    #image, boxes = flip_left_right(\n    #    image, boxes\n    #)\n    image, boxes = multiple_erase(\n        image, boxes, max_area=0.025\n    )\n    # image = random_function(image, grayscale, 0.25)\n \n    return image, boxes","e0783d87":"# \u0410\u0443\u0433\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0438\u0437 albumentations, \u0438\u043c\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u043d\u0435 \u0431\u0443\u0434\u0435\u043c,\n# \u043f\u043e\u0441\u043a\u043e\u043b\u044c\u043a\u0443 \u043f\u0440\u043e\u0445\u043e\u0434 \u043f\u043e \u0431\u043e\u043a\u0441\u0430\u043c \u0432\u044b\u0434\u0430\u0435\u0442 \u043e\u0448\u0438\u0431\u043a\u0443 \u043f\u0440\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0438\n# \u0434\u0435\u043a\u043e\u0440\u0430\u0442\u043e\u0440\u0430 tf.function\nIMAGE_HEIGHT, IMAGE_WIDTH = 640, 640\ntrain_transforms = alb.Compose([\n                             # alb.Resize(IMAGE_HEIGHT, IMAGE_WIDTH),\n                             # alb.HorizontalFlip(), # \u041e\u0442\u0440\u0430\u0437\u0438\u0442\u044c \u043f\u043e \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u0438\n                             # A.RandomSizedBBoxSafeCrop(500, 640, p=.1), # \u0412\u0437\u044f\u0442\u044c \u043e\u0431\u043b\u0430\u0441\u0442\u044c 500 \u043d\u0430 640 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e \u0434\u043b\u044f \u0431\u043e\u043a\u0441\u043e\u0432\n                             # alb.Rotate(limit=90, border_mode=cv2.BORDER_REPLICATE, p=.05), # \u0421\u043b\u0443\u0447\u0430\u0439\u043d\u043e \u043f\u043e\u0432\u0435\u0440\u043d\u0443\u0442\u044c \u0434\u043e 90 \u0433\u0440\u0430\u0434\u0443\u0441\u043e\u0432\n                             alb.RandomBrightnessContrast(0.4, 0.4, always_apply=True), # \u042f\u0440\u043a\u043e\u0441\u0442\u044c\/\u043a\u043e\u043d\u0442\u0440\u0430\u0441\u0442\u043d\u043e\u0441\u0442\u044c\n                             alb.HueSaturationValue(10, 20, 10, True), # \u0426\u0432\u0435\u0442\u0430\u0441\u0442\u043e\u0441\u0442\u044c\/\u043d\u0430\u0441\u044b\u0449\u0435\u043d\u043d\u043e\u0441\u0442\u044c \n                             alb.RandomGamma(always_apply=True), # \u0413\u0430\u043c\u043c\u0430\n                             alb.GaussianBlur((3, 9), p=.1), # \u0420\u0430\u0437\u043c\u044b\u0442\u0438\u0435\n                             ])# , alb.BboxParams(format='albumentations', label_fields=[], ))","b9465a0a":"num_classes = 6\n\n# \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f tf.data.Dataset\n@tf.function\ndef process_path(file_path, train):\n  # convert the path to a list of path components\n  parts = tf.strings.split(file_path, os.path.sep)\n  mask = train_names == parts[-1]\n  boxes_info = train_boxes[mask]\n  labels_info = train_labels[mask]\n \n  # [x_min, y_min, w, h] -> [y_min, x_min, y_max, x_max]\n  def get_boxes(boxes_info):\n    box = tf.concat(\n        [boxes_info[:, 1:2],\n         boxes_info[:, 0:1],\n         boxes_info[:, 1:2] + boxes_info[:, 3:4],\n         boxes_info[:, 0:1] + boxes_info[:, 2:3]],\n        axis=1\n    )\n \n    img_size = tf.concat([boxes_info[:, 5:6], boxes_info[:, 4:5]], axis=1)\n    img_size = tf.concat([img_size, img_size], axis=1)\n    return box \/ img_size\n  \n  boxes = get_boxes(boxes_info)\n  \n  classes = tf.one_hot(\n      labels_info, num_classes\n  )\n \n  def aug_fn(image):\n    data = {\n          \"image\": image,\n          # \"bboxes\": boxes,\n          # \"labels\": classes\n    }\n    aug_data = train_transforms(**data)\n    image = tf.convert_to_tensor(aug_data['image'], tf.float32)\n    # boxes = tf.convert_to_tensor(aug_data['bboxes'], tf.float32)\n    # classes = tf.convert_to_tensor(aug_data['labels'], tf.float32)\n    return image # , boxes, classes\n  \n  img = tf.io.read_file(file_path)\n  img = tf.image.decode_jpeg(img, channels=3)\n  \n  if train:\n    img, boxes = augment_image(img, boxes)\n    # img = tf.numpy_function(func=aug_fn, inp=[img], Tout=tf.float32)\n    img = tf.image.random_brightness(\n      img, 0.15, seed=None\n    )\n    img = tf.image.random_contrast(\n      img, 0.5, 1\n    )\n    img = tf.image.random_hue(\n      img, 0.1\n    )\n    tf.image.random_saturation(\n        img, 0, 5, seed=None\n    )\n\n    img = tf.cast(img, tf.float32)\n  else:\n    img = tf.cast(img, tf.float32)\n\n  img = tf.expand_dims(img, axis=0)\n \n  if train:\n    return img, (boxes, classes)\n  else:\n    return img, parts[-1]","418b202b":"# \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430\nfunc_test = process_path('\/kaggle\/input\/payment-detection\/train\/train\/d7b5ce1ca2c36eb82a7e3648bfb9f379.jpg', True)\nfunc_test[0].shape, func_test[1][0], func_test[1][1]","3da3b236":"val_size = int(image_count_train * 0.2)\ntrain_ds = list_ds_train.skip(val_size)\nval_ds = list_ds_train.take(val_size)\n \nlen(train_ds), len(val_ds)","52596015":"train_ds = train_ds.map(partial(process_path, train=True), num_parallel_calls=AUTOTUNE).prefetch(AUTOTUNE)\nval_ds = val_ds.map(partial(process_path, train=True), num_parallel_calls=AUTOTUNE).prefetch(AUTOTUNE)\ntest_ds = list_ds_test.map(partial(process_path, train=False), num_parallel_calls=AUTOTUNE).prefetch(AUTOTUNE)","58b7a958":"for image, label in train_ds.take(1):\n  print(\"Image shape: \", image.numpy().shape)\n  print(\"Boxes, classes: \", label[0].numpy().shape, label[1].numpy().shape)","d8d74fa1":"category_index = {\n    1: {'id': 1, 'name': 'VI'},\n    2: {'id': 2, 'name': 'MA'},\n    3: {'id': 3, 'name': 'EX'},\n    4: {'id': 4, 'name': 'PC'},\n    5: {'id': 5, 'name': 'ST'},\n    6: {'id': 6, 'name': 'UY'},\n}\n \nplt.figure(figsize=(30, 15))\nfor idx, (image, label) in enumerate(train_ds.take(9)):\n  dummy_scores = np.array([1.0]*label[0].numpy().shape[0], dtype=np.float32) # give boxes a score of 100%\n  plt.subplot(3, 3, idx+1)\n  plot_detections(\n      image.numpy().astype(np.uint8)[0],\n      label[0].numpy(),\n      np.argmax(label[1].numpy(), axis=1) + 1,\n      dummy_scores, category_index) \nplt.show()","98e7c9d9":"# Download the checkpoint and put it into models\/research\/object_detection\/test_data\/\n\n!wget http:\/\/download.tensorflow.org\/models\/object_detection\/tf2\/20200711\/ssd_resnet50_v1_fpn_640x640_coco17_tpu-8.tar.gz\n!tar -xf ssd_resnet50_v1_fpn_640x640_coco17_tpu-8.tar.gz\n!mv ssd_resnet50_v1_fpn_640x640_coco17_tpu-8\/checkpoint \/kaggle\/temp\/models\/research\/object_detection\/test_data\/","4789fdc3":"# \u0421\u043a\u0430\u0447\u0430\u0435\u043c \u0447\u0435\u043a\u043f\u043e\u0439\u043d\u0442 \u0441 \u043b\u0443\u0447\u0448\u0438\u043c \u0441\u043a\u043e\u0440\u043e\u043c\n!pip install gdown\n%cd \/kaggle\/working\n!gdown https:\/\/drive.google.com\/uc?id=1ZNuF_bwibIZalhxwQHBUjs-13o6oM9l5 && unzip ckpt.zip -d ckpt && rm ckpt.zip","82b41c46":"tf.keras.backend.clear_session()\n \nprint('Building model and restoring weights for fine-tuning...', flush=True)\nnum_classes = 6\npipeline_config = '\/kaggle\/temp\/models\/research\/object_detection\/configs\/tf2\/ssd_resnet50_v1_fpn_640x640_coco17_tpu-8.config'\n# \u0415\u0441\u043b\u0438 \u043e\u0431\u0443\u0447\u0430\u0442\u044c \u043c\u043e\u0434\u0435\u043b\u044c \u0441 \u043d\u0443\u043b\u044f, \u0442\u043e \u0443\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u044b\u0431\u0438\u0440\u0430\u0435\u043c \u0437\u0430\u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u043f\u0443\u0442\u044c\n# checkpoint_path = '\/kaggle\/temp\/models\/research\/object_detection\/test_data\/checkpoint\/ckpt-0'\ncheckpoint_path = '\/kaggle\/working\/ckpt\/ckpt-71'\n\n# Load pipeline config and build a detection model.\n\nconfigs = config_util.get_configs_from_pipeline_file(pipeline_config)\nmodel_config = configs['model']\nmodel_config.ssd.num_classes = num_classes\nmodel_config.ssd.freeze_batchnorm = False\ndetection_model = model_builder.build(\n      model_config=model_config, is_training=True)\n \n# Set up object-based checkpoint restore --- RetinaNet has two prediction\n# `heads` --- one for classification, the other for box regression.  We will\n# restore the box regression head but initialize the classification head\n# from scratch (we show the omission below by commenting out the line that\n# we would add if we wanted to restore both heads)\nfake_box_predictor = tf.compat.v2.train.Checkpoint(\n    _base_tower_layers_for_heads=detection_model._box_predictor._base_tower_layers_for_heads,\n    # \u0415\u0441\u043b\u0438 \u043e\u0431\u0443\u0447\u0430\u0442\u044c \u0441 \u043d\u0443\u043b\u044f, \u0442\u043e \u0441\u0442\u0440\u043e\u0447\u043a\u0443 \u043d\u0438\u0436\u0435 \u043d\u0443\u0436\u043d\u043e \u0437\u0430\u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c, \u043d\u043e \u043e\u043d\u0430 \u043d\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0442\u044c\u0441\u044f \u0432 \u0447\u0435\u043a\u043f\u043e\u0439\u043d\u0442\n    _prediction_heads=detection_model._box_predictor._prediction_heads, \n    #    (i.e., the classification head that we *will not* restore)\n    _box_prediction_head=detection_model._box_predictor._box_prediction_head,\n    )\nfake_model = tf.compat.v2.train.Checkpoint(\n          _feature_extractor=detection_model._feature_extractor,\n          _box_predictor=fake_box_predictor)\nckpt = tf.compat.v2.train.Checkpoint(model=fake_model)\nckpt.restore(checkpoint_path).expect_partial()\n \n# Run model through a dummy image so that variables are created\nimage, shapes = detection_model.preprocess(tf.zeros([1, 640, 640, 3]))\nprediction_dict = detection_model.predict(image, shapes)\n_ = detection_model.postprocess(prediction_dict, shapes)\nprint('Weights restored!')","9d534fe8":"# \u041f\u0440\u043e\u0432\u0435\u0440\u0438\u043c, \u0447\u0442\u043e \u043c\u044b \u043d\u0430 GPU\ntf.config.list_physical_devices('GPU')","afce368b":"tf.keras.backend.set_learning_phase(True)\n\nbatch_size = 4\nlearning_rate = 0.01\nnum_epoch = 1\npbar_rate = 5 # \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441 \u043a\u0430\u0436\u0434\u044b\u0435 n \u0431\u0430\u0442\u0447\u0435\u0439\nckpt_rate = 5 # \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0442\u044c \u043c\u043e\u0434\u0435\u043b\u044c \u043a\u0430\u0436\u0434\u044b\u0435 n \u044d\u043f\u043e\u0445\n \n# Select all variables to fine-tune.\ntrainable_variables = detection_model.trainable_variables\nto_fine_tune = []\nprefixes_to_train = [\n  'WeightSharedConvolutionalBoxPredictor\/WeightSharedConvolutionalBoxHead',\n  'WeightSharedConvolutionalBoxPredictor\/WeightSharedConvolutionalClassHead']\nfor var in trainable_variables:\n# \u0415\u0441\u043b\u0438 \u043e\u0431\u0443\u0447\u0430\u0442\u044c \u0442\u043e\u043b\u044c\u043a\u043e \u0433\u043e\u043b\u043e\u0432\u044b, \u0442\u043e \u0443\u0431\u0440\u0430\u0442\u044c \u043a\u043e\u043c\u043c\u0435\u043d\u0442 \u0438\u0437 \u0441\u0442\u0440\u043e\u043a\u0438 \u043d\u0438\u0436\u0435 \u0438 \u0437\u0430\u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0438\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0443 \u043f\u043e\u0441\u043b\u0435\n#  if any([var.name.startswith(prefix) for prefix in prefixes_to_train]):\n  if var.trainable:\n    to_fine_tune.append(var)\n \n# Set up forward + backward pass for a single train step.\ndef get_model_train_step_function(model, optimizer, vars_to_fine_tune):\n  \"\"\"Get a tf.function for training step.\"\"\"\n \n  # Use tf.function for a bit of speed.\n  # Comment out the tf.function decorator if you want the inside of the\n  # function to run eagerly.\n  # experimental_relax_shapes=True - \u0447\u0442\u043e\u0431\u044b tf.function \u0440\u0430\u0431\u043e\u0442\u0430\u043b \u0441 \u0440\u0430\u0437\u043d\u044b\u043c\u0438 \u0440\u0430\u0437\u043c\u0435\u0440\u043d\u043e\u0441\u0442\u044f\u043c\u0438 \u043a\u0430\u0440\u0442\u0438\u043d\u043e\u043a \u0432 \u0433\u0440\u0430\u0444\u0435\n  @tf.function(experimental_relax_shapes=True)\n  def train_step_fn(image_tensors,\n                    groundtruth_boxes_list,\n                    groundtruth_classes_list):\n    \"\"\"A single training iteration.\n \n    Args:\n      image_tensors: A list of [1, height, width, 3] Tensor of type tf.float32.\n        Note that the height and width can vary across images, as they are\n        reshaped within this function to be 640x640.\n      groundtruth_boxes_list: A list of Tensors of shape [N_i, 4] with type\n        tf.float32 representing groundtruth boxes for each image in the batch.\n      groundtruth_classes_list: A list of Tensors of shape [N_i, num_classes]\n        with type tf.float32 representing groundtruth boxes for each image in\n        the batch.\n \n    Returns:\n      A scalar tensor representing the total loss for the input batch.\n    \"\"\"\n    shapes = tf.constant(batch_size * [[640, 640, 3]], dtype=tf.int32)\n    model.provide_groundtruth(\n        groundtruth_boxes_list=groundtruth_boxes_list,\n        groundtruth_classes_list=groundtruth_classes_list)\n    with tf.GradientTape() as tape:\n      preprocessed_images = tf.concat(\n          [detection_model.preprocess(image_tensor)[0]\n           for image_tensor in image_tensors], axis=0)\n      prediction_dict = model.predict(preprocessed_images, shapes)\n      losses_dict = model.loss(prediction_dict, shapes)\n      total_loss = losses_dict['Loss\/localization_loss'] + losses_dict['Loss\/classification_loss']\n      gradients = tape.gradient(total_loss, vars_to_fine_tune)\n      optimizer.apply_gradients(zip(gradients, vars_to_fine_tune))\n    return total_loss\n \n  return train_step_fn\n \noptimizer = tf.keras.optimizers.SGD(learning_rate=learning_rate, momentum=0.9)\ntrain_step_fn = get_model_train_step_function(\n    detection_model, optimizer, to_fine_tune)\n \nprint('Start fine-tuning!', flush=True)\nfor epoch in range(num_epoch):\n  print('Epoch:', epoch)\n  epoch_loss = []\n  with tqdm(total=len(train_ds.window(batch_size))) as pbar:\n    for idx, (image_tensors, (gt_boxes_list, gt_classes_list)) in enumerate(train_ds.window(batch_size)):\n      image_tensors = list(image_tensors)\n      gt_boxes_list = list(gt_boxes_list)\n      gt_classes_list = list(gt_classes_list)\n \n      # Training step (forward pass + backwards pass)\n      total_loss = train_step_fn(image_tensors, gt_boxes_list, gt_classes_list)\n \n      if idx % pbar_rate == 0:\n        # \u0412\u044b\u0432\u0435\u0434\u0435\u043c \u043e\u0448\u0438\u0431\u043a\u0443 \u0432 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\n        pbar.set_description(\"Loss value {:.4f}\".format(total_loss.numpy()))\n        pbar.update(pbar_rate)\n        epoch_loss.append(total_loss.numpy())\n      \n  print('Epoch loss:', np.mean(epoch_loss))\n  if epoch % ckpt_rate == 0:\n    ckpt.save('\/kaggle\/temp\/ckpt\/ckpt') # \u0421\u043e\u0445\u0440\u0430\u043d\u0438\u043c \u0447\u0435\u043a\u043f\u043e\u0439\u043d\u0442 \u0432\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u043f\u0430\u043f\u043a\u0443\n    print('Checkpoint saved!')\nprint('Done fine-tuning!')","a4789215":"# \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0444\u0438\u043b\u044c\u0442\u0440\u0430\u0446\u0438\u0438 \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u0439 \u043f\u043e \u0441\u043a\u043e\u0440\u0430\u043c, IOU \u0438 \u043f\u043b\u043e\u0449\u0430\u0434\u0438\ndef filter_predictions(scores, \n                       boxes, \n                       classes, \n                       iou_thresh=0.5, \n                       filter_thresh=0.5,\n                       area_thresh=0.4):\n\n  def calc_areas(boxes):\n    areas = []\n    for i in boxes:\n      areas.append((np.abs(np.diff(i[::2])) * np.abs(np.diff(i[1::2])))[0])\n    return np.array(areas)\n\n  # non-max supression\n  nonmaxsupr_ind = tf.image.non_max_suppression(\n      boxes, \n      scores,\n      100,\n      iou_threshold=iou_thresh\n  ).numpy()\n  boxes = boxes.numpy()[nonmaxsupr_ind]\n  classes = classes.numpy()[nonmaxsupr_ind]\n  scores = scores.numpy()[nonmaxsupr_ind]\n  # score-filtering\n  mask = scores > filter_thresh\n  if not any(mask): # \u0435\u0441\u043b\u0438 \u0432\u0441\u0451 \u043c\u0435\u043d\u044c\u0448\u0435 \u043f\u043e\u0440\u043e\u0433\u0430, \u0432\u044b\u0434\u0430\u0442\u044c \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u0435\n    mask = scores == np.max(scores)\n  boxes = boxes[mask]\n  if len(boxes) > 1:\n    areas = calc_areas(boxes)\n    mask_areas = areas < area_thresh\n    boxes = boxes[mask_areas]\n  classes = classes[mask]\n  scores = scores[mask]\n  return scores, boxes, classes","1470bac1":"# Again, uncomment this decorator if you want to run inference eagerly\n# @tf.function(experimental_relax_shapes=True)\ndef detect(input_tensor):\n  \"\"\"Run detection on an input image.\n\n  Args:\n    input_tensor: A [1, height, width, 3] Tensor of type tf.float32.\n      Note that height and width can be anything since the image will be\n      immediately resized according to the needs of the model within this\n      function.\n\n  Returns:\n    A dict containing 3 Tensors (`detection_boxes`, `detection_classes`,\n      and `detection_scores`).\n  \"\"\"\n  preprocessed_image, shapes = detection_model.preprocess(input_tensor)\n  prediction_dict = detection_model.predict(preprocessed_image, shapes)\n  return detection_model.postprocess(prediction_dict, shapes)\n\n# Note that the first frame will trigger tracing of the tf.function, which will\n# take some time, after which inference should be fast.\n\nSCORE_THRESH = 0.4\nIOU_THRESH = 0.3\nAREA_THRESH = 0.4\n\nlabel_id_offset = 1\ncategory_index = {\n    1: {'id': 1, 'name': 'VI'},\n    2: {'id': 2, 'name': 'MA'},\n    3: {'id': 3, 'name': 'EX'},\n    4: {'id': 4, 'name': 'PC'},\n    5: {'id': 5, 'name': 'ST'},\n    6: {'id': 6, 'name': 'UY'},\n}\n\nplt.figure(figsize=(30, 15))\nfor idx, (image, label) in enumerate(test_ds.take(9)):\n  detections = detect(image)\n  scores, boxes, classes = filter_predictions(\n    detections['detection_scores'][0], \n    detections['detection_boxes'][0], \n    detections['detection_classes'][0], \n    iou_thresh=IOU_THRESH, filter_thresh=SCORE_THRESH,\n    area_thresh=AREA_THRESH\n  )\n  plt.subplot(3, 3, idx+1)\n  plot_detections(\n      image.numpy().astype(np.uint8)[0],\n      boxes,\n      classes.astype(np.uint32)\n      + label_id_offset,\n      scores, category_index,\n      min_score_thresh=0.01)\nplt.show()","e24f8e07":"# \u041f\u043e\u0441\u0447\u0438\u0442\u0430\u0435\u043c \u043c\u0435\u0442\u0440\u0438\u043a\u0443 \u043d\u0430 val_ds\n\ndef evaluate_levenshtein(ds, thresh, iou, area):\n  dist = 0\n  levenshtein = Levenshtein()\n\n  def preprocess_lev(boxes, classes):\n    boxes = pd.DataFrame(\n        boxes,\n        columns=['y_min', 'x_min', 'y_max', 'x_max']\n    )\n    classes = pd.DataFrame(\n        classes + label_id_offset,\n        columns=['class']\n    )\n    df = pd.concat([classes, boxes], axis=1).sort_values(['x_min', 'y_min'])\n    category_index = {\n        1: {'id': 1, 'name': 'VI'},\n        2: {'id': 2, 'name': 'MA'},\n        3: {'id': 3, 'name': 'EX'},\n        4: {'id': 4, 'name': 'PC'},\n        5: {'id': 5, 'name': 'ST'},\n        6: {'id': 6, 'name': 'UY'},\n    }\n    classes = ' '.join([category_index[i]['name'] for i in df['class']])\n    return classes\n\n  for idx, (image, label) in tqdm(enumerate(ds), total=len(ds)):\n    detections = detect(image)\n\n    true_boxes = label[0].numpy()\n    true_classes = label[1].numpy()\n    true_classes = np.argmax(true_classes, axis=1)\n\n    scores, boxes, classes = filter_predictions(\n        detections['detection_scores'][0], \n        detections['detection_boxes'][0], \n        detections['detection_classes'][0], \n        iou_thresh=iou, filter_thresh=thresh,\n        area_thresh=area\n    )\n\n    classes = preprocess_lev(boxes, classes)\n    true_classes = preprocess_lev(true_boxes, true_classes)\n\n    dist += levenshtein.distance(classes, true_classes)\n  \n  return dist \/ len(ds)\n\nlev_dist = evaluate_levenshtein(val_ds, SCORE_THRESH, IOU_THRESH, AREA_THRESH)\nprint('Levenshtein distance for val set:', lev_dist)","f1bad29a":"# \u0421\u043d\u043e\u0432\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u043c \u0447\u0435\u043a\u043f\u043e\u0439\u043d\u0442\ntf.keras.backend.clear_session()\n \nprint('Building model and restoring weights for fine-tuning...', flush=True)\nnum_classes = 6\npipeline_config = '\/kaggle\/temp\/models\/research\/object_detection\/configs\/tf2\/ssd_resnet50_v1_fpn_640x640_coco17_tpu-8.config'\ncheckpoint_path = '\/kaggle\/working\/ckpt\/ckpt-71'\n\n# Load pipeline config and build a detection model.\n\nconfigs = config_util.get_configs_from_pipeline_file(pipeline_config)\nmodel_config = configs['model']\nmodel_config.ssd.num_classes = num_classes\nmodel_config.ssd.freeze_batchnorm = False\ndetection_model = model_builder.build(\n      model_config=model_config, is_training=True)\n \nfake_box_predictor = tf.compat.v2.train.Checkpoint(\n    _base_tower_layers_for_heads=detection_model._box_predictor._base_tower_layers_for_heads,\n    _prediction_heads=detection_model._box_predictor._prediction_heads, \n    _box_prediction_head=detection_model._box_predictor._box_prediction_head,\n    )\nfake_model = tf.compat.v2.train.Checkpoint(\n          _feature_extractor=detection_model._feature_extractor,\n          _box_predictor=fake_box_predictor)\nckpt = tf.compat.v2.train.Checkpoint(model=fake_model)\nckpt.restore(checkpoint_path).expect_partial()\n \n# Run model through a dummy image so that variables are created\nimage, shapes = detection_model.preprocess(tf.zeros([1, 640, 640, 3]))\nprediction_dict = detection_model.predict(image, shapes)\n_ = detection_model.postprocess(prediction_dict, shapes)\nprint('Weights restored!')","e371e8ed":"# \u0424\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u0439\nSCORE_THRESH = 0.4\nIOU_THRESH = 0.3\nAREA_THRESH = 0.4\nlabel_id_offset = 1\n\ndef make_predict(test_ds, thresh=0.5, iou=0.4, area=0.4):\n  predictions = pd.DataFrame(\n    columns = ['image', 'payment'],\n    index = np.arange(len(test_ds))\n  )\n\n  for idx, (image, file_name) in tqdm(enumerate(test_ds), total=len(test_ds)):\n    detections = detect(image)\n\n    scores, boxes, classes = filter_predictions(\n        detections['detection_scores'][0], \n        detections['detection_boxes'][0], \n        detections['detection_classes'][0], \n        iou_thresh=iou, filter_thresh=thresh,\n        area_thresh=area\n    )\n\n    boxes = pd.DataFrame(\n        boxes,\n        columns=['y_min', 'x_min', 'y_max', 'x_max']\n    )\n    classes = pd.DataFrame(\n        classes + label_id_offset,\n        columns=['class']\n    )\n    df = pd.concat([classes, boxes], axis=1).sort_values(['x_min', 'y_min'])\n\n    category_index = {\n        1: {'id': 1, 'name': 'VI'},\n        2: {'id': 2, 'name': 'MA'},\n        3: {'id': 3, 'name': 'EX'},\n        4: {'id': 4, 'name': 'PC'},\n        5: {'id': 5, 'name': 'ST'},\n        6: {'id': 6, 'name': 'UY'},\n    }\n    classes = ' '.join([category_index[i]['name'] for i in df['class']])\n\n    predictions.iloc[idx]['image'] = file_name.numpy().decode(\"utf-8\") \n    predictions.iloc[idx]['payment'] = classes\n  \n  return predictions\n\npredictions = make_predict(test_ds, \n                           thresh=SCORE_THRESH, \n                           iou=IOU_THRESH, \n                           area=AREA_THRESH)\npredictions.head()","411b943f":"# \u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c csv\n!rm \/kaggle\/working\/submission.csv\npredictions.to_csv(\"\/kaggle\/working\/submission.csv\", index=None)","37e22de1":"# \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0443\u043b\u0443\u0447\u0448\u0435\u043d\u0438\u044f\n\n*   \u041f\u043e\u0434\u0431\u043e\u0440 \u0433\u0438\u043f\u0435\u0440\u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432\n*   \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0431\u043e\u043b\u0435\u0435 \u043c\u043e\u0449\u043d\u044b\u0445 \u043c\u043e\u0434\u0435\u043b\u0435\u0439 (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, EfficientDet)\n  *   \u0412 \u0442\u043e\u043c \u0447\u0438\u0441\u043b\u0435, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043c\u043e\u0434\u0435\u043b\u0435\u0439 \u0441 \u0431\u043e\u043b\u0435\u0435 \u0432\u044b\u0441\u043e\u043a\u0438\u043c \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u0438\u0435\u043c\n*   \u041f\u043e\u0434\u0431\u043e\u0440 \u0431\u043e\u043b\u0435\u0435 \u0441\u043b\u043e\u0436\u043d\u044b\u0445 \u0430\u0443\u0433\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0439 \n\n","45fd1b73":"# \u041e\u0431\u0443\u0447\u0435\u043d\u0438\u0435\n","d56ccfde":"\u0410\u0443\u0433\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438:\n","bb519c65":"# \u0417\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u0439","8c080129":"# \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438\n","5da67645":"# \u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0430 \u0434\u0430\u043d\u043d\u044b\u0445\n\n","5c1dba98":"## \u0418\u043c\u043f\u043e\u0440\u0442\u044b","da5cc70d":"# Payment systems detection\n\n\u041e\u0441\u043d\u043e\u0432\u0430\u043d\u043e \u043d\u0430: https:\/\/github.com\/tensorflow\/models\/blob\/master\/research\/object_detection\/colab_tutorials\/eager_few_shot_od_training_tf2_colab.ipynb","1caad721":"# \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043c\u043e\u0434\u0435\u043b\u0438","1c5043a9":"# \u0417\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u043c\u043e\u0434\u0435\u043b\u0438\n","1a45df05":"## \u041f\u043e\u0441\u043c\u043e\u0442\u0440\u0438\u043c \u043d\u0430 \u0442\u043e, \u043a\u0430\u043a \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u043c\u043e\u0434\u0435\u043b\u044c\n\n__SCORE_THRESH__ - \u043f\u043e\u0440\u043e\u0433 \u043e\u0442\u0441\u0435\u0447\u0435\u043d\u0438\u044f \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u0439 \u043f\u043e \u0443\u0432\u0435\u0440\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u043c\u043e\u0434\u0435\u043b\u0438\n\n__IOU_THRESH__ - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f \u0434\u043e\u043b\u044f \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f \u0432 \u043e\u0431\u044a\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0438 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432 \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u0441\u0435\u0447\u0435\u043d\u0438\u044f (intersection over union)\n\n__AREA_THRESH__ - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f \u043f\u043b\u043e\u0449\u0430\u0434\u044c \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u044f, \u0435\u0441\u043b\u0438 \u0438\u0445 \u0431\u043e\u043b\u0435\u0435 1","428135b6":"# Utilities"}}