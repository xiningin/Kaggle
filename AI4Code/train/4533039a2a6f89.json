{"cell_type":{"e6dbacd1":"code","d7a77fb2":"code","1a67dd91":"code","2ab4331d":"code","6f4c8233":"code","e32e66a4":"code","459323cc":"code","3764c3b8":"code","5382d7c9":"code","c7a6e27d":"code","d9252f5e":"code","0902ede1":"code","da9c8003":"code","32082f5f":"code","5a51537a":"code","7321b10e":"code","82152754":"code","14085dd2":"code","0172cff4":"code","9d138be3":"code","233fa7ec":"code","4a12d721":"code","514c0444":"code","4686cf5f":"code","ad161f82":"code","b726933b":"code","fd67f322":"code","5c940b6c":"code","8041025d":"code","5d4e6b58":"code","5cfdc4d8":"code","e19ad770":"code","66e52c1d":"code","73333c0f":"code","15539f01":"code","8190293b":"code","96cc8bd1":"code","068af41b":"code","de0907c5":"code","79bd328c":"code","70968eed":"code","d3124095":"code","c80b5b5e":"markdown","739d00df":"markdown","63e2271a":"markdown","56d5a6b0":"markdown","f83f3ecc":"markdown","f03def46":"markdown","65947d4c":"markdown","0136e652":"markdown","333b21f4":"markdown","861c44e6":"markdown","66563129":"markdown","5196a675":"markdown","ab39494e":"markdown","4c770748":"markdown","6199b74d":"markdown","039fa103":"markdown","3e840513":"markdown","0bc445df":"markdown","5dad103c":"markdown","0a98d197":"markdown","64ec8c8b":"markdown","a10b3861":"markdown","8ba99861":"markdown","9ce137f0":"markdown","c33c79f2":"markdown"},"source":{"e6dbacd1":"import re\nimport nltk\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom ast import literal_eval\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom matplotlib.font_manager import FontProperties\nfrom nltk.corpus import wordnet\nfrom nltk.corpus import stopwords\nfrom nltk.stem import WordNetLemmatizer\nfrom sklearn.cluster import KMeans\nfrom sklearn.metrics.pairwise import linear_kernel, cosine_similarity\nfrom sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer\nimport plotly\nimport plotly.io as pio\nfrom os import path\nfrom PIL import Image\nimport plotly.graph_objs as go\nfrom plotly.offline import iplot, init_notebook_mode\nfrom wordcloud import WordCloud, STOPWORDS, ImageColorGenerator\n\n%matplotlib inline\nwarnings.simplefilter('ignore')\npd.set_option('display.max_columns', 50)","d7a77fb2":"#Loading the datasets\n#metadata of the movies\nmd = pd.read_csv('\/kaggle\/input\/the-movies-dataset\/movies_metadata.csv')\n#movie credits\ncredits = pd.read_csv('\/kaggle\/input\/the-movies-dataset\/credits.csv') \n#movie keywords\nkeywords = pd.read_csv('\/kaggle\/input\/the-movies-dataset\/keywords.csv') ","1a67dd91":"credits.head()","2ab4331d":"#Converting the string into list of dictionaries\ncredits.cast = credits.cast.apply(literal_eval)\ncredits.crew = credits.crew.apply(literal_eval)","6f4c8233":"# Extracting the Casts into a list from Dictionaries\ncredits['cast'] = credits['cast'].apply(lambda x: [i['name'] for i in x] if isinstance(x, list) else [])","e32e66a4":"# Extracting the Director from the Crew\ndef extract_director(x):\n    for crew_mem in x:\n        if crew_mem['job'] == 'Director':\n            return crew_mem['name']\n        else:\n            return np.nan\n\ncredits['director'] = credits['crew'].apply(extract_director)\ncredits['director'].fillna('',inplace = True)","459323cc":"credits.drop(['crew'],axis = 1,inplace = True)\ncredits.head()","3764c3b8":"keywords.head()","5382d7c9":"#Converting the string into list of dictionaries\nkeywords.keywords = keywords.keywords.apply(literal_eval)","c7a6e27d":"# Extracting the Keywords into a list from Dictionaries\nkeywords['keywords'] = keywords['keywords'].apply(lambda x: [i['name'] for i in x] if isinstance(x, list) else [])","d9252f5e":"keywords.head()","0902ede1":"md.head()","da9c8003":"md.describe(include = 'all')","32082f5f":"md[(md.adult != \"True\") & (md.adult != \"False\")]","5a51537a":"idx = [19729,29502,35586]\nlst_1 = ['popularity', 'poster_path', 'production_companies','production_countries', 'release_date', 'revenue',\n         'runtime', 'spoken_languages', 'status', 'tagline', 'title', 'video', 'vote_average', 'vote_count']\nlst_2 = ['belongs_to_collection', 'budget', 'genres', 'homepage', 'id', 'imdb_id', 'original_language', 'original_title', \n         'overview','popularity', 'poster_path', 'production_companies','production_countries', 'release_date']\nfor i in idx:\n    for col_seq in range(len(lst_1)):\n            md[lst_1[col_seq]][i] = md[lst_2[col_seq]][i+1]","7321b10e":"idx = [x+1 for x in idx]\nmd.drop(index = idx,inplace = True)","82152754":"md.adult = md.adult.apply(lambda x : True if (x == 'True') else False)","14085dd2":"# Extracting the Genres into a list from Dictionaris\nmd['genres'] = md['genres'].fillna('[]').apply(literal_eval).apply(lambda x: [i['name'] for i in x] if isinstance(x, list) else [])","0172cff4":"# Dropping Duplicates \ncredits.drop_duplicates('id',inplace = True)\nkeywords.drop_duplicates('id',inplace = True)\nmd.drop_duplicates('id',inplace = True)","9d138be3":"#Converting IDs into same data type\nmd.id = md.id.astype(int)","233fa7ec":"#Merging DataFrames into one\nmd = md.merge(credits, on = 'id', how = 'left')\nmd = md.merge(keywords, on = 'id', how = 'left')\nmd.head()","4a12d721":"# Selecting required columns from the master dataframe\nmovies = md[['id','original_title','title','cast', 'director', 'keywords', 'genres', 'release_date', 'overview', \n             'original_language', 'adult', 'runtime', 'tagline', 'vote_average', 'vote_count','popularity']]\nmovies.head(30)","514c0444":"# Missing Value\nmovies.isna().sum()","4686cf5f":"movies.original_language.fillna('',inplace = True)\n# Fill NA of Tagline with empty strings\nmovies.tagline.fillna('',inplace = True)\n# Fill NA of overview with empty strings\nmovies.overview.fillna('',inplace = True)\nmovies.loc[movies.overview == 'No overview found.','overview'] = ''\n# Fill NA of runtime with 0\nmovies.runtime.fillna(0,inplace = True)\n\nmovies.cast = movies.cast.apply(lambda x: x if isinstance(x, list) else [])\nmovies.director.fillna('',inplace = True)\nmovies.keywords = movies.keywords.apply(lambda x: x if isinstance(x, list) else [])\n\n# If the release_Date is missing, as of now we're putting the date of 2050-01-01 in order to be able to convert in into datetime object\nmovies.loc[movies['release_date'].isna(),'release_date'] = '2050-01-01'\nmovies.release_date = pd.to_datetime(movies.release_date,format = '%Y-%m-%d')","ad161f82":"movies.head(5)","b726933b":"movies[\"popularity\"] = pd.to_numeric(movies[\"popularity\"], downcast=\"float\")\nmovies = movies.sort_values(by='popularity',axis=0, ascending=False)[0:20000].reset_index()\nmovies=movies.drop(['index'], axis=1)\nmovies.head(5)","fd67f322":"#combining the overview and taglines\nmovies['plot_corpus'] = movies['overview'] + movies['tagline']\n\ndef listtostr(txt):\n    '''\n    Returns string by joining the elements of the list\n    '''\n    \n    txt_clean = ' '.join([str(elem) for elem in txt])\n    return txt_clean\n\nmovies['keywords'] = movies['keywords'].apply(listtostr)\nmovies['genres'] = movies['genres'].apply(listtostr)\n\n#movies['plot_corpus_1'] = movies['overview'] + movies['tagline'] + movies['keywords']\nmovies['genre_corpus'] = movies['keywords'] + movies['genres']","5c940b6c":"def get_wordnet_pos(word):\n    '''\n    Returns the tag for the word\n    '''\n    tag = nltk.pos_tag([word])[0][1][0].upper()\n    tag_dict = {\"J\": wordnet.ADJ,\n                \"N\": wordnet.NOUN,\n                \"V\": wordnet.VERB,\n                \"R\": wordnet.ADV}\n\n    return tag_dict.get(tag, wordnet.NOUN)\n\nlemmatizer=WordNetLemmatizer()\n\ndef clean_plot(txt):\n    '''\n    Returns the cleaned plot text \n    '''\n    \n    regex = re.compile(r\"[!@%&;?'',.\"\"-]\")\n    txt_clean = re.sub(regex,'',txt)\n    txt_clean = txt_clean.lower()\n    txt_clean = txt_clean.split(' ')\n    txt_clean = [word for word in txt_clean if word not in stopwords.words('english')]\n    txt_clean = ' '.join(txt_clean)\n    word_list = nltk.word_tokenize(txt_clean)\n    txt_clean = ' '.join([lemmatizer.lemmatize(w,get_wordnet_pos(w)) for w in word_list])\n    return txt_clean\n\ndef clean_cast(txt):\n    '''\n    Returns the cleaned cast string\n    '''\n    \n    for i in range(len(txt)):\n        txt[i] = re.sub(r\"[.,']\",\"\",txt[i])\n        txt[i] = re.sub(r\"[-]\",\" \",txt[i])\n        txt[i] = re.sub(\" \",\"_\",txt[i])\n        txt[i] = txt[i].lower()\n    return txt\n\ndef clean_director(txt):\n    '''\n    Returns the cleaned director string\n    '''\n    \n    txt_clean = re.sub(r\"[.,']\",\"\",txt)\n    txt_clean = re.sub(r\"[-]\",\" \",txt_clean)\n    txt_clean = re.sub(\" \",\"_\",txt_clean)\n    txt_clean = txt_clean.lower()\n    return txt_clean","8041025d":"movies['plot_corpus'] = movies['plot_corpus'].apply(clean_plot)\nmovies['genre_corpus'] = movies['genre_corpus'].apply(clean_plot)\nmovies['genre_pure'] = movies['genres'].apply(clean_plot)","5d4e6b58":"movies['genre_pure']","5cfdc4d8":"movies['cast'] = movies['cast'].apply(clean_cast)\nmovies['cast'] = movies['cast'].apply(listtostr)\nmovies['director'] = movies['director'].apply(clean_director)","e19ad770":"movies['genre_corpus'] = movies['genre_corpus'] + movies['cast']\nmovies['mixed_corpus'] = movies['genre_corpus'] + movies['plot_corpus']","66e52c1d":"tf = TfidfVectorizer(analyzer = 'word', ngram_range = (1,2), min_df = 0, stop_words = 'english')\ncv = CountVectorizer(analyzer = 'word', ngram_range = (1,2), min_df = 0, stop_words = 'english')\n\nplot_vector = tf.fit_transform(movies['plot_corpus'])\ngenre_vector = cv.fit_transform(movies['genre_corpus'])\ncast_vector = cv.fit_transform(movies['cast'])\ndirector_vector = cv.fit_transform(movies['director'])\ngenre_only_vector = cv.fit_transform(movies['genre_pure'])\n","73333c0f":"from sklearn.metrics.pairwise import cosine_similarity\n\nplot_score = cosine_similarity(plot_vector,plot_vector)\ngenre_score = cosine_similarity(genre_vector,genre_vector)\ncast_score = cosine_similarity(cast_vector,cast_vector)\ndirector_score = cosine_similarity(director_vector, director_vector)\ngenre_only_score = cosine_similarity(genre_only_vector,genre_only_vector)\n\nplot_score = pd.DataFrame(plot_score)\ngenre_score = pd.DataFrame(genre_score)\ncast_score = pd.DataFrame(cast_score)\ndirector_score = pd.DataFrame(director_score)\ngenre_only_score = pd.DataFrame(genre_only_score)","15539f01":"vote_counts = movies[movies['vote_count'].notnull()]['vote_count'].astype('int')\nvote_averages = movies[movies['vote_average'].notnull()]['vote_average'].astype('int')\nC = vote_averages.mean()\nm = vote_counts.quantile(0.95)\n\nprint(C,m)\n\ndef weighted_rating(x):\n    v = x['vote_count']\n    R = x['vote_average']\n    return (v\/(v+m) * R) + (m\/(m+v) * C)\n\nmovies['wr'] = movies.apply(weighted_rating, axis=1)","8190293b":"movies['genres'] = movies['genres'].apply(lambda x : x.split())\nmovies['release_year'] = movies.release_date.apply(lambda x: x.year)","96cc8bd1":"def score(value,index_list,feature):\n    '''\n    Returns list of scores for the passed feature\n    '''\n    if feature == 'genre':\n        df_temp = pd.DataFrame(genre_only_score[value])\n    if feature == 'plot':\n        df_temp = pd.DataFrame(plot_score[value])\n    if feature == 'plot_1':\n        df_temp = pd.DataFrame(plot_score_1[value])\n    if feature == 'cast':\n        df_temp = pd.DataFrame(cast_score[value])\n    if feature == 'director':\n        df_temp = pd.DataFrame(director_score[value])\n    df_temp = df_temp.loc[df_temp.index.isin(index_list)]\n    my_list = df_temp[value].tolist()\n    return my_list\n\n    ","068af41b":"def get_feature_set(df1,df2,df3,title):\n    \n    '''\n    idx : index value of the target movie\n    top : index value of top 500 movies(sorted(descending) by genre similarity score w.r.t. target movie)\n    feature_set : Data frame containing plot score matrix of movies which had their index in \"top\"\n    movie_set : Name of the movies which had their index in \"top\"\n    '''   \n    \n    idx = movies.index[movies.title == title].values.astype(int)[0]\n    top = df1[idx].sort_values(ascending = False)[0:500].index.values.tolist()\n    top = df1[idx].sort_values(ascending = False)[0:500].index.values.tolist()\n    feature_set = df2[df2.index.isin(top)]\n    movies_set = pd.DataFrame(movies.loc[movies.index.isin(top),'title'])\n    return feature_set,movies_set\n\ndef get_recommendations(title,cluster_num,df1=genre_score,df2=plot_score,df3=cast_score):\n    \n    '''\n    movie_set = dataframe to store the cluster labels(1,2,3) assigned to movies along with their similarity scores and ratings\n    df_recommend = dataframe with information about the top 50 movies recommended from each cluster\n    '''\n    \n    feature_set,movies_set = get_feature_set(df1,df2,df3,title)\n    cluster_algo = KMeans(n_clusters=3, init='k-means++', max_iter=300, n_init=10, random_state=42)\n    cluster = cluster_algo.fit(feature_set)\n    movies_set['cluster'] = cluster.labels_\n    index = movies_set.index.values.tolist()\n    idx = movies.index[movies.title == title].values.astype(int)[0]\n    movies_set.loc[movies_set.index.isin(index),'wr'] = movies.loc[movies.index.isin(index),'wr']\n    movies_set.loc[movies_set.index.isin(index),'p_score'] = score(idx,index,'plot')\n    movies_set.loc[movies_set.index.isin(index),'g_score'] =score(idx,index,'genre')\n    movies_set.loc[movies_set.index.isin(index),'c_score'] = score(idx,index,'cast')\n    movies_set.loc[movies_set.index.isin(index),'d_score'] = score(idx,index,'director')\n    target_cluster = movies_set.loc[movies_set.title == title, 'cluster'].values[0]\n    if(target_cluster!=0):\n        movies_set.loc[movies_set.cluster==target_cluster,'cluster'] = 100\n        movies_set.loc[movies_set.cluster==0,'cluster'] = target_cluster\n        movies_set.loc[movies_set.cluster==100,'cluster'] = 0\n    if(cluster_num==1):\n        recommend_1 = movies_set[movies_set.cluster == 0] \n        df_recommend = pd.DataFrame(recommend_1.sort_values(['g_score','p_score','c_score','d_score', 'wr'],ascending=[False,False,False,False,False])[1:50].title)\n    if(cluster_num==2):\n        recommend_1 = movies_set[movies_set.cluster == 1] \n        df_recommend = pd.DataFrame(recommend_1.sort_values(['g_score','p_score','c_score','d_score', 'wr'],ascending=[False,False,False,False,False])[1:50].title)\n    if(cluster_num==3):\n        recommend_1 = movies_set[movies_set.cluster == 2] \n        df_recommend = pd.DataFrame(recommend_1.sort_values(['g_score','p_score','c_score','d_score', 'wr'],ascending=[False,False,False,False,False])[1:50].title)\n    df_recommend.loc[df_recommend.index.isin(index),'genres'] = movies.loc[movies.index.isin(index),'genre_pure']\n    df_recommend.loc[df_recommend.index.isin(index),'title'] = movies.loc[movies.index.isin(index),'title']\n    df_recommend.loc[df_recommend.index.isin(index),'director'] = movies.loc[movies.index.isin(index),'director']\n    df_recommend.loc[df_recommend.index.isin(index),'cast'] = movies.loc[movies.index.isin(index),'cast']\n    df_recommend.loc[df_recommend.index.isin(index),'ratings'] = movies.loc[movies.index.isin(index),'wr']\n    df_recommend.loc[df_recommend.index.isin(index),'adult'] = movies.loc[movies.index.isin(index),'adult']\n    df_recommend['ratings'] = df_recommend['ratings'].round(decimals=2)\n    return df_recommend","de0907c5":"def cluster_class(title,cl_num):\n    '''\n    converts each column of the recommendation dataframe into list\n    '''\n    df = get_recommendations(title,cluster_num=cl_num)\n    cast = ' '.join(df.cast.tolist())\n    genre = ' '.join(df.genres.tolist())\n    director = ' '.join(df.director.tolist())\n    ratings = df.ratings.tolist()\n    return df,cast,director,genre,ratings,cl_num","79bd328c":"class recommended_cluster:\n    '''\n    movies   : A dataframe of movies with other information within a cluster\n    cast     : A list of cast for the movies within a cluster\n    director : A list of directors for the movies within a cluster\n    genre    : A list of genres of the movies within a cluster\n    ratings  : A list of ratings of the movies within a cluster\n    \n    '''\n   \n    def __init__(self,cluster_tuple):\n        self.movies = cluster_tuple[0]\n        self.cast = cluster_tuple[1]\n        self.director = cluster_tuple[2]\n        self.genre = cluster_tuple[3]\n        self.ratings = cluster_tuple[4]\n        self.cl_num = cluster_tuple[5]\n        \n    def recommended_movie(self):\n        '''\n        generates a table containing top 10 recommendations from each cluster along with their corresponding ratings\n        '''\n        df = self.movies[0:10]\n        fig = go.Figure(data=[go.Table(header = dict(values = ['Title','Rating'],\n                                                     font = dict(size=15),\n                                                     align = \"center\"),\n                                       cells = dict(values = [df.title,df.ratings],\n                                                    align = \"center\")\n                                      )\n                             ]\n                       )\n        fig.show()    \n    \n    \n    def cast_cloud(self):\n        '''\n        generates a wordcloud of casts present in a cluster\n        '''\n        wordcloud = WordCloud(random_state=1,\n                              background_color='black', colormap='Blues_r',\n                              collocations=False, stopwords = STOPWORDS).generate(self.cast)\n        return wordcloud\n\n    def director_cloud(self):\n        '''\n        generates a wordcloud of directors present in a cluster\n        '''\n        wordcloud = WordCloud(random_state=1,\n                              background_color='black', colormap='Blues_r',\n                              collocations=False, stopwords = STOPWORDS).generate(self.director)\n        return wordcloud\n\n        \n    def genre_cloud(self):\n        '''\n        generates a wordcloud of genres present in a cluster\n        '''\n        wordcloud = WordCloud(random_state=1,\n                              background_color='black', colormap='Blues_r',\n                              collocations=False, stopwords = STOPWORDS).generate(self.genre)\n        return wordcloud\n\n    \n    def get_wordcloud(self):\n        '''\n        plots the cast, genre and director wordclouds in the from of subplots \n        '''\n        fig = plt.figure(figsize=(30,10))\n        ax1 = fig.add_subplot(131)\n        ax2 = fig.add_subplot(132)\n        ax3 = fig.add_subplot(133)\n\n        font = FontProperties()\n        font.set_family('serif')\n        font.set_name('Times New Roman')\n        font.set_size(40)\n\n        def nulltick(ax):\n            '''\n            removes the ticks from x and y axis of the wordcloud plots\n            '''\n            ax.xaxis.set_major_locator(ticker.NullLocator())\n            ax.xaxis.set_minor_locator(ticker.NullLocator())\n            ax.yaxis.set_major_locator(ticker.NullLocator())\n            ax.yaxis.set_minor_locator(ticker.NullLocator())\n        \n        ax1.imshow(self.genre_cloud(), interpolation='bilinear')\n        nulltick(ax1)\n        ax1.set_xlabel(\"GENRE WORDCLOUD\",fontproperties = font)\n        ax2.imshow(self.cast_cloud(), interpolation='bilinear')\n        nulltick(ax2)\n        ax2.set_xlabel(\"CAST WORDCLOUD\",fontproperties = font)\n        ax3.imshow(self.director_cloud(), interpolation='bilinear')\n        nulltick(ax3)\n        ax3.set_xlabel(\"DIRECTOR WORDCLOUD\",fontproperties = font)\n        \n        fig.suptitle('CLUSTER '+str(self.cl_num), fontsize=60)\n        fig.tight_layout()\n        plt.show()\n    \n    def pie_data(self):\n        '''\n        returns a dataframe with frequency of occurence of genres in a cluster\n        '''\n        wordlist = self.genre.split()\n        wordfreq = [wordlist.count(p) for p in wordlist]\n        dictionary = dict(list(zip(wordlist,wordfreq)))\n        lst = list(dictionary.items())\n        df = pd.DataFrame(lst)\n        df.columns =['Genre','Frequency']\n        return df\n\n    def get_piechart(self):\n        '''\n        plots the frequency of occurence of genres in a cluster in the form of a piechart\n        '''\n        df = self.pie_data()\n        values = df['Frequency']\n        labels = df['Genre']\n        fig = go.Figure(data=[go.Pie(labels=labels, values=values, hole=.3)])\n        fig.show()\n        \n        \n    def get_ratings(self):\n        '''\n        calculates the minimum, maximum and average rating of a cluster\n        '''\n        minima = min(self.ratings)\n        maxima = max(self.ratings)\n        avg = sum(self.ratings)\/len(self.ratings)\n        return round(minima,2),round(maxima,2),round(avg,2)\n    \n    def ratings_chart(self):\n        '''\n        plots the minimum, maximum and average rating of a cluster in the form of a bar chart \n        '''\n        minima,maxima,avg = self.get_ratings()\n        fig = go.Figure(data=[\n            go.Bar(name='Minimum Rating', x=['CLUSTER '+str(self.cl_num)], y=[minima], text=minima,textposition='outside',width = [0.2,0.2,0.2],marker_color = 'indianred'),\n            go.Bar(name='Average Rating', x=['CLUSTER '+str(self.cl_num)], y=[avg],text=avg,textposition='outside', width = [0.2,0.2,0.2],marker_color = 'blue'),\n            go.Bar(name='Maximum Rating', x=['CLUSTER '+str(self.cl_num)], y=[maxima],text=maxima,textposition='outside', width = [0.2,0.2,0.2], marker_color = 'green')\n        ])\n        fig.update_yaxes(range=[1, 10],dtick=1)\n        fig.show()\n   ","70968eed":"def Dashboard(title):\n    for i in [1,2,3]:\n        cluster = recommended_cluster(cluster_class(title,i))\n        cluster.get_wordcloud()\n        cluster.recommended_movie()\n        cluster.get_piechart()\n        cluster.ratings_chart()","d3124095":"Dashboard(\"Spider-Man\")","c80b5b5e":"There are a total of 151 movies with 0 votes,but no movie has a popularity of 0.\nSo we can get a weighted average of votes of similar movies in the same genres and also weigth it on the popularity of the corresponding movie.","739d00df":"# DATASET\n\n### Context\n\nThese files contain metadata for all 45,000 movies listed in the Full MovieLens Dataset. The dataset consists of movies released on or before July 2017. Data points include cast, crew, plot keywords, budget, revenue, posters, release dates, languages, production companies, countries, TMDB vote counts and vote averages.\n\nThis dataset also has files containing 26 million ratings from 270,000 users for all 45,000 movies. Ratings are on a scale of 1-5 and have been obtained from the official GroupLens website.","63e2271a":"## movies_metadata.csv","56d5a6b0":"## Vectorization \nIn order to perform further operations on our text, we need to transform our documents into vector representations such that we can apply numeric machine learning. This process is called vectorization.For vectorization of text corpuses (or columns) \"CountVectorizer\" and \"Tfidfvectorizer\"have been used.\n\n\"CountVectorizer\" counts the word frequencies. With the \"TfidfVectorizer\" the value increases proportionally to count, but is inversely proportional to frequency of the word in the corpus; that is the inverse document frequency (IDF) part. The IDF feature of the tfidf vectorizer helps in dealing with the redundancy that might be caused by common words in a corpus consisting of sentences such as our overview column.\"Tfidfvectorizer\" has been used to vectorize the 'plot corpus' and countevectorizer to vectorize genre,cast and director columns.","f83f3ecc":"# DATA PREPARATION","f03def46":"genres are also in JSON format, so we'll handle it in the similar way we have handled it so far.","65947d4c":"Calculating average of the ratings alotted by various users would give biased results because of the discrepancy in the number of ratings each movie received. Instead we use the weighted rating formulae.\n","0136e652":"# IMPORT LIBRARIES","333b21f4":"## !!! Takes a lot of time, so a csv file has been saved, use that !!!","861c44e6":"### credits.csv","66563129":"### keywords.csv","5196a675":"***credits*** contains the cast, crew and id corresponding to various movies. As we can see, the cast and crew columns contains a list of dictionaries but it is in the form of strings somewhat resembling a JSON format. Hence we'll use literal_eval to convert in from string to list of dictionaries and then extract the Cast and Director from the Crew columns.","ab39494e":"![](http:\/\/data:image\/jpeg;base64,\/9j\/4AAQSkZJRgABAQAAAQABAAD\/2wCEAAkGBw8PDQ8PDw8PDw0PDRAQDw8NEA8PEA0PFxEWFxYVFRUZHiggGB0lJxUVITEhJikrMC4uFx81ODMtOCouLisBCgoKDg0OGBAQGi0lHyUtLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLf\/AABEIAIcBdAMBEQACEQEDEQH\/xAAcAAACAgMBAQAAAAAAAAAAAAABAgAFAwQGBwj\/xABHEAACAQMCBAMFBAUJBgcBAAABAgMABBESIQUGEzEiQVEHFDJhcSOBkaFCUmKxwRU0VHKCk7LR0iQzQ3Pw8SVTdJKio+EW\/8QAGgEBAAMBAQEAAAAAAAAAAAAAAAECAwQFBv\/EADURAQACAQIDBgQEBgIDAAAAAAABAgMRIQQSMQUTIkFRYTJxkcEUUqGxIySB0eHwQnIVM\/H\/2gAMAwEAAhEDEQA\/APMgK73lmoIBQGgYCgIFEiBQMBUAgUBAoGC0BxQHFAdNEppoDpoJpoJpoJpoBpoJpoBiiAxQAigGKAYoBigGKBSKkDFEBigBFAMUAxQCgFAKCUEohKAVIlAKCUEoJQSgyVCTCgNAQKBgKJECgYCgYCoBAoGAoGAokwWggWgOmiB00SOmgmmgmmgmmgGmgGmiE00SBWgXTQArRAEUC4oARQKRQAipAIoFIogCKAYoARQCgFAKCUAohKAVIlAKCUEoJQZahJqAgUDCgYCiTAUDAVAYCgYLRJgtAwFAwFAQtAdNAdNBNNAdNBNNANNBNNACtANNACtACtANNApWgUiiCkUAIoFIoFIoARUhSKAEUQUigFAMUAoAaAUEohKAVIlBKAUEoM1QkwFAwFEmAoGAqAwFA4WgcCiTBaBgtA4FAQtAwWoSOmgOmgmmgmmgOmgGmgmmgGmgGmgBWgBWpQGmgUrQKVoFK0ClaBSKIKRQIRQAipCkUC4oARRBaAGgBoBQCglEJQCpEoBQSgzgVCTCgYCiTgVAcCgYCgcCiTgUDgUDhahJgtAwWgYLRI6aA6agHTUiaagTTQTTUgaagTTUgaaIKVokCtEFK0ClaBStApWpQUrQKRQIVoFIoghFApFApFSFoARRBaAYoBigFAKCUQFBKkSgFBsgVCTCiTAUDgVAcCgyKKJOBQOBUJOBQOFok4WgYLUBgtAQtAdNBMUBxQTFAMUExQDTQDTQDTQArQKVqQpWgUrRBStAhWpQUrQIRQIRQKRRBCKBSKBCKkAigUiiC0ANAKAUAoJRAVIlBKDZFQsYUDgVAcCgyKKJOBQZFFBkUVCTgUSyBagMBQMBRJgtAQKA4oJigOKCYoBigmKAYoJpoAVoFIoAVogpFApWpCFaIKRQIRQIRUoIRQIRQIRQBULMFUMzHsqAszfQDc0mYjqRWZ6Lvh3JXEriUxJbNGwRXY3BWEIjFghIbxHJRhsD8O+Nqp3seTWMFvNYL7OLw2y3Blt1RmRQpaQsC0ixjPhx3O+\/YfdVe99lvw\/uxcT9nl5B1syW8hhFuCEaQGSSaQokaZUZYnHp8QFO+9kfh58pc7xXg1zaSNHcQPE641Z0uoz2GtSVye+M5wR61pF4llbHavWFfVlANAKAUAoJRAVIlBtCoWMKgZAKB1FEsiigyovYdyTgAdyfQVBCwXhFzqKe7zalKBgY3GgvjTq28Ocjv61TvK+rTkt6Ozh5bt4pIbKaAXFyYg7vBK0bpJklgT2KAEDt+ifWvHydoZIyzFN4etj4DHOGLW2lTc48IgtLiOOEnxwh3jZuoIzqIGGwMg4r0OEz2zU1s8\/iMVcdtIUqITnAJwCTgZwB3J+VdTnECiTAUDBaA4oDigmKCYoJigmKAYoJigGmgGKAEUAIoFIoFIogpFSEK0CFaIIRQIRUhCKIW\/LPLxvrmKN3MEErugm0nxuiazHGSNJkxvg+QJ3xis7302htjxa7y9WuLG04MkNzEqw26MYbrcs8iSkASebO6sqbD9FnwNgKynXWJbxppLgOZfaJcTXBey1WqdPpa2CNNIok1AnOQvn23Gpt\/TSMeu8srZtNocZcXk0gxJNNIN9pJHcbtqOxOO+9aRWseTCb2nzYre4kiOqKSSNtRfVG7IdZ\/SyD3+fenLWfIi9o83WcD52AQ2\/Eo\/erRpTM66FZ55sEgzlieooIQgY20jyULWVsWnRvTPrtZoc4ct+7EXEGmSzkO7wa3t4ZSc9JJW\/3igEAN5kEbEECaX12lXLiiPFDmDWznKaAGgFBKICglSNsVCx1qA4FBkUUSyouSABknYAbkmolMRu9V5O4FHDboJU6V8zs0hKI8yJ2CqQcptg4G+52rweN4icl5pW23s9fhMMUpF7V3925zO7QvbtAsqANmW6RCfCwCnVthjhVGD6b9q48mtdNPLzehgrFotzab+Sy\/km1uXSYqVkJ1FxqRpxvkEHtv5Crctbz\/u7PvL01j\/YV\/NdykU8ESiNi\/glW4XqRFD8Jkzkkg7g98scdzUze2O3gnROLFXJWZvGv7rWx4ZbmMoFhCSKRJ0ESNJlIxp8PfG+\/erxkteY5rbwwmlaaxFdNXnPNnAzZ3TqquLdiDC7A4PhBK6vMjNe3w2WL0jWd3lZsfLadI2UwFdDEcVAOKA4oJigGKCYoJigmKCYoBigmKkDFApFACKBSKBSKIIRQIVqQhWgQiiGfhvDZbqYQwo0jlS5WMoJOkuNZXVsSAdge5IHnVb2mIXx05peyXVvYLwcaZOlZwxrLFPHgSRSo2VkUH\/i6+6kbsSpG5FY9YdXR5BzHzFc8QkV7hhhBhIowVjjyBkhcnc475Pp2raldOrlyZOaduilYVozIRUIIaBDUjruSbpZxJw64YtHOjRwYjM88bFWYrBqOiLOkHVjuB9RhlrpvDpw318MuRuIGjkeNxiSN2jcd8OrFWGfqDW1Z1hz2jSZhiNSqFAKAUEogKkbgqqx1oMgoM0MbOwVFZnY4VUBZmPoANzUa+q0RM9HZcncr3HvK3FxFJbwW2JiZoypkYHwoob5+dcfF561xTv1dXC4LWyRs7flbirzKXJg0qxBfT9vOAfiIHbuN68ClpjedHuZscRtGv2XcNuzyu5KdJ9OpDl9eAPI7L93zrWJtefLT0c\/hrG2uvqHErl4wZI0E3S1dRUPjwVyAFHnjFXvE\/FBSItPLM6Ke64w9usfvhQdZ5C8aYcxQMF0Fttypz+eKzyzpyx9WuLFNubl8uhP\/AOsjitVlET6nm0JlGEboGOSHG2wzsdyewxSl4rXaFvw82vpqnMPDX4rBBLbyqI1PwSBlVixALhu+3pjetotOsWrLOIrTmpkjXV5\/xbh7Ws7wOULLjdGDAg9vp9DXt4cnPXm0eJlx8lpiGpWjMcUBxRKYoJQDFBMUExRCYoJigGKAYoBigGKkKRQKRQKRQIRRBCKBGFSPRvZLBGnWdzpuZ1HRRiMSWyHxSR7b+IlWAJ06FzjNYzbWzppXSkKf2o3CLdtbQsQjFLi6iVvAbrSdLafIlWBPqdJ2IJKkb6q5rTy6OGIrdzMZFBjIoghFAhqRt8EOLy2Ph\/nEXxhCuNYzqDEKR9TiqZPhlfF8cG5ldWv7or8PvEgGBGAMNjYISuNv0TimP4YM3xyrKuzA0CmgFBKISg6ThlpZmynmnkl95WURwQRsiq+pM63ypOBg57eQ86yyXmvR0YscX11lZ8l8ItJZjNezQxWkJ3WaVUNxJ5KBnOkbEn6DzOM+e8tu7xx1XHOfF+GpELbhsNrqkH21xDCmVj\/UV8ZJPmfT67Ry3nqRbFXop+WOK2lok7yxyyXUkTxRMoTp26MhBbJOdRz6dh8zWebh73x2rE7zEtcHF0x5a2mNomJ\/V0vB7Ce9QvAjOAFLBmRCA2cbMfPBr5SeB4ib2x9Zjru+1jtLhox1yTtFumx+H8JuLguIU1GMgP4kXSTkDuR6GsMPC5cszyR067t8\/GYMMROSevTY3EeE3NsoeZCis2kHWjZOM+RPoatm4XPgrE32j5q8PxnD57TXHvPybKctXxAIi2YAg9WLcEbfpVtXs\/ip3iP1Yz2pwcTpr+k\/2akHCriSd4FTVNGCXXUmwBAO5OD8QrCvDZr5JxxG8e7ovxmCmKuWZ8M9NmW94DdQxmSWPTGuMnXG2CTgbA\/Or5eCz4qc142+bPD2hw2a8UpO\/wAirwe66HvAT7DQX1a0HhHnjOfyqscJn7vvNPD16rTxvD973Ovi106ef0bHLPF7iFZBDw64uS7giTCQoQBjZ27\/AHV73ZuG+LHPN57\/AKPnO1eIx5sscnlrC7fmG7A\/2ng8wTz0SQ3Bx\/VwK9HWXl8sSr2tOFX+RGvu1x+oq9FwfnGfC33fjVoyTDO2GHK8a4JLaNh8NGThJV+Fvkf1T8v31vW0Wc1qTVWVZVKCUEoJQSgmKAUAxQDFAKIAipCkUCkUCkUCEUQxSbAn0B7b0lMdXt\/D+BxPw60glUBooYmR4sxPBPo3eJhuhyzdvIkHIJFYaaw69dJeJ8WkeS6uHkfqSNPJmTwapAp0IzacLq0qucADPkO1aY+jnyz4mkwrVixsKDseUOGWwtJLqWCW6u+oUgh6bNGgChhJgdx38R22wATmvO43LMxOOLaavQ4XBExzTGqql5PustJKIrSLUxzPIFCDy7ZH3ZzVqcbSKxWNZn5ItwGTWZ2iPeWdOTUPRHXkkNyzJDNBHEbfqCNnwSZNZHgbcKO1R+OmddtNOuvVb\/x8bb669Jjop+W+H3TXCzRW0zmAs+yOAJUB0rq8jqx55GD6V05s1Ir1c2DDebaxE7Ke4Rw7iTPUDsHyQTrz4s4885reumkaOe2vNOrEalUpoAaAUAoJRDcFQsz20DyOscaNJI5wqIpZmPoAKTOnVMRq7Gw9m\/EJIy79GBsZWOVyXb66QQv4\/hWVssR0bVwWnrsrRa3nDLpTJboJQMqtxHHNGwz3B7feCDWU3tLorirHk9K5E4+15eSu8axSSQKHVGLKzxkYIz22Y7b9u9edHh4uY\/NX9nqT4+BrP5bTH1j\/AA2+Wh0uKXsPYN1GH3SAj8nNcXBeDi8tP96\/5d3aH8TgsOT5R+n+Gzz+ubND6XC\/mjite14\/gR82XYc\/zM+8T9l7wt9VtA360ER\/FBXoYJ1x1n2h5fERplvHvLmeWt+K37enVH3dYf5V5XA78Zln\/er2e0NuBwV+X7f5bXP8+mzVf151z9FVj\/AVr2tbTBEeswx7DprxEz6QPG4tHC4bcfFKLa3+eTpLf4TVuIjl4WuP15YV4S3Pxl8s+XNb+zj\/AGoc9S2MyWNquljCsssmdJVWLBUH\/tJP1FenGldtHkzrbfVyXLvtNuYLiPrZkt3kVZQXLFUJwWGfMd\/uq02ifJWKzHm9a45w2KXcqNY+FxsQfkaotqrURpIJI5vtUXwvnvp8if8AP5UidCY1hwvErMwylO690b9ZfL7\/ACrqrbWHHavLOjVqyqUEoJiglAsjqoyzBR6sQBToaS0\/5UjZ1SPVNI7hEWMbM57KGOBn76pOSsNIxWkeIJfRTm3kt1tJ9GtEuWy0q+qFfC3zwTjzrOcrSuCPOUuLK3ey94\/lD\/aoWxd8OvXjs2bbtAVPj7Ejc6v2TtVJtM+bSKVjyavCWTqSCJXEDBHXUrAK+MMuT37A9zWuLXzZZ9NlnWrnKRQAipCEUCkUGNxsc7DG53GB92\/4VE9E16w9k4bw67ihha1vepEY42EXEEM4ClBskylXH1bXWEROjrmYeNcQhdJ50kTpyLcTB0GogHqNuCdyD3B9CK2x\/C5cvxy1WFXZsMg2P0pPQjq9b5nvbuK2jNkgOoeOQIXEMYTOQgz+49u1fP4a45yT3k\/\/AF9FmtkjHHdQ8yure4uZ2606uyymITTSMIy+caUyM\/cF288V7Fb48dI5a++0bvFtTJlvMWt56azO2vs37Dj6W9stpcwTNLa3JntxFJ0dLkNlZCDqA8bdvXBxWWTBOS3eUmNJjfXdrj4iMVO7vE61nWNJ0YIedL0XSTvIWjUn\/ZkPShKkEacDPbOcnJ2q1uBx8nLHX180V4\/L3nNPT08nNzFSxKLoQk6U1F9A9NR7\/WuysTEaS4rTEzrEMZqVSmgU0AoAaCUQsLZkEiGRS0QdTIqnDMmRqAPkcZqJWjq6fmDgdpA6+53q3KNg6dPijHkda+FvyrjmZ13ejWI02bljxziKQ9MXcoiOweUrkD0SRhq+4E9qhZXu65LMWmcnJZiQpPqSfE3\/AMaDoeQr0rxCHOkKW0gKAo8QKff8S7nfauDivDlxX95j6vQ4TxYM2P2ifo7OYdLj6HymQZ++Mr+9BXHbwdox7x9ndT+J2XaPyz99fusOeFzYN8pYz+eP4109qxrw8\/0cvY0\/zUfKVhy8c2Vr\/wCnjH4KB\/Cung\/\/AEU+UOXjY04jJHvKg5M8V5fv+3++Vz\/CvN7N3z5Z9\/vL1O1tuHwR7faA54+0uLKAfpOcj+u6qP3GnaniyYsfunsfwYs2X0j9omWv7UOYPcI7aYRiUxTdURltAchlQb4OPiY9vKu3P4s+Knzn6Q4OF8PD5r\/Kv1lx\/PHLj8dgtuMcLBlZ4BFLbMUSTwO3bJxqUllIzuACM+fa4HP8p+zDiM91GbyBrW0SRWmMzLrlUHOhFBJycYycAAnv2oLXmr2rSm5kisIoejG7J1pwzmYg4JVVYaV9O+fl2qDRf8l80C6eN3VVZ1KSqPhZezDf07\/SrTG2qkW3mG3zpwrRGzAbwyDf9hiB\/FatjnSdFM0axq4quhypRI0AoKy9lPX0POYITFqUroUsQ2CNR89x2rHJa0Ts3w1rMbsfD762guo5o4F4gB4ZYbxOojL+ssj\/AAOPI4I+VZRrLfaprpeo8ywxw21lIfBbXE3vRh9dBAGB56cnHkavGPVScsejZuGkniiiur6W5jgx0kd0AQgYyCPET5ZJJq8Y6+cs5y28oCC3t4\/gEQPrlSfxO9XiIhnM3lsiVTsGUn0BFW1V0kcUQBFEARQKRUhCKBGWkkPWuXOL3kllbFLBnQW8aiR7u3XXpUKSQMkHwnyrniZdkxHq8653spo+ITPLb9AXAWddMnWRmbKt49IAbKZK\/MHzrTHPkxzR0mHPMK1c7GwoPQeRuLyvZzRECSS3UmBXJGuMKPs8\/LIGfLWPSvH47FWuSJjpPV7XAZrWxzWesdGhZcH4Ve\/bi6lhUeKS3kkjQxsTqY5IzgnzB+8YwL2zZ8Mckxr77s64cGeefWY9tmnzXd8NdYba3maKCLJb3WATI7eRLF11n55P41pwlM0Wm94+rPi74JrFKT9N3GXKoHIjZnTyZ0EbN\/ZDNj8a9GNfN5kxGuzCasgpoglAKCKjHUQrMFGpioJCL6nHYVE2rHWVq0tPSGRLOViAInyYGuACpXVAASZBnGV2O49KznNT1afh8no3eGcuX11EJre1mmhJIEkYBUkHB86d9Q\/D5PRritGS44XcEIQMalwMsA2B8s7ff8q5stdJ1dmC2tdPRsu5Y5YlifNiST95rNuaOFmBKqSB3x5VlfNjpMRaYjVetLW6Rq2eETGK4jbsVbP3jcfmBXNx2k4eeN9JifpLt7O1jiIpP\/KJj6w9O5vYJeWFyO2V3\/ZWQN+5zXD2htmxZY\/3d39lxzcPnwz\/ALtP9ltzkueHzfIxn\/7Vrs7SjXhrf0\/dw9kzpxdP6\/sz8rtmwtj6R4\/BiP4VpwU\/y9Pkz7RjTiske6i5A3a7f1eP97n+NcPZMa2yW9\/7vR7a2rir7f2G\/wDteOwp3ESLn5EI0n8RUZZ5+0Kx6GH+H2Ze35p+8Q4P263TSXEFtGGeQlFWOMF3chS2Ao3P+8X8K7KeLi7T+WsR9d3DbwcFWPzWmf6Rt+62t3u+XuU9ege+9TUVbxLbNNLgavUgY+Wo12vPavsb55v+Iz3FreuZ1W3MyTaFRozrVSjaQAc6sj+qalLyzmLgE\/DLl7e4RlVWYRSkfZzx58LK3Y7YyO4oO29mnD5cPLIjJFkmMuCvUyuCQD5dt6nXbRSY8Wr1nmuHVZTse\/uuo\/ULn+Aqa9YL\/DLyaulxJRKUEoKvigBuLfMXWGib7Pw7\/Bv4ttqxy+TowebDc2ofSosWjQuOq6C2MojzuI8nAY9snt86xdDY4qscs4aDhSwW0UQSCIdDXK2N5LmTOZG\/H8TQK8MYskt4+Gk3Mkmu7vJVtjIq\/wDl2oyemvlnvj5nZqH4UkUUkss3CveGWIpaQP0Pd1cjHUuPFmQ9sDG313CCWhHb6Ht9VuY5GuNTyYiVWJViURUPhX0A22q1PiUyfDK+rqcQYoARRBSKBSKkIRQdlyLzfa2VtJb3cmjE5e2SKGaVmjcAsCsanfXqOfPX9awmeWdHVXW1YbHOurikMclrw6+d4CzJPMsdmhjIGsaZWDv2BGF7jvUc066xCZpExpLzcMGAZSCpGQR2IroidYccxMTpJGFSh1nJpaK7tiCmiW1kVVDqXkcsXbwDJyOmBkjso+VebxU81LbbxL0+EjlyV32mP1lWcZ5c6ctzI0sUFuCzwdQ5aYnxCNUG+2SCceXnWmDi+ataxEzPn7M+I4TS9rTMRHlr5+zmDXe84hqQhoENJnTqRGu0Nqw4XPOHeON2iicLPIqgi3H6TMCR2Hrj0rG2bTpu6KcPM\/Fs9F4R7Hyyqb25KNqYslpg5XbSNbDC9jnY9++2+c89ustorSvSHcWfJPDouqRBrM4QTh2bpzBRhQ0KkR4GTsFA3NOSFpvLV4NwW0TifEUW1tljWGw0IsEQVcrNkgY2JwM\/QVEVjmkmZ0hdScv2LHLWVmx9WtoCfxK1blhXWXzaK6HC2rKTS49DsapkjWrXFblsuI01MFHdiAPvNceS3LWbT5O+sazELq7Zcle4B0oMnw42J+uzb96+ZibT4tXs1rEbNSywZDu2xXv4xksFHfJ3J8vnWs1maT7\/ANGlLct6z7u\/48erweyl7lCsbH6IyH80FW4ue84PHf0dHA6Y+Py08p3j9\/uv+OS9XhUj\/r28b\/4Wr0eJnn4Sbezy+Dr3fHVr6WmE5Rk\/8NiP6ol\/KR6js+f5Wv8AX7nadf5y0fL9oVvs5X7CY+ZlUfgn\/wC1z9jx\/Dv83X27P8SkexeA\/a8YvJfJA6j66lQfkpqvC+Pjcl\/TVPGfw+z8VPXf7\/dxvNvtAawnuFto45Lya4dtcoLRwwKdCbAgsx0ttkYxk5yK7eD8U5L+tp\/TZw8d4a4sfpWP13aXKntVkuLhbPisNtLa3TCEusZUIXOAJEJKshJAPbHfeu1wOg565htOXI0teGWVul3dDqv4SEjjBIDSYOpznUFGcDDfQhx3BfardGZVv1he3dgGkijMbw5PxYyQyjzGM48\/IwjR6P0y8qoO7kLkeh7n8MmgtufbgRcNl\/WlKRKPqcn8g1aY48TPLOlXktdDlSglBBQaVx\/O4P8AlXH7krDL5OjB5uq5W4Nwd7Dh7zR8OeSS0LXb3F60UyzaRoGgNvk5z2xtsaz0bq7mKxsYbnhvua2qSSW9ybtLO4NwiyAQ4Gok7DL42GaiSB5e4VYPwuykEHCprtxP7yeIcQktZFInYJhVznb1x2HfNCVhacFsjKgls+X1hLqJGj4vcM6pncqCACceWRn5U0HG3CIsgWLHRXjF0sWk6l6QaUJpPmMY3q1PiVyfCtK6nCFEhQA0QUigQipGxwniMtpcxXEJUOjANqXVrhLDWnqMgeXyql667w0x30nSXtHA+Lw3tulxAxKP3B2eNx8SOPJgdiKpEtujzPmzl+Oa6mbhcfVSFJXvFgXMaXGoNojYHDSHLExqNtskZAqK30nboi+PmjXzcXIpBIYFWGMqwKsMjIyDuNiDW8TE9HLasx1ZuEcQa1uEnUBmTVtsMgqR3IOO\/pVMuKMleWV8WWcV4tBeO8VkvJzNIFBwFVV7Io8vU+Zz86jDhrijSqc2a+W2tlY1bMWJjSduqNNeix4Dy\/dX7ottE0kZcq8ylDHCARqLEsMEZGB3O+M4OM7Zfyt6YJn4tnofJfs8tQ84vR17izuxGNDSJC2beGVWK58WOoQO3bcemW9p8To0rWPDDuOYuHK\/DL22jVUEllcxoqKAqs0TAYUfM1MxsRM67tvg16Lm0t7hfhnt4pR\/bQN\/GprOyJ6ttjgZOw9TsKajn+GTp\/K3EPtEOq34fpwy7494G3\/XnVYndaekOhx8qvqq+WxWzhOKDp+XnDMGK5KKzk5OcgdgB5\/X\/v43ac8uKY9dIevwfjtEtuUEEknO3cbg\/Mfn+NeJMxOz2Yhs8GhDNqUIw1rkr3DBjnOO+M9vXNa7xGkqXl2VsC\/B7uMjBgnLAHuF1I\/+qrUjm4LJT8s\/5dHNpx2HJH\/KI+8LO0k6nAm\/ZtZlP9gt\/ACurFbn4Cf+suXNXk7Sj\/tE\/U3KkmOFOf1BcfuLfxqez7fymvzO0668dp68rH7Pzps5WPYXDE\/QRIf86p2RtgtPuv254uJrEen3avJMmiG9um+pP9VWdv8AEKy7NnSmXNLbtevNkw4K\/wC6zp9nnHOfKjusNygOt4E1nBwxOSM+mx2P\/Q9TgKR+HrHn1+u7yO0sn81efLp9NnOcp8n3d7fwxCGRIUmR55mUiOOJWBbD9mY4wAPM+gJHRMaOWLRMbO\/9uXKlzNPDxG3jedFgEE8cSl3jCuzI4UbkeNgfTAol5\/wPlaWZ16sbBSfgI3b+t6CrxXTeWc312h7xy\/Z4bqN+ioRfkPP7zWa7kOfeOC6uBFGcw2+RkdnlPxH5gYwPv9a6aV0hy5bazo5ers0oDQSg05f55b\/8uf8AclYZvJ0YPNXzaUCs8lgA+dJNsfFg4ON6xdDNaBvC8UlkNeoIyQMpbT8QG\/lipGCF0kcKstgzscAC3bLH8agGbSgUtJYKG1aSbc+LScHz8qkZS4ZLQq0TD3s7wIUT4H8vWrU+JTJ8K2rqcSUEoFNApFEFNBjNSHivZY1dUkl6ciqskKTywJMgfUVLLuucsMjfxHv2rO9Nd4a48k12no9T4DzZwlbQrHJDZx2sKs9u+I+ghAPhH6YycZXOT86prEbS205t+rSi4BHxa4a+urboW5iaK2QoI7q4Rv8AjztjUv7C9xkk7nAiI1nVMztoqOOezqBJbZLe4lDTyiMQyBXJRQXkkMmPDpUemCdA2LZq3NaPNn3dJ3mGvH7J7jDa72DOPAUhkAU57sC24+QIq3PZXuqe7Dw72ZLLNPBJfNm1aNZXgiUB2kTWFAYnRpBXzbOvyqvPaZ01X7ukR0XPFeQuH2VtJOolkl1WyMZZWKdNriFJFKLhSGGQQQc5NVtXzaVnyh6DDCsahI1VEUYVEUKqj0AGwq8QpO7lbnj9tY8TvxPIFjaytbk6FaR9aNLFJlVydgsHl5iqaxEraaw5zjHtcjHTFpbF0YnqPcEq0ahyD9kNmJAyPENiM43Atpa3SFJvSvWXnqc1Xywe7JcyLaLE0UMSsYjAmfCQ8RUswG3iyN+3bFow+ss7cR6QqPeJMuxkdmkjaN2di7Ojd1JbJwcCrRhpDOeIvPmxI5WN4lJWKXT1EGyyaTldQ88HcVbuqeivfX9VnwzmK7tYulBKqxgkhWgt5cE+hdCQNu2cVHdVW7+\/q1RV2R1oNq0uWjZWU\/CwbHkT86zy4q5azW3m0x5bY5iY8ln\/ACqG7hk+SkOv57j6A149uyrR0mJ+e0vWx9q06XjT5bun5eeObSBofSwfADRkMN84O351w5uHvinxR+urrpnpljWkustrmKJ7yKUlFubVSMgt49LJjw59fyrLh8lY72lv+UO7u75MeK9I1mtv7Sx8v8VhXh1zBK+l2EwRdLnIaLHcDA3zU8HxFI4W9LTvv+zbj+GyW4ymWsbeHXp5SnAuKwx8NuInfErdYIulznVGANwMDfNTwfEVpwl6zO+\/7I4\/hsl+NpeI22\/ceC8Whh4XPGXxO\/W0rpbuyBRvjH504XPTHwdo133TxnDXy8dSYjbb+7BacRhi4RNEH+3lZsrpbsWVTvjHZT51TDkpXg5pHWZ+6\/EYMl+OjJMeGsftGv7r\/hd\/DPAjINcWkKMgqy4GMb19DFeSIq+Xtfnmbeq2tpFGyMB+yUx+Y2qUGubg47r9wJoKiSEFsnt3OABmoHJcxc2ZVre1yq7q8uCpI81Qdx9f+9b0x+csMmTyhyFasBoJQSgNBr3Vr1NLBmjkQko6YyMjBGDsQarasWhel5rLF7rP\/S5f7uH\/AE1TuoafiJ9E91n\/AKXL\/dw\/6ad1B+In0T3Wf+ly\/wB3D\/pp3UH4ifRPdZ\/6XL\/dw\/6ad1B38+gx2Ta1eSZ5SmSgYIqqSMZwoGTUxjiN1bZZmNG5WjFKJCgBoFNAhogjVIxtQYnHfdhkYyrFWxkHuN+4B+4VE1ieqa2ms7Og4dz3xGDSDKk8SgDRcKXc4XGernVknc5z3OMbYr3c+UtO+jzhtWPtBdbt7u5thNKYVt4kgk6aW8OdUhXUCSzsEzv2Rd9qr3duq8ZqTs6KH2q2JYiSK5QCPWXCxumdsr8QbIyfLGxwTtmszMdYWjSekq3lz2hWEUd\/cP13km4jJMyRxgkRsBHAMswGdEKk77ZNVrbqvavRX82e0lbuB7WC3ZYpUUtO7ZdGBDgCPbcEAE6vXGavy2sznJWk7y5zivPXE7kKHuTGBq1Jbqscb5OwIwSQB5Emrxj16yytn\/LDmjnCqSSqZ0BiWCZJY6c9skk\/Uk1pFYjoxte1uskNWULQA0CmgBoP\/9k=)","4c770748":"Due to the limited computing strength available only around 45%(20,000 rows) of the data has been used to work upon.","6199b74d":"***keywords*** contains the keywords and id corresponding to various movies. As we can see, the keywords columns contains a list of dictionaries but it is in the form of strings,similar to ***credits***. We'll handle it in a similar way.","039fa103":"# DATA PREPROCESSING","3e840513":"### SUBSTITUTING NULL VALUES  ","0bc445df":"## Text cleaning\nBefore vectorization a certain level of cleaning is required. This includes:\n* Removing punctuations\n* Converting the text documents to lower case\n* Removing the stopwords: Stopwords are the English words which do not add much meaning to a sentence. They can safely be ignored      without sacrificing the meaning of the sentence. For example, the words like the, he, have etc\n* Lemmatization : Lemmatization is the process of converting a word to its base form. \n\n**Note** : Another way of reducing words to their root form is stemming. But stemming just removes the last few characters, often leading to incorrect meanings and spelling errors whereas lemmatization considers the context and converts the word to its meaningful base form, we decided to use the latter. ","5dad103c":"## VISUALIZATION\nAfter we have the recommendations we need to present it in a way that is easy to comprehend.\n* We are going to print top ten recommendations from each cluster.\n* Wordclouds to represent prominent genres, casts and directors in each cluster.\n> (Word clouds or tag clouds are graphical representations of word frequency that give greater prominence to words that appear more frequently in a source text. The larger the word in the visual the more common the word was in the document(s).We are going to make three wordclouds for each cluster.)\n* Pie chart to represent genre frequency in each cluster\n* A barchart to represent maximum, minimum and average ratings of each cluster\n\n","0a98d197":"# **INTRODUCTION**\n\nRecommender Systems are used to generate recommendations. The two main types of recommender systems are either collaborative or content-based filters.\n\n* Collaborative filters : This type of filter is based on users\u2019 rates, and it will recommend us movies that we haven\u2019t watched yet, but users similar to us have, and like. To determine whether two users are similar or not, this filter considers the movies both of them watched and how they rated them. By looking at the items in common, this type of algorithm will basically predict the rate of a movie for a user who hasn\u2019t watched it yet, based on the similar users\u2019 rates.\n\n* Content-based filters : This type of filter does not involve other users if not ourselves. Based on what we like, the algorithm will simply pick items with similar content to recommend us.\n\n* Hybrid Engine : Ideas brought together from content and collaborative filtering to build an engine that gave movie suggestions to a particular user based on the estimated ratings that it had internally calculated for that user.","64ec8c8b":"The \"adult\" column has 5 values instead of 2 (True and False). So first let's handle this column itself.\n\nFor these three movies, the data seems to be all jumbled up amongst various columns. For example, adult column contains the overview and overview column contains the status etc. But actually the data is divided across two indices. So we combine the data into single index and drop the later index.","a10b3861":"# IMPORT DATASET\n\nWe're going to use only three files from the database, namely\n\n* movies_metadata,\n* credits,\n* keywords.","8ba99861":"## MODEL KEY POINTS \n* Arrange movies in the descending order by their genre similarity score with respect to the target film.\n* Cluster the movies received from the previous step based on their plot scores.\n* Further sort movies(in descending order) within each cluster on the basis of all the similarity scores(previously calculated) and their calculated weighted ratings.\n* Return the top fifty recommendations from each cluster","9ce137f0":"# SELECTING REQUIRED DATA","c33c79f2":"## SIMILARITY MEASURES\nThere are various metrics to calculate the similarity score of the vectorized documents. Cosine similarity has been used here.\nCosine similarity is a metric used to measure how similar the documents are irrespective of their size. The smaller the angle, higher the cosine similarity. Mathematically, it measures the cosine of the angle between two vectors projected in a multi-dimensional space. The cosine similarity is advantageous because even if the two similar documents are far apart by the Euclidean distance (due to the size of the document), chances are they may still be oriented closer together. \n\nThe cosine similarity function returns a returns a pairwise cosine similarity matrix for the vector input. When stored in a dataframe, each row represents the similarity score of a particular movies with respect to all the other movies."}}