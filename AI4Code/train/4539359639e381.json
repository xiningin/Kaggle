{"cell_type":{"b8267179":"code","72de55de":"code","34d55125":"code","0b010c5c":"code","0babd412":"code","46f71d46":"code","0bd98973":"code","ac3f95ff":"code","39d53090":"code","2adbd458":"code","4db38636":"code","c0981914":"code","045b124b":"code","1d852f9a":"markdown","863a96cc":"markdown","3a98baf0":"markdown","fbd6a2d4":"markdown"},"source":{"b8267179":"import numpy as np\nimport os\nimport matplotlib.pyplot as plt\nfrom matplotlib import image\nfrom PIL import Image\nimport keras\nimport tensorflow as tf\nimport time\nimport imageio\nfrom matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas","72de55de":"!mkdir Data","34d55125":"os.system('gsutil ls gs:\/\/quickdraw_dataset\/sketchrnn\/ >> names.txt')\npaths = []\nwith open('names.txt','r') as f:\n    for line in f.readlines():\n        if \"full\" in line:\n            continue\n        paths.append(line.replace(\"\\n\",\"\"))\npaths = np.array(paths)\n\n#TESTING\n\nnum_classes = 7\n\npaths = paths[:num_classes]\n\nnames = [path.split('\/')[-1].replace('.npz','') for path in paths]","0b010c5c":"#Utils \n\ndownload = lambda file, dataPath: os.system('gsutil -m cp \"' + file + '\" ' + dataPath)\n\ndef getImg(fig):\n    canvas = FigureCanvas(fig)\n    canvas.draw() \n\n    width, height = fig.get_size_inches() * fig.get_dpi()\n    width, height = int(width), int(height)\n\n    return np.frombuffer(canvas.tostring_rgb(), dtype='uint8').reshape(height, width, 3)","0babd412":"def getData(path, numSamples = 20, generator = 'train',verbose = True):\n    \n    dataPath = 'Data'\n    fileName = path.split('\/')[-1]\n    \n    localPath = os.path.join(dataPath,fileName)\n    \n    if not os.path.exists(localPath):\n        if verbose:\n            print('DOWNLOADING',path)\n        download(path,dataPath)\n    \n    #Caches data\n    data = np.load(localPath, encoding='latin1', allow_pickle=True)\n        \n    test,train,valid = data['test'],data['train'],data['valid']\n    \n    cur = train if generator=='train' else valid\n    \n    assert numSamples < len(cur)\n    \n    idx = np.concatenate((np.ones(numSamples),np.zeros(len(cur) - numSamples)))\n    np.random.shuffle(idx)\n    \n    imgs = cur[idx == 1]\n    \n    ret = []\n    \n    \n    for i,img in enumerate(imgs):\n\n        fig, ax = plt.subplots()\n        curx, cury = 0, 0\n        \n        for stroke in img:\n            if stroke[2] == 0:\n                x,y  = [curx, curx + stroke[0]], [cury, cury - stroke[1]]\n                ax.plot(x,y)\n            curx += stroke[0]\n            cury -= stroke[1]\n        \n        \n        ax.axis('off')\n        fig.patch.set_facecolor('black')\n        fig.savefig('temp.jpg',facecolor=fig.get_facecolor())\n        temp = image.imread(\"temp.jpg\")\n        #temp = getImg(fig)\n        ret.append(temp)\n        fig.clear()\n        plt.close(fig)\n        \n    return np.array(ret)","46f71d46":"class DataGenerator(keras.utils.Sequence):\n    'Generates data for Keras'\n    \n    def __init__(self, generator='train'):\n        self.epochNumber = 0\n        self.generator = generator\n\n    def __len__(self):\n        'Denotes the number of batches per epoch'\n        if self.generator=='valid':\n            return 5\n        elif self.generator=='train':\n            return 50\n\n    def __getitem__(self, index):\n        'Generate one batch of data'\n        num = 5\n        idx = np.concatenate((np.ones(num),np.zeros(len(paths) - num)))\n        np.random.shuffle(idx)\n        \n        \n        \n        pos = np.where(idx == 1)[0]\n        curPaths = paths[idx == 1]\n        \n        \n        X = []\n        y = []\n        \n        for i, path in enumerate(curPaths):\n            fileName = path.split('\/')[-1]\n            \n            NUM_SAMPLES = 5\n            \n            X.append(np.array(getData(path, numSamples = NUM_SAMPLES, generator = self.generator)))\n            for j in range(NUM_SAMPLES):\n                Y = np.zeros(num_classes)\n                Y[pos[i]] = 1\n                y.append(np.array([Y]))\n            \n       \n        \n        X = np.vstack(X)\n        y = np.vstack(y)\n        \n        \n        return X, y\n\n    def on_epoch_end(self):\n        \n        self.epochNumber += 1\n        \n        if not self.epochNumber%2:\n            name = str(self.epochNumber) + \".h5\"\n            model.save(name)","0bd98973":"from tensorflow.keras.applications import ResNet50\nfrom tensorflow.keras.applications import MobileNet\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Flatten, GlobalAveragePooling2D\n\n\n\nmodel = Sequential()\nmodel.add(ResNet50(include_top=False, pooling='avg'))\nmodel.add(Dense(num_classes, activation='softmax'))\n\nmodel.compile(optimizer='adam', \n              loss='categorical_crossentropy', \n              metrics=['accuracy'])","ac3f95ff":"train = DataGenerator()\nvalid = DataGenerator(generator='valid')\nmodel.fit_generator(generator=train, validation_data = valid, epochs = 20)","39d53090":"model = keras.models.load_model('4.h5')","2adbd458":"def saveGif(save_path, data_class):\n    dataPath = 'Data'\n    fileName = paths[data_class].split('\/')[-1]\n\n    localPath = os.path.join(dataPath,fileName)\n\n    if not os.path.exists(localPath):\n        if verbose:\n            print('DOWNLOADING',path)\n        download(path,dataPath)\n\n    data = np.load(localPath, encoding='latin1', allow_pickle=True)\n    test,train,valid = data['test'],data['train'],data['valid']\n\n    cur = train\n\n    img = np.random.choice(cur,1)[0]\n\n    #\n    fig, ax = plt.subplots()\n\n    ax.axis('off')\n    fig.patch.set_facecolor('black')\n    progress = []\n\n    curx, cury = 0, 0 \n    for stroke in img:\n        if stroke[2] == 0:\n            x,y  = [curx, curx + stroke[0]], [cury, cury - stroke[1]]\n            ax.plot(x,y)\n        curx += stroke[0]\n        cury -= stroke[1]\n\n        fig.savefig('temp.jpg',facecolor=fig.get_facecolor())\n        temp = image.imread(\"temp.jpg\")\n        progress.append(temp)\n\n    plt.close()\n\n    #Normal Drawings\n    fig, ax = plt.subplots()\n\n    progress2 = []\n\n    ax.axis('off')\n    ax.set_xlim(-800,800)\n    ax.set_ylim(-800,800)\n    progress2 = []\n\n    curx, cury = 0, 0 \n    for stroke in img:\n        if stroke[2] == 0:\n            x,y  = [curx, curx + stroke[0]], [cury, cury - stroke[1]]\n            ax.plot(x,y,color='black')\n        curx += stroke[0]\n        cury -= stroke[1]\n\n        fig.savefig('temp.jpg',facecolor=fig.get_facecolor())\n        temp = image.imread(\"temp.jpg\")\n        progress2.append(temp)\n\n    plt.close()\n\n    GIF = []\n    for i in range(len(progress)):\n        fig, ax = plt.subplots(1,2,figsize = (15, 10))\n        fig.suptitle('ACTUAL:' + names[data_class] +' CURRENT PREDICTION: ' + names[np.argmax(model.predict(np.array([progress[i]])))])\n\n        ax[1].set_title('Representation')\n        ax[1].axis('off')\n        ax[1].imshow(progress[i])\n\n        ax[0].set_title('Drawing')\n        ax[0].axis('off')\n        ax[0].imshow(progress2[i])\n\n        fig.savefig('temp.jpg',facecolor=fig.get_facecolor())\n        temp = image.imread(\"temp.jpg\")\n        GIF.append(temp)\n\n        plt.close()\n\n    imageio.mimsave(save_path, GIF)","4db38636":"saveGif('out.gif',4)","c0981914":"for i, name in enumerate(names):\n    saveGif(name + '.gif',i)","045b124b":"data = np.load(localPath, encoding='latin1', allow_pickle=True)","1d852f9a":"## Querying data utils","863a96cc":"## Find all the classes using gsutil","3a98baf0":"## Data Generator","fbd6a2d4":"## Setup"}}