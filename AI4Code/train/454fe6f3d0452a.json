{"cell_type":{"9ef72a1f":"code","156057d1":"code","6e2930ae":"code","688d25dd":"code","a8af8de3":"code","e05939e9":"code","9fa74761":"code","38a88dc8":"code","970520b3":"code","1cfd2b54":"code","032bd1f3":"code","47cd7152":"code","26d23ad3":"code","8fe83d50":"code","e7f1e658":"code","687b10d8":"markdown","a9c8427d":"markdown","611e94d0":"markdown","acecd1b6":"markdown","02836792":"markdown","1d774102":"markdown","34b93b5e":"markdown","d949d5d2":"markdown","62f396ef":"markdown","c05fa614":"markdown","b37276e5":"markdown","93b645f2":"markdown","a628fecf":"markdown","61f18e7b":"markdown","f79c7dae":"markdown","6ffeb7e7":"markdown","94877a36":"markdown"},"source":{"9ef72a1f":"import networkx as nx # The graph library\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom IPython.display import Image #For image\n%matplotlib inline\n\nimport warnings\nwarnings.filterwarnings('ignore')","156057d1":"G = nx.Graph() #Initialize\n\n#Creating set of nodes\nnodes = [\"A\", \"B\", \"C\", \"D\", \"E\",\"F\"]\nfor node in nodes:\n    G.add_node(node)\n\n#Creating a set of edges\nedges = {\"A\": [(\"B\",7), (\"C\",9), (\"F\",14)], #edges AB, AC, AF with weight 7, 9, 14 respectively\n         \"B\": [(\"A\",7),(\"C\",10), (\"D\",15)],\n         \"C\": [(\"A\",9), (\"B\",10), (\"D\",11), (\"F\",2)],\n         \"D\": [(\"B\",15), (\"C\",11), (\"E\",6)],\n         \"E\": [(\"D\",6), (\"F\",9)],\n         \"F\": [(\"A\",14), (\"C\",2), (\"E\",9)]\n        }\n\n#Add edges with direction to graph G\nfor node in edges.keys():\n    neighbors = edges[node]\n    for neighbor_node in neighbors:\n        G.add_edge(node, neighbor_node[0],weight=neighbor_node[1]) #Source node, node, weight","6e2930ae":"#Graph edge with edge weight label is hard!\n#Let do it with out weight label\nnx.draw(G, with_labels=True, node_color=\"#1cf0c7\", \n        node_size=1500, alpha=0.7, font_weight=\"bold\", pos=nx.circular_layout(G)) #Adding pos make it look cleaner","688d25dd":"#Displays edges and edge weights of graph G\nprint(\"All the edges of G:\", G.edges)\nprint(\"Weight on edge FE:\", G.edges[('F', 'E')])\nprint(\"Neighbor node of F:\", ['F']) ","a8af8de3":"nx.draw(G, with_labels=True, node_color=\"#1cf0c7\", \n        node_size=1500, alpha=0.7, font_weight=\"bold\", pos=nx.circular_layout(G)) #Adding pos make it look cleaner","e05939e9":"#with no weight\nprint(\"Is there a path from A to E in graph G: \", nx.has_path(G, \"A\", \"E\"))\nprint(\"Shortest path from A to E not considering the weight: \",nx.shortest_path(G, \"A\", \"E\")) \nprint(\"Number of edges to get there (distance): \",nx.shortest_path_length(G, \"A\", \"E\"))\n\n#with weight\nprint(\"************************************************************\")\nprint(\"Dijkstra path from A to E: \",nx.dijkstra_path(G, \"A\", \"E\"))\nprint(\"The distance of that path\",nx.dijkstra_path_length(G, \"A\", \"E\"))","9fa74761":"ls ..\/input\/facebook\/facebook_network.png","38a88dc8":"Image(filename = \"..\/input\/facebook\/facebook_network.png\")","970520b3":"G = nx.Graph() #Initialize\n\n#Creating Nodes\nnodes = [\"A\", \"B\", \"C\", \"D\", \"E\",\"F\"]\nfor node in nodes:\n    G.add_node(node)\n    \n#Adding edges\nedges = {\"A\": [(\"B\"), (\"C\"), (\"F\")],\n         \"B\": [(\"A\"),(\"C\"), (\"D\")],\n         \"C\": [(\"A\"), (\"B\"), (\"D\"), (\"F\")],\n         \"D\": [(\"B\"), (\"C\"), (\"E\")],\n         \"E\": [(\"D\"), (\"F\")],\n         \"F\": [(\"A\"), (\"C\"), (\"E\")]\n        }\n\nfor node in edges.keys():\n    neighbors = edges[node]\n    for neighbor_node in neighbors:\n        G.add_edge(node, neighbor_node) #Source node, node, weight\n        \nnx.draw(G, with_labels=True, node_color=\"#1cf0c7\", \n        node_size=1500, alpha=0.7, font_weight=\"bold\", pos=nx.circular_layout(G))","1cfd2b54":"degrees = nx.degree_centrality(G)\ncloseness = nx.closeness_centrality(G)\nbetweeness = nx.betweenness_centrality(G)\neigs = nx.eigenvector_centrality(G)\n\ncentrality = pd.DataFrame([degrees, closeness, betweeness, eigs]).transpose()\ncentrality.columns = [\"degrees\", \"closeness\", \"betweeness\", \"eigs\"]\ncentrality = centrality.sort_values(by='eigs', ascending=False)\ncentrality","032bd1f3":"ls ..\/input\/edge-data\/books_data.edgelist","47cd7152":"#This data set contains node(book), its neighbors (similar book), and similarity score (weight)\ndf = pd.read_csv('..\/input\/edge-data\/books_data.edgelist', names=['source', 'target', 'weight'], delimiter=' ')\ndf.head()","26d23ad3":"#Load second data which has more detail\nmeta = pd.read_csv('..\/input\/edge-data\/books_meta.txt', sep='\\t')\nmeta.head()","8fe83d50":"#Type your preference book here\nGOT = meta[meta.Title.str.contains('Harry Potter and the Order of the Phoenix')]\nGOT","e7f1e658":"rec_dict = {}\nid_name_dict = dict(zip(meta.ASIN, meta.Title))\nfor row in GOT.index:\n    book_id = GOT.ASIN[row]\n    book_name = id_name_dict[book_id]\n    most_similar = df[(df.source==book_id)\n                      | (df.target==book_id)\n                     ].sort_values(by='weight', ascending=False).head(10)\n    most_similar['source_name'] = most_similar['source'].map(id_name_dict)\n    most_similar['target_name'] = most_similar['target'].map(id_name_dict)\n    recommendations = []\n    for row in most_similar.index:\n        if most_similar.source[row] == book_id:\n            recommendations.append((most_similar.target_name[row], most_similar.weight[row]))\n        else:\n            recommendations.append((most_similar.source_name[row], most_similar.weight[row]))\n    rec_dict[book_name] = recommendations\n    print(\"Recommendations for:\", book_name)\n    for r in recommendations:\n        print(r)\n    print('\\n')","687b10d8":"Let's create a same graph but with no weight","a9c8427d":"# Dijkstra's algorithm (shortest path)\n\npronounce: Diekstra\n\n**Dijkstra's algorithm** (or Dijkstra's Shortest Path First algorithm, SPF algorithm) is an algorithm for finding the shortest paths between nodes in a graph. A description of the algorithm can be found [here](https:\/\/www.geeksforgeeks.org\/dijkstras-shortest-path-algorithm-greedy-algo-7\/).\n\nBelow is a gif that sum of the process of finding the shortest path from node 1 to node 5.  (Source: wiki image)","611e94d0":"Observe that, there are many path from $1$ to $5$, but the shortest one is $1->3->6->5$ since the total distance is $9+2+9=20$\n\nSimilarly, we will use the graph created above and find the shortest path from A to E. It is a little bit hard to see, but A is equivalent to node 1, B is 2, C is 3, D is 4, and E is 5. Use your imagination to verify that these two graph are the same!","acecd1b6":"Calculate the centrality of each nodes.","02836792":"Note that **Clustering Coefficient** is s a measure of the degree to **which nodes in a graph tend to cluster together**. Evidence suggests that in most real-world networks, and in particular social networks, nodes tend to create tightly knit groups characterised by a relatively high density of ties; this likelihood tends to be greater than the average probability of a tie randomly established between two nodes (Holland and Leinhardt, 1971 Watts and Strogatz, 1998).\n\nThe (Local) **clustering coefficient** formula for a directed graph is:\n$$C_{i}={\\frac  {|\\{e_{{jk}}:v_{j},v_{k}\\in N_{i},e_{{jk}}\\in E\\}|}{k_{i}(k_{i}-1)}}$$\nwhere\n* $e_{jk}$ is edge between nodes $v_j$ and $v_k$\n* $N_{i}$ is the neighbor of node $v_i$\n* $k_i$ is the number neighbor nodes of $v_i$. Note that there are $k_{i}(k_{i}-1)$  links that could exist among the vertices within the neighbourhood $N_i$\nFor a undirected graph, just multiply the formula by 2. More about it [here](https:\/\/en.wikipedia.org\/wiki\/Clustering_coefficient).","1d774102":"The code bellow will \n\n1) Identify the node correspond to the book\n\n2) Find its neighbors and sort by weight. \n\n3) Display the top ten books","34b93b5e":"# Creating a network","d949d5d2":"## Centrality\n\nCentrality describes the influence\/importance of nodes in the graph. There are three metrics \n\n* **Degree-centrality**: The number of edges attached to a node divide by the maximum edges a node can have\n* **Closeness-centrality**: The reciprocal of the sum of the distances to all other nodes in the network \n* **Betweenness-centrality**: The number of shortest paths between all node pairs the node lies on divided by the maximum number of shortest-paths any one node in the network lies on.\n* **Eigenvalue-centrality**: An iterative algorithm that assigns relative influence to a node based on the number and importance of connected nodes. It can be very computationally expensive to compute for large networks. Google's PageRank algorithm is a variation of eigenvalue-centrality.\n\nAll of these metrics basically tell how important a node is. ","62f396ef":"# Introduction\n\nIn this notebook, you will learn how to create your first graph with **networkx** and then jump to an example to see how graph theory can help you solve a real-life problem ","c05fa614":"Note that the weight here represent the similarity of any two books","b37276e5":"# Example: Book Recommendation\n\nWe are going to create the a book recommendation using items base. The weight is already provided from the data","93b645f2":"It's hard to put weight on edges using networkx, so I will just draw it with out label. ","a628fecf":"<img src=\"https:\/\/upload.wikimedia.org\/wikipedia\/commons\/5\/57\/Dijkstra_Animation.gif\">","61f18e7b":"Below are two set of codes which find the shortest path with weighted version (or all edge weight is 1) and with unweighted version","f79c7dae":"# Application\n\nImagine that we want to design an online bookstore that has a recommendation feature for the user. There are two main keys: users and items. We have to choose which key is the node and which is the edge of our graph. If we choose the user as the node, we are using **User-Based Collaborative Filtering**. If we choose items as the nodes, we are using **Item-Based Collaborative Filtering**\n\n**User base:** When recommending items to a user whether they be books, music, movies, restaurants or other consumer products one is typically trying to find the preferences of other users with similar tastes who can provide useful suggestions for the user in question. With this, examining the relationships amongst users and their previous preferences can help identify which users are most similar to each other\n\n**Item base:** Alternatively, one can examine the relationships between the items themselves.","6ffeb7e7":"### References\nAll about drawing graph [here](https:\/\/qxf2.com\/blog\/drawing-weighted-graphs-with-networkx\/)\n\nHow weight between two books is calculated: [Association Rules Generation from Frequent Itemsets](http:\/\/rasbt.github.io\/mlxtend\/user_guide\/frequent_patterns\/association_rules\/#example-1-generating-association-rules-from-frequent-itemsets)\n\nThere are also alternative approaches to [recommendations systems](https:\/\/www.researchgate.net\/publication\/256458336_Basic_Approaches_in_Recommendation_Systems)","94877a36":"A **graph** (or a network) consists of a set of nodes and a set of edges. Edges connect one node to anothers. We are dealing with a **simple graph in this notebook**, one edge has exactly two endpoints and two points has at most one adjacent edge. An edge can have directions or not. An edge can have a **weight** (a positive real number) associated with it. \n\nA real-life example of a graph is the map system. Houses are nodes, route from one house to another is the edge, and weight is distance. Sometimes, all roads are two-way, we call this an **undirected** graph. If the road is one-way, we call it a **directed** graph.\n\nWe are going to create a visual of a undirected weighted graph (with edge weights)."}}