{"cell_type":{"84cc3afd":"code","3b9a5f5c":"code","f0608b54":"code","6b850ef8":"code","07c67210":"code","2b693187":"code","a8f20dce":"code","3c34f344":"code","dccb5500":"code","69fbb4cc":"code","05337db9":"code","133f26d2":"code","8b4ce4cf":"code","76b2c335":"code","3f9e2ba0":"code","d0d490a0":"code","b5d640a7":"code","d3099f45":"code","13f152d0":"code","9cc70fd4":"code","3a2e745b":"code","54c00901":"code","6379a7bc":"code","876620f5":"code","f9071830":"code","2298d65e":"code","642927ce":"code","dd4a61c6":"code","3216e1e2":"code","d8be614f":"code","af7d56dd":"code","3c53f55d":"code","999bfe85":"code","eb7d398f":"code","3f8542b6":"code","b161988e":"code","f9882e4b":"code","5d8b78d0":"code","460ccf2d":"code","3351db7e":"code","0f2503d5":"code","fff01b27":"code","d769a367":"markdown","2a36ecfc":"markdown","cc29e363":"markdown","0fc644ea":"markdown","7dddbb22":"markdown","40b56458":"markdown","03e313db":"markdown"},"source":{"84cc3afd":"import random, os, sys\nimport numpy as np\nimport pandas as pd\n\nimport skimage.io\nimport skimage.transform\nimport skimage.filters\nfrom skimage.feature import corner_peaks\nfrom skimage.morphology import label\n\n\n\n\nfrom scipy.ndimage.interpolation import map_coordinates\nfrom scipy.ndimage.filters import gaussian_filter\n\nfrom matplotlib import pyplot as plt","3b9a5f5c":"random.seed = 42\nnp.random.seed = 42","f0608b54":"IMG_WIDTH = 192\nIMG_HEIGHT = 192\nN_CHANEL = 3","6b850ef8":"def get_images_and_masks_id(path='..\/input\/stage1_train\/'):\n    train_id = next(os.walk(path))[1]\n    list_train_set = []\n    for i in train_id:\n        list_train_set.append({\n            'image_id':i,\n            'masks_id':next(os.walk('{0}\/{1}\/masks\/'.format(path, i)))[2]})\n    return list_train_set","07c67210":"def stack_masks(masks_np_list):\n    masks = np.mean(masks_np_list.transpose(1,2,0), axis=2)\n    return masks.reshape(masks.shape[0], masks.shape[1], 1)","2b693187":"def get_image_and_masks(image_id, list_masks_id, path='..\/input\/stage1_train\/'):\n    image_file = \"{0}\/{1}\/images\/{1}.png\".format(path, image_id)\n    image = skimage.io.imread(image_file)\n    masks_list = []\n    for mask_id in list_masks_id:\n        mask_file = \"{0}\/{1}\/masks\/{2}\".format(path, image_id, mask_id)\n        masks_list.append(skimage.io.imread(mask_file))\n    return {'image':image, 'masks':stack_masks(np.array(masks_list))}","a8f20dce":"def img_resize(img, output_shape=(IMG_HEIGHT, IMG_WIDTH, N_CHANEL)):\n    if img.shape[0] == output_shape[0] and img.shape[1] == output_shape[1]:\n        return img[:,:,:N_CHANEL] \/ 255\n    else:\n        return skimage.transform.resize(\n            img[:,:,:N_CHANEL], \n            output_shape,\n            mode='reflect')","3c34f344":"def mask_resize(mask, output_shape=(IMG_HEIGHT, IMG_WIDTH, 1)):\n    if mask.shape[0] == output_shape[0] and mask.shape[1] == output_shape[1]:\n        return (mask != 0).astype(np.uint)\n    else:\n        result = skimage.transform.resize(\n            mask[:,:,:1], \n            output_shape,\n            mode='reflect')\n        result = (result > 0.5).astype(np.uint)\n        return result","dccb5500":"for image_and_masks_id in get_images_and_masks_id()[:10]:\n    test_instance = get_image_and_masks(\n        image_and_masks_id['image_id'], \n        image_and_masks_id['masks_id'])\n    img = test_instance['image'] #img_resize\n    mask = test_instance['masks'] #mask_resize\n    plt.figure(1, figsize=(15,5))\n    plt.subplot(1,2,1); plt.imshow(img)\n    plt.subplot(1,2,2); plt.imshow(mask[:,:,0])\n    plt.show()","69fbb4cc":"input_data = []; output_data = []\nfor image_and_masks_id in get_images_and_masks_id():\n    test_instance = get_image_and_masks(\n        image_and_masks_id['image_id'], \n        image_and_masks_id['masks_id'])\n    input_data.append(img_resize(test_instance['image']))\n    output_data.append(mask_resize(test_instance['masks']))\ninput_data = np.array(input_data)\noutput_data = np.array(output_data)","05337db9":"assert input_data.shape[0] == output_data.shape[0]","133f26d2":"from scipy import ndimage\nfrom skimage.transform import swirl\nimport skimage.util\nfrom random import randrange, uniform","8b4ce4cf":"def swirl_generator(image, mask):\n    img = image[:,:,:3]\n    msk = mask[:,:,0]\n    \n    for i in range(randrange(5,10)):\n        r_radius = randrange(int(image.shape[0]\/2), int(image.shape[0]\/1.5))\n        r_center_x = randrange(0, image.shape[0])\n        r_center_y = randrange(0, image.shape[1])\n\n        img = swirl(\n            img.astype(np.float64), \n            center=(r_center_x, r_center_y), strength=1, radius=r_radius, mode='constant')\n        msk = swirl(\n            msk.astype(np.float64), \n            center=(r_center_x, r_center_y), strength=1, radius=r_radius, mode='constant')\n    msk = (msk > 0.5).astype(np.uint)\n    return img, msk","76b2c335":"def gaus_filter(img):\n    sigma = uniform(0.5, 2.5)\n    return ndimage.gaussian_filter(img, sigma)","3f9e2ba0":"def rand_noise(img):\n    sigma = uniform(0, 0.03)\n    return skimage.util.random_noise(img, var=sigma)","d0d490a0":"# test swirl_generator\nfig, ax = plt.subplots(2,4, figsize=(14,8))\n\nplots = []; num = 100\nplots.append((input_data[num], np.squeeze(output_data[num])))\nplots.append((swirl_generator(input_data[num], output_data[num])))\nplots.append((gaus_filter(input_data[num]), output_data[num][:,:,0]))\nplots.append((rand_noise(input_data[num]), output_data[num][:,:,0]))\n\nfor i, p in enumerate(plots):\n    ax[0][i].imshow(p[0])\n    ax[1][i].imshow(p[1])","b5d640a7":"from skimage.transform import rotate","d3099f45":"X = []; y = []\nfor img, msk in zip(input_data, output_data):\n    for i in range(randrange(0,2)):\n        r_angle = randrange(0, 360)\n        rot_img = rotate(img.astype(np.float64), angle=r_angle)\n        rot_msk = rotate(msk.astype(np.float64), angle=r_angle)\n        if np.max(rot_msk) < 0.5: continue\n        X.append(gaus_filter(np.fliplr(rot_img))) # vertical flip + gaus filte\n        y.append(np.fliplr(rot_msk))\n        X.append(rand_noise(np.flipud(rot_img))) # horisontal flip + noise\n        y.append(np.flipud(rot_msk))\n    X.append(img)\n    y.append(msk)\nX = np.array(X)\ny = np.array(y)","13f152d0":"del input_data, output_data","9cc70fd4":"X.shape","3a2e745b":"y.shape","54c00901":"indexes = np.arange(X.shape[0])\nnp.random.shuffle(indexes)\ntrain_indexes = indexes","6379a7bc":"# test normalization\nassert 1.0 >= np.max(X) and np.min(X) <= 0.0\nassert 1.0 >= np.max(y) and np.min(y) <= 0.0\n\ny_max_list = np.max(y, axis=(1,2)) # find max in mask\nassert (y_max_list < 0.5).any() == False","876620f5":"from tqdm import tqdm\nfrom itertools import chain\nfrom skimage.io import imread, imshow, imread_collection, concatenate_images\nfrom skimage.transform import resize\nfrom skimage.morphology import label\n\nfrom keras.models import Model, load_model\nfrom keras.layers import Input\nfrom keras.optimizers import Adam\nfrom keras.layers.merge import concatenate\nfrom keras.layers import Input, Conv2D, MaxPooling2D, UpSampling2D, Reshape, core, Dropout\nfrom keras.layers.core import Lambda\nfrom keras.layers.pooling import MaxPooling2D\nfrom keras.layers.merge import concatenate\nfrom keras.callbacks import EarlyStopping, ModelCheckpoint\nfrom keras import backend as K\n\nimport tensorflow as tf","f9071830":"def mean_iou(y_true, y_pred):\n    prec = []\n    for t in np.arange(0.5, 1.0, 0.05):\n        y_pred_ = tf.to_int32(y_pred > t)\n        Y_negatives = tf.subtract(1.,y_pred)\n        tp = tf.reduce_sum(tf.reduce_sum(tf.multiply(y_true,y_pred),1),1)  # True positives (i.e. the intersection)\n        fp = tf.reduce_sum(tf.reduce_sum(tf.multiply(y_true,Y_negatives),1),1)  # False positives\n        fn = tf.reduce_sum(tf.reduce_sum(tf.multiply(tf.subtract(y_true,y_pred),y_pred),1),1)  # False negatives\n        p = tp \/ (tp + fp + fn)\n        prec.append(p)\n    return K.mean(K.stack(prec), axis=0)","2298d65e":"def create_model():\n    print('model creat')\n    k = 4\n    inputs = Input((IMG_HEIGHT, IMG_WIDTH, N_CHANEL))\n\n    conv1 = Conv2D(2*k, (3, 3), activation='relu', padding='same')(inputs)\n    conv1 = Conv2D(2*k, (3, 3), activation='relu', padding='same')(conv1)\n    pool1 = MaxPooling2D(pool_size=(2, 2))(conv1)\n\n    conv2 = Conv2D(4*k, (3, 3), activation='relu', padding='same')(pool1)\n    conv2 = Conv2D(4*k, (3, 3), activation='relu', padding='same')(conv2)\n    pool2 = MaxPooling2D(pool_size=(2, 2))(conv2)\n\n    conv3 = Conv2D(8*k, (3, 3), activation='relu', padding='same')(pool2)\n    conv3 = Conv2D(8*k, (3, 3), activation='relu', padding='same')(conv3)\n    pool3 = MaxPooling2D(pool_size=(2, 2))(conv3)\n\n    conv4 = Conv2D(16*k, (3, 3), activation='relu', padding='same')(pool3)\n    conv4 = Conv2D(16*k, (3, 3), activation='relu', padding='same')(conv4)\n    pool4 = MaxPooling2D(pool_size=(2, 2))(conv4)\n\n    conv5 = Conv2D(32*k, (3, 3), activation='relu', padding='same')(pool4)\n    conv5 = Conv2D(32*k, (3, 3), activation='relu', padding='same')(conv5)\n\n    up6 = concatenate([UpSampling2D(size=(2, 2))(conv5), conv4])\n    conv6 = Conv2D(16*k, (3, 3), activation='relu', padding='same')(up6)\n    conv6 = Conv2D(16*k, (3, 3), activation='relu', padding='same')(conv6)\n\n    up7 = concatenate([UpSampling2D(size=(2, 2))(conv6), conv3])\n    conv7 = Conv2D(8*k, (3, 3), activation='relu', padding='same')(up7)\n    conv7 = Conv2D(8*k, (3, 3), activation='relu', padding='same')(conv7)\n\n    up8 = concatenate([UpSampling2D(size=(2, 2))(conv7), conv2])\n    conv8 = Conv2D(4*k, (3, 3), activation='relu', padding='same')(up8)\n    conv8 = Conv2D(4*k, (3, 3), activation='relu', padding='same')(conv8)\n\n    up9 = concatenate([UpSampling2D(size=(2, 2))(conv8), conv1])\n    conv9 = Conv2D(2*k, (3, 3), activation='relu', padding='same')(up9)\n    conv9 = Conv2D(2*k, (3, 3), activation='relu', padding='same')(conv9)\n    \n    outputs = Conv2D(1, (1, 1), activation='sigmoid') (conv9)\n\n    model = Model(inputs=[inputs], outputs=[outputs])\n    return model","642927ce":"def compile_model(model):\n    model.compile(\n        optimizer='adam', \n        loss = 'binary_crossentropy',\n        metrics=[mean_iou])\n    return model","dd4a61c6":"def fit_model(model, batch_size, validation_split, epochs):\n    checkpointer = ModelCheckpoint('U-Net_model.h5', verbose=1, save_best_only=True)\n    earlystopper = EarlyStopping(patience=5, verbose=1)\n    history = model.fit(\n        X[train_indexes], \n        y[train_indexes], \n        validation_split=validation_split, \n        batch_size=batch_size, \n        epochs=epochs,\n        callbacks=[checkpointer, earlystopper])\n    return history","3216e1e2":"#delete old model\n!rm .\/U-Net_model.h5","d8be614f":"%%time\nfrom keras.models import load_model\nif os.path.isfile('..\/working\/U-Net_model.h5'):\n    print('model load')\n    model = load_model('..\/working\/U-Net_model.h5',  custom_objects={'mean_iou': mean_iou})\nelse:\n    model = create_model()\nmodel = compile_model(model)\nfit_model(model, 4, 0.1, 12)","af7d56dd":"del X, y","3c53f55d":"# load test dataset\ntest_img_name = [img for img in next(os.walk('..\/input\/stage1_test\/'))[1]]\ntest_img = [skimage.io.imread('..\/input\/stage1_test\/{0}\/images\/{0}.png'.format(img)) for img in test_img_name]\ninput_shape = [img.shape[:2] for img in test_img]\ntest_img = [img_resize(img) for img in test_img] # \u0432\u0435\u0440\u043d\u0443\u0442\u044c \u0440\u0430\u0437\u043c\u0435\u0440\u044b \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0439 \u043d\u0430\u0437\u0430\u0434\ntest_img = np.array(test_img)\ntest_img.shape","999bfe85":"assert 1.0 >= np.max(test_img) and np.min(test_img) <= 0.0","eb7d398f":"model = load_model('..\/working\/U-Net_model.h5',  custom_objects={'mean_iou': mean_iou})\npreds_test= model.predict(test_img, verbose=1)","3f8542b6":"def return_shape_masks(masks, shapes):\n    reshape_mask = []\n    for i, shape in enumerate(shapes):\n        mask = skimage.transform.resize(\n            masks[i], \n            shape, \n            mode='reflect')\n        mask = (mask > 0.5).astype(np.uint8)\n        reshape_mask.append(mask)\n    return np.array(reshape_mask)\n\ndef return_shape_img(images, shapes):\n    reshape_images = []\n    for i, shape in enumerate(shapes):\n        img = skimage.transform.resize(\n            images[i],\n            (shape[0], shape[1], 3),\n            mode='reflect')\n        reshape_images.append(img)\n    return np.array(reshape_images)","b161988e":"from skimage.morphology import watershed\nfrom scipy import ndimage as ndi\nfrom skimage.feature import peak_local_max\n\ndef rle_encoding(x): # \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043d\u0430\u0445\u043e\u0434\u0438\u0442 \u0432\u0441\u0435 \u0442\u043e\u0447\u043a\u0438 \u043d\u0430 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0438\n    '''x: numpy array of shape (height, width), 1 - mask, 0 - background\n    Returns run length as list'''\n    dots = np.where(x.T.flatten() > 0.5)[0] # .T sets Fortran order down-then-right\n    run_lengths = []\n    prev = -2\n    for b in dots:\n        if (b>prev+1): run_lengths.extend((b+1, 0))\n        run_lengths[-1] += 1\n        prev = b\n    return run_lengths\n\ndef prob_to_rles(x, cutoff=0.50): # \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0440\u0430\u0437\u0434\u0435\u043b\u044f\u0435\u0442 \u043f\u044f\u0442\u043d\u0430 \u043d\u0430 \u0433\u0440\u0443\u043f\u043f\u044b\n    lab_img = label(x > cutoff)\n    for i in range(1, lab_img.max() + 1):\n        yield rle_encoding(lab_img == i)","f9882e4b":"images = return_shape_img(test_img, input_shape)\nmasks = return_shape_masks(preds_test, input_shape)\n\nfor i, mask in enumerate(masks[:10]):\n    plt.figure(figsize = (14, 5))\n    plt.subplot(1, 2, 1); plt.imshow(images[i]);\n    plt.subplot(1, 2, 2); plt.imshow(mask[:,:,0])\n    plt.show()","5d8b78d0":"new_test_ids = []\nrles = []\nfor i, id in enumerate(test_img_name):\n    rle = list(prob_to_rles(masks[i][:,:,0]))\n    rles.extend(rle)\n    new_test_ids.extend([id] * len(rle))","460ccf2d":"submission_df = pd.DataFrame()\nsubmission_df['ImageId'] = new_test_ids\nsubmission_df['EncodedPixels'] = pd.Series(rles).apply(lambda x: ' '.join(str(y) for y in x))\nsubmission_df.to_csv('submission.csv', index=False)","3351db7e":"def rls_decode(text_line, out_shape):\n    img = np.zeros(out_shape[0]*out_shape[1])\n    \n    str_numbers = text_line.split()\n    \n    int_numbers = []\n    for str_nb in str_numbers:\n        int_numbers.append(int(str_nb))\n    \n    pixcels = []; lengs = []\n    for i, num in enumerate(int_numbers):\n        if (i % 2 == 0) or (i == 0):\n            pixcels.append(num)\n        if (i % 2 == 1) or (i == 1):\n            lengs.append(num)\n            \n    for px, l in zip(pixcels, lengs):\n        for x in range(l):\n            img[px+x] = 1\n    return img","0f2503d5":"test_mask_id = '0999dab07b11bc85fb8464fc36c947fbd8b5d6ec49817361cb780659ca805eac'\ntest_mask_shape = (253, 519)","fff01b27":"n_nuclei = submission_df['EncodedPixels'][submission_df['ImageId'] == test_mask_id].shape[0]\n\ndecode_masks = []\nfor i in range(n_nuclei):\n    nucl = submission_df['EncodedPixels'][submission_df['ImageId'] == test_mask_id].iloc[i]\n    nucl_mask = rls_decode(nucl, test_mask_shape)\n    decode_masks.append(nucl_mask.reshape(test_mask_shape))\n    \ndecode_masks = [e*i for i, e in enumerate(decode_masks)]\nimage = np.sum(np.array(decode_masks), axis=0)\nplt.imshow(image)\nprint('count nuclei:',np.max(image))","d769a367":"## Showing train dataset","2a36ecfc":"### increase dataset","cc29e363":"## Create train dataset","0fc644ea":"## creat U-Net model","7dddbb22":"# Submission test","40b56458":"### rotate and flip","03e313db":"## Create submission"}}