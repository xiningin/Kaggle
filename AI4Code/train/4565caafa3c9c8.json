{"cell_type":{"0151f751":"code","b4570dba":"code","cd334b81":"code","08730f68":"code","02f5d2d5":"code","9e6facd7":"code","0f98d7e8":"code","911a0e31":"code","bab55a61":"code","f58ba19c":"code","2f759753":"code","fa9244d4":"code","99c61a92":"code","f41d6a6b":"code","ce2e9f26":"code","b288923a":"markdown","943740a3":"markdown","9db64c01":"markdown"},"source":{"0151f751":"import pandas as pd\nimport numpy as np\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import KFold\nfrom sklearn.feature_selection import RFECV\nimport lightgbm as lgb\nfrom tqdm import tqdm_notebook\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.preprocessing import LabelEncoder\nimport multiprocessing\nimport gc","b4570dba":"files = ['..\/input\/test_identity.csv', \n         '..\/input\/test_transaction.csv',\n         '..\/input\/train_identity.csv',\n         '..\/input\/train_transaction.csv',\n         '..\/input\/sample_submission.csv']\n\ndef load_data(file):\n    return pd.read_csv(file)\n\nwith multiprocessing.Pool() as pool:\n    test_id, test_tr, train_id, train_tr, sub = pool.map(load_data, files)","cd334b81":"train = pd.merge(train_tr, train_id, on='TransactionID', how='left')\ntest = pd.merge(test_tr, test_id, on='TransactionID', how='left')\n\ndel test_id, test_tr, train_id, train_tr\ngc.collect()\n\none_value_cols = [col for col in train.columns if train[col].nunique() <= 1]\none_value_cols_test = [col for col in test.columns if test[col].nunique() <= 1]\n\nmany_null_cols = [col for col in train.columns if train[col].isnull().sum() \/ train.shape[0] > 0.9]\nmany_null_cols_test = [col for col in test.columns if test[col].isnull().sum() \/ test.shape[0] > 0.9]\n\nbig_top_value_cols = [col for col in train.columns if train[col].value_counts(dropna=False, normalize=True).values[0] > 0.9]\nbig_top_value_cols_test = [col for col in test.columns if test[col].value_counts(dropna=False, normalize=True).values[0] > 0.9]\n\ncols_to_drop = list(set(many_null_cols + many_null_cols_test + big_top_value_cols + big_top_value_cols_test + one_value_cols + one_value_cols_test))\ncols_to_drop.remove('isFraud')\nprint('{} features are going to be dropped for being useless'.format(len(cols_to_drop)))\n\ntrain = train.drop(cols_to_drop, axis=1)\ntest = test.drop(cols_to_drop, axis=1)","08730f68":"def reduce_mem_usage(df, verbose=True):\n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    start_mem = df.memory_usage().sum() \/ 1024**2    \n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)    \n    end_mem = df.memory_usage().sum() \/ 1024**2\n    if verbose: \n        print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n    return df","02f5d2d5":"for col in tqdm_notebook(train.columns): \n    if train[col].dtype == 'object':\n        le = LabelEncoder()\n        le.fit(list(train[col].astype(str).values) + list(test[col].astype(str).values))\n        train[col] = le.transform(list(train[col].astype(str).values))","9e6facd7":"del test\ngc.collect()","0f98d7e8":"train = reduce_mem_usage(train)","911a0e31":"X = train.sort_values('TransactionDT').drop(['isFraud', 'TransactionDT', 'TransactionID'], axis=1)\ny = train.sort_values('TransactionDT')['isFraud']\n\ndel train\ngc.collect()","bab55a61":"# RFECV does not support NaNs\nX.fillna(-999, inplace=True)","f58ba19c":"params = {'num_leaves': 491,\n          'min_child_weight': 0.03454472573214212,\n          'feature_fraction': 0.3797454081646243,\n          'bagging_fraction': 0.4181193142567742,\n          'min_data_in_leaf': 106,\n          'objective': 'binary',\n          'max_depth': -1,\n          'learning_rate': 0.006883242363721497,\n          \"boosting_type\": \"gbdt\",\n          \"bagging_seed\": 11,\n          \"metric\": 'auc',\n          \"verbosity\": -1,\n          'reg_alpha': 0.3899927210061127,\n          'reg_lambda': 0.6485237330340494,\n          'random_state': 47\n         }","2f759753":"clf = lgb.LGBMClassifier(**params)\nrfe = RFECV(estimator=clf, step=10, cv=KFold(n_splits=5, shuffle=False), scoring='roc_auc', verbose=2)","fa9244d4":"rfe.fit(X, y)","99c61a92":"print('Optimal number of features:', rfe.n_features_)","f41d6a6b":"plt.figure(figsize=(14, 8))\nplt.xlabel(\"Number of features selected\")\nplt.ylabel(\"Cross validation score\")\nplt.plot(range(1, len(rfe.grid_scores_) + 1), rfe.grid_scores_)\nplt.show()","ce2e9f26":"for col in X.columns[rfe.ranking_ == 1]:\n    print(col)","b288923a":"We can eleminate some useless features already at the begining. Such as:\n* Features with only 1 unique value\n* Features with more than 90% missing values\n* Features with the top value appears more than 90% of the time","943740a3":"Printing out all features with rank 1","9db64c01":"And here we go. This would take a while."}}