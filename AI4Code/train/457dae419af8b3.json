{"cell_type":{"7cfc3f87":"code","5bb19103":"code","bf136382":"code","7ac1d84d":"code","caf56dc7":"code","65311e2f":"code","809c564d":"code","316e386a":"code","47b8a6b1":"code","c3a9ecf4":"code","efc52703":"code","1ceff4bf":"code","daba0e0a":"code","7684da3e":"code","51550ee4":"code","4c0c41be":"code","2bf9a40a":"code","bb7a53f2":"code","c01b5fd7":"code","4234e7d8":"code","f03bf429":"code","a7400b2e":"code","25e8e30d":"code","07e78ecf":"code","6b41e00e":"code","05a34b56":"code","09bd231d":"code","58609117":"code","56ae9945":"code","2b766161":"code","6ebe3a5e":"code","88f75632":"code","efe83f91":"code","1b16d4ea":"code","cb5b0a6e":"code","d9a3a89d":"code","81ea9105":"code","e9dc4d52":"markdown","392e1c44":"markdown","a4a6d69c":"markdown","ef51f996":"markdown","2735760b":"markdown","3f58289f":"markdown","3cbe016e":"markdown","1f3a5918":"markdown","be513dcd":"markdown","6f19bb8a":"markdown","e4e2627e":"markdown","0c3a5320":"markdown","ae4326bc":"markdown","c8f6533e":"markdown","c3c31069":"markdown","821f8dd4":"markdown","42c5e8a1":"markdown","c1184d78":"markdown","344c89ed":"markdown","788dd4f3":"markdown","0400f2b5":"markdown","80f741ce":"markdown","838f6efd":"markdown","cb98d607":"markdown","c71048ed":"markdown","8029c192":"markdown","78b5113b":"markdown","df6508c0":"markdown","48a8f721":"markdown","ec7d12eb":"markdown","3892fb6d":"markdown","8b002fd3":"markdown","33b66b1c":"markdown","4e964323":"markdown","3dc92484":"markdown","ecf94780":"markdown","237da7c6":"markdown","b2c96d9b":"markdown","75352559":"markdown","c8d342fe":"markdown","ba1c5e94":"markdown","3115908f":"markdown","3b5b16ea":"markdown","9aa9437b":"markdown","e9fda75d":"markdown","a42d3903":"markdown"},"source":{"7cfc3f87":"# import library\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport datetime as dt\n\n#For Data  Visualization\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n#For Machine Learning Algorithm\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import KMeans\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\ndf = pd.read_excel('..\/input\/Online Retail.xlsx')\n\n","5bb19103":"df.head(5)","bf136382":"df.info()","7ac1d84d":"df.isnull().sum()","caf56dc7":"df= df.dropna(subset=['CustomerID'])","65311e2f":"df.isnull().sum().sum()","809c564d":"df.duplicated().sum()\n","316e386a":"df = df.drop_duplicates()","47b8a6b1":"df.duplicated().sum()\n","c3a9ecf4":"df.describe()","efc52703":"df=df[(df['Quantity']>0) & (df['UnitPrice']>0)]\ndf.describe() ","1ceff4bf":"df.shape","daba0e0a":"def get_month(x) : return dt.datetime(x.year,x.month,1)\ndf['InvoiceMonth'] = df['InvoiceDate'].apply(get_month)\ngrouping = df.groupby('CustomerID')['InvoiceMonth']\ndf['CohortMonth'] = grouping.transform('min')\ndf.tail()","7684da3e":"def get_month_int (dframe,column):\n    year = dframe[column].dt.year\n    month = dframe[column].dt.month\n    day = dframe[column].dt.day\n    return year, month , day \n\ninvoice_year,invoice_month,_ = get_month_int(df,'InvoiceMonth')\ncohort_year,cohort_month,_ = get_month_int(df,'CohortMonth')\n\nyear_diff = invoice_year - cohort_year \nmonth_diff = invoice_month - cohort_month \n\ndf['CohortIndex'] = year_diff * 12 + month_diff + 1 ","51550ee4":"#Count monthly active customers from each cohort\ngrouping = df.groupby(['CohortMonth', 'CohortIndex'])\ncohort_data = grouping['CustomerID'].apply(pd.Series.nunique)\n# Return number of unique elements in the object.\ncohort_data = cohort_data.reset_index()\ncohort_counts = cohort_data.pivot(index='CohortMonth',columns='CohortIndex',values='CustomerID')\ncohort_counts\n","4c0c41be":"# Retention table\ncohort_size = cohort_counts.iloc[:,0]\nretention = cohort_counts.divide(cohort_size,axis=0) #axis=0 to ensure the divide along the row axis \nretention.round(3) * 100 #to show the number as percentage ","2bf9a40a":"#Build the heatmap\nplt.figure(figsize=(15, 8))\nplt.title('Retention rates')\nsns.heatmap(data=retention,annot = True,fmt = '.0%',vmin = 0.0,vmax = 0.5,cmap=\"BuPu_r\")\nplt.show()","bb7a53f2":"#Average quantity for each cohort\ngrouping = df.groupby(['CohortMonth', 'CohortIndex'])\ncohort_data = grouping['Quantity'].mean()\ncohort_data = cohort_data.reset_index()\naverage_quantity = cohort_data.pivot(index='CohortMonth',columns='CohortIndex',values='Quantity')\naverage_quantity.round(1)\naverage_quantity.index = average_quantity.index.date\n\n#Build the heatmap\nplt.figure(figsize=(15, 8))\nplt.title('Average quantity for each cohort')\nsns.heatmap(data=average_quantity,annot = True,vmin = 0.0,vmax =20,cmap=\"BuGn_r\")\nplt.show()","c01b5fd7":"#New Total Sum Column  \ndf['TotalSum'] = df['UnitPrice']* df['Quantity']\n\n#Data preparation steps\nprint('Min Invoice Date:',df.InvoiceDate.dt.date.min(),'max Invoice Date:',\n       df.InvoiceDate.dt.date.max())\n\ndf.head(3)","4234e7d8":"snapshot_date = df['InvoiceDate'].max() + dt.timedelta(days=1)\nsnapshot_date\n#The last day of purchase in total is 09 DEC, 2011. To calculate the day periods, \n#let's set one day after the last one,or \n#10 DEC as a snapshot_date. We will cound the diff days with snapshot_date.\n","f03bf429":"# Calculate RFM metrics\nrfm = df.groupby(['CustomerID']).agg({'InvoiceDate': lambda x : (snapshot_date - x.max()).days,\n                                      'InvoiceNo':'count','TotalSum': 'sum'})\n#Function Lambdea: it gives the number of days between hypothetical today and the last transaction\n\n#Rename columns\nrfm.rename(columns={'InvoiceDate':'Recency','InvoiceNo':'Frequency','TotalSum':'MonetaryValue'}\n           ,inplace= True)\n\n#Final RFM values\nrfm.head()\n","a7400b2e":"#Building RFM segments\nr_labels =range(4,0,-1)\nf_labels=range(1,5)\nm_labels=range(1,5)\nr_quartiles = pd.qcut(rfm['Recency'], q=4, labels = r_labels)\nf_quartiles = pd.qcut(rfm['Frequency'],q=4, labels = f_labels)\nm_quartiles = pd.qcut(rfm['MonetaryValue'],q=4,labels = m_labels)\nrfm = rfm.assign(R=r_quartiles,F=f_quartiles,M=m_quartiles)\n\n# Build RFM Segment and RFM Score\ndef add_rfm(x) : return str(x['R']) + str(x['F']) + str(x['M'])\nrfm['RFM_Segment'] = rfm.apply(add_rfm,axis=1 )\nrfm['RFM_Score'] = rfm[['R','F','M']].sum(axis=1)\n\nrfm.head()","25e8e30d":"rfm.groupby(['RFM_Segment']).size().sort_values(ascending=False)[:5]","07e78ecf":"#Select bottom RFM segment \"111\" and view top 5 rows\nrfm[rfm['RFM_Segment']=='111'].head()","6b41e00e":"rfm.groupby('RFM_Score').agg({'Recency': 'mean','Frequency': 'mean',\n                             'MonetaryValue': ['mean', 'count'] }).round(1)\n\n","05a34b56":"def segments(df):\n    if df['RFM_Score'] > 9 :\n        return 'Gold'\n    elif (df['RFM_Score'] > 5) and (df['RFM_Score'] <= 9 ):\n        return 'Sliver'\n    else:  \n        return 'Bronze'\n\nrfm['General_Segment'] = rfm.apply(segments,axis=1)\n\nrfm.groupby('General_Segment').agg({'Recency':'mean','Frequency':'mean',\n                                    'MonetaryValue':['mean','count']}).round(1)\n","09bd231d":"rfm_rfm = rfm[['Recency','Frequency','MonetaryValue']]\nprint(rfm_rfm.describe())\n\n","58609117":"# plot the distribution of RFM values\nf,ax = plt.subplots(figsize=(10, 12))\nplt.subplot(3, 1, 1); sns.distplot(rfm.Recency, label = 'Recency')\nplt.subplot(3, 1, 2); sns.distplot(rfm.Frequency, label = 'Frequency')\nplt.subplot(3, 1, 3); sns.distplot(rfm.MonetaryValue, label = 'Monetary Value')\nplt.style.use('fivethirtyeight')\nplt.tight_layout()\nplt.show()\n","56ae9945":"#Unskew the data with log transformation\nrfm_log = rfm[['Recency', 'Frequency', 'MonetaryValue']].apply(np.log, axis = 1).round(3)\n#or rfm_log = np.log(rfm_rfm)\n\n\n# plot the distribution of RFM values\nf,ax = plt.subplots(figsize=(10, 12))\nplt.subplot(3, 1, 1); sns.distplot(rfm_log.Recency, label = 'Recency')\nplt.subplot(3, 1, 2); sns.distplot(rfm_log.Frequency, label = 'Frequency')\nplt.subplot(3, 1, 3); sns.distplot(rfm_log.MonetaryValue, label = 'Monetary Value')\nplt.style.use('fivethirtyeight')\nplt.tight_layout()\nplt.show()\n","2b766161":"#Normalize the variables with StandardScaler\nfrom sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit(rfm_log)\n#Store it separately for clustering\nrfm_normalized= scaler.transform(rfm_log)","6ebe3a5e":"from sklearn.cluster import KMeans\n\n#First : Get the Best KMeans \nks = range(1,8)\ninertias=[]\nfor k in ks :\n    # Create a KMeans clusters\n    kc = KMeans(n_clusters=k,random_state=1)\n    kc.fit(rfm_normalized)\n    inertias.append(kc.inertia_)\n\n# Plot ks vs inertias\nf, ax = plt.subplots(figsize=(15, 8))\nplt.plot(ks, inertias, '-o')\nplt.xlabel('Number of clusters, k')\nplt.ylabel('Inertia')\nplt.xticks(ks)\nplt.style.use('ggplot')\nplt.title('What is the Best Number for KMeans ?')\nplt.show()\n\n","88f75632":"# clustering\nkc = KMeans(n_clusters= 3, random_state=1)\nkc.fit(rfm_normalized)\n\n#Create a cluster label column in the original DataFrame\ncluster_labels = kc.labels_\n\n#Calculate average RFM values and size for each cluster:\nrfm_rfm_k3 = rfm_rfm.assign(K_Cluster = cluster_labels)\n\n#Calculate average RFM values and sizes for each cluster:\nrfm_rfm_k3.groupby('K_Cluster').agg({'Recency': 'mean','Frequency': 'mean',\n                                         'MonetaryValue': ['mean', 'count'],}).round(0)\n","efe83f91":"rfm_normalized = pd.DataFrame(rfm_normalized,index=rfm_rfm.index,columns=rfm_rfm.columns)\nrfm_normalized['K_Cluster'] = kc.labels_\nrfm_normalized['General_Segment'] = rfm['General_Segment']\nrfm_normalized.reset_index(inplace = True)\n\n#Melt the data into a long format so RFM values and metric names are stored in 1 column each\nrfm_melt = pd.melt(rfm_normalized,id_vars=['CustomerID','General_Segment','K_Cluster'],value_vars=['Recency', 'Frequency', 'MonetaryValue'],\nvar_name='Metric',value_name='Value')\nrfm_melt.head()\n","1b16d4ea":"f, (ax1, ax2) = plt.subplots(1,2, figsize=(15, 8))\nsns.lineplot(x = 'Metric', y = 'Value', hue = 'General_Segment', data = rfm_melt,ax=ax1)\n\n# a snake plot with K-Means\nsns.lineplot(x = 'Metric', y = 'Value', hue = 'K_Cluster', data = rfm_melt,ax=ax2)\n\nplt.suptitle(\"Snake Plot of RFM\",fontsize=24) #make title fontsize subtitle \nplt.show()\n","cb5b0a6e":"# The further a ratio is from 0, the more important that attribute is for a segment relative to the total population\ncluster_avg = rfm_rfm_k3.groupby(['K_Cluster']).mean()\npopulation_avg = rfm_rfm.mean()\nrelative_imp = cluster_avg \/ population_avg - 1\nrelative_imp.round(2)\n\n","d9a3a89d":"# the mean value in total \ntotal_avg = rfm.iloc[:, 0:3].mean()\n# calculate the proportional gap with total mean\ncluster_avg = rfm.groupby('General_Segment').mean().iloc[:, 0:3]\nprop_rfm = cluster_avg\/total_avg - 1\nprop_rfm.round(2)\n","81ea9105":"# heatmap with RFM\nf, (ax1, ax2) = plt.subplots(1,2, figsize=(15, 5))\nsns.heatmap(data=relative_imp, annot=True, fmt='.2f', cmap='Blues',ax=ax1)\nax1.set(title = \"Heatmap of K-Means\")\n\n# a snake plot with K-Means\nsns.heatmap(prop_rfm, cmap= 'Oranges', fmt= '.2f', annot = True,ax=ax2)\nax2.set(title = \"Heatmap of RFM quantile\")\n\nplt.suptitle(\"Heat Map of RFM\",fontsize=20) #make title fontsize subtitle \n\nplt.show()\n\n","e9dc4d52":"**Key steps**\n1. Data pre-processing\n2. Choosing a number of clusters\n3. Running k-means clustering on pre-processed data\n4. Analyzing average RFM values of each cluster","392e1c44":"Hi Kagglers,\n\nWelcome to My Kernal about Cohort Analysis (Retention over User & Product Lifttime) which we especially use more in E-commerce website, and Application Mobile \n\nIf there are any feedbacks\/suggestions you would like to see in the Kernel please let me know. This notebook will always be a work in progress. Please leave any comments about further improvements to the notebook. I appreciate every note!\n\nIf you like it, you can upvote and\/or leave a comment :)\n","a4a6d69c":"**Reference**\n- Customer segmentation on DataCamp course by Karolis Urbonas \"Head of Data Science, Amazon\" https:\/\/www.datacamp.com\/courses\/customer-segmentation-in-python\n- https:\/\/clevertap.com\/blog\/rfm-analysis\/\n- https:\/\/clevertap.com\/blog\/cohort-analysis\/\n- https:\/\/towardsdatascience.com\/who-is-your-golden-goose-cohort-analysis-50c9de5dbd31\n\n","ef51f996":"**Nots that: There are Missing Data in Description and The Customer ID Columns , let's check that**","2735760b":"**What is RFM?\n**\n- **RFM** is an acronym of recency, frequency and monetary. Recency is about when was the last order of a customer. It means the number of days since a customer made the last purchase. If it\u2019s a case for a website or an app, this could be interpreted as the last visit day or the last login time.\n\n- **Frequency** is about the number of purchase in a given period. It could be 3 months, 6 months or 1 year. So we can understand this value as for how often or how many a customer used the product of a company. The bigger the value is, the more engaged the customers are. Could we say them as our VIP? Not necessary. Cause we also have to think about how much they actually paid for each purchase, which means monetary value.\n\n- **Monetary** is the total amount of money a customer spent in that given period. Therefore big spenders will be differentiated with other customers such as MVP or VIP.\n\n![](http:\/\/d35fo82fjcw0y8.cloudfront.net\/2018\/03\/01013508\/Incontent_image.png)","3f58289f":"**From this table, we find this Problem: Mean and Variance are not Equal**\n\n**Soluation: Scaling variables by using a scaler from scikit-learn library**","3cbe016e":"**Use RFM score to group customers into Gold, Silver and Bronze segments:**","1f3a5918":"![](http:\/\/blog.appsee.com\/wp-content\/uploads\/2018\/06\/action-cohort-analysis-4.png)","be513dcd":"**Note Theat: We Choose No.KMeans = 3 **","6f19bb8a":"**The Result is a Table which has a row for each customer with their RFM **","e4e2627e":"Note That : The min for unit price = 0 and the min for Quantity with negative value ","0c3a5320":"**Snake plots to understand and compare segments**\n- Market research technique to compare different segments\n- Visual representation of each segment's attributes\n- Need to first normalize data (center & scale)\n- Plot each cluster's average normalized values of each attribute\n\n","ae4326bc":"In the real world, we would be working with the most recent snapshot of the data of today or yesterday","c8f6533e":"![](http:\/\/d35fo82fjcw0y8.cloudfront.net\/2016\/03\/03210554\/table1a2.png)","c3c31069":"**Process of calculating percentiles:**\n1. Sort customers based on that metric\n2. Break customers into a pre-defined number of groups of equal size\n3. Assign a label to each group","821f8dd4":"** Note That: Customer retention is a very useful metric to understand how many of the all customers are still active.Retention gives you the percentage of active customers compared to the total number of customers.**","42c5e8a1":"**Relative importance of segment attributes **\n- Useful technique to identify relative importance of each segment's attribute\n- Calculate average values of each cluster\n- Calculate average values of population\n- Calculate importance score by dividing them and subtracting 1 (ensures 0 is returned when cluster average equals population average)\n\n**Let\u2019s try again with a heat map. Heat maps are a graphical representation of data where larger values were colored in darker scales and smaller values in lighter scales. We can compare the variance between the groups quite intuitively by colors. **\n\n","c1184d78":"# Recency, Frequency and Monetary Value calculation","344c89ed":"**Largest RFM segments **\n**It is always the best practice to investigate the size of the segments before you use them for targeting or other business Application.**","788dd4f3":"**Import Libraries and DataSet **","0400f2b5":"**Note That : **\n\n**#We will rate \"Recency\" customer who have been active more recently better than the less recent customer,because each company wants its customers to be recent ** \n\n**#We will rate \"Frequency\" and \"Monetary Value\" higher label because we want Customer to spend more money and visit more often(that is  different order than recency). **","80f741ce":"**2. Choosing a Number of Clusters**","838f6efd":"**We use these Sequence of structuring pre-processing steps: **\n**1. Unskew the data - log transformation **\n\n**2. Standardize to the same average values **\n\n**3. Scale to the same standard deviation **\n\n**4. Store as a separate array to be used for clustering**\n_______________________________\n\n**Why the sequence matters?**\n- Log transformation only works with positive data\n- Normalization forces data to have negative values and log will not work","cb98d607":"# Data Pre-Processing for Kmeans Clustering","c71048ed":"**Filtering on RFM segments **","8029c192":"**Methods to define the number of clusters**\n- Visual methods - elbow criterion\n- Mathematical methods - silhouette coefficient\n- Experimentation and interpretation\n\n**Elbow criterion method ** \n- Plot the number of clusters against within-cluster sum-of-squared-errors (SSE) - sum of squared distances from every data point to their cluster center\n- Identify an \"elbow\" in the plot\n- Elbow - a point representing an \"optimal\" number of clusters","78b5113b":"**Average quantity for each cohort **","df6508c0":"![](http:\/\/www.omniconvert.com\/blog\/wp-content\/uploads\/2016\/03\/feature-img-marketizator-rfm.png)","48a8f721":"# Implementation of K-Means Clustering","ec7d12eb":"Check and Clean Missing Data ","3892fb6d":"Check & Clean Duplicates Data","8b002fd3":"**Retention Rate Table **","33b66b1c":"**Also, there is another Problem: UnSymmetric distribution of variables (data skewed)**\n\n**Soluation:Logarithmic transformation (positive values only) will manage skewness**","4e964323":"[](http:\/\/)","3dc92484":"**Explore + Clean the data **","ecf94780":"# Analyzing RFM Segments","237da7c6":"**The RFM values can be grouped in several ways: **\n\n**1.Percentiles e.g. quantiles **\n\n**2.Pareto 80\/20 cut**\n\n**3.Custom - based on business knowledge**\n\n**We are going to implement percentile-based grouping.**","b2c96d9b":"**You can Updated RFM data by adding Tenure variable : **\n** -Tenure: time since the first transaction \u060c Defines how long the customer has been with the company**\n\n**Conclusion:  We talked about how to get RFM values from customer purchase data, and we made two kinds of segmentation with RFM quantiles and K-Means clustering methods. **\n\n\n","75352559":"**For cohort analysis, there are a few labels that we have to create:**\n- Invoice period: A string representation of the year and month of a single transaction\/invoice.\n- Cohort group:\u200aA string representation of the the year and month of a customer\u2019s first purchase. This label is common across all invoices for a particular customer.\n- Cohort period \/ Cohort Index:\u200aA integer representation a customer\u2019s stage in its \u201clifetime\u201d. The number represents the number of months passed since the first purchase.\n\n","c8d342fe":"**** 1. Data Pre-Processing****\n","ba1c5e94":"# Let's Make Cohort Analysis","3115908f":"**We must check these Key k-means assumptions before we implement our Kmeans Clustering Mode**\n- Symmetric distribution of variables (not skewed)\n- Variables with same average values\n- Variables with same variance","3b5b16ea":"**Summary metrics per RFM Score **","9aa9437b":"# Cohort Analysis (Retention over User & Product Lifetime)","e9fda75d":"**A cohort** is a group of subjects who share a defining characteristic. We can observe how a cohort behaves across time and compare it to other cohorts. Cohorts are used in medicine, psychology, econometrics, ecology and many other areas to perform a cross-section (compare difference across subjects) at intervals through time. \n\n**Types of cohorts: \n**\n- Time Cohorts are customers who signed up for a product or service during a particular time frame. Analyzing these cohorts shows the customers\u2019 behavior depending on the time they started using the company\u2019s products or services. The time may be monthly or quarterly even daily.\n- Behaovior cohorts are customers who purchased a product or subscribed to a service in the past. It groups customers by the type of product or service they signed up. Customers who signed up for basic level services might have different needs than those who signed up for advanced services. Understaning the needs of the various cohorts can help a company design custom-made services or products for particular segments.\n- Size cohorts refer to the various sizes of customers who purchase company\u2019s products or services. This categorization can be based on the amount of spending in some periodic time after acquisition or the product type that the customer spent most of their order amount in some period of time.\n","a42d3903":"**Snake Plot and Heatmap**"}}