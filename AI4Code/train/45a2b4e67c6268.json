{"cell_type":{"cd8d7f52":"code","66ceebf5":"code","0b677a2b":"code","5f3d6323":"code","8c307745":"code","61f50344":"code","12afda8d":"code","02fb969b":"code","49071148":"code","952a8a1f":"code","a10190cb":"markdown","cc484686":"markdown","97fdae5b":"markdown","0a79def7":"markdown","0b51a599":"markdown","4256dcdd":"markdown","03a207a3":"markdown","99e7a87e":"markdown","9fd49b63":"markdown","1f43cd66":"markdown","f3723328":"markdown","fe7161f5":"markdown","3ca60da3":"markdown","cb1130a4":"markdown","ec85389b":"markdown"},"source":{"cd8d7f52":"import numpy as np\nimport pandas as pd","66ceebf5":"# if we set the parameters to 1,1,2, the method is calledd levenshstein distance\n\ndef dp_solver(word,target,del_cost=1,ins_cost=1,rep_cost=2):\n\n  # initialize\n  m=len(word)\n  n=len(target)\n  D=np.zeros((m+1,n+1))\n  for i in range(m+1):\n    D[i,0]=i\n  for j in range(n+1):\n    D[0,j]=j\n\n  for i in range(1,m+1):\n    for j in range(1,n+1):\n      if word[i-1]!=target[j-1]:\n        rp=rep_cost\n      else:\n        rp=0\n      \n      D[i,j]=min([D[i-1,j]+del_cost,D[i,j-1]+ins_cost,D[i-1,j-1]+rp])\n\n  min_dis=D[m,n]\n\n  return D,min_dis","0b677a2b":"word='intention'\ntarget='execution'\n\nmatrix,min_dis=dp_solver(word,target)\n\nprint('minimum distance edit number :' ,min_dis)\n\npd.DataFrame(matrix,columns=['#']+[c for c in target],\n             index=['#']+[c for c in word])","5f3d6323":"def BackTraceSolver(src,tar,del_cost=1,ins_cost=1,rep_cost=2):\n  m=len(src)\n  n=len(tar)\n\n  D=np.zeros((m+1,n+1))\n  \n  for i in range(m+1):\n    D[i,0]=i\n  for j in range(n+1):\n    D[0,j]=j\n\n  prt={}\n  for i in range(1,m+1):\n    for j in range(1,n+1):\n      if src[i-1]!=tar[j-1]:\n        rp=rep_cost\n      else:\n        rp=0\n\n      search={}\n      search[(i-1,j)]=D[i-1,j]+del_cost\n      search[(i,j-1)]=D[i,j-1]+ins_cost\n      search[(i-1,j-1)]=D[i-1,j-1]+rp\n\n\n      D[i,j]=min(search.values())\n\n      re_search={val:key for key,val in search.items()}\n\n      if (search[(i-1,j)]!=search[(i,j-1)]!=search[(i-1,j-1)]):\n        d_i,d_j=re_search[D[i,j]]\n        #record path\n        prt[(i,j)]=(d_i,d_j)\n\n      else:\n        #record path\n        prt[(i,j)]=(i-1,j-1)\n\n  # trace back from last point\n  trace_back=[]\n  last_pt=(m,n)\n  while True:\n    try :\n      prt[last_pt]\n    except:\n      trace_back.append(last_pt)\n      break\n    trace_back.append(last_pt)\n    last_pt=prt[last_pt]\n\n\n  min_dis=D[m,n]\n\n  return D,min_dis,trace_back","8c307745":"src='intention'\ntar='execution'\n\nmatrix,min_ids,trace_back=BackTraceSolver(src,tar)","61f50344":"trace_back","12afda8d":"trace_matrix=matrix.copy()\nfor item in trace_back:\n  i,j=item\n  trace_matrix[i][j]=1e-7","02fb969b":"df=pd.DataFrame(trace_matrix,columns=['#']+[c for c in target],\n             index=['#']+[c for c in word])\ndf","49071148":"print('i->#') #delete\nprint('n->e') #replace\nprint('t->x') #replace\nprint('e->e,c') #insert\nprint('n->u') #replace\nprint('tion->tion') #same","952a8a1f":"import seaborn as sns\n\nsns.heatmap(data=df)","a10190cb":"* left : insert\n\n* up : delete\n\n* diag : replace","cc484686":"heatmap","97fdae5b":"\n$$\\text{Per Cell Operations}$$\n\\begin{align}\n \\\\\nD[i,j] =min\n\\begin{cases}\nD[i-1,j] + del\\_cost\\\\\nD[i,j-1] + ins\\_cost\\\\\nD[i-1,j-1] + \\left\\{\\begin{matrix}\nrep\\_cost; & if src[i]\\neq tar[j]\\\\\n0 ; & if src[i]=tar[j]\n\\end{matrix}\\right.\n\\end{cases}\n\\tag{2}\n\\end{align}","0a79def7":"\\begin{align}\n \\\\\nptr[i,j] =\n\\begin{cases}\nLEFT(insert)\\\\\nDOWN(delete)\\\\\nDIAG(replace)\n\\end{cases}\n\\end{align}","0b51a599":"# Introduction","4256dcdd":"### Dynamic Programming(Levenshstein)","03a207a3":"* We often need to align each charactor of the two strings to each other \n\n* Every time we enter a cell, remember where we came from \n\n* When we reach the end, trace back the path from the upper right corner to read off the alignment","99e7a87e":"Goal:\n\n* evaluate spelling similarity of two string \n\n\n\nStep:\n\n* initial state : the word we're transforming\n\n* operators : delete,switch,replace,insert (Note that replace is equal to delete + insert)\n\n* goal state : the word we're trying to get to\n\n* path cost : what we want to minimize --- the number of edits\n\n\nMore application :\n\n* DNA, spell correction and more\n\n\nDetail introduction :\n\n* https:\/\/web.stanford.edu\/class\/cs124\/lec\/med.pdf","9fd49b63":"$$\\text{Base Conditions}$$\n\n\\begin{align}\nD[i,0] &= i \\ \\ \\ D[0,j] = j \n\\end{align}","1f43cd66":"### BackTrace","f3723328":"* Show the result by checking the table and print","fe7161f5":"$$\\text{Recurrence Relation}$$\n\n\\begin{align}\n \\\\\nD[i,j] =min\n\\begin{cases}\nD[i-1,j] + del\\_cost\\\\\nD[i,j-1] + ins\\_cost\\\\\nD[i-1,j-1] + \\left\\{\\begin{matrix}\nrep\\_cost; & if src[i]\\neq tar[j]\\\\\n0 ; & if src[i]=tar[j]\n\\end{matrix}\\right.\n\\end{cases}\n\\tag{2}\n\\end{align}","3ca60da3":" \n What can't we know from the DP table? :\n \n * I N T E & N T I O N\n\n * & E X E C U T I O N\n\n * I -> & : delete  (cost : 1)\n\n * N -> E : replace  (cost : 2)\n\n * T -> X : replace  (cost : 2)\n\n * & -> C : insert  (cost : 2)\n\n * N -> U : replace  (cost: 1 )\n\n\n Use BackTrace solve this problem","cb1130a4":"$$\\text{Initialization}$$\n\n\\begin{align}\nD[0,0] &= 0 \\\\\nD[i,0] &= D[i-1,0] + del\\_cost(source[i]) \\tag{1}\\\\\nD[0,j] &= D[0,j-1] + ins\\_cost(target[j]) \\\\\n\\end{align}","ec85389b":"# Algorithms"}}