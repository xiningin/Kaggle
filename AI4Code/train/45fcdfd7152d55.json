{"cell_type":{"58bd6e59":"code","f72124ab":"code","b6beaafa":"code","731d8f82":"code","1f75a751":"code","8c348c1b":"code","159530d7":"code","d15140d0":"code","534a57b0":"code","f225f8fd":"code","2a3447fa":"markdown","613564cf":"markdown","2ae744e7":"markdown","90000839":"markdown","bc4d6cdb":"markdown"},"source":{"58bd6e59":"import os\nimport glob\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport warnings\nimport numpy as np\nimport plotly.express as px\nwarnings.filterwarnings('ignore')\ntrain = pd.read_csv('..\/input\/optiver-realized-volatility-prediction\/train.csv')\ntrain.head()","f72124ab":"list_order_book_file_train = glob.glob('\/kaggle\/input\/optiver-realized-volatility-prediction\/book_train.parquet\/*')\n","b6beaafa":"time_id_unique = np.unique(list_order_book_file_train)","731d8f82":"def log_return(wap):\n    return np.log(wap).diff()\n\n\ndef realized_volatility(series_log_return):\n    return np.sqrt(np.sum(series_log_return**2))\n\ndef wap_1(df):\n    df['wap1'] =(df['bid_price1'] * df['ask_size1']+df['ask_price1'] * df['bid_size1'])  \/ (\n                              df['bid_size1']+ df['ask_size1'])\n    return df['wap1']\ndef wap_2(df):\n    df['wap2'] =(df['bid_price2'] * df['ask_size2']+df['ask_price2'] * df['bid_size2'])  \/ (\n                              df['bid_size2']+ df['ask_size2'])\n    return df['wap2'] \n\n\ndef wap_logreturn(df,index):\n    df['log_return{}'.format(index)] = df.groupby(['time_id'])['wap{}'.format(index)].apply(log_return)\n    df = df[~df['log_return{}'.format(index)].isnull()]\n    \n    ## Compute the realized volatility of the stock per time id \n    df_realized_vol_per_stock =  pd.DataFrame(df.groupby(['time_id'])['log_return{}'.format(index)].agg(realized_volatility)).reset_index()\n\n    return df_realized_vol_per_stock['log_return{}'.format(index)]\n\n\n\ndef realized_volatility_per_time_id(file_path):\n    df = pd.read_parquet(file_path)\n    df_realized_vol_per_stock = pd.DataFrame()\n\n\n    ## Calculate WAP\n    df['wap1'] = wap_1(df)\n    df['wap2'] = wap_2(df)\n    \n    ## Apply log return after grouping by id ( 5 then 6 then 7 ..... ) in order to apply the log return lag correctly\n    df_realized_vol_per_stock['rv1'] = wap_logreturn(df,1)\n    df_realized_vol_per_stock['rv2'] = wap_logreturn(df,2)\n    df_realized_vol_per_stock['time_id'] =  np.unique(np.array(df)[:,0]).flatten().astype(int)\n\n\n    ## Extract the stock index \/ indice\n    stock_id = file_path.split('=')[1]\n    df_realized_vol_per_stock['row_id'] = df_realized_vol_per_stock['time_id'].apply(lambda x:f'{stock_id}-{x}')\n    return df_realized_vol_per_stock[['row_id','rv1','rv2']]","1f75a751":"%time p = realized_volatility_per_time_id(list_order_book_file_train[0])\n","8c348c1b":"## I use this package to exploit the groupby function under numpy\n!pip3 install numpy_indexed\nimport numpy_indexed as npi\n","159530d7":"def wap_logreturn_numpy(df,index):\n    np_df = np.array(df).astype(np.float32)\n    np_df_unique_id = np.unique(np_df[:,0]).reshape(-1,1)\n    #rv = np.array([])\n\n    wap_grouby_timeid_flatten = npi.group_by(np_df[:, 0]).split(np_df[:, -2 + index]) \n    for i in range(len(wap_grouby_timeid_flatten)):\n        wap_grouby_timeid_flatten[i] = np.diff(np.log(wap_grouby_timeid_flatten[i]))\n\n    rv_list = []\n    for i in range(len(wap_grouby_timeid_flatten)):\n        rv_list.append(realized_volatility(wap_grouby_timeid_flatten[i]))\n      \n    rv_array = np.array(rv_list).reshape(-1,1)\n    rv = np.concatenate((np_df_unique_id,rv_array),axis=1)\n    return  rv","d15140d0":"def numpy_realized_volatility_per_time_id(file_path):\n    df = pd.read_parquet(file_path)\n    np_df_unique_id = np.unique(np.array(df)[:,0]).flatten()\n\n    df_realized_vol_per_stock = pd.DataFrame()\n    ## Calculate WAP\n    df['wap1'] = wap_1(df)\n    df['wap2'] = wap_2(df)\n    \n    ## Apply log return after grouping by id ( 5 then 6 then 7 ..... ) in order to apply the log return lag correctly\n    df_realized_vol_per_stock['rv1'] = wap_logreturn_numpy(df,0)[:,-1]\n    df_realized_vol_per_stock['rv2'] = wap_logreturn_numpy(df,1)[:,-1]\n\n    ## Extract the stock index \/ indice    \n    stock_id = np.int(file_path.split('=')[1])\n    \n    list_of_index = []\n    for i in range(len(np.unique(np_df_unique_id))):\n        list_of_index.append(f'{stock_id}-{np.int(np_df_unique_id[i])}')\n\n    df_realized_vol_per_stock['row_id'] = list_of_index\n\n    return df_realized_vol_per_stock[['row_id','rv1','rv2']]\n\ndf = pd.read_parquet(list_order_book_file_train[0])\ndf['wap1'] = wap_1(df)\ndf['wap2'] = wap_2(df)","534a57b0":"%time n = numpy_realized_volatility_per_time_id(list_order_book_file_train[0])","f225f8fd":"n[['row_id','rv1','rv2']] == p[['row_id','rv1','rv2']]","2a3447fa":" - `numpy_realized_volatility_per_time_id`is a global function that calls  `wap1` and `wap2`function, as well as   the previous one `wap_logreturn_numpy`.\n\n- Path name `split` was handled using simple list comprehension loop. ","613564cf":"# Numpy Implementation ","2ae744e7":"I re-implement the computation of log return as well as realized volatility because it seems that aggregation and applied function on groupby data slowed down the execution of the process.\n- The function is pretty simple, I took advantage of list and numpy array to extract the realized volatility using the `wap_logreturn_numpy` function.\n    - `index` argument was used to select the respective wap for each of `wap1` and `wap2`.\n    \n","90000839":"# Optimal variable extraction: 12X TIMES FASTER !\n\n**August 2021**\n\n**If you use parts of this notebook in your scripts\/notebooks, giving  some kind of credit would be very much appreciated :)  You can for instance link back to this `notebook`, and `upvote it`. Thanks!**\n\n\n\nIn this notebook, I implement my numpy's version of `realized_volatility_per_time_id` function, a crucial function for prediction, using only `numpy` array. My implemtation shows great performance as It performs 12 times faster than original Optiver's pandas implementation.\n\n**Results of the numpy implementation is showed below at the end.**","bc4d6cdb":"# Pandas function ( original implementation of the tutorial notebook )"}}