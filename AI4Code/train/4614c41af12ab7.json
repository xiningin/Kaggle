{"cell_type":{"a9e4eed5":"code","8f214f56":"code","2dc92fb7":"code","9c1f7f35":"code","d4e09344":"code","0789f0eb":"code","e283e8bd":"code","088c935f":"code","3235f467":"code","994568eb":"code","2745d8df":"code","1a927ba3":"code","04806890":"code","b57b0379":"code","550fb930":"code","549c0d74":"code","232e1549":"code","487478cc":"code","a29282a0":"code","3a95ad00":"code","56ece841":"code","4c471563":"code","9cce2482":"code","58d99b2c":"code","7d1347f7":"code","afe11c5a":"code","425bf073":"code","d46bbda2":"code","f79ab52c":"code","d527cb62":"markdown","89f83341":"markdown","6bf8cf99":"markdown","449d2ce5":"markdown","da34b058":"markdown","3a8328b9":"markdown","f4d60871":"markdown","7c25fc8b":"markdown","e4c98dec":"markdown","a12c7c48":"markdown","0cb8d497":"markdown","cd06c185":"markdown","c5ad0f4b":"markdown","b2434e06":"markdown","f9eff4f4":"markdown","c094e99d":"markdown","5f76305e":"markdown","91acd72f":"markdown","e393403d":"markdown","d5e0e85f":"markdown","e786296e":"markdown","6542e231":"markdown","f16a1e8f":"markdown","b54aa529":"markdown","dbbfad78":"markdown","dc47a920":"markdown","b595aa86":"markdown","e4edae64":"markdown","b77f1860":"markdown","92a5babf":"markdown","a18688b9":"markdown","69b1a1d0":"markdown","24817394":"markdown","2970afd3":"markdown"},"source":{"a9e4eed5":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\n#for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#    for filename in filenames:\n#        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","8f214f56":"import gensim\nimport matplotlib\nimport pickle\nimport gc","2dc92fb7":"def readarticle(filepath):\n    paperdata = {\"paper_id\" : None, \"title\" : None, \"abstract\" : None}\n    with open(filepath) as file:\n        filedata = json.load(file)\n        paperdata[\"paper_id\"] = filedata[\"paper_id\"]\n        paperdata[\"title\"] = filedata[\"metadata\"][\"title\"]\n                \n        if \"abstract\" in filedata:\n            abstract = []\n            for paragraph in filedata[\"abstract\"]:\n                abstract.append(paragraph[\"text\"])\n            abstract = '\\n'.join(abstract)\n            paperdata[\"abstract\"] = abstract\n        else:\n            paperdata[\"abstract\"] = []\n    return paperdata\n\ndef read_multiple(jsonfiles_pathnames):\n    papers = {\"paper_id\" : [], \"title\" : [], \"abstract\" : []}\n    for filepath in jsonfiles_pathnames:\n        paperdata = readarticle(filepath)\n        if len(paperdata[\"abstract\"]) > 0: \n            papers[\"paper_id\"].append(paperdata[\"paper_id\"])\n            papers[\"title\"].append(paperdata[\"title\"])\n            papers[\"abstract\"].append(paperdata[\"abstract\"])\n            #papers[\"body_text\"].append(paperdata[\"body_text\"])\n            #print(\"not none\")\n        #else:\n            #print(\"none\")\n    print(len(papers[\"paper_id\"]))\n    print(len(papers[\"title\"]))\n    print(len(papers[\"abstract\"]))\n    return papers\n\ndef make_bigram(tokenized_data, min_count = 5, threshold = 100):\n    bigram_phrases = gensim.models.Phrases(tokenized_data, min_count = min_count, threshold = threshold)\n    #after Phrases a Phraser is faster to access\n    bigram = gensim.models.phrases.Phraser(bigram_phrases)\n    gc.collect()\n    return bigram\n\ndef make_trigram(tokenized_data, min_count = 5, threshold = 100):\n    bigram_phrases = gensim.models.Phrases(tokenized_data, min_count = min_count, threshold = threshold)\n    trigram_phrases = gensim.models.Phrases(bigram_phrases[tokenized_data], threshold = 100)\n    #after Phrases a Phraser is faster to access\n    trigram = gensim.models.phrases.Phraser(trigram_phrases)\n    gc.collect()\n    return trigram\n\ndef readjson_retbodytext(jsonfiles_pathnames):\n    print(\"reading json files\")\n    documents = read_multiple(jsonfiles_pathnames)\n    print(\"writing documents dictionary to output for use in another kernel\")\n    with open(\"documents_dict.pkl\", 'wb') as f:\n        pickle.dump(documents, f)\n    print(\"done writing documents dict.  Format is paper_id, title, body_text\")\n    gc.collect()\n    return documents[\"abstract\"]\n    \ndef open_tokenize(jsonfiles_pathnames):\n    \n    body_text = readjson_retbodytext(jsonfiles_pathnames)\n    \n    print(\"removing stopwords, steming, and tokenizing.  This is expensive\")\n    tokenized_documents = gensim.parsing.preprocessing.preprocess_documents(body_text)\n    print(\"done preprocessing documents. now writing to output to be used in another documents\")\n    with open(\"tokenized_documents.pkl\", 'wb') as f:\n        pickle.dump(tokenized_documents, f)\n    print(\"done writing file\")\n    \n    gc.collect()\n    return tokenized_documents","9c1f7f35":"#no_n_below should be uint, ex: no_n_below = 3 or no_n_below = 5\n#no_freq_above should be float [0,1], ex: no_freq_above = 0.5\n#n_feats should be uint, ex: n_feats = 1024 or n_feats = 2048\ndef create_dictionary(tokenized_documents, n_feats, no_n_below = 3, no_freq_above = 0.5):\n    print(\"creating dictionary\")\n    id2word_dict = gensim.corpora.Dictionary(tokenized_documents)\n    print(\"done creating dictionary\")\n    \n    print(\"prior dictionary len %i\" % len(id2word_dict))\n    id2word_dict.filter_extremes(no_below = no_n_below, no_above = no_freq_above, keep_n = n_feats, keep_tokens = None)\n    print(\"current dictionary len %i\" % len(id2word_dict))\n    \n    return id2word_dict\n\ndef corpus_tf(id2word_dict, tokenized_documents):\n    return [id2word_dict.doc2bow(document) for document in tokenized_documents]\n\ndef try_parameters(tokenized_documents, n_feats, n_topics):\n    id2word_dict = create_dictionary(tokenized_documents, n_feats = n_feats)\n    tfcorpus = corpus_tf(id2word_dict, tokenized_documents)\n    print(\"training lda model with %i features and %i topics\" % (n_feats, n_topics))\n    lda_model = gensim.models.ldamodel.LdaModel(corpus = tfcorpus, num_topics = n_topics, id2word = id2word_dict, per_word_topics = False)\n    coherence_model = gensim.models.CoherenceModel(model = lda_model, texts = tokenized_documents, dictionary = id2word_dict, coherence = \"c_v\")\n    coherence_score = coherence_model.get_coherence()\n    print(\"coherence for unknown ngram with %i features and %i topics: %f\" % (n_feats, n_topics, coherence_score))\n    gc.collect()\n    return coherence_score\n\ndef loop_lda(tokenized_documents, \n                     tfcorpus, \n                     id2word_dict,\n                     start, #suggest 2 or something\n                     stop, # suggest 20 or similar\n                     step,\n                     per_word_topics = False): #compute list of topics for each word\n    topic_counts = []\n    coherence_scores = []\n    for n_topics in range (start, stop, step):\n        lda_model = gensim.models.ldamodel.LdaModel(corpus = tfcorpus, num_topics = n_topics, id2word = id2word_dict, per_word_topics = per_word_topics)\n        coherence_model = gensim.models.CoherenceModel(model = lda_model, texts = tokenized_documents, dictionary = id2word_dict, coherence = \"c_v\")\n        coherence_score = coherence_model.get_coherence()\n        coherence_scores.append(coherence_score)\n        topic_counts.append(n_topics)\n        print(\"coherence of %f with %i topics\" % (coherence_score, n_topics))\n              \n    return topic_counts, coherence_scores;\n        \ndef loop_ntopics_lda(tokenized_documents, n_feats, start, stop, step):\n    id2word_dict = create_dictionary(tokenized_documents, n_feats = n_feats)\n    tfcorpus = corpus_tf(id2word_dict, tokenized_documents)\n    topic_counts, coherence_scores = loop_lda(tokenized_documents, tfcorpus, id2word_dict, start, stop, step)\n    gc.collect()\n    return topic_counts, coherence_scores\n\nngram_bounds = (1,2)\nn_feats_bounds = (512,2048)\nn_topics_bounds = (1,20)\n\nbounds = [ngram_bounds, n_feats_bounds, n_topics_bounds]\n\ndef lda_objective(X, tokenized_documents, tokenized_bigram_documents):\n    ngram = int(round(X[0])) #bound should be [1,2]\n    n_feats = int(round(X[1])) #bounds should be [512, 2048]\n    n_topics = int(round(X[2])) #bouns should be [1,20]\n    \n    if ngram == 2:\n        documents = tokenized_bigram_documents\n        type_string = \"tokenized_bigram_documents\"\n    else:\n        documents = tokenized_documents\n        type_string = \"tokenized_documents\"\n\n    print(\"creating dictionary with %s for: %i %i %i\" % (type_string, ngram, n_feats, n_topics))\n    id2word_dict = create_dictionary(documents, n_feats = n_feats)\n\n    print(\"done creating dictionary.  creating corpus for: %i %i %i\" % (ngram, n_feats, n_topics))\n    tfcorpus = corpus_tf(id2word_dict, documents)\n\n    print(\"done creating corpus.  Building model for: %i %i %i\" % (ngram, n_feats, n_topics))\n    lda_model = gensim.models.ldamodel.LdaModel(corpus = tfcorpus, num_topics = n_topics, id2word = id2word_dict, per_word_topics = False)\n\n    print(\"calculating coherence for: %i %i %i\" % (ngram, n_feats, n_topics))\n    coherence_model = gensim.models.CoherenceModel(model = lda_model, texts = documents, dictionary = id2word_dict, coherence = \"c_v\")\n    coherence = coherence_model.get_coherence()\n    #we want to MAX coherence.  but we will be using a \n    value2minimize = 1 - coherence\n    return value2minimize\n","d4e09344":"def topic_distribution(query_string, id2word_dict, lda_model):\n    tokenized_query = gensim.parsing.preprocessing.preprocess_string(query_string)\n\n    print(\"tokens in query: %i\" % (len(tokenized_query)))\n    print(tokenized_query)\n    \n    vectorized_query = id2word_dict.doc2bow(tokenized_query)\n    \n    return lda_model[vectorized_query]    #query topic vector (distribution)\n    \ndef corpus_similarities_print3(query_topicvec, index, documents_dict):\n    similarities = index[query_topicvec]\n    ranked_indices = sorted(enumerate(similarities), key = lambda item: -item[1])\n    #papers = {\"paper_id\" : [], \"title\" : [], \"abstract\" : []}\n    \n    document_pids = documents_dict[\"paper_id\"]\n    document_titles = documents_dict[\"title\"]\n    #document_abstracts = documents_dict[\"abstract\"]\n    \n    print(ranked_indices[0][0])\n    topdex = ranked_indices[0][0]\n    second = ranked_indices[1][0]\n    third = ranked_indices[2][0]\n    \n    print(\"\\nTOP RESULT TITLE: %s\" % (document_titles[topdex]))\n    print(\"TOP RESULT PID: %s\" % (document_pids[topdex]))\n    print(second)\n    print(\"\\nSecond RESULT TITLE: %s\" % (document_titles[second]))\n    print(\"Second RESULT PID: %s\" % (document_pids[second]))\n    print(third)\n    print(\"\\nThird RESULT TITLE: %s\" % (document_titles[third]))\n    print(\"Third RESULT PID: %s\" % (document_pids[third]))\n    gc.collect()","0789f0eb":"coherence_results_path = \"\/kaggle\/input\/try-lda-parameters\/coherence_dict.pkl\"\nwith open(coherence_results_path, \"rb\") as f:\n    coherence_results = pickle.load(f)\n\n#including the defintion for this dictionary in the comments for our reference\n\n#coherence_dict = {\"topic_counts\" : topic_counts,\n#                  \"coherence_1gram_512features\" : coherence_1gram_512features,\n#                  \"coherence_1gram_1024features\" : coherence_1gram_1024features,\n#                  \"coherence_2gram_256features\" : coherence_2gram_256features, \n#                  \"coherence_2gram_512features\" : coherence_2gram_512features,\n#                  \"coherence_2gram_1024features\" : coherence_2gram_1024features}\n\nstart = coherence_results[\"topic_counts\"][0]\nlength = len(coherence_results[\"topic_counts\"])\nstop = length + start\n\nprint(start)\nprint(length)\nprint(stop)\n\nx = range(start, stop, 1)\nmatplotlib.pyplot.plot(x, coherence_results[\"coherence_1gram_512features\"], label = \"1gram_512feats\")\nmatplotlib.pyplot.plot(x, coherence_results[\"coherence_1gram_1024features\"], label = \"1gram_1024feats\")\nmatplotlib.pyplot.plot(x, coherence_results[\"coherence_2gram_256features\"], label = \"2gram_256feats\")\nmatplotlib.pyplot.plot(x, coherence_results[\"coherence_2gram_512features\"], label = \"2gram_512feats\")\nmatplotlib.pyplot.plot(x, coherence_results[\"coherence_2gram_1024features\"], label = \"2gram_1024feats\")\n\nmatplotlib.pyplot.xlabel(\"Number of topics\")\nmatplotlib.pyplot.ylabel(\"Coherence score\")\n\nmatplotlib.pyplot.title(\"Coherence values for for gram 1 and 2, and features 256, 512, and 1024\")\nmatplotlib.pyplot.legend()\nmatplotlib.pyplot.show()","e283e8bd":"tokenized_path = \"\/kaggle\/input\/preprocess-cord19\/tokenized_documents.pkl\"\nprint(\"opening %s\" % str(tokenized_path)) \nwith open(tokenized_path, \"rb\") as f:\n    tokenized_documents = pickle.load(f)\nprint(\"done opening tokenized documents.  Optimizing\")\n\nbigram_path = \"\/kaggle\/input\/preprocess-cord19\/bigram_model.pkl\"\nprint(\"opening %s\" % str(bigram_path))\nwith open(bigram_path, \"rb\") as f:\n    bigram_model = pickle.load(f)\nprint(\"creating bigram documents\")\ntokenized_document = [bigram_model[document] for document in tokenized_documents]\nprint(\"done retrieving documents. lets optimize\")\n\nn_feats = 512\nn_topics = 18\nid2word_dict = create_dictionary(tokenized_documents, n_feats = n_feats)\ntfcorpus = corpus_tf(id2word_dict, tokenized_documents)\nprint(\"training lda model with %i topics\" % (n_topics))\nlda_model = gensim.models.ldamodel.LdaModel(corpus = tfcorpus, num_topics = n_topics, id2word = id2word_dict, per_word_topics = False)\ncoherence_model = gensim.models.CoherenceModel(model = lda_model, texts = tokenized_documents, dictionary = id2word_dict, coherence = \"c_v\")\ncoherence_score = coherence_model.get_coherence()\nprint(\"Achieved coherence of: %f\" % (coherence_score))\n","088c935f":"#build index for document similarity.  the similarity method used will be cosine similarity\nprint(\"creating index\")\nindex = gensim.similarities.MatrixSimilarity(lda_model[tfcorpus])\nprint(\"done creating index\")\n\ndocuments_path = \"\/kaggle\/input\/preprocess-cord19\/documents_dict.pkl\"\nwith open(documents_path, \"rb\") as f:\n    documents_dict = pickle.load(f)\nprint(\"done opening raw documents\")\n\n","3235f467":"query = \"What has been published about information sharing and inter-sectoral collaboration? \"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","994568eb":"query = \"What has been published about data standards and nomenclature?\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","2745d8df":"query = \"What has been published about governmental public health?\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","1a927ba3":"query = \"What do we know about risk communication?\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","04806890":"query = \"What has been published about communicating with high-risk populations?\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","b57b0379":"query = \"What has been published to clarify community measures?\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","550fb930":"query = \"What has been published about equity considerations and problems of inequity?\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","549c0d74":"query = \"Methods for coordinating data-gathering with standardized nomenclature.\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","232e1549":"query = \"Sharing response information among planners, providers, and others.\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","487478cc":"query = \"Understanding and mitigating barriers to information-sharing.\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","a29282a0":"query = \"How to recruit, support, and coordinate local (non-Federal) expertise and capacity relevant to public health emergency response (public, private, commercial and non-profit, including academic).\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","3a95ad00":"query = \"Integration of federal\/state\/local public health surveillance systems.\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","56ece841":"query = \"Value of investments in baseline public health response infrastructure preparedness\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","4c471563":"query = \"Modes of communicating with target high-risk populations (elderly, health care workers).\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","9cce2482":"query = \"Risk communication and guidelines that are easy to understand and follow (include targeting at risk populations\u2019 families too).\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","58d99b2c":"query = \"Communication that indicates potential risk of disease to all population groups.\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","7d1347f7":"query = \"Misunderstanding around containment and mitigation.\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","afe11c5a":"query = \"Action plan to mitigate gaps and problems of inequity in the Nation\u2019s public health capability, capacity, and funding to ensure all citizens in need are supported and can access information, surveillance, and treatment.\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","425bf073":"query = \"Measures to reach marginalized and disadvantaged populations.\nData systems and research priorities and agendas incorporate attention to the needs and circumstances of disadvantaged populations and underrepresented minorities.\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","d46bbda2":"query = \"Mitigating threats to incarcerated people from COVID-19, assuring access to information, prevention, diagnosis, and treatment.\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","f79ab52c":"query = \"Understanding coverage policies (barriers and opportunities) related to testing, treatment, and care\"\nquery_topicvec = topic_distribution(query, id2word_dict, lda_model)\ncorpus_similarities_print3(query_topicvec, index, documents_dict)","d527cb62":"# \"What has been published about equity considerations and problems of inequity?\"","89f83341":"# \"What do we know about risk communication?\"","6bf8cf99":"# \"Value of investments in baseline public health response infrastructure preparedness\"","449d2ce5":"# \"Sharing response information among planners, providers, and others.\"","da34b058":"# Definitions from preprocessing kernel\n\nIncluding definitions from the preprocessing step here.  They are not used in this kernel.  The output from the preprocessing step is used as input to this notebook.\n\n**Definition for reading the json files:**\nThe purpose of these definitions is to read all json files in a path and return a dictionary containing entries for the paper's id, title, abstract, and body text. These json files are the papers that we have full body text for.  Now that we are up to 50k+ documents we keep running out of memory.  We will limit ourselves to abstracts under the assumption that abstracts should summarize the entire paper including results.\n\n**Bigram and trigram definitions:**\nBelow are definitions for making bigrams (sequences of 2 words) and trigrams (collections of 3 words). We will be skipping trigrams, but the definition is included in case it is desired later.\n\n**Definitions for tokenizing documents:**\nReading in the documents was done inside the same function that tokenizes the documents so that the raw documents can go out of scope. This is done to reduce memory usage. We will only be looking at papers that have a json file. We will be saving the resulting dictionary for use later.","3a8328b9":"# \"Methods for coordinating data-gathering with standardized nomenclature.\"","f4d60871":"# \"Integration of federal\/state\/local public health surveillance systems.\"","7c25fc8b":"# \"What has been published to clarify community measures?\"","e4c98dec":"# \"Misunderstanding around containment and mitigation.\"","a12c7c48":"# Try LDA Parameters steps\nCode available in the public kernel that produced the \"try-lda-parameters\" input.\nTry ngrams (1 and 2), number of features, and number of topics\n1.  Open tokenized documents from preprocesing steps.  This will serve as our 1gram.\n2.  Set features to 512 and loop through [2,20] LDA topics and collect coherence scores. Set features to 1024 and loop through [2,20] LDA topics and collect coherence scores.\n3.  Open bigram model.  Run tokenized document through the bigram model in order to obtain tokenized bigram documents.\n4.  Set features to 256 and loop through [2,20] LDA topics and collect coherence scores. Set features to 512 and loop through [2,20] LDA topics and collect coherence scores.\n5.  Save results for use in this notebook.\n","0cb8d497":"# \"Modes of communicating with target high-risk populations (elderly, health care workers).\"","cd06c185":"# \"Measures to reach marginalized and disadvantaged populations.\nData systems and research priorities and agendas incorporate attention to the needs and circumstances of disadvantaged populations and underrepresented minorities.\"","c5ad0f4b":"# \"What has been published about information sharing and inter-sectoral collaboration? \"","b2434e06":"# \"How to recruit, support, and coordinate local (non-Federal) expertise and capacity relevant to public health emergency response (public, private, commercial and non-profit, including academic).\"","f9eff4f4":"This is the final portion of an effor to optimize some parameters for a Latent Dirichlet Allocation (LDA) topic model. We break up this effort into multiple steps in order to speed up testing and making changes. This also uses less memory and is less likely to time out.  There are many parameters we could attempt to optimize.  However, due to processing constraints we limit ourselves to the number of topics and the number of features (word or bigrams).\n\nA topic model learns a topic-feature matrix of abstract topics and features (word or ngrams) and a document-topic matrix of documents and topics, from a document-feature matrix of documents and features. From this factorization we achieve statistical feature vectors for each topic and topic vectors for each document in the training corpus. We can then find topic vectors for the questions we would like to ask the corpus of documents. We will use the closest matching documents in the CORD-19 dataset in an attempt to answer the task questions. LDA assumes a Dirichlet prior on topic-feature and document-topic distributions. In other words it assumes each topic is defined by and small collection of words or ngrams and that each documnent consists of a small number of topics.\n\nThe advantage of trying to find some configurations of LDA training parameters with better coherence scores is that the resulting topic model might perform better under this tasks queries than they would from random parameter selection.  However, coherence is not a human measure (involving humans would be expensive and negate the benifit of first step automation) and we only varied a select few parameters (there are more parameter that could impact human perception of the results).\n\nWe will be relying on paper titles and PIDs as answers to the task's queries.  The papers have the advantage of being written by humans (rather than a generated summary) and therefore is assumed to be understandable.  However, it is up to the person asking the question to then go to the referenced papers and determine if their question is answered.","c094e99d":"# \"Understanding coverage policies (barriers and opportunities) related to testing, treatment, and care\"","5f76305e":"# \"Action plan to mitigate gaps and problems of inequity in the Nation\u2019s public health capability, capacity, and funding to ensure all citizens in need are supported and can access information, surveillance, and treatment.\"","91acd72f":"# Specific Questions\nThese are the specific bullet points to be addressed in this task","e393403d":"# \"Mitigating threats to incarcerated people from COVID-19, assuring access to information, prevention, diagnosis, and treatment.\"","d5e0e85f":"# Definitions for query topic vectors and ranking \n**Topic distribution:**\nThis definition takes a provided string, tokenizes it with the provided dictionary (either word or bigram based), and then returns a topic distribution vector using a provided LDA topic model.\n**Print top 3 matches:**\nthis takes a query in the form of a topic distribution and a gensim similarity matrix designed to efficiently calculate cosine similarities and then creates a ranked list of indices for the matches.  The indices are used along with a provided dictionary of the raw data in order to print the title and abstract of the top three matching papers.","e786296e":"# Create similarity index.\nThis gensim matrix is designed to easily calculate cosine similary with-respect-to entry indices.  It can be sorted to ","6542e231":"# \"What has been published about governmental public health?\"","f16a1e8f":"# Open and view results from parameter search\nHere we will view the results from our various combinations of ngram (1 and 2), number of features, and number of topics","b54aa529":"# \"What has been published about data standards and nomenclature?\"","dbbfad78":"# \"What has been published about communicating with high-risk populations?\"","dc47a920":"# Additional Imports \nGensim imported for natural language processing tasks; matplotlib imported for plotting; pickle used for opening results saved from previous steps;","b595aa86":"# \"Understanding and mitigating barriers to information-sharing.\"","e4edae64":"# Broad questions\nWe will start will the broad scope questions for this task.","b77f1860":"# \"Risk communication and guidelines that are easy to understand and follow (include targeting at risk populations\u2019 families too).\"","92a5babf":"# Definitions for \"Try LDA Parameters\" kernel\nIn this portion of our effort to tune some of the LDA parameters, we will try configurations of several hyperparameters.  The parameters we will vary are: ngram (1 or 2), number of features (words or bigrams) in the feature distribution vectors of the topics, and number of topics to factor for when creating the LDA model (topic-feature matrix).\n\n**Create Dictionary:**\nThis is the definition for creating a dictionary for our corpus. Number of features (word stems of ngrams) will be the variable optimized for using this function.\n\n**Create term frequency corpus:**\nDefinition for creating the corpus from the dictionary and documents.\n\n**Try model configuration:**\nDefinition to train a LDA Model and the compute the coherence score.\n\n**Loop through number of topics:**  Given a set ngram (1 or 2) and feature length, loop through number of topics given the start, stop, and step bounds.  For each n_topics build an LDA topic model, calculate coherence, and return coherence list.\n\n**Objective function for differential evolution optimization:**\nOriginally we wanted to use differential evolution to optimize LDA parameters.  However, we were unable to use this technique because each mumber of the population requires compute and memory resources to evaluate the objective function. \n\nDifferential evolution uses a population to try many different parameters, removes the poor performing population members, makes combinations of the more successfull population members, performs some mutations, and then repeats until some stopping condintion (number of evolutions, or no improvement after a given number of steps).  In this way it hopes to achieve good non-linear optimization.  Differential evolution is similar to genetic algorithms, but skips the chromosome string encoding and acts directly on the variables.   We would need to reserve extra compute resources for this technique.  Note that we need to define a vector of tuples for the bounds, and that some parameters need to be converted to to int (uint) because this scipy function works with floats only.","a18688b9":"# Choose ngram, number of features, and number of topics\nFrom the above results we choose our ngram (words or bigram), number of featurs, and number of topics.  It would be preferable to save the best performing model from the previous testing and load it.\n* We will select the tokenized bigram documents\n* We will select 512 features\n* We will use 18 topics","69b1a1d0":"# \"Communication that indicates potential risk of disease to all population groups.\"","24817394":"# Preprocessing steps\nCode available in the public kernel that produced the preprocess input.\n\n1. **Look at metadata and print information**\n2. **Collect json file paths**\n3. **Remove stopwords, stem, tokenize documents, and save.**  Stopwords are words common to all text, such as \"and\" and \"the,\" and therefore we remove them. Stemming reduces words to their root form. For example, \"infected\" and \"infecting\" will both be reduced to \"infect.\" Tokenization converts the body text of each paper into a vector of whitespace-separated text (words). These tokens will be treated as semantic features, particularly after stemming. When we create the document-feature matrix (term frequency corpus) the exact text of the word (or bigram) will no longer be observed, as these features define the row vectors of that matrix. Here, we save the tokenized documents.\n4. **Create bigram model and save.  In this section we create and save the bigram model.** This just contains the word pair. We will have to run the tokenized documents through the model in order to create a bigram tokenized version of the documents. We will do that in another step therefore we save the model here.","2970afd3":"# Introduction"}}