{"cell_type":{"55f599e2":"code","1cc228cd":"code","21afe04d":"code","008df604":"code","dfe590d4":"code","83c8d4e2":"code","06a24363":"code","09585b9c":"code","c784da28":"code","39775082":"code","0b3e88fa":"code","141121c8":"code","36cfb748":"code","eb8057f8":"code","db275018":"code","4976b36c":"code","0e9adfa5":"code","b7b3273c":"code","6c69fb4d":"code","3292b379":"code","38265af4":"code","7f951a9b":"code","20685914":"markdown","9b748a2c":"markdown","ce244a76":"markdown","2e01ba23":"markdown","efd57112":"markdown","e6bc1610":"markdown"},"source":{"55f599e2":"# load tools\nimport os\nimport tensorflow as tf\nimport tensorflow_datasets as tfds\nimport tensorflow_addons as tfa\nimport math\nfrom tensorflow import keras\nfrom tensorflow.keras import layers, regularizers\nimport matplotlib.pyplot as plt ","1cc228cd":"# load data from Tensorflow datasets catalog (balanced!)\nds, ds_info = tfds.load(\n    \"malaria\",\n    split=\"train\",\n    shuffle_files=True,\n    as_supervised=True,\n    with_info=True\n)","21afe04d":"#general information about the Dataset\nprint(ds_info)","008df604":"#split into train and test set\ntrain_size = int(0.8 * 27558)\ntest_size = int(0.2 * 27558)\n\nds_train = ds.take(train_size)\nds_test = ds.skip(train_size)","dfe590d4":"#normalization\n@tf.function\ndef normalize_img(image, label):\n    return tf.cast(image, tf.float32) \/ 255.0,  label","83c8d4e2":"#rotation\n@tf.function\ndef rotate(img, max_degrees=25):\n    degrees = tf.random.uniform([], -max_degrees, max_degrees, dtype=tf.float32)\n    img = tfa.image.rotate(img, degrees*math.pi \/ 180, interpolation=\"BILINEAR\")\n    return img","06a24363":"#augmentation\n@tf.function\ndef augment(image, label):\n    image = tf.image.resize(image, size=[30, 30])\n    image = rotate(image)\n    image = tf.image.random_brightness(image, max_delta=0.2)\n    image = tf.image.random_contrast(image, lower=0.5, upper=1.5)\n    return image, label","09585b9c":"#necessary paramters\nAUTOTUNE=tf.data.experimental.AUTOTUNE\nBATCH_SIZE=16","c784da28":"#data preprocessing\nds_train = ds_train.cache()\nds_train = ds_train.shuffle(2021)\nds_train = ds_train.map(normalize_img, num_parallel_calls=AUTOTUNE)\nds_train = ds_train.map(augment, num_parallel_calls=AUTOTUNE)\nds_train = ds_train.batch(BATCH_SIZE)\nds_train = ds_train.prefetch(AUTOTUNE)\n\nds_test = ds_test.map(augment, num_parallel_calls=AUTOTUNE)\nds_test = ds_test.batch(BATCH_SIZE)\nds_test = ds_test.prefetch(AUTOTUNE)","39775082":"#get one batch of image, label pair\nimage_batch, label_batch = next(iter(ds_train))","0b3e88fa":"#visualization function\ndef show_batch(image_batch, label_batch):\n    plt.figure(figsize=(10,10))\n    for n in range(16):\n        ax = plt.subplot(4,4,n+1)\n        plt.imshow(image_batch[n])\n        if label_batch[n]:\n            plt.title(\"uninfected\")\n        else:\n            plt.title(\"infected\")\n        plt.axis(\"off\")","141121c8":"#viol\u00e0\nshow_batch(image_batch.numpy(), label_batch.numpy())","36cfb748":"#pretty standart model\ndef my_model():\n    inputs = keras.Input(shape=(30,30, 3))\n    x = layers.Conv2D(\n        16, 3)(inputs)\n    x = layers.BatchNormalization()(x)\n    x = keras.activations.relu(x)\n    x = layers.MaxPooling2D()(x)\n    x = layers.Conv2D(\n        32, 3)(inputs)\n    x = layers.BatchNormalization()(x)\n    x = keras.activations.relu(x)\n    x = layers.MaxPooling2D()(x)    \n    x = layers.Conv2D(\n        64, 3)(inputs)\n    x = layers.BatchNormalization()(x)\n    x = keras.activations.relu(x)\n    x = layers.Flatten()(x)\n    x = layers.Dense(\n        32, activation=\"relu\")(x)\n    #x = layers.Dropout(0.3)(x)\n    outputs = layers.Dense(2, activation=\"softmax\")(x)\n    return keras.Model(inputs=inputs, outputs=outputs)","eb8057f8":"#actucal building\nmodel = my_model()","db275018":"#overview\nmodel.summary()","4976b36c":"#callback\n#save_callback = keras.callbacks.ModelCheckpoint(\n#    \"checkpoint\/\",\n#    monitor=\"accuracy\",\n#    save_best_only = True\n#)","0e9adfa5":"#compile + fit\nmodel.compile(\n    loss=keras.losses.SparseCategoricalCrossentropy(from_logits=False),\n    optimizer=keras.optimizers.Adam(lr=1e-4),\n    metrics=[\"accuracy\"]\n)\nmodel.fit(ds_train, epochs=8, verbose=2)","b7b3273c":"#evaluation\nmodel.evaluate(ds_test)","6c69fb4d":"import numpy as np\npredictions = np.argmax(model.predict(ds_test), axis = 1)\n\nimages, labels = tuple(zip(*ds_test.unbatch()))\nlabels = np.array(labels)","3292b379":"from sklearn.metrics import confusion_matrix\n%matplotlib inline\nimport itertools\nimport matplotlib.pyplot as plt\n\ncm = confusion_matrix(y_true=labels, y_pred=predictions)","38265af4":"def plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        print(\"Normalized confusion matrix\")\n    else:\n        print('Confusion matrix, without normalization')\n\n    print(cm)\n\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","7f951a9b":"classes = [\"uninfected\", \"infected\"]\nplot_confusion_matrix(cm, classes=classes, title=\"Confusion Matrix\")","20685914":"# 2. Image Preprocessing","9b748a2c":"# Malaria Classifier\n\n![image.png](attachment:9e3c7b36-f42d-46e9-9aa3-09463d69dea7.png)\n\nIn this notebook we are going to predict whether a cell is infected with Malaria or not based on microscopic images. This kernel is straigt forward and just addressed to people who are familiar with CNNs and Tensorflow - enjoy.\n\nBest score: 82% accuracy\n\n# Agenda:\n1. Load Dataset\n2. Image Preprocessing\n3. Visualization\n4. Model Building + Training","ce244a76":"# 1. Load Dataset","2e01ba23":"# 3. Visualization","efd57112":"# 4. Model Building + Training","e6bc1610":"I think especially in term of time efficiency we are happy with an test accuracy of 82%. This kernel took us about 1-2h in total. See you on my next kernel."}}