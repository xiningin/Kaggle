{"cell_type":{"0f74c459":"code","cb61faf0":"code","7a14340a":"code","33c84b52":"code","f6221940":"code","f2e20ecf":"code","bb38360a":"code","b79e4f5a":"code","4c4d4cf3":"code","66a58e91":"code","1eab5232":"code","eebfbfa5":"code","560e85f5":"code","b9d690c6":"code","2de873e8":"code","c778e533":"code","372e7ef1":"code","752a5216":"code","e2d5e28d":"code","d9843eee":"code","95b8f267":"code","f6b1beb0":"code","47a0775a":"code","16d88d01":"code","97c98dac":"code","bf6420f1":"code","c22938e6":"code","07a9e678":"code","92bd4b4b":"code","0887f0dc":"code","bd843e8b":"code","3cac1cff":"code","8cd1d1ec":"code","287159df":"code","34ab841d":"code","3369d845":"code","f9d639d4":"code","7fb5993f":"code","e98de71a":"code","51639600":"code","ef056a71":"code","c5c0db7e":"code","912c4dd5":"code","2e2c6be5":"code","a0305721":"code","5a2a984d":"code","d67b875a":"code","97ca9302":"code","d7468d63":"code","59b9283c":"code","e74bdd13":"code","c7d11fc9":"code","69343524":"code","563d3cf3":"code","2b11294f":"code","0722ea0e":"code","58c6b9d5":"code","7d1ed6ea":"code","7142efa7":"code","8ca06fe7":"code","e11fc367":"code","244d9ab7":"code","23dcec10":"code","73116ee4":"code","1df98a7e":"code","29297538":"code","d5578488":"code","ef0c3e49":"code","1cd8209d":"code","10fa8a89":"code","7fbba641":"code","c6d03a30":"code","49746acc":"code","e4e6ddf8":"code","d74878f2":"code","dead969a":"code","8c492c22":"code","25268fe9":"code","e750411d":"code","c7ee4f7c":"code","90d24a48":"code","94766eaa":"code","b9ea513a":"code","8c1209e2":"code","f9ac4c15":"code","7f5d1cf0":"code","546cb130":"code","9acd4e18":"code","32c0fad5":"code","347e9c6e":"code","53968b79":"code","f0c598d3":"code","58e79cac":"code","204c48ed":"code","0d40f369":"code","77d59640":"code","32f8347f":"code","91cd1bfe":"code","d4658ddc":"code","d64ff093":"code","a2dcc076":"code","bc5bf501":"code","0540feb5":"code","6e7676bc":"code","970d9195":"code","af0f030d":"code","dab43900":"markdown","f3a4a502":"markdown","3d55bf74":"markdown","d7b9f416":"markdown","98e32f44":"markdown","86f4e1e5":"markdown","84675fda":"markdown","5ca81aee":"markdown","e23ff449":"markdown","2ff945eb":"markdown","f002e936":"markdown","e7a421d9":"markdown","8c53fb7d":"markdown","be5cb396":"markdown","ab831e7e":"markdown","da926785":"markdown","f386b516":"markdown","c3eeae71":"markdown","abe09124":"markdown","62ebe5cb":"markdown","e6a0d790":"markdown","563aa387":"markdown","2b68861e":"markdown","01c62ce7":"markdown","8ce388f6":"markdown","c3bc8f34":"markdown","5594a8b9":"markdown","5b88f3f4":"markdown","38ae1b2c":"markdown","88cfcf5c":"markdown","b7faace6":"markdown","444d6d50":"markdown","f7e5ae3d":"markdown","a506e3d5":"markdown","fc46acbf":"markdown","7413baa3":"markdown","6b45fc10":"markdown","98a4ab35":"markdown","c7a6fe22":"markdown","7163a810":"markdown","f4cfdb39":"markdown","86b5054e":"markdown","eebcd46b":"markdown","faec6cb2":"markdown","3f32a544":"markdown","feddf1ab":"markdown","5a555c23":"markdown","340a555b":"markdown","a63e5ef9":"markdown","204fd5a9":"markdown","db308ba1":"markdown","bdc9f094":"markdown","97c5ff3e":"markdown","5206c71b":"markdown","089c4041":"markdown","a204f7ca":"markdown","7fa1ee2f":"markdown","280661cf":"markdown","e8415aee":"markdown","c734e036":"markdown"},"source":{"0f74c459":"import re\nfrom pprint import pprint\nfrom copy import deepcopy\nfrom itertools import product\nimport pandas as pd\n%matplotlib inline\n\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\n\npd.set_option('display.max_colwidth', None)","cb61faf0":"orders = pd.read_csv('..\/input\/opn-rd2-acv\/orders.csv')","7a14340a":"# Specify dtypes prevents mixed types of int,str after reading. Makes merging accurate\nbank = pd.read_csv('..\/input\/opn-rd2-acv\/bank_accounts.csv',dtype={'bank_account':str})  ","33c84b52":"cc = pd.read_csv('..\/input\/opn-rd2-acv\/credit_cards.csv')","f6221940":"devices = pd.read_csv('..\/input\/opn-rd2-acv\/devices.csv')","f2e20ecf":"sum(orders.duplicated())\nsum(bank.duplicated())\nsum(cc.duplicated())\nsum(devices.duplicated())","bb38360a":"bank = bank.drop_duplicates()\nsum(bank.duplicated())","b79e4f5a":"orders.head()\norders.info()\norders.describe()","4c4d4cf3":"bank.head()\nbank.info()","66a58e91":"cc.head()\ncc.info()","1eab5232":"devices.head()\ndevices.info()","eebfbfa5":"#buyer_userid seller_userid\ndevice_merge = (orders.merge(devices,left_on='buyer_userid',right_on='userid').rename(columns={'device':'buyer_device'})\n                     .merge(devices,left_on='seller_userid',right_on='userid').rename(columns={'device':'seller_device'})\n               )\ndevice_merge","560e85f5":"device_fraud_mask = device_merge['buyer_device'] == device_merge['seller_device']\n# 355 will become 291 later due to each orderid having multiple methods to fraud with different devices)\nsum(device_fraud_mask)   ","b9d690c6":"device_fraud = device_merge[device_fraud_mask]\ndevice_fraud.head()","2de873e8":"device_fraud['d_chain'] = (device_fraud['buyer_userid'].astype(str) \n                                  + '-\"'\n                                  +'device:'\n                                  + device_fraud['buyer_device']\n                                  + '\"->'\n                                  + device_fraud['seller_userid'].astype(str)\n                                 )","c778e533":"device_fraud.head()","372e7ef1":"bank_merge = (orders.merge(bank,left_on='buyer_userid',right_on='userid').rename(columns={'bank_account':'buyer_bank'})\n                     .merge(bank,left_on='seller_userid',right_on='userid').rename(columns={'bank_account':'seller_bank'})\n               )\nbank_merge","752a5216":"bank_fraud_mask = bank_merge['buyer_bank'] == bank_merge['seller_bank']","e2d5e28d":"# bank_fraud_mask is 34 only if not converting to object (dtype={'bank_account':str}) when reading bank_accounts.csv\n# 56 will become 54 later due to each orderid having multiple methods to fraud with different devices)\nsum(bank_fraud_mask)     ","d9843eee":"bank_fraud = bank_merge[bank_fraud_mask]\nbank_fraud.head()","95b8f267":"bank_fraud['b_chain'] = (bank_fraud['buyer_userid'].astype(str) \n                                  + '-\"'\n                                  +'bank_account:'\n                                  + bank_fraud['buyer_bank']\n                                  + '\"->'\n                                  + bank_fraud['seller_userid'].astype(str)\n                                 )","f6b1beb0":"bank_fraud.head()","47a0775a":"# Both bank and device fraud in same orderid \nlen(set(bank_fraud.orderid) & set(device_fraud.orderid))","16d88d01":"cc_merge = (orders.merge(cc,left_on='buyer_userid',right_on='userid').rename(columns={'credit_card':'buyer_cc'})\n                .merge(cc,left_on='seller_userid',right_on='userid').rename(columns={'credit_card':'seller_cc'})\n               )\ncc_merge","97c98dac":"cc_fraud_mask = cc_merge['buyer_cc'] == cc_merge['seller_cc']\nsum(cc_fraud_mask)","bf6420f1":"is_fraud = ['not fraud']*len(orders)\nresult = dict(zip(orders.orderid,is_fraud))","c22938e6":"len(device_fraud['d_chain'].values)","07a9e678":"device_repeats = device_fraud.groupby('orderid').filter(lambda group:len(group)>1)\ndevice_repeats","92bd4b4b":"device_repeats.orderid.nunique()\ndevice_repeats.groupby('orderid').size().sort_values(ascending=False)","0887f0dc":"# view some samples of top 2 orderid with most number of ways to device fraud\ndevice_repeats.query('orderid==1955166134')  \ndevice_repeats.query('orderid==1954135512')  ","bd843e8b":"# sort descending so smallest alphetic string appears last\n# smallest string will overwrite previously larger strings assigned to same orderid  \ndevice_fraud_sorted = device_fraud.sort_values(by='d_chain',ascending=False)\nd_chain_dic = dict(zip(device_fraud_sorted['orderid'].values,device_fraud_sorted['d_chain'].values))","3cac1cff":"len(d_chain_dic)","8cd1d1ec":"# update device first so later updating bank direct frauds on same orderid can overwrite direct device fraud chain\nresult.update(d_chain_dic)","287159df":"len(bank_fraud['b_chain'].values)","34ab841d":"bank_repeats = bank_fraud.groupby('orderid').filter(lambda group:len(group)>1)\nbank_repeats\n\n# Two order ids have 2 rows with same orderid with multiple bank acc --> get the smaller alphabetical bank","3369d845":"bank_repeats.groupby('orderid').size()","f9d639d4":"bank_fraud_sorted = bank_fraud.sort_values(by='b_chain',ascending=False)\nb_chain_dic = dict(zip(bank_fraud_sorted['orderid'].values,bank_fraud_sorted['b_chain'].values))","7fb5993f":"len(b_chain_dic)","e98de71a":"result.update(b_chain_dic)","51639600":"buyer_cc_linkable = orders.buyer_userid.isin(cc.userid)\nsum(buyer_cc_linkable)\n\nbuyer_bank_linkable = orders.buyer_userid.isin(bank.userid)\nsum(buyer_bank_linkable)\n\nbuyer_device_linkable = orders.buyer_userid.isin(devices.userid)\nsum(buyer_device_linkable)","ef056a71":"seller_cc_linkable = orders.seller_userid.isin(cc.userid)\nsum(seller_cc_linkable)\n\nseller_bank_linkable = orders.seller_userid.isin(bank.userid)\nsum(seller_bank_linkable)\n\nseller_device_linkable = orders.seller_userid.isin(devices.userid)\nsum(seller_device_linkable)","c5c0db7e":"sum(~orders.buyer_userid.isin(cc.userid) &\n    ~orders.buyer_userid.isin(bank.userid) &\n    ~orders.buyer_userid.isin(devices.userid)\n    )\nsum(~orders.seller_userid.isin(cc.userid) &\n    ~orders.seller_userid.isin(bank.userid) &\n    ~orders.seller_userid.isin(devices.userid)\n    )\n\n# these number of people confirmed no fraud no matter link length since there is no way to start linking them  ","912c4dd5":"# 48 unique buyers and 48 unique sellers among 56 direct bank fraud\n\nlen(bank_fraud.groupby('buyer_userid'))\nbank_fraud.groupby('buyer_userid').size().sort_values(ascending=False)\nlen(bank_fraud.groupby('seller_userid'))\nbank_fraud.groupby('seller_userid').size().sort_values(ascending=False)","2e2c6be5":"bank_fraud.query('buyer_userid == 100918044')","a0305721":"# 48 unique buyers and 48 unique sellers among 56 direct device fraud\n\nlen(device_fraud.groupby('buyer_userid'))\ndevice_fraud.groupby('buyer_userid').size().sort_values(ascending=False)\nlen(device_fraud.groupby('seller_userid'))\ndevice_fraud.groupby('seller_userid').size().sort_values(ascending=False)","5a2a984d":"cc.groupby('userid').size().sort_values(ascending=False)\nbank.groupby('userid').size().sort_values(ascending=False)\ndevices.groupby('userid').size().sort_values(ascending=False)","d67b875a":"user_cc = cc.groupby('userid')['credit_card'].apply(list)\nuser_cc","97ca9302":"user_bank = bank.groupby('userid')['bank_account'].apply(list)\nuser_bank","d7468d63":"user_device = devices.groupby('userid')['device'].apply(list)\nuser_device","59b9283c":"cc_user = cc.groupby('credit_card')['userid'].apply(list)\ncc_user","e74bdd13":"cc_user.apply(len).value_counts().sort_index()","c7d11fc9":"bank_user = bank.groupby('bank_account')['userid'].apply(list)\nbank_user","69343524":"bank_user.apply(len).value_counts().sort_index()","563d3cf3":"device_user = devices.groupby('device')['userid'].apply(list)\ndevice_user","2b11294f":"device_user.apply(len).value_counts().sort_index()","0722ea0e":"import networkx as nx","58c6b9d5":"# basic undirected unweighted graph\n# adding edges automatically adds nodes\n# edges once added will be automatically deduplicated if the same\/reverse edge tuple is added\ng = nx.Graph()","7d1ed6ea":"for user,cc in user_cc.items():\n    g.add_edges_from(product([user],['credit_card:'+item for item in cc]))","7142efa7":"for user,bank in user_bank.items():\n    g.add_edges_from(product([user],['bank_account:'+item for item in bank]))","8ca06fe7":"for user,device in user_device.items():\n    g.add_edges_from(product([user],['device:'+item for item in device]))","e11fc367":"len(g.nodes)","244d9ab7":"order_paths = {}\nfor orderid,source,target in zip(orders.orderid,orders.buyer_userid,orders.seller_userid):\n    try:\n        path_list = list(nx.all_shortest_paths(g, source,target))\n    # NetworkXNoPath    \n    except:\n        path_list = []\n        \n    order_paths[orderid] = path_list","23dcec10":"path_df = pd.DataFrame({'orderid':list(order_paths.keys()),'paths':list(order_paths.values())})\npath_df\npath_df[path_df.paths.str.len()!=0] # path_df.paths.apply(len)!=0 or .astype(bool) works too","73116ee4":"path_df_fraud = path_df[path_df.paths.astype(bool)] \npath_df_fraud","1df98a7e":"cc_mask = path_df_fraud.paths.apply(lambda outer_list:any(['credit_card' in str(item) for inner_list in outer_list for item in inner_list]))\npath_df_fraud[cc_mask]","29297538":"bank_mask = path_df_fraud.paths.apply(lambda outer_list:any(['bank_account' in str(item) for inner_list in outer_list for item in inner_list]))\npath_df_fraud[bank_mask]","d5578488":"length_of_paths = path_df_fraud.paths.apply(lambda x:len(x[0]))\nlength_of_paths.value_counts().sort_index()","ef0c3e49":"number_of_paths = path_df_fraud.paths.apply(lambda x:len(x))\nnumber_of_paths.value_counts().sort_index()","1cd8209d":"def format_paths(paths):\n    formatted_paths = []\n    for path in paths:\n        new_path = deepcopy(path)\n        new_path[1::2] = ['-\"'+item+'\"->' for item in new_path[1::2]]\n        formatted_paths.append(''.join(list(str(item) for item in new_path)))\n    return formatted_paths\n\nformatted_paths = path_df_fraud.paths.apply(format_paths)\nformatted_paths","10fa8a89":"# for copying the df scheme and orderid column only, not the paths column (which will be overwritten)\nfirst_path_df = path_df_fraud.copy()","7fbba641":"first_path_df.paths = formatted_paths.str[0]\nfirst_path_df","c6d03a30":"mask_bank_first = first_path_df['orderid'].isin(b_chain_dic.keys())","49746acc":"bank_nx = first_path_df[mask_bank_first ]","e4e6ddf8":"b_chain_series = pd.Series(index=list(b_chain_dic.keys()),data=list(b_chain_dic.values()))\nb_chain_series","d74878f2":"bank_nx_dic = dict(zip(bank_nx.orderid,bank_nx.paths))","dead969a":"bank_nx_series = pd.Series(index=list(bank_nx_dic.keys()),data=list(bank_nx_dic.values()))","8c492c22":"bank_fraud_methods = pd.concat([b_chain_series,bank_nx_series],axis=1)\n#bank_fraud_methods\nbank_fraud_methods[bank_fraud_methods[0] != bank_fraud_methods[1]]","25268fe9":"min_path_df = path_df_fraud.copy()","e750411d":"min_path_df.paths = formatted_paths.apply(min)","c7ee4f7c":"mask_bank_min = min_path_df['orderid'].isin(b_chain_dic.keys())","90d24a48":"bank_min_nx = min_path_df[mask_bank_min]","94766eaa":"bank_min_nx_dic = dict(zip(bank_min_nx.orderid,bank_min_nx.paths))","b9ea513a":"bank_min_nx_series = pd.Series(index=list(bank_min_nx_dic.keys()),data=list(bank_min_nx_dic.values()))","8c1209e2":"bank_fraud_methods = pd.concat([b_chain_series,bank_min_nx_series],axis=1)\nbank_fraud_methods[bank_fraud_methods[0] != bank_fraud_methods[1]]   # everything is equal","f9ac4c15":"min_path_dic = dict(zip(min_path_df.orderid,min_path_df.paths))","7f5d1cf0":"path_df_fraud[bank_mask & (length_of_paths==5) & (number_of_paths==4)] ","546cb130":"def sort_func(string):\n    cc_links = string.count('credit_card')\n    bank_links = string.count('bank_account')\n    # device not needed because there's only 2 degrees of freedom, if #cc,#bank tie, #device must tie\n    # device value will not affect sort result\n    return (cc_links,bank_links)\n\n\ntest_formatted_paths = format_paths(path_df_fraud.query(f'orderid==1953272960').iloc[0,1])\nprint('original')\npprint(test_formatted_paths)\ns = sorted(test_formatted_paths)\nprint('secondary sorted')\npprint(s)\ns_func = sorted(s,key=sort_func,reverse=True)\nprint('primary sorted')\npprint(s_func)","9acd4e18":"path_df_fraud[bank_mask & (length_of_paths==7) & (number_of_paths==4)] ","32c0fad5":"# https:\/\/www.rexegg.com\/regex-quantifiers.html#helpful\ndef sort_regex(string):\n    cc_pattern = 'credit_card:(.*?)\"'\n    bank_pattern = 'bank_account:(.*?)\"'\n    device_pattern = 'device:(.*?)\"'\n    \n    cc_match = ''.join(re.findall(cc_pattern, string))\n    bank_match = ''.join(re.findall(bank_pattern, string))\n    device_match = ''.join(re.findall(device_pattern, string))\n    \n    return (cc_match,bank_match,device_match)\n\ntest_path = format_paths(path_df_fraud.query('orderid == 1953361436').iloc[0,1])\ntest_path\n\nsort_regex(test_path[0])","347e9c6e":"formatted_paths_sorted = formatted_paths.apply(sorted)\nformatted_paths_sorted = formatted_paths_sorted.apply(sorted,key=sort_func,reverse=True)","53968b79":"# ensure sorting made a difference\nsum(formatted_paths_sorted != formatted_paths)","f0c598d3":"sorted_first_path_df = path_df_fraud.copy()\nsorted_first_path_df.paths = formatted_paths_sorted.str[0]\nsorted_first_path_df\n\nsorted_first_path_dic = dict(zip(sorted_first_path_df.orderid,sorted_first_path_df.paths))\nlen(sorted_first_path_dic)","58e79cac":"min_path_dic == sorted_first_path_dic","204c48ed":"formatted_paths_sorted_alpha = formatted_paths.apply(sorted,key=sort_regex)\nformatted_paths_sorted_alpha = formatted_paths_sorted_alpha.apply(sorted,key=sort_func,reverse=True)","0d40f369":"sum(formatted_paths_sorted!=formatted_paths_sorted_alpha)","77d59640":"alpha_sorted_first_path_df = path_df_fraud.copy()\nalpha_sorted_first_path_df.paths = formatted_paths_sorted_alpha.str[0]\nalpha_sorted_first_path_df\n\nalpha_sorted_first_path_dic = dict(zip(alpha_sorted_first_path_df.orderid,alpha_sorted_first_path_df.paths))\nlen(alpha_sorted_first_path_dic)","32f8347f":"sorted_first_path_dic == alpha_sorted_first_path_dic","91cd1bfe":"is_fraud = ['not fraud']*len(orders)\nresult = dict(zip(orders.orderid,is_fraud))","d4658ddc":"result.update(sorted_first_path_dic)","d64ff093":"result_df = pd.DataFrame({'orderid':list(result.keys()),'is_fraud':list(result.values())})","a2dcc076":"result_df.to_csv('all_fraud_2step_sorted.csv',index=False)","bc5bf501":"result_df.head()","0540feb5":"sum(result_df.is_fraud != 'not fraud')","6e7676bc":"result_df[result_df.is_fraud != 'not fraud']","970d9195":"# https:\/\/www.rexegg.com\/regex-quantifiers.html#helpful\ndef sort_regex(string):\n    cc_pattern = 'credit_card:(.*?)\"'\n    bank_pattern = 'bank_account:(.*?)\"'\n    device_pattern = 'device:(.*?)\"'\n    \n    cc_match = ''.join(re.findall(cc_pattern, string))\n    bank_match = ''.join(re.findall(bank_pattern, string))\n    device_match = ''.join(re.findall(device_pattern, string))\n    print(cc_match,bank_match,device_match)\n    \n    return (cc_match,bank_match,device_match)","af0f030d":"paths = [\n    '1-\"device:100\"->4-\"bank_account:100\"->3',\n    '1-\"bank_account:200\"->6-\"device:100\"->3',\n    '1-\"bank_account:10\"->2-\"bank_account:10\"->3',  \n]\nprint('original')\npprint(paths)\ns = sorted(paths)\nprint('secondary sorted (no regex)')\npprint(s)\n\ns_func = sorted(s,key=sort_func,reverse=True)\nprint('primary sorted (no regex)')\npprint(s_func)\n\ns = sorted(paths,key=sort_regex)\nprint('secondary sorted (with regex)')\npprint(s)\n\ns_func = sorted(s,key=sort_func,reverse=True)\nprint('primary sorted (with regex)')\npprint(s_func)","dab43900":"# Formatting the path  (deepcopy() if space allows)\n- Much more convenient than seeing all lists from upstream `order_paths` to  `path_df` to `path_df_fraud` being edited by downstream list formatting operations if no deepcopy","f3a4a502":"# Testing primary sort_func\nhttps:\/\/docs.python.org\/3\/howto\/sorting.html#sort-stability-and-complex-sorts","3d55bf74":"# Exploring different ways to extract the correct chain from list of chains \n1. First path --> 1 row wrong already on direct bank match, not submitted \n2. Min path --> Private (**0.85849**) , Public (**0.88888**)\n3. 2 Step sort (basic sort, sort_func) --> Private (**0.86320**), Public (**0.88888**)\n3. 2 Step sort (regex sort, sort_func) --> Private (**0.86084**), Public (**0.88888**) Matches instructions most closely. ","d7b9f416":"## Trying another way of secondary sorting ","98e32f44":"## Find examples to test sorting function on real data ","86f4e1e5":"## Select relevant prepared dic to overwrite no_fraud ","84675fda":"## Taking minimum path in every orderid ","5ca81aee":"# Proceed to apply sorting function after testing sort function ","e23ff449":"## Looking for bank account in fraud chain for example to test sorting function","2ff945eb":"### Checking if bank direct chains created from nx match that from pandas merging","f002e936":"# Creating per user statistics  ","e7a421d9":"## 2-step sorting\n1. normal sort as secondary sort\n2. sort_func as primary sort (count how many credit card, bank account, device)","8c53fb7d":"### One row is different --> Simply taking first path does not work  ","be5cb396":"## Updating with device fraud ","ab831e7e":"# Looking for indirect links","da926785":"- Many orderid could have been direct frauded with multiple choices (up to 5) of device","f386b516":"## Checking full row duplicates  (affects merging and groupby.apply(list) later)","c3eeae71":"### Checking for difference in sort results after extracting 1st (.str[0]) value ","abe09124":"## Looking for credit cards in fraud chain for example to test sorting function","62ebe5cb":"### Checking for difference in sort results after extracting 1st (.str[0]) value ","e6a0d790":"## Merge bank ","563aa387":"## Number of people sharing a bank ","2b68861e":"## Updating with bank fraud ","01c62ce7":"- Almost every buyer\/seller in orders table has a linking cc\/bank\/device, not much opportunity to filter them down before doing any processing","8ce388f6":"# Creating filters to extract specific fraud chains for testing sort","c3bc8f34":"## identifying buyer_userid and seller_userid that cannot be linked in any way given the available information","5594a8b9":"# Prepare Output File","5b88f3f4":"## Checking buyers and sellers who direct fraud on multiple orderid  (not required for task) ","38ae1b2c":"# NetworkX ","88cfcf5c":"### Preparing direct bank fraud dictionary to overwrite some rows in result dict (including direct device frauds) ","b7faace6":"### Repeated device fraud rows for same orderid ","444d6d50":"### Repeated bank fraud rows for same orderid  ","f7e5ae3d":"## userid: device ","a506e3d5":"### Preparing direct device fraud dictionary to overwrite some rows in result dict  ","fc46acbf":"## Check if all users in orders are in the other 3 df and vice versa ","7413baa3":"## Number of people sharing a credit card","6b45fc10":"## Simply taking first path in every orderid ","98a4ab35":"# Creating own fraud chains to test secondary sorting functions","c7a6fe22":"## 2-step sorting (regex on secondary sort)\n1. sort_regex as secondary sort\n2. sort_func as primary sort (count how many credit card, bank account, device)","7163a810":"# Read files ","f4cfdb39":"#  Creating per fraud method statistics (Can skip until NetworkX header to save 4 minutes)\n- Not required for graph building or answering task as both this and the reversed per user_xxx dictionary created above represent the same edge in graph\n- The previous way of creating edges is up to 3x faster, groupby speed depends on number of groups created and effect is significant with expensive apply(list) operation, there are less groups grouping by userid than the reverse","86b5054e":"# Jump to creating result df \n- Private (**0.68160**) Public (**0.64814**) after adding sorted device and bank direct frauds\n\n[Create Result DataFrame](#create_df)","eebcd46b":"# Questions\n1. What does the instruction mean exactly? (This is implemented by the secondary sorts in the notebook)\n\n_If there are more than one results from the previous step, sort the links alphabetically in ascending order based on the priority list (i.e. sort Credit Cards first, then followed by Bank Account links and finally Device links) and output the first one._\n\n2. What else is there to do to make the solution score 1? \n3. Is there something wrong with the sorting approach in the notebook? ","faec6cb2":"##  Removing duplicates from bank","3f32a544":"## userid : cc ","feddf1ab":"## Find number of paths in each orderid ","5a555c23":"### Bank ","340a555b":"## Merge Credit Card ","a63e5ef9":"### Device ","204fd5a9":"# Creating empty result dic ","db308ba1":"### Example of 1 buyer\/seller direct fraud on 4 orders","bdc9f094":"## Number of credit cards, bank accounts, devices per person ","97c5ff3e":"## userid \uff1a bank ","5206c71b":"# Create result_df after all updates\n<a id='create_df'><\/a>","089c4041":"## Merge device ","a204f7ca":"# Inner merging twice to search for direct frauds","7fa1ee2f":"## Number of people sharing a device ","280661cf":"# Results summary\n\n**DataFrame merging** (Only Direct Bank + Device Frauds)  \n1. Private (**0.68160**) Public (**0.64814**)\n\n**NetworkX**\n1. First path --> 1 row wrong already on direct bank match, not submitted \n2. Min path --> Private (**0.85849**) , Public (**0.88888**)\n3. 2 Step sort (basic sort, sort_func) --> Private (**0.86320**), Public (**0.88888**)\n3. 2 Step sort (regex sort, sort_func) --> Private (**0.86084**), Public (**0.88888**) Matches instructions most closely.","e8415aee":"## Find lengths of all fraud chains (number of links = (len - 1)\/2 )","c734e036":"# Create dataframe of all fraud paths"}}