{"cell_type":{"ef76a1cb":"code","beac2fae":"code","79d7b7c4":"code","d33a7010":"code","655374ca":"code","727316f7":"code","9ef868b7":"code","bb01732e":"code","2e3690b8":"code","4e34bae0":"code","add96a57":"code","58ed88de":"code","eb8d53c7":"code","25546227":"code","61745d81":"code","acf29d2f":"code","eadcb100":"markdown","87ba82c7":"markdown","fe7dc860":"markdown","9a0b25db":"markdown","4e0df2fc":"markdown","2ba7bcae":"markdown","5f5c4ecb":"markdown","12300f86":"markdown","9d896f40":"markdown","6f396bef":"markdown","e389bb5b":"markdown","6a81ab12":"markdown","0fabf653":"markdown","00e9b3d2":"markdown","0b89c92e":"markdown","d3e72e2d":"markdown","56898310":"markdown","bdfa9a6a":"markdown","2ba14cd0":"markdown","37814f34":"markdown","cebfdd55":"markdown"},"source":{"ef76a1cb":"import os\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport plotly.offline as offline\nimport plotly.graph_objs as go\nfrom imblearn.over_sampling import SMOTE\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import confusion_matrix,roc_curve,auc\nfrom sklearn.model_selection import train_test_split\n\n\noffline.init_notebook_mode(connected=True) ","beac2fae":"credit_card = pd.read_csv(\"..\/input\/creditcard.csv\")\ncredit_card.head()","79d7b7c4":"credit_card.shape #analyze the number of records","d33a7010":"credit_card.isnull().values.any()","655374ca":"credit_card.describe()","727316f7":"class_imb=credit_card['Class'].value_counts()\n\ndata=[go.Bar(x=class_imb.keys().tolist(),y=class_imb.tolist(),marker=dict(color=\"Red\"))]\n\nlayout = go.Layout(title = 'Credit Card Fraud Class - data unbalance (Not fraud = 0, Fraud = 1',\n                   xaxis=dict(title='Class', showticklabels=True),\n                   yaxis=dict(title='Number of transactions'))\nfig=go.Figure(data=data,layout=layout)\noffline.iplot(fig)","9ef868b7":"normal_trans=credit_card[credit_card['Class']==0]\nfraud_trans=credit_card[credit_card['Class']==1]\n\n\n\ntrace0 = go.Box(\n    y=normal_trans.Amount,name = \"Normal\"\n)\ntrace1 = go.Box(\n    y=fraud_trans.Amount,name = \"Fraud\"\n)\ndata = [trace0, trace1]\noffline.iplot(data)","bb01732e":"fraud = credit_card.loc[credit_card['Class'] == 1]\n\ndata = [go.Scatter(\n    x = fraud['Time'],y = fraud['Amount'],\n    name=\"Amount\",\n     marker=dict(\n                color='rgb(238,23,11)',\n                line=dict(\n                    color='red',\n                    width=1),\n                opacity=0.5,\n            ),\n    text= fraud['Amount'],\n    mode = \"markers\"\n)]\n\nlayout = dict(title = 'Amount of fraudulent transactions',\n          xaxis = dict(title = 'Time [s]', showticklabels=True), \n          yaxis = dict(title = 'Amount')\n         )\nfig = dict(data=data, layout=layout)\noffline.iplot(fig)","2e3690b8":"credit_card.hist(figsize=(20,20))\nplt.show()","4e34bae0":"columns=credit_card.columns\nfeature_columns=columns.delete(len(columns)-1)\n\nX=credit_card[feature_columns] #data\ny=credit_card['Class']         #label","add96a57":"X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.3,random_state=2019)","58ed88de":"balance_sampling=SMOTE(random_state=2019)\nX_balance,y_balance=balance_sampling.fit_sample(X_train,y_train)\n","eb8d53c7":"len(y_balance[y_balance==1]) #check for the increase in Fraud labels","25546227":"clf=RandomForestClassifier(n_jobs=4, #number of parallel jobs\n                             random_state=2019,\n                             criterion='gini',\n                             n_estimators=100,#number of estimators\n                             verbose=False)\nclf.fit(X_balance,y_balance)\nprediction=clf.predict(X_test)","61745d81":"confusion_matrix=(y_test,prediction)","acf29d2f":"false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, prediction)\nroc_auc = auc(false_positive_rate, true_positive_rate)\nprint (roc_auc)","eadcb100":"Do fraudulent transactions occur more often during certain time frame ? Let us find out with a visual representation.","87ba82c7":"Fraud transactions have a higher Upper-fence value than Normal transaction","fe7dc860":"In the case of imbalanced data, majority classes dominate over minority classes, causing the machine learning classifiers to be more biased towards majority classes. This causes poor classification of minority classes. Classifiers may even predict all the test data as majority classes.\n\nHence it is important to resolve class imbalance.","9a0b25db":"**Computing ROC-AUC score**","4e0df2fc":"**SMOTE for removing Class Imbalance**","2ba7bcae":"Lets check the Transaction Amount class-wise(Normal & Fraudlent).","5f5c4ecb":"**Classification** : RandomForestClassifier","12300f86":"> *Thank You. *","9d896f40":"SMOTE synthesises new minority instances between existing (real) minority instances. \n\nImagine that SMOTE draws lines between existing minority instances.\n\nSMOTE then imagines new, synthetic minority instances somewhere on these lines.\n\n![](https:\/\/s3-ap-south-1.amazonaws.com\/av-blog-media\/wp-content\/uploads\/2017\/03\/16142852\/ICP3.png)\n\nAfter synthesising new minority instances, the imbalance shrinks. \n","6f396bef":"We can see there is a huge imbalance in the data i.e the no.of records in Class 0(Not Fraud ) is very high(284315) whereas the no.of records in Class 1(Fraud) is too low(492).\nThis is a imbalanced class distribution scenario where the number of observations belonging to one class is significantly lower than those belonging to the other classes.\n","e389bb5b":"> A **confusion matrix** is a table that is often used to describe the performance of a classification model (or \"classifier\") on a set of test data for which the true values are known. \n\nThe number of correct and incorrect predictions are summarized with count values and broken down by each class. This is the key to the confusion matrix.\n\n![](https:\/\/cdncontribute.geeksforgeeks.org\/wp-content\/uploads\/Confusion_Matrix1_1.png)","6a81ab12":"Plot histogram of each feature .","0fabf653":"We will check for class imbalance in the data.Lets plot the no.of records in each Class(i.e Fraud=1,Not Farud=0)","00e9b3d2":"**Credit Card Fraud Detection**\n\n*Anonymized credit card transactions labeled as fraudulent or genuine*\n\n> It is important that credit card companies are able to recognize fraudulent credit card transactions so that customers are not charged for items that they did not purchase.\n\n\nThe datasets contains transactions made by credit cards in September 2013 by european cardholders. This dataset presents transactions that occurred in two days, where we have 492 frauds out of 284,807 transactions. The dataset is highly unbalanced, the positive class (frauds) account for 0.172% of all transactions.\n\nIt contains only numerical input variables which are the result of a PCA transformation. Unfortunately, due to confidentiality issues, we cannot provide the original features and more background information about the data. Features V1, V2, ... V28 are the principal components obtained with PCA, the only features which have not been transformed with PCA are 'Time' and 'Amount'. Feature 'Time' contains the seconds elapsed between each transaction and the first transaction in the dataset. The feature 'Amount' is the transaction Amount, this feature can be used for example-dependant cost-senstive learning. Feature 'Class' is the response variable and it takes value 1 in case of fraud and 0 otherwise. ","0b89c92e":"Check if any null values exist in the dataset.","d3e72e2d":"Splitting the dataset into training and testing(30%)","56898310":"There are no values missing in our dataset .\nLet get an overview of the data coloumn-wise.","bdfa9a6a":"\n\nDoesn't seem like the time of transaction really matters here as per above observation.","2ba14cd0":"**Data Loading**","37814f34":"To balance the data, you have several options. \n\nThe first is to simply gather more data. While this is always preferable, it is often not possible.\n\nIn this case, you can try resampling the data, either by under-sampling your majority class (non-fraud transactions in the above example) or over-sampling your minority class (the fraudulent transactions). \n\nOver-sampling consists of either sampling each member of the minority class with replacement, or creating synthetic members by randomly sampling from the feature set. This is what SMOTE\u200a\u2014\u200aSynthetic Minority Over-sampling Technique\u200a\u2014\u200adoes.","cebfdd55":"**EDA**"}}