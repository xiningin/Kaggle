{"cell_type":{"09faa3f4":"code","553f6b97":"code","24c29c74":"code","d8d10f61":"code","f8d93397":"code","1a174e75":"code","1f346b93":"code","b6edae34":"code","4d92c32d":"code","51c6569e":"code","72c2b160":"code","9a629893":"code","8553cb41":"code","f3e5b19d":"code","bb087ed9":"code","17202599":"code","db458f72":"code","f3a2db0a":"code","4594e090":"code","e06a33ce":"code","c5a6c53e":"code","e3614948":"code","9d978c8f":"code","d65c9f67":"code","e8c2a9a7":"code","7d7c638d":"code","bbb367af":"code","2ca2e8dc":"code","a083947e":"code","10fe0b3e":"code","2ef5fca8":"code","15c9abb5":"code","e97af71f":"code","c04c019d":"code","fa49ae15":"code","f741a6a7":"code","0a8eb841":"code","17c086d2":"code","3ce0d488":"code","956b225a":"code","3d2f34af":"code","2fc72973":"code","f1f9df90":"code","201a4a63":"code","9a4f9bb1":"code","3f89a41f":"code","56f1fb8c":"code","3201f3a9":"code","6f3dbbf5":"code","863fb5ab":"code","c31860d1":"code","e21a645a":"code","6b667c92":"code","5842e1f7":"code","e56bbd34":"code","1b9b390e":"code","db7035bf":"code","d5dba215":"code","06a63675":"code","f2281825":"markdown","ea0b0f5a":"markdown","eaf5e35c":"markdown","3f64b003":"markdown","4c6e2f14":"markdown","beebb53c":"markdown","939b9c4a":"markdown","27bb4c3e":"markdown","cea18fa5":"markdown","94d942a5":"markdown","1457eb5b":"markdown","9d4a2753":"markdown","96471c11":"markdown","54c1a61e":"markdown","4282ae3e":"markdown","be68af5a":"markdown","59658dc8":"markdown","99667fb3":"markdown","b074448e":"markdown","877de49c":"markdown","b19986e6":"markdown","9a5b16eb":"markdown","938082cc":"markdown","6c918021":"markdown","ba9353a4":"markdown","b60c4f24":"markdown"},"source":{"09faa3f4":"#!pip install pycountry","553f6b97":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nimport plotly.graph_objects as go\nfrom fbprophet import Prophet\nimport pycountry\nimport plotly.express as px\nfrom collections import namedtuple","24c29c74":"df = pd.read_csv('..\/input\/novel-corona-virus-2019-dataset\/covid_19_data.csv',parse_dates=['Last Update'])\ndf.rename(columns={'ObservationDate':'Date', 'Country\/Region':'Country'}, inplace=True)\n\ndf_confirmed = pd.read_csv(\"..\/input\/novel-corona-virus-2019-dataset\/time_series_covid_19_confirmed.csv\")\ndf_recovered = pd.read_csv(\"..\/input\/novel-corona-virus-2019-dataset\/time_series_covid_19_recovered.csv\")\ndf_deaths = pd.read_csv(\"..\/input\/novel-corona-virus-2019-dataset\/time_series_covid_19_deaths.csv\")\n\ndf_confirmed.rename(columns={'Country\/Region':'Country'}, inplace=True)\ndf_recovered.rename(columns={'Country\/Region':'Country'}, inplace=True)\ndf_deaths.rename(columns={'Country\/Region':'Country'}, inplace=True)","d8d10f61":"df_confirmed.head()","f8d93397":"df.head()","1a174e75":"df.tail()","1f346b93":"df2 = df.groupby([\"Date\", \"Country\", \"Province\/State\"])[['SNo', 'Date', 'Province\/State', 'Country', 'Confirmed', 'Deaths', 'Recovered']].sum().reset_index()","b6edae34":"df2","4d92c32d":"df.query('Country==\"India\"').groupby(\"Last Update\")[['Confirmed', 'Deaths', 'Recovered']].sum().reset_index()","51c6569e":"df.groupby(\"Country\")[['Confirmed', 'Deaths', 'Recovered']].sum().reset_index()","72c2b160":"df.groupby('Date').sum()","9a629893":"confirmed = df.groupby('Date').sum()['Confirmed'].reset_index()\ndeaths = df.groupby('Date').sum()['Deaths'].reset_index()\nrecovered = df.groupby('Date').sum()['Recovered'].reset_index()","8553cb41":"fig = go.Figure()\nfig.add_trace(go.Bar(x=confirmed['Date'],\n                y=confirmed['Confirmed'],\n                name='Confirmed',\n                marker_color='blue'\n                ))\nfig.add_trace(go.Bar(x=deaths['Date'],\n                y=deaths['Deaths'],\n                name='Deaths',\n                marker_color='Red'\n                ))\nfig.add_trace(go.Bar(x=recovered['Date'],\n                y=recovered['Recovered'],\n                name='Recovered',\n                marker_color='Green'\n                ))\n\nfig.update_layout(\n    title='Worldwide Corona Virus Cases - Confirmed, Deaths, Recovered (Bar Chart)',\n    xaxis_tickfont_size=14,\n    yaxis=dict(\n        title='Number of Cases',\n        titlefont_size=16,\n        tickfont_size=14,\n    ),\n    legend=dict(\n        x=0,\n        y=1.0,\n        bgcolor='rgba(255, 255, 255, 0)',\n        bordercolor='rgba(255, 255, 255, 0)'\n    ),\n    barmode='group',\n    bargap=0.15, # gap between bars of adjacent location coordinates.\n    bargroupgap=0.1 # gap between bars of the same location coordinate.\n)\nfig.show()","f3e5b19d":"fig = go.Figure()\nfig.add_trace(go.Scatter(x=confirmed['Date'], \n                         y=confirmed['Confirmed'],\n                         mode='lines+markers',\n                         name='Confirmed',\n                         line=dict(color='blue', width=2)\n                        ))\nfig.add_trace(go.Scatter(x=deaths['Date'], \n                         y=deaths['Deaths'],\n                         mode='lines+markers',\n                         name='Deaths',\n                         line=dict(color='Red', width=2)\n                        ))\nfig.add_trace(go.Scatter(x=recovered['Date'], \n                         y=recovered['Recovered'],\n                         mode='lines+markers',\n                         name='Recovered',\n                         line=dict(color='Green', width=2)\n                        ))\nfig.update_layout(\n    title='Worldwide Corona Virus Cases - Confirmed, Deaths, Recovered (Line Chart)',\n    xaxis_tickfont_size=14,\n    yaxis=dict(\n        title='Number of Cases',\n        titlefont_size=16,\n        tickfont_size=14,\n    ),\n    legend=dict(\n        x=0,\n        y=1.0,\n        bgcolor='rgba(255, 255, 255, 0)',\n        bordercolor='rgba(255, 255, 255, 0)'\n    )\n)\nfig.show()","bb087ed9":"df_confirmed = df_confirmed[[\"Province\/State\",\"Lat\",\"Long\",\"Country\"]]\ndf_temp = df.copy()\ndf_temp['Country'].replace({'Mainland China': 'China'}, inplace=True)\ndf_latlong = pd.merge(df_temp, df_confirmed, on=[\"Country\", \"Province\/State\"])","17202599":"fig = px.density_mapbox(df_latlong, \n                        lat=\"Lat\", \n                        lon=\"Long\", \n                        hover_name=\"Province\/State\", \n                        hover_data=[\"Confirmed\",\"Deaths\",\"Recovered\"], \n                        animation_frame=\"Date\",\n                        color_continuous_scale=\"Portland\",\n                        radius=7, \n                        zoom=0,height=700)\nfig.update_layout(title='Worldwide Corona Virus Cases Time Lapse - Confirmed, Deaths, Recovered',\n                  font=dict(family=\"Courier New, monospace\",\n                            size=18,\n                            color=\"#7f7f7f\")\n                 )\nfig.update_layout(mapbox_style=\"open-street-map\", mapbox_center_lon=0)\nfig.update_layout(margin={\"r\":0,\"t\":0,\"l\":0,\"b\":0})\n\n\nfig.show()","db458f72":"confirmed = df2.groupby(['Date', 'Country']).sum()[['Confirmed']].reset_index()\ndeaths = df2.groupby(['Date', 'Country']).sum()[['Deaths']].reset_index()\nrecovered = df2.groupby(['Date', 'Country']).sum()[['Recovered']].reset_index()","f3a2db0a":"latest_date = confirmed['Date'].max()\nlatest_date","4594e090":"confirmed = confirmed[(confirmed['Date']==latest_date)][['Country', 'Confirmed']]\ndeaths = deaths[(deaths['Date']==latest_date)][['Country', 'Deaths']]\nrecovered = recovered[(recovered['Date']==latest_date)][['Country', 'Recovered']]","e06a33ce":"all_countries = confirmed['Country'].unique()\nprint(\"Number of countries\/regions with cases: \" + str(len(all_countries)))\nprint(\"Countries\/Regions with cases: \")\nfor i in all_countries:\n    print(\"    \" + str(i))","c5a6c53e":"print(list(country.name for country in pycountry.countries))","e3614948":"print('UK' in list(country.name for country in pycountry.countries))\nprint('United Kingdom' in list(country.name for country in pycountry.countries))","9d978c8f":"confirmed2 = confirmed.copy()\ndeaths2 = deaths.copy()\nrecovered2 = recovered.copy()\nbubble_plot_dfs = [confirmed2, deaths2, recovered2]\nfor df_ in bubble_plot_dfs:\n    df_[\"Country\"].replace({'Mainland China': 'China'}, inplace=True)\n    df_[\"Country\"].replace({'UK': 'United Kingdom'}, inplace=True)\n    df_[\"Country\"].replace({'US': 'United States'}, inplace=True)","d65c9f67":"countries = {}\nfor country in pycountry.countries:\n    countries[country.name] = country.alpha_3\n    \nconfirmed2[\"iso_alpha\"] = confirmed2[\"Country\"].map(countries.get)\ndeaths2[\"iso_alpha\"] = deaths2[\"Country\"].map(countries.get)\nrecovered2[\"iso_alpha\"] = recovered2[\"Country\"].map(countries.get)","e8c2a9a7":"plot_data_confirmed = confirmed2[[\"iso_alpha\",\"Confirmed\", \"Country\"]]\nplot_data_deaths = deaths2[[\"iso_alpha\",\"Deaths\"]]\nplot_data_recovered = recovered2[[\"iso_alpha\",\"Recovered\"]]","7d7c638d":"fig = px.scatter_geo(plot_data_confirmed, locations=\"iso_alpha\", color=\"Country\",\n                     hover_name=\"iso_alpha\", size=\"Confirmed\",\n                     projection=\"natural earth\", title = 'Worldwide Confirmed Cases')\nfig.show()","bbb367af":"fig = px.scatter_geo(plot_data_deaths, locations=\"iso_alpha\", color=\"Deaths\",\n                     hover_name=\"iso_alpha\", size=\"Deaths\",\n                     projection=\"natural earth\", title=\"Worldwide Death Cases\")\nfig.show()","2ca2e8dc":"fig = px.scatter_geo(plot_data_recovered, locations=\"iso_alpha\", color=\"Recovered\",\n                     hover_name=\"iso_alpha\", size=\"Recovered\",\n                     projection=\"natural earth\", title=\"Worldwide Recovered Cases\")\nfig.show()","a083947e":"confirmed = df.groupby('Date').sum()['Confirmed'].reset_index()\ndeaths = df.groupby('Date').sum()['Deaths'].reset_index()\nrecovered = df.groupby('Date').sum()['Recovered'].reset_index()","10fe0b3e":"confirmed.columns = ['ds','y']\n#confirmed['ds'] = confirmed['ds'].dt.date\nconfirmed['ds'] = pd.to_datetime(confirmed['ds'])","2ef5fca8":"confirmed.head()","15c9abb5":"m = Prophet(interval_width=0.95)\nm.fit(confirmed)\nfuture = m.make_future_dataframe(periods=7)\nfuture_confirmed = future.copy() # for non-baseline predictions later on\nfuture.tail()","e97af71f":"forecast = m.predict(future)\nforecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()","c04c019d":"confirmed_forecast_plot = m.plot(forecast)","fa49ae15":"forecast_components = m.plot_components(forecast)","f741a6a7":"deaths.columns = ['ds','y']\ndeaths['ds'] = pd.to_datetime(deaths['ds'])","0a8eb841":"m = Prophet(interval_width=0.95)\nm.fit(deaths)\nfuture = m.make_future_dataframe(periods=7)\nfuture_deaths = future.copy() # for non-baseline predictions later on\nfuture.tail()","17c086d2":"forecast = m.predict(future)\nforecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()","3ce0d488":"deaths_forecast_plot = m.plot(forecast)","956b225a":"forecast_components = m.plot_components(forecast)","3d2f34af":"recovered.columns = ['ds','y']\nrecovered['ds'] = pd.to_datetime(recovered['ds'])","2fc72973":"m = Prophet(interval_width=0.95)\nm.fit(recovered)\nfuture = m.make_future_dataframe(periods=7)\nfuture_recovered = future.copy() # for non-baseline predictions later on\nfuture.tail()","f1f9df90":"forecast = m.predict(future)\nforecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()","201a4a63":"recovered_forecast_plot = m.plot(forecast)","9a4f9bb1":"forecast_components = m.plot_components(forecast)","3f89a41f":"days_to_forecast = 7 # changable\nfirst_forecasted_date = sorted(list(set(df2['Date'].values)))[-days_to_forecast]\n\nprint('The first date to perform forecasts for is: ' + str(first_forecasted_date))","56f1fb8c":"confirmed_df = df2[['SNo', 'Date','Province\/State', 'Country', 'Confirmed']]\nconfirmed_df","3201f3a9":"deaths_df = df2[['SNo', 'Date','Province\/State', 'Country', 'Deaths']]\ndeaths_df","6f3dbbf5":"recovered_df = df2[['SNo', 'Date','Province\/State', 'Country', 'Recovered']]\nrecovered_df","863fb5ab":"def make_forecasts(all_countries, confirmed_df, deaths_df, recovered_df, days_to_forecast, first_forecasted_date, mode):\n    forecast_dfs = []\n    absolute_errors = [] # collate absolute errors so that we can find MAE later on\n    counter = 0 # arbitrary counter to output snippet of result_val_df only once, when it is 1\n    for country in all_countries:\n        try:\n            assert(country in confirmed_df['Country'].values)\n            print('Country ' + str(country) + ' is listed! ')\n            country_confirmed_df = confirmed_df[(confirmed_df['Country'] == country)]\n            country_deaths_df = deaths_df[(deaths_df['Country'] == country)]\n            country_recovered_df = recovered_df[(recovered_df['Country'] == country)]\n            country_dfs = [('Confirmed', country_confirmed_df), \n                           ('Deaths', country_deaths_df), \n                           ('Recovered', country_recovered_df)]\n            states_in_country = country_confirmed_df['Province\/State'].unique()\n            for state in states_in_country:\n                try:\n                    state_dfs = [] # to store forecasts for Confirmed, Deaths and Recovered\n\n                    assert(state in country_confirmed_df['Province\/State'].values)\n\n                    # make forecasts for each case type (Confirmed, Deaths, Recovered)\n                    for country_df_tup in country_dfs:\n                        case_type = country_df_tup[0]\n                        country_df = country_df_tup[1]\n                        state_df = country_df[(country_df['Province\/State'] == state)]\n\n                        # data preparation for forecast with Prophet at state level\n                        state_df = state_df[['Date', case_type]]\n                        state_df.columns = ['ds','y']\n                        state_df['ds'] = pd.to_datetime(state_df['ds'])\n\n                        state_df_val = state_df[(state_df['ds'] >= pd.to_datetime(first_forecasted_date))] # validation set\n                        state_df = state_df[(state_df['ds'] < pd.to_datetime(first_forecasted_date))] # train set\n\n                        if mode == 'default':\n                            m = Prophet()\n                        elif mode == 'custom':\n                            m = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False)\n                            m.add_seasonality(name='monthly', period=30.5, fourier_order=10)\n                            m.add_seasonality(name='weekly', period=7, fourier_order=21)\n                            m.add_seasonality(name='daily', period=1, fourier_order=3)\n                        m.fit(state_df)\n                        future = m.make_future_dataframe(periods=days_to_forecast)\n                        forecast = m.predict(future)\n\n                        # evaluate forecasts with validation set and save absolute errors to absolute_errors\n                        forecast_df = forecast[['ds', 'yhat']]\n                        result_df = forecast_df[(forecast_df['ds'] >= pd.to_datetime(first_forecasted_date))]\n                        result_val_df = result_df.merge(state_df_val, on=['ds'])\n                        result_val_df['abs_diff'] = (result_val_df['y'] - result_val_df['yhat']).abs()\n                        absolute_errors += list(result_val_df['abs_diff'].values)\n\n                        # the following allows the user to check the output at particular checkpoints. Feel free to change!\n                        if counter == 1:\n                            print('Printing snippet of result_val_df: \\n')\n                            print(result_val_df)\n                            print(absolute_errors)\n                        counter += 1\n\n                        # save results to dataframe\n                        forecast_df['Province\/State'] = state\n                        forecast_df['Country\/Region'] = country\n                        forecast_df.rename(columns={'yhat':case_type}, inplace=True)\n                        state_dfs += [forecast_df.tail(days_to_forecast)]\n\n                    merged_df = state_dfs[0].merge(state_dfs[1],on=['ds', 'Province\/State', 'Country\/Region']).merge(state_dfs[2],on=['ds', 'Province\/State', 'Country\/Region'])\n                    forecast_dfs += [merged_df]\n                except:\n                    continue\n        except:\n            print('Country ' + str(country) + ' is not listed! ')\n            continue\n    results_tup = namedtuple('results_tup', ['forecast_dfs', 'absolute_errors'])\n    return results_tup(forecast_dfs, absolute_errors)","c31860d1":"forecast_results = make_forecasts(all_countries, confirmed_df, deaths_df, recovered_df, days_to_forecast, first_forecasted_date, 'default')\nabsolute_errors = forecast_results.absolute_errors","e21a645a":"forecast_results.forecast_dfs[0].tail(days_to_forecast) # example of a forecast","6b667c92":"forecasts_final = pd.concat(forecast_results.forecast_dfs, axis=0)\nforecasts_final.sort_values(by='ds')\nforecasts_final = forecasts_final[['ds', 'Province\/State', 'Country\/Region', 'Confirmed', 'Deaths', 'Recovered']]\nforecasts_final.rename(columns={'ds':'ObservationDate'}, inplace=True)\nfor case_type in ['Confirmed', 'Deaths', 'Recovered']:\n    forecasts_final[case_type] = forecasts_final[case_type].round() # round forecasts to integer as humans cannot be floats\n    forecasts_final[forecasts_final[case_type] < 0] = 0 # replace negative forecasts to zero\n\nforecasts_final","5842e1f7":"forecasts_final.to_csv(\"forecasts_default_prophet.csv\", index=False) # save forecasts to CSV","e56bbd34":"forecast_results_custom = make_forecasts(all_countries, confirmed_df, deaths_df, recovered_df, days_to_forecast, first_forecasted_date, 'custom')\nabsolute_errors_custom = forecast_results_custom.absolute_errors\nforecast_dfs_custom = forecast_results_custom.forecast_dfs","1b9b390e":"forecasts_final_custom = pd.concat(forecast_dfs_custom, axis=0)\nforecasts_final_custom.sort_values(by='ds')\nforecasts_final_custom = forecasts_final_custom[['ds', 'Province\/State', 'Country\/Region', 'Confirmed', 'Deaths', 'Recovered']]\nforecasts_final_custom.rename(columns={'ds':'ObservationDate'}, inplace=True)\nfor case_type in ['Confirmed', 'Deaths', 'Recovered']:\n    forecasts_final_custom[case_type] = forecasts_final_custom[case_type].round() # round forecasts to integer as humans cannot be floats\n    forecasts_final_custom[forecasts_final_custom[case_type] < 0] = 0 # replace negative forecasts to zero\n\nforecasts_final_custom","db7035bf":"forecasts_final_custom.to_csv(\"forecasts_custom_prophet.csv\", index=False) # save forecasts to CSV","d5dba215":"N = len(absolute_errors)\nmean_absolute_error = sum(absolute_errors)\/N\nprint('The mean absolute error for ' + str(days_to_forecast) + ' days of forecasts with the default Prophet model is: ' + str(round(mean_absolute_error, 2))) # round to 2 decimal places","06a63675":"mean_absolute_error_custom = sum(absolute_errors_custom)\/N\nprint('The mean absolute error for ' + str(days_to_forecast) + ' days of forecasts with the custom Prophet model is: ' + str(round(mean_absolute_error_custom, 2))) # round to 2 decimal places","f2281825":"## Forecasting Confirmed Cases Worldwide with Prophet (Baseline)\n\nWe perform a week's ahead forecast with Prophet, with 95% prediction intervals. Here, no tweaking of seasonality-related parameters and additional regressors are performed.","ea0b0f5a":"## Forecasting Deaths Worldwide with Prophet (Baseline)\n\nWe perform a week's ahead forecast with Prophet, with 95% prediction intervals. Here, no tweaking of seasonality-related parameters and additional regressors are performed.","eaf5e35c":"## Earliest Cases","3f64b003":"## Summary Plot of Worldwide Cases - Confirmed, Deaths & Recovered","4c6e2f14":"Seems pretty decent for a baseline Prophet model in the case of the number of recovered! :)\n\nFrom the forecast component plots, it is clear that there exists an upward trend in the number of cases worldwide. In the weekly trends plot, interestingly, it is the **highest at the weekends**!","beebb53c":"## By Country View (World)","939b9c4a":"### Forecasting Confirmed Cases, Deaths & Recovered Cases and Computing Mean Absolute Error (MAE)\n\nNext, we perform predictions for each country and state. Note that we compute MAE with the raw predictions before rounding.","27bb4c3e":"### Countries\/Regions Affected","cea18fa5":"# Visualizations","94d942a5":"## Background\n\nCOVID-19 (previously known as 2019 Novel Coronavirus, or 2019-nCoV), is a new respiratory virus first identified in Wuhan, Hubei Province, China. A novel coronavirus (nCoV) is a new coronavirus that has not been previously identified. The 2019 novel coronavirus (2019-nCoV), is not that same as the coronaviruses that commonly circulate among humans and cause mild illness, like the common cold.\n\nA diagnosis with coronavirus 229E, NL63, OC43, or HKU1 is not the same as a 2019-nCoV diagnosis. These are different viruses and patients with 2019-nCoV will be evaluated and cared for differently than patients with common coronavirus diagnosis. \n\nPublic health officials and partners are working hard to identify the source of the 2019-nCoV. Coronaviruses are a large family of viruses, some causing illness in people and others that circulate among animals, including camels, cats and bats. Analysis of the genetic tree of this virus is ongoing to know the specific source of the virus. SARS, another coronavirus that emerged to infect people, came from civet cats, while MERS, another coronavirus that emerged to infect people, came from camels. More information about the source and spread of 2019-nCoV is available on the 2019-nCoV Situation Summary: Source and Spread of the Virus.\n\nThis virus probably originally emerged from an animal source but now seems to be spreading from person-to-person. It\u2019s important to note that person-to-person spread can happen on a continuum. Some viruses are highly contagious (like measles), while other viruses are less so. At this time, it\u2019s unclear how easily or sustainably this virus is spreading between people. Learn what is known about the spread of newly emerged coronaviruses.","1457eb5b":"# Forecasting Total Number of Cases Worldwide\n\n## Prophet\n\nWe use Prophet, a procedure for forecasting time series data based on an additive model where non-linear trends are fit with yearly, weekly, and daily seasonality, plus holiday effects. It works best with time series that have strong seasonal effects and several seasons of historical data. Prophet is robust to missing data and shifts in the trend, and typically handles outliers well. It is also an open source software released by Facebook\u2019s Core Data Science team. It is available for download on CRAN and PyPI.\n\n## Why Prophet?\n\nProphet is easy to customize and use, and to produce accurate forecasts which can be explained intuitively with supporting evidence such as forecast seasonality components. It allows the analyst to explain in an intuitive and convinving manner to higher management as to why the forecasts are as such, and the plausible underlying factors that contribute to its result. Furthermore, it is also open-source! :)\n\n## References \n- https:\/\/facebook.github.io\/prophet\/\n- https:\/\/facebook.github.io\/prophet\/docs\/\n- https:\/\/github.com\/facebook\/prophet","9d4a2753":"## Transforming Data for Forecasting","96471c11":"We need to do some processing to the country names for this bubble plot as some of the countries are not found in `pycountry.countries` although they are, just that its due to them being listed acronyms and with additional words, such as Mainland China instead of China.","54c1a61e":"## Analysis by Country\n\nWe use Plotly (https:\/\/plot.ly\/python\/bubble-maps\/) for the visuals\n\n### Latest Date in Data","4282ae3e":"## By Country View (India)","be68af5a":"### Data Preparation\n\nAs we are now forecasting at country and state\/province level, for small values, it is possible for forecasts to become negative. To counter this, we round negative values to zero. To perform forecast evaluations using mean absolute error (MAE), we require to partition the dataset into train & validation sets. Here, the test set will contain the dates for which the Prophet model is trained on and where forecasts were made.","59658dc8":"# Data Import, Preprocessing and EDA","99667fb3":"### Some Final Touch-ups..","b074448e":"## Forecasting Recovered Cases Worldwide with Prophet (Baseline)\n\nWe perform a week's ahead forecast with Prophet, with 95% prediction intervals. Here, no tweaking of seasonality-related parameters and additional regressors are performed.","877de49c":"# Forecasting Confirmed, Death & Recovered Cases Worldwide with Prophet (by Country\/Region & Province\/State)","b19986e6":"# Evaluation of Forecasts (Mean Absolute Error)","9a5b16eb":"# COVID-19 Novel Coronavirus: EDA & Forecast Number of Cases","938082cc":"## Prophet with Daily & Weekly Seasonality (with custom Fourier orders)\n\nProphet will by default fit weekly and yearly seasonalities, if the time series is more than two cycles long. It will also fit daily seasonality for a sub-daily time series. You can add other seasonalities (monthly, quarterly, hourly) using the add_seasonality method (Python) or function (R).\n\nThe inputs to this function are a name, the period of the seasonality in days, and the Fourier order for the seasonality. For reference, by default Prophet uses a Fourier order of 3 for weekly seasonality and 10 for yearly seasonality. An optional input to add_seasonality is the prior scale for that seasonal component - this is discussed below.\n\n**Source:** https:\/\/facebook.github.io\/prophet\/docs\/seasonality,_holiday_effects,_and_regressors.html#fourier-order-for-seasonalities","6c918021":"## With Baseline Prophet Model (Using Default Parameters), Prophet Model with Custom Seasonalities & Fourier Orders","ba9353a4":"## By Country (Sorted)","b60c4f24":"## Latest Cases"}}