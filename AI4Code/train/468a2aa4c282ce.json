{"cell_type":{"b3e17700":"code","1b793217":"code","13bb26ab":"code","2bf7c03d":"code","2420a0b2":"code","8acc6ae0":"code","09ad92a1":"code","1546174b":"code","a370423d":"code","95ce476b":"code","e4f5aef2":"code","0b6dbe33":"code","3f175a9f":"code","8929fbcc":"code","dfee2290":"code","fae77f77":"code","1b943673":"code","7d3f9b2e":"code","f1424b1f":"markdown","90e89190":"markdown","0ce4b8fe":"markdown","9ba114d4":"markdown","66fed1e8":"markdown","90b79fe8":"markdown","14ec442e":"markdown","a69b7421":"markdown","93f18002":"markdown"},"source":{"b3e17700":"! pip install ..\/input\/chaii-python-module-installers\/xxhash-2.0.2-cp37-cp37m-manylinux2010_x86_64.whl\n! pip install ..\/input\/chaii-python-module-installers\/datasets-1.11.0-py3-none-any.whl\n! pip install -U --no-build-isolation --no-deps ..\/input\/chaii-python-module-installers\/transformers_master\/ -qq","1b793217":"import os\nimport sys\nsys.path.append(\"..\/input\/tez-lib\/\")\nimport tez\nimport torch\nimport random\nimport argparse\nimport collections\nimport transformers\nimport numpy as np\nimport pandas as pd\nfrom torch import nn\nfrom tqdm.auto import tqdm\nfrom datasets import Dataset\nfrom functools import partial\nfrom tez import enums\nfrom tez.callbacks import Callback\nfrom IPython.display import display, HTML\nfrom transformers import AdamW, get_linear_schedule_with_warmup\nfrom transformers import AutoTokenizer\nfrom transformers import default_data_collator\nfrom string import punctuation","13bb26ab":"class ChaiiCustomDataset:\n    def __init__(self, data):\n        self.data = data\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, item):\n        return {\n            \"ids\": torch.tensor(self.data[item][\"input_ids\"], dtype=torch.long),\n            \"mask\": torch.tensor(self.data[item][\"attention_mask\"], dtype=torch.long),\n        }","2bf7c03d":"class ChaiiNeuralModel(tez.Model):\n    def __init__(self, model_name, num_train_steps, steps_per_epoch, learning_rate):\n        super().__init__()\n        self.learning_rate = learning_rate\n        self.steps_per_epoch = steps_per_epoch\n        self.model_name = model_name\n        self.num_train_steps = num_train_steps\n        self.step_scheduler_after = \"batch\"\n\n        hidden_dropout_prob: float = 0.0\n        layer_norm_eps: float = 1e-7\n\n        config = transformers.AutoConfig.from_pretrained(model_name)\n        config.update(\n            {\n                \"output_hidden_states\": True,\n                \"hidden_dropout_prob\": hidden_dropout_prob,\n                \"layer_norm_eps\": layer_norm_eps,\n                \"add_pooling_layer\": False,\n            }\n        )\n        self.transformer = transformers.AutoModel.from_pretrained(model_name, config=config)\n        self.output = nn.Linear(config.hidden_size, config.num_labels)\n\n    def forward(self, ids, mask, token_type_ids=None, start_positions=None, end_positions=None):\n        transformer_out = self.transformer(ids, mask)\n        sequence_output = transformer_out[0]\n        logits = self.output(sequence_output)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1).contiguous()\n        end_logits = end_logits.squeeze(-1).contiguous()\n\n        return (start_logits, end_logits), 0, {}","2420a0b2":"def prepare_train_features(examples,\n                           tokenizer=None,\n                           pad_on_right=None,\n                           max_length=None,\n                           doc_stride=None):\n    # Some of the questions have lots of whitespace on the left, which is not useful and will make the\n    # truncation of the context fail (the tokenized question will take a lots of space). So we remove that\n    # left whitespace\n    examples[\"question\"] = [q.lstrip() for q in examples[\"question\"]]\n\n    # Tokenize our examples with truncation and padding, but keep the overflows using a stride. This results\n    # in one example possible giving several features when a context is long, each of those features having a\n    # context that overlaps a bit the context of the previous feature.\n    tokenized_examples = tokenizer(\n        examples[\"question\" if pad_on_right else \"context\"],\n        examples[\"context\" if pad_on_right else \"question\"],\n        truncation=\"only_second\" if pad_on_right else \"only_first\",\n        max_length=max_length,\n        stride=doc_stride,\n        return_overflowing_tokens=True,\n        return_offsets_mapping=True,\n        padding=\"max_length\",\n    )\n\n    # Since one example might give us several features if it has a long context, we need a map from a feature to\n    # its corresponding example. This key gives us just that.\n    sample_mapping = tokenized_examples.pop(\"overflow_to_sample_mapping\")\n    # The offset mappings will give us a map from token to character position in the original context. This will\n    # help us compute the start_positions and end_positions.\n    offset_mapping = tokenized_examples.pop(\"offset_mapping\")\n\n    # Let's label those examples!\n    tokenized_examples[\"start_positions\"] = []\n    tokenized_examples[\"end_positions\"] = []\n\n    for i, offsets in enumerate(offset_mapping):\n        # We will label impossible answers with the index of the CLS token.\n        input_ids = tokenized_examples[\"input_ids\"][i]\n        cls_index = input_ids.index(tokenizer.cls_token_id)\n\n        # Grab the sequence corresponding to that example (to know what is the context and what is the question).\n        sequence_ids = tokenized_examples.sequence_ids(i)\n\n        # One example can give several spans, this is the index of the example containing this span of text.\n        sample_index = sample_mapping[i]\n        answers = examples[\"answers\"][sample_index]\n        # If no answers are given, set the cls_index as answer.\n        if len(answers[\"answer_start\"]) == 0:\n            tokenized_examples[\"start_positions\"].append(cls_index)\n            tokenized_examples[\"end_positions\"].append(cls_index)\n        else:\n            # Start\/end character index of the answer in the text.\n            start_char = answers[\"answer_start\"][0]\n            end_char = start_char + len(answers[\"text\"][0])\n\n            # Start token index of the current span in the text.\n            token_start_index = 0\n            while sequence_ids[token_start_index] != (1 if pad_on_right else 0):\n                token_start_index += 1\n\n            # End token index of the current span in the text.\n            token_end_index = len(input_ids) - 1\n            while sequence_ids[token_end_index] != (1 if pad_on_right else 0):\n                token_end_index -= 1\n\n            # Detect if the answer is out of the span (in which case this feature is labeled with the CLS index).\n            if not (offsets[token_start_index][0] <= start_char and offsets[token_end_index][1] >= end_char):\n                tokenized_examples[\"start_positions\"].append(cls_index)\n                tokenized_examples[\"end_positions\"].append(cls_index)\n            else:\n                # Otherwise move the token_start_index and token_end_index to the two ends of the answer.\n                # Note: we could go after the last offset if the answer is the last word (edge case).\n                while token_start_index < len(offsets) and offsets[token_start_index][0] <= start_char:\n                    token_start_index += 1\n                tokenized_examples[\"start_positions\"].append(token_start_index - 1)\n                while offsets[token_end_index][1] >= end_char:\n                    token_end_index -= 1\n                tokenized_examples[\"end_positions\"].append(token_end_index + 1)\n\n    return tokenized_examples\n\ndef prepare_validation_features(examples,\n                                tokenizer=None,\n                                pad_on_right=None,\n                                max_length=None,\n                                doc_stride=None):\n    # Some of the questions have lots of whitespace on the left, which is not useful and will make the\n    # truncation of the context fail (the tokenized question will take a lots of space). So we remove that\n    # left whitespace\n    examples[\"question\"] = [q.lstrip() for q in examples[\"question\"]]\n\n    # Tokenize our examples with truncation and maybe padding, but keep the overflows using a stride. This results\n    # in one example possible giving several features when a context is long, each of those features having a\n    # context that overlaps a bit the context of the previous feature.\n    tokenized_examples = tokenizer(\n        examples[\"question\" if pad_on_right else \"context\"],\n        examples[\"context\" if pad_on_right else \"question\"],\n        truncation=\"only_second\" if pad_on_right else \"only_first\",\n        max_length=max_length,\n        stride=doc_stride,\n        return_overflowing_tokens=True,\n        return_offsets_mapping=True,\n        padding=\"max_length\",\n    )\n\n    # Since one example might give us several features if it has a long context, we need a map from a feature to\n    # its corresponding example. This key gives us just that.\n    sample_mapping = tokenized_examples.pop(\"overflow_to_sample_mapping\")\n\n    # We keep the example_id that gave us this feature and we will store the offset mappings.\n    tokenized_examples[\"example_id\"] = []\n\n    for i in range(len(tokenized_examples[\"input_ids\"])):\n        # Grab the sequence corresponding to that example (to know what is the context and what is the question).\n        sequence_ids = tokenized_examples.sequence_ids(i)\n        context_index = 1 if pad_on_right else 0\n\n        # One example can give several spans, this is the index of the example containing this span of text.\n        sample_index = sample_mapping[i]\n        tokenized_examples[\"example_id\"].append(examples[\"id\"][sample_index])\n\n        # Set to None the offset_mapping that are not part of the context so it's easy to determine if a token\n        # position is part of the context or not.\n        tokenized_examples[\"offset_mapping\"][i] = [\n            (o if sequence_ids[k] == context_index else None)\n            for k, o in enumerate(tokenized_examples[\"offset_mapping\"][i])\n        ]\n\n    return tokenized_examples\n\ndef postprocess_qa_predictions(examples, \n                               tokenizer, \n                               features, \n                               raw_predictions, \n                               n_best_size=20, \n                               max_answer_length=30, \n                               squad_v2=False):\n    all_start_logits, all_end_logits = raw_predictions\n    example_id_to_index = {k: i for i, k in enumerate(examples[\"id\"])}\n    features_per_example = collections.defaultdict(list)\n    for i, feature in enumerate(features):\n        features_per_example[example_id_to_index[feature[\"example_id\"]]].append(i)\n\n    predictions = collections.OrderedDict()\n\n    print(f\"Post-processing {len(examples)} example predictions split into {len(features)} features.\")\n\n    for example_index, example in enumerate(tqdm(examples)):\n        feature_indices = features_per_example[example_index]\n\n        min_null_score = None  # Only used if squad_v2 is True.\n        valid_answers = []\n\n        context = example[\"context\"]\n        for feature_index in feature_indices:\n            start_logits = all_start_logits[feature_index]\n            end_logits = all_end_logits[feature_index]\n            offset_mapping = features[feature_index][\"offset_mapping\"]\n\n            cls_index = features[feature_index][\"input_ids\"].index(tokenizer.cls_token_id)\n            feature_null_score = start_logits[cls_index] + end_logits[cls_index]\n            if min_null_score is None or min_null_score < feature_null_score:\n                min_null_score = feature_null_score\n\n            start_indexes = np.argsort(start_logits)[-1 : -n_best_size - 1 : -1].tolist()\n            end_indexes = np.argsort(end_logits)[-1 : -n_best_size - 1 : -1].tolist()\n            for start_index in start_indexes:\n                for end_index in end_indexes:\n                    if (\n                        start_index >= len(offset_mapping)\n                        or end_index >= len(offset_mapping)\n                        or offset_mapping[start_index] is None\n                        or offset_mapping[end_index] is None\n                    ):\n                        continue\n                    if end_index < start_index or end_index - start_index + 1 > max_answer_length:\n                        continue\n\n                    start_char = offset_mapping[start_index][0]\n                    end_char = offset_mapping[end_index][1]\n                    valid_answers.append(\n                        {\n                            \"score\": start_logits[start_index] + end_logits[end_index],\n                            \"text\": context[start_char:end_char],\n                        }\n                    )\n\n        if len(valid_answers) > 0:\n            best_answer = sorted(valid_answers, key=lambda x: x[\"score\"], reverse=True)[0]\n        else:\n            best_answer = {\"text\": \"\", \"score\": 0.0}\n\n        if not squad_v2:\n            predictions[example[\"id\"]] = best_answer[\"text\"]\n        else:\n            answer = best_answer[\"text\"] if best_answer[\"score\"] > min_null_score else \"\"\n            predictions[example[\"id\"]] = answer\n\n    return predictions\n\ndef preprocess_answers(answer_info):\n    ans_start_index = answer_info[0]\n    ans_text = answer_info[1]\n    return {\n        'answer_start': [int(ans_start_index)],\n        'text': [ans_text]\n    }","8acc6ae0":"def jaccard(str1, str2):\n    a = set(str1.lower().split())\n    b = set(str2.lower().split())\n    c = a.intersection(b)\n    return float(len(c)) \/ (len(a) + len(b) - len(c))","09ad92a1":"class EarlyStopping(Callback):\n    def __init__(\n        self,\n        monitor,\n        model_path,\n        valid_dataframe,\n        valid_data_loader,\n        tokenizer,\n        pad_on_right,\n        max_length,\n        doc_stride,\n        patience=3,\n        mode=\"min\",\n        delta=0.001,\n        save_weights_only=False,\n    ):\n        self.monitor = monitor\n        self.patience = patience\n        self.counter = 0\n        self.mode = mode\n        self.best_score = None\n        self.early_stop = False\n        self.delta = delta\n        self.save_weights_only = save_weights_only\n        self.model_path = model_path\n        if self.mode == \"min\":\n            self.val_score = np.Inf\n        else:\n            self.val_score = -np.Inf\n\n        if self.monitor.startswith(\"train_\"):\n            self.model_state = \"train\"\n            self.monitor_value = self.monitor[len(\"train_\") :]\n        elif self.monitor.startswith(\"valid_\"):\n            self.model_state = \"valid\"\n            self.monitor_value = self.monitor[len(\"valid_\") :]\n        else:\n            raise Exception(\"monitor must start with train_ or valid_\")\n\n        self.valid_targets = valid_dataframe.answer_text.values\n        self.valid_data_loader = valid_data_loader\n        self.tokenizer = tokenizer\n        valid_dataframe = valid_dataframe.drop([\"answer_text\", \"answer_start\"], axis=1)\n        self.valid_dataset = Dataset.from_pandas(valid_dataframe)\n        self.valid_features = self.valid_dataset.map(\n            partial(\n                prepare_validation_features,\n                tokenizer=self.tokenizer,\n                pad_on_right=pad_on_right,\n                max_length=max_length,\n                doc_stride=doc_stride,\n            ),\n            batched=True,\n            remove_columns=self.valid_dataset.column_names,\n        )\n\n    def on_epoch_end(self, model):\n        model.eval()\n        tk0 = tqdm(self.valid_data_loader, total=len(self.valid_data_loader))\n        start_logits = []\n        end_logits = []\n\n        for _, data in enumerate(tk0):\n            with torch.no_grad():\n                for key, value in data.items():\n                    data[key] = value.to(\"cuda\")\n                output, _, _ = model(**data)\n                start = output[0].detach().cpu().numpy()\n                end = output[1].detach().cpu().numpy()\n                start_logits.append(start)\n                end_logits.append(end)\n\n        start_logits = np.vstack(start_logits)\n        end_logits = np.vstack(end_logits)\n\n        valid_preds = postprocess_qa_predictions(\n            self.valid_dataset, self.tokenizer, self.valid_features, (start_logits, end_logits)\n        )\n        epoch_score = np.mean([jaccard(x, y) for x, y in zip(self.valid_targets, valid_preds.values())])\n        print(f\"Jaccard Score = {epoch_score}\")\n        model.train()\n        if self.mode == \"min\":\n            score = -1.0 * epoch_score\n        else:\n            score = np.copy(epoch_score)\n\n        if self.best_score is None:\n            self.best_score = score\n            self.save_checkpoint(epoch_score, model)\n        elif score < self.best_score + self.delta:\n            self.counter += 1\n            print(\"EarlyStopping counter: {} out of {}\".format(self.counter, self.patience))\n            if self.counter >= self.patience:\n                model.model_state = enums.ModelState.END\n        else:\n            self.best_score = score\n            self.save_checkpoint(epoch_score, model)\n            self.counter = 0\n\n    def save_checkpoint(self, epoch_score, model):\n        if epoch_score not in [-np.inf, np.inf, -np.nan, np.nan]:\n            print(\"Validation score improved ({} --> {}). Saving model!\".format(self.val_score, epoch_score))\n            model.save(self.model_path, weights_only=self.save_weights_only)\n        self.val_score = epoch_score","1546174b":"tokenizer = transformers.AutoTokenizer.from_pretrained(\"..\/input\/chaii-pretrained-models\/models\/deepset\/xlm-roberta-large-squad2\")\npad_on_right = tokenizer.padding_side == \"right\"\nmax_length = 384\ndoc_stride = 128\n\ntest_data = pd.read_csv(\"..\/input\/chaii-hindi-and-tamil-question-answering\/test.csv\")\ntest_dataset = Dataset.from_pandas(test_data)\ntest_features = test_dataset.map(\n    partial(\n        prepare_validation_features, \n        tokenizer=tokenizer,\n        pad_on_right=pad_on_right, \n        max_length=max_length,\n        doc_stride=doc_stride\n    ),\n    batched=True,\n    remove_columns=test_dataset.column_names\n)\ntest_feats_small = test_features.map(\n    lambda example: example, remove_columns=['example_id', 'offset_mapping']\n)\n\nfin_start_logits = None\nfin_end_logits = None\n\nfor fold_no in tqdm(range(10)):\n    model = ChaiiNeuralModel(model_name=\"..\/input\/chaii-pretrained-models\/models\/deepset\/xlm-roberta-large-squad2\", num_train_steps=0, steps_per_epoch=0, learning_rate=0)\n    model.load(\"..\/input\/chaii-trained-folds\/chaii_trained_fold_%s.bin\" %(str(fold_no)), weights_only=True)\n    model.to(\"cuda\")\n    model.eval()\n    data_loader = torch.utils.data.DataLoader(\n        ChaiiCustomDataset(test_feats_small), \n        batch_size=32,\n        num_workers=4,\n        pin_memory=True,\n        shuffle=False\n    )\n\n    start_logits = []\n    end_logits = []\n\n    for b_idx, data in enumerate(data_loader):\n        with torch.no_grad():\n            for key, value in data.items():\n                data[key] = value.to(\"cuda\")\n            output, _, _ = model(**data)\n            start = output[0].detach().cpu().numpy()\n            end = output[1].detach().cpu().numpy()\n            start_logits.append(start)\n            end_logits.append(end)\n    \n    start_logits = np.vstack(start_logits)\n    end_logits = np.vstack(end_logits)\n    \n    if fin_start_logits is None:\n        fin_start_logits = start_logits\n        fin_end_logits = end_logits\n    else:\n        fin_start_logits += start_logits\n        fin_end_logits += end_logits\n    \n    del model\n    torch.cuda.empty_cache()","a370423d":"fin_start_logits","95ce476b":"fin_end_logits","e4f5aef2":"fin_start_logits \/= 10\nfin_end_logits \/= 10","0b6dbe33":"final_preds = postprocess_qa_predictions(test_dataset, tokenizer, test_features, (fin_start_logits, fin_end_logits))","3f175a9f":"submission = []\nfor p1, p2 in final_preds.items():\n    p2 = \" \".join(p2.split())\n    p2 = p2.strip(punctuation)\n    submission.append((p1, p2))\n    \nsample = pd.DataFrame(submission, columns=[\"id\", \"PredictionString\"])\n\ntest_data =pd.merge(left=test_data,right=sample,on='id')","8929fbcc":"test_data","dfee2290":"bad_starts = [\".\", \",\", \"(\", \")\", \"-\", \"\u2013\",  \",\", \";\"]\nbad_endings = [\"...\", \"-\", \"(\", \")\", \"\u2013\", \",\", \";\"]\n\ntamil_ad = \"\u0b95\u0bbf.\u0baa\u0bbf\"\ntamil_bc = \"\u0b95\u0bbf.\u0bae\u0bc1\"\ntamil_km = \"\u0b95\u0bbf.\u0bae\u0bc0\"\nhindi_ad = \"\u0908\"\nhindi_bc = \"\u0908.\u092a\u0942\"\n\ncleaned_preds = []\nfor pred, context in test_data[[\"PredictionString\", \"context\"]].to_numpy():\n    if pred == \"\":\n        cleaned_preds.append(pred)\n        continue\n    while any([pred.startswith(y) for y in bad_starts]):\n        pred = pred[1:]\n    while any([pred.endswith(y) for y in bad_endings]):\n        if pred.endswith(\"...\"):\n            pred = pred[:-3]\n        else:\n            pred = pred[:-1]\n    \n    if any([pred.endswith(tamil_ad), pred.endswith(tamil_bc), pred.endswith(tamil_km), pred.endswith(hindi_ad), pred.endswith(hindi_bc)]) and pred+\".\" in context:\n        pred = pred+\".\"\n\n    cleaned_preds.append(pred)","fae77f77":"test_data[\"PredictionString\"] = cleaned_preds","1b943673":"test_data","7d3f9b2e":"test_data[['id', 'PredictionString']].to_csv('submission.csv', index=False)","f1424b1f":"# Install Module\n\nInstalling Datasets Module and Updating Transformers to the latest version by offline package resources","90e89190":"## Running the test dataset via each fold model and storing relevant positions  for each answer extracted","0ce4b8fe":"# Defining the early stopping class","9ba114d4":"## Pytorch Custom Dataset\n\nLink: https:\/\/pytorch.org\/tutorials\/beginner\/basics\/data_tutorial.html\n\nA custom Dataset class must implement three functions: __init__, __len__, and __getitem__. Take a look at this implementation; the FashionMNIST images are stored in a directory img_dir, and their labels are stored separately in a CSV file annotations_file.\n\nThe below examples is limited to create a custom Image Dataset however the code structure can be re-initialized to build a text based custom dataset also\n\n![image.png](attachment:3b28bf09-56a4-4db7-95f2-86e072ebc5ff.png)","66fed1e8":"## Pytorch Build the NN\n\nLink: https:\/\/pytorch.org\/tutorials\/beginner\/basics\/buildmodel_tutorial.html\n\nWe define our neural network by subclassing nn.Module, and initialize the neural network layers in __init__. Every nn.Module subclass implements the operations on input data in the forward method.\n\n![image.png](attachment:f13e73fd-85c4-44b1-abec-360c3e955e71.png)","90b79fe8":"# Post Processing each predictions","14ec442e":"# Importing Libraries","a69b7421":"# Preparing the Tokenization Pipeline","93f18002":"## Dividing by total no of folds to get average out values"}}