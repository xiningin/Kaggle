{"cell_type":{"327dfa40":"code","281de3a8":"code","f7729c73":"code","33c4c86f":"code","686ff293":"code","c111bea1":"code","005bcc64":"code","7c41f679":"code","74df3697":"markdown","50758ec4":"markdown","6b511a49":"markdown","a074334d":"markdown","d364d17d":"markdown","4fdaf70c":"markdown"},"source":{"327dfa40":"import os\nimport random\nimport itertools\nimport numpy as np\nimport pandas as pd\nfrom tqdm.contrib.concurrent import process_map","281de3a8":"!wget http:\/\/webhotel4.ruc.dk\/~keld\/research\/LKH-3\/LKH-3.0.7.tgz\n!tar xvfz LKH-3.0.7.tgz\n!cd LKH-3.0.7; make; cp LKH ..","f7729c73":"LETTERS = {\n    1: '\ud83c\udf85',  # father christmas\n    2: '\ud83e\udd36',  # mother christmas\n    3: '\ud83e\udd8c',  # reindeer\n    4: '\ud83e\udddd',  # elf\n    5: '\ud83c\udf84',  # christmas tree\n    6: '\ud83c\udf81',  # gift\n    7: '\ud83c\udf80',  # ribbon\n    8: '\ud83c\udf1f',  # star\n}\nINV_LETTERS = {v: k for k, v in LETTERS.items()}\n\nsolution = pd.read_csv('..\/input\/ctsp-2440\/submission_no_wildcards_2440_2440_2440.csv')\nstrings = [[INV_LETTERS[c] for c in s] for s in solution.schedule]\nstrings.sort(key=len, reverse=True)\nprint(f'Strings lengths are {[len(_) for _ in strings]}.')","33c4c86f":"def find_strings_perms(strings, verbose=False):\n    all_perms = set(itertools.permutations(range(1, 8), 7))\n    perms = []\n    for s in strings:\n        perms.append([])\n        for i in range(len(s)-6):\n            p = tuple(s[i:i+7])\n            if p in all_perms:\n                perms[-1].append(p)\n    if verbose:\n        lens = [len(_) for _ in  perms]\n        print(f'There are {lens} permutations in strings, {sum(lens)} in total.')\n        lens = [len(set(_)) for _ in  perms]\n        print(f'There are {lens} unique permutations in strings, {sum(lens)} in total.')\n    return perms\n\nstrings_perms = find_strings_perms(strings, verbose=True)","686ff293":"def rebalance_perms(strings_perms, verbose=False):\n    # convert to dicts for fast lookup and to keep permutations order\n    strings_perms = [dict.fromkeys(_) for _ in strings_perms] \n    for p in strings_perms[0].copy():  # iterate over the copy to allow modification during iteration\n        if p[:2] != (1, 2) and (p in strings_perms[1] or p in strings_perms[2]):\n            strings_perms[0].pop(p)\n    for p in strings_perms[1].copy():\n        if p[:2] != (1, 2) and p in strings_perms[2]:\n            strings_perms[1].pop(p)\n    if verbose:\n        lens = [len(_) for _ in  strings_perms]\n        print(f'There are {lens} permutations left in strings after rebalancing, {sum(lens)} in total.')\n    return [list(_) for _ in strings_perms] \n\nstrings_perms = rebalance_perms(strings_perms, verbose=True)","c111bea1":"def perm_dist_wildcard(p, q):\n    #Hacky-cracky generalization of initial distance calculation to take wildcards into account\n    #Wildcard in first position in q but no wildcard in p.\n    if (8 in q) and (8 not in p):\n        if (q[0] == 8):\n            i = p.index(q[1])\n            if p[i:] == q[1:7-i+1]:\n                if i - 1 == 0:\n                    #Going from non-wildcard permutation to its wildcard will result in length 7\n                    return 7\n                else:\n                    return i - 1\n            else:\n                return 6\n        else:\n            i = p.index(q[0])\n            w = q.index(8)\n            return i if (p[i:i+w] == q[:w]) and (p[i+w+1:] == q[w+1:7-i]) else 7\n    \n    #Distance from wildcard to its normal permutation is 0.\n    if (8 in p) and (8 not in q):\n        wi = p.index(8)\n        if (p[:wi] == q[:wi]) and (p[wi+1:] == q[wi+1:]):\n            return 0\n        \n    #Distance from wildcard to non-wildcard\n    if q[0] not in p:\n        i = p.index(8)\n        return i if p[i+1:] == q[1:7-i] else 7\n    \n    i = p.index(q[0])\n    return i if p[i:] == q[:7-i] else 7\n\ndef create_perms_wildcards(perms):\n    #Create wildcards with only first member as wildcard\n    #Currently creates wildcards for only mandatory members\n    perms_wildcards = perms.copy()\n    wildcards = []\n    for perm in perms:\n        if perm[:2] == (1,2):\n            perm_w = list(perm)\n            perm_w[0] = 8\n            perm_w = tuple(perm_w)\n            wildcards.append(perm_w)\n    for wildcard in wildcards:\n        perms_wildcards.append(wildcard)\n    return perms_wildcards\n\ndef perms_to_string_wildcards(perms):\n    perms = list(perms)\n    s = [*perms[0]]\n    for p, q in zip(perms, perms[1:]):\n        d = perm_dist_wildcard(p, q)\n        if 8 in q:\n            if d == 7:\n                s[-7:] = q[:-d]\n            else:\n                s[-7+d:] = q[:-d]\n        if d > 0:\n            s.extend(q[-d:])\n    return s\n\ndef distances_matrix_wildcards(perms):\n    m = np.zeros((len(perms), len(perms)), dtype='int8')\n    for i, p in enumerate(perms):\n        for j, q in enumerate(perms):\n            m[i, j] = perm_dist_wildcard(p, q)\n    return m\n\ndef write_params_file_acvrp(uid):\n    with open('santa_%s.par' % uid, 'w') as f:\n        print('SPECIAL', file=f)\n        print('PROBLEM_FILE = santa_%s.vrp' % uid, file=f)\n        print('MTSP_OBJECTIVE = MINSUM', file=f)\n        print('TOUR_FILE = best_tour_%s.txt' % uid, file=f)\n        print('OUTPUT_TOUR_FILE = output_tour_%s_$.txt' % uid, file=f)\n        print('INITIAL_TOUR_FILE = initial_tour_%s.txt' % uid, file=f)\n        print('SALESMEN = 1', file=f)\n        print('PATCHING_C = 4', file=f)\n        print('PATCHING_A = 3', file=f)\n        print('GAIN23 = YES', file=f)\n        print('SEED = 42', file=f)\n        print('MAX_TRIALS = 100000', file=f)\n        print('TIME_LIMIT = 30000', file=f) #seconds\n        print('TRACE_LEVEL = 2', file=f)\n        print('PRECISION = 1', file=f)\n\ndef write_problem_file_acvrp(uid, distances, capacity=2, wildcard_count=0):\n    with open('santa_%s.vrp' % uid, 'w') as f:\n        print('TYPE: ACVRP', file=f)\n        print(f'DIMENSION: {len(distances)}', file=f)\n        print(f'CAPACITY : {capacity}', file=f)\n        print('VEHICLES : 1', file=f)\n        print('EDGE_WEIGHT_TYPE: EXPLICIT', file=f)\n        print('EDGE_WEIGHT_FORMAT: FULL_MATRIX\\n', file=f)\n        print('EDGE_WEIGHT_SECTION', file=f)\n        for row in distances:\n            print(' '.join(str(_) for _ in row), file=f)\n        print('DEMAND_SECTION', file=f)\n        r = 0\n        non_wildcard_count = len(distances) - wildcard_count\n        for row in distances:\n            r += 1\n            if r > non_wildcard_count:\n                print(f'{r}    1', file=f)\n            else:\n                print(f'{r}    0', file=f)\n\ndef write_initial_tour_file(uid, perms):\n    with open('initial_tour_%s.txt' % uid, 'w') as f:\n        print('TOUR_SECTION', file=f)\n        print(' '.join(str(_) for _ in range(1, len(perms)+1)), -1, file=f)\n\ndef read_output_tour_wildcard(uid, perms, exclusion_count = 0):\n    perms = list(perms)\n    with open('best_tour_%s.txt' % uid) as f:\n        lines = f.readlines()\n    tour = lines[lines.index('TOUR_SECTION\\n')+1:-2-exclusion_count]\n    return [perms[int(_) - 1] for _ in tour] \n\ndef solve_acvrp(perms, verbose=False):\n    uid = str(random.randint(1, 9999))\n    write_params_file_acvrp(uid)\n    perms_wildcard = create_perms_wildcards(perms)\n    wildcard_option_count = len(perms_wildcard) - len(perms)\n    distances = distances_matrix_wildcards(perms_wildcard)\n    write_problem_file_acvrp(uid, distances, 2, wildcard_option_count)\n    write_initial_tour_file(uid, perms_wildcard)\n    \n    # Run LKH-3 to solve ACVRP instance\n    if verbose:\n        os.system('.\/LKH santa_%s.par' % uid)\n    else:\n        os.system('touch lkh_%s.log' % uid)\n        os.system('.\/LKH santa_%s.par >> lkh_%s.log' % (uid, uid))\n    \n    # To read output tour, we want to exclude wildcard in the end of the file,\n    # but there will be 2 more members than a normal tour thanks to two wildcards.\n    # This is why we have this weird wildcard_option_count-2 as argument.\n    tour = read_output_tour_wildcard(uid, perms_wildcard, wildcard_option_count-2)\n    return perms_to_string_wildcards(tour)","005bcc64":"print('='*91)\n#Solve ACVRP for wildcards!\nnew_strings = list(process_map(solve_acvrp, strings_perms))\nnew_strings.sort(key=len, reverse=True)\nnew_lens = [len(_) for _ in new_strings]\nstrings = new_strings","7c41f679":"sub = pd.DataFrame()\nsub['schedule'] = [''.join(LETTERS[x] for x in s) for s in strings]\nsub_name = 'submission.csv'\nsub.to_csv(sub_name, index=False)","74df3697":"# Peek closely at the permutations in each string\n\nRebalancing helps to reduce the amount of nodes in each string so this might help with getting the solution faster.","50758ec4":"# Solving wildcards using ACVRP (Asymmetric Capacitated Vehicle Routing Problem)\nLKH-3's ACVRP will be used.\n\n## General idea\nPut a constraint to how many wildcards can be \"traveled through\". In our assignment it is 2. Have non-wildcards with zero capacity and wildcards with 1. When setting vehicles capacity to 2 we should have only 2 wildcards in our solution.\n\n## How to read the results from tour file?\nAll the unused wildcards will be in the end of the tour so these should be ignored.\n\n## Why VRP?\nLKH-3 library didn't seem to have good solution for capacitated TSP but it is the same as VRP with vehicles = 1.","6b511a49":"2440 was obtained by running CTSP model for several days.","a074334d":"# **REFERENCES**\n* https:\/\/www.kaggle.com\/starohub\/st-21-a-minmax-ctsp\n* https:\/\/www.kaggle.com\/yamqwe\/permutations-rebalancing-multiprocessing\n* http:\/\/webhotel4.ruc.dk\/~keld\/research\/LKH-3\/","d364d17d":"This might not be the most optimal solution the model can find because of time constraint. But eventually solution for 2430 can be obtained.","4fdaf70c":"## Wildcard adding\n* Currently wildcard options are added to mandatory permutations as these probably bring the most additional length to string and could be the best candidates for wildcard.\n* Wildcard will be added to the beginning of the permutation. For example *234567.\n\nPossible improvements might include.\n* Adding wildcard options to other positions.\n* Adding non-mandatory permutations to wildcard options.\n\n### Optimization trick\nI will define distance from wildcard to its non-wildcard to be 0 (and 7 vice versa). This way the optimization can use all non-wildcard options and use wildcards."}}