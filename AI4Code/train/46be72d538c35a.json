{"cell_type":{"7be452db":"code","5b9bb334":"code","30e0f58c":"code","f5292aa7":"code","2e38c5e5":"code","059f667d":"code","1e6c0c21":"code","55253f1d":"code","8dfc4812":"code","186be1d8":"code","b905064b":"code","d78eb8a9":"code","7f839712":"code","15122511":"code","48ce9b3c":"code","515112c5":"code","29fe2a2f":"code","c147c408":"code","923e74a5":"code","432cb14c":"code","f4e0e298":"code","4b16d77c":"markdown","f0f55ed2":"markdown","b4971942":"markdown","4e74b6b7":"markdown","1de644d4":"markdown","61edc350":"markdown","e5c7489a":"markdown"},"source":{"7be452db":"import numpy as np\nimport pandas as pd\nimport sklearn\nimport scipy\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.metrics import classification_report,accuracy_score\nfrom sklearn.ensemble import IsolationForest\nfrom sklearn.neighbors import LocalOutlierFactor\nfrom sklearn.svm import OneClassSVM\nfrom pylab import rcParams\nrcParams['figure.figsize'] = 14, 8\nRANDOM_SEED = 42\nLABELS = [\"Nonfraudulent\", \"Fraudulent\"]","5b9bb334":"data = pd.read_csv(\"..\/input\/credit-card-fraud\/creditcard.csv\")\ndata.head()","30e0f58c":"data.info()","f5292aa7":"data.isnull().values.any()","2e38c5e5":"count_classes = pd.value_counts(data['Class'], sort = True)\n\ncount_classes.plot(kind = 'bar', rot=0)\n\nplt.title(\"Transaction\")\n\nplt.xticks(range(2), LABELS)\n\nplt.xlabel(\"Class\")\n\nplt.ylabel(\"Frequency\")","059f667d":"fraudulent = data[data['Class']==1]\n\nnonfraudulent = data[data['Class']==0]\n\nprint(f'fraudulent{fraudulent.shape}  nonfraudulent{nonfraudulent.shape}')","1e6c0c21":"data1= data.sample(frac = 0.1,random_state=1)\n\ndata1.shape","55253f1d":"data.shape","8dfc4812":"f, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\nf.suptitle('Amount per transaction by class')\nbins = 50\nax1.hist(fraudulent.Amount, bins = bins)\nax1.set_title('Fraud')\nax2.hist(nonfraudulent.Amount, bins = bins)\nax2.set_title('Nonfraudulent')\nplt.xlabel('Amount ($)')\nplt.ylabel('Number of Transactions')\nplt.xlim((0, 20000))\nplt.yscale('log')\nplt.show()","186be1d8":"print('Fraudulent Amount')\nfraudulent.Amount.describe()\nplt.boxplot(fraudulent.Amount)","b905064b":"print('Non-fraudulent Amount')\nnonfraudulent.Amount.describe()\nplt.boxplot(nonfraudulent.Amount)","d78eb8a9":"f, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\nf.suptitle('V2 vs Amount')\nax1.scatter(fraudulent.V2, fraudulent.Amount)\nax1.set_title('Fraud')\nax2.scatter(nonfraudulent.V2, nonfraudulent.Amount)\nax2.set_title('Nonfraud')\nplt.xlabel('V2')\nplt.ylabel('Amount')\nplt.show()","7f839712":"sns.regplot(x='V2',\n           y='Amount',\n           ci=None,\n           data=nonfraudulent)","15122511":"sns.regplot(x='V2',\n           y='Amount',\n           ci=None,\n           data=fraudulent)","48ce9b3c":"import seaborn as sns\n#get correlations of each features in dataset\ncorrmat = data1.corr()\ntop_corr_features = corrmat.index\nplt.figure(figsize=(20,20))\n#plot heat map\ng=sns.heatmap(data[top_corr_features].corr(),annot=True,cmap=\"RdYlGn\")","515112c5":"Fraud = data1[data1['Class']==1]\n\nValid = data1[data1['Class']==0]\n\noutlier_fraction = len(Fraud)\/float(len(Valid))","29fe2a2f":"print(outlier_fraction)\n\nprint(\"Fraud Cases : {}\".format(len(Fraud)))\n\nprint(\"Valid Cases : {}\".format(len(Valid)))","c147c408":"#Create independent and Dependent Features\ncolumns = data1.columns.tolist()\n# Filter the columns to remove data we do not want \ncolumns = [c for c in columns if c not in [\"Class\"]]\n# Store the variable we are predicting \ntarget = \"Class\"\n# Define a random state \nstate = np.random.RandomState(42)\nX = data1[columns]\nY = data1[target]\nX_outliers = state.uniform(low=0, high=1, size=(X.shape[0], X.shape[1]))\n# Print the shapes of X & Y\nprint(X.shape)\nprint(Y.shape)","923e74a5":"classifiers = {\n    \"Isolation Forest\":IsolationForest(n_estimators=100, max_samples=len(X),contamination=outlier_fraction,random_state=state, verbose=0),\n    \"Local Outlier Factor\":LocalOutlierFactor(n_neighbors=20, algorithm='auto',leaf_size=30, metric='minkowski', p=2, metric_params=None, contamination=outlier_fraction)\n}","432cb14c":"type(classifiers)","f4e0e298":"from sklearn.metrics import confusion_matrix\nn_outliers = len(Fraud)\nfor i, (clf_name,clf) in enumerate(classifiers.items()):\n    #Fit the data and tag outliers\n    if clf_name == \"Local Outlier Factor\":\n        y_pred = clf.fit_predict(X)\n        scores_prediction = clf.negative_outlier_factor_\n    elif clf_name == \"Isolation Forest\":\n        clf.fit(X)\n        scores_prediction = clf.decision_function(X)\n        y_pred = clf.predict(X)\n    else:    \n       print ('No other model')\n    \n    #Reshape the prediction values to 0 for Valid transactions , 1 for Fraud transactions\n    y_pred[y_pred == 1] = 0\n    y_pred[y_pred == -1] = 1\n    n_errors = (y_pred != Y).sum()\n    # Run Classification Metrics\n    print(\"{}: {}\".format(clf_name,n_errors))\n    print(\"Accuracy Score :\")\n    print(accuracy_score(Y,y_pred))\n    print(\"Classification Report :\")\n    print(classification_report(Y,y_pred))\n    conf_matrix = confusion_matrix(Y, y_pred)\n    sns.heatmap(conf_matrix, xticklabels=LABELS, yticklabels=LABELS, annot=True, fmt='d');\n    plt.title('Confusion Matrix for ' + clf_name)\n    plt.ylabel('Actual class')\n    plt.xlabel('Predicted class')\n    plt.show()","4b16d77c":"# Boxplots","f0f55ed2":"# Analyzing the models using Errors, Confusion Matrix, Accuracy Score and Classification Report","b4971942":"# Frequency Histograms","4e74b6b7":"# Correlation matrix","1de644d4":"\n# Observations: Coclusion\n* Isolation Forest detected 73 errors versus Local Outlier Factor detecting 97 errors vs. SVM detecting 8516 errors\n* Isolation Forest has a 99.74% more accurate than LOF of 99.65% and SVM of 70.09\n* When comparing error precision & recall for 3 models , the Isolation Forest performed much better than the LOF as we can see that the detection of fraud cases is around 27 % versus LOF detection rate of just 2 % and SVM of 0%.\n* So overall Isolation Forest Method performed much better in determining the fraud cases which is around 30%.\n","61edc350":"# # Outlier detection Models","e5c7489a":"# Scatterplots with best line of fit"}}