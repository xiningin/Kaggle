{"cell_type":{"2aacc913":"code","641a7a90":"code","9951b0cd":"code","8ed2d11f":"code","3e59b1ee":"code","4687792b":"code","4cc33f19":"code","566505bb":"code","02e7ca29":"code","f62fb8b7":"code","6c792405":"code","ddd88c15":"code","d57f91bc":"code","00016279":"code","77a9649d":"code","5035cd46":"code","16786b29":"code","f8731489":"code","b62bb813":"code","4e87613b":"code","8d1df0cf":"code","6582f54d":"markdown","cc591e0d":"markdown","61a17cb0":"markdown","30f64536":"markdown","54384d9f":"markdown","a11628e8":"markdown","c2b4d5c8":"markdown"},"source":{"2aacc913":"import dask\nimport dask.dataframe as dd\nimport warnings\nimport datetime\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport category_encoders as ce\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split, KFold\nfrom sklearn.metrics import confusion_matrix, classification_report, accuracy_score, recall_score, precision_score, f1_score\nimport xgboost as xgb\n\n%matplotlib inline\nsns.set(style=\"whitegrid\")\nwarnings.filterwarnings(\"ignore\")\npd.set_option('display.float_format', lambda x: '%.2f' % x)","641a7a90":"dtypes = {\n        'MachineIdentifier':                                    'category',\n        'AVProductsInstalled':                                  'float16',\n        'AVProductsEnabled':                                    'float16',\n        'IsProtected':                                          'float16',\n        'Census_ProcessorCoreCount':                            'float16',\n        'Census_SystemVolumeTotalCapacity':                     'float32',\n        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',\n        'Wdft_IsGamer':                                         'float16',\n        'AvSigVersion':                                         'category',\n        'OsBuildLab':                                           'category',\n        'Census_OSVersion':                                     'category',\n        'AppVersion':                                           'category',\n        'EngineVersion':                                        'category',\n        'Census_PowerPlatformRoleName':                         'category',\n        'OsPlatformSubRelease':                                 'category',\n        'Census_OSInstallTypeName':                             'category',\n        'SkuEdition':                                           'category',\n        'Census_ActivationChannel':                             'category',\n        'Census_OSWUAutoUpdateOptionsName':                     'category',\n        'ProductName':                                          'category',\n        'Platform':                                             'category',\n        'Census_PrimaryDiskTypeName':                           'category',\n        'Census_DeviceFamily':                                  'category',\n        'Census_OSArchitecture':                                'category',\n        'Processor':                                            'category',\n        'HasDetections':                                        'int8'\n        }\n\nlabel = ['HasDetections']\n\nids = ['MachineIdentifier']\n\nnumerical_features = ['AVProductsEnabled', 'AVProductsInstalled', \n                      'Census_ProcessorCoreCount', 'Census_SystemVolumeTotalCapacity']\n\nbinary_features = ['Census_IsAlwaysOnAlwaysConnectedCapable', 'IsProtected', 'Wdft_IsGamer']\n\nversion_features = ['AvSigVersion', 'OsBuildLab', 'Census_OSVersion', 'AppVersion', 'EngineVersion']\n\n# < 10 categories\nlow_cardinality_features = ['Census_PowerPlatformRoleName', 'OsPlatformSubRelease', \n                            'Census_OSInstallTypeName', 'SkuEdition', 'Census_ActivationChannel', \n                            'Census_OSWUAutoUpdateOptionsName', 'ProductName', \n                            'Platform', 'Census_PrimaryDiskTypeName', 'Census_DeviceFamily', \n                            'Census_OSArchitecture', 'Processor']\n\nuse_columns = numerical_features + binary_features + version_features + low_cardinality_features","9951b0cd":"train = pd.read_csv('..\/input\/microsoft-malware-prediction\/train.csv', dtype=dtypes, usecols=(use_columns + label), nrows=1000000)\nprint(train.shape)","8ed2d11f":"for feature in version_features:\n    if feature in ['EngineVersion']:\n        train[feature] = train[feature].apply(lambda x : \".\".join(x.split('.')[:3]))\n    elif feature in ['OsBuildLab']:\n        train[feature] = train[feature].apply(lambda x : \".\".join(x.split('.')[:1]))\n    else:\n        train[feature] = train[feature].apply(lambda x : \".\".join(x.split('.')[:2]))","3e59b1ee":"# Remove rows with NA\ntrain.dropna(inplace=True)","4687792b":"Y_train = train[label]\nX_train = train.drop(label, axis = 1)\n\nencoder = ce.TargetEncoder(cols=(version_features + low_cardinality_features))\nencoder.fit(X_train, Y_train)\nX_train = encoder.fit_transform(X_train.reset_index(), Y_train)","4cc33f19":"X_train.fillna(X_train.mean(), inplace=True)","566505bb":"test = dd.read_csv('..\/input\/microsoft-malware-prediction\/test.csv', dtype=dtypes, usecols=(use_columns + ids)).compute()","02e7ca29":"test.drop('MachineIdentifier',axis=1, inplace=True)","f62fb8b7":"for feature in version_features:\n    if feature in ['EngineVersion']:\n        test[feature] = test[feature].apply(lambda x : \".\".join(x.split('.')[:3]))\n    elif feature in ['OsBuildLab']:\n        test[feature] = test[feature].apply(lambda x : \".\".join(x.split('.')[:1]))\n    else:\n        test[feature] = test[feature].apply(lambda x : \".\".join(x.split('.')[:2]))\n        \ntest = encoder.transform(test.reset_index())","6c792405":"test.drop('index', axis = 1, inplace = True)\nX_train.drop('index', axis = 1, inplace = True)\ntest['is_train'] = 0\nX_train['is_train'] = 1","ddd88c15":"df = pd.concat([X_train, test], axis = 0)\ndf.describe()","d57f91bc":"df.head()","00016279":"X_train.head()","77a9649d":"y = df['is_train']\ndf.drop('is_train', axis = 1, inplace = True) \n\n# Xgboost parameters\nxgb_params = {'learning_rate': 0.05, \n              'max_depth': 4,\n              'subsample': 0.9,        \n              'colsample_bytree': 0.9,\n              'objective': 'binary:logistic',\n              'silent': 1, \n              'n_estimators':100, \n              'gamma':1,         \n              'min_child_weight':4}   \nclf = xgb.XGBClassifier(**xgb_params, seed = 10)\nclf.fit(df, y)","5035cd46":"del test, Y_train, df, y","16786b29":"X_train.head()","f8731489":"X_train.drop('is_train', axis = 1, inplace = True) \n\nprobs = clf.predict_proba(X_train)[:,1]\nnew_df = pd.DataFrame({'id':X_train.index, 'probs':probs})\nnew_df = new_df.sort_values(by = 'probs', ascending=False)","b62bb813":"val_set_ids = new_df.iloc[1:np.int(new_df.shape[0]*0.2),1]","4e87613b":"val_set_ids.to_csv('validation_20.csv')","8d1df0cf":"# # Adversarial validation idexes\n# avi = pd.read_csv('..\/input\/validation_20.csv', names=['indexes', 'probability'])\n\n# # Split in train and validation\n# X_train = train[~train.index.isin(avi['indexes'])]\n# 2X_val = train[train.index.isin(avi['indexes'])]","6582f54d":"## Adversarial Validation\nWhen looking at different kinds techniques to avoid overfitting, the one that is most fit to our problems is Adversarial Validation. Which gives us probabilities of a given row from a train dataset to belong to the test dataset.\n\n* *References: [Improve Your Model Performance using Cross Validation (in Python and R)](https:\/\/www.analyticsvidhya.com\/blog\/2018\/05\/improve-model-performance-cross-validation-in-python-r\/)*","cc591e0d":"## Simplification of version related features\n### Reduce granularity on version features","61a17cb0":"### To read","30f64536":"### Load data\n\nI reduced the size so it could run on Kaggle, I run it locally with all the data.","54384d9f":"## Encoding\n\nFrom analysing a different number of encoders (One hot, Hash, frequency, binary), the one with best results was the Target Encoder.","a11628e8":"### Introduction\nOne of the most important problems in the [challange to predict malware](https:\/\/www.kaggle.com\/c\/microsoft-malware-prediction) is to find an validation dataset that represents the test. As many commented in the [discussions](http:\/\/https:\/\/www.kaggle.com\/c\/microsoft-malware-prediction\/discussion\/75087), the data for this competition is quite diferent from the train dataset to the test. This kernel has some feature engenieering and adversarial validation made by me and [DimitreOliveira](https:\/\/www.kaggle.com\/dimitreoliveira) to deal with that problem.\n\n#### **Table of contents**\n1. [Simplification of version related features](#Simplification-of-version-related-features);\n2. [Encoding](#Encoding);\n3. [Adversarial Validation](#Adversarial-Validation).","c2b4d5c8":"### Fill missing values with mean\nThe values will be filled with the mean value, since it's the base to our encoder."}}