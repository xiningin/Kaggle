{"cell_type":{"70d441d9":"code","30870c4b":"code","97784adc":"code","c66a7e90":"code","ab028a96":"code","a1b21d20":"code","a091f59f":"code","5341b80f":"code","4c10f141":"code","e77678bc":"code","acf0c7cf":"code","5ce6c8d4":"code","8ac7b89a":"code","0fbe89bf":"code","55d98e19":"code","cabcffed":"code","b2742dda":"code","96ed8b38":"code","5c169380":"code","75eedd81":"code","3d519402":"code","17395e8f":"code","1ab2b87c":"code","6ef02694":"markdown","b872d4ca":"markdown","bcd5394c":"markdown","534cca70":"markdown","538f4f53":"markdown","4de7d97f":"markdown","e9f40fc9":"markdown","32a8c33f":"markdown","bac06f65":"markdown","a83677ae":"markdown","117d4551":"markdown","a711a719":"markdown","dce0f2ce":"markdown","eef0ccd1":"markdown","f5371fb5":"markdown","58911436":"markdown","81ecf5db":"markdown","7b854067":"markdown","cb93d188":"markdown","1fca4ce0":"markdown","93d3ac2c":"markdown"},"source":{"70d441d9":"import collections\nimport json\nimport os\nimport uuid\nimport gc\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom PIL import Image, ImageDraw\nimport tifffile as tiff \nimport seaborn as sns\nimport tensorflow as tf\nfrom tqdm.notebook import tqdm\n\nfrom skimage.measure import label, regionprops\nimport cv2","30870c4b":"TRAIN_PATH = \"..\/input\/hubmap-kidney-segmentation\/train\/\"\n\n## Training dataset information\ntrain_df = pd.read_csv(\"..\/input\/hubmap-kidney-segmentation\/train.csv\")\nprint(f\"Shape of the Train data - {train_df.shape}\")\n\nprint(f\"First ID - {train_df.iloc[0, 0]}\")\nprint(f\"First Encoding string beginning- {train_df.iloc[0, 1][:100]}\")","97784adc":"def DICE_COE(mask1, mask2):\n    intersect = np.sum(mask1*mask2)\n    fsum = np.sum(mask1)\n    ssum = np.sum(mask2)\n    dice = (2 * intersect ) \/ (fsum + ssum)\n    dice = np.mean(dice)\n    dice = round(dice, 3) # for easy reading\n    return dice    ","c66a7e90":"## Looking into a single training image\nimage1 = tiff.imread(TRAIN_PATH + train_df.iloc[4, 0] + \".tiff\")","ab028a96":"print(\"Image ID --> \", train_df.iloc[1, 0], \"\\tTraining image shape -->\", image1.shape)","a1b21d20":"## The kidney tissue image\nimage1 = image1[0][0].transpose(1, 2, 0)\nplt.figure(figsize=(10, 10))\nplt.imshow(image1)\nplt.title(\"Random Image of Kidney Tissue\", size=15)\nplt.show()","a091f59f":"## We need to decode the mask from encoding column of train.csv\n## https:\/\/www.kaggle.com\/paulorzp\/rle-functions-run-lenght-encode-decode\ndef mask2rle(img):\n    '''\n    img: numpy array, 1 - mask, 0 - background\n    Returns run length as string formated\n    '''\n    pixels= img.T.flatten()\n    pixels = np.concatenate([[0], pixels, [0]])\n    runs = np.where(pixels[1:] != pixels[:-1])[0] + 1\n    runs[1::2] -= runs[::2]\n    return ' '.join(str(x) for x in runs)\n \ndef rle2mask(mask_rle, shape):\n    '''\n    mask_rle: run-length as string formated (start length)\n    shape: (width,height) of array to return \n    Returns numpy array, 1 - mask, 0 - background\n\n    '''\n    s = mask_rle.split()\n    starts, lengths = [np.asarray(x, dtype=int) for x in (s[0:][::2], s[1:][::2])]\n    starts -= 1\n    ends = starts + lengths\n    #print(starts, ends)\n    img = np.zeros(shape[0]*shape[1], dtype=np.uint8)\n    for lo, hi in zip(starts, ends):\n        img[lo:hi] = 1\n    return img.reshape(shape).T","5341b80f":"## Plot all the Glomeruli in this particular kidney\nmask = rle2mask(train_df.iloc[4, 1], (image1.shape[1], image1.shape[0])) # Call the RLE2Mask function","4c10f141":"## The same kidney image with all the masks\nplt.figure(figsize=(10, 10))\nplt.imshow(image1)\nplt.imshow(mask, alpha=0.5, cmap='plasma')\nplt.title(\"Image with Masks on Glomeruli\", size=15)\nplt.show()","e77678bc":"# SAVING RAM\ndel train_df\na = gc.collect()","acf0c7cf":"print(f\"Shape of the Full Glomeruli Mask - {mask.shape}\")","5ce6c8d4":"## Identify all the coordinates of the glomeruli in this image\nlabelled = label(mask) \nprops = regionprops(labelled)\n\nprint(f\"Number of Glomeruli identified - {len(props)}\")","8ac7b89a":"bboxes = [] \nfor prop in props:\n    bboxes.append([prop.bbox[0] - 20, prop.bbox[1] - 20, \n                   prop.bbox[2] + 20, prop.bbox[3] + 20]) ## Adding a little bit of extra image run","0fbe89bf":"plt.figure(figsize=(10, 10))\nplt.imshow(image1[bboxes[0][0]:bboxes[0][2], bboxes[0][1]:bboxes[0][3], :])\nplt.imshow(mask[bboxes[0][0]:bboxes[0][2], bboxes[0][1]:bboxes[0][3]], alpha=0.5, cmap='viridis')\nplt.show()","55d98e19":"# SAVING RAM\ndel image1, props, labelled, bboxes\na = gc.collect()","cabcffed":"print(f\"Dice Coefficient of two same masks are {DICE_COE(mask, mask)}\")","b2742dda":"# We are just shifting the images towards the bottom to keep it simple\ndef return_shifted(mask, shift=5):\n    nmask = np.zeros((mask.shape[0]+shift, mask.shape[1]))\n    nmask[shift:, :] = mask\n    nmask = nmask[:-shift, :]\n    return nmask\n\n\nsh_mask = return_shifted(mask)","96ed8b38":"print(f\"The DICE COEFFICIENT of Same Masks shifted by 5 pixels is {DICE_COE(mask, sh_mask)}\")","5c169380":"# SAVING RAM\ndel sh_mask\na = gc.collect()","75eedd81":"for shift in [10,20,30]:\n    print(f\"The DICE COEFFICIENT of Same Masks shifted by {shift} pixels is {DICE_COE(mask, return_shifted(mask, shift=shift))}\")","3d519402":"for shift in [400,500,600]:\n    print(f\"The DICE COEFFICIENT of Same Masks shifted by {shift} pixels is {DICE_COE(mask, return_shifted(mask, shift=shift))}\")","17395e8f":"nums = list(range(1, 601, 15))\ndices  = []\nfor num in tqdm(nums):\n    dices.append(DICE_COE(mask, return_shifted(mask, shift=num)))","1ab2b87c":"plt.figure(figsize=(10, 10))\nplt.plot(nums, dices)\nplt.title('SHIFT VS DICE COEFFICIENT', size=20)\nplt.xlabel('Shift in Pixels', size=15)\nplt.ylabel('Dice coefficient', size=15)\n\nplt.show()","6ef02694":"Yes! You can obtain the answer by easy calculation\n\nLet the number of masked pixels be x . Then the intersection between the two images will also have x pixels.\n\n$\\huge \\frac{2\\cdot x }{x + x}  = 1.0$","b872d4ca":"Lets shift the mask a little, say 5 pixels and see the effect on the dice score","bcd5394c":"Converting the Properties to Bounding boxes","534cca70":"<div id=\"diceplot\"> <\/div>\n\nLets take a step further and plot a curve between shift and the Dice coefficient","538f4f53":"<div id=\"loaddataset\"> <\/div>\n\n### Loading Dataset","4de7d97f":"<div id=\"libimport\"> <\/div>\n\n### Import the libraries\n","e9f40fc9":"* As seen above, we need to calculate the intersection pixels in the masks. \n* Since our masks consist of just 0s and 1s, simple multiplication will leave us with intersection pixels","32a8c33f":"#### **We can clearly see how the Dice Coefficient Decreases as the shift increases and the masks are less overlapping with the true masks.**\n\nP.S - The Small increase in the end can be attributed to the fact that some masks might be overlapping with other true masks as the shift increases. ","bac06f65":"We can see that the score decreased!\n\n\nNow lets shift it more by 10 20 30 pixels","a83677ae":"Now lets try to calculate for big shifts like 400, 500 and 600","117d4551":"### References\n\n1. [HuBMAP - Visualize Mask & BBOX \ud83d\udcc8](https:\/\/www.kaggle.com\/ckanth090\/hubmap-visualize-mask-bbox)","a711a719":"### Table of Contents\n\n1. [Import libraries](#libimport)\n2. [Loading Dataset](#loaddatset)\n3. [Writing a Simple DICE Implementation](#simpledice)\n4. [Image and the Mask](#imagemask)\n5. [How Big are the Glomeruli Masks?](#glomersize)\n6. [Dice Coefficient Between same masks](#dicesame)\n7. [Dice Coefficient Between shifted masks](#diceshift)\n8. [Plot Between Dice Coefficient and Shift in masks](#diceplot)","dce0f2ce":"<div id=\"simpledice\"> <\/div>\n\n### Writing a Simple DICE Coefficient Implementation","eef0ccd1":"<div id=\"glomersize\"> <\/div>\n\n## How Big are the Glomeruli Masks?","f5371fb5":"####  SKIMAGE HANDY FUNCTIONS\n\n* LABEL [(skimage.measure.label)](https:\/\/scikit-image.org\/docs\/dev\/api\/skimage.measure.html#skimage.measure.label)\nThis finds the connected regions from the image array.\n\n* REGION PROPS [(skimage.measure.region_props)](https:\/\/scikit-image.org\/docs\/dev\/api\/skimage.measure.html#skimage.measure.regionprops)\nThis Finds the properties of the labeled array, here we are concerned about the bounding box of the mask.","58911436":"<div id=\"diceshift\"> <\/div>\n\n### DICE COEFFICIENT OF SHIFTED IMAGES","81ecf5db":"<div id=\"imagemask\"> <\/div>\n\n### Image and The Mask","7b854067":"## DICE COEFFICIENT\n\n* This competition is evaluated on the mean Dice coefficient. \n* The Dice coefficient can be used to compare the pixel-wise agreement between a predicted segmentation and its corresponding ground truth. \n* Dice coefficient is 2 times The area of Overlap divided by the total number of pixels in both the images\n\n![Dice coeff image](https:\/\/miro.medium.com\/max\/429\/1*yUd5ckecHjWZf6hGrdlwzA.png)\n\nThe formula is given by:\n\n<center> $ \\huge \\frac{2*|X\u2229Y|}{|X|+|Y|}$ <\/center>\n\n<br>\n\nwhere X is the predicted set of pixels and Y is the ground truth.\n* The Dice coefficient is defined to be 1 when both X and Y are empty. The leaderboard score is the mean of the Dice coefficients for each image in the test set.\n\n* [Here's](https:\/\/towardsdatascience.com\/metrics-to-evaluate-your-semantic-segmentation-model-6bcb99639aa2) an interesting article for further read!","cb93d188":"We can notice a few things - \n* The Mask is not perfectly positioned on the Glomeruli\n* The Mask is Approximately 400 pixels wide, we can understand the scale of the size of the other masks","1fca4ce0":"Visualizing one of the Bounding box","93d3ac2c":"<div id=\"dicesame\"> <\/div>\n\n### DICE COEFFICIENT BETWEEN SAME IMAGES\n\nWhat do you think will be the output in this case?"}}