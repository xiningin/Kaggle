{"cell_type":{"f00ba51c":"code","0e881358":"code","cc2f3d8e":"code","7ed25a3e":"code","990b22af":"code","7b0fbb14":"code","bd7cbf80":"code","31c46212":"code","b14fd90b":"code","4b86aea4":"code","7323758d":"markdown","04d02a2b":"markdown","88ca54a8":"markdown","5ce0f679":"markdown"},"source":{"f00ba51c":"#packages\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\npd.set_option('display.max_rows', None)\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","0e881358":"shopdf = pd.read_csv(\"\/kaggle\/input\/orderbrushing\/order_brush_order.csv\")\nshopdf.head()","cc2f3d8e":"#dropping order id because all of them are unique, making it unusable as a predictor\nprint(shopdf['orderid'].nunique() == len(shopdf))\nshopdf = shopdf.drop('orderid', axis=1)","7ed25a3e":"#converting time string to Timestamp object \nshopdf['event_time'] = pd.to_datetime(shopdf['event_time'])","990b22af":"def sus_checkv3(x):\n    #per shop\n    shop_user = []\n    abs_count = []\n    sus_id = 0\n    \n    #sort time\n    x = x.sort_values('event_time')\n    \n    #for each possible brush order hour\n    for timestamp in x['event_time']:\n        \n        #per timeframe\n        result_user = []\n        \n        #create a dataframe of orders occuring within 1 hour from the timestamp\n        subframe = x[(x['event_time'] >= timestamp) & (x['event_time'] <= (timestamp + timedelta(hours=1)))]\n        \n        #find number of unique users within that timeframe\n        unique_user = subframe['userid'].nunique()\n\n        if unique_user > 0:\n            conc_rate = len(subframe)\/unique_user\n        else:\n            conc_rate = 0\n        \n        #if that window exceeds concentration threshold\n        if conc_rate >= 3:\n            #ranking the highest proportion users\n            user_prop = subframe['userid'].value_counts()\n            #putting user_prop into a dataframe\n            user_frame = pd.DataFrame({'id': user_prop.index, 'count': user_prop.values})\n            nummax = user_prop.max()\n            \n            #selecting the userid(s) that have highest proportion\n            result_user = list(user_frame[user_frame['count'] == nummax]['id'])\n            shop_user.append(result_user)\n            abs_count.append(nummax)\n        \n    if len(abs_count) > 0:\n        \n        total_max = max(abs_count)\n\n        count_frame = pd.DataFrame({'id': shop_user, 'count':abs_count})\n        \n        #this series will contain both lists containing userids that are tied for highest proportion \n        #as well as single values of the same\n        sus_id = count_frame[count_frame['count'] == total_max]['id']\n        \n        sus_id_result = []\n        \n        #getting the list values out\n        for i in sus_id:\n            if type(i) is list:\n                for j in i:\n                    sus_id_result.append(j)\n            else:\n                sus_id_result.append(i)\n\n        return sus_id_result\n    \n    #handling for non-brusher shops\n    else:\n        return 0","7b0fbb14":"#application of above function\nsusdf = shopdf.groupby('shopid').apply(sus_checkv3)","bd7cbf80":"#formatting to follow submission rules\nuserid_col = []\nfor i in susdf.values:\n    if i != 0:\n        intermed_list = []\n        #sort list, convert all values into string and append unique values only\n        for i in [str(j) for j in sorted(i)]:\n            if i not in intermed_list:\n                intermed_list.append(i)\n        \n        #join with &\n        userid_col.append(\"&\".join(intermed_list))\n    else:\n        userid_col.append('0')","31c46212":"final_df = pd.DataFrame({'shopid': susdf.index, 'userid': userid_col})\nfinal_df.to_csv('submission_df.csv', index=False)","b14fd90b":"from IPython.display import Image\nImage(\"\/kaggle\/input\/eval-formulapng\/eval_formula.png\")","4b86aea4":"#number of unique shops\nlen_counter = []\nfor i in userid_col:\n    if i != '0':\n        len_counter.append(i)\nprint(\"Total number of unique suspicious shops found: \" + str(len(len_counter)))","7323758d":"We obtained a final score of <strong>0.89933<\/strong>. <br>\n\n<h3>Possible improvements<\/h3> <br>\nFrom the kaggle evaluations formula for this challenge, it can be calculated that there are 315 suspicious shopids. <br>","04d02a2b":"## Shopee Code League Week 1 \nBy: Gabriel Lewis and Jackie Chu","88ca54a8":"Our first improvement task is to discover the 39 suspicious shopids that we missed in our analysis","5ce0f679":"<h3>Task Summary:<\/h3> <br>\nWe first identified and dropped unhelpful columns like orderid. Next, we grouped the dataframe by shops, since the first part of the task was to detect shop that have conducted order brushing. For each shop, we iterated through each timestamp of each order, and created 'sub-frames' of orders that fit within an hour of the order in question. We subjected that window to the concentration rate test, and if threshold is met, we record the userid whose presence had the highest proportion in that window. We repeat for all timestamps in the shop, recording all highly represented userids of each window. After some formatting we end up with lists of userids that are suspected brushers for shops with suspicious 1h windows."}}