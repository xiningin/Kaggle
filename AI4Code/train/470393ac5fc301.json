{"cell_type":{"8632f5c2":"code","cf43f8fa":"code","ec20498d":"code","dbe1c8be":"code","d7dfec02":"code","3e733047":"code","bff614dd":"markdown","16e87267":"markdown","c07fd78f":"markdown","9f5bbdb4":"markdown"},"source":{"8632f5c2":"import pandas as pd\nimport numpy as np\n\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nsns.set_style(\"darkgrid\")\n%matplotlib inline","cf43f8fa":"objects = pd.DataFrame({\"Object name\": [\"chair\", \"desk\", \"shoe\", \"car\", \"person\"], \n                     \"Object coordinate\": [(2, 1), (1, 2), (-0.5, 1), (-1, -1), (5, -5)]})\nobjects[\"X-coordinate\"] = objects[\"Object coordinate\"].apply(lambda x: x[0])\nobjects[\"Y-coordinate\"] = objects[\"Object coordinate\"].apply(lambda x: x[1])\nprint(objects)","ec20498d":"fig = plt.gcf()\nfig.set_size_inches(8, 8)\nsns.scatterplot(x=\"X-coordinate\", y=\"Y-coordinate\", hue=\"Object name\", data=objects)\nplt.title(\"Object Coordinates\")","dbe1c8be":"def euclidean_distance(x1, y1, x2, y2):\n    \"\"\"\n    Calculates the euclidean distance between two points.\n    :param x1: x-coordinate of first point\n    :param y1: y-coordinate of first point\n    :param x2: x-coordinate of second point\n    :param y2: y-coordinate of second point\n    :return: euclidean distance between points\n    \"\"\"\n    return np.sqrt((x2-x1)**2 + (y2-y1)**2)\n\ndef distances(x, y, data):\n    \"\"\"\n    Returns euclidean distances of inputted object coordinates and\n    all other objects in the inputted data.\n    :param x: x-coordinate of object\n    :param y: y-coordinate of object\n    :param data: dataframe of objects\n    :return: list of distances between objects\n    \"\"\"\n    data[\"Distances\"] = euclidean_distance(x, y, data[\"X-coordinate\"], data[\"Y-coordinate\"])\n    temp = data.sort_values(by=\"Distances\")\n    return [list(l) for l in zip(temp[\"Object name\"], temp[\"Distances\"])]\n\n\nchair = distances(2, 1, objects)\n\ndesk = distances(1, 2, objects)\n\nshoe = distances(-0.5, 1, objects)\n\ncar = distances(-1, -1, objects)\n\nperson = distances(5, -5, objects)\n\nprint(\"chair: \" + str(chair))\nprint(\"desk: \" + str(desk))\nprint(\"shoe: \" + str(shoe))\nprint(\"car: \" + str(car))\nprint(\"person: \" + str(person))","d7dfec02":"def bitvector(data):\n    \"\"\"\n    Returns a series of each object's bitvector representation within\n    the inputted data.\n    :param data: dataframe of objects\n    :return: series of bitvectors\n    \"\"\"\n    def transform_x(x):\n        if x < 0:\n            return \"0\"\n        else:\n            return \"1\"\n        \n    def transform_y(y):\n        if y < 0:\n            return \"0\"\n        else:\n            return \"1\"\n    \n    x_bit = objects[\"X-coordinate\"].apply(transform_x)\n    y_bit = objects[\"Y-coordinate\"].apply(transform_y)\n    bitvector_representations = x_bit + y_bit\n    data[\"Bitvector\"] = bitvector_representations\n    bitvector_representations.index = data[\"Object name\"]\n    return bitvector_representations\n\nbitvector(objects)","3e733047":"def hamming_distances(object_bit, data):\n    \"\"\"\n    Returns hamming distances between inputted object's bitvector and\n    the bitvectors of the objects in the inputted data.\n    :param object_bit: bitvector of object\n    :param data: dataframe of objects\n    :return: list of hamming distances\n    \"\"\"\n    def hamming(other_bit):\n        return sum(object_bit[i] != other_bit[i] for i in range(len(object_bit)))\n    data[\"Hamming distance\"] = data[\"Bitvector\"].apply(hamming)\n    temp = data.sort_values(by=\"Hamming distance\")\n    return [list(l) for l in zip(temp[\"Object name\"], temp[\"Hamming distance\"])]\n   \n\nchair = hamming_distances(\"11\", objects)\n\ndesk = hamming_distances(\"11\", objects)\n\nshoe = hamming_distances(\"01\", objects)\n\ncar = hamming_distances(\"00\", objects)\n\nperson = hamming_distances(\"10\", objects)\n\nprint(\"chair: \" + str(chair))\nprint(\"desk: \" + str(desk))\nprint(\"shoe: \" + str(shoe))\nprint(\"car: \" + str(car))\nprint(\"person: \" + str(person))","bff614dd":"##### Chair\nFor chair, the rankings were the same except for car and person, where person is farther in terms of euclidean disance and closer in terms of hamming distance. It can be observed from the visualization above that person indeed has a farther linear distance from chair, but is only 1 quadrant away, where as car has a smaller linear distance but is 2 quadrants away.\n\n##### Desk\nDesk is the same as chair described above, with all rankings being the same besides car and person. Car is farther in terms of hamming distance and closer in terms of euclidean distance.\n\n##### Shoe\nShoe has the exact same ranking for euclidean and hamming distance. The only thing to note is that chair, desk, and car have the exact same hamming distance, 1, to shoe, but have different euclidean distances.\n\n##### Car\nCar's hamming distance ranking deviated a little from its euclidean distance ranking for person. Based on euclidean distance, person is the farthest from car, but is in the middle for hamming distance. Other objects' rankings remain consistent. It can also be observed that person is 1 quadrant away from car and chair and desk are 2 quadrants away.\n\n##### Person\nPerson has the exact same ranking for euclidean and hamming distance. The only thing to note is that chair, desk, and car have the exact same hamming distance, 1, to person, but have different euclidean distances.","16e87267":"### Importing Packages","c07fd78f":"### Data","9f5bbdb4":"The advantage of using a bitvector representation of an object lies in the simple way of denoting which quadrant each object is, based on the bits. For example, \"11\" would be in quadrant 1, \"01\" would be in quadrant 2, \"00\" would be in quadrant 3, and \"01\" would be in quadrant 4. With this, it is easier to identify clustering and approximate locations of objects, rather than looking at a set of coordinate points. \n\nWhen calculating the distances between the objects as done above, it is much easier to interpret a hamming difference than an euclidean distance. The hamming difference represents how many quadrants apart two bitvectors are. This information cannot easily be determined by looking at euclidean distances. \n\nIn general, using bitvector representation of objects has the advantage of grouping or clustering all the objects together based on location in quadrants. It is a simple representation of the sparsity of the objects. Nevertheless, caution should still be used with a simple bitvector representation like the one used above."}}