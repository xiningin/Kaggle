{"cell_type":{"5b16d180":"code","70665bf6":"code","2c716f0f":"code","5e1d348a":"code","f1677233":"code","1b5c16e7":"code","efd177c3":"code","001597a0":"code","d8a4cbf6":"code","b836b6e9":"code","aa00ad12":"code","9ea002b0":"code","382751a2":"code","0842d3b6":"code","13b018fc":"code","421ec5d3":"code","a85c2cff":"code","d969672a":"markdown","fe7fca9f":"markdown","1222edb4":"markdown","2c5bd38f":"markdown","0eddba33":"markdown","3ac975be":"markdown","2394dc12":"markdown","c7216cff":"markdown","fe2528b9":"markdown","574ba94f":"markdown","8edb224f":"markdown","dee83a95":"markdown","5b63137e":"markdown"},"source":{"5b16d180":"import torch\nimport torch.nn as nn\nimport torch.nn.functional as f\n\nimport torchvision\nimport torchvision.datasets\n\nimport numpy as np\nimport matplotlib.pyplot as plt","70665bf6":"transforms = torchvision.transforms.Compose([\n    torchvision.transforms.Resize(256),\n    torchvision.transforms.CenterCrop(224),\n    torchvision.transforms.ToTensor(),\n    torchvision.transforms.ColorJitter()\n])","2c716f0f":"trainset = torchvision.datasets.ImageFolder(\"..\/input\/100-bird-species\/train\", transform = transforms)\nvalidset = torchvision.datasets.ImageFolder(\"..\/input\/100-bird-species\/valid\", transform = transforms)\ntestset = torchvision.datasets.ImageFolder(\"..\/input\/100-bird-species\/test\", transform = transforms)","5e1d348a":"batch_size = 20","f1677233":"trainloader = torch.utils.data.DataLoader(trainset , batch_size=batch_size , shuffle = True)\nvalidloader = torch.utils.data.DataLoader(validset , batch_size=batch_size , shuffle = True)\ntestloader  = torch.utils.data.DataLoader(testset  , batch_size=batch_size)","1b5c16e7":"images, labels = iter(trainloader).next()\nimages, labels = images.numpy() , labels.numpy()\n\nfig = plt.figure(figsize = (15,5))\n\nfor i in range(batch_size):\n  ax = fig.add_subplot(2 , batch_size\/2 , i + 1 , xticks = [] , yticks = [])\n  ax.imshow(np.transpose(images[i] , (2,1,0)) , cmap = 'gray')\n  ax.set_title(labels[i])","efd177c3":"# Single batch\nprint(\"Size of trainingset : \", len(trainloader))\nprint(\"Size of validset    : \", len(validloader))\nprint(\"Size of testset     : \", len(testloader))","001597a0":"print(\"Classes : \", trainset.classes)","d8a4cbf6":"!nvidia-smi","b836b6e9":"model = torchvision.models.resnet50(pretrained = True)# Use ResNet 50\nfor param in model.parameters():\n  param = param.requires_grad_(False)\nmodel.fc = nn.Linear(model.fc.in_features ,len(trainset.classes))\nprint(\"The new fully connected layer is : \",model.fc)\nmodel.cuda() #Moving the model to GPU","aa00ad12":"import torch.optim as optim\n\nlr = 3e-3\ncriterion = nn.CrossEntropyLoss().cuda()\noptimizer = optim.SGD(model.parameters() , lr = lr , momentum=0.9)","9ea002b0":"epochs = 1\nprint_every = 30\nmin_valid_loss = np.inf\ntrainloss = []\nvalidloss = []\n\nfor i in range(epochs):\n    train_loss = 0.0\n    valid_loss = 0.0\n    \n    model.train()\n    for batch_i, (images, target) in enumerate(trainloader):\n        images = images.cuda()\n        target = target.cuda()\n        \n        optimizer.zero_grad()\n        output = model(images) \n        loss = criterion(output, target)\n        loss.backward()\n        optimizer.step()\n        \n        train_loss = train_loss + ((1\/(batch_i+1)) * (loss.data - train_loss))\n        trainloss.append(train_loss)\n        \n    model.eval()\n    for batch_i, (images, target) in enumerate(validloader):\n        images = images.cuda()\n        target = target.cuda()\n        \n        optimizer.zero_grad()\n        output = model(images) \n        loss = criterion(output, target)\n        loss.backward()\n        optimizer.step()\n        \n        valid_loss = valid_loss + ((1\/(batch_i+1)) * (loss.data - valid_loss))\n        validloss.append(valid_loss)\n        \n    print(\"Epoch: {}, Batch: {}, Training Loss: {}, Vaildation Loss: {}\".format(i+1, batch_i+1, train_loss, valid_loss))\n    \n    if valid_loss < min_valid_loss:\n        torch.save(model.state_dict(), \"birds.pt\")\n        print(\"Validation Loss Change from {} ---> {}\".format(min_valid_loss, valid_loss))\n        min_valid_loss = valid_loss\n    ","382751a2":"plt.plot(trainloss)","0842d3b6":"def test(loaders, model, criterion, use_cuda  = True):\n\n    # monitor test loss and accuracy\n    test_loss = 0.\n    correct = 0.\n    total = 0.\n\n    model.eval()\n    for batch_idx, (data, target) in enumerate(loaders):\n        # move to GPU\n        if use_cuda:\n            data, target = data.cuda(), target.cuda()\n        # forward pass: compute predicted outputs by passing inputs to the model\n        output = model(data)\n        # calculate the loss\n        loss = criterion(output, target)\n        # update average test loss \n        test_loss = test_loss + ((1 \/ (batch_idx + 1)) * (loss.data - test_loss))\n        # convert output probabilities to predicted class\n        pred = output.data.max(1, keepdim=True)[1]\n        # compare predictions to true label\n        correct += np.sum(np.squeeze(pred.eq(target.data.view_as(pred))).cpu().numpy())\n        total += data.size(0)\n            \n    print('Test Loss: {:.6f}\\n'.format(test_loss))\n\n    print('\\nTest Accuracy: %2d%% (%2d\/%2d)' % (\n        100. * correct \/ total, correct, total))","13b018fc":"test(testloader , model , criterion)","421ec5d3":"dataiter = iter(testloader)\nimages, labels = dataiter.next()\n# get predictions\npreds = np.squeeze(model(images.cuda()).data.max(1, keepdim=True)[1].cpu().numpy())\nimages = images.cpu().numpy()\n\n# plot the images in the batch, along with predicted and true labels\nfig = plt.figure(figsize=(25, 4))\nfor idx in np.arange(batch_size):\n    ax = fig.add_subplot(2, batch_size\/2, idx+1, xticks=[], yticks=[])\n    ax.imshow(np.squeeze(images[idx].transpose(1,2,0)), cmap='gray')\n    ax.set_title(\"{} ({})\".format(trainset.classes[preds[idx]], trainset.classes[labels[idx]]),\n                 color=(\"green\" if preds[idx]==labels[idx] else \"red\"))\nplt.tight_layout()","a85c2cff":"import time\ndataiter = iter(testloader)\nimages, labels = dataiter.next()\n# get predictions\nstart = time.time()\npreds = np.squeeze(model(images.cuda()).data.max(1, keepdim=True)[1].cpu().numpy())\nend = time.time()\nprint(\"Inference time : {} ms\" .format((end - start)*1000))","d969672a":"### Test Accuracy","fe7fca9f":"### Define the DataLoader","1222edb4":"### Import Libraries","2c5bd38f":"### Inference Time","0eddba33":"### Define the training loop","3ac975be":"### Visualize the Dataset","2394dc12":"### Define the Optimizer and Loss functions","c7216cff":"# Transfer Learning Tutorial","fe2528b9":"### Look at the available GPU","574ba94f":"### Loads the datasets","8edb224f":"### Define the model","dee83a95":"### Define the batchsize","5b63137e":"### Compose Transforms"}}