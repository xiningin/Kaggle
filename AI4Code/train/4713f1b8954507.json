{"cell_type":{"49436f5c":"code","352eb0f7":"code","ddf75eff":"code","c4a1d32f":"code","f5d8f8df":"code","64ff61d8":"code","7a6395c6":"code","aa366d3b":"code","e0c8d856":"code","48bdc1b3":"code","356e25d0":"code","24ae6906":"code","e921364c":"code","a83d4f23":"code","e7ad1436":"code","3afef145":"code","43232ee4":"code","9ae4101c":"code","4bdcd00e":"code","783fb6f3":"code","ce9d8531":"code","9e70a671":"code","4f3bf58e":"code","7e71083f":"code","5de9a4ca":"code","8d305025":"code","6a8fe930":"code","7f7ead71":"code","c4cffdf9":"code","43e452e2":"code","84dbc00f":"code","50613084":"code","f2c21e9d":"code","2ea4491c":"code","d5df3130":"code","3cb86d30":"code","cdfc13ba":"code","7b1fe473":"code","13a11aaf":"code","5de2c8df":"code","d840eebd":"code","e37bb993":"code","d93e8a03":"code","cf7c186a":"code","ef8ac921":"code","a1d8dff9":"code","dc709b93":"markdown","ca7887cb":"markdown"},"source":{"49436f5c":"\nimport pandas as pd\nfrom pandas.plotting import lag_plot\nfrom pandas.plotting import autocorrelation_plot\nimport numpy as np\nimport scipy as sp\nfrom matplotlib import pyplot\nimport matplotlib.pyplot as plt\nfrom datetime import datetime\nfrom dateutil.rrule import rrule, DAILY\nfrom scipy.stats import mstats\n\nimport statsmodels.tsa as ts\nfrom statsmodels.tsa.api import VAR\nfrom statsmodels.tsa.api import VARMAX\nfrom statsmodels.tsa.api import VECM\nfrom statsmodels.tsa.api import ARIMA\nfrom statsmodels.tsa.vector_ar.vecm import coint_johansen\nfrom statsmodels.tsa.vector_ar.vecm import select_coint_rank\nfrom statsmodels.tsa.stattools import adfuller\nfrom statsmodels.tools.eval_measures import rmse, aic\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nfrom statsmodels.graphics.tsaplots import plot_acf\nimport statsmodels.tsa.stattools as stt\n\n\n\n","352eb0f7":"!ls","ddf75eff":"########## reading the data and preprocessing for current problem#################\ninputData=pd.read_csv('inputDataProcessed.csv', encoding=\"ISO-8859-1\")\n\ninputData.head()\n","c4a1d32f":"n = len(pd.unique(inputData['Store']))\nprint(n)\n\ni = 9","f5d8f8df":"# plot sales data\nstoreDataAll=inputData.loc[inputData[\"Store\"]==i]\nstoreDataAll=storeDataAll.reset_index(drop=True)\n    ","64ff61d8":"# Create figure and plot space\n        \nplt.plot( storeDataAll.iloc[0:250,1],storeDataAll.iloc[0:250,2])\n        ","7a6395c6":"\nplt.scatter(storeDataAll['Sales'],storeDataAll['Customers'])","aa366d3b":"plt.scatter(storeDataAll['Customers'], storeDataAll['Sales'])","e0c8d856":"#cap sales Data\ntransformed_test_data1 = pd.Series(mstats.winsorize(storeDataAll['Sales'], limits=[0.05, 0.05])) \ntransformed_test_data1.plot()   ","48bdc1b3":"# In[28]:\n\n\ntransformed_test_data2 = pd.Series(mstats.winsorize(storeDataAll['Customers'], limits=[0.05, 0.05])) \ntransformed_test_data2.plot()\n\n","356e25d0":"# get transformed values\nstoreDataAll.iloc[:,2]=transformed_test_data1.values\nstoreDataAll.iloc[:,3]=transformed_test_data2.values\n","24ae6906":"storeDataAll.head()","e921364c":"\n################# get seasonality and trend ##########################\n##### change codde to include search for best sesonality using freq#############\n    \nresult = seasonal_decompose((storeDataAll.iloc[:,2]), model='additive', freq=365, extrapolate_trend='freq')\nresult.plot()","a83d4f23":"#plot_acf(storeDataAll.iloc[:,2])\n\n\n","e7ad1436":"print(result.resid.mean())","3afef145":"storeDataAll[\"SalesSeasonality\"]=result.seasonal\nstoreDataAll[\"SalesTrend\"]=result.trend\n","43232ee4":"################# get seasonality and trend ##########################\n##### change codde to include search for best sesonality using freq#############\nresult = seasonal_decompose((storeDataAll.iloc[:,3]), model='additive', freq=365, extrapolate_trend='freq')\nresult.plot()\nprint(result.resid.mean())\n#plot_acf(storeDataAll.iloc[:,3])\nstoreDataAll[\"CustSeasonality\"]=result.seasonal\nstoreDataAll[\"CustTrend\"]=result.trend\n    \n    ","9ae4101c":"###### split data into train and test #########################################\nstoreOneData, TestData=storeDataAll[:-100], storeDataAll[-100:]\n\n\nstoreOneData.shape, TestData.shape\n\n   ","4bdcd00e":"#################### causality test####################################\n## null hypothesis is: x does not granger cause y #####################\n## if value of p is less than 0.05 then granger causality exists ######\n    \nCausalitySales=(ts.stattools.grangercausalitytests(storeOneData[['Sales','Customers']].dropna(),1))\n#print(CausalitySales)\nCausalityCust=(ts.stattools.grangercausalitytests(storeOneData[['Customers','Sales']].dropna(),1))\n#print(CausalityCust)","783fb6f3":"####################### stationarity ##################################\n## null hypothesis is there is nonstationarity ########################\n## if p<0.05 then series is staionary no differencing reqd ############\n\nstation=adfuller(storeOneData.iloc[:,2], autolag='AIC')\nprint('ADF Statistic: %f' % station[0])\nprint('p-value: %f' % station[1])\n","ce9d8531":"if station[4]['5%'] < station[0]:\n    stationDIF=adfuller(storeOneData.iloc[:,3].diff().dropna(), autolag='AIC')\n    print('ADF Statistic DIFF: %f' % stationDIF[0])\n    print('p-value DIFF: %f' % stationDIF[1])\n\nprint(station)","9e70a671":"####################### stationarity ##################################\n## null hypothesis is there is nonstationarity ########################\n## if p<0.05 then series is staionary no differencing reqd ############\n\nstation=adfuller(storeOneData.iloc[:,3], autolag='AIC')\nprint('ADF Statistic: %f' % station[0])\nprint('p-value: %f' % station[1])","4f3bf58e":"if station[4]['5%'] < station[0]:\n    stationDIF=adfuller(storeOneData.iloc[:,3].diff().dropna(), autolag='AIC')\n    print('ADF Statistic DIFF: %f' % stationDIF[0])\n    print('p-value DIFF: %f' % stationDIF[1])\n\nprint(station)\n","7e71083f":"# define endogenous and exogenous variables\n\nendog=storeOneData[['Sales', 'Customers']].astype('float32')\n    \nexog= storeOneData[['Promo', 'SchoolHoliday',\n                        'DayOfWeek_1', 'DayOfWeek_2', 'DayOfWeek_3',\n                        'DayOfWeek_4','DayOfWeek_5', 'DayOfWeek_6', 'DayOfWeek_0', 'SalesSeasonality',\n                        'SalesTrend', 'CustSeasonality', 'CustTrend']]\nexog= exog.astype('float32')\nendog=endog.astype('float32')\n        ","5de9a4ca":"# get the differenced series if required\n\nendogdif1=endog.diff().dropna()\nexogdif1=exog.diff().dropna()\n\nendogdif11=endog.iloc[:,0].diff().dropna()\nendogdif1.iloc[:,0]=endogdif11.values\n\nendogdif12=endog.iloc[:,1].diff().dropna()\nendogdif1.iloc[:,1]=endogdif12.values\n","8d305025":"#TestDatadif1=TestData.diff().dropna()","6a8fe930":"#################### cointegration Analysis if required###################################\n## null hypothesis is that there is no cointegration ##########################\n## to be tested if ADF test says non-stationarity #############################\n\ncoint=coint_johansen(endogdif1,0,1)\ncoint.trace_stat\ncoint.max_eig_stat\ntraces = coint.lr1\nmaxeig=coint.lr2\ncvts = coint.cvt  ## 0: 90%  1:95% 2: 99%\ncvms = coint.cvm   ## 0: 90%  1:95% 2: 99%\n","7f7ead71":"N, l = endogdif1.shape\n\nfor i in range(l):\n    if traces[i] > cvts[i, 1]:\n        r = i + 1\nprint(r)\n","c4cffdf9":"rank=select_coint_rank(endogdif1,0,1)\nprint(rank.rank)\n#result=stt.coint(endog['Sales'], endog['Customers'])\n","43e452e2":"#mod = VECM(endogdif1, exog=exogdif1) #endogdif1, exogdif1 \n#res = mod.fit() #maxiter=500, disp=False\n#res.hessian()\n#print(res.summary())\n\n","84dbc00f":"# specify VAR model at levels\nmod = VAR(endogdif1, exog=exogdif1) #, order=(2,0,0)\n\naa=mod.select_order()\naa.summary\nprint(aa.aic)\nres=mod.fit(maxlags=aa.aic, ic='aic')\nlag_order = res.k_ar\nres.summary()","50613084":"# specify VARMAX model\n\nmod = VARMAX(endogdif1, exog=exogdif1,order=(18,0), trend='n') #endogdif1, exogdif1 \nres = mod.fit(maxiter=100, disp=False) #maxiter=500, disp=False\n#res.hessian()\nprint(res.summary())\nprint(res.params)\n\n","f2c21e9d":"# get impulse response functions\nirf=res.impulse_responses(steps=100, orthogonalized=False)\nirf.plot()\n#res.plot_diagnostics(figsize=(16, 8))\n","2ea4491c":"# forecast and get the accuracy of the forecast for differenced series\n\nforecast_input = endogdif1.values[-lag_order:]\n","d5df3130":"exogdif1","3cb86d30":"forcast=res.forecast(y=forecast_input, steps=678, exog_future=exogdif1)\n\n\nforcast=pd.DataFrame(forcast)\nforcast.head()\nforcast.iloc[:,0].plot()","cdfc13ba":"actual=endogdif1[[\"Sales\"]]","7b1fe473":"actual.columns=['ActualSales']\nactual=actual.reset_index(drop=True)\npredicted=forcast.iloc[:,0]\npredicted=predicted.reset_index(drop=True)\npred=pd.merge(actual, predicted, right_index=True, left_index=True)\npred = pred[pred.ActualSales != 0]\n","13a11aaf":"pred.columns=['ActualSales', 'Sales']\npred.head()\n","5de2c8df":"# plot\npyplot.plot(actual)\npyplot.plot(predicted, color='red')\npyplot.show()\n","d840eebd":"MPE=np.mean((pred.ActualSales-pred.Sales)\/(pred.ActualSales))\nprint(MPE)\n\nMAPE=np.mean(abs(pred.ActualSales-pred.Sales)\/(pred.ActualSales))\nprint(MAPE)\n","e37bb993":"\n# forecast and get the accuracy of the forecast\nforcast=res.forecast(steps=len(endog), exog=exog)\n#forcast.iloc[:,0].plot()\n","d93e8a03":"actual=endog[[\"Sales\"]]","cf7c186a":"actual.columns=['ActualSales']\nactual=actual.reset_index(drop=True)\npredicted=forcast[['Sales']]\npredicted=predicted.reset_index(drop=True)\npred=pd.merge(actual, predicted, right_index=True, left_index=True)\npred = pred[pred.ActualSales != 0]","ef8ac921":"\n# plot\npyplot.plot(actual)\npyplot.plot(predicted, color='red')\npyplot.show()\n","a1d8dff9":"MPE=np.mean((pred.ActualSales-pred.Sales)\/(pred.ActualSales))\nprint(MPE)\n\nMAPE=np.mean(abs(pred.ActualSales-pred.Sales)\/(pred.ActualSales))\nprint(MAPE)","dc709b93":"# Customer","ca7887cb":"# Sales"}}