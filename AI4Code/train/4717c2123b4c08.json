{"cell_type":{"763c00c2":"code","38baa404":"code","02d117d0":"code","4ccf32d6":"code","117dede8":"code","dff7897d":"code","7b967918":"code","53c7f20c":"code","681253fa":"code","c355d594":"code","17a25a20":"code","104e9b5b":"markdown","aa7a9536":"markdown","5f2a8417":"markdown","ff15623f":"markdown","296c70e2":"markdown"},"source":{"763c00c2":"import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom enum import Enum\nfrom tqdm import tqdm\nfrom typing import Union, List, Callable\nfrom functools import lru_cache\nfrom collections import defaultdict\nfrom dataclasses import dataclass\n\nnp.random.seed(12)","38baa404":"# define some models and functions\n\nclass Orientation(Enum):\n    Horizontal = 0\n    Vertical = 1\n    Combined = 2\n\n    def __repr__(self):\n        return self.name\n\n    def __str__(self):\n        return self.__repr__()\n\n\n@dataclass\nclass Photo:\n    id: Union[int, tuple]\n    tags: set\n    orientation: Orientation\n\n    @classmethod\n    def from_string(cls, id: int, line: str) -> \"Photo\":\n        orient, _, *tags = line.strip().split()\n\n        if orient == \"V\":\n            orient = Orientation.Vertical\n        elif orient == \"H\":\n            orient = Orientation.Horizontal\n        else:\n            raise ValueError(\"Unknown orientation: '{}'.\".format(orient))\n\n        return Photo(id=id, tags=set(tags), orientation=orient)\n\n    def __len__(self):\n        return len(self.tags)\n\n    def __and__(self, other):\n        return len(self.tags & other.tags)\n\n    def __sub__(self, other):\n        return len(self.tags - other.tags)\n\n    def __or__(self, other):\n        assert self.orientation == Orientation.Vertical and other.orientation == Orientation.Vertical\n\n        return Photo(\n            id=(self.id, other.id),\n            tags=self.tags | other.tags,\n            orientation=Orientation.Combined,\n        )\n\n    def __hash__(self):\n        return hash(self.id)\n    \n    def max_score(self) -> int:\n        return len(self) \/\/ 2\n\n\ndef calc_score(p1: Photo, p2: Photo) -> int:\n    return min(p1 & p2, p1 - p2, p2 - p1)\n\n\n@lru_cache(maxsize=2**20)\ndef lazy_calc_score(p1: Photo, p2: Photo) -> int:\n    return calc_score(p1, p2)\n\n\ndef calc_max_score(p1: Photo, p2: Photo) -> int:\n    return min(len(p1), len(p2)) \/\/ 2\n\n\ndef calc_lost_score(p1: Photo, p2: Photo) -> int:\n    return p1.max_score() + p2.max_score() - 2 * calc_score(p1, p2)\n\n\ndef _apply(sequence: List[Photo], function: Callable[[Photo, Photo], int]) -> int:\n    if len(sequence) <= 1:\n        return 0\n    return sum(function(sequence[i], sequence[i - 1]) for i in range(1, len(sequence)))\n\n\ndef sequence_score(sequence: List[Photo]) -> int:\n    return _apply(sequence, calc_score)\n\n    \ndef sequence_max_score(sequence: List[Photo]) -> int:\n    return _apply(sequence, calc_max_score)\n\n \ndef sequence_lost_score(sequence: List[Photo]) -> int:\n    return _apply(sequence, calc_lost_score)\n\n\ndef read_file(path: str) -> List[Photo]:\n    data = []\n    with open(path, \"r\") as file:\n        num_photo = int(file.readline())\n        for i, line in enumerate(file):\n            data.append(Photo.from_string(i, line))\n    return data\n\n\ndef check_sequence(sequence: List[Photo]):\n    all_id = set()\n    for photo in sequence:\n        photo_id = photo.id\n        assert isinstance(photo_id, (int, tuple)), f\"Wrong id format: {photo_id}\"\n\n        if isinstance(photo_id, tuple):\n            assert len(photo.id) == 2, f\"Wrong id format: {photo_id}\"\n            assert photo_id[0] != photo_id[1], f\"Wrong id format: {photo_id}\"\n        else:\n            photo_id = (photo_id,)\n\n        for x in photo_id:\n            assert x not in all_id, f\"id {x} not unique\"\n            all_id.add(x)\n\n            \ndef create_submission(submission: List[Photo], path=\"submission.txt\"):\n    check_sequence(submission)\n    with open(path, \"w+\") as f:\n        f.write(\"{}\\n\".format(len(submission)))\n        for photo in submission:\n            photo_id = photo.id\n            if not isinstance(photo_id, tuple):\n                photo_id = (photo_id,)\n            f.write(\"{}\\n\".format(\" \".join(map(str, photo_id))))\n            \n\ndef show(submission: List[Photo]):\n    total_score, total_max_score = [], []\n    p1 = submission[0]\n    for p2 in submission[1:]:\n        total_score.append(calc_score(p1, p2))\n        total_max_score.append(calc_max_score(p1, p2))\n        p1 = p2\n        \n    print(\"Total score: {}\/{}\".format(sum(total_score), sum(total_max_score)))\n\n    # slide size distribution\n    horizontal_hist, vertical_hist = defaultdict(int), defaultdict(int)\n    for photo in submission:\n        is_vertical = isinstance(photo.id, tuple)\n        hist = vertical_hist if is_vertical else horizontal_hist\n        hist[len(photo)] += 1\n    fig = plt.figure(figsize=(14,4))\n    plt.bar(horizontal_hist.keys(), horizontal_hist.values(), label=\"horizontal\", alpha=0.5)\n    plt.bar(vertical_hist.keys(), vertical_hist.values(), label=\"vertical\", alpha=0.5)\n    plt.xlabel(\"number of tags\"); plt.ylabel(\"number of slides\"); plt.legend(); plt.show()\n    \n    # score\n    fig = plt.figure(figsize=(14,4))\n    plt.plot(total_score, label=\"score\", alpha=0.5)\n    plt.plot(total_max_score, label=\"max score\", alpha=0.5)\n    plt.xlabel(\"slide\"); plt.ylabel(\"score\"); plt.legend(); plt.show()\n\n    # number of slides\n    nb_horizontal, nb_vertical = [0], [0]\n    for photo in submission:\n        is_vertical = isinstance(photo.id, tuple)\n        nb_horizontal.append(nb_horizontal[-1] + (not is_vertical))\n        nb_vertical.append(nb_vertical[-1] + is_vertical)\n    fig = plt.figure(figsize=(14,4))\n    plt.plot(nb_horizontal, label=\"horizontal\", alpha=0.5)\n    plt.plot(nb_vertical, label=\"vertical\", alpha=0.5)\n    plt.xlabel(\"slide\"); plt.ylabel(\"number of slides\"); plt.legend(); plt.show()\n\n    # loss\n    horizontal_loss, vertical_loss = [0], [0]\n    for score, max_score, photo in zip(total_score, total_max_score, submission):\n        is_vertical = isinstance(photo.id, tuple)\n        loss = max_score - score\n        horizontal_loss.append(horizontal_loss[-1] + loss * (not is_vertical))\n        vertical_loss.append(vertical_loss[-1] + loss * is_vertical)\n    fig = plt.figure(figsize=(14,4))\n    plt.plot(horizontal_loss, label=\"horizontal\", alpha=0.5)\n    plt.plot(vertical_loss, label=\"vertical\", alpha=0.5)\n    plt.plot([sum(x) for x in zip(horizontal_loss, vertical_loss)], label=\"total\", alpha=0.5)\n    plt.xlabel(\"slide\"); plt.ylabel(\"loss\"); plt.legend(); plt.show()","02d117d0":"data = read_file(path=\"..\/input\/hashcode-photo-slideshow\/d_pet_pictures.txt\")\nprint(f\"Score = {sequence_score(data)} \/ {sequence_max_score(data)}\")","4ccf32d6":"def stitch(sequences, th=1):\n    \"\"\" trying to connect two different sequences \"\"\"\n    if len(sequences) <= 1:\n        return sequences\n    \n    if th == 0:\n        return [sum(sequences, [])]\n    \n    for i, j in itertools.combinations(range(len(sequences)), r=2):\n        s1, s2 = sequences[i], sequences[j]\n\n        if not s1 or not s2:\n            continue\n\n        if lazy_calc_score(s1[-1], s2[0]) >= th:\n            sequences[i], sequences[j] = [], s1 + s2\n            continue\n\n        if lazy_calc_score(s1[-1], s2[-1]) >= th:\n            sequences[i], sequences[j] = [], s1 + s2[::-1]\n            continue\n\n        if lazy_calc_score(s1[0], s2[0]) >= th:\n            sequences[i], sequences[j] = [], s1[::-1] + s2\n            continue\n\n        if lazy_calc_score(s1[0], s2[-1]) >= th:\n            sequences[i], sequences[j] = [], s1[::-1] + s2[::-1]\n            continue\n                \n    return [s for s in sequences if s]\n\n\n\ndef _do_insert(s1, s2, th):\n    \"\"\" trying to insert sequence 1 into sequence 2 \"\"\"\n    if not s1 or len(s2) <= 1:\n        return False, s2\n    \n    for i, p2 in enumerate(s2[1:], start=1):\n        p1 = s2[i - 1]\n        \n        if lazy_calc_score(p1, s1[0]) + lazy_calc_score(s1[-1], p2) >= 2 * th:\n            return True, s2[:i] + s1 + s2[i:]\n\n        if lazy_calc_score(p1, s1[-1]) + lazy_calc_score(s1[0], p2) >= 2 * th:\n            return True, s2[:i] + s1[::-1] + s2[i:]\n        \n    return False, s2\n\n\n\ndef insert(sequences, th):\n    if len(sequences) <= 1:\n        return sequences\n    \n    for i, j in itertools.product(range(len(sequences)), repeat=2):\n        if i != j:\n            status, combined_sequence = _do_insert(sequences[i], sequences[j], th=th)\n            if status:\n                sequences[i], sequences[j] = [], combined_sequence\n    \n    return [s for s in sequences if s]\n\n\n\ndef _do_shuffle(s1, s2, th=1, p=1):\n    \"\"\" trying to swap some subsequence from sequence 1 and sequence 2 \"\"\"\n    if not s1 or len(s2) <= 1:\n        return s1, s2\n    \n    for i, p2 in enumerate(s2[1:], start=1):\n        p1 = s2[i - 1]\n\n        if lazy_calc_score(p1, s1[0]) >= th:\n            if np.random.random_sample() < p:\n                return s2[:i] + s1, s2[i:]\n\n        if lazy_calc_score(p1, s1[-1]) >= th:\n            if np.random.random_sample() < p:\n                return s2[:i] + s1[::-1], s2[i:]\n    \n    return s1, s2\n\n\n\ndef shuffle(sequences, th=1, p=1):\n    if len(sequences) <= 1 or p == 0:\n        return sequences\n    \n    for i, j in itertools.product(range(len(sequences)), repeat=2):\n        if i != j:\n            sequences[i], sequences[j] = _do_shuffle(sequences[i], sequences[j], th=th, p=p)\n\n    return [s for s in sequences if s]\n\n\n        \ndef create_sub_sequences(sequence, slide_score=1):\n    \"\"\" create list of perfect subsequence \"\"\"\n    out = []\n    if not sequence:\n        return out\n    \n    sub_sequence = [sequence[0]]\n    sequence = sequence[1:]\n    while sequence:\n        p1 = sub_sequence[-1]\n        \n        _next = None\n        for i, p2 in enumerate(sequence):\n            if p2 & p1 == slide_score:\n                _next = i\n                break\n        \n        if _next is not None:\n            p2 = sequence[i]\n            sub_sequence.append(p2)\n            sequence = sequence[:i] + sequence[i + 1:]\n        else:\n            out.append(sub_sequence)\n            sub_sequence = [sequence[0]]\n            sequence = sequence[1:]\n    out.append(sub_sequence)\n    \n    assert all(sequence_lost_score(s) == 0 for s in out)\n    \n    return out\n\n\ndef create_photo_sequences(photos):\n    horisontal_sequences = []\n    for size in sorted({len(x) \/\/ 2 * 2 for x in photos}):\n        sizes = (size, size + 1)\n        print(\">>> Processing {}...\".format(sizes))\n        slide_score = size \/\/ 2\n        sequence = [x for x in photos if len(x) in sizes]\n        if not sequence:\n            continue\n\n        sequences = create_sub_sequences(sequence, slide_score=slide_score)\n\n        nb_attempts = 0\n        previous_total_score = 0\n        while True:\n            # subsequence post processing\n            # trying to reduce number of subsequences, all subsequences must remain perfect\n            sequences = stitch(sequences, th=slide_score)\n            sequences = insert(sequences, th=slide_score)\n            sequences = shuffle(sequences, th=slide_score, p=0.2)\n\n            total_score = sum(sequence_score(x) for x in sequences)\n            if total_score <= previous_total_score:\n                nb_attempts += 1\n            else:\n                nb_attempts = 0\n            previous_total_score = total_score\n\n            if len(sequences) == 1 or nb_attempts >= 10:\n                break\n\n        assert all(sequence_lost_score(s) == 0 for s in sequences)\n\n        sequence = sum(sequences, [])\n        print(\"Nb sub sequences\", len(sequences), \", Nb photos\", len(sequence))\n        print(f\"Score = {sequence_score(sequence)} \/ {sequence_max_score(sequence)}\")\n\n        horisontal_sequences += sequences\n        size += 2\n\n    return sum(horisontal_sequences, [])","117dede8":"# Match vertical photos\n# Please see https:\/\/www.kaggle.com\/huikang\/441k-in-11-mins for more details\nMERGE_WINDOW = 10000\nREARRANGE_FOR_MERGE = True\n\ndef match_vertical_photos(vertical_photos):\n    vertical_photos = sorted(vertical_photos, key=len)\n\n    vertical_tmp = vertical_photos[::-1]  # start from photo with most tags\n\n    if REARRANGE_FOR_MERGE:  \n        # so we can easily match photos with more tags with photos with less tags\n        vertical_photos[0::2] = vertical_tmp[:len(vertical_photos) \/\/ 2]\n        vertical_photos[1::2] = vertical_tmp[len(vertical_photos) \/\/ 2:][::-1]\n\n    vertical_photos, vertical_tmp = [vertical_photos[0]], vertical_photos[1:]\n\n    for i in tqdm(range(len(vertical_tmp))):\n        p1 = vertical_photos[-1]\n        best = -9999\n        best_next_ptr = 0\n        cnt = 0\n        for j, p2 in enumerate(vertical_tmp):\n            if len(vertical_photos)%2 == 0:  # we do not need to consider between pairs\n                break\n            if best == 0:\n                # we have found an optimal match\n                break\n            if cnt > MERGE_WINDOW:\n                # early stopping in the search for a paired photo\n                break\n            sc = - (p1 & p2)\n            num_tags_if_paired = len(p1 | p2)\n            if num_tags_if_paired % 2 == 1:  \n                # penalise if the total number of tags is odd\n                sc = min(sc, -0.9)\n            if num_tags_if_paired > 22 and REARRANGE_FOR_MERGE:  \n                # to encourage the total number of tags around 22\n                sc = min(sc, -0.02 * num_tags_if_paired)\n            if sc > best:\n                best = sc\n                best_next_ptr = j\n            cnt += 1\n        vertical_photos.append(vertical_tmp[best_next_ptr])\n        vertical_tmp = vertical_tmp[:best_next_ptr] + vertical_tmp[best_next_ptr+1:]\n\n    combined_photo = [a | b for a,b in zip(vertical_photos[0::2], vertical_photos[1::2])]\n    \n    return combined_photo","dff7897d":"vertical_photos = [x for x in data if x.orientation == Orientation.Vertical]\ncombined_photos = match_vertical_photos(vertical_photos)\nall_photos = combined_photos + [x for x in data if x.orientation == Orientation.Horizontal]\nsubmission = create_photo_sequences(all_photos)","7b967918":"show(submission)","53c7f20c":"def _reverse(sequence, start, end):\n    return sequence[:start] + sequence[start:end][::-1] + sequence[end:]\n\n    \ndef _improve(sequence, i, greedy=False):\n    l1, l2 = sequence[i - 1], sequence[i]\n    l12, max_l12 = lazy_calc_score(l1, l2), calc_max_score(l1, l2)\n    for j in range(i + 1, len(sequence)):\n        r1, r2 = sequence[j - 1], sequence[j]\n        max_r12 = calc_max_score(r1, r2)\n        current_max_score = max_l12 + max_r12\n        \n        max_lr1 = calc_max_score(l1, r1)\n        max_lr2 = calc_max_score(l2, r2)\n        new_max_score = max_lr1 + max_lr2\n        \n        if not greedy and new_max_score < current_max_score:\n            continue\n        \n        r12 = lazy_calc_score(r1, r2)\n        current_score = l12 + r12\n        \n        lr1 = calc_score(l1, r1)\n        lr2 = calc_score(l2, r2)\n        new_score = lr1 + lr2\n        \n        if new_score > current_score:\n            sequence = _reverse(sequence, i, j)\n            break\n    \n    return sequence\n    \n    \ndef post_process(submission, greedy=False):  \n    p1 = submission[0]\n    for i in range(1, len(submission)):\n        p2 = submission[i]\n        if lazy_calc_score(p1, p2) < calc_max_score(p1, p2):\n            submission = _improve(submission, i, greedy=greedy)\n        p1 = p2\n    return submission","681253fa":"nb_attempts = 0\nprevious_score = 0\ngreedy = False\nwhile True:\n    print(f\"Score = {sequence_score(submission)} \/ {sequence_max_score(submission)}\")\n    current_score = sequence_score(submission)\n    \n    if current_score <= previous_score:\n        nb_attempts += 1\n    else:\n        nb_attempts = 0\n    if nb_attempts >= 2:\n        if not greedy:\n            greedy = True\n        else:\n            break\n    previous_score = current_score\n    \n    submission = post_process(submission[::-1], greedy=greedy)","c355d594":"show(submission)","17a25a20":"create_submission(submission)","104e9b5b":"## Optimizing a photo album from Hash Code 2019\n\nI think it is not necessary to implement greedy search through all images. Instead, I tried to split all photos into several subsequences and optimized them individually.\n\n## Stages:\n\n- arrange photos\n- post processing","aa7a9536":"## Create submission","5f2a8417":"## Post processing","ff15623f":"## Arrange photos","296c70e2":"Our submission consists of separate subsequences and we never thought about how these subsequences fit together. Here, we shuffle the submission to get maximum score."}}