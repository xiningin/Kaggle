{"cell_type":{"fe26b031":"code","56828f8b":"code","cce21e9c":"code","fdd02da6":"code","66995b47":"code","0fca0f36":"code","a0030196":"code","787b96a1":"code","bec7e4f8":"code","7210e9dc":"code","0531c549":"code","b65edfe6":"code","1c43d024":"code","50e73cd7":"code","2b0525f5":"code","2ba64d21":"code","a3e8d253":"code","0f7ce301":"code","52b6c2c2":"code","e4502f04":"code","fb650fc3":"code","cbb938c7":"code","5db6641f":"code","ee761deb":"code","b7a9cfbc":"code","7b0f08e0":"code","ec0070b8":"code","4bf47f47":"code","35914266":"code","c65fca4d":"code","e9c48363":"code","c20d0c68":"code","7f2d16a5":"code","28ba3d0e":"code","eee406d0":"code","c41a93f1":"code","a3ea7249":"code","5c9b3b31":"code","f588698f":"code","345912f7":"code","4404dcc8":"code","d3845a0d":"code","a1cfa582":"code","83f08501":"code","e8b6e363":"code","58ef3941":"code","e4325862":"code","5a79c9ec":"code","79f3d336":"code","7af839c8":"code","6a768233":"code","cf5bae65":"code","d3a2beae":"code","fe77a70e":"code","00c143f5":"code","385b10ed":"code","f40b2d21":"code","16fc7190":"code","bcb7d1de":"code","f6f8f48e":"code","57604ee1":"code","7e8cb084":"code","dd5a2e94":"code","bda5dfaf":"code","84e33e99":"code","97d74dae":"code","6fb57840":"code","470c245a":"code","fe7b0c1d":"code","6b35c155":"code","264c4395":"code","7e4e5837":"code","edc884ce":"code","e7d4728b":"code","ea1b021a":"code","8f7ff28e":"code","28ef324c":"code","228473a8":"code","f201542c":"code","3c6fb8d6":"code","ff7fdacf":"code","897866e5":"markdown","5462cda3":"markdown","3671351a":"markdown","9dad2453":"markdown","0e3d22b1":"markdown","cf0b841c":"markdown","41f41cfc":"markdown","ccc8ffe5":"markdown","8e191f85":"markdown","1b9cf4cd":"markdown","b7a07b75":"markdown","e87a486f":"markdown","a524a8be":"markdown","21281963":"markdown","e30789f7":"markdown","24b13ce7":"markdown","fa901ad4":"markdown","78971536":"markdown","6d190656":"markdown","7beb6da8":"markdown","da0084b3":"markdown","a39e80cc":"markdown","54585b61":"markdown","51842971":"markdown","eff1b70f":"markdown","3db64d07":"markdown","a306abf5":"markdown","f14ff723":"markdown","7eebaeb0":"markdown","ee9ff751":"markdown","dd4e0a9b":"markdown","43e9fb04":"markdown","977415a0":"markdown","7deb62b5":"markdown","a14624ab":"markdown"},"source":{"fe26b031":"import pandas as pd\nimport numpy as np\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom inspect import signature\n\nimport os\nimport sys\nfrom zipfile import ZipFile\n\nimport ipywidgets as widgets\nfrom IPython import display\n\nimport h2o\nfrom h2o.frame import H2OFrame\n\nfrom tqdm import tqdm\ntqdm.pandas()","56828f8b":"pd.set_option('display.width', 1000)\npd.set_option('display.max_columns', 1000)\npd.set_option('display.max_rows', 1000)\npd.set_option('display.max_colwidth', 1000)","cce21e9c":"PATH = '..\/input\/'\nPATH","fdd02da6":"for curr_dir, subdirs, files in os.walk(PATH):\n    print(curr_dir)    \n    print(files)","66995b47":"# find number of line in each file\n!find ..\/input\/*ank*\/ -name '*.csv' | xargs wc -l | sort -nr","0fca0f36":"# check which seperator symbol (i.e. ',', ':', ';' etc.) is used in 'bank-additional-full.csv'\n!head -n 2 $PATH\/bank-marketing\/bank-additional-full.csv","a0030196":"# check which seperator symbol (i.e. ',', ':', ';' etc.) is used in 'bank-additional.csv'\n!head -n 2 $PATH\/bank-marketing-full-dataset\/bank-additional.csv\n ","787b96a1":"# find the details of each of columns in the file 'bank-additional-full.csv'\n!tail -30 $PATH\/bank-marketing\/bank-additional-names.txt","bec7e4f8":"feature_columns = ['age', 'job', 'marital', 'education', 'default', 'housing', 'loan',\n                  'contact', 'month', 'day_of_week', 'duration', 'campaign', 'pdays',\n                  'previous', 'poutcome', 'emp_var_rate', 'cons_price_idx', 'cons_conf_idx',\n                   'euribor3m', 'nr_employed']\n\ntarget_column = 'deposit_subscribed'","7210e9dc":"h2o.init()","0531c549":"# reading data into h2o frame abbreviated as hf\nhf_trn = h2o.import_file(f\"{PATH}bank-marketing\/bank-additional-full.csv\", sep=';')                              \nhf_tst = h2o.import_file(f\"{PATH}bank-marketing-full-dataset\/bank-additional.csv\", sep=';')                              ","b65edfe6":"hf_trn.shape, hf_tst.shape","1c43d024":"hf_trn.head(5)","50e73cd7":"hf_tst.head(5)","2b0525f5":"hf_trn.columns = feature_columns+[target_column]\nhf_tst.columns = feature_columns+[target_column]","2ba64d21":"hf_trn.head(1)","a3e8d253":"hf_tst.head(1)","0f7ce301":"from h2o.frame import H2OFrame\ndef missing_value_info(hf, value, perc=False):      \n    missing_hf = H2OFrame({c: hf[c].isin(value).sum() for c in hf.columns})    \n    if perc:\n        return H2OFrame(missing_hf.as_data_frame().divide(len(hf)).multiply(100).round(2))\n    else:\n        return missing_hf","52b6c2c2":"missing_value_info(hf_trn, 'unknown')","e4502f04":"missing_value_info(hf_trn, 'unknown', True)","fb650fc3":"# In training data\nhf_trn[target_column].table()","cbb938c7":"# for training data\nH2OFrame(hf_trn.types)","5db6641f":"# for testing data\nH2OFrame(hf_tst.types)","ee761deb":"# find which columns are categorical\ncateg_columns = [hf_trn.names[int(col_index)] \n                              for col_index in hf_trn.columns_by_type(coltype='categorical')]\ncateg_columns.remove(target_column)\nH2OFrame([categ_columns])","b7a9cfbc":"df_trn = hf_trn.as_data_frame()\ndf_trn.shape","7b0f08e0":"sns.set_style(\"ticks\")\nfig, axes = plt.subplots(nrows=4, ncols=3, figsize=(25, 21))\nfig.suptitle(f\"Frequency Distribution of Categorical Features\\n[{target_column}:`yes`]\",\n             horizontalalignment='center', y=1.05,\n             verticalalignment='center', fontsize=30)\n\nplt.rcParams.update({'font.size': 15})\nfig.subplots_adjust(top=0.99, bottom=0.01, hspace=1.5, wspace=0.4)\nfor ax, c in list(zip(axes.flat, categ_columns)):        \n    sns.countplot(c, data=df_trn[df_trn[target_column]=='yes'],                  \n                  order= df_trn[df_trn[target_column]=='yes'][c].value_counts().index,\n                  ax=ax)\n    for p in ax.patches:\n        ax.annotate(\"{}\".format(p.get_height()), (p.get_x()+0.1, p.get_height()+50),\n                       ha='left', va='bottom', rotation=45)\n    ax.tick_params(labelrotation=90)  \n    plt.sca(ax)\n    plt.yticks(rotation=0)    \n    # ax.axis('off')\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['bottom'].set_visible(True)\n    ax.spines['left'].set_visible(False)\n    ","ec0070b8":"# https:\/\/stackoverflow.com\/questions\/19273040\/rotating-axis-text-for-each-subplot\nsns.set_style(\"ticks\")\nfig, axes = plt.subplots(nrows=4, ncols=3, figsize=(25, 21))\nfig.suptitle(f\"Frequency Distribution of Categorical Features\\n[{target_column}:`no`]\",\n             horizontalalignment='center', y=1.05,\n             verticalalignment='center', fontsize=30)\n\nplt.rcParams.update({'font.size': 15})\nfig.subplots_adjust(top=0.99, bottom=0.01, hspace=1.5, wspace=0.4)\n\nfor ax, c in list(zip(axes.flat, categ_columns)):        \n    sns.countplot(c, data=df_trn[df_trn[target_column]=='no'],                  \n                  order= df_trn[df_trn[target_column]=='no'][c].value_counts().index,\n                  ax=ax)\n    for p in ax.patches:\n        ax.annotate(\"{}\".format(p.get_height()), (p.get_x()+0.1, p.get_height()+50),\n                       ha='left', va='bottom', rotation=45)\n    ax.tick_params(labelrotation=90)  \n    plt.sca(ax)\n    plt.yticks(rotation=0)    \n    # ax.axis('off')\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['bottom'].set_visible(True)\n    ax.spines['left'].set_visible(False)\n    ","4bf47f47":"widgets_list = []\n\nfor c in enumerate(categ_columns):\n    widgets_list.append(widgets.Output())   \n    \n# render in output widgets\nfor c, wid in list(zip(categ_columns, widgets_list)):\n    with wid:\n        display.display(hf_trn[c].table().sort(['Count'], ascending=[False]))\n    \n# create HBox\nhbox1 = widgets.HBox(widgets_list[:4])\nhbox2 = widgets.HBox(widgets_list[4:])","35914266":"hbox1","c65fca4d":"hbox2","e9c48363":"# Categorical Unique Count\ncateg_uc = []\nfor c in categ_columns:    \n    categ_uc.append([c, hf_trn[c].unique().nrows])\n","c20d0c68":"h2o.H2OFrame(categ_uc, column_names=['Categ_Column', 'Count']).sort(['Count'], ascending=False)","7f2d16a5":"# find which columns are numerical\nnumerical_columns = [hf_trn.names[int(col_index)] \n               for col_index in hf_trn.columns_by_type(coltype='numeric')]\nh2o.H2OFrame([numerical_columns])","28ba3d0e":"# https:\/\/stackoverflow.com\/questions\/19273040\/rotating-axis-text-for-each-subplot\nsns.set_style(\"ticks\")\nfig, axes = plt.subplots(nrows=4, ncols=3, figsize=(25, 21))\nfig.suptitle(f\"Distribution of Numerical Features\\n[{target_column}: `no`]\",\n             horizontalalignment='center', y=1.1,\n             verticalalignment='center', fontsize=40)\nplt.rcParams.update({'font.size': 15})\nfig.subplots_adjust(top=0.99, bottom=0.05, hspace=1.5, wspace=0.2)\n\nfor ax, c in list(zip(axes.flat, numerical_columns)):        \n    sns.distplot(a=df_trn[df_trn[target_column] == 'no'][c],\n                  kde=False)\n    \n    ax.tick_params(labelrotation=90)  \n    plt.sca(ax)\n    plt.yticks(rotation=0)    \n    # ax.axis('off')\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['bottom'].set_visible(True)\n    ax.spines['left'].set_visible(False)\n","eee406d0":"hf_trn_corr = hf_trn[numerical_columns].cor(y=hf_trn[target_column], use='complete.obs')","c41a93f1":"hf_trn_corr['index'] = h2o.H2OFrame(numerical_columns)","a3ea7249":"# correlation of each numeric feature column with target column\nhf_trn_corr","5c9b3b31":"# correlation matrix of numeric feature columns\nplt.figure(figsize=(8, 8))\nplt.rcParams.update({'font.size': 10})\nhf_trn_corr = hf_trn[numerical_columns].cor()\nax = sns.heatmap(hf_trn_corr.as_data_frame(), annot=True, fmt='.2f')\nax.set_yticklabels(numerical_columns, rotation=0, ha='right', minor=False);","f588698f":"_ = sns.pairplot(df_trn, hue=target_column, palette=\"husl\")","345912f7":"print(categ_columns)","4404dcc8":"# which Numerical columns contain misisng values in training data\nfor c in numerical_columns:\n    print(c, \"=\", hf_trn[c].nacnt())","d3845a0d":"# which categorical columns contain 'unknown'\nmissing_value_cols = []\nfor c in categ_columns:\n    if 'unknown' in hf_trn[c].categories():\n        missing_value_cols.append(c)","a1cfa582":"missing_value_cols","83f08501":"# https:\/\/stackoverflow.com\/questions\/19273040\/rotating-axis-text-for-each-subplot\nsns.set_style(\"ticks\")\nfig, axes = plt.subplots(nrows=3, ncols=2, figsize=(25, 21))\nfig.suptitle(\"Distribution of `Missing` Categorical Features\",\n             horizontalalignment='center', y=1.05,\n             verticalalignment='center', fontsize=40)\n\nplt.rcParams.update({'font.size': 20})\nfig.subplots_adjust(top=0.99, bottom=0.4, hspace=1.5, wspace=0.2)\n\nfor ax, c in list(zip(axes.flat, missing_value_cols)):        \n    sns.countplot(c, data=df_trn,                  \n                  order= df_trn[c].value_counts().index,\n                  hue=target_column,\n                  ax=ax)\n    for p in ax.patches:\n        ax.annotate(\"{}\".format(p.get_height()), (p.get_x()+0.1, p.get_height()+50),\n                       ha='left', va='bottom', rotation=45)\n    ax.tick_params(labelrotation=90)  \n    plt.sca(ax)\n    plt.yticks(rotation=0)    \n    # ax.axis('off')\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['bottom'].set_visible(True)\n    ax.spines['left'].set_visible(False)\n    ","e8b6e363":"# number of rows for which all the columns in missing_value_cols have misisng values\nfrom collections import Counter\nconditions = ((df_trn['job'] == 'unknown') & \n              (df_trn['marital'] == 'unknown') & \n              (df_trn['education'] == 'unknown') & \n              (df_trn['default'] == 'unknown') &  \n              (df_trn['housing'] == 'unknown') & \n              (df_trn['loan'] == 'unknown'))\ndf_trn[conditions].__len__()","58ef3941":"df_trn = hf_trn.as_data_frame()\ndf_tst = hf_tst.as_data_frame()\ndf_trn.shape, df_tst.shape","e4325862":"from sklearn.preprocessing import StandardScaler","5a79c9ec":"print(numerical_columns)","79f3d336":"scaler = StandardScaler()\n%time scaler.fit(df_trn[numerical_columns])","7af839c8":"scaler.mean_","6a768233":"df_trn.loc[:, numerical_columns] = pd.DataFrame(scaler.transform(df_trn[numerical_columns]), \n                                                columns=numerical_columns)","cf5bae65":"df_tst.loc[:, numerical_columns] = pd.DataFrame(scaler.transform(df_tst[numerical_columns]),\n                                                columns=numerical_columns)","d3a2beae":"df_trn.head()","fe77a70e":"df_tst.head()","00c143f5":"hf_trn = H2OFrame(df_trn)\nhf_tst = H2OFrame(df_tst)","385b10ed":"hf_trn.describe()","f40b2d21":"hf_tst.describe()","16fc7190":"# find numerical column index\nfor idx in hf_trn.columns_by_type('numeric'):\n    hf_tst[int(idx)] = hf_tst[int(idx)].asnumeric()\n\n# find categorical column index\nfor idx in hf_trn.columns_by_type('categorical'):\n    hf_tst[int(idx)] = hf_tst[int(idx)].asfactor()\n    ","bcb7d1de":"# verify data types\nassert hf_trn.columns_by_type('categorical') == hf_tst.columns_by_type('categorical')\nassert hf_trn.columns_by_type('numeric') == hf_tst.columns_by_type('numeric')\n","f6f8f48e":"from h2o.estimators.random_forest import H2ORandomForestEstimator\nfrom h2o.estimators.gbm import H2OGradientBoostingEstimator\nfrom h2o.estimators.stackedensemble import H2OStackedEnsembleEstimator\nfrom h2o.grid.grid_search import H2OGridSearch","57604ee1":"# Identify predictors and response columns\nx_cols = list(hf_trn.columns)\ny_col = target_column\nx_cols.remove(y_col)\nprint(x_cols)\nprint()\nprint(y_col)","7e8cb084":"nfolds = 5\ngbm_hyper_params = {\"ntrees\": list(range(10, 251, 20)), \n                    \"max_depth\": list(range(3, 16)),\n                    \"min_rows\": [2, 3, 4, 5, 6, 7, 8],\n                    \"learn_rate\": [0.1, 0.01, 0.001, 0.0001],\n                    \"sample_rate\": [0.5, 0.6, 0.7, 0.8, 0.9],\n                    \"col_sample_rate\": [0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n                    \"balance_classes\": [True, False]\n                    }\n\ngbm_search_criteria = {\"strategy\": \"RandomDiscrete\", \"max_models\": 40, \n                       \"seed\": 42}","dd5a2e94":"gbm = H2OGradientBoostingEstimator(distribution=\"bernoulli\",\n                                   nfolds=nfolds,\n                                   fold_assignment=\"Stratified\",\n                                   keep_cross_validation_predictions=True,\n                                   categorical_encoding='auto',\n                                   seed=42)","bda5dfaf":"gbm_grid = H2OGridSearch(model=gbm,\n                         hyper_params=gbm_hyper_params,\n                         search_criteria=gbm_search_criteria,\n                         grid_id=\"gbm_grid_binomial\")","84e33e99":"%time gbm_grid.train(x=x_cols, y=y_col, training_frame=hf_trn)","97d74dae":"# find the trained models based on the descending order of F1 score \ngbm_grid_f1 = gbm_grid.get_grid(sort_by = \"F1\",\n                                decreasing = True)\n# F1 score of cross-validated model\ngbm_grid_f1","6fb57840":"# find the trained models based on the descending order of roc_auc score \ngbm_grid_roc_auc = gbm_grid.get_grid(sort_by = \"auc\",\n                                decreasing = True)\n# roc_auc score of cross-validated model\ngbm_grid_roc_auc\n","470c245a":"# save the best model based on f1 score\nmodel_path = h2o.save_model(model=gbm_grid_f1.models[0], \n                            path=\"..\/input\/saved_models\/\",\n                            force=True)\nprint(model_path)","fe7b0c1d":"!ls -hl ..\/input\/saved_models\/","6b35c155":"# load the model\ngbm_grid_f1 = h2o.load_model(model_path)","264c4395":"metric = [('Train', 'F1', gbm_grid_f1.F1(train=True)[0][0], gbm_grid_f1.F1(train=True)[0][1]),\n      ('Train', 'Precision', gbm_grid_f1.precision(train=True)[0][0], gbm_grid_f1.precision(train=True)[0][1]),\n      ('Train', 'Recall', gbm_grid_f1.recall(train=True)[0][0], gbm_grid_f1.recall(train=True)[0][1]),\n      ('Train', 'ROC_AUC', '-', gbm_grid_f1.auc(train=True)),\n      ('Train', 'RR_AUC', '-', gbm_grid_f1.pr_auc(train=True)),           \n      \n      ('Xval', 'F1', gbm_grid_f1.F1(xval=True)[0][0], gbm_grid_f1.F1(xval=True)[0][1]),\n      ('Xval', 'Precision', gbm_grid_f1.precision(xval=True)[0][0], gbm_grid_f1.precision(xval=True)[0][1]),\n      ('Xval', 'Recall', gbm_grid_f1.recall(xval=True)[0][0], gbm_grid_f1.recall(xval=True)[0][1]),      \n      ('Xval', 'ROC_AUC', '-', gbm_grid_f1.auc(xval=True)),\n      ('Xval', 'RR_AUC', '-', gbm_grid_f1.pr_auc(xval=True))]\n\npd.DataFrame(metric, columns=['Data', 'Metric', 'Threshold', 'Score']).set_index(['Data', 'Metric'])","7e4e5837":"gbm_grid_f1.plot()","edc884ce":"from sklearn.metrics import f1_score, roc_curve, auc\nfrom sklearn.metrics import roc_auc_score, precision_recall_curve ","e7d4728b":"y_tst_pred_gbm = gbm_grid_f1.model_performance(test_data=hf_tst)    ","ea1b021a":"metric = [('Test', 'F1', y_tst_pred_gbm.F1()[0][0], y_tst_pred_gbm.F1()[0][1]),\n      ('Test', 'Precision', y_tst_pred_gbm.precision()[0][0], y_tst_pred_gbm.precision()[0][1]),\n      ('Test', 'Recall', y_tst_pred_gbm.recall()[0][0], y_tst_pred_gbm.recall()[0][1]),\n      ('Test', 'ROC_AUC', '-', y_tst_pred_gbm.auc()),\n      ('Test', 'RR_AUC', '-', y_tst_pred_gbm.pr_auc())]\n     \n\npd.DataFrame(metric, columns=['Data', 'Metric', 'Threshold', 'Score']).set_index(['Data', 'Metric'])","8f7ff28e":"# True Positive Rate\ntpr_h2o =y_tst_pred_gbm.tprs\n# False Positive Rate\nfpr_h2o = y_tst_pred_gbm.fprs","28ef324c":"# ROC AUC Curve using Sklearn\nplt.title('ROC AUC Curve', color='blue')\nplt.plot([0, 1], [0, 1], ls='--', lw=2, alpha=0.2)\nax = sns.lineplot(y=tpr_h2o, x=fpr_h2o, \n                  label=\"auc={0:.4f}\".format(auc(x=fpr_h2o, y=tpr_h2o)))\nax.set_xlabel(\"False Positive Rate (FPR)\", color='r')\nax.set_ylabel(\"True Positive Rate (TPR)\", color='g')\nplt.legend(loc='lower right');","228473a8":"# ROC AUC Curve using H2O\ny_tst_pred_gbm.plot(type='roc')","f201542c":"# find precision and recall scores at different threshold to plot precision_recall curver\nprecision = y_tst_pred_gbm.precision(thresholds=[i for i in np.arange(0.02, 1, 0.001)])\nrecall = y_tst_pred_gbm.recall(thresholds=[i for i in np.arange(0.02, 1, 0.001)])","3c6fb8d6":"# take the precision and recall scores for positive class - 'yes'\nprec = [p[1] for p in precision]\nrec = [r[1] for r in recall]\nlen(prec), len(rec)","ff7fdacf":"# http:\/\/www.chioka.in\/differences-between-roc-auc-and-pr-auc\/\npositive_label = 'yes'\npr_auc = auc(x=rec, y=prec)  \n\nax = sns.lineplot(y=prec, x=rec, \n                  label=\"{0}: auc={1:.4f}\".format(positive_label, pr_auc))\nax.set_xlabel(\"Recall\", color='g')\nax.set_ylabel(\"Precision\", color='g')\nplt.title(f\"PR AUC Curve [Positive Class]: `{positive_label}`\", color='blue')\nplt.plot([0, 1], [0.5, 0.5], linestyle='--', alpha=0.2)\nplt.plot([0.5, 0.5], [0, 1], linestyle='--', alpha=0.2)\nplt.legend(loc='lower right');","897866e5":"## Evaluation","5462cda3":"## Prediction","3671351a":"> * We can verify our result of categorical columns with the one given in the file `bank-additional-names.txt`.\n> * All the feature columns in `categ_columns` are also specified as categorical in `bank-additional-names.txt`.","9dad2453":"> * **['job', 'marital', 'education', 'default', 'housing', 'loan']** columns contain missing values.\n> * We will treat missing values as possible class lable.","0e3d22b1":"> * dataset link - http:\/\/archive.ics.uci.edu\/ml\/datasets\/Bank+Marketing","cf0b841c":"### Drop Unnecessary Columns","41f41cfc":"## Initialize H2O","ccc8ffe5":"### Missing Value Check\n> * Missing Attribute Values: There are several missing values in some categorical attributes, all coded with the `\"unknown\"` label. These missing values can be treated as a possible class label or using deletion or imputation techniques. \n\n> * We will take `\"unknown\"` value as a possible class label.","8e191f85":"### Target Class Distribution\n","1b9cf4cd":"## Read the dataset","b7a07b75":"* No column needs to be dropped","e87a486f":"### Feature Normalization of Numerical Columns","a524a8be":"> * While training our model, we can specify what are the feature columns should be considered as categorical.\n> * We can also specify the encoding scheme will be used to convert categorical features into numerical form.\n> * H2O handles it internally.","21281963":"> * Convert pandas dataframe to h2o frame","e30789f7":"### Correlation Matrix","24b13ce7":"## Build the Model - GBM With Cross-Validated GridSearch","fa901ad4":"### Categorical Encoding: Convert Categorical Features into Numerical Form\n> http:\/\/docs.h2o.ai\/h2o\/latest-stable\/h2o-docs\/data-science\/algo-params\/categorical_encoding.html","78971536":"> * First h2o frame represents the count of missing values and,\n> * Second h2o frame shows the percentage of it for each column","6d190656":"### Distribution of Columns having `unknown` as missing value","7beb6da8":"> * In order to plot some distributions, we need to convert h2o frame into pandas dataframe.","da0084b3":"### Verfiy the type and number of columns before training\n> * We need to make sure that number and types of feature columns should be same in both training and testing data, otherwise H2O will throw the following possible error if any type or number of columns are not same -\n     `Error: Test\/Validation dataset has categorical column 'age' which is real-valued in the training data`     \n ","a39e80cc":"* We can find out the different evaluation metrics available for classification in H2O library in the following url\nhttp:\/\/docs.h2o.ai\/h2o\/latest-stable\/h2o-docs\/performance-and-prediction.html#classification\n\n    1. Gini Coefficient\n    2. Absolute MCC (Matthews Correlation Coefficient)\n    3. F1\n    4. F0.5\n    5. F2\n    5. Accuracy\n    6. Logloss\n    7. AUC (Area Under the ROC Curve)\n    8. AUCPR (Area Under the Precision-Recall Curve)","54585b61":"### Find Numerical Features and their Distribution","51842971":"https:\/\/h2o-release.s3.amazonaws.com\/h2o\/rel-ueno\/2\/docs-website\/h2o-py\/docs\/frame.html","eff1b70f":"### Find Categorical Features and their Distribution","3db64d07":"### Find Unique Value Count for Categorical Features","a306abf5":"## EDA","f14ff723":"> ---\n> ---","7eebaeb0":"## Save the Model","ee9ff751":"## Train the Model","dd4e0a9b":"> * **Frequency Distribution of Categorical Features Using H2O Frame**","43e9fb04":"### Check Data Types of Each Columns","977415a0":"## Load the Model","7deb62b5":"> * We can see that both the files are semicolon (;) seperated. Hence we need to read the file with seperator as `;`\n> * We will use `bank-additional-full.csv` as training data and `bank-additional.csv` as testing data.","a14624ab":"* We can observe that type of each column in hf_trn matches with the one mentioned in bank-additional-names.txt file, but hf_tst does not have correct data type for its columns.\n    - real means numeric\n    - enum means categorical\n \n**We have to match the data type of each column in training and testing data**[](http:\/\/)"}}