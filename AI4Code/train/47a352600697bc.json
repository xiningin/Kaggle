{"cell_type":{"d5e25304":"code","9c8c325e":"code","beb971c8":"code","3865fe7b":"code","eb3f01b5":"code","c834e24b":"code","359ed602":"code","4db9d683":"code","b15e84de":"code","9d7883f7":"code","74c7ac86":"code","44903daa":"code","d69407d5":"code","6333e2e2":"code","f90a5f8d":"code","e85eb2d2":"code","563fb6b1":"code","e03c3787":"code","5c988d87":"code","12963aa4":"code","4a4b47de":"code","88115964":"code","64890dc6":"code","64f0b471":"code","b9a8448b":"code","61cf1852":"code","471ee528":"code","ba87fd92":"code","253c520f":"code","4dbbb112":"markdown","c6983a03":"markdown","60cdd438":"markdown","b67ab12a":"markdown"},"source":{"d5e25304":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","9c8c325e":"import torch\nimport torchvision\nimport numpy\nimport matplotlib.pyplot as plt\nimport pandas as pd","beb971c8":"mnist_train=pd.read_csv('\/kaggle\/input\/mnist-in-csv\/mnist_train.csv')","3865fe7b":"mnist_train.head()","eb3f01b5":"random_sample=mnist_train.sample(8)","c834e24b":"image_features=random_sample.drop('label',axis=1)\nimage_batch=(torch.tensor(image_features.values\/255)).reshape(-1,28,28)","359ed602":"image_batch.shape","4db9d683":"grid=torchvision.utils.make_grid(image_batch.unsqueeze(1),nrow=8)\nprint(grid.shape)","b15e84de":"plt.figure(figsize=(12,12))\nplt.imshow(grid.numpy().transpose(1,2,0))\nplt.axis('off')","9d7883f7":"train_features=mnist_train.drop('label',axis=1)\ntrain_label=mnist_train['label']\n","74c7ac86":"from torch.utils.data import Dataset,DataLoader","44903daa":"# torch.from_numpy(image_features.values[0])","d69407d5":"#custom datasets class must implement __getitem__ and __len__ methods\nclass MnistDataset(Dataset):\n    def __init__(self,path,transform=None):\n        #loading dataframe as xy\n        xy=pd.read_csv(path)\n        #x is for the image matrix\n        self.x=xy.iloc[:,1:].values\n        #y is for the label\n        self.y=xy['label']\n        #n_samples gives number of images\n        self.n_samples=len(xy)\n        self.transform=transform\n        \n    def __getitem__(self,index):\n        sample=self.x[index],np.array(self.y[index])\n        if self.transform is not None:\n            sample=self.transform(sample)\n        return sample\n    def __len__(self):\n        return self.n_samples\n\n#custom transformation class  must implement __call__\nclass ToTensor:\n    def __call__(self,sample):\n        inputs,target=sample\n        #from_numpy converts numpy arrays to tensors\n        return torch.from_numpy(inputs),torch.from_numpy(target)\n        ","6333e2e2":"train_path='\/kaggle\/input\/mnist-in-csv\/mnist_train.csv'\ntest_path='\/kaggle\/input\/mnist-in-csv\/mnist_test.csv'\ntrain_set=MnistDataset(train_path,transform=ToTensor())\n# test_set=MnistDataset(test_path)","f90a5f8d":"first_data=train_set[0]\nplt.imshow(first_data[0].numpy().reshape(28,28))","e85eb2d2":"from torchvision import transforms\n\ntrain_loader=DataLoader(train_set,batch_size=100,shuffle=True)\n# test_loader=DataLoader(test_set,batch_size=100,shuffle=True)","563fb6b1":"plt.imshow(iter(train_loader).next()[0][0].reshape(28,28))","e03c3787":"iter(train_loader).next()[0][0].dtype","5c988d87":"#it is 1 because of single channel of colour i.e Black&White or Grayscale image\ninput_size=1\n#first convolution converts 1 channel to 16 channels in feature maps\nhid1_size=16\n#similary to 32 channels\nhid2_size=32\n\nk_conv_size=5# kernel or filter size\nimport torch.nn.functional as F\n","12963aa4":"class Net(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        \n        self.layer1=torch.nn.Sequential(\n        torch.nn.Conv2d(input_size,hid1_size,k_conv_size),\n        torch.nn.BatchNorm2d(hid1_size),\n        torch.nn.ReLU(),\n        torch.nn.MaxPool2d(kernel_size=2)\n            \n        )\n        \n        self.layer2=torch.nn.Sequential(\n            torch.nn.Conv2d(hid1_size,hid2_size,k_conv_size),\n            torch.nn.BatchNorm2d(hid2_size),\n            torch.nn.ReLU(),\n            torch.nn.MaxPool2d(kernel_size=2)\n        )\n        self.fc=torch.nn.Linear(512,10)\n        \n        \n    def forward(self,x):\n        x=self.layer1(x)\n        \n        x=self.layer2(x)\n        #Changing the image into one dimensional tensor for feeding the fully connected layers\n        x=x.reshape(x.shape[0],-1)\n       \n        x=self.fc(x)\n        return x","4a4b47de":"model=Net()\ndevice=torch.device('cuda' if torch.cuda.is_available() else 'cpu')\nmodel.to(device)","88115964":"#It is to check model accepts the input or not\n# x=torch.randn(100,1,28,28)\n# model(x)","64890dc6":"# model","64f0b471":"lr=1e-3\nloss_fn=torch.nn.CrossEntropyLoss()\noptimizer=torch.optim.SGD(model.parameters(),lr=lr,momentum=0.9)\n","b9a8448b":"epochs=3\nloss_values=[]","61cf1852":"targets=np.array([])\npreds=np.array([])\nfor epoch in range(epochs):\n    for i,(img,target) in enumerate(train_loader):\n        img=img.reshape(100,1,28,28).float().to(device)\n        optimizer.zero_grad()\n        output=model(img)\n        pred=torch.argmax(output,axis=1)\n#         print(target,pred)\n        targets=np.hstack([targets,target.cpu().numpy()])\n        preds=np.hstack([preds,pred.cpu().numpy()])\n        loss=loss_fn(output,target.to(device))\n        \n        loss.backward()\n        optimizer.step()\n        if i % 100==0:\n            print(loss)\n","471ee528":"from sklearn.metrics import accuracy_score,recall_score","ba87fd92":"accuracy_score(targets,preds)","253c520f":"recall_score(targets,preds,average='macro')","4dbbb112":"It is very important to check the data type so we should convert the data to float during the training phase \nThese simple mistakes will cause hours of headache","c6983a03":"The unsqueeze is used to add new axis or dimension to the image matrix","60cdd438":"Here we can see we have a column dedicated for label and other 784 data for 28*28 pixel of a image","b67ab12a":"we generally load data using pandas just for Exploratory data analysis because pytorch has inbuilt dataloaders to create mini batches and many other features"}}