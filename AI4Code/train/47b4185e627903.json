{"cell_type":{"7f19a39d":"code","c61662d6":"code","c9de79fb":"code","be90929a":"code","d48019ef":"code","e1b5af77":"code","ce6f32f5":"code","dfe6cc64":"code","0304db7e":"code","8df2b269":"code","2ad02cc8":"code","66073297":"code","6118a0cb":"code","5c28035f":"code","0a351768":"code","b3e0fa73":"code","698a81cb":"code","5f10bec5":"code","b8599c38":"code","3ede01f1":"code","dc85ab4b":"code","07cbd979":"code","ada0ccce":"code","0478a309":"code","2600a2e5":"code","4124e948":"code","904d87ca":"code","73a9aad2":"code","73fb7ba1":"code","f1b4dcce":"code","904bef90":"code","4a1c3777":"code","3f0e2ed5":"code","cd2ca8c7":"code","8303776b":"code","a9ea1c78":"code","339c139b":"code","ce259789":"code","2c538d8b":"code","88ef75b0":"code","36adb872":"code","3577068a":"code","dd0d41b5":"code","7365b390":"code","eb6c9a5e":"code","e626a245":"code","3dbca2dc":"code","52a64233":"code","4046b311":"code","408e46d6":"code","1a4c0d34":"code","632b061e":"code","109b8abd":"code","e77a50d7":"code","be236ae8":"code","5696854c":"code","eef1c4c9":"code","597c3446":"code","46182b54":"code","1a45b9bb":"code","43d60c30":"code","090769a5":"code","306426e8":"code","6101e17d":"code","4f34d1a0":"code","76ce027c":"code","74de9dc3":"code","b2695837":"code","37eeec60":"code","76a94f4f":"code","713de729":"code","8b3b1e7e":"code","4df21120":"code","2ca4e887":"code","acba665b":"code","c04110c2":"code","04f4ef28":"code","1eac351c":"code","af1294bf":"code","a26b5d73":"code","ba0d7710":"code","b915c792":"code","5b2243f8":"code","b8392d19":"code","e9ac7ef0":"code","c9ca05bc":"code","23c5801f":"code","29062763":"code","806d64ee":"code","1bd02045":"code","c5ca563a":"markdown","851886ee":"markdown","71346c50":"markdown","bc262bbf":"markdown","55e91a3e":"markdown","ae32d80c":"markdown","ee7dce44":"markdown","3670d89e":"markdown","846ace44":"markdown","c40569ec":"markdown","d90f1eb6":"markdown","30fd9a5e":"markdown","f5d4f11f":"markdown","6c20d2d3":"markdown","e27b250a":"markdown","eb732bb7":"markdown","7fa3b6d0":"markdown","1c369a47":"markdown","bd0549e5":"markdown","b8f4620f":"markdown","08ffefb1":"markdown","de2bda96":"markdown","98cec3b6":"markdown","1a18f9b7":"markdown","63db810e":"markdown","d4b2cc2c":"markdown","4bf8c78e":"markdown","191065eb":"markdown","6ddb4e84":"markdown"},"source":{"7f19a39d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","c61662d6":"df = pd.read_csv('..\/input\/vehicle-dataset-from-cardekho\/Car details v3.csv')\ndf","c9de79fb":"df = df.drop('name', axis=1)","be90929a":"df","d48019ef":"df.isna().sum()","e1b5af77":"# for rindex, rrindex in enumerate(df['mileage']):\n#     df['mileage'] = df['mileage'][rindex].replace(' kmpl', '')\n#     print(rindex)\n\ndf['mileage'].replace(' kmpl', '', inplace=True, regex=True)\ndf['mileage'].replace(' km\/kg', '', inplace=True, regex=True)\n\n\n# df['mileage'].apply(lambda x: x.replace(' kmpl', ''))\n#     f[1] = df[1].apply(lambda x: x + 1)\n# pd.to_numeric(df['mileage'], errors='raise')\n# df","ce6f32f5":"pd.to_numeric(df['mileage'])","dfe6cc64":"df_2 = df[~df['mileage'].isnull()]\n#df[df['column name'].isnull()]\nmileages = pd.to_numeric(df_2['mileage'])\nimpute_value = mileages.mean()\nprint(f'Value for imputation (based off the mean of mileages): {round(impute_value, 2)}')","0304db7e":"df.mileage = df.mileage.fillna(value=round(impute_value, 2))\ndf.mileage.isna().sum()\ndf.mileage = pd.to_numeric(df.mileage)","8df2b269":"df","2ad02cc8":"df.engine.isna().sum()","66073297":"# Same process as 'mileage' column\n# df['mileage'].replace(' kmpl', '', inplace=True, regex=True)\ndf.engine.replace(' CC', '', inplace=True, regex=True)\npd.to_numeric(df.engine)\ndf_engines = df[~df['engine'].isnull()]\n#df[df['column name'].isnull()]\nengines = pd.to_numeric(df_engines['engine'])\nimpute_value_engine = int(round(engines.mean(), 0))\nprint(f'Value for imputation (based off the mean of mileages): {impute_value_engine}')\n\n#Perform imputation\ndf.engine = df.engine.fillna(value=impute_value_engine)\ndf.engine = pd.to_numeric(df.engine)\n\n#Check results\nprint(f'Number of nans: {df.engine.isna().sum()}')","6118a0cb":"#Same process as above (I should really have a function built for this by now!)\n# Same process as 'mileage' column\n# df['mileage'].replace(' kmpl', '', inplace=True, regex=True)\ndf.max_power.replace(' bhp', '', inplace=True, regex=True)\npd.to_numeric(df.max_power)\ndf_mp = df[~df['max_power'].isnull()]\n#df[df['column name'].isnull()]\nmp = pd.to_numeric(df_mp['max_power'])\nimpute_value_mp = int(round(mp.mean(), 1))\nprint(f'Value for imputation (based off the mean of mileages): {impute_value_mp}')\n\n#Perform imputation\ndf.max_power = df.max_power.fillna(value=impute_value_mp)\ndf.max_power = pd.to_numeric(df.max_power)\n\n#Check results\nprint(f'Number of nans: {df.max_power.isna().sum()}')","5c28035f":"df_nt = df.drop('torque', axis=1)","0a351768":"df_nt","b3e0fa73":"df_nt.dtypes","698a81cb":"df_nt.seats.value_counts()","5f10bec5":"#We'll be replacing missing values for the 'seats' column with '5.0', the mode.","b8599c38":"df_nt.seats = df_nt.seats.fillna(value=5.0)\nprint(f'Number of nans for seats column: {df_nt.seats.isna().sum()}')","3ede01f1":"import seaborn as sns\nimport matplotlib.pyplot as plt","dc85ab4b":"#Basic plotting to get a better understanding of categorical columns\ncat_cols = ['fuel', 'seller_type', 'transmission', 'owner']\n\nfor i in cat_cols:\n    sns.countplot(x=i, data = df_nt)\n    plt.show()","07cbd979":"# We can use OHE and OrdinalEncoding to deal with all categorical columns swiftly and efficiently\nfrom sklearn.preprocessing import OneHotEncoder, OrdinalEncoder","ada0ccce":"#Simple binary encoding, 0 if manual, 1 if automatic\nmapper = {'Manual':0, 'Automatic':1}\ndf_nt.transmission = df_nt.transmission.replace(mapper)\ndf_nt.transmission.value_counts()","0478a309":"import numpy as np","2600a2e5":"# cols = ['fuel', 'seller_type']\n# ohe = OneHotEncoder()\n# feature_array = ohe.fit_transform(df[['fuel', 'seller_type']]).toarray()\n# feature_array","4124e948":"# feature_labels = ohe.categories_\n# # feature_labels =  np.ndarray.flatten(feature_labels)\n# feature_labels","904d87ca":"# cols = ['CNG', 'Diesel', 'LPG', 'Petrol', 'Dealer', 'Individual' ,'Trustmark Dealer']\n# # '1983', '1991', '1994', '1995', '1996', '1997', '1998', '1999', '2000', '2001', '2002',\n#         #'2003', '2004', '2005', '2006', '2007', '2008', '2009', '2010', '2011', '2012', '2013',\n#        # '2014', '2015', '2016', '2017', '2018', '2019', '2020'","73a9aad2":"# df_OHE = pd.DataFrame(feature_array)\n\n# df_OHE\n# # feature_array","73fb7ba1":"# df_nt = df_nt.drop(['fuel', 'seller_type'], axis=1)","f1b4dcce":"# df_nt","904bef90":"# df_nt = pd.concat([df_nt, df_OHE], axis=1)","4a1c3777":"# df_nt","3f0e2ed5":"from sklearn.compose import ColumnTransformer","cd2ca8c7":"df.fuel.unique()\n# df.seller_type.unique()","8303776b":"df_nt","a9ea1c78":"#Wrapper for seller_type\nmapp = {'Individual':0, 'Dealer':1, 'Trustmark Dealer':2}\ndf_nt.seller_type = df_nt.seller_type.replace(mapp)\n\n#Wrapper for fuel\nmapp2 = {'Diesel': 0, 'Petrol': 1, 'LPG': 2, 'CNG': 3}\ndf_nt.fuel= df_nt.fuel.replace(mapp2)\n\n#Simple binary encoding, 0 if manual, 1 if automatic\nmapper = {'Manual':0, 'Automatic':1}\ndf_nt.transmission = df_nt.transmission.replace(mapper)\ndf_nt.transmission.value_counts()","339c139b":"df_nt","ce259789":"# model_ODE = ColumnTransformer(\n#     [('ODE', OrdinalEncoder(),['owner'])],\n#     remainder = 'passthrough'\n#     )\n\n# fuix = model_ODE.fit_transform(df_nt)\n# pd.DataFrame(fuix) \n# df_nt.owner.unique()\ncats = ['First Owner', 'Second Owner', 'Third Owner', 'Fourth & Above Owner', 'Test Drive Car']\nfuel_cats = []\nseller_type_cats = []\n\n# cats\nordi = OrdinalEncoder(categories=[cats])\nordi.fit(df_nt[['owner']])","2c538d8b":"df_nt.owner = pd.DataFrame(ordi.transform(df_nt[['owner']])) ","88ef75b0":"df_nt.max_power = df_nt.max_power.fillna(impute_value_mp)\ndf_nt.max_power.isna().sum()\n\ndf_nt.isna().sum().sum()","36adb872":"df_nt.dtypes","3577068a":"from sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import RandomForestRegressor\nfrom xgboost import XGBRegressor\n\nfrom sklearn.model_selection import train_test_split\n\nfrom sklearn.preprocessing import StandardScaler, RobustScaler, MinMaxScaler","dd0d41b5":"y = df_nt.selling_price\nX = df_nt.drop('selling_price', axis=1)\n# X = df_nt.drop(['selling_price', 'km_driven'], axis=1)","7365b390":"#Splitting data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = .20, random_state = 1)\n\nX_train","eb6c9a5e":"#Scaling the data for Linear Regression\n    \nscaler = StandardScaler()\n\nscaled_X_train = pd.DataFrame(scaler.fit_transform(X_train), columns = X_train.columns)\nscaled_X_test = pd.DataFrame(scaler.fit_transform(X_test), columns = X_test.columns)\n\n# Running linear regression\n\nLR = LinearRegression()\nLR.fit(scaled_X_train, y_train)\ny_pred_LR = LR.predict(scaled_X_test)\n\nX_train\nscaled_X_train\n","e626a245":"xgbr = XGBRegressor(verbosity=0)\nxgbr.fit(X_train, y_train)\n# print(xgbr.score(scaled_X_train, y_train))\n\ny_pred_X = xgbr.predict(X_test)","3dbca2dc":"from sklearn.metrics import r2_score as r2, mean_absolute_error as mae, mean_squared_error as mse\nimport math","52a64233":"def get_metrics(preds, actual, model_type):\n    r2s = r2(preds, actual)\n    maes = mae(preds, actual)\n    mses = mse(preds, actual)\n    rmses = math.sqrt(mses)\n#     return rmse, mse, mae, r2\n    df = pd.DataFrame([r2s, maes, mses, rmses, model_type]).transpose()\n    df.columns = ['r2 coeff.', 'MAE', 'MSE', 'RMSE', 'Type of model']\n    return df","4046b311":"df_metrics = get_metrics(y_pred_LR, y_test, 'Linear Regression')\ndf_metrics_X = get_metrics(y_pred_X, y_test, 'XGBR')\n\ndf_metrics = pd.concat([df_metrics, df_metrics_X], axis=0)\ndf_metrics","408e46d6":"from matplotlib import rcParams","1a4c0d34":"# sns.pairplot(data=df)","632b061e":"rcParams['figure.figsize'] = 15,8\nsns.histplot(x='selling_price', hue='owner', data=df, log_scale=True);","109b8abd":"df.owner.value_counts()\/ len(df.owner)","e77a50d7":"#Wrapper\nwr = {'First Owner': 0, 'Second Owner': 1, 'Third Owner': 1, 'Fourth & Above Owner': 1, 'Test Drive Car': 1}\ndf.owner = df.owner.replace(wr)\ndf.owner.value_counts()","be236ae8":"sns.histplot(x='selling_price', hue='owner', data=df, log_scale=True);","5696854c":"df.fuel.dtype","eef1c4c9":"numerical_cols = ['selling_price', 'km_driven', 'year', 'engine', 'mileage', 'max_power', 'seats']\nfor col in numerical_cols:\n    df.boxplot(col)\n    plt.show()","597c3446":"from scipy.stats import zscore","46182b54":"def gen_zscores(df, col):\n    df['zscore_'+col] = zscore(df[col])\n\n[gen_zscores(df, nc) for nc in numerical_cols]\n\ndf","1a45b9bb":"# df = df.drop('zscore_max_power', axis=1)\n# df = df.drop('zscore_seats', axis=1)","43d60c30":"df.describe()","090769a5":"df[df['zscore_selling_price'] > 5]","306426e8":"df = df[(df.zscore_selling_price>-5) & (df.zscore_selling_price<5)]","6101e17d":"df = df.drop('zscore_selling_price', axis=1)","4f34d1a0":"def rid_outliers(df, col, zscore_val):\n    df = df.copy()\n    df = df[(df[col]>-(zscore_val)) & (df[col]<zscore_val)]\n    df = df.drop([col], axis=1)\n    return df","76ce027c":"df = rid_outliers(df, 'zscore_km_driven', 4.5)\n# df = df.drop('zscore_km_driven', axis=1)\n\ndf = df.drop([8042, 316], axis=0)\n\ndf","74de9dc3":"df = df.drop('zscore_year', axis=1)","b2695837":"# df[df.zscore_mileage > 3.0]\ndf = rid_outliers(df, 'zscore_mileage', 3.0)","37eeec60":"df = df.drop(['zscore_max_power', 'zscore_seats'], axis=1)\ndf","76a94f4f":"df = rid_outliers(df, 'zscore_engine', 3.4)","713de729":"numerical_cols = ['selling_price', 'km_driven', 'year', 'engine', 'mileage', 'max_power', 'seats']\nfor col in numerical_cols:\n    df.boxplot(col)\n    plt.show()","8b3b1e7e":"df[df.seats == 14.0]","4df21120":"#From above, the index is 4575, dropping this index due to the seat count being so high (probably a bus, we're trying to predict car selling prices)\ndf = df.drop(4575)\ndf","2ca4e887":"[gen_zscores(df, nc) for nc in numerical_cols]\ndf","acba665b":"zs = ['zscore_selling_price', 'zscore_km_driven', 'zscore_year', 'zscore_engine', 'zscore_mileage']\n\nfor z in zs:\n    sns.boxplot(df[z])\n    plt.show()","c04110c2":"df = df.drop(zs, axis=1)","04f4ef28":"df = df.drop(['zscore_max_power', 'zscore_seats'], axis=1)","1eac351c":"cats = ['fuel', 'seller_type', 'transmission']\nfor c in cats:\n    sns.countplot(x=c, data=df)\n    plt.show()","af1294bf":"#Wrapper for seller_type\nmapp = {'Individual':0, 'Dealer':1, 'Trustmark Dealer':2}\ndf.seller_type = df.seller_type.replace(mapp)\n\n#Wrapper for fuel\nmapp2 = {'Diesel': 0, 'Petrol': 1, 'LPG': 2, 'CNG': 2}\ndf.fuel= df.fuel.replace(mapp2)\n\n#Simple binary encoding, 0 if manual, 1 if automatic\nmapper = {'Manual':0, 'Automatic':1}\ndf.transmission = df.transmission.replace(mapper)\ndf.transmission.value_counts()\n\ndf","a26b5d73":"df.isna().sum()","ba0d7710":"sns.histplot(x='seats', data=df)","b915c792":"# We will impute the seats NaN values with 5, the most common occurance\ndf.seats = df.seats.fillna(value=5.0)\nprint(f'Number of nans for seats column: {df.seats.isna().sum()}')","5b2243f8":"df = df.drop(['torque'], axis = 1)\ndf","b8392d19":"df.max_power = df.max_power.fillna(value=impute_value_mp)\ndf.isna().sum()","e9ac7ef0":"y = df.selling_price\nX = df.drop('selling_price', axis=1)","c9ca05bc":"#Splitting data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = .25, random_state = 1)\n\n#Scaling the data for Linear Regression\n    \nscaler = StandardScaler()\n\nscaled_X_train = pd.DataFrame(scaler.fit_transform(X_train), columns = X_train.columns)\nscaled_X_test = pd.DataFrame(scaler.transform(X_test), columns = X_test.columns)\n\n# Running linear regression\n\nLR_2 = LinearRegression()\nLR_2.fit(scaled_X_train, y_train)\ny_pred_LR_2 = LR_2.predict(scaled_X_test)\n","23c5801f":"xgbr_2 = XGBRegressor(verbosity=0)\nxgbr_2.fit(X_train, y_train)\ny_pred_X_2 = xgbr_2.predict(X_test)","29062763":"df_metrics","806d64ee":"df_metrics_LR2 = get_metrics(y_pred_LR_2, y_test, 'Linear Regression - Revised')\ndf_metrics_X2 = get_metrics(y_pred_X_2, y_test, 'XGBR - revised')\n\ndf_metrics = pd.concat([df_metrics, df_metrics_LR2, df_metrics_X2], axis=0)\ndf_metrics","1bd02045":"#To be continued...","c5ca563a":"### Linear Regression","851886ee":"#### 'Engine' column","71346c50":"### Part 2. Dealing with categorical values","bc262bbf":"# Back to the drawing-board\n### Let's perform some feature engineering and attempt to fix-up our model","55e91a3e":"### Part 1. Dealing with numerical NaN's","ae32d80c":"Seem to be some outliers, especially that one on the top. Let's get rid of that value using z-scores","ee7dce44":"Conclusion: Linear Regression improved ever so slightly, XGBR got worst","3670d89e":"#### Dealing with 'owner' column and OrdinalEncoder","846ace44":"Assessing the model","c40569ec":"### Assessing model performance","d90f1eb6":"#### OHE","30fd9a5e":"Data looks a bit better in terms of outliers, let's add one final touch","f5d4f11f":"#### Repeating the process for 'max_power'","6c20d2d3":"#### Dealing with 'year'","e27b250a":"### Additional EDA","eb732bb7":"## Hyperparameter Optimization","7fa3b6d0":"We can see that it's pretty heavily skewed, so if you're a first owner that's a lot better than the second third fourth and test drive cars","1c369a47":"#### Dropping the 'torque' column","bd0549e5":"Additional fixes","b8f4620f":"As we previously have done, we'll simply be label encoding the categorical columns in the following manner:\n1. For the seller type, the individual can be a '0', the dealer will be '1', and the trustmark dealer will be '2'.\n2. For fuel we're going to modify it slightly from our previous run: Diesel will be 0, petrol will be 1, and 'LPG' and 'CNG' will both become 2 (the two will effectively be combined into one).\n3. Simple binary encoding for transmission, 0 if manual, 1 if automatic","08ffefb1":"#### Dealing with 'seats'","de2bda96":"#### Let's leave the outlier trimming at this for the time being, we can always return to it and cut some additional data out if our model is not performing to expectations","98cec3b6":"### Model Splitting \/ Training","1a18f9b7":"## Data Cleaning","63db810e":"For this, let's combine the classes of '2nd', '3rd', 'fourth and above', and 'test drive car into one variable'","d4b2cc2c":"#### Replacing null values and doing additional manipulation for 'mileage' column","4bf8c78e":"## Scaling and building our model","191065eb":"### XGBoostRegressor","6ddb4e84":"#### Dealing with 'Transmission' column"}}