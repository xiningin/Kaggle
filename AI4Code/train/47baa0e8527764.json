{"cell_type":{"9b2c9023":"code","c0a0c510":"code","bff4dd75":"code","1ef08e1b":"code","ea8af63e":"code","91cf558a":"code","579fcfc2":"code","c9f7b45c":"code","dd008ddd":"code","6fb02eed":"code","55774599":"code","930fc619":"code","52caa72f":"code","66c2e8ff":"markdown","c286c2ab":"markdown","ab5f2d90":"markdown","4b5a2f40":"markdown"},"source":{"9b2c9023":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","c0a0c510":"import time\nimport torch\nfrom torch import nn, optim\nimport torch.nn.functional as F\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')","bff4dd75":"train=pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")\ntest=pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\nlabel=train[\"label\"]\ntrain=train.drop(labels = [\"label\"],axis = 1) \ntrain=train\/255\ntest=test\/255","1ef08e1b":"train=train.values.reshape(-1,1,28,28) #1,28,28 \u5355\u901a\u9053\uff0c28\u884c 28\u5217 # \u7531\u4e8e\u4f7f\u7528\u56fe\u50cf\u589e\u5e7f\uff0c\u53bb\u6389\u4e00\u7ef4\ntest=test.values.reshape(-1,1,28,28) #1,28,28 \u5355\u901a\u9053\uff0c28\u884c 28\u5217","ea8af63e":"from keras.preprocessing.image import ImageDataGenerator\n#  randomly rotating, scaling, and shifting\n# CREATE MORE IMAGES VIA DATA AUGMENTATION\ndatagen = ImageDataGenerator(\n        rotation_range=10,  \n        zoom_range = 0.10,  \n        width_shift_range=0.1, \n        height_shift_range=0.1\n        )","91cf558a":"train=torch.tensor(train, dtype=torch.float)\nlabel=torch.tensor(label.values, dtype=torch.float)\nbatch_size = 32\ntrain_data = torch.utils.data.TensorDataset(train,label)\ntrain_iter = torch.utils.data.DataLoader(train_data, batch_size=batch_size, shuffle=True )","579fcfc2":"# \u6b8b\u5dee\u7f51\u7edc\nclass Residual(nn.Module): \n    def __init__(self, in_channels, out_channels, use_1x1conv=False, stride=1):\n        super(Residual, self).__init__()\n        self.conv1 = nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1, stride=stride)\n        self.conv2 = nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1)\n        if use_1x1conv:\n            self.conv3 = nn.Conv2d(in_channels, out_channels, kernel_size=1, stride=stride)\n        else:\n            self.conv3 = None\n        self.bn1 = nn.BatchNorm2d(out_channels)\n        self.bn2 = nn.BatchNorm2d(out_channels)\n\n    def forward(self, X):\n        Y = F.relu(self.bn1(self.conv1(X)))\n        Y = self.bn2(self.conv2(Y))\n        if self.conv3:\n            X = self.conv3(X)\n        return F.relu(Y + X)","c9f7b45c":"# \u6b8b\u5dee\u5757\ndef resnet_block(in_channels, out_channels, num_residuals, first_block=False):\n    if first_block:\n        assert in_channels == out_channels # \u7b2c\u4e00\u4e2a\u6a21\u5757\u7684\u901a\u9053\u6570\u540c\u8f93\u5165\u901a\u9053\u6570\u4e00\u81f4\n    blk = []\n    for i in range(num_residuals):\n        if i == 0 and not first_block:\n            blk.append(Residual(in_channels, out_channels, use_1x1conv=True, stride=2))\n        else:\n            blk.append(Residual(out_channels, out_channels))\n    return nn.Sequential(*blk)","dd008ddd":"net = nn.Sequential(\n    nn.Conv2d(1, 32, kernel_size=7, stride=2, padding=3),\n    nn.BatchNorm2d(32), \n    nn.ReLU(),\n    nn.MaxPool2d(kernel_size=3, stride=2, padding=1),\n    resnet_block(32, 32, 2, first_block=True),\n    resnet_block(32, 64, 2),\n    resnet_block(64, 128, 2),\n    resnet_block(128, 256, 2),\n    nn.AdaptiveAvgPool2d((1,1)),\n    nn.Flatten(),\n    nn.Linear(256,10),\n)","6fb02eed":"lr=0.0015\ndecay=0\nnum_epochs=30\nloss=nn.CrossEntropyLoss()\noptimizer = optim.Adam(net.parameters(), lr=lr)","55774599":"def train_net(net, train_iter,loss, num_epochs, lr, optimizer):\n    for epochs in range(num_epochs):\n        for x,y in train_iter:\n            # \u6ce8\u610f\u6700\u540e\u4e00\u6b21\u7684\u6570\u636e\u4e0d\u4e00\u5b9a\u662f\u7b26\u5408batch_size\u7684 \u6240\u4ee5\u7528x.shape[0]\u4ee3\u66ff\n            if (epochs % 2)==0:\n                b=np.array([datagen.flow(x[i:i+1]).next()[0] for i in range(x.shape[0])])\n                x=torch.tensor(b, dtype=torch.float)\n            y_hat=net(x) #\u6a21\u578b\u8ba1\u7b97\n            l=loss(y_hat,y.long()) #\u635f\u5931\u8ba1\u7b97\n            optimizer.zero_grad() #\u68af\u5ea6\u6e050\n            l.backward() #\u53cd\u5411\u4f20\u64ad\n            optimizer.step()\n        print(\"epochs:\"+str(epochs)+\" loss:\"+str(l))\n        \ntrain_net(net,train_iter,loss, num_epochs, lr, optimizer)","930fc619":"test=torch.tensor(test, dtype=torch.float)\nsub=net(test)\nsub=sub.argmax(dim=1)\nsub=sub.numpy()\nsub.reshape(-1,1)\nsubmission=pd.read_csv(\"..\/input\/digit-recognizer\/sample_submission.csv\")\nsubmission[\"Label\"]=sub\nsubmission.to_csv('submission.csv', index=False)","52caa72f":"submission","66c2e8ff":"\u8bad\u7ec3","c286c2ab":"\u6784\u5efa\u6a21\u578b","ab5f2d90":"\u9884\u6d4b","4b5a2f40":"* - \u4f7f\u7528resnet+\u56fe\u50cf\u589e\u5f3a 0.99171 692\n- \u589e\u5927\u901a\u9053\u6570  0.99214  649"}}