{"cell_type":{"701bc010":"code","168cc539":"code","64af795c":"code","7c2137dc":"code","0ebe320a":"code","c3146c63":"code","1ba7d284":"code","4efb32a1":"code","20febc36":"code","777ace42":"code","401bb9eb":"code","fdc3435b":"code","5d26f159":"code","69ff6686":"code","aa12a032":"code","dfaa8d0a":"code","1efa9695":"code","cd31128d":"code","7d89b967":"code","b4ffdaed":"code","4af79af8":"code","644500ca":"markdown","ded3f4cc":"markdown","c6549df1":"markdown","625ea6ff":"markdown","90704c29":"markdown","b596c4b9":"markdown","c787da38":"markdown","95510df1":"markdown","f74194dc":"markdown"},"source":{"701bc010":"! pip uninstall --y kaggle\n! pip install --upgrade pip\n! pip install kaggle==1.5.6\n\n! mkdir -p ~\/.kaggle\n!cp kaggle.json ~\/.kaggle\/\n! chmod 600 ~\/.kaggle\/kaggle.json\n!kaggle -v","168cc539":"import pandas as pd\nimport numpy as np\n\nimport torch\nimport torchvision.datasets as data\nimport torchvision.transforms as transforms\nimport random\n\nfrom sklearn import preprocessing","64af795c":"device = 'cuda' if torch.cuda.is_available() else 'cpu'\n\nrandom.seed(777)\ntorch.manual_seed(777)\nif device == 'cuda':\n  torch.cuda.manual_seed_all(777)","7c2137dc":"learning_rate = 1e-4\ntraining_epoches = 100\nbatch_size = 50\nScaler = preprocessing.StandardScaler()","0ebe320a":"! kaggle competitions download -c 2020soil","c3146c63":"! unzip 2020soil.zip","1ba7d284":"train = pd.read_csv('2020AI_soil_train.csv', header=None, skiprows=1,usecols=range(1,9))\n\ntrain","4efb32a1":"test = pd.read_csv('2020_soil_test.csv', header = None, skiprows=1, usecols=range(1,8))\n\ntest","20febc36":"x_train = train.loc[:,1:7]\ny_train = train.loc[:,8:8]\n\nx_train = np.array(x_train)\ny_train = np.array(y_train)\n\nx_train = torch.FloatTensor(x_train)\ny_train = torch.FloatTensor(y_train)","777ace42":"train_dataset = torch.utils.data.TensorDataset(x_train, y_train)\n\ndata_loader = torch.utils.data.DataLoader(dataset = train_dataset,\n                                          batch_size = batch_size,\n                                          shuffle = True,\n                                          drop_last=True)","401bb9eb":"linear1 = torch.nn.Linear(7,32, bias = True) # feature\nlinear2 = torch.nn.Linear(32,32, bias = True)\nlinear3 = torch.nn.Linear(32,32, bias = True)\nlinear4 = torch.nn.Linear(32,16, bias = True)\nlinear5 = torch.nn.Linear(16,16, bias = True)\nlinear6 = torch.nn.Linear(16,16, bias = True)\nlinear7 = torch.nn.Linear(16,8, bias = True)\nlinear8 = torch.nn.Linear(8,8, bias = True)\nlinear9 = torch.nn.Linear(8,8, bias = True)\nlinear10 = torch.nn.Linear(8,1, bias = True)","fdc3435b":"torch.nn.init.xavier_uniform_(linear1.weight)\ntorch.nn.init.xavier_uniform_(linear2.weight)\ntorch.nn.init.xavier_uniform_(linear3.weight)\ntorch.nn.init.xavier_uniform_(linear4.weight)\ntorch.nn.init.xavier_uniform_(linear5.weight)\ntorch.nn.init.xavier_uniform_(linear6.weight)\ntorch.nn.init.xavier_uniform_(linear7.weight)\ntorch.nn.init.xavier_uniform_(linear8.weight)\ntorch.nn.init.xavier_uniform_(linear9.weight)\ntorch.nn.init.xavier_uniform_(linear10.weight)","5d26f159":"model = torch.nn.Sequential(linear1,\n                            linear2,\n                            linear3,\n                            linear4,\n                            linear5,\n                            linear6,\n                            linear7,\n                            linear8,\n                            linear9,\n                            linear10).to(device)","69ff6686":"loss = torch.nn.MSELoss().to(device)\noptimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)","aa12a032":"total_batch = len(data_loader)\n\nfor epoch in range(training_epoches):\n  avg_cost = 0\n\n  for X, Y in data_loader:\n\n    X = X.to(device)\n    Y = Y.to(device)\n\n    optimizer.zero_grad()\n    hypothesis = model(X)\n    cost = loss(hypothesis, Y)\n    cost.backward()\n    optimizer.step()\n\n    avg_cost += cost \/ total_batch\n  \n  print('Epoch:','%04d' % (epoch+1), 'cost=', '{:.9f}'.format(avg_cost))\nprint('Learning finshed')","dfaa8d0a":"with torch.no_grad():\n  x_test = test.loc[:,1:7]\n  x_test = np.array(x_test)\n\n  x_test = torch.from_numpy(x_test).float().to(device)\n\n  prediction = model(x_test)","1efa9695":"correct_prediction = prediction.cpu().numpy().reshape(-1,1)","cd31128d":"submit = pd.read_csv('soil_submission.csv')\nsubmit","7d89b967":"for i in range(len(correct_prediction)):\n  submit['Expected'][i] = correct_prediction[i].item()\n\nsubmit","b4ffdaed":"submit.to_csv('1\ucc28\uc2dc\ub3c4.csv', mode='w', index = False)","4af79af8":"! kaggle competitions submit -c 2020soil -f 1\ucc28\uc2dc\ub3c4.csv -m \"Message\"","644500ca":"## \ud30c\ub77c\ubbf8\ud130 \uc124\uc815","ded3f4cc":"## \uc81c\ucd9c \uc591\uc2dd","c6549df1":"## \uce90\uae00 \uc5f0\uacb0","625ea6ff":"## GPU \uc0ac\uc6a9","90704c29":"## \uae30\uc874 Base Line\uacfc \ub2e4\ub978 \uc810\n- \uae30\uc874\uc758 baseline \ucf54\ub4dc\uc758 \uacbd\uc6b0 \ub2e8\uc21c \uc120\ud615 \ud68c\uadc0 \ubb38\uc81c\ub97c \ud478\ub294 \ubc29\uc2dd\uc73c\ub85c, SGD \uc635\ud2f0\ub9c8\uc774\uc800\ub97c \uc774\uc6a9\ud55c \ucf54\ub4dc\uc600\uc74c\n- \uac01 col\uc758 \ub370\uc774\ud130 \uac12\uc758 \ucc28\uc774\uac00 \ucee4 MinMaxScaler()\ub97c \uc0ac\uc6a9\ud588\ub358 \uac83 \uac19\uc74c\n\n- **\ucc28\uc774\uc810) \uc774 \ubb38\uc81c\ub97c NN\uc73c\ub85c \ud480\uc5c8\uc74c. Layer\ub97c 10\uac1c\ub85c \uc313\uace0 output\uac12\uc744 7->32->16->8->1\ub85c \ubc14\uafd4\uc11c \ucd5c\uc885 \uac12\uc744 \ub0b4\ub294 \uc2dd\uc73c\ub85c \ud568.**","b596c4b9":"## \ubaa8\ub378 \ud559\uc2b5","c787da38":"## \ubaa8\ub4c8 \uc784\ud3ec\ud2b8","95510df1":"## DNN layer \uc313\uae30 \ubc0f \ubaa8\ub378 \ucd08\uae30\ud654","f74194dc":"## \ub370\uc774\ud130 \ub85c\ub4dc"}}