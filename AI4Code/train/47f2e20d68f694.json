{"cell_type":{"b56710d5":"code","82c53e69":"code","4c98280b":"code","ba953f69":"code","e77976d2":"markdown","89e092ad":"markdown","bf2b702d":"markdown","3b9c929c":"markdown","c338bcb2":"markdown","c9b008f0":"markdown"},"source":{"b56710d5":"import requests\nimport pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport networkx as nx\nimport plotly.graph_objects as go","82c53e69":"def get_toptier_agency_info():\n    url = 'https:\/\/api.usaspending.gov\/api\/v2\/references\/toptier_agencies\/'\n    response = requests.get(url).json()\n    df = pd.json_normalize(response, 'results')\n    df.set_index('abbreviation', inplace = True)\n    return df\n\ndef get_agency_toptier_code(agency_abbreviation):\n    df = get_toptier_agency_info()\n    toptier_code = df.loc[agency_abbreviation]['toptier_code']\n    return df, toptier_code\n\ndef get_agency_name(agency_abbreviation):\n    df = get_toptier_agency_info()\n    name = df.loc[agency_abbreviation]['agency_name']\n    return name\n\ndef get_agency_object_classes(agency_abbreviation, fiscal_year):\n    hasNext = True\n    page = 1\n    toptier_code = get_agency_toptier_code(agency_abbreviation)\n\n    while hasNext == True:\n\n        url = 'https:\/\/api.usaspending.gov\/api\/v2\/agency\/{toptier_code}\/object_class\/'\n        url = url.format(toptier_code = toptier_code)\n        fiscal_year = str(fiscal_year)\n\n        params = {'fiscal_year': fiscal_year, 'page':page}\n        response = requests.get(url, params = params).json()\n\n        hasNext = response['page_metadata']['hasNext']\n        page = response['page_metadata']['page']+1\n\n        if 'df' not in locals():\n            df = pd.json_normalize(response, 'results').set_index('name')\n        else:\n            df = pd.concat([df, pd.json_normalize(response, 'results').set_index('name')])\n    return df\n\ndef get_agency_budget_functions(agency_abbreviation, fiscal_year):\n    \n    hasNext = True\n    page = 1\n    toptier_code = get_agency_toptier_code(agency_abbreviation)\n\n    while hasNext == True:\n        url = 'https:\/\/api.usaspending.gov\/api\/v2\/agency\/{toptier_code}\/budget_function\/'\n        url = url.format(toptier_code = toptier_code)\n        fiscal_year = str(fiscal_year)\n\n        params = {'fiscal_year': fiscal_year, 'page':page}\n        response = requests.get(url, params = params).json()\n\n        hasNext = response['page_metadata']['hasNext']\n        page = response['page_metadata']['page']+1\n\n        if 'df' not in locals():\n            df = pd.json_normalize(response, ['results','children'], [['results','name']])\n            df = df.rename(columns={\"name\":\"subfunction\", 'results.name':'main_function'})\n        else:\n            df = pd.concat([df, pd.json_normalize(response, ['results','children'], [['results','name']]).rename(columns={\"name\":\"subfunction\", 'results.name':'main_function'})])\n            \n    return df\n\ndef get_tree_branches(df):\n    \n    if 'children' in df.columns:\n        for index, row in df.iterrows():\n            if row['children'] != np.nan:\n                \n                df1 = pd.json_normalize(row['children'])\n                \n                df1['parent'] = row['name']\n                df1['tier'] = 'office'\n                \n                if 'name' in df1.columns:\n                    df1['name'] = df1['name']+' (office)'\n                \n            if 'children' in df1.columns:\n                get_tree_brances(df1)\n            \n            df = pd.concat([df,df1])\n            \n        del df['children']\n          \n    return df\n\ndef get_agency_structure(agency_abbreviation, fiscal_year, agency_info = None):\n    \n    hasNext = True\n    page = 1\n    limit = 1\n    \n    if agency_info is None:\n        agency_info, toptier_code = get_agency_toptier_code(agency_abbreviation)\n    \n    else:\n        toptier_code = agency_info.loc[agency_abbreviation]['toptier_code']\n\n    while  hasNext == True:\n\n        params = {'fiscal_year': fiscal_year, 'page':page}\n        url = 'https:\/\/api.usaspending.gov\/api\/v2\/agency\/{toptier_code}\/sub_agency\/'\n        url = url.format(toptier_code = toptier_code)\n        response = requests.get(url, params = params).json()\n\n        hasNext = response['page_metadata']['hasNext']\n        page = response['page_metadata']['page']+1\n\n        if 'df' not in locals():\n            if len(response['results'])>0:\n                df = pd.json_normalize(response['results'])\n                df['name'] = df['name']+ ' (subagency)'\n            else: \n                return None, None, None\n        else:\n            \n            df1 = pd.json_normalize(response['results'])\n            df1['name'] = df1['name']+ ' (subagency)'\n            df = pd.concat([df, df1])\n\n        df['parent'] = agency_info.loc[agency_abbreviation]['agency_name']+ ' (agency)'\n        \n        df['tier'] = 'subagency'\n        ##add type 'subagency' as 'type'\n    \n    df = get_tree_branches(df)\n    ## change method to get_get_agency_offices add 'office' as 'type'\n    return agency_info, toptier_code, df\n\ndef aggregate_duplicate_offices(df, toptier):\n    \n    #change to only aggregate if data points are same tier, e.g dont combine an office with \n    #a subangency etc. \n    duplicates_df = df[df.reset_index().duplicated(subset = 'name', keep = False).tolist()]\n    unique_dup_indexes = np.unique(duplicates_df.index)\n\n    toptier = toptier\n\n    for index in unique_dup_indexes:\n\n        df1 = duplicates_df.loc[index]\n\n\n        if df1['abbreviation'].nunique()==1:\n            abbreviation = np.unique(df1['abbreviation'])[0]\n\n        else: \n            for val in np.unique(df1['abbreviation']):\n                if val != 'N\/A':\n                    abbreviation = val\n\n        total_obligations = sum(df1['total_obligations'])         \n        transaction_count =sum(df1['transaction_count'])\n        new_award_count = sum(df1['new_award_count'])\n        tier = np.unique(df1['tier'])[0]\n        if toptier in df1['parent'].unique():\n            parent= toptier\n\n        else:\n            parent = df1['parent'].unique()[0]\n\n        row_dict = {'abbreviation':[abbreviation], 'total_obligations': [total_obligations],\n                   'transaction_count': [transaction_count],'new_award_count':[new_award_count], 'parent':\n                   [parent], 'tier':tier}\n        if 'agg_df' not in locals():\n            agg_df = pd.DataFrame.from_dict(row_dict)\n            agg_df.index = [index]\n\n        else: \n            row = pd.DataFrame.from_dict(row_dict)\n            row.index = [index]\n            agg_df = pd.concat([agg_df,row])\n\n    if 'agg_df' in locals():\n        df = df.drop(index = unique_dup_indexes)\n        df = pd.concat([df, agg_df])\n    return df\n\n        \n\ndef get_toptier_agency_award_info(toptier_code, fiscal_year, agency_abbreviation, agency_name):\n    params = {'fiscal_year': str(fiscal_year)}\n    url = 'https:\/\/api.usaspending.gov\/api\/v2\/agency\/{toptier_code}\/awards\/'\n    url = url.format(toptier_code = toptier_code)\n    response = requests.get(url, params = params).json()\n    transaction_count = response['transaction_count']\n    obligations = response['obligations']\n    url = 'https:\/\/api.usaspending.gov\/api\/v2\/agency\/{toptier_code}\/awards\/new\/count'\n    url = url.format(toptier_code = toptier_code)\n    response = requests.get(url, params = params).json()\n    new_award_count = response['new_award_count']\n    tier = 'agency'\n\n    row_dict = {'name':agency_name, 'abbreviation':[agency_abbreviation], 'total_obligations': [obligations], \n                'transaction_count':[transaction_count], 'new_award_count': [new_award_count],\n               'parent': ['Executive Branch'], 'tier': [tier]}\n\n    row = pd.DataFrame.from_dict(row_dict)\n    \n    return row\n\ndef get_government_totals(df):\n    agency_name = 'Executive Branch'\n    abbreviation = 'N\/A'\n    total_obligations = sum(df.loc[df['tier']=='agency']['total_obligations'])\n    transaction_count = sum(df.loc[df['tier']=='agency']['transaction_count'])\n    new_award_count = sum(df.loc[df['tier']=='agency']['new_award_count'])\n    parent = 'N\/A'\n    tier = 'top tier'\n\n    row_dict = {'name':agency_name, 'abbreviation':[abbreviation], 'total_obligations': [total_obligations], \n                    'transaction_count':[transaction_count], 'new_award_count': [new_award_count],\n                   'parent': [parent], 'tier': [tier]}\n\n    row = pd.DataFrame.from_dict(row_dict)\n    return row\n\ndef plot_agency_structure(agency_abbreviation, fiscal_year, limit = None, return_df = False):\n    \n    if agency_abbreviation != 'All':\n        agency_info, toptier_code, df = get_agency_structure(agency_abbreviation, fiscal_year)\n        agency_name = agency_info.loc[agency_abbreviation]['agency_name']+' (agency)'\n\n    else:\n        df = get_government_structure(fiscal_year, limit = limit)\n        agency_name = 'Executive Branch'\n    \n    df = df.set_index('name')\n    df = df.fillna('N\/A')\n    \n    df = aggregate_duplicate_offices(df, agency_name)\n\n    edges = list(zip(df.index,df['parent']))\n    \n    if agency_abbreviation != 'All':\n        row = get_toptier_agency_award_info(toptier_code, fiscal_year, agency_abbreviation, agency_name)\n    \n    else:\n        row = get_government_totals(df)\n    \n    row = row.set_index('name')\n    df.index.name = 'name'\n\n    df = pd.concat([df, row])\n    \n    G = nx.Graph()\n    G.add_edges_from(edges)\n\n    pos = nx.spring_layout(G, dim = 3)\n    pos = pd.DataFrame.from_dict(pos, orient = 'index', columns = ['x', 'y', 'z'])\n    pos.index.name = 'name'\n    pos = pos.merge(df, how = 'inner', left_index =True, right_index = True)\n    pos['name'] = pos.index\n\n    pos['log_obligations'] =pos['total_obligations'].apply(lambda x: np.log10(x))\n\n    hover_data = {'x':False, 'y':False, 'z' : False, 'name':True, 'parent':True,\n                 'total_obligations': True, 'transaction_count':True}\n    \n    if agency_abbreviation != 'All':\n        symbol_map = {'agency': 'x', 'subagency':'square', 'office':'circle'}\n    else:\n        symbol_map = {'agency': 'square', 'subagency':'circle', 'office':'circle-open', 'top tier':'x'}\n\n    fig = px.scatter_3d(pos, x='x', y='y', z='z',\n                  hover_data = hover_data, color = 'log_obligations', title = agency_name,\n                       symbol = 'tier', symbol_map = symbol_map)\n    fig.update_layout(showlegend=False)\n\n\n    for index,row in pos.iterrows():\n        if index != agency_name:\n            df1 = pos.loc[[index, row['parent']]]\n\n            fig.add_trace(go.Scatter3d(x = df1['x'],\n                          y=df1['y'],\n                          z= df1['z'],\n                          mode='lines',\n                            line=dict(color='rgb(0,0,0)', width=5),\n                           hoverinfo='none'),\n\n                         )\n\n            fig.update_scenes(yaxis_showticklabels=False)\n            fig.update_scenes(xaxis_showticklabels=False)\n            fig.update_scenes(zaxis_showticklabels=False)\n    fig.show()\n    if return_df == True: \n        return df\n\ndef get_government_structure(fiscal_year, limit = None):\n    params = {'depth': 0}\n    url = 'https:\/\/api.usaspending.gov\/api\/v2\/references\/filter_tree\/tas\/'\n    response = requests.get(url, params = params).json()\n    df = pd.json_normalize(response['results'])\n    df= df.set_index('id')\n    df = df.drop(index = '310', axis = 0)\n    abbreviations = df.description.apply(lambda x: str.split(x)[-1][1:-1]).tolist()\n    agency_info = get_toptier_agency_info()\n    abbreviations = list(set(abbreviations).intersection(agency_info.index))\n    \n    if limit is not None:\n        agency_info = agency_info.reindex(abbreviations).sort_values(by = 'obligated_amount', ascending = False).iloc[:limit]\n        abbreviations = agency_info.index.to_list()\n        \n    del df\n    for abbreviation in abbreviations:\n        toptier_code = agency_info.loc[abbreviation]['toptier_code']\n        agency_name = agency_info.loc[abbreviation]['agency_name']+' (agency)'\n        if 'df' not in locals():\n            df = get_agency_structure(abbreviation, fiscal_year, agency_info = agency_info)[2]\n        else:\n            df1 = get_agency_structure(abbreviation, fiscal_year, agency_info = agency_info)[2]\n            df = pd.concat([df,df1])\n\n        row = get_toptier_agency_award_info(toptier_code, fiscal_year, abbreviation, agency_name)\n        df= pd.concat([df, row])\n    return df","4c98280b":"plot_agency_structure('All', 2021, limit = 15, return_df = False)\n","ba953f69":"plot_agency_structure('USDA', 2020, return_df = False)","e77976d2":"This is just an example of using the function to only plot a particular federal agency, ie. the department of Agriculture during the 2020 fiscal year. In this case, solid circles indicate offices and squares indicate subagencies. ","89e092ad":"## Imports","bf2b702d":"## Helper Functions\n\nThe cell below defines various helper functions for making API calls, preprocessing and plotting the data.","3b9c929c":"## Background\n\nIn 2014,the United States congress passed the Digital Accountability and Transparency Act (DATA Act) requiring federal government to make federal agency expenditure data available to the American public to foster government transparency regarding how tax dollars are spent.  Data is collected from multiple sources and stored on a publicly available database, which can be accessed using an API hosted at https:\/\/www.usaspending.gov\/. You can read the documentation for making requests to this API [here](https:\/\/api.usaspending.gov\/docs\/endpoints). The graphic below shows an overview of how the data is collected. \n\n\n![](https:\/\/www.usaspending.gov\/img\/daims-information-flow-diagram-v2.0.jpg)","c338bcb2":"## Methodology\n\nUsing the <code>requests<\/code> library, obligation data related to agencies, sub-agencies and offices are requested from the USASpending API. (An obligation in this context refers to when an agency, sub-agency or office of the federal government enters into a binding agreement to spend money either immediately or sometime in the future.). Using <code>networkx<\/code> a hierarchical graph representing the relationship between agencies, sub-agencies and offices is created and plotted using <code>plotly<\/code>. Nodes are color coded based on the log10 obligation amount of the particular node (e.g. a log10 obligation of 12 indicates a trillion dollar obligation for an agency). Node markers denote the tier of node with squares indicating agencies, closed circles indicating sub-agencies and open circles indicating offices. Plotly natively allows viewers to interact with the plot by zooming, panning or rotating the plot as desired. Hovering a mouse over a particular node causes information related to that node to pop-up in a tag. The plot is constructed using the helper function <code>plot_agency_structure()<\/code> defined in the code cell above. The \u2018All\u2019 parameter value tells the function that we are plotting the entire government hierarchy and not just the hierarchy of a particular agency which is also possible using the agency's official abbreviation (e.g. DOD). The \u20182021\u2019 parameter value tells the function to request data from the given fiscal year. The limit = 15 parameter value tells the function to only plot the top 15 agencies with the highest obligations. The limit parameter is set to None by default which would plot the entire federal government graph.","c9b008f0":"## Goals\n\nThe goal of this notebook is to gain practice requesting data from an API and using this data to make one or more visualizations."}}