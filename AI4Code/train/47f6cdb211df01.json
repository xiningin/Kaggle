{"cell_type":{"e93e25d9":"code","80eee300":"code","026e8350":"code","5ed83fde":"code","6d947c40":"code","fce2324a":"code","a87edf63":"code","b0c16a96":"code","d88e3330":"code","92df6d03":"code","e491258f":"code","271d0b09":"code","9f38f0b0":"code","3862ce2b":"code","d1f21121":"markdown","b39e75b8":"markdown"},"source":{"e93e25d9":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport matplotlib\nfrom plotly.offline import iplot, plot\nimport plotly.graph_objs as go","80eee300":"data = pd.read_csv('\/kaggle\/input\/grallrounds\/Grants Results History Round over Round  Grant over Grant - GR1-GR12.csv')\n\ndef fill_missing_values(df):\n    df.total = df.total.apply(lambda x: str(x).replace(',', '').replace('$', '')).astype(float)\n    df.crowdfund_amount_contributions_usd = df.crowdfund_amount_contributions_usd.apply(lambda x: str(x).replace('$', '').replace(',', '')).astype(float)\n    df.match_amount = df.match_amount.apply(lambda x: str(x).replace('$', '').replace(',', '')).astype(float)\n    return df\n\ndata = fill_missing_values(data)\n\ndf = data.groupby(['round_number','region']).agg(grant_uniq=(\"grant_title\", \"nunique\"), total_sum=(\"total\", \"sum\"), total_mean=(\"total\", \"mean\"), unique_contributors_mean=(\"num_unique_contributors\", \"mean\")\n                                 ,match_mean=(\"match_amount\", \"mean\"), mode=(\"category\", lambda x:x.value_counts().index[0]),\n                                  crowdsourced_mean=(\"crowdfund_amount_contributions_usd\", \"mean\")\n                                 )\ndf","026e8350":"d = data.groupby(['region']).agg(grant_uniq=(\"grant_title\", \"nunique\"), total_sum=(\"total\", \"sum\"), total_mean=(\"total\", \"mean\"), unique_contributors_mean=(\"num_unique_contributors\", \"mean\")\n                                 ,match_mean=(\"match_amount\", \"mean\"), mode=(\"category\", lambda x:x.value_counts().index[0]),\n                                  crowdsourced_mean=(\"crowdfund_amount_contributions_usd\", \"mean\")\n                                 ).sort_values('grant_uniq')\nd","5ed83fde":"# Creating trace1\ntrace1 = go.Scatter(\n                    x = df.unstack().index,\n                    y = df.unstack()[('grant_uniq','north_america')],\n                    mode = \"lines\",\n                    name = \"North America\",\n                    marker = dict(color = 'rgba(16, 112, 2, 0.8)'),\n                    text= df.index)\n# Creating trace2\ntrace2 = go.Scatter(\n                    x = df.unstack().index,\n                    y = df.unstack()[('grant_uniq','europe')],\n                    mode = \"lines+markers\",\n                    name = \"europe\",\n                    marker = dict(color = 'rgba(80, 26, 80, 0.8)'),\n                    text= df.index)\n\ntrace3 = go.Scatter(\n                    x = df.unstack().index,\n                    y = df.unstack()[('grant_uniq','none')],\n                    mode = \"lines+markers\",\n                    name = \"none\",\n                    marker = dict(color = 'rgba(20, 26, 80, 0.4)'),\n                    text= df.index)\n\ntrace4 = go.Scatter(\n                    x = df.unstack().index,\n                    y = df.unstack()[('grant_uniq','undefined')],\n                    mode = \"lines+markers\",\n                    name = \"undefined\",\n                    marker = dict(color = 'rgba(0, 86, 80, 0.6)'),\n                    text= df.index)\n\ndata = [trace1, trace2, trace3, trace4]\n\nlayout = dict(title = 'Regions over time',\n              xaxis= dict(title= 'Gitcoin Round',ticklen= 5,zeroline= False)\n             )\nfig = dict(data = data, layout = layout)\niplot(fig)","6d947c40":"def continent(row):\n    if row == 'africa':\n        return \"Africa\"\n    elif row in (\"east_asia\", \"southeast_asia\", \"india\", \"middle_east\"):\n        return \"Asia\"\n    elif row in (\"europe\"):\n        return \"Europe\"\n    elif row in (\"latin_america\"):\n        return \"South America\"\n    elif row in (\"oceania\"):\n        return \"Oceania\"\n    elif row in (\"north_america\"):\n        return \"North America\"\n    else:\n        return np.nan\n    \nd['continent'] = d.index.map(continent)\nd = d.groupby(['continent']).agg(grant_uniq=(\"grant_uniq\", \"sum\"), total_sum=(\"total_sum\", \"sum\"), total_mean=(\"total_mean\", \"mean\"), unique_contributors_mean=(\"unique_contributors_mean\", \"mean\"),\n                                  match_mean=(\"match_mean\", \"mean\"), mode=(\"mode\", lambda x:x.value_counts().index[0]),\n                                  crowdsourced_mean=(\"crowdsourced_mean\", \"mean\")\n                                 )","fce2324a":"world = gpd.read_file(gpd.datasets.get_path(\"naturalearth_lowres\")).drop(['gdp_md_est'], axis=1)\nworld = world.dissolve(by='continent', aggfunc='sum')\nworld = world.merge(d, how='inner', left_on='continent', right_index=True)","a87edf63":"cmap = plt.cm.rainbow\nnorm = matplotlib.colors.Normalize(vmin=world.total_mean.min(), vmax=world.total_mean.max())\n\nworld.plot(column='total_mean', cmap=cmap, figsize=(20, 10))\nplt.title('Total by Continent')\nplt.box(False)\nsm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)\n\n\nplt.colorbar(sm)\n\nplt.gca().spines['top'].set_visible(False)\nplt.gca().spines['right'].set_visible(False)\n\nplt.xlabel('longitude')\nplt.ylabel('latitude')\nplt.savefig('base.png', format='png')","b0c16a96":"from bokeh.io import output_notebook\nfrom bokeh.plotting import figure, ColumnDataSource\nfrom bokeh.io import output_notebook, show, output_file\nfrom bokeh.plotting import figure\nfrom bokeh.models import GeoJSONDataSource, LinearColorMapper, ColorBar, HoverTool\nfrom bokeh.palettes import brewer\noutput_notebook()\nimport json\n\n#Convert data to geojson for bokeh\nwi_geojson=GeoJSONDataSource(geojson=world.to_json())","d88e3330":"world['continent'] = world.index","92df6d03":"world['total_funds_per_capita'] = world.total_sum \/ world.pop_est","e491258f":"world.total_funds_per_capita.sort_values()","271d0b09":"world.columns","9f38f0b0":"world['match_mean_per_total_mean'] = world.match_mean \/ world.total_mean","3862ce2b":"color_mapper = LinearColorMapper(palette = brewer['RdBu'][10], low = world.unique_contributors_mean.min(), high = world.unique_contributors_mean.max())\n\ncolor_bar = ColorBar(color_mapper=color_mapper, label_standoff=8, width = 500, height = 20,\n                     border_line_color=None,location = (0,0), orientation = 'horizontal')\n\nhover = HoverTool(tooltips = [ ('Unique Contributors Mean per row', '@unique_contributors_mean'),('Number of Unique grants','@grant_uniq'),('Population Estimate','@pop_est'),\n                               ('Match Mean', '@match_mean'),('Crowdsourced Mean', '@crowdsourced_mean'),('Total Mean', '@total_mean'),('match_mean_per_total_mean', '@match_mean_per_total_mean')\n                             ])\np = figure(title=\"Coninent Data\", tools=[hover])\np.patches(\"xs\",\"ys\",source=wi_geojson,\n          fill_color = {'field' :'unique_contributors_mean', 'transform' : color_mapper})\np.add_layout(color_bar, 'below')\nshow(p)","d1f21121":"From this map fair to day that redistribution does not particularly work\n","b39e75b8":"https:\/\/datascience.quantecon.org\/applications\/maps.html"}}