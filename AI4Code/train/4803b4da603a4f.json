{"cell_type":{"27dcd31a":"code","3c4f06b3":"code","87bcc424":"code","43a2456c":"code","52091ddb":"code","8b4d6cfe":"code","ff769d7b":"code","70605d57":"code","ad15ffc0":"code","daf1fb1f":"code","10b9bc59":"code","2949b10b":"code","7d902cee":"code","be767fda":"code","2f1d7c78":"markdown","89cc848a":"markdown","13f288c2":"markdown","acec7741":"markdown","8ff37967":"markdown","dddb070a":"markdown","a167b0c9":"markdown","41ca4ce6":"markdown","9ef2c87b":"markdown","5427978d":"markdown","b947dcb3":"markdown","7ad6f9f4":"markdown"},"source":{"27dcd31a":"import numpy as np # linear algebra\n\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport matplotlib.pyplot as pyplot\n%matplotlib inline\n\nfrom statsmodels.graphics.tsaplots import plot_acf\nfrom statsmodels.tsa import stattools\n\nimport sklearn\nimport sklearn.model_selection as skms\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.preprocessing import OneHotEncoder\n\nfrom xgboost import XGBRegressor\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n        \nprint(\"Setup Complete\")","3c4f06b3":"def score_dataset(X_train, y_train, X_test, y_test):\n    # low learning rate and many rounds to prevent underfitting\n    model = XGBRegressor(eval_metric='mae',n_estimators=5000, learning_rate = 0.05)\n    # early_stopping_rounds to prevent overfitting\n    model.fit(X_train, y_train, early_stopping_rounds = 8, eval_set = [(X_test, y_test)], verbose=False)\n    predictions = model.predict(X_test)\n    # mae, predictions for each X_test\n    return mean_absolute_error(y_test, predictions), predictions # mean_absolute_error metric","87bcc424":"# read data\npath = \"\/kaggle\/input\/instruments-solarflares\/flares_and_instruments_v2.csv\"\ndf = pd.read_csv(path, header=0, index_col=0) \n# format time data from string to datetime\ndf['JJJ Start'] = pd.to_datetime(df['JJJ Start'])\ndf['JJJ Peak'] = pd.to_datetime(df['JJJ Peak'])\ndf['JJJ End'] = pd.to_datetime(df['JJJ End'])\n# Feature engineering using the time between Start and Peak to help predict \"Peak to end\" time\ndf['time to peak'] = (df['JJJ Peak'] - df['JJJ Start']).dt.seconds\ndf['peak to end'] = (df['JJJ End'] - df['JJJ Peak']).dt.seconds # predicting this with the model later\n# Feature engineering #2 (time difference between current flare and last)\narr = np.zeros(12455) # initialize array\nfor i in range(1, len(arr)): # compute differences\n    arr[i] = arr[i] + (df['JJJ Peak'][i] - df['JJJ Peak'][i-1]).seconds\narr[0] = np.mean(arr) \n# set column\ndf['diff time'] = arr \n# don't include columns that are already represented or can't be known at time of prediction\ndf = df.drop(['JJJ End', 'JJJ Start', 'JJJ Peak'], axis=1) \n# display data\ndf.head()","43a2456c":"# transform \"JJJ Class\" values from categorical to numerical\nOH_encoder = OneHotEncoder(handle_unknown='ignore', sparse=False)\nOH_cols = pd.DataFrame(OH_encoder.fit_transform(df[['JJJ Class']]))\nOH_cols.index = df.index\ndf = df.drop(['JJJ Class'], axis=1) # replaced by columns with numerical values\ndf = pd.concat([df, OH_cols], axis=1)\ndf.head() # show (1 if the flare fits the \"class\")","52091ddb":"df.describe() # show statistics","8b4d6cfe":"# predicting 'peak to end' (include in y, not X)\nX, y = df.drop(['peak to end'], axis=1), df['peak to end']\n# 80% for training, 20% for test data\nX_train, X_test, y_train, y_test = skms.train_test_split(X, y, train_size=0.8, test_size=0.2)","ff769d7b":"# make predictions using XGBoost\nmae, predictions = score_dataset(X_train, y_train, X_test, y_test)\nprint('MAE %.2f' % mae) # Mean absolute error to two decimal places","70605d57":"# Visualize the results\nplot_y_test = y_test[:100] # first 100 correct ones\nplot_predictions = predictions[:100] # first 100 predictions\npyplot.figure(figsize=(20, 5))\npyplot.plot(plot_y_test, label = 'Expected')\npyplot.plot(plot_predictions, label='Predicted')\npyplot.legend()\npyplot.show() # show","ad15ffc0":"# read data\npath = \"\/kaggle\/input\/instruments-solarflares\/flares_and_instruments_v2.csv\"\ndf = pd.read_csv(path, header=0, index_col=0)\n# organize data by solar flares per day\ntime = pd.to_datetime(df['JJJ Start'])\ndf = time.groupby(time.dt.floor('d')).size()\n# show data\ndf.head()","daf1fb1f":"# Number of solar flares vs. Time\npyplot.figure(figsize=(30, 6))\npyplot.plot(df)","10b9bc59":"# How many past days are correlated with prediction for current day\nplot_acf(df)\npyplot.show()","2949b10b":"features = [] # organizing the features\nn_in = 7 \n# Shift the data so that the last 7 days are features for the current day\nfor i in range(n_in, 0, -1):\n    features.append(df.shift(i))\nfeatures.append(df.shift(0))\n# combine the features\ndf = pd.concat(features, axis=1)\n# drop rows with missing values\ndf.dropna(inplace = True)\n# Prediction (y) is last feature; exclude it from X\nX, y = df.values[:, :-1], df.values[:, -1]\n# 80% training data, 20% for test data\nX_train, X_test, y_train, y_test = skms.train_test_split(X, y, train_size=0.8, test_size=0.2)","7d902cee":"# make predictions using XGBoost\nmae, predictions = score_dataset(X_train, y_train, X_test, y_test)\nprint('MAE %.2f' % mae) # Mean absolute error to two decimal places","be767fda":"# Visualize the results\npyplot.figure(figsize=(30, 6))\nplt_y_test = y_test[:100] # first 100 correct ones\nplt_predictions = predictions[:100] # first 100 predictions\npyplot.plot(plt_y_test, label='Expected')\npyplot.plot(plt_predictions, label='Predicted')\npyplot.legend()\npyplot.show()","2f1d7c78":"The features (besides the ones I \"engineered\") are described in \"flares_and_instruments_v2.csv\" on the database's home page. They measure details about the solar flares (like class and position) and the instruments used for observing them. ","89cc848a":"### Train Test Split","13f288c2":"# 1. Predict Solar Flare Peak to End Time","acec7741":"### Train Test Split","8ff37967":"### Results","dddb070a":"# 2. Predict Solar Flare Frequency","a167b0c9":"# Introduction\nThis notebook predicts the frequency (measured by daily number) and length of solar flares. Any feedback is welcome and appreciated! <br><br>\nSee the two cells below to get started.","41ca4ce6":"### Data Preprocessing","9ef2c87b":"### Feature Engineering and Data Preprocessing","5427978d":"## XGBoost Model ","b947dcb3":"### Results","7ad6f9f4":"### Exploratory Data Analysis"}}