{"cell_type":{"46ca746d":"code","14cfd9e3":"code","97e932e6":"code","eabaa74b":"code","710921a7":"code","f7a92e3b":"code","7a4c6057":"code","5d034631":"code","fc648fbb":"code","857a17dd":"code","b4e9c88b":"code","25c49e5e":"code","1c10f6cd":"code","cf50679e":"code","640b146d":"code","6afe4de9":"code","90519b7d":"code","5ef13413":"code","1f902d4d":"code","74a13496":"code","7f091c29":"code","e251bf14":"code","556a316c":"code","57fe38c2":"code","a6ecbc8d":"code","77e44c1f":"code","d1119b18":"code","83be736d":"code","60d5c8db":"code","316ba24f":"code","faa82931":"code","ad1663f7":"code","26521471":"code","431ca870":"code","ea54fd90":"code","fdc097aa":"code","e2938d50":"code","1b9d866e":"code","44d01264":"code","c77d3590":"code","72e66740":"code","bee9b39d":"code","458dd7d6":"code","61d2921e":"code","9981a87d":"code","402d723d":"code","90debd43":"code","1e3b67ca":"code","09d77366":"code","398ac07a":"code","c22e21aa":"code","3c74eb45":"code","403ad5c8":"code","901d2674":"code","e7a86532":"code","0a57ad31":"code","b5cbe511":"code","465d0a49":"code","6a6fcbd7":"code","5331d65f":"code","4d5ec0d3":"code","28e028b0":"code","7af65a22":"code","97b48f4d":"code","0d841980":"code","77bbe46b":"code","2d7a0432":"code","cfa4c7a7":"code","46fdf334":"code","f1ef0ac4":"code","31d43e67":"code","ebfac24f":"code","a22a4fde":"code","13505abc":"code","d8ca8ce1":"code","42de0031":"code","28301813":"code","bc96a9fd":"code","37647193":"code","b91c70de":"code","cbd1cf6a":"code","72a1c0f6":"code","118ddd5f":"code","452b3a3b":"code","22c904c3":"code","7d582a80":"code","fd7f053f":"code","3b6895d0":"code","b6e584b7":"code","d8239cfd":"code","43a52aca":"code","1d13ddc1":"code","3284849c":"code","4047db0f":"code","702fad97":"code","e51b4de1":"code","1abb2229":"code","b0b71742":"code","7193f432":"markdown","d8029bcb":"markdown","0ed1b240":"markdown","756527eb":"markdown","7c9ba4c8":"markdown","b521b885":"markdown","ec815a20":"markdown","e596ac56":"markdown","06d50a32":"markdown","5ae3d43a":"markdown","672b6acc":"markdown","d88eda38":"markdown","46c91349":"markdown","f3fcf044":"markdown","c6506396":"markdown","53bdb2ba":"markdown","21225173":"markdown","4724b0b1":"markdown","794c8ef7":"markdown","48dd8830":"markdown","225648ef":"markdown","9667ad55":"markdown","ecf7069d":"markdown","84e57c17":"markdown"},"source":{"46ca746d":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nplt.rcParams.update({'figure.max_open_warning': 0})\nimport warnings\nwarnings.filterwarnings('ignore')","14cfd9e3":"path = \"\/kaggle\/input\/stanford-covid-vaccine\/\"","97e932e6":"path_npy = \"\/kaggle\/input\/stanford-covid-vaccine\/bpps\/\"","eabaa74b":"train = pd.read_json(f\"{path}train.json\", lines=True)\ntest = pd.read_json(f\"{path}test.json\", lines=True)\nsubmission = pd.read_csv(f\"{path}sample_submission.csv\")","710921a7":"pd.set_option('display.max_rows', None)\npd.set_option('display.max_columns', None)","f7a92e3b":"train.dtypes.value_counts().plot.bar()","7a4c6057":"train.info()","5d034631":"test.info()","fc648fbb":"import seaborn as sns","857a17dd":"plt.figure(figsize=(18,8))\nsns.heatmap(train.isna(), cbar=False)\nplt.title(\"Train set global view\")\nplt.show()","b4e9c88b":"print('train shape :',train.shape)\nprint('test shape :',test.shape)\nprint('submission shape :', submission.shape)","25c49e5e":"train.head()","1c10f6cd":"test.head()","cf50679e":"submission.head()","640b146d":"train.describe()","6afe4de9":"import seaborn as sns","90519b7d":"fig, axe = plt.subplots(1, 2, figsize=(15, 5))\nsns.distplot(train['signal_to_noise'], ax=axe[0])\nsns.countplot(train['SN_filter'], ax=axe[1])\n\naxe[0].set_title('Distribution  Signal\/Noise ')\naxe[1].set_title('Signal\/Noise Filter');","5ef13413":"One_sample = train.iloc[0]\nOne_sequence = One_sample[\"sequence\"]\nOne_structure = One_sample[\"structure\"]\nOne_predicted_loop_type = One_sample[\"predicted_loop_type\"]\nOne_reactivity = One_sample[\"reactivity\"]","1f902d4d":"print(\"One_sequence :\",One_sequence)\nprint(\"One_structure :\",One_structure)\nprint(\"One_predicted_loop_type :\",One_predicted_loop_type)\nprint(\"One_reactivity :\", One_reactivity)","74a13496":"len(One_reactivity)","7f091c29":"import collections","e251bf14":"collections.Counter(One_sequence)","556a316c":"sum_one_sequence = sum(collections.Counter(One_sequence).values())\nsum_one_sequence","57fe38c2":"collections.Counter(One_structure)","a6ecbc8d":"sum_one_structure = sum(collections.Counter(One_structure).values())\nsum_one_structure","77e44c1f":"collections.Counter(One_predicted_loop_type)","d1119b18":"sum_one_predicted_loop_type = sum(collections.Counter(One_predicted_loop_type).values())\nsum_one_predicted_loop_type","83be736d":"target_cols = ['reactivity', 'deg_Mg_pH10', 'deg_pH10', 'deg_Mg_50C', 'deg_50C']","60d5c8db":"def read_bpps_sum(df):\n    bpps_arr = []\n    for mol_id in df.id.to_list():\n        bpps_arr.append(np.load(f\"{path_npy}{mol_id}.npy\").sum(axis=1))\n    return bpps_arr","316ba24f":"def read_bpps_max(df):\n    bpps_arr = []\n    for mol_id in df.id.to_list():\n        bpps_arr.append(np.load(f\"{path_npy}{mol_id}.npy\").max(axis=1))\n    return bpps_arr","faa82931":"def read_bpps_nb(df):\n    #mean and std from https:\/\/www.kaggle.com\/symyksr\/openvaccine-deepergcn \n    bpps_nb_mean = 0.077522\n    bpps_nb_std = 0.08914\n    bpps_arr = []\n    for mol_id in df.id.to_list():\n        bpps = np.load(f\"{path_npy}{mol_id}.npy\")\n        bpps_nb = (bpps > 0).sum(axis=0) \/ bpps.shape[0]\n        bpps_nb = (bpps_nb - bpps_nb_mean) \/ bpps_nb_std\n        bpps_arr.append(bpps_nb)\n    return bpps_arr ","ad1663f7":"train['bpps_sum'] = read_bpps_sum(train)\ntrain['bpps_max'] = read_bpps_max(train)\ntrain['bpps_nb'] = read_bpps_nb(train)","26521471":"test['bpps_sum'] = read_bpps_sum(test)\ntest['bpps_max'] = read_bpps_max(test)\ntest['bpps_nb'] = read_bpps_nb(test)","431ca870":"train[train.columns[-3:]].head()","ea54fd90":"len(train[train.columns[-3]][0])","fdc097aa":"test[test.columns[-3:]].head()","e2938d50":"len(test[test.columns[-3]][0])","1b9d866e":"train_set = train.copy()\ntest_set = test.copy()","44d01264":"import json","c77d3590":"train_json = train_set.to_json(orient='table')\ntest_json = test_set.to_json(orient='table')","72e66740":"train_json = json.loads(train_json)\ntest_json = json.loads(test_json)\ntrain_json = train_json[\"data\"]\ntest_json = test_json[\"data\"]","bee9b39d":"for line in train_json:\n    line['step'] = list(range(line['seq_scored']))\n    line['sequence'] = list(line['sequence'])\n    line['structure'] = list(line['structure'])\n    line['predicted_loop_type'] = list(line['predicted_loop_type'])","458dd7d6":"df_data_train_set = pd.json_normalize(data = train_json, \n                            record_path ='reactivity',  \n                            meta =['id','signal_to_noise',\n                                  'SN_filter','seq_length','seq_scored']) \ndf_data_train_set.rename(columns={0:'reactivity'}, inplace=True)\ndf_data_train_set['step'] = pd.json_normalize(data = train_json, record_path ='step')\ndf_data_train_set['sequence'] = pd.json_normalize(data = train_json, record_path ='sequence')\ndf_data_train_set['structure'] = pd.json_normalize(data = train_json, record_path ='structure')\ndf_data_train_set['predicted_loop_type'] = pd.json_normalize(data = train_json, record_path ='predicted_loop_type')\ndf_data_train_set['reactivity_error'] = pd.json_normalize(data = train_json, record_path ='reactivity_error')\ndf_data_train_set['deg_Mg_pH10'] = pd.json_normalize(data = train_json, record_path ='deg_Mg_pH10')\ndf_data_train_set['deg_error_Mg_pH10'] = pd.json_normalize(data = train_json, record_path ='deg_error_Mg_pH10')\ndf_data_train_set['deg_pH10'] = pd.json_normalize(data = train_json, record_path ='deg_pH10')\ndf_data_train_set['deg_error_pH10'] = pd.json_normalize(data = train_json, record_path ='deg_error_pH10')\ndf_data_train_set['deg_Mg_50C'] = pd.json_normalize(data = train_json, record_path ='deg_Mg_50C')\ndf_data_train_set['deg_error_Mg_50C'] = pd.json_normalize(data = train_json, record_path ='deg_error_Mg_50C')\ndf_data_train_set['deg_50C'] = pd.json_normalize(data = train_json, record_path ='deg_50C')\ndf_data_train_set['deg_error_50C'] = pd.json_normalize(data = train_json, record_path ='deg_error_50C')\ndf_data_train_set['bpps_sum'] = pd.json_normalize(data = train_json, record_path ='bpps_sum')\ndf_data_train_set['bpps_max'] = pd.json_normalize(data = train_json, record_path ='bpps_max')\ndf_data_train_set['bpps_nb'] = pd.json_normalize(data = train_json, record_path ='bpps_nb')\n\ndf_data_train_set.set_index(['id','step'], inplace=True)","61d2921e":"df_data_train_set.head()","9981a87d":"for line in test_json:\n    line['step'] = list(range(line['seq_scored']))\n    line['sequence'] = list(line['sequence'])\n    line['structure'] = list(line['structure'])\n    line['predicted_loop_type'] = list(line['predicted_loop_type'])","402d723d":"df_data_test_set = pd.json_normalize(data = test_json,\n                         record_path = 'sequence',\n                        meta = ['id','seq_length','seq_scored'])\ndf_data_test_set.rename(columns={0:'sequence'},inplace=True)\ndf_data_test_set['step'] = pd.json_normalize(data = test_json,record_path = 'step')\ndf_data_test_set['sequence'] = pd.json_normalize(data = test_json,record_path = 'sequence')\ndf_data_test_set['structure'] = pd.json_normalize(data = test_json,record_path = 'structure')\ndf_data_test_set['predicted_loop_type'] = pd.json_normalize(data = test_json,record_path = 'predicted_loop_type')\ndf_data_test_set['bpps_sum'] = pd.json_normalize(data = test_json, record_path ='bpps_sum')\ndf_data_test_set['bpps_max'] = pd.json_normalize(data = test_json, record_path ='bpps_max')\ndf_data_test_set['bpps_nb'] = pd.json_normalize(data = test_json, record_path ='bpps_nb')\n\ndf_data_test_set.set_index(['id','step'], inplace=True)","90debd43":"public_test_df = df_data_test_set.query(\"seq_length == 107\").copy()\nprivate_test_df = df_data_test_set.query(\"seq_length == 130\").copy()","1e3b67ca":"public_test_df.head(3)","09d77366":"private_test_df.head(3)","398ac07a":"from sklearn.preprocessing import OneHotEncoder, LabelEncoder\nimport copy","c22e21aa":"Encoding = LabelEncoder()\nquantitative_train = [cols for cols in df_data_train_set.columns if df_data_train_set[cols].dtype == 'object']\nquantitative_test = [cols for cols in df_data_test_set.columns if df_data_test_set[cols].dtype == 'object']\ndf_train_set_encode = copy.deepcopy(df_data_train_set)\ndf_test_set_encode = copy.deepcopy(df_data_test_set)\nfor cols in quantitative_train:\n        df_train_set_encode[cols] = Encoding.fit_transform(df_train_set_encode[cols])\nfor cols in quantitative_test:\n        df_test_set_encode[cols] = Encoding.fit_transform(df_test_set_encode[cols])","3c74eb45":"df_train_set_encode.head(3)","403ad5c8":"df_test_set_encode.head(3)","901d2674":"y = df_train_set_encode[target_cols]","e7a86532":"from sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.linear_model import RidgeCV, LassoCV, ElasticNet\nfrom sklearn.ensemble import BaggingRegressor\nimport xgboost as xgb\nfrom sklearn.ensemble import RandomForestRegressor, AdaBoostRegressor\nfrom sklearn.svm import SVR\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.multioutput import MultiOutputRegressor\nfrom sklearn.feature_selection import SelectKBest, f_classif","0a57ad31":"list_of_model = []","b5cbe511":"alphas = 10**np.linspace(10,-2,100)*0.5","465d0a49":"rideCV = MultiOutputRegressor(estimator=RidgeCV(alphas = alphas))\nlassoCV = MultiOutputRegressor(estimator=LassoCV(alphas = None, cv = 10))\nElasticNet = MultiOutputRegressor(estimator=ElasticNet(alpha=0.01, l1_ratio=0.5))\nRandomForest = MultiOutputRegressor(estimator=RandomForestRegressor(max_depth=2, random_state=0))\nAdaBoost = MultiOutputRegressor(estimator=AdaBoostRegressor(random_state=0, n_estimators=100))\nSVR = MultiOutputRegressor(estimator=SVR(C=1.0, epsilon=0.2))\nDecisionTree = MultiOutputRegressor(estimator=DecisionTreeRegressor(max_depth=3,random_state=0))\nKNN = MultiOutputRegressor(estimator=KNeighborsRegressor())","6a6fcbd7":"list_of_model = {\n                'RandomForest': RandomForest,\n                'DecisionTree': DecisionTree,\n                'SVR': SVR,\n                'KNN': KNN}","5331d65f":"columns = df_test_set_encode.columns\ncolumns","4d5ec0d3":"def standard_scale(X_train, X_test):\n    preprocessor = StandardScaler().fit(X_train)\n    X_train = preprocessor.transform(X_train)\n    X_test = preprocessor.transform(X_test)\n    return X_train, X_test ","28e028b0":"#X_train, X_test = standard_scale(df_train_set_encode[columns],df_test_set_encode)","7af65a22":"def Evalution_model(model, key):\n    model.fit(df_train_set_encode[columns], y)\n    y_pred = model.predict(df_test_set_encode)\n    \n    print(\"{} Performance for training and testing set\".format(key))\n    print(\"----------------------------------------------------------------------------\")\n    print('Score :',model.score(df_train_set_encode[columns], y))\n    return y_pred","97b48f4d":"y_predict = []","0d841980":"#for key, model in list_of_model.items():\n#    y_predict = Evalution_model(model, key)","77bbe46b":"y_predict","2d7a0432":"xgb_model = xgb.XGBRegressor( booster='gbtree', colsample_bylevel=1,\n             colsample_bynode=1, colsample_bytree=0.6, gamma=0,\n             importance_type='gain', learning_rate=0.01, max_delta_step=0,\n             max_depth=100, min_child_weight=2, n_estimators=100,\n             n_jobs=1, nthread=None, objective='reg:squarederror',\n             reg_alpha=0.6, reg_lambda=0.6, scale_pos_weight=1, \n             silent=None, subsample=0.8, verbosity=0)","cfa4c7a7":"xgb_mod = MultiOutputRegressor(estimator=xgb_model)","46fdf334":"xgb_mod.fit(df_train_set_encode[columns], y)\npred_final = xgb_mod.predict(df_test_set_encode)","f1ef0ac4":"print('Score :',xgb_mod.score(df_train_set_encode[columns], y))","31d43e67":"pred_final.shape","ebfac24f":"pred_final","a22a4fde":"import plotly.express as px\nimport tensorflow.keras.layers as L\nimport tensorflow as tf\nfrom sklearn.model_selection import train_test_split","13505abc":"tf.random.set_seed(2020)\nnp.random.seed(2020)","d8ca8ce1":"y_true = tf.random.normal((32, 68, 3))\ny_pred = tf.random.normal((32, 68, 3))","42de0031":"def MCRMSE(y_true, y_pred):\n    colwise_mse = tf.reduce_mean(tf.square(y_true - y_pred), axis=1)\n    return tf.reduce_mean(tf.sqrt(colwise_mse), axis=1)","28301813":"def gru_layer(hidden_dim, dropout):\n    return L.Bidirectional(L.GRU(hidden_dim, dropout=dropout, return_sequences=True,\n                                 kernel_initializer='orthogonal'))","bc96a9fd":"def Build_Model(embed_size, seq_len=107, pred_len=68, dropout=0.5, sp_dropout=0.2, embed_dim=200,\n                hidden_dim=256, n_layers=3):\n    \n    inputs = L.Input(shape=(seq_len, 3))\n    embed = L.Embedding(input_dim=embed_size, output_dim=embed_dim)(inputs)\n    \n    reshaped = tf.reshape(embed, shape=(-1, embed.shape[1],  embed.shape[2] * embed.shape[3]))\n    hidden = L.SpatialDropout1D(sp_dropout)(reshaped)\n    \n    for x in range(n_layers):\n        hidden = gru_layer(hidden_dim, dropout)(hidden)\n    \n    # Since we are only making predictions on the first part of each sequence, \n    # we have to truncate it\n    truncated = hidden[:, :pred_len]\n    out = L.Dense(5, activation='linear')(truncated)\n    \n    model = tf.keras.Model(inputs=inputs, outputs=out)\n    model.compile(tf.optimizers.Adam(), loss=MCRMSE)\n    \n    return model","37647193":"def pandas_list_to_array(df):\n    \"\"\"\n    Input: dataframe of shape (x, y), containing list of length l\n    Return: np.array of shape (x, l, y)\n    \"\"\"\n    \n    return np.transpose(\n        np.array(df.values.tolist()),\n        (0, 2, 1)\n    )","b91c70de":"def preprocess_inputs(df, token2int, cols=['sequence', 'structure', 'predicted_loop_type']):\n    return pandas_list_to_array(\n        df[cols].applymap(lambda seq: [token2int[x] for x in seq])\n    )","cbd1cf6a":"train = train.query(\"signal_to_noise >= 1\")","72a1c0f6":"token2int = {x:i for i, x in enumerate('().ACGUBEHIMSX')}\n\ntrain_inputs = preprocess_inputs(train, token2int)\ntrain_labels = pandas_list_to_array(train[target_cols])","118ddd5f":"from sklearn.model_selection import train_test_split","452b3a3b":"x_train, x_valid, y_train, y_valid = train_test_split(\n    train_inputs, train_labels, test_size=.1, random_state=34, stratify=train.SN_filter)","22c904c3":"public_test_df = test.query(\"seq_length == 107\").copy()\nprivate_test_df = test.query(\"seq_length == 130\").copy()","7d582a80":"public_inputs_test = preprocess_inputs(public_test_df, token2int)\nprivate_inputs_test = preprocess_inputs(private_test_df, token2int)","fd7f053f":"model = Build_Model(embed_size=len(token2int))\nmodel.summary()","3b6895d0":"history = model.fit(x_train, y_train,validation_data=(x_valid, y_valid),batch_size=64,epochs=75,verbose=2,\n        callbacks=[\n            tf.keras.callbacks.ReduceLROnPlateau(patience=5),\n            tf.keras.callbacks.ModelCheckpoint('model.h5')\n        ]\n)","b6e584b7":"fig = px.line(\n    history.history, y=['loss', 'val_loss'],\n    labels={'index': 'epoch', 'value': 'MCRMSE'}, \n    title='Training History')\nfig.show()","d8239cfd":"model_public = Build_Model(seq_len=107, pred_len=107, embed_size=len(token2int))\nmodel_private = Build_Model(seq_len=130, pred_len=130, embed_size=len(token2int))\n\nmodel_public.load_weights('model.h5')\nmodel_private.load_weights('model.h5')","43a52aca":"pred_public = model_public.predict(public_inputs_test)\npred_private = model_private.predict(private_inputs_test)","1d13ddc1":"preds_gru = []","3284849c":"for df, pred in [(public_test_df, pred_public), (private_test_df, pred_private)]:\n    for i, uid in enumerate(df.id):\n        single_pred = pred[i]\n\n        single_df = pd.DataFrame(single_pred, columns=target_cols)\n        single_df['id_seqpos'] = [f'{uid}_{x}' for x in range(single_df.shape[0])]\n\n        preds_gru.append(single_df)\n\nsubmit_df = pd.concat(preds_gru)","4047db0f":"submission.shape","702fad97":"submission = submit_df[['id_seqpos']].merge(submit_df, on=['id_seqpos'])","e51b4de1":"submission.head()","1abb2229":"submission.shape","b0b71742":"submission.to_csv('gru_submission.csv', index=False)\nprint(\"Great sub!\")","7193f432":"# ENCODAGE DATA","d8029bcb":"# COLUMNS","0ed1b240":"# Bi-GRU","756527eb":"![eterna_covid-19_web_1200_v2.jpg](attachment:eterna_covid-19_web_1200_v2.jpg)","7c9ba4c8":"* structure - (1x107 string in Train and Public Test, 130 in Private Test) An array of (, ), and . characters that describe whether a base is estimated to be paired or unpaired. Paired bases are denoted by opening and closing parentheses e.g. (....) means that base 0 is paired to base 5, and bases 1-4 are unpaired.","b521b885":"\n* id - An arbitrary identifier for each sample.\n* seq_scored - (68 in Train and Public Test, 91 in Private Test) Integer value denoting the number of positions used in scoring with predicted values. This should match the length of reactivity, deg_* and *_error_* columns. Note that molecules used for the Private Test will be longer than those in the Train and Public Test data, so the size of this vector will be different.\n* seq_length - (107 in Train and Public Test, 130 in Private Test) Integer values, denotes the length of sequence. Note that molecules used for the Private Test will be longer than those in the Train and Public Test data, so the size of this vector will be different.\n* sequence - (1x107 string in Train and Public Test, 130 in Private Test) Describes the RNA sequence, a combination of A, G, U, and C for each sample. Should be 107 characters long, and the first 68 bases should correspond to the 68 positions specified in seq_scored (note: indexed starting at 0).\n* structure - (1x107 string in Train and Public Test, 130 in Private Test) An array of (, ), and . characters that describe whether a base is estimated to be paired or unpaired. Paired bases are denoted by opening and closing parentheses e.g. (....) means that base 0 is paired to base 5, and bases 1-4 are unpaired.\n* reactivity - (1x68 vector in Train and Public Test, 1x91 in Private Test) An array of floating point numbers, should have the same length as seq_scored. These numbers are reactivity values for the first 68 bases as denoted in sequence, and used to determine the likely secondary structure of the RNA sample.\n* deg_pH10 - (1x68 vector in Train and Public Test, 1x91 in Private Test) An array of floating point numbers, should have the same length as seq_scored. These numbers are reactivity values for the first 68 bases as denoted in sequence, and used to determine the likelihood of degradation at the base\/linkage after incubating without magnesium at high pH (pH 10).\n* deg_Mg_pH10 - (1x68 vector in Train and Public Test, 1x91 in Private Test) An array of floating point numbers, should have the same length as seq_scored. These numbers are reactivity values for the first 68 bases as denoted in sequence, and used to determine the likelihood of degradation at the base\/linkage after incubating with magnesium in high pH (pH 10).\n* deg_50C - (1x68 vector in Train and Public Test, 1x91 in Private Test) An array of floating point numbers, should have the same length as seq_scored. These numbers are reactivity values for the first 68 bases as denoted in sequence, and used to determine the likelihood of degradation at the base\/linkage after incubating without magnesium at high temperature (50 degrees Celsius).\n* deg_Mg_50C - (1x68 vector in Train and Public Test, 1x91 in Private Test) An array of floating point numbers, should have the same length as seq_scored. These numbers are reactivity values for the first 68 bases as denoted in sequence, and used to determine the likelihood of degradation at the base\/linkage after incubating with magnesium at high temperature (50 degrees Celsius).\n* *_error_* - An array of floating point numbers, should have the same length as the corresponding reactivity or deg_* columns, calculated errors in experimental values obtained in reactivity and deg_* columns.\n* predicted_loop_type - (1x107 string) Describes the structural context (also referred to as 'loop type')of each character in sequence. Loop types assigned by bpRNA from Vienna RNAfold 2 structure. From the bpRNA_documentation: S: paired \"Stem\" M: Multiloop I: Internal loop B: Bulge H: Hairpin loop E: dangling End X: eXternal loop","ec815a20":"Additional Notes:\n\n* Minimum value across all 5 conditions must be greater than -0.5.\n* Mean signal\/noise across all 5 conditions must be greater than 1.0. [Signal\/noise is defined as mean( measurement value over 68 nts )\/mean( statistical error in measurement value over 68 nts)] To help ensure sequence diversity, the resulting sequences were clustered into clusters with less than 50% sequence similarity, and the 629 test set sequences were chosen from clusters with 3 or fewer members. That is, any sequence in the test set should be sequence similar to at most 2 other sequences.\n\nNote that these filters have not been applied to the 2400 RNAs in the public training data train.json \u2014 some of those measurements have negative values or poor signal-to-noise, or some RNA sequences have near-identical sequences in that set. But we are providing all those data in case competitors can squeeze out more signal.\n","e596ac56":"In this competition, you will be predicting the degradation rates at various locations along RNA sequence.\n\nThere are multiple ground truth values provided in the training data. While the submission format requires all 5 to be predicted, only the following are scored: reactivity, deg_Mg_pH10, and deg_Mg_50C.","06d50a32":"# EDA (EXPLORATORY DATA ANALYSIS)","5ae3d43a":"# BUILD AND TRAIN MODEL Bi-GRU","672b6acc":"![index.png](attachment:index.png)","d88eda38":"# PUBLIC AND PRIVATE PREDICTION","46c91349":"* Predicted_loop_type - (1x107 string) Describes the structural context (also referred to as 'loop type')of each character in sequence. Loop types assigned by bpRNA from Vienna RNAfold 2 structure. From the bpRNA_documentation: S: paired \"Stem\" M: Multiloop I: Internal loop B: Bulge H: Hairpin loop E: dangling End X: eXternal loop","f3fcf044":"Let's look together columns and types variable of data train and test set.","c6506396":"* This is good news, because I don't see any missing value.","53bdb2ba":"# EVALUATION","21225173":"The bpps folder contains Base Pairing Probabilities matrices for each sequence. These matrices give the probability that each pair of nucleotides in the RNA forms a base pair. Each matrix is a symmetric square matrix the same length as the sequence. For a complete EDA of the bpps folder, see this notebook [here](https:\/\/www.kaggle.com\/hidehisaarai1213\/openvaccine-checkout-bpps?scriptVersionId=42460013).","4724b0b1":"# DATA DESCRIPTION","794c8ef7":"* sequence - (1x107 string in Train and Public Test, 130 in Private Test) Describes the RNA sequence, a combination of A, G, U, and C for each sample. Should be 107 characters long, and the first 68 bases should correspond to the 68 positions specified in seq_scored (note: indexed starting at 0).","48dd8830":"NB: These different steps make it possible to verify the integrity of the data. :-)","225648ef":"# FEATURE ENGINEERING","9667ad55":"# MODELING","ecf7069d":"# Summary:\n1. EDA (Exploratory Data Analysis)\n2. Features engineering & Pre-processing\n3. Modeling\n4. Optimization","84e57c17":"# Problems : \n* One of the biggest challenges right now is how to design super stable messenger RNA molecules (mRNA).\n* Researchers have observed that RNA molecules have the tendency to spontaneously degrade. This is a serious limitation--a single cut can render the mRNA vaccine useless.\n\n# Goal:\nwe are looking to leverage the data science expertise of the Kaggle community to develop models and design rules for RNA degradation. Your model will predict likely degradation rates at each base of an RNA molecule, trained on a subset of an Eterna dataset comprising over 3000 RNA molecules (which span a panoply of sequences and structures) and their degradation rates at each position. We will then score your models on a second generation of RNA sequences that have just been devised by Eterna players for COVID-19 mRNA vaccines. These final test sequences are currently being synthesized and experimentally characterized at Stanford University in parallel to your modeling efforts -- Nature will score your models! "}}