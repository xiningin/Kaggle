{"cell_type":{"1aec8021":"code","9dc61f23":"code","cb7495ea":"code","a7a2ed28":"code","252bbb4c":"code","beb3929f":"code","6f14d140":"code","1c9d3a7a":"code","81afd940":"code","b51b360c":"code","070d76d4":"code","54b39e46":"code","0f10c534":"code","73a28b1f":"code","b05fe461":"code","c85277e2":"code","edba07c3":"code","a591dc8b":"code","85ee6c17":"code","74dcaddf":"code","f2de80bf":"code","298c78dd":"code","0fad4f37":"code","819a89b4":"code","bbba391c":"code","e5ff5b10":"code","f7e9eb00":"code","52bce911":"code","bef2648b":"code","759fbcf7":"code","d5593a3e":"code","aeb936df":"code","fe7d91b8":"code","d5294ae7":"code","3f3ad61d":"code","181fb3ce":"code","6325b2af":"code","390bd900":"code","89204834":"code","8883aec9":"code","c9a9acb2":"code","7361f108":"code","55a3d42c":"code","e59b8e55":"code","ff691aa1":"code","c5127031":"code","b85792c5":"code","bf688f84":"code","0106c8b5":"code","536842ba":"code","150a15a5":"code","8405904d":"code","56c111b5":"code","63c8d162":"code","768868af":"code","74d7a4e0":"code","3ddbe228":"code","bf4600eb":"code","18caf273":"code","64f1cdce":"code","07601c66":"code","81e0453a":"markdown","a05c58a8":"markdown","fe2c251f":"markdown","17b58a0c":"markdown","92220ec4":"markdown","8c9a5cb6":"markdown","afdd6435":"markdown","21e2b35b":"markdown","1a0298b5":"markdown"},"source":{"1aec8021":"#importing libraries\nimport pandas as pd\nimport numpy as np\nfrom sklearn.metrics import accuracy_score\nfrom sklearn import metrics\nimport matplotlib.pyplot as plt","9dc61f23":"# loading the pre-processed dataset\ndata = pd.read_csv('..\/input\/glass\/glass.csv')","cb7495ea":"#shape of the data\ndata.shape","a7a2ed28":"#first five rows of the data\ndata.head()","252bbb4c":"#checking missing values in the data\ndata.isnull().sum()","beb3929f":"# checking the data type\ndata.dtypes","6f14d140":"data.describe()","1c9d3a7a":"data['Type'].value_counts()","81afd940":"# data visualization\nglass_classes = data['Type'].unique()\nvalues = data['Type'].value_counts()\n\nplt.bar(glass_classes, values)\nplt.title('Types_of_Glass')\nplt.xlabel('Glass Classes')\nplt.ylabel('Examples count')\nplt.show()","b51b360c":"# separating the independent and dependent variables\n\n# storing all the independent variables as X\nX = data.drop(['Type'], axis=1)\n\n# storing the dependent variable as y\ny = data['Type']","070d76d4":"# shape of independent and dependent variables\nX.shape, y.shape","54b39e46":"#importing sklearn and train_test_split to create validation set\nimport sklearn\nfrom sklearn.model_selection import train_test_split\n#creating the train and validation set\nX_train, X_test, y_train, y_test = train_test_split(X,y, test_size = 0.2, stratify=y, random_state = 70)","0f10c534":"# distribution in training set\ny_train.value_counts(normalize=True)","73a28b1f":"# distribution in testing set\ny_test.value_counts(normalize=True)","b05fe461":"#shape of training set\nX_train.shape, y_train.shape","c85277e2":"#shape of testing set\nX_test.shape,y_test.shape","edba07c3":"#importing decision tree classifier \nfrom sklearn.tree import DecisionTreeClassifier","a591dc8b":"#fitting the model\ndt_model = DecisionTreeClassifier(random_state=10)","85ee6c17":"dt_model.fit(X_train, y_train)","74dcaddf":"#checking the training score\ndt_model.score(X_train, y_train)","f2de80bf":"#checking the validation score\ndt_model.score(X_test, y_test)","298c78dd":"#predictions on validation set\ndt_predict=dt_model.predict(X_test)","0fad4f37":"dt_predict","819a89b4":"from sklearn.metrics import accuracy_score\naccuracy_score(y_test,dt_predict)","bbba391c":"train_accuracy = []\nvalidation_accuracy = []\nfor depth in range(1,15):\n    dt_model = DecisionTreeClassifier(max_depth=depth, random_state=6)\n    dt_model.fit(X_train, y_train)\n    train_accuracy.append(dt_model.score(X_train, y_train))\n    validation_accuracy.append(dt_model.score(X_test, y_test))","e5ff5b10":"frame = pd.DataFrame({'max_depth':range(1,15), 'train_acc':train_accuracy, 'test_acc':validation_accuracy})\nframe.head()","f7e9eb00":"plt.figure(figsize=(14,6))\nplt.plot(frame['max_depth'], frame['train_acc'], marker='o')\nplt.plot(frame['max_depth'], frame['test_acc'], marker='o')\nplt.xlabel('Depth of tree')\nplt.ylabel('performance')\nplt.legend(['train_acc','test_acc'])","52bce911":"# max. depth goes on increasing till max. depth is 9 after that remain const. \ndt_model = DecisionTreeClassifier(max_depth=9, max_leaf_nodes=35, random_state=10)","bef2648b":"#fitting the model\ndt_model.fit(X_train, y_train)","759fbcf7":"#Training score\ndt_model.score(X_train, y_train)","d5593a3e":"#Validation score\ndt_model.score(X_test, y_test)","aeb936df":"dt_predict1=dt_model.predict(X_test)","fe7d91b8":"dt_predict1","d5294ae7":"accuracy_score(y_test,dt_predict1)","3f3ad61d":"# Get the confusion Matrix of the Model\ncnf_matrix = metrics.confusion_matrix(y_test,dt_predict1)\ncnf_matrix","181fb3ce":"# Plot the Confusion Matrix as a HeatMap\nimport seaborn as sns\nclass_names=[1,2,3,5,6,7] # Name  of classes\nfig, ax = plt.subplots()\ntick_marks = np.arange(len(class_names))\nplt.xticks(tick_marks, class_names)\nplt.yticks(tick_marks, class_names)\n# create heatmap\nsns.heatmap(pd.DataFrame(cnf_matrix), annot=True, cmap=\"YlGnBu\" ,fmt='g')\nax.xaxis.set_label_position(\"top\")\nplt.tight_layout()\nplt.title('Confusion matrix', y=1.1)\nplt.ylabel('Actual label')\nplt.xlabel('Predicted label')","6325b2af":"print(metrics.classification_report(y, dt_model.predict(X),zero_division=1)) # Displays a comprehensive Report of the DT Model","390bd900":"from sklearn import tree","89204834":"plt.figure(figsize = (20,10))\ntree.plot_tree(dt_model);","8883aec9":"#importing KNN classifier and metric F1score\nfrom sklearn.neighbors import KNeighborsClassifier as KNN","c9a9acb2":"# important to mention that n_neighbors = 5, is not a multiple value of our quantity of features\nclf = KNN(n_neighbors = 5)\n\n# Fitting the model\nclf.fit(X_train, y_train)","7361f108":"predict_type_n = clf.predict(X_test)","55a3d42c":"from sklearn.metrics import accuracy_score\naccuracy_score(y_test,predict_type_n)","e59b8e55":"train_accuracy = []\nvalidation_accuracy = []\nfor i in range(1,15):\n    clf = KNN(n_neighbors = i)\n    clf.fit(X_train, y_train)\n    train_accuracy.append(clf.score(X_train, y_train))\n    validation_accuracy.append(clf.score(X_test, y_test))","ff691aa1":"frame = pd.DataFrame({'n_neighbors':range(1,15), 'train_acc':train_accuracy, 'valid_acc':validation_accuracy})\nframe.head(10)","c5127031":"plt.figure(figsize=(14,6))\nplt.plot(frame['n_neighbors'], frame['train_acc'], marker='o')\nplt.plot(frame['n_neighbors'], frame['valid_acc'], marker='o')\nplt.xlabel('Value of K')\nplt.ylabel('performance')\nplt.legend(['train_acc','valid_acc'])","b85792c5":"clf = KNN(n_neighbors = 8)\nclf.fit(X_train, y_train)\n#Training score\nclf.score(X_train, y_train)","bf688f84":"predict_type_n_2 = clf.predict(X_test)\npredict_type_n_2","0106c8b5":"accuracy_score(y_test,predict_type_n_2)","536842ba":"# Get the confusion Matrix of the Model\ncnf_matrix_1 = metrics.confusion_matrix(y_test,predict_type_n_2)\ncnf_matrix_1","150a15a5":"# Plot the Confusion Matrix as a HeatMap\nclass_names=[1,2,3,5,6,7] # Name  of classes\nfig, ax = plt.subplots()\ntick_marks = np.arange(len(class_names))\nplt.xticks(tick_marks, class_names)\nplt.yticks(tick_marks, class_names)\n# create heatmap\nsns.heatmap(pd.DataFrame(cnf_matrix_1), annot=True, cmap=\"YlGnBu\" ,fmt='g')\nax.xaxis.set_label_position(\"top\")\nplt.tight_layout()\nplt.title('Confusion matrix', y=1.1)\nplt.ylabel('Actual label')\nplt.xlabel('Predicted label')","8405904d":"print(metrics.classification_report(y, clf.predict(X),zero_division=1)) # Displays a comprehensive Report of the KNN Model","56c111b5":"from sklearn.svm import SVC\n","63c8d162":"clf_1=SVC(kernel='linear')","768868af":"clf_1.fit(X_train, y_train)","74d7a4e0":"clf_1.get_params()","3ddbe228":"y_pred = clf_1.predict(X_test)","bf4600eb":"# Model Accuracy: how often is the classifier correct?\nprint(\"Accuracy:\",metrics.accuracy_score(y_test, y_pred))","18caf273":"# Get the confusion Matrix of the Model\ncnf_matrix = metrics.confusion_matrix(y_test, y_pred)\ncnf_matrix","64f1cdce":"# Plot the Confusion Matrix as a HeatMap\nimport seaborn as sns\nclass_names=[1,2,3,5,6,7] # Name  of classes\nfig, ax = plt.subplots()\ntick_marks = np.arange(len(class_names))\nplt.xticks(tick_marks, class_names)\nplt.yticks(tick_marks, class_names)\n# create heatmap\nsns.heatmap(pd.DataFrame(cnf_matrix), annot=True, cmap=\"YlGnBu\" ,fmt='g')\nax.xaxis.set_label_position(\"top\")\nplt.tight_layout()\nplt.title('Confusion matrix', y=1.1)\nplt.ylabel('Actual label')\nplt.xlabel('Predicted label')","07601c66":"print(metrics.classification_report(y, clf_1.predict(X),zero_division=1)) # Displays a comprehensive Report of the SVC Model","81e0453a":"# K-Nearest Neighbour","a05c58a8":"## Prepare problem","fe2c251f":"# Finding optimum max_depth","17b58a0c":"# SVM","92220ec4":"# finding optimum k value","8c9a5cb6":"## Decision Tree ","afdd6435":"## descriptive statastics","21e2b35b":"## THANK YOU.....","1a0298b5":"## Glass Type classification \nHey there,\"welcome\" to my first notebook. I hope you benefit this notebook.\nIn this notebook, I am going to use \"Decision tree\" and \"K-nearest Neighbors\" algorithm."}}