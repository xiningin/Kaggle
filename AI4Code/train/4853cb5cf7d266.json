{"cell_type":{"ce779355":"code","ff025760":"code","c770c291":"code","3bfeaff1":"code","d8a0ac91":"code","4e6e2c8f":"code","922d0f2c":"code","a98e7af5":"code","46ed9251":"code","5119b440":"code","778dfcad":"code","c96273ba":"code","db365078":"markdown","996b2c12":"markdown","a69d4980":"markdown","dac352ab":"markdown","f3fb1ee8":"markdown","e11086cc":"markdown","3b9712a2":"markdown","f6cf3b7b":"markdown","7bd184c5":"markdown","9ed3a166":"markdown","c71cfb2d":"markdown","6fde2cf6":"markdown"},"source":{"ce779355":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","ff025760":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cv2\nimport os","c770c291":"def image_read(image1, image2, title1 = \"\", title2 = \"\"):\n    fig = plt.figure(figsize = (15, 15))\n    ax1 = fig.add_subplot(121)\n    ax1.imshow(image1, cmap = \"gray\")\n    ax1.set(xticks = [], yticks = [], title = title1)\n    ax2 = fig.add_subplot(122)\n    ax2.imshow(image2, cmap = \"gray\")\n    ax2.set(xticks = [], yticks = [], title = title2)","3bfeaff1":"path = \"\/kaggle\/input\/car-plate-detection\/images\/Cars108.png\"","d8a0ac91":"image = cv2.imread(path)\nplot_image = image_read(image, image, title1 = \"Original\", title2 = \"Original\")","4e6e2c8f":"gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)\n\nimage_read(image, gray, title1 = \"Original\", title2 = \"Gray\")","922d0f2c":"smooth = cv2.bilateralFilter(gray, 9, 75, 75)\n\nimage_read(gray, smooth, title1 = \"Gray\", title2 = \"Smooth\")","a98e7af5":"edge = cv2.Canny(smooth, 70, 400)\nimage_read(smooth, edge, title1 = \"Smooth\", title2 = \"Edge\")","46ed9251":"contours, new = cv2.findContours(edge.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\n\nimage_copy = image.copy()\n\n_ = cv2.drawContours(image_copy, contours, -1, (255, 0, 0), 2)\n\nimage_read(edge, image_copy, title1 = \"Edge\", title2 = \"Contours\")","5119b440":"contours = sorted(contours, key = cv2.contourArea, reverse = True)[:5]\n\nimage_reduced = edge.copy()\n_ = cv2.drawContours(image_reduced, contours, -1, (255, 0, 0), 2)\n\nimage_read(image_copy, image_reduced, title1 = \"Original\", title2 = \"Reduced\")","778dfcad":"plate = None\n\nfor i in contours:\n    a = cv2.arcLength(i, True)\n    edge_count = cv2.approxPolyDP(i, 0.02 * a, True)\n    if len(edge_count) == 5:\n        x, y, w, h = cv2.boundingRect(i)\n        plate = image[y:y+h, x:x+w]\n        break\n\ncv2.imwrite(\"plate.png\", plate)","c96273ba":"image_read(plate, image, title1 = \"Plate\", title2 = \"Original\")","db365078":"**\u00cen acest proiect se va \u00eencerca localizare pl\u0103cii de \u00eenmatriculare pe imaginea vehiculului. Loca\u021bia pl\u0103cii va fi determinat\u0103 doar pe o imagine selectat\u0103 aleator. \n\n**Aceast\u0103 metod\u0103 poate fi generalizat\u0103 cu alte imagini urmand pa\u0219ii de mai jos.****\n**","996b2c12":"\nS\u0103 \u00eencepem prin reprezentarea oric\u0103rei imagini pe care o alegem mai \u00eent\u00e2i pe grafic.\n\nCre\u0103m o func\u021bie numit\u0103 citire imagine \u0219i \u00eei spunem s\u0103 fac\u0103 2 fotografii \u0219i 2 titluri. Exist\u0103 dou\u0103 imagini pentru c\u0103 putem compara imaginile \u00eentre ele.","a69d4980":"\nImaginea imaginii selectate este dup\u0103 cum urmeaz\u0103.","dac352ab":"Dup\u0103 detectarea col\u021bului de margine, am ajuns la procesul de contur. Logica aici conecteaz\u0103 toate punctele continue de aceea\u0219i culoare \u0219i densitate de-a lungul marginilor lor. Pe scurt, putem spune c\u0103 include marginile \u0219i col\u021burile.","f3fb1ee8":"\u00cen ultima etap\u0103, calcul\u0103m lungimile celor 5 contururi pe care le-am preluat \u0219i determin\u0103m coordonatele de pe imagine pentru conturul asem\u0103n\u0103tor unui dreptunghi (form\u0103 de plac\u0103) \u00eentre ele. Dup\u0103 determinarea coordonatelor, zona care apar\u021bine acestor coordonate g\u0103site pe imagine este t\u0103iat\u0103 \u0219i zona care este probabil s\u0103 apar\u021bin\u0103 pl\u0103cii r\u0103m\u00e2ne.\n\nMerit\u0103 s\u0103 men\u021bion\u0103m din nou c\u0103 aceste valori prag, num\u0103rul maxim de contururi sunt valabile pentru aceast\u0103 imagine. Poate func\u021biona cu alte imagini din date, dar utilizarea acelora\u0219i valori \u00een toate nu garanteaz\u0103 c\u0103 va aduce placa corect de fiecare dat\u0103.","e11086cc":"\nBiblioteca principal\u0103 pe care o voi folosi pentru detectarea pl\u0103cilor este CV2.\n\n\u00cen acela\u0219i timp, am \u00eemp\u0103rt\u0103\u0219it resursele de care am beneficiat \u00een partea de jos a studiului \u0219i pe care cred c\u0103 le poate fi de folos, le pute\u021bi naviga","3b9712a2":"\nDup\u0103 ce l-am transformat \u00eentr-o imagine alb-negru, vom estompa imaginea. Motivul pentru aceasta este eliminarea zgomotelor din imagine. C\u00e2nd zgomotul imaginii este eliminat, marginile \u0219i liniile de col\u021b devin mai clare, beneficiul fiind c\u0103 obiectele independente din imagine pot fi selectate mai u\u0219or, de exemplu, locurile \u00een care ma\u0219ina \u00eencepe \u00een imagine sunt mai clare dec\u00e2t prima imagine, \u00een acela\u0219i mod, placa este mai pronun\u021bat\u0103 \u00een a doua imagine comparativ cu prima imagine. Ceea ce se \u00een\u021belege prin evident nu este claritate, s\u0103 nu confund\u0103m, ceea ce \u00een\u021belegem prin claritate este diferen\u021bierea \u00een imagine.\n\nFiltrul bilateral \u00een cv2 este utilizat pentru cur\u0103\u021barea zgomotului.\n\n\nDocument pentru filtru bilateral ->[https:\/\/docs.opencv.org\/master\/d4\/d13\/tutorial_py_filtering.html](http:\/\/)","f6cf3b7b":"\nProcesul de desenare a marginilor \u0219i col\u021burilor dup\u0103 procesul de albire. Dup\u0103 cum se vede mai jos, marginile \u0219i col\u021burile apar mai clar \u00een imaginea neclar\u0103. Dac\u0103 se folose\u0219te forma original\u0103 a imaginii, vor fi desenate marginile \u0219i col\u021burile acestora, cum ar fi alte obiecte pe fundalul imaginii sau umbrele reflectate pe vehicul etc., ob\u021bin\u00e2ndu-se astfel o imagine mai complex\u0103.\n\n\u00cenc\u0103 folosesc Canny \u00een cv2 pentru a desena un col\u021b \u0219i un col\u021b. Func\u021bia Canny ia ca parametri o imagine, valoarea pragului minim \u0219i valoarea pragului maxim. \u00cen\u021belesul valorilor pragului minim \u0219i maxim este acela c\u0103 determin\u0103 care dintre toate muchiile trasate sunt muchii reale \u0219i care sunt ireale. De exemplu, exist\u0103 o mul\u021bime de copaci \u00een fundalul imaginii, dac\u0103 p\u0103str\u0103m valoarea maxim\u0103 a pragului mic\u0103, va g\u0103si mai multe margini \u00een fundalul imaginii, ceea ce va face imaginea mai confuz\u0103, iar men\u021binerea valorii pragului maxim prea mare nu poate provoca margini \u0219i col\u021buri \u00een plac\u0103.\n\nDac\u0103 densitatea marginii-col\u021b este peste pragul maxim, aceasta este cu siguran\u021b\u0103 marginea, dac\u0103 densitatea marginii-col\u021b este sub valoarea pragului minim, cu siguran\u021b\u0103 nu este o margine.\n\nCanny --> [https:\/\/opencv-python-tutroals.readthedocs.io\/en\/latest\/py_tutorials\/py_imgproc\/py_canny\/py_canny.html](http:\/\/)","7bd184c5":"\nSper c\u0103 a fost util.\n\nSurse pe care le-am folosit pentru acest studiu.\n\n* [https:\/\/github.com\/ertugruldeniz\/plakatanimasistemi\/blob\/master\/ErtugrulDeniz_Plaka_Tanima_Sistemi.pdf](http:\/\/)\n\n* [https:\/\/www.youtube.com\/watch?v=UgGLo_QRHJ8&ab_channel=EdwardPie](http:\/\/)\n\n* [https:\/\/www.kitapyurdu.com\/kitap\/python-ile-imgeden-veriye-goruntu-isleme-ve-uygulamalari\/539377.html](http:\/\/)\n\n","9ed3a166":"\nImaginea 108 a fost selectat\u0103. Putem da oricare dintre numerele din date \u00een loc de 108 pentru a \u00eencerca o alt\u0103 imagine.","c71cfb2d":"\nDup\u0103 primirea imaginii, \u00eei schimb\u0103m formatul. Trecem de la imaginea RGB la imaginea alb-negru. Acest lucru se datoreaz\u0103 faptului c\u0103 procesele sunt mai simple \u0219i mai u\u0219oare pentru imaginile alb-negru. Imaginile cu culori RGB normale au 3 canale, \u00een timp ce num\u0103rul de canale este 1 \u00een imaginile alb-negru. Deoarece este mai u\u0219or de utilizat, a fost preferat\u0103 o imagine alb-negru.","6fde2cf6":"\nEnumer\u0103m toate contururile care ies dup\u0103 procesul de contur \u00een func\u021bie de dimensiunile suprafe\u021bei. Marc\u0103m cele 5 contururi (apar\u021bin\u00e2nd acestei imagini - supuse modific\u0103rilor) cu cea mai mare zon\u0103. Deci, cele cu suprafe\u021be mici sunt eliminate, cum ar fi unele zone cu copaci deasupra"}}