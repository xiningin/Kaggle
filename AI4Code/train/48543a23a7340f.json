{"cell_type":{"fcd671b6":"code","371c3ffb":"code","f42db483":"code","f717e348":"code","34e1d2d2":"code","ab222aef":"code","5dc484c8":"code","85791473":"code","d261835c":"markdown","3c3cb12b":"markdown","151970f1":"markdown","8167467a":"markdown","eb931ad8":"markdown","4d274cdf":"markdown","9d5fa4ac":"markdown"},"source":{"fcd671b6":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport collections\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","371c3ffb":"#JAWABAN LISTING 1:\n#Yang dimaksud dari listing 1 ini merupakan penciptaan dari sebuah Deque yang dimulai dengan\n#Penciptaan Deque, yang disertai untuk melihat apakah Deque tersebut kososng atau berisi\n#Setelahnya disertakan operasi operasi untuk menambah elemen 4 yang terletak di ekor Deque tersebut\n#Kemudian menambahkan elemen 'dog' di ekor Deque tersebut\n#Kemudian menambhakan elemen 'cat' di depan Deque tersebut\n#Kemudian dibuat operasi penambahan elemen True seusainya di depan Deque\n#Seusainya dibuat operasi yang tujuannya melakukan pemeriksaan seberapa panjang Deque tersebut\n#Kemudian dilakukan pemeriksaan lagi apakah deque tersebut kosong atau tidak\n#Kemudian dilakukanlah operasi untuk menambah elemen 8.4 pada ekor Deque tersebut\n#setelahnya dilakukanlah sebuah operasi yang bertujuan untuk melakukan penghapusan 1 elemen pada ekor Deque itu\n#Dan untuk sentuhan akhir, dilakukanlah operasi yang memiliki tujuan untuk penghapusan 1 elemen dari sisi depan Deque tersebut\n\n#JAWABAN LISTING 2:\n#Listing kedua ini memiliki maksud untuk melakukan penciptaan suatu program yang memiliki tujuan untuk\n#Melakukan pengecekkan apakah suatu kata tergolong palindrome atau tidak\n#Langkah pertama yang dilakukan yakni memanggil Deque dari modul pythonds.basic.deque\n#Kemudian diikuti dengan pemanggilan fungsi python yang memiliki nama fungsi \"palchecker\" serta parameternya\n#Yakni \"aString\" yang seusainya dilakukan penciptaan Deque bervariabel \"chardeque\"\n#Seusainya tambahkan elemen ch pada ekor Deque chardeque\n#Kemudian cek, jikalau masih sama (Palindrome) maka cetak \"True\"\n#Setelahnya apabila deque memiliki elemen yang lebih dari 1 namun masih sama(Palindrome) maka\n#Dimulai dengan menghapus elemen pada depan Deque chardeque\n#Lalu melakukan penghapusan elemen pada ekor Deque chardeque\n#Apabila elemen paling pertama dan paling akhir itu keduanya Palindrome,maka cetaklah\n#False,lalu melakukan pencetakkan fungsi palchecker dari \"lsdkjfskf\"\n#Dan juga lakukanlah pencetakkan dari fungsi palchecker dari \"radar\"","f42db483":"class ArrayStack:\n    \"\"\"LIFO Stack implementation using a Python list as underlying storage.\"\"\"\n\n    def __init__(self):\n        \"\"\"Create an empty stack.\"\"\"\n        self._data = []  # nonpublic list instance\n\n    def __len__(self):\n        \"\"\"Return the number of elements in the stack.\"\"\"\n        return len(self._data)\n\n    def is_empty(self):\n        \"\"\"Return True if the stack is empty.\"\"\"\n        return len(self._data) == 0\n\n    def push(self, e):\n        \"\"\"Add element e to the top of the stack.\"\"\"\n        self._data.append(e)  # new item stored at end of list\n\n    def top(self):\n        \"\"\"Return (but do not remove) the element at the top of the stack.\n\n        Raise Empty exception if the stack is empty.\n        \"\"\"\n        # if self.is_empty():\n        # raise Empty('Stack is empty')\n        return self._data[-1]  # the last item in the list\n\n    def pop(self):\n        \"\"\"Remove and return the element from the top of the stack (i.e., LIFO).\n\n        Raise Empty exception if the stack is empty.\n        \"\"\"\n        # if self.is_empty():\n        #  raise Empty('Stack is empty')\n        return self._data.pop()  # remove last item from list","f717e348":"class ArrayQueue:\n    \"\"\"FIFO queue implementation using a Python list as underlying storage.\"\"\"\n    DEFAULT_CAPACITY = 10  # moderate capacity for all new queues\n\n    def __init__(self):\n        \"\"\"Create an empty queue.\"\"\"\n        self._data = [None] * ArrayQueue.DEFAULT_CAPACITY\n        self._size = 0\n        self._front = 0\n\n    def __len__(self):\n        \"\"\"Return the number of elements in the queue.\"\"\"\n        return self._size\n\n    def is_empty(self):\n        \"\"\"Return True if the queue is empty.\"\"\"\n        return self._size == 0\n\n    def first(self):\n        \"\"\"Return (but do not remove) the element at the front of the queue.\n\n        Raise Empty exception if the queue is empty.\n        \"\"\"\n        # if self.is_empty():\n            # raise Empty('Queue is empty')\n        return self._data[self._front]\n\n    def dequeue(self):\n        \"\"\"Remove and return the first element of the queue (i.e., FIFO).\n\n        Raise Empty exception if the queue is empty.\n        \"\"\"\n        # if self.is_empty():\n          #  raise Empty('Queue is empty')\n        answer = self._data[self._front]\n        self._data[self._front] = None  # help garbage collection\n        self._front = (self._front + 1) % len(self._data)\n        self._size -= 1\n        return answer\n\n    def enqueue(self, e):\n        \"\"\"Add an element to the back of queue.\"\"\"\n        if self._size == len(self._data):\n            self._resize(2 * len(self.data))  # double the array size\n        avail = (self._front + self._size) % len(self._data)\n        self._data[avail] = e\n        self._size += 1\n\n    def _resize(self, cap):  # we assume cap >= len(self)\n        \"\"\"Resize to a new list of capacity >= len(self).\"\"\"\n        old = self._data  # keep track of existing list\n        self._data = [None] * cap  # allocate list with new capacity\n        walk = self._front\n        for k in range(self._size):  # only consider existing elements\n            self._data[k] = old[walk]  # intentionally shift indices\n            walk = (1 + walk) % len(old)  # use old size as modulus\n        self._front = 0  # front has been realigned","34e1d2d2":"stack = ArrayStack()\n\nstack.push(5)\nprint(stack._data)\n\nstack.push(3)\nprint(stack._data)\n\npop = stack.pop()\nprint('Return:', pop)\nprint(stack._data)\n\nstack.push(2)\nprint(stack._data)\n\nstack.push(8)\nprint(stack._data)\n\npop = stack.pop()\nprint('Return:', pop)\nprint(stack._data)\n\npop = stack.pop()\nprint('Return:', pop)\nprint(stack._data)\n\nstack.push(9)\nprint(stack._data)\n\nstack.push(1)\nprint(stack._data)\n\npop = stack.pop()\nprint('Return:', pop)\nprint(stack._data)\n\nstack.push(7)\nprint(stack._data)\n\nstack.push(6)\nprint(stack._data)\n\npop = stack.pop()\nprint('Return:', pop)\nprint(stack._data)\n\npop = stack.pop()\nprint('Return:', pop)\nprint(stack._data)\n\nstack.push(4)\nprint(stack._data)\n\npop = stack.pop()\nprint('Return:', pop)\nprint(stack._data)\n\npop = stack.pop()\nprint('Return:', pop)\nprint(stack._data)","ab222aef":"q = ArrayQueue()\nprint(q._data)\n\nq.enqueue(5)\nprint(q._data)\n\nq.enqueue(3)\nprint(q._data)\n\ndequeue = q.dequeue()\nprint('Return:', dequeue)\n\nq.enqueue(2)\nprint(q._data)\n\nq.enqueue(8)\nprint(q._data)\n\ndequeue = q.dequeue()\nprint('Return:', dequeue)\n\ndequeue = q.dequeue()\nprint('Return:', dequeue)\n\nq.enqueue(9)\nprint(q._data)\n\nq.enqueue(1)\nprint(q._data)\n\ndequeue = q.dequeue()\nprint('Return:', dequeue)\n\nq.enqueue(7)\nprint(q._data)\n\nq.enqueue(6)\nprint(q._data)\n\ndequeue = q.dequeue()\nprint('Return:', dequeue)\n\ndequeue = q.dequeue()\nprint('Return:', dequeue)\n\nq.enqueue(4)\nprint(q._data)\n\ndequeue = q.dequeue()\nprint('Return:', dequeue)\n\ndequeue = q.dequeue()\nprint('Return:', dequeue)\n\nprint(q._data)","5dc484c8":"deque = collections.deque([1, 2, 3, 4, 5, 6, 7, 8])\nprint(deque)\nqueue = ArrayQueue()\nwhile not len(deque) == 0:\n    queue.enqueue(deque.popleft())\nprint('Queue - Length:  ', len(queue))\nprint('Queue - First Element: ', queue.first(), '\\n')","85791473":"deque_two = collections.deque([1, 2, 3, 4, 5, 6, 7, 8])\nstack = ArrayStack()\nprint(deque_two)\nwhile not len(deque_two) == 0:\n    stack.push(deque_two.popleft())\nprint('Stack - Length: ', len(stack))\nprint('Stack - Top Element: ', stack.top())","d261835c":"7. (R-6.14) Repeat the previous problem using the deque D and an initially empty stack S.","3c3cb12b":"1. (R-6.1) What values are returned during the following series of stack operations, if executed upon an initially empty stack? \n\npush(5), push(3), pop(), push(2), push(8), pop(), pop(), push(9), push(1), pop(), push(7), push(6), pop(), pop(), push(4), pop(), pop().","151970f1":"2. (R-6.2) Suppose an initially empty stack S has executed a total of 25 push operations, 12 top operations, and 10 pop operations, 3 of which raised Empty errors that were caught and ignored. What is the current size of S?\n\nSize of S:\nOnly 7 pop operations removed elements as pop errors do not remove any elements from the stack.\nStack size = 25 (push operations) - 7 (pop operations that removed elements from the stack)\nStack size = 18","8167467a":"3. (R-6.3) Implement a function transfer(S, T) that transfers all elements from stack S onto stack T, so that the element that starts at the top of S is the first to be inserted onto T, and the element at the bottom of S ends up at the top of T. Use ArrayStack (ch06\/array_stack.py) to test your function.","eb931ad8":"4. (R-6.7) What values are returned during the following sequence of queue operations, if executed on an initially empty queue?","4d274cdf":"6. (R-6.13) Suppose you have a deque D containing the numbers (1,2,3,4,5,6,7,8), in this order. Suppose further that you have an initially empty queue Q. Give a code fragment that uses only D and Q (and no other variables) and results in D storing the elements in the order (1,2,3,5,4,6,7,8).","9d5fa4ac":"5. (R-6.8) Suppose an initially empty queue Q has executed a total of 32 enqueue operations. 15 dequeue operations were also executed, 5 of which raised Empty errors that were caught and ignored. What is the current size of Q?\n\nSize of Q: \n\n32 enqueue operations - 10 dequeue operations  (5 empty errors did not alter the size of Q)\nSize of Q = 22"}}