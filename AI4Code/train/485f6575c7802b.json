{"cell_type":{"517c55ad":"code","1d12df0b":"code","448d9ba6":"code","4056d0e6":"code","ea9106c1":"code","fac21c3c":"code","d336521f":"code","f55e86bb":"code","6b993916":"code","ec42ba2d":"code","02f40ef7":"code","c61f29b5":"code","05ec5f86":"code","676e15db":"code","53d205e2":"code","c56a7e06":"code","46d78a59":"code","6a6cdcf3":"code","d388a286":"code","8babb3bb":"code","a14412cb":"code","638a2adc":"code","bb667a15":"markdown","f1c06740":"markdown","0cc9059e":"markdown"},"source":{"517c55ad":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","1d12df0b":"import copy\nimport numpy as np\nimport pandas as pd\nimport warnings\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn import metrics\nimport lightgbm as lgb_r\nfrom lightgbm import Dataset\nfrom optuna.integration import lightgbm as lgb\nfrom catboost import CatBoostClassifier, Pool\nfrom sklearn.linear_model import LinearRegression\nimport tensorflow as tf\n\nnp.random.seed(42)\nwarnings.filterwarnings(\"ignore\")","448d9ba6":"TRAIN_RAW_PATH = \"..\/input\/ai-medical-contest-2020\/train.csv\"\nTEST_RAW_PATH = \"..\/input\/ai-medical-contest-2020\/test.csv\"\nSUB_RAW_PATH = \"..\/input\/ai-medical-contest-2020\/sample_submission.csv\"\nCOLS_CAT = [  # \u30ab\u30c6\u30b4\u30ea\u5909\u6570\u306e\u30ea\u30b9\u30c8\n    \"type_hospital\",\n    \"place_hospital\",\n    \"place_patient_birth\",\n    \"place_patient_live\",\n    \"place_patient_live2\",\n    \"patient_type\",\n    \"icu\",\n    \"intubed\",\n    \"sex\",\n    \"asthma\",\n    \"cardiovascular\",\n    \"chronic_renal_failure\",\n    \"copd\",\n    \"diabetes\",\n    \"hypertension\",\n    \"immunosuppression\",\n    \"obesity\",\n    \"pneumonia\",\n    \"pregnancy\",\n    \"other_disease\",\n    \"tobacco\",\n    \"contact_other_covid\",\n    \"test_result\",\n]","4056d0e6":"class Preprocessing:\n    def __init__(self, train_path, test_path, include_cat=True):\n        self.df_train = pd.read_csv(train_path)\n        self.df_test = pd.read_csv(test_path)\n        self.df_traintest = self.make_traintest()\n        self.df_traintest = self.preprocessing(include_cat)\n        self.df_traintest = self.generate_features()\n        self.df_train, self.df_test = self.create_folds()\n\n    def make_traintest(self):\n        # traintest\u30d5\u30a1\u30a4\u30eb\u3092\u4f5c\u308b\n        df_traintest = pd.concat([self.df_train, self.df_test]).reset_index(drop=True)\n        format = \"%Y-%m-%d\"  # \u4e8c\u6b21\u5730\u8868\u793a\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8, \u4f8b) 2020-09-26\n        cols_time = [\"entry_date\", \"date_symptoms\", \"date_died\"]  # \u65e5\u6642\u3092\u8868\u3059\u5217\u540d\u306e\u30ea\u30b9\u30c8\n        for col in cols_time:  # \u5404\u5217\u306b\u3064\u3044\u3066\n            df_traintest[col] = pd.to_datetime(\n                df_traintest[col], format=format\n            )  # string\u578b\u304b\u3089datetime\u578b\u306b\u5909\u63db\n        return df_traintest\n\n    def preprocessing(self, include_cat=True):\n        df_traintest = self.df_traintest\n        cols_tmp = [\n                \"icu\",\n                \"intubed\",\n                \"asthma\",\n                \"cardiovascular\",\n                \"chronic_renal_failure\",\n                \"copd\",\n                \"diabetes\",\n                \"hypertension\",\n                \"immunosuppression\",\n                \"obesity\",\n                \"pneumonia\",\n                \"pregnancy\",\n                \"other_disease\",\n                \"tobacco\",\n                \"contact_other_covid\",\n            ]\n        for col in cols_tmp:\n            df_traintest[col] = df_traintest[col].replace(\"No\", 0)\n            df_traintest[col] = df_traintest[col].replace(\"Yes\", 1)\n            df_traintest[col] = df_traintest[col].fillna(2)\n            df_traintest[col] = df_traintest[col].astype(int)\n        # int\u306b\u3059\u308b\n        df_traintest[\"place_patient_birth\"] = df_traintest[\n            \"place_patient_birth\"\n        ].fillna(\n            33\n        )  # nan\u3092\u65b0\u898f\u306e\u30ab\u30c6\u30b4\u30ea 33 \u306b\u7f6e\u63db\n        df_traintest[\"place_patient_birth\"] = df_traintest[\n            \"place_patient_birth\"\n        ].astype(int)\n\n        # \u65e5\u6642\u5909\u6570\u30921\u67081\u65e5\u304b\u3089\u6570\u3048\u305f\u65e5\u6570\u306b\u5909\u63db\u3059\u308b\n        df_traintest[\"entry_date\"] = (\n            df_traintest[\"entry_date\"].apply(lambda x: x.dayofyear).astype(np.uint16)\n        )\n        df_traintest[\"date_symptoms\"] = (\n            df_traintest[\"date_symptoms\"].apply(lambda x: x.dayofyear).astype(np.uint16)\n        )\n        \n        if include_cat:\n            # \u30ab\u30c6\u30b4\u30ea\u5909\u6570\u3092\u30e9\u30d9\u30eb\u30a8\u30f3\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3059\u308b (\u6570\u5024\u306b\u7f6e\u304d\u63db\u3048\u308b).\n            df_traintest[\"sex\"] = df_traintest[\"sex\"].replace(\n                \"female\", 0\n            )  # female\u306b0\u3092\u4ee3\u5165\n            df_traintest[\"sex\"] = df_traintest[\"sex\"].replace(\"male\", 1)  # male\u306b1\u3092\u4ee3\u5165\n            df_traintest[\"sex\"] = df_traintest[\"sex\"].astype(int)  # \u578b\u3092\u6574\u6570\u306b\u5909\u63db\n\n            df_traintest[\"patient_type\"] = df_traintest[\"patient_type\"].replace(\n                \"inpatient\", 0\n            )\n            df_traintest[\"patient_type\"] = df_traintest[\"patient_type\"].replace(\n                \"outpatient\", 1\n            )\n            df_traintest[\"patient_type\"] = df_traintest[\"patient_type\"].astype(int)\n\n            \n            df_traintest[\"test_result\"] = df_traintest[\"test_result\"].replace(\n                \"Negative\", 0\n            )\n            df_traintest[\"test_result\"] = df_traintest[\"test_result\"].replace(\n                \"Positive\", 1\n            )\n            df_traintest[\"test_result\"] = df_traintest[\"test_result\"].replace(\n                \"Results awaited\", 1\n            )\n            df_traintest[\"test_result\"] = df_traintest[\"test_result\"].astype(int)\n        \n        return df_traintest\n\n    def generate_features(self):\n        df_traintest = self.df_traintest\n        col_index = \"patient_id\"  # id\u306e\u5217\n        # \u5909\u6570\u3068\u5909\u6570\u306e\u5dee\u3092\u3068\u308b\n        df_traintest[\"entry_-_symptom_date\"] = (\n            df_traintest[\"entry_date\"] - df_traintest[\"date_symptoms\"]\n        )  # \u767a\u75c7\u304b\u3089\u5165\u9662\u307e\u3067\u306e\u65e5\u6570\n\n        # \u5909\u6570\u3068\u5909\u6570\u306e\u4e57\u7b97\u3092\u3068\u308b\n        age = df_traintest[\"age\"].values\n        age = (age - age.mean()) \/ age.std()  # \u5e74\u9f62\u3092\u6b63\u898f\u5316\n        entry_date = df_traintest[\"entry_date\"].values\n        entry_date = (entry_date - entry_date.mean()) \/ entry_date.std()  # \u5e74\u9f62\u3092\u6b63\u898f\u5316\n        df_traintest[\"age_x_entry_date\"] = (\n            age * entry_date\n        )  # \u5e74\u9f62\u3068\u5165\u9662\u65e5\u3092\u4e57\u7b97. 2\u3064\u306e\u5909\u6570\u306e\u76f8\u4e92\u4f5c\u7528\u3092\u8868\u73fe\u3067\u304d\u308b\n\n        # \u30ab\u30a6\u30f3\u30c8\u30a8\u30f3\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\n        # \u3042\u308b\u30ab\u30c6\u30b4\u30ea\u304c\u30c7\u30fc\u30bf\u306b\u4f55\u4ef6\u3042\u308b\u304b\u3001\u3092\u7279\u5fb4\u91cf\u3068\u3059\u308b. \u4f8b) \u5165\u9662\u65e5\u304c2020\/1\/1\u306e\u884c\u304c\u4f55\u4ef6\u3042\u308b\u304b\n        col_groupby = \"entry_date\"  # \u30ab\u30a6\u30f3\u30c8\u3092\u884c\u3046\u5217\n        df_tmp = copy.deepcopy(df_traintest)\n        df_agg = (\n            df_traintest.groupby(col_groupby)[col_index].agg(len).reset_index()\n        )  # \u96c6\u7d04\u7279\u5fb4\u91cf\u3092\u5f97\u308b\n        col_new = \"entry_date_count\"  # \u7279\u5fb4\u91cf\u540d. \u5404\u65e5\u306e\u5165\u9662\u60a3\u8005\u6570\n        df_agg.columns = [col_groupby, col_new]\n        df_tmp = pd.merge(df_tmp, df_agg, on=col_groupby, how=\"left\").drop(\n            col_groupby, axis=1\n        )\n        df_traintest[col_new] = df_tmp[col_new]\n        return df_traintest\n\n    def create_folds(self):\n        df_traintest = self.df_traintest\n        df_train = df_traintest.iloc[: len(self.df_train)]\n        df_test = df_traintest.iloc[len(self.df_train) :].reset_index(drop=True)\n        df_train[\"skfold\"] = -1\n        skf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)\n        folds = skf.split(\n            np.arange(len(df_train)), y=df_train[\"died\"]\n        )  # \u5404fold\u30bf\u30fc\u30b2\u30c3\u30c8\u306e\u30e9\u30d9\u30eb\u306e\u5206\u5e03\u304c\u305d\u308d\u3046\u3088\u3046\u306b\u3059\u308b = stratified K fold\n        for fold, (trn_, val_) in enumerate(folds):\n            df_train.loc[val_, \"skfold\"] = fold\n\n        return (df_train, df_test)","ea9106c1":"def load_data(df_train, df_test, fold):\n    cols_feature = df_train.columns.values.tolist()[3:-1]\n    tr_X = df_train[df_train.skfold != fold][cols_feature]\n    val_X = df_train[df_train.skfold == fold][cols_feature]\n    tr_y = df_train[df_train.skfold != fold][\"died\"]\n    val_y = df_train[df_train.skfold == fold][\"died\"]\n    test_X = df_test[cols_feature]\n    return (tr_X, tr_y, val_X, val_y, test_X)","fac21c3c":"def run_baseline(tr_X, tr_y, val_X, val_y, fold, COLS_CAT):\n    params = {\n        \"objective\": \"binary\",  # \u76ee\u7684->2\u5024\u5206\u985e\n        \"num_threads\": -1,\n        \"bagging_seed\": 42,  # random seed \u306e\u56fa\u5b9a\n        \"random_state\": 42,  # random seed \u306e\u56fa\u5b9a\n        \"boosting\": \"gbdt\",\n        \"metric\": \"auc\",  # \u8a55\u4fa1\u5909\u6570->AUC\n        \"verbosity\": -1,\n    }\n    train_data = Dataset(\n        tr_X, label=tr_y, categorical_feature=COLS_CAT\n    )  # LightGBM\u7528\u306b\u30c7\u30fc\u30bf\u3092\u6574\u5f62\n    valid_data = Dataset(val_X, label=val_y, categorical_feature=COLS_CAT)\n    model = lgb_r.train(\n        params,  # \u30e2\u30c7\u30eb\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\n        train_data,  # \u5b66\u7fd2\u30c7\u30fc\u30bf\n        150000,  # \u5b66\u7fd2\u3092\u7e70\u308a\u8fd4\u3059\u6700\u5927epoch\u6570, epoch = \u30e2\u30c7\u30eb\u306e\u5b66\u7fd2\u56de\u6570\n        valid_sets=[train_data, valid_data],  # \u691c\u8a3c\u30c7\u30fc\u30bf\n        verbose_eval=100,  # 100 epoch \u3054\u3068\u306b\u7d4c\u904e\u3092\u8868\u793a\u3059\u308b\n        early_stopping_rounds=150,  # 150epoch\u7d9a\u3051\u3066\u691c\u8a3c\u30c7\u30fc\u30bf\u306e\u30ed\u30b9\u304c\u6e1b\u3089\u306a\u304b\u3063\u305f\u3089\u5b66\u7fd2\u3092\u4e2d\u65ad\u3059\u308b\n    )\n    return model","d336521f":"def lgb_optuna(tr_X, tr_y, val_X, val_y, fold, COLS_CAT):\n    dtrain = Dataset(\n        tr_X, tr_y, categorical_feature=COLS_CAT, free_raw_data=False\n    )\n    dval = Dataset(\n        val_X, val_y, categorical_feature=COLS_CAT, free_raw_data=False\n    )\n    params = {\n        \"objective\": \"binary\",  # \u76ee\u7684->2\u5024\u5206\u985e\n        \"num_threads\": -1,\n        \"bagging_seed\": 42,  # random seed \u306e\u56fa\u5b9a\n        \"random_state\": 42,  # random seed \u306e\u56fa\u5b9a\n        \"boosting\": \"gbdt\",\n        \"metric\": \"auc\",  # \u8a55\u4fa1\u5909\u6570->AUC\n        \"verbosity\": -1,\n    }\n\n    model = lgb.train(\n        params,  # \u30e2\u30c7\u30eb\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\n        dtrain,  # \u5b66\u7fd2\u30c7\u30fc\u30bf\n        150000,  # \u5b66\u7fd2\u3092\u7e70\u308a\u8fd4\u3059\u6700\u5927epoch\u6570, epoch = \u30e2\u30c7\u30eb\u306e\u5b66\u7fd2\u56de\u6570\n        valid_sets=[dtrain, dval],  # \u691c\u8a3c\u30c7\u30fc\u30bf\n        verbose_eval=100,  # 100 epoch \u3054\u3068\u306b\u7d4c\u904e\u3092\u8868\u793a\u3059\u308b\n        early_stopping_rounds=150,  # 150epoch\u7d9a\u3051\u3066\u691c\u8a3c\u30c7\u30fc\u30bf\u306e\u30ed\u30b9\u304c\u6e1b\u3089\u306a\u304b\u3063\u305f\u3089\u5b66\u7fd2\u3092\u4e2d\u65ad\u3059\u308b\n    )\n\n    best_params = model.params\n    print(\"Best params:\", best_params)\n    print(\"  Params: \")\n    for key, value in best_params.items():\n        print(\"    {}: {}\".format(key, value))\n    return model","f55e86bb":"def run_cat(train_pool, validate_pool, fold):\n\n    # \u5b66\u7fd2\n    model = CatBoostClassifier(iterations=50, custom_loss=[\"AUC\"])\n    model.fit(\n        train_pool,\n        eval_set=validate_pool,  # \u691c\u8a3c\u7528\u30c7\u30fc\u30bf\n        early_stopping_rounds=150,  # 150\u56de\u4ee5\u4e0a\u7cbe\u5ea6\u304c\u6539\u5584\u3057\u306a\u3051\u308c\u3070\u4e2d\u6b62\n        use_best_model=True,\n        verbose=False,\n    )\n    print(model.get_best_score())\n    # \u4e88\u6e2c\n    preds = model.predict_proba(validate_pool)[:, 1]\n    return model","6b993916":"pp_lgb = Preprocessing(\n            TRAIN_RAW_PATH, TEST_RAW_PATH, include_cat=True\n        )\ndf_train = pp_lgb.df_train\ndf_test = pp_lgb.df_test\n\npreds_val_base = []\npreds_test_base = []\n\nfor fold in range(0, 5):\n    tr_X, tr_y, val_X, val_y, test_X = load_data(df_train, df_test, fold)\n    model = run_baseline(tr_X, tr_y, val_X, val_y, fold, COLS_CAT)\n    pred_val = model.predict(\n        val_X, num_iteration=model.best_iteration\n    )  # \u691c\u8a3c\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u4e88\u6e2c\u3092\u5b9f\u884c\n    preds_val_base.append(pred_val)\n    pred_test = model.predict(\n        test_X, num_iteration=model.best_iteration\n    )  # \u30c6\u30b9\u30c8\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u4e88\u6e2c\u3092\u5b9f\u884c\n    preds_test_base.append(pred_test)\n    score = metrics.roc_auc_score(val_y, pred_val)\n    print(score)\npreds_test_mean_base = np.array(preds_test_base).mean(\n            axis=0\n)  # \u30e2\u30c7\u30eb\u30925\u500b\u4f5c\u3063\u305f\u306e\u3067\u4e88\u6e2c\u306f\u4e00\u3064\u306e\u30c7\u30fc\u30bf\u306b5\u500b\u3042\u308b. \u3053\u308c\u3092\u5e73\u5747\u3059\u308b.","ec42ba2d":"pp_cat = Preprocessing(\n    TRAIN_RAW_PATH, TEST_RAW_PATH, include_cat=False\n)\ndf_train = pp_cat.df_train\ndf_test = pp_cat.df_test\n\npreds_test_cat = []\npreds_val_cat = []\n\nfor fold in range(0, 5):\n    tr_X, tr_y, val_X, val_y, test_X = load_data(df_train, df_test, fold)\n    cat_features = [tr_X.columns.get_loc(col) for col in COLS_CAT]\n    train_pool = Pool(tr_X, tr_y, cat_features=cat_features)\n    validate_pool = Pool(val_X, val_y, cat_features=cat_features)\n    test_pool = Pool(test_X, cat_features=cat_features)\n    model = run_cat(train_pool, validate_pool, fold)\n    pred_val = model.predict_proba(validate_pool)[:, 1]  # \u691c\u8a3c\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u4e88\u6e2c\u3092\u5b9f\u884c\n    preds_val_cat.append(pred_val)\n    pred_test = model.predict_proba(test_pool)[:, 1]  # \u30c6\u30b9\u30c8\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u4e88\u6e2c\u3092\u5b9f\u884c\n    preds_test_cat.append(pred_test)\n    score = metrics.roc_auc_score(val_y, pred_val)\n    print(score)\n    \npreds_test_mean_cat = np.array(preds_test_cat).mean(\n            axis=0\n)  # \u30e2\u30c7\u30eb\u30925\u500b\u4f5c\u3063\u305f\u306e\u3067\u4e88\u6e2c\u306f\u4e00\u3064\u306e\u30c7\u30fc\u30bf\u306b5\u500b\u3042\u308b. \u3053\u308c\u3092\u5e73\u5747\u3059\u308b.","02f40ef7":"df_train = pp_lgb.df_train\ndf_test = pp_lgb.df_test\n\npreds_test_lgb = []\npreds_val_lgb = []\nfor fold in range(0, 5):\n    tr_X, tr_y, val_X, val_y, test_X = load_data(df_train, df_test, fold)\n    model = lgb_optuna(tr_X, tr_y, val_X, val_y, fold, COLS_CAT)\n    pred_val = model.predict(\n        val_X, num_iteration=model.best_iteration\n    )  # \u691c\u8a3c\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u4e88\u6e2c\u3092\u5b9f\u884c\n    preds_val_lgb.append(pred_val)\n    pred_test = model.predict(\n        test_X, num_iteration=model.best_iteration\n    )  # \u30c6\u30b9\u30c8\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u4e88\u6e2c\u3092\u5b9f\u884c\n    preds_test_lgb.append(pred_test)\n    score = metrics.roc_auc_score(val_y, pred_val)\n    print(score)\npreds_test_mean_lgb = np.array(preds_test_lgb).mean(\n            axis=0\n)  # \u30e2\u30c7\u30eb\u30925\u500b\u4f5c\u3063\u305f\u306e\u3067\u4e88\u6e2c\u306f\u4e00\u3064\u306e\u30c7\u30fc\u30bf\u306b5\u500b\u3042\u308b. \u3053\u308c\u3092\u5e73\u5747\u3059\u308b.","c61f29b5":"def generate_stack_train(preds_val_base, preds_val_lgb, preds_val_cat):\n    df_ = df_train[[\"patient_id\", \"skfold\"]]\n    \n    id_ = [\n        df_[df_[\"skfold\"] == fold][\"patient_id\"] for fold in range(5)\n    ]\n    pred_folds = [\n        pd.DataFrame(\n            {\"patient_id\": id_[fold], \"pred_base\": preds_val_base[fold],\n            \"pred_lgb\": preds_val_lgb[fold], \"pred_cat\": preds_val_cat[fold]}\n        )\n        for fold in range(5)\n    ]\n    features_by_model = pd.concat(pred_folds)\n    return df_.drop([\"skfold\"],axis=1).merge(features_by_model, on=\"patient_id\")","05ec5f86":"def generate_stack_test(preds_test_mean_base, preds_test_mean_lgb, preds_test_mean_cat):\n    id_ = df_test[\"patient_id\"]\n    \n    pred_ = pd.DataFrame(\n            {\"patient_id\": id_, \"pred_base\": preds_test_mean_base,\n            \"pred_lgb\": preds_test_mean_lgb, \"pred_cat\": preds_test_mean_cat}\n    )\n    return pred_","676e15db":"train_stack = generate_stack_train(preds_val_base, preds_val_lgb, preds_val_cat)\ntest_stack = generate_stack_test(preds_test_mean_base, preds_test_mean_lgb, preds_test_mean_cat)","53d205e2":"# NN\nmodel = tf.keras.Sequential([\n    tf.keras.layers.Dense(units=1, input_shape=(None,3)),\n    tf.keras.layers.Dense(128),\n    tf.keras.layers.Dense(64),\n    tf.keras.layers.Dense(1, activation='sigmoid')\n])\nmodel.compile(optimizer=\"adam\", loss=\"binary_crossentropy\", metrics=[tf.keras.metrics.AUC()])\n\nX = train_stack[[\"pred_base\",\"pred_cat\",\"pred_lgb\"]]\ny = df_train[\"died\"]\n\n\nmodel.fit(X, y, batch_size=50, epochs=10)\n\npred = model.predict_proba(X)\nscore = metrics.roc_auc_score(y, pred)\nprint(score)\nsubmission_id = pd.read_csv(SUB_RAW_PATH)[\"patient_id\"]\nfinal_pred = np.ravel(model.predict_proba(test_stack[[\"pred_base\",\"pred_cat\",\"pred_lgb\"]]))\npd.DataFrame({'patient_id': submission_id, 'died': final_pred}).to_csv(\"submission.csv\", index=False)","c56a7e06":"# all\nX = train_stack.drop([\"patient_id\"],axis=1)\ny = df_train[\"died\"]\nreg = LinearRegression().fit(X,y)\npred = reg.predict(X)\nscore = metrics.roc_auc_score(y, pred)\nprint(score)\nsubmission_id = pd.read_csv(SUB_RAW_PATH)[\"patient_id\"]\nfinal_pred = reg.predict(test_stack.drop([\"patient_id\"], axis=1))\npd.DataFrame({'patient_id': submission_id, 'died': final_pred}).to_csv(\"submission_all.csv\", index=False)","46d78a59":"# baseline + lgb_optuna\nX = train_stack.drop([\"patient_id\",\"pred_cat\"],axis=1)\ny = df_train[\"died\"]\nreg = LinearRegression().fit(X,y)\npred = reg.predict(X)\nscore = metrics.roc_auc_score(y, pred)\nprint(score)\nsubmission_id = pd.read_csv(SUB_RAW_PATH)[\"patient_id\"]\nfinal_pred = reg.predict(test_stack.drop([\"patient_id\",\"pred_cat\"], axis=1))\npd.DataFrame({'patient_id': submission_id, 'died': final_pred}).to_csv(\"submission_bl.csv\", index=False)","6a6cdcf3":"# baseline + cat\nX = train_stack.drop([\"patient_id\",\"pred_lgb\"],axis=1)\ny = df_train[\"died\"]\nreg = LinearRegression().fit(X,y)\npred = reg.predict(X)\nscore = metrics.roc_auc_score(y, pred)\nprint(score)\nsubmission_id = pd.read_csv(SUB_RAW_PATH)[\"patient_id\"]\nfinal_pred = reg.predict(test_stack.drop([\"patient_id\",\"pred_lgb\"], axis=1))\npd.DataFrame({'patient_id': submission_id, 'died': final_pred}).to_csv(\"submission_bc.csv\", index=False)","d388a286":"# lgb_optuna + cat\nX = train_stack.drop([\"patient_id\",\"pred_base\"],axis=1)\ny = df_train[\"died\"]\nreg = LinearRegression().fit(X,y)\npred = reg.predict(X)\nscore = metrics.roc_auc_score(y, pred)\nprint(score)\nsubmission_id = pd.read_csv(SUB_RAW_PATH)[\"patient_id\"]\nfinal_pred = reg.predict(test_stack.drop([\"patient_id\",\"pred_base\"], axis=1))\npd.DataFrame({'patient_id': submission_id, 'died': final_pred}).to_csv(\"submission_lc.csv\", index=False)","8babb3bb":"# baseline\nsubmission_id = pd.read_csv(SUB_RAW_PATH)[\"patient_id\"]\nfinal_pred = preds_test_mean_base\npd.DataFrame({'patient_id': submission_id, 'died': final_pred}).to_csv(\"submission_b.csv\", index=False)","a14412cb":"# lgb_optuna\nsubmission_id = pd.read_csv(SUB_RAW_PATH)[\"patient_id\"]\nfinal_pred = preds_test_mean_lgb\npd.DataFrame({'patient_id': submission_id, 'died': final_pred}).to_csv(\"submission_l.csv\", index=False)","638a2adc":"# cat\nsubmission_id = pd.read_csv(SUB_RAW_PATH)[\"patient_id\"]\nfinal_pred = preds_test_mean_cat\npd.DataFrame({'patient_id': submission_id, 'died': final_pred}).to_csv(\"submission_c.csv\", index=False)","bb667a15":"# \u524d\u51e6\u7406","f1c06740":"# \u5b66\u7fd2","0cc9059e":"# stacking"}}