{"cell_type":{"6b01b70e":"code","dbe7f96a":"code","5b4af7cd":"code","12caf13b":"code","70b1a0c7":"code","051ccd7a":"code","f18afc85":"code","2cd069e1":"code","61f3a9ec":"code","c2b55eed":"code","0834165a":"code","447f3051":"code","efd3c19a":"code","2b4053ad":"code","254a69b4":"code","9d5319ca":"code","2d10dfd6":"code","226d1163":"code","9f7c4d91":"code","e3752650":"code","3e6ba1a9":"code","e606de3b":"code","5cff6bc3":"code","a5eb56bf":"code","95d3fd84":"code","dca42864":"markdown","899b4177":"markdown","82ba04b1":"markdown","c16b8329":"markdown","ba06144f":"markdown","87575364":"markdown","ea6b269f":"markdown","65d20e0f":"markdown","03862274":"markdown"},"source":{"6b01b70e":"from pathlib import Path\nimport os, shutil, time\nfrom skimage import io\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nimport plotly.express as px\nimport plotly.figure_factory as ff\nimport plotly.graph_objects as go\n\nimport keras\nfrom keras.applications import VGG16\nfrom keras import models, layers, optimizers\nfrom keras.optimizers import Nadam\nfrom keras.preprocessing.image import ImageDataGenerator\n\nimport tensorflow as tf\nfrom sklearn.metrics import roc_auc_score, roc_curve, precision_recall_curve, auc ,confusion_matrix, classification_report\nimport cv2\n","dbe7f96a":"dir_labels = ['PNEUMONIA', 'NORMAL']\nimg_size = 224\ndef get_training_data(data_dir):\n    data = [] \n    for label in dir_labels: \n        path = os.path.join(data_dir, label)\n        for img in os.listdir(path):\n            try:\n                img_arr = cv2.imread(os.path.join(path, img), cv2.IMREAD_COLOR)\n                resized_arr = cv2.resize(img_arr, (img_size, img_size)) # Reshaping images to preferred size\n                if label == 'NORMAL':\n                    data.append([resized_arr, 0])\n                if label == 'PNEUMONIA':\n                    if 'virus' in img:\n                        data.append([resized_arr, 1])\n                    if 'bacteria' in img:\n                        data.append([resized_arr, 2])\n            except Exception as e:\n                print(e)\n    return np.array(data)","5b4af7cd":"train = get_training_data('..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/train')\ntest = get_training_data('..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/test')\nval = get_training_data('..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/val')","12caf13b":"labels = ['Normal', 'Viral','Bacterial']\n\nx_train = []\ny_train = []\n\nx_val = []\ny_val = []\n\nx_test = []\ny_test = []\n\nfor feature, label in train:\n    x_train.append(feature)\n    y_train.append(label)\n\nfor feature, label in test:\n    x_test.append(feature)\n    y_test.append(label)\n    \nfor feature, label in val:\n    x_val.append(feature)\n    y_val.append(label)","70b1a0c7":"for i in range(1):\n    fig = px.imshow(x_train[i], color_continuous_scale='gray', title=labels[y_train[i]])\n    fig.show()","051ccd7a":"# Normalize the data\nx_train = np.array(x_train)\nx_val = np.array(x_val)\nx_test = np.array(x_test)\n\n# resize data for deep learning \nx_train = x_train.reshape(-1, img_size, img_size, 3)\ny_train = np.array(y_train)\n\nx_val = x_val.reshape(-1, img_size, img_size, 3)\ny_val = np.array(y_val)\n\nx_test = x_test.reshape(-1, img_size, img_size, 3)\ny_test = np.array(y_test)","f18afc85":"df_train = pd.DataFrame(y_train)\ndf_train = pd.DataFrame(df_train.value_counts(), columns=['Train'])\ndf_val = pd.DataFrame(y_val)\ndf_val = pd.DataFrame(df_val.value_counts(), columns=['Val'])\ndf_test = pd.DataFrame(y_test)\ndf_test = pd.DataFrame(df_test.value_counts(), columns=['Test'])\n\ndf_train = df_train.join([df_test, df_val])\ndf_train = df_train.reset_index().T.drop([0])\ndf_train.columns = ['Bacterial', 'Viral', 'Normal']\n\nfig = px.bar(df_train)\nfig.show()\n\ncolumns = df_train.columns\nindex = df_train.index\n\nfig = go.Figure(data=[\n    go.Bar(name=index[0], x=columns, y=df_train.iloc[0]),\n    go.Bar(name=index[1], x=columns, y=df_train.iloc[1]),\n    go.Bar(name=index[2], x=columns, y=df_train.iloc[2])\n])\n# Change the bar mode\nfig.update_layout(barmode='group')\nfig.show()\n\ncolumns = df_train.columns\nindex = df_train.index\n\nfig = go.Figure(data=[\n    go.Bar(name=columns[0], x=index, y=df_train.iloc[:,0]),\n    go.Bar(name=columns[1], x=index, y=df_train.iloc[:,1]),\n    go.Bar(name=columns[2], x=index, y=df_train.iloc[:,2])\n])\n# Change the bar mode\nfig.update_layout(barmode='group')\nfig.show()","2cd069e1":"conv_base = VGG16(weights = 'imagenet',\n                 include_top = False,\n                 input_shape=(img_size, img_size, 3))","61f3a9ec":"conv_base.summary()","c2b55eed":"model = models.Sequential()\nmodel.add(conv_base)\nmodel.add(layers.Flatten())\nmodel.add(layers.Dense(256, activation='relu'))\nmodel.add(layers.Dropout(0.25))\nmodel.add(layers.Dense(256, activation='relu'))\nmodel.add(layers.Dropout(0.25))\nmodel.add(layers.Dense(3, activation='softmax'))\n\nmodel.summary()","0834165a":"len(model.trainable_weights)","447f3051":"conv_base.trainable = True\n\nset_traninable = False\nfor layer in conv_base.layers:\n    if layer.name == 'block5_conv1':\n        set_traninable = True\n    if set_traninable:\n        layer.traninable = True\n    else:\n        layer.trainable = False\n\nlen(model.trainable_weights)","efd3c19a":"datagen = ImageDataGenerator(rescale=1.\/224,\n                                  rotation_range=10,\n                                  width_shift_range=0.2,\n                                  shear_range=0.2,\n                                  zoom_range=0.2,\n                                  horizontal_flip=False,\n                                  fill_mode='nearest')\ndatagen.fit(x_train)","2b4053ad":"time_start = time.process_time()\n\nmodel.compile(loss='sparse_categorical_crossentropy',\n             optimizer='sgd',  #optimizers.RMSprop(lr=2e-5),\n             metrics=['acc'])\n\ncallbacks_list = [keras.callbacks.ReduceLROnPlateau(monitor='loss', factor=0.5, patience=3)]\n\nhistory = model.fit(datagen.flow(x_train,y_train, batch_size = 50),\n                    steps_per_epoch=100, \n                    epochs=16,\n                    validation_data=datagen.flow(x_val, y_val, batch_size = 40),\n                    validation_steps=1,\n                    callbacks=callbacks_list)\n\n\ntime_end = time.process_time()\nprint(f'\\n\\nIt took: {(time_end-time_start)\/60} min')\n\npx.line(history.history)","254a69b4":"px.line(history.history['acc'])","9d5319ca":"px.line(history.history['loss'])","2d10dfd6":"px.line(history.history['val_acc'])","226d1163":"val_loss, val_acc = model.evaluate(x_test, y_test)","9f7c4d91":"y_pred = model.predict(x_test)\ny_pred = np.argmax(y_pred,axis = 1)","e3752650":"print(classification_report(y_test, y_pred, target_names = labels))","3e6ba1a9":"cm = confusion_matrix(y_test, y_pred)\n\nfig = ff.create_annotated_heatmap(cm, x=labels, y=labels, colorscale='mint')\n\nfig.update_layout(title_text='<b>Confusion matrix<\/b>',\n                  xaxis = dict(title='Predicted value'),\n                  yaxis = dict(title='Real value')\n                 )\nfig['layout']['yaxis']['autorange'] = \"reversed\"\nfig.show()\n","e606de3b":"y_pred = y_pred.reshape(1,-1)[0]","5cff6bc3":"correct = np.nonzero(y_pred == y_test)[0]\nincorrect = np.nonzero(y_pred != y_test)[0]\nprint(f'Number of incorrect classified images: {len(incorrect)} ~ {round(len(incorrect)\/len(y_test)*100,1)}% \\nNumber of correct classified images: {len(correct)} ~ {round(len(correct)\/len(y_test)*100,1)}%')\n\ncorrect_normal = np.sum(np.logical_and(y_pred == 0, y_test == 0))\nincorrect_normal = np.sum(np.logical_and(y_pred == 0, y_test != 0))\ncorrect_viral = np.sum(np.logical_and(y_pred == 1, y_test == 1))\nincorrect_viral = np.sum(np.logical_and(y_pred == 1, y_test != 1))\ncorrect_bac = np.sum(np.logical_and(y_pred == 2, y_test == 2))\nincorrect_bac = np.sum(np.logical_and(y_pred == 2, y_test != 2))\n\nprint(f'\\nNumber of images correctly classified as normal: {correct_normal}')\nprint(f'Number of images incorrectly classified as normal: {incorrect_normal}')\nprint(f'Number of images correctly classified as viral: {correct_viral}')\nprint(f'Number of images incorrectly classified as viral: {incorrect_viral}')\nprint(f'Number of images correctly classified as bacterial: {correct_bac}')\nprint(f'Number of images incorrectly classified as bacterial: {incorrect_bac}')\n\n","a5eb56bf":"i=0\nfor c in incorrect:\n    print(y_pred[c])\n    print(y_test[c],'\\n')\n    i += 1\n    if i == 4:\n        break","95d3fd84":"i=0\n\nfor c in incorrect:\n    if y_pred[c] == 0: \n        predicted = 'Normal'\n    if y_pred[c] == 1: \n        predicted = 'Viral'\n    if y_pred[c] == 2: \n        predicted = 'Bacterial'    \n    if y_test[c] == 0: \n        GT = 'Normal'\n    if y_test[c] == 1: \n        GT = 'Viral'\n    if y_test[c] == 2: \n        GT = 'Bacterial'\n    fig = px.imshow(x_test[c][:][:][:], title=f'Groundtruth: {GT} <br>Predicted: {predicted}')\n    fig.show()\n    i += 1\n    if i == 2:\n        break","dca42864":"## Importing libraries","899b4177":"## Freezing\n\nIn order to take advantage of the VGG16 model, while still enabeling the model to adapt to the new data i want to keep most of the model as it is, and only letting the top layers adjust to the trainning data.\nThis is done by freezing all layers from bottom to \"block5_conv1\" (\"set_traninable\" as False) and activating layers above (\"set_traninable\" as True).","82ba04b1":"As a sanity check lets look at the predictions and ground truths. ","c16b8329":"# **Pneumonia, Viral vs. Bacterial**\n\nPneumonia is an inflammatory condition of the lung primarily affecting the small air sacs. Pneumonia is usually caused by infection with viruses or bacteria, and less commonly by other microorganisms. Identifying the responsible microorganism can target treatment and increase certainty of prognosis.\n\n![image.png](attachment:image.png)","ba06144f":"## Importing VGG16 model","87575364":"## Image Data Generator\nThe image data generator makes it easy to import the pictures from directories in batches and also to do image augmentation. Since x-rays are produced in a uniform format rotation_range are set to 10 and horizontal_flip is set to False.","ea6b269f":"## Finding pictures","65d20e0f":"## Adding top layers","03862274":"# Credits\n\n- https:\/\/plotly.com\/python\/\n- https:\/\/www.kaggle.com\/kashyapgohil\/pneumonia-detection-using-cnn\n- https:\/\/keras.io\/api\/\n- https:\/\/stackoverflow.com\/questions\/60860121\/plotly-how-to-make-an-annotated-confusion-matrix-using-a-heatmap\n- https:\/\/www.kaggle.com\/kashyapgohil\/pneumonia-detection-using-cnn\n- Image from https:\/\/pixabay.com\/da\/images\/search\/lunge\/\n- Deep Learning with Python by Fran\u00e7ois Chollet\n"}}