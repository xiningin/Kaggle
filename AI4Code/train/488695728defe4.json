{"cell_type":{"fb8e168c":"code","789b26c3":"code","7fa3633e":"code","c5fc5faf":"code","cfb56f47":"markdown"},"source":{"fb8e168c":"import psutil\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\nimport time\nimport multiprocessing\nfrom IPython.display import clear_output\nfrom collections import deque","789b26c3":"class SystemMonitorProcess:\n    def __init__(self, start_timestamp, update_interval=0.1):\n        self.update_interval = update_interval\n        self.cpu_nums = psutil.cpu_count()\n        self.max_mem = psutil.virtual_memory().total\n        self.sysCpuLogs = deque()\n        self.sysMemLogs = deque()\n        self.timeLogs = deque()\n        self.start_time = start_timestamp\n\n    def get_system_info(self):\n        cpu_percent = psutil.cpu_percent(interval=0.0, percpu=False)\n        mem_percent = float(psutil.virtual_memory().used) \/ self.max_mem * 100\n        return cpu_percent, mem_percent\n        \n    def monitor(self):\n        while True:\n            time.sleep(self.update_interval)\n            sCpu, sMem = self.get_system_info()  \n            self.sysCpuLogs.append(sCpu)\n            self.sysMemLogs.append(sMem)\n            self.timeLogs.append(time.time() - self.start_time)\n            logs.update({\n                'sysCpuLogs': self.sysCpuLogs,\n                'sysMemLogs': self.sysMemLogs,\n                'time': self.timeLogs\n            })","7fa3633e":"class SystemMonitor:\n    def __init__(self, update_interval=0.1):\n        self.graph = None\n        self.update_interval = update_interval\n        self.start_timestamp = time.time()\n        self.msgs = []\n    \n    def monitor(self):\n        self.graph = SystemMonitorProcess(self.start_timestamp, self.update_interval)\n        self.graph.monitor()\n        \n    def annotate(self, msg):\n        self.msgs.append([time.time() - self.start_timestamp, msg])\n        \n    def plot(self):\n        if not 'sysCpuLogs' in logs:\n            print('No data yet.')\n            return\n\n        fig = plt.figure(figsize=(20,3))\n        plt.ylabel('usage (%)')\n        \n        # FIXME display running time on primary X axis!\n        ax = plt.axes()\n        #plt.xlabel('running time (s)')\n        \n        ax2 = ax.twiny()\n        ax2.plot(list(logs['time']), logs['sysCpuLogs'], label=\"cpu\")\n        ax2.plot(list(logs['time']), logs['sysMemLogs'], label=\"mem\")\n        ax2.set_xticks([msg[0] for msg in self.msgs])\n        ax2.set_xticklabels([msg[1] for msg in self.msgs], rotation=90)\n\n        ax2.legend(loc='best')\n        plt.show()","c5fc5faf":"# example usage:\nsm = SystemMonitor(0.1) # polling frequency\nlogs = multiprocessing.Manager().dict()\nsmp = multiprocessing.Process(target=sm.monitor)\nsmp.start()\n\n### YOUR ACTUAL CODE GOES HERE: ###\nfor i in range(5):\n    sm.annotate('step '+str(i))\n    clear_output()\n    sm.plot()\n    time.sleep(1.0)\n### END OF YOUR CODE ###\n\nprint('Final plot:')\nsm.plot() # shows plot\nsmp.terminate() # kills the system monitor","cfb56f47":"# Monitoring System Usage\nWith Kernel-only competitions we really have to use the allocated resources as fully as possible. But it's sometimes difficult to judge how much resources are available, and when! This kernel monitors system usage to make it easier to optimize things:\n\n<center><img src=\"https:\/\/i.imgur.com\/LuddNgv.png\" width=\"\"\/><\/center>"}}