{"cell_type":{"d5096249":"code","cdf48b12":"code","45b08edd":"code","d939cc61":"code","fab679ed":"code","06fad5b6":"code","b3c21969":"code","615979b0":"code","5a9eca47":"code","383b2e18":"code","4376fb6c":"code","242e905b":"code","2a7373cf":"code","4dacede8":"code","c3562e63":"code","f7ef8f7f":"code","efc007dd":"code","a5a3d853":"code","f61ad2b0":"code","d57000e4":"markdown","ce37ec1d":"markdown","a029d7bd":"markdown","9e711da5":"markdown"},"source":{"d5096249":"import numpy as np\nimport pandas as pd\nfrom math import sqrt\nfrom pylab import rcParams\nimport pandas.testing as tm\nimport statsmodels.api as sm\nfrom matplotlib import pyplot\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import mean_squared_error\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nimport statsmodels.api as sm\nimport warnings\nwarnings.filterwarnings('ignore')","cdf48b12":"train = pd.read_csv('..\/input\/daily-climate-time-series-data\/DailyDelhiClimateTrain.csv', header=0, index_col=0, \n                    parse_dates=True, squeeze=True)\ntest = pd.read_csv('..\/input\/daily-climate-time-series-data\/DailyDelhiClimateTest.csv', header=0, index_col=0, \n                   parse_dates=True, squeeze=True)","45b08edd":"train = train['meantemp']\ntest = test['meantemp']","d939cc61":"train['2014':'2015'].plot()\nplt.title('Atributos do clima de 2014 a 2015')\nplt.show()","fab679ed":"train.asfreq('M').plot() # asfreq method is used to convert a time series to a specified frequency. Here it is monthly frequency.\nplt.title('Umidade ao longo do tempo (frequ\u00eancia mensal)')\nplt.show()","06fad5b6":"plot_pacf(train,lags=25,title='Temperatura M\u00e9dia')\nplt.show()","b3c21969":"rcParams['figure.figsize'] = 11, 9\ndecomposed_meantemp_volume = sm.tsa.seasonal_decompose(train,period=360) # The frequncy is annual\nfigure = decomposed_meantemp_volume.plot()\nplt.show()","615979b0":"train.loc[['2016-02-29']]","5a9eca47":"train = train[~((train.index.month == 2) & (train.index.day == 29))]\ntrain","383b2e18":"train = train[~((train.index.year == 2017))]\ntrain","4376fb6c":"grupos = train.groupby(pd.Grouper(freq='A'))\nanos_meantemp = pd.DataFrame() \nfor nome, grupo in grupos:\n    anos_meantemp[nome.year] = grupo.values","242e905b":"anos_meantemp.plot(figsize=(10,5)\n          ,subplots=True\n          ,title='Temperatura por m\u00e9dia')","2a7373cf":"fig, axes = plt.subplots(1,2, figsize=(30,10))\ntrain.hist(ax=axes[0])\nanos_meantemp.boxplot(ax=axes[1])\n\nplt.show()","4dacede8":"history = [x for x in train]\n\npredictions = list()\n\nfor i in range(len(test)):\n    \n    valor_predito = history[-1]\n    predictions.append(valor_predito)\n  \n    valor_real = test[i]\n    history.append(valor_real)\n  \n    print(i,'- Valor Predito=%.3f, Valor Esperado=%3.f' % (valor_predito, valor_real))","c3562e63":"mse = sqrt(mean_squared_error(test, predictions))\nprint('RMSE: %.3f' % rmse)","f7ef8f7f":"pyplot.plot(test.values)\npyplot.plot(predictions, color='red')\npyplot.show()","efc007dd":"import warnings\nwarnings.filterwarnings('ignore')\n# cria a vari\u00e1vel history\nhistory = [x for x in train]\n# cria lista de previs\u00f5es\npredictions = list()\n\n# inicia Walk-Forward\nfor t in range(len(test)):\n    # difference data\n    meses_no_ano = 12\n\n  # cria um modelo SARIMA com os dados de history\n  # desliga a diferencia\u00e7\u00e3o do modelo ARIMA\n    model = sm.tsa.statespace.SARIMAX(history, order=(1,0,1), \n                                    seasonal_order=(1,1,1, meses_no_ano))\n  \n  # treina o modelo SARIMAX\n    model_fit = model.fit(trend='nc', disp=0)\n\n  # a vari\u00e1vel valor_predito recebe o valor previsto pelo modelo\n    valor_predito = model_fit.forecast()[0]\n\n    predictions.append(valor_predito)\n         \n  # a vari\u00e1vel valor_real recebe o valor real do teste\n    valor_real = test[t]\n  \n  # adiciona o valor real a vari\u00e1vel history\n    history.append(valor_real)\n\n  # imprime valor predito e valor real\n    print('Valor predito=%.3f, Valor esperado=%3.f' % (valor_predito, valor_real))","a5a3d853":"rmse = sqrt(mean_squared_error(test, predictions))\nprint('Test RMSE: %.3f' % rmse)","f61ad2b0":"pyplot.plot(test.values)\npyplot.plot(predictions, color='red')\npyplot.show()","d57000e4":"Conclus\u00e3o e considera\u00e7\u00f5es:\nPara o problema abordado foi utilizado o m\u00e9todo SARIMA, pois os atributos de umidade e temperatura m\u00e9dia possui sazonalidade. A meantemp diminui no final de cada ano e atinge o m\u00e1ximo na metade do ano, acompanhando as esta\u00e7\u00f5es do ano e ap\u00f3s isto, segue um padr\u00e3o repetido para s\u00e9ries temporais inteiras. O metodo ARIMA n\u00e3o foi escolhido, pois  ele n\u00e3o suporta dados sazonais e essa \u00e9 uma s\u00e9rie temporal com um ciclo repetitivo. \n\nNa verifica\u00e7\u00e3o de Estacionaridade com a decomposi\u00e7\u00e3o sazonal, a umidade e a temperatura m\u00e9dia n\u00e3o s\u00e3o estacion\u00e1rios. \u00c0 primeira vista, vemos claramente que as distribui\u00e7\u00f5es de umidade s\u00e3o diferentes e a press\u00e3o m\u00e9dia \u00e9 quase constante,mas de acordo com o gr\u00e1fico n\u00e3o \u00e9 estacion\u00e1ria, pois os valores n\u00e3o s\u00e3o constantes ao longo do tempo. \n\nNo gr\u00e1fico acima, podemos ver que os valores previstos se parecem muito com os valores reais. O valor RMSE obtido neste modelo \u00e9 1,68. Isso mostra que nosso modelo SARIMA pode ser usado para prever valores de temperatura futuros.\n\n\n\n\n\n\n\n\n","ce37ec1d":"# Removendo o dia 29\/02\/2016","a029d7bd":"#Models","9e711da5":"#Sarima"}}