{"cell_type":{"caab75c9":"code","bea8a3b2":"code","34d317ab":"code","1b76f9c2":"code","4ffcdd9a":"code","315844a2":"code","17c4e2e7":"code","71258391":"code","4323b40a":"code","a4d98272":"code","7bb7b1cf":"code","c9388b20":"code","ae9c9666":"code","84afe76d":"code","d275ddc2":"code","74bd9303":"markdown","c53cda67":"markdown","3e13a918":"markdown","91153acc":"markdown","7e0a0faa":"markdown","861533bf":"markdown","14910046":"markdown","ec469e24":"markdown"},"source":{"caab75c9":"# The problem we will solve is to convert from Celsius to Fahrenheit\n# where the approximate formula is: f=c\u00d71.8+32 \n\n# Of course, it would be simple enough to create a conventional Python function \n# But that wouldn't be machine learning.\n\n# Instead, we will give TensorFlow some sample Celsius values (0, 8, 15, 22, 38) and \n# their corresponding Fahrenheit values (32, 46, 59, 72, 100). \n# Then, we will train a model that figures out the above formula through the training process.","bea8a3b2":"import tensorflow as tf\nimport numpy as np\nimport matplotlib.pyplot as plt","34d317ab":"c = np.array([-40, -10,  0,  8, 15, 22,  38],  dtype=float)\nf = np.array([-40,  14, 32, 46, 59, 72, 100],  dtype=float)","1b76f9c2":"# Feature \u2014 The input(s) to our model. \n#           In this case, a single value \u2014 the degrees in Celsius.\n# Labels \u2014  The output our model predicts. \n#           In this case, a single value \u2014 the degrees in Fahrenheit.\n# Example \u2014 A pair of inputs\/outputs used during training. \n#           In our case a pair of values from celsius_q and fahrenheit_a at a specific index, such as (22,72).","4ffcdd9a":"# Since the problem is straightforward, \n# this network will require only a single layer, \n# with a single neuron.","315844a2":"model = tf.keras.Sequential([\n  tf.keras.layers.Dense(units=1, input_shape=[1])\n])","17c4e2e7":"# model definition takes a list of layers as argument, \n# specifying the calculation order from the input to the output.\n\n# input_shape=[1] \u2014 This specifies that the input to this layer is a single value. \n#                   That is, the shape is a one-dimensional array with one member. \n\n# units=1 \u2014 This specifies the number of neurons in the layer. \n#           The number of neurons defines how many internal variables the layer has to try to learn how to solve the problem. ","71258391":"model.compile(loss='mean_squared_error',\n              optimizer=tf.keras.optimizers.Adam(0.1), metrics=['mean_squared_error'])","4323b40a":"# Loss function \u2014 A way of measuring how far off predictions are from the desired outcome. \n#                 (The measured difference is called the \"loss\".)\n\n# Optimizer function \u2014 A way of adjusting internal values in order to reduce the loss.","a4d98272":"history = model.fit(c, f, epochs=500, verbose=False)\nprint(\"Finished training the model\")","7bb7b1cf":"history.params","c9388b20":"plt.xlabel('Epoch Number')\nplt.ylabel(\"Loss Magnitude\")\nplt.plot(history.history['loss'])\nplt.show()","ae9c9666":"print(model.predict([100.0]))","84afe76d":"# f = c\u00d71.8+32 \n\nf_by_hand = (100*1.8)+32\nprint(f_by_hand) ","d275ddc2":"l0 = tf.keras.layers.Dense(units=4, input_shape=[1])\nl1 = tf.keras.layers.Dense(units=4)\nl2 = tf.keras.layers.Dense(units=1)\n\nmodel = tf.keras.Sequential([l0, l1, l2])\n\nmodel.compile(loss='mean_squared_error', optimizer=tf.keras.optimizers.Adam(0.1), metrics=['mean_squared_error'])\n\nhistory = model.fit(c, f, epochs=100, verbose=False)\nprint(\"Finished training the model\")\n\nprint(model.predict([100.0]))\n\nplt.xlabel('Epoch Number')\nplt.ylabel(\"Loss Magnitude\")\nplt.plot(history.history['loss'])","74bd9303":"# Improving model using CNN","c53cda67":"# Training Data","3e13a918":"# Creating a model","91153acc":"# Predict Values","7e0a0faa":"# Compile, loss, optimizer","861533bf":"# Train the model","14910046":"# Importing Libraries","ec469e24":"# Training Statistics"}}