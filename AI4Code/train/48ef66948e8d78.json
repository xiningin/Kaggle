{"cell_type":{"4a0f69a7":"code","d7f9a540":"code","e57f66f8":"code","9cb43334":"code","2e8ab15e":"code","115e5199":"code","f1c67701":"code","b59834a4":"code","f8ce1613":"code","3462d922":"code","57b77ddf":"code","07366914":"code","f5f1d290":"code","b6ef63e4":"code","83cb53d7":"code","c88b3b9a":"code","e9922f57":"code","d7ff4fff":"code","fa64884b":"code","04d1c4d9":"code","3041e495":"code","07cd1758":"code","4b3a022f":"code","a823a04e":"code","8c9123ea":"code","d19e8a3b":"code","70ea6bd3":"code","3e16e0a1":"code","287d815d":"code","10a05edf":"markdown","f6cceefc":"markdown","37329f2c":"markdown","d27d11ba":"markdown","b50d861a":"markdown","8c192733":"markdown","85b32233":"markdown","d26449c4":"markdown","9de7484f":"markdown","a57d38d1":"markdown","f98e4b82":"markdown","f83e3696":"markdown","9a1d2730":"markdown","5559762d":"markdown","90f844f8":"markdown","3ca2b77f":"markdown","cdc146cc":"markdown","e90c38eb":"markdown"},"source":{"4a0f69a7":"import numpy as np\nimport pandas as pd\nfrom pathlib import Path\nfrom tqdm import tqdm\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\n","d7f9a540":"trainfile = pd.read_csv(\"..\/input\/google-smartphone-decimeter-challenge\/baseline_locations_train.csv\")\ntestfile = pd.read_csv(\"..\/input\/google-smartphone-decimeter-challenge\/baseline_locations_test.csv\")\nsubmission = pd.read_csv(\"..\/input\/google-smartphone-decimeter-challenge\/sample_submission.csv\")","e57f66f8":"trainfile","9cb43334":"datapath = Path(\"..\/input\/google-smartphone-decimeter-challenge\")\ntruths = (datapath \/ 'train').rglob('ground_truth.csv')\n\n\ncols = ['collectionName', 'phoneName', 'millisSinceGpsEpoch','phone','heightAboveWgs84EllipsoidM','latDeg',\n       'lngDeg',]\ntruth_list =[]\nfor filepath in tqdm(truths, total=73):\n    file = pd.read_csv(filepath, usecols=cols)\n    truth_list.append(file)\n    \ntruth_data = pd.concat(truth_list, ignore_index=True)\n\ntrain = trainfile[cols]\n\ntrain = train.merge(truth_data.iloc[:,3:], suffixes=(\"_current\",\"_truth\",\"_truth\"))","2e8ab15e":"train","115e5199":"train.info()","f1c67701":"train.iloc[:,3:].corr()","b59834a4":"test = testfile.copy()\n\nprint(\"############### collectionName unique values ##############################\")\nprint(\"train: {}\".format(train.collectionName.nunique()))\nprint(train.collectionName.unique())\nprint(\"----------------------------------------------\")\nprint(\"test: {}\".format(test.collectionName.nunique()))\nprint(test.collectionName.unique())\nprint(\"----------------------------------------------\")\n\nprint(\"\\n\")\n\nprint(\"############### phoneName unique values ##############################\")\nprint(\"train: {}\".format(train.phoneName.nunique()))\nprint(train.phoneName.unique())\nprint(\"----------------------------------------------\")\nprint(\"test: {}\".format(test.phoneName.nunique()))\nprint(test.phoneName.unique())\nprint(\"----------------------------------------------\")","f8ce1613":"train_phone = pd.get_dummies(train.loc[:,\"phoneName\"])\ntest_phone = pd.get_dummies(test.loc[:,\"phoneName\"])\n\nprint(\"train_phone shape:{}\".format(train_phone.shape))\nprint(\"test_phone shape:{}\".format(test_phone.shape))","3462d922":"train_phone1, test_phone1 = train_phone.align(test_phone, join=\"outer\",axis=1, fill_value=0)\nprint(\"Updated train shape {}\".format(train_phone.shape))\n\nprint(\"Updated test shape {}\".format(test_phone.shape))","57b77ddf":"train1 = pd.concat([train.iloc[:,3:], train_phone1], axis=1, ignore_index=False)\ntest1 = pd.concat([test.iloc[:,3:5], test_phone1], axis=1, ignore_index=False)","07366914":"print(\"train1_shape:\",train1.shape)\ntrain1.columns","f5f1d290":"print(\"test1-shape:\",test1.shape)\ntest1.columns","b6ef63e4":"plt.figure(figsize=[10,5])\nplt.plot(train1[\"latDeg_current\"][:200],train1[\"lngDeg_current\"][:200],\"bo\",label=\"current\")\nplt.plot(train1[\"latDeg_truth\"][:200],train1[\"lngDeg_truth\"][:200],\"r*\",label=\"truth\")\nplt.title(\"current vs truth\", fontweight=\"bold\")\nplt.xlabel(\"latDeg\")\nplt.ylabel(\"lngDeg\")\nplt.legend()\n\nplt.figure(figsize=[15,5])\nplt.subplot(1,2,1)\nplt.plot(train1[\"latDeg_current\"][:200],train1[\"latDeg_truth\"][:200],\"bo\")\nplt.title(\"lat (current vs truth)\", fontweight=\"bold\")\n\nplt.subplot(1,2,2)\nplt.plot(train1[\"lngDeg_current\"][:200],train1[\"lngDeg_truth\"][:200],\"bo\")\nplt.title(\"lng (current vs truth)\", fontweight=\"bold\")","83cb53d7":"# for lat\ncolumns1 = list(train1.columns[4:])\nX1,y1 = train1.loc[:,[train1.columns[0]]+columns1],train1[\"latDeg_truth\"].values\n  \n#for lng\ncolumns2 = list(train1.columns[4:])\nX2,y2 = train1.loc[:,[train1.columns[1]]+columns2],train1[\"lngDeg_truth\"].values\n\n\nXt1 = test1.loc[:,[test1.columns[0]]+columns1] #for lat\nXt2 = test1.loc[:,[test1.columns[1]]+columns2] #for lng\n\nprint(\"X1 columns:\", X1.columns.tolist())\nprint(\"Xt1 columns:\", Xt1.columns.tolist())\nprint(\"\\n\")\nprint(\"X2 columns:\", X2.columns.tolist())\nprint(\"Xt2 columns:\", Xt2.columns.tolist())","c88b3b9a":"xtr1,xval1,ytr1,yval1 = train_test_split(X1, y1, test_size=0.3, random_state=10)\nxtr2,xval2,ytr2,yval2 = train_test_split(X2, y2, test_size=0.3, random_state=10)\n\nprint(\"xtr1 shape:{}; xval1 shape:{}\".format(xtr1.shape,xval1.shape))\nprint(\"xtr2 shape:{}; xval2 shape:{}\".format(xtr2.shape,xval2.shape))","e9922f57":"from math import radians, cos, sin, asin, sqrt\ndef lat_lon_dist(df):\n    \"\"\"\n    Calculate the great circle distance between two points \n    on the earth (specified in decimal degrees)\n    \"\"\"\n    dist_list = []\n    for i in tqdm(range(df.shape[0]),total=100):\n        lat1 = df[\"latDeg_truth\"][i]\n        lon1 = df[\"lngDeg_truth\"][i]\n        lat2 = df[\"latDeg_pred\"][i]\n        lon2 = df[\"lngDeg_pred\"][i]\n        # convert decimal degrees to radians \n        lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])\n        # haversine formula \n        dlon = lon2 - lon1 \n        dlat = lat2 - lat1 \n        a = sin(dlat\/2)**2 + cos(lat1) * cos(lat2) * sin(dlon\/2)**2\n        c = 2 * asin(sqrt(a)) \n        # Radius of earth in kilometers is 6371\n        mdist = 6371* c*1000\n        dist_list.append(mdist)\n    \n    return dist_list","d7ff4fff":"idx_Mi8=np.where(xtr1[\"Mi8\"]==1)[0]\nidx_Pixel4=np.where(xtr1[\"Pixel4\"]==1)[0]\nidx_Pixel4Modded=np.where(xtr1[\"Pixel4Modded\"]==1)[0]\nidx_Pixel4XL=np.where(xtr1[\"Pixel4XL\"]==1)[0]\nidx_Pixel4XLModded=np.where(xtr1[\"Pixel4XLModded\"]==1)[0]\nidx_Pixel5=np.where(xtr1[\"Pixel5\"]==1)[0]\nidx_SamsungS20Ultra=np.where(xtr1[\"SamsungS20Ultra\"]==1)[0]","fa64884b":"xtr1","04d1c4d9":"#lr1 = LinearRegression() #selected as a starting point\n#model_lat = lr1.fit(xtr1.to_numpy()[idx_Mi8,0].reshape(-1,1),ytr1)\n#pred_yval1 = model_lat.predict(xval1) # prediction for val data (lat)\n#lr2 = LinearRegression()\n#model_lng = lr2.fit(xtr2,ytr2)\n#pred_yval2 = model_lng.predict(xval2) # prediction for val data (long)\n\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF, ConstantKernel as C\n\n# Instantiate a Gaussian Process model\ngp1_Mi8 = GaussianProcessRegressor()\ngp1_Mi8.fit(xtr1.to_numpy()[idx_Mi8,0].reshape(-1,1),np.array(ytr1[idx_Mi8].ravel()).reshape(-1,1))\n\n\n\n","3041e495":"val_df = pd.concat([xval1[[\"latDeg_current\"]], xval2], ignore_index=False, axis=1).reset_index(drop=[\"index\"])","07cd1758":"#truth\nval_df[\"latDeg_truth\"] = yval1\nval_df[\"lngDeg_truth\"] = yval2\n\n#pred\nval_df[\"latDeg_pred\"] = pred_yval1\nval_df[\"lngDeg_pred\"] = pred_yval2","4b3a022f":"val_df[\"dist\"] = lat_lon_dist(val_df)","a823a04e":"phone = val_df.iloc[:,2:-5].idxmax(axis=1) #Reversing one-hot decoding for phoneName\n\nval_df1 = pd.concat([val_df.iloc[:,:2],val_df.iloc[:,-3:]], axis=1, ignore_index=False)\nval_df1[\"phoneName\"] = phone\n\nval_df1 = val_df1[val_df1.columns[-1:].tolist()+val_df1.columns[:-1].tolist()]","8c9123ea":"import seaborn as sns\nplt.figure(figsize=[15,7])\n\n# ax, fig = plt.subplots(figsize=[15,7])\nsns.boxplot(x=\"phoneName\", y=\"dist\",data=val_df1)\nplt.ylabel(\"Dist (m)\") # distance in meters\n#plt.ylim([0,30]) # for better visualization","d19e8a3b":"val_df2 = pd.DataFrame()\nval_df2[\"phoneName\"] =  val_df1.phoneName.unique().tolist()\nval_df2[\"dist_50\"] = [np.percentile(val_df1[val_df1.phoneName==ph][\"dist\"],50) for ph in val_df2[\"phoneName\"].tolist()]\nval_df2[\"dist_95\"] = [np.percentile(val_df1[val_df1.phoneName==ph][\"dist\"],95) for ph in val_df2[\"phoneName\"].tolist()]\nval_df2[\"avg_dist_50_95\"] = np.mean(np.array(val_df2.iloc[:,1:]),axis=1)\nprint(\"Val evaluation details:\\n\",val_df2)\n\nprint(\"\\n\")\nprint(\"------------------------------------------------------\")\nprint(\"Final val evaluation score: {}\".format(val_df2.iloc[:,-1].mean()))\nprint(\"------------------------------------------------------\")","70ea6bd3":"lr1 = LinearRegression()\nmodel_lat = lr1.fit(X1,y1)\npred_yt1 = model_lat.predict(Xt1) # prediction for test data (lat)\n\nlr2 = LinearRegression()\nmodel_lng = lr2.fit(X2,y2)\npred_yt2 = model_lng.predict(Xt2) # prediction for test data (long)","3e16e0a1":"submission = test[['phone','millisSinceGpsEpoch']]\npd.options.mode.chained_assignment = None  # default='warn'\nsubmission['latDeg'] = pred_yt1.tolist()\nsubmission['lngDeg'] = pred_yt2.tolist()","287d815d":"submission.to_csv(\".\/submission.csv\",index=False)","10a05edf":"**Model building**","f6cceefc":"**Plotting current vs truth coordinates**","37329f2c":"**Input-output**","d27d11ba":"**Aligning train & test columns**","b50d861a":"**Model evaluation on validation data**","8c192733":"* In above correlation table, we can see that ***latDeg_current is highly correlated with latDeg_truth*** and ***lngDeg_current is highly correlated with lngDeg_truth***\n* That would help us to build a baseline model","85b32233":"**Adding truth & predicted lat-long values to val_df**","d26449c4":"**Note:** Here, collectionName would be useless to consider as it would be different in train and test data but **phoneName** might be helpful","9de7484f":"**Training the model on complete data and predict for test data**","a57d38d1":"**Defining a function to get prediction and ground truth distance estimation (in meters)**\n\n[Haversine formula for distance estimation using GPS co-ordinates](https:\/\/stackoverflow.com\/questions\/15736995\/how-can-i-quickly-estimate-the-distance-between-two-latitude-longitude-points)","f98e4b82":"**Box-plot analysis for dist  analysis for each phone**","f83e3696":"**Loading train, test & submission files**","9a1d2730":"**Train-test data after addition of one-hot encoded columns**","5559762d":"**One-hot encoding for 'phoneName' of train and test data**","90f844f8":"**Checking the correlation between current & truth coordinates**","3ca2b77f":"**Preparing evaluation score for each phone (50th & 95th percentile)**","cdc146cc":"* Basically, there is no change is one-hot encoded phoneName columns for train or test data","e90c38eb":"**Extracting ground truths and aligning with train inputs**"}}