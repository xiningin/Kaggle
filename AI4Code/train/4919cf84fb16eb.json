{"cell_type":{"73fb0d05":"code","842e2c92":"code","9811b3a6":"code","0de6ed3c":"code","b466887d":"code","2752c0aa":"code","8959c10b":"code","b3162d65":"code","51d60b82":"code","3b7dc350":"code","6ff3a097":"code","a354ce1e":"code","c72c25a1":"code","1c0a8a0f":"code","a7e2776a":"code","274d498f":"code","c1cd3453":"code","ade2d35b":"code","fd9c956e":"code","88203227":"code","baf51e39":"markdown","93dcc57d":"markdown","60bb1b49":"markdown","bafa88bc":"markdown","c513efe8":"markdown","cd6a70e6":"markdown","bc0ddf25":"markdown","4c0589fb":"markdown","7c6737e0":"markdown","6d9fc3d0":"markdown","080768b7":"markdown","c458731c":"markdown","04f51d7a":"markdown","8c0537c8":"markdown","b9c83c54":"markdown","36169568":"markdown","67622741":"markdown","b8776a99":"markdown"},"source":{"73fb0d05":"#[1]\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","842e2c92":"#[2]\n# save filepath to variable for easier access\nmelbourne_file_path = '..\/input\/melbourne-housing-snapshot\/melb_data.csv'\n# read the data and store data in DataFrame titled melbourne_data\nmelbourne_data = pd.read_csv(melbourne_file_path) \n\nmelbourne_data.head()\n# print a summary of the data in Melbourne data\n#melbourne_data.describe()","9811b3a6":"#[3]\nmelbourne_data.shape","0de6ed3c":"#[4]\nmelbourne_data.columns","b466887d":"#[5]\n# The Melbourne data has some missing values (some houses for which some variables weren't recorded.)\n# We will take the simplest option for now, and drop houses from our data. \n\n# dropna drops missing values \nmelbourne_data = melbourne_data.dropna(axis=0)","2752c0aa":"#[6]\ny = melbourne_data.Price","8959c10b":"#[7]\nmelbourne_features = ['Rooms', 'Bathroom', 'Landsize', 'Lattitude', 'Longtitude']\nX = melbourne_data[melbourne_features]\nX.head()","b3162d65":"#[8]\nfrom sklearn.tree import DecisionTreeRegressor\n\n# Define model. Specify a number for random_state to ensure same results each run\nmelbourne_model = DecisionTreeRegressor(random_state=1)\n\n# Fit model\nmelbourne_model.fit(X, y)","51d60b82":"#[9]\nprint(\"Making predictions for the following 5 houses:\")\nprint(X.head())\nprint(\"The predictions are\")\nprint(melbourne_model.predict(X.head()))","3b7dc350":"#[10]\nfrom sklearn.metrics import mean_absolute_error\n\npredicted_home_prices = melbourne_model.predict(X)\nmean_absolute_error(y, predicted_home_prices)","6ff3a097":"#[11]\nfrom sklearn.model_selection import train_test_split\n\n# split data into training and validation data, for both features and target\n# The split is based on a random number generator. Supplying a numeric value to\n# the random_state argument guarantees we get the same split every time we\n# run this script.\ntrain_X, val_X, train_y, val_y = train_test_split(X, y, random_state = 0)\n\n","a354ce1e":"#[12]\ntrain_y.shape","c72c25a1":"#[13]\nval_y.shape","1c0a8a0f":"#[14]\n# Define model\nmelbourne_model = DecisionTreeRegressor()\n\n# Fit model\nmelbourne_model.fit(train_X, train_y)","a7e2776a":"#[15]\n# get predicted prices on validation data\nval_predictions = melbourne_model.predict(val_X)\nprint(mean_absolute_error(val_y, val_predictions))","274d498f":"#[16]\ndef get_mae(max_leaf_nodes, train_X, val_X, train_y, val_y):\n    model = DecisionTreeRegressor(max_leaf_nodes=max_leaf_nodes, random_state=0)\n    model.fit(train_X, train_y)\n    preds_val = model.predict(val_X)\n    mae = mean_absolute_error(val_y, preds_val)\n    return(mae)","c1cd3453":"#[17]\n# compare MAE with differing values of max_leaf_nodes\nfor max_leaf_nodes in [5, 50, 500, 5000]:\n    my_mae = get_mae(max_leaf_nodes, train_X, val_X, train_y, val_y)\n    print(\"Max leaf nodes: %d  \\t\\t Mean Absolute Error:  %d\" %(max_leaf_nodes, my_mae))","ade2d35b":"#[18]\n# Let's run the optimal model with 500 notes\nmelbourne_model = DecisionTreeRegressor(max_leaf_nodes=500, random_state=0)\nmelbourne_model.fit(train_X, train_y)\n    \n","fd9c956e":"#[19]\n# Can we get a visual?\nimport graphviz \n\ndot_data = tree.export_graphviz(melbourne_model, out_file=None,\n                               feature_names=melbourne_features) \ngraph = graphviz.Source(dot_data)\ngraph.render(\"DecisionTree\")","88203227":"#[20]\nfrom sklearn.ensemble import RandomForestRegressor\n\nforest_model = RandomForestRegressor(random_state=1)\nforest_model.fit(train_X, train_y)\nmelb_preds = forest_model.predict(val_X)\nprint(mean_absolute_error(val_y, melb_preds))","baf51e39":"# Intro to Machine Learning\nThis is condensed from [Intro to Machine Learning Kaggle course](https:\/\/www.kaggle.com\/learn\/intro-to-machine-learning)\n- Build a model\n- Validate a model\n- Overfitting and underfitting\n- A more sophisticated model: Random forests","93dcc57d":"Here's the takeaway: Models can suffer from either:\n- **Overfitting:** capturing spurious patterns that won't recur in the future, leading to less accurate predictions, or \n- **Underfitting:** failing to capture relevant patterns, again leading to less accurate predictions. \n\nWe use **validation** data, which isn't used in model training, to measure a candidate model's accuracy. This lets us try many candidate models and keep the best one. ","60bb1b49":"### The Problem with \"In-Sample\" Scores\n\nThe measure we just computed can be called an \"in-sample\" score. We used a single \"sample\" of houses for both building the model and evaluating it. This is bad.  If our model doesn't hold when it sees new data, the model would be very inaccurate when used in practice.\n\nSince models' practical value come from making predictions on new data, we measure performance on data that wasn't used to build the model. The most straightforward way to do this is to exclude some data from the model-building process, and then use those to test the model's accuracy on data it hasn't seen before. This data is called **validation data**.\n\n### Coding It\nThe scikit-learn library has a function `train_test_split` to break up the data into two pieces. We'll use some of that data as training data to fit the model, and we'll use the other data as validation data to calculate `mean_absolute_error`.\n\nHere is the code:","bafa88bc":"You've built a model. But how good is it?\n\n## Model Validation\n\nIn most applications, the relevant measure of model quality is predictive accuracy. There are many metrics for summarizing model quality, but we'll start with one called **Mean Absolute Error** \n\nHere is how we calculate the mean absolute error:","c513efe8":"# Conclusion \nThere is likely room for further improvement, but this is a big improvement over the best decision tree error of 250,000. There are parameters which allow you to change the performance of the Random Forest much as we changed the maximum depth of the single decision tree. But one of the best features of Random Forest models is that they generally work reasonably even without this tuning.\n\n# Your Turn \n- Try **[Using a Random Forest model](https:\/\/www.kaggle.com\/kernels\/fork\/1259186)** yourself and see how much it improves your model.\n- Visit [https:\/\/www.kaggle.com\/learn](https:\/\/www.kaggle.com\/learn) for **Intermediate ML** and **Intro to Deep Learning** courses.","cd6a70e6":"We can use a for-loop to compare the accuracy of models built with different values for *max_leaf_nodes.*","bc0ddf25":"--- \n# [Random Forests](https:\/\/scikit-learn.org\/stable\/modules\/ensemble.html#forest)\n\nDecision trees leave you with a difficult decision. A deep tree with lots of leaves will overfit because each prediction is coming from historical data from only the few houses at its leaf. But a shallow tree with few leaves will perform poorly because it fails to capture as many distinctions in the raw data.\n\nEven today's most sophisticated modeling techniques face this tension between underfitting and overfitting. But, many models have clever ideas that can lead to better performance. We'll look at the [**random forest**](https:\/\/scikit-learn.org\/stable\/modules\/ensemble.html#forest) as an example.\n\nThe random forest uses many trees, and it makes a prediction by averaging the predictions of each component tree. It generally has much better predictive accuracy than a single decision tree and it works well with default parameters. If you keep modeling, you can learn more models with even better performance, but many of those are sensitive to getting the right parameters. \n\nA random forest is a meta estimator that fits a number of decision tree classifiers on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting. The sub-sample size is controlled with the max_samples parameter if bootstrap=True (default), otherwise the whole dataset is used to build each tree.\n\n\nWe build a random forest model similarly to how we built a decision tree in scikit-learn - this time using the `RandomForestRegressor` class instead of `DecisionTreeRegressor`.","4c0589fb":"## Load the data!","7c6737e0":"## Selecting The Prediction Target \nYou can pull out a variable with **dot-notation**.  This single column is stored in a **Series**, which is broadly like a DataFrame with only a single column of data.  \n\nWe'll use the dot notation to select the column we want to predict, which is called the **prediction target**. By convention, the prediction target is called **y**. So the code we need to save the house prices in the Melbourne data is","6d9fc3d0":"---\n# Building Your Model\n\nYou will use the [**scikit-learn**](https:\/\/scikit-learn.org\/stable\/index.html) library to create your models.  When coding, this library is written as **sklearn**, as you will see in the sample code. Scikit-learn is easily the most popular library for modeling the types of data typically stored in DataFrames. \n\nThe steps to building and using a model are:\n* **Define:** What type of model will it be?  A decision tree?  Some other type of model? Some other parameters of the model type are specified too.\n* **Fit:** Capture patterns from provided data. This is the heart of modeling.\n* **Predict:** Just what it sounds like\n* **Evaluate**: Determine how accurate the model's predictions are.\n\nHere is an example of defining a decision tree model with scikit-learn and fitting it with the features and target variable.","080768b7":"Of the options listed, what is the optimal number of leaves?","c458731c":"## Our Scenario\nYour cousin has made millions of dollars speculating on real estate. He's offered to become business partners with you because of your interest in data science. He'll supply the money, and you'll supply models that predict how much various houses are worth.\n\nYou ask your cousin how he's predicted real estate values in the past. and he says it is just intuition. But more questioning reveals that he's identified price patterns from houses he has seen in the past, and he uses those patterns to make predictions for new houses he is considering.\n\nMachine learning works the same way.  We'll start with a model called the [**Decision Tree**](https:\/\/scikit-learn.org\/stable\/modules\/tree.html#). There are fancier models that give more accurate predictions. But decision trees are easy to understand.\n\nFor simplicity, we'll start with the simplest possible decision tree. \n\n![First Decision Trees](http:\/\/i.imgur.com\/7tsb5b1.png)\n\nIt divides houses into only two categories. The predicted price for any house under consideration is the historical average price of houses in the same category.\n\nWe use data to decide how to break the houses into two groups,  and then again to determine the predicted price in each group.  This step of capturing patterns from data is called **fitting** or **training** the model. The data used to **fit** the model is called the **training data**.  \n\nWe will get to the details of how the model is fit (e.g. how to split up the data).  After the model has been fit, you can apply it to new data to **predict** prices of additional homes.\n\n---\n## Improving the Decision Tree\nYou can capture more factors affecting home price using a tree that has more \"splits.\" These are called \"deeper\" trees. A decision tree that also considers the total size of each house's lot might look like this: \n\n![Depth 2 Tree](http:\/\/i.imgur.com\/R3ywQsR.png)\n\nYou predict the price of any house by tracing through the decision tree, always picking the path corresponding to that house's characteristics. The predicted price for the house is at the bottom of the tree.  The point at the bottom where we make a prediction is called a **leaf.**   \n\nThe splits and values at the leaves will be determined by the data, so it's time for you to check out the data you will be working with.","04f51d7a":" \nHow do we know which machine learning models to use?  \n- [Scikit-learn](https:\/\/scikit-learn.org\/stable\/index.html)\n\n- [Which machine learning models to use?](https:\/\/towardsdatascience.com\/which-machine-learning-model-to-use-db5fdf37f3dd)\n\n- [Tour of machine learning algorithms](https:\/\/machinelearningmastery.com\/a-tour-of-machine-learning-algorithms\/)\n\n![Images](https:\/\/miro.medium.com\/max\/2000\/1*FrmBl7WZBbedTku_2SQV3A.png)\n[(source)](https:\/\/peekaboo-vision.blogspot.com\/2013\/01\/machine-learning-cheat-sheet-for-scikit.html)\n\n","8c0537c8":"- Your mean absolute error for the in-sample data was about 500 dollars.  \n- Out-of-sample it is more than 250,000 dollars.\n\nThis is the difference between a model that is almost exactly right, and one that is unusable for most practical purposes.  As a point of reference, the average home value in the validation data is 1.1 million dollars.  So the error in new data is about a quarter of the average home value. \n\nLet's find ways to improve this model!","b9c83c54":"## Selecting Data for Modeling\nYour dataset had  too many variables to wrap your head around, or even to print out nicely.  How can you pare down this overwhelming amount of data to something you can understand?\n\nWe'll start by picking a few variables using our intuition. Later courses will show you statistical techniques to automatically prioritize variables.\n\nTo choose variables\/columns, we'll need to see a list of all columns in the dataset. That is done with the **columns** property of the DataFrame (the bottom line of code below).\n","36169568":"`random_state=1` is like setting the seed\n\nMany machine learning models allow some randomness in model training. Specifying a number for `random_state` ensures you get the same results in each run. \n\nA side note on global optimum:  *The problem of learning an optimal decision tree is known to be NP-complete under several aspects of optimality and even for simple concepts. Consequently, practical decision-tree learning algorithms are based on heuristic algorithms such as the greedy algorithm where locally optimal decisions are made at each node. Such algorithms cannot guarantee to return the globally optimal decision tree. This can be mitigated by training multiple trees in an ensemble learner, where the features and samples are randomly sampled with replacement.*\n\nWe now have a fitted model that we can use to make predictions.\n\nIn practice, you'll want to make predictions for new houses coming on the market rather than the houses we already have prices for. But we'll make predictions for the first few rows of the training data to see how the predict function works.\n","67622741":"## Experimenting With Different Models, Underfitting and Overfitting\n\nNow that you have a reliable way to measure model accuracy, you can experiment with alternative models and see which gives the best predictions.  But what alternatives do you have for models?\n\nYou can see in scikit-learn's [documentation](http:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.tree.DecisionTreeRegressor.html) that the decision tree model has many options. The most important options determine the tree's depth.  A tree's depth is a measure of how many splits it makes before coming to a prediction.  \n\nIf a tree to has 10 splits, data will be split into \\\\(2^{10}\\\\) groups of houses, or 1024 leaves.  \n\n**Overfitting**:  When we divide the houses amongst many leaves, we also have fewer houses in each leaf.  Leaves with very few houses may make very unreliable predictions for new data.\n\n**Underfitting**:  If our tree very shallow, it doesn't divide up the houses into very distinct groups.  Resulting predictions may be far off for most houses, even in the training data (and it will be bad in validation too for the same reason). When a model fails to capture important distinctions and patterns in the data, so it performs poorly even in training data, that is called **underfitting**.  \n\nWe want to find the model between underfitting and overfitting.  Visually, we want the low point of the (red) validation curve.\n\n<img src=\"http:\/\/i.imgur.com\/AXSEOfI.png\" alt=\"underfitting_overfitting\" width=\"500\"\/>\n\n### Example\nLets use `max_leaf_nodes` argument to control overfitting vs underfitting.  We can use a utility function to help compare MAE scores from different values for `max_leaf_nodes`:\n","b8776a99":"## Choosing \"Features\"\nThe columns that are inputted into our model (and later used to make predictions) are called **features**. In our case, those would be the columns used to determine the home price. Sometimes, you will use all columns except the target as features. Other times you'll be better off with fewer features. \n\nFor now, we'll build a model with only a few features. Later on you'll see how to iterate and compare models built with different features.\n\nBy convention, this data is called **X**."}}