{"cell_type":{"0f602744":"code","f738fe0c":"code","f01495cc":"code","358850b4":"code","3dd7ec1b":"code","1a9f2812":"code","b88ba27a":"code","fbdb3ff4":"code","f3382aee":"code","a6bf1452":"code","5e9427a8":"code","845c37b6":"code","d3ed2e48":"code","c7fbe232":"code","f71c5faa":"code","da77c3b7":"code","e4423878":"code","311de0b7":"code","6e99f958":"code","c916a3a8":"code","d03824c0":"code","caaa159e":"code","9d2ce45f":"code","cafe5578":"code","a54b7c40":"code","c053236b":"markdown","5f26bf7d":"markdown","d488dd39":"markdown"},"source":{"0f602744":"#read\/write image data\n!pip install imageio\n#deep learning library\n!pip install torch\n#access kaggle datasets from colab\n!pip install kaggle\n#model loading\n!pip install ipywidgets","f738fe0c":"#File input output\nimport os\n#matrix math\nimport numpy as np\n#read\/write image data\nimport imageio\n#visualize data\nimport matplotlib.pyplot as plt\n#data preprocessing \nimport pandas as pd\n#deep learning\nimport torch\n#just in case we need a backup datasets\nfrom torch.utils import data\n#will output the plot right below the cell that produces it\n%matplotlib inline","f01495cc":"#allows us to upload files into colab\n#we'll need to upload the kaggle.json file\n#in kaggle, under accounts, click 'create new API token'\n#upload the kaggle.json file that is automatically downloaded\n\n# only Run in Reasearch.colab\n\n'''\nfrom google.colab import files\nfiles.upload()\n'''","358850b4":"#ensure its there\n!ls -lha kaggle.json","3dd7ec1b":"# The Kaggle API client expects this file to be in ~\/.kaggle,\n# so lets move it there.\n!mkdir -p ~\/.kaggle\n!cp kaggle.json ~\/.kaggle\/\n\n# This permissions change avoids a warning on Kaggle tool startup.\n!chmod 600 ~\/.kaggle\/kaggle.json","1a9f2812":"#lets now download our dataset\n!kaggle competitions download -c tgs-salt-identification-challenge ","b88ba27a":"#and we'll need those training images unzipped\n!ls\n!unzip train.zip","fbdb3ff4":"#lets create a class to represent this data, to make it easier to access\n\nclass TGSSaltDataset(data.Dataset):\n    #init with the location of the dataset, and the list of file \n    def __init__(self, root_path, file_list):\n        self.root_path = root_path\n        self.file_list = file_list\n    #get method - how long is the list\n    def __len__(self):\n        return len(self.file_list)\n    #get method - return the seismic image + label for a given index\n    def __getitem__(self, index):\n        #if the index is out of bounds, get a random image\n        if index not in range(0, len(self.file_list)):\n            return self.__getitem__(np.random.randint(0, self.__len__()))\n        #define a file ID using the index parameter\n        file_id = self.file_list[index]\n        #image folder + path\n        image_folder = os.path.join(self.root_path, \"images\")\n        image_path = os.path.join(image_folder, file_id + \".png\")\n        #label folder + path\n        mask_folder = os.path.join(self.root_path, \"masks\")\n        mask_path = os.path.join(mask_folder, file_id + \".png\")\n        #read it, store it in memory as a byte array\n        image = np.array(imageio.imread(image_path), dtype=np.uint8)\n        mask = np.array(imageio.imread(mask_path), dtype=np.uint8)\n        #return image + label\n        return image, mask","f3382aee":"#only run in Google.colab.research\n'''\n#train image + mask data\ntrain_mask = pd.read_csv('train.csv')\n#depth data\ndepth = pd.read_csv('depths.csv')\n#training path\ntrain_path = \".\/\"\n\n#list of files\nfile_list = list(train_mask['id'].values)\n#define our dataset using our class\ndataset = TGSSaltDataset(train_path, file_list)\n'''","a6bf1452":"#function to visualize these images\ndef plot2x2Array(image, mask):\n    #invoke matplotlib!\n    f, axarr = plt.subplots(1,2)\n    axarr[0].imshow(image)\n    axarr[1].imshow(mask)\n    axarr[0].grid()\n    axarr[1].grid()\n    axarr[0].set_title('Image')\n    axarr[1].set_title('Mask')","5e9427a8":"#only run in Google.colab.research\n'''\nfor i in range(5):\n    image, mask = dataset[np.random.randint(0, len(dataset))]\n    plot2x2Array(image, mask)","845c37b6":"'''plt.figure(figsize = (6, 6))\nplt.hist(depth['z'], bins = 50)\nplt.title('Depth distribution')'''","d3ed2e48":"#convert to image\ndef rleToMask(rleString,height,width):\n    #width heigh\n    rows,cols = height,width\n    try:\n        #get numbers\n        rleNumbers = [int(numstring) for numstring in rleString.split(' ')]\n        #get pairs\n        rlePairs = np.array(rleNumbers).reshape(-1,2)\n        #create an image\n        img = np.zeros(rows*cols,dtype=np.uint8)\n        #for each pair\n        for index,length in rlePairs:\n            #get the pixel value \n            index -= 1\n            img[index:index+length] = 255\n        \n        \n        #reshape\n        img = img.reshape(cols,rows)\n        img = img.T\n    \n    #else return empty image\n    except:\n        img = np.zeros((cols,rows))\n    \n    return img","c7fbe232":"#only run in Google.research.colab\n#for measuring how salty an image is\ndef salt_proportion(imgArray):\n    try: \n        unique, counts = np.unique(imgArray, return_counts=True)\n        ## The total number of pixels is 101*101 = 10,201\n        return counts[1]\/10201.\n    \n    except: \n        return 0.0","f71c5faa":"#only run in Google.research.colab\n'''\ntrain_mask['mask'] = train_mask['rle_mask'].apply(lambda x: rleToMask(x, 101,101))\ntrain_mask['salt_proportion'] = train_mask['mask'].apply(lambda x: salt_proportion(x))","da77c3b7":"#only run in Google.research.colab\n'''\nmerged = train_mask.merge(depth, how = 'left')\nmerged.head()","e4423878":"#only run in Google.research.colab\n'''\nplt.figure(figsize = (12, 6))\nplt.scatter(merged['salt_proportion'], merged['z'])\nplt.title('Proportion of salt v. depth')","311de0b7":"#only run in Google.research.colab\n'''\nprint(\"Correlation: \", np.corrcoef(merged['salt_proportion'], merged['z'])[0, 1])\n","6e99f958":"from keras.models import Model, load_model\nfrom keras.layers import Input\nfrom keras.layers.core import Lambda, RepeatVector, Reshape\nfrom keras.layers.convolutional import Conv2D, Conv2DTranspose\nfrom keras.layers.pooling import MaxPooling2D\nfrom keras.layers.merge import concatenate\nfrom keras.callbacks import EarlyStopping, ModelCheckpoint, ReduceLROnPlateau\nfrom keras import backend as K","c916a3a8":"im_width = 128\nim_height = 128\nborder = 5\nim_chan = 2 # Number of channels: first is original and second cumsum(axis=0)\nn_features = 1 # Number of extra features, like depth\n#path_train = '..\/input\/train\/'\n#path_test = '..\/input\/test\/'","d03824c0":"# Build U-Net model\ninput_img = Input((im_height, im_width, im_chan), name='img')\ninput_features = Input((n_features, ), name='feat')\n\nc1 = Conv2D(8, (3, 3), activation='relu', padding='same') (input_img)\nc1 = Conv2D(8, (3, 3), activation='relu', padding='same') (c1)\np1 = MaxPooling2D((2, 2)) (c1)\n\nc2 = Conv2D(16, (3, 3), activation='relu', padding='same') (p1)\nc2 = Conv2D(16, (3, 3), activation='relu', padding='same') (c2)\np2 = MaxPooling2D((2, 2)) (c2)\n\nc3 = Conv2D(32, (3, 3), activation='relu', padding='same') (p2)\nc3 = Conv2D(32, (3, 3), activation='relu', padding='same') (c3)\np3 = MaxPooling2D((2, 2)) (c3)\n\nc4 = Conv2D(64, (3, 3), activation='relu', padding='same') (p3)\nc4 = Conv2D(64, (3, 3), activation='relu', padding='same') (c4)\np4 = MaxPooling2D(pool_size=(2, 2)) (c4)\n\n# Join features information in the depthest layer\nf_repeat = RepeatVector(8*8)(input_features)\nf_conv = Reshape((8, 8, n_features))(f_repeat)\np4_feat = concatenate([p4, f_conv], -1)\n\nc5 = Conv2D(128, (3, 3), activation='relu', padding='same') (p4_feat)\nc5 = Conv2D(128, (3, 3), activation='relu', padding='same') (c5)\n\nu6 = Conv2DTranspose(64, (2, 2), strides=(2, 2), padding='same') (c5)\n#check out this skip connection thooooo\nu6 = concatenate([u6, c4])\nc6 = Conv2D(64, (3, 3), activation='relu', padding='same') (u6)\nc6 = Conv2D(64, (3, 3), activation='relu', padding='same') (c6)\n\nu7 = Conv2DTranspose(32, (2, 2), strides=(2, 2), padding='same') (c6)\nu7 = concatenate([u7, c3])\nc7 = Conv2D(32, (3, 3), activation='relu', padding='same') (u7)\nc7 = Conv2D(32, (3, 3), activation='relu', padding='same') (c7)\n\nu8 = Conv2DTranspose(16, (2, 2), strides=(2, 2), padding='same') (c7)\nu8 = concatenate([u8, c2])\nc8 = Conv2D(16, (3, 3), activation='relu', padding='same') (u8)\nc8 = Conv2D(16, (3, 3), activation='relu', padding='same') (c8)\n\nu9 = Conv2DTranspose(8, (2, 2), strides=(2, 2), padding='same') (c8)\nu9 = concatenate([u9, c1], axis=3)\nc9 = Conv2D(8, (3, 3), activation='relu', padding='same') (u9)\nc9 = Conv2D(8, (3, 3), activation='relu', padding='same') (c9)\n\noutputs = Conv2D(1, (1, 1), activation='sigmoid') (c9)\n\nmodel = Model(inputs=[input_img, input_features], outputs=[outputs])\nmodel.compile(optimizer='adam', loss='binary_crossentropy') #, metrics=[mean_iou]) # The mean_iou metrics seens to leak train and test values...\nmodel.summary()","caaa159e":"!pip install ipywidgets\n","9d2ce45f":"#only run in Google.research.colab\n'''\nimport sys\nfrom tqdm import tqdm\nfrom keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img\nfrom skimage.transform import resize\n\n\ntrain_ids = next(os.walk(train_path+\"images\"))[2]\n\n\n# Get and resize train images and masks\nX = np.zeros((len(train_ids), im_height, im_width, im_chan), dtype=np.float32)\ny = np.zeros((len(train_ids), im_height, im_width, 1), dtype=np.float32)\nX_feat = np.zeros((len(train_ids), n_features), dtype=np.float32)\nprint('Getting and resizing train images and masks ... ')\nsys.stdout.flush()\nfor n, id_ in tqdm(enumerate(train_ids), total=len(train_ids)):\n    path = train_path\n    \n    # Depth\n    #X_feat[n] = depth.loc[id_.replace('.png', ''), 'z']\n    \n    # Load X\n    img = load_img(path + '\/images\/' + id_, grayscale=True)\n    x_img = img_to_array(img)\n    x_img = resize(x_img, (128, 128, 1), mode='constant', preserve_range=True)\n    \n    # Create cumsum x\n    x_center_mean = x_img[border:-border, border:-border].mean()\n    x_csum = (np.float32(x_img)-x_center_mean).cumsum(axis=0)\n    x_csum -= x_csum[border:-border, border:-border].mean()\n    x_csum \/= max(1e-3, x_csum[border:-border, border:-border].std())\n\n    # Load Y\n    mask = img_to_array(load_img(path + '\/masks\/' + id_, grayscale=True))\n    mask = resize(mask, (128, 128, 1), mode='constant', preserve_range=True)\n\n    # Save images\n    X[n, ..., 0] = x_img.squeeze() \/ 255\n    X[n, ..., 1] = x_csum.squeeze()\n    y[n] = mask \/ 255\n\nprint('Done!')","cafe5578":"#only run in Google.research.colab\n'''from sklearn.model_selection import train_test_split\n\nX_train, X_valid, X_feat_train, X_feat_valid, y_train, y_valid = train_test_split(X, X_feat, y, test_size=0.15, random_state=42)","a54b7c40":"#only run in Google.research.colab\n'''\ncallbacks = [\n    EarlyStopping(patience=5, verbose=1),\n    ReduceLROnPlateau(patience=3, verbose=1),\n    ModelCheckpoint('model-tgs-salt-1.h5', verbose=1, save_best_only=True, save_weights_only=True)\n]\n\nresults = model.fit({'img': X_train, 'feat': X_feat_train}, y_train, batch_size=16, epochs=50, callbacks=callbacks,\n                    validation_data=({'img': X_valid, 'feat': X_feat_valid}, y_valid))","c053236b":"I've made this repository in research.colab so there might be some sort of errors.\nGithub Repository Link : https:\/\/github.com\/harshitahluwalia7895\/TGS-Salt-Identification-Challenge-Kaggle \nLinkedin Link: https:\/\/www.linkedin.com\/in\/harshit-ahluwalia-4b1153141\/\n![alt text](https:\/\/pbs.twimg.com\/media\/DilKBjUVsAA74j1.jpg)\n\n## Background Data\n\n- Where there is salt, there is oil.\n- But where is the salt?\n- Classifying seismic imaging currently requires human (salt\/not salt)\n- Can we use an algorithm to do this instead? (yes)\n- Seismic data is like an ultra-sound of the subsurface\n- It uses wavelengths around 1m to 100m\n- The Society of Exploration Geophysicists has 10K publications using the keyword 'salt'\n- We can think of Earth as layered.\n- Sand gets deposited on top of existing sand. And in comes the salt.\n- There is an entire research branch dedicated to salt tectonics, that is the movement of salt in the subsurface.\n\n## Our steps\n\n- Install Dependencies\n- Upload our Dataset\n- View the labeled seismic imaging data\n- Plot the depth distribution in the training data \n- Plot the proportion of salt vs depth in the training data\n- Build a U-Net algorithm to learn the mapping between seismic images and the salt filter mask\n","5f26bf7d":"#### U-Nets\n\n- This looks like a computer vision problem!\n- What outperforms everything else when it comes to computer vision most of the time? (hint deep learning)\n- Specifically, deep convolutional neural networks.\n- AlexNet\n- VGG-16, VGG-19;\n- Inception Nets;\n- ResNet;\n- Squeeze Net \n\n![alt text](https:\/\/pics.spark-in.me\/upload\/388373c74ab710cc4c429538d4779a93.png)\n![alt text](https:\/\/pics.spark-in.me\/upload\/8b468c6dd60a499e6cdde0af803cb96f.png)\n\n#### Why not use one of these, why use a U-Net?\n\n- U-NET is considered one of standard architectures for image classification tasks, when we need not only to segment the whole image by its class, but also to segment areas of image by class, i.e. produce a mask that will separate image into several classes.\n-its architecture is input image size agnostic since it does not contain fully connected layers \n- Because of many layers takes significant amount of time to train;\n- U-Net is designed like an auto-encoder. \n- It has an encoding path (\u201ccontracting\u201d) paired with a decoding path (\u201cexpanding\u201d) which gives it the \u201cU\u201d shape.  \n- However, in contrast to the autoencoder, U-Net predicts a pixelwise segmentation map of the input image rather than classifying the input image as a whole. \n- For each pixel in the original image, it asks the question: \u201cTo which class does this pixel belong?\n- This flexibility allows U-Net to predict different parts of the seismic image (salt, not salt) simultaneously.\n- U-Net passes the feature maps from each level of the contracting path over to the analogous level in the expanding path.  \n- These are similar to residual connections in a ResNet type model, and allow the classifier to consider features at various scales and complexities to make its decision.\n\n#### What does a U-Net look like?\n\n![alt text](https:\/\/cdn-images-1.medium.com\/max\/800\/1*dKPBgCdJx6zj3MpED3lcNA.png)\n![alt text](https:\/\/pics.spark-in.me\/upload\/cb8197bb7e57317eda88f921dfc1c413.png)\n\nits high to low res, then low res to high res\n\n- The first part (encoder) is where we apply convolutional blocks followed by a maxpool downsampling to encode the input image into feature representations at multiple different levels.\n\nconvolutions\u2192 downsampling.\n\nExample\n\n```\n# a sample down block\ndef make_conv_bn_relu(in_channels, out_channels, kernel_size=3, stride=1, padding=1):\n    return [\n        nn.Conv2d(in_channels, out_channels, kernel_size=kernel_size,  stride=stride, padding=padding, bias=False),\n        nn.BatchNorm2d(out_channels),\n        nn.ReLU(inplace=True)\n    ]\nself.down1 = nn.Sequential(\n    *make_conv_bn_relu(in_channels, 64, kernel_size=3, stride=1, padding=1 ),\n    *make_conv_bn_relu(64, 64, kernel_size=3, stride=1, padding=1 ),\n)\n\n# convolutions followed by a maxpool\ndown1 = self.down1(x)\nout1   = F.max_pool2d(down1, kernel_size=2, stride=2)\n\n```\n\n- The  second part (decoder) of the network consists of upsample and concatenation followed by regular convolution operations\n\nupsampling \u2192 concatenation \u2192convolutions.\n\n```\n# a sample up block\ndef make_conv_bn_relu(in_channels, out_channels, kernel_size=3, stride=1, padding=1):\n    return [\n        nn.Conv2d(in_channels, out_channels, kernel_size=kernel_size,  stride=stride, padding=padding, bias=False),\n        nn.BatchNorm2d(out_channels),\n        nn.ReLU(inplace=True)\n    ]\nself.up4 = nn.Sequential(\n    *make_conv_bn_relu(128,64, kernel_size=3, stride=1, padding=1 ),\n    *make_conv_bn_relu(64,64, kernel_size=3, stride=1, padding=1 )\n)\nself.final_conv = nn.Conv2d(32, num_classes, kernel_size=1, stride=1, padding=0 )\n\n# upsample out_last, concatenate with down1 and apply conv operations\nout   = F.upsample(out_last, scale_factor=2, mode='bilinear')  \nout   = torch.cat([down1, out], 1)\nout   = self.up4(out)\n\n# final 1x1 conv for predictions\nfinal_out = self.final_conv(out)\n```\n\n\n","d488dd39":"Run-length encoding (RLE) is a very simple form of lossless data compression in which runs of data (that is, sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count, rather than as the original run. \n\n![alt text](https:\/\/sites.google.com\/a\/ruknuddin.com\/inqilab-patel-magazine\/_\/rsrc\/1525765922681\/term-of-the-day\/runlengthencoding\/RunLengthEncoding.PNG)\n\n"}}