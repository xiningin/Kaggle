{"cell_type":{"bc192af2":"code","3b5252f6":"code","04a2e44f":"code","7c068080":"code","14d2544d":"code","88bebe09":"code","74b338d6":"code","371b992f":"code","e1fb41c8":"code","6034d559":"code","27834f09":"code","56f2b86f":"code","1ed5ba1b":"code","24599c89":"code","0a1f1d45":"code","bed3ac10":"markdown","ab430ef3":"markdown","d4f03f36":"markdown","1624846a":"markdown","4e3af1a5":"markdown","23a4df5c":"markdown"},"source":{"bc192af2":"# General Libs\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom tensorflow import keras\n\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, Conv2D, MaxPooling2D, Flatten\nfrom tensorflow.keras.optimizers import RMSprop\n\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.preprocessing import image\n# from tensorflow.keras.applications.inception_v3 import InceptionV3, preprocess_input\nfrom tensorflow.keras.applications.inception_resnet_v2 import InceptionResNetV2, preprocess_input\nfrom tensorflow.keras.layers import Dense, Flatten\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.optimizers import Adam\nimport random\n\n\n# Resultados\nfrom tensorflow.keras.models import load_model\nfrom sklearn.metrics import classification_report, confusion_matrix\n\n","3b5252f6":"import itertools\n\n#Plot the confusion matrix. Set Normalize = True\/False\ndef plot_confusion_matrix(cm, classes, normalize=True, title='Confusion matrix', cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.figure(figsize=(10,10))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        cm = np.around(cm, decimals=2)\n        cm[np.isnan(cm)] = 0.0\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","04a2e44f":"# Configura\u00e7\u00f5es para importar o dataset\nIMG_SIZE = 299\nIMG_SHAPE = (IMG_SIZE,IMG_SIZE)\n\nFIRE_DATASET_DIR = '..\/input\/firedataset\/fire-dataset\/fire_dataset'\nFIRE_TEST_DATASET_DIR = '..\/input\/firedataset\/fire-dataset\/test_fire_dataset'\n    \nSEED = 10\n\nBATCH_SIZE = 32","7c068080":"# doc: https:\/\/www.tensorflow.org\/api_docs\/python\/tf\/keras\/preprocessing\/image\/ImageDataGenerator#flow_from_directory\n\n# Generator para parte train\ntrain_generator = ImageDataGenerator(validation_split=0.2)\n\n# data_generator = ImageDataGenerator(rescale=1.\/255, validation_split=0.2)\n\ntrain_generator = train_generator.flow_from_directory(FIRE_DATASET_DIR, target_size=IMG_SHAPE, shuffle=True, seed=SEED,\n                                                     class_mode='categorical', batch_size=BATCH_SIZE, subset=\"training\")\n\n# Generator para parte valida\u00e7\u00e3o\nvalidation_generator = ImageDataGenerator(preprocessing_function=preprocess_input, validation_split=0.2)\nvalidation_generator = validation_generator.flow_from_directory(FIRE_DATASET_DIR, target_size=IMG_SHAPE, shuffle=False, seed=SEED,\n                                                     class_mode='categorical', batch_size=BATCH_SIZE, subset=\"validation\")\n\n# Generator para dataset de teste\ntest_generator = ImageDataGenerator(preprocessing_function=preprocess_input)\ntest_generator = test_generator.flow_from_directory(FIRE_TEST_DATASET_DIR, target_size=IMG_SHAPE, shuffle=False, seed=SEED,\n                                                    class_mode='categorical', batch_size=BATCH_SIZE)\n\n\nnb_train_samples = train_generator.samples\nnb_validation_samples = validation_generator.samples\nnb_test_samples = test_generator.samples\nclasses = list(train_generator.class_indices.keys())\nprint('Classes: '+ str(classes))\nnum_classes = len(classes)","14d2544d":"# Visualizando alguns exemplos do dataset por meio do Generator criado\nplt.figure(figsize=(15,15))\nfor i in range(3):\n    #gera subfigures\n    plt.subplot(330 + 1 + i)\n    batch = validation_generator.next()[0]*255\n    image = batch[0].astype('uint8')\n    plt.imshow(image)\nplt.show()","88bebe09":"model = Sequential()\nmodel.add(Conv2D(40, kernel_size=(3, 3),\n                 activation='relu',\n                 input_shape=(IMG_SIZE,IMG_SIZE,3)))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Conv2D(60, kernel_size=(3,3), activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Conv2D(80, kernel_size=(3,3), activation='relu'))\nmodel.add(Flatten())\nmodel.add(Dense(100, activation='relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(100, activation='relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(num_classes, activation='softmax'))\nmodel.summary()\n","74b338d6":"# Compilar o modelo\nmodel.compile(loss='categorical_crossentropy',\n              optimizer=RMSprop(),\n              metrics=['accuracy'])\n\n# Parametros\nepochs = 40\n\n# Salvar o melhor modelo\ncallbacks_list = [\n    keras.callbacks.ModelCheckpoint(\n        filepath = 'model.manual',\n        monitor = 'val_loss',\n        save_best_only = True,\n        verbose = 1),\n    keras.callbacks.EarlyStopping(\n        monitor = 'val_loss', \n        patience = 10,\n        verbose = 1)\n]\n\nhistory = model.fit(train_generator,\n                    steps_per_epoch = train_generator.samples \/\/ BATCH_SIZE,\n                    epochs = epochs,\n                    callbacks = callbacks_list,\n                    validation_data = validation_generator,\n                    verbose = 1,\n                    validation_steps = validation_generator.samples \/\/ BATCH_SIZE)","371b992f":"history_dict = history.history\nloss_values = history_dict['loss']\nval_loss_values = history_dict['val_loss']\n\nepochs_x = range(1, len(loss_values) + 1)\nplt.figure(figsize=(10,10))\nplt.subplot(2,1,1)\nplt.plot(epochs_x, loss_values, 'bo', label='Training loss')\nplt.plot(epochs_x, val_loss_values, 'b', label='Validation loss')\nplt.title('Training and validation Loss and Acc')\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.legend()\nplt.subplot(2,1,2)\nacc_values = history_dict['accuracy']\nval_acc_values = history_dict['val_accuracy']\nplt.plot(epochs_x, acc_values, 'bo', label='Training acc')\nplt.plot(epochs_x, val_acc_values, 'b', label='Validation acc')\n\nplt.xlabel('Epochs')\nplt.ylabel('Acc')\nplt.legend()\nplt.show()\n","e1fb41c8":"# Carregando o melhor modelo salvo\nmodel = load_model('model.manual')\n\nscore_val = model.evaluate_generator(validation_generator)\nscore_test = model.evaluate_generator(test_generator)\n\nprint(f\"Val loss:{score_val[0]}\\tVal accuracy:{score_val[1]}\")\nprint(f\"Test loss:{score_test[0]}\\tTest accuracy:{score_test[1]}\")","6034d559":"#Confution Matrix and Classification Report\nY_pred = model.predict_generator(test_generator)\ny_pred = np.argmax(Y_pred, axis=1)\ntarget_names = classes\n\n#Confution Matrix\ncm = confusion_matrix(test_generator.classes, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\n\n#Classification Report\nprint('Classification Report')\nprint(classification_report(test_generator.classes, y_pred, target_names=target_names))","27834f09":"base_model = InceptionResNetV2(weights='imagenet',\n                               include_top=False,\n                               input_shape=(IMG_SIZE, IMG_SIZE, 3))\n\nx = base_model.output\nx = Flatten()(x)\nx = Dense(100, activation='relu')(x)\npredictions = Dense(num_classes, activation='softmax', kernel_initializer='random_uniform')(x)\n\nmodel = Model(inputs=base_model.input, outputs=predictions)\n\n# Freezing pretrained layers\nfor layer in base_model.layers:\n    layer.trainable=False\n    \noptimizer = Adam()\nmodel.compile(optimizer=optimizer,loss='categorical_crossentropy',metrics=['accuracy'])","56f2b86f":"epochs = 40\n\n# Saving the best model\ncallbacks_list = [\n    keras.callbacks.ModelCheckpoint(\n        filepath='model.transferlearning',\n        monitor='val_loss', save_best_only=True, verbose=1),\n    keras.callbacks.EarlyStopping(monitor='val_loss', patience=10,verbose=1)\n]\n\nhistory = model.fit(\n        train_generator,\n        steps_per_epoch=nb_train_samples \/\/ BATCH_SIZE,\n        epochs=epochs,\n        callbacks = callbacks_list,\n        validation_data=validation_generator,\n        verbose = 1,\n        validation_steps=nb_validation_samples \/\/ BATCH_SIZE)\n","1ed5ba1b":"history_dict = history.history\nloss_values = history_dict['loss']\nval_loss_values = history_dict['val_loss']\n\nepochs_x = range(1, len(loss_values) + 1)\nplt.figure(figsize=(10,10))\nplt.subplot(2,1,1)\nplt.plot(epochs_x, loss_values, 'bo', label='Training loss')\nplt.plot(epochs_x, val_loss_values, 'b', label='Validation loss')\nplt.title('Training and validation Loss and Accuracy')\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\n#plt.legend()\nplt.subplot(2,1,2)\nacc_values = history_dict['accuracy']\nval_acc_values = history_dict['val_accuracy']\nplt.plot(epochs_x, acc_values, 'bo', label='Training acc')\nplt.plot(epochs_x, val_acc_values, 'b', label='Validation acc')\n#plt.title('Training and validation accuracy')\nplt.xlabel('Epochs')\nplt.ylabel('Acc')\nplt.legend()\nplt.show()","24599c89":"# Load the best saved model\nmodel = load_model('model.transferlearning')\n\nscore_val = model.evaluate_generator(validation_generator)\nscore_test = model.evaluate_generator(test_generator)\n\nprint(f\"Val loss:{score_val[0]}\\tVal accuracy:{score_val[1]}\")\nprint(f\"Test loss:{score_test[0]}\\tTest accuracy:{score_test[1]}\")","0a1f1d45":"#Confution Matrix and Classification Report\nY_pred = model.predict_generator(test_generator)\ny_pred = np.argmax(Y_pred, axis=1)\ntarget_names = classes\n\n#Confution Matrix\ncm = confusion_matrix(test_generator.classes, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\n\nprint('Classification Report')\nprint(classification_report(test_generator.classes, y_pred, target_names=target_names))","bed3ac10":"### Resultados ","ab430ef3":"# Modelo Transfer\u00eancia de Aprendizado","d4f03f36":"## Configura\u00e7\u00f5es iniciais ","1624846a":"### Resultados","4e3af1a5":"# Deep Learning Aplicada - Atividade 2\n\n## Descri\u00e7\u00e3o da Atividade\nNo Kaggle, procure um dataset de imagens interessante (prefer\u00eancia com tasks - submiss\u00e3o - ranking), \u00e0 sua escolha, e implementar modelos de deep learning para classifica\u00e7\u00e3o considerando a melhor avalia\u00e7\u00e3o de acur\u00e1cia poss\u00edvel. Compare um modelo totalmente desenvolvido manualmente e um modelo baseado em arquiteturas cl\u00e1ssicas e transfer learning. Entregar um \u00fanico notebook (link p\u00fablico) com as solu\u00e7\u00f5es e seus resultados. Na pr\u00f3xima aula, apresentar estrat\u00e9gias desenvolvidas e resultados obtidos.\n\n## Dataset\nDataset contendo imagens de fogo\n\n#### Dataset Treino e Valida\u00e7\u00e3o\n980 imagens no formato jpge\nFonte: https:\/\/www.kaggle.com\/phylake1337\/fire-dataset\n\n#### Dataset Test\n20 imagens no formato jpge\nFonte: Pesquisa do google image\n\n## Notebook\nUsa como base o [notebook](https:\/\/www.kaggle.com\/mauriciofigueiredo\/fruit-classification-with-transfer-learning) utilizado na disciplina pelo professor [Maur\u00edcio Figueiredo](https:\/\/www.kaggle.com\/mauriciofigueiredo)\n\n#### Autora: Thalita Alves\n","23a4df5c":"# Modelo Manual "}}