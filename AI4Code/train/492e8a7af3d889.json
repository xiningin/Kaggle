{"cell_type":{"05233984":"code","b9ecb52c":"code","d4b581c9":"code","a9d1f75f":"code","6cca4d50":"code","4314dbc4":"code","f47770aa":"code","49b8e6c2":"code","ec0cb54b":"code","0b83888f":"code","3eafb151":"code","c06a2dca":"code","b109a94e":"code","abffab1d":"code","08cd1e9e":"code","3c0144a7":"code","442a0c6d":"code","6fb48927":"code","bcdb381a":"code","64f49f1a":"code","31a4eff9":"markdown","fe26fcc9":"markdown","42fc66b3":"markdown","f1b7be98":"markdown","f038319a":"markdown","faa4c86b":"markdown","ee08f353":"markdown","065a6aba":"markdown","3901c038":"markdown","cf0efbf9":"markdown","63225246":"markdown","37a63883":"markdown","ab67ddc5":"markdown","657fb2bc":"markdown","4f70f8bd":"markdown","71f5b345":"markdown","58de173b":"markdown","351deb37":"markdown","618a11cc":"markdown"},"source":{"05233984":"import os\nprint(os.listdir(\"..\/input\/chest-xray-pneumonia\/chest_xray\/train\"))","b9ecb52c":"import numpy as np\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\nfrom scipy import signal\nfrom scipy.fftpack import fft, ifft\nimport cv2\nimport matplotlib.pyplot as plt\nimport os\nfrom scipy import fft\nfrom tqdm import tqdm\nimport seaborn as sns\nfrom itertools import chain \nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import Imputer, LabelEncoder, OneHotEncoder, StandardScaler\n\nsns.set(style=\"whitegrid\")\nnimdata = cv2.imread(\"..\/input\/chest-xray-pneumonia\/chest_xray\/train\/NORMAL\/IM-0531-0001-0001.jpeg\",cv2.IMREAD_GRAYSCALE)\npmdata = cv2.imread(\"..\/input\/chest-xray-pneumonia\/chest_xray\/train\/PNEUMONIA\/person619_virus_1190.jpeg\",cv2.IMREAD_GRAYSCALE)\nfig , axs = plt.subplots(1,2,figsize=(10,10))\naxs[0].imshow(pmdata,cmap='gray')\naxs[0].set_title('PNEUMONIA')\naxs[1].imshow(nimdata,cmap='gray')\naxs[1].set_title('NORMAL')\nplt.show()","d4b581c9":"resize_pimg = cv2.resize(pmdata,(50,50))\nresize_nimg = cv2.resize(nimdata,(50,50))\npflatten_list = list(chain.from_iterable(resize_pimg)) \nnflatten_list = list(chain.from_iterable(resize_nimg)) \nfig,axs = plt.subplots(2,1,figsize=(12,4),sharex=True)\naxs[0].plot(pflatten_list)\naxs[0].set_title('PNEUMONIA')\naxs[1].plot(nflatten_list)\naxs[1].set_title('NORMAL')\nplt.show()","a9d1f75f":"fig,axs = plt.subplots(1,2,figsize=(12,4),sharex=True)\nsns.distplot(pflatten_list,ax=axs[0],color='Red').set_title('PNEUMONIA')\nsns.distplot(nflatten_list,ax=axs[1],color='Green').set_title('NORMAL')\nplt.show()","6cca4d50":"pfreqs, ppsd = signal.welch(pflatten_list)\nnfreqs, npsd = signal.welch(nflatten_list)\nfig,axs = plt.subplots(1,2,figsize=(12,4),sharey=True)\naxs[0].semilogx(pfreqs, ppsd,color ='r')\naxs[1].semilogx(nfreqs, npsd,color ='g')\naxs[0].set_title('PSD: PNEUMONIA')\naxs[1].set_title('PSD: NORMAL')\naxs[0].set_xlabel('Frequency')\naxs[1].set_xlabel('Frequency')\naxs[0].set_ylabel('Power')\naxs[1].set_ylabel('Power')\nplt.tight_layout()","4314dbc4":"sos = signal.iirfilter(3, Wn=0.01, rs=0.5 ,fs=100,btype='lp',output='sos',\n                       analog=False, ftype='cheby2')\nw, h = signal.sosfreqz(sos, worN=100)\n","f47770aa":"plt.subplot(2, 1, 1)\ndb = 20*np.log10(np.maximum(np.abs(h), 1e-5))\nplt.plot(w, db)\nplt.ylim(-75, 5)\nplt.grid(True)\nplt.yticks([0, -20, -40, -60])\nplt.ylabel('Gain [dB]')\nplt.title('Frequency Response')\nplt.subplot(2, 1, 2)\nplt.plot(w\/np.pi, np.angle(h))\nplt.grid(True)\nplt.yticks([-np.pi, -0.5*np.pi, 0, 0.5*np.pi, np.pi],\n           [r'$-\\pi$', r'$-\\pi\/2$', '0', r'$\\pi\/2$', r'$\\pi$'])\nplt.ylabel('Phase [rad]')\nplt.xlabel('Normalized frequency (1.0 = Nyquist)')\nplt.show()","49b8e6c2":"t, s = signal.step(sos)\nfig,axs = plt.subplots(1,1,figsize=(7,3),sharey=True)\naxs.semilogx(t, s,color ='g')\naxs.set_title('PSD')\naxs.set_xlabel('Frequency')\naxs.set_ylabel('Power')\nplt.tight_layout()","ec0cb54b":"fig, axs = plt.subplots(2, 2,figsize=(12,4), sharey=True,sharex=True)\npfiltered = signal.sosfilt(sos, pflatten_list)\nnfiltered = signal.sosfilt(sos, nflatten_list)\naxs[0,0].plot(pflatten_list)\naxs[0,0].set_title('PNEUMONIA')\naxs[0,1].plot(pfiltered)\naxs[0,1].set_title('PNEUMONIA After 0.01 Hz low-pass filter')\naxs[1,0].plot(nflatten_list)\naxs[1,0].set_title('NORMAL')\naxs[1,1].plot(nfiltered)\naxs[1,1].set_title('NORMAL After 0.01 Hz low-pass filter')\n#ax2.axis([0, 1, -2, 2])\nplt.show()","0b83888f":"pfreqs, ppsd = signal.welch(pfiltered)\nnfreqs, npsd = signal.welch(nfiltered)\nfig,axs = plt.subplots(1,2,figsize=(12,4),sharey=True)\naxs[0].semilogx(pfreqs, ppsd,color ='r')\naxs[1].semilogx(nfreqs, npsd,color ='g')\naxs[0].set_title('PSD: PNEUMONIA FILTERED')\naxs[1].set_title('PSD: NORMAL FILTERED')\naxs[0].set_xlabel('Frequency')\naxs[1].set_xlabel('Frequency')\naxs[0].set_ylabel('Power')\naxs[1].set_ylabel('Power')\nplt.tight_layout()","3eafb151":"fig,axs = plt.subplots(1,2,figsize=(12,4),sharey=True)\npf, Pxx_den = signal.periodogram(pfiltered, 50)\nf, nxx_den = signal.periodogram(nfiltered, 50)\naxs[0].semilogy(pf, Pxx_den)\naxs[1].semilogy(f, nxx_den)\naxs[0].set_title('PNEUMOINA')\naxs[1].set_title('NORMAL')\naxs[0].set_xlabel('frequency [Hz]')\naxs[0].set_xlabel('frequency [Hz]')\naxs[0].set_ylabel('PSD [V**2\/Hz]')\nplt.show()","c06a2dca":"def autocorrelation(x):\n    xp = np.fft.fftshift((x - np.average(x))\/np.std(x))\n    n, = xp.shape\n    xp = np.r_[xp[:n\/\/2], np.zeros_like(xp), xp[n\/\/2:]]\n    f = fft(xp)\n    p = np.absolute(f)**2\n    pi = ifft(p)\n    return np.real(pi)[:n\/\/2]\/(np.arange(n\/\/2)[::-1]+n\/\/2)\n\ndef kLargest(arr, k): \n    max_ks = []\n    # Sort the given array arr in reverse  \n    # order. \n    arr = np.sort(arr)[::-1]\n    #arr.sort(reverse = True) \n    # Print the first kth largest elements \n    for i in range(k):\n        max_ks.append(arr[i])\n        \n    return max_ks\n\ndef rms(x):\n    return np.sqrt(np.mean(x**2))","b109a94e":"print(f'Tree max values of autocorrelation\\nNORMAL FILTERED:   {kLargest(autocorrelation(nfiltered), 3)}\\n\\nPNEUMONIA FILTERED:{kLargest(autocorrelation(pfiltered), 3)}')","abffab1d":"ppeaks, _  = signal.find_peaks(ppsd)\nnpeaks, _  = signal.find_peaks(npsd)\nprint(f'Ten max peaksof filtered PSD\\nPNEUMONIA:   {kLargest(ppeaks,10)}\\nNORMAL peaks:{kLargest(npeaks,10)}')","08cd1e9e":"print(f'Root Mean Square\\n--------------------\\nNORMAL : {rms(nfiltered)}\\nPNEUMOINA : {rms(pfiltered)}')\nprint('--'*10)\nprint(f'Mean \\n--------------------\\nNORMAL : {np.mean(pflatten_list)}\\nPNEUMOINA : {np.mean(nfiltered)}')","3c0144a7":"fig,axs = plt.subplots(1,2,figsize=(12,4),sharey=True)\nnfft = fft(nflatten_list)\npfft = fft(pflatten_list)\naxs[0].plot(pfft.real, 'b-')\naxs[0].plot(pfft.imag, 'r--')\naxs[0].set_title('PNEUMOINA')\naxs[1].plot(nfft.real, 'b-')\naxs[1].plot(nfft.imag, 'r--')\naxs[1].set_title('NORMAL')\nplt.legend(('real', 'imaginary'))\n\nplt.show()","442a0c6d":"dft = cv2.dft(np.float32(nimdata),flags = cv2.DFT_COMPLEX_OUTPUT)\ndft_shift = np.fft.fftshift(dft)\nmagnitude_spectrum = 20*np.log(cv2.magnitude(dft_shift[:,:,0],dft_shift[:,:,1]))\nplt.figure(figsize=(11,6))\nplt.subplot(121),plt.imshow(nimdata, cmap = 'gray')\nplt.title('ORIGINAL'), plt.xticks([]), plt.yticks([])\nplt.subplot(122),plt.imshow(magnitude_spectrum, cmap = 'gray')\nplt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])\nplt.show()","6fb48927":"dft = cv2.dft(np.float32(pmdata),flags = cv2.DFT_COMPLEX_OUTPUT)\ndft_shift = np.fft.fftshift(dft)\nmagnitude_spectrum = 20*np.log(cv2.magnitude(dft_shift[:,:,0],dft_shift[:,:,1]))\nplt.figure(figsize=(11,6))\nplt.subplot(121),plt.imshow(pmdata, cmap = 'gray')\nplt.title('ORIGINAL'), plt.xticks([]), plt.yticks([])\nplt.subplot(122),plt.imshow(magnitude_spectrum, cmap = 'gray')\nplt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])\nplt.show()","bcdb381a":"mpath = \"..\/input\/chest-xray-pneumonia\/chest_xray\/train\/\"\nIM_SIZE = 90\nfrom tqdm import tqdm\ndef get_img(folder):\n    X = []\n    y = []\n    for xr in os.listdir(folder):\n        if not xr.startswith('.'):\n            if xr in ['NORMAL']:\n                label = 0\n            elif xr in ['PNEUMONIA']:\n                label = 1\n            for filename in tqdm(os.listdir(folder + xr)):\n                im_array = cv2.imread(folder + xr +'\/'+ filename,cv2.IMREAD_GRAYSCALE)\n                if im_array is not None:\n                    img = cv2.resize(im_array,(IM_SIZE,IM_SIZE))\n                    dft = cv2.dft(np.float32(img),flags = cv2.DFT_COMPLEX_OUTPUT)\n                    dft_shift = np.fft.fftshift(dft)\n                    magnitude_spectrum = 20*np.log(cv2.magnitude(dft_shift[:,:,0],dft_shift[:,:,1]))\n                    msd = np.std(magnitude_spectrum)\n                    new_image = cv2.Laplacian(img,cv2.CV_64F)\n                    lpvar = abs(np.max(new_image) - np.min(new_image))\/np.max(new_image)\n                    #flatten the image\n                    flatten_list = list(chain.from_iterable(img))\n                    #filtering\n                    sos = signal.iirfilter(3, Wn=0.01, rs=0.5 ,fs=100,btype='lp',output='sos',\n                       analog=False, ftype='cheby2')\n                    filtered = signal.sosfilt(sos, flatten_list)\n                    #power Spectral density\n                    _, psd = signal.welch(filtered)\n                    #find peaks of PSD\n                    peaks, _  = signal.find_peaks(psd)\n                    maxPeaks  = kLargest(peaks, k=6)\n                    #mean and rms\n                    Mean = np.mean(flatten_list)\n                    Rms = rms(filtered)\n                    # autocorrelation\n                    auto= autocorrelation(filtered)\n                    maxauto = kLargest(auto, k=5)\n                    #fft\n                    invfft = fft(filtered)\n                    vfl = np.std(flatten_list)\n                    invfft_r_peaks, _  = signal.find_peaks(invfft.real)\n                    invfft_imag_peaks, _  = signal.find_peaks(invfft.imag)\n                    maxinvfft_r_peaks  = kLargest(invfft_r_peaks, k=6)\n                    maxinvfft_imag_peaks  = kLargest(invfft_imag_peaks, k=6)\n                    #peaks of periodogram filtered\n                    _, Pxx_den = signal.periodogram(filtered,100)\n                    Perio_Peaks, _  = signal.find_peaks(Pxx_den)\n                    \n                    maxPerio_Peaks  = kLargest(Perio_Peaks, k=6)\n                    total = maxPeaks + [Rms,Mean,lpvar,msd,vfl] \n                    total = total + maxPerio_Peaks\n                    total = total + maxinvfft_r_peaks\n                    total = total + maxinvfft_imag_peaks\n                    total = total + maxPeaks\n                    total = total + maxauto\n                    X.append(total)\n                    y.append(label)    \n    y = np.array(y)\n    return np.array(X),y\nX,y = get_img(mpath)\n\nX_train,X_test,y_train,y_test = train_test_split(X,y ,test_size = 0.2)\n#Normalization\nscaler = StandardScaler()\nX_train = scaler.fit_transform(X_train)    \nX_test = scaler.transform(X_test)\nmmscaler = MinMaxScaler()\nX_train_01 = mmscaler.fit_transform(X_train)    \nX_test_01 = mmscaler.transform(X_test)","64f49f1a":"import tensorflow as tf  \nmodel = tf.keras.models.Sequential()  \nmodel.add(tf.keras.layers.Dense(1000, activation=tf.nn.relu))  \nmodel.add(tf.keras.layers.Dense(1000, activation=tf.nn.relu))\n\nmodel.add(tf.keras.layers.Dense(2, activation=tf.nn.softmax)) \n\nmodel.compile(optimizer='adam',  \n              loss='sparse_categorical_crossentropy',  \n              metrics=['accuracy'])  \nmodel.fit(X_train_01, y_train, epochs=200)  \n\nval_loss, val_acc = model.evaluate(X_test_01, y_test) \nprint(f'Validation loss: {val_loss}')  \nprint(f'Validation accuracy: {val_acc}')  ","31a4eff9":">** WHAT NEXT?**\n>\n> Now I'm looking for someone who have deeper understanding about Signal Processing to make this model better ","fe26fcc9":"> **Periodogram of filtered Signsls**","42fc66b3":"> **3- Root Mean Square and Mean of filtered signals**\n","f1b7be98":"> Now base on Signals,PSD and filtered Signals we calculate some parametrs can lead to distinguish type of images\n>\n> **1- Autocorrelation**","f038319a":"> **5- Magnitude Spectrum can be useful**\n>\n>a- NORMAL","faa4c86b":"> **2- Finding Peaks**","ee08f353":"> This two plots are slightly different.\n>\n>Let's compare probability distributions","065a6aba":">**4- Inverse Fast Fourier Transform**","3901c038":">b- PNEUMOINA\n","cf0efbf9":">**TRAINING THE MODEL**","63225246":"># SIGNAL PROCESSING AND DEEP LEARING\nIn this kernal we are trying to classify X ray images by combining Signal Processing and Deep Learing rather than using Convolutional Neural Network.\nTo Start we **import** required libraries and tow **images (PNEUMONIA,NORMAL)** from the X ray dataset for analysis purposes.","37a63883":">The Step response","ab67ddc5":">Helper functions to find autocorrelation,Root Mean Square and max values of an array ","657fb2bc":"> From PSD plots I choose the **critical frequency** at 0.01Hz and  minimum attenuation in the stop band 0.5 and samplling size 1000, and method **IIR Chebyshev type II filter**\n>\n>Let's take a look at the Frquancy response","4f70f8bd":"> The nomal image histogrom is more close to normal distribution intressting !!!.\n>\n>Now we have seen signals are too noicy, in this situation it's very difficlt to extract some informations from, so our nex step is to remove noices from images roughtly speaking we apply **Filtering**.\n>\n> What type of filter? \n>\n> What is Cutoff frequency ?\n>Here we are looking for small hiden  informations on these images so i think the ideal type of filter is **LOWPASS FILTER**. Let's take a look to the Power Spectral Density PSD\n","71f5b345":"> **Now we apply Signal Processing to all images**","58de173b":"> Power Spectral Density of filtered Signals","351deb37":"> To transform images into signals we reduce image sizes and used a flatten fucntion to convert  them from 2-D into 1-D array","618a11cc":"> Applying the filter to Signals"}}