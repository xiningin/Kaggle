{"cell_type":{"0aa452cb":"code","a7ef664d":"code","3cef7192":"code","898109ab":"code","3ebf463d":"code","92f92337":"code","49176d63":"code","a7b28be9":"code","7a0605d4":"code","f1d5c569":"code","700cb17d":"markdown","1e6a5808":"markdown","4a475b02":"markdown"},"source":{"0aa452cb":"\nimport matplotlib.pyplot as plt\nimport random\nimport time\nimport os\n\nimport numpy as np\nfrom sklearn.pipeline import make_pipeline\n# Binary Relevance\nfrom sklearn.multiclass import OneVsRestClassifier\n\n# Performance metric\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.metrics import roc_curve, auc\nfrom sklearn.metrics import hamming_loss\nfrom sklearn.metrics import label_ranking_average_precision_score\nfrom sklearn.metrics import multilabel_confusion_matrix\nfrom sklearn.metrics import classification_report\n\nfrom sklearn.model_selection import train_test_split\n\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.preprocessing import StandardScaler\n\n\nfrom sklearn.model_selection import cross_val_score","a7ef664d":"ACTIONS = [\"kiri\", \"maju\",\"idle\",\"kanan\"]\nreshape = (-1,8, 60)\n","3cef7192":"def create_data(starting_dir=\"..\/input\/eeg8chanel\/data8\"):\n    training_data = {}\n    for action in ACTIONS:\n        if action not in training_data:\n            training_data[action] = []\n        data_dir = os.path.join(starting_dir,action)\n        for item in os.listdir(data_dir):\n            data = np.load(os.path.join(data_dir, item))\n            for item in data:\n                training_data[action].append(item)\n\n    lengths = [len(training_data[action]) for action in ACTIONS]\n    print(lengths)\n\n    for action in ACTIONS:\n        np.random.shuffle(training_data[action])  \n        training_data[action] = training_data[action][:min(lengths)]\n\n    lengths = [len(training_data[action]) for action in ACTIONS]\n    print(lengths)\n    combined_data = []\n    for action in ACTIONS:\n        for data in training_data[action]:\n            if action == \"kiri\":\n                combined_data.append([data, [1, 0, 0,0]])\n            elif action == \"maju\":\n                combined_data.append([data, [0, 1, 0, 0]])\n            elif action == \"idle\":\n                combined_data.append([data, [0, 0, 1, 0]])\n            elif action == \"kanan\":\n                combined_data.append([data, [0, 0, 0, 1]])\n\n    np.random.shuffle(combined_data)\n    print(\"length:\",len(combined_data))\n    return combined_data\n","898109ab":"print(\"creating training data\")\ntraindata = create_data(starting_dir=\"..\/input\/eeg8chanel\/data8\")\ntrain_X = []\ntrain_y = []\n\nfor X, y in traindata:\n    train_X.append(X)\n    train_y.append(y)\n    \n\n","3ebf463d":"train_X = np.array(train_X).reshape(1000,480)\ntrain_y = np.array(train_y)\ntrain_X.shape,train_y.shape\n","92f92337":"x_train,x_test,y_train,y_test=train_test_split(train_X,train_y,test_size=0.2 )\nx_train.shape,y_train.shape, x_test.shape , y_test.shape","49176d63":"from sklearn.neighbors import KNeighborsClassifier","a7b28be9":"#training a logistics regression model\nlogmodel = OneVsRestClassifier(KNeighborsClassifier(3))\nlogmodel.fit(x_train,y_train)\nprediksi = logmodel.predict(x_test)\n\nprint(classification_report(y_test,prediksi))\nprint(\"Accuracy = \",accuracy_score(y_test,prediksi))\nprint(\"Hamming Loss = \",hamming_loss(y_test,prediksi))\nprint(\"label_ranking_average_precision_score\",label_ranking_average_precision_score(y_test,prediksi))\nscores = cross_val_score( logmodel, x_train,y_train, cv=5, scoring='f1_macro')\nscores","7a0605d4":"\n#defining various steps required for the genetic algorithm\ndef initilization_of_population(size,n_feat):\n    population = []\n    for i in range(size):\n        chromosome = np.ones(n_feat,dtype=np.bool)\n        chromosome[:int(0.3*n_feat)]=False\n        np.random.shuffle(chromosome)\n        population.append(chromosome)\n    return population\n\ndef fitness_score(population):\n    scores = []\n    for chromosome in population:\n        logmodel.fit(x_train[:,chromosome],y_train)\n        predictions = logmodel.predict(x_test[:,chromosome])\n        scores.append(accuracy_score(y_test,predictions))\n    scores, population = np.array(scores), np.array(population) \n    inds = np.argsort(scores)\n    return list(scores[inds][::-1]), list(population[inds,:][::-1])\n\ndef selection(pop_after_fit,n_parents):\n    population_nextgen = []\n    for i in range(n_parents):\n        population_nextgen.append(pop_after_fit[i])\n    return population_nextgen\n\ndef crossover(pop_after_sel):\n    population_nextgen=pop_after_sel\n    for i in range(len(pop_after_sel)):\n        child=pop_after_sel[i]\n        child[3:7]=pop_after_sel[(i+1)%len(pop_after_sel)][3:7]\n        population_nextgen.append(child)\n    return population_nextgen\n\ndef mutation(pop_after_cross,mutation_rate):\n    population_nextgen = []\n    for i in range(0,len(pop_after_cross)):\n        chromosome = pop_after_cross[i]\n        for j in range(len(chromosome)):\n            if random.random() < mutation_rate:\n                chromosome[j]= not chromosome[j]\n        population_nextgen.append(chromosome)\n    #print(population_nextgen)\n    return population_nextgen\n\ndef generations(size,n_feat,n_parents,mutation_rate,n_gen,x_train,\n                                   x_test, y_train, y_test):\n    best_chromo= []\n    best_score= []\n\n    population_nextgen=initilization_of_population(size,n_feat)\n    for i in range(n_gen):\n        scores, pop_after_fit = fitness_score(population_nextgen)\n        print(scores[:2])\n        pop_after_sel = selection(pop_after_fit,n_parents)\n        pop_after_cross = crossover(pop_after_sel)\n        population_nextgen = mutation(pop_after_cross,mutation_rate)\n        best_chromo.append(pop_after_fit[0])\n        best_score.append(scores[0])\n    return best_chromo,best_score","f1d5c569":"chromo,score=generations(#size=200,\n                         size=3,\n                         n_feat=480,\n                         #n_parents=100,\n                         n_parents=3,\n                         mutation_rate=0.10,\n                         n_gen=11,\n                         x_train=x_train,x_test=x_test,y_train=y_train,y_test=y_test)\nlogmodel.fit(x_train[:,chromo[-1]],y_train)\npredictions = logmodel.predict(x_test[:,chromo[-1]])\nprint(\"Accuracy score after genetic algorithm is= \"+str(accuracy_score(y_test,predictions)))\nprint(classification_report(y_test,predictions))","700cb17d":"# DATA","1e6a5808":"# hasil ml validasi silang","4a475b02":"# hasil ml +GA"}}