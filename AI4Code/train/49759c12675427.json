{"cell_type":{"617fbab9":"code","93dd8ea5":"code","31ba4ee6":"code","3bb47ff3":"code","ffa1edb4":"code","374a30e7":"code","db992804":"code","bf1f6498":"code","9a4c145e":"code","f6b9cd85":"code","82c63f73":"code","05f430f2":"code","ccebbadd":"code","c2c9ee03":"code","5467031b":"code","220c72c7":"code","8e968d23":"code","a3451000":"code","17eac21c":"code","b80b3f6b":"code","c66db9c9":"code","577cc173":"markdown","03d485d2":"markdown","6d86b1e6":"markdown"},"source":{"617fbab9":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","93dd8ea5":"from math import sqrt\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import linear_kernel\nimport plotly.express as px\nimport plotly.graph_objects as go\n","31ba4ee6":"rating = pd.read_csv('..\/input\/movielens-20m-dataset\/rating.csv')","3bb47ff3":"movies = pd.read_csv('..\/input\/movielens-20m-dataset\/movie.csv')","ffa1edb4":"## Dimensionlaity of the rating\nprint(\"Number of Rows:\", rating.shape[0])\nprint(\"Number of Columns:\", rating.shape[1])","374a30e7":"## Dimensionlaity of the Movies \nprint(\"Number of Rows:\", movies.shape[0])\nprint(\"Number of Columns:\", movies.shape[1])","db992804":"## Columns\nrating.columns","bf1f6498":"## Columns\nmovies.columns","9a4c145e":"rating.describe()","f6b9cd85":"movies.describe(include=['object'])","82c63f73":"fig = go.Figure(data=[go.Bar(\n            x=movies['genres'].value_counts().index[0:15], y=movies['genres'].value_counts().values[0:15],\n            text=movies['genres'].value_counts().values[0:15],\n            textposition='outside',marker_color='dodgerblue'\n        )])\n\nfig.show()","05f430f2":"rating","ccebbadd":"merge_ratings_movies = pd.merge(movies, rating, on='movieId', how='inner')","c2c9ee03":"merge_ratings_movies","5467031b":"ratings_grouped_by_users = merge_ratings_movies.groupby('userId').agg([np.size, np.mean])\nratings_grouped_by_users","220c72c7":"# Define a TF-IDF Vectorizer Object.\ntfidf_movies_genres = TfidfVectorizer(token_pattern = '[a-zA-Z0-9\\-]+')\n\n#Replace NaN with an empty string\nmovies['genres'] = movies['genres'].replace(to_replace=\"(no genres listed)\", value=\"\")\n\n#Construct the required TF-IDF matrix by fitting and transforming the data\ntfidf_movies_genres_matrix = tfidf_movies_genres.fit_transform(movies['genres'])\ncosine_sim_movies = linear_kernel(tfidf_movies_genres_matrix, tfidf_movies_genres_matrix)","8e968d23":"print(cosine_sim_movies)","a3451000":"def get_recommendations_based_on_genres(movie_title, cosine_sim_movies=cosine_sim_movies):\n    # Get the index of the movie that matches the title\n    idx_movie = movies.loc[movies['title'].isin([movie_title])]\n    idx_movie = idx_movie.index\n    \n    # Get the pairwsie similarity scores of all movies with that movie\n    sim_scores_movies = list(enumerate(cosine_sim_movies[idx_movie][0]))\n    \n    # Sort the movies based on the similarity scores\n    sim_scores_movies = sorted(sim_scores_movies, key=lambda x: x[1], reverse=True)\n\n    # Get the scores of the 10 most similar movies\n    sim_scores_movies = sim_scores_movies[1:10]\n    \n    # Get the movie indices\n    movie_indices = [i[0] for i in sim_scores_movies]\n    \n    # Return the top most similar movies\n    return movies['title'].iloc[movie_indices]","17eac21c":"get_recommendations_based_on_genres(\"Toy Story (1995)\")","b80b3f6b":"def get_recommendation_content_model(userId):\n    recommended_movie_list = []\n    movie_list = []\n    df_rating_filtered = rating[rating[\"userId\"]== userId]\n    for key, row in df_rating_filtered.iterrows():\n        movie_list.append((movies[\"title\"][row[\"movieId\"]==movies[\"movieId\"]]).values) \n    for index, movie in enumerate(movie_list):\n        for key, movie_recommended in get_recommendations_based_on_genres(movie[0]).iteritems():\n            recommended_movie_list.append(movie_recommended)\n\n    # removing already watched movie from recommended list    \n    for movie_title in recommended_movie_list:\n        if movie_title in movie_list:\n            recommended_movie_list.remove(movie_title)\n    \n    return set(recommended_movie_list)","c66db9c9":"get_recommendation_content_model(52)","577cc173":"## Collaborative Filtering","03d485d2":"## Top Movies","6d86b1e6":"## Load Data"}}