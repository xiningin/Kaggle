{"cell_type":{"624a33fb":"code","661df956":"code","695f3972":"code","639eb9ff":"code","1ead5ea4":"code","1a57c47b":"code","3d605583":"markdown","41d49340":"markdown","133277a4":"markdown"},"source":{"624a33fb":"import math\nimport matplotlib.pyplot as plt\nimport random\nimport numpy as np\n\nrand = []\nfor i in range(3):\n    r = random.randrange(3,15,1)\n    if r in rand:\n      i -= 1\n    else:\n      rand.append(r)\n      \nprint(\"random gen frequencies: \", rand)\n\n#generate random signal made of 3 overlain frequencies\ndef signal(t):\n    return(math.sin(rand[0]*t) + math.sin(rand[1]*t) + math.sin(rand[2]*t))\n\n\ndef delrepeats(inarr):\n  newarr = []\n  for i in inarr:\n    if i not in newarr:\n      newarr.append(i)\n  return(newarr)","661df956":"#The variable q which is being passed to the function acts as the limit. The larger this number the more accurate the integral approximation will be -- at the cost of computational speed. \n\n#Converts to approximation of e^j*omega with eulers identity (remove imaginary isin part)\ndef g(t,x):\n    return (signal(t)*math.cos(x*t))\n\n#Riemann Integral with respect to time (dt)\ndef riemann_integral(a,b,q):\n    scalar = (b-a)\/q\n    sum = 0\n    for n in range(1,q):\n        sum += signal(n*scalar)\n    return(sum*scalar)\n\n#Riemann Integral In terms of time and frequency (Used for Fourier)\n#this integral has an additional omega input (makes it a function)\ndef riemann_integral1(a,b,q,omega):\n    scalar = (b-a)\/q\n    sum = 0\n    for n in range(1,q):\n        sum += g(n*scalar,omega)\n    return(sum*scalar)","695f3972":"arr_omega=[]\narr_integral= []\narr_ampf=[]\narr_t=[]\narr_amp=[]\n\nstep = 10*50\nfor i in range(0,step):\n    time = i\/50\n    arr_t.append(time)\n    arr_amp.append(signal(time))\n    arr_integral.append(riemann_integral(0,time,100))\n","639eb9ff":"plt.plot(arr_t, arr_amp)\nplt.plot(arr_t, arr_integral)\nplt.xlabel(\"Time\")\nplt.ylabel(\"Amplitude\")\nplt.show()\n#plot signal and signal integral for testing","1ead5ea4":"q=100\nstep = 15*50\nfor i in range(0,step):\n    x = i\/50\n    arr_omega.append(x)\n    arr_ampf.append((1\/q) * riemann_integral1(0,q,1000,x))\nprint(arr_omega[30])\nprint(arr_ampf[30])\n\nplt.plot(arr_omega, arr_ampf)\nplt.xlabel(\"Frequency\")\nplt.ylabel(\"Amplitude\")\nplt.show()\n#Plot fourier transform\n#Spikes occur at randomly determined frequencies","1a57c47b":"lastamp = 0\narrSpikeFreq = []\n\n#find max amplitude frequency\nnpampf = np.asarray(arr_ampf)\nmaxindex = np.argmax(npampf)\nmaxamp = arr_ampf[maxindex]\n\n#use max amp. to normalize values \nfor ampindex in range(len(arr_ampf)):\n  normalizedval = abs(arr_ampf[ampindex] \/ maxamp)\n  #if the normalized value is bigger than 90% round and append as a spike\n  if normalizedval > .9:\n    arrSpikeFreq.append(round(arr_omega[ampindex]))\n\n#remove repeated frequencies\nfrequencies = delrepeats(arrSpikeFreq)\n\nprint(\"predicted frequencies:\",frequencies)\nprint(\"actual frequencies:\", rand)","3d605583":"Although advanced and efficient algorithms for computing the fourier transform of time series data have been long uncovered. Understanding the original algorithms for approximating the core of most signal processing algorithms can provide a deeper appreciation of what's really going on \"under the hood\".\n\nLet's first start by defining a random \"signal\" by overlaying 3 randomly generated sin waves with unique differing frequencies.","41d49340":"In the block below the fourier operation is run on the sample signal that we generated. ","133277a4":"Explaination of Math:\n\nA fourier transform is an integral transform with the kernel:\n\n$$e^{j \\omega t}$$\n\nIn an integral transform an improper definite integral needs to be computed for every point in frequency space: this would ordinarly be impossible to do computationally but there are some approximations that enable it. In order to do this we will be using the Rieman Sum definition of a Definite Integral, which we have developed a python algorithm for. \n\nThe mathematical operation for a riemann integral is:\n\n$$\\int_{a}^{b}f(x)dx= \\lim_{n \\to \\infty} \\sum_{k=1}^{n} f(a +k\\Delta x)*\\Delta x \\\\\n\\\\\nwhere,\\space \\Delta x = \\frac{b-a}{n} \n$$\n\nSince our fourier integral deals with 2 domains (frequency and time) this operation will yield a function rather than a definite value. This function which we are solving for will be notated as a function of omega.\n$$ \\\\ \\\\\ns(\\omega)=\\int_{-\\infty}^{\\infty}f(t)e^{-j\\omega t}dt=\\lim_{q \\to \\infty}\\sum_{k=0}^{q} f(-q+k\\Delta x)e^{-j\\omega (-q+k\\Delta x)}$$\n\nHowever this integral contains the imaginary operator j, which cannot be reasonably computed without human intuition. The workaround will be to use Euler's indentity to estimate the real part:\n\n$$since, \\space e^{i\\theta} = cos(\\theta) - isin(\\theta)\n\\\\\n\\\\\n e^{j\\omega t} = cos(\\omega t) - isin(\\omega t) \\approx cos(\\omega t) $$ \n\n with the approxation we can substitute this into our integral, additionally the delta X term was factored out of the sum to make our computations efficient (One time multiplication rather than with each sum-iteration).\n\n This makes our final approximation for the fourier transform (frequency function):\n\nthis approximation increases in accuracy as q is increased.\n\n $$s(\\omega) \\approx \\Delta x * \\sum_{k=0}^{q} f(-q+k\\Delta x)*cos(\\omega * (-q+k\\Delta x))\n $$\n\nThis is a very good approximation for a fourier transform. We wrote code for this operation below. All operations explained have been converted to python functions and are shown below."}}