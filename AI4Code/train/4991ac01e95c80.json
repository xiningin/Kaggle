{"cell_type":{"5277c166":"code","b1d841f2":"code","ff12322b":"code","efed6fea":"code","e15924ea":"code","03568eac":"code","ed3e983a":"code","d3789f5f":"code","81b9eb7e":"code","093b5f16":"markdown","d2466284":"markdown","72c7c76b":"markdown","48ccf348":"markdown","b5c85c4e":"markdown","68806480":"markdown","2d6c61e1":"markdown","a5ee40ab":"markdown","a1d5d1f5":"markdown","1bc549d6":"markdown","1079bd2c":"markdown"},"source":{"5277c166":"# Set up code checking\nfrom learntools.core import binder\nbinder.bind(globals())\nfrom learntools.feature_engineering.ex1 import *\n\nimport pandas as pd\n\nclick_data = pd.read_csv('..\/input\/feature-engineering-data\/train_sample.csv',\n                         parse_dates=['click_time'])\nclick_data.head(10)","b1d841f2":"# Add new columns for timestamp features day, hour, minute, and second\nclicks = click_data.copy()\nclicks['day'] = clicks['click_time'].dt.day.astype('uint8')\n# Fill in the rest\nclicks['hour'] = clicks['click_time'].dt.hour.astype('uint8')\nclicks['minute'] = clicks['click_time'].dt.minute.astype('uint8')\nclicks['second'] = clicks['click_time'].dt.second.astype('uint8')\n\n# Check your answer\nq_1.check()","ff12322b":"from sklearn import preprocessing\n\ncat_features = ['ip', 'app', 'device', 'os', 'channel']\n\n\nlabel_encoder = preprocessing.LabelEncoder()\nfor feature in cat_features:\n    encoded = label_encoder.fit_transform(clicks[feature])\n    clicks[feature + '_labels'] = encoded\n\n# Check your answer\nq_2.check()","efed6fea":"clicks.head()","e15924ea":"# Check your answer (Run this code cell to receive credit!)\nq_3.solution()","03568eac":"# Check your answer (Run this code cell to receive credit!)\nq_4.solution()","ed3e983a":"feature_cols = ['day', 'hour', 'minute', 'second', \n                'ip_labels', 'app_labels', 'device_labels',\n                'os_labels', 'channel_labels']\n\nvalid_fraction = 0.1\nclicks_srt = clicks.sort_values('click_time')\nvalid_rows = int(len(clicks_srt) * valid_fraction)\ntrain = clicks_srt[:-valid_rows * 2]\n# valid size == test size, last two sections of the data\nvalid = clicks_srt[-valid_rows * 2:-valid_rows]\ntest = clicks_srt[-valid_rows:]","d3789f5f":"import lightgbm as lgb\n\ndtrain = lgb.Dataset(train[feature_cols], label=train['is_attributed'])\ndvalid = lgb.Dataset(valid[feature_cols], label=valid['is_attributed'])\ndtest = lgb.Dataset(test[feature_cols], label=test['is_attributed'])\n\nparam = {'num_leaves': 64, 'objective': 'binary'}\nparam['metric'] = 'auc'\nnum_round = 1000\nbst = lgb.train(param, dtrain, num_round, valid_sets=[dvalid], early_stopping_rounds=10)","81b9eb7e":"from sklearn import metrics\n\nypred = bst.predict(test[feature_cols])\nscore = metrics.roc_auc_score(test['is_attributed'], ypred)\nprint(f\"Test score: {score}\")","093b5f16":"**[Feature Engineering Home Page](https:\/\/www.kaggle.com\/learn\/feature-engineering)**\n\n---\n","d2466284":"## Evaluate the model\nFinally, with the model trained, I'll evaluate it's performance on the test set. ","72c7c76b":"### 3) One-hot Encoding\n\nNow you have label encoded features, does it make sense to use one-hot encoding for the categorical variables ip, app, device, os, or channel?\n\nRun the following line after you've decided your answer.","48ccf348":"### Create train\/validation\/test splits\n\nHere we'll create training, validation, and test splits. First, `clicks` DataFrame is sorted in order of increasing time. The first 80% of the rows are the train set, the next 10% are the validation set, and the last 10% are the test set.","b5c85c4e":"### Train with LightGBM\n\nNow we can create LightGBM dataset objects for each of the smaller datasets and train the baseline model.","68806480":"This will be our baseline score for the model. When we transform features, add new ones, or perform feature selection, we should be improving on this score. However, since this is the test set, we only want to look at it at the end of all our manipulations. At the very end of this course you'll look at the test score again to see if you improved on the baseline model.\n\n# Keep Going\nNow that you have a baseline model, you are ready to learn **[Categorical Encoding Techniques](https:\/\/www.kaggle.com\/matleonard\/categorical-encodings)** to improve it.","2d6c61e1":"## Baseline Model\n\nThe first thing you need to do is construct a baseline model. All new features, processing, encodings, and feature selection should improve upon this baseline model. First you need to do a bit of feature engineering before training the model itself.\n\n### 1) Features from timestamps\nFrom the timestamps, create features for the day, hour, minute and second. Store these as new integer columns `day`, `hour`, `minute`, and `second` in a new DataFrame `clicks`.","a5ee40ab":"# Introduction\n\nIn this exercise, you will develop a baseline model for predicting if a customer will buy an app after clicking on an ad. With this baseline model, you'll be able to see how your feature engineering and selection efforts improve the model's performance.","a1d5d1f5":"---\n**[Feature Engineering Home Page](https:\/\/www.kaggle.com\/learn\/feature-engineering)**\n\n\n\n\n\n*Have questions or comments? Visit the [Learn Discussion forum](https:\/\/www.kaggle.com\/learn-forum) to chat with other Learners.*","1bc549d6":"### 2) Label Encoding\nFor each of the categorical features `['ip', 'app', 'device', 'os', 'channel']`, use scikit-learn's `LabelEncoder` to create new features in the `clicks` DataFrame. The new column names should be the original column name with `'_labels'` appended, like `ip_labels`.","1079bd2c":"## Train, validation, and test sets\nWith our baseline features ready, we need to split our data into training and validation sets. We should also hold out a test set to measure the final accuracy of the model.\n\n### 4) Train\/test splits with time series data\nThis is time series data. Are they any special considerations when creating train\/test splits for time series? If so, what and why?\n\nUncomment the following line after you've decided your answer."}}