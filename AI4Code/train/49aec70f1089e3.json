{"cell_type":{"66bb3694":"code","c3a6ab2a":"code","f4d5f6ce":"code","aa22922f":"code","8932fbdf":"code","088e5413":"markdown","8a733d15":"markdown","5f4af49f":"markdown","3d0f2506":"markdown"},"source":{"66bb3694":"!pip install kaggle-environments --upgrade -q\n\nfrom kaggle_environments import make, evaluate","c3a6ab2a":"class HistoryCollectingAgent():\n    def __init__(self):\n        self.my_choices = []\n        self.my_rewards = []\n        self.opponent_choices = []\n    \n    def __call__(self, obs, conf):\n        if obs.lastActions:\n            self.my_choices.append(obs.lastActions[obs.agentIndex])\n            self.opponent_choices.append(obs.lastActions[1 - obs.agentIndex])\n            self.my_rewards.append(obs.reward - sum(self.my_rewards))\n        return self.action(obs, conf)\n    \n    # abstract method to be implemented in inheriting classes\n    def action(self, obs, conf): raise NotImplementedError()","f4d5f6ce":" class LeastUsedAgent(HistoryCollectingAgent):   \n    def count_pulls(self, bandit):\n        return self.my_choices.count(bandit) + self.opponent_choices.count(bandit)\n    \n    def action(self, obs, conf):\n        return min(range(conf.banditCount), key=self.count_pulls)","aa22922f":"env = make(\"mab\", debug=True)\nmy_agent = LeastUsedAgent()\nenv.run([my_agent, \"random\"])\nenv.render(mode=\"ipython\", width=800, height=500)","8932fbdf":"agent = LeastUsedAgent()\ndef do_action(obs, conf):\n    return agent(obs, conf)","088e5413":"### Since we are being passed only the last two actions we need to maintain our own history to capture past choices and rewards. This little helper class does just that","8a733d15":"### Since we implemented `__call__` you can pass your agent object as a function:","5f4af49f":"### Then every agent you create can inherit from it and have ready access to the past actions. For example the \"least pulled\" agent looks like this:","3d0f2506":"### To submit it to the competion we need to add an extra snippet since it expects a `def`"}}