{"cell_type":{"be3d068b":"code","b537bb0b":"code","776d75dc":"code","5a8d093d":"code","2ff8b2b3":"code","53e7a014":"code","4e353f8e":"code","cffe447c":"code","dba5dd45":"code","69f86556":"code","0466dbe3":"code","df07247b":"code","57084a3d":"code","a5267145":"code","ab4dd578":"code","089520ad":"code","db4a53a5":"code","a0f36390":"code","1e165dd8":"code","41adbcac":"code","b63aa390":"code","57481978":"code","40a7fb4d":"code","69346948":"markdown","218ec45d":"markdown","61bde754":"markdown","91910b16":"markdown","be53d523":"markdown","96859d38":"markdown","68e3ab8e":"markdown","4a570b94":"markdown","c0b7ce16":"markdown","fc21674c":"markdown","f613e93e":"markdown","093a5e62":"markdown","fef5b8dc":"markdown","b42e20c9":"markdown","1012191c":"markdown","67f18238":"markdown","13b18821":"markdown","4acec32e":"markdown","25157e8e":"markdown","9da82b25":"markdown","86fe970f":"markdown","7b8edcb6":"markdown","7a7c880e":"markdown","dc20b1c6":"markdown","4e89eca8":"markdown","fe3878b6":"markdown","71f1a4e4":"markdown","3fd6925c":"markdown","5bf6cd39":"markdown","fe7fd7cd":"markdown","f95e51b3":"markdown","806da9a6":"markdown","0d3b7474":"markdown","8ead0475":"markdown"},"source":{"be3d068b":"#importing all important packages\nimport numpy as np #linear algebra\nimport pandas as pd #data processing\nimport matplotlib.pyplot as plt #data visualisation\nimport seaborn as sns #data visualisation\n%matplotlib inline","b537bb0b":"#Input Data\ndata = pd.read_csv(\"..\/input\/pokemon\/Pokemon.csv\") #reading csv file and save it into a variable\ndata.head(10) #show the first 10 rows in data","776d75dc":"data.Name = data.Name.str.replace(\".*(?=Mega)\", \"\")\ndata.head(10)","5a8d093d":"data = data.set_index('Name') #change and set the index to the name attribute\ndata = data.drop(['#'],axis=1) #drop the columns with axis=1; axis=0 is for rows\ndata.head()","2ff8b2b3":"data['Type 2'].fillna(data['Type 1'], inplace=True)\ndata.head(10)","53e7a014":"print(\"Type 1:\",data[\"Type 1\"].unique(), \"=\", len(data[\"Type 1\"].unique()))\nprint(\"Type 2:\",data[\"Type 2\"].unique(), \"=\", len(data[\"Type 2\"].unique()))","4e353f8e":"print(data[\"Type 1\"].value_counts())\nprint(data[\"Type 2\"].value_counts())","cffe447c":"strongest = data.sort_values(by='Total', ascending=False) #sorting the rows in descending order\nstrongest.drop_duplicates(subset=['Type 1'],keep='first')\n#since the rows are now sorted in descending order\n#thus we take the first row for every new type of pokemon i.e the table will check Type 1 of every pokemon\n#The first pokemon of that type is the strongest for that type\n#so we just keep the first row","dba5dd45":"weakest = data.sort_values(by='Total') #sorting the rows in ascending order\nweakest.drop_duplicates(subset=['Type 1'],keep='first')","69f86556":"fastest = data.sort_values(by='Speed', ascending=False) #sorting the rows in descending order\nfastest.drop_duplicates(subset=['Type 1'],keep='first')","0466dbe3":"slowest = data.sort_values(by='Speed') #sorting the rows in ascending order\nslowest.drop_duplicates(subset=['Type 1'],keep='first')","df07247b":"#now, let's summary the data\ndata.describe()","57084a3d":"sns.set(style = 'darkgrid')\nf, ax = plt.subplots(2,1, figsize = (18,10)) #making 2 count plots \n\nsns.countplot(x = 'Type 1', data = data, order = data['Type 1'].value_counts().index ,ax = ax[0])\nsns.countplot(x = 'Type 2', data = data, order = data['Type 2'].value_counts().index ,ax = ax[1])\n\nplt.show()","a5267145":"#we create a dictionary to make process easier\ntypes_count = {'Grass' : 0, 'Fire' : 0, 'Water' : 0, 'Bug' : 0, 'Normal' : 0, 'Poison' : 0, \n               'Electric' : 0, 'Ground' : 0, 'Fairy' : 0, 'Fighting' : 0, 'Psychic' : 0, \n               'Rock' : 0, 'Ghost' : 0, 'Ice' : 0, 'Dragon' : 0, 'Dark' : 0, 'Steel' : 0, 'Flying' : 0}\n\ntype1 = data[\"Type 1\"]\ntype2 = data[\"Type 2\"]\n\nfor i in range(len(type1)):\n    \n    #first, count the Type 1 column\n    types_count[type1[i]] += 1\n    \n    #now we count the Type 2 column and avoid double counting\n    if type1[i] != type2[i]:\n        types_count[type2[i]] += 1\n\nfor t in types_count:\n    print(\"{:10} = {}\".format(t,types_count[t]))","ab4dd578":"type1_count = {'Grass' : 0, 'Fire' : 0, 'Water' : 0, 'Bug' : 0, 'Normal' : 0, 'Poison' : 0, \n               'Electric' : 0, 'Ground' : 0, 'Fairy' : 0, 'Fighting' : 0, 'Psychic' : 0, \n               'Rock' : 0, 'Ghost' : 0, 'Ice' : 0, 'Dragon' : 0, 'Dark' : 0, 'Steel' : 0,\n               'Flying' : 0}\ntype2_count = {'Grass' : 0, 'Fire' : 0, 'Water' : 0, 'Bug' : 0, 'Normal' : 0, 'Poison' : 0, \n               'Electric' : 0, 'Ground' : 0, 'Fairy' : 0, 'Fighting' : 0, 'Psychic' : 0, \n               'Rock' : 0, 'Ghost' : 0, 'Ice' : 0, 'Dragon' : 0, 'Dark' : 0, 'Steel' : 0,\n               'Flying' : 0}\n\nfor i in range(len(type1)):\n    type1_count[type1[i]] += 1\n    type2_count[type2[i]] += 1\n\nprint(\"TYPE 1\")\nfor t in type1_count:\n    print(\"{:10} = {}\".format(t,type1_count[t]))\nprint(\"-------------------\")\nprint(\"TYPE 2\")\nfor t in type2_count:\n    print(\"{:10} = {}\".format(t,type2_count[t]))","089520ad":"f, axs = plt.subplots(2,2, figsize=(20,20))\n\nlabels ='Grass', 'Fire', 'Water', 'Bug', 'Normal', 'Poison', 'Electric', 'Ground', \\\n        'Fairy', 'Fighting', 'Psychic', 'Rock', 'Ghost' ,'Ice' ,'Dragon' ,'Dark' , \\\n        'Steel','Flying'\n    \nsize0 = [95,64,126,72,102,62,50,67,40,53,90,58,46,38,50,51,49,101] #overall count\nsize1 = [70,52,112,69,98,28,44,32,17,27,57,44,32,24,32,31,27,4] #Type 1 count\nsize2 = [58,40,73,20,65,49,33,48,38,46,71,23,24,27,29,30,27,99] #Type 2 count\n\n#Overall pie\naxs[0,0].pie(size0, labels = labels, autopct='%1.1f%%' ,startangle = 90)\naxs[0,0].axis(\"equal\")\naxs[0,0].set_title(\"Overall\", size = 20)\n\n#Type1 pie\naxs[0,1].pie(size1, labels = labels, autopct='%1.1f%%' ,startangle = 180)\naxs[0,1].axis(\"equal\")\naxs[0,1].set_title(\"Type 1\", size = 20)\n\n#Type2 pie\naxs[1,0].pie(size2, labels = labels, autopct='%1.1f%%' ,startangle = 90)\naxs[1,0].axis(\"equal\")\naxs[1,0].set_title(\"Type 2\", size = 20)\n\nf.delaxes(axs[1,1]) #deleting axs[1,1] so it will be white blank\nplt.show()","db4a53a5":"data2 = data.drop(['Generation', 'Total', 'Legendary'], axis = 1) #we drop some columns that unnecessary\ndata2.head()","a0f36390":"#stats for the Attack by Type 1\nsns.set_style(\"whitegrid\")\nf, ax = plt.subplots(1,1, figsize = (20,10))\n\nax = sns.boxplot(data = data2, x = 'Type 1', y = 'Attack')\nax.set_title(label='Attack by Type 1', size = 20)\n\nplt.show()","1e165dd8":"#stats for the Attack by Type 2\nf, ax = plt.subplots(1,1, figsize = (20,10))\n\nax = sns.boxplot(data = data2, x = 'Type 2', y = 'Attack')\nax.set_title(label='Attack by Type 2', size = 20)\n\nplt.show()","41adbcac":"#stats for the Defense by Type 1\nf, ax = plt.subplots(1,1, figsize = (20,10))\n\nax = sns.violinplot(data = data2, x = 'Type 1', y = 'Defense')\nax.set_title(label='Defense by Type 1', size = 20)\n\nplt.show()","b63aa390":"#stats for the Defense by Type 2\nf, ax = plt.subplots(1,1, figsize = (20,10))\n\nax = sns.violinplot(data = data2, x = 'Type 2', y = 'Defense')\nax.set_title(label='Defense by Type 2', size = 20)\n\nplt.show()","57481978":"f, ax = plt.subplots(0,0, figsize = (20,10))\nax = sns.swarmplot(data = data, x = 'Generation', y= 'Total', hue = 'Legendary')\n\nplt.axhline(data['Total'].mean(), color = 'red', linestyle = 'dashed') #giving a straight line on mean\n\nplt.show()","40a7fb4d":"f, ax = plt.subplots(0,0,figsize=(15,10))\nax = sns.heatmap(data.corr(), annot = True, cmap = 'winter') #data.corr() used to make correlation matrix\n\nplt.show()","69346948":"The Fastest pokemon is **DeoxysSpeed Forme** which is a Legendary Psychic pokemon.","218ec45d":"<a id = \"8\"><\/a>\n### Count Plot","61bde754":"This data shows that Bug type and Normal type have slowest pokemon compared other types.","91910b16":"<a id = \"6\"><\/a>\n### Summary","be53d523":"This shows that **Steel ** pokemon have the highest defense compared the other types.","96859d38":"So, we finally know who is the strongest pokemons by types. And also the strongest of the strongest pokemon is **Mega Rayquaza**, the Dragon type. And also we know that 10\/18 Strongest Pokemons by types are Legendary. Let's check who is the weakest by types.","68e3ab8e":"We finally know who is the weakest pokemons by types. The weakest of the weakest pokemon is **Sunkern**, the Grass type. We can't find the Legendary category here.","4a570b94":"And from this chart, we can conclude that **Fighting** pokemon have a higher attack than other pokemon types. All pokemons that have Fighting as their second type have higher attack value.","c0b7ce16":"If we look at row 5, there is a NaN type in the *Type 2* row. We can choose to delete or fill in the data. But in this case if we delete rows that has NaN, then it will mess up our data. Then we'll choose to fill it by copying the data from *Type 1* column.","fc21674c":"We can conclude that the highest frequency in *Type 1* is **Water** and in *Type 2* is **Flying**. On the other hand, the lowest frequency in *Type 1* is **Flying** and in *Type 2* is **Bug**","f613e93e":"<a id = \"5\"><\/a>\n### The Fastest and The Slowest\n**Now, who is the fastest and the slowest Pokemons by types?**","093a5e62":"<a id = \"1\"><\/a>\n## Basic Analysis","fef5b8dc":"<a id = \"7\"><\/a>\n## Data Visualisation\nAnd now we move to the important part where we will get informations from visualizing our data. First, we make count plots to see value counts for each type","b42e20c9":"Hello Everyone!\nThis is my first Kaggle Notebook. I'm a beginner and I try my best to do data analysis. This Pokemon Dataset is a very good dataset to begin with and I hope you can understand my analysis. I am very open in accepting criticism and suggestions for perfecting this kernel.\n\nIf you find this notebook useful, feel free to **Upvote**.\n","1012191c":"And this shows that **Rock** pokemon is better than** Steel** pokemon in Defense values.","67f18238":"<a id = \"10\"><\/a>\n### All stats analysis of the pokemons\nlet's analyze all ratio data.","13b18821":"And we get that there are 18 unique types.\nOk, now we use *value_counts()* to count each unique type in *Type 1 * and * Type 2*","4acec32e":"<a id = \"11\"><\/a>\n### Strongest Generation","25157e8e":"We got overall count from both types, now it's time to get *Type 1* count and *Type 2* count.","9da82b25":"<a id = \"12\"><\/a>\n### Finding any correlation","86fe970f":"This shows that 3rd generation has many strong pokemons. And also this data informed that all Legendary pokemon are strong or even the strongest.","7b8edcb6":"Yes! Now finally we can make the pie plot. We'll make 3 pie plots: Type 1 count, Type 2 count. and overall count,","7a7c880e":"Ok, that's all my analysis. If you think I missed something, feel free to comment. Thank you for reading this notebook!","dc20b1c6":"______________________________________","4e89eca8":"## Exploratory Data Analysis\nby [Iqrar Agalosi Nureyza](https:\/\/www.kaggle.com\/iqrar99)\n\nDataset : [Pokemon stats](https:\/\/www.kaggle.com\/abcsds\/pokemon)\n","fe3878b6":"<a id = \"9\"><\/a>\n### Percentages for each type\n**How about percentages for each type?** We can make a pie plot to get informations about that. But before that we must to count all pokemon types from both columns and avoid double counting, because we copied the elements in the *Type 1* column to the *Type 2* column before. **Why we do this?** Because there are pokemon that don't have Type 2.","71f1a4e4":"**Table of Contents**\n1. [Basic Analysis](#1)\n    * [Data Cleaning](#2)\n    * [Frequency](#3)\n    * [The Strongest and The Weakest](#4)\n    * [The Fastest and The Slowest](#5)\n    * [Summary](#6)\n2. [Data Visualisation](#7)\n    * [Count Plot](#8)\n    * [Pie Plot](#9)\n    * [Box Plot and Violin Plot](#10)\n    * [Swarm Flot](#11)\n    * [Heat Map](#12)","3fd6925c":"<a id = \"3\"><\/a>\n### Frequency\nNow, let's see all unique types in *Type 1* and *Type 2*.","5bf6cd39":"_________________________________________________________","fe7fd7cd":"We finally know that our data has 12 columns.\n* *Name*       : Nominal data\n* *Type 1*     : Nominal data\n* *Type 2*     : Nominal data\n* *Total *     : Ratio data\n* *HP *        : Ratio data\n* *Attack*     : Ratio data\n* *Defense*    : Ratio data\n* *Sp Atk*     : Ratio data\n* *Sp Def*     : Ratio data\n* *Speed*      : Ratio data\n* *Generation* : Ordinal data\n* *Legendary*  : Nominal data","f95e51b3":"Take a look at the data. We can conclude that the **Dragon** type pokemon has an advantage over other types because they have a higher attack compared to other types. Let's see the starter pokemon : Fire, Water, and Grass. Fire Pokemons have a higher attack than Water and Grass. So it's very recommended to use it for attacking opponent for every beginner trainer. (If you ever played pokemon, then u can understand what *starter pokemon* is)","806da9a6":"<a id = \"2\"><\/a>\n### Data Cleaning\nI found some unneeded text in *Name* column. For example, \"CharizardMega Charizard X\" should be \"Mega Charizard X\". So we need to remove all characters before \"Mega\".","0d3b7474":"From the heat map above, the correlation between the attributes of the pokemon is not to much. The highest correlation is *Sp. Attack* and *Total*, following *Attack *with *Total *and *Sp. Defense* and *Total*.","8ead0475":"<a id = \"4\"><\/a>\n### The Strongest and The Weakest\n**Who is the strongest and the weakest Pokemons by types?** We will find out."}}