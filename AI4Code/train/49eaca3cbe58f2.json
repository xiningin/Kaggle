{"cell_type":{"41232367":"code","7dac5edf":"code","86ead641":"code","b06f8fe7":"code","69382cc6":"code","532f2e26":"code","f90aef00":"code","f589ded0":"code","ebfc432c":"code","1c1b9a87":"code","e6d015b2":"code","fa9f0994":"code","9cd9b85c":"code","f1f2a795":"code","88674e06":"code","e4ad352a":"code","611a5f1a":"code","b184350a":"code","00f60a84":"code","c52338c8":"code","bc546ddb":"code","7bfc5f69":"code","ba5e778e":"code","3dd53043":"code","e05e62e0":"code","4cbac330":"code","5086a6d8":"code","dfdab376":"markdown"},"source":{"41232367":"!pip install vit-pytorch\n!pip3 install crc32c\n!pip3 install tfrecord","7dac5edf":"import numpy as np\nimport pickle as pkl\nimport time\nfrom random import shuffle\nimport pandas as pd\nimport spectral\nimport matplotlib.pyplot as plt\nimport time\nfrom scipy.io import loadmat\nimport random\nimport torch\n#import seaborn as sns\nfrom collections import Counter\nimport os\nfrom sklearn.decomposition import PCA\nfrom sklearn.model_selection import train_test_split\nfrom torch import nn\nfrom torch.optim import Adam","86ead641":"def seed_everything(seed):\n    \"\"\"\n    Seeds basic parameters for reproductibility of results\n    \n    Arguments:\n        seed {int} -- Number of the seed\n    \"\"\"\n    random.seed(seed)\n    os.environ[\"PYTHONHASHSEED\"] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\n\nseed_everything(100)","b06f8fe7":"def loadData(name):\n    data_path = '..\/input\/'\n    if name == 'IP':\n        data = loadmat(os.path.join(data_path, 'indian-pines\/Indian_pines_corrected.mat'))['indian_pines_corrected']\n        labels = loadmat(os.path.join(data_path, 'indian-pines\/Indian_pines_gt.mat'))['indian_pines_gt']\n    elif name == 'SA':\n        data = loadmat(os.path.join(data_path, 'salinas\/salinas_corrected.mat'))['salinas_corrected']\n        labels = loadmat(os.path.join(data_path, 'salinas\/salinas_gt.mat'))['salinas_gt']\n    elif name == 'PU':\n        data = loadmat(os.path.join(data_path, 'paviau\/paviaU.mat'))['paviaU']\n        labels = loadmat(os.path.join(data_path, 'paviau\/paviaU_gt.mat'))['paviaU_gt']\n    \n    return data, labels","69382cc6":"input_data, input_label = loadData('IP')","532f2e26":"#\u67e5\u770b\u7c7b\u522b\u6570\u91cf\nprint(np.unique(input_label))\nnum_labels = len(np.unique(input_label))-1\nprint(num_labels)","f90aef00":"#\u7edf\u8ba1\u6837\u672c\u7684\u4e2a\u6570\ndict_k = {}\nfor i in range(input_label.shape[0]):\n    for j in range(input_label.shape[1]):\n        #if output_image[i][j] in [m for m in range(1,17)]:\n        if input_label[i][j] in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]:\n            if input_label[i][j] not in dict_k:\n                dict_k[input_label[i][j]]=0\n            dict_k[input_label[i][j]] +=1","f589ded0":"print(dict_k)","ebfc432c":"\nground_truth = spectral.imshow(classes=input_label.astype(int),figsize=(9,9))\nplt.show()","1c1b9a87":"# \u5bf9\u9ad8\u5149\u8c31\u6570\u636e X \u5e94\u7528 PCA \u53d8\u6362\n# def applyPCA(X, numComponents):\n#     newX = np.reshape(X, (-1, X.shape[2]))\n#     pca = PCA(n_components=numComponents, whiten=True)\n#     newX = pca.fit_transform(newX)\n#     newX = np.reshape(newX, (X.shape[0], X.shape[1], numComponents))\n#     return newX\n\ndef padWithZeros(X, margin=2):\n    newX = np.zeros((X.shape[0] + 2 * margin, X.shape[1] + 2* margin, X.shape[2]))\n    x_offset = margin\n    y_offset = margin\n    newX[x_offset:X.shape[0] + x_offset, y_offset:X.shape[1] + y_offset, :] = X\n    return newX\n\ndef createImageCubes(X, y, windowSize=5, removeZeroLabels = True):\n    # \u7ed9 X \u505a padding\n    margin = int((windowSize - 1) \/ 2)\n    zeroPaddedX = padWithZeros(X, margin=margin)\n    # split patches\n    patchesData = np.zeros((X.shape[0] * X.shape[1], windowSize, windowSize, X.shape[2]))\n    patchesLabels = np.zeros((X.shape[0] * X.shape[1]))\n    patchIndex = 0\n    for r in range(margin, zeroPaddedX.shape[0] - margin):\n        for c in range(margin, zeroPaddedX.shape[1] - margin):\n            patch = zeroPaddedX[r - margin:r + margin + 1, c - margin:c + margin + 1]   \n            patchesData[patchIndex, :, :, :] = patch\n            patchesLabels[patchIndex] = y[r-margin, c-margin]\n            patchIndex = patchIndex + 1\n    if removeZeroLabels:\n        patchesData = patchesData[patchesLabels>0,:,:,:]\n        patchesLabels = patchesLabels[patchesLabels>0]\n        patchesLabels -= 1\n    return patchesData, patchesLabels\n\ndef splitTrainTestSet(X, y, testRatio, randomState=345):\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=testRatio, \n                                                        random_state=randomState, stratify=y)\n    return X_train, X_test, y_train, y_test","e6d015b2":"# \u5730\u7269\u7c7b\u522b\nclass_num = num_labels\n\n# \u7528\u4e8e\u6d4b\u8bd5\u6837\u672c\u7684\u6bd4\u4f8b\ntest_ratio = 0.8\n# \u6bcf\u4e2a\u50cf\u7d20\u5468\u56f4\u63d0\u53d6 patch \u7684\u5c3a\u5bf8\npatch_size = 15\n# \u4f7f\u7528 PCA \u964d\u7ef4\uff0c\u5f97\u5230\u4e3b\u6210\u5206\u7684\u6570\u91cf\n# pca_components = 10\n\nprint('Hyperspectral data shape: ', input_data.shape)\nprint('Label shape: ', input_label.shape)\n\n# print('\\n... ... PCA tranformation ... ...')\n# X_pca = applyPCA(input_data, numComponents=pca_components)\n# print('Data shape after PCA: ', X_pca.shape)","fa9f0994":"print('\\n... ... create data cubes ... ...')\nX, y = createImageCubes(input_data, input_label, windowSize=patch_size)\nprint('Data cube X shape: ', X.shape)\nprint('Data cube y shape: ', y.shape)","9cd9b85c":"print('\\n... ... create train & test data ... ...')\nXtrain, Xtest, ytrain, ytest = splitTrainTestSet(X, y, test_ratio)\nprint('Xtrain shape: ', Xtrain.shape)\nprint('Xtest  shape: ', Xtest.shape)","f1f2a795":"\n\n\nprint('\\n... ... create train & test data ... ...')\nXtrain, Xtest, ytrain, ytest = splitTrainTestSet(X, y, test_ratio)\nprint('Xtrain shape: ', Xtrain.shape)\nprint('Xtest  shape: ', Xtest.shape)\n\n\n# \u4e3a\u4e86\u9002\u5e94 pytorch \u7ed3\u6784\uff0c\u6570\u636e\u8981\u505a transpose\nXtrain = Xtrain.transpose(0,  3, 1, 2)\nXtest  = Xtest.transpose(0, 3, 1, 2)\nprint('after transpose: Xtrain shape: ', Xtrain.shape) \nprint('after transpose: Xtest  shape: ', Xtest.shape) \n\n\n\"\"\" Training dataset\"\"\"\nclass TrainDS(torch.utils.data.Dataset): \n    def __init__(self):\n        self.len = Xtrain.shape[0]\n        self.x_data = torch.FloatTensor(Xtrain)\n        self.y_data = torch.LongTensor(ytrain)        \n    def __getitem__(self, index):\n        # \u6839\u636e\u7d22\u5f15\u8fd4\u56de\u6570\u636e\u548c\u5bf9\u5e94\u7684\u6807\u7b7e\n        return self.x_data[index], self.y_data[index]\n    def __len__(self): \n        # \u8fd4\u56de\u6587\u4ef6\u6570\u636e\u7684\u6570\u76ee\n        return self.len\n\n\"\"\" Testing dataset\"\"\"\nclass TestDS(torch.utils.data.Dataset): \n    def __init__(self):\n        self.len = Xtest.shape[0]\n        self.x_data = torch.FloatTensor(Xtest)\n        self.y_data = torch.LongTensor(ytest)\n    def __getitem__(self, index):\n        # \u6839\u636e\u7d22\u5f15\u8fd4\u56de\u6570\u636e\u548c\u5bf9\u5e94\u7684\u6807\u7b7e\n        return self.x_data[index], self.y_data[index]\n    def __len__(self): \n        # \u8fd4\u56de\u6587\u4ef6\u6570\u636e\u7684\u6570\u76ee\n        return self.len\n\n# # \u521b\u5efa trainloader \u548c testloader\ntrainset = TrainDS()\ntestset  = TestDS()\ntrain_loader = torch.utils.data.DataLoader(dataset=trainset, batch_size=10, shuffle=True)\ntest_loader  = torch.utils.data.DataLoader(dataset=testset,  batch_size=128, shuffle=False)\n\n","88674e06":"for i in train_loader:\n    data,target = i\n    print(data.shape)\n    print(target)\n    ","e4ad352a":"from vit_pytorch import ViT\n\nv = ViT(\n    image_size = 15,\n    patch_size = 3,\n    num_classes = num_labels,\n    dim = 1024,\n    depth = 6,\n    heads = 16,\n    channels = X.shape[3],\n    mlp_dim = 1024,\n    dropout = 0.2,\n    emb_dropout = 0.1\n)","611a5f1a":"device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\nmodel = v.to(device)\ncriterion = nn.CrossEntropyLoss()\noptimizer = Adam(model.parameters(), lr=0.0001)\n\n\ndef train(epoch):\n    running_loss = 0.\n    total = 0\n    correct = 0\n    time_s = time.time()\n    for batch_idx, data in enumerate(train_loader, 0):\n\n        inputs,target = data\n        inputs = inputs.to(device)\n        target = target.to(device)\n        optimizer.zero_grad()\n\n        y_pre = model(inputs)\n        _, predict = torch.max(y_pre.data, dim=1)\n        total += target.size(0)\n        correct += (predict == target).cpu().sum().item()\n        loss = criterion(y_pre, target)\n        loss.backward()\n        optimizer.step()\n        \n\n        running_loss += loss.item()\n        \n \n        if batch_idx % 10 == 9:\n            time_e = time.time()\n\n            times = time_e - time_s\n            print('\u7b2c{}\u6b21\u5468\u671f\u7684\u7b2c{}\u6b21\u635f\u5931\uff1a{}\uff0c\u5171\u8017\u65f6\uff1a{}s,\u51c6\u786e\u7387\u4e3a\uff1a{:.2f}'.format(epoch + 1, batch_idx + 1, running_loss \/ 10, times,\n                                                    100 * correct \/ total))            \n                      \n            running_loss = 0.0\n            \n\ndef valid():\n    total = 0\n    correct = 0\n    \n    with torch.no_grad():\n        for data in test_loader:\n            inputs,labels = data\n            inputs = inputs.to(device)\n            labels = labels.to(device)\n            y_pre = model(inputs)\n            _, predict = torch.max(y_pre.data, dim=1)\n            total += labels.size(0)\n            correct += (predict == labels).cpu().sum().item()\n\n\n        print('\u6d4b\u8bd5\u96c6\u51c6\u786e\u7387\uff1a{}'.format(100 * correct \/ total))\n\n","b184350a":"for j in range(10):\n    for i in range(100):\n        train(i)\n    valid()\n","00f60a84":"# X_pca = X.transpose(0, 3, 1, 2)\n\n# \"\"\" Training dataset\"\"\"\n# class AllData(torch.utils.data.Dataset): \n#     def __init__(self):\n#         self.len = X_pca.shape[0]\n#         self.x_data = torch.FloatTensor(X_pca)\n#         self.y_data = torch.LongTensor(y)        \n#     def __getitem__(self, index):\n#         # \u6839\u636e\u7d22\u5f15\u8fd4\u56de\u6570\u636e\u548c\u5bf9\u5e94\u7684\u6807\u7b7e\n#         return self.x_data[index], self.y_data[index]\n#     def __len__(self): \n#         # \u8fd4\u56de\u6587\u4ef6\u6570\u636e\u7684\u6570\u76ee\n#         return self.len\n    \n\n# all_data = AllData()\n# data_loader = torch.utils.data.DataLoader(dataset=all_data, batch_size=64, shuffle=False)\n\n","c52338c8":"# for i in data_loader:\n#     data,target = i\n#     print(data.shape)\n#     break","bc546ddb":"# y_pred = []\n# with torch.no_grad():\n#     for data in data_loader:\n#         inputs,labels = data\n#         inputs = inputs.to(device)\n#         y_pre = model(inputs)\n#         _, predict = torch.max(y_pre.data, dim=1)\n# #         print(predict)\n#         y_pred.append(predict)\n# #y_pred","7bfc5f69":"# len(y_pred)","ba5e778e":"# y_predict = []\n\n# for i in range(len(y_pred)):\n#     for j in range(len(y_pred[i])):\n#         y_predict.append(y_pred[i][j].item())\n        \n# #print(y_predict)\n        ","3dd53043":"len(y_predict)","e05e62e0":"#y_predict[0]","4cbac330":"# outputs = np.zeros((input_label.shape[0],input_label.shape[1]))\n\n# for i in range(input_label.shape[0]):\n#     for j in range(input_label.shape[1]):\n#         if int(input_label[i,j]) == 0:\n#             continue\n#         else :\n#             outputs[i,j] = y_predict[0]+1\n#             del(y_predict[0])","5086a6d8":"# ground_truth = spectral.imshow(classes = input_label.astype(int),figsize =(9,9))\n# ground_predict = spectral.imshow(classes = outputs.astype(int), figsize =(9,9))\n# plt.show()","dfdab376":"# \u753b\u9884\u6d4b\u56fe"}}