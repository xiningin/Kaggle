{"cell_type":{"79f32720":"code","9d2f8bc2":"code","2cac8f99":"code","41b1b40f":"code","2cf877bd":"code","c55477d3":"code","c44d7d0e":"code","1914e63c":"code","dedc9c12":"code","dde66378":"code","bbca42c2":"code","1fa7e9c7":"code","ea96d2f7":"code","0522cf3a":"code","708b92d3":"code","a27913c4":"code","d323a989":"code","d37c261c":"code","bc8ca5e3":"code","d42fc1f7":"code","215f5a74":"code","2e89add4":"code","81d51f92":"code","029cdaa8":"code","e3f03bb1":"code","95524a8c":"code","c9122b3b":"code","e6893abb":"code","190617f1":"code","a6f0f73f":"markdown","81d7d985":"markdown","6b0f6591":"markdown","8fa82b9a":"markdown","4b032a1b":"markdown","68774dc5":"markdown","0bb70b6c":"markdown","6d476cdb":"markdown","3e7ad04f":"markdown","1039c4fc":"markdown","ecd12b43":"markdown","de2a708e":"markdown","c365e459":"markdown","858a855e":"markdown","11e7a45a":"markdown","d6a0fa6c":"markdown","bb21aca2":"markdown","29e313d7":"markdown","54481362":"markdown","52909c94":"markdown","1d44482f":"markdown","46274408":"markdown","644a8242":"markdown"},"source":{"79f32720":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport os\nprint(os.listdir(\"..\/input\"))","9d2f8bc2":"apps = pd.read_csv(\"..\/input\/googleplaystore.csv\")","2cac8f99":"apps.info()","41b1b40f":"apps.head()","2cf877bd":"apps.Rating.value_counts()","c55477d3":"apps[apps.Rating == 19.0]","c44d7d0e":"apps = apps.drop(apps.index[10472])\napps.iloc[10471:10475]","1914e63c":"apps = apps.dropna()","dedc9c12":"apps.Category.nunique()","dde66378":"apps.Category.unique()","bbca42c2":"category_list = list(apps.Category.unique())\nratings = []\n\nfor category in category_list:\n    x = apps[apps.Category == category]\n    rating_rate = x.Rating.sum()\/len(x)\n    ratings.append(rating_rate)\ndata = pd.DataFrame({'Category':category_list, 'Rating':ratings})\nnew_index = (data['Rating'].sort_values(ascending=False)).index.values\nsorted_data = data.reindex(new_index)\n\nsorted_data","1fa7e9c7":"plt.figure(figsize=(25,15))\nsns.barplot(x=sorted_data.Category, y=sorted_data.Rating)\n\nplt.xticks(rotation = 45)\nplt.xlabel('Application Category')\nplt.ylabel('Ratings')\nplt.title('Average Ratings by Category')\nplt.show()","ea96d2f7":"apps[\"Content Rating\"].unique()","0522cf3a":"# list of categories\ncat_list = list(apps.Category.unique())\n\n# content rating lists\neveryone = []\nteen = []\neveryone_10 = []\nmature_17 = []\nadults_only_18 = []\nunrated = []\n\n# the function which fills category's (temp) content rating counts into lists\ndef insert_counts(everyone, teen, everyone_10, mature_17, adults_only_18, unrated, temp):\n    \n    # everyone\n    try:\n        everyone.append(temp.groupby('Content Rating').size()['Everyone'])\n    except:\n        everyone.append(0)\n    \n    # teen\n    try:\n        teen.append(temp.groupby('Content Rating').size()['Teen'])\n    except:\n        teen.append(0)\n    \n    # everyone 10+\n    try:\n        everyone_10.append(temp.groupby('Content Rating').size()['Everyone 10+'])\n    except:\n        everyone_10.append(0)\n        \n    # mature 17+\n    try:\n        mature_17.append(temp.groupby('Content Rating').size()['Mature 17+'])\n    except:\n        mature_17.append(0)\n        \n    # adults only 18+\n    try:\n        adults_only_18.append(temp.groupby('Content Rating').size()['Adults only 18+'])\n    except:\n        adults_only_18.append(0)\n        \n    # unrated\n    try:\n        unrated.append(temp.groupby('Content Rating').size()['Unrated'])\n    except:\n        unrated.append(0)\n\n# fill lists iteratively via function\nfor cat in cat_list:\n    temp = apps[apps.Category == cat]\n    insert_counts(everyone, teen, everyone_10, mature_17, adults_only_18, unrated, temp)\n    ","708b92d3":"f,ax = plt.subplots(figsize = (25,25))\nsns.barplot(x=everyone,y=cat_list,color='green',alpha = 0.5,label='Everyone')\nsns.barplot(x=teen,y=cat_list,color='blue',alpha = 0.7,label='Teen')\nsns.barplot(x=everyone_10,y=cat_list,color='pink',alpha = 0.6,label='Everyone 10+')\nsns.barplot(x=mature_17,y=cat_list,color='yellow',alpha = 0.6,label='Mature 17+')\nsns.barplot(x=adults_only_18,y=cat_list,color='red',alpha = 0.6,label='Adults Only 18+')\nsns.barplot(x=unrated,y=cat_list,color='aqua',alpha = 0.6,label='Unrated')\n\nax.legend(loc='lower right',frameon = True)\nax.set(xlabel='Percentage of Content Ratings', ylabel='Categories',title = \"Percentage of Categories According to Content Ratings \")","a27913c4":"plt.figure(figsize = (10,8))\nsns.countplot(apps['Content Rating'])\nplt.show()","d323a989":"plt.figure(figsize = (15,15))\nplt.pie(everyone, labels = cat_list, autopct = '%.1f%%', rotatelabels = True, startangle = -90.0)\nplt.title('Distribution of the Everyone Content across Categories')\n\nplt.show()","d37c261c":"plt.figure(figsize = (15,15))\nplt.pie(mature_17, labels = cat_list, autopct = '%.1f%%', rotatelabels = True)\nplt.title('Distribution of the Mature 17+ Content across Categories')\nplt.show()","bc8ca5e3":"apps2 = apps\napps2['Android Ver'].value_counts()","d42fc1f7":"apps2['Android Ver'][apps2['Android Ver'] == 'Varies with device'] = '4.1 and up'\n\napps2['android_ver_int'] = apps2['Android Ver'].str[0:1].astype(int)\n\napps2['android_ver_int'].value_counts()","215f5a74":"new_index2 = (apps2['android_ver_int'].sort_values(ascending=False)).index.values\nsorted_apps2 = apps2.reindex(new_index2)\n\nsorted_apps2.head(7)","2e89add4":"f,ax = plt.subplots(figsize = (5,5))\nsns.heatmap(sorted_apps2.corr(), annot = True, fmt = '.2f', ax = ax)\nplt.show()","81d51f92":"new_df = apps2.groupby('Category').mean()\nnew_df.sort_values('Rating', inplace = True)\n\nnew_df.head()","029cdaa8":"new_df['Category'] = new_df.index","e3f03bb1":"f,ax2 = plt.subplots(figsize =(20,10))\nsns.pointplot(x='Category',y='android_ver_int',data=new_df,color='magenta',alpha=0.8)\nsns.pointplot(x='Category',y='Rating',data=new_df,color='aqua',alpha=0.8)\nplt.text(x = 18, y = 4.3, s = 'Average Rating', color = 'aqua', fontsize = 17,style = 'italic')\nplt.text(x = 18, y = 3.46, s = 'Average Min Supported Android Ver', color='magenta',fontsize = 18,style = 'italic')\nplt.xlabel('Categories', fontsize = 15, color = 'black')\nplt.ylabel('Ratings', fontsize = 15, color = 'black')\nplt.xticks(rotation = 75)\nplt.show()","95524a8c":"g = sns.jointplot(new_df['android_ver_int'], new_df['Rating'], kind=\"kde\", height=7, color='aqua')\nplt.savefig('graph.png')\nplt.show()","c9122b3b":"apps['Reviews_int'] = apps.Reviews.astype(int)","e6893abb":"f,ax = plt.subplots(figsize = (5,5))\nsns.heatmap(apps.corr(), annot = True, fmt = '.2f', ax = ax)\nplt.show()","190617f1":"#Content Rating\n#Type\n#Rating\n\nplt.figure(figsize = (12,7))\nsns.boxplot(x='Content Rating', y='Rating', hue='Type', data=apps, palette='PRGn')\nplt.show()","a6f0f73f":"One can easily observe that nearly all the applications are targeting 'Everyone', excepting 'Dating' applications.  \n\nBut I want to dive deeper via seaborn's **countplot** and **pieplot**.","81d7d985":"We can come with something like \"people are tend to vote higher when they pay for it\".\n\nAnd also there is no paid applications for adults only (18+) content rating.","6b0f6591":"Enrty looks messy. Let's try to guess how it should have been:\n\n\n**Category:** NaN  \n**Rating:** 1.9  \n**Reviews:** 1,000+  \n**Size:** 3.0M  \n**Installs:** 19  \n**Type:** Free  \n**Price:** 0  \n**Content Rating:** Everyone  \n**Genres:** NaN  \n**Last Updated:** February 11, 2018  \n**Current Ver:** 1.0.19  \n**Android Ver:** 4.0 and up  \n\n\nIt still has NaN attributes, which means this guy cannot be mended. Remove it!","8fa82b9a":"The correlation of reviews and ratings are as weak as the correlation of android version.  \n\nThere is another feature called `Type`, indicating whether the application is free or paid. Including the content rating, let's examine the effects of them on rating, by using seaborn's **boxplot**.","4b032a1b":"We can say these two features are irrelevant. Using seaborn's **jointplot** may help us to see where most of the data stay.","68774dc5":"Before stepping into visualizations, we have to check what kind of distribution the `Rating` feature has.","0bb70b6c":"Now let's keep them in a distinct dataframe, sorted by their `Android Ver`.","6d476cdb":"## Conclusions\n\n* Ratings change slightly as category of the application changes.\n* Almost all the applications are targeting 'Everyone', excepting 'Dating' applications.\n* There is a weak correlation between *minimum supported android version* and *ratings*.\n* The correlation of reviews and ratings are as weak as the correlation of android version.\n* People are tend to vote higher when they pay for it.\n* There is no paid applications for adults only (18+) content rating.\n","3e7ad04f":"As we can see, there is a weak correlation between *minimum supported android version* and *ratings*.  \n\nTo have a clearer sight on correlation, let's try plotting them on the same graph, with grouping by categories (via seaborn's **pointplot**).","1039c4fc":"As it seems, ratings change slightly as category of the application changes.  \n\nWe have another feature named *content rating*, which is the age group the app is targeted at. I wonder how it distributes over the categories, so I will be using seaborn's **horizontal barplot** to visualize it.  \n\nLet's see what are the `Content Ratings` that we have to deal with.","ecd12b43":"Firstly fetch the dataset into `apps` variable.","de2a708e":"I will be creating lists for each content rating types, and fill them with the count of categories they encompass.","c365e459":"We will be using seaborn's boxplot to visualize the correlation. As we bind x-axis as applications grouped by their categories, and y-axis as average ratings of the categories; then we'll be able to see clearly whether there is a strong relation between the category of application and its rating or not.  \n\nTo do so, I created a dataframe which consist of two features (*lists*):  \n`Category` : Name of categories (`category_list`)  \n`Rating` : Average ratings of each categories (`ratings`)","858a855e":"And then take a look what do we have in it.","11e7a45a":"I wonder if there is a strong relation between the category of application and its rating. But first things first.  \n### *How many categories are there, and what are them?*","d6a0fa6c":"# Visualizing Google Play Store Apps via Seaborn\n\nHere in this kernel, we will be visualizing the Google Play Store Apps dataset via **seaborn** library. Then we will be able to make some conclusions.\n","bb21aca2":"Now I wonder whether there is a correlation between the minimum supported Android version of the applications and the ratings of them.  \n\nBut we know that our `Android Ver` feature is object-type (string), so we have to cast it to a numerical type; but first let's check if there is any inconvenient type for this kind of conversion.","29e313d7":"Now I want to test the effect of `Reviews` feature on ratings. Again, we need to cast its type to integer, and add it as a new feature.","54481362":"Take a look at the first five samples of the dataset, by using `apps.head()` method:","52909c94":"We know there are bunch of entries like this, so we have to get rif of dirty data for the sake of visualization.","1d44482f":"Ranging from 1.2 to 4.4, most of them are high ratings. But there is an awkward value (`19.0`), which has to be manipulated. See how data looks like:","46274408":"1319 of the entries' Android versions are marked as `Varies with device`. Since most of the applications are supporting `4.1 and up`, I want to assume these guys are `4.1 and up` too.","644a8242":"One column (`rating`) is float and the rest of columns consist of string objects, 13 attributes as total. At the first glance, we can see there are some kind of features that are expected to be numeric values (reviews, installs etc.), but they are structured as string type.  To understand the metadata, we have to look at the brief definitions of the features:\n\n\n**App:** Application name  \n**Category:** Category the app belongs to  \n**Rating:** Overall user rating of the app (as when scraped)  \n**Reviews:** Number of user reviews for the app (as when scraped)  \n**Size:** Size of the app (as when scraped)  \n**Installs:** Number of user downloads\/installs for the app (as when scraped)  \n**Type:** Paid or Free  \n**Price:** Price of the app (as when scraped)  \n**Content Rating:** Age group the app is targeted at - Children \/ Mature 21+ \/ Adult  \n**Genres:** An app can belong to multiple genres (apart from its main category). For eg, a musical family game will belong to Music, Game, Family genres.  \n**Last Updated:** Date when the app was last updated on Play Store (as when scraped)  \n**Current Ver:** Current version of the app available on Play Store (as when scraped)  \n**Android Ver:** Min required Android version (as when scraped)  "}}