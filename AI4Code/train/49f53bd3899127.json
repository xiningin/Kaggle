{"cell_type":{"6629cd1d":"code","0cdb7f12":"code","841b0f94":"code","25b53abf":"code","dba42bd9":"code","a3a98dfc":"code","0d1bd7fa":"code","ed57c117":"code","517b3c21":"code","852cafae":"code","a8203ecd":"code","88c075b6":"code","9e2c191e":"code","bfda4378":"code","52e0f37a":"code","b27d50cf":"code","9dfb90b1":"code","f85f22a4":"code","d6e43975":"code","6bbde443":"code","850b5541":"code","7382c44f":"code","508e2b27":"code","d19f7acd":"code","2647a47b":"code","3a1f9d50":"code","30414d8a":"code","19879014":"code","7d679235":"code","c4613e79":"code","226b3891":"code","c14cec9a":"code","38294872":"code","2ac89074":"code","572d46f8":"code","2356cdd4":"code","a91191ab":"code","95c28c3c":"code","e478f3c9":"code","4b95d0f9":"code","4966d207":"code","c03f1e28":"code","e1debdf2":"code","e97137d6":"code","aae32b94":"code","c3cd3a2e":"code","110c4858":"code","8e31233d":"code","84d75e25":"code","14fb94a0":"code","b1ba83f4":"code","905341d6":"code","a5289f91":"code","cb914d56":"code","05634b5e":"code","b5fe78e6":"code","9ad31fab":"code","ed4557fb":"code","20c2a859":"code","4d2c8714":"code","f259adb0":"code","c26a981a":"markdown","36b3f1d4":"markdown","4957bedc":"markdown","be96fd09":"markdown","c8993151":"markdown","775c5a05":"markdown","594656eb":"markdown","3cd94e95":"markdown","108b17dd":"markdown","5b8ed175":"markdown","509ac9ac":"markdown","5c66aac5":"markdown","57d6e347":"markdown","9881f93f":"markdown","5b4ab855":"markdown","3f661f4a":"markdown","9a2482a5":"markdown"},"source":{"6629cd1d":"!pip install --upgrade seaborn","0cdb7f12":"import numpy as np, pandas as pd\nfrom glob import glob\nimport shutil, os\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import GroupKFold\nfrom tqdm.notebook import tqdm\nimport seaborn as sns","841b0f94":"dim = 1024 #512, 256, 'original'\nfold = 4","25b53abf":"train_df = pd.read_csv(f'..\/input\/vinbigdata-{dim}-image-dataset\/vinbigdata\/train.csv')\n# train_df = pd.read_csv(f'..\/input\/vinbigdata-512-image-dataset\/vinbigdata\/train.csv')\n\ntrain_df.head()","dba42bd9":"train_df['image_path'] = f'\/kaggle\/input\/vinbigdata-{dim}-image-dataset\/vinbigdata\/train\/'+train_df.image_id+('.png' if dim!='original' else '.jpg')\ntrain_df.head()","a3a98dfc":"train_df.iloc[2423][\"image_path\"]","0d1bd7fa":"without_mass=train_df[train_df.class_id!=8]\n\nwithout_mass_files   = []\nwithout_mass_files += list(without_mass.image_path.unique())\n\nmass_files=train_df[train_df.class_id==8]['image_path'].unique()\nmass_df=train_df[train_df.class_id==8]","ed57c117":"without_mass_files[0]","517b3c21":"import random\n \nprint(random.randint(0,9))","852cafae":"print(random.uniform(1,5))","a8203ecd":"import random\n \nprint(random.randint(0,9))\n\nrandom.uniform(1.1,5.4)\n\nrandom.random()","88c075b6":"os.makedirs('\/kaggle\/working\/vinbigdata\/labels\/train', exist_ok = True)\nos.makedirs('\/kaggle\/working\/vinbigdata\/labels\/val', exist_ok = True)\nos.makedirs('\/kaggle\/working\/vinbigdata\/images\/train', exist_ok = True)\nos.makedirs('\/kaggle\/working\/vinbigdata\/images\/val', exist_ok = True)","9e2c191e":"def normalized_text_create(desktop_path,name, boxes,box_labels):\n    #x_min.y_min,x_max,y_max--->x,y,w,h,normalized\n        \n    full_path = os.path.join(desktop_path, name+'.txt')  # \u4e5f\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a.doc\u7684word\u6587\u6863\n    print('full_path',full_path)\n    file = open(full_path, 'w')\n    \n    if(len(boxes)==0):\n        file.close()\n    else:\n        for i in range(len(boxes)):\n    #         file.write(str(box_labels[i])+ ' '+ str(x)+ ' '+ str(y)+ ' '+ str(w)+ ' '+ str(h)+ ' '+ '\\n') \n            file.write(str(box_labels[i])+ ' '+ str(boxes[i][0])+ ' '+ str(boxes[i][1])+ ' '+ str(boxes[i][2])+ ' '+ str(boxes[i][3])+ ' '+ '\\n')\n            print('\u5f55\u5165'+str(box_labels[i])+ ' '+ str(boxes[i][0])+ ' '+ str(boxes[i][1])+ ' '+ str(boxes[i][2])+ ' '+ str(boxes[i][3])+ ' ')\n        file.close()","bfda4378":"%matplotlib inline\nimport random\nimport matplotlib.pyplot as plt\nimport math\n# from PIL import Image\n\nimport PIL.Image as img\ncount=2000\nfor file in tqdm(without_mass_files):\n    count-=1\n    if count==0:\n        break\n#     IMG = r'F:\\PY\\github\\copy-paste-aug-main\\u=3785402047,1898752523&fm=193&f=GIF.jpg'  # \u56fe\u7247\u5730\u5740\n    IMG = file\n    im = img.open(IMG)  # \u7528PIL\u6253\u5f00\u4e00\u4e2a\u56fe\u7247\n    \n    plt.imshow(im)\n    plt.axis('on') # \u5173\u6389\u5750\u6807\u8f74\u4e3a off\n    plt.title('\u539f\u56fe'+file) # \u56fe\u50cf\u9898\u76ee\n    plt.show()\n    \n    # \u968f\u673a\u8865\u4e01\u7684\u4e2a\u6570\n    num_patch=random.randint(1,30)\n    \n    patch_group=[]\n    \n    for i in range(num_patch):\n        col_patch=random.randint(0,mass_files.shape[0])\n        \n        x_min=mass_df.iloc[col_patch][\"x_min\"]*(dim\/(1.0*mass_df.iloc[col_patch][\"width\"]))\n        x_max=mass_df.iloc[col_patch][\"x_max\"]*(dim\/(1.0*mass_df.iloc[col_patch][\"width\"]))\n        y_min=mass_df.iloc[col_patch][\"y_min\"]*(dim\/(1.0*mass_df.iloc[col_patch][\"height\"]))\n        y_max=mass_df.iloc[col_patch][\"y_max\"]*(dim\/(1.0*mass_df.iloc[col_patch][\"height\"]))\n        box = (x_min, y_min, x_max, y_max)\n        print('box',box)\n\n        #box\u4ee3\u8868\u9700\u8981\u526a\u5207\u56fe\u7247\u7684\u4f4d\u7f6e\u683c\u5f0f\u4e3a:xmin ymin xmax ymax\n\n        mass_img=img.open(mass_df.iloc[col_patch][\"image_path\"])\n        print('mass_img.size',mass_img.size)\n        patch=mass_img.crop(box)\n        print('cut_patch.size',patch.size)\n        oper_rotate=random.uniform(1,6)\n        \n        if oper_rotate<2:\n            patch=patch.transpose(img.FLIP_LEFT_RIGHT)\n        elif oper_rotate<3:\n            patch=patch.transpose(img.FLIP_TOP_BOTTOM)\n        elif oper_rotate<4:\n            patch=patch.transpose(img.ROTATE_90)\n        elif oper_rotate<5:\n            patch=patch.transpose(img.ROTATE_180)\n        elif oper_rotate<6:\n            patch=patch.transpose(img.ROTATE_270)\n        \n        \n        oper_extend=random.uniform(0.8,1.2)\n#         print('patch.size',patch.size)\n#         print('int(patch.size[0]*oper_extend)',int(patch.size[0]*oper_extend))\n#         print('int(patch.size[1]*oper_extend)',int(patch.size[1]*oper_extend))\n        patch=patch.resize((int(patch.size[0]*oper_extend), int(patch.size[1]*oper_extend)))\n        \n        print('\u8c03\u6574\u524d\u8865\u4e01\u5927\u5c0f\u662f:'+str(patch.size))\n#         patch=patch.resize((int(patch.size[0]*(dim\/(1.0*mass_df.iloc[col_patch][\"width\"]))), int(patch.size[1]*(dim\/(1.0*mass_df.iloc[col_patch][\"height\"]))) ) )\n#         patch=patch.resize((int(patch.size[0]*(dim\/(1.0*im.size[0]))), int(patch.size[1]*(dim\/im.size[1])) ) )\n\n        patch_group.append(patch)\n        print(\"\")\n        \n    print('patch\u5757\u6570\uff1a'+str(len(patch_group)))\n    \n    filename = file.split('\/')[-1].split('.')[0]\n    boxes=[]\n    box_labels=[]\n    for i in range(len(patch_group)):\n        \n        \n#         print('patch_group[i]',patch_group[i].size[0])\n#         print('im.size[0]-patch_group[i].size[0]',im.size[0]-patch_group[i].size[0])\n#         print('patch_group[i]',patch_group[i].size[1])\n#         print('im.size[0]-patch_group[i].size[0]',im.size[1]-patch_group[i].size[1])\n        width_min=min(patch_group[i].size[0],im.size[0]-patch_group[i].size[0])\n        width_max=max(patch_group[i].size[0],im.size[0]-patch_group[i].size[0])\n        width_range=random.randint(width_min,width_max)\n        \n        height_min=min(patch_group[i].size[1],im.size[1]-patch_group[i].size[1])\n        height_max=max(patch_group[i].size[1],im.size[1]-patch_group[i].size[1])\n        height_range=random.randint(height_min,height_max)\n        \n#         print('width_range',width_range)\n#         print('height_range',height_range)\n        im_add=im.copy()\n        im.paste(patch_group[i], (width_range,height_range)) \n        \n        box_labels.append(0)\n        \n        boxes.append([width_range\/(1.0*dim),height_range\/(1.0*dim),(patch_group[i].size[0])\/(1.0*dim),(patch_group[i].size[1])\/(1.0*dim)])\n        normalized_text_create('\/kaggle\/working\/vinbigdata\/labels\/train','patched'+filename,boxes,box_labels)\n        im=img.blend(im, im_add, 0.2)#im*(1-a)+im_add*a\n    \n    \n    \n    print(\"\u56fe\u7ed3\u675f\")\n    print('\u8865\u4e01\u56fe'+file)\n    plt.title('\u8865\u4e01\u56fe'+file) # \u56fe\u50cf\u9898\u76ee\n    plt.axis('on') # \u5173\u6389\u5750\u6807\u8f74\u4e3a off\n    plt.imshow(im)\n    plt.show()\n    \n    im.save('\/kaggle\/working\/vinbigdata\/images\/train\/patched'+filename+'.png')\n    \n    \n    print(\"\")\n    print(\"\")","52e0f37a":"####","b27d50cf":"# import os\n# import time\n# import random\n# import pydicom \n# import cv2\n# import numpy as np\n# import pandas as pd\n# from glob import glob\n# import matplotlib.pyplot as plt\n# from random import randint\n# from pydicom.pixel_data_handlers.util import apply_voi_lut","9dfb90b1":"# train_dir = \"..\/input\/vinbigdata-chest-xray-abnormalities-detection\/train\"\n# test_dir = \"..\/input\/vinbigdata-chest-xray-abnormalities-detection\/test\"\n\n# train_files = os.listdir(train_dir)\n# test_files = os.listdir(test_dir)\n\n# train_df = pd.read_csv(\"..\/input\/vinbigdata-chest-xray-abnormalities-detection\/train.csv\")","f85f22a4":"# def get_bbox_area(row):\n#     return (row['x_max']-row['x_min'])*(row['y_max']-row['y_min'])\n\n\n# new_df = train_df[train_df['class_name'] != 'No finding']\n# new_df['bbox_area'] = new_df.apply(get_bbox_area, axis=1)\n# new_df.head()\n# new_df=new_df[train_df['class_name'] == 'Nodule\/Mass']","d6e43975":"# def dicom_to_np(path, voi_lut = True, fix_monochrome = True):\n#     dicom = pydicom.read_file(path)\n    \n#     # VOI LUT (if available by DICOM device) is used to transform raw DICOM data to \"human-friendly\" view\n#     if voi_lut:\n#         data = apply_voi_lut(dicom.pixel_array, dicom)\n#     else:\n#         data = dicom.pixel_array\n               \n#     # depending on this value, X-ray may look inverted - fix that:\n#     if fix_monochrome and dicom.PhotometricInterpretation == \"MONOCHROME1\":\n#         data = np.amax(data) - data\n        \n#     data = data - np.min(data)\n#     data = data \/ np.max(data)\n#     data = (data * 255).astype(np.uint8)\n        \n#     return data","6bbde443":"# imgs = []\n# ids = []\n# img_ids = new_df['image_id'].values\n# class_ids = new_df['class_id'].unique()\n\n# label_to_color = {class_id:[randint(0,255) for i in range(3)] for class_id in class_ids}\n# thickness = 3\n# scale = 2\n\n\n# img_id = '2ad18a594cbaf3c6d6145a7775829554'\n# img_path = f'{train_dir}\/{img_id}.dicom'\n# img = dicom_to_np(path=img_path)\n# img = cv2.resize(img, None, fx=1\/scale, fy=1\/scale)\n# img = np.stack([img, img, img], axis=-1)\n\n# boxes = new_df.loc[new_df['image_id'] == img_id, ['x_min', 'y_min', 'x_max', 'y_max']].values\/scale\n# labels = new_df.loc[new_df['image_id'] == img_id, ['class_id']].values.squeeze()\n\n# for label_id, box in zip(labels, boxes):\n#     color = label_to_color[label_id]\n#     img = cv2.rectangle(\n#         img,\n#         (int(box[0]), int(box[1])),\n#         (int(box[2]), int(box[3])),\n#         color, thickness\n# )\n# img = cv2.resize(img, (500,500))\n# imgs.append(img)\n# ids.append(label_id)","850b5541":"# show_bbox(imgs, ids)","7382c44f":"# def show_bbox(img_ids, img_classes):\n#     plt.figure(figsize=(16, 12))\n    \n#     for i, (img, img_class) in enumerate(zip(img_ids, img_classes)):\n#         plt.subplot(2, 3, i + 1)\n#         img = cv2.resize(img, (500,500))\n#         plt.imshow(img, cmap='gray')\n#         plt.title(f\"Class: {img_class}\", fontsize=15)\n#         plt.axis(\"off\")\n    \n#     plt.show()","508e2b27":"####","d19f7acd":"train_df = train_df[train_df.class_id==8].reset_index(drop = True)","2647a47b":"!pip install ensemble_boxes","3a1f9d50":"gkf  = GroupKFold(n_splits = 5)\ntrain_df['fold'] = -1\nfor fold, (train_idx, val_idx) in enumerate(gkf.split(train_df, groups = train_df.image_id.tolist())):\n    train_df.loc[val_idx, 'fold'] = fold\ntrain_df.head()","30414d8a":"train_files = []\nval_files   = []\nval_files += list(train_df[train_df.fold==fold].image_path.unique())\ntrain_files += list(train_df[train_df.fold!=fold].image_path.unique())\nlen(train_files), len(val_files)","19879014":"# os.makedirs('\/kaggle\/working\/vinbigdata\/labels\/train', exist_ok = True)\n# os.makedirs('\/kaggle\/working\/vinbigdata\/labels\/val', exist_ok = True)\n# os.makedirs('\/kaggle\/working\/vinbigdata\/images\/train', exist_ok = True)\n# os.makedirs('\/kaggle\/working\/vinbigdata\/images\/val', exist_ok = True)\n# label_dir = '\/kaggle\/input\/vinbigdata-yolo-labels-dataset\/labels'","7d679235":"import os.path as osp\nfrom path import Path\nfrom collections import Counter\nimport cv2\nfrom ensemble_boxes import *","c4613e79":"imagepaths = train_df['image_path'].unique()\ntrain_annotations=train_df","226b3891":"train_annotations['area']=((train_annotations['x_max']-train_annotations['x_min'])\/train_annotations['width'])*((train_annotations['y_max']-train_annotations['y_min'])\/train_annotations['height'])","c14cec9a":"# img_array  = cv2.imread('\/kaggle\/input\/vinbigdata-512-image-dataset\/vinbigdata\/train\/d3637a1935a905b3c326af31389cb846.png')","38294872":"# def Create_nms_box_txt(desktop_path,name):\n#     iou_thr = 0.5\n#     skip_box_thr = 0.0001\n#     viz_images = []\n# #     image_basename = Path(path).stem\n#     image_basename = name\n# #     print(f\"(\\'{image_basename}\\', \\'{path}\\')\")\n#     img_annotations = train_annotations[train_annotations.image_id==image_basename][train_annotations.class_id==8]\n\n#     boxes_viz = img_annotations[['x_min', 'y_min', 'x_max', 'y_max']].to_numpy().tolist()\n#     labels_viz = img_annotations['class_id'].to_numpy().tolist()\n\n#     print(\"Bboxes before nms:\\n\", boxes_viz)\n#     print(\"Labels before nms:\\n\", labels_viz)\n\n#     boxes_list = []\n#     scores_list = []\n#     labels_list = []\n#     weights = []\n\n#     boxes_single = []\n#     labels_single = []\n\n#     cls_ids = img_annotations['class_id'].unique().tolist()\n#     count_dict = Counter(img_annotations['class_id'].tolist())\n#     print(count_dict)\n\n#     for cid in cls_ids:       \n#         ## Performing Fusing operation only for multiple bboxes with the same label\n#         if count_dict[cid]==1:\n#             labels_single.append(cid)\n#             boxes_single.append(img_annotations[img_annotations.class_id==cid][['x_min', 'y_min', 'x_max', 'y_max']].to_numpy().squeeze().tolist())\n\n#         else:\n#             cls_list =img_annotations[img_annotations.class_id==cid]['class_id'].tolist()\n#             labels_list.append(cls_list)\n#             bbox = img_annotations[img_annotations.class_id==cid][['x_min', 'y_min', 'x_max', 'y_max']].to_numpy()\n\n#             ## Normalizing Bbox by Image Width and Height\n#             bbox = bbox\/(img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"], img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"])\n\n\n#             bbox = np.clip(bbox, 0, 1)\n#             boxes_list.append(bbox.tolist())\n\n#             scores_list.append(np.ones(len(cls_list)).tolist())\n\n#             weights.append(1)\n\n            \n#     # Perform NMS\n#     if len(boxes_list)==0:\n#         boxes=boxes_single\n#         box_labels=labels_single\n#         print(\"Bboxes after nms:\\n\", boxes)\n#         print(\"Labels after nms:\\n\", box_labels)\n        \n#         count_dict = Counter(box_labels)\n#         print(count_dict)\n\n#         text_create(desktop_path,image_basename,boxes,box_labels,img_annotations.iloc[0][\"width\"],img_annotations.iloc[0][\"height\"])\n        \n#     else:\n#         boxes, scores, box_labels = nms(boxes_list, scores_list, labels_list, weights=weights,\n#                                     iou_thr=iou_thr)\n\n\n#         #img_array.shape[1]\u662f\u5bbd\u5ea6\n#         boxes = boxes*(img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"], img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"])\n#         boxes = boxes.round(1).tolist()\n#         box_labels = box_labels.astype(int).tolist()\n\n#         boxes.extend(boxes_single)\n#         box_labels.extend(labels_single)\n\n#         print(\"Bboxes after nms:\\n\", boxes)\n#         print(\"Labels after nms:\\n\", box_labels)\n\n#         count_dict = Counter(box_labels)\n#         print(count_dict)\n\n#         text_create(desktop_path,image_basename,boxes,box_labels,img_annotations.iloc[0][\"width\"],img_annotations.iloc[0][\"height\"])","2ac89074":"# iou_thr = 0.5\n# skip_box_thr = 0.0001\n# viz_images = []\n# for i, path in tqdm(enumerate(imagepaths[5:6])):\n#     image_basename = Path(path).stem\n#     print(f\"(\\'{image_basename}\\', \\'{path}\\')\")\n#     img_annotations = train_annotations[train_annotations.image_id==image_basename]\n\n#     boxes_viz = img_annotations[['x_min', 'y_min', 'x_max', 'y_max']].to_numpy().tolist()\n#     labels_viz = img_annotations['class_id'].to_numpy().tolist()\n\n#     print(\"Bboxes before nms:\\n\", boxes_viz)\n#     print(\"Labels before nms:\\n\", labels_viz)\n\n#     boxes_list = []\n#     scores_list = []\n#     labels_list = []\n#     weights = []\n\n#     boxes_single = []\n#     labels_single = []\n\n#     cls_ids = img_annotations['class_id'].unique().tolist()\n#     count_dict = Counter(img_annotations['class_id'].tolist())\n#     print(count_dict)\n\n#     for cid in cls_ids:       \n#         ## Performing Fusing operation only for multiple bboxes with the same label\n#         if count_dict[cid]==1:\n#             labels_single.append(cid)\n#             boxes_single.append(img_annotations[img_annotations.class_id==cid][['x_min', 'y_min', 'x_max', 'y_max']].to_numpy().squeeze().tolist())\n\n#         else:\n#             cls_list =img_annotations[img_annotations.class_id==cid]['class_id'].tolist()\n#             labels_list.append(cls_list)\n#             bbox = img_annotations[img_annotations.class_id==cid][['x_min', 'y_min', 'x_max', 'y_max']].to_numpy()\n\n#             ## Normalizing Bbox by Image Width and Height\n#             bbox = bbox\/(img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"], img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"])\n\n\n#             bbox = np.clip(bbox, 0, 1)\n#             boxes_list.append(bbox.tolist())\n\n#             scores_list.append(np.ones(len(cls_list)).tolist())\n\n#             weights.append(1)\n\n\n#     # Perform NMS\n#     boxes, scores, box_labels = nms(boxes_list, scores_list, labels_list, weights=weights,\n#                                     iou_thr=iou_thr)\n    \n#     print(\"Bboxes without multipy:\\n\", boxes)\n\n#     #img_array.shape[1]\u662f\u5bbd\u5ea6\n#     boxes = boxes*(img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"], img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"])\n#     boxes = boxes.round(1).tolist()\n#     box_labels = box_labels.astype(int).tolist()\n\n#     boxes.extend(boxes_single)\n#     box_labels.extend(labels_single)\n\n#     print(\"Bboxes after nms:\\n\", boxes)\n#     print(\"Labels after nms:\\n\", box_labels)\n\n#     count_dict = Counter(box_labels)\n#     print(count_dict)\n\n#     text_create('.\/',image_basename,boxes,box_labels,img_annotations.iloc[0][\"width\"],img_annotations.iloc[0][\"height\"])","572d46f8":"train_annotations=train_annotations[train_annotations.area<0.026]","2356cdd4":"train_annotations","a91191ab":"def Create_softnms_box_txt(desktop_path,name):\n    iou_thr = 0.5\n    skip_box_thr = 0.0001\n    viz_images = []\n    sigma = 0.1\n#     image_basename = Path(path).stem\n    image_basename = name\n#     print(f\"(\\'{image_basename}\\', \\'{path}\\')\")\n    img_annotations = train_annotations[train_annotations.image_id==image_basename][train_annotations.class_id==8]\n\n    boxes_viz = img_annotations[['x_min', 'y_min', 'x_max', 'y_max']].to_numpy().tolist()\n    labels_viz_raw = img_annotations['class_id'].to_numpy().tolist()\n    labels_viz = [0 if wd == 8 else wd for wd in labels_viz_raw]\n    \n    print('boxes_viz',boxes_viz)\n    \n    if(len(boxes_viz)==0):\n        text_create(desktop_path,image_basename,[],[],0,0)\n        return None\n\n    print('\u6ca1\u6709return')\n        \n    print(\"Bboxes before nms:\\n\", boxes_viz)\n    print(\"Labels before nms:\\n\", labels_viz)\n\n    boxes_list = []\n    scores_list = []\n    labels_list = []\n    weights = []\n\n    boxes_single = []\n    labels_single = []\n\n    cls_ids = img_annotations['class_id'].unique().tolist()\n    count_dict = Counter(img_annotations['class_id'].tolist())\n    print(count_dict)\n\n    for cid in cls_ids:       \n        ## Performing Fusing operation only for multiple bboxes with the same label\n        if count_dict[cid]==1:\n            labels_single.append(cid)\n            boxes_single.append(img_annotations[img_annotations.class_id==cid][['x_min', 'y_min', 'x_max', 'y_max']].to_numpy().squeeze().tolist())\n\n        else:\n            cls_list =img_annotations[img_annotations.class_id==cid]['class_id'].tolist()\n            labels_list.append(cls_list)\n            bbox = img_annotations[img_annotations.class_id==cid][['x_min', 'y_min', 'x_max', 'y_max']].to_numpy()\n\n            ## Normalizing Bbox by Image Width and Height\n            bbox = bbox\/(img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"], img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"])\n\n\n            bbox = np.clip(bbox, 0, 1)\n            boxes_list.append(bbox.tolist())\n\n            scores_list.append(np.ones(len(cls_list)).tolist())\n\n            weights.append(1)\n\n            \n\n    # Perform NMS\n    if len(boxes_list)==0:\n        boxes=boxes_single\n        box_labels=labels_single\n        print(\"Bboxes after nms:\\n\", boxes)\n        print(\"Labels after nms:\\n\", box_labels)\n        \n        count_dict = Counter(box_labels)\n        print(count_dict)\n\n        text_create(desktop_path,image_basename,boxes,box_labels,img_annotations.iloc[0][\"width\"],img_annotations.iloc[0][\"height\"])\n        \n    else:\n        boxes, scores, box_labels = soft_nms(boxes_list, scores_list, labels_list, weights=weights,\n                                    iou_thr=iou_thr)\n\n\n        #img_array.shape[1]\u662f\u5bbd\u5ea6\n        boxes = boxes*(img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"], img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"])\n        boxes = boxes.round(1).tolist()\n        box_labels = box_labels.astype(int).tolist()\n\n        boxes.extend(boxes_single)\n        box_labels.extend(labels_single)\n\n        print(\"Bboxes after nms:\\n\", boxes)\n        print(\"Labels after nms:\\n\", box_labels)\n\n        count_dict = Counter(box_labels)\n        print(count_dict)\n\n        text_create(desktop_path,image_basename,boxes,box_labels,img_annotations.iloc[0][\"width\"],img_annotations.iloc[0][\"height\"])","95c28c3c":"def Create_non_maximum_weighted_box_txt(desktop_path,name):\n    iou_thr = 0.5\n    skip_box_thr = 0.0001\n    viz_images = []\n#     image_basename = Path(path).stem\n    image_basename = name\n#     print(f\"(\\'{image_basename}\\', \\'{path}\\')\")\n    img_annotations = train_annotations[train_annotations.image_id==image_basename][train_annotations.class_id==8]\n\n    boxes_viz = img_annotations[['x_min', 'y_min', 'x_max', 'y_max']].to_numpy().tolist()\n    labels_viz = img_annotations['class_id'].to_numpy().tolist()\n\n    print(\"Bboxes before nms:\\n\", boxes_viz)\n    print(\"Labels before nms:\\n\", labels_viz)\n\n    boxes_list = []\n    scores_list = []\n    labels_list = []\n    weights = []\n\n    boxes_single = []\n    labels_single = []\n\n    cls_ids = img_annotations['class_id'].unique().tolist()\n    count_dict = Counter(img_annotations['class_id'].tolist())\n    print(count_dict)\n\n    for cid in cls_ids:       \n        ## Performing Fusing operation only for multiple bboxes with the same label\n        if count_dict[cid]==1:\n            labels_single.append(cid)\n            boxes_single.append(img_annotations[img_annotations.class_id==cid][['x_min', 'y_min', 'x_max', 'y_max']].to_numpy().squeeze().tolist())\n\n        else:\n            cls_list =img_annotations[img_annotations.class_id==cid]['class_id'].tolist()\n            labels_list.append(cls_list)\n            bbox = img_annotations[img_annotations.class_id==cid][['x_min', 'y_min', 'x_max', 'y_max']].to_numpy()\n\n            ## Normalizing Bbox by Image Width and Height\n            bbox = bbox\/(img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"], img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"])\n\n\n            bbox = np.clip(bbox, 0, 1)\n            boxes_list.append(bbox.tolist())\n\n            scores_list.append(np.ones(len(cls_list)).tolist())\n\n            weights.append(1)\n\n            \n    # Perform NMS\n    if len(boxes_list)==0:\n        boxes=boxes_single\n        box_labels=labels_single\n        print(\"Bboxes after nms:\\n\", boxes)\n        print(\"Labels after nms:\\n\", box_labels)\n        \n        count_dict = Counter(box_labels)\n        print(count_dict)\n\n        text_create(desktop_path,image_basename,boxes,box_labels,img_annotations.iloc[0][\"width\"],img_annotations.iloc[0][\"height\"])\n        \n    else:\n        boxes, scores, box_labels = non_maximum_weighted(boxes_list, scores_list, labels_list, weights=weights,\n                                    iou_thr=iou_thr)\n\n\n        #img_array.shape[1]\u662f\u5bbd\u5ea6\n        boxes = boxes*(img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"], img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"])\n        boxes = boxes.round(1).tolist()\n        box_labels = box_labels.astype(int).tolist()\n\n        boxes.extend(boxes_single)\n        box_labels.extend(labels_single)\n\n        print(\"Bboxes after nms:\\n\", boxes)\n        print(\"Labels after nms:\\n\", box_labels)\n\n        count_dict = Counter(box_labels)\n        print(count_dict)\n\n        text_create(desktop_path,image_basename,boxes,box_labels,img_annotations.iloc[0][\"width\"],img_annotations.iloc[0][\"height\"])","e478f3c9":"# os.makedirs('\/kaggle\/working\/vinbigdata\/labels\/train', exist_ok = True)\n# os.makedirs('\/kaggle\/working\/vinbigdata\/labels\/val', exist_ok = True)\n# os.makedirs('\/kaggle\/working\/vinbigdata\/images\/train', exist_ok = True)\n# os.makedirs('\/kaggle\/working\/vinbigdata\/images\/val', exist_ok = True)\n# label_dir = '\/kaggle\/input\/vinbigdata-yolo-labels-dataset\/labels'","4b95d0f9":"# # shutil.copy(file, '\/kaggle\/working\/vinbigdata\/images\/train')\n\n# img_annotations = train_df[train_df.image_id=='47ed17dcb2cbeec15182ed335a8b5a9e'][train_df.class_id==8]","4966d207":"# img_annotations","c03f1e28":"def Create_weighted_boxes_fusion_box_txt(desktop_path,name):\n    iou_thr = 0.5\n    skip_box_thr = 0.0001\n    viz_images = []\n#     image_basename = Path(path).stem\n    image_basename = name\n#     print(f\"(\\'{image_basename}\\', \\'{path}\\')\")\n    img_annotations = train_annotations[train_annotations.image_id==image_basename][train_df.class_id==8]\n\n    boxes_viz = img_annotations[['x_min', 'y_min', 'x_max', 'y_max']].to_numpy().tolist()\n    labels_viz_raw = img_annotations['class_id'].to_numpy().tolist()\n    labels_viz = [0 if wd == 8 else wd for wd in labels_viz_raw]\n\n    print(\"Bboxes before nms:\\n\", boxes_viz)\n    print(\"Labels before nms:\\n\", labels_viz)\n\n    boxes_list = []\n    scores_list = []\n    labels_list = []\n    weights = []\n\n    boxes_single = []\n    labels_single = []\n\n    cls_ids = img_annotations['class_id'].unique().tolist()\n    count_dict = Counter(img_annotations['class_id'].tolist())\n    print(count_dict)\n\n    for cid in cls_ids:       \n        ## Performing Fusing operation only for multiple bboxes with the same label\n        if count_dict[cid]==1:\n            labels_single.append(cid)\n            boxes_single.append(img_annotations[img_annotations.class_id==cid][['x_min', 'y_min', 'x_max', 'y_max']].to_numpy().squeeze().tolist())\n\n        else:\n            cls_list =img_annotations[img_annotations.class_id==cid]['class_id'].tolist()\n            labels_list.append(cls_list)\n            bbox = img_annotations[img_annotations.class_id==cid][['x_min', 'y_min', 'x_max', 'y_max']].to_numpy()\n\n            ## Normalizing Bbox by Image Width and Height\n            bbox = bbox\/(img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"], img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"])\n\n\n            bbox = np.clip(bbox, 0, 1)\n            boxes_list.append(bbox.tolist())\n\n            scores_list.append(np.ones(len(cls_list)).tolist())\n\n            weights.append(1)\n\n            \n    # Perform NMS\n    if len(boxes_list)==0:\n        boxes=boxes_single\n        box_labels=labels_single\n        print(\"Bboxes after nms:\\n\", boxes)\n        print(\"Labels after nms:\\n\", box_labels)\n        \n        count_dict = Counter(box_labels)\n        print(count_dict)\n\n        text_create(desktop_path,image_basename,boxes,box_labels,img_annotations.iloc[0][\"width\"],img_annotations.iloc[0][\"height\"])\n        \n    else:\n        boxes, scores, box_labels = weighted_boxes_fusion(boxes_list, scores_list, labels_list, weights=weights,\n                                    iou_thr=iou_thr)\n\n\n        #img_array.shape[1]\u662f\u5bbd\u5ea6\n        boxes = boxes*(img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"], img_annotations.iloc[0][\"width\"], img_annotations.iloc[0][\"height\"])\n        boxes = boxes.round(1).tolist()\n        box_labels = box_labels.astype(int).tolist()\n\n        boxes.extend(boxes_single)\n        box_labels.extend(labels_single)\n\n        print(\"Bboxes after nms:\\n\", boxes)\n        print(\"Labels after nms:\\n\", box_labels)\n\n        count_dict = Counter(box_labels)\n        print(count_dict)\n\n        text_create(desktop_path,image_basename,boxes,box_labels,img_annotations.iloc[0][\"width\"],img_annotations.iloc[0][\"height\"])","e1debdf2":"def text_create(desktop_path,name, boxes,box_labels,w,h):\n    \n        \n    full_path = os.path.join(desktop_path, name+'.txt')  # \u4e5f\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a.doc\u7684word\u6587\u6863\n    print('full_path',full_path)\n    file = open(full_path, 'w')\n    \n    if(len(boxes)==0):\n        file.close()\n    else:\n        dw = 1. \/ (w)\n        dh = 1. \/ (h)\n\n        for i in range(len(boxes)):\n\n\n            x = (boxes[i][0] + boxes[i][2]) \/ 2.0\n            y = (boxes[i][1] + boxes[i][3]) \/ 2.0\n            w = boxes[i][2] - boxes[i][0]\n            h = boxes[i][3] - boxes[i][1]\n\n\n            x = x * dw\n            w = w * dw\n            y = y * dh\n            h = h * dh\n\n\n    #         file.write(str(box_labels[i])+ ' '+ str(x)+ ' '+ str(y)+ ' '+ str(w)+ ' '+ str(h)+ ' '+ '\\n') \n            file.write(str(0)+ ' '+ str(x)+ ' '+ str(y)+ ' '+ str(w)+ ' '+ str(h)+ ' '+ '\\n')\n            print('\u5f55\u5165'+str(0)+ ' '+ str(x)+ ' '+ str(y)+ ' '+ str(w)+ ' '+ str(h)+ ' ')\n        file.close()","e97137d6":"train_files","aae32b94":"os.makedirs('\/kaggle\/working\/vinbigdata\/labels\/train', exist_ok = True)\nos.makedirs('\/kaggle\/working\/vinbigdata\/labels\/val', exist_ok = True)\nos.makedirs('\/kaggle\/working\/vinbigdata\/images\/train', exist_ok = True)\nos.makedirs('\/kaggle\/working\/vinbigdata\/images\/val', exist_ok = True)\nlabel_dir = '\/kaggle\/input\/vinbigdata-yolo-labels-dataset\/labels'\nfor file in tqdm(train_files):\n    shutil.copy(file, '\/kaggle\/working\/vinbigdata\/images\/train')\n    filename = file.split('\/')[-1].split('.')[0]\n    \n    # nms stuff\n    print(filename)\n    Create_softnms_box_txt('\/kaggle\/working\/vinbigdata\/labels\/train',filename)\n    \n#     shutil.copy(os.path.join(label_dir, filename+'.txt'), '\/kaggle\/working\/vinbigdata\/labels\/train')\n    \nfor file in tqdm(val_files):\n    shutil.copy(file, '\/kaggle\/working\/vinbigdata\/images\/val')\n    filename = file.split('\/')[-1].split('.')[0]\n    \n    # nms stuff\n    Create_softnms_box_txt('\/kaggle\/working\/vinbigdata\/labels\/val',filename)\n#     shutil.copy(os.path.join(label_dir, filename+'.txt'), '\/kaggle\/working\/vinbigdata\/labels\/val')","c3cd3a2e":"import os\npath = os.getcwd()#\u83b7\u53d6\u5f53\u524d\u8def\u5f84\n# print(path)\n\nall_files = [f for f in os.listdir('\/kaggle\/working\/vinbigdata\/labels\/train' )]#\u8f93\u51fa\u6839path\u4e0b\u7684\u6240\u6709\u6587\u4ef6\u540d\u5230\u4e00\u4e2a\u5217\u8868\u4e2d\n# all_files = [f for f in os.listdir(path )]#\u8f93\u51fa\u6839path\u4e0b\u7684\u6240\u6709\u6587\u4ef6\u540d\u5230\u4e00\u4e2a\u5217\u8868\u4e2d\n#\u5bf9\u5404\u4e2a\u6587\u4ef6\u8fdb\u884c\u5904\u7406\nprint(all_files)","110c4858":"class_ids, class_names = list(zip(*set(zip(train_df.class_id, train_df.class_name))))\nclasses = list(np.array(class_names)[np.argsort(class_ids)])\nclasses = list(map(lambda x: str(x), classes))\nclasses","8e31233d":"from os import listdir\nfrom os.path import isfile, join\nimport yaml\n\ncwd = '\/kaggle\/working\/'\n\nwith open(join( cwd , 'train.txt'), 'w') as f:\n    for path in glob('\/kaggle\/working\/vinbigdata\/images\/train\/*'):\n        f.write(path+'\\n')\n            \nwith open(join( cwd , 'val.txt'), 'w') as f:\n    for path in glob('\/kaggle\/working\/vinbigdata\/images\/val\/*'):\n        f.write(path+'\\n')\n\ndata = dict(\n    train =  join( cwd , 'train.txt') ,\n    val   =  join( cwd , 'val.txt' ),\n    nc    = 1,\n    names = classes\n    )\n\nwith open(join( cwd , 'vinbigdata.yaml'), 'w') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False)\n\nf = open(join( cwd , 'vinbigdata.yaml'), 'r')\nprint('\\nyaml:')\nprint(f.read())","84d75e25":"# https:\/\/www.kaggle.com\/ultralytics\/yolov5\n# !git clone https:\/\/github.com\/ultralytics\/yolov5  # clone repo\n# %cd yolov5\nshutil.copytree('\/kaggle\/input\/yolov5-official-v31-dataset\/yolov5', '\/kaggle\/working\/yolov5')\nos.chdir('\/kaggle\/working\/yolov5')\n%pip install -qr requirements.txt # install dependencies\n\nimport torch\nfrom IPython.display import Image, clear_output  # to display images\n\nclear_output()\nprint('Setup complete. Using torch %s %s' % (torch.__version__, torch.cuda.get_device_properties(0) if torch.cuda.is_available() else 'CPU'))","14fb94a0":"!python detect.py --weights yolov5s.pt --img 640 --conf 0.25 --source data\/images\/\nImage(filename='runs\/detect\/exp\/zidane.jpg', width=600)","b1ba83f4":"# # !WANDB_MODE=\"dryrun\" python train.py --img 640 --batch 16 --epochs 3 --data coco128.yaml --weights yolov5s.pt --nosave --cache \n!WANDB_MODE=\"dryrun\" python train.py --img 640 --batch 16 --epochs 50 --data \/kaggle\/working\/vinbigdata.yaml --weights yolov5s.pt --cache","905341d6":"\n!pip install matplotlib==3.1.3","a5289f91":"plt.figure(figsize = (20,20))\nplt.axis('off')\nplt.imshow(plt.imread('runs\/train\/exp\/labels_correlogram.jpg'));","cb914d56":"plt.figure(figsize = (20,20))\nplt.axis('off')\nplt.imshow(plt.imread('runs\/train\/exp\/labels.jpg'));","05634b5e":"import matplotlib.pyplot as plt\nplt.figure(figsize = (15, 15))\nplt.imshow(plt.imread('runs\/train\/exp\/train_batch0.jpg'))\n\nplt.figure(figsize = (15, 15))\nplt.imshow(plt.imread('runs\/train\/exp\/train_batch1.jpg'))\n\nplt.figure(figsize = (15, 15))\nplt.imshow(plt.imread('runs\/train\/exp\/train_batch2.jpg'))","b5fe78e6":"fig, ax = plt.subplots(3, 2, figsize = (2*5,3*5), constrained_layout = True)\nfor row in range(3):\n    ax[row][0].imshow(plt.imread(f'runs\/train\/exp\/test_batch{row}_labels.jpg'))\n    ax[row][0].set_xticks([])\n    ax[row][0].set_yticks([])\n    ax[row][0].set_title(f'runs\/train\/exp\/test_batch{row}_labels.jpg', fontsize = 12)\n    \n    ax[row][1].imshow(plt.imread(f'runs\/train\/exp\/test_batch{row}_pred.jpg'))\n    ax[row][1].set_xticks([])\n    ax[row][1].set_yticks([])\n    ax[row][1].set_title(f'runs\/train\/exp\/test_batch{row}_pred.jpg', fontsize = 12)","9ad31fab":"plt.figure(figsize=(30,15))\nplt.axis('off')\nplt.imshow(plt.imread('runs\/train\/exp\/results.png'));","ed4557fb":"plt.figure(figsize=(30,15))\nplt.axis('off')\nplt.imshow(plt.imread('runs\/train\/exp1\/confusion_matrix.png'));","20c2a859":"!python detect.py --weights 'runs\/train\/exp\/weights\/best.pt'\\\n--img 640\\\n--conf 0.15\\\n--iou 0.5\\\n--source \/kaggle\/working\/vinbigdata\/images\/val\\\n--exist-ok","4d2c8714":"import matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import ImageGrid\nimport numpy as np\nimport random\nimport cv2\nfrom glob import glob\nfrom tqdm import tqdm\n\nfiles = glob('runs\/detect\/exp\/*')\nfor _ in range(3):\n    row = 4\n    col = 4\n    grid_files = random.sample(files, row*col)\n    images     = []\n    for image_path in tqdm(grid_files):\n        img          = cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB)\n        images.append(img)\n\n    fig = plt.figure(figsize=(col*5, row*5))\n    grid = ImageGrid(fig, 111,  # similar to subplot(111)\n                     nrows_ncols=(col, row),  # creates 2x2 grid of axes\n                     axes_pad=0.05,  # pad between axes in inch.\n                     )\n\n    for ax, im in zip(grid, images):\n        # Iterating over the grid returns the Axes.\n        ax.imshow(im)\n        ax.set_xticks([])\n        ax.set_yticks([])\n    plt.show()","f259adb0":"# shutil.rmtree('\/kaggle\/working\/vinbigdata')\n# shutil.rmtree('runs\/detect')\n# for file in (glob('runs\/train\/exp\/**\/*.png', recursive = True)+glob('runs\/train\/exp\/**\/*.jpg', recursive = True)):\n#     os.remove(file)","c26a981a":"# [YOLOv5](https:\/\/github.com\/ultralytics\/yolov5)\n![](https:\/\/user-images.githubusercontent.com\/26833433\/98699617-a1595a00-2377-11eb-8145-fc674eb9b1a7.jpg)\n![](https:\/\/user-images.githubusercontent.com\/26833433\/90187293-6773ba00-dd6e-11ea-8f90-cd94afc0427f.png)","36b3f1d4":"## Pretrained Checkpoints:\n\n| Model | AP<sup>val<\/sup> | AP<sup>test<\/sup> | AP<sub>50<\/sub> | Speed<sub>GPU<\/sub> | FPS<sub>GPU<\/sub> || params | FLOPS |\n|---------- |------ |------ |------ | -------- | ------| ------ |------  |  :------: |\n| [YOLOv5s](https:\/\/github.com\/ultralytics\/yolov5\/releases\/tag\/v3.0)    | 37.0     | 37.0     | 56.2     | **2.4ms** | **416** || 7.5M   | 13.2B\n| [YOLOv5m](https:\/\/github.com\/ultralytics\/yolov5\/releases\/tag\/v3.0)    | 44.3     | 44.3     | 63.2     | 3.4ms     | 294     || 21.8M  | 39.4B\n| [YOLOv5l](https:\/\/github.com\/ultralytics\/yolov5\/releases\/tag\/v3.0)    | 47.7     | 47.7     | 66.5     | 4.4ms     | 227     || 47.8M  | 88.1B\n| [YOLOv5x](https:\/\/github.com\/ultralytics\/yolov5\/releases\/tag\/v3.0)    | **49.2** | **49.2** | **67.7** | 6.9ms     | 145     || 89.0M  | 166.4B\n| | | | | | || |\n| [YOLOv5x](https:\/\/github.com\/ultralytics\/yolov5\/releases\/tag\/v3.0) + TTA|**50.8**| **50.8** | **68.9** | 25.5ms    | 39      || 89.0M  | 354.3B\n| | | | | | || |\n| [YOLOv3-SPP](https:\/\/github.com\/ultralytics\/yolov5\/releases\/tag\/v3.0) | 45.6     | 45.5     | 65.2     | 4.5ms     | 222     || 63.0M  | 118.0B","4957bedc":"# Inference Plot","be96fd09":"# Selecting Models\nIn this notebok I'm using `v5s`. To select your prefered model just replace `--cfg models\/yolov5s.yaml --weights yolov5s.pt` with the following command:\n* `v5s` : `--cfg models\/yolov5s.yaml --weights yolov5s.pt`\n* `v5m` : `--cfg models\/yolov5m.yaml --weights yolov5m.pt`\n* `v5l` : `--cfg models\/yolov5l.yaml --weights yolov5l.pt`\n* `v5x` : `--cfg models\/yolov5x.yaml --weights yolov5x.pt`","c8993151":"# Split","775c5a05":"# Batch Image","594656eb":"# Train","3cd94e95":"# Inference","108b17dd":"# Version\n* `v13`: Fold4\n* `v12`: Fold3\n* `v10`: Fold2\n* `v09`: Fold1\n* `v03`: Fold0","5b8ed175":"# Only 14 Class","509ac9ac":"# Copying Files","5c66aac5":"# Get Class Name","57d6e347":"# Confusion Matrix","9881f93f":"# (Loss, Map) Vs Epoch","5b4ab855":"# GT Vs Pred","3f661f4a":"# Class Distribution","9a2482a5":"# YOLOv5 Stuff"}}