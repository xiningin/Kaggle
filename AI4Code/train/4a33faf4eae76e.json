{"cell_type":{"0df10601":"code","69cc536c":"code","2b7ef6c1":"code","19cc4f4e":"code","6f286a0e":"code","d979d4d7":"code","1241aacd":"markdown","0bf8f3d4":"markdown","9467f091":"markdown"},"source":{"0df10601":"# Install:\n# Kaggle environments.\n!git clone https:\/\/github.com\/Kaggle\/kaggle-environments.git\n!cd kaggle-environments && pip install .\n\n# GFootball environment.\n!apt-get update -y\n!apt-get install -y libsdl2-gfx-dev libsdl2-ttf-dev\n\n# Make sure that the Branch in git clone and in wget call matches !!\n!git clone -b v2.8 https:\/\/github.com\/google-research\/football.git\n!mkdir -p football\/third_party\/gfootball_engine\/lib\n!wget https:\/\/storage.googleapis.com\/gfootball\/prebuilt_gameplayfootball_v2.8.so -O football\/third_party\/gfootball_engine\/lib\/prebuilt_gameplayfootball.so\n# Custom files\n!wget https:\/\/gist.githubusercontent.com\/RaffaeleMorganti\/04192739d0a5a518ac253889eb83c6f1\/raw\/c09f3d602ea89e66daeda96574d966949a2896ce\/11_vs_11_deterministic.py -O football\/gfootball\/scenarios\/11_vs_11_deterministic.py \n!wget https:\/\/gist.githubusercontent.com\/RaffaeleMorganti\/04192739d0a5a518ac253889eb83c6f1\/raw\/c09f3d602ea89e66daeda96574d966949a2896ce\/football_action_set.py -O football\/gfootball\/env\/football_action_set.py\n!cd football && GFOOTBALL_USE_PREBUILT_SO=1 pip3 install .","69cc536c":"%%writefile submission.py\n\n# start executing cells from here to rewrite submission.py\n\nfrom kaggle_environments.envs.football.helpers import *\nimport math\nimport random\n\ndef find_patterns(obs, player_x, player_y):\n    \"\"\" find list of appropriate patterns in groups of memory patterns \"\"\"\n    for get_group in groups_of_memory_patterns:\n        group = get_group(obs, player_x, player_y)\n        if group[\"environment_fits\"](obs, player_x, player_y):\n            return group[\"get_memory_patterns\"](obs, player_x, player_y)\n\ndef get_action_of_agent(obs, player_x, player_y):\n    \"\"\" get action of appropriate pattern in agent's memory \"\"\"\n    memory_patterns = find_patterns(obs, player_x, player_y)\n    # find appropriate pattern in list of memory patterns\n    for get_pattern in memory_patterns:\n        pattern = get_pattern(obs, player_x, player_y)\n        if pattern[\"environment_fits\"](obs, player_x, player_y):\n            return pattern[\"get_action\"](obs, player_x, player_y)\n        \ndef get_active_sticky_action(obs, exceptions):\n    \"\"\" get release action of the first active sticky action, except those in exceptions list \"\"\"\n    release_action = None\n    for k in sticky_actions:\n        if k not in exceptions and sticky_actions[k] in obs[\"sticky_actions\"]:\n            if k == \"sprint\":\n                release_action = Action.ReleaseSprint\n            '''\n            elif k == \"dribble\":\n                release_action = Action.ReleaseDribble\n            else:\n                release_action = Action.ReleaseDirection\n            '''\n            break\n    return release_action\n\ndef get_active_sticky_direction(obs, exceptions):\n    for k in sticky_actions:\n        if k not in exceptions and sticky_actions[k] in obs[\"sticky_actions\"]:\n            return sticky_actions[k]\n    return None\n\ndef get_average_distance_to_opponents(obs, player_x, player_y):\n    \"\"\" get average distance to closest opponents \"\"\"\n    distances_sum = 0\n    distances_amount = 0\n    for i in range(1, len(obs[\"right_team\"])):\n        # if opponent is ahead of player\n        if obs[\"right_team\"][i][0] > (player_x - 0.015):\n            distance_to_opponent = get_distance(player_x, player_y, obs[\"right_team\"][i][0], obs[\"right_team\"][i][1])\n            if distance_to_opponent < 0.1:\n                distances_sum += distance_to_opponent\n                distances_amount += 1\n    # if there is no opponents close around\n    if distances_amount == 0:\n        return 100, distances_amount\n    return distances_sum*10000 \/\/ (distances_amount*10), distances_amount\n\ndef get_distance(x1, y1, x2, y2):\n    \"\"\" get two-dimensional Euclidean distance, considering y size of the field \"\"\"\n    return math.sqrt((x1 - x2) ** 2 + (y1 * 2.38 - y2 * 2.38) ** 2)\n\n# Evaluate angle between two objects\ndef get_angle(pos1,pos2):\n    return math.degrees(math.atan2(pos2[1]* 2.38 - pos1[1]* 2.38, pos2[0]-pos1[0]))\n\n# Offense Patterns\n\ndef continue_after_gain_poss(obs, player_x, player_y):\n    \"\"\" continue going the direction that help gain the ball for 3 steps \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # We have the ball but we didn't previously.\n        if obs[\"ball_owned_team\"] == 0 and state.prev_ball_owned_team != obs[\"ball_owned_team\"]:\n            state.pass_cmd_issued = False # Clear old state\n            dir = get_active_sticky_direction(obs, [\"sprint\",\"dribble\"])\n            if dir != None:\n                return True\n        return False\n    \n    def get_action(obs, player_x, player_y):\n        \"\"\" get action of this memory pattern \"\"\"\n        if abs(player_x) > 0.9 and obs.left_team_direction[obs.active][0] < -0.006:\n            dir = Action.Top if player_y < 0 else Action.Bottom\n            return dir\n        if player_x < -0.75:\n            # Sensitive area, release sprint first\n            if Action.Sprint in obs[\"sticky_actions\"]:\n                return Action.ReleaseSprint\n            dir = Action.Top if player_y < 0 else Action.Bottom\n            return dir\n        dir = get_active_sticky_direction(obs, [\"sprint\",\"dribble\"])\n        if state.debug_offense:\n            print(f'Step {3001-steps_left} continue_after_gain_poss() {dir} {obs.active}:{player_x:.3f}:{player_y:.3f}')\n        if dir != None:\n            return do_actions([dir])\n        return Action.Shot\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef bad_angle_short_pass(obs, player_x, player_y):\n    \"\"\" perform a short pass, if player is at bad angle to opponent's goal \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # player have the ball and is at bad angle to opponent's goal\n        if (obs[\"ball_owned_player\"] == obs[\"active\"] and\n                obs[\"ball_owned_team\"] == 0 and\n                abs(player_y) > 0.1 and\n                player_x > 0.78):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        if state.debug_offense:\n            print(f'Step {3001-steps_left} bad_angle_short_pass() {obs.active}:{player_x:.3f}:{player_y:.3f}')\n        \"\"\" get action of this memory pattern \"\"\"\n        action_to_release = get_active_sticky_action(obs, [])\n        if action_to_release != None:\n            return action_to_release\n        if state.pass_cmd_issued == False:\n            state.pass_cmd_issued = True\n            return Action.ShortPass if abs(player_y) < 0.3 else Action.HighPass\n        else:\n            if player_x < 0.85:\n                action = Action.TopRight if player_y > 0 else Action.BottomRight\n            else:\n                action = Action.Top if player_y > 0 else Action.Bottom\n            return action\n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef close_to_goalkeeper_shot(obs, player_x, player_y):\n    \"\"\" shot if close to the goalkeeper \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        goalkeeper_x = obs[\"right_team\"][0][0] + obs[\"right_team_direction\"][0][0] * 13\n        goalkeeper_y = obs[\"right_team\"][0][1] + obs[\"right_team_direction\"][0][1] * 13\n        # player have the ball and located close to the goalkeeper\n        if (obs[\"ball_owned_player\"] == obs[\"active\"] and\n                obs[\"ball_owned_team\"] == 0 and\n                get_distance(player_x, player_y, goalkeeper_x, goalkeeper_y) < 0.3):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        if state.debug_offense:\n            print(f'Step {3001-steps_left} close_to_goalkeeper_shot() {my_dist_opp[obs.active][0]:0.3f} {obs.active}:{player_x:.3f}:{player_y:.3f}')\n        \"\"\" get action of this memory pattern \"\"\"\n        if Action.Sprint in obs[\"sticky_actions\"]:\n            return Action.ReleaseSprint\n        if player_y <= -0.03 or (player_y > 0 and player_y < 0.03):\n            if Action.BottomRight not in obs[\"sticky_actions\"]:\n                return do_actions([Action.BottomRight,Action.Shot])\n        else:\n            if Action.TopRight not in obs[\"sticky_actions\"]:\n                return do_actions([Action.TopRight,Action.Shot])\n        return Action.Shot\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef far_from_goal_goalie_has_ball(obs, player_x, player_y):\n    \"\"\" perform a shot, if far from opponent's goal \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # Goalie have the ball but a defender is active. Spread out and HighPass is fine.\n        if (obs[\"ball_owned_player\"] != obs[\"active\"] and\n                obs[\"ball_owned_team\"] == 0 and\n                (player_x < -0.6 or obs[\"ball_owned_player\"] == 0)):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        if state.debug_offense:\n            print(f'Step {3001-steps_left} far_from_goal_goalie_has_ball() {obs.active}:{player_x:.3f}:{player_y:.3f}')\n        \"\"\" get action of this memory pattern \"\"\"\n        # The goal here is to get open and not too far from the goalie\n        # so he can throw the ball to the active player.\n        action = Action.Right\n        if player_x > -0.8:\n            action = Action.Left\n        elif player_x < -0.95:\n            action = Action.Right\n        elif abs(player_y) < 0.12:\n            action = Action.Bottom if player_y > 0 else Action.Top\n        return action\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef angle_to_direction(angle):\n    if angle > 157.5: return Action.Left, 180\n    elif angle > 112.5: return Action.BottomLeft, 135\n    elif angle > 67.5: return Action.Bottom, 90\n    elif angle > 22.5: return Action.BottomRight, 45\n    elif angle > -22.5: return Action.Right, 0\n    elif angle > -67.5: return Action.TopRight, -45\n    elif angle > -112.5: return Action.Top, -90\n    elif angle > -157.5: return Action.TopLeft, -135\n    else: return Action.Left, -180\n\ndef find_evade_dir(obs, player_x, player_y):\n    biggest_distance = 0\n    left, left_opponents_amount = get_average_distance_to_opponents(obs, player_x - 0.01, player_y)\n    right, right_opponents_amount = get_average_distance_to_opponents(obs, player_x + 0.01, player_y)\n    top_right, tr_opponents_amount = get_average_distance_to_opponents(obs, player_x + 0.01, player_y - 0.01)\n    top_left, tl_opponents_amount = get_average_distance_to_opponents(obs, player_x - 0.01, player_y - 0.01)\n    top, t_opponents_amount = get_average_distance_to_opponents(obs, player_x, player_y - 0.01)\n    if player_y <= -0.32:\n        top_right = top_left = top = 0\n    bottom_right, br_opponents_amount = get_average_distance_to_opponents(obs, player_x + 0.01, player_y + 0.01)\n    bottom_left, bl_opponents_amount = get_average_distance_to_opponents(obs, player_x - 0.01, player_y + 0.01)\n    bottom, b_opponents_amount = get_average_distance_to_opponents(obs, player_x, player_y + 0.01)\n    if player_y >= 0.32:\n        bottom_right = bottom_left = bottom = 0\n    if player_x <= -0.7 and player_y >= -0.2:\n        bottom_left = left = 0\n    if player_x <= -0.7 and player_y <= 0.2:\n        top_left = left = 0\n    if player_x <= -0.85:\n        top_left = bottom_left = left = 0\n    if player_x > 0.93:\n        top_left = top_right = right = 0\n    biggest_distance = max(left, right, top_right, top_left, top, bottom_right, bottom_left, bottom)\n    action = Action.Right\n    if (biggest_distance == right or right == 100):\n        # Right is best or clear and already in the center or wing\n        action = Action.Right\n    elif (biggest_distance == top_right or top_right == 100):\n        action = Action.TopRight\n    elif (biggest_distance == bottom_right or bottom_right == 100):\n        action = Action.BottomRight\n    elif (biggest_distance == top or top == 100):\n        action = Action.Top\n    elif (biggest_distance == bottom or bottom == 100):\n        action = Action.Bottom\n    elif (biggest_distance == top_left or top_left == 100):\n        action = Action.TopLeft\n    elif (biggest_distance == bottom_left or bottom_left == 100):\n        action = Action.BottomLeft\n    elif (biggest_distance == left or left == 100):\n        action = Action.Left\n    return action\n\ndef far_from_goal_shot(obs, player_x, player_y):\n    \"\"\" perform a shot, if far from opponent's goal \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # player have the ball and is far from opponent's goal\n        if (obs[\"ball_owned_player\"] == obs[\"active\"] and\n                obs[\"ball_owned_team\"] == 0 and\n                obs[\"ball_owned_player\"] == 0):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        if state.debug_offense:\n            print(f'Step {3001-steps_left} far_from_goal_shot() {obs.active}:{player_x:.3f}:{player_y:.3f}')\n        \"\"\" get action of this memory pattern \"\"\"\n        return Action.Shot\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef far_from_goal_high_pass(obs, player_x, player_y):\n    \"\"\" perform a high pass, if far from opponent's goal \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # player have the ball and is far from opponent's goal\n        if (obs[\"ball_owned_player\"] == obs[\"active\"] and\n            obs[\"ball_owned_team\"] == 0 and\n            player_x < -0.3):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        \"\"\" get action of this memory pattern \"\"\"\n        if state.debug_offense:\n            print(f'Step {3001-steps_left} far_from_goal_high_pass() {obs.active}:{player_x:.3f}:{player_y:.3f}')\n        if defender_close[obs.active] == 0 or abs(player_y) > 0.33:\n            should_pass, ix = teammate_open(obs, player_x, player_y)\n            if should_pass:\n                pass_angle = my_angle_own[obs.active][ix]\n                direction, angle = angle_to_direction(pass_angle)\n                action = Action.ShortPass if defender_block_pass[obs.active][ix] == 0 else Action.HighPass\n            else:\n                direction = Action.Right\n                action = Action.HighPass\n            if state.pass_cmd_issued == False:\n                state.pass_cmd_issued = True\n            if direction not in obs[\"sticky_actions\"]:\n                return do_actions([direction,action])\n            else:\n                return action\n        else:\n            direction = find_evade_dir(obs, player_x, player_y)\n            curdir = get_active_sticky_direction(obs, [\"sprint\",\"dribble\"])\n            if curdir != None and curdir != direction:\n                if Action.Sprint in obs[\"sticky_actions\"]:\n                    return Action.ReleaseSprint\n            return direction\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef go_through_opponents(obs, player_x, player_y):\n    \"\"\" avoid closest opponents by going around them \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        biggest_distance = 0\n        right, right_opponents_amount = get_average_distance_to_opponents(obs, player_x + 0.01, player_y)\n        top_right, tr_opponents_amount = get_average_distance_to_opponents(obs, player_x + 0.01, player_y - 0.01)\n        top, t_opponents_amount = get_average_distance_to_opponents(obs, player_x, player_y - 0.01)\n        if player_y <= -0.3:\n            top_right = top = 0\n        bottom_right, br_opponents_amount = get_average_distance_to_opponents(obs, player_x + 0.01, player_y + 0.01)\n        bottom, b_opponents_amount = get_average_distance_to_opponents(obs, player_x, player_y + 0.01)\n        if player_y >= 0.3:\n            bottom_right = bottom = 0\n        biggest_distance = max(right, top_right, bottom_right)\n        biggest_opponents_amount = max(right_opponents_amount,tr_opponents_amount,br_opponents_amount)\n        action = Action.ReleaseDribble\n        if right < 100 and top_right < 100 and bottom_right < 100:\n            # then biggest_distance wins\n            if biggest_distance == right:\n                # Right is best or clear\n                action = Action.Right\n            elif biggest_distance == top_right and player_y > -0.32:\n                action = Action.TopRight\n            elif biggest_distance == bottom_right and player_y < 0.32:\n                action = Action.BottomRight\n        elif right == 100 and top_right < 100 and bottom_right < 100:\n            action = Action.Right\n        elif right < 100 and top_right == 100 and bottom_right < 100:\n            action = Action.TopRight\n        elif right < 100 and top_right < 100 and bottom_right == 100:\n            action = Action.BottomRight\n        elif right == 100 and top_right == 100 and bottom_right < 100:\n            action = Action.Right if player_y < 0.12 else Action.TopRight\n        elif right == 100 and top_right < 100 and bottom_right == 100:\n            action = Action.Right if player_y > -0.12 else Action.BottomRight\n        elif right < 100 and top_right == 100 and bottom_right == 100:\n            action = Action.TopRight if player_y > 0 else Action.BottomRight\n        elif right == 100 and top_right == 100 and bottom_right == 100:\n            if abs(player_y) < 0.12:\n                action = Action.Right\n            elif player_y > 0.12:\n                action = Action.TopRight\n            else:\n                action = Action.BottomRight\n            \n        obs[\"memory_patterns\"][\"go_around_opponent\"] = action\n        obs[\"memory_patterns\"][\"biggest_distance\"] = biggest_distance\n        if state.debug_offense:\n            print(f'  go_through ({player_x:.3f},{player_y:.3f}) {action} R:TR:BR {right:.3f}:{top_right:.3f}:{bottom_right:.3f}'\n                  f' {right_opponents_amount}:{tr_opponents_amount}:{br_opponents_amount}')\n        # is player is surrounded?\n        if biggest_opponents_amount >= 3:\n            obs[\"memory_patterns\"][\"go_around_opponent_surrounded\"] = True\n        else:\n            obs[\"memory_patterns\"][\"go_around_opponent_surrounded\"] = False\n        return True\n        \n    def get_action(obs, player_x, player_y):\n        \"\"\" get action of this memory pattern \"\"\"\n        action = obs[\"memory_patterns\"][\"go_around_opponent\"]\n        if state.debug_offense:\n            print(f'Step {3001-steps_left} go_through_opponents() {action} {obs.active}:{player_x:.3f}:{player_y:.3f}')\n        if (obs[\"memory_patterns\"][\"go_around_opponent_surrounded\"] or action == Action.ReleaseDribble):\n            # if player is surrounded or no good dir to go, stop.\n            if Action.Sprint in obs[\"sticky_actions\"]:\n                return Action.ReleaseSprint\n            return Action.ReleaseDribble\n        if Action.Sprint not in obs[\"sticky_actions\"]:\n            return Action.Sprint\n        return action\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\n# Defense Patterns\n\ndef teammate_open(obs, player_x, player_y):\n    active = obs[\"active\"]\n    active_potential = potential[active]\n    sort_potential = sorted(potential.items(), key=lambda item: item[1], reverse=True)\n    sorted_opp_pos = sorted(obs['right_team'])\n    current_offside_x_value = sorted_opp_pos[-2][0]\n    for pot in sort_potential[0:1]:\n        ix = pot[0]\n        if ix == active or ix == 0:\n            # Don't send to ourselves or goalie\n            continue\n        if obs['left_team_active'][ix] is False:\n            continue\n        if pot[1] <= active_potential+0.01:\n            if (state.debug_passing):\n                print(f'Step {3001-steps_left} Ignore {ix} pot:{pot[1]:.3f} our:{active_potential:.3f}')\n            continue\n        if (obs['left_team'][ix][0] > 0 and obs['left_team'][ix][0] > current_offside_x_value and\n            obs['left_team'][active][0] <= current_offside_x_value):\n            if state.debug_offense:\n                print(f'Step {3001-steps_left} teammate_open Act:{obs.active}X:{player_x:.3f}'\n                      f' ignore {ix} mateX:{obs.left_team[ix][0]:.3f} offsideX:{current_offside_x_value:.3f}')\n            continue\n        if obs['left_team'][ix][0] > 0.88 and abs(obs['left_team'][ix][1]) > 0.28:\n            # Ignore those that are too deep and too outside\n            continue\n        if state.debug_offense:\n            print(f'Step {3001-steps_left} teammate_open Act:{obs.active}:{player_x:.3f}:{player_y:.3f}'\n                  f' pass to mate {ix}:{obs.left_team[ix][0]:.3f}:{obs.left_team[ix][1]:.3f} pot:{pot[1]} vs {active_potential}')\n        return True, ix\n    return False, 0\n\ndef charge_and_shot(obs, player_x, player_y):\n    \"\"\" when player's center and the cross is coming in, shoot first time \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        if obs[\"ball_owned_team\"] != -1:\n            return False\n        if player_x > 0.7 and player_x < 1.01 and abs(player_y) < 0.12:\n            # offensive player in the box\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        \"\"\" get action of this memory pattern \"\"\"\n        shot_angle = my_angle_goal[obs.active]\n        direction, angle = angle_to_direction(shot_angle)\n        if state.debug_offense:\n            print(f'Step {3001-steps_left} charge_and_shot() {direction} A:{shot_angle} {obs.active}:{player_x:.3f}:{player_y:.3f}')\n        return do_actions([direction,Action.Shot])\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef quick_pass(obs, player_x, player_y):\n    \"\"\" when player's center and the cross is coming in, shoot first time \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        if obs[\"ball_owned_team\"] != -1:\n            return False\n        if abs(obs[\"ball_direction\"][0])+abs(obs[\"ball_direction\"][1]) < 0.007:\n            # Ball moving slowly, it's most likely not a passing situation\n            return False\n        if obs[\"active\"] == 0:\n            # Have goalie clear it first time\n            return True\n        dist_ball = get_distance(player_x, player_y, obs[\"ball\"][0], obs[\"ball\"][1])\n        if state.debug_offense:\n            print(f'Step {3001-steps_left} DistB {dist_ball:.3f} {player_x:.3f},{player_y:.3f}'\n                  f' d:{obs[\"left_team_direction\"][obs.active][0]:.3f},{obs[\"left_team_direction\"][obs.active][1]:.3f}'\n                  f' B:{obs[\"ball\"][0]:.3f},{obs[\"ball\"][1]:.3f} Bd:{obs[\"ball_direction\"][0]:.3f},{obs[\"ball_direction\"][1]:.3f}')\n        if dist_ball > 0.15:\n            fu_pos, t_pos = ball_intercept_pos(obs)\n            if t_pos > 4:\n                # Wait until the ball is close before making decision\n                return False\n        if player_x < 0.4 and player_x > -0.2 and defender_close[obs.active] > 0:\n            return False\n        if player_x <= -0.2 and defender_near[obs.active] > 0:\n            return False\n        if player_x > -0.7:\n            # Pass quickly if we are not too deep\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        \"\"\" get action of this memory pattern \"\"\"\n        if obs[\"active\"] == 0:\n            # Have goalie clear it first time\n            return Action.Shot\n        first, opp = first_to_the_ball(obs, player_x, player_y)\n        should_pass, ix = teammate_open(obs, player_x, player_y)\n        if first:\n            if should_pass is False:\n                if state.debug_offense:\n                    print(f'Step {3001-steps_left} quick_pass {ix} no open teammate from {obs.active}:{player_x:.3f}:{player_y:.3f}')\n                return Action.Idle\n            pass_angle = my_angle_own[obs.active][ix]\n            direction, angle = angle_to_direction(pass_angle)\n            action = Action.ShortPass if defender_block_pass[obs.active][ix] == 0 else Action.HighPass\n            if state.debug_offense:\n                print(f'Step {3001-steps_left} quick_pass to {ix} A:{pass_angle:.2f} {direction} {action} from {obs.active}:{player_x:.3f}:{player_y:.3f}')\n            return do_actions([direction,action])\n        else:\n            # We won't be first to the ball, just idle to continue what we are doing\n            return Action.Idle\n\n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef steps_to_go_there(loca, va, locb, vb):\n    dvx = vb[0]-va[0]\n    dvy = vb[1]-va[1]\n    tx = ty = 0\n    if dvx != 0:\n        tx = (loca[0]-locb[0])\/dvx\n    if dvy != 0:\n        ty = (loca[1]-locb[1])\/dvy\n    if dvx == 0 and dvy == 0:\n        return (locb[0],locb[1]), 50\n    time = max(abs(tx),abs(ty))\n    ex = locb[0]+vb[0]*time\n    ey = locb[1]+vb[1]*time\n    if state.debug_offense:\n        print(f'steps_to_go_there: {loca[0]:.3f},{loca[1]:.3f} to {locb[0]:.3f},{locb[1]:.3f}'\n              f' Time {time:.2f} x:{tx:.2f} t:{ty:.2f} loc {ex:.3f},{ey:.3f}')\n    return (ex,ey), time\n    \n# Return True if we are the first to reach the ball,\n# compared to other players opp or ours.\ndef first_to_the_ball(obs, player_x, player_y):\n    active = obs['active']\n    if obs['ball'][2] > 0.3: # Ball in the air\n        # Location that the ball will land and in how many steps\n        tgt, time = ball_landing_pos(obs)\n        tgtdir = (0,0)\n    else:\n        tgt = obs['ball']\n        tgtdir = obs['ball_direction']\n\n    our_dist = get_distance(player_x, player_y, tgt[0], tgt[1])\n    if state.debug_offense:\n        print(f'Step {3001-steps_left} first_to_the_ball D:{our_dist:.3f} {player_x:.3f},{player_y:.3f}'\n              f' d:{obs[\"left_team_direction\"][obs.active][0]:.3f},{obs[\"left_team_direction\"][obs.active][1]:.3f}'\n              f' B:{obs[\"ball\"][0]:.3f},{obs[\"ball\"][1]:.3f} Bd:{obs[\"ball_direction\"][0]:.3f},{obs[\"ball_direction\"][1]:.3f}')\n    if our_dist > 0.15:\n        maxopp = None\n        maxopptime = 50\n        # Calculate how long it takes us to get to the target\n        loc, ourtime = steps_to_go_there(obs['left_team'][active], obs['left_team_direction'][active],\n                                         tgt, tgtdir)\n        for ix in range(11):\n            if my_dist_opp[active][ix] > 0.4:\n                continue\n            loc, opptime = steps_to_go_there(obs['right_team'][ix], obs['right_team_direction'][ix],\n                                             tgt, tgtdir)\n            if opptime < maxopptime:\n                maxopptime = opptime\n                maxopp = ix\n        if maxopp != None and maxopptime < ourtime:\n            return False, maxopp\n        return True, None\n    else:\n        maxopp = None\n        maxdist = 50\n        # We are very close, use distance\n        for ix in range(11):\n            if my_dist_opp[active][ix] > 0.4:\n                continue\n            opp_dist = get_distance(obs['right_team'][ix][0], obs['right_team'][ix][1], tgt[0], tgt[1])\n            if opp_dist < maxdist:\n                maxdist = opp_dist\n                maxopp = ix\n        if maxopp != None and maxdist < our_dist:\n            return False, maxopp\n        return True, None\n        \ndef ball_intercept_pos(obs):\n    active = obs['active']\n    va = obs['left_team_direction'][active]\n    loca = obs['left_team'][active]\n    vb = obs['ball_direction']\n    locb = obs['ball']\n    dvx = vb[0]-va[0]\n    dvy = vb[1]-va[1]\n    tx = ty = 0\n    if dvx != 0:\n        tx = (loca[0]-locb[0])\/dvx\n    if dvy != 0:\n        ty = (loca[1]-locb[1])\/dvy\n    if dvx == 0 and dvy == 0:\n        return (locb[0],locb[1]), 10\n    time = min(abs(tx),abs(ty))\n    ex = locb[0]+vb[0]*time\n    ey = locb[1]+vb[1]*time\n    if state.debug_offense:\n        print(f'Ball_intercept_pos: Time {time:.2f} x:{tx:.2f} t:{ty:.2f} loc {ex:.3f},{ey:.3f}')\n    return (ex,ey), time\n\n# Estimate landing position\ndef ball_landing_pos(obs):\n    start_height = obs['ball'][2]\n    end_height = 0.2\n    start_speed = obs['ball_direction'][2]\n    gravity = 0.1\n    time = (start_speed**2\/gravity**2 - 2\/gravity*(end_height-start_height))**0.5 + start_speed\/gravity\n    ex = obs['ball'][0]+obs['ball_direction'][0]*time\n    ey = obs['ball'][1]+obs['ball_direction'][1]*time\n    if state.debug_offense:\n        print(f'ball_landing_pos: Time {time:.2f} loc {ex:.3f},{ey:.3f}')\n    return (ex,ey), time\n\ndef chase_active_opp(obs, player_x, player_y):\n    # if opponent is ahead of player\n    opp_active_x = obs[\"right_team\"][obs[\"ball_owned_player\"]][0]\n    opp_active_y = obs[\"right_team\"][obs[\"ball_owned_player\"]][1]\n    if player_x < -0.69 and abs(player_y) < 0.23:\n        # Penalty box, be more careful\n        slide_distance = 0.015\n    else:\n        slide_distance = 0.025\n    if opp_active_x < player_x:\n        distance_to_opponent = get_distance(player_x, player_y, opp_active_x, opp_active_y)\n        distance_to_ball = get_distance(player_x, player_y, obs[\"ball\"][0], obs[\"ball\"][1])\n        if (distance_to_opponent < slide_distance and distance_to_ball < slide_distance):\n            return True\n    state.chase = False\n    state.chase_cnt = 0\n    return False\n\ndef chase_slide(obs, player_x, player_y):\n    \"\"\" when we are chasing and behind an opp player and both are going full speed \"\"\"\n    \"\"\" Count how long we've chased him. On the count of five, slide. \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        chasing = chase_active_opp(obs, player_x, player_y)\n        if obs[\"ball_owned_team\"] == 1:\n            if chasing == False:\n                return False\n            state.chase = True\n            state.chase_cnt += 1\n            if state.debug_defense:\n                print(f'Step {3001-steps_left} cnt:{state.chase_cnt} {obs.active}:{player_x:.3f}:{player_y:.3f}')\n            if state.chase_cnt >= 2:\n                return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        if state.debug_defense:\n            print(f'Step {3001-steps_left} chase_slide() {obs.active}:{player_x:.3f}:{player_y:.3f}')\n        \"\"\" get action of this memory pattern \"\"\"\n        return Action.Slide\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef mark(obs,tgt,tgt_dir):\n    active = obs['active']\n    our_dir = obs['left_team_direction'][active]\n    our_loc = obs['left_team'][active]\n    direction = Action.ReleaseDirection\n    if tgt[0] > our_loc[0]+(0.044)-tgt_dir[0]:\n        if tgt[1] > our_loc[1]+0.015:\n            # Below us and far\n            direction = Action.BottomRight\n        elif tgt[1] > our_loc[1]:\n            direction = Action.Right\n        elif tgt[1] < our_loc[1]-0.015:\n            direction = Action.TopRight\n        else:\n            direction = Action.Right\n    elif tgt[0] > our_loc[0]+(0.044):\n        if tgt[1] > our_loc[1]+0.015:\n            # Below us and far\n            direction = Action.Bottom\n        elif tgt[1] > our_loc[1]:\n            direction = Action.Idle\n        elif tgt[1] < our_loc[1]-0.015:\n            direction = Action.Top\n        else:\n            direction = Action.Idle\n    elif tgt[0] > our_loc[0]:\n        # Slightly further from our goal than us on X\n        if tgt[1] > our_loc[1]+0.015:\n            # Below us and far\n            direction = Action.Bottom\n        elif tgt[1] > our_loc[1]:\n            # Below us, not far\n            direction = Action.Left\n        elif tgt[1] < our_loc[1]-0.015:\n            # Above us, and far\n            direction = Action.Top\n        else:\n            # Above us, not far\n            direction = Action.Left\n    elif tgt[0] < our_loc[0]:\n        # Closer to our goal than us on X\n        if tgt[1] > our_loc[1]+0.015:\n            # Below us and far\n            direction = Action.BottomLeft\n        elif tgt[1] > our_loc[1]:\n            # Below us, not far\n            direction = Action.Left\n        elif tgt[1] < our_loc[1]-0.015:\n            # Above us and far\n            direction = Action.TopLeft\n        else:\n            # Above us, not far\n            direction = Action.Left\n    if (state.debug_defense):\n        print(f'Step {3001-steps_left} {active} go {direction}, tgt:{tgt[0]:.3f},{tgt[1]:.3f}:{tgt_dir[0]:.3f},{tgt_dir[1]:.3f}'\n              f' us:{our_loc[0]:.3f},{our_loc[1]:.3f}:{our_dir[0]:.3f},{our_dir[1]:.3f}') \n    return direction\n\ndef find_highest_opp(obs):\n    highest_x = 2\n    highest = 9\n    for ix in range(11):\n        if highest_x > obs['right_team'][ix][0]:\n            highest_x = obs['right_team'][ix][0]\n            highest = ix\n    return highest\n\ndef high_ball_overhead(obs, player_x, player_y):\n    \"\"\" High ball overhead, be behind the forward. Don't chase the ball. \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        if obs[\"ball_owned_team\"] != -1:\n            return False\n        if abs(obs[\"ball_direction\"][0])+abs(obs[\"ball_direction\"][1]) < 0.01:\n            # Ball moving slowly, it's most likely not a passing situation\n            return False\n        # Active is the last defender\n        sorted_our_pos = sorted(obs['left_team'])\n        last_defender_x_value = sorted_our_pos[1][0]\n        if last_defender_x_value >= player_x and obs[\"ball\"][0] > player_x:\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        \"\"\" get action of this memory pattern \"\"\"\n        # Find the highest forward and mark him\n        highest_opp = find_highest_opp(obs)\n        action = mark(obs,obs[\"right_team\"][highest_opp],obs[\"right_team_direction\"][highest_opp])\n        if state.debug_defense:\n            print(f'Step {3001-steps_left} high_ball_overhead() {action} {obs.active}:{player_x:.3f}:{player_y:.3f}'\n                  f' mark {highest_opp}:{obs[\"right_team\"][highest_opp][0]}:{obs[\"right_team\"][highest_opp][1]}'\n                  f' B:{obs.ball[0]:.3f}:{obs.ball[1]:.3f}'\n                  f' Bd:{obs.ball_direction[0]:.3f}:{obs.ball_direction[1]:.3f}')\n        return action\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef run_to_ball_bottom(obs, player_x, player_y):\n    \"\"\" run to the ball if it is to the bottom from player's position \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # ball is to the bottom from player's position\n        if (obs[\"ball\"][1] > player_y and\n                abs(obs[\"ball\"][0] - player_x) < 0.01):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        if state.debug_defense:\n            print(f'Step {3001-steps_left} run_to_ball_bottom() {obs.active}:{player_x:.3f}:{player_y:.3f}'\n                  f' B:{obs.ball[0]:.3f}:{obs.ball[1]:.3f} Bd:{obs.ball_direction[0]:.3f}:{obs.ball_direction[1]:.3f}')\n        \"\"\" get action of this memory pattern \"\"\"\n        if Action.Sprint not in obs[\"sticky_actions\"]:\n            return Action.Sprint\n        return Action.Bottom\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef run_to_ball_bottom_left(obs, player_x, player_y):\n    \"\"\" run to the ball if it is to the bottom left from player's position \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # ball is to the bottom left from player's position\n        if (obs[\"ball\"][0] < player_x and\n                obs[\"ball\"][1] > player_y):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        if state.debug_defense:\n            print(f'Step {3001-steps_left} run_to_ball_bottom_left() {obs.active}:{player_x:.3f}:{player_y:.3f}'\n                  f' B:{obs.ball[0]:.3f}:{obs.ball[1]:.3f} Bd:{obs.ball_direction[0]:.3f}:{obs.ball_direction[1]:.3f}')\n        \"\"\" get action of this memory pattern \"\"\"\n        if Action.Sprint not in obs[\"sticky_actions\"]:\n            return Action.Sprint\n        return Action.BottomLeft\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef run_to_ball_bottom_right(obs, player_x, player_y):\n    \"\"\" run to the ball if it is to the bottom right from player's position \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # ball is to the bottom right from player's position\n        if (obs[\"ball\"][0] > player_x+0.015 and\n                obs[\"ball\"][1] > player_y):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        if state.debug_defense:\n            print(f'Step {3001-steps_left} run_to_ball_bottom_right() {obs.active}:{player_x:.3f}:{player_y:.3f}'\n                  f' B:{obs.ball[0]:.3f}:{obs.ball[1]:.3f} Bd:{obs.ball_direction[0]:.3f}:{obs.ball_direction[1]:.3f}')\n        \"\"\" get action of this memory pattern \"\"\"\n        if Action.Sprint not in obs[\"sticky_actions\"]:\n            return Action.Sprint\n        return Action.BottomRight\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef run_to_ball_left(obs, player_x, player_y):\n    \"\"\" run to the ball if it is to the left from player's position \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # ball is to the left from player's position\n        if (obs[\"ball\"][0] < player_x and\n                abs(obs[\"ball\"][1] - player_y) < 0.01):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        if state.debug_defense:\n            print(f'Step {3001-steps_left} run_to_ball_left() {obs.active}:{player_x:.3f}:{player_y:.3f}'\n                  f' B:{obs.ball[0]:.3f}:{obs.ball[1]:.3f} Bd:{obs.ball_direction[0]:.3f}:{obs.ball_direction[1]:.3f}')\n        \"\"\" get action of this memory pattern \"\"\"\n        if Action.Sprint not in obs[\"sticky_actions\"]:\n            return Action.Sprint\n        return Action.Left\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef run_to_ball_right(obs, player_x, player_y):\n    \"\"\" run to the ball if it is to the right from player's position \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # ball is to the right from player's position\n        if (obs[\"ball\"][0] > player_x+0.04 and\n                abs(obs[\"ball\"][1] - player_y) < 0.01):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        if state.debug_defense:\n            print(f'Step {3001-steps_left} run_to_ball_right() {obs.active}:{player_x:.3f}:{player_y:.3f}'\n                  f' B:{obs.ball[0]:.3f}:{obs.ball[1]:.3f} Bd:{obs.ball_direction[0]:.3f}:{obs.ball_direction[1]:.3f}')\n        \"\"\" get action of this memory pattern \"\"\"\n        if Action.Sprint not in obs[\"sticky_actions\"]:\n            return Action.Sprint\n        return Action.Right\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef run_to_ball_top(obs, player_x, player_y):\n    \"\"\" run to the ball if it is to the top from player's position \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # ball is to the top from player's position\n        if (obs[\"ball\"][1] < player_y and\n                abs(obs[\"ball\"][0] - player_x) < 0.01):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        if state.debug_defense:\n            print(f'Step {3001-steps_left} run_to_ball_top() {obs.active}:{player_x:.3f}:{player_y:.3f}'\n                  f' B:{obs.ball[0]:.3f}:{obs.ball[1]:.3f} Bd:{obs.ball_direction[0]:.3f}:{obs.ball_direction[1]:.3f}')\n        \"\"\" get action of this memory pattern \"\"\"\n        if Action.Sprint not in obs[\"sticky_actions\"]:\n            return Action.Sprint\n        return Action.Top\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef run_to_ball_top_left(obs, player_x, player_y):\n    \"\"\" run to the ball if it is to the top left from player's position \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # ball is to the top left from player's position\n        if (obs[\"ball\"][0] < player_x and\n                obs[\"ball\"][1] < player_y):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        if state.debug_defense:\n            print(f'Step {3001-steps_left} run_to_ball_top_left() {obs.active}:{player_x:.3f}:{player_y:.3f}'\n                  f' B:{obs.ball[0]:.3f}:{obs.ball[1]:.3f} Bd:{obs.ball_direction[0]:.3f}:{obs.ball_direction[1]:.3f}')\n        \"\"\" get action of this memory pattern \"\"\"\n        if Action.Sprint not in obs[\"sticky_actions\"]:\n            return Action.Sprint\n        return Action.TopLeft\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef run_to_ball_top_right(obs, player_x, player_y):\n    \"\"\" run to the ball if it is to the top right from player's position \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # ball is to the top right from player's position\n        if (obs[\"ball\"][0] > player_x+0.015 and\n                obs[\"ball\"][1] < player_y):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        if state.debug_defense:\n            print(f'Step {3001-steps_left} run_to_ball_top_right() {obs.active}:{player_x:.3f}:{player_y:.3f}'\n                  f' B:{obs.ball[0]:.3f}:{obs.ball[1]:.3f} Bd:{obs.ball_direction[0]:.3f}:{obs.ball_direction[1]:.3f}')\n        \"\"\" get action of this memory pattern \"\"\"\n        if Action.Sprint not in obs[\"sticky_actions\"]:\n            return Action.Sprint\n        return Action.TopRight\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\n# Special Game Modes\n# Evaluate euclidian distance between two objects\ndef uncalibrated_get_distance(pos1,pos2):\n    return ((pos1[0]-pos2[0])**2+(pos1[1]-pos2[1])**2)**0.5\n\ndef defending_setpiece(obs):\n    # Find out if we are the kicking team or the defending team\n    ball_dist = uncalibrated_get_distance(obs[\"left_team\"][obs['active']], obs['ball'])\n    defending = True\n    if (ball_dist < 0.043 or \n        (obs['game_mode'] == GameMode.Penalty and ball_dist < 0.056)):\n         # ball is that far for goalkick, kickoff is 0.02, pen is 0.055\n        defending = False\n    return defending\n\ndef go_center(player_x, player_y):\n    action = Action.Top if player_y > 0 else Action.Bottom\n    if player_x > -0.7:\n        action = Action.Left\n    elif player_x < -0.9:\n        action = Action.Right\n    return action\n\ndef corner(obs, player_x, player_y):\n    \"\"\" perform a high pass in corner game mode \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # it is corner game mode\n        if obs['game_mode'] == GameMode.Corner:\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        defend = defending_setpiece(obs)\n        if state.debug_special:\n            print(f'Step {3001-steps_left} corner() {obs.active}:{player_x:.3f}:{player_y:.3f} {\"D\" if defend else \"A\"}')\n        \"\"\" get action of this memory pattern \"\"\"\n        if defend:\n            action = go_center(player_x, player_y)\n            return action\n        action = Action.Top if player_y > 0 else Action.Bottom\n        followthru_action = Action.TopRight if player_y > 0 else Action.BottomRight\n        return do_actions([action,Action.HighPass,followthru_action,followthru_action,Action.HighPass,Action.HighPass,Action.HighPass])\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef free_kick(obs, player_x, player_y):\n    \"\"\" perform a high pass or a shot in free kick game mode \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # it is free kick game mode\n        if obs['game_mode'] == GameMode.FreeKick:\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        defend = defending_setpiece(obs)\n        if state.debug_special:\n            print(f'Step {3001-steps_left} free_kick() {obs.active}:{player_x:.3f}:{player_y:.3f} {\"D\" if defend else \"A\"}')\n        \"\"\" get action of this memory pattern \"\"\"\n        if obs[\"ball_owned_team\"] == 0:\n            # shot if player close to goal\n            if player_x > 0.5:\n                action_to_release = get_active_sticky_action(obs, [\"top_right\", \"bottom_right\"])\n                if action_to_release != None:\n                    return action_to_release\n                if Action.TopRight not in obs[\"sticky_actions\"] and Action.BottomRight not in obs[\"sticky_actions\"]:\n                    if player_y > 0:\n                        return Action.TopRight\n                    else:\n                        return Action.BottomRight\n                return Action.Shot\n            else:\n                # high pass if player far from goal\n                action_to_release = get_active_sticky_action(obs, [\"right\"])\n                if action_to_release != None:\n                    return action_to_release\n                if Action.Right not in obs[\"sticky_actions\"]:\n                    return Action.Right\n                return Action.HighPass\n        else:\n            # We are the defending team\n            if defender_close[obs.active] > 0:\n                return Action.ReleaseDirection\n            if player_x < 0.5:\n                # Mark the one behind\n                return Action.Right\n            else:\n                # Mark the one ahead\n                return Action.Left\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef goal_kick(obs, player_x, player_y):\n    \"\"\" perform a short pass in goal kick game mode \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # it is goal kick game mode\n        if obs['game_mode'] == GameMode.GoalKick:\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        defend = defending_setpiece(obs)\n        if state.debug_special:\n            print(f'Step {3001-steps_left} goal_kick() {obs.active}:{player_x:.3f}:{player_y:.3f} {\"D\" if defend else \"A\"}')\n        \"\"\" get action of this memory pattern \"\"\"\n        action_to_release = get_active_sticky_action(obs, [\"top_right\", \"bottom_right\"])\n        if action_to_release != None:\n            return action_to_release\n        return Action.TopRight if obs.ball[1] > 0 else Action.BottomRight\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef kick_off(obs, player_x, player_y):\n    \"\"\" perform a short pass in kick off game mode \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # it is kick off game mode\n        defend = defending_setpiece(obs)\n        if obs['game_mode'] == GameMode.KickOff:\n            return True\n        if (obs['active'] != 6 and obs['ball'][0] == 0 and obs['ball'][1] == 0 and\n            obs['ball_direction'][0] == 0 and obs['ball_direction'][1] == 0 and\n            obs['ball_rotation'][0] == 0 and obs['ball_rotation'][1] == 0):\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        defend = defending_setpiece(obs)\n        \"\"\" get action of this memory pattern \"\"\"\n        if state.debug_special:\n            print(f'Step {3001-steps_left} kick_off() {obs.game_mode}'\n                  f' {obs.active}:{player_x:.3f}:{player_y:.3f} {\"D\" if defend else \"A\"}'\n                  f' B:{obs.ball[0]},{obs.ball[1]}')\n        if defend:\n            return do_actions([Action.Right,Action.Right,Action.Right,Action.Right])\n        else:\n            return do_actions([Action.TopLeft,Action.Sprint,Action.Sprint])\n\n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef penalty(obs, player_x, player_y):\n    \"\"\" perform a shot in penalty game mode \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # it is penalty game mode\n        if obs['game_mode'] == GameMode.Penalty:\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        defend = defending_setpiece(obs)\n        if state.debug_special:\n            print(f'Step {3001-steps_left} penalty() {obs.active}:{player_x:.3f}:{player_y:.3f} {\"D\" if defend else \"A\"}')\n        \"\"\" get action of this memory pattern \"\"\"\n        return do_actions([Action.ReleaseDribble,Action.Shot,Action.ReleaseSprint,Action.Shot,Action.Bottom,Action.HighPass,Action.ReleaseSprint,Action.Slide,Action.Slide])\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\ndef throw_in(obs, player_x, player_y):\n    \"\"\" perform a short pass in throw in game mode \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # it is throw in game mode\n        if obs['game_mode'] == GameMode.ThrowIn:\n            return True\n        return False\n        \n    def get_action(obs, player_x, player_y):\n        defend = defending_setpiece(obs)\n        if state.debug_special:\n            print(f'Step {3001-steps_left} throw_in() {obs.active}:{player_x:.3f}:{player_y:.3f} {\"D\" if defend else \"A\"}')\n        \"\"\" get action of this memory pattern \"\"\"\n        action_to_release = get_active_sticky_action(obs, [\"right\"])\n        if action_to_release != None:\n            return action_to_release\n        if obs[\"ball_owned_team\"] == 0:\n            # We are the throwing team\n            if player_y < 0:\n                return Action.TopRight\n            else:\n                return Action.BottomRight\n        else:\n            # We are the defending team\n            if defender_close[obs.active] > 0:\n                return Action.ReleaseDirection\n            if player_x < 0.5:\n                # Mark the one behind\n                return Action.Right\n            else:\n                # Mark the one ahead\n                return Action.Left\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\n# Any environment\n\ndef idle(obs, player_x, player_y):\n    \"\"\" do nothing, release all sticky actions \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        return True\n        \n    def get_action(obs, player_x, player_y):\n        \"\"\" get action of this memory pattern \"\"\"\n        action_to_release = get_active_sticky_action(obs, [])\n        if action_to_release != None:\n            return action_to_release\n        return Action.Idle\n    \n    return {\"environment_fits\": environment_fits, \"get_action\": get_action}\n\n# Group of Memory Patterns\n\ndef defence_memory_patterns(obs, player_x, player_y):\n    \"\"\" group of memory patterns for environments in which opponent's team has the ball \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # player don't have the ball\n        if obs[\"ball_owned_team\"] != 0:\n            return True\n        return False\n        \n    def get_memory_patterns(obs, player_x, player_y):\n        \"\"\" get list of memory patterns \"\"\"\n        # shift ball position\n        obs[\"ball\"][0] += obs[\"ball_direction\"][0] * 7\n        obs[\"ball\"][1] += obs[\"ball_direction\"][1] * 3\n        # if opponent has the ball and is far from y axis center\n        if abs(obs[\"ball\"][1]) > 0.07 and obs[\"ball_owned_team\"] == 1:\n            obs[\"ball\"][0] -= 0.01\n            if obs[\"ball\"][1] > 0:\n                obs[\"ball\"][1] -= 0.01\n            else:\n                obs[\"ball\"][1] += 0.01\n            \n        memory_patterns = [\n            charge_and_shot,\n            quick_pass,\n            run_to_ball_right,\n            run_to_ball_left,\n            run_to_ball_bottom,\n            run_to_ball_top,\n            run_to_ball_top_right,\n            run_to_ball_top_left,\n            run_to_ball_bottom_right,\n            run_to_ball_bottom_left,\n            idle\n        ]\n        return memory_patterns\n        \n    return {\"environment_fits\": environment_fits, \"get_memory_patterns\": get_memory_patterns}\n\ndef regular_defence_memory_patterns(obs, player_x, player_y):\n    \"\"\" group of memory patterns for environments in which opponent's team has the ball \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # We are defending\n        chasing = chase_active_opp(obs, player_x, player_y)\n        if obs[\"ball_owned_team\"] == 1 and chasing:\n            return True\n        # Active is the last defender\n        sorted_our_pos = sorted(obs['left_team'])\n        last_defender_x_value = sorted_our_pos[1][0]\n        if (obs[\"ball_owned_team\"] == -1 and\n            abs(obs[\"ball_direction\"][0])+abs(obs[\"ball_direction\"][1]) > 0.01 and\n            last_defender_x_value >= player_x and obs[\"ball\"][0] > player_x):\n            return True\n        return False\n        \n    def get_memory_patterns(obs, player_x, player_y):\n        \"\"\" get list of memory patterns \"\"\"\n        memory_patterns = [\n            chase_slide,\n            high_ball_overhead,\n            idle\n        ]\n        return memory_patterns\n        \n    return {\"environment_fits\": environment_fits, \"get_memory_patterns\": get_memory_patterns}\n\ndef goalkeeper_memory_patterns(obs, player_x, player_y):\n    \"\"\" group of memory patterns for goalkeeper \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # player is a goalkeeper have the ball\n        if (obs[\"ball_owned_player\"] == obs[\"active\"] and\n                obs[\"ball_owned_team\"] == 0 and\n                obs[\"ball_owned_player\"] == 0):\n            return True\n        return False\n        \n    def get_memory_patterns(obs, player_x, player_y):\n        \"\"\" get list of memory patterns \"\"\"\n        memory_patterns = [\n            far_from_goal_shot,\n            idle\n        ]\n        return memory_patterns\n        \n    return {\"environment_fits\": environment_fits, \"get_memory_patterns\": get_memory_patterns}\n\ndef offence_memory_patterns(obs, player_x, player_y):\n    \"\"\" group of memory patterns for environments in which player's team has the ball \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # player have the ball\n        if obs[\"ball_owned_team\"] == 0:\n            return True\n        return False\n        \n    def get_memory_patterns(obs, player_x, player_y):\n        \"\"\" get list of memory patterns \"\"\"\n        memory_patterns = [\n            continue_after_gain_poss,\n            far_from_goal_goalie_has_ball,\n            far_from_goal_shot,\n            far_from_goal_high_pass,\n            bad_angle_short_pass,\n            close_to_goalkeeper_shot,\n            go_through_opponents,\n            idle\n        ]\n        return memory_patterns\n        \n    return {\"environment_fits\": environment_fits, \"get_memory_patterns\": get_memory_patterns}\n\ndef other_memory_patterns(obs, player_x, player_y):\n    \"\"\" group of memory patterns for all other environments \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        return True\n        \n    def get_memory_patterns(obs, player_x, player_y):\n        \"\"\" get list of memory patterns \"\"\"\n        memory_patterns = [\n            idle\n        ]\n        return memory_patterns\n        \n    return {\"environment_fits\": environment_fits, \"get_memory_patterns\": get_memory_patterns}\n\ndef special_game_modes_memory_patterns(obs, player_x, player_y):\n    \"\"\" group of memory patterns for special game mode environments \"\"\"\n    def environment_fits(obs, player_x, player_y):\n        \"\"\" environment fits constraints \"\"\"\n        # if game mode is not normal\n        if obs['game_mode'] != GameMode.Normal:\n            return True\n        if (obs['active'] != 6 and obs['ball'][0] == 0 and obs['ball'][1] == 0 and\n            obs['ball_direction'][0] == 0 and obs['ball_direction'][1] == 0 and\n            obs['ball_rotation'][0] == 0 and obs['ball_rotation'][1] == 0):\n            return True\n        return False\n        \n    def get_memory_patterns(obs, player_x, player_y):\n        \"\"\" get list of memory patterns \"\"\"\n        memory_patterns = [\n            corner,\n            free_kick,\n            goal_kick,\n            kick_off,\n            penalty,\n            throw_in,\n            idle\n        ]\n        return memory_patterns\n        \n    return {\"environment_fits\": environment_fits, \"get_memory_patterns\": get_memory_patterns}\n\n# Global Variables\n\n# list of groups of memory patterns\ngroups_of_memory_patterns = [\n    special_game_modes_memory_patterns,\n    goalkeeper_memory_patterns,\n    offence_memory_patterns,\n    regular_defence_memory_patterns,\n    defence_memory_patterns,\n    other_memory_patterns\n]\n\n# dictionary of sticky actions\nsticky_actions = {\n    \"left\": Action.Left,\n    \"top_left\": Action.TopLeft,\n    \"top\": Action.Top,\n    \"top_right\": Action.TopRight,\n    \"right\": Action.Right,\n    \"bottom_right\": Action.BottomRight,\n    \"bottom\": Action.Bottom,\n    \"bottom_left\": Action.BottomLeft,\n    \"sprint\": Action.Sprint,\n    \"dribble\": Action.Dribble\n}\n\n# @human_readable_agent wrapper modifies raw observations \n# provided by the environment:\n# https:\/\/github.com\/google-research\/football\/blob\/master\/gfootball\/doc\/observation.md#raw-observations\n# into a form easier to work with by humans.\n# Following modifications are applied:\n# - Action, PlayerRole and GameMode enums are introduced.\n# - 'sticky_actions' are turned into a set of active actions (Action enum)\n#    see usage example below.\n# - 'game_mode' is turned into GameMode enum.\n# - 'designated' field is removed, as it always equals to 'active'\n#    when a single player is controlled on the team.\n# - 'left_team_roles'\/'right_team_roles' are turned into PlayerRole enums.\n# - Action enum is to be returned by the agent function.\n\nmemory = []\nnotRunning = [False,0]\ndid_init=False\nstate = None\nsteps_left = 3001\n\nclass My_State:\n    def __init__(self):\n        self.prev_active = None\n        self.prev_ball_owned_team = None\n        self.prev_ball_owned_player = None\n        self.pass_cmd_issued = False\n        self.quick_pass_cmd_issued = False\n        self.quick_pass_cmd = None\n        self.chase = False\n        self.chase_cnt = 0\n        self.current_score_left = 0\n        self.current_score_right = 0\n        self.debug_passing = False\n        self.debug_defense = False\n        self.debug_offense = False\n        self.debug_special = False\n        self.debug_distance = False\n\ndef init(obs):\n    global state\n    state = My_State()\n\n# Execute a sequence of actions\ndef do_actions(sequence):\n    global memory\n    memory = sequence[1:]\n    return sequence[0]\n\nmy_dist_own = [ [ 0 for y in range(11) ] for x in range(11) ]\nmy_angle_own = [ [ 5 for y in range(11) ] for x in range(11) ]\nmy_angle_goal = [ [ 5 for y in range(1) ] for x in range(11) ]\nmy_dist_opp = {}\nmy_angle_opp = {}\ndef_dist = [ [ 0 for y in range(11) ] for x in range(11) ]\ndef_angle = [ [ 0 for y in range(11) ] for x in range(11) ]\ndefender_near = [ [ 0 for y in range(1) ] for x in range(11) ]\ndefender_close = [ [ 0 for y in range(1) ] for x in range(11) ]\navg_dist_opp = [ [ 0 for y in range(1) ] for x in range(11) ]\ndef_block_pass_angle = [ [ None for y in range(11) ] for x in range(11) ]\ndefender_block_pass = [ [ 0 for y in range(11) ] for x in range(11) ]\ndefender_block_goal = [ [ 0 for y in range(1) ] for x in range(11) ]\ndef_block_goal_angle = {}\npotential = {}\n\ndef block_angle_by_dist(dist):\n    if dist < 0.1: return 12\n    elif dist < 0.2: return 13\n    elif dist < 0.3: return 15\n    elif dist < 0.4: return 20\n    elif dist < 0.5: return 25\n    return 30\n\ndef angle_covered(goal_angle,opp_angle,block_angle):\n    delta = abs(goal_angle-opp_angle)\n    if  delta > 180:\n        delta = 360-delta\n    if delta <= block_angle:\n        return True\n    return False\n\ndef players_assess(obs):\n    active = obs['active']\n    left_team = obs['left_team']\n    right_team = obs['right_team']\n    for ix in range(11):\n        if (state.debug_distance and ix == active):\n            print(f'Step {3001-steps_left} P{ix} {left_team[ix][0]:.2f},{left_team[ix][1]:.2f}')\n        # Calculate distance to our teammates\n        for jx in range(ix+1,11):\n            dist = get_distance(left_team[ix][0], left_team[ix][1], left_team[jx][0], left_team[jx][1])\n            my_dist_own[ix][jx] = my_dist_own[jx][ix] = dist\n        # Calculate angle to our teammates\n        for jx in range(11):\n            if ix == jx: continue\n            angle = get_angle(left_team[ix], left_team[jx])\n            my_angle_own[ix][jx] = angle\n            if (state.debug_distance and ix == active and my_dist_own[ix][jx] < 0.2):\n                print(f' P{jx} D:{my_dist_own[ix][jx]:.2f} A:{angle:.2f}')\n        # Calculate distance and angle to our opponents\n        opp_dist = {}\n        opp_angle = {}\n        for jx in range(11):\n            dist = get_distance(left_team[ix][0], left_team[ix][1], right_team[jx][0], right_team[jx][1])\n            opp_dist[jx] = dist\n            def_dist[jx][ix] = dist\n            angle = get_angle(left_team[ix], right_team[jx])\n            opp_angle[jx] = angle\n            def_angle[jx][ix] = 180+angle if angle < 0 else angle-180\n            if state.debug_distance and ix == active and dist < 0.2:\n                print(f' OP{jx} {right_team[jx][0]:.2f},{right_team[jx][1]:.2f} D:{dist:.2f} A:{angle:.2f}')\n        my_dist_opp[ix] = opp_dist\n        my_angle_opp[ix] = opp_angle\n        my_angle_goal[ix] = get_angle(left_team[ix], (1,0))\n        \n    # Calculate current defender near and close.\n    for ix in range(11):\n        dist, amount = get_average_distance_to_opponents(obs,left_team[ix][0],left_team[ix][1])\n        avg_dist_opp[ix] = dist\/1000\n        defender_near[ix] = defender_close[ix] = 0\n        goal_angle = my_angle_goal[ix]\n        def_block_goal = {}\n        def_block_pass = {}\n        for jx in range(11):\n            if obs['right_team_active'][jx] is False:\n                continue\n            if my_dist_opp[ix][jx] <= 0.015*5:\n                defender_near[ix] += 1\n                if my_dist_opp[ix][jx] <= 0.015*2.5:\n                    defender_close[ix] += 1\n            opp_angle = my_angle_opp[active][jx]\n            block_angle = block_angle_by_dist(my_dist_opp[active][jx])\n            if angle_covered(goal_angle,opp_angle,block_angle):\n                def_block_goal[jx] = opp_angle\n            if active != ix and my_dist_own[active][ix] >= my_dist_opp[active][jx]:\n                pass_angle = my_angle_own[active][ix]\n                if angle_covered(pass_angle,opp_angle,block_angle):\n                    def_block_pass[jx] = opp_angle\n        def_block_goal_angle[ix] = def_block_goal\n        defender_block_goal[ix] = len(def_block_goal_angle[ix])\n        def_block_pass_angle[active][ix] = def_block_pass\n        defender_block_pass[active][ix] = len(def_block_pass_angle[active][ix])\n        if state.debug_distance and (defender_near[ix] == 0 or defender_close[ix] == 0 or defender_block_pass[active][ix] == 0 or ix == active):\n            print(f' D:A:N:C:B {ix} {my_dist_own[active][ix]:.3f}:{avg_dist_opp[ix]:.3f}:{defender_near[ix]}:{defender_close[ix]}:{defender_block_pass[active][ix]}')\n\n    for ix in range(11):\n        # Calculate our player's potential\n        potential[ix] = left_team[ix][0]-abs(left_team[ix][1])+avg_dist_opp[ix]-(my_dist_own[active][ix]\/2.5)\n\n@human_readable_agent\ndef agent(obs):\n    global state\n    global did_init\n    global steps_left\n    global memory\n    \n    if not did_init:\n        init(obs)\n        did_init=True\n\n    # Execute memorized actions\n    if (memory and state.prev_active == obs[\"active\"] and\n        state.prev_ball_owned_team == obs[\"ball_owned_team\"] and\n        state.prev_ball_owned_player == obs[\"ball_owned_player\"]):\n        return memory.pop(0)\n    else:\n        memory.clear()\n    steps_left = obs['steps_left']\n    active = obs['active']\n    players_assess(obs)\n    \"\"\" Ole ole ole ole \"\"\"\n    # dictionary for Memory Patterns data\n    obs[\"memory_patterns\"] = {}\n    # We always control left team (observations and actions\n    # are mirrored appropriately by the environment).\n    controlled_player_pos = obs[\"left_team\"][obs[\"active\"]]\n    if state.current_score_left != obs[\"score\"][0] or state.current_score_right != obs[\"score\"][1]:\n        if state.debug_offense or state.debug_defense or state.debug_special or state.debug_passing:\n            print(f'!!!!! Step {3001-steps_left} Score Update !!!!!! L:{obs[\"score\"][0]} R:{obs[\"score\"][1]}'\n                  f' (previous {state.current_score_left}:{state.current_score_right})')\n        state.current_score_left = obs[\"score\"][0]\n        state.current_score_right = obs[\"score\"][1]\n    # get action of appropriate pattern in agent's memory\n    action = get_action_of_agent(obs, controlled_player_pos[0], controlled_player_pos[1])\n    # return action\n    state.prev_ball_owned_team = obs[\"ball_owned_team\"]\n    state.prev_ball_owned_player = obs[\"ball_owned_player\"]\n    state.prev_active = obs[\"active\"]\n    return action","2b7ef6c1":"from kaggle_environments import make\ndeterministic = True\nenv = make(\"football\", debug=True, configuration={\"save_video\": True, \"scenario_name\": \"11_vs_11_deterministic\" if deterministic else \"11_vs_11_kaggle\", \"running_in_notebook\": True, \"episodeSteps\": 3000})\noutput = env.run([\"\/kaggle\/working\/submission.py\", \"builtin_ai\"])[-1]\nprint('Left player: reward = %s, status = %s, info = %s' % (output[0]['reward'], output[0]['status'], output[0]['info']))\nprint('Right player: reward = %s, status = %s, info = %s' % (output[1]['reward'], output[1]['status'], output[1]['info']))\nenv.render(mode=\"human\", width=800, height=600)","19cc4f4e":"from kaggle_environments import make\ndef playMatch(leftAgent = \"builtin_ai\", rightAgent = \"builtin_ai\", deterministic = False):\n    env = make(\"football\", debug=True, configuration={\"save_video\": True, \"scenario_name\": \"11_vs_11_deterministic\" if deterministic else \"11_vs_11_kaggle\", \"running_in_notebook\": True, \"episodeSteps\": 3000})\n    output = env.run([leftAgent, rightAgent])[-1]\n    print('Left player: reward = %s, status = %s, info = %s' % (output[0]['reward'], output[0]['status'], output[0]['info']))\n    print('Right player: reward = %s, status = %s, info = %s' % (output[1]['reward'], output[1]['status'], output[1]['info']))\n    env.render(mode=\"human\", width=800, height=600)\n    return env, output\n\nfrom pandas import DataFrame\n\ndef analyse_match(steps):\n    obs = []\n    for step in steps:\n        val = step[0]['observation']['players_raw'][0] # left player\n        val['action'] = step[0]['action'][0] if step[0]['action'] else -1\n        obs.append(val)\n    df = DataFrame(obs)\n    #print(f'{dir(obs)} {obs[99]}')\n    lgoal = obs[-1]['score'][0]\n    rgoal = obs[-1]['score'][1]\n    lwin = rwin = False\n    if lgoal > rgoal:\n        lwin = True\n    elif lgoal < rgoal:\n        rwin = True\n    pos = [-1,-1,-1]\n    pos = (df['ball_owned_team'].value_counts()\/sum(df['ball_owned_team'].value_counts())*100).rename({-1:'None',0:'Left',1:'Right'})\n    print(f'{pos[0]} {pos[1]} {pos[2]}')\n    return lwin, rwin, lgoal, rgoal, pos[1], pos[2]\n\ndef printStats(steps):\n    obs = []\n    for step in steps:\n        val = step[0]['observation']['players_raw'][0] # left player\n        val['action'] = step[0]['action'][0] if step[0]['action'] else -1\n        obs.append(val)\n    df = DataFrame(obs)\n    print(f'{dir(obs)} {obs[99]}')\n    report = {}\n    report['Goal Scored'] = obs[-1]['score']\n    report['Yellow Cards'] = [sum(obs[-1]['left_team_yellow_card']),sum(obs[-1]['right_team_yellow_card'])]\n    report['Red Cards'] = [11-sum(obs[-1]['left_team_active']),11-sum(obs[-1]['right_team_active'])]\n    reportDF = DataFrame.from_records(report).T\n    reportDF.columns = ['Left','Right']\n\n    ballOwn = (df['ball_owned_team'].value_counts()\/sum(df['ball_owned_team'].value_counts())*100).rename({-1:'None',0:'Left',1:'Right'})\n    gameMode = (df['game_mode'].value_counts()\/sum(df['game_mode'].value_counts())*100).rename({0:'Normal',1:'KickOff',2:'GoalKick',3:'FreeKick',4:'Corner',5:'ThrowIn',6:'Penalty'})\n    ballPos = DataFrame.from_records(df['ball'])\n    ballPos.columns = ['x','y','z']\n\n    print('-----------------------------\\n   Stats                \\n-----------------------------')\n    print(reportDF)\n    print('-----------------------------\\n   Ball Possession (%)  \\n-----------------------------')\n    print(ballOwn.to_string())\n    print('-----------------------------\\n   Game Mode (%)        \\n-----------------------------')\n    print(gameMode.to_string())\n    print('-----------------------------\\n   Average Ball Position\\n-----------------------------')\n    print(ballPos.mean().to_string())","6f286a0e":"leftwin = rightwin = draw = 0\nleftpos = rightpos = 0\nleftgoal = rightgoal = 0\ntotalgame = 5\nlgoal = [ [ 0 for y in range(1) ] for x in range(totalgame) ]\nrgoal = [ [ 0 for y in range(1) ] for x in range(totalgame) ]\n\nfor game in range(totalgame):\n    match, output = playMatch(\"\/kaggle\/working\/submission.py\", deterministic=False)\n    lwin, rwin, lgoal[game], rgoal[game], lpos, rpos = analyse_match(match.steps)\n    if lwin:\n        leftwin += 1\n    elif rwin:\n        rightwin += 1\n    else:\n        draw += 1\n    leftpos += lpos\n    rightpos += rpos\n    leftgoal += lgoal[game]\n    rightgoal += rgoal[game]\n    print(f'Game {game+1}, Left:{lgoal[game]} Right:{rgoal[game]} ({lpos}):({rpos})')\n\nprint(f'V20_4 vs AI Left wins {leftwin}, loses {rightwin}, draw {draw}, ({leftgoal}:{rightgoal}) {(leftgoal*100\/(rightgoal if rightgoal > 0 else 1)):.2f}% (Lpos:{leftpos\/totalgame} Rpos:{rightpos\/totalgame})')","d979d4d7":"# Replay analysis of gfootball game from json file\nfrom kaggle_environments.envs.football.helpers import *\nimport json\nimport math\n\nclass My_State:\n    def __init__(self):\n        self.ball_owner = None\n        self.intended_passer = None\n        self.intended_passee = None\n        self.completed_pass = 0\n        self.offside_value = 0\n        self.debug_distance = False\n        self.debug_distance_future = False\n        self.debug_passing = False\n        self.debug_passing_detail = False\n        self.debug_defense = False\n        self.debug_offense = True\n        self.debug_future = False\n        self.debug_passing_super_detail = False\n\ndef init():\n    global state\n    state = My_State()\n    \ndef calculate_potential(filename, start, stop):\n    global potential\n    init()\n\n    def_dist = [ [ 0 for y in range(11) ] for x in range(11) ]\n    def_angle = [ [ 0 for y in range(11) ] for x in range(11) ]\n    def_angle_goal = [ [ 0 for y in range(1) ] for x in range(11) ]\n    my_dist_own = [ [ 0 for y in range(11) ] for x in range(11) ]\n    def_block_pass_angle = [ [ None for y in range(11) ] for x in range(11) ]\n    defender_block_pass = [ [ 0 for y in range(11) ] for x in range(11) ]\n    potential = [ [ 5 for y in range(1) ] for x in range(11) ]\n    defender_near = [ [ 5 for y in range(1) ] for x in range(11) ]\n    defender_close = [ [ 5 for y in range(1) ] for x in range(11) ]\n    avg_dist_opp = [ [ 0 for y in range(1) ] for x in range(11) ]\n    defender_block_goal = [ [ 5 for y in range(1) ] for x in range(11) ]\n    goal_dist_own = [ [ 5 for y in range(1) ] for x in range(11) ]\n    goal_dist_opp = [ [ 5 for y in range(1) ] for x in range(11) ]\n    my_open_goal_angle = [ [ 5 for y in range(1) ] for x in range(11) ]\n    ball_dist = [ [ 5 for y in range(1) ] for x in range(11) ]\n    my_angle_goal = [ [ 5 for y in range(1) ] for x in range(11) ]\n    my_angle_own = [ [ 5 for y in range(11) ] for x in range(11) ]\n    my_future_dist_own = [ [ 0 for y in range(11) ] for x in range(11) ]\n    future_def_block_pass_angle = [ [ None for y in range(11) ] for x in range(11) ]\n    future_defender_block_pass = [ [ 0 for y in range(11) ] for x in range(11) ]\n    future_left_team = [ [ 5 for y in range(1) ] for x in range(11) ]\n    future_right_team = [ [ 5 for y in range(1) ] for x in range(11) ]\n    future_defender_near = [ [ 5 for y in range(1) ] for x in range(11) ]\n    future_defender_close = [ [ 5 for y in range(1) ] for x in range(11) ]\n    future_defender_block_goal = [ [ 5 for y in range(1) ] for x in range(11) ]\n    goal_future_dist_own = [ [ 5 for y in range(1) ] for x in range(11) ]\n    goal_future_dist_opp = [ [ 5 for y in range(1) ] for x in range(11) ]\n    my_future_open_goal_angle = [ [ 5 for y in range(1) ] for x in range(11) ]\n    ball_future_dist = [ [ 5 for y in range(1) ] for x in range(11) ]\n    my_future_angle_goal = [ [ 5 for y in range(1) ] for x in range(11) ]\n    my_future_angle_own = [ [ 5 for y in range(11) ] for x in range(11) ]\n    potential = {}\n    my_dist_opp = {}\n    my_angle_opp = {}\n    def_block_goal_angle = {}\n    my_future_dist_opp = {}\n    my_future_angle_opp = {}\n    future_def_block_goal_angle = {}\n    def get_distance(x1, y1, x2, y2):\n        \"\"\" get two-dimensional Euclidean distance, considering y size of the field \"\"\"\n        return math.sqrt((x1 - x2) ** 2 + (y1 * 2.38 - y2 * 2.38) ** 2)\n    def get_average_distance_to_opponents(obs, player_x, player_y):\n        \"\"\" get average distance to closest opponents \"\"\"\n        distances_sum = 0\n        distances_amount = 0\n        for i in range(1, len(obs[\"right_team\"])):\n            # if opponent is ahead of player\n            if obs[\"right_team\"][i][0] > (player_x - 0.015):\n                distance_to_opponent = get_distance(player_x, player_y, obs[\"right_team\"][i][0], obs[\"right_team\"][i][1])\n                if distance_to_opponent < 0.1:\n                    distances_sum += distance_to_opponent\n                    distances_amount += 1\n        # if there is no opponents close around\n        if distances_amount == 0:\n            return 100, distances_amount\n        return distances_sum*10000 \/\/ (distances_amount*10), distances_amount\n\n    # Evaluate euclidian distance between two objects\n    def uncalibrated_get_distance(pos1,pos2):\n        return (get_distance(pos1[0],pos1[1],pos2[0],pos2[1]))    # Evaluate euclidian distance between two objects\n    # Evaluate angle between two objects\n    def get_angle(pos1,pos2):\n        return math.degrees(math.atan2(pos2[1]-pos1[1], pos2[0]-pos1[0]))\n    def get_direction(pass_angle):\n        action, angle = actual_pass_direction(pass_angle)\n        return action, angle\n    def block_angle_by_dist(dist):\n        if dist < 0.1: return 7\n        elif dist < 0.2: return 10\n        elif dist < 0.3: return 15\n        elif dist < 0.4: return 20\n        return 25\n    def angle_adjust(ang):\n        if ang > 180: return ang-360\n        elif ang < -180: return 360+ang\n        else: return ang\n\n    def angle_covered(goal_angle,opp_angle,block_angle):\n        delta = abs(goal_angle-opp_angle)\n        if  delta > 180:\n            delta = 360-delta\n        if delta <= block_angle:\n            return True\n        return False\n    def pos_after_move(pos,dir,mulp):\n        # high dir means high speed so we use high multiplier\n        # because it takes a long time to change to do new thing.\n        # low dir, low multiplier because there's low delay to change.\n        return (pos[0]+dir[0]*mulp,pos[1]+dir[1]*mulp)\n\n    def players_assess(obs):\n        active = obs['active']\n        left_team = obs['left_team']\n        right_team = obs['right_team']\n        for ix in range(11):\n            if (state.debug_distance and ix == active):\n                print(f'Step {3001-steps_left} P{ix} {left_team[ix][0]:.2f},{left_team[ix][1]:.2f}')\n            ball_dist[ix] = get_distance(left_team[ix][0], left_team[ix][1], obs[\"ball\"][0], obs[\"ball\"][1])\n            # Calculate distance to our teammates\n            for jx in range(ix+1,11):\n                dist = get_distance(left_team[ix][0], left_team[ix][1], left_team[jx][0], left_team[jx][1])\n                my_dist_own[ix][jx] = my_dist_own[jx][ix] = dist\n            # Calculate angle to our teammates\n            for jx in range(11):\n                if ix == jx: continue\n                angle = get_angle(left_team[ix], left_team[jx])\n                my_angle_own[ix][jx] = angle\n                if (state.debug_distance and ix == active and my_dist_own[ix][jx] < 0.2):\n                    print(f' P{jx} D:{my_dist_own[ix][jx]:.2f} A:{angle:.2f}')\n            # Calculate distance and angle to our opponents\n            opp_dist = {}\n            opp_angle = {}\n            for jx in range(11):\n                dist = get_distance(left_team[ix][0], left_team[ix][1], right_team[jx][0], right_team[jx][1])\n                opp_dist[jx] = dist\n                def_dist[jx][ix] = dist\n                angle = get_angle(left_team[ix], right_team[jx])\n                opp_angle[jx] = angle\n                def_angle[jx][ix] = 180+angle if angle < 0 else angle-180\n                if state.debug_distance and ix == active and dist < 0.2:\n                    print(f' OP{jx} {right_team[jx][0]:.2f},{right_team[jx][1]:.2f} D:{dist:.2f} A:{angle:.2f}')\n            my_dist_opp[ix] = opp_dist\n            my_angle_opp[ix] = opp_angle\n            my_angle_goal[ix] = get_angle(left_team[ix], (1,0))\n\n        # Calculate current defender near and close.\n        for ix in range(11):\n            dist, amount = get_average_distance_to_opponents(obs,left_team[ix][0],left_team[ix][1])\n            avg_dist_opp[ix] = dist\/1000\n            defender_near[ix] = defender_close[ix] = 0\n            goal_angle = my_angle_goal[ix]\n            def_block_goal = {}\n            def_block_pass = {}\n            for jx in range(11):\n                if obs['right_team_active'][jx] is False:\n                    continue\n                if my_dist_opp[ix][jx] <= 0.015*5:\n                    defender_near[ix] += 1\n                    if my_dist_opp[ix][jx] <= 0.015*2.5:\n                        defender_close[ix] += 1\n                opp_angle = my_angle_opp[active][jx]\n                block_angle = block_angle_by_dist(my_dist_opp[active][jx])\n                if angle_covered(goal_angle,opp_angle,block_angle):\n                    def_block_goal[jx] = opp_angle\n                if active != ix and my_dist_own[active][ix] >= my_dist_opp[active][jx]:\n                    pass_angle = my_angle_own[active][ix]\n                    if angle_covered(pass_angle,opp_angle,block_angle):\n                        def_block_pass[jx] = opp_angle\n            def_block_goal_angle[ix] = def_block_goal\n            defender_block_goal[ix] = len(def_block_goal_angle[ix])\n            def_block_pass_angle[active][ix] = def_block_pass\n            defender_block_pass[active][ix] = len(def_block_pass_angle[active][ix])\n            if state.debug_distance and (defender_near[ix] == 0 or defender_close[ix] == 0 or defender_block_pass[active][ix] == 0 or ix == active):\n                print(f' D:A:N:C:B {ix} {my_dist_own[active][ix]:.3f}:{avg_dist_opp[ix]:.3f}:{defender_near[ix]}:{defender_close[ix]}:{defender_block_pass[active][ix]}')\n\n        for ix in range(11):\n            # Calculate our player's potential\n            potential[ix] = left_team[ix][0]-abs(left_team[ix][1])+avg_dist_opp[ix]-(my_dist_own[active][ix]\/2.5)\n\n    # Estimate landing position\n    def ball_landing_pos(obs):\n        start_height = obs['ball'][2]\n        end_height = 0.2\n        start_speed = obs['ball_direction'][2]\n        gravity = 0.1\n        time = (start_speed**2\/gravity**2 - 2\/gravity*(end_height-start_height))**0.5 + start_speed\/gravity\n        ex = obs['ball'][0]+obs['ball_direction'][0]*time\n        ey = obs['ball'][1]+obs['ball_direction'][1]*time\n        if state.debug_offense:\n            print(f'ball_landing_pos: Time {time:.2f} loc {ex:.3f},{ey:.3f}')\n        return (ex,ey), time\n\n    def ball_intercept_pos(obs):\n        active = obs['active']\n        va = obs['left_team_direction'][active]\n        loca = obs['left_team'][active]\n        vb = obs['ball_direction']\n        locb = obs['ball']\n        dvx = vb[0]-va[0]\n        dvy = vb[1]-va[1]\n        tx = ty = 0\n        if dvx != 0:\n            tx = (loca[0]-locb[0])\/dvx\n        if dvy != 0:\n            ty = (loca[1]-locb[1])\/dvy\n        if dvx == 0 and dvy == 0:\n            return (locb[0],locb[1]), 10\n        time = min(abs(tx),abs(ty))\n        ex = locb[0]+vb[0]*time\n        ey = locb[1]+vb[1]*time\n        if state.debug_offense:\n            print(f'Ball_intercept_pos: Time {time:.2f} x:{tx:.2f} t:{ty:.2f} loc {ex:.3f},{ey:.3f}')\n        return (ex,ey), time\n\n    # Estimate ball movement to intercept\n    def estimate_ball_pos(obs):\n        if obs['ball'][2] > 0.3:\n            loc, time = ball_landing_pos(obs)\n        else:\n            loc, time = ball_intercept_pos(obs)\n        return loc, time\n\n    def find_evade_dir(obs, player_x, player_y):\n        biggest_distance = 0\n        left, left_opponents_amount = get_average_distance_to_opponents(obs, player_x - 0.01, player_y)\n        right, right_opponents_amount = get_average_distance_to_opponents(obs, player_x + 0.01, player_y)\n        top_right, tr_opponents_amount = get_average_distance_to_opponents(obs, player_x + 0.01, player_y - 0.01)\n        top_left, tl_opponents_amount = get_average_distance_to_opponents(obs, player_x - 0.01, player_y - 0.01)\n        top, t_opponents_amount = get_average_distance_to_opponents(obs, player_x, player_y - 0.01)\n        if player_y <= -0.32:\n            top_right = top_left = top = 0\n        bottom_right, br_opponents_amount = get_average_distance_to_opponents(obs, player_x + 0.01, player_y + 0.01)\n        bottom_left, bl_opponents_amount = get_average_distance_to_opponents(obs, player_x - 0.01, player_y + 0.01)\n        bottom, b_opponents_amount = get_average_distance_to_opponents(obs, player_x, player_y + 0.01)\n        if player_y >= 0.32:\n            bottom_right = bottom_left = bottom = 0\n        if player_x <= -0.7 and player_y >= -0.2:\n            bottom_left = left = 0\n        if player_x <= -0.7 and player_y <= 0.2:\n            top_left = left = 0\n        if player_x <= -0.85:\n            top_left = bottom_left = left = 0\n        if player_x > 0.93:\n            top_left = top_right = right = 0\n        biggest_distance = max(left, right, top_right, top_left, top, bottom_right, bottom_left, bottom)\n        action = Action.Right\n        if (biggest_distance == right or right == 100):\n            # Right is best or clear and already in the center or wing\n            action = Action.Right\n        elif (biggest_distance == top_right or top_right == 100):\n            action = Action.TopRight\n        elif (biggest_distance == bottom_right or bottom_right == 100):\n            action = Action.BottomRight\n        elif (biggest_distance == top or top == 100):\n            action = Action.Top\n        elif (biggest_distance == bottom or bottom == 100):\n            action = Action.Bottom\n        elif (biggest_distance == top_left or top_left == 100):\n            action = Action.TopLeft\n        elif (biggest_distance == bottom_left or bottom_left == 100):\n            action = Action.BottomLeft\n        elif (biggest_distance == left or left == 100):\n            action = Action.Left\n        print(f'Step {ix-1} BL:L:TL {bottom_left}:{left}:{top_left} T:B {top}:{bottom} TR:R:BR {top_right}:{right}:{bottom_right}')\n        return action\n\n    with open(filename, \"r\") as read_file:\n        dev = json.load(read_file)\n        for ix in range(start,stop+1):\n            obs = dev[\"steps\"][ix][0][\"observation\"]['players_raw'][0]\n            oppobs = dev[\"steps\"][ix][1][\"observation\"]['players_raw'][0]\n            left_action = dev[\"steps\"][ix][0][\"action\"][0]\n            right_action = dev[\"steps\"][ix][1][\"action\"][0]\n            active = obs['active']\n            oppactive = oppobs['active']\n            ball_owned_team = obs['ball_owned_team']\n            controlled_player_pos = obs['left_team'][active]\n            opp_player_pos = obs['right_team'][oppactive]\n            dir = obs['left_team_direction'][active]\n            oppdir = obs['right_team_direction'][oppactive]\n            goaliepos = obs['right_team'][0]\n            goaliedir = obs['right_team_direction'][0]\n            ball_dir = obs['ball_direction']\n            ball = obs['ball']\n            next_ball = obs['ball']+ball_dir\n            players_assess(obs)\n            #print(f'obs[{ix}] {obs}')\n            xstep = ystep = 0\n            dx = opp_player_pos[0]-controlled_player_pos[0]\n            dy = opp_player_pos[1]-controlled_player_pos[1]\n            if oppdir[0]-dir[0] != 0:\n                xstep = (opp_player_pos[0]-controlled_player_pos[0])\/(oppdir[0]-dir[0])\n            if oppdir[1]-dir[1] != 0:\n                ystep = (opp_player_pos[1]-controlled_player_pos[1])\/(oppdir[1]-dir[1])\n            ball_land_pos, time = estimate_ball_pos(obs)\n            evade_dir = find_evade_dir(obs, controlled_player_pos[0], controlled_player_pos[1])\n            print(f'Step {ix-1} Bown {ball_owned_team}'\n                  f'\\n We {active} ({controlled_player_pos[0]:.4f},{controlled_player_pos[1]:.4f})'\n                  f' dir:({dir[0]:.4f},{dir[1]:.4f}) C:N {defender_close[active]}:{defender_near[active]} Evade:{evade_dir}'\n                  f'\\n Op {oppactive} ({opp_player_pos[0]:.4f},{opp_player_pos[1]:.4f})'\n                  f' dir:({oppdir[0]:.4f},{oppdir[1]:.4f})'\n                  f'\\n B ({ball[0]:.4f},{ball[1]:.4f},{ball[2]:.4f})'\n                  f' dir:({ball_dir[0]:.4f},{ball_dir[1]:.4f},{ball_dir[2]:.4f})'\n                  f'\\n Exp. B land ({ball_land_pos[0]:.4f},{ball_land_pos[1]:.4f} time {time:.2f})'\n                  f'\\n OpG ({goaliepos[0]:.4f},{goaliepos[1]:.4f})'\n                  f' dir:({goaliedir[0]:.4f},{goaliedir[1]:.4f})')\n            print(f'\\n ATV:B:{ball_dist[active]:.4f} ATV:R:{my_dist_opp[active][oppactive]:.4f}'\n                  f' ATV:G:{my_dist_opp[active][0]:.4f} xs:{xstep:.2f} ys:{ystep:.2f} dx:{dx:.3f} dy:{dy:.3f}')\n            print(f'Step {ix-1} We action {left_action} Op action {right_action}\\n')\n            #num, tgt_loc, tgt_dir = find_threat()\n            #print(f'  Threat {num} Loc:{tgt_loc[0]:.2f},{tgt_loc[1]:.2f} Dir:{tgt_dir[0]:.2f},{tgt_dir[1]:.2f}')\n            '''\n            if ball_owned_team == 0:\n                num, dir = teammate_more_open(active)\n                #print(f'Step {ix-1} pass {num} dir {dir}')\n                if num == 0:\n                    action = dribble(obs)\n                    # print(f'  dribble {action}')\n                sort_potential = sorted(potential.items(), key=lambda item: item[1], reverse=True)\n                #print(f'sort pot: {sort_potential}')\n                #print(f'pot: {potential}')\n                sticky = obs['sticky_actions']\n                #print(f'sticky: {sticky} {Action.Right}')\n            elif ball_owned_team == 1:\n                num,tgt,tgt_dir = find_threat()\n                opp = (opp_player_pos[0]+oppdir[0],opp_player_pos[1]+oppdir[1])\n                if (state.debug_defense):\n                    print(f'Step {ix-1} {active} {oppactive}, opp:{opp_player_pos[0]:.3f},{opp_player_pos[1]:.3f} dir:{oppdir[0]:.3f},{oppdir[1]:.3f} result:{opp[0]:.3f},{opp[1]:.3f}') \n                mark(tgt)\n            '''\n\ncalculate_potential(\"..\/input\/gameplay\/5925837_Hui_vecxoz.json\",1835,1845)","1241aacd":"# *The \"goal\" ;) of this notebook is to popularize, to the extent of my modest abilities, usage of functional programming and readable, scalable architectures.*","0bf8f3d4":"This is my copy of a notebook started by [Yegor Biryukov](https:\/\/www.kaggle.com\/yegorbiryukov\/gfootball-with-memory-patterns) with the deterministic script from [Raffaele Morganti](https:\/\/www.kaggle.com\/raffaelemorganti\/rule-based-way). My sincere gratitude to both of them for making my participation in this competition much easier.\n\nThe approach is rule-based and strictly human learning. :) I took the liberty of combining chunks of code from Yegor's notebook into one big chunk for easy execution. Here's the list of enhancements I made.\n\n* Defensive issues:\n1. Limit blind Action.Shot up field to goalie only. The reason for this is I found that trying to boot the ball upfield without looking at whether opponent players might be blocking is dangerous so I limit it to goalie who mostly has enough room in front of him to clear.\n2. For other players, I try to evade the chasing opponents before trying to pass while avoiding going into my own penalty box.\n3. Sliding is essential but doing it wildly can get your player sent off so I chose to slide only when the player is near both the ball and the opponent player for two steps. This is all trial-and-error.\n4. High ball overhead beyond our last defender leads to many goals so I handle this situation as a special case. The last defender does not chase the ball but chase the highest opponent player instead. This works reasonably well but not foolproof for the case of two-on-two and the ball is going to the second-highest attacker instead of the highest one. I try to fix it only to make it worse so I gave up.\n\n* Offensive issues:\n1. I notice that quick passing and shooting without taking possession of the ball is the way top players score so I mimic it by calculating whether the active player is going to be the first to the ball. If so, issue the pass or shot command before the ball arrives. This is not without a downside in that if the player turns out not to be first to the ball, he can stray too far from the opponent to impede him going for goal. Another sticky point is the fact that passing command is delayed. If the player turns the wrong direction after taking possession of the ball, i.e. facing toward our own goal, it can result in an own goal. So, I made quick passing and shooting sticky by repeating it. This is risky so I try to delay making this quick pass\/shoot decision as late as possible before the ball reaches the player.\n2. When trying to dribble past defenders, I adjust the constant so we don't look at defenders that is a little bit far behind us. This improves the score quite a bit.\n\nOverall, I'm happy with the result. I think I achieve rank 31st only because I had many submissions with different tuning parameters. What I thought was a good change turn out not to be that good in the end. The randomness of game results results in misleading LB score makes tuning difficult. I wish I have implemented a local LB but it might not help much because of the lack of variety in agents.","9467f091":"# Explanation of The Architecture\n* In <code><b>agent<\/b><\/code> function data of the current environment is modified and <code><b>get_action_of_agent<\/b><\/code> function is called to get the action that will be returned.\n* In <code><b>get_action_of_agent<\/b><\/code> function list of memory patterns is provided by <code><b>find_patterns<\/b><\/code> function, then action of the first memory pattern in that list, whose constraints are met by current environment, is returned.\n* All Groups of Memory Patterns and all Memory Patterns are just functions that are taking the same arguments: <code><b>obs, player_x, player_y<\/b><\/code> and return a dictionary with at least two functions.\n* First function in that dictionary for both Groups of Memory Patterns and Memory Patterns is <code><b>environment_fits<\/b><\/code>, it returns True or False, in case constraints described in this function are met by current environment or not. If this function returns True, than the Group of Memory Patterns or Memory Pattern it belongs to is selected for future processing. If this function returns False, than search for appropriate Group of Memory Patterns or Memory Pattern continues.\n* Second function is called only when this Group of Memory Patterns or Memory Pattern was selected for future processing. In any Group of Memory Patterns the second function is <code><b>get_memory_patterns<\/b><\/code> that return list of memory patterns. In any Memory Pattern the second function is <code><b>get_action<\/b><\/code> that return action of the memory pattern it belongs to.\n* In all Groups of Memory Patterns and all Memory Patterns functions <code><b>environment_fits<\/b><\/code>, <code><b>get_memory_patterns<\/b><\/code> and <code><b>get_action<\/b><\/code> take <code><b>obs, player_x, player_y<\/b><\/code> as arguments."}}