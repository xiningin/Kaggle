{"cell_type":{"67a33790":"code","d9804471":"code","d52540c7":"code","b401b913":"code","3a696beb":"code","613dfdef":"code","1ea16a05":"code","c255f0ef":"code","1c9f5eaa":"code","6ecae856":"code","e6298996":"markdown","02be7893":"markdown","20994c21":"markdown","9c8a527e":"markdown","36639441":"markdown","20ea05a3":"markdown","44a5f925":"markdown","889db24b":"markdown","baf02860":"markdown","12916d93":"markdown","3391e022":"markdown","52ecfe35":"markdown","b567a98c":"markdown","c1625b48":"markdown","d171c5cb":"markdown"},"source":{"67a33790":"#Basic libraries\nimport numpy as np\nimport pandas as pd\n\n#EDA: \nimport seaborn as sns\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.offline as py\nimport plotly.tools as tls\nfrom plotly.offline import init_notebook_mode\n## Wordclouds\nimport altair as alt\nfrom  altair.vega import v5\nfrom IPython.display import HTML\nimport json\n\n#Basic Preprocessing\nfrom collections import defaultdict, Counter\n\n#Question-Answering\nfrom transformers import AutoModelForQuestionAnswering, AutoTokenizer, pipeline","d9804471":"df = pd.read_csv('..\/input\/chaii-hindi-and-tamil-question-answering\/train.csv')","d52540c7":"# Defining functions for visualizations: \n\ndef pie_plot(labels, values, colors, title):\n    fig = {\n      \"data\": [\n        {\n          \"values\": values,\n          \"labels\": labels,\n          \"domain\": {\"x\": [0, .48]},\n          \"name\": \"Job Type\",\n          \"sort\": False,\n          \"marker\": {'colors': colors},\n          \"textinfo\":\"percent+label\",\n          \"textfont\": {'color': '#FFFFFF', 'size': 10},\n          \"hole\": .6,\n          \"type\": \"pie\"\n        } ],\n        \"layout\": {\n            \"title\":title,\n            \"annotations\": [\n                {\n                    \"font\": {\n                        \"size\": 25,\n\n                    },\n                    \"showarrow\": False,\n                    \"text\": \"\"\n\n                }\n            ]\n        }\n    }\n    return fig","b401b913":"##-----------------------------------------------------------\n# This whole section \nvega_url = 'https:\/\/cdn.jsdelivr.net\/npm\/vega@' + v5.SCHEMA_VERSION\nvega_lib_url = 'https:\/\/cdn.jsdelivr.net\/npm\/vega-lib'\nvega_lite_url = 'https:\/\/cdn.jsdelivr.net\/npm\/vega-lite@' + alt.SCHEMA_VERSION\nvega_embed_url = 'https:\/\/cdn.jsdelivr.net\/npm\/vega-embed@3'\nnoext = \"?noext\"\n\npaths = {\n    'vega': vega_url + noext,\n    'vega-lib': vega_lib_url + noext,\n    'vega-lite': vega_lite_url + noext,\n    'vega-embed': vega_embed_url + noext\n}\n\nworkaround = \"\"\"\nrequirejs.config({{\n    baseUrl: 'https:\/\/cdn.jsdelivr.net\/npm\/',\n    paths: {}\n}});\n\"\"\"\n\n#------------------------------------------------ Defs for future rendering\ndef add_autoincrement(render_func):\n    # Keep track of unique <div\/> IDs\n    cache = {}\n    def wrapped(chart, id=\"vega-chart\", autoincrement=True):\n        if autoincrement:\n            if id in cache:\n                counter = 1 + cache[id]\n                cache[id] = counter\n            else:\n                cache[id] = 0\n            actual_id = id if cache[id] == 0 else id + '-' + str(cache[id])\n        else:\n            if id not in cache:\n                cache[id] = 0\n            actual_id = id\n        return render_func(chart, id=actual_id)\n    # Cache will stay outside and \n    return wrapped\n            \n@add_autoincrement\ndef render(chart, id=\"vega-chart\"):\n    chart_str = \"\"\"\n    <div id=\"{id}\"><\/div><script>\n    require([\"vega-embed\"], function(vg_embed) {{\n        const spec = {chart};     \n        vg_embed(\"#{id}\", spec, {{defaultStyle: true}}).catch(console.warn);\n        console.log(\"works?\");\n    }});\n    console.log(\"recheck to see if it works?\");\n    <\/script>\n    \"\"\"\n    return HTML(\n        chart_str.format(\n            id=id,\n            chart=json.dumps(chart) if isinstance(chart, dict) else chart.to_json(indent=None)\n        )\n    )\n\n\n\nHTML(\"\".join((\n    \"<script>\",\n    workaround.format(json.dumps(paths)),\n    \"<\/script>\")))","3a696beb":"# Wordcloud function\n\n\ndef word_cloud(df, pixwidth=6000, pixheight=350, column=\"index\", counts=\"count\"):\n    data= [dict(name=\"dataset\", values=df.to_dict(orient=\"records\"))]\n    wordcloud = {\n        \"$schema\": \"https:\/\/vega.github.io\/schema\/vega\/v5.json\",\n        \"width\": pixwidth,\n        \"height\": pixheight,\n        \"padding\": 0,\n        \"title\": \"Hover to see number of occureances from all the sequences\",\n        \"data\": data\n    }\n    scale = dict(\n        name=\"color\",\n        type=\"ordinal\",\n        range=[\"cadetblue\", \"royalblue\", \"steelblue\", \"navy\", \"teal\"]\n    )\n    mark = {\n        \"type\":\"text\",\n        \"from\":dict(data=\"dataset\"),\n        \"encode\":dict(\n            enter=dict(\n                text=dict(field=column),\n                align=dict(value=\"center\"),\n                baseline=dict(value=\"alphabetic\"),\n                fill=dict(scale=\"color\", field=column),\n                tooltip=dict(signal=\"datum.count + ' occurrances'\")\n            )\n        ),\n        \"transform\": [{\n            \"type\": \"wordcloud\",\n            \"text\": dict(field=column),\n            \"size\": [pixwidth, pixheight],\n            \"font\": \"Helvetica Neue, Arial\",\n            \"fontSize\": dict(field=\"datum.{}\".format(counts)),\n            \"fontSizeRange\": [10, 60],\n            \"padding\": 2\n        }]\n    }\n    wordcloud[\"scales\"] = [scale]\n    wordcloud[\"marks\"] = [mark]\n    \n    return wordcloud\n\n\n\ndef wordcloud_create(df, field):\n    ult = {}\n    corpus = df[field].values.tolist()\n    final = defaultdict(int) #Declaring an empty dictionary for count (Saves ram usage)\n    for words in corpus:\n        for word in words.split():\n             final[word]+=1\n    temp = Counter(final)\n    for k, v in  temp.most_common(300):\n        ult[k] = v\n    corpus = pd.Series(ult) #Creating a dataframe from the final default dict\n    return render(word_cloud(corpus.to_frame(name=\"count\").reset_index(), pixheight=600, pixwidth=900))","613dfdef":"df.head()","1ea16a05":"value_counts = df['language'].value_counts()\nlabels = value_counts.index.tolist()\npy.iplot(pie_plot(labels, value_counts, ['#1B9E77', '#D95F02'], \"Language breakdown\"))","c255f0ef":"hindi_df = df[df['language']=='hindi']\nwordcloud_create(hindi_df, 'context')","1c9f5eaa":"hindi_df = df[df['language']=='hindi']\nwordcloud_create(hindi_df, 'question')","6ecae856":"hindi_df = df[df['language']=='hindi']\nwordcloud_create(hindi_df, 'answer_text')","e6298996":"From the columns, we can observe the following columns: \n- **id**: The unique id for that particular row. \n- **context**: The text in hindi\/tamil from which the answer needs to be derived. \n- **question**: The question in the respective language\n- **answer_text**: This is the text which signifies the answer. We are trying to predict this for the test set. As this is a text based competition, we will be using jaccard score to evaluate how closely related to the true answer it was. \n- **answer_start**: The starting character index in the context from where the answer begins. \n- **language**: The language of the context and question. ","02be7893":"**Alongside punctuations, question words are present as well.**","20994c21":"# Contents: \n1. [Importing Libraries and Data](#1) \n    1. [Necessary Functions](#necessary_functions)\n3. [Understanding Data](#2)\n3. [Exploratory Data Analysis](#3)\n    1. [What is the number of tamil and hindi rows in the database?](#4) \n    2. [What are the most prevelant words for Hindi?](#5)\n    3. [What are the most prevelant questions words for Hindi?](#6)\n    4. [What are the most prevelant answers for Hindi](#7)","9c8a527e":"**Now, its apparent proper nouns are most likely to be present in answers than any other parts of speech.\nUnits of measurement ( months, numbers etc) also find place in answers.**","36639441":"As I know hindi, I can look at the above wordcloud and figure out that: \n- The most common words, like English, are the stop words. \n- Punctuation is present for hindi dataset too, such as: , | ? - \n\n\nBased on these, we can formulate a plan for the next steps. \nLet's draw the same for Tamil and see if something can be inferred. ","20ea05a3":"### [Necessary Functions]()<a id=\"necessary_functions\"><\/a> <br>","44a5f925":"Credits: https:\/\/www.kaggle.com\/hoshi7\/chaii-the-beginning-eda-wordclouds by @hoshi7\nThis work is an extension of the work above. \nPlease upvote the original notebook if you find this useful.\nThanks","889db24b":"#### [What are the most prevelant words for Hindi?]()<a id=\"5\"><\/a> <br>","baf02860":"#### [What are the most prevelant question words for Hindi?]()<a id=\"6\"><\/a> <br>","12916d93":"As I know hindi, I can look at the above wordcloud and figure out that:\n\nThe most common words, like English, are the stop words.\n**Punctuation is present for hindi dataset too, such as: , | ? -**","3391e022":"#### [What is the number of tamil and hindi questions in the dataset?]()<a id=\"4\"><\/a> <br>","52ecfe35":"## [Importing Libraries and Data]()<a id=\"1\"><\/a> <br>\n","b567a98c":"## [Exploratory Data Analysis]()<a id=\"3\"><\/a> <br>","c1625b48":"## [Understanding Data]()<a id=\"2\"><\/a> <br>\n","d171c5cb":"#### [What are the most prevelant answers for Hindi?]()<a id=\"7\"><\/a> <br>"}}