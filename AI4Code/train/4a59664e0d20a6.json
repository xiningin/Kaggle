{"cell_type":{"1928899f":"code","745c0da8":"code","407f7e70":"code","b229e1c1":"code","91841ac8":"code","2935728f":"code","8da2eb88":"code","f28c49c7":"code","d4dc8cfb":"code","4c986852":"code","d16766d3":"code","302b30c9":"code","03385dab":"code","9246e98e":"code","49c0b7fc":"code","0052b72b":"code","1217419b":"code","324e926e":"code","ed6070b0":"markdown","e23101a4":"markdown","6ff24bfa":"markdown","db3bb825":"markdown","e8189fa8":"markdown","71360143":"markdown","cbea90b8":"markdown","e7ce0fae":"markdown","d7b5b942":"markdown","5e754291":"markdown"},"source":{"1928899f":"import mne # MNE is already installed in the kaggle image. pip install is not required.\n\nimport numpy as np \nimport pandas as pd \nimport os\nfrom tqdm import tqdm\nimport glob\nfrom matplotlib import pyplot as plt","745c0da8":"_dfs_list = []\nfor csv_filename in tqdm(glob.glob('..\/input\/Alcoholics\/SMNI_CMI_TRAIN\/*.csv')):\n    _dfs_list.append(pd.read_csv(csv_filename))\ndf = pd.concat(_dfs_list)\ndel(_dfs_list)\ndf = df.drop(['Unnamed: 0'], axis=1)\ndf.head(3)","407f7e70":"# correct the 'sensor position' names\n\nchannel_list = list(set(df['sensor position']))\nchannel_list.sort()\n\nchannel_mapping = {\n    'AFZ':'AFz', \n    'CPZ':'CPz', \n    'CZ':'Cz', \n    'FCZ':'FCz', \n    'FP1':'Fp1',\n    'FP2':'Fp2', \n    'FPZ':'Fpz', \n    'FZ':'Fz', \n    'OZ':'Oz', \n    'POZ':'POz', \n    'PZ':'Pz',\n}\n\nchannel_mapping_full = dict()\n\nfor ch in channel_list:\n    if ch in channel_mapping:\n        channel_mapping_full[ch] = channel_mapping[ch]\n    else:\n        channel_mapping_full[ch] = ch\n\nchannel_list_fixed = [channel_mapping_full[ch] for ch in channel_list]\n        \ndf['sensor position'] = df['sensor position'].map(channel_mapping_full)\ndf.head(3)","b229e1c1":"# transpose the table to make the data extraction easier\n\ntransposed_df_list = []\n\nfor group_df in tqdm(df.groupby(['name', 'trial number', 'matching condition', 'sensor position', 'subject identifier'])):\n    _df = pd.DataFrame(group_df[1]['sensor value']).T\n    _df.columns = [f'sample_{idx}' for idx in range(256)]\n    _df['name'] = group_df[0][0]\n    _df['trial number'] = group_df[0][1]\n    _df['matching condition'] = group_df[0][2]\n    _df['sensor position'] = group_df[0][3]\n    _df['subject identifier'] = group_df[0][4]\n    \n    transposed_df_list.append(_df)\n    \ndf = pd.concat(transposed_df_list)\ndf = df[[*df.columns[-5:],*df.columns[0:-5]]]\ndf = df.reset_index(drop=True)\ndf.head(3)","91841ac8":"def get_record_df(df, name, trial_number, matching_condition, channel_list):\n    df_record = df[df['name'].eq(name) & df['trial number'].eq(trial_number) & df['matching condition'].eq(matching_condition)].set_index(['sensor position']).loc[channel_list]\n    return df_record\n\ndf_record = get_record_df(df, 'co2a0000364', 0, 'S1 obj', channel_list_fixed)\ndf_record","2935728f":"def get_signal_array(df, name, trial_number, matching_condition, channel_list):\n    df_record = get_record_df(df, name, trial_number, matching_condition, channel_list)\n    return df_record.to_numpy()[:, 4:]\n\nsignal_array = get_signal_array(df, 'co2a0000364', 10, 'S1 obj', channel_list_fixed)\nsignal_array.shape","8da2eb88":"plt.title('Signal array as an image (64 x 256)')\nplt.ylabel('Channels (sensor position)');\nplt.xlabel('Sample number');\nplt.imshow(signal_array.astype(int));\nplt.show()\n\nchannels_to_display = ['AF1', 'CP3', 'F1']\nfor channel in channels_to_display:\n    plt.xlabel('Sample number');\n    plt.plot(signal_array[channel_list.index(channel)]);\nplt.legend(channels_to_display);","f28c49c7":"info = mne.create_info(ch_names=channel_list_fixed, sfreq=256, ch_types=['eeg']*64)\nraw = mne.io.RawArray(signal_array, info)\n\nstandard_1020_montage = mne.channels.make_standard_montage('standard_1020');\nraw.drop_channels(['X', 'Y', 'nd'])\nraw.set_montage(standard_1020_montage)","d4dc8cfb":"raw.plot_psd();\nraw.plot_psd(average=True);","4c986852":"raw_filtered = raw.copy().filter(8,30, verbose=False);\nraw_filtered.plot_psd();\nraw_filtered.plot_psd(average=True);","d16766d3":"plt.imshow(raw.get_data())\nplt.show()\nplt.imshow(raw.copy().filter(1,10, verbose=False).get_data());\nplt.show()\nplt.plot(raw.copy().get_data()[40])\nplt.plot(raw.copy().filter(8,30, verbose=False).get_data()[40])","302b30c9":"ica = mne.preprocessing.ICA(random_state=42, n_components=20)\nica.fit(raw.copy().filter(1,None, verbose=False), verbose=False)\nica.plot_components()","03385dab":"def plot_eeg_topomap(signal_array, save_path_animation=None, show_names=False, start_time=0.05, end_time=1, step_size=0.1):\n    # select channel X,Y format\n    montage = mne.channels.make_standard_montage('standard_1020')\n    \n    # remove channels that don't have X,Y positions\n    ch_to_remove = []\n    for ch in channel_list_fixed:\n        if ch not in list(set(montage.ch_names).intersection(channel_list_fixed)):\n            ch_to_remove.append(channel_list_fixed.index(ch))\n    arr = np.delete(signal_array.copy(), ch_to_remove, axis=0)\n    \n    # create info+evoked objects\n    info = mne.create_info(ch_names=list(set(montage.ch_names).intersection(channel_list_fixed)), sfreq=256, ch_types='eeg')\n    evoked = mne.EvokedArray(arr, info)\n    \n    # set channel X,Y positions\n    evoked.set_montage(montage)\n\n    # plot img\n    evoked.plot_topomap(np.arange(start_time, end_time, step_size), ch_type='eeg', time_unit='s', ncols=5, nrows=2, show_names=show_names);","9246e98e":"plot_eeg_topomap(signal_array, show_names=False)","49c0b7fc":"def plot_eeg_topomap_animation(signal_array, save_path_animation, start_time=0.00, end_time=1, step_size=0.01, frame_rate=10):\n    # select channel X,Y format\n    montage = mne.channels.make_standard_montage('standard_1020')\n    \n    # remove channels that don't have X,Y positions\n    ch_to_remove = []\n    for ch in channel_list_fixed:\n        if ch not in list(set(montage.ch_names).intersection(channel_list_fixed)):\n            ch_to_remove.append(channel_list_fixed.index(ch))\n    arr = np.delete(signal_array.copy(), ch_to_remove, axis=0)\n    \n    # create info+evoked objects\n    info = mne.create_info(ch_names=list(set(montage.ch_names).intersection(channel_list_fixed)), sfreq=256, ch_types='eeg')\n    evoked = mne.EvokedArray(arr, info)\n    \n    # set channel X,Y positions\n    evoked.set_montage(montage)\n    \n    # (optional) plot and save animation\n    if save_path_animation:\n        fig, anim = evoked.animate_topomap(times=np.arange(start_time, end_time, step_size), frame_rate=frame_rate, butterfly=True, blit=False, );\n        anim.save(save_path_animation);\n        print('saved to', save_path_animation)","0052b72b":"plot_eeg_topomap_animation(signal_array, '.\/gif.gif')","1217419b":"def plot_eeg_joint_topomap(signal_array, save_path_animation=None, show_names=False, start_time=0.05, end_time=1, step_size=0.1):\n    # select channel X,Y format\n    montage = mne.channels.make_standard_montage('standard_1020')\n    \n    # remove channels that don't have X,Y positions\n    ch_to_remove = []\n    for ch in channel_list_fixed:\n        if ch not in list(set(montage.ch_names).intersection(channel_list_fixed)):\n            ch_to_remove.append(channel_list_fixed.index(ch))\n    arr = np.delete(signal_array.copy(), ch_to_remove, axis=0)\n    \n    # create info+evoked objects\n    info = mne.create_info(ch_names=list(set(montage.ch_names).intersection(channel_list_fixed)), sfreq=256, ch_types='eeg')\n    evoked = mne.EvokedArray(arr, info)\n    \n    # set channel X,Y positions\n    evoked.set_montage(montage)\n\n    # plot img\n    evoked.plot_joint();\n    \nplot_eeg_joint_topomap(signal_array)","324e926e":"#https:\/\/www.youtube.com\/watch?v=wNIaT1UT6rI&list=PLXtvZiGkmNVvPS0N9UNBVkIFe0_0t_Nqt&index=3","ed6070b0":"# MNE Tutorial: Different ways of visualizing an EEG signal\nThis notebook will teach you how to use the MNE library to plot EEG data. ","e23101a4":"# Plot freqs","6ff24bfa":"# Plot a topographic map as an image","db3bb825":"# Displaying raw signal as an image\nYou can use the images for CNN training","e8189fa8":"# Plot a topographic map as an animation","71360143":"# Loading the dataset\nThis dataset comes in separate csv files. We will concat them into a single Pandas DataFrame. ","cbea90b8":"# ICA","e7ce0fae":"# Load signal data to an MNE Raw object\nCreate Info object. input = channel list, data freq, channel types \n\nCreate Raw object. input = the signal array and the Info object\n\nSet Raw object montage. After we attach a montage to the signal, we can display it in a topmap.","d7b5b942":"# Apply filter","5e754291":"![](.\/gif.gif)"}}