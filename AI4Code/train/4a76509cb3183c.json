{"cell_type":{"9a45eabc":"code","4a88725d":"markdown"},"source":{"9a45eabc":"import numpy as np # linear algebra\nimport pandas as pd\npd.set_option(\"display.max_rows\", 101)\nimport os\nprint(os.listdir(\"..\/input\"))\nimport cv2\nimport json\nimport matplotlib.pyplot as plt\n%matplotlib inline\nplt.rcParams[\"font.size\"] = 15\nimport seaborn as sns\nfrom collections import Counter\nfrom PIL import Image\nimport math\nimport seaborn as sns\nfrom collections import defaultdict\nfrom pathlib import Path\nimport cv2\nfrom tqdm import tqdm\n\nfrom skimage.feature import  hog\nfrom skimage import data, exposure\n\ninput_dir = \"..\/input\/\"\n\ntrain_df = pd.read_csv(\"..\/input\/train.csv\")\nsample_df = pd.read_csv(\"..\/input\/sample_submission.csv\")\n\nclass_dict = defaultdict(int)\n\nkind_class_dict = defaultdict(int)\n\nno_defects_num = 0\ndefects_num = 0\n\nfor col in range(0, len(train_df), 4):\n    img_names = [str(i).split(\"_\")[0] for i in train_df.iloc[col:col+4, 0].values]\n    if not (img_names[0] == img_names[1] == img_names[2] == img_names[3]):\n        raise ValueError\n        \n    labels = train_df.iloc[col:col+4, 1]\n    if labels.isna().all():\n        no_defects_num += 1\n    else:\n        defects_num += 1\n    \n    kind_class_dict[sum(labels.isna().values == False)] += 1\n        \n    for idx, label in enumerate(labels.isna().values.tolist()):\n        if label == False:\n            class_dict[idx+1] += 1\n            \n\nprint(\"the number of images with no defects: {}\".format(no_defects_num))\nprint(\"the number of images with defects: {}\".format(defects_num))\n\n\ntrain_size_dict = defaultdict(int)\ntrain_path = Path(\"..\/input\/train_images\/\")\n\nfor img_name in train_path.iterdir():\n    img = Image.open(img_name)\n    train_size_dict[img.size] += 1\n    \ntest_size_dict = defaultdict(int)\ntest_path = Path(\"..\/input\/test_images\/\")\n\nfor img_name in test_path.iterdir():\n    img = Image.open(img_name)\n    test_size_dict[img.size] += 1\n    \npalet = [(249, 192, 12), (0, 185, 241), (114, 0, 218), (249,50,12)]\n\n\ndef name_and_mask(start_idx):\n    col = start_idx\n    img_names = [str(i).split(\"_\")[0] for i in train_df.iloc[col:col+4, 0].values]\n    if not (img_names[0] == img_names[1] == img_names[2] == img_names[3]):\n        raise ValueError\n\n    labels = train_df.iloc[col:col+4, 1]\n    mask = np.zeros((256, 1600, 4), dtype=np.uint8)\n\n    for idx, label in enumerate(labels.values):\n        if label is not np.nan:\n            mask_label = np.zeros(1600*256, dtype=np.uint8)\n            label = label.split(\" \")\n            positions = map(int, label[0::2])\n            length = map(int, label[1::2])\n            for pos, le in zip(positions, length):\n                mask_label[pos:(pos+le)] = 1\n            mask[:, :, idx] = mask_label.reshape(256, 1600, order='F')\n    return img_names[0], mask\n\ndef Show_LBP_and_HOG(col):\n    name, mask = name_and_mask(col)\n    img = cv2.imread(str(train_path \/ name), cv2.IMREAD_GRAYSCALE)\n    \n    lbp = feature.local_binary_pattern(img, 10, 5, method=\"uniform\")\n    \n    fd, hog_image = hog(img, orientations=8, pixels_per_cell=(16, 16),cells_per_block=(1, 1), visualize=True, multichannel=False)\n\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(30, 30), sharex=True, sharey=True)\n\n    ax1.axis('off')\n    ax1.imshow(lbp)\n    ax1.set_title('Local Binary Pattern')\n\n    # Rescale histogram for better display\n    hog_image_rescaled = exposure.rescale_intensity(hog_image, in_range=(0, 10))\n\n    ax2.axis('off')\n    ax2.imshow(hog_image_rescaled, cmap=plt.cm.gray)\n    ax2.set_title('Histogram of Oriented Gradients')\n    plt.show()\n    \n      \n\nidx_no_defect = []\nidx_defect = []\n\nfor col in range(0, len(train_df), 4):\n    img_names = [str(i).split(\"_\")[0] for i in train_df.iloc[col:col+4, 0].values]\n    if not (img_names[0] == img_names[1] == img_names[2] == img_names[3]):\n        raise ValueError\n        \n    labels = train_df.iloc[col:col+4, 1]\n    if labels.isna().all():\n        idx_no_defect.append(col)\n    else: \n          idx_defect.append(col)\n\n                       \n        \nfor idx in idx_no_defect[:3]:\n    Show_LBP_and_HOG(idx)\n    \n\nfor idx in idx_defect[:3]:\n    Show_LBP_and_HOG(idx)\n    \n    \n    \n    \n   ","4a88725d":"Visualizing LBP & HOG features (I used Gldfish kernel to load images : https:\/\/www.kaggle.com\/go1dfish\/clear-mask-visualization-and-simple-eda) . "}}