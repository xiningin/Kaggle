{"cell_type":{"ee5fceff":"code","7e404dce":"code","17ccdb1f":"code","b53d8bc7":"code","9023e914":"code","2e592249":"code","68f2de63":"code","2e4aff3a":"code","539155e8":"code","af669c11":"code","70d7c661":"code","82631bfe":"code","99d32434":"code","60cfc92e":"code","e2215b03":"code","738fcc3c":"code","1dbb5e1b":"code","85da8263":"code","a23c4396":"code","02b1bbf2":"code","ffe1d311":"code","967b044b":"code","1cb637c1":"code","62ec9669":"code","c8a59987":"code","ea0c612b":"code","c72fc147":"code","bea95e68":"code","8dc64420":"code","6027369a":"code","5c24b518":"code","93f8948e":"markdown","08a295a6":"markdown","77887bfc":"markdown","22569f1c":"markdown","be1c7fac":"markdown","65c52eeb":"markdown","20a3773f":"markdown","2cf5dee0":"markdown","312f6dac":"markdown","06fe58a5":"markdown","fc5b24ad":"markdown","5a48a7d9":"markdown","68087271":"markdown","fd50c3d8":"markdown","b4734bc6":"markdown","8b1faada":"markdown","52c233d7":"markdown","614b00fb":"markdown","db5f6625":"markdown","f19e1f65":"markdown","ab26312e":"markdown","53e326a8":"markdown","53873df4":"markdown","24086877":"markdown","d6697c6c":"markdown"},"source":{"ee5fceff":"import os\nimport re\nimport random\nimport time\nfrom tqdm import tqdm\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nimport requests\nimport zipfile\n\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.model_selection import StratifiedKFold, cross_val_score\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.metrics import accuracy_score, roc_curve, auc\nimport nltk\n# Uncomment to download \"stopwords\"\nnltk.download(\"stopwords\")\nfrom nltk.corpus import stopwords\n\nimport torch\nfrom transformers import BertTokenizer\nfrom torch.utils.data import TensorDataset, DataLoader, RandomSampler, SequentialSampler\nimport torch\nimport torch.nn as nn\nfrom transformers import BertModel\nfrom transformers import AdamW, get_linear_schedule_with_warmup\n\n%matplotlib inline\nimport warnings\nwarnings.filterwarnings(\"ignore\")","7e404dce":"# Download data\nrequest = requests.get(\"https:\/\/drive.google.com\/uc?export=download&id=1wHt8PsMLsfX5yNSqrt2fSTcb8LEiclcf\")\nwith open(\"data.zip\", \"wb\") as file:\n    file.write(request.content)\n\n# Unzip data\nwith zipfile.ZipFile('data.zip') as zip:\n    zip.extractall('data')","17ccdb1f":" # Load data and set labels\ndata_complaint = pd.read_csv('data\/complaint1700.csv')\ndata_complaint['label'] = 0\ndata_non_complaint = pd.read_csv('data\/noncomplaint1700.csv')\ndata_non_complaint['label'] = 1\n\n# Concatenate complaining and non-complaining data\ndata = pd.concat([data_complaint, data_non_complaint], axis=0).reset_index(drop=True)\n\n# Drop 'airline' column\ndata.drop(['airline'], inplace=True, axis=1)\n\n# Display 5 random samples\ndata.sample(5)","b53d8bc7":"X = data.tweet.values\ny = data.label.values\n\nX_train, X_val, y_train, y_val =\\\n    train_test_split(X, y, test_size=0.1, random_state=2020)","9023e914":"# Load test data\ntest_data = pd.read_csv('data\/test_data.csv')\n\n# Keep important columns\ntest_data = test_data[['id', 'tweet']]\n\n# Display 5 samples from the test data\ntest_data.sample(5)","2e592249":"if torch.cuda.is_available():\n    device = torch.device(\"cuda\")\n    print(f\"There are {torch.cuda.device_count()} GPU(s) are available.\")\n    print(f\"Device Name {torch.cuda.get_device_name(0)}\")\nelse:\n    print(\"No GPU available. We can use CPU instead\")\n    device = torch.device(\"cpu\")","68f2de63":"def text_preprocessing(s):\n    \"\"\"\n    - Lowercase the sentence\n    - Change \"'t\" to \"not\"\n    - Remove \"@name\"\n    - Isolate and remove punctuations except \"?\"\n    - Remove other special characters\n    - Remove stop words except \"not\" and \"can\"\n    - Remove trailing whitespace\n    \"\"\"\n    s = s.lower()\n    # Change 't to 'not'\n    s = re.sub(r\"\\'t\", \" not\", s)\n    # Remove @name\n    s = re.sub(r'(@.*?)[\\s]', ' ', s)\n    # Isolate and remove punctuations except '?'\n    s = re.sub(r'([\\'\\\"\\.\\(\\)\\!\\?\\\\\\\/\\,])', r' \\1 ', s)\n    s = re.sub(r'[^\\w\\s\\?]', ' ', s)\n    # Remove some special characters\n    s = re.sub(r'([\\;\\:\\|\u2022\u00ab\\n])', ' ', s)\n    # Remove stopwords except 'not' and 'can'\n    s = \" \".join([word for word in s.split()\n                  if word not in stopwords.words('english')\n                  or word in ['not', 'can']])\n    # Remove trailing whitespace\n    s = re.sub(r'\\s+', ' ', s).strip()\n    \n    return s","2e4aff3a":"%%time\n\n# Preprocess text\nX_train_preprocessed = np.array([text_preprocessing(text) for text in X_train])\nX_val_preprocessed = np.array([text_preprocessing(text) for text in X_val])\n\n# Calculate TF-IDF\ntf_idf = TfidfVectorizer(ngram_range=(1, 3),\n                         binary=True,\n                         smooth_idf=False)\nX_train_tfidf = tf_idf.fit_transform(X_train_preprocessed)\nX_val_tfidf = tf_idf.transform(X_val_preprocessed)","539155e8":"def get_auc_CV(model):\n    \"\"\"\n    Return the average AUC score from cross-validation.\n    \"\"\"\n    # Set KFold to shuffle data before the split\n    kf = StratifiedKFold(5, shuffle=True, random_state=1)\n\n    # Get AUC scores\n    auc = cross_val_score(\n        model, X_train_tfidf, y_train, scoring=\"roc_auc\", cv=kf)\n\n    return auc.mean()","af669c11":"res = pd.Series([get_auc_CV(MultinomialNB(i))\n                 for i in np.arange(1, 10, 0.1)],\n                index=np.arange(1, 10, 0.1))\n\nbest_alpha = np.round(res.idxmax(), 2)\nprint('Best alpha: ', best_alpha)\n\nplt.plot(res)\nplt.title('AUC vs. Alpha')\nplt.xlabel('Alpha')\nplt.ylabel('AUC')\nplt.show()","70d7c661":"def evaluate_roc(probs, y_true):\n    \"\"\"\n    - Print AUC and accuracy on the test set\n    - Plot ROC\n    @params    probs (np.array): an array of predicted probabilities with shape (len(y_true), 2)\n    @params    y_true (np.array): an array of the true values with shape (len(y_true),)\n    \"\"\"\n    preds = probs[:, 1]\n    fpr, tpr, threshold = roc_curve(y_true, preds)\n    roc_auc = auc(fpr, tpr)\n    print(f'AUC: {roc_auc:.4f}')\n       \n    # Get accuracy over the test set\n    y_pred = np.where(preds >= 0.5, 1, 0)\n    accuracy = accuracy_score(y_true, y_pred)\n    print(f'Accuracy: {accuracy*100:.2f}%')\n    \n    # Plot ROC AUC\n    plt.title('Receiver Operating Characteristic')\n    plt.plot(fpr, tpr, 'b', label = 'AUC = %0.2f' % roc_auc)\n    plt.legend(loc = 'lower right')\n    plt.plot([0, 1], [0, 1],'r--')\n    plt.xlim([0, 1])\n    plt.ylim([0, 1])\n    plt.ylabel('True Positive Rate')\n    plt.xlabel('False Positive Rate')\n    plt.show()\n","82631bfe":"# Compute predicted probabilities\nnb_model = MultinomialNB(alpha=1.8)\nnb_model.fit(X_train_tfidf, y_train)\nprobs = nb_model.predict_proba(X_val_tfidf)\n\n# Evaluate the classifier\nevaluate_roc(probs, y_val)","99d32434":"## Installing huggingface transformer library\n!pip install transformers","60cfc92e":"def text_preprocessing(text):\n    \"\"\"\n    - Remove entity mentions (eg. '@united')\n    - Correct errors (eg. '&amp;' to '&')\n    @param    text (str): a string to be processed.\n    @return   text (Str): the processed string.\n    \"\"\"\n    # Remove '@name'\n    text = re.sub(r'(@.*?)[\\s]', ' ', text)\n\n    # Replace '&amp;' with '&'\n    text = re.sub(r'&amp;', '&', text)\n\n    # Remove trailing whitespace\n    text = re.sub(r'\\s+', ' ', text).strip()\n\n    return text","e2215b03":"# Print sentence 0\nprint('Original: ', X[0])\nprint('Processed: ', text_preprocessing(X[0]))","738fcc3c":"tokenizer = BertTokenizer.from_pretrained('bert-base-uncased', do_lower_case=True)\n\n# Create a function to tokenize a set of texts\ndef preprocessing_for_bert(data):\n    # Create empty lists to store outputs\n    input_ids = []\n    attention_masks = []\n\n    # For every sentence...\n    for sent in data:\n        encoded_sent = tokenizer.encode_plus(\n            text=text_preprocessing(sent),  # Preprocess sentence\n            add_special_tokens=True,        # Add `[CLS]` and `[SEP]`\n            max_length=MAX_LEN,                  # Max length to truncate\/pad\n            pad_to_max_length=True,         # Pad sentence to max length\n            #return_tensors='pt',           # Return PyTorch tensor\n            return_attention_mask=True      # Return attention mask\n            )\n        \n        # Add the outputs to the lists\n        input_ids.append(encoded_sent.get('input_ids'))\n        attention_masks.append(encoded_sent.get('attention_mask'))\n\n    # Convert lists to tensors\n    input_ids = torch.tensor(input_ids)\n    attention_masks = torch.tensor(attention_masks)\n\n    return input_ids, attention_masks","1dbb5e1b":"# Concatenate train data and test data\nall_tweets = np.concatenate([data.tweet.values, test_data.tweet.values])\n\n# Encode our concatenated data\nencoded_tweets = [tokenizer.encode(sent, add_special_tokens=True) for sent in all_tweets]\n\n# Find the maximum length\nmax_len = max([len(sent) for sent in encoded_tweets])\nprint('Max length: ', max_len)","85da8263":"MAX_LEN = 64\n# Print sentence 0 and its encoded token ids\ntoken_ids = list(preprocessing_for_bert([X[1]])[0].squeeze().numpy())\nprint('Original: ', X[1])\nprint('Token IDs: ', token_ids)\n\n# Run function `preprocessing_for_bert` on the train set and the validation set\nprint('Tokenizing data...')\ntrain_inputs, train_masks = preprocessing_for_bert(X_train)\nval_inputs, val_masks = preprocessing_for_bert(X_val)","a23c4396":"# Convert other data types to torch.Tensor\ntrain_labels = torch.tensor(y_train)\nval_labels = torch.tensor(y_val)\n\n# For fine-tuning BERT, the authors recommend a batch size of 16 or 32.\nbatch_size = 32\n\n# Create the DataLoader for our training set\ntrain_data = TensorDataset(train_inputs, train_masks, train_labels)\ntrain_sampler = RandomSampler(train_data)\ntrain_dataloader = DataLoader(train_data, sampler=train_sampler, batch_size=batch_size)\n\n# Create the DataLoader for our validation set\nval_data = TensorDataset(val_inputs, val_masks, val_labels)\nval_sampler = SequentialSampler(val_data)\nval_dataloader = DataLoader(val_data, sampler=val_sampler, batch_size=batch_size)","02b1bbf2":"%%time\n\n# Create the BertClassfier class\nclass BertClassifier(nn.Module):\n    \"\"\"Bert Model for Classification Tasks.\n    \"\"\"\n    def __init__(self, freeze_bert=False):\n        super(BertClassifier, self).__init__()\n        # Specify hidden size of BERT, hidden size of our classifier, and number of labels\n        D_in, H, D_out = 768, 50, 2\n\n        # Instantiate BERT model\n        self.bert = BertModel.from_pretrained('bert-base-uncased')\n\n        # Instantiate an one-layer feed-forward classifier\n        self.classifier = nn.Sequential(\n            nn.Linear(D_in, H),\n            nn.ReLU(),\n            #nn.Dropout(0.5),\n            nn.Linear(H, D_out)\n        )\n\n        # Freeze the BERT model\n        if freeze_bert:\n            for param in self.bert.parameters():\n                param.requires_grad = False\n        \n    def forward(self, input_ids, attention_mask):\n\n        # Feed input to BERT\n        outputs = self.bert(input_ids=input_ids,\n                            attention_mask=attention_mask)\n        \n        # Extract the last hidden state of the token `[CLS]` for classification task\n        last_hidden_state_cls = outputs[0][:, 0, :]\n\n        # Feed input to classifier to compute logits\n        logits = self.classifier(last_hidden_state_cls)\n\n        return logits","ffe1d311":"def initialize_model(epochs=4):\n    \"\"\"Initialize the Bert Classifier, the optimizer and the learning rate scheduler.\n    \"\"\"\n    # Instantiate Bert Classifier\n    \n    bert_classifier = BertClassifier(freeze_bert=False)\n\n    # Tell PyTorch to run the model on GPU\n    bert_classifier.to(device)\n\n    # Create the optimizer\n    optimizer = AdamW(bert_classifier.parameters(),\n                      lr=5e-5,    # Default learning rate\n                      eps=1e-8    # Default epsilon value\n                      )\n\n    # Total number of training steps\n    total_steps = len(train_dataloader) * epochs\n\n    # Set up the learning rate scheduler\n    scheduler = get_linear_schedule_with_warmup(optimizer,\n                                                num_warmup_steps=0, # Default value\n                                                num_training_steps=total_steps)\n    \n    return bert_classifier, optimizer, scheduler","967b044b":"def set_seed(seed_value=42):\n    \"\"\"Set seed for reproducibility.\n    \"\"\"\n    random.seed(seed_value)\n    np.random.seed(seed_value)\n    torch.manual_seed(seed_value)\n    torch.cuda.manual_seed_all(seed_value)\n    \n# Specify loss function\nloss_fn = nn.CrossEntropyLoss()","1cb637c1":"def train(model, train_dataloader, val_dataloader=None, epochs=4, evaluation=False):\n    \"\"\"Train the BertClassifier model.\n    \"\"\"\n    # Start training loop\n    print(\"Start training...\\n\")\n    for epoch_i in range(epochs):\n        # Print the header of the result table\n        print(f\"{'Epoch':^7} | {'Batch':^7} | {'Train Loss':^12} | {'Val Loss':^10} | {'Val Acc':^9} | {'Elapsed':^9}\")\n        print(\"-\"*70)\n\n        # Measure the elapsed time of each epoch\n        t0_epoch, t0_batch = time.time(), time.time()\n\n        # Reset tracking variables at the beginning of each epoch\n        total_loss, batch_loss, batch_counts = 0, 0, 0\n\n        # Put the model into the training mode\n        model.train()\n\n        # For each batch of training data...\n        for step, batch in enumerate(train_dataloader):\n            batch_counts +=1\n            # Load batch to GPU\n            b_input_ids, b_attn_mask, b_labels = tuple(t.to(device) for t in batch)\n\n            # Zero out any previously calculated gradients\n            model.zero_grad()\n\n            # Perform a forward pass. This will return logits.\n            logits = model(b_input_ids, b_attn_mask)\n\n            # Compute loss and accumulate the loss values\n            loss = loss_fn(logits, b_labels)\n            batch_loss += loss.item()\n            total_loss += loss.item()\n\n            # Perform a backward pass to calculate gradients\n            loss.backward()\n\n            # Clip the norm of the gradients to 1.0 to prevent \"exploding gradients\"\n            torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n\n            # Update parameters and the learning rate\n            optimizer.step()\n            scheduler.step()\n\n            # Print the loss values and time elapsed for every 20 batches\n            if (step % 20 == 0 and step != 0) or (step == len(train_dataloader) - 1):\n                # Calculate time elapsed for 20 batches\n                time_elapsed = time.time() - t0_batch\n\n                # Print training results\n                print(f\"{epoch_i + 1:^7} | {step:^7} | {batch_loss \/ batch_counts:^12.6f} | {'-':^10} | {'-':^9} | {time_elapsed:^9.2f}\")\n\n                # Reset batch tracking variables\n                batch_loss, batch_counts = 0, 0\n                t0_batch = time.time()\n\n        # Calculate the average loss over the entire training data\n        avg_train_loss = total_loss \/ len(train_dataloader)\n\n        print(\"-\"*70)\n        if evaluation == True:\n            # After the completion of each training epoch, measure the model's performance\n            # on our validation set.\n            val_loss, val_accuracy = evaluate(model, val_dataloader)\n\n            # Print performance over the entire training data\n            time_elapsed = time.time() - t0_epoch\n            \n            print(f\"{epoch_i + 1:^7} | {'-':^7} | {avg_train_loss:^12.6f} | {val_loss:^10.6f} | {val_accuracy:^9.2f} | {time_elapsed:^9.2f}\")\n            print(\"-\"*70)\n        print(\"\\n\")\n    \n    print(\"Training complete!\")\n\n\ndef evaluate(model, val_dataloader):\n    # Put the model into the evaluation mode. The dropout layers are disabled during\n    # the test time.\n    model.eval()\n\n    # Tracking variables\n    val_accuracy = []\n    val_loss = []\n\n    # For each batch in our validation set...\n    for batch in val_dataloader:\n        # Load batch to GPU\n        b_input_ids, b_attn_mask, b_labels = tuple(t.to(device) for t in batch)\n\n        # Compute logits\n        with torch.no_grad():\n            logits = model(b_input_ids, b_attn_mask)\n\n        # Compute loss\n        loss = loss_fn(logits, b_labels)\n        val_loss.append(loss.item())\n\n        # Get the predictions\n        preds = torch.argmax(logits, dim=1).flatten()\n\n        # Calculate the accuracy rate\n        accuracy = (preds == b_labels).cpu().numpy().mean() * 100\n        val_accuracy.append(accuracy)\n\n    # Compute the average accuracy and loss over the validation set.\n    val_loss = np.mean(val_loss)\n    val_accuracy = np.mean(val_accuracy)\n\n    return val_loss, val_accuracy","62ec9669":"set_seed(42)    # Set seed for reproducibility\nbert_classifier, optimizer, scheduler = initialize_model(epochs=2)\ntrain(bert_classifier, train_dataloader, val_dataloader, epochs=2, evaluation=True)","c8a59987":"import torch.nn.functional as F\n\ndef bert_predict(model, test_dataloader):\n    \"\"\"Perform a forward pass on the trained BERT model to predict probabilities\n    on the test set.\n    \"\"\"\n    # Put the model into the evaluation mode. The dropout layers are disabled during\n    # the test time.\n    model.eval()\n\n    all_logits = []\n\n    # For each batch in our test set...\n    for batch in test_dataloader:\n        # Load batch to GPU\n        b_input_ids, b_attn_mask = tuple(t.to(device) for t in batch)[:2]\n\n        # Compute logits\n        with torch.no_grad():\n            logits = model(b_input_ids, b_attn_mask)\n        all_logits.append(logits)\n    \n    # Concatenate logits from each batch\n    all_logits = torch.cat(all_logits, dim=0)\n\n    # Apply softmax to calculate probabilities\n    probs = F.softmax(all_logits, dim=1).cpu().numpy()\n\n    return probs","ea0c612b":"# Compute predicted probabilities on the test set\nprobs = bert_predict(bert_classifier, val_dataloader)\n\n# Evaluate the Bert classifier\nevaluate_roc(probs, y_val)","c72fc147":"# Concatenate the train set and the validation set\nfull_train_data = torch.utils.data.ConcatDataset([train_data, val_data])\nfull_train_sampler = RandomSampler(full_train_data)\nfull_train_dataloader = DataLoader(full_train_data, sampler=full_train_sampler, batch_size=32)\n\n# Train the Bert Classifier on the entire training data\nset_seed(42)\nbert_classifier, optimizer, scheduler = initialize_model(epochs=2)\ntrain(bert_classifier, full_train_dataloader, epochs=2)","bea95e68":"test_data.sample(5)","8dc64420":"# Run `preprocessing_for_bert` on the test set\nprint('Tokenizing data...')\ntest_inputs, test_masks = preprocessing_for_bert(test_data.tweet)\n\n# Create the DataLoader for our test set\ntest_dataset = TensorDataset(test_inputs, test_masks)\ntest_sampler = SequentialSampler(test_dataset)\ntest_dataloader = DataLoader(test_dataset, sampler=test_sampler, batch_size=32)","6027369a":"# Compute predicted probabilities on the test set\nprobs = bert_predict(bert_classifier, test_dataloader)\n\n# Get predictions from the probabilities\nthreshold = 0.9\npreds = np.where(probs[:, 1] > threshold, 1, 0)\n\n# Number of tweets predicted non-negative\nprint(\"Number of tweets predicted non-negative: \", preds.sum())","5c24b518":"output = test_data[preds==1]\nlist(output.sample(20).tweet)","93f8948e":"# Creating a Baseline Model With TF-IDF + Naive Bayes Classifier\n\n* TF-IDF is used to vectorize data \n* Naive Bayes as the classifier","08a295a6":"## Classifier BERT Model","77887bfc":"## Training the model on entire training data","22569f1c":"### 2. TF-IDF Vectorizer","be1c7fac":"## Setting up GPU","65c52eeb":"### Setting Seed","20a3773f":"### Tokenization and Preprocessing","2cf5dee0":"## Prediction on test data","312f6dac":"# Step - 1 Initial Setup","06fe58a5":"## Load Test Data","fc5b24ad":"# Fine tuning BERT","5a48a7d9":"## Train Naive Bayes Model","68087271":"## Bert Tokenizer","fd50c3d8":"### Evaluation","b4734bc6":"### Hyper Parameters","8b1faada":"#### Finding the suitable maximumm length","52c233d7":"## Training","614b00fb":"## Downloading dataset","db5f6625":"## Train and Test Split","f19e1f65":"## Predicting Single Tweet","ab26312e":"## Importing Libraries","53e326a8":"## Load Train Data","53873df4":"## Torch Data loader and Dataset for Training ","24086877":"## 2.1 Hyper Parameter Tuning","d6697c6c":"## Data Preparation\n### 1. Preprocessing"}}